{"hash": -1929262071302712016, "project": "debian", "size": 10, "label": 0, "functionSource": "static cmsBool ReadOneMLUC ( struct _cms_typehandler_struct * self , cmsIOHANDLER * io , _cmsDICelem * e , cmsUInt32Number i , cmsMLU * * mlu ) {\n cmsUInt32Number nItems = 0 ;\n if ( e -> Offsets [ i ] == 0 || e -> Sizes [ i ] == 0 ) {\n * mlu = NULL ;\n return TRUE ;\n }\n if ( ! io -> Seek ( io , e -> Offsets [ i ] ) ) return FALSE ;\n * mlu = ( cmsMLU * ) Type_MLU_Read ( self , io , & nItems , e -> Sizes [ i ] ) ;\n return * mlu != NULL ;\n }", "idx": 0}
{"hash": 1891617106617090004, "project": "chrome", "size": 58, "label": 0, "functionSource": "static void U_CALLCONV T_UConverter_toUnicode_UTF32_LE ( UConverterToUnicodeArgs * args , UErrorCode * err ) {\n const unsigned char * mySource = ( unsigned char * ) args -> source ;\n UChar * myTarget = args -> target ;\n const unsigned char * sourceLimit = ( unsigned char * ) args -> sourceLimit ;\n const UChar * targetLimit = args -> targetLimit ;\n unsigned char * toUBytes = args -> converter -> toUBytes ;\n uint32_t ch , i ;\n if ( args -> converter -> toUnicodeStatus && myTarget < targetLimit ) {\n i = args -> converter -> toULength ;\n args -> converter -> toULength = 0 ;\n ch = args -> converter -> toUnicodeStatus - 1 ;\n args -> converter -> toUnicodeStatus = 0 ;\n goto morebytes ;\n }\n while ( mySource < sourceLimit && myTarget < targetLimit ) {\n i = 0 ;\n ch = 0 ;\n morebytes : while ( i < sizeof ( uint32_t ) ) {\n if ( mySource < sourceLimit ) {\n ch |= ( ( uint8_t ) ( * mySource ) ) << ( i * 8 ) ;\n toUBytes [ i ++ ] = ( char ) * ( mySource ++ ) ;\n }\n else {\n args -> converter -> toUnicodeStatus = ch + 1 ;\n args -> converter -> toULength = ( int8_t ) i ;\n goto donefornow ;\n }\n }\n if ( ch <= MAXIMUM_UTF && ! U_IS_SURROGATE ( ch ) ) {\n if ( ch <= MAXIMUM_UCS2 ) {\n * ( myTarget ++ ) = ( UChar ) ch ;\n }\n else {\n * ( myTarget ++ ) = U16_LEAD ( ch ) ;\n ch = U16_TRAIL ( ch ) ;\n if ( myTarget < targetLimit ) {\n * ( myTarget ++ ) = ( UChar ) ch ;\n }\n else {\n args -> converter -> UCharErrorBuffer [ 0 ] = ( UChar ) ch ;\n args -> converter -> UCharErrorBufferLength = 1 ;\n * err = U_BUFFER_OVERFLOW_ERROR ;\n break ;\n }\n }\n }\n else {\n args -> converter -> toULength = ( int8_t ) i ;\n * err = U_ILLEGAL_CHAR_FOUND ;\n break ;\n }\n }\n donefornow : if ( mySource < sourceLimit && myTarget >= targetLimit && U_SUCCESS ( * err ) ) {\n * err = U_BUFFER_OVERFLOW_ERROR ;\n }\n args -> target = myTarget ;\n args -> source = ( const char * ) mySource ;\n }", "idx": 1}
{"hash": 7039307292471244756, "project": "debian", "size": 15, "label": 0, "functionSource": "static guint16 de_tp_epc_ellipsoid_point_with_alt ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len _U_ , gchar * add_string _U_ , int string_len _U_ ) {\n guint32 curr_offset ;\n guint32 longitude ;\n curr_offset = offset ;\n proto_tree_add_bits_item ( tree , hf_gsm_a_dtap_epc_latitude_sign , tvb , curr_offset << 3 , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_bits_item ( tree , hf_gsm_a_dtap_epc_degrees_latitude , tvb , ( curr_offset << 3 ) + 1 , 23 , ENC_BIG_ENDIAN ) ;\n curr_offset += 3 ;\n longitude = tvb_get_ntoh24 ( tvb , curr_offset ) ;\n proto_tree_add_int_format ( tree , hf_gsm_a_dtap_epc_degrees_longitude , tvb , curr_offset , 3 , longitude , \"%s = %s: %d\" , decode_bits_in_field ( curr_offset << 3 , 24 , longitude ) , proto_registrar_get_name ( hf_gsm_a_dtap_epc_degrees_longitude ) , longitude - 8388608 ) ;\n curr_offset += 3 ;\n proto_tree_add_bits_item ( tree , hf_gsm_a_dtap_epc_altitude_dir , tvb , curr_offset << 3 , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_bits_item ( tree , hf_gsm_a_dtap_epc_altitude , tvb , ( curr_offset << 3 ) + 1 , 15 , ENC_BIG_ENDIAN ) ;\n curr_offset += 2 ;\n return ( curr_offset - offset ) ;\n }", "idx": 2}
{"hash": 927123821003322045, "project": "chrome", "size": 13, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( PageLoadMetricsBrowserTest , UseCounterAnimatedCSSPropertiesMixedContent ) {\n net : : EmbeddedTestServer https_server ( net : : EmbeddedTestServer : : TYPE_HTTPS ) ;\n https_server . AddDefaultHandlers ( base : : FilePath ( FILE_PATH_LITERAL ( \"chrome/test/data\" ) ) ) ;\n ASSERT_TRUE ( https_server . Start ( ) ) ;\n auto waiter = CreatePageLoadMetricsWaiter ( ) ;\n waiter -> AddPageExpectation ( TimingField : : LOAD_EVENT ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , https_server . GetURL ( \"/page_load_metrics/use_counter_features.html\" ) ) ;\n waiter -> Wait ( ) ;\n NavigateToUntrackedUrl ( ) ;\n histogram_tester_ . ExpectBucketCount ( internal : : kAnimatedCssPropertiesHistogramName , 161 , 1 ) ;\n histogram_tester_ . ExpectBucketCount ( internal : : kAnimatedCssPropertiesHistogramName , 91 , 1 ) ;\n histogram_tester_ . ExpectBucketCount ( internal : : kAnimatedCssPropertiesHistogramName , blink : : mojom : : kTotalPagesMeasuredCSSSampleId , 1 ) ;\n }", "idx": 3}
{"hash": 1245821301839614810, "project": "debian", "size": 14, "label": 0, "functionSource": "static gboolean fat_str_replace ( char * str , char replacement ) {\n gboolean success ;\n int i ;\n success = FALSE ;\n for ( i = 0 ;\n str [ i ] != '\\0' ;\n i ++ ) {\n if ( strchr ( FAT_FORBIDDEN_CHARACTERS , str [ i ] ) || str [ i ] < 32 ) {\n success = TRUE ;\n str [ i ] = replacement ;\n }\n }\n return success ;\n }", "idx": 4}
{"hash": -7422764464424760982, "project": "chrome", "size": 18, "label": 0, "functionSource": "TEST_F ( ExtensionServiceSyncTest , DisableExtensionFromSync ) {\n base : : FilePath source_install_dir = data_dir ( ) . AppendASCII ( \"good\" ) . AppendASCII ( \"Extensions\" ) ;\n base : : FilePath pref_path = source_install_dir . DirName ( ) . Append ( chrome : : kPreferencesFilename ) ;\n InitializeInstalledExtensionService ( pref_path , source_install_dir ) ;\n browser_sync : : ProfileSyncService * sync_service = ProfileSyncServiceFactory : : GetForProfile ( profile ( ) ) ;\n sync_service -> SetFirstSetupComplete ( ) ;\n service ( ) -> Init ( ) ;\n ASSERT_TRUE ( service ( ) -> is_ready ( ) ) ;\n ASSERT_EQ ( 3u , loaded_ . size ( ) ) ;\n const Extension * extension = service ( ) -> GetExtensionById ( good0 , true ) ;\n ASSERT_TRUE ( extension ) ;\n ASSERT_TRUE ( service ( ) -> IsExtensionEnabled ( good0 ) ) ;\n extension_sync_service ( ) -> MergeDataAndStartSyncing ( syncer : : EXTENSIONS , syncer : : SyncDataList ( ) , base : : MakeUnique < syncer : : FakeSyncChangeProcessor > ( ) , base : : MakeUnique < syncer : : SyncErrorFactoryMock > ( ) ) ;\n ExtensionSyncData disable_good_crx ( * extension , false , extensions : : disable_reason : : DISABLE_USER_ACTION , false , false , ExtensionSyncData : : BOOLEAN_UNSET , false ) ;\n SyncChangeList list ( 1 , disable_good_crx . GetSyncChange ( SyncChange : : ACTION_UPDATE ) ) ;\n extension_sync_service ( ) -> ProcessSyncChanges ( FROM_HERE , list ) ;\n ASSERT_FALSE ( service ( ) -> IsExtensionEnabled ( good0 ) ) ;\n }", "idx": 5}
{"hash": -1283648210945038844, "project": "chrome", "size": 153, "label": 0, "functionSource": "void vp9_fdct16x16_c ( const int16_t * input , tran_low_t * output , int stride ) {\n int pass ;\n tran_low_t intermediate [ 256 ] ;\n const int16_t * in_pass0 = input ;\n const tran_low_t * in = NULL ;\n tran_low_t * out = intermediate ;\n for ( pass = 0 ;\n pass < 2 ;\n ++ pass ) {\n tran_high_t step1 [ 8 ] ;\n tran_high_t step2 [ 8 ] ;\n tran_high_t step3 [ 8 ] ;\n tran_high_t input [ 8 ] ;\n tran_high_t temp1 , temp2 ;\n int i ;\n for ( i = 0 ;\n i < 16 ;\n i ++ ) {\n if ( 0 == pass ) {\n input [ 0 ] = ( in_pass0 [ 0 * stride ] + in_pass0 [ 15 * stride ] ) * 4 ;\n input [ 1 ] = ( in_pass0 [ 1 * stride ] + in_pass0 [ 14 * stride ] ) * 4 ;\n input [ 2 ] = ( in_pass0 [ 2 * stride ] + in_pass0 [ 13 * stride ] ) * 4 ;\n input [ 3 ] = ( in_pass0 [ 3 * stride ] + in_pass0 [ 12 * stride ] ) * 4 ;\n input [ 4 ] = ( in_pass0 [ 4 * stride ] + in_pass0 [ 11 * stride ] ) * 4 ;\n input [ 5 ] = ( in_pass0 [ 5 * stride ] + in_pass0 [ 10 * stride ] ) * 4 ;\n input [ 6 ] = ( in_pass0 [ 6 * stride ] + in_pass0 [ 9 * stride ] ) * 4 ;\n input [ 7 ] = ( in_pass0 [ 7 * stride ] + in_pass0 [ 8 * stride ] ) * 4 ;\n step1 [ 0 ] = ( in_pass0 [ 7 * stride ] - in_pass0 [ 8 * stride ] ) * 4 ;\n step1 [ 1 ] = ( in_pass0 [ 6 * stride ] - in_pass0 [ 9 * stride ] ) * 4 ;\n step1 [ 2 ] = ( in_pass0 [ 5 * stride ] - in_pass0 [ 10 * stride ] ) * 4 ;\n step1 [ 3 ] = ( in_pass0 [ 4 * stride ] - in_pass0 [ 11 * stride ] ) * 4 ;\n step1 [ 4 ] = ( in_pass0 [ 3 * stride ] - in_pass0 [ 12 * stride ] ) * 4 ;\n step1 [ 5 ] = ( in_pass0 [ 2 * stride ] - in_pass0 [ 13 * stride ] ) * 4 ;\n step1 [ 6 ] = ( in_pass0 [ 1 * stride ] - in_pass0 [ 14 * stride ] ) * 4 ;\n step1 [ 7 ] = ( in_pass0 [ 0 * stride ] - in_pass0 [ 15 * stride ] ) * 4 ;\n }\n else {\n input [ 0 ] = ( ( in [ 0 * 16 ] + 1 ) >> 2 ) + ( ( in [ 15 * 16 ] + 1 ) >> 2 ) ;\n input [ 1 ] = ( ( in [ 1 * 16 ] + 1 ) >> 2 ) + ( ( in [ 14 * 16 ] + 1 ) >> 2 ) ;\n input [ 2 ] = ( ( in [ 2 * 16 ] + 1 ) >> 2 ) + ( ( in [ 13 * 16 ] + 1 ) >> 2 ) ;\n input [ 3 ] = ( ( in [ 3 * 16 ] + 1 ) >> 2 ) + ( ( in [ 12 * 16 ] + 1 ) >> 2 ) ;\n input [ 4 ] = ( ( in [ 4 * 16 ] + 1 ) >> 2 ) + ( ( in [ 11 * 16 ] + 1 ) >> 2 ) ;\n input [ 5 ] = ( ( in [ 5 * 16 ] + 1 ) >> 2 ) + ( ( in [ 10 * 16 ] + 1 ) >> 2 ) ;\n input [ 6 ] = ( ( in [ 6 * 16 ] + 1 ) >> 2 ) + ( ( in [ 9 * 16 ] + 1 ) >> 2 ) ;\n input [ 7 ] = ( ( in [ 7 * 16 ] + 1 ) >> 2 ) + ( ( in [ 8 * 16 ] + 1 ) >> 2 ) ;\n step1 [ 0 ] = ( ( in [ 7 * 16 ] + 1 ) >> 2 ) - ( ( in [ 8 * 16 ] + 1 ) >> 2 ) ;\n step1 [ 1 ] = ( ( in [ 6 * 16 ] + 1 ) >> 2 ) - ( ( in [ 9 * 16 ] + 1 ) >> 2 ) ;\n step1 [ 2 ] = ( ( in [ 5 * 16 ] + 1 ) >> 2 ) - ( ( in [ 10 * 16 ] + 1 ) >> 2 ) ;\n step1 [ 3 ] = ( ( in [ 4 * 16 ] + 1 ) >> 2 ) - ( ( in [ 11 * 16 ] + 1 ) >> 2 ) ;\n step1 [ 4 ] = ( ( in [ 3 * 16 ] + 1 ) >> 2 ) - ( ( in [ 12 * 16 ] + 1 ) >> 2 ) ;\n step1 [ 5 ] = ( ( in [ 2 * 16 ] + 1 ) >> 2 ) - ( ( in [ 13 * 16 ] + 1 ) >> 2 ) ;\n step1 [ 6 ] = ( ( in [ 1 * 16 ] + 1 ) >> 2 ) - ( ( in [ 14 * 16 ] + 1 ) >> 2 ) ;\n step1 [ 7 ] = ( ( in [ 0 * 16 ] + 1 ) >> 2 ) - ( ( in [ 15 * 16 ] + 1 ) >> 2 ) ;\n }\n {\n tran_high_t s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 ;\n tran_high_t t0 , t1 , t2 , t3 ;\n tran_high_t x0 , x1 , x2 , x3 ;\n s0 = input [ 0 ] + input [ 7 ] ;\n s1 = input [ 1 ] + input [ 6 ] ;\n s2 = input [ 2 ] + input [ 5 ] ;\n s3 = input [ 3 ] + input [ 4 ] ;\n s4 = input [ 3 ] - input [ 4 ] ;\n s5 = input [ 2 ] - input [ 5 ] ;\n s6 = input [ 1 ] - input [ 6 ] ;\n s7 = input [ 0 ] - input [ 7 ] ;\n x0 = s0 + s3 ;\n x1 = s1 + s2 ;\n x2 = s1 - s2 ;\n x3 = s0 - s3 ;\n t0 = ( x0 + x1 ) * cospi_16_64 ;\n t1 = ( x0 - x1 ) * cospi_16_64 ;\n t2 = x3 * cospi_8_64 + x2 * cospi_24_64 ;\n t3 = x3 * cospi_24_64 - x2 * cospi_8_64 ;\n out [ 0 ] = fdct_round_shift ( t0 ) ;\n out [ 4 ] = fdct_round_shift ( t2 ) ;\n out [ 8 ] = fdct_round_shift ( t1 ) ;\n out [ 12 ] = fdct_round_shift ( t3 ) ;\n t0 = ( s6 - s5 ) * cospi_16_64 ;\n t1 = ( s6 + s5 ) * cospi_16_64 ;\n t2 = fdct_round_shift ( t0 ) ;\n t3 = fdct_round_shift ( t1 ) ;\n x0 = s4 + t2 ;\n x1 = s4 - t2 ;\n x2 = s7 - t3 ;\n x3 = s7 + t3 ;\n t0 = x0 * cospi_28_64 + x3 * cospi_4_64 ;\n t1 = x1 * cospi_12_64 + x2 * cospi_20_64 ;\n t2 = x2 * cospi_12_64 + x1 * - cospi_20_64 ;\n t3 = x3 * cospi_28_64 + x0 * - cospi_4_64 ;\n out [ 2 ] = fdct_round_shift ( t0 ) ;\n out [ 6 ] = fdct_round_shift ( t2 ) ;\n out [ 10 ] = fdct_round_shift ( t1 ) ;\n out [ 14 ] = fdct_round_shift ( t3 ) ;\n }\n {\n temp1 = ( step1 [ 5 ] - step1 [ 2 ] ) * cospi_16_64 ;\n temp2 = ( step1 [ 4 ] - step1 [ 3 ] ) * cospi_16_64 ;\n step2 [ 2 ] = fdct_round_shift ( temp1 ) ;\n step2 [ 3 ] = fdct_round_shift ( temp2 ) ;\n temp1 = ( step1 [ 4 ] + step1 [ 3 ] ) * cospi_16_64 ;\n temp2 = ( step1 [ 5 ] + step1 [ 2 ] ) * cospi_16_64 ;\n step2 [ 4 ] = fdct_round_shift ( temp1 ) ;\n step2 [ 5 ] = fdct_round_shift ( temp2 ) ;\n step3 [ 0 ] = step1 [ 0 ] + step2 [ 3 ] ;\n step3 [ 1 ] = step1 [ 1 ] + step2 [ 2 ] ;\n step3 [ 2 ] = step1 [ 1 ] - step2 [ 2 ] ;\n step3 [ 3 ] = step1 [ 0 ] - step2 [ 3 ] ;\n step3 [ 4 ] = step1 [ 7 ] - step2 [ 4 ] ;\n step3 [ 5 ] = step1 [ 6 ] - step2 [ 5 ] ;\n step3 [ 6 ] = step1 [ 6 ] + step2 [ 5 ] ;\n step3 [ 7 ] = step1 [ 7 ] + step2 [ 4 ] ;\n temp1 = step3 [ 1 ] * - cospi_8_64 + step3 [ 6 ] * cospi_24_64 ;\n temp2 = step3 [ 2 ] * cospi_24_64 + step3 [ 5 ] * cospi_8_64 ;\n step2 [ 1 ] = fdct_round_shift ( temp1 ) ;\n step2 [ 2 ] = fdct_round_shift ( temp2 ) ;\n temp1 = step3 [ 2 ] * cospi_8_64 - step3 [ 5 ] * cospi_24_64 ;\n temp2 = step3 [ 1 ] * cospi_24_64 + step3 [ 6 ] * cospi_8_64 ;\n step2 [ 5 ] = fdct_round_shift ( temp1 ) ;\n step2 [ 6 ] = fdct_round_shift ( temp2 ) ;\n step1 [ 0 ] = step3 [ 0 ] + step2 [ 1 ] ;\n step1 [ 1 ] = step3 [ 0 ] - step2 [ 1 ] ;\n step1 [ 2 ] = step3 [ 3 ] + step2 [ 2 ] ;\n step1 [ 3 ] = step3 [ 3 ] - step2 [ 2 ] ;\n step1 [ 4 ] = step3 [ 4 ] - step2 [ 5 ] ;\n step1 [ 5 ] = step3 [ 4 ] + step2 [ 5 ] ;\n step1 [ 6 ] = step3 [ 7 ] - step2 [ 6 ] ;\n step1 [ 7 ] = step3 [ 7 ] + step2 [ 6 ] ;\n temp1 = step1 [ 0 ] * cospi_30_64 + step1 [ 7 ] * cospi_2_64 ;\n temp2 = step1 [ 1 ] * cospi_14_64 + step1 [ 6 ] * cospi_18_64 ;\n out [ 1 ] = fdct_round_shift ( temp1 ) ;\n out [ 9 ] = fdct_round_shift ( temp2 ) ;\n temp1 = step1 [ 2 ] * cospi_22_64 + step1 [ 5 ] * cospi_10_64 ;\n temp2 = step1 [ 3 ] * cospi_6_64 + step1 [ 4 ] * cospi_26_64 ;\n out [ 5 ] = fdct_round_shift ( temp1 ) ;\n out [ 13 ] = fdct_round_shift ( temp2 ) ;\n temp1 = step1 [ 3 ] * - cospi_26_64 + step1 [ 4 ] * cospi_6_64 ;\n temp2 = step1 [ 2 ] * - cospi_10_64 + step1 [ 5 ] * cospi_22_64 ;\n out [ 3 ] = fdct_round_shift ( temp1 ) ;\n out [ 11 ] = fdct_round_shift ( temp2 ) ;\n temp1 = step1 [ 1 ] * - cospi_18_64 + step1 [ 6 ] * cospi_14_64 ;\n temp2 = step1 [ 0 ] * - cospi_2_64 + step1 [ 7 ] * cospi_30_64 ;\n out [ 7 ] = fdct_round_shift ( temp1 ) ;\n out [ 15 ] = fdct_round_shift ( temp2 ) ;\n }\n in ++ ;\n in_pass0 ++ ;\n out += 16 ;\n }\n in = intermediate ;\n out = output ;\n }\n }", "idx": 6}
{"hash": -7455544248455991006, "project": "debian", "size": 20, "label": 0, "functionSource": "static int kvm_get_debugregs ( X86CPU * cpu ) {\n CPUX86State * env = & cpu -> env ;\n struct kvm_debugregs dbgregs ;\n int i , ret ;\n if ( ! kvm_has_debugregs ( ) ) {\n return 0 ;\n }\n ret = kvm_vcpu_ioctl ( CPU ( cpu ) , KVM_GET_DEBUGREGS , & dbgregs ) ;\n if ( ret < 0 ) {\n return ret ;\n }\n for ( i = 0 ;\n i < 4 ;\n i ++ ) {\n env -> dr [ i ] = dbgregs . db [ i ] ;\n }\n env -> dr [ 4 ] = env -> dr [ 6 ] = dbgregs . dr6 ;\n env -> dr [ 5 ] = env -> dr [ 7 ] = dbgregs . dr7 ;\n return 0 ;\n }", "idx": 7}
{"hash": 4180964683905830761, "project": "debian", "size": 125, "label": 0, "functionSource": "static int inode_doinit_with_dentry ( struct inode * inode , struct dentry * opt_dentry ) {\n struct superblock_security_struct * sbsec = NULL ;\n struct inode_security_struct * isec = inode -> i_security ;\n u32 task_sid , sid = 0 ;\n u16 sclass ;\n struct dentry * dentry ;\n # define INITCONTEXTLEN 255 char * context = NULL ;\n unsigned len = 0 ;\n int rc = 0 ;\n if ( isec -> initialized == LABEL_INITIALIZED ) return 0 ;\n spin_lock ( & isec -> lock ) ;\n if ( isec -> initialized == LABEL_INITIALIZED ) goto out_unlock ;\n if ( isec -> sclass == SECCLASS_FILE ) isec -> sclass = inode_mode_to_security_class ( inode -> i_mode ) ;\n sbsec = inode -> i_sb -> s_security ;\n if ( ! ( sbsec -> flags & SE_SBINITIALIZED ) ) {\n spin_lock ( & sbsec -> isec_lock ) ;\n if ( list_empty ( & isec -> list ) ) list_add ( & isec -> list , & sbsec -> isec_head ) ;\n spin_unlock ( & sbsec -> isec_lock ) ;\n goto out_unlock ;\n }\n sclass = isec -> sclass ;\n task_sid = isec -> task_sid ;\n sid = isec -> sid ;\n isec -> initialized = LABEL_PENDING ;\n spin_unlock ( & isec -> lock ) ;\n switch ( sbsec -> behavior ) {\n case SECURITY_FS_USE_NATIVE : break ;\n case SECURITY_FS_USE_XATTR : if ( ! ( inode -> i_opflags & IOP_XATTR ) ) {\n sid = sbsec -> def_sid ;\n break ;\n }\n if ( opt_dentry ) {\n dentry = dget ( opt_dentry ) ;\n }\n else {\n dentry = d_find_alias ( inode ) ;\n }\n if ( ! dentry ) {\n goto out ;\n }\n len = INITCONTEXTLEN ;\n context = kmalloc ( len + 1 , GFP_NOFS ) ;\n if ( ! context ) {\n rc = - ENOMEM ;\n dput ( dentry ) ;\n goto out ;\n }\n context [ len ] = '\\0' ;\n rc = __vfs_getxattr ( dentry , inode , XATTR_NAME_SELINUX , context , len ) ;\n if ( rc == - ERANGE ) {\n kfree ( context ) ;\n rc = __vfs_getxattr ( dentry , inode , XATTR_NAME_SELINUX , NULL , 0 ) ;\n if ( rc < 0 ) {\n dput ( dentry ) ;\n goto out ;\n }\n len = rc ;\n context = kmalloc ( len + 1 , GFP_NOFS ) ;\n if ( ! context ) {\n rc = - ENOMEM ;\n dput ( dentry ) ;\n goto out ;\n }\n context [ len ] = '\\0' ;\n rc = __vfs_getxattr ( dentry , inode , XATTR_NAME_SELINUX , context , len ) ;\n }\n dput ( dentry ) ;\n if ( rc < 0 ) {\n if ( rc != - ENODATA ) {\n printk ( KERN_WARNING \"SELinux: %s: getxattr returned \" \"%d for dev=%s ino=%ld\\n\" , __func__ , - rc , inode -> i_sb -> s_id , inode -> i_ino ) ;\n kfree ( context ) ;\n goto out ;\n }\n sid = sbsec -> def_sid ;\n rc = 0 ;\n }\n else {\n rc = security_context_to_sid_default ( context , rc , & sid , sbsec -> def_sid , GFP_NOFS ) ;\n if ( rc ) {\n char * dev = inode -> i_sb -> s_id ;\n unsigned long ino = inode -> i_ino ;\n if ( rc == - EINVAL ) {\n if ( printk_ratelimit ( ) ) printk ( KERN_NOTICE \"SELinux: inode=%lu on dev=%s was found to have an invalid \" \"context=%s. This indicates you may need to relabel the inode or the \" \"filesystem in question.\\n\" , ino , dev , context ) ;\n }\n else {\n printk ( KERN_WARNING \"SELinux: %s: context_to_sid(%s) \" \"returned %d for dev=%s ino=%ld\\n\" , __func__ , context , - rc , dev , ino ) ;\n }\n kfree ( context ) ;\n rc = 0 ;\n break ;\n }\n }\n kfree ( context ) ;\n break ;\n case SECURITY_FS_USE_TASK : sid = task_sid ;\n break ;\n case SECURITY_FS_USE_TRANS : sid = sbsec -> sid ;\n rc = security_transition_sid ( task_sid , sid , sclass , NULL , & sid ) ;\n if ( rc ) goto out ;\n break ;\n case SECURITY_FS_USE_MNTPOINT : sid = sbsec -> mntpoint_sid ;\n break ;\n default : sid = sbsec -> sid ;\n if ( ( sbsec -> flags & SE_SBGENFS ) && ! S_ISLNK ( inode -> i_mode ) ) {\n if ( opt_dentry ) dentry = dget ( opt_dentry ) ;\n else dentry = d_find_alias ( inode ) ;\n if ( ! dentry ) goto out ;\n rc = selinux_genfs_get_sid ( dentry , sclass , sbsec -> flags , & sid ) ;\n dput ( dentry ) ;\n if ( rc ) goto out ;\n }\n break ;\n }\n out : spin_lock ( & isec -> lock ) ;\n if ( isec -> initialized == LABEL_PENDING ) {\n if ( ! sid || rc ) {\n isec -> initialized = LABEL_INVALID ;\n goto out_unlock ;\n }\n isec -> initialized = LABEL_INITIALIZED ;\n isec -> sid = sid ;\n }\n out_unlock : spin_unlock ( & isec -> lock ) ;\n return rc ;\n }", "idx": 8}
{"hash": -2591112946600337077, "project": "debian", "size": 114, "label": 0, "functionSource": "static int g723_1_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n G723_1_Context * p = avctx -> priv_data ;\n AVFrame * frame = data ;\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n int dec_mode = buf [ 0 ] & 3 ;\n PPFParam ppf [ SUBFRAMES ] ;\n int16_t cur_lsp [ LPC_ORDER ] ;\n int16_t lpc [ SUBFRAMES * LPC_ORDER ] ;\n int16_t acb_vector [ SUBFRAME_LEN ] ;\n int16_t * out ;\n int bad_frame = 0 , i , j , ret ;\n int16_t * audio = p -> audio ;\n if ( buf_size < frame_size [ dec_mode ] ) {\n if ( buf_size ) av_log ( avctx , AV_LOG_WARNING , \"Expected %d bytes, got %d - skipping packet\\n\" , frame_size [ dec_mode ] , buf_size ) ;\n * got_frame_ptr = 0 ;\n return buf_size ;\n }\n if ( unpack_bitstream ( p , buf , buf_size ) < 0 ) {\n bad_frame = 1 ;\n if ( p -> past_frame_type == ACTIVE_FRAME ) p -> cur_frame_type = ACTIVE_FRAME ;\n else p -> cur_frame_type = UNTRANSMITTED_FRAME ;\n }\n frame -> nb_samples = FRAME_LEN ;\n if ( ( ret = ff_get_buffer ( avctx , frame , 0 ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n out = ( int16_t * ) frame -> data [ 0 ] ;\n if ( p -> cur_frame_type == ACTIVE_FRAME ) {\n if ( ! bad_frame ) p -> erased_frames = 0 ;\n else if ( p -> erased_frames != 3 ) p -> erased_frames ++ ;\n inverse_quant ( cur_lsp , p -> prev_lsp , p -> lsp_index , bad_frame ) ;\n lsp_interpolate ( lpc , cur_lsp , p -> prev_lsp ) ;\n memcpy ( p -> prev_lsp , cur_lsp , LPC_ORDER * sizeof ( * p -> prev_lsp ) ) ;\n memcpy ( p -> excitation , p -> prev_excitation , PITCH_MAX * sizeof ( * p -> excitation ) ) ;\n if ( ! p -> erased_frames ) {\n int16_t * vector_ptr = p -> excitation + PITCH_MAX ;\n p -> interp_gain = fixed_cb_gain [ ( p -> subframe [ 2 ] . amp_index + p -> subframe [ 3 ] . amp_index ) >> 1 ] ;\n for ( i = 0 ;\n i < SUBFRAMES ;\n i ++ ) {\n gen_fcb_excitation ( vector_ptr , & p -> subframe [ i ] , p -> cur_rate , p -> pitch_lag [ i >> 1 ] , i ) ;\n gen_acb_excitation ( acb_vector , & p -> excitation [ SUBFRAME_LEN * i ] , p -> pitch_lag [ i >> 1 ] , & p -> subframe [ i ] , p -> cur_rate ) ;\n for ( j = 0 ;\n j < SUBFRAME_LEN ;\n j ++ ) {\n int v = av_clip_int16 ( vector_ptr [ j ] << 1 ) ;\n vector_ptr [ j ] = av_clip_int16 ( v + acb_vector [ j ] ) ;\n }\n vector_ptr += SUBFRAME_LEN ;\n }\n vector_ptr = p -> excitation + PITCH_MAX ;\n p -> interp_index = comp_interp_index ( p , p -> pitch_lag [ 1 ] , & p -> sid_gain , & p -> cur_gain ) ;\n if ( p -> postfilter ) {\n i = PITCH_MAX ;\n for ( j = 0 ;\n j < SUBFRAMES ;\n i += SUBFRAME_LEN , j ++ ) comp_ppf_coeff ( p , i , p -> pitch_lag [ j >> 1 ] , ppf + j , p -> cur_rate ) ;\n for ( i = 0 , j = 0 ;\n j < SUBFRAMES ;\n i += SUBFRAME_LEN , j ++ ) ff_acelp_weighted_vector_sum ( p -> audio + LPC_ORDER + i , vector_ptr + i , vector_ptr + i + ppf [ j ] . index , ppf [ j ] . sc_gain , ppf [ j ] . opt_gain , 1 << 14 , 15 , SUBFRAME_LEN ) ;\n }\n else {\n audio = vector_ptr - LPC_ORDER ;\n }\n memcpy ( p -> prev_excitation , p -> excitation + FRAME_LEN , PITCH_MAX * sizeof ( * p -> excitation ) ) ;\n }\n else {\n p -> interp_gain = ( p -> interp_gain * 3 + 2 ) >> 2 ;\n if ( p -> erased_frames == 3 ) {\n memset ( p -> excitation , 0 , ( FRAME_LEN + PITCH_MAX ) * sizeof ( * p -> excitation ) ) ;\n memset ( p -> prev_excitation , 0 , PITCH_MAX * sizeof ( * p -> excitation ) ) ;\n memset ( frame -> data [ 0 ] , 0 , ( FRAME_LEN + LPC_ORDER ) * sizeof ( int16_t ) ) ;\n }\n else {\n int16_t * buf = p -> audio + LPC_ORDER ;\n residual_interp ( p -> excitation , buf , p -> interp_index , p -> interp_gain , & p -> random_seed ) ;\n memcpy ( p -> prev_excitation , buf + ( FRAME_LEN - PITCH_MAX ) , PITCH_MAX * sizeof ( * p -> excitation ) ) ;\n }\n }\n p -> cng_random_seed = CNG_RANDOM_SEED ;\n }\n else {\n if ( p -> cur_frame_type == SID_FRAME ) {\n p -> sid_gain = sid_gain_to_lsp_index ( p -> subframe [ 0 ] . amp_index ) ;\n inverse_quant ( p -> sid_lsp , p -> prev_lsp , p -> lsp_index , 0 ) ;\n }\n else if ( p -> past_frame_type == ACTIVE_FRAME ) {\n p -> sid_gain = estimate_sid_gain ( p ) ;\n }\n if ( p -> past_frame_type == ACTIVE_FRAME ) p -> cur_gain = p -> sid_gain ;\n else p -> cur_gain = ( p -> cur_gain * 7 + p -> sid_gain ) >> 3 ;\n generate_noise ( p ) ;\n lsp_interpolate ( lpc , p -> sid_lsp , p -> prev_lsp ) ;\n memcpy ( p -> prev_lsp , p -> sid_lsp , LPC_ORDER * sizeof ( * p -> prev_lsp ) ) ;\n }\n p -> past_frame_type = p -> cur_frame_type ;\n memcpy ( p -> audio , p -> synth_mem , LPC_ORDER * sizeof ( * p -> audio ) ) ;\n for ( i = LPC_ORDER , j = 0 ;\n j < SUBFRAMES ;\n i += SUBFRAME_LEN , j ++ ) ff_celp_lp_synthesis_filter ( p -> audio + i , & lpc [ j * LPC_ORDER ] , audio + i , SUBFRAME_LEN , LPC_ORDER , 0 , 1 , 1 << 12 ) ;\n memcpy ( p -> synth_mem , p -> audio + FRAME_LEN , LPC_ORDER * sizeof ( * p -> audio ) ) ;\n if ( p -> postfilter ) {\n formant_postfilter ( p , lpc , p -> audio , out ) ;\n }\n else {\n for ( i = 0 ;\n i < FRAME_LEN ;\n i ++ ) out [ i ] = av_clip_int16 ( p -> audio [ LPC_ORDER + i ] << 1 ) ;\n }\n * got_frame_ptr = 1 ;\n return frame_size [ dec_mode ] ;\n }", "idx": 9}
{"hash": -331579171381918893, "project": "debian", "size": 8, "label": 1, "functionSource": "static void SRP_user_pwd_free ( SRP_user_pwd * user_pwd ) {\n if ( user_pwd == NULL ) return ;\n BN_free ( user_pwd -> s ) ;\n BN_clear_free ( user_pwd -> v ) ;\n OPENSSL_free ( user_pwd -> id ) ;\n OPENSSL_free ( user_pwd -> info ) ;\n OPENSSL_free ( user_pwd ) ;\n }", "idx": 10}
{"hash": -7470076990396875111, "project": "chrome", "size": 54, "label": 0, "functionSource": "static int kq_dispatch ( struct event_base * base , void * arg , struct timeval * tv ) {\n struct kqop * kqop = arg ;\n struct kevent * changes = kqop -> changes ;\n struct kevent * events = kqop -> events ;\n struct event * ev ;\n struct timespec ts , * ts_p = NULL ;\n int i , res ;\n if ( tv != NULL ) {\n TIMEVAL_TO_TIMESPEC ( tv , & ts ) ;\n ts_p = & ts ;\n }\n res = kevent ( kqop -> kq , changes , kqop -> nchanges , events , kqop -> nevents , ts_p ) ;\n kqop -> nchanges = 0 ;\n if ( res == - 1 ) {\n if ( errno != EINTR ) {\n event_warn ( \"kevent\" ) ;\n return ( - 1 ) ;\n }\n return ( 0 ) ;\n }\n event_debug ( ( \"%s: kevent reports %d\" , __func__ , res ) ) ;\n for ( i = 0 ;\n i < res ;\n i ++ ) {\n int which = 0 ;\n if ( events [ i ] . flags & EV_ERROR ) {\n if ( events [ i ] . data == EBADF || events [ i ] . data == EINVAL || events [ i ] . data == ENOENT ) continue ;\n errno = events [ i ] . data ;\n return ( - 1 ) ;\n }\n if ( events [ i ] . filter == EVFILT_READ ) {\n which |= EV_READ ;\n }\n else if ( events [ i ] . filter == EVFILT_WRITE ) {\n which |= EV_WRITE ;\n }\n else if ( events [ i ] . filter == EVFILT_SIGNAL ) {\n which |= EV_SIGNAL ;\n }\n if ( ! which ) continue ;\n if ( events [ i ] . filter == EVFILT_SIGNAL ) {\n struct event_list * head = ( struct event_list * ) events [ i ] . udata ;\n TAILQ_FOREACH ( ev , head , ev_signal_next ) {\n event_active ( ev , which , events [ i ] . data ) ;\n }\n }\n else {\n ev = ( struct event * ) events [ i ] . udata ;\n if ( ! ( ev -> ev_events & EV_PERSIST ) ) ev -> ev_flags &= ~ EVLIST_X_KQINKERNEL ;\n event_active ( ev , which , 1 ) ;\n }\n }\n return ( 0 ) ;\n }", "idx": 11}
{"hash": -305162769887579921, "project": "debian", "size": 18, "label": 0, "functionSource": "static int sse ( MpegEncContext * s , uint8_t * src1 , uint8_t * src2 , int w , int h , int stride ) {\n uint32_t * sq = ff_squareTbl + 256 ;\n int acc = 0 ;\n int x , y ;\n if ( w == 16 && h == 16 ) return s -> dsp . sse [ 0 ] ( NULL , src1 , src2 , stride , 16 ) ;\n else if ( w == 8 && h == 8 ) return s -> dsp . sse [ 1 ] ( NULL , src1 , src2 , stride , 8 ) ;\n for ( y = 0 ;\n y < h ;\n y ++ ) {\n for ( x = 0 ;\n x < w ;\n x ++ ) {\n acc += sq [ src1 [ x + y * stride ] - src2 [ x + y * stride ] ] ;\n }\n }\n assert ( acc >= 0 ) ;\n return acc ;\n }", "idx": 12}
{"hash": -398565394354770780, "project": "debian", "size": 5, "label": 0, "functionSource": "static int ohci_bus_start ( OHCIState * ohci ) {\n trace_usb_ohci_start ( ohci -> name ) ;\n ohci_eof_timer ( ohci ) ;\n return 1 ;\n }", "idx": 13}
{"hash": 1760449185745615462, "project": "debian", "size": 4, "label": 0, "functionSource": "void TSfflush ( TSFile filep ) {\n FileImpl * file = ( FileImpl * ) filep ;\n file -> fflush ( ) ;\n }", "idx": 14}
{"hash": -5018047422955641881, "project": "debian", "size": 84, "label": 0, "functionSource": "static void s390_init ( ram_addr_t ram_size , const char * boot_device , const char * kernel_filename , const char * kernel_cmdline , const char * initrd_filename , const char * cpu_model ) {\n CPUState * env = NULL ;\n ram_addr_t ram_addr ;\n ram_addr_t kernel_size = 0 ;\n ram_addr_t initrd_offset ;\n ram_addr_t initrd_size = 0 ;\n int i ;\n if ( ! kvm_enabled ( ) ) {\n fprintf ( stderr , \"The S390 target only works with KVM enabled\\n\" ) ;\n exit ( 1 ) ;\n }\n s390_bus = s390_virtio_bus_init ( & ram_size ) ;\n ram_addr = qemu_ram_alloc ( ram_size ) ;\n cpu_register_physical_memory ( 0 , ram_size , ram_addr ) ;\n if ( cpu_model == NULL ) {\n cpu_model = \"host\" ;\n }\n ipi_states = qemu_malloc ( sizeof ( CPUState * ) * smp_cpus ) ;\n for ( i = 0 ;\n i < smp_cpus ;\n i ++ ) {\n CPUState * tmp_env ;\n tmp_env = cpu_init ( cpu_model ) ;\n if ( ! env ) {\n env = tmp_env ;\n }\n ipi_states [ i ] = tmp_env ;\n tmp_env -> halted = 1 ;\n tmp_env -> exception_index = EXCP_HLT ;\n }\n env -> halted = 0 ;\n env -> exception_index = 0 ;\n if ( kernel_filename ) {\n kernel_size = load_image ( kernel_filename , qemu_get_ram_ptr ( 0 ) ) ;\n if ( lduw_phys ( KERN_IMAGE_START ) != 0x0dd0 ) {\n fprintf ( stderr , \"Specified image is not an s390 boot image\\n\" ) ;\n exit ( 1 ) ;\n }\n cpu_synchronize_state ( env ) ;\n env -> psw . addr = KERN_IMAGE_START ;\n env -> psw . mask = 0x0000000180000000ULL ;\n }\n if ( initrd_filename ) {\n initrd_offset = INITRD_START ;\n while ( kernel_size + 0x100000 > initrd_offset ) {\n initrd_offset += 0x100000 ;\n }\n initrd_size = load_image ( initrd_filename , qemu_get_ram_ptr ( initrd_offset ) ) ;\n stq_phys ( INITRD_PARM_START , initrd_offset ) ;\n stq_phys ( INITRD_PARM_SIZE , initrd_size ) ;\n }\n if ( kernel_cmdline ) {\n cpu_physical_memory_rw ( KERN_PARM_AREA , ( uint8_t * ) kernel_cmdline , strlen ( kernel_cmdline ) , 1 ) ;\n }\n for ( i = 0 ;\n i < nb_nics ;\n i ++ ) {\n NICInfo * nd = & nd_table [ i ] ;\n DeviceState * dev ;\n if ( ! nd -> model ) {\n nd -> model = qemu_strdup ( \"virtio\" ) ;\n }\n if ( strcmp ( nd -> model , \"virtio\" ) ) {\n fprintf ( stderr , \"S390 only supports VirtIO nics\\n\" ) ;\n exit ( 1 ) ;\n }\n dev = qdev_create ( ( BusState * ) s390_bus , \"virtio-net-s390\" ) ;\n qdev_set_nic_properties ( dev , nd ) ;\n qdev_init_nofail ( dev ) ;\n }\n for ( i = 0 ;\n i < MAX_BLK_DEVS ;\n i ++ ) {\n DriveInfo * dinfo ;\n DeviceState * dev ;\n dinfo = drive_get ( IF_IDE , 0 , i ) ;\n if ( ! dinfo ) {\n continue ;\n }\n dev = qdev_create ( ( BusState * ) s390_bus , \"virtio-blk-s390\" ) ;\n qdev_prop_set_drive ( dev , \"drive\" , dinfo ) ;\n qdev_init_nofail ( dev ) ;\n }\n }", "idx": 15}
{"hash": -5952453487978309155, "project": "chrome", "size": 27, "label": 0, "functionSource": "void vp8_fast_quantize_b_c ( BLOCK * b , BLOCKD * d ) {\n int i , rc , eob ;\n int x , y , z , sz ;\n short * coeff_ptr = b -> coeff ;\n short * round_ptr = b -> round ;\n short * quant_ptr = b -> quant_fast ;\n short * qcoeff_ptr = d -> qcoeff ;\n short * dqcoeff_ptr = d -> dqcoeff ;\n short * dequant_ptr = d -> dequant ;\n eob = - 1 ;\n for ( i = 0 ;\n i < 16 ;\n i ++ ) {\n rc = vp8_default_zig_zag1d [ i ] ;\n z = coeff_ptr [ rc ] ;\n sz = ( z >> 31 ) ;\n x = ( z ^ sz ) - sz ;\n y = ( ( x + round_ptr [ rc ] ) * quant_ptr [ rc ] ) >> 16 ;\n x = ( y ^ sz ) - sz ;\n qcoeff_ptr [ rc ] = x ;\n dqcoeff_ptr [ rc ] = x * dequant_ptr [ rc ] ;\n if ( y ) {\n eob = i ;\n }\n }\n * d -> eob = ( char ) ( eob + 1 ) ;\n }", "idx": 16}
{"hash": -7262742957929857695, "project": "chrome", "size": 31, "label": 0, "functionSource": "xmlChar * xsltEvalAVT ( xsltTransformContextPtr ctxt , void * avt , xmlNodePtr node ) {\n xmlChar * ret = NULL , * tmp ;\n xmlXPathCompExprPtr comp ;\n xsltAttrVTPtr cur = ( xsltAttrVTPtr ) avt ;\n int i ;\n int str ;\n if ( ( ctxt == NULL ) || ( avt == NULL ) || ( node == NULL ) ) return ( NULL ) ;\n str = cur -> strstart ;\n for ( i = 0 ;\n i < cur -> nb_seg ;\n i ++ ) {\n if ( str ) {\n ret = xmlStrcat ( ret , ( const xmlChar * ) cur -> segments [ i ] ) ;\n }\n else {\n comp = ( xmlXPathCompExprPtr ) cur -> segments [ i ] ;\n tmp = xsltEvalXPathStringNs ( ctxt , comp , cur -> nsNr , cur -> nsList ) ;\n if ( tmp != NULL ) {\n if ( ret != NULL ) {\n ret = xmlStrcat ( ret , tmp ) ;\n xmlFree ( tmp ) ;\n }\n else {\n ret = tmp ;\n }\n }\n }\n str = ! str ;\n }\n return ( ret ) ;\n }", "idx": 17}
{"hash": 1859256631654516868, "project": "chrome", "size": 30, "label": 0, "functionSource": "int ff_set_ref_count ( H264Context * h ) {\n int num_ref_idx_active_override_flag ;\n h -> ref_count [ 0 ] = h -> pps . ref_count [ 0 ] ;\n h -> ref_count [ 1 ] = h -> pps . ref_count [ 1 ] ;\n if ( h -> slice_type_nos != AV_PICTURE_TYPE_I ) {\n unsigned max [ 2 ] ;\n max [ 0 ] = max [ 1 ] = h -> picture_structure == PICT_FRAME ? 15 : 31 ;\n if ( h -> slice_type_nos == AV_PICTURE_TYPE_B ) h -> direct_spatial_mv_pred = get_bits1 ( & h -> gb ) ;\n num_ref_idx_active_override_flag = get_bits1 ( & h -> gb ) ;\n if ( num_ref_idx_active_override_flag ) {\n h -> ref_count [ 0 ] = get_ue_golomb ( & h -> gb ) + 1 ;\n if ( h -> slice_type_nos == AV_PICTURE_TYPE_B ) {\n h -> ref_count [ 1 ] = get_ue_golomb ( & h -> gb ) + 1 ;\n }\n else h -> ref_count [ 1 ] = 1 ;\n }\n if ( h -> ref_count [ 0 ] - 1 > max [ 0 ] || h -> ref_count [ 1 ] - 1 > max [ 1 ] ) {\n av_log ( h -> avctx , AV_LOG_ERROR , \"reference overflow %u > %u or %u > %u\\n\" , h -> ref_count [ 0 ] - 1 , max [ 0 ] , h -> ref_count [ 1 ] - 1 , max [ 1 ] ) ;\n h -> ref_count [ 0 ] = h -> ref_count [ 1 ] = 0 ;\n return AVERROR_INVALIDDATA ;\n }\n if ( h -> slice_type_nos == AV_PICTURE_TYPE_B ) h -> list_count = 2 ;\n else h -> list_count = 1 ;\n }\n else {\n h -> list_count = 0 ;\n h -> ref_count [ 0 ] = h -> ref_count [ 1 ] = 0 ;\n }\n return 0 ;\n }", "idx": 18}
{"hash": 6302861533225984845, "project": "debian", "size": 47, "label": 0, "functionSource": "static void pxa2xx_i2c_write ( void * opaque , hwaddr addr , uint64_t value64 , unsigned size ) {\n PXA2xxI2CState * s = ( PXA2xxI2CState * ) opaque ;\n uint32_t value = value64 ;\n int ack ;\n addr -= s -> offset ;\n switch ( addr ) {\n case ICR : s -> control = value & 0xfff7 ;\n if ( ( value & ( 1 << 3 ) ) && ( value & ( 1 << 6 ) ) ) {\n if ( value & ( 1 << 0 ) ) {\n if ( s -> data & 1 ) s -> status |= 1 << 0 ;\n else s -> status &= ~ ( 1 << 0 ) ;\n ack = ! i2c_start_transfer ( s -> bus , s -> data >> 1 , s -> data & 1 ) ;\n }\n else {\n if ( s -> status & ( 1 << 0 ) ) {\n s -> data = i2c_recv ( s -> bus ) ;\n if ( value & ( 1 << 2 ) ) i2c_nack ( s -> bus ) ;\n ack = 1 ;\n }\n else ack = ! i2c_send ( s -> bus , s -> data ) ;\n }\n if ( value & ( 1 << 1 ) ) i2c_end_transfer ( s -> bus ) ;\n if ( ack ) {\n if ( value & ( 1 << 0 ) ) s -> status |= 1 << 6 ;\n else if ( s -> status & ( 1 << 0 ) ) s -> status |= 1 << 7 ;\n else s -> status |= 1 << 6 ;\n s -> status &= ~ ( 1 << 1 ) ;\n }\n else {\n s -> status |= 1 << 6 ;\n s -> status |= 1 << 10 ;\n s -> status |= 1 << 1 ;\n }\n }\n if ( ! ( value & ( 1 << 3 ) ) && ( value & ( 1 << 6 ) ) ) if ( value & ( 1 << 4 ) ) i2c_end_transfer ( s -> bus ) ;\n pxa2xx_i2c_update ( s ) ;\n break ;\n case ISR : s -> status &= ~ ( value & 0x07f0 ) ;\n pxa2xx_i2c_update ( s ) ;\n break ;\n case ISAR : i2c_set_slave_address ( & s -> slave -> i2c , value & 0x7f ) ;\n break ;\n case IDBR : s -> data = value & 0xff ;\n break ;\n default : printf ( \"%s: Bad register \" REG_FMT \"\\n\" , __FUNCTION__ , addr ) ;\n }\n }", "idx": 19}
{"hash": -5861712607647761763, "project": "debian", "size": 17, "label": 0, "functionSource": "static char * _zip_readstr ( unsigned char * * buf , int len , int nulp , struct zip_error * error ) {\n char * r , * o ;\n r = ( char * ) malloc ( nulp ? len + 1 : len ) ;\n if ( ! r ) {\n _zip_error_set ( error , ZIP_ER_MEMORY , 0 ) ;\n return NULL ;\n }\n memcpy ( r , * buf , len ) ;\n * buf += len ;\n if ( nulp ) {\n r [ len ] = 0 ;\n for ( o = r ;\n o < r + len ;\n o ++ ) if ( * o == '\\0' ) * o = ' ' ;\n }\n return r ;\n }", "idx": 20}
{"hash": 6336384260629386331, "project": "debian", "size": 52, "label": 0, "functionSource": "static int dissect_zbee_zcl_groups ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , void * data ) {\n proto_tree * payload_tree ;\n zbee_zcl_packet * zcl ;\n guint offset = 0 ;\n guint8 cmd_id ;\n gint rem_len ;\n if ( data == NULL ) return 0 ;\n zcl = ( zbee_zcl_packet * ) data ;\n cmd_id = zcl -> cmd_id ;\n if ( zcl -> direction == ZBEE_ZCL_FCF_TO_SERVER ) {\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \"%s, Seq: %u\" , val_to_str_const ( cmd_id , zbee_zcl_groups_srv_rx_cmd_names , \"Unknown Command\" ) , zcl -> tran_seqno ) ;\n proto_tree_add_item ( tree , hf_zbee_zcl_groups_srv_rx_cmd_id , tvb , offset , 1 , cmd_id ) ;\n rem_len = tvb_reported_length_remaining ( tvb , ++ offset ) ;\n if ( rem_len > 0 ) {\n payload_tree = proto_tree_add_subtree ( tree , tvb , offset , rem_len , ett_zbee_zcl_groups , NULL , \"Payload\" ) ;\n switch ( cmd_id ) {\n case ZBEE_ZCL_CMD_ID_GROUPS_ADD_GROUP : dissect_zcl_groups_add_group_or_if_identifying ( tvb , payload_tree , & offset ) ;\n break ;\n case ZBEE_ZCL_CMD_ID_GROUPS_VIEW_GROUP : dissect_zcl_groups_view_group ( tvb , payload_tree , & offset ) ;\n break ;\n case ZBEE_ZCL_CMD_ID_GROUPS_ADD_GET_GROUP_MEMBERSHIP : dissect_zcl_groups_get_group_membership ( tvb , payload_tree , & offset ) ;\n break ;\n case ZBEE_ZCL_CMD_ID_GROUPS_REMOVE_GROUP : dissect_zcl_groups_remove_group ( tvb , payload_tree , & offset ) ;\n break ;\n case ZBEE_ZCL_CMD_ID_GROUPS_REMOVE_ALL_GROUPS : break ;\n case ZBEE_ZCL_CMD_ID_GROUPS_ADD_GROUP_IF_IDENTIFYING : dissect_zcl_groups_add_group_or_if_identifying ( tvb , payload_tree , & offset ) ;\n break ;\n default : break ;\n }\n }\n }\n else {\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \"%s, Seq: %u\" , val_to_str_const ( cmd_id , zbee_zcl_groups_srv_tx_cmd_names , \"Unknown Command\" ) , zcl -> tran_seqno ) ;\n proto_tree_add_item ( tree , hf_zbee_zcl_groups_srv_tx_cmd_id , tvb , offset , 1 , cmd_id ) ;\n rem_len = tvb_reported_length_remaining ( tvb , ++ offset ) ;\n if ( rem_len > 0 ) {\n payload_tree = proto_tree_add_subtree ( tree , tvb , offset , rem_len , ett_zbee_zcl_groups , NULL , \"Payload\" ) ;\n switch ( cmd_id ) {\n case ZBEE_ZCL_CMD_ID_GROUPS_ADD_GROUP_RESPONSE : dissect_zcl_groups_add_remove_group_response ( tvb , payload_tree , & offset ) ;\n break ;\n case ZBEE_ZCL_CMD_ID_GROUPS_VIEW_GROUP_RESPONSE : dissect_zcl_groups_view_group_response ( tvb , payload_tree , & offset ) ;\n break ;\n case ZBEE_ZCL_CMD_ID_GROUPS_GET_GROUP_MEMBERSHIP_RESPONSE : dissect_zcl_groups_get_group_membership_response ( tvb , payload_tree , & offset ) ;\n break ;\n case ZBEE_ZCL_CMD_ID_GROUPS_REMOVE_GROUP_RESPONSE : dissect_zcl_groups_add_remove_group_response ( tvb , payload_tree , & offset ) ;\n break ;\n default : break ;\n }\n }\n }\n return tvb_captured_length ( tvb ) ;\n }", "idx": 21}
{"hash": 6458694302493204858, "project": "debian", "size": 139, "label": 0, "functionSource": "Tuplestorestate * ExecMakeTableFunctionResult ( ExprState * funcexpr , ExprContext * econtext , MemoryContext argContext , TupleDesc expectedDesc , bool randomAccess ) {\n Tuplestorestate * tupstore = NULL ;\n TupleDesc tupdesc = NULL ;\n Oid funcrettype ;\n bool returnsTuple ;\n bool returnsSet = false ;\n FunctionCallInfoData fcinfo ;\n PgStat_FunctionCallUsage fcusage ;\n ReturnSetInfo rsinfo ;\n HeapTupleData tmptup ;\n MemoryContext callerContext ;\n MemoryContext oldcontext ;\n bool direct_function_call ;\n bool first_time = true ;\n callerContext = CurrentMemoryContext ;\n funcrettype = exprType ( ( Node * ) funcexpr -> expr ) ;\n returnsTuple = type_is_rowtype ( funcrettype ) ;\n rsinfo . type = T_ReturnSetInfo ;\n rsinfo . econtext = econtext ;\n rsinfo . expectedDesc = expectedDesc ;\n rsinfo . allowedModes = ( int ) ( SFRM_ValuePerCall | SFRM_Materialize | SFRM_Materialize_Preferred ) ;\n if ( randomAccess ) rsinfo . allowedModes |= ( int ) SFRM_Materialize_Random ;\n rsinfo . returnMode = SFRM_ValuePerCall ;\n rsinfo . setResult = NULL ;\n rsinfo . setDesc = NULL ;\n if ( funcexpr && IsA ( funcexpr , FuncExprState ) && IsA ( funcexpr -> expr , FuncExpr ) ) {\n FuncExprState * fcache = ( FuncExprState * ) funcexpr ;\n ExprDoneCond argDone ;\n direct_function_call = true ;\n if ( fcache -> func . fn_oid == InvalidOid ) {\n FuncExpr * func = ( FuncExpr * ) fcache -> xprstate . expr ;\n init_fcache ( func -> funcid , func -> inputcollid , fcache , econtext -> ecxt_per_query_memory , false ) ;\n }\n returnsSet = fcache -> func . fn_retset ;\n InitFunctionCallInfoData ( fcinfo , & ( fcache -> func ) , list_length ( fcache -> args ) , fcache -> fcinfo_data . fncollation , NULL , ( Node * ) & rsinfo ) ;\n MemoryContextReset ( argContext ) ;\n oldcontext = MemoryContextSwitchTo ( argContext ) ;\n argDone = ExecEvalFuncArgs ( & fcinfo , fcache -> args , econtext ) ;\n MemoryContextSwitchTo ( oldcontext ) ;\n if ( argDone != ExprSingleResult ) ereport ( ERROR , ( errcode ( ERRCODE_FEATURE_NOT_SUPPORTED ) , errmsg ( \"set-valued function called in context that cannot accept a set\" ) ) ) ;\n if ( fcache -> func . fn_strict ) {\n int i ;\n for ( i = 0 ;\n i < fcinfo . nargs ;\n i ++ ) {\n if ( fcinfo . argnull [ i ] ) goto no_function_result ;\n }\n }\n }\n else {\n direct_function_call = false ;\n InitFunctionCallInfoData ( fcinfo , NULL , 0 , InvalidOid , NULL , NULL ) ;\n }\n MemoryContextSwitchTo ( econtext -> ecxt_per_tuple_memory ) ;\n for ( ;\n ;\n ) {\n Datum result ;\n CHECK_FOR_INTERRUPTS ( ) ;\n ResetExprContext ( econtext ) ;\n if ( direct_function_call ) {\n pgstat_init_function_usage ( & fcinfo , & fcusage ) ;\n fcinfo . isnull = false ;\n rsinfo . isDone = ExprSingleResult ;\n result = FunctionCallInvoke ( & fcinfo ) ;\n pgstat_end_function_usage ( & fcusage , rsinfo . isDone != ExprMultipleResult ) ;\n }\n else {\n result = ExecEvalExpr ( funcexpr , econtext , & fcinfo . isnull , & rsinfo . isDone ) ;\n }\n if ( rsinfo . returnMode == SFRM_ValuePerCall ) {\n if ( rsinfo . isDone == ExprEndResult ) break ;\n if ( first_time ) {\n oldcontext = MemoryContextSwitchTo ( econtext -> ecxt_per_query_memory ) ;\n tupstore = tuplestore_begin_heap ( randomAccess , false , work_mem ) ;\n rsinfo . setResult = tupstore ;\n if ( ! returnsTuple ) {\n tupdesc = CreateTemplateTupleDesc ( 1 , false ) ;\n TupleDescInitEntry ( tupdesc , ( AttrNumber ) 1 , \"column\" , funcrettype , - 1 , 0 ) ;\n rsinfo . setDesc = tupdesc ;\n }\n MemoryContextSwitchTo ( oldcontext ) ;\n }\n if ( returnsTuple ) {\n if ( ! fcinfo . isnull ) {\n HeapTupleHeader td = DatumGetHeapTupleHeader ( result ) ;\n if ( tupdesc == NULL ) {\n oldcontext = MemoryContextSwitchTo ( econtext -> ecxt_per_query_memory ) ;\n tupdesc = lookup_rowtype_tupdesc_copy ( HeapTupleHeaderGetTypeId ( td ) , HeapTupleHeaderGetTypMod ( td ) ) ;\n rsinfo . setDesc = tupdesc ;\n MemoryContextSwitchTo ( oldcontext ) ;\n }\n else {\n if ( HeapTupleHeaderGetTypeId ( td ) != tupdesc -> tdtypeid || HeapTupleHeaderGetTypMod ( td ) != tupdesc -> tdtypmod ) ereport ( ERROR , ( errcode ( ERRCODE_DATATYPE_MISMATCH ) , errmsg ( \"rows returned by function are not all of the same row type\" ) ) ) ;\n }\n tmptup . t_len = HeapTupleHeaderGetDatumLength ( td ) ;\n tmptup . t_data = td ;\n tuplestore_puttuple ( tupstore , & tmptup ) ;\n }\n else {\n int natts = expectedDesc -> natts ;\n bool * nullflags ;\n nullflags = ( bool * ) palloc ( natts * sizeof ( bool ) ) ;\n memset ( nullflags , true , natts * sizeof ( bool ) ) ;\n tuplestore_putvalues ( tupstore , expectedDesc , NULL , nullflags ) ;\n }\n }\n else {\n tuplestore_putvalues ( tupstore , tupdesc , & result , & fcinfo . isnull ) ;\n }\n if ( rsinfo . isDone != ExprMultipleResult ) break ;\n }\n else if ( rsinfo . returnMode == SFRM_Materialize ) {\n if ( ! first_time || rsinfo . isDone != ExprSingleResult ) ereport ( ERROR , ( errcode ( ERRCODE_E_R_I_E_SRF_PROTOCOL_VIOLATED ) , errmsg ( \"table-function protocol for materialize mode was not followed\" ) ) ) ;\n break ;\n }\n else ereport ( ERROR , ( errcode ( ERRCODE_E_R_I_E_SRF_PROTOCOL_VIOLATED ) , errmsg ( \"unrecognized table-function returnMode: %d\" , ( int ) rsinfo . returnMode ) ) ) ;\n first_time = false ;\n }\n no_function_result : if ( rsinfo . setResult == NULL ) {\n MemoryContextSwitchTo ( econtext -> ecxt_per_query_memory ) ;\n tupstore = tuplestore_begin_heap ( randomAccess , false , work_mem ) ;\n rsinfo . setResult = tupstore ;\n if ( ! returnsSet ) {\n int natts = expectedDesc -> natts ;\n bool * nullflags ;\n MemoryContextSwitchTo ( econtext -> ecxt_per_tuple_memory ) ;\n nullflags = ( bool * ) palloc ( natts * sizeof ( bool ) ) ;\n memset ( nullflags , true , natts * sizeof ( bool ) ) ;\n tuplestore_putvalues ( tupstore , expectedDesc , NULL , nullflags ) ;\n }\n }\n if ( rsinfo . setDesc ) {\n tupledesc_match ( expectedDesc , rsinfo . setDesc ) ;\n if ( rsinfo . setDesc -> tdrefcount == - 1 ) FreeTupleDesc ( rsinfo . setDesc ) ;\n }\n MemoryContextSwitchTo ( callerContext ) ;\n return rsinfo . setResult ;\n }", "idx": 22}
{"hash": 8947170728280515149, "project": "debian", "size": 6, "label": 0, "functionSource": "static void CheckMake ( SplinePoint * from , SplinePoint * to ) {\n CheckMakeB ( & from -> me , NULL ) ;\n CheckMakeB ( & from -> nextcp , & from -> me ) ;\n CheckMakeB ( & to -> prevcp , & from -> nextcp ) ;\n CheckMakeB ( & to -> me , & to -> prevcp ) ;\n }", "idx": 23}
{"hash": -4239386405881995323, "project": "chrome", "size": 9, "label": 0, "functionSource": "xmlHashTablePtr xmlHashCreateDict ( int size , xmlDictPtr dict ) {\n xmlHashTablePtr table ;\n table = xmlHashCreate ( size ) ;\n if ( table != NULL ) {\n table -> dict = dict ;\n xmlDictReference ( dict ) ;\n }\n return ( table ) ;\n }", "idx": 24}
{"hash": -5493081488206619677, "project": "debian", "size": 25, "label": 0, "functionSource": "static const char * cmd_hash_key ( cmd_parms * cmd , void * _dcfg , const char * _p1 , const char * _p2 ) {\n directory_config * dcfg = ( directory_config * ) _dcfg ;\n char * p1 = NULL ;\n if ( dcfg == NULL ) return NULL ;\n if ( _p1 == NULL ) return NULL ;\n if ( strcasecmp ( _p1 , \"Rand\" ) == 0 ) {\n p1 = apr_pstrdup ( cmd -> pool , getkey ( cmd -> pool ) ) ;\n dcfg -> crypto_key = p1 ;\n dcfg -> crypto_key_len = strlen ( dcfg -> crypto_key ) ;\n }\n else {\n p1 = apr_pstrdup ( cmd -> pool , _p1 ) ;\n dcfg -> crypto_key = p1 ;\n dcfg -> crypto_key_len = strlen ( p1 ) ;\n }\n if ( _p2 == NULL ) {\n return NULL ;\n }\n else {\n if ( strcasecmp ( _p2 , \"KeyOnly\" ) == 0 ) dcfg -> crypto_key_add = HASH_KEYONLY ;\n else if ( strcasecmp ( _p2 , \"SessionID\" ) == 0 ) dcfg -> crypto_key_add = HASH_SESSIONID ;\n else if ( strcasecmp ( _p2 , \"RemoteIP\" ) == 0 ) dcfg -> crypto_key_add = HASH_REMOTEIP ;\n }\n return NULL ;\n }", "idx": 25}
{"hash": 3668456668028959955, "project": "debian", "size": 4, "label": 0, "functionSource": "static void unicode_escape_to_buffer ( FBuffer * buffer , char buf [ 6 ] , UTF16 character ) {\n unicode_escape ( buf , character ) ;\n fbuffer_append ( buffer , buf , 6 ) ;\n }", "idx": 26}
{"hash": 3599206110384554647, "project": "debian", "size": 44, "label": 0, "functionSource": "void name ## _free ( type * a ) ;\n # define DECLARE_ASN1_PRINT_FUNCTION ( stname ) DECLARE_ASN1_PRINT_FUNCTION_fname ( stname , stname ) # define DECLARE_ASN1_PRINT_FUNCTION_fname ( stname , fname ) int fname ## _print_ctx ( BIO * out , stname * x , int indent , const ASN1_PCTX * pctx ) ;\n # define D2I_OF ( type ) type * ( * ) ( type * * , const unsigned char * * , long ) # define I2D_OF ( type ) int ( * ) ( type * , unsigned char * * ) # define I2D_OF_const ( type ) int ( * ) ( const type * , unsigned char * * ) # define CHECKED_D2I_OF ( type , d2i ) ( ( d2i_of_void * ) ( 1 ? d2i : ( ( D2I_OF ( type ) ) 0 ) ) ) # define CHECKED_I2D_OF ( type , i2d ) ( ( i2d_of_void * ) ( 1 ? i2d : ( ( I2D_OF ( type ) ) 0 ) ) ) # define CHECKED_NEW_OF ( type , xnew ) ( ( void * ( * ) ( void ) ) ( 1 ? xnew : ( ( type * ( * ) ( void ) ) 0 ) ) ) # define CHECKED_PTR_OF ( type , p ) ( ( void * ) ( 1 ? p : ( type * ) 0 ) ) # define CHECKED_PPTR_OF ( type , p ) ( ( void * * ) ( 1 ? p : ( type * * ) 0 ) ) # define TYPEDEF_D2I_OF ( type ) typedef type * d2i_of_ ## type ( type * * , const unsigned char * * , long ) # define TYPEDEF_I2D_OF ( type ) typedef int i2d_of_ ## type ( type * , unsigned char * * ) # define TYPEDEF_D2I2D_OF ( type ) TYPEDEF_D2I_OF ( type ) ;\n TYPEDEF_I2D_OF ( type ) TYPEDEF_D2I2D_OF ( void ) ;\n # ifndef OPENSSL_EXPORT_VAR_AS_FUNCTION typedef const ASN1_ITEM ASN1_ITEM_EXP ;\n # define ASN1_ITEM_ptr ( iptr ) ( iptr ) # define ASN1_ITEM_ref ( iptr ) ( & ( iptr ## _it ) ) # define ASN1_ITEM_rptr ( ref ) ( & ( ref ## _it ) ) # define DECLARE_ASN1_ITEM ( name ) OPENSSL_EXTERN const ASN1_ITEM name ## _it ;\n # else typedef const ASN1_ITEM * ASN1_ITEM_EXP ( void ) ;\n # define ASN1_ITEM_ptr ( iptr ) ( iptr ( ) ) # define ASN1_ITEM_ref ( iptr ) ( iptr ## _it ) # define ASN1_ITEM_rptr ( ref ) ( ref ## _it ( ) ) # define DECLARE_ASN1_ITEM ( name ) const ASN1_ITEM * name ## _it ( void ) ;\n # endif # define ASN1_STRFLGS_ESC_2253 1 # define ASN1_STRFLGS_ESC_CTRL 2 # define ASN1_STRFLGS_ESC_MSB 4 # define ASN1_STRFLGS_ESC_QUOTE 8 # define CHARTYPE_PRINTABLESTRING 0x10 # define CHARTYPE_FIRST_ESC_2253 0x20 # define CHARTYPE_LAST_ESC_2253 0x40 # define ASN1_STRFLGS_UTF8_CONVERT 0x10 # define ASN1_STRFLGS_IGNORE_TYPE 0x20 # define ASN1_STRFLGS_SHOW_TYPE 0x40 # define ASN1_STRFLGS_DUMP_ALL 0x80 # define ASN1_STRFLGS_DUMP_UNKNOWN 0x100 # define ASN1_STRFLGS_DUMP_DER 0x200 # define ASN1_STRFLGS_ESC_2254 0x400 # define ASN1_STRFLGS_RFC2253 ( ASN1_STRFLGS_ESC_2253 | ASN1_STRFLGS_ESC_CTRL | ASN1_STRFLGS_ESC_MSB | ASN1_STRFLGS_UTF8_CONVERT | ASN1_STRFLGS_DUMP_UNKNOWN | ASN1_STRFLGS_DUMP_DER ) DEFINE_STACK_OF ( ASN1_INTEGER ) DEFINE_STACK_OF ( ASN1_GENERALSTRING ) DEFINE_STACK_OF ( ASN1_UTF8STRING ) typedef struct asn1_type_st {\n int type ;\n union {\n char * ptr ;\n ASN1_BOOLEAN boolean ;\n ASN1_STRING * asn1_string ;\n ASN1_OBJECT * object ;\n ASN1_INTEGER * integer ;\n ASN1_ENUMERATED * enumerated ;\n ASN1_BIT_STRING * bit_string ;\n ASN1_OCTET_STRING * octet_string ;\n ASN1_PRINTABLESTRING * printablestring ;\n ASN1_T61STRING * t61string ;\n ASN1_IA5STRING * ia5string ;\n ASN1_GENERALSTRING * generalstring ;\n ASN1_BMPSTRING * bmpstring ;\n ASN1_UNIVERSALSTRING * universalstring ;\n ASN1_UTCTIME * utctime ;\n ASN1_GENERALIZEDTIME * generalizedtime ;\n ASN1_VISIBLESTRING * visiblestring ;\n ASN1_UTF8STRING * utf8string ;\n ASN1_STRING * set ;\n ASN1_STRING * sequence ;\n ASN1_VALUE * asn1_value ;\n }\n value ;\n }\n ASN1_TYPE ;\n DEFINE_STACK_OF ( ASN1_TYPE ) typedef STACK_OF ( ASN1_TYPE ) ASN1_SEQUENCE_ANY ;\n DECLARE_ASN1_ENCODE_FUNCTIONS_const ( ASN1_SEQUENCE_ANY , ASN1_SEQUENCE_ANY ) DECLARE_ASN1_ENCODE_FUNCTIONS_const ( ASN1_SEQUENCE_ANY , ASN1_SET_ANY ) typedef struct BIT_STRING_BITNAME_st {\n int bitnum ;\n const char * lname ;\n const char * sname ;\n }\n BIT_STRING_BITNAME ;\n # define B_ASN1_TIME B_ASN1_UTCTIME | B_ASN1_GENERALIZEDTIME # define B_ASN1_PRINTABLE B_ASN1_NUMERICSTRING | B_ASN1_PRINTABLESTRING | B_ASN1_T61STRING | B_ASN1_IA5STRING | B_ASN1_BIT_STRING | B_ASN1_UNIVERSALSTRING | B_ASN1_BMPSTRING | B_ASN1_UTF8STRING | B_ASN1_SEQUENCE | B_ASN1_UNKNOWN # define B_ASN1_DIRECTORYSTRING B_ASN1_PRINTABLESTRING | B_ASN1_TELETEXSTRING | B_ASN1_BMPSTRING | B_ASN1_UNIVERSALSTRING | B_ASN1_UTF8STRING # define B_ASN1_DISPLAYTEXT B_ASN1_IA5STRING | B_ASN1_VISIBLESTRING | B_ASN1_BMPSTRING | B_ASN1_UTF8STRING DECLARE_ASN1_FUNCTIONS_fname ( ASN1_TYPE , ASN1_ANY , ASN1_TYPE )", "idx": 27}
{"hash": 1760449185745615462, "project": "debian", "size": 7, "label": 0, "functionSource": "int TSMimeHdrFieldLengthGet ( TSMBuffer bufp , TSMLoc hdr , TSMLoc field ) {\n sdk_assert ( sdk_sanity_check_mbuffer ( bufp ) == TS_SUCCESS ) ;\n sdk_assert ( ( sdk_sanity_check_mime_hdr_handle ( hdr ) == TS_SUCCESS ) || ( sdk_sanity_check_http_hdr_handle ( hdr ) == TS_SUCCESS ) ) ;\n sdk_assert ( sdk_sanity_check_field_handle ( field , hdr ) == TS_SUCCESS ) ;\n MIMEFieldSDKHandle * handle = ( MIMEFieldSDKHandle * ) field ;\n return mime_field_length_get ( handle -> field_ptr ) ;\n }", "idx": 28}
{"hash": 3919646340804521652, "project": "debian", "size": 31, "label": 0, "functionSource": "static unsigned long write_large_blob_data ( struct git_istream * st , struct sha1file * f , const unsigned char * sha1 ) {\n git_zstream stream ;\n unsigned char ibuf [ 1024 * 16 ] ;\n unsigned char obuf [ 1024 * 16 ] ;\n unsigned long olen = 0 ;\n git_deflate_init ( & stream , pack_compression_level ) ;\n for ( ;\n ;\n ) {\n ssize_t readlen ;\n int zret = Z_OK ;\n readlen = read_istream ( st , ibuf , sizeof ( ibuf ) ) ;\n if ( readlen == - 1 ) die ( _ ( \"unable to read %s\" ) , sha1_to_hex ( sha1 ) ) ;\n stream . next_in = ibuf ;\n stream . avail_in = readlen ;\n while ( ( stream . avail_in || readlen == 0 ) && ( zret == Z_OK || zret == Z_BUF_ERROR ) ) {\n stream . next_out = obuf ;\n stream . avail_out = sizeof ( obuf ) ;\n zret = git_deflate ( & stream , readlen ? 0 : Z_FINISH ) ;\n sha1write ( f , obuf , stream . next_out - obuf ) ;\n olen += stream . next_out - obuf ;\n }\n if ( stream . avail_in ) die ( _ ( \"deflate error (%d)\" ) , zret ) ;\n if ( readlen == 0 ) {\n if ( zret != Z_STREAM_END ) die ( _ ( \"deflate error (%d)\" ) , zret ) ;\n break ;\n }\n }\n git_deflate_end ( & stream ) ;\n return olen ;\n }", "idx": 29}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_INTEGER_M262144_262143 ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_constrained_integer ( tvb , offset , actx , tree , hf_index , - 262144 , 262143U , NULL , FALSE ) ;\n return offset ;\n }", "idx": 30}
{"hash": -7795592811940874822, "project": "debian", "size": 13, "label": 0, "functionSource": "gcry_error_t gcry_pk_testkey ( gcry_sexp_t s_key ) {\n gcry_module_t module = NULL ;\n gcry_mpi_t * key = NULL ;\n gcry_err_code_t rc ;\n REGISTER_DEFAULT_PUBKEYS ;\n rc = sexp_to_key ( s_key , 1 , 0 , NULL , & key , & module , NULL ) ;\n if ( ! rc ) {\n rc = pubkey_check_secret_key ( module -> mod_id , key ) ;\n release_mpi_array ( key ) ;\n gcry_free ( key ) ;\n }\n return gcry_error ( rc ) ;\n }", "idx": 31}
{"hash": 7039307292471244756, "project": "debian", "size": 9, "label": 0, "functionSource": "static void dtap_bcc_setup ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len ) {\n guint32 curr_offset ;\n guint32 consumed ;\n guint curr_len ;\n curr_offset = offset ;\n curr_len = len ;\n ELEM_MAND_V ( GSM_A_PDU_TYPE_DTAP , DE_BCC_CALL_REF , \"(Broadcast identity)\" ) ;\n ELEM_OPT_TLV ( 0x7e , GSM_A_PDU_TYPE_DTAP , DE_USER_USER , \"(Originator-to-dispatcher information)\" ) ;\n }", "idx": 32}
{"hash": -7440595807730782314, "project": "debian", "size": 17, "label": 1, "functionSource": "int get_file_params_count_resume ( char * * params , int paramcount ) {\n int pos , best ;\n if ( * params [ 0 ] == '\"' ) {\n for ( pos = 0 ;\n pos < paramcount - 2 ;\n pos ++ ) {\n if ( params [ pos ] [ strlen ( params [ pos ] ) - 1 ] == '\"' && get_params_match_resume ( params , pos + 1 ) ) return pos + 1 ;\n }\n }\n best = paramcount - 2 ;\n for ( pos = paramcount - 2 ;\n pos > 0 ;\n pos -- ) {\n if ( get_params_match_resume ( params , pos ) ) best = pos ;\n }\n return best ;\n }", "idx": 33}
{"hash": -1483849844579170895, "project": "chrome", "size": 3, "label": 0, "functionSource": "static float usec_to_fps ( uint64_t usec , unsigned int frames ) {\n return ( float ) ( usec > 0 ? frames * 1000000.0 / ( float ) usec : 0 ) ;\n }", "idx": 34}
{"hash": -1111775978048960297, "project": "chrome", "size": 12, "label": 0, "functionSource": "TEST_F ( BrowsingDataRemoverImplTest , RemoveQuotaManagedDataForeverNeither ) {\n # if BUILDFLAG ( ENABLE_EXTENSIONS ) CreateMockPolicy ( ) ;\n # endif BlockUntilBrowsingDataRemoved ( base : : Time ( ) , base : : Time : : Max ( ) , BrowsingDataRemover : : REMOVE_FILE_SYSTEMS | BrowsingDataRemover : : REMOVE_WEBSQL | BrowsingDataRemover : : REMOVE_APPCACHE | BrowsingDataRemover : : REMOVE_SERVICE_WORKERS | BrowsingDataRemover : : REMOVE_CACHE_STORAGE | BrowsingDataRemover : : REMOVE_INDEXEDDB , false ) ;\n EXPECT_EQ ( BrowsingDataRemover : : REMOVE_FILE_SYSTEMS | BrowsingDataRemover : : REMOVE_WEBSQL | BrowsingDataRemover : : REMOVE_APPCACHE | BrowsingDataRemover : : REMOVE_SERVICE_WORKERS | BrowsingDataRemover : : REMOVE_CACHE_STORAGE | BrowsingDataRemover : : REMOVE_INDEXEDDB , GetRemovalMask ( ) ) ;\n EXPECT_EQ ( BrowsingDataHelper : : UNPROTECTED_WEB , GetOriginTypeMask ( ) ) ;\n StoragePartitionRemovalData removal_data = GetStoragePartitionRemovalData ( ) ;\n EXPECT_EQ ( removal_data . remove_mask , StoragePartition : : REMOVE_DATA_MASK_FILE_SYSTEMS | StoragePartition : : REMOVE_DATA_MASK_WEBSQL | StoragePartition : : REMOVE_DATA_MASK_APPCACHE | StoragePartition : : REMOVE_DATA_MASK_SERVICE_WORKERS | StoragePartition : : REMOVE_DATA_MASK_CACHE_STORAGE | StoragePartition : : REMOVE_DATA_MASK_INDEXEDDB ) ;\n EXPECT_EQ ( removal_data . quota_storage_remove_mask , StoragePartition : : QUOTA_MANAGED_STORAGE_MASK_ALL ) ;\n EXPECT_TRUE ( removal_data . origin_matcher . Run ( kOrigin1 , mock_policy ( ) ) ) ;\n EXPECT_TRUE ( removal_data . origin_matcher . Run ( kOrigin2 , mock_policy ( ) ) ) ;\n EXPECT_TRUE ( removal_data . origin_matcher . Run ( kOrigin3 , mock_policy ( ) ) ) ;\n }", "idx": 35}
{"hash": -5780611388839125875, "project": "chrome", "size": 4, "label": 0, "functionSource": "xmlDeregisterNodeFunc * __xmlDeregisterNodeDefaultValue ( void ) {\n if ( IS_MAIN_THREAD ) return ( & xmlDeregisterNodeDefaultValue ) ;\n else return ( & xmlGetGlobalState ( ) -> xmlDeregisterNodeDefaultValue ) ;\n }", "idx": 36}
{"hash": 4496746249504396521, "project": "debian", "size": 7, "label": 0, "functionSource": "int compare_key_tok_id ( const void * a1 , const void * a2 ) {\n const struct key_tok * p1 = a1 ;\n const struct key_tok * p2 = a2 ;\n if ( p1 -> token == p2 -> token ) return 0 ;\n if ( p1 -> token < p2 -> token ) return - 1 ;\n else return 1 ;\n }", "idx": 37}
{"hash": -8704451445127642833, "project": "chrome", "size": 19, "label": 1, "functionSource": "static int32_t u_scanf_octal_handler ( UFILE * input , u_scanf_spec_info * info , ufmt_args * args , const UChar * fmt , int32_t * fmtConsumed , int32_t * argConverted ) {\n int32_t len ;\n int32_t skipped ;\n void * num = ( void * ) ( args [ 0 ] . ptrValue ) ;\n int64_t result ;\n skipped = u_scanf_skip_leading_ws ( input , info -> fPadChar ) ;\n ufile_fill_uchar_buffer ( input ) ;\n len = ( int32_t ) ( input -> str . fLimit - input -> str . fPos ) ;\n if ( info -> fWidth != - 1 ) len = ufmt_min ( len , info -> fWidth ) ;\n result = ufmt_uto64 ( input -> str . fPos , & len , 8 ) ;\n input -> str . fPos += len ;\n if ( ! info -> fSkipArg ) {\n if ( info -> fIsShort ) * ( int16_t * ) num = ( int16_t ) ( UINT16_MAX & result ) ;\n else if ( info -> fIsLongLong ) * ( int64_t * ) num = result ;\n else * ( int32_t * ) num = ( int32_t ) ( UINT32_MAX & result ) ;\n }\n * argConverted = ! info -> fSkipArg ;\n return len + skipped ;\n }", "idx": 38}
{"hash": -2064332158282087279, "project": "debian", "size": 13, "label": 1, "functionSource": "static void parse_content_type ( struct attachment_istream * astream , const struct message_header_line * hdr ) {\n struct rfc822_parser_context parser ;\n string_t * content_type ;\n if ( astream -> part . content_type != NULL ) return ;\n rfc822_parser_init ( & parser , hdr -> full_value , hdr -> full_value_len , NULL ) ;\n rfc822_skip_lwsp ( & parser ) ;\n T_BEGIN {\n content_type = t_str_new ( 64 ) ;\n ( void ) rfc822_parse_content_type ( & parser , content_type ) ;\n astream -> part . content_type = i_strdup ( str_c ( content_type ) ) ;\n }\n T_END ;\n }", "idx": 39}
{"hash": -2908211205972632000, "project": "debian", "size": 18, "label": 0, "functionSource": "static void windows_print_sticky ( WINDOW_REC * win ) {\n MAIN_WINDOW_REC * mainwin ;\n GSList * tmp , * list ;\n GString * str ;\n mainwin = WINDOW_MAIN ( win ) ;\n str = g_string_new ( NULL ) ;\n list = get_sticky_windows_sorted ( mainwin ) ;\n for ( tmp = list ;\n tmp != NULL ;\n tmp = tmp -> next ) {\n WINDOW_REC * rec = tmp -> data ;\n g_string_append_printf ( str , \"#%d, \" , rec -> refnum ) ;\n }\n g_string_truncate ( str , str -> len - 2 ) ;\n g_slist_free ( list ) ;\n printformat_window ( win , MSGLEVEL_CLIENTCRAP , TXT_WINDOW_INFO_STICKY , str -> str ) ;\n g_string_free ( str , TRUE ) ;\n }", "idx": 40}
{"hash": 1504508151056681409, "project": "debian", "size": 38, "label": 0, "functionSource": "static int find_newc_header ( struct archive_read * a ) {\n const void * h ;\n const char * p , * q ;\n size_t skip , skipped = 0 ;\n ssize_t bytes ;\n for ( ;\n ;\n ) {\n h = __archive_read_ahead ( a , newc_header_size , & bytes ) ;\n if ( h == NULL ) return ( ARCHIVE_FATAL ) ;\n p = h ;\n q = p + bytes ;\n if ( memcmp ( \"07070\" , p , 5 ) == 0 && ( p [ 5 ] == '1' || p [ 5 ] == '2' ) && is_hex ( p , newc_header_size ) ) return ( ARCHIVE_OK ) ;\n while ( p + newc_header_size <= q ) {\n switch ( p [ 5 ] ) {\n case '1' : case '2' : if ( memcmp ( \"07070\" , p , 5 ) == 0 && is_hex ( p , newc_header_size ) ) {\n skip = p - ( const char * ) h ;\n __archive_read_consume ( a , skip ) ;\n skipped += skip ;\n if ( skipped > 0 ) {\n archive_set_error ( & a -> archive , 0 , \"Skipped %d bytes before \" \"finding valid header\" , ( int ) skipped ) ;\n return ( ARCHIVE_WARN ) ;\n }\n return ( ARCHIVE_OK ) ;\n }\n p += 2 ;\n break ;\n case '0' : p ++ ;\n break ;\n default : p += 6 ;\n break ;\n }\n }\n skip = p - ( const char * ) h ;\n __archive_read_consume ( a , skip ) ;\n skipped += skip ;\n }\n }", "idx": 41}
{"hash": -252067619174963255, "project": "debian", "size": 11, "label": 0, "functionSource": "static void at1_imdct ( AT1Ctx * q , float * spec , float * out , int nbits , int rev_spec ) {\n FFTContext * mdct_context = & q -> mdct_ctx [ nbits - 5 - ( nbits > 6 ) ] ;\n int transf_size = 1 << nbits ;\n if ( rev_spec ) {\n int i ;\n for ( i = 0 ;\n i < transf_size / 2 ;\n i ++ ) FFSWAP ( float , spec [ i ] , spec [ transf_size - 1 - i ] ) ;\n }\n mdct_context -> imdct_half ( mdct_context , out , spec ) ;\n }", "idx": 42}
{"hash": 5704453449583823009, "project": "chrome", "size": 13, "label": 0, "functionSource": "void evbuffer_drain ( struct evbuffer * buf , size_t len ) {\n size_t oldoff = buf -> off ;\n if ( len >= buf -> off ) {\n buf -> off = 0 ;\n buf -> buffer = buf -> orig_buffer ;\n buf -> misalign = 0 ;\n goto done ;\n }\n buf -> buffer += len ;\n buf -> misalign += len ;\n buf -> off -= len ;\n done : if ( buf -> off != oldoff && buf -> cb != NULL ) ( * buf -> cb ) ( buf , oldoff , buf -> off , buf -> cbarg ) ;\n }", "idx": 43}
{"hash": -4872400287267974771, "project": "debian", "size": 20, "label": 1, "functionSource": "static void reindex_all_databases ( const char * maintenance_db , const char * host , const char * port , const char * username , enum trivalue prompt_password , const char * progname , bool echo , bool quiet , bool verbose ) {\n PGconn * conn ;\n PGresult * result ;\n int i ;\n conn = connectMaintenanceDatabase ( maintenance_db , host , port , username , prompt_password , progname ) ;\n result = executeQuery ( conn , \"SELECT datname FROM pg_database WHERE datallowconn ORDER BY 1;\n\" , progname , echo ) ;\n PQfinish ( conn ) ;\n for ( i = 0 ;\n i < PQntuples ( result ) ;\n i ++ ) {\n char * dbname = PQgetvalue ( result , i , 0 ) ;\n if ( ! quiet ) {\n printf ( _ ( \"%s: reindexing database \\\"%s\\\"\\n\" ) , progname , dbname ) ;\n fflush ( stdout ) ;\n }\n reindex_one_database ( dbname , dbname , \"DATABASE\" , host , port , username , prompt_password , progname , echo , verbose ) ;\n }\n PQclear ( result ) ;\n }", "idx": 44}
{"hash": -4271192073087306668, "project": "debian", "size": 10, "label": 0, "functionSource": "static inline void set_intra_mode_default ( AVSContext * h ) {\n if ( h -> stream_revision > 0 ) {\n h -> pred_mode_Y [ 3 ] = h -> pred_mode_Y [ 6 ] = NOT_AVAIL ;\n h -> top_pred_Y [ h -> mbx * 2 + 0 ] = h -> top_pred_Y [ h -> mbx * 2 + 1 ] = NOT_AVAIL ;\n }\n else {\n h -> pred_mode_Y [ 3 ] = h -> pred_mode_Y [ 6 ] = INTRA_L_LP ;\n h -> top_pred_Y [ h -> mbx * 2 + 0 ] = h -> top_pred_Y [ h -> mbx * 2 + 1 ] = INTRA_L_LP ;\n }\n }", "idx": 45}
{"hash": 2776415072272421122, "project": "debian", "size": 15, "label": 0, "functionSource": "static void hscroll ( AVCodecContext * avctx ) {\n AnsiContext * s = avctx -> priv_data ;\n int i ;\n if ( s -> y < avctx -> height - s -> font_height ) {\n s -> y += s -> font_height ;\n return ;\n }\n i = 0 ;\n for ( ;\n i < avctx -> height - s -> font_height ;\n i ++ ) memcpy ( s -> frame -> data [ 0 ] + i * s -> frame -> linesize [ 0 ] , s -> frame -> data [ 0 ] + ( i + s -> font_height ) * s -> frame -> linesize [ 0 ] , avctx -> width ) ;\n for ( ;\n i < avctx -> height ;\n i ++ ) memset ( s -> frame -> data [ 0 ] + i * s -> frame -> linesize [ 0 ] , DEFAULT_BG_COLOR , avctx -> width ) ;\n }", "idx": 46}
{"hash": 7424930167238097621, "project": "debian", "size": 5, "label": 0, "functionSource": "static int proc_submiturb ( struct usb_dev_state * ps , void __user * arg ) {\n struct usbdevfs_urb uurb ;\n if ( copy_from_user ( & uurb , arg , sizeof ( uurb ) ) ) return - EFAULT ;\n return proc_do_submiturb ( ps , & uurb , ( ( ( struct usbdevfs_urb __user * ) arg ) -> iso_frame_desc ) , arg ) ;\n }", "idx": 47}
{"hash": 313627013719508831, "project": "debian", "size": 7, "label": 0, "functionSource": "static inline void SetPixelViaPixelInfo ( const Image * restrict image , const PixelInfo * restrict pixel_info , Quantum * restrict pixel ) {\n pixel [ image -> channel_map [ RedPixelChannel ] . offset ] = ClampToQuantum ( pixel_info -> red ) ;\n pixel [ image -> channel_map [ GreenPixelChannel ] . offset ] = ClampToQuantum ( pixel_info -> green ) ;\n pixel [ image -> channel_map [ BluePixelChannel ] . offset ] = ClampToQuantum ( pixel_info -> blue ) ;\n if ( image -> channel_map [ BlackPixelChannel ] . traits != UndefinedPixelTrait ) pixel [ image -> channel_map [ BlackPixelChannel ] . offset ] = ClampToQuantum ( pixel_info -> black ) ;\n if ( image -> channel_map [ AlphaPixelChannel ] . traits != UndefinedPixelTrait ) pixel [ image -> channel_map [ AlphaPixelChannel ] . offset ] = pixel_info -> alpha_trait == UndefinedPixelTrait ? OpaqueAlpha : ClampToQuantum ( pixel_info -> alpha ) ;\n }", "idx": 48}
{"hash": 1760449185745615462, "project": "debian", "size": 6, "label": 0, "functionSource": "inline TSReturnCode ink_sanity_check_stat_structure ( void * obj ) {\n if ( obj == nullptr ) {\n return TS_ERROR ;\n }\n return TS_SUCCESS ;\n }", "idx": 49}
{"hash": 3804373597256531021, "project": "debian", "size": 119, "label": 0, "functionSource": "static int replace_user_table ( THD * thd , TABLE * table , const LEX_USER & combo , ulong rights , bool revoke_grant , bool can_create_user , bool no_auto_create ) {\n int error = - 1 ;\n bool old_row_exists = 0 ;\n const char * password = \"\" ;\n uint password_len = 0 ;\n char what = ( revoke_grant ) ? 'N' : 'Y' ;\n uchar user_key [ MAX_KEY_LENGTH ] ;\n LEX * lex = thd -> lex ;\n DBUG_ENTER ( \"replace_user_table\" ) ;\n safe_mutex_assert_owner ( & acl_cache -> lock ) ;\n if ( combo . password . str && combo . password . str [ 0 ] ) {\n if ( combo . password . length != SCRAMBLED_PASSWORD_CHAR_LENGTH && combo . password . length != SCRAMBLED_PASSWORD_CHAR_LENGTH_323 ) {\n my_error ( ER_PASSWD_LENGTH , MYF ( 0 ) , SCRAMBLED_PASSWORD_CHAR_LENGTH ) ;\n DBUG_RETURN ( - 1 ) ;\n }\n password_len = combo . password . length ;\n password = combo . password . str ;\n }\n table -> use_all_columns ( ) ;\n table -> field [ 0 ] -> store ( combo . host . str , combo . host . length , system_charset_info ) ;\n table -> field [ 1 ] -> store ( combo . user . str , combo . user . length , system_charset_info ) ;\n key_copy ( user_key , table -> record [ 0 ] , table -> key_info , table -> key_info -> key_length ) ;\n if ( table -> file -> index_read_idx_map ( table -> record [ 0 ] , 0 , user_key , HA_WHOLE_KEY , HA_READ_KEY_EXACT ) ) {\n if ( what == 'N' ) {\n my_error ( ER_NONEXISTING_GRANT , MYF ( 0 ) , combo . user . str , combo . host . str ) ;\n goto end ;\n }\n else if ( ! password_len && no_auto_create ) {\n my_error ( ER_PASSWORD_NO_MATCH , MYF ( 0 ) ) ;\n goto end ;\n }\n else if ( ! can_create_user ) {\n my_error ( ER_CANT_CREATE_USER_WITH_GRANT , MYF ( 0 ) ) ;\n goto end ;\n }\n old_row_exists = 0 ;\n restore_record ( table , s -> default_values ) ;\n table -> field [ 0 ] -> store ( combo . host . str , combo . host . length , system_charset_info ) ;\n table -> field [ 1 ] -> store ( combo . user . str , combo . user . length , system_charset_info ) ;\n table -> field [ 2 ] -> store ( password , password_len , system_charset_info ) ;\n }\n else {\n old_row_exists = 1 ;\n store_record ( table , record [ 1 ] ) ;\n if ( combo . password . str ) table -> field [ 2 ] -> store ( password , password_len , system_charset_info ) ;\n else if ( ! rights && ! revoke_grant && lex -> ssl_type == SSL_TYPE_NOT_SPECIFIED && ! lex -> mqh . specified_limits ) {\n DBUG_RETURN ( 0 ) ;\n }\n }\n Field * * tmp_field ;\n ulong priv ;\n uint next_field ;\n for ( tmp_field = table -> field + 3 , priv = SELECT_ACL ;\n * tmp_field && ( * tmp_field ) -> real_type ( ) == MYSQL_TYPE_ENUM && ( ( Field_enum * ) ( * tmp_field ) ) -> typelib -> count == 2 ;\n tmp_field ++ , priv <<= 1 ) {\n if ( priv & rights ) ( * tmp_field ) -> store ( & what , 1 , & my_charset_latin1 ) ;\n }\n rights = get_access ( table , 3 , & next_field ) ;\n DBUG_PRINT ( \"info\" , ( \"table fields: %d\" , table -> s -> fields ) ) ;\n if ( table -> s -> fields >= 31 ) {\n switch ( lex -> ssl_type ) {\n case SSL_TYPE_ANY : table -> field [ next_field ] -> store ( STRING_WITH_LEN ( \"ANY\" ) , & my_charset_latin1 ) ;\n table -> field [ next_field + 1 ] -> store ( \"\" , 0 , & my_charset_latin1 ) ;\n table -> field [ next_field + 2 ] -> store ( \"\" , 0 , & my_charset_latin1 ) ;\n table -> field [ next_field + 3 ] -> store ( \"\" , 0 , & my_charset_latin1 ) ;\n break ;\n case SSL_TYPE_X509 : table -> field [ next_field ] -> store ( STRING_WITH_LEN ( \"X509\" ) , & my_charset_latin1 ) ;\n table -> field [ next_field + 1 ] -> store ( \"\" , 0 , & my_charset_latin1 ) ;\n table -> field [ next_field + 2 ] -> store ( \"\" , 0 , & my_charset_latin1 ) ;\n table -> field [ next_field + 3 ] -> store ( \"\" , 0 , & my_charset_latin1 ) ;\n break ;\n case SSL_TYPE_SPECIFIED : table -> field [ next_field ] -> store ( STRING_WITH_LEN ( \"SPECIFIED\" ) , & my_charset_latin1 ) ;\n table -> field [ next_field + 1 ] -> store ( \"\" , 0 , & my_charset_latin1 ) ;\n table -> field [ next_field + 2 ] -> store ( \"\" , 0 , & my_charset_latin1 ) ;\n table -> field [ next_field + 3 ] -> store ( \"\" , 0 , & my_charset_latin1 ) ;\n if ( lex -> ssl_cipher ) table -> field [ next_field + 1 ] -> store ( lex -> ssl_cipher , strlen ( lex -> ssl_cipher ) , system_charset_info ) ;\n if ( lex -> x509_issuer ) table -> field [ next_field + 2 ] -> store ( lex -> x509_issuer , strlen ( lex -> x509_issuer ) , system_charset_info ) ;\n if ( lex -> x509_subject ) table -> field [ next_field + 3 ] -> store ( lex -> x509_subject , strlen ( lex -> x509_subject ) , system_charset_info ) ;\n break ;\n case SSL_TYPE_NOT_SPECIFIED : break ;\n case SSL_TYPE_NONE : table -> field [ next_field ] -> store ( \"\" , 0 , & my_charset_latin1 ) ;\n table -> field [ next_field + 1 ] -> store ( \"\" , 0 , & my_charset_latin1 ) ;\n table -> field [ next_field + 2 ] -> store ( \"\" , 0 , & my_charset_latin1 ) ;\n table -> field [ next_field + 3 ] -> store ( \"\" , 0 , & my_charset_latin1 ) ;\n break ;\n }\n next_field += 4 ;\n USER_RESOURCES mqh = lex -> mqh ;\n if ( mqh . specified_limits & USER_RESOURCES : : QUERIES_PER_HOUR ) table -> field [ next_field ] -> store ( ( longlong ) mqh . questions , TRUE ) ;\n if ( mqh . specified_limits & USER_RESOURCES : : UPDATES_PER_HOUR ) table -> field [ next_field + 1 ] -> store ( ( longlong ) mqh . updates , TRUE ) ;\n if ( mqh . specified_limits & USER_RESOURCES : : CONNECTIONS_PER_HOUR ) table -> field [ next_field + 2 ] -> store ( ( longlong ) mqh . conn_per_hour , TRUE ) ;\n if ( table -> s -> fields >= 36 && ( mqh . specified_limits & USER_RESOURCES : : USER_CONNECTIONS ) ) table -> field [ next_field + 3 ] -> store ( ( longlong ) mqh . user_conn , TRUE ) ;\n mqh_used = mqh_used || mqh . questions || mqh . updates || mqh . conn_per_hour ;\n }\n if ( old_row_exists ) {\n if ( cmp_record ( table , record [ 1 ] ) ) {\n if ( ( error = table -> file -> ha_update_row ( table -> record [ 1 ] , table -> record [ 0 ] ) ) && error != HA_ERR_RECORD_IS_THE_SAME ) {\n table -> file -> print_error ( error , MYF ( 0 ) ) ;\n error = - 1 ;\n goto end ;\n }\n else error = 0 ;\n }\n }\n else if ( ( error = table -> file -> ha_write_row ( table -> record [ 0 ] ) ) ) {\n if ( table -> file -> is_fatal_error ( error , HA_CHECK_DUP ) ) {\n table -> file -> print_error ( error , MYF ( 0 ) ) ;\n error = - 1 ;\n goto end ;\n }\n }\n error = 0 ;\n end : if ( ! error ) {\n acl_cache -> clear ( 1 ) ;\n if ( old_row_exists ) acl_update_user ( combo . user . str , combo . host . str , combo . password . str , password_len , lex -> ssl_type , lex -> ssl_cipher , lex -> x509_issuer , lex -> x509_subject , & lex -> mqh , rights ) ;\n else acl_insert_user ( combo . user . str , combo . host . str , password , password_len , lex -> ssl_type , lex -> ssl_cipher , lex -> x509_issuer , lex -> x509_subject , & lex -> mqh , rights ) ;\n }\n DBUG_RETURN ( error ) ;\n }", "idx": 50}
{"hash": 914926989019402478, "project": "debian", "size": 9, "label": 0, "functionSource": "static int main_atou ( const char * arg , usize_t * uo , usize_t low , usize_t high , char which ) {\n int ret ;\n xoff_t xo ;\n if ( ( ret = main_atoux ( arg , & xo , low , high , which ) ) ) {\n return ret ;\n }\n * uo = ( usize_t ) xo ;\n return 0 ;\n }", "idx": 51}
{"hash": -735007692503855355, "project": "debian", "size": 124, "label": 0, "functionSource": "static Image * ReadCAPTIONImage ( const ImageInfo * image_info , ExceptionInfo * exception ) {\n char * caption , geometry [ MaxTextExtent ] , * property , * text ;\n const char * gravity , * option ;\n DrawInfo * draw_info ;\n Image * image ;\n MagickBooleanType split , status ;\n register ssize_t i ;\n size_t height , width ;\n TypeMetric metrics ;\n assert ( image_info != ( const ImageInfo * ) NULL ) ;\n assert ( image_info -> signature == MagickSignature ) ;\n if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ;\n assert ( exception != ( ExceptionInfo * ) NULL ) ;\n assert ( exception -> signature == MagickSignature ) ;\n image = AcquireImage ( image_info ) ;\n ( void ) ResetImagePage ( image , \"0x0+0+0\" ) ;\n option = GetImageOption ( image_info , \"filename\" ) ;\n if ( option == ( const char * ) NULL ) property = InterpretImageProperties ( image_info , image , image_info -> filename ) ;\n else if ( LocaleNCompare ( option , \"caption:\" , 8 ) == 0 ) property = InterpretImageProperties ( image_info , image , option + 8 ) ;\n else property = InterpretImageProperties ( image_info , image , option ) ;\n ( void ) SetImageProperty ( image , \"caption\" , property ) ;\n property = DestroyString ( property ) ;\n caption = ConstantString ( GetImageProperty ( image , \"caption\" ) ) ;\n draw_info = CloneDrawInfo ( image_info , ( DrawInfo * ) NULL ) ;\n ( void ) CloneString ( & draw_info -> text , caption ) ;\n gravity = GetImageOption ( image_info , \"gravity\" ) ;\n if ( gravity != ( char * ) NULL ) draw_info -> gravity = ( GravityType ) ParseCommandOption ( MagickGravityOptions , MagickFalse , gravity ) ;\n split = MagickFalse ;\n status = MagickTrue ;\n if ( image -> columns == 0 ) {\n text = AcquireString ( caption ) ;\n i = FormatMagickCaption ( image , draw_info , split , & metrics , & text ) ;\n ( void ) CloneString ( & draw_info -> text , text ) ;\n text = DestroyString ( text ) ;\n ( void ) FormatLocaleString ( geometry , MaxTextExtent , \"%+g%+g\" , - metrics . bounds . x1 , metrics . ascent ) ;\n if ( draw_info -> gravity == UndefinedGravity ) ( void ) CloneString ( & draw_info -> geometry , geometry ) ;\n status = GetMultilineTypeMetrics ( image , draw_info , & metrics ) ;\n width = ( size_t ) floor ( metrics . width + draw_info -> stroke_width + 0.5 ) ;\n image -> columns = width ;\n }\n if ( image -> rows == 0 ) {\n split = MagickTrue ;\n text = AcquireString ( caption ) ;\n i = FormatMagickCaption ( image , draw_info , split , & metrics , & text ) ;\n ( void ) CloneString ( & draw_info -> text , text ) ;\n text = DestroyString ( text ) ;\n ( void ) FormatLocaleString ( geometry , MaxTextExtent , \"%+g%+g\" , - metrics . bounds . x1 , metrics . ascent ) ;\n if ( draw_info -> gravity == UndefinedGravity ) ( void ) CloneString ( & draw_info -> geometry , geometry ) ;\n status = GetMultilineTypeMetrics ( image , draw_info , & metrics ) ;\n image -> rows = ( size_t ) ( ( i + 1 ) * ( metrics . ascent - metrics . descent + draw_info -> interline_spacing + draw_info -> stroke_width ) + 0.5 ) ;\n }\n if ( status != MagickFalse ) status = SetImageExtent ( image , image -> columns , image -> rows ) ;\n if ( status == MagickFalse ) {\n draw_info = DestroyDrawInfo ( draw_info ) ;\n InheritException ( exception , & image -> exception ) ;\n return ( DestroyImageList ( image ) ) ;\n }\n if ( SetImageBackgroundColor ( image ) == MagickFalse ) {\n draw_info = DestroyDrawInfo ( draw_info ) ;\n InheritException ( exception , & image -> exception ) ;\n image = DestroyImageList ( image ) ;\n return ( ( Image * ) NULL ) ;\n }\n if ( ( fabs ( image_info -> pointsize ) < MagickEpsilon ) && ( strlen ( caption ) > 0 ) ) {\n double high , low ;\n for ( ;\n ;\n draw_info -> pointsize *= 2.0 ) {\n text = AcquireString ( caption ) ;\n i = FormatMagickCaption ( image , draw_info , split , & metrics , & text ) ;\n ( void ) CloneString ( & draw_info -> text , text ) ;\n text = DestroyString ( text ) ;\n ( void ) FormatLocaleString ( geometry , MaxTextExtent , \"%+g%+g\" , - metrics . bounds . x1 , metrics . ascent ) ;\n if ( draw_info -> gravity == UndefinedGravity ) ( void ) CloneString ( & draw_info -> geometry , geometry ) ;\n status = GetMultilineTypeMetrics ( image , draw_info , & metrics ) ;\n ( void ) status ;\n width = ( size_t ) floor ( metrics . width + draw_info -> stroke_width + 0.5 ) ;\n height = ( size_t ) floor ( metrics . height + draw_info -> stroke_width + 0.5 ) ;\n if ( ( image -> columns != 0 ) && ( image -> rows != 0 ) ) {\n if ( ( width >= image -> columns ) && ( height >= image -> rows ) ) break ;\n }\n else if ( ( ( image -> columns != 0 ) && ( width >= image -> columns ) ) || ( ( image -> rows != 0 ) && ( height >= image -> rows ) ) ) break ;\n }\n high = draw_info -> pointsize ;\n for ( low = 1.0 ;\n ( high - low ) > 0.5 ;\n ) {\n draw_info -> pointsize = ( low + high ) / 2.0 ;\n text = AcquireString ( caption ) ;\n i = FormatMagickCaption ( image , draw_info , split , & metrics , & text ) ;\n ( void ) CloneString ( & draw_info -> text , text ) ;\n text = DestroyString ( text ) ;\n ( void ) FormatLocaleString ( geometry , MaxTextExtent , \"%+g%+g\" , - metrics . bounds . x1 , metrics . ascent ) ;\n if ( draw_info -> gravity == UndefinedGravity ) ( void ) CloneString ( & draw_info -> geometry , geometry ) ;\n ( void ) GetMultilineTypeMetrics ( image , draw_info , & metrics ) ;\n width = ( size_t ) floor ( metrics . width + draw_info -> stroke_width + 0.5 ) ;\n height = ( size_t ) floor ( metrics . height + draw_info -> stroke_width + 0.5 ) ;\n if ( ( image -> columns != 0 ) && ( image -> rows != 0 ) ) {\n if ( ( width < image -> columns ) && ( height < image -> rows ) ) low = draw_info -> pointsize + 0.5 ;\n else high = draw_info -> pointsize - 0.5 ;\n }\n else if ( ( ( image -> columns != 0 ) && ( width < image -> columns ) ) || ( ( image -> rows != 0 ) && ( height < image -> rows ) ) ) low = draw_info -> pointsize + 0.5 ;\n else high = draw_info -> pointsize - 0.5 ;\n }\n draw_info -> pointsize = floor ( ( low + high ) / 2.0 - 0.5 ) ;\n }\n i = FormatMagickCaption ( image , draw_info , split , & metrics , & caption ) ;\n ( void ) CloneString ( & draw_info -> text , caption ) ;\n ( void ) FormatLocaleString ( geometry , MaxTextExtent , \"%+g%+g\" , MagickMax ( draw_info -> direction == RightToLeftDirection ? image -> columns - metrics . bounds . x2 : - metrics . bounds . x1 , 0.0 ) , draw_info -> gravity == UndefinedGravity ? metrics . ascent : 0.0 ) ;\n ( void ) CloneString ( & draw_info -> geometry , geometry ) ;\n status = AnnotateImage ( image , draw_info ) ;\n if ( image_info -> pointsize == 0.0 ) {\n char pointsize [ MaxTextExtent ] ;\n ( void ) FormatLocaleString ( pointsize , MaxTextExtent , \"%.20g\" , draw_info -> pointsize ) ;\n ( void ) SetImageProperty ( image , \"caption:pointsize\" , pointsize ) ;\n }\n draw_info = DestroyDrawInfo ( draw_info ) ;\n caption = DestroyString ( caption ) ;\n if ( status == MagickFalse ) {\n image = DestroyImageList ( image ) ;\n return ( ( Image * ) NULL ) ;\n }\n return ( GetFirstImageInList ( image ) ) ;\n }", "idx": 52}
{"hash": -2127895299879503273, "project": "debian", "size": 8, "label": 0, "functionSource": "static void pmac_ide_writel ( void * opaque , hwaddr addr , uint32_t val ) {\n MACIOIDEState * d = opaque ;\n addr = ( addr & 0xFFF ) >> 4 ;\n val = bswap32 ( val ) ;\n if ( addr == 0 ) {\n ide_data_writel ( & d -> bus , 0 , val ) ;\n }\n }", "idx": 53}
{"hash": -2323311514228246061, "project": "chrome", "size": 3, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( DownloadsApiTest , DownloadsApiTest ) {\n ASSERT_TRUE ( RunExtensionTest ( \"downloads\" ) ) << message_ ;\n }", "idx": 54}
{"hash": 9173144338563772419, "project": "debian", "size": 65, "label": 0, "functionSource": "int main ( void ) {\n int result = OK ;\n process_cgivars ( ) ;\n reset_cgi_vars ( ) ;\n result = read_cgi_config_file ( get_cgi_config_location ( ) ) ;\n if ( result == ERROR ) {\n document_header ( CGI_ID , FALSE , \"Error\" ) ;\n print_error ( get_cgi_config_location ( ) , ERROR_CGI_CFG_FILE ) ;\n document_footer ( CGI_ID ) ;\n return ERROR ;\n }\n result = read_main_config_file ( main_config_file ) ;\n if ( result == ERROR ) {\n document_header ( CGI_ID , FALSE , \"Error\" ) ;\n print_error ( main_config_file , ERROR_CGI_MAIN_CFG ) ;\n document_footer ( CGI_ID ) ;\n return ERROR ;\n }\n strcpy ( command_file , get_cmd_file_location ( ) ) ;\n if ( strcmp ( start_time_string , \"\" ) ) string_to_time ( start_time_string , & start_time ) ;\n if ( strcmp ( end_time_string , \"\" ) ) string_to_time ( end_time_string , & end_time ) ;\n result = read_all_object_configuration_data ( main_config_file , READ_ALL_OBJECT_DATA ) ;\n if ( result == ERROR ) {\n document_header ( CGI_ID , FALSE , \"Error\" ) ;\n print_error ( NULL , ERROR_CGI_OBJECT_DATA ) ;\n document_footer ( CGI_ID ) ;\n return ERROR ;\n }\n result = read_all_status_data ( get_cgi_config_location ( ) , READ_ALL_STATUS_DATA ) ;\n if ( result == ERROR && daemon_check == TRUE ) {\n document_header ( CGI_ID , FALSE , \"Error\" ) ;\n print_error ( NULL , ERROR_CGI_STATUS_DATA ) ;\n document_footer ( CGI_ID ) ;\n free_memory ( ) ;\n return ERROR ;\n }\n document_header ( CGI_ID , TRUE , \"External Command Interface\" ) ;\n get_authentication_information ( & current_authdata ) ;\n if ( display_header == TRUE ) {\n printf ( \"\\n<!-- Image \\\"stop.png\\\" has been taken from \\\"http://fedoraproject.org/wiki/Template:Admon/caution\\\" -->\\n\\n\" ) ;\n printf ( \"<table border=0 width=100%%>\\n\" ) ;\n printf ( \"<tr>\\n\" ) ;\n printf ( \"<td align=left valign=top width=33%%>\\n\" ) ;\n display_info_table ( \"External Command Interface\" , & current_authdata , daemon_check ) ;\n printf ( \"</td>\\n\" ) ;\n printf ( \"<td align=center valign=top width=33%%>\\n\" ) ;\n printf ( \"</td>\\n\" ) ;\n printf ( \"<td align=right valign=bottom width=33%%>\\n\" ) ;\n printf ( \"</td>\\n\" ) ;\n printf ( \"</tr>\\n\" ) ;\n printf ( \"</table>\\n\" ) ;\n }\n if ( command_type == CMD_NONE ) {\n print_generic_error_message ( \"Error: No command was specified!\" , NULL , 2 ) ;\n }\n else if ( is_authorized_for_read_only ( & current_authdata ) == TRUE ) {\n print_generic_error_message ( \"Error: It appears as though you do not have permission to perform any commands!\" , NULL , 1 ) ;\n }\n else if ( command_mode == CMDMODE_REQUEST ) request_command_data ( command_type ) ;\n else if ( command_mode == CMDMODE_COMMIT ) commit_command_data ( command_type ) ;\n document_footer ( CGI_ID ) ;\n free_memory ( ) ;\n free_object_data ( ) ;\n return OK ;\n }", "idx": 55}
{"hash": 2830888773500127914, "project": "debian", "size": 10, "label": 0, "functionSource": "static void check_for_pg_role_prefix ( ClusterInfo * cluster ) {\n PGresult * res ;\n PGconn * conn = connectToServer ( cluster , \"template1\" ) ;\n prep_status ( \"Checking for roles starting with 'pg_'\" ) ;\n res = executeQueryOrDie ( conn , \"SELECT * \" \"FROM pg_catalog.pg_roles \" \"WHERE rolname ~ '^pg_'\" ) ;\n if ( PQntuples ( res ) != 0 ) pg_fatal ( \"The %s cluster contains roles starting with 'pg_'\\n\" , CLUSTER_NAME ( cluster ) ) ;\n PQclear ( res ) ;\n PQfinish ( conn ) ;\n check_ok ( ) ;\n }", "idx": 56}
{"hash": 8801969307247112896, "project": "debian", "size": 411, "label": 1, "functionSource": "const EVP_CIPHER * EVP_aes_ ## keylen ## _ ## mode ( void ) \\ {\n return & aes_ ## keylen ## _ ## mode ;\n }\n # endif # if defined ( OPENSSL_CPUID_OBJ ) && ( defined ( __arm__ ) || defined ( __arm ) || defined ( __aarch64__ ) ) # include \"arm_arch.h\" # if __ARM_MAX_ARCH__ >= 7 # if defined ( BSAES_ASM ) # define BSAES_CAPABLE ( OPENSSL_armcap_P & ARMV7_NEON ) # endif # if defined ( VPAES_ASM ) # define VPAES_CAPABLE ( OPENSSL_armcap_P & ARMV7_NEON ) # endif # define HWAES_CAPABLE ( OPENSSL_armcap_P & ARMV8_AES ) # define HWAES_set_encrypt_key aes_v8_set_encrypt_key # define HWAES_set_decrypt_key aes_v8_set_decrypt_key # define HWAES_encrypt aes_v8_encrypt # define HWAES_decrypt aes_v8_decrypt # define HWAES_cbc_encrypt aes_v8_cbc_encrypt # define HWAES_ctr32_encrypt_blocks aes_v8_ctr32_encrypt_blocks # endif # endif # if defined ( HWAES_CAPABLE ) int HWAES_set_encrypt_key ( const unsigned char * userKey , const int bits , AES_KEY * key ) ;\n int HWAES_set_decrypt_key ( const unsigned char * userKey , const int bits , AES_KEY * key ) ;\n void HWAES_encrypt ( const unsigned char * in , unsigned char * out , const AES_KEY * key ) ;\n void HWAES_decrypt ( const unsigned char * in , unsigned char * out , const AES_KEY * key ) ;\n void HWAES_cbc_encrypt ( const unsigned char * in , unsigned char * out , size_t length , const AES_KEY * key , unsigned char * ivec , const int enc ) ;\n void HWAES_ctr32_encrypt_blocks ( const unsigned char * in , unsigned char * out , size_t len , const AES_KEY * key , const unsigned char ivec [ 16 ] ) ;\n void HWAES_xts_encrypt ( const unsigned char * inp , unsigned char * out , size_t len , const AES_KEY * key1 , const AES_KEY * key2 , const unsigned char iv [ 16 ] ) ;\n void HWAES_xts_decrypt ( const unsigned char * inp , unsigned char * out , size_t len , const AES_KEY * key1 , const AES_KEY * key2 , const unsigned char iv [ 16 ] ) ;\n # endif # define BLOCK_CIPHER_generic_pack ( nid , keylen , flags ) \\ BLOCK_CIPHER_generic ( nid , keylen , 16 , 16 , cbc , cbc , CBC , flags | EVP_CIPH_FLAG_DEFAULT_ASN1 ) \\ BLOCK_CIPHER_generic ( nid , keylen , 16 , 0 , ecb , ecb , ECB , flags | EVP_CIPH_FLAG_DEFAULT_ASN1 ) \\ BLOCK_CIPHER_generic ( nid , keylen , 1 , 16 , ofb128 , ofb , OFB , flags | EVP_CIPH_FLAG_DEFAULT_ASN1 ) \\ BLOCK_CIPHER_generic ( nid , keylen , 1 , 16 , cfb128 , cfb , CFB , flags | EVP_CIPH_FLAG_DEFAULT_ASN1 ) \\ BLOCK_CIPHER_generic ( nid , keylen , 1 , 16 , cfb1 , cfb1 , CFB , flags ) \\ BLOCK_CIPHER_generic ( nid , keylen , 1 , 16 , cfb8 , cfb8 , CFB , flags ) \\ BLOCK_CIPHER_generic ( nid , keylen , 1 , 16 , ctr , ctr , CTR , flags ) static int aes_init_key ( EVP_CIPHER_CTX * ctx , const unsigned char * key , const unsigned char * iv , int enc ) {\n int ret , mode ;\n EVP_AES_KEY * dat = EVP_C_DATA ( EVP_AES_KEY , ctx ) ;\n mode = EVP_CIPHER_CTX_mode ( ctx ) ;\n if ( ( mode == EVP_CIPH_ECB_MODE || mode == EVP_CIPH_CBC_MODE ) && ! enc ) {\n # ifdef HWAES_CAPABLE if ( HWAES_CAPABLE ) {\n ret = HWAES_set_decrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & dat -> ks . ks ) ;\n dat -> block = ( block128_f ) HWAES_decrypt ;\n dat -> stream . cbc = NULL ;\n # ifdef HWAES_cbc_encrypt if ( mode == EVP_CIPH_CBC_MODE ) dat -> stream . cbc = ( cbc128_f ) HWAES_cbc_encrypt ;\n # endif }\n else # endif # ifdef BSAES_CAPABLE if ( BSAES_CAPABLE && mode == EVP_CIPH_CBC_MODE ) {\n ret = AES_set_decrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & dat -> ks . ks ) ;\n dat -> block = ( block128_f ) AES_decrypt ;\n dat -> stream . cbc = ( cbc128_f ) bsaes_cbc_encrypt ;\n }\n else # endif # ifdef VPAES_CAPABLE if ( VPAES_CAPABLE ) {\n ret = vpaes_set_decrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & dat -> ks . ks ) ;\n dat -> block = ( block128_f ) vpaes_decrypt ;\n dat -> stream . cbc = mode == EVP_CIPH_CBC_MODE ? ( cbc128_f ) vpaes_cbc_encrypt : NULL ;\n }\n else # endif {\n ret = AES_set_decrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & dat -> ks . ks ) ;\n dat -> block = ( block128_f ) AES_decrypt ;\n dat -> stream . cbc = mode == EVP_CIPH_CBC_MODE ? ( cbc128_f ) AES_cbc_encrypt : NULL ;\n }\n }\n else # ifdef HWAES_CAPABLE if ( HWAES_CAPABLE ) {\n ret = HWAES_set_encrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & dat -> ks . ks ) ;\n dat -> block = ( block128_f ) HWAES_encrypt ;\n dat -> stream . cbc = NULL ;\n # ifdef HWAES_cbc_encrypt if ( mode == EVP_CIPH_CBC_MODE ) dat -> stream . cbc = ( cbc128_f ) HWAES_cbc_encrypt ;\n else # endif # ifdef HWAES_ctr32_encrypt_blocks if ( mode == EVP_CIPH_CTR_MODE ) dat -> stream . ctr = ( ctr128_f ) HWAES_ctr32_encrypt_blocks ;\n else # endif ( void ) 0 ;\n }\n else # endif # ifdef BSAES_CAPABLE if ( BSAES_CAPABLE && mode == EVP_CIPH_CTR_MODE ) {\n ret = AES_set_encrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & dat -> ks . ks ) ;\n dat -> block = ( block128_f ) AES_encrypt ;\n dat -> stream . ctr = ( ctr128_f ) bsaes_ctr32_encrypt_blocks ;\n }\n else # endif # ifdef VPAES_CAPABLE if ( VPAES_CAPABLE ) {\n ret = vpaes_set_encrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & dat -> ks . ks ) ;\n dat -> block = ( block128_f ) vpaes_encrypt ;\n dat -> stream . cbc = mode == EVP_CIPH_CBC_MODE ? ( cbc128_f ) vpaes_cbc_encrypt : NULL ;\n }\n else # endif {\n ret = AES_set_encrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & dat -> ks . ks ) ;\n dat -> block = ( block128_f ) AES_encrypt ;\n dat -> stream . cbc = mode == EVP_CIPH_CBC_MODE ? ( cbc128_f ) AES_cbc_encrypt : NULL ;\n # ifdef AES_CTR_ASM if ( mode == EVP_CIPH_CTR_MODE ) dat -> stream . ctr = ( ctr128_f ) AES_ctr32_encrypt ;\n # endif }\n if ( ret < 0 ) {\n EVPerr ( EVP_F_AES_INIT_KEY , EVP_R_AES_KEY_SETUP_FAILED ) ;\n return 0 ;\n }\n return 1 ;\n }\n static int aes_cbc_cipher ( EVP_CIPHER_CTX * ctx , unsigned char * out , const unsigned char * in , size_t len ) {\n EVP_AES_KEY * dat = EVP_C_DATA ( EVP_AES_KEY , ctx ) ;\n if ( dat -> stream . cbc ) ( * dat -> stream . cbc ) ( in , out , len , & dat -> ks , EVP_CIPHER_CTX_iv_noconst ( ctx ) , EVP_CIPHER_CTX_encrypting ( ctx ) ) ;\n else if ( EVP_CIPHER_CTX_encrypting ( ctx ) ) CRYPTO_cbc128_encrypt ( in , out , len , & dat -> ks , EVP_CIPHER_CTX_iv_noconst ( ctx ) , dat -> block ) ;\n else CRYPTO_cbc128_decrypt ( in , out , len , & dat -> ks , EVP_CIPHER_CTX_iv_noconst ( ctx ) , dat -> block ) ;\n return 1 ;\n }\n static int aes_ecb_cipher ( EVP_CIPHER_CTX * ctx , unsigned char * out , const unsigned char * in , size_t len ) {\n size_t bl = EVP_CIPHER_CTX_block_size ( ctx ) ;\n size_t i ;\n EVP_AES_KEY * dat = EVP_C_DATA ( EVP_AES_KEY , ctx ) ;\n if ( len < bl ) return 1 ;\n for ( i = 0 , len -= bl ;\n i <= len ;\n i += bl ) ( * dat -> block ) ( in + i , out + i , & dat -> ks ) ;\n return 1 ;\n }\n static int aes_ofb_cipher ( EVP_CIPHER_CTX * ctx , unsigned char * out , const unsigned char * in , size_t len ) {\n EVP_AES_KEY * dat = EVP_C_DATA ( EVP_AES_KEY , ctx ) ;\n int num = EVP_CIPHER_CTX_num ( ctx ) ;\n CRYPTO_ofb128_encrypt ( in , out , len , & dat -> ks , EVP_CIPHER_CTX_iv_noconst ( ctx ) , & num , dat -> block ) ;\n EVP_CIPHER_CTX_set_num ( ctx , num ) ;\n return 1 ;\n }\n static int aes_cfb_cipher ( EVP_CIPHER_CTX * ctx , unsigned char * out , const unsigned char * in , size_t len ) {\n EVP_AES_KEY * dat = EVP_C_DATA ( EVP_AES_KEY , ctx ) ;\n int num = EVP_CIPHER_CTX_num ( ctx ) ;\n CRYPTO_cfb128_encrypt ( in , out , len , & dat -> ks , EVP_CIPHER_CTX_iv_noconst ( ctx ) , & num , EVP_CIPHER_CTX_encrypting ( ctx ) , dat -> block ) ;\n EVP_CIPHER_CTX_set_num ( ctx , num ) ;\n return 1 ;\n }\n static int aes_cfb8_cipher ( EVP_CIPHER_CTX * ctx , unsigned char * out , const unsigned char * in , size_t len ) {\n EVP_AES_KEY * dat = EVP_C_DATA ( EVP_AES_KEY , ctx ) ;\n int num = EVP_CIPHER_CTX_num ( ctx ) ;\n CRYPTO_cfb128_8_encrypt ( in , out , len , & dat -> ks , EVP_CIPHER_CTX_iv_noconst ( ctx ) , & num , EVP_CIPHER_CTX_encrypting ( ctx ) , dat -> block ) ;\n EVP_CIPHER_CTX_set_num ( ctx , num ) ;\n return 1 ;\n }\n static int aes_cfb1_cipher ( EVP_CIPHER_CTX * ctx , unsigned char * out , const unsigned char * in , size_t len ) {\n EVP_AES_KEY * dat = EVP_C_DATA ( EVP_AES_KEY , ctx ) ;\n if ( EVP_CIPHER_CTX_test_flags ( ctx , EVP_CIPH_FLAG_LENGTH_BITS ) ) {\n int num = EVP_CIPHER_CTX_num ( ctx ) ;\n CRYPTO_cfb128_1_encrypt ( in , out , len , & dat -> ks , EVP_CIPHER_CTX_iv_noconst ( ctx ) , & num , EVP_CIPHER_CTX_encrypting ( ctx ) , dat -> block ) ;\n EVP_CIPHER_CTX_set_num ( ctx , num ) ;\n return 1 ;\n }\n while ( len >= MAXBITCHUNK ) {\n int num = EVP_CIPHER_CTX_num ( ctx ) ;\n CRYPTO_cfb128_1_encrypt ( in , out , MAXBITCHUNK * 8 , & dat -> ks , EVP_CIPHER_CTX_iv_noconst ( ctx ) , & num , EVP_CIPHER_CTX_encrypting ( ctx ) , dat -> block ) ;\n EVP_CIPHER_CTX_set_num ( ctx , num ) ;\n len -= MAXBITCHUNK ;\n }\n if ( len ) {\n int num = EVP_CIPHER_CTX_num ( ctx ) ;\n CRYPTO_cfb128_1_encrypt ( in , out , len * 8 , & dat -> ks , EVP_CIPHER_CTX_iv_noconst ( ctx ) , & num , EVP_CIPHER_CTX_encrypting ( ctx ) , dat -> block ) ;\n EVP_CIPHER_CTX_set_num ( ctx , num ) ;\n }\n return 1 ;\n }\n static int aes_ctr_cipher ( EVP_CIPHER_CTX * ctx , unsigned char * out , const unsigned char * in , size_t len ) {\n unsigned int num = EVP_CIPHER_CTX_num ( ctx ) ;\n EVP_AES_KEY * dat = EVP_C_DATA ( EVP_AES_KEY , ctx ) ;\n if ( dat -> stream . ctr ) CRYPTO_ctr128_encrypt_ctr32 ( in , out , len , & dat -> ks , EVP_CIPHER_CTX_iv_noconst ( ctx ) , EVP_CIPHER_CTX_buf_noconst ( ctx ) , & num , dat -> stream . ctr ) ;\n else CRYPTO_ctr128_encrypt ( in , out , len , & dat -> ks , EVP_CIPHER_CTX_iv_noconst ( ctx ) , EVP_CIPHER_CTX_buf_noconst ( ctx ) , & num , dat -> block ) ;\n EVP_CIPHER_CTX_set_num ( ctx , num ) ;\n return 1 ;\n }\n BLOCK_CIPHER_generic_pack ( NID_aes , 128 , 0 ) BLOCK_CIPHER_generic_pack ( NID_aes , 192 , 0 ) BLOCK_CIPHER_generic_pack ( NID_aes , 256 , 0 ) static int aes_gcm_cleanup ( EVP_CIPHER_CTX * c ) {\n EVP_AES_GCM_CTX * gctx = EVP_C_DATA ( EVP_AES_GCM_CTX , c ) ;\n OPENSSL_cleanse ( & gctx -> gcm , sizeof ( gctx -> gcm ) ) ;\n if ( gctx -> iv != EVP_CIPHER_CTX_iv_noconst ( c ) ) OPENSSL_free ( gctx -> iv ) ;\n return 1 ;\n }\n static void ctr64_inc ( unsigned char * counter ) {\n int n = 8 ;\n unsigned char c ;\n do {\n -- n ;\n c = counter [ n ] ;\n ++ c ;\n counter [ n ] = c ;\n if ( c ) return ;\n }\n while ( n ) ;\n }\n static int aes_gcm_ctrl ( EVP_CIPHER_CTX * c , int type , int arg , void * ptr ) {\n EVP_AES_GCM_CTX * gctx = EVP_C_DATA ( EVP_AES_GCM_CTX , c ) ;\n switch ( type ) {\n case EVP_CTRL_INIT : gctx -> key_set = 0 ;\n gctx -> iv_set = 0 ;\n gctx -> ivlen = EVP_CIPHER_CTX_iv_length ( c ) ;\n gctx -> iv = EVP_CIPHER_CTX_iv_noconst ( c ) ;\n gctx -> taglen = - 1 ;\n gctx -> iv_gen = 0 ;\n gctx -> tls_aad_len = - 1 ;\n return 1 ;\n case EVP_CTRL_AEAD_SET_IVLEN : if ( arg <= 0 ) return 0 ;\n if ( ( arg > EVP_MAX_IV_LENGTH ) && ( arg > gctx -> ivlen ) ) {\n if ( gctx -> iv != EVP_CIPHER_CTX_iv_noconst ( c ) ) OPENSSL_free ( gctx -> iv ) ;\n gctx -> iv = OPENSSL_malloc ( arg ) ;\n if ( gctx -> iv == NULL ) return 0 ;\n }\n gctx -> ivlen = arg ;\n return 1 ;\n case EVP_CTRL_AEAD_SET_TAG : if ( arg <= 0 || arg > 16 || EVP_CIPHER_CTX_encrypting ( c ) ) return 0 ;\n memcpy ( EVP_CIPHER_CTX_buf_noconst ( c ) , ptr , arg ) ;\n gctx -> taglen = arg ;\n return 1 ;\n case EVP_CTRL_AEAD_GET_TAG : if ( arg <= 0 || arg > 16 || ! EVP_CIPHER_CTX_encrypting ( c ) || gctx -> taglen < 0 ) return 0 ;\n memcpy ( ptr , EVP_CIPHER_CTX_buf_noconst ( c ) , arg ) ;\n return 1 ;\n case EVP_CTRL_GCM_SET_IV_FIXED : if ( arg == - 1 ) {\n memcpy ( gctx -> iv , ptr , gctx -> ivlen ) ;\n gctx -> iv_gen = 1 ;\n return 1 ;\n }\n if ( ( arg < 4 ) || ( gctx -> ivlen - arg ) < 8 ) return 0 ;\n if ( arg ) memcpy ( gctx -> iv , ptr , arg ) ;\n if ( EVP_CIPHER_CTX_encrypting ( c ) && RAND_bytes ( gctx -> iv + arg , gctx -> ivlen - arg ) <= 0 ) return 0 ;\n gctx -> iv_gen = 1 ;\n return 1 ;\n case EVP_CTRL_GCM_IV_GEN : if ( gctx -> iv_gen == 0 || gctx -> key_set == 0 ) return 0 ;\n CRYPTO_gcm128_setiv ( & gctx -> gcm , gctx -> iv , gctx -> ivlen ) ;\n if ( arg <= 0 || arg > gctx -> ivlen ) arg = gctx -> ivlen ;\n memcpy ( ptr , gctx -> iv + gctx -> ivlen - arg , arg ) ;\n ctr64_inc ( gctx -> iv + gctx -> ivlen - 8 ) ;\n gctx -> iv_set = 1 ;\n return 1 ;\n case EVP_CTRL_GCM_SET_IV_INV : if ( gctx -> iv_gen == 0 || gctx -> key_set == 0 || EVP_CIPHER_CTX_encrypting ( c ) ) return 0 ;\n memcpy ( gctx -> iv + gctx -> ivlen - arg , ptr , arg ) ;\n CRYPTO_gcm128_setiv ( & gctx -> gcm , gctx -> iv , gctx -> ivlen ) ;\n gctx -> iv_set = 1 ;\n return 1 ;\n case EVP_CTRL_AEAD_TLS1_AAD : if ( arg != EVP_AEAD_TLS1_AAD_LEN ) return 0 ;\n memcpy ( EVP_CIPHER_CTX_buf_noconst ( c ) , ptr , arg ) ;\n gctx -> tls_aad_len = arg ;\n {\n unsigned int len = EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 2 ] << 8 | EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 1 ] ;\n len -= EVP_GCM_TLS_EXPLICIT_IV_LEN ;\n if ( ! EVP_CIPHER_CTX_encrypting ( c ) ) len -= EVP_GCM_TLS_TAG_LEN ;\n EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 2 ] = len >> 8 ;\n EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 1 ] = len & 0xff ;\n }\n return EVP_GCM_TLS_TAG_LEN ;\n case EVP_CTRL_COPY : {\n EVP_CIPHER_CTX * out = ptr ;\n EVP_AES_GCM_CTX * gctx_out = EVP_C_DATA ( EVP_AES_GCM_CTX , out ) ;\n if ( gctx -> gcm . key ) {\n if ( gctx -> gcm . key != & gctx -> ks ) return 0 ;\n gctx_out -> gcm . key = & gctx_out -> ks ;\n }\n if ( gctx -> iv == EVP_CIPHER_CTX_iv_noconst ( c ) ) gctx_out -> iv = EVP_CIPHER_CTX_iv_noconst ( out ) ;\n else {\n gctx_out -> iv = OPENSSL_malloc ( gctx -> ivlen ) ;\n if ( gctx_out -> iv == NULL ) return 0 ;\n memcpy ( gctx_out -> iv , gctx -> iv , gctx -> ivlen ) ;\n }\n return 1 ;\n }\n default : return - 1 ;\n }\n }\n static int aes_gcm_init_key ( EVP_CIPHER_CTX * ctx , const unsigned char * key , const unsigned char * iv , int enc ) {\n EVP_AES_GCM_CTX * gctx = EVP_C_DATA ( EVP_AES_GCM_CTX , ctx ) ;\n if ( ! iv && ! key ) return 1 ;\n if ( key ) {\n do {\n # ifdef HWAES_CAPABLE if ( HWAES_CAPABLE ) {\n HWAES_set_encrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & gctx -> ks . ks ) ;\n CRYPTO_gcm128_init ( & gctx -> gcm , & gctx -> ks , ( block128_f ) HWAES_encrypt ) ;\n # ifdef HWAES_ctr32_encrypt_blocks gctx -> ctr = ( ctr128_f ) HWAES_ctr32_encrypt_blocks ;\n # else gctx -> ctr = NULL ;\n # endif break ;\n }\n else # endif # ifdef BSAES_CAPABLE if ( BSAES_CAPABLE ) {\n AES_set_encrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & gctx -> ks . ks ) ;\n CRYPTO_gcm128_init ( & gctx -> gcm , & gctx -> ks , ( block128_f ) AES_encrypt ) ;\n gctx -> ctr = ( ctr128_f ) bsaes_ctr32_encrypt_blocks ;\n break ;\n }\n else # endif # ifdef VPAES_CAPABLE if ( VPAES_CAPABLE ) {\n vpaes_set_encrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & gctx -> ks . ks ) ;\n CRYPTO_gcm128_init ( & gctx -> gcm , & gctx -> ks , ( block128_f ) vpaes_encrypt ) ;\n gctx -> ctr = NULL ;\n break ;\n }\n else # endif ( void ) 0 ;\n AES_set_encrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & gctx -> ks . ks ) ;\n CRYPTO_gcm128_init ( & gctx -> gcm , & gctx -> ks , ( block128_f ) AES_encrypt ) ;\n # ifdef AES_CTR_ASM gctx -> ctr = ( ctr128_f ) AES_ctr32_encrypt ;\n # else gctx -> ctr = NULL ;\n # endif }\n while ( 0 ) ;\n if ( iv == NULL && gctx -> iv_set ) iv = gctx -> iv ;\n if ( iv ) {\n CRYPTO_gcm128_setiv ( & gctx -> gcm , iv , gctx -> ivlen ) ;\n gctx -> iv_set = 1 ;\n }\n gctx -> key_set = 1 ;\n }\n else {\n if ( gctx -> key_set ) CRYPTO_gcm128_setiv ( & gctx -> gcm , iv , gctx -> ivlen ) ;\n else memcpy ( gctx -> iv , iv , gctx -> ivlen ) ;\n gctx -> iv_set = 1 ;\n gctx -> iv_gen = 0 ;\n }\n return 1 ;\n }\n static int aes_gcm_tls_cipher ( EVP_CIPHER_CTX * ctx , unsigned char * out , const unsigned char * in , size_t len ) {\n EVP_AES_GCM_CTX * gctx = EVP_C_DATA ( EVP_AES_GCM_CTX , ctx ) ;\n int rv = - 1 ;\n if ( out != in || len < ( EVP_GCM_TLS_EXPLICIT_IV_LEN + EVP_GCM_TLS_TAG_LEN ) ) return - 1 ;\n if ( EVP_CIPHER_CTX_ctrl ( ctx , EVP_CIPHER_CTX_encrypting ( ctx ) ? EVP_CTRL_GCM_IV_GEN : EVP_CTRL_GCM_SET_IV_INV , EVP_GCM_TLS_EXPLICIT_IV_LEN , out ) <= 0 ) goto err ;\n if ( CRYPTO_gcm128_aad ( & gctx -> gcm , EVP_CIPHER_CTX_buf_noconst ( ctx ) , gctx -> tls_aad_len ) ) goto err ;\n in += EVP_GCM_TLS_EXPLICIT_IV_LEN ;\n out += EVP_GCM_TLS_EXPLICIT_IV_LEN ;\n len -= EVP_GCM_TLS_EXPLICIT_IV_LEN + EVP_GCM_TLS_TAG_LEN ;\n if ( EVP_CIPHER_CTX_encrypting ( ctx ) ) {\n if ( gctx -> ctr ) {\n size_t bulk = 0 ;\n # if defined ( AES_GCM_ASM ) if ( len >= 32 && AES_GCM_ASM ( gctx ) ) {\n if ( CRYPTO_gcm128_encrypt ( & gctx -> gcm , NULL , NULL , 0 ) ) return - 1 ;\n bulk = AES_gcm_encrypt ( in , out , len , gctx -> gcm . key , gctx -> gcm . Yi . c , gctx -> gcm . Xi . u ) ;\n gctx -> gcm . len . u [ 1 ] += bulk ;\n }\n # endif if ( CRYPTO_gcm128_encrypt_ctr32 ( & gctx -> gcm , in + bulk , out + bulk , len - bulk , gctx -> ctr ) ) goto err ;\n }\n else {\n size_t bulk = 0 ;\n # if defined ( AES_GCM_ASM2 ) if ( len >= 32 && AES_GCM_ASM2 ( gctx ) ) {\n if ( CRYPTO_gcm128_encrypt ( & gctx -> gcm , NULL , NULL , 0 ) ) return - 1 ;\n bulk = AES_gcm_encrypt ( in , out , len , gctx -> gcm . key , gctx -> gcm . Yi . c , gctx -> gcm . Xi . u ) ;\n gctx -> gcm . len . u [ 1 ] += bulk ;\n }\n # endif if ( CRYPTO_gcm128_encrypt ( & gctx -> gcm , in + bulk , out + bulk , len - bulk ) ) goto err ;\n }\n out += len ;\n CRYPTO_gcm128_tag ( & gctx -> gcm , out , EVP_GCM_TLS_TAG_LEN ) ;\n rv = len + EVP_GCM_TLS_EXPLICIT_IV_LEN + EVP_GCM_TLS_TAG_LEN ;\n }\n else {\n if ( gctx -> ctr ) {\n size_t bulk = 0 ;\n # if defined ( AES_GCM_ASM ) if ( len >= 16 && AES_GCM_ASM ( gctx ) ) {\n if ( CRYPTO_gcm128_decrypt ( & gctx -> gcm , NULL , NULL , 0 ) ) return - 1 ;\n bulk = AES_gcm_decrypt ( in , out , len , gctx -> gcm . key , gctx -> gcm . Yi . c , gctx -> gcm . Xi . u ) ;\n gctx -> gcm . len . u [ 1 ] += bulk ;\n }\n # endif if ( CRYPTO_gcm128_decrypt_ctr32 ( & gctx -> gcm , in + bulk , out + bulk , len - bulk , gctx -> ctr ) ) goto err ;\n }\n else {\n size_t bulk = 0 ;\n # if defined ( AES_GCM_ASM2 ) if ( len >= 16 && AES_GCM_ASM2 ( gctx ) ) {\n if ( CRYPTO_gcm128_decrypt ( & gctx -> gcm , NULL , NULL , 0 ) ) return - 1 ;\n bulk = AES_gcm_decrypt ( in , out , len , gctx -> gcm . key , gctx -> gcm . Yi . c , gctx -> gcm . Xi . u ) ;\n gctx -> gcm . len . u [ 1 ] += bulk ;\n }\n # endif if ( CRYPTO_gcm128_decrypt ( & gctx -> gcm , in + bulk , out + bulk , len - bulk ) ) goto err ;\n }\n CRYPTO_gcm128_tag ( & gctx -> gcm , EVP_CIPHER_CTX_buf_noconst ( ctx ) , EVP_GCM_TLS_TAG_LEN ) ;\n if ( CRYPTO_memcmp ( EVP_CIPHER_CTX_buf_noconst ( ctx ) , in + len , EVP_GCM_TLS_TAG_LEN ) ) {\n OPENSSL_cleanse ( out , len ) ;\n goto err ;\n }\n rv = len ;\n }\n err : gctx -> iv_set = 0 ;\n gctx -> tls_aad_len = - 1 ;\n return rv ;\n }\n static int aes_gcm_cipher ( EVP_CIPHER_CTX * ctx , unsigned char * out , const unsigned char * in , size_t len ) {\n EVP_AES_GCM_CTX * gctx = EVP_C_DATA ( EVP_AES_GCM_CTX , ctx ) ;\n if ( ! gctx -> key_set ) return - 1 ;\n if ( gctx -> tls_aad_len >= 0 ) return aes_gcm_tls_cipher ( ctx , out , in , len ) ;\n if ( ! gctx -> iv_set ) return - 1 ;\n if ( in ) {\n if ( out == NULL ) {\n if ( CRYPTO_gcm128_aad ( & gctx -> gcm , in , len ) ) return - 1 ;\n }\n else if ( EVP_CIPHER_CTX_encrypting ( ctx ) ) {\n if ( gctx -> ctr ) {\n size_t bulk = 0 ;\n # if defined ( AES_GCM_ASM ) if ( len >= 32 && AES_GCM_ASM ( gctx ) ) {\n size_t res = ( 16 - gctx -> gcm . mres ) % 16 ;\n if ( CRYPTO_gcm128_encrypt ( & gctx -> gcm , in , out , res ) ) return - 1 ;\n bulk = AES_gcm_encrypt ( in + res , out + res , len - res , gctx -> gcm . key , gctx -> gcm . Yi . c , gctx -> gcm . Xi . u ) ;\n gctx -> gcm . len . u [ 1 ] += bulk ;\n bulk += res ;\n }\n # endif if ( CRYPTO_gcm128_encrypt_ctr32 ( & gctx -> gcm , in + bulk , out + bulk , len - bulk , gctx -> ctr ) ) return - 1 ;\n }\n else {\n size_t bulk = 0 ;\n # if defined ( AES_GCM_ASM2 ) if ( len >= 32 && AES_GCM_ASM2 ( gctx ) ) {\n size_t res = ( 16 - gctx -> gcm . mres ) % 16 ;\n if ( CRYPTO_gcm128_encrypt ( & gctx -> gcm , in , out , res ) ) return - 1 ;\n bulk = AES_gcm_encrypt ( in + res , out + res , len - res , gctx -> gcm . key , gctx -> gcm . Yi . c , gctx -> gcm . Xi . u ) ;\n gctx -> gcm . len . u [ 1 ] += bulk ;\n bulk += res ;\n }\n # endif if ( CRYPTO_gcm128_encrypt ( & gctx -> gcm , in + bulk , out + bulk , len - bulk ) ) return - 1 ;\n }\n }\n else {\n if ( gctx -> ctr ) {\n size_t bulk = 0 ;\n # if defined ( AES_GCM_ASM ) if ( len >= 16 && AES_GCM_ASM ( gctx ) ) {\n size_t res = ( 16 - gctx -> gcm . mres ) % 16 ;\n if ( CRYPTO_gcm128_decrypt ( & gctx -> gcm , in , out , res ) ) return - 1 ;\n bulk = AES_gcm_decrypt ( in + res , out + res , len - res , gctx -> gcm . key , gctx -> gcm . Yi . c , gctx -> gcm . Xi . u ) ;\n gctx -> gcm . len . u [ 1 ] += bulk ;\n bulk += res ;\n }\n # endif if ( CRYPTO_gcm128_decrypt_ctr32 ( & gctx -> gcm , in + bulk , out + bulk , len - bulk , gctx -> ctr ) ) return - 1 ;\n }\n else {\n size_t bulk = 0 ;\n # if defined ( AES_GCM_ASM2 ) if ( len >= 16 && AES_GCM_ASM2 ( gctx ) ) {\n size_t res = ( 16 - gctx -> gcm . mres ) % 16 ;\n if ( CRYPTO_gcm128_decrypt ( & gctx -> gcm , in , out , res ) ) return - 1 ;\n bulk = AES_gcm_decrypt ( in + res , out + res , len - res , gctx -> gcm . key , gctx -> gcm . Yi . c , gctx -> gcm . Xi . u ) ;\n gctx -> gcm . len . u [ 1 ] += bulk ;\n bulk += res ;\n }\n # endif if ( CRYPTO_gcm128_decrypt ( & gctx -> gcm , in + bulk , out + bulk , len - bulk ) ) return - 1 ;\n }\n }\n return len ;\n }\n else {\n if ( ! EVP_CIPHER_CTX_encrypting ( ctx ) ) {\n if ( gctx -> taglen < 0 ) return - 1 ;\n if ( CRYPTO_gcm128_finish ( & gctx -> gcm , EVP_CIPHER_CTX_buf_noconst ( ctx ) , gctx -> taglen ) != 0 ) return - 1 ;\n gctx -> iv_set = 0 ;\n return 0 ;\n }\n CRYPTO_gcm128_tag ( & gctx -> gcm , EVP_CIPHER_CTX_buf_noconst ( ctx ) , 16 ) ;\n gctx -> taglen = 16 ;\n gctx -> iv_set = 0 ;\n return 0 ;\n }\n }\n # define CUSTOM_FLAGS ( EVP_CIPH_FLAG_DEFAULT_ASN1 \\ | EVP_CIPH_CUSTOM_IV | EVP_CIPH_FLAG_CUSTOM_CIPHER \\ | EVP_CIPH_ALWAYS_CALL_INIT | EVP_CIPH_CTRL_INIT \\ | EVP_CIPH_CUSTOM_COPY ) BLOCK_CIPHER_custom ( NID_aes , 128 , 1 , 12 , gcm , GCM , EVP_CIPH_FLAG_AEAD_CIPHER | CUSTOM_FLAGS ) BLOCK_CIPHER_custom ( NID_aes , 192 , 1 , 12 , gcm , GCM , EVP_CIPH_FLAG_AEAD_CIPHER | CUSTOM_FLAGS ) BLOCK_CIPHER_custom ( NID_aes , 256 , 1 , 12 , gcm , GCM , EVP_CIPH_FLAG_AEAD_CIPHER | CUSTOM_FLAGS )", "idx": 57}
{"hash": 3426991998365732450, "project": "debian", "size": 7, "label": 0, "functionSource": "static void ps2_reset_keyboard ( PS2KbdState * s ) {\n trace_ps2_reset_keyboard ( s ) ;\n s -> scan_enabled = 1 ;\n s -> scancode_set = 2 ;\n ps2_reset_queue ( & s -> common ) ;\n ps2_set_ledstate ( s , 0 ) ;\n }", "idx": 58}
{"hash": -3559021711340554904, "project": "debian", "size": 102, "label": 1, "functionSource": "static Expr * inline_function ( Oid funcid , Oid result_type , Oid result_collid , Oid input_collid , List * args , bool funcvariadic , HeapTuple func_tuple , eval_const_expressions_context * context ) {\n Form_pg_proc funcform = ( Form_pg_proc ) GETSTRUCT ( func_tuple ) ;\n char * src ;\n Datum tmp ;\n bool isNull ;\n bool modifyTargetList ;\n MemoryContext oldcxt ;\n MemoryContext mycxt ;\n inline_error_callback_arg callback_arg ;\n ErrorContextCallback sqlerrcontext ;\n FuncExpr * fexpr ;\n SQLFunctionParseInfoPtr pinfo ;\n ParseState * pstate ;\n List * raw_parsetree_list ;\n Query * querytree ;\n Node * newexpr ;\n int * usecounts ;\n ListCell * arg ;\n int i ;\n if ( funcform -> prolang != SQLlanguageId || funcform -> prosecdef || funcform -> proretset || funcform -> prorettype == RECORDOID || ! heap_attisnull ( func_tuple , Anum_pg_proc_proconfig ) || funcform -> pronargs != list_length ( args ) ) return NULL ;\n if ( list_member_oid ( context -> active_fns , funcid ) ) return NULL ;\n if ( pg_proc_aclcheck ( funcid , GetUserId ( ) , ACL_EXECUTE ) != ACLCHECK_OK ) return NULL ;\n if ( FmgrHookIsNeeded ( funcid ) ) return NULL ;\n mycxt = AllocSetContextCreate ( CurrentMemoryContext , \"inline_function\" , ALLOCSET_DEFAULT_MINSIZE , ALLOCSET_DEFAULT_INITSIZE , ALLOCSET_DEFAULT_MAXSIZE ) ;\n oldcxt = MemoryContextSwitchTo ( mycxt ) ;\n tmp = SysCacheGetAttr ( PROCOID , func_tuple , Anum_pg_proc_prosrc , & isNull ) ;\n if ( isNull ) elog ( ERROR , \"null prosrc for function %u\" , funcid ) ;\n src = TextDatumGetCString ( tmp ) ;\n callback_arg . proname = NameStr ( funcform -> proname ) ;\n callback_arg . prosrc = src ;\n sqlerrcontext . callback = sql_inline_error_callback ;\n sqlerrcontext . arg = ( void * ) & callback_arg ;\n sqlerrcontext . previous = error_context_stack ;\n error_context_stack = & sqlerrcontext ;\n fexpr = makeNode ( FuncExpr ) ;\n fexpr -> funcid = funcid ;\n fexpr -> funcresulttype = result_type ;\n fexpr -> funcretset = false ;\n fexpr -> funcvariadic = funcvariadic ;\n fexpr -> funcformat = COERCE_EXPLICIT_CALL ;\n fexpr -> funccollid = result_collid ;\n fexpr -> inputcollid = input_collid ;\n fexpr -> args = args ;\n fexpr -> location = - 1 ;\n pinfo = prepare_sql_fn_parse_info ( func_tuple , ( Node * ) fexpr , input_collid ) ;\n raw_parsetree_list = pg_parse_query ( src ) ;\n if ( list_length ( raw_parsetree_list ) != 1 ) goto fail ;\n pstate = make_parsestate ( NULL ) ;\n pstate -> p_sourcetext = src ;\n sql_fn_parser_setup ( pstate , pinfo ) ;\n querytree = transformTopLevelStmt ( pstate , linitial ( raw_parsetree_list ) ) ;\n free_parsestate ( pstate ) ;\n if ( ! IsA ( querytree , Query ) || querytree -> commandType != CMD_SELECT || querytree -> utilityStmt || querytree -> hasAggs || querytree -> hasWindowFuncs || querytree -> hasSubLinks || querytree -> cteList || querytree -> rtable || querytree -> jointree -> fromlist || querytree -> jointree -> quals || querytree -> groupClause || querytree -> groupingSets || querytree -> havingQual || querytree -> windowClause || querytree -> distinctClause || querytree -> sortClause || querytree -> limitOffset || querytree -> limitCount || querytree -> setOperations || list_length ( querytree -> targetList ) != 1 ) goto fail ;\n if ( check_sql_fn_retval ( funcid , result_type , list_make1 ( querytree ) , & modifyTargetList , NULL ) ) goto fail ;\n newexpr = ( Node * ) ( ( TargetEntry * ) linitial ( querytree -> targetList ) ) -> expr ;\n Assert ( exprType ( newexpr ) == result_type ) ;\n Assert ( ! modifyTargetList ) ;\n if ( expression_returns_set ( newexpr ) ) goto fail ;\n if ( funcform -> provolatile == PROVOLATILE_IMMUTABLE && contain_mutable_functions ( newexpr ) ) goto fail ;\n else if ( funcform -> provolatile == PROVOLATILE_STABLE && contain_volatile_functions ( newexpr ) ) goto fail ;\n if ( funcform -> proisstrict && contain_nonstrict_functions ( newexpr ) ) goto fail ;\n usecounts = ( int * ) palloc0 ( funcform -> pronargs * sizeof ( int ) ) ;\n newexpr = substitute_actual_parameters ( newexpr , funcform -> pronargs , args , usecounts ) ;\n i = 0 ;\n foreach ( arg , args ) {\n Node * param = lfirst ( arg ) ;\n if ( usecounts [ i ] == 0 ) {\n if ( funcform -> proisstrict ) goto fail ;\n }\n else if ( usecounts [ i ] != 1 ) {\n QualCost eval_cost ;\n if ( contain_subplans ( param ) ) goto fail ;\n cost_qual_eval ( & eval_cost , list_make1 ( param ) , NULL ) ;\n if ( eval_cost . startup + eval_cost . per_tuple > 10 * cpu_operator_cost ) goto fail ;\n if ( contain_volatile_functions ( param ) ) goto fail ;\n }\n i ++ ;\n }\n MemoryContextSwitchTo ( oldcxt ) ;\n newexpr = copyObject ( newexpr ) ;\n MemoryContextDelete ( mycxt ) ;\n if ( OidIsValid ( result_collid ) ) {\n Oid exprcoll = exprCollation ( newexpr ) ;\n if ( OidIsValid ( exprcoll ) && exprcoll != result_collid ) {\n CollateExpr * newnode = makeNode ( CollateExpr ) ;\n newnode -> arg = ( Expr * ) newexpr ;\n newnode -> collOid = result_collid ;\n newnode -> location = - 1 ;\n newexpr = ( Node * ) newnode ;\n }\n }\n if ( context -> root ) record_plan_function_dependency ( context -> root , funcid ) ;\n context -> active_fns = lcons_oid ( funcid , context -> active_fns ) ;\n newexpr = eval_const_expressions_mutator ( newexpr , context ) ;\n context -> active_fns = list_delete_first ( context -> active_fns ) ;\n error_context_stack = sqlerrcontext . previous ;\n return ( Expr * ) newexpr ;\n fail : MemoryContextSwitchTo ( oldcxt ) ;\n MemoryContextDelete ( mycxt ) ;\n error_context_stack = sqlerrcontext . previous ;\n return NULL ;\n }", "idx": 59}
{"hash": -1055531103257174901, "project": "debian", "size": 5, "label": 0, "functionSource": "static void sig_message_private ( SERVER_REC * server , const char * msg , const char * nick , const char * address ) {\n g_return_if_fail ( server != NULL ) ;\n g_return_if_fail ( nick != NULL ) ;\n SERVER_LAST_MSG_ADD ( server , nick ) ;\n }", "idx": 60}
{"hash": 8445816931248660591, "project": "debian", "size": 29, "label": 0, "functionSource": "static void spl_dllist_it_helper_move_forward ( spl_ptr_llist_element * * traverse_pointer_ptr , int * traverse_position_ptr , spl_ptr_llist * llist , int flags TSRMLS_DC ) {\n if ( * traverse_pointer_ptr ) {\n spl_ptr_llist_element * old = * traverse_pointer_ptr ;\n if ( flags & SPL_DLLIST_IT_LIFO ) {\n * traverse_pointer_ptr = old -> prev ;\n ( * traverse_position_ptr ) -- ;\n if ( flags & SPL_DLLIST_IT_DELETE ) {\n zval * prev = ( zval * ) spl_ptr_llist_pop ( llist TSRMLS_CC ) ;\n if ( prev ) {\n zval_ptr_dtor ( ( zval * * ) & prev ) ;\n }\n }\n }\n else {\n * traverse_pointer_ptr = old -> next ;\n if ( flags & SPL_DLLIST_IT_DELETE ) {\n zval * prev = ( zval * ) spl_ptr_llist_shift ( llist TSRMLS_CC ) ;\n if ( prev ) {\n zval_ptr_dtor ( ( zval * * ) & prev ) ;\n }\n }\n else {\n ( * traverse_position_ptr ) ++ ;\n }\n }\n SPL_LLIST_DELREF ( old ) ;\n SPL_LLIST_CHECK_ADDREF ( * traverse_pointer_ptr ) ;\n }\n }", "idx": 61}
{"hash": 2895622461494525400, "project": "debian", "size": 36, "label": 0, "functionSource": "static void test_insert_select ( ) {\n MYSQL_STMT * stmt_insert , * stmt_select ;\n char * query ;\n int rc ;\n uint i ;\n myheader ( \"test_insert_select\" ) ;\n rc = mysql_query ( mysql , \"DROP TABLE IF EXISTS t1, t2\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"create table t1 (a int)\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"create table t2 (a int)\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"insert into t2 values (1)\" ) ;\n myquery ( rc ) ;\n query = ( char * ) \"insert into t1 select a from t2\" ;\n stmt_insert = mysql_simple_prepare ( mysql , query ) ;\n check_stmt ( stmt_insert ) ;\n query = ( char * ) \"select * from t1\" ;\n stmt_select = mysql_simple_prepare ( mysql , query ) ;\n check_stmt ( stmt_select ) ;\n for ( i = 0 ;\n i < 3 ;\n i ++ ) {\n rc = mysql_stmt_execute ( stmt_insert ) ;\n check_execute ( stmt_insert , rc ) ;\n if ( ! opt_silent ) fprintf ( stdout , \"insert %u\\n\" , i ) ;\n rc = mysql_stmt_execute ( stmt_select ) ;\n check_execute ( stmt_select , rc ) ;\n rc = my_process_stmt_result ( stmt_select ) ;\n DIE_UNLESS ( rc == ( int ) ( i + 1 ) ) ;\n }\n mysql_stmt_close ( stmt_insert ) ;\n mysql_stmt_close ( stmt_select ) ;\n rc = mysql_query ( mysql , \"drop table t1, t2\" ) ;\n myquery ( rc ) ;\n }", "idx": 62}
{"hash": -1929262071302712016, "project": "debian", "size": 5, "label": 0, "functionSource": "static void Type_NamedColor_Free ( struct _cms_typehandler_struct * self , void * Ptr ) {\n cmsFreeNamedColorList ( ( cmsNAMEDCOLORLIST * ) Ptr ) ;\n return ;\n cmsUNUSED_PARAMETER ( self ) ;\n }", "idx": 63}
{"hash": -8884965407551053630, "project": "debian", "size": 10, "label": 0, "functionSource": "static void DecoderUpdateFormatLocked ( decoder_t * p_dec ) {\n decoder_owner_sys_t * p_owner = p_dec -> p_owner ;\n vlc_assert_locked ( & p_owner -> lock ) ;\n p_owner -> b_fmt_description = true ;\n es_format_Clean ( & p_owner -> fmt_description ) ;\n es_format_Copy ( & p_owner -> fmt_description , & p_dec -> fmt_out ) ;\n if ( p_owner -> p_description && p_dec -> p_description ) vlc_meta_Delete ( p_owner -> p_description ) ;\n p_owner -> p_description = p_dec -> p_description ;\n p_dec -> p_description = NULL ;\n }", "idx": 64}
{"hash": -1315695702746584250, "project": "debian", "size": 3, "label": 0, "functionSource": "static void proto_tree_set_ether_tvb ( field_info * fi , tvbuff_t * tvb , gint start ) {\n proto_tree_set_ether ( fi , tvb_get_ptr ( tvb , start , FT_ETHER_LEN ) ) ;\n }", "idx": 65}
{"hash": 2521579609370336371, "project": "debian", "size": 359, "label": 1, "functionSource": "IMPLEMENT_dtls1_meth_func ( DTLSv1_server_method , dtls1_accept , ssl_undefined_function , dtls1_get_server_method ) int dtls1_accept ( SSL * s ) {\n BUF_MEM * buf ;\n unsigned long Time = ( unsigned long ) time ( NULL ) ;\n void ( * cb ) ( const SSL * ssl , int type , int val ) = NULL ;\n unsigned long alg_k ;\n int ret = - 1 ;\n int new_state , state , skip = 0 ;\n int listen ;\n # ifndef OPENSSL_NO_SCTP unsigned char sctpauthkey [ 64 ] ;\n char labelbuffer [ sizeof ( DTLS1_SCTP_AUTH_LABEL ) ] ;\n # endif RAND_add ( & Time , sizeof ( Time ) , 0 ) ;\n ERR_clear_error ( ) ;\n clear_sys_error ( ) ;\n if ( s -> info_callback != NULL ) cb = s -> info_callback ;\n else if ( s -> ctx -> info_callback != NULL ) cb = s -> ctx -> info_callback ;\n listen = s -> d1 -> listen ;\n s -> in_handshake ++ ;\n if ( ! SSL_in_init ( s ) || SSL_in_before ( s ) ) SSL_clear ( s ) ;\n s -> d1 -> listen = listen ;\n # ifndef OPENSSL_NO_SCTP BIO_ctrl ( SSL_get_wbio ( s ) , BIO_CTRL_DGRAM_SCTP_SET_IN_HANDSHAKE , s -> in_handshake , NULL ) ;\n # endif if ( s -> cert == NULL ) {\n SSLerr ( SSL_F_DTLS1_ACCEPT , SSL_R_NO_CERTIFICATE_SET ) ;\n return ( - 1 ) ;\n }\n # ifndef OPENSSL_NO_HEARTBEATS if ( s -> tlsext_hb_pending ) {\n dtls1_stop_timer ( s ) ;\n s -> tlsext_hb_pending = 0 ;\n s -> tlsext_hb_seq ++ ;\n }\n # endif for ( ;\n ;\n ) {\n state = s -> state ;\n switch ( s -> state ) {\n case SSL_ST_RENEGOTIATE : s -> renegotiate = 1 ;\n case SSL_ST_BEFORE : case SSL_ST_ACCEPT : case SSL_ST_BEFORE | SSL_ST_ACCEPT : case SSL_ST_OK | SSL_ST_ACCEPT : s -> server = 1 ;\n if ( cb != NULL ) cb ( s , SSL_CB_HANDSHAKE_START , 1 ) ;\n if ( ( s -> version & 0xff00 ) != ( DTLS1_VERSION & 0xff00 ) ) {\n SSLerr ( SSL_F_DTLS1_ACCEPT , ERR_R_INTERNAL_ERROR ) ;\n return - 1 ;\n }\n s -> type = SSL_ST_ACCEPT ;\n if ( s -> init_buf == NULL ) {\n if ( ( buf = BUF_MEM_new ( ) ) == NULL ) {\n ret = - 1 ;\n goto end ;\n }\n if ( ! BUF_MEM_grow ( buf , SSL3_RT_MAX_PLAIN_LENGTH ) ) {\n BUF_MEM_free ( buf ) ;\n ret = - 1 ;\n goto end ;\n }\n s -> init_buf = buf ;\n }\n if ( ! ssl3_setup_buffers ( s ) ) {\n ret = - 1 ;\n goto end ;\n }\n s -> init_num = 0 ;\n s -> d1 -> change_cipher_spec_ok = 0 ;\n s -> s3 -> change_cipher_spec = 0 ;\n if ( s -> state != SSL_ST_RENEGOTIATE ) {\n # ifndef OPENSSL_NO_SCTP if ( ! BIO_dgram_is_sctp ( SSL_get_wbio ( s ) ) ) # endif if ( ! ssl_init_wbio_buffer ( s , 1 ) ) {\n ret = - 1 ;\n goto end ;\n }\n ssl3_init_finished_mac ( s ) ;\n s -> state = SSL3_ST_SR_CLNT_HELLO_A ;\n s -> ctx -> stats . sess_accept ++ ;\n }\n else {\n s -> ctx -> stats . sess_accept_renegotiate ++ ;\n s -> state = SSL3_ST_SW_HELLO_REQ_A ;\n }\n break ;\n case SSL3_ST_SW_HELLO_REQ_A : case SSL3_ST_SW_HELLO_REQ_B : s -> shutdown = 0 ;\n dtls1_clear_record_buffer ( s ) ;\n dtls1_start_timer ( s ) ;\n ret = dtls1_send_hello_request ( s ) ;\n if ( ret <= 0 ) goto end ;\n s -> s3 -> tmp . next_state = SSL3_ST_SR_CLNT_HELLO_A ;\n s -> state = SSL3_ST_SW_FLUSH ;\n s -> init_num = 0 ;\n ssl3_init_finished_mac ( s ) ;\n break ;\n case SSL3_ST_SW_HELLO_REQ_C : s -> state = SSL_ST_OK ;\n break ;\n case SSL3_ST_SR_CLNT_HELLO_A : case SSL3_ST_SR_CLNT_HELLO_B : case SSL3_ST_SR_CLNT_HELLO_C : s -> shutdown = 0 ;\n ret = ssl3_get_client_hello ( s ) ;\n if ( ret <= 0 ) goto end ;\n dtls1_stop_timer ( s ) ;\n if ( ret == 1 && ( SSL_get_options ( s ) & SSL_OP_COOKIE_EXCHANGE ) ) s -> state = DTLS1_ST_SW_HELLO_VERIFY_REQUEST_A ;\n else s -> state = SSL3_ST_SW_SRVR_HELLO_A ;\n s -> init_num = 0 ;\n if ( listen ) {\n memcpy ( s -> s3 -> write_sequence , s -> s3 -> read_sequence , sizeof ( s -> s3 -> write_sequence ) ) ;\n }\n if ( listen && s -> state == SSL3_ST_SW_SRVR_HELLO_A ) {\n ret = 2 ;\n s -> d1 -> listen = 0 ;\n s -> d1 -> handshake_read_seq = 2 ;\n s -> d1 -> handshake_write_seq = 1 ;\n s -> d1 -> next_handshake_write_seq = 1 ;\n goto end ;\n }\n break ;\n case DTLS1_ST_SW_HELLO_VERIFY_REQUEST_A : case DTLS1_ST_SW_HELLO_VERIFY_REQUEST_B : ret = dtls1_send_hello_verify_request ( s ) ;\n if ( ret <= 0 ) goto end ;\n s -> state = SSL3_ST_SW_FLUSH ;\n s -> s3 -> tmp . next_state = SSL3_ST_SR_CLNT_HELLO_A ;\n if ( s -> version != DTLS1_BAD_VER ) ssl3_init_finished_mac ( s ) ;\n break ;\n # ifndef OPENSSL_NO_SCTP case DTLS1_SCTP_ST_SR_READ_SOCK : if ( BIO_dgram_sctp_msg_waiting ( SSL_get_rbio ( s ) ) ) {\n s -> s3 -> in_read_app_data = 2 ;\n s -> rwstate = SSL_READING ;\n BIO_clear_retry_flags ( SSL_get_rbio ( s ) ) ;\n BIO_set_retry_read ( SSL_get_rbio ( s ) ) ;\n ret = - 1 ;\n goto end ;\n }\n s -> state = SSL3_ST_SR_FINISHED_A ;\n break ;\n case DTLS1_SCTP_ST_SW_WRITE_SOCK : ret = BIO_dgram_sctp_wait_for_dry ( SSL_get_wbio ( s ) ) ;\n if ( ret < 0 ) goto end ;\n if ( ret == 0 ) {\n if ( s -> d1 -> next_state != SSL_ST_OK ) {\n s -> s3 -> in_read_app_data = 2 ;\n s -> rwstate = SSL_READING ;\n BIO_clear_retry_flags ( SSL_get_rbio ( s ) ) ;\n BIO_set_retry_read ( SSL_get_rbio ( s ) ) ;\n ret = - 1 ;\n goto end ;\n }\n }\n s -> state = s -> d1 -> next_state ;\n break ;\n # endif case SSL3_ST_SW_SRVR_HELLO_A : case SSL3_ST_SW_SRVR_HELLO_B : s -> renegotiate = 2 ;\n dtls1_start_timer ( s ) ;\n ret = dtls1_send_server_hello ( s ) ;\n if ( ret <= 0 ) goto end ;\n if ( s -> hit ) {\n # ifndef OPENSSL_NO_SCTP snprintf ( ( char * ) labelbuffer , sizeof ( DTLS1_SCTP_AUTH_LABEL ) , DTLS1_SCTP_AUTH_LABEL ) ;\n SSL_export_keying_material ( s , sctpauthkey , sizeof ( sctpauthkey ) , labelbuffer , sizeof ( labelbuffer ) , NULL , 0 , 0 ) ;\n BIO_ctrl ( SSL_get_wbio ( s ) , BIO_CTRL_DGRAM_SCTP_ADD_AUTH_KEY , sizeof ( sctpauthkey ) , sctpauthkey ) ;\n # endif # ifndef OPENSSL_NO_TLSEXT if ( s -> tlsext_ticket_expected ) s -> state = SSL3_ST_SW_SESSION_TICKET_A ;\n else s -> state = SSL3_ST_SW_CHANGE_A ;\n # else s -> state = SSL3_ST_SW_CHANGE_A ;\n # endif }\n else s -> state = SSL3_ST_SW_CERT_A ;\n s -> init_num = 0 ;\n break ;\n case SSL3_ST_SW_CERT_A : case SSL3_ST_SW_CERT_B : if ( ! ( s -> s3 -> tmp . new_cipher -> algorithm_auth & SSL_aNULL ) && ! ( s -> s3 -> tmp . new_cipher -> algorithm_mkey & SSL_kPSK ) ) {\n dtls1_start_timer ( s ) ;\n ret = dtls1_send_server_certificate ( s ) ;\n if ( ret <= 0 ) goto end ;\n # ifndef OPENSSL_NO_TLSEXT if ( s -> tlsext_status_expected ) s -> state = SSL3_ST_SW_CERT_STATUS_A ;\n else s -> state = SSL3_ST_SW_KEY_EXCH_A ;\n }\n else {\n skip = 1 ;\n s -> state = SSL3_ST_SW_KEY_EXCH_A ;\n }\n # else }\n else skip = 1 ;\n s -> state = SSL3_ST_SW_KEY_EXCH_A ;\n # endif s -> init_num = 0 ;\n break ;\n case SSL3_ST_SW_KEY_EXCH_A : case SSL3_ST_SW_KEY_EXCH_B : alg_k = s -> s3 -> tmp . new_cipher -> algorithm_mkey ;\n if ( ( s -> options & SSL_OP_EPHEMERAL_RSA ) # ifndef OPENSSL_NO_KRB5 && ! ( alg_k & SSL_kKRB5 ) # endif ) s -> s3 -> tmp . use_rsa_tmp = 1 ;\n else s -> s3 -> tmp . use_rsa_tmp = 0 ;\n if ( s -> s3 -> tmp . use_rsa_tmp # ifndef OPENSSL_NO_PSK || ( ( alg_k & SSL_kPSK ) && s -> ctx -> psk_identity_hint ) # endif || ( alg_k & ( SSL_kEDH | SSL_kDHr | SSL_kDHd ) ) || ( alg_k & SSL_kEECDH ) || ( ( alg_k & SSL_kRSA ) && ( s -> cert -> pkeys [ SSL_PKEY_RSA_ENC ] . privatekey == NULL || ( SSL_C_IS_EXPORT ( s -> s3 -> tmp . new_cipher ) && EVP_PKEY_size ( s -> cert -> pkeys [ SSL_PKEY_RSA_ENC ] . privatekey ) * 8 > SSL_C_EXPORT_PKEYLENGTH ( s -> s3 -> tmp . new_cipher ) ) ) ) ) {\n dtls1_start_timer ( s ) ;\n ret = dtls1_send_server_key_exchange ( s ) ;\n if ( ret <= 0 ) goto end ;\n }\n else skip = 1 ;\n s -> state = SSL3_ST_SW_CERT_REQ_A ;\n s -> init_num = 0 ;\n break ;\n case SSL3_ST_SW_CERT_REQ_A : case SSL3_ST_SW_CERT_REQ_B : if ( ! ( s -> verify_mode & SSL_VERIFY_PEER ) || ( ( s -> session -> peer != NULL ) && ( s -> verify_mode & SSL_VERIFY_CLIENT_ONCE ) ) || ( ( s -> s3 -> tmp . new_cipher -> algorithm_auth & SSL_aNULL ) && ! ( s -> verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT ) ) || ( s -> s3 -> tmp . new_cipher -> algorithm_auth & SSL_aKRB5 ) || ( s -> s3 -> tmp . new_cipher -> algorithm_mkey & SSL_kPSK ) ) {\n skip = 1 ;\n s -> s3 -> tmp . cert_request = 0 ;\n s -> state = SSL3_ST_SW_SRVR_DONE_A ;\n # ifndef OPENSSL_NO_SCTP if ( BIO_dgram_is_sctp ( SSL_get_wbio ( s ) ) ) {\n s -> d1 -> next_state = SSL3_ST_SW_SRVR_DONE_A ;\n s -> state = DTLS1_SCTP_ST_SW_WRITE_SOCK ;\n }\n # endif }\n else {\n s -> s3 -> tmp . cert_request = 1 ;\n dtls1_start_timer ( s ) ;\n ret = dtls1_send_certificate_request ( s ) ;\n if ( ret <= 0 ) goto end ;\n # ifndef NETSCAPE_HANG_BUG s -> state = SSL3_ST_SW_SRVR_DONE_A ;\n # ifndef OPENSSL_NO_SCTP if ( BIO_dgram_is_sctp ( SSL_get_wbio ( s ) ) ) {\n s -> d1 -> next_state = SSL3_ST_SW_SRVR_DONE_A ;\n s -> state = DTLS1_SCTP_ST_SW_WRITE_SOCK ;\n }\n # endif # else s -> state = SSL3_ST_SW_FLUSH ;\n s -> s3 -> tmp . next_state = SSL3_ST_SR_CERT_A ;\n # ifndef OPENSSL_NO_SCTP if ( BIO_dgram_is_sctp ( SSL_get_wbio ( s ) ) ) {\n s -> d1 -> next_state = s -> s3 -> tmp . next_state ;\n s -> s3 -> tmp . next_state = DTLS1_SCTP_ST_SW_WRITE_SOCK ;\n }\n # endif # endif s -> init_num = 0 ;\n }\n break ;\n case SSL3_ST_SW_SRVR_DONE_A : case SSL3_ST_SW_SRVR_DONE_B : dtls1_start_timer ( s ) ;\n ret = dtls1_send_server_done ( s ) ;\n if ( ret <= 0 ) goto end ;\n s -> s3 -> tmp . next_state = SSL3_ST_SR_CERT_A ;\n s -> state = SSL3_ST_SW_FLUSH ;\n s -> init_num = 0 ;\n break ;\n case SSL3_ST_SW_FLUSH : s -> rwstate = SSL_WRITING ;\n if ( BIO_flush ( s -> wbio ) <= 0 ) {\n if ( ! BIO_should_retry ( s -> wbio ) ) {\n s -> rwstate = SSL_NOTHING ;\n s -> state = s -> s3 -> tmp . next_state ;\n }\n ret = - 1 ;\n goto end ;\n }\n s -> rwstate = SSL_NOTHING ;\n s -> state = s -> s3 -> tmp . next_state ;\n break ;\n case SSL3_ST_SR_CERT_A : case SSL3_ST_SR_CERT_B : ret = ssl3_check_client_hello ( s ) ;\n if ( ret <= 0 ) goto end ;\n if ( ret == 2 ) {\n dtls1_stop_timer ( s ) ;\n s -> state = SSL3_ST_SR_CLNT_HELLO_C ;\n }\n else {\n if ( s -> s3 -> tmp . cert_request ) {\n ret = ssl3_get_client_certificate ( s ) ;\n if ( ret <= 0 ) goto end ;\n }\n s -> init_num = 0 ;\n s -> state = SSL3_ST_SR_KEY_EXCH_A ;\n }\n break ;\n case SSL3_ST_SR_KEY_EXCH_A : case SSL3_ST_SR_KEY_EXCH_B : ret = ssl3_get_client_key_exchange ( s ) ;\n if ( ret <= 0 ) goto end ;\n # ifndef OPENSSL_NO_SCTP snprintf ( ( char * ) labelbuffer , sizeof ( DTLS1_SCTP_AUTH_LABEL ) , DTLS1_SCTP_AUTH_LABEL ) ;\n SSL_export_keying_material ( s , sctpauthkey , sizeof ( sctpauthkey ) , labelbuffer , sizeof ( labelbuffer ) , NULL , 0 , 0 ) ;\n BIO_ctrl ( SSL_get_wbio ( s ) , BIO_CTRL_DGRAM_SCTP_ADD_AUTH_KEY , sizeof ( sctpauthkey ) , sctpauthkey ) ;\n # endif s -> state = SSL3_ST_SR_CERT_VRFY_A ;\n s -> init_num = 0 ;\n if ( ret == 2 ) {\n s -> state = SSL3_ST_SR_FINISHED_A ;\n s -> init_num = 0 ;\n }\n else {\n s -> state = SSL3_ST_SR_CERT_VRFY_A ;\n s -> init_num = 0 ;\n s -> method -> ssl3_enc -> cert_verify_mac ( s , NID_md5 , & ( s -> s3 -> tmp . cert_verify_md [ 0 ] ) ) ;\n s -> method -> ssl3_enc -> cert_verify_mac ( s , NID_sha1 , & ( s -> s3 -> tmp . cert_verify_md [ MD5_DIGEST_LENGTH ] ) ) ;\n }\n break ;\n case SSL3_ST_SR_CERT_VRFY_A : case SSL3_ST_SR_CERT_VRFY_B : if ( ! s -> s3 -> change_cipher_spec ) s -> d1 -> change_cipher_spec_ok = 1 ;\n ret = ssl3_get_cert_verify ( s ) ;\n if ( ret <= 0 ) goto end ;\n # ifndef OPENSSL_NO_SCTP if ( BIO_dgram_is_sctp ( SSL_get_wbio ( s ) ) && state == SSL_ST_RENEGOTIATE ) s -> state = DTLS1_SCTP_ST_SR_READ_SOCK ;\n else # endif s -> state = SSL3_ST_SR_FINISHED_A ;\n s -> init_num = 0 ;\n break ;\n case SSL3_ST_SR_FINISHED_A : case SSL3_ST_SR_FINISHED_B : if ( ! s -> s3 -> change_cipher_spec ) s -> d1 -> change_cipher_spec_ok = 1 ;\n ret = ssl3_get_finished ( s , SSL3_ST_SR_FINISHED_A , SSL3_ST_SR_FINISHED_B ) ;\n if ( ret <= 0 ) goto end ;\n dtls1_stop_timer ( s ) ;\n if ( s -> hit ) s -> state = SSL_ST_OK ;\n # ifndef OPENSSL_NO_TLSEXT else if ( s -> tlsext_ticket_expected ) s -> state = SSL3_ST_SW_SESSION_TICKET_A ;\n # endif else s -> state = SSL3_ST_SW_CHANGE_A ;\n s -> init_num = 0 ;\n break ;\n # ifndef OPENSSL_NO_TLSEXT case SSL3_ST_SW_SESSION_TICKET_A : case SSL3_ST_SW_SESSION_TICKET_B : ret = dtls1_send_newsession_ticket ( s ) ;\n if ( ret <= 0 ) goto end ;\n s -> state = SSL3_ST_SW_CHANGE_A ;\n s -> init_num = 0 ;\n break ;\n case SSL3_ST_SW_CERT_STATUS_A : case SSL3_ST_SW_CERT_STATUS_B : ret = ssl3_send_cert_status ( s ) ;\n if ( ret <= 0 ) goto end ;\n s -> state = SSL3_ST_SW_KEY_EXCH_A ;\n s -> init_num = 0 ;\n break ;\n # endif case SSL3_ST_SW_CHANGE_A : case SSL3_ST_SW_CHANGE_B : s -> session -> cipher = s -> s3 -> tmp . new_cipher ;\n if ( ! s -> method -> ssl3_enc -> setup_key_block ( s ) ) {\n ret = - 1 ;\n goto end ;\n }\n ret = dtls1_send_change_cipher_spec ( s , SSL3_ST_SW_CHANGE_A , SSL3_ST_SW_CHANGE_B ) ;\n if ( ret <= 0 ) goto end ;\n # ifndef OPENSSL_NO_SCTP if ( ! s -> hit ) {\n BIO_ctrl ( SSL_get_wbio ( s ) , BIO_CTRL_DGRAM_SCTP_NEXT_AUTH_KEY , 0 , NULL ) ;\n }\n # endif s -> state = SSL3_ST_SW_FINISHED_A ;\n s -> init_num = 0 ;\n if ( ! s -> method -> ssl3_enc -> change_cipher_state ( s , SSL3_CHANGE_CIPHER_SERVER_WRITE ) ) {\n ret = - 1 ;\n goto end ;\n }\n dtls1_reset_seq_numbers ( s , SSL3_CC_WRITE ) ;\n break ;\n case SSL3_ST_SW_FINISHED_A : case SSL3_ST_SW_FINISHED_B : ret = dtls1_send_finished ( s , SSL3_ST_SW_FINISHED_A , SSL3_ST_SW_FINISHED_B , s -> method -> ssl3_enc -> server_finished_label , s -> method -> ssl3_enc -> server_finished_label_len ) ;\n if ( ret <= 0 ) goto end ;\n s -> state = SSL3_ST_SW_FLUSH ;\n if ( s -> hit ) {\n s -> s3 -> tmp . next_state = SSL3_ST_SR_FINISHED_A ;\n # ifndef OPENSSL_NO_SCTP BIO_ctrl ( SSL_get_wbio ( s ) , BIO_CTRL_DGRAM_SCTP_NEXT_AUTH_KEY , 0 , NULL ) ;\n # endif }\n else {\n s -> s3 -> tmp . next_state = SSL_ST_OK ;\n # ifndef OPENSSL_NO_SCTP if ( BIO_dgram_is_sctp ( SSL_get_wbio ( s ) ) ) {\n s -> d1 -> next_state = s -> s3 -> tmp . next_state ;\n s -> s3 -> tmp . next_state = DTLS1_SCTP_ST_SW_WRITE_SOCK ;\n }\n # endif }\n s -> init_num = 0 ;\n break ;\n case SSL_ST_OK : ssl3_cleanup_key_block ( s ) ;\n # if 0 BUF_MEM_free ( s -> init_buf ) ;\n s -> init_buf = NULL ;\n # endif ssl_free_wbio_buffer ( s ) ;\n s -> init_num = 0 ;\n if ( s -> renegotiate == 2 ) {\n s -> renegotiate = 0 ;\n s -> new_session = 0 ;\n ssl_update_cache ( s , SSL_SESS_CACHE_SERVER ) ;\n s -> ctx -> stats . sess_accept_good ++ ;\n s -> handshake_func = dtls1_accept ;\n if ( cb != NULL ) cb ( s , SSL_CB_HANDSHAKE_DONE , 1 ) ;\n }\n ret = 1 ;\n s -> d1 -> handshake_read_seq = 0 ;\n s -> d1 -> handshake_write_seq = 0 ;\n s -> d1 -> next_handshake_write_seq = 0 ;\n goto end ;\n default : SSLerr ( SSL_F_DTLS1_ACCEPT , SSL_R_UNKNOWN_STATE ) ;\n ret = - 1 ;\n goto end ;\n }\n if ( ! s -> s3 -> tmp . reuse_message && ! skip ) {\n if ( s -> debug ) {\n if ( ( ret = BIO_flush ( s -> wbio ) ) <= 0 ) goto end ;\n }\n if ( ( cb != NULL ) && ( s -> state != state ) ) {\n new_state = s -> state ;\n s -> state = state ;\n cb ( s , SSL_CB_ACCEPT_LOOP , 1 ) ;\n s -> state = new_state ;\n }\n }\n skip = 0 ;\n }\n end : s -> in_handshake -- ;\n # ifndef OPENSSL_NO_SCTP BIO_ctrl ( SSL_get_wbio ( s ) , BIO_CTRL_DGRAM_SCTP_SET_IN_HANDSHAKE , s -> in_handshake , NULL ) ;\n # endif if ( cb != NULL ) cb ( s , SSL_CB_ACCEPT_EXIT , ret ) ;\n return ( ret ) ;\n }", "idx": 66}
{"hash": 3766491362463647945, "project": "debian", "size": 285, "label": 1, "functionSource": "static ngx_int_t create_request ( ngx_http_request_t * r ) {\n u_char ch ;\n const char * helper_agent_request_socket_password_data ;\n unsigned int helper_agent_request_socket_password_len ;\n u_char buf [ sizeof ( \"4294967296\" ) + 1 ] ;\n size_t len , size , key_len , val_len ;\n const u_char * app_type_string ;\n size_t app_type_string_len ;\n int server_name_len ;\n ngx_str_t escaped_uri ;\n ngx_str_t * union_station_filters = NULL ;\n void * tmp ;\n ngx_uint_t i , n ;\n ngx_buf_t * b ;\n ngx_chain_t * cl , * body ;\n ngx_list_part_t * part ;\n ngx_table_elt_t * header ;\n ngx_http_script_code_pt code ;\n ngx_http_script_engine_t e , le ;\n ngx_http_core_srv_conf_t * cscf ;\n passenger_loc_conf_t * slcf ;\n passenger_context_t * context ;\n ngx_http_script_len_code_pt lcode ;\n cscf = ngx_http_get_module_srv_conf ( r , ngx_http_core_module ) ;\n slcf = ngx_http_get_module_loc_conf ( r , ngx_http_passenger_module ) ;\n context = ngx_http_get_module_ctx ( r , ngx_http_passenger_module ) ;\n if ( context == NULL ) {\n return NGX_HTTP_INTERNAL_SERVER_ERROR ;\n }\n app_type_string = ( const u_char * ) pp_get_app_type_name ( context -> app_type ) ;\n app_type_string_len = strlen ( ( const char * ) app_type_string ) + 1 ;\n escaped_uri . len = * ngx_escape_uri ( NULL , r -> uri . data , r -> uri . len , NGX_ESCAPE_URI ) + r -> uri . len ;\n escaped_uri . data = ngx_pnalloc ( r -> pool , escaped_uri . len + 1 ) ;\n escaped_uri . data [ escaped_uri . len ] = '\\0' ;\n ngx_escape_uri ( escaped_uri . data , r -> uri . data , r -> uri . len , NGX_ESCAPE_URI ) ;\n len = 0 ;\n if ( r -> headers_in . content_length_n >= 0 ) {\n len += sizeof ( \"CONTENT_LENGTH\" ) + uint_to_str ( r -> headers_in . content_length_n , buf , sizeof ( buf ) ) + 1 ;\n }\n len += sizeof ( \"DOCUMENT_ROOT\" ) + context -> public_dir . len + 1 ;\n if ( context -> base_uri . len > 0 ) {\n len += sizeof ( \"SCRIPT_NAME\" ) + context -> base_uri . len + 1 ;\n len += sizeof ( \"RAILS_RELATIVE_URL_ROOT\" ) + context -> base_uri . len + 1 ;\n len += sizeof ( \"PATH_INFO\" ) + escaped_uri . len - context -> base_uri . len + 1 ;\n }\n else {\n len += sizeof ( \"SCRIPT_NAME\" ) + sizeof ( \"\" ) ;\n len += sizeof ( \"PATH_INFO\" ) + escaped_uri . len + 1 ;\n }\n len += sizeof ( \"REQUEST_URI\" ) + escaped_uri . len + 1 ;\n if ( r -> args . len > 0 ) {\n len += 1 + r -> args . len ;\n }\n if ( r -> headers_in . host != NULL ) {\n tmp = memchr ( r -> headers_in . host -> value . data , ':' , r -> headers_in . host -> value . len ) ;\n if ( tmp == NULL ) {\n server_name_len = r -> headers_in . host -> value . len ;\n }\n else {\n server_name_len = ( int ) ( ( const u_char * ) tmp - r -> headers_in . host -> value . data ) ;\n }\n }\n else {\n server_name_len = cscf -> server_name . len ;\n }\n len += sizeof ( \"SERVER_NAME\" ) + server_name_len + 1 ;\n if ( r -> headers_in . content_type != NULL && r -> headers_in . content_type -> value . len > 0 ) {\n len += sizeof ( \"CONTENT_TYPE\" ) + r -> headers_in . content_type -> value . len + 1 ;\n }\n # if ( NGX_HTTP_SSL ) if ( r -> http_connection -> ssl ) {\n len += sizeof ( \"HTTPS\" ) + sizeof ( \"on\" ) ;\n }\n # endif len += slcf -> options_cache . len ;\n len += sizeof ( \"PASSENGER_APP_TYPE\" ) + app_type_string_len ;\n if ( slcf -> union_station_filters != NGX_CONF_UNSET_PTR && slcf -> union_station_filters -> nelts > 0 ) {\n len += sizeof ( \"UNION_STATION_FILTERS\" ) ;\n union_station_filters = ( ngx_str_t * ) slcf -> union_station_filters -> elts ;\n for ( i = 0 ;\n i < slcf -> union_station_filters -> nelts ;\n i ++ ) {\n if ( i != 0 ) {\n len ++ ;\n }\n len += union_station_filters [ i ] . len ;\n }\n len ++ ;\n }\n if ( slcf -> vars_len ) {\n ngx_memzero ( & le , sizeof ( ngx_http_script_engine_t ) ) ;\n ngx_http_script_flush_no_cacheable_variables ( r , slcf -> flushes ) ;\n le . flushed = 1 ;\n le . ip = slcf -> vars_len -> elts ;\n le . request = r ;\n while ( * ( uintptr_t * ) le . ip ) {\n lcode = * ( ngx_http_script_len_code_pt * ) le . ip ;\n key_len = lcode ( & le ) ;\n for ( val_len = 0 ;\n * ( uintptr_t * ) le . ip ;\n val_len += lcode ( & le ) ) {\n lcode = * ( ngx_http_script_len_code_pt * ) le . ip ;\n }\n le . ip += sizeof ( uintptr_t ) ;\n len += key_len + val_len ;\n }\n }\n if ( slcf -> upstream_config . pass_request_headers ) {\n part = & r -> headers_in . headers . part ;\n header = part -> elts ;\n for ( i = 0 ;\n ;\n i ++ ) {\n if ( i >= part -> nelts ) {\n if ( part -> next == NULL ) {\n break ;\n }\n part = part -> next ;\n header = part -> elts ;\n i = 0 ;\n }\n if ( ! header_is_transfer_encoding ( & header [ i ] . key ) ) {\n len += sizeof ( \"HTTP_\" ) - 1 + header [ i ] . key . len + 1 + header [ i ] . value . len + 1 ;\n }\n }\n }\n helper_agent_request_socket_password_data = pp_agents_starter_get_request_socket_password ( pp_agents_starter , & helper_agent_request_socket_password_len ) ;\n size = helper_agent_request_socket_password_len + len + 10 + 1 + 1 ;\n b = ngx_create_temp_buf ( r -> pool , size ) ;\n if ( b == NULL ) {\n return NGX_ERROR ;\n }\n cl = ngx_alloc_chain_link ( r -> pool ) ;\n if ( cl == NULL ) {\n return NGX_ERROR ;\n }\n cl -> buf = b ;\n b -> last = ngx_copy ( b -> last , helper_agent_request_socket_password_data , helper_agent_request_socket_password_len ) ;\n b -> last = ngx_snprintf ( b -> last , 10 , \"%ui\" , len ) ;\n * b -> last ++ = ( u_char ) ':' ;\n if ( r -> headers_in . content_length_n >= 0 ) {\n b -> last = ngx_copy ( b -> last , \"CONTENT_LENGTH\" , sizeof ( \"CONTENT_LENGTH\" ) ) ;\n b -> last = ngx_snprintf ( b -> last , 10 , \"%O\" , r -> headers_in . content_length_n ) ;\n * b -> last ++ = ( u_char ) 0 ;\n }\n b -> last = ngx_copy ( b -> last , \"DOCUMENT_ROOT\" , sizeof ( \"DOCUMENT_ROOT\" ) ) ;\n b -> last = ngx_copy ( b -> last , context -> public_dir . data , context -> public_dir . len + 1 ) ;\n if ( context -> base_uri . len > 0 ) {\n b -> last = ngx_copy ( b -> last , \"SCRIPT_NAME\" , sizeof ( \"SCRIPT_NAME\" ) ) ;\n b -> last = ngx_copy ( b -> last , context -> base_uri . data , context -> base_uri . len + 1 ) ;\n b -> last = ngx_copy ( b -> last , \"RAILS_RELATIVE_URL_ROOT\" , sizeof ( \"RAILS_RELATIVE_URL_ROOT\" ) ) ;\n b -> last = ngx_copy ( b -> last , context -> base_uri . data , context -> base_uri . len + 1 ) ;\n b -> last = ngx_copy ( b -> last , \"PATH_INFO\" , sizeof ( \"PATH_INFO\" ) ) ;\n b -> last = ngx_copy ( b -> last , escaped_uri . data + context -> base_uri . len , escaped_uri . len - context -> base_uri . len ) ;\n b -> last = ngx_copy ( b -> last , \"\" , 1 ) ;\n }\n else {\n b -> last = ngx_copy ( b -> last , \"SCRIPT_NAME\" , sizeof ( \"SCRIPT_NAME\" ) ) ;\n b -> last = ngx_copy ( b -> last , \"\" , sizeof ( \"\" ) ) ;\n b -> last = ngx_copy ( b -> last , \"PATH_INFO\" , sizeof ( \"PATH_INFO\" ) ) ;\n b -> last = ngx_copy ( b -> last , escaped_uri . data , escaped_uri . len ) ;\n b -> last = ngx_copy ( b -> last , \"\" , 1 ) ;\n }\n b -> last = ngx_copy ( b -> last , \"REQUEST_URI\" , sizeof ( \"REQUEST_URI\" ) ) ;\n b -> last = ngx_copy ( b -> last , escaped_uri . data , escaped_uri . len ) ;\n if ( r -> args . len > 0 ) {\n b -> last = ngx_copy ( b -> last , \"?\" , 1 ) ;\n b -> last = ngx_copy ( b -> last , r -> args . data , r -> args . len ) ;\n }\n b -> last = ngx_copy ( b -> last , \"\" , 1 ) ;\n b -> last = ngx_copy ( b -> last , \"SERVER_NAME\" , sizeof ( \"SERVER_NAME\" ) ) ;\n if ( r -> headers_in . host != NULL ) {\n b -> last = ngx_copy ( b -> last , r -> headers_in . host -> value . data , server_name_len ) ;\n }\n else {\n b -> last = ngx_copy ( b -> last , cscf -> server_name . data , server_name_len ) ;\n }\n b -> last = ngx_copy ( b -> last , \"\" , 1 ) ;\n if ( r -> headers_in . content_type != NULL && r -> headers_in . content_type -> value . len > 0 ) {\n b -> last = ngx_copy ( b -> last , \"CONTENT_TYPE\" , sizeof ( \"CONTENT_TYPE\" ) ) ;\n b -> last = ngx_copy ( b -> last , r -> headers_in . content_type -> value . data , r -> headers_in . content_type -> value . len ) ;\n b -> last = ngx_copy ( b -> last , \"\" , 1 ) ;\n }\n # if ( NGX_HTTP_SSL ) if ( r -> http_connection -> ssl ) {\n b -> last = ngx_copy ( b -> last , \"HTTPS\" , sizeof ( \"HTTPS\" ) ) ;\n b -> last = ngx_copy ( b -> last , \"on\" , sizeof ( \"on\" ) ) ;\n }\n # endif b -> last = ngx_copy ( b -> last , slcf -> options_cache . data , slcf -> options_cache . len ) ;\n b -> last = ngx_copy ( b -> last , \"PASSENGER_APP_TYPE\" , sizeof ( \"PASSENGER_APP_TYPE\" ) ) ;\n b -> last = ngx_copy ( b -> last , app_type_string , app_type_string_len ) ;\n if ( slcf -> union_station_filters != NGX_CONF_UNSET_PTR && slcf -> union_station_filters -> nelts > 0 ) {\n b -> last = ngx_copy ( b -> last , \"UNION_STATION_FILTERS\" , sizeof ( \"UNION_STATION_FILTERS\" ) ) ;\n for ( i = 0 ;\n i < slcf -> union_station_filters -> nelts ;\n i ++ ) {\n if ( i != 0 ) {\n b -> last = ngx_copy ( b -> last , \"\\1\" , 1 ) ;\n }\n b -> last = ngx_copy ( b -> last , union_station_filters [ i ] . data , union_station_filters [ i ] . len ) ;\n }\n b -> last = ngx_copy ( b -> last , \"\\0\" , 1 ) ;\n }\n if ( slcf -> vars_len ) {\n ngx_memzero ( & e , sizeof ( ngx_http_script_engine_t ) ) ;\n e . ip = slcf -> vars -> elts ;\n e . pos = b -> last ;\n e . request = r ;\n e . flushed = 1 ;\n le . ip = slcf -> vars_len -> elts ;\n while ( * ( uintptr_t * ) le . ip ) {\n lcode = * ( ngx_http_script_len_code_pt * ) le . ip ;\n ( void ) lcode ( & le ) ;\n for ( val_len = 0 ;\n * ( uintptr_t * ) le . ip ;\n val_len += lcode ( & le ) ) {\n lcode = * ( ngx_http_script_len_code_pt * ) le . ip ;\n }\n le . ip += sizeof ( uintptr_t ) ;\n while ( * ( uintptr_t * ) e . ip ) {\n code = * ( ngx_http_script_code_pt * ) e . ip ;\n code ( ( ngx_http_script_engine_t * ) & e ) ;\n }\n e . ip += sizeof ( uintptr_t ) ;\n }\n b -> last = e . pos ;\n }\n if ( slcf -> upstream_config . pass_request_headers ) {\n part = & r -> headers_in . headers . part ;\n header = part -> elts ;\n for ( i = 0 ;\n ;\n i ++ ) {\n if ( i >= part -> nelts ) {\n if ( part -> next == NULL ) {\n break ;\n }\n part = part -> next ;\n header = part -> elts ;\n i = 0 ;\n }\n if ( header_is_transfer_encoding ( & header [ i ] . key ) ) {\n continue ;\n }\n b -> last = ngx_cpymem ( b -> last , \"HTTP_\" , sizeof ( \"HTTP_\" ) - 1 ) ;\n for ( n = 0 ;\n n < header [ i ] . key . len ;\n n ++ ) {\n ch = header [ i ] . key . data [ n ] ;\n if ( ch >= 'a' && ch <= 'z' ) {\n ch &= ~ 0x20 ;\n }\n else if ( ch == '-' ) {\n ch = '_' ;\n }\n * b -> last ++ = ch ;\n }\n * b -> last ++ = ( u_char ) 0 ;\n b -> last = ngx_copy ( b -> last , header [ i ] . value . data , header [ i ] . value . len ) ;\n * b -> last ++ = ( u_char ) 0 ;\n }\n }\n * b -> last ++ = ( u_char ) ',' ;\n if ( slcf -> upstream_config . pass_request_body ) {\n body = r -> upstream -> request_bufs ;\n r -> upstream -> request_bufs = cl ;\n while ( body ) {\n b = ngx_alloc_buf ( r -> pool ) ;\n if ( b == NULL ) {\n return NGX_ERROR ;\n }\n ngx_memcpy ( b , body -> buf , sizeof ( ngx_buf_t ) ) ;\n cl -> next = ngx_alloc_chain_link ( r -> pool ) ;\n if ( cl -> next == NULL ) {\n return NGX_ERROR ;\n }\n cl = cl -> next ;\n cl -> buf = b ;\n body = body -> next ;\n }\n b -> flush = 1 ;\n }\n else {\n r -> upstream -> request_bufs = cl ;\n }\n cl -> next = NULL ;\n return NGX_OK ;\n }", "idx": 67}
{"hash": -4885528830177756816, "project": "debian", "size": 38, "label": 0, "functionSource": "static HA_KEYSEG * ha_find_null ( HA_KEYSEG * keyseg , uchar * a ) {\n for ( ;\n ( enum ha_base_keytype ) keyseg -> type != HA_KEYTYPE_END ;\n keyseg ++ ) {\n uchar * end ;\n if ( keyseg -> null_bit ) {\n if ( ! * a ++ ) return keyseg ;\n }\n end = a + keyseg -> length ;\n switch ( ( enum ha_base_keytype ) keyseg -> type ) {\n case HA_KEYTYPE_TEXT : case HA_KEYTYPE_BINARY : case HA_KEYTYPE_BIT : if ( keyseg -> flag & HA_SPACE_PACK ) {\n int a_length ;\n get_key_length ( a_length , a ) ;\n a += a_length ;\n break ;\n }\n else a = end ;\n break ;\n case HA_KEYTYPE_VARTEXT1 : case HA_KEYTYPE_VARTEXT2 : case HA_KEYTYPE_VARBINARY1 : case HA_KEYTYPE_VARBINARY2 : {\n int a_length ;\n get_key_length ( a_length , a ) ;\n a += a_length ;\n break ;\n }\n case HA_KEYTYPE_NUM : if ( keyseg -> flag & HA_SPACE_PACK ) {\n int alength = * a ++ ;\n end = a + alength ;\n }\n a = end ;\n break ;\n case HA_KEYTYPE_INT8 : case HA_KEYTYPE_SHORT_INT : case HA_KEYTYPE_USHORT_INT : case HA_KEYTYPE_LONG_INT : case HA_KEYTYPE_ULONG_INT : case HA_KEYTYPE_INT24 : case HA_KEYTYPE_UINT24 : # ifdef HAVE_LONG_LONG case HA_KEYTYPE_LONGLONG : case HA_KEYTYPE_ULONGLONG : # endif case HA_KEYTYPE_FLOAT : case HA_KEYTYPE_DOUBLE : a = end ;\n break ;\n case HA_KEYTYPE_END : DBUG_ASSERT ( 0 ) ;\n break ;\n }\n }\n return keyseg ;\n }", "idx": 68}
{"hash": 4489017523191997023, "project": "debian", "size": 93, "label": 0, "functionSource": "static void ras_call_matching ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , h225_packet_info * pi ) {\n proto_item * hidden_item ;\n conversation_t * conversation = NULL ;\n h225ras_call_info_key h225ras_call_key ;\n h225ras_call_t * h225ras_call = NULL ;\n nstime_t delta ;\n guint msg_category ;\n if ( pi -> msg_type == H225_RAS && pi -> msg_tag < 21 ) {\n msg_category = pi -> msg_tag / 3 ;\n if ( pi -> msg_tag % 3 == 0 ) {\n conversation = find_or_create_conversation ( pinfo ) ;\n h225ras_call_key . reqSeqNum = pi -> requestSeqNum ;\n h225ras_call_key . conversation = conversation ;\n h225ras_call = find_h225ras_call ( & h225ras_call_key , msg_category ) ;\n if ( h225ras_call != NULL ) {\n do {\n if ( pinfo -> num == h225ras_call -> req_num ) {\n break ;\n }\n if ( h225ras_call -> next_call == NULL ) {\n if ( ( pinfo -> num > h225ras_call -> rsp_num && h225ras_call -> rsp_num != 0 && pinfo -> abs_ts . secs > ( h225ras_call -> req_time . secs + THRESHOLD_REPEATED_RESPONDED_CALL ) ) || ( pinfo -> num > h225ras_call -> req_num && h225ras_call -> rsp_num == 0 && pinfo -> abs_ts . secs > ( h225ras_call -> req_time . secs + THRESHOLD_REPEATED_NOT_RESPONDED_CALL ) ) ) {\n h225ras_call = append_h225ras_call ( h225ras_call , pinfo , & pi -> guid , msg_category ) ;\n }\n else {\n pi -> is_duplicate = TRUE ;\n hidden_item = proto_tree_add_uint ( tree , hf_h225_ras_dup , tvb , 0 , 0 , pi -> requestSeqNum ) ;\n PROTO_ITEM_SET_HIDDEN ( hidden_item ) ;\n }\n break ;\n }\n h225ras_call = h225ras_call -> next_call ;\n }\n while ( h225ras_call != NULL ) ;\n }\n else {\n h225ras_call = new_h225ras_call ( & h225ras_call_key , pinfo , & pi -> guid , msg_category ) ;\n }\n if ( h225ras_call && h225ras_call -> rsp_num != 0 ) {\n proto_item * ti = proto_tree_add_uint_format ( tree , hf_h225_ras_rsp_frame , tvb , 0 , 0 , h225ras_call -> rsp_num , \"The response to this request is in frame %u\" , h225ras_call -> rsp_num ) ;\n PROTO_ITEM_SET_GENERATED ( ti ) ;\n }\n }\n else {\n conversation = find_conversation ( pinfo -> num , & pinfo -> src , & pinfo -> dst , pinfo -> ptype , pinfo -> srcport , pinfo -> destport , 0 ) ;\n if ( conversation != NULL ) {\n h225ras_call_key . reqSeqNum = pi -> requestSeqNum ;\n h225ras_call_key . conversation = conversation ;\n h225ras_call = find_h225ras_call ( & h225ras_call_key , msg_category ) ;\n if ( h225ras_call ) {\n do {\n if ( pinfo -> num == h225ras_call -> rsp_num ) {\n break ;\n }\n if ( h225ras_call -> next_call == NULL ) {\n break ;\n }\n h225ras_call = h225ras_call -> next_call ;\n }\n while ( h225ras_call != NULL ) ;\n if ( ! h225ras_call ) {\n return ;\n }\n if ( msg_category == 3 || msg_category == 5 ) {\n pi -> guid = h225ras_call -> guid ;\n hidden_item = proto_tree_add_guid ( tree , hf_h225_guid , tvb , 0 , GUID_LEN , & pi -> guid ) ;\n PROTO_ITEM_SET_HIDDEN ( hidden_item ) ;\n }\n if ( h225ras_call -> rsp_num == 0 ) {\n h225ras_call -> rsp_num = pinfo -> num ;\n }\n else {\n if ( h225ras_call -> rsp_num != pinfo -> num ) {\n pi -> is_duplicate = TRUE ;\n hidden_item = proto_tree_add_uint ( tree , hf_h225_ras_dup , tvb , 0 , 0 , pi -> requestSeqNum ) ;\n PROTO_ITEM_SET_HIDDEN ( hidden_item ) ;\n }\n }\n if ( h225ras_call -> req_num != 0 ) {\n proto_item * ti ;\n h225ras_call -> responded = TRUE ;\n pi -> request_available = TRUE ;\n ti = proto_tree_add_uint_format ( tree , hf_h225_ras_req_frame , tvb , 0 , 0 , h225ras_call -> req_num , \"This is a response to a request in frame %u\" , h225ras_call -> req_num ) ;\n PROTO_ITEM_SET_GENERATED ( ti ) ;\n nstime_delta ( & delta , & pinfo -> abs_ts , & h225ras_call -> req_time ) ;\n pi -> delta_time = delta ;\n ti = proto_tree_add_time ( tree , hf_h225_ras_deltatime , tvb , 0 , 0 , & ( pi -> delta_time ) ) ;\n PROTO_ITEM_SET_GENERATED ( ti ) ;\n }\n }\n }\n }\n }\n }", "idx": 69}
{"hash": -331579171381918893, "project": "debian", "size": 31, "label": 0, "functionSource": "int SRP_create_verifier_BN ( const char * user , const char * pass , BIGNUM * * salt , BIGNUM * * verifier , BIGNUM * N , BIGNUM * g ) {\n int result = 0 ;\n BIGNUM * x = NULL ;\n BN_CTX * bn_ctx = BN_CTX_new ( ) ;\n unsigned char tmp2 [ MAX_LEN ] ;\n BIGNUM * salttmp = NULL ;\n if ( ( user == NULL ) || ( pass == NULL ) || ( salt == NULL ) || ( verifier == NULL ) || ( N == NULL ) || ( g == NULL ) || ( bn_ctx == NULL ) ) goto err ;\n srp_bn_print ( N ) ;\n srp_bn_print ( g ) ;\n if ( * salt == NULL ) {\n if ( RAND_pseudo_bytes ( tmp2 , SRP_RANDOM_SALT_LEN ) < 0 ) goto err ;\n salttmp = BN_bin2bn ( tmp2 , SRP_RANDOM_SALT_LEN , NULL ) ;\n }\n else {\n salttmp = * salt ;\n }\n x = SRP_Calc_x ( salttmp , user , pass ) ;\n * verifier = BN_new ( ) ;\n if ( * verifier == NULL ) goto err ;\n if ( ! BN_mod_exp ( * verifier , g , x , N , bn_ctx ) ) {\n BN_clear_free ( * verifier ) ;\n goto err ;\n }\n srp_bn_print ( * verifier ) ;\n result = 1 ;\n * salt = salttmp ;\n err : if ( * salt != salttmp ) BN_clear_free ( salttmp ) ;\n BN_clear_free ( x ) ;\n BN_CTX_free ( bn_ctx ) ;\n return result ;\n }", "idx": 70}
{"hash": 1182028467273264883, "project": "debian", "size": 130, "label": 0, "functionSource": "int read_line ( char * buf , int size ) {\n char c , UNINIT_VAR ( last_quote ) , last_char = 0 ;\n char * p = buf , * buf_end = buf + size - 1 ;\n int skip_char = 0 ;\n my_bool have_slash = FALSE ;\n enum {\n R_NORMAL , R_Q , R_SLASH_IN_Q , R_COMMENT , R_LINE_START }\n state = R_LINE_START ;\n DBUG_ENTER ( \"read_line\" ) ;\n start_lineno = cur_file -> lineno ;\n DBUG_PRINT ( \"info\" , ( \"Starting to read at lineno: %d\" , start_lineno ) ) ;\n for ( ;\n p < buf_end ;\n ) {\n skip_char = 0 ;\n c = my_getc ( cur_file -> file ) ;\n if ( feof ( cur_file -> file ) ) {\n found_eof : if ( cur_file -> file != stdin ) {\n fclose ( cur_file -> file ) ;\n cur_file -> file = 0 ;\n }\n my_free ( cur_file -> file_name ) ;\n cur_file -> file_name = 0 ;\n if ( cur_file == file_stack ) {\n if ( cur_block != block_stack ) die ( \"Missing end of block\" ) ;\n * p = 0 ;\n DBUG_PRINT ( \"info\" , ( \"end of file at line %d\" , cur_file -> lineno ) ) ;\n DBUG_RETURN ( 1 ) ;\n }\n cur_file -- ;\n start_lineno = cur_file -> lineno ;\n continue ;\n }\n if ( c == '\\n' ) {\n cur_file -> lineno ++ ;\n if ( p != buf && * ( p - 1 ) == '\\r' ) p -- ;\n }\n switch ( state ) {\n case R_NORMAL : if ( end_of_query ( c ) ) {\n * p = 0 ;\n DBUG_PRINT ( \"exit\" , ( \"Found delimiter '%s' at line %d\" , delimiter , cur_file -> lineno ) ) ;\n DBUG_RETURN ( 0 ) ;\n }\n else if ( ( c == '{\n' && ( ! my_strnncoll_simple ( charset_info , ( const uchar * ) \"while\" , 5 , ( uchar * ) buf , min ( 5 , p - buf ) , 0 ) || ! my_strnncoll_simple ( charset_info , ( const uchar * ) \"if\" , 2 , ( uchar * ) buf , min ( 2 , p - buf ) , 0 ) ) ) ) {\n * p ++ = c ;\n * p = 0 ;\n DBUG_PRINT ( \"exit\" , ( \"Found '{\n' indicating start of block at line %d\" , cur_file -> lineno ) ) ;\n DBUG_RETURN ( 0 ) ;\n }\n else if ( c == '\\'' || c == '\"' || c == '`' ) {\n if ( ! have_slash ) {\n last_quote = c ;\n state = R_Q ;\n }\n }\n have_slash = ( c == '\\\\' ) ;\n break ;\n case R_COMMENT : if ( c == '\\n' ) {\n * p = 0 ;\n DBUG_PRINT ( \"exit\" , ( \"Found newline in comment at line: %d\" , cur_file -> lineno ) ) ;\n DBUG_RETURN ( 0 ) ;\n }\n break ;\n case R_LINE_START : if ( c == '#' || c == '-' ) {\n state = R_COMMENT ;\n }\n else if ( my_isspace ( charset_info , c ) ) {\n if ( c == '\\n' ) {\n if ( last_char == '\\n' ) {\n DBUG_PRINT ( \"info\" , ( \"Found two new lines in a row\" ) ) ;\n * p ++ = c ;\n * p = 0 ;\n DBUG_RETURN ( 0 ) ;\n }\n start_lineno = cur_file -> lineno ;\n DBUG_PRINT ( \"info\" , ( \"Query hasn't started yet, start_lineno: %d\" , start_lineno ) ) ;\n }\n skip_char = 1 ;\n }\n else if ( end_of_query ( c ) ) {\n * p = 0 ;\n DBUG_PRINT ( \"exit\" , ( \"Found delimiter '%s' at line: %d\" , delimiter , cur_file -> lineno ) ) ;\n DBUG_RETURN ( 0 ) ;\n }\n else if ( c == '}\n' ) {\n * p ++ = c ;\n * p = 0 ;\n DBUG_PRINT ( \"exit\" , ( \"Found '}\n' in begining of a line at line: %d\" , cur_file -> lineno ) ) ;\n DBUG_RETURN ( 0 ) ;\n }\n else if ( c == '\\'' || c == '\"' || c == '`' ) {\n last_quote = c ;\n state = R_Q ;\n }\n else state = R_NORMAL ;\n break ;\n case R_Q : if ( c == last_quote ) state = R_NORMAL ;\n else if ( c == '\\\\' ) state = R_SLASH_IN_Q ;\n break ;\n case R_SLASH_IN_Q : state = R_Q ;\n break ;\n }\n last_char = c ;\n if ( ! skip_char ) {\n # ifdef USE_MB int charlen = my_mbcharlen ( charset_info , ( unsigned char ) c ) ;\n if ( ( charlen > 1 ) && ( p + charlen ) <= buf_end ) {\n int i ;\n char * mb_start = p ;\n * p ++ = c ;\n for ( i = 1 ;\n i < charlen ;\n i ++ ) {\n c = my_getc ( cur_file -> file ) ;\n if ( feof ( cur_file -> file ) ) goto found_eof ;\n * p ++ = c ;\n }\n if ( ! my_ismbchar ( charset_info , mb_start , p ) ) {\n while ( p - 1 > mb_start ) my_ungetc ( * -- p ) ;\n }\n }\n else # endif * p ++ = c ;\n }\n }\n die ( \"The input buffer is too small for this query.x\\n\" \"check your query or increase MAX_QUERY and recompile\" ) ;\n DBUG_RETURN ( 0 ) ;\n }", "idx": 71}
{"hash": -8028756826159773630, "project": "debian", "size": 19, "label": 0, "functionSource": "static void repoint_table_dependencies ( ArchiveHandle * AH ) {\n TocEntry * te ;\n int i ;\n DumpId olddep ;\n for ( te = AH -> toc -> next ;\n te != AH -> toc ;\n te = te -> next ) {\n if ( te -> section != SECTION_POST_DATA ) continue ;\n for ( i = 0 ;\n i < te -> nDeps ;\n i ++ ) {\n olddep = te -> dependencies [ i ] ;\n if ( olddep <= AH -> maxDumpId && AH -> tableDataId [ olddep ] != 0 ) {\n te -> dependencies [ i ] = AH -> tableDataId [ olddep ] ;\n ahlog ( AH , 2 , \"transferring dependency %d -> %d to %d\\n\" , te -> dumpId , olddep , AH -> tableDataId [ olddep ] ) ;\n }\n }\n }\n }", "idx": 72}
{"hash": -3053641395158209010, "project": "debian", "size": 55, "label": 0, "functionSource": "static int x ( struct vcache * avc , int afun , struct vrequest * areq , \\ struct afs_pdata * ain , struct afs_pdata * aout , \\ afs_ucred_t * * acred ) DECL_PIOCTL ( PGetFID ) ;\n DECL_PIOCTL ( PSetAcl ) ;\n DECL_PIOCTL ( PStoreBehind ) ;\n DECL_PIOCTL ( PGCPAGs ) ;\n DECL_PIOCTL ( PGetAcl ) ;\n DECL_PIOCTL ( PNoop ) ;\n DECL_PIOCTL ( PBogus ) ;\n DECL_PIOCTL ( PGetFileCell ) ;\n DECL_PIOCTL ( PGetWSCell ) ;\n DECL_PIOCTL ( PGetUserCell ) ;\n DECL_PIOCTL ( PSetTokens ) ;\n DECL_PIOCTL ( PGetVolumeStatus ) ;\n DECL_PIOCTL ( PSetVolumeStatus ) ;\n DECL_PIOCTL ( PFlush ) ;\n DECL_PIOCTL ( PNewStatMount ) ;\n DECL_PIOCTL ( PGetTokens ) ;\n DECL_PIOCTL ( PUnlog ) ;\n DECL_PIOCTL ( PMariner ) ;\n DECL_PIOCTL ( PCheckServers ) ;\n DECL_PIOCTL ( PCheckVolNames ) ;\n DECL_PIOCTL ( PCheckAuth ) ;\n DECL_PIOCTL ( PFindVolume ) ;\n DECL_PIOCTL ( PViceAccess ) ;\n DECL_PIOCTL ( PSetCacheSize ) ;\n DECL_PIOCTL ( PGetCacheSize ) ;\n DECL_PIOCTL ( PRemoveCallBack ) ;\n DECL_PIOCTL ( PNewCell ) ;\n DECL_PIOCTL ( PNewAlias ) ;\n DECL_PIOCTL ( PListCells ) ;\n DECL_PIOCTL ( PListAliases ) ;\n DECL_PIOCTL ( PRemoveMount ) ;\n DECL_PIOCTL ( PGetCellStatus ) ;\n DECL_PIOCTL ( PSetCellStatus ) ;\n DECL_PIOCTL ( PFlushVolumeData ) ;\n DECL_PIOCTL ( PFlushAllVolumeData ) ;\n DECL_PIOCTL ( PGetVnodeXStatus ) ;\n DECL_PIOCTL ( PGetVnodeXStatus2 ) ;\n DECL_PIOCTL ( PSetSysName ) ;\n DECL_PIOCTL ( PSetSPrefs ) ;\n DECL_PIOCTL ( PSetSPrefs33 ) ;\n DECL_PIOCTL ( PGetSPrefs ) ;\n DECL_PIOCTL ( PExportAfs ) ;\n DECL_PIOCTL ( PGag ) ;\n DECL_PIOCTL ( PTwiddleRx ) ;\n DECL_PIOCTL ( PGetInitParams ) ;\n DECL_PIOCTL ( PGetRxkcrypt ) ;\n DECL_PIOCTL ( PSetRxkcrypt ) ;\n DECL_PIOCTL ( PGetCPrefs ) ;\n DECL_PIOCTL ( PSetCPrefs ) ;\n DECL_PIOCTL ( PFlushMount ) ;\n DECL_PIOCTL ( PRxStatProc ) ;\n DECL_PIOCTL ( PRxStatPeer ) ;\n DECL_PIOCTL ( PPrefetchFromTape ) ;\n DECL_PIOCTL ( PFsCmd ) ;\n DECL_PIOCTL ( PCallBackAddr )", "idx": 73}
{"hash": -7262742957929857695, "project": "chrome", "size": 135, "label": 0, "functionSource": "void xsltCompileAttr ( xsltStylesheetPtr style , xmlAttrPtr attr ) {\n const xmlChar * str ;\n const xmlChar * cur ;\n xmlChar * ret = NULL ;\n xmlChar * expr = NULL ;\n xsltAttrVTPtr avt ;\n int i = 0 , lastavt = 0 ;\n if ( ( style == NULL ) || ( attr == NULL ) || ( attr -> children == NULL ) ) return ;\n if ( ( attr -> children -> type != XML_TEXT_NODE ) || ( attr -> children -> next != NULL ) ) {\n xsltTransformError ( NULL , style , attr -> parent , \"Attribute '%s': The content is expected to be a single text \" \"node when compiling an AVT.\\n\" , attr -> name ) ;\n style -> errors ++ ;\n return ;\n }\n str = attr -> children -> content ;\n if ( ( xmlStrchr ( str , '{\n' ) == NULL ) && ( xmlStrchr ( str , '}\n' ) == NULL ) ) return ;\n # ifdef WITH_XSLT_DEBUG_AVT xsltGenericDebug ( xsltGenericDebugContext , \"Found AVT %s: %s\\n\" , attr -> name , str ) ;\n # endif if ( attr -> psvi != NULL ) {\n # ifdef WITH_XSLT_DEBUG_AVT xsltGenericDebug ( xsltGenericDebugContext , \"AVT %s: already compiled\\n\" , attr -> name ) ;\n # endif return ;\n }\n avt = xsltNewAttrVT ( style ) ;\n if ( avt == NULL ) return ;\n attr -> psvi = avt ;\n avt -> nsList = xmlGetNsList ( attr -> doc , attr -> parent ) ;\n if ( avt -> nsList != NULL ) {\n while ( avt -> nsList [ i ] != NULL ) i ++ ;\n }\n avt -> nsNr = i ;\n cur = str ;\n while ( * cur != 0 ) {\n if ( * cur == '{\n' ) {\n if ( * ( cur + 1 ) == '{\n' ) {\n cur ++ ;\n ret = xmlStrncat ( ret , str , cur - str ) ;\n cur ++ ;\n str = cur ;\n continue ;\n }\n if ( * ( cur + 1 ) == '}\n' ) {\n ret = xmlStrncat ( ret , str , cur - str ) ;\n cur += 2 ;\n str = cur ;\n continue ;\n }\n if ( ( ret != NULL ) || ( cur - str > 0 ) ) {\n ret = xmlStrncat ( ret , str , cur - str ) ;\n str = cur ;\n if ( avt -> nb_seg == 0 ) avt -> strstart = 1 ;\n if ( ( avt = xsltSetAttrVTsegment ( avt , ( void * ) ret ) ) == NULL ) goto error ;\n ret = NULL ;\n lastavt = 0 ;\n }\n cur ++ ;\n while ( ( * cur != 0 ) && ( * cur != '}\n' ) ) {\n if ( ( * cur == '\\'' ) || ( * cur == '\"' ) ) {\n char delim = * ( cur ++ ) ;\n while ( ( * cur != 0 ) && ( * cur != delim ) ) cur ++ ;\n if ( * cur != 0 ) cur ++ ;\n }\n else cur ++ ;\n }\n if ( * cur == 0 ) {\n xsltTransformError ( NULL , style , attr -> parent , \"Attribute '%s': The AVT has an unmatched '{\n'.\\n\" , attr -> name ) ;\n style -> errors ++ ;\n goto error ;\n }\n str ++ ;\n expr = xmlStrndup ( str , cur - str ) ;\n if ( expr == NULL ) {\n XSLT_TODO goto error ;\n }\n else {\n xmlXPathCompExprPtr comp ;\n comp = xsltXPathCompile ( style , expr ) ;\n if ( comp == NULL ) {\n xsltTransformError ( NULL , style , attr -> parent , \"Attribute '%s': Failed to compile the expression \" \"'%s' in the AVT.\\n\" , attr -> name , expr ) ;\n style -> errors ++ ;\n goto error ;\n }\n if ( avt -> nb_seg == 0 ) avt -> strstart = 0 ;\n if ( lastavt == 1 ) {\n if ( ( avt = xsltSetAttrVTsegment ( avt , NULL ) ) == NULL ) goto error ;\n }\n if ( ( avt = xsltSetAttrVTsegment ( avt , ( void * ) comp ) ) == NULL ) goto error ;\n lastavt = 1 ;\n xmlFree ( expr ) ;\n expr = NULL ;\n }\n cur ++ ;\n str = cur ;\n }\n else if ( * cur == '}\n' ) {\n cur ++ ;\n if ( * cur == '}\n' ) {\n ret = xmlStrncat ( ret , str , cur - str ) ;\n cur ++ ;\n str = cur ;\n continue ;\n }\n else {\n xsltTransformError ( NULL , style , attr -> parent , \"Attribute '%s': The AVT has an unmatched '}\n'.\\n\" , attr -> name ) ;\n goto error ;\n }\n }\n else cur ++ ;\n }\n if ( ( ret != NULL ) || ( cur - str > 0 ) ) {\n ret = xmlStrncat ( ret , str , cur - str ) ;\n str = cur ;\n if ( avt -> nb_seg == 0 ) avt -> strstart = 1 ;\n if ( ( avt = xsltSetAttrVTsegment ( avt , ( void * ) ret ) ) == NULL ) goto error ;\n ret = NULL ;\n }\n error : if ( avt == NULL ) {\n xsltTransformError ( NULL , style , attr -> parent , \"xsltCompileAttr: malloc problem\\n\" ) ;\n }\n else {\n if ( attr -> psvi != avt ) {\n attr -> psvi = avt ;\n style -> attVTs = avt ;\n }\n }\n if ( ret != NULL ) xmlFree ( ret ) ;\n if ( expr != NULL ) xmlFree ( expr ) ;\n }", "idx": 74}
{"hash": 6302861533225984845, "project": "debian", "size": 8, "label": 0, "functionSource": "static int pxa2xx_clkcfg_write ( CPUARMState * env , const ARMCPRegInfo * ri , uint64_t value ) {\n PXA2xxState * s = ( PXA2xxState * ) ri -> opaque ;\n s -> clkcfg = value & 0xf ;\n if ( value & 2 ) {\n printf ( \"%s: CPU frequency change attempt\\n\" , __func__ ) ;\n }\n return 0 ;\n }", "idx": 75}
{"hash": -46053003459728034, "project": "chrome", "size": 10, "label": 0, "functionSource": "static uint8_t lut_interp_linear_precache_output ( uint32_t input_value , uint16_t * table , size_t length ) {\n uintptr_t value = ( input_value * ( length - 1 ) ) ;\n uint32_t upper = ( value + PRECACHE_OUTPUT_MAX - 1 ) / PRECACHE_OUTPUT_MAX ;\n uint32_t lower = value / PRECACHE_OUTPUT_MAX ;\n uint32_t interp = value % PRECACHE_OUTPUT_MAX ;\n value = ( table [ upper ] * ( interp ) + table [ lower ] * ( PRECACHE_OUTPUT_MAX - interp ) ) ;\n value += ( PRECACHE_OUTPUT_MAX * 65535 / 255 ) / 2 ;\n value /= ( PRECACHE_OUTPUT_MAX * 65535 / 255 ) ;\n return value ;\n }", "idx": 76}
{"hash": 4489017523191997023, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h225_OCTET_STRING_SIZE_4 ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_octet_string ( tvb , offset , actx , tree , hf_index , 4 , 4 , FALSE , NULL ) ;\n return offset ;\n }", "idx": 77}
{"hash": 6790518433053241091, "project": "debian", "size": 6, "label": 0, "functionSource": "static void gtkui_kill_connections ( void ) {\n DEBUG_MSG ( \"gtk_kill_connections\" ) ;\n g_source_remove ( connections_idle ) ;\n gtk_widget_destroy ( conns_window ) ;\n conns_window = NULL ;\n }", "idx": 78}
{"hash": 2709342705526909410, "project": "debian", "size": 4, "label": 0, "functionSource": "int ssl_allow_compression ( SSL * s ) {\n if ( s -> options & SSL_OP_NO_COMPRESSION ) return 0 ;\n return ssl_security ( s , SSL_SECOP_COMPRESSION , 0 , 0 , NULL ) ;\n }", "idx": 79}
{"hash": 2772622454795674000, "project": "debian", "size": 14, "label": 0, "functionSource": "static int h263_skip_b_part ( MpegEncContext * s , int cbp ) {\n LOCAL_ALIGNED_16 ( int16_t , dblock , [ 64 ] ) ;\n int i , mbi ;\n mbi = s -> mb_intra ;\n s -> mb_intra = 0 ;\n for ( i = 0 ;\n i < 6 ;\n i ++ ) {\n if ( h263_decode_block ( s , dblock , i , cbp & 32 ) < 0 ) return - 1 ;\n cbp += cbp ;\n }\n s -> mb_intra = mbi ;\n return 0 ;\n }", "idx": 80}
{"hash": 378220832151730865, "project": "debian", "size": 9, "label": 0, "functionSource": "int qemuMonitorTextSystemReset ( qemuMonitorPtr mon ) {\n char * info ;\n if ( qemuMonitorHMPCommand ( mon , \"system_reset\" , & info ) < 0 ) {\n qemuReportError ( VIR_ERR_OPERATION_FAILED , \"%s\" , _ ( \"system reset operation failed\" ) ) ;\n return - 1 ;\n }\n VIR_FREE ( info ) ;\n return 0 ;\n }", "idx": 81}
{"hash": 8320716512483418415, "project": "chrome", "size": 26, "label": 0, "functionSource": "void vp9_idct16x16_10_add_c ( const tran_low_t * input , uint8_t * dest , int stride ) {\n tran_low_t out [ 16 * 16 ] = {\n 0 }\n ;\n tran_low_t * outptr = out ;\n int i , j ;\n tran_low_t temp_in [ 16 ] , temp_out [ 16 ] ;\n for ( i = 0 ;\n i < 4 ;\n ++ i ) {\n idct16 ( input , outptr ) ;\n input += 16 ;\n outptr += 16 ;\n }\n for ( i = 0 ;\n i < 16 ;\n ++ i ) {\n for ( j = 0 ;\n j < 16 ;\n ++ j ) temp_in [ j ] = out [ j * 16 + i ] ;\n idct16 ( temp_in , temp_out ) ;\n for ( j = 0 ;\n j < 16 ;\n ++ j ) dest [ j * stride + i ] = clip_pixel ( ROUND_POWER_OF_TWO ( temp_out [ j ] , 6 ) + dest [ j * stride + i ] ) ;\n }\n }", "idx": 82}
{"hash": 6862887795439011210, "project": "chrome", "size": 18, "label": 0, "functionSource": "TEST_F ( SSLErrorAssistantTest , DynamicInterstitialListOverridable ) {\n ASSERT_TRUE ( embedded_test_server ( ) -> Start ( ) ) ;\n EXPECT_EQ ( 1u , ssl_info ( ) . public_key_hashes . size ( ) ) ;\n auto config_proto = std : : make_unique < chrome_browser_ssl : : SSLErrorAssistantConfig > ( ) ;\n config_proto -> set_version_id ( kLargeVersionId ) ;\n chrome_browser_ssl : : DynamicInterstitial * filter = config_proto -> add_dynamic_interstitial ( ) ;\n filter -> set_interstitial_type ( chrome_browser_ssl : : DynamicInterstitial : : INTERSTITIAL_PAGE_SSL ) ;\n filter -> set_cert_error ( chrome_browser_ssl : : DynamicInterstitial : : ERR_CERT_COMMON_NAME_INVALID ) ;\n filter -> add_sha256_hash ( \"sha256uthatch\" ) ;\n filter -> add_sha256_hash ( ssl_info ( ) . public_key_hashes [ 0 ] . ToString ( ) ) ;\n filter -> add_sha256_hash ( \"sha256/treecreeper\" ) ;\n filter -> set_mitm_software_name ( \"UwS\" ) ;\n filter -> set_issuer_common_name_regex ( \"[0-9]+.0.[0-9]+.1\" ) ;\n filter -> set_issuer_organization_regex ( \"T[a-z]+t CA\" ) ;\n filter -> set_show_only_for_nonoverridable_errors ( true ) ;\n error_assistant ( ) -> SetErrorAssistantProto ( std : : move ( config_proto ) ) ;\n EXPECT_FALSE ( error_assistant ( ) -> MatchDynamicInterstitial ( ssl_info ( ) , true ) ) ;\n }", "idx": 83}
{"hash": -673406620978847526, "project": "chrome", "size": 10, "label": 0, "functionSource": "static void TestFramePrinting ( WebLocalFrameImpl * frame ) {\n WebPrintParams print_params ;\n WebSize page_size ( 500 , 500 ) ;\n print_params . print_content_area . width = page_size . width ;\n print_params . print_content_area . height = page_size . height ;\n EXPECT_EQ ( 1 , frame -> PrintBegin ( print_params , WebNode ( ) ) ) ;\n PaintRecorder recorder ;\n frame -> PrintPagesForTesting ( recorder . beginRecording ( IntRect ( ) ) , page_size ) ;\n frame -> PrintEnd ( ) ;\n }", "idx": 84}
{"hash": -7670127399145950875, "project": "debian", "size": 5, "label": 0, "functionSource": "static int pop_value ( i_ctx_t * i_ctx_p , ref * pvalue ) {\n if ( ! ref_stack_count ( & o_stack ) ) return_error ( gs_error_stackunderflow ) ;\n * pvalue = * ref_stack_index ( & o_stack , 0L ) ;\n return 0 ;\n }", "idx": 85}
{"hash": 1245821301839614810, "project": "debian", "size": 10, "label": 0, "functionSource": "static int run_cancel_or_skip_warning ( CommonJob * job , char * primary_text , char * secondary_text , const char * details_text , int total_operations , int operations_remaining ) {\n int response ;\n if ( total_operations == 1 ) {\n response = run_warning ( job , primary_text , secondary_text , details_text , FALSE , CANCEL , NULL ) ;\n }\n else {\n response = run_warning ( job , primary_text , secondary_text , details_text , operations_remaining > 1 , CANCEL , SKIP_ALL , SKIP , NULL ) ;\n }\n return response ;\n }", "idx": 86}
{"hash": 6302861533225984845, "project": "debian", "size": 16, "label": 0, "functionSource": "static uint64_t pxa2xx_i2c_read ( void * opaque , hwaddr addr , unsigned size ) {\n PXA2xxI2CState * s = ( PXA2xxI2CState * ) opaque ;\n addr -= s -> offset ;\n switch ( addr ) {\n case ICR : return s -> control ;\n case ISR : return s -> status | ( i2c_bus_busy ( s -> bus ) << 2 ) ;\n case ISAR : return s -> slave -> i2c . address ;\n case IDBR : return s -> data ;\n case IBMR : if ( s -> status & ( 1 << 2 ) ) s -> ibmr ^= 3 ;\n else s -> ibmr = 0 ;\n return s -> ibmr ;\n default : printf ( \"%s: Bad register \" REG_FMT \"\\n\" , __FUNCTION__ , addr ) ;\n break ;\n }\n return 0 ;\n }", "idx": 87}
{"hash": -3135212895432241239, "project": "debian", "size": 6, "label": 0, "functionSource": "static guint32 dissect_netb_session_end ( tvbuff_t * tvb , packet_info * pinfo _U_ , int offset , proto_tree * tree ) {\n nb_data2 ( hf_netb_termination_indicator , tvb , offset , tree ) ;\n nb_remote_session ( tvb , offset , tree ) ;\n nb_local_session ( tvb , offset , tree ) ;\n return 0 ;\n }", "idx": 88}
{"hash": 8445816931248660591, "project": "debian", "size": 10, "label": 0, "functionSource": "static void spl_dllist_it_get_current_data ( zend_object_iterator * iter , zval * * * data TSRMLS_DC ) {\n spl_dllist_it * iterator = ( spl_dllist_it * ) iter ;\n spl_ptr_llist_element * element = iterator -> traverse_pointer ;\n if ( element == NULL || element -> data == NULL ) {\n * data = NULL ;\n }\n else {\n * data = ( zval * * ) & element -> data ;\n }\n }", "idx": 89}
{"hash": 4187524518637656726, "project": "debian", "size": 561, "label": 0, "functionSource": "int # ifdef GLOB_ATTRIBUTE GLOB_ATTRIBUTE # endif glob ( pattern , flags , errfunc , pglob ) const char * pattern ;\n int flags ;\n int ( * errfunc ) ( const char * , int ) ;\n glob_t * pglob ;\n {\n const char * filename ;\n char * dirname = NULL ;\n size_t dirlen ;\n int status ;\n size_t oldcount ;\n int meta ;\n int dirname_modified ;\n int malloc_dirname = 0 ;\n glob_t dirs ;\n int retval = 0 ;\n # ifdef _LIBC size_t alloca_used = 0 ;\n # endif if ( pattern == NULL || pglob == NULL || ( flags & ~ __GLOB_FLAGS ) != 0 ) {\n __set_errno ( EINVAL ) ;\n return - 1 ;\n }\n if ( ! ( flags & GLOB_DOOFFS ) ) pglob -> gl_offs = 0 ;\n if ( flags & GLOB_BRACE ) {\n const char * begin ;\n if ( flags & GLOB_NOESCAPE ) begin = strchr ( pattern , '{\n' ) ;\n else {\n begin = pattern ;\n while ( 1 ) {\n if ( * begin == '\\0' ) {\n begin = NULL ;\n break ;\n }\n if ( * begin == '\\\\' && begin [ 1 ] != '\\0' ) ++ begin ;\n else if ( * begin == '{\n' ) break ;\n ++ begin ;\n }\n }\n if ( begin != NULL ) {\n size_t firstc ;\n char * alt_start ;\n const char * p ;\n const char * next ;\n const char * rest ;\n size_t rest_len ;\n char * onealt ;\n size_t pattern_len = strlen ( pattern ) - 1 ;\n # ifdef _LIBC int alloca_onealt = __libc_use_alloca ( alloca_used + pattern_len ) ;\n if ( alloca_onealt ) onealt = alloca_account ( pattern_len , alloca_used ) ;\n else # endif {\n onealt = ( char * ) malloc ( pattern_len ) ;\n if ( onealt == NULL ) {\n if ( ! ( flags & GLOB_APPEND ) ) {\n pglob -> gl_pathc = 0 ;\n pglob -> gl_pathv = NULL ;\n }\n return GLOB_NOSPACE ;\n }\n }\n alt_start = mempcpy ( onealt , pattern , begin - pattern ) ;\n next = next_brace_sub ( begin + 1 , flags ) ;\n if ( next == NULL ) {\n illegal_brace : # ifdef _LIBC if ( __builtin_expect ( ! alloca_onealt , 0 ) ) # endif free ( onealt ) ;\n return glob ( pattern , flags & ~ GLOB_BRACE , errfunc , pglob ) ;\n }\n rest = next ;\n while ( * rest != '}\n' ) {\n rest = next_brace_sub ( rest + 1 , flags ) ;\n if ( rest == NULL ) goto illegal_brace ;\n }\n rest_len = strlen ( ++ rest ) + 1 ;\n if ( ! ( flags & GLOB_APPEND ) ) {\n pglob -> gl_pathc = 0 ;\n pglob -> gl_pathv = NULL ;\n }\n firstc = pglob -> gl_pathc ;\n p = begin + 1 ;\n while ( 1 ) {\n int result ;\n mempcpy ( mempcpy ( alt_start , p , next - p ) , rest , rest_len ) ;\n result = glob ( onealt , ( ( flags & ~ ( GLOB_NOCHECK | GLOB_NOMAGIC ) ) | GLOB_APPEND ) , errfunc , pglob ) ;\n if ( result && result != GLOB_NOMATCH ) {\n # ifdef _LIBC if ( __builtin_expect ( ! alloca_onealt , 0 ) ) # endif free ( onealt ) ;\n if ( ! ( flags & GLOB_APPEND ) ) {\n globfree ( pglob ) ;\n pglob -> gl_pathc = 0 ;\n }\n return result ;\n }\n if ( * next == '}\n' ) break ;\n p = next + 1 ;\n next = next_brace_sub ( p , flags ) ;\n assert ( next != NULL ) ;\n }\n # ifdef _LIBC if ( __builtin_expect ( ! alloca_onealt , 0 ) ) # endif free ( onealt ) ;\n if ( pglob -> gl_pathc != firstc ) return 0 ;\n else if ( ! ( flags & ( GLOB_NOCHECK | GLOB_NOMAGIC ) ) ) return GLOB_NOMATCH ;\n }\n }\n if ( ! ( flags & GLOB_APPEND ) ) {\n pglob -> gl_pathc = 0 ;\n if ( ! ( flags & GLOB_DOOFFS ) ) pglob -> gl_pathv = NULL ;\n else {\n size_t i ;\n pglob -> gl_pathv = ( char * * ) malloc ( ( pglob -> gl_offs + 1 ) * sizeof ( char * ) ) ;\n if ( pglob -> gl_pathv == NULL ) return GLOB_NOSPACE ;\n for ( i = 0 ;\n i <= pglob -> gl_offs ;\n ++ i ) pglob -> gl_pathv [ i ] = NULL ;\n }\n }\n oldcount = pglob -> gl_pathc + pglob -> gl_offs ;\n filename = strrchr ( pattern , '/' ) ;\n # if defined __MSDOS__ || defined WINDOWS32 if ( filename == NULL ) filename = strchr ( pattern , ':' ) ;\n # endif dirname_modified = 0 ;\n if ( filename == NULL ) {\n if ( ( flags & ( GLOB_TILDE | GLOB_TILDE_CHECK ) ) && pattern [ 0 ] == '~' ) {\n dirname = ( char * ) pattern ;\n dirlen = strlen ( pattern ) ;\n filename = NULL ;\n }\n else {\n if ( __builtin_expect ( pattern [ 0 ] == '\\0' , 0 ) ) {\n dirs . gl_pathv = NULL ;\n goto no_matches ;\n }\n filename = pattern ;\n # ifdef _AMIGA dirname = ( char * ) \"\" ;\n # else dirname = ( char * ) \".\" ;\n # endif dirlen = 0 ;\n }\n }\n else if ( filename == pattern || ( filename == pattern + 1 && pattern [ 0 ] == '\\\\' && ( flags & GLOB_NOESCAPE ) == 0 ) ) {\n dirname = ( char * ) \"/\" ;\n dirlen = 1 ;\n ++ filename ;\n }\n else {\n char * newp ;\n dirlen = filename - pattern ;\n # if defined __MSDOS__ || defined WINDOWS32 if ( * filename == ':' || ( filename > pattern + 1 && filename [ - 1 ] == ':' ) ) {\n char * drive_spec ;\n ++ dirlen ;\n drive_spec = ( char * ) __alloca ( dirlen + 1 ) ;\n * ( ( char * ) mempcpy ( drive_spec , pattern , dirlen ) ) = '\\0' ;\n if ( __glob_pattern_p ( drive_spec , ! ( flags & GLOB_NOESCAPE ) ) ) return GLOB_NOMATCH ;\n }\n # endif # ifdef _LIBC if ( __libc_use_alloca ( alloca_used + dirlen + 1 ) ) newp = alloca_account ( dirlen + 1 , alloca_used ) ;\n else # endif {\n newp = malloc ( dirlen + 1 ) ;\n if ( newp == NULL ) return GLOB_NOSPACE ;\n malloc_dirname = 1 ;\n }\n * ( ( char * ) mempcpy ( newp , pattern , dirlen ) ) = '\\0' ;\n dirname = newp ;\n ++ filename ;\n if ( filename [ 0 ] == '\\0' # if defined __MSDOS__ || defined WINDOWS32 && dirname [ dirlen - 1 ] != ':' && ( dirlen < 3 || dirname [ dirlen - 2 ] != ':' || dirname [ dirlen - 1 ] != '/' ) # endif && dirlen > 1 ) {\n int orig_flags = flags ;\n if ( ! ( flags & GLOB_NOESCAPE ) && dirname [ dirlen - 1 ] == '\\\\' ) {\n char * p = ( char * ) & dirname [ dirlen - 1 ] ;\n while ( p > dirname && p [ - 1 ] == '\\\\' ) -- p ;\n if ( ( & dirname [ dirlen ] - p ) & 1 ) {\n * ( char * ) & dirname [ -- dirlen ] = '\\0' ;\n flags &= ~ ( GLOB_NOCHECK | GLOB_NOMAGIC ) ;\n }\n }\n int val = glob ( dirname , flags | GLOB_MARK , errfunc , pglob ) ;\n if ( val == 0 ) pglob -> gl_flags = ( ( pglob -> gl_flags & ~ GLOB_MARK ) | ( flags & GLOB_MARK ) ) ;\n else if ( val == GLOB_NOMATCH && flags != orig_flags ) {\n dirs . gl_pathv = NULL ;\n flags = orig_flags ;\n oldcount = pglob -> gl_pathc + pglob -> gl_offs ;\n goto no_matches ;\n }\n retval = val ;\n goto out ;\n }\n }\n # ifndef VMS if ( ( flags & ( GLOB_TILDE | GLOB_TILDE_CHECK ) ) && dirname [ 0 ] == '~' ) {\n if ( dirname [ 1 ] == '\\0' || dirname [ 1 ] == '/' || ( ! ( flags & GLOB_NOESCAPE ) && dirname [ 1 ] == '\\\\' && ( dirname [ 2 ] == '\\0' || dirname [ 2 ] == '/' ) ) ) {\n char * home_dir = getenv ( \"HOME\" ) ;\n int malloc_home_dir = 0 ;\n # ifdef _AMIGA if ( home_dir == NULL || home_dir [ 0 ] == '\\0' ) home_dir = \"SYS:\" ;\n # else # ifdef WINDOWS32 if ( home_dir == NULL || home_dir [ 0 ] == '\\0' ) home_dir = \"c:/users/default\" ;\n # else if ( home_dir == NULL || home_dir [ 0 ] == '\\0' ) {\n int success ;\n char * name ;\n size_t buflen = GET_LOGIN_NAME_MAX ( ) + 1 ;\n if ( buflen == 0 ) buflen = 20 ;\n name = alloca_account ( buflen , alloca_used ) ;\n success = getlogin_r ( name , buflen ) == 0 ;\n if ( success ) {\n struct passwd * p ;\n # if defined HAVE_GETPWNAM_R || defined _LIBC long int pwbuflen = GETPW_R_SIZE_MAX ( ) ;\n char * pwtmpbuf ;\n struct passwd pwbuf ;\n int malloc_pwtmpbuf = 0 ;\n int save = errno ;\n # ifndef _LIBC if ( pwbuflen == - 1 ) pwbuflen = 1024 ;\n # endif if ( __libc_use_alloca ( alloca_used + pwbuflen ) ) pwtmpbuf = alloca_account ( pwbuflen , alloca_used ) ;\n else {\n pwtmpbuf = malloc ( pwbuflen ) ;\n if ( pwtmpbuf == NULL ) {\n retval = GLOB_NOSPACE ;\n goto out ;\n }\n malloc_pwtmpbuf = 1 ;\n }\n while ( getpwnam_r ( name , & pwbuf , pwtmpbuf , pwbuflen , & p ) != 0 ) {\n if ( errno != ERANGE ) {\n p = NULL ;\n break ;\n }\n if ( ! malloc_pwtmpbuf && __libc_use_alloca ( alloca_used + 2 * pwbuflen ) ) pwtmpbuf = extend_alloca_account ( pwtmpbuf , pwbuflen , 2 * pwbuflen , alloca_used ) ;\n else {\n char * newp = realloc ( malloc_pwtmpbuf ? pwtmpbuf : NULL , 2 * pwbuflen ) ;\n if ( newp == NULL ) {\n if ( __builtin_expect ( malloc_pwtmpbuf , 0 ) ) free ( pwtmpbuf ) ;\n retval = GLOB_NOSPACE ;\n goto out ;\n }\n pwtmpbuf = newp ;\n pwbuflen = 2 * pwbuflen ;\n malloc_pwtmpbuf = 1 ;\n }\n __set_errno ( save ) ;\n }\n # else p = getpwnam ( name ) ;\n # endif if ( p != NULL ) {\n if ( ! malloc_pwtmpbuf ) home_dir = p -> pw_dir ;\n else {\n size_t home_dir_len = strlen ( p -> pw_dir ) + 1 ;\n if ( __libc_use_alloca ( alloca_used + home_dir_len ) ) home_dir = alloca_account ( home_dir_len , alloca_used ) ;\n else {\n home_dir = malloc ( home_dir_len ) ;\n if ( home_dir == NULL ) {\n free ( pwtmpbuf ) ;\n retval = GLOB_NOSPACE ;\n goto out ;\n }\n malloc_home_dir = 1 ;\n }\n memcpy ( home_dir , p -> pw_dir , home_dir_len ) ;\n free ( pwtmpbuf ) ;\n }\n }\n }\n }\n if ( home_dir == NULL || home_dir [ 0 ] == '\\0' ) {\n if ( flags & GLOB_TILDE_CHECK ) {\n if ( __builtin_expect ( malloc_home_dir , 0 ) ) free ( home_dir ) ;\n retval = GLOB_NOMATCH ;\n goto out ;\n }\n else home_dir = ( char * ) \"~\" ;\n }\n # endif # endif if ( dirname [ 1 ] == '\\0' ) {\n if ( __builtin_expect ( malloc_dirname , 0 ) ) free ( dirname ) ;\n dirname = home_dir ;\n dirlen = strlen ( dirname ) ;\n malloc_dirname = malloc_home_dir ;\n }\n else {\n char * newp ;\n size_t home_len = strlen ( home_dir ) ;\n int use_alloca = __libc_use_alloca ( alloca_used + home_len + dirlen ) ;\n if ( use_alloca ) newp = alloca_account ( home_len + dirlen , alloca_used ) ;\n else {\n newp = malloc ( home_len + dirlen ) ;\n if ( newp == NULL ) {\n if ( __builtin_expect ( malloc_home_dir , 0 ) ) free ( home_dir ) ;\n retval = GLOB_NOSPACE ;\n goto out ;\n }\n }\n mempcpy ( mempcpy ( newp , home_dir , home_len ) , & dirname [ 1 ] , dirlen ) ;\n if ( __builtin_expect ( malloc_dirname , 0 ) ) free ( dirname ) ;\n dirname = newp ;\n dirlen += home_len - 1 ;\n malloc_dirname = ! use_alloca ;\n }\n dirname_modified = 1 ;\n }\n # if ! defined _AMIGA && ! defined WINDOWS32 else {\n char * end_name = strchr ( dirname , '/' ) ;\n char * user_name ;\n int malloc_user_name = 0 ;\n const char * home_dir ;\n char * unescape = NULL ;\n if ( ! ( flags & GLOB_NOESCAPE ) ) {\n if ( end_name == NULL ) {\n unescape = strchr ( dirname , '\\\\' ) ;\n if ( unescape ) end_name = strchr ( unescape , '\\0' ) ;\n }\n else unescape = memchr ( dirname , '\\\\' , end_name - dirname ) ;\n }\n if ( end_name == NULL ) user_name = dirname + 1 ;\n else {\n char * newp ;\n if ( __libc_use_alloca ( alloca_used + ( end_name - dirname ) ) ) newp = alloca_account ( end_name - dirname , alloca_used ) ;\n else {\n newp = malloc ( end_name - dirname ) ;\n if ( newp == NULL ) {\n retval = GLOB_NOSPACE ;\n goto out ;\n }\n malloc_user_name = 1 ;\n }\n if ( unescape != NULL ) {\n char * p = mempcpy ( newp , dirname + 1 , unescape - dirname - 1 ) ;\n char * q = unescape ;\n while ( * q != '\\0' ) {\n if ( * q == '\\\\' ) {\n if ( q [ 1 ] == '\\0' ) {\n if ( filename == NULL ) * p ++ = '\\\\' ;\n break ;\n }\n ++ q ;\n }\n * p ++ = * q ++ ;\n }\n * p = '\\0' ;\n }\n else * ( ( char * ) mempcpy ( newp , dirname + 1 , end_name - dirname ) ) = '\\0' ;\n user_name = newp ;\n }\n {\n struct passwd * p ;\n # if defined HAVE_GETPWNAM_R || defined _LIBC long int buflen = GETPW_R_SIZE_MAX ( ) ;\n char * pwtmpbuf ;\n int malloc_pwtmpbuf = 0 ;\n struct passwd pwbuf ;\n int save = errno ;\n # ifndef _LIBC if ( buflen == - 1 ) buflen = 1024 ;\n # endif if ( __libc_use_alloca ( alloca_used + buflen ) ) pwtmpbuf = alloca_account ( buflen , alloca_used ) ;\n else {\n pwtmpbuf = malloc ( buflen ) ;\n if ( pwtmpbuf == NULL ) {\n nomem_getpw : if ( __builtin_expect ( malloc_user_name , 0 ) ) free ( user_name ) ;\n retval = GLOB_NOSPACE ;\n goto out ;\n }\n malloc_pwtmpbuf = 1 ;\n }\n while ( getpwnam_r ( user_name , & pwbuf , pwtmpbuf , buflen , & p ) != 0 ) {\n if ( errno != ERANGE ) {\n p = NULL ;\n break ;\n }\n if ( ! malloc_pwtmpbuf && __libc_use_alloca ( alloca_used + 2 * buflen ) ) pwtmpbuf = extend_alloca_account ( pwtmpbuf , buflen , 2 * buflen , alloca_used ) ;\n else {\n char * newp = realloc ( malloc_pwtmpbuf ? pwtmpbuf : NULL , 2 * buflen ) ;\n if ( newp == NULL ) {\n if ( __builtin_expect ( malloc_pwtmpbuf , 0 ) ) free ( pwtmpbuf ) ;\n goto nomem_getpw ;\n }\n pwtmpbuf = newp ;\n malloc_pwtmpbuf = 1 ;\n }\n __set_errno ( save ) ;\n }\n # else p = getpwnam ( user_name ) ;\n # endif if ( __builtin_expect ( malloc_user_name , 0 ) ) free ( user_name ) ;\n if ( p != NULL ) {\n size_t home_len = strlen ( p -> pw_dir ) ;\n size_t rest_len = end_name == NULL ? 0 : strlen ( end_name ) ;\n if ( __builtin_expect ( malloc_dirname , 0 ) ) free ( dirname ) ;\n malloc_dirname = 0 ;\n if ( __libc_use_alloca ( alloca_used + home_len + rest_len + 1 ) ) dirname = alloca_account ( home_len + rest_len + 1 , alloca_used ) ;\n else {\n dirname = malloc ( home_len + rest_len + 1 ) ;\n if ( dirname == NULL ) {\n if ( __builtin_expect ( malloc_pwtmpbuf , 0 ) ) free ( pwtmpbuf ) ;\n retval = GLOB_NOSPACE ;\n goto out ;\n }\n malloc_dirname = 1 ;\n }\n * ( ( char * ) mempcpy ( mempcpy ( dirname , p -> pw_dir , home_len ) , end_name , rest_len ) ) = '\\0' ;\n dirlen = home_len + rest_len ;\n dirname_modified = 1 ;\n if ( __builtin_expect ( malloc_pwtmpbuf , 0 ) ) free ( pwtmpbuf ) ;\n }\n else {\n if ( __builtin_expect ( malloc_pwtmpbuf , 0 ) ) free ( pwtmpbuf ) ;\n if ( flags & GLOB_TILDE_CHECK ) return GLOB_NOMATCH ;\n }\n }\n }\n # endif }\n # endif if ( filename == NULL ) {\n struct stat st ;\n struct_stat64 st64 ;\n if ( ( flags & GLOB_NOCHECK ) || ( ( ( __builtin_expect ( flags & GLOB_ALTDIRFUNC , 0 ) ) ? ( ( * pglob -> gl_stat ) ( dirname , & st ) == 0 && S_ISDIR ( st . st_mode ) ) : ( __stat64 ( dirname , & st64 ) == 0 && S_ISDIR ( st64 . st_mode ) ) ) ) ) {\n int newcount = pglob -> gl_pathc + pglob -> gl_offs ;\n char * * new_gl_pathv ;\n new_gl_pathv = ( char * * ) realloc ( pglob -> gl_pathv , ( newcount + 1 + 1 ) * sizeof ( char * ) ) ;\n if ( new_gl_pathv == NULL ) {\n nospace : free ( pglob -> gl_pathv ) ;\n pglob -> gl_pathv = NULL ;\n pglob -> gl_pathc = 0 ;\n return GLOB_NOSPACE ;\n }\n pglob -> gl_pathv = new_gl_pathv ;\n if ( flags & GLOB_MARK ) {\n char * p ;\n pglob -> gl_pathv [ newcount ] = malloc ( dirlen + 2 ) ;\n if ( pglob -> gl_pathv [ newcount ] == NULL ) goto nospace ;\n p = mempcpy ( pglob -> gl_pathv [ newcount ] , dirname , dirlen ) ;\n p [ 0 ] = '/' ;\n p [ 1 ] = '\\0' ;\n }\n else {\n pglob -> gl_pathv [ newcount ] = strdup ( dirname ) ;\n if ( pglob -> gl_pathv [ newcount ] == NULL ) goto nospace ;\n }\n pglob -> gl_pathv [ ++ newcount ] = NULL ;\n ++ pglob -> gl_pathc ;\n pglob -> gl_flags = flags ;\n return 0 ;\n }\n return GLOB_NOMATCH ;\n }\n meta = __glob_pattern_type ( dirname , ! ( flags & GLOB_NOESCAPE ) ) ;\n if ( meta & 5 ) {\n size_t i ;\n if ( ! ( flags & GLOB_NOESCAPE ) && dirlen > 0 && dirname [ dirlen - 1 ] == '\\\\' ) {\n char * p = ( char * ) & dirname [ dirlen - 1 ] ;\n while ( p > dirname && p [ - 1 ] == '\\\\' ) -- p ;\n if ( ( & dirname [ dirlen ] - p ) & 1 ) * ( char * ) & dirname [ -- dirlen ] = '\\0' ;\n }\n if ( __builtin_expect ( ( flags & GLOB_ALTDIRFUNC ) != 0 , 0 ) ) {\n dirs . gl_opendir = pglob -> gl_opendir ;\n dirs . gl_readdir = pglob -> gl_readdir ;\n dirs . gl_closedir = pglob -> gl_closedir ;\n dirs . gl_stat = pglob -> gl_stat ;\n dirs . gl_lstat = pglob -> gl_lstat ;\n }\n status = glob ( dirname , ( ( flags & ( GLOB_ERR | GLOB_NOESCAPE | GLOB_ALTDIRFUNC ) ) | GLOB_NOSORT | GLOB_ONLYDIR ) , errfunc , & dirs ) ;\n if ( status != 0 ) {\n if ( ( flags & GLOB_NOCHECK ) == 0 || status != GLOB_NOMATCH ) return status ;\n goto no_matches ;\n }\n for ( i = 0 ;\n i < dirs . gl_pathc ;\n ++ i ) {\n int old_pathc ;\n # ifdef SHELL {\n extern int interrupt_state ;\n if ( interrupt_state ) {\n globfree ( & dirs ) ;\n return GLOB_ABORTED ;\n }\n }\n # endif old_pathc = pglob -> gl_pathc ;\n status = glob_in_dir ( filename , dirs . gl_pathv [ i ] , ( ( flags | GLOB_APPEND ) & ~ ( GLOB_NOCHECK | GLOB_NOMAGIC ) ) , errfunc , pglob , alloca_used ) ;\n if ( status == GLOB_NOMATCH ) continue ;\n if ( status != 0 ) {\n globfree ( & dirs ) ;\n globfree ( pglob ) ;\n pglob -> gl_pathc = 0 ;\n return status ;\n }\n if ( prefix_array ( dirs . gl_pathv [ i ] , & pglob -> gl_pathv [ old_pathc + pglob -> gl_offs ] , pglob -> gl_pathc - old_pathc ) ) {\n globfree ( & dirs ) ;\n globfree ( pglob ) ;\n pglob -> gl_pathc = 0 ;\n return GLOB_NOSPACE ;\n }\n }\n flags |= GLOB_MAGCHAR ;\n if ( pglob -> gl_pathc + pglob -> gl_offs == oldcount ) {\n no_matches : if ( flags & GLOB_NOCHECK ) {\n int newcount = pglob -> gl_pathc + pglob -> gl_offs ;\n char * * new_gl_pathv ;\n new_gl_pathv = ( char * * ) realloc ( pglob -> gl_pathv , ( newcount + 2 ) * sizeof ( char * ) ) ;\n if ( new_gl_pathv == NULL ) {\n globfree ( & dirs ) ;\n return GLOB_NOSPACE ;\n }\n pglob -> gl_pathv = new_gl_pathv ;\n pglob -> gl_pathv [ newcount ] = __strdup ( pattern ) ;\n if ( pglob -> gl_pathv [ newcount ] == NULL ) {\n globfree ( & dirs ) ;\n globfree ( pglob ) ;\n pglob -> gl_pathc = 0 ;\n return GLOB_NOSPACE ;\n }\n ++ pglob -> gl_pathc ;\n ++ newcount ;\n pglob -> gl_pathv [ newcount ] = NULL ;\n pglob -> gl_flags = flags ;\n }\n else {\n globfree ( & dirs ) ;\n return GLOB_NOMATCH ;\n }\n }\n globfree ( & dirs ) ;\n }\n else {\n int old_pathc = pglob -> gl_pathc ;\n int orig_flags = flags ;\n if ( meta & 2 ) {\n char * p = strchr ( dirname , '\\\\' ) , * q ;\n q = p ;\n do {\n if ( * p == '\\\\' ) {\n * q = * ++ p ;\n -- dirlen ;\n }\n else * q = * p ;\n ++ q ;\n }\n while ( * p ++ != '\\0' ) ;\n dirname_modified = 1 ;\n }\n if ( dirname_modified ) flags &= ~ ( GLOB_NOCHECK | GLOB_NOMAGIC ) ;\n status = glob_in_dir ( filename , dirname , flags , errfunc , pglob , alloca_used ) ;\n if ( status != 0 ) {\n if ( status == GLOB_NOMATCH && flags != orig_flags && pglob -> gl_pathc + pglob -> gl_offs == oldcount ) {\n dirs . gl_pathv = NULL ;\n flags = orig_flags ;\n goto no_matches ;\n }\n return status ;\n }\n if ( dirlen > 0 ) {\n if ( prefix_array ( dirname , & pglob -> gl_pathv [ old_pathc + pglob -> gl_offs ] , pglob -> gl_pathc - old_pathc ) ) {\n globfree ( pglob ) ;\n pglob -> gl_pathc = 0 ;\n return GLOB_NOSPACE ;\n }\n }\n }\n if ( flags & GLOB_MARK ) {\n size_t i ;\n struct stat st ;\n struct_stat64 st64 ;\n for ( i = oldcount ;\n i < pglob -> gl_pathc + pglob -> gl_offs ;\n ++ i ) if ( ( __builtin_expect ( flags & GLOB_ALTDIRFUNC , 0 ) ? ( ( * pglob -> gl_stat ) ( pglob -> gl_pathv [ i ] , & st ) == 0 && S_ISDIR ( st . st_mode ) ) : ( __stat64 ( pglob -> gl_pathv [ i ] , & st64 ) == 0 && S_ISDIR ( st64 . st_mode ) ) ) ) {\n size_t len = strlen ( pglob -> gl_pathv [ i ] ) + 2 ;\n char * new = realloc ( pglob -> gl_pathv [ i ] , len ) ;\n if ( new == NULL ) {\n globfree ( pglob ) ;\n pglob -> gl_pathc = 0 ;\n return GLOB_NOSPACE ;\n }\n strcpy ( & new [ len - 2 ] , \"/\" ) ;\n pglob -> gl_pathv [ i ] = new ;\n }\n }\n if ( ! ( flags & GLOB_NOSORT ) ) {\n qsort ( & pglob -> gl_pathv [ oldcount ] , pglob -> gl_pathc + pglob -> gl_offs - oldcount , sizeof ( char * ) , collated_compare ) ;\n }\n out : if ( __builtin_expect ( malloc_dirname , 0 ) ) free ( dirname ) ;\n return retval ;\n }", "idx": 90}
{"hash": -7943184491469275573, "project": "chrome", "size": 4, "label": 0, "functionSource": "const char * evutil_getenv ( const char * varname ) {\n if ( evutil_issetugid ( ) ) return NULL ;\n return getenv ( varname ) ;\n }", "idx": 91}
{"hash": -7076754245473579218, "project": "chrome", "size": 20, "label": 0, "functionSource": "static void evhttp_get_body ( struct evhttp_connection * evcon , struct evhttp_request * req ) {\n const char * xfer_enc ;\n if ( req -> kind == EVHTTP_REQUEST && req -> type != EVHTTP_REQ_POST ) {\n evhttp_connection_done ( evcon ) ;\n return ;\n }\n evcon -> state = EVCON_READING_BODY ;\n xfer_enc = evhttp_find_header ( req -> input_headers , \"Transfer-Encoding\" ) ;\n if ( xfer_enc != NULL && strcasecmp ( xfer_enc , \"chunked\" ) == 0 ) {\n req -> chunked = 1 ;\n req -> ntoread = - 1 ;\n }\n else {\n if ( evhttp_get_body_length ( req ) == - 1 ) {\n evhttp_connection_fail ( evcon , EVCON_HTTP_INVALID_HEADER ) ;\n return ;\n }\n }\n evhttp_read_body ( evcon , req ) ;\n }", "idx": 92}
{"hash": -6215323349888018447, "project": "debian", "size": 18, "label": 0, "functionSource": "static char * constructConnStr ( const char * * keywords , const char * * values ) {\n PQExpBuffer buf = createPQExpBuffer ( ) ;\n char * connstr ;\n int i ;\n bool firstkeyword = true ;\n for ( i = 0 ;\n keywords [ i ] != NULL ;\n i ++ ) {\n if ( strcmp ( keywords [ i ] , \"dbname\" ) == 0 || strcmp ( keywords [ i ] , \"password\" ) == 0 || strcmp ( keywords [ i ] , \"fallback_application_name\" ) == 0 ) continue ;\n if ( ! firstkeyword ) appendPQExpBufferChar ( buf , ' ' ) ;\n firstkeyword = false ;\n appendPQExpBuffer ( buf , \"%s=\" , keywords [ i ] ) ;\n appendConnStrVal ( buf , values [ i ] ) ;\n }\n connstr = pg_strdup ( buf -> data ) ;\n destroyPQExpBuffer ( buf ) ;\n return connstr ;\n }", "idx": 93}
{"hash": 3584320764213684062, "project": "debian", "size": 30, "label": 0, "functionSource": "static void get_name_from_fullpropspec ( struct CFullPropSpec * v , char * out , int bufsize ) {\n struct GuidPropertySet * pset = GuidPropertySet_find_guid ( & v -> guid ) ;\n const char * id_str , * guid_str ;\n char * dest = out ;\n id_str = pset ? try_val_to_str ( v -> u . propid , pset -> id_map ) : NULL ;\n if ( id_str ) {\n g_snprintf ( dest , bufsize , \"%s\" , id_str ) ;\n }\n else {\n guid_str = guids_get_guid_name ( & v -> guid ) ;\n if ( guid_str ) {\n g_snprintf ( dest , bufsize , \"\\\"%s\\\"\" , guid_str ) ;\n }\n else {\n guid_str = guid_to_str ( wmem_packet_scope ( ) , & v -> guid ) ;\n g_snprintf ( dest , bufsize , \"{\n%s}\n\" , guid_str ) ;\n }\n if ( v -> kind == PRSPEC_LPWSTR ) {\n g_snprintf ( dest , bufsize , \"%s \\\"%s\\\"\" , guid_str , v -> u . name ) ;\n }\n else if ( v -> kind == PRSPEC_PROPID ) {\n g_snprintf ( dest , bufsize , \"%s 0x%08x\" , guid_str , v -> u . propid ) ;\n }\n else {\n g_snprintf ( dest , bufsize , \"%s <INVALID>\" , dest ) ;\n }\n }\n }", "idx": 94}
{"hash": 6809509104003465181, "project": "chrome", "size": 149, "label": 1, "functionSource": "static void parse_command_line ( int argc , const char * * argv_ , AppInput * app_input , SvcContext * svc_ctx , vpx_codec_enc_cfg_t * enc_cfg ) {\n struct arg arg = {\n 0 }\n ;\n char * * argv = NULL ;\n char * * argi = NULL ;\n char * * argj = NULL ;\n vpx_codec_err_t res ;\n int passes = 0 ;\n int pass = 0 ;\n const char * fpf_file_name = NULL ;\n unsigned int min_bitrate = 0 ;\n unsigned int max_bitrate = 0 ;\n svc_ctx -> log_level = SVC_LOG_DEBUG ;\n svc_ctx -> spatial_layers = default_spatial_layers ;\n svc_ctx -> temporal_layers = default_temporal_layers ;\n res = vpx_codec_enc_config_default ( vpx_codec_vp9_cx ( ) , enc_cfg , 0 ) ;\n if ( res ) {\n die ( \"Failed to get config: %s\\n\" , vpx_codec_err_to_string ( res ) ) ;\n }\n enc_cfg -> g_w = default_width ;\n enc_cfg -> g_h = default_height ;\n enc_cfg -> g_timebase . num = default_timebase_num ;\n enc_cfg -> g_timebase . den = default_timebase_den ;\n enc_cfg -> rc_target_bitrate = default_bitrate ;\n enc_cfg -> kf_min_dist = default_kf_dist ;\n enc_cfg -> kf_max_dist = default_kf_dist ;\n enc_cfg -> rc_end_usage = VPX_CQ ;\n app_input -> frames_to_code = default_frames_to_code ;\n app_input -> frames_to_skip = default_frames_to_skip ;\n argv = argv_dup ( argc - 1 , argv_ + 1 ) ;\n for ( argi = argj = argv ;\n ( * argj = * argi ) ;\n argi += arg . argv_step ) {\n arg . argv_step = 1 ;\n if ( arg_match ( & arg , & frames_arg , argi ) ) {\n app_input -> frames_to_code = arg_parse_uint ( & arg ) ;\n }\n else if ( arg_match ( & arg , & width_arg , argi ) ) {\n enc_cfg -> g_w = arg_parse_uint ( & arg ) ;\n }\n else if ( arg_match ( & arg , & height_arg , argi ) ) {\n enc_cfg -> g_h = arg_parse_uint ( & arg ) ;\n }\n else if ( arg_match ( & arg , & timebase_arg , argi ) ) {\n enc_cfg -> g_timebase = arg_parse_rational ( & arg ) ;\n }\n else if ( arg_match ( & arg , & bitrate_arg , argi ) ) {\n enc_cfg -> rc_target_bitrate = arg_parse_uint ( & arg ) ;\n }\n else if ( arg_match ( & arg , & skip_frames_arg , argi ) ) {\n app_input -> frames_to_skip = arg_parse_uint ( & arg ) ;\n }\n else if ( arg_match ( & arg , & spatial_layers_arg , argi ) ) {\n svc_ctx -> spatial_layers = arg_parse_uint ( & arg ) ;\n }\n else if ( arg_match ( & arg , & temporal_layers_arg , argi ) ) {\n svc_ctx -> temporal_layers = arg_parse_uint ( & arg ) ;\n }\n else if ( arg_match ( & arg , & kf_dist_arg , argi ) ) {\n enc_cfg -> kf_min_dist = arg_parse_uint ( & arg ) ;\n enc_cfg -> kf_max_dist = enc_cfg -> kf_min_dist ;\n }\n else if ( arg_match ( & arg , & scale_factors_arg , argi ) ) {\n vpx_svc_set_scale_factors ( svc_ctx , arg . val ) ;\n }\n else if ( arg_match ( & arg , & quantizers_arg , argi ) ) {\n vpx_svc_set_quantizers ( svc_ctx , arg . val ) ;\n }\n else if ( arg_match ( & arg , & passes_arg , argi ) ) {\n passes = arg_parse_uint ( & arg ) ;\n if ( passes < 1 || passes > 2 ) {\n die ( \"Error: Invalid number of passes (%d)\\n\" , passes ) ;\n }\n }\n else if ( arg_match ( & arg , & pass_arg , argi ) ) {\n pass = arg_parse_uint ( & arg ) ;\n if ( pass < 1 || pass > 2 ) {\n die ( \"Error: Invalid pass selected (%d)\\n\" , pass ) ;\n }\n }\n else if ( arg_match ( & arg , & fpf_name_arg , argi ) ) {\n fpf_file_name = arg . val ;\n }\n else if ( arg_match ( & arg , & min_q_arg , argi ) ) {\n enc_cfg -> rc_min_quantizer = arg_parse_uint ( & arg ) ;\n }\n else if ( arg_match ( & arg , & max_q_arg , argi ) ) {\n enc_cfg -> rc_max_quantizer = arg_parse_uint ( & arg ) ;\n }\n else if ( arg_match ( & arg , & min_bitrate_arg , argi ) ) {\n min_bitrate = arg_parse_uint ( & arg ) ;\n }\n else if ( arg_match ( & arg , & max_bitrate_arg , argi ) ) {\n max_bitrate = arg_parse_uint ( & arg ) ;\n }\n else {\n ++ argj ;\n }\n }\n if ( passes == 0 || passes == 1 ) {\n if ( pass ) {\n fprintf ( stderr , \"pass is ignored since there's only one pass\\n\" ) ;\n }\n enc_cfg -> g_pass = VPX_RC_ONE_PASS ;\n }\n else {\n if ( pass == 0 ) {\n die ( \"pass must be specified when passes is 2\\n\" ) ;\n }\n if ( fpf_file_name == NULL ) {\n die ( \"fpf must be specified when passes is 2\\n\" ) ;\n }\n if ( pass == 1 ) {\n enc_cfg -> g_pass = VPX_RC_FIRST_PASS ;\n if ( ! stats_open_file ( & app_input -> rc_stats , fpf_file_name , 0 ) ) {\n fatal ( \"Failed to open statistics store\" ) ;\n }\n }\n else {\n enc_cfg -> g_pass = VPX_RC_LAST_PASS ;\n if ( ! stats_open_file ( & app_input -> rc_stats , fpf_file_name , 1 ) ) {\n fatal ( \"Failed to open statistics store\" ) ;\n }\n enc_cfg -> rc_twopass_stats_in = stats_get ( & app_input -> rc_stats ) ;\n }\n app_input -> passes = passes ;\n app_input -> pass = pass ;\n }\n if ( enc_cfg -> rc_target_bitrate > 0 ) {\n if ( min_bitrate > 0 ) {\n enc_cfg -> rc_2pass_vbr_minsection_pct = min_bitrate * 100 / enc_cfg -> rc_target_bitrate ;\n }\n if ( max_bitrate > 0 ) {\n enc_cfg -> rc_2pass_vbr_maxsection_pct = max_bitrate * 100 / enc_cfg -> rc_target_bitrate ;\n }\n }\n for ( argi = argv ;\n * argi ;\n ++ argi ) if ( argi [ 0 ] [ 0 ] == '-' && strlen ( argi [ 0 ] ) > 1 ) die ( \"Error: Unrecognized option %s\\n\" , * argi ) ;\n if ( argv [ 0 ] == NULL || argv [ 1 ] == 0 ) {\n usage_exit ( ) ;\n }\n app_input -> input_filename = argv [ 0 ] ;\n app_input -> output_filename = argv [ 1 ] ;\n free ( argv ) ;\n if ( enc_cfg -> g_w < 16 || enc_cfg -> g_w % 2 || enc_cfg -> g_h < 16 || enc_cfg -> g_h % 2 ) die ( \"Invalid resolution: %d x %d\\n\" , enc_cfg -> g_w , enc_cfg -> g_h ) ;\n printf ( \"Codec %s\\nframes: %d, skip: %d\\n\" \"layers: %d\\n\" \"width %d, height: %d,\\n\" \"num: %d, den: %d, bitrate: %d,\\n\" \"gop size: %d\\n\" , vpx_codec_iface_name ( vpx_codec_vp9_cx ( ) ) , app_input -> frames_to_code , app_input -> frames_to_skip , svc_ctx -> spatial_layers , enc_cfg -> g_w , enc_cfg -> g_h , enc_cfg -> g_timebase . num , enc_cfg -> g_timebase . den , enc_cfg -> rc_target_bitrate , enc_cfg -> kf_max_dist ) ;\n }", "idx": 95}
{"hash": 4180964683905830761, "project": "debian", "size": 3, "label": 0, "functionSource": "static int selinux_task_wait ( struct task_struct * p ) {\n return task_has_perm ( p , current , PROCESS__SIGCHLD ) ;\n }", "idx": 96}
{"hash": 7279312193592248512, "project": "debian", "size": 8, "label": 0, "functionSource": "static void intra_pred_lp_top ( uint8_t * d , uint8_t * top , uint8_t * left , int stride ) {\n int x , y ;\n for ( y = 0 ;\n y < 8 ;\n y ++ ) for ( x = 0 ;\n x < 8 ;\n x ++ ) d [ y * stride + x ] = LOWPASS ( top , x + 1 ) ;\n }", "idx": 97}
{"hash": -8965664157246946065, "project": "chrome", "size": 73, "label": 0, "functionSource": "int main ( int argc , char * * argv ) {\n FILE * infile = NULL ;\n vpx_codec_ctx_t codec ;\n vpx_codec_enc_cfg_t cfg ;\n int frame_count = 0 ;\n vpx_image_t raw ;\n vpx_codec_err_t res ;\n VpxVideoInfo info = {\n 0 }\n ;\n VpxVideoWriter * writer = NULL ;\n const VpxInterface * encoder = NULL ;\n const int fps = 30 ;\n const int bitrate = 200 ;\n int keyframe_interval = 0 ;\n const char * codec_arg = NULL ;\n const char * width_arg = NULL ;\n const char * height_arg = NULL ;\n const char * infile_arg = NULL ;\n const char * outfile_arg = NULL ;\n const char * keyframe_interval_arg = NULL ;\n exec_name = argv [ 0 ] ;\n if ( argc < 7 ) die ( \"Invalid number of arguments\" ) ;\n codec_arg = argv [ 1 ] ;\n width_arg = argv [ 2 ] ;\n height_arg = argv [ 3 ] ;\n infile_arg = argv [ 4 ] ;\n outfile_arg = argv [ 5 ] ;\n keyframe_interval_arg = argv [ 6 ] ;\n encoder = get_vpx_encoder_by_name ( codec_arg ) ;\n if ( ! encoder ) die ( \"Unsupported codec.\" ) ;\n info . codec_fourcc = encoder -> fourcc ;\n info . frame_width = strtol ( width_arg , NULL , 0 ) ;\n info . frame_height = strtol ( height_arg , NULL , 0 ) ;\n info . time_base . numerator = 1 ;\n info . time_base . denominator = fps ;\n if ( info . frame_width <= 0 || info . frame_height <= 0 || ( info . frame_width % 2 ) != 0 || ( info . frame_height % 2 ) != 0 ) {\n die ( \"Invalid frame size: %dx%d\" , info . frame_width , info . frame_height ) ;\n }\n if ( ! vpx_img_alloc ( & raw , VPX_IMG_FMT_I420 , info . frame_width , info . frame_height , 1 ) ) {\n die ( \"Failed to allocate image.\" ) ;\n }\n keyframe_interval = strtol ( keyframe_interval_arg , NULL , 0 ) ;\n if ( keyframe_interval < 0 ) die ( \"Invalid keyframe interval value.\" ) ;\n printf ( \"Using %s\\n\" , vpx_codec_iface_name ( encoder -> codec_interface ( ) ) ) ;\n res = vpx_codec_enc_config_default ( encoder -> codec_interface ( ) , & cfg , 0 ) ;\n if ( res ) die_codec ( & codec , \"Failed to get default codec config.\" ) ;\n cfg . g_w = info . frame_width ;\n cfg . g_h = info . frame_height ;\n cfg . g_timebase . num = info . time_base . numerator ;\n cfg . g_timebase . den = info . time_base . denominator ;\n cfg . rc_target_bitrate = bitrate ;\n cfg . g_error_resilient = argc > 7 ? strtol ( argv [ 7 ] , NULL , 0 ) : 0 ;\n writer = vpx_video_writer_open ( outfile_arg , kContainerIVF , & info ) ;\n if ( ! writer ) die ( \"Failed to open %s for writing.\" , outfile_arg ) ;\n if ( ! ( infile = fopen ( infile_arg , \"rb\" ) ) ) die ( \"Failed to open %s for reading.\" , infile_arg ) ;\n if ( vpx_codec_enc_init ( & codec , encoder -> codec_interface ( ) , & cfg , 0 ) ) die_codec ( & codec , \"Failed to initialize encoder\" ) ;\n while ( vpx_img_read ( & raw , infile ) ) {\n int flags = 0 ;\n if ( keyframe_interval > 0 && frame_count % keyframe_interval == 0 ) flags |= VPX_EFLAG_FORCE_KF ;\n encode_frame ( & codec , & raw , frame_count ++ , flags , writer ) ;\n }\n while ( encode_frame ( & codec , NULL , - 1 , 0 , writer ) ) {\n }\n ;\n printf ( \"\\n\" ) ;\n fclose ( infile ) ;\n printf ( \"Processed %d frames.\\n\" , frame_count ) ;\n vpx_img_free ( & raw ) ;\n if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed to destroy codec.\" ) ;\n vpx_video_writer_close ( writer ) ;\n return EXIT_SUCCESS ;\n }", "idx": 98}
{"hash": 6250095321513210169, "project": "debian", "size": 4, "label": 0, "functionSource": "void rfbReleaseClientIterator ( rfbClientIteratorPtr iterator ) {\n IF_PTHREADS ( if ( iterator -> next ) rfbDecrClientRef ( iterator -> next ) ) ;\n free ( iterator ) ;\n }", "idx": 99}
{"hash": -2908211205972632000, "project": "debian", "size": 11, "label": 0, "functionSource": "void mainwindows_recreate ( void ) {\n GSList * tmp ;\n for ( tmp = mainwindows ;\n tmp != NULL ;\n tmp = tmp -> next ) {\n MAIN_WINDOW_REC * rec = tmp -> data ;\n rec -> screen_win = mainwindow_create_screen ( rec ) ;\n rec -> dirty = TRUE ;\n textbuffer_view_set_window ( WINDOW_GUI ( rec -> active ) -> view , rec -> screen_win ) ;\n }\n }", "idx": 100}
{"hash": 229962612204196999, "project": "debian", "size": 27, "label": 0, "functionSource": "static void add_remote_info_ref ( struct remote_ls_ctx * ls ) {\n struct strbuf * buf = ( struct strbuf * ) ls -> userData ;\n struct object * o ;\n struct ref * ref ;\n ref = alloc_ref ( ls -> dentry_name ) ;\n if ( http_fetch_ref ( repo -> url , ref ) != 0 ) {\n fprintf ( stderr , \"Unable to fetch ref %s from %s\\n\" , ls -> dentry_name , repo -> url ) ;\n aborted = 1 ;\n free ( ref ) ;\n return ;\n }\n o = parse_object ( ref -> old_oid . hash ) ;\n if ( ! o ) {\n fprintf ( stderr , \"Unable to parse object %s for remote ref %s\\n\" , oid_to_hex ( & ref -> old_oid ) , ls -> dentry_name ) ;\n aborted = 1 ;\n free ( ref ) ;\n return ;\n }\n strbuf_addf ( buf , \"%s\\t%s\\n\" , oid_to_hex ( & ref -> old_oid ) , ls -> dentry_name ) ;\n if ( o -> type == OBJ_TAG ) {\n o = deref_tag ( o , ls -> dentry_name , 0 ) ;\n if ( o ) strbuf_addf ( buf , \"%s\\t%s^{\n}\n\\n\" , oid_to_hex ( & o -> oid ) , ls -> dentry_name ) ;\n }\n free ( ref ) ;\n }", "idx": 101}
{"hash": 4489017523191997023, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h225_Content ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_Content , Content_choice , NULL ) ;\n return offset ;\n }", "idx": 102}
{"hash": -2908211205972632000, "project": "debian", "size": 6, "label": 0, "functionSource": "static void cmd_window_dup ( void ) {\n MAIN_WINDOW_REC * rec ;\n rec = mainwindows_find_upper ( active_mainwin ) ;\n if ( rec == NULL ) rec = mainwindows_find_upper ( NULL ) ;\n if ( rec != NULL ) window_set_active ( rec -> active ) ;\n }", "idx": 103}
{"hash": 1182028467273264883, "project": "debian", "size": 86, "label": 0, "functionSource": "void var_set_query_get_value ( struct st_command * command , VAR * var ) {\n long row_no ;\n int col_no = - 1 ;\n MYSQL_RES * res ;\n MYSQL * mysql = cur_con -> mysql ;\n static DYNAMIC_STRING ds_query ;\n static DYNAMIC_STRING ds_col ;\n static DYNAMIC_STRING ds_row ;\n const struct command_arg query_get_value_args [ ] = {\n {\n \"query\" , ARG_STRING , TRUE , & ds_query , \"Query to run\" }\n , {\n \"column name\" , ARG_STRING , TRUE , & ds_col , \"Name of column\" }\n , {\n \"row number\" , ARG_STRING , TRUE , & ds_row , \"Number for row\" }\n }\n ;\n DBUG_ENTER ( \"var_set_query_get_value\" ) ;\n LINT_INIT ( res ) ;\n if ( ! mysql ) {\n handle_no_active_connection ( command , cur_con , & ds_res ) ;\n DBUG_VOID_RETURN ;\n }\n strip_parentheses ( command ) ;\n DBUG_PRINT ( \"info\" , ( \"query: %s\" , command -> query ) ) ;\n check_command_args ( command , command -> first_argument , query_get_value_args , sizeof ( query_get_value_args ) / sizeof ( struct command_arg ) , ',' ) ;\n DBUG_PRINT ( \"info\" , ( \"query: %s\" , ds_query . str ) ) ;\n DBUG_PRINT ( \"info\" , ( \"col: %s\" , ds_col . str ) ) ;\n if ( ! str2int ( ds_row . str , 10 , ( long ) 0 , ( long ) INT_MAX , & row_no ) ) die ( \"Invalid row number: '%s'\" , ds_row . str ) ;\n DBUG_PRINT ( \"info\" , ( \"row: %s, row_no: %ld\" , ds_row . str , row_no ) ) ;\n dynstr_free ( & ds_row ) ;\n if ( strip_surrounding ( ds_query . str , '\"' , '\"' ) ) die ( \"Mismatched \\\"'s around query '%s'\" , ds_query . str ) ;\n if ( mysql_real_query ( mysql , ds_query . str , ds_query . length ) ) {\n handle_error ( curr_command , mysql_errno ( mysql ) , mysql_error ( mysql ) , mysql_sqlstate ( mysql ) , & ds_res ) ;\n dynstr_free ( & ds_query ) ;\n dynstr_free ( & ds_col ) ;\n eval_expr ( var , \"\" , 0 ) ;\n DBUG_VOID_RETURN ;\n }\n if ( ! ( res = mysql_store_result ( mysql ) ) ) {\n report_or_die ( \"Query '%s' didn't return a result set\" , ds_query . str ) ;\n dynstr_free ( & ds_query ) ;\n dynstr_free ( & ds_col ) ;\n eval_expr ( var , \"\" , 0 ) ;\n return ;\n }\n {\n uint i ;\n uint num_fields = mysql_num_fields ( res ) ;\n MYSQL_FIELD * fields = mysql_fetch_fields ( res ) ;\n for ( i = 0 ;\n i < num_fields ;\n i ++ ) {\n if ( strcmp ( fields [ i ] . name , ds_col . str ) == 0 && strlen ( fields [ i ] . name ) == ds_col . length ) {\n col_no = i ;\n break ;\n }\n }\n if ( col_no == - 1 ) {\n mysql_free_result ( res ) ;\n report_or_die ( \"Could not find column '%s' in the result of '%s'\" , ds_col . str , ds_query . str ) ;\n dynstr_free ( & ds_query ) ;\n dynstr_free ( & ds_col ) ;\n return ;\n }\n DBUG_PRINT ( \"info\" , ( \"Found column %d with name '%s'\" , i , fields [ i ] . name ) ) ;\n }\n dynstr_free ( & ds_col ) ;\n {\n MYSQL_ROW row ;\n long rows = 0 ;\n const char * value = \"No such row\" ;\n while ( ( row = mysql_fetch_row ( res ) ) ) {\n if ( ++ rows == row_no ) {\n DBUG_PRINT ( \"info\" , ( \"At row %ld, column %d is '%s'\" , row_no , col_no , row [ col_no ] ) ) ;\n if ( row [ col_no ] ) value = row [ col_no ] ;\n else value = \"NULL\" ;\n break ;\n }\n }\n eval_expr ( var , value , 0 , false , false ) ;\n }\n dynstr_free ( & ds_query ) ;\n mysql_free_result ( res ) ;\n DBUG_VOID_RETURN ;\n }", "idx": 104}
{"hash": 5505129039893037501, "project": "chrome", "size": 11, "label": 0, "functionSource": "TEST_F ( SyncBookmarkDataTypeControllerTest , StartAssociationFailed ) {\n CreateBookmarkModel ( LOAD_MODEL ) ;\n SetStartExpectations ( ) ;\n EXPECT_CALL ( * profile_sync_factory_ , CreateBookmarkSyncComponents ( _ , _ ) ) ;\n EXPECT_CALL ( * model_associator_ , CryptoReadyIfNecessary ( ) ) . WillRepeatedly ( Return ( true ) ) ;\n EXPECT_CALL ( * model_associator_ , SyncModelHasUserCreatedNodes ( _ ) ) . WillRepeatedly ( DoAll ( SetArgumentPointee < 0 > ( true ) , Return ( true ) ) ) ;\n EXPECT_CALL ( * model_associator_ , AssociateModels ( _ , _ ) ) . WillRepeatedly ( Return ( syncer : : SyncError ( FROM_HERE , syncer : : SyncError : : DATATYPE_ERROR , \"error\" , syncer : : BOOKMARKS ) ) ) ;\n EXPECT_CALL ( start_callback_ , Run ( DataTypeController : : ASSOCIATION_FAILED , _ , _ ) ) ;\n Start ( ) ;\n EXPECT_EQ ( DataTypeController : : DISABLED , bookmark_dtc_ -> state ( ) ) ;\n }", "idx": 105}
{"hash": -4527380754569407959, "project": "chrome", "size": 10, "label": 1, "functionSource": "GType hb_gobject_ ## name ## _get_type ( void ) \\ {\n static gsize type_id = 0 ;\n if ( g_once_init_enter ( & type_id ) ) {\n GType id = g_boxed_type_register_static ( g_intern_static_string ( \"hb_\" # name \"_t\" ) , ( GBoxedCopyFunc ) copy_func , ( GBoxedFreeFunc ) free_func ) ;\n g_once_init_leave ( & type_id , id ) ;\n }\n return type_id ;\n \\ }\n # define HB_DEFINE_OBJECT_TYPE ( name ) HB_DEFINE_BOXED_TYPE ( name , hb_ ## name ## _reference , hb_ ## name ## _destroy ) ;\n HB_DEFINE_OBJECT_TYPE ( buffer ) HB_DEFINE_OBJECT_TYPE ( blob ) HB_DEFINE_OBJECT_TYPE ( face ) HB_DEFINE_OBJECT_TYPE ( font ) HB_DEFINE_OBJECT_TYPE ( font_funcs ) HB_DEFINE_OBJECT_TYPE ( set )", "idx": 106}
{"hash": -8933711118846965366, "project": "debian", "size": 8, "label": 0, "functionSource": "static inline uint8_t cirrus_src ( CirrusVGAState * s , uint32_t srcaddr ) {\n if ( s -> cirrus_srccounter ) {\n return s -> cirrus_bltbuf [ srcaddr & ( CIRRUS_BLTBUFSIZE - 1 ) ] ;\n }\n else {\n return s -> vga . vram_ptr [ srcaddr & s -> cirrus_addr_mask ] ;\n }\n }", "idx": 107}
{"hash": -2386031673786599357, "project": "debian", "size": 14, "label": 0, "functionSource": "static gpgme_error_t gpgsm_passwd ( void * engine , gpgme_key_t key , unsigned int flags ) {\n engine_gpgsm_t gpgsm = engine ;\n gpgme_error_t err ;\n char * line ;\n if ( ! key || ! key -> subkeys || ! key -> subkeys -> fpr ) return gpg_error ( GPG_ERR_INV_CERT_OBJ ) ;\n if ( asprintf ( & line , \"PASSWD -- %s\" , key -> subkeys -> fpr ) < 0 ) return gpg_error_from_syserror ( ) ;\n gpgsm_clear_fd ( gpgsm , OUTPUT_FD ) ;\n gpgsm_clear_fd ( gpgsm , INPUT_FD ) ;\n gpgsm_clear_fd ( gpgsm , MESSAGE_FD ) ;\n gpgsm -> inline_data = NULL ;\n err = start ( gpgsm , line ) ;\n free ( line ) ;\n return err ;\n }", "idx": 108}
{"hash": -2607754285145856562, "project": "debian", "size": 54, "label": 0, "functionSource": "static void zisofs_detect_magic ( struct archive_write * a , const void * buff , size_t s ) {\n struct iso9660 * iso9660 = a -> format_data ;\n struct isofile * file = iso9660 -> cur_file ;\n const unsigned char * p , * endp ;\n const unsigned char * magic_buff ;\n uint32_t uncompressed_size ;\n unsigned char header_size ;\n unsigned char log2_bs ;\n size_t _ceil , doff ;\n uint32_t bst , bed ;\n int magic_max ;\n int64_t entry_size ;\n entry_size = archive_entry_size ( file -> entry ) ;\n if ( ( int64_t ) sizeof ( iso9660 -> zisofs . magic_buffer ) > entry_size ) magic_max = ( int ) entry_size ;\n else magic_max = sizeof ( iso9660 -> zisofs . magic_buffer ) ;\n if ( iso9660 -> zisofs . magic_cnt == 0 && s >= ( size_t ) magic_max ) magic_buff = buff ;\n else {\n if ( iso9660 -> zisofs . magic_cnt < magic_max ) {\n size_t l ;\n l = sizeof ( iso9660 -> zisofs . magic_buffer ) - iso9660 -> zisofs . magic_cnt ;\n if ( l > s ) l = s ;\n memcpy ( iso9660 -> zisofs . magic_buffer + iso9660 -> zisofs . magic_cnt , buff , l ) ;\n iso9660 -> zisofs . magic_cnt += ( int ) l ;\n if ( iso9660 -> zisofs . magic_cnt < magic_max ) return ;\n }\n magic_buff = iso9660 -> zisofs . magic_buffer ;\n }\n iso9660 -> zisofs . detect_magic = 0 ;\n p = magic_buff ;\n if ( memcmp ( p , zisofs_magic , sizeof ( zisofs_magic ) ) != 0 ) return ;\n p += sizeof ( zisofs_magic ) ;\n uncompressed_size = archive_le32dec ( p ) ;\n header_size = p [ 4 ] ;\n log2_bs = p [ 5 ] ;\n if ( uncompressed_size < 24 || header_size != 4 || log2_bs > 30 || log2_bs < 7 ) return ;\n _ceil = ( uncompressed_size + ( ARCHIVE_LITERAL_LL ( 1 ) << log2_bs ) - 1 ) >> log2_bs ;\n doff = ( _ceil + 1 ) * 4 + 16 ;\n if ( entry_size < ( int64_t ) doff ) return ;\n p = magic_buff + 16 ;\n endp = magic_buff + magic_max ;\n while ( _ceil && p + 8 <= endp ) {\n bst = archive_le32dec ( p ) ;\n if ( bst != doff ) return ;\n p += 4 ;\n bed = archive_le32dec ( p ) ;\n if ( bed < bst || bed > entry_size ) return ;\n doff += bed - bst ;\n _ceil -- ;\n }\n file -> zisofs . uncompressed_size = uncompressed_size ;\n file -> zisofs . header_size = header_size ;\n file -> zisofs . log2_bs = log2_bs ;\n iso9660 -> zisofs . making = 0 ;\n }", "idx": 109}
{"hash": 3599206110384554647, "project": "debian", "size": 69, "label": 0, "functionSource": "static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _new ( sk_ ## t1 ## _compfunc compare ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_new ( ( OPENSSL_sk_compfunc ) compare ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _new_null ( void ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_new_null ( ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _new_reserve ( sk_ ## t1 ## _compfunc compare , int n ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_new_reserve ( ( OPENSSL_sk_compfunc ) compare , n ) ;\n }\n static ossl_inline int sk_ ## t1 ## _reserve ( STACK_OF ( t1 ) * sk , int n ) {\n return OPENSSL_sk_reserve ( ( OPENSSL_STACK * ) sk , n ) ;\n }\n static ossl_inline void sk_ ## t1 ## _free ( STACK_OF ( t1 ) * sk ) {\n OPENSSL_sk_free ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline void sk_ ## t1 ## _zero ( STACK_OF ( t1 ) * sk ) {\n OPENSSL_sk_zero ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _delete ( STACK_OF ( t1 ) * sk , int i ) {\n return ( t2 * ) OPENSSL_sk_delete ( ( OPENSSL_STACK * ) sk , i ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _delete_ptr ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return ( t2 * ) OPENSSL_sk_delete_ptr ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _push ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_push ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _unshift ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_unshift ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _pop ( STACK_OF ( t1 ) * sk ) {\n return ( t2 * ) OPENSSL_sk_pop ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _shift ( STACK_OF ( t1 ) * sk ) {\n return ( t2 * ) OPENSSL_sk_shift ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline void sk_ ## t1 ## _pop_free ( STACK_OF ( t1 ) * sk , sk_ ## t1 ## _freefunc freefunc ) {\n OPENSSL_sk_pop_free ( ( OPENSSL_STACK * ) sk , ( OPENSSL_sk_freefunc ) freefunc ) ;\n }\n static ossl_inline int sk_ ## t1 ## _insert ( STACK_OF ( t1 ) * sk , t2 * ptr , int idx ) {\n return OPENSSL_sk_insert ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr , idx ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _set ( STACK_OF ( t1 ) * sk , int idx , t2 * ptr ) {\n return ( t2 * ) OPENSSL_sk_set ( ( OPENSSL_STACK * ) sk , idx , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _find ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_find ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _find_ex ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_find_ex ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline void sk_ ## t1 ## _sort ( STACK_OF ( t1 ) * sk ) {\n OPENSSL_sk_sort ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline int sk_ ## t1 ## _is_sorted ( const STACK_OF ( t1 ) * sk ) {\n return OPENSSL_sk_is_sorted ( ( const OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _dup ( const STACK_OF ( t1 ) * sk ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_dup ( ( const OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _deep_copy ( const STACK_OF ( t1 ) * sk , sk_ ## t1 ## _copyfunc copyfunc , sk_ ## t1 ## _freefunc freefunc ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_deep_copy ( ( const OPENSSL_STACK * ) sk , ( OPENSSL_sk_copyfunc ) copyfunc , ( OPENSSL_sk_freefunc ) freefunc ) ;\n }\n static ossl_inline sk_ ## t1 ## _compfunc sk_ ## t1 ## _set_cmp_func ( STACK_OF ( t1 ) * sk , sk_ ## t1 ## _compfunc compare ) {\n return ( sk_ ## t1 ## _compfunc ) OPENSSL_sk_set_cmp_func ( ( OPENSSL_STACK * ) sk , ( OPENSSL_sk_compfunc ) compare ) ;\n }\n # define DEFINE_SPECIAL_STACK_OF ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , t2 , t2 ) # define DEFINE_STACK_OF ( t ) SKM_DEFINE_STACK_OF ( t , t , t ) # define DEFINE_SPECIAL_STACK_OF_CONST ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , const t2 , t2 ) # define DEFINE_STACK_OF_CONST ( t ) SKM_DEFINE_STACK_OF ( t , const t , t ) typedef char * OPENSSL_STRING ;\n typedef const char * OPENSSL_CSTRING ;\n DEFINE_SPECIAL_STACK_OF ( OPENSSL_STRING , char )", "idx": 110}
{"hash": -5268859819325807498, "project": "debian", "size": 14, "label": 0, "functionSource": "static void query_filesystem_info_callback ( GObject * source_object , GAsyncResult * res , gpointer user_data ) {\n GFileInfo * info ;\n FilesystemInfoState * state ;\n state = user_data ;\n if ( state -> directory == NULL ) {\n filesystem_info_state_free ( state ) ;\n return ;\n }\n info = g_file_query_filesystem_info_finish ( G_FILE ( source_object ) , res , NULL ) ;\n got_filesystem_info ( state , info ) ;\n if ( info != NULL ) {\n g_object_unref ( info ) ;\n }\n }", "idx": 111}
{"hash": 1760449185745615462, "project": "debian", "size": 3, "label": 0, "functionSource": "TSReturnCode TSUrlUserSet ( TSMBuffer bufp , TSMLoc obj , const char * value , int length ) {\n return URLPartSet ( bufp , obj , value , length , & URL : : user_set ) ;\n }", "idx": 112}
{"hash": -5706788925640467782, "project": "chrome", "size": 21, "label": 0, "functionSource": "static void set_mode_info_seg_skip ( MACROBLOCK * x , TX_MODE tx_mode , int * rate , int64_t * dist , BLOCK_SIZE bsize ) {\n MACROBLOCKD * const xd = & x -> e_mbd ;\n MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] . src_mi -> mbmi ;\n INTERP_FILTER filter_ref ;\n if ( xd -> up_available ) filter_ref = xd -> mi [ - xd -> mi_stride ] . src_mi -> mbmi . interp_filter ;\n else if ( xd -> left_available ) filter_ref = xd -> mi [ - 1 ] . src_mi -> mbmi . interp_filter ;\n else filter_ref = EIGHTTAP ;\n mbmi -> sb_type = bsize ;\n mbmi -> mode = ZEROMV ;\n mbmi -> tx_size = MIN ( max_txsize_lookup [ bsize ] , tx_mode_to_biggest_tx_size [ tx_mode ] ) ;\n mbmi -> skip = 1 ;\n mbmi -> uv_mode = DC_PRED ;\n mbmi -> ref_frame [ 0 ] = LAST_FRAME ;\n mbmi -> ref_frame [ 1 ] = NONE ;\n mbmi -> mv [ 0 ] . as_int = 0 ;\n mbmi -> interp_filter = filter_ref ;\n xd -> mi [ 0 ] . src_mi -> bmi [ 0 ] . as_mv [ 0 ] . as_int = 0 ;\n x -> skip = 1 ;\n * rate = 0 ;\n * dist = 0 ;\n }", "idx": 113}
{"hash": -1710554222303887484, "project": "chrome", "size": 28, "label": 0, "functionSource": "static void idct4_sse2 ( __m128i * in ) {\n const __m128i k__cospi_p16_p16 = pair_set_epi16 ( cospi_16_64 , cospi_16_64 ) ;\n const __m128i k__cospi_p16_m16 = pair_set_epi16 ( cospi_16_64 , - cospi_16_64 ) ;\n const __m128i k__cospi_p24_m08 = pair_set_epi16 ( cospi_24_64 , - cospi_8_64 ) ;\n const __m128i k__cospi_p08_p24 = pair_set_epi16 ( cospi_8_64 , cospi_24_64 ) ;\n const __m128i k__DCT_CONST_ROUNDING = _mm_set1_epi32 ( DCT_CONST_ROUNDING ) ;\n __m128i u [ 8 ] , v [ 8 ] ;\n transpose_4x4 ( in ) ;\n u [ 0 ] = _mm_unpacklo_epi16 ( in [ 0 ] , in [ 1 ] ) ;\n u [ 1 ] = _mm_unpackhi_epi16 ( in [ 0 ] , in [ 1 ] ) ;\n v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p16_p16 ) ;\n v [ 1 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p16_m16 ) ;\n v [ 2 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p24_m08 ) ;\n v [ 3 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p08_p24 ) ;\n u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , k__DCT_CONST_ROUNDING ) ;\n u [ 1 ] = _mm_add_epi32 ( v [ 1 ] , k__DCT_CONST_ROUNDING ) ;\n u [ 2 ] = _mm_add_epi32 ( v [ 2 ] , k__DCT_CONST_ROUNDING ) ;\n u [ 3 ] = _mm_add_epi32 ( v [ 3 ] , k__DCT_CONST_ROUNDING ) ;\n v [ 0 ] = _mm_srai_epi32 ( u [ 0 ] , DCT_CONST_BITS ) ;\n v [ 1 ] = _mm_srai_epi32 ( u [ 1 ] , DCT_CONST_BITS ) ;\n v [ 2 ] = _mm_srai_epi32 ( u [ 2 ] , DCT_CONST_BITS ) ;\n v [ 3 ] = _mm_srai_epi32 ( u [ 3 ] , DCT_CONST_BITS ) ;\n u [ 0 ] = _mm_packs_epi32 ( v [ 0 ] , v [ 1 ] ) ;\n u [ 1 ] = _mm_packs_epi32 ( v [ 3 ] , v [ 2 ] ) ;\n in [ 0 ] = _mm_add_epi16 ( u [ 0 ] , u [ 1 ] ) ;\n in [ 1 ] = _mm_sub_epi16 ( u [ 0 ] , u [ 1 ] ) ;\n in [ 1 ] = _mm_shuffle_epi32 ( in [ 1 ] , 0x4E ) ;\n }", "idx": 114}
{"hash": 5917118798851365454, "project": "debian", "size": 6, "label": 0, "functionSource": "static void dissect_zcl_appl_evtalt_event_notif ( tvbuff_t * tvb , proto_tree * tree , guint * offset ) {\n proto_tree_add_item ( tree , hf_zbee_zcl_appl_evtalt_event_hdr , tvb , * offset , 1 , ENC_NA ) ;\n * offset += 1 ;\n proto_tree_add_item ( tree , hf_zbee_zcl_appl_evtalt_event_id , tvb , * offset , 1 , ENC_NA ) ;\n * offset += 1 ;\n }", "idx": 115}
{"hash": 2713698759296604855, "project": "debian", "size": 12, "label": 0, "functionSource": "static void free_duplicate_context ( MpegEncContext * s ) {\n if ( s == NULL ) return ;\n av_freep ( & s -> edge_emu_buffer ) ;\n av_freep ( & s -> me . scratchpad ) ;\n s -> me . temp = s -> rd_scratchpad = s -> b_scratchpad = s -> obmc_scratchpad = NULL ;\n av_freep ( & s -> dct_error_sum ) ;\n av_freep ( & s -> me . map ) ;\n av_freep ( & s -> me . score_map ) ;\n av_freep ( & s -> blocks ) ;\n av_freep ( & s -> ac_val_base ) ;\n s -> block = NULL ;\n }", "idx": 116}
{"hash": -7076754245473579218, "project": "chrome", "size": 22, "label": 0, "functionSource": "void evhttp_free ( struct evhttp * http ) {\n struct evhttp_cb * http_cb ;\n struct evhttp_connection * evcon ;\n struct evhttp_bound_socket * bound ;\n int fd ;\n while ( ( bound = TAILQ_FIRST ( & http -> sockets ) ) != NULL ) {\n TAILQ_REMOVE ( & http -> sockets , bound , next ) ;\n fd = bound -> bind_ev . ev_fd ;\n event_del ( & bound -> bind_ev ) ;\n EVUTIL_CLOSESOCKET ( fd ) ;\n free ( bound ) ;\n }\n while ( ( evcon = TAILQ_FIRST ( & http -> connections ) ) != NULL ) {\n evhttp_connection_free ( evcon ) ;\n }\n while ( ( http_cb = TAILQ_FIRST ( & http -> callbacks ) ) != NULL ) {\n TAILQ_REMOVE ( & http -> callbacks , http_cb , next ) ;\n free ( http_cb -> what ) ;\n free ( http_cb ) ;\n }\n free ( http ) ;\n }", "idx": 117}
{"hash": 6353572510321903594, "project": "chrome", "size": 404, "label": 0, "functionSource": "void vp8_sixtap_predict8x8_neon ( unsigned char * src_ptr , int src_pixels_per_line , int xoffset , int yoffset , unsigned char * dst_ptr , int dst_pitch ) {\n unsigned char * src , * tmpp ;\n unsigned char tmp [ 64 ] ;\n int i ;\n uint8x8_t d0u8 , d1u8 , d2u8 , d3u8 , d4u8 , d5u8 , d6u8 , d7u8 , d8u8 , d9u8 ;\n uint8x8_t d18u8 , d19u8 , d20u8 , d21u8 , d22u8 , d23u8 , d24u8 , d25u8 ;\n uint8x8_t d26u8 , d27u8 , d28u8 , d29u8 , d30u8 , d31u8 ;\n int8x8_t dtmps8 , d0s8 , d1s8 , d2s8 , d3s8 , d4s8 , d5s8 ;\n uint16x8_t q3u16 , q4u16 , q5u16 , q6u16 , q7u16 ;\n uint16x8_t q8u16 , q9u16 , q10u16 , q11u16 , q12u16 ;\n int16x8_t q3s16 , q4s16 , q5s16 , q6s16 , q7s16 ;\n int16x8_t q8s16 , q9s16 , q10s16 , q11s16 , q12s16 ;\n uint8x16_t q3u8 , q4u8 , q5u8 , q6u8 , q7u8 , q9u8 , q10u8 , q11u8 , q12u8 ;\n if ( xoffset == 0 ) {\n dtmps8 = vld1_s8 ( vp8_sub_pel_filters [ yoffset ] ) ;\n d0s8 = vdup_lane_s8 ( dtmps8 , 0 ) ;\n d1s8 = vdup_lane_s8 ( dtmps8 , 1 ) ;\n d2s8 = vdup_lane_s8 ( dtmps8 , 2 ) ;\n d3s8 = vdup_lane_s8 ( dtmps8 , 3 ) ;\n d4s8 = vdup_lane_s8 ( dtmps8 , 4 ) ;\n d5s8 = vdup_lane_s8 ( dtmps8 , 5 ) ;\n d0u8 = vreinterpret_u8_s8 ( vabs_s8 ( d0s8 ) ) ;\n d1u8 = vreinterpret_u8_s8 ( vabs_s8 ( d1s8 ) ) ;\n d2u8 = vreinterpret_u8_s8 ( vabs_s8 ( d2s8 ) ) ;\n d3u8 = vreinterpret_u8_s8 ( vabs_s8 ( d3s8 ) ) ;\n d4u8 = vreinterpret_u8_s8 ( vabs_s8 ( d4s8 ) ) ;\n d5u8 = vreinterpret_u8_s8 ( vabs_s8 ( d5s8 ) ) ;\n src = src_ptr - src_pixels_per_line * 2 ;\n d18u8 = vld1_u8 ( src ) ;\n src += src_pixels_per_line ;\n d19u8 = vld1_u8 ( src ) ;\n src += src_pixels_per_line ;\n d20u8 = vld1_u8 ( src ) ;\n src += src_pixels_per_line ;\n d21u8 = vld1_u8 ( src ) ;\n src += src_pixels_per_line ;\n d22u8 = vld1_u8 ( src ) ;\n src += src_pixels_per_line ;\n d23u8 = vld1_u8 ( src ) ;\n src += src_pixels_per_line ;\n d24u8 = vld1_u8 ( src ) ;\n src += src_pixels_per_line ;\n d25u8 = vld1_u8 ( src ) ;\n src += src_pixels_per_line ;\n d26u8 = vld1_u8 ( src ) ;\n src += src_pixels_per_line ;\n d27u8 = vld1_u8 ( src ) ;\n src += src_pixels_per_line ;\n d28u8 = vld1_u8 ( src ) ;\n src += src_pixels_per_line ;\n d29u8 = vld1_u8 ( src ) ;\n src += src_pixels_per_line ;\n d30u8 = vld1_u8 ( src ) ;\n for ( i = 2 ;\n i > 0 ;\n i -- ) {\n q3u16 = vmull_u8 ( d18u8 , d0u8 ) ;\n q4u16 = vmull_u8 ( d19u8 , d0u8 ) ;\n q5u16 = vmull_u8 ( d20u8 , d0u8 ) ;\n q6u16 = vmull_u8 ( d21u8 , d0u8 ) ;\n q3u16 = vmlsl_u8 ( q3u16 , d19u8 , d1u8 ) ;\n q4u16 = vmlsl_u8 ( q4u16 , d20u8 , d1u8 ) ;\n q5u16 = vmlsl_u8 ( q5u16 , d21u8 , d1u8 ) ;\n q6u16 = vmlsl_u8 ( q6u16 , d22u8 , d1u8 ) ;\n q3u16 = vmlsl_u8 ( q3u16 , d22u8 , d4u8 ) ;\n q4u16 = vmlsl_u8 ( q4u16 , d23u8 , d4u8 ) ;\n q5u16 = vmlsl_u8 ( q5u16 , d24u8 , d4u8 ) ;\n q6u16 = vmlsl_u8 ( q6u16 , d25u8 , d4u8 ) ;\n q3u16 = vmlal_u8 ( q3u16 , d20u8 , d2u8 ) ;\n q4u16 = vmlal_u8 ( q4u16 , d21u8 , d2u8 ) ;\n q5u16 = vmlal_u8 ( q5u16 , d22u8 , d2u8 ) ;\n q6u16 = vmlal_u8 ( q6u16 , d23u8 , d2u8 ) ;\n q3u16 = vmlal_u8 ( q3u16 , d23u8 , d5u8 ) ;\n q4u16 = vmlal_u8 ( q4u16 , d24u8 , d5u8 ) ;\n q5u16 = vmlal_u8 ( q5u16 , d25u8 , d5u8 ) ;\n q6u16 = vmlal_u8 ( q6u16 , d26u8 , d5u8 ) ;\n q7u16 = vmull_u8 ( d21u8 , d3u8 ) ;\n q8u16 = vmull_u8 ( d22u8 , d3u8 ) ;\n q9u16 = vmull_u8 ( d23u8 , d3u8 ) ;\n q10u16 = vmull_u8 ( d24u8 , d3u8 ) ;\n q3s16 = vreinterpretq_s16_u16 ( q3u16 ) ;\n q4s16 = vreinterpretq_s16_u16 ( q4u16 ) ;\n q5s16 = vreinterpretq_s16_u16 ( q5u16 ) ;\n q6s16 = vreinterpretq_s16_u16 ( q6u16 ) ;\n q7s16 = vreinterpretq_s16_u16 ( q7u16 ) ;\n q8s16 = vreinterpretq_s16_u16 ( q8u16 ) ;\n q9s16 = vreinterpretq_s16_u16 ( q9u16 ) ;\n q10s16 = vreinterpretq_s16_u16 ( q10u16 ) ;\n q7s16 = vqaddq_s16 ( q7s16 , q3s16 ) ;\n q8s16 = vqaddq_s16 ( q8s16 , q4s16 ) ;\n q9s16 = vqaddq_s16 ( q9s16 , q5s16 ) ;\n q10s16 = vqaddq_s16 ( q10s16 , q6s16 ) ;\n d6u8 = vqrshrun_n_s16 ( q7s16 , 7 ) ;\n d7u8 = vqrshrun_n_s16 ( q8s16 , 7 ) ;\n d8u8 = vqrshrun_n_s16 ( q9s16 , 7 ) ;\n d9u8 = vqrshrun_n_s16 ( q10s16 , 7 ) ;\n d18u8 = d22u8 ;\n d19u8 = d23u8 ;\n d20u8 = d24u8 ;\n d21u8 = d25u8 ;\n d22u8 = d26u8 ;\n d23u8 = d27u8 ;\n d24u8 = d28u8 ;\n d25u8 = d29u8 ;\n d26u8 = d30u8 ;\n vst1_u8 ( dst_ptr , d6u8 ) ;\n dst_ptr += dst_pitch ;\n vst1_u8 ( dst_ptr , d7u8 ) ;\n dst_ptr += dst_pitch ;\n vst1_u8 ( dst_ptr , d8u8 ) ;\n dst_ptr += dst_pitch ;\n vst1_u8 ( dst_ptr , d9u8 ) ;\n dst_ptr += dst_pitch ;\n }\n return ;\n }\n dtmps8 = vld1_s8 ( vp8_sub_pel_filters [ xoffset ] ) ;\n d0s8 = vdup_lane_s8 ( dtmps8 , 0 ) ;\n d1s8 = vdup_lane_s8 ( dtmps8 , 1 ) ;\n d2s8 = vdup_lane_s8 ( dtmps8 , 2 ) ;\n d3s8 = vdup_lane_s8 ( dtmps8 , 3 ) ;\n d4s8 = vdup_lane_s8 ( dtmps8 , 4 ) ;\n d5s8 = vdup_lane_s8 ( dtmps8 , 5 ) ;\n d0u8 = vreinterpret_u8_s8 ( vabs_s8 ( d0s8 ) ) ;\n d1u8 = vreinterpret_u8_s8 ( vabs_s8 ( d1s8 ) ) ;\n d2u8 = vreinterpret_u8_s8 ( vabs_s8 ( d2s8 ) ) ;\n d3u8 = vreinterpret_u8_s8 ( vabs_s8 ( d3s8 ) ) ;\n d4u8 = vreinterpret_u8_s8 ( vabs_s8 ( d4s8 ) ) ;\n d5u8 = vreinterpret_u8_s8 ( vabs_s8 ( d5s8 ) ) ;\n if ( yoffset == 0 ) src = src_ptr - 2 ;\n else src = src_ptr - 2 - ( src_pixels_per_line * 2 ) ;\n tmpp = tmp ;\n for ( i = 2 ;\n i > 0 ;\n i -- ) {\n q3u8 = vld1q_u8 ( src ) ;\n src += src_pixels_per_line ;\n q4u8 = vld1q_u8 ( src ) ;\n src += src_pixels_per_line ;\n q5u8 = vld1q_u8 ( src ) ;\n src += src_pixels_per_line ;\n q6u8 = vld1q_u8 ( src ) ;\n src += src_pixels_per_line ;\n __builtin_prefetch ( src ) ;\n __builtin_prefetch ( src + src_pixels_per_line ) ;\n __builtin_prefetch ( src + src_pixels_per_line * 2 ) ;\n q7u16 = vmull_u8 ( vget_low_u8 ( q3u8 ) , d0u8 ) ;\n q8u16 = vmull_u8 ( vget_low_u8 ( q4u8 ) , d0u8 ) ;\n q9u16 = vmull_u8 ( vget_low_u8 ( q5u8 ) , d0u8 ) ;\n q10u16 = vmull_u8 ( vget_low_u8 ( q6u8 ) , d0u8 ) ;\n d28u8 = vext_u8 ( vget_low_u8 ( q3u8 ) , vget_high_u8 ( q3u8 ) , 1 ) ;\n d29u8 = vext_u8 ( vget_low_u8 ( q4u8 ) , vget_high_u8 ( q4u8 ) , 1 ) ;\n d30u8 = vext_u8 ( vget_low_u8 ( q5u8 ) , vget_high_u8 ( q5u8 ) , 1 ) ;\n d31u8 = vext_u8 ( vget_low_u8 ( q6u8 ) , vget_high_u8 ( q6u8 ) , 1 ) ;\n q7u16 = vmlsl_u8 ( q7u16 , d28u8 , d1u8 ) ;\n q8u16 = vmlsl_u8 ( q8u16 , d29u8 , d1u8 ) ;\n q9u16 = vmlsl_u8 ( q9u16 , d30u8 , d1u8 ) ;\n q10u16 = vmlsl_u8 ( q10u16 , d31u8 , d1u8 ) ;\n d28u8 = vext_u8 ( vget_low_u8 ( q3u8 ) , vget_high_u8 ( q3u8 ) , 4 ) ;\n d29u8 = vext_u8 ( vget_low_u8 ( q4u8 ) , vget_high_u8 ( q4u8 ) , 4 ) ;\n d30u8 = vext_u8 ( vget_low_u8 ( q5u8 ) , vget_high_u8 ( q5u8 ) , 4 ) ;\n d31u8 = vext_u8 ( vget_low_u8 ( q6u8 ) , vget_high_u8 ( q6u8 ) , 4 ) ;\n q7u16 = vmlsl_u8 ( q7u16 , d28u8 , d4u8 ) ;\n q8u16 = vmlsl_u8 ( q8u16 , d29u8 , d4u8 ) ;\n q9u16 = vmlsl_u8 ( q9u16 , d30u8 , d4u8 ) ;\n q10u16 = vmlsl_u8 ( q10u16 , d31u8 , d4u8 ) ;\n d28u8 = vext_u8 ( vget_low_u8 ( q3u8 ) , vget_high_u8 ( q3u8 ) , 2 ) ;\n d29u8 = vext_u8 ( vget_low_u8 ( q4u8 ) , vget_high_u8 ( q4u8 ) , 2 ) ;\n d30u8 = vext_u8 ( vget_low_u8 ( q5u8 ) , vget_high_u8 ( q5u8 ) , 2 ) ;\n d31u8 = vext_u8 ( vget_low_u8 ( q6u8 ) , vget_high_u8 ( q6u8 ) , 2 ) ;\n q7u16 = vmlal_u8 ( q7u16 , d28u8 , d2u8 ) ;\n q8u16 = vmlal_u8 ( q8u16 , d29u8 , d2u8 ) ;\n q9u16 = vmlal_u8 ( q9u16 , d30u8 , d2u8 ) ;\n q10u16 = vmlal_u8 ( q10u16 , d31u8 , d2u8 ) ;\n d28u8 = vext_u8 ( vget_low_u8 ( q3u8 ) , vget_high_u8 ( q3u8 ) , 5 ) ;\n d29u8 = vext_u8 ( vget_low_u8 ( q4u8 ) , vget_high_u8 ( q4u8 ) , 5 ) ;\n d30u8 = vext_u8 ( vget_low_u8 ( q5u8 ) , vget_high_u8 ( q5u8 ) , 5 ) ;\n d31u8 = vext_u8 ( vget_low_u8 ( q6u8 ) , vget_high_u8 ( q6u8 ) , 5 ) ;\n q7u16 = vmlal_u8 ( q7u16 , d28u8 , d5u8 ) ;\n q8u16 = vmlal_u8 ( q8u16 , d29u8 , d5u8 ) ;\n q9u16 = vmlal_u8 ( q9u16 , d30u8 , d5u8 ) ;\n q10u16 = vmlal_u8 ( q10u16 , d31u8 , d5u8 ) ;\n d28u8 = vext_u8 ( vget_low_u8 ( q3u8 ) , vget_high_u8 ( q3u8 ) , 3 ) ;\n d29u8 = vext_u8 ( vget_low_u8 ( q4u8 ) , vget_high_u8 ( q4u8 ) , 3 ) ;\n d30u8 = vext_u8 ( vget_low_u8 ( q5u8 ) , vget_high_u8 ( q5u8 ) , 3 ) ;\n d31u8 = vext_u8 ( vget_low_u8 ( q6u8 ) , vget_high_u8 ( q6u8 ) , 3 ) ;\n q3u16 = vmull_u8 ( d28u8 , d3u8 ) ;\n q4u16 = vmull_u8 ( d29u8 , d3u8 ) ;\n q5u16 = vmull_u8 ( d30u8 , d3u8 ) ;\n q6u16 = vmull_u8 ( d31u8 , d3u8 ) ;\n q3s16 = vreinterpretq_s16_u16 ( q3u16 ) ;\n q4s16 = vreinterpretq_s16_u16 ( q4u16 ) ;\n q5s16 = vreinterpretq_s16_u16 ( q5u16 ) ;\n q6s16 = vreinterpretq_s16_u16 ( q6u16 ) ;\n q7s16 = vreinterpretq_s16_u16 ( q7u16 ) ;\n q8s16 = vreinterpretq_s16_u16 ( q8u16 ) ;\n q9s16 = vreinterpretq_s16_u16 ( q9u16 ) ;\n q10s16 = vreinterpretq_s16_u16 ( q10u16 ) ;\n q7s16 = vqaddq_s16 ( q7s16 , q3s16 ) ;\n q8s16 = vqaddq_s16 ( q8s16 , q4s16 ) ;\n q9s16 = vqaddq_s16 ( q9s16 , q5s16 ) ;\n q10s16 = vqaddq_s16 ( q10s16 , q6s16 ) ;\n d22u8 = vqrshrun_n_s16 ( q7s16 , 7 ) ;\n d23u8 = vqrshrun_n_s16 ( q8s16 , 7 ) ;\n d24u8 = vqrshrun_n_s16 ( q9s16 , 7 ) ;\n d25u8 = vqrshrun_n_s16 ( q10s16 , 7 ) ;\n if ( yoffset == 0 ) {\n vst1_u8 ( dst_ptr , d22u8 ) ;\n dst_ptr += dst_pitch ;\n vst1_u8 ( dst_ptr , d23u8 ) ;\n dst_ptr += dst_pitch ;\n vst1_u8 ( dst_ptr , d24u8 ) ;\n dst_ptr += dst_pitch ;\n vst1_u8 ( dst_ptr , d25u8 ) ;\n dst_ptr += dst_pitch ;\n }\n else {\n vst1_u8 ( tmpp , d22u8 ) ;\n tmpp += 8 ;\n vst1_u8 ( tmpp , d23u8 ) ;\n tmpp += 8 ;\n vst1_u8 ( tmpp , d24u8 ) ;\n tmpp += 8 ;\n vst1_u8 ( tmpp , d25u8 ) ;\n tmpp += 8 ;\n }\n }\n if ( yoffset == 0 ) return ;\n q3u8 = vld1q_u8 ( src ) ;\n src += src_pixels_per_line ;\n q4u8 = vld1q_u8 ( src ) ;\n src += src_pixels_per_line ;\n q5u8 = vld1q_u8 ( src ) ;\n src += src_pixels_per_line ;\n q6u8 = vld1q_u8 ( src ) ;\n src += src_pixels_per_line ;\n q7u8 = vld1q_u8 ( src ) ;\n q8u16 = vmull_u8 ( vget_low_u8 ( q3u8 ) , d0u8 ) ;\n q9u16 = vmull_u8 ( vget_low_u8 ( q4u8 ) , d0u8 ) ;\n q10u16 = vmull_u8 ( vget_low_u8 ( q5u8 ) , d0u8 ) ;\n q11u16 = vmull_u8 ( vget_low_u8 ( q6u8 ) , d0u8 ) ;\n q12u16 = vmull_u8 ( vget_low_u8 ( q7u8 ) , d0u8 ) ;\n d27u8 = vext_u8 ( vget_low_u8 ( q3u8 ) , vget_high_u8 ( q3u8 ) , 1 ) ;\n d28u8 = vext_u8 ( vget_low_u8 ( q4u8 ) , vget_high_u8 ( q4u8 ) , 1 ) ;\n d29u8 = vext_u8 ( vget_low_u8 ( q5u8 ) , vget_high_u8 ( q5u8 ) , 1 ) ;\n d30u8 = vext_u8 ( vget_low_u8 ( q6u8 ) , vget_high_u8 ( q6u8 ) , 1 ) ;\n d31u8 = vext_u8 ( vget_low_u8 ( q7u8 ) , vget_high_u8 ( q7u8 ) , 1 ) ;\n q8u16 = vmlsl_u8 ( q8u16 , d27u8 , d1u8 ) ;\n q9u16 = vmlsl_u8 ( q9u16 , d28u8 , d1u8 ) ;\n q10u16 = vmlsl_u8 ( q10u16 , d29u8 , d1u8 ) ;\n q11u16 = vmlsl_u8 ( q11u16 , d30u8 , d1u8 ) ;\n q12u16 = vmlsl_u8 ( q12u16 , d31u8 , d1u8 ) ;\n d27u8 = vext_u8 ( vget_low_u8 ( q3u8 ) , vget_high_u8 ( q3u8 ) , 4 ) ;\n d28u8 = vext_u8 ( vget_low_u8 ( q4u8 ) , vget_high_u8 ( q4u8 ) , 4 ) ;\n d29u8 = vext_u8 ( vget_low_u8 ( q5u8 ) , vget_high_u8 ( q5u8 ) , 4 ) ;\n d30u8 = vext_u8 ( vget_low_u8 ( q6u8 ) , vget_high_u8 ( q6u8 ) , 4 ) ;\n d31u8 = vext_u8 ( vget_low_u8 ( q7u8 ) , vget_high_u8 ( q7u8 ) , 4 ) ;\n q8u16 = vmlsl_u8 ( q8u16 , d27u8 , d4u8 ) ;\n q9u16 = vmlsl_u8 ( q9u16 , d28u8 , d4u8 ) ;\n q10u16 = vmlsl_u8 ( q10u16 , d29u8 , d4u8 ) ;\n q11u16 = vmlsl_u8 ( q11u16 , d30u8 , d4u8 ) ;\n q12u16 = vmlsl_u8 ( q12u16 , d31u8 , d4u8 ) ;\n d27u8 = vext_u8 ( vget_low_u8 ( q3u8 ) , vget_high_u8 ( q3u8 ) , 2 ) ;\n d28u8 = vext_u8 ( vget_low_u8 ( q4u8 ) , vget_high_u8 ( q4u8 ) , 2 ) ;\n d29u8 = vext_u8 ( vget_low_u8 ( q5u8 ) , vget_high_u8 ( q5u8 ) , 2 ) ;\n d30u8 = vext_u8 ( vget_low_u8 ( q6u8 ) , vget_high_u8 ( q6u8 ) , 2 ) ;\n d31u8 = vext_u8 ( vget_low_u8 ( q7u8 ) , vget_high_u8 ( q7u8 ) , 2 ) ;\n q8u16 = vmlal_u8 ( q8u16 , d27u8 , d2u8 ) ;\n q9u16 = vmlal_u8 ( q9u16 , d28u8 , d2u8 ) ;\n q10u16 = vmlal_u8 ( q10u16 , d29u8 , d2u8 ) ;\n q11u16 = vmlal_u8 ( q11u16 , d30u8 , d2u8 ) ;\n q12u16 = vmlal_u8 ( q12u16 , d31u8 , d2u8 ) ;\n d27u8 = vext_u8 ( vget_low_u8 ( q3u8 ) , vget_high_u8 ( q3u8 ) , 5 ) ;\n d28u8 = vext_u8 ( vget_low_u8 ( q4u8 ) , vget_high_u8 ( q4u8 ) , 5 ) ;\n d29u8 = vext_u8 ( vget_low_u8 ( q5u8 ) , vget_high_u8 ( q5u8 ) , 5 ) ;\n d30u8 = vext_u8 ( vget_low_u8 ( q6u8 ) , vget_high_u8 ( q6u8 ) , 5 ) ;\n d31u8 = vext_u8 ( vget_low_u8 ( q7u8 ) , vget_high_u8 ( q7u8 ) , 5 ) ;\n q8u16 = vmlal_u8 ( q8u16 , d27u8 , d5u8 ) ;\n q9u16 = vmlal_u8 ( q9u16 , d28u8 , d5u8 ) ;\n q10u16 = vmlal_u8 ( q10u16 , d29u8 , d5u8 ) ;\n q11u16 = vmlal_u8 ( q11u16 , d30u8 , d5u8 ) ;\n q12u16 = vmlal_u8 ( q12u16 , d31u8 , d5u8 ) ;\n d27u8 = vext_u8 ( vget_low_u8 ( q3u8 ) , vget_high_u8 ( q3u8 ) , 3 ) ;\n d28u8 = vext_u8 ( vget_low_u8 ( q4u8 ) , vget_high_u8 ( q4u8 ) , 3 ) ;\n d29u8 = vext_u8 ( vget_low_u8 ( q5u8 ) , vget_high_u8 ( q5u8 ) , 3 ) ;\n d30u8 = vext_u8 ( vget_low_u8 ( q6u8 ) , vget_high_u8 ( q6u8 ) , 3 ) ;\n d31u8 = vext_u8 ( vget_low_u8 ( q7u8 ) , vget_high_u8 ( q7u8 ) , 3 ) ;\n q3u16 = vmull_u8 ( d27u8 , d3u8 ) ;\n q4u16 = vmull_u8 ( d28u8 , d3u8 ) ;\n q5u16 = vmull_u8 ( d29u8 , d3u8 ) ;\n q6u16 = vmull_u8 ( d30u8 , d3u8 ) ;\n q7u16 = vmull_u8 ( d31u8 , d3u8 ) ;\n q3s16 = vreinterpretq_s16_u16 ( q3u16 ) ;\n q4s16 = vreinterpretq_s16_u16 ( q4u16 ) ;\n q5s16 = vreinterpretq_s16_u16 ( q5u16 ) ;\n q6s16 = vreinterpretq_s16_u16 ( q6u16 ) ;\n q7s16 = vreinterpretq_s16_u16 ( q7u16 ) ;\n q8s16 = vreinterpretq_s16_u16 ( q8u16 ) ;\n q9s16 = vreinterpretq_s16_u16 ( q9u16 ) ;\n q10s16 = vreinterpretq_s16_u16 ( q10u16 ) ;\n q11s16 = vreinterpretq_s16_u16 ( q11u16 ) ;\n q12s16 = vreinterpretq_s16_u16 ( q12u16 ) ;\n q8s16 = vqaddq_s16 ( q8s16 , q3s16 ) ;\n q9s16 = vqaddq_s16 ( q9s16 , q4s16 ) ;\n q10s16 = vqaddq_s16 ( q10s16 , q5s16 ) ;\n q11s16 = vqaddq_s16 ( q11s16 , q6s16 ) ;\n q12s16 = vqaddq_s16 ( q12s16 , q7s16 ) ;\n d26u8 = vqrshrun_n_s16 ( q8s16 , 7 ) ;\n d27u8 = vqrshrun_n_s16 ( q9s16 , 7 ) ;\n d28u8 = vqrshrun_n_s16 ( q10s16 , 7 ) ;\n d29u8 = vqrshrun_n_s16 ( q11s16 , 7 ) ;\n d30u8 = vqrshrun_n_s16 ( q12s16 , 7 ) ;\n dtmps8 = vld1_s8 ( vp8_sub_pel_filters [ yoffset ] ) ;\n d0s8 = vdup_lane_s8 ( dtmps8 , 0 ) ;\n d1s8 = vdup_lane_s8 ( dtmps8 , 1 ) ;\n d2s8 = vdup_lane_s8 ( dtmps8 , 2 ) ;\n d3s8 = vdup_lane_s8 ( dtmps8 , 3 ) ;\n d4s8 = vdup_lane_s8 ( dtmps8 , 4 ) ;\n d5s8 = vdup_lane_s8 ( dtmps8 , 5 ) ;\n d0u8 = vreinterpret_u8_s8 ( vabs_s8 ( d0s8 ) ) ;\n d1u8 = vreinterpret_u8_s8 ( vabs_s8 ( d1s8 ) ) ;\n d2u8 = vreinterpret_u8_s8 ( vabs_s8 ( d2s8 ) ) ;\n d3u8 = vreinterpret_u8_s8 ( vabs_s8 ( d3s8 ) ) ;\n d4u8 = vreinterpret_u8_s8 ( vabs_s8 ( d4s8 ) ) ;\n d5u8 = vreinterpret_u8_s8 ( vabs_s8 ( d5s8 ) ) ;\n tmpp = tmp ;\n q9u8 = vld1q_u8 ( tmpp ) ;\n tmpp += 16 ;\n q10u8 = vld1q_u8 ( tmpp ) ;\n tmpp += 16 ;\n q11u8 = vld1q_u8 ( tmpp ) ;\n tmpp += 16 ;\n q12u8 = vld1q_u8 ( tmpp ) ;\n d18u8 = vget_low_u8 ( q9u8 ) ;\n d19u8 = vget_high_u8 ( q9u8 ) ;\n d20u8 = vget_low_u8 ( q10u8 ) ;\n d21u8 = vget_high_u8 ( q10u8 ) ;\n d22u8 = vget_low_u8 ( q11u8 ) ;\n d23u8 = vget_high_u8 ( q11u8 ) ;\n d24u8 = vget_low_u8 ( q12u8 ) ;\n d25u8 = vget_high_u8 ( q12u8 ) ;\n for ( i = 2 ;\n i > 0 ;\n i -- ) {\n q3u16 = vmull_u8 ( d18u8 , d0u8 ) ;\n q4u16 = vmull_u8 ( d19u8 , d0u8 ) ;\n q5u16 = vmull_u8 ( d20u8 , d0u8 ) ;\n q6u16 = vmull_u8 ( d21u8 , d0u8 ) ;\n q3u16 = vmlsl_u8 ( q3u16 , d19u8 , d1u8 ) ;\n q4u16 = vmlsl_u8 ( q4u16 , d20u8 , d1u8 ) ;\n q5u16 = vmlsl_u8 ( q5u16 , d21u8 , d1u8 ) ;\n q6u16 = vmlsl_u8 ( q6u16 , d22u8 , d1u8 ) ;\n q3u16 = vmlsl_u8 ( q3u16 , d22u8 , d4u8 ) ;\n q4u16 = vmlsl_u8 ( q4u16 , d23u8 , d4u8 ) ;\n q5u16 = vmlsl_u8 ( q5u16 , d24u8 , d4u8 ) ;\n q6u16 = vmlsl_u8 ( q6u16 , d25u8 , d4u8 ) ;\n q3u16 = vmlal_u8 ( q3u16 , d20u8 , d2u8 ) ;\n q4u16 = vmlal_u8 ( q4u16 , d21u8 , d2u8 ) ;\n q5u16 = vmlal_u8 ( q5u16 , d22u8 , d2u8 ) ;\n q6u16 = vmlal_u8 ( q6u16 , d23u8 , d2u8 ) ;\n q3u16 = vmlal_u8 ( q3u16 , d23u8 , d5u8 ) ;\n q4u16 = vmlal_u8 ( q4u16 , d24u8 , d5u8 ) ;\n q5u16 = vmlal_u8 ( q5u16 , d25u8 , d5u8 ) ;\n q6u16 = vmlal_u8 ( q6u16 , d26u8 , d5u8 ) ;\n q7u16 = vmull_u8 ( d21u8 , d3u8 ) ;\n q8u16 = vmull_u8 ( d22u8 , d3u8 ) ;\n q9u16 = vmull_u8 ( d23u8 , d3u8 ) ;\n q10u16 = vmull_u8 ( d24u8 , d3u8 ) ;\n q3s16 = vreinterpretq_s16_u16 ( q3u16 ) ;\n q4s16 = vreinterpretq_s16_u16 ( q4u16 ) ;\n q5s16 = vreinterpretq_s16_u16 ( q5u16 ) ;\n q6s16 = vreinterpretq_s16_u16 ( q6u16 ) ;\n q7s16 = vreinterpretq_s16_u16 ( q7u16 ) ;\n q8s16 = vreinterpretq_s16_u16 ( q8u16 ) ;\n q9s16 = vreinterpretq_s16_u16 ( q9u16 ) ;\n q10s16 = vreinterpretq_s16_u16 ( q10u16 ) ;\n q7s16 = vqaddq_s16 ( q7s16 , q3s16 ) ;\n q8s16 = vqaddq_s16 ( q8s16 , q4s16 ) ;\n q9s16 = vqaddq_s16 ( q9s16 , q5s16 ) ;\n q10s16 = vqaddq_s16 ( q10s16 , q6s16 ) ;\n d6u8 = vqrshrun_n_s16 ( q7s16 , 7 ) ;\n d7u8 = vqrshrun_n_s16 ( q8s16 , 7 ) ;\n d8u8 = vqrshrun_n_s16 ( q9s16 , 7 ) ;\n d9u8 = vqrshrun_n_s16 ( q10s16 , 7 ) ;\n d18u8 = d22u8 ;\n d19u8 = d23u8 ;\n d20u8 = d24u8 ;\n d21u8 = d25u8 ;\n d22u8 = d26u8 ;\n d23u8 = d27u8 ;\n d24u8 = d28u8 ;\n d25u8 = d29u8 ;\n d26u8 = d30u8 ;\n vst1_u8 ( dst_ptr , d6u8 ) ;\n dst_ptr += dst_pitch ;\n vst1_u8 ( dst_ptr , d7u8 ) ;\n dst_ptr += dst_pitch ;\n vst1_u8 ( dst_ptr , d8u8 ) ;\n dst_ptr += dst_pitch ;\n vst1_u8 ( dst_ptr , d9u8 ) ;\n dst_ptr += dst_pitch ;\n }\n return ;\n }", "idx": 118}
{"hash": 6343276067273564310, "project": "debian", "size": 27, "label": 0, "functionSource": "static afs_int32 getCPS ( struct rx_call * call , afs_int32 aid , prlist * alist , afs_int32 * over , afs_int32 * cid ) {\n afs_int32 code ;\n struct ubik_trans * tt ;\n afs_int32 temp ;\n struct prentry tentry ;\n * over = 0 ;\n alist -> prlist_len = 0 ;\n alist -> prlist_val = NULL ;\n code = Initdb ( ) ;\n if ( code != PRSUCCESS ) return code ;\n code = ubik_BeginTransReadAny ( dbase , UBIK_READTRANS , & tt ) ;\n if ( code ) return code ;\n code = ubik_SetLock ( tt , 1 , 1 , LOCKREAD ) ;\n if ( code ) ABORT_WITH ( tt , code ) ;\n code = read_DbHeader ( tt ) ;\n if ( code ) ABORT_WITH ( tt , code ) ;\n temp = FindByID ( tt , aid ) ;\n if ( ! temp ) ABORT_WITH ( tt , PRNOENT ) ;\n code = pr_ReadEntry ( tt , 0 , temp , & tentry ) ;\n if ( code ) ABORT_WITH ( tt , code ) ;\n code = WhoIsThis ( call , tt , cid ) ;\n if ( code || ! AccessOK ( tt , * cid , & tentry , PRP_MEMBER_MEM , PRP_MEMBER_ANY ) ) ABORT_WITH ( tt , PRPERM ) ;\n code = GetList ( tt , & tentry , alist , 1 ) ;\n if ( code != PRSUCCESS ) ABORT_WITH ( tt , code ) ;\n code = ubik_EndTrans ( tt ) ;\n return code ;\n }", "idx": 119}
{"hash": 416708768813973469, "project": "chrome", "size": 14, "label": 0, "functionSource": "TEST_F ( TemplateURLParserTest , TestPostSuggestion ) {\n ParamFilterImpl filter ( std : : string ( ) , \"Mozilla\" ) ;\n ASSERT_NO_FATAL_FAILURE ( ParseFile ( \"post_suggestion.xml\" , & filter ) ) ;\n ASSERT_TRUE ( template_url_ ) ;\n EXPECT_EQ ( ASCIIToUTF16 ( \"Yahoo\" ) , template_url_ -> short_name ( ) ) ;\n EXPECT_TRUE ( template_url_ -> url_ref ( ) . SupportsReplacement ( SearchTermsData ( ) ) ) ;\n EXPECT_TRUE ( template_url_ -> suggestions_url ( ) . empty ( ) ) ;\n EXPECT_EQ ( \"http://search.yahoo.com/search?p={\nsearchTerms}\n&ei=UTF-8\" , template_url_ -> url ( ) ) ;\n ASSERT_EQ ( 1U , template_url_ -> input_encodings ( ) . size ( ) ) ;\n EXPECT_EQ ( \"UTF-8\" , template_url_ -> input_encodings ( ) [ 0 ] ) ;\n EXPECT_EQ ( GURL ( \"http://search.yahoo.com/favicon.ico\" ) , template_url_ -> favicon_url ( ) ) ;\n }", "idx": 120}
{"hash": 2064081176034684128, "project": "debian", "size": 42, "label": 1, "functionSource": "static int matroska_read_seek ( AVFormatContext * s , int stream_index , int64_t timestamp , int flags ) {\n MatroskaDemuxContext * matroska = s -> priv_data ;\n MatroskaTrack * tracks = matroska -> tracks . elem ;\n AVStream * st = s -> streams [ stream_index ] ;\n int i , index , index_sub , index_min ;\n if ( matroska -> cues_parsing_deferred ) {\n matroska_parse_cues ( matroska ) ;\n matroska -> cues_parsing_deferred = 0 ;\n }\n if ( ! st -> nb_index_entries ) return 0 ;\n timestamp = FFMAX ( timestamp , st -> index_entries [ 0 ] . timestamp ) ;\n if ( ( index = av_index_search_timestamp ( st , timestamp , flags ) ) < 0 ) {\n avio_seek ( s -> pb , st -> index_entries [ st -> nb_index_entries - 1 ] . pos , SEEK_SET ) ;\n matroska -> current_id = 0 ;\n while ( ( index = av_index_search_timestamp ( st , timestamp , flags ) ) < 0 ) {\n matroska_clear_queue ( matroska ) ;\n if ( matroska_parse_cluster ( matroska ) < 0 ) break ;\n }\n }\n matroska_clear_queue ( matroska ) ;\n if ( index < 0 ) return 0 ;\n index_min = index ;\n for ( i = 0 ;\n i < matroska -> tracks . nb_elem ;\n i ++ ) {\n tracks [ i ] . audio . pkt_cnt = 0 ;\n tracks [ i ] . audio . sub_packet_cnt = 0 ;\n tracks [ i ] . audio . buf_timecode = AV_NOPTS_VALUE ;\n tracks [ i ] . end_timecode = 0 ;\n if ( tracks [ i ] . type == MATROSKA_TRACK_TYPE_SUBTITLE && tracks [ i ] . stream -> discard != AVDISCARD_ALL ) {\n index_sub = av_index_search_timestamp ( tracks [ i ] . stream , st -> index_entries [ index ] . timestamp , AVSEEK_FLAG_BACKWARD ) ;\n if ( index_sub >= 0 && st -> index_entries [ index_sub ] . pos < st -> index_entries [ index_min ] . pos && st -> index_entries [ index ] . timestamp - st -> index_entries [ index_sub ] . timestamp < 30000000000 / matroska -> time_scale ) index_min = index_sub ;\n }\n }\n avio_seek ( s -> pb , st -> index_entries [ index_min ] . pos , SEEK_SET ) ;\n matroska -> current_id = 0 ;\n matroska -> skip_to_keyframe = ! ( flags & AVSEEK_FLAG_ANY ) ;\n matroska -> skip_to_timecode = st -> index_entries [ index ] . timestamp ;\n matroska -> done = 0 ;\n ff_update_cur_dts ( s , st , st -> index_entries [ index ] . timestamp ) ;\n return 0 ;\n }", "idx": 121}
{"hash": -7990991774694156606, "project": "debian", "size": 76, "label": 0, "functionSource": "static int unpack_vlcs ( Vp3DecodeContext * s , GetBitContext * gb , VLC * table , int coeff_index , int plane , int eob_run ) {\n int i , j = 0 ;\n int token ;\n int zero_run = 0 ;\n int16_t coeff = 0 ;\n int bits_to_get ;\n int blocks_ended ;\n int coeff_i = 0 ;\n int num_coeffs = s -> num_coded_frags [ plane ] [ coeff_index ] ;\n int16_t * dct_tokens = s -> dct_tokens [ plane ] [ coeff_index ] ;\n int * coded_fragment_list = s -> coded_fragment_list [ plane ] ;\n Vp3Fragment * all_fragments = s -> all_fragments ;\n VLC_TYPE ( * vlc_table ) [ 2 ] = table -> table ;\n if ( num_coeffs < 0 ) av_log ( s -> avctx , AV_LOG_ERROR , \"Invalid number of coefficents at level %d\\n\" , coeff_index ) ;\n if ( eob_run > num_coeffs ) {\n coeff_i = blocks_ended = num_coeffs ;\n eob_run -= num_coeffs ;\n }\n else {\n coeff_i = blocks_ended = eob_run ;\n eob_run = 0 ;\n }\n if ( blocks_ended ) dct_tokens [ j ++ ] = blocks_ended << 2 ;\n while ( coeff_i < num_coeffs && get_bits_left ( gb ) > 0 ) {\n token = get_vlc2 ( gb , vlc_table , 11 , 3 ) ;\n if ( ( unsigned ) token <= 6U ) {\n eob_run = eob_run_base [ token ] ;\n if ( eob_run_get_bits [ token ] ) eob_run += get_bits ( gb , eob_run_get_bits [ token ] ) ;\n if ( eob_run > num_coeffs - coeff_i ) {\n dct_tokens [ j ++ ] = TOKEN_EOB ( num_coeffs - coeff_i ) ;\n blocks_ended += num_coeffs - coeff_i ;\n eob_run -= num_coeffs - coeff_i ;\n coeff_i = num_coeffs ;\n }\n else {\n dct_tokens [ j ++ ] = TOKEN_EOB ( eob_run ) ;\n blocks_ended += eob_run ;\n coeff_i += eob_run ;\n eob_run = 0 ;\n }\n }\n else if ( token >= 0 ) {\n bits_to_get = coeff_get_bits [ token ] ;\n if ( bits_to_get ) bits_to_get = get_bits ( gb , bits_to_get ) ;\n coeff = coeff_tables [ token ] [ bits_to_get ] ;\n zero_run = zero_run_base [ token ] ;\n if ( zero_run_get_bits [ token ] ) zero_run += get_bits ( gb , zero_run_get_bits [ token ] ) ;\n if ( zero_run ) {\n dct_tokens [ j ++ ] = TOKEN_ZERO_RUN ( coeff , zero_run ) ;\n }\n else {\n if ( ! coeff_index ) all_fragments [ coded_fragment_list [ coeff_i ] ] . dc = coeff ;\n dct_tokens [ j ++ ] = TOKEN_COEFF ( coeff ) ;\n }\n if ( coeff_index + zero_run > 64 ) {\n av_log ( s -> avctx , AV_LOG_DEBUG , \"Invalid zero run of %d with\" \" %d coeffs left\\n\" , zero_run , 64 - coeff_index ) ;\n zero_run = 64 - coeff_index ;\n }\n for ( i = coeff_index + 1 ;\n i <= coeff_index + zero_run ;\n i ++ ) s -> num_coded_frags [ plane ] [ i ] -- ;\n coeff_i ++ ;\n }\n else {\n av_log ( s -> avctx , AV_LOG_ERROR , \"Invalid token %d\\n\" , token ) ;\n return - 1 ;\n }\n }\n if ( blocks_ended > s -> num_coded_frags [ plane ] [ coeff_index ] ) av_log ( s -> avctx , AV_LOG_ERROR , \"More blocks ended than coded!\\n\" ) ;\n if ( blocks_ended ) for ( i = coeff_index + 1 ;\n i < 64 ;\n i ++ ) s -> num_coded_frags [ plane ] [ i ] -= blocks_ended ;\n if ( plane < 2 ) s -> dct_tokens [ plane + 1 ] [ coeff_index ] = dct_tokens + j ;\n else if ( coeff_index < 63 ) s -> dct_tokens [ 0 ] [ coeff_index + 1 ] = dct_tokens + j ;\n return eob_run ;\n }", "idx": 122}
{"hash": 914926989019402478, "project": "debian", "size": 13, "label": 0, "functionSource": "static usize_t main_get_winsize ( main_file * ifile ) {\n xoff_t file_size = 0 ;\n usize_t size = option_winsize ;\n static shortbuf iszbuf ;\n if ( main_file_stat ( ifile , & file_size ) == 0 ) {\n size = ( usize_t ) min ( file_size , ( xoff_t ) size ) ;\n }\n size = max ( size , XD3_ALLOCSIZE ) ;\n if ( option_verbose > 1 ) {\n XPR ( NT \"input %s window size %s\\n\" , ifile -> filename , main_format_bcnt ( size , & iszbuf ) ) ;\n }\n return size ;\n }", "idx": 123}
{"hash": 1896723564367514490, "project": "debian", "size": 31, "label": 1, "functionSource": "void Init_ossl_cipher ( void ) {\n # if 0 mOSSL = rb_define_module ( \"OpenSSL\" ) ;\n eOSSLError = rb_define_class_under ( mOSSL , \"OpenSSLError\" , rb_eStandardError ) ;\n # endif cCipher = rb_define_class_under ( mOSSL , \"Cipher\" , rb_cObject ) ;\n eCipherError = rb_define_class_under ( cCipher , \"CipherError\" , eOSSLError ) ;\n rb_define_alloc_func ( cCipher , ossl_cipher_alloc ) ;\n rb_define_copy_func ( cCipher , ossl_cipher_copy ) ;\n rb_define_module_function ( cCipher , \"ciphers\" , ossl_s_ciphers , 0 ) ;\n rb_define_method ( cCipher , \"initialize\" , ossl_cipher_initialize , 1 ) ;\n rb_define_method ( cCipher , \"reset\" , ossl_cipher_reset , 0 ) ;\n rb_define_method ( cCipher , \"encrypt\" , ossl_cipher_encrypt , - 1 ) ;\n rb_define_method ( cCipher , \"decrypt\" , ossl_cipher_decrypt , - 1 ) ;\n rb_define_method ( cCipher , \"pkcs5_keyivgen\" , ossl_cipher_pkcs5_keyivgen , - 1 ) ;\n rb_define_method ( cCipher , \"update\" , ossl_cipher_update , - 1 ) ;\n rb_define_method ( cCipher , \"final\" , ossl_cipher_final , 0 ) ;\n rb_define_method ( cCipher , \"name\" , ossl_cipher_name , 0 ) ;\n rb_define_method ( cCipher , \"key=\" , ossl_cipher_set_key , 1 ) ;\n rb_define_method ( cCipher , \"auth_data=\" , ossl_cipher_set_auth_data , 1 ) ;\n rb_define_method ( cCipher , \"auth_tag=\" , ossl_cipher_set_auth_tag , 1 ) ;\n rb_define_method ( cCipher , \"auth_tag\" , ossl_cipher_get_auth_tag , - 1 ) ;\n rb_define_method ( cCipher , \"auth_tag_len=\" , ossl_cipher_set_auth_tag_len , 1 ) ;\n rb_define_method ( cCipher , \"authenticated?\" , ossl_cipher_is_authenticated , 0 ) ;\n rb_define_method ( cCipher , \"key_len=\" , ossl_cipher_set_key_length , 1 ) ;\n rb_define_method ( cCipher , \"key_len\" , ossl_cipher_key_length , 0 ) ;\n rb_define_method ( cCipher , \"iv=\" , ossl_cipher_set_iv , 1 ) ;\n rb_define_method ( cCipher , \"iv_len=\" , ossl_cipher_set_iv_length , 1 ) ;\n rb_define_method ( cCipher , \"iv_len\" , ossl_cipher_iv_length , 0 ) ;\n rb_define_method ( cCipher , \"block_size\" , ossl_cipher_block_size , 0 ) ;\n rb_define_method ( cCipher , \"padding=\" , ossl_cipher_set_padding , 1 ) ;\n id_auth_tag_len = rb_intern_const ( \"auth_tag_len\" ) ;\n }", "idx": 124}
{"hash": 355220887711506893, "project": "debian", "size": 24, "label": 0, "functionSource": "static double var_eq_non_const ( VariableStatData * vardata , Oid operator , Node * other , bool varonleft ) {\n double selec ;\n bool isdefault ;\n if ( vardata -> isunique && vardata -> rel && vardata -> rel -> tuples >= 1.0 ) return 1.0 / vardata -> rel -> tuples ;\n if ( HeapTupleIsValid ( vardata -> statsTuple ) ) {\n Form_pg_statistic stats ;\n double ndistinct ;\n float4 * numbers ;\n int nnumbers ;\n stats = ( Form_pg_statistic ) GETSTRUCT ( vardata -> statsTuple ) ;\n selec = 1.0 - stats -> stanullfrac ;\n ndistinct = get_variable_numdistinct ( vardata , & isdefault ) ;\n if ( ndistinct > 1 ) selec /= ndistinct ;\n if ( get_attstatsslot ( vardata -> statsTuple , vardata -> atttype , vardata -> atttypmod , STATISTIC_KIND_MCV , InvalidOid , NULL , NULL , NULL , & numbers , & nnumbers ) ) {\n if ( nnumbers > 0 && selec > numbers [ 0 ] ) selec = numbers [ 0 ] ;\n free_attstatsslot ( vardata -> atttype , NULL , 0 , numbers , nnumbers ) ;\n }\n }\n else {\n selec = 1.0 / get_variable_numdistinct ( vardata , & isdefault ) ;\n }\n CLAMP_PROBABILITY ( selec ) ;\n return selec ;\n }", "idx": 125}
{"hash": -6359684484462176044, "project": "debian", "size": 19, "label": 0, "functionSource": "EC_KEY * o2i_ECPublicKey ( EC_KEY * * a , const unsigned char * * in , long len ) {\n EC_KEY * ret = NULL ;\n if ( a == NULL || ( * a ) == NULL || ( * a ) -> group == NULL ) {\n ECerr ( EC_F_O2I_ECPUBLICKEY , ERR_R_PASSED_NULL_PARAMETER ) ;\n return 0 ;\n }\n ret = * a ;\n if ( ret -> pub_key == NULL && ( ret -> pub_key = EC_POINT_new ( ret -> group ) ) == NULL ) {\n ECerr ( EC_F_O2I_ECPUBLICKEY , ERR_R_MALLOC_FAILURE ) ;\n return 0 ;\n }\n if ( ! EC_POINT_oct2point ( ret -> group , ret -> pub_key , * in , len , NULL ) ) {\n ECerr ( EC_F_O2I_ECPUBLICKEY , ERR_R_EC_LIB ) ;\n return 0 ;\n }\n ret -> conv_form = ( point_conversion_form_t ) ( * in [ 0 ] & ~ 0x01 ) ;\n * in += len ;\n return ret ;\n }", "idx": 126}
{"hash": -7456613930747243098, "project": "debian", "size": 90, "label": 0, "functionSource": "static int decode_block ( BinkAudioContext * s , float * * out , int use_dct ) {\n int ch , i , j , k ;\n float q , quant [ 25 ] ;\n int width , coeff ;\n GetBitContext * gb = & s -> gb ;\n if ( use_dct ) skip_bits ( gb , 2 ) ;\n for ( ch = 0 ;\n ch < s -> channels ;\n ch ++ ) {\n FFTSample * coeffs = out [ ch ] ;\n if ( s -> version_b ) {\n if ( get_bits_left ( gb ) < 64 ) return AVERROR_INVALIDDATA ;\n coeffs [ 0 ] = av_int2float ( get_bits_long ( gb , 32 ) ) * s -> root ;\n coeffs [ 1 ] = av_int2float ( get_bits_long ( gb , 32 ) ) * s -> root ;\n }\n else {\n if ( get_bits_left ( gb ) < 58 ) return AVERROR_INVALIDDATA ;\n coeffs [ 0 ] = get_float ( gb ) * s -> root ;\n coeffs [ 1 ] = get_float ( gb ) * s -> root ;\n }\n if ( get_bits_left ( gb ) < s -> num_bands * 8 ) return AVERROR_INVALIDDATA ;\n for ( i = 0 ;\n i < s -> num_bands ;\n i ++ ) {\n int value = get_bits ( gb , 8 ) ;\n quant [ i ] = quant_table [ FFMIN ( value , 95 ) ] ;\n }\n k = 0 ;\n q = quant [ 0 ] ;\n i = 2 ;\n while ( i < s -> frame_len ) {\n if ( s -> version_b ) {\n j = i + 16 ;\n }\n else {\n int v = get_bits1 ( gb ) ;\n if ( v ) {\n v = get_bits ( gb , 4 ) ;\n j = i + rle_length_tab [ v ] * 8 ;\n }\n else {\n j = i + 8 ;\n }\n }\n j = FFMIN ( j , s -> frame_len ) ;\n width = get_bits ( gb , 4 ) ;\n if ( width == 0 ) {\n memset ( coeffs + i , 0 , ( j - i ) * sizeof ( * coeffs ) ) ;\n i = j ;\n while ( s -> bands [ k ] < i ) q = quant [ k ++ ] ;\n }\n else {\n while ( i < j ) {\n if ( s -> bands [ k ] == i ) q = quant [ k ++ ] ;\n coeff = get_bits ( gb , width ) ;\n if ( coeff ) {\n int v ;\n v = get_bits1 ( gb ) ;\n if ( v ) coeffs [ i ] = - q * coeff ;\n else coeffs [ i ] = q * coeff ;\n }\n else {\n coeffs [ i ] = 0.0f ;\n }\n i ++ ;\n }\n }\n }\n if ( CONFIG_BINKAUDIO_DCT_DECODER && use_dct ) {\n coeffs [ 0 ] /= 0.5 ;\n s -> trans . dct . dct_calc ( & s -> trans . dct , coeffs ) ;\n }\n else if ( CONFIG_BINKAUDIO_RDFT_DECODER ) s -> trans . rdft . rdft_calc ( & s -> trans . rdft , coeffs ) ;\n }\n for ( ch = 0 ;\n ch < s -> channels ;\n ch ++ ) {\n int j ;\n int count = s -> overlap_len * s -> channels ;\n if ( ! s -> first ) {\n j = ch ;\n for ( i = 0 ;\n i < s -> overlap_len ;\n i ++ , j += s -> channels ) out [ ch ] [ i ] = ( s -> previous [ ch ] [ i ] * ( count - j ) + out [ ch ] [ i ] * j ) / count ;\n }\n memcpy ( s -> previous [ ch ] , & out [ ch ] [ s -> frame_len - s -> overlap_len ] , s -> overlap_len * sizeof ( * s -> previous [ ch ] ) ) ;\n }\n s -> first = 0 ;\n return 0 ;\n }", "idx": 127}
{"hash": -7237039260294671485, "project": "debian", "size": 5, "label": 1, "functionSource": "static void nlm_msg_res_unmatched_value_destroy ( gpointer value ) {\n nlm_msg_res_unmatched_data * umd = ( nlm_msg_res_unmatched_data * ) value ;\n g_free ( ( gpointer ) umd -> cookie ) ;\n g_free ( umd ) ;\n }", "idx": 128}
{"hash": -1483849844579170895, "project": "chrome", "size": 6, "label": 0, "functionSource": "int file_is_y4m ( const char detect [ 4 ] ) {\n if ( memcmp ( detect , \"YUV4\" , 4 ) == 0 ) {\n return 1 ;\n }\n return 0 ;\n }", "idx": 129}
{"hash": -1672864273235910388, "project": "debian", "size": 93, "label": 1, "functionSource": "static void _slurm_rpc_submit_batch_job ( slurm_msg_t * msg ) {\n static int active_rpc_cnt = 0 ;\n int error_code = SLURM_SUCCESS ;\n DEF_TIMERS ;\n uint32_t job_id = 0 , priority = 0 ;\n struct job_record * job_ptr = NULL ;\n slurm_msg_t response_msg ;\n submit_response_msg_t submit_msg ;\n job_desc_msg_t * job_desc_msg = ( job_desc_msg_t * ) msg -> data ;\n slurmctld_lock_t job_read_lock = {\n READ_LOCK , READ_LOCK , READ_LOCK , READ_LOCK , READ_LOCK }\n ;\n slurmctld_lock_t job_write_lock = {\n READ_LOCK , WRITE_LOCK , WRITE_LOCK , READ_LOCK , READ_LOCK }\n ;\n uid_t uid = g_slurm_auth_get_uid ( msg -> auth_cred , slurmctld_config . auth_info ) ;\n char * err_msg = NULL , * job_submit_user_msg = NULL ;\n bool reject_job = false ;\n START_TIMER ;\n debug2 ( \"Processing RPC: REQUEST_SUBMIT_BATCH_JOB from uid=%d\" , uid ) ;\n if ( slurmctld_config . submissions_disabled ) {\n info ( \"Submissions disabled on system\" ) ;\n error_code = ESLURM_SUBMISSIONS_DISABLED ;\n reject_job = true ;\n goto send_msg ;\n }\n if ( ( uid != job_desc_msg -> user_id ) && ( ! validate_super_user ( uid ) ) ) {\n error_code = ESLURM_USER_ID_MISSING ;\n error ( \"Security violation, REQUEST_SUBMIT_BATCH_JOB from uid=%d\" , uid ) ;\n }\n if ( ( job_desc_msg -> alloc_node == NULL ) || ( job_desc_msg -> alloc_node [ 0 ] == '\\0' ) ) {\n error_code = ESLURM_INVALID_NODE_NAME ;\n error ( \"REQUEST_SUBMIT_BATCH_JOB lacks alloc_node from uid=%d\" , uid ) ;\n }\n dump_job_desc ( job_desc_msg ) ;\n if ( error_code == SLURM_SUCCESS ) {\n lock_slurmctld ( job_read_lock ) ;\n job_desc_msg -> pack_job_offset = NO_VAL ;\n error_code = validate_job_create_req ( job_desc_msg , uid , & err_msg ) ;\n unlock_slurmctld ( job_read_lock ) ;\n }\n if ( err_msg ) job_submit_user_msg = xstrdup ( err_msg ) ;\n if ( error_code ) {\n reject_job = true ;\n goto send_msg ;\n }\n _throttle_start ( & active_rpc_cnt ) ;\n lock_slurmctld ( job_write_lock ) ;\n START_TIMER ;\n if ( fed_mgr_fed_rec ) {\n if ( fed_mgr_job_allocate ( msg , job_desc_msg , false , uid , msg -> protocol_version , & job_id , & error_code , & err_msg ) ) reject_job = true ;\n }\n else {\n job_desc_msg -> pack_job_offset = NO_VAL ;\n error_code = job_allocate ( job_desc_msg , job_desc_msg -> immediate , false , NULL , 0 , uid , & job_ptr , & err_msg , msg -> protocol_version ) ;\n if ( ! job_ptr || ( error_code && job_ptr -> job_state == JOB_FAILED ) ) reject_job = true ;\n else {\n job_id = job_ptr -> job_id ;\n priority = job_ptr -> priority ;\n }\n if ( job_desc_msg -> immediate && ( error_code != SLURM_SUCCESS ) ) {\n error_code = ESLURM_CAN_NOT_START_IMMEDIATELY ;\n reject_job = true ;\n }\n }\n unlock_slurmctld ( job_write_lock ) ;\n _throttle_fini ( & active_rpc_cnt ) ;\n send_msg : END_TIMER2 ( \"_slurm_rpc_submit_batch_job\" ) ;\n if ( reject_job ) {\n info ( \"%s: %s\" , __func__ , slurm_strerror ( error_code ) ) ;\n if ( err_msg ) slurm_send_rc_err_msg ( msg , error_code , err_msg ) ;\n else slurm_send_rc_msg ( msg , error_code ) ;\n }\n else {\n info ( \"%s: JobId=%u InitPrio=%u %s\" , __func__ , job_id , priority , TIME_STR ) ;\n submit_msg . job_id = job_id ;\n submit_msg . step_id = SLURM_BATCH_SCRIPT ;\n submit_msg . error_code = error_code ;\n submit_msg . job_submit_user_msg = job_submit_user_msg ;\n slurm_msg_t_init ( & response_msg ) ;\n response_msg . flags = msg -> flags ;\n response_msg . protocol_version = msg -> protocol_version ;\n response_msg . conn = msg -> conn ;\n response_msg . msg_type = RESPONSE_SUBMIT_BATCH_JOB ;\n response_msg . data = & submit_msg ;\n slurm_send_node_msg ( msg -> conn_fd , & response_msg ) ;\n schedule_job_save ( ) ;\n schedule_node_save ( ) ;\n queue_job_scheduler ( ) ;\n }\n xfree ( err_msg ) ;\n xfree ( job_submit_user_msg ) ;\n }", "idx": 130}
{"hash": 3804373597256531021, "project": "debian", "size": 27, "label": 0, "functionSource": "static ulong get_sort ( uint count , ... ) {\n va_list args ;\n va_start ( args , count ) ;\n ulong sort = 0 ;\n DBUG_ASSERT ( count <= 4 ) ;\n while ( count -- ) {\n char * start , * str = va_arg ( args , char * ) ;\n uint chars = 0 ;\n uint wild_pos = 0 ;\n if ( ( start = str ) ) {\n for ( ;\n * str ;\n str ++ ) {\n if ( * str == wild_prefix && str [ 1 ] ) str ++ ;\n else if ( * str == wild_many || * str == wild_one ) {\n wild_pos = ( uint ) ( str - start ) + 1 ;\n if ( ! ( wild_pos == 1 && * str == wild_many && * ( ++ str ) == '\\0' ) ) wild_pos ++ ;\n break ;\n }\n chars = 128 ;\n }\n }\n sort = ( sort << 8 ) + ( wild_pos ? min ( wild_pos , 127 ) : chars ) ;\n }\n va_end ( args ) ;\n return sort ;\n }", "idx": 131}
{"hash": -5249292504513104172, "project": "debian", "size": 28, "label": 0, "functionSource": "char * xmlrpc_decode_string ( char * buf ) {\n const char * p ;\n char * q ;\n p = buf ;\n q = buf ;\n while ( * p != '\\0' ) {\n if ( * p == '&' ) {\n p ++ ;\n if ( ! strncmp ( p , \"gt;\n\" , 3 ) ) * q ++ = '>' , p += 3 ;\n else if ( ! strncmp ( p , \"lt;\n\" , 3 ) ) * q ++ = '<' , p += 3 ;\n else if ( ! strncmp ( p , \"quot;\n\" , 5 ) ) * q ++ = '\"' , p += 5 ;\n else if ( ! strncmp ( p , \"amp;\n\" , 4 ) ) * q ++ = '&' , p += 4 ;\n else if ( * p == '#' ) {\n p ++ ;\n * q ++ = ( char ) atoi ( p ) ;\n while ( * p != ';\n' && * p != '\\0' ) p ++ ;\n }\n }\n else * q ++ = * p ++ ;\n }\n * q = '\\0' ;\n return buf ;\n }", "idx": 132}
{"hash": 6393050609822897742, "project": "debian", "size": 22, "label": 0, "functionSource": "static TRBCCode xhci_reset_slot ( XHCIState * xhci , unsigned int slotid ) {\n uint32_t slot_ctx [ 4 ] ;\n dma_addr_t octx ;\n int i ;\n trace_usb_xhci_slot_reset ( slotid ) ;\n assert ( slotid >= 1 && slotid <= xhci -> numslots ) ;\n octx = xhci -> slots [ slotid - 1 ] . ctx ;\n DPRINTF ( \"xhci: output context at \" DMA_ADDR_FMT \"\\n\" , octx ) ;\n for ( i = 2 ;\n i <= 31 ;\n i ++ ) {\n if ( xhci -> slots [ slotid - 1 ] . eps [ i - 1 ] ) {\n xhci_disable_ep ( xhci , slotid , i ) ;\n }\n }\n xhci_dma_read_u32s ( xhci , octx , slot_ctx , sizeof ( slot_ctx ) ) ;\n slot_ctx [ 3 ] &= ~ ( SLOT_STATE_MASK << SLOT_STATE_SHIFT ) ;\n slot_ctx [ 3 ] |= SLOT_DEFAULT << SLOT_STATE_SHIFT ;\n DPRINTF ( \"xhci: output slot context: %08x %08x %08x %08x\\n\" , slot_ctx [ 0 ] , slot_ctx [ 1 ] , slot_ctx [ 2 ] , slot_ctx [ 3 ] ) ;\n xhci_dma_write_u32s ( xhci , octx , slot_ctx , sizeof ( slot_ctx ) ) ;\n return CC_SUCCESS ;\n }", "idx": 133}
{"hash": -6552851419396579257, "project": "debian", "size": 4, "label": 0, "functionSource": "static int SpoolssFCPN_q ( tvbuff_t * tvb , int offset , packet_info * pinfo , proto_tree * tree , dcerpc_info * di , guint8 * drep ) {\n offset = dissect_nt_policy_hnd ( tvb , offset , pinfo , tree , di , drep , hf_hnd , NULL , NULL , FALSE , FALSE ) ;\n return offset ;\n }", "idx": 134}
{"hash": 2830888773500127914, "project": "debian", "size": 17, "label": 0, "functionSource": "void check_and_dump_old_cluster ( bool live_check ) {\n if ( ! live_check ) start_postmaster ( & old_cluster , true ) ;\n get_db_and_rel_infos ( & old_cluster ) ;\n init_tablespaces ( ) ;\n get_loadable_libraries ( ) ;\n check_is_install_user ( & old_cluster ) ;\n check_proper_datallowconn ( & old_cluster ) ;\n check_for_prepared_transactions ( & old_cluster ) ;\n check_for_reg_data_type_usage ( & old_cluster ) ;\n check_for_isn_and_int8_passing_mismatch ( & old_cluster ) ;\n if ( GET_MAJOR_VERSION ( old_cluster . major_version ) <= 905 ) check_for_pg_role_prefix ( & old_cluster ) ;\n if ( GET_MAJOR_VERSION ( old_cluster . major_version ) == 904 && old_cluster . controldata . cat_ver < JSONB_FORMAT_CHANGE_CAT_VER ) check_for_jsonb_9_4_usage ( & old_cluster ) ;\n if ( GET_MAJOR_VERSION ( old_cluster . major_version ) <= 903 ) old_9_3_check_for_line_data_type_usage ( & old_cluster ) ;\n if ( GET_MAJOR_VERSION ( old_cluster . major_version ) <= 804 ) new_9_0_populate_pg_largeobject_metadata ( & old_cluster , true ) ;\n if ( ! user_opts . check ) generate_old_dump ( ) ;\n if ( ! live_check ) stop_postmaster ( false ) ;\n }", "idx": 135}
{"hash": 3246343243711264189, "project": "debian", "size": 18, "label": 0, "functionSource": "static void handle_ns_request ( int dns_fd , struct query * q ) {\n char buf [ 64 * 1024 ] ;\n int len ;\n if ( ns_ip != INADDR_ANY ) {\n memcpy ( & q -> destination . s_addr , & ns_ip , sizeof ( in_addr_t ) ) ;\n }\n len = dns_encode_ns_response ( buf , sizeof ( buf ) , q , topdomain ) ;\n if ( len < 1 ) {\n warnx ( \"dns_encode_ns_response doesn't fit\" ) ;\n return ;\n }\n if ( debug >= 2 ) {\n fprintf ( stderr , \"TX: client %s, type %d, name %s, %d bytes NS reply\\n\" , format_addr ( & q -> from , q -> fromlen ) , q -> type , q -> name , len ) ;\n }\n if ( sendto ( dns_fd , buf , len , 0 , ( struct sockaddr * ) & q -> from , q -> fromlen ) <= 0 ) {\n warn ( \"ns reply send error\" ) ;\n }\n }", "idx": 136}
{"hash": 6458694302493204858, "project": "debian", "size": 35, "label": 0, "functionSource": "Datum GetAttributeByName ( HeapTupleHeader tuple , const char * attname , bool * isNull ) {\n AttrNumber attrno ;\n Datum result ;\n Oid tupType ;\n int32 tupTypmod ;\n TupleDesc tupDesc ;\n HeapTupleData tmptup ;\n int i ;\n if ( attname == NULL ) elog ( ERROR , \"invalid attribute name\" ) ;\n if ( isNull == NULL ) elog ( ERROR , \"a NULL isNull pointer was passed\" ) ;\n if ( tuple == NULL ) {\n * isNull = true ;\n return ( Datum ) 0 ;\n }\n tupType = HeapTupleHeaderGetTypeId ( tuple ) ;\n tupTypmod = HeapTupleHeaderGetTypMod ( tuple ) ;\n tupDesc = lookup_rowtype_tupdesc ( tupType , tupTypmod ) ;\n attrno = InvalidAttrNumber ;\n for ( i = 0 ;\n i < tupDesc -> natts ;\n i ++ ) {\n if ( namestrcmp ( & ( tupDesc -> attrs [ i ] -> attname ) , attname ) == 0 ) {\n attrno = tupDesc -> attrs [ i ] -> attnum ;\n break ;\n }\n }\n if ( attrno == InvalidAttrNumber ) elog ( ERROR , \"attribute \\\"%s\\\" does not exist\" , attname ) ;\n tmptup . t_len = HeapTupleHeaderGetDatumLength ( tuple ) ;\n ItemPointerSetInvalid ( & ( tmptup . t_self ) ) ;\n tmptup . t_tableOid = InvalidOid ;\n tmptup . t_data = tuple ;\n result = heap_getattr ( & tmptup , attrno , tupDesc , isNull ) ;\n ReleaseTupleDesc ( tupDesc ) ;\n return result ;\n }", "idx": 137}
{"hash": -8620097311326519087, "project": "chrome", "size": 92, "label": 0, "functionSource": "err_status_t srtp_protect_rtcp ( srtp_t ctx , void * rtcp_hdr , int * pkt_octet_len ) {\n srtcp_hdr_t * hdr = ( srtcp_hdr_t * ) rtcp_hdr ;\n uint32_t * enc_start ;\n uint32_t * auth_start ;\n uint32_t * trailer ;\n unsigned int enc_octet_len = 0 ;\n uint8_t * auth_tag = NULL ;\n err_status_t status ;\n int tag_len ;\n srtp_stream_ctx_t * stream ;\n int prefix_len ;\n uint32_t seq_num ;\n if ( * pkt_octet_len < octets_in_rtcp_header ) return err_status_bad_param ;\n stream = srtp_get_stream ( ctx , hdr -> ssrc ) ;\n if ( stream == NULL ) {\n if ( ctx -> stream_template != NULL ) {\n srtp_stream_ctx_t * new_stream ;\n status = srtp_stream_clone ( ctx -> stream_template , hdr -> ssrc , & new_stream ) ;\n if ( status ) return status ;\n new_stream -> next = ctx -> stream_list ;\n ctx -> stream_list = new_stream ;\n stream = new_stream ;\n }\n else {\n return err_status_no_ctx ;\n }\n }\n if ( stream -> direction != dir_srtp_sender ) {\n if ( stream -> direction == dir_unknown ) {\n stream -> direction = dir_srtp_sender ;\n }\n else {\n srtp_handle_event ( ctx , stream , event_ssrc_collision ) ;\n }\n }\n if ( stream -> rtp_cipher -> algorithm == AES_128_GCM || stream -> rtp_cipher -> algorithm == AES_256_GCM ) {\n return srtp_protect_rtcp_aead ( ctx , stream , rtcp_hdr , ( unsigned int * ) pkt_octet_len ) ;\n }\n tag_len = auth_get_tag_length ( stream -> rtcp_auth ) ;\n enc_start = ( uint32_t * ) hdr + uint32s_in_rtcp_header ;\n enc_octet_len = * pkt_octet_len - octets_in_rtcp_header ;\n trailer = ( uint32_t * ) ( ( char * ) enc_start + enc_octet_len ) ;\n if ( stream -> rtcp_services & sec_serv_conf ) {\n * trailer = htonl ( SRTCP_E_BIT ) ;\n }\n else {\n enc_start = NULL ;\n enc_octet_len = 0 ;\n * trailer = 0x00000000 ;\n }\n auth_start = ( uint32_t * ) hdr ;\n auth_tag = ( uint8_t * ) hdr + * pkt_octet_len + sizeof ( srtcp_trailer_t ) ;\n ekt_write_data ( stream -> ekt , auth_tag , tag_len , pkt_octet_len , rdbx_get_packet_index ( & stream -> rtp_rdbx ) ) ;\n status = rdb_increment ( & stream -> rtcp_rdb ) ;\n if ( status ) return status ;\n seq_num = rdb_get_value ( & stream -> rtcp_rdb ) ;\n * trailer |= htonl ( seq_num ) ;\n debug_print ( mod_srtp , \"srtcp index: %x\" , seq_num ) ;\n if ( stream -> rtcp_cipher -> type -> id == AES_ICM ) {\n v128_t iv ;\n iv . v32 [ 0 ] = 0 ;\n iv . v32 [ 1 ] = hdr -> ssrc ;\n iv . v32 [ 2 ] = htonl ( seq_num >> 16 ) ;\n iv . v32 [ 3 ] = htonl ( seq_num << 16 ) ;\n status = cipher_set_iv ( stream -> rtcp_cipher , & iv , direction_encrypt ) ;\n }\n else {\n v128_t iv ;\n iv . v32 [ 0 ] = 0 ;\n iv . v32 [ 1 ] = 0 ;\n iv . v32 [ 2 ] = 0 ;\n iv . v32 [ 3 ] = htonl ( seq_num ) ;\n status = cipher_set_iv ( stream -> rtcp_cipher , & iv , direction_encrypt ) ;\n }\n if ( status ) return err_status_cipher_fail ;\n if ( auth_start ) {\n prefix_len = auth_get_prefix_length ( stream -> rtcp_auth ) ;\n status = cipher_output ( stream -> rtcp_cipher , auth_tag , prefix_len ) ;\n debug_print ( mod_srtp , \"keystream prefix: %s\" , octet_string_hex_string ( auth_tag , prefix_len ) ) ;\n if ( status ) return err_status_cipher_fail ;\n }\n if ( enc_start ) {\n status = cipher_encrypt ( stream -> rtcp_cipher , ( uint8_t * ) enc_start , & enc_octet_len ) ;\n if ( status ) return err_status_cipher_fail ;\n }\n auth_start ( stream -> rtcp_auth ) ;\n status = auth_compute ( stream -> rtcp_auth , ( uint8_t * ) auth_start , ( * pkt_octet_len ) + sizeof ( srtcp_trailer_t ) , auth_tag ) ;\n debug_print ( mod_srtp , \"srtcp auth tag: %s\" , octet_string_hex_string ( auth_tag , tag_len ) ) ;\n if ( status ) return err_status_auth_fail ;\n * pkt_octet_len += ( tag_len + sizeof ( srtcp_trailer_t ) ) ;\n return err_status_ok ;\n }", "idx": 138}
{"hash": -755883256379441954, "project": "chrome", "size": 39, "label": 1, "functionSource": "void vp9_ ## type ## _predictor_ ## size ## x ## size ## _c ( uint8_t * dst , ptrdiff_t stride , const uint8_t * above , const uint8_t * left ) {\n type ## _predictor ( dst , stride , size , above , left ) ;\n }\n # define intra_pred_allsizes ( type ) intra_pred_sized ( type , 4 ) intra_pred_sized ( type , 8 ) intra_pred_sized ( type , 16 ) intra_pred_sized ( type , 32 ) static INLINE void d207_predictor ( uint8_t * dst , ptrdiff_t stride , int bs , const uint8_t * above , const uint8_t * left ) {\n int r , c ;\n ( void ) above ;\n for ( r = 0 ;\n r < bs - 1 ;\n ++ r ) dst [ r * stride ] = ROUND_POWER_OF_TWO ( left [ r ] + left [ r + 1 ] , 1 ) ;\n dst [ ( bs - 1 ) * stride ] = left [ bs - 1 ] ;\n dst ++ ;\n for ( r = 0 ;\n r < bs - 2 ;\n ++ r ) dst [ r * stride ] = ROUND_POWER_OF_TWO ( left [ r ] + left [ r + 1 ] * 2 + left [ r + 2 ] , 2 ) ;\n dst [ ( bs - 2 ) * stride ] = ROUND_POWER_OF_TWO ( left [ bs - 2 ] + left [ bs - 1 ] * 3 , 2 ) ;\n dst [ ( bs - 1 ) * stride ] = left [ bs - 1 ] ;\n dst ++ ;\n for ( c = 0 ;\n c < bs - 2 ;\n ++ c ) dst [ ( bs - 1 ) * stride + c ] = left [ bs - 1 ] ;\n for ( r = bs - 2 ;\n r >= 0 ;\n -- r ) for ( c = 0 ;\n c < bs - 2 ;\n ++ c ) dst [ r * stride + c ] = dst [ ( r + 1 ) * stride + c - 2 ] ;\n }\n intra_pred_allsizes ( d207 ) static INLINE void d63_predictor ( uint8_t * dst , ptrdiff_t stride , int bs , const uint8_t * above , const uint8_t * left ) {\n int r , c ;\n ( void ) left ;\n for ( r = 0 ;\n r < bs ;\n ++ r ) {\n for ( c = 0 ;\n c < bs ;\n ++ c ) dst [ c ] = r & 1 ? ROUND_POWER_OF_TWO ( above [ r / 2 + c ] + above [ r / 2 + c + 1 ] * 2 + above [ r / 2 + c + 2 ] , 2 ) : ROUND_POWER_OF_TWO ( above [ r / 2 + c ] + above [ r / 2 + c + 1 ] , 1 ) ;\n dst += stride ;\n }\n }\n intra_pred_allsizes ( d63 )", "idx": 139}
{"hash": 313627013719508831, "project": "debian", "size": 3, "label": 0, "functionSource": "static inline PixelTrait GetPixelGrayTraits ( const Image * restrict image ) {\n return ( image -> channel_map [ GrayPixelChannel ] . traits ) ;\n }", "idx": 140}
{"hash": 1286774465219423144, "project": "debian", "size": 6, "label": 0, "functionSource": "static int jbig2_find_changing_element_of_color ( const byte * line , uint32_t x , uint32_t w , int color ) {\n if ( line == 0 ) return w ;\n x = jbig2_find_changing_element ( line , x , w ) ;\n if ( x < w && getbit ( line , x ) != color ) x = jbig2_find_changing_element ( line , x , w ) ;\n return x ;\n }", "idx": 141}
{"hash": 6393050609822897742, "project": "debian", "size": 74, "label": 0, "functionSource": "static TRBCCode xhci_address_slot ( XHCIState * xhci , unsigned int slotid , uint64_t pictx , bool bsr ) {\n XHCISlot * slot ;\n USBPort * uport ;\n USBDevice * dev ;\n dma_addr_t ictx , octx , dcbaap ;\n uint64_t poctx ;\n uint32_t ictl_ctx [ 2 ] ;\n uint32_t slot_ctx [ 4 ] ;\n uint32_t ep0_ctx [ 5 ] ;\n int i ;\n TRBCCode res ;\n assert ( slotid >= 1 && slotid <= xhci -> numslots ) ;\n dcbaap = xhci_addr64 ( xhci -> dcbaap_low , xhci -> dcbaap_high ) ;\n poctx = ldq_le_pci_dma ( PCI_DEVICE ( xhci ) , dcbaap + 8 * slotid ) ;\n ictx = xhci_mask64 ( pictx ) ;\n octx = xhci_mask64 ( poctx ) ;\n DPRINTF ( \"xhci: input context at \" DMA_ADDR_FMT \"\\n\" , ictx ) ;\n DPRINTF ( \"xhci: output context at \" DMA_ADDR_FMT \"\\n\" , octx ) ;\n xhci_dma_read_u32s ( xhci , ictx , ictl_ctx , sizeof ( ictl_ctx ) ) ;\n if ( ictl_ctx [ 0 ] != 0x0 || ictl_ctx [ 1 ] != 0x3 ) {\n DPRINTF ( \"xhci: invalid input context control %08x %08x\\n\" , ictl_ctx [ 0 ] , ictl_ctx [ 1 ] ) ;\n return CC_TRB_ERROR ;\n }\n xhci_dma_read_u32s ( xhci , ictx + 32 , slot_ctx , sizeof ( slot_ctx ) ) ;\n xhci_dma_read_u32s ( xhci , ictx + 64 , ep0_ctx , sizeof ( ep0_ctx ) ) ;\n DPRINTF ( \"xhci: input slot context: %08x %08x %08x %08x\\n\" , slot_ctx [ 0 ] , slot_ctx [ 1 ] , slot_ctx [ 2 ] , slot_ctx [ 3 ] ) ;\n DPRINTF ( \"xhci: input ep0 context: %08x %08x %08x %08x %08x\\n\" , ep0_ctx [ 0 ] , ep0_ctx [ 1 ] , ep0_ctx [ 2 ] , ep0_ctx [ 3 ] , ep0_ctx [ 4 ] ) ;\n uport = xhci_lookup_uport ( xhci , slot_ctx ) ;\n if ( uport == NULL ) {\n DPRINTF ( \"xhci: port not found\\n\" ) ;\n return CC_TRB_ERROR ;\n }\n trace_usb_xhci_slot_address ( slotid , uport -> path ) ;\n dev = uport -> dev ;\n if ( ! dev || ! dev -> attached ) {\n DPRINTF ( \"xhci: port %s not connected\\n\" , uport -> path ) ;\n return CC_USB_TRANSACTION_ERROR ;\n }\n for ( i = 0 ;\n i < xhci -> numslots ;\n i ++ ) {\n if ( i == slotid - 1 ) {\n continue ;\n }\n if ( xhci -> slots [ i ] . uport == uport ) {\n DPRINTF ( \"xhci: port %s already assigned to slot %d\\n\" , uport -> path , i + 1 ) ;\n return CC_TRB_ERROR ;\n }\n }\n slot = & xhci -> slots [ slotid - 1 ] ;\n slot -> uport = uport ;\n slot -> ctx = octx ;\n usb_device_reset ( dev ) ;\n if ( bsr ) {\n slot_ctx [ 3 ] = SLOT_DEFAULT << SLOT_STATE_SHIFT ;\n }\n else {\n USBPacket p ;\n uint8_t buf [ 1 ] ;\n slot_ctx [ 3 ] = ( SLOT_ADDRESSED << SLOT_STATE_SHIFT ) | slotid ;\n memset ( & p , 0 , sizeof ( p ) ) ;\n usb_packet_addbuf ( & p , buf , sizeof ( buf ) ) ;\n usb_packet_setup ( & p , USB_TOKEN_OUT , usb_ep_get ( dev , USB_TOKEN_OUT , 0 ) , 0 , 0 , false , false ) ;\n usb_device_handle_control ( dev , & p , DeviceOutRequest | USB_REQ_SET_ADDRESS , slotid , 0 , 0 , NULL ) ;\n assert ( p . status != USB_RET_ASYNC ) ;\n }\n res = xhci_enable_ep ( xhci , slotid , 1 , octx + 32 , ep0_ctx ) ;\n DPRINTF ( \"xhci: output slot context: %08x %08x %08x %08x\\n\" , slot_ctx [ 0 ] , slot_ctx [ 1 ] , slot_ctx [ 2 ] , slot_ctx [ 3 ] ) ;\n DPRINTF ( \"xhci: output ep0 context: %08x %08x %08x %08x %08x\\n\" , ep0_ctx [ 0 ] , ep0_ctx [ 1 ] , ep0_ctx [ 2 ] , ep0_ctx [ 3 ] , ep0_ctx [ 4 ] ) ;\n xhci_dma_write_u32s ( xhci , octx , slot_ctx , sizeof ( slot_ctx ) ) ;\n xhci_dma_write_u32s ( xhci , octx + 32 , ep0_ctx , sizeof ( ep0_ctx ) ) ;\n xhci -> slots [ slotid - 1 ] . addressed = 1 ;\n return res ;\n }", "idx": 142}
{"hash": 229962612204196999, "project": "debian", "size": 9, "label": 0, "functionSource": "static int get_sha1_hex_from_objpath ( const char * path , unsigned char * sha1 ) {\n char hex [ 40 ] ;\n if ( strlen ( path ) != 41 ) return - 1 ;\n memcpy ( hex , path , 2 ) ;\n path += 2 ;\n path ++ ;\n memcpy ( hex , path , 38 ) ;\n return get_sha1_hex ( hex , sha1 ) ;\n }", "idx": 143}
{"hash": -8704451445127642833, "project": "chrome", "size": 23, "label": 1, "functionSource": "static int32_t u_scanf_hex_handler ( UFILE * input , u_scanf_spec_info * info , ufmt_args * args , const UChar * fmt , int32_t * fmtConsumed , int32_t * argConverted ) {\n int32_t len ;\n int32_t skipped ;\n void * num = ( void * ) ( args [ 0 ] . ptrValue ) ;\n int64_t result ;\n skipped = u_scanf_skip_leading_ws ( input , info -> fPadChar ) ;\n ufile_fill_uchar_buffer ( input ) ;\n len = ( int32_t ) ( input -> str . fLimit - input -> str . fPos ) ;\n if ( info -> fWidth != - 1 ) len = ufmt_min ( len , info -> fWidth ) ;\n if ( * ( input -> str . fPos ) == 0x0030 && ( * ( input -> str . fPos + 1 ) == 0x0078 || * ( input -> str . fPos + 1 ) == 0x0058 ) ) {\n input -> str . fPos += 2 ;\n len -= 2 ;\n }\n result = ufmt_uto64 ( input -> str . fPos , & len , 16 ) ;\n input -> str . fPos += len ;\n if ( ! info -> fSkipArg ) {\n if ( info -> fIsShort ) * ( int16_t * ) num = ( int16_t ) ( UINT16_MAX & result ) ;\n else if ( info -> fIsLongLong ) * ( int64_t * ) num = result ;\n else * ( int32_t * ) num = ( int32_t ) ( UINT32_MAX & result ) ;\n }\n * argConverted = ! info -> fSkipArg ;\n return len + skipped ;\n }", "idx": 144}
{"hash": 3350291745253252503, "project": "chrome", "size": 4, "label": 0, "functionSource": "int main ( int argc ATTRIBUTE_UNUSED , char * * argv ATTRIBUTE_UNUSED ) {\n printf ( \"%s : SAX1 parsing support not compiled in\\n\" , argv [ 0 ] ) ;\n return ( 0 ) ;\n }", "idx": 145}
{"hash": 6393050609822897742, "project": "debian", "size": 69, "label": 0, "functionSource": "static void usb_xhci_realize ( struct PCIDevice * dev , Error * * errp ) {\n int i , ret ;\n Error * err = NULL ;\n XHCIState * xhci = XHCI ( dev ) ;\n dev -> config [ PCI_CLASS_PROG ] = 0x30 ;\n dev -> config [ PCI_INTERRUPT_PIN ] = 0x01 ;\n dev -> config [ PCI_CACHE_LINE_SIZE ] = 0x10 ;\n dev -> config [ 0x60 ] = 0x30 ;\n if ( xhci -> numintrs > MAXINTRS ) {\n xhci -> numintrs = MAXINTRS ;\n }\n while ( xhci -> numintrs & ( xhci -> numintrs - 1 ) ) {\n xhci -> numintrs ++ ;\n }\n if ( xhci -> numintrs < 1 ) {\n xhci -> numintrs = 1 ;\n }\n if ( xhci -> numslots > MAXSLOTS ) {\n xhci -> numslots = MAXSLOTS ;\n }\n if ( xhci -> numslots < 1 ) {\n xhci -> numslots = 1 ;\n }\n if ( xhci_get_flag ( xhci , XHCI_FLAG_ENABLE_STREAMS ) ) {\n xhci -> max_pstreams_mask = 7 ;\n }\n else {\n xhci -> max_pstreams_mask = 0 ;\n }\n if ( xhci -> msi != ON_OFF_AUTO_OFF ) {\n ret = msi_init ( dev , 0x70 , xhci -> numintrs , true , false , & err ) ;\n assert ( ! ret || ret == - ENOTSUP ) ;\n if ( ret && xhci -> msi == ON_OFF_AUTO_ON ) {\n error_append_hint ( & err , \"You have to use msi=auto (default) or \" \"msi=off with this machine type.\\n\" ) ;\n error_propagate ( errp , err ) ;\n return ;\n }\n assert ( ! err || xhci -> msi == ON_OFF_AUTO_AUTO ) ;\n error_free ( err ) ;\n }\n usb_xhci_init ( xhci ) ;\n xhci -> mfwrap_timer = timer_new_ns ( QEMU_CLOCK_VIRTUAL , xhci_mfwrap_timer , xhci ) ;\n memory_region_init ( & xhci -> mem , OBJECT ( xhci ) , \"xhci\" , LEN_REGS ) ;\n memory_region_init_io ( & xhci -> mem_cap , OBJECT ( xhci ) , & xhci_cap_ops , xhci , \"capabilities\" , LEN_CAP ) ;\n memory_region_init_io ( & xhci -> mem_oper , OBJECT ( xhci ) , & xhci_oper_ops , xhci , \"operational\" , 0x400 ) ;\n memory_region_init_io ( & xhci -> mem_runtime , OBJECT ( xhci ) , & xhci_runtime_ops , xhci , \"runtime\" , LEN_RUNTIME ) ;\n memory_region_init_io ( & xhci -> mem_doorbell , OBJECT ( xhci ) , & xhci_doorbell_ops , xhci , \"doorbell\" , LEN_DOORBELL ) ;\n memory_region_add_subregion ( & xhci -> mem , 0 , & xhci -> mem_cap ) ;\n memory_region_add_subregion ( & xhci -> mem , OFF_OPER , & xhci -> mem_oper ) ;\n memory_region_add_subregion ( & xhci -> mem , OFF_RUNTIME , & xhci -> mem_runtime ) ;\n memory_region_add_subregion ( & xhci -> mem , OFF_DOORBELL , & xhci -> mem_doorbell ) ;\n for ( i = 0 ;\n i < xhci -> numports ;\n i ++ ) {\n XHCIPort * port = & xhci -> ports [ i ] ;\n uint32_t offset = OFF_OPER + 0x400 + 0x10 * i ;\n port -> xhci = xhci ;\n memory_region_init_io ( & port -> mem , OBJECT ( xhci ) , & xhci_port_ops , port , port -> name , 0x10 ) ;\n memory_region_add_subregion ( & xhci -> mem , offset , & port -> mem ) ;\n }\n pci_register_bar ( dev , 0 , PCI_BASE_ADDRESS_SPACE_MEMORY | PCI_BASE_ADDRESS_MEM_TYPE_64 , & xhci -> mem ) ;\n if ( pci_bus_is_express ( dev -> bus ) || xhci_get_flag ( xhci , XHCI_FLAG_FORCE_PCIE_ENDCAP ) ) {\n ret = pcie_endpoint_cap_init ( dev , 0xa0 ) ;\n assert ( ret >= 0 ) ;\n }\n if ( xhci -> msix != ON_OFF_AUTO_OFF ) {\n msix_init ( dev , xhci -> numintrs , & xhci -> mem , 0 , OFF_MSIX_TABLE , & xhci -> mem , 0 , OFF_MSIX_PBA , 0x90 , NULL ) ;\n }\n }", "idx": 146}
{"hash": -7415191846425595149, "project": "chrome", "size": 17, "label": 0, "functionSource": "int vp9_alloc_ref_frame_buffers ( VP9_COMMON * cm , int width , int height ) {\n int i ;\n const int ss_x = cm -> subsampling_x ;\n const int ss_y = cm -> subsampling_y ;\n vp9_free_ref_frame_buffers ( cm ) ;\n for ( i = 0 ;\n i < FRAME_BUFFERS ;\n ++ i ) {\n cm -> frame_bufs [ i ] . ref_count = 0 ;\n if ( vp9_alloc_frame_buffer ( & cm -> frame_bufs [ i ] . buf , width , height , ss_x , ss_y , # if CONFIG_VP9_HIGHBITDEPTH cm -> use_highbitdepth , # endif VP9_ENC_BORDER_IN_PIXELS ) < 0 ) goto fail ;\n }\n init_frame_bufs ( cm ) ;\n # if CONFIG_INTERNAL_STATS || CONFIG_VP9_POSTPROC if ( vp9_alloc_frame_buffer ( & cm -> post_proc_buffer , width , height , ss_x , ss_y , # if CONFIG_VP9_HIGHBITDEPTH cm -> use_highbitdepth , # endif VP9_ENC_BORDER_IN_PIXELS ) < 0 ) goto fail ;\n # endif return 0 ;\n fail : vp9_free_ref_frame_buffers ( cm ) ;\n return 1 ;\n }", "idx": 147}
{"hash": 2578089348587614328, "project": "debian", "size": 3, "label": 0, "functionSource": "int i2d_EC_PUBKEY_fp ( FILE * fp , EC_KEY * eckey ) {\n return ASN1_i2d_fp_of ( EC_KEY , i2d_EC_PUBKEY , fp , eckey ) ;\n }", "idx": 148}
{"hash": 1208165234047591297, "project": "debian", "size": 32, "label": 0, "functionSource": "void parseDataValue ( proto_tree * tree , tvbuff_t * tvb , packet_info * pinfo , gint * pOffset , const char * szFieldName ) {\n static const int * datavalue_mask [ ] = {\n & hf_opcua_datavalue_mask_valueflag , & hf_opcua_datavalue_mask_statuscodeflag , & hf_opcua_datavalue_mask_sourcetimestampflag , & hf_opcua_datavalue_mask_servertimestampflag , & hf_opcua_datavalue_mask_sourcepicoseconds , & hf_opcua_datavalue_mask_serverpicoseconds , NULL }\n ;\n proto_item * ti ;\n proto_tree * subtree = proto_tree_add_subtree_format ( tree , tvb , * pOffset , - 1 , ett_opcua_datavalue , & ti , \"%s: DataValue\" , szFieldName ) ;\n gint iOffset = * pOffset ;\n guint8 EncodingMask ;\n EncodingMask = tvb_get_guint8 ( tvb , iOffset ) ;\n proto_tree_add_bitmask ( subtree , tvb , iOffset , hf_opcua_datavalue_mask , ett_opcua_datavalue_encodingmask , datavalue_mask , ENC_LITTLE_ENDIAN ) ;\n iOffset ++ ;\n if ( EncodingMask & DATAVALUE_ENCODINGBYTE_VALUE ) {\n parseVariant ( subtree , tvb , pinfo , & iOffset , \"Value\" ) ;\n }\n if ( EncodingMask & DATAVALUE_ENCODINGBYTE_STATUSCODE ) {\n parseStatusCode ( subtree , tvb , pinfo , & iOffset , hf_opcua_StatusCode ) ;\n }\n if ( EncodingMask & DATAVALUE_ENCODINGBYTE_SOURCETIMESTAMP ) {\n parseDateTime ( subtree , tvb , pinfo , & iOffset , hf_opcua_SourceTimestamp ) ;\n }\n if ( EncodingMask & DATAVALUE_ENCODINGBYTE_SOURCEPICOSECONDS ) {\n parseUInt16 ( subtree , tvb , pinfo , & iOffset , hf_opcua_SourcePicoseconds ) ;\n }\n if ( EncodingMask & DATAVALUE_ENCODINGBYTE_SERVERTIMESTAMP ) {\n parseDateTime ( subtree , tvb , pinfo , & iOffset , hf_opcua_ServerTimestamp ) ;\n }\n if ( EncodingMask & DATAVALUE_ENCODINGBYTE_SERVERPICOSECONDS ) {\n parseUInt16 ( subtree , tvb , pinfo , & iOffset , hf_opcua_ServerPicoseconds ) ;\n }\n proto_item_set_end ( ti , tvb , iOffset ) ;\n * pOffset = iOffset ;\n }", "idx": 149}
{"hash": 4372812923566076695, "project": "debian", "size": 32, "label": 0, "functionSource": "static void send_everything ( connection_t * c ) {\n avl_node_t * node , * node2 ;\n node_t * n ;\n subnet_t * s ;\n edge_t * e ;\n if ( tunnelserver ) {\n for ( node = myself -> subnet_tree -> head ;\n node ;\n node = node -> next ) {\n s = node -> data ;\n send_add_subnet ( c , s ) ;\n }\n return ;\n }\n for ( node = node_tree -> head ;\n node ;\n node = node -> next ) {\n n = node -> data ;\n for ( node2 = n -> subnet_tree -> head ;\n node2 ;\n node2 = node2 -> next ) {\n s = node2 -> data ;\n send_add_subnet ( c , s ) ;\n }\n for ( node2 = n -> edge_tree -> head ;\n node2 ;\n node2 = node2 -> next ) {\n e = node2 -> data ;\n send_add_edge ( c , e ) ;\n }\n }\n }", "idx": 150}
{"hash": -1055531103257174901, "project": "debian", "size": 18, "label": 0, "functionSource": "GList * completion_get_servertags ( const char * word ) {\n GList * list ;\n GSList * tmp ;\n int len ;\n g_return_val_if_fail ( word != NULL , NULL ) ;\n len = strlen ( word ) ;\n list = NULL ;\n for ( tmp = servers ;\n tmp != NULL ;\n tmp = tmp -> next ) {\n SERVER_REC * rec = tmp -> data ;\n if ( g_ascii_strncasecmp ( rec -> tag , word , len ) == 0 ) {\n if ( rec == active_win -> active_server ) list = g_list_prepend ( list , g_strdup ( rec -> tag ) ) ;\n else list = g_list_append ( list , g_strdup ( rec -> tag ) ) ;\n }\n }\n return list ;\n }", "idx": 151}
{"hash": -7434014980763120366, "project": "debian", "size": 6, "label": 0, "functionSource": "void ber_decode_as_foreach ( GHFunc func , gpointer user_data ) {\n da_data decode_as_data ;\n decode_as_data . func = func ;\n decode_as_data . user_data = user_data ;\n dissector_table_foreach ( \"ber.syntax\" , ber_decode_as_dt , & decode_as_data ) ;\n }", "idx": 152}
{"hash": -4239386405881995323, "project": "chrome", "size": 51, "label": 0, "functionSource": "static int xmlHashGrow ( xmlHashTablePtr table , int size ) {\n unsigned long key ;\n int oldsize , i ;\n xmlHashEntryPtr iter , next ;\n struct _xmlHashEntry * oldtable ;\n # ifdef DEBUG_GROW unsigned long nbElem = 0 ;\n # endif if ( table == NULL ) return ( - 1 ) ;\n if ( size < 8 ) return ( - 1 ) ;\n if ( size > 8 * 2048 ) return ( - 1 ) ;\n oldsize = table -> size ;\n oldtable = table -> table ;\n if ( oldtable == NULL ) return ( - 1 ) ;\n table -> table = xmlMalloc ( size * sizeof ( xmlHashEntry ) ) ;\n if ( table -> table == NULL ) {\n table -> table = oldtable ;\n return ( - 1 ) ;\n }\n memset ( table -> table , 0 , size * sizeof ( xmlHashEntry ) ) ;\n table -> size = size ;\n for ( i = 0 ;\n i < oldsize ;\n i ++ ) {\n if ( oldtable [ i ] . valid == 0 ) continue ;\n key = xmlHashComputeKey ( table , oldtable [ i ] . name , oldtable [ i ] . name2 , oldtable [ i ] . name3 ) ;\n memcpy ( & ( table -> table [ key ] ) , & ( oldtable [ i ] ) , sizeof ( xmlHashEntry ) ) ;\n table -> table [ key ] . next = NULL ;\n }\n for ( i = 0 ;\n i < oldsize ;\n i ++ ) {\n iter = oldtable [ i ] . next ;\n while ( iter ) {\n next = iter -> next ;\n key = xmlHashComputeKey ( table , iter -> name , iter -> name2 , iter -> name3 ) ;\n if ( table -> table [ key ] . valid == 0 ) {\n memcpy ( & ( table -> table [ key ] ) , iter , sizeof ( xmlHashEntry ) ) ;\n table -> table [ key ] . next = NULL ;\n xmlFree ( iter ) ;\n }\n else {\n iter -> next = table -> table [ key ] . next ;\n table -> table [ key ] . next = iter ;\n }\n # ifdef DEBUG_GROW nbElem ++ ;\n # endif iter = next ;\n }\n }\n xmlFree ( oldtable ) ;\n # ifdef DEBUG_GROW xmlGenericError ( xmlGenericErrorContext , \"xmlHashGrow : from %d to %d, %d elems\\n\" , oldsize , size , nbElem ) ;\n # endif return ( 0 ) ;\n }", "idx": 153}
{"hash": 3399746267815027606, "project": "debian", "size": 12, "label": 0, "functionSource": "static int amr_decode_fix_avctx ( AVCodecContext * avctx ) {\n const int is_amr_wb = 1 + ( avctx -> codec_id == AV_CODEC_ID_AMR_WB ) ;\n avctx -> sample_rate = 8000 * is_amr_wb ;\n if ( avctx -> channels > 1 ) {\n av_log_missing_feature ( avctx , \"multi-channel AMR\" , 0 ) ;\n return AVERROR_PATCHWELCOME ;\n }\n avctx -> channels = 1 ;\n avctx -> channel_layout = AV_CH_LAYOUT_MONO ;\n avctx -> sample_fmt = AV_SAMPLE_FMT_S16 ;\n return 0 ;\n }", "idx": 154}
{"hash": 1223258652239369123, "project": "debian", "size": 20, "label": 1, "functionSource": "static int spl_filesystem_file_is_empty_line ( spl_filesystem_object * intern TSRMLS_DC ) {\n if ( intern -> u . file . current_line ) {\n return intern -> u . file . current_line_len == 0 ;\n }\n else if ( intern -> u . file . current_zval ) {\n switch ( Z_TYPE_P ( intern -> u . file . current_zval ) ) {\n case IS_STRING : return Z_STRLEN_P ( intern -> u . file . current_zval ) == 0 ;\n case IS_ARRAY : if ( SPL_HAS_FLAG ( intern -> flags , SPL_FILE_OBJECT_READ_CSV ) && zend_hash_num_elements ( Z_ARRVAL_P ( intern -> u . file . current_zval ) ) == 1 ) {\n zval * * first = Z_ARRVAL_P ( intern -> u . file . current_zval ) -> pListHead -> pData ;\n return Z_TYPE_PP ( first ) == IS_STRING && Z_STRLEN_PP ( first ) == 0 ;\n }\n return zend_hash_num_elements ( Z_ARRVAL_P ( intern -> u . file . current_zval ) ) == 0 ;\n case IS_NULL : return 1 ;\n default : return 0 ;\n }\n }\n else {\n return 1 ;\n }\n }", "idx": 155}
{"hash": 2895622461494525400, "project": "debian", "size": 28, "label": 0, "functionSource": "static void test_wl4435_3 ( ) {\n char tmp [ 255 ] ;\n puts ( \"\" ) ;\n WL4435_TEST ( \"TINYINT\" , \"127\" , MYSQL_TYPE_TINY , MYSQL_TYPE_TINY , char , , ( \" - TINYINT / char / MYSQL_TYPE_TINY:\\t\\t\\t %d\" , ( int ) pspv ) , pspv == 127 ) ;\n WL4435_TEST ( \"SMALLINT\" , \"32767\" , MYSQL_TYPE_SHORT , MYSQL_TYPE_SHORT , short , , ( \" - SMALLINT / short / MYSQL_TYPE_SHORT:\\t\\t %d\" , ( int ) pspv ) , pspv == 32767 ) ;\n WL4435_TEST ( \"INT\" , \"2147483647\" , MYSQL_TYPE_LONG , MYSQL_TYPE_LONG , int , , ( \" - INT / int / MYSQL_TYPE_LONG:\\t\\t\\t %d\" , pspv ) , pspv == 2147483647l ) ;\n WL4435_TEST ( \"BIGINT\" , \"9223372036854775807\" , MYSQL_TYPE_LONGLONG , MYSQL_TYPE_LONGLONG , long long , , ( \" - BIGINT / long long / MYSQL_TYPE_LONGLONG:\\t\\t %lld\" , pspv ) , pspv == 9223372036854775807ll ) ;\n WL4435_TEST ( \"TIMESTAMP\" , \"'2007-11-18 15:01:02'\" , MYSQL_TYPE_TIMESTAMP , MYSQL_TYPE_TIMESTAMP , MYSQL_TIME , , ( \" - TIMESTAMP / MYSQL_TIME / MYSQL_TYPE_TIMESTAMP:\\t \" \"%.4d-%.2d-%.2d %.2d:%.2d:%.2d\" , ( int ) pspv . year , ( int ) pspv . month , ( int ) pspv . day , ( int ) pspv . hour , ( int ) pspv . minute , ( int ) pspv . second ) , pspv . year == 2007 && pspv . month == 11 && pspv . day == 18 && pspv . hour == 15 && pspv . minute == 1 && pspv . second == 2 ) ;\n WL4435_TEST ( \"DATETIME\" , \"'1234-11-12 12:34:59'\" , MYSQL_TYPE_DATETIME , MYSQL_TYPE_DATETIME , MYSQL_TIME , , ( \" - DATETIME / MYSQL_TIME / MYSQL_TYPE_DATETIME:\\t \" \"%.4d-%.2d-%.2d %.2d:%.2d:%.2d\" , ( int ) pspv . year , ( int ) pspv . month , ( int ) pspv . day , ( int ) pspv . hour , ( int ) pspv . minute , ( int ) pspv . second ) , pspv . year == 1234 && pspv . month == 11 && pspv . day == 12 && pspv . hour == 12 && pspv . minute == 34 && pspv . second == 59 ) ;\n WL4435_TEST ( \"TIME\" , \"'123:45:01'\" , MYSQL_TYPE_TIME , MYSQL_TYPE_TIME , MYSQL_TIME , , ( \" - TIME / MYSQL_TIME / MYSQL_TYPE_TIME:\\t\\t \" \"%.3d:%.2d:%.2d\" , ( int ) pspv . hour , ( int ) pspv . minute , ( int ) pspv . second ) , pspv . hour == 123 && pspv . minute == 45 && pspv . second == 1 ) ;\n WL4435_TEST ( \"DATE\" , \"'1234-11-12'\" , MYSQL_TYPE_DATE , MYSQL_TYPE_DATE , MYSQL_TIME , , ( \" - DATE / MYSQL_TIME / MYSQL_TYPE_DATE:\\t\\t \" \"%.4d-%.2d-%.2d\" , ( int ) pspv . year , ( int ) pspv . month , ( int ) pspv . day ) , pspv . year == 1234 && pspv . month == 11 && pspv . day == 12 ) ;\n WL4435_TEST ( \"YEAR\" , \"'2010'\" , MYSQL_TYPE_SHORT , MYSQL_TYPE_YEAR , short , , ( \" - YEAR / short / MYSQL_TYPE_SHORT:\\t\\t\\t %.4d\" , ( int ) pspv ) , pspv == 2010 ) ;\n WL4435_TEST ( \"FLOAT(7, 4)\" , \"123.4567\" , MYSQL_TYPE_FLOAT , MYSQL_TYPE_FLOAT , float , , ( \" - FLOAT / float / MYSQL_TYPE_FLOAT:\\t\\t\\t %g\" , ( double ) pspv ) , pspv - 123.4567 < 0.0001 ) ;\n WL4435_TEST ( \"DOUBLE(8, 5)\" , \"123.45678\" , MYSQL_TYPE_DOUBLE , MYSQL_TYPE_DOUBLE , double , , ( \" - DOUBLE / double / MYSQL_TYPE_DOUBLE:\\t\\t %g\" , ( double ) pspv ) , pspv - 123.45678 < 0.00001 ) ;\n WL4435_TEST ( \"DECIMAL(9, 6)\" , \"123.456789\" , MYSQL_TYPE_NEWDECIMAL , MYSQL_TYPE_NEWDECIMAL , char , [ 255 ] , ( \" - DECIMAL / char[] / MYSQL_TYPE_NEWDECIMAL:\\t\\t '%s'\" , ( char * ) pspv ) , ! strcmp ( pspv , \"123.456789\" ) ) ;\n WL4435_TEST ( \"CHAR(32)\" , \"REPEAT('C', 16)\" , MYSQL_TYPE_STRING , MYSQL_TYPE_STRING , char , [ 255 ] , ( \" - CHAR(32) / char[] / MYSQL_TYPE_STRING:\\t\\t '%s'\" , ( char * ) pspv ) , ! strcmp ( pspv , \"CCCCCCCCCCCCCCCC\" ) ) ;\n WL4435_TEST ( \"VARCHAR(32)\" , \"REPEAT('V', 16)\" , MYSQL_TYPE_VAR_STRING , MYSQL_TYPE_VAR_STRING , char , [ 255 ] , ( \" - VARCHAR(32) / char[] / MYSQL_TYPE_VAR_STRING:\\t '%s'\" , ( char * ) pspv ) , ! strcmp ( pspv , \"VVVVVVVVVVVVVVVV\" ) ) ;\n WL4435_TEST ( \"TINYTEXT\" , \"REPEAT('t', 16)\" , MYSQL_TYPE_TINY_BLOB , MYSQL_TYPE_BLOB , char , [ 255 ] , ( \" - TINYTEXT / char[] / MYSQL_TYPE_TINY_BLOB:\\t\\t '%s'\" , ( char * ) pspv ) , ! strcmp ( pspv , \"tttttttttttttttt\" ) ) ;\n WL4435_TEST ( \"TEXT\" , \"REPEAT('t', 16)\" , MYSQL_TYPE_BLOB , MYSQL_TYPE_BLOB , char , [ 255 ] , ( \" - TEXT / char[] / MYSQL_TYPE_BLOB:\\t\\t\\t '%s'\" , ( char * ) pspv ) , ! strcmp ( pspv , \"tttttttttttttttt\" ) ) ;\n WL4435_TEST ( \"MEDIUMTEXT\" , \"REPEAT('t', 16)\" , MYSQL_TYPE_MEDIUM_BLOB , MYSQL_TYPE_BLOB , char , [ 255 ] , ( \" - MEDIUMTEXT / char[] / MYSQL_TYPE_MEDIUM_BLOB:\\t '%s'\" , ( char * ) pspv ) , ! strcmp ( pspv , \"tttttttttttttttt\" ) ) ;\n WL4435_TEST ( \"LONGTEXT\" , \"REPEAT('t', 16)\" , MYSQL_TYPE_LONG_BLOB , MYSQL_TYPE_BLOB , char , [ 255 ] , ( \" - LONGTEXT / char[] / MYSQL_TYPE_LONG_BLOB:\\t\\t '%s'\" , ( char * ) pspv ) , ! strcmp ( pspv , \"tttttttttttttttt\" ) ) ;\n WL4435_TEST ( \"BINARY(32)\" , \"REPEAT('\\1', 16)\" , MYSQL_TYPE_STRING , MYSQL_TYPE_STRING , char , [ 255 ] , ( \" - BINARY(32) / char[] / MYSQL_TYPE_STRING:\\t\\t '%s'\" , ( char * ) pspv ) , memset ( tmp , 1 , 16 ) && ! memcmp ( tmp , pspv , 16 ) ) ;\n WL4435_TEST ( \"VARBINARY(32)\" , \"REPEAT('\\1', 16)\" , MYSQL_TYPE_VAR_STRING , MYSQL_TYPE_VAR_STRING , char , [ 255 ] , ( \" - VARBINARY(32) / char[] / MYSQL_TYPE_VAR_STRING:\\t '%s'\" , ( char * ) pspv ) , memset ( tmp , 1 , 16 ) && ! memcmp ( tmp , pspv , 16 ) ) ;\n WL4435_TEST ( \"TINYBLOB\" , \"REPEAT('\\2', 16)\" , MYSQL_TYPE_TINY_BLOB , MYSQL_TYPE_BLOB , char , [ 255 ] , ( \" - TINYBLOB / char[] / MYSQL_TYPE_TINY_BLOB:\\t\\t '%s'\" , ( char * ) pspv ) , memset ( tmp , 2 , 16 ) && ! memcmp ( tmp , pspv , 16 ) ) ;\n WL4435_TEST ( \"BLOB\" , \"REPEAT('\\2', 16)\" , MYSQL_TYPE_BLOB , MYSQL_TYPE_BLOB , char , [ 255 ] , ( \" - BLOB / char[] / MYSQL_TYPE_BLOB:\\t\\t\\t '%s'\" , ( char * ) pspv ) , memset ( tmp , 2 , 16 ) && ! memcmp ( tmp , pspv , 16 ) ) ;\n WL4435_TEST ( \"MEDIUMBLOB\" , \"REPEAT('\\2', 16)\" , MYSQL_TYPE_MEDIUM_BLOB , MYSQL_TYPE_BLOB , char , [ 255 ] , ( \" - MEDIUMBLOB / char[] / MYSQL_TYPE_MEDIUM_BLOB:\\t '%s'\" , ( char * ) pspv ) , memset ( tmp , 2 , 16 ) && ! memcmp ( tmp , pspv , 16 ) ) ;\n WL4435_TEST ( \"LONGBLOB\" , \"REPEAT('\\2', 16)\" , MYSQL_TYPE_LONG_BLOB , MYSQL_TYPE_BLOB , char , [ 255 ] , ( \" - LONGBLOB / char[] / MYSQL_TYPE_LONG_BLOB:\\t\\t '%s'\" , ( char * ) pspv ) , memset ( tmp , 2 , 16 ) && ! memcmp ( tmp , pspv , 16 ) ) ;\n }", "idx": 156}
{"hash": 5651124822185017997, "project": "debian", "size": 38, "label": 0, "functionSource": "static VALUE ossl_x509name_to_a ( VALUE self ) {\n X509_NAME * name ;\n X509_NAME_ENTRY * entry ;\n int i , entries , nid ;\n char long_name [ 512 ] ;\n const char * short_name ;\n VALUE ary , vname , ret ;\n ASN1_STRING * value ;\n GetX509Name ( self , name ) ;\n entries = X509_NAME_entry_count ( name ) ;\n if ( entries < 0 ) {\n OSSL_Debug ( \"name entries < 0!\" ) ;\n return rb_ary_new ( ) ;\n }\n ret = rb_ary_new2 ( entries ) ;\n for ( i = 0 ;\n i < entries ;\n i ++ ) {\n if ( ! ( entry = X509_NAME_get_entry ( name , i ) ) ) {\n ossl_raise ( eX509NameError , NULL ) ;\n }\n if ( ! i2t_ASN1_OBJECT ( long_name , sizeof ( long_name ) , X509_NAME_ENTRY_get_object ( entry ) ) ) {\n ossl_raise ( eX509NameError , NULL ) ;\n }\n nid = OBJ_ln2nid ( long_name ) ;\n if ( nid == NID_undef ) {\n vname = rb_str_new2 ( ( const char * ) & long_name ) ;\n }\n else {\n short_name = OBJ_nid2sn ( nid ) ;\n vname = rb_str_new2 ( short_name ) ;\n }\n value = X509_NAME_ENTRY_get_data ( entry ) ;\n ary = rb_ary_new3 ( 3 , vname , asn1str_to_str ( value ) , INT2NUM ( value -> type ) ) ;\n rb_ary_push ( ret , ary ) ;\n }\n return ret ;\n }", "idx": 157}
{"hash": 927123821003322045, "project": "chrome", "size": 10, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( PageLoadMetricsBrowserTest , ChromeErrorPage ) {\n ASSERT_TRUE ( embedded_test_server ( ) -> Start ( ) ) ;\n GURL url = embedded_test_server ( ) -> GetURL ( \"/title1.html\" ) ;\n ASSERT_TRUE ( embedded_test_server ( ) -> ShutdownAndWaitUntilComplete ( ) ) ;\n content : : NavigationHandleObserver observer ( browser ( ) -> tab_strip_model ( ) -> GetActiveWebContents ( ) , url ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , url ) ;\n ASSERT_TRUE ( observer . is_error ( ) ) ;\n NavigateToUntrackedUrl ( ) ;\n EXPECT_TRUE ( NoPageLoadMetricsRecorded ( ) ) << \"Recorded metrics: \" << GetRecordedPageLoadMetricNames ( ) ;\n }", "idx": 158}
{"hash": -6986708248145981986, "project": "debian", "size": 13, "label": 0, "functionSource": "static int alloc_tl_data ( krb5_int16 n_tl_data , krb5_tl_data * * tldp ) {\n krb5_tl_data * * tlp = tldp ;\n int i ;\n for ( i = 0 ;\n i < n_tl_data ;\n i ++ ) {\n * tlp = calloc ( 1 , sizeof ( krb5_tl_data ) ) ;\n if ( * tlp == NULL ) return ENOMEM ;\n memset ( * tlp , 0 , sizeof ( krb5_tl_data ) ) ;\n tlp = & ( ( * tlp ) -> tl_data_next ) ;\n }\n return 0 ;\n }", "idx": 159}
{"hash": 313627013719508831, "project": "debian", "size": 3, "label": 0, "functionSource": "static inline PixelTrait GetPixelCrTraits ( const Image * restrict image ) {\n return ( image -> channel_map [ CrPixelChannel ] . traits ) ;\n }", "idx": 160}
{"hash": -3165961362620712443, "project": "chrome", "size": 10, "label": 0, "functionSource": "static void initial_reordering_syllable ( const hb_ot_shape_plan_t * plan , hb_face_t * face , hb_buffer_t * buffer , unsigned int start , unsigned int end ) {\n syllable_type_t syllable_type = ( syllable_type_t ) ( buffer -> info [ start ] . syllable ( ) & 0x0F ) ;\n switch ( syllable_type ) {\n case vowel_syllable : case consonant_syllable : initial_reordering_consonant_syllable ( plan , face , buffer , start , end ) ;\n break ;\n case broken_cluster : case standalone_cluster : initial_reordering_standalone_cluster ( plan , face , buffer , start , end ) ;\n break ;\n case symbol_cluster : case non_indic_cluster : break ;\n }\n }", "idx": 161}
{"hash": 6393050609822897742, "project": "debian", "size": 28, "label": 0, "functionSource": "static XHCIStreamContext * xhci_find_stream ( XHCIEPContext * epctx , unsigned int streamid , uint32_t * cc_error ) {\n XHCIStreamContext * sctx ;\n dma_addr_t base ;\n uint32_t ctx [ 2 ] , sct ;\n assert ( streamid != 0 ) ;\n if ( epctx -> lsa ) {\n if ( streamid >= epctx -> nr_pstreams ) {\n * cc_error = CC_INVALID_STREAM_ID_ERROR ;\n return NULL ;\n }\n sctx = epctx -> pstreams + streamid ;\n }\n else {\n FIXME ( \"secondary streams not implemented yet\" ) ;\n }\n if ( sctx -> sct == - 1 ) {\n xhci_dma_read_u32s ( epctx -> xhci , sctx -> pctx , ctx , sizeof ( ctx ) ) ;\n sct = ( ctx [ 0 ] >> 1 ) & 0x07 ;\n if ( epctx -> lsa && sct != 1 ) {\n * cc_error = CC_INVALID_STREAM_TYPE_ERROR ;\n return NULL ;\n }\n sctx -> sct = sct ;\n base = xhci_addr64 ( ctx [ 0 ] & ~ 0xf , ctx [ 1 ] ) ;\n xhci_ring_init ( epctx -> xhci , & sctx -> ring , base ) ;\n }\n return sctx ;\n }", "idx": 162}
{"hash": 1742637512846796448, "project": "debian", "size": 73, "label": 0, "functionSource": "static int dissect_mac_fdd_rach ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , void * data ) {\n guint8 tctf ;\n guint8 chan ;\n guint16 bitoffs = 0 ;\n tvbuff_t * next_tvb ;\n proto_tree * rach_tree = NULL ;\n proto_item * channel_type ;\n umts_mac_info * macinf ;\n fp_info * fpinf ;\n rlc_info * rlcinf ;\n proto_item * ti = NULL ;\n guint8 c_t ;\n tctf = tvb_get_bits8 ( tvb , 0 , 2 ) ;\n bitoffs += 2 ;\n col_set_str ( pinfo -> cinfo , COL_PROTOCOL , \"MAC\" ) ;\n col_set_str ( pinfo -> cinfo , COL_INFO , val_to_str_const ( tctf , rach_fdd_tctf_vals , \"Unknown TCTF\" ) ) ;\n ti = proto_tree_add_item ( tree , proto_umts_mac , tvb , 0 , - 1 , ENC_NA ) ;\n rach_tree = proto_item_add_subtree ( ti , ett_mac_rach ) ;\n macinf = ( umts_mac_info * ) p_get_proto_data ( wmem_file_scope ( ) , pinfo , proto_umts_mac , 0 ) ;\n fpinf = ( fp_info * ) p_get_proto_data ( wmem_file_scope ( ) , pinfo , proto_fp , 0 ) ;\n rlcinf = ( rlc_info * ) p_get_proto_data ( wmem_file_scope ( ) , pinfo , proto_rlc , 0 ) ;\n if ( ! macinf || ! fpinf ) {\n proto_tree_add_expert ( rach_tree , pinfo , & ei_mac_per_frame_info_missing , tvb , 0 , - 1 ) ;\n return 1 ;\n }\n proto_tree_add_bits_item ( rach_tree , hf_mac_rach_fdd_tctf , tvb , 0 , 2 , ENC_BIG_ENDIAN ) ;\n if ( tctf == TCTF_DCCH_DTCH_RACH_FDD ) {\n macinf -> ctmux [ fpinf -> cur_tb ] = 1 ;\n bitoffs = tree_add_common_dcch_dtch_fields ( tvb , pinfo , rach_tree , bitoffs , fpinf , macinf , rlcinf ) ;\n }\n chan = fpinf -> cur_chan ;\n switch ( tctf ) {\n case TCTF_CCCH_RACH_FDD : proto_item_append_text ( ti , \" (CCCH)\" ) ;\n channel_type = proto_tree_add_uint ( rach_tree , hf_mac_channel , tvb , 0 , 0 , MAC_CCCH ) ;\n PROTO_ITEM_SET_GENERATED ( channel_type ) ;\n next_tvb = tvb_new_octet_aligned ( tvb , bitoffs , fpinf -> chan_tf_size [ chan ] - bitoffs ) ;\n add_new_data_source ( pinfo , next_tvb , \"Octet-Aligned CCCH Data\" ) ;\n call_dissector_with_data ( rlc_ccch_handle , next_tvb , pinfo , tree , data ) ;\n break ;\n case TCTF_DCCH_DTCH_RACH_FDD : c_t = tvb_get_bits8 ( tvb , bitoffs - 4 , 4 ) ;\n if ( c_t == 15 ) {\n expert_add_info ( pinfo , NULL , & ei_mac_reserved_c_t ) ;\n break ;\n }\n rlcinf -> mode [ chan ] = lchId_rlc_map [ c_t + 1 ] ;\n macinf -> content [ chan ] = lchId_type_table [ c_t + 1 ] ;\n rlcinf -> rbid [ chan ] = c_t + 1 ;\n switch ( macinf -> content [ chan ] ) {\n case MAC_CONTENT_DCCH : proto_item_append_text ( ti , \" (DCCH)\" ) ;\n channel_type = proto_tree_add_uint ( rach_tree , hf_mac_channel , tvb , 0 , 0 , MAC_DCCH ) ;\n PROTO_ITEM_SET_GENERATED ( channel_type ) ;\n next_tvb = tvb_new_octet_aligned ( tvb , bitoffs , fpinf -> chan_tf_size [ chan ] - bitoffs ) ;\n add_new_data_source ( pinfo , next_tvb , \"Octet-Aligned DCCH Data\" ) ;\n call_dissector_with_data ( rlc_dcch_handle , next_tvb , pinfo , tree , data ) ;\n break ;\n case MAC_CONTENT_PS_DTCH : proto_item_append_text ( ti , \" (PS DTCH)\" ) ;\n channel_type = proto_tree_add_uint ( rach_tree , hf_mac_channel , tvb , 0 , 0 , MAC_DTCH ) ;\n PROTO_ITEM_SET_GENERATED ( channel_type ) ;\n next_tvb = tvb_new_octet_aligned ( tvb , bitoffs , fpinf -> chan_tf_size [ chan ] - bitoffs ) ;\n add_new_data_source ( pinfo , next_tvb , \"Octet-Aligned DTCH Data\" ) ;\n call_dissector_with_data ( rlc_ps_dtch_handle , next_tvb , pinfo , tree , data ) ;\n break ;\n case MAC_CONTENT_CS_DTCH : proto_item_append_text ( ti , \" (CS DTCH)\" ) ;\n break ;\n default : proto_item_append_text ( ti , \" (Unknown RACH DCCH/DTCH Content)\" ) ;\n expert_add_info_format ( pinfo , NULL , & ei_mac_unknown_content , \"Unknown RACH DCCH/DTCH Content\" ) ;\n }\n break ;\n default : proto_item_append_text ( ti , \" (Unknown RACH TCTF)\" ) ;\n expert_add_info_format ( pinfo , NULL , & ei_mac_rach_tctf_unknown , \"Unknown RACH TCTF\" ) ;\n }\n return tvb_captured_length ( tvb ) ;\n }", "idx": 163}
{"hash": -2964264153308487898, "project": "debian", "size": 115, "label": 0, "functionSource": "static MagickBooleanType load_tile_rle ( Image * image , Image * tile_image , XCFDocInfo * inDocInfo , XCFLayerInfo * inLayerInfo , size_t data_length , ExceptionInfo * exception ) {\n MagickOffsetType size ;\n Quantum alpha ;\n register Quantum * q ;\n size_t length ;\n ssize_t bytes_per_pixel , count , i , j ;\n unsigned char data , pixel , * xcfdata , * xcfodata , * xcfdatalimit ;\n bytes_per_pixel = ( ssize_t ) inDocInfo -> bytes_per_pixel ;\n xcfdata = ( unsigned char * ) AcquireQuantumMemory ( data_length , sizeof ( * xcfdata ) ) ;\n if ( xcfdata == ( unsigned char * ) NULL ) ThrowBinaryException ( ResourceLimitError , \"MemoryAllocationFailed\" , image -> filename ) ;\n xcfodata = xcfdata ;\n count = ReadBlob ( image , ( size_t ) data_length , xcfdata ) ;\n xcfdatalimit = xcfodata + count - 1 ;\n alpha = ScaleCharToQuantum ( ( unsigned char ) inLayerInfo -> alpha ) ;\n for ( i = 0 ;\n i < ( ssize_t ) bytes_per_pixel ;\n i ++ ) {\n q = GetAuthenticPixels ( tile_image , 0 , 0 , tile_image -> columns , tile_image -> rows , exception ) ;\n if ( q == ( Quantum * ) NULL ) continue ;\n size = ( MagickOffsetType ) tile_image -> rows * tile_image -> columns ;\n while ( size > 0 ) {\n if ( xcfdata > xcfdatalimit ) goto bogus_rle ;\n pixel = ( * xcfdata ++ ) ;\n length = ( size_t ) pixel ;\n if ( length >= 128 ) {\n length = 255 - ( length - 1 ) ;\n if ( length == 128 ) {\n if ( xcfdata >= xcfdatalimit ) goto bogus_rle ;\n length = ( size_t ) ( ( * xcfdata << 8 ) + xcfdata [ 1 ] ) ;\n xcfdata += 2 ;\n }\n size -= length ;\n if ( size < 0 ) goto bogus_rle ;\n if ( & xcfdata [ length - 1 ] > xcfdatalimit ) goto bogus_rle ;\n while ( length -- > 0 ) {\n data = ( * xcfdata ++ ) ;\n switch ( i ) {\n case 0 : {\n if ( inDocInfo -> image_type == GIMP_GRAY ) SetPixelGray ( tile_image , ScaleCharToQuantum ( data ) , q ) ;\n else {\n SetPixelRed ( tile_image , ScaleCharToQuantum ( data ) , q ) ;\n SetPixelGreen ( tile_image , ScaleCharToQuantum ( data ) , q ) ;\n SetPixelBlue ( tile_image , ScaleCharToQuantum ( data ) , q ) ;\n }\n SetPixelAlpha ( tile_image , alpha , q ) ;\n break ;\n }\n case 1 : {\n if ( inDocInfo -> image_type == GIMP_GRAY ) SetPixelAlpha ( tile_image , ScaleCharToQuantum ( data ) , q ) ;\n else SetPixelGreen ( tile_image , ScaleCharToQuantum ( data ) , q ) ;\n break ;\n }\n case 2 : {\n SetPixelBlue ( tile_image , ScaleCharToQuantum ( data ) , q ) ;\n break ;\n }\n case 3 : {\n SetPixelAlpha ( tile_image , ScaleCharToQuantum ( data ) , q ) ;\n break ;\n }\n }\n q += GetPixelChannels ( tile_image ) ;\n }\n }\n else {\n length += 1 ;\n if ( length == 128 ) {\n if ( xcfdata >= xcfdatalimit ) goto bogus_rle ;\n length = ( size_t ) ( ( * xcfdata << 8 ) + xcfdata [ 1 ] ) ;\n xcfdata += 2 ;\n }\n size -= length ;\n if ( size < 0 ) goto bogus_rle ;\n if ( xcfdata > xcfdatalimit ) goto bogus_rle ;\n pixel = ( * xcfdata ++ ) ;\n for ( j = 0 ;\n j < ( ssize_t ) length ;\n j ++ ) {\n data = pixel ;\n switch ( i ) {\n case 0 : {\n if ( inDocInfo -> image_type == GIMP_GRAY ) SetPixelGray ( tile_image , ScaleCharToQuantum ( data ) , q ) ;\n else {\n SetPixelRed ( tile_image , ScaleCharToQuantum ( data ) , q ) ;\n SetPixelGreen ( tile_image , ScaleCharToQuantum ( data ) , q ) ;\n SetPixelBlue ( tile_image , ScaleCharToQuantum ( data ) , q ) ;\n }\n SetPixelAlpha ( tile_image , alpha , q ) ;\n break ;\n }\n case 1 : {\n if ( inDocInfo -> image_type == GIMP_GRAY ) SetPixelAlpha ( tile_image , ScaleCharToQuantum ( data ) , q ) ;\n else SetPixelGreen ( tile_image , ScaleCharToQuantum ( data ) , q ) ;\n break ;\n }\n case 2 : {\n SetPixelBlue ( tile_image , ScaleCharToQuantum ( data ) , q ) ;\n break ;\n }\n case 3 : {\n SetPixelAlpha ( tile_image , ScaleCharToQuantum ( data ) , q ) ;\n break ;\n }\n }\n q += GetPixelChannels ( tile_image ) ;\n }\n }\n }\n if ( SyncAuthenticPixels ( tile_image , exception ) == MagickFalse ) break ;\n }\n xcfodata = ( unsigned char * ) RelinquishMagickMemory ( xcfodata ) ;\n return ( MagickTrue ) ;\n bogus_rle : if ( xcfodata != ( unsigned char * ) NULL ) xcfodata = ( unsigned char * ) RelinquishMagickMemory ( xcfodata ) ;\n return ( MagickFalse ) ;\n }", "idx": 164}
{"hash": -1672864273235910388, "project": "debian", "size": 38, "label": 0, "functionSource": "static void _slurm_rpc_update_partition ( slurm_msg_t * msg ) {\n int error_code = SLURM_SUCCESS ;\n DEF_TIMERS ;\n update_part_msg_t * part_desc_ptr = ( update_part_msg_t * ) msg -> data ;\n slurmctld_lock_t part_write_lock = {\n READ_LOCK , WRITE_LOCK , READ_LOCK , WRITE_LOCK , NO_LOCK }\n ;\n uid_t uid = g_slurm_auth_get_uid ( msg -> auth_cred , slurmctld_config . auth_info ) ;\n START_TIMER ;\n debug2 ( \"Processing RPC: REQUEST_UPDATE_PARTITION from uid=%d\" , uid ) ;\n if ( ! validate_super_user ( uid ) ) {\n error_code = ESLURM_USER_ID_MISSING ;\n error ( \"Security violation, UPDATE_PARTITION RPC from uid=%d\" , uid ) ;\n }\n if ( error_code == SLURM_SUCCESS ) {\n if ( msg -> msg_type == REQUEST_CREATE_PARTITION ) {\n lock_slurmctld ( part_write_lock ) ;\n error_code = update_part ( part_desc_ptr , true ) ;\n unlock_slurmctld ( part_write_lock ) ;\n }\n else {\n lock_slurmctld ( part_write_lock ) ;\n error_code = update_part ( part_desc_ptr , false ) ;\n unlock_slurmctld ( part_write_lock ) ;\n }\n END_TIMER2 ( \"_slurm_rpc_update_partition\" ) ;\n }\n if ( error_code ) {\n info ( \"_slurm_rpc_update_partition partition=%s: %s\" , part_desc_ptr -> name , slurm_strerror ( error_code ) ) ;\n slurm_send_rc_msg ( msg , error_code ) ;\n }\n else {\n debug2 ( \"_slurm_rpc_update_partition complete for %s %s\" , part_desc_ptr -> name , TIME_STR ) ;\n slurm_send_rc_msg ( msg , SLURM_SUCCESS ) ;\n schedule_part_save ( ) ;\n queue_job_scheduler ( ) ;\n }\n }", "idx": 165}
{"hash": 2709342705526909410, "project": "debian", "size": 42, "label": 0, "functionSource": "int ssl_get_client_min_max_version ( const SSL * s , int * min_version , int * max_version ) {\n int version ;\n int hole ;\n const SSL_METHOD * single = NULL ;\n const SSL_METHOD * method ;\n const version_info * table ;\n const version_info * vent ;\n switch ( s -> method -> version ) {\n default : * min_version = * max_version = s -> version ;\n return 0 ;\n case TLS_ANY_VERSION : table = tls_version_table ;\n break ;\n case DTLS_ANY_VERSION : table = dtls_version_table ;\n break ;\n }\n * min_version = version = 0 ;\n hole = 1 ;\n for ( vent = table ;\n vent -> version != 0 ;\n ++ vent ) {\n if ( vent -> cmeth == NULL ) {\n hole = 1 ;\n continue ;\n }\n method = vent -> cmeth ( ) ;\n if ( ssl_method_error ( s , method ) != 0 ) {\n hole = 1 ;\n }\n else if ( ! hole ) {\n single = NULL ;\n * min_version = method -> version ;\n }\n else {\n version = ( single = method ) -> version ;\n * min_version = version ;\n hole = 0 ;\n }\n }\n * max_version = version ;\n if ( version == 0 ) return SSL_R_NO_PROTOCOLS_AVAILABLE ;\n return 0 ;\n }", "idx": 166}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_T_conferenceIDResponse ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_T_conferenceIDResponse , T_conferenceIDResponse_sequence ) ;\n return offset ;\n }", "idx": 167}
{"hash": 1202634027547122397, "project": "debian", "size": 31, "label": 0, "functionSource": "static int kex_agree_comp ( LIBSSH2_SESSION * session , libssh2_endpoint_data * endpoint , unsigned char * comp , unsigned long comp_len ) {\n const LIBSSH2_COMP_METHOD * * compp = _libssh2_comp_methods ( session ) ;\n unsigned char * s ;\n ( void ) session ;\n if ( endpoint -> comp_prefs ) {\n s = ( unsigned char * ) endpoint -> comp_prefs ;\n while ( s && * s ) {\n unsigned char * p = ( unsigned char * ) strchr ( ( char * ) s , ',' ) ;\n size_t method_len = ( p ? ( size_t ) ( p - s ) : strlen ( ( char * ) s ) ) ;\n if ( kex_agree_instr ( comp , comp_len , s , method_len ) ) {\n const LIBSSH2_COMP_METHOD * method = ( const LIBSSH2_COMP_METHOD * ) kex_get_method_by_name ( ( char * ) s , method_len , ( const LIBSSH2_COMMON_METHOD * * ) compp ) ;\n if ( ! method ) {\n return - 1 ;\n }\n endpoint -> comp = method ;\n return 0 ;\n }\n s = p ? p + 1 : NULL ;\n }\n return - 1 ;\n }\n while ( * compp && ( * compp ) -> name ) {\n s = kex_agree_instr ( comp , comp_len , ( unsigned char * ) ( * compp ) -> name , strlen ( ( * compp ) -> name ) ) ;\n if ( s ) {\n endpoint -> comp = * compp ;\n return 0 ;\n }\n compp ++ ;\n }\n return - 1 ;\n }", "idx": 168}
{"hash": 2578089348587614328, "project": "debian", "size": 3, "label": 0, "functionSource": "int i2d_PKCS8_fp ( FILE * fp , X509_SIG * p8 ) {\n return ASN1_i2d_fp_of ( X509_SIG , i2d_X509_SIG , fp , p8 ) ;\n }", "idx": 169}
{"hash": -8365810778652022218, "project": "debian", "size": 8, "label": 0, "functionSource": "static void virtio_net_set_link_status ( VLANClientState * nc ) {\n VirtIONet * n = DO_UPCAST ( NICState , nc , nc ) -> opaque ;\n uint16_t old_status = n -> status ;\n if ( nc -> link_down ) n -> status &= ~ VIRTIO_NET_S_LINK_UP ;\n else n -> status |= VIRTIO_NET_S_LINK_UP ;\n if ( n -> status != old_status ) virtio_notify_config ( & n -> vdev ) ;\n virtio_net_set_status ( & n -> vdev , n -> vdev . status ) ;\n }", "idx": 170}
{"hash": -8028756826159773630, "project": "debian", "size": 26, "label": 0, "functionSource": "static void _doSetFixedOutputState ( ArchiveHandle * AH ) {\n RestoreOptions * ropt = AH -> public . ropt ;\n ahprintf ( AH , \"SET statement_timeout = 0;\n\\n\" ) ;\n ahprintf ( AH , \"SET lock_timeout = 0;\n\\n\" ) ;\n ahprintf ( AH , \"SET idle_in_transaction_session_timeout = 0;\n\\n\" ) ;\n ahprintf ( AH , \"SET client_encoding = '%s';\n\\n\" , pg_encoding_to_char ( AH -> public . encoding ) ) ;\n ahprintf ( AH , \"SET standard_conforming_strings = %s;\n\\n\" , AH -> public . std_strings ? \"on\" : \"off\" ) ;\n if ( ropt && ropt -> use_role ) ahprintf ( AH , \"SET ROLE %s;\n\\n\" , fmtId ( ropt -> use_role ) ) ;\n ahprintf ( AH , \"SET check_function_bodies = false;\n\\n\" ) ;\n ahprintf ( AH , \"SET client_min_messages = warning;\n\\n\" ) ;\n if ( ! AH -> public . std_strings ) ahprintf ( AH , \"SET escape_string_warning = off;\n\\n\" ) ;\n if ( ropt && ropt -> enable_row_security ) ahprintf ( AH , \"SET row_security = on;\n\\n\" ) ;\n else ahprintf ( AH , \"SET row_security = off;\n\\n\" ) ;\n ahprintf ( AH , \"\\n\" ) ;\n }", "idx": 171}
{"hash": -2607754285145856562, "project": "debian", "size": 22, "label": 0, "functionSource": "static void _isoent_file_location ( struct iso9660 * iso9660 , struct isoent * isoent , int * symlocation ) {\n struct isoent * * children ;\n int n ;\n if ( isoent -> children . cnt == 0 ) return ;\n children = isoent -> children_sorted ;\n for ( n = 0 ;\n n < isoent -> children . cnt ;\n n ++ ) {\n struct isoent * np ;\n struct isofile * file ;\n np = children [ n ] ;\n if ( np -> dir ) continue ;\n if ( np == iso9660 -> el_torito . boot ) continue ;\n file = np -> file ;\n if ( file -> boot || file -> hardlink_target != NULL ) continue ;\n if ( archive_entry_filetype ( file -> entry ) == AE_IFLNK || file -> content . size == 0 ) {\n file -> content . location = ( * symlocation ) -- ;\n continue ;\n }\n file -> write_content = 1 ;\n }\n }", "idx": 172}
{"hash": 6790518433053241091, "project": "debian", "size": 12, "label": 0, "functionSource": "static void join_print_po ( struct packet_object * po ) {\n int ret ;\n if ( ! data_window ) return ;\n if ( GBL_OPTIONS -> regex && regexec ( GBL_OPTIONS -> regex , po -> DATA . disp_data , 0 , NULL , 0 ) != 0 ) {\n return ;\n }\n SAFE_REALLOC ( dispbuf , hex_len ( po -> DATA . disp_len ) * sizeof ( u_char ) + 1 ) ;\n ret = GBL_FORMAT ( po -> DATA . disp_data , po -> DATA . disp_len , dispbuf ) ;\n dispbuf [ ret ] = 0 ;\n if ( ! ip_addr_cmp ( & po -> L3 . src , & curr_conn -> L3_addr1 ) ) gtkui_data_print ( 3 , dispbuf , 1 ) ;\n else gtkui_data_print ( 3 , dispbuf , 2 ) ;\n }", "idx": 173}
{"hash": -9166093589752902240, "project": "chrome", "size": 88, "label": 0, "functionSource": "static int32_t doWriteReverse ( const UChar * src , int32_t srcLength , UChar * dest , int32_t destSize , uint16_t options , UErrorCode * pErrorCode ) {\n int32_t i , j ;\n UChar32 c ;\n switch ( options & ( UBIDI_REMOVE_BIDI_CONTROLS | UBIDI_DO_MIRRORING | UBIDI_KEEP_BASE_COMBINING ) ) {\n case 0 : if ( destSize < srcLength ) {\n * pErrorCode = U_BUFFER_OVERFLOW_ERROR ;\n return srcLength ;\n }\n destSize = srcLength ;\n do {\n i = srcLength ;\n U16_BACK_1 ( src , 0 , srcLength ) ;\n j = srcLength ;\n do {\n * dest ++ = src [ j ++ ] ;\n }\n while ( j < i ) ;\n }\n while ( srcLength > 0 ) ;\n break ;\n case UBIDI_KEEP_BASE_COMBINING : if ( destSize < srcLength ) {\n * pErrorCode = U_BUFFER_OVERFLOW_ERROR ;\n return srcLength ;\n }\n destSize = srcLength ;\n do {\n i = srcLength ;\n do {\n U16_PREV ( src , 0 , srcLength , c ) ;\n }\n while ( srcLength > 0 && IS_COMBINING ( u_charType ( c ) ) ) ;\n j = srcLength ;\n do {\n * dest ++ = src [ j ++ ] ;\n }\n while ( j < i ) ;\n }\n while ( srcLength > 0 ) ;\n break ;\n default : if ( ! ( options & UBIDI_REMOVE_BIDI_CONTROLS ) ) {\n i = srcLength ;\n }\n else {\n int32_t length = srcLength ;\n UChar ch ;\n i = 0 ;\n do {\n ch = * src ++ ;\n if ( ! IS_BIDI_CONTROL_CHAR ( ch ) ) {\n ++ i ;\n }\n }\n while ( -- length > 0 ) ;\n src -= srcLength ;\n }\n if ( destSize < i ) {\n * pErrorCode = U_BUFFER_OVERFLOW_ERROR ;\n return i ;\n }\n destSize = i ;\n do {\n i = srcLength ;\n U16_PREV ( src , 0 , srcLength , c ) ;\n if ( options & UBIDI_KEEP_BASE_COMBINING ) {\n while ( srcLength > 0 && IS_COMBINING ( u_charType ( c ) ) ) {\n U16_PREV ( src , 0 , srcLength , c ) ;\n }\n }\n if ( options & UBIDI_REMOVE_BIDI_CONTROLS && IS_BIDI_CONTROL_CHAR ( c ) ) {\n continue ;\n }\n j = srcLength ;\n if ( options & UBIDI_DO_MIRRORING ) {\n int32_t k = 0 ;\n c = u_charMirror ( c ) ;\n U16_APPEND_UNSAFE ( dest , k , c ) ;\n dest += k ;\n j += k ;\n }\n while ( j < i ) {\n * dest ++ = src [ j ++ ] ;\n }\n }\n while ( srcLength > 0 ) ;\n break ;\n }\n return destSize ;\n }", "idx": 174}
{"hash": -6063487367164326236, "project": "debian", "size": 3, "label": 0, "functionSource": "WRITE_CLASS_ENCODER ( EntityAuth ) static inline ostream & operator << ( ostream & out , const EntityAuth & a ) {\n return out << \"auth(auid = \" << a . auid << \" key=\" << a . key << \" with \" << a . caps . size ( ) << \" caps)\" ;\n }", "idx": 175}
{"hash": 3649198920984613385, "project": "debian", "size": 6, "label": 0, "functionSource": "static void vmsvga_text_update ( void * opaque , console_ch_t * chardata ) {\n struct vmsvga_state_s * s = opaque ;\n if ( s -> vga . hw_ops -> text_update ) {\n s -> vga . hw_ops -> text_update ( & s -> vga , chardata ) ;\n }\n }", "idx": 176}
{"hash": 1182028467273264883, "project": "debian", "size": 6, "label": 0, "functionSource": "char * re_eprint ( int err ) {\n static char epbuf [ 100 ] ;\n size_t len __attribute__ ( ( unused ) ) = my_regerror ( REG_ITOA | err , ( my_regex_t * ) NULL , epbuf , sizeof ( epbuf ) ) ;\n assert ( len <= sizeof ( epbuf ) ) ;\n return ( epbuf ) ;\n }", "idx": 177}
{"hash": -5992472514718425579, "project": "debian", "size": 6, "label": 0, "functionSource": "static void lxc_cgroup_mount_point_free ( struct cgroup_mount_point * mp ) {\n if ( ! mp ) return ;\n free ( mp -> mount_point ) ;\n free ( mp -> mount_prefix ) ;\n free ( mp ) ;\n }", "idx": 178}
{"hash": 5918484636148310736, "project": "debian", "size": 7, "label": 0, "functionSource": "int gdev_mem_data_size ( const gx_device_memory * dev , int width , int height , ulong * psize ) {\n ulong bits_size ;\n ulong line_ptrs_size = gdev_mem_line_ptrs_size ( dev , width , height ) ;\n if ( gdev_mem_bits_size ( dev , width , height , & bits_size ) < 0 || bits_size > max_ulong - line_ptrs_size ) return_error ( gs_error_VMerror ) ;\n * psize = bits_size + line_ptrs_size ;\n return 0 ;\n }", "idx": 179}
{"hash": -2423144171479606949, "project": "debian", "size": 6, "label": 0, "functionSource": "static void pdf_run_CS ( fz_context * ctx , pdf_processor * proc , const char * name , fz_colorspace * colorspace ) {\n pdf_run_processor * pr = ( pdf_run_processor * ) proc ;\n pr -> dev -> flags &= ~ FZ_DEVFLAG_STROKECOLOR_UNDEFINED ;\n if ( ! strcmp ( name , \"Pattern\" ) ) pdf_set_pattern ( ctx , pr , PDF_STROKE , NULL , NULL ) ;\n else pdf_set_colorspace ( ctx , pr , PDF_STROKE , colorspace ) ;\n }", "idx": 180}
{"hash": -6529313662352494663, "project": "debian", "size": 46, "label": 0, "functionSource": "void gdev_x_clear_window ( gx_device_X * xdev ) {\n if ( ! xdev -> ghostview ) {\n if ( xdev -> useBackingPixmap ) {\n if ( xdev -> bpixmap == 0 ) {\n x_error_handler . oldhandler = XSetErrorHandler ( x_catch_alloc ) ;\n x_error_handler . alloc_error = False ;\n xdev -> bpixmap = XCreatePixmap ( xdev -> dpy , xdev -> win , xdev -> width , xdev -> height , xdev -> vinfo -> depth ) ;\n XSync ( xdev -> dpy , False ) ;\n if ( x_error_handler . alloc_error ) {\n xdev -> useBackingPixmap = False ;\n # ifdef DEBUG emprintf ( xdev -> memory , \"Warning: Failed to allocated backing pixmap.\\n\" ) ;\n # endif if ( xdev -> bpixmap ) {\n XFreePixmap ( xdev -> dpy , xdev -> bpixmap ) ;\n xdev -> bpixmap = None ;\n XSync ( xdev -> dpy , False ) ;\n }\n }\n x_error_handler . oldhandler = XSetErrorHandler ( x_error_handler . oldhandler ) ;\n }\n }\n else {\n if ( xdev -> bpixmap != 0 ) {\n XFreePixmap ( xdev -> dpy , xdev -> bpixmap ) ;\n xdev -> bpixmap = ( Pixmap ) 0 ;\n }\n }\n }\n x_set_buffer ( xdev ) ;\n if ( xdev -> dest == ( Pixmap ) 0 ) {\n xdev -> dest = ( xdev -> bpixmap != ( Pixmap ) 0 ? xdev -> bpixmap : ( Pixmap ) xdev -> win ) ;\n }\n if ( xdev -> dest != ( Pixmap ) 0 ) {\n XSetForeground ( xdev -> dpy , xdev -> gc , xdev -> background ) ;\n XFillRectangle ( xdev -> dpy , xdev -> dest , xdev -> gc , 0 , 0 , xdev -> width , xdev -> height ) ;\n }\n if ( xdev -> bpixmap != ( Pixmap ) 0 ) {\n if ( ! xdev -> ghostview ) XSetWindowBackgroundPixmap ( xdev -> dpy , xdev -> win , xdev -> bpixmap ) ;\n XSetForeground ( xdev -> dpy , xdev -> gc , xdev -> background ) ;\n XFillRectangle ( xdev -> dpy , xdev -> bpixmap , xdev -> gc , 0 , 0 , xdev -> width , xdev -> height ) ;\n }\n xdev -> back_color = xdev -> background ;\n XSetBackground ( xdev -> dpy , xdev -> gc , xdev -> background ) ;\n xdev -> fore_color = xdev -> background ;\n XSetForeground ( xdev -> dpy , xdev -> gc , xdev -> background ) ;\n xdev -> colors_or = xdev -> colors_and = xdev -> background ;\n }", "idx": 181}
{"hash": 1182028467273264883, "project": "debian", "size": 5, "label": 0, "functionSource": "void free_all_replace ( ) {\n free_replace ( ) ;\n free_replace_regex ( ) ;\n free_replace_column ( ) ;\n }", "idx": 182}
{"hash": -3383030848920666759, "project": "debian", "size": 26, "label": 0, "functionSource": "static const struct var_expand_table * login_set_var_expand_table ( const struct master_service_settings_input * input ) {\n static struct var_expand_table static_tab [ ] = {\n {\n 'l' , NULL , \"lip\" }\n , {\n 'r' , NULL , \"rip\" }\n , {\n 'p' , NULL , \"pid\" }\n , {\n 's' , NULL , \"service\" }\n , {\n '\\0' , NULL , \"local_name\" }\n , {\n '\\0' , NULL , NULL }\n }\n ;\n struct var_expand_table * tab ;\n tab = t_malloc ( sizeof ( static_tab ) ) ;\n memcpy ( tab , static_tab , sizeof ( static_tab ) ) ;\n tab [ 0 ] . value = net_ip2addr ( & input -> local_ip ) ;\n tab [ 1 ] . value = net_ip2addr ( & input -> remote_ip ) ;\n tab [ 2 ] . value = my_pid ;\n tab [ 3 ] . value = input -> service ;\n tab [ 4 ] . value = input -> local_name ;\n return tab ;\n }", "idx": 183}
{"hash": 794575292121248454, "project": "debian", "size": 6, "label": 0, "functionSource": "void notef ( struct GlobalConfig * config , const char * fmt , ... ) {\n va_list ap ;\n va_start ( ap , fmt ) ;\n if ( config -> tracetype ) voutf ( config , NOTE_PREFIX , fmt , ap ) ;\n va_end ( ap ) ;\n }", "idx": 184}
{"hash": -8933711118846965366, "project": "debian", "size": 19, "label": 1, "functionSource": "static void cirrus_mem_writeb_mode4and5_8bpp ( CirrusVGAState * s , unsigned mode , unsigned offset , uint32_t mem_value ) {\n int x ;\n unsigned val = mem_value ;\n uint8_t * dst ;\n dst = s -> vga . vram_ptr + ( offset &= s -> cirrus_addr_mask ) ;\n for ( x = 0 ;\n x < 8 ;\n x ++ ) {\n if ( val & 0x80 ) {\n * dst = s -> cirrus_shadow_gr1 ;\n }\n else if ( mode == 5 ) {\n * dst = s -> cirrus_shadow_gr0 ;\n }\n val <<= 1 ;\n dst ++ ;\n }\n memory_region_set_dirty ( & s -> vga . vram , offset , 8 ) ;\n }", "idx": 185}
{"hash": -7795592811940874822, "project": "debian", "size": 47, "label": 0, "functionSource": "gcry_error_t gcry_pk_algo_info ( int algorithm , int what , void * buffer , size_t * nbytes ) {\n gcry_err_code_t err = GPG_ERR_NO_ERROR ;\n switch ( what ) {\n case GCRYCTL_TEST_ALGO : {\n int use = nbytes ? * nbytes : 0 ;\n if ( buffer ) err = GPG_ERR_INV_ARG ;\n else if ( check_pubkey_algo ( algorithm , use ) ) err = GPG_ERR_PUBKEY_ALGO ;\n break ;\n }\n case GCRYCTL_GET_ALGO_USAGE : {\n gcry_module_t pubkey ;\n int use = 0 ;\n REGISTER_DEFAULT_PUBKEYS ;\n ath_mutex_lock ( & pubkeys_registered_lock ) ;\n pubkey = _gcry_module_lookup_id ( pubkeys_registered , algorithm ) ;\n if ( pubkey ) {\n use = ( ( gcry_pk_spec_t * ) pubkey -> spec ) -> use ;\n _gcry_module_release ( pubkey ) ;\n }\n ath_mutex_unlock ( & pubkeys_registered_lock ) ;\n * nbytes = use ;\n break ;\n }\n case GCRYCTL_GET_ALGO_NPKEY : {\n int npkey = pubkey_get_npkey ( algorithm ) ;\n * nbytes = npkey ;\n break ;\n }\n case GCRYCTL_GET_ALGO_NSKEY : {\n int nskey = pubkey_get_nskey ( algorithm ) ;\n * nbytes = nskey ;\n break ;\n }\n case GCRYCTL_GET_ALGO_NSIGN : {\n int nsign = pubkey_get_nsig ( algorithm ) ;\n * nbytes = nsign ;\n break ;\n }\n case GCRYCTL_GET_ALGO_NENCR : {\n int nencr = pubkey_get_nenc ( algorithm ) ;\n * nbytes = nencr ;\n break ;\n }\n default : err = GPG_ERR_INV_OP ;\n }\n return gcry_error ( err ) ;\n }", "idx": 186}
{"hash": 4489017523191997023, "project": "debian", "size": 20, "label": 0, "functionSource": "void proto_reg_handoff_h225 ( void ) {\n static gboolean h225_prefs_initialized = FALSE ;\n static dissector_handle_t q931_tpkt_handle ;\n static guint saved_h225_tls_port ;\n if ( ! h225_prefs_initialized ) {\n dissector_add_uint ( \"udp.port\" , UDP_PORT_RAS1 , h225ras_handle ) ;\n dissector_add_uint ( \"udp.port\" , UDP_PORT_RAS2 , h225ras_handle ) ;\n h245_handle = find_dissector ( \"h245\" ) ;\n h245dg_handle = find_dissector ( \"h245dg\" ) ;\n h4501_handle = find_dissector ( \"h4501\" ) ;\n data_handle = find_dissector ( \"data\" ) ;\n h225_prefs_initialized = TRUE ;\n q931_tpkt_handle = find_dissector ( \"q931.tpkt\" ) ;\n }\n else {\n ssl_dissector_delete ( saved_h225_tls_port , q931_tpkt_handle ) ;\n }\n saved_h225_tls_port = h225_tls_port ;\n ssl_dissector_add ( saved_h225_tls_port , q931_tpkt_handle ) ;\n }", "idx": 187}
{"hash": 3584320764213684062, "project": "debian", "size": 35, "label": 0, "functionSource": "static int parse_CDbColId ( tvbuff_t * tvb , int offset , proto_tree * parent_tree , proto_tree * pad_tree , const char * text ) {\n guint32 eKind , ulId ;\n e_guid_t guid ;\n const char * str ;\n static const char * KIND [ ] = {\n \"DBKIND_GUID_NAME\" , \"DBKIND_GUID_PROPID\" }\n ;\n proto_item * tree_item ;\n proto_tree * tree = proto_tree_add_subtree ( parent_tree , tvb , offset , 0 , ett_CDbColId , & tree_item , text ) ;\n eKind = tvb_get_letohl ( tvb , offset ) ;\n str = ( eKind < 2 ? KIND [ eKind ] : \"???\" ) ;\n proto_tree_add_string_format_value ( tree , hf_mswsp_cdbcolid_ekind , tvb , offset , 4 , str , \"%s (%u)\" , str , eKind ) ;\n offset += 4 ;\n offset = parse_padding ( tvb , offset , 8 , pad_tree , \"paddingGuidAlign\" ) ;\n offset = parse_guid ( tvb , offset , tree , & guid , \"GUID\" ) ;\n ulId = tvb_get_letohl ( tvb , offset ) ;\n proto_tree_add_uint ( tree , hf_mswsp_cdbcolid_ulid , tvb , offset , 4 , ulId ) ;\n offset += 4 ;\n if ( eKind == DBKIND_GUID_NAME ) {\n char * name ;\n int len = ulId ;\n name = tvb_get_string_enc ( wmem_packet_scope ( ) , tvb , offset , len , ENC_LITTLE_ENDIAN | ENC_UCS_2 ) ;\n proto_item_append_text ( tree_item , \" \\\"%s\\\"\" , name ) ;\n proto_tree_add_string_format_value ( tree , hf_mswsp_cdbcolid_vstring , tvb , offset , len , name , \"\\\"%s\\\"\" , name ) ;\n offset += len ;\n }\n else if ( eKind == DBKIND_GUID_PROPID ) {\n proto_item_append_text ( tree_item , \" %08x\" , ulId ) ;\n }\n else {\n proto_item_append_text ( tree_item , \"<INVALID>\" ) ;\n }\n proto_item_set_end ( tree_item , tvb , offset ) ;\n return offset ;\n }", "idx": 188}
{"hash": -398565394354770780, "project": "debian", "size": 49, "label": 0, "functionSource": "static void usb_ohci_init ( OHCIState * ohci , DeviceState * dev , int num_ports , dma_addr_t localmem_base , char * masterbus , uint32_t firstport , AddressSpace * as , Error * * errp ) {\n Error * err = NULL ;\n int i ;\n ohci -> as = as ;\n if ( num_ports > OHCI_MAX_PORTS ) {\n error_setg ( errp , \"OHCI num-ports=%d is too big (limit is %d ports)\" , num_ports , OHCI_MAX_PORTS ) ;\n return ;\n }\n if ( usb_frame_time == 0 ) {\n # ifdef OHCI_TIME_WARP usb_frame_time = NANOSECONDS_PER_SECOND ;\n usb_bit_time = NANOSECONDS_PER_SECOND / ( USB_HZ / 1000 ) ;\n # else usb_frame_time = NANOSECONDS_PER_SECOND / 1000 ;\n if ( NANOSECONDS_PER_SECOND >= USB_HZ ) {\n usb_bit_time = NANOSECONDS_PER_SECOND / USB_HZ ;\n }\n else {\n usb_bit_time = 1 ;\n }\n # endif trace_usb_ohci_init_time ( usb_frame_time , usb_bit_time ) ;\n }\n ohci -> num_ports = num_ports ;\n if ( masterbus ) {\n USBPort * ports [ OHCI_MAX_PORTS ] ;\n for ( i = 0 ;\n i < num_ports ;\n i ++ ) {\n ports [ i ] = & ohci -> rhport [ i ] . port ;\n }\n usb_register_companion ( masterbus , ports , num_ports , firstport , ohci , & ohci_port_ops , USB_SPEED_MASK_LOW | USB_SPEED_MASK_FULL , & err ) ;\n if ( err ) {\n error_propagate ( errp , err ) ;\n return ;\n }\n }\n else {\n usb_bus_new ( & ohci -> bus , sizeof ( ohci -> bus ) , & ohci_bus_ops , dev ) ;\n for ( i = 0 ;\n i < num_ports ;\n i ++ ) {\n usb_register_port ( & ohci -> bus , & ohci -> rhport [ i ] . port , ohci , i , & ohci_port_ops , USB_SPEED_MASK_LOW | USB_SPEED_MASK_FULL ) ;\n }\n }\n memory_region_init_io ( & ohci -> mem , OBJECT ( dev ) , & ohci_mem_ops , ohci , \"ohci\" , 256 ) ;\n ohci -> localmem_base = localmem_base ;\n ohci -> name = object_get_typename ( OBJECT ( dev ) ) ;\n usb_packet_init ( & ohci -> usb_packet ) ;\n ohci -> async_td = 0 ;\n ohci -> eof_timer = timer_new_ns ( QEMU_CLOCK_VIRTUAL , ohci_frame_boundary , ohci ) ;\n }", "idx": 189}
{"hash": -16551315108292821, "project": "debian", "size": 3, "label": 0, "functionSource": "gcry_sexp_t gcry_sexp_car ( const gcry_sexp_t list ) {\n return gcry_sexp_nth ( list , 0 ) ;\n }", "idx": 190}
{"hash": 3557739556029059195, "project": "chrome", "size": 13, "label": 0, "functionSource": "void vp9_sad ## m ## x ## n ## x ## k ## _c ( const uint8_t * src , int src_stride , const uint8_t * ref , int ref_stride , unsigned int * sads ) {\n int i ;\n for ( i = 0 ;\n i < k ;\n ++ i ) sads [ i ] = vp9_sad ## m ## x ## n ## _c ( src , src_stride , & ref [ i ] , ref_stride ) ;\n \\ }\n # define sadMxNx4D ( m , n ) void vp9_sad ## m ## x ## n ## x4d_c ( const uint8_t * src , int src_stride , const uint8_t * const refs [ ] , int ref_stride , unsigned int * sads ) {\n int i ;\n for ( i = 0 ;\n i < 4 ;\n ++ i ) sads [ i ] = vp9_sad ## m ## x ## n ## _c ( src , src_stride , refs [ i ] , ref_stride ) ;\n \\ }\n sadMxN ( 64 , 64 ) sadMxNxK ( 64 , 64 , 3 ) sadMxNxK ( 64 , 64 , 8 ) sadMxNx4D ( 64 , 64 ) sadMxN ( 64 , 32 ) sadMxNx4D ( 64 , 32 ) sadMxN ( 32 , 64 ) sadMxNx4D ( 32 , 64 ) sadMxN ( 32 , 32 ) sadMxNxK ( 32 , 32 , 3 ) sadMxNxK ( 32 , 32 , 8 ) sadMxNx4D ( 32 , 32 ) sadMxN ( 32 , 16 ) sadMxNx4D ( 32 , 16 ) sadMxN ( 16 , 32 ) sadMxNx4D ( 16 , 32 ) sadMxN ( 16 , 16 ) sadMxNxK ( 16 , 16 , 3 ) sadMxNxK ( 16 , 16 , 8 ) sadMxNx4D ( 16 , 16 ) sadMxN ( 16 , 8 ) sadMxNxK ( 16 , 8 , 3 ) sadMxNxK ( 16 , 8 , 8 ) sadMxNx4D ( 16 , 8 ) sadMxN ( 8 , 16 ) sadMxNxK ( 8 , 16 , 3 ) sadMxNxK ( 8 , 16 , 8 ) sadMxNx4D ( 8 , 16 ) sadMxN ( 8 , 8 ) sadMxNxK ( 8 , 8 , 3 ) sadMxNxK ( 8 , 8 , 8 ) sadMxNx4D ( 8 , 8 ) sadMxN ( 8 , 4 ) sadMxNxK ( 8 , 4 , 8 ) sadMxNx4D ( 8 , 4 ) sadMxN ( 4 , 8 ) sadMxNxK ( 4 , 8 , 8 ) sadMxNx4D ( 4 , 8 ) sadMxN ( 4 , 4 ) sadMxNxK ( 4 , 4 , 3 )", "idx": 191}
{"hash": -1672864273235910388, "project": "debian", "size": 29, "label": 0, "functionSource": "static void _slurm_rpc_update_front_end ( slurm_msg_t * msg ) {\n int error_code = SLURM_SUCCESS ;\n DEF_TIMERS ;\n update_front_end_msg_t * update_front_end_msg_ptr = ( update_front_end_msg_t * ) msg -> data ;\n slurmctld_lock_t node_write_lock = {\n NO_LOCK , NO_LOCK , WRITE_LOCK , NO_LOCK , NO_LOCK }\n ;\n uid_t uid = g_slurm_auth_get_uid ( msg -> auth_cred , slurmctld_config . auth_info ) ;\n START_TIMER ;\n debug2 ( \"Processing RPC: REQUEST_UPDATE_FRONT_END from uid=%d\" , uid ) ;\n if ( ! validate_super_user ( uid ) ) {\n error_code = ESLURM_USER_ID_MISSING ;\n error ( \"Security violation, UPDATE_FRONT_END RPC from uid=%d\" , uid ) ;\n }\n if ( error_code == SLURM_SUCCESS ) {\n lock_slurmctld ( node_write_lock ) ;\n error_code = update_front_end ( update_front_end_msg_ptr ) ;\n unlock_slurmctld ( node_write_lock ) ;\n END_TIMER2 ( \"_slurm_rpc_update_front_end\" ) ;\n }\n if ( error_code ) {\n info ( \"_slurm_rpc_update_front_end for %s: %s\" , update_front_end_msg_ptr -> name , slurm_strerror ( error_code ) ) ;\n slurm_send_rc_msg ( msg , error_code ) ;\n }\n else {\n debug2 ( \"_slurm_rpc_update_front_end complete for %s %s\" , update_front_end_msg_ptr -> name , TIME_STR ) ;\n slurm_send_rc_msg ( msg , SLURM_SUCCESS ) ;\n }\n }", "idx": 192}
{"hash": -1283648210945038844, "project": "chrome", "size": 61, "label": 1, "functionSource": "void vp9_fdct8x8_c ( const int16_t * input , int16_t * final_output , int stride ) {\n int i , j ;\n int16_t intermediate [ 64 ] ;\n {\n int16_t * output = intermediate ;\n int s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 ;\n int t0 , t1 , t2 , t3 ;\n int x0 , x1 , x2 , x3 ;\n int i ;\n for ( i = 0 ;\n i < 8 ;\n i ++ ) {\n s0 = ( input [ 0 * stride ] + input [ 7 * stride ] ) * 4 ;\n s1 = ( input [ 1 * stride ] + input [ 6 * stride ] ) * 4 ;\n s2 = ( input [ 2 * stride ] + input [ 5 * stride ] ) * 4 ;\n s3 = ( input [ 3 * stride ] + input [ 4 * stride ] ) * 4 ;\n s4 = ( input [ 3 * stride ] - input [ 4 * stride ] ) * 4 ;\n s5 = ( input [ 2 * stride ] - input [ 5 * stride ] ) * 4 ;\n s6 = ( input [ 1 * stride ] - input [ 6 * stride ] ) * 4 ;\n s7 = ( input [ 0 * stride ] - input [ 7 * stride ] ) * 4 ;\n x0 = s0 + s3 ;\n x1 = s1 + s2 ;\n x2 = s1 - s2 ;\n x3 = s0 - s3 ;\n t0 = ( x0 + x1 ) * cospi_16_64 ;\n t1 = ( x0 - x1 ) * cospi_16_64 ;\n t2 = x2 * cospi_24_64 + x3 * cospi_8_64 ;\n t3 = - x2 * cospi_8_64 + x3 * cospi_24_64 ;\n output [ 0 * 8 ] = fdct_round_shift ( t0 ) ;\n output [ 2 * 8 ] = fdct_round_shift ( t2 ) ;\n output [ 4 * 8 ] = fdct_round_shift ( t1 ) ;\n output [ 6 * 8 ] = fdct_round_shift ( t3 ) ;\n t0 = ( s6 - s5 ) * cospi_16_64 ;\n t1 = ( s6 + s5 ) * cospi_16_64 ;\n t2 = fdct_round_shift ( t0 ) ;\n t3 = fdct_round_shift ( t1 ) ;\n x0 = s4 + t2 ;\n x1 = s4 - t2 ;\n x2 = s7 - t3 ;\n x3 = s7 + t3 ;\n t0 = x0 * cospi_28_64 + x3 * cospi_4_64 ;\n t1 = x1 * cospi_12_64 + x2 * cospi_20_64 ;\n t2 = x2 * cospi_12_64 + x1 * - cospi_20_64 ;\n t3 = x3 * cospi_28_64 + x0 * - cospi_4_64 ;\n output [ 1 * 8 ] = fdct_round_shift ( t0 ) ;\n output [ 3 * 8 ] = fdct_round_shift ( t2 ) ;\n output [ 5 * 8 ] = fdct_round_shift ( t1 ) ;\n output [ 7 * 8 ] = fdct_round_shift ( t3 ) ;\n input ++ ;\n output ++ ;\n }\n }\n for ( i = 0 ;\n i < 8 ;\n ++ i ) {\n fdct8 ( & intermediate [ i * 8 ] , & final_output [ i * 8 ] ) ;\n for ( j = 0 ;\n j < 8 ;\n ++ j ) final_output [ j + i * 8 ] /= 2 ;\n }\n }", "idx": 193}
{"hash": 3192165150896245305, "project": "debian", "size": 98, "label": 0, "functionSource": "unsigned long # endif # undef mul # undef mul_add # define mul_add ( r , a , word , carry ) do {\n \\ register BN_ULONG high , low ;\n \\ asm ( \"mulq %3\" \\ : \"=a\" ( low ) , \"=d\" ( high ) \\ : \"a\" ( word ) , \"m\" ( a ) \\ : \"cc\" ) ;\n \\ asm ( \"addq %2,%0;\n adcq %3,%1\" \\ : \"+r\" ( carry ) , \"+d\" ( high ) \\ : \"a\" ( low ) , \"g\" ( 0 ) \\ : \"cc\" ) ;\n \\ asm ( \"addq %2,%0;\n adcq %3,%1\" \\ : \"+m\" ( r ) , \"+d\" ( high ) \\ : \"r\" ( carry ) , \"g\" ( 0 ) \\ : \"cc\" ) ;\n \\ carry = high ;\n \\ }\n while ( 0 ) # define mul ( r , a , word , carry ) do {\n \\ register BN_ULONG high , low ;\n \\ asm ( \"mulq %3\" \\ : \"=a\" ( low ) , \"=d\" ( high ) \\ : \"a\" ( word ) , \"g\" ( a ) \\ : \"cc\" ) ;\n \\ asm ( \"addq %2,%0;\n adcq %3,%1\" \\ : \"+r\" ( carry ) , \"+d\" ( high ) \\ : \"a\" ( low ) , \"g\" ( 0 ) \\ : \"cc\" ) ;\n \\ ( r ) = carry , carry = high ;\n \\ }\n while ( 0 ) # undef sqr # define sqr ( r0 , r1 , a ) \\ asm ( \"mulq %2\" \\ : \"=a\" ( r0 ) , \"=d\" ( r1 ) \\ : \"a\" ( a ) \\ : \"cc\" ) ;\n BN_ULONG bn_mul_add_words ( BN_ULONG * rp , const BN_ULONG * ap , int num , BN_ULONG w ) {\n BN_ULONG c1 = 0 ;\n if ( num <= 0 ) return ( c1 ) ;\n while ( num & ~ 3 ) {\n mul_add ( rp [ 0 ] , ap [ 0 ] , w , c1 ) ;\n mul_add ( rp [ 1 ] , ap [ 1 ] , w , c1 ) ;\n mul_add ( rp [ 2 ] , ap [ 2 ] , w , c1 ) ;\n mul_add ( rp [ 3 ] , ap [ 3 ] , w , c1 ) ;\n ap += 4 ;\n rp += 4 ;\n num -= 4 ;\n }\n if ( num ) {\n mul_add ( rp [ 0 ] , ap [ 0 ] , w , c1 ) ;\n if ( -- num == 0 ) return c1 ;\n mul_add ( rp [ 1 ] , ap [ 1 ] , w , c1 ) ;\n if ( -- num == 0 ) return c1 ;\n mul_add ( rp [ 2 ] , ap [ 2 ] , w , c1 ) ;\n return c1 ;\n }\n return ( c1 ) ;\n }\n BN_ULONG bn_mul_words ( BN_ULONG * rp , const BN_ULONG * ap , int num , BN_ULONG w ) {\n BN_ULONG c1 = 0 ;\n if ( num <= 0 ) return ( c1 ) ;\n while ( num & ~ 3 ) {\n mul ( rp [ 0 ] , ap [ 0 ] , w , c1 ) ;\n mul ( rp [ 1 ] , ap [ 1 ] , w , c1 ) ;\n mul ( rp [ 2 ] , ap [ 2 ] , w , c1 ) ;\n mul ( rp [ 3 ] , ap [ 3 ] , w , c1 ) ;\n ap += 4 ;\n rp += 4 ;\n num -= 4 ;\n }\n if ( num ) {\n mul ( rp [ 0 ] , ap [ 0 ] , w , c1 ) ;\n if ( -- num == 0 ) return c1 ;\n mul ( rp [ 1 ] , ap [ 1 ] , w , c1 ) ;\n if ( -- num == 0 ) return c1 ;\n mul ( rp [ 2 ] , ap [ 2 ] , w , c1 ) ;\n }\n return ( c1 ) ;\n }\n void bn_sqr_words ( BN_ULONG * r , const BN_ULONG * a , int n ) {\n if ( n <= 0 ) return ;\n while ( n & ~ 3 ) {\n sqr ( r [ 0 ] , r [ 1 ] , a [ 0 ] ) ;\n sqr ( r [ 2 ] , r [ 3 ] , a [ 1 ] ) ;\n sqr ( r [ 4 ] , r [ 5 ] , a [ 2 ] ) ;\n sqr ( r [ 6 ] , r [ 7 ] , a [ 3 ] ) ;\n a += 4 ;\n r += 8 ;\n n -= 4 ;\n }\n if ( n ) {\n sqr ( r [ 0 ] , r [ 1 ] , a [ 0 ] ) ;\n if ( -- n == 0 ) return ;\n sqr ( r [ 2 ] , r [ 3 ] , a [ 1 ] ) ;\n if ( -- n == 0 ) return ;\n sqr ( r [ 4 ] , r [ 5 ] , a [ 2 ] ) ;\n }\n }\n BN_ULONG bn_div_words ( BN_ULONG h , BN_ULONG l , BN_ULONG d ) {\n BN_ULONG ret , waste ;\n asm ( \"divq %4\" : \"=a\" ( ret ) , \"=d\" ( waste ) : \"a\" ( l ) , \"d\" ( h ) , \"g\" ( d ) : \"cc\" ) ;\n return ret ;\n }\n BN_ULONG bn_add_words ( BN_ULONG * rp , const BN_ULONG * ap , const BN_ULONG * bp , int n ) {\n BN_ULONG ret ;\n size_t i = 0 ;\n if ( n <= 0 ) return 0 ;\n asm volatile ( \" subq %0,%0 \\n\" \" jmp 1f \\n\" \".p2align 4 \\n\" \"1: movq (%4,%2,8),%0 \\n\" \" adcq (%5,%2,8),%0 \\n\" \" movq %0,(%3,%2,8) \\n\" \" lea 1(%2),%2 \\n\" \" loop 1b \\n\" \" sbbq %0,%0 \\n\" : \"=&r\" ( ret ) , \"+c\" ( n ) , \"+r\" ( i ) : \"r\" ( rp ) , \"r\" ( ap ) , \"r\" ( bp ) : \"cc\" , \"memory\" ) ;\n return ret & 1 ;\n }\n # ifndef SIMICS BN_ULONG bn_sub_words ( BN_ULONG * rp , const BN_ULONG * ap , const BN_ULONG * bp , int n ) {\n BN_ULONG ret ;\n size_t i = 0 ;\n if ( n <= 0 ) return 0 ;\n asm volatile ( \" subq %0,%0 \\n\" \" jmp 1f \\n\" \".p2align 4 \\n\" \"1: movq (%4,%2,8),%0 \\n\" \" sbbq (%5,%2,8),%0 \\n\" \" movq %0,(%3,%2,8) \\n\" \" lea 1(%2),%2 \\n\" \" loop 1b \\n\" \" sbbq %0,%0 \\n\" : \"=&r\" ( ret ) , \"+c\" ( n ) , \"+r\" ( i ) : \"r\" ( rp ) , \"r\" ( ap ) , \"r\" ( bp ) : \"cc\" , \"memory\" ) ;\n return ret & 1 ;\n }", "idx": 194}
{"hash": 6632536031698733342, "project": "debian", "size": 18, "label": 0, "functionSource": "static void log_read_interval ( const ReadInterval * interval , void * log_ctx , int log_level ) {\n av_log ( log_ctx , log_level , \"id:%d\" , interval -> id ) ;\n if ( interval -> has_start ) {\n av_log ( log_ctx , log_level , \" start:%s%s\" , interval -> start_is_offset ? \"+\" : \"\" , av_ts2timestr ( interval -> start , & AV_TIME_BASE_Q ) ) ;\n }\n else {\n av_log ( log_ctx , log_level , \" start:N/A\" ) ;\n }\n if ( interval -> has_end ) {\n av_log ( log_ctx , log_level , \" end:%s\" , interval -> end_is_offset ? \"+\" : \"\" ) ;\n if ( interval -> duration_frames ) av_log ( log_ctx , log_level , \"#%\" PRId64 , interval -> end ) ;\n else av_log ( log_ctx , log_level , \"%s\" , av_ts2timestr ( interval -> end , & AV_TIME_BASE_Q ) ) ;\n }\n else {\n av_log ( log_ctx , log_level , \" end:N/A\" ) ;\n }\n av_log ( log_ctx , log_level , \"\\n\" ) ;\n }", "idx": 195}
{"hash": -5927738579069082820, "project": "debian", "size": 69, "label": 0, "functionSource": "static void xps_draw_arc ( fz_context * doc , fz_path * path , float size_x , float size_y , float rotation_angle , int is_large_arc , int is_clockwise , float point_x , float point_y ) {\n fz_matrix rotmat , revmat ;\n fz_matrix mtx ;\n fz_point pt ;\n float rx , ry ;\n float x1 , y1 , x2 , y2 ;\n float x1t , y1t ;\n float cxt , cyt , cx , cy ;\n float t1 , t2 , t3 ;\n float sign ;\n float th1 , dth ;\n pt = fz_currentpoint ( doc , path ) ;\n x1 = pt . x ;\n y1 = pt . y ;\n x2 = point_x ;\n y2 = point_y ;\n rx = size_x ;\n ry = size_y ;\n if ( is_clockwise != is_large_arc ) sign = 1 ;\n else sign = - 1 ;\n fz_rotate ( & rotmat , rotation_angle ) ;\n fz_rotate ( & revmat , - rotation_angle ) ;\n rx = fabsf ( rx ) ;\n ry = fabsf ( ry ) ;\n if ( rx < 0.001f || ry < 0.001f || ( x1 == x2 && y1 == y2 ) ) {\n fz_lineto ( doc , path , x2 , y2 ) ;\n return ;\n }\n pt . x = ( x1 - x2 ) / 2 ;\n pt . y = ( y1 - y2 ) / 2 ;\n fz_transform_vector ( & pt , & revmat ) ;\n x1t = pt . x ;\n y1t = pt . y ;\n t1 = ( x1t * x1t ) / ( rx * rx ) + ( y1t * y1t ) / ( ry * ry ) ;\n if ( t1 > 1 ) {\n rx = rx * sqrtf ( t1 ) ;\n ry = ry * sqrtf ( t1 ) ;\n }\n t1 = ( rx * rx * ry * ry ) - ( rx * rx * y1t * y1t ) - ( ry * ry * x1t * x1t ) ;\n t2 = ( rx * rx * y1t * y1t ) + ( ry * ry * x1t * x1t ) ;\n t3 = t1 / t2 ;\n if ( t3 < 0 ) t3 = 0 ;\n t3 = sqrtf ( t3 ) ;\n cxt = sign * t3 * ( rx * y1t ) / ry ;\n cyt = sign * t3 * - ( ry * x1t ) / rx ;\n pt . x = cxt ;\n pt . y = cyt ;\n fz_transform_vector ( & pt , & rotmat ) ;\n cx = pt . x + ( x1 + x2 ) / 2 ;\n cy = pt . y + ( y1 + y2 ) / 2 ;\n {\n fz_point coord1 , coord2 , coord3 , coord4 ;\n coord1 . x = 1 ;\n coord1 . y = 0 ;\n coord2 . x = ( x1t - cxt ) / rx ;\n coord2 . y = ( y1t - cyt ) / ry ;\n coord3 . x = ( x1t - cxt ) / rx ;\n coord3 . y = ( y1t - cyt ) / ry ;\n coord4 . x = ( - x1t - cxt ) / rx ;\n coord4 . y = ( - y1t - cyt ) / ry ;\n th1 = angle_between ( coord1 , coord2 ) ;\n dth = angle_between ( coord3 , coord4 ) ;\n if ( dth < 0 && ! is_clockwise ) dth += ( ( ( float ) M_PI / 180 ) * 360 ) ;\n if ( dth > 0 && is_clockwise ) dth -= ( ( ( float ) M_PI / 180 ) * 360 ) ;\n }\n fz_pre_scale ( fz_pre_rotate ( fz_translate ( & mtx , cx , cy ) , rotation_angle ) , rx , ry ) ;\n xps_draw_arc_segment ( doc , path , & mtx , th1 , th1 + dth , is_clockwise ) ;\n fz_lineto ( doc , path , point_x , point_y ) ;\n }", "idx": 196}
{"hash": -1983921383858884161, "project": "debian", "size": 63, "label": 1, "functionSource": "static int ipvideo_decode_block_opcode_0x8_16 ( IpvideoContext * s ) {\n int x , y ;\n uint16_t P [ 4 ] ;\n unsigned int flags = 0 ;\n uint16_t * pixel_ptr = ( uint16_t * ) s -> pixel_ptr ;\n P [ 0 ] = bytestream2_get_le16 ( & s -> stream_ptr ) ;\n P [ 1 ] = bytestream2_get_le16 ( & s -> stream_ptr ) ;\n if ( ! ( P [ 0 ] & 0x8000 ) ) {\n for ( y = 0 ;\n y < 16 ;\n y ++ ) {\n if ( ! ( y & 3 ) ) {\n if ( y ) {\n P [ 0 ] = bytestream2_get_le16 ( & s -> stream_ptr ) ;\n P [ 1 ] = bytestream2_get_le16 ( & s -> stream_ptr ) ;\n }\n flags = bytestream2_get_le16 ( & s -> stream_ptr ) ;\n }\n for ( x = 0 ;\n x < 4 ;\n x ++ , flags >>= 1 ) * pixel_ptr ++ = P [ flags & 1 ] ;\n pixel_ptr += s -> stride - 4 ;\n if ( y == 7 ) pixel_ptr -= 8 * s -> stride - 4 ;\n }\n }\n else {\n flags = bytestream2_get_le32 ( & s -> stream_ptr ) ;\n P [ 2 ] = bytestream2_get_le16 ( & s -> stream_ptr ) ;\n P [ 3 ] = bytestream2_get_le16 ( & s -> stream_ptr ) ;\n if ( ! ( P [ 2 ] & 0x8000 ) ) {\n for ( y = 0 ;\n y < 16 ;\n y ++ ) {\n for ( x = 0 ;\n x < 4 ;\n x ++ , flags >>= 1 ) * pixel_ptr ++ = P [ flags & 1 ] ;\n pixel_ptr += s -> stride - 4 ;\n if ( y == 7 ) {\n pixel_ptr -= 8 * s -> stride - 4 ;\n P [ 0 ] = P [ 2 ] ;\n P [ 1 ] = P [ 3 ] ;\n flags = bytestream2_get_le32 ( & s -> stream_ptr ) ;\n }\n }\n }\n else {\n for ( y = 0 ;\n y < 8 ;\n y ++ ) {\n if ( y == 4 ) {\n P [ 0 ] = P [ 2 ] ;\n P [ 1 ] = P [ 3 ] ;\n flags = bytestream2_get_le32 ( & s -> stream_ptr ) ;\n }\n for ( x = 0 ;\n x < 8 ;\n x ++ , flags >>= 1 ) * pixel_ptr ++ = P [ flags & 1 ] ;\n pixel_ptr += s -> line_inc ;\n }\n }\n }\n return 0 ;\n }", "idx": 197}
{"hash": 5506079590431503777, "project": "debian", "size": 13, "label": 0, "functionSource": "static guint qname_labels_count ( const guchar * name , guint name_len ) {\n guint labels = 0 ;\n unsigned i ;\n if ( name_len > 1 ) {\n for ( i = 0 ;\n i < strlen ( name ) ;\n i ++ ) {\n if ( name [ i ] == '.' ) labels ++ ;\n }\n labels ++ ;\n }\n return labels ;\n }", "idx": 198}
{"hash": 6336384260629386331, "project": "debian", "size": 36, "label": 0, "functionSource": "static void dissect_zcl_part_multiack ( tvbuff_t * tvb , proto_tree * tree , guint * offset ) {\n guint tvb_len = tvb_reported_length ( tvb ) ;\n guint i = 0 ;\n guint8 options ;\n guint16 first_frame_id ;\n guint16 nack_id ;\n static const int * ack_opts [ ] = {\n & hf_zbee_zcl_part_ack_opt_nack_id_len , & hf_zbee_zcl_part_ack_opt_res , NULL }\n ;\n options = tvb_get_guint8 ( tvb , * offset ) ;\n proto_tree_add_bitmask ( tree , tvb , * offset , hf_zbee_zcl_part_ack_opt , ett_zbee_zcl_part_ack_opts , ack_opts , ENC_NA ) ;\n * offset += 1 ;\n if ( ( options & ZBEE_ZCL_PART_ACK_OPT_NACK_LEN ) == 0 ) {\n first_frame_id = ( guint16 ) tvb_get_guint8 ( tvb , * offset ) ;\n proto_tree_add_item ( tree , hf_zbee_zcl_part_first_frame_id , tvb , * offset , 1 , ( first_frame_id & 0xFF ) ) ;\n * offset += 1 ;\n }\n else {\n first_frame_id = tvb_get_letohs ( tvb , * offset ) ;\n proto_tree_add_item ( tree , hf_zbee_zcl_part_first_frame_id , tvb , * offset , 2 , first_frame_id ) ;\n * offset += 2 ;\n }\n while ( * offset < tvb_len && i < ZBEE_ZCL_PART_NUM_NACK_ID_ETT ) {\n if ( ( options & ZBEE_ZCL_PART_ACK_OPT_NACK_LEN ) == 0 ) {\n nack_id = ( guint16 ) tvb_get_guint8 ( tvb , * offset ) ;\n proto_tree_add_item ( tree , hf_zbee_zcl_part_nack_id , tvb , * offset , 1 , ( nack_id & 0xFF ) ) ;\n * offset += 1 ;\n }\n else {\n nack_id = tvb_get_letohs ( tvb , * offset ) ;\n proto_tree_add_item ( tree , hf_zbee_zcl_part_nack_id , tvb , * offset , 2 , nack_id ) ;\n * offset += 2 ;\n }\n i ++ ;\n }\n }", "idx": 199}
{"hash": -6119142299306266167, "project": "debian", "size": 15, "label": 0, "functionSource": "static int for_neg_int_continue ( i_ctx_t * i_ctx_p ) {\n os_ptr op = osp ;\n register es_ptr ep = esp ;\n int var = ep [ - 3 ] . value . intval ;\n if ( var < ep [ - 1 ] . value . intval ) {\n esp -= 5 ;\n return o_pop_estack ;\n }\n push ( 1 ) ;\n make_int ( op , var ) ;\n ep [ - 3 ] . value . intval = var + ep [ - 2 ] . value . intval ;\n ref_assign ( ep + 2 , ep ) ;\n esp = ep + 2 ;\n return o_push_estack ;\n }", "idx": 200}
{"hash": 3616225660295849566, "project": "debian", "size": 5, "label": 0, "functionSource": "static gchar get_priority ( const guint8 priority ) {\n static gchar priorities [ ] = \"??VDIWEFS\" ;\n if ( priority >= ( guint8 ) sizeof ( priorities ) ) return '?' ;\n return priorities [ priority ] ;\n }", "idx": 201}
{"hash": 4489017523191997023, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h225_T_port ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_constrained_integer ( tvb , offset , actx , tree , hf_index , 0U , 65535U , & ip_port , FALSE ) ;\n return offset ;\n }", "idx": 202}
{"hash": 2687336064028423153, "project": "chrome", "size": 3, "label": 0, "functionSource": "static void dnslabel_table_init ( struct dnslabel_table * table ) {\n table -> n_labels = 0 ;\n }", "idx": 203}
{"hash": 7690587584364497392, "project": "debian", "size": 114, "label": 0, "functionSource": "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n TargaContext * const s = avctx -> priv_data ;\n AVFrame * const p = data ;\n uint8_t * dst ;\n int stride ;\n int idlen , compr , y , w , h , bpp , flags , ret ;\n int first_clr , colors , csize ;\n bytestream2_init ( & s -> gb , avpkt -> data , avpkt -> size ) ;\n idlen = bytestream2_get_byte ( & s -> gb ) ;\n bytestream2_skip ( & s -> gb , 1 ) ;\n compr = bytestream2_get_byte ( & s -> gb ) ;\n first_clr = bytestream2_get_le16 ( & s -> gb ) ;\n colors = bytestream2_get_le16 ( & s -> gb ) ;\n csize = bytestream2_get_byte ( & s -> gb ) ;\n bytestream2_skip ( & s -> gb , 4 ) ;\n w = bytestream2_get_le16 ( & s -> gb ) ;\n h = bytestream2_get_le16 ( & s -> gb ) ;\n bpp = bytestream2_get_byte ( & s -> gb ) ;\n flags = bytestream2_get_byte ( & s -> gb ) ;\n bytestream2_skip ( & s -> gb , idlen ) ;\n switch ( bpp ) {\n case 8 : avctx -> pix_fmt = ( ( compr & ( ~ TGA_RLE ) ) == TGA_BW ) ? AV_PIX_FMT_GRAY8 : AV_PIX_FMT_PAL8 ;\n break ;\n case 15 : avctx -> pix_fmt = AV_PIX_FMT_RGB555LE ;\n break ;\n case 16 : avctx -> pix_fmt = AV_PIX_FMT_RGB555LE ;\n break ;\n case 24 : avctx -> pix_fmt = AV_PIX_FMT_BGR24 ;\n break ;\n case 32 : avctx -> pix_fmt = AV_PIX_FMT_BGRA ;\n break ;\n default : av_log ( avctx , AV_LOG_ERROR , \"Bit depth %i is not supported\\n\" , bpp ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( ( ret = av_image_check_size ( w , h , 0 , avctx ) ) < 0 ) return ret ;\n if ( w != avctx -> width || h != avctx -> height ) avcodec_set_dimensions ( avctx , w , h ) ;\n if ( ( ret = ff_get_buffer ( avctx , p , 0 ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n if ( flags & 0x20 ) {\n dst = p -> data [ 0 ] ;\n stride = p -> linesize [ 0 ] ;\n }\n else {\n dst = p -> data [ 0 ] + p -> linesize [ 0 ] * ( h - 1 ) ;\n stride = - p -> linesize [ 0 ] ;\n }\n if ( colors ) {\n int pal_size , pal_sample_size ;\n if ( ( colors + first_clr ) > 256 ) {\n av_log ( avctx , AV_LOG_ERROR , \"Incorrect palette: %i colors with offset %i\\n\" , colors , first_clr ) ;\n return AVERROR_INVALIDDATA ;\n }\n switch ( csize ) {\n case 24 : pal_sample_size = 3 ;\n break ;\n case 16 : case 15 : pal_sample_size = 2 ;\n break ;\n default : av_log ( avctx , AV_LOG_ERROR , \"Palette entry size %i bits is not supported\\n\" , csize ) ;\n return AVERROR_INVALIDDATA ;\n }\n pal_size = colors * pal_sample_size ;\n if ( avctx -> pix_fmt != AV_PIX_FMT_PAL8 ) bytestream2_skip ( & s -> gb , pal_size ) ;\n else {\n int t ;\n uint32_t * pal = ( ( uint32_t * ) p -> data [ 1 ] ) + first_clr ;\n if ( bytestream2_get_bytes_left ( & s -> gb ) < pal_size ) {\n av_log ( avctx , AV_LOG_ERROR , \"Not enough data to read palette\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n switch ( pal_sample_size ) {\n case 3 : for ( t = 0 ;\n t < colors ;\n t ++ ) * pal ++ = bytestream2_get_le24u ( & s -> gb ) ;\n break ;\n case 2 : for ( t = 0 ;\n t < colors ;\n t ++ ) {\n uint32_t v = bytestream2_get_le16u ( & s -> gb ) ;\n v = ( ( v & 0x7C00 ) << 9 ) | ( ( v & 0x03E0 ) << 6 ) | ( ( v & 0x001F ) << 3 ) ;\n v |= ( v & 0xE0E0E0U ) >> 5 ;\n * pal ++ = v ;\n }\n break ;\n }\n p -> palette_has_changed = 1 ;\n }\n }\n if ( ( compr & ( ~ TGA_RLE ) ) == TGA_NODATA ) {\n memset ( p -> data [ 0 ] , 0 , p -> linesize [ 0 ] * h ) ;\n }\n else {\n if ( compr & TGA_RLE ) {\n int res = targa_decode_rle ( avctx , s , dst , w , h , stride , bpp ) ;\n if ( res < 0 ) return res ;\n }\n else {\n size_t img_size = w * ( ( bpp + 1 ) >> 3 ) ;\n if ( bytestream2_get_bytes_left ( & s -> gb ) < img_size * h ) {\n av_log ( avctx , AV_LOG_ERROR , \"Not enough data available for image\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n for ( y = 0 ;\n y < h ;\n y ++ ) {\n bytestream2_get_bufferu ( & s -> gb , dst , img_size ) ;\n dst += stride ;\n }\n }\n }\n * got_frame = 1 ;\n return avpkt -> size ;\n }", "idx": 204}
{"hash": -483869641057106085, "project": "debian", "size": 81, "label": 0, "functionSource": "extern int as_mysql_step_start ( mysql_conn_t * mysql_conn , struct step_record * step_ptr ) {\n int tasks = 0 , nodes = 0 , task_dist = 0 ;\n int rc = SLURM_SUCCESS ;\n char temp_bit [ BUF_SIZE ] ;\n char node_list [ BUFFER_SIZE ] ;\n char * node_inx = NULL ;\n time_t start_time , submit_time ;\n char * query = NULL ;\n if ( ! step_ptr -> job_ptr -> db_index && ( ( ! step_ptr -> job_ptr -> details || ! step_ptr -> job_ptr -> details -> submit_time ) && ! step_ptr -> job_ptr -> resize_time ) ) {\n error ( \"as_mysql_step_start: \" \"Not inputing this job, it has no submit time.\" ) ;\n return SLURM_ERROR ;\n }\n if ( step_ptr -> job_ptr -> resize_time ) {\n submit_time = start_time = step_ptr -> job_ptr -> resize_time ;\n if ( step_ptr -> start_time > submit_time ) start_time = step_ptr -> start_time ;\n }\n else {\n start_time = step_ptr -> start_time ;\n submit_time = step_ptr -> job_ptr -> details -> submit_time ;\n }\n if ( check_connection ( mysql_conn ) != SLURM_SUCCESS ) return ESLURM_DB_CONNECTION ;\n if ( slurmdbd_conf ) {\n if ( step_ptr -> job_ptr -> details ) tasks = step_ptr -> job_ptr -> details -> num_tasks ;\n else tasks = step_ptr -> cpu_count ;\n snprintf ( node_list , BUFFER_SIZE , \"%s\" , step_ptr -> job_ptr -> nodes ) ;\n nodes = step_ptr -> step_layout -> node_cnt ;\n task_dist = step_ptr -> step_layout -> task_dist ;\n node_inx = step_ptr -> network ;\n }\n else if ( step_ptr -> step_id == SLURM_BATCH_SCRIPT ) {\n if ( step_ptr -> step_node_bitmap ) {\n node_inx = bit_fmt ( temp_bit , sizeof ( temp_bit ) , step_ptr -> step_node_bitmap ) ;\n }\n snprintf ( node_list , BUFFER_SIZE , \"%s\" , step_ptr -> gres ) ;\n nodes = tasks = 1 ;\n if ( ! step_ptr -> tres_alloc_str ) xstrfmtcat ( step_ptr -> tres_alloc_str , \"%s%u=%u,%u=%u\" , step_ptr -> tres_alloc_str ? \",\" : \"\" , TRES_CPU , 1 , TRES_NODE , 1 ) ;\n }\n else {\n char * ionodes = NULL , * temp_nodes = NULL ;\n if ( step_ptr -> step_node_bitmap ) {\n node_inx = bit_fmt ( temp_bit , sizeof ( temp_bit ) , step_ptr -> step_node_bitmap ) ;\n }\n if ( ! step_ptr -> step_layout || ! step_ptr -> step_layout -> task_cnt ) {\n if ( step_ptr -> cpu_count ) tasks = step_ptr -> cpu_count ;\n else {\n if ( ( tasks = slurmdb_find_tres_count_in_string ( step_ptr -> tres_alloc_str , TRES_CPU ) ) == INFINITE64 ) {\n if ( ( tasks = slurmdb_find_tres_count_in_string ( step_ptr -> job_ptr -> tres_alloc_str , TRES_CPU ) ) == INFINITE64 ) tasks = step_ptr -> job_ptr -> total_nodes ;\n }\n }\n nodes = step_ptr -> job_ptr -> total_nodes ;\n temp_nodes = step_ptr -> job_ptr -> nodes ;\n }\n else {\n tasks = step_ptr -> step_layout -> task_cnt ;\n # ifdef HAVE_BGQ select_g_select_jobinfo_get ( step_ptr -> select_jobinfo , SELECT_JOBDATA_NODE_CNT , & nodes ) ;\n # else nodes = step_ptr -> step_layout -> node_cnt ;\n # endif task_dist = step_ptr -> step_layout -> task_dist ;\n temp_nodes = step_ptr -> step_layout -> node_list ;\n }\n select_g_select_jobinfo_get ( step_ptr -> select_jobinfo , SELECT_JOBDATA_IONODES , & ionodes ) ;\n if ( ionodes ) {\n snprintf ( node_list , BUFFER_SIZE , \"%s[%s]\" , temp_nodes , ionodes ) ;\n xfree ( ionodes ) ;\n }\n else snprintf ( node_list , BUFFER_SIZE , \"%s\" , temp_nodes ) ;\n }\n if ( ! step_ptr -> job_ptr -> db_index ) {\n if ( ! ( step_ptr -> job_ptr -> db_index = _get_db_index ( mysql_conn , submit_time , step_ptr -> job_ptr -> job_id , step_ptr -> job_ptr -> assoc_id ) ) ) {\n if ( as_mysql_job_start ( mysql_conn , step_ptr -> job_ptr ) == SLURM_ERROR ) {\n error ( \"couldn't add job %u at step start\" , step_ptr -> job_ptr -> job_id ) ;\n return SLURM_SUCCESS ;\n }\n }\n }\n query = xstrdup_printf ( \"insert into \\\"%s_%s\\\" (job_db_inx, id_step, time_start, \" \"step_name, state, tres_alloc, \" \"nodes_alloc, task_cnt, nodelist, node_inx, \" \"task_dist, req_cpufreq, req_cpufreq_min, req_cpufreq_gov) \" \"values (%\" PRIu64 \", %d, %d, '%s', %d, '%s', %d, %d, \" \"'%s', '%s', %d, %u, %u, %u) \" \"on duplicate key update \" \"nodes_alloc=%d, task_cnt=%d, time_end=0, state=%d, \" \"nodelist='%s', node_inx='%s', task_dist=%d, \" \"req_cpufreq=%u, req_cpufreq_min=%u, req_cpufreq_gov=%u,\" \"tres_alloc='%s';\n\" , mysql_conn -> cluster_name , step_table , step_ptr -> job_ptr -> db_index , step_ptr -> step_id , ( int ) start_time , step_ptr -> name , JOB_RUNNING , step_ptr -> tres_alloc_str , nodes , tasks , node_list , node_inx , task_dist , step_ptr -> cpu_freq_max , step_ptr -> cpu_freq_min , step_ptr -> cpu_freq_gov , nodes , tasks , JOB_RUNNING , node_list , node_inx , task_dist , step_ptr -> cpu_freq_max , step_ptr -> cpu_freq_min , step_ptr -> cpu_freq_gov , step_ptr -> tres_alloc_str ) ;\n if ( debug_flags & DEBUG_FLAG_DB_STEP ) DB_DEBUG ( mysql_conn -> conn , \"query\\n%s\" , query ) ;\n rc = mysql_db_query ( mysql_conn , query ) ;\n xfree ( query ) ;\n return rc ;\n }", "idx": 205}
{"hash": 6458694302493204858, "project": "debian", "size": 40, "label": 0, "functionSource": "static Datum ExecEvalRowCompare ( RowCompareExprState * rstate , ExprContext * econtext , bool * isNull , ExprDoneCond * isDone ) {\n bool result ;\n RowCompareType rctype = ( ( RowCompareExpr * ) rstate -> xprstate . expr ) -> rctype ;\n int32 cmpresult = 0 ;\n ListCell * l ;\n ListCell * r ;\n int i ;\n if ( isDone ) * isDone = ExprSingleResult ;\n * isNull = true ;\n i = 0 ;\n forboth ( l , rstate -> largs , r , rstate -> rargs ) {\n ExprState * le = ( ExprState * ) lfirst ( l ) ;\n ExprState * re = ( ExprState * ) lfirst ( r ) ;\n FunctionCallInfoData locfcinfo ;\n InitFunctionCallInfoData ( locfcinfo , & ( rstate -> funcs [ i ] ) , 2 , rstate -> collations [ i ] , NULL , NULL ) ;\n locfcinfo . arg [ 0 ] = ExecEvalExpr ( le , econtext , & locfcinfo . argnull [ 0 ] , NULL ) ;\n locfcinfo . arg [ 1 ] = ExecEvalExpr ( re , econtext , & locfcinfo . argnull [ 1 ] , NULL ) ;\n if ( rstate -> funcs [ i ] . fn_strict && ( locfcinfo . argnull [ 0 ] || locfcinfo . argnull [ 1 ] ) ) return ( Datum ) 0 ;\n locfcinfo . isnull = false ;\n cmpresult = DatumGetInt32 ( FunctionCallInvoke ( & locfcinfo ) ) ;\n if ( locfcinfo . isnull ) return ( Datum ) 0 ;\n if ( cmpresult != 0 ) break ;\n i ++ ;\n }\n switch ( rctype ) {\n case ROWCOMPARE_LT : result = ( cmpresult < 0 ) ;\n break ;\n case ROWCOMPARE_LE : result = ( cmpresult <= 0 ) ;\n break ;\n case ROWCOMPARE_GE : result = ( cmpresult >= 0 ) ;\n break ;\n case ROWCOMPARE_GT : result = ( cmpresult > 0 ) ;\n break ;\n default : elog ( ERROR , \"unrecognized RowCompareType: %d\" , ( int ) rctype ) ;\n result = 0 ;\n break ;\n }\n * isNull = false ;\n return BoolGetDatum ( result ) ;\n }", "idx": 206}
{"hash": 7749168290238234888, "project": "debian", "size": 37, "label": 0, "functionSource": "static int test_compressed_stream_overflow ( xd3_stream * stream , int ignore ) {\n int ret ;\n int i ;\n uint8_t * buf ;\n if ( ( buf = ( uint8_t * ) malloc ( TWO_MEGS_AND_DELTA ) ) == NULL ) {\n return ENOMEM ;\n }\n memset ( buf , 0 , TWO_MEGS_AND_DELTA ) ;\n for ( i = 0 ;\n i < ( 2 << 20 ) ;\n i += 256 ) {\n int j ;\n int off = mt_random ( & static_mtrand ) % 10 ;\n for ( j = 0 ;\n j < 256 ;\n j ++ ) {\n buf [ i + j ] = j + off ;\n }\n }\n if ( SIZEOF_XOFF_T == 4 ) {\n ret = test_streaming ( stream , buf , buf + ( 1 << 20 ) , buf + ( 2 << 20 ) , ( 1 << 12 ) + 1 ) ;\n if ( ret == XD3_INVALID_INPUT && MSG_IS ( \"decoder file offset overflow\" ) ) {\n ret = 0 ;\n }\n else {\n XPR ( NT XD3_LIB_ERRMSG ( stream , ret ) ) ;\n stream -> msg = \"expected overflow condition\" ;\n ret = XD3_INTERNAL ;\n goto fail ;\n }\n }\n if ( ( ret = test_streaming ( stream , buf , buf + ( 1 << 20 ) , buf + ( 2 << 20 ) , << 12 ) ) ) {\n goto fail ;\n }\n fail : free ( buf ) ;\n return ret ;\n }", "idx": 207}
{"hash": -7455544248455991006, "project": "debian", "size": 4, "label": 0, "functionSource": "bool kvm_has_adjust_clock_stable ( void ) {\n int ret = kvm_check_extension ( kvm_state , KVM_CAP_ADJUST_CLOCK ) ;\n return ( ret == KVM_CLOCK_TSC_STABLE ) ;\n }", "idx": 208}
{"hash": 6632536031698733342, "project": "debian", "size": 9, "label": 0, "functionSource": "static int opt_show_format_entry ( void * optctx , const char * opt , const char * arg ) {\n char * buf = av_asprintf ( \"format=%s\" , arg ) ;\n int ret ;\n if ( ! buf ) return AVERROR ( ENOMEM ) ;\n av_log ( NULL , AV_LOG_WARNING , \"Option '%s' is deprecated, use '-show_entries format=%s' instead\\n\" , opt , arg ) ;\n ret = opt_show_entries ( optctx , opt , buf ) ;\n av_free ( buf ) ;\n return ret ;\n }", "idx": 209}
{"hash": 4187524518637656726, "project": "debian", "size": 153, "label": 0, "functionSource": "static int glob_in_dir ( const char * pattern , const char * directory , int flags , int ( * errfunc ) ( const char * , int ) , glob_t * pglob , size_t alloca_used ) {\n size_t dirlen = strlen ( directory ) ;\n void * stream = NULL ;\n struct globnames {\n struct globnames * next ;\n size_t count ;\n char * name [ 64 ] ;\n }\n ;\n # define INITIAL_COUNT sizeof ( init_names . name ) / sizeof ( init_names . name [ 0 ] ) struct globnames init_names ;\n struct globnames * names = & init_names ;\n struct globnames * names_alloca = & init_names ;\n size_t nfound = 0 ;\n size_t cur = 0 ;\n int meta ;\n int save ;\n alloca_used += sizeof ( init_names ) ;\n init_names . next = NULL ;\n init_names . count = INITIAL_COUNT ;\n meta = __glob_pattern_type ( pattern , ! ( flags & GLOB_NOESCAPE ) ) ;\n if ( meta == 0 && ( flags & ( GLOB_NOCHECK | GLOB_NOMAGIC ) ) ) {\n flags |= GLOB_NOCHECK ;\n }\n else if ( meta == 0 ) {\n union {\n struct stat st ;\n struct_stat64 st64 ;\n }\n ust ;\n size_t patlen = strlen ( pattern ) ;\n int alloca_fullname = __libc_use_alloca ( alloca_used + dirlen + 1 + patlen + 1 ) ;\n char * fullname ;\n if ( alloca_fullname ) fullname = alloca_account ( dirlen + 1 + patlen + 1 , alloca_used ) ;\n else {\n fullname = malloc ( dirlen + 1 + patlen + 1 ) ;\n if ( fullname == NULL ) return GLOB_NOSPACE ;\n }\n mempcpy ( mempcpy ( mempcpy ( fullname , directory , dirlen ) , \"/\" , 1 ) , pattern , patlen + 1 ) ;\n if ( ( __builtin_expect ( flags & GLOB_ALTDIRFUNC , 0 ) ? ( * pglob -> gl_stat ) ( fullname , & ust . st ) : __stat64 ( fullname , & ust . st64 ) ) == 0 ) flags |= GLOB_NOCHECK ;\n if ( __builtin_expect ( ! alloca_fullname , 0 ) ) free ( fullname ) ;\n }\n else {\n stream = ( __builtin_expect ( flags & GLOB_ALTDIRFUNC , 0 ) ? ( * pglob -> gl_opendir ) ( directory ) : opendir ( directory ) ) ;\n if ( stream == NULL ) {\n if ( errno != ENOTDIR && ( ( errfunc != NULL && ( * errfunc ) ( directory , errno ) ) || ( flags & GLOB_ERR ) ) ) return GLOB_ABORTED ;\n }\n else {\n # ifdef _LIBC int dfd = ( __builtin_expect ( flags & GLOB_ALTDIRFUNC , 0 ) ? - 1 : dirfd ( ( DIR * ) stream ) ) ;\n # endif int fnm_flags = ( ( ! ( flags & GLOB_PERIOD ) ? FNM_PERIOD : 0 ) | ( ( flags & GLOB_NOESCAPE ) ? FNM_NOESCAPE : 0 ) # if defined _AMIGA || defined VMS | FNM_CASEFOLD # endif ) ;\n flags |= GLOB_MAGCHAR ;\n while ( 1 ) {\n const char * name ;\n size_t len ;\n # if defined _LIBC && ! defined COMPILE_GLOB64 struct dirent64 * d ;\n union {\n struct dirent64 d64 ;\n char room [ offsetof ( struct dirent64 , d_name [ 0 ] ) + NAME_MAX + 1 ] ;\n }\n d64buf ;\n if ( __builtin_expect ( flags & GLOB_ALTDIRFUNC , 0 ) ) {\n struct dirent * d32 = ( * pglob -> gl_readdir ) ( stream ) ;\n if ( d32 != NULL ) {\n CONVERT_DIRENT_DIRENT64 ( & d64buf . d64 , d32 ) ;\n d = & d64buf . d64 ;\n }\n else d = NULL ;\n }\n else d = __readdir64 ( stream ) ;\n # else struct dirent * d = ( __builtin_expect ( flags & GLOB_ALTDIRFUNC , 0 ) ? ( ( struct dirent * ) ( * pglob -> gl_readdir ) ( stream ) ) : __readdir ( stream ) ) ;\n # endif if ( d == NULL ) break ;\n if ( ! REAL_DIR_ENTRY ( d ) ) continue ;\n if ( ( flags & GLOB_ONLYDIR ) && ! DIRENT_MIGHT_BE_DIR ( d ) ) continue ;\n name = d -> d_name ;\n if ( fnmatch ( pattern , name , fnm_flags ) == 0 ) {\n if ( ! DIRENT_MIGHT_BE_SYMLINK ( d ) || link_exists_p ( dfd , directory , dirlen , name , pglob , flags ) ) {\n if ( cur == names -> count ) {\n struct globnames * newnames ;\n size_t count = names -> count * 2 ;\n size_t size = ( sizeof ( struct globnames ) + ( ( count - INITIAL_COUNT ) * sizeof ( char * ) ) ) ;\n if ( __libc_use_alloca ( alloca_used + size ) ) newnames = names_alloca = alloca_account ( size , alloca_used ) ;\n else if ( ( newnames = malloc ( size ) ) == NULL ) goto memory_error ;\n newnames -> count = count ;\n newnames -> next = names ;\n names = newnames ;\n cur = 0 ;\n }\n len = NAMLEN ( d ) ;\n names -> name [ cur ] = ( char * ) malloc ( len + 1 ) ;\n if ( names -> name [ cur ] == NULL ) goto memory_error ;\n * ( ( char * ) mempcpy ( names -> name [ cur ++ ] , name , len ) ) = '\\0' ;\n ++ nfound ;\n }\n }\n }\n }\n }\n if ( nfound == 0 && ( flags & GLOB_NOCHECK ) ) {\n size_t len = strlen ( pattern ) ;\n nfound = 1 ;\n names -> name [ cur ] = ( char * ) malloc ( len + 1 ) ;\n if ( names -> name [ cur ] == NULL ) goto memory_error ;\n * ( ( char * ) mempcpy ( names -> name [ cur ++ ] , pattern , len ) ) = '\\0' ;\n }\n int result = GLOB_NOMATCH ;\n if ( nfound != 0 ) {\n result = 0 ;\n char * * new_gl_pathv ;\n new_gl_pathv = ( char * * ) realloc ( pglob -> gl_pathv , ( pglob -> gl_pathc + pglob -> gl_offs + nfound + 1 ) * sizeof ( char * ) ) ;\n if ( new_gl_pathv == NULL ) {\n memory_error : while ( 1 ) {\n struct globnames * old = names ;\n for ( size_t i = 0 ;\n i < cur ;\n ++ i ) free ( names -> name [ i ] ) ;\n names = names -> next ;\n if ( names == NULL ) {\n assert ( old == & init_names ) ;\n break ;\n }\n cur = names -> count ;\n if ( old == names_alloca ) names_alloca = names ;\n else free ( old ) ;\n }\n result = GLOB_NOSPACE ;\n }\n else {\n while ( 1 ) {\n struct globnames * old = names ;\n for ( size_t i = 0 ;\n i < cur ;\n ++ i ) new_gl_pathv [ pglob -> gl_offs + pglob -> gl_pathc ++ ] = names -> name [ i ] ;\n names = names -> next ;\n if ( names == NULL ) {\n assert ( old == & init_names ) ;\n break ;\n }\n cur = names -> count ;\n if ( old == names_alloca ) names_alloca = names ;\n else free ( old ) ;\n }\n pglob -> gl_pathv = new_gl_pathv ;\n pglob -> gl_pathv [ pglob -> gl_offs + pglob -> gl_pathc ] = NULL ;\n pglob -> gl_flags = flags ;\n }\n }\n if ( stream != NULL ) {\n save = errno ;\n if ( __builtin_expect ( flags & GLOB_ALTDIRFUNC , 0 ) ) ( * pglob -> gl_closedir ) ( stream ) ;\n else closedir ( stream ) ;\n __set_errno ( save ) ;\n }\n return result ;\n }", "idx": 210}
{"hash": -2607754285145856562, "project": "debian", "size": 44, "label": 0, "functionSource": "static ssize_t write_iso9660_data ( struct archive_write * a , const void * buff , size_t s ) {\n struct iso9660 * iso9660 = a -> format_data ;\n size_t ws ;\n if ( iso9660 -> temp_fd < 0 ) {\n archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , \"Couldn't create temporary file\" ) ;\n return ( ARCHIVE_FATAL ) ;\n }\n ws = s ;\n if ( iso9660 -> need_multi_extent && ( iso9660 -> cur_file -> cur_content -> size + ws ) >= ( MULTI_EXTENT_SIZE - LOGICAL_BLOCK_SIZE ) ) {\n struct content * con ;\n size_t ts ;\n ts = ( size_t ) ( MULTI_EXTENT_SIZE - LOGICAL_BLOCK_SIZE - iso9660 -> cur_file -> cur_content -> size ) ;\n if ( iso9660 -> zisofs . detect_magic ) zisofs_detect_magic ( a , buff , ts ) ;\n if ( iso9660 -> zisofs . making ) {\n if ( zisofs_write_to_temp ( a , buff , ts ) != ARCHIVE_OK ) return ( ARCHIVE_FATAL ) ;\n }\n else {\n if ( wb_write_to_temp ( a , buff , ts ) != ARCHIVE_OK ) return ( ARCHIVE_FATAL ) ;\n iso9660 -> cur_file -> cur_content -> size += ts ;\n }\n if ( wb_write_padding_to_temp ( a , iso9660 -> cur_file -> cur_content -> size ) != ARCHIVE_OK ) return ( ARCHIVE_FATAL ) ;\n iso9660 -> cur_file -> cur_content -> blocks = ( int ) ( ( iso9660 -> cur_file -> cur_content -> size + LOGICAL_BLOCK_SIZE - 1 ) >> LOGICAL_BLOCK_BITS ) ;\n ws -= ts ;\n buff = ( const void * ) ( ( ( const unsigned char * ) buff ) + ts ) ;\n con = calloc ( 1 , sizeof ( * con ) ) ;\n if ( con == NULL ) {\n archive_set_error ( & a -> archive , ENOMEM , \"Can't allocate content data\" ) ;\n return ( ARCHIVE_FATAL ) ;\n }\n con -> offset_of_temp = wb_offset ( a ) ;\n iso9660 -> cur_file -> cur_content -> next = con ;\n iso9660 -> cur_file -> cur_content = con ;\n # ifdef HAVE_ZLIB_H iso9660 -> zisofs . block_offset = 0 ;\n # endif }\n if ( iso9660 -> zisofs . detect_magic ) zisofs_detect_magic ( a , buff , ws ) ;\n if ( iso9660 -> zisofs . making ) {\n if ( zisofs_write_to_temp ( a , buff , ws ) != ARCHIVE_OK ) return ( ARCHIVE_FATAL ) ;\n }\n else {\n if ( wb_write_to_temp ( a , buff , ws ) != ARCHIVE_OK ) return ( ARCHIVE_FATAL ) ;\n iso9660 -> cur_file -> cur_content -> size += ws ;\n }\n return ( s ) ;\n }", "idx": 211}
{"hash": 3167715554364353813, "project": "debian", "size": 5, "label": 0, "functionSource": "static MagickBooleanType IsIPL ( const unsigned char * magick , const size_t length ) {\n if ( length < 4 ) return ( MagickFalse ) ;\n if ( LocaleNCompare ( ( const char * ) magick , \"data\" , 4 ) == 0 ) return ( MagickTrue ) ;\n return ( MagickFalse ) ;\n }", "idx": 212}
{"hash": -7470076990396875111, "project": "chrome", "size": 8, "label": 1, "functionSource": "static void kq_dealloc ( struct event_base * base , void * arg ) {\n struct kqop * kqop = arg ;\n if ( kqop -> changes ) free ( kqop -> changes ) ;\n if ( kqop -> events ) free ( kqop -> events ) ;\n if ( kqop -> kq >= 0 && kqop -> pid == getpid ( ) ) close ( kqop -> kq ) ;\n memset ( kqop , 0 , sizeof ( struct kqop ) ) ;\n free ( kqop ) ;\n }", "idx": 213}
{"hash": 1981604082870872490, "project": "chrome", "size": 5, "label": 1, "functionSource": "static int32_t u_printf_count_handler ( const u_printf_stream_handler * handler , void * context , ULocaleBundle * formatBundle , const u_printf_spec_info * info , const ufmt_args * args ) {\n int32_t * count = ( int32_t * ) ( args [ 0 ] . ptrValue ) ;\n * count = info -> fWidth ;\n return 0 ;\n }", "idx": 214}
{"hash": -5082285935423529157, "project": "debian", "size": 23, "label": 0, "functionSource": "static int dissect_rsl_ie_full_bcch_inf ( tvbuff_t * tvb , packet_info * pinfo _U_ , proto_tree * tree , int offset , gboolean is_mandatory ) {\n proto_item * ti ;\n proto_tree * ie_tree ;\n tvbuff_t * next_tvb ;\n guint16 length ;\n guint8 ie_id ;\n if ( is_mandatory == FALSE ) {\n ie_id = tvb_get_guint8 ( tvb , offset ) ;\n if ( ie_id != RSL_IE_FULL_BCCH_INF ) return offset ;\n }\n ie_tree = proto_tree_add_subtree ( tree , tvb , offset , 0 , ett_ie_full_bcch_inf , & ti , \"Full BCCH Information IE\" ) ;\n proto_tree_add_item ( ie_tree , hf_rsl_ie_id , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n offset ++ ;\n length = tvb_get_guint8 ( tvb , offset ) ;\n proto_item_set_len ( ti , length + 2 ) ;\n proto_tree_add_item ( ie_tree , hf_rsl_ie_length , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n offset ++ ;\n proto_tree_add_item ( ie_tree , hf_rsl_layer_3_message , tvb , offset , length , ENC_NA ) ;\n next_tvb = tvb_new_subset_length ( tvb , offset , length ) ;\n call_dissector ( gsm_a_ccch_handle , next_tvb , pinfo , top_tree ) ;\n offset = offset + length ;\n return offset ;\n }", "idx": 215}
{"hash": 7039307292471244756, "project": "debian", "size": 9, "label": 0, "functionSource": "static guint16 de_tp_ms_positioning_technology ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len _U_ , gchar * add_string _U_ , int string_len _U_ ) {\n guint32 curr_offset ;\n guchar oct ;\n curr_offset = offset ;\n oct = tvb_get_guint8 ( tvb , curr_offset ) ;\n proto_tree_add_uint_format_value ( tree , hf_gsm_a_dtap_ms_positioning_technology , tvb , curr_offset , 1 , oct , \"%s\" , val_to_str ( oct , gsm_positioning_technology_vals , \"Reserved (%d)\" ) ) ;\n curr_offset += 1 ;\n return ( curr_offset - offset ) ;\n }", "idx": 216}
{"hash": 6249489553242542670, "project": "debian", "size": 8, "label": 0, "functionSource": "attr_val * create_attr_ival ( int attr , int value ) {\n attr_val * my_val ;\n my_val = emalloc_zero ( sizeof ( * my_val ) ) ;\n my_val -> attr = attr ;\n my_val -> value . i = value ;\n my_val -> type = T_Integer ;\n return my_val ;\n }", "idx": 217}
{"hash": 1208165234047591297, "project": "debian", "size": 5, "label": 0, "functionSource": "proto_item * parseFloat ( proto_tree * tree , tvbuff_t * tvb , packet_info * pinfo _U_ , gint * pOffset , int hfIndex ) {\n proto_item * item = proto_tree_add_item ( tree , hfIndex , tvb , * pOffset , ( int ) sizeof ( gfloat ) , ENC_LITTLE_ENDIAN ) ;\n * pOffset += ( int ) sizeof ( gfloat ) ;\n return item ;\n }", "idx": 218}
{"hash": -3456072850741599569, "project": "debian", "size": 147, "label": 0, "functionSource": "static int dissect_pbb_addressblock ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , guint offset , guint maxoffset , guint8 addressType , guint8 addressSize ) {\n guint8 addr [ MAX_ADDR_SIZE ] ;\n guint8 numAddr ;\n guint8 address_flags ;\n guint8 head_length = 0 , tail_length = 0 ;\n guint block_length = 0 , midSize = 0 ;\n guint block_index = 0 , head_index = 0 , tail_index = 0 , mid_index = 0 , prefix_index = 0 ;\n proto_tree * addr_tree = NULL ;\n proto_tree * addrFlags_tree = NULL ;\n proto_tree * addrValue_tree = NULL ;\n proto_item * addr_item = NULL ;\n proto_item * addrFlags_item = NULL ;\n proto_item * addrValue_item = NULL ;\n int i = 0 ;\n if ( maxoffset - offset < 2 ) {\n proto_tree_add_expert_format ( tree , pinfo , & ei_packetbb_error , tvb , offset , maxoffset - offset , \"Not enough octets for minimal addressblock header\" ) ;\n return tvb_reported_length ( tvb ) ;\n }\n DISSECTOR_ASSERT ( addressSize <= MAX_ADDR_SIZE ) ;\n memset ( addr , 0 , addressSize ) ;\n block_length = 2 ;\n block_index = offset ;\n midSize = addressSize ;\n numAddr = tvb_get_guint8 ( tvb , offset ++ ) ;\n address_flags = tvb_get_guint8 ( tvb , offset ++ ) ;\n if ( ( address_flags & ADDR_HASHEAD ) != 0 ) {\n head_index = offset ;\n if ( maxoffset - offset <= 0 ) {\n proto_tree_add_expert_format ( tree , pinfo , & ei_packetbb_error , tvb , offset , maxoffset - offset , \"Not enough octets for addressblock head\" ) ;\n return tvb_reported_length ( tvb ) ;\n }\n head_length = tvb_get_guint8 ( tvb , offset ++ ) ;\n if ( head_length > addressSize - 1 ) {\n proto_tree_add_expert_format ( tree , pinfo , & ei_packetbb_error , tvb , offset , maxoffset - offset , \"address head length is too long\" ) ;\n return tvb_reported_length ( tvb ) ;\n }\n if ( maxoffset - offset < head_length ) {\n proto_tree_add_expert_format ( tree , pinfo , & ei_packetbb_error , tvb , offset , maxoffset - offset , \"Not enough octets for addressblock head\" ) ;\n return tvb_reported_length ( tvb ) ;\n }\n tvb_memcpy ( tvb , addr , offset , head_length ) ;\n midSize -= head_length ;\n block_length += ( head_length + 1 ) ;\n offset += head_length ;\n }\n if ( ( address_flags & ADDR_HASZEROTAIL ) != 0 ) {\n tail_index = offset ;\n if ( maxoffset - offset <= 0 ) {\n proto_tree_add_expert_format ( tree , pinfo , & ei_packetbb_error , tvb , offset , maxoffset - offset , \"Not enough octets for addressblock tail\" ) ;\n return tvb_reported_length ( tvb ) ;\n }\n tail_length = tvb_get_guint8 ( tvb , offset ++ ) ;\n if ( tail_length > addressSize - 1 - head_length ) {\n proto_tree_add_expert_format ( tree , pinfo , & ei_packetbb_error , tvb , offset , maxoffset - offset , \"address tail length is too long\" ) ;\n return tvb_reported_length ( tvb ) ;\n }\n midSize -= tail_length ;\n block_length ++ ;\n }\n else if ( ( address_flags & ADDR_HASFULLTAIL ) != 0 ) {\n tail_index = offset ;\n if ( maxoffset - offset <= 0 ) {\n proto_tree_add_expert_format ( tree , pinfo , & ei_packetbb_error , tvb , offset , maxoffset - offset , \"Not enough octets for addressblock tail\" ) ;\n return tvb_reported_length ( tvb ) ;\n }\n tail_length = tvb_get_guint8 ( tvb , offset ++ ) ;\n if ( tail_length > addressSize - 1 - head_length ) {\n proto_tree_add_expert_format ( tree , pinfo , & ei_packetbb_error , tvb , offset , maxoffset - offset , \"address tail length is too long\" ) ;\n return tvb_reported_length ( tvb ) ;\n }\n if ( maxoffset - offset < tail_length ) {\n proto_tree_add_expert_format ( tree , pinfo , & ei_packetbb_error , tvb , offset , maxoffset - offset , \"Not enough octets for addressblock tail\" ) ;\n return tvb_reported_length ( tvb ) ;\n }\n tvb_memcpy ( tvb , & addr [ addressSize - tail_length ] , offset , tail_length ) ;\n midSize -= tail_length ;\n block_length += ( tail_length + 1 ) ;\n offset += tail_length ;\n }\n mid_index = offset ;\n block_length += numAddr * midSize ;\n offset += numAddr * midSize ;\n if ( ( address_flags & ADDR_HASSINGLEPRELEN ) != 0 ) {\n prefix_index = offset ;\n block_length ++ ;\n }\n else if ( ( address_flags & ADDR_HASMULTIPRELEN ) != 0 ) {\n prefix_index = offset ;\n block_length += numAddr ;\n }\n if ( maxoffset < block_index + block_length ) {\n proto_tree_add_expert_format ( tree , pinfo , & ei_packetbb_error , tvb , offset , maxoffset - offset , \"Not enough octets for address block\" ) ;\n return maxoffset ;\n }\n addr_item = proto_tree_add_item ( tree , hf_packetbb_addr , tvb , block_index , block_length , ENC_NA ) ;\n addr_tree = proto_item_add_subtree ( addr_item , ett_packetbb_addr ) ;\n proto_item_append_text ( addr_item , \" (%d addresses)\" , numAddr ) ;\n proto_tree_add_item ( addr_tree , hf_packetbb_addr_num , tvb , block_index , 1 , ENC_BIG_ENDIAN ) ;\n addrFlags_item = proto_tree_add_item ( addr_tree , hf_packetbb_addr_flags , tvb , block_index + 1 , 1 , ENC_BIG_ENDIAN ) ;\n addrFlags_tree = proto_item_add_subtree ( addrFlags_item , ett_packetbb_addr_flags ) ;\n proto_tree_add_item ( addrFlags_tree , hf_packetbb_addr_flags_hashead , tvb , block_index + 1 , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( addrFlags_tree , hf_packetbb_addr_flags_hasfulltail , tvb , block_index + 1 , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( addrFlags_tree , hf_packetbb_addr_flags_haszerotail , tvb , block_index + 1 , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( addrFlags_tree , hf_packetbb_addr_flags_hassingleprelen , tvb , block_index + 1 , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( addrFlags_tree , hf_packetbb_addr_flags_hasmultiprelen , tvb , block_index + 1 , 1 , ENC_BIG_ENDIAN ) ;\n if ( ( address_flags & ADDR_HASHEAD ) != 0 ) {\n proto_tree_add_item ( addr_tree , hf_packetbb_addr_head , tvb , head_index , head_length + 1 , ENC_NA ) ;\n }\n if ( ( address_flags & ADDR_HASFULLTAIL ) != 0 ) {\n proto_tree_add_item ( addr_tree , hf_packetbb_addr_tail , tvb , tail_index , tail_length + 1 , ENC_NA ) ;\n }\n else if ( ( address_flags & ADDR_HASZEROTAIL ) != 0 ) {\n proto_tree_add_item ( addr_tree , hf_packetbb_addr_tail , tvb , tail_index , 1 , ENC_NA ) ;\n }\n for ( i = 0 ;\n i < numAddr ;\n i ++ ) {\n guint32 ipv4 = 0 ;\n guint8 prefix = addressSize * 8 ;\n tvb_memcpy ( tvb , & addr [ head_length ] , mid_index + midSize * i , midSize ) ;\n ipv4 = ( addr [ 3 ] << 24 ) + ( addr [ 2 ] << 16 ) + ( addr [ 1 ] << 8 ) + addr [ 0 ] ;\n switch ( addressType ) {\n case 0 : addrValue_item = proto_tree_add_ipv4 ( addr_tree , hf_packetbb_addr_value [ addressType ] , tvb , mid_index , block_index + block_length - mid_index , ipv4 ) ;\n break ;\n case 1 : addrValue_item = proto_tree_add_ipv6 ( addr_tree , hf_packetbb_addr_value [ addressType ] , tvb , mid_index , block_index + block_length - mid_index , ( struct e_in6_addr * ) addr ) ;\n break ;\n case 2 : addrValue_item = proto_tree_add_ether ( addr_tree , hf_packetbb_addr_value [ addressType ] , tvb , mid_index , block_index + block_length - mid_index , addr ) ;\n break ;\n case 3 : addrValue_item = proto_tree_add_bytes ( addr_tree , hf_packetbb_addr_value [ addressType ] , tvb , mid_index , block_index + block_length - mid_index , addr ) ;\n break ;\n default : break ;\n }\n addrValue_tree = proto_item_add_subtree ( addrValue_item , ett_packetbb_addr_value ) ;\n proto_tree_add_item ( addrValue_tree , hf_packetbb_addr_value_mid , tvb , mid_index + midSize * i , midSize , ENC_NA ) ;\n if ( ( address_flags & ADDR_HASSINGLEPRELEN ) != 0 ) {\n prefix = tvb_get_guint8 ( tvb , prefix_index ) ;\n proto_tree_add_item ( addrValue_tree , hf_packetbb_addr_value_prefix , tvb , prefix_index , 1 , ENC_BIG_ENDIAN ) ;\n }\n else if ( ( address_flags & ADDR_HASMULTIPRELEN ) != 0 ) {\n prefix = tvb_get_guint8 ( tvb , prefix_index + i ) ;\n proto_tree_add_item ( addrValue_tree , hf_packetbb_addr_value_prefix , tvb , prefix_index + i , 1 , ENC_BIG_ENDIAN ) ;\n }\n proto_item_append_text ( addrValue_item , \"/%d\" , prefix ) ;\n }\n offset = dissect_pbb_tlvblock ( tvb , pinfo , addr_tree , block_index + block_length , maxoffset , numAddr , TLV_CAT_ADDRESS ) ;\n return offset ;\n }", "idx": 219}
{"hash": 730982944360815735, "project": "debian", "size": 22, "label": 1, "functionSource": "static int idcin_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n IdcinContext * s = avctx -> priv_data ;\n const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;\n s -> buf = buf ;\n s -> size = buf_size ;\n if ( s -> frame . data [ 0 ] ) avctx -> release_buffer ( avctx , & s -> frame ) ;\n if ( ff_get_buffer ( avctx , & s -> frame ) ) {\n av_log ( avctx , AV_LOG_ERROR , \" id CIN Video: get_buffer() failed\\n\" ) ;\n return - 1 ;\n }\n idcin_decode_vlcs ( s ) ;\n if ( pal ) {\n s -> frame . palette_has_changed = 1 ;\n memcpy ( s -> pal , pal , AVPALETTE_SIZE ) ;\n }\n memcpy ( s -> frame . data [ 1 ] , s -> pal , AVPALETTE_SIZE ) ;\n * got_frame = 1 ;\n * ( AVFrame * ) data = s -> frame ;\n return buf_size ;\n }", "idx": 220}
{"hash": 7191899184788440065, "project": "debian", "size": 4, "label": 0, "functionSource": "static int fake_magic_space ( const char * , int ) # endif {\n rl_insert ( 1 , ' ' ) ;\n return 0 ;\n }", "idx": 221}
{"hash": 370610032569630438, "project": "debian", "size": 104, "label": 0, "functionSource": "int tls1_mac ( SSL * ssl , unsigned char * md , int send ) {\n SSL3_RECORD * rec ;\n unsigned char * seq ;\n EVP_MD_CTX * hash ;\n size_t md_size , orig_len ;\n int i ;\n EVP_MD_CTX hmac , * mac_ctx ;\n unsigned char header [ 13 ] ;\n int stream_mac = ( send ? ( ssl -> mac_flags & SSL_MAC_FLAG_WRITE_MAC_STREAM ) : ( ssl -> mac_flags & SSL_MAC_FLAG_READ_MAC_STREAM ) ) ;\n int t ;\n if ( send ) {\n rec = & ( ssl -> s3 -> wrec ) ;\n seq = & ( ssl -> s3 -> write_sequence [ 0 ] ) ;\n hash = ssl -> write_hash ;\n }\n else {\n rec = & ( ssl -> s3 -> rrec ) ;\n seq = & ( ssl -> s3 -> read_sequence [ 0 ] ) ;\n hash = ssl -> read_hash ;\n }\n t = EVP_MD_CTX_size ( hash ) ;\n OPENSSL_assert ( t >= 0 ) ;\n md_size = t ;\n if ( stream_mac ) {\n mac_ctx = hash ;\n }\n else {\n EVP_MD_CTX_copy ( & hmac , hash ) ;\n mac_ctx = & hmac ;\n }\n if ( ssl -> version == DTLS1_VERSION || ssl -> version == DTLS1_BAD_VER ) {\n unsigned char dtlsseq [ 8 ] , * p = dtlsseq ;\n s2n ( send ? ssl -> d1 -> w_epoch : ssl -> d1 -> r_epoch , p ) ;\n memcpy ( p , & seq [ 2 ] , 6 ) ;\n memcpy ( header , dtlsseq , 8 ) ;\n }\n else memcpy ( header , seq , 8 ) ;\n orig_len = rec -> length + md_size + ( ( unsigned int ) rec -> type >> 8 ) ;\n rec -> type &= 0xff ;\n header [ 8 ] = rec -> type ;\n header [ 9 ] = ( unsigned char ) ( ssl -> version >> 8 ) ;\n header [ 10 ] = ( unsigned char ) ( ssl -> version ) ;\n header [ 11 ] = ( rec -> length ) >> 8 ;\n header [ 12 ] = ( rec -> length ) & 0xff ;\n if ( ! send && EVP_CIPHER_CTX_mode ( ssl -> enc_read_ctx ) == EVP_CIPH_CBC_MODE && ssl3_cbc_record_digest_supported ( mac_ctx ) ) {\n ssl3_cbc_digest_record ( mac_ctx , md , & md_size , header , rec -> input , rec -> length + md_size , orig_len , ssl -> s3 -> read_mac_secret , ssl -> s3 -> read_mac_secret_size , 0 ) ;\n }\n else {\n EVP_DigestSignUpdate ( mac_ctx , header , sizeof ( header ) ) ;\n EVP_DigestSignUpdate ( mac_ctx , rec -> input , rec -> length ) ;\n t = EVP_DigestSignFinal ( mac_ctx , md , & md_size ) ;\n OPENSSL_assert ( t > 0 ) ;\n # ifdef OPENSSL_FIPS if ( ! send && FIPS_mode ( ) ) tls_fips_digest_extra ( ssl -> enc_read_ctx , mac_ctx , rec -> input , rec -> length , orig_len ) ;\n # endif }\n if ( ! stream_mac ) EVP_MD_CTX_cleanup ( & hmac ) ;\n # ifdef TLS_DEBUG printf ( \"sec=\" ) ;\n {\n unsigned int z ;\n for ( z = 0 ;\n z < md_size ;\n z ++ ) printf ( \"%02X \" , mac_sec [ z ] ) ;\n printf ( \"\\n\" ) ;\n }\n printf ( \"seq=\" ) ;\n {\n int z ;\n for ( z = 0 ;\n z < 8 ;\n z ++ ) printf ( \"%02X \" , seq [ z ] ) ;\n printf ( \"\\n\" ) ;\n }\n printf ( \"buf=\" ) ;\n {\n int z ;\n for ( z = 0 ;\n z < 5 ;\n z ++ ) printf ( \"%02X \" , buf [ z ] ) ;\n printf ( \"\\n\" ) ;\n }\n printf ( \"rec=\" ) ;\n {\n unsigned int z ;\n for ( z = 0 ;\n z < rec -> length ;\n z ++ ) printf ( \"%02X \" , buf [ z ] ) ;\n printf ( \"\\n\" ) ;\n }\n # endif if ( ssl -> version != DTLS1_VERSION && ssl -> version != DTLS1_BAD_VER ) {\n for ( i = 7 ;\n i >= 0 ;\n i -- ) {\n ++ seq [ i ] ;\n if ( seq [ i ] != 0 ) break ;\n }\n }\n # ifdef TLS_DEBUG {\n unsigned int z ;\n for ( z = 0 ;\n z < md_size ;\n z ++ ) printf ( \"%02X \" , md [ z ] ) ;\n printf ( \"\\n\" ) ;\n }\n # endif return ( md_size ) ;\n }", "idx": 222}
{"hash": -7456613930747243098, "project": "debian", "size": 4, "label": 0, "functionSource": "static void get_bits_align32 ( GetBitContext * s ) {\n int n = ( - get_bits_count ( s ) ) & 31 ;\n if ( n ) skip_bits ( s , n ) ;\n }", "idx": 223}
{"hash": -3996653205403580145, "project": "chrome", "size": 3, "label": 0, "functionSource": "static hb_bool_t hb_ucdn_compose ( hb_unicode_funcs_t * ufuncs , hb_codepoint_t a , hb_codepoint_t b , hb_codepoint_t * ab , void * user_data HB_UNUSED ) {\n return ucdn_compose ( ab , a , b ) ;\n }", "idx": 224}
{"hash": 2335222688263906532, "project": "debian", "size": 48, "label": 1, "functionSource": "static int rv34_decode_inter_mb_header ( RV34DecContext * r , int8_t * intra_types ) {\n MpegEncContext * s = & r -> s ;\n GetBitContext * gb = & s -> gb ;\n int mb_pos = s -> mb_x + s -> mb_y * s -> mb_stride ;\n int i , t ;\n r -> block_type = r -> decode_mb_info ( r ) ;\n if ( r -> block_type == - 1 ) return - 1 ;\n s -> current_picture_ptr -> f . mb_type [ mb_pos ] = rv34_mb_type_to_lavc [ r -> block_type ] ;\n r -> mb_type [ mb_pos ] = r -> block_type ;\n if ( r -> block_type == RV34_MB_SKIP ) {\n if ( s -> pict_type == AV_PICTURE_TYPE_P ) r -> mb_type [ mb_pos ] = RV34_MB_P_16x16 ;\n if ( s -> pict_type == AV_PICTURE_TYPE_B ) r -> mb_type [ mb_pos ] = RV34_MB_B_DIRECT ;\n }\n r -> is16 = ! ! IS_INTRA16x16 ( s -> current_picture_ptr -> f . mb_type [ mb_pos ] ) ;\n rv34_decode_mv ( r , r -> block_type ) ;\n if ( r -> block_type == RV34_MB_SKIP ) {\n fill_rectangle ( intra_types , 4 , 4 , r -> intra_types_stride , 0 , sizeof ( intra_types [ 0 ] ) ) ;\n return 0 ;\n }\n r -> chroma_vlc = 1 ;\n r -> luma_vlc = 0 ;\n if ( IS_INTRA ( s -> current_picture_ptr -> f . mb_type [ mb_pos ] ) ) {\n if ( r -> is16 ) {\n t = get_bits ( gb , 2 ) ;\n fill_rectangle ( intra_types , 4 , 4 , r -> intra_types_stride , t , sizeof ( intra_types [ 0 ] ) ) ;\n r -> luma_vlc = 2 ;\n }\n else {\n if ( r -> decode_intra_types ( r , gb , intra_types ) < 0 ) return - 1 ;\n r -> luma_vlc = 1 ;\n }\n r -> chroma_vlc = 0 ;\n r -> cur_vlcs = choose_vlc_set ( r -> si . quant , r -> si . vlc_set , 0 ) ;\n }\n else {\n for ( i = 0 ;\n i < 16 ;\n i ++ ) intra_types [ ( i & 3 ) + ( i >> 2 ) * r -> intra_types_stride ] = 0 ;\n r -> cur_vlcs = choose_vlc_set ( r -> si . quant , r -> si . vlc_set , 1 ) ;\n if ( r -> mb_type [ mb_pos ] == RV34_MB_P_MIX16x16 ) {\n r -> is16 = 1 ;\n r -> chroma_vlc = 1 ;\n r -> luma_vlc = 2 ;\n r -> cur_vlcs = choose_vlc_set ( r -> si . quant , r -> si . vlc_set , 0 ) ;\n }\n }\n return rv34_decode_cbp ( gb , r -> cur_vlcs , r -> is16 ) ;\n }", "idx": 225}
{"hash": -1929262071302712016, "project": "debian", "size": 5, "label": 0, "functionSource": "static void * Type_MPE_Dup ( struct _cms_typehandler_struct * self , const void * Ptr , cmsUInt32Number n ) {\n return ( void * ) cmsPipelineDup ( ( cmsPipeline * ) Ptr ) ;\n cmsUNUSED_PARAMETER ( n ) ;\n cmsUNUSED_PARAMETER ( self ) ;\n }", "idx": 226}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_INTEGER_27_78 ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_constrained_integer ( tvb , offset , actx , tree , hf_index , 27U , 78U , NULL , FALSE ) ;\n return offset ;\n }", "idx": 227}
{"hash": 8971107218655826309, "project": "chrome", "size": 10, "label": 0, "functionSource": "static void ustr_resize ( struct UString * s , int32_t len , UErrorCode * status ) {\n if ( U_FAILURE ( * status ) ) return ;\n s -> fChars = ( UChar * ) uprv_realloc ( s -> fChars , sizeof ( UChar ) * ( len + 1 ) ) ;\n if ( s -> fChars == 0 ) {\n * status = U_MEMORY_ALLOCATION_ERROR ;\n s -> fLength = s -> fCapacity = 0 ;\n return ;\n }\n s -> fCapacity = len ;\n }", "idx": 228}
{"hash": -7455544248455991006, "project": "debian", "size": 3, "label": 0, "functionSource": "bool kvm_enable_x2apic ( void ) {\n return MEMORIZE ( kvm_x2apic_api_set_flags ( KVM_X2APIC_API_USE_32BIT_IDS | KVM_X2APIC_API_DISABLE_BROADCAST_QUIRK ) , has_x2apic_api ) ;\n }", "idx": 229}
{"hash": 4489017523191997023, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h225_VoiceCaps ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_VoiceCaps , VoiceCaps_sequence ) ;\n return offset ;\n }", "idx": 230}
{"hash": -2928324134072492299, "project": "debian", "size": 21, "label": 0, "functionSource": "void h248_calls_init_tap ( void ) {\n GString * error_string ;\n if ( have_megaco_tap_listener == FALSE ) {\n error_string = register_tap_listener ( \"megaco\" , & ( the_tapinfo_struct . megaco_dummy ) , NULL , 0 , voip_calls_dlg_reset , h248_calls_packet , voip_calls_dlg_draw ) ;\n if ( error_string != NULL ) {\n simple_dialog ( ESD_TYPE_ERROR , ESD_BTN_OK , \"%s\" , error_string -> str ) ;\n g_string_free ( error_string , TRUE ) ;\n exit ( 1 ) ;\n }\n have_megaco_tap_listener = TRUE ;\n }\n if ( have_h248_tap_listener == FALSE ) {\n error_string = register_tap_listener ( \"h248\" , & ( the_tapinfo_struct . h248_dummy ) , NULL , 0 , voip_calls_dlg_reset , h248_calls_packet , voip_calls_dlg_draw ) ;\n if ( error_string != NULL ) {\n simple_dialog ( ESD_TYPE_ERROR , ESD_BTN_OK , \"%s\" , error_string -> str ) ;\n g_string_free ( error_string , TRUE ) ;\n exit ( 1 ) ;\n }\n have_h248_tap_listener = TRUE ;\n }\n }", "idx": 231}
{"hash": -1145838621747570454, "project": "debian", "size": 18, "label": 0, "functionSource": "struct key * key_lookup ( key_serial_t id ) {\n struct rb_node * n ;\n struct key * key ;\n spin_lock ( & key_serial_lock ) ;\n n = key_serial_tree . rb_node ;\n while ( n ) {\n key = rb_entry ( n , struct key , serial_node ) ;\n if ( id < key -> serial ) n = n -> rb_left ;\n else if ( id > key -> serial ) n = n -> rb_right ;\n else goto found ;\n }\n not_found : key = ERR_PTR ( - ENOKEY ) ;\n goto error ;\n found : if ( atomic_read ( & key -> usage ) == 0 ) goto not_found ;\n __key_get ( key ) ;\n error : spin_unlock ( & key_serial_lock ) ;\n return key ;\n }", "idx": 232}
{"hash": -2908211205972632000, "project": "debian", "size": 6, "label": 0, "functionSource": "void mainwindow_destroy_half ( MAIN_WINDOW_REC * window ) {\n int really_quitting = quitting ;\n quitting = TRUE ;\n mainwindow_destroy ( window ) ;\n quitting = really_quitting ;\n }", "idx": 233}
{"hash": -6870389834356302891, "project": "debian", "size": 50, "label": 0, "functionSource": "int ff_rv_decode_dc ( MpegEncContext * s , int n ) {\n int code ;\n if ( n < 4 ) {\n code = get_vlc2 ( & s -> gb , rv_dc_lum . table , DC_VLC_BITS , 2 ) ;\n if ( code < 0 ) {\n code = get_bits ( & s -> gb , 7 ) ;\n if ( code == 0x7c ) {\n code = ( int8_t ) ( get_bits ( & s -> gb , 7 ) + 1 ) ;\n }\n else if ( code == 0x7d ) {\n code = - 128 + get_bits ( & s -> gb , 7 ) ;\n }\n else if ( code == 0x7e ) {\n if ( get_bits1 ( & s -> gb ) == 0 ) code = ( int8_t ) ( get_bits ( & s -> gb , 8 ) + 1 ) ;\n else code = ( int8_t ) ( get_bits ( & s -> gb , 8 ) ) ;\n }\n else if ( code == 0x7f ) {\n skip_bits ( & s -> gb , 11 ) ;\n code = 1 ;\n }\n }\n else {\n code -= 128 ;\n }\n }\n else {\n code = get_vlc2 ( & s -> gb , rv_dc_chrom . table , DC_VLC_BITS , 2 ) ;\n if ( code < 0 ) {\n code = get_bits ( & s -> gb , 9 ) ;\n if ( code == 0x1fc ) {\n code = ( int8_t ) ( get_bits ( & s -> gb , 7 ) + 1 ) ;\n }\n else if ( code == 0x1fd ) {\n code = - 128 + get_bits ( & s -> gb , 7 ) ;\n }\n else if ( code == 0x1fe ) {\n skip_bits ( & s -> gb , 9 ) ;\n code = 1 ;\n }\n else {\n av_log ( s -> avctx , AV_LOG_ERROR , \"chroma dc error\\n\" ) ;\n return 0xffff ;\n }\n }\n else {\n code -= 128 ;\n }\n }\n return - code ;\n }", "idx": 234}
{"hash": -8225252931914868675, "project": "chrome", "size": 25, "label": 0, "functionSource": "static void variance_neon_w8 ( const uint8_t * a , int a_stride , const uint8_t * b , int b_stride , int w , int h , unsigned int * sse , int * sum ) {\n int i , j ;\n int16x8_t v_sum = vdupq_n_s16 ( 0 ) ;\n int32x4_t v_sse_lo = vdupq_n_s32 ( 0 ) ;\n int32x4_t v_sse_hi = vdupq_n_s32 ( 0 ) ;\n for ( i = 0 ;\n i < h ;\n ++ i ) {\n for ( j = 0 ;\n j < w ;\n j += 8 ) {\n const uint8x8_t v_a = vld1_u8 ( & a [ j ] ) ;\n const uint8x8_t v_b = vld1_u8 ( & b [ j ] ) ;\n const uint16x8_t v_diff = vsubl_u8 ( v_a , v_b ) ;\n const int16x8_t sv_diff = vreinterpretq_s16_u16 ( v_diff ) ;\n v_sum = vaddq_s16 ( v_sum , sv_diff ) ;\n v_sse_lo = vmlal_s16 ( v_sse_lo , vget_low_s16 ( sv_diff ) , vget_low_s16 ( sv_diff ) ) ;\n v_sse_hi = vmlal_s16 ( v_sse_hi , vget_high_s16 ( sv_diff ) , vget_high_s16 ( sv_diff ) ) ;\n }\n a += a_stride ;\n b += b_stride ;\n }\n * sum = horizontal_add_s16x8 ( v_sum ) ;\n * sse = ( unsigned int ) horizontal_add_s32x4 ( vaddq_s32 ( v_sse_lo , v_sse_hi ) ) ;\n }", "idx": 235}
{"hash": 6675626110148442062, "project": "debian", "size": 11, "label": 1, "functionSource": "static int mem_resize ( jas_stream_memobj_t * m , int bufsize ) {\n unsigned char * buf ;\n assert ( m -> buf_ ) ;\n assert ( bufsize >= 0 ) ;\n if ( ! ( buf = jas_realloc2 ( m -> buf_ , bufsize , sizeof ( unsigned char ) ) ) ) {\n return - 1 ;\n }\n m -> buf_ = buf ;\n m -> bufsize_ = bufsize ;\n return 0 ;\n }", "idx": 236}
{"hash": -3559021711340554904, "project": "debian", "size": 13, "label": 0, "functionSource": "static List * fetch_function_defaults ( HeapTuple func_tuple ) {\n List * defaults ;\n Datum proargdefaults ;\n bool isnull ;\n char * str ;\n proargdefaults = SysCacheGetAttr ( PROCOID , func_tuple , Anum_pg_proc_proargdefaults , & isnull ) ;\n if ( isnull ) elog ( ERROR , \"not enough default arguments\" ) ;\n str = TextDatumGetCString ( proargdefaults ) ;\n defaults = ( List * ) stringToNode ( str ) ;\n Assert ( IsA ( defaults , List ) ) ;\n pfree ( str ) ;\n return defaults ;\n }", "idx": 237}
{"hash": -1929262071302712016, "project": "debian", "size": 15, "label": 0, "functionSource": "cmsTagDescriptor * _cmsGetTagDescriptor ( cmsContext ContextID , cmsTagSignature sig ) {\n _cmsTagLinkedList * pt ;\n _cmsTagPluginChunkType * TagPluginChunk = ( _cmsTagPluginChunkType * ) _cmsContextGetClientChunk ( ContextID , TagPlugin ) ;\n for ( pt = TagPluginChunk -> Tag ;\n pt != NULL ;\n pt = pt -> Next ) {\n if ( sig == pt -> Signature ) return & pt -> Descriptor ;\n }\n for ( pt = SupportedTags ;\n pt != NULL ;\n pt = pt -> Next ) {\n if ( sig == pt -> Signature ) return & pt -> Descriptor ;\n }\n return NULL ;\n }", "idx": 238}
{"hash": -1321749842392027937, "project": "chrome", "size": 26, "label": 0, "functionSource": "void vp8_optimize_mby ( MACROBLOCK * x ) {\n int b ;\n int type ;\n int has_2nd_order ;\n ENTROPY_CONTEXT_PLANES t_above , t_left ;\n ENTROPY_CONTEXT * ta ;\n ENTROPY_CONTEXT * tl ;\n if ( ! x -> e_mbd . above_context ) return ;\n if ( ! x -> e_mbd . left_context ) return ;\n vpx_memcpy ( & t_above , x -> e_mbd . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;\n vpx_memcpy ( & t_left , x -> e_mbd . left_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;\n ta = ( ENTROPY_CONTEXT * ) & t_above ;\n tl = ( ENTROPY_CONTEXT * ) & t_left ;\n has_2nd_order = ( x -> e_mbd . mode_info_context -> mbmi . mode != B_PRED && x -> e_mbd . mode_info_context -> mbmi . mode != SPLITMV ) ;\n type = has_2nd_order ? PLANE_TYPE_Y_NO_DC : PLANE_TYPE_Y_WITH_DC ;\n for ( b = 0 ;\n b < 16 ;\n b ++ ) {\n optimize_b ( x , b , type , ta + vp8_block2above [ b ] , tl + vp8_block2left [ b ] ) ;\n }\n if ( has_2nd_order ) {\n b = 24 ;\n optimize_b ( x , b , PLANE_TYPE_Y2 , ta + vp8_block2above [ b ] , tl + vp8_block2left [ b ] ) ;\n check_reset_2nd_coeffs ( & x -> e_mbd , PLANE_TYPE_Y2 , ta + vp8_block2above [ b ] , tl + vp8_block2left [ b ] ) ;\n }\n }", "idx": 239}
{"hash": -2478888184195421052, "project": "debian", "size": 13, "label": 0, "functionSource": "static void display_mouse_define ( DisplayChangeListener * dcl , QEMUCursor * c ) {\n SimpleSpiceDisplay * ssd = container_of ( dcl , SimpleSpiceDisplay , dcl ) ;\n qemu_mutex_lock ( & ssd -> lock ) ;\n if ( ssd -> ptr_move ) {\n g_free ( ssd -> ptr_move ) ;\n ssd -> ptr_move = NULL ;\n }\n if ( ssd -> ptr_define ) {\n g_free ( ssd -> ptr_define ) ;\n }\n ssd -> ptr_define = qemu_spice_create_cursor_update ( ssd , c ) ;\n qemu_mutex_unlock ( & ssd -> lock ) ;\n }", "idx": 240}
{"hash": -7690167309709817279, "project": "debian", "size": 3, "label": 0, "functionSource": "static int sockstat_seq_open ( struct inode * inode , struct file * file ) {\n return single_open_net ( inode , file , sockstat_seq_show ) ;\n }", "idx": 241}
{"hash": 7607805321589710329, "project": "debian", "size": 10, "label": 0, "functionSource": "int zcvx ( i_ctx_t * i_ctx_p ) {\n os_ptr op = osp ;\n ref * aop ;\n uint opidx ;\n check_op ( 1 ) ;\n if ( r_has_type ( op , t_operator ) && ( ( opidx = op_index ( op ) ) == 0 || op_def_is_internal ( op_index_def ( opidx ) ) ) ) return_error ( gs_error_rangecheck ) ;\n aop = ACCESS_REF ( op ) ;\n r_set_attrs ( aop , a_executable ) ;\n return 0 ;\n }", "idx": 242}
{"hash": 3966033627990943399, "project": "chrome", "size": 7, "label": 0, "functionSource": "static void getSingleRun ( UBiDi * pBiDi , UBiDiLevel level ) {\n pBiDi -> runs = pBiDi -> simpleRuns ;\n pBiDi -> runCount = 1 ;\n pBiDi -> runs [ 0 ] . logicalStart = MAKE_INDEX_ODD_PAIR ( 0 , level ) ;\n pBiDi -> runs [ 0 ] . visualLimit = pBiDi -> length ;\n pBiDi -> runs [ 0 ] . insertRemove = 0 ;\n }", "idx": 243}
{"hash": -7434014980763120366, "project": "debian", "size": 156, "label": 0, "functionSource": "int dissect_ber_choice ( asn1_ctx_t * actx , proto_tree * parent_tree , tvbuff_t * tvb , int offset , const ber_choice_t * choice , gint hf_id , gint ett_id , gint * branch_taken ) {\n gint8 ber_class ;\n gboolean pc , ind , imp_tag = FALSE ;\n gint32 tag ;\n guint32 len ;\n proto_tree * tree = parent_tree ;\n proto_item * item = NULL ;\n int end_offset , start_offset , count ;\n int hoffset = offset ;\n gint length ;\n tvbuff_t * next_tvb ;\n gboolean first_pass ;\n header_field_info * hfinfo ;\n const ber_choice_t * ch ;\n # ifdef DEBUG_BER_CHOICE {\n const char * name ;\n if ( hf_id >= 0 ) {\n hfinfo = proto_registrar_get_nth ( hf_id ) ;\n name = hfinfo -> name ;\n }\n else {\n name = \"unnamed\" ;\n }\n if ( tvb_reported_length_remaining ( tvb , offset ) > 3 ) {\n printf ( \"CHOICE dissect_ber_choice(%s) entered offset:%d len:%d %02x:%02x:%02x\\n\" , name , offset , tvb_reported_length_remaining ( tvb , offset ) , tvb_get_guint8 ( tvb , offset ) , tvb_get_guint8 ( tvb , offset + 1 ) , tvb_get_guint8 ( tvb , offset + 2 ) ) ;\n }\n else {\n printf ( \"CHOICE dissect_ber_choice(%s) entered len:%d\\n\" , name , tvb_reported_length_remaining ( tvb , offset ) ) ;\n }\n }\n # endif start_offset = offset ;\n if ( branch_taken ) {\n * branch_taken = - 1 ;\n }\n if ( tvb_reported_length_remaining ( tvb , offset ) == 0 ) {\n item = proto_tree_add_string_format_value ( parent_tree , hf_ber_error , tvb , offset , 0 , \"empty_choice\" , \"Empty choice was found\" ) ;\n expert_add_info ( actx -> pinfo , item , & ei_ber_empty_choice ) ;\n return offset ;\n }\n offset = get_ber_identifier ( tvb , offset , & ber_class , & pc , & tag ) ;\n offset = get_ber_length ( tvb , offset , & len , & ind ) ;\n end_offset = offset + len ;\n if ( hf_id >= 0 ) {\n hfinfo = proto_registrar_get_nth ( hf_id ) ;\n switch ( hfinfo -> type ) {\n case FT_UINT8 : case FT_UINT16 : case FT_UINT24 : case FT_UINT32 : break ;\n default : proto_tree_add_expert_format ( tree , actx -> pinfo , & ei_hf_field_not_integer_type , tvb , offset , len , \"dissect_ber_choice(): frame:%u offset:%d Was passed an HF field that was not integer type : %s\" , actx -> pinfo -> fd -> num , offset , hfinfo -> abbrev ) ;\n return end_offset ;\n }\n }\n ch = choice ;\n first_pass = TRUE ;\n while ( ch -> func || first_pass ) {\n if ( branch_taken ) {\n ( * branch_taken ) ++ ;\n }\n if ( ! ch -> func ) {\n first_pass = FALSE ;\n ch = choice ;\n if ( branch_taken ) {\n * branch_taken = - 1 ;\n }\n continue ;\n }\n # ifdef DEBUG_BER_CHOICE printf ( \"CHOICE testing potential subdissector class[%p]:%d:(expected)%d tag:%d:(expected)%d flags:%d\\n\" , ch , ber_class , ch -> ber_class , tag , ch -> tag , ch -> flags ) ;\n # endif if ( ( first_pass && ( ( ( ch -> ber_class == ber_class ) && ( ch -> tag == tag ) ) || ( ( ch -> ber_class == ber_class ) && ( ch -> tag == - 1 ) && ( ch -> flags & BER_FLAGS_NOOWNTAG ) ) ) ) || ( ! first_pass && ( ( ( ch -> ber_class == BER_CLASS_ANY ) && ( ch -> tag == - 1 ) ) ) ) ) {\n if ( ! ( ch -> flags & BER_FLAGS_NOOWNTAG ) ) {\n hoffset = dissect_ber_identifier ( actx -> pinfo , tree , tvb , start_offset , NULL , NULL , NULL ) ;\n hoffset = dissect_ber_length ( actx -> pinfo , tree , tvb , hoffset , NULL , NULL ) ;\n start_offset = hoffset ;\n if ( ind ) {\n length = len - 2 ;\n }\n else {\n length = len ;\n }\n }\n else {\n length = end_offset - hoffset ;\n }\n if ( hf_id >= 0 ) {\n if ( parent_tree ) {\n item = proto_tree_add_uint ( parent_tree , hf_id , tvb , hoffset , end_offset - hoffset , ch -> value ) ;\n tree = proto_item_add_subtree ( item , ett_id ) ;\n }\n }\n # ifdef REMOVED if ( first_pass ) next_tvb = ber_tvb_new_subset_length ( tvb , hoffset , length ) ;\n else next_tvb = tvb ;\n # endif next_tvb = ber_tvb_new_subset_length ( tvb , hoffset , length ) ;\n # ifdef DEBUG_BER_CHOICE {\n const char * name ;\n if ( hf_id >= 0 ) {\n hfinfo = proto_registrar_get_nth ( hf_id ) ;\n name = hfinfo -> name ;\n }\n else {\n name = \"unnamed\" ;\n }\n if ( tvb_reported_length_remaining ( next_tvb , 0 ) > 3 ) {\n printf ( \"CHOICE dissect_ber_choice(%s) calling subdissector start_offset:%d offset:%d len:%d %02x:%02x:%02x\\n\" , name , start_offset , offset , tvb_reported_length_remaining ( next_tvb , 0 ) , tvb_get_guint8 ( next_tvb , 0 ) , tvb_get_guint8 ( next_tvb , 1 ) , tvb_get_guint8 ( next_tvb , 2 ) ) ;\n }\n else {\n printf ( \"CHOICE dissect_ber_choice(%s) calling subdissector len:%d\\n\" , name , tvb_reported_length ( next_tvb ) ) ;\n }\n }\n # endif if ( next_tvb == NULL ) {\n THROW ( ReportedBoundsError ) ;\n }\n imp_tag = FALSE ;\n if ( ( ch -> flags & BER_FLAGS_IMPLTAG ) ) imp_tag = TRUE ;\n count = ch -> func ( imp_tag , next_tvb , 0 , actx , tree , * ch -> p_id ) ;\n # ifdef DEBUG_BER_CHOICE {\n const char * name ;\n if ( hf_id >= 0 ) {\n hfinfo = proto_registrar_get_nth ( hf_id ) ;\n name = hfinfo -> name ;\n }\n else {\n name = \"unnamed\" ;\n }\n printf ( \"CHOICE dissect_ber_choice(%s) subdissector ate %d bytes\\n\" , name , count ) ;\n }\n # endif if ( ( count == 0 ) && ( ( ( ch -> ber_class == ber_class ) && ( ch -> tag == - 1 ) && ( ch -> flags & BER_FLAGS_NOOWNTAG ) ) || ! first_pass ) ) {\n ch ++ ;\n # ifdef DEBUG_BER_CHOICE {\n const char * name ;\n if ( hf_id >= 0 ) {\n hfinfo = proto_registrar_get_nth ( hf_id ) ;\n name = hfinfo -> name ;\n }\n else {\n name = \"unnamed\" ;\n }\n printf ( \"CHOICE dissect_ber_choice(%s) trying again\\n\" , name ) ;\n }\n # endif continue ;\n }\n if ( ! ( ch -> flags & BER_FLAGS_NOOWNTAG ) ) {\n if ( ind ) {\n if ( show_internal_ber_fields ) {\n proto_tree_add_item ( tree , hf_ber_choice_eoc , tvb , end_offset - 2 , 2 , ENC_NA ) ;\n }\n }\n }\n return end_offset ;\n }\n ch ++ ;\n }\n if ( branch_taken ) {\n * branch_taken = - 1 ;\n }\n # ifdef REMOVED item = proto_tree_add_string_format_value ( tree , hf_ber_error , tvb , offset , len , \"missing_choice_field\" , \"This choice field was not found.\" ) ;\n expert_add_info ( actx -> pinfo , item , & ei_ber_choice_not_found ) ;\n return end_offset ;\n # endif return start_offset ;\n }", "idx": 244}
{"hash": -341028540041678099, "project": "debian", "size": 6, "label": 0, "functionSource": "static void __attribute__ ( ( __format__ ( __printf__ , 1 , 2 ) ) ) warning ( const char * fmt , ... ) {\n va_list ap ;\n va_start ( ap , fmt ) ;\n vwarning ( fmt , ap ) ;\n va_end ( ap ) ;\n }", "idx": 245}
{"hash": 378220832151730865, "project": "debian", "size": 37, "label": 0, "functionSource": "int qemuMonitorTextSendKey ( qemuMonitorPtr mon , unsigned int holdtime , unsigned int * keycodes , unsigned int nkeycodes ) {\n int i ;\n virBuffer buf = VIR_BUFFER_INITIALIZER ;\n char * cmd , * reply = NULL ;\n int ret = - 1 ;\n if ( nkeycodes > VIR_DOMAIN_SEND_KEY_MAX_KEYS || nkeycodes == 0 ) return - 1 ;\n virBufferAddLit ( & buf , \"sendkey \" ) ;\n for ( i = 0 ;\n i < nkeycodes ;\n i ++ ) {\n if ( keycodes [ i ] > 0xffff ) {\n qemuReportError ( VIR_ERR_OPERATION_FAILED , _ ( \"keycode %d is invalid: 0x%X\" ) , i , keycodes [ i ] ) ;\n virBufferFreeAndReset ( & buf ) ;\n return - 1 ;\n }\n if ( i ) virBufferAddChar ( & buf , '-' ) ;\n virBufferAsprintf ( & buf , \"0x%02X\" , keycodes [ i ] ) ;\n }\n if ( holdtime ) virBufferAsprintf ( & buf , \" %u\" , holdtime ) ;\n if ( virBufferError ( & buf ) ) {\n virReportOOMError ( ) ;\n return - 1 ;\n }\n cmd = virBufferContentAndReset ( & buf ) ;\n if ( qemuMonitorHMPCommand ( mon , cmd , & reply ) < 0 ) {\n qemuReportError ( VIR_ERR_OPERATION_FAILED , _ ( \"failed to send key using command '%s'\" ) , cmd ) ;\n goto cleanup ;\n }\n if ( STRNEQ ( reply , \"\" ) ) {\n qemuReportError ( VIR_ERR_OPERATION_FAILED , _ ( \"failed to send key '%s'\" ) , reply ) ;\n goto cleanup ;\n }\n ret = 0 ;\n cleanup : VIR_FREE ( cmd ) ;\n VIR_FREE ( reply ) ;\n return ret ;\n }", "idx": 246}
{"hash": 4180964683905830761, "project": "debian", "size": 41, "label": 0, "functionSource": "static inline u16 socket_type_to_security_class ( int family , int type , int protocol ) {\n switch ( family ) {\n case PF_UNIX : switch ( type ) {\n case SOCK_STREAM : case SOCK_SEQPACKET : return SECCLASS_UNIX_STREAM_SOCKET ;\n case SOCK_DGRAM : return SECCLASS_UNIX_DGRAM_SOCKET ;\n }\n break ;\n case PF_INET : case PF_INET6 : switch ( type ) {\n case SOCK_STREAM : if ( default_protocol_stream ( protocol ) ) return SECCLASS_TCP_SOCKET ;\n else return SECCLASS_RAWIP_SOCKET ;\n case SOCK_DGRAM : if ( default_protocol_dgram ( protocol ) ) return SECCLASS_UDP_SOCKET ;\n else return SECCLASS_RAWIP_SOCKET ;\n case SOCK_DCCP : return SECCLASS_DCCP_SOCKET ;\n default : return SECCLASS_RAWIP_SOCKET ;\n }\n break ;\n case PF_NETLINK : switch ( protocol ) {\n case NETLINK_ROUTE : return SECCLASS_NETLINK_ROUTE_SOCKET ;\n case NETLINK_SOCK_DIAG : return SECCLASS_NETLINK_TCPDIAG_SOCKET ;\n case NETLINK_NFLOG : return SECCLASS_NETLINK_NFLOG_SOCKET ;\n case NETLINK_XFRM : return SECCLASS_NETLINK_XFRM_SOCKET ;\n case NETLINK_SELINUX : return SECCLASS_NETLINK_SELINUX_SOCKET ;\n case NETLINK_ISCSI : return SECCLASS_NETLINK_ISCSI_SOCKET ;\n case NETLINK_AUDIT : return SECCLASS_NETLINK_AUDIT_SOCKET ;\n case NETLINK_FIB_LOOKUP : return SECCLASS_NETLINK_FIB_LOOKUP_SOCKET ;\n case NETLINK_CONNECTOR : return SECCLASS_NETLINK_CONNECTOR_SOCKET ;\n case NETLINK_NETFILTER : return SECCLASS_NETLINK_NETFILTER_SOCKET ;\n case NETLINK_DNRTMSG : return SECCLASS_NETLINK_DNRT_SOCKET ;\n case NETLINK_KOBJECT_UEVENT : return SECCLASS_NETLINK_KOBJECT_UEVENT_SOCKET ;\n case NETLINK_GENERIC : return SECCLASS_NETLINK_GENERIC_SOCKET ;\n case NETLINK_SCSITRANSPORT : return SECCLASS_NETLINK_SCSITRANSPORT_SOCKET ;\n case NETLINK_RDMA : return SECCLASS_NETLINK_RDMA_SOCKET ;\n case NETLINK_CRYPTO : return SECCLASS_NETLINK_CRYPTO_SOCKET ;\n default : return SECCLASS_NETLINK_SOCKET ;\n }\n case PF_PACKET : return SECCLASS_PACKET_SOCKET ;\n case PF_KEY : return SECCLASS_KEY_SOCKET ;\n case PF_APPLETALK : return SECCLASS_APPLETALK_SOCKET ;\n }\n return SECCLASS_SOCKET ;\n }", "idx": 247}
{"hash": 229962612204196999, "project": "debian", "size": 55, "label": 0, "functionSource": "static void remote_ls ( const char * path , int flags , void ( * userFunc ) ( struct remote_ls_ctx * ls ) , void * userData ) {\n char * url = xstrfmt ( \"%s%s\" , repo -> url , path ) ;\n struct active_request_slot * slot ;\n struct slot_results results ;\n struct strbuf in_buffer = STRBUF_INIT ;\n struct buffer out_buffer = {\n STRBUF_INIT , 0 }\n ;\n struct curl_slist * dav_headers = NULL ;\n struct xml_ctx ctx ;\n struct remote_ls_ctx ls ;\n ls . flags = flags ;\n ls . path = xstrdup ( path ) ;\n ls . dentry_name = NULL ;\n ls . dentry_flags = 0 ;\n ls . userData = userData ;\n ls . userFunc = userFunc ;\n strbuf_addf ( & out_buffer . buf , PROPFIND_ALL_REQUEST ) ;\n dav_headers = curl_slist_append ( dav_headers , \"Depth: 1\" ) ;\n dav_headers = curl_slist_append ( dav_headers , \"Content-Type: text/xml\" ) ;\n slot = get_active_slot ( ) ;\n slot -> results = & results ;\n curl_setup_http ( slot -> curl , url , DAV_PROPFIND , & out_buffer , fwrite_buffer ) ;\n curl_easy_setopt ( slot -> curl , CURLOPT_HTTPHEADER , dav_headers ) ;\n curl_easy_setopt ( slot -> curl , CURLOPT_FILE , & in_buffer ) ;\n if ( start_active_slot ( slot ) ) {\n run_active_slot ( slot ) ;\n if ( results . curl_result == CURLE_OK ) {\n XML_Parser parser = XML_ParserCreate ( NULL ) ;\n enum XML_Status result ;\n ctx . name = xcalloc ( 10 , 1 ) ;\n ctx . len = 0 ;\n ctx . cdata = NULL ;\n ctx . userFunc = handle_remote_ls_ctx ;\n ctx . userData = & ls ;\n XML_SetUserData ( parser , & ctx ) ;\n XML_SetElementHandler ( parser , xml_start_tag , xml_end_tag ) ;\n XML_SetCharacterDataHandler ( parser , xml_cdata ) ;\n result = XML_Parse ( parser , in_buffer . buf , in_buffer . len , 1 ) ;\n free ( ctx . name ) ;\n if ( result != XML_STATUS_OK ) {\n fprintf ( stderr , \"XML error: %s\\n\" , XML_ErrorString ( XML_GetErrorCode ( parser ) ) ) ;\n }\n XML_ParserFree ( parser ) ;\n }\n }\n else {\n fprintf ( stderr , \"Unable to start PROPFIND request\\n\" ) ;\n }\n free ( ls . path ) ;\n free ( url ) ;\n strbuf_release ( & out_buffer . buf ) ;\n strbuf_release ( & in_buffer ) ;\n curl_slist_free_all ( dav_headers ) ;\n }", "idx": 248}
{"hash": 2713698759296604855, "project": "debian", "size": 25, "label": 0, "functionSource": "static void dct_unquantize_mpeg1_inter_c ( MpegEncContext * s , int16_t * block , int n , int qscale ) {\n int i , level , nCoeffs ;\n const uint16_t * quant_matrix ;\n nCoeffs = s -> block_last_index [ n ] ;\n quant_matrix = s -> inter_matrix ;\n for ( i = 0 ;\n i <= nCoeffs ;\n i ++ ) {\n int j = s -> intra_scantable . permutated [ i ] ;\n level = block [ j ] ;\n if ( level ) {\n if ( level < 0 ) {\n level = - level ;\n level = ( ( ( level << 1 ) + 1 ) * qscale * ( ( int ) ( quant_matrix [ j ] ) ) ) >> 4 ;\n level = ( level - 1 ) | 1 ;\n level = - level ;\n }\n else {\n level = ( ( ( level << 1 ) + 1 ) * qscale * ( ( int ) ( quant_matrix [ j ] ) ) ) >> 4 ;\n level = ( level - 1 ) | 1 ;\n }\n block [ j ] = level ;\n }\n }\n }", "idx": 249}
{"hash": 4722923622195275414, "project": "debian", "size": 9, "label": 0, "functionSource": "static uint32_t softfloat_mul ( uint32_t x , uint64_t mantissa ) {\n uint64_t l = x * ( mantissa & 0xffffffff ) ;\n uint64_t h = x * ( mantissa >> 32 ) ;\n h += l >> 32 ;\n l &= 0xffffffff ;\n l += 1 << av_log2 ( h >> 21 ) ;\n h += l >> 32 ;\n return h >> 20 ;\n }", "idx": 250}
{"hash": 6632536031698733342, "project": "debian", "size": 166, "label": 0, "functionSource": "static const char * name ## _get_name ( void * ctx ) \\ {\n return # name ;\n \\ }\n static const AVClass name ## _class = {\n . class_name = # name , . item_name = name ## _get_name , . option = name ## _options \\ }\n typedef struct DefaultContext {\n const AVClass * class ;\n int nokey ;\n int noprint_wrappers ;\n int nested_section [ SECTION_MAX_NB_LEVELS ] ;\n }\n DefaultContext ;\n # undef OFFSET # define OFFSET ( x ) offsetof ( DefaultContext , x ) static const AVOption default_options [ ] = {\n {\n \"noprint_wrappers\" , \"do not print headers and footers\" , OFFSET ( noprint_wrappers ) , AV_OPT_TYPE_BOOL , {\n . i64 = 0 }\n , 0 , 1 }\n , {\n \"nw\" , \"do not print headers and footers\" , OFFSET ( noprint_wrappers ) , AV_OPT_TYPE_BOOL , {\n . i64 = 0 }\n , 0 , 1 }\n , {\n \"nokey\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , {\n . i64 = 0 }\n , 0 , 1 }\n , {\n \"nk\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , {\n . i64 = 0 }\n , 0 , 1 }\n , {\n NULL }\n , }\n ;\n DEFINE_WRITER_CLASS ( default ) ;\n static inline char * upcase_string ( char * dst , size_t dst_size , const char * src ) {\n int i ;\n for ( i = 0 ;\n src [ i ] && i < dst_size - 1 ;\n i ++ ) dst [ i ] = av_toupper ( src [ i ] ) ;\n dst [ i ] = 0 ;\n return dst ;\n }\n static void default_print_section_header ( WriterContext * wctx ) {\n DefaultContext * def = wctx -> priv ;\n char buf [ 32 ] ;\n const struct section * section = wctx -> section [ wctx -> level ] ;\n const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ;\n av_bprint_clear ( & wctx -> section_pbuf [ wctx -> level ] ) ;\n if ( parent_section && ! ( parent_section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) {\n def -> nested_section [ wctx -> level ] = 1 ;\n av_bprintf ( & wctx -> section_pbuf [ wctx -> level ] , \"%s%s:\" , wctx -> section_pbuf [ wctx -> level - 1 ] . str , upcase_string ( buf , sizeof ( buf ) , av_x_if_null ( section -> element_name , section -> name ) ) ) ;\n }\n if ( def -> noprint_wrappers || def -> nested_section [ wctx -> level ] ) return ;\n if ( ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) printf ( \"[%s]\\n\" , upcase_string ( buf , sizeof ( buf ) , section -> name ) ) ;\n }\n static void default_print_section_footer ( WriterContext * wctx ) {\n DefaultContext * def = wctx -> priv ;\n const struct section * section = wctx -> section [ wctx -> level ] ;\n char buf [ 32 ] ;\n if ( def -> noprint_wrappers || def -> nested_section [ wctx -> level ] ) return ;\n if ( ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) printf ( \"[/%s]\\n\" , upcase_string ( buf , sizeof ( buf ) , section -> name ) ) ;\n }\n static void default_print_str ( WriterContext * wctx , const char * key , const char * value ) {\n DefaultContext * def = wctx -> priv ;\n if ( ! def -> nokey ) printf ( \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ;\n printf ( \"%s\\n\" , value ) ;\n }\n static void default_print_int ( WriterContext * wctx , const char * key , long long int value ) {\n DefaultContext * def = wctx -> priv ;\n if ( ! def -> nokey ) printf ( \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ;\n printf ( \"%lld\\n\" , value ) ;\n }\n static const Writer default_writer = {\n . name = \"default\" , . priv_size = sizeof ( DefaultContext ) , . print_section_header = default_print_section_header , . print_section_footer = default_print_section_footer , . print_integer = default_print_int , . print_string = default_print_str , . flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS , . priv_class = & default_class , }\n ;\n static const char * c_escape_str ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) {\n const char * p ;\n for ( p = src ;\n * p ;\n p ++ ) {\n switch ( * p ) {\n case '\\b' : av_bprintf ( dst , \"%s\" , \"\\\\b\" ) ;\n break ;\n case '\\f' : av_bprintf ( dst , \"%s\" , \"\\\\f\" ) ;\n break ;\n case '\\n' : av_bprintf ( dst , \"%s\" , \"\\\\n\" ) ;\n break ;\n case '\\r' : av_bprintf ( dst , \"%s\" , \"\\\\r\" ) ;\n break ;\n case '\\\\' : av_bprintf ( dst , \"%s\" , \"\\\\\\\\\" ) ;\n break ;\n default : if ( * p == sep ) av_bprint_chars ( dst , '\\\\' , 1 ) ;\n av_bprint_chars ( dst , * p , 1 ) ;\n }\n }\n return dst -> str ;\n }\n static const char * csv_escape_str ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) {\n char meta_chars [ ] = {\n sep , '\"' , '\\n' , '\\r' , '\\0' }\n ;\n int needs_quoting = ! ! src [ strcspn ( src , meta_chars ) ] ;\n if ( needs_quoting ) av_bprint_chars ( dst , '\"' , 1 ) ;\n for ( ;\n * src ;\n src ++ ) {\n if ( * src == '\"' ) av_bprint_chars ( dst , '\"' , 1 ) ;\n av_bprint_chars ( dst , * src , 1 ) ;\n }\n if ( needs_quoting ) av_bprint_chars ( dst , '\"' , 1 ) ;\n return dst -> str ;\n }\n static const char * none_escape_str ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) {\n return src ;\n }\n typedef struct CompactContext {\n const AVClass * class ;\n char * item_sep_str ;\n char item_sep ;\n int nokey ;\n int print_section ;\n char * escape_mode_str ;\n const char * ( * escape_str ) ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) ;\n int nested_section [ SECTION_MAX_NB_LEVELS ] ;\n int has_nested_elems [ SECTION_MAX_NB_LEVELS ] ;\n int terminate_line [ SECTION_MAX_NB_LEVELS ] ;\n }\n CompactContext ;\n # undef OFFSET # define OFFSET ( x ) offsetof ( CompactContext , x ) static const AVOption compact_options [ ] = {\n {\n \"item_sep\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , {\n . str = \"|\" }\n , CHAR_MIN , CHAR_MAX }\n , {\n \"s\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , {\n . str = \"|\" }\n , CHAR_MIN , CHAR_MAX }\n , {\n \"nokey\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , {\n . i64 = 0 }\n , 0 , 1 }\n , {\n \"nk\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , {\n . i64 = 0 }\n , 0 , 1 }\n , {\n \"escape\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , {\n . str = \"c\" }\n , CHAR_MIN , CHAR_MAX }\n , {\n \"e\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , {\n . str = \"c\" }\n , CHAR_MIN , CHAR_MAX }\n , {\n \"print_section\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , {\n . i64 = 1 }\n , 0 , 1 }\n , {\n \"p\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , {\n . i64 = 1 }\n , 0 , 1 }\n , {\n NULL }\n , }\n ;\n DEFINE_WRITER_CLASS ( compact )", "idx": 251}
{"hash": -5280794106681745199, "project": "debian", "size": 39, "label": 0, "functionSource": "static const gchar * gst_asf_demux_get_gst_tag_from_tag_name ( const gchar * name_utf8 ) {\n const struct {\n const gchar * asf_name ;\n const gchar * gst_name ;\n }\n tags [ ] = {\n {\n \"WM/Genre\" , GST_TAG_GENRE }\n , {\n \"WM/AlbumTitle\" , GST_TAG_ALBUM }\n , {\n \"WM/AlbumArtist\" , GST_TAG_ARTIST }\n , {\n \"WM/Picture\" , GST_TAG_IMAGE }\n , {\n \"WM/Track\" , GST_TAG_TRACK_NUMBER }\n , {\n \"WM/TrackNumber\" , GST_TAG_TRACK_NUMBER }\n , {\n \"WM/Year\" , GST_TAG_DATE_TIME }\n }\n ;\n gsize out ;\n guint i ;\n if ( name_utf8 == NULL ) {\n GST_WARNING ( \"Failed to convert name to UTF8, skipping\" ) ;\n return NULL ;\n }\n out = strlen ( name_utf8 ) ;\n for ( i = 0 ;\n i < G_N_ELEMENTS ( tags ) ;\n ++ i ) {\n if ( strncmp ( tags [ i ] . asf_name , name_utf8 , out ) == 0 ) {\n GST_LOG ( \"map tagname '%s' -> '%s'\" , name_utf8 , tags [ i ] . gst_name ) ;\n return tags [ i ] . gst_name ;\n }\n }\n return NULL ;\n }", "idx": 252}
{"hash": 7039307292471244756, "project": "debian", "size": 10, "label": 0, "functionSource": "static guint16 de_tp_ack ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len _U_ , gchar * add_string _U_ , int string_len _U_ ) {\n guint32 curr_offset ;\n guchar oct ;\n curr_offset = offset ;\n oct = tvb_get_guint8 ( tvb , curr_offset ) ;\n if ( ( oct & 0xF0 ) == 0x80 ) proto_tree_add_uint ( tree , hf_gsm_a_dtap_ack_element , tvb , curr_offset , 1 , oct & 0x01 ) ;\n else proto_tree_add_uint_format_value ( tree , hf_gsm_a_dtap_ack_element , tvb , curr_offset , 1 , 0xFF , \"No acknowledgment element present\" ) ;\n curr_offset += 1 ;\n return ( curr_offset - offset ) ;\n }", "idx": 253}
{"hash": -2607754285145856562, "project": "debian", "size": 34, "label": 0, "functionSource": "static int isoent_clone_tree ( struct archive_write * a , struct isoent * * nroot , struct isoent * root ) {\n struct isoent * np , * xroot , * newent ;\n np = root ;\n xroot = NULL ;\n do {\n newent = isoent_clone ( np ) ;\n if ( newent == NULL ) {\n archive_set_error ( & a -> archive , ENOMEM , \"Can't allocate memory\" ) ;\n return ( ARCHIVE_FATAL ) ;\n }\n if ( xroot == NULL ) {\n * nroot = xroot = newent ;\n newent -> parent = xroot ;\n }\n else isoent_add_child_tail ( xroot , newent ) ;\n if ( np -> dir && np -> children . first != NULL ) {\n np = np -> children . first ;\n xroot = newent ;\n continue ;\n }\n while ( np != np -> parent ) {\n if ( np -> chnext == NULL ) {\n np = np -> parent ;\n xroot = xroot -> parent ;\n }\n else {\n np = np -> chnext ;\n break ;\n }\n }\n }\n while ( np != np -> parent ) ;\n return ( ARCHIVE_OK ) ;\n }", "idx": 254}
{"hash": 5400542917484463750, "project": "chrome", "size": 6, "label": 1, "functionSource": "static void fd_list_add ( struct FrameData * * list , struct FrameData * layer_data ) {\n struct FrameData * * p = list ;\n while ( * p != NULL ) p = & ( * p ) -> next ;\n * p = layer_data ;\n layer_data -> next = NULL ;\n }", "idx": 255}
{"hash": 8206514580434225668, "project": "chrome", "size": 9, "label": 1, "functionSource": "IN_PROC_BROWSER_TEST_F ( HttpsEngagementPageLoadMetricsBrowserTest , BackgroundThenForeground_Http ) {\n StartHttpServer ( ) ;\n base : : TimeDelta upper_bound = NavigateInBackgroundAndCloseInForegroundWithTiming ( http_test_server_ -> GetURL ( \"/simple.html\" ) ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHttpEngagementHistogram , 1 ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHttpsEngagementHistogram , 0 ) ;\n int32_t bucket_min = histogram_tester_ . GetAllSamples ( internal : : kHttpEngagementHistogram ) [ 0 ] . min ;\n EXPECT_GE ( upper_bound . InMilliseconds ( ) , bucket_min ) ;\n EXPECT_LT ( 0 , bucket_min ) ;\n }", "idx": 256}
{"hash": 5357882892791796049, "project": "debian", "size": 29, "label": 0, "functionSource": "static void e1000e_update_interrupt_state ( E1000ECore * core ) {\n bool interrupts_pending ;\n bool is_msix = msix_enabled ( core -> owner ) ;\n if ( is_msix ) {\n if ( core -> mac [ ICR ] & E1000_ICR_OTHER_CAUSES ) {\n core -> mac [ ICR ] |= E1000_ICR_OTHER ;\n trace_e1000e_irq_add_msi_other ( core -> mac [ ICR ] ) ;\n }\n }\n e1000e_fix_icr_asserted ( core ) ;\n core -> mac [ ICS ] = core -> mac [ ICR ] ;\n interrupts_pending = ( core -> mac [ IMS ] & core -> mac [ ICR ] ) ? true : false ;\n trace_e1000e_irq_pending_interrupts ( core -> mac [ ICR ] & core -> mac [ IMS ] , core -> mac [ ICR ] , core -> mac [ IMS ] ) ;\n if ( is_msix || msi_enabled ( core -> owner ) ) {\n if ( interrupts_pending ) {\n e1000e_send_msi ( core , is_msix ) ;\n }\n }\n else {\n if ( interrupts_pending ) {\n if ( ! e1000e_itr_should_postpone ( core ) ) {\n e1000e_raise_legacy_irq ( core ) ;\n }\n }\n else {\n e1000e_lower_legacy_irq ( core ) ;\n }\n }\n }", "idx": 257}
{"hash": 7651945086108393719, "project": "debian", "size": 23, "label": 0, "functionSource": "static void qemuMonitorJSONHandleIOError ( qemuMonitorPtr mon , virJSONValuePtr data ) {\n const char * device ;\n const char * action ;\n const char * reason ;\n int actionID ;\n if ( ( action = virJSONValueObjectGetString ( data , \"action\" ) ) == NULL ) {\n VIR_WARN ( \"Missing action in disk io error event\" ) ;\n action = \"ignore\" ;\n }\n if ( ( device = virJSONValueObjectGetString ( data , \"device\" ) ) == NULL ) {\n VIR_WARN ( \"missing device in disk io error event\" ) ;\n }\n # if 0 if ( ( reason = virJSONValueObjectGetString ( data , \"reason\" ) ) == NULL ) {\n VIR_WARN ( \"missing reason in disk io error event\" ) ;\n reason = \"\" ;\n }\n # else reason = \"\" ;\n # endif if ( ( actionID = qemuMonitorIOErrorActionTypeFromString ( action ) ) < 0 ) {\n VIR_WARN ( \"unknown disk io error action '%s'\" , action ) ;\n actionID = VIR_DOMAIN_EVENT_IO_ERROR_NONE ;\n }\n qemuMonitorEmitIOError ( mon , device , actionID , reason ) ;\n }", "idx": 258}
{"hash": -866921002076081979, "project": "debian", "size": 16, "label": 0, "functionSource": "int action_cancel_handler ( TSCont contp , TSEvent event , void * ) {\n if ( event == TS_EVENT_IMMEDIATE ) {\n SDK_RPRINT ( SDK_ActionCancel_test , \"TSActionCancel\" , \"TestCase1\" , TC_PASS , \"ok\" ) ;\n * SDK_ActionCancel_pstatus = REGRESSION_TEST_PASSED ;\n }\n else if ( event == TS_EVENT_TIMEOUT ) {\n SDK_RPRINT ( SDK_ActionCancel_test , \"TSActionCancel\" , \"TestCase1\" , TC_FAIL , \"bad action\" ) ;\n * SDK_ActionCancel_pstatus = REGRESSION_TEST_FAILED ;\n }\n else {\n SDK_RPRINT ( SDK_ActionCancel_test , \"TSActionCancel\" , \"TestCase1\" , TC_FAIL , \"bad event\" ) ;\n * SDK_ActionCancel_pstatus = REGRESSION_TEST_FAILED ;\n }\n TSContDestroy ( contp ) ;\n return 0 ;\n }", "idx": 259}
{"hash": -1321749842392027937, "project": "chrome", "size": 7, "label": 0, "functionSource": "void vp8_encode_inter16x16 ( MACROBLOCK * x ) {\n vp8_build_inter_predictors_mb ( & x -> e_mbd ) ;\n vp8_subtract_mb ( x ) ;\n transform_mb ( x ) ;\n vp8_quantize_mb ( x ) ;\n if ( x -> optimize ) optimize_mb ( x ) ;\n }", "idx": 260}
{"hash": -7455544248455991006, "project": "debian", "size": 44, "label": 0, "functionSource": "int kvm_arch_get_registers ( CPUState * cs ) {\n X86CPU * cpu = X86_CPU ( cs ) ;\n int ret ;\n assert ( cpu_is_stopped ( cs ) || qemu_cpu_is_self ( cs ) ) ;\n ret = kvm_get_vcpu_events ( cpu ) ;\n if ( ret < 0 ) {\n goto out ;\n }\n ret = kvm_get_mp_state ( cpu ) ;\n if ( ret < 0 ) {\n goto out ;\n }\n ret = kvm_getput_regs ( cpu , 0 ) ;\n if ( ret < 0 ) {\n goto out ;\n }\n ret = kvm_get_xsave ( cpu ) ;\n if ( ret < 0 ) {\n goto out ;\n }\n ret = kvm_get_xcrs ( cpu ) ;\n if ( ret < 0 ) {\n goto out ;\n }\n ret = kvm_get_sregs ( cpu ) ;\n if ( ret < 0 ) {\n goto out ;\n }\n ret = kvm_get_msrs ( cpu ) ;\n if ( ret < 0 ) {\n goto out ;\n }\n ret = kvm_get_apic ( cpu ) ;\n if ( ret < 0 ) {\n goto out ;\n }\n ret = kvm_get_debugregs ( cpu ) ;\n if ( ret < 0 ) {\n goto out ;\n }\n ret = 0 ;\n out : cpu_sync_bndcs_hflags ( & cpu -> env ) ;\n return ret ;\n }", "idx": 261}
{"hash": 4511225370772574632, "project": "debian", "size": 3, "label": 0, "functionSource": "static void sapi_uwsgi_log_message ( char * message TSRMLS_DC ) {\n # endif uwsgi_log ( \"%s\\n\" , message ) ;\n }", "idx": 262}
{"hash": -5456913190944844754, "project": "chrome", "size": 16, "label": 0, "functionSource": "TEST_F ( TemplateURLTest , InputEncodingBeforeSearchTerm ) {\n TemplateURLData data ;\n data . SetURL ( \"http://foox{\ninputEncoding?}\na{\nsearchTerms}\ny{\noutputEncoding?}\nb\" ) ;\n TemplateURL url ( data ) ;\n EXPECT_TRUE ( url . url_ref ( ) . IsValid ( search_terms_data_ ) ) ;\n ASSERT_TRUE ( url . url_ref ( ) . SupportsReplacement ( search_terms_data_ ) ) ;\n GURL result ( url . url_ref ( ) . ReplaceSearchTerms ( TemplateURLRef : : SearchTermsArgs ( ASCIIToUTF16 ( \"X\" ) ) , search_terms_data_ ) ) ;\n ASSERT_TRUE ( result . is_valid ( ) ) ;\n EXPECT_EQ ( \"http://fooxutf-8axyb/\" , result . spec ( ) ) ;\n }", "idx": 263}
{"hash": -5357254031401749470, "project": "debian", "size": 10, "label": 0, "functionSource": "int luaD_rawrunprotected ( lua_State * L , Pfunc f , void * ud ) {\n struct lua_longjmp lj ;\n lj . status = 0 ;\n lj . previous = L -> errorJmp ;\n L -> errorJmp = & lj ;\n LUAI_TRY ( L , & lj , ( * f ) ( L , ud ) ;\n ) ;\n L -> errorJmp = lj . previous ;\n return lj . status ;\n }", "idx": 264}
{"hash": -649112636673899765, "project": "debian", "size": 12, "label": 0, "functionSource": "static inline void get_strl ( AVIOContext * pb , char * buf , int buf_size , int len ) {\n int i ;\n char * q , r ;\n q = buf ;\n for ( i = 0 ;\n i < len ;\n i ++ ) {\n r = avio_r8 ( pb ) ;\n if ( i < buf_size - 1 ) * q ++ = r ;\n }\n if ( buf_size > 0 ) * q = '\\0' ;\n }", "idx": 265}
{"hash": -3819889754140204145, "project": "debian", "size": 7, "label": 0, "functionSource": "static u_int parse_constraint ( chunk_t object ) {\n switch ( object . len ) {\n case 0 : return 0 ;\n case 1 : return ( object . ptr [ 0 ] & 0x80 ) ? X509_NO_CONSTRAINT : object . ptr [ 0 ] ;\n default : return X509_NO_CONSTRAINT ;\n }\n }", "idx": 266}
{"hash": -866921002076081979, "project": "debian", "size": 14, "label": 0, "functionSource": "TSReturnCode compare_field_names ( RegressionTest * , TSMBuffer bufp1 , TSMLoc mime_loc1 , TSMLoc field_loc1 , TSMBuffer bufp2 , TSMLoc mime_loc2 , TSMLoc field_loc2 ) {\n const char * name1 ;\n const char * name2 ;\n int length1 ;\n int length2 ;\n name1 = TSMimeHdrFieldNameGet ( bufp1 , mime_loc1 , field_loc1 , & length1 ) ;\n name2 = TSMimeHdrFieldNameGet ( bufp2 , mime_loc2 , field_loc2 , & length2 ) ;\n if ( ( length1 == length2 ) && ( strncmp ( name1 , name2 , length1 ) == 0 ) ) {\n return TS_SUCCESS ;\n }\n else {\n return TS_ERROR ;\n }\n }", "idx": 267}
{"hash": 6458694302493204858, "project": "debian", "size": 131, "label": 0, "functionSource": "static Datum ExecEvalXml ( XmlExprState * xmlExpr , ExprContext * econtext , bool * isNull , ExprDoneCond * isDone ) {\n XmlExpr * xexpr = ( XmlExpr * ) xmlExpr -> xprstate . expr ;\n Datum value ;\n bool isnull ;\n ListCell * arg ;\n ListCell * narg ;\n if ( isDone ) * isDone = ExprSingleResult ;\n * isNull = true ;\n switch ( xexpr -> op ) {\n case IS_XMLCONCAT : {\n List * values = NIL ;\n foreach ( arg , xmlExpr -> args ) {\n ExprState * e = ( ExprState * ) lfirst ( arg ) ;\n value = ExecEvalExpr ( e , econtext , & isnull , NULL ) ;\n if ( ! isnull ) values = lappend ( values , DatumGetPointer ( value ) ) ;\n }\n if ( list_length ( values ) > 0 ) {\n * isNull = false ;\n return PointerGetDatum ( xmlconcat ( values ) ) ;\n }\n else return ( Datum ) 0 ;\n }\n break ;\n case IS_XMLFOREST : {\n StringInfoData buf ;\n initStringInfo ( & buf ) ;\n forboth ( arg , xmlExpr -> named_args , narg , xexpr -> arg_names ) {\n ExprState * e = ( ExprState * ) lfirst ( arg ) ;\n char * argname = strVal ( lfirst ( narg ) ) ;\n value = ExecEvalExpr ( e , econtext , & isnull , NULL ) ;\n if ( ! isnull ) {\n appendStringInfo ( & buf , \"<%s>%s</%s>\" , argname , map_sql_value_to_xml_value ( value , exprType ( ( Node * ) e -> expr ) , true ) , argname ) ;\n * isNull = false ;\n }\n }\n if ( * isNull ) {\n pfree ( buf . data ) ;\n return ( Datum ) 0 ;\n }\n else {\n text * result ;\n result = cstring_to_text_with_len ( buf . data , buf . len ) ;\n pfree ( buf . data ) ;\n return PointerGetDatum ( result ) ;\n }\n }\n break ;\n case IS_XMLELEMENT : * isNull = false ;\n return PointerGetDatum ( xmlelement ( xmlExpr , econtext ) ) ;\n break ;\n case IS_XMLPARSE : {\n ExprState * e ;\n text * data ;\n bool preserve_whitespace ;\n Assert ( list_length ( xmlExpr -> args ) == 2 ) ;\n e = ( ExprState * ) linitial ( xmlExpr -> args ) ;\n value = ExecEvalExpr ( e , econtext , & isnull , NULL ) ;\n if ( isnull ) return ( Datum ) 0 ;\n data = DatumGetTextP ( value ) ;\n e = ( ExprState * ) lsecond ( xmlExpr -> args ) ;\n value = ExecEvalExpr ( e , econtext , & isnull , NULL ) ;\n if ( isnull ) return ( Datum ) 0 ;\n preserve_whitespace = DatumGetBool ( value ) ;\n * isNull = false ;\n return PointerGetDatum ( xmlparse ( data , xexpr -> xmloption , preserve_whitespace ) ) ;\n }\n break ;\n case IS_XMLPI : {\n ExprState * e ;\n text * arg ;\n Assert ( list_length ( xmlExpr -> args ) <= 1 ) ;\n if ( xmlExpr -> args ) {\n e = ( ExprState * ) linitial ( xmlExpr -> args ) ;\n value = ExecEvalExpr ( e , econtext , & isnull , NULL ) ;\n if ( isnull ) arg = NULL ;\n else arg = DatumGetTextP ( value ) ;\n }\n else {\n arg = NULL ;\n isnull = false ;\n }\n return PointerGetDatum ( xmlpi ( xexpr -> name , arg , isnull , isNull ) ) ;\n }\n break ;\n case IS_XMLROOT : {\n ExprState * e ;\n xmltype * data ;\n text * version ;\n int standalone ;\n Assert ( list_length ( xmlExpr -> args ) == 3 ) ;\n e = ( ExprState * ) linitial ( xmlExpr -> args ) ;\n value = ExecEvalExpr ( e , econtext , & isnull , NULL ) ;\n if ( isnull ) return ( Datum ) 0 ;\n data = DatumGetXmlP ( value ) ;\n e = ( ExprState * ) lsecond ( xmlExpr -> args ) ;\n value = ExecEvalExpr ( e , econtext , & isnull , NULL ) ;\n if ( isnull ) version = NULL ;\n else version = DatumGetTextP ( value ) ;\n e = ( ExprState * ) lthird ( xmlExpr -> args ) ;\n value = ExecEvalExpr ( e , econtext , & isnull , NULL ) ;\n standalone = DatumGetInt32 ( value ) ;\n * isNull = false ;\n return PointerGetDatum ( xmlroot ( data , version , standalone ) ) ;\n }\n break ;\n case IS_XMLSERIALIZE : {\n ExprState * e ;\n Assert ( list_length ( xmlExpr -> args ) == 1 ) ;\n e = ( ExprState * ) linitial ( xmlExpr -> args ) ;\n value = ExecEvalExpr ( e , econtext , & isnull , NULL ) ;\n if ( isnull ) return ( Datum ) 0 ;\n * isNull = false ;\n return PointerGetDatum ( xmltotext_with_xmloption ( DatumGetXmlP ( value ) , xexpr -> xmloption ) ) ;\n }\n break ;\n case IS_DOCUMENT : {\n ExprState * e ;\n Assert ( list_length ( xmlExpr -> args ) == 1 ) ;\n e = ( ExprState * ) linitial ( xmlExpr -> args ) ;\n value = ExecEvalExpr ( e , econtext , & isnull , NULL ) ;\n if ( isnull ) return ( Datum ) 0 ;\n else {\n * isNull = false ;\n return BoolGetDatum ( xml_is_document ( DatumGetXmlP ( value ) ) ) ;\n }\n }\n break ;\n }\n elog ( ERROR , \"unrecognized XML operation\" ) ;\n return ( Datum ) 0 ;\n }", "idx": 268}
{"hash": -8046645508582876963, "project": "debian", "size": 33, "label": 0, "functionSource": "static void roq_encode_video ( RoqContext * enc ) {\n RoqTempdata * tempData = enc -> tmpData ;\n int i ;\n memset ( tempData , 0 , sizeof ( * tempData ) ) ;\n create_cel_evals ( enc , tempData ) ;\n generate_new_codebooks ( enc , tempData ) ;\n if ( enc -> framesSinceKeyframe >= 1 ) {\n motion_search ( enc , 8 ) ;\n motion_search ( enc , 4 ) ;\n }\n retry_encode : for ( i = 0 ;\n i < enc -> width * enc -> height / 64 ;\n i ++ ) gather_data_for_cel ( tempData -> cel_evals + i , enc , tempData ) ;\n if ( tempData -> mainChunkSize / 8 > 65535 ) {\n av_log ( enc -> avctx , AV_LOG_ERROR , \"Warning, generated a frame too big (%d > 65535), \" \"try using a smaller qscale value.\\n\" , tempData -> mainChunkSize / 8 ) ;\n enc -> lambda *= 1.5 ;\n tempData -> mainChunkSize = 0 ;\n memset ( tempData -> used_option , 0 , sizeof ( tempData -> used_option ) ) ;\n memset ( tempData -> codebooks . usedCB4 , 0 , sizeof ( tempData -> codebooks . usedCB4 ) ) ;\n memset ( tempData -> codebooks . usedCB2 , 0 , sizeof ( tempData -> codebooks . usedCB2 ) ) ;\n goto retry_encode ;\n }\n remap_codebooks ( enc , tempData ) ;\n write_codebooks ( enc , tempData ) ;\n reconstruct_and_encode_image ( enc , tempData , enc -> width , enc -> height , enc -> width * enc -> height / 64 ) ;\n enc -> avctx -> coded_frame = enc -> current_frame ;\n FFSWAP ( AVFrame * , enc -> current_frame , enc -> last_frame ) ;\n FFSWAP ( motion_vect * , enc -> last_motion4 , enc -> this_motion4 ) ;\n FFSWAP ( motion_vect * , enc -> last_motion8 , enc -> this_motion8 ) ;\n av_free ( tempData -> cel_evals ) ;\n av_free ( tempData -> closest_cb2 ) ;\n enc -> framesSinceKeyframe ++ ;\n }", "idx": 269}
{"hash": -5082285935423529157, "project": "debian", "size": 22, "label": 0, "functionSource": "static int dissect_rsl_ie_smscb_inf ( tvbuff_t * tvb , packet_info * pinfo _U_ , proto_tree * tree , int offset , gboolean is_mandatory ) {\n proto_item * ti ;\n proto_tree * ie_tree ;\n tvbuff_t * next_tvb ;\n guint length ;\n guint8 ie_id ;\n if ( is_mandatory == FALSE ) {\n ie_id = tvb_get_guint8 ( tvb , offset ) ;\n if ( ie_id != RSL_IE_SMSCB_INF ) return offset ;\n }\n ie_tree = proto_tree_add_subtree ( tree , tvb , offset , 0 , ett_ie_smscb_inf , & ti , \"SMSCB Information IE \" ) ;\n proto_tree_add_item ( ie_tree , hf_rsl_ie_id , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n offset ++ ;\n length = tvb_get_guint8 ( tvb , offset ) ;\n proto_item_set_len ( ti , length + 2 ) ;\n proto_tree_add_item ( ie_tree , hf_rsl_ie_length , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n offset ++ ;\n next_tvb = tvb_new_subset_length ( tvb , offset , length ) ;\n call_dissector ( gsm_cbch_handle , next_tvb , pinfo , top_tree ) ;\n offset = offset + length ;\n return offset ;\n }", "idx": 270}
{"hash": 6120640898537304364, "project": "debian", "size": 4, "label": 0, "functionSource": "static void pdf_process_end ( fz_context * ctx , pdf_processor * proc , pdf_csi * csi ) {\n while ( csi -> gstate > 0 ) pdf_process_grestore ( ctx , proc , csi ) ;\n if ( proc -> op_END ) proc -> op_END ( ctx , proc ) ;\n }", "idx": 271}
{"hash": -7555034601056330007, "project": "debian", "size": 45, "label": 0, "functionSource": "virLogOutputPtr virLogParseOutput ( const char * src ) {\n virLogOutputPtr ret = NULL ;\n char * * tokens = NULL ;\n char * abspath = NULL ;\n size_t count = 0 ;\n virLogPriority prio ;\n int dest ;\n bool isSUID = virIsSUID ( ) ;\n VIR_DEBUG ( \"output=%s\" , src ) ;\n if ( ! ( tokens = virStringSplitCount ( src , \":\" , 0 , & count ) ) || count < 2 ) {\n virReportError ( VIR_ERR_INVALID_ARG , _ ( \"Malformed format for output '%s'\" ) , src ) ;\n goto cleanup ;\n }\n if ( virStrToLong_uip ( tokens [ 0 ] , NULL , 10 , & prio ) < 0 || ( prio < VIR_LOG_DEBUG ) || ( prio > VIR_LOG_ERROR ) ) {\n virReportError ( VIR_ERR_INVALID_ARG , _ ( \"Invalid priority '%s' for output '%s'\" ) , tokens [ 0 ] , src ) ;\n goto cleanup ;\n }\n if ( ( dest = virLogDestinationTypeFromString ( tokens [ 1 ] ) ) < 0 ) {\n virReportError ( VIR_ERR_INVALID_ARG , _ ( \"Invalid destination '%s' for output '%s'\" ) , tokens [ 1 ] , src ) ;\n goto cleanup ;\n }\n if ( ( ( dest == VIR_LOG_TO_STDERR || dest == VIR_LOG_TO_JOURNALD ) && count != 2 ) || ( ( dest == VIR_LOG_TO_FILE || dest == VIR_LOG_TO_SYSLOG ) && count != 3 ) ) {\n virReportError ( VIR_ERR_INVALID_ARG , _ ( \"Output '%s' does not meet the format requirements \" \"for destination type '%s'\" ) , src , tokens [ 1 ] ) ;\n goto cleanup ;\n }\n if ( isSUID && dest != VIR_LOG_TO_STDERR ) {\n virReportError ( VIR_ERR_INTERNAL_ERROR , \"%s\" , _ ( \"Running with SUID permits only destination of type \" \"'stderr'\" ) ) ;\n goto cleanup ;\n }\n switch ( ( virLogDestination ) dest ) {\n case VIR_LOG_TO_STDERR : ret = virLogNewOutputToStderr ( prio ) ;\n break ;\n case VIR_LOG_TO_SYSLOG : # if HAVE_SYSLOG_H ret = virLogNewOutputToSyslog ( prio , tokens [ 2 ] ) ;\n # endif break ;\n case VIR_LOG_TO_FILE : if ( virFileAbsPath ( tokens [ 2 ] , & abspath ) < 0 ) goto cleanup ;\n ret = virLogNewOutputToFile ( prio , abspath ) ;\n VIR_FREE ( abspath ) ;\n break ;\n case VIR_LOG_TO_JOURNALD : # if USE_JOURNALD ret = virLogNewOutputToJournald ( prio ) ;\n # endif break ;\n case VIR_LOG_TO_OUTPUT_LAST : break ;\n }\n cleanup : virStringListFree ( tokens ) ;\n return ret ;\n }", "idx": 272}
{"hash": 4489017523191997023, "project": "debian", "size": 14, "label": 0, "functionSource": "int dissect_h225_GenericIdentifier ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 860 \"./asn1/h225/h225.cnf\" gef_ctx_t * gefx ;\n proto_item * ti ;\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_GenericIdentifier , GenericIdentifier_choice , NULL ) ;\n # line 863 \"./asn1/h225/h225.cnf\" gef_ctx_update_key ( gef_ctx_get ( actx -> private_data ) ) ;\n gefx = gef_ctx_get ( actx -> private_data ) ;\n if ( gefx ) {\n ti = proto_tree_add_string ( tree , hf_h225_debug_dissector_try_string , tvb , offset >> 3 , 0 , gefx -> key ) ;\n PROTO_ITEM_SET_HIDDEN ( ti ) ;\n dissector_try_string ( gef_name_dissector_table , gefx -> key , tvb_new_subset ( tvb , offset >> 3 , 0 , 0 ) , actx -> pinfo , tree , actx ) ;\n }\n actx -> private_data = gefx ;\n return offset ;\n }", "idx": 273}
{"hash": -8815658870890288443, "project": "chrome", "size": 3, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( CrossOriginXHR , AllURLs ) {\n ASSERT_TRUE ( RunExtensionTest ( \"cross_origin_xhr/all_urls\" ) ) << message_ ;\n }", "idx": 274}
{"hash": -3528294111382233554, "project": "chrome", "size": 80, "label": 0, "functionSource": "static void U_CALLCONV _ASCIIToUnicodeWithOffsets ( UConverterToUnicodeArgs * pArgs , UErrorCode * pErrorCode ) {\n const uint8_t * source , * sourceLimit ;\n UChar * target , * oldTarget ;\n int32_t targetCapacity , length ;\n int32_t * offsets ;\n int32_t sourceIndex ;\n uint8_t c ;\n source = ( const uint8_t * ) pArgs -> source ;\n sourceLimit = ( const uint8_t * ) pArgs -> sourceLimit ;\n target = oldTarget = pArgs -> target ;\n targetCapacity = ( int32_t ) ( pArgs -> targetLimit - pArgs -> target ) ;\n offsets = pArgs -> offsets ;\n sourceIndex = 0 ;\n length = ( int32_t ) ( sourceLimit - source ) ;\n if ( length < targetCapacity ) {\n targetCapacity = length ;\n }\n if ( targetCapacity >= 8 ) {\n int32_t count , loops ;\n UChar oredChars ;\n loops = count = targetCapacity >> 3 ;\n do {\n oredChars = target [ 0 ] = source [ 0 ] ;\n oredChars |= target [ 1 ] = source [ 1 ] ;\n oredChars |= target [ 2 ] = source [ 2 ] ;\n oredChars |= target [ 3 ] = source [ 3 ] ;\n oredChars |= target [ 4 ] = source [ 4 ] ;\n oredChars |= target [ 5 ] = source [ 5 ] ;\n oredChars |= target [ 6 ] = source [ 6 ] ;\n oredChars |= target [ 7 ] = source [ 7 ] ;\n if ( oredChars > 0x7f ) {\n break ;\n }\n source += 8 ;\n target += 8 ;\n }\n while ( -- count > 0 ) ;\n count = loops - count ;\n targetCapacity -= count * 8 ;\n if ( offsets != NULL ) {\n oldTarget += count * 8 ;\n while ( count > 0 ) {\n offsets [ 0 ] = sourceIndex ++ ;\n offsets [ 1 ] = sourceIndex ++ ;\n offsets [ 2 ] = sourceIndex ++ ;\n offsets [ 3 ] = sourceIndex ++ ;\n offsets [ 4 ] = sourceIndex ++ ;\n offsets [ 5 ] = sourceIndex ++ ;\n offsets [ 6 ] = sourceIndex ++ ;\n offsets [ 7 ] = sourceIndex ++ ;\n offsets += 8 ;\n -- count ;\n }\n }\n }\n c = 0 ;\n while ( targetCapacity > 0 && ( c = * source ++ ) <= 0x7f ) {\n * target ++ = c ;\n -- targetCapacity ;\n }\n if ( c > 0x7f ) {\n UConverter * cnv = pArgs -> converter ;\n cnv -> toUBytes [ 0 ] = c ;\n cnv -> toULength = 1 ;\n * pErrorCode = U_ILLEGAL_CHAR_FOUND ;\n }\n else if ( source < sourceLimit && target >= pArgs -> targetLimit ) {\n * pErrorCode = U_BUFFER_OVERFLOW_ERROR ;\n }\n if ( offsets != NULL ) {\n size_t count = target - oldTarget ;\n while ( count > 0 ) {\n * offsets ++ = sourceIndex ++ ;\n -- count ;\n }\n }\n pArgs -> source = ( const char * ) source ;\n pArgs -> target = target ;\n pArgs -> offsets = offsets ;\n }", "idx": 275}
{"hash": -3740862514502467070, "project": "debian", "size": 35, "label": 0, "functionSource": "void cvt_unix_to_1904 ( long long time , int32 result [ 2 ] ) {\n uint32 date1970 [ 4 ] , tm [ 4 ] ;\n uint32 year [ 2 ] ;\n int i ;\n tm [ 0 ] = time & 0xffff ;\n tm [ 1 ] = ( time >> 16 ) & 0xffff ;\n tm [ 2 ] = ( time >> 32 ) & 0xffff ;\n tm [ 3 ] = ( time >> 48 ) & 0xffff ;\n memset ( date1970 , 0 , sizeof ( date1970 ) ) ;\n year [ 0 ] = ( 60 * 60 * 24 * 365L ) & 0xffff ;\n year [ 1 ] = ( 60 * 60 * 24 * 365L ) >> 16 ;\n for ( i = 1904 ;\n i < 1970 ;\n ++ i ) {\n date1970 [ 0 ] += year [ 0 ] ;\n date1970 [ 1 ] += year [ 1 ] ;\n if ( ( i & 3 ) == 0 && ( i % 100 != 0 || i % 400 == 0 ) ) date1970 [ 0 ] += 24 * 60 * 60L ;\n date1970 [ 1 ] += ( date1970 [ 0 ] >> 16 ) ;\n date1970 [ 0 ] &= 0xffff ;\n date1970 [ 2 ] += date1970 [ 1 ] >> 16 ;\n date1970 [ 1 ] &= 0xffff ;\n date1970 [ 3 ] += date1970 [ 2 ] >> 16 ;\n date1970 [ 2 ] &= 0xffff ;\n }\n for ( i = 0 ;\n i < 3 ;\n ++ i ) {\n tm [ i ] += date1970 [ i ] ;\n tm [ i + 1 ] += tm [ i ] >> 16 ;\n tm [ i ] &= 0xffff ;\n }\n tm [ 3 ] -= date1970 [ 3 ] ;\n result [ 0 ] = ( tm [ 1 ] << 16 ) | tm [ 0 ] ;\n result [ 1 ] = ( tm [ 3 ] << 16 ) | tm [ 2 ] ;\n }", "idx": 276}
{"hash": 4423867112908498696, "project": "chrome", "size": 49, "label": 1, "functionSource": "void vp9_init_quantizer ( VP9_COMP * cpi ) {\n VP9_COMMON * const cm = & cpi -> common ;\n QUANTS * const quants = & cpi -> quants ;\n int i , q , quant ;\n for ( q = 0 ;\n q < QINDEX_RANGE ;\n q ++ ) {\n const int qzbin_factor = q == 0 ? 64 : ( vp9_dc_quant ( q , 0 ) < 148 ? 84 : 80 ) ;\n const int qrounding_factor = q == 0 ? 64 : 48 ;\n for ( i = 0 ;\n i < 2 ;\n ++ i ) {\n int qrounding_factor_fp = i == 0 ? 48 : 42 ;\n if ( q == 0 ) qrounding_factor_fp = 64 ;\n quant = i == 0 ? vp9_dc_quant ( q , cm -> y_dc_delta_q ) : vp9_ac_quant ( q , 0 ) ;\n invert_quant ( & quants -> y_quant [ q ] [ i ] , & quants -> y_quant_shift [ q ] [ i ] , quant ) ;\n quants -> y_quant_fp [ q ] [ i ] = ( 1 << 16 ) / quant ;\n quants -> y_round_fp [ q ] [ i ] = ( qrounding_factor_fp * quant ) >> 7 ;\n quants -> y_zbin [ q ] [ i ] = ROUND_POWER_OF_TWO ( qzbin_factor * quant , 7 ) ;\n quants -> y_round [ q ] [ i ] = ( qrounding_factor * quant ) >> 7 ;\n cm -> y_dequant [ q ] [ i ] = quant ;\n quant = i == 0 ? vp9_dc_quant ( q , cm -> uv_dc_delta_q ) : vp9_ac_quant ( q , cm -> uv_ac_delta_q ) ;\n invert_quant ( & quants -> uv_quant [ q ] [ i ] , & quants -> uv_quant_shift [ q ] [ i ] , quant ) ;\n quants -> uv_quant_fp [ q ] [ i ] = ( 1 << 16 ) / quant ;\n quants -> uv_round_fp [ q ] [ i ] = ( qrounding_factor_fp * quant ) >> 7 ;\n quants -> uv_zbin [ q ] [ i ] = ROUND_POWER_OF_TWO ( qzbin_factor * quant , 7 ) ;\n quants -> uv_round [ q ] [ i ] = ( qrounding_factor * quant ) >> 7 ;\n cm -> uv_dequant [ q ] [ i ] = quant ;\n }\n for ( i = 2 ;\n i < 8 ;\n i ++ ) {\n quants -> y_quant [ q ] [ i ] = quants -> y_quant [ q ] [ 1 ] ;\n quants -> y_quant_fp [ q ] [ i ] = quants -> y_quant_fp [ q ] [ 1 ] ;\n quants -> y_round_fp [ q ] [ i ] = quants -> y_round_fp [ q ] [ 1 ] ;\n quants -> y_quant_shift [ q ] [ i ] = quants -> y_quant_shift [ q ] [ 1 ] ;\n quants -> y_zbin [ q ] [ i ] = quants -> y_zbin [ q ] [ 1 ] ;\n quants -> y_round [ q ] [ i ] = quants -> y_round [ q ] [ 1 ] ;\n cm -> y_dequant [ q ] [ i ] = cm -> y_dequant [ q ] [ 1 ] ;\n quants -> uv_quant [ q ] [ i ] = quants -> uv_quant [ q ] [ 1 ] ;\n quants -> uv_quant_fp [ q ] [ i ] = quants -> uv_quant_fp [ q ] [ 1 ] ;\n quants -> uv_round_fp [ q ] [ i ] = quants -> uv_round_fp [ q ] [ 1 ] ;\n quants -> uv_quant_shift [ q ] [ i ] = quants -> uv_quant_shift [ q ] [ 1 ] ;\n quants -> uv_zbin [ q ] [ i ] = quants -> uv_zbin [ q ] [ 1 ] ;\n quants -> uv_round [ q ] [ i ] = quants -> uv_round [ q ] [ 1 ] ;\n cm -> uv_dequant [ q ] [ i ] = cm -> uv_dequant [ q ] [ 1 ] ;\n }\n }\n }", "idx": 277}
{"hash": -4239386405881995323, "project": "chrome", "size": 3, "label": 0, "functionSource": "void * xmlHashLookup2 ( xmlHashTablePtr table , const xmlChar * name , const xmlChar * name2 ) {\n return ( xmlHashLookup3 ( table , name , name2 , NULL ) ) ;\n }", "idx": 278}
{"hash": 6080147530626246065, "project": "debian", "size": 175, "label": 0, "functionSource": "static int vc1_decode_intra_block ( VC1Context * v , int16_t block [ 64 ] , int n , int coded , int mquant , int codingset ) {\n GetBitContext * gb = & v -> s . gb ;\n MpegEncContext * s = & v -> s ;\n int dc_pred_dir = 0 ;\n int i ;\n int16_t * dc_val ;\n int16_t * ac_val , * ac_val2 ;\n int dcdiff ;\n int mb_pos = s -> mb_x + s -> mb_y * s -> mb_stride ;\n int a_avail = v -> a_avail , c_avail = v -> c_avail ;\n int use_pred = s -> ac_pred ;\n int scale ;\n int q1 , q2 = 0 ;\n s -> dsp . clear_block ( block ) ;\n mquant = ( mquant < 1 ) ? 0 : ( ( mquant > 31 ) ? 31 : mquant ) ;\n s -> y_dc_scale = s -> y_dc_scale_table [ mquant ] ;\n s -> c_dc_scale = s -> c_dc_scale_table [ mquant ] ;\n if ( n < 4 ) {\n dcdiff = get_vlc2 ( & s -> gb , ff_msmp4_dc_luma_vlc [ s -> dc_table_index ] . table , DC_VLC_BITS , 3 ) ;\n }\n else {\n dcdiff = get_vlc2 ( & s -> gb , ff_msmp4_dc_chroma_vlc [ s -> dc_table_index ] . table , DC_VLC_BITS , 3 ) ;\n }\n if ( dcdiff < 0 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"Illegal DC VLC\\n\" ) ;\n return - 1 ;\n }\n if ( dcdiff ) {\n if ( dcdiff == 119 ) {\n if ( mquant == 1 ) dcdiff = get_bits ( gb , 10 ) ;\n else if ( mquant == 2 ) dcdiff = get_bits ( gb , 9 ) ;\n else dcdiff = get_bits ( gb , 8 ) ;\n }\n else {\n if ( mquant == 1 ) dcdiff = ( dcdiff << 2 ) + get_bits ( gb , 2 ) - 3 ;\n else if ( mquant == 2 ) dcdiff = ( dcdiff << 1 ) + get_bits1 ( gb ) - 1 ;\n }\n if ( get_bits1 ( gb ) ) dcdiff = - dcdiff ;\n }\n dcdiff += vc1_pred_dc ( & v -> s , v -> overlap , mquant , n , a_avail , c_avail , & dc_val , & dc_pred_dir ) ;\n * dc_val = dcdiff ;\n if ( n < 4 ) {\n block [ 0 ] = dcdiff * s -> y_dc_scale ;\n }\n else {\n block [ 0 ] = dcdiff * s -> c_dc_scale ;\n }\n i = 1 ;\n if ( ! a_avail ) dc_pred_dir = 1 ;\n if ( ! c_avail ) dc_pred_dir = 0 ;\n if ( ! a_avail && ! c_avail ) use_pred = 0 ;\n ac_val = s -> ac_val [ 0 ] [ 0 ] + s -> block_index [ n ] * 16 ;\n ac_val2 = ac_val ;\n scale = mquant * 2 + v -> halfpq ;\n if ( dc_pred_dir ) ac_val -= 16 ;\n else ac_val -= 16 * s -> block_wrap [ n ] ;\n q1 = s -> current_picture . qscale_table [ mb_pos ] ;\n if ( dc_pred_dir && c_avail && mb_pos ) q2 = s -> current_picture . qscale_table [ mb_pos - 1 ] ;\n if ( ! dc_pred_dir && a_avail && mb_pos >= s -> mb_stride ) q2 = s -> current_picture . qscale_table [ mb_pos - s -> mb_stride ] ;\n if ( dc_pred_dir && n == 1 ) q2 = q1 ;\n if ( ! dc_pred_dir && n == 2 ) q2 = q1 ;\n if ( n == 3 ) q2 = q1 ;\n if ( coded ) {\n int last = 0 , skip , value ;\n int k ;\n while ( ! last ) {\n vc1_decode_ac_coeff ( v , & last , & skip , & value , codingset ) ;\n i += skip ;\n if ( i > 63 ) break ;\n if ( v -> fcm == PROGRESSIVE ) block [ v -> zz_8x8 [ 0 ] [ i ++ ] ] = value ;\n else {\n if ( use_pred && ( v -> fcm == ILACE_FRAME ) ) {\n if ( ! dc_pred_dir ) block [ v -> zz_8x8 [ 2 ] [ i ++ ] ] = value ;\n else block [ v -> zz_8x8 [ 3 ] [ i ++ ] ] = value ;\n }\n else {\n block [ v -> zzi_8x8 [ i ++ ] ] = value ;\n }\n }\n }\n if ( use_pred ) {\n if ( q2 && q1 != q2 ) {\n q1 = q1 * 2 + ( ( q1 == v -> pq ) ? v -> halfpq : 0 ) - 1 ;\n q2 = q2 * 2 + ( ( q2 == v -> pq ) ? v -> halfpq : 0 ) - 1 ;\n if ( q1 < 1 ) return AVERROR_INVALIDDATA ;\n if ( dc_pred_dir ) {\n for ( k = 1 ;\n k < 8 ;\n k ++ ) block [ k << v -> left_blk_sh ] += ( ac_val [ k ] * q2 * ff_vc1_dqscale [ q1 - 1 ] + 0x20000 ) >> 18 ;\n }\n else {\n for ( k = 1 ;\n k < 8 ;\n k ++ ) block [ k << v -> top_blk_sh ] += ( ac_val [ k + 8 ] * q2 * ff_vc1_dqscale [ q1 - 1 ] + 0x20000 ) >> 18 ;\n }\n }\n else {\n if ( dc_pred_dir ) {\n for ( k = 1 ;\n k < 8 ;\n k ++ ) block [ k << v -> left_blk_sh ] += ac_val [ k ] ;\n }\n else {\n for ( k = 1 ;\n k < 8 ;\n k ++ ) block [ k << v -> top_blk_sh ] += ac_val [ k + 8 ] ;\n }\n }\n }\n for ( k = 1 ;\n k < 8 ;\n k ++ ) {\n ac_val2 [ k ] = block [ k << v -> left_blk_sh ] ;\n ac_val2 [ k + 8 ] = block [ k << v -> top_blk_sh ] ;\n }\n for ( k = 1 ;\n k < 64 ;\n k ++ ) if ( block [ k ] ) {\n block [ k ] *= scale ;\n if ( ! v -> pquantizer ) block [ k ] += ( block [ k ] < 0 ) ? - mquant : mquant ;\n }\n if ( use_pred ) i = 63 ;\n }\n else {\n int k ;\n memset ( ac_val2 , 0 , 16 * 2 ) ;\n if ( dc_pred_dir ) {\n if ( use_pred ) {\n memcpy ( ac_val2 , ac_val , 8 * 2 ) ;\n if ( q2 && q1 != q2 ) {\n q1 = q1 * 2 + ( ( q1 == v -> pq ) ? v -> halfpq : 0 ) - 1 ;\n q2 = q2 * 2 + ( ( q2 == v -> pq ) ? v -> halfpq : 0 ) - 1 ;\n if ( q1 < 1 ) return AVERROR_INVALIDDATA ;\n for ( k = 1 ;\n k < 8 ;\n k ++ ) ac_val2 [ k ] = ( ac_val2 [ k ] * q2 * ff_vc1_dqscale [ q1 - 1 ] + 0x20000 ) >> 18 ;\n }\n }\n }\n else {\n if ( use_pred ) {\n memcpy ( ac_val2 + 8 , ac_val + 8 , 8 * 2 ) ;\n if ( q2 && q1 != q2 ) {\n q1 = q1 * 2 + ( ( q1 == v -> pq ) ? v -> halfpq : 0 ) - 1 ;\n q2 = q2 * 2 + ( ( q2 == v -> pq ) ? v -> halfpq : 0 ) - 1 ;\n if ( q1 < 1 ) return AVERROR_INVALIDDATA ;\n for ( k = 1 ;\n k < 8 ;\n k ++ ) ac_val2 [ k + 8 ] = ( ac_val2 [ k + 8 ] * q2 * ff_vc1_dqscale [ q1 - 1 ] + 0x20000 ) >> 18 ;\n }\n }\n }\n if ( use_pred ) {\n if ( dc_pred_dir ) {\n for ( k = 1 ;\n k < 8 ;\n k ++ ) {\n block [ k << v -> left_blk_sh ] = ac_val2 [ k ] * scale ;\n if ( ! v -> pquantizer && block [ k << v -> left_blk_sh ] ) block [ k << v -> left_blk_sh ] += ( block [ k << v -> left_blk_sh ] < 0 ) ? - mquant : mquant ;\n }\n }\n else {\n for ( k = 1 ;\n k < 8 ;\n k ++ ) {\n block [ k << v -> top_blk_sh ] = ac_val2 [ k + 8 ] * scale ;\n if ( ! v -> pquantizer && block [ k << v -> top_blk_sh ] ) block [ k << v -> top_blk_sh ] += ( block [ k << v -> top_blk_sh ] < 0 ) ? - mquant : mquant ;\n }\n }\n i = 63 ;\n }\n }\n s -> block_last_index [ n ] = i ;\n return 0 ;\n }", "idx": 279}
{"hash": 8947170728280515149, "project": "debian", "size": 37, "label": 0, "functionSource": "static void circlearcto ( real a1 , real a2 , real cx , real cy , real r , SplineSet * cur , real * transform ) {\n SplinePoint * pt ;\n DBasePoint temp , base , cp ;\n real cplen ;\n int sign = 1 ;\n real s1 , s2 , c1 , c2 ;\n if ( a1 == a2 ) return ;\n cplen = ( a2 - a1 ) / 90 * r * .552 ;\n a1 *= 3.1415926535897932 / 180 ;\n a2 *= 3.1415926535897932 / 180 ;\n s1 = sin ( a1 ) ;\n s2 = sin ( a2 ) ;\n c1 = cos ( a1 ) ;\n c2 = cos ( a2 ) ;\n temp . x = cx + r * c2 ;\n temp . y = cy + r * s2 ;\n base . x = cx + r * c1 ;\n base . y = cy + r * s1 ;\n pt = chunkalloc ( sizeof ( SplinePoint ) ) ;\n Transform ( & pt -> me , & temp , transform ) ;\n cp . x = temp . x - cplen * s2 ;\n cp . y = temp . y + cplen * c2 ;\n if ( ( cp . x - base . x ) * ( cp . x - base . x ) + ( cp . y - base . y ) * ( cp . y - base . y ) > ( temp . x - base . x ) * ( temp . x - base . x ) + ( temp . y - base . y ) * ( temp . y - base . y ) ) {\n sign = - 1 ;\n cp . x = temp . x + cplen * s2 ;\n cp . y = temp . y - cplen * c2 ;\n }\n Transform ( & pt -> prevcp , & cp , transform ) ;\n pt -> nonextcp = true ;\n cp . x = base . x + sign * cplen * s1 ;\n cp . y = base . y - sign * cplen * c1 ;\n Transform ( & cur -> last -> nextcp , & cp , transform ) ;\n cur -> last -> nonextcp = false ;\n CheckMake ( cur -> last , pt ) ;\n SplineMake3 ( cur -> last , pt ) ;\n cur -> last = pt ;\n }", "idx": 280}
{"hash": 1245821301839614810, "project": "debian", "size": 6, "label": 0, "functionSource": "static gboolean should_skip_readdir_error ( CommonJob * common , GFile * dir ) {\n if ( common -> skip_readdir_error != NULL ) {\n return g_hash_table_lookup ( common -> skip_readdir_error , dir ) != NULL ;\n }\n return FALSE ;\n }", "idx": 281}
{"hash": 4180964683905830761, "project": "debian", "size": 45, "label": 0, "functionSource": "static int selinux_socket_sock_rcv_skb ( struct sock * sk , struct sk_buff * skb ) {\n int err ;\n struct sk_security_struct * sksec = sk -> sk_security ;\n u16 family = sk -> sk_family ;\n u32 sk_sid = sksec -> sid ;\n struct common_audit_data ad ;\n struct lsm_network_audit net = {\n 0 , }\n ;\n char * addrp ;\n u8 secmark_active ;\n u8 peerlbl_active ;\n if ( family != PF_INET && family != PF_INET6 ) return 0 ;\n if ( family == PF_INET6 && skb -> protocol == htons ( ETH_P_IP ) ) family = PF_INET ;\n if ( ! selinux_policycap_netpeer ) return selinux_sock_rcv_skb_compat ( sk , skb , family ) ;\n secmark_active = selinux_secmark_enabled ( ) ;\n peerlbl_active = selinux_peerlbl_enabled ( ) ;\n if ( ! secmark_active && ! peerlbl_active ) return 0 ;\n ad . type = LSM_AUDIT_DATA_NET ;\n ad . u . net = & net ;\n ad . u . net -> netif = skb -> skb_iif ;\n ad . u . net -> family = family ;\n err = selinux_parse_skb ( skb , & ad , & addrp , 1 , NULL ) ;\n if ( err ) return err ;\n if ( peerlbl_active ) {\n u32 peer_sid ;\n err = selinux_skb_peerlbl_sid ( skb , family , & peer_sid ) ;\n if ( err ) return err ;\n err = selinux_inet_sys_rcv_skb ( sock_net ( sk ) , skb -> skb_iif , addrp , family , peer_sid , & ad ) ;\n if ( err ) {\n selinux_netlbl_err ( skb , family , err , 0 ) ;\n return err ;\n }\n err = avc_has_perm ( sk_sid , peer_sid , SECCLASS_PEER , PEER__RECV , & ad ) ;\n if ( err ) {\n selinux_netlbl_err ( skb , family , err , 0 ) ;\n return err ;\n }\n }\n if ( secmark_active ) {\n err = avc_has_perm ( sk_sid , skb -> secmark , SECCLASS_PACKET , PACKET__RECV , & ad ) ;\n if ( err ) return err ;\n }\n return err ;\n }", "idx": 282}
{"hash": -6032494406888257778, "project": "chrome", "size": 7, "label": 0, "functionSource": "static uint32_t U_CALLCONV lenient8IteratorGetState ( const UCharIterator * iter ) {\n uint32_t state = ( uint32_t ) ( iter -> start << 1 ) ;\n if ( iter -> reservedField != 0 ) {\n state |= 1 ;\n }\n return state ;\n }", "idx": 283}
{"hash": 6323824267898511453, "project": "debian", "size": 3, "label": 0, "functionSource": "fz_colorspace * fz_device_bgr ( fz_context * ctx ) {\n return ctx -> colorspace -> bgr ;\n }", "idx": 284}
{"hash": 4423867112908498696, "project": "chrome", "size": 10, "label": 0, "functionSource": "void vp9_regular_quantize_b_4x4 ( MACROBLOCK * x , int plane , int block , const int16_t * scan , const int16_t * iscan ) {\n MACROBLOCKD * const xd = & x -> e_mbd ;\n struct macroblock_plane * p = & x -> plane [ plane ] ;\n struct macroblockd_plane * pd = & xd -> plane [ plane ] ;\n # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) {\n vp9_high_quantize_b ( BLOCK_OFFSET ( p -> coeff , block ) , 16 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , BLOCK_OFFSET ( p -> qcoeff , block ) , BLOCK_OFFSET ( pd -> dqcoeff , block ) , pd -> dequant , p -> zbin_extra , & p -> eobs [ block ] , scan , iscan ) ;\n return ;\n }\n # endif vp9_quantize_b ( BLOCK_OFFSET ( p -> coeff , block ) , 16 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , BLOCK_OFFSET ( p -> qcoeff , block ) , BLOCK_OFFSET ( pd -> dqcoeff , block ) , pd -> dequant , p -> zbin_extra , & p -> eobs [ block ] , scan , iscan ) ;\n }", "idx": 285}
{"hash": -2222463888415249941, "project": "chrome", "size": 109, "label": 0, "functionSource": "static void encode_with_recode_loop ( VP9_COMP * cpi , size_t * size , uint8_t * dest , int q , int bottom_index , int top_index ) {\n VP9_COMMON * const cm = & cpi -> common ;\n RATE_CONTROL * const rc = & cpi -> rc ;\n int loop_count = 0 ;\n int loop = 0 ;\n int overshoot_seen = 0 ;\n int undershoot_seen = 0 ;\n int q_low = bottom_index , q_high = top_index ;\n int frame_over_shoot_limit ;\n int frame_under_shoot_limit ;\n vp9_rc_compute_frame_size_bounds ( cpi , rc -> this_frame_target , & frame_under_shoot_limit , & frame_over_shoot_limit ) ;\n do {\n vp9_clear_system_state ( ) ;\n vp9_set_quantizer ( cm , q ) ;\n if ( loop_count == 0 ) setup_frame ( cpi ) ;\n if ( cpi -> oxcf . aq_mode == VARIANCE_AQ ) {\n vp9_vaq_frame_setup ( cpi ) ;\n }\n else if ( cpi -> oxcf . aq_mode == COMPLEXITY_AQ ) {\n vp9_setup_in_frame_q_adj ( cpi ) ;\n }\n vp9_encode_frame ( cpi ) ;\n vp9_clear_system_state ( ) ;\n if ( cpi -> sf . recode_loop >= ALLOW_RECODE_KFARFGF ) {\n save_coding_context ( cpi ) ;\n if ( ! cpi -> sf . use_nonrd_pick_mode ) vp9_pack_bitstream ( cpi , dest , size ) ;\n rc -> projected_frame_size = ( int ) ( * size ) << 3 ;\n restore_coding_context ( cpi ) ;\n if ( frame_over_shoot_limit == 0 ) frame_over_shoot_limit = 1 ;\n }\n if ( cpi -> oxcf . rc_mode == VPX_Q ) {\n loop = 0 ;\n }\n else {\n if ( ( cm -> frame_type == KEY_FRAME ) && rc -> this_key_frame_forced && ( rc -> projected_frame_size < rc -> max_frame_bandwidth ) ) {\n int last_q = q ;\n int kf_err = vp9_get_y_sse ( cpi -> Source , get_frame_new_buffer ( cm ) ) ;\n int high_err_target = cpi -> ambient_err ;\n int low_err_target = cpi -> ambient_err >> 1 ;\n kf_err += ! kf_err ;\n if ( ( kf_err > high_err_target && rc -> projected_frame_size <= frame_over_shoot_limit ) || ( kf_err > low_err_target && rc -> projected_frame_size <= frame_under_shoot_limit ) ) {\n q_high = q > q_low ? q - 1 : q_low ;\n q = ( q * high_err_target ) / kf_err ;\n q = MIN ( q , ( q_high + q_low ) >> 1 ) ;\n }\n else if ( kf_err < low_err_target && rc -> projected_frame_size >= frame_under_shoot_limit ) {\n q_low = q < q_high ? q + 1 : q_high ;\n q = ( q * low_err_target ) / kf_err ;\n q = MIN ( q , ( q_high + q_low + 1 ) >> 1 ) ;\n }\n q = clamp ( q , q_low , q_high ) ;\n loop = q != last_q ;\n }\n else if ( recode_loop_test ( cpi , frame_over_shoot_limit , frame_under_shoot_limit , q , MAX ( q_high , top_index ) , bottom_index ) ) {\n int last_q = q ;\n int retries = 0 ;\n if ( rc -> projected_frame_size > rc -> this_frame_target ) {\n if ( rc -> projected_frame_size >= rc -> max_frame_bandwidth ) q_high = rc -> worst_quality ;\n q_low = q < q_high ? q + 1 : q_high ;\n if ( undershoot_seen || loop_count > 1 ) {\n vp9_rc_update_rate_correction_factors ( cpi , 1 ) ;\n q = ( q_high + q_low + 1 ) / 2 ;\n }\n else {\n vp9_rc_update_rate_correction_factors ( cpi , 0 ) ;\n q = vp9_rc_regulate_q ( cpi , rc -> this_frame_target , bottom_index , MAX ( q_high , top_index ) ) ;\n while ( q < q_low && retries < 10 ) {\n vp9_rc_update_rate_correction_factors ( cpi , 0 ) ;\n q = vp9_rc_regulate_q ( cpi , rc -> this_frame_target , bottom_index , MAX ( q_high , top_index ) ) ;\n retries ++ ;\n }\n }\n overshoot_seen = 1 ;\n }\n else {\n q_high = q > q_low ? q - 1 : q_low ;\n if ( overshoot_seen || loop_count > 1 ) {\n vp9_rc_update_rate_correction_factors ( cpi , 1 ) ;\n q = ( q_high + q_low ) / 2 ;\n }\n else {\n vp9_rc_update_rate_correction_factors ( cpi , 0 ) ;\n q = vp9_rc_regulate_q ( cpi , rc -> this_frame_target , bottom_index , top_index ) ;\n if ( cpi -> oxcf . rc_mode == VPX_CQ && q < q_low ) {\n q_low = q ;\n }\n while ( q > q_high && retries < 10 ) {\n vp9_rc_update_rate_correction_factors ( cpi , 0 ) ;\n q = vp9_rc_regulate_q ( cpi , rc -> this_frame_target , bottom_index , top_index ) ;\n retries ++ ;\n }\n }\n undershoot_seen = 1 ;\n }\n q = clamp ( q , q_low , q_high ) ;\n loop = q != last_q ;\n }\n else {\n loop = 0 ;\n }\n }\n if ( rc -> is_src_frame_alt_ref && rc -> projected_frame_size < rc -> max_frame_bandwidth ) loop = 0 ;\n if ( loop ) {\n loop_count ++ ;\n # if CONFIG_INTERNAL_STATS cpi -> tot_recode_hits ++ ;\n # endif }\n }\n while ( loop ) ;\n }", "idx": 286}
{"hash": 1366214969540455677, "project": "debian", "size": 61, "label": 0, "functionSource": "WORK_STATE tls_post_process_client_hello ( SSL * s , WORK_STATE wst ) {\n int al = SSL_AD_HANDSHAKE_FAILURE ;\n const SSL_CIPHER * cipher ;\n if ( wst == WORK_MORE_A ) {\n if ( ! s -> hit ) {\n if ( s -> cert -> cert_cb ) {\n int rv = s -> cert -> cert_cb ( s , s -> cert -> cert_cb_arg ) ;\n if ( rv == 0 ) {\n al = SSL_AD_INTERNAL_ERROR ;\n SSLerr ( SSL_F_TLS_POST_PROCESS_CLIENT_HELLO , SSL_R_CERT_CB_ERROR ) ;\n goto f_err ;\n }\n if ( rv < 0 ) {\n s -> rwstate = SSL_X509_LOOKUP ;\n return WORK_MORE_A ;\n }\n s -> rwstate = SSL_NOTHING ;\n }\n cipher = ssl3_choose_cipher ( s , s -> session -> ciphers , SSL_get_ciphers ( s ) ) ;\n if ( cipher == NULL ) {\n SSLerr ( SSL_F_TLS_POST_PROCESS_CLIENT_HELLO , SSL_R_NO_SHARED_CIPHER ) ;\n goto f_err ;\n }\n s -> s3 -> tmp . new_cipher = cipher ;\n if ( s -> not_resumable_session_cb != NULL ) s -> session -> not_resumable = s -> not_resumable_session_cb ( s , ( ( cipher -> algorithm_mkey & ( SSL_kDHE | SSL_kECDHE ) ) != 0 ) ) ;\n if ( s -> session -> not_resumable ) s -> tlsext_ticket_expected = 0 ;\n }\n else {\n s -> s3 -> tmp . new_cipher = s -> session -> cipher ;\n }\n if ( ! ( s -> verify_mode & SSL_VERIFY_PEER ) ) {\n if ( ! ssl3_digest_cached_records ( s , 0 ) ) {\n al = SSL_AD_INTERNAL_ERROR ;\n goto f_err ;\n }\n }\n if ( s -> version >= SSL3_VERSION ) {\n if ( ! ssl_check_clienthello_tlsext_late ( s , & al ) ) {\n SSLerr ( SSL_F_TLS_POST_PROCESS_CLIENT_HELLO , SSL_R_CLIENTHELLO_TLSEXT ) ;\n goto f_err ;\n }\n }\n wst = WORK_MORE_B ;\n }\n # ifndef OPENSSL_NO_SRP if ( wst == WORK_MORE_B ) {\n int ret ;\n if ( ( ret = ssl_check_srp_ext_ClientHello ( s , & al ) ) < 0 ) {\n s -> rwstate = SSL_X509_LOOKUP ;\n return WORK_MORE_B ;\n }\n if ( ret != SSL_ERROR_NONE ) {\n if ( al != TLS1_AD_UNKNOWN_PSK_IDENTITY ) SSLerr ( SSL_F_TLS_POST_PROCESS_CLIENT_HELLO , SSL_R_CLIENTHELLO_TLSEXT ) ;\n goto f_err ;\n }\n }\n # endif s -> renegotiate = 2 ;\n return WORK_FINISHED_STOP ;\n f_err : ssl3_send_alert ( s , SSL3_AL_FATAL , al ) ;\n ossl_statem_set_error ( s ) ;\n return WORK_ERROR ;\n }", "idx": 287}
{"hash": -3146697469509848825, "project": "debian", "size": 3, "label": 0, "functionSource": "static int dsa_param_encode ( const EVP_PKEY * pkey , unsigned char * * pder ) {\n return i2d_DSAparams ( pkey -> pkey . dsa , pder ) ;\n }", "idx": 288}
{"hash": -4978896576290502518, "project": "debian", "size": 56, "label": 0, "functionSource": "static int sort_record_index ( MI_SORT_PARAM * sort_param , MI_INFO * info , MI_KEYDEF * keyinfo , my_off_t page , uchar * buff , uint sort_key , File new_file , my_bool update_index ) {\n uint nod_flag , used_length , key_length ;\n uchar * temp_buff , * keypos , * endpos ;\n my_off_t next_page , rec_pos ;\n uchar lastkey [ MI_MAX_KEY_BUFF ] ;\n char llbuff [ 22 ] ;\n SORT_INFO * sort_info = sort_param -> sort_info ;\n MI_CHECK * param = sort_info -> param ;\n DBUG_ENTER ( \"sort_record_index\" ) ;\n nod_flag = mi_test_if_nod ( buff ) ;\n temp_buff = 0 ;\n if ( nod_flag ) {\n if ( ! ( temp_buff = ( uchar * ) my_alloca ( ( uint ) keyinfo -> block_length ) ) ) {\n mi_check_print_error ( param , \"Not Enough memory\" ) ;\n DBUG_RETURN ( - 1 ) ;\n }\n }\n used_length = mi_getint ( buff ) ;\n keypos = buff + 2 + nod_flag ;\n endpos = buff + used_length ;\n for ( ;\n ;\n ) {\n if ( nod_flag ) {\n next_page = _mi_kpos ( nod_flag , keypos ) ;\n if ( my_pread ( info -> s -> kfile , ( uchar * ) temp_buff , ( uint ) keyinfo -> block_length , next_page , MYF ( MY_NABP + MY_WME ) ) ) {\n mi_check_print_error ( param , \"Can't read keys from filepos: %s\" , llstr ( next_page , llbuff ) ) ;\n goto err ;\n }\n if ( sort_record_index ( sort_param , info , keyinfo , next_page , temp_buff , sort_key , new_file , update_index ) ) goto err ;\n }\n if ( keypos >= endpos || ( key_length = ( * keyinfo -> get_key ) ( keyinfo , nod_flag , & keypos , lastkey ) ) == 0 ) break ;\n rec_pos = _mi_dpos ( info , 0 , lastkey + key_length ) ;\n if ( ( * info -> s -> read_rnd ) ( info , sort_param -> record , rec_pos , 0 ) ) {\n mi_check_print_error ( param , \"%d when reading datafile\" , my_errno ) ;\n goto err ;\n }\n if ( rec_pos != sort_param -> filepos && update_index ) {\n _mi_dpointer ( info , keypos - nod_flag - info -> s -> rec_reflength , sort_param -> filepos ) ;\n if ( movepoint ( info , sort_param -> record , rec_pos , sort_param -> filepos , sort_key ) ) {\n mi_check_print_error ( param , \"%d when updating key-pointers\" , my_errno ) ;\n goto err ;\n }\n }\n if ( sort_write_record ( sort_param ) ) goto err ;\n }\n bzero ( ( uchar * ) buff + used_length , keyinfo -> block_length - used_length ) ;\n if ( my_pwrite ( info -> s -> kfile , ( uchar * ) buff , ( uint ) keyinfo -> block_length , page , param -> myf_rw ) ) {\n mi_check_print_error ( param , \"%d when updating keyblock\" , my_errno ) ;\n goto err ;\n }\n if ( temp_buff ) my_afree ( ( uchar * ) temp_buff ) ;\n DBUG_RETURN ( 0 ) ;\n err : if ( temp_buff ) my_afree ( ( uchar * ) temp_buff ) ;\n DBUG_RETURN ( 1 ) ;\n }", "idx": 289}
{"hash": 9155638497612715289, "project": "debian", "size": 21, "label": 0, "functionSource": "static void typhoon_set_timer_irq ( void * opaque , int irq , int level ) {\n TyphoonState * s = opaque ;\n int i ;\n if ( level == 0 ) {\n return ;\n }\n for ( i = 0 ;\n i < 4 ;\n ++ i ) {\n AlphaCPU * cpu = s -> cchip . cpu [ i ] ;\n if ( cpu != NULL ) {\n uint32_t iic = s -> cchip . iic [ i ] ;\n iic = ( ( iic - 1 ) & 0x1ffffff ) | ( iic & 0x1000000 ) ;\n s -> cchip . iic [ i ] = iic ;\n if ( iic & 0x1000000 ) {\n s -> cchip . misc |= 1 << ( i + 4 ) ;\n cpu_interrupt ( CPU ( cpu ) , CPU_INTERRUPT_TIMER ) ;\n }\n }\n }\n }", "idx": 290}
{"hash": -341028540041678099, "project": "debian", "size": 42, "label": 0, "functionSource": "static void tokenize ( const char * line , char * * tokens , int * ntok ) {\n register const char * cp ;\n register char * sp ;\n static char tspace [ MAXLINE ] ;\n sp = tspace ;\n cp = line ;\n for ( * ntok = 0 ;\n * ntok < MAXTOKENS ;\n ( * ntok ) ++ ) {\n tokens [ * ntok ] = sp ;\n while ( ISSPACE ( * cp ) ) cp ++ ;\n if ( ISEOL ( * cp ) ) break ;\n if ( * ntok == 1 && tokens [ 0 ] [ 0 ] == ':' ) {\n do {\n if ( sp - tspace >= MAXLINE ) goto toobig ;\n * sp ++ = * cp ++ ;\n }\n while ( ! ISEOL ( * cp ) ) ;\n }\n else if ( * cp == '\\\"' ) {\n ++ cp ;\n do {\n if ( sp - tspace >= MAXLINE ) goto toobig ;\n * sp ++ = * cp ++ ;\n }\n while ( ( * cp != '\\\"' ) && ! ISEOL ( * cp ) ) ;\n }\n else {\n do {\n if ( sp - tspace >= MAXLINE ) goto toobig ;\n * sp ++ = * cp ++ ;\n }\n while ( ( * cp != '\\\"' ) && ! ISSPACE ( * cp ) && ! ISEOL ( * cp ) ) ;\n }\n if ( sp - tspace >= MAXLINE ) goto toobig ;\n * sp ++ = '\\0' ;\n }\n return ;\n toobig : * ntok = 0 ;\n fprintf ( stderr , \"***Line `%s' is too big\\n\" , line ) ;\n return ;\n }", "idx": 291}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_RoundTripDelayResponse ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_RoundTripDelayResponse , RoundTripDelayResponse_sequence ) ;\n return offset ;\n }", "idx": 292}
{"hash": -8620097311326519087, "project": "chrome", "size": 3, "label": 0, "functionSource": "void srtp_set_user_data ( srtp_t ctx , void * data ) {\n ctx -> user_data = data ;\n }", "idx": 293}
{"hash": -5268859819325807498, "project": "debian", "size": 3, "label": 0, "functionSource": "static gboolean lacks_deep_count ( NautilusFile * file ) {\n return file -> details -> deep_counts_status != NAUTILUS_REQUEST_DONE ;\n }", "idx": 294}
{"hash": 3804373597256531021, "project": "debian", "size": 11, "label": 0, "functionSource": "static void acl_insert_db ( const char * user , const char * host , const char * db , ulong privileges ) {\n ACL_DB acl_db ;\n safe_mutex_assert_owner ( & acl_cache -> lock ) ;\n acl_db . user = strdup_root ( & mem , user ) ;\n update_hostname ( & acl_db . host , * host ? strdup_root ( & mem , host ) : 0 ) ;\n acl_db . db = strdup_root ( & mem , db ) ;\n acl_db . access = privileges ;\n acl_db . sort = get_sort ( 3 , acl_db . host . hostname , acl_db . db , acl_db . user ) ;\n VOID ( push_dynamic ( & acl_dbs , ( uchar * ) & acl_db ) ) ;\n my_qsort ( ( uchar * ) dynamic_element ( & acl_dbs , 0 , ACL_DB * ) , acl_dbs . elements , sizeof ( ACL_DB ) , ( qsort_cmp ) acl_compare ) ;\n }", "idx": 295}
{"hash": 4704178797381506498, "project": "debian", "size": 3, "label": 0, "functionSource": "void kadm5_set_use_password_server ( void ) {\n use_password_server = 1 ;\n }", "idx": 296}
{"hash": 2335222688263906532, "project": "debian", "size": 26, "label": 1, "functionSource": "static int rv34_set_deblock_coef ( RV34DecContext * r ) {\n MpegEncContext * s = & r -> s ;\n int hmvmask = 0 , vmvmask = 0 , i , j ;\n int midx = s -> mb_x * 2 + s -> mb_y * 2 * s -> b8_stride ;\n int16_t ( * motion_val ) [ 2 ] = & s -> current_picture_ptr -> f . motion_val [ 0 ] [ midx ] ;\n for ( j = 0 ;\n j < 16 ;\n j += 8 ) {\n for ( i = 0 ;\n i < 2 ;\n i ++ ) {\n if ( is_mv_diff_gt_3 ( motion_val + i , 1 ) ) vmvmask |= 0x11 << ( j + i * 2 ) ;\n if ( ( j || s -> mb_y ) && is_mv_diff_gt_3 ( motion_val + i , s -> b8_stride ) ) hmvmask |= 0x03 << ( j + i * 2 ) ;\n }\n motion_val += s -> b8_stride ;\n }\n if ( s -> first_slice_line ) hmvmask &= ~ 0x000F ;\n if ( ! s -> mb_x ) vmvmask &= ~ 0x1111 ;\n if ( r -> rv30 ) {\n vmvmask |= ( vmvmask & 0x4444 ) >> 1 ;\n hmvmask |= ( hmvmask & 0x0F00 ) >> 4 ;\n if ( s -> mb_x ) r -> deblock_coefs [ s -> mb_x - 1 + s -> mb_y * s -> mb_stride ] |= ( vmvmask & 0x1111 ) << 3 ;\n if ( ! s -> first_slice_line ) r -> deblock_coefs [ s -> mb_x + ( s -> mb_y - 1 ) * s -> mb_stride ] |= ( hmvmask & 0xF ) << 12 ;\n }\n return hmvmask | vmvmask ;\n }", "idx": 297}
{"hash": -7236893719053583356, "project": "debian", "size": 3, "label": 0, "functionSource": "void proto_reg_handoff_zbee_zcl_ballast_configuration ( void ) {\n zbee_zcl_init_cluster ( ZBEE_PROTOABBREV_ZCL_BALLAST_CONFIG , proto_zbee_zcl_ballast_configuration , ett_zbee_zcl_ballast_configuration , ZBEE_ZCL_CID_BALLAST_CONFIG , ZBEE_MFG_CODE_NONE , hf_zbee_zcl_ballast_configuration_attr_id , - 1 , - 1 , ( zbee_zcl_fn_attr_data ) dissect_zcl_ballast_configuration_attr_data ) ;\n }", "idx": 298}
{"hash": 6632536031698733342, "project": "debian", "size": 7, "label": 0, "functionSource": "static const Writer * writer_get_by_name ( const char * name ) {\n int i ;\n for ( i = 0 ;\n registered_writers [ i ] ;\n i ++ ) if ( ! strcmp ( registered_writers [ i ] -> name , name ) ) return registered_writers [ i ] ;\n return NULL ;\n }", "idx": 299}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_T_crcDesired ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_T_crcDesired , T_crcDesired_sequence ) ;\n return offset ;\n }", "idx": 300}
{"hash": -6627217369018123590, "project": "chrome", "size": 3, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( ContentSettingBubbleDialogTest , InvokeDialog_protocol_handlers ) {\n RunDialog ( ) ;\n }", "idx": 301}
{"hash": 3599206110384554647, "project": "debian", "size": 25, "label": 0, "functionSource": "int PEM_write_bio_ ## name ( BIO * bp , type * x , const EVP_CIPHER * enc , unsigned char * kstr , int klen , pem_password_cb * cb , void * u ) ;\n # define DECLARE_PEM_write ( name , type ) DECLARE_PEM_write_bio ( name , type ) DECLARE_PEM_write_fp ( name , type ) # define DECLARE_PEM_write_const ( name , type ) DECLARE_PEM_write_bio_const ( name , type ) DECLARE_PEM_write_fp_const ( name , type ) # define DECLARE_PEM_write_cb ( name , type ) DECLARE_PEM_write_cb_bio ( name , type ) DECLARE_PEM_write_cb_fp ( name , type ) # define DECLARE_PEM_read ( name , type ) DECLARE_PEM_read_bio ( name , type ) DECLARE_PEM_read_fp ( name , type ) # define DECLARE_PEM_rw ( name , type ) DECLARE_PEM_read ( name , type ) DECLARE_PEM_write ( name , type ) # define DECLARE_PEM_rw_const ( name , type ) DECLARE_PEM_read ( name , type ) DECLARE_PEM_write_const ( name , type ) # define DECLARE_PEM_rw_cb ( name , type ) DECLARE_PEM_read ( name , type ) DECLARE_PEM_write_cb ( name , type ) typedef int pem_password_cb ( char * buf , int size , int rwflag , void * userdata ) ;\n int PEM_get_EVP_CIPHER_INFO ( char * header , EVP_CIPHER_INFO * cipher ) ;\n int PEM_do_header ( EVP_CIPHER_INFO * cipher , unsigned char * data , long * len , pem_password_cb * callback , void * u ) ;\n int PEM_read_bio ( BIO * bp , char * * name , char * * header , unsigned char * * data , long * len ) ;\n # define PEM_FLAG_SECURE 0x1 # define PEM_FLAG_EAY_COMPATIBLE 0x2 # define PEM_FLAG_ONLY_B64 0x4 int PEM_read_bio_ex ( BIO * bp , char * * name , char * * header , unsigned char * * data , long * len , unsigned int flags ) ;\n int PEM_bytes_read_bio_secmem ( unsigned char * * pdata , long * plen , char * * pnm , const char * name , BIO * bp , pem_password_cb * cb , void * u ) ;\n int PEM_write_bio ( BIO * bp , const char * name , const char * hdr , const unsigned char * data , long len ) ;\n int PEM_bytes_read_bio ( unsigned char * * pdata , long * plen , char * * pnm , const char * name , BIO * bp , pem_password_cb * cb , void * u ) ;\n void * PEM_ASN1_read_bio ( d2i_of_void * d2i , const char * name , BIO * bp , void * * x , pem_password_cb * cb , void * u ) ;\n int PEM_ASN1_write_bio ( i2d_of_void * i2d , const char * name , BIO * bp , void * x , const EVP_CIPHER * enc , unsigned char * kstr , int klen , pem_password_cb * cb , void * u ) ;\n STACK_OF ( X509_INFO ) * PEM_X509_INFO_read_bio ( BIO * bp , STACK_OF ( X509_INFO ) * sk , pem_password_cb * cb , void * u ) ;\n int PEM_X509_INFO_write_bio ( BIO * bp , X509_INFO * xi , EVP_CIPHER * enc , unsigned char * kstr , int klen , pem_password_cb * cd , void * u ) ;\n # ifndef OPENSSL_NO_STDIO int PEM_read ( FILE * fp , char * * name , char * * header , unsigned char * * data , long * len ) ;\n int PEM_write ( FILE * fp , const char * name , const char * hdr , const unsigned char * data , long len ) ;\n void * PEM_ASN1_read ( d2i_of_void * d2i , const char * name , FILE * fp , void * * x , pem_password_cb * cb , void * u ) ;\n int PEM_ASN1_write ( i2d_of_void * i2d , const char * name , FILE * fp , void * x , const EVP_CIPHER * enc , unsigned char * kstr , int klen , pem_password_cb * callback , void * u ) ;\n STACK_OF ( X509_INFO ) * PEM_X509_INFO_read ( FILE * fp , STACK_OF ( X509_INFO ) * sk , pem_password_cb * cb , void * u ) ;\n # endif int PEM_SignInit ( EVP_MD_CTX * ctx , EVP_MD * type ) ;\n int PEM_SignUpdate ( EVP_MD_CTX * ctx , unsigned char * d , unsigned int cnt ) ;\n int PEM_SignFinal ( EVP_MD_CTX * ctx , unsigned char * sigret , unsigned int * siglen , EVP_PKEY * pkey ) ;\n int PEM_def_callback ( char * buf , int num , int rwflag , void * userdata ) ;\n void PEM_proc_type ( char * buf , int type ) ;\n void PEM_dek_info ( char * buf , const char * type , int len , char * str ) ;\n # include < openssl / symhacks . h > DECLARE_PEM_rw ( X509 , X509 ) DECLARE_PEM_rw ( X509_AUX , X509 ) DECLARE_PEM_rw ( X509_REQ , X509_REQ ) DECLARE_PEM_write ( X509_REQ_NEW , X509_REQ ) DECLARE_PEM_rw ( X509_CRL , X509_CRL ) DECLARE_PEM_rw ( PKCS7 , PKCS7 ) DECLARE_PEM_rw ( NETSCAPE_CERT_SEQUENCE , NETSCAPE_CERT_SEQUENCE ) DECLARE_PEM_rw ( PKCS8 , X509_SIG ) DECLARE_PEM_rw ( PKCS8_PRIV_KEY_INFO , PKCS8_PRIV_KEY_INFO ) # ifndef OPENSSL_NO_RSA DECLARE_PEM_rw_cb ( RSAPrivateKey , RSA )", "idx": 302}
{"hash": 6393050609822897742, "project": "debian", "size": 6, "label": 0, "functionSource": "static void xhci_detach ( USBPort * usbport ) {\n XHCIState * xhci = usbport -> opaque ;\n XHCIPort * port = xhci_lookup_port ( xhci , usbport ) ;\n xhci_detach_slot ( xhci , usbport ) ;\n xhci_port_update ( port , 1 ) ;\n }", "idx": 303}
{"hash": -7455544248455991006, "project": "debian", "size": 8, "label": 0, "functionSource": "static void kvm_getput_reg ( __u64 * kvm_reg , target_ulong * qemu_reg , int set ) {\n if ( set ) {\n * kvm_reg = * qemu_reg ;\n }\n else {\n * qemu_reg = * kvm_reg ;\n }\n }", "idx": 304}
{"hash": -8437173884317959107, "project": "debian", "size": 6, "label": 0, "functionSource": "static float vorbisfloat2float ( unsigned val ) {\n double mant = val & 0x1fffff ;\n long exp = ( val & 0x7fe00000L ) >> 21 ;\n if ( val & 0x80000000 ) mant = - mant ;\n return ldexp ( mant , exp - 20 - 768 ) ;\n }", "idx": 305}
{"hash": 6393050609822897742, "project": "debian", "size": 18, "label": 0, "functionSource": "static void xhci_init_epctx ( XHCIEPContext * epctx , dma_addr_t pctx , uint32_t * ctx ) {\n dma_addr_t dequeue ;\n dequeue = xhci_addr64 ( ctx [ 2 ] & ~ 0xf , ctx [ 3 ] ) ;\n epctx -> type = ( ctx [ 1 ] >> EP_TYPE_SHIFT ) & EP_TYPE_MASK ;\n epctx -> pctx = pctx ;\n epctx -> max_psize = ctx [ 1 ] >> 16 ;\n epctx -> max_psize *= 1 + ( ( ctx [ 1 ] >> 8 ) & 0xff ) ;\n epctx -> max_pstreams = ( ctx [ 0 ] >> 10 ) & epctx -> xhci -> max_pstreams_mask ;\n epctx -> lsa = ( ctx [ 0 ] >> 15 ) & 1 ;\n if ( epctx -> max_pstreams ) {\n xhci_alloc_streams ( epctx , dequeue ) ;\n }\n else {\n xhci_ring_init ( epctx -> xhci , & epctx -> ring , dequeue ) ;\n epctx -> ring . ccs = ctx [ 2 ] & 1 ;\n }\n epctx -> interval = 1 << ( ( ctx [ 0 ] >> 16 ) & 0xff ) ;\n }", "idx": 306}
{"hash": -5780611388839125875, "project": "chrome", "size": 8, "label": 0, "functionSource": "const char * xmlThrDefTreeIndentString ( const char * v ) {\n const char * ret ;\n xmlMutexLock ( xmlThrDefMutex ) ;\n ret = xmlTreeIndentStringThrDef ;\n xmlTreeIndentStringThrDef = v ;\n xmlMutexUnlock ( xmlThrDefMutex ) ;\n return ret ;\n }", "idx": 307}
{"hash": 1161306432039958162, "project": "chrome", "size": 68, "label": 0, "functionSource": "static int evport_dispatch ( struct event_base * base , void * arg , struct timeval * tv ) {\n int i , res ;\n struct evport_data * epdp = arg ;\n port_event_t pevtlist [ EVENTS_PER_GETN ] ;\n int nevents = 1 ;\n struct timespec ts ;\n struct timespec * ts_p = NULL ;\n if ( tv != NULL ) {\n ts . tv_sec = tv -> tv_sec ;\n ts . tv_nsec = tv -> tv_usec * 1000 ;\n ts_p = & ts ;\n }\n for ( i = 0 ;\n i < EVENTS_PER_GETN ;\n ++ i ) {\n struct fd_info * fdi = NULL ;\n if ( epdp -> ed_pending [ i ] != - 1 ) {\n fdi = & ( epdp -> ed_fds [ epdp -> ed_pending [ i ] ] ) ;\n }\n if ( fdi != NULL && FDI_HAS_EVENTS ( fdi ) ) {\n int fd = FDI_HAS_READ ( fdi ) ? fdi -> fdi_revt -> ev_fd : fdi -> fdi_wevt -> ev_fd ;\n reassociate ( epdp , fdi , fd ) ;\n epdp -> ed_pending [ i ] = - 1 ;\n }\n }\n if ( ( res = port_getn ( epdp -> ed_port , pevtlist , EVENTS_PER_GETN , ( unsigned int * ) & nevents , ts_p ) ) == - 1 ) {\n if ( errno == EINTR || errno == EAGAIN ) {\n evsignal_process ( base ) ;\n return ( 0 ) ;\n }\n else if ( errno == ETIME ) {\n if ( nevents == 0 ) return ( 0 ) ;\n }\n else {\n event_warn ( \"port_getn\" ) ;\n return ( - 1 ) ;\n }\n }\n else if ( base -> sig . evsignal_caught ) {\n evsignal_process ( base ) ;\n }\n event_debug ( ( \"%s: port_getn reports %d events\" , __func__ , nevents ) ) ;\n for ( i = 0 ;\n i < nevents ;\n ++ i ) {\n struct event * ev ;\n struct fd_info * fdi ;\n port_event_t * pevt = & pevtlist [ i ] ;\n int fd = ( int ) pevt -> portev_object ;\n check_evportop ( epdp ) ;\n check_event ( pevt ) ;\n epdp -> ed_pending [ i ] = fd ;\n res = 0 ;\n if ( pevt -> portev_events & POLLIN ) res |= EV_READ ;\n if ( pevt -> portev_events & POLLOUT ) res |= EV_WRITE ;\n if ( pevt -> portev_events & ( POLLERR | POLLHUP | POLLNVAL ) ) res |= EV_READ | EV_WRITE ;\n assert ( epdp -> ed_nevents > fd ) ;\n fdi = & ( epdp -> ed_fds [ fd ] ) ;\n if ( ( res & EV_READ ) && ( ( ev = fdi -> fdi_revt ) != NULL ) ) {\n event_active ( ev , res , 1 ) ;\n }\n if ( ( res & EV_WRITE ) && ( ( ev = fdi -> fdi_wevt ) != NULL ) ) {\n event_active ( ev , res , 1 ) ;\n }\n }\n check_evportop ( epdp ) ;\n return ( 0 ) ;\n }", "idx": 308}
{"hash": 6570435103925347380, "project": "chrome", "size": 6, "label": 0, "functionSource": "void vp9_default_coef_probs ( VP9_COMMON * cm ) {\n vp9_copy ( cm -> fc . coef_probs [ TX_4X4 ] , default_coef_probs_4x4 ) ;\n vp9_copy ( cm -> fc . coef_probs [ TX_8X8 ] , default_coef_probs_8x8 ) ;\n vp9_copy ( cm -> fc . coef_probs [ TX_16X16 ] , default_coef_probs_16x16 ) ;\n vp9_copy ( cm -> fc . coef_probs [ TX_32X32 ] , default_coef_probs_32x32 ) ;\n }", "idx": 309}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_IS11172AudioMode ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_IS11172AudioMode , IS11172AudioMode_sequence ) ;\n return offset ;\n }", "idx": 310}
{"hash": -5459605226342014540, "project": "debian", "size": 101, "label": 0, "functionSource": "static int tm2_decode_blocks ( TM2Context * ctx , AVFrame * p ) {\n int i , j ;\n int w = ctx -> avctx -> width , h = ctx -> avctx -> height , bw = w >> 2 , bh = h >> 2 , cw = w >> 1 ;\n int type ;\n int keyframe = 1 ;\n int * Y , * U , * V ;\n uint8_t * dst ;\n for ( i = 0 ;\n i < TM2_NUM_STREAMS ;\n i ++ ) ctx -> tok_ptrs [ i ] = 0 ;\n if ( ctx -> tok_lens [ TM2_TYPE ] < bw * bh ) {\n av_log ( ctx -> avctx , AV_LOG_ERROR , \"Got %i tokens for %i blocks\\n\" , ctx -> tok_lens [ TM2_TYPE ] , bw * bh ) ;\n return AVERROR_INVALIDDATA ;\n }\n memset ( ctx -> last , 0 , 4 * bw * sizeof ( int ) ) ;\n memset ( ctx -> clast , 0 , 4 * bw * sizeof ( int ) ) ;\n for ( j = 0 ;\n j < bh ;\n j ++ ) {\n memset ( ctx -> D , 0 , 4 * sizeof ( int ) ) ;\n memset ( ctx -> CD , 0 , 4 * sizeof ( int ) ) ;\n for ( i = 0 ;\n i < bw ;\n i ++ ) {\n type = GET_TOK ( ctx , TM2_TYPE ) ;\n switch ( type ) {\n case TM2_HI_RES : tm2_hi_res_block ( ctx , p , i , j ) ;\n break ;\n case TM2_MED_RES : tm2_med_res_block ( ctx , p , i , j ) ;\n break ;\n case TM2_LOW_RES : tm2_low_res_block ( ctx , p , i , j ) ;\n break ;\n case TM2_NULL_RES : tm2_null_res_block ( ctx , p , i , j ) ;\n break ;\n case TM2_UPDATE : tm2_update_block ( ctx , p , i , j ) ;\n keyframe = 0 ;\n break ;\n case TM2_STILL : tm2_still_block ( ctx , p , i , j ) ;\n keyframe = 0 ;\n break ;\n case TM2_MOTION : tm2_motion_block ( ctx , p , i , j ) ;\n keyframe = 0 ;\n break ;\n default : av_log ( ctx -> avctx , AV_LOG_ERROR , \"Skipping unknown block type %i\\n\" , type ) ;\n }\n }\n }\n Y = ( ctx -> cur ? ctx -> Y2 : ctx -> Y1 ) ;\n U = ( ctx -> cur ? ctx -> U2 : ctx -> U1 ) ;\n V = ( ctx -> cur ? ctx -> V2 : ctx -> V1 ) ;\n dst = p -> data [ 0 ] ;\n for ( j = 0 ;\n j < h ;\n j ++ ) {\n for ( i = 0 ;\n i < w ;\n i ++ ) {\n int y = Y [ i ] , u = U [ i >> 1 ] , v = V [ i >> 1 ] ;\n dst [ 3 * i + 0 ] = av_clip_uint8 ( y + v ) ;\n dst [ 3 * i + 1 ] = av_clip_uint8 ( y ) ;\n dst [ 3 * i + 2 ] = av_clip_uint8 ( y + u ) ;\n }\n Y [ - 4 ] = Y [ - 3 ] = Y [ - 2 ] = Y [ - 1 ] = Y [ 0 ] ;\n Y [ w + 3 ] = Y [ w + 2 ] = Y [ w + 1 ] = Y [ w ] = Y [ w - 1 ] ;\n if ( j == 0 ) {\n memcpy ( Y - 4 - 1 * ctx -> y_stride , Y - 4 , ctx -> y_stride ) ;\n memcpy ( Y - 4 - 2 * ctx -> y_stride , Y - 4 , ctx -> y_stride ) ;\n memcpy ( Y - 4 - 3 * ctx -> y_stride , Y - 4 , ctx -> y_stride ) ;\n memcpy ( Y - 4 - 4 * ctx -> y_stride , Y - 4 , ctx -> y_stride ) ;\n }\n else if ( j == h - 1 ) {\n memcpy ( Y - 4 + 1 * ctx -> y_stride , Y - 4 , ctx -> y_stride ) ;\n memcpy ( Y - 4 + 2 * ctx -> y_stride , Y - 4 , ctx -> y_stride ) ;\n memcpy ( Y - 4 + 3 * ctx -> y_stride , Y - 4 , ctx -> y_stride ) ;\n memcpy ( Y - 4 + 4 * ctx -> y_stride , Y - 4 , ctx -> y_stride ) ;\n }\n Y += ctx -> y_stride ;\n if ( j & 1 ) {\n U [ - 2 ] = U [ - 1 ] = U [ 0 ] ;\n V [ - 2 ] = V [ - 1 ] = V [ 0 ] ;\n U [ cw + 1 ] = U [ cw ] = U [ cw - 1 ] ;\n V [ cw + 1 ] = V [ cw ] = V [ cw - 1 ] ;\n if ( j == 1 ) {\n memcpy ( U - 2 - 1 * ctx -> uv_stride , U - 2 , ctx -> uv_stride ) ;\n memcpy ( V - 2 - 1 * ctx -> uv_stride , V - 2 , ctx -> uv_stride ) ;\n memcpy ( U - 2 - 2 * ctx -> uv_stride , U - 2 , ctx -> uv_stride ) ;\n memcpy ( V - 2 - 2 * ctx -> uv_stride , V - 2 , ctx -> uv_stride ) ;\n }\n else if ( j == h - 1 ) {\n memcpy ( U - 2 + 1 * ctx -> uv_stride , U - 2 , ctx -> uv_stride ) ;\n memcpy ( V - 2 + 1 * ctx -> uv_stride , V - 2 , ctx -> uv_stride ) ;\n memcpy ( U - 2 + 2 * ctx -> uv_stride , U - 2 , ctx -> uv_stride ) ;\n memcpy ( V - 2 + 2 * ctx -> uv_stride , V - 2 , ctx -> uv_stride ) ;\n }\n U += ctx -> uv_stride ;\n V += ctx -> uv_stride ;\n }\n dst += p -> linesize [ 0 ] ;\n }\n return keyframe ;\n }", "idx": 311}
{"hash": -2908211205972632000, "project": "debian", "size": 6, "label": 0, "functionSource": "static void cmd_window_dright ( void ) {\n MAIN_WINDOW_REC * rec ;\n rec = mainwindows_find_right ( active_mainwin , FALSE ) ;\n if ( rec == NULL ) rec = mainwindows_find_right ( active_mainwin , TRUE ) ;\n if ( rec != NULL ) window_set_active ( rec -> active ) ;\n }", "idx": 312}
{"hash": 1742637512846796448, "project": "debian", "size": 177, "label": 0, "functionSource": "void proto_register_umts_mac ( void ) {\n module_t * mac_module ;\n static gint * ett [ ] = {\n & ett_mac , & ett_mac_fach , & ett_mac_rach , & ett_mac_dch , & ett_mac_pch , & ett_mac_edch , & ett_mac_hsdsch , & ett_mac_edch_type2 , & ett_mac_edch_type2_sdu }\n ;\n static hf_register_info hf [ ] = {\n {\n & hf_mac_rach_fdd_tctf , {\n \"Target Channel Type Field\" , \"mac.tctf\" , FT_UINT8 , BASE_HEX , VALS ( rach_fdd_tctf_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_mac_fach_fdd_tctf , {\n \"Target Channel Type Field\" , \"mac.tctf\" , FT_UINT8 , BASE_HEX , VALS ( fach_fdd_tctf_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_mac_ct , {\n \"C/T\" , \"mac.ct\" , FT_UINT8 , BASE_HEX , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_mac_ueid_type , {\n \"UEID Type\" , \"mac.ueid_type\" , FT_UINT8 , BASE_DEC , VALS ( ueid_type_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_mac_crnti , {\n \"C-RNTI (UEID)\" , \"mac.ueid\" , FT_UINT16 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_mac_urnti , {\n \"U-RNTI (UEID)\" , \"mac.ueid\" , FT_UINT32 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_mac_channel , {\n \"Logical Channel Type\" , \"mac.logical_channel\" , FT_UINT16 , BASE_DEC , VALS ( mac_logical_channel_vals ) , 0 , NULL , HFILL }\n }\n , # if 0 {\n & hf_mac_channel_str , {\n \"Logical Channel\" , \"mac.logical_channel\" , FT_STRING , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , # endif # if 0 {\n & hf_mac_channel_hsdsch , {\n \"MACd-FlowID\" , \"mac.macd_flowid\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , # endif {\n & hf_mac_macdflowd_id , {\n \"MACd-FlowID\" , \"mac.macd_flowid\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_mac_lch_id , {\n \"Logical Channel ID\" , \"mac.logical_channel_id\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_mac_trch_id , {\n \"Transport Channel ID\" , \"mac.transport_channel_id\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , # if 0 {\n & hf_mac_edch_type2_descriptors , {\n \"MAC-is Descriptors\" , \"mac.edch.type2.descriptors\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , # endif # if 0 {\n & hf_mac_edch_type2_lchid , {\n \"LCH-ID\" , \"mac.logical_channel_id\" , FT_UINT8 , BASE_HEX , NULL , 0xf0 , NULL , HFILL }\n }\n , # endif # if 0 {\n & hf_mac_edch_type2_length , {\n \"Length\" , \"mac.edch.type2.length\" , FT_UINT16 , BASE_DEC , NULL , 0x0ffe , NULL , HFILL }\n }\n , # endif # if 0 {\n & hf_mac_edch_type2_flag , {\n \"Flag\" , \"mac.edch.type2.lchid\" , FT_UINT8 , BASE_HEX , NULL , 0x01 , \"Indicates if another entry follows\" , HFILL }\n }\n , # endif {\n & hf_mac_edch_type2_ss , {\n \"SS\" , \"mac.edch.type2.ss\" , FT_UINT8 , BASE_HEX , NULL , 0xc0 , \"Segmentation Status\" , HFILL }\n }\n , {\n & hf_mac_edch_type2_ss_interpretation , {\n \"SS interpretation\" , \"mac.edch.type2.ss_interpretation\" , FT_UINT8 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_mac_edch_type2_tsn , {\n \"TSN\" , \"mac.edch.type2.tsn\" , FT_UINT16 , BASE_DEC , NULL , 0 , \"Transmission Sequence Number\" , HFILL }\n }\n , {\n & hf_mac_edch_type2_sdu , {\n \"MAC-is SDU\" , \"mac.edch.type2.sdu\" , FT_NONE , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_mac_edch_type2_sdu_data , {\n \"Data\" , \"mac.edch.type2.sdu.data\" , FT_BYTES , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , # if 0 {\n & hf_mac_edch_type2_subframe_header , {\n \"Subframe header\" , \"mac.edch.type2.subframeheader\" , FT_STRING , BASE_NONE , NULL , 0x0 , \"EDCH Subframe header\" , HFILL }\n }\n , # endif {\n & hf_mac_is_reasmin , {\n \"Reassembled in frame\" , \"mac.is.reasmin\" , FT_FRAMENUM , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_mac_is_fraglink , {\n \"Frame\" , \"mac.is.fraglink\" , FT_FRAMENUM , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n }\n ;\n static ei_register_info ei [ ] = {\n {\n & ei_mac_per_frame_info_missing , {\n \"mac.per_frame_info_missing\" , PI_MALFORMED , PI_ERROR , \"Cannot dissect MAC frame because per-frame info is missing\" , EXPFILL }\n }\n , {\n & ei_mac_unknown_content , {\n \"mac.unknown_content\" , PI_MALFORMED , PI_ERROR , \"Unknown RACH DCCH/DTCH Content\" , EXPFILL }\n }\n , {\n & ei_mac_rach_tctf_unknown , {\n \"mac.rach_tctf.unknown\" , PI_MALFORMED , PI_ERROR , \"Unknown RACH TCTF\" , EXPFILL }\n }\n , {\n & ei_mac_cs_dtch_not_implemented , {\n \"mac.cs_dtch.not_implemented\" , PI_DEBUG , PI_ERROR , \"CS DTCH Is not implemented\" , EXPFILL }\n }\n , {\n & ei_mac_fach_content_type_unknown , {\n \"mac.fach_content_type.unknown\" , PI_UNDECODED , PI_WARN , \" Unimplemented FACH Content type!\" , EXPFILL }\n }\n , {\n & ei_mac_no_logical_channel , {\n \"mac.no_logical_channel\" , PI_PROTOCOL , PI_WARN , \"Frame is missing logical channel\" , EXPFILL }\n }\n , {\n & ei_mac_faked_logical_channel_id , {\n \"mac.faked_logical_channel_id\" , PI_PROTOCOL , PI_WARN , \"This is a faked logical channel id!\" , EXPFILL }\n }\n , {\n & ei_mac_macis_sdu_reassembled , {\n \"mac.macis_sdu.reassembled\" , PI_REASSEMBLE , PI_CHAT , \"Reassembled MAC-is SDU\" , EXPFILL }\n }\n , {\n & ei_mac_macis_sdu_first , {\n \"mac.macis_sdu.first\" , PI_REASSEMBLE , PI_CHAT , \"This MAC-is SDU is the first segment of a MAC-d PDU or MAC-c PDU\" , EXPFILL }\n }\n , {\n & ei_mac_macis_sdu_middle , {\n \"mac.macis_sdu.middle\" , PI_REASSEMBLE , PI_CHAT , \"This MAC-is SDU is a middle segment of a MAC-d PDU or MAC-c PDU\" , EXPFILL }\n }\n , {\n & ei_mac_macis_sdu_last , {\n \"mac.macis_sdu.last\" , PI_REASSEMBLE , PI_CHAT , \"This MAC-is SDU is the last segment of a MAC-d PDU or MAC-c PDU\" , EXPFILL }\n }\n , {\n & ei_mac_macis_sdu_complete , {\n \"mac.macis_sdu.complete\" , PI_REASSEMBLE , PI_CHAT , \"This MAC-is SDU is a complete MAC-d PDU or MAC-c PDU\" , EXPFILL }\n }\n , {\n & ei_mac_reserved_c_t , {\n \"mac.reserved_ct\" , PI_PROTOCOL , PI_WARN , \"C/T has a reserved value, PDU is discarded\" , EXPFILL }\n }\n }\n ;\n expert_module_t * expert_umts_mac ;\n proto_umts_mac = proto_register_protocol ( \"MAC\" , \"MAC\" , \"mac\" ) ;\n proto_register_field_array ( proto_umts_mac , hf , array_length ( hf ) ) ;\n proto_register_subtree_array ( ett , array_length ( ett ) ) ;\n expert_umts_mac = expert_register_protocol ( proto_umts_mac ) ;\n expert_register_field_array ( expert_umts_mac , ei , array_length ( ei ) ) ;\n register_dissector ( \"mac.fdd.rach\" , dissect_mac_fdd_rach , proto_umts_mac ) ;\n register_dissector ( \"mac.fdd.fach\" , dissect_mac_fdd_fach , proto_umts_mac ) ;\n register_dissector ( \"mac.fdd.pch\" , dissect_mac_fdd_pch , proto_umts_mac ) ;\n register_dissector ( \"mac.fdd.dch\" , dissect_mac_fdd_dch , proto_umts_mac ) ;\n register_dissector ( \"mac.fdd.edch\" , dissect_mac_fdd_edch , proto_umts_mac ) ;\n register_dissector ( \"mac.fdd.edch.type2\" , dissect_mac_fdd_edch_type2 , proto_umts_mac ) ;\n register_dissector ( \"mac.fdd.hsdsch\" , dissect_mac_fdd_hsdsch , proto_umts_mac ) ;\n register_init_routine ( mac_init ) ;\n register_cleanup_routine ( mac_cleanup ) ;\n mac_module = prefs_register_protocol ( proto_umts_mac , NULL ) ;\n prefs_register_enum_preference ( mac_module , \"tsn_size\" , \"TSN size\" , \"TSN size in bits, either 6 or 14 bit\" , & global_mac_tsn_size , tsn_size_enumvals , FALSE ) ;\n }", "idx": 313}
{"hash": -4433254577494420260, "project": "debian", "size": 59, "label": 0, "functionSource": "static void png_handle_row ( PNGDecContext * s ) {\n uint8_t * ptr , * last_row ;\n int got_line ;\n if ( ! s -> interlace_type ) {\n ptr = s -> image_buf + s -> image_linesize * s -> y ;\n if ( s -> color_type == PNG_COLOR_TYPE_RGB_ALPHA ) {\n png_filter_row ( & s -> dsp , s -> tmp_row , s -> crow_buf [ 0 ] , s -> crow_buf + 1 , s -> last_row , s -> row_size , s -> bpp ) ;\n convert_to_rgb32 ( ptr , s -> tmp_row , s -> width , s -> filter_type == PNG_FILTER_TYPE_LOCO ) ;\n FFSWAP ( uint8_t * , s -> last_row , s -> tmp_row ) ;\n }\n else {\n if ( s -> y == 0 ) last_row = s -> last_row ;\n else last_row = ptr - s -> image_linesize ;\n png_filter_row ( & s -> dsp , ptr , s -> crow_buf [ 0 ] , s -> crow_buf + 1 , last_row , s -> row_size , s -> bpp ) ;\n }\n if ( s -> filter_type == PNG_FILTER_TYPE_LOCO && s -> color_type == PNG_COLOR_TYPE_RGB && s -> y > 0 ) deloco_rgb24 ( ptr - s -> image_linesize , s -> row_size ) ;\n s -> y ++ ;\n if ( s -> y == s -> height ) {\n s -> state |= PNG_ALLIMAGE ;\n if ( s -> filter_type == PNG_FILTER_TYPE_LOCO && s -> color_type == PNG_COLOR_TYPE_RGB ) deloco_rgb24 ( ptr , s -> row_size ) ;\n }\n }\n else {\n got_line = 0 ;\n for ( ;\n ;\n ) {\n ptr = s -> image_buf + s -> image_linesize * s -> y ;\n if ( ( ff_png_pass_ymask [ s -> pass ] << ( s -> y & 7 ) ) & 0x80 ) {\n if ( got_line ) break ;\n png_filter_row ( & s -> dsp , s -> tmp_row , s -> crow_buf [ 0 ] , s -> crow_buf + 1 , s -> last_row , s -> pass_row_size , s -> bpp ) ;\n FFSWAP ( uint8_t * , s -> last_row , s -> tmp_row ) ;\n got_line = 1 ;\n }\n if ( ( png_pass_dsp_ymask [ s -> pass ] << ( s -> y & 7 ) ) & 0x80 ) {\n png_put_interlaced_row ( ptr , s -> width , s -> bits_per_pixel , s -> pass , s -> color_type , s -> last_row ) ;\n }\n s -> y ++ ;\n if ( s -> y == s -> height ) {\n for ( ;\n ;\n ) {\n if ( s -> pass == NB_PASSES - 1 ) {\n s -> state |= PNG_ALLIMAGE ;\n goto the_end ;\n }\n else {\n s -> pass ++ ;\n s -> y = 0 ;\n s -> pass_row_size = ff_png_pass_row_size ( s -> pass , s -> bits_per_pixel , s -> width ) ;\n s -> crow_size = s -> pass_row_size + 1 ;\n if ( s -> pass_row_size != 0 ) break ;\n }\n }\n }\n }\n the_end : ;\n }\n }", "idx": 314}
{"hash": 7039307292471244756, "project": "debian", "size": 9, "label": 0, "functionSource": "static void dtap_tp_close_ue_test_loop ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len ) {\n guint32 curr_offset ;\n guint32 consumed ;\n guint curr_len ;\n curr_len = len ;\n curr_offset = offset ;\n ELEM_MAND_V ( GSM_A_PDU_TYPE_DTAP , DE_TP_UE_TEST_LOOP_MODE , NULL ) ;\n EXTRANEOUS_DATA_CHECK ( curr_len , 0 , pinfo , & ei_gsm_a_dtap_extraneous_data ) ;\n }", "idx": 315}
{"hash": 1896723564367514490, "project": "debian", "size": 5, "label": 0, "functionSource": "static VALUE ossl_cipher_name ( VALUE self ) {\n EVP_CIPHER_CTX * ctx ;\n GetCipher ( self , ctx ) ;\n return rb_str_new2 ( EVP_CIPHER_name ( EVP_CIPHER_CTX_cipher ( ctx ) ) ) ;\n }", "idx": 316}
{"hash": -1315695702746584250, "project": "debian", "size": 98, "label": 0, "functionSource": "static gboolean construct_match_selected_string ( field_info * finfo , epan_dissect_t * edt , char * * filter ) {\n header_field_info * hfinfo ;\n int abbrev_len ;\n char * ptr ;\n int buf_len ;\n int dfilter_len , i ;\n gint start , length , length_remaining ;\n guint8 c ;\n gchar is_signed_num = FALSE ;\n if ( ! finfo ) return FALSE ;\n hfinfo = finfo -> hfinfo ;\n DISSECTOR_ASSERT ( hfinfo ) ;\n abbrev_len = ( int ) strlen ( hfinfo -> abbrev ) ;\n if ( hfinfo -> strings && ( hfinfo -> display & FIELD_DISPLAY_E_MASK ) == BASE_NONE ) {\n const gchar * str = NULL ;\n switch ( hfinfo -> type ) {\n case FT_INT8 : case FT_INT16 : case FT_INT24 : case FT_INT32 : str = hf_try_val_to_str ( fvalue_get_sinteger ( & finfo -> value ) , hfinfo ) ;\n break ;\n case FT_UINT8 : case FT_UINT16 : case FT_UINT24 : case FT_UINT32 : str = hf_try_val_to_str ( fvalue_get_uinteger ( & finfo -> value ) , hfinfo ) ;\n break ;\n default : break ;\n }\n if ( str != NULL && filter != NULL ) {\n * filter = wmem_strdup_printf ( NULL , \"%s == \\\"%s\\\"\" , hfinfo -> abbrev , str ) ;\n return TRUE ;\n }\n }\n switch ( hfinfo -> type ) {\n case FT_INT8 : case FT_INT16 : case FT_INT24 : case FT_INT32 : is_signed_num = TRUE ;\n case FT_UINT8 : case FT_UINT16 : case FT_UINT24 : case FT_UINT32 : case FT_FRAMENUM : if ( filter != NULL ) {\n guint32 number ;\n char buf [ 32 ] ;\n const char * out ;\n if ( is_signed_num ) number = fvalue_get_sinteger ( & finfo -> value ) ;\n else number = fvalue_get_uinteger ( & finfo -> value ) ;\n out = hfinfo_numeric_value_format ( hfinfo , buf , number ) ;\n * filter = wmem_strdup_printf ( NULL , \"%s == %s\" , hfinfo -> abbrev , out ) ;\n }\n break ;\n case FT_INT40 : case FT_INT48 : case FT_INT56 : case FT_INT64 : is_signed_num = TRUE ;\n case FT_UINT40 : case FT_UINT48 : case FT_UINT56 : case FT_UINT64 : if ( filter != NULL ) {\n guint64 number ;\n char buf [ 48 ] ;\n const char * out ;\n if ( is_signed_num ) number = fvalue_get_sinteger64 ( & finfo -> value ) ;\n else number = fvalue_get_uinteger64 ( & finfo -> value ) ;\n out = hfinfo_numeric_value_format64 ( hfinfo , buf , number ) ;\n * filter = wmem_strdup_printf ( NULL , \"%s == %s\" , hfinfo -> abbrev , out ) ;\n }\n break ;\n case FT_PROTOCOL : if ( filter != NULL ) * filter = wmem_strdup ( NULL , finfo -> hfinfo -> abbrev ) ;\n break ;\n case FT_NONE : length = finfo -> length ;\n if ( length == 0 ) {\n if ( filter != NULL ) * filter = wmem_strdup ( NULL , finfo -> hfinfo -> abbrev ) ;\n break ;\n }\n if ( length < 0 ) return FALSE ;\n if ( edt == NULL ) return FALSE ;\n if ( finfo -> ds_tvb != edt -> tvb ) return FALSE ;\n length_remaining = tvb_captured_length_remaining ( finfo -> ds_tvb , finfo -> start ) ;\n if ( length > length_remaining ) length = length_remaining ;\n if ( length <= 0 ) return FALSE ;\n if ( filter != NULL ) {\n start = finfo -> start ;\n buf_len = 32 + length * 3 ;\n * filter = ( char * ) wmem_alloc0 ( NULL , buf_len ) ;\n ptr = * filter ;\n ptr += g_snprintf ( ptr , ( gulong ) ( buf_len - ( ptr - * filter ) ) , \"frame[%d:%d] == \" , finfo -> start , length ) ;\n for ( i = 0 ;\n i < length ;\n i ++ ) {\n c = tvb_get_guint8 ( finfo -> ds_tvb , start ) ;\n start ++ ;\n if ( i == 0 ) {\n ptr += g_snprintf ( ptr , ( gulong ) ( buf_len - ( ptr - * filter ) ) , \"%02x\" , c ) ;\n }\n else {\n ptr += g_snprintf ( ptr , ( gulong ) ( buf_len - ( ptr - * filter ) ) , \":%02x\" , c ) ;\n }\n }\n }\n break ;\n case FT_PCRE : DISSECTOR_ASSERT_NOT_REACHED ( ) ;\n break ;\n default : if ( filter != NULL ) {\n char * str ;\n dfilter_len = fvalue_string_repr_len ( & finfo -> value , FTREPR_DFILTER , finfo -> hfinfo -> display ) ;\n dfilter_len += abbrev_len + 4 + 1 ;\n * filter = ( char * ) wmem_alloc0 ( NULL , dfilter_len ) ;\n str = fvalue_to_string_repr ( NULL , & finfo -> value , FTREPR_DFILTER , finfo -> hfinfo -> display ) ;\n g_snprintf ( * filter , dfilter_len , \"%s == %s\" , hfinfo -> abbrev , str ) ;\n wmem_free ( NULL , str ) ;\n }\n break ;\n }\n return TRUE ;\n }", "idx": 317}
{"hash": 5357882892791796049, "project": "debian", "size": 6, "label": 0, "functionSource": "static inline void e1000e_ring_advance ( E1000ECore * core , const E1000E_RingInfo * r , uint32_t count ) {\n core -> mac [ r -> dh ] += count ;\n if ( core -> mac [ r -> dh ] * E1000_RING_DESC_LEN >= core -> mac [ r -> dlen ] ) {\n core -> mac [ r -> dh ] = 0 ;\n }\n }", "idx": 318}
{"hash": -7777644912037188223, "project": "debian", "size": 10, "label": 0, "functionSource": "static int decode_udvm_address_operand ( guint8 * buff , guint operand_address , guint16 * value , guint current_address ) {\n guint32 result ;\n guint16 value1 ;\n gint next_operand_address ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & value1 ) ;\n result = value1 & 0xffff ;\n result = result + current_address ;\n * value = result & 0xffff ;\n return next_operand_address ;\n }", "idx": 319}
{"hash": 2120840145598099861, "project": "chrome", "size": 7, "label": 1, "functionSource": "void exsltSaxonRegister ( void ) {\n xsltRegisterExtModule ( SAXON_NAMESPACE , ( xsltExtInitFunction ) exsltSaxonInit , ( xsltExtShutdownFunction ) exsltSaxonShutdown ) ;\n xsltRegisterExtModuleFunction ( ( const xmlChar * ) \"expression\" , SAXON_NAMESPACE , exsltSaxonExpressionFunction ) ;\n xsltRegisterExtModuleFunction ( ( const xmlChar * ) \"eval\" , SAXON_NAMESPACE , exsltSaxonEvalFunction ) ;\n xsltRegisterExtModuleFunction ( ( const xmlChar * ) \"evaluate\" , SAXON_NAMESPACE , exsltSaxonEvaluateFunction ) ;\n xsltRegisterExtModuleFunction ( ( const xmlChar * ) \"line-number\" , SAXON_NAMESPACE , exsltSaxonLineNumberFunction ) ;\n }", "idx": 320}
{"hash": -5861178779585941932, "project": "debian", "size": 3, "label": 0, "functionSource": "void safeputchar ( netdissect_options * ndo , const u_char c ) {\n ND_PRINT ( ( ndo , ( c < 0x80 && ND_ISPRINT ( c ) ) ? \"%c\" : \"\\\\0x%02x\" , c ) ) ;\n }", "idx": 321}
{"hash": 2687336064028423153, "project": "chrome", "size": 11, "label": 0, "functionSource": "int evdns_count_nameservers ( void ) {\n const struct nameserver * server = server_head ;\n int n = 0 ;\n if ( ! server ) return 0 ;\n do {\n ++ n ;\n server = server -> next ;\n }\n while ( server != server_head ) ;\n return n ;\n }", "idx": 322}
{"hash": -5280794106681745199, "project": "debian", "size": 10, "label": 0, "functionSource": "static void gst_asf_demux_release_old_pads ( GstASFDemux * demux ) {\n GST_DEBUG_OBJECT ( demux , \"Releasing old pads\" ) ;\n while ( demux -> old_num_streams > 0 ) {\n gst_pad_push_event ( demux -> old_stream [ demux -> old_num_streams - 1 ] . pad , gst_event_new_eos ( ) ) ;\n gst_asf_demux_free_stream ( demux , & demux -> old_stream [ demux -> old_num_streams - 1 ] ) ;\n -- demux -> old_num_streams ;\n }\n memset ( demux -> old_stream , 0 , sizeof ( demux -> old_stream ) ) ;\n demux -> old_num_streams = 0 ;\n }", "idx": 323}
{"hash": -2908211205972632000, "project": "debian", "size": 5, "label": 0, "functionSource": "static void cmd_window_move_up ( void ) {\n MAIN_WINDOW_REC * rec ;\n rec = mainwindows_find_upper_left ( active_mainwin ) ;\n if ( rec != NULL ) window_reparent ( active_win , rec ) ;\n }", "idx": 324}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_T_mcCapability ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_T_mcCapability , T_mcCapability_sequence ) ;\n return offset ;\n }", "idx": 325}
{"hash": 1760449185745615462, "project": "debian", "size": 11, "label": 0, "functionSource": "TSReturnCode TSClientRequestUuidGet ( TSHttpTxn txnp , char * uuid_str ) {\n sdk_assert ( sdk_sanity_check_null_ptr ( ( void * ) uuid_str ) == TS_SUCCESS ) ;\n HttpSM * sm = ( HttpSM * ) txnp ;\n const char * machine = ( char * ) Machine : : instance ( ) -> uuid . getString ( ) ;\n int len ;\n len = snprintf ( uuid_str , TS_CRUUID_STRING_LEN , \"%s-%\" PRId64 \"\" , machine , sm -> sm_id ) ;\n if ( len > TS_CRUUID_STRING_LEN ) {\n return TS_ERROR ;\n }\n return TS_SUCCESS ;\n }", "idx": 326}
{"hash": 7823043019110226810, "project": "chrome", "size": 3, "label": 0, "functionSource": "TEST_F ( ExternalProtocolHandlerTest , TestLaunchSchemeBlockedChromeUnknown ) {\n DoTest ( ExternalProtocolHandler : : BLOCK , shell_integration : : UNKNOWN_DEFAULT , Action : : BLOCK ) ;\n }", "idx": 327}
{"hash": 3599206110384554647, "project": "debian", "size": 71, "label": 1, "functionSource": "unsigned long # define BN_BYTES 8 # endif # ifdef SIXTY_FOUR_BIT # define BN_ULONG unsigned long long # define BN_BYTES 8 # endif # ifdef THIRTY_TWO_BIT # define BN_ULONG unsigned int # define BN_BYTES 4 # endif # define BN_BITS2 ( BN_BYTES * 8 ) # define BN_BITS ( BN_BITS2 * 2 ) # define BN_TBIT ( ( BN_ULONG ) 1 << ( BN_BITS2 - 1 ) ) # define BN_FLG_MALLOCED 0x01 # define BN_FLG_STATIC_DATA 0x02 # define BN_FLG_CONSTTIME 0x04 # define BN_FLG_SECURE 0x08 # if OPENSSL_API_COMPAT < 0x00908000L # define BN_FLG_EXP_CONSTTIME BN_FLG_CONSTTIME # define BN_FLG_FREE 0x8000 # endif void BN_set_flags ( BIGNUM * b , int n ) ;\n int BN_get_flags ( const BIGNUM * b , int n ) ;\n # define BN_RAND_TOP_ANY - 1 # define BN_RAND_TOP_ONE 0 # define BN_RAND_TOP_TWO 1 # define BN_RAND_BOTTOM_ANY 0 # define BN_RAND_BOTTOM_ODD 1 void BN_with_flags ( BIGNUM * dest , const BIGNUM * b , int flags ) ;\n int BN_GENCB_call ( BN_GENCB * cb , int a , int b ) ;\n BN_GENCB * BN_GENCB_new ( void ) ;\n void BN_GENCB_free ( BN_GENCB * cb ) ;\n void BN_GENCB_set_old ( BN_GENCB * gencb , void ( * callback ) ( int , int , void * ) , void * cb_arg ) ;\n void BN_GENCB_set ( BN_GENCB * gencb , int ( * callback ) ( int , int , BN_GENCB * ) , void * cb_arg ) ;\n void * BN_GENCB_get_arg ( BN_GENCB * cb ) ;\n # define BN_prime_checks 0 # define BN_prime_checks_for_size ( b ) ( ( b ) >= 3747 ? 3 : ( b ) >= 1345 ? 4 : ( b ) >= 476 ? 5 : ( b ) >= 400 ? 6 : ( b ) >= 347 ? 7 : ( b ) >= 308 ? 8 : ( b ) >= 55 ? 27 : 34 ) # define BN_num_bytes ( a ) ( ( BN_num_bits ( a ) + 7 ) / 8 ) int BN_abs_is_word ( const BIGNUM * a , const BN_ULONG w ) ;\n int BN_is_zero ( const BIGNUM * a ) ;\n int BN_is_one ( const BIGNUM * a ) ;\n int BN_is_word ( const BIGNUM * a , const BN_ULONG w ) ;\n int BN_is_odd ( const BIGNUM * a ) ;\n # define BN_one ( a ) ( BN_set_word ( ( a ) , 1 ) ) void BN_zero_ex ( BIGNUM * a ) ;\n # if OPENSSL_API_COMPAT >= 0x00908000L # define BN_zero ( a ) BN_zero_ex ( a ) # else # define BN_zero ( a ) ( BN_set_word ( ( a ) , 0 ) ) # endif const BIGNUM * BN_value_one ( void ) ;\n char * BN_options ( void ) ;\n BN_CTX * BN_CTX_new ( void ) ;\n BN_CTX * BN_CTX_secure_new ( void ) ;\n void BN_CTX_free ( BN_CTX * c ) ;\n void BN_CTX_start ( BN_CTX * ctx ) ;\n BIGNUM * BN_CTX_get ( BN_CTX * ctx ) ;\n void BN_CTX_end ( BN_CTX * ctx ) ;\n int BN_rand ( BIGNUM * rnd , int bits , int top , int bottom ) ;\n int BN_priv_rand ( BIGNUM * rnd , int bits , int top , int bottom ) ;\n int BN_rand_range ( BIGNUM * rnd , const BIGNUM * range ) ;\n int BN_priv_rand_range ( BIGNUM * rnd , const BIGNUM * range ) ;\n int BN_pseudo_rand ( BIGNUM * rnd , int bits , int top , int bottom ) ;\n int BN_pseudo_rand_range ( BIGNUM * rnd , const BIGNUM * range ) ;\n int BN_num_bits ( const BIGNUM * a ) ;\n int BN_num_bits_word ( BN_ULONG l ) ;\n int BN_security_bits ( int L , int N ) ;\n BIGNUM * BN_new ( void ) ;\n BIGNUM * BN_secure_new ( void ) ;\n void BN_clear_free ( BIGNUM * a ) ;\n BIGNUM * BN_copy ( BIGNUM * a , const BIGNUM * b ) ;\n void BN_swap ( BIGNUM * a , BIGNUM * b ) ;\n BIGNUM * BN_bin2bn ( const unsigned char * s , int len , BIGNUM * ret ) ;\n int BN_bn2bin ( const BIGNUM * a , unsigned char * to ) ;\n int BN_bn2binpad ( const BIGNUM * a , unsigned char * to , int tolen ) ;\n BIGNUM * BN_lebin2bn ( const unsigned char * s , int len , BIGNUM * ret ) ;\n int BN_bn2lebinpad ( const BIGNUM * a , unsigned char * to , int tolen ) ;\n BIGNUM * BN_mpi2bn ( const unsigned char * s , int len , BIGNUM * ret ) ;\n int BN_bn2mpi ( const BIGNUM * a , unsigned char * to ) ;\n int BN_sub ( BIGNUM * r , const BIGNUM * a , const BIGNUM * b ) ;\n int BN_usub ( BIGNUM * r , const BIGNUM * a , const BIGNUM * b ) ;\n int BN_uadd ( BIGNUM * r , const BIGNUM * a , const BIGNUM * b ) ;\n int BN_add ( BIGNUM * r , const BIGNUM * a , const BIGNUM * b ) ;\n int BN_mul ( BIGNUM * r , const BIGNUM * a , const BIGNUM * b , BN_CTX * ctx ) ;\n int BN_sqr ( BIGNUM * r , const BIGNUM * a , BN_CTX * ctx ) ;\n void BN_set_negative ( BIGNUM * b , int n ) ;\n int BN_is_negative ( const BIGNUM * b ) ;\n int BN_div ( BIGNUM * dv , BIGNUM * rem , const BIGNUM * m , const BIGNUM * d , BN_CTX * ctx ) ;\n # define BN_mod ( rem , m , d , ctx ) BN_div ( NULL , ( rem ) , ( m ) , ( d ) , ( ctx ) ) int BN_nnmod ( BIGNUM * r , const BIGNUM * m , const BIGNUM * d , BN_CTX * ctx ) ;\n int BN_mod_add ( BIGNUM * r , const BIGNUM * a , const BIGNUM * b , const BIGNUM * m , BN_CTX * ctx ) ;\n int BN_mod_add_quick ( BIGNUM * r , const BIGNUM * a , const BIGNUM * b , const BIGNUM * m ) ;\n int BN_mod_sub ( BIGNUM * r , const BIGNUM * a , const BIGNUM * b , const BIGNUM * m , BN_CTX * ctx ) ;\n int BN_mod_sub_quick ( BIGNUM * r , const BIGNUM * a , const BIGNUM * b , const BIGNUM * m ) ;\n int BN_mod_mul ( BIGNUM * r , const BIGNUM * a , const BIGNUM * b , const BIGNUM * m , BN_CTX * ctx ) ;\n int BN_mod_sqr ( BIGNUM * r , const BIGNUM * a , const BIGNUM * m , BN_CTX * ctx ) ;\n int BN_mod_lshift1 ( BIGNUM * r , const BIGNUM * a , const BIGNUM * m , BN_CTX * ctx ) ;\n int BN_mod_lshift1_quick ( BIGNUM * r , const BIGNUM * a , const BIGNUM * m ) ;\n int BN_mod_lshift ( BIGNUM * r , const BIGNUM * a , int n , const BIGNUM * m , BN_CTX * ctx ) ;\n int BN_mod_lshift_quick ( BIGNUM * r , const BIGNUM * a , int n , const BIGNUM * m ) ;\n BN_ULONG BN_mod_word ( const BIGNUM * a , BN_ULONG w ) ;\n BN_ULONG BN_div_word ( BIGNUM * a , BN_ULONG w ) ;\n int BN_mul_word ( BIGNUM * a , BN_ULONG w ) ;\n int BN_add_word ( BIGNUM * a , BN_ULONG w ) ;\n int BN_sub_word ( BIGNUM * a , BN_ULONG w ) ;\n int BN_set_word ( BIGNUM * a , BN_ULONG w ) ;\n BN_ULONG BN_get_word ( const BIGNUM * a )", "idx": 328}
{"hash": -1315695702746584250, "project": "debian", "size": 272, "label": 0, "functionSource": "const gchar * proto_custom_set ( proto_tree * tree , GSList * field_ids , gint occurrence , gchar * result , gchar * expr , const int size ) {\n guint32 number ;\n guint64 number64 ;\n guint8 * bytes ;\n ipv4_addr_and_mask * ipv4 ;\n struct e_in6_addr * ipv6 ;\n address addr ;\n guint32 n_addr ;\n const true_false_string * tfstring ;\n int len , prev_len = 0 , last , i , offset_r = 0 , offset_e = 0 ;\n GPtrArray * finfos ;\n field_info * finfo = NULL ;\n header_field_info * hfinfo ;\n const gchar * abbrev = NULL ;\n const char * hf_str_val ;\n char number_buf [ 48 ] ;\n const char * number_out ;\n char * tmpbuf , * str ;\n int * field_idx ;\n int field_id ;\n int ii = 0 ;\n g_assert ( field_ids != NULL ) ;\n while ( ( field_idx = ( int * ) g_slist_nth_data ( field_ids , ii ++ ) ) ) {\n field_id = * field_idx ;\n PROTO_REGISTRAR_GET_NTH ( ( guint ) field_id , hfinfo ) ;\n if ( ! hfinfo ) return \"\" ;\n if ( occurrence < 0 ) {\n while ( hfinfo -> same_name_prev_id != - 1 ) {\n PROTO_REGISTRAR_GET_NTH ( hfinfo -> same_name_prev_id , hfinfo ) ;\n }\n }\n while ( hfinfo ) {\n finfos = proto_get_finfo_ptr_array ( tree , hfinfo -> id ) ;\n if ( ! finfos || ! ( len = g_ptr_array_len ( finfos ) ) ) {\n if ( occurrence < 0 ) {\n hfinfo = hfinfo -> same_name_next ;\n }\n else {\n hfinfo = hfinfo_same_name_get_prev ( hfinfo ) ;\n }\n continue ;\n }\n if ( ( ( occurrence - prev_len ) > len ) || ( ( occurrence + prev_len ) < - len ) ) {\n if ( occurrence < 0 ) {\n hfinfo = hfinfo -> same_name_next ;\n }\n else {\n hfinfo = hfinfo_same_name_get_prev ( hfinfo ) ;\n }\n prev_len += len ;\n continue ;\n }\n if ( occurrence < 0 ) {\n i = occurrence + len + prev_len ;\n last = i ;\n }\n else if ( occurrence > 0 ) {\n i = occurrence - 1 - prev_len ;\n last = i ;\n }\n else {\n i = 0 ;\n last = len - 1 ;\n }\n prev_len += len ;\n while ( i <= last ) {\n finfo = ( field_info * ) g_ptr_array_index ( finfos , i ) ;\n if ( offset_r && ( offset_r < ( size - 2 ) ) ) result [ offset_r ++ ] = ',' ;\n if ( offset_e && ( offset_e < ( size - 2 ) ) ) expr [ offset_e ++ ] = ',' ;\n switch ( hfinfo -> type ) {\n case FT_NONE : if ( offset_r == 0 ) {\n result [ 0 ] = '\\0' ;\n }\n else if ( result [ offset_r - 1 ] == ',' ) {\n result [ offset_r - 1 ] = '\\0' ;\n }\n break ;\n case FT_PROTOCOL : g_strlcpy ( result , \"Yes\" , size ) ;\n break ;\n case FT_UINT_BYTES : case FT_BYTES : bytes = ( guint8 * ) fvalue_get ( & finfo -> value ) ;\n if ( bytes ) {\n switch ( hfinfo -> display ) {\n case SEP_DOT : str = bytestring_to_str ( NULL , bytes , fvalue_length ( & finfo -> value ) , '.' ) ;\n break ;\n case SEP_DASH : str = bytestring_to_str ( NULL , bytes , fvalue_length ( & finfo -> value ) , '-' ) ;\n break ;\n case SEP_COLON : str = bytestring_to_str ( NULL , bytes , fvalue_length ( & finfo -> value ) , ':' ) ;\n break ;\n case SEP_SPACE : str = bytestring_to_str ( NULL , bytes , fvalue_length ( & finfo -> value ) , ' ' ) ;\n break ;\n case BASE_NONE : default : if ( prefs . display_byte_fields_with_spaces ) {\n str = bytestring_to_str ( NULL , bytes , fvalue_length ( & finfo -> value ) , ' ' ) ;\n }\n else {\n str = bytes_to_str ( NULL , bytes , fvalue_length ( & finfo -> value ) ) ;\n }\n break ;\n }\n offset_r += protoo_strlcpy ( result + offset_r , str , size - offset_r ) ;\n wmem_free ( NULL , str ) ;\n }\n else {\n if ( hfinfo -> display & BASE_ALLOW_ZERO ) {\n offset_r += protoo_strlcpy ( result + offset_r , \"<none>\" , size - offset_r ) ;\n }\n else {\n offset_r += protoo_strlcpy ( result + offset_r , \"<MISSING>\" , size - offset_r ) ;\n }\n }\n break ;\n case FT_ABSOLUTE_TIME : tmpbuf = abs_time_to_str ( NULL , ( const nstime_t * ) fvalue_get ( & finfo -> value ) , ( absolute_time_display_e ) hfinfo -> display , TRUE ) ;\n offset_r += protoo_strlcpy ( result + offset_r , tmpbuf , size - offset_r ) ;\n wmem_free ( NULL , tmpbuf ) ;\n break ;\n case FT_RELATIVE_TIME : tmpbuf = rel_time_to_secs_str ( NULL , ( const nstime_t * ) fvalue_get ( & finfo -> value ) ) ;\n offset_r += protoo_strlcpy ( result + offset_r , tmpbuf , size - offset_r ) ;\n wmem_free ( NULL , tmpbuf ) ;\n break ;\n case FT_BOOLEAN : number64 = fvalue_get_uinteger64 ( & finfo -> value ) ;\n tfstring = ( const true_false_string * ) & tfs_true_false ;\n if ( hfinfo -> strings ) {\n tfstring = ( const struct true_false_string * ) hfinfo -> strings ;\n }\n offset_r += protoo_strlcpy ( result + offset_r , number64 ? tfstring -> true_string : tfstring -> false_string , size - offset_r ) ;\n offset_e += protoo_strlcpy ( expr + offset_e , number64 ? \"1\" : \"0\" , size - offset_e ) ;\n break ;\n case FT_INT8 : case FT_INT16 : case FT_INT24 : case FT_INT32 : case FT_UINT8 : case FT_UINT16 : case FT_UINT24 : case FT_UINT32 : case FT_FRAMENUM : hf_str_val = NULL ;\n number = IS_FT_INT ( hfinfo -> type ) ? ( guint32 ) fvalue_get_sinteger ( & finfo -> value ) : fvalue_get_uinteger ( & finfo -> value ) ;\n if ( ( hfinfo -> display & FIELD_DISPLAY_E_MASK ) == BASE_CUSTOM ) {\n gchar tmp [ ITEM_LABEL_LENGTH ] ;\n custom_fmt_func_t fmtfunc = ( custom_fmt_func_t ) hfinfo -> strings ;\n DISSECTOR_ASSERT ( fmtfunc ) ;\n fmtfunc ( tmp , number ) ;\n offset_r += protoo_strlcpy ( result + offset_r , tmp , size - offset_r ) ;\n }\n else if ( hfinfo -> strings && hfinfo -> type != FT_FRAMENUM ) {\n number_out = hf_str_val = hf_try_val_to_str ( number , hfinfo ) ;\n if ( ! number_out ) number_out = hfinfo_number_value_format_display ( hfinfo , BASE_DEC , number_buf , number ) ;\n offset_r += protoo_strlcpy ( result + offset_r , number_out , size - offset_r ) ;\n }\n else {\n number_out = hfinfo_number_value_format ( hfinfo , number_buf , number ) ;\n offset_r += protoo_strlcpy ( result + offset_r , number_out , size - offset_r ) ;\n }\n if ( hf_str_val && ( hfinfo -> display & FIELD_DISPLAY_E_MASK ) == BASE_NONE ) {\n g_snprintf ( expr + offset_e , size - offset_e , \"\\\"%s\\\"\" , hf_str_val ) ;\n }\n else {\n number_out = hfinfo_numeric_value_format ( hfinfo , number_buf , number ) ;\n g_strlcpy ( expr + offset_e , number_out , size - offset_e ) ;\n }\n offset_e = ( int ) strlen ( expr ) ;\n break ;\n case FT_INT40 : case FT_INT48 : case FT_INT56 : case FT_INT64 : case FT_UINT40 : case FT_UINT48 : case FT_UINT56 : case FT_UINT64 : hf_str_val = NULL ;\n number64 = IS_FT_INT ( hfinfo -> type ) ? ( guint64 ) fvalue_get_sinteger64 ( & finfo -> value ) : fvalue_get_uinteger64 ( & finfo -> value ) ;\n if ( ( hfinfo -> display & FIELD_DISPLAY_E_MASK ) == BASE_CUSTOM ) {\n gchar tmp [ ITEM_LABEL_LENGTH ] ;\n custom_fmt_func_64_t fmtfunc64 = ( custom_fmt_func_64_t ) hfinfo -> strings ;\n DISSECTOR_ASSERT ( fmtfunc64 ) ;\n fmtfunc64 ( tmp , number64 ) ;\n offset_r += protoo_strlcpy ( result + offset_r , tmp , size - offset_r ) ;\n }\n else if ( hfinfo -> strings ) {\n number_out = hf_str_val = hf_try_val64_to_str ( number64 , hfinfo ) ;\n if ( ! number_out ) number_out = hfinfo_number_value_format_display64 ( hfinfo , BASE_DEC , number_buf , number64 ) ;\n offset_r += protoo_strlcpy ( result + offset_r , number_out , size - offset_r ) ;\n }\n else {\n number_out = hfinfo_number_value_format64 ( hfinfo , number_buf , number64 ) ;\n offset_r += protoo_strlcpy ( result + offset_r , number_out , size - offset_r ) ;\n }\n if ( hf_str_val && ( hfinfo -> display & FIELD_DISPLAY_E_MASK ) == BASE_NONE ) {\n g_snprintf ( expr + offset_e , size - offset_e , \"\\\"%s\\\"\" , hf_str_val ) ;\n }\n else {\n number_out = hfinfo_numeric_value_format64 ( hfinfo , number_buf , number64 ) ;\n g_strlcpy ( expr + offset_e , number_out , size - offset_e ) ;\n }\n offset_e = ( int ) strlen ( expr ) ;\n break ;\n case FT_EUI64 : str = eui64_to_str ( NULL , fvalue_get_uinteger64 ( & finfo -> value ) ) ;\n offset_r += protoo_strlcpy ( result + offset_r , str , size - offset_r ) ;\n wmem_free ( NULL , str ) ;\n break ;\n case FT_IPv4 : ipv4 = ( ipv4_addr_and_mask * ) fvalue_get ( & finfo -> value ) ;\n n_addr = ipv4_get_net_order_addr ( ipv4 ) ;\n set_address ( & addr , AT_IPv4 , 4 , & n_addr ) ;\n address_to_str_buf ( & addr , result + offset_r , size - offset_r ) ;\n offset_r = ( int ) strlen ( result ) ;\n break ;\n case FT_IPv6 : ipv6 = ( struct e_in6_addr * ) fvalue_get ( & finfo -> value ) ;\n set_address ( & addr , AT_IPv6 , sizeof ( struct e_in6_addr ) , ipv6 ) ;\n address_to_str_buf ( & addr , result + offset_r , size - offset_r ) ;\n offset_r = ( int ) strlen ( result ) ;\n break ;\n case FT_FCWWN : set_address ( & addr , AT_FCWWN , FCWWN_ADDR_LEN , fvalue_get ( & finfo -> value ) ) ;\n address_to_str_buf ( & addr , result + offset_r , size - offset_r ) ;\n offset_r = ( int ) strlen ( result ) ;\n break ;\n case FT_ETHER : set_address ( & addr , AT_ETHER , FT_ETHER_LEN , fvalue_get ( & finfo -> value ) ) ;\n address_to_str_buf ( & addr , result + offset_r , size - offset_r ) ;\n offset_r = ( int ) strlen ( result ) ;\n break ;\n case FT_GUID : str = guid_to_str ( NULL , ( e_guid_t * ) fvalue_get ( & finfo -> value ) ) ;\n offset_r += protoo_strlcpy ( result + offset_r , str , size - offset_r ) ;\n wmem_free ( NULL , str ) ;\n break ;\n case FT_REL_OID : bytes = ( guint8 * ) fvalue_get ( & finfo -> value ) ;\n str = rel_oid_resolved_from_encoded ( NULL , bytes , fvalue_length ( & finfo -> value ) ) ;\n offset_r += protoo_strlcpy ( result + offset_r , str , size - offset_r ) ;\n wmem_free ( NULL , str ) ;\n str = rel_oid_encoded2string ( NULL , bytes , fvalue_length ( & finfo -> value ) ) ;\n offset_e += protoo_strlcpy ( expr + offset_e , str , size - offset_e ) ;\n wmem_free ( NULL , str ) ;\n break ;\n case FT_OID : bytes = ( guint8 * ) fvalue_get ( & finfo -> value ) ;\n str = oid_resolved_from_encoded ( NULL , bytes , fvalue_length ( & finfo -> value ) ) ;\n offset_r += protoo_strlcpy ( result + offset_r , str , size - offset_r ) ;\n wmem_free ( NULL , str ) ;\n str = oid_encoded2string ( NULL , bytes , fvalue_length ( & finfo -> value ) ) ;\n offset_e += protoo_strlcpy ( expr + offset_e , str , size - offset_e ) ;\n wmem_free ( NULL , str ) ;\n break ;\n case FT_SYSTEM_ID : bytes = ( guint8 * ) fvalue_get ( & finfo -> value ) ;\n str = print_system_id ( NULL , bytes , fvalue_length ( & finfo -> value ) ) ;\n offset_r += protoo_strlcpy ( result + offset_r , str , size - offset_r ) ;\n offset_e += protoo_strlcpy ( expr + offset_e , str , size - offset_e ) ;\n wmem_free ( NULL , str ) ;\n break ;\n case FT_FLOAT : g_snprintf ( result + offset_r , size - offset_r , \"%.\" G_STRINGIFY ( FLT_DIG ) \"g\" , fvalue_get_floating ( & finfo -> value ) ) ;\n offset_r = ( int ) strlen ( result ) ;\n break ;\n case FT_DOUBLE : g_snprintf ( result + offset_r , size - offset_r , \"%.\" G_STRINGIFY ( DBL_DIG ) \"g\" , fvalue_get_floating ( & finfo -> value ) ) ;\n offset_r = ( int ) strlen ( result ) ;\n break ;\n case FT_STRING : case FT_STRINGZ : case FT_UINT_STRING : case FT_STRINGZPAD : bytes = ( guint8 * ) fvalue_get ( & finfo -> value ) ;\n offset_r += protoo_strlcpy ( result + offset_r , hfinfo_format_text ( hfinfo , bytes ) , size - offset_r ) ;\n break ;\n case FT_IEEE_11073_SFLOAT : str = fvalue_to_string_repr ( NULL , & finfo -> value , FTREPR_DISPLAY , hfinfo -> display ) ;\n g_snprintf ( result + offset_r , size - offset_r , \"%s: %s\" , hfinfo -> name , str ) ;\n wmem_free ( NULL , str ) ;\n offset_r = ( int ) strlen ( result ) ;\n break ;\n case FT_IEEE_11073_FLOAT : str = fvalue_to_string_repr ( NULL , & finfo -> value , FTREPR_DISPLAY , hfinfo -> display ) ;\n g_snprintf ( result + offset_r , size - offset_r , \"%s: %s\" , hfinfo -> name , str ) ;\n offset_r = ( int ) strlen ( result ) ;\n wmem_free ( NULL , str ) ;\n break ;\n case FT_IPXNET : case FT_PCRE : default : g_error ( \"hfinfo->type %d (%s) not handled\\n\" , hfinfo -> type , ftype_name ( hfinfo -> type ) ) ;\n DISSECTOR_ASSERT_NOT_REACHED ( ) ;\n break ;\n }\n i ++ ;\n }\n switch ( hfinfo -> type ) {\n case FT_BOOLEAN : case FT_UINT8 : case FT_UINT16 : case FT_UINT24 : case FT_UINT32 : case FT_UINT40 : case FT_UINT48 : case FT_UINT56 : case FT_UINT64 : case FT_FRAMENUM : case FT_INT8 : case FT_INT16 : case FT_INT24 : case FT_INT32 : case FT_INT40 : case FT_INT48 : case FT_INT56 : case FT_INT64 : case FT_OID : case FT_REL_OID : case FT_SYSTEM_ID : break ;\n default : g_strlcpy ( expr , result , size ) ;\n break ;\n }\n if ( ! abbrev ) {\n abbrev = hfinfo -> abbrev ;\n }\n if ( occurrence == 0 ) {\n hfinfo = hfinfo_same_name_get_prev ( hfinfo ) ;\n }\n else {\n hfinfo = NULL ;\n }\n }\n }\n return abbrev ? abbrev : \"\" ;\n }", "idx": 329}
{"hash": 1286774465219423144, "project": "debian", "size": 14, "label": 1, "functionSource": "static void jbig2_decode_mmr_init ( Jbig2MmrCtx * mmr , int width , int height , const byte * data , size_t size ) {\n int i ;\n uint32_t word = 0 ;\n mmr -> width = width ;\n mmr -> height = height ;\n mmr -> data = data ;\n mmr -> size = size ;\n mmr -> data_index = 0 ;\n mmr -> bit_index = 0 ;\n for ( i = 0 ;\n i < size && i < 4 ;\n i ++ ) word |= ( data [ i ] << ( ( 3 - i ) << 3 ) ) ;\n mmr -> word = word ;\n }", "idx": 330}
{"hash": 5611940141018433728, "project": "chrome", "size": 13, "label": 0, "functionSource": "static void update_coef_probs ( VP9_COMP * cpi , vp9_writer * w ) {\n const TX_MODE tx_mode = cpi -> common . tx_mode ;\n const TX_SIZE max_tx_size = tx_mode_to_biggest_tx_size [ tx_mode ] ;\n TX_SIZE tx_size ;\n vp9_coeff_stats frame_branch_ct [ TX_SIZES ] [ PLANE_TYPES ] ;\n vp9_coeff_probs_model frame_coef_probs [ TX_SIZES ] [ PLANE_TYPES ] ;\n for ( tx_size = TX_4X4 ;\n tx_size <= TX_32X32 ;\n ++ tx_size ) build_tree_distribution ( cpi , tx_size , frame_branch_ct [ tx_size ] , frame_coef_probs [ tx_size ] ) ;\n for ( tx_size = TX_4X4 ;\n tx_size <= max_tx_size ;\n ++ tx_size ) update_coef_probs_common ( w , cpi , tx_size , frame_branch_ct [ tx_size ] , frame_coef_probs [ tx_size ] ) ;\n }", "idx": 331}
{"hash": 2064081176034684128, "project": "debian", "size": 50, "label": 0, "functionSource": "static int matroska_parse_frame ( MatroskaDemuxContext * matroska , MatroskaTrack * track , AVStream * st , uint8_t * data , int pkt_size , uint64_t timecode , uint64_t duration , int64_t pos , int is_keyframe ) {\n MatroskaTrackEncoding * encodings = track -> encodings . elem ;\n uint8_t * pkt_data = data ;\n int offset = 0 , res ;\n AVPacket * pkt ;\n if ( encodings && encodings -> scope & 1 ) {\n res = matroska_decode_buffer ( & pkt_data , & pkt_size , track ) ;\n if ( res < 0 ) return res ;\n }\n if ( st -> codec -> codec_id == AV_CODEC_ID_WAVPACK ) {\n uint8_t * wv_data ;\n res = matroska_parse_wavpack ( track , pkt_data , & wv_data , & pkt_size ) ;\n if ( res < 0 ) {\n av_log ( matroska -> ctx , AV_LOG_ERROR , \"Error parsing a wavpack block.\\n\" ) ;\n goto fail ;\n }\n if ( pkt_data != data ) av_freep ( & pkt_data ) ;\n pkt_data = wv_data ;\n }\n if ( st -> codec -> codec_id == AV_CODEC_ID_PRORES ) offset = 8 ;\n pkt = av_mallocz ( sizeof ( AVPacket ) ) ;\n if ( av_new_packet ( pkt , pkt_size + offset ) < 0 ) {\n av_free ( pkt ) ;\n av_freep ( & pkt_data ) ;\n return AVERROR ( ENOMEM ) ;\n }\n if ( st -> codec -> codec_id == AV_CODEC_ID_PRORES ) {\n uint8_t * buf = pkt -> data ;\n bytestream_put_be32 ( & buf , pkt_size ) ;\n bytestream_put_be32 ( & buf , MKBETAG ( 'i' , 'c' , 'p' , 'f' ) ) ;\n }\n memcpy ( pkt -> data + offset , pkt_data , pkt_size ) ;\n if ( pkt_data != data ) av_free ( pkt_data ) ;\n pkt -> flags = is_keyframe ;\n pkt -> stream_index = st -> index ;\n if ( track -> ms_compat ) pkt -> dts = timecode ;\n else pkt -> pts = timecode ;\n pkt -> pos = pos ;\n if ( st -> codec -> codec_id == AV_CODEC_ID_TEXT ) pkt -> convergence_duration = duration ;\n else if ( track -> type != MATROSKA_TRACK_TYPE_SUBTITLE ) pkt -> duration = duration ;\n if ( st -> codec -> codec_id == AV_CODEC_ID_SSA ) matroska_fix_ass_packet ( matroska , pkt , duration ) ;\n if ( matroska -> prev_pkt && timecode != AV_NOPTS_VALUE && matroska -> prev_pkt -> pts == timecode && matroska -> prev_pkt -> stream_index == st -> index && st -> codec -> codec_id == AV_CODEC_ID_SSA ) matroska_merge_packets ( matroska -> prev_pkt , pkt ) ;\n else {\n dynarray_add ( & matroska -> packets , & matroska -> num_packets , pkt ) ;\n matroska -> prev_pkt = pkt ;\n }\n return 0 ;\n fail : if ( pkt_data != data ) av_freep ( & pkt_data ) ;\n return res ;\n }", "idx": 332}
{"hash": -8531860357798072773, "project": "debian", "size": 26, "label": 0, "functionSource": "bool key_changed_h ( connection_t * c ) {\n char name [ MAX_STRING_SIZE ] ;\n node_t * n ;\n if ( sscanf ( c -> buffer , \"%*d %*x \" MAX_STRING , name ) != 1 ) {\n logger ( LOG_ERR , \"Got bad %s from %s (%s)\" , \"KEY_CHANGED\" , c -> name , c -> hostname ) ;\n return false ;\n }\n if ( ! check_id ( name ) ) {\n logger ( LOG_ERR , \"Got bad %s from %s (%s): %s\" , \"KEY_CHANGED\" , c -> name , c -> hostname , \"invalid name\" ) ;\n return false ;\n }\n if ( seen_request ( c -> buffer ) ) {\n return true ;\n }\n n = lookup_node ( name ) ;\n if ( ! n ) {\n logger ( LOG_ERR , \"Got %s from %s (%s) origin %s which does not exist\" , \"KEY_CHANGED\" , c -> name , c -> hostname , name ) ;\n return true ;\n }\n n -> status . validkey = false ;\n n -> last_req_key = 0 ;\n if ( ! tunnelserver ) {\n forward_request ( c ) ;\n }\n return true ;\n }", "idx": 333}
{"hash": -4055702019813176658, "project": "debian", "size": 9, "label": 0, "functionSource": "static guint call_list_length ( call_list * list ) {\n guint count = 0 ;\n for ( ;\n list ;\n list = list -> next ) {\n count ++ ;\n }\n return count ;\n }", "idx": 334}
{"hash": -1983921383858884161, "project": "debian", "size": 16, "label": 0, "functionSource": "static int ipvideo_decode_block_opcode_0x4 ( IpvideoContext * s , AVFrame * frame ) {\n int x , y ;\n unsigned char B , BL , BH ;\n if ( ! s -> is_16bpp ) {\n B = bytestream2_get_byte ( & s -> stream_ptr ) ;\n }\n else {\n B = bytestream2_get_byte ( & s -> mv_ptr ) ;\n }\n BL = B & 0x0F ;\n BH = ( B >> 4 ) & 0x0F ;\n x = - 8 + BL ;\n y = - 8 + BH ;\n av_dlog ( NULL , \" motion byte = %d, (x, y) = (%d, %d)\\n\" , B , x , y ) ;\n return copy_from ( s , s -> last_frame , frame , x , y ) ;\n }", "idx": 335}
{"hash": 8461266595329035000, "project": "chrome", "size": 3, "label": 0, "functionSource": "const char * event_get_version ( void ) {\n return ( VERSION ) ;\n }", "idx": 336}
{"hash": -7434014980763120366, "project": "debian", "size": 3, "label": 0, "functionSource": "int dissect_ber_constrained_set_of ( gboolean implicit_tag , asn1_ctx_t * actx , proto_tree * parent_tree , tvbuff_t * tvb , int offset , gint32 min_len , gint32 max_len , const ber_sequence_t * seq , gint hf_id , gint ett_id ) {\n return dissect_ber_sq_of ( implicit_tag , BER_UNI_TAG_SET , actx , parent_tree , tvb , offset , min_len , max_len , seq , hf_id , ett_id ) ;\n }", "idx": 337}
{"hash": -3135212895432241239, "project": "debian", "size": 4, "label": 0, "functionSource": "static void dissect_netbios_payload ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree ) {\n heur_dtbl_entry_t * hdtbl_entry ;\n if ( ! dissector_try_heuristic ( netbios_heur_subdissector_list , tvb , pinfo , tree , & hdtbl_entry , NULL ) ) call_data_dissector ( tvb , pinfo , tree ) ;\n }", "idx": 338}
{"hash": 4180964683905830761, "project": "debian", "size": 17, "label": 0, "functionSource": "static int selinux_binder_transfer_file ( struct task_struct * from , struct task_struct * to , struct file * file ) {\n u32 sid = task_sid ( to ) ;\n struct file_security_struct * fsec = file -> f_security ;\n struct dentry * dentry = file -> f_path . dentry ;\n struct inode_security_struct * isec ;\n struct common_audit_data ad ;\n int rc ;\n ad . type = LSM_AUDIT_DATA_PATH ;\n ad . u . path = file -> f_path ;\n if ( sid != fsec -> sid ) {\n rc = avc_has_perm ( sid , fsec -> sid , SECCLASS_FD , FD__USE , & ad ) ;\n if ( rc ) return rc ;\n }\n if ( unlikely ( IS_PRIVATE ( d_backing_inode ( dentry ) ) ) ) return 0 ;\n isec = backing_inode_security ( dentry ) ;\n return avc_has_perm ( sid , isec -> sid , isec -> sclass , file_to_av ( file ) , & ad ) ;\n }", "idx": 339}
{"hash": -2922528420890432122, "project": "debian", "size": 25, "label": 0, "functionSource": "static void wma_lsp_to_curve ( WMACodecContext * s , float * out , float * val_max_ptr , int n , float * lsp ) {\n int i , j ;\n float p , q , w , v , val_max ;\n val_max = 0 ;\n for ( i = 0 ;\n i < n ;\n i ++ ) {\n p = 0.5f ;\n q = 0.5f ;\n w = s -> lsp_cos_table [ i ] ;\n for ( j = 1 ;\n j < NB_LSP_COEFS ;\n j += 2 ) {\n q *= w - lsp [ j - 1 ] ;\n p *= w - lsp [ j ] ;\n }\n p *= p * ( 2.0f - w ) ;\n q *= q * ( 2.0f + w ) ;\n v = p + q ;\n v = pow_m1_4 ( s , v ) ;\n if ( v > val_max ) val_max = v ;\n out [ i ] = v ;\n }\n * val_max_ptr = val_max ;\n }", "idx": 340}
{"hash": -5262394088289559608, "project": "debian", "size": 12, "label": 0, "functionSource": "static void timerblock_tick ( void * opaque ) {\n TimerBlock * tb = ( TimerBlock * ) opaque ;\n tb -> status = 1 ;\n if ( tb -> control & 2 ) {\n tb -> count = tb -> load ;\n timerblock_reload ( tb , 0 ) ;\n }\n else {\n tb -> count = 0 ;\n }\n timerblock_update_irq ( tb ) ;\n }", "idx": 341}
{"hash": -8437173884317959107, "project": "debian", "size": 83, "label": 0, "functionSource": "static int vorbis_floor0_decode ( vorbis_context * vc , vorbis_floor_data * vfu , float * vec ) {\n vorbis_floor0 * vf = & vfu -> t0 ;\n float * lsp = vf -> lsp ;\n unsigned amplitude , book_idx ;\n unsigned blockflag = vc -> modes [ vc -> mode_number ] . blockflag ;\n if ( ! vf -> amplitude_bits ) return 1 ;\n amplitude = get_bits ( & vc -> gb , vf -> amplitude_bits ) ;\n if ( amplitude > 0 ) {\n float last = 0 ;\n unsigned idx , lsp_len = 0 ;\n vorbis_codebook codebook ;\n book_idx = get_bits ( & vc -> gb , ilog ( vf -> num_books ) ) ;\n if ( book_idx >= vf -> num_books ) {\n av_log ( vc -> avctx , AV_LOG_ERROR , \"floor0 dec: booknumber too high!\\n\" ) ;\n book_idx = 0 ;\n }\n av_dlog ( NULL , \"floor0 dec: booknumber: %u\\n\" , book_idx ) ;\n codebook = vc -> codebooks [ vf -> book_list [ book_idx ] ] ;\n if ( ! codebook . codevectors ) return AVERROR_INVALIDDATA ;\n while ( lsp_len < vf -> order ) {\n int vec_off ;\n av_dlog ( NULL , \"floor0 dec: book dimension: %d\\n\" , codebook . dimensions ) ;\n av_dlog ( NULL , \"floor0 dec: maximum depth: %d\\n\" , codebook . maxdepth ) ;\n vec_off = get_vlc2 ( & vc -> gb , codebook . vlc . table , codebook . nb_bits , codebook . maxdepth ) * codebook . dimensions ;\n av_dlog ( NULL , \"floor0 dec: vector offset: %d\\n\" , vec_off ) ;\n for ( idx = 0 ;\n idx < codebook . dimensions ;\n ++ idx ) lsp [ lsp_len + idx ] = codebook . codevectors [ vec_off + idx ] + last ;\n last = lsp [ lsp_len + idx - 1 ] ;\n lsp_len += codebook . dimensions ;\n }\n {\n int idx ;\n for ( idx = 0 ;\n idx < lsp_len ;\n ++ idx ) av_dlog ( NULL , \"floor0 dec: coeff at %d is %f\\n\" , idx , lsp [ idx ] ) ;\n }\n {\n int i ;\n int order = vf -> order ;\n float wstep = M_PI / vf -> bark_map_size ;\n for ( i = 0 ;\n i < order ;\n i ++ ) lsp [ i ] = 2.0f * cos ( lsp [ i ] ) ;\n av_dlog ( NULL , \"floor0 synth: map_size = %\" PRIu32 \";\n m = %d;\n wstep = %f\\n\" , vf -> map_size [ blockflag ] , order , wstep ) ;\n i = 0 ;\n while ( i < vf -> map_size [ blockflag ] ) {\n int j , iter_cond = vf -> map [ blockflag ] [ i ] ;\n float p = 0.5f ;\n float q = 0.5f ;\n float two_cos_w = 2.0f * cos ( wstep * iter_cond ) ;\n for ( j = 0 ;\n j + 1 < order ;\n j += 2 ) {\n q *= lsp [ j ] - two_cos_w ;\n p *= lsp [ j + 1 ] - two_cos_w ;\n }\n if ( j == order ) {\n p *= p * ( 2.0f - two_cos_w ) ;\n q *= q * ( 2.0f + two_cos_w ) ;\n }\n else {\n q *= two_cos_w - lsp [ j ] ;\n p *= p * ( 4.f - two_cos_w * two_cos_w ) ;\n q *= q ;\n }\n q = exp ( ( ( ( amplitude * vf -> amplitude_offset ) / ( ( ( 1 << vf -> amplitude_bits ) - 1 ) * sqrt ( p + q ) ) ) - vf -> amplitude_offset ) * .11512925f ) ;\n do {\n vec [ i ] = q ;\n ++ i ;\n }\n while ( vf -> map [ blockflag ] [ i ] == iter_cond ) ;\n }\n }\n }\n else {\n return 1 ;\n }\n av_dlog ( NULL , \" Floor0 decoded\\n\" ) ;\n return 0 ;\n }", "idx": 342}
{"hash": 1223258652239369123, "project": "debian", "size": 17, "label": 0, "functionSource": "SPL_METHOD ( FilesystemIterator , current ) {\n spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n if ( zend_parse_parameters_none ( ) == FAILURE ) {\n return ;\n }\n if ( SPL_FILE_DIR_CURRENT ( intern , SPL_FILE_DIR_CURRENT_AS_PATHNAME ) ) {\n spl_filesystem_object_get_file_name ( intern TSRMLS_CC ) ;\n RETURN_STRINGL ( intern -> file_name , intern -> file_name_len , 1 ) ;\n }\n else if ( SPL_FILE_DIR_CURRENT ( intern , SPL_FILE_DIR_CURRENT_AS_FILEINFO ) ) {\n spl_filesystem_object_get_file_name ( intern TSRMLS_CC ) ;\n spl_filesystem_object_create_type ( 0 , intern , SPL_FS_INFO , NULL , return_value TSRMLS_CC ) ;\n }\n else {\n RETURN_ZVAL ( getThis ( ) , 1 , 0 ) ;\n }\n }", "idx": 343}
{"hash": -4960438251319819237, "project": "chrome", "size": 26, "label": 1, "functionSource": "static int get_twopass_worst_quality ( const VP9_COMP * cpi , const FIRSTPASS_STATS * stats , int section_target_bandwidth ) {\n const RATE_CONTROL * const rc = & cpi -> rc ;\n const VP9EncoderConfig * const oxcf = & cpi -> oxcf ;\n if ( section_target_bandwidth <= 0 ) {\n return rc -> worst_quality ;\n }\n else {\n const int num_mbs = cpi -> common . MBs ;\n const double section_err = stats -> coded_error / stats -> count ;\n const double err_per_mb = section_err / num_mbs ;\n const double speed_term = 1.0 + 0.04 * oxcf -> speed ;\n const int target_norm_bits_per_mb = ( ( uint64_t ) section_target_bandwidth << BPER_MB_NORMBITS ) / num_mbs ;\n int q ;\n int is_svc_upper_layer = 0 ;\n if ( is_two_pass_svc ( cpi ) && cpi -> svc . spatial_layer_id > 0 ) is_svc_upper_layer = 1 ;\n for ( q = rc -> best_quality ;\n q < rc -> worst_quality ;\n ++ q ) {\n const double factor = calc_correction_factor ( err_per_mb , ERR_DIVISOR , is_svc_upper_layer ? SVC_FACTOR_PT_LOW : FACTOR_PT_LOW , FACTOR_PT_HIGH , q ) ;\n const int bits_per_mb = vp9_rc_bits_per_mb ( INTER_FRAME , q , factor * speed_term ) ;\n if ( bits_per_mb <= target_norm_bits_per_mb ) break ;\n }\n if ( cpi -> oxcf . rc_mode == VPX_CQ ) q = MAX ( q , oxcf -> cq_level ) ;\n return q ;\n }\n }", "idx": 344}
{"hash": -6986708248145981986, "project": "debian", "size": 10, "label": 0, "functionSource": "static kadm5_ret_t validate_allowed_keysalts ( const char * allowed_keysalts ) {\n kadm5_ret_t ret ;\n krb5_key_salt_tuple * ks_tuple = NULL ;\n krb5_int32 n_ks_tuple = 0 ;\n if ( strchr ( allowed_keysalts , '\\t' ) != NULL ) return KADM5_BAD_KEYSALTS ;\n ret = krb5_string_to_keysalts ( allowed_keysalts , \",\" , \":.-\" , 0 , & ks_tuple , & n_ks_tuple ) ;\n free ( ks_tuple ) ;\n if ( ret == EINVAL ) return KADM5_BAD_KEYSALTS ;\n return ret ;\n }", "idx": 345}
{"hash": 8127806390163862344, "project": "debian", "size": 23, "label": 0, "functionSource": "static void vapic_map_rom_writable ( VAPICROMState * s ) {\n hwaddr rom_paddr = s -> rom_state_paddr & ROM_BLOCK_MASK ;\n MemoryRegionSection section ;\n MemoryRegion * as ;\n size_t rom_size ;\n uint8_t * ram ;\n as = sysbus_address_space ( & s -> busdev ) ;\n if ( s -> rom_mapped_writable ) {\n memory_region_del_subregion ( as , & s -> rom ) ;\n memory_region_destroy ( & s -> rom ) ;\n }\n section = memory_region_find ( as , 0 , 1 ) ;\n ram = memory_region_get_ram_ptr ( section . mr ) ;\n rom_size = ram [ rom_paddr + 2 ] * ROM_BLOCK_SIZE ;\n s -> rom_size = rom_size ;\n rom_size += rom_paddr & ~ TARGET_PAGE_MASK ;\n rom_paddr &= TARGET_PAGE_MASK ;\n rom_size = TARGET_PAGE_ALIGN ( rom_size ) ;\n memory_region_init_alias ( & s -> rom , OBJECT ( s ) , \"kvmvapic-rom\" , section . mr , rom_paddr , rom_size ) ;\n memory_region_add_subregion_overlap ( as , rom_paddr , & s -> rom , 1000 ) ;\n s -> rom_mapped_writable = true ;\n memory_region_unref ( section . mr ) ;\n }", "idx": 346}
{"hash": 3557739556029059195, "project": "chrome", "size": 13, "label": 0, "functionSource": "void vp9_sad ## m ## x ## n ## x ## k ## _c ( const uint8_t * src , int src_stride , const uint8_t * ref , int ref_stride , unsigned int * sads ) {\n int i ;\n for ( i = 0 ;\n i < k ;\n ++ i ) sads [ i ] = vp9_sad ## m ## x ## n ## _c ( src , src_stride , & ref [ i ] , ref_stride ) ;\n \\ }\n # define sadMxNx4D ( m , n ) void vp9_sad ## m ## x ## n ## x4d_c ( const uint8_t * src , int src_stride , const uint8_t * const refs [ ] , int ref_stride , unsigned int * sads ) {\n int i ;\n for ( i = 0 ;\n i < 4 ;\n ++ i ) sads [ i ] = vp9_sad ## m ## x ## n ## _c ( src , src_stride , refs [ i ] , ref_stride ) ;\n \\ }\n sadMxN ( 64 , 64 ) sadMxNxK ( 64 , 64 , 3 ) sadMxNxK ( 64 , 64 , 8 ) sadMxNx4D ( 64 , 64 ) sadMxN ( 64 , 32 ) sadMxNx4D ( 64 , 32 ) sadMxN ( 32 , 64 ) sadMxNx4D ( 32 , 64 ) sadMxN ( 32 , 32 ) sadMxNxK ( 32 , 32 , 3 ) sadMxNxK ( 32 , 32 , 8 ) sadMxNx4D ( 32 , 32 ) sadMxN ( 32 , 16 ) sadMxNx4D ( 32 , 16 ) sadMxN ( 16 , 32 ) sadMxNx4D ( 16 , 32 ) sadMxN ( 16 , 16 ) sadMxNxK ( 16 , 16 , 3 ) sadMxNxK ( 16 , 16 , 8 ) sadMxNx4D ( 16 , 16 ) sadMxN ( 16 , 8 ) sadMxNxK ( 16 , 8 , 3 ) sadMxNxK ( 16 , 8 , 8 )", "idx": 347}
{"hash": -4178541639582894026, "project": "debian", "size": 69, "label": 0, "functionSource": "static int zmbv_decode_xor_32 ( ZmbvContext * c ) {\n uint8_t * src = c -> decomp_buf ;\n uint32_t * output , * prev ;\n int8_t * mvec ;\n int x , y ;\n int d , dx , dy , bw2 , bh2 ;\n int block ;\n int i , j ;\n int mx , my ;\n output = ( uint32_t * ) c -> cur ;\n prev = ( uint32_t * ) c -> prev ;\n mvec = ( int8_t * ) src ;\n src += ( ( c -> bx * c -> by * 2 + 3 ) & ~ 3 ) ;\n block = 0 ;\n for ( y = 0 ;\n y < c -> height ;\n y += c -> bh ) {\n bh2 = ( ( c -> height - y ) > c -> bh ) ? c -> bh : ( c -> height - y ) ;\n for ( x = 0 ;\n x < c -> width ;\n x += c -> bw ) {\n uint32_t * out , * tprev ;\n d = mvec [ block ] & 1 ;\n dx = mvec [ block ] >> 1 ;\n dy = mvec [ block + 1 ] >> 1 ;\n block += 2 ;\n bw2 = ( ( c -> width - x ) > c -> bw ) ? c -> bw : ( c -> width - x ) ;\n out = output + x ;\n tprev = prev + x + dx + dy * c -> width ;\n mx = x + dx ;\n my = y + dy ;\n for ( j = 0 ;\n j < bh2 ;\n j ++ ) {\n if ( my + j < 0 || my + j >= c -> height ) {\n memset ( out , 0 , bw2 * 4 ) ;\n }\n else {\n for ( i = 0 ;\n i < bw2 ;\n i ++ ) {\n if ( mx + i < 0 || mx + i >= c -> width ) out [ i ] = 0 ;\n else out [ i ] = tprev [ i ] ;\n }\n }\n out += c -> width ;\n tprev += c -> width ;\n }\n if ( d ) {\n out = output + x ;\n for ( j = 0 ;\n j < bh2 ;\n j ++ ) {\n for ( i = 0 ;\n i < bw2 ;\n i ++ ) {\n out [ i ] ^= * ( ( uint32_t * ) src ) ;\n src += 4 ;\n }\n out += c -> width ;\n }\n }\n }\n output += c -> width * c -> bh ;\n prev += c -> width * c -> bh ;\n }\n if ( src - c -> decomp_buf != c -> decomp_len ) av_log ( c -> avctx , AV_LOG_ERROR , \"Used %ti of %i bytes\\n\" , src - c -> decomp_buf , c -> decomp_len ) ;\n return 0 ;\n }", "idx": 348}
{"hash": -454486177854888036, "project": "debian", "size": 16, "label": 0, "functionSource": "static void rac_normalise ( RangeCoder * c ) {\n for ( ;\n ;\n ) {\n c -> range <<= 8 ;\n c -> low <<= 8 ;\n if ( c -> src < c -> src_end ) {\n c -> low |= * c -> src ++ ;\n }\n else if ( ! c -> low ) {\n c -> got_error = 1 ;\n return ;\n }\n if ( c -> range >= RAC_BOTTOM ) return ;\n }\n }", "idx": 349}
{"hash": -9197960073880365676, "project": "debian", "size": 17, "label": 0, "functionSource": "static uint8_t one_code ( Gif_Context * gfc , Gif_Code code ) {\n uint8_t * suffixes = gfc -> suffix ;\n Gif_Code * prefixes = gfc -> prefix ;\n uint8_t * ptr ;\n int lastsuffix = 0 ;\n int codelength = gfc -> length [ code ] ;\n gfc -> decodepos += codelength ;\n ptr = gfc -> image + gfc -> decodepos ;\n while ( codelength > 0 ) {\n lastsuffix = suffixes [ code ] ;\n code = prefixes [ code ] ;\n -- ptr ;\n if ( ptr < gfc -> maximage ) * ptr = lastsuffix ;\n -- codelength ;\n }\n return lastsuffix ;\n }", "idx": 350}
{"hash": 1223258652239369123, "project": "debian", "size": 10, "label": 0, "functionSource": "SPL_METHOD ( SplFileInfo , setInfoClass ) {\n spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n zend_class_entry * ce = spl_ce_SplFileInfo ;\n zend_error_handling error_handling ;\n zend_replace_error_handling ( EH_THROW , spl_ce_UnexpectedValueException , & error_handling TSRMLS_CC ) ;\n if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , \"|C\" , & ce ) == SUCCESS ) {\n intern -> info_class = ce ;\n }\n zend_restore_error_handling ( & error_handling TSRMLS_CC ) ;\n }", "idx": 351}
{"hash": -3740862514502467070, "project": "debian", "size": 81, "label": 0, "functionSource": "void SFDefaultOS2Info ( struct pfminfo * pfminfo , SplineFont * sf , char * fontname ) {\n int samewid = - 1 ;\n char * weight = sf -> cidmaster == NULL ? sf -> weight : sf -> cidmaster -> weight ;\n if ( sf -> pfminfo . pfmset ) {\n if ( pfminfo != & sf -> pfminfo ) * pfminfo = sf -> pfminfo ;\n if ( ! pfminfo -> panose_set ) {\n struct pfminfo info ;\n memset ( & info , 0 , sizeof ( info ) ) ;\n sf -> pfminfo . pfmset = false ;\n SFDefaultOS2Info ( & info , sf , fontname ) ;\n sf -> pfminfo . pfmset = true ;\n memcpy ( pfminfo -> panose , info . panose , sizeof ( info . panose ) ) ;\n }\n }\n else {\n struct pfminfo hold ;\n if ( pfminfo -> hheadset || pfminfo -> vheadset ) hold = * pfminfo ;\n else hold . hheadset = hold . vheadset = false ;\n memset ( pfminfo , '\\0' , sizeof ( * pfminfo ) ) ;\n SFDefaultOS2Simple ( pfminfo , sf ) ;\n samewid = CIDOneWidth ( sf ) ;\n pfminfo -> pfmfamily = 0x10 ;\n if ( samewid > 0 ) {\n pfminfo -> pfmfamily = 0x30 ;\n }\n else if ( strstrmatch ( fontname , \"sans\" ) != NULL ) pfminfo -> pfmfamily = 0x20 ;\n else if ( strstrmatch ( fontname , \"script\" ) != NULL ) {\n pfminfo -> pfmfamily = 0x40 ;\n pfminfo -> panose [ 0 ] = 3 ;\n }\n if ( samewid == - 1 ) pfminfo -> pfmfamily |= 0x1 ;\n if ( weight != NULL ) OS2WeightCheck ( pfminfo , weight ) ;\n OS2WeightCheck ( pfminfo , fontname ) ;\n if ( strstrmatch ( fontname , \"ultra\" ) != NULL && strstrmatch ( fontname , \"condensed\" ) != NULL ) {\n pfminfo -> width = 1 ;\n pfminfo -> panose [ 3 ] = 8 ;\n }\n else if ( strstrmatch ( fontname , \"extra\" ) != NULL && strstrmatch ( fontname , \"condensed\" ) != NULL ) {\n pfminfo -> width = 2 ;\n pfminfo -> panose [ 3 ] = 8 ;\n }\n else if ( strstrmatch ( fontname , \"semi\" ) != NULL && strstrmatch ( fontname , \"condensed\" ) != NULL ) {\n pfminfo -> width = 4 ;\n pfminfo -> panose [ 3 ] = 6 ;\n }\n else if ( strstrmatch ( fontname , \"condensed\" ) != NULL || strstrmatch ( fontname , \"narrow\" ) != NULL ) {\n pfminfo -> width = 3 ;\n pfminfo -> panose [ 3 ] = 6 ;\n }\n else if ( strstrmatch ( fontname , \"ultra\" ) != NULL && strstrmatch ( fontname , \"expanded\" ) != NULL ) {\n pfminfo -> width = 9 ;\n pfminfo -> panose [ 3 ] = 7 ;\n }\n else if ( strstrmatch ( fontname , \"extra\" ) != NULL && strstrmatch ( fontname , \"expanded\" ) != NULL ) {\n pfminfo -> width = 8 ;\n pfminfo -> panose [ 3 ] = 7 ;\n }\n else if ( strstrmatch ( fontname , \"semi\" ) != NULL && strstrmatch ( fontname , \"expanded\" ) != NULL ) {\n pfminfo -> width = 6 ;\n pfminfo -> panose [ 3 ] = 5 ;\n }\n else if ( strstrmatch ( fontname , \"expanded\" ) != NULL ) {\n pfminfo -> width = 7 ;\n pfminfo -> panose [ 3 ] = 5 ;\n }\n if ( samewid > 0 ) pfminfo -> panose [ 3 ] = 9 ;\n if ( hold . hheadset ) {\n pfminfo -> hheadset = true ;\n pfminfo -> hheadascent_add = hold . hheadascent_add ;\n pfminfo -> hheaddescent_add = hold . hheaddescent_add ;\n pfminfo -> hhead_ascent = hold . hhead_ascent ;\n pfminfo -> hhead_descent = hold . hhead_descent ;\n pfminfo -> linegap = hold . linegap ;\n }\n if ( hold . vheadset ) {\n pfminfo -> vheadset = true ;\n pfminfo -> vlinegap = hold . vlinegap ;\n }\n }\n if ( ! pfminfo -> subsuper_set ) SFDefaultOS2SubSuper ( pfminfo , sf -> ascent + sf -> descent , sf -> italicangle ) ;\n }", "idx": 352}
{"hash": -3889154245145551951, "project": "debian", "size": 5, "label": 0, "functionSource": "static void release_tree_entry ( struct tree_entry * e ) {\n if ( e -> tree ) release_tree_content_recursive ( e -> tree ) ;\n * ( ( void * * ) e ) = avail_tree_entry ;\n avail_tree_entry = e ;\n }", "idx": 353}
{"hash": -5268859819325807498, "project": "debian", "size": 19, "label": 0, "functionSource": "static gboolean is_link_trusted ( NautilusFile * file , gboolean is_launcher ) {\n GFile * location ;\n gboolean res ;\n g_autofree gchar * trusted = NULL ;\n if ( ! is_launcher ) {\n return TRUE ;\n }\n trusted = nautilus_file_get_metadata ( file , NAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED , NULL ) ;\n if ( nautilus_file_can_execute ( file ) && trusted != NULL ) {\n return TRUE ;\n }\n res = FALSE ;\n if ( nautilus_file_is_local ( file ) ) {\n location = nautilus_file_get_location ( file ) ;\n res = nautilus_is_in_system_dir ( location ) ;\n g_object_unref ( location ) ;\n }\n return res ;\n }", "idx": 354}
{"hash": 3728341105073176576, "project": "debian", "size": 38, "label": 1, "functionSource": "static ossl_inline type * lh_ ## type ## _insert ( LHASH_OF ( type ) * lh , type * d ) {\n return ( type * ) OPENSSL_LH_insert ( ( OPENSSL_LHASH * ) lh , d ) ;\n }\n static ossl_inline type * lh_ ## type ## _delete ( LHASH_OF ( type ) * lh , const type * d ) {\n return ( type * ) OPENSSL_LH_delete ( ( OPENSSL_LHASH * ) lh , d ) ;\n }\n static ossl_inline type * lh_ ## type ## _retrieve ( LHASH_OF ( type ) * lh , const type * d ) {\n return ( type * ) OPENSSL_LH_retrieve ( ( OPENSSL_LHASH * ) lh , d ) ;\n }\n static ossl_inline int lh_ ## type ## _error ( LHASH_OF ( type ) * lh ) {\n return OPENSSL_LH_error ( ( OPENSSL_LHASH * ) lh ) ;\n }\n static ossl_inline unsigned long lh_ ## type ## _num_items ( LHASH_OF ( type ) * lh ) {\n return OPENSSL_LH_num_items ( ( OPENSSL_LHASH * ) lh ) ;\n }\n static ossl_inline void lh_ ## type ## _node_stats_bio ( const LHASH_OF ( type ) * lh , BIO * out ) {\n OPENSSL_LH_node_stats_bio ( ( const OPENSSL_LHASH * ) lh , out ) ;\n }\n static ossl_inline void lh_ ## type ## _node_usage_stats_bio ( const LHASH_OF ( type ) * lh , BIO * out ) {\n OPENSSL_LH_node_usage_stats_bio ( ( const OPENSSL_LHASH * ) lh , out ) ;\n }\n static ossl_inline void lh_ ## type ## _stats_bio ( const LHASH_OF ( type ) * lh , BIO * out ) {\n OPENSSL_LH_stats_bio ( ( const OPENSSL_LHASH * ) lh , out ) ;\n }\n static ossl_inline unsigned long lh_ ## type ## _get_down_load ( LHASH_OF ( type ) * lh ) {\n return OPENSSL_LH_get_down_load ( ( OPENSSL_LHASH * ) lh ) ;\n }\n static ossl_inline void lh_ ## type ## _set_down_load ( LHASH_OF ( type ) * lh , unsigned long dl ) {\n OPENSSL_LH_set_down_load ( ( OPENSSL_LHASH * ) lh , dl ) ;\n }\n static ossl_inline void lh_ ## type ## _doall ( LHASH_OF ( type ) * lh , void ( * doall ) ( type * ) ) {\n OPENSSL_LH_doall ( ( OPENSSL_LHASH * ) lh , ( OPENSSL_LH_DOALL_FUNC ) doall ) ;\n }\n LHASH_OF ( type ) # define IMPLEMENT_LHASH_DOALL_ARG_CONST ( type , argtype ) int_implement_lhash_doall ( type , argtype , const type ) # define IMPLEMENT_LHASH_DOALL_ARG ( type , argtype ) int_implement_lhash_doall ( type , argtype , type ) # define int_implement_lhash_doall ( type , argtype , cbargtype ) static ossl_inline void lh_ ## type ## _doall_ ## argtype ( LHASH_OF ( type ) * lh , void ( * fn ) ( cbargtype * , argtype * ) , argtype * arg ) {\n OPENSSL_LH_doall_arg ( ( OPENSSL_LHASH * ) lh , ( OPENSSL_LH_DOALL_FUNCARG ) fn , ( void * ) arg ) ;\n }\n LHASH_OF ( type ) DEFINE_LHASH_OF ( OPENSSL_STRING ) ;\n # ifdef _MSC_VER # pragma warning ( push ) # pragma warning ( disable : 4090 ) # endif DEFINE_LHASH_OF ( OPENSSL_CSTRING )", "idx": 355}
{"hash": -3819889754140204145, "project": "debian", "size": 29, "label": 0, "functionSource": "static bool check_address_object ( ts_type_t ts_type , chunk_t object ) {\n switch ( ts_type ) {\n case TS_IPV4_ADDR_RANGE : if ( object . len > 5 ) {\n DBG1 ( DBG_ASN , \"IPv4 address object is larger than 5 octets\" ) ;\n return FALSE ;\n }\n break ;\n case TS_IPV6_ADDR_RANGE : if ( object . len > 17 ) {\n DBG1 ( DBG_ASN , \"IPv6 address object is larger than 17 octets\" ) ;\n return FALSE ;\n }\n break ;\n default : DBG1 ( DBG_ASN , \"unknown address family\" ) ;\n return FALSE ;\n }\n if ( object . len == 0 ) {\n DBG1 ( DBG_ASN , \"An ASN.1 bit string must contain at least the \" \"initial octet\" ) ;\n return FALSE ;\n }\n if ( object . len == 1 && object . ptr [ 0 ] != 0 ) {\n DBG1 ( DBG_ASN , \"An empty ASN.1 bit string must contain a zero \" \"initial octet\" ) ;\n return FALSE ;\n }\n if ( object . ptr [ 0 ] > 7 ) {\n DBG1 ( DBG_ASN , \"number of unused bits is too large\" ) ;\n return FALSE ;\n }\n return TRUE ;\n }", "idx": 356}
{"hash": 9155638497612715289, "project": "debian", "size": 84, "label": 0, "functionSource": "static void cchip_write ( void * opaque , hwaddr addr , uint64_t v32 , unsigned size ) {\n TyphoonState * s = opaque ;\n uint64_t val , oldval , newval ;\n if ( addr & 4 ) {\n val = v32 << 32 | s -> latch_tmp ;\n addr ^= 4 ;\n }\n else {\n s -> latch_tmp = v32 ;\n return ;\n }\n switch ( addr ) {\n case 0x0000 : break ;\n case 0x0040 : break ;\n case 0x0080 : newval = oldval = s -> cchip . misc ;\n newval &= ~ ( val & 0x10000ff0 ) ;\n if ( val & 0x100000 ) {\n newval &= ~ 0xff0000ull ;\n }\n else {\n newval |= val & 0x00f00000 ;\n if ( ( newval & 0xf0000 ) == 0 ) {\n newval |= val & 0xf0000 ;\n }\n }\n newval |= ( val & 0xf000 ) >> 4 ;\n newval &= ~ 0xf0000000000ull ;\n newval |= val & 0xf0000000000ull ;\n s -> cchip . misc = newval ;\n if ( ( newval ^ oldval ) & 0xff0 ) {\n int i ;\n for ( i = 0 ;\n i < 4 ;\n ++ i ) {\n AlphaCPU * cpu = s -> cchip . cpu [ i ] ;\n if ( cpu != NULL ) {\n CPUState * cs = CPU ( cpu ) ;\n if ( newval & ( 1 << ( i + 8 ) ) ) {\n cpu_interrupt ( cs , CPU_INTERRUPT_SMP ) ;\n }\n else {\n cpu_reset_interrupt ( cs , CPU_INTERRUPT_SMP ) ;\n }\n if ( ( newval & ( 1 << ( i + 4 ) ) ) == 0 ) {\n cpu_reset_interrupt ( cs , CPU_INTERRUPT_TIMER ) ;\n }\n }\n }\n }\n break ;\n case 0x00c0 : break ;\n case 0x0100 : case 0x0140 : case 0x0180 : case 0x01c0 : break ;\n case 0x0200 : s -> cchip . dim [ 0 ] = val ;\n cpu_irq_change ( s -> cchip . cpu [ 0 ] , val & s -> cchip . drir ) ;\n break ;\n case 0x0240 : s -> cchip . dim [ 0 ] = val ;\n cpu_irq_change ( s -> cchip . cpu [ 1 ] , val & s -> cchip . drir ) ;\n break ;\n case 0x0280 : case 0x02c0 : case 0x0300 : break ;\n case 0x0340 : break ;\n case 0x0380 : s -> cchip . iic [ 0 ] = val & 0xffffff ;\n break ;\n case 0x03c0 : s -> cchip . iic [ 1 ] = val & 0xffffff ;\n break ;\n case 0x0400 : case 0x0440 : case 0x0480 : case 0x04c0 : break ;\n case 0x0580 : break ;\n case 0x05c0 : break ;\n case 0x0600 : s -> cchip . dim [ 2 ] = val ;\n cpu_irq_change ( s -> cchip . cpu [ 2 ] , val & s -> cchip . drir ) ;\n break ;\n case 0x0640 : s -> cchip . dim [ 3 ] = val ;\n cpu_irq_change ( s -> cchip . cpu [ 3 ] , val & s -> cchip . drir ) ;\n break ;\n case 0x0680 : case 0x06c0 : break ;\n case 0x0700 : s -> cchip . iic [ 2 ] = val & 0xffffff ;\n break ;\n case 0x0740 : s -> cchip . iic [ 3 ] = val & 0xffffff ;\n break ;\n case 0x0780 : break ;\n case 0x0c00 : case 0x0c40 : case 0x0c80 : case 0x0cc0 : break ;\n default : cpu_unassigned_access ( current_cpu , addr , true , false , 0 , size ) ;\n return ;\n }\n }", "idx": 357}
{"hash": -1102844685921778700, "project": "debian", "size": 6, "label": 0, "functionSource": "static int utf8_to_unicode ( uint32_t * pwc , const char * s , size_t n ) {\n int cnt ;\n cnt = _utf8_to_unicode ( pwc , s , n ) ;\n if ( cnt == 3 && IS_SURROGATE_PAIR_LA ( * pwc ) ) return ( - 3 ) ;\n return ( cnt ) ;\n }", "idx": 358}
{"hash": 2895622461494525400, "project": "debian", "size": 61, "label": 0, "functionSource": "static void test_create_drop ( ) {\n MYSQL_STMT * stmt_create , * stmt_drop , * stmt_select , * stmt_create_select ;\n char * query ;\n int rc , i ;\n myheader ( \"test_table_manipulation\" ) ;\n rc = mysql_query ( mysql , \"DROP TABLE IF EXISTS t1, t2\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"create table t2 (a int);\n\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"create table t1 (a int);\n\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"insert into t2 values (3), (2), (1);\n\" ) ;\n myquery ( rc ) ;\n query = ( char * ) \"create table t1 (a int)\" ;\n stmt_create = mysql_simple_prepare ( mysql , query ) ;\n check_stmt ( stmt_create ) ;\n query = ( char * ) \"drop table t1\" ;\n stmt_drop = mysql_simple_prepare ( mysql , query ) ;\n check_stmt ( stmt_drop ) ;\n query = ( char * ) \"select a in (select a from t2) from t1\" ;\n stmt_select = mysql_simple_prepare ( mysql , query ) ;\n check_stmt ( stmt_select ) ;\n rc = mysql_query ( mysql , \"DROP TABLE t1\" ) ;\n myquery ( rc ) ;\n query = ( char * ) \"create table t1 select a from t2\" ;\n stmt_create_select = mysql_simple_prepare ( mysql , query ) ;\n check_stmt ( stmt_create_select ) ;\n for ( i = 0 ;\n i < 3 ;\n i ++ ) {\n rc = mysql_stmt_execute ( stmt_create ) ;\n check_execute ( stmt_create , rc ) ;\n if ( ! opt_silent ) fprintf ( stdout , \"created %i\\n\" , i ) ;\n rc = mysql_stmt_execute ( stmt_select ) ;\n check_execute ( stmt_select , rc ) ;\n rc = my_process_stmt_result ( stmt_select ) ;\n DIE_UNLESS ( rc == 0 ) ;\n rc = mysql_stmt_execute ( stmt_drop ) ;\n check_execute ( stmt_drop , rc ) ;\n if ( ! opt_silent ) fprintf ( stdout , \"dropped %i\\n\" , i ) ;\n rc = mysql_stmt_execute ( stmt_create_select ) ;\n check_execute ( stmt_create , rc ) ;\n if ( ! opt_silent ) fprintf ( stdout , \"created select %i\\n\" , i ) ;\n rc = mysql_stmt_execute ( stmt_select ) ;\n check_execute ( stmt_select , rc ) ;\n rc = my_process_stmt_result ( stmt_select ) ;\n DIE_UNLESS ( rc == 3 ) ;\n rc = mysql_stmt_execute ( stmt_drop ) ;\n check_execute ( stmt_drop , rc ) ;\n if ( ! opt_silent ) fprintf ( stdout , \"dropped %i\\n\" , i ) ;\n }\n mysql_stmt_close ( stmt_create ) ;\n mysql_stmt_close ( stmt_drop ) ;\n mysql_stmt_close ( stmt_select ) ;\n mysql_stmt_close ( stmt_create_select ) ;\n rc = mysql_query ( mysql , \"DROP TABLE t2\" ) ;\n myquery ( rc ) ;\n }", "idx": 359}
{"hash": -2607754285145856562, "project": "debian", "size": 14, "label": 0, "functionSource": "static void isoent_remove_child ( struct isoent * parent , struct isoent * child ) {\n struct isoent * ent ;\n ent = parent -> children . first ;\n while ( ent -> chnext != child ) ent = ent -> chnext ;\n if ( ( ent -> chnext = ent -> chnext -> chnext ) == NULL ) parent -> children . last = & ( ent -> chnext ) ;\n parent -> children . cnt -- ;\n if ( child -> dir ) {\n ent = parent -> subdirs . first ;\n while ( ent -> drnext != child ) ent = ent -> drnext ;\n if ( ( ent -> drnext = ent -> drnext -> drnext ) == NULL ) parent -> subdirs . last = & ( ent -> drnext ) ;\n parent -> subdirs . cnt -- ;\n }\n __archive_rb_tree_remove_node ( & ( parent -> rbtree ) , ( struct archive_rb_node * ) child ) ;\n }", "idx": 360}
{"hash": -7117046864335130087, "project": "chrome", "size": 4, "label": 1, "functionSource": "static int estimate_bits_at_q ( FRAME_TYPE frame_type , int q , int mbs , double correction_factor ) {\n const int bpm = ( int ) ( vp9_rc_bits_per_mb ( frame_type , q , correction_factor ) ) ;\n return ( ( uint64_t ) bpm * mbs ) >> BPER_MB_NORMBITS ;\n }", "idx": 361}
{"hash": 5400542917484463750, "project": "chrome", "size": 29, "label": 0, "functionSource": "static vpx_codec_err_t parse_layer_options_from_string ( SvcContext * svc_ctx , LAYER_OPTION_TYPE type , const char * input , int * option0 , int * option1 ) {\n int i ;\n vpx_codec_err_t res = VPX_CODEC_OK ;\n char * input_string ;\n char * token ;\n const char * delim = \",\" ;\n char * save_ptr ;\n if ( input == NULL || option0 == NULL || ( option1 == NULL && type == SCALE_FACTOR ) ) return VPX_CODEC_INVALID_PARAM ;\n input_string = strdup ( input ) ;\n token = strtok_r ( input_string , delim , & save_ptr ) ;\n for ( i = 0 ;\n i < svc_ctx -> spatial_layers ;\n ++ i ) {\n if ( token != NULL ) {\n res = extract_option ( type , token , option0 + i , option1 + i ) ;\n if ( res != VPX_CODEC_OK ) break ;\n token = strtok_r ( NULL , delim , & save_ptr ) ;\n }\n else {\n break ;\n }\n }\n if ( res == VPX_CODEC_OK && i != svc_ctx -> spatial_layers ) {\n svc_log ( svc_ctx , SVC_LOG_ERROR , \"svc: layer params type: %d %d values required, \" \"but only %d specified\\n\" , type , svc_ctx -> spatial_layers , i ) ;\n res = VPX_CODEC_INVALID_PARAM ;\n }\n free ( input_string ) ;\n return res ;\n }", "idx": 362}
{"hash": -5268859819325807498, "project": "debian", "size": 22, "label": 0, "functionSource": "FileMonitors * nautilus_directory_remove_file_monitors ( NautilusDirectory * directory , NautilusFile * file ) {\n GList * result , * * list , * node , * next ;\n Monitor * monitor ;\n g_assert ( NAUTILUS_IS_DIRECTORY ( directory ) ) ;\n g_assert ( NAUTILUS_IS_FILE ( file ) ) ;\n g_assert ( file -> details -> directory == directory ) ;\n result = NULL ;\n list = & directory -> details -> monitor_list ;\n for ( node = directory -> details -> monitor_list ;\n node != NULL ;\n node = next ) {\n next = node -> next ;\n monitor = node -> data ;\n if ( monitor -> file == file ) {\n * list = g_list_remove_link ( * list , node ) ;\n result = g_list_concat ( node , result ) ;\n request_counter_remove_request ( directory -> details -> monitor_counters , monitor -> request ) ;\n }\n }\n nautilus_directory_async_state_changed ( directory ) ;\n return ( FileMonitors * ) result ;\n }", "idx": 363}
{"hash": 3731043152202786975, "project": "debian", "size": 25, "label": 0, "functionSource": "char get_header_code ( struct hdr_field * hf ) {\n switch ( hf -> type ) {\n case HDR_CALLID_T : return 'i' ;\n case HDR_CONTACT_T : return 'm' ;\n case HDR_CONTENTLENGTH_T : return 'l' ;\n case HDR_CONTENTTYPE_T : return 'c' ;\n case HDR_FROM_T : return 'f' ;\n case HDR_SUBJECT_T : return 's' ;\n case HDR_SUPPORTED_T : return 'k' ;\n case HDR_TO_T : return 't' ;\n case HDR_VIA_T : return 'v' ;\n case HDR_ROUTE_T : return 'r' ;\n case HDR_RECORDROUTE_T : return 'R' ;\n case HDR_ALLOW_T : return 'a' ;\n case HDR_ACCEPT_T : return 'A' ;\n case HDR_CSEQ_T : return 'S' ;\n case HDR_REFER_TO_T : return 'o' ;\n case HDR_RPID_T : return 'p' ;\n case HDR_EXPIRES_T : return 'P' ;\n case HDR_AUTHORIZATION_T : return 'H' ;\n case HDR_PROXYAUTH_T : return 'z' ;\n default : return 'x' ;\n }\n return 'x' ;\n }", "idx": 364}
{"hash": -8884965407551053630, "project": "debian", "size": 11, "label": 0, "functionSource": "void input_DecoderDecode ( decoder_t * p_dec , block_t * p_block , bool b_do_pace ) {\n decoder_owner_sys_t * p_owner = p_dec -> p_owner ;\n if ( b_do_pace ) {\n if ( ! p_owner -> b_waiting ) block_FifoPace ( p_owner -> p_fifo , 10 , SIZE_MAX ) ;\n }\n # ifdef __arm__ else if ( block_FifoSize ( p_owner -> p_fifo ) > 50 * 1024 * 1024 ) # else else if ( block_FifoSize ( p_owner -> p_fifo ) > 400 * 1024 * 1024 ) # endif {\n msg_Warn ( p_dec , \"decoder/packetizer fifo full (data not \" \"consumed quickly enough), resetting fifo!\" ) ;\n block_FifoEmpty ( p_owner -> p_fifo ) ;\n }\n block_FifoPut ( p_owner -> p_fifo , p_block ) ;\n }", "idx": 365}
{"hash": -2723830976796502611, "project": "chrome", "size": 5, "label": 0, "functionSource": "static vpx_codec_err_t ctrl_set_arnr_type ( vpx_codec_alg_priv_t * ctx , va_list args ) {\n ( void ) ctx ;\n ( void ) args ;\n return VPX_CODEC_OK ;\n }", "idx": 366}
{"hash": -1919011628477388936, "project": "debian", "size": 19, "label": 0, "functionSource": "static uint64_t openpic_src_read ( void * opaque , uint64_t addr , unsigned len ) {\n OpenPICState * opp = opaque ;\n uint32_t retval ;\n int idx ;\n DPRINTF ( \"%s: addr %#\" HWADDR_PRIx \"\\n\" , __func__ , addr ) ;\n retval = 0xFFFFFFFF ;\n addr = addr & 0xffff ;\n idx = addr >> 5 ;\n switch ( addr & 0x1f ) {\n case 0x00 : retval = read_IRQreg_ivpr ( opp , idx ) ;\n break ;\n case 0x10 : retval = read_IRQreg_idr ( opp , idx ) ;\n break ;\n case 0x18 : retval = read_IRQreg_ilr ( opp , idx ) ;\n break ;\n }\n DPRINTF ( \"%s: => 0x%08x\\n\" , __func__ , retval ) ;\n return retval ;\n }", "idx": 367}
{"hash": 2713698759296604855, "project": "debian", "size": 42, "label": 0, "functionSource": "void ff_init_vlc_rl ( RLTable * rl ) {\n int i , q ;\n for ( q = 0 ;\n q < 32 ;\n q ++ ) {\n int qmul = q * 2 ;\n int qadd = ( q - 1 ) | 1 ;\n if ( q == 0 ) {\n qmul = 1 ;\n qadd = 0 ;\n }\n for ( i = 0 ;\n i < rl -> vlc . table_size ;\n i ++ ) {\n int code = rl -> vlc . table [ i ] [ 0 ] ;\n int len = rl -> vlc . table [ i ] [ 1 ] ;\n int level , run ;\n if ( len == 0 ) {\n run = 66 ;\n level = MAX_LEVEL ;\n }\n else if ( len < 0 ) {\n run = 0 ;\n level = code ;\n }\n else {\n if ( code == rl -> n ) {\n run = 66 ;\n level = 0 ;\n }\n else {\n run = rl -> table_run [ code ] + 1 ;\n level = rl -> table_level [ code ] * qmul + qadd ;\n if ( code >= rl -> last ) run += 192 ;\n }\n }\n rl -> rl_vlc [ q ] [ i ] . len = len ;\n rl -> rl_vlc [ q ] [ i ] . level = level ;\n rl -> rl_vlc [ q ] [ i ] . run = run ;\n }\n }\n }", "idx": 368}
{"hash": -8437173884317959107, "project": "debian", "size": 141, "label": 0, "functionSource": "static int vorbis_parse_audio_packet ( vorbis_context * vc , float * * floor_ptr ) {\n GetBitContext * gb = & vc -> gb ;\n FFTContext * mdct ;\n unsigned previous_window = vc -> previous_window ;\n unsigned mode_number , blockflag , blocksize ;\n int i , j ;\n uint8_t no_residue [ 255 ] ;\n uint8_t do_not_decode [ 255 ] ;\n vorbis_mapping * mapping ;\n float * ch_res_ptr = vc -> channel_residues ;\n uint8_t res_chan [ 255 ] ;\n unsigned res_num = 0 ;\n int retlen = 0 ;\n unsigned ch_left = vc -> audio_channels ;\n unsigned vlen ;\n if ( get_bits1 ( gb ) ) {\n av_log ( vc -> avctx , AV_LOG_ERROR , \"Not a Vorbis I audio packet.\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( vc -> mode_count == 1 ) {\n mode_number = 0 ;\n }\n else {\n GET_VALIDATED_INDEX ( mode_number , ilog ( vc -> mode_count - 1 ) , vc -> mode_count ) }\n vc -> mode_number = mode_number ;\n mapping = & vc -> mappings [ vc -> modes [ mode_number ] . mapping ] ;\n av_dlog ( NULL , \" Mode number: %u , mapping: %d , blocktype %d\\n\" , mode_number , vc -> modes [ mode_number ] . mapping , vc -> modes [ mode_number ] . blockflag ) ;\n blockflag = vc -> modes [ mode_number ] . blockflag ;\n blocksize = vc -> blocksize [ blockflag ] ;\n vlen = blocksize / 2 ;\n if ( blockflag ) {\n previous_window = get_bits ( gb , 1 ) ;\n skip_bits1 ( gb ) ;\n }\n memset ( ch_res_ptr , 0 , sizeof ( float ) * vc -> audio_channels * vlen ) ;\n for ( i = 0 ;\n i < vc -> audio_channels ;\n ++ i ) memset ( floor_ptr [ i ] , 0 , vlen * sizeof ( floor_ptr [ 0 ] [ 0 ] ) ) ;\n for ( i = 0 ;\n i < vc -> audio_channels ;\n ++ i ) {\n vorbis_floor * floor ;\n int ret ;\n if ( mapping -> submaps > 1 ) {\n floor = & vc -> floors [ mapping -> submap_floor [ mapping -> mux [ i ] ] ] ;\n }\n else {\n floor = & vc -> floors [ mapping -> submap_floor [ 0 ] ] ;\n }\n ret = floor -> decode ( vc , & floor -> data , floor_ptr [ i ] ) ;\n if ( ret < 0 ) {\n av_log ( vc -> avctx , AV_LOG_ERROR , \"Invalid codebook in vorbis_floor_decode.\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n no_residue [ i ] = ret ;\n }\n for ( i = mapping -> coupling_steps - 1 ;\n i >= 0 ;\n -- i ) {\n if ( ! ( no_residue [ mapping -> magnitude [ i ] ] & no_residue [ mapping -> angle [ i ] ] ) ) {\n no_residue [ mapping -> magnitude [ i ] ] = 0 ;\n no_residue [ mapping -> angle [ i ] ] = 0 ;\n }\n }\n for ( i = 0 ;\n i < mapping -> submaps ;\n ++ i ) {\n vorbis_residue * residue ;\n unsigned ch = 0 ;\n int ret ;\n for ( j = 0 ;\n j < vc -> audio_channels ;\n ++ j ) {\n if ( ( mapping -> submaps == 1 ) || ( i == mapping -> mux [ j ] ) ) {\n res_chan [ j ] = res_num ;\n if ( no_residue [ j ] ) {\n do_not_decode [ ch ] = 1 ;\n }\n else {\n do_not_decode [ ch ] = 0 ;\n }\n ++ ch ;\n ++ res_num ;\n }\n }\n residue = & vc -> residues [ mapping -> submap_residue [ i ] ] ;\n if ( ch_left < ch ) {\n av_log ( vc -> avctx , AV_LOG_ERROR , \"Too many channels in vorbis_floor_decode.\\n\" ) ;\n return - 1 ;\n }\n if ( ch ) {\n ret = vorbis_residue_decode ( vc , residue , ch , do_not_decode , ch_res_ptr , vlen , ch_left ) ;\n if ( ret < 0 ) return ret ;\n }\n ch_res_ptr += ch * vlen ;\n ch_left -= ch ;\n }\n if ( ch_left > 0 ) return AVERROR_INVALIDDATA ;\n for ( i = mapping -> coupling_steps - 1 ;\n i >= 0 ;\n -- i ) {\n float * mag , * ang ;\n mag = vc -> channel_residues + res_chan [ mapping -> magnitude [ i ] ] * blocksize / 2 ;\n ang = vc -> channel_residues + res_chan [ mapping -> angle [ i ] ] * blocksize / 2 ;\n vc -> dsp . vorbis_inverse_coupling ( mag , ang , blocksize / 2 ) ;\n }\n mdct = & vc -> mdct [ blockflag ] ;\n for ( j = vc -> audio_channels - 1 ;\n j >= 0 ;\n j -- ) {\n ch_res_ptr = vc -> channel_residues + res_chan [ j ] * blocksize / 2 ;\n vc -> fdsp . vector_fmul ( floor_ptr [ j ] , floor_ptr [ j ] , ch_res_ptr , blocksize / 2 ) ;\n mdct -> imdct_half ( mdct , ch_res_ptr , floor_ptr [ j ] ) ;\n }\n retlen = ( blocksize + vc -> blocksize [ previous_window ] ) / 4 ;\n for ( j = 0 ;\n j < vc -> audio_channels ;\n j ++ ) {\n unsigned bs0 = vc -> blocksize [ 0 ] ;\n unsigned bs1 = vc -> blocksize [ 1 ] ;\n float * residue = vc -> channel_residues + res_chan [ j ] * blocksize / 2 ;\n float * saved = vc -> saved + j * bs1 / 4 ;\n float * ret = floor_ptr [ j ] ;\n float * buf = residue ;\n const float * win = vc -> win [ blockflag & previous_window ] ;\n if ( blockflag == previous_window ) {\n vc -> fdsp . vector_fmul_window ( ret , saved , buf , win , blocksize / 4 ) ;\n }\n else if ( blockflag > previous_window ) {\n vc -> fdsp . vector_fmul_window ( ret , saved , buf , win , bs0 / 4 ) ;\n memcpy ( ret + bs0 / 2 , buf + bs0 / 4 , ( ( bs1 - bs0 ) / 4 ) * sizeof ( float ) ) ;\n }\n else {\n memcpy ( ret , saved , ( ( bs1 - bs0 ) / 4 ) * sizeof ( float ) ) ;\n vc -> fdsp . vector_fmul_window ( ret + ( bs1 - bs0 ) / 4 , saved + ( bs1 - bs0 ) / 4 , buf , win , bs0 / 4 ) ;\n }\n memcpy ( saved , buf + blocksize / 4 , blocksize / 4 * sizeof ( float ) ) ;\n }\n vc -> previous_window = blockflag ;\n return retlen ;\n }", "idx": 369}
{"hash": -8029592471297395650, "project": "debian", "size": 88, "label": 0, "functionSource": "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n AVFrame * frame = data ;\n const uint8_t * buf = avpkt -> data ;\n const uint8_t * buf_end = buf + avpkt -> size ;\n KgvContext * const c = avctx -> priv_data ;\n int offsets [ 8 ] ;\n uint16_t * out , * prev ;\n int outcnt = 0 , maxcnt ;\n int w , h , i , res ;\n if ( avpkt -> size < 2 ) return AVERROR_INVALIDDATA ;\n w = ( buf [ 0 ] + 1 ) * 8 ;\n h = ( buf [ 1 ] + 1 ) * 8 ;\n buf += 2 ;\n if ( ( res = av_image_check_size ( w , h , 0 , avctx ) ) < 0 ) return res ;\n if ( w != avctx -> width || h != avctx -> height ) {\n av_frame_unref ( & c -> prev ) ;\n avcodec_set_dimensions ( avctx , w , h ) ;\n }\n maxcnt = w * h ;\n if ( ( res = ff_get_buffer ( avctx , frame , AV_GET_BUFFER_FLAG_REF ) ) < 0 ) return res ;\n out = ( uint16_t * ) frame -> data [ 0 ] ;\n if ( c -> prev . data [ 0 ] ) {\n prev = ( uint16_t * ) c -> prev . data [ 0 ] ;\n }\n else {\n prev = NULL ;\n }\n for ( i = 0 ;\n i < 8 ;\n i ++ ) offsets [ i ] = - 1 ;\n while ( outcnt < maxcnt && buf_end - 2 > buf ) {\n int code = AV_RL16 ( buf ) ;\n buf += 2 ;\n if ( ! ( code & 0x8000 ) ) {\n out [ outcnt ++ ] = code ;\n }\n else {\n int count ;\n int inp_off ;\n uint16_t * inp ;\n if ( ( code & 0x6000 ) == 0x6000 ) {\n int oidx = ( code >> 10 ) & 7 ;\n int start ;\n count = ( code & 0x3FF ) + 3 ;\n if ( offsets [ oidx ] < 0 ) {\n if ( buf_end - 3 < buf ) break ;\n offsets [ oidx ] = AV_RL24 ( buf ) ;\n buf += 3 ;\n }\n start = ( outcnt + offsets [ oidx ] ) % maxcnt ;\n if ( maxcnt - start < count ) break ;\n if ( ! prev ) {\n av_log ( avctx , AV_LOG_ERROR , \"Frame reference does not exist\\n\" ) ;\n break ;\n }\n inp = prev ;\n inp_off = start ;\n }\n else {\n int offset = ( code & 0x1FFF ) + 1 ;\n if ( ! ( code & 0x6000 ) ) {\n count = 2 ;\n }\n else if ( ( code & 0x6000 ) == 0x2000 ) {\n count = 3 ;\n }\n else {\n if ( buf_end - 1 < buf ) break ;\n count = 4 + * buf ++ ;\n }\n if ( outcnt < offset ) break ;\n inp = out ;\n inp_off = outcnt - offset ;\n }\n if ( maxcnt - outcnt < count ) break ;\n for ( i = inp_off ;\n i < count + inp_off ;\n i ++ ) {\n out [ outcnt ++ ] = inp [ i ] ;\n }\n }\n }\n if ( outcnt - maxcnt ) av_log ( avctx , AV_LOG_DEBUG , \"frame finished with %d diff\\n\" , outcnt - maxcnt ) ;\n av_frame_unref ( & c -> prev ) ;\n if ( ( res = av_frame_ref ( & c -> prev , frame ) ) < 0 ) return res ;\n * got_frame = 1 ;\n return avpkt -> size ;\n }", "idx": 370}
{"hash": 9160937366035817353, "project": "chrome", "size": 14, "label": 0, "functionSource": "void vp9_set_mv_search_range ( MACROBLOCK * x , const MV * mv ) {\n int col_min = ( mv -> col >> 3 ) - MAX_FULL_PEL_VAL + ( mv -> col & 7 ? 1 : 0 ) ;\n int row_min = ( mv -> row >> 3 ) - MAX_FULL_PEL_VAL + ( mv -> row & 7 ? 1 : 0 ) ;\n int col_max = ( mv -> col >> 3 ) + MAX_FULL_PEL_VAL ;\n int row_max = ( mv -> row >> 3 ) + MAX_FULL_PEL_VAL ;\n col_min = MAX ( col_min , ( MV_LOW >> 3 ) + 1 ) ;\n row_min = MAX ( row_min , ( MV_LOW >> 3 ) + 1 ) ;\n col_max = MIN ( col_max , ( MV_UPP >> 3 ) - 1 ) ;\n row_max = MIN ( row_max , ( MV_UPP >> 3 ) - 1 ) ;\n if ( x -> mv_col_min < col_min ) x -> mv_col_min = col_min ;\n if ( x -> mv_col_max > col_max ) x -> mv_col_max = col_max ;\n if ( x -> mv_row_min < row_min ) x -> mv_row_min = row_min ;\n if ( x -> mv_row_max > row_max ) x -> mv_row_max = row_max ;\n }", "idx": 371}
{"hash": -282365232561056844, "project": "debian", "size": 21, "label": 0, "functionSource": "void vmxnet_tx_pkt_update_ip_checksums ( struct VmxnetTxPkt * pkt ) {\n uint16_t csum ;\n uint32_t ph_raw_csum ;\n assert ( pkt ) ;\n uint8_t gso_type = pkt -> virt_hdr . gso_type & ~ VIRTIO_NET_HDR_GSO_ECN ;\n struct ip_header * ip_hdr ;\n if ( VIRTIO_NET_HDR_GSO_TCPV4 != gso_type && VIRTIO_NET_HDR_GSO_UDP != gso_type ) {\n return ;\n }\n ip_hdr = pkt -> vec [ VMXNET_TX_PKT_L3HDR_FRAG ] . iov_base ;\n if ( pkt -> payload_len + pkt -> vec [ VMXNET_TX_PKT_L3HDR_FRAG ] . iov_len > ETH_MAX_IP_DGRAM_LEN ) {\n return ;\n }\n ip_hdr -> ip_len = cpu_to_be16 ( pkt -> payload_len + pkt -> vec [ VMXNET_TX_PKT_L3HDR_FRAG ] . iov_len ) ;\n ip_hdr -> ip_sum = 0 ;\n csum = net_raw_checksum ( ( uint8_t * ) ip_hdr , pkt -> vec [ VMXNET_TX_PKT_L3HDR_FRAG ] . iov_len ) ;\n ip_hdr -> ip_sum = cpu_to_be16 ( csum ) ;\n ph_raw_csum = eth_calc_pseudo_hdr_csum ( ip_hdr , pkt -> payload_len ) ;\n csum = cpu_to_be16 ( ~ net_checksum_finish ( ph_raw_csum ) ) ;\n iov_from_buf ( & pkt -> vec [ VMXNET_TX_PKT_PL_START_FRAG ] , pkt -> payload_frags , pkt -> virt_hdr . csum_offset , & csum , sizeof ( csum ) ) ;\n }", "idx": 372}
{"hash": 6667142528452941476, "project": "debian", "size": 7, "label": 0, "functionSource": "static void print_blob_as_hex ( FILE * output_file , const char * str , ulong len ) {\n const char * ptr = str , * end = ptr + len ;\n for ( ;\n ptr < end ;\n ptr ++ ) fprintf ( output_file , \"%02X\" , * ( ( uchar * ) ptr ) ) ;\n check_io ( output_file ) ;\n }", "idx": 373}
{"hash": 2343071019501443392, "project": "chrome", "size": 10, "label": 0, "functionSource": "static int update_mv ( vp9_writer * w , const unsigned int ct [ 2 ] , vp9_prob * cur_p , vp9_prob upd_p ) {\n const vp9_prob new_p = get_binary_prob ( ct [ 0 ] , ct [ 1 ] ) | 1 ;\n const int update = cost_branch256 ( ct , * cur_p ) + vp9_cost_zero ( upd_p ) > cost_branch256 ( ct , new_p ) + vp9_cost_one ( upd_p ) + 7 * 256 ;\n vp9_write ( w , update , upd_p ) ;\n if ( update ) {\n * cur_p = new_p ;\n vp9_write_literal ( w , new_p >> 1 , 7 ) ;\n }\n return update ;\n }", "idx": 374}
{"hash": -1315695702746584250, "project": "debian", "size": 41, "label": 0, "functionSource": "void proto_registrar_dump_fields ( void ) {\n header_field_info * hfinfo , * parent_hfinfo ;\n int i , len ;\n const char * enum_name ;\n const char * base_name ;\n const char * blurb ;\n char width [ 5 ] ;\n len = gpa_hfinfo . len ;\n for ( i = 0 ;\n i < len ;\n i ++ ) {\n if ( gpa_hfinfo . hfi [ i ] == NULL ) continue ;\n PROTO_REGISTRAR_GET_NTH ( i , hfinfo ) ;\n if ( hfinfo -> id == hf_text_only ) continue ;\n if ( proto_registrar_is_protocol ( i ) ) {\n ws_debug_printf ( \"P\\t%s\\t%s\\n\" , hfinfo -> name , hfinfo -> abbrev ) ;\n }\n else {\n if ( hfinfo -> same_name_prev_id != - 1 ) continue ;\n PROTO_REGISTRAR_GET_NTH ( hfinfo -> parent , parent_hfinfo ) ;\n enum_name = ftype_name ( hfinfo -> type ) ;\n base_name = \"\" ;\n if ( hfinfo -> type == FT_UINT8 || hfinfo -> type == FT_UINT16 || hfinfo -> type == FT_UINT24 || hfinfo -> type == FT_UINT32 || hfinfo -> type == FT_UINT40 || hfinfo -> type == FT_UINT48 || hfinfo -> type == FT_UINT56 || hfinfo -> type == FT_UINT64 || hfinfo -> type == FT_INT8 || hfinfo -> type == FT_INT16 || hfinfo -> type == FT_INT24 || hfinfo -> type == FT_INT32 || hfinfo -> type == FT_INT40 || hfinfo -> type == FT_INT48 || hfinfo -> type == FT_INT56 || hfinfo -> type == FT_INT64 ) {\n switch ( FIELD_DISPLAY ( hfinfo -> display ) ) {\n case BASE_NONE : case BASE_DEC : case BASE_HEX : case BASE_OCT : case BASE_DEC_HEX : case BASE_HEX_DEC : case BASE_CUSTOM : case BASE_PT_UDP : case BASE_PT_TCP : case BASE_PT_DCCP : case BASE_PT_SCTP : base_name = val_to_str_const ( FIELD_DISPLAY ( hfinfo -> display ) , hf_display , \"????\" ) ;\n break ;\n default : base_name = \"????\" ;\n break ;\n }\n }\n else if ( hfinfo -> type == FT_BOOLEAN ) {\n g_snprintf ( width , sizeof ( width ) , \"%d\" , hfinfo -> display ) ;\n base_name = width ;\n }\n blurb = hfinfo -> blurb ;\n if ( blurb == NULL ) blurb = \"\" ;\n else if ( strlen ( blurb ) == 0 ) blurb = \"\\\"\\\"\" ;\n ws_debug_printf ( \"F\\t%s\\t%s\\t%s\\t%s\\t%s\\t0x%\" G_GINT64_MODIFIER \"x\\t%s\\n\" , hfinfo -> name , hfinfo -> abbrev , enum_name , parent_hfinfo -> abbrev , base_name , hfinfo -> bitmask , blurb ) ;\n }\n }\n }", "idx": 375}
{"hash": 8320716512483418415, "project": "chrome", "size": 4, "label": 0, "functionSource": "void vp9_iwht4x4_add ( const tran_low_t * input , uint8_t * dest , int stride , int eob ) {\n if ( eob > 1 ) vp9_iwht4x4_16_add ( input , dest , stride ) ;\n else vp9_iwht4x4_1_add ( input , dest , stride ) ;\n }", "idx": 376}
{"hash": 2713698759296604855, "project": "debian", "size": 27, "label": 0, "functionSource": "void ff_init_block_index ( MpegEncContext * s ) {\n const int linesize = s -> current_picture . f . linesize [ 0 ] ;\n / ot s -> linesize as this would be wrong for field pics const int uvlinesize = s -> current_picture . f . linesize [ 1 ] ;\n const int mb_size = 4 ;\n s -> block_index [ 0 ] = s -> b8_stride * ( s -> mb_y * 2 ) - 2 + s -> mb_x * 2 ;\n s -> block_index [ 1 ] = s -> b8_stride * ( s -> mb_y * 2 ) - 1 + s -> mb_x * 2 ;\n s -> block_index [ 2 ] = s -> b8_stride * ( s -> mb_y * 2 + 1 ) - 2 + s -> mb_x * 2 ;\n s -> block_index [ 3 ] = s -> b8_stride * ( s -> mb_y * 2 + 1 ) - 1 + s -> mb_x * 2 ;\n s -> block_index [ 4 ] = s -> mb_stride * ( s -> mb_y + 1 ) + s -> b8_stride * s -> mb_height * 2 + s -> mb_x - 1 ;\n s -> block_index [ 5 ] = s -> mb_stride * ( s -> mb_y + s -> mb_height + 2 ) + s -> b8_stride * s -> mb_height * 2 + s -> mb_x - 1 ;\n s -> dest [ 0 ] = s -> current_picture . f . data [ 0 ] + ( ( s -> mb_x - 1 ) << mb_size ) ;\n s -> dest [ 1 ] = s -> current_picture . f . data [ 1 ] + ( ( s -> mb_x - 1 ) << ( mb_size - s -> chroma_x_shift ) ) ;\n s -> dest [ 2 ] = s -> current_picture . f . data [ 2 ] + ( ( s -> mb_x - 1 ) << ( mb_size - s -> chroma_x_shift ) ) ;\n if ( ! ( s -> pict_type == AV_PICTURE_TYPE_B && s -> avctx -> draw_horiz_band && s -> picture_structure == PICT_FRAME ) ) {\n if ( s -> picture_structure == PICT_FRAME ) {\n s -> dest [ 0 ] += s -> mb_y * linesize << mb_size ;\n s -> dest [ 1 ] += s -> mb_y * uvlinesize << ( mb_size - s -> chroma_y_shift ) ;\n s -> dest [ 2 ] += s -> mb_y * uvlinesize << ( mb_size - s -> chroma_y_shift ) ;\n }\n else {\n s -> dest [ 0 ] += ( s -> mb_y >> 1 ) * linesize << mb_size ;\n s -> dest [ 1 ] += ( s -> mb_y >> 1 ) * uvlinesize << ( mb_size - s -> chroma_y_shift ) ;\n s -> dest [ 2 ] += ( s -> mb_y >> 1 ) * uvlinesize << ( mb_size - s -> chroma_y_shift ) ;\n assert ( ( s -> mb_y & 1 ) == ( s -> picture_structure == PICT_BOTTOM_FIELD ) ) ;\n }\n }\n }", "idx": 377}
{"hash": 1366214969540455677, "project": "debian", "size": 7, "label": 0, "functionSource": "static int send_server_key_exchange ( SSL * s ) {\n unsigned long alg_k = s -> s3 -> tmp . new_cipher -> algorithm_mkey ;\n if ( alg_k & ( SSL_kDHE | SSL_kECDHE ) # ifndef OPENSSL_NO_PSK || ( ( alg_k & ( SSL_kPSK | SSL_kRSAPSK ) ) && s -> cert -> psk_identity_hint ) || ( alg_k & ( SSL_PSK & ( SSL_kDHEPSK | SSL_kECDHEPSK ) ) ) # endif # ifndef OPENSSL_NO_SRP || ( alg_k & SSL_kSRP ) # endif ) {\n return 1 ;\n }\n return 0 ;\n }", "idx": 378}
{"hash": -5493081488206619677, "project": "debian", "size": 8, "label": 0, "functionSource": "static const char * cmd_response_body_access ( cmd_parms * cmd , void * _dcfg , const char * p1 ) {\n directory_config * dcfg = ( directory_config * ) _dcfg ;\n if ( dcfg == NULL ) return NULL ;\n if ( strcasecmp ( p1 , \"on\" ) == 0 ) dcfg -> resbody_access = 1 ;\n else if ( strcasecmp ( p1 , \"off\" ) == 0 ) dcfg -> resbody_access = 0 ;\n else return apr_psprintf ( cmd -> pool , \"ModSecurity: Invalid value for SecResponseBodyAccess: %s\" , p1 ) ;\n return NULL ;\n }", "idx": 379}
{"hash": -341028540041678099, "project": "debian", "size": 91, "label": 0, "functionSource": "static void cookedprint ( int datatype , int length , const char * data , int status , int quiet , FILE * fp ) {\n char * name ;\n char * value ;\n char output_raw ;\n int fmt ;\n l_fp lfp ;\n sockaddr_u hval ;\n u_long uval ;\n int narr ;\n size_t len ;\n l_fp lfparr [ 8 ] ;\n char b [ 12 ] ;\n char bn [ 2 * MAXVARLEN ] ;\n char bv [ 2 * MAXVALLEN ] ;\n UNUSED_ARG ( datatype ) ;\n if ( ! quiet ) fprintf ( fp , \"status=%04x %s,\\n\" , status , statustoa ( datatype , status ) ) ;\n startoutput ( ) ;\n while ( nextvar ( & length , & data , & name , & value ) ) {\n fmt = varfmt ( name ) ;\n output_raw = 0 ;\n switch ( fmt ) {\n case PADDING : output_raw = '*' ;\n break ;\n case TS : if ( ! decodets ( value , & lfp ) ) output_raw = '?' ;\n else output ( fp , name , prettydate ( & lfp ) ) ;\n break ;\n case HA : case NA : if ( ! decodenetnum ( value , & hval ) ) {\n output_raw = '?' ;\n }\n else if ( fmt == HA ) {\n output ( fp , name , nntohost ( & hval ) ) ;\n }\n else {\n output ( fp , name , stoa ( & hval ) ) ;\n }\n break ;\n case RF : if ( decodenetnum ( value , & hval ) ) {\n if ( ISREFCLOCKADR ( & hval ) ) output ( fp , name , refnumtoa ( & hval ) ) ;\n else output ( fp , name , stoa ( & hval ) ) ;\n }\n else if ( strlen ( value ) <= 4 ) {\n output ( fp , name , value ) ;\n }\n else {\n output_raw = '?' ;\n }\n break ;\n case LP : if ( ! decodeuint ( value , & uval ) || uval > 3 ) {\n output_raw = '?' ;\n }\n else {\n b [ 0 ] = ( 0x2 & uval ) ? '1' : '0' ;\n b [ 1 ] = ( 0x1 & uval ) ? '1' : '0' ;\n b [ 2 ] = '\\0' ;\n output ( fp , name , b ) ;\n }\n break ;\n case OC : if ( ! decodeuint ( value , & uval ) ) {\n output_raw = '?' ;\n }\n else {\n snprintf ( b , sizeof ( b ) , \"%03lo\" , uval ) ;\n output ( fp , name , b ) ;\n }\n break ;\n case AR : if ( ! decodearr ( value , & narr , lfparr ) ) output_raw = '?' ;\n else outputarr ( fp , name , narr , lfparr ) ;\n break ;\n case FX : if ( ! decodeuint ( value , & uval ) ) output_raw = '?' ;\n else output ( fp , name , tstflags ( uval ) ) ;\n break ;\n default : fprintf ( stderr , \"Internal error in cookedprint, %s=%s, fmt %d\\n\" , name , value , fmt ) ;\n output_raw = '?' ;\n break ;\n }\n if ( output_raw != 0 ) {\n atoascii ( name , MAXVARLEN , bn , sizeof ( bn ) ) ;\n if ( output_raw != '*' ) {\n atoascii ( value , MAXVALLEN , bv , sizeof ( bv ) - 1 ) ;\n len = strlen ( bv ) ;\n bv [ len ] = output_raw ;\n bv [ len + 1 ] = '\\0' ;\n }\n else {\n atoascii ( value , MAXVALLEN , bv , sizeof ( bv ) ) ;\n }\n output ( fp , bn , bv ) ;\n }\n }\n endoutput ( fp ) ;\n }", "idx": 380}
{"hash": -7455544248455991006, "project": "debian", "size": 18, "label": 0, "functionSource": "void kvm_arch_reset_vcpu ( X86CPU * cpu ) {\n CPUX86State * env = & cpu -> env ;\n env -> xcr0 = 1 ;\n if ( kvm_irqchip_in_kernel ( ) ) {\n env -> mp_state = cpu_is_bsp ( cpu ) ? KVM_MP_STATE_RUNNABLE : KVM_MP_STATE_UNINITIALIZED ;\n }\n else {\n env -> mp_state = KVM_MP_STATE_RUNNABLE ;\n }\n if ( cpu -> hyperv_synic ) {\n int i ;\n for ( i = 0 ;\n i < ARRAY_SIZE ( env -> msr_hv_synic_sint ) ;\n i ++ ) {\n env -> msr_hv_synic_sint [ i ] = HV_SINT_MASKED ;\n }\n }\n }", "idx": 381}
{"hash": 1182028467273264883, "project": "debian", "size": 10, "label": 0, "functionSource": "void usage ( ) {\n print_version ( ) ;\n puts ( ORACLE_WELCOME_COPYRIGHT_NOTICE ( \"2000\" ) ) ;\n printf ( \"Runs a test against the mysql server and compares output with a results file.\\n\\n\" ) ;\n printf ( \"Usage: %s [OPTIONS] [database] < test_file\\n\" , my_progname ) ;\n print_defaults ( \"my\" , load_default_groups ) ;\n puts ( \"\" ) ;\n my_print_help ( my_long_options ) ;\n my_print_variables ( my_long_options ) ;\n }", "idx": 382}
{"hash": 4180964683905830761, "project": "debian", "size": 3, "label": 0, "functionSource": "static int match_file ( const void * p , struct file * file , unsigned fd ) {\n return file_has_perm ( p , file , file_to_av ( file ) ) ? fd + 1 : 0 ;\n }", "idx": 383}
{"hash": -5493081488206619677, "project": "debian", "size": 17, "label": 0, "functionSource": "static const char * cmd_chroot_dir ( cmd_parms * cmd , void * _dcfg , const char * p1 ) {\n char cwd [ 1025 ] = \"\" ;\n if ( cmd -> server -> is_virtual ) {\n return \"ModSecurity: SecChrootDir not allowed in VirtualHost\" ;\n }\n chroot_dir = ( char * ) p1 ;\n if ( getcwd ( cwd , 1024 ) == NULL ) {\n return \"ModSecurity: Failed to get the current working directory\" ;\n }\n if ( chdir ( chroot_dir ) < 0 ) {\n return apr_psprintf ( cmd -> pool , \"ModSecurity: Failed to chdir to %s, errno=%d (%s)\" , chroot_dir , errno , strerror ( errno ) ) ;\n }\n if ( chdir ( cwd ) < 0 ) {\n return apr_psprintf ( cmd -> pool , \"ModSecurity: Failed to chdir to %s, errno=%d (%s)\" , cwd , errno , strerror ( errno ) ) ;\n }\n return NULL ;\n }", "idx": 384}
{"hash": 3599206110384554647, "project": "debian", "size": 29, "label": 0, "functionSource": "int PEM_write_ ## name ( FILE * fp , type * x , const EVP_CIPHER * enc , unsigned char * kstr , int klen , pem_password_cb * cb , void * u ) ;\n # endif # define DECLARE_PEM_read_bio ( name , type ) type * PEM_read_bio_ ## name ( BIO * bp , type * * x , pem_password_cb * cb , void * u ) ;\n # define DECLARE_PEM_write_bio ( name , type ) int PEM_write_bio_ ## name ( BIO * bp , type * x ) ;\n # define DECLARE_PEM_write_bio_const ( name , type ) int PEM_write_bio_ ## name ( BIO * bp , const type * x ) ;\n # define DECLARE_PEM_write_cb_bio ( name , type ) int PEM_write_bio_ ## name ( BIO * bp , type * x , const EVP_CIPHER * enc , unsigned char * kstr , int klen , pem_password_cb * cb , void * u ) ;\n # define DECLARE_PEM_write ( name , type ) DECLARE_PEM_write_bio ( name , type ) DECLARE_PEM_write_fp ( name , type ) # define DECLARE_PEM_write_const ( name , type ) DECLARE_PEM_write_bio_const ( name , type ) DECLARE_PEM_write_fp_const ( name , type ) # define DECLARE_PEM_write_cb ( name , type ) DECLARE_PEM_write_cb_bio ( name , type ) DECLARE_PEM_write_cb_fp ( name , type ) # define DECLARE_PEM_read ( name , type ) DECLARE_PEM_read_bio ( name , type ) DECLARE_PEM_read_fp ( name , type ) # define DECLARE_PEM_rw ( name , type ) DECLARE_PEM_read ( name , type ) DECLARE_PEM_write ( name , type ) # define DECLARE_PEM_rw_const ( name , type ) DECLARE_PEM_read ( name , type ) DECLARE_PEM_write_const ( name , type ) # define DECLARE_PEM_rw_cb ( name , type ) DECLARE_PEM_read ( name , type ) DECLARE_PEM_write_cb ( name , type ) typedef int pem_password_cb ( char * buf , int size , int rwflag , void * userdata ) ;\n int PEM_get_EVP_CIPHER_INFO ( char * header , EVP_CIPHER_INFO * cipher ) ;\n int PEM_do_header ( EVP_CIPHER_INFO * cipher , unsigned char * data , long * len , pem_password_cb * callback , void * u ) ;\n int PEM_read_bio ( BIO * bp , char * * name , char * * header , unsigned char * * data , long * len ) ;\n # define PEM_FLAG_SECURE 0x1 # define PEM_FLAG_EAY_COMPATIBLE 0x2 # define PEM_FLAG_ONLY_B64 0x4 int PEM_read_bio_ex ( BIO * bp , char * * name , char * * header , unsigned char * * data , long * len , unsigned int flags ) ;\n int PEM_bytes_read_bio_secmem ( unsigned char * * pdata , long * plen , char * * pnm , const char * name , BIO * bp , pem_password_cb * cb , void * u ) ;\n int PEM_write_bio ( BIO * bp , const char * name , const char * hdr , const unsigned char * data , long len ) ;\n int PEM_bytes_read_bio ( unsigned char * * pdata , long * plen , char * * pnm , const char * name , BIO * bp , pem_password_cb * cb , void * u ) ;\n void * PEM_ASN1_read_bio ( d2i_of_void * d2i , const char * name , BIO * bp , void * * x , pem_password_cb * cb , void * u ) ;\n int PEM_ASN1_write_bio ( i2d_of_void * i2d , const char * name , BIO * bp , void * x , const EVP_CIPHER * enc , unsigned char * kstr , int klen , pem_password_cb * cb , void * u ) ;\n STACK_OF ( X509_INFO ) * PEM_X509_INFO_read_bio ( BIO * bp , STACK_OF ( X509_INFO ) * sk , pem_password_cb * cb , void * u ) ;\n int PEM_X509_INFO_write_bio ( BIO * bp , X509_INFO * xi , EVP_CIPHER * enc , unsigned char * kstr , int klen , pem_password_cb * cd , void * u ) ;\n # ifndef OPENSSL_NO_STDIO int PEM_read ( FILE * fp , char * * name , char * * header , unsigned char * * data , long * len ) ;\n int PEM_write ( FILE * fp , const char * name , const char * hdr , const unsigned char * data , long len ) ;\n void * PEM_ASN1_read ( d2i_of_void * d2i , const char * name , FILE * fp , void * * x , pem_password_cb * cb , void * u ) ;\n int PEM_ASN1_write ( i2d_of_void * i2d , const char * name , FILE * fp , void * x , const EVP_CIPHER * enc , unsigned char * kstr , int klen , pem_password_cb * callback , void * u ) ;\n STACK_OF ( X509_INFO ) * PEM_X509_INFO_read ( FILE * fp , STACK_OF ( X509_INFO ) * sk , pem_password_cb * cb , void * u ) ;\n # endif int PEM_SignInit ( EVP_MD_CTX * ctx , EVP_MD * type ) ;\n int PEM_SignUpdate ( EVP_MD_CTX * ctx , unsigned char * d , unsigned int cnt ) ;\n int PEM_SignFinal ( EVP_MD_CTX * ctx , unsigned char * sigret , unsigned int * siglen , EVP_PKEY * pkey ) ;\n int PEM_def_callback ( char * buf , int num , int rwflag , void * userdata ) ;\n void PEM_proc_type ( char * buf , int type ) ;\n void PEM_dek_info ( char * buf , const char * type , int len , char * str ) ;\n # include < openssl / symhacks . h > DECLARE_PEM_rw ( X509 , X509 ) DECLARE_PEM_rw ( X509_AUX , X509 ) DECLARE_PEM_rw ( X509_REQ , X509_REQ ) DECLARE_PEM_write ( X509_REQ_NEW , X509_REQ ) DECLARE_PEM_rw ( X509_CRL , X509_CRL ) DECLARE_PEM_rw ( PKCS7 , PKCS7 ) DECLARE_PEM_rw ( NETSCAPE_CERT_SEQUENCE , NETSCAPE_CERT_SEQUENCE ) DECLARE_PEM_rw ( PKCS8 , X509_SIG ) DECLARE_PEM_rw ( PKCS8_PRIV_KEY_INFO , PKCS8_PRIV_KEY_INFO ) # ifndef OPENSSL_NO_RSA DECLARE_PEM_rw_cb ( RSAPrivateKey , RSA )", "idx": 385}
{"hash": -8046645508582876963, "project": "debian", "size": 5, "label": 0, "functionSource": "static inline uint8_t motion_arg ( motion_vect mot ) {\n uint8_t ax = 8 - ( ( uint8_t ) mot . d [ 0 ] ) ;\n uint8_t ay = 8 - ( ( uint8_t ) mot . d [ 1 ] ) ;\n return ( ( ax & 15 ) << 4 ) | ( ay & 15 ) ;\n }", "idx": 386}
{"hash": -649112636673899765, "project": "debian", "size": 6, "label": 0, "functionSource": "static int rm_read_seek ( AVFormatContext * s , int stream_index , int64_t pts , int flags ) {\n RMDemuxContext * rm = s -> priv_data ;\n if ( ff_seek_frame_binary ( s , stream_index , pts , flags ) < 0 ) return - 1 ;\n rm -> audio_pkt_cnt = 0 ;\n return 0 ;\n }", "idx": 387}
{"hash": -7777644912037188223, "project": "debian", "size": 2, "label": 0, "functionSource": "static void udvm_state_free ( guint8 buff [ ] _U_ , guint16 p_id_start _U_ , guint16 p_id_length _U_ ) {\n }", "idx": 388}
{"hash": 8637588907624249958, "project": "debian", "size": 22, "label": 0, "functionSource": "static int dissect_pcp_partial_pmid ( tvbuff_t * tvb , packet_info * pinfo _U_ , proto_tree * tree , int offset ) {\n proto_item * pcp_pmid_item ;\n proto_tree * pcp_pmid_tree ;\n guint32 bits_offset ;\n guint32 pmid ;\n guint8 * name ;\n bits_offset = offset * 8 ;\n pmid = tvb_get_ntohl ( tvb , offset ) ;\n name = get_name_from_pmid ( pmid , pinfo ) ;\n pcp_pmid_item = proto_tree_add_item ( tree , hf_pcp_pmid , tvb , offset , 4 , ENC_BIG_ENDIAN ) ;\n proto_item_append_text ( pcp_pmid_item , \" (%s)\" , name ) ;\n pcp_pmid_tree = proto_item_add_subtree ( pcp_pmid_item , ett_pcp ) ;\n proto_tree_add_bits_item ( pcp_pmid_tree , hf_pcp_pmid_flag , tvb , bits_offset , 1 , ENC_BIG_ENDIAN ) ;\n bits_offset += 1 ;\n proto_tree_add_bits_item ( pcp_pmid_tree , hf_pcp_pmid_domain , tvb , bits_offset , 9 , ENC_BIG_ENDIAN ) ;\n bits_offset += 9 ;\n proto_tree_add_bits_item ( pcp_pmid_tree , hf_pcp_pmid_cluster , tvb , bits_offset , 12 , ENC_BIG_ENDIAN ) ;\n bits_offset += 12 ;\n proto_tree_add_bits_item ( pcp_pmid_tree , hf_pcp_pmid_item , tvb , bits_offset , 10 , ENC_BIG_ENDIAN ) ;\n offset += 4 ;\n return offset ;\n }", "idx": 389}
{"hash": 6415329349331062723, "project": "chrome", "size": 22, "label": 0, "functionSource": "static void http_failure_test ( void ) {\n struct bufferevent * bev ;\n int fd ;\n const char * http_request ;\n short port = - 1 ;\n test_ok = 0 ;\n fprintf ( stdout , \"Testing Bad HTTP Request: \" ) ;\n http = http_setup ( & port , NULL ) ;\n fd = http_connect ( \"127.0.0.1\" , port ) ;\n bev = bufferevent_new ( fd , http_failure_readcb , http_writecb , http_errorcb , NULL ) ;\n http_request = \"illegal request\\r\\n\" ;\n bufferevent_write ( bev , http_request , strlen ( http_request ) ) ;\n event_dispatch ( ) ;\n bufferevent_free ( bev ) ;\n EVUTIL_CLOSESOCKET ( fd ) ;\n evhttp_free ( http ) ;\n if ( test_ok != 2 ) {\n fprintf ( stdout , \"FAILED\\n\" ) ;\n exit ( 1 ) ;\n }\n fprintf ( stdout , \"OK\\n\" ) ;\n }", "idx": 390}
{"hash": -8199454075838226273, "project": "debian", "size": 105, "label": 0, "functionSource": "static gchar * rtmpt_get_packet_desc ( tvbuff_t * tvb , guint32 offset , guint32 remain , rtmpt_conv_t * rconv , int cdir , rtmpt_packet_t * tp , gint * deschasopcode ) {\n if ( tp -> cmd == RTMPT_TYPE_CHUNK_SIZE || tp -> cmd == RTMPT_TYPE_ABORT_MESSAGE || tp -> cmd == RTMPT_TYPE_ACKNOWLEDGEMENT || tp -> cmd == RTMPT_TYPE_WINDOW ) {\n if ( tp -> len >= 4 && remain >= 4 ) {\n * deschasopcode = TRUE ;\n return wmem_strdup_printf ( wmem_packet_scope ( ) , \"%s %d\" , val_to_str ( tp -> cmd , rtmpt_opcode_vals , \"Unknown (0x%01x)\" ) , tvb_get_ntohl ( tvb , offset ) ) ;\n }\n }\n else if ( tp -> cmd == RTMPT_TYPE_PEER_BANDWIDTH ) {\n if ( tp -> len >= 5 && remain >= 5 ) {\n * deschasopcode = TRUE ;\n return wmem_strdup_printf ( wmem_packet_scope ( ) , \"%s %d,%s\" , val_to_str ( tp -> cmd , rtmpt_opcode_vals , \"Unknown (0x%01x)\" ) , tvb_get_ntohl ( tvb , offset ) , val_to_str ( tvb_get_guint8 ( tvb , offset + 4 ) , rtmpt_limit_vals , \"Unknown (%d)\" ) ) ;\n }\n }\n else if ( tp -> cmd == RTMPT_TYPE_UCM ) {\n guint16 iUCM = - 1 ;\n const gchar * sFunc ;\n const gchar * sParam = \"\" ;\n if ( tp -> len < 2 || remain < 2 ) return NULL ;\n iUCM = tvb_get_ntohs ( tvb , offset ) ;\n sFunc = try_val_to_str ( iUCM , rtmpt_ucm_vals ) ;\n if ( sFunc == NULL ) {\n * deschasopcode = TRUE ;\n sFunc = wmem_strdup_printf ( wmem_packet_scope ( ) , \"User Control Message 0x%01x\" , iUCM ) ;\n }\n if ( iUCM == RTMPT_UCM_STREAM_BEGIN || iUCM == RTMPT_UCM_STREAM_EOF || iUCM == RTMPT_UCM_STREAM_DRY || iUCM == RTMPT_UCM_STREAM_ISRECORDED ) {\n if ( tp -> len >= 6 && remain >= 6 ) {\n sParam = wmem_strdup_printf ( wmem_packet_scope ( ) , \" %d\" , tvb_get_ntohl ( tvb , offset + 2 ) ) ;\n }\n }\n else if ( iUCM == RTMPT_UCM_SET_BUFFER ) {\n if ( tp -> len >= 10 && remain >= 10 ) {\n sParam = wmem_strdup_printf ( wmem_packet_scope ( ) , \" %d,%dms\" , tvb_get_ntohl ( tvb , offset + 2 ) , tvb_get_ntohl ( tvb , offset + 6 ) ) ;\n }\n }\n return wmem_strdup_printf ( wmem_packet_scope ( ) , \"%s%s\" , sFunc , sParam ) ;\n }\n else if ( tp -> cmd == RTMPT_TYPE_COMMAND_AMF0 || tp -> cmd == RTMPT_TYPE_COMMAND_AMF3 || tp -> cmd == RTMPT_TYPE_DATA_AMF0 || tp -> cmd == RTMPT_TYPE_DATA_AMF3 ) {\n guint32 slen = 0 ;\n guint32 soff = 0 ;\n gchar * sFunc = NULL ;\n gchar * sParam = NULL ;\n if ( tp -> cmd == RTMPT_TYPE_COMMAND_AMF3 || tp -> cmd == RTMPT_TYPE_DATA_AMF3 ) {\n soff = 1 ;\n }\n if ( tp -> len >= 3 + soff && remain >= 3 + soff ) {\n slen = tvb_get_ntohs ( tvb , offset + 1 + soff ) ;\n }\n if ( slen > 0 ) {\n sFunc = tvb_get_string_enc ( wmem_packet_scope ( ) , tvb , offset + 3 + soff , slen , ENC_ASCII ) ;\n RTMPT_DEBUG ( \"got function call '%s'\\n\" , sFunc ) ;\n if ( strcmp ( sFunc , \"connect\" ) == 0 ) {\n sParam = rtmpt_get_amf_param ( tvb , offset + soff , 2 , \"app\" ) ;\n }\n else if ( strcmp ( sFunc , \"play\" ) == 0 ) {\n sParam = rtmpt_get_amf_param ( tvb , offset + soff , 3 , NULL ) ;\n }\n else if ( strcmp ( sFunc , \"play2\" ) == 0 ) {\n sParam = rtmpt_get_amf_param ( tvb , offset + soff , 3 , \"streamName\" ) ;\n }\n else if ( strcmp ( sFunc , \"releaseStream\" ) == 0 ) {\n sParam = rtmpt_get_amf_param ( tvb , offset + soff , 3 , NULL ) ;\n }\n else if ( strcmp ( sFunc , \"FCPublish\" ) == 0 ) {\n sParam = rtmpt_get_amf_param ( tvb , offset + soff , 3 , NULL ) ;\n }\n else if ( strcmp ( sFunc , \"publish\" ) == 0 ) {\n sParam = rtmpt_get_amf_param ( tvb , offset + soff , 3 , NULL ) ;\n }\n else if ( strcmp ( sFunc , \"onStatus\" ) == 0 ) {\n if ( tp -> cmd == RTMPT_TYPE_COMMAND_AMF0 || tp -> cmd == RTMPT_TYPE_COMMAND_AMF3 ) {\n sParam = rtmpt_get_amf_param ( tvb , offset + soff , 3 , \"code\" ) ;\n }\n else {\n sParam = rtmpt_get_amf_param ( tvb , offset + soff , 1 , \"code\" ) ;\n }\n }\n else if ( strcmp ( sFunc , \"onPlayStatus\" ) == 0 ) {\n sParam = rtmpt_get_amf_param ( tvb , offset + soff , 1 , \"code\" ) ;\n }\n else if ( strcmp ( sFunc , \"_result\" ) == 0 ) {\n sParam = rtmpt_get_amf_param ( tvb , offset + soff , 3 , \"code\" ) ;\n tp -> isresponse = TRUE ;\n }\n else if ( strcmp ( sFunc , \"_error\" ) == 0 ) {\n sParam = rtmpt_get_amf_param ( tvb , offset + soff , 3 , \"code\" ) ;\n tp -> isresponse = TRUE ;\n }\n if ( tp -> txid != 0 && tp -> otherframe == 0 ) {\n tp -> otherframe = GPOINTER_TO_INT ( wmem_tree_lookup32 ( rconv -> txids [ cdir ^ 1 ] , tp -> txid ) ) ;\n if ( tp -> otherframe ) {\n RTMPT_DEBUG ( \"got otherframe=%d\\n\" , tp -> otherframe ) ;\n }\n }\n }\n if ( sFunc ) {\n if ( sParam ) {\n return wmem_strdup_printf ( wmem_packet_scope ( ) , \"%s('%s')\" , sFunc , sParam ) ;\n }\n else {\n return wmem_strdup_printf ( wmem_packet_scope ( ) , \"%s()\" , sFunc ) ;\n }\n }\n }\n return NULL ;\n }", "idx": 391}
{"hash": -6024601983167898950, "project": "debian", "size": 24, "label": 0, "functionSource": "static void activation_mount_not_mounted_callback ( GObject * source_object , GAsyncResult * res , gpointer user_data ) {\n ActivateParameters * parameters = user_data ;\n GError * error ;\n NautilusFile * file ;\n LaunchLocation * loc ;\n file = parameters -> not_mounted -> data ;\n error = NULL ;\n if ( ! g_file_mount_enclosing_volume_finish ( G_FILE ( source_object ) , res , & error ) ) {\n if ( error -> domain != G_IO_ERROR || ( error -> code != G_IO_ERROR_CANCELLED && error -> code != G_IO_ERROR_FAILED_HANDLED && error -> code != G_IO_ERROR_ALREADY_MOUNTED ) ) {\n eel_show_error_dialog ( _ ( \"Unable to access location\" ) , error -> message , parameters -> parent_window ) ;\n }\n if ( error -> domain != G_IO_ERROR || error -> code != G_IO_ERROR_ALREADY_MOUNTED ) {\n loc = find_launch_location_for_file ( parameters -> locations , file ) ;\n if ( loc ) {\n parameters -> locations = g_list_remove ( parameters -> locations , loc ) ;\n launch_location_free ( loc ) ;\n }\n }\n g_error_free ( error ) ;\n }\n parameters -> not_mounted = g_list_delete_link ( parameters -> not_mounted , parameters -> not_mounted ) ;\n nautilus_file_unref ( file ) ;\n activation_mount_not_mounted ( parameters ) ;\n }", "idx": 392}
{"hash": -331579171381918893, "project": "debian", "size": 8, "label": 0, "functionSource": "void SRP_user_pwd_free ( SRP_user_pwd * user_pwd ) {\n if ( user_pwd == NULL ) return ;\n BN_free ( user_pwd -> s ) ;\n BN_clear_free ( user_pwd -> v ) ;\n OPENSSL_free ( user_pwd -> id ) ;\n OPENSSL_free ( user_pwd -> info ) ;\n OPENSSL_free ( user_pwd ) ;\n }", "idx": 393}
{"hash": -2723830976796502611, "project": "chrome", "size": 107, "label": 1, "functionSource": "static vpx_codec_err_t validate_config ( vpx_codec_alg_priv_t * ctx , const vpx_codec_enc_cfg_t * cfg , const struct vp9_extracfg * extra_cfg ) {\n RANGE_CHECK ( cfg , g_w , 1 , 65535 ) ;\n RANGE_CHECK ( cfg , g_h , 1 , 65535 ) ;\n RANGE_CHECK ( cfg , g_timebase . den , 1 , 1000000000 ) ;\n RANGE_CHECK ( cfg , g_timebase . num , 1 , cfg -> g_timebase . den ) ;\n RANGE_CHECK_HI ( cfg , g_profile , 3 ) ;\n RANGE_CHECK_HI ( cfg , rc_max_quantizer , 63 ) ;\n RANGE_CHECK_HI ( cfg , rc_min_quantizer , cfg -> rc_max_quantizer ) ;\n RANGE_CHECK_BOOL ( extra_cfg , lossless ) ;\n RANGE_CHECK ( extra_cfg , aq_mode , 0 , AQ_MODE_COUNT - 1 ) ;\n RANGE_CHECK ( extra_cfg , frame_periodic_boost , 0 , 1 ) ;\n RANGE_CHECK_HI ( cfg , g_threads , 64 ) ;\n RANGE_CHECK_HI ( cfg , g_lag_in_frames , MAX_LAG_BUFFERS ) ;\n RANGE_CHECK ( cfg , rc_end_usage , VPX_VBR , VPX_Q ) ;\n RANGE_CHECK_HI ( cfg , rc_undershoot_pct , 1000 ) ;\n RANGE_CHECK_HI ( cfg , rc_overshoot_pct , 1000 ) ;\n RANGE_CHECK_HI ( cfg , rc_2pass_vbr_bias_pct , 100 ) ;\n RANGE_CHECK ( cfg , kf_mode , VPX_KF_DISABLED , VPX_KF_AUTO ) ;\n RANGE_CHECK_BOOL ( cfg , rc_resize_allowed ) ;\n RANGE_CHECK_HI ( cfg , rc_dropframe_thresh , 100 ) ;\n RANGE_CHECK_HI ( cfg , rc_resize_up_thresh , 100 ) ;\n RANGE_CHECK_HI ( cfg , rc_resize_down_thresh , 100 ) ;\n RANGE_CHECK ( cfg , g_pass , VPX_RC_ONE_PASS , VPX_RC_LAST_PASS ) ;\n if ( cfg -> rc_resize_allowed == 1 ) {\n RANGE_CHECK ( cfg , rc_scaled_width , 1 , cfg -> g_w ) ;\n RANGE_CHECK ( cfg , rc_scaled_height , 1 , cfg -> g_h ) ;\n }\n RANGE_CHECK ( cfg , ss_number_layers , 1 , VPX_SS_MAX_LAYERS ) ;\n RANGE_CHECK ( cfg , ts_number_layers , 1 , VPX_TS_MAX_LAYERS ) ;\n if ( cfg -> ts_number_layers > 1 ) {\n unsigned int i ;\n for ( i = 1 ;\n i < cfg -> ts_number_layers ;\n ++ i ) if ( cfg -> ts_target_bitrate [ i ] < cfg -> ts_target_bitrate [ i - 1 ] ) ERROR ( \"ts_target_bitrate entries are not increasing\" ) ;\n RANGE_CHECK ( cfg , ts_rate_decimator [ cfg -> ts_number_layers - 1 ] , 1 , 1 ) ;\n for ( i = cfg -> ts_number_layers - 2 ;\n i > 0 ;\n -- i ) if ( cfg -> ts_rate_decimator [ i - 1 ] != 2 * cfg -> ts_rate_decimator [ i ] ) ERROR ( \"ts_rate_decimator factors are not powers of 2\" ) ;\n }\n # if CONFIG_SPATIAL_SVC if ( cfg -> ss_number_layers * cfg -> ts_number_layers > REF_FRAMES ) ERROR ( \"Too many layers. Maximum 8 layers could be set\" ) ;\n if ( ( cfg -> ss_number_layers > 1 || cfg -> ts_number_layers > 1 ) && cfg -> g_pass == VPX_RC_LAST_PASS ) {\n unsigned int i , alt_ref_sum = 0 ;\n for ( i = 0 ;\n i < cfg -> ss_number_layers ;\n ++ i ) {\n if ( cfg -> ss_enable_auto_alt_ref [ i ] ) ++ alt_ref_sum ;\n }\n if ( alt_ref_sum > REF_FRAMES - cfg -> ss_number_layers * cfg -> ts_number_layers ) ERROR ( \"Not enough ref buffers for svc alt ref frames\" ) ;\n if ( ( cfg -> ss_number_layers > 3 || cfg -> ss_number_layers * cfg -> ts_number_layers > 4 ) && cfg -> g_error_resilient == 0 ) ERROR ( \"Multiple frame context are not supported for more than 3 spatial \" \"layers or more than 4 spatial x temporal layers\" ) ;\n }\n # endif if ( cfg -> kf_mode != VPX_KF_DISABLED && cfg -> kf_min_dist != cfg -> kf_max_dist && cfg -> kf_min_dist > 0 ) ERROR ( \"kf_min_dist not supported in auto mode, use 0 \" \"or kf_max_dist instead.\" ) ;\n RANGE_CHECK_BOOL ( extra_cfg , enable_auto_alt_ref ) ;\n RANGE_CHECK ( extra_cfg , cpu_used , - 16 , 16 ) ;\n RANGE_CHECK_HI ( extra_cfg , noise_sensitivity , 6 ) ;\n RANGE_CHECK ( extra_cfg , tile_columns , 0 , 6 ) ;\n RANGE_CHECK ( extra_cfg , tile_rows , 0 , 2 ) ;\n RANGE_CHECK_HI ( extra_cfg , sharpness , 7 ) ;\n RANGE_CHECK ( extra_cfg , arnr_max_frames , 0 , 15 ) ;\n RANGE_CHECK_HI ( extra_cfg , arnr_strength , 6 ) ;\n RANGE_CHECK ( extra_cfg , cq_level , 0 , 63 ) ;\n RANGE_CHECK ( cfg , g_bit_depth , VPX_BITS_8 , VPX_BITS_12 ) ;\n RANGE_CHECK ( cfg , g_input_bit_depth , 8 , 12 ) ;\n RANGE_CHECK ( extra_cfg , content , VP9E_CONTENT_DEFAULT , VP9E_CONTENT_INVALID - 1 ) ;\n if ( extra_cfg -> tuning == VP8_TUNE_SSIM ) ERROR ( \"Option --tune=ssim is not currently supported in VP9.\" ) ;\n if ( cfg -> g_pass == VPX_RC_LAST_PASS ) {\n const size_t packet_sz = sizeof ( FIRSTPASS_STATS ) ;\n const int n_packets = ( int ) ( cfg -> rc_twopass_stats_in . sz / packet_sz ) ;\n const FIRSTPASS_STATS * stats ;\n if ( cfg -> rc_twopass_stats_in . buf == NULL ) ERROR ( \"rc_twopass_stats_in.buf not set.\" ) ;\n if ( cfg -> rc_twopass_stats_in . sz % packet_sz ) ERROR ( \"rc_twopass_stats_in.sz indicates truncated packet.\" ) ;\n if ( cfg -> ss_number_layers > 1 || cfg -> ts_number_layers > 1 ) {\n int i ;\n unsigned int n_packets_per_layer [ VPX_SS_MAX_LAYERS ] = {\n 0 }\n ;\n stats = cfg -> rc_twopass_stats_in . buf ;\n for ( i = 0 ;\n i < n_packets ;\n ++ i ) {\n const int layer_id = ( int ) stats [ i ] . spatial_layer_id ;\n if ( layer_id >= 0 && layer_id < ( int ) cfg -> ss_number_layers ) {\n ++ n_packets_per_layer [ layer_id ] ;\n }\n }\n for ( i = 0 ;\n i < ( int ) cfg -> ss_number_layers ;\n ++ i ) {\n unsigned int layer_id ;\n if ( n_packets_per_layer [ i ] < 2 ) {\n ERROR ( \"rc_twopass_stats_in requires at least two packets for each \" \"layer.\" ) ;\n }\n stats = ( const FIRSTPASS_STATS * ) cfg -> rc_twopass_stats_in . buf + n_packets - cfg -> ss_number_layers + i ;\n layer_id = ( int ) stats -> spatial_layer_id ;\n if ( layer_id >= cfg -> ss_number_layers || ( unsigned int ) ( stats -> count + 0.5 ) != n_packets_per_layer [ layer_id ] - 1 ) ERROR ( \"rc_twopass_stats_in missing EOS stats packet\" ) ;\n }\n }\n else {\n if ( cfg -> rc_twopass_stats_in . sz < 2 * packet_sz ) ERROR ( \"rc_twopass_stats_in requires at least two packets.\" ) ;\n stats = ( const FIRSTPASS_STATS * ) cfg -> rc_twopass_stats_in . buf + n_packets - 1 ;\n if ( ( int ) ( stats -> count + 0.5 ) != n_packets - 1 ) ERROR ( \"rc_twopass_stats_in missing EOS stats packet\" ) ;\n }\n }\n # if ! CONFIG_VP9_HIGHBITDEPTH if ( cfg -> g_profile > ( unsigned int ) PROFILE_1 ) ERROR ( \"Profile > 1 not supported in this build configuration\" ) ;\n # endif if ( cfg -> g_profile <= ( unsigned int ) PROFILE_1 && extra_cfg -> bit_depth > VPX_BITS_8 ) ERROR ( \"Codec high bit-depth not supported in profile < 2\" ) ;\n if ( cfg -> g_profile > ( unsigned int ) PROFILE_1 && extra_cfg -> bit_depth == VPX_BITS_8 ) ERROR ( \"Codec bit-depth 8 not supported in profile > 1\" ) ;\n return VPX_CODEC_OK ;\n }", "idx": 394}
{"hash": 2895622461494525400, "project": "debian", "size": 50, "label": 0, "functionSource": "static void test_view_insert ( ) {\n MYSQL_STMT * insert_stmt , * select_stmt ;\n int rc , i ;\n MYSQL_BIND my_bind [ 1 ] ;\n int my_val = 0 ;\n ulong my_length = 0L ;\n long my_null = 0L ;\n const char * query = \"insert into v1 values (?)\" ;\n myheader ( \"test_view_insert\" ) ;\n rc = mysql_query ( mysql , \"DROP TABLE IF EXISTS t1,v1\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"DROP VIEW IF EXISTS t1,v1\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"create table t1 (a int, primary key (a))\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"create view v1 as select a from t1 where a>=1\" ) ;\n myquery ( rc ) ;\n insert_stmt = mysql_stmt_init ( mysql ) ;\n rc = mysql_stmt_prepare ( insert_stmt , query , strlen ( query ) ) ;\n check_execute ( insert_stmt , rc ) ;\n query = \"select * from t1\" ;\n select_stmt = mysql_stmt_init ( mysql ) ;\n rc = mysql_stmt_prepare ( select_stmt , query , strlen ( query ) ) ;\n check_execute ( select_stmt , rc ) ;\n memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n my_bind [ 0 ] . buffer_type = MYSQL_TYPE_LONG ;\n my_bind [ 0 ] . buffer = ( char * ) & my_val ;\n my_bind [ 0 ] . length = & my_length ;\n my_bind [ 0 ] . is_null = ( char * ) & my_null ;\n rc = mysql_stmt_bind_param ( insert_stmt , my_bind ) ;\n check_execute ( insert_stmt , rc ) ;\n for ( i = 0 ;\n i < 3 ;\n i ++ ) {\n int rowcount = 0 ;\n my_val = i ;\n rc = mysql_stmt_execute ( insert_stmt ) ;\n check_execute ( insert_stmt , rc ) ;\n rc = mysql_stmt_execute ( select_stmt ) ;\n check_execute ( select_stmt , rc ) ;\n rowcount = ( int ) my_process_stmt_result ( select_stmt ) ;\n DIE_UNLESS ( ( i + 1 ) == rowcount ) ;\n }\n mysql_stmt_close ( insert_stmt ) ;\n mysql_stmt_close ( select_stmt ) ;\n rc = mysql_query ( mysql , \"DROP VIEW v1\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"DROP TABLE t1\" ) ;\n myquery ( rc ) ;\n }", "idx": 395}
{"hash": 6343276067273564310, "project": "debian", "size": 30, "label": 1, "functionSource": "static afs_int32 newEntry ( struct rx_call * call , char aname [ ] , afs_int32 flag , afs_int32 oid , afs_int32 * aid , afs_int32 * cid ) {\n afs_int32 code ;\n struct ubik_trans * tt ;\n int admin ;\n char cname [ PR_MAXNAMELEN ] ;\n stolower ( aname ) ;\n code = Initdb ( ) ;\n if ( code ) return code ;\n code = ubik_BeginTrans ( dbase , UBIK_WRITETRANS , & tt ) ;\n if ( code ) return code ;\n code = ubik_SetLock ( tt , 1 , 1 , LOCKWRITE ) ;\n if ( code ) ABORT_WITH ( tt , code ) ;\n code = read_DbHeader ( tt ) ;\n if ( code ) ABORT_WITH ( tt , code ) ;\n code = WhoIsThisWithName ( call , tt , cid , cname ) ;\n if ( code != 2 ) {\n if ( code ) ABORT_WITH ( tt , PRPERM ) ;\n admin = IsAMemberOf ( tt , * cid , SYSADMINID ) ;\n }\n else {\n admin = ( ( ! restricted && ! strcmp ( aname , cname ) ) ) || IsAMemberOf ( tt , * cid , SYSADMINID ) ;\n oid = * cid = SYSADMINID ;\n }\n if ( ! CreateOK ( tt , * cid , oid , flag , admin ) ) ABORT_WITH ( tt , PRPERM ) ;\n code = CreateEntry ( tt , aname , aid , 0 , flag , oid , * cid ) ;\n if ( code != PRSUCCESS ) ABORT_WITH ( tt , code ) ;\n code = ubik_EndTrans ( tt ) ;\n if ( code ) return code ;\n return PRSUCCESS ;\n }", "idx": 396}
{"hash": 1891617106617090004, "project": "chrome", "size": 82, "label": 1, "functionSource": "static void T_UConverter_fromUnicode_UTF32_LE_OFFSET_LOGIC ( UConverterFromUnicodeArgs * args , UErrorCode * err ) {\n const UChar * mySource = args -> source ;\n unsigned char * myTarget ;\n int32_t * myOffsets ;\n const UChar * sourceLimit = args -> sourceLimit ;\n const unsigned char * targetLimit = ( unsigned char * ) args -> targetLimit ;\n UChar32 ch , ch2 ;\n unsigned int indexToWrite ;\n unsigned char temp [ sizeof ( uint32_t ) ] ;\n int32_t offsetNum = 0 ;\n if ( mySource >= sourceLimit ) {\n return ;\n }\n if ( args -> converter -> fromUnicodeStatus == UCNV_NEED_TO_WRITE_BOM ) {\n static const char bom [ ] = {\n ( char ) 0xff , ( char ) 0xfe , 0 , 0 }\n ;\n ucnv_fromUWriteBytes ( args -> converter , bom , 4 , & args -> target , args -> targetLimit , & args -> offsets , - 1 , err ) ;\n args -> converter -> fromUnicodeStatus = 0 ;\n }\n myTarget = ( unsigned char * ) args -> target ;\n myOffsets = args -> offsets ;\n temp [ 3 ] = 0 ;\n if ( args -> converter -> fromUChar32 ) {\n ch = args -> converter -> fromUChar32 ;\n args -> converter -> fromUChar32 = 0 ;\n goto lowsurogate ;\n }\n while ( mySource < sourceLimit && myTarget < targetLimit ) {\n ch = * ( mySource ++ ) ;\n if ( U16_IS_SURROGATE ( ch ) ) {\n if ( U16_IS_LEAD ( ch ) ) {\n lowsurogate : if ( mySource < sourceLimit ) {\n ch2 = * mySource ;\n if ( U16_IS_TRAIL ( ch2 ) ) {\n ch = ( ( ch - SURROGATE_HIGH_START ) << HALF_SHIFT ) + ch2 + SURROGATE_LOW_BASE ;\n mySource ++ ;\n }\n else {\n args -> converter -> fromUChar32 = ch ;\n * err = U_ILLEGAL_CHAR_FOUND ;\n break ;\n }\n }\n else {\n args -> converter -> fromUChar32 = ch ;\n if ( args -> flush ) {\n * err = U_ILLEGAL_CHAR_FOUND ;\n }\n break ;\n }\n }\n else {\n args -> converter -> fromUChar32 = ch ;\n * err = U_ILLEGAL_CHAR_FOUND ;\n break ;\n }\n }\n temp [ 2 ] = ( uint8_t ) ( ch >> 16 & 0x1F ) ;\n temp [ 1 ] = ( uint8_t ) ( ch >> 8 ) ;\n temp [ 0 ] = ( uint8_t ) ( ch ) ;\n for ( indexToWrite = 0 ;\n indexToWrite <= sizeof ( uint32_t ) - 1 ;\n indexToWrite ++ ) {\n if ( myTarget < targetLimit ) {\n * ( myTarget ++ ) = temp [ indexToWrite ] ;\n * ( myOffsets ++ ) = offsetNum ;\n }\n else {\n args -> converter -> charErrorBuffer [ args -> converter -> charErrorBufferLength ++ ] = temp [ indexToWrite ] ;\n * err = U_BUFFER_OVERFLOW_ERROR ;\n }\n }\n offsetNum = offsetNum + 1 + ( temp [ 2 ] != 0 ) ;\n }\n if ( mySource < sourceLimit && myTarget >= targetLimit && U_SUCCESS ( * err ) ) {\n * err = U_BUFFER_OVERFLOW_ERROR ;\n }\n args -> target = ( char * ) myTarget ;\n args -> source = mySource ;\n args -> offsets = myOffsets ;\n }", "idx": 397}
{"hash": -3889154245145551951, "project": "debian", "size": 21, "label": 0, "functionSource": "static void mktree ( struct tree_content * t , int v , struct strbuf * b ) {\n size_t maxlen = 0 ;\n unsigned int i ;\n if ( ! v ) qsort ( t -> entries , t -> entry_count , sizeof ( t -> entries [ 0 ] ) , tecmp0 ) ;\n else qsort ( t -> entries , t -> entry_count , sizeof ( t -> entries [ 0 ] ) , tecmp1 ) ;\n for ( i = 0 ;\n i < t -> entry_count ;\n i ++ ) {\n if ( t -> entries [ i ] -> versions [ v ] . mode ) maxlen += t -> entries [ i ] -> name -> str_len + 34 ;\n }\n strbuf_reset ( b ) ;\n strbuf_grow ( b , maxlen ) ;\n for ( i = 0 ;\n i < t -> entry_count ;\n i ++ ) {\n struct tree_entry * e = t -> entries [ i ] ;\n if ( ! e -> versions [ v ] . mode ) continue ;\n strbuf_addf ( b , \"%o %s%c\" , ( unsigned int ) ( e -> versions [ v ] . mode & ~ NO_DELTA ) , e -> name -> str_dat , '\\0' ) ;\n strbuf_add ( b , e -> versions [ v ] . sha1 , 20 ) ;\n }\n }", "idx": 398}
{"hash": 415966375198131126, "project": "debian", "size": 12, "label": 1, "functionSource": "void init_util ( void ) {\n filegen_register ( statsdir , \"peerstats\" , & peerstats ) ;\n filegen_register ( statsdir , \"loopstats\" , & loopstats ) ;\n filegen_register ( statsdir , \"clockstats\" , & clockstats ) ;\n filegen_register ( statsdir , \"rawstats\" , & rawstats ) ;\n filegen_register ( statsdir , \"sysstats\" , & sysstats ) ;\n filegen_register ( statsdir , \"protostats\" , & protostats ) ;\n # ifdef AUTOKEY filegen_register ( statsdir , \"cryptostats\" , & cryptostats ) ;\n # endif # ifdef DEBUG_TIMING filegen_register ( statsdir , \"timingstats\" , & timingstats ) ;\n # endif step_callback = & ntpd_time_stepped ;\n # ifdef DEBUG atexit ( & uninit_util ) ;\n # endif }", "idx": 399}
{"hash": 1460203986417252430, "project": "debian", "size": 89, "label": 0, "functionSource": "gcry_error_t gcry_mpi_scan ( struct gcry_mpi * * ret_mpi , enum gcry_mpi_format format , const void * buffer_arg , size_t buflen , size_t * nscanned ) {\n const unsigned char * buffer = ( const unsigned char * ) buffer_arg ;\n struct gcry_mpi * a = NULL ;\n unsigned int len ;\n int secure = ( buffer && gcry_is_secure ( buffer ) ) ;\n if ( format == GCRYMPI_FMT_SSH ) len = 0 ;\n else len = buflen ;\n if ( format == GCRYMPI_FMT_STD ) {\n const unsigned char * s = buffer ;\n a = secure ? mpi_alloc_secure ( ( len + BYTES_PER_MPI_LIMB - 1 ) / BYTES_PER_MPI_LIMB ) : mpi_alloc ( ( len + BYTES_PER_MPI_LIMB - 1 ) / BYTES_PER_MPI_LIMB ) ;\n if ( len ) {\n a -> sign = ! ! ( * s & 0x80 ) ;\n if ( a -> sign ) {\n mpi_free ( a ) ;\n return gcry_error ( GPG_ERR_INTERNAL ) ;\n }\n else _gcry_mpi_set_buffer ( a , s , len , 0 ) ;\n }\n if ( ret_mpi ) {\n mpi_normalize ( a ) ;\n * ret_mpi = a ;\n }\n else mpi_free ( a ) ;\n return 0 ;\n }\n else if ( format == GCRYMPI_FMT_USG ) {\n a = secure ? mpi_alloc_secure ( ( len + BYTES_PER_MPI_LIMB - 1 ) / BYTES_PER_MPI_LIMB ) : mpi_alloc ( ( len + BYTES_PER_MPI_LIMB - 1 ) / BYTES_PER_MPI_LIMB ) ;\n if ( len ) _gcry_mpi_set_buffer ( a , buffer , len , 0 ) ;\n if ( ret_mpi ) {\n mpi_normalize ( a ) ;\n * ret_mpi = a ;\n }\n else mpi_free ( a ) ;\n return 0 ;\n }\n else if ( format == GCRYMPI_FMT_PGP ) {\n a = mpi_read_from_buffer ( buffer , & len , secure ) ;\n if ( nscanned ) * nscanned = len ;\n if ( ret_mpi && a ) {\n mpi_normalize ( a ) ;\n * ret_mpi = a ;\n }\n else if ( a ) {\n mpi_free ( a ) ;\n a = NULL ;\n }\n return a ? 0 : gcry_error ( GPG_ERR_INV_OBJ ) ;\n }\n else if ( format == GCRYMPI_FMT_SSH ) {\n const unsigned char * s = buffer ;\n size_t n ;\n if ( len && len < 4 ) return gcry_error ( GPG_ERR_TOO_SHORT ) ;\n n = ( s [ 0 ] << 24 | s [ 1 ] << 16 | s [ 2 ] << 8 | s [ 3 ] ) ;\n s += 4 ;\n if ( len ) len -= 4 ;\n if ( len && n > len ) return gcry_error ( GPG_ERR_TOO_LARGE ) ;\n a = secure ? mpi_alloc_secure ( ( n + BYTES_PER_MPI_LIMB - 1 ) / BYTES_PER_MPI_LIMB ) : mpi_alloc ( ( n + BYTES_PER_MPI_LIMB - 1 ) / BYTES_PER_MPI_LIMB ) ;\n if ( n ) {\n a -> sign = ! ! ( * s & 0x80 ) ;\n if ( a -> sign ) {\n mpi_free ( a ) ;\n return gcry_error ( GPG_ERR_INTERNAL ) ;\n }\n else _gcry_mpi_set_buffer ( a , s , n , 0 ) ;\n }\n if ( nscanned ) * nscanned = n + 4 ;\n if ( ret_mpi ) {\n mpi_normalize ( a ) ;\n * ret_mpi = a ;\n }\n else mpi_free ( a ) ;\n return 0 ;\n }\n else if ( format == GCRYMPI_FMT_HEX ) {\n if ( buflen ) return gcry_error ( GPG_ERR_INV_ARG ) ;\n a = secure ? mpi_alloc_secure ( 0 ) : mpi_alloc ( 0 ) ;\n if ( mpi_fromstr ( a , ( const char * ) buffer ) ) {\n mpi_free ( a ) ;\n return gcry_error ( GPG_ERR_INV_OBJ ) ;\n }\n if ( ret_mpi ) {\n mpi_normalize ( a ) ;\n * ret_mpi = a ;\n }\n else mpi_free ( a ) ;\n return 0 ;\n }\n else return gcry_error ( GPG_ERR_INV_ARG ) ;\n }", "idx": 400}
{"hash": 1182028467273264883, "project": "debian", "size": 3, "label": 0, "functionSource": "void my_ungetc ( int c ) {\n * line_buffer_pos ++ = ( char ) c ;\n }", "idx": 401}
{"hash": -331579171381918893, "project": "debian", "size": 20, "label": 1, "functionSource": "static ossl_inline void lh_ ## type ## _node_usage_stats_bio ( const LHASH_OF ( type ) * lh , BIO * out ) {\n OPENSSL_LH_node_usage_stats_bio ( ( const OPENSSL_LHASH * ) lh , out ) ;\n }\n static ossl_inline void lh_ ## type ## _stats_bio ( const LHASH_OF ( type ) * lh , BIO * out ) {\n OPENSSL_LH_stats_bio ( ( const OPENSSL_LHASH * ) lh , out ) ;\n }\n static ossl_inline unsigned long lh_ ## type ## _get_down_load ( LHASH_OF ( type ) * lh ) {\n return OPENSSL_LH_get_down_load ( ( OPENSSL_LHASH * ) lh ) ;\n }\n static ossl_inline void lh_ ## type ## _set_down_load ( LHASH_OF ( type ) * lh , unsigned long dl ) {\n OPENSSL_LH_set_down_load ( ( OPENSSL_LHASH * ) lh , dl ) ;\n }\n static ossl_inline void lh_ ## type ## _doall ( LHASH_OF ( type ) * lh , void ( * doall ) ( type * ) ) {\n OPENSSL_LH_doall ( ( OPENSSL_LHASH * ) lh , ( OPENSSL_LH_DOALL_FUNC ) doall ) ;\n }\n LHASH_OF ( type ) # define IMPLEMENT_LHASH_DOALL_ARG_CONST ( type , argtype ) int_implement_lhash_doall ( type , argtype , const type ) # define IMPLEMENT_LHASH_DOALL_ARG ( type , argtype ) int_implement_lhash_doall ( type , argtype , type ) # define int_implement_lhash_doall ( type , argtype , cbargtype ) static ossl_inline void lh_ ## type ## _doall_ ## argtype ( LHASH_OF ( type ) * lh , void ( * fn ) ( cbargtype * , argtype * ) , argtype * arg ) {\n OPENSSL_LH_doall_arg ( ( OPENSSL_LHASH * ) lh , ( OPENSSL_LH_DOALL_FUNCARG ) fn , ( void * ) arg ) ;\n }\n LHASH_OF ( type ) DEFINE_LHASH_OF ( OPENSSL_STRING ) ;\n # ifdef _MSC_VER # pragma warning ( push ) # pragma warning ( disable : 4090 ) # endif DEFINE_LHASH_OF ( OPENSSL_CSTRING )", "idx": 402}
{"hash": 6393050609822897742, "project": "debian", "size": 39, "label": 0, "functionSource": "static int xhci_xfer_create_sgl ( XHCITransfer * xfer , int in_xfer ) {\n XHCIState * xhci = xfer -> epctx -> xhci ;\n int i ;\n xfer -> int_req = false ;\n pci_dma_sglist_init ( & xfer -> sgl , PCI_DEVICE ( xhci ) , xfer -> trb_count ) ;\n for ( i = 0 ;\n i < xfer -> trb_count ;\n i ++ ) {\n XHCITRB * trb = & xfer -> trbs [ i ] ;\n dma_addr_t addr ;\n unsigned int chunk = 0 ;\n if ( trb -> control & TRB_TR_IOC ) {\n xfer -> int_req = true ;\n }\n switch ( TRB_TYPE ( * trb ) ) {\n case TR_DATA : if ( ( ! ( trb -> control & TRB_TR_DIR ) ) != ( ! in_xfer ) ) {\n DPRINTF ( \"xhci: data direction mismatch for TR_DATA\\n\" ) ;\n goto err ;\n }\n case TR_NORMAL : case TR_ISOCH : addr = xhci_mask64 ( trb -> parameter ) ;\n chunk = trb -> status & 0x1ffff ;\n if ( trb -> control & TRB_TR_IDT ) {\n if ( chunk > 8 || in_xfer ) {\n DPRINTF ( \"xhci: invalid immediate data TRB\\n\" ) ;\n goto err ;\n }\n qemu_sglist_add ( & xfer -> sgl , trb -> addr , chunk ) ;\n }\n else {\n qemu_sglist_add ( & xfer -> sgl , addr , chunk ) ;\n }\n break ;\n }\n }\n return 0 ;\n err : qemu_sglist_destroy ( & xfer -> sgl ) ;\n xhci_die ( xhci ) ;\n return - 1 ;\n }", "idx": 403}
{"hash": -8225252931914868675, "project": "chrome", "size": 17, "label": 0, "functionSource": "static void var_filter_block2d_bil_w8 ( const uint8_t * src_ptr , uint8_t * output_ptr , unsigned int src_pixels_per_line , int pixel_step , unsigned int output_height , unsigned int output_width , const uint16_t * vpx_filter ) {\n const uint8x8_t f0 = vmov_n_u8 ( ( uint8_t ) vpx_filter [ 0 ] ) ;\n const uint8x8_t f1 = vmov_n_u8 ( ( uint8_t ) vpx_filter [ 1 ] ) ;\n unsigned int i ;\n for ( i = 0 ;\n i < output_height ;\n ++ i ) {\n const uint8x8_t src_0 = vld1_u8 ( & src_ptr [ 0 ] ) ;\n const uint8x8_t src_1 = vld1_u8 ( & src_ptr [ pixel_step ] ) ;\n const uint16x8_t a = vmull_u8 ( src_0 , f0 ) ;\n const uint16x8_t b = vmlal_u8 ( a , src_1 , f1 ) ;\n const uint8x8_t out = vrshrn_n_u16 ( b , FILTER_BITS ) ;\n vst1_u8 ( & output_ptr [ 0 ] , out ) ;\n src_ptr += src_pixels_per_line ;\n output_ptr += output_width ;\n }\n }", "idx": 404}
{"hash": -5689214734378699681, "project": "debian", "size": 7, "label": 0, "functionSource": "int buffer_write_bytes ( buffer_t buffer , const char * data , int size ) {\n if ( buffer_write ( buffer , data , size ) ) {\n PyErr_NoMemory ( ) ;\n return 0 ;\n }\n return 1 ;\n }", "idx": 405}
{"hash": 9069516812577077304, "project": "debian", "size": 60, "label": 1, "functionSource": "static int testit ( struct test_case_struct * tc ) {\n int retval ;\n wordexp_t we , sav_we ;\n char * dummy ;\n int bzzzt = 0 ;\n int start_offs = 0 ;\n int i ;\n if ( tc -> env ) setenv ( \"var\" , tc -> env , 1 ) ;\n else unsetenv ( \"var\" ) ;\n if ( tc -> ifs ) setenv ( \"IFS\" , tc -> ifs , 1 ) ;\n else unsetenv ( \"IFS\" ) ;\n sav_we . we_wordc = 99 ;\n sav_we . we_wordv = & dummy ;\n sav_we . we_offs = 3 ;\n we = sav_we ;\n printf ( \"Test %d (%s): \" , ++ tests , tc -> words ) ;\n if ( tc -> flags & WRDE_APPEND ) {\n if ( wordexp ( \"pre1 pre2\" , & we , tc -> flags & ~ WRDE_APPEND ) != 0 ) {\n printf ( \"FAILED setup\\n\" ) ;\n return 1 ;\n }\n }\n retval = wordexp ( tc -> words , & we , tc -> flags ) ;\n if ( tc -> flags & WRDE_DOOFFS ) start_offs = sav_we . we_offs ;\n if ( retval != tc -> retval || ( retval == 0 && we . we_wordc != tc -> wordc ) ) bzzzt = 1 ;\n else if ( retval == 0 ) {\n for ( i = 0 ;\n i < start_offs ;\n ++ i ) if ( we . we_wordv [ i ] != NULL ) {\n bzzzt = 1 ;\n break ;\n }\n for ( i = 0 ;\n i < we . we_wordc ;\n ++ i ) if ( we . we_wordv [ i + start_offs ] == NULL || strcmp ( tc -> wordv [ i ] , we . we_wordv [ i + start_offs ] ) != 0 ) {\n bzzzt = 1 ;\n break ;\n }\n }\n if ( bzzzt ) {\n printf ( \"FAILED\\n\" ) ;\n printf ( \"Test words: <%s>, need retval %d, wordc %Zd\\n\" , tc -> words , tc -> retval , tc -> wordc ) ;\n if ( start_offs != 0 ) printf ( \"(preceded by %d NULLs)\\n\" , start_offs ) ;\n printf ( \"Got retval %d, wordc %Zd: \" , retval , we . we_wordc ) ;\n if ( retval == 0 || retval == WRDE_NOSPACE ) {\n for ( i = 0 ;\n i < we . we_wordc + start_offs ;\n ++ i ) if ( we . we_wordv [ i ] == NULL ) printf ( \"NULL \" ) ;\n else printf ( \"<%s> \" , we . we_wordv [ i ] ) ;\n }\n printf ( \"\\n\" ) ;\n }\n else if ( retval != 0 && retval != WRDE_NOSPACE && ( we . we_wordc != sav_we . we_wordc || we . we_wordv != sav_we . we_wordv || we . we_offs != sav_we . we_offs ) ) {\n bzzzt = 1 ;\n printf ( \"FAILED to restore wordexp_t members\\n\" ) ;\n }\n else printf ( \"OK\\n\" ) ;\n if ( retval == 0 || retval == WRDE_NOSPACE ) wordfree ( & we ) ;\n return bzzzt ;\n }", "idx": 406}
{"hash": -9032389459913766398, "project": "debian", "size": 3, "label": 0, "functionSource": "static inline bool ipv6_prefix_equal ( const struct in6_addr * a1 , const struct in6_addr * a2 , unsigned int prefixlen ) {\n return __ipv6_prefix_equal ( a1 -> s6_addr32 , a2 -> s6_addr32 , prefixlen ) ;\n }", "idx": 407}
{"hash": 5506079590431503777, "project": "debian", "size": 125, "label": 0, "functionSource": "int expand_dns_name ( tvbuff_t * tvb , int offset , int max_len , int dns_data_offset , const guchar * * name ) {\n int start_offset = offset ;\n guchar * np ;\n int len = - 1 ;\n int chars_processed = 0 ;\n int data_size = tvb_reported_length_remaining ( tvb , dns_data_offset ) ;\n int component_len ;\n int indir_offset ;\n int maxname ;\n const int min_len = 1 ;\n maxname = MAXDNAME ;\n np = ( guchar * ) wmem_alloc ( wmem_packet_scope ( ) , maxname ) ;\n * name = np ;\n maxname -- ;\n for ( ;\n ;\n ) {\n if ( max_len && offset - start_offset > max_len - 1 ) {\n break ;\n }\n component_len = tvb_get_guint8 ( tvb , offset ) ;\n offset ++ ;\n if ( component_len == 0 ) {\n break ;\n }\n chars_processed ++ ;\n switch ( component_len & 0xc0 ) {\n case 0x00 : if ( np != * name ) {\n if ( maxname > 0 ) {\n * np ++ = '.' ;\n maxname -- ;\n }\n }\n while ( component_len > 0 ) {\n if ( max_len && offset - start_offset > max_len - 1 ) {\n THROW ( ReportedBoundsError ) ;\n }\n if ( maxname > 0 ) {\n * np ++ = tvb_get_guint8 ( tvb , offset ) ;\n maxname -- ;\n }\n component_len -- ;\n offset ++ ;\n chars_processed ++ ;\n }\n break ;\n case 0x40 : switch ( component_len & 0x3f ) {\n case 0x01 : {\n int bit_count ;\n int label_len ;\n int print_len ;\n bit_count = tvb_get_guint8 ( tvb , offset ) ;\n offset ++ ;\n label_len = ( bit_count - 1 ) / 8 + 1 ;\n if ( maxname > 0 ) {\n print_len = g_snprintf ( np , maxname + 1 , \"\\\\[x\" ) ;\n if ( print_len <= maxname ) {\n np += print_len ;\n maxname -= print_len ;\n }\n else {\n maxname = 0 ;\n }\n }\n while ( label_len -- ) {\n if ( maxname > 0 ) {\n print_len = g_snprintf ( np , maxname + 1 , \"%02x\" , tvb_get_guint8 ( tvb , offset ) ) ;\n if ( print_len <= maxname ) {\n np += print_len ;\n maxname -= print_len ;\n }\n else {\n maxname = 0 ;\n }\n }\n offset ++ ;\n }\n if ( maxname > 0 ) {\n print_len = g_snprintf ( np , maxname + 1 , \"/%d]\" , bit_count ) ;\n if ( print_len <= maxname ) {\n np += print_len ;\n maxname -= print_len ;\n }\n else {\n maxname = 0 ;\n }\n }\n }\n break ;\n default : * name = \"<Unknown extended label>\" ;\n len = offset - start_offset ;\n if ( len < min_len ) {\n THROW ( ReportedBoundsError ) ;\n }\n return len ;\n }\n break ;\n case 0x80 : THROW ( ReportedBoundsError ) ;\n break ;\n case 0xc0 : indir_offset = dns_data_offset + ( ( ( component_len & ~ 0xc0 ) << 8 ) | tvb_get_guint8 ( tvb , offset ) ) ;\n offset ++ ;\n chars_processed ++ ;\n if ( len < 0 ) {\n len = offset - start_offset ;\n }\n if ( chars_processed >= data_size ) {\n * name = \"<Name contains a pointer that loops>\" ;\n if ( len < min_len ) {\n THROW ( ReportedBoundsError ) ;\n }\n return len ;\n }\n offset = indir_offset ;\n break ;\n }\n }\n * np = '\\0' ;\n if ( len < 0 ) {\n len = offset - start_offset ;\n }\n if ( len < min_len ) {\n THROW ( ReportedBoundsError ) ;\n }\n return len ;\n }", "idx": 408}
{"hash": -7855974557509681261, "project": "debian", "size": 5, "label": 0, "functionSource": "bool op_strict ( Oid opno ) {\n RegProcedure funcid = get_opcode ( opno ) ;\n if ( funcid == ( RegProcedure ) InvalidOid ) elog ( ERROR , \"operator %u does not exist\" , opno ) ;\n return func_strict ( ( Oid ) funcid ) ;\n }", "idx": 409}
{"hash": -4525874104093394205, "project": "debian", "size": 49, "label": 0, "functionSource": "static OFCondition parsePresentationContext ( unsigned char type , PRV_PRESENTATIONCONTEXTITEM * context , unsigned char * buf , unsigned long * itemLength , unsigned long availData ) {\n unsigned long length ;\n unsigned long presentationLength ;\n OFCondition cond = EC_Normal ;\n DUL_SUBITEM * subItem ;\n if ( availData < 8 ) return makeLengthError ( \"presentation context\" , availData , 8 ) ;\n if ( ( context -> transferSyntaxList = LST_Create ( ) ) == NULL ) return EC_MemoryExhausted ;\n * itemLength = 0 ;\n context -> type = * buf ++ ;\n context -> rsv1 = * buf ++ ;\n EXTRACT_SHORT_BIG ( buf , context -> length ) ;\n buf += 2 ;\n context -> contextID = * buf ++ ;\n context -> rsv2 = * buf ++ ;\n context -> result = * buf ++ ;\n context -> rsv3 = * buf ++ ;\n length = context -> length ;\n * itemLength = 2 + 2 + length ;\n if ( availData - 4 < length || length < 4 ) return makeLengthError ( \"presentation context\" , availData , 4 , length ) ;\n DCMNET_TRACE ( \"Parsing Presentation Context: (\" << STD_NAMESPACE hex << STD_NAMESPACE setfill ( '0' ) << STD_NAMESPACE setw ( 2 ) << ( unsigned int ) context -> type << STD_NAMESPACE dec << \"), Length: \" << ( unsigned long ) context -> length << OFendl << \"Presentation Context ID: \" << STD_NAMESPACE hex << STD_NAMESPACE setfill ( '0' ) << STD_NAMESPACE setw ( 2 ) << ( unsigned int ) context -> contextID << STD_NAMESPACE dec ) ;\n presentationLength = length - 4 ;\n if ( ! ( ( type == DUL_TYPEPRESENTATIONCONTEXTAC ) && ( context -> result != DUL_PRESENTATION_ACCEPT ) ) ) {\n while ( presentationLength > 0 ) {\n DCMNET_TRACE ( \"Parsing remaining \" << presentationLength << \" bytes of Presentation Context\" << OFendl << \"Next item type: \" << STD_NAMESPACE hex << STD_NAMESPACE setfill ( '0' ) << STD_NAMESPACE setw ( 2 ) << ( unsigned int ) * buf ) ;\n switch ( * buf ) {\n case DUL_TYPEABSTRACTSYNTAX : cond = parseSubItem ( & context -> abstractSyntax , buf , & length , presentationLength ) ;\n if ( cond . bad ( ) ) return cond ;\n buf += length ;\n presentationLength -= length ;\n DCMNET_TRACE ( \"Successfully parsed Abstract Syntax\" ) ;\n break ;\n case DUL_TYPETRANSFERSYNTAX : subItem = ( DUL_SUBITEM * ) malloc ( sizeof ( DUL_SUBITEM ) ) ;\n if ( subItem == NULL ) return EC_MemoryExhausted ;\n cond = parseSubItem ( subItem , buf , & length , presentationLength ) ;\n if ( cond . bad ( ) ) return cond ;\n LST_Enqueue ( & context -> transferSyntaxList , ( LST_NODE * ) subItem ) ;\n buf += length ;\n presentationLength -= length ;\n DCMNET_TRACE ( \"Successfully parsed Transfer Syntax\" ) ;\n break ;\n default : cond = parseDummy ( buf , & length , presentationLength ) ;\n buf += length ;\n if ( ! OFStandard : : safeSubtract ( presentationLength , length , presentationLength ) ) return makeUnderflowError ( \"unknown presentation context type\" , presentationLength , length ) ;\n break ;\n }\n }\n }\n return EC_Normal ;\n }", "idx": 410}
{"hash": -5697857125570093892, "project": "chrome", "size": 3, "label": 0, "functionSource": "static const char * ultag_getLanguage ( const ULanguageTag * langtag ) {\n return langtag -> language ;\n }", "idx": 411}
{"hash": -341028540041678099, "project": "debian", "size": 20, "label": 0, "functionSource": "static void setdebug ( struct parse * pcmd , FILE * fp ) {\n if ( pcmd -> nargs == 0 ) {\n ( void ) fprintf ( fp , \"debug level is %d\\n\" , debug ) ;\n return ;\n }\n else if ( STREQ ( pcmd -> argval [ 0 ] . string , \"no\" ) ) {\n debug = 0 ;\n }\n else if ( STREQ ( pcmd -> argval [ 0 ] . string , \"more\" ) ) {\n debug ++ ;\n }\n else if ( STREQ ( pcmd -> argval [ 0 ] . string , \"less\" ) ) {\n debug -- ;\n }\n else {\n ( void ) fprintf ( fp , \"What?\\n\" ) ;\n return ;\n }\n ( void ) fprintf ( fp , \"debug level set to %d\\n\" , debug ) ;\n }", "idx": 412}
{"hash": 750873883941333769, "project": "debian", "size": 31, "label": 0, "functionSource": "static int aasc_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n AascContext * s = avctx -> priv_data ;\n int compr , i , stride , ret ;\n if ( ( ret = ff_reget_buffer ( avctx , s -> frame ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"reget_buffer() failed\\n\" ) ;\n return ret ;\n }\n compr = AV_RL32 ( buf ) ;\n buf += 4 ;\n buf_size -= 4 ;\n switch ( compr ) {\n case 0 : stride = ( avctx -> width * 3 + 3 ) & ~ 3 ;\n for ( i = avctx -> height - 1 ;\n i >= 0 ;\n i -- ) {\n memcpy ( s -> frame -> data [ 0 ] + i * s -> frame -> linesize [ 0 ] , buf , avctx -> width * 3 ) ;\n buf += stride ;\n }\n break ;\n case 1 : bytestream2_init ( & s -> gb , buf , buf_size ) ;\n ff_msrle_decode ( avctx , ( AVPicture * ) s -> frame , 8 , & s -> gb ) ;\n break ;\n default : av_log ( avctx , AV_LOG_ERROR , \"Unknown compression type %d\\n\" , compr ) ;\n return AVERROR_INVALIDDATA ;\n }\n * got_frame = 1 ;\n if ( ( ret = av_frame_ref ( data , s -> frame ) ) < 0 ) return ret ;\n return buf_size ;\n }", "idx": 413}
{"hash": 927123821003322045, "project": "chrome", "size": 37, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( SessionRestorePageLoadMetricsBrowserTest , RestoreForeignSession ) {\n Profile * profile = browser ( ) -> profile ( ) ;\n sessions : : SerializedNavigationEntry nav1 = sessions : : SerializedNavigationEntryTestHelper : : CreateNavigation ( GetTestURL ( ) . spec ( ) , \"one\" ) ;\n sessions : : SerializedNavigationEntry nav2 = sessions : : SerializedNavigationEntryTestHelper : : CreateNavigation ( GetTestURL2 ( ) . spec ( ) , \"two\" ) ;\n std : : vector < const sessions : : SessionWindow * > session ;\n sessions : : SessionWindow window ;\n auto tab1 = std : : make_unique < sessions : : SessionTab > ( ) ;\n {\n sync_pb : : SessionTab sync_data ;\n sync_data . set_tab_visual_index ( 0 ) ;\n sync_data . set_current_navigation_index ( 0 ) ;\n sync_data . set_pinned ( true ) ;\n sync_data . add_navigation ( ) -> CopyFrom ( nav1 . ToSyncData ( ) ) ;\n tab1 -> SetFromSyncData ( sync_data , base : : Time : : Now ( ) ) ;\n }\n window . tabs . push_back ( std : : move ( tab1 ) ) ;\n auto tab2 = std : : make_unique < sessions : : SessionTab > ( ) ;\n {\n sync_pb : : SessionTab sync_data ;\n sync_data . set_tab_visual_index ( 1 ) ;\n sync_data . set_current_navigation_index ( 0 ) ;\n sync_data . set_pinned ( false ) ;\n sync_data . add_navigation ( ) -> CopyFrom ( nav2 . ToSyncData ( ) ) ;\n tab2 -> SetFromSyncData ( sync_data , base : : Time : : Now ( ) ) ;\n }\n window . tabs . push_back ( std : : move ( tab2 ) ) ;\n session . push_back ( static_cast < const sessions : : SessionWindow * > ( & window ) ) ;\n ui_test_utils : : BrowserAddedObserver window_observer ;\n SessionRestorePaintWaiter session_restore_paint_waiter ;\n SessionRestore : : RestoreForeignSessionWindows ( profile , session . begin ( ) , session . end ( ) ) ;\n Browser * new_browser = window_observer . WaitForSingleNewBrowser ( ) ;\n ASSERT_TRUE ( new_browser ) ;\n ASSERT_EQ ( 2 , new_browser -> tab_strip_model ( ) -> count ( ) ) ;\n session_restore_paint_waiter . WaitForForegroundTabs ( 1 ) ;\n ASSERT_NO_FATAL_FAILURE ( WaitForTabsToLoad ( new_browser ) ) ;\n ExpectFirstPaintMetricsTotalCount ( 1 ) ;\n }", "idx": 414}
{"hash": 7909110399479437032, "project": "chrome", "size": 3, "label": 0, "functionSource": "hb_bool_t hb_set_has ( const hb_set_t * set , hb_codepoint_t codepoint ) {\n return set -> has ( codepoint ) ;\n }", "idx": 415}
{"hash": 8139827869427659905, "project": "debian", "size": 39, "label": 0, "functionSource": "int gdev_pdf_get_param ( gx_device * dev , char * Param , void * list ) {\n gx_device_pdf * pdev = ( gx_device_pdf * ) dev ;\n const gs_param_item_t * pi ;\n gs_param_list * plist = ( gs_param_list * ) list ;\n int code = 0 ;\n for ( pi = pdf_param_items ;\n pi -> key != 0 ;\n ++ pi ) {\n if ( strcmp ( pi -> key , Param ) == 0 ) {\n const char * key = pi -> key ;\n const void * pvalue = ( const void * ) ( ( const char * ) pdev + pi -> offset ) ;\n int size = xfer_item_sizes [ pi -> type ] ;\n gs_param_typed_value typed ;\n memcpy ( & typed . value , pvalue , size ) ;\n typed . type = pi -> type ;\n code = ( * plist -> procs -> xmit_typed ) ( plist , key , & typed ) ;\n return code ;\n }\n }\n if ( strcmp ( Param , \"CoreDistVersion\" ) == 0 ) {\n return ( param_write_int ( plist , \"CoreDistVersion\" , & CoreDistVersion ) ) ;\n }\n if ( strcmp ( Param , \"CompatibilityLevel\" ) == 0 ) {\n float f = pdev -> CompatibilityLevel ;\n return ( param_write_float ( plist , \"CompatibilityLevel\" , & f ) ) ;\n }\n if ( strcmp ( Param , \"ForOPDFRead\" ) == 0 ) {\n return ( param_write_bool ( plist , \"ForOPDFRead\" , & pdev -> ForOPDFRead ) ) ;\n }\n if ( ! pdev -> is_ps2write ) {\n if ( strcmp ( Param , \"pdfmark\" ) == 0 ) {\n return ( param_write_null ( plist , \"pdfmark\" ) ) ;\n }\n if ( strcmp ( Param , \"DSC\" ) == 0 ) {\n return ( param_write_null ( plist , \"DSC\" ) ) ;\n }\n }\n return gdev_psdf_get_param ( dev , Param , list ) ;\n }", "idx": 416}
{"hash": -5420171864670538459, "project": "debian", "size": 9, "label": 0, "functionSource": "static void qemu_kvm_start_vcpu ( CPUState * cpu ) {\n cpu -> thread = g_malloc0 ( sizeof ( QemuThread ) ) ;\n cpu -> halt_cond = g_malloc0 ( sizeof ( QemuCond ) ) ;\n qemu_cond_init ( cpu -> halt_cond ) ;\n qemu_thread_create ( cpu -> thread , qemu_kvm_cpu_thread_fn , cpu , QEMU_THREAD_JOINABLE ) ;\n while ( ! cpu -> created ) {\n qemu_cond_wait ( & qemu_cpu_cond , & qemu_global_mutex ) ;\n }\n }", "idx": 417}
{"hash": -5615323818347734353, "project": "debian", "size": 3, "label": 0, "functionSource": "static void init_error_log_mutex ( ) {\n mysql_mutex_init ( key_LOCK_error_log , & LOCK_error_log , MY_MUTEX_INIT_FAST ) ;\n }", "idx": 418}
{"hash": 4489017523191997023, "project": "debian", "size": 8, "label": 1, "functionSource": "static int dissect_h225_T_guid ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 712 \"./asn1/h225/h225.cnf\" tvbuff_t * guid_tvb = NULL ;\n actx -> value_ptr = & guid_tvb ;\n offset = dissect_h225_GloballyUniqueID ( tvb , offset , actx , tree , hf_index ) ;\n if ( guid_tvb ) tvb_get_ntohguid ( guid_tvb , 0 , call_id_guid = wmem_new ( wmem_packet_scope ( ) , e_guid_t ) ) ;\n actx -> value_ptr = NULL ;\n return offset ;\n }", "idx": 419}
{"hash": -8365810778652022218, "project": "debian", "size": 15, "label": 0, "functionSource": "static void virtio_net_reset ( VirtIODevice * vdev ) {\n VirtIONet * n = to_virtio_net ( vdev ) ;\n n -> promisc = 1 ;\n n -> allmulti = 0 ;\n n -> alluni = 0 ;\n n -> nomulti = 0 ;\n n -> nouni = 0 ;\n n -> nobcast = 0 ;\n n -> mac_table . in_use = 0 ;\n n -> mac_table . first_multi = 0 ;\n n -> mac_table . multi_overflow = 0 ;\n n -> mac_table . uni_overflow = 0 ;\n memset ( n -> mac_table . macs , 0 , MAC_TABLE_ENTRIES * ETH_ALEN ) ;\n memset ( n -> vlans , 0 , MAX_VLAN >> 3 ) ;\n }", "idx": 420}
{"hash": -8704283573519790151, "project": "debian", "size": 3, "label": 0, "functionSource": "int ber_ptrlen ( BerElement * ber ) {\n return ( ber -> ber_ptr - ber -> ber_buf ) ;\n }", "idx": 421}
{"hash": -7775977291865552483, "project": "debian", "size": 9, "label": 0, "functionSource": "char * qemuAliasFromDisk ( const virDomainDiskDef * disk ) {\n char * ret ;\n if ( ! disk -> info . alias ) {\n virReportError ( VIR_ERR_INVALID_ARG , \"%s\" , _ ( \"disk does not have an alias\" ) ) ;\n return NULL ;\n }\n ignore_value ( virAsprintf ( & ret , \"%s%s\" , QEMU_DRIVE_HOST_PREFIX , disk -> info . alias ) ) ;\n return ret ;\n }", "idx": 422}
{"hash": 1223258652239369123, "project": "debian", "size": 3, "label": 0, "functionSource": "SPL_METHOD ( SplFileInfo , _bad_state_ex ) {\n zend_throw_exception_ex ( spl_ce_LogicException , 0 TSRMLS_CC , \"The parent constructor was not called: the object is in an \" \"invalid state \" ) ;\n }", "idx": 423}
{"hash": -7795592811940874822, "project": "debian", "size": 5, "label": 0, "functionSource": "static gcry_module_t gcry_pk_lookup_name ( const char * name ) {\n gcry_module_t pubkey ;\n pubkey = _gcry_module_lookup ( pubkeys_registered , ( void * ) name , gcry_pk_lookup_func_name ) ;\n return pubkey ;\n }", "idx": 424}
{"hash": -2723830976796502611, "project": "chrome", "size": 3, "label": 0, "functionSource": "static int64_t timebase_units_to_ticks ( const vpx_rational_t * timebase , int64_t n ) {\n return n * TICKS_PER_SEC * timebase -> num / timebase -> den ;\n }", "idx": 425}
{"hash": -5082285935423529157, "project": "debian", "size": 20, "label": 0, "functionSource": "static int dissect_rsl_ie_phy_ctx ( tvbuff_t * tvb , packet_info * pinfo _U_ , proto_tree * tree , int offset , gboolean is_mandatory ) {\n proto_item * ti ;\n proto_tree * ie_tree ;\n guint length ;\n guint8 ie_id ;\n if ( is_mandatory == FALSE ) {\n ie_id = tvb_get_guint8 ( tvb , offset ) ;\n if ( ie_id != RSL_IE_PHY_CTX ) return offset ;\n }\n ie_tree = proto_tree_add_subtree ( tree , tvb , offset , 0 , ett_ie_phy_ctx , & ti , \"Physical Context IE \" ) ;\n proto_tree_add_item ( ie_tree , hf_rsl_ie_id , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n offset ++ ;\n length = tvb_get_guint8 ( tvb , offset ) ;\n proto_item_set_len ( ti , length + 2 ) ;\n proto_tree_add_item ( ie_tree , hf_rsl_ie_length , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n offset ++ ;\n proto_tree_add_item ( ie_tree , hf_rsl_phy_ctx , tvb , offset , length , ENC_NA ) ;\n offset = offset + length ;\n return offset ;\n }", "idx": 426}
{"hash": 1760449185745615462, "project": "debian", "size": 11, "label": 0, "functionSource": "TSReturnCode TSHttpTxnHookRegisteredFor ( TSHttpTxn txnp , TSHttpHookID id , TSEventFunc funcp ) {\n HttpSM * sm = ( HttpSM * ) txnp ;\n APIHook * hook = sm -> txn_hook_get ( id ) ;\n while ( hook != nullptr ) {\n if ( hook -> m_cont && hook -> m_cont -> m_event_func == funcp ) {\n return TS_SUCCESS ;\n }\n hook = hook -> m_link . next ;\n }\n return TS_ERROR ;\n }", "idx": 427}
{"hash": -3559021711340554904, "project": "debian", "size": 23, "label": 0, "functionSource": "static bool is_strict_saop ( ScalarArrayOpExpr * expr , bool falseOK ) {\n Node * rightop ;\n set_sa_opfuncid ( expr ) ;\n if ( ! func_strict ( expr -> opfuncid ) ) return false ;\n if ( expr -> useOr && falseOK ) return true ;\n Assert ( list_length ( expr -> args ) == 2 ) ;\n rightop = ( Node * ) lsecond ( expr -> args ) ;\n if ( rightop && IsA ( rightop , Const ) ) {\n Datum arraydatum = ( ( Const * ) rightop ) -> constvalue ;\n bool arrayisnull = ( ( Const * ) rightop ) -> constisnull ;\n ArrayType * arrayval ;\n int nitems ;\n if ( arrayisnull ) return false ;\n arrayval = DatumGetArrayTypeP ( arraydatum ) ;\n nitems = ArrayGetNItems ( ARR_NDIM ( arrayval ) , ARR_DIMS ( arrayval ) ) ;\n if ( nitems > 0 ) return true ;\n }\n else if ( rightop && IsA ( rightop , ArrayExpr ) ) {\n ArrayExpr * arrayexpr = ( ArrayExpr * ) rightop ;\n if ( arrayexpr -> elements != NIL && ! arrayexpr -> multidims ) return true ;\n }\n return false ;\n }", "idx": 428}
{"hash": 4715922168896528064, "project": "debian", "size": 42, "label": 0, "functionSource": "void jpc_qmfb_join_row ( jpc_fix_t * a , int numcols , int parity ) {\n int bufsize = JPC_CEILDIVPOW2 ( numcols , 1 ) ;\n jpc_fix_t joinbuf [ QMFB_JOINBUFSIZE ] ;\n jpc_fix_t * buf = joinbuf ;\n register jpc_fix_t * srcptr ;\n register jpc_fix_t * dstptr ;\n register int n ;\n int hstartcol ;\n if ( bufsize > QMFB_JOINBUFSIZE ) {\n if ( ! ( buf = jas_alloc2 ( bufsize , sizeof ( jpc_fix_t ) ) ) ) {\n abort ( ) ;\n }\n }\n hstartcol = ( numcols + 1 - parity ) >> 1 ;\n n = hstartcol ;\n srcptr = & a [ 0 ] ;\n dstptr = buf ;\n while ( n -- > 0 ) {\n * dstptr = * srcptr ;\n ++ srcptr ;\n ++ dstptr ;\n }\n srcptr = & a [ hstartcol ] ;\n dstptr = & a [ 1 - parity ] ;\n n = numcols - hstartcol ;\n while ( n -- > 0 ) {\n * dstptr = * srcptr ;\n dstptr += 2 ;\n ++ srcptr ;\n }\n srcptr = buf ;\n dstptr = & a [ parity ] ;\n n = hstartcol ;\n while ( n -- > 0 ) {\n * dstptr = * srcptr ;\n dstptr += 2 ;\n ++ srcptr ;\n }\n if ( buf != joinbuf ) {\n jas_free ( buf ) ;\n }\n }", "idx": 429}
{"hash": 3668456668028959955, "project": "debian", "size": 18, "label": 0, "functionSource": "static VALUE cState_object_nl_set ( VALUE self , VALUE object_nl ) {\n unsigned long len ;\n GET_STATE ( self ) ;\n Check_Type ( object_nl , T_STRING ) ;\n len = RSTRING_LEN ( object_nl ) ;\n if ( len == 0 ) {\n if ( state -> object_nl ) {\n ruby_xfree ( state -> object_nl ) ;\n state -> object_nl = NULL ;\n }\n }\n else {\n if ( state -> object_nl ) ruby_xfree ( state -> object_nl ) ;\n state -> object_nl = fstrndup ( RSTRING_PTR ( object_nl ) , len ) ;\n state -> object_nl_len = len ;\n }\n return Qnil ;\n }", "idx": 430}
{"hash": -8128341148043427861, "project": "chrome", "size": 7, "label": 0, "functionSource": "static int trellis_get_coeff_context ( const int16_t * scan , const int16_t * nb , int idx , int token , uint8_t * token_cache ) {\n int bak = token_cache [ scan [ idx ] ] , pt ;\n token_cache [ scan [ idx ] ] = vp9_pt_energy_class [ token ] ;\n pt = get_coef_context ( nb , token_cache , idx + 1 ) ;\n token_cache [ scan [ idx ] ] = bak ;\n return pt ;\n }", "idx": 431}
{"hash": 4489017523191997023, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h225_EncryptIntAlg ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_EncryptIntAlg , EncryptIntAlg_choice , NULL ) ;\n return offset ;\n }", "idx": 432}
{"hash": -3384986069176965684, "project": "chrome", "size": 17, "label": 0, "functionSource": "static void setup_features ( VP8_COMP * cpi ) {\n if ( cpi -> mb . e_mbd . segmentation_enabled ) {\n cpi -> mb . e_mbd . update_mb_segmentation_map = 1 ;\n cpi -> mb . e_mbd . update_mb_segmentation_data = 1 ;\n }\n else {\n cpi -> mb . e_mbd . update_mb_segmentation_map = 0 ;\n cpi -> mb . e_mbd . update_mb_segmentation_data = 0 ;\n }\n cpi -> mb . e_mbd . mode_ref_lf_delta_enabled = 0 ;\n cpi -> mb . e_mbd . mode_ref_lf_delta_update = 0 ;\n vpx_memset ( cpi -> mb . e_mbd . ref_lf_deltas , 0 , sizeof ( cpi -> mb . e_mbd . ref_lf_deltas ) ) ;\n vpx_memset ( cpi -> mb . e_mbd . mode_lf_deltas , 0 , sizeof ( cpi -> mb . e_mbd . mode_lf_deltas ) ) ;\n vpx_memset ( cpi -> mb . e_mbd . last_ref_lf_deltas , 0 , sizeof ( cpi -> mb . e_mbd . ref_lf_deltas ) ) ;\n vpx_memset ( cpi -> mb . e_mbd . last_mode_lf_deltas , 0 , sizeof ( cpi -> mb . e_mbd . mode_lf_deltas ) ) ;\n set_default_lf_deltas ( cpi ) ;\n }", "idx": 433}
{"hash": -1763326842639388875, "project": "debian", "size": 45, "label": 0, "functionSource": "static int chacha_cipher ( EVP_CIPHER_CTX * ctx , unsigned char * out , const unsigned char * inp , size_t len ) {\n EVP_CHACHA_KEY * key = data ( ctx ) ;\n unsigned int n , rem , ctr32 ;\n if ( ( n = key -> partial_len ) ) {\n while ( len && n < CHACHA_BLK_SIZE ) {\n * out ++ = * inp ++ ^ key -> buf [ n ++ ] ;\n len -- ;\n }\n key -> partial_len = n ;\n if ( len == 0 ) return 1 ;\n if ( n == CHACHA_BLK_SIZE ) {\n key -> partial_len = 0 ;\n key -> counter [ 0 ] ++ ;\n if ( key -> counter [ 0 ] == 0 ) key -> counter [ 1 ] ++ ;\n }\n }\n rem = ( unsigned int ) ( len % CHACHA_BLK_SIZE ) ;\n len -= rem ;\n ctr32 = key -> counter [ 0 ] ;\n while ( len >= CHACHA_BLK_SIZE ) {\n size_t blocks = len / CHACHA_BLK_SIZE ;\n if ( sizeof ( size_t ) > sizeof ( unsigned int ) && blocks > ( 1U << 28 ) ) blocks = ( 1U << 28 ) ;\n ctr32 += ( unsigned int ) blocks ;\n if ( ctr32 < blocks ) {\n blocks -= ctr32 ;\n ctr32 = 0 ;\n }\n blocks *= CHACHA_BLK_SIZE ;\n ChaCha20_ctr32 ( out , inp , blocks , key -> key . d , key -> counter ) ;\n len -= blocks ;\n inp += blocks ;\n out += blocks ;\n key -> counter [ 0 ] = ctr32 ;\n if ( ctr32 == 0 ) key -> counter [ 1 ] ++ ;\n }\n if ( rem ) {\n memset ( key -> buf , 0 , sizeof ( key -> buf ) ) ;\n ChaCha20_ctr32 ( key -> buf , key -> buf , CHACHA_BLK_SIZE , key -> key . d , key -> counter ) ;\n for ( n = 0 ;\n n < rem ;\n n ++ ) out [ n ] = inp [ n ] ^ key -> buf [ n ] ;\n key -> partial_len = rem ;\n }\n return 1 ;\n }", "idx": 434}
{"hash": 2917602761308156638, "project": "debian", "size": 5, "label": 0, "functionSource": "static Asn1Generic * DecodeAsn1DerUTF8String ( const unsigned char * buffer , uint32_t max_size , uint8_t depth , uint32_t * errcode ) {\n Asn1Generic * a = DecodeAsn1DerOctetString ( buffer , max_size , depth , errcode ) ;\n if ( a != NULL ) a -> type = ASN1_UTF8STRING ;\n return a ;\n }", "idx": 435}
{"hash": -398565394354770780, "project": "debian", "size": 13, "label": 0, "functionSource": "static int ohci_port_set_if_connected ( OHCIState * ohci , int i , uint32_t val ) {\n int ret = 1 ;\n if ( val == 0 ) return 0 ;\n if ( ! ( ohci -> rhport [ i ] . ctrl & OHCI_PORT_CCS ) ) {\n ohci -> rhport [ i ] . ctrl |= OHCI_PORT_CSC ;\n if ( ohci -> rhstatus & OHCI_RHS_DRWE ) {\n }\n return 0 ;\n }\n if ( ohci -> rhport [ i ] . ctrl & val ) ret = 0 ;\n ohci -> rhport [ i ] . ctrl |= val ;\n return ret ;\n }", "idx": 436}
{"hash": -5725800580349519214, "project": "chrome", "size": 28, "label": 0, "functionSource": "vpx_codec_err_t vp9_set_reference_dec ( VP9_COMMON * cm , VP9_REFFRAME ref_frame_flag , YV12_BUFFER_CONFIG * sd ) {\n RefBuffer * ref_buf = NULL ;\n if ( ref_frame_flag == VP9_LAST_FLAG ) {\n ref_buf = & cm -> frame_refs [ 0 ] ;\n }\n else if ( ref_frame_flag == VP9_GOLD_FLAG ) {\n ref_buf = & cm -> frame_refs [ 1 ] ;\n }\n else if ( ref_frame_flag == VP9_ALT_FLAG ) {\n ref_buf = & cm -> frame_refs [ 2 ] ;\n }\n else {\n vpx_internal_error ( & cm -> error , VPX_CODEC_ERROR , \"Invalid reference frame\" ) ;\n return cm -> error . error_code ;\n }\n if ( ! equal_dimensions ( ref_buf -> buf , sd ) ) {\n vpx_internal_error ( & cm -> error , VPX_CODEC_ERROR , \"Incorrect buffer dimensions\" ) ;\n }\n else {\n int * ref_fb_ptr = & ref_buf -> idx ;\n const int free_fb = get_free_fb ( cm ) ;\n cm -> frame_bufs [ free_fb ] . ref_count -- ;\n ref_cnt_fb ( cm -> frame_bufs , ref_fb_ptr , free_fb ) ;\n ref_buf -> buf = & cm -> frame_bufs [ * ref_fb_ptr ] . buf ;\n vp8_yv12_copy_frame ( sd , ref_buf -> buf ) ;\n }\n return cm -> error . error_code ;\n }", "idx": 437}
{"hash": 6343276067273564310, "project": "debian", "size": 7, "label": 0, "functionSource": "afs_int32 SPR_GetHostCPS ( struct rx_call * call , afs_int32 ahost , prlist * alist , afs_int32 * over ) {\n afs_int32 code ;\n code = getHostCPS ( call , ahost , alist , over ) ;\n osi_auditU ( call , PTS_GetHCPSEvent , code , AUD_HOST , htonl ( ahost ) , AUD_END ) ;\n ViceLog ( 125 , ( \"PTS_GetHostCPS: code %d ahost %d\\n\" , code , ahost ) ) ;\n return code ;\n }", "idx": 438}
{"hash": 1504508151056681409, "project": "debian", "size": 32, "label": 0, "functionSource": "static int header_odc ( struct archive_read * a , struct cpio * cpio , struct archive_entry * entry , size_t * namelength , size_t * name_pad ) {\n const void * h ;\n int r ;\n const char * header ;\n a -> archive . archive_format = ARCHIVE_FORMAT_CPIO_POSIX ;\n a -> archive . archive_format_name = \"POSIX octet-oriented cpio\" ;\n r = find_odc_header ( a ) ;\n if ( r < ARCHIVE_WARN ) return ( r ) ;\n if ( a -> archive . archive_format == ARCHIVE_FORMAT_CPIO_AFIO_LARGE ) {\n int r2 = ( header_afiol ( a , cpio , entry , namelength , name_pad ) ) ;\n if ( r2 == ARCHIVE_OK ) return ( r ) ;\n else return ( r2 ) ;\n }\n h = __archive_read_ahead ( a , odc_header_size , NULL ) ;\n if ( h == NULL ) return ( ARCHIVE_FATAL ) ;\n header = ( const char * ) h ;\n archive_entry_set_dev ( entry , ( dev_t ) atol8 ( header + odc_dev_offset , odc_dev_size ) ) ;\n archive_entry_set_ino ( entry , atol8 ( header + odc_ino_offset , odc_ino_size ) ) ;\n archive_entry_set_mode ( entry , ( mode_t ) atol8 ( header + odc_mode_offset , odc_mode_size ) ) ;\n archive_entry_set_uid ( entry , atol8 ( header + odc_uid_offset , odc_uid_size ) ) ;\n archive_entry_set_gid ( entry , atol8 ( header + odc_gid_offset , odc_gid_size ) ) ;\n archive_entry_set_nlink ( entry , ( unsigned int ) atol8 ( header + odc_nlink_offset , odc_nlink_size ) ) ;\n archive_entry_set_rdev ( entry , ( dev_t ) atol8 ( header + odc_rdev_offset , odc_rdev_size ) ) ;\n archive_entry_set_mtime ( entry , atol8 ( header + odc_mtime_offset , odc_mtime_size ) , 0 ) ;\n * namelength = ( size_t ) atol8 ( header + odc_namesize_offset , odc_namesize_size ) ;\n * name_pad = 0 ;\n cpio -> entry_bytes_remaining = atol8 ( header + odc_filesize_offset , odc_filesize_size ) ;\n archive_entry_set_size ( entry , cpio -> entry_bytes_remaining ) ;\n cpio -> entry_padding = 0 ;\n __archive_read_consume ( a , odc_header_size ) ;\n return ( r ) ;\n }", "idx": 439}
{"hash": 5918484636148310736, "project": "debian", "size": 22, "label": 0, "functionSource": "int mem_word_get_bits_rectangle ( gx_device * dev , const gs_int_rect * prect , gs_get_bits_params_t * params , gs_int_rect * * unread ) {\n gx_device_memory * const mdev = ( gx_device_memory * ) dev ;\n byte * src ;\n uint dev_raster = gx_device_raster ( dev , 1 ) ;\n int x = prect -> p . x ;\n int w = prect -> q . x - x ;\n int y = prect -> p . y ;\n int h = prect -> q . y - y ;\n int bit_x , bit_w ;\n int code ;\n fit_fill_xywh ( dev , x , y , w , h ) ;\n if ( w <= 0 || h <= 0 ) {\n x = y = w = h = 0 ;\n }\n bit_x = x * dev -> color_info . depth ;\n bit_w = w * dev -> color_info . depth ;\n src = scan_line_base ( mdev , y ) ;\n mem_swap_byte_rect ( src , dev_raster , bit_x , bit_w , h , false ) ;\n code = mem_get_bits_rectangle ( dev , prect , params , unread ) ;\n mem_swap_byte_rect ( src , dev_raster , bit_x , bit_w , h , false ) ;\n return code ;\n }", "idx": 440}
{"hash": -4421762461659142174, "project": "debian", "size": 6, "label": 0, "functionSource": "static inline int unhex ( int a ) {\n if ( a >= 'A' && a <= 'F' ) return a - 'A' + 0xA ;\n if ( a >= 'a' && a <= 'f' ) return a - 'a' + 0xA ;\n if ( a >= '0' && a <= '9' ) return a - '0' ;\n return 0 ;\n }", "idx": 441}
{"hash": 2916221576319982604, "project": "debian", "size": 156, "label": 1, "functionSource": "static int encode_picture_lossless ( AVCodecContext * avctx , AVPacket * pkt , const AVFrame * pict , int * got_packet ) {\n MpegEncContext * const s = avctx -> priv_data ;\n MJpegContext * const m = s -> mjpeg_ctx ;\n const int width = s -> width ;\n const int height = s -> height ;\n AVFrame * const p = & s -> current_picture . f ;\n const int predictor = avctx -> prediction_method + 1 ;\n const int mb_width = ( width + s -> mjpeg_hsample [ 0 ] - 1 ) / s -> mjpeg_hsample [ 0 ] ;\n const int mb_height = ( height + s -> mjpeg_vsample [ 0 ] - 1 ) / s -> mjpeg_vsample [ 0 ] ;\n int ret , max_pkt_size = FF_MIN_BUFFER_SIZE ;\n if ( avctx -> pix_fmt == AV_PIX_FMT_BGRA ) max_pkt_size += width * height * 3 * 4 ;\n else {\n max_pkt_size += mb_width * mb_height * 3 * 4 * s -> mjpeg_hsample [ 0 ] * s -> mjpeg_vsample [ 0 ] ;\n }\n if ( ( ret = ff_alloc_packet ( pkt , max_pkt_size ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"Error getting output packet of size %d.\\n\" , max_pkt_size ) ;\n return ret ;\n }\n init_put_bits ( & s -> pb , pkt -> data , pkt -> size ) ;\n * p = * pict ;\n p -> pict_type = AV_PICTURE_TYPE_I ;\n p -> key_frame = 1 ;\n ff_mjpeg_encode_picture_header ( s ) ;\n s -> header_bits = put_bits_count ( & s -> pb ) ;\n if ( avctx -> pix_fmt == AV_PIX_FMT_BGRA ) {\n int x , y , i ;\n const int linesize = p -> linesize [ 0 ] ;\n uint16_t ( * buffer ) [ 4 ] = ( void * ) s -> rd_scratchpad ;\n int left [ 3 ] , top [ 3 ] , topleft [ 3 ] ;\n for ( i = 0 ;\n i < 3 ;\n i ++ ) {\n buffer [ 0 ] [ i ] = 1 << ( 9 - 1 ) ;\n }\n for ( y = 0 ;\n y < height ;\n y ++ ) {\n const int modified_predictor = y ? predictor : 1 ;\n uint8_t * ptr = p -> data [ 0 ] + ( linesize * y ) ;\n if ( s -> pb . buf_end - s -> pb . buf - ( put_bits_count ( & s -> pb ) >> 3 ) < width * 3 * 4 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"encoded frame too large\\n\" ) ;\n return - 1 ;\n }\n for ( i = 0 ;\n i < 3 ;\n i ++ ) {\n top [ i ] = left [ i ] = topleft [ i ] = buffer [ 0 ] [ i ] ;\n }\n for ( x = 0 ;\n x < width ;\n x ++ ) {\n buffer [ x ] [ 1 ] = ptr [ 4 * x + 0 ] - ptr [ 4 * x + 1 ] + 0x100 ;\n buffer [ x ] [ 2 ] = ptr [ 4 * x + 2 ] - ptr [ 4 * x + 1 ] + 0x100 ;\n buffer [ x ] [ 0 ] = ( ptr [ 4 * x + 0 ] + 2 * ptr [ 4 * x + 1 ] + ptr [ 4 * x + 2 ] ) >> 2 ;\n for ( i = 0 ;\n i < 3 ;\n i ++ ) {\n int pred , diff ;\n PREDICT ( pred , topleft [ i ] , top [ i ] , left [ i ] , modified_predictor ) ;\n topleft [ i ] = top [ i ] ;\n top [ i ] = buffer [ x + 1 ] [ i ] ;\n left [ i ] = buffer [ x ] [ i ] ;\n diff = ( ( left [ i ] - pred + 0x100 ) & 0x1FF ) - 0x100 ;\n if ( i == 0 ) ff_mjpeg_encode_dc ( s , diff , m -> huff_size_dc_luminance , m -> huff_code_dc_luminance ) ;\n else ff_mjpeg_encode_dc ( s , diff , m -> huff_size_dc_chrominance , m -> huff_code_dc_chrominance ) ;\n }\n }\n }\n }\n else {\n int mb_x , mb_y , i ;\n for ( mb_y = 0 ;\n mb_y < mb_height ;\n mb_y ++ ) {\n if ( s -> pb . buf_end - s -> pb . buf - ( put_bits_count ( & s -> pb ) >> 3 ) < mb_width * 4 * 3 * s -> mjpeg_hsample [ 0 ] * s -> mjpeg_vsample [ 0 ] ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"encoded frame too large\\n\" ) ;\n return - 1 ;\n }\n for ( mb_x = 0 ;\n mb_x < mb_width ;\n mb_x ++ ) {\n if ( mb_x == 0 || mb_y == 0 ) {\n for ( i = 0 ;\n i < 3 ;\n i ++ ) {\n uint8_t * ptr ;\n int x , y , h , v , linesize ;\n h = s -> mjpeg_hsample [ i ] ;\n v = s -> mjpeg_vsample [ i ] ;\n linesize = p -> linesize [ i ] ;\n for ( y = 0 ;\n y < v ;\n y ++ ) {\n for ( x = 0 ;\n x < h ;\n x ++ ) {\n int pred ;\n ptr = p -> data [ i ] + ( linesize * ( v * mb_y + y ) ) + ( h * mb_x + x ) ;\n if ( y == 0 && mb_y == 0 ) {\n if ( x == 0 && mb_x == 0 ) {\n pred = 128 ;\n }\n else {\n pred = ptr [ - 1 ] ;\n }\n }\n else {\n if ( x == 0 && mb_x == 0 ) {\n pred = ptr [ - linesize ] ;\n }\n else {\n PREDICT ( pred , ptr [ - linesize - 1 ] , ptr [ - linesize ] , ptr [ - 1 ] , predictor ) ;\n }\n }\n if ( i == 0 ) ff_mjpeg_encode_dc ( s , * ptr - pred , m -> huff_size_dc_luminance , m -> huff_code_dc_luminance ) ;\n else ff_mjpeg_encode_dc ( s , * ptr - pred , m -> huff_size_dc_chrominance , m -> huff_code_dc_chrominance ) ;\n }\n }\n }\n }\n else {\n for ( i = 0 ;\n i < 3 ;\n i ++ ) {\n uint8_t * ptr ;\n int x , y , h , v , linesize ;\n h = s -> mjpeg_hsample [ i ] ;\n v = s -> mjpeg_vsample [ i ] ;\n linesize = p -> linesize [ i ] ;\n for ( y = 0 ;\n y < v ;\n y ++ ) {\n for ( x = 0 ;\n x < h ;\n x ++ ) {\n int pred ;\n ptr = p -> data [ i ] + ( linesize * ( v * mb_y + y ) ) + ( h * mb_x + x ) ;\n PREDICT ( pred , ptr [ - linesize - 1 ] , ptr [ - linesize ] , ptr [ - 1 ] , predictor ) ;\n if ( i == 0 ) ff_mjpeg_encode_dc ( s , * ptr - pred , m -> huff_size_dc_luminance , m -> huff_code_dc_luminance ) ;\n else ff_mjpeg_encode_dc ( s , * ptr - pred , m -> huff_size_dc_chrominance , m -> huff_code_dc_chrominance ) ;\n }\n }\n }\n }\n }\n }\n }\n emms_c ( ) ;\n ff_mjpeg_encode_picture_trailer ( s ) ;\n s -> picture_number ++ ;\n flush_put_bits ( & s -> pb ) ;\n pkt -> size = put_bits_ptr ( & s -> pb ) - s -> pb . buf ;\n pkt -> flags |= AV_PKT_FLAG_KEY ;\n * got_packet = 1 ;\n return 0 ;\n }", "idx": 442}
{"hash": 8947170728280515149, "project": "debian", "size": 3, "label": 0, "functionSource": "int MatIsIdentity ( real transform [ 6 ] ) {\n return ( transform [ 0 ] == 1 && transform [ 3 ] == 1 && transform [ 1 ] == 0 && transform [ 2 ] == 0 && transform [ 4 ] == 0 && transform [ 5 ] == 0 ) ;\n }", "idx": 443}
{"hash": 2335116444795821310, "project": "debian", "size": 17, "label": 0, "functionSource": "static bool have_changed_settings ( const struct config_filter_parser * parser , const char * const * modules ) {\n const unsigned char * changes ;\n unsigned int i , j , size ;\n for ( i = 0 ;\n parser -> parsers [ i ] . root != NULL ;\n i ++ ) {\n if ( ! config_module_want_parser ( config_module_parsers , modules , parser -> parsers [ i ] . root ) ) continue ;\n changes = settings_parser_get_changes ( parser -> parsers [ i ] . parser ) ;\n size = parser -> parsers [ i ] . root -> struct_size ;\n for ( j = 0 ;\n j < size ;\n j ++ ) {\n if ( changes [ j ] != 0 ) return TRUE ;\n }\n }\n return FALSE ;\n }", "idx": 444}
{"hash": -7131177824150194183, "project": "debian", "size": 200, "label": 1, "functionSource": "static int bink_decode_plane ( BinkContext * c , GetBitContext * gb , int plane_idx , int is_chroma ) {\n int blk , ret ;\n int i , j , bx , by ;\n uint8_t * dst , * prev , * ref , * ref_start , * ref_end ;\n int v , col [ 2 ] ;\n const uint8_t * scan ;\n int xoff , yoff ;\n LOCAL_ALIGNED_16 ( int16_t , block , [ 64 ] ) ;\n LOCAL_ALIGNED_16 ( uint8_t , ublock , [ 64 ] ) ;\n LOCAL_ALIGNED_16 ( int32_t , dctblock , [ 64 ] ) ;\n int coordmap [ 64 ] ;\n const int stride = c -> pic -> linesize [ plane_idx ] ;\n int bw = is_chroma ? ( c -> avctx -> width + 15 ) >> 4 : ( c -> avctx -> width + 7 ) >> 3 ;\n int bh = is_chroma ? ( c -> avctx -> height + 15 ) >> 4 : ( c -> avctx -> height + 7 ) >> 3 ;\n int width = c -> avctx -> width >> is_chroma ;\n init_lengths ( c , FFMAX ( width , 8 ) , bw ) ;\n for ( i = 0 ;\n i < BINK_NB_SRC ;\n i ++ ) read_bundle ( gb , c , i ) ;\n ref_start = c -> last -> data [ plane_idx ] ? c -> last -> data [ plane_idx ] : c -> pic -> data [ plane_idx ] ;\n ref_end = ref_start + ( bw - 1 + c -> last -> linesize [ plane_idx ] * ( bh - 1 ) ) * 8 ;\n for ( i = 0 ;\n i < 64 ;\n i ++ ) coordmap [ i ] = ( i & 7 ) + ( i >> 3 ) * stride ;\n for ( by = 0 ;\n by < bh ;\n by ++ ) {\n if ( ( ret = read_block_types ( c -> avctx , gb , & c -> bundle [ BINK_SRC_BLOCK_TYPES ] ) ) < 0 ) return ret ;\n if ( ( ret = read_block_types ( c -> avctx , gb , & c -> bundle [ BINK_SRC_SUB_BLOCK_TYPES ] ) ) < 0 ) return ret ;\n if ( ( ret = read_colors ( gb , & c -> bundle [ BINK_SRC_COLORS ] , c ) ) < 0 ) return ret ;\n if ( ( ret = read_patterns ( c -> avctx , gb , & c -> bundle [ BINK_SRC_PATTERN ] ) ) < 0 ) return ret ;\n if ( ( ret = read_motion_values ( c -> avctx , gb , & c -> bundle [ BINK_SRC_X_OFF ] ) ) < 0 ) return ret ;\n if ( ( ret = read_motion_values ( c -> avctx , gb , & c -> bundle [ BINK_SRC_Y_OFF ] ) ) < 0 ) return ret ;\n if ( ( ret = read_dcs ( c -> avctx , gb , & c -> bundle [ BINK_SRC_INTRA_DC ] , DC_START_BITS , 0 ) ) < 0 ) return ret ;\n if ( ( ret = read_dcs ( c -> avctx , gb , & c -> bundle [ BINK_SRC_INTER_DC ] , DC_START_BITS , 1 ) ) < 0 ) return ret ;\n if ( ( ret = read_runs ( c -> avctx , gb , & c -> bundle [ BINK_SRC_RUN ] ) ) < 0 ) return ret ;\n if ( by == bh ) break ;\n dst = c -> pic -> data [ plane_idx ] + 8 * by * stride ;\n prev = ( c -> last -> data [ plane_idx ] ? c -> last -> data [ plane_idx ] : c -> pic -> data [ plane_idx ] ) + 8 * by * stride ;\n for ( bx = 0 ;\n bx < bw ;\n bx ++ , dst += 8 , prev += 8 ) {\n blk = get_value ( c , BINK_SRC_BLOCK_TYPES ) ;\n if ( ( by & 1 ) && blk == SCALED_BLOCK ) {\n bx ++ ;\n dst += 8 ;\n prev += 8 ;\n continue ;\n }\n switch ( blk ) {\n case SKIP_BLOCK : c -> dsp . put_pixels_tab [ 1 ] [ 0 ] ( dst , prev , stride , 8 ) ;\n break ;\n case SCALED_BLOCK : blk = get_value ( c , BINK_SRC_SUB_BLOCK_TYPES ) ;\n switch ( blk ) {\n case RUN_BLOCK : scan = bink_patterns [ get_bits ( gb , 4 ) ] ;\n i = 0 ;\n do {\n int run = get_value ( c , BINK_SRC_RUN ) + 1 ;\n i += run ;\n if ( i > 64 ) {\n av_log ( c -> avctx , AV_LOG_ERROR , \"Run went out of bounds\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( get_bits1 ( gb ) ) {\n v = get_value ( c , BINK_SRC_COLORS ) ;\n for ( j = 0 ;\n j < run ;\n j ++ ) ublock [ * scan ++ ] = v ;\n }\n else {\n for ( j = 0 ;\n j < run ;\n j ++ ) ublock [ * scan ++ ] = get_value ( c , BINK_SRC_COLORS ) ;\n }\n }\n while ( i < 63 ) ;\n if ( i == 63 ) ublock [ * scan ++ ] = get_value ( c , BINK_SRC_COLORS ) ;\n break ;\n case INTRA_BLOCK : memset ( dctblock , 0 , sizeof ( * dctblock ) * 64 ) ;\n dctblock [ 0 ] = get_value ( c , BINK_SRC_INTRA_DC ) ;\n read_dct_coeffs ( gb , dctblock , bink_scan , bink_intra_quant , - 1 ) ;\n c -> bdsp . idct_put ( ublock , 8 , dctblock ) ;\n break ;\n case FILL_BLOCK : v = get_value ( c , BINK_SRC_COLORS ) ;\n c -> dsp . fill_block_tab [ 0 ] ( dst , v , stride , 16 ) ;\n break ;\n case PATTERN_BLOCK : for ( i = 0 ;\n i < 2 ;\n i ++ ) col [ i ] = get_value ( c , BINK_SRC_COLORS ) ;\n for ( j = 0 ;\n j < 8 ;\n j ++ ) {\n v = get_value ( c , BINK_SRC_PATTERN ) ;\n for ( i = 0 ;\n i < 8 ;\n i ++ , v >>= 1 ) ublock [ i + j * 8 ] = col [ v & 1 ] ;\n }\n break ;\n case RAW_BLOCK : for ( j = 0 ;\n j < 8 ;\n j ++ ) for ( i = 0 ;\n i < 8 ;\n i ++ ) ublock [ i + j * 8 ] = get_value ( c , BINK_SRC_COLORS ) ;\n break ;\n default : av_log ( c -> avctx , AV_LOG_ERROR , \"Incorrect 16x16 block type %d\\n\" , blk ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( blk != FILL_BLOCK ) c -> bdsp . scale_block ( ublock , dst , stride ) ;\n bx ++ ;\n dst += 8 ;\n prev += 8 ;\n break ;\n case MOTION_BLOCK : xoff = get_value ( c , BINK_SRC_X_OFF ) ;\n yoff = get_value ( c , BINK_SRC_Y_OFF ) ;\n ref = prev + xoff + yoff * stride ;\n if ( ref < ref_start || ref > ref_end ) {\n av_log ( c -> avctx , AV_LOG_ERROR , \"Copy out of bounds @%d, %d\\n\" , bx * 8 + xoff , by * 8 + yoff ) ;\n return AVERROR_INVALIDDATA ;\n }\n c -> dsp . put_pixels_tab [ 1 ] [ 0 ] ( dst , ref , stride , 8 ) ;\n break ;\n case RUN_BLOCK : scan = bink_patterns [ get_bits ( gb , 4 ) ] ;\n i = 0 ;\n do {\n int run = get_value ( c , BINK_SRC_RUN ) + 1 ;\n i += run ;\n if ( i > 64 ) {\n av_log ( c -> avctx , AV_LOG_ERROR , \"Run went out of bounds\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( get_bits1 ( gb ) ) {\n v = get_value ( c , BINK_SRC_COLORS ) ;\n for ( j = 0 ;\n j < run ;\n j ++ ) dst [ coordmap [ * scan ++ ] ] = v ;\n }\n else {\n for ( j = 0 ;\n j < run ;\n j ++ ) dst [ coordmap [ * scan ++ ] ] = get_value ( c , BINK_SRC_COLORS ) ;\n }\n }\n while ( i < 63 ) ;\n if ( i == 63 ) dst [ coordmap [ * scan ++ ] ] = get_value ( c , BINK_SRC_COLORS ) ;\n break ;\n case RESIDUE_BLOCK : xoff = get_value ( c , BINK_SRC_X_OFF ) ;\n yoff = get_value ( c , BINK_SRC_Y_OFF ) ;\n ref = prev + xoff + yoff * stride ;\n if ( ref < ref_start || ref > ref_end ) {\n av_log ( c -> avctx , AV_LOG_ERROR , \"Copy out of bounds @%d, %d\\n\" , bx * 8 + xoff , by * 8 + yoff ) ;\n return AVERROR_INVALIDDATA ;\n }\n c -> dsp . put_pixels_tab [ 1 ] [ 0 ] ( dst , ref , stride , 8 ) ;\n c -> dsp . clear_block ( block ) ;\n v = get_bits ( gb , 7 ) ;\n read_residue ( gb , block , v ) ;\n c -> dsp . add_pixels8 ( dst , block , stride ) ;\n break ;\n case INTRA_BLOCK : memset ( dctblock , 0 , sizeof ( * dctblock ) * 64 ) ;\n dctblock [ 0 ] = get_value ( c , BINK_SRC_INTRA_DC ) ;\n read_dct_coeffs ( gb , dctblock , bink_scan , bink_intra_quant , - 1 ) ;\n c -> bdsp . idct_put ( dst , stride , dctblock ) ;\n break ;\n case FILL_BLOCK : v = get_value ( c , BINK_SRC_COLORS ) ;\n c -> dsp . fill_block_tab [ 1 ] ( dst , v , stride , 8 ) ;\n break ;\n case INTER_BLOCK : xoff = get_value ( c , BINK_SRC_X_OFF ) ;\n yoff = get_value ( c , BINK_SRC_Y_OFF ) ;\n ref = prev + xoff + yoff * stride ;\n c -> dsp . put_pixels_tab [ 1 ] [ 0 ] ( dst , ref , stride , 8 ) ;\n memset ( dctblock , 0 , sizeof ( * dctblock ) * 64 ) ;\n dctblock [ 0 ] = get_value ( c , BINK_SRC_INTER_DC ) ;\n read_dct_coeffs ( gb , dctblock , bink_scan , bink_inter_quant , - 1 ) ;\n c -> bdsp . idct_add ( dst , stride , dctblock ) ;\n break ;\n case PATTERN_BLOCK : for ( i = 0 ;\n i < 2 ;\n i ++ ) col [ i ] = get_value ( c , BINK_SRC_COLORS ) ;\n for ( i = 0 ;\n i < 8 ;\n i ++ ) {\n v = get_value ( c , BINK_SRC_PATTERN ) ;\n for ( j = 0 ;\n j < 8 ;\n j ++ , v >>= 1 ) dst [ i * stride + j ] = col [ v & 1 ] ;\n }\n break ;\n case RAW_BLOCK : for ( i = 0 ;\n i < 8 ;\n i ++ ) memcpy ( dst + i * stride , c -> bundle [ BINK_SRC_COLORS ] . cur_ptr + i * 8 , 8 ) ;\n c -> bundle [ BINK_SRC_COLORS ] . cur_ptr += 64 ;\n break ;\n default : av_log ( c -> avctx , AV_LOG_ERROR , \"Unknown block type %d\\n\" , blk ) ;\n return AVERROR_INVALIDDATA ;\n }\n }\n }\n if ( get_bits_count ( gb ) & 0x1F ) / ext plane data starts at 32 - bit boundary skip_bits_long ( gb , 32 - ( get_bits_count ( gb ) & 0x1F ) ) ;\n return 0 ;\n }", "idx": 445}
{"hash": -3889154245145551951, "project": "debian", "size": 6, "label": 0, "functionSource": "static void option_date_format ( const char * fmt ) {\n if ( ! strcmp ( fmt , \"raw\" ) ) whenspec = WHENSPEC_RAW ;\n else if ( ! strcmp ( fmt , \"rfc2822\" ) ) whenspec = WHENSPEC_RFC2822 ;\n else if ( ! strcmp ( fmt , \"now\" ) ) whenspec = WHENSPEC_NOW ;\n else die ( \"unknown --date-format argument %s\" , fmt ) ;\n }", "idx": 446}
{"hash": 6632536031698733342, "project": "debian", "size": 24, "label": 0, "functionSource": "static const char * flat_escape_value_str ( AVBPrint * dst , const char * src ) {\n const char * p ;\n for ( p = src ;\n * p ;\n p ++ ) {\n switch ( * p ) {\n case '\\n' : av_bprintf ( dst , \"%s\" , \"\\\\n\" ) ;\n break ;\n case '\\r' : av_bprintf ( dst , \"%s\" , \"\\\\r\" ) ;\n break ;\n case '\\\\' : av_bprintf ( dst , \"%s\" , \"\\\\\\\\\" ) ;\n break ;\n case '\"' : av_bprintf ( dst , \"%s\" , \"\\\\\\\"\" ) ;\n break ;\n case '`' : av_bprintf ( dst , \"%s\" , \"\\\\`\" ) ;\n break ;\n case '$' : av_bprintf ( dst , \"%s\" , \"\\\\$\" ) ;\n break ;\n default : av_bprint_chars ( dst , * p , 1 ) ;\n break ;\n }\n }\n return dst -> str ;\n }", "idx": 447}
{"hash": 3584320764213684062, "project": "debian", "size": 19, "label": 0, "functionSource": "static int parse_CRowVariantArrayInfo ( tvbuff_t * tvb , int offset , proto_tree * tree , gboolean is_64bit , struct CRowVariant * variant ) {\n if ( is_64bit ) {\n variant -> content . array_vector . i64 . count = tvb_get_letoh64 ( tvb , offset ) ;\n proto_tree_add_uint64 ( tree , hf_mswsp_crowvariantinfo_count64 , tvb , offset , 8 , variant -> content . array_vector . i64 . count ) ;\n offset += 8 ;\n variant -> content . array_vector . i64 . array_address = tvb_get_letoh64 ( tvb , offset ) ;\n proto_tree_add_uint64 ( tree , hf_mswsp_arrayvector_address64 , tvb , offset , 8 , variant -> content . array_vector . i64 . array_address ) ;\n offset += 8 ;\n }\n else {\n variant -> content . array_vector . i32 . count = tvb_get_letohl ( tvb , offset ) ;\n proto_tree_add_uint ( tree , hf_mswsp_crowvariantinfo_count32 , tvb , offset , 4 , variant -> content . array_vector . i32 . count ) ;\n offset += 4 ;\n variant -> content . array_vector . i32 . array_address = tvb_get_letohl ( tvb , offset ) ;\n proto_tree_add_uint ( tree , hf_mswsp_arrayvector_address32 , tvb , offset , 4 , variant -> content . array_vector . i32 . array_address ) ;\n offset += 4 ;\n }\n return offset ;\n }", "idx": 448}
{"hash": 3944119518966250431, "project": "debian", "size": 11, "label": 0, "functionSource": "enum nss_status _nss_nis_setaliasent ( void ) {\n __libc_lock_lock ( lock ) ;\n new_start = 1 ;\n if ( oldkey != NULL ) {\n free ( oldkey ) ;\n oldkey = NULL ;\n oldkeylen = 0 ;\n }\n __libc_lock_unlock ( lock ) ;\n return NSS_STATUS_SUCCESS ;\n }", "idx": 449}
{"hash": 155037296040076635, "project": "debian", "size": 241, "label": 0, "functionSource": "static enum nss_status getanswer_r ( const querybuf * answer , int anslen , const char * qname , int qtype , struct hostent * result , char * buffer , size_t buflen , int * errnop , int * h_errnop , int map , int32_t * ttlp , char * * canonp ) {\n struct host_data {\n char * aliases [ MAX_NR_ALIASES ] ;\n unsigned char host_addr [ 16 ] ;\n char * h_addr_ptrs [ 0 ] ;\n }\n * host_data ;\n int linebuflen ;\n const HEADER * hp ;\n const u_char * end_of_message , * cp ;\n int n , ancount , qdcount ;\n int haveanswer , had_error ;\n char * bp , * * ap , * * hap ;\n char tbuf [ MAXDNAME ] ;\n const char * tname ;\n int ( * name_ok ) ( const char * ) ;\n u_char packtmp [ NS_MAXCDNAME ] ;\n int have_to_map = 0 ;\n uintptr_t pad = - ( uintptr_t ) buffer % __alignof__ ( struct host_data ) ;\n buffer += pad ;\n buflen = buflen > pad ? buflen - pad : 0 ;\n if ( __glibc_unlikely ( buflen < sizeof ( struct host_data ) ) ) {\n too_small : * errnop = ERANGE ;\n * h_errnop = NETDB_INTERNAL ;\n return NSS_STATUS_TRYAGAIN ;\n }\n host_data = ( struct host_data * ) buffer ;\n linebuflen = buflen - sizeof ( struct host_data ) ;\n if ( buflen - sizeof ( struct host_data ) != linebuflen ) linebuflen = INT_MAX ;\n tname = qname ;\n result -> h_name = NULL ;\n end_of_message = answer -> buf + anslen ;\n switch ( qtype ) {\n case T_A : case T_AAAA : name_ok = res_hnok ;\n break ;\n case T_PTR : name_ok = res_dnok ;\n break ;\n default : * errnop = ENOENT ;\n return NSS_STATUS_UNAVAIL ;\n }\n hp = & answer -> hdr ;\n ancount = ntohs ( hp -> ancount ) ;\n qdcount = ntohs ( hp -> qdcount ) ;\n cp = answer -> buf + HFIXEDSZ ;\n if ( __builtin_expect ( qdcount , 1 ) != 1 ) {\n * h_errnop = NO_RECOVERY ;\n return NSS_STATUS_UNAVAIL ;\n }\n if ( sizeof ( struct host_data ) + ( ancount + 1 ) * sizeof ( char * ) >= buflen ) goto too_small ;\n bp = ( char * ) & host_data -> h_addr_ptrs [ ancount + 1 ] ;\n linebuflen -= ( ancount + 1 ) * sizeof ( char * ) ;\n n = __ns_name_unpack ( answer -> buf , end_of_message , cp , packtmp , sizeof packtmp ) ;\n if ( n != - 1 && __ns_name_ntop ( packtmp , bp , linebuflen ) == - 1 ) {\n if ( __builtin_expect ( errno , 0 ) == EMSGSIZE ) goto too_small ;\n n = - 1 ;\n }\n if ( n > 0 && bp [ 0 ] == '.' ) bp [ 0 ] = '\\0' ;\n if ( __builtin_expect ( n < 0 || ( ( * name_ok ) ( bp ) == 0 && ( errno = EBADMSG ) ) , 0 ) ) {\n * errnop = errno ;\n * h_errnop = NO_RECOVERY ;\n return NSS_STATUS_UNAVAIL ;\n }\n cp += n + QFIXEDSZ ;\n if ( qtype == T_A || qtype == T_AAAA ) {\n n = strlen ( bp ) + 1 ;\n if ( n >= MAXHOSTNAMELEN ) {\n * h_errnop = NO_RECOVERY ;\n * errnop = ENOENT ;\n return NSS_STATUS_TRYAGAIN ;\n }\n result -> h_name = bp ;\n bp += n ;\n linebuflen -= n ;\n if ( linebuflen < 0 ) goto too_small ;\n qname = result -> h_name ;\n }\n ap = host_data -> aliases ;\n * ap = NULL ;\n result -> h_aliases = host_data -> aliases ;\n hap = host_data -> h_addr_ptrs ;\n * hap = NULL ;\n result -> h_addr_list = host_data -> h_addr_ptrs ;\n haveanswer = 0 ;\n had_error = 0 ;\n while ( ancount -- > 0 && cp < end_of_message && had_error == 0 ) {\n int type , class ;\n n = __ns_name_unpack ( answer -> buf , end_of_message , cp , packtmp , sizeof packtmp ) ;\n if ( n != - 1 && __ns_name_ntop ( packtmp , bp , linebuflen ) == - 1 ) {\n if ( __builtin_expect ( errno , 0 ) == EMSGSIZE ) goto too_small ;\n n = - 1 ;\n }\n if ( __glibc_unlikely ( n < 0 || ( * name_ok ) ( bp ) == 0 ) ) {\n ++ had_error ;\n continue ;\n }\n cp += n ;\n if ( __glibc_unlikely ( cp + 10 > end_of_message ) ) {\n ++ had_error ;\n continue ;\n }\n type = __ns_get16 ( cp ) ;\n cp += INT16SZ ;\n class = __ns_get16 ( cp ) ;\n cp += INT16SZ ;\n int32_t ttl = __ns_get32 ( cp ) ;\n cp += INT32SZ ;\n n = __ns_get16 ( cp ) ;\n cp += INT16SZ ;\n if ( __glibc_unlikely ( class != C_IN ) ) {\n cp += n ;\n continue ;\n }\n if ( ( qtype == T_A || qtype == T_AAAA ) && type == T_CNAME ) {\n if ( ttlp != NULL && ttl < * ttlp ) * ttlp = ttl ;\n if ( ap >= & host_data -> aliases [ MAX_NR_ALIASES - 1 ] ) continue ;\n n = dn_expand ( answer -> buf , end_of_message , cp , tbuf , sizeof tbuf ) ;\n if ( __glibc_unlikely ( n < 0 || ( * name_ok ) ( tbuf ) == 0 ) ) {\n ++ had_error ;\n continue ;\n }\n cp += n ;\n * ap ++ = bp ;\n n = strlen ( bp ) + 1 ;\n if ( __builtin_expect ( n , 0 ) >= MAXHOSTNAMELEN ) {\n ++ had_error ;\n continue ;\n }\n bp += n ;\n linebuflen -= n ;\n n = strlen ( tbuf ) + 1 ;\n if ( __glibc_unlikely ( n > linebuflen ) ) goto too_small ;\n if ( __builtin_expect ( n , 0 ) >= MAXHOSTNAMELEN ) {\n ++ had_error ;\n continue ;\n }\n result -> h_name = bp ;\n bp = __mempcpy ( bp , tbuf , n ) ;\n linebuflen -= n ;\n continue ;\n }\n if ( qtype == T_PTR && type == T_CNAME ) {\n n = dn_expand ( answer -> buf , end_of_message , cp , tbuf , sizeof tbuf ) ;\n if ( __glibc_unlikely ( n < 0 || res_dnok ( tbuf ) == 0 ) ) {\n ++ had_error ;\n continue ;\n }\n cp += n ;\n n = strlen ( tbuf ) + 1 ;\n if ( __glibc_unlikely ( n > linebuflen ) ) goto too_small ;\n if ( __builtin_expect ( n , 0 ) >= MAXHOSTNAMELEN ) {\n ++ had_error ;\n continue ;\n }\n tname = bp ;\n bp = __mempcpy ( bp , tbuf , n ) ;\n linebuflen -= n ;\n continue ;\n }\n if ( type == T_A && qtype == T_AAAA && map ) have_to_map = 1 ;\n else if ( __glibc_unlikely ( type != qtype ) ) {\n if ( ( _res . options & RES_USE_DNSSEC ) == 0 ) syslog ( LOG_NOTICE | LOG_AUTH , \"gethostby*.getanswer: asked for \\\"%s %s %s\\\", \" \"got type \\\"%s\\\"\" , qname , p_class ( C_IN ) , p_type ( qtype ) , p_type ( type ) ) ;\n cp += n ;\n continue ;\n }\n switch ( type ) {\n case T_PTR : if ( __glibc_unlikely ( strcasecmp ( tname , bp ) != 0 ) ) {\n syslog ( LOG_NOTICE | LOG_AUTH , AskedForGot , qname , bp ) ;\n cp += n ;\n continue ;\n }\n n = __ns_name_unpack ( answer -> buf , end_of_message , cp , packtmp , sizeof packtmp ) ;\n if ( n != - 1 && __ns_name_ntop ( packtmp , bp , linebuflen ) == - 1 ) {\n if ( __builtin_expect ( errno , 0 ) == EMSGSIZE ) goto too_small ;\n n = - 1 ;\n }\n if ( __glibc_unlikely ( n < 0 || res_hnok ( bp ) == 0 ) ) {\n ++ had_error ;\n break ;\n }\n result -> h_name = bp ;\n if ( have_to_map ) {\n n = strlen ( bp ) + 1 ;\n if ( __glibc_unlikely ( n >= MAXHOSTNAMELEN ) ) {\n ++ had_error ;\n break ;\n }\n bp += n ;\n linebuflen -= n ;\n if ( map_v4v6_hostent ( result , & bp , & linebuflen ) ) goto too_small ;\n }\n * h_errnop = NETDB_SUCCESS ;\n return NSS_STATUS_SUCCESS ;\n case T_A : case T_AAAA : if ( __builtin_expect ( strcasecmp ( result -> h_name , bp ) , 0 ) != 0 ) {\n syslog ( LOG_NOTICE | LOG_AUTH , AskedForGot , result -> h_name , bp ) ;\n cp += n ;\n continue ;\n }\n if ( n != result -> h_length ) {\n cp += n ;\n continue ;\n }\n if ( ! haveanswer ) {\n int nn ;\n if ( ttlp != NULL && ttl < * ttlp ) * ttlp = ttl ;\n if ( canonp != NULL ) * canonp = bp ;\n result -> h_name = bp ;\n nn = strlen ( bp ) + 1 ;\n bp += nn ;\n linebuflen -= nn ;\n }\n linebuflen -= sizeof ( align ) - ( ( u_long ) bp % sizeof ( align ) ) ;\n bp += sizeof ( align ) - ( ( u_long ) bp % sizeof ( align ) ) ;\n if ( __glibc_unlikely ( n > linebuflen ) ) goto too_small ;\n bp = __mempcpy ( * hap ++ = bp , cp , n ) ;\n cp += n ;\n linebuflen -= n ;\n break ;\n default : abort ( ) ;\n }\n if ( had_error == 0 ) ++ haveanswer ;\n }\n if ( haveanswer > 0 ) {\n * ap = NULL ;\n * hap = NULL ;\n # if defined RESOLVSORT if ( _res . nsort && haveanswer > 1 && qtype == T_A ) addrsort ( host_data -> h_addr_ptrs , haveanswer ) ;\n # endif if ( result -> h_name == NULL ) {\n n = strlen ( qname ) + 1 ;\n if ( n > linebuflen ) goto too_small ;\n if ( n >= MAXHOSTNAMELEN ) goto no_recovery ;\n result -> h_name = bp ;\n bp = __mempcpy ( bp , qname , n ) ;\n linebuflen -= n ;\n }\n if ( have_to_map ) if ( map_v4v6_hostent ( result , & bp , & linebuflen ) ) goto too_small ;\n * h_errnop = NETDB_SUCCESS ;\n return NSS_STATUS_SUCCESS ;\n }\n no_recovery : * h_errnop = NO_RECOVERY ;\n * errnop = ENOENT ;\n return ( ( qtype == T_A || qtype == T_AAAA ) && ap != host_data -> aliases ? NSS_STATUS_NOTFOUND : NSS_STATUS_TRYAGAIN ) ;\n }", "idx": 450}
{"hash": 2772622454795674000, "project": "debian", "size": 16, "label": 0, "functionSource": "void ff_h263_decode_init_vlc ( void ) {\n static int done = 0 ;\n if ( ! done ) {\n done = 1 ;\n INIT_VLC_STATIC ( & ff_h263_intra_MCBPC_vlc , INTRA_MCBPC_VLC_BITS , 9 , ff_h263_intra_MCBPC_bits , 1 , 1 , ff_h263_intra_MCBPC_code , 1 , 1 , 72 ) ;\n INIT_VLC_STATIC ( & ff_h263_inter_MCBPC_vlc , INTER_MCBPC_VLC_BITS , 28 , ff_h263_inter_MCBPC_bits , 1 , 1 , ff_h263_inter_MCBPC_code , 1 , 1 , 198 ) ;\n INIT_VLC_STATIC ( & ff_h263_cbpy_vlc , CBPY_VLC_BITS , 16 , & ff_h263_cbpy_tab [ 0 ] [ 1 ] , 2 , 1 , & ff_h263_cbpy_tab [ 0 ] [ 0 ] , 2 , 1 , 64 ) ;\n INIT_VLC_STATIC ( & mv_vlc , MV_VLC_BITS , 33 , & ff_mvtab [ 0 ] [ 1 ] , 2 , 1 , & ff_mvtab [ 0 ] [ 0 ] , 2 , 1 , 538 ) ;\n ff_init_rl ( & ff_h263_rl_inter , ff_h263_static_rl_table_store [ 0 ] ) ;\n ff_init_rl ( & ff_rl_intra_aic , ff_h263_static_rl_table_store [ 1 ] ) ;\n INIT_VLC_RL ( ff_h263_rl_inter , 554 ) ;\n INIT_VLC_RL ( ff_rl_intra_aic , 554 ) ;\n INIT_VLC_STATIC ( & h263_mbtype_b_vlc , H263_MBTYPE_B_VLC_BITS , 15 , & ff_h263_mbtype_b_tab [ 0 ] [ 1 ] , 2 , 1 , & ff_h263_mbtype_b_tab [ 0 ] [ 0 ] , 2 , 1 , 80 ) ;\n INIT_VLC_STATIC ( & cbpc_b_vlc , CBPC_B_VLC_BITS , 4 , & ff_cbpc_b_tab [ 0 ] [ 1 ] , 2 , 1 , & ff_cbpc_b_tab [ 0 ] [ 0 ] , 2 , 1 , 8 ) ;\n }\n }", "idx": 451}
{"hash": -8933711118846965366, "project": "debian", "size": 22, "label": 0, "functionSource": "static void cirrus_reset ( void * opaque ) {\n CirrusVGAState * s = opaque ;\n vga_common_reset ( & s -> vga ) ;\n unmap_linear_vram ( s ) ;\n s -> vga . sr [ 0x06 ] = 0x0f ;\n if ( s -> device_id == CIRRUS_ID_CLGD5446 ) {\n s -> vga . sr [ 0x1F ] = 0x2d ;\n s -> vga . gr [ 0x18 ] = 0x0f ;\n s -> vga . sr [ 0x0f ] = 0x98 ;\n s -> vga . sr [ 0x17 ] = 0x20 ;\n s -> vga . sr [ 0x15 ] = 0x04 ;\n }\n else {\n s -> vga . sr [ 0x1F ] = 0x22 ;\n s -> vga . sr [ 0x0F ] = CIRRUS_MEMSIZE_2M ;\n s -> vga . sr [ 0x17 ] = s -> bustype ;\n s -> vga . sr [ 0x15 ] = 0x03 ;\n }\n s -> vga . cr [ 0x27 ] = s -> device_id ;\n s -> cirrus_hidden_dac_lockindex = 5 ;\n s -> cirrus_hidden_dac_data = 0 ;\n }", "idx": 452}
{"hash": -1658505547857059267, "project": "debian", "size": 19, "label": 1, "functionSource": "static int build_def_list ( Picture * def , Picture * * in , int len , int is_long , int sel ) {\n int i [ 2 ] = {\n 0 }\n ;\n int index = 0 ;\n while ( i [ 0 ] < len || i [ 1 ] < len ) {\n while ( i [ 0 ] < len && ! ( in [ i [ 0 ] ] && ( in [ i [ 0 ] ] -> f . reference & sel ) ) ) i [ 0 ] ++ ;\n while ( i [ 1 ] < len && ! ( in [ i [ 1 ] ] && ( in [ i [ 1 ] ] -> f . reference & ( sel ^ 3 ) ) ) ) i [ 1 ] ++ ;\n if ( i [ 0 ] < len ) {\n in [ i [ 0 ] ] -> pic_id = is_long ? i [ 0 ] : in [ i [ 0 ] ] -> frame_num ;\n split_field_copy ( & def [ index ++ ] , in [ i [ 0 ] ++ ] , sel , 1 ) ;\n }\n if ( i [ 1 ] < len ) {\n in [ i [ 1 ] ] -> pic_id = is_long ? i [ 1 ] : in [ i [ 1 ] ] -> frame_num ;\n split_field_copy ( & def [ index ++ ] , in [ i [ 1 ] ++ ] , sel ^ 3 , 0 ) ;\n }\n }\n return index ;\n }", "idx": 453}
{"hash": -1315695702746584250, "project": "debian", "size": 5, "label": 0, "functionSource": "GPtrArray * proto_get_finfo_ptr_array ( const proto_tree * tree , const int id ) {\n if ( ! tree ) return NULL ;\n if ( PTREE_DATA ( tree ) -> interesting_hfids != NULL ) return ( GPtrArray * ) g_hash_table_lookup ( PTREE_DATA ( tree ) -> interesting_hfids , GINT_TO_POINTER ( id ) ) ;\n else return NULL ;\n }", "idx": 454}
{"hash": 2419147764757351618, "project": "debian", "size": 6, "label": 0, "functionSource": "static void s390_virtio_bus_register_withprop ( VirtIOS390DeviceInfo * info ) {\n info -> qdev . init = s390_virtio_busdev_init ;\n info -> qdev . bus_info = & s390_virtio_bus_info ;\n assert ( info -> qdev . size >= sizeof ( VirtIOS390Device ) ) ;\n qdev_register ( & info -> qdev ) ;\n }", "idx": 455}
{"hash": 1760449185745615462, "project": "debian", "size": 6, "label": 0, "functionSource": "int TSHttpTxnLookingUpTypeGet ( TSHttpTxn txnp ) {\n sdk_assert ( sdk_sanity_check_txn ( txnp ) == TS_SUCCESS ) ;\n HttpSM * sm = ( HttpSM * ) txnp ;\n HttpTransact : : State * s = & ( sm -> t_state ) ;\n return ( int ) ( s -> current . request_to ) ;\n }", "idx": 456}
{"hash": 4976989049001279223, "project": "debian", "size": 25, "label": 0, "functionSource": "int32_t http_parse_version ( const char * start , const char * end ) {\n int maj ;\n int min ;\n if ( ( end - start ) < 8 ) {\n return HTTP_VERSION ( 0 , 9 ) ;\n }\n if ( ( ( start [ 0 ] == 'H' ) || ( start [ 0 ] == 'h' ) ) && ( ( start [ 1 ] == 'T' ) || ( start [ 1 ] == 't' ) ) && ( ( start [ 2 ] == 'T' ) || ( start [ 2 ] == 't' ) ) && ( ( start [ 3 ] == 'P' ) || ( start [ 3 ] == 'p' ) ) && ( start [ 4 ] == '/' ) ) {\n start += 5 ;\n maj = 0 ;\n min = 0 ;\n while ( ( start != end ) && ParseRules : : is_digit ( * start ) ) {\n maj = ( maj * 10 ) + ( * start - '0' ) ;\n start += 1 ;\n }\n if ( * start == '.' ) {\n start += 1 ;\n }\n while ( ( start != end ) && ParseRules : : is_digit ( * start ) ) {\n min = ( min * 10 ) + ( * start - '0' ) ;\n start += 1 ;\n }\n return HTTP_VERSION ( maj , min ) ;\n }\n return HTTP_VERSION ( 0 , 9 ) ;\n }", "idx": 457}
{"hash": -2661809302248698892, "project": "debian", "size": 45, "label": 0, "functionSource": "static int decode_i_frame ( FourXContext * f , AVFrame * frame , const uint8_t * buf , int length ) {\n int x , y , ret ;\n const int width = f -> avctx -> width ;\n const int height = f -> avctx -> height ;\n const unsigned int bitstream_size = AV_RL32 ( buf ) ;\n int token_count av_unused ;\n unsigned int prestream_size ;\n const uint8_t * prestream ;\n if ( length < bitstream_size + 12 ) {\n av_log ( f -> avctx , AV_LOG_ERROR , \"packet size too small\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n token_count = AV_RL32 ( buf + bitstream_size + 8 ) ;\n prestream_size = 4 * AV_RL32 ( buf + bitstream_size + 4 ) ;\n prestream = buf + bitstream_size + 12 ;\n if ( prestream_size + bitstream_size + 12 != length || bitstream_size > ( 1 << 26 ) || prestream_size > ( 1 << 26 ) ) {\n av_log ( f -> avctx , AV_LOG_ERROR , \"size mismatch %d %d %d\\n\" , prestream_size , bitstream_size , length ) ;\n return AVERROR_INVALIDDATA ;\n }\n prestream = read_huffman_tables ( f , prestream ) ;\n if ( ! prestream ) {\n av_log ( f -> avctx , AV_LOG_ERROR , \"Error reading Huffman tables.\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n init_get_bits ( & f -> gb , buf + 4 , 8 * bitstream_size ) ;\n prestream_size = length + buf - prestream ;\n av_fast_malloc ( & f -> bitstream_buffer , & f -> bitstream_buffer_size , prestream_size + FF_INPUT_BUFFER_PADDING_SIZE ) ;\n if ( ! f -> bitstream_buffer ) return AVERROR ( ENOMEM ) ;\n f -> dsp . bswap_buf ( f -> bitstream_buffer , ( const uint32_t * ) prestream , prestream_size / 4 ) ;\n memset ( ( uint8_t * ) f -> bitstream_buffer + prestream_size , 0 , FF_INPUT_BUFFER_PADDING_SIZE ) ;\n init_get_bits ( & f -> pre_gb , f -> bitstream_buffer , 8 * prestream_size ) ;\n f -> last_dc = 0 * 128 * 8 * 8 ;\n for ( y = 0 ;\n y < height ;\n y += 16 ) {\n for ( x = 0 ;\n x < width ;\n x += 16 ) {\n if ( ( ret = decode_i_mb ( f ) ) < 0 ) return ret ;\n idct_put ( f , frame , x , y ) ;\n }\n }\n if ( get_vlc2 ( & f -> pre_gb , f -> pre_vlc . table , ACDC_VLC_BITS , 3 ) != 256 ) av_log ( f -> avctx , AV_LOG_ERROR , \"end mismatch\\n\" ) ;\n return 0 ;\n }", "idx": 458}
{"hash": -2242211406757466627, "project": "debian", "size": 3, "label": 0, "functionSource": "static void alljoyn_typeid ( gchar * result , guint32 type ) {\n g_snprintf ( result , ITEM_LABEL_LENGTH , \"'%c' => \" , type ) ;\n }", "idx": 459}
{"hash": -755883256379441954, "project": "chrome", "size": 31, "label": 0, "functionSource": "void vp9_init_intra_predictors ( ) {\n # define INIT_ALL_SIZES ( p , type ) p [ TX_4X4 ] = vp9_ ## type ## _predictor_4x4 ;\n p [ TX_8X8 ] = vp9_ ## type ## _predictor_8x8 ;\n p [ TX_16X16 ] = vp9_ ## type ## _predictor_16x16 ;\n p [ TX_32X32 ] = vp9_ ## type ## _predictor_32x32 INIT_ALL_SIZES ( pred [ V_PRED ] , v ) ;\n INIT_ALL_SIZES ( pred [ H_PRED ] , h ) ;\n INIT_ALL_SIZES ( pred [ D207_PRED ] , d207 ) ;\n INIT_ALL_SIZES ( pred [ D45_PRED ] , d45 ) ;\n INIT_ALL_SIZES ( pred [ D63_PRED ] , d63 ) ;\n INIT_ALL_SIZES ( pred [ D117_PRED ] , d117 ) ;\n INIT_ALL_SIZES ( pred [ D135_PRED ] , d135 ) ;\n INIT_ALL_SIZES ( pred [ D153_PRED ] , d153 ) ;\n INIT_ALL_SIZES ( pred [ TM_PRED ] , tm ) ;\n INIT_ALL_SIZES ( dc_pred [ 0 ] [ 0 ] , dc_128 ) ;\n INIT_ALL_SIZES ( dc_pred [ 0 ] [ 1 ] , dc_top ) ;\n INIT_ALL_SIZES ( dc_pred [ 1 ] [ 0 ] , dc_left ) ;\n INIT_ALL_SIZES ( dc_pred [ 1 ] [ 1 ] , dc ) ;\n # if CONFIG_VP9_HIGHBITDEPTH INIT_ALL_SIZES ( pred_high [ V_PRED ] , high_v ) ;\n INIT_ALL_SIZES ( pred_high [ H_PRED ] , high_h ) ;\n INIT_ALL_SIZES ( pred_high [ D207_PRED ] , high_d207 ) ;\n INIT_ALL_SIZES ( pred_high [ D45_PRED ] , high_d45 ) ;\n INIT_ALL_SIZES ( pred_high [ D63_PRED ] , high_d63 ) ;\n INIT_ALL_SIZES ( pred_high [ D117_PRED ] , high_d117 ) ;\n INIT_ALL_SIZES ( pred_high [ D135_PRED ] , high_d135 ) ;\n INIT_ALL_SIZES ( pred_high [ D153_PRED ] , high_d153 ) ;\n INIT_ALL_SIZES ( pred_high [ TM_PRED ] , high_tm ) ;\n INIT_ALL_SIZES ( dc_pred_high [ 0 ] [ 0 ] , high_dc_128 ) ;\n INIT_ALL_SIZES ( dc_pred_high [ 0 ] [ 1 ] , high_dc_top ) ;\n INIT_ALL_SIZES ( dc_pred_high [ 1 ] [ 0 ] , high_dc_left ) ;\n INIT_ALL_SIZES ( dc_pred_high [ 1 ] [ 1 ] , high_dc ) ;\n # endif # undef intra_pred_allsizes }", "idx": 460}
{"hash": -7076754245473579218, "project": "chrome", "size": 4, "label": 0, "functionSource": "static int evhttp_is_connection_keepalive ( struct evkeyvalq * headers ) {\n const char * connection = evhttp_find_header ( headers , \"Connection\" ) ;\n return ( connection != NULL && strncasecmp ( connection , \"keep-alive\" , 10 ) == 0 ) ;\n }", "idx": 461}
{"hash": -5268859819325807498, "project": "debian", "size": 8, "label": 0, "functionSource": "void nautilus_directory_invalidate_count_and_mime_list ( NautilusDirectory * directory ) {\n NautilusFile * file ;\n file = nautilus_directory_get_existing_corresponding_file ( directory ) ;\n if ( file != NULL ) {\n nautilus_file_invalidate_count_and_mime_list ( file ) ;\n }\n nautilus_file_unref ( file ) ;\n }", "idx": 462}
{"hash": 1760449185745615462, "project": "debian", "size": 4, "label": 0, "functionSource": "void TSTextLogObjectHeaderSet ( TSTextLogObject the_object , const char * header ) {\n sdk_assert ( sdk_sanity_check_iocore_structure ( the_object ) == TS_SUCCESS ) ;\n ( ( TextLogObject * ) the_object ) -> set_log_file_header ( header ) ;\n }", "idx": 463}
{"hash": 2895622461494525400, "project": "debian", "size": 48, "label": 0, "functionSource": "static void test_view ( ) {\n MYSQL_STMT * stmt ;\n int rc , i ;\n MYSQL_BIND my_bind [ 1 ] ;\n char str_data [ 50 ] ;\n ulong length = 0L ;\n long is_null = 0L ;\n const char * query = \"SELECT COUNT(*) FROM v1 WHERE SERVERNAME=?\" ;\n myheader ( \"test_view\" ) ;\n rc = mysql_query ( mysql , \"DROP TABLE IF EXISTS t1,t2,t3,v1\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"DROP VIEW IF EXISTS v1,t1,t2,t3\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"CREATE TABLE t1 (\" \" SERVERGRP varchar(20) NOT NULL default '', \" \" DBINSTANCE varchar(20) NOT NULL default '', \" \" PRIMARY KEY (SERVERGRP)) \" \" CHARSET=latin1 collate=latin1_bin\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"CREATE TABLE t2 (\" \" SERVERNAME varchar(20) NOT NULL, \" \" SERVERGRP varchar(20) NOT NULL, \" \" PRIMARY KEY (SERVERNAME)) \" \" CHARSET=latin1 COLLATE latin1_bin\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"CREATE TABLE t3 (\" \" SERVERGRP varchar(20) BINARY NOT NULL, \" \" TABNAME varchar(30) NOT NULL, MAPSTATE char(1) NOT NULL, \" \" ACTSTATE char(1) NOT NULL , \" \" LOCAL_NAME varchar(30) NOT NULL, \" \" CHG_DATE varchar(8) NOT NULL default '00000000', \" \" CHG_TIME varchar(6) NOT NULL default '000000', \" \" MXUSER varchar(12) NOT NULL default '', \" \" PRIMARY KEY (SERVERGRP, TABNAME, MAPSTATE, ACTSTATE, \" \" LOCAL_NAME)) CHARSET=latin1 COLLATE latin1_bin\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"CREATE VIEW v1 AS select sql_no_cache\" \" T0001.SERVERNAME AS SERVERNAME, T0003.TABNAME AS\" \" TABNAME,T0003.LOCAL_NAME AS LOCAL_NAME,T0002.DBINSTANCE AS\" \" DBINSTANCE from t2 T0001 join t1 T0002 join t3 T0003 where\" \" ((T0002.SERVERGRP = T0001.SERVERGRP) and\" \" (T0002.SERVERGRP = T0003.SERVERGRP)\" \" and (T0003.MAPSTATE = _latin1'A') and\" \" (T0003.ACTSTATE = _latin1' '))\" ) ;\n myquery ( rc ) ;\n stmt = mysql_stmt_init ( mysql ) ;\n rc = mysql_stmt_prepare ( stmt , query , strlen ( query ) ) ;\n check_execute ( stmt , rc ) ;\n strmov ( str_data , \"TEST\" ) ;\n memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n my_bind [ 0 ] . buffer_type = MYSQL_TYPE_STRING ;\n my_bind [ 0 ] . buffer = ( char * ) & str_data ;\n my_bind [ 0 ] . buffer_length = 50 ;\n my_bind [ 0 ] . length = & length ;\n length = 4 ;\n my_bind [ 0 ] . is_null = ( char * ) & is_null ;\n rc = mysql_stmt_bind_param ( stmt , my_bind ) ;\n check_execute ( stmt , rc ) ;\n for ( i = 0 ;\n i < 3 ;\n i ++ ) {\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n rc = my_process_stmt_result ( stmt ) ;\n DIE_UNLESS ( 1 == rc ) ;\n }\n mysql_stmt_close ( stmt ) ;\n rc = mysql_query ( mysql , \"DROP TABLE t1,t2,t3\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"DROP VIEW v1\" ) ;\n myquery ( rc ) ;\n }", "idx": 464}
{"hash": 3584320764213684062, "project": "debian", "size": 4, "label": 0, "functionSource": "static void vvalue_strbuf_append_i8 ( wmem_strbuf_t * strbuf , void * ptr ) {\n gint64 i8 = * ( gint64 * ) ptr ;\n wmem_strbuf_append_printf ( strbuf , \"%\" G_GINT64_MODIFIER \"d\" , i8 ) ;\n }", "idx": 465}
{"hash": -3559021711340554904, "project": "debian", "size": 3, "label": 0, "functionSource": "bool and_clause ( Node * clause ) {\n return ( clause != NULL && IsA ( clause , BoolExpr ) && ( ( BoolExpr * ) clause ) -> boolop == AND_EXPR ) ;\n }", "idx": 466}
{"hash": 313627013719508831, "project": "debian", "size": 4, "label": 0, "functionSource": "static inline MagickRealType GetPixelLuma ( const Image * restrict image , const Quantum * restrict pixel ) {\n if ( image -> colorspace == GRAYColorspace ) return ( ( MagickRealType ) pixel [ image -> channel_map [ GrayPixelChannel ] . offset ] ) ;\n return ( 0.212656f * pixel [ image -> channel_map [ RedPixelChannel ] . offset ] + 0.715158f * pixel [ image -> channel_map [ GreenPixelChannel ] . offset ] + 0.072186f * pixel [ image -> channel_map [ BluePixelChannel ] . offset ] ) ;\n }", "idx": 467}
{"hash": -5082285935423529157, "project": "debian", "size": 14, "label": 0, "functionSource": "static int dissect_rsl_ie_cb_cmd_type ( tvbuff_t * tvb , packet_info * pinfo _U_ , proto_tree * tree , int offset , gboolean is_mandatory ) {\n proto_tree * ie_tree ;\n guint8 ie_id ;\n if ( is_mandatory == FALSE ) {\n ie_id = tvb_get_guint8 ( tvb , offset ) ;\n if ( ie_id != RSL_IE_CB_CMD_TYPE ) return offset ;\n }\n ie_tree = proto_tree_add_subtree ( tree , tvb , offset , 0 , ett_ie_cb_cmd_type , NULL , \"CB Command type IE\" ) ;\n proto_tree_add_item ( ie_tree , hf_rsl_ie_id , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n offset ++ ;\n proto_tree_add_item ( ie_tree , hf_rsl_ch_needed , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n offset ++ ;\n return offset ;\n }", "idx": 468}
{"hash": -2591112946600337077, "project": "debian", "size": 18, "label": 0, "functionSource": "static int comp_interp_index ( G723_1_Context * p , int pitch_lag , int * exc_eng , int * scale ) {\n int offset = PITCH_MAX + 2 * SUBFRAME_LEN ;\n int16_t * buf = p -> audio + LPC_ORDER ;\n int index , ccr , tgt_eng , best_eng , temp ;\n * scale = scale_vector ( buf , p -> excitation , FRAME_LEN + PITCH_MAX ) ;\n buf += offset ;\n ccr = 0 ;\n index = autocorr_max ( buf , offset , & ccr , pitch_lag , SUBFRAME_LEN * 2 , - 1 ) ;\n ccr = av_sat_add32 ( ccr , 1 << 15 ) >> 16 ;\n tgt_eng = dot_product ( buf , buf , SUBFRAME_LEN * 2 ) ;\n * exc_eng = av_sat_add32 ( tgt_eng , 1 << 15 ) >> 16 ;\n if ( ccr <= 0 ) return 0 ;\n best_eng = dot_product ( buf - index , buf - index , SUBFRAME_LEN * 2 ) ;\n best_eng = av_sat_add32 ( best_eng , 1 << 15 ) >> 16 ;\n temp = best_eng * * exc_eng >> 3 ;\n if ( temp < ccr * ccr ) return index ;\n else return 0 ;\n }", "idx": 469}
{"hash": 9155638497612715289, "project": "debian", "size": 55, "label": 1, "functionSource": "static uint64_t cchip_read ( void * opaque , hwaddr addr , unsigned size ) {\n CPUAlphaState * env = cpu_single_env ;\n TyphoonState * s = opaque ;\n CPUState * cpu ;\n uint64_t ret = 0 ;\n if ( addr & 4 ) {\n return s -> latch_tmp ;\n }\n switch ( addr ) {\n case 0x0000 : break ;\n case 0x0040 : break ;\n case 0x0080 : cpu = ENV_GET_CPU ( env ) ;\n ret = s -> cchip . misc | ( cpu -> cpu_index & 3 ) ;\n break ;\n case 0x00c0 : break ;\n case 0x0100 : case 0x0140 : case 0x0180 : case 0x01c0 : break ;\n case 0x0200 : ret = s -> cchip . dim [ 0 ] ;\n break ;\n case 0x0240 : ret = s -> cchip . dim [ 1 ] ;\n break ;\n case 0x0280 : ret = s -> cchip . dim [ 0 ] & s -> cchip . drir ;\n break ;\n case 0x02c0 : ret = s -> cchip . dim [ 1 ] & s -> cchip . drir ;\n break ;\n case 0x0300 : ret = s -> cchip . drir ;\n break ;\n case 0x0340 : break ;\n case 0x0380 : ret = s -> cchip . iic [ 0 ] ;\n break ;\n case 0x03c0 : ret = s -> cchip . iic [ 1 ] ;\n break ;\n case 0x0400 : case 0x0440 : case 0x0480 : case 0x04c0 : break ;\n case 0x0580 : break ;\n case 0x05c0 : break ;\n case 0x0600 : ret = s -> cchip . dim [ 2 ] ;\n break ;\n case 0x0640 : ret = s -> cchip . dim [ 3 ] ;\n break ;\n case 0x0680 : ret = s -> cchip . dim [ 2 ] & s -> cchip . drir ;\n break ;\n case 0x06c0 : ret = s -> cchip . dim [ 3 ] & s -> cchip . drir ;\n break ;\n case 0x0700 : ret = s -> cchip . iic [ 2 ] ;\n break ;\n case 0x0740 : ret = s -> cchip . iic [ 3 ] ;\n break ;\n case 0x0780 : break ;\n case 0x0c00 : case 0x0c40 : case 0x0c80 : case 0x0cc0 : break ;\n default : cpu = CPU ( alpha_env_get_cpu ( cpu_single_env ) ) ;\n cpu_unassigned_access ( cpu , addr , false , false , 0 , size ) ;\n return - 1 ;\n }\n s -> latch_tmp = ret >> 32 ;\n return ret ;\n }", "idx": 470}
{"hash": -5673151078622202536, "project": "debian", "size": 20, "label": 0, "functionSource": "VirtIODevice * virtio_balloon_init ( DeviceState * dev ) {\n VirtIOBalloon * s ;\n int ret ;\n s = ( VirtIOBalloon * ) virtio_common_init ( \"virtio-balloon\" , VIRTIO_ID_BALLOON , 8 , sizeof ( VirtIOBalloon ) ) ;\n s -> vdev . get_config = virtio_balloon_get_config ;\n s -> vdev . set_config = virtio_balloon_set_config ;\n s -> vdev . get_features = virtio_balloon_get_features ;\n ret = qemu_add_balloon_handler ( virtio_balloon_to_target , virtio_balloon_stat , s ) ;\n if ( ret < 0 ) {\n virtio_cleanup ( & s -> vdev ) ;\n return NULL ;\n }\n s -> ivq = virtio_add_queue ( & s -> vdev , 128 , virtio_balloon_handle_output ) ;\n s -> dvq = virtio_add_queue ( & s -> vdev , 128 , virtio_balloon_handle_output ) ;\n s -> svq = virtio_add_queue ( & s -> vdev , 128 , virtio_balloon_receive_stats ) ;\n reset_stats ( s ) ;\n s -> qdev = dev ;\n register_savevm ( dev , \"virtio-balloon\" , - 1 , 1 , virtio_balloon_save , virtio_balloon_load , s ) ;\n return & s -> vdev ;\n }", "idx": 471}
{"hash": 6080147530626246065, "project": "debian", "size": 128, "label": 1, "functionSource": "static void vc1_decode_b_mb ( VC1Context * v ) {\n MpegEncContext * s = & v -> s ;\n GetBitContext * gb = & s -> gb ;\n int i , j ;\n int mb_pos = s -> mb_x + s -> mb_y * s -> mb_stride ;\n int cbp = 0 ;\n int mqdiff , mquant ;\n int ttmb = v -> ttfrm ;\n int mb_has_coeffs = 0 ;\n int index , index1 ;\n int val , sign ;\n int first_block = 1 ;\n int dst_idx , off ;\n int skipped , direct ;\n int dmv_x [ 2 ] , dmv_y [ 2 ] ;\n int bmvtype = BMV_TYPE_BACKWARD ;\n mquant = v -> pq ;\n s -> mb_intra = 0 ;\n if ( v -> dmb_is_raw ) direct = get_bits1 ( gb ) ;\n else direct = v -> direct_mb_plane [ mb_pos ] ;\n if ( v -> skip_is_raw ) skipped = get_bits1 ( gb ) ;\n else skipped = v -> s . mbskip_table [ mb_pos ] ;\n dmv_x [ 0 ] = dmv_x [ 1 ] = dmv_y [ 0 ] = dmv_y [ 1 ] = 0 ;\n for ( i = 0 ;\n i < 6 ;\n i ++ ) {\n v -> mb_type [ 0 ] [ s -> block_index [ i ] ] = 0 ;\n s -> dc_val [ 0 ] [ s -> block_index [ i ] ] = 0 ;\n }\n s -> current_picture . f . qscale_table [ mb_pos ] = 0 ;\n if ( ! direct ) {\n if ( ! skipped ) {\n GET_MVDATA ( dmv_x [ 0 ] , dmv_y [ 0 ] ) ;\n dmv_x [ 1 ] = dmv_x [ 0 ] ;\n dmv_y [ 1 ] = dmv_y [ 0 ] ;\n }\n if ( skipped || ! s -> mb_intra ) {\n bmvtype = decode012 ( gb ) ;\n switch ( bmvtype ) {\n case 0 : bmvtype = ( v -> bfraction >= ( B_FRACTION_DEN / 2 ) ) ? BMV_TYPE_BACKWARD : BMV_TYPE_FORWARD ;\n break ;\n case 1 : bmvtype = ( v -> bfraction >= ( B_FRACTION_DEN / 2 ) ) ? BMV_TYPE_FORWARD : BMV_TYPE_BACKWARD ;\n break ;\n case 2 : bmvtype = BMV_TYPE_INTERPOLATED ;\n dmv_x [ 0 ] = dmv_y [ 0 ] = 0 ;\n }\n }\n }\n for ( i = 0 ;\n i < 6 ;\n i ++ ) v -> mb_type [ 0 ] [ s -> block_index [ i ] ] = s -> mb_intra ;\n if ( skipped ) {\n if ( direct ) bmvtype = BMV_TYPE_INTERPOLATED ;\n vc1_pred_b_mv ( v , dmv_x , dmv_y , direct , bmvtype ) ;\n vc1_b_mc ( v , dmv_x , dmv_y , direct , bmvtype ) ;\n return ;\n }\n if ( direct ) {\n cbp = get_vlc2 ( & v -> s . gb , v -> cbpcy_vlc -> table , VC1_CBPCY_P_VLC_BITS , 2 ) ;\n GET_MQUANT ( ) ;\n s -> mb_intra = 0 ;\n s -> current_picture . f . qscale_table [ mb_pos ] = mquant ;\n if ( ! v -> ttmbf ) ttmb = get_vlc2 ( gb , ff_vc1_ttmb_vlc [ v -> tt_index ] . table , VC1_TTMB_VLC_BITS , 2 ) ;\n dmv_x [ 0 ] = dmv_y [ 0 ] = dmv_x [ 1 ] = dmv_y [ 1 ] = 0 ;\n vc1_pred_b_mv ( v , dmv_x , dmv_y , direct , bmvtype ) ;\n vc1_b_mc ( v , dmv_x , dmv_y , direct , bmvtype ) ;\n }\n else {\n if ( ! mb_has_coeffs && ! s -> mb_intra ) {\n vc1_pred_b_mv ( v , dmv_x , dmv_y , direct , bmvtype ) ;\n vc1_b_mc ( v , dmv_x , dmv_y , direct , bmvtype ) ;\n return ;\n }\n if ( s -> mb_intra && ! mb_has_coeffs ) {\n GET_MQUANT ( ) ;\n s -> current_picture . f . qscale_table [ mb_pos ] = mquant ;\n s -> ac_pred = get_bits1 ( gb ) ;\n cbp = 0 ;\n vc1_pred_b_mv ( v , dmv_x , dmv_y , direct , bmvtype ) ;\n }\n else {\n if ( bmvtype == BMV_TYPE_INTERPOLATED ) {\n GET_MVDATA ( dmv_x [ 0 ] , dmv_y [ 0 ] ) ;\n if ( ! mb_has_coeffs ) {\n vc1_pred_b_mv ( v , dmv_x , dmv_y , direct , bmvtype ) ;\n vc1_b_mc ( v , dmv_x , dmv_y , direct , bmvtype ) ;\n return ;\n }\n }\n vc1_pred_b_mv ( v , dmv_x , dmv_y , direct , bmvtype ) ;\n if ( ! s -> mb_intra ) {\n vc1_b_mc ( v , dmv_x , dmv_y , direct , bmvtype ) ;\n }\n if ( s -> mb_intra ) s -> ac_pred = get_bits1 ( gb ) ;\n cbp = get_vlc2 ( & v -> s . gb , v -> cbpcy_vlc -> table , VC1_CBPCY_P_VLC_BITS , 2 ) ;\n GET_MQUANT ( ) ;\n s -> current_picture . f . qscale_table [ mb_pos ] = mquant ;\n if ( ! v -> ttmbf && ! s -> mb_intra && mb_has_coeffs ) ttmb = get_vlc2 ( gb , ff_vc1_ttmb_vlc [ v -> tt_index ] . table , VC1_TTMB_VLC_BITS , 2 ) ;\n }\n }\n dst_idx = 0 ;\n for ( i = 0 ;\n i < 6 ;\n i ++ ) {\n s -> dc_val [ 0 ] [ s -> block_index [ i ] ] = 0 ;\n dst_idx += i >> 2 ;\n val = ( ( cbp >> ( 5 - i ) ) & 1 ) ;\n off = ( i & 4 ) ? 0 : ( ( i & 1 ) * 8 + ( i & 2 ) * 4 * s -> linesize ) ;\n v -> mb_type [ 0 ] [ s -> block_index [ i ] ] = s -> mb_intra ;\n if ( s -> mb_intra ) {\n v -> a_avail = v -> c_avail = 0 ;\n if ( i == 2 || i == 3 || ! s -> first_slice_line ) v -> a_avail = v -> mb_type [ 0 ] [ s -> block_index [ i ] - s -> block_wrap [ i ] ] ;\n if ( i == 1 || i == 3 || s -> mb_x ) v -> c_avail = v -> mb_type [ 0 ] [ s -> block_index [ i ] - 1 ] ;\n vc1_decode_intra_block ( v , s -> block [ i ] , i , val , mquant , ( i & 4 ) ? v -> codingset2 : v -> codingset ) ;\n if ( ( i > 3 ) && ( s -> flags & CODEC_FLAG_GRAY ) ) continue ;\n v -> vc1dsp . vc1_inv_trans_8x8 ( s -> block [ i ] ) ;\n if ( v -> rangeredfrm ) for ( j = 0 ;\n j < 64 ;\n j ++ ) s -> block [ i ] [ j ] <<= 1 ;\n s -> dsp . put_signed_pixels_clamped ( s -> block [ i ] , s -> dest [ dst_idx ] + off , i & 4 ? s -> uvlinesize : s -> linesize ) ;\n }\n else if ( val ) {\n vc1_decode_p_block ( v , s -> block [ i ] , i , mquant , ttmb , first_block , s -> dest [ dst_idx ] + off , ( i & 4 ) ? s -> uvlinesize : s -> linesize , ( i & 4 ) && ( s -> flags & CODEC_FLAG_GRAY ) , NULL ) ;\n if ( ! v -> ttmbf && ttmb < 8 ) ttmb = - 1 ;\n first_block = 0 ;\n }\n }\n }", "idx": 472}
{"hash": -7131177824150194183, "project": "debian", "size": 80, "label": 0, "functionSource": "static int read_residue ( GetBitContext * gb , int16_t block [ 64 ] , int masks_count ) {\n int coef_list [ 128 ] ;\n int mode_list [ 128 ] ;\n int i , sign , mask , ccoef , mode ;\n int list_start = 64 , list_end = 64 , list_pos ;\n int nz_coeff [ 64 ] ;\n int nz_coeff_count = 0 ;\n coef_list [ list_end ] = 4 ;\n mode_list [ list_end ++ ] = 0 ;\n coef_list [ list_end ] = 24 ;\n mode_list [ list_end ++ ] = 0 ;\n coef_list [ list_end ] = 44 ;\n mode_list [ list_end ++ ] = 0 ;\n coef_list [ list_end ] = 0 ;\n mode_list [ list_end ++ ] = 2 ;\n for ( mask = 1 << get_bits ( gb , 3 ) ;\n mask ;\n mask >>= 1 ) {\n for ( i = 0 ;\n i < nz_coeff_count ;\n i ++ ) {\n if ( ! get_bits1 ( gb ) ) continue ;\n if ( block [ nz_coeff [ i ] ] < 0 ) block [ nz_coeff [ i ] ] -= mask ;\n else block [ nz_coeff [ i ] ] += mask ;\n masks_count -- ;\n if ( masks_count < 0 ) return 0 ;\n }\n list_pos = list_start ;\n while ( list_pos < list_end ) {\n if ( ! ( coef_list [ list_pos ] | mode_list [ list_pos ] ) || ! get_bits1 ( gb ) ) {\n list_pos ++ ;\n continue ;\n }\n ccoef = coef_list [ list_pos ] ;\n mode = mode_list [ list_pos ] ;\n switch ( mode ) {\n case 0 : coef_list [ list_pos ] = ccoef + 4 ;\n mode_list [ list_pos ] = 1 ;\n case 2 : if ( mode == 2 ) {\n coef_list [ list_pos ] = 0 ;\n mode_list [ list_pos ++ ] = 0 ;\n }\n for ( i = 0 ;\n i < 4 ;\n i ++ , ccoef ++ ) {\n if ( get_bits1 ( gb ) ) {\n coef_list [ -- list_start ] = ccoef ;\n mode_list [ list_start ] = 3 ;\n }\n else {\n nz_coeff [ nz_coeff_count ++ ] = bink_scan [ ccoef ] ;\n sign = - get_bits1 ( gb ) ;\n block [ bink_scan [ ccoef ] ] = ( mask ^ sign ) - sign ;\n masks_count -- ;\n if ( masks_count < 0 ) return 0 ;\n }\n }\n break ;\n case 1 : mode_list [ list_pos ] = 2 ;\n for ( i = 0 ;\n i < 3 ;\n i ++ ) {\n ccoef += 4 ;\n coef_list [ list_end ] = ccoef ;\n mode_list [ list_end ++ ] = 2 ;\n }\n break ;\n case 3 : nz_coeff [ nz_coeff_count ++ ] = bink_scan [ ccoef ] ;\n sign = - get_bits1 ( gb ) ;\n block [ bink_scan [ ccoef ] ] = ( mask ^ sign ) - sign ;\n coef_list [ list_pos ] = 0 ;\n mode_list [ list_pos ++ ] = 0 ;\n masks_count -- ;\n if ( masks_count < 0 ) return 0 ;\n break ;\n }\n }\n }\n return 0 ;\n }", "idx": 473}
{"hash": -2994308217034422906, "project": "chrome", "size": 15, "label": 0, "functionSource": "TEST_F ( ProcessUtilTest , DISABLED_GetTerminationStatusExit ) {\n const std : : string signal_file = ProcessUtilTest : : GetSignalFilePath ( kSignalFileSlow ) ;\n remove ( signal_file . c_str ( ) ) ;\n base : : Process process = SpawnChild ( \"SlowChildProcess\" ) ;\n ASSERT_TRUE ( process . IsValid ( ) ) ;\n int exit_code = 42 ;\n EXPECT_EQ ( base : : TERMINATION_STATUS_STILL_RUNNING , base : : GetTerminationStatus ( process . Handle ( ) , & exit_code ) ) ;\n EXPECT_EQ ( kExpectedStillRunningExitCode , exit_code ) ;\n SignalChildren ( signal_file . c_str ( ) ) ;\n exit_code = 42 ;\n base : : TerminationStatus status = WaitForChildTermination ( process . Handle ( ) , & exit_code ) ;\n EXPECT_EQ ( base : : TERMINATION_STATUS_NORMAL_TERMINATION , status ) ;\n EXPECT_EQ ( 0 , exit_code ) ;\n remove ( signal_file . c_str ( ) ) ;\n }", "idx": 474}
{"hash": -7014146700012452141, "project": "debian", "size": 38, "label": 1, "functionSource": "static void cdxl_decode_ham6 ( CDXLVideoContext * c ) {\n AVCodecContext * avctx = c -> avctx ;\n uint32_t new_palette [ 16 ] , r , g , b ;\n uint8_t * ptr , * out , index , op ;\n int x , y ;\n ptr = c -> new_video ;\n out = c -> frame . data [ 0 ] ;\n import_palette ( c , new_palette ) ;\n import_format ( c , avctx -> width , c -> new_video ) ;\n for ( y = 0 ;\n y < avctx -> height ;\n y ++ ) {\n r = new_palette [ 0 ] & 0xFF0000 ;\n g = new_palette [ 0 ] & 0xFF00 ;\n b = new_palette [ 0 ] & 0xFF ;\n for ( x = 0 ;\n x < avctx -> width ;\n x ++ ) {\n index = * ptr ++ ;\n op = index >> 4 ;\n index &= 15 ;\n switch ( op ) {\n case 0 : r = new_palette [ index ] & 0xFF0000 ;\n g = new_palette [ index ] & 0xFF00 ;\n b = new_palette [ index ] & 0xFF ;\n break ;\n case 1 : b = index * 0x11 ;\n break ;\n case 2 : r = index * 0x11 << 16 ;\n break ;\n case 3 : g = index * 0x11 << 8 ;\n break ;\n }\n AV_WL24 ( out + x * 3 , r | g | b ) ;\n }\n out += c -> frame . linesize [ 0 ] ;\n }\n }", "idx": 475}
{"hash": -789251383577298283, "project": "debian", "size": 62, "label": 1, "functionSource": "static void fmtint ( char * * sbuffer , char * * buffer , size_t * currlen , size_t * maxlen , LLONG value , int base , int min , int max , int flags ) {\n int signvalue = 0 ;\n const char * prefix = \"\" ;\n unsigned LLONG uvalue ;\n char convert [ DECIMAL_SIZE ( value ) + 3 ] ;\n int place = 0 ;\n int spadlen = 0 ;\n int zpadlen = 0 ;\n int caps = 0 ;\n if ( max < 0 ) max = 0 ;\n uvalue = value ;\n if ( ! ( flags & DP_F_UNSIGNED ) ) {\n if ( value < 0 ) {\n signvalue = '-' ;\n uvalue = - value ;\n }\n else if ( flags & DP_F_PLUS ) signvalue = '+' ;\n else if ( flags & DP_F_SPACE ) signvalue = ' ' ;\n }\n if ( flags & DP_F_NUM ) {\n if ( base == 8 ) prefix = \"0\" ;\n if ( base == 16 ) prefix = \"0x\" ;\n }\n if ( flags & DP_F_UP ) caps = 1 ;\n do {\n convert [ place ++ ] = ( caps ? \"0123456789ABCDEF\" : \"0123456789abcdef\" ) [ uvalue % ( unsigned ) base ] ;\n uvalue = ( uvalue / ( unsigned ) base ) ;\n }\n while ( uvalue && ( place < ( int ) sizeof ( convert ) ) ) ;\n if ( place == sizeof ( convert ) ) place -- ;\n convert [ place ] = 0 ;\n zpadlen = max - place ;\n spadlen = min - OSSL_MAX ( max , place ) - ( signvalue ? 1 : 0 ) - strlen ( prefix ) ;\n if ( zpadlen < 0 ) zpadlen = 0 ;\n if ( spadlen < 0 ) spadlen = 0 ;\n if ( flags & DP_F_ZERO ) {\n zpadlen = OSSL_MAX ( zpadlen , spadlen ) ;\n spadlen = 0 ;\n }\n if ( flags & DP_F_MINUS ) spadlen = - spadlen ;\n while ( spadlen > 0 ) {\n doapr_outch ( sbuffer , buffer , currlen , maxlen , ' ' ) ;\n -- spadlen ;\n }\n if ( signvalue ) doapr_outch ( sbuffer , buffer , currlen , maxlen , signvalue ) ;\n while ( * prefix ) {\n doapr_outch ( sbuffer , buffer , currlen , maxlen , * prefix ) ;\n prefix ++ ;\n }\n if ( zpadlen > 0 ) {\n while ( zpadlen > 0 ) {\n doapr_outch ( sbuffer , buffer , currlen , maxlen , '0' ) ;\n -- zpadlen ;\n }\n }\n while ( place > 0 ) doapr_outch ( sbuffer , buffer , currlen , maxlen , convert [ -- place ] ) ;\n while ( spadlen < 0 ) {\n doapr_outch ( sbuffer , buffer , currlen , maxlen , ' ' ) ;\n ++ spadlen ;\n }\n return ;\n }", "idx": 476}
{"hash": 7039307292471244756, "project": "debian", "size": 9, "label": 0, "functionSource": "static void dtap_gcc_setup ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len ) {\n guint32 curr_offset ;\n guint32 consumed ;\n guint curr_len ;\n curr_offset = offset ;\n curr_len = len ;\n ELEM_MAND_V ( GSM_A_PDU_TYPE_DTAP , DE_GCC_CALL_REF , NULL ) ;\n ELEM_OPT_TLV ( 0x7e , GSM_A_PDU_TYPE_DTAP , DE_USER_USER , NULL ) ;\n }", "idx": 477}
{"hash": 2895622461494525400, "project": "debian", "size": 34, "label": 0, "functionSource": "static void test_bug29306 ( ) {\n MYSQL_FIELD * field ;\n int rc ;\n MYSQL_RES * res ;\n DBUG_ENTER ( \"test_bug29306\" ) ;\n myheader ( \"test_bug29306\" ) ;\n rc = mysql_query ( mysql , \"DROP TABLE IF EXISTS tab17557\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"DROP VIEW IF EXISTS view17557\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"CREATE TABLE tab17557 (dd decimal (3,1))\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"CREATE VIEW view17557 as SELECT dd FROM tab17557\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"INSERT INTO tab17557 VALUES (7.6)\" ) ;\n myquery ( rc ) ;\n res = mysql_list_fields ( mysql , \"view17557\" , NULL ) ;\n while ( ( field = mysql_fetch_field ( res ) ) ) {\n if ( ! opt_silent ) {\n printf ( \"field name %s\\n\" , field -> name ) ;\n printf ( \"field table %s\\n\" , field -> table ) ;\n printf ( \"field decimals %d\\n\" , field -> decimals ) ;\n if ( field -> decimals < 1 ) printf ( \"Error! No decimals! \\n\" ) ;\n printf ( \"\\n\\n\" ) ;\n }\n DIE_UNLESS ( field -> decimals == 1 ) ;\n }\n mysql_free_result ( res ) ;\n rc = mysql_query ( mysql , \"DROP TABLE tab17557\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"DROP VIEW view17557\" ) ;\n myquery ( rc ) ;\n DBUG_VOID_RETURN ;\n }", "idx": 478}
{"hash": -7434014980763120366, "project": "debian", "size": 28, "label": 0, "functionSource": "static proto_item * ber_proto_tree_add_item ( packet_info * pinfo , proto_tree * tree , const int hfindex , tvbuff_t * tvb , const gint start , gint length , const guint encoding ) {\n header_field_info * hfinfo ;\n hfinfo = proto_registrar_get_nth ( ( guint ) hfindex ) ;\n if ( hfinfo != NULL ) {\n switch ( hfinfo -> type ) {\n case FT_BOOLEAN : case FT_UINT8 : case FT_UINT16 : case FT_UINT24 : case FT_UINT32 : case FT_INT8 : case FT_INT16 : case FT_INT24 : case FT_INT32 : if ( ( length != 1 ) && ( length != 2 ) && ( length != 3 ) && ( length != 4 ) ) return ber_add_bad_length_error ( pinfo , tree , hfinfo -> name , tvb , start , length ) ;\n break ;\n case FT_IPv4 : if ( length != FT_IPv4_LEN ) return ber_add_bad_length_error ( pinfo , tree , hfinfo -> name , tvb , start , length ) ;\n break ;\n case FT_IPXNET : if ( length != FT_IPXNET_LEN ) return ber_add_bad_length_error ( pinfo , tree , hfinfo -> name , tvb , start , length ) ;\n break ;\n case FT_IPv6 : if ( ( length < 0 ) || ( length > FT_IPv6_LEN ) ) return ber_add_bad_length_error ( pinfo , tree , hfinfo -> name , tvb , start , length ) ;\n break ;\n case FT_ETHER : if ( length != FT_ETHER_LEN ) return ber_add_bad_length_error ( pinfo , tree , hfinfo -> name , tvb , start , length ) ;\n break ;\n case FT_GUID : if ( length != FT_GUID_LEN ) return ber_add_bad_length_error ( pinfo , tree , hfinfo -> name , tvb , start , length ) ;\n break ;\n case FT_FLOAT : if ( length != 4 ) return ber_add_bad_length_error ( pinfo , tree , hfinfo -> name , tvb , start , length ) ;\n break ;\n case FT_DOUBLE : if ( length != 8 ) return ber_add_bad_length_error ( pinfo , tree , hfinfo -> name , tvb , start , length ) ;\n break ;\n case FT_ABSOLUTE_TIME : case FT_RELATIVE_TIME : if ( ( length != 4 ) && ( length != 8 ) ) return ber_add_bad_length_error ( pinfo , tree , hfinfo -> name , tvb , start , length ) ;\n break ;\n default : break ;\n }\n }\n return proto_tree_add_item ( tree , hfindex , tvb , start , length , encoding ) ;\n }", "idx": 479}
{"hash": 2895622461494525400, "project": "debian", "size": 11, "label": 0, "functionSource": "static void test_bug11766854 ( ) {\n struct st_mysql_client_plugin * plugin ;\n DBUG_ENTER ( \"test_bug11766854\" ) ;\n myheader ( \"test_bug11766854\" ) ;\n plugin = mysql_load_plugin ( mysql , \"foo\" , - 1 , 0 ) ;\n DIE_UNLESS ( plugin == 0 ) ;\n plugin = mysql_load_plugin ( mysql , \"qa_auth_client\" , - 1 , 0 ) ;\n DIE_UNLESS ( plugin != 0 ) ;\n DIE_IF ( mysql_errno ( mysql ) ) ;\n DBUG_VOID_RETURN ;\n }", "idx": 480}
{"hash": 2388171415474875762, "project": "debian", "size": 181, "label": 0, "functionSource": "static void dissect_rsvp_msg_tree ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , int tree_mode , rsvp_conversation_info * rsvph , gboolean e2ei ) {\n proto_tree * rsvp_tree ;\n proto_tree * rsvp_header_tree ;\n proto_tree * rsvp_object_tree ;\n proto_tree * ti , * len_item ;\n proto_item * hidden_item , * cksum_item ;\n guint16 cksum , computed_cksum ;\n vec_t cksum_vec [ 1 ] ;\n int offset = 0 ;\n int len ;\n guint8 message_type ;\n int session_off , tempfilt_off ;\n int msg_length ;\n int obj_length ;\n gboolean have_integrity_object = FALSE ;\n offset = 0 ;\n msg_length = tvb_get_ntohs ( tvb , 6 ) ;\n message_type = tvb_get_guint8 ( tvb , 1 ) ;\n ti = proto_tree_add_item ( tree , proto_rsvp , tvb , offset , msg_length , ENC_NA ) ;\n rsvp_tree = proto_item_add_subtree ( ti , tree_mode ) ;\n if ( e2ei ) proto_item_append_text ( rsvp_tree , \" (E2E-IGNORE)\" ) ;\n proto_item_append_text ( rsvp_tree , \": \" ) ;\n proto_item_append_text ( rsvp_tree , \"%s\" , val_to_str_ext ( message_type , & message_type_vals_ext , \"Unknown (%u). \" ) ) ;\n find_rsvp_session_tempfilt ( tvb , 0 , & session_off , & tempfilt_off ) ;\n if ( session_off ) proto_item_append_text ( rsvp_tree , \"%s\" , summary_session ( tvb , session_off ) ) ;\n if ( tempfilt_off ) proto_item_append_text ( rsvp_tree , \"%s\" , summary_template ( tvb , tempfilt_off ) ) ;\n rsvp_header_tree = proto_tree_add_subtree_format ( rsvp_tree , tvb , offset , 8 , TREE ( TT_HDR ) , & ti , \"RSVP Header. %s\" , val_to_str_ext ( message_type , & message_type_vals_ext , \"Unknown Message (%u). \" ) ) ;\n if ( e2ei ) proto_item_append_text ( ti , \" (E2E-IGNORE)\" ) ;\n proto_tree_add_item ( rsvp_header_tree , hf_rsvp_version , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rsvp_header_tree , hf_rsvp_flags , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_uint ( rsvp_header_tree , hf_rsvp_filter [ RSVPF_MSG ] , tvb , offset + 1 , 1 , message_type ) ;\n switch ( RSVPF_MSG + message_type ) {\n case RSVPF_PATH : case RSVPF_RESV : case RSVPF_PATHERR : case RSVPF_RESVERR : case RSVPF_PATHTEAR : case RSVPF_RESVTEAR : case RSVPF_RCONFIRM : case RSVPF_RTEARCONFIRM : case RSVPF_BUNDLE : case RSVPF_ACK : case RSVPF_SREFRESH : case RSVPF_HELLO : case RSVPF_NOTIFY : hidden_item = proto_tree_add_boolean ( rsvp_header_tree , hf_rsvp_filter [ RSVPF_MSG + message_type ] , tvb , offset + 1 , 1 , 1 ) ;\n PROTO_ITEM_SET_HIDDEN ( hidden_item ) ;\n break ;\n }\n cksum = tvb_get_ntohs ( tvb , offset + 2 ) ;\n cksum_item = proto_tree_add_item ( rsvp_header_tree , hf_rsvp_message_checksum , tvb , offset + 2 , 2 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rsvp_header_tree , hf_rsvp_sending_ttl , tvb , offset + 4 , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rsvp_header_tree , hf_rsvp_message_length , tvb , offset + 6 , 2 , ENC_BIG_ENDIAN ) ;\n offset = 8 ;\n len = 8 ;\n if ( message_type == RSVP_MSG_BUNDLE ) {\n if ( rsvp_bundle_dissect ) {\n int len2 = 8 ;\n while ( len2 < msg_length ) {\n gint sub_len ;\n tvbuff_t * tvb_sub ;\n sub_len = tvb_get_ntohs ( tvb , len2 + 6 ) ;\n tvb_sub = tvb_new_subset_length ( tvb , len2 , sub_len ) ;\n dissect_rsvp_msg_tree ( tvb_sub , pinfo , rsvp_tree , TREE ( TT_BUNDLE_COMPMSG ) , rsvph , e2ei ) ;\n len2 += sub_len ;\n }\n }\n else {\n proto_tree_add_expert ( rsvp_tree , pinfo , & ei_rsvp_bundle_component_msg , tvb , offset , msg_length - len ) ;\n }\n return ;\n }\n while ( len < msg_length ) {\n guint8 rsvp_class ;\n guint8 type ;\n obj_length = tvb_get_ntohs ( tvb , offset ) ;\n rsvp_class = tvb_get_guint8 ( tvb , offset + 2 ) ;\n type = tvb_get_guint8 ( tvb , offset + 3 ) ;\n ti = proto_tree_add_item ( rsvp_tree , hf_rsvp_filter [ rsvp_class_to_filter_num ( rsvp_class ) ] , tvb , offset , obj_length , ENC_BIG_ENDIAN ) ;\n rsvp_object_tree = proto_item_add_subtree ( ti , TREE ( rsvp_class_to_tree_type ( rsvp_class ) ) ) ;\n len_item = proto_tree_add_item ( rsvp_object_tree , hf_rsvp_length , tvb , offset , 2 , ENC_BIG_ENDIAN ) ;\n if ( obj_length < 4 ) {\n expert_add_info_format ( pinfo , len_item , & ei_rsvp_invalid_length , \"Length: %u (bogus, must be >= 4)\" , obj_length ) ;\n break ;\n }\n proto_tree_add_uint ( rsvp_object_tree , hf_rsvp_filter [ RSVPF_OBJECT ] , tvb , offset + 2 , 1 , rsvp_class ) ;\n switch ( rsvp_class ) {\n case RSVP_CLASS_SESSION : dissect_rsvp_session ( ti , rsvp_object_tree , tvb , offset , obj_length , rsvp_class , type , rsvph ) ;\n break ;\n case RSVP_CLASS_HOP : dissect_rsvp_hop ( ti , pinfo , rsvp_object_tree , tvb , offset , obj_length , rsvp_class , type ) ;\n break ;\n case RSVP_CLASS_TIME_VALUES : dissect_rsvp_time_values ( ti , rsvp_object_tree , tvb , offset , obj_length , rsvp_class , type ) ;\n break ;\n case RSVP_CLASS_ERROR : dissect_rsvp_error ( ti , pinfo , rsvp_object_tree , tvb , offset , obj_length , rsvp_class , type ) ;\n break ;\n case RSVP_CLASS_SCOPE : dissect_rsvp_scope ( ti , rsvp_object_tree , tvb , offset , obj_length , rsvp_class , type ) ;\n break ;\n case RSVP_CLASS_STYLE : dissect_rsvp_style ( ti , rsvp_object_tree , tvb , offset , obj_length , rsvp_class , type ) ;\n break ;\n case RSVP_CLASS_CONFIRM : dissect_rsvp_confirm ( ti , rsvp_object_tree , tvb , offset , obj_length , rsvp_class , type ) ;\n break ;\n case RSVP_CLASS_SENDER_TEMPLATE : case RSVP_CLASS_FILTER_SPEC : dissect_rsvp_template_filter ( ti , rsvp_object_tree , tvb , offset , obj_length , rsvp_class , type , rsvph ) ;\n break ;\n case RSVP_CLASS_SENDER_TSPEC : dissect_rsvp_tspec ( ti , pinfo , rsvp_object_tree , tvb , offset , obj_length , rsvp_class , type ) ;\n break ;\n case RSVP_CLASS_FLOWSPEC : dissect_rsvp_flowspec ( ti , pinfo , rsvp_object_tree , tvb , offset , obj_length , rsvp_class , type ) ;\n break ;\n case RSVP_CLASS_ADSPEC : dissect_rsvp_adspec ( ti , pinfo , rsvp_object_tree , tvb , offset , obj_length , rsvp_class , type ) ;\n break ;\n case RSVP_CLASS_INTEGRITY : have_integrity_object = TRUE ;\n dissect_rsvp_integrity ( ti , rsvp_object_tree , tvb , offset , obj_length , rsvp_class , type ) ;\n break ;\n case RSVP_CLASS_POLICY : dissect_rsvp_policy ( ti , rsvp_object_tree , tvb , offset , obj_length , rsvp_class , type ) ;\n break ;\n case RSVP_CLASS_LABEL_REQUEST : dissect_rsvp_label_request ( ti , rsvp_object_tree , tvb , offset , obj_length , rsvp_class , type ) ;\n break ;\n case RSVP_CLASS_RECOVERY_LABEL : case RSVP_CLASS_UPSTREAM_LABEL : case RSVP_CLASS_SUGGESTED_LABEL : case RSVP_CLASS_LABEL : dissect_rsvp_label ( ti , rsvp_object_tree , tvb , offset , obj_length , rsvp_class , type ) ;\n break ;\n case RSVP_CLASS_LABEL_SET : dissect_rsvp_label_set ( ti , rsvp_object_tree , tvb , offset , obj_length , rsvp_class , type ) ;\n break ;\n case RSVP_CLASS_SESSION_ATTRIBUTE : dissect_rsvp_session_attribute ( ti , rsvp_object_tree , tvb , offset , obj_length , rsvp_class , type ) ;\n break ;\n case RSVP_CLASS_EXPLICIT_ROUTE : dissect_rsvp_explicit_route ( ti , pinfo , rsvp_object_tree , tvb , offset , obj_length , rsvp_class , type ) ;\n break ;\n case RSVP_CLASS_RECORD_ROUTE : dissect_rsvp_record_route ( ti , pinfo , rsvp_object_tree , tvb , offset , obj_length , rsvp_class , type ) ;\n break ;\n case RSVP_CLASS_EXCLUDE_ROUTE : dissect_rsvp_exclude_route ( ti , pinfo , rsvp_object_tree , tvb , offset , obj_length , rsvp_class , type ) ;\n break ;\n case RSVP_CLASS_MESSAGE_ID : dissect_rsvp_message_id ( ti , rsvp_object_tree , tvb , offset , obj_length , rsvp_class , type ) ;\n break ;\n case RSVP_CLASS_MESSAGE_ID_ACK : dissect_rsvp_message_id_ack ( ti , rsvp_object_tree , tvb , offset , obj_length , rsvp_class , type ) ;\n break ;\n case RSVP_CLASS_MESSAGE_ID_LIST : dissect_rsvp_message_id_list ( ti , rsvp_object_tree , tvb , offset , obj_length , rsvp_class , type ) ;\n break ;\n case RSVP_CLASS_HELLO : dissect_rsvp_hello ( ti , rsvp_object_tree , tvb , offset , obj_length , rsvp_class , type ) ;\n break ;\n case RSVP_CLASS_DCLASS : dissect_rsvp_dclass ( ti , rsvp_object_tree , tvb , offset , obj_length , rsvp_class , type ) ;\n break ;\n case RSVP_CLASS_ADMIN_STATUS : dissect_rsvp_admin_status ( ti , rsvp_object_tree , tvb , offset , obj_length , rsvp_class , type ) ;\n break ;\n case RSVP_CLASS_LSP_ATTRIBUTES : case RSVP_CLASS_LSP_REQUIRED_ATTRIBUTES : dissect_rsvp_lsp_attributes ( ti , pinfo , rsvp_object_tree , tvb , offset , obj_length , rsvp_class , type ) ;\n break ;\n case RSVP_CLASS_ASSOCIATION : dissect_rsvp_association ( ti , rsvp_object_tree , tvb , offset , obj_length , rsvp_class , type ) ;\n break ;\n case RSVP_CLASS_LSP_TUNNEL_IF_ID : dissect_rsvp_lsp_tunnel_if_id ( ti , pinfo , rsvp_object_tree , tvb , offset , obj_length , rsvp_class , type ) ;\n break ;\n case RSVP_CLASS_NOTIFY_REQUEST : dissect_rsvp_notify_request ( ti , rsvp_object_tree , tvb , offset , obj_length , rsvp_class , type ) ;\n break ;\n case RSVP_CLASS_GENERALIZED_UNI : dissect_rsvp_gen_uni ( ti , pinfo , rsvp_object_tree , tvb , offset , obj_length , rsvp_class , type , rsvph ) ;\n break ;\n case RSVP_CLASS_CALL_ID : dissect_rsvp_call_id ( ti , pinfo , rsvp_object_tree , tvb , offset , obj_length , rsvp_class , type ) ;\n break ;\n case RSVP_CLASS_3GPP2_OBJECT : dissect_rsvp_3gpp_object ( ti , pinfo , rsvp_object_tree , tvb , offset , obj_length , rsvp_class , type ) ;\n break ;\n case RSVP_CLASS_RESTART_CAP : dissect_rsvp_restart_cap ( ti , rsvp_object_tree , tvb , offset , obj_length , rsvp_class , type ) ;\n break ;\n case RSVP_CLASS_LINK_CAP : dissect_rsvp_link_cap ( ti , pinfo , rsvp_object_tree , tvb , offset , obj_length , rsvp_class , type ) ;\n break ;\n case RSVP_CLASS_PROTECTION : dissect_rsvp_protection_info ( ti , rsvp_object_tree , tvb , offset , obj_length , rsvp_class , type ) ;\n break ;\n case RSVP_CLASS_FAST_REROUTE : dissect_rsvp_fast_reroute ( ti , pinfo , rsvp_object_tree , tvb , offset , obj_length , rsvp_class , type ) ;\n break ;\n case RSVP_CLASS_DETOUR : dissect_rsvp_detour ( ti , pinfo , rsvp_object_tree , tvb , offset , obj_length , rsvp_class , type ) ;\n break ;\n case RSVP_CLASS_DIFFSERV : dissect_rsvp_diffserv ( ti , rsvp_object_tree , tvb , offset , obj_length , rsvp_class , type ) ;\n break ;\n case RSVP_CLASS_CLASSTYPE : dissect_rsvp_diffserv_aware_te ( ti , rsvp_object_tree , tvb , offset , obj_length , rsvp_class , type ) ;\n break ;\n case RSVP_CLASS_VENDOR_PRIVATE_1 : case RSVP_CLASS_VENDOR_PRIVATE_2 : case RSVP_CLASS_VENDOR_PRIVATE_3 : case RSVP_CLASS_VENDOR_PRIVATE_4 : case RSVP_CLASS_VENDOR_PRIVATE_5 : case RSVP_CLASS_VENDOR_PRIVATE_6 : case RSVP_CLASS_VENDOR_PRIVATE_7 : case RSVP_CLASS_VENDOR_PRIVATE_8 : case RSVP_CLASS_VENDOR_PRIVATE_9 : case RSVP_CLASS_VENDOR_PRIVATE_10 : case RSVP_CLASS_VENDOR_PRIVATE_11 : case RSVP_CLASS_VENDOR_PRIVATE_12 : dissect_rsvp_vendor_private_use ( ti , rsvp_object_tree , tvb , offset , obj_length , rsvp_class , type ) ;\n break ;\n case RSVP_CLASS_CALL_ATTRIBUTES : dissect_rsvp_call_attributes ( ti , pinfo , rsvp_object_tree , tvb , offset , obj_length , rsvp_class , type ) ;\n break ;\n case RSVP_CLASS_JUNIPER_PROPERTIES : dissect_rsvp_juniper ( ti , rsvp_object_tree , tvb , offset , obj_length , rsvp_class , type ) ;\n break ;\n case RSVP_CLASS_NULL : default : dissect_rsvp_unknown ( ti , rsvp_object_tree , tvb , offset , obj_length , rsvp_class , type ) ;\n break ;\n }\n offset += obj_length ;\n len += obj_length ;\n }\n if ( ! pinfo -> fragmented && ( ( int ) tvb_captured_length ( tvb ) >= msg_length ) ) {\n SET_CKSUM_VEC_TVB ( cksum_vec [ 0 ] , tvb , 0 , msg_length ) ;\n computed_cksum = in_cksum ( & cksum_vec [ 0 ] , 1 ) ;\n if ( computed_cksum == 0 ) {\n proto_item_append_text ( cksum_item , \" [correct]\" ) ;\n }\n else if ( cksum == 0 && have_integrity_object ) {\n proto_item_append_text ( cksum_item , \" [ignored, integrity object used]\" ) ;\n }\n else {\n proto_item_append_text ( cksum_item , \" [incorrect, should be 0x%04x]\" , in_cksum_shouldbe ( cksum , computed_cksum ) ) ;\n }\n }\n }", "idx": 481}
{"hash": 2546373479020365143, "project": "debian", "size": 26, "label": 0, "functionSource": "int mime_parse_integer ( const char * & buf , const char * end , int * integer ) {\n int val ;\n bool negative ;\n negative = false ;\n while ( ( buf != end ) && * buf && ! is_digit ( * buf ) && ( * buf != '-' ) ) {\n buf += 1 ;\n }\n if ( ( buf == end ) || ( * buf == '\\0' ) ) {\n return 0 ;\n }\n if ( * buf == '-' ) {\n negative = true ;\n buf += 1 ;\n }\n val = 0 ;\n while ( ( buf != end ) && is_digit ( * buf ) ) {\n val = ( val * 10 ) + ( * buf ++ - '0' ) ;\n }\n if ( negative ) {\n * integer = - val ;\n }\n else {\n * integer = val ;\n }\n return 1 ;\n }", "idx": 482}
{"hash": 9046191708840218774, "project": "debian", "size": 3, "label": 0, "functionSource": "static inline u32 perc ( u32 count , u32 total ) {\n return ( count * 100 + ( total / 2 ) ) / total ;\n }", "idx": 483}
{"hash": 2546373479020365143, "project": "debian", "size": 86, "label": 0, "functionSource": "int mime_format_date ( char * buffer , time_t value ) {\n static const char * daystrs [ ] = {\n \"Sun\" , \"Mon\" , \"Tue\" , \"Wed\" , \"Thu\" , \"Fri\" , \"Sat\" }\n ;\n static const char * monthstrs [ ] = {\n \"Jan\" , \"Feb\" , \"Mar\" , \"Apr\" , \"May\" , \"Jun\" , \"Jul\" , \"Aug\" , \"Sep\" , \"Oct\" , \"Nov\" , \"Dec\" }\n ;\n static const char * digitstrs [ ] = {\n \"00\" , \"01\" , \"02\" , \"03\" , \"04\" , \"05\" , \"06\" , \"07\" , \"08\" , \"09\" , \"10\" , \"11\" , \"12\" , \"13\" , \"14\" , \"15\" , \"16\" , \"17\" , \"18\" , \"19\" , \"20\" , \"21\" , \"22\" , \"23\" , \"24\" , \"25\" , \"26\" , \"27\" , \"28\" , \"29\" , \"30\" , \"31\" , \"32\" , \"33\" , \"34\" , \"35\" , \"36\" , \"37\" , \"38\" , \"39\" , \"40\" , \"41\" , \"42\" , \"43\" , \"44\" , \"45\" , \"46\" , \"47\" , \"48\" , \"49\" , \"50\" , \"51\" , \"52\" , \"53\" , \"54\" , \"55\" , \"56\" , \"57\" , \"58\" , \"59\" , \"60\" , \"61\" , \"62\" , \"63\" , \"64\" , \"65\" , \"66\" , \"67\" , \"68\" , \"69\" , \"70\" , \"71\" , \"72\" , \"73\" , \"74\" , \"75\" , \"76\" , \"77\" , \"78\" , \"79\" , \"80\" , \"81\" , \"82\" , \"83\" , \"84\" , \"85\" , \"86\" , \"87\" , \"88\" , \"89\" , \"90\" , \"91\" , \"92\" , \"93\" , \"94\" , \"95\" , \"96\" , \"97\" , \"98\" , \"99\" , }\n ;\n char * buf ;\n int sec , min , hour , wday , mday = 0 , year = 0 , month = 0 ;\n buf = buffer ;\n sec = ( int ) ( value % 60 ) ;\n value /= 60 ;\n min = ( int ) ( value % 60 ) ;\n value /= 60 ;\n hour = ( int ) ( value % 24 ) ;\n value /= 24 ;\n wday = ( int ) ( ( 4 + value ) % 7 ) ;\n # if MIME_FORMAT_DATE_USE_LOOKUP_TABLE mime_days_since_epoch_to_mdy ( value , & month , & mday , & year ) ;\n # else mime_days_since_epoch_to_mdy_slowcase ( value , & month , & mday , & year ) ;\n # endif ink_assert ( ( mday >= 0 ) && ( mday <= 99 ) ) ;\n ink_assert ( ( hour >= 0 ) && ( hour <= 99 ) ) ;\n ink_assert ( ( min >= 0 ) && ( min <= 99 ) ) ;\n ink_assert ( ( sec >= 0 ) && ( sec <= 99 ) ) ;\n const char * three_char_day = daystrs [ wday ] ;\n buf [ 0 ] = three_char_day [ 0 ] ;\n buf [ 1 ] = three_char_day [ 1 ] ;\n buf [ 2 ] = three_char_day [ 2 ] ;\n buf += 3 ;\n buf [ 0 ] = ',' ;\n buf [ 1 ] = ' ' ;\n buf += 2 ;\n buf [ 0 ] = digitstrs [ mday ] [ 0 ] ;\n buf [ 1 ] = digitstrs [ mday ] [ 1 ] ;\n buf [ 2 ] = ' ' ;\n buf += 3 ;\n const char * three_char_month = monthstrs [ month ] ;\n buf [ 0 ] = three_char_month [ 0 ] ;\n buf [ 1 ] = three_char_month [ 1 ] ;\n buf [ 2 ] = three_char_month [ 2 ] ;\n buf += 3 ;\n buf [ 0 ] = ' ' ;\n if ( ( year >= 2000 ) && ( year <= 2009 ) ) {\n buf [ 1 ] = '2' ;\n buf [ 2 ] = '0' ;\n buf [ 3 ] = '0' ;\n buf [ 4 ] = ( year - 2000 ) + '0' ;\n }\n else if ( ( year >= 1990 ) && ( year <= 1999 ) ) {\n buf [ 1 ] = '1' ;\n buf [ 2 ] = '9' ;\n buf [ 3 ] = '9' ;\n buf [ 4 ] = ( year - 1990 ) + '0' ;\n }\n else {\n buf [ 4 ] = ( year % 10 ) + '0' ;\n year /= 10 ;\n buf [ 3 ] = ( year % 10 ) + '0' ;\n year /= 10 ;\n buf [ 2 ] = ( year % 10 ) + '0' ;\n year /= 10 ;\n buf [ 1 ] = ( year % 10 ) + '0' ;\n }\n buf [ 5 ] = ' ' ;\n buf += 6 ;\n buf [ 0 ] = digitstrs [ hour ] [ 0 ] ;\n buf [ 1 ] = digitstrs [ hour ] [ 1 ] ;\n buf [ 2 ] = ':' ;\n buf += 3 ;\n buf [ 0 ] = digitstrs [ min ] [ 0 ] ;\n buf [ 1 ] = digitstrs [ min ] [ 1 ] ;\n buf [ 2 ] = ':' ;\n buf += 3 ;\n buf [ 0 ] = digitstrs [ sec ] [ 0 ] ;\n buf [ 1 ] = digitstrs [ sec ] [ 1 ] ;\n buf [ 2 ] = ' ' ;\n buf += 3 ;\n buf [ 0 ] = 'G' ;\n buf [ 1 ] = 'M' ;\n buf [ 2 ] = 'T' ;\n buf [ 3 ] = '\\0' ;\n buf += 3 ;\n return buf - buffer ;\n }", "idx": 484}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_Mla_type ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_Mla_type , Mla_type_choice , NULL ) ;\n return offset ;\n }", "idx": 485}
{"hash": 367231654042118631, "project": "debian", "size": 5, "label": 0, "functionSource": "static void advertise_sasl ( struct Client * client_p ) {\n if ( ! ConfigFileEntry . sasl_service ) return ;\n if ( irccmp ( client_p -> name , ConfigFileEntry . sasl_service ) ) return ;\n sendto_local_clients_with_capability ( CLICAP_CAP_NOTIFY , \":%s CAP * NEW :sasl\" , me . name ) ;\n }", "idx": 486}
{"hash": -8562387810778703674, "project": "chrome", "size": 9, "label": 0, "functionSource": "static hb_bool_t hb_font_get_glyph_h_origin_nil ( hb_font_t * font , void * font_data HB_UNUSED , hb_codepoint_t glyph , hb_position_t * x , hb_position_t * y , void * user_data HB_UNUSED ) {\n if ( font -> parent ) {\n hb_bool_t ret = font -> parent -> get_glyph_h_origin ( glyph , x , y ) ;\n if ( ret ) font -> parent_scale_position ( x , y ) ;\n return ret ;\n }\n * x = * y = 0 ;\n return false ;\n }", "idx": 487}
{"hash": -4239386405881995323, "project": "chrome", "size": 43, "label": 0, "functionSource": "static unsigned long xmlHashComputeQKey ( xmlHashTablePtr table , const xmlChar * prefix , const xmlChar * name , const xmlChar * prefix2 , const xmlChar * name2 , const xmlChar * prefix3 , const xmlChar * name3 ) {\n unsigned long value = 0L ;\n char ch ;\n # ifdef HASH_RANDOMIZATION value = table -> random_seed ;\n # endif if ( prefix != NULL ) value += 30 * ( * prefix ) ;\n else value += 30 * ( * name ) ;\n if ( prefix != NULL ) {\n while ( ( ch = * prefix ++ ) != 0 ) {\n value = value ^ ( ( value << 5 ) + ( value >> 3 ) + ( unsigned long ) ch ) ;\n }\n value = value ^ ( ( value << 5 ) + ( value >> 3 ) + ( unsigned long ) ':' ) ;\n }\n if ( name != NULL ) {\n while ( ( ch = * name ++ ) != 0 ) {\n value = value ^ ( ( value << 5 ) + ( value >> 3 ) + ( unsigned long ) ch ) ;\n }\n }\n value = value ^ ( ( value << 5 ) + ( value >> 3 ) ) ;\n if ( prefix2 != NULL ) {\n while ( ( ch = * prefix2 ++ ) != 0 ) {\n value = value ^ ( ( value << 5 ) + ( value >> 3 ) + ( unsigned long ) ch ) ;\n }\n value = value ^ ( ( value << 5 ) + ( value >> 3 ) + ( unsigned long ) ':' ) ;\n }\n if ( name2 != NULL ) {\n while ( ( ch = * name2 ++ ) != 0 ) {\n value = value ^ ( ( value << 5 ) + ( value >> 3 ) + ( unsigned long ) ch ) ;\n }\n }\n value = value ^ ( ( value << 5 ) + ( value >> 3 ) ) ;\n if ( prefix3 != NULL ) {\n while ( ( ch = * prefix3 ++ ) != 0 ) {\n value = value ^ ( ( value << 5 ) + ( value >> 3 ) + ( unsigned long ) ch ) ;\n }\n value = value ^ ( ( value << 5 ) + ( value >> 3 ) + ( unsigned long ) ':' ) ;\n }\n if ( name3 != NULL ) {\n while ( ( ch = * name3 ++ ) != 0 ) {\n value = value ^ ( ( value << 5 ) + ( value >> 3 ) + ( unsigned long ) ch ) ;\n }\n }\n return ( value % table -> size ) ;\n }", "idx": 488}
{"hash": -1338403456839869183, "project": "debian", "size": 226, "label": 0, "functionSource": "static void dissect_q931_IEs ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * root_tree , proto_tree * q931_tree , gboolean is_over_ip , int offset , int initial_codeset , q931_packet_info * q931_pi ) {\n proto_item * ti ;\n proto_tree * ie_tree = NULL ;\n guint8 info_element ;\n guint8 dummy ;\n guint16 info_element_len ;\n int codeset , locked_codeset ;\n gboolean non_locking_shift , first_segment ;\n tvbuff_t * h225_tvb , * next_tvb ;\n e164_info_t e164_info ;\n e164_info . e164_number_type = NONE ;\n e164_info . nature_of_address = NONE ;\n e164_info . E164_number_str = \"\" ;\n e164_info . E164_number_length = NONE ;\n codeset = locked_codeset = initial_codeset ;\n first_segment = FALSE ;\n while ( tvb_reported_length_remaining ( tvb , offset ) > 0 ) {\n info_element = tvb_get_guint8 ( tvb , offset ) ;\n if ( ( info_element & Q931_IE_SO_MASK ) && ( ( info_element & Q931_IE_SO_IDENTIFIER_MASK ) == Q931_IE_SHIFT ) ) {\n non_locking_shift = info_element & Q931_IE_SHIFT_NON_LOCKING ;\n codeset = info_element & Q931_IE_SHIFT_CODESET ;\n if ( ! non_locking_shift ) locked_codeset = codeset ;\n if ( q931_tree != NULL ) {\n proto_tree_add_uint_format ( q931_tree , hf_q931_locking_codeset , tvb , offset , 1 , codeset , \"%s shift to codeset %u: %s\" , ( non_locking_shift ? \"Non-locking\" : \"Locking\" ) , codeset , val_to_str ( codeset , q931_codeset_vals , \"Unknown (0x%02X)\" ) ) ;\n }\n offset += 1 ;\n continue ;\n }\n if ( info_element & Q931_IE_SO_MASK ) {\n if ( dissector_get_uint_handle ( codeset_dissector_table , codeset ) || dissector_get_uint_handle ( ie_dissector_table , ( codeset << 8 ) | ( info_element & Q931_IE_SO_IDENTIFIER_MASK ) ) ) {\n next_tvb = tvb_new_subset_length ( tvb , offset , 1 ) ;\n if ( dissector_try_uint ( ie_dissector_table , ( codeset << 8 ) | ( info_element & Q931_IE_SO_IDENTIFIER_MASK ) , next_tvb , pinfo , q931_tree ) || dissector_try_uint ( codeset_dissector_table , codeset , next_tvb , pinfo , q931_tree ) ) {\n offset += 1 ;\n codeset = locked_codeset ;\n continue ;\n }\n }\n switch ( ( codeset << 8 ) | ( info_element & Q931_IE_SO_IDENTIFIER_MASK ) ) {\n case CS0 | Q931_IE_MORE_DATA_OR_SEND_COMP : switch ( info_element ) {\n case Q931_IE_MORE_DATA : proto_tree_add_item ( q931_tree , hf_q931_more_data , tvb , offset , 1 , ENC_NA ) ;\n break ;\n case Q931_IE_SENDING_COMPLETE : proto_tree_add_item ( q931_tree , hf_q931_sending_complete , tvb , offset , 1 , ENC_NA ) ;\n break ;\n default : proto_tree_add_expert_format ( q931_tree , pinfo , & ei_q931_information_element , tvb , offset , 1 , \"Unknown information element (0x%02X)\" , info_element ) ;\n break ;\n }\n break ;\n case CS0 | Q931_IE_CONGESTION_LEVEL : proto_tree_add_item ( q931_tree , hf_q931_congestion_level , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n break ;\n case CS0 | Q931_IE_REPEAT_INDICATOR : proto_tree_add_item ( q931_tree , hf_q931_repeat_indicator , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n break ;\n default : proto_tree_add_expert_format ( q931_tree , pinfo , & ei_q931_information_element , tvb , offset , 1 , \"Unknown information element (0x%02X)\" , info_element ) ;\n break ;\n }\n offset += 1 ;\n codeset = locked_codeset ;\n continue ;\n }\n if ( is_over_ip && tvb_bytes_exist ( tvb , offset , 4 ) && codeset == 0 && tvb_get_guint8 ( tvb , offset ) == Q931_IE_USER_USER && tvb_get_guint8 ( tvb , offset + 3 ) == Q931_PROTOCOL_DISCRIMINATOR_ASN1 ) {\n info_element_len = tvb_get_ntohs ( tvb , offset + 1 ) ;\n if ( q931_tree != NULL ) {\n ie_tree = proto_tree_add_subtree ( q931_tree , tvb , offset , 1 + 2 + info_element_len , ett_q931_ie [ info_element ] , NULL , val_to_str ( info_element , q931_info_element_vals [ codeset ] , \"Unknown information element (0x%02X)\" ) ) ;\n proto_tree_add_uint_format_value ( ie_tree , hf_q931_information_element , tvb , offset , 1 , info_element , \"%s\" , val_to_str ( info_element , q931_info_element_vals [ codeset ] , \"Unknown (0x%02X)\" ) ) ;\n proto_tree_add_item ( ie_tree , hf_q931_information_element_len , tvb , offset + 1 , 2 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( ie_tree , hf_q931_user_protocol_discriminator , tvb , offset + 3 , 1 , ENC_NA ) ;\n }\n if ( info_element_len > 1 ) {\n if ( ! pinfo -> can_desegment ) {\n info_element_len = MIN ( info_element_len , tvb_captured_length_remaining ( tvb , offset + 3 ) ) ;\n }\n if ( h225_handle != NULL ) {\n h225_tvb = tvb_new_subset_length ( tvb , offset + 4 , info_element_len - 1 ) ;\n call_dissector ( h225_handle , h225_tvb , pinfo , root_tree ) ;\n }\n else {\n proto_tree_add_item ( ie_tree , hf_q931_user_information_bytes , tvb , offset + 4 , info_element_len - 1 , ENC_NA ) ;\n }\n }\n offset += 1 + 2 + info_element_len ;\n }\n else {\n info_element_len = tvb_get_guint8 ( tvb , offset + 1 ) ;\n if ( first_segment && ( tvb_reported_length_remaining ( tvb , offset + 2 ) < info_element_len ) ) {\n proto_tree_add_expert ( q931_tree , pinfo , & ei_q931_incomplete_ie , tvb , offset , - 1 ) ;\n break ;\n }\n if ( dissector_get_uint_handle ( codeset_dissector_table , codeset ) || dissector_get_uint_handle ( ie_dissector_table , ( codeset << 8 ) | info_element ) ) {\n next_tvb = tvb_new_subset_length ( tvb , offset , info_element_len + 2 ) ;\n if ( dissector_try_uint ( ie_dissector_table , ( codeset << 8 ) | info_element , next_tvb , pinfo , q931_tree ) || dissector_try_uint ( codeset_dissector_table , codeset , next_tvb , pinfo , q931_tree ) ) {\n offset += 2 + info_element_len ;\n codeset = locked_codeset ;\n continue ;\n }\n }\n ie_tree = proto_tree_add_subtree ( q931_tree , tvb , offset , 1 + 1 + info_element_len , ett_q931_ie [ info_element ] , & ti , val_to_str ( info_element , q931_info_element_vals [ codeset ] , \"Unknown information element (0x%02X)\" ) ) ;\n proto_tree_add_uint_format_value ( ie_tree , hf_q931_information_element , tvb , offset , 1 , info_element , \"%s\" , val_to_str ( info_element , q931_info_element_vals [ codeset ] , \"Unknown (0x%02X)\" ) ) ;\n proto_tree_add_uint ( ie_tree , hf_q931_information_element_len , tvb , offset + 1 , 1 , info_element_len ) ;\n if ( ( ( codeset << 8 ) | info_element ) == ( CS0 | Q931_IE_SEGMENTED_MESSAGE ) ) {\n dissect_q931_segmented_message_ie ( tvb , pinfo , offset + 2 , info_element_len , ie_tree , ti ) ;\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \" of %s\" , val_to_str_ext ( tvb_get_guint8 ( tvb , offset + 3 ) , & q931_message_type_vals_ext , \"Unknown message type (0x%02X)\" ) ) ;\n if ( tvb_get_guint8 ( tvb , offset + 2 ) & 0x80 ) {\n first_segment = TRUE ;\n }\n else {\n proto_tree_add_item ( q931_tree , hf_q931_message_segment , tvb , offset + 4 , - 1 , ENC_NA ) ;\n info_element_len += tvb_reported_length_remaining ( tvb , offset + 4 ) ;\n }\n }\n else {\n switch ( ( codeset << 8 ) | info_element ) {\n case CS0 | Q931_IE_BEARER_CAPABILITY : case CS0 | Q931_IE_LOW_LAYER_COMPAT : if ( q931_tree != NULL ) {\n dissect_q931_bearer_capability_ie ( tvb , offset + 2 , info_element_len , ie_tree ) ;\n }\n break ;\n case CS0 | Q931_IE_CAUSE : dissect_q931_cause_ie_with_info ( tvb , offset + 2 , info_element_len , ie_tree , hf_q931_cause_value , & dummy , q931_info_element_vals0 , q931_pi ) ;\n break ;\n case CS0 | Q931_IE_CHANGE_STATUS : if ( q931_tree != NULL ) {\n dissect_q931_change_status_ie ( tvb , offset + 2 , info_element_len , ie_tree ) ;\n }\n break ;\n case CS0 | Q931_IE_CALL_STATE : if ( q931_tree != NULL ) {\n dissect_q931_call_state_ie ( tvb , offset + 2 , info_element_len , ie_tree ) ;\n }\n break ;\n case CS0 | Q931_IE_CHANNEL_IDENTIFICATION : if ( q931_tree != NULL ) {\n dissect_q931_channel_identification_ie ( tvb , offset + 2 , info_element_len , ie_tree ) ;\n }\n break ;\n case CS0 | Q931_IE_PROGRESS_INDICATOR : if ( q931_tree != NULL ) {\n dissect_q931_progress_indicator_ie ( tvb , offset + 2 , info_element_len , ie_tree ) ;\n }\n break ;\n case CS0 | Q931_IE_NETWORK_SPECIFIC_FACIL : case CS0 | Q931_IE_TRANSIT_NETWORK_SEL : if ( q931_tree != NULL ) {\n dissect_q931_ns_facilities_ie ( tvb , offset + 2 , info_element_len , ie_tree ) ;\n }\n break ;\n case CS0 | Q931_IE_NOTIFICATION_INDICATOR : if ( q931_tree != NULL ) {\n dissect_q931_notification_indicator_ie ( tvb , offset + 2 , info_element_len , ie_tree ) ;\n }\n break ;\n case CS0 | Q931_IE_DISPLAY : if ( q931_tree != NULL ) {\n dissect_q931_ia5_ie ( tvb , offset + 2 , info_element_len , ie_tree , hf_q931_display_information ) ;\n }\n break ;\n case CS0 | Q931_IE_DATE_TIME : dissect_q931_date_time_ie ( tvb , pinfo , offset + 2 , info_element_len , ie_tree ) ;\n break ;\n case CS0 | Q931_IE_KEYPAD_FACILITY : if ( q931_tree != NULL ) {\n dissect_q931_ia5_ie ( tvb , offset + 2 , info_element_len , ie_tree , hf_q931_keypad_facility ) ;\n }\n break ;\n case CS0 | Q931_IE_SIGNAL : dissect_q931_signal_ie ( tvb , pinfo , offset + 2 , info_element_len , ie_tree , ti ) ;\n break ;\n case CS0 | Q931_IE_INFORMATION_RATE : dissect_q931_information_rate_ie ( tvb , pinfo , offset + 2 , info_element_len , ie_tree , ti ) ;\n break ;\n case CS0 | Q931_IE_E2E_TRANSIT_DELAY : dissect_q931_e2e_transit_delay_ie ( tvb , pinfo , offset + 2 , info_element_len , ie_tree , ti ) ;\n break ;\n case CS0 | Q931_IE_TD_SELECTION_AND_INT : dissect_q931_td_selection_and_int_ie ( tvb , pinfo , offset + 2 , info_element_len , ie_tree , ti ) ;\n break ;\n case CS0 | Q931_IE_PL_BINARY_PARAMETERS : if ( q931_tree != NULL ) {\n dissect_q931_pl_binary_parameters_ie ( tvb , offset + 2 , info_element_len , ie_tree ) ;\n }\n break ;\n case CS0 | Q931_IE_PL_WINDOW_SIZE : if ( q931_tree != NULL ) {\n dissect_q931_pl_window_size_ie ( tvb , offset + 2 , info_element_len , ie_tree ) ;\n }\n break ;\n case CS0 | Q931_IE_PACKET_SIZE : if ( q931_tree != NULL ) {\n dissect_q931_packet_size_ie ( tvb , offset + 2 , info_element_len , ie_tree ) ;\n }\n break ;\n case CS0 | Q931_IE_CUG : if ( q931_tree != NULL ) {\n dissect_q931_cug_ie ( tvb , offset + 2 , info_element_len , ie_tree ) ;\n }\n break ;\n case CS0 | Q931_IE_REVERSE_CHARGE_IND : if ( q931_tree != NULL ) {\n dissect_q931_reverse_charge_ind_ie ( tvb , offset + 2 , info_element_len , ie_tree ) ;\n }\n break ;\n case CS0 | Q931_IE_CONNECTED_NUMBER_DEFAULT : if ( q931_tree != NULL ) {\n dissect_q931_number_ie ( tvb , offset + 2 , info_element_len , ie_tree , hf_q931_connected_number , e164_info , q931_pi ) ;\n }\n break ;\n case CS0 | Q931_IE_CALLING_PARTY_NUMBER : e164_info . e164_number_type = CALLING_PARTY_NUMBER ;\n dissect_q931_number_ie ( tvb , offset + 2 , info_element_len , ie_tree , hf_q931_calling_party_number , e164_info , q931_pi ) ;\n break ;\n case CS0 | Q931_IE_CALLED_PARTY_NUMBER : e164_info . e164_number_type = CALLED_PARTY_NUMBER ;\n dissect_q931_number_ie ( tvb , offset + 2 , info_element_len , ie_tree , hf_q931_called_party_number , e164_info , q931_pi ) ;\n break ;\n case CS0 | Q931_IE_CALLING_PARTY_SUBADDR : case CS0 | Q931_IE_CALLED_PARTY_SUBADDR : if ( q931_tree != NULL ) {\n dissect_q931_party_subaddr_ie ( tvb , offset + 2 , info_element_len , ie_tree ) ;\n }\n break ;\n case CS0 | Q931_IE_REDIRECTING_NUMBER : if ( q931_tree != NULL ) {\n dissect_q931_number_ie ( tvb , offset + 2 , info_element_len , ie_tree , hf_q931_redirecting_number , e164_info , q931_pi ) ;\n }\n break ;\n case CS0 | Q931_IE_RESTART_INDICATOR : dissect_q931_restart_indicator_ie ( tvb , pinfo , offset + 2 , info_element_len , ie_tree , ti ) ;\n break ;\n case CS0 | Q931_IE_HIGH_LAYER_COMPAT : if ( q931_tree != NULL ) {\n dissect_q931_high_layer_compat_ie ( tvb , offset + 2 , info_element_len , ie_tree ) ;\n }\n break ;\n case CS0 | Q931_IE_USER_USER : if ( q931_tree != NULL ) {\n dissect_q931_user_user_ie ( tvb , pinfo , offset + 2 , info_element_len , ie_tree ) ;\n }\n break ;\n case CS5 | Q931_IE_PARTY_CATEGORY : if ( q931_tree != NULL ) {\n dissect_q931_party_category_ie ( tvb , offset + 2 , info_element_len , ie_tree ) ;\n }\n break ;\n case CS6 | Q931_IE_DISPLAY : if ( q931_tree != NULL ) {\n dissect_q931_ia5_ie ( tvb , offset + 2 , info_element_len , ie_tree , hf_q931_avaya_display ) ;\n }\n break ;\n default : if ( q931_tree != NULL ) {\n proto_tree_add_item ( ie_tree , hf_q931_data , tvb , offset + 2 , info_element_len , ENC_NA ) ;\n }\n break ;\n }\n }\n offset += 1 + 1 + info_element_len ;\n }\n codeset = locked_codeset ;\n }\n tap_queue_packet ( q931_tap , pinfo , q931_pi ) ;\n }", "idx": 489}
{"hash": 914926989019402478, "project": "debian", "size": 42, "label": 0, "functionSource": "static int main_recompress_output ( main_file * ofile ) {\n pid_t recomp_id ;\n int pipefd [ 2 ] ;\n int output_fd = - 1 ;\n int ret ;\n const main_extcomp * recomp = ofile -> compressor ;\n pipefd [ 0 ] = pipefd [ 1 ] = - 1 ;\n if ( pipe ( pipefd ) ) {\n XPR ( NT \"pipe failed: %s\\n\" , xd3_mainerror ( ret = get_errno ( ) ) ) ;\n goto pipe_cleanup ;\n }\n if ( ( recomp_id = fork ( ) ) < 0 ) {\n XPR ( NT \"fork failed: %s\\n\" , xd3_mainerror ( ret = get_errno ( ) ) ) ;\n goto pipe_cleanup ;\n }\n if ( recomp_id == 0 ) {\n if ( option_verbose > 2 ) {\n XPR ( NT \"external recompression pid %d\\n\" , getpid ( ) ) ;\n }\n if ( dup2 ( XFNO ( ofile ) , STDOUT_FILENO ) < 0 || dup2 ( pipefd [ PIPE_READ_FD ] , STDIN_FILENO ) < 0 || close ( pipefd [ PIPE_READ_FD ] ) || close ( pipefd [ PIPE_WRITE_FD ] ) || execlp ( recomp -> recomp_cmdname , recomp -> recomp_cmdname , recomp -> recomp_options , option_force2 ? \"-f\" : NULL , NULL ) ) {\n XPR ( NT \"child process %s failed to execute: %s\\n\" , recomp -> recomp_cmdname , xd3_mainerror ( get_errno ( ) ) ) ;\n }\n _exit ( 127 ) ;\n }\n XD3_ASSERT ( num_subprocs < MAX_SUBPROCS ) ;\n ext_subprocs [ num_subprocs ++ ] = recomp_id ;\n output_fd = dup ( pipefd [ PIPE_WRITE_FD ] ) ;\n if ( output_fd < 0 || main_file_close ( ofile ) || close ( pipefd [ PIPE_READ_FD ] ) || close ( pipefd [ PIPE_WRITE_FD ] ) ) {\n XPR ( NT \"close failed: %s\\n\" , xd3_mainerror ( ret = get_errno ( ) ) ) ;\n goto pipe_cleanup ;\n }\n # if XD3_STDIO if ( ( ofile -> file = fdopen ( output_fd , \"w\" ) ) == NULL ) {\n XPR ( NT \"fdopen failed: %s\\n\" , xd3_mainerror ( ret = get_errno ( ) ) ) ;\n goto pipe_cleanup ;\n }\n # elif XD3_POSIX ofile -> file = output_fd ;\n # endif return 0 ;\n pipe_cleanup : close ( output_fd ) ;\n close ( pipefd [ PIPE_READ_FD ] ) ;\n close ( pipefd [ PIPE_WRITE_FD ] ) ;\n return ret ;\n }", "idx": 490}
{"hash": -5717349108307169967, "project": "debian", "size": 25, "label": 0, "functionSource": "static void read_vec_pos ( GetBitContext * gb , int * vec_pos , int * sel_flag , int * sel_len , int * prev ) {\n int i , y_flag = 0 ;\n for ( i = 2 ;\n i >= 0 ;\n i -- ) {\n if ( ! sel_flag [ i ] ) {\n vec_pos [ i ] = 0 ;\n continue ;\n }\n if ( ( ! i && ! y_flag ) || get_bits1 ( gb ) ) {\n if ( sel_len [ i ] > 0 ) {\n int pval = prev [ i ] ;\n vec_pos [ i ] = get_bits ( gb , sel_len [ i ] ) ;\n if ( vec_pos [ i ] >= pval ) vec_pos [ i ] ++ ;\n }\n else {\n vec_pos [ i ] = ! prev [ i ] ;\n }\n y_flag = 1 ;\n }\n else {\n vec_pos [ i ] = prev [ i ] ;\n }\n }\n }", "idx": 491}
{"hash": 8127806390163862344, "project": "debian", "size": 3, "label": 0, "functionSource": "static uint8_t modrm_reg ( uint8_t modrm ) {\n return ( modrm >> 3 ) & 7 ;\n }", "idx": 492}
{"hash": -8554791788564546469, "project": "debian", "size": 10, "label": 1, "functionSource": "file_transfer_t * imcb_file_send_start ( struct im_connection * ic , char * handle , char * file_name , size_t file_size ) {\n bee_t * bee = ic -> bee ;\n bee_user_t * bu = bee_user_by_handle ( bee , ic , handle ) ;\n if ( bee -> ui -> ft_in_start ) {\n return bee -> ui -> ft_in_start ( bee , bu , file_name , file_size ) ;\n }\n else {\n return NULL ;\n }\n }", "idx": 493}
{"hash": -5420171864670538459, "project": "debian", "size": 11, "label": 0, "functionSource": "static bool all_cpu_threads_idle ( void ) {\n CPUArchState * env ;\n for ( env = first_cpu ;\n env != NULL ;\n env = env -> next_cpu ) {\n if ( ! cpu_thread_is_idle ( ENV_GET_CPU ( env ) ) ) {\n return false ;\n }\n }\n return true ;\n }", "idx": 494}
{"hash": -8934524072451888241, "project": "debian", "size": 4, "label": 0, "functionSource": "inline static bool is_request_conditional ( HTTPHdr * header ) {\n uint64_t mask = ( MIME_PRESENCE_IF_UNMODIFIED_SINCE | MIME_PRESENCE_IF_MODIFIED_SINCE | MIME_PRESENCE_IF_RANGE | MIME_PRESENCE_IF_MATCH | MIME_PRESENCE_IF_NONE_MATCH ) ;\n return ( header -> presence ( mask ) && ( header -> method_get_wksidx ( ) == HTTP_WKSIDX_GET || header -> method_get_wksidx ( ) == HTTP_WKSIDX_HEAD ) ) ;\n }", "idx": 495}
{"hash": -8925552398357902286, "project": "chrome", "size": 38, "label": 1, "functionSource": "void vp9_tokenize_initialize ( ) {\n TOKENVALUE * const t = dct_value_tokens + DCT_MAX_VALUE ;\n const vp9_extra_bit * const e = vp9_extra_bits ;\n int i = - DCT_MAX_VALUE ;\n int sign = 1 ;\n do {\n if ( ! i ) sign = 0 ;\n {\n const int a = sign ? - i : i ;\n int eb = sign ;\n if ( a > 4 ) {\n int j = 4 ;\n while ( ++ j < 11 && e [ j ] . base_val <= a ) {\n }\n t [ i ] . token = -- j ;\n eb |= ( a - e [ j ] . base_val ) << 1 ;\n }\n else {\n t [ i ] . token = a ;\n }\n t [ i ] . extra = eb ;\n }\n {\n int cost = 0 ;\n const vp9_extra_bit * p = & vp9_extra_bits [ t [ i ] . token ] ;\n if ( p -> base_val ) {\n const int extra = t [ i ] . extra ;\n const int length = p -> len ;\n if ( length ) cost += treed_cost ( p -> tree , p -> prob , extra >> 1 , length ) ;\n cost += vp9_cost_bit ( vp9_prob_half , extra & 1 ) ;\n dct_value_cost [ i + DCT_MAX_VALUE ] = cost ;\n }\n }\n }\n while ( ++ i < DCT_MAX_VALUE ) ;\n vp9_dct_value_tokens_ptr = dct_value_tokens + DCT_MAX_VALUE ;\n vp9_dct_value_cost_ptr = dct_value_cost + DCT_MAX_VALUE ;\n }", "idx": 496}
{"hash": -3165961362620712443, "project": "chrome", "size": 60, "label": 0, "functionSource": "static bool decompose_indic ( const hb_ot_shape_normalize_context_t * c , hb_codepoint_t ab , hb_codepoint_t * a , hb_codepoint_t * b ) {\n switch ( ab ) {\n case 0x0931u : return false ;\n case 0x0B94u : return false ;\n case 0x0F77u : * a = 0x0FB2u ;\n * b = 0x0F81u ;\n return true ;\n case 0x0F79u : * a = 0x0FB3u ;\n * b = 0x0F81u ;\n return true ;\n case 0x17BEu : * a = 0x17C1u ;\n * b = 0x17BEu ;\n return true ;\n case 0x17BFu : * a = 0x17C1u ;\n * b = 0x17BFu ;\n return true ;\n case 0x17C0u : * a = 0x17C1u ;\n * b = 0x17C0u ;\n return true ;\n case 0x17C4u : * a = 0x17C1u ;\n * b = 0x17C4u ;\n return true ;\n case 0x17C5u : * a = 0x17C1u ;\n * b = 0x17C5u ;\n return true ;\n case 0x1925u : * a = 0x1920u ;\n * b = 0x1923u ;\n return true ;\n case 0x1926u : * a = 0x1920u ;\n * b = 0x1924u ;\n return true ;\n case 0x1B3Cu : * a = 0x1B42u ;\n * b = 0x1B3Cu ;\n return true ;\n case 0x1112Eu : * a = 0x11127u ;\n * b = 0x11131u ;\n return true ;\n case 0x1112Fu : * a = 0x11127u ;\n * b = 0x11132u ;\n return true ;\n # if 0 case 0x0B57u : * a = no decomp , -> RIGHT ;\n return true ;\n case 0x1C29u : * a = no decomp , -> LEFT ;\n return true ;\n case 0xA9C0u : * a = no decomp , -> RIGHT ;\n return true ;\n case 0x111BuF : * a = no decomp , -> ABOVE ;\n return true ;\n # endif }\n if ( ( ab == 0x0DDAu || hb_in_range ( ab , 0x0DDCu , 0x0DDEu ) ) ) {\n const indic_shape_plan_t * indic_plan = ( const indic_shape_plan_t * ) c -> plan -> data ;\n hb_codepoint_t glyph ;\n if ( hb_options ( ) . uniscribe_bug_compatible || ( c -> font -> get_glyph ( ab , 0 , & glyph ) && indic_plan -> pstf . would_substitute ( & glyph , 1 , c -> font -> face ) ) ) {\n * a = 0x0DD9u ;\n * b = ab ;\n return true ;\n }\n }\n return c -> unicode -> decompose ( ab , a , b ) ;\n }", "idx": 497}
{"hash": -275948070528829821, "project": "debian", "size": 4, "label": 0, "functionSource": "static void HtmlCopy ( char * * ppsz_html , char * * ppsz_subtitle , const char * psz_text ) {\n HtmlPut ( ppsz_html , psz_text ) ;\n * ppsz_subtitle += strlen ( psz_text ) ;\n }", "idx": 498}
{"hash": -7777331401175181229, "project": "debian", "size": 9, "label": 0, "functionSource": "static void cmd_server_connect ( const char * data ) {\n GHashTable * optlist ;\n char * addr ;\n void * free_arg ;\n if ( ! cmd_get_params ( data , & free_arg , 1 | PARAM_FLAG_OPTIONS , \"connect\" , & optlist , & addr ) ) return ;\n if ( * addr == '\\0' || g_strcmp0 ( addr , \"+\" ) == 0 ) cmd_param_error ( CMDERR_NOT_ENOUGH_PARAMS ) ;\n if ( * addr == '+' ) window_create ( NULL , FALSE ) ;\n cmd_params_free ( free_arg ) ;\n }", "idx": 499}
{"hash": -3740862514502467070, "project": "debian", "size": 4, "label": 0, "functionSource": "static int tagcomp ( const void * _t1 , const void * _t2 ) {\n struct taboff * t1 = * ( ( struct taboff * * ) _t1 ) , * t2 = * ( ( struct taboff * * ) _t2 ) ;\n return ( ( int ) ( t1 -> tag - t2 -> tag ) ) ;\n }", "idx": 500}
{"hash": -5952453487978309155, "project": "chrome", "size": 4, "label": 0, "functionSource": "void vp8_regular_quantize_b_pair ( BLOCK * b1 , BLOCK * b2 , BLOCKD * d1 , BLOCKD * d2 ) {\n vp8_regular_quantize_b ( b1 , d1 ) ;\n vp8_regular_quantize_b ( b2 , d2 ) ;\n }", "idx": 501}
{"hash": -6024601983167898950, "project": "debian", "size": 10, "label": 0, "functionSource": "static int file_compare_by_parent_uri ( NautilusFile * file_a , NautilusFile * file_b ) {\n char * parent_uri_a , * parent_uri_b ;\n int ret ;\n parent_uri_a = nautilus_file_get_parent_uri ( file_a ) ;\n parent_uri_b = nautilus_file_get_parent_uri ( file_b ) ;\n ret = strcmp ( parent_uri_a , parent_uri_b ) ;\n g_free ( parent_uri_a ) ;\n g_free ( parent_uri_b ) ;\n return ret ;\n }", "idx": 502}
{"hash": -4558261210024070448, "project": "chrome", "size": 20, "label": 0, "functionSource": "xmlListPtr xmlListCreate ( xmlListDeallocator deallocator , xmlListDataCompare compare ) {\n xmlListPtr l ;\n if ( NULL == ( l = ( xmlListPtr ) xmlMalloc ( sizeof ( xmlList ) ) ) ) {\n xmlGenericError ( xmlGenericErrorContext , \"Cannot initialize memory for list\" ) ;\n return ( NULL ) ;\n }\n memset ( l , 0 , sizeof ( xmlList ) ) ;\n if ( NULL == ( l -> sentinel = ( xmlLinkPtr ) xmlMalloc ( sizeof ( xmlLink ) ) ) ) {\n xmlGenericError ( xmlGenericErrorContext , \"Cannot initialize memory for sentinel\" ) ;\n xmlFree ( l ) ;\n return ( NULL ) ;\n }\n l -> sentinel -> next = l -> sentinel ;\n l -> sentinel -> prev = l -> sentinel ;\n l -> sentinel -> data = NULL ;\n if ( deallocator != NULL ) l -> linkDeallocator = deallocator ;\n if ( compare != NULL ) l -> linkCompare = compare ;\n else l -> linkCompare = xmlLinkCompare ;\n return l ;\n }", "idx": 503}
{"hash": -5268859819325807498, "project": "debian", "size": 16, "label": 0, "functionSource": "static void deep_count_state_free ( DeepCountState * state ) {\n if ( state -> enumerator ) {\n if ( ! g_file_enumerator_is_closed ( state -> enumerator ) ) {\n g_file_enumerator_close_async ( state -> enumerator , 0 , NULL , NULL , NULL ) ;\n }\n g_object_unref ( state -> enumerator ) ;\n }\n g_object_unref ( state -> cancellable ) ;\n if ( state -> deep_count_location ) {\n g_object_unref ( state -> deep_count_location ) ;\n }\n g_list_free_full ( state -> deep_count_subdirectories , g_object_unref ) ;\n g_array_free ( state -> seen_deep_count_inodes , TRUE ) ;\n g_free ( state -> fs_id ) ;\n g_free ( state ) ;\n }", "idx": 504}
{"hash": -1929262071302712016, "project": "debian", "size": 11, "label": 0, "functionSource": "static cmsBool Type_MPEcurve_Write ( struct _cms_typehandler_struct * self , cmsIOHANDLER * io , void * Ptr , cmsUInt32Number nItems ) {\n cmsUInt32Number BaseOffset ;\n cmsStage * mpe = ( cmsStage * ) Ptr ;\n _cmsStageToneCurvesData * Curves = ( _cmsStageToneCurvesData * ) mpe -> Data ;\n BaseOffset = io -> Tell ( io ) - sizeof ( _cmsTagBase ) ;\n if ( ! _cmsWriteUInt16Number ( io , ( cmsUInt16Number ) mpe -> InputChannels ) ) return FALSE ;\n if ( ! _cmsWriteUInt16Number ( io , ( cmsUInt16Number ) mpe -> InputChannels ) ) return FALSE ;\n if ( ! WritePositionTable ( self , io , 0 , mpe -> InputChannels , BaseOffset , Curves , WriteMPECurve ) ) return FALSE ;\n return TRUE ;\n cmsUNUSED_PARAMETER ( nItems ) ;\n }", "idx": 505}
{"hash": -4765077557530511796, "project": "chrome", "size": 30, "label": 0, "functionSource": "static int ogg_new_stream ( AVFormatContext * s , uint32_t serial ) {\n struct ogg * ogg = s -> priv_data ;\n int idx = ogg -> nstreams ;\n AVStream * st ;\n struct ogg_stream * os ;\n size_t size ;\n if ( ogg -> state ) {\n av_log ( s , AV_LOG_ERROR , \"New streams are not supposed to be added \" \"in between Ogg context save/restore operations.\\n\" ) ;\n return AVERROR_BUG ;\n }\n if ( av_size_mult ( ogg -> nstreams + 1 , sizeof ( * ogg -> streams ) , & size ) < 0 || ! ( os = av_realloc ( ogg -> streams , size ) ) ) return AVERROR ( ENOMEM ) ;\n ogg -> streams = os ;\n os = ogg -> streams + idx ;\n memset ( os , 0 , sizeof ( * os ) ) ;\n os -> serial = serial ;\n os -> bufsize = DECODER_BUFFER_SIZE ;\n os -> buf = av_malloc ( os -> bufsize + AV_INPUT_BUFFER_PADDING_SIZE ) ;\n os -> header = - 1 ;\n os -> start_granule = OGG_NOGRANULE_VALUE ;\n if ( ! os -> buf ) return AVERROR ( ENOMEM ) ;\n st = avformat_new_stream ( s , NULL ) ;\n if ( ! st ) {\n av_freep ( & os -> buf ) ;\n return AVERROR ( ENOMEM ) ;\n }\n st -> id = idx ;\n avpriv_set_pts_info ( st , 64 , 1 , 1000000 ) ;\n ogg -> nstreams ++ ;\n return idx ;\n }", "idx": 506}
{"hash": 355220887711506893, "project": "debian", "size": 3, "label": 0, "functionSource": "Datum nlikesel ( PG_FUNCTION_ARGS ) {\n PG_RETURN_FLOAT8 ( patternsel ( fcinfo , Pattern_Type_Like , true ) ) ;\n }", "idx": 507}
{"hash": -8028756826159773630, "project": "debian", "size": 16, "label": 0, "functionSource": "static void processEncodingEntry ( ArchiveHandle * AH , TocEntry * te ) {\n char * defn = pg_strdup ( te -> defn ) ;\n char * ptr1 ;\n char * ptr2 = NULL ;\n int encoding ;\n ptr1 = strchr ( defn , '\\'' ) ;\n if ( ptr1 ) ptr2 = strchr ( ++ ptr1 , '\\'' ) ;\n if ( ptr2 ) {\n * ptr2 = '\\0' ;\n encoding = pg_char_to_encoding ( ptr1 ) ;\n if ( encoding < 0 ) exit_horribly ( modulename , \"unrecognized encoding \\\"%s\\\"\\n\" , ptr1 ) ;\n AH -> public . encoding = encoding ;\n }\n else exit_horribly ( modulename , \"invalid ENCODING item: %s\\n\" , te -> defn ) ;\n free ( defn ) ;\n }", "idx": 508}
{"hash": 1182028467273264883, "project": "debian", "size": 35, "label": 0, "functionSource": "void append_field ( DYNAMIC_STRING * ds , uint col_idx , MYSQL_FIELD * field , char * val , ulonglong len , my_bool is_null ) {\n char null [ ] = \"NULL\" ;\n if ( col_idx < max_replace_column && replace_column [ col_idx ] ) {\n val = replace_column [ col_idx ] ;\n len = strlen ( val ) ;\n }\n else if ( is_null ) {\n val = null ;\n len = 4 ;\n }\n # ifdef __WIN__ else if ( ( field -> type == MYSQL_TYPE_DOUBLE || field -> type == MYSQL_TYPE_FLOAT ) && field -> decimals >= 31 ) {\n char * start = strchr ( val , 'e' ) ;\n if ( start && strlen ( start ) >= 5 && ( start [ 1 ] == '-' || start [ 1 ] == '+' ) && start [ 2 ] == '0' ) {\n start += 2 ;\n if ( field -> flags & ZEROFILL_FLAG ) {\n memmove ( val + 1 , val , start - val ) ;\n * val = '0' ;\n }\n else {\n memmove ( start , start + 1 , strlen ( start ) ) ;\n len -- ;\n }\n }\n }\n # endif if ( ! display_result_vertically ) {\n if ( col_idx ) dynstr_append_mem ( ds , \"\\t\" , 1 ) ;\n replace_dynstr_append_mem ( ds , val , ( int ) len ) ;\n }\n else {\n dynstr_append ( ds , field -> name ) ;\n dynstr_append_mem ( ds , \"\\t\" , 1 ) ;\n replace_dynstr_append_mem ( ds , val , ( int ) len ) ;\n dynstr_append_mem ( ds , \"\\n\" , 1 ) ;\n }\n }", "idx": 509}
{"hash": 5917118798851365454, "project": "debian", "size": 10, "label": 0, "functionSource": "static void decode_zcl_appl_stats_utc_time ( gchar * s , guint32 value ) {\n if ( value == ZBEE_ZCL_APPL_STATS_INVALID_TIME ) g_snprintf ( s , ITEM_LABEL_LENGTH , \"Invalid UTC Time\" ) ;\n else {\n gchar * utc_time ;\n value += ZBEE_ZCL_NSTIME_UTC_OFFSET ;\n utc_time = abs_time_secs_to_str ( NULL , value , ABSOLUTE_TIME_LOCAL , TRUE ) ;\n g_snprintf ( s , ITEM_LABEL_LENGTH , \"%s\" , utc_time ) ;\n wmem_free ( NULL , utc_time ) ;\n }\n }", "idx": 510}
{"hash": 1245821301839614810, "project": "debian", "size": 77, "label": 0, "functionSource": "static void report_trash_progress ( CommonJob * job , SourceInfo * source_info , TransferInfo * transfer_info ) {\n int files_left ;\n double elapsed , transfer_rate ;\n int remaining_time ;\n gint64 now ;\n char * details ;\n char * status ;\n DeleteJob * delete_job ;\n delete_job = ( DeleteJob * ) job ;\n now = g_get_monotonic_time ( ) ;\n files_left = source_info -> num_files - transfer_info -> num_files ;\n if ( files_left < 0 ) {\n files_left = 0 ;\n }\n if ( transfer_info -> last_report_time != 0 && ABS ( ( gint64 ) ( transfer_info -> last_report_time - now ) ) < 100 * NSEC_PER_MICROSEC && files_left > 0 ) {\n return ;\n }\n transfer_info -> last_report_time = now ;\n if ( source_info -> num_files == 1 ) {\n if ( files_left > 0 ) {\n status = _ ( \"Trashing \u201c%B\u201d\" ) ;\n }\n else {\n status = _ ( \"Trashed \u201c%B\u201d\" ) ;\n }\n nautilus_progress_info_take_status ( job -> progress , f ( status , ( GFile * ) delete_job -> files -> data ) ) ;\n }\n else {\n if ( files_left > 0 ) {\n status = ngettext ( \"Trashing %'d file\" , \"Trashing %'d files\" , source_info -> num_files ) ;\n }\n else {\n status = ngettext ( \"Trashed %'d file\" , \"Trashed %'d files\" , source_info -> num_files ) ;\n }\n nautilus_progress_info_take_status ( job -> progress , f ( status , source_info -> num_files ) ) ;\n }\n elapsed = g_timer_elapsed ( job -> time , NULL ) ;\n transfer_rate = 0 ;\n remaining_time = INT_MAX ;\n if ( elapsed > 0 ) {\n transfer_rate = transfer_info -> num_files / elapsed ;\n if ( transfer_rate > 0 ) {\n remaining_time = ( source_info -> num_files - transfer_info -> num_files ) / transfer_rate ;\n }\n }\n if ( elapsed < SECONDS_NEEDED_FOR_RELIABLE_TRANSFER_RATE ) {\n if ( files_left > 0 ) {\n details = f ( _ ( \"%'d / %'d\" ) , transfer_info -> num_files + 1 , source_info -> num_files ) ;\n }\n else {\n details = f ( _ ( \"%'d / %'d\" ) , transfer_info -> num_files , source_info -> num_files ) ;\n }\n }\n else {\n if ( files_left > 0 ) {\n gchar * time_left_message ;\n gchar * files_per_second_message ;\n gchar * concat_detail ;\n time_left_message = ngettext ( \"%'d / %'d \\xE2\\x80\\x94 %T left\" , \"%'d / %'d \\xE2\\x80\\x94 %T left\" , seconds_count_format_time_units ( remaining_time ) ) ;\n files_per_second_message = ngettext ( \"(%d file/sec)\" , \"(%d files/sec)\" , ( int ) ( transfer_rate + 0.5 ) ) ;\n concat_detail = g_strconcat ( time_left_message , \" \" , files_per_second_message , NULL ) ;\n details = f ( concat_detail , transfer_info -> num_files + 1 , source_info -> num_files , remaining_time , ( int ) transfer_rate + 0.5 ) ;\n g_free ( concat_detail ) ;\n }\n else {\n details = f ( _ ( \"%'d / %'d\" ) , transfer_info -> num_files , source_info -> num_files ) ;\n }\n }\n nautilus_progress_info_set_details ( job -> progress , details ) ;\n if ( elapsed > SECONDS_NEEDED_FOR_APROXIMATE_TRANSFER_RATE ) {\n nautilus_progress_info_set_remaining_time ( job -> progress , remaining_time ) ;\n nautilus_progress_info_set_elapsed_time ( job -> progress , elapsed ) ;\n }\n if ( source_info -> num_files != 0 ) {\n nautilus_progress_info_set_progress ( job -> progress , transfer_info -> num_files , source_info -> num_files ) ;\n }\n }", "idx": 511}
{"hash": -1483849844579170895, "project": "chrome", "size": 93, "label": 0, "functionSource": "static void find_mismatch ( const vpx_image_t * const img1 , const vpx_image_t * const img2 , int yloc [ 4 ] , int uloc [ 4 ] , int vloc [ 4 ] ) {\n const uint32_t bsize = 64 ;\n const uint32_t bsizey = bsize >> img1 -> y_chroma_shift ;\n const uint32_t bsizex = bsize >> img1 -> x_chroma_shift ;\n const uint32_t c_w = ( img1 -> d_w + img1 -> x_chroma_shift ) >> img1 -> x_chroma_shift ;\n const uint32_t c_h = ( img1 -> d_h + img1 -> y_chroma_shift ) >> img1 -> y_chroma_shift ;\n int match = 1 ;\n uint32_t i , j ;\n yloc [ 0 ] = yloc [ 1 ] = yloc [ 2 ] = yloc [ 3 ] = - 1 ;\n for ( i = 0 , match = 1 ;\n match && i < img1 -> d_h ;\n i += bsize ) {\n for ( j = 0 ;\n match && j < img1 -> d_w ;\n j += bsize ) {\n int k , l ;\n const int si = mmin ( i + bsize , img1 -> d_h ) - i ;\n const int sj = mmin ( j + bsize , img1 -> d_w ) - j ;\n for ( k = 0 ;\n match && k < si ;\n ++ k ) {\n for ( l = 0 ;\n match && l < sj ;\n ++ l ) {\n if ( * ( img1 -> planes [ VPX_PLANE_Y ] + ( i + k ) * img1 -> stride [ VPX_PLANE_Y ] + j + l ) != * ( img2 -> planes [ VPX_PLANE_Y ] + ( i + k ) * img2 -> stride [ VPX_PLANE_Y ] + j + l ) ) {\n yloc [ 0 ] = i + k ;\n yloc [ 1 ] = j + l ;\n yloc [ 2 ] = * ( img1 -> planes [ VPX_PLANE_Y ] + ( i + k ) * img1 -> stride [ VPX_PLANE_Y ] + j + l ) ;\n yloc [ 3 ] = * ( img2 -> planes [ VPX_PLANE_Y ] + ( i + k ) * img2 -> stride [ VPX_PLANE_Y ] + j + l ) ;\n match = 0 ;\n break ;\n }\n }\n }\n }\n }\n uloc [ 0 ] = uloc [ 1 ] = uloc [ 2 ] = uloc [ 3 ] = - 1 ;\n for ( i = 0 , match = 1 ;\n match && i < c_h ;\n i += bsizey ) {\n for ( j = 0 ;\n match && j < c_w ;\n j += bsizex ) {\n int k , l ;\n const int si = mmin ( i + bsizey , c_h - i ) ;\n const int sj = mmin ( j + bsizex , c_w - j ) ;\n for ( k = 0 ;\n match && k < si ;\n ++ k ) {\n for ( l = 0 ;\n match && l < sj ;\n ++ l ) {\n if ( * ( img1 -> planes [ VPX_PLANE_U ] + ( i + k ) * img1 -> stride [ VPX_PLANE_U ] + j + l ) != * ( img2 -> planes [ VPX_PLANE_U ] + ( i + k ) * img2 -> stride [ VPX_PLANE_U ] + j + l ) ) {\n uloc [ 0 ] = i + k ;\n uloc [ 1 ] = j + l ;\n uloc [ 2 ] = * ( img1 -> planes [ VPX_PLANE_U ] + ( i + k ) * img1 -> stride [ VPX_PLANE_U ] + j + l ) ;\n uloc [ 3 ] = * ( img2 -> planes [ VPX_PLANE_U ] + ( i + k ) * img2 -> stride [ VPX_PLANE_U ] + j + l ) ;\n match = 0 ;\n break ;\n }\n }\n }\n }\n }\n vloc [ 0 ] = vloc [ 1 ] = vloc [ 2 ] = vloc [ 3 ] = - 1 ;\n for ( i = 0 , match = 1 ;\n match && i < c_h ;\n i += bsizey ) {\n for ( j = 0 ;\n match && j < c_w ;\n j += bsizex ) {\n int k , l ;\n const int si = mmin ( i + bsizey , c_h - i ) ;\n const int sj = mmin ( j + bsizex , c_w - j ) ;\n for ( k = 0 ;\n match && k < si ;\n ++ k ) {\n for ( l = 0 ;\n match && l < sj ;\n ++ l ) {\n if ( * ( img1 -> planes [ VPX_PLANE_V ] + ( i + k ) * img1 -> stride [ VPX_PLANE_V ] + j + l ) != * ( img2 -> planes [ VPX_PLANE_V ] + ( i + k ) * img2 -> stride [ VPX_PLANE_V ] + j + l ) ) {\n vloc [ 0 ] = i + k ;\n vloc [ 1 ] = j + l ;\n vloc [ 2 ] = * ( img1 -> planes [ VPX_PLANE_V ] + ( i + k ) * img1 -> stride [ VPX_PLANE_V ] + j + l ) ;\n vloc [ 3 ] = * ( img2 -> planes [ VPX_PLANE_V ] + ( i + k ) * img2 -> stride [ VPX_PLANE_V ] + j + l ) ;\n match = 0 ;\n break ;\n }\n }\n }\n }\n }\n }", "idx": 512}
{"hash": 3599206110384554647, "project": "debian", "size": 27, "label": 0, "functionSource": "int PEM_write_bio_ ## name ( BIO * bp , type * x ) ;\n # define DECLARE_PEM_write_bio_const ( name , type ) int PEM_write_bio_ ## name ( BIO * bp , const type * x ) ;\n # define DECLARE_PEM_write_cb_bio ( name , type ) int PEM_write_bio_ ## name ( BIO * bp , type * x , const EVP_CIPHER * enc , unsigned char * kstr , int klen , pem_password_cb * cb , void * u ) ;\n # define DECLARE_PEM_write ( name , type ) DECLARE_PEM_write_bio ( name , type ) DECLARE_PEM_write_fp ( name , type ) # define DECLARE_PEM_write_const ( name , type ) DECLARE_PEM_write_bio_const ( name , type ) DECLARE_PEM_write_fp_const ( name , type ) # define DECLARE_PEM_write_cb ( name , type ) DECLARE_PEM_write_cb_bio ( name , type ) DECLARE_PEM_write_cb_fp ( name , type ) # define DECLARE_PEM_read ( name , type ) DECLARE_PEM_read_bio ( name , type ) DECLARE_PEM_read_fp ( name , type ) # define DECLARE_PEM_rw ( name , type ) DECLARE_PEM_read ( name , type ) DECLARE_PEM_write ( name , type ) # define DECLARE_PEM_rw_const ( name , type ) DECLARE_PEM_read ( name , type ) DECLARE_PEM_write_const ( name , type ) # define DECLARE_PEM_rw_cb ( name , type ) DECLARE_PEM_read ( name , type ) DECLARE_PEM_write_cb ( name , type ) typedef int pem_password_cb ( char * buf , int size , int rwflag , void * userdata ) ;\n int PEM_get_EVP_CIPHER_INFO ( char * header , EVP_CIPHER_INFO * cipher ) ;\n int PEM_do_header ( EVP_CIPHER_INFO * cipher , unsigned char * data , long * len , pem_password_cb * callback , void * u ) ;\n int PEM_read_bio ( BIO * bp , char * * name , char * * header , unsigned char * * data , long * len ) ;\n # define PEM_FLAG_SECURE 0x1 # define PEM_FLAG_EAY_COMPATIBLE 0x2 # define PEM_FLAG_ONLY_B64 0x4 int PEM_read_bio_ex ( BIO * bp , char * * name , char * * header , unsigned char * * data , long * len , unsigned int flags ) ;\n int PEM_bytes_read_bio_secmem ( unsigned char * * pdata , long * plen , char * * pnm , const char * name , BIO * bp , pem_password_cb * cb , void * u ) ;\n int PEM_write_bio ( BIO * bp , const char * name , const char * hdr , const unsigned char * data , long len ) ;\n int PEM_bytes_read_bio ( unsigned char * * pdata , long * plen , char * * pnm , const char * name , BIO * bp , pem_password_cb * cb , void * u ) ;\n void * PEM_ASN1_read_bio ( d2i_of_void * d2i , const char * name , BIO * bp , void * * x , pem_password_cb * cb , void * u ) ;\n int PEM_ASN1_write_bio ( i2d_of_void * i2d , const char * name , BIO * bp , void * x , const EVP_CIPHER * enc , unsigned char * kstr , int klen , pem_password_cb * cb , void * u ) ;\n STACK_OF ( X509_INFO ) * PEM_X509_INFO_read_bio ( BIO * bp , STACK_OF ( X509_INFO ) * sk , pem_password_cb * cb , void * u ) ;\n int PEM_X509_INFO_write_bio ( BIO * bp , X509_INFO * xi , EVP_CIPHER * enc , unsigned char * kstr , int klen , pem_password_cb * cd , void * u ) ;\n # ifndef OPENSSL_NO_STDIO int PEM_read ( FILE * fp , char * * name , char * * header , unsigned char * * data , long * len ) ;\n int PEM_write ( FILE * fp , const char * name , const char * hdr , const unsigned char * data , long len ) ;\n void * PEM_ASN1_read ( d2i_of_void * d2i , const char * name , FILE * fp , void * * x , pem_password_cb * cb , void * u ) ;\n int PEM_ASN1_write ( i2d_of_void * i2d , const char * name , FILE * fp , void * x , const EVP_CIPHER * enc , unsigned char * kstr , int klen , pem_password_cb * callback , void * u ) ;\n STACK_OF ( X509_INFO ) * PEM_X509_INFO_read ( FILE * fp , STACK_OF ( X509_INFO ) * sk , pem_password_cb * cb , void * u ) ;\n # endif int PEM_SignInit ( EVP_MD_CTX * ctx , EVP_MD * type ) ;\n int PEM_SignUpdate ( EVP_MD_CTX * ctx , unsigned char * d , unsigned int cnt ) ;\n int PEM_SignFinal ( EVP_MD_CTX * ctx , unsigned char * sigret , unsigned int * siglen , EVP_PKEY * pkey ) ;\n int PEM_def_callback ( char * buf , int num , int rwflag , void * userdata ) ;\n void PEM_proc_type ( char * buf , int type ) ;\n void PEM_dek_info ( char * buf , const char * type , int len , char * str ) ;\n # include < openssl / symhacks . h > DECLARE_PEM_rw ( X509 , X509 ) DECLARE_PEM_rw ( X509_AUX , X509 ) DECLARE_PEM_rw ( X509_REQ , X509_REQ ) DECLARE_PEM_write ( X509_REQ_NEW , X509_REQ ) DECLARE_PEM_rw ( X509_CRL , X509_CRL ) DECLARE_PEM_rw ( PKCS7 , PKCS7 ) DECLARE_PEM_rw ( NETSCAPE_CERT_SEQUENCE , NETSCAPE_CERT_SEQUENCE )", "idx": 513}
{"hash": 1949916022780590905, "project": "debian", "size": 53, "label": 0, "functionSource": "static inline picture_t * ffmpeg_NewPictBuf ( decoder_t * p_dec , AVCodecContext * p_context ) {\n decoder_sys_t * p_sys = p_dec -> p_sys ;\n int width = p_context -> coded_width ;\n int height = p_context -> coded_height ;\n if ( p_sys -> p_va == NULL ) {\n int aligns [ AV_NUM_DATA_POINTERS ] ;\n avcodec_align_dimensions2 ( p_context , & width , & height , aligns ) ;\n }\n if ( width == 0 || height == 0 || width > 8192 || height > 8192 || width < p_context -> width || height < p_context -> height ) {\n msg_Err ( p_dec , \"Invalid frame size %dx%d. vsz %dx%d\" , width , height , p_context -> width , p_context -> height ) ;\n return NULL ;\n }\n p_dec -> fmt_out . video . i_width = width ;\n p_dec -> fmt_out . video . i_height = height ;\n if ( width != p_context -> width || height != p_context -> height ) {\n p_dec -> fmt_out . video . i_visible_width = p_context -> width ;\n p_dec -> fmt_out . video . i_visible_height = p_context -> height ;\n }\n else {\n p_dec -> fmt_out . video . i_visible_width = width ;\n p_dec -> fmt_out . video . i_visible_height = height ;\n }\n if ( ! p_sys -> p_va && GetVlcChroma ( & p_dec -> fmt_out . video , p_context -> pix_fmt ) ) {\n p_dec -> fmt_out . video . i_chroma = VLC_CODEC_I420 ;\n }\n p_dec -> fmt_out . i_codec = p_dec -> fmt_out . video . i_chroma ;\n if ( p_dec -> fmt_in . video . i_sar_num > 0 && p_dec -> fmt_in . video . i_sar_den > 0 ) {\n p_dec -> fmt_out . video . i_sar_num = p_dec -> fmt_in . video . i_sar_num ;\n p_dec -> fmt_out . video . i_sar_den = p_dec -> fmt_in . video . i_sar_den ;\n }\n else {\n p_dec -> fmt_out . video . i_sar_num = p_context -> sample_aspect_ratio . num ;\n p_dec -> fmt_out . video . i_sar_den = p_context -> sample_aspect_ratio . den ;\n if ( ! p_dec -> fmt_out . video . i_sar_num || ! p_dec -> fmt_out . video . i_sar_den ) {\n p_dec -> fmt_out . video . i_sar_num = 1 ;\n p_dec -> fmt_out . video . i_sar_den = 1 ;\n }\n }\n if ( p_dec -> fmt_in . video . i_frame_rate > 0 && p_dec -> fmt_in . video . i_frame_rate_base > 0 ) {\n p_dec -> fmt_out . video . i_frame_rate = p_dec -> fmt_in . video . i_frame_rate ;\n p_dec -> fmt_out . video . i_frame_rate_base = p_dec -> fmt_in . video . i_frame_rate_base ;\n }\n # if LIBAVCODEC_VERSION_CHECK ( 56 , 5 , 0 , 7 , 100 ) else if ( p_context -> framerate . num > 0 && p_context -> framerate . den > 0 ) {\n p_dec -> fmt_out . video . i_frame_rate = p_context -> framerate . num ;\n p_dec -> fmt_out . video . i_frame_rate_base = p_context -> framerate . den ;\n # if LIBAVCODEC_VERSION_MICRO < 100 p_dec -> fmt_out . video . i_frame_rate_base *= __MAX ( p_context -> ticks_per_frame , 1 ) ;\n # endif }\n # endif else if ( p_context -> time_base . num > 0 && p_context -> time_base . den > 0 ) {\n p_dec -> fmt_out . video . i_frame_rate = p_context -> time_base . den ;\n p_dec -> fmt_out . video . i_frame_rate_base = p_context -> time_base . num * __MAX ( p_context -> ticks_per_frame , 1 ) ;\n }\n return decoder_NewPicture ( p_dec ) ;\n }", "idx": 514}
{"hash": -650231346353974279, "project": "debian", "size": 16, "label": 0, "functionSource": "void appendStringLiteralDQ ( PQExpBuffer buf , const char * str , const char * dqprefix ) {\n static const char suffixes [ ] = \"_XXXXXXX\" ;\n int nextchar = 0 ;\n PQExpBuffer delimBuf = createPQExpBuffer ( ) ;\n appendPQExpBufferChar ( delimBuf , '$' ) ;\n if ( dqprefix ) appendPQExpBufferStr ( delimBuf , dqprefix ) ;\n while ( strstr ( str , delimBuf -> data ) != NULL ) {\n appendPQExpBufferChar ( delimBuf , suffixes [ nextchar ++ ] ) ;\n nextchar %= sizeof ( suffixes ) - 1 ;\n }\n appendPQExpBufferChar ( delimBuf , '$' ) ;\n appendPQExpBufferStr ( buf , delimBuf -> data ) ;\n appendPQExpBufferStr ( buf , str ) ;\n appendPQExpBufferStr ( buf , delimBuf -> data ) ;\n destroyPQExpBuffer ( delimBuf ) ;\n }", "idx": 515}
{"hash": 7549435794356072684, "project": "debian", "size": 4, "label": 0, "functionSource": "static VALUE ossl_asn1_ ## klass ( int argc , VALUE * argv , VALUE self ) \\ {\n return rb_funcall3 ( cASN1 ## klass , rb_intern ( \"new\" ) , argc , argv ) ;\n }\n OSSL_ASN1_IMPL_FACTORY_METHOD ( Boolean ) OSSL_ASN1_IMPL_FACTORY_METHOD ( Integer ) OSSL_ASN1_IMPL_FACTORY_METHOD ( Enumerated ) OSSL_ASN1_IMPL_FACTORY_METHOD ( BitString ) OSSL_ASN1_IMPL_FACTORY_METHOD ( OctetString ) OSSL_ASN1_IMPL_FACTORY_METHOD ( UTF8String ) OSSL_ASN1_IMPL_FACTORY_METHOD ( NumericString ) OSSL_ASN1_IMPL_FACTORY_METHOD ( PrintableString ) OSSL_ASN1_IMPL_FACTORY_METHOD ( T61String ) OSSL_ASN1_IMPL_FACTORY_METHOD ( VideotexString ) OSSL_ASN1_IMPL_FACTORY_METHOD ( IA5String ) OSSL_ASN1_IMPL_FACTORY_METHOD ( GraphicString ) OSSL_ASN1_IMPL_FACTORY_METHOD ( ISO64String ) OSSL_ASN1_IMPL_FACTORY_METHOD ( GeneralString ) OSSL_ASN1_IMPL_FACTORY_METHOD ( UniversalString ) OSSL_ASN1_IMPL_FACTORY_METHOD ( BMPString )", "idx": 516}
{"hash": 5991533509192663951, "project": "debian", "size": 35, "label": 0, "functionSource": "static int mime_header_encoder_block_collector ( int c , void * data ) {\n int n ;\n struct mime_header_encoder_data * pe = ( struct mime_header_encoder_data * ) data ;\n switch ( pe -> status2 ) {\n case 1 : pe -> prevpos = pe -> outdev . pos ;\n mbfl_convert_filter_copy ( pe -> conv2_filter , pe -> conv2_filter_backup ) ;\n mbfl_convert_filter_copy ( pe -> encod_filter , pe -> encod_filter_backup ) ;\n ( * pe -> conv2_filter -> filter_function ) ( c , pe -> conv2_filter ) ;\n ( * pe -> conv2_filter -> filter_flush ) ( pe -> conv2_filter ) ;\n ( * pe -> encod_filter -> filter_flush ) ( pe -> encod_filter ) ;\n n = pe -> outdev . pos - pe -> linehead + pe -> firstindent ;\n pe -> outdev . pos = pe -> prevpos ;\n mbfl_convert_filter_copy ( pe -> conv2_filter_backup , pe -> conv2_filter ) ;\n mbfl_convert_filter_copy ( pe -> encod_filter_backup , pe -> encod_filter ) ;\n if ( n >= 74 ) {\n ( * pe -> conv2_filter -> filter_flush ) ( pe -> conv2_filter ) ;\n ( * pe -> encod_filter -> filter_flush ) ( pe -> encod_filter ) ;\n mbfl_memory_device_strncat ( & pe -> outdev , \"\\x3f\\x3d\" , 2 ) ;\n mbfl_memory_device_strncat ( & pe -> outdev , pe -> lwsp , pe -> lwsplen ) ;\n pe -> linehead = pe -> outdev . pos ;\n pe -> firstindent = 0 ;\n mbfl_memory_device_strncat ( & pe -> outdev , pe -> encname , pe -> encnamelen ) ;\n c = ( * pe -> conv2_filter -> filter_function ) ( c , pe -> conv2_filter ) ;\n }\n else {\n c = ( * pe -> conv2_filter -> filter_function ) ( c , pe -> conv2_filter ) ;\n }\n break ;\n default : mbfl_memory_device_strncat ( & pe -> outdev , pe -> encname , pe -> encnamelen ) ;\n c = ( * pe -> conv2_filter -> filter_function ) ( c , pe -> conv2_filter ) ;\n pe -> status2 = 1 ;\n break ;\n }\n return c ;\n }", "idx": 517}
{"hash": 3731043152202786975, "project": "debian", "size": 50, "label": 0, "functionSource": "int dump_msg_test ( char * code , FILE * fd , char header , char segregationLevel ) {\n unsigned short int i , j , l , m , msglen ;\n int k ;\n char r , * msg ;\n unsigned char * payload ;\n payload = ( unsigned char * ) code ;\n memcpy ( & i , code , 2 ) ;\n memcpy ( & j , & code [ MSG_START_IDX ] , 2 ) ;\n memcpy ( & msglen , & code [ MSG_LEN_IDX ] , 2 ) ;\n i = ntohs ( i ) ;\n j = ntohs ( j ) ;\n msglen = ntohs ( msglen ) ;\n if ( header == 0 ) {\n fwrite ( code , 1 , j + msglen , fd ) ;\n fwrite ( & theSignal , 1 , 4 , fd ) ;\n return 0 ;\n }\n msg = ( char * ) & payload [ j ] ;\n r = ( i < 100 ) ? 1 : 0 ;\n if ( r ) {\n if ( segregationLevel & ALSO_RURI ) {\n if ( ! ( segregationLevel & JUNIT ) ) {\n k = htonl ( payload [ REQUEST_URI_IDX + 1 ] + payload [ REQUEST_URI_IDX + 2 ] ) ;\n fwrite ( & k , 1 , 4 , fd ) ;\n fwrite ( msg , 1 , ntohl ( k ) , fd ) ;\n k = htonl ( ( long ) payload [ REQUEST_URI_IDX ] ) ;\n fwrite ( & k , 1 , 4 , fd ) ;\n fwrite ( & payload [ REQUEST_URI_IDX + 1 ] , 1 , payload [ REQUEST_URI_IDX ] , fd ) ;\n fwrite ( & theSignal , 1 , 4 , fd ) ;\n }\n else print_uri_junit_tests ( msg , payload [ REQUEST_URI_IDX + 1 ] + payload [ REQUEST_URI_IDX + 2 ] , & payload [ REQUEST_URI_IDX + 1 ] , payload [ REQUEST_URI_IDX ] , fd , 1 , \"\" ) ;\n }\n i = REQUEST_URI_IDX + 1 + payload [ REQUEST_URI_IDX ] ;\n }\n else {\n i = REQUEST_URI_IDX ;\n }\n j = payload [ i ] ;\n i ++ ;\n for ( k = i ;\n k < i + ( j * 3 ) ;\n k += 3 ) {\n memcpy ( & l , & payload [ k + 1 ] , 2 ) ;\n memcpy ( & m , & payload [ k + 4 ] , 2 ) ;\n l = ntohs ( l ) ;\n m = ntohs ( m ) ;\n if ( header == ( char ) payload [ k ] || ( header == 'U' && ( payload [ k ] == 'f' || payload [ k ] == 't' || payload [ k ] == 'm' || payload [ k ] == 'o' || payload [ k ] == 'p' ) ) ) dump_headers_test ( msg , msglen , & payload [ i + ( j * 3 ) + l + 3 ] , m - l , payload [ k ] , fd , segregationLevel ) ;\n }\n return 1 ;\n }", "idx": 518}
{"hash": -5420171864670538459, "project": "debian", "size": 18, "label": 0, "functionSource": "static void qemu_tcg_init_vcpu ( CPUState * cpu ) {\n if ( ! tcg_cpu_thread ) {\n cpu -> thread = g_malloc0 ( sizeof ( QemuThread ) ) ;\n cpu -> halt_cond = g_malloc0 ( sizeof ( QemuCond ) ) ;\n qemu_cond_init ( cpu -> halt_cond ) ;\n tcg_halt_cond = cpu -> halt_cond ;\n qemu_thread_create ( cpu -> thread , qemu_tcg_cpu_thread_fn , cpu , QEMU_THREAD_JOINABLE ) ;\n # ifdef _WIN32 cpu -> hThread = qemu_thread_get_handle ( cpu -> thread ) ;\n # endif while ( ! cpu -> created ) {\n qemu_cond_wait ( & qemu_cpu_cond , & qemu_global_mutex ) ;\n }\n tcg_cpu_thread = cpu -> thread ;\n }\n else {\n cpu -> thread = tcg_cpu_thread ;\n cpu -> halt_cond = tcg_halt_cond ;\n }\n }", "idx": 519}
{"hash": -4055702019813176658, "project": "debian", "size": 576, "label": 0, "functionSource": "void proto_register_iax2 ( void ) {\n static hf_register_info hf [ ] = {\n {\n & hf_iax2_packet_type , {\n \"Packet type\" , \"iax2.packet_type\" , FT_UINT8 , BASE_DEC , VALS ( iax_packet_types ) , 0 , \"Full/minivoice/minivideo/trunk packet\" , HFILL }\n }\n , {\n & hf_iax2_callno , {\n \"Call identifier\" , \"iax2.call\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"This is the identifier Wireshark assigns to identify this call.\" \" It does not correspond to any real field in the protocol\" , HFILL }\n }\n , {\n & hf_iax2_scallno , {\n \"Source call\" , \"iax2.src_call\" , FT_UINT16 , BASE_DEC , NULL , 0x7FFF , \"src_call holds the number of this call at the packet source pbx\" , HFILL }\n }\n , {\n & hf_iax2_dcallno , {\n \"Destination call\" , \"iax2.dst_call\" , FT_UINT16 , BASE_DEC , NULL , 0x7FFF , \"dst_call holds the number of this call at the packet destination\" , HFILL }\n }\n , {\n & hf_iax2_retransmission , {\n \"Retransmission\" , \"iax2.retransmission\" , FT_BOOLEAN , 16 , NULL , 0x8000 , \"retransmission is set if this packet is a retransmission of an earlier failed packet\" , HFILL }\n }\n , {\n & hf_iax2_ts , {\n \"Timestamp\" , \"iax2.timestamp\" , FT_UINT32 , BASE_DEC , NULL , 0x0 , \"timestamp is the time, in ms after the start of this call, at which this packet was transmitted\" , HFILL }\n }\n , {\n & hf_iax2_minits , {\n \"Timestamp\" , \"iax2.timestamp\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , \"timestamp is the time, in ms after the start of this call, at which this packet was transmitted\" , HFILL }\n }\n , {\n & hf_iax2_minividts , {\n \"Timestamp\" , \"iax2.timestamp\" , FT_UINT16 , BASE_DEC , NULL , 0x7FFF , \"timestamp is the time, in ms after the start of this call, at which this packet was transmitted\" , HFILL }\n }\n , {\n & hf_iax2_absts , {\n \"Absolute Time\" , \"iax2.abstime\" , FT_ABSOLUTE_TIME , ABSOLUTE_TIME_LOCAL , NULL , 0x0 , \"The absolute time of this packet (calculated by adding the IAX timestamp to the start time of this call)\" , HFILL }\n }\n , {\n & hf_iax2_lateness , {\n \"Lateness\" , \"iax2.lateness\" , FT_RELATIVE_TIME , BASE_NONE , NULL , 0x0 , \"The lateness of this packet compared to its timestamp\" , HFILL }\n }\n , {\n & hf_iax2_minividmarker , {\n \"Marker\" , \"iax2.video.marker\" , FT_UINT16 , BASE_DEC , NULL , 0x8000 , \"RTP end-of-frame marker\" , HFILL }\n }\n , {\n & hf_iax2_oseqno , {\n \"Outbound seq.no.\" , \"iax2.oseqno\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , \"oseqno is the sequence no of this packet. The first packet has oseqno==0,\" \" and subsequent packets increment the oseqno by 1\" , HFILL }\n }\n , {\n & hf_iax2_iseqno , {\n \"Inbound seq.no.\" , \"iax2.iseqno\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , \"iseqno is the sequence no of the last successfully received packet\" , HFILL }\n }\n , {\n & hf_iax2_type , {\n \"Type\" , \"iax2.type\" , FT_UINT8 , BASE_DEC | BASE_EXT_STRING , & iax_frame_types_ext , 0x0 , \"For full IAX2 frames, type is the type of frame\" , HFILL }\n }\n , {\n & hf_iax2_csub , {\n \"Unknown subclass\" , \"iax2.subclass\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , \"Subclass of unknown type of full IAX2 frame\" , HFILL }\n }\n , {\n & hf_iax2_dtmf_csub , {\n \"DTMF subclass (digit)\" , \"iax2.dtmf.subclass\" , FT_STRINGZ , BASE_NONE , NULL , 0x0 , \"DTMF subclass gives the DTMF digit\" , HFILL }\n }\n , {\n & hf_iax2_cmd_csub , {\n \"Control subclass\" , \"iax2.control.subclass\" , FT_UINT8 , BASE_DEC | BASE_EXT_STRING , & iax_cmd_subclasses_ext , 0x0 , \"This gives the command number for a Control packet.\" , HFILL }\n }\n , {\n & hf_iax2_iax_csub , {\n \"IAX subclass\" , \"iax2.iax.subclass\" , FT_UINT8 , BASE_DEC | BASE_EXT_STRING , & iax_iax_subclasses_ext , 0x0 , \"IAX subclass gives the command number for IAX signaling packets\" , HFILL }\n }\n , {\n & hf_iax2_voice_csub , {\n \"Voice Subclass (compressed codec no)\" , \"iax2.voice.subclass\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_voice_codec , {\n \"CODEC\" , \"iax2.voice.codec\" , FT_UINT32 , BASE_HEX | BASE_EXT_STRING , & codec_types_ext , 0x0 , \"CODEC gives the codec used to encode audio data\" , HFILL }\n }\n , {\n & hf_iax2_video_csub , {\n \"Video Subclass (compressed codec no)\" , \"iax2.video.subclass\" , FT_UINT8 , BASE_DEC , NULL , 0xBF , NULL , HFILL }\n }\n , {\n & hf_iax2_marker , {\n \"Marker\" , \"iax2.video.marker\" , FT_BOOLEAN , 8 , NULL , 0x40 , \"RTP end-of-frame marker\" , HFILL }\n }\n , {\n & hf_iax2_video_codec , {\n \"CODEC\" , \"iax2.video.codec\" , FT_UINT32 , BASE_HEX | BASE_EXT_STRING , & codec_types_ext , 0 , \"The codec used to encode video data\" , HFILL }\n }\n , {\n & hf_iax2_modem_csub , {\n \"Modem subclass\" , \"iax2.modem.subclass\" , FT_UINT8 , BASE_DEC , VALS ( iax_modem_subclasses ) , 0x0 , \"Modem subclass gives the type of modem\" , HFILL }\n }\n , {\n & hf_iax2_text_csub , {\n \"Text subclass\" , \"iax2.text.subclass\" , FT_UINT8 , BASE_DEC , VALS ( iax_text_subclasses ) , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_text_text , {\n \"Text\" , \"iax2.text.text\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_html_csub , {\n \"HTML subclass\" , \"iax2.html.subclass\" , FT_UINT8 , BASE_DEC , VALS ( iax_html_subclasses ) , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_html_url , {\n \"HTML URL\" , \"iax2.html.url\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_trunk_ts , {\n \"Timestamp\" , \"iax2.timestamp\" , FT_UINT32 , BASE_DEC , NULL , 0x0 , \"timestamp is the time, in ms after the start of Command data this call,\" \" at which this trunk packet was transmitted\" , HFILL }\n }\n , {\n & hf_iax2_trunk_metacmd , {\n \"Meta command\" , \"iax2.trunk.metacmd\" , FT_UINT8 , BASE_DEC , NULL , 0x7F , \"Meta command indicates whether or not the Meta Frame is a trunk.\" , HFILL }\n }\n , {\n & hf_iax2_trunk_cmddata , {\n \"Command data\" , \"iax2.trunk.cmddata\" , FT_UINT8 , BASE_HEX , NULL , 0x0 , \"Flags for options that apply to a trunked call\" , HFILL }\n }\n , {\n & hf_iax2_trunk_cmddata_ts , {\n \"Trunk timestamps\" , \"iax2.trunk.cmddata.ts\" , FT_BOOLEAN , 8 , NULL , IAX2_TRUNK_TS , \"True: calls do each include their own timestamp\" , HFILL }\n }\n , {\n & hf_iax2_trunk_call_len , {\n \"Data length\" , \"iax2.trunk.call.len\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , \"Trunk call data length in octets\" , HFILL }\n }\n , {\n & hf_iax2_trunk_call_scallno , {\n \"Source call number\" , \"iax2.trunk.call.scallno\" , FT_UINT16 , BASE_DEC , NULL , 0x7FFF , \"Trunk call source call number\" , HFILL }\n }\n , {\n & hf_iax2_trunk_call_ts , {\n \"Timestamp\" , \"iax2.trunk.call.ts\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , \"timestamp is the time, in ms after the start of this call, at which this packet was transmitted\" , HFILL }\n }\n , {\n & hf_iax2_trunk_call_data , {\n \"Data\" , \"iax2.trunk.call.payload\" , FT_BYTES , BASE_NONE , NULL , 0x0 , \"Payload carried by this trunked packet.\" , HFILL }\n }\n , {\n & hf_iax2_trunk_ncalls , {\n \"Number of calls\" , \"iax2.trunk.ncalls\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , \"Number of calls in this trunk packet\" , HFILL }\n }\n , {\n & hf_IAX_IE_APPARENTADDR_SINFAMILY , {\n \"Family\" , \"iax2.iax.app_addr.sinfamily\" , FT_UINT16 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_IAX_IE_APPARENTADDR_SINPORT , {\n \"Port\" , \"iax2.iax.app_addr.sinport\" , FT_UINT16 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_IAX_IE_APPARENTADDR_SINADDR , {\n \"Address\" , \"iax2.iax.app_addr.sinaddr\" , FT_IPv4 , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_CALLED_NUMBER ] , {\n \"Number/extension being called\" , \"iax2.iax.called_number\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_CALLING_NUMBER ] , {\n \"Calling number\" , \"iax2.iax.calling_number\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_CALLING_ANI ] , {\n \"Calling number ANI for billing\" , \"iax2.iax.calling_ani\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_CALLING_NAME ] , {\n \"Name of caller\" , \"iax2.iax.calling_name\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_CALLED_CONTEXT ] , {\n \"Context for number\" , \"iax2.iax.called_context\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_USERNAME ] , {\n \"Username (peer or user) for authentication\" , \"iax2.iax.username\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_PASSWORD ] , {\n \"Password for authentication\" , \"iax2.iax.password\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_CAPABILITY ] , {\n \"Actual codec capability\" , \"iax2.iax.capability\" , FT_UINT32 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_FORMAT ] , {\n \"Desired codec format\" , \"iax2.iax.format\" , FT_UINT32 , BASE_HEX | BASE_EXT_STRING , & codec_types_ext , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_LANGUAGE ] , {\n \"Desired language\" , \"iax2.iax.language\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_VERSION ] , {\n \"Protocol version\" , \"iax2.iax.version\" , FT_UINT16 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_ADSICPE ] , {\n \"CPE ADSI capability\" , \"iax2.iax.cpe_adsi\" , FT_UINT16 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_DNID ] , {\n \"Originally dialed DNID\" , \"iax2.iax.dnid\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_AUTHMETHODS ] , {\n \"Authentication method(s)\" , \"iax2.iax.auth.methods\" , FT_UINT16 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_CHALLENGE ] , {\n \"Challenge data for MD5/RSA\" , \"iax2.iax.auth.challenge\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_MD5_RESULT ] , {\n \"MD5 challenge result\" , \"iax2.iax.auth.md5\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_RSA_RESULT ] , {\n \"RSA challenge result\" , \"iax2.iax.auth.rsa\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_REFRESH ] , {\n \"When to refresh registration\" , \"iax2.iax.refresh\" , FT_INT16 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_DPSTATUS ] , {\n \"Dialplan status\" , \"iax2.iax.dialplan_status\" , FT_UINT16 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_CALLNO ] , {\n \"Call number of peer\" , \"iax2.iax.call_no\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_CAUSE ] , {\n \"Cause\" , \"iax2.iax.cause\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_IAX_UNKNOWN ] , {\n \"Unknown IAX command\" , \"iax2.iax.iax_unknown\" , FT_BYTES , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_MSGCOUNT ] , {\n \"How many messages waiting\" , \"iax2.iax.msg_count\" , FT_INT16 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_AUTOANSWER ] , {\n \"Request auto-answering\" , \"iax2.iax.autoanswer\" , FT_NONE , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_MUSICONHOLD ] , {\n \"Request musiconhold with QUELCH\" , \"iax2.iax.moh\" , FT_NONE , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_TRANSFERID ] , {\n \"Transfer Request Identifier\" , \"iax2.iax.transferid\" , FT_UINT32 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_RDNIS ] , {\n \"Referring DNIS\" , \"iax2.iax.rdnis\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_PROVISIONING ] , {\n \"Provisioning info\" , \"iax2.iax.provisioning\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_AESPROVISIONING ] , {\n \"AES Provisioning info\" , \"iax2.iax.aesprovisioning\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_DATETIME ] , {\n \"Date/Time\" , \"iax2.iax.datetime.raw\" , FT_UINT32 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ie_datetime , {\n \"Date/Time\" , \"iax2.iax.datetime\" , FT_ABSOLUTE_TIME , ABSOLUTE_TIME_LOCAL , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_DEVICETYPE ] , {\n \"Device type\" , \"iax2.iax.devicetype\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_SERVICEIDENT ] , {\n \"Service identifier\" , \"iax2.iax.serviceident\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_FIRMWAREVER ] , {\n \"Firmware version\" , \"iax2.iax.firmwarever\" , FT_UINT16 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_FWBLOCKDESC ] , {\n \"Firmware block description\" , \"iax2.iax.fwblockdesc\" , FT_UINT32 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_FWBLOCKDATA ] , {\n \"Firmware block of data\" , \"iax2.iax.fwblockdata\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_PROVVER ] , {\n \"Provisioning version\" , \"iax2.iax.provver\" , FT_UINT32 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_CALLINGPRES ] , {\n \"Calling presentation\" , \"iax2.iax.callingpres\" , FT_UINT8 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_CALLINGTON ] , {\n \"Calling type of number\" , \"iax2.iax.callington\" , FT_UINT8 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_CALLINGTNS ] , {\n \"Calling transit network select\" , \"iax2.iax.callingtns\" , FT_UINT16 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_SAMPLINGRATE ] , {\n \"Supported sampling rates\" , \"iax2.iax.samplingrate\" , FT_UINT16 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_CAUSECODE ] , {\n \"Hangup cause\" , \"iax2.iax.causecode\" , FT_UINT8 , BASE_HEX | BASE_EXT_STRING , & iax_causecodes_ext , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_ENCRYPTION ] , {\n \"Encryption format\" , \"iax2.iax.encryption\" , FT_UINT16 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_ENCKEY ] , {\n \"Encryption key\" , \"iax2.iax.enckey\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_CODEC_PREFS ] , {\n \"Codec negotiation\" , \"iax2.iax.codecprefs\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_RR_JITTER ] , {\n \"Received jitter (as in RFC1889)\" , \"iax2.iax.rrjitter\" , FT_UINT32 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_RR_LOSS ] , {\n \"Received loss (high byte loss pct, low 24 bits loss count, as in rfc1889)\" , \"iax2.iax.rrloss\" , FT_UINT32 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_RR_PKTS ] , {\n \"Total frames received\" , \"iax2.iax.rrpkts\" , FT_UINT32 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_RR_DELAY ] , {\n \"Max playout delay in ms for received frames\" , \"iax2.iax.rrdelay\" , FT_UINT16 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_RR_DROPPED ] , {\n \"Dropped frames (presumably by jitterbuffer)\" , \"iax2.iax.rrdropped\" , FT_UINT32 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_RR_OOO ] , {\n \"Frame received out of order\" , \"iax2.iax.rrooo\" , FT_UINT32 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_DATAFORMAT ] , {\n \"Data call format\" , \"iax2.iax.dataformat\" , FT_UINT32 , BASE_HEX , VALS ( iax_dataformats ) , 0x0 , NULL , HFILL }\n }\n , {\n & hf_IAX_IE_UNKNOWN_BYTE , {\n \"Unknown\" , \"iax2.iax.unknownbyte\" , FT_UINT8 , BASE_HEX , NULL , 0x0 , \"Raw data for unknown IEs\" , HFILL }\n }\n , {\n & hf_IAX_IE_UNKNOWN_I16 , {\n \"Unknown\" , \"iax2.iax.unknownshort\" , FT_UINT16 , BASE_HEX , NULL , 0x0 , \"Raw data for unknown IEs\" , HFILL }\n }\n , {\n & hf_IAX_IE_UNKNOWN_I32 , {\n \"Unknown\" , \"iax2.iax.unknownlong\" , FT_UINT32 , BASE_HEX , NULL , 0x0 , \"Raw data for unknown IEs\" , HFILL }\n }\n , {\n & hf_IAX_IE_UNKNOWN_BYTES , {\n \"Unknown\" , \"iax2.iax.unknownstring\" , FT_STRING , BASE_NONE , NULL , 0x0 , \"Raw data for unknown IEs\" , HFILL }\n }\n , {\n & hf_iax2_ie_id , {\n \"IE id\" , \"iax2.ie_id\" , FT_UINT8 , BASE_DEC | BASE_EXT_STRING , & iax_ies_type_ext , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_length , {\n \"Length\" , \"iax2.length\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_g723_1 , {\n \"G.723.1 compression\" , \"iax2.cap.g723_1\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_G723_1 , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_gsm , {\n \"GSM compression\" , \"iax2.cap.gsm\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_GSM , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_ulaw , {\n \"Raw mu-law data (G.711)\" , \"iax2.cap.ulaw\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_ULAW , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_alaw , {\n \"Raw A-law data (G.711)\" , \"iax2.cap.alaw\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_ALAW , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_g726_aal2 , {\n \"G.726 compression (AAL2 packing)\" , \"iax2.cap.g726_aal2\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_G726_AAL2 , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_adpcm , {\n \"ADPCM\" , \"iax2.cap.adpcm\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_ADPCM , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_slinear , {\n \"Raw 16-bit Signed Linear (8000 Hz) PCM\" , \"iax2.cap.slinear\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_SLINEAR , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_lpc10 , {\n \"LPC10, 180 samples/frame\" , \"iax2.cap.lpc10\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_LPC10 , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_g729a , {\n \"G.729a Audio\" , \"iax2.cap.g729a\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_G729A , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_speex , {\n \"SPEEX Audio\" , \"iax2.cap.speex\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_SPEEX , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_ilbc , {\n \"iLBC Free compressed Audio\" , \"iax2.cap.ilbc\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_ILBC , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_g726 , {\n \"ADPCM (G.726, 32kbps, RFC3551 codeword packing)\" , \"iax2.cap.g726\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_G726 , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_g722 , {\n \"G.722 wideband audio\" , \"iax2.cap.g722\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_G722 , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_siren7 , {\n \"G.722.1 (also known as Siren7, 32kbps assumed)\" , \"iax2.cap.siren7\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_SIREN7 , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_siren14 , {\n \"G.722.1 Annex C (also known as Siren14, 48kbps assumed)\" , \"iax2.cap.siren14\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_SIREN14 , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_slinear16 , {\n \"Raw 16-bit Signed Linear (16000 Hz) PCM\" , \"iax2.cap.slinear16\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_SLINEAR16 , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_jpeg , {\n \"JPEG images\" , \"iax2.cap.jpeg\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_JPEG , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_png , {\n \"PNG images\" , \"iax2.cap.png\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_PNG , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_h261 , {\n \"H.261 video\" , \"iax2.cap.h261\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_H261 , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_h263 , {\n \"H.263 video\" , \"iax2.cap.h263\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_H263 , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_h263_plus , {\n \"H.263+ video\" , \"iax2.cap.h263_plus\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_H263_PLUS , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_h264 , {\n \"H.264 video\" , \"iax2.cap.h264\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_H264 , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_mpeg4 , {\n \"MPEG4 video\" , \"iax2.cap.mpeg4\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_MP4_VIDEO , NULL , HFILL }\n }\n , {\n & hf_iax2_fragment_unfinished , {\n \"IAX2 fragment, unfinished\" , \"iax2.fragment_unfinished\" , FT_BYTES , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_payload_data , {\n \"IAX2 payload\" , \"iax2.payload_data\" , FT_BYTES , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_fragments , {\n \"IAX2 Fragments\" , \"iax2.fragments\" , FT_NONE , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_fragment , {\n \"IAX2 Fragment data\" , \"iax2.fragment\" , FT_FRAMENUM , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_fragment_overlap , {\n \"Fragment overlap\" , \"iax2.fragment.overlap\" , FT_BOOLEAN , BASE_NONE , NULL , 0x0 , \"Fragment overlaps with other fragments\" , HFILL }\n }\n , {\n & hf_iax2_fragment_overlap_conflict , {\n \"Conflicting data in fragment overlap\" , \"iax2.fragment.overlap.conflict\" , FT_BOOLEAN , BASE_NONE , NULL , 0x0 , \"Overlapping fragments contained conflicting data\" , HFILL }\n }\n , {\n & hf_iax2_fragment_multiple_tails , {\n \"Multiple tail fragments found\" , \"iax2.fragment.multipletails\" , FT_BOOLEAN , BASE_NONE , NULL , 0x0 , \"Several tails were found when defragmenting the packet\" , HFILL }\n }\n , {\n & hf_iax2_fragment_too_long_fragment , {\n \"Fragment too long\" , \"iax2.fragment.toolongfragment\" , FT_BOOLEAN , BASE_NONE , NULL , 0x0 , \"Fragment contained data past end of packet\" , HFILL }\n }\n , {\n & hf_iax2_fragment_error , {\n \"Defragmentation error\" , \"iax2.fragment.error\" , FT_FRAMENUM , BASE_NONE , NULL , 0x0 , \"Defragmentation error due to illegal fragments\" , HFILL }\n }\n , {\n & hf_iax2_fragment_count , {\n \"Fragment count\" , \"iax2.fragment.count\" , FT_UINT32 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_reassembled_in , {\n \"IAX2 fragment, reassembled in frame\" , \"iax2.reassembled_in\" , FT_FRAMENUM , BASE_NONE , NULL , 0x0 , \"This IAX2 packet is reassembled in this frame\" , HFILL }\n }\n , {\n & hf_iax2_reassembled_length , {\n \"Reassembled IAX2 length\" , \"iax2.reassembled.length\" , FT_UINT32 , BASE_DEC , NULL , 0x0 , \"The total length of the reassembled payload\" , HFILL }\n }\n }\n ;\n static gint * ett [ ] = {\n & ett_iax2 , & ett_iax2_full_mini_subtree , & ett_iax2_type , & ett_iax2_ie , & ett_iax2_codecs , & ett_iax2_ies_apparent_addr , & ett_iax2_fragment , & ett_iax2_fragments , & ett_iax2_trunk_cmddata , & ett_iax2_trunk_call }\n ;\n static ei_register_info ei [ ] = {\n {\n & ei_iax_too_many_transfers , {\n \"iax2.too_many_transfers\" , PI_PROTOCOL , PI_WARN , \"Too many transfers for iax_call\" , EXPFILL }\n }\n , {\n & ei_iax_circuit_id_conflict , {\n \"iax2.circuit_id_conflict\" , PI_PROTOCOL , PI_WARN , \"Circuit ID conflict\" , EXPFILL }\n }\n , {\n & ei_iax_peer_address_unsupported , {\n \"iax2.peer_address_unsupported\" , PI_PROTOCOL , PI_WARN , \"Peer address unsupported\" , EXPFILL }\n }\n , {\n & ei_iax_invalid_len , {\n \"iax2.invalid_len\" , PI_PROTOCOL , PI_WARN , \"Invalid length\" , EXPFILL }\n }\n , {\n & ei_iax_invalid_ts , {\n \"iax2.invalid_ts\" , PI_PROTOCOL , PI_WARN , \"Invalid timestamp\" , EXPFILL }\n }\n }\n ;\n expert_module_t * expert_iax ;\n memset ( hf_iax2_ies , 0xff , sizeof ( hf_iax2_ies ) ) ;\n proto_iax2 = proto_register_protocol ( \"Inter-Asterisk eXchange v2\" , \"IAX2\" , \"iax2\" ) ;\n proto_register_field_array ( proto_iax2 , hf , array_length ( hf ) ) ;\n proto_register_subtree_array ( ett , array_length ( ett ) ) ;\n expert_iax = expert_register_protocol ( proto_iax2 ) ;\n expert_register_field_array ( expert_iax , ei , array_length ( ei ) ) ;\n register_dissector ( \"iax2\" , dissect_iax2 , proto_iax2 ) ;\n iax2_codec_dissector_table = register_dissector_table ( \"iax2.codec\" , \"IAX codec number\" , FT_UINT32 , BASE_HEX ) ;\n iax2_dataformat_dissector_table = register_dissector_table ( \"iax2.dataformat\" , \"IAX dataformat number\" , FT_UINT32 , BASE_HEX ) ;\n register_init_routine ( & iax_init_protocol ) ;\n register_cleanup_routine ( & iax_cleanup_protocol ) ;\n iax2_tap = register_tap ( \"IAX2\" ) ;\n }", "idx": 520}
{"hash": -4525874104093394205, "project": "debian", "size": 8, "label": 0, "functionSource": "static OFCondition makeUnderflowError ( const char * pdu , unsigned long minuend , unsigned long subtrahend ) {\n OFStringStream stream ;\n stream << \"DUL Illegal \" << pdu << \". Got \" << minuend << \" bytes of data and told to subtrat \" << subtrahend << \" bytes of data\" ;\n stream << \".\" << OFStringStream_ends ;\n OFCondition ret ;\n OFSTRINGSTREAM_GETSTR ( stream , tmpString ) ret = makeDcmnetCondition ( DULC_INCORRECTBUFFERLENGTH , OF_error , tmpString ) ;\n OFSTRINGSTREAM_FREESTR ( tmpString ) return ret ;\n }", "idx": 521}
{"hash": 6380456053173444622, "project": "debian", "size": 14, "label": 0, "functionSource": "const char * SSL_rstate_string ( const SSL * s ) {\n const char * str ;\n switch ( s -> rstate ) {\n case SSL_ST_READ_HEADER : str = \"RH\" ;\n break ;\n case SSL_ST_READ_BODY : str = \"RB\" ;\n break ;\n case SSL_ST_READ_DONE : str = \"RD\" ;\n break ;\n default : str = \"unknown\" ;\n break ;\n }\n return ( str ) ;\n }", "idx": 522}
{"hash": 7493853980473701704, "project": "debian", "size": 4, "label": 0, "functionSource": "static void gic_dist_writew ( void * opaque , hwaddr offset , uint32_t value ) {\n gic_dist_writeb ( opaque , offset , value & 0xff ) ;\n gic_dist_writeb ( opaque , offset + 1 , value >> 8 ) ;\n }", "idx": 523}
{"hash": -1672864273235910388, "project": "debian", "size": 46, "label": 0, "functionSource": "static void _slurm_rpc_reconfigure_controller ( slurm_msg_t * msg ) {\n int error_code = SLURM_SUCCESS ;\n static bool in_progress = false ;\n DEF_TIMERS ;\n slurmctld_lock_t config_write_lock = {\n WRITE_LOCK , WRITE_LOCK , WRITE_LOCK , WRITE_LOCK , NO_LOCK }\n ;\n uid_t uid = g_slurm_auth_get_uid ( msg -> auth_cred , slurmctld_config . auth_info ) ;\n START_TIMER ;\n info ( \"Processing RPC: REQUEST_RECONFIGURE from uid=%d\" , uid ) ;\n if ( ! validate_super_user ( uid ) ) {\n error ( \"Security violation, RECONFIGURE RPC from uid=%d\" , uid ) ;\n error_code = ESLURM_USER_ID_MISSING ;\n }\n if ( in_progress || slurmctld_config . shutdown_time ) error_code = EINPROGRESS ;\n if ( error_code == SLURM_SUCCESS ) {\n debug ( \"sched: begin reconfiguration\" ) ;\n lock_slurmctld ( config_write_lock ) ;\n in_progress = true ;\n error_code = read_slurm_conf ( 1 , true ) ;\n if ( error_code == SLURM_SUCCESS ) {\n _update_cred_key ( ) ;\n set_slurmctld_state_loc ( ) ;\n msg_to_slurmd ( REQUEST_RECONFIGURE ) ;\n }\n in_progress = false ;\n gs_reconfig ( ) ;\n unlock_slurmctld ( config_write_lock ) ;\n assoc_mgr_set_missing_uids ( ) ;\n start_power_mgr ( & slurmctld_config . thread_id_power ) ;\n trigger_reconfig ( ) ;\n }\n END_TIMER2 ( \"_slurm_rpc_reconfigure_controller\" ) ;\n if ( error_code ) {\n error ( \"_slurm_rpc_reconfigure_controller: %s\" , slurm_strerror ( error_code ) ) ;\n slurm_send_rc_msg ( msg , error_code ) ;\n }\n else {\n info ( \"_slurm_rpc_reconfigure_controller: completed %s\" , TIME_STR ) ;\n slurm_send_rc_msg ( msg , SLURM_SUCCESS ) ;\n acct_storage_g_reconfig ( acct_db_conn , 0 ) ;\n priority_g_reconfig ( false ) ;\n save_all_state ( ) ;\n queue_job_scheduler ( ) ;\n }\n }", "idx": 524}
{"hash": -7853481279968318488, "project": "chrome", "size": 39, "label": 0, "functionSource": "void vp9_select_in_frame_q_segment ( VP9_COMP * cpi , int mi_row , int mi_col , int output_enabled , int projected_rate ) {\n VP9_COMMON * const cm = & cpi -> common ;\n const int mi_offset = mi_row * cm -> mi_cols + mi_col ;\n const int bw = num_8x8_blocks_wide_lookup [ BLOCK_64X64 ] ;\n const int bh = num_8x8_blocks_high_lookup [ BLOCK_64X64 ] ;\n const int xmis = MIN ( cm -> mi_cols - mi_col , bw ) ;\n const int ymis = MIN ( cm -> mi_rows - mi_row , bh ) ;\n int complexity_metric = 64 ;\n int x , y ;\n unsigned char segment ;\n if ( ! output_enabled ) {\n segment = 0 ;\n }\n else {\n const int target_rate = ( cpi -> rc . sb64_target_rate * xmis * ymis * 256 ) / ( bw * bh ) ;\n const int aq_strength = get_aq_c_strength ( cm -> base_qindex , cm -> bit_depth ) ;\n const int active_segments = aq_c_active_segments [ aq_strength ] ;\n segment = active_segments - 1 ;\n while ( segment > 0 ) {\n if ( projected_rate < ( target_rate * aq_c_transitions [ aq_strength ] [ segment ] ) ) {\n break ;\n }\n -- segment ;\n }\n if ( target_rate > 0 ) {\n complexity_metric = clamp ( ( int ) ( ( projected_rate * 64 ) / target_rate ) , 16 , 255 ) ;\n }\n }\n for ( y = 0 ;\n y < ymis ;\n y ++ ) {\n for ( x = 0 ;\n x < xmis ;\n x ++ ) {\n cpi -> segmentation_map [ mi_offset + y * cm -> mi_cols + x ] = segment ;\n cpi -> complexity_map [ mi_offset + y * cm -> mi_cols + x ] = ( unsigned char ) complexity_metric ;\n }\n }\n }", "idx": 525}
{"hash": -3740862514502467070, "project": "debian", "size": 29, "label": 0, "functionSource": "static void dumpttf ( FILE * ttf , struct alltabs * at ) {\n int32 checksum ;\n int i , head_index = - 1 ;\n putlong ( ttf , at -> tabdir . version ) ;\n putshort ( ttf , at -> tabdir . numtab ) ;\n putshort ( ttf , at -> tabdir . searchRange ) ;\n putshort ( ttf , at -> tabdir . entrySel ) ;\n putshort ( ttf , at -> tabdir . rangeShift ) ;\n for ( i = 0 ;\n i < at -> tabdir . numtab ;\n ++ i ) {\n if ( at -> tabdir . alpha [ i ] -> tag == CHR ( 'h' , 'e' , 'a' , 'd' ) || at -> tabdir . alpha [ i ] -> tag == CHR ( 'b' , 'h' , 'e' , 'd' ) ) head_index = i ;\n putlong ( ttf , at -> tabdir . alpha [ i ] -> tag ) ;\n putlong ( ttf , at -> tabdir . alpha [ i ] -> checksum ) ;\n putlong ( ttf , at -> tabdir . alpha [ i ] -> offset ) ;\n putlong ( ttf , at -> tabdir . alpha [ i ] -> length ) ;\n }\n for ( i = 0 ;\n i < at -> tabdir . numtab ;\n ++ i ) if ( at -> tabdir . ordered [ i ] -> data != NULL ) {\n if ( ! ttfcopyfile ( ttf , at -> tabdir . ordered [ i ] -> data , at -> tabdir . ordered [ i ] -> offset , Tag2String ( at -> tabdir . ordered [ i ] -> tag ) ) ) at -> error = true ;\n }\n if ( head_index != - 1 ) {\n checksum = filechecksum ( ttf ) ;\n checksum = 0xb1b0afba - checksum ;\n fseek ( ttf , at -> tabdir . alpha [ head_index ] -> offset + 2 * sizeof ( int32 ) , SEEK_SET ) ;\n putlong ( ttf , checksum ) ;\n }\n }", "idx": 526}
{"hash": -650231346353974279, "project": "debian", "size": 46, "label": 0, "functionSource": "bool parsePGArray ( const char * atext , char * * * itemarray , int * nitems ) {\n int inputlen ;\n char * * items ;\n char * strings ;\n int curitem ;\n * itemarray = NULL ;\n * nitems = 0 ;\n inputlen = strlen ( atext ) ;\n if ( inputlen < 2 || atext [ 0 ] != '{\n' || atext [ inputlen - 1 ] != '}\n' ) return false ;\n items = ( char * * ) malloc ( inputlen * ( sizeof ( char * ) + sizeof ( char ) ) ) ;\n if ( items == NULL ) return false ;\n * itemarray = items ;\n strings = ( char * ) ( items + inputlen ) ;\n atext ++ ;\n curitem = 0 ;\n while ( * atext != '}\n' ) {\n if ( * atext == '\\0' ) return false ;\n items [ curitem ] = strings ;\n while ( * atext != '}\n' && * atext != ',' ) {\n if ( * atext == '\\0' ) return false ;\n if ( * atext != '\"' ) * strings ++ = * atext ++ ;\n else {\n atext ++ ;\n while ( * atext != '\"' ) {\n if ( * atext == '\\0' ) return false ;\n if ( * atext == '\\\\' ) {\n atext ++ ;\n if ( * atext == '\\0' ) return false ;\n }\n * strings ++ = * atext ++ ;\n }\n atext ++ ;\n }\n }\n * strings ++ = '\\0' ;\n if ( * atext == ',' ) atext ++ ;\n curitem ++ ;\n }\n if ( atext [ 1 ] != '\\0' ) return false ;\n * nitems = curitem ;\n return true ;\n }", "idx": 527}
{"hash": 6458694302493204858, "project": "debian", "size": 49, "label": 0, "functionSource": "TupleTableSlot * ExecProject ( ProjectionInfo * projInfo , ExprDoneCond * isDone ) {\n TupleTableSlot * slot ;\n ExprContext * econtext ;\n int numSimpleVars ;\n Assert ( projInfo != NULL ) ;\n slot = projInfo -> pi_slot ;\n econtext = projInfo -> pi_exprContext ;\n if ( isDone ) * isDone = ExprSingleResult ;\n ExecClearTuple ( slot ) ;\n if ( projInfo -> pi_lastInnerVar > 0 ) slot_getsomeattrs ( econtext -> ecxt_innertuple , projInfo -> pi_lastInnerVar ) ;\n if ( projInfo -> pi_lastOuterVar > 0 ) slot_getsomeattrs ( econtext -> ecxt_outertuple , projInfo -> pi_lastOuterVar ) ;\n if ( projInfo -> pi_lastScanVar > 0 ) slot_getsomeattrs ( econtext -> ecxt_scantuple , projInfo -> pi_lastScanVar ) ;\n numSimpleVars = projInfo -> pi_numSimpleVars ;\n if ( numSimpleVars > 0 ) {\n Datum * values = slot -> tts_values ;\n bool * isnull = slot -> tts_isnull ;\n int * varSlotOffsets = projInfo -> pi_varSlotOffsets ;\n int * varNumbers = projInfo -> pi_varNumbers ;\n int i ;\n if ( projInfo -> pi_directMap ) {\n for ( i = 0 ;\n i < numSimpleVars ;\n i ++ ) {\n char * slotptr = ( ( char * ) econtext ) + varSlotOffsets [ i ] ;\n TupleTableSlot * varSlot = * ( ( TupleTableSlot * * ) slotptr ) ;\n int varNumber = varNumbers [ i ] - 1 ;\n values [ i ] = varSlot -> tts_values [ varNumber ] ;\n isnull [ i ] = varSlot -> tts_isnull [ varNumber ] ;\n }\n }\n else {\n int * varOutputCols = projInfo -> pi_varOutputCols ;\n for ( i = 0 ;\n i < numSimpleVars ;\n i ++ ) {\n char * slotptr = ( ( char * ) econtext ) + varSlotOffsets [ i ] ;\n TupleTableSlot * varSlot = * ( ( TupleTableSlot * * ) slotptr ) ;\n int varNumber = varNumbers [ i ] - 1 ;\n int varOutputCol = varOutputCols [ i ] - 1 ;\n values [ varOutputCol ] = varSlot -> tts_values [ varNumber ] ;\n isnull [ varOutputCol ] = varSlot -> tts_isnull [ varNumber ] ;\n }\n }\n }\n if ( projInfo -> pi_targetlist ) {\n if ( ! ExecTargetList ( projInfo -> pi_targetlist , slot -> tts_tupleDescriptor , econtext , slot -> tts_values , slot -> tts_isnull , projInfo -> pi_itemIsDone , isDone ) ) return slot ;\n }\n return ExecStoreVirtualTuple ( slot ) ;\n }", "idx": 528}
{"hash": 7039307292471244756, "project": "debian", "size": 10, "label": 0, "functionSource": "static void dtap_tp_gprs_test_mode_cmd ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len ) {\n guint32 curr_offset ;\n guint32 consumed ;\n guint curr_len ;\n curr_len = len ;\n curr_offset = offset ;\n ELEM_MAND_V ( GSM_A_PDU_TYPE_DTAP , DE_TP_PDU_DESCRIPTION , NULL ) ;\n ELEM_MAND_V ( GSM_A_PDU_TYPE_DTAP , DE_TP_MODE_FLAG , NULL ) ;\n EXTRANEOUS_DATA_CHECK ( curr_len , 0 , pinfo , & ei_gsm_a_dtap_extraneous_data ) ;\n }", "idx": 529}
{"hash": 7484321273243811670, "project": "chrome", "size": 5, "label": 0, "functionSource": "TEST_F ( ShortcutsProviderTest , DoesNotProvideOnFocus ) {\n AutocompleteInput input ( ASCIIToUTF16 ( \"about:o\" ) , base : : string16 : : npos , std : : string ( ) , GURL ( ) , metrics : : OmniboxEventProto : : INVALID_SPEC , false , false , true , true , true , TestSchemeClassifier ( ) ) ;\n provider_ -> Start ( input , false ) ;\n EXPECT_TRUE ( provider_ -> matches ( ) . empty ( ) ) ;\n }", "idx": 530}
{"hash": 6595989226414083189, "project": "debian", "size": 4, "label": 0, "functionSource": "static __inline__ void __swab16s ( __u16 * p ) {\n # ifdef __arch_swab16s __arch_swab16s ( p ) ;\n # else * p = __swab16p ( p ) ;\n # endif }", "idx": 531}
{"hash": -6068976579504840746, "project": "debian", "size": 56, "label": 0, "functionSource": "void save_config ( struct recvbuf * rbufp , int restrict_mask ) {\n static const char * illegal_in_filename = # if defined ( VMS ) \":[]\" # elif defined ( SYS_WINNT ) \":\\\\/\" # else \"\\\\/\" # endif ;\n char reply [ 128 ] ;\n # ifdef SAVECONFIG char filespec [ 128 ] ;\n char filename [ 128 ] ;\n char fullpath [ 512 ] ;\n const char savedconfig_eq [ ] = \"savedconfig=\" ;\n char savedconfig [ sizeof ( savedconfig_eq ) + sizeof ( filename ) ] ;\n time_t now ;\n int fd ;\n FILE * fptr ;\n # endif if ( RES_NOMODIFY & restrict_mask ) {\n snprintf ( reply , sizeof ( reply ) , \"saveconfig prohibited by restrict ... nomodify\" ) ;\n ctl_putdata ( reply , strlen ( reply ) , 0 ) ;\n ctl_flushpkt ( 0 ) ;\n NLOG ( NLOG_SYSINFO ) msyslog ( LOG_NOTICE , \"saveconfig from %s rejected due to nomodify restriction\" , stoa ( & rbufp -> recv_srcadr ) ) ;\n sys_restricted ++ ;\n return ;\n }\n # ifdef SAVECONFIG if ( NULL == saveconfigdir ) {\n snprintf ( reply , sizeof ( reply ) , \"saveconfig prohibited, no saveconfigdir configured\" ) ;\n ctl_putdata ( reply , strlen ( reply ) , 0 ) ;\n ctl_flushpkt ( 0 ) ;\n NLOG ( NLOG_SYSINFO ) msyslog ( LOG_NOTICE , \"saveconfig from %s rejected, no saveconfigdir\" , stoa ( & rbufp -> recv_srcadr ) ) ;\n return ;\n }\n if ( 0 == reqend - reqpt ) return ;\n strlcpy ( filespec , reqpt , sizeof ( filespec ) ) ;\n time ( & now ) ;\n if ( 0 == strftime ( filename , sizeof ( filename ) , filespec , localtime ( & now ) ) ) strlcpy ( filename , filespec , sizeof ( filename ) ) ;\n if ( NULL != strpbrk ( filename , illegal_in_filename ) ) {\n snprintf ( reply , sizeof ( reply ) , \"saveconfig does not allow directory in filename\" ) ;\n ctl_putdata ( reply , strlen ( reply ) , 0 ) ;\n ctl_flushpkt ( 0 ) ;\n msyslog ( LOG_NOTICE , \"saveconfig with path from %s rejected\" , stoa ( & rbufp -> recv_srcadr ) ) ;\n return ;\n }\n snprintf ( fullpath , sizeof ( fullpath ) , \"%s%s\" , saveconfigdir , filename ) ;\n fd = open ( fullpath , O_CREAT | O_TRUNC | O_WRONLY , S_IRUSR | S_IWUSR ) ;\n if ( - 1 == fd ) fptr = NULL ;\n else fptr = fdopen ( fd , \"w\" ) ;\n if ( NULL == fptr || - 1 == dump_all_config_trees ( fptr , 1 ) ) {\n snprintf ( reply , sizeof ( reply ) , \"Unable to save configuration to file %s\" , filename ) ;\n msyslog ( LOG_ERR , \"saveconfig %s from %s failed\" , filename , stoa ( & rbufp -> recv_srcadr ) ) ;\n }\n else {\n snprintf ( reply , sizeof ( reply ) , \"Configuration saved to %s\" , filename ) ;\n msyslog ( LOG_NOTICE , \"Configuration saved to %s (requested by %s)\" , fullpath , stoa ( & rbufp -> recv_srcadr ) ) ;\n snprintf ( savedconfig , sizeof ( savedconfig ) , \"%s%s\" , savedconfig_eq , filename ) ;\n set_sys_var ( savedconfig , strlen ( savedconfig ) + 1 , RO ) ;\n }\n if ( NULL != fptr ) fclose ( fptr ) ;\n # else snprintf ( reply , sizeof ( reply ) , \"saveconfig unavailable, configured with --disable-saveconfig\" ) ;\n # endif ctl_putdata ( reply , strlen ( reply ) , 0 ) ;\n ctl_flushpkt ( 0 ) ;\n }", "idx": 532}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_IA5String_SIZE_1_40 ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_IA5String ( tvb , offset , actx , tree , hf_index , 1 , 40 , FALSE ) ;\n return offset ;\n }", "idx": 533}
{"hash": -7440595807730782314, "project": "debian", "size": 10, "label": 0, "functionSource": "static FILE_DCC_REC * dcc_resume_find ( int type , const char * nick , int port ) {\n GSList * tmp ;\n for ( tmp = dcc_conns ;\n tmp != NULL ;\n tmp = tmp -> next ) {\n FILE_DCC_REC * dcc = tmp -> data ;\n if ( dcc -> type == type && ! dcc_is_connected ( dcc ) && dcc -> port == port && g_ascii_strcasecmp ( dcc -> nick , nick ) == 0 ) return dcc ;\n }\n return NULL ;\n }", "idx": 534}
{"hash": -2928324134072492299, "project": "debian", "size": 21, "label": 0, "functionSource": "static void add_to_graph ( voip_calls_tapinfo_t * tapinfo _U_ , packet_info * pinfo , const gchar * frame_label , const gchar * comment , guint16 call_num , address * src_addr , address * dst_addr , guint16 line_style ) {\n seq_analysis_item_t * gai ;\n gchar time_str [ COL_MAX_LEN ] ;\n gai = ( seq_analysis_item_t * ) g_malloc ( sizeof ( seq_analysis_item_t ) ) ;\n gai -> fd = pinfo -> fd ;\n COPY_ADDRESS ( & ( gai -> src_addr ) , src_addr ) ;\n COPY_ADDRESS ( & ( gai -> dst_addr ) , dst_addr ) ;\n gai -> port_src = pinfo -> srcport ;\n gai -> port_dst = pinfo -> destport ;\n if ( frame_label != NULL ) gai -> frame_label = g_strdup ( frame_label ) ;\n else gai -> frame_label = g_strdup ( \"\" ) ;\n if ( comment != NULL ) gai -> comment = g_strdup ( comment ) ;\n else gai -> comment = g_strdup ( \"\" ) ;\n gai -> conv_num = call_num ;\n gai -> line_style = line_style ;\n set_fd_time ( cfile . epan , gai -> fd , time_str ) ;\n gai -> time_str = g_strdup ( time_str ) ;\n gai -> display = FALSE ;\n tapinfo -> graph_analysis -> list = g_list_prepend ( tapinfo -> graph_analysis -> list , gai ) ;\n g_hash_table_insert ( tapinfo -> graph_analysis -> ht , & gai -> fd -> num , gai ) ;\n }", "idx": 535}
{"hash": -7614722514335375899, "project": "chrome", "size": 15, "label": 0, "functionSource": "TEST_F ( ProfileInfoCacheTest , BackgroundModeStatus ) {\n GetCache ( ) -> AddProfileToCache ( GetProfilePath ( \"path_1\" ) , ASCIIToUTF16 ( \"name_1\" ) , base : : string16 ( ) , 0 , std : : string ( ) ) ;\n GetCache ( ) -> AddProfileToCache ( GetProfilePath ( \"path_2\" ) , ASCIIToUTF16 ( \"name_2\" ) , base : : string16 ( ) , 0 , std : : string ( ) ) ;\n EXPECT_FALSE ( GetCache ( ) -> GetBackgroundStatusOfProfileAtIndex ( 0 ) ) ;\n EXPECT_FALSE ( GetCache ( ) -> GetBackgroundStatusOfProfileAtIndex ( 1 ) ) ;\n GetCache ( ) -> SetBackgroundStatusOfProfileAtIndex ( 1 , true ) ;\n EXPECT_FALSE ( GetCache ( ) -> GetBackgroundStatusOfProfileAtIndex ( 0 ) ) ;\n EXPECT_TRUE ( GetCache ( ) -> GetBackgroundStatusOfProfileAtIndex ( 1 ) ) ;\n GetCache ( ) -> SetBackgroundStatusOfProfileAtIndex ( 0 , true ) ;\n EXPECT_TRUE ( GetCache ( ) -> GetBackgroundStatusOfProfileAtIndex ( 0 ) ) ;\n EXPECT_TRUE ( GetCache ( ) -> GetBackgroundStatusOfProfileAtIndex ( 1 ) ) ;\n GetCache ( ) -> SetBackgroundStatusOfProfileAtIndex ( 1 , false ) ;\n EXPECT_TRUE ( GetCache ( ) -> GetBackgroundStatusOfProfileAtIndex ( 0 ) ) ;\n EXPECT_FALSE ( GetCache ( ) -> GetBackgroundStatusOfProfileAtIndex ( 1 ) ) ;\n }", "idx": 536}
{"hash": -7236893719053583356, "project": "debian", "size": 14, "label": 0, "functionSource": "static void dissect_zcl_color_control_move_to_hue_and_saturation ( tvbuff_t * tvb , proto_tree * tree , guint * offset , gboolean enhanced ) {\n if ( enhanced ) {\n proto_tree_add_item ( tree , hf_zbee_zcl_color_control_enhanced_hue , tvb , * offset , 2 , ENC_LITTLE_ENDIAN ) ;\n * offset += 2 ;\n }\n else {\n proto_tree_add_item ( tree , hf_zbee_zcl_color_control_hue , tvb , * offset , 1 , ENC_LITTLE_ENDIAN ) ;\n * offset += 1 ;\n }\n proto_tree_add_item ( tree , hf_zbee_zcl_color_control_saturation , tvb , * offset , 1 , ENC_LITTLE_ENDIAN ) ;\n * offset += 1 ;\n proto_tree_add_item ( tree , hf_zbee_zcl_color_control_transit_time , tvb , * offset , 2 , ENC_LITTLE_ENDIAN ) ;\n * offset += 2 ;\n }", "idx": 537}
{"hash": 6600620671673714486, "project": "debian", "size": 18, "label": 0, "functionSource": "static void * i_alloc_struct ( gs_memory_t * mem , gs_memory_type_ptr_t pstype , client_name_t cname ) {\n gs_ref_memory_t * const imem = ( gs_ref_memory_t * ) mem ;\n uint size = pstype -> ssize ;\n obj_header_t * obj ;\n obj_header_t * * pfl ;\n # ifdef MEMENTO if ( Memento_failThisEvent ( ) ) return NULL ;\n # endif ALLOC_CHECK_SIZE ( mem , pstype ) ;\n IF_FREELIST_ALLOC ( obj , imem , size , pstype , pfl ) alloc_trace ( \":+<f\" , imem , cname , pstype , size , obj ) ;\n ELSEIF_BIG_FREELIST_ALLOC ( obj , imem , size , pstype ) alloc_trace ( \":+<F\" , imem , cname , pstype , size , obj ) ;\n ELSEIF_LIFO_ALLOC ( obj , imem , size , pstype ) alloc_trace ( \":+< \" , imem , cname , pstype , size , obj ) ;\n ELSE_ALLOC {\n obj = alloc_obj ( imem , size , pstype , 0 , cname ) ;\n if ( obj == 0 ) return 0 ;\n alloc_trace ( \":+<.\" , imem , cname , pstype , size , obj ) ;\n }\n # if IGC_PTR_STABILITY_CHECK obj [ - 1 ] . d . o . space_id = imem -> space_id ;\n # endif return obj ;\n }", "idx": 538}
{"hash": 2755982813601944893, "project": "debian", "size": 21, "label": 0, "functionSource": "static inline void eval_lpcenv_or_interp ( TwinContext * tctx , enum FrameType ftype , float * out , const float * in , int size , int step , int part ) {\n int i ;\n const ModeTab * mtab = tctx -> mtab ;\n const float * cos_tab = tctx -> cos_tabs [ ftype ] ;\n for ( i = 0 ;\n i < size ;\n i += step ) out [ i ] = eval_lpc_spectrum ( in , get_cos ( i , part , cos_tab , size ) , mtab -> n_lsp ) ;\n for ( i = step ;\n i <= size - 2 * step ;\n i += step ) {\n if ( out [ i + step ] + out [ i - step ] > 1.95 * out [ i ] || out [ i + step ] >= out [ i - step ] ) {\n interpolate ( out + i - step + 1 , out [ i ] , out [ i - step ] , step - 1 ) ;\n }\n else {\n out [ i - step / 2 ] = eval_lpc_spectrum ( in , get_cos ( i - step / 2 , part , cos_tab , size ) , mtab -> n_lsp ) ;\n interpolate ( out + i - step + 1 , out [ i - step / 2 ] , out [ i - step ] , step / 2 - 1 ) ;\n interpolate ( out + i - step / 2 + 1 , out [ i ] , out [ i - step / 2 ] , step / 2 - 1 ) ;\n }\n }\n interpolate ( out + size - 2 * step + 1 , out [ size - step ] , out [ size - 2 * step ] , step - 1 ) ;\n }", "idx": 539}
{"hash": -8925552398357902286, "project": "chrome", "size": 4, "label": 0, "functionSource": "void vp9_coef_tree_initialize ( ) {\n init_bit_trees ( ) ;\n vp9_tokens_from_tree ( vp9_coef_encodings , vp9_coef_tree ) ;\n }", "idx": 540}
{"hash": 7092216800726729686, "project": "debian", "size": 7, "label": 0, "functionSource": "static int dissect_h245_GenericInformation ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 656 \"../../asn1/h245/h245.cnf\" void * priv_data = actx -> private_data ;\n actx -> private_data = gef_ctx_alloc ( NULL , \"GenericInformation\" ) ;\n offset = dissect_h245_GenericMessage ( tvb , offset , actx , tree , hf_index ) ;\n # line 659 \"../../asn1/h245/h245.cnf\" actx -> private_data = priv_data ;\n return offset ;\n }", "idx": 541}
{"hash": 1760449185745615462, "project": "debian", "size": 19, "label": 0, "functionSource": "TSReturnCode TSMimeHdrFieldCopyValues ( TSMBuffer dest_bufp , TSMLoc dest_hdr , TSMLoc dest_field , TSMBuffer src_bufp , TSMLoc src_hdr , TSMLoc src_field ) {\n sdk_assert ( sdk_sanity_check_mbuffer ( src_bufp ) == TS_SUCCESS ) ;\n sdk_assert ( sdk_sanity_check_mbuffer ( dest_bufp ) == TS_SUCCESS ) ;\n sdk_assert ( ( sdk_sanity_check_mime_hdr_handle ( src_hdr ) == TS_SUCCESS ) || ( sdk_sanity_check_http_hdr_handle ( src_hdr ) == TS_SUCCESS ) ) ;\n sdk_assert ( ( sdk_sanity_check_mime_hdr_handle ( dest_hdr ) == TS_SUCCESS ) || ( sdk_sanity_check_http_hdr_handle ( dest_hdr ) == TS_SUCCESS ) ) ;\n sdk_assert ( sdk_sanity_check_field_handle ( src_field , src_hdr ) == TS_SUCCESS ) ;\n sdk_assert ( sdk_sanity_check_field_handle ( dest_field , dest_hdr ) == TS_SUCCESS ) ;\n if ( ! isWriteable ( dest_bufp ) ) {\n return TS_ERROR ;\n }\n MIMEFieldSDKHandle * s_handle = ( MIMEFieldSDKHandle * ) src_field ;\n MIMEFieldSDKHandle * d_handle = ( MIMEFieldSDKHandle * ) dest_field ;\n HdrHeap * d_heap = ( ( HdrHeapSDKHandle * ) dest_bufp ) -> m_heap ;\n MIMEField * s_field , * d_field ;\n s_field = s_handle -> field_ptr ;\n d_field = d_handle -> field_ptr ;\n mime_field_value_set ( d_heap , d_handle -> mh , d_field , s_field -> m_ptr_value , s_field -> m_len_value , true ) ;\n return TS_SUCCESS ;\n }", "idx": 542}
{"hash": 1760449185745615462, "project": "debian", "size": 12, "label": 0, "functionSource": "TSReturnCode TSMimeHdrFieldValueIntSet ( TSMBuffer bufp , TSMLoc hdr , TSMLoc field , int idx , int value ) {\n sdk_assert ( sdk_sanity_check_mbuffer ( bufp ) == TS_SUCCESS ) ;\n sdk_assert ( ( sdk_sanity_check_mime_hdr_handle ( hdr ) == TS_SUCCESS ) || ( sdk_sanity_check_http_hdr_handle ( hdr ) == TS_SUCCESS ) ) ;\n sdk_assert ( sdk_sanity_check_field_handle ( field , hdr ) == TS_SUCCESS ) ;\n if ( ! isWriteable ( bufp ) ) {\n return TS_ERROR ;\n }\n char tmp [ 16 ] ;\n int len = mime_format_int ( tmp , value , sizeof ( tmp ) ) ;\n TSMimeFieldValueSet ( bufp , field , idx , tmp , len ) ;\n return TS_SUCCESS ;\n }", "idx": 543}
{"hash": 1760449185745615462, "project": "debian", "size": 5, "label": 0, "functionSource": "int64_t TSVConnCacheObjectSizeGet ( TSVConn connp ) {\n sdk_assert ( sdk_sanity_check_iocore_structure ( connp ) == TS_SUCCESS ) ;\n CacheVC * vc = ( CacheVC * ) connp ;\n return vc -> get_object_size ( ) ;\n }", "idx": 544}
{"hash": 3322961578925988960, "project": "debian", "size": 39, "label": 0, "functionSource": "static int parse_picture_segment ( AVCodecContext * avctx , const uint8_t * buf , int buf_size ) {\n PGSSubContext * ctx = avctx -> priv_data ;\n uint8_t sequence_desc ;\n unsigned int rle_bitmap_len , width , height ;\n uint16_t picture_id ;\n if ( buf_size <= 4 ) return - 1 ;\n buf_size -= 4 ;\n picture_id = bytestream_get_be16 ( & buf ) ;\n buf ++ ;\n sequence_desc = bytestream_get_byte ( & buf ) ;\n if ( ! ( sequence_desc & 0x80 ) ) {\n if ( buf_size > ctx -> pictures [ picture_id ] . rle_remaining_len ) return - 1 ;\n memcpy ( ctx -> pictures [ picture_id ] . rle + ctx -> pictures [ picture_id ] . rle_data_len , buf , buf_size ) ;\n ctx -> pictures [ picture_id ] . rle_data_len += buf_size ;\n ctx -> pictures [ picture_id ] . rle_remaining_len -= buf_size ;\n return 0 ;\n }\n if ( buf_size <= 7 ) return - 1 ;\n buf_size -= 7 ;\n rle_bitmap_len = bytestream_get_be24 ( & buf ) - 2 * 2 ;\n width = bytestream_get_be16 ( & buf ) ;\n height = bytestream_get_be16 ( & buf ) ;\n if ( avctx -> width < width || avctx -> height < height ) {\n av_log ( avctx , AV_LOG_ERROR , \"Bitmap dimensions larger than video.\\n\" ) ;\n return - 1 ;\n }\n if ( buf_size > rle_bitmap_len ) {\n av_log ( avctx , AV_LOG_ERROR , \"too much RLE data\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n ctx -> pictures [ picture_id ] . w = width ;\n ctx -> pictures [ picture_id ] . h = height ;\n av_fast_malloc ( & ctx -> pictures [ picture_id ] . rle , & ctx -> pictures [ picture_id ] . rle_buffer_size , rle_bitmap_len ) ;\n if ( ! ctx -> pictures [ picture_id ] . rle ) return - 1 ;\n memcpy ( ctx -> pictures [ picture_id ] . rle , buf , buf_size ) ;\n ctx -> pictures [ picture_id ] . rle_data_len = buf_size ;\n ctx -> pictures [ picture_id ] . rle_remaining_len = rle_bitmap_len - buf_size ;\n return 0 ;\n }", "idx": 545}
{"hash": -7795592811940874822, "project": "debian", "size": 28, "label": 0, "functionSource": "static gcry_err_code_t pubkey_decrypt ( int algorithm , gcry_mpi_t * result , gcry_mpi_t * data , gcry_mpi_t * skey , int flags ) {\n gcry_pk_spec_t * pubkey ;\n gcry_module_t module ;\n gcry_err_code_t rc ;\n int i ;\n * result = NULL ;\n if ( DBG_CIPHER && ! fips_mode ( ) ) {\n log_debug ( \"pubkey_decrypt: algo=%d\\n\" , algorithm ) ;\n for ( i = 0 ;\n i < pubkey_get_nskey ( algorithm ) ;\n i ++ ) log_mpidump ( \" skey\" , skey [ i ] ) ;\n for ( i = 0 ;\n i < pubkey_get_nenc ( algorithm ) ;\n i ++ ) log_mpidump ( \" data\" , data [ i ] ) ;\n }\n ath_mutex_lock ( & pubkeys_registered_lock ) ;\n module = _gcry_module_lookup_id ( pubkeys_registered , algorithm ) ;\n if ( module ) {\n pubkey = ( gcry_pk_spec_t * ) module -> spec ;\n rc = pubkey -> decrypt ( algorithm , result , data , skey , flags ) ;\n _gcry_module_release ( module ) ;\n goto ready ;\n }\n rc = GPG_ERR_PUBKEY_ALGO ;\n ready : ath_mutex_unlock ( & pubkeys_registered_lock ) ;\n if ( ! rc && DBG_CIPHER && ! fips_mode ( ) ) log_mpidump ( \" plain\" , * result ) ;\n return rc ;\n }", "idx": 546}
{"hash": -4558261210024070448, "project": "chrome", "size": 5, "label": 0, "functionSource": "static int xmlLinkCompare ( const void * data0 , const void * data1 ) {\n if ( data0 < data1 ) return ( - 1 ) ;\n else if ( data0 == data1 ) return ( 0 ) ;\n return ( 1 ) ;\n }", "idx": 547}
{"hash": 5357882892791796049, "project": "debian", "size": 3, "label": 0, "functionSource": "static inline void e1000e_autoneg_pause ( E1000ECore * core ) {\n timer_del ( core -> autoneg_timer ) ;\n }", "idx": 548}
{"hash": -7670127399145950875, "project": "debian", "size": 27, "label": 0, "functionSource": "static int file_path_add ( gs_main_instance * minst , gs_file_path * pfp , const char * dirs ) {\n uint len = r_size ( & pfp -> list ) ;\n const char * dpath = dirs ;\n int code ;\n if ( dirs == 0 ) return 0 ;\n for ( ;\n ;\n ) {\n const char * npath = dpath ;\n while ( * npath != 0 && * npath != gp_file_name_list_separator ) npath ++ ;\n if ( npath > dpath ) {\n if ( len == r_size ( & pfp -> container ) ) {\n code = extend_path_list_container ( minst , pfp ) ;\n if ( code < 0 ) {\n emprintf ( minst -> heap , \"\\nAdding path to search paths failed.\\n\" ) ;\n return ( code ) ;\n }\n }\n make_const_string ( & pfp -> container . value . refs [ len ] , avm_foreign | a_readonly , npath - dpath , ( const byte * ) dpath ) ;\n ++ len ;\n }\n if ( ! * npath ) break ;\n dpath = npath + 1 ;\n }\n r_set_size ( & pfp -> list , len ) ;\n return 0 ;\n }", "idx": 549}
{"hash": 4839943401171415484, "project": "chrome", "size": 24, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_P ( BrowserCloseManagerBrowserTest , TestOpenAndCloseWindowDuringShutdown ) {\n ASSERT_NO_FATAL_FAILURE ( ui_test_utils : : NavigateToURL ( browsers_ [ 0 ] , embedded_test_server ( ) -> GetURL ( \"/beforeunload.html\" ) ) ) ;\n PrepareForDialog ( browsers_ [ 0 ] ) ;\n RepeatedNotificationObserver cancel_observer ( chrome : : NOTIFICATION_BROWSER_CLOSE_CANCELLED , 2 ) ;\n chrome : : CloseAllBrowsersAndQuit ( ) ;\n browsers_ . push_back ( CreateBrowser ( browser ( ) -> profile ( ) ) ) ;\n ASSERT_NO_FATAL_FAILURE ( ui_test_utils : : NavigateToURL ( browsers_ [ 1 ] , embedded_test_server ( ) -> GetURL ( \"/beforeunload.html\" ) ) ) ;\n PrepareForDialog ( browsers_ [ 1 ] ) ;\n ASSERT_FALSE ( browsers_ [ 1 ] -> ShouldCloseWindow ( ) ) ;\n ASSERT_NO_FATAL_FAILURE ( CancelClose ( ) ) ;\n ASSERT_NO_FATAL_FAILURE ( CancelClose ( ) ) ;\n cancel_observer . Wait ( ) ;\n EXPECT_FALSE ( browser_shutdown : : IsTryingToQuit ( ) ) ;\n EXPECT_EQ ( 1 , browsers_ [ 0 ] -> tab_strip_model ( ) -> count ( ) ) ;\n EXPECT_EQ ( 1 , browsers_ [ 1 ] -> tab_strip_model ( ) -> count ( ) ) ;\n RepeatedNotificationObserver close_observer ( chrome : : NOTIFICATION_BROWSER_CLOSED , 2 ) ;\n chrome : : CloseAllBrowsersAndQuit ( ) ;\n ASSERT_FALSE ( browsers_ [ 1 ] -> ShouldCloseWindow ( ) ) ;\n ASSERT_NO_FATAL_FAILURE ( AcceptClose ( ) ) ;\n ASSERT_NO_FATAL_FAILURE ( AcceptClose ( ) ) ;\n close_observer . Wait ( ) ;\n EXPECT_TRUE ( browser_shutdown : : IsTryingToQuit ( ) ) ;\n EXPECT_TRUE ( BrowserList : : GetInstance ( ) -> empty ( ) ) ;\n }", "idx": 550}
{"hash": -3889154245145551951, "project": "debian", "size": 76, "label": 0, "functionSource": "static void stream_blob ( uintmax_t len , unsigned char * sha1out , uintmax_t mark ) {\n size_t in_sz = 64 * 1024 , out_sz = 64 * 1024 ;\n unsigned char * in_buf = xmalloc ( in_sz ) ;\n unsigned char * out_buf = xmalloc ( out_sz ) ;\n struct object_entry * e ;\n unsigned char sha1 [ 20 ] ;\n unsigned long hdrlen ;\n off_t offset ;\n git_SHA_CTX c ;\n git_zstream s ;\n struct sha1file_checkpoint checkpoint ;\n int status = Z_OK ;\n if ( ( max_packsize && ( pack_size + 60 + len ) > max_packsize ) || ( pack_size + 60 + len ) < pack_size ) cycle_packfile ( ) ;\n sha1file_checkpoint ( pack_file , & checkpoint ) ;\n offset = checkpoint . offset ;\n hdrlen = snprintf ( ( char * ) out_buf , out_sz , \"blob %\" PRIuMAX , len ) + 1 ;\n if ( out_sz <= hdrlen ) die ( \"impossibly large object header\" ) ;\n git_SHA1_Init ( & c ) ;\n git_SHA1_Update ( & c , out_buf , hdrlen ) ;\n crc32_begin ( pack_file ) ;\n git_deflate_init ( & s , pack_compression_level ) ;\n hdrlen = encode_in_pack_object_header ( OBJ_BLOB , len , out_buf ) ;\n if ( out_sz <= hdrlen ) die ( \"impossibly large object header\" ) ;\n s . next_out = out_buf + hdrlen ;\n s . avail_out = out_sz - hdrlen ;\n while ( status != Z_STREAM_END ) {\n if ( 0 < len && ! s . avail_in ) {\n size_t cnt = in_sz < len ? in_sz : ( size_t ) len ;\n size_t n = fread ( in_buf , 1 , cnt , stdin ) ;\n if ( ! n && feof ( stdin ) ) die ( \"EOF in data (%\" PRIuMAX \" bytes remaining)\" , len ) ;\n git_SHA1_Update ( & c , in_buf , n ) ;\n s . next_in = in_buf ;\n s . avail_in = n ;\n len -= n ;\n }\n status = git_deflate ( & s , len ? 0 : Z_FINISH ) ;\n if ( ! s . avail_out || status == Z_STREAM_END ) {\n size_t n = s . next_out - out_buf ;\n sha1write ( pack_file , out_buf , n ) ;\n pack_size += n ;\n s . next_out = out_buf ;\n s . avail_out = out_sz ;\n }\n switch ( status ) {\n case Z_OK : case Z_BUF_ERROR : case Z_STREAM_END : continue ;\n default : die ( \"unexpected deflate failure: %d\" , status ) ;\n }\n }\n git_deflate_end ( & s ) ;\n git_SHA1_Final ( sha1 , & c ) ;\n if ( sha1out ) hashcpy ( sha1out , sha1 ) ;\n e = insert_object ( sha1 ) ;\n if ( mark ) insert_mark ( mark , e ) ;\n if ( e -> idx . offset ) {\n duplicate_count_by_type [ OBJ_BLOB ] ++ ;\n truncate_pack ( & checkpoint ) ;\n }\n else if ( find_sha1_pack ( sha1 , packed_git ) ) {\n e -> type = OBJ_BLOB ;\n e -> pack_id = MAX_PACK_ID ;\n e -> idx . offset = 1 ;\n duplicate_count_by_type [ OBJ_BLOB ] ++ ;\n truncate_pack ( & checkpoint ) ;\n }\n else {\n e -> depth = 0 ;\n e -> type = OBJ_BLOB ;\n e -> pack_id = pack_id ;\n e -> idx . offset = offset ;\n e -> idx . crc32 = crc32_end ( pack_file ) ;\n object_count ++ ;\n object_count_by_type [ OBJ_BLOB ] ++ ;\n }\n free ( in_buf ) ;\n free ( out_buf ) ;\n }", "idx": 551}
{"hash": 229962612204196999, "project": "debian", "size": 6, "label": 0, "functionSource": "static void curl_setup_http_get ( CURL * curl , const char * url , const char * custom_req ) {\n curl_easy_setopt ( curl , CURLOPT_HTTPGET , 1 ) ;\n curl_easy_setopt ( curl , CURLOPT_URL , url ) ;\n curl_easy_setopt ( curl , CURLOPT_CUSTOMREQUEST , custom_req ) ;\n curl_easy_setopt ( curl , CURLOPT_WRITEFUNCTION , fwrite_null ) ;\n }", "idx": 552}
{"hash": -3805791263064294216, "project": "debian", "size": 393, "label": 0, "functionSource": "int phar_parse_tarfile ( php_stream * fp , char * fname , int fname_len , char * alias , int alias_len , phar_archive_data * * pphar , int is_data , php_uint32 compression , char * * error TSRMLS_DC ) {\n char buf [ 512 ] , * actual_alias = NULL , * p ;\n phar_entry_info entry = {\n 0 }\n ;\n size_t pos = 0 , read , totalsize ;\n tar_header * hdr ;\n php_uint32 sum1 , sum2 , size , old ;\n phar_archive_data * myphar , * * actual ;\n int last_was_longlink = 0 ;\n if ( error ) {\n * error = NULL ;\n }\n php_stream_seek ( fp , 0 , SEEK_END ) ;\n totalsize = php_stream_tell ( fp ) ;\n php_stream_seek ( fp , 0 , SEEK_SET ) ;\n read = php_stream_read ( fp , buf , sizeof ( buf ) ) ;\n if ( read != sizeof ( buf ) ) {\n if ( error ) {\n spprintf ( error , 4096 , \"phar error: \\\"%s\\\" is not a tar file or is truncated\" , fname ) ;\n }\n php_stream_close ( fp ) ;\n return FAILURE ;\n }\n hdr = ( tar_header * ) buf ;\n old = ( memcmp ( hdr -> magic , \"ustar\" , sizeof ( \"ustar\" ) - 1 ) != 0 ) ;\n myphar = ( phar_archive_data * ) pecalloc ( 1 , sizeof ( phar_archive_data ) , PHAR_G ( persist ) ) ;\n myphar -> is_persistent = PHAR_G ( persist ) ;\n zend_hash_init ( & myphar -> manifest , 2 + ( totalsize >> 12 ) , zend_get_hash_value , destroy_phar_manifest_entry , ( zend_bool ) myphar -> is_persistent ) ;\n zend_hash_init ( & myphar -> mounted_dirs , 5 , zend_get_hash_value , NULL , ( zend_bool ) myphar -> is_persistent ) ;\n zend_hash_init ( & myphar -> virtual_dirs , 4 + ( totalsize >> 11 ) , zend_get_hash_value , NULL , ( zend_bool ) myphar -> is_persistent ) ;\n myphar -> is_tar = 1 ;\n myphar -> flags = compression ;\n entry . is_tar = 1 ;\n entry . is_crc_checked = 1 ;\n entry . phar = myphar ;\n pos += sizeof ( buf ) ;\n do {\n phar_entry_info * newentry ;\n pos = php_stream_tell ( fp ) ;\n hdr = ( tar_header * ) buf ;\n sum1 = phar_tar_number ( hdr -> checksum , sizeof ( hdr -> checksum ) ) ;\n if ( sum1 == 0 && phar_tar_checksum ( buf , sizeof ( buf ) ) == 0 ) {\n break ;\n }\n memset ( hdr -> checksum , ' ' , sizeof ( hdr -> checksum ) ) ;\n sum2 = phar_tar_checksum ( buf , old ? sizeof ( old_tar_header ) : sizeof ( tar_header ) ) ;\n size = entry . uncompressed_filesize = entry . compressed_filesize = phar_tar_number ( hdr -> size , sizeof ( hdr -> size ) ) ;\n if ( ( ( ! old && hdr -> prefix [ 0 ] == 0 ) || old ) && strlen ( hdr -> name ) == sizeof ( \".phar/signature.bin\" ) - 1 && ! strncmp ( hdr -> name , \".phar/signature.bin\" , sizeof ( \".phar/signature.bin\" ) - 1 ) ) {\n off_t curloc ;\n if ( size > 511 ) {\n if ( error ) {\n spprintf ( error , 4096 , \"phar error: tar-based phar \\\"%s\\\" has signature that is larger than 511 bytes, cannot process\" , fname ) ;\n }\n bail : php_stream_close ( fp ) ;\n phar_destroy_phar_data ( myphar TSRMLS_CC ) ;\n return FAILURE ;\n }\n curloc = php_stream_tell ( fp ) ;\n read = php_stream_read ( fp , buf , size ) ;\n if ( read != size ) {\n if ( error ) {\n spprintf ( error , 4096 , \"phar error: tar-based phar \\\"%s\\\" signature cannot be read\" , fname ) ;\n }\n goto bail ;\n }\n # ifdef WORDS_BIGENDIAN # define PHAR_GET_32 ( buffer ) \\ ( ( ( ( ( unsigned char * ) ( buffer ) ) [ 3 ] ) << 24 ) \\ | ( ( ( ( unsigned char * ) ( buffer ) ) [ 2 ] ) << 16 ) \\ | ( ( ( ( unsigned char * ) ( buffer ) ) [ 1 ] ) << 8 ) \\ | ( ( ( unsigned char * ) ( buffer ) ) [ 0 ] ) ) # else # define PHAR_GET_32 ( buffer ) ( php_uint32 ) * ( buffer ) # endif myphar -> sig_flags = PHAR_GET_32 ( buf ) ;\n if ( FAILURE == phar_verify_signature ( fp , php_stream_tell ( fp ) - size - 512 , myphar -> sig_flags , buf + 8 , size - 8 , fname , & myphar -> signature , & myphar -> sig_len , error TSRMLS_CC ) ) {\n if ( error ) {\n char * save = * error ;\n spprintf ( error , 4096 , \"phar error: tar-based phar \\\"%s\\\" signature cannot be verified: %s\" , fname , save ) ;\n efree ( save ) ;\n }\n goto bail ;\n }\n php_stream_seek ( fp , curloc + 512 , SEEK_SET ) ;\n if ( ( ( hdr -> typeflag == '\\0' ) || ( hdr -> typeflag == TAR_FILE ) ) && size > 0 ) {\n php_stream_seek ( fp , 512 , SEEK_CUR ) ;\n if ( ( uint ) php_stream_tell ( fp ) > totalsize ) {\n if ( error ) {\n spprintf ( error , 4096 , \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\" , fname ) ;\n }\n php_stream_close ( fp ) ;\n phar_destroy_phar_data ( myphar TSRMLS_CC ) ;\n return FAILURE ;\n }\n }\n read = php_stream_read ( fp , buf , sizeof ( buf ) ) ;\n if ( read != sizeof ( buf ) ) {\n if ( error ) {\n spprintf ( error , 4096 , \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\" , fname ) ;\n }\n php_stream_close ( fp ) ;\n phar_destroy_phar_data ( myphar TSRMLS_CC ) ;\n return FAILURE ;\n }\n hdr = ( tar_header * ) buf ;\n sum1 = phar_tar_number ( hdr -> checksum , sizeof ( hdr -> checksum ) ) ;\n if ( sum1 == 0 && phar_tar_checksum ( buf , sizeof ( buf ) ) == 0 ) {\n break ;\n }\n if ( error ) {\n spprintf ( error , 4096 , \"phar error: \\\"%s\\\" has entries after signature, invalid phar\" , fname ) ;\n }\n goto bail ;\n }\n if ( ! last_was_longlink && hdr -> typeflag == 'L' ) {\n last_was_longlink = 1 ;\n entry . filename_len = entry . uncompressed_filesize ;\n if ( entry . filename_len == UINT_MAX ) {\n if ( error ) {\n spprintf ( error , 4096 , \"phar error: \\\"%s\\\" is a corrupted tar file (invalid entry size)\" , fname ) ;\n }\n php_stream_close ( fp ) ;\n phar_destroy_phar_data ( myphar TSRMLS_CC ) ;\n return FAILURE ;\n }\n entry . filename = pemalloc ( entry . filename_len + 1 , myphar -> is_persistent ) ;\n read = php_stream_read ( fp , entry . filename , entry . filename_len ) ;\n if ( read != entry . filename_len ) {\n efree ( entry . filename ) ;\n if ( error ) {\n spprintf ( error , 4096 , \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\" , fname ) ;\n }\n php_stream_close ( fp ) ;\n phar_destroy_phar_data ( myphar TSRMLS_CC ) ;\n return FAILURE ;\n }\n entry . filename [ entry . filename_len ] = '\\0' ;\n size = ( ( size + 511 ) & ~ 511 ) - size ;\n php_stream_seek ( fp , size , SEEK_CUR ) ;\n if ( ( uint ) php_stream_tell ( fp ) > totalsize ) {\n efree ( entry . filename ) ;\n if ( error ) {\n spprintf ( error , 4096 , \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\" , fname ) ;\n }\n php_stream_close ( fp ) ;\n phar_destroy_phar_data ( myphar TSRMLS_CC ) ;\n return FAILURE ;\n }\n read = php_stream_read ( fp , buf , sizeof ( buf ) ) ;\n if ( read != sizeof ( buf ) ) {\n efree ( entry . filename ) ;\n if ( error ) {\n spprintf ( error , 4096 , \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\" , fname ) ;\n }\n php_stream_close ( fp ) ;\n phar_destroy_phar_data ( myphar TSRMLS_CC ) ;\n return FAILURE ;\n }\n continue ;\n }\n else if ( ! last_was_longlink && ! old && hdr -> prefix [ 0 ] != 0 ) {\n char name [ 256 ] ;\n int i , j ;\n for ( i = 0 ;\n i < 155 ;\n i ++ ) {\n name [ i ] = hdr -> prefix [ i ] ;\n if ( name [ i ] == '\\0' ) {\n break ;\n }\n }\n name [ i ++ ] = '/' ;\n for ( j = 0 ;\n j < 100 ;\n j ++ ) {\n name [ i + j ] = hdr -> name [ j ] ;\n if ( name [ i + j ] == '\\0' ) {\n break ;\n }\n }\n entry . filename_len = i + j ;\n if ( name [ entry . filename_len - 1 ] == '/' ) {\n entry . filename_len -- ;\n }\n entry . filename = pestrndup ( name , entry . filename_len , myphar -> is_persistent ) ;\n }\n else if ( ! last_was_longlink ) {\n int i ;\n for ( i = 0 ;\n i < 100 ;\n i ++ ) {\n if ( hdr -> name [ i ] == '\\0' ) {\n break ;\n }\n }\n entry . filename_len = i ;\n entry . filename = pestrndup ( hdr -> name , i , myphar -> is_persistent ) ;\n if ( i > 0 && entry . filename [ entry . filename_len - 1 ] == '/' ) {\n entry . filename [ entry . filename_len - 1 ] = '\\0' ;\n entry . filename_len -- ;\n }\n }\n last_was_longlink = 0 ;\n phar_add_virtual_dirs ( myphar , entry . filename , entry . filename_len TSRMLS_CC ) ;\n if ( sum1 != sum2 ) {\n if ( error ) {\n spprintf ( error , 4096 , \"phar error: \\\"%s\\\" is a corrupted tar file (checksum mismatch of file \\\"%s\\\")\" , fname , entry . filename ) ;\n }\n pefree ( entry . filename , myphar -> is_persistent ) ;\n php_stream_close ( fp ) ;\n phar_destroy_phar_data ( myphar TSRMLS_CC ) ;\n return FAILURE ;\n }\n entry . tar_type = ( ( old & ( hdr -> typeflag == '\\0' ) ) ? TAR_FILE : hdr -> typeflag ) ;\n entry . offset = entry . offset_abs = pos ;\n entry . fp_type = PHAR_FP ;\n entry . flags = phar_tar_number ( hdr -> mode , sizeof ( hdr -> mode ) ) & PHAR_ENT_PERM_MASK ;\n entry . timestamp = phar_tar_number ( hdr -> mtime , sizeof ( hdr -> mtime ) ) ;\n entry . is_persistent = myphar -> is_persistent ;\n # ifndef S_ISDIR # define S_ISDIR ( mode ) ( ( ( mode ) & S_IFMT ) == S_IFDIR ) # endif if ( old && entry . tar_type == TAR_FILE && S_ISDIR ( entry . flags ) ) {\n entry . tar_type = TAR_DIR ;\n }\n if ( entry . tar_type == TAR_DIR ) {\n entry . is_dir = 1 ;\n }\n else {\n entry . is_dir = 0 ;\n }\n entry . link = NULL ;\n if ( entry . tar_type == TAR_LINK ) {\n if ( ! zend_hash_exists ( & myphar -> manifest , hdr -> linkname , strlen ( hdr -> linkname ) ) ) {\n if ( error ) {\n spprintf ( error , 4096 , \"phar error: \\\"%s\\\" is a corrupted tar file - hard link to non-existent file \\\"%s\\\"\" , fname , hdr -> linkname ) ;\n }\n pefree ( entry . filename , entry . is_persistent ) ;\n php_stream_close ( fp ) ;\n phar_destroy_phar_data ( myphar TSRMLS_CC ) ;\n return FAILURE ;\n }\n entry . link = estrdup ( hdr -> linkname ) ;\n }\n else if ( entry . tar_type == TAR_SYMLINK ) {\n entry . link = estrdup ( hdr -> linkname ) ;\n }\n phar_set_inode ( & entry TSRMLS_CC ) ;\n zend_hash_add ( & myphar -> manifest , entry . filename , entry . filename_len , ( void * ) & entry , sizeof ( phar_entry_info ) , ( void * * ) & newentry ) ;\n if ( entry . is_persistent ) {\n ++ entry . manifest_pos ;\n }\n if ( entry . filename_len >= sizeof ( \".phar/.metadata\" ) - 1 && ! memcmp ( entry . filename , \".phar/.metadata\" , sizeof ( \".phar/.metadata\" ) - 1 ) ) {\n if ( FAILURE == phar_tar_process_metadata ( newentry , fp TSRMLS_CC ) ) {\n if ( error ) {\n spprintf ( error , 4096 , \"phar error: tar-based phar \\\"%s\\\" has invalid metadata in magic file \\\"%s\\\"\" , fname , entry . filename ) ;\n }\n php_stream_close ( fp ) ;\n phar_destroy_phar_data ( myphar TSRMLS_CC ) ;\n return FAILURE ;\n }\n }\n if ( ! actual_alias && entry . filename_len == sizeof ( \".phar/alias.txt\" ) - 1 && ! strncmp ( entry . filename , \".phar/alias.txt\" , sizeof ( \".phar/alias.txt\" ) - 1 ) ) {\n if ( size > 511 ) {\n if ( error ) {\n spprintf ( error , 4096 , \"phar error: tar-based phar \\\"%s\\\" has alias that is larger than 511 bytes, cannot process\" , fname ) ;\n }\n php_stream_close ( fp ) ;\n phar_destroy_phar_data ( myphar TSRMLS_CC ) ;\n return FAILURE ;\n }\n read = php_stream_read ( fp , buf , size ) ;\n if ( read == size ) {\n buf [ size ] = '\\0' ;\n if ( ! phar_validate_alias ( buf , size ) ) {\n if ( size > 50 ) {\n buf [ 50 ] = '.' ;\n buf [ 51 ] = '.' ;\n buf [ 52 ] = '.' ;\n buf [ 53 ] = '\\0' ;\n }\n if ( error ) {\n spprintf ( error , 4096 , \"phar error: invalid alias \\\"%s\\\" in tar-based phar \\\"%s\\\"\" , buf , fname ) ;\n }\n php_stream_close ( fp ) ;\n phar_destroy_phar_data ( myphar TSRMLS_CC ) ;\n return FAILURE ;\n }\n actual_alias = pestrndup ( buf , size , myphar -> is_persistent ) ;\n myphar -> alias = actual_alias ;\n myphar -> alias_len = size ;\n php_stream_seek ( fp , pos , SEEK_SET ) ;\n }\n else {\n if ( error ) {\n spprintf ( error , 4096 , \"phar error: Unable to read alias from tar-based phar \\\"%s\\\"\" , fname ) ;\n }\n php_stream_close ( fp ) ;\n phar_destroy_phar_data ( myphar TSRMLS_CC ) ;\n return FAILURE ;\n }\n }\n size = ( size + 511 ) & ~ 511 ;\n if ( ( ( hdr -> typeflag == '\\0' ) || ( hdr -> typeflag == TAR_FILE ) ) && size > 0 ) {\n php_stream_seek ( fp , size , SEEK_CUR ) ;\n if ( ( uint ) php_stream_tell ( fp ) > totalsize ) {\n if ( error ) {\n spprintf ( error , 4096 , \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\" , fname ) ;\n }\n php_stream_close ( fp ) ;\n phar_destroy_phar_data ( myphar TSRMLS_CC ) ;\n return FAILURE ;\n }\n }\n read = php_stream_read ( fp , buf , sizeof ( buf ) ) ;\n if ( read != sizeof ( buf ) ) {\n if ( error ) {\n spprintf ( error , 4096 , \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\" , fname ) ;\n }\n php_stream_close ( fp ) ;\n phar_destroy_phar_data ( myphar TSRMLS_CC ) ;\n return FAILURE ;\n }\n }\n while ( read != 0 ) ;\n if ( zend_hash_exists ( & ( myphar -> manifest ) , \".phar/stub.php\" , sizeof ( \".phar/stub.php\" ) - 1 ) ) {\n myphar -> is_data = 0 ;\n }\n else {\n myphar -> is_data = 1 ;\n }\n if ( ! myphar -> is_data && PHAR_G ( require_hash ) && ! myphar -> signature ) {\n php_stream_close ( fp ) ;\n phar_destroy_phar_data ( myphar TSRMLS_CC ) ;\n if ( error ) {\n spprintf ( error , 0 , \"tar-based phar \\\"%s\\\" does not have a signature\" , fname ) ;\n }\n return FAILURE ;\n }\n myphar -> fname = pestrndup ( fname , fname_len , myphar -> is_persistent ) ;\n # ifdef PHP_WIN32 phar_unixify_path_separators ( myphar -> fname , fname_len ) ;\n # endif myphar -> fname_len = fname_len ;\n myphar -> fp = fp ;\n p = strrchr ( myphar -> fname , '/' ) ;\n if ( p ) {\n myphar -> ext = memchr ( p , '.' , ( myphar -> fname + fname_len ) - p ) ;\n if ( myphar -> ext == p ) {\n myphar -> ext = memchr ( p + 1 , '.' , ( myphar -> fname + fname_len ) - p - 1 ) ;\n }\n if ( myphar -> ext ) {\n myphar -> ext_len = ( myphar -> fname + fname_len ) - myphar -> ext ;\n }\n }\n phar_request_initialize ( TSRMLS_C ) ;\n if ( SUCCESS != zend_hash_add ( & ( PHAR_GLOBALS -> phar_fname_map ) , myphar -> fname , fname_len , ( void * ) & myphar , sizeof ( phar_archive_data * ) , ( void * * ) & actual ) ) {\n if ( error ) {\n spprintf ( error , 4096 , \"phar error: Unable to add tar-based phar \\\"%s\\\" to phar registry\" , fname ) ;\n }\n php_stream_close ( fp ) ;\n phar_destroy_phar_data ( myphar TSRMLS_CC ) ;\n return FAILURE ;\n }\n myphar = * actual ;\n if ( actual_alias ) {\n phar_archive_data * * fd_ptr ;\n myphar -> is_temporary_alias = 0 ;\n if ( SUCCESS == zend_hash_find ( & ( PHAR_GLOBALS -> phar_alias_map ) , actual_alias , myphar -> alias_len , ( void * * ) & fd_ptr ) ) {\n if ( SUCCESS != phar_free_alias ( * fd_ptr , actual_alias , myphar -> alias_len TSRMLS_CC ) ) {\n if ( error ) {\n spprintf ( error , 4096 , \"phar error: Unable to add tar-based phar \\\"%s\\\", alias is already in use\" , fname ) ;\n }\n zend_hash_del ( & ( PHAR_GLOBALS -> phar_fname_map ) , myphar -> fname , fname_len ) ;\n return FAILURE ;\n }\n }\n zend_hash_add ( & ( PHAR_GLOBALS -> phar_alias_map ) , actual_alias , myphar -> alias_len , ( void * ) & myphar , sizeof ( phar_archive_data * ) , NULL ) ;\n }\n else {\n phar_archive_data * * fd_ptr ;\n if ( alias_len ) {\n if ( SUCCESS == zend_hash_find ( & ( PHAR_GLOBALS -> phar_alias_map ) , alias , alias_len , ( void * * ) & fd_ptr ) ) {\n if ( SUCCESS != phar_free_alias ( * fd_ptr , alias , alias_len TSRMLS_CC ) ) {\n if ( error ) {\n spprintf ( error , 4096 , \"phar error: Unable to add tar-based phar \\\"%s\\\", alias is already in use\" , fname ) ;\n }\n zend_hash_del ( & ( PHAR_GLOBALS -> phar_fname_map ) , myphar -> fname , fname_len ) ;\n return FAILURE ;\n }\n }\n zend_hash_add ( & ( PHAR_GLOBALS -> phar_alias_map ) , alias , alias_len , ( void * ) & myphar , sizeof ( phar_archive_data * ) , NULL ) ;\n myphar -> alias = pestrndup ( alias , alias_len , myphar -> is_persistent ) ;\n myphar -> alias_len = alias_len ;\n }\n else {\n myphar -> alias = pestrndup ( myphar -> fname , fname_len , myphar -> is_persistent ) ;\n myphar -> alias_len = fname_len ;\n }\n myphar -> is_temporary_alias = 1 ;\n }\n if ( pphar ) {\n * pphar = myphar ;\n }\n return SUCCESS ;\n }", "idx": 553}
{"hash": 1223258652239369123, "project": "debian", "size": 11, "label": 0, "functionSource": "SPL_METHOD ( SplFileObject , next ) {\n spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n if ( zend_parse_parameters_none ( ) == FAILURE ) {\n return ;\n }\n spl_filesystem_file_free_line ( intern TSRMLS_CC ) ;\n if ( SPL_HAS_FLAG ( intern -> flags , SPL_FILE_OBJECT_READ_AHEAD ) ) {\n spl_filesystem_file_read_line ( getThis ( ) , intern , 1 TSRMLS_CC ) ;\n }\n intern -> u . file . current_line_num ++ ;\n }", "idx": 554}
{"hash": 4489017523191997023, "project": "debian", "size": 10, "label": 0, "functionSource": "static int dissect_h225_AdmissionRejectReason ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 669 \"./asn1/h225/h225.cnf\" gint32 value ;\n h225_packet_info * h225_pi ;\n h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_AdmissionRejectReason , AdmissionRejectReason_choice , & value ) ;\n if ( h225_pi != NULL ) {\n h225_pi -> reason = value ;\n }\n return offset ;\n }", "idx": 555}
{"hash": -3943803018993195328, "project": "debian", "size": 53, "label": 0, "functionSource": "static int ra144_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n AVFrame * frame = data ;\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n static const uint8_t sizes [ LPC_ORDER ] = {\n 6 , 5 , 5 , 4 , 4 , 3 , 3 , 3 , 3 , 2 }\n ;\n unsigned int refl_rms [ NBLOCKS ] ;\n uint16_t block_coefs [ NBLOCKS ] [ LPC_ORDER ] ;\n unsigned int lpc_refl [ LPC_ORDER ] ;\n int i , j ;\n int ret ;\n int16_t * samples ;\n unsigned int energy ;\n RA144Context * ractx = avctx -> priv_data ;\n GetBitContext gb ;\n frame -> nb_samples = NBLOCKS * BLOCKSIZE ;\n if ( ( ret = ff_get_buffer ( avctx , frame , 0 ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n samples = ( int16_t * ) frame -> data [ 0 ] ;\n if ( buf_size < FRAMESIZE ) {\n av_log ( avctx , AV_LOG_ERROR , \"Frame too small (%d bytes). Truncated file?\\n\" , buf_size ) ;\n * got_frame_ptr = 0 ;\n return buf_size ;\n }\n init_get_bits ( & gb , buf , FRAMESIZE * 8 ) ;\n for ( i = 0 ;\n i < LPC_ORDER ;\n i ++ ) lpc_refl [ i ] = ff_lpc_refl_cb [ i ] [ get_bits ( & gb , sizes [ i ] ) ] ;\n ff_eval_coefs ( ractx -> lpc_coef [ 0 ] , lpc_refl ) ;\n ractx -> lpc_refl_rms [ 0 ] = ff_rms ( lpc_refl ) ;\n energy = ff_energy_tab [ get_bits ( & gb , 5 ) ] ;\n refl_rms [ 0 ] = ff_interp ( ractx , block_coefs [ 0 ] , 1 , 1 , ractx -> old_energy ) ;\n refl_rms [ 1 ] = ff_interp ( ractx , block_coefs [ 1 ] , 2 , energy <= ractx -> old_energy , ff_t_sqrt ( energy * ractx -> old_energy ) >> 12 ) ;\n refl_rms [ 2 ] = ff_interp ( ractx , block_coefs [ 2 ] , 3 , 0 , energy ) ;\n refl_rms [ 3 ] = ff_rescale_rms ( ractx -> lpc_refl_rms [ 0 ] , energy ) ;\n ff_int_to_int16 ( block_coefs [ 3 ] , ractx -> lpc_coef [ 0 ] ) ;\n for ( i = 0 ;\n i < NBLOCKS ;\n i ++ ) {\n do_output_subblock ( ractx , block_coefs [ i ] , refl_rms [ i ] , & gb ) ;\n for ( j = 0 ;\n j < BLOCKSIZE ;\n j ++ ) * samples ++ = av_clip_int16 ( ractx -> curr_sblock [ j + 10 ] << 2 ) ;\n }\n ractx -> old_energy = energy ;\n ractx -> lpc_refl_rms [ 1 ] = ractx -> lpc_refl_rms [ 0 ] ;\n FFSWAP ( unsigned int * , ractx -> lpc_coef [ 0 ] , ractx -> lpc_coef [ 1 ] ) ;\n * got_frame_ptr = 1 ;\n return FRAMESIZE ;\n }", "idx": 556}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_RedundancyEncodingCapability ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_RedundancyEncodingCapability , RedundancyEncodingCapability_sequence ) ;\n return offset ;\n }", "idx": 557}
{"hash": 2830888773500127914, "project": "debian", "size": 43, "label": 0, "functionSource": "static void check_for_jsonb_9_4_usage ( ClusterInfo * cluster ) {\n int dbnum ;\n FILE * script = NULL ;\n bool found = false ;\n char output_path [ MAXPGPATH ] ;\n prep_status ( \"Checking for JSONB user data types\" ) ;\n snprintf ( output_path , sizeof ( output_path ) , \"tables_using_jsonb.txt\" ) ;\n for ( dbnum = 0 ;\n dbnum < cluster -> dbarr . ndbs ;\n dbnum ++ ) {\n PGresult * res ;\n bool db_used = false ;\n int ntups ;\n int rowno ;\n int i_nspname , i_relname , i_attname ;\n DbInfo * active_db = & cluster -> dbarr . dbs [ dbnum ] ;\n PGconn * conn = connectToServer ( cluster , active_db -> db_name ) ;\n res = executeQueryOrDie ( conn , \"SELECT n.nspname, c.relname, a.attname \" \"FROM pg_catalog.pg_class c, \" \" pg_catalog.pg_namespace n, \" \" pg_catalog.pg_attribute a \" \"WHERE c.oid = a.attrelid AND \" \" NOT a.attisdropped AND \" \" a.atttypid = 'pg_catalog.jsonb'::pg_catalog.regtype AND \" \" c.relnamespace = n.oid AND \" \" n.nspname !~ '^pg_temp_' AND \" \" n.nspname NOT IN ('pg_catalog', 'information_schema')\" ) ;\n ntups = PQntuples ( res ) ;\n i_nspname = PQfnumber ( res , \"nspname\" ) ;\n i_relname = PQfnumber ( res , \"relname\" ) ;\n i_attname = PQfnumber ( res , \"attname\" ) ;\n for ( rowno = 0 ;\n rowno < ntups ;\n rowno ++ ) {\n found = true ;\n if ( script == NULL && ( script = fopen_priv ( output_path , \"w\" ) ) == NULL ) pg_fatal ( \"Could not open file \\\"%s\\\": %s\\n\" , output_path , getErrorText ( ) ) ;\n if ( ! db_used ) {\n fprintf ( script , \"Database: %s\\n\" , active_db -> db_name ) ;\n db_used = true ;\n }\n fprintf ( script , \" %s.%s.%s\\n\" , PQgetvalue ( res , rowno , i_nspname ) , PQgetvalue ( res , rowno , i_relname ) , PQgetvalue ( res , rowno , i_attname ) ) ;\n }\n PQclear ( res ) ;\n PQfinish ( conn ) ;\n }\n if ( script ) fclose ( script ) ;\n if ( found ) {\n pg_log ( PG_REPORT , \"fatal\\n\" ) ;\n pg_fatal ( \"Your installation contains one of the JSONB data types in user tables.\\n\" \"The internal format of JSONB changed during 9.4 beta so this cluster cannot currently\\n\" \"be upgraded. You can remove the problem tables and restart the upgrade. A list\\n\" \"of the problem columns is in the file:\\n\" \" %s\\n\\n\" , output_path ) ;\n }\n else check_ok ( ) ;\n }", "idx": 558}
{"hash": 3192165150896245305, "project": "debian", "size": 72, "label": 0, "functionSource": "void bn_sqr_comba8 ( BN_ULONG * r , const BN_ULONG * a ) {\n BN_ULONG c1 , c2 , c3 ;\n c1 = 0 ;\n c2 = 0 ;\n c3 = 0 ;\n sqr_add_c ( a , 0 , c1 , c2 , c3 ) ;\n r [ 0 ] = c1 ;\n c1 = 0 ;\n sqr_add_c2 ( a , 1 , 0 , c2 , c3 , c1 ) ;\n r [ 1 ] = c2 ;\n c2 = 0 ;\n sqr_add_c ( a , 1 , c3 , c1 , c2 ) ;\n sqr_add_c2 ( a , 2 , 0 , c3 , c1 , c2 ) ;\n r [ 2 ] = c3 ;\n c3 = 0 ;\n sqr_add_c2 ( a , 3 , 0 , c1 , c2 , c3 ) ;\n sqr_add_c2 ( a , 2 , 1 , c1 , c2 , c3 ) ;\n r [ 3 ] = c1 ;\n c1 = 0 ;\n sqr_add_c ( a , 2 , c2 , c3 , c1 ) ;\n sqr_add_c2 ( a , 3 , 1 , c2 , c3 , c1 ) ;\n sqr_add_c2 ( a , 4 , 0 , c2 , c3 , c1 ) ;\n r [ 4 ] = c2 ;\n c2 = 0 ;\n sqr_add_c2 ( a , 5 , 0 , c3 , c1 , c2 ) ;\n sqr_add_c2 ( a , 4 , 1 , c3 , c1 , c2 ) ;\n sqr_add_c2 ( a , 3 , 2 , c3 , c1 , c2 ) ;\n r [ 5 ] = c3 ;\n c3 = 0 ;\n sqr_add_c ( a , 3 , c1 , c2 , c3 ) ;\n sqr_add_c2 ( a , 4 , 2 , c1 , c2 , c3 ) ;\n sqr_add_c2 ( a , 5 , 1 , c1 , c2 , c3 ) ;\n sqr_add_c2 ( a , 6 , 0 , c1 , c2 , c3 ) ;\n r [ 6 ] = c1 ;\n c1 = 0 ;\n sqr_add_c2 ( a , 7 , 0 , c2 , c3 , c1 ) ;\n sqr_add_c2 ( a , 6 , 1 , c2 , c3 , c1 ) ;\n sqr_add_c2 ( a , 5 , 2 , c2 , c3 , c1 ) ;\n sqr_add_c2 ( a , 4 , 3 , c2 , c3 , c1 ) ;\n r [ 7 ] = c2 ;\n c2 = 0 ;\n sqr_add_c ( a , 4 , c3 , c1 , c2 ) ;\n sqr_add_c2 ( a , 5 , 3 , c3 , c1 , c2 ) ;\n sqr_add_c2 ( a , 6 , 2 , c3 , c1 , c2 ) ;\n sqr_add_c2 ( a , 7 , 1 , c3 , c1 , c2 ) ;\n r [ 8 ] = c3 ;\n c3 = 0 ;\n sqr_add_c2 ( a , 7 , 2 , c1 , c2 , c3 ) ;\n sqr_add_c2 ( a , 6 , 3 , c1 , c2 , c3 ) ;\n sqr_add_c2 ( a , 5 , 4 , c1 , c2 , c3 ) ;\n r [ 9 ] = c1 ;\n c1 = 0 ;\n sqr_add_c ( a , 5 , c2 , c3 , c1 ) ;\n sqr_add_c2 ( a , 6 , 4 , c2 , c3 , c1 ) ;\n sqr_add_c2 ( a , 7 , 3 , c2 , c3 , c1 ) ;\n r [ 10 ] = c2 ;\n c2 = 0 ;\n sqr_add_c2 ( a , 7 , 4 , c3 , c1 , c2 ) ;\n sqr_add_c2 ( a , 6 , 5 , c3 , c1 , c2 ) ;\n r [ 11 ] = c3 ;\n c3 = 0 ;\n sqr_add_c ( a , 6 , c1 , c2 , c3 ) ;\n sqr_add_c2 ( a , 7 , 5 , c1 , c2 , c3 ) ;\n r [ 12 ] = c1 ;\n c1 = 0 ;\n sqr_add_c2 ( a , 7 , 6 , c2 , c3 , c1 ) ;\n r [ 13 ] = c2 ;\n c2 = 0 ;\n sqr_add_c ( a , 7 , c3 , c1 , c2 ) ;\n r [ 14 ] = c3 ;\n r [ 15 ] = c1 ;\n }", "idx": 559}
{"hash": 9099890689552893382, "project": "debian", "size": 6, "label": 0, "functionSource": "static void cpTags ( TIFF * in , TIFF * out ) {\n struct cpTag * p ;\n for ( p = tags ;\n p < & tags [ NTAGS ] ;\n p ++ ) cpTag ( in , out , p -> tag , p -> count , p -> type ) ;\n }", "idx": 560}
{"hash": 174091092490434632, "project": "chrome", "size": 11, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( AppApiTest , DISABLED_AppProcessRedirectBack ) {\n ASSERT_TRUE ( LoadExtension ( test_data_dir_ . AppendASCII ( \"app_process\" ) ) ) ;\n GURL base_url = GetTestBaseURL ( \"app_process\" ) ;\n chrome : : NewTab ( browser ( ) ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , base_url . Resolve ( \"path1/empty.html\" ) ) ;\n chrome : : NewTab ( browser ( ) ) ;\n ui_test_utils : : NavigateToURLBlockUntilNavigationsComplete ( browser ( ) , base_url . Resolve ( \"path1/redirect.html\" ) , 2 ) ;\n ASSERT_EQ ( 3 , browser ( ) -> tab_strip_model ( ) -> count ( ) ) ;\n EXPECT_EQ ( \"/extensions/api_test/app_process/path1/empty.html\" , browser ( ) -> tab_strip_model ( ) -> GetWebContentsAt ( 2 ) -> GetController ( ) . GetLastCommittedEntry ( ) -> GetURL ( ) . path ( ) ) ;\n EXPECT_EQ ( browser ( ) -> tab_strip_model ( ) -> GetWebContentsAt ( 1 ) -> GetRenderProcessHost ( ) , browser ( ) -> tab_strip_model ( ) -> GetWebContentsAt ( 2 ) -> GetRenderProcessHost ( ) ) ;\n }", "idx": 561}
{"hash": -3889154245145551951, "project": "debian", "size": 18, "label": 0, "functionSource": "static void git_pack_config ( void ) {\n int indexversion_value ;\n unsigned long packsizelimit_value ;\n if ( ! git_config_get_ulong ( \"pack.depth\" , & max_depth ) ) {\n if ( max_depth > MAX_DEPTH ) max_depth = MAX_DEPTH ;\n }\n if ( ! git_config_get_int ( \"pack.compression\" , & pack_compression_level ) ) {\n if ( pack_compression_level == - 1 ) pack_compression_level = Z_DEFAULT_COMPRESSION ;\n else if ( pack_compression_level < 0 || pack_compression_level > Z_BEST_COMPRESSION ) git_die_config ( \"pack.compression\" , \"bad pack compression level %d\" , pack_compression_level ) ;\n pack_compression_seen = 1 ;\n }\n if ( ! git_config_get_int ( \"pack.indexversion\" , & indexversion_value ) ) {\n pack_idx_opts . version = indexversion_value ;\n if ( pack_idx_opts . version > 2 ) git_die_config ( \"pack.indexversion\" , \"bad pack.indexversion=%\" PRIu32 , pack_idx_opts . version ) ;\n }\n if ( ! git_config_get_ulong ( \"pack.packsizelimit\" , & packsizelimit_value ) ) max_packsize = packsizelimit_value ;\n git_config ( git_default_config , NULL ) ;\n }", "idx": 562}
{"hash": -2423144171479606949, "project": "debian", "size": 4, "label": 0, "functionSource": "static void pdf_run_re ( fz_context * ctx , pdf_processor * proc , float x , float y , float w , float h ) {\n pdf_run_processor * pr = ( pdf_run_processor * ) proc ;\n fz_rectto ( ctx , pr -> path , x , y , x + w , y + h ) ;\n }", "idx": 563}
{"hash": -1929262071302712016, "project": "debian", "size": 5, "label": 0, "functionSource": "static void Type_LUTB2A_Free ( struct _cms_typehandler_struct * self , void * Ptr ) {\n cmsPipelineFree ( ( cmsPipeline * ) Ptr ) ;\n return ;\n cmsUNUSED_PARAMETER ( self ) ;\n }", "idx": 564}
{"hash": -1315695702746584250, "project": "debian", "size": 14, "label": 0, "functionSource": "static gboolean prefix_equal ( gconstpointer ap , gconstpointer bp ) {\n const gchar * a = ( const gchar * ) ap ;\n const gchar * b = ( const gchar * ) bp ;\n do {\n gchar ac = * a ++ ;\n gchar bc = * b ++ ;\n if ( ( ac == '.' || ac == '\\0' ) && ( bc == '.' || bc == '\\0' ) ) return TRUE ;\n if ( ( ac == '.' || ac == '\\0' ) && ! ( bc == '.' || bc == '\\0' ) ) return FALSE ;\n if ( ( bc == '.' || bc == '\\0' ) && ! ( ac == '.' || ac == '\\0' ) ) return FALSE ;\n if ( ac != bc ) return FALSE ;\n }\n while ( 1 ) ;\n return FALSE ;\n }", "idx": 565}
{"hash": -1929262071302712016, "project": "debian", "size": 19, "label": 0, "functionSource": "static void DupTagList ( struct _cmsContext_struct * ctx , const struct _cmsContext_struct * src ) {\n _cmsTagPluginChunkType newHead = {\n NULL }\n ;\n _cmsTagLinkedList * entry ;\n _cmsTagLinkedList * Anterior = NULL ;\n _cmsTagPluginChunkType * head = ( _cmsTagPluginChunkType * ) src -> chunks [ TagPlugin ] ;\n for ( entry = head -> Tag ;\n entry != NULL ;\n entry = entry -> Next ) {\n _cmsTagLinkedList * newEntry = ( _cmsTagLinkedList * ) _cmsSubAllocDup ( ctx -> MemPool , entry , sizeof ( _cmsTagLinkedList ) ) ;\n if ( newEntry == NULL ) return ;\n newEntry -> Next = NULL ;\n if ( Anterior ) Anterior -> Next = newEntry ;\n Anterior = newEntry ;\n if ( newHead . Tag == NULL ) newHead . Tag = newEntry ;\n }\n ctx -> chunks [ TagPlugin ] = _cmsSubAllocDup ( ctx -> MemPool , & newHead , sizeof ( _cmsTagPluginChunkType ) ) ;\n }", "idx": 566}
{"hash": 313627013719508831, "project": "debian", "size": 3, "label": 0, "functionSource": "static inline void SetPixelBlackTraits ( Image * image , const PixelTrait traits ) {\n image -> channel_map [ BlackPixelChannel ] . traits = traits ;\n }", "idx": 567}
{"hash": 5611940141018433728, "project": "chrome", "size": 41, "label": 0, "functionSource": "static size_t encode_tiles ( VP9_COMP * cpi , uint8_t * data_ptr ) {\n VP9_COMMON * const cm = & cpi -> common ;\n vp9_writer residual_bc ;\n int tile_row , tile_col ;\n TOKENEXTRA * tok [ 4 ] [ 1 << 6 ] , * tok_end ;\n size_t total_size = 0 ;\n const int tile_cols = 1 << cm -> log2_tile_cols ;\n const int tile_rows = 1 << cm -> log2_tile_rows ;\n vpx_memset ( cm -> above_seg_context , 0 , sizeof ( * cm -> above_seg_context ) * mi_cols_aligned_to_sb ( cm -> mi_cols ) ) ;\n tok [ 0 ] [ 0 ] = cpi -> tok ;\n for ( tile_row = 0 ;\n tile_row < tile_rows ;\n tile_row ++ ) {\n if ( tile_row ) tok [ tile_row ] [ 0 ] = tok [ tile_row - 1 ] [ tile_cols - 1 ] + cpi -> tok_count [ tile_row - 1 ] [ tile_cols - 1 ] ;\n for ( tile_col = 1 ;\n tile_col < tile_cols ;\n tile_col ++ ) tok [ tile_row ] [ tile_col ] = tok [ tile_row ] [ tile_col - 1 ] + cpi -> tok_count [ tile_row ] [ tile_col - 1 ] ;\n }\n for ( tile_row = 0 ;\n tile_row < tile_rows ;\n tile_row ++ ) {\n for ( tile_col = 0 ;\n tile_col < tile_cols ;\n tile_col ++ ) {\n TileInfo tile ;\n vp9_tile_init ( & tile , cm , tile_row , tile_col ) ;\n tok_end = tok [ tile_row ] [ tile_col ] + cpi -> tok_count [ tile_row ] [ tile_col ] ;\n if ( tile_col < tile_cols - 1 || tile_row < tile_rows - 1 ) vp9_start_encode ( & residual_bc , data_ptr + total_size + 4 ) ;\n else vp9_start_encode ( & residual_bc , data_ptr + total_size ) ;\n write_modes ( cpi , & tile , & residual_bc , & tok [ tile_row ] [ tile_col ] , tok_end ) ;\n assert ( tok [ tile_row ] [ tile_col ] == tok_end ) ;\n vp9_stop_encode ( & residual_bc ) ;\n if ( tile_col < tile_cols - 1 || tile_row < tile_rows - 1 ) {\n mem_put_be32 ( data_ptr + total_size , residual_bc . pos ) ;\n total_size += 4 ;\n }\n total_size += residual_bc . pos ;\n }\n }\n return total_size ;\n }", "idx": 568}
{"hash": -7670127399145950875, "project": "debian", "size": 10, "label": 0, "functionSource": "int gs_pop_boolean ( gs_main_instance * minst , bool * result ) {\n i_ctx_t * i_ctx_p = minst -> i_ctx_p ;\n ref vref ;\n int code = pop_value ( i_ctx_p , & vref ) ;\n if ( code < 0 ) return code ;\n check_type_only ( vref , t_boolean ) ;\n * result = vref . value . boolval ;\n ref_stack_pop ( & o_stack , 1 ) ;\n return 0 ;\n }", "idx": 569}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_Re_type ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_Re_type , Re_type_choice , NULL ) ;\n return offset ;\n }", "idx": 570}
{"hash": -3740862514502467070, "project": "debian", "size": 11, "label": 0, "functionSource": "static void dumpblankglyph ( struct glyphinfo * gi , SplineFont * sf , int fixedwidth ) {\n int advance = gi -> next_glyph == 1 ? 0 : fixedwidth <= 0 ? ( sf -> ascent + sf -> descent ) / 3 : fixedwidth ;\n gi -> pointcounts [ gi -> next_glyph ] = 0 ;\n gi -> loca [ gi -> next_glyph ++ ] = ftell ( gi -> glyphs ) ;\n putshort ( gi -> hmtx , advance ) ;\n putshort ( gi -> hmtx , 0 ) ;\n if ( sf -> hasvmetrics ) {\n putshort ( gi -> vmtx , gi -> next_glyph == 2 ? 0 : ( sf -> ascent + sf -> descent ) ) ;\n putshort ( gi -> vmtx , 0 ) ;\n }\n }", "idx": 571}
{"hash": -4078760840682683657, "project": "chrome", "size": 5, "label": 0, "functionSource": "static PREDICTION_MODE read_intra_mode_y ( VP9_COMMON * cm , vp9_reader * r , int size_group ) {\n const PREDICTION_MODE y_mode = read_intra_mode ( r , cm -> fc . y_mode_prob [ size_group ] ) ;\n if ( ! cm -> frame_parallel_decoding_mode ) ++ cm -> counts . y_mode [ size_group ] [ y_mode ] ;\n return y_mode ;\n }", "idx": 572}
{"hash": 1760449185745615462, "project": "debian", "size": 14, "label": 0, "functionSource": "TSReturnCode TSHttpTxnServerRespGet ( TSHttpTxn txnp , TSMBuffer * bufp , TSMLoc * obj ) {\n sdk_assert ( sdk_sanity_check_txn ( txnp ) == TS_SUCCESS ) ;\n sdk_assert ( sdk_sanity_check_null_ptr ( ( void * ) bufp ) == TS_SUCCESS ) ;\n sdk_assert ( sdk_sanity_check_null_ptr ( ( void * ) obj ) == TS_SUCCESS ) ;\n HttpSM * sm = ( HttpSM * ) txnp ;\n HTTPHdr * hptr = & ( sm -> t_state . hdr_info . server_response ) ;\n if ( hptr -> valid ( ) ) {\n * ( reinterpret_cast < HTTPHdr * * > ( bufp ) ) = hptr ;\n * obj = reinterpret_cast < TSMLoc > ( hptr -> m_http ) ;\n sdk_assert ( sdk_sanity_check_mbuffer ( * bufp ) == TS_SUCCESS ) ;\n return TS_SUCCESS ;\n }\n return TS_ERROR ;\n }", "idx": 573}
{"hash": 3309252579593081468, "project": "debian", "size": 14, "label": 0, "functionSource": "static int fetch_children ( char * line , void * data ) {\n struct ChildCtx * cc = data ;\n anum_t anum ;\n if ( ! line || sscanf ( line , ANUM , & anum ) != 1 ) return 0 ;\n for ( unsigned int i = 0 ;\n i < cc -> ctx -> msgcount ;\n i ++ ) if ( NHDR ( cc -> ctx -> hdrs [ i ] ) -> article_num == anum ) return 0 ;\n if ( cc -> num >= cc -> max ) {\n cc -> max *= 2 ;\n mutt_mem_realloc ( & cc -> child , sizeof ( anum_t ) * cc -> max ) ;\n }\n cc -> child [ cc -> num ++ ] = anum ;\n return 0 ;\n }", "idx": 574}
{"hash": 5045872831385413038, "project": "debian", "size": 6, "label": 0, "functionSource": "static int dissect_btgatt_nordic_uart_tx ( tvbuff_t * tvb , packet_info * pinfo _U_ , proto_tree * tree , void * data ) {\n btatt_data_t * att_data = ( btatt_data_t * ) data ;\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) return - 1 ;\n proto_tree_add_item ( tree , hf_gatt_nordic_uart_tx , tvb , 0 , tvb_captured_length ( tvb ) , ENC_ASCII | ENC_NA ) ;\n return tvb_captured_length ( tvb ) ;\n }", "idx": 575}
{"hash": 1286774465219423144, "project": "debian", "size": 9, "label": 0, "functionSource": "static void jbig2_decode_mmr_consume ( Jbig2MmrCtx * mmr , int n_bits ) {\n mmr -> word <<= n_bits ;\n mmr -> bit_index += n_bits ;\n while ( mmr -> bit_index >= 8 ) {\n mmr -> bit_index -= 8 ;\n if ( mmr -> data_index + 4 < mmr -> size ) mmr -> word |= ( mmr -> data [ mmr -> data_index + 4 ] << mmr -> bit_index ) ;\n mmr -> data_index ++ ;\n }\n }", "idx": 576}
{"hash": 1773163316021227217, "project": "debian", "size": 39, "label": 0, "functionSource": "static void cmd_names ( const char * data , SERVER_REC * server , WI_ITEM_REC * item ) {\n CHANNEL_REC * chanrec ;\n GHashTable * optlist ;\n GString * unknowns ;\n char * channel , * * channels , * * tmp ;\n int flags ;\n void * free_arg ;\n g_return_if_fail ( data != NULL ) ;\n if ( ! IS_SERVER ( server ) || ! server -> connected ) cmd_return_error ( CMDERR_NOT_CONNECTED ) ;\n if ( ! cmd_get_params ( data , & free_arg , 1 | PARAM_FLAG_OPTIONS , \"names\" , & optlist , & channel ) ) return ;\n if ( g_strcmp0 ( channel , \"*\" ) == 0 || * channel == '\\0' ) {\n if ( ! IS_CHANNEL ( item ) ) cmd_param_error ( CMDERR_NOT_JOINED ) ;\n channel = CHANNEL ( item ) -> name ;\n }\n flags = 0 ;\n if ( g_hash_table_lookup ( optlist , \"ops\" ) != NULL ) flags |= CHANNEL_NICKLIST_FLAG_OPS ;\n if ( g_hash_table_lookup ( optlist , \"halfops\" ) != NULL ) flags |= CHANNEL_NICKLIST_FLAG_HALFOPS ;\n if ( g_hash_table_lookup ( optlist , \"voices\" ) != NULL ) flags |= CHANNEL_NICKLIST_FLAG_VOICES ;\n if ( g_hash_table_lookup ( optlist , \"normal\" ) != NULL ) flags |= CHANNEL_NICKLIST_FLAG_NORMAL ;\n if ( g_hash_table_lookup ( optlist , \"count\" ) != NULL ) flags |= CHANNEL_NICKLIST_FLAG_COUNT ;\n if ( flags == 0 ) flags = CHANNEL_NICKLIST_FLAG_ALL ;\n unknowns = g_string_new ( NULL ) ;\n channels = g_strsplit ( channel , \",\" , - 1 ) ;\n for ( tmp = channels ;\n * tmp != NULL ;\n tmp ++ ) {\n chanrec = channel_find ( server , * tmp ) ;\n if ( chanrec == NULL ) g_string_append_printf ( unknowns , \"%s,\" , * tmp ) ;\n else {\n fe_channels_nicklist ( chanrec , flags ) ;\n signal_stop ( ) ;\n }\n }\n g_strfreev ( channels ) ;\n if ( unknowns -> len > 1 ) g_string_truncate ( unknowns , unknowns -> len - 1 ) ;\n if ( unknowns -> len > 0 && g_strcmp0 ( channel , unknowns -> str ) != 0 ) signal_emit ( \"command names\" , 3 , unknowns -> str , server , item ) ;\n g_string_free ( unknowns , TRUE ) ;\n cmd_params_free ( free_arg ) ;\n }", "idx": 577}
{"hash": -2607754285145856562, "project": "debian", "size": 40, "label": 0, "functionSource": "static int write_directory_descriptors ( struct archive_write * a , struct vdd * vdd ) {\n struct isoent * np ;\n int depth , r ;\n depth = 0 ;\n np = vdd -> rootent ;\n do {\n struct extr_rec * extr ;\n r = _write_directory_descriptors ( a , vdd , np , depth ) ;\n if ( r < 0 ) return ( r ) ;\n if ( vdd -> vdd_type != VDD_JOLIET ) {\n for ( extr = np -> extr_rec_list . first ;\n extr != NULL ;\n extr = extr -> next ) {\n unsigned char * wb ;\n wb = wb_buffptr ( a ) ;\n memcpy ( wb , extr -> buf , extr -> offset ) ;\n memset ( wb + extr -> offset , 0 , LOGICAL_BLOCK_SIZE - extr -> offset ) ;\n r = wb_consume ( a , LOGICAL_BLOCK_SIZE ) ;\n if ( r < 0 ) return ( r ) ;\n }\n }\n if ( np -> subdirs . first != NULL && depth + 1 < vdd -> max_depth ) {\n np = np -> subdirs . first ;\n depth ++ ;\n continue ;\n }\n while ( np != np -> parent ) {\n if ( np -> drnext == NULL ) {\n np = np -> parent ;\n depth -- ;\n }\n else {\n np = np -> drnext ;\n break ;\n }\n }\n }\n while ( np != np -> parent ) ;\n return ( ARCHIVE_OK ) ;\n }", "idx": 578}
{"hash": -8028756826159773630, "project": "debian", "size": 14, "label": 0, "functionSource": "static void reduce_dependencies ( ArchiveHandle * AH , TocEntry * te , TocEntry * ready_list ) {\n int i ;\n ahlog ( AH , 2 , \"reducing dependencies for %d\\n\" , te -> dumpId ) ;\n for ( i = 0 ;\n i < te -> nRevDeps ;\n i ++ ) {\n TocEntry * otherte = AH -> tocsByDumpId [ te -> revDeps [ i ] ] ;\n otherte -> depCount -- ;\n if ( otherte -> depCount == 0 && otherte -> par_prev != NULL ) {\n par_list_remove ( otherte ) ;\n par_list_append ( ready_list , otherte ) ;\n }\n }\n }", "idx": 579}
{"hash": 6415329349331062723, "project": "chrome", "size": 22, "label": 0, "functionSource": "void http_post_cb ( struct evhttp_request * req , void * arg ) {\n struct evbuffer * evb ;\n event_debug ( ( \"%s: called\\n\" , __func__ ) ) ;\n if ( req -> type != EVHTTP_REQ_POST ) {\n fprintf ( stdout , \"FAILED (post type)\\n\" ) ;\n exit ( 1 ) ;\n }\n if ( EVBUFFER_LENGTH ( req -> input_buffer ) != strlen ( POST_DATA ) ) {\n fprintf ( stdout , \"FAILED (length: %zu vs %zu)\\n\" , EVBUFFER_LENGTH ( req -> input_buffer ) , strlen ( POST_DATA ) ) ;\n exit ( 1 ) ;\n }\n if ( memcmp ( EVBUFFER_DATA ( req -> input_buffer ) , POST_DATA , strlen ( POST_DATA ) ) ) {\n fprintf ( stdout , \"FAILED (data)\\n\" ) ;\n fprintf ( stdout , \"Got :%s\\n\" , EVBUFFER_DATA ( req -> input_buffer ) ) ;\n fprintf ( stdout , \"Want:%s\\n\" , POST_DATA ) ;\n exit ( 1 ) ;\n }\n evb = evbuffer_new ( ) ;\n evbuffer_add_printf ( evb , \"This is funny\" ) ;\n evhttp_send_reply ( req , HTTP_OK , \"Everything is fine\" , evb ) ;\n evbuffer_free ( evb ) ;\n }", "idx": 580}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_MIPAddress ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_MIPAddress , MIPAddress_sequence ) ;\n return offset ;\n }", "idx": 581}
{"hash": -2504372172279754762, "project": "debian", "size": 10, "label": 1, "functionSource": "static int mimic_decode_update_thread_context ( AVCodecContext * avctx , const AVCodecContext * avctx_from ) {\n MimicContext * dst = avctx -> priv_data , * src = avctx_from -> priv_data ;\n if ( avctx == avctx_from ) return 0 ;\n dst -> cur_index = src -> next_cur_index ;\n dst -> prev_index = src -> next_prev_index ;\n memcpy ( dst -> buf_ptrs , src -> buf_ptrs , sizeof ( src -> buf_ptrs ) ) ;\n memcpy ( dst -> flipped_ptrs , src -> flipped_ptrs , sizeof ( src -> flipped_ptrs ) ) ;\n memset ( & dst -> buf_ptrs [ dst -> cur_index ] , 0 , sizeof ( AVFrame ) ) ;\n return 0 ;\n }", "idx": 582}
{"hash": 468458465404335175, "project": "debian", "size": 9, "label": 0, "functionSource": "static void init_slot ( ParallelSlot * slot , PGconn * conn , const char * progname ) {\n slot -> connection = conn ;\n slot -> isFree = true ;\n slot -> sock = PQsocket ( conn ) ;\n if ( slot -> sock < 0 ) {\n fprintf ( stderr , _ ( \"%s: invalid socket: %s\" ) , progname , PQerrorMessage ( conn ) ) ;\n exit ( 1 ) ;\n }\n }", "idx": 583}
{"hash": -6856626433814917486, "project": "debian", "size": 564, "label": 0, "functionSource": "void proto_register_btavdtp ( void ) {\n module_t * module ;\n static hf_register_info hf [ ] = {\n {\n & hf_btavdtp_signal , {\n \"Signal\" , \"btavdtp.signal\" , FT_NONE , BASE_NONE , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_message_type , {\n \"Message Type\" , \"btavdtp.message_type\" , FT_UINT8 , BASE_HEX , VALS ( message_type_vals ) , AVDTP_MESSAGE_TYPE_MASK , NULL , HFILL }\n }\n , {\n & hf_btavdtp_packet_type , {\n \"Packet Type\" , \"btavdtp.packet_type\" , FT_UINT8 , BASE_HEX , VALS ( packet_type_vals ) , AVDTP_PACKET_TYPE_MASK , NULL , HFILL }\n }\n , {\n & hf_btavdtp_transaction , {\n \"Transaction\" , \"btavdtp.transaction\" , FT_UINT8 , BASE_HEX , NULL , AVDTP_TRANSACTION_MASK , NULL , HFILL }\n }\n , {\n & hf_btavdtp_signal_id , {\n \"Signal\" , \"btavdtp.signal_id\" , FT_UINT8 , BASE_HEX , VALS ( signal_id_vals ) , AVDTP_SIGNAL_ID_MASK , NULL , HFILL }\n }\n , {\n & hf_btavdtp_rfa0 , {\n \"RFA\" , \"btavdtp.rfa0\" , FT_UINT8 , BASE_HEX , NULL , AVDTP_RFA0_MASK , NULL , HFILL }\n }\n , {\n & hf_btavdtp_number_of_signal_packets , {\n \"Number of signal packets\" , \"btavdtp.num_signal_packets\" , FT_UINT8 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_error_code , {\n \"Error Code\" , \"btavdtp.error_code\" , FT_UINT8 , BASE_HEX , VALS ( error_code_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_sep_seid , {\n \"SEID\" , \"btavdtp.sep_seid\" , FT_UINT8 , BASE_DEC , NULL , 0xFC , NULL , HFILL }\n }\n , {\n & hf_btavdtp_sep_inuse , {\n \"In Use\" , \"btavdtp.sep_inuse\" , FT_UINT8 , BASE_HEX , VALS ( true_false ) , 0x02 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_sep_rfa0 , {\n \"RFA0\" , \"btavdtp.sep_rfa0\" , FT_UINT8 , BASE_HEX , NULL , 0x01 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_sep_media_type , {\n \"Media Type\" , \"btavdtp.sep_media_type\" , FT_UINT8 , BASE_HEX , VALS ( media_type_vals ) , 0xF0 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_sep_type , {\n \"Type\" , \"btavdtp.sep_type\" , FT_UINT8 , BASE_HEX , VALS ( sep_type_vals ) , 0x08 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_sep_rfa1 , {\n \"RFA1\" , \"btavdtp.sep_rfa1\" , FT_UINT8 , BASE_HEX , NULL , 0x07 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_acp_sep , {\n \"ACP SEP\" , \"btavdtp.acp_sep\" , FT_NONE , BASE_NONE , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_acp_seid_item , {\n \"ACP SEID\" , \"btavdtp.acp_seid_item\" , FT_NONE , BASE_NONE , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_int_seid_item , {\n \"INT SEID\" , \"btavdtp.int_seid_item\" , FT_NONE , BASE_NONE , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_acp_seid , {\n \"ACP SEID\" , \"btavdtp.acp_seid\" , FT_UINT8 , BASE_DEC , NULL , 0xFC , NULL , HFILL }\n }\n , {\n & hf_btavdtp_int_seid , {\n \"INT SEID\" , \"btavdtp.int_seid\" , FT_UINT8 , BASE_DEC , NULL , 0xFC , NULL , HFILL }\n }\n , {\n & hf_btavdtp_rfa_seid , {\n \"RFA\" , \"btavdtp.rfa_seid\" , FT_UINT8 , BASE_HEX , NULL , 0x03 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_service_category , {\n \"Service Category\" , \"btavdtp.service_category\" , FT_UINT8 , BASE_HEX , VALS ( service_category_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_length_of_service_category , {\n \"Length of Service Category\" , \"btavdtp.length_of_service_category\" , FT_UINT8 , BASE_HEX , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_delay , {\n \"Delay\" , \"btavdtp.delay\" , FT_UINT16 , BASE_DEC , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_recovery_type , {\n \"Service Category\" , \"btavdtp.recovery_type\" , FT_UINT8 , BASE_HEX , VALS ( recovery_type_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_maximum_recovery_window_size , {\n \"Service Category\" , \"btavdtp.maximum_recovery_window_size\" , FT_UINT8 , BASE_HEX , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_maximum_number_of_media_packet_in_parity_code , {\n \"Service Category\" , \"btavdtp.maximum_number_of_media_packet_in_parity_code\" , FT_UINT8 , BASE_HEX , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_multiplexing_fragmentation , {\n \"Fragmentation\" , \"btavdtp.multiplexing_fragmentation\" , FT_UINT8 , BASE_HEX , VALS ( true_false ) , 0x80 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_multiplexing_rfa , {\n \"RFA\" , \"btavdtp.multiplexing_rfa\" , FT_UINT8 , BASE_HEX , NULL , 0x7F , NULL , HFILL }\n }\n , {\n & hf_btavdtp_multiplexing_tsid , {\n \"TSID\" , \"btavdtp.multiplexing_tsid\" , FT_UINT8 , BASE_HEX , VALS ( multiplexing_tsid_vals ) , 0xF8 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_multiplexing_tcid , {\n \"TCID\" , \"btavdtp.multiplexing_tcid\" , FT_UINT8 , BASE_HEX , VALS ( multiplexing_tcid_vals ) , 0xF8 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_multiplexing_entry_rfa , {\n \"RFA\" , \"btavdtp.multiplexing_entry_rfa\" , FT_UINT8 , BASE_HEX , NULL , 0x07 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_header_compression_backch , {\n \"BackCh\" , \"btavdtp.header_compression_backch\" , FT_UINT8 , BASE_HEX , VALS ( true_false ) , 0x80 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_header_compression_media , {\n \"Media\" , \"btavdtp.header_compression_media\" , FT_UINT8 , BASE_HEX , VALS ( true_false ) , 0x40 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_header_compression_recovery , {\n \"Recovery\" , \"btavdtp.header_compression_recovery\" , FT_UINT8 , BASE_HEX , VALS ( true_false ) , 0x20 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_header_compression_rfa , {\n \"RFA\" , \"btavdtp.header_compression_rfa\" , FT_UINT8 , BASE_HEX , NULL , 0x1f , NULL , HFILL }\n }\n , {\n & hf_btavdtp_content_protection_type , {\n \"Type\" , \"btavdtp.content_protection_type\" , FT_UINT16 , BASE_HEX , VALS ( content_protection_type_vals ) , 0x0000 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_media_codec_media_type , {\n \"Media Type\" , \"btavdtp.media_codec_media_type\" , FT_UINT8 , BASE_HEX , VALS ( media_type_vals ) , 0xF0 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_media_codec_rfa , {\n \"RFA\" , \"btavdtp.media_codec_rfa\" , FT_UINT8 , BASE_HEX , NULL , 0x0F , NULL , HFILL }\n }\n , {\n & hf_btavdtp_media_codec_audio_type , {\n \"Media Codec Audio Type\" , \"btavdtp.media_codec_audio_type\" , FT_UINT8 , BASE_HEX , VALS ( media_codec_audio_type_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_media_codec_video_type , {\n \"Media Codec Video Type\" , \"btavdtp.media_codec_video_type\" , FT_UINT8 , BASE_HEX , VALS ( media_codec_video_type_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_media_codec_unknown_type , {\n \"Media Codec Unknown Type\" , \"btavdtp.media_codec_unknown_type\" , FT_UINT8 , BASE_HEX , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_sbc_sampling_frequency_16000 , {\n \"Sampling Frequency 16000 Hz\" , \"btavdtp.codec.sbc.sampling_frequency.16000\" , FT_BOOLEAN , 8 , NULL , 0x80 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_sbc_sampling_frequency_32000 , {\n \"Sampling Frequency 32000 Hz\" , \"btavdtp.codec.sbc.sampling_frequency.32000\" , FT_BOOLEAN , 8 , NULL , 0x40 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_sbc_sampling_frequency_44100 , {\n \"Sampling Frequency 44100 Hz\" , \"btavdtp.codec.sbc.sampling_frequency.44100\" , FT_BOOLEAN , 8 , NULL , 0x20 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_sbc_sampling_frequency_48000 , {\n \"Sampling Frequency 48000 Hz\" , \"btavdtp.codec.sbc.sampling_frequency.48000\" , FT_BOOLEAN , 8 , NULL , 0x10 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_sbc_channel_mode_mono , {\n \"Channel Mode Mono\" , \"btavdtp.codec.sbc.channel_mode.mono\" , FT_BOOLEAN , 8 , NULL , 0x08 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_sbc_channel_mode_dual_channel , {\n \"Channel Mode Dual Channel\" , \"btavdtp.codec.sbc.channel_mode.dual_channel\" , FT_BOOLEAN , 8 , NULL , 0x04 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_sbc_channel_mode_stereo , {\n \"Channel Mode Stereo\" , \"btavdtp.codec.sbc.channel_mode.stereo\" , FT_BOOLEAN , 8 , NULL , 0x02 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_sbc_channel_mode_joint_stereo , {\n \"Channel Mode Joint Stereo\" , \"btavdtp.codec.sbc.channel_mode.joint_stereo\" , FT_BOOLEAN , 8 , NULL , 0x01 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_sbc_block_4 , {\n \"Block Length 4\" , \"btavdtp.codec.sbc.block.4\" , FT_BOOLEAN , 8 , NULL , 0x80 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_sbc_block_8 , {\n \"Block Length 8\" , \"btavdtp.codec.sbc.block.8\" , FT_BOOLEAN , 8 , NULL , 0x40 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_sbc_block_12 , {\n \"Block Length 12\" , \"btavdtp.codec.sbc.block.12\" , FT_BOOLEAN , 8 , NULL , 0x20 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_sbc_block_16 , {\n \"Block Length 16\" , \"btavdtp.codec.sbc.block.16\" , FT_BOOLEAN , 8 , NULL , 0x10 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_sbc_subbands_4 , {\n \"Subbands 4\" , \"btavdtp.codec.sbc.subbands.4\" , FT_BOOLEAN , 8 , NULL , 0x08 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_sbc_subbands_8 , {\n \"Subbands 8\" , \"btavdtp.codec.sbc.subbands.8\" , FT_BOOLEAN , 8 , NULL , 0x04 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_sbc_allocation_method_snr , {\n \"Allocation Method SNR\" , \"btavdtp.codec.sbc.allocation_method.snr\" , FT_BOOLEAN , 8 , NULL , 0x02 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_sbc_allocation_method_loudness , {\n \"Allocation Method Loudness\" , \"btavdtp.codec.sbc.allocation_method.loudness\" , FT_BOOLEAN , 8 , NULL , 0x01 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_sbc_min_bitpool , {\n \"Minimum Bitpool\" , \"btavdtp.codec.sbc.minimum_bitpool\" , FT_UINT8 , BASE_DEC , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_sbc_max_bitpool , {\n \"Maximum Bitpool\" , \"btavdtp.codec.sbc.maximum_bitpool\" , FT_UINT8 , BASE_DEC , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_mpeg12_layer_1 , {\n \"MP1\" , \"btavdtp.codec.mpeg12.layer_1\" , FT_BOOLEAN , 8 , NULL , 0x80 , \"MPEG Layer 1\" , HFILL }\n }\n , {\n & hf_btavdtp_mpeg12_layer_2 , {\n \"MP2\" , \"btavdtp.codec.mpeg12.layer_2\" , FT_BOOLEAN , 8 , NULL , 0x40 , \"MPEG Layer 2\" , HFILL }\n }\n , {\n & hf_btavdtp_mpeg12_layer_3 , {\n \"MP3\" , \"btavdtp.codec.mpeg12.layer_3\" , FT_BOOLEAN , 8 , NULL , 0x20 , \"MPEG Layer 3\" , HFILL }\n }\n , {\n & hf_btavdtp_mpeg12_crc_protection , {\n \"CRC Protection\" , \"btavdtp.codec.mpeg12.crc_protection\" , FT_BOOLEAN , 8 , NULL , 0x10 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_mpeg12_channel_mode_mono , {\n \"Channel Mode Mono\" , \"btavdtp.codec.mpeg12.channel_mode.mono\" , FT_BOOLEAN , 8 , NULL , 0x08 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_mpeg12_channel_mode_dual_channel , {\n \"Channel Mode Dual Channel\" , \"btavdtp.codec.mpeg12.channel_mode.dual_channel\" , FT_BOOLEAN , 8 , NULL , 0x04 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_mpeg12_channel_mode_stereo , {\n \"Channel Mode Stereo\" , \"btavdtp.codec.mpeg12.channel_mode.stereo\" , FT_BOOLEAN , 8 , NULL , 0x02 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_mpeg12_channel_mode_joint_stereo , {\n \"Channel Mode Joint Stereo\" , \"btavdtp.codec.mpeg12.channel_mode.joint_stereo\" , FT_BOOLEAN , 8 , NULL , 0x01 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_mpeg12_rfa , {\n \"RFA\" , \"btavdtp.codec.mpeg12.rfa\" , FT_BOOLEAN , 8 , NULL , 0x80 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_mpeg12_mpf_2 , {\n \"Media Payload Format 2\" , \"btavdtp.codec.mpeg12.mpf_2\" , FT_BOOLEAN , 8 , NULL , 0x40 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_mpeg12_sampling_frequency_16000 , {\n \"Sampling Frequency 16000 Hz\" , \"btavdtp.codec.sbc.sampling_frequency.16000\" , FT_BOOLEAN , 8 , NULL , 0x20 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_mpeg12_sampling_frequency_22050 , {\n \"Sampling Frequency 22050 Hz\" , \"btavdtp.codec.sbc.sampling_frequency.22050\" , FT_BOOLEAN , 8 , NULL , 0x10 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_mpeg12_sampling_frequency_24000 , {\n \"Sampling Frequency 24000 Hz\" , \"btavdtp.codec.sbc.sampling_frequency.24000\" , FT_BOOLEAN , 8 , NULL , 0x08 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_mpeg12_sampling_frequency_32000 , {\n \"Sampling Frequency 32000 Hz\" , \"btavdtp.codec.sbc.sampling_frequency.32000\" , FT_BOOLEAN , 8 , NULL , 0x04 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_mpeg12_sampling_frequency_44100 , {\n \"Sampling Frequency 44100 Hz\" , \"btavdtp.codec.sbc.sampling_frequency.44100\" , FT_BOOLEAN , 8 , NULL , 0x02 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_mpeg12_sampling_frequency_48000 , {\n \"Sampling Frequency 48000 Hz\" , \"btavdtp.codec.sbc.sampling_frequency.48000\" , FT_BOOLEAN , 8 , NULL , 0x01 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_mpeg12_vbr_supported , {\n \"VBR Supported\" , \"btavdtp.codec.mpeg12.vbr\" , FT_BOOLEAN , 16 , NULL , 0x8000 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_mpeg12_bit_rate , {\n \"Bit Rate\" , \"btavdtp.codec.mpeg12.bit_rate\" , FT_UINT16 , BASE_HEX , NULL , 0x7FFF , NULL , HFILL }\n }\n , {\n & hf_btavdtp_mpeg24_object_type_mpeg2_aac_lc , {\n \"MPEG2 AAC LC\" , \"btavdtp.codec.mpeg24.object_type.mpeg2_aac_lc\" , FT_BOOLEAN , 8 , NULL , 0x80 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_mpeg24_object_type_mpeg4_aac_lc , {\n \"MPEG4 AAC LC\" , \"btavdtp.codec.mpeg24.object_type.mpeg4_aac_lc\" , FT_BOOLEAN , 8 , NULL , 0x40 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_mpeg24_object_type_mpeg4_aac_ltp , {\n \"MPEG4 AAC LTP\" , \"btavdtp.codec.mpeg24.object_type.mpeg4_aac_ltp\" , FT_BOOLEAN , 8 , NULL , 0x20 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_mpeg24_object_type_mpeg4_aac_scalable , {\n \"MPEG4 AAC Scalable\" , \"btavdtp.codec.mpeg24.object_type.mpeg4_aac_scalable\" , FT_BOOLEAN , 8 , NULL , 0x10 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_mpeg24_object_type_rfa , {\n \"RFA\" , \"btavdtp.codec.mpeg24.object_type.rfa\" , FT_UINT8 , BASE_HEX , NULL , 0x0F , NULL , HFILL }\n }\n , {\n & hf_btavdtp_mpeg24_sampling_frequency_8000 , {\n \"Sampling Frequency 8000 Hz\" , \"btavdtp.codec.mpeg24.sampling_frequency.8000\" , FT_BOOLEAN , 8 , NULL , 0x80 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_mpeg24_sampling_frequency_11025 , {\n \"Sampling Frequency 11025 Hz\" , \"btavdtp.codec.mpeg24.sampling_frequency.11025\" , FT_BOOLEAN , 8 , NULL , 0x40 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_mpeg24_sampling_frequency_12000 , {\n \"Sampling Frequency 12000 Hz\" , \"btavdtp.codec.mpeg24.sampling_frequency.12000\" , FT_BOOLEAN , 8 , NULL , 0x20 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_mpeg24_sampling_frequency_16000 , {\n \"Sampling Frequency 16000 Hz\" , \"btavdtp.codec.mpeg24.sampling_frequency.16000\" , FT_BOOLEAN , 8 , NULL , 0x10 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_mpeg24_sampling_frequency_22050 , {\n \"Sampling Frequency 22050 Hz\" , \"btavdtp.codec.mpeg24.sampling_frequency.22050\" , FT_BOOLEAN , 8 , NULL , 0x08 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_mpeg24_sampling_frequency_24000 , {\n \"Sampling Frequency 24000 Hz\" , \"btavdtp.codec.mpeg24.sampling_frequency.24000\" , FT_BOOLEAN , 8 , NULL , 0x04 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_mpeg24_sampling_frequency_32000 , {\n \"Sampling Frequency 32000 Hz\" , \"btavdtp.codec.mpeg24.sampling_frequency.32000\" , FT_BOOLEAN , 8 , NULL , 0x02 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_mpeg24_sampling_frequency_44100 , {\n \"Sampling Frequency 44100 Hz\" , \"btavdtp.codec.mpeg24.sampling_frequency.44100\" , FT_BOOLEAN , 8 , NULL , 0x01 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_mpeg24_sampling_frequency_48000 , {\n \"Sampling Frequency 48000 Hz\" , \"btavdtp.codec.mpeg24.sampling_frequency.48000\" , FT_BOOLEAN , 8 , NULL , 0x80 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_mpeg24_sampling_frequency_64000 , {\n \"Sampling Frequency 64000 Hz\" , \"btavdtp.codec.mpeg24.sampling_frequency.64000\" , FT_BOOLEAN , 8 , NULL , 0x40 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_mpeg24_sampling_frequency_88200 , {\n \"Sampling Frequency 88200 Hz\" , \"btavdtp.codec.mpeg24.sampling_frequency.88200\" , FT_BOOLEAN , 8 , NULL , 0x20 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_mpeg24_sampling_frequency_96000 , {\n \"Sampling Frequency 96000 Hz\" , \"btavdtp.codec.mpeg24.sampling_frequency.96000\" , FT_BOOLEAN , 8 , NULL , 0x10 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_mpeg24_channels_1 , {\n \"Channels 1\" , \"btavdtp.codec.mpeg24.channels.1\" , FT_BOOLEAN , 8 , NULL , 0x08 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_mpeg24_channels_2 , {\n \"Channels 2\" , \"btavdtp.codec.mpeg24.channels.2\" , FT_BOOLEAN , 8 , NULL , 0x04 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_mpeg24_rfa , {\n \"RFA\" , \"btavdtp.codec.mpeg24.rfa\" , FT_UINT8 , BASE_HEX , NULL , 0x03 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_mpeg24_vbr_supported , {\n \"VBR Supported\" , \"btavdtp.codec.mpeg24.vbr\" , FT_BOOLEAN , 24 , NULL , 0x800000 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_mpeg24_bit_rate , {\n \"Bit Rate\" , \"btavdtp.codec.mpeg24.bit_rate\" , FT_UINT24 , BASE_HEX , NULL , 0x7FFFFF , NULL , HFILL }\n }\n , {\n & hf_btavdtp_atrac_version , {\n \"Version\" , \"btavdtp.codec.atrac.version\" , FT_UINT8 , BASE_DEC , NULL , 0xE0 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_atrac_channel_mode_single_channel , {\n \"Channel Mode Single Channel\" , \"btavdtp.codec.atrac.channel_mode.single_channel\" , FT_BOOLEAN , 8 , NULL , 0x10 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_atrac_channel_mode_dual_channel , {\n \"Channel Mode Dual Channel\" , \"btavdtp.codec.atrac.channel_mode.dual_channel\" , FT_BOOLEAN , 8 , NULL , 0x08 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_atrac_channel_mode_joint_stereo , {\n \"Channel Mode Joint Stereo\" , \"btavdtp.codec.atrac.channel_mode.joint_stereo\" , FT_BOOLEAN , 8 , NULL , 0x04 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_atrac_rfa1 , {\n \"RFA\" , \"btavdtp.codec.atrac.rfa1\" , FT_UINT8 , BASE_HEX , NULL , 0x03 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_atrac_rfa2 , {\n \"RFA\" , \"btavdtp.codec.atrac.rfa2\" , FT_UINT24 , BASE_HEX , NULL , 0xC00000 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_atrac_sampling_frequency_44100 , {\n \"Sampling Frequency 44100 Hz\" , \"btavdtp.codec.sbc.sampling_frequency.44100\" , FT_BOOLEAN , 24 , NULL , 0x200000 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_atrac_sampling_frequency_48000 , {\n \"Sampling Frequency 48000 Hz\" , \"btavdtp.codec.sbc.sampling_frequency.48000\" , FT_BOOLEAN , 24 , NULL , 0x100000 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_atrac_vbr_supported , {\n \"VBR Supported\" , \"btavdtp.codec.atrac.vbr\" , FT_BOOLEAN , 24 , NULL , 0x080000 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_atrac_bit_rate , {\n \"Bit Rate\" , \"btavdtp.codec.atrac.bit_rate\" , FT_UINT24 , BASE_HEX , NULL , 0x07FFFF , NULL , HFILL }\n }\n , {\n & hf_btavdtp_atrac_maximum_sul , {\n \"Maximum SUL\" , \"btavdtp.codec.atrac.maximum_sul\" , FT_UINT8 , BASE_DEC , NULL , 0x00 , \"Sound Unit Length (SUL) is one of the parameters that determine bit rate of the audio stream.\" , HFILL }\n }\n , {\n & hf_btavdtp_atrac_rfa3 , {\n \"RFA\" , \"btavdtp.codec.atrac.rfa3\" , FT_UINT8 , BASE_HEX , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_h263_level_10 , {\n \"H264 Level 10\" , \"btavdtp.codec.h264.level.10\" , FT_BOOLEAN , 8 , NULL , 0x80 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_h263_level_20 , {\n \"H264 Level 20\" , \"btavdtp.codec.h264.level.20\" , FT_BOOLEAN , 8 , NULL , 0x40 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_h263_level_30 , {\n \"H264 Level 30\" , \"btavdtp.codec.h264.level.30\" , FT_BOOLEAN , 8 , NULL , 0x20 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_h263_level_rfa , {\n \"H264 Level RFA\" , \"btavdtp.codec.h264.level.rfa\" , FT_UINT8 , BASE_HEX , NULL , 0x1F , NULL , HFILL }\n }\n , {\n & hf_btavdtp_mpeg4_level_0 , {\n \"MPEG Level 0\" , \"btavdtp.codec.mpeg4.level.0\" , FT_BOOLEAN , 8 , NULL , 0x80 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_mpeg4_level_1 , {\n \"MPEG Level 1\" , \"btavdtp.codec.mpeg4.level.1\" , FT_BOOLEAN , 8 , NULL , 0x40 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_mpeg4_level_2 , {\n \"MPEG Level 2\" , \"btavdtp.codec.mpeg4.level.2\" , FT_BOOLEAN , 8 , NULL , 0x20 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_mpeg4_level_3 , {\n \"MPEG4 Level 3\" , \"btavdtp.codec.mpeg4.level.3\" , FT_BOOLEAN , 8 , NULL , 0x10 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_mpeg4_level_rfa , {\n \"MPEG4 Level RFA\" , \"btavdtp.codec.mpeg4.level.rfa\" , FT_UINT8 , BASE_HEX , NULL , 0x0F , NULL , HFILL }\n }\n , {\n & hf_btavdtp_vendor_id , {\n \"Vendor ID\" , \"btavdtp.codec.vendor.vendor_id\" , FT_UINT32 , BASE_HEX | BASE_EXT_STRING , & bluetooth_company_id_vals_ext , 0x00 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_vendor_specific_codec_id , {\n \"Codec\" , \"btavdtp.codec.vendor.codec_id\" , FT_UINT16 , BASE_HEX , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_vendor_specific_value , {\n \"Value\" , \"btavdtp.codec.vendor.value\" , FT_NONE , BASE_NONE , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_vendor_specific_apt_codec_id , {\n \"Codec\" , \"btavdtp.codec.vendor.codec_id\" , FT_UINT16 , BASE_HEX , VALS ( vendor_apt_codec_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_vendor_specific_aptx_sampling_frequency_16000 , {\n \"Sampling Frequency 16000 Hz\" , \"btavdtp.codec.aptx.sampling_frequency.16000\" , FT_BOOLEAN , 8 , NULL , 0x80 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_vendor_specific_aptx_sampling_frequency_32000 , {\n \"Sampling Frequency 32000 Hz\" , \"btavdtp.codec.aptx.sampling_frequency.32000\" , FT_BOOLEAN , 8 , NULL , 0x40 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_vendor_specific_aptx_sampling_frequency_44100 , {\n \"Sampling Frequency 44100 Hz\" , \"btavdtp.codec.aptx.sampling_frequency.44100\" , FT_BOOLEAN , 8 , NULL , 0x20 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_vendor_specific_aptx_sampling_frequency_48000 , {\n \"Sampling Frequency 48000 Hz\" , \"btavdtp.codec.aptx.sampling_frequency.48000\" , FT_BOOLEAN , 8 , NULL , 0x10 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_vendor_specific_aptx_channel_mode_mono , {\n \"Channel Mode Mono\" , \"btavdtp.codec.aptx.channel_mode.mono\" , FT_BOOLEAN , 8 , NULL , 0x08 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_vendor_specific_aptx_channel_mode_dual_channel , {\n \"Channel Mode Dual Channel\" , \"btavdtp.codec.aptx.channel_mode.dual_channel\" , FT_BOOLEAN , 8 , NULL , 0x04 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_vendor_specific_aptx_channel_mode_stereo , {\n \"Channel Mode Stereo\" , \"btavdtp.codec.aptx.channel_mode.stereo\" , FT_BOOLEAN , 8 , NULL , 0x02 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_vendor_specific_aptx_channel_mode_joint_stereo , {\n \"Channel Mode Joint Stereo\" , \"btavdtp.codec.aptx.channel_mode.joint_stereo\" , FT_BOOLEAN , 8 , NULL , 0x01 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_capabilities , {\n \"Capabilities\" , \"btavdtp.capabilities\" , FT_NONE , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_service , {\n \"Service\" , \"btavdtp.service\" , FT_NONE , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_service_multiplexing_entry , {\n \"Entry\" , \"btavdtp.service_multiplexing_entry\" , FT_NONE , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_btavdtp_data , {\n \"Data\" , \"btavdtp.data\" , FT_NONE , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n }\n ;\n static gint * ett [ ] = {\n & ett_btavdtp , & ett_btavdtp_sep , & ett_btavdtp_capabilities , & ett_btavdtp_service , }\n ;\n proto_btavdtp = proto_register_protocol ( \"Bluetooth AVDTP Protocol\" , \"BT AVDTP\" , \"btavdtp\" ) ;\n btavdtp_handle = register_dissector ( \"btavdtp\" , dissect_btavdtp , proto_btavdtp ) ;\n proto_register_field_array ( proto_btavdtp , hf , array_length ( hf ) ) ;\n proto_register_subtree_array ( ett , array_length ( ett ) ) ;\n module = prefs_register_protocol_subtree ( \"Bluetooth\" , proto_btavdtp , NULL ) ;\n prefs_register_static_text_preference ( module , \"avdtp.version\" , \"Bluetooth Protocol AVDTP version: 1.3\" , \"Version of protocol supported by this dissector.\" ) ;\n channels = wmem_tree_new_autoreset ( wmem_epan_scope ( ) , wmem_file_scope ( ) ) ;\n sep_list = wmem_tree_new_autoreset ( wmem_epan_scope ( ) , wmem_file_scope ( ) ) ;\n sep_open = wmem_tree_new_autoreset ( wmem_epan_scope ( ) , wmem_file_scope ( ) ) ;\n media_packet_times = wmem_tree_new_autoreset ( wmem_epan_scope ( ) , wmem_file_scope ( ) ) ;\n # if RTP_PLAYER_WORKAROUND == TRUE file_scope_stream_number = wmem_tree_new_autoreset ( wmem_epan_scope ( ) , wmem_file_scope ( ) ) ;\n # endif }", "idx": 584}
{"hash": 1182028467273264883, "project": "debian", "size": 21, "label": 0, "functionSource": "int do_done ( struct st_command * command ) {\n if ( cur_block == block_stack ) {\n if ( * command -> query != '}\n' ) die ( \"Stray 'end' command - end of block before beginning\" ) ;\n die ( \"Stray '}\n' - end of block before beginning\" ) ;\n }\n if ( cur_block -> ok && cur_block -> cmd == cmd_while ) {\n cur_block -- ;\n parser . current_line = cur_block -> line ;\n }\n else {\n if ( * cur_block -> delim ) {\n strcpy ( delimiter , cur_block -> delim ) ;\n delimiter_length = strlen ( delimiter ) ;\n }\n cur_block -- ;\n parser . current_line ++ ;\n }\n return 0 ;\n }", "idx": 585}
{"hash": -1929262071302712016, "project": "debian", "size": 30, "label": 0, "functionSource": "static cmsBool Type_NamedColor_Write ( struct _cms_typehandler_struct * self , cmsIOHANDLER * io , void * Ptr , cmsUInt32Number nItems ) {\n cmsNAMEDCOLORLIST * NamedColorList = ( cmsNAMEDCOLORLIST * ) Ptr ;\n char prefix [ 33 ] ;\n char suffix [ 33 ] ;\n int i , nColors ;\n nColors = cmsNamedColorCount ( NamedColorList ) ;\n if ( ! _cmsWriteUInt32Number ( io , 0 ) ) return FALSE ;\n if ( ! _cmsWriteUInt32Number ( io , nColors ) ) return FALSE ;\n if ( ! _cmsWriteUInt32Number ( io , NamedColorList -> ColorantCount ) ) return FALSE ;\n strncpy ( prefix , ( const char * ) NamedColorList -> Prefix , 32 ) ;\n strncpy ( suffix , ( const char * ) NamedColorList -> Suffix , 32 ) ;\n suffix [ 32 ] = prefix [ 32 ] = 0 ;\n if ( ! io -> Write ( io , 32 , prefix ) ) return FALSE ;\n if ( ! io -> Write ( io , 32 , suffix ) ) return FALSE ;\n for ( i = 0 ;\n i < nColors ;\n i ++ ) {\n cmsUInt16Number PCS [ 3 ] ;\n cmsUInt16Number Colorant [ cmsMAXCHANNELS ] ;\n char Root [ 33 ] ;\n if ( ! cmsNamedColorInfo ( NamedColorList , i , Root , NULL , NULL , PCS , Colorant ) ) return 0 ;\n Root [ 32 ] = 0 ;\n if ( ! io -> Write ( io , 32 , Root ) ) return FALSE ;\n if ( ! _cmsWriteUInt16Array ( io , 3 , PCS ) ) return FALSE ;\n if ( ! _cmsWriteUInt16Array ( io , NamedColorList -> ColorantCount , Colorant ) ) return FALSE ;\n }\n return TRUE ;\n cmsUNUSED_PARAMETER ( nItems ) ;\n cmsUNUSED_PARAMETER ( self ) ;\n }", "idx": 586}
{"hash": 7493853980473701704, "project": "debian", "size": 24, "label": 0, "functionSource": "static void arm_gic_realize ( DeviceState * dev , Error * * errp ) {\n int i ;\n GICState * s = ARM_GIC ( dev ) ;\n SysBusDevice * sbd = SYS_BUS_DEVICE ( dev ) ;\n ARMGICClass * agc = ARM_GIC_GET_CLASS ( s ) ;\n agc -> parent_realize ( dev , errp ) ;\n if ( error_is_set ( errp ) ) {\n return ;\n }\n gic_init_irqs_and_distributor ( s , s -> num_irq ) ;\n memory_region_init_io ( & s -> cpuiomem [ 0 ] , OBJECT ( s ) , & gic_thiscpu_ops , s , \"gic_cpu\" , 0x100 ) ;\n for ( i = 0 ;\n i < NUM_CPU ( s ) ;\n i ++ ) {\n s -> backref [ i ] = s ;\n memory_region_init_io ( & s -> cpuiomem [ i + 1 ] , OBJECT ( s ) , & gic_cpu_ops , & s -> backref [ i ] , \"gic_cpu\" , 0x100 ) ;\n }\n sysbus_init_mmio ( sbd , & s -> iomem ) ;\n for ( i = 0 ;\n i <= NUM_CPU ( s ) ;\n i ++ ) {\n sysbus_init_mmio ( sbd , & s -> cpuiomem [ i ] ) ;\n }\n }", "idx": 587}
{"hash": 8572106347813672436, "project": "debian", "size": 55, "label": 0, "functionSource": "static struct xfrm_policy * pfkey_compile_policy ( struct sock * sk , int opt , u8 * data , int len , int * dir ) {\n struct net * net = sock_net ( sk ) ;\n struct xfrm_policy * xp ;\n struct sadb_x_policy * pol = ( struct sadb_x_policy * ) data ;\n struct sadb_x_sec_ctx * sec_ctx ;\n switch ( sk -> sk_family ) {\n case AF_INET : if ( opt != IP_IPSEC_POLICY ) {\n * dir = - EOPNOTSUPP ;\n return NULL ;\n }\n break ;\n # if IS_ENABLED ( CONFIG_IPV6 ) case AF_INET6 : if ( opt != IPV6_IPSEC_POLICY ) {\n * dir = - EOPNOTSUPP ;\n return NULL ;\n }\n break ;\n # endif default : * dir = - EINVAL ;\n return NULL ;\n }\n * dir = - EINVAL ;\n if ( len < sizeof ( struct sadb_x_policy ) || pol -> sadb_x_policy_len * 8 > len || pol -> sadb_x_policy_type > IPSEC_POLICY_BYPASS || ( ! pol -> sadb_x_policy_dir || pol -> sadb_x_policy_dir > IPSEC_DIR_OUTBOUND ) ) return NULL ;\n xp = xfrm_policy_alloc ( net , GFP_ATOMIC ) ;\n if ( xp == NULL ) {\n * dir = - ENOBUFS ;\n return NULL ;\n }\n xp -> action = ( pol -> sadb_x_policy_type == IPSEC_POLICY_DISCARD ? XFRM_POLICY_BLOCK : XFRM_POLICY_ALLOW ) ;\n xp -> lft . soft_byte_limit = XFRM_INF ;\n xp -> lft . hard_byte_limit = XFRM_INF ;\n xp -> lft . soft_packet_limit = XFRM_INF ;\n xp -> lft . hard_packet_limit = XFRM_INF ;\n xp -> family = sk -> sk_family ;\n xp -> xfrm_nr = 0 ;\n if ( pol -> sadb_x_policy_type == IPSEC_POLICY_IPSEC && ( * dir = parse_ipsecrequests ( xp , pol ) ) < 0 ) goto out ;\n if ( len >= ( pol -> sadb_x_policy_len * 8 + sizeof ( struct sadb_x_sec_ctx ) ) ) {\n char * p = ( char * ) pol ;\n struct xfrm_user_sec_ctx * uctx ;\n p += pol -> sadb_x_policy_len * 8 ;\n sec_ctx = ( struct sadb_x_sec_ctx * ) p ;\n if ( len < pol -> sadb_x_policy_len * 8 + sec_ctx -> sadb_x_sec_len ) {\n * dir = - EINVAL ;\n goto out ;\n }\n if ( ( * dir = verify_sec_ctx_len ( p ) ) ) goto out ;\n uctx = pfkey_sadb2xfrm_user_sec_ctx ( sec_ctx ) ;\n * dir = security_xfrm_policy_alloc ( & xp -> security , uctx ) ;\n kfree ( uctx ) ;\n if ( * dir ) goto out ;\n }\n * dir = pol -> sadb_x_policy_dir - 1 ;\n return xp ;\n out : xp -> walk . dead = 1 ;\n xfrm_policy_destroy ( xp ) ;\n return NULL ;\n }", "idx": 588}
{"hash": -755883256379441954, "project": "chrome", "size": 178, "label": 1, "functionSource": "void vp9_ ## type ## _predictor_ ## size ## x ## size ## _c ( uint8_t * dst , ptrdiff_t stride , const uint8_t * above , const uint8_t * left ) {\n type ## _predictor ( dst , stride , size , above , left ) ;\n }\n # define intra_pred_allsizes ( type ) intra_pred_sized ( type , 4 ) intra_pred_sized ( type , 8 ) intra_pred_sized ( type , 16 ) intra_pred_sized ( type , 32 ) static INLINE void d207_predictor ( uint8_t * dst , ptrdiff_t stride , int bs , const uint8_t * above , const uint8_t * left ) {\n int r , c ;\n ( void ) above ;\n for ( r = 0 ;\n r < bs - 1 ;\n ++ r ) dst [ r * stride ] = ROUND_POWER_OF_TWO ( left [ r ] + left [ r + 1 ] , 1 ) ;\n dst [ ( bs - 1 ) * stride ] = left [ bs - 1 ] ;\n dst ++ ;\n for ( r = 0 ;\n r < bs - 2 ;\n ++ r ) dst [ r * stride ] = ROUND_POWER_OF_TWO ( left [ r ] + left [ r + 1 ] * 2 + left [ r + 2 ] , 2 ) ;\n dst [ ( bs - 2 ) * stride ] = ROUND_POWER_OF_TWO ( left [ bs - 2 ] + left [ bs - 1 ] * 3 , 2 ) ;\n dst [ ( bs - 1 ) * stride ] = left [ bs - 1 ] ;\n dst ++ ;\n for ( c = 0 ;\n c < bs - 2 ;\n ++ c ) dst [ ( bs - 1 ) * stride + c ] = left [ bs - 1 ] ;\n for ( r = bs - 2 ;\n r >= 0 ;\n -- r ) for ( c = 0 ;\n c < bs - 2 ;\n ++ c ) dst [ r * stride + c ] = dst [ ( r + 1 ) * stride + c - 2 ] ;\n }\n intra_pred_allsizes ( d207 ) static INLINE void d63_predictor ( uint8_t * dst , ptrdiff_t stride , int bs , const uint8_t * above , const uint8_t * left ) {\n int r , c ;\n ( void ) left ;\n for ( r = 0 ;\n r < bs ;\n ++ r ) {\n for ( c = 0 ;\n c < bs ;\n ++ c ) dst [ c ] = r & 1 ? ROUND_POWER_OF_TWO ( above [ r / 2 + c ] + above [ r / 2 + c + 1 ] * 2 + above [ r / 2 + c + 2 ] , 2 ) : ROUND_POWER_OF_TWO ( above [ r / 2 + c ] + above [ r / 2 + c + 1 ] , 1 ) ;\n dst += stride ;\n }\n }\n intra_pred_allsizes ( d63 ) static INLINE void d45_predictor ( uint8_t * dst , ptrdiff_t stride , int bs , const uint8_t * above , const uint8_t * left ) {\n int r , c ;\n ( void ) left ;\n for ( r = 0 ;\n r < bs ;\n ++ r ) {\n for ( c = 0 ;\n c < bs ;\n ++ c ) dst [ c ] = r + c + 2 < bs * 2 ? ROUND_POWER_OF_TWO ( above [ r + c ] + above [ r + c + 1 ] * 2 + above [ r + c + 2 ] , 2 ) : above [ bs * 2 - 1 ] ;\n dst += stride ;\n }\n }\n intra_pred_allsizes ( d45 ) static INLINE void d117_predictor ( uint8_t * dst , ptrdiff_t stride , int bs , const uint8_t * above , const uint8_t * left ) {\n int r , c ;\n for ( c = 0 ;\n c < bs ;\n c ++ ) dst [ c ] = ROUND_POWER_OF_TWO ( above [ c - 1 ] + above [ c ] , 1 ) ;\n dst += stride ;\n dst [ 0 ] = ROUND_POWER_OF_TWO ( left [ 0 ] + above [ - 1 ] * 2 + above [ 0 ] , 2 ) ;\n for ( c = 1 ;\n c < bs ;\n c ++ ) dst [ c ] = ROUND_POWER_OF_TWO ( above [ c - 2 ] + above [ c - 1 ] * 2 + above [ c ] , 2 ) ;\n dst += stride ;\n dst [ 0 ] = ROUND_POWER_OF_TWO ( above [ - 1 ] + left [ 0 ] * 2 + left [ 1 ] , 2 ) ;\n for ( r = 3 ;\n r < bs ;\n ++ r ) dst [ ( r - 2 ) * stride ] = ROUND_POWER_OF_TWO ( left [ r - 3 ] + left [ r - 2 ] * 2 + left [ r - 1 ] , 2 ) ;\n for ( r = 2 ;\n r < bs ;\n ++ r ) {\n for ( c = 1 ;\n c < bs ;\n c ++ ) dst [ c ] = dst [ - 2 * stride + c - 1 ] ;\n dst += stride ;\n }\n }\n intra_pred_allsizes ( d117 ) static INLINE void d135_predictor ( uint8_t * dst , ptrdiff_t stride , int bs , const uint8_t * above , const uint8_t * left ) {\n int r , c ;\n dst [ 0 ] = ROUND_POWER_OF_TWO ( left [ 0 ] + above [ - 1 ] * 2 + above [ 0 ] , 2 ) ;\n for ( c = 1 ;\n c < bs ;\n c ++ ) dst [ c ] = ROUND_POWER_OF_TWO ( above [ c - 2 ] + above [ c - 1 ] * 2 + above [ c ] , 2 ) ;\n dst [ stride ] = ROUND_POWER_OF_TWO ( above [ - 1 ] + left [ 0 ] * 2 + left [ 1 ] , 2 ) ;\n for ( r = 2 ;\n r < bs ;\n ++ r ) dst [ r * stride ] = ROUND_POWER_OF_TWO ( left [ r - 2 ] + left [ r - 1 ] * 2 + left [ r ] , 2 ) ;\n dst += stride ;\n for ( r = 1 ;\n r < bs ;\n ++ r ) {\n for ( c = 1 ;\n c < bs ;\n c ++ ) dst [ c ] = dst [ - stride + c - 1 ] ;\n dst += stride ;\n }\n }\n intra_pred_allsizes ( d135 ) static INLINE void d153_predictor ( uint8_t * dst , ptrdiff_t stride , int bs , const uint8_t * above , const uint8_t * left ) {\n int r , c ;\n dst [ 0 ] = ROUND_POWER_OF_TWO ( above [ - 1 ] + left [ 0 ] , 1 ) ;\n for ( r = 1 ;\n r < bs ;\n r ++ ) dst [ r * stride ] = ROUND_POWER_OF_TWO ( left [ r - 1 ] + left [ r ] , 1 ) ;\n dst ++ ;\n dst [ 0 ] = ROUND_POWER_OF_TWO ( left [ 0 ] + above [ - 1 ] * 2 + above [ 0 ] , 2 ) ;\n dst [ stride ] = ROUND_POWER_OF_TWO ( above [ - 1 ] + left [ 0 ] * 2 + left [ 1 ] , 2 ) ;\n for ( r = 2 ;\n r < bs ;\n r ++ ) dst [ r * stride ] = ROUND_POWER_OF_TWO ( left [ r - 2 ] + left [ r - 1 ] * 2 + left [ r ] , 2 ) ;\n dst ++ ;\n for ( c = 0 ;\n c < bs - 2 ;\n c ++ ) dst [ c ] = ROUND_POWER_OF_TWO ( above [ c - 1 ] + above [ c ] * 2 + above [ c + 1 ] , 2 ) ;\n dst += stride ;\n for ( r = 1 ;\n r < bs ;\n ++ r ) {\n for ( c = 0 ;\n c < bs - 2 ;\n c ++ ) dst [ c ] = dst [ - stride + c - 2 ] ;\n dst += stride ;\n }\n }\n intra_pred_allsizes ( d153 ) static INLINE void v_predictor ( uint8_t * dst , ptrdiff_t stride , int bs , const uint8_t * above , const uint8_t * left ) {\n int r ;\n ( void ) left ;\n for ( r = 0 ;\n r < bs ;\n r ++ ) {\n vpx_memcpy ( dst , above , bs ) ;\n dst += stride ;\n }\n }\n intra_pred_allsizes ( v ) static INLINE void h_predictor ( uint8_t * dst , ptrdiff_t stride , int bs , const uint8_t * above , const uint8_t * left ) {\n int r ;\n ( void ) above ;\n for ( r = 0 ;\n r < bs ;\n r ++ ) {\n vpx_memset ( dst , left [ r ] , bs ) ;\n dst += stride ;\n }\n }\n intra_pred_allsizes ( h ) static INLINE void tm_predictor ( uint8_t * dst , ptrdiff_t stride , int bs , const uint8_t * above , const uint8_t * left ) {\n int r , c ;\n int ytop_left = above [ - 1 ] ;\n for ( r = 0 ;\n r < bs ;\n r ++ ) {\n for ( c = 0 ;\n c < bs ;\n c ++ ) dst [ c ] = clip_pixel ( left [ r ] + above [ c ] - ytop_left ) ;\n dst += stride ;\n }\n }\n intra_pred_allsizes ( tm ) static INLINE void dc_128_predictor ( uint8_t * dst , ptrdiff_t stride , int bs , const uint8_t * above , const uint8_t * left ) {\n int r ;\n ( void ) above ;\n ( void ) left ;\n for ( r = 0 ;\n r < bs ;\n r ++ ) {\n vpx_memset ( dst , 128 , bs ) ;\n dst += stride ;\n }\n }\n intra_pred_allsizes ( dc_128 ) static INLINE void dc_left_predictor ( uint8_t * dst , ptrdiff_t stride , int bs , const uint8_t * above , const uint8_t * left ) {\n int i , r , expected_dc , sum = 0 ;\n ( void ) above ;\n for ( i = 0 ;\n i < bs ;\n i ++ ) sum += left [ i ] ;\n expected_dc = ( sum + ( bs >> 1 ) ) / bs ;\n for ( r = 0 ;\n r < bs ;\n r ++ ) {\n vpx_memset ( dst , expected_dc , bs ) ;\n dst += stride ;\n }\n }\n intra_pred_allsizes ( dc_left )", "idx": 589}
{"hash": -4239386405881995323, "project": "chrome", "size": 17, "label": 1, "functionSource": "xmlHashTablePtr xmlHashCreate ( int size ) {\n xmlHashTablePtr table ;\n if ( size <= 0 ) size = 256 ;\n table = xmlMalloc ( sizeof ( xmlHashTable ) ) ;\n if ( table ) {\n table -> dict = NULL ;\n table -> size = size ;\n table -> nbElems = 0 ;\n table -> table = xmlMalloc ( size * sizeof ( xmlHashEntry ) ) ;\n if ( table -> table ) {\n memset ( table -> table , 0 , size * sizeof ( xmlHashEntry ) ) ;\n return ( table ) ;\n }\n xmlFree ( table ) ;\n }\n return ( NULL ) ;\n }", "idx": 590}
{"hash": 1788300783882316916, "project": "debian", "size": 41, "label": 0, "functionSource": "void ff_fix_long_p_mvs ( MpegEncContext * s ) {\n MotionEstContext * const c = & s -> me ;\n const int f_code = s -> f_code ;\n int y , range ;\n assert ( s -> pict_type == AV_PICTURE_TYPE_P ) ;\n range = ( ( ( s -> out_format == FMT_MPEG1 || s -> msmpeg4_version ) ? 8 : 16 ) << f_code ) ;\n assert ( range <= 16 || ! s -> msmpeg4_version ) ;\n assert ( range <= 256 || ! ( s -> codec_id == AV_CODEC_ID_MPEG2VIDEO && s -> avctx -> strict_std_compliance >= FF_COMPLIANCE_NORMAL ) ) ;\n if ( c -> avctx -> me_range && range > c -> avctx -> me_range ) range = c -> avctx -> me_range ;\n if ( s -> flags & CODEC_FLAG_4MV ) {\n const int wrap = s -> b8_stride ;\n for ( y = 0 ;\n y < s -> mb_height ;\n y ++ ) {\n int xy = y * 2 * wrap ;\n int i = y * s -> mb_stride ;\n int x ;\n for ( x = 0 ;\n x < s -> mb_width ;\n x ++ ) {\n if ( s -> mb_type [ i ] & CANDIDATE_MB_TYPE_INTER4V ) {\n int block ;\n for ( block = 0 ;\n block < 4 ;\n block ++ ) {\n int off = ( block & 1 ) + ( block >> 1 ) * wrap ;\n int mx = s -> current_picture . motion_val [ 0 ] [ xy + off ] [ 0 ] ;\n int my = s -> current_picture . motion_val [ 0 ] [ xy + off ] [ 1 ] ;\n if ( mx >= range || mx < - range || my >= range || my < - range ) {\n s -> mb_type [ i ] &= ~ CANDIDATE_MB_TYPE_INTER4V ;\n s -> mb_type [ i ] |= CANDIDATE_MB_TYPE_INTRA ;\n s -> current_picture . mb_type [ i ] = CANDIDATE_MB_TYPE_INTRA ;\n }\n }\n }\n xy += 2 ;\n i ++ ;\n }\n }\n }\n }", "idx": 591}
{"hash": -8028756826159773630, "project": "debian", "size": 5, "label": 0, "functionSource": "static void _becomeOwner ( ArchiveHandle * AH , TocEntry * te ) {\n RestoreOptions * ropt = AH -> public . ropt ;\n if ( ropt && ( ropt -> noOwner || ! ropt -> use_setsessauth ) ) return ;\n _becomeUser ( AH , te -> owner ) ;\n }", "idx": 592}
{"hash": -8988932206384554896, "project": "debian", "size": 17, "label": 0, "functionSource": "static void chomp6 ( ChannelData * chd , int16_t * output , uint8_t val , int tab_idx ) {\n int16_t current = read_table ( chd , val , tab_idx ) ;\n if ( ( chd -> previous ^ current ) >= 0 ) {\n chd -> factor = FFMIN ( chd -> factor + 506 , 32767 ) ;\n }\n else {\n if ( chd -> factor - 314 < - 32768 ) chd -> factor = - 32767 ;\n else chd -> factor -= 314 ;\n }\n current = mace_broken_clip_int16 ( current + chd -> level ) ;\n chd -> level = ( current * chd -> factor ) >> 15 ;\n current >>= 1 ;\n output [ 0 ] = QT_8S_2_16S ( chd -> previous + chd -> prev2 - ( ( chd -> prev2 - current ) >> 2 ) ) ;\n output [ 1 ] = QT_8S_2_16S ( chd -> previous + current + ( ( chd -> prev2 - current ) >> 2 ) ) ;\n chd -> prev2 = chd -> previous ;\n chd -> previous = current ;\n }", "idx": 593}
{"hash": 7399683071036018868, "project": "debian", "size": 11, "label": 0, "functionSource": "static union _zend_function * row_get_ctor ( zval * object TSRMLS_DC ) {\n static zend_internal_function ctor = {\n 0 }\n ;\n ctor . type = ZEND_INTERNAL_FUNCTION ;\n ctor . function_name = \"__construct\" ;\n ctor . scope = pdo_row_ce ;\n ctor . handler = ZEND_FN ( dbstmt_constructor ) ;\n ctor . fn_flags = ZEND_ACC_PUBLIC ;\n return ( union _zend_function * ) & ctor ;\n }", "idx": 594}
{"hash": 9176142195250515812, "project": "debian", "size": 19, "label": 0, "functionSource": "static void prplcb_roomlist_in_progress ( PurpleRoomlist * list , gboolean in_progress ) {\n struct im_connection * ic ;\n struct purple_data * pd ;\n struct purple_roomlist_data * rld = list -> ui_data ;\n if ( in_progress || ! rld ) {\n return ;\n }\n ic = purple_ic_by_pa ( list -> account ) ;\n imcb_chat_list_free ( ic ) ;\n pd = ic -> proto_data ;\n g_free ( pd -> chat_list_server ) ;\n pd -> chat_list_server = NULL ;\n ic -> chatlist = g_slist_reverse ( rld -> chats ) ;\n rld -> chats = NULL ;\n imcb_chat_list_finish ( ic ) ;\n if ( rld -> initialized ) {\n purple_roomlist_unref ( list ) ;\n }\n }", "idx": 595}
{"hash": -7241004363975794258, "project": "debian", "size": 15, "label": 0, "functionSource": "int jbig2_page_add_result ( Jbig2Ctx * ctx , Jbig2Page * page , Jbig2Image * image , int x , int y , Jbig2ComposeOp op ) {\n if ( page -> image == NULL ) {\n jbig2_error ( ctx , JBIG2_SEVERITY_WARNING , - 1 , \"page info possibly missing, no image defined\" ) ;\n return 0 ;\n }\n if ( page -> striped ) {\n uint32_t new_height = y + image -> height + page -> end_row ;\n if ( page -> image -> height < new_height ) {\n jbig2_error ( ctx , JBIG2_SEVERITY_DEBUG , - 1 , \"growing page buffer to %d rows \" \"to accomodate new stripe\" , new_height ) ;\n jbig2_image_resize ( ctx , page -> image , page -> image -> width , new_height ) ;\n }\n }\n jbig2_image_compose ( ctx , page -> image , image , x , y + page -> end_row , op ) ;\n return 0 ;\n }", "idx": 596}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_H2250Capability ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_H2250Capability , H2250Capability_sequence ) ;\n return offset ;\n }", "idx": 597}
{"hash": -1055531103257174901, "project": "debian", "size": 22, "label": 0, "functionSource": "static void complete_window_nicks ( GList * * list , WINDOW_REC * window , const char * word , const char * nicksuffix ) {\n CHANNEL_REC * channel ;\n GList * tmplist ;\n GSList * tmp ;\n channel = CHANNEL ( window -> active ) ;\n if ( channel != NULL ) {\n tmplist = completion_channel_nicks ( channel , word , nicksuffix ) ;\n * list = completion_joinlist ( * list , tmplist ) ;\n }\n if ( nicksuffix != NULL ) {\n return ;\n }\n for ( tmp = window -> items ;\n tmp != NULL ;\n tmp = tmp -> next ) {\n channel = CHANNEL ( tmp -> data ) ;\n if ( channel != NULL && tmp -> data != window -> active ) {\n tmplist = completion_channel_nicks ( channel , word , nicksuffix ) ;\n * list = completion_joinlist ( * list , tmplist ) ;\n }\n }\n }", "idx": 598}
{"hash": -7019074708255236794, "project": "debian", "size": 11, "label": 0, "functionSource": "static float auto_correlation ( float * diff_isf , float mean , int lag ) {\n int i ;\n float sum = 0.0 ;\n for ( i = 7 ;\n i < LP_ORDER - 2 ;\n i ++ ) {\n float prod = ( diff_isf [ i ] - mean ) * ( diff_isf [ i - lag ] - mean ) ;\n sum += prod * prod ;\n }\n return sum ;\n }", "idx": 599}
{"hash": 4704178797381506498, "project": "debian", "size": 17, "label": 0, "functionSource": "kadm5_ret_t kadm5_get_principal_keys ( void * server_handle , krb5_principal principal , krb5_keyblock * * keyblocks , int * n_keys ) {\n krb5_db_entry * kdb ;\n osa_princ_ent_rec adb ;\n kadm5_ret_t ret ;\n kadm5_server_handle_t handle = server_handle ;\n if ( keyblocks ) * keyblocks = NULL ;\n CHECK_HANDLE ( server_handle ) ;\n if ( principal == NULL ) return EINVAL ;\n if ( ( ret = kdb_get_entry ( handle , principal , & kdb , & adb ) ) ) return ( ret ) ;\n if ( keyblocks ) {\n ret = decrypt_key_data ( handle -> context , kdb -> n_key_data , kdb -> key_data , keyblocks , n_keys ) ;\n if ( ret ) goto done ;\n }\n ret = KADM5_OK ;\n done : kdb_free_entry ( handle , kdb , & adb ) ;\n return ret ;\n }", "idx": 600}
{"hash": -4456702502726364053, "project": "debian", "size": 30, "label": 0, "functionSource": "static int decode_cabac_mb_mvd ( H264Context * h , int ctxbase , int amvd , int * mvda ) {\n int mvd ;\n if ( ! get_cabac ( & h -> cabac , & h -> cabac_state [ ctxbase + ( ( amvd - 3 ) >> ( INT_BIT - 1 ) ) + ( ( amvd - 33 ) >> ( INT_BIT - 1 ) ) + 2 ] ) ) {\n * mvda = 0 ;\n return 0 ;\n }\n mvd = 1 ;\n ctxbase += 3 ;\n while ( mvd < 9 && get_cabac ( & h -> cabac , & h -> cabac_state [ ctxbase ] ) ) {\n if ( mvd < 4 ) ctxbase ++ ;\n mvd ++ ;\n }\n if ( mvd >= 9 ) {\n int k = 3 ;\n while ( get_cabac_bypass ( & h -> cabac ) ) {\n mvd += 1 << k ;\n k ++ ;\n if ( k > 24 ) {\n av_log ( h -> avctx , AV_LOG_ERROR , \"overflow in decode_cabac_mb_mvd\\n\" ) ;\n return INT_MIN ;\n }\n }\n while ( k -- ) {\n mvd += get_cabac_bypass ( & h -> cabac ) << k ;\n }\n * mvda = mvd < 70 ? mvd : 70 ;\n }\n else * mvda = mvd ;\n return get_cabac_bypass_sign ( & h -> cabac , - mvd ) ;\n }", "idx": 601}
{"hash": 7549435794356072684, "project": "debian", "size": 4, "label": 0, "functionSource": "static VALUE ossl_asn1_ ## klass ( int argc , VALUE * argv , VALUE self ) \\ {\n return rb_funcall3 ( cASN1 ## klass , rb_intern ( \"new\" ) , argc , argv ) ;\n }\n OSSL_ASN1_IMPL_FACTORY_METHOD ( Boolean ) OSSL_ASN1_IMPL_FACTORY_METHOD ( Integer ) OSSL_ASN1_IMPL_FACTORY_METHOD ( Enumerated )", "idx": 602}
{"hash": -5082285935423529157, "project": "debian", "size": 18, "label": 0, "functionSource": "static int dissect_rsl_ie_sys_info_type ( tvbuff_t * tvb , packet_info * pinfo _U_ , proto_tree * tree , int offset , gboolean is_mandatory , guint8 * sys_info_type ) {\n proto_tree * ie_tree ;\n guint8 ie_id ;\n if ( is_mandatory == FALSE ) {\n ie_id = tvb_get_guint8 ( tvb , offset ) ;\n if ( ie_id != RSL_IE_SYS_INFO_TYPE ) {\n * sys_info_type = 0xff ;\n return offset ;\n }\n }\n ie_tree = proto_tree_add_subtree ( tree , tvb , offset , 2 , ett_ie_sys_info_type , NULL , \"System Info Type IE\" ) ;\n proto_tree_add_item ( ie_tree , hf_rsl_ie_id , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n offset ++ ;\n * sys_info_type = tvb_get_guint8 ( tvb , offset ) ;\n proto_tree_add_item ( tree , hf_rsl_sys_info_type , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n offset ++ ;\n return offset ;\n }", "idx": 603}
{"hash": -7076754245473579218, "project": "chrome", "size": 26, "label": 1, "functionSource": "static void evhttp_connection_done ( struct evhttp_connection * evcon ) {\n struct evhttp_request * req = TAILQ_FIRST ( & evcon -> requests ) ;\n int con_outgoing = evcon -> flags & EVHTTP_CON_OUTGOING ;\n if ( con_outgoing ) {\n int need_close ;\n TAILQ_REMOVE ( & evcon -> requests , req , next ) ;\n req -> evcon = NULL ;\n evcon -> state = EVCON_IDLE ;\n need_close = evhttp_is_connection_close ( req -> flags , req -> input_headers ) || evhttp_is_connection_close ( req -> flags , req -> output_headers ) ;\n if ( need_close ) evhttp_connection_reset ( evcon ) ;\n if ( TAILQ_FIRST ( & evcon -> requests ) != NULL ) {\n if ( ! evhttp_connected ( evcon ) ) evhttp_connection_connect ( evcon ) ;\n else evhttp_request_dispatch ( evcon ) ;\n }\n else if ( ! need_close ) {\n evhttp_connection_start_detectclose ( evcon ) ;\n }\n }\n else {\n evcon -> state = EVCON_WRITING ;\n }\n ( * req -> cb ) ( req , req -> cb_arg ) ;\n if ( con_outgoing ) {\n evhttp_request_free ( req ) ;\n }\n }", "idx": 604}
{"hash": -4271192073087306668, "project": "debian", "size": 6, "label": 0, "functionSource": "static inline void store_mvs ( AVSContext * h ) {\n h -> col_mv [ h -> mbidx * 4 + 0 ] = h -> mv [ MV_FWD_X0 ] ;\n h -> col_mv [ h -> mbidx * 4 + 1 ] = h -> mv [ MV_FWD_X1 ] ;\n h -> col_mv [ h -> mbidx * 4 + 2 ] = h -> mv [ MV_FWD_X2 ] ;\n h -> col_mv [ h -> mbidx * 4 + 3 ] = h -> mv [ MV_FWD_X3 ] ;\n }", "idx": 605}
{"hash": -8830528631587258848, "project": "debian", "size": 62, "label": 0, "functionSource": "static int compress_filter ( void * opaque , int control , IOBUF a , byte * buf , size_t * ret_len ) {\n size_t size = * ret_len ;\n compress_filter_context_t * zfx = opaque ;\n z_stream * zs = zfx -> opaque ;\n int rc = 0 ;\n if ( control == IOBUFCTRL_UNDERFLOW ) {\n if ( ! zfx -> status ) {\n zs = zfx -> opaque = xmalloc_clear ( sizeof * zs ) ;\n init_uncompress ( zfx , zs ) ;\n zfx -> status = 1 ;\n }\n # ifndef __riscos__ zs -> next_out = buf ;\n # else zs -> next_out = ( Bytef * ) buf ;\n # endif zs -> avail_out = size ;\n zfx -> outbufsize = size ;\n rc = do_uncompress ( zfx , zs , a , ret_len ) ;\n }\n else if ( control == IOBUFCTRL_FLUSH ) {\n if ( ! zfx -> status ) {\n PACKET pkt ;\n PKT_compressed cd ;\n if ( zfx -> algo != COMPRESS_ALGO_ZIP && zfx -> algo != COMPRESS_ALGO_ZLIB ) BUG ( ) ;\n memset ( & cd , 0 , sizeof cd ) ;\n cd . len = 0 ;\n cd . algorithm = zfx -> algo ;\n init_packet ( & pkt ) ;\n pkt . pkttype = PKT_COMPRESSED ;\n pkt . pkt . compressed = & cd ;\n if ( build_packet ( a , & pkt ) ) log_bug ( \"build_packet(PKT_COMPRESSED) failed\\n\" ) ;\n zs = zfx -> opaque = xmalloc_clear ( sizeof * zs ) ;\n init_compress ( zfx , zs ) ;\n zfx -> status = 2 ;\n }\n # ifndef __riscos__ zs -> next_in = buf ;\n # else zs -> next_in = ( Bytef * ) buf ;\n # endif zs -> avail_in = size ;\n rc = do_compress ( zfx , zs , Z_NO_FLUSH , a ) ;\n }\n else if ( control == IOBUFCTRL_FREE ) {\n if ( zfx -> status == 1 ) {\n inflateEnd ( zs ) ;\n xfree ( zs ) ;\n zfx -> opaque = NULL ;\n xfree ( zfx -> outbuf ) ;\n zfx -> outbuf = NULL ;\n }\n else if ( zfx -> status == 2 ) {\n # ifndef __riscos__ zs -> next_in = buf ;\n # else zs -> next_in = ( Bytef * ) buf ;\n # endif zs -> avail_in = 0 ;\n do_compress ( zfx , zs , Z_FINISH , a ) ;\n deflateEnd ( zs ) ;\n xfree ( zs ) ;\n zfx -> opaque = NULL ;\n xfree ( zfx -> outbuf ) ;\n zfx -> outbuf = NULL ;\n }\n if ( zfx -> release ) zfx -> release ( zfx ) ;\n }\n else if ( control == IOBUFCTRL_DESC ) * ( char * * ) buf = \"compress_filter\" ;\n return rc ;\n }", "idx": 606}
{"hash": -2607754285145856562, "project": "debian", "size": 16, "label": 0, "functionSource": "static int write_path_table ( struct archive_write * a , int type_m , struct vdd * vdd ) {\n int depth , r ;\n size_t path_table_size ;\n r = ARCHIVE_OK ;\n path_table_size = 0 ;\n for ( depth = 0 ;\n depth < vdd -> max_depth ;\n depth ++ ) {\n r = _write_path_table ( a , type_m , depth , vdd ) ;\n if ( r < 0 ) return ( r ) ;\n path_table_size += r ;\n }\n path_table_size = path_table_size % PATH_TABLE_BLOCK_SIZE ;\n if ( path_table_size > 0 ) r = write_null ( a , PATH_TABLE_BLOCK_SIZE - path_table_size ) ;\n return ( r ) ;\n }", "idx": 607}
{"hash": -1672864273235910388, "project": "debian", "size": 40, "label": 0, "functionSource": "static void _slurm_rpc_layout_show ( slurm_msg_t * msg ) {\n layout_info_request_msg_t * layout_req_msg = ( layout_info_request_msg_t * ) msg -> data ;\n DEF_TIMERS ;\n slurm_msg_t response_msg ;\n char * dump ;\n int dump_size ;\n static int high_buffer_size = ( 1024 * 1024 ) ;\n Buf buffer = init_buf ( high_buffer_size ) ;\n START_TIMER ;\n debug2 ( \"Processing RPC: REQUEST_LAYOUT_INFO\" ) ;\n if ( layout_req_msg -> layout_type == NULL ) {\n dump = slurm_get_layouts ( ) ;\n pack32 ( ( uint32_t ) 2 , buffer ) ;\n packstr ( dump , buffer ) ;\n packstr ( \"\\n\" , buffer ) ;\n xfree ( dump ) ;\n }\n else {\n if ( layouts_pack_layout ( layout_req_msg -> layout_type , layout_req_msg -> entities , layout_req_msg -> type , layout_req_msg -> flags , buffer ) != SLURM_SUCCESS ) {\n debug2 ( \"%s: unable to get layout[%s]\" , __func__ , layout_req_msg -> layout_type ) ;\n slurm_send_rc_msg ( msg , SLURM_NO_CHANGE_IN_DATA ) ;\n free_buf ( buffer ) ;\n return ;\n }\n }\n dump_size = get_buf_offset ( buffer ) ;\n high_buffer_size = MAX ( high_buffer_size , dump_size ) ;\n dump = xfer_buf_data ( buffer ) ;\n END_TIMER2 ( \"_slurm_rpc_resv_show\" ) ;\n slurm_msg_t_init ( & response_msg ) ;\n response_msg . flags = msg -> flags ;\n response_msg . protocol_version = msg -> protocol_version ;\n response_msg . address = msg -> address ;\n response_msg . conn = msg -> conn ;\n response_msg . msg_type = RESPONSE_LAYOUT_INFO ;\n response_msg . data = dump ;\n response_msg . data_size = dump_size ;\n slurm_send_node_msg ( msg -> conn_fd , & response_msg ) ;\n xfree ( dump ) ;\n }", "idx": 608}
{"hash": 3919646340804521652, "project": "debian", "size": 8, "label": 0, "functionSource": "static int pack_offset_sort ( const void * _a , const void * _b ) {\n const struct object_entry * a = * ( struct object_entry * * ) _a ;\n const struct object_entry * b = * ( struct object_entry * * ) _b ;\n if ( ! a -> in_pack && ! b -> in_pack ) return hashcmp ( a -> idx . sha1 , b -> idx . sha1 ) ;\n if ( a -> in_pack < b -> in_pack ) return - 1 ;\n if ( a -> in_pack > b -> in_pack ) return 1 ;\n return a -> in_pack_offset < b -> in_pack_offset ? - 1 : ( a -> in_pack_offset > b -> in_pack_offset ) ;\n }", "idx": 609}
{"hash": -4341894042551388054, "project": "chrome", "size": 48, "label": 1, "functionSource": "static int mv_refs_rt ( const VP9_COMMON * cm , const MACROBLOCKD * xd , const TileInfo * const tile , MODE_INFO * mi , MV_REFERENCE_FRAME ref_frame , int_mv * mv_ref_list , int mi_row , int mi_col ) {\n const int * ref_sign_bias = cm -> ref_frame_sign_bias ;\n int i , refmv_count = 0 ;\n const POSITION * const mv_ref_search = mv_ref_blocks [ mi -> mbmi . sb_type ] ;\n int different_ref_found = 0 ;\n int context_counter = 0 ;\n int const_motion = 0 ;\n vpx_memset ( mv_ref_list , 0 , sizeof ( * mv_ref_list ) * MAX_MV_REF_CANDIDATES ) ;\n for ( i = 0 ;\n i < 2 ;\n ++ i ) {\n const POSITION * const mv_ref = & mv_ref_search [ i ] ;\n if ( is_inside ( tile , mi_col , mi_row , cm -> mi_rows , mv_ref ) ) {\n const MODE_INFO * const candidate_mi = xd -> mi [ mv_ref -> col + mv_ref -> row * xd -> mi_stride ] ;\n const MB_MODE_INFO * const candidate = & candidate_mi -> mbmi ;\n context_counter += mode_2_counter [ candidate -> mode ] ;\n different_ref_found = 1 ;\n if ( candidate -> ref_frame [ 0 ] == ref_frame ) ADD_MV_REF_LIST ( get_sub_block_mv ( candidate_mi , 0 , mv_ref -> col , - 1 ) ) ;\n }\n }\n const_motion = 1 ;\n for ( ;\n i < MVREF_NEIGHBOURS && ! refmv_count ;\n ++ i ) {\n const POSITION * const mv_ref = & mv_ref_search [ i ] ;\n if ( is_inside ( tile , mi_col , mi_row , cm -> mi_rows , mv_ref ) ) {\n const MB_MODE_INFO * const candidate = & xd -> mi [ mv_ref -> col + mv_ref -> row * xd -> mi_stride ] -> mbmi ;\n different_ref_found = 1 ;\n if ( candidate -> ref_frame [ 0 ] == ref_frame ) ADD_MV_REF_LIST ( candidate -> mv [ 0 ] ) ;\n }\n }\n if ( different_ref_found && ! refmv_count ) {\n for ( i = 0 ;\n i < MVREF_NEIGHBOURS ;\n ++ i ) {\n const POSITION * mv_ref = & mv_ref_search [ i ] ;\n if ( is_inside ( tile , mi_col , mi_row , cm -> mi_rows , mv_ref ) ) {\n const MB_MODE_INFO * const candidate = & xd -> mi [ mv_ref -> col + mv_ref -> row * xd -> mi_stride ] -> mbmi ;\n IF_DIFF_REF_FRAME_ADD_MV ( candidate ) ;\n }\n }\n }\n Done : mi -> mbmi . mode_context [ ref_frame ] = counter_to_context [ context_counter ] ;\n for ( i = 0 ;\n i < MAX_MV_REF_CANDIDATES ;\n ++ i ) clamp_mv_ref ( & mv_ref_list [ i ] . as_mv , xd ) ;\n return const_motion ;\n }", "idx": 610}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_RequestModeRejectCause ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_RequestModeRejectCause , RequestModeRejectCause_choice , NULL ) ;\n return offset ;\n }", "idx": 611}
{"hash": -7811574867662618708, "project": "debian", "size": 3, "label": 0, "functionSource": "static void print_var_int ( const char * var , int val ) {\n printf ( \"%s=%d\\n\" , var , val ) ;\n }", "idx": 612}
{"hash": -7131177824150194183, "project": "debian", "size": 11, "label": 0, "functionSource": "static void read_bundle ( GetBitContext * gb , BinkContext * c , int bundle_num ) {\n int i ;\n if ( bundle_num == BINK_SRC_COLORS ) {\n for ( i = 0 ;\n i < 16 ;\n i ++ ) read_tree ( gb , & c -> col_high [ i ] ) ;\n c -> col_lastval = 0 ;\n }\n if ( bundle_num != BINK_SRC_INTRA_DC && bundle_num != BINK_SRC_INTER_DC ) read_tree ( gb , & c -> bundle [ bundle_num ] . tree ) ;\n c -> bundle [ bundle_num ] . cur_dec = c -> bundle [ bundle_num ] . cur_ptr = c -> bundle [ bundle_num ] . data ;\n }", "idx": 613}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_NoPTAudioToneCapability ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_NoPTAudioToneCapability , NoPTAudioToneCapability_sequence ) ;\n return offset ;\n }", "idx": 614}
{"hash": 5468438784905165517, "project": "debian", "size": 3, "label": 0, "functionSource": "int ec_GF2m_precompute_mult ( EC_GROUP * group , BN_CTX * ctx ) {\n return ec_wNAF_precompute_mult ( group , ctx ) ;\n }", "idx": 615}
{"hash": 5357882892791796049, "project": "debian", "size": 16, "label": 0, "functionSource": "uint64_t e1000e_core_read ( E1000ECore * core , hwaddr addr , unsigned size ) {\n uint64_t val ;\n uint16_t index = e1000e_get_reg_index_with_offset ( mac_reg_access , addr ) ;\n if ( index < E1000E_NREADOPS && e1000e_macreg_readops [ index ] ) {\n if ( mac_reg_access [ index ] & MAC_ACCESS_PARTIAL ) {\n trace_e1000e_wrn_regs_read_trivial ( index << 2 ) ;\n }\n val = e1000e_macreg_readops [ index ] ( core , index ) ;\n trace_e1000e_core_read ( index << 2 , size , val ) ;\n return val ;\n }\n else {\n trace_e1000e_wrn_regs_read_unknown ( index << 2 , size ) ;\n }\n return 0 ;\n }", "idx": 616}
{"hash": -16551315108292821, "project": "debian", "size": 25, "label": 0, "functionSource": "void gcry_sexp_release ( gcry_sexp_t sexp ) {\n if ( sexp ) {\n if ( gcry_is_secure ( sexp ) ) {\n const byte * p = sexp -> d ;\n int type ;\n while ( ( type = * p ) != ST_STOP ) {\n p ++ ;\n switch ( type ) {\n case ST_OPEN : break ;\n case ST_CLOSE : break ;\n case ST_DATA : {\n DATALEN n ;\n memcpy ( & n , p , sizeof n ) ;\n p += sizeof n ;\n p += n ;\n }\n break ;\n default : break ;\n }\n }\n wipememory ( sexp -> d , p - sexp -> d ) ;\n }\n gcry_free ( sexp ) ;\n }\n }", "idx": 617}
{"hash": 1182028467273264883, "project": "debian", "size": 30, "label": 0, "functionSource": "int compare_files2 ( File fd1 , const char * filename2 ) {\n int error = RESULT_OK ;\n File fd2 ;\n size_t fd1_length , fd2_length ;\n DYNAMIC_STRING fd1_result , fd2_result ;\n if ( ( fd2 = my_open ( filename2 , O_RDONLY , MYF ( 0 ) ) ) < 0 ) {\n my_close ( fd1 , MYF ( 0 ) ) ;\n die ( \"Failed to open second file: '%s'\" , filename2 ) ;\n }\n fd1_length = ( size_t ) my_seek ( fd1 , 0 , SEEK_END , MYF ( 0 ) ) ;\n fd2_length = ( size_t ) my_seek ( fd2 , 0 , SEEK_END , MYF ( 0 ) ) ;\n if ( init_dynamic_string ( & fd1_result , 0 , fd1_length , 0 ) || init_dynamic_string ( & fd2_result , 0 , fd2_length , 0 ) ) die ( \"Out of memory when allocating data for result\" ) ;\n fd1_result . length = fd1_length ;\n fd2_result . length = fd2_length ;\n ( void ) my_seek ( fd1 , 0 , SEEK_SET , MYF ( 0 ) ) ;\n ( void ) my_seek ( fd2 , 0 , SEEK_SET , MYF ( 0 ) ) ;\n if ( my_read ( fd1 , ( uchar * ) fd1_result . str , fd1_length , MYF ( MY_WME | MY_NABP ) ) ) die ( \"Error when reading data from result file\" ) ;\n if ( my_read ( fd2 , ( uchar * ) fd2_result . str , fd2_length , MYF ( MY_WME | MY_NABP ) ) ) die ( \"Error when reading data from result file\" ) ;\n if ( global_subst && ( fd1_length != fd2_length || memcmp ( fd1_result . str , fd2_result . str , fd1_length ) ) ) {\n uint global_subst_from_len = strlen ( global_subst_from ) ;\n uint global_subst_to_len = strlen ( global_subst_to ) ;\n while ( replace ( & fd1_result , global_subst_from , global_subst_from_len , global_subst_to , global_subst_to_len ) == 0 ) ;\n }\n if ( fd1_result . length != fd2_result . length ) error = RESULT_LENGTH_MISMATCH ;\n else if ( ( memcmp ( fd1_result . str , fd2_result . str , fd1_result . length ) ) ) error = RESULT_CONTENT_MISMATCH ;\n my_close ( fd2 , MYF ( 0 ) ) ;\n dynstr_free ( & fd1_result ) ;\n dynstr_free ( & fd2_result ) ;\n return error ;\n }", "idx": 618}
{"hash": -7049333455584635197, "project": "chrome", "size": 92, "label": 0, "functionSource": "static void U_CALLCONV _UTF16ToUnicodeWithOffsets ( UConverterToUnicodeArgs * pArgs , UErrorCode * pErrorCode ) {\n UConverter * cnv = pArgs -> converter ;\n const char * source = pArgs -> source ;\n const char * sourceLimit = pArgs -> sourceLimit ;\n int32_t * offsets = pArgs -> offsets ;\n int32_t state , offsetDelta ;\n uint8_t b ;\n state = cnv -> mode ;\n offsetDelta = 0 ;\n while ( source < sourceLimit && U_SUCCESS ( * pErrorCode ) ) {\n switch ( state ) {\n case 0 : cnv -> toUBytes [ 0 ] = ( uint8_t ) * source ++ ;\n cnv -> toULength = 1 ;\n state = 1 ;\n break ;\n case 1 : b = * source ;\n if ( cnv -> toUBytes [ 0 ] == 0xfe && b == 0xff ) {\n if ( IS_UTF16LE ( cnv ) ) {\n state = 7 ;\n }\n else {\n state = 8 ;\n }\n }\n else if ( cnv -> toUBytes [ 0 ] == 0xff && b == 0xfe ) {\n if ( IS_UTF16BE ( cnv ) ) {\n state = 6 ;\n }\n else {\n state = 9 ;\n }\n }\n else if ( ( IS_UTF16 ( cnv ) && UCNV_GET_VERSION ( cnv ) == 1 ) ) {\n state = 6 ;\n }\n if ( state >= 8 ) {\n ++ source ;\n cnv -> toULength = 0 ;\n offsetDelta = ( int32_t ) ( source - pArgs -> source ) ;\n }\n else if ( state < 6 ) {\n if ( source != pArgs -> source ) {\n source = pArgs -> source ;\n cnv -> toULength = 0 ;\n }\n if ( IS_UTF16LE ( cnv ) ) {\n state = 9 ;\n }\n else {\n state = 8 ;\n }\n }\n else {\n cnv -> toUBytes [ 1 ] = b ;\n cnv -> toULength = 2 ;\n pArgs -> source = source + 1 ;\n cnv -> mode = state + 2 ;\n * pErrorCode = U_ILLEGAL_ESCAPE_SEQUENCE ;\n return ;\n }\n cnv -> mode = state ;\n continue ;\n case 8 : pArgs -> source = source ;\n _UTF16BEToUnicodeWithOffsets ( pArgs , pErrorCode ) ;\n source = pArgs -> source ;\n break ;\n case 9 : pArgs -> source = source ;\n _UTF16LEToUnicodeWithOffsets ( pArgs , pErrorCode ) ;\n source = pArgs -> source ;\n break ;\n default : break ;\n }\n }\n if ( offsets != NULL && offsetDelta != 0 ) {\n int32_t * offsetsLimit = pArgs -> offsets ;\n while ( offsets < offsetsLimit ) {\n * offsets ++ += offsetDelta ;\n }\n }\n pArgs -> source = source ;\n if ( source == sourceLimit && pArgs -> flush ) {\n switch ( state ) {\n case 0 : break ;\n case 8 : _UTF16BEToUnicodeWithOffsets ( pArgs , pErrorCode ) ;\n break ;\n case 9 : _UTF16LEToUnicodeWithOffsets ( pArgs , pErrorCode ) ;\n break ;\n default : break ;\n }\n }\n cnv -> mode = state ;\n }", "idx": 619}
{"hash": 8572106347813672436, "project": "debian", "size": 23, "label": 0, "functionSource": "static int pfkey_delete ( struct sock * sk , struct sk_buff * skb , const struct sadb_msg * hdr , void * const * ext_hdrs ) {\n struct net * net = sock_net ( sk ) ;\n struct xfrm_state * x ;\n struct km_event c ;\n int err ;\n if ( ! ext_hdrs [ SADB_EXT_SA - 1 ] || ! present_and_same_family ( ext_hdrs [ SADB_EXT_ADDRESS_SRC - 1 ] , ext_hdrs [ SADB_EXT_ADDRESS_DST - 1 ] ) ) return - EINVAL ;\n x = pfkey_xfrm_state_lookup ( net , hdr , ext_hdrs ) ;\n if ( x == NULL ) return - ESRCH ;\n if ( ( err = security_xfrm_state_delete ( x ) ) ) goto out ;\n if ( xfrm_state_kern ( x ) ) {\n err = - EPERM ;\n goto out ;\n }\n err = xfrm_state_delete ( x ) ;\n if ( err < 0 ) goto out ;\n c . seq = hdr -> sadb_msg_seq ;\n c . portid = hdr -> sadb_msg_pid ;\n c . event = XFRM_MSG_DELSA ;\n km_state_notify ( x , & c ) ;\n out : xfrm_audit_state_delete ( x , err ? 0 : 1 , audit_get_loginuid ( current ) , audit_get_sessionid ( current ) , 0 ) ;\n xfrm_state_put ( x ) ;\n return err ;\n }", "idx": 620}
{"hash": 7039307292471244756, "project": "debian", "size": 9, "label": 0, "functionSource": "static void dtap_tp_multi_slot_loop_cmd ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len ) {\n guint32 curr_offset ;\n guint32 consumed ;\n guint curr_len ;\n curr_len = len ;\n curr_offset = offset ;\n ELEM_MAND_V ( GSM_A_PDU_TYPE_DTAP , DE_TP_LOOP_TYPE , NULL ) ;\n EXTRANEOUS_DATA_CHECK ( curr_len , 0 , pinfo , & ei_gsm_a_dtap_extraneous_data ) ;\n }", "idx": 621}
{"hash": 4180964683905830761, "project": "debian", "size": 7, "label": 0, "functionSource": "static int selinux_tun_dev_attach ( struct sock * sk , void * security ) {\n struct tun_security_struct * tunsec = security ;\n struct sk_security_struct * sksec = sk -> sk_security ;\n sksec -> sid = tunsec -> sid ;\n sksec -> sclass = SECCLASS_TUN_SOCKET ;\n return 0 ;\n }", "idx": 622}
{"hash": -2908211205972632000, "project": "debian", "size": 110, "label": 0, "functionSource": "static void mainwindows_resize_smaller ( int ydiff ) {\n MAIN_WINDOW_REC * rec ;\n GSList * sorted , * tmp ;\n int space ;\n sorted = NULL ;\n for ( rec = mainwindows_find_lower ( NULL ) ;\n rec != NULL ;\n rec = mainwindows_find_lower ( rec ) ) {\n sorted = g_slist_prepend ( sorted , rec ) ;\n }\n if ( sorted == NULL ) return ;\n for ( ;\n ;\n ) {\n int skip_active = FALSE ;\n space = 0 ;\n for ( tmp = sorted ;\n tmp != NULL ;\n tmp = tmp -> next ) {\n int min ;\n GSList * line , * ltmp ;\n rec = tmp -> data ;\n line = mainwindows_get_line ( rec ) ;\n min = screen_height - ydiff ;\n for ( ltmp = line ;\n ltmp != NULL ;\n ltmp = ltmp -> next ) {\n int lmin ;\n MAIN_WINDOW_REC * win = ltmp -> data ;\n if ( win == active_mainwin && tmp == sorted ) skip_active = TRUE ;\n lmin = MAIN_WINDOW_TEXT_HEIGHT ( win ) - WINDOW_MIN_SIZE ;\n if ( lmin < min ) min = lmin ;\n }\n g_slist_free ( line ) ;\n space += min ;\n }\n if ( space >= - ydiff ) break ;\n rec = sorted -> data ;\n if ( skip_active && sorted -> next != NULL ) rec = sorted -> next -> data ;\n sorted = g_slist_remove ( sorted , rec ) ;\n if ( sorted != NULL ) {\n GSList * line , * ltmp ;\n line = mainwindows_get_line ( rec ) ;\n for ( ltmp = line ;\n ltmp != NULL ;\n ltmp = ltmp -> next ) {\n MAIN_WINDOW_REC * win = ltmp -> data ;\n mainwindow_destroy ( win ) ;\n }\n g_slist_free ( line ) ;\n }\n else {\n GSList * line , * ltmp ;\n line = mainwindows_get_line ( rec ) ;\n for ( ltmp = line ;\n ltmp != NULL ;\n ltmp = ltmp -> next ) {\n MAIN_WINDOW_REC * win = ltmp -> data ;\n win -> last_line += ydiff ;\n mainwindow_resize ( win , 0 , ydiff ) ;\n }\n g_slist_free ( line ) ;\n return ;\n }\n }\n for ( tmp = sorted ;\n tmp != NULL && ydiff < 0 ;\n tmp = tmp -> next ) {\n int min ;\n GSList * line , * ltmp ;\n rec = tmp -> data ;\n line = mainwindows_get_line ( rec ) ;\n min = screen_height - ydiff ;\n for ( ltmp = line ;\n ltmp != NULL ;\n ltmp = ltmp -> next ) {\n int lmin ;\n MAIN_WINDOW_REC * win = ltmp -> data ;\n lmin = MAIN_WINDOW_TEXT_HEIGHT ( win ) - WINDOW_MIN_SIZE ;\n if ( lmin < min ) min = lmin ;\n }\n space = min ;\n if ( space == 0 ) {\n for ( ltmp = line ;\n ltmp != NULL ;\n ltmp = ltmp -> next ) {\n MAIN_WINDOW_REC * win = ltmp -> data ;\n mainwindow_resize ( win , 0 , 0 ) ;\n win -> size_dirty = TRUE ;\n win -> first_line += ydiff ;\n win -> last_line += ydiff ;\n signal_emit ( \"mainwindow moved\" , 1 , win ) ;\n }\n }\n else {\n if ( space > - ydiff ) space = - ydiff ;\n for ( ltmp = line ;\n ltmp != NULL ;\n ltmp = ltmp -> next ) {\n MAIN_WINDOW_REC * win = ltmp -> data ;\n win -> last_line += ydiff ;\n win -> first_line += ydiff + space ;\n mainwindow_resize ( win , 0 , - space ) ;\n }\n ydiff += space ;\n }\n g_slist_free ( line ) ;\n }\n g_slist_free ( sorted ) ;\n }", "idx": 623}
{"hash": -649112636673899765, "project": "debian", "size": 124, "label": 1, "functionSource": "static int ivr_read_header ( AVFormatContext * s ) {\n unsigned tag , type , len , tlen , value ;\n int i , j , n , count , nb_streams = 0 , ret ;\n uint8_t key [ 256 ] , val [ 256 ] ;\n AVIOContext * pb = s -> pb ;\n AVStream * st ;\n int64_t pos , offset , temp ;\n pos = avio_tell ( pb ) ;\n tag = avio_rl32 ( pb ) ;\n if ( tag == MKTAG ( '.' , 'R' , '1' , 'M' ) ) {\n if ( avio_rb16 ( pb ) != 1 ) return AVERROR_INVALIDDATA ;\n if ( avio_r8 ( pb ) != 1 ) return AVERROR_INVALIDDATA ;\n len = avio_rb32 ( pb ) ;\n avio_skip ( pb , len ) ;\n avio_skip ( pb , 5 ) ;\n temp = avio_rb64 ( pb ) ;\n while ( ! avio_feof ( pb ) && temp ) {\n offset = temp ;\n temp = avio_rb64 ( pb ) ;\n }\n avio_skip ( pb , offset - avio_tell ( pb ) ) ;\n if ( avio_r8 ( pb ) != 1 ) return AVERROR_INVALIDDATA ;\n len = avio_rb32 ( pb ) ;\n avio_skip ( pb , len ) ;\n if ( avio_r8 ( pb ) != 2 ) return AVERROR_INVALIDDATA ;\n avio_skip ( pb , 16 ) ;\n pos = avio_tell ( pb ) ;\n tag = avio_rl32 ( pb ) ;\n }\n if ( tag != MKTAG ( '.' , 'R' , 'E' , 'C' ) ) return AVERROR_INVALIDDATA ;\n if ( avio_r8 ( pb ) != 0 ) return AVERROR_INVALIDDATA ;\n count = avio_rb32 ( pb ) ;\n for ( i = 0 ;\n i < count ;\n i ++ ) {\n if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ;\n type = avio_r8 ( pb ) ;\n tlen = avio_rb32 ( pb ) ;\n avio_get_str ( pb , tlen , key , sizeof ( key ) ) ;\n len = avio_rb32 ( pb ) ;\n if ( type == 5 ) {\n avio_get_str ( pb , len , val , sizeof ( val ) ) ;\n av_log ( s , AV_LOG_DEBUG , \"%s = '%s'\\n\" , key , val ) ;\n }\n else if ( type == 4 ) {\n av_log ( s , AV_LOG_DEBUG , \"%s = '0x\" , key ) ;\n for ( j = 0 ;\n j < len ;\n j ++ ) av_log ( s , AV_LOG_DEBUG , \"%X\" , avio_r8 ( pb ) ) ;\n av_log ( s , AV_LOG_DEBUG , \"'\\n\" ) ;\n }\n else if ( len == 4 && type == 3 && ! strncmp ( key , \"StreamCount\" , tlen ) ) {\n nb_streams = value = avio_rb32 ( pb ) ;\n }\n else if ( len == 4 && type == 3 ) {\n value = avio_rb32 ( pb ) ;\n av_log ( s , AV_LOG_DEBUG , \"%s = %d\\n\" , key , value ) ;\n }\n else {\n av_log ( s , AV_LOG_DEBUG , \"Skipping unsupported key: %s\\n\" , key ) ;\n avio_skip ( pb , len ) ;\n }\n }\n for ( n = 0 ;\n n < nb_streams ;\n n ++ ) {\n st = avformat_new_stream ( s , NULL ) ;\n if ( ! st ) return AVERROR ( ENOMEM ) ;\n st -> priv_data = ff_rm_alloc_rmstream ( ) ;\n if ( ! st -> priv_data ) return AVERROR ( ENOMEM ) ;\n if ( avio_r8 ( pb ) != 1 ) return AVERROR_INVALIDDATA ;\n count = avio_rb32 ( pb ) ;\n for ( i = 0 ;\n i < count ;\n i ++ ) {\n if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ;\n type = avio_r8 ( pb ) ;\n tlen = avio_rb32 ( pb ) ;\n avio_get_str ( pb , tlen , key , sizeof ( key ) ) ;\n len = avio_rb32 ( pb ) ;\n if ( type == 5 ) {\n avio_get_str ( pb , len , val , sizeof ( val ) ) ;\n av_log ( s , AV_LOG_DEBUG , \"%s = '%s'\\n\" , key , val ) ;\n }\n else if ( type == 4 && ! strncmp ( key , \"OpaqueData\" , tlen ) ) {\n ret = ffio_ensure_seekback ( pb , 4 ) ;\n if ( ret < 0 ) return ret ;\n if ( avio_rb32 ( pb ) == MKBETAG ( 'M' , 'L' , 'T' , 'I' ) ) {\n ret = rm_read_multi ( s , pb , st , NULL ) ;\n }\n else {\n avio_seek ( pb , - 4 , SEEK_CUR ) ;\n ret = ff_rm_read_mdpr_codecdata ( s , pb , st , st -> priv_data , len , NULL ) ;\n }\n if ( ret < 0 ) return ret ;\n }\n else if ( type == 4 ) {\n int j ;\n av_log ( s , AV_LOG_DEBUG , \"%s = '0x\" , key ) ;\n for ( j = 0 ;\n j < len ;\n j ++ ) av_log ( s , AV_LOG_DEBUG , \"%X\" , avio_r8 ( pb ) ) ;\n av_log ( s , AV_LOG_DEBUG , \"'\\n\" ) ;\n }\n else if ( len == 4 && type == 3 && ! strncmp ( key , \"Duration\" , tlen ) ) {\n st -> duration = avio_rb32 ( pb ) ;\n }\n else if ( len == 4 && type == 3 ) {\n value = avio_rb32 ( pb ) ;\n av_log ( s , AV_LOG_DEBUG , \"%s = %d\\n\" , key , value ) ;\n }\n else {\n av_log ( s , AV_LOG_DEBUG , \"Skipping unsupported key: %s\\n\" , key ) ;\n avio_skip ( pb , len ) ;\n }\n }\n }\n if ( avio_r8 ( pb ) != 6 ) return AVERROR_INVALIDDATA ;\n avio_skip ( pb , 12 ) ;\n avio_skip ( pb , avio_rb64 ( pb ) + pos - avio_tell ( s -> pb ) ) ;\n if ( avio_r8 ( pb ) != 8 ) return AVERROR_INVALIDDATA ;\n avio_skip ( pb , 8 ) ;\n return 0 ;\n }", "idx": 624}
{"hash": -5357254031401749470, "project": "debian", "size": 62, "label": 0, "functionSource": "int luaD_precall ( lua_State * L , StkId func , int nresults ) {\n LClosure * cl ;\n ptrdiff_t funcr ;\n if ( ! ttisfunction ( func ) ) func = tryfuncTM ( L , func ) ;\n funcr = savestack ( L , func ) ;\n cl = & clvalue ( func ) -> l ;\n L -> ci -> savedpc = L -> savedpc ;\n if ( ! cl -> isC ) {\n CallInfo * ci ;\n StkId st , base ;\n Proto * p = cl -> p ;\n luaD_checkstack ( L , p -> maxstacksize ) ;\n func = restorestack ( L , funcr ) ;\n if ( ! p -> is_vararg ) {\n base = func + 1 ;\n if ( L -> top > base + p -> numparams ) L -> top = base + p -> numparams ;\n }\n else {\n int nargs = cast_int ( L -> top - func ) - 1 ;\n base = adjust_varargs ( L , p , nargs ) ;\n func = restorestack ( L , funcr ) ;\n }\n ci = inc_ci ( L ) ;\n ci -> func = func ;\n L -> base = ci -> base = base ;\n ci -> top = L -> base + p -> maxstacksize ;\n lua_assert ( ci -> top <= L -> stack_last ) ;\n L -> savedpc = p -> code ;\n ci -> tailcalls = 0 ;\n ci -> nresults = nresults ;\n for ( st = L -> top ;\n st < ci -> top ;\n st ++ ) setnilvalue ( st ) ;\n L -> top = ci -> top ;\n if ( L -> hookmask & LUA_MASKCALL ) {\n L -> savedpc ++ ;\n luaD_callhook ( L , LUA_HOOKCALL , - 1 ) ;\n L -> savedpc -- ;\n }\n return PCRLUA ;\n }\n else {\n CallInfo * ci ;\n int n ;\n luaD_checkstack ( L , LUA_MINSTACK ) ;\n ci = inc_ci ( L ) ;\n ci -> func = restorestack ( L , funcr ) ;\n L -> base = ci -> base = ci -> func + 1 ;\n ci -> top = L -> top + LUA_MINSTACK ;\n lua_assert ( ci -> top <= L -> stack_last ) ;\n ci -> nresults = nresults ;\n if ( L -> hookmask & LUA_MASKCALL ) luaD_callhook ( L , LUA_HOOKCALL , - 1 ) ;\n lua_unlock ( L ) ;\n n = ( * curr_func ( L ) -> c . f ) ( L ) ;\n lua_lock ( L ) ;\n if ( n < 0 ) return PCRYIELD ;\n else {\n luaD_poscall ( L , L -> top - n ) ;\n return PCRC ;\n }\n }\n }", "idx": 625}
{"hash": 2064081176034684128, "project": "debian", "size": 19, "label": 0, "functionSource": "static int matroska_deliver_packet ( MatroskaDemuxContext * matroska , AVPacket * pkt ) {\n if ( matroska -> num_packets > 0 ) {\n memcpy ( pkt , matroska -> packets [ 0 ] , sizeof ( AVPacket ) ) ;\n av_free ( matroska -> packets [ 0 ] ) ;\n if ( matroska -> num_packets > 1 ) {\n void * newpackets ;\n memmove ( & matroska -> packets [ 0 ] , & matroska -> packets [ 1 ] , ( matroska -> num_packets - 1 ) * sizeof ( AVPacket * ) ) ;\n newpackets = av_realloc ( matroska -> packets , ( matroska -> num_packets - 1 ) * sizeof ( AVPacket * ) ) ;\n if ( newpackets ) matroska -> packets = newpackets ;\n }\n else {\n av_freep ( & matroska -> packets ) ;\n matroska -> prev_pkt = NULL ;\n }\n matroska -> num_packets -- ;\n return 0 ;\n }\n return - 1 ;\n }", "idx": 626}
{"hash": -7076754245473579218, "project": "chrome", "size": 7, "label": 0, "functionSource": "static void evhttp_connection_start_detectclose ( struct evhttp_connection * evcon ) {\n evcon -> flags |= EVHTTP_CON_CLOSEDETECT ;\n if ( event_initialized ( & evcon -> close_ev ) ) event_del ( & evcon -> close_ev ) ;\n event_set ( & evcon -> close_ev , evcon -> fd , EV_READ , evhttp_detect_close_cb , evcon ) ;\n EVHTTP_BASE_SET ( evcon , & evcon -> close_ev ) ;\n event_add ( & evcon -> close_ev , NULL ) ;\n }", "idx": 627}
{"hash": 8320716512483418415, "project": "chrome", "size": 8, "label": 1, "functionSource": "void vp9_iht16x16_add ( TX_TYPE tx_type , const int16_t * input , uint8_t * dest , int stride , int eob ) {\n if ( tx_type == DCT_DCT ) {\n vp9_idct16x16_add ( input , dest , stride , eob ) ;\n }\n else {\n vp9_iht16x16_256_add ( input , dest , stride , tx_type ) ;\n }\n }", "idx": 628}
{"hash": -8884965407551053630, "project": "debian", "size": 9, "label": 0, "functionSource": "static void DecoderSignalWait ( decoder_t * p_dec , bool b_has_data ) {\n decoder_owner_sys_t * p_owner = p_dec -> p_owner ;\n vlc_mutex_lock ( & p_owner -> lock ) ;\n if ( p_owner -> b_waiting ) {\n if ( b_has_data ) p_owner -> b_has_data = true ;\n vlc_cond_signal ( & p_owner -> wait_acknowledge ) ;\n }\n vlc_mutex_unlock ( & p_owner -> lock ) ;\n }", "idx": 629}
{"hash": -7076754245473579218, "project": "chrome", "size": 22, "label": 0, "functionSource": "void evhttp_connection_free ( struct evhttp_connection * evcon ) {\n struct evhttp_request * req ;\n if ( evcon -> fd != - 1 ) {\n if ( evhttp_connected ( evcon ) && evcon -> closecb != NULL ) ( * evcon -> closecb ) ( evcon , evcon -> closecb_arg ) ;\n }\n while ( ( req = TAILQ_FIRST ( & evcon -> requests ) ) != NULL ) {\n TAILQ_REMOVE ( & evcon -> requests , req , next ) ;\n evhttp_request_free ( req ) ;\n }\n if ( evcon -> http_server != NULL ) {\n struct evhttp * http = evcon -> http_server ;\n TAILQ_REMOVE ( & http -> connections , evcon , next ) ;\n }\n if ( event_initialized ( & evcon -> close_ev ) ) event_del ( & evcon -> close_ev ) ;\n if ( event_initialized ( & evcon -> ev ) ) event_del ( & evcon -> ev ) ;\n if ( evcon -> fd != - 1 ) EVUTIL_CLOSESOCKET ( evcon -> fd ) ;\n if ( evcon -> bind_address != NULL ) free ( evcon -> bind_address ) ;\n if ( evcon -> address != NULL ) free ( evcon -> address ) ;\n if ( evcon -> input_buffer != NULL ) evbuffer_free ( evcon -> input_buffer ) ;\n if ( evcon -> output_buffer != NULL ) evbuffer_free ( evcon -> output_buffer ) ;\n free ( evcon ) ;\n }", "idx": 630}
{"hash": 1760449185745615462, "project": "debian", "size": 6, "label": 0, "functionSource": "void TSHttpTxnArgSet ( TSHttpTxn txnp , int arg_idx , void * arg ) {\n sdk_assert ( sdk_sanity_check_txn ( txnp ) == TS_SUCCESS ) ;\n sdk_assert ( arg_idx >= 0 && arg_idx < HTTP_SSN_TXN_MAX_USER_ARG ) ;\n HttpSM * sm = ( HttpSM * ) txnp ;\n sm -> t_state . user_args [ arg_idx ] = arg ;\n }", "idx": 631}
{"hash": -398565394354770780, "project": "debian", "size": 3, "label": 0, "functionSource": "static inline int ohci_read_hcca ( OHCIState * ohci , dma_addr_t addr , struct ohci_hcca * hcca ) {\n return dma_memory_read ( ohci -> as , addr + ohci -> localmem_base , hcca , sizeof ( * hcca ) ) ;\n }", "idx": 632}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_RequestChannelCloseReject ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_RequestChannelCloseReject , RequestChannelCloseReject_sequence ) ;\n return offset ;\n }", "idx": 633}
{"hash": -8028756826159773630, "project": "debian", "size": 21, "label": 0, "functionSource": "static void _reconnectToDB ( ArchiveHandle * AH , const char * dbname ) {\n if ( RestoringToDB ( AH ) ) ReconnectToServer ( AH , dbname , NULL ) ;\n else {\n if ( dbname ) {\n PQExpBufferData connectbuf ;\n initPQExpBuffer ( & connectbuf ) ;\n appendPsqlMetaConnect ( & connectbuf , dbname ) ;\n ahprintf ( AH , \"%s\\n\" , connectbuf . data ) ;\n termPQExpBuffer ( & connectbuf ) ;\n }\n else ahprintf ( AH , \"%s\\n\" , \"\\\\connect -\\n\" ) ;\n }\n if ( AH -> currUser ) free ( AH -> currUser ) ;\n AH -> currUser = NULL ;\n if ( AH -> currSchema ) free ( AH -> currSchema ) ;\n AH -> currSchema = NULL ;\n if ( AH -> currTablespace ) free ( AH -> currTablespace ) ;\n AH -> currTablespace = NULL ;\n AH -> currWithOids = - 1 ;\n _doSetFixedOutputState ( AH ) ;\n }", "idx": 634}
{"hash": 2830888773500127914, "project": "debian", "size": 14, "label": 0, "functionSource": "static void check_new_cluster_is_empty ( void ) {\n int dbnum ;\n for ( dbnum = 0 ;\n dbnum < new_cluster . dbarr . ndbs ;\n dbnum ++ ) {\n int relnum ;\n RelInfoArr * rel_arr = & new_cluster . dbarr . dbs [ dbnum ] . rel_arr ;\n for ( relnum = 0 ;\n relnum < rel_arr -> nrels ;\n relnum ++ ) {\n if ( strcmp ( rel_arr -> rels [ relnum ] . nspname , \"pg_catalog\" ) != 0 ) pg_fatal ( \"New cluster database \\\"%s\\\" is not empty\\n\" , new_cluster . dbarr . dbs [ dbnum ] . db_name ) ;\n }\n }\n }", "idx": 635}
{"hash": -5456913190944844754, "project": "chrome", "size": 31, "label": 0, "functionSource": "TEST_F ( TemplateURLTest , GetURLNoInstantURL ) {\n TemplateURLData data ;\n data . SetURL ( \"http://google.com/?q={\nsearchTerms}\n\" ) ;\n data . suggestions_url = \"http://google.com/suggest?q={\nsearchTerms}\n\" ;\n data . alternate_urls . push_back ( \"http://google.com/alt?q={\nsearchTerms}\n\" ) ;\n data . alternate_urls . push_back ( \"{\ngoogle:baseURL}\n/alt/#q={\nsearchTerms}\n\" ) ;\n TemplateURL url ( data ) ;\n const std : : vector < TemplateURLRef > & url_refs = url . url_refs ( ) ;\n ASSERT_EQ ( 3U , url_refs . size ( ) ) ;\n EXPECT_EQ ( \"http://google.com/alt?q={\nsearchTerms}\n\" , url_refs [ 0 ] . GetURL ( ) ) ;\n EXPECT_EQ ( \"{\ngoogle:baseURL}\n/alt/#q={\nsearchTerms}\n\" , url_refs [ 1 ] . GetURL ( ) ) ;\n EXPECT_EQ ( \"http://google.com/?q={\nsearchTerms}\n\" , url_refs [ 2 ] . GetURL ( ) ) ;\n }", "idx": 636}
{"hash": -7555034601056330007, "project": "debian", "size": 10, "label": 0, "functionSource": "static int virLogFormatString ( char * * msg , int linenr , const char * funcname , virLogPriority priority , const char * str ) {\n int ret ;\n if ( ( funcname != NULL ) ) {\n ret = virAsprintfQuiet ( msg , \"%llu: %s : %s:%d : %s\\n\" , virThreadSelfID ( ) , virLogPriorityString ( priority ) , funcname , linenr , str ) ;\n }\n else {\n ret = virAsprintfQuiet ( msg , \"%llu: %s : %s\\n\" , virThreadSelfID ( ) , virLogPriorityString ( priority ) , str ) ;\n }\n return ret ;\n }", "idx": 637}
{"hash": -5025430721469043309, "project": "debian", "size": 5, "label": 0, "functionSource": "static void map_doit ( void * a ) {\n struct map_args * args = ( struct map_args * ) a ;\n int type = ( args -> mode == __RTLD_OPENEXEC ) ? lt_executable : lt_library ;\n args -> map = _dl_map_object ( args -> loader , args -> str , type , 0 , args -> mode , LM_ID_BASE ) ;\n }", "idx": 638}
{"hash": 6080147530626246065, "project": "debian", "size": 224, "label": 1, "functionSource": "static inline void vc1_pred_mv_intfr ( VC1Context * v , int n , int dmv_x , int dmv_y , int mvn , int r_x , int r_y , uint8_t * is_intra ) {\n MpegEncContext * s = & v -> s ;\n int xy , wrap , off = 0 ;\n int A [ 2 ] , B [ 2 ] , C [ 2 ] ;\n int px , py ;\n int a_valid = 0 , b_valid = 0 , c_valid = 0 ;\n int field_a , field_b , field_c ;\n int total_valid , num_samefield , num_oppfield ;\n int pos_c , pos_b , n_adj ;\n wrap = s -> b8_stride ;\n xy = s -> block_index [ n ] ;\n if ( s -> mb_intra ) {\n s -> mv [ 0 ] [ n ] [ 0 ] = s -> current_picture . f . motion_val [ 0 ] [ xy ] [ 0 ] = 0 ;\n s -> mv [ 0 ] [ n ] [ 1 ] = s -> current_picture . f . motion_val [ 0 ] [ xy ] [ 1 ] = 0 ;\n s -> current_picture . f . motion_val [ 1 ] [ xy ] [ 0 ] = 0 ;\n s -> current_picture . f . motion_val [ 1 ] [ xy ] [ 1 ] = 0 ;\n if ( mvn == 1 ) {\n s -> current_picture . f . motion_val [ 0 ] [ xy + 1 ] [ 0 ] = 0 ;\n s -> current_picture . f . motion_val [ 0 ] [ xy + 1 ] [ 1 ] = 0 ;\n s -> current_picture . f . motion_val [ 0 ] [ xy + wrap ] [ 0 ] = 0 ;\n s -> current_picture . f . motion_val [ 0 ] [ xy + wrap ] [ 1 ] = 0 ;\n s -> current_picture . f . motion_val [ 0 ] [ xy + wrap + 1 ] [ 0 ] = 0 ;\n s -> current_picture . f . motion_val [ 0 ] [ xy + wrap + 1 ] [ 1 ] = 0 ;\n v -> luma_mv [ s -> mb_x ] [ 0 ] = v -> luma_mv [ s -> mb_x ] [ 1 ] = 0 ;\n s -> current_picture . f . motion_val [ 1 ] [ xy + 1 ] [ 0 ] = 0 ;\n s -> current_picture . f . motion_val [ 1 ] [ xy + 1 ] [ 1 ] = 0 ;\n s -> current_picture . f . motion_val [ 1 ] [ xy + wrap ] [ 0 ] = 0 ;\n s -> current_picture . f . motion_val [ 1 ] [ xy + wrap ] [ 1 ] = 0 ;\n s -> current_picture . f . motion_val [ 1 ] [ xy + wrap + 1 ] [ 0 ] = 0 ;\n s -> current_picture . f . motion_val [ 1 ] [ xy + wrap + 1 ] [ 1 ] = 0 ;\n }\n return ;\n }\n off = ( ( n == 0 ) || ( n == 1 ) ) ? 1 : - 1 ;\n if ( s -> mb_x || ( n == 1 ) || ( n == 3 ) ) {\n if ( ( v -> blk_mv_type [ xy ] ) || ( ! v -> blk_mv_type [ xy ] && ! v -> blk_mv_type [ xy - 1 ] ) ) {\n A [ 0 ] = s -> current_picture . f . motion_val [ 0 ] [ xy - 1 ] [ 0 ] ;\n A [ 1 ] = s -> current_picture . f . motion_val [ 0 ] [ xy - 1 ] [ 1 ] ;\n a_valid = 1 ;\n }\n else {\n A [ 0 ] = ( s -> current_picture . f . motion_val [ 0 ] [ xy - 1 ] [ 0 ] + s -> current_picture . f . motion_val [ 0 ] [ xy - 1 + off * wrap ] [ 0 ] + 1 ) >> 1 ;\n A [ 1 ] = ( s -> current_picture . f . motion_val [ 0 ] [ xy - 1 ] [ 1 ] + s -> current_picture . f . motion_val [ 0 ] [ xy - 1 + off * wrap ] [ 1 ] + 1 ) >> 1 ;\n a_valid = 1 ;\n }\n if ( ! ( n & 1 ) && v -> is_intra [ s -> mb_x - 1 ] ) {\n a_valid = 0 ;\n A [ 0 ] = A [ 1 ] = 0 ;\n }\n }\n else A [ 0 ] = A [ 1 ] = 0 ;\n B [ 0 ] = B [ 1 ] = C [ 0 ] = C [ 1 ] = 0 ;\n if ( n == 0 || n == 1 || v -> blk_mv_type [ xy ] ) {\n if ( ! s -> first_slice_line ) {\n if ( ! v -> is_intra [ s -> mb_x - s -> mb_stride ] ) {\n b_valid = 1 ;\n n_adj = n | 2 ;\n pos_b = s -> block_index [ n_adj ] - 2 * wrap ;\n if ( v -> blk_mv_type [ pos_b ] && v -> blk_mv_type [ xy ] ) {\n n_adj = ( n & 2 ) | ( n & 1 ) ;\n }\n B [ 0 ] = s -> current_picture . f . motion_val [ 0 ] [ s -> block_index [ n_adj ] - 2 * wrap ] [ 0 ] ;\n B [ 1 ] = s -> current_picture . f . motion_val [ 0 ] [ s -> block_index [ n_adj ] - 2 * wrap ] [ 1 ] ;\n if ( v -> blk_mv_type [ pos_b ] && ! v -> blk_mv_type [ xy ] ) {\n B [ 0 ] = ( B [ 0 ] + s -> current_picture . f . motion_val [ 0 ] [ s -> block_index [ n_adj ^ 2 ] - 2 * wrap ] [ 0 ] + 1 ) >> 1 ;\n B [ 1 ] = ( B [ 1 ] + s -> current_picture . f . motion_val [ 0 ] [ s -> block_index [ n_adj ^ 2 ] - 2 * wrap ] [ 1 ] + 1 ) >> 1 ;\n }\n }\n if ( s -> mb_width > 1 ) {\n if ( ! v -> is_intra [ s -> mb_x - s -> mb_stride + 1 ] ) {\n c_valid = 1 ;\n n_adj = 2 ;\n pos_c = s -> block_index [ 2 ] - 2 * wrap + 2 ;\n if ( v -> blk_mv_type [ pos_c ] && v -> blk_mv_type [ xy ] ) {\n n_adj = n & 2 ;\n }\n C [ 0 ] = s -> current_picture . f . motion_val [ 0 ] [ s -> block_index [ n_adj ] - 2 * wrap + 2 ] [ 0 ] ;\n C [ 1 ] = s -> current_picture . f . motion_val [ 0 ] [ s -> block_index [ n_adj ] - 2 * wrap + 2 ] [ 1 ] ;\n if ( v -> blk_mv_type [ pos_c ] && ! v -> blk_mv_type [ xy ] ) {\n C [ 0 ] = ( 1 + C [ 0 ] + ( s -> current_picture . f . motion_val [ 0 ] [ s -> block_index [ n_adj ^ 2 ] - 2 * wrap + 2 ] [ 0 ] ) ) >> 1 ;\n C [ 1 ] = ( 1 + C [ 1 ] + ( s -> current_picture . f . motion_val [ 0 ] [ s -> block_index [ n_adj ^ 2 ] - 2 * wrap + 2 ] [ 1 ] ) ) >> 1 ;\n }\n if ( s -> mb_x == s -> mb_width - 1 ) {\n if ( ! v -> is_intra [ s -> mb_x - s -> mb_stride - 1 ] ) {\n c_valid = 1 ;\n n_adj = 3 ;\n pos_c = s -> block_index [ 3 ] - 2 * wrap - 2 ;\n if ( v -> blk_mv_type [ pos_c ] && v -> blk_mv_type [ xy ] ) {\n n_adj = n | 1 ;\n }\n C [ 0 ] = s -> current_picture . f . motion_val [ 0 ] [ s -> block_index [ n_adj ] - 2 * wrap - 2 ] [ 0 ] ;\n C [ 1 ] = s -> current_picture . f . motion_val [ 0 ] [ s -> block_index [ n_adj ] - 2 * wrap - 2 ] [ 1 ] ;\n if ( v -> blk_mv_type [ pos_c ] && ! v -> blk_mv_type [ xy ] ) {\n C [ 0 ] = ( 1 + C [ 0 ] + s -> current_picture . f . motion_val [ 0 ] [ s -> block_index [ 1 ] - 2 * wrap - 2 ] [ 0 ] ) >> 1 ;\n C [ 1 ] = ( 1 + C [ 1 ] + s -> current_picture . f . motion_val [ 0 ] [ s -> block_index [ 1 ] - 2 * wrap - 2 ] [ 1 ] ) >> 1 ;\n }\n }\n else c_valid = 0 ;\n }\n }\n }\n }\n }\n else {\n pos_b = s -> block_index [ 1 ] ;\n b_valid = 1 ;\n B [ 0 ] = s -> current_picture . f . motion_val [ 0 ] [ pos_b ] [ 0 ] ;\n B [ 1 ] = s -> current_picture . f . motion_val [ 0 ] [ pos_b ] [ 1 ] ;\n pos_c = s -> block_index [ 0 ] ;\n c_valid = 1 ;\n C [ 0 ] = s -> current_picture . f . motion_val [ 0 ] [ pos_c ] [ 0 ] ;\n C [ 1 ] = s -> current_picture . f . motion_val [ 0 ] [ pos_c ] [ 1 ] ;\n }\n total_valid = a_valid + b_valid + c_valid ;\n if ( ! s -> mb_x && ! ( n == 1 || n == 3 ) ) {\n A [ 0 ] = A [ 1 ] = 0 ;\n }\n if ( ( s -> first_slice_line && v -> blk_mv_type [ xy ] ) || ( s -> first_slice_line && ! ( n & 2 ) ) ) {\n B [ 0 ] = B [ 1 ] = C [ 0 ] = C [ 1 ] = 0 ;\n }\n if ( ! v -> blk_mv_type [ xy ] ) {\n if ( s -> mb_width == 1 ) {\n px = B [ 0 ] ;\n py = B [ 1 ] ;\n }\n else {\n if ( total_valid >= 2 ) {\n px = mid_pred ( A [ 0 ] , B [ 0 ] , C [ 0 ] ) ;\n py = mid_pred ( A [ 1 ] , B [ 1 ] , C [ 1 ] ) ;\n }\n else if ( total_valid ) {\n if ( a_valid ) {\n px = A [ 0 ] ;\n py = A [ 1 ] ;\n }\n if ( b_valid ) {\n px = B [ 0 ] ;\n py = B [ 1 ] ;\n }\n if ( c_valid ) {\n px = C [ 0 ] ;\n py = C [ 1 ] ;\n }\n }\n else px = py = 0 ;\n }\n }\n else {\n if ( a_valid ) field_a = ( A [ 1 ] & 4 ) ? 1 : 0 ;\n else field_a = 0 ;\n if ( b_valid ) field_b = ( B [ 1 ] & 4 ) ? 1 : 0 ;\n else field_b = 0 ;\n if ( c_valid ) field_c = ( C [ 1 ] & 4 ) ? 1 : 0 ;\n else field_c = 0 ;\n num_oppfield = field_a + field_b + field_c ;\n num_samefield = total_valid - num_oppfield ;\n if ( total_valid == 3 ) {\n if ( ( num_samefield == 3 ) || ( num_oppfield == 3 ) ) {\n px = mid_pred ( A [ 0 ] , B [ 0 ] , C [ 0 ] ) ;\n py = mid_pred ( A [ 1 ] , B [ 1 ] , C [ 1 ] ) ;\n }\n else if ( num_samefield >= num_oppfield ) {\n px = ! field_a ? A [ 0 ] : B [ 0 ] ;\n py = ! field_a ? A [ 1 ] : B [ 1 ] ;\n }\n else {\n px = field_a ? A [ 0 ] : B [ 0 ] ;\n py = field_a ? A [ 1 ] : B [ 1 ] ;\n }\n }\n else if ( total_valid == 2 ) {\n if ( num_samefield >= num_oppfield ) {\n if ( ! field_a && a_valid ) {\n px = A [ 0 ] ;\n py = A [ 1 ] ;\n }\n else if ( ! field_b && b_valid ) {\n px = B [ 0 ] ;\n py = B [ 1 ] ;\n }\n else if ( c_valid ) {\n px = C [ 0 ] ;\n py = C [ 1 ] ;\n }\n else px = py = 0 ;\n }\n else {\n if ( field_a && a_valid ) {\n px = A [ 0 ] ;\n py = A [ 1 ] ;\n }\n else if ( field_b && b_valid ) {\n px = B [ 0 ] ;\n py = B [ 1 ] ;\n }\n else if ( c_valid ) {\n px = C [ 0 ] ;\n py = C [ 1 ] ;\n }\n }\n }\n else if ( total_valid == 1 ) {\n px = ( a_valid ) ? A [ 0 ] : ( ( b_valid ) ? B [ 0 ] : C [ 0 ] ) ;\n py = ( a_valid ) ? A [ 1 ] : ( ( b_valid ) ? B [ 1 ] : C [ 1 ] ) ;\n }\n else px = py = 0 ;\n }\n s -> mv [ 0 ] [ n ] [ 0 ] = s -> current_picture . f . motion_val [ 0 ] [ xy ] [ 0 ] = ( ( px + dmv_x + r_x ) & ( ( r_x << 1 ) - 1 ) ) - r_x ;\n s -> mv [ 0 ] [ n ] [ 1 ] = s -> current_picture . f . motion_val [ 0 ] [ xy ] [ 1 ] = ( ( py + dmv_y + r_y ) & ( ( r_y << 1 ) - 1 ) ) - r_y ;\n if ( mvn == 1 ) {\n s -> current_picture . f . motion_val [ 0 ] [ xy + 1 ] [ 0 ] = s -> current_picture . f . motion_val [ 0 ] [ xy ] [ 0 ] ;\n s -> current_picture . f . motion_val [ 0 ] [ xy + 1 ] [ 1 ] = s -> current_picture . f . motion_val [ 0 ] [ xy ] [ 1 ] ;\n s -> current_picture . f . motion_val [ 0 ] [ xy + wrap ] [ 0 ] = s -> current_picture . f . motion_val [ 0 ] [ xy ] [ 0 ] ;\n s -> current_picture . f . motion_val [ 0 ] [ xy + wrap ] [ 1 ] = s -> current_picture . f . motion_val [ 0 ] [ xy ] [ 1 ] ;\n s -> current_picture . f . motion_val [ 0 ] [ xy + wrap + 1 ] [ 0 ] = s -> current_picture . f . motion_val [ 0 ] [ xy ] [ 0 ] ;\n s -> current_picture . f . motion_val [ 0 ] [ xy + wrap + 1 ] [ 1 ] = s -> current_picture . f . motion_val [ 0 ] [ xy ] [ 1 ] ;\n }\n else if ( mvn == 2 ) {\n s -> current_picture . f . motion_val [ 0 ] [ xy + 1 ] [ 0 ] = s -> current_picture . f . motion_val [ 0 ] [ xy ] [ 0 ] ;\n s -> current_picture . f . motion_val [ 0 ] [ xy + 1 ] [ 1 ] = s -> current_picture . f . motion_val [ 0 ] [ xy ] [ 1 ] ;\n s -> mv [ 0 ] [ n + 1 ] [ 0 ] = s -> mv [ 0 ] [ n ] [ 0 ] ;\n s -> mv [ 0 ] [ n + 1 ] [ 1 ] = s -> mv [ 0 ] [ n ] [ 1 ] ;\n }\n }", "idx": 639}
{"hash": -192019917869801237, "project": "debian", "size": 22, "label": 0, "functionSource": "static void steamdiscover_dissect_body_authresponse ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , gint offset , gint bytes_left ) {\n gint len ;\n gint64 value ;\n protobuf_desc_t pb = {\n tvb , offset , bytes_left }\n ;\n protobuf_tag_t tag = {\n 0 , 0 , 0 }\n ;\n while ( protobuf_iter_next ( & pb , & tag ) ) {\n switch ( tag . field_number ) {\n case STEAMDISCOVER_FN_AUTHRESPONSE_AUTHRESULT : STEAMDISCOVER_ENSURE_WIRETYPE ( PROTOBUF_WIRETYPE_VARINT ) ;\n value = get_varint64 ( pb . tvb , pb . offset , pb . bytes_left , & len ) ;\n proto_tree_add_uint64 ( tree , hf_steam_ihs_discovery_body_authresponse_authresult , pb . tvb , pb . offset , len , ( guint64 ) value ) ;\n col_add_fstr ( pinfo -> cinfo , COL_INFO , \"%s Result=%\" G_GUINT64_FORMAT \"(%s)\" , hf_steam_ihs_discovery_header_msgtype_strings [ STEAMDISCOVER_MSGTYPE_DEVICEAUTHORIZATIONRESPONSE ] . strptr , ( guint64 ) value , val64_to_str_const ( ( guint64 ) value , hf_steam_ihs_discovery_body_authresponse_authresult_strings , \"Unknown\" ) ) ;\n break ;\n default : len = protobuf_dissect_unknown_field ( & pb , & tag , pinfo , tree , NULL ) ;\n break ;\n }\n protobuf_seek_forward ( & pb , len ) ;\n }\n }", "idx": 640}
{"hash": -5992472514718425579, "project": "debian", "size": 19, "label": 0, "functionSource": "static int lxc_cgroup_create_legacy ( struct cgroup_process_info * base_info , const char * name , pid_t pid ) {\n struct cgroup_process_info * info_ptr ;\n int r ;\n for ( info_ptr = base_info ;\n info_ptr ;\n info_ptr = info_ptr -> next ) {\n if ( ! lxc_string_in_array ( \"ns\" , ( const char * * ) info_ptr -> hierarchy -> subsystems ) ) continue ;\n char * tmp = cgroup_rename_nsgroup ( ( const char * ) info_ptr -> designated_mount_point -> mount_point , info_ptr -> cgroup_path , pid , name ) ;\n if ( ! tmp ) return - 1 ;\n free ( info_ptr -> cgroup_path ) ;\n info_ptr -> cgroup_path = tmp ;\n r = lxc_grow_array ( ( void * * * ) & info_ptr -> created_paths , & info_ptr -> created_paths_capacity , info_ptr -> created_paths_count + 1 , 8 ) ;\n if ( r < 0 ) return - 1 ;\n tmp = strdup ( tmp ) ;\n if ( ! tmp ) return - 1 ;\n info_ptr -> created_paths [ info_ptr -> created_paths_count ++ ] = tmp ;\n }\n return 0 ;\n }", "idx": 641}
{"hash": 155037296040076635, "project": "debian", "size": 3, "label": 0, "functionSource": "hidden_def ( _nss_dns_gethostbyaddr2_r ) enum nss_status _nss_dns_gethostbyaddr_r ( const void * addr , socklen_t len , int af , struct hostent * result , char * buffer , size_t buflen , int * errnop , int * h_errnop ) {\n return _nss_dns_gethostbyaddr2_r ( addr , len , af , result , buffer , buflen , errnop , h_errnop , NULL ) ;\n }", "idx": 642}
{"hash": 5347874611477979643, "project": "chrome", "size": 21, "label": 0, "functionSource": "static void multiple_write_cb ( int fd , short event , void * arg ) {\n struct event * ev = arg ;\n int len ;\n len = 128 ;\n if ( woff + len >= sizeof ( wbuf ) ) len = sizeof ( wbuf ) - woff ;\n len = write ( fd , wbuf + woff , len ) ;\n if ( len == - 1 ) {\n fprintf ( stderr , \"%s: write\\n\" , __func__ ) ;\n if ( usepersist ) event_del ( ev ) ;\n return ;\n }\n woff += len ;\n if ( woff >= sizeof ( wbuf ) ) {\n shutdown ( fd , SHUT_WR ) ;\n if ( usepersist ) event_del ( ev ) ;\n return ;\n }\n if ( ! usepersist ) {\n if ( event_add ( ev , NULL ) == - 1 ) exit ( 1 ) ;\n }\n }", "idx": 643}
{"hash": -2908211205972632000, "project": "debian", "size": 17, "label": 0, "functionSource": "GSList * mainwindows_get_line ( MAIN_WINDOW_REC * rec ) {\n MAIN_WINDOW_REC * win ;\n GSList * list ;\n list = NULL ;\n for ( win = mainwindows_find_left ( rec , FALSE ) ;\n win != NULL ;\n win = mainwindows_find_left ( win , FALSE ) ) {\n list = g_slist_append ( list , win ) ;\n }\n if ( rec != NULL ) list = g_slist_append ( list , rec ) ;\n for ( win = mainwindows_find_right ( rec , FALSE ) ;\n win != NULL ;\n win = mainwindows_find_right ( win , FALSE ) ) {\n list = g_slist_append ( list , win ) ;\n }\n return list ;\n }", "idx": 644}
{"hash": -1055531103257174901, "project": "debian", "size": 5, "label": 0, "functionSource": "static void last_msg_destroy ( GSList * * list , LAST_MSG_REC * rec ) {\n * list = g_slist_remove ( * list , rec ) ;\n g_free ( rec -> nick ) ;\n g_free ( rec ) ;\n }", "idx": 645}
{"hash": 2125998987781803371, "project": "debian", "size": 119, "label": 0, "functionSource": "static block_t * Encode ( encoder_t * p_enc , picture_t * p_pic ) {\n encoder_sys_t * p_sys = p_enc -> p_sys ;\n block_t * p_block , * p_output_chain = NULL ;\n SchroFrame * p_frame ;\n bool b_go = true ;\n if ( ! p_pic ) {\n if ( ! p_sys -> started || p_sys -> b_eos_pulled ) return NULL ;\n if ( ! p_sys -> b_eos_signalled ) {\n p_sys -> b_eos_signalled = 1 ;\n schro_encoder_end_of_stream ( p_sys -> p_schro ) ;\n }\n }\n else {\n p_sys -> p_format -> interlaced = ! p_pic -> b_progressive ;\n p_sys -> p_format -> top_field_first = p_pic -> b_top_field_first ;\n if ( p_sys -> b_auto_field_coding ) schro_encoder_setting_set_double ( p_sys -> p_schro , \"interlaced_coding\" , ! p_pic -> b_progressive ) ;\n }\n if ( ! p_sys -> started ) {\n date_t date ;\n if ( p_pic -> format . i_chroma != p_enc -> fmt_in . i_codec ) {\n char chroma_in [ 5 ] , chroma_out [ 5 ] ;\n vlc_fourcc_to_char ( p_pic -> format . i_chroma , chroma_in ) ;\n chroma_in [ 4 ] = '\\0' ;\n chroma_out [ 4 ] = '\\0' ;\n vlc_fourcc_to_char ( p_enc -> fmt_in . i_codec , chroma_out ) ;\n msg_Warn ( p_enc , \"Resetting chroma from %s to %s\" , chroma_out , chroma_in ) ;\n if ( ! SetEncChromaFormat ( p_enc , p_pic -> format . i_chroma ) ) {\n msg_Err ( p_enc , \"Could not reset chroma format to %s\" , chroma_in ) ;\n return NULL ;\n }\n }\n date_Init ( & date , p_enc -> fmt_in . video . i_frame_rate , p_enc -> fmt_in . video . i_frame_rate_base ) ;\n date_Increment ( & date , 1 ) ;\n p_sys -> i_pts_offset = date_Get ( & date ) ;\n if ( schro_encoder_setting_get_double ( p_sys -> p_schro , \"interlaced_coding\" ) > 0.0 ) {\n date_Set ( & date , 0 ) ;\n date_Increment ( & date , 1 ) ;\n p_sys -> i_field_time = date_Get ( & date ) / 2 ;\n }\n schro_video_format_set_std_signal_range ( p_sys -> p_format , SCHRO_SIGNAL_RANGE_8BIT_VIDEO ) ;\n schro_encoder_set_video_format ( p_sys -> p_schro , p_sys -> p_format ) ;\n schro_encoder_start ( p_sys -> p_schro ) ;\n p_sys -> started = 1 ;\n }\n if ( ! p_sys -> b_eos_signalled ) {\n picture_Hold ( p_pic ) ;\n p_frame = CreateSchroFrameFromInputPic ( p_enc , p_pic ) ;\n if ( ! p_frame ) return NULL ;\n schro_encoder_push_frame ( p_sys -> p_schro , p_frame ) ;\n StorePicturePTS ( p_enc , p_sys -> i_input_picnum , p_pic -> date ) ;\n p_sys -> i_input_picnum ++ ;\n p_block = block_Alloc ( 1 ) ;\n if ( ! p_block ) return NULL ;\n p_block -> i_dts = p_pic -> date - p_sys -> i_pts_offset ;\n block_FifoPut ( p_sys -> p_dts_fifo , p_block ) ;\n p_block = NULL ;\n if ( schro_encoder_setting_get_double ( p_sys -> p_schro , \"interlaced_coding\" ) > 0.0 ) {\n StorePicturePTS ( p_enc , p_sys -> i_input_picnum , p_pic -> date + p_sys -> i_field_time ) ;\n p_sys -> i_input_picnum ++ ;\n p_block = block_Alloc ( 1 ) ;\n if ( ! p_block ) return NULL ;\n p_block -> i_dts = p_pic -> date - p_sys -> i_pts_offset + p_sys -> i_field_time ;\n block_FifoPut ( p_sys -> p_dts_fifo , p_block ) ;\n p_block = NULL ;\n }\n }\n do {\n SchroStateEnum state ;\n state = schro_encoder_wait ( p_sys -> p_schro ) ;\n switch ( state ) {\n case SCHRO_STATE_NEED_FRAME : b_go = false ;\n break ;\n case SCHRO_STATE_AGAIN : break ;\n case SCHRO_STATE_END_OF_STREAM : p_sys -> b_eos_pulled = 1 ;\n b_go = false ;\n break ;\n case SCHRO_STATE_HAVE_BUFFER : {\n SchroBuffer * p_enc_buf ;\n uint32_t u_pic_num ;\n int i_presentation_frame ;\n p_enc_buf = schro_encoder_pull ( p_sys -> p_schro , & i_presentation_frame ) ;\n p_block = block_Alloc ( p_enc_buf -> length ) ;\n if ( ! p_block ) return NULL ;\n memcpy ( p_block -> p_buffer , p_enc_buf -> data , p_enc_buf -> length ) ;\n schro_buffer_unref ( p_enc_buf ) ;\n if ( 0 == p_block -> p_buffer [ 4 ] ) {\n p_block -> i_flags |= BLOCK_FLAG_TYPE_I ;\n if ( ! p_enc -> fmt_out . p_extra ) {\n const uint8_t eos [ ] = {\n 'B' , 'B' , 'C' , 'D' , 0x10 , 0 , 0 , 0 , 13 , 0 , 0 , 0 , 0 }\n ;\n uint32_t len = GetDWBE ( p_block -> p_buffer + 5 ) ;\n if ( len > UINT32_MAX - sizeof ( eos ) ) return NULL ;\n p_enc -> fmt_out . p_extra = malloc ( len + sizeof ( eos ) ) ;\n if ( ! p_enc -> fmt_out . p_extra ) return NULL ;\n memcpy ( p_enc -> fmt_out . p_extra , p_block -> p_buffer , len ) ;\n memcpy ( ( uint8_t * ) p_enc -> fmt_out . p_extra + len , eos , sizeof ( eos ) ) ;\n SetDWBE ( ( uint8_t * ) p_enc -> fmt_out . p_extra + len + sizeof ( eos ) - 4 , len ) ;\n p_enc -> fmt_out . i_extra = len + sizeof ( eos ) ;\n }\n }\n if ( ReadDiracPictureNumber ( & u_pic_num , p_block ) ) {\n block_t * p_dts_block = block_FifoGet ( p_sys -> p_dts_fifo ) ;\n p_block -> i_dts = p_dts_block -> i_dts ;\n p_block -> i_pts = GetPicturePTS ( p_enc , u_pic_num ) ;\n block_Release ( p_dts_block ) ;\n block_ChainAppend ( & p_output_chain , p_block ) ;\n }\n else {\n block_ChainAppend ( & p_output_chain , p_block ) ;\n }\n break ;\n }\n default : break ;\n }\n }\n while ( b_go ) ;\n return p_output_chain ;\n }", "idx": 646}
{"hash": -4810636875286199147, "project": "debian", "size": 71, "label": 0, "functionSource": "static enum fetch_step vbf_stp_error ( struct worker * wrk , struct busyobj * bo ) {\n ssize_t l , ll , o ;\n double now ;\n uint8_t * ptr ;\n struct vsb * synth_body ;\n CHECK_OBJ_NOTNULL ( wrk , WORKER_MAGIC ) ;\n CHECK_OBJ_NOTNULL ( bo , BUSYOBJ_MAGIC ) ;\n CHECK_OBJ_NOTNULL ( bo -> fetch_objcore , OBJCORE_MAGIC ) ;\n AN ( bo -> fetch_objcore -> flags & OC_F_BUSY ) ;\n assert ( bo -> director_state == DIR_S_NULL ) ;\n wrk -> stats -> fetch_failed ++ ;\n now = W_TIM_real ( wrk ) ;\n VSLb_ts_busyobj ( bo , \"Error\" , now ) ;\n if ( bo -> fetch_objcore -> stobj -> stevedore != NULL ) ObjFreeObj ( bo -> wrk , bo -> fetch_objcore ) ;\n HTTP_Setup ( bo -> beresp , bo -> ws , bo -> vsl , SLT_BerespMethod ) ;\n http_PutResponse ( bo -> beresp , \"HTTP/1.1\" , 503 , \"Backend fetch failed\" ) ;\n http_TimeHeader ( bo -> beresp , \"Date: \" , now ) ;\n http_SetHeader ( bo -> beresp , \"Server: Varnish\" ) ;\n bo -> fetch_objcore -> t_origin = now ;\n if ( ! VTAILQ_EMPTY ( & bo -> fetch_objcore -> objhead -> waitinglist ) ) {\n bo -> fetch_objcore -> ttl = 1 ;\n bo -> fetch_objcore -> grace = 5 ;\n bo -> fetch_objcore -> keep = 5 ;\n }\n else {\n bo -> fetch_objcore -> ttl = 0 ;\n bo -> fetch_objcore -> grace = 0 ;\n bo -> fetch_objcore -> keep = 0 ;\n }\n synth_body = VSB_new_auto ( ) ;\n AN ( synth_body ) ;\n VCL_backend_error_method ( bo -> vcl , wrk , NULL , bo , synth_body ) ;\n AZ ( VSB_finish ( synth_body ) ) ;\n if ( wrk -> handling == VCL_RET_ABANDON || wrk -> handling == VCL_RET_FAIL ) {\n VSB_destroy ( & synth_body ) ;\n return ( F_STP_FAIL ) ;\n }\n if ( wrk -> handling == VCL_RET_RETRY ) {\n VSB_destroy ( & synth_body ) ;\n if ( bo -> retries ++ < cache_param -> max_retries ) return ( F_STP_RETRY ) ;\n VSLb ( bo -> vsl , SLT_VCL_Error , \"Too many retries, failing\" ) ;\n return ( F_STP_FAIL ) ;\n }\n assert ( wrk -> handling == VCL_RET_DELIVER ) ;\n bo -> vfc -> bo = bo ;\n bo -> vfc -> wrk = bo -> wrk ;\n bo -> vfc -> oc = bo -> fetch_objcore ;\n bo -> vfc -> http = bo -> beresp ;\n bo -> vfc -> esi_req = bo -> bereq ;\n if ( vbf_beresp2obj ( bo ) ) {\n ( void ) VFP_Error ( bo -> vfc , \"Could not get storage\" ) ;\n VSB_destroy ( & synth_body ) ;\n return ( F_STP_FAIL ) ;\n }\n ll = VSB_len ( synth_body ) ;\n o = 0 ;\n while ( ll > 0 ) {\n l = ll ;\n if ( VFP_GetStorage ( bo -> vfc , & l , & ptr ) != VFP_OK ) break ;\n if ( l > ll ) l = ll ;\n memcpy ( ptr , VSB_data ( synth_body ) + o , l ) ;\n VFP_Extend ( bo -> vfc , l ) ;\n ll -= l ;\n o += l ;\n }\n AZ ( ObjSetU64 ( wrk , bo -> fetch_objcore , OA_LEN , o ) ) ;\n VSB_destroy ( & synth_body ) ;\n HSH_Unbusy ( wrk , bo -> fetch_objcore ) ;\n ObjSetState ( wrk , bo -> fetch_objcore , BOS_FINISHED ) ;\n return ( F_STP_DONE ) ;\n }", "idx": 647}
{"hash": 1245821301839614810, "project": "debian", "size": 3, "label": 0, "functionSource": "static void custom_full_name_skip ( va_list * va ) {\n ( void ) va_arg ( * va , GFile * ) ;\n }", "idx": 648}
{"hash": 4180964683905830761, "project": "debian", "size": 9, "label": 0, "functionSource": "static int selinux_cred_prepare ( struct cred * new , const struct cred * old , gfp_t gfp ) {\n const struct task_security_struct * old_tsec ;\n struct task_security_struct * tsec ;\n old_tsec = old -> security ;\n tsec = kmemdup ( old_tsec , sizeof ( struct task_security_struct ) , gfp ) ;\n if ( ! tsec ) return - ENOMEM ;\n new -> security = tsec ;\n return 0 ;\n }", "idx": 649}
{"hash": 3487452046891662469, "project": "debian", "size": 3, "label": 0, "functionSource": "static inline void qemu_put_be64s ( QEMUFile * f , const uint64_t * pv ) {\n qemu_put_be64 ( f , * pv ) ;\n }", "idx": 650}
{"hash": 7749168290238234888, "project": "debian", "size": 3, "label": 0, "functionSource": "static int test_save_copy ( const char * origname ) {\n return test_copy_to ( origname , TEST_COPY_FILE ) ;\n }", "idx": 651}
{"hash": -5268859819325807498, "project": "debian", "size": 3, "label": 0, "functionSource": "static gboolean lacks_directory_count ( NautilusFile * file ) {\n return ! file -> details -> directory_count_is_up_to_date && nautilus_file_should_show_directory_item_count ( file ) ;\n }", "idx": 652}
{"hash": -6063487367164326236, "project": "debian", "size": 51, "label": 1, "functionSource": "WRITE_CLASS_ENCODER ( AuthCapsInfo ) struct AuthTicket {\n EntityName name ;\n uint64_t global_id ;\n uint64_t auid ;\n utime_t created , renew_after , expires ;\n AuthCapsInfo caps ;\n __u32 flags ;\n AuthTicket ( ) : global_id ( 0 ) , auid ( CEPH_AUTH_UID_DEFAULT ) , flags ( 0 ) {\n }\n void init_timestamps ( utime_t now , double ttl ) {\n created = now ;\n expires = now ;\n expires += ttl ;\n renew_after = now ;\n renew_after += ttl / 2.0 ;\n }\n void encode ( bufferlist & bl ) const {\n __u8 struct_v = 2 ;\n : : encode ( struct_v , bl ) ;\n : : encode ( name , bl ) ;\n : : encode ( global_id , bl ) ;\n : : encode ( auid , bl ) ;\n : : encode ( created , bl ) ;\n : : encode ( expires , bl ) ;\n : : encode ( caps , bl ) ;\n : : encode ( flags , bl ) ;\n }\n void decode ( bufferlist : : iterator & bl ) {\n __u8 struct_v ;\n : : decode ( struct_v , bl ) ;\n : : decode ( name , bl ) ;\n : : decode ( global_id , bl ) ;\n if ( struct_v >= 2 ) : : decode ( auid , bl ) ;\n else auid = CEPH_AUTH_UID_DEFAULT ;\n : : decode ( created , bl ) ;\n : : decode ( expires , bl ) ;\n : : decode ( caps , bl ) ;\n : : decode ( flags , bl ) ;\n }\n }\n ;\n WRITE_CLASS_ENCODER ( AuthTicket ) struct AuthAuthorizer {\n __u32 protocol ;\n bufferlist bl ;\n CryptoKey session_key ;\n explicit AuthAuthorizer ( __u32 p ) : protocol ( p ) {\n }\n virtual ~ AuthAuthorizer ( ) {\n }\n virtual bool verify_reply ( bufferlist : : iterator & reply ) = 0 ;\n }", "idx": 653}
{"hash": -2994308217034422906, "project": "chrome", "size": 7, "label": 0, "functionSource": "MULTIPROCESS_TEST_MAIN ( CrashingChildProcess ) {\n WaitToDie ( ProcessUtilTest : : GetSignalFilePath ( kSignalFileCrash ) . c_str ( ) ) ;\n # if defined ( OS_POSIX ) : : signal ( SIGSEGV , SIG_DFL ) ;\n # endif volatile int * oops = NULL ;\n * oops = 0xDEAD ;\n return 1 ;\n }", "idx": 654}
{"hash": 6302861533225984845, "project": "debian", "size": 10, "label": 0, "functionSource": "static void pxa2xx_i2s_reset ( PXA2xxI2SState * i2s ) {\n i2s -> rx_len = 0 ;\n i2s -> tx_len = 0 ;\n i2s -> fifo_len = 0 ;\n i2s -> clk = 0x1a ;\n i2s -> control [ 0 ] = 0x00 ;\n i2s -> control [ 1 ] = 0x00 ;\n i2s -> status = 0x00 ;\n i2s -> mask = 0x00 ;\n }", "idx": 655}
{"hash": -6435087038712482873, "project": "debian", "size": 9, "label": 0, "functionSource": "static inline int get_qscale ( MpegEncContext * s ) {\n int qscale = get_bits ( & s -> gb , 5 ) ;\n if ( s -> q_scale_type ) {\n return non_linear_qscale [ qscale ] ;\n }\n else {\n return qscale << 1 ;\n }\n }", "idx": 656}
{"hash": 6667142528452941476, "project": "debian", "size": 12, "label": 0, "functionSource": "static void unescape ( FILE * file , char * pos , size_t length ) {\n char * tmp ;\n DBUG_ENTER ( \"unescape\" ) ;\n if ( ! ( tmp = ( char * ) my_malloc ( length * 2 + 1 , MYF ( MY_WME ) ) ) ) die ( EX_MYSQLERR , \"Couldn't allocate memory\" ) ;\n mysql_real_escape_string ( & mysql_connection , tmp , pos , ( ulong ) length ) ;\n fputc ( '\\'' , file ) ;\n fputs ( tmp , file ) ;\n fputc ( '\\'' , file ) ;\n check_io ( file ) ;\n my_free ( tmp ) ;\n DBUG_VOID_RETURN ;\n }", "idx": 657}
{"hash": 1760449185745615462, "project": "debian", "size": 27, "label": 0, "functionSource": "void TSUrlPrint ( TSMBuffer bufp , TSMLoc obj , TSIOBuffer iobufp ) {\n sdk_assert ( sdk_sanity_check_mbuffer ( bufp ) == TS_SUCCESS ) ;\n sdk_assert ( sdk_sanity_check_url_handle ( obj ) == TS_SUCCESS ) ;\n sdk_assert ( sdk_sanity_check_iocore_structure ( iobufp ) == TS_SUCCESS ) ;\n MIOBuffer * b = ( MIOBuffer * ) iobufp ;\n IOBufferBlock * blk ;\n int bufindex ;\n int tmp , dumpoffset ;\n int done ;\n URL u ;\n u . m_heap = ( ( HdrHeapSDKHandle * ) bufp ) -> m_heap ;\n u . m_url_impl = ( URLImpl * ) obj ;\n dumpoffset = 0 ;\n do {\n blk = b -> get_current_block ( ) ;\n if ( ! blk || blk -> write_avail ( ) == 0 ) {\n b -> add_block ( ) ;\n blk = b -> get_current_block ( ) ;\n }\n bufindex = 0 ;\n tmp = dumpoffset ;\n done = u . print ( blk -> end ( ) , blk -> write_avail ( ) , & bufindex , & tmp ) ;\n dumpoffset += bufindex ;\n b -> fill ( bufindex ) ;\n }\n while ( ! done ) ;\n }", "idx": 658}
{"hash": -4136526370773302162, "project": "debian", "size": 9, "label": 0, "functionSource": "void tvb_composite_prepend ( tvbuff_t * tvb , tvbuff_t * member ) {\n struct tvb_composite * composite_tvb = ( struct tvb_composite * ) tvb ;\n tvb_comp_t * composite ;\n DISSECTOR_ASSERT ( tvb && ! tvb -> initialized ) ;\n DISSECTOR_ASSERT ( tvb -> ops == & tvb_composite_ops ) ;\n DISSECTOR_ASSERT ( member -> length ) ;\n composite = & composite_tvb -> composite ;\n composite -> tvbs = g_slist_prepend ( composite -> tvbs , member ) ;\n }", "idx": 659}
{"hash": 7191899184788440065, "project": "debian", "size": 24, "label": 0, "functionSource": "static void print_tab_data ( MYSQL_RES * result ) {\n MYSQL_ROW cur ;\n MYSQL_FIELD * field ;\n ulong * lengths ;\n if ( opt_silent < 2 && column_names ) {\n int first = 0 ;\n while ( ( field = mysql_fetch_field ( result ) ) ) {\n if ( first ++ ) ( void ) tee_fputs ( \"\\t\" , PAGER ) ;\n ( void ) tee_fputs ( field -> name , PAGER ) ;\n }\n ( void ) tee_fputs ( \"\\n\" , PAGER ) ;\n }\n while ( ( cur = mysql_fetch_row ( result ) ) ) {\n lengths = mysql_fetch_lengths ( result ) ;\n safe_put_field ( cur [ 0 ] , lengths [ 0 ] ) ;\n for ( uint off = 1 ;\n off < mysql_num_fields ( result ) ;\n off ++ ) {\n ( void ) tee_fputs ( \"\\t\" , PAGER ) ;\n safe_put_field ( cur [ off ] , lengths [ off ] ) ;\n }\n ( void ) tee_fputs ( \"\\n\" , PAGER ) ;\n }\n }", "idx": 660}
{"hash": -6579823731174944595, "project": "debian", "size": 10, "label": 0, "functionSource": "void * xcalloc ( size_t num , size_t size ) {\n size_t res ;\n if ( check_mul_overflow ( num , size , & res ) ) abort ( ) ;\n void * ptr ;\n ptr = malloc ( res ) ;\n if ( ptr ) {\n memset ( ptr , '\\0' , ( res ) ) ;\n }\n return ptr ;\n }", "idx": 661}
{"hash": 2713698759296604855, "project": "debian", "size": 20, "label": 0, "functionSource": "static void update_noise_reduction ( MpegEncContext * s ) {\n int intra , i ;\n for ( intra = 0 ;\n intra < 2 ;\n intra ++ ) {\n if ( s -> dct_count [ intra ] > ( 1 << 16 ) ) {\n for ( i = 0 ;\n i < 64 ;\n i ++ ) {\n s -> dct_error_sum [ intra ] [ i ] >>= 1 ;\n }\n s -> dct_count [ intra ] >>= 1 ;\n }\n for ( i = 0 ;\n i < 64 ;\n i ++ ) {\n s -> dct_offset [ intra ] [ i ] = ( s -> avctx -> noise_reduction * s -> dct_count [ intra ] + s -> dct_error_sum [ intra ] [ i ] / 2 ) / ( s -> dct_error_sum [ intra ] [ i ] + 1 ) ;\n }\n }\n }", "idx": 662}
{"hash": -6228844445714759206, "project": "debian", "size": 31, "label": 0, "functionSource": "static bool script_support_content ( struct mail_user * user , const char * * content_type , const char * filename ) {\n struct fts_parser_script_user * suser = SCRIPT_USER_CONTEXT ( user ) ;\n const struct content * content ;\n const char * extension ;\n if ( suser == NULL ) {\n suser = p_new ( user -> pool , struct fts_parser_script_user , 1 ) ;\n p_array_init ( & suser -> content , user -> pool , 32 ) ;\n MODULE_CONTEXT_SET ( user , fts_parser_script_user_module , suser ) ;\n }\n if ( array_count ( & suser -> content ) == 0 ) {\n if ( script_contents_read ( user ) < 0 ) return FALSE ;\n }\n if ( strcmp ( * content_type , \"application/octet-stream\" ) == 0 ) {\n if ( filename == NULL ) return FALSE ;\n extension = strrchr ( filename , '.' ) ;\n if ( extension == NULL ) return FALSE ;\n extension = filename + 1 ;\n array_foreach ( & suser -> content , content ) {\n if ( content -> extensions != NULL && str_array_icase_find ( content -> extensions , extension ) ) {\n * content_type = content -> content_type ;\n return TRUE ;\n }\n }\n }\n else {\n array_foreach ( & suser -> content , content ) {\n if ( strcmp ( content -> content_type , * content_type ) == 0 ) return TRUE ;\n }\n }\n return FALSE ;\n }", "idx": 663}
{"hash": -7553540414561818627, "project": "debian", "size": 52, "label": 0, "functionSource": "int test_gf2m_mod ( BIO * bp ) {\n BIGNUM * a , * b [ 2 ] , * c , * d , * e ;\n int i , j , ret = 0 ;\n int p0 [ ] = {\n 163 , 7 , 6 , 3 , 0 , - 1 }\n ;\n int p1 [ ] = {\n 193 , 15 , 0 , - 1 }\n ;\n a = BN_new ( ) ;\n b [ 0 ] = BN_new ( ) ;\n b [ 1 ] = BN_new ( ) ;\n c = BN_new ( ) ;\n d = BN_new ( ) ;\n e = BN_new ( ) ;\n BN_GF2m_arr2poly ( p0 , b [ 0 ] ) ;\n BN_GF2m_arr2poly ( p1 , b [ 1 ] ) ;\n for ( i = 0 ;\n i < num0 ;\n i ++ ) {\n BN_bntest_rand ( a , 1024 , 0 , 0 ) ;\n for ( j = 0 ;\n j < 2 ;\n j ++ ) {\n BN_GF2m_mod ( c , a , b [ j ] ) ;\n # if 0 if ( bp != NULL ) {\n if ( ! results ) {\n BN_print ( bp , a ) ;\n BIO_puts ( bp , \" % \" ) ;\n BN_print ( bp , b [ j ] ) ;\n BIO_puts ( bp , \" - \" ) ;\n BN_print ( bp , c ) ;\n BIO_puts ( bp , \"\\n\" ) ;\n }\n }\n # endif BN_GF2m_add ( d , a , c ) ;\n BN_GF2m_mod ( e , d , b [ j ] ) ;\n if ( ! BN_is_zero ( e ) ) {\n fprintf ( stderr , \"GF(2^m) modulo test failed!\\n\" ) ;\n goto err ;\n }\n }\n }\n ret = 1 ;\n err : BN_free ( a ) ;\n BN_free ( b [ 0 ] ) ;\n BN_free ( b [ 1 ] ) ;\n BN_free ( c ) ;\n BN_free ( d ) ;\n BN_free ( e ) ;\n return ret ;\n }", "idx": 664}
{"hash": -7248963932691286231, "project": "debian", "size": 15, "label": 0, "functionSource": "static int add_server ( struct manager_ctx * manager , struct server * server ) {\n int ret = check_port ( manager , server ) ;\n if ( ret == - 1 ) {\n LOGE ( \"port is not available, please check.\" ) ;\n return - 1 ;\n }\n bool new = false ;\n cork_hash_table_put ( server_table , ( void * ) server -> port , ( void * ) server , & new , NULL , NULL ) ;\n char * cmd = construct_command_line ( manager , server ) ;\n if ( system ( cmd ) == - 1 ) {\n ERROR ( \"add_server_system\" ) ;\n return - 1 ;\n }\n return 0 ;\n }", "idx": 665}
{"hash": 9009378236683657160, "project": "debian", "size": 4, "label": 0, "functionSource": "static void change_identity ( const struct passwd * pw ) {\n if ( setgid ( pw -> pw_gid ) ) err ( EXIT_FAILURE , _ ( \"cannot set group id\" ) ) ;\n if ( setuid ( pw -> pw_uid ) ) err ( EXIT_FAILURE , _ ( \"cannot set user id\" ) ) ;\n }", "idx": 666}
{"hash": 5991533509192663951, "project": "debian", "size": 10, "label": 0, "functionSource": "void mime_header_decoder_delete ( struct mime_header_decoder_data * pd ) {\n if ( pd ) {\n mbfl_convert_filter_delete ( pd -> conv2_filter ) ;\n mbfl_convert_filter_delete ( pd -> conv1_filter ) ;\n mbfl_convert_filter_delete ( pd -> deco_filter ) ;\n mbfl_memory_device_clear ( & pd -> outdev ) ;\n mbfl_memory_device_clear ( & pd -> tmpdev ) ;\n mbfl_free ( ( void * ) pd ) ;\n }\n }", "idx": 667}
{"hash": -3135212895432241239, "project": "debian", "size": 33, "label": 0, "functionSource": "int process_netbios_name ( const guchar * name_ptr , char * name_ret , int name_ret_len ) {\n int i ;\n int name_type = * ( name_ptr + NETBIOS_NAME_LEN - 1 ) ;\n guchar name_char ;\n char * name_ret_orig = name_ret ;\n static const char hex_digits [ 16 ] = {\n '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'a' , 'b' , 'c' , 'd' , 'e' , 'f' }\n ;\n for ( i = 0 ;\n i < NETBIOS_NAME_LEN - 1 ;\n i ++ ) {\n name_char = * name_ptr ++ ;\n if ( name_char >= ' ' && name_char <= '~' ) {\n if ( -- name_ret_len > 0 ) * name_ret ++ = name_char ;\n }\n else {\n if ( -- name_ret_len > 0 ) * name_ret ++ = '<' ;\n if ( -- name_ret_len > 0 ) * name_ret ++ = hex_digits [ ( name_char >> 4 ) ] ;\n if ( -- name_ret_len > 0 ) * name_ret ++ = hex_digits [ ( name_char & 0x0F ) ] ;\n if ( -- name_ret_len > 0 ) * name_ret ++ = '>' ;\n }\n }\n * name_ret = '\\0' ;\n name_ret -- ;\n while ( name_ret >= name_ret_orig ) {\n if ( * name_ret != ' ' ) {\n * ( name_ret + 1 ) = 0 ;\n break ;\n }\n name_ret -- ;\n }\n return name_type ;\n }", "idx": 668}
{"hash": -3053641395158209010, "project": "debian", "size": 10, "label": 0, "functionSource": "static int x ( struct vcache * avc , int afun , struct vrequest * areq , \\ struct afs_pdata * ain , struct afs_pdata * aout , \\ afs_ucred_t * * acred ) DECL_PIOCTL ( PGetFID ) ;\n DECL_PIOCTL ( PSetAcl ) ;\n DECL_PIOCTL ( PStoreBehind ) ;\n DECL_PIOCTL ( PGCPAGs ) ;\n DECL_PIOCTL ( PGetAcl ) ;\n DECL_PIOCTL ( PNoop ) ;\n DECL_PIOCTL ( PBogus ) ;\n DECL_PIOCTL ( PGetFileCell ) ;\n DECL_PIOCTL ( PGetWSCell ) ;\n DECL_PIOCTL ( PGetUserCell )", "idx": 669}
{"hash": -1315695702746584250, "project": "debian", "size": 11, "label": 0, "functionSource": "ptvcursor_t * ptvcursor_new ( proto_tree * tree , tvbuff_t * tvb , gint offset ) {\n ptvcursor_t * ptvc ;\n ptvc = ( ptvcursor_t * ) wmem_alloc ( wmem_packet_scope ( ) , sizeof ( ptvcursor_t ) ) ;\n ptvc -> tree = tree ;\n ptvc -> tvb = tvb ;\n ptvc -> offset = offset ;\n ptvc -> pushed_tree = NULL ;\n ptvc -> pushed_tree_max = 0 ;\n ptvc -> pushed_tree_index = 0 ;\n return ptvc ;\n }", "idx": 670}
{"hash": 8388187431631506723, "project": "debian", "size": 8, "label": 0, "functionSource": "static bool hyperv_runtime_enable_needed ( void * opaque ) {\n X86CPU * cpu = opaque ;\n CPUX86State * env = & cpu -> env ;\n if ( ! cpu -> hyperv_runtime ) {\n return false ;\n }\n return env -> msr_hv_runtime != 0 ;\n }", "idx": 671}
{"hash": 1245821301839614810, "project": "debian", "size": 39, "label": 0, "functionSource": "static void file_deleted_callback ( GFile * file , GError * error , gpointer callback_data ) {\n DeleteData * data = callback_data ;\n CommonJob * job ;\n SourceInfo * source_info ;\n TransferInfo * transfer_info ;\n GFileType file_type ;\n char * primary ;\n char * secondary ;\n char * details = NULL ;\n int response ;\n job = data -> job ;\n source_info = data -> source_info ;\n transfer_info = data -> transfer_info ;\n data -> transfer_info -> num_files ++ ;\n if ( error == NULL ) {\n nautilus_file_changes_queue_file_removed ( file ) ;\n report_delete_progress ( data -> job , data -> source_info , data -> transfer_info ) ;\n return ;\n }\n if ( job_aborted ( job ) || job -> skip_all_error || should_skip_file ( job , file ) || should_skip_readdir_error ( job , file ) ) {\n return ;\n }\n primary = f ( _ ( \"Error while deleting.\" ) ) ;\n file_type = g_file_query_file_type ( file , G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS , job -> cancellable ) ;\n if ( file_type == G_FILE_TYPE_DIRECTORY ) {\n secondary = IS_IO_ERROR ( error , PERMISSION_DENIED ) ? f ( _ ( \"There was an error deleting the folder \u201c%B\u201d.\" ) , file ) : f ( _ ( \"You do not have sufficient permissions to delete the folder \u201c%B\u201d.\" ) , file ) ;\n }\n else {\n secondary = IS_IO_ERROR ( error , PERMISSION_DENIED ) ? f ( _ ( \"There was an error deleting the file \u201c%B\u201d.\" ) , file ) : f ( _ ( \"You do not have sufficient permissions to delete the file \u201c%B\u201d.\" ) , file ) ;\n }\n details = error -> message ;\n response = run_cancel_or_skip_warning ( job , primary , secondary , details , source_info -> num_files , source_info -> num_files - transfer_info -> num_files ) ;\n if ( response == 0 || response == GTK_RESPONSE_DELETE_EVENT ) {\n abort_job ( job ) ;\n }\n else if ( response == 1 ) {\n job -> skip_all_error = TRUE ;\n }\n }", "idx": 672}
{"hash": -1929262071302712016, "project": "debian", "size": 5, "label": 0, "functionSource": "static void * Type_ProfileSequenceDesc_Dup ( struct _cms_typehandler_struct * self , const void * Ptr , cmsUInt32Number n ) {\n return ( void * ) cmsDupProfileSequenceDescription ( ( cmsSEQ * ) Ptr ) ;\n cmsUNUSED_PARAMETER ( n ) ;\n cmsUNUSED_PARAMETER ( self ) ;\n }", "idx": 673}
{"hash": -1929262071302712016, "project": "debian", "size": 16, "label": 0, "functionSource": "static cmsBool Type_UcrBg_Write ( struct _cms_typehandler_struct * self , cmsIOHANDLER * io , void * Ptr , cmsUInt32Number nItems ) {\n cmsUcrBg * Value = ( cmsUcrBg * ) Ptr ;\n cmsUInt32Number TextSize ;\n char * Text ;\n if ( ! _cmsWriteUInt32Number ( io , Value -> Ucr -> nEntries ) ) return FALSE ;\n if ( ! _cmsWriteUInt16Array ( io , Value -> Ucr -> nEntries , Value -> Ucr -> Table16 ) ) return FALSE ;\n if ( ! _cmsWriteUInt32Number ( io , Value -> Bg -> nEntries ) ) return FALSE ;\n if ( ! _cmsWriteUInt16Array ( io , Value -> Bg -> nEntries , Value -> Bg -> Table16 ) ) return FALSE ;\n TextSize = cmsMLUgetASCII ( Value -> Desc , cmsNoLanguage , cmsNoCountry , NULL , 0 ) ;\n Text = ( char * ) _cmsMalloc ( self -> ContextID , TextSize ) ;\n if ( cmsMLUgetASCII ( Value -> Desc , cmsNoLanguage , cmsNoCountry , Text , TextSize ) != TextSize ) return FALSE ;\n if ( ! io -> Write ( io , TextSize , Text ) ) return FALSE ;\n _cmsFree ( self -> ContextID , Text ) ;\n return TRUE ;\n cmsUNUSED_PARAMETER ( nItems ) ;\n }", "idx": 674}
{"hash": -4635544075321012404, "project": "debian", "size": 34, "label": 0, "functionSource": "static CURLcode AddFormData ( struct FormData * * formp , enum formtype type , const void * line , size_t length , curl_off_t * size ) {\n struct FormData * newform = malloc ( sizeof ( struct FormData ) ) ;\n if ( ! newform ) return CURLE_OUT_OF_MEMORY ;\n newform -> next = NULL ;\n if ( type <= FORM_CONTENT ) {\n if ( ! length ) length = strlen ( ( char * ) line ) ;\n newform -> line = malloc ( length + 1 ) ;\n if ( ! newform -> line ) {\n free ( newform ) ;\n return CURLE_OUT_OF_MEMORY ;\n }\n memcpy ( newform -> line , line , length ) ;\n newform -> length = length ;\n newform -> line [ length ] = 0 ;\n }\n else newform -> line = ( char * ) line ;\n newform -> type = type ;\n if ( * formp ) {\n ( * formp ) -> next = newform ;\n * formp = newform ;\n }\n else * formp = newform ;\n if ( size ) {\n if ( type != FORM_FILE ) * size += length ;\n else {\n if ( ! strequal ( \"-\" , newform -> line ) ) {\n struct_stat file ;\n if ( ! stat ( newform -> line , & file ) && ! S_ISDIR ( file . st_mode ) ) * size += filesize ( newform -> line , file ) ;\n else return CURLE_BAD_FUNCTION_ARGUMENT ;\n }\n }\n }\n return CURLE_OK ;\n }", "idx": 675}
{"hash": -4136526370773302162, "project": "debian", "size": 5, "label": 1, "functionSource": "static guint composite_offset ( const tvbuff_t * tvb , const guint counter ) {\n const struct tvb_composite * composite_tvb = ( const struct tvb_composite * ) tvb ;\n const tvbuff_t * member = ( const tvbuff_t * ) composite_tvb -> composite . tvbs -> data ;\n return tvb_offset_from_real_beginning_counter ( member , counter ) ;\n }", "idx": 676}
{"hash": -8933711118846965366, "project": "debian", "size": 3, "label": 0, "functionSource": "static int cirrus_bitblt_videotovideo_patterncopy ( CirrusVGAState * s ) {\n return cirrus_bitblt_common_patterncopy ( s ) ;\n }", "idx": 677}
{"hash": 6323824267898511453, "project": "debian", "size": 65, "label": 0, "functionSource": "static void cmyk_to_rgb ( fz_context * ctx , const fz_colorspace * cs , const float * cmyk , float * rgb ) {\n # ifdef SLOWCMYK float c = cmyk [ 0 ] , m = cmyk [ 1 ] , y = cmyk [ 2 ] , k = cmyk [ 3 ] ;\n float r , g , b , x ;\n float cm = c * m ;\n float c1m = m - cm ;\n float cm1 = c - cm ;\n float c1m1 = 1 - m - cm1 ;\n float c1m1y = c1m1 * y ;\n float c1m1y1 = c1m1 - c1m1y ;\n float c1my = c1m * y ;\n float c1my1 = c1m - c1my ;\n float cm1y = cm1 * y ;\n float cm1y1 = cm1 - cm1y ;\n float cmy = cm * y ;\n float cmy1 = cm - cmy ;\n x = c1m1y1 * k ;\n r = g = b = c1m1y1 - x ;\n r += 0.1373f * x ;\n g += 0.1216f * x ;\n b += 0.1255f * x ;\n x = c1m1y * k ;\n r += 0.1098f * x ;\n g += 0.1020f * x ;\n x = c1m1y - x ;\n r += x ;\n g += 0.9490f * x ;\n x = c1my1 * k ;\n r += 0.1412f * x ;\n x = c1my1 - x ;\n r += 0.9255f * x ;\n b += 0.5490f * x ;\n x = c1my * k ;\n r += 0.1333f * x ;\n x = c1my - x ;\n r += 0.9294f * x ;\n g += 0.1098f * x ;\n b += 0.1412f * x ;\n x = cm1y1 * k ;\n g += 0.0588f * x ;\n b += 0.1412f * x ;\n x = cm1y1 - x ;\n g += 0.6784f * x ;\n b += 0.9373f * x ;\n x = cm1y * k ;\n g += 0.0745f * x ;\n x = cm1y - x ;\n g += 0.6510f * x ;\n b += 0.3137f * x ;\n x = cmy1 * k ;\n b += 0.0078f * x ;\n x = cmy1 - x ;\n r += 0.1804f * x ;\n g += 0.1922f * x ;\n b += 0.5725f * x ;\n x = cmy * ( 1 - k ) ;\n r += 0.2118f * x ;\n g += 0.2119f * x ;\n b += 0.2235f * x ;\n rgb [ 0 ] = fz_clamp ( r , 0 , 1 ) ;\n rgb [ 1 ] = fz_clamp ( g , 0 , 1 ) ;\n rgb [ 2 ] = fz_clamp ( b , 0 , 1 ) ;\n # else rgb [ 0 ] = 1 - fz_min ( 1 , cmyk [ 0 ] + cmyk [ 3 ] ) ;\n rgb [ 1 ] = 1 - fz_min ( 1 , cmyk [ 1 ] + cmyk [ 3 ] ) ;\n rgb [ 2 ] = 1 - fz_min ( 1 , cmyk [ 2 ] + cmyk [ 3 ] ) ;\n # endif }", "idx": 678}
{"hash": 7092216800726729686, "project": "debian", "size": 5, "label": 0, "functionSource": "static int dissect_h245_T_h223_al_type_al1M ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 339 \"../../asn1/h245/h245.cnf\" if ( h223_lc_params_temp ) h223_lc_params_temp -> al_type = al1M ;\n offset = dissect_h245_H223AL1MParameters ( tvb , offset , actx , tree , hf_index ) ;\n return offset ;\n }", "idx": 679}
{"hash": -2928324134072492299, "project": "debian", "size": 16, "label": 0, "functionSource": "static guint change_call_num_graph ( voip_calls_tapinfo_t * tapinfo _U_ , guint16 call_num , guint16 new_call_num ) {\n seq_analysis_item_t * gai ;\n GList * list ;\n guint items_changed ;\n items_changed = 0 ;\n list = g_list_first ( tapinfo -> graph_analysis -> list ) ;\n while ( list ) {\n gai = ( seq_analysis_item_t * ) list -> data ;\n if ( gai -> conv_num == call_num ) {\n gai -> conv_num = new_call_num ;\n items_changed ++ ;\n }\n list = g_list_next ( list ) ;\n }\n return items_changed ;\n }", "idx": 680}
{"hash": 4489017523191997023, "project": "debian", "size": 8, "label": 1, "functionSource": "static int dissect_h225_RequestSeqNum ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 724 \"./asn1/h225/h225.cnf\" h225_packet_info * h225_pi ;\n h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;\n if ( h225_pi != NULL ) {\n offset = dissect_per_constrained_integer ( tvb , offset , actx , tree , hf_index , 1U , 65535U , & ( h225_pi -> requestSeqNum ) , FALSE ) ;\n # line 732 \"./asn1/h225/h225.cnf\" }\n return offset ;\n }", "idx": 681}
{"hash": -2994308217034422906, "project": "chrome", "size": 9, "label": 0, "functionSource": "TEST_F ( ProcessUtilTest , KillSlowChild ) {\n const std : : string signal_file = ProcessUtilTest : : GetSignalFilePath ( kSignalFileSlow ) ;\n remove ( signal_file . c_str ( ) ) ;\n base : : Process process = SpawnChild ( \"SlowChildProcess\" ) ;\n ASSERT_TRUE ( process . IsValid ( ) ) ;\n SignalChildren ( signal_file . c_str ( ) ) ;\n EXPECT_TRUE ( base : : WaitForSingleProcess ( process . Handle ( ) , TestTimeouts : : action_max_timeout ( ) ) ) ;\n remove ( signal_file . c_str ( ) ) ;\n }", "idx": 682}
{"hash": 8461782184979846246, "project": "chrome", "size": 12, "label": 1, "functionSource": "TEST_F ( ProtocolHandlerRegistryTest , TestReplaceRemovesStaleHandlers ) {\n ProtocolHandler ph1 = CreateProtocolHandler ( \"mailto\" , GURL ( \"http://test.com/%s\" ) , \"test1\" ) ;\n ProtocolHandler ph2 = CreateProtocolHandler ( \"mailto\" , GURL ( \"http://test.com/updated-url/%s\" ) , \"test2\" ) ;\n ProtocolHandler ph3 = CreateProtocolHandler ( \"mailto\" , GURL ( \"http://test.com/third/%s\" ) , \"test\" ) ;\n registry ( ) -> OnAcceptRegisterProtocolHandler ( ph1 ) ;\n registry ( ) -> OnAcceptRegisterProtocolHandler ( ph2 ) ;\n ASSERT_TRUE ( registry ( ) -> AttemptReplace ( ph3 ) ) ;\n const ProtocolHandler & handler ( registry ( ) -> GetHandlerFor ( \"mailto\" ) ) ;\n ASSERT_EQ ( handler . url ( ) , ph3 . url ( ) ) ;\n registry ( ) -> RemoveHandler ( ph3 ) ;\n ASSERT_TRUE ( registry ( ) -> GetHandlerFor ( \"mailto\" ) . IsEmpty ( ) ) ;\n }", "idx": 683}
{"hash": 1458662858915721428, "project": "debian", "size": 13, "label": 0, "functionSource": "static inline void * alloc_code_gen_buffer ( void ) {\n int flags = MAP_PRIVATE | MAP_ANONYMOUS ;\n uintptr_t start = 0 ;\n void * buf ;\n # if defined ( __PIE__ ) || defined ( __PIC__ ) # elif defined ( __x86_64__ ) && defined ( MAP_32BIT ) flags |= MAP_32BIT ;\n if ( tcg_ctx . code_gen_buffer_size > 800u * 1024 * 1024 ) {\n tcg_ctx . code_gen_buffer_size = 800u * 1024 * 1024 ;\n }\n # elif defined ( __sparc__ ) start = 0x40000000ul ;\n # elif defined ( __s390x__ ) start = 0x90000000ul ;\n # endif buf = mmap ( ( void * ) start , tcg_ctx . code_gen_buffer_size , PROT_WRITE | PROT_READ | PROT_EXEC , flags , - 1 , 0 ) ;\n return buf == MAP_FAILED ? NULL : buf ;\n }", "idx": 684}
{"hash": 8572106347813672436, "project": "debian", "size": 18, "label": 0, "functionSource": "static int key_notify_policy ( struct xfrm_policy * xp , int dir , const struct km_event * c ) {\n struct sk_buff * out_skb ;\n struct sadb_msg * out_hdr ;\n int err ;\n out_skb = pfkey_xfrm_policy2msg_prep ( xp ) ;\n if ( IS_ERR ( out_skb ) ) return PTR_ERR ( out_skb ) ;\n err = pfkey_xfrm_policy2msg ( out_skb , xp , dir ) ;\n if ( err < 0 ) return err ;\n out_hdr = ( struct sadb_msg * ) out_skb -> data ;\n out_hdr -> sadb_msg_version = PF_KEY_V2 ;\n if ( c -> data . byid && c -> event == XFRM_MSG_DELPOLICY ) out_hdr -> sadb_msg_type = SADB_X_SPDDELETE2 ;\n else out_hdr -> sadb_msg_type = event2poltype ( c -> event ) ;\n out_hdr -> sadb_msg_errno = 0 ;\n out_hdr -> sadb_msg_seq = c -> seq ;\n out_hdr -> sadb_msg_pid = c -> portid ;\n pfkey_broadcast ( out_skb , GFP_ATOMIC , BROADCAST_ALL , NULL , xp_net ( xp ) ) ;\n return 0 ;\n }", "idx": 685}
{"hash": -6580451576689962916, "project": "debian", "size": 4, "label": 0, "functionSource": "static char * ext_t_0_wv_cspc_12 ( tvbuff_t * tvb _U_ , guint32 value , guint32 str_tbl _U_ ) {\n char * str = wmem_strdup_printf ( wmem_packet_scope ( ) , \"Common Value: '%s'\" , val_to_str ( value , vals_wv_csp_12_element_value_tokens , \"<Unknown WV-CSP 1.2 Common Value token 0x%X>\" ) ) ;\n return str ;\n }", "idx": 686}
{"hash": -1743990138967426061, "project": "debian", "size": 37, "label": 1, "functionSource": "int ImagingPcdDecode ( Imaging im , ImagingCodecState state , UINT8 * buf , int bytes ) {\n int x ;\n int chunk ;\n UINT8 * out ;\n UINT8 * ptr ;\n ptr = buf ;\n chunk = 3 * state -> xsize ;\n for ( ;\n ;\n ) {\n if ( bytes < chunk ) return ptr - buf ;\n out = state -> buffer ;\n for ( x = 0 ;\n x < state -> xsize ;\n x ++ ) {\n out [ 0 ] = ptr [ x ] ;\n out [ 1 ] = ptr [ ( x + 4 * state -> xsize ) / 2 ] ;\n out [ 2 ] = ptr [ ( x + 5 * state -> xsize ) / 2 ] ;\n out += 4 ;\n }\n state -> shuffle ( ( UINT8 * ) im -> image [ state -> y ] , state -> buffer , state -> xsize ) ;\n if ( ++ state -> y >= state -> ysize ) return - 1 ;\n out = state -> buffer ;\n for ( x = 0 ;\n x < state -> xsize ;\n x ++ ) {\n out [ 0 ] = ptr [ x + state -> xsize ] ;\n out [ 1 ] = ptr [ ( x + 4 * state -> xsize ) / 2 ] ;\n out [ 2 ] = ptr [ ( x + 5 * state -> xsize ) / 2 ] ;\n out += 4 ;\n }\n state -> shuffle ( ( UINT8 * ) im -> image [ state -> y ] , state -> buffer , state -> xsize ) ;\n if ( ++ state -> y >= state -> ysize ) return - 1 ;\n ptr += chunk ;\n bytes -= chunk ;\n }\n }", "idx": 687}
{"hash": -7553540414561818627, "project": "debian", "size": 34, "label": 0, "functionSource": "int test_lshift1 ( BIO * bp ) {\n BIGNUM * a , * b , * c ;\n int i ;\n a = BN_new ( ) ;\n b = BN_new ( ) ;\n c = BN_new ( ) ;\n BN_bntest_rand ( a , 200 , 0 , 0 ) ;\n a -> neg = rand_neg ( ) ;\n for ( i = 0 ;\n i < num0 ;\n i ++ ) {\n BN_lshift1 ( b , a ) ;\n if ( bp != NULL ) {\n if ( ! results ) {\n BN_print ( bp , a ) ;\n BIO_puts ( bp , \" * 2\" ) ;\n BIO_puts ( bp , \" - \" ) ;\n }\n BN_print ( bp , b ) ;\n BIO_puts ( bp , \"\\n\" ) ;\n }\n BN_add ( c , a , a ) ;\n BN_sub ( a , b , c ) ;\n if ( ! BN_is_zero ( a ) ) {\n fprintf ( stderr , \"Left shift one test failed!\\n\" ) ;\n return 0 ;\n }\n BN_copy ( a , b ) ;\n }\n BN_free ( a ) ;\n BN_free ( b ) ;\n BN_free ( c ) ;\n return ( 1 ) ;\n }", "idx": 688}
{"hash": -755883256379441954, "project": "chrome", "size": 383, "label": 0, "functionSource": "void vp9_ ## type ## _predictor_ ## size ## x ## size ## _c ( uint8_t * dst , ptrdiff_t stride , const uint8_t * above , const uint8_t * left ) {\n type ## _predictor ( dst , stride , size , above , left ) ;\n }\n # if CONFIG_VP9_HIGHBITDEPTH # define intra_pred_high_sized ( type , size ) void vp9_high_ ## type ## _predictor_ ## size ## x ## size ## _c ( uint16_t * dst , ptrdiff_t stride , const uint16_t * above , const uint16_t * left , int bd ) {\n high_ ## type ## _predictor ( dst , stride , size , above , left , bd ) ;\n }\n # define intra_pred_allsizes ( type ) intra_pred_sized ( type , 4 ) intra_pred_sized ( type , 8 ) intra_pred_sized ( type , 16 ) intra_pred_sized ( type , 32 ) intra_pred_high_sized ( type , 4 ) intra_pred_high_sized ( type , 8 ) intra_pred_high_sized ( type , 16 ) intra_pred_high_sized ( type , 32 ) # else # define intra_pred_allsizes ( type ) intra_pred_sized ( type , 4 ) intra_pred_sized ( type , 8 ) intra_pred_sized ( type , 16 ) intra_pred_sized ( type , 32 ) # endif # if CONFIG_VP9_HIGHBITDEPTH static INLINE void high_d207_predictor ( uint16_t * dst , ptrdiff_t stride , int bs , const uint16_t * above , const uint16_t * left , int bd ) {\n int r , c ;\n ( void ) above ;\n ( void ) bd ;\n for ( r = 0 ;\n r < bs - 1 ;\n ++ r ) {\n dst [ r * stride ] = ROUND_POWER_OF_TWO ( left [ r ] + left [ r + 1 ] , 1 ) ;\n }\n dst [ ( bs - 1 ) * stride ] = left [ bs - 1 ] ;\n dst ++ ;\n for ( r = 0 ;\n r < bs - 2 ;\n ++ r ) {\n dst [ r * stride ] = ROUND_POWER_OF_TWO ( left [ r ] + left [ r + 1 ] * 2 + left [ r + 2 ] , 2 ) ;\n }\n dst [ ( bs - 2 ) * stride ] = ROUND_POWER_OF_TWO ( left [ bs - 2 ] + left [ bs - 1 ] * 3 , 2 ) ;\n dst [ ( bs - 1 ) * stride ] = left [ bs - 1 ] ;\n dst ++ ;\n for ( c = 0 ;\n c < bs - 2 ;\n ++ c ) dst [ ( bs - 1 ) * stride + c ] = left [ bs - 1 ] ;\n for ( r = bs - 2 ;\n r >= 0 ;\n -- r ) {\n for ( c = 0 ;\n c < bs - 2 ;\n ++ c ) dst [ r * stride + c ] = dst [ ( r + 1 ) * stride + c - 2 ] ;\n }\n }\n static INLINE void high_d63_predictor ( uint16_t * dst , ptrdiff_t stride , int bs , const uint16_t * above , const uint16_t * left , int bd ) {\n int r , c ;\n ( void ) left ;\n ( void ) bd ;\n for ( r = 0 ;\n r < bs ;\n ++ r ) {\n for ( c = 0 ;\n c < bs ;\n ++ c ) {\n dst [ c ] = r & 1 ? ROUND_POWER_OF_TWO ( above [ r / 2 + c ] + above [ r / 2 + c + 1 ] * 2 + above [ r / 2 + c + 2 ] , 2 ) : ROUND_POWER_OF_TWO ( above [ r / 2 + c ] + above [ r / 2 + c + 1 ] , 1 ) ;\n }\n dst += stride ;\n }\n }\n static INLINE void high_d45_predictor ( uint16_t * dst , ptrdiff_t stride , int bs , const uint16_t * above , const uint16_t * left , int bd ) {\n int r , c ;\n ( void ) left ;\n ( void ) bd ;\n for ( r = 0 ;\n r < bs ;\n ++ r ) {\n for ( c = 0 ;\n c < bs ;\n ++ c ) {\n dst [ c ] = r + c + 2 < bs * 2 ? ROUND_POWER_OF_TWO ( above [ r + c ] + above [ r + c + 1 ] * 2 + above [ r + c + 2 ] , 2 ) : above [ bs * 2 - 1 ] ;\n }\n dst += stride ;\n }\n }\n static INLINE void high_d117_predictor ( uint16_t * dst , ptrdiff_t stride , int bs , const uint16_t * above , const uint16_t * left , int bd ) {\n int r , c ;\n ( void ) bd ;\n for ( c = 0 ;\n c < bs ;\n c ++ ) dst [ c ] = ROUND_POWER_OF_TWO ( above [ c - 1 ] + above [ c ] , 1 ) ;\n dst += stride ;\n dst [ 0 ] = ROUND_POWER_OF_TWO ( left [ 0 ] + above [ - 1 ] * 2 + above [ 0 ] , 2 ) ;\n for ( c = 1 ;\n c < bs ;\n c ++ ) dst [ c ] = ROUND_POWER_OF_TWO ( above [ c - 2 ] + above [ c - 1 ] * 2 + above [ c ] , 2 ) ;\n dst += stride ;\n dst [ 0 ] = ROUND_POWER_OF_TWO ( above [ - 1 ] + left [ 0 ] * 2 + left [ 1 ] , 2 ) ;\n for ( r = 3 ;\n r < bs ;\n ++ r ) dst [ ( r - 2 ) * stride ] = ROUND_POWER_OF_TWO ( left [ r - 3 ] + left [ r - 2 ] * 2 + left [ r - 1 ] , 2 ) ;\n for ( r = 2 ;\n r < bs ;\n ++ r ) {\n for ( c = 1 ;\n c < bs ;\n c ++ ) dst [ c ] = dst [ - 2 * stride + c - 1 ] ;\n dst += stride ;\n }\n }\n static INLINE void high_d135_predictor ( uint16_t * dst , ptrdiff_t stride , int bs , const uint16_t * above , const uint16_t * left , int bd ) {\n int r , c ;\n ( void ) bd ;\n dst [ 0 ] = ROUND_POWER_OF_TWO ( left [ 0 ] + above [ - 1 ] * 2 + above [ 0 ] , 2 ) ;\n for ( c = 1 ;\n c < bs ;\n c ++ ) dst [ c ] = ROUND_POWER_OF_TWO ( above [ c - 2 ] + above [ c - 1 ] * 2 + above [ c ] , 2 ) ;\n dst [ stride ] = ROUND_POWER_OF_TWO ( above [ - 1 ] + left [ 0 ] * 2 + left [ 1 ] , 2 ) ;\n for ( r = 2 ;\n r < bs ;\n ++ r ) dst [ r * stride ] = ROUND_POWER_OF_TWO ( left [ r - 2 ] + left [ r - 1 ] * 2 + left [ r ] , 2 ) ;\n dst += stride ;\n for ( r = 1 ;\n r < bs ;\n ++ r ) {\n for ( c = 1 ;\n c < bs ;\n c ++ ) dst [ c ] = dst [ - stride + c - 1 ] ;\n dst += stride ;\n }\n }\n static INLINE void high_d153_predictor ( uint16_t * dst , ptrdiff_t stride , int bs , const uint16_t * above , const uint16_t * left , int bd ) {\n int r , c ;\n ( void ) bd ;\n dst [ 0 ] = ROUND_POWER_OF_TWO ( above [ - 1 ] + left [ 0 ] , 1 ) ;\n for ( r = 1 ;\n r < bs ;\n r ++ ) dst [ r * stride ] = ROUND_POWER_OF_TWO ( left [ r - 1 ] + left [ r ] , 1 ) ;\n dst ++ ;\n dst [ 0 ] = ROUND_POWER_OF_TWO ( left [ 0 ] + above [ - 1 ] * 2 + above [ 0 ] , 2 ) ;\n dst [ stride ] = ROUND_POWER_OF_TWO ( above [ - 1 ] + left [ 0 ] * 2 + left [ 1 ] , 2 ) ;\n for ( r = 2 ;\n r < bs ;\n r ++ ) dst [ r * stride ] = ROUND_POWER_OF_TWO ( left [ r - 2 ] + left [ r - 1 ] * 2 + left [ r ] , 2 ) ;\n dst ++ ;\n for ( c = 0 ;\n c < bs - 2 ;\n c ++ ) dst [ c ] = ROUND_POWER_OF_TWO ( above [ c - 1 ] + above [ c ] * 2 + above [ c + 1 ] , 2 ) ;\n dst += stride ;\n for ( r = 1 ;\n r < bs ;\n ++ r ) {\n for ( c = 0 ;\n c < bs - 2 ;\n c ++ ) dst [ c ] = dst [ - stride + c - 2 ] ;\n dst += stride ;\n }\n }\n static INLINE void high_v_predictor ( uint16_t * dst , ptrdiff_t stride , int bs , const uint16_t * above , const uint16_t * left , int bd ) {\n int r ;\n ( void ) left ;\n ( void ) bd ;\n for ( r = 0 ;\n r < bs ;\n r ++ ) {\n vpx_memcpy ( dst , above , bs * sizeof ( uint16_t ) ) ;\n dst += stride ;\n }\n }\n static INLINE void high_h_predictor ( uint16_t * dst , ptrdiff_t stride , int bs , const uint16_t * above , const uint16_t * left , int bd ) {\n int r ;\n ( void ) above ;\n ( void ) bd ;\n for ( r = 0 ;\n r < bs ;\n r ++ ) {\n vpx_memset16 ( dst , left [ r ] , bs ) ;\n dst += stride ;\n }\n }\n static INLINE void high_tm_predictor ( uint16_t * dst , ptrdiff_t stride , int bs , const uint16_t * above , const uint16_t * left , int bd ) {\n int r , c ;\n int ytop_left = above [ - 1 ] ;\n ( void ) bd ;\n for ( r = 0 ;\n r < bs ;\n r ++ ) {\n for ( c = 0 ;\n c < bs ;\n c ++ ) dst [ c ] = clip_pixel_high ( left [ r ] + above [ c ] - ytop_left , bd ) ;\n dst += stride ;\n }\n }\n static INLINE void high_dc_128_predictor ( uint16_t * dst , ptrdiff_t stride , int bs , const uint16_t * above , const uint16_t * left , int bd ) {\n int r ;\n ( void ) above ;\n ( void ) left ;\n for ( r = 0 ;\n r < bs ;\n r ++ ) {\n vpx_memset16 ( dst , 128 << ( bd - 8 ) , bs ) ;\n dst += stride ;\n }\n }\n static INLINE void high_dc_left_predictor ( uint16_t * dst , ptrdiff_t stride , int bs , const uint16_t * above , const uint16_t * left , int bd ) {\n int i , r , expected_dc , sum = 0 ;\n ( void ) above ;\n ( void ) bd ;\n for ( i = 0 ;\n i < bs ;\n i ++ ) sum += left [ i ] ;\n expected_dc = ( sum + ( bs >> 1 ) ) / bs ;\n for ( r = 0 ;\n r < bs ;\n r ++ ) {\n vpx_memset16 ( dst , expected_dc , bs ) ;\n dst += stride ;\n }\n }\n static INLINE void high_dc_top_predictor ( uint16_t * dst , ptrdiff_t stride , int bs , const uint16_t * above , const uint16_t * left , int bd ) {\n int i , r , expected_dc , sum = 0 ;\n ( void ) left ;\n ( void ) bd ;\n for ( i = 0 ;\n i < bs ;\n i ++ ) sum += above [ i ] ;\n expected_dc = ( sum + ( bs >> 1 ) ) / bs ;\n for ( r = 0 ;\n r < bs ;\n r ++ ) {\n vpx_memset16 ( dst , expected_dc , bs ) ;\n dst += stride ;\n }\n }\n static INLINE void high_dc_predictor ( uint16_t * dst , ptrdiff_t stride , int bs , const uint16_t * above , const uint16_t * left , int bd ) {\n int i , r , expected_dc , sum = 0 ;\n const int count = 2 * bs ;\n ( void ) bd ;\n for ( i = 0 ;\n i < bs ;\n i ++ ) {\n sum += above [ i ] ;\n sum += left [ i ] ;\n }\n expected_dc = ( sum + ( count >> 1 ) ) / count ;\n for ( r = 0 ;\n r < bs ;\n r ++ ) {\n vpx_memset16 ( dst , expected_dc , bs ) ;\n dst += stride ;\n }\n }\n # endif static INLINE void d207_predictor ( uint8_t * dst , ptrdiff_t stride , int bs , const uint8_t * above , const uint8_t * left ) {\n int r , c ;\n ( void ) above ;\n for ( r = 0 ;\n r < bs - 1 ;\n ++ r ) dst [ r * stride ] = ROUND_POWER_OF_TWO ( left [ r ] + left [ r + 1 ] , 1 ) ;\n dst [ ( bs - 1 ) * stride ] = left [ bs - 1 ] ;\n dst ++ ;\n for ( r = 0 ;\n r < bs - 2 ;\n ++ r ) dst [ r * stride ] = ROUND_POWER_OF_TWO ( left [ r ] + left [ r + 1 ] * 2 + left [ r + 2 ] , 2 ) ;\n dst [ ( bs - 2 ) * stride ] = ROUND_POWER_OF_TWO ( left [ bs - 2 ] + left [ bs - 1 ] * 3 , 2 ) ;\n dst [ ( bs - 1 ) * stride ] = left [ bs - 1 ] ;\n dst ++ ;\n for ( c = 0 ;\n c < bs - 2 ;\n ++ c ) dst [ ( bs - 1 ) * stride + c ] = left [ bs - 1 ] ;\n for ( r = bs - 2 ;\n r >= 0 ;\n -- r ) for ( c = 0 ;\n c < bs - 2 ;\n ++ c ) dst [ r * stride + c ] = dst [ ( r + 1 ) * stride + c - 2 ] ;\n }\n intra_pred_allsizes ( d207 ) static INLINE void d63_predictor ( uint8_t * dst , ptrdiff_t stride , int bs , const uint8_t * above , const uint8_t * left ) {\n int r , c ;\n ( void ) left ;\n for ( r = 0 ;\n r < bs ;\n ++ r ) {\n for ( c = 0 ;\n c < bs ;\n ++ c ) dst [ c ] = r & 1 ? ROUND_POWER_OF_TWO ( above [ r / 2 + c ] + above [ r / 2 + c + 1 ] * 2 + above [ r / 2 + c + 2 ] , 2 ) : ROUND_POWER_OF_TWO ( above [ r / 2 + c ] + above [ r / 2 + c + 1 ] , 1 ) ;\n dst += stride ;\n }\n }\n intra_pred_allsizes ( d63 ) static INLINE void d45_predictor ( uint8_t * dst , ptrdiff_t stride , int bs , const uint8_t * above , const uint8_t * left ) {\n int r , c ;\n ( void ) left ;\n for ( r = 0 ;\n r < bs ;\n ++ r ) {\n for ( c = 0 ;\n c < bs ;\n ++ c ) dst [ c ] = r + c + 2 < bs * 2 ? ROUND_POWER_OF_TWO ( above [ r + c ] + above [ r + c + 1 ] * 2 + above [ r + c + 2 ] , 2 ) : above [ bs * 2 - 1 ] ;\n dst += stride ;\n }\n }\n intra_pred_allsizes ( d45 ) static INLINE void d117_predictor ( uint8_t * dst , ptrdiff_t stride , int bs , const uint8_t * above , const uint8_t * left ) {\n int r , c ;\n for ( c = 0 ;\n c < bs ;\n c ++ ) dst [ c ] = ROUND_POWER_OF_TWO ( above [ c - 1 ] + above [ c ] , 1 ) ;\n dst += stride ;\n dst [ 0 ] = ROUND_POWER_OF_TWO ( left [ 0 ] + above [ - 1 ] * 2 + above [ 0 ] , 2 ) ;\n for ( c = 1 ;\n c < bs ;\n c ++ ) dst [ c ] = ROUND_POWER_OF_TWO ( above [ c - 2 ] + above [ c - 1 ] * 2 + above [ c ] , 2 ) ;\n dst += stride ;\n dst [ 0 ] = ROUND_POWER_OF_TWO ( above [ - 1 ] + left [ 0 ] * 2 + left [ 1 ] , 2 ) ;\n for ( r = 3 ;\n r < bs ;\n ++ r ) dst [ ( r - 2 ) * stride ] = ROUND_POWER_OF_TWO ( left [ r - 3 ] + left [ r - 2 ] * 2 + left [ r - 1 ] , 2 ) ;\n for ( r = 2 ;\n r < bs ;\n ++ r ) {\n for ( c = 1 ;\n c < bs ;\n c ++ ) dst [ c ] = dst [ - 2 * stride + c - 1 ] ;\n dst += stride ;\n }\n }\n intra_pred_allsizes ( d117 ) static INLINE void d135_predictor ( uint8_t * dst , ptrdiff_t stride , int bs , const uint8_t * above , const uint8_t * left ) {\n int r , c ;\n dst [ 0 ] = ROUND_POWER_OF_TWO ( left [ 0 ] + above [ - 1 ] * 2 + above [ 0 ] , 2 ) ;\n for ( c = 1 ;\n c < bs ;\n c ++ ) dst [ c ] = ROUND_POWER_OF_TWO ( above [ c - 2 ] + above [ c - 1 ] * 2 + above [ c ] , 2 ) ;\n dst [ stride ] = ROUND_POWER_OF_TWO ( above [ - 1 ] + left [ 0 ] * 2 + left [ 1 ] , 2 ) ;\n for ( r = 2 ;\n r < bs ;\n ++ r ) dst [ r * stride ] = ROUND_POWER_OF_TWO ( left [ r - 2 ] + left [ r - 1 ] * 2 + left [ r ] , 2 ) ;\n dst += stride ;\n for ( r = 1 ;\n r < bs ;\n ++ r ) {\n for ( c = 1 ;\n c < bs ;\n c ++ ) dst [ c ] = dst [ - stride + c - 1 ] ;\n dst += stride ;\n }\n }\n intra_pred_allsizes ( d135 ) static INLINE void d153_predictor ( uint8_t * dst , ptrdiff_t stride , int bs , const uint8_t * above , const uint8_t * left ) {\n int r , c ;\n dst [ 0 ] = ROUND_POWER_OF_TWO ( above [ - 1 ] + left [ 0 ] , 1 ) ;\n for ( r = 1 ;\n r < bs ;\n r ++ ) dst [ r * stride ] = ROUND_POWER_OF_TWO ( left [ r - 1 ] + left [ r ] , 1 ) ;\n dst ++ ;\n dst [ 0 ] = ROUND_POWER_OF_TWO ( left [ 0 ] + above [ - 1 ] * 2 + above [ 0 ] , 2 ) ;\n dst [ stride ] = ROUND_POWER_OF_TWO ( above [ - 1 ] + left [ 0 ] * 2 + left [ 1 ] , 2 ) ;\n for ( r = 2 ;\n r < bs ;\n r ++ ) dst [ r * stride ] = ROUND_POWER_OF_TWO ( left [ r - 2 ] + left [ r - 1 ] * 2 + left [ r ] , 2 ) ;\n dst ++ ;\n for ( c = 0 ;\n c < bs - 2 ;\n c ++ ) dst [ c ] = ROUND_POWER_OF_TWO ( above [ c - 1 ] + above [ c ] * 2 + above [ c + 1 ] , 2 ) ;\n dst += stride ;\n for ( r = 1 ;\n r < bs ;\n ++ r ) {\n for ( c = 0 ;\n c < bs - 2 ;\n c ++ ) dst [ c ] = dst [ - stride + c - 2 ] ;\n dst += stride ;\n }\n }\n intra_pred_allsizes ( d153 ) static INLINE void v_predictor ( uint8_t * dst , ptrdiff_t stride , int bs , const uint8_t * above , const uint8_t * left ) {\n int r ;\n ( void ) left ;\n for ( r = 0 ;\n r < bs ;\n r ++ ) {\n vpx_memcpy ( dst , above , bs ) ;\n dst += stride ;\n }\n }\n intra_pred_allsizes ( v ) static INLINE void h_predictor ( uint8_t * dst , ptrdiff_t stride , int bs , const uint8_t * above , const uint8_t * left ) {\n int r ;\n ( void ) above ;\n for ( r = 0 ;\n r < bs ;\n r ++ ) {\n vpx_memset ( dst , left [ r ] , bs ) ;\n dst += stride ;\n }\n }\n intra_pred_allsizes ( h ) static INLINE void tm_predictor ( uint8_t * dst , ptrdiff_t stride , int bs , const uint8_t * above , const uint8_t * left ) {\n int r , c ;\n int ytop_left = above [ - 1 ] ;\n for ( r = 0 ;\n r < bs ;\n r ++ ) {\n for ( c = 0 ;\n c < bs ;\n c ++ ) dst [ c ] = clip_pixel ( left [ r ] + above [ c ] - ytop_left ) ;\n dst += stride ;\n }\n }\n intra_pred_allsizes ( tm )", "idx": 689}
{"hash": -3053641395158209010, "project": "debian", "size": 2, "label": 0, "functionSource": "static int x ( struct vcache * avc , int afun , struct vrequest * areq , \\ struct afs_pdata * ain , struct afs_pdata * aout , \\ afs_ucred_t * * acred ) DECL_PIOCTL ( PGetFID ) ;\n DECL_PIOCTL ( PSetAcl )", "idx": 690}
{"hash": -4341894042551388054, "project": "chrome", "size": 48, "label": 0, "functionSource": "static int mv_refs_rt ( const VP9_COMMON * cm , const MACROBLOCKD * xd , const TileInfo * const tile , MODE_INFO * mi , MV_REFERENCE_FRAME ref_frame , int_mv * mv_ref_list , int mi_row , int mi_col ) {\n const int * ref_sign_bias = cm -> ref_frame_sign_bias ;\n int i , refmv_count = 0 ;\n const POSITION * const mv_ref_search = mv_ref_blocks [ mi -> mbmi . sb_type ] ;\n int different_ref_found = 0 ;\n int context_counter = 0 ;\n int const_motion = 0 ;\n vpx_memset ( mv_ref_list , 0 , sizeof ( * mv_ref_list ) * MAX_MV_REF_CANDIDATES ) ;\n for ( i = 0 ;\n i < 2 ;\n ++ i ) {\n const POSITION * const mv_ref = & mv_ref_search [ i ] ;\n if ( is_inside ( tile , mi_col , mi_row , cm -> mi_rows , mv_ref ) ) {\n const MODE_INFO * const candidate_mi = xd -> mi [ mv_ref -> col + mv_ref -> row * xd -> mi_stride ] . src_mi ;\n const MB_MODE_INFO * const candidate = & candidate_mi -> mbmi ;\n context_counter += mode_2_counter [ candidate -> mode ] ;\n different_ref_found = 1 ;\n if ( candidate -> ref_frame [ 0 ] == ref_frame ) ADD_MV_REF_LIST ( get_sub_block_mv ( candidate_mi , 0 , mv_ref -> col , - 1 ) ) ;\n }\n }\n const_motion = 1 ;\n for ( ;\n i < MVREF_NEIGHBOURS && ! refmv_count ;\n ++ i ) {\n const POSITION * const mv_ref = & mv_ref_search [ i ] ;\n if ( is_inside ( tile , mi_col , mi_row , cm -> mi_rows , mv_ref ) ) {\n const MB_MODE_INFO * const candidate = & xd -> mi [ mv_ref -> col + mv_ref -> row * xd -> mi_stride ] . src_mi -> mbmi ;\n different_ref_found = 1 ;\n if ( candidate -> ref_frame [ 0 ] == ref_frame ) ADD_MV_REF_LIST ( candidate -> mv [ 0 ] ) ;\n }\n }\n if ( different_ref_found && ! refmv_count ) {\n for ( i = 0 ;\n i < MVREF_NEIGHBOURS ;\n ++ i ) {\n const POSITION * mv_ref = & mv_ref_search [ i ] ;\n if ( is_inside ( tile , mi_col , mi_row , cm -> mi_rows , mv_ref ) ) {\n const MB_MODE_INFO * const candidate = & xd -> mi [ mv_ref -> col + mv_ref -> row * xd -> mi_stride ] . src_mi -> mbmi ;\n IF_DIFF_REF_FRAME_ADD_MV ( candidate ) ;\n }\n }\n }\n Done : mi -> mbmi . mode_context [ ref_frame ] = counter_to_context [ context_counter ] ;\n for ( i = 0 ;\n i < MAX_MV_REF_CANDIDATES ;\n ++ i ) clamp_mv_ref ( & mv_ref_list [ i ] . as_mv , xd ) ;\n return const_motion ;\n }", "idx": 691}
{"hash": 7324112841603622093, "project": "debian", "size": 12, "label": 0, "functionSource": "int message_search_msg ( struct message_search_context * ctx , struct istream * input , struct message_part * parts , const char * * error_r ) {\n char * error ;\n int ret ;\n T_BEGIN {\n ret = message_search_msg_real ( ctx , input , parts , error_r ) ;\n error = i_strdup ( * error_r ) ;\n }\n T_END ;\n * error_r = t_strdup ( error ) ;\n i_free ( error ) ;\n return ret ;\n }", "idx": 692}
{"hash": 2066486429767443123, "project": "debian", "size": 41, "label": 0, "functionSource": "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n CamtasiaContext * const c = avctx -> priv_data ;\n const unsigned char * encoded = buf ;\n AVFrame * frame = data ;\n int zret ;\n int ret , len = buf_size ;\n if ( ( ret = ff_get_buffer ( avctx , frame , 0 ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n zret = inflateReset ( & c -> zstream ) ;\n if ( zret != Z_OK ) {\n av_log ( avctx , AV_LOG_ERROR , \"Inflate reset error: %d\\n\" , zret ) ;\n return AVERROR_UNKNOWN ;\n }\n c -> zstream . next_in = encoded ;\n c -> zstream . avail_in = len ;\n c -> zstream . next_out = c -> decomp_buf ;\n c -> zstream . avail_out = c -> decomp_size ;\n zret = inflate ( & c -> zstream , Z_FINISH ) ;\n if ( ( zret != Z_OK ) && ( zret != Z_STREAM_END ) && ( zret != Z_DATA_ERROR ) ) {\n av_log ( avctx , AV_LOG_ERROR , \"Inflate error: %d\\n\" , zret ) ;\n return AVERROR_UNKNOWN ;\n }\n if ( zret != Z_DATA_ERROR ) {\n bytestream2_init ( & c -> gb , c -> decomp_buf , c -> decomp_size - c -> zstream . avail_out ) ;\n ff_msrle_decode ( avctx , ( AVPicture * ) frame , c -> bpp , & c -> gb ) ;\n }\n if ( c -> avctx -> pix_fmt == AV_PIX_FMT_PAL8 ) {\n const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;\n if ( pal ) {\n frame -> palette_has_changed = 1 ;\n memcpy ( c -> pal , pal , AVPALETTE_SIZE ) ;\n }\n memcpy ( frame -> data [ 1 ] , c -> pal , AVPALETTE_SIZE ) ;\n }\n * got_frame = 1 ;\n return buf_size ;\n }", "idx": 693}
{"hash": -8263083159286474465, "project": "debian", "size": 31, "label": 0, "functionSource": "static int allocate_buffers ( ShortenContext * s ) {\n int i , chan ;\n int * coeffs ;\n void * tmp_ptr ;\n for ( chan = 0 ;\n chan < s -> channels ;\n chan ++ ) {\n if ( FFMAX ( 1 , s -> nmean ) >= UINT_MAX / sizeof ( int32_t ) ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"nmean too large\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( s -> blocksize + s -> nwrap >= UINT_MAX / sizeof ( int32_t ) || s -> blocksize + s -> nwrap <= ( unsigned ) s -> nwrap ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"s->blocksize + s->nwrap too large\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n tmp_ptr = av_realloc ( s -> offset [ chan ] , sizeof ( int32_t ) * FFMAX ( 1 , s -> nmean ) ) ;\n if ( ! tmp_ptr ) return AVERROR ( ENOMEM ) ;\n s -> offset [ chan ] = tmp_ptr ;\n tmp_ptr = av_realloc ( s -> decoded_base [ chan ] , ( s -> blocksize + s -> nwrap ) * sizeof ( s -> decoded_base [ 0 ] [ 0 ] ) ) ;\n if ( ! tmp_ptr ) return AVERROR ( ENOMEM ) ;\n s -> decoded_base [ chan ] = tmp_ptr ;\n for ( i = 0 ;\n i < s -> nwrap ;\n i ++ ) s -> decoded_base [ chan ] [ i ] = 0 ;\n s -> decoded [ chan ] = s -> decoded_base [ chan ] + s -> nwrap ;\n }\n coeffs = av_realloc ( s -> coeffs , s -> nwrap * sizeof ( * s -> coeffs ) ) ;\n if ( ! coeffs ) return AVERROR ( ENOMEM ) ;\n s -> coeffs = coeffs ;\n return 0 ;\n }", "idx": 694}
{"hash": -1283648210945038844, "project": "chrome", "size": 11, "label": 1, "functionSource": "void vp9_fdct16x16_1_c ( const int16_t * input , int16_t * output , int stride ) {\n int r , c ;\n int16_t sum = 0 ;\n for ( r = 0 ;\n r < 16 ;\n ++ r ) for ( c = 0 ;\n c < 16 ;\n ++ c ) sum += input [ r * stride + c ] ;\n output [ 0 ] = sum >> 1 ;\n output [ 1 ] = 0 ;\n }", "idx": 695}
{"hash": 2419147764757351618, "project": "debian", "size": 20, "label": 0, "functionSource": "VirtIOS390Device * s390_virtio_bus_find_vring ( VirtIOS390Bus * bus , ram_addr_t mem , int * vq_num ) {\n VirtIOS390Device * _dev ;\n DeviceState * dev ;\n int i ;\n QLIST_FOREACH ( dev , & bus -> bus . children , sibling ) {\n _dev = ( VirtIOS390Device * ) dev ;\n for ( i = 0 ;\n i < VIRTIO_PCI_QUEUE_MAX ;\n i ++ ) {\n if ( ! virtio_queue_get_addr ( _dev -> vdev , i ) ) break ;\n if ( virtio_queue_get_addr ( _dev -> vdev , i ) == mem ) {\n if ( vq_num ) {\n * vq_num = i ;\n }\n return _dev ;\n }\n }\n }\n return NULL ;\n }", "idx": 696}
{"hash": 2542574915000171973, "project": "chrome", "size": 3, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( VirtualKeyboardBrowserTest , DISABLED_AttributesTest ) {\n RunTest ( base : : FilePath ( FILE_PATH_LITERAL ( \"attributes_test.js\" ) ) ) ;\n }", "idx": 697}
{"hash": 1760449185745615462, "project": "debian", "size": 13, "label": 0, "functionSource": "void TSVConnShutdown ( TSVConn connp , int read , int write ) {\n sdk_assert ( sdk_sanity_check_iocore_structure ( connp ) == TS_SUCCESS ) ;\n VConnection * vc = ( VConnection * ) connp ;\n if ( read && write ) {\n vc -> do_io_shutdown ( IO_SHUTDOWN_READWRITE ) ;\n }\n else if ( read ) {\n vc -> do_io_shutdown ( IO_SHUTDOWN_READ ) ;\n }\n else if ( write ) {\n vc -> do_io_shutdown ( IO_SHUTDOWN_WRITE ) ;\n }\n }", "idx": 698}
{"hash": -2423144171479606949, "project": "debian", "size": 7, "label": 0, "functionSource": "static void pdf_run_gs_UseBlackPtComp ( fz_context * ctx , pdf_processor * proc , pdf_obj * obj ) {\n pdf_run_processor * pr = ( pdf_run_processor * ) proc ;\n pdf_gstate * gstate = pdf_flush_text ( ctx , pr ) ;\n int on = pdf_name_eq ( ctx , obj , PDF_NAME_ON ) ;\n gstate -> stroke . color_params . bp = on ;\n gstate -> fill . color_params . bp = on ;\n }", "idx": 699}
{"hash": -6552851419396579257, "project": "debian", "size": 20, "label": 0, "functionSource": "static int SpoolssGetPrinterDataEx_q ( tvbuff_t * tvb , int offset , packet_info * pinfo , proto_tree * tree , dcerpc_info * di , guint8 * drep _U_ ) {\n dcerpc_call_value * dcv = ( dcerpc_call_value * ) di -> call_data ;\n char * key_name , * value_name ;\n proto_item * hidden_item ;\n hidden_item = proto_tree_add_uint ( tree , hf_printerdata , tvb , offset , 0 , 1 ) ;\n PROTO_ITEM_SET_HIDDEN ( hidden_item ) ;\n offset = dissect_nt_policy_hnd ( tvb , offset , pinfo , tree , di , drep , hf_hnd , NULL , NULL , FALSE , FALSE ) ;\n key_name = NULL ;\n offset = dissect_ndr_cvstring ( tvb , offset , pinfo , tree , di , drep , sizeof ( guint16 ) , hf_printerdata_key , TRUE , & key_name ) ;\n value_name = NULL ;\n offset = dissect_ndr_cvstring ( tvb , offset , pinfo , tree , di , drep , sizeof ( guint16 ) , hf_printerdata_value , TRUE , & value_name ) ;\n if ( ! pinfo -> fd -> flags . visited ) {\n if ( ! dcv -> se_data ) {\n dcv -> se_data = wmem_strdup_printf ( wmem_file_scope ( ) , \"%s==%s\" , key_name ? key_name : \"\" , value_name ? value_name : \"\" ) ;\n }\n }\n if ( dcv -> se_data ) col_append_fstr ( pinfo -> cinfo , COL_INFO , \", %s\" , ( char * ) dcv -> se_data ) ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , tree , di , drep , hf_needed , NULL ) ;\n return offset ;\n }", "idx": 700}
{"hash": 8953904005695962093, "project": "debian", "size": 68, "label": 1, "functionSource": "static int xan_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int ret , buf_size = avpkt -> size ;\n XanContext * s = avctx -> priv_data ;\n GetByteContext ctx ;\n int tag = 0 ;\n bytestream2_init ( & ctx , buf , buf_size ) ;\n while ( bytestream2_get_bytes_left ( & ctx ) > 8 && tag != VGA__TAG ) {\n unsigned * tmpptr ;\n uint32_t new_pal ;\n int size ;\n int i ;\n tag = bytestream2_get_le32 ( & ctx ) ;\n size = bytestream2_get_be32 ( & ctx ) ;\n size = FFMIN ( size , bytestream2_get_bytes_left ( & ctx ) ) ;\n switch ( tag ) {\n case PALT_TAG : if ( size < PALETTE_SIZE ) return AVERROR_INVALIDDATA ;\n if ( s -> palettes_count >= PALETTES_MAX ) return AVERROR_INVALIDDATA ;\n tmpptr = av_realloc ( s -> palettes , ( s -> palettes_count + 1 ) * AVPALETTE_SIZE ) ;\n if ( ! tmpptr ) return AVERROR ( ENOMEM ) ;\n s -> palettes = tmpptr ;\n tmpptr += s -> palettes_count * AVPALETTE_COUNT ;\n for ( i = 0 ;\n i < PALETTE_COUNT ;\n i ++ ) {\n # if RUNTIME_GAMMA int r = gamma_corr ( bytestream2_get_byteu ( & ctx ) ) ;\n int g = gamma_corr ( bytestream2_get_byteu ( & ctx ) ) ;\n int b = gamma_corr ( bytestream2_get_byteu ( & ctx ) ) ;\n # else int r = gamma_lookup [ bytestream2_get_byteu ( & ctx ) ] ;\n int g = gamma_lookup [ bytestream2_get_byteu ( & ctx ) ] ;\n int b = gamma_lookup [ bytestream2_get_byteu ( & ctx ) ] ;\n # endif * tmpptr ++ = ( r << 16 ) | ( g << 8 ) | b ;\n }\n s -> palettes_count ++ ;\n break ;\n case SHOT_TAG : if ( size < 4 ) return AVERROR_INVALIDDATA ;\n new_pal = bytestream2_get_le32 ( & ctx ) ;\n if ( new_pal < s -> palettes_count ) {\n s -> cur_palette = new_pal ;\n }\n else av_log ( avctx , AV_LOG_ERROR , \"Invalid palette selected\\n\" ) ;\n break ;\n case VGA__TAG : break ;\n default : bytestream2_skip ( & ctx , size ) ;\n break ;\n }\n }\n buf_size = bytestream2_get_bytes_left ( & ctx ) ;\n if ( s -> palettes_count <= 0 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"No palette found\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( ( ret = ff_get_buffer ( avctx , & s -> current_frame ) ) ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n s -> current_frame . reference = 3 ;\n if ( ! s -> frame_size ) s -> frame_size = s -> current_frame . linesize [ 0 ] * s -> avctx -> height ;\n memcpy ( s -> current_frame . data [ 1 ] , s -> palettes + s -> cur_palette * AVPALETTE_COUNT , AVPALETTE_SIZE ) ;\n s -> buf = ctx . buffer ;\n s -> size = buf_size ;\n if ( xan_wc3_decode_frame ( s ) < 0 ) return AVERROR_INVALIDDATA ;\n if ( s -> last_frame . data [ 0 ] ) avctx -> release_buffer ( avctx , & s -> last_frame ) ;\n * got_frame = 1 ;\n * ( AVFrame * ) data = s -> current_frame ;\n FFSWAP ( AVFrame , s -> current_frame , s -> last_frame ) ;\n return buf_size ;\n }", "idx": 701}
{"hash": 4489017523191997023, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h225_SEQUENCE_OF_ConferenceList ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence_of ( tvb , offset , actx , tree , hf_index , ett_h225_SEQUENCE_OF_ConferenceList , SEQUENCE_OF_ConferenceList_sequence_of ) ;\n return offset ;\n }", "idx": 702}
{"hash": -5280794106681745199, "project": "debian", "size": 20, "label": 0, "functionSource": "static void gst_asf_demux_reset_stream_state_after_discont ( GstASFDemux * demux ) {\n guint n ;\n gst_adapter_clear ( demux -> adapter ) ;\n GST_DEBUG_OBJECT ( demux , \"reset stream state\" ) ;\n gst_flow_combiner_reset ( demux -> flowcombiner ) ;\n for ( n = 0 ;\n n < demux -> num_streams ;\n n ++ ) {\n demux -> stream [ n ] . discont = TRUE ;\n demux -> stream [ n ] . first_buffer = TRUE ;\n while ( demux -> stream [ n ] . payloads -> len > 0 ) {\n AsfPayload * payload ;\n guint last ;\n last = demux -> stream [ n ] . payloads -> len - 1 ;\n payload = & g_array_index ( demux -> stream [ n ] . payloads , AsfPayload , last ) ;\n gst_buffer_replace ( & payload -> buf , NULL ) ;\n g_array_remove_index ( demux -> stream [ n ] . payloads , last ) ;\n }\n }\n }", "idx": 703}
{"hash": -483869641057106085, "project": "debian", "size": 85, "label": 0, "functionSource": "extern int as_mysql_step_complete ( mysql_conn_t * mysql_conn , struct step_record * step_ptr ) {\n time_t now ;\n uint16_t comp_status ;\n int tasks = 0 ;\n struct jobacctinfo * jobacct = ( struct jobacctinfo * ) step_ptr -> jobacct ;\n char * query = NULL ;\n int rc = SLURM_SUCCESS ;\n uint32_t exit_code = 0 ;\n time_t submit_time ;\n if ( ! step_ptr -> job_ptr -> db_index && ( ( ! step_ptr -> job_ptr -> details || ! step_ptr -> job_ptr -> details -> submit_time ) && ! step_ptr -> job_ptr -> resize_time ) ) {\n error ( \"as_mysql_step_complete: \" \"Not inputing this job, it has no submit time.\" ) ;\n return SLURM_ERROR ;\n }\n if ( step_ptr -> job_ptr -> resize_time ) submit_time = step_ptr -> job_ptr -> resize_time ;\n else submit_time = step_ptr -> job_ptr -> details -> submit_time ;\n if ( check_connection ( mysql_conn ) != SLURM_SUCCESS ) return ESLURM_DB_CONNECTION ;\n if ( slurmdbd_conf ) {\n now = step_ptr -> job_ptr -> end_time ;\n if ( step_ptr -> job_ptr -> details ) tasks = step_ptr -> job_ptr -> details -> num_tasks ;\n else tasks = step_ptr -> cpu_count ;\n }\n else if ( step_ptr -> step_id == SLURM_BATCH_SCRIPT ) {\n now = time ( NULL ) ;\n tasks = 1 ;\n }\n else {\n now = time ( NULL ) ;\n if ( ! step_ptr -> step_layout || ! step_ptr -> step_layout -> task_cnt ) {\n if ( step_ptr -> cpu_count ) tasks = step_ptr -> cpu_count ;\n else {\n if ( ( tasks = slurmdb_find_tres_count_in_string ( step_ptr -> tres_alloc_str , TRES_CPU ) ) == INFINITE64 ) {\n if ( ( tasks = slurmdb_find_tres_count_in_string ( step_ptr -> job_ptr -> tres_alloc_str , TRES_CPU ) ) == INFINITE64 ) tasks = step_ptr -> job_ptr -> total_nodes ;\n }\n }\n }\n else tasks = step_ptr -> step_layout -> task_cnt ;\n }\n exit_code = step_ptr -> exit_code ;\n comp_status = step_ptr -> state & JOB_STATE_BASE ;\n if ( comp_status < JOB_COMPLETE ) {\n if ( WIFSIGNALED ( exit_code ) ) {\n comp_status = JOB_CANCELLED ;\n }\n else if ( exit_code ) comp_status = JOB_FAILED ;\n else {\n step_ptr -> requid = - 1 ;\n comp_status = JOB_COMPLETE ;\n }\n }\n if ( ! step_ptr -> job_ptr -> db_index ) {\n if ( ! ( step_ptr -> job_ptr -> db_index = _get_db_index ( mysql_conn , submit_time , step_ptr -> job_ptr -> job_id , step_ptr -> job_ptr -> assoc_id ) ) ) {\n if ( as_mysql_job_start ( mysql_conn , step_ptr -> job_ptr ) == SLURM_ERROR ) {\n error ( \"couldn't add job %u \" \"at step completion\" , step_ptr -> job_ptr -> job_id ) ;\n return SLURM_SUCCESS ;\n }\n }\n }\n query = xstrdup_printf ( \"update \\\"%s_%s\\\" set time_end=%d, state=%u, \" \"kill_requid=%d, exit_code=%d\" , mysql_conn -> cluster_name , step_table , ( int ) now , comp_status , step_ptr -> requid , exit_code ) ;\n if ( jobacct ) {\n double ave_vsize = NO_VAL , ave_rss = NO_VAL , ave_pages = NO_VAL ;\n double ave_disk_read = ( double ) NO_VAL ;\n double ave_disk_write = ( double ) NO_VAL ;\n double ave_cpu = ( double ) NO_VAL ;\n if ( tasks > 0 ) {\n ave_vsize = ( double ) jobacct -> tot_vsize ;\n ave_vsize /= ( double ) tasks ;\n ave_rss = ( double ) jobacct -> tot_rss ;\n ave_rss /= ( double ) tasks ;\n ave_pages = ( double ) jobacct -> tot_pages ;\n ave_pages /= ( double ) tasks ;\n ave_cpu = ( double ) jobacct -> tot_cpu ;\n ave_cpu /= ( double ) tasks ;\n ave_disk_read = ( double ) jobacct -> tot_disk_read ;\n ave_disk_read /= ( double ) tasks ;\n ave_disk_write = ( double ) jobacct -> tot_disk_write ;\n ave_disk_write /= ( double ) tasks ;\n }\n xstrfmtcat ( query , \", user_sec=%u, user_usec=%u, \" \"sys_sec=%u, sys_usec=%u, \" \"max_disk_read=%f, max_disk_read_task=%u, \" \"max_disk_read_node=%u, ave_disk_read=%f, \" \"max_disk_write=%f, max_disk_write_task=%u, \" \"max_disk_write_node=%u, ave_disk_write=%f, \" \"max_vsize=%\" PRIu64 \", max_vsize_task=%u, \" \"max_vsize_node=%u, ave_vsize=%f, \" \"max_rss=%\" PRIu64 \", max_rss_task=%u, \" \"max_rss_node=%u, ave_rss=%f, \" \"max_pages=%\" PRIu64 \", max_pages_task=%u, \" \"max_pages_node=%u, ave_pages=%f, \" \"min_cpu=%u, min_cpu_task=%u, \" \"min_cpu_node=%u, ave_cpu=%f, \" \"act_cpufreq=%u, consumed_energy=%\" PRIu64 \"\" , jobacct -> user_cpu_sec , jobacct -> user_cpu_usec , jobacct -> sys_cpu_sec , jobacct -> sys_cpu_usec , jobacct -> max_disk_read , jobacct -> max_disk_read_id . taskid , jobacct -> max_disk_read_id . nodeid , ave_disk_read , jobacct -> max_disk_write , jobacct -> max_disk_write_id . taskid , jobacct -> max_disk_write_id . nodeid , ave_disk_write , jobacct -> max_vsize , jobacct -> max_vsize_id . taskid , jobacct -> max_vsize_id . nodeid , ave_vsize , jobacct -> max_rss , jobacct -> max_rss_id . taskid , jobacct -> max_rss_id . nodeid , ave_rss , jobacct -> max_pages , jobacct -> max_pages_id . taskid , jobacct -> max_pages_id . nodeid , ave_pages , jobacct -> min_cpu , jobacct -> min_cpu_id . taskid , jobacct -> min_cpu_id . nodeid , ave_cpu , jobacct -> act_cpufreq , jobacct -> energy . consumed_energy ) ;\n }\n xstrfmtcat ( query , \" where job_db_inx=%\" PRIu64 \" and id_step=%d\" , step_ptr -> job_ptr -> db_index , step_ptr -> step_id ) ;\n if ( debug_flags & DEBUG_FLAG_DB_STEP ) DB_DEBUG ( mysql_conn -> conn , \"query\\n%s\" , query ) ;\n rc = mysql_db_query ( mysql_conn , query ) ;\n xfree ( query ) ;\n return rc ;\n }", "idx": 704}
{"hash": 8445816931248660591, "project": "debian", "size": 38, "label": 0, "functionSource": "SPL_METHOD ( SplDoublyLinkedList , add ) {\n zval * zindex , * value ;\n spl_dllist_object * intern ;\n spl_ptr_llist_element * element ;\n long index ;\n if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , \"zz\" , & zindex , & value ) == FAILURE ) {\n return ;\n }\n intern = ( spl_dllist_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n index = spl_offset_convert_to_long ( zindex TSRMLS_CC ) ;\n if ( index < 0 || index > intern -> llist -> count ) {\n zend_throw_exception ( spl_ce_OutOfRangeException , \"Offset invalid or out of range\" , 0 TSRMLS_CC ) ;\n return ;\n }\n Z_ADDREF_P ( value ) ;\n if ( index == intern -> llist -> count ) {\n spl_ptr_llist_push ( intern -> llist , value TSRMLS_CC ) ;\n }\n else {\n spl_ptr_llist_element * elem = emalloc ( sizeof ( spl_ptr_llist_element ) ) ;\n element = spl_ptr_llist_offset ( intern -> llist , index , intern -> flags & SPL_DLLIST_IT_LIFO ) ;\n elem -> data = value ;\n elem -> rc = 1 ;\n elem -> next = element ;\n elem -> prev = element -> prev ;\n if ( elem -> prev == NULL ) {\n intern -> llist -> head = elem ;\n }\n else {\n element -> prev -> next = elem ;\n }\n element -> prev = elem ;\n intern -> llist -> count ++ ;\n if ( intern -> llist -> ctor ) {\n intern -> llist -> ctor ( elem TSRMLS_CC ) ;\n }\n }\n }", "idx": 705}
{"hash": 5610242550647094255, "project": "debian", "size": 25, "label": 0, "functionSource": "static int vaapi_h264_decode_slice ( AVCodecContext * avctx , const uint8_t * buffer , uint32_t size ) {\n H264Context * const h = avctx -> priv_data ;\n VASliceParameterBufferH264 * slice_param ;\n av_dlog ( avctx , \"vaapi_h264_decode_slice(): buffer %p, size %d\\n\" , buffer , size ) ;\n slice_param = ( VASliceParameterBufferH264 * ) ff_vaapi_alloc_slice ( avctx -> hwaccel_context , buffer , size ) ;\n if ( ! slice_param ) return - 1 ;\n slice_param -> slice_data_bit_offset = get_bits_count ( & h -> gb ) + 8 ;\n slice_param -> first_mb_in_slice = ( h -> mb_y >> FIELD_OR_MBAFF_PICTURE ) * h -> mb_width + h -> mb_x ;\n slice_param -> slice_type = ff_h264_get_slice_type ( h ) ;\n slice_param -> direct_spatial_mv_pred_flag = h -> slice_type == AV_PICTURE_TYPE_B ? h -> direct_spatial_mv_pred : 0 ;\n slice_param -> num_ref_idx_l0_active_minus1 = h -> list_count > 0 ? h -> ref_count [ 0 ] - 1 : 0 ;\n slice_param -> num_ref_idx_l1_active_minus1 = h -> list_count > 1 ? h -> ref_count [ 1 ] - 1 : 0 ;\n slice_param -> cabac_init_idc = h -> cabac_init_idc ;\n slice_param -> slice_qp_delta = h -> qscale - h -> pps . init_qp ;\n slice_param -> disable_deblocking_filter_idc = h -> deblocking_filter < 2 ? ! h -> deblocking_filter : h -> deblocking_filter ;\n slice_param -> slice_alpha_c0_offset_div2 = h -> slice_alpha_c0_offset / 2 - 26 ;\n slice_param -> slice_beta_offset_div2 = h -> slice_beta_offset / 2 - 26 ;\n slice_param -> luma_log2_weight_denom = h -> luma_log2_weight_denom ;\n slice_param -> chroma_log2_weight_denom = h -> chroma_log2_weight_denom ;\n fill_vaapi_RefPicList ( slice_param -> RefPicList0 , h -> ref_list [ 0 ] , h -> list_count > 0 ? h -> ref_count [ 0 ] : 0 ) ;\n fill_vaapi_RefPicList ( slice_param -> RefPicList1 , h -> ref_list [ 1 ] , h -> list_count > 1 ? h -> ref_count [ 1 ] : 0 ) ;\n fill_vaapi_plain_pred_weight_table ( h , 0 , & slice_param -> luma_weight_l0_flag , slice_param -> luma_weight_l0 , slice_param -> luma_offset_l0 , & slice_param -> chroma_weight_l0_flag , slice_param -> chroma_weight_l0 , slice_param -> chroma_offset_l0 ) ;\n fill_vaapi_plain_pred_weight_table ( h , 1 , & slice_param -> luma_weight_l1_flag , slice_param -> luma_weight_l1 , slice_param -> luma_offset_l1 , & slice_param -> chroma_weight_l1_flag , slice_param -> chroma_weight_l1 , slice_param -> chroma_offset_l1 ) ;\n return 0 ;\n }", "idx": 706}
{"hash": -7187272991279783781, "project": "debian", "size": 8, "label": 0, "functionSource": "static int idreg_init1 ( SysBusDevice * dev ) {\n IDRegState * s = FROM_SYSBUS ( IDRegState , dev ) ;\n memory_region_init_ram ( & s -> mem , OBJECT ( s ) , \"sun4m.idreg\" , sizeof ( idreg_data ) ) ;\n vmstate_register_ram_global ( & s -> mem ) ;\n memory_region_set_readonly ( & s -> mem , true ) ;\n sysbus_init_mmio ( dev , & s -> mem ) ;\n return 0 ;\n }", "idx": 707}
{"hash": 3584320764213684062, "project": "debian", "size": 50, "label": 0, "functionSource": "static int parse_rType ( tvbuff_t * tvb , int offset , proto_tree * tree , enum rType * rtype , const char * * str ) {\n const char * txt = NULL ;\n guint32 type = tvb_get_letohl ( tvb , offset ) ;\n switch ( type ) {\n case RTNone : * rtype = RTNone ;\n break ;\n case RTAnd : * rtype = RTAnd ;\n break ;\n case RTOr : * rtype = RTOr ;\n break ;\n case RTNot : * rtype = RTNot ;\n break ;\n case RTContent : * rtype = RTContent ;\n break ;\n case RTProperty : * rtype = RTProperty ;\n break ;\n case RTProximity : * rtype = RTProximity ;\n break ;\n case RTVector : * rtype = RTVector ;\n break ;\n case RTNatLanguage : * rtype = RTNatLanguage ;\n break ;\n case RTScope : * rtype = RTScope ;\n break ;\n case RTCoerce_Add : * rtype = RTCoerce_Add ;\n break ;\n case RTCoerce_Multiply : * rtype = RTCoerce_Multiply ;\n break ;\n case RTCoerce_Absolute : * rtype = RTCoerce_Absolute ;\n break ;\n case RTProb : * rtype = RTProb ;\n break ;\n case RTFeedback : * rtype = RTFeedback ;\n break ;\n case RTReldoc : * rtype = RTReldoc ;\n break ;\n case RTReuseWhere : * rtype = RTReuseWhere ;\n break ;\n case RTInternalProp : * rtype = RTInternalProp ;\n break ;\n default : DISSECTOR_ASSERT ( FALSE ) ;\n break ;\n }\n txt = val_to_str ( * rtype , RT_VALS , \"0x%.8x\" ) ;\n proto_tree_add_string_format_value ( tree , hf_mswsp_crestrict_ultype , tvb , offset , 4 , txt , \"%s (0x%.8x)\" , txt [ 0 ] == '0' ? \"\" : txt , * rtype ) ;\n if ( str ) {\n * str = txt ;\n }\n return offset + 4 ;\n }", "idx": 708}
{"hash": -8416645554750795024, "project": "debian", "size": 155, "label": 1, "functionSource": "int ImagingFliDecode ( Imaging im , ImagingCodecState state , UINT8 * buf , int bytes ) {\n UINT8 * ptr ;\n int framesize ;\n int c , chunks ;\n int l , lines ;\n int i , j , x = 0 , y , ymax ;\n if ( bytes < 4 ) return 0 ;\n ptr = buf ;\n framesize = I32 ( ptr ) ;\n if ( framesize < I32 ( ptr ) ) return 0 ;\n if ( I16 ( ptr + 4 ) != 0xF1FA ) {\n state -> errcode = IMAGING_CODEC_UNKNOWN ;\n return - 1 ;\n }\n chunks = I16 ( ptr + 6 ) ;\n ptr += 16 ;\n for ( c = 0 ;\n c < chunks ;\n c ++ ) {\n UINT8 * data = ptr + 6 ;\n switch ( I16 ( ptr + 4 ) ) {\n case 4 : case 11 : break ;\n case 7 : lines = I16 ( data ) ;\n data += 2 ;\n for ( l = y = 0 ;\n l < lines && y < state -> ysize ;\n l ++ , y ++ ) {\n UINT8 * buf = ( UINT8 * ) im -> image [ y ] ;\n int p , packets ;\n packets = I16 ( data ) ;\n data += 2 ;\n while ( packets & 0x8000 ) {\n if ( packets & 0x4000 ) {\n y += 65536 - packets ;\n if ( y >= state -> ysize ) {\n state -> errcode = IMAGING_CODEC_OVERRUN ;\n return - 1 ;\n }\n buf = ( UINT8 * ) im -> image [ y ] ;\n }\n else {\n buf [ state -> xsize - 1 ] = ( UINT8 ) packets ;\n }\n packets = I16 ( data ) ;\n data += 2 ;\n }\n for ( p = x = 0 ;\n p < packets ;\n p ++ ) {\n x += data [ 0 ] ;\n if ( data [ 1 ] >= 128 ) {\n i = 256 - data [ 1 ] ;\n if ( x + i + i > state -> xsize ) break ;\n for ( j = 0 ;\n j < i ;\n j ++ ) {\n buf [ x ++ ] = data [ 2 ] ;\n buf [ x ++ ] = data [ 3 ] ;\n }\n data += 2 + 2 ;\n }\n else {\n i = 2 * ( int ) data [ 1 ] ;\n if ( x + i > state -> xsize ) break ;\n memcpy ( buf + x , data + 2 , i ) ;\n data += 2 + i ;\n x += i ;\n }\n }\n if ( p < packets ) break ;\n }\n if ( l < lines ) {\n state -> errcode = IMAGING_CODEC_OVERRUN ;\n return - 1 ;\n }\n break ;\n case 12 : y = I16 ( data ) ;\n ymax = y + I16 ( data + 2 ) ;\n data += 4 ;\n for ( ;\n y < ymax && y < state -> ysize ;\n y ++ ) {\n UINT8 * out = ( UINT8 * ) im -> image [ y ] ;\n int p , packets = * data ++ ;\n for ( p = x = 0 ;\n p < packets ;\n p ++ , x += i ) {\n x += data [ 0 ] ;\n if ( data [ 1 ] & 0x80 ) {\n i = 256 - data [ 1 ] ;\n if ( x + i > state -> xsize ) break ;\n memset ( out + x , data [ 2 ] , i ) ;\n data += 3 ;\n }\n else {\n i = data [ 1 ] ;\n if ( x + i > state -> xsize ) break ;\n memcpy ( out + x , data + 2 , i ) ;\n data += i + 2 ;\n }\n }\n if ( p < packets ) break ;\n }\n if ( y < ymax ) {\n state -> errcode = IMAGING_CODEC_OVERRUN ;\n return - 1 ;\n }\n break ;\n case 13 : for ( y = 0 ;\n y < state -> ysize ;\n y ++ ) memset ( im -> image [ y ] , 0 , state -> xsize ) ;\n break ;\n case 15 : for ( y = 0 ;\n y < state -> ysize ;\n y ++ ) {\n UINT8 * out = ( UINT8 * ) im -> image [ y ] ;\n data += 1 ;\n for ( x = 0 ;\n x < state -> xsize ;\n x += i ) {\n if ( data [ 0 ] & 0x80 ) {\n i = 256 - data [ 0 ] ;\n if ( x + i > state -> xsize ) break ;\n memcpy ( out + x , data + 1 , i ) ;\n data += i + 1 ;\n }\n else {\n i = data [ 0 ] ;\n if ( x + i > state -> xsize ) break ;\n memset ( out + x , data [ 1 ] , i ) ;\n data += 2 ;\n }\n }\n if ( x != state -> xsize ) {\n state -> errcode = IMAGING_CODEC_OVERRUN ;\n return - 1 ;\n }\n }\n break ;\n case 16 : for ( y = 0 ;\n y < state -> ysize ;\n y ++ ) {\n UINT8 * buf = ( UINT8 * ) im -> image [ y ] ;\n memcpy ( buf + x , data , state -> xsize ) ;\n data += state -> xsize ;\n }\n break ;\n case 18 : break ;\n default : state -> errcode = IMAGING_CODEC_UNKNOWN ;\n return - 1 ;\n }\n ptr += I32 ( ptr ) ;\n }\n return - 1 ;\n }", "idx": 709}
{"hash": -5268859819325807498, "project": "debian", "size": 20, "label": 0, "functionSource": "static gboolean info_provider_idle_callback ( gpointer user_data ) {\n InfoProviderResponse * response ;\n NautilusDirectory * directory ;\n response = user_data ;\n directory = response -> directory ;\n if ( response -> handle != directory -> details -> extension_info_in_progress || response -> provider != directory -> details -> extension_info_provider ) {\n g_warning ( \"Unexpected plugin response. This probably indicates a bug in a Nautilus extension: handle=%p\" , response -> handle ) ;\n }\n else {\n NautilusFile * file ;\n async_job_end ( directory , \"extension info\" ) ;\n file = directory -> details -> extension_info_file ;\n directory -> details -> extension_info_file = NULL ;\n directory -> details -> extension_info_provider = NULL ;\n directory -> details -> extension_info_in_progress = NULL ;\n directory -> details -> extension_info_idle = 0 ;\n finish_info_provider ( directory , file , response -> provider ) ;\n }\n return FALSE ;\n }", "idx": 710}
{"hash": 1760449185745615462, "project": "debian", "size": 6, "label": 0, "functionSource": "static TSReturnCode sdk_sanity_check_stat_id ( int id ) {\n if ( id < 0 || id >= api_rsb -> max_stats ) {\n return TS_ERROR ;\n }\n return TS_SUCCESS ;\n }", "idx": 711}
{"hash": -1483849844579170895, "project": "chrome", "size": 3, "label": 0, "functionSource": "static size_t wrap_fwrite ( const void * ptr , size_t size , size_t nmemb , FILE * stream ) {\n return fwrite ( ptr , size , nmemb , stream ) ;\n }", "idx": 712}
{"hash": 2898965519451754076, "project": "chrome", "size": 18, "label": 0, "functionSource": "int main ( int argc , char * * argv ) {\n using std : : string ;\n if ( argc != 2 ) {\n fprintf ( stderr , \"One argument, the input filename, must be provided.\\n\" ) ;\n return 1 ;\n }\n string filename ( argv [ 1 ] ) ;\n string outfilename = filename . substr ( 0 , filename . find_last_of ( \".\" ) ) + \".ttf\" ;\n string input = woff2 : : GetFileContent ( filename ) ;\n const uint8_t * raw_input = reinterpret_cast < const uint8_t * > ( input . data ( ) ) ;\n string output ( std : : min ( woff2 : : ComputeWOFF2FinalSize ( raw_input , input . size ( ) ) , woff2 : : kDefaultMaxSize ) , 0 ) ;\n woff2 : : WOFF2StringOut out ( & output ) ;\n const bool ok = woff2 : : ConvertWOFF2ToTTF ( raw_input , input . size ( ) , & out ) ;\n if ( ok ) {\n woff2 : : SetFileContents ( outfilename , output . begin ( ) , output . begin ( ) + out . Size ( ) ) ;\n }\n return ok ? 0 : 1 ;\n }", "idx": 713}
{"hash": -4239386405881995323, "project": "chrome", "size": 35, "label": 0, "functionSource": "void xmlHashFree ( xmlHashTablePtr table , xmlHashDeallocator f ) {\n int i ;\n xmlHashEntryPtr iter ;\n xmlHashEntryPtr next ;\n int inside_table = 0 ;\n int nbElems ;\n if ( table == NULL ) return ;\n if ( table -> table ) {\n nbElems = table -> nbElems ;\n for ( i = 0 ;\n ( i < table -> size ) && ( nbElems > 0 ) ;\n i ++ ) {\n iter = & ( table -> table [ i ] ) ;\n if ( iter -> valid == 0 ) continue ;\n inside_table = 1 ;\n while ( iter ) {\n next = iter -> next ;\n if ( ( f != NULL ) && ( iter -> payload != NULL ) ) f ( iter -> payload , iter -> name ) ;\n if ( table -> dict == NULL ) {\n if ( iter -> name ) xmlFree ( iter -> name ) ;\n if ( iter -> name2 ) xmlFree ( iter -> name2 ) ;\n if ( iter -> name3 ) xmlFree ( iter -> name3 ) ;\n }\n iter -> payload = NULL ;\n if ( ! inside_table ) xmlFree ( iter ) ;\n nbElems -- ;\n inside_table = 0 ;\n iter = next ;\n }\n }\n xmlFree ( table -> table ) ;\n }\n if ( table -> dict ) xmlDictFree ( table -> dict ) ;\n xmlFree ( table ) ;\n }", "idx": 714}
{"hash": 3887066622454352196, "project": "chrome", "size": 21, "label": 0, "functionSource": "static void swap_block_ptr ( MACROBLOCK * x , PICK_MODE_CONTEXT * ctx , int m , int n , int min_plane , int max_plane ) {\n int i ;\n for ( i = min_plane ;\n i < max_plane ;\n ++ i ) {\n struct macroblock_plane * const p = & x -> plane [ i ] ;\n struct macroblockd_plane * const pd = & x -> e_mbd . plane [ i ] ;\n p -> coeff = ctx -> coeff_pbuf [ i ] [ m ] ;\n p -> qcoeff = ctx -> qcoeff_pbuf [ i ] [ m ] ;\n pd -> dqcoeff = ctx -> dqcoeff_pbuf [ i ] [ m ] ;\n p -> eobs = ctx -> eobs_pbuf [ i ] [ m ] ;\n ctx -> coeff_pbuf [ i ] [ m ] = ctx -> coeff_pbuf [ i ] [ n ] ;\n ctx -> qcoeff_pbuf [ i ] [ m ] = ctx -> qcoeff_pbuf [ i ] [ n ] ;\n ctx -> dqcoeff_pbuf [ i ] [ m ] = ctx -> dqcoeff_pbuf [ i ] [ n ] ;\n ctx -> eobs_pbuf [ i ] [ m ] = ctx -> eobs_pbuf [ i ] [ n ] ;\n ctx -> coeff_pbuf [ i ] [ n ] = p -> coeff ;\n ctx -> qcoeff_pbuf [ i ] [ n ] = p -> qcoeff ;\n ctx -> dqcoeff_pbuf [ i ] [ n ] = pd -> dqcoeff ;\n ctx -> eobs_pbuf [ i ] [ n ] = p -> eobs ;\n }\n }", "idx": 715}
{"hash": -5493081488206619677, "project": "debian", "size": 6, "label": 0, "functionSource": "static const char * cmd_content_injection ( cmd_parms * cmd , void * _dcfg , int flag ) {\n directory_config * dcfg = ( directory_config * ) _dcfg ;\n if ( dcfg == NULL ) return NULL ;\n dcfg -> content_injection_enabled = flag ;\n return NULL ;\n }", "idx": 716}
{"hash": 1245821301839614810, "project": "debian", "size": 24, "label": 0, "functionSource": "static gboolean is_trusted_desktop_file ( GFile * file , GCancellable * cancellable ) {\n char * basename ;\n gboolean res ;\n GFileInfo * info ;\n if ( ! g_file_is_native ( file ) ) {\n return FALSE ;\n }\n basename = g_file_get_basename ( file ) ;\n if ( ! g_str_has_suffix ( basename , \".desktop\" ) ) {\n g_free ( basename ) ;\n return FALSE ;\n }\n g_free ( basename ) ;\n info = g_file_query_info ( file , G_FILE_ATTRIBUTE_STANDARD_TYPE \",\" G_FILE_ATTRIBUTE_ACCESS_CAN_EXECUTE , G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS , cancellable , NULL ) ;\n if ( info == NULL ) {\n return FALSE ;\n }\n res = FALSE ;\n if ( g_file_info_get_file_type ( info ) == G_FILE_TYPE_REGULAR && ! g_file_info_get_attribute_boolean ( info , G_FILE_ATTRIBUTE_ACCESS_CAN_EXECUTE ) && nautilus_is_in_system_dir ( file ) ) {\n res = TRUE ;\n }\n g_object_unref ( info ) ;\n return res ;\n }", "idx": 717}
{"hash": -6579823731174944595, "project": "debian", "size": 4, "label": 0, "functionSource": "static void alloc_limit_failure ( char * fn_name , size_t size ) {\n fprintf ( stderr , \"%s: Maximum allocation size exceeded \" \"(maxsize = %lu;\n size = %lu).\\n\" , fn_name , ( unsigned long ) alloc_limit , ( unsigned long ) size ) ;\n }", "idx": 718}
{"hash": -5280794106681745199, "project": "debian", "size": 128, "label": 0, "functionSource": "static GstFlowReturn gst_asf_demux_process_ext_stream_props ( GstASFDemux * demux , guint8 * data , guint64 size ) {\n AsfStreamExtProps esp ;\n AsfStream * stream = NULL ;\n AsfObject stream_obj ;\n guint16 stream_name_count ;\n guint16 num_payload_ext ;\n guint64 len ;\n guint8 * stream_obj_data = NULL ;\n guint8 * data_start ;\n guint obj_size ;\n guint i , stream_num ;\n data_start = data ;\n obj_size = ( guint ) size ;\n esp . payload_extensions = NULL ;\n if ( size < 64 ) goto not_enough_data ;\n esp . valid = TRUE ;\n esp . start_time = gst_asf_demux_get_uint64 ( & data , & size ) * GST_MSECOND ;\n esp . end_time = gst_asf_demux_get_uint64 ( & data , & size ) * GST_MSECOND ;\n esp . data_bitrate = gst_asf_demux_get_uint32 ( & data , & size ) ;\n esp . buffer_size = gst_asf_demux_get_uint32 ( & data , & size ) ;\n esp . intial_buf_fullness = gst_asf_demux_get_uint32 ( & data , & size ) ;\n esp . data_bitrate2 = gst_asf_demux_get_uint32 ( & data , & size ) ;\n esp . buffer_size2 = gst_asf_demux_get_uint32 ( & data , & size ) ;\n esp . intial_buf_fullness2 = gst_asf_demux_get_uint32 ( & data , & size ) ;\n esp . max_obj_size = gst_asf_demux_get_uint32 ( & data , & size ) ;\n esp . flags = gst_asf_demux_get_uint32 ( & data , & size ) ;\n stream_num = gst_asf_demux_get_uint16 ( & data , & size ) ;\n esp . lang_idx = gst_asf_demux_get_uint16 ( & data , & size ) ;\n esp . avg_time_per_frame = gst_asf_demux_get_uint64 ( & data , & size ) ;\n stream_name_count = gst_asf_demux_get_uint16 ( & data , & size ) ;\n num_payload_ext = gst_asf_demux_get_uint16 ( & data , & size ) ;\n GST_INFO ( \"start_time = %\" GST_TIME_FORMAT , GST_TIME_ARGS ( esp . start_time ) ) ;\n GST_INFO ( \"end_time = %\" GST_TIME_FORMAT , GST_TIME_ARGS ( esp . end_time ) ) ;\n GST_INFO ( \"flags = %08x\" , esp . flags ) ;\n GST_INFO ( \"average time per frame = %\" GST_TIME_FORMAT , GST_TIME_ARGS ( esp . avg_time_per_frame * 100 ) ) ;\n GST_INFO ( \"stream number = %u\" , stream_num ) ;\n GST_INFO ( \"stream language ID idx = %u (%s)\" , esp . lang_idx , ( esp . lang_idx < demux -> num_languages ) ? GST_STR_NULL ( demux -> languages [ esp . lang_idx ] ) : \"??\" ) ;\n GST_INFO ( \"stream name count = %u\" , stream_name_count ) ;\n for ( i = 0 ;\n i < stream_name_count ;\n ++ i ) {\n guint16 stream_lang_idx G_GNUC_UNUSED ;\n gchar * stream_name = NULL ;\n if ( size < 2 ) goto not_enough_data ;\n stream_lang_idx = gst_asf_demux_get_uint16 ( & data , & size ) ;\n if ( ! gst_asf_demux_get_string ( & stream_name , NULL , & data , & size ) ) goto not_enough_data ;\n GST_INFO ( \"stream name %d: %s\" , i , GST_STR_NULL ( stream_name ) ) ;\n g_free ( stream_name ) ;\n }\n GST_LOG ( \"payload extension systems count = %u\" , num_payload_ext ) ;\n if ( num_payload_ext > 0 ) esp . payload_extensions = g_new0 ( AsfPayloadExtension , num_payload_ext + 1 ) ;\n for ( i = 0 ;\n i < num_payload_ext ;\n ++ i ) {\n AsfPayloadExtension ext ;\n ASFGuid ext_guid ;\n guint32 sys_info_len ;\n if ( size < 16 + 2 + 4 ) goto not_enough_data ;\n gst_asf_demux_get_guid ( & ext_guid , & data , & size ) ;\n ext . id = gst_asf_demux_identify_guid ( asf_payload_ext_guids , & ext_guid ) ;\n ext . len = gst_asf_demux_get_uint16 ( & data , & size ) ;\n sys_info_len = gst_asf_demux_get_uint32 ( & data , & size ) ;\n GST_LOG ( \"payload systems info len = %u\" , sys_info_len ) ;\n if ( ! gst_asf_demux_skip_bytes ( sys_info_len , & data , & size ) ) goto not_enough_data ;\n esp . payload_extensions [ i ] = ext ;\n }\n GST_LOG ( \"bytes read: %u/%u\" , ( guint ) ( data - data_start ) , obj_size ) ;\n if ( size == 0 ) {\n stream = gst_asf_demux_get_stream ( demux , stream_num ) ;\n goto done ;\n }\n if ( size < ASF_OBJECT_HEADER_SIZE ) goto not_enough_data ;\n if ( ! asf_demux_peek_object ( demux , data , size , & stream_obj , TRUE ) ) goto corrupted_stream ;\n if ( stream_obj . id != ASF_OBJ_STREAM ) goto expected_stream_object ;\n if ( stream_obj . size < ASF_OBJECT_HEADER_SIZE || stream_obj . size > ( 10 * 1024 * 1024 ) ) goto not_enough_data ;\n gst_asf_demux_skip_bytes ( ASF_OBJECT_HEADER_SIZE , & data , & size ) ;\n len = stream_obj . size - ASF_OBJECT_HEADER_SIZE ;\n if ( ! gst_asf_demux_get_bytes ( & stream_obj_data , len , & data , & size ) ) goto not_enough_data ;\n stream = gst_asf_demux_parse_stream_object ( demux , stream_obj_data , len ) ;\n g_free ( stream_obj_data ) ;\n done : if ( stream ) {\n stream -> ext_props = esp ;\n if ( stream -> is_video && stream -> caps ) {\n GValue framerate = {\n 0 }\n ;\n GstStructure * s ;\n gint num , denom ;\n g_value_init ( & framerate , GST_TYPE_FRACTION ) ;\n num = GST_SECOND / 100 ;\n denom = esp . avg_time_per_frame ;\n if ( denom == 0 ) {\n denom = GST_SECOND / 2500 ;\n }\n gst_value_set_fraction ( & framerate , num , denom ) ;\n stream -> caps = gst_caps_make_writable ( stream -> caps ) ;\n s = gst_caps_get_structure ( stream -> caps , 0 ) ;\n gst_structure_set_value ( s , \"framerate\" , & framerate ) ;\n g_value_unset ( & framerate ) ;\n GST_DEBUG_OBJECT ( demux , \"setting framerate of %d/%d = %f\" , num , denom , ( ( gdouble ) num ) / denom ) ;\n }\n if ( stream -> ext_props . lang_idx < demux -> num_languages ) {\n if ( stream -> pending_tags == NULL ) stream -> pending_tags = gst_tag_list_new_empty ( ) ;\n GST_LOG_OBJECT ( demux , \"stream %u has language '%s'\" , stream -> id , demux -> languages [ stream -> ext_props . lang_idx ] ) ;\n gst_tag_list_add ( stream -> pending_tags , GST_TAG_MERGE_APPEND , GST_TAG_LANGUAGE_CODE , demux -> languages [ stream -> ext_props . lang_idx ] , NULL ) ;\n }\n }\n else if ( gst_asf_demux_is_unknown_stream ( demux , stream_num ) ) {\n GST_WARNING_OBJECT ( demux , \"Ext. stream properties for unknown stream\" ) ;\n }\n if ( ! stream ) g_free ( esp . payload_extensions ) ;\n return GST_FLOW_OK ;\n not_enough_data : {\n GST_WARNING_OBJECT ( demux , \"short read parsing ext stream props object!\" ) ;\n g_free ( esp . payload_extensions ) ;\n return GST_FLOW_OK ;\n }\n expected_stream_object : {\n GST_WARNING_OBJECT ( demux , \"error parsing extended stream properties \" \"object: expected embedded stream object, but got %s object instead!\" , gst_asf_get_guid_nick ( asf_object_guids , stream_obj . id ) ) ;\n g_free ( esp . payload_extensions ) ;\n return GST_FLOW_OK ;\n }\n corrupted_stream : {\n GST_WARNING_OBJECT ( demux , \"Corrupted stream\" ) ;\n g_free ( esp . payload_extensions ) ;\n return GST_FLOW_ERROR ;\n }\n }", "idx": 719}
{"hash": 5045171829429605074, "project": "debian", "size": 3, "label": 0, "functionSource": "static int zclipsave ( i_ctx_t * i_ctx_p ) {\n return gs_clipsave ( igs ) ;\n }", "idx": 720}
{"hash": 1760449185745615462, "project": "debian", "size": 14, "label": 0, "functionSource": "TSReturnCode TSHttpTxnClientPacketMarkSet ( TSHttpTxn txnp , int mark ) {\n sdk_assert ( sdk_sanity_check_txn ( txnp ) == TS_SUCCESS ) ;\n HttpSM * sm = ( HttpSM * ) txnp ;\n if ( nullptr == sm -> ua_session ) {\n return TS_ERROR ;\n }\n NetVConnection * vc = sm -> ua_session -> get_netvc ( ) ;\n if ( nullptr == vc ) {\n return TS_ERROR ;\n }\n vc -> options . packet_mark = ( uint32_t ) mark ;\n vc -> apply_options ( ) ;\n return TS_SUCCESS ;\n }", "idx": 721}
{"hash": 1805246168069113443, "project": "debian", "size": 6, "label": 0, "functionSource": "static inline int predict ( int16_t * src , int16_t * last ) {\n const int LT = last [ - 1 ] ;\n const int T = last [ 0 ] ;\n const int L = src [ - 1 ] ;\n return mid_pred ( L , L + T - LT , T ) ;\n }", "idx": 722}
{"hash": 3322961578925988960, "project": "debian", "size": 37, "label": 0, "functionSource": "static int display_end_segment ( AVCodecContext * avctx , void * data , const uint8_t * buf , int buf_size ) {\n AVSubtitle * sub = data ;\n PGSSubContext * ctx = avctx -> priv_data ;\n int64_t pts ;\n uint16_t rect ;\n pts = ctx -> pts != AV_NOPTS_VALUE ? ctx -> pts : sub -> pts ;\n memset ( sub , 0 , sizeof ( * sub ) ) ;\n sub -> pts = pts ;\n ctx -> pts = AV_NOPTS_VALUE ;\n if ( ! ctx -> presentation . object_count ) return 1 ;\n sub -> start_display_time = 0 ;\n sub -> end_display_time = 20000 ;\n sub -> format = 0 ;\n sub -> num_rects = ctx -> presentation . object_count ;\n sub -> rects = av_mallocz ( sizeof ( * sub -> rects ) * sub -> num_rects ) ;\n for ( rect = 0 ;\n rect < sub -> num_rects ;\n ++ rect ) {\n uint16_t picture_id = ctx -> presentation . objects [ rect ] . picture_id ;\n sub -> rects [ rect ] = av_mallocz ( sizeof ( * sub -> rects [ rect ] ) ) ;\n sub -> rects [ rect ] -> x = ctx -> presentation . objects [ rect ] . x ;\n sub -> rects [ rect ] -> y = ctx -> presentation . objects [ rect ] . y ;\n sub -> rects [ rect ] -> w = ctx -> pictures [ picture_id ] . w ;\n sub -> rects [ rect ] -> h = ctx -> pictures [ picture_id ] . h ;\n sub -> rects [ rect ] -> type = SUBTITLE_BITMAP ;\n sub -> rects [ rect ] -> pict . linesize [ 0 ] = ctx -> pictures [ picture_id ] . w ;\n if ( ctx -> pictures [ picture_id ] . rle ) {\n if ( ctx -> pictures [ picture_id ] . rle_remaining_len ) av_log ( avctx , AV_LOG_ERROR , \"RLE data length %u is %u bytes shorter than expected\\n\" , ctx -> pictures [ picture_id ] . rle_data_len , ctx -> pictures [ picture_id ] . rle_remaining_len ) ;\n if ( decode_rle ( avctx , sub , rect , ctx -> pictures [ picture_id ] . rle , ctx -> pictures [ picture_id ] . rle_data_len ) < 0 ) return 0 ;\n }\n sub -> rects [ rect ] -> nb_colors = 256 ;\n sub -> rects [ rect ] -> pict . data [ 1 ] = av_mallocz ( AVPALETTE_SIZE ) ;\n sub -> rects [ rect ] -> flags = ( ctx -> presentation . objects [ rect ] . composition & 0x40 ) != 0 ? AV_SUBTITLE_FLAG_FORCED : 0 ;\n if ( ! ctx -> forced_subs_only || ctx -> presentation . objects [ rect ] . composition & 0x40 ) memcpy ( sub -> rects [ rect ] -> pict . data [ 1 ] , ctx -> clut , sub -> rects [ rect ] -> nb_colors * sizeof ( uint32_t ) ) ;\n }\n return 1 ;\n }", "idx": 723}
{"hash": -2423144171479606949, "project": "debian", "size": 39, "label": 0, "functionSource": "static void pdf_show_image ( fz_context * ctx , pdf_run_processor * pr , fz_image * image ) {\n pdf_gstate * gstate = pr -> gstate + pr -> gtop ;\n fz_matrix image_ctm ;\n fz_rect bbox ;\n if ( pr -> super . hidden ) return ;\n image_ctm = gstate -> ctm ;\n fz_pre_scale ( fz_pre_translate ( & image_ctm , 0 , 1 ) , 1 , - 1 ) ;\n bbox = fz_unit_rect ;\n fz_transform_rect ( & bbox , & image_ctm ) ;\n if ( image -> mask && gstate -> blendmode ) {\n fz_begin_group ( ctx , pr -> dev , & bbox , NULL , 0 , 0 , gstate -> blendmode , 1 ) ;\n fz_try ( ctx ) fz_clip_image_mask ( ctx , pr -> dev , image -> mask , & image_ctm , & bbox ) ;\n fz_catch ( ctx ) {\n fz_end_group ( ctx , pr -> dev ) ;\n fz_rethrow ( ctx ) ;\n }\n fz_try ( ctx ) pdf_show_image_imp ( ctx , pr , image , & image_ctm , & bbox ) ;\n fz_always ( ctx ) {\n fz_pop_clip ( ctx , pr -> dev ) ;\n fz_end_group ( ctx , pr -> dev ) ;\n }\n fz_catch ( ctx ) fz_rethrow ( ctx ) ;\n }\n else if ( image -> mask ) {\n fz_clip_image_mask ( ctx , pr -> dev , image -> mask , & image_ctm , & bbox ) ;\n fz_try ( ctx ) pdf_show_image_imp ( ctx , pr , image , & image_ctm , & bbox ) ;\n fz_always ( ctx ) fz_pop_clip ( ctx , pr -> dev ) ;\n fz_catch ( ctx ) fz_rethrow ( ctx ) ;\n }\n else {\n softmask_save softmask = {\n NULL }\n ;\n gstate = pdf_begin_group ( ctx , pr , & bbox , & softmask ) ;\n fz_try ( ctx ) pdf_show_image_imp ( ctx , pr , image , & image_ctm , & bbox ) ;\n fz_always ( ctx ) pdf_end_group ( ctx , pr , & softmask ) ;\n fz_catch ( ctx ) fz_rethrow ( ctx ) ;\n }\n }", "idx": 724}
{"hash": -2423144171479606949, "project": "debian", "size": 12, "label": 0, "functionSource": "static void pdf_set_pattern ( fz_context * ctx , pdf_run_processor * pr , int what , pdf_pattern * pat , float * v ) {\n pdf_gstate * gs ;\n pdf_material * mat ;\n gs = pdf_flush_text ( ctx , pr ) ;\n mat = what == PDF_FILL ? & gs -> fill : & gs -> stroke ;\n pdf_drop_pattern ( ctx , mat -> pattern ) ;\n mat -> pattern = NULL ;\n mat -> kind = PDF_MAT_PATTERN ;\n if ( pat ) mat -> pattern = pdf_keep_pattern ( ctx , pat ) ;\n if ( v ) pdf_set_color ( ctx , pr , what , v ) ;\n mat -> gstate_num = pr -> gparent ;\n }", "idx": 725}
{"hash": -1929262071302712016, "project": "debian", "size": 15, "label": 0, "functionSource": "static cmsBool Type_ColorantOrderType_Write ( struct _cms_typehandler_struct * self , cmsIOHANDLER * io , void * Ptr , cmsUInt32Number nItems ) {\n cmsUInt8Number * ColorantOrder = ( cmsUInt8Number * ) Ptr ;\n cmsUInt32Number i , sz , Count ;\n for ( Count = i = 0 ;\n i < cmsMAXCHANNELS ;\n i ++ ) {\n if ( ColorantOrder [ i ] != 0xFF ) Count ++ ;\n }\n if ( ! _cmsWriteUInt32Number ( io , Count ) ) return FALSE ;\n sz = Count * sizeof ( cmsUInt8Number ) ;\n if ( ! io -> Write ( io , sz , ColorantOrder ) ) return FALSE ;\n return TRUE ;\n cmsUNUSED_PARAMETER ( nItems ) ;\n cmsUNUSED_PARAMETER ( self ) ;\n }", "idx": 726}
{"hash": 3599206110384554647, "project": "debian", "size": 17, "label": 0, "functionSource": "static ossl_inline void lh_ ## type ## _stats_bio ( const LHASH_OF ( type ) * lh , BIO * out ) {\n OPENSSL_LH_stats_bio ( ( const OPENSSL_LHASH * ) lh , out ) ;\n }\n static ossl_inline unsigned long lh_ ## type ## _get_down_load ( LHASH_OF ( type ) * lh ) {\n return OPENSSL_LH_get_down_load ( ( OPENSSL_LHASH * ) lh ) ;\n }\n static ossl_inline void lh_ ## type ## _set_down_load ( LHASH_OF ( type ) * lh , unsigned long dl ) {\n OPENSSL_LH_set_down_load ( ( OPENSSL_LHASH * ) lh , dl ) ;\n }\n static ossl_inline void lh_ ## type ## _doall ( LHASH_OF ( type ) * lh , void ( * doall ) ( type * ) ) {\n OPENSSL_LH_doall ( ( OPENSSL_LHASH * ) lh , ( OPENSSL_LH_DOALL_FUNC ) doall ) ;\n }\n LHASH_OF ( type ) # define IMPLEMENT_LHASH_DOALL_ARG_CONST ( type , argtype ) int_implement_lhash_doall ( type , argtype , const type ) # define IMPLEMENT_LHASH_DOALL_ARG ( type , argtype ) int_implement_lhash_doall ( type , argtype , type ) # define int_implement_lhash_doall ( type , argtype , cbargtype ) static ossl_inline void lh_ ## type ## _doall_ ## argtype ( LHASH_OF ( type ) * lh , void ( * fn ) ( cbargtype * , argtype * ) , argtype * arg ) {\n OPENSSL_LH_doall_arg ( ( OPENSSL_LHASH * ) lh , ( OPENSSL_LH_DOALL_FUNCARG ) fn , ( void * ) arg ) ;\n }\n LHASH_OF ( type ) DEFINE_LHASH_OF ( OPENSSL_STRING ) ;\n # ifdef _MSC_VER # pragma warning ( push ) # pragma warning ( disable : 4090 ) # endif DEFINE_LHASH_OF ( OPENSSL_CSTRING )", "idx": 727}
{"hash": 1760449185745615462, "project": "debian", "size": 4, "label": 0, "functionSource": "char * TSMatcherReadIntoBuffer ( char * file_name , int * file_len ) {\n sdk_assert ( sdk_sanity_check_null_ptr ( ( void * ) file_name ) == TS_SUCCESS ) ;\n return readIntoBuffer ( ( char * ) file_name , \"TSMatcher\" , file_len ) ;\n }", "idx": 728}
{"hash": -6068976579504840746, "project": "debian", "size": 3, "label": 0, "functionSource": "static void write_clockstatus ( struct recvbuf * rbufp , int restrict_mask ) {\n ctl_error ( CERR_PERMISSION ) ;\n }", "idx": 729}
{"hash": 6862887795439011210, "project": "chrome", "size": 16, "label": 0, "functionSource": "TEST_F ( SSLErrorAssistantTest , DynamicInterstitialListHashesMismatch ) {\n ASSERT_TRUE ( embedded_test_server ( ) -> Start ( ) ) ;\n EXPECT_EQ ( 1u , ssl_info ( ) . public_key_hashes . size ( ) ) ;\n auto config_proto = std : : make_unique < chrome_browser_ssl : : SSLErrorAssistantConfig > ( ) ;\n config_proto -> set_version_id ( kLargeVersionId ) ;\n chrome_browser_ssl : : DynamicInterstitial * filter = config_proto -> add_dynamic_interstitial ( ) ;\n filter -> set_interstitial_type ( chrome_browser_ssl : : DynamicInterstitial : : INTERSTITIAL_PAGE_SSL ) ;\n filter -> set_cert_error ( chrome_browser_ssl : : DynamicInterstitial : : UNKNOWN_CERT_ERROR ) ;\n filter -> add_sha256_hash ( \"sha256/yellowlegs\" ) ;\n filter -> add_sha256_hash ( \"sha256/killdeer\" ) ;\n filter -> set_issuer_common_name_regex ( issuer_common_name ( ) ) ;\n filter -> set_issuer_organization_regex ( issuer_organization_name ( ) ) ;\n filter -> set_mitm_software_name ( \"UwS\" ) ;\n error_assistant ( ) -> SetErrorAssistantProto ( std : : move ( config_proto ) ) ;\n EXPECT_FALSE ( error_assistant ( ) -> MatchDynamicInterstitial ( ssl_info ( ) ) ) ;\n }", "idx": 730}
{"hash": 313627013719508831, "project": "debian", "size": 3, "label": 0, "functionSource": "static inline void SetPixelCbTraits ( Image * image , const PixelTrait traits ) {\n image -> channel_map [ CbPixelChannel ] . traits = traits ;\n }", "idx": 731}
{"hash": -1315695702746584250, "project": "debian", "size": 31, "label": 0, "functionSource": "void proto_get_frame_protocols ( const wmem_list_t * layers , gboolean * is_ip , gboolean * is_tcp , gboolean * is_udp , gboolean * is_sctp , gboolean * is_ssl , gboolean * is_rtp , gboolean * is_lte_rlc ) {\n wmem_list_frame_t * protos = wmem_list_head ( layers ) ;\n int proto_id ;\n const char * proto_name ;\n while ( protos != NULL ) {\n proto_id = GPOINTER_TO_INT ( wmem_list_frame_data ( protos ) ) ;\n proto_name = proto_get_protocol_filter_name ( proto_id ) ;\n if ( is_ip && ( ( ! strcmp ( proto_name , \"ip\" ) ) || ( ! strcmp ( proto_name , \"ipv6\" ) ) ) ) {\n * is_ip = TRUE ;\n }\n else if ( is_tcp && ! strcmp ( proto_name , \"tcp\" ) ) {\n * is_tcp = TRUE ;\n }\n else if ( is_udp && ! strcmp ( proto_name , \"udp\" ) ) {\n * is_udp = TRUE ;\n }\n else if ( is_sctp && ! strcmp ( proto_name , \"sctp\" ) ) {\n * is_sctp = TRUE ;\n }\n else if ( is_ssl && ! strcmp ( proto_name , \"ssl\" ) ) {\n * is_ssl = TRUE ;\n }\n else if ( is_rtp && ! strcmp ( proto_name , \"rtp\" ) ) {\n * is_rtp = TRUE ;\n }\n else if ( is_lte_rlc && ! strcmp ( proto_name , \"rlc-lte\" ) ) {\n * is_lte_rlc = TRUE ;\n }\n protos = wmem_list_frame_next ( protos ) ;\n }\n }", "idx": 732}
{"hash": -9028269206303312561, "project": "debian", "size": 46, "label": 0, "functionSource": "static void xps_parse_gradient_brush ( xps_document * doc , const fz_matrix * ctm , const fz_rect * area , char * base_uri , xps_resource * dict , fz_xml * root , void ( * draw ) ( xps_document * , const fz_matrix * , const fz_rect * , struct stop * , int , fz_xml * , int ) ) {\n fz_xml * node ;\n char * opacity_att ;\n char * spread_att ;\n char * transform_att ;\n fz_xml * transform_tag = NULL ;\n fz_xml * stop_tag = NULL ;\n struct stop stop_list [ MAX_STOPS ] ;\n int stop_count ;\n fz_matrix transform ;\n int spread_method ;\n opacity_att = fz_xml_att ( root , \"Opacity\" ) ;\n spread_att = fz_xml_att ( root , \"SpreadMethod\" ) ;\n transform_att = fz_xml_att ( root , \"Transform\" ) ;\n for ( node = fz_xml_down ( root ) ;\n node ;\n node = fz_xml_next ( node ) ) {\n if ( ! strcmp ( fz_xml_tag ( node ) , \"LinearGradientBrush.Transform\" ) ) transform_tag = fz_xml_down ( node ) ;\n if ( ! strcmp ( fz_xml_tag ( node ) , \"RadialGradientBrush.Transform\" ) ) transform_tag = fz_xml_down ( node ) ;\n if ( ! strcmp ( fz_xml_tag ( node ) , \"LinearGradientBrush.GradientStops\" ) ) stop_tag = fz_xml_down ( node ) ;\n if ( ! strcmp ( fz_xml_tag ( node ) , \"RadialGradientBrush.GradientStops\" ) ) stop_tag = fz_xml_down ( node ) ;\n }\n xps_resolve_resource_reference ( doc , dict , & transform_att , & transform_tag , NULL ) ;\n spread_method = SPREAD_PAD ;\n if ( spread_att ) {\n if ( ! strcmp ( spread_att , \"Pad\" ) ) spread_method = SPREAD_PAD ;\n if ( ! strcmp ( spread_att , \"Reflect\" ) ) spread_method = SPREAD_REFLECT ;\n if ( ! strcmp ( spread_att , \"Repeat\" ) ) spread_method = SPREAD_REPEAT ;\n }\n transform = fz_identity ;\n if ( transform_att ) xps_parse_render_transform ( doc , transform_att , & transform ) ;\n if ( transform_tag ) xps_parse_matrix_transform ( doc , transform_tag , & transform ) ;\n fz_concat ( & transform , & transform , ctm ) ;\n if ( ! stop_tag ) {\n fz_warn ( doc -> ctx , \"missing gradient stops tag\" ) ;\n return ;\n }\n stop_count = xps_parse_gradient_stops ( doc , base_uri , stop_tag , stop_list , MAX_STOPS ) ;\n if ( stop_count == 0 ) {\n fz_warn ( doc -> ctx , \"no gradient stops found\" ) ;\n return ;\n }\n xps_begin_opacity ( doc , & transform , area , base_uri , dict , opacity_att , NULL ) ;\n draw ( doc , & transform , area , stop_list , stop_count , root , spread_method ) ;\n xps_end_opacity ( doc , base_uri , dict , opacity_att , NULL ) ;\n }", "idx": 733}
{"hash": -2864619463801931351, "project": "chrome", "size": 25, "label": 1, "functionSource": "static void exsltDynEvaluateFunction ( xmlXPathParserContextPtr ctxt , int nargs ) {\n xmlChar * str = NULL ;\n xmlXPathObjectPtr ret = NULL ;\n if ( ctxt == NULL ) return ;\n if ( nargs != 1 ) {\n xsltPrintErrorContext ( xsltXPathGetTransformContext ( ctxt ) , NULL , NULL ) ;\n xsltGenericError ( xsltGenericErrorContext , \"dyn:evalute() : invalid number of args %d\\n\" , nargs ) ;\n ctxt -> error = XPATH_INVALID_ARITY ;\n return ;\n }\n str = xmlXPathPopString ( ctxt ) ;\n if ( ! str || ! xmlStrlen ( str ) ) {\n if ( str ) xmlFree ( str ) ;\n valuePush ( ctxt , xmlXPathNewNodeSet ( NULL ) ) ;\n return ;\n }\n ret = xmlXPathEval ( str , ctxt -> context ) ;\n if ( ret ) valuePush ( ctxt , ret ) ;\n else {\n xsltGenericError ( xsltGenericErrorContext , \"dyn:evaluate() : unable to evaluate expression '%s'\\n\" , str ) ;\n valuePush ( ctxt , xmlXPathNewNodeSet ( NULL ) ) ;\n }\n xmlFree ( str ) ;\n return ;\n }", "idx": 734}
{"hash": -5280794106681745199, "project": "debian", "size": 196, "label": 0, "functionSource": "static GstFlowReturn gst_asf_demux_process_ext_content_desc ( GstASFDemux * demux , guint8 * data , guint64 size ) {\n GstTagList * taglist ;\n guint16 blockcount , i ;\n gboolean content3D = FALSE ;\n struct {\n const gchar * interleave_name ;\n GstASF3DMode interleaving_type ;\n }\n stereoscopic_layout_map [ ] = {\n {\n \"SideBySideRF\" , GST_ASF_3D_SIDE_BY_SIDE_HALF_RL }\n , {\n \"SideBySideLF\" , GST_ASF_3D_SIDE_BY_SIDE_HALF_LR }\n , {\n \"OverUnderRT\" , GST_ASF_3D_TOP_AND_BOTTOM_HALF_RL }\n , {\n \"OverUnderLT\" , GST_ASF_3D_TOP_AND_BOTTOM_HALF_LR }\n , {\n \"DualStream\" , GST_ASF_3D_DUAL_STREAM }\n }\n ;\n GST_INFO_OBJECT ( demux , \"object is an extended content description\" ) ;\n taglist = gst_tag_list_new_empty ( ) ;\n if ( size < 2 ) goto not_enough_data ;\n blockcount = gst_asf_demux_get_uint16 ( & data , & size ) ;\n for ( i = 1 ;\n i <= blockcount ;\n ++ i ) {\n const gchar * gst_tag_name ;\n guint16 datatype ;\n guint16 value_len ;\n guint16 name_len ;\n GValue tag_value = {\n 0 , }\n ;\n gsize in , out ;\n gchar * name ;\n gchar * name_utf8 = NULL ;\n gchar * value ;\n if ( ! gst_asf_demux_get_string ( & name , & name_len , & data , & size ) ) goto not_enough_data ;\n if ( size < 2 ) {\n g_free ( name ) ;\n goto not_enough_data ;\n }\n datatype = gst_asf_demux_get_uint16 ( & data , & size ) ;\n if ( ! gst_asf_demux_get_string ( & value , & value_len , & data , & size ) ) {\n g_free ( name ) ;\n goto not_enough_data ;\n }\n name_utf8 = g_convert ( name , name_len , \"UTF-8\" , \"UTF-16LE\" , & in , & out , NULL ) ;\n if ( name_utf8 != NULL ) {\n GST_DEBUG ( \"Found tag/metadata %s\" , name_utf8 ) ;\n gst_tag_name = gst_asf_demux_get_gst_tag_from_tag_name ( name_utf8 ) ;\n GST_DEBUG ( \"gst_tag_name %s\" , GST_STR_NULL ( gst_tag_name ) ) ;\n switch ( datatype ) {\n case ASF_DEMUX_DATA_TYPE_UTF16LE_STRING : {\n gchar * value_utf8 ;\n value_utf8 = g_convert ( value , value_len , \"UTF-8\" , \"UTF-16LE\" , & in , & out , NULL ) ;\n if ( value_utf8 != NULL && * value_utf8 != '\\0' ) {\n GST_DEBUG ( \"string value %s\" , value_utf8 ) ;\n value_utf8 [ out ] = '\\0' ;\n if ( gst_tag_name != NULL ) {\n if ( strcmp ( gst_tag_name , GST_TAG_DATE_TIME ) == 0 ) {\n guint year = atoi ( value_utf8 ) ;\n if ( year > 0 ) {\n g_value_init ( & tag_value , GST_TYPE_DATE_TIME ) ;\n g_value_take_boxed ( & tag_value , gst_date_time_new_y ( year ) ) ;\n }\n }\n else if ( strcmp ( gst_tag_name , GST_TAG_GENRE ) == 0 ) {\n guint id3v1_genre_id ;\n const gchar * genre_str ;\n if ( sscanf ( value_utf8 , \"(%u)\" , & id3v1_genre_id ) == 1 && ( ( genre_str = gst_tag_id3_genre_get ( id3v1_genre_id ) ) ) ) {\n GST_DEBUG ( \"Genre: %s -> %s\" , value_utf8 , genre_str ) ;\n g_free ( value_utf8 ) ;\n value_utf8 = g_strdup ( genre_str ) ;\n }\n }\n else {\n GType tag_type ;\n tag_type = gst_tag_get_type ( gst_tag_name ) ;\n g_value_init ( & tag_value , tag_type ) ;\n if ( ! gst_value_deserialize ( & tag_value , value_utf8 ) ) {\n GValue from_val = {\n 0 , }\n ;\n g_value_init ( & from_val , G_TYPE_STRING ) ;\n g_value_set_string ( & from_val , value_utf8 ) ;\n if ( ! g_value_transform ( & from_val , & tag_value ) ) {\n GST_WARNING_OBJECT ( demux , \"Could not transform string tag to \" \"%s tag type %s\" , gst_tag_name , g_type_name ( tag_type ) ) ;\n g_value_unset ( & tag_value ) ;\n }\n g_value_unset ( & from_val ) ;\n }\n }\n }\n else {\n GST_DEBUG ( \"Setting metadata\" ) ;\n g_value_init ( & tag_value , G_TYPE_STRING ) ;\n g_value_set_string ( & tag_value , value_utf8 ) ;\n if ( content3D ) {\n guint i ;\n if ( strncmp ( \"StereoscopicLayout\" , name_utf8 , strlen ( name_utf8 ) ) == 0 ) {\n for ( i = 0 ;\n i < G_N_ELEMENTS ( stereoscopic_layout_map ) ;\n i ++ ) {\n if ( g_str_equal ( stereoscopic_layout_map [ i ] . interleave_name , value_utf8 ) ) {\n demux -> asf_3D_mode = stereoscopic_layout_map [ i ] . interleaving_type ;\n GST_INFO ( \"find interleave type %u\" , demux -> asf_3D_mode ) ;\n }\n }\n }\n GST_INFO_OBJECT ( demux , \"3d type is %u\" , demux -> asf_3D_mode ) ;\n }\n else {\n demux -> asf_3D_mode = GST_ASF_3D_NONE ;\n GST_INFO_OBJECT ( demux , \"None 3d type\" ) ;\n }\n }\n }\n else if ( value_utf8 == NULL ) {\n GST_WARNING ( \"Failed to convert string value to UTF8, skipping\" ) ;\n }\n else {\n GST_DEBUG ( \"Skipping empty string value for %s\" , GST_STR_NULL ( gst_tag_name ) ) ;\n }\n g_free ( value_utf8 ) ;\n break ;\n }\n case ASF_DEMUX_DATA_TYPE_BYTE_ARRAY : {\n if ( gst_tag_name ) {\n if ( ! g_str_equal ( gst_tag_name , GST_TAG_IMAGE ) ) {\n GST_FIXME ( \"Unhandled byte array tag %s\" , GST_STR_NULL ( gst_tag_name ) ) ;\n break ;\n }\n else {\n asf_demux_parse_picture_tag ( taglist , ( guint8 * ) value , value_len ) ;\n }\n }\n break ;\n }\n case ASF_DEMUX_DATA_TYPE_DWORD : {\n guint uint_val ;\n if ( value_len < 4 ) break ;\n uint_val = GST_READ_UINT32_LE ( value ) ;\n g_value_init ( & tag_value , G_TYPE_UINT ) ;\n if ( ! strcmp ( name_utf8 , \"WM/Track\" ) ) ++ uint_val ;\n g_value_set_uint ( & tag_value , uint_val ) ;\n break ;\n }\n case ASF_DEMUX_DATA_TYPE_BOOL : {\n gboolean bool_val ;\n if ( value_len < 4 ) break ;\n bool_val = GST_READ_UINT32_LE ( value ) ;\n if ( strncmp ( \"Stereoscopic\" , name_utf8 , strlen ( name_utf8 ) ) == 0 ) {\n if ( bool_val ) {\n GST_INFO_OBJECT ( demux , \"This is 3D contents\" ) ;\n content3D = TRUE ;\n }\n else {\n GST_INFO_OBJECT ( demux , \"This is not 3D contenst\" ) ;\n content3D = FALSE ;\n }\n }\n break ;\n }\n default : {\n GST_DEBUG ( \"Skipping tag %s of type %d\" , gst_tag_name , datatype ) ;\n break ;\n }\n }\n if ( G_IS_VALUE ( & tag_value ) ) {\n if ( gst_tag_name ) {\n GstTagMergeMode merge_mode = GST_TAG_MERGE_APPEND ;\n if ( strcmp ( name_utf8 , \"WM/TrackNumber\" ) == 0 ) merge_mode = GST_TAG_MERGE_REPLACE ;\n gst_tag_list_add_values ( taglist , merge_mode , gst_tag_name , & tag_value , NULL ) ;\n }\n else {\n GST_DEBUG ( \"Setting global metadata %s\" , name_utf8 ) ;\n gst_structure_set_value ( demux -> global_metadata , name_utf8 , & tag_value ) ;\n }\n g_value_unset ( & tag_value ) ;\n }\n }\n g_free ( name ) ;\n g_free ( value ) ;\n g_free ( name_utf8 ) ;\n }\n gst_asf_demux_add_global_tags ( demux , taglist ) ;\n return GST_FLOW_OK ;\n not_enough_data : {\n GST_WARNING ( \"Unexpected end of data parsing ext content desc object\" ) ;\n gst_tag_list_unref ( taglist ) ;\n return GST_FLOW_OK ;\n }\n }", "idx": 735}
{"hash": 6675626110148442062, "project": "debian", "size": 10, "label": 0, "functionSource": "int jas_stream_printf ( jas_stream_t * stream , const char * fmt , ... ) {\n va_list ap ;\n char buf [ 4096 ] ;\n int ret ;\n va_start ( ap , fmt ) ;\n ret = vsnprintf ( buf , sizeof buf , fmt , ap ) ;\n jas_stream_puts ( stream , buf ) ;\n va_end ( ap ) ;\n return ret ;\n }", "idx": 736}
{"hash": 103178053094187415, "project": "chrome", "size": 11, "label": 0, "functionSource": "xmlChar * xsltEvalAttrValueTemplate ( xsltTransformContextPtr ctxt , xmlNodePtr inst , const xmlChar * name , const xmlChar * ns ) {\n xmlChar * ret ;\n xmlChar * expr ;\n if ( ( ctxt == NULL ) || ( inst == NULL ) || ( name == NULL ) || ( inst -> type != XML_ELEMENT_NODE ) ) return ( NULL ) ;\n expr = xsltGetNsProp ( inst , name , ns ) ;\n if ( expr == NULL ) return ( NULL ) ;\n ret = xsltAttrTemplateValueProcessNode ( ctxt , expr , inst ) ;\n # ifdef WITH_XSLT_DEBUG_TEMPLATES XSLT_TRACE ( ctxt , XSLT_TRACE_TEMPLATES , xsltGenericDebug ( xsltGenericDebugContext , \"xsltEvalAttrValueTemplate: %s returns %s\\n\" , expr , ret ) ) ;\n # endif if ( expr != NULL ) xmlFree ( expr ) ;\n return ( ret ) ;\n }", "idx": 737}
{"hash": 9160937366035817353, "project": "chrome", "size": 57, "label": 0, "functionSource": "int vp9_find_best_sub_pixel_tree_pruned ( const MACROBLOCK * x , MV * bestmv , const MV * ref_mv , int allow_hp , int error_per_bit , const vp9_variance_fn_ptr_t * vfp , int forced_stop , int iters_per_step , int * sad_list , int * mvjcost , int * mvcost [ 2 ] , int * distortion , unsigned int * sse1 , const uint8_t * second_pred , int w , int h ) {\n SETUP_SUBPEL_SEARCH ;\n if ( sad_list && sad_list [ 0 ] != INT_MAX && sad_list [ 1 ] != INT_MAX && sad_list [ 2 ] != INT_MAX && sad_list [ 3 ] != INT_MAX && sad_list [ 4 ] != INT_MAX ) {\n unsigned int left , right , up , down , diag ;\n whichdir = ( sad_list [ 1 ] < sad_list [ 3 ] ? 0 : 1 ) + ( sad_list [ 2 ] < sad_list [ 4 ] ? 0 : 2 ) ;\n switch ( whichdir ) {\n case 0 : CHECK_BETTER ( left , tr , tc - hstep ) ;\n CHECK_BETTER ( down , tr + hstep , tc ) ;\n CHECK_BETTER ( diag , tr + hstep , tc - hstep ) ;\n break ;\n case 1 : CHECK_BETTER ( right , tr , tc + hstep ) ;\n CHECK_BETTER ( down , tr + hstep , tc ) ;\n CHECK_BETTER ( diag , tr + hstep , tc + hstep ) ;\n break ;\n case 2 : CHECK_BETTER ( left , tr , tc - hstep ) ;\n CHECK_BETTER ( up , tr - hstep , tc ) ;\n CHECK_BETTER ( diag , tr - hstep , tc - hstep ) ;\n break ;\n case 3 : CHECK_BETTER ( right , tr , tc + hstep ) ;\n CHECK_BETTER ( up , tr - hstep , tc ) ;\n CHECK_BETTER ( diag , tr - hstep , tc + hstep ) ;\n break ;\n }\n }\n else {\n FIRST_LEVEL_CHECKS ;\n if ( halfiters > 1 ) {\n SECOND_LEVEL_CHECKS ;\n }\n }\n tr = br ;\n tc = bc ;\n if ( forced_stop != 2 ) {\n hstep >>= 1 ;\n FIRST_LEVEL_CHECKS ;\n if ( quarteriters > 1 ) {\n SECOND_LEVEL_CHECKS ;\n }\n tr = br ;\n tc = bc ;\n }\n if ( allow_hp && vp9_use_mv_hp ( ref_mv ) && forced_stop == 0 ) {\n hstep >>= 1 ;\n FIRST_LEVEL_CHECKS ;\n if ( eighthiters > 1 ) {\n SECOND_LEVEL_CHECKS ;\n }\n tr = br ;\n tc = bc ;\n }\n ( void ) tr ;\n ( void ) tc ;\n bestmv -> row = br ;\n bestmv -> col = bc ;\n if ( ( abs ( bestmv -> col - ref_mv -> col ) > ( MAX_FULL_PEL_VAL << 3 ) ) || ( abs ( bestmv -> row - ref_mv -> row ) > ( MAX_FULL_PEL_VAL << 3 ) ) ) return INT_MAX ;\n return besterr ;\n }", "idx": 738}
{"hash": -2127895299879503273, "project": "debian", "size": 76, "label": 0, "functionSource": "static void pmac_ide_atapi_transfer_cb ( void * opaque , int ret ) {\n DBDMA_io * io = opaque ;\n MACIOIDEState * m = io -> opaque ;\n IDEState * s = idebus_active_if ( & m -> bus ) ;\n int unaligned ;\n if ( ret < 0 ) {\n m -> aiocb = NULL ;\n qemu_sglist_destroy ( & s -> sg ) ;\n ide_atapi_io_error ( s , ret ) ;\n io -> remainder_len = 0 ;\n goto done ;\n }\n if ( ! m -> dma_active ) {\n MACIO_DPRINTF ( \"waiting for data (%#x - %#x - %x)\\n\" , s -> nsector , io -> len , s -> status ) ;\n io -> processing = false ;\n return ;\n }\n MACIO_DPRINTF ( \"io_buffer_size = %#x\\n\" , s -> io_buffer_size ) ;\n if ( s -> io_buffer_size > 0 ) {\n m -> aiocb = NULL ;\n qemu_sglist_destroy ( & s -> sg ) ;\n s -> packet_transfer_size -= s -> io_buffer_size ;\n s -> io_buffer_index += s -> io_buffer_size ;\n s -> lba += s -> io_buffer_index >> 11 ;\n s -> io_buffer_index &= 0x7ff ;\n }\n s -> io_buffer_size = MIN ( io -> len , s -> packet_transfer_size ) ;\n MACIO_DPRINTF ( \"remainder: %d io->len: %d size: %d\\n\" , io -> remainder_len , io -> len , s -> packet_transfer_size ) ;\n if ( io -> remainder_len && io -> len ) {\n int remainder_len = MIN ( io -> remainder_len , io -> len ) ;\n MACIO_DPRINTF ( \"copying remainder %d bytes\\n\" , remainder_len ) ;\n cpu_physical_memory_write ( io -> addr , io -> remainder + 0x200 - remainder_len , remainder_len ) ;\n io -> addr += remainder_len ;\n io -> len -= remainder_len ;\n s -> io_buffer_size = remainder_len ;\n io -> remainder_len -= remainder_len ;\n qemu_sglist_init ( & s -> sg , DEVICE ( m ) , io -> len / MACIO_PAGE_SIZE + 1 , & address_space_memory ) ;\n pmac_ide_atapi_transfer_cb ( opaque , 0 ) ;\n return ;\n }\n if ( ! s -> packet_transfer_size ) {\n MACIO_DPRINTF ( \"end of transfer\\n\" ) ;\n ide_atapi_cmd_ok ( s ) ;\n m -> dma_active = false ;\n }\n if ( io -> len == 0 ) {\n MACIO_DPRINTF ( \"end of DMA\\n\" ) ;\n goto done ;\n }\n unaligned = io -> len & 0x1ff ;\n if ( unaligned ) {\n int sector_num = ( s -> lba << 2 ) + ( s -> io_buffer_index >> 9 ) ;\n int nsector = io -> len >> 9 ;\n MACIO_DPRINTF ( \"precopying unaligned %d bytes to %#\" HWADDR_PRIx \"\\n\" , unaligned , io -> addr + io -> len - unaligned ) ;\n blk_read ( s -> blk , sector_num + nsector , io -> remainder , 1 ) ;\n cpu_physical_memory_write ( io -> addr + io -> len - unaligned , io -> remainder , unaligned ) ;\n io -> len -= unaligned ;\n }\n MACIO_DPRINTF ( \"io->len = %#x\\n\" , io -> len ) ;\n qemu_sglist_init ( & s -> sg , DEVICE ( m ) , io -> len / MACIO_PAGE_SIZE + 1 , & address_space_memory ) ;\n qemu_sglist_add ( & s -> sg , io -> addr , io -> len ) ;\n io -> addr += s -> io_buffer_size ;\n io -> remainder_len = MIN ( s -> packet_transfer_size - s -> io_buffer_size , ( 0x200 - unaligned ) & 0x1ff ) ;\n MACIO_DPRINTF ( \"set remainder to: %d\\n\" , io -> remainder_len ) ;\n if ( ! io -> len ) {\n pmac_ide_atapi_transfer_cb ( opaque , 0 ) ;\n return ;\n }\n io -> len = 0 ;\n MACIO_DPRINTF ( \"sector_num=%d size=%d, cmd_cmd=%d\\n\" , ( s -> lba << 2 ) + ( s -> io_buffer_index >> 9 ) , s -> packet_transfer_size , s -> dma_cmd ) ;\n m -> aiocb = dma_blk_read ( s -> blk , & s -> sg , ( int64_t ) ( s -> lba << 2 ) + ( s -> io_buffer_index >> 9 ) , pmac_ide_atapi_transfer_cb , io ) ;\n return ;\n done : MACIO_DPRINTF ( \"done DMA\\n\" ) ;\n block_acct_done ( blk_get_stats ( s -> blk ) , & s -> acct ) ;\n io -> dma_end ( opaque ) ;\n }", "idx": 739}
{"hash": 5045872831385413038, "project": "debian", "size": 3048, "label": 1, "functionSource": "static gint dissect_attribute_value ( proto_tree * tree , proto_item * patron_item , packet_info * pinfo , tvbuff_t * old_tvb , gint old_offset , gint length , guint16 handle , bluetooth_uuid_t uuid , btatt_data_t * att_data ) {\n proto_item * sub_item ;\n proto_tree * sub_tree = NULL ;\n tvbuff_t * tvb ;\n gint offset = 0 ;\n bluetooth_uuid_t sub_uuid ;\n bluetooth_uuid_t service_uuid ;\n guint16 sub_handle ;\n guint32 value ;\n guint32 flags ;\n guint32 operator_value ;\n guint32 opcode ;\n guint32 operand_offset ;\n const gint * * hfs ;\n bluetooth_data_t * bluetooth_data = NULL ;\n tvb = tvb_new_subset_length_caplen ( old_tvb , old_offset , length , length ) ;\n DISSECTOR_ASSERT ( att_data ) ;\n bluetooth_data = att_data -> bluetooth_data ;\n if ( p_get_proto_data ( pinfo -> pool , pinfo , proto_btatt , PROTO_DATA_BTATT_HANDLE ) == NULL ) {\n guint16 * value_data ;\n value_data = wmem_new ( wmem_file_scope ( ) , guint16 ) ;\n * value_data = handle ;\n p_add_proto_data ( pinfo -> pool , pinfo , proto_btatt , PROTO_DATA_BTATT_HANDLE , value_data ) ;\n }\n if ( btatt_dissect_attribute_handle ( handle , tvb , pinfo , tree , att_data ) ) return old_offset + length ;\n if ( p_get_proto_data ( pinfo -> pool , pinfo , proto_bluetooth , PROTO_DATA_BLUETOOTH_SERVICE_UUID ) == NULL ) {\n guint8 * value_data ;\n value_data = wmem_strdup ( wmem_file_scope ( ) , print_numeric_uuid ( & uuid ) ) ;\n p_add_proto_data ( pinfo -> pool , pinfo , proto_bluetooth , PROTO_DATA_BLUETOOTH_SERVICE_UUID , value_data ) ;\n }\n if ( dissector_try_string ( bluetooth_uuid_table , print_numeric_uuid ( & uuid ) , tvb , pinfo , tree , att_data ) ) return old_offset + length ;\n else if ( ! uuid . bt_uuid ) {\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) return old_offset ;\n proto_tree_add_item ( tree , hf_btatt_value , tvb , offset , - 1 , ENC_NA ) ;\n return old_offset + tvb_captured_length ( tvb ) ;\n }\n service_uuid = get_service_uuid_from_handle ( pinfo , handle , bluetooth_data ) ;\n switch ( uuid . bt_uuid ) {\n case 0x2800 : case 0x2801 : if ( is_readable_request ( att_data -> opcode ) || att_data -> opcode == ATT_OPCODE_READ_BY_GROUP_TYPE_REQUEST ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_READ_BY_GROUP_TYPE_RESPONSE ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n if ( tvb_reported_length_remaining ( tvb , offset ) == 2 ) {\n proto_tree_add_item ( tree , hf_btatt_uuid16 , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n sub_uuid = get_uuid ( tvb , offset , 2 ) ;\n proto_item_append_text ( patron_item , \", UUID: %s\" , print_uuid ( & sub_uuid ) ) ;\n offset += 2 ;\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \", %s\" , print_uuid ( & sub_uuid ) ) ;\n save_handle ( pinfo , sub_uuid , handle , ATTRIBUTE_TYPE_SERVICE , bluetooth_data ) ;\n }\n else if ( tvb_reported_length_remaining ( tvb , offset ) == 16 ) {\n proto_tree_add_item ( tree , hf_btatt_uuid128 , tvb , offset , 16 , ENC_NA ) ;\n sub_uuid = get_uuid ( tvb , offset , 16 ) ;\n proto_item_append_text ( patron_item , \", UUID128: %s\" , print_uuid ( & sub_uuid ) ) ;\n offset += 16 ;\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \", %s\" , print_uuid ( & sub_uuid ) ) ;\n save_handle ( pinfo , sub_uuid , handle , ATTRIBUTE_TYPE_SERVICE , bluetooth_data ) ;\n }\n else {\n sub_item = proto_tree_add_item ( tree , hf_btatt_value , tvb , offset , - 1 , ENC_NA ) ;\n expert_add_info ( pinfo , sub_item , & ei_btatt_bad_data ) ;\n offset = tvb_captured_length ( tvb ) ;\n }\n break ;\n case 0x2802 : if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n offset = dissect_handle ( tree , pinfo , hf_btatt_included_service_handle , tvb , offset , bluetooth_data , NULL , HANDLE_TVB ) ;\n sub_handle = tvb_get_guint16 ( tvb , offset - 2 , ENC_LITTLE_ENDIAN ) ;\n proto_tree_add_item ( tree , hf_btatt_ending_handle , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_uuid16 , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n sub_uuid = get_uuid ( tvb , offset , 2 ) ;\n proto_item_append_text ( patron_item , \", Included Handle: 0x%04x, UUID: %s\" , sub_handle , print_uuid ( & sub_uuid ) ) ;\n offset += 2 ;\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \", %s\" , print_uuid ( & sub_uuid ) ) ;\n save_handle ( pinfo , sub_uuid , sub_handle , ATTRIBUTE_TYPE_OTHER , bluetooth_data ) ;\n break ;\n case 0x2803 : if ( is_readable_request ( att_data -> opcode ) || att_data -> opcode == ATT_OPCODE_READ_BY_TYPE_REQUEST ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_READ_BY_TYPE_RESPONSE ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_characteristic_properties , ett_btatt_characteristic_properties , hfx_btatt_characteristic_properties , ENC_NA ) ;\n offset += 1 ;\n offset = dissect_handle ( tree , pinfo , hf_btatt_characteristic_value_handle , tvb , offset , bluetooth_data , NULL , HANDLE_TVB ) ;\n sub_handle = tvb_get_guint16 ( tvb , offset - 2 , ENC_LITTLE_ENDIAN ) ;\n if ( tvb_reported_length_remaining ( tvb , offset ) == 16 ) {\n proto_tree_add_item ( tree , hf_btatt_uuid128 , tvb , offset , 16 , ENC_NA ) ;\n sub_uuid = get_uuid ( tvb , offset , 16 ) ;\n proto_item_append_text ( patron_item , \", Characteristic Handle: 0x%04x, UUID128: %s\" , tvb_get_guint16 ( tvb , offset - 2 , ENC_LITTLE_ENDIAN ) , print_uuid ( & sub_uuid ) ) ;\n offset += 16 ;\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \", %s\" , print_uuid ( & sub_uuid ) ) ;\n save_handle ( pinfo , sub_uuid , sub_handle , ATTRIBUTE_TYPE_CHARACTERISTIC , bluetooth_data ) ;\n }\n else if ( tvb_reported_length_remaining ( tvb , offset ) == 2 ) {\n proto_tree_add_item ( tree , hf_btatt_uuid16 , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n sub_uuid = get_uuid ( tvb , offset , 2 ) ;\n proto_item_append_text ( patron_item , \", Characteristic Handle: 0x%04x, UUID: %s\" , sub_handle , print_uuid ( & sub_uuid ) ) ;\n offset += 2 ;\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \", %s\" , print_uuid ( & sub_uuid ) ) ;\n save_handle ( pinfo , sub_uuid , sub_handle , ATTRIBUTE_TYPE_CHARACTERISTIC , bluetooth_data ) ;\n }\n else {\n sub_item = proto_tree_add_item ( tree , hf_btatt_value , tvb , offset , - 1 , ENC_NA ) ;\n expert_add_info ( pinfo , sub_item , & ei_btatt_bad_data ) ;\n offset = tvb_captured_length ( tvb ) ;\n }\n break ;\n case 0x2900 : if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_characteristic_extended_properties , ett_btatt_value , hfx_btatt_characteristic_extended_properties , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 0x2901 : if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_characteristic_user_description , tvb , offset , tvb_captured_length_remaining ( tvb , offset ) , ENC_NA | ENC_UTF_8 ) ;\n offset += tvb_captured_length_remaining ( tvb , offset ) ;\n break ;\n case 0x2902 : if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) || att_data -> opcode == ATT_OPCODE_HANDLE_VALUE_CONFIRMATION ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_characteristic_configuration_client , ett_btatt_value , hfx_btatt_characteristic_configuration_client , ENC_LITTLE_ENDIAN ) ;\n value = tvb_get_guint16 ( tvb , offset , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n {\n bluetooth_uuid_t characteristic_uuid ;\n characteristic_uuid = get_characteristic_uuid_from_handle ( pinfo , handle , bluetooth_data ) ;\n if ( value & 0x1 ) switch ( characteristic_uuid . bt_uuid ) {\n case 0x2A05 : case 0x2A1C : case 0x2A21 : case 0x2A35 : case 0x2A52 : case 0x2A55 : case 0x2A66 : case 0x2A6B : case 0x2A99 : case 0x2A9C : case 0x2A9D : case 0x2A9F : case 0x2ABC : case 0x2AC5 : case 0x2AC6 : case 0x2AC8 : case 0x2AC9 : case 0x2ACC : case 0x2AD4 : case 0x2AD5 : case 0x2AD6 : case 0x2AD7 : case 0x2AD8 : case 0x2AD9 : expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n break ;\n case 0x2A18 : case 0x2A19 : case 0x2A1E : case 0x2A22 : case 0x2A2C : case 0x2A2B : case 0x2A31 : case 0x2A33 : case 0x2A34 : case 0x2A36 : case 0x2A37 : case 0x2A3F : case 0x2A45 : case 0x2A46 : case 0x2A4D : case 0x2A53 : case 0x2A56 : case 0x2A58 : case 0x2A5A : case 0x2A5B : case 0x2A63 : case 0x2A64 : case 0x2A67 : case 0x2A68 : case 0x2A6C : case 0x2A6D : case 0x2A6E : case 0x2A6F : case 0x2A70 : case 0x2A71 : case 0x2A72 : case 0x2A73 : case 0x2A74 : case 0x2A75 : case 0x2A76 : case 0x2A77 : case 0x2A78 : case 0x2A79 : case 0x2A7A : case 0x2A7B : case 0x2AA0 : case 0x2AA1 : case 0x2AA3 : case 0x2AA7 : case 0x2AB8 : case 0x2ACD : case 0x2ACE : case 0x2ACF : case 0x2AD0 : case 0x2AD1 : case 0x2AD2 : case 0x2AD3 : case 0x2ADA : default : break ;\n }\n if ( value & 0x2 ) switch ( characteristic_uuid . bt_uuid ) {\n case 0x2A18 : case 0x2A19 : case 0x2A1E : case 0x2A22 : case 0x2A2B : case 0x2A2C : case 0x2A31 : case 0x2A33 : case 0x2A34 : case 0x2A36 : case 0x2A37 : case 0x2A3F : case 0x2A45 : case 0x2A46 : case 0x2A4D : case 0x2A53 : case 0x2A5B : case 0x2A63 : case 0x2A64 : case 0x2A67 : case 0x2A68 : case 0x2A6C : case 0x2A6D : case 0x2A6E : case 0x2A6F : case 0x2A70 : case 0x2A71 : case 0x2A72 : case 0x2A73 : case 0x2A74 : case 0x2A75 : case 0x2A76 : case 0x2A77 : case 0x2A78 : case 0x2A79 : case 0x2A7A : case 0x2A7B : case 0x2AA0 : case 0x2AA1 : case 0x2AA3 : case 0x2AA7 : case 0x2AB8 : case 0x2AC9 : case 0x2ACC : case 0x2ACD : case 0x2ACE : case 0x2ACF : case 0x2AD0 : case 0x2AD1 : case 0x2AD2 : case 0x2AD3 : case 0x2AD4 : case 0x2AD5 : case 0x2AD6 : case 0x2AD7 : case 0x2AD8 : case 0x2ADA : expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n break ;\n case 0x2A05 : case 0x2A1C : case 0x2A21 : case 0x2A35 : case 0x2A52 : case 0x2A55 : case 0x2A56 : case 0x2A58 : case 0x2A5A : case 0x2A66 : case 0x2A6B : case 0x2A99 : case 0x2A9C : case 0x2A9D : case 0x2A9F : case 0x2ABC : case 0x2AC5 : case 0x2AC6 : case 0x2AC8 : case 0x2AD9 : default : break ;\n }\n if ( value > 0x3 ) expert_add_info ( pinfo , tree , & ei_btatt_bad_data ) ;\n }\n break ;\n case 0x2903 : if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_characteristic_configuration_server , ett_btatt_value , hfx_btatt_characteristic_configuration_server , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 0x2904 : if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_characteristic_presentation_format , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_characteristic_presentation_exponent , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_characteristic_presentation_unit , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_characteristic_presentation_namespace , tvb , offset , 1 , ENC_NA ) ;\n value = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n if ( value == 0x01 ) proto_tree_add_item ( tree , hf_btatt_characteristic_presentation_namespace_description_btsig , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n else proto_tree_add_item ( tree , hf_btatt_characteristic_presentation_namespace_description , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 0x2905 : if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n sub_item = proto_tree_add_none_format ( tree , hf_btatt_handles_info , tvb , offset , tvb_captured_length ( tvb ) , \"Handles (%i items)\" , tvb_captured_length ( tvb ) / 2 ) ;\n sub_tree = proto_item_add_subtree ( sub_item , ett_btatt_list ) ;\n while ( offset < ( gint64 ) tvb_captured_length ( tvb ) ) {\n offset = dissect_handle ( sub_tree , pinfo , hf_btatt_handle , tvb , offset , bluetooth_data , NULL , HANDLE_TVB ) ;\n }\n break ;\n case 0x2906 : {\n bluetooth_uuid_t characteristic_uuid ;\n guint8 * characteristic_dissector_name ;\n dissector_handle_t characteristic_dissector ;\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n characteristic_uuid = get_characteristic_uuid_from_handle ( pinfo , handle , bluetooth_data ) ;\n characteristic_dissector_name = wmem_strdup_printf ( wmem_packet_scope ( ) , \"btgatt.uuid0x%s\" , print_numeric_uuid ( & characteristic_uuid ) ) ;\n characteristic_dissector = find_dissector ( characteristic_dissector_name ) ;\n sub_item = proto_tree_add_item ( tree , hf_btatt_valid_range_lower_inclusive_value , tvb , offset , tvb_reported_length_remaining ( tvb , offset ) / 2 , ENC_NA ) ;\n sub_tree = proto_item_add_subtree ( sub_item , ett_btatt_list ) ;\n if ( characteristic_dissector ) call_dissector_with_data ( characteristic_dissector , tvb_new_subset_length_caplen ( tvb , offset , tvb_reported_length_remaining ( tvb , offset ) / 2 , tvb_reported_length_remaining ( tvb , offset ) / 2 ) , pinfo , sub_tree , att_data ) ;\n sub_item = proto_tree_add_item ( tree , hf_btatt_valid_range_upper_inclusive_value , tvb , offset + tvb_reported_length_remaining ( tvb , offset ) / 2 , tvb_reported_length_remaining ( tvb , offset ) / 2 , ENC_NA ) ;\n sub_tree = proto_item_add_subtree ( sub_item , ett_btatt_list ) ;\n if ( characteristic_dissector ) call_dissector_with_data ( characteristic_dissector , tvb_new_subset_length_caplen ( tvb , offset + tvb_reported_length_remaining ( tvb , offset ) / 2 , tvb_reported_length_remaining ( tvb , offset ) / 2 , tvb_reported_length_remaining ( tvb , offset ) / 2 ) , pinfo , sub_tree , att_data ) ;\n offset += tvb_reported_length_remaining ( tvb , offset ) ;\n }\n break ;\n case 0x2907 : if ( service_uuid . bt_uuid == GATT_SERVICE_HUMAN_INTERFACE_DEVICE ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n if ( tvb_reported_length_remaining ( tvb , offset ) == 2 ) {\n proto_tree_add_item ( tree , hf_btatt_uuid16 , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n else if ( tvb_reported_length_remaining ( tvb , offset ) == 16 ) {\n proto_tree_add_item ( tree , hf_btatt_uuid128 , tvb , offset , 16 , ENC_NA ) ;\n offset += 16 ;\n }\n else {\n sub_item = proto_tree_add_item ( tree , hf_btatt_value , tvb , offset , - 1 , ENC_NA ) ;\n expert_add_info ( pinfo , sub_item , & ei_btatt_bad_data ) ;\n offset = tvb_captured_length ( tvb ) ;\n }\n break ;\n case 0x2908 : if ( service_uuid . bt_uuid == GATT_SERVICE_HUMAN_INTERFACE_DEVICE ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_report_reference_report_id , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_report_reference_report_type , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2909 : if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_number_of_digitals , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x290A : if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_value_trigger_setting_condition , tvb , offset , 1 , ENC_NA ) ;\n value = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n if ( value >= 1 && value <= 3 ) {\n proto_tree_add_item ( tree , hf_btatt_value_trigger_setting_analog , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n else if ( value == 4 ) {\n call_dissector_with_data ( find_dissector ( \"btgatt.uuid0x2a56\" ) , tvb_new_subset_length_caplen ( tvb , offset , 1 , 1 ) , pinfo , tree , att_data ) ;\n offset += 1 ;\n }\n else if ( value == 5 || value == 6 ) {\n proto_tree_add_item ( tree , hf_btatt_value_trigger_setting_analog_one , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_value_trigger_setting_analog_two , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n break ;\n case 0x290B : if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_esp_trigger_logic , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x290C : if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_esp_flags , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_esp_sampling_function , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_esp_measurement_period , tvb , offset , 3 , ENC_LITTLE_ENDIAN ) ;\n offset += 3 ;\n proto_tree_add_item ( tree , hf_btatt_esp_update_interval , tvb , offset , 3 , ENC_LITTLE_ENDIAN ) ;\n offset += 3 ;\n proto_tree_add_item ( tree , hf_btatt_esp_application , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_esp_measurement_uncertainty , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x290D : if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_esp_condition , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_esp_operand , tvb , offset , tvb_captured_length_remaining ( tvb , offset ) , ENC_NA ) ;\n offset += tvb_captured_length_remaining ( tvb , offset ) ;\n break ;\n case 0x290E : if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_time_trigger_setting_condition , tvb , offset , 1 , ENC_NA ) ;\n value = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n if ( value == 0 ) {\n proto_tree_add_item ( tree , hf_btatt_time_trigger_setting_value , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n }\n else if ( value == 1 || value == 2 ) {\n proto_tree_add_item ( tree , hf_btatt_time_trigger_setting_value_time_interval , tvb , offset , 3 , ENC_LITTLE_ENDIAN ) ;\n offset += 3 ;\n }\n else if ( value == 3 ) {\n proto_tree_add_item ( tree , hf_btatt_time_trigger_setting_value_count , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n break ;\n case 0x2A00 : if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_device_name , tvb , offset , tvb_captured_length_remaining ( tvb , offset ) , ENC_NA | ENC_UTF_8 ) ;\n offset += tvb_captured_length_remaining ( tvb , offset ) ;\n break ;\n case 0x2A01 : if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n switch ( ( tvb_get_guint16 ( tvb , offset , ENC_LITTLE_ENDIAN ) & 0xFFC0 ) >> 6 ) {\n case 0x003 : hfs = hfx_btatt_appearance_watch ;\n break ;\n case 0x00C : hfs = hfx_btatt_appearance_thermometer ;\n break ;\n case 0x00D : hfs = hfx_btatt_appearance_heart_rate ;\n break ;\n case 0x00E : hfs = hfx_btatt_appearance_blood_pressure ;\n break ;\n case 0x00F : hfs = hfx_btatt_appearance_hid ;\n break ;\n case 0x011 : hfs = hfx_btatt_appearance_running_walking_sensor ;\n break ;\n case 0x012 : hfs = hfx_btatt_appearance_cycling ;\n break ;\n case 0x031 : hfs = hfx_btatt_appearance_pulse_oximeter ;\n break ;\n case 0x033 : hfs = hfx_btatt_appearance_personal_mobility_device ;\n break ;\n case 0x035 : hfs = hfx_btatt_appearance_insulin_pump ;\n break ;\n case 0x051 : hfs = hfx_btatt_appearance_outdoor_sports_activity ;\n break ;\n default : hfs = hfx_btatt_appearance ;\n }\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_appearance , ett_btatt_value , hfs , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 0x2A02 : if ( service_uuid . bt_uuid == GATT_SERVICE_GENERIC_ACCESS_PROFILE ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_peripheral_privacy_flag , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A03 : if ( service_uuid . bt_uuid == GATT_SERVICE_GENERIC_ACCESS_PROFILE ) {\n if ( is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n offset = dissect_bd_addr ( hf_btatt_reconnection_address , pinfo , tree , tvb , offset , FALSE , bluetooth_data -> interface_id , bluetooth_data -> adapter_id , NULL ) ;\n break ;\n case 0x2A04 : if ( service_uuid . bt_uuid == GATT_SERVICE_GENERIC_ACCESS_PROFILE ) {\n if ( ! ( is_readable_request ( att_data -> opcode ) || is_readable_response ( att_data -> opcode ) ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_minimum_connection_interval , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_maximum_connection_interval , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_slave_latency , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_connection_supervision_timeout_multiplier , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 0x2A05 : if ( service_uuid . bt_uuid == GATT_SERVICE_GENERIC_ATTRIBUTE_PROFILE ) {\n if ( att_data -> opcode == ATT_OPCODE_HANDLE_VALUE_CONFIRMATION ) break ;\n if ( att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_INDICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_starting_handle , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_ending_handle , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 0x2A06 : if ( service_uuid . bt_uuid == GATT_SERVICE_IMMEDIATE_ALERT ) {\n if ( att_data -> opcode != ATT_OPCODE_WRITE_COMMAND ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n else if ( service_uuid . bt_uuid == GATT_SERVICE_LINK_LOSS ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_alert_level , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A07 : if ( service_uuid . bt_uuid == GATT_SERVICE_TX_POWER ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_tx_power_level , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A08 : if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_year , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_month , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_day , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_hours , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_minutes , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_seconds , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A09 : if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_day_of_week , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A0A : case 0x2A0B : case 0x2A0C : case 0x2A2B : if ( uuid . bt_uuid == 0x2A2B ) {\n if ( service_uuid . bt_uuid == GATT_SERVICE_CURRENT_TIME_SERVICE ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_year , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_month , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_day , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_hours , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_minutes , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_seconds , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_day_of_week , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n if ( uuid . bt_uuid == 0x2A0C || uuid . bt_uuid == 0x2A2B ) {\n proto_tree_add_item ( tree , hf_btatt_fractions256 , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n }\n else if ( uuid . bt_uuid == 0x2A0B ) {\n proto_tree_add_item ( tree , hf_btatt_fractions100 , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n }\n if ( uuid . bt_uuid == 0x2A2B ) {\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_time_adjust_reason , ett_btatt_value , hfx_btatt_time_adjust_reason , ENC_NA ) ;\n offset += 1 ;\n }\n break ;\n case 0x2A0D : if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_dst_offset , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A0E : if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_timezone , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A0F : case 0x2A10 : if ( service_uuid . bt_uuid == GATT_SERVICE_CURRENT_TIME_SERVICE ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n if ( uuid . bt_uuid == 0x2A10 ) {\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_timezone_information , ett_btatt_value , hfx_btatt_timezone_information , ENC_NA ) ;\n offset += 1 ;\n }\n proto_tree_add_item ( tree , hf_btatt_timezone , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_dst_offset , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A11 : if ( service_uuid . bt_uuid == GATT_SERVICE_NEXT_DST_CHANGE_SERVICE ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_year , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_month , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_day , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_hours , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_minutes , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_seconds , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_dst_offset , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A12 : if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_time_accuracy , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A13 : if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_time_source , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A14 : if ( service_uuid . bt_uuid == GATT_SERVICE_CURRENT_TIME_SERVICE ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_time_source , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_time_accuracy , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_time_days_since_update , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_time_hours_since_update , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A15 : if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n call_dissector_with_data ( find_dissector ( \"btgatt.uuid0x2A0C\" ) , tvb_new_subset_length_caplen ( tvb , offset , 9 , 9 ) , pinfo , tree , att_data ) ;\n offset += 9 ;\n call_dissector_with_data ( find_dissector ( \"btgatt.uuid0x2A0F\" ) , tvb_new_subset_length_caplen ( tvb , offset , 2 , 2 ) , pinfo , tree , att_data ) ;\n offset += 2 ;\n call_dissector_with_data ( find_dissector ( \"btgatt.uuid0x2A14\" ) , tvb_new_subset_length_caplen ( tvb , offset , 4 , 4 ) , pinfo , tree , att_data ) ;\n offset += 4 ;\n break ;\n case 0x2A16 : if ( service_uuid . bt_uuid == GATT_SERVICE_REFERENCE_TIME_UPDATE_SERVICE ) {\n if ( att_data -> opcode != ATT_OPCODE_WRITE_COMMAND ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_time_update_control_point , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A17 : if ( service_uuid . bt_uuid == GATT_SERVICE_REFERENCE_TIME_UPDATE_SERVICE ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_time_current_state , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_time_result , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A18 : if ( service_uuid . bt_uuid == GATT_SERVICE_GLUCOSE ) {\n if ( att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_glucose_measurement_flags , ett_btatt_value , hfx_btatt_glucose_measurement_flags , ENC_NA ) ;\n flags = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_glucose_measurement_sequence_number , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n sub_item = proto_tree_add_item ( tree , hf_btatt_glucose_measurement_base_time , tvb , offset , 7 , ENC_NA ) ;\n sub_tree = proto_item_add_subtree ( sub_item , ett_btatt_list ) ;\n proto_tree_add_item ( sub_tree , hf_btatt_year , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( sub_tree , hf_btatt_month , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_day , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_hours , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_minutes , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_seconds , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n if ( flags & 0x01 ) {\n proto_tree_add_item ( tree , hf_btatt_glucose_measurement_time_offset , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( ( flags & 0x02 ) && ! ( flags & 0x04 ) ) {\n proto_tree_add_item ( tree , hf_btatt_glucose_measurement_glucose_concentration_kg_per_l , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( ( flags & 0x02 ) && ( flags & 0x04 ) ) {\n proto_tree_add_item ( tree , hf_btatt_glucose_measurement_glucose_concentration_mol_per_l , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( flags & 0x02 ) {\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_glucose_measurement_type_and_sample_location , ett_btatt_value , hfx_btatt_glucose_measurement_type_and_sample_location , ENC_NA ) ;\n offset += 1 ;\n }\n if ( flags & 0x08 ) {\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_glucose_measurement_sensor_status_annunciation , ett_btatt_value , hfx_btatt_glucose_measurement_sensor_status_annunciation , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n break ;\n case 0x2A19 : {\n if ( service_uuid . bt_uuid == GATT_SERVICE_BATTERY_SERVICE ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n guint32 battery_level ;\n sub_item = proto_tree_add_item_ret_uint ( tree , hf_btatt_battery_level , tvb , offset , 1 , ENC_NA , & battery_level ) ;\n if ( battery_level > 100 ) expert_add_info ( pinfo , sub_item , & ei_btatt_bad_data ) ;\n offset += 1 ;\n }\n break ;\n case 0x2A1A : if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_battery_power_state , ett_btatt_value , hfx_btatt_battery_power_state , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A1B : {\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n guint32 battery_level ;\n sub_item = proto_tree_add_item_ret_uint ( tree , hf_btatt_battery_level , tvb , offset , 1 , ENC_NA , & battery_level ) ;\n if ( battery_level > 100 ) expert_add_info ( pinfo , sub_item , & ei_btatt_bad_data ) ;\n offset += 1 ;\n if ( tvb_reported_length_remaining ( tvb , offset ) >= 1 ) {\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_battery_power_state , ett_btatt_value , hfx_btatt_battery_power_state , ENC_NA ) ;\n offset += 1 ;\n }\n }\n break ;\n case 0x2A1C : case 0x2A1E : if ( uuid . bt_uuid == 0x2A1C ) {\n if ( service_uuid . bt_uuid == GATT_SERVICE_HEALTH_THERMOMETER ) {\n if ( att_data -> opcode == ATT_OPCODE_HANDLE_VALUE_CONFIRMATION ) break ;\n if ( att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_INDICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n }\n else if ( uuid . bt_uuid == 0x2A1E ) {\n if ( service_uuid . bt_uuid == GATT_SERVICE_HEALTH_THERMOMETER ) {\n if ( att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_temperature_measurement_flags , ett_btatt_value , hfx_btatt_temperature_measurement_flags , ENC_NA ) ;\n flags = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n if ( flags & 0x01 ) {\n proto_tree_add_item ( tree , hf_btatt_temperature_measurement_value_celsius , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n }\n else {\n proto_tree_add_item ( tree , hf_btatt_temperature_measurement_value_fahrenheit , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n }\n if ( flags & 0x02 ) {\n sub_item = proto_tree_add_item ( tree , hf_btatt_temperature_measurement_timestamp , tvb , offset , 7 , ENC_NA ) ;\n sub_tree = proto_item_add_subtree ( sub_item , ett_btatt_list ) ;\n proto_tree_add_item ( sub_tree , hf_btatt_year , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( sub_tree , hf_btatt_month , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_day , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_hours , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_minutes , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_seconds , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n }\n if ( flags & 0x04 ) {\n proto_tree_add_item ( tree , hf_btatt_temperature_type , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n }\n break ;\n case 0x2A1D : if ( service_uuid . bt_uuid == GATT_SERVICE_HEALTH_THERMOMETER ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_temperature_type , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A21 : if ( service_uuid . bt_uuid == GATT_SERVICE_HEALTH_THERMOMETER ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) || att_data -> opcode == ATT_OPCODE_HANDLE_VALUE_CONFIRMATION ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_INDICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_measurement_interval , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 0x2A22 : if ( service_uuid . bt_uuid == GATT_SERVICE_HUMAN_INTERFACE_DEVICE ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n call_dissector_with_data ( usb_hid_boot_keyboard_input_report_handle , tvb_new_subset_remaining ( tvb , offset ) , pinfo , tree , NULL ) ;\n offset += tvb_reported_length_remaining ( tvb , offset ) ;\n break ;\n case 0x2A23 : if ( service_uuid . bt_uuid == GATT_SERVICE_DEVICE_INFORMATION ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_system_id_manufacturer_identifier , tvb , offset , 5 , ENC_LITTLE_ENDIAN ) ;\n offset += 5 ;\n proto_tree_add_item ( tree , hf_btatt_system_id_organizationally_unique_identifier , tvb , offset , 3 , ENC_LITTLE_ENDIAN ) ;\n offset += 3 ;\n break ;\n case 0x2A24 : if ( service_uuid . bt_uuid == GATT_SERVICE_DEVICE_INFORMATION ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_model_number_string , tvb , offset , tvb_captured_length_remaining ( tvb , offset ) , ENC_NA | ENC_UTF_8 ) ;\n offset += tvb_captured_length_remaining ( tvb , offset ) ;\n break ;\n case 0x2A25 : if ( service_uuid . bt_uuid == GATT_SERVICE_DEVICE_INFORMATION ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_serial_number_string , tvb , offset , tvb_captured_length_remaining ( tvb , offset ) , ENC_NA | ENC_UTF_8 ) ;\n offset += tvb_captured_length_remaining ( tvb , offset ) ;\n break ;\n case 0x2A26 : if ( service_uuid . bt_uuid == GATT_SERVICE_DEVICE_INFORMATION ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_firmware_revision_string , tvb , offset , tvb_captured_length_remaining ( tvb , offset ) , ENC_NA | ENC_UTF_8 ) ;\n offset += tvb_captured_length_remaining ( tvb , offset ) ;\n break ;\n case 0x2A27 : if ( service_uuid . bt_uuid == GATT_SERVICE_DEVICE_INFORMATION ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_hardware_revision_string , tvb , offset , tvb_captured_length_remaining ( tvb , offset ) , ENC_NA | ENC_UTF_8 ) ;\n offset += tvb_captured_length_remaining ( tvb , offset ) ;\n break ;\n case 0x2A28 : if ( service_uuid . bt_uuid == GATT_SERVICE_DEVICE_INFORMATION ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_software_revision_string , tvb , offset , tvb_captured_length_remaining ( tvb , offset ) , ENC_NA | ENC_UTF_8 ) ;\n offset += tvb_captured_length_remaining ( tvb , offset ) ;\n break ;\n case 0x2A29 : if ( service_uuid . bt_uuid == GATT_SERVICE_DEVICE_INFORMATION ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_manufacturer_string , tvb , offset , tvb_captured_length_remaining ( tvb , offset ) , ENC_NA | ENC_UTF_8 ) ;\n offset += tvb_captured_length_remaining ( tvb , offset ) ;\n break ;\n case 0x2A2A : {\n guint16 count ;\n guint16 list_length = 0 ;\n if ( service_uuid . bt_uuid == GATT_SERVICE_DEVICE_INFORMATION ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_regulatory_certification_data_list_count , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n count = tvb_get_guint16 ( tvb , offset , ENC_LITTLE_ENDIAN ) ;\n list_length += 2 ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_regulatory_certification_data_list_length , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n list_length += 2 ;\n offset += 2 ;\n while ( count -- ) {\n proto_item * authorizing_body_data_item ;\n proto_tree * authorizing_body_data_tree ;\n guint8 item_type ;\n guint16 item_length ;\n guint16 certification_data_list_count = 0 ;\n guint16 certification_data_list_length = 0 ;\n proto_item * list_length_item ;\n sub_item = proto_tree_add_item ( tree , hf_btatt_regulatory_certification_data_list_item , tvb , offset , 0 , ENC_NA ) ;\n sub_tree = proto_item_add_subtree ( sub_item , ett_btatt_list ) ;\n proto_tree_add_item ( sub_tree , hf_btatt_regulatory_certification_data_list_item_body , tvb , offset , 1 , ENC_NA ) ;\n list_length += 1 ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_regulatory_certification_data_list_item_body_structure_type , tvb , offset , 1 , ENC_NA ) ;\n item_type = tvb_get_guint8 ( tvb , offset ) ;\n list_length += 1 ;\n offset += 1 ;\n list_length_item = proto_tree_add_item ( sub_tree , hf_btatt_regulatory_certification_data_list_item_body_structure_length , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n item_length = tvb_get_guint16 ( tvb , offset , ENC_LITTLE_ENDIAN ) ;\n list_length += 2 + item_length ;\n offset += 2 ;\n if ( item_type == 0x01 ) {\n authorizing_body_data_item = proto_tree_add_item ( sub_tree , hf_btatt_regulatory_certification_data_list_item_authorizing_body_data , tvb , offset , item_length , ENC_NA ) ;\n authorizing_body_data_tree = proto_item_add_subtree ( authorizing_body_data_item , ett_btatt_list ) ;\n if ( item_length > 0 ) {\n proto_tree_add_item ( authorizing_body_data_tree , hf_btatt_regulatory_certification_data_list_item_authorizing_body_data_major_ig_version , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n }\n if ( item_length > 1 ) {\n proto_tree_add_item ( authorizing_body_data_tree , hf_btatt_regulatory_certification_data_list_item_authorizing_body_data_minor_ig_version , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n }\n if ( item_length > 2 ) {\n proto_tree_add_item ( authorizing_body_data_tree , hf_btatt_regulatory_certification_data_list_item_authorizing_body_data_certification_data_list_count , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n certification_data_list_count = tvb_get_guint16 ( tvb , offset , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( item_length > 4 ) {\n proto_tree_add_item ( authorizing_body_data_tree , hf_btatt_regulatory_certification_data_list_item_authorizing_body_data_certification_data_list_length , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n certification_data_list_length = tvb_get_guint16 ( tvb , offset , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( item_length > 6 && certification_data_list_count ) {\n proto_item * certification_data_list_item ;\n proto_tree * certification_data_list_tree ;\n certification_data_list_item = proto_tree_add_item ( sub_tree , hf_btatt_regulatory_certification_data_list_item_authorizing_body_data_certification_data_list , tvb , offset , certification_data_list_length , ENC_NA ) ;\n certification_data_list_tree = proto_item_add_subtree ( certification_data_list_item , ett_btatt_list ) ;\n while ( certification_data_list_count -- ) {\n proto_tree_add_item ( certification_data_list_tree , hf_btatt_regulatory_certification_data_list_item_authorizing_body_data_certified_device_class , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n }\n }\n else if ( item_type == 0x02 ) {\n proto_tree_add_item ( sub_tree , hf_btatt_regulatory_certification_data_list_item_regulation_bit_field_type , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n else {\n proto_tree_add_item ( sub_tree , hf_btatt_regulatory_certification_data_list_item_data , tvb , offset , item_length , ENC_NA ) ;\n offset += item_length ;\n }\n proto_item_set_len ( sub_item , 1 + 1 + 2 + item_length ) ;\n if ( list_length != length ) expert_add_info ( pinfo , list_length_item , & ei_btatt_invalid_length ) ;\n }\n }\n break ;\n case 0x2A2C : if ( service_uuid . bt_uuid == GATT_SERVICE_ENVIRONMENTAL_SENSING ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_magnetic_declination , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 0x2A31 : if ( service_uuid . bt_uuid == GATT_SERVICE_SCAN_PARAMETERS ) {\n if ( att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_scan_refresh , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A32 : if ( service_uuid . bt_uuid == GATT_SERVICE_HUMAN_INTERFACE_DEVICE ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_WRITE_COMMAND ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n call_dissector_with_data ( usb_hid_boot_keyboard_output_report_handle , tvb_new_subset_remaining ( tvb , offset ) , pinfo , tree , NULL ) ;\n offset += tvb_reported_length_remaining ( tvb , offset ) ;\n break ;\n case 0x2A33 : if ( service_uuid . bt_uuid == GATT_SERVICE_HUMAN_INTERFACE_DEVICE ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n call_dissector_with_data ( usb_hid_boot_mouse_input_report_handle , tvb_new_subset_remaining ( tvb , offset ) , pinfo , tree , NULL ) ;\n offset += tvb_reported_length_remaining ( tvb , offset ) ;\n break ;\n case 0x2A34 : if ( service_uuid . bt_uuid == GATT_SERVICE_GLUCOSE ) {\n if ( att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_glucose_measurement_context_flags , ett_btatt_value , hfx_btatt_glucose_measurement_context_flags , ENC_NA ) ;\n flags = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_glucose_measurement_context_sequence_number , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n if ( flags & 0x80 ) {\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_glucose_measurement_context_extended_flags , ett_btatt_value , hfx_btatt_glucose_measurement_context_extended_flags , ENC_NA ) ;\n offset += 1 ;\n }\n if ( flags & 0x01 ) {\n proto_tree_add_item ( tree , hf_btatt_glucose_measurement_context_carbohydrate_id , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_glucose_measurement_context_carbohydrate_kg , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( flags & 0x02 ) {\n proto_tree_add_item ( tree , hf_btatt_glucose_measurement_context_meal , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n }\n if ( flags & 0x04 ) {\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_glucose_measurement_context_tester_health , ett_btatt_value , hfx_btatt_glucose_measurement_context_tester_health , ENC_NA ) ;\n offset += 1 ;\n }\n if ( flags & 0x08 ) {\n proto_tree_add_item ( tree , hf_btatt_glucose_measurement_context_exercise_duration , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_glucose_measurement_context_exercise_intensity , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n }\n if ( flags & 0x10 ) {\n proto_tree_add_item ( tree , hf_btatt_glucose_measurement_context_medication_id , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n if ( flags & 0x20 ) {\n proto_tree_add_item ( tree , hf_btatt_glucose_measurement_context_medication_l , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n else {\n proto_tree_add_item ( tree , hf_btatt_glucose_measurement_context_medication_kg , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n }\n if ( flags & 0x40 ) {\n proto_tree_add_item ( tree , hf_btatt_glucose_measurement_context_hba1c , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n break ;\n case 0x2A35 : case 0x2A36 : if ( uuid . bt_uuid == 0x2A35 ) {\n if ( service_uuid . bt_uuid == GATT_SERVICE_BLOOD_PRESSURE ) {\n if ( att_data -> opcode == ATT_OPCODE_HANDLE_VALUE_CONFIRMATION ) break ;\n if ( att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_INDICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n }\n else if ( uuid . bt_uuid == 0x2A36 ) {\n if ( service_uuid . bt_uuid == GATT_SERVICE_BLOOD_PRESSURE ) {\n if ( att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_blood_pressure_measurement_flags , ett_btatt_value , hfx_btatt_blood_pressure_measurement_flags , ENC_NA ) ;\n flags = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n if ( flags & 0x01 ) {\n proto_tree_add_item ( tree , hf_btatt_blood_pressure_measurement_compound_value_systolic_kpa , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_blood_pressure_measurement_compound_value_diastolic_kpa , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_blood_pressure_measurement_compound_value_mean_arterial_pressure_kpa , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n else {\n proto_tree_add_item ( tree , hf_btatt_blood_pressure_measurement_compound_value_systolic_mmhg , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_blood_pressure_measurement_compound_value_diastolic_mmhg , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_blood_pressure_measurement_compound_value_mean_arterial_pressure_mmhg , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( flags & 0x02 ) {\n sub_item = proto_tree_add_item ( tree , hf_btatt_blood_pressure_measurement_timestamp , tvb , offset , 7 , ENC_NA ) ;\n sub_tree = proto_item_add_subtree ( sub_item , ett_btatt_list ) ;\n proto_tree_add_item ( sub_tree , hf_btatt_year , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( sub_tree , hf_btatt_month , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_day , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_hours , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_minutes , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_seconds , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n }\n if ( flags & 0x04 ) {\n proto_tree_add_item ( tree , hf_btatt_blood_pressure_measurement_pulse_rate , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( flags & 0x08 ) {\n proto_tree_add_item ( tree , hf_btatt_blood_pressure_measurement_user_id , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n }\n if ( flags & 0x10 ) {\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_blood_pressure_measurement_status , ett_btatt_value , hfx_btatt_blood_pressure_measurement_status , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n break ;\n case 0x2A37 : if ( service_uuid . bt_uuid == GATT_SERVICE_HEART_RATE ) {\n if ( att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_heart_rate_measurement_flags , ett_btatt_value , hfx_btatt_heart_rate_measurement_flags , ENC_NA ) ;\n flags = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n if ( flags & 0x01 ) {\n proto_tree_add_item ( tree , hf_btatt_heart_rate_measurement_value_16 , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n else {\n proto_tree_add_item ( tree , hf_btatt_heart_rate_measurement_value_8 , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n }\n if ( flags & 0x08 ) {\n proto_tree_add_item ( tree , hf_btatt_heart_rate_measurement_energy_expended , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( flags & 0x10 ) {\n guint interval_count = 0 ;\n sub_item = proto_tree_add_item ( tree , hf_btatt_heart_rate_measurement_rr_intervals , tvb , offset , tvb_captured_length_remaining ( tvb , offset ) , ENC_NA ) ;\n sub_tree = proto_item_add_subtree ( sub_item , ett_btatt_list ) ;\n while ( tvb_reported_length_remaining ( tvb , offset ) ) {\n proto_tree_add_item ( sub_tree , hf_btatt_heart_rate_measurement_rr_interval , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n interval_count += 1 ;\n }\n proto_item_append_text ( sub_item , \" [count = %2u]\" , interval_count ) ;\n }\n break ;\n case 0x2A38 : if ( service_uuid . bt_uuid == GATT_SERVICE_HEART_RATE ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_body_sensor_location , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A39 : if ( service_uuid . bt_uuid == GATT_SERVICE_HEART_RATE ) {\n if ( is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_heart_rate_control_point , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A3F : if ( service_uuid . bt_uuid == GATT_SERVICE_PHONE_ALERT_STATUS_SERVICE ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_alert_status , ett_btatt_value , hfx_btatt_alert_status , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A40 : if ( service_uuid . bt_uuid == GATT_SERVICE_PHONE_ALERT_STATUS_SERVICE ) {\n if ( att_data -> opcode != ATT_OPCODE_WRITE_COMMAND ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_ringer_control_point , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A41 : if ( service_uuid . bt_uuid == GATT_SERVICE_PHONE_ALERT_STATUS_SERVICE ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_ringer_setting , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A42 : case 0x2A47 : case 0x2A48 : if ( uuid . bt_uuid == 0x2A47 || uuid . bt_uuid == 0x2A48 ) {\n if ( service_uuid . bt_uuid == GATT_SERVICE_ALERT_NOTIFICATION_SERVICE ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_alert_category_id_bitmask_1 , ett_btatt_value , hfx_btatt_alert_category_id_bitmask_1 , ENC_NA ) ;\n offset += 1 ;\n if ( tvb_reported_length_remaining ( tvb , offset ) >= 1 ) {\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_alert_category_id_bitmask_2 , ett_btatt_value , hfx_btatt_alert_category_id_bitmask_2 , ENC_NA ) ;\n offset += 1 ;\n }\n break ;\n case 0x2A43 : if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_alert_category_id , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A44 : if ( service_uuid . bt_uuid == GATT_SERVICE_ALERT_NOTIFICATION_SERVICE ) {\n if ( is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_alert_command_id , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_alert_category_id , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A45 : if ( service_uuid . bt_uuid == GATT_SERVICE_ALERT_NOTIFICATION_SERVICE ) {\n if ( att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_alert_category_id , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_alert_unread_count , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A46 : if ( service_uuid . bt_uuid == GATT_SERVICE_ALERT_NOTIFICATION_SERVICE ) {\n if ( att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_alert_category_id , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_alert_number_of_new_alert , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n if ( tvb_reported_length_remaining ( tvb , offset ) > 0 ) {\n proto_tree_add_item ( tree , hf_btatt_alert_text_string_information , tvb , offset , tvb_captured_length_remaining ( tvb , offset ) , ENC_NA | ENC_UTF_8 ) ;\n offset += tvb_captured_length_remaining ( tvb , offset ) ;\n }\n break ;\n case 0x2A49 : if ( service_uuid . bt_uuid == GATT_SERVICE_BLOOD_PRESSURE ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_blood_pressure_feature , ett_btatt_value , hfx_btatt_blood_pressure_feature , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 0x2A4A : if ( service_uuid . bt_uuid == GATT_SERVICE_HUMAN_INTERFACE_DEVICE ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_hogp_bcd_hid , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_hogp_b_country_code , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_hogp_flags , ett_btatt_value , hfx_btatt_hogp_flags , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A4B : if ( service_uuid . bt_uuid == GATT_SERVICE_HUMAN_INTERFACE_DEVICE ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n offset = dissect_usb_hid_get_report_descriptor ( pinfo , tree , tvb , offset , NULL ) ;\n break ;\n case 0x2A4C : if ( service_uuid . bt_uuid == GATT_SERVICE_HUMAN_INTERFACE_DEVICE ) {\n if ( att_data -> opcode != ATT_OPCODE_WRITE_COMMAND ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_hogp_hid_control_point_command , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A4D : if ( service_uuid . bt_uuid == GATT_SERVICE_HUMAN_INTERFACE_DEVICE ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_WRITE_COMMAND && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n sub_item = proto_tree_add_item ( tree , hf_btatt_value , tvb , offset , - 1 , ENC_NA ) ;\n expert_add_info ( pinfo , sub_item , & ei_btatt_undecoded ) ;\n offset = tvb_captured_length ( tvb ) ;\n break ;\n case 0x2A4E : if ( service_uuid . bt_uuid == GATT_SERVICE_HUMAN_INTERFACE_DEVICE ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_WRITE_COMMAND ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_hogp_protocol_mode , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A4F : if ( service_uuid . bt_uuid == GATT_SERVICE_SCAN_PARAMETERS ) {\n if ( att_data -> opcode != ATT_OPCODE_WRITE_COMMAND ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_le_scan_interval , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_le_scan_window , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 0x2A50 : if ( service_uuid . bt_uuid == GATT_SERVICE_DEVICE_INFORMATION ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_pnp_id_vendor_id_source , tvb , offset , 1 , ENC_NA ) ;\n value = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n if ( value == 1 ) proto_tree_add_item ( tree , hf_btatt_pnp_id_vendor_id_bluetooth_sig , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n else if ( value == 2 ) proto_tree_add_item ( tree , hf_btatt_pnp_id_vendor_id_usb_forum , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n else proto_tree_add_item ( tree , hf_btatt_pnp_id_vendor_id , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_pnp_id_product_id , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_pnp_id_product_version , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 0x2A51 : if ( service_uuid . bt_uuid == GATT_SERVICE_GLUCOSE ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_glucose_feature , ett_btatt_value , hfx_btatt_glucose_feature , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 0x2A52 : if ( service_uuid . bt_uuid == GATT_SERVICE_GLUCOSE || service_uuid . bt_uuid == GATT_SERVICE_CONTINUOUS_GLUCOSE_MONITORING || service_uuid . bt_uuid == GATT_SERVICE_PULSE_OXIMETER ) {\n if ( is_writeable_response ( att_data -> opcode ) || att_data -> opcode == ATT_OPCODE_HANDLE_VALUE_CONFIRMATION ) break ;\n if ( ! is_writeable_request ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_INDICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_record_access_control_point_opcode , tvb , offset , 1 , ENC_NA ) ;\n opcode = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_record_access_control_point_operator , tvb , offset , 1 , ENC_NA ) ;\n operator_value = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n sub_item = proto_tree_add_item ( tree , hf_btatt_record_access_control_point_operand , tvb , offset , 0 , ENC_NA ) ;\n sub_tree = proto_item_add_subtree ( sub_item , ett_btatt_list ) ;\n operand_offset = offset ;\n switch ( opcode ) {\n case 1 : case 2 : case 4 : switch ( operator_value ) {\n case 0 : case 1 : case 5 : case 6 : break ;\n case 2 : proto_tree_add_item ( sub_tree , hf_btatt_record_access_control_point_operand_filter_type , tvb , offset , 1 , ENC_NA ) ;\n value = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n if ( value == 0x01 ) {\n proto_tree_add_item ( sub_tree , hf_btatt_record_access_control_point_operand_max_time_offset , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n else {\n proto_tree_add_item ( sub_tree , hf_btatt_value , tvb , offset , - 1 , ENC_NA ) ;\n offset = tvb_captured_length ( tvb ) ;\n }\n break ;\n case 3 : proto_tree_add_item ( sub_tree , hf_btatt_record_access_control_point_operand_filter_type , tvb , offset , 1 , ENC_NA ) ;\n value = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n if ( value == 0x01 ) {\n proto_tree_add_item ( sub_tree , hf_btatt_record_access_control_point_operand_min_time_offset , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n else {\n proto_tree_add_item ( sub_tree , hf_btatt_value , tvb , offset , - 1 , ENC_NA ) ;\n offset = tvb_captured_length ( tvb ) ;\n }\n break ;\n case 4 : proto_tree_add_item ( sub_tree , hf_btatt_record_access_control_point_operand_filter_type , tvb , offset , 1 , ENC_NA ) ;\n value = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n if ( value == 0x01 ) {\n proto_tree_add_item ( sub_tree , hf_btatt_record_access_control_point_operand_min_time_offset , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( sub_tree , hf_btatt_record_access_control_point_operand_max_time_offset , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n else {\n proto_tree_add_item ( sub_tree , hf_btatt_value , tvb , offset , - 1 , ENC_NA ) ;\n offset = tvb_captured_length ( tvb ) ;\n }\n break ;\n }\n break ;\n case 3 : break ;\n case 5 : proto_tree_add_item ( sub_tree , hf_btatt_record_access_control_point_operand_number_of_records , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 6 : proto_tree_add_item ( sub_tree , hf_btatt_record_access_control_point_request_opcode , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_record_access_control_point_response_code , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n }\n ;\n proto_item_set_len ( sub_item , offset - operand_offset ) ;\n break ;\n case 0x2A53 : if ( service_uuid . bt_uuid == GATT_SERVICE_RUNNING_SPEED_AND_CADENCE ) {\n if ( att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_rsc_measurement_flags , ett_btatt_value , hfx_btatt_rsc_measurement_flags , ENC_NA ) ;\n flags = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_rsc_measurement_instantaneous_speed , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_rsc_measurement_instantaneous_cadence , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n if ( flags & 0x01 ) {\n proto_tree_add_item ( tree , hf_btatt_rsc_measurement_instantaneous_stride_length , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( flags & 0x02 ) {\n proto_tree_add_item ( tree , hf_btatt_rsc_measurement_total_distance , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n }\n break ;\n case 0x2A54 : if ( service_uuid . bt_uuid == GATT_SERVICE_RUNNING_SPEED_AND_CADENCE ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_rsc_feature , ett_btatt_value , hfx_btatt_rsc_feature , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 0x2A55 : if ( service_uuid . bt_uuid == GATT_SERVICE_RUNNING_SPEED_AND_CADENCE || service_uuid . bt_uuid == GATT_SERVICE_CYCLING_SPEED_AND_CADENCE ) {\n if ( is_writeable_response ( att_data -> opcode ) || att_data -> opcode == ATT_OPCODE_HANDLE_VALUE_CONFIRMATION ) break ;\n if ( ! is_writeable_request ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_INDICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_sc_control_point_opcode , tvb , offset , 1 , ENC_NA ) ;\n opcode = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n switch ( opcode ) {\n case 1 : proto_tree_add_item ( tree , hf_btatt_sc_control_point_cumulative_value , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n break ;\n case 3 : proto_tree_add_item ( tree , hf_btatt_sensor_location , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 16 : proto_tree_add_item ( tree , hf_btatt_sc_control_point_request_opcode , tvb , offset , 1 , ENC_NA ) ;\n value = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_sc_control_point_response_value , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n if ( value == 0x04 && tvb_get_guint8 ( tvb , offset ) == 0x01 ) {\n while ( tvb_captured_length_remaining ( tvb , offset ) ) {\n proto_tree_add_item ( tree , hf_btatt_sensor_location , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n }\n }\n break ;\n case 2 : case 4 : break ;\n }\n break ;\n case 0x2A56 : if ( service_uuid . bt_uuid == GATT_SERVICE_AUTOMATION_IO ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) || att_data -> opcode == ATT_OPCODE_HANDLE_VALUE_CONFIRMATION ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_WRITE_COMMAND && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_digital , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A58 : if ( service_uuid . bt_uuid == GATT_SERVICE_AUTOMATION_IO ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) || att_data -> opcode == ATT_OPCODE_HANDLE_VALUE_CONFIRMATION ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_WRITE_COMMAND && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_analog , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 0x2A5A : if ( service_uuid . bt_uuid == GATT_SERVICE_AUTOMATION_IO ) {\n if ( is_readable_request ( att_data -> opcode ) || att_data -> opcode == ATT_OPCODE_HANDLE_VALUE_CONFIRMATION ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n call_dissector_with_data ( find_dissector ( \"btgatt.uuid0x2a56\" ) , tvb_new_subset_length_caplen ( tvb , offset , 1 , 1 ) , pinfo , tree , att_data ) ;\n offset += 1 ;\n call_dissector_with_data ( find_dissector ( \"btgatt.uuid0x2a58\" ) , tvb_new_subset_length_caplen ( tvb , offset , 2 , 2 ) , pinfo , tree , att_data ) ;\n offset += 2 ;\n break ;\n case 0x2A5B : if ( service_uuid . bt_uuid == GATT_SERVICE_CYCLING_SPEED_AND_CADENCE ) {\n if ( att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_csc_measurement_flags , ett_btatt_value , hfx_btatt_csc_measurement_flags , ENC_NA ) ;\n flags = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n if ( flags & 0x01 ) {\n proto_tree_add_item ( tree , hf_btatt_csc_measurement_cumulative_wheel_revolutions , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n proto_tree_add_item ( tree , hf_btatt_csc_measurement_last_event_time , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( flags & 0x02 ) {\n proto_tree_add_item ( tree , hf_btatt_csc_measurement_cumulative_crank_revolutions , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_csc_measurement_last_event_time , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n break ;\n case 0x2A5C : if ( service_uuid . bt_uuid == GATT_SERVICE_CYCLING_SPEED_AND_CADENCE ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_csc_feature , ett_btatt_value , hfx_btatt_csc_feature , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 0x2A5D : if ( service_uuid . bt_uuid == GATT_SERVICE_RUNNING_SPEED_AND_CADENCE || service_uuid . bt_uuid == GATT_SERVICE_CYCLING_SPEED_AND_CADENCE || service_uuid . bt_uuid == GATT_SERVICE_CYCLING_POWER ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_sensor_location , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A5E : if ( service_uuid . bt_uuid == GATT_SERVICE_PULSE_OXIMETER ) {\n if ( att_data -> opcode == ATT_OPCODE_HANDLE_VALUE_CONFIRMATION ) break ;\n if ( att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_INDICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_plx_spot_check_measurement_flags , ett_btatt_value , hfx_btatt_plx_spot_check_measurement_flags , ENC_NA ) ;\n flags = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n sub_item = proto_tree_add_item ( tree , hf_btatt_plx_spo2pr_spot_check , tvb , offset , 4 , ENC_NA ) ;\n sub_tree = proto_item_add_subtree ( sub_item , ett_btatt_value ) ;\n proto_tree_add_item ( sub_tree , hf_btatt_plx_spo2 , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( sub_tree , hf_btatt_plx_pulse_rate , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n if ( flags & 0x01 ) {\n sub_item = proto_tree_add_item ( tree , hf_btatt_plx_spot_check_measurement_timestamp , tvb , offset , 7 , ENC_NA ) ;\n sub_tree = proto_item_add_subtree ( sub_item , ett_btatt_value ) ;\n call_dissector_with_data ( find_dissector ( \"btgatt.uuid0x2a08\" ) , tvb_new_subset_length_caplen ( tvb , offset , 7 , 7 ) , pinfo , sub_tree , att_data ) ;\n offset += 7 ;\n }\n if ( flags & 0x02 ) {\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_plx_measurement_status , ett_btatt_value , hfx_btatt_plx_measurement_status , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( flags & 0x04 ) {\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_plx_device_and_sensor_status , ett_btatt_value , hfx_btatt_plx_device_and_sensor_status , ENC_LITTLE_ENDIAN ) ;\n offset += 3 ;\n }\n if ( flags & 0x08 ) {\n proto_tree_add_item ( tree , hf_btatt_plx_pulse_amplitude_index , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n break ;\n case 0x2A5F : if ( service_uuid . bt_uuid == GATT_SERVICE_PULSE_OXIMETER ) {\n if ( att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_plx_continuous_measurement_flags , ett_btatt_value , hfx_btatt_plx_continuous_measurement_flags , ENC_NA ) ;\n flags = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n sub_item = proto_tree_add_item ( tree , hf_btatt_plx_spo2pr_normal , tvb , offset , 4 , ENC_NA ) ;\n sub_tree = proto_item_add_subtree ( sub_item , ett_btatt_value ) ;\n proto_tree_add_item ( sub_tree , hf_btatt_plx_spo2 , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( sub_tree , hf_btatt_plx_pulse_rate , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n if ( flags & 0x01 ) {\n sub_item = proto_tree_add_item ( tree , hf_btatt_plx_spo2pr_fast , tvb , offset , 4 , ENC_NA ) ;\n sub_tree = proto_item_add_subtree ( sub_item , ett_btatt_value ) ;\n proto_tree_add_item ( sub_tree , hf_btatt_plx_spo2 , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( sub_tree , hf_btatt_plx_pulse_rate , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( flags & 0x02 ) {\n sub_item = proto_tree_add_item ( tree , hf_btatt_plx_spo2pr_slow , tvb , offset , 4 , ENC_NA ) ;\n sub_tree = proto_item_add_subtree ( sub_item , ett_btatt_value ) ;\n proto_tree_add_item ( sub_tree , hf_btatt_plx_spo2 , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( sub_tree , hf_btatt_plx_pulse_rate , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( flags & 0x04 ) {\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_plx_measurement_status , ett_btatt_value , hfx_btatt_plx_measurement_status , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( flags & 0x08 ) {\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_plx_device_and_sensor_status , ett_btatt_value , hfx_btatt_plx_device_and_sensor_status , ENC_LITTLE_ENDIAN ) ;\n offset += 3 ;\n }\n if ( flags & 0x10 ) {\n proto_tree_add_item ( tree , hf_btatt_plx_pulse_amplitude_index , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n break ;\n case 0x2A60 : if ( service_uuid . bt_uuid == GATT_SERVICE_PULSE_OXIMETER ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_plx_features_supported_features , ett_btatt_value , hfx_btatt_plx_features_supported_features , ENC_LITTLE_ENDIAN ) ;\n flags = tvb_get_guint16 ( tvb , offset , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n if ( flags & 0x01 ) {\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_plx_measurement_status , ett_btatt_value , hfx_btatt_plx_measurement_status , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( flags & 0x02 ) {\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_plx_device_and_sensor_status , ett_btatt_value , hfx_btatt_plx_device_and_sensor_status , ENC_LITTLE_ENDIAN ) ;\n offset += 3 ;\n }\n break ;\n case 0x2A63 : if ( service_uuid . bt_uuid == GATT_SERVICE_CYCLING_POWER ) {\n if ( att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_cycling_power_measurement_flags , ett_btatt_value , hfx_btatt_cycling_power_measurement_flags , ENC_LITTLE_ENDIAN ) ;\n flags = tvb_get_guint16 ( tvb , offset , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_cycling_power_measurement_instantaneous_power , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n if ( flags & 0x01 ) {\n proto_tree_add_item ( tree , hf_btatt_cycling_power_measurement_pedal_power_balance , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n }\n if ( flags & 0x04 ) {\n proto_tree_add_item ( tree , hf_btatt_cycling_power_measurement_accumulated_torque , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( flags & 0x10 ) {\n proto_tree_add_item ( tree , hf_btatt_cycling_power_measurement_wheel_revolution_data_cumulative_wheel_revolutions , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n proto_tree_add_item ( tree , hf_btatt_cycling_power_measurement_wheel_revolution_data_last_wheel_event_time , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( flags & 0x20 ) {\n proto_tree_add_item ( tree , hf_btatt_cycling_power_measurement_crank_revolution_data_cumulative_crank_revolutions , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_cycling_power_measurement_crank_revolution_data_last_crank_event_time , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( flags & 0x40 ) {\n proto_tree_add_item ( tree , hf_btatt_cycling_power_measurement_extreme_force_magnitudes_maximum_force_magnitude , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_cycling_power_measurement_extreme_force_magnitudes_minimum_force_magnitude , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( flags & 0x80 ) {\n proto_tree_add_item ( tree , hf_btatt_cycling_power_measurement_extreme_torque_magnitudes_maximum_torque_magnitude , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_cycling_power_measurement_extreme_torque_magnitudes_minimum_torque_magnitude , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( flags & 0x100 ) {\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_cycling_power_measurement_extreme_angles , ett_btatt_value , hfx_btatt_cycling_power_measurement_extreme_angles , ENC_NA ) ;\n offset += 3 ;\n }\n if ( flags & 0x200 ) {\n proto_tree_add_item ( tree , hf_btatt_cycling_power_measurement_top_dead_spot_angle , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( flags & 0x400 ) {\n proto_tree_add_item ( tree , hf_btatt_cycling_power_measurement_bottom_dead_spot_angle , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( flags & 0x800 ) {\n proto_tree_add_item ( tree , hf_btatt_cycling_power_measurement_accumulated_energy , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n break ;\n case 0x2A64 : if ( service_uuid . bt_uuid == GATT_SERVICE_CYCLING_POWER ) {\n if ( att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_cycling_power_vector_flags , ett_btatt_value , hfx_btatt_cycling_power_vector_flags , ENC_NA ) ;\n flags = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n if ( flags & 0x01 ) {\n proto_tree_add_item ( tree , hf_btatt_cycling_power_vector_crank_revolution_data_cumulative_crank_revolutions , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_cycling_power_vector_crank_revolution_data_last_crank_event_time , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( flags & 0x02 ) {\n proto_tree_add_item ( tree , hf_btatt_cycling_power_vector_first_crank_measurement_angle , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( flags & 0x04 ) {\n while ( tvb_reported_length_remaining ( tvb , offset ) > 0 ) {\n proto_tree_add_item ( tree , hf_btatt_cycling_power_vector_instantaneous_force_magnitude_array , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n }\n if ( flags & 0x08 ) {\n while ( tvb_reported_length_remaining ( tvb , offset ) > 0 ) {\n proto_tree_add_item ( tree , hf_btatt_cycling_power_vector_instantaneous_torque_magnitude_array , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n }\n break ;\n case 0x2A65 : if ( service_uuid . bt_uuid == GATT_SERVICE_CYCLING_POWER ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_cycling_power_feature , ett_btatt_value , hfx_btatt_cycling_power_feature , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n break ;\n case 0x2A66 : if ( service_uuid . bt_uuid == GATT_SERVICE_CYCLING_POWER ) {\n if ( is_writeable_response ( att_data -> opcode ) || att_data -> opcode == ATT_OPCODE_HANDLE_VALUE_CONFIRMATION ) break ;\n if ( ! is_writeable_request ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_INDICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_cycling_power_control_point_opcode , tvb , offset , 1 , ENC_NA ) ;\n opcode = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n switch ( opcode ) {\n case 1 : proto_tree_add_item ( tree , hf_btatt_cycling_power_control_point_cumulative_value , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n break ;\n case 2 : proto_tree_add_item ( tree , hf_btatt_cycling_power_control_point_sensor_location , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 4 : proto_tree_add_item ( tree , hf_btatt_cycling_power_control_point_crank_length , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 6 : proto_tree_add_item ( tree , hf_btatt_cycling_power_control_point_chain_length , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 8 : proto_tree_add_item ( tree , hf_btatt_cycling_power_control_point_chain_weight , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 10 : proto_tree_add_item ( tree , hf_btatt_cycling_power_control_point_span_length , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 13 : proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_cycling_power_control_point_content_mask , ett_btatt_value , hfx_btatt_cycling_power_control_point_content_mask , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 3 : case 5 : case 7 : case 9 : case 11 : case 12 : case 14 : case 15 : break ;\n case 32 : proto_tree_add_item ( tree , hf_btatt_cycling_power_control_point_request_opcode , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_cycling_power_control_point_response_value , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n switch ( tvb_get_guint8 ( tvb , offset - 2 ) ) {\n case 1 : case 2 : case 4 : case 6 : case 8 : case 10 : case 13 : break ;\n case 3 : if ( tvb_get_guint8 ( tvb , offset - 1 ) == 0x01 ) {\n while ( tvb_captured_length_remaining ( tvb , offset ) ) {\n proto_tree_add_item ( tree , hf_btatt_sensor_location , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n }\n }\n break ;\n case 5 : if ( tvb_get_guint8 ( tvb , offset - 1 ) == 0x01 ) {\n proto_tree_add_item ( tree , hf_btatt_cycling_power_control_point_crank_length , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n break ;\n case 7 : if ( tvb_get_guint8 ( tvb , offset - 1 ) == 0x01 ) {\n proto_tree_add_item ( tree , hf_btatt_cycling_power_control_point_chain_length , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n break ;\n case 9 : if ( tvb_get_guint8 ( tvb , offset - 1 ) == 0x01 ) {\n proto_tree_add_item ( tree , hf_btatt_cycling_power_control_point_chain_weight , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n break ;\n case 11 : if ( tvb_get_guint8 ( tvb , offset - 1 ) == 0x01 ) {\n proto_tree_add_item ( tree , hf_btatt_cycling_power_control_point_span_length , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n break ;\n case 12 : if ( tvb_get_guint8 ( tvb , offset - 1 ) == 0x01 ) {\n proto_tree_add_item ( tree , hf_btatt_cycling_power_control_point_start_offset_compensation , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n break ;\n case 14 : if ( tvb_get_guint8 ( tvb , offset - 1 ) == 0x01 ) {\n proto_tree_add_item ( tree , hf_btatt_cycling_power_control_point_sampling_rate , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n }\n break ;\n case 15 : if ( tvb_get_guint8 ( tvb , offset - 1 ) == 0x01 ) {\n sub_item = proto_tree_add_item ( tree , hf_btatt_cycling_power_control_point_factory_calibration_date , tvb , offset , 7 , ENC_NA ) ;\n sub_tree = proto_item_add_subtree ( sub_item , ett_btatt_list ) ;\n proto_tree_add_item ( sub_tree , hf_btatt_year , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( sub_tree , hf_btatt_month , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_day , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_hours , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_minutes , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_seconds , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n }\n break ;\n }\n break ;\n }\n break ;\n case 0x2A67 : if ( service_uuid . bt_uuid == GATT_SERVICE_LOCATION_AND_NAVIGATION ) {\n if ( att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_location_and_speed_flags , ett_btatt_value , hfx_btatt_location_and_speed_flags , ENC_LITTLE_ENDIAN ) ;\n flags = tvb_get_guint16 ( tvb , offset , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n if ( flags & 0x01 ) {\n proto_tree_add_item ( tree , hf_btatt_location_and_speed_instantaneous_speed , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( flags & 0x02 ) {\n proto_tree_add_item ( tree , hf_btatt_location_and_speed_total_distance , tvb , offset , 3 , ENC_LITTLE_ENDIAN ) ;\n offset += 3 ;\n }\n if ( flags & 0x04 ) {\n proto_tree_add_item ( tree , hf_btatt_location_and_speed_location_latitude , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n proto_tree_add_item ( tree , hf_btatt_location_and_speed_location_longitude , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n }\n if ( flags & 0x08 ) {\n proto_tree_add_item ( tree , hf_btatt_location_and_speed_elevation , tvb , offset , 3 , ENC_LITTLE_ENDIAN ) ;\n offset += 3 ;\n }\n if ( flags & 0x10 ) {\n proto_tree_add_item ( tree , hf_btatt_location_and_speed_heading , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( flags & 0x20 ) {\n proto_tree_add_item ( tree , hf_btatt_location_and_speed_rolling_time , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n }\n if ( flags & 0x40 ) {\n sub_item = proto_tree_add_item ( tree , hf_btatt_location_and_speed_utc_time , tvb , offset , 7 , ENC_NA ) ;\n sub_tree = proto_item_add_subtree ( sub_item , ett_btatt_list ) ;\n proto_tree_add_item ( sub_tree , hf_btatt_year , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( sub_tree , hf_btatt_month , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_day , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_hours , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_minutes , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_seconds , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n }\n break ;\n case 0x2A68 : if ( service_uuid . bt_uuid == GATT_SERVICE_LOCATION_AND_NAVIGATION ) {\n if ( att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_navigation_flags , ett_btatt_value , hfx_btatt_navigation_flags , ENC_LITTLE_ENDIAN ) ;\n flags = tvb_get_guint16 ( tvb , offset , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_navigation_bearing , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_navigation_heading , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n if ( flags & 0x01 ) {\n proto_tree_add_item ( tree , hf_btatt_navigation_remaining_distance , tvb , offset , 3 , ENC_LITTLE_ENDIAN ) ;\n offset += 3 ;\n }\n if ( flags & 0x02 ) {\n proto_tree_add_item ( tree , hf_btatt_navigation_remaining_vertical_distance , tvb , offset , 3 , ENC_LITTLE_ENDIAN ) ;\n offset += 3 ;\n }\n if ( flags & 0x04 ) {\n sub_item = proto_tree_add_item ( tree , hf_btatt_navigation_estimated_time_of_arrival , tvb , offset , 7 , ENC_NA ) ;\n sub_tree = proto_item_add_subtree ( sub_item , ett_btatt_list ) ;\n proto_tree_add_item ( sub_tree , hf_btatt_year , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( sub_tree , hf_btatt_month , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_day , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_hours , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_minutes , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_seconds , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n }\n break ;\n case 0x2A69 : if ( service_uuid . bt_uuid == GATT_SERVICE_LOCATION_AND_NAVIGATION ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_position_quality_flags , ett_btatt_value , hfx_btatt_position_quality_flags , ENC_LITTLE_ENDIAN ) ;\n flags = tvb_get_guint16 ( tvb , offset , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n if ( flags & 0x01 ) {\n proto_tree_add_item ( tree , hf_btatt_position_quality_number_of_beacons_in_solution , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n }\n if ( flags & 0x02 ) {\n proto_tree_add_item ( tree , hf_btatt_position_quality_number_of_beacons_in_view , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n }\n if ( flags & 0x04 ) {\n proto_tree_add_item ( tree , hf_btatt_position_quality_time_to_first_fix , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( flags & 0x08 ) {\n proto_tree_add_item ( tree , hf_btatt_position_quality_ehpe , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n }\n if ( flags & 0x10 ) {\n proto_tree_add_item ( tree , hf_btatt_position_quality_evpe , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n }\n if ( flags & 0x20 ) {\n proto_tree_add_item ( tree , hf_btatt_position_quality_hdop , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n }\n if ( flags & 0x40 ) {\n proto_tree_add_item ( tree , hf_btatt_position_quality_vdop , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n }\n break ;\n case 0x2A6A : if ( service_uuid . bt_uuid == GATT_SERVICE_LOCATION_AND_NAVIGATION ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_ln_feature , ett_btatt_value , hfx_btatt_ln_feature , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n break ;\n case 0x2A6B : if ( service_uuid . bt_uuid == GATT_SERVICE_LOCATION_AND_NAVIGATION ) {\n if ( is_writeable_response ( att_data -> opcode ) || att_data -> opcode == ATT_OPCODE_HANDLE_VALUE_CONFIRMATION ) break ;\n if ( ! is_writeable_request ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_INDICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_ln_control_point_opcode , tvb , offset , 1 , ENC_NA ) ;\n opcode = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n switch ( opcode ) {\n case 1 : proto_tree_add_item ( tree , hf_btatt_ln_control_point_cumulative_value , tvb , offset , 3 , ENC_LITTLE_ENDIAN ) ;\n offset += 3 ;\n break ;\n case 2 : proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_ln_control_point_content_mask , ett_btatt_value , hfx_btatt_ln_control_point_content_mask , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 3 : proto_tree_add_item ( tree , hf_btatt_ln_control_point_navigation_control , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 4 : break ;\n case 5 : case 6 : proto_tree_add_item ( tree , hf_btatt_ln_control_point_route_number , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 7 : proto_tree_add_item ( tree , hf_btatt_ln_control_point_fix_rate , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 8 : proto_tree_add_item ( tree , hf_btatt_ln_control_point_elevation , tvb , offset , 3 , ENC_LITTLE_ENDIAN ) ;\n offset += 3 ;\n break ;\n case 32 : proto_tree_add_item ( tree , hf_btatt_ln_control_point_request_opcode , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_ln_control_point_response_value , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n switch ( tvb_get_guint8 ( tvb , offset - 2 ) ) {\n case 1 : case 2 : case 3 : case 6 : case 7 : case 8 : break ;\n case 4 : proto_tree_add_item ( tree , hf_btatt_ln_control_point_response_value_number_of_routes , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 5 : proto_tree_add_item ( tree , hf_btatt_ln_control_point_response_value_name_of_route , tvb , offset , tvb_captured_length_remaining ( tvb , offset ) , ENC_NA | ENC_UTF_8 ) ;\n offset += tvb_captured_length_remaining ( tvb , offset ) ;\n break ;\n }\n break ;\n }\n break ;\n case 0x2A6C : if ( service_uuid . bt_uuid == GATT_SERVICE_ENVIRONMENTAL_SENSING ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_elevation , tvb , offset , 3 , ENC_LITTLE_ENDIAN ) ;\n offset += 3 ;\n break ;\n case 0x2A6D : if ( service_uuid . bt_uuid == GATT_SERVICE_ENVIRONMENTAL_SENSING ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_pressure , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n break ;\n case 0x2A6E : if ( service_uuid . bt_uuid == GATT_SERVICE_ENVIRONMENTAL_SENSING ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_temperature , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 0x2A6F : if ( service_uuid . bt_uuid == GATT_SERVICE_ENVIRONMENTAL_SENSING ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_humidity , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 0x2A70 : if ( service_uuid . bt_uuid == GATT_SERVICE_ENVIRONMENTAL_SENSING ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_true_wind_speed , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 0x2A71 : if ( service_uuid . bt_uuid == GATT_SERVICE_ENVIRONMENTAL_SENSING ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_true_wind_direction , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 0x2A72 : if ( service_uuid . bt_uuid == GATT_SERVICE_ENVIRONMENTAL_SENSING ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_apparent_wind_speed , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 0x2A73 : if ( service_uuid . bt_uuid == GATT_SERVICE_ENVIRONMENTAL_SENSING ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_apparent_wind_direction , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 0x2A74 : if ( service_uuid . bt_uuid == GATT_SERVICE_ENVIRONMENTAL_SENSING ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_gust_factor , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A75 : if ( service_uuid . bt_uuid == GATT_SERVICE_ENVIRONMENTAL_SENSING ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_pollen_concentration , tvb , offset , 3 , ENC_LITTLE_ENDIAN ) ;\n offset += 3 ;\n break ;\n case 0x2A76 : if ( service_uuid . bt_uuid == GATT_SERVICE_ENVIRONMENTAL_SENSING ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_uv_index , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A77 : if ( service_uuid . bt_uuid == GATT_SERVICE_ENVIRONMENTAL_SENSING ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_irradiance , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 0x2A78 : if ( service_uuid . bt_uuid == GATT_SERVICE_ENVIRONMENTAL_SENSING ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_rainfall , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 0x2A79 : if ( service_uuid . bt_uuid == GATT_SERVICE_ENVIRONMENTAL_SENSING ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_wind_chill , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A7A : if ( service_uuid . bt_uuid == GATT_SERVICE_ENVIRONMENTAL_SENSING ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_heart_index , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A7B : if ( service_uuid . bt_uuid == GATT_SERVICE_ENVIRONMENTAL_SENSING ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_dew_point , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A7D : if ( service_uuid . bt_uuid == GATT_SERVICE_ENVIRONMENTAL_SENSING ) {\n if ( att_data -> opcode == ATT_OPCODE_HANDLE_VALUE_CONFIRMATION ) break ;\n if ( att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_INDICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_descriptor_value_changed_flags , ett_btatt_value , hfx_btatt_descriptor_value_changed_flags , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n if ( tvb_reported_length_remaining ( tvb , offset ) == 2 ) {\n proto_tree_add_item ( tree , hf_btatt_uuid16 , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n else if ( tvb_reported_length_remaining ( tvb , offset ) == 16 ) {\n proto_tree_add_item ( tree , hf_btatt_uuid128 , tvb , offset , 16 , ENC_NA ) ;\n offset += 16 ;\n }\n else {\n sub_item = proto_tree_add_item ( tree , hf_btatt_value , tvb , offset , - 1 , ENC_NA ) ;\n expert_add_info ( pinfo , sub_item , & ei_btatt_bad_data ) ;\n offset = tvb_captured_length ( tvb ) ;\n }\n break ;\n case 0x2A7E : if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_aerobic_heart_rate_lower_limit , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A7F : if ( service_uuid . bt_uuid == GATT_SERVICE_USER_DATA ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_aerobic_threshold , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A80 : if ( service_uuid . bt_uuid == GATT_SERVICE_USER_DATA ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_age , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A81 : if ( service_uuid . bt_uuid == GATT_SERVICE_USER_DATA ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_anaerobic_heart_rate_lower_limit , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A82 : if ( service_uuid . bt_uuid == GATT_SERVICE_USER_DATA ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_anaerobic_heart_rate_upper_limit , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A83 : if ( service_uuid . bt_uuid == GATT_SERVICE_USER_DATA ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_anaerobic_threshold , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A84 : if ( service_uuid . bt_uuid == GATT_SERVICE_USER_DATA ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_aerobic_heart_rate_upper_limit , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A85 : case 0x2A86 : if ( service_uuid . bt_uuid == GATT_SERVICE_USER_DATA ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_year , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_month , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_day , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A87 : if ( service_uuid . bt_uuid == GATT_SERVICE_USER_DATA ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_email_address , tvb , offset , tvb_captured_length_remaining ( tvb , offset ) , ENC_NA | ENC_UTF_8 ) ;\n offset += tvb_captured_length_remaining ( tvb , offset ) ;\n break ;\n case 0x2A88 : if ( service_uuid . bt_uuid == GATT_SERVICE_USER_DATA ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_fat_burn_heart_rate_lower_limit , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A89 : if ( service_uuid . bt_uuid == GATT_SERVICE_USER_DATA ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_fat_burn_heart_rate_upper_limit , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A8A : if ( service_uuid . bt_uuid == GATT_SERVICE_USER_DATA ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_first_name , tvb , offset , tvb_captured_length_remaining ( tvb , offset ) , ENC_NA | ENC_UTF_8 ) ;\n offset += tvb_captured_length_remaining ( tvb , offset ) ;\n break ;\n case 0x2A8B : if ( service_uuid . bt_uuid == GATT_SERVICE_USER_DATA ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_five_zone_heart_rate_limits_very_light_light_limit , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_five_zone_heart_rate_limits_light_moderate_limit , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_five_zone_heart_rate_limits_moderate_hard_limit , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_five_zone_heart_rate_limits_hard_maximum_limit , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A8C : if ( service_uuid . bt_uuid == GATT_SERVICE_USER_DATA ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_gender , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A8D : if ( service_uuid . bt_uuid == GATT_SERVICE_USER_DATA ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_heart_rate_max , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A8E : if ( service_uuid . bt_uuid == GATT_SERVICE_USER_DATA ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_height , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 0x2A8F : if ( service_uuid . bt_uuid == GATT_SERVICE_USER_DATA ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_hip_circumference , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 0x2A90 : if ( service_uuid . bt_uuid == GATT_SERVICE_USER_DATA ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_last_name , tvb , offset , tvb_captured_length_remaining ( tvb , offset ) , ENC_NA | ENC_UTF_8 ) ;\n offset += tvb_captured_length_remaining ( tvb , offset ) ;\n break ;\n case 0x2A91 : if ( service_uuid . bt_uuid == GATT_SERVICE_USER_DATA ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_maximum_recommended_heart_rate , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A92 : if ( service_uuid . bt_uuid == GATT_SERVICE_USER_DATA ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_resting_heart_rate , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A93 : if ( service_uuid . bt_uuid == GATT_SERVICE_USER_DATA ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_sport_type_for_aerobic_and_anaerobic_thresholds , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A94 : if ( service_uuid . bt_uuid == GATT_SERVICE_USER_DATA ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_three_zone_heart_rate_limits_light_moderate , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_three_zone_heart_rate_limits_moderate_hard , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A95 : if ( service_uuid . bt_uuid == GATT_SERVICE_USER_DATA ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_two_zone_heart_rate_limit_fat_burn_fitness , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A96 : if ( service_uuid . bt_uuid == GATT_SERVICE_USER_DATA ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_vo2_max , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A97 : if ( service_uuid . bt_uuid == GATT_SERVICE_USER_DATA ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_waist_circumference , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 0x2A98 : if ( service_uuid . bt_uuid == GATT_SERVICE_USER_DATA ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_weight , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 0x2A99 : if ( service_uuid . bt_uuid == GATT_SERVICE_USER_DATA ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_database_change_increment , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n break ;\n case 0x2A9A : if ( service_uuid . bt_uuid == GATT_SERVICE_USER_DATA ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_user_index , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A9B : if ( service_uuid . bt_uuid == GATT_SERVICE_BODY_COMPOSITION ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_body_composition_feature , ett_btatt_value , hfx_btatt_body_composition_feature , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n break ;\n case 0x2A9C : if ( service_uuid . bt_uuid == GATT_SERVICE_BODY_COMPOSITION ) {\n if ( att_data -> opcode == ATT_OPCODE_HANDLE_VALUE_CONFIRMATION ) break ;\n if ( att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_INDICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_body_composition_measurement_flags , ett_btatt_value , hfx_btatt_body_composition_measurement_flags , ENC_LITTLE_ENDIAN ) ;\n flags = tvb_get_guint16 ( tvb , offset , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_body_composition_measurement_body_fat_percentage , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n if ( flags & 0x02 ) {\n sub_item = proto_tree_add_item ( tree , hf_btatt_body_composition_measurement_timestamp , tvb , offset , 7 , ENC_NA ) ;\n sub_tree = proto_item_add_subtree ( sub_item , ett_btatt_list ) ;\n proto_tree_add_item ( sub_tree , hf_btatt_year , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( sub_tree , hf_btatt_month , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_day , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_hours , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_minutes , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_seconds , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n }\n if ( flags & 0x04 ) {\n proto_tree_add_item ( tree , hf_btatt_body_composition_measurement_user_id , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n }\n if ( flags & 0x08 ) {\n proto_tree_add_item ( sub_tree , hf_btatt_body_composition_measurement_basal_metabolism , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( flags & 0x10 ) {\n proto_tree_add_item ( sub_tree , hf_btatt_body_composition_measurement_muscle_percentage , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( flags & 0x20 ) {\n if ( flags & 0x01 ) proto_tree_add_item ( sub_tree , hf_btatt_body_composition_measurement_muscle_mass_lb , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n else proto_tree_add_item ( sub_tree , hf_btatt_body_composition_measurement_muscle_mass_kg , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( flags & 0x40 ) {\n if ( flags & 0x01 ) proto_tree_add_item ( sub_tree , hf_btatt_body_composition_measurement_fat_free_mass_lb , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n else proto_tree_add_item ( sub_tree , hf_btatt_body_composition_measurement_fat_free_mass_kg , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( flags & 0x80 ) {\n if ( flags & 0x01 ) proto_tree_add_item ( sub_tree , hf_btatt_body_composition_measurement_soft_lean_mass_lb , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n else proto_tree_add_item ( sub_tree , hf_btatt_body_composition_measurement_soft_lean_mass_kg , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( flags & 0x100 ) {\n if ( flags & 0x01 ) proto_tree_add_item ( sub_tree , hf_btatt_body_composition_measurement_body_water_mass_lb , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n else proto_tree_add_item ( sub_tree , hf_btatt_body_composition_measurement_body_water_mass_kg , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( flags & 0x200 ) {\n proto_tree_add_item ( sub_tree , hf_btatt_body_composition_measurement_impedance , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( flags & 0x400 ) {\n if ( flags & 0x01 ) proto_tree_add_item ( sub_tree , hf_btatt_body_composition_measurement_weight_lb , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n else proto_tree_add_item ( sub_tree , hf_btatt_body_composition_measurement_weight_kg , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( flags & 0x800 ) {\n if ( flags & 0x01 ) proto_tree_add_item ( sub_tree , hf_btatt_body_composition_measurement_height_inches , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n else proto_tree_add_item ( sub_tree , hf_btatt_body_composition_measurement_height_meter , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n break ;\n case 0x2A9D : if ( service_uuid . bt_uuid == GATT_SERVICE_WEIGHT_SCALE ) {\n if ( is_writeable_response ( att_data -> opcode ) || att_data -> opcode == ATT_OPCODE_HANDLE_VALUE_CONFIRMATION ) break ;\n if ( ! is_writeable_request ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_INDICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_weight_measurement_flags , ett_btatt_value , hfx_btatt_weight_measurement_flags , ENC_NA ) ;\n flags = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n if ( flags & 0x01 ) proto_tree_add_item ( tree , hf_btatt_weight_measurement_weight_lb , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n else proto_tree_add_item ( tree , hf_btatt_weight_measurement_weight_kg , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n if ( flags & 0x02 ) {\n sub_item = proto_tree_add_item ( tree , hf_btatt_weight_measurement_timestamp , tvb , offset , 7 , ENC_NA ) ;\n sub_tree = proto_item_add_subtree ( sub_item , ett_btatt_list ) ;\n proto_tree_add_item ( sub_tree , hf_btatt_year , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( sub_tree , hf_btatt_month , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_day , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_hours , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_minutes , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_seconds , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n }\n if ( flags & 0x04 ) {\n proto_tree_add_item ( tree , hf_btatt_weight_measurement_user_id , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n }\n if ( flags & 0x08 ) {\n proto_tree_add_item ( sub_tree , hf_btatt_weight_measurement_bmi , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n if ( flags & 0x01 ) proto_tree_add_item ( sub_tree , hf_btatt_weight_measurement_height_in , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n else proto_tree_add_item ( sub_tree , hf_btatt_weight_measurement_height_m , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n break ;\n case 0x2A9E : if ( service_uuid . bt_uuid == GATT_SERVICE_WEIGHT_SCALE ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_weight_scale_feature , ett_btatt_value , hfx_btatt_weight_scale_feature , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n break ;\n case 0x2A9F : if ( service_uuid . bt_uuid == GATT_SERVICE_USER_DATA ) {\n if ( is_writeable_response ( att_data -> opcode ) || att_data -> opcode == ATT_OPCODE_HANDLE_VALUE_CONFIRMATION ) break ;\n if ( ! is_writeable_request ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_INDICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_user_control_point_opcode , tvb , offset , 1 , ENC_NA ) ;\n opcode = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n switch ( opcode ) {\n case 0x01 : sub_item = proto_tree_add_item ( tree , hf_btatt_user_control_point_consent_code , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n value = tvb_get_guint16 ( tvb , offset , ENC_LITTLE_ENDIAN ) ;\n if ( value > 9999 ) expert_add_info ( pinfo , sub_item , & ei_btatt_consent_out_of_bounds ) ;\n offset += 2 ;\n break ;\n case 0x02 : proto_tree_add_item ( tree , hf_btatt_user_index , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n sub_item = proto_tree_add_item ( tree , hf_btatt_user_control_point_consent_code , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n value = tvb_get_guint16 ( tvb , offset , ENC_LITTLE_ENDIAN ) ;\n if ( value > 9999 ) expert_add_info ( pinfo , sub_item , & ei_btatt_consent_out_of_bounds ) ;\n offset += 2 ;\n break ;\n case 0x03 : break ;\n case 0x20 : proto_tree_add_item ( tree , hf_btatt_user_control_point_request_opcode , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_user_control_point_response_value , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n if ( tvb_get_guint8 ( tvb , offset - 2 ) == 0x01 && tvb_get_guint8 ( tvb , offset - 1 ) == 0x01 ) {\n proto_tree_add_item ( tree , hf_btatt_user_index , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n }\n break ;\n }\n break ;\n case 0x2AA0 : case 0x2AA1 : if ( service_uuid . bt_uuid == GATT_SERVICE_ENVIRONMENTAL_SENSING ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_magnetic_flux_density_x , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_magnetic_flux_density_y , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n if ( uuid . bt_uuid == 0x2AA1 ) {\n proto_tree_add_item ( tree , hf_btatt_magnetic_flux_density_z , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n break ;\n case 0x2AA2 : if ( service_uuid . bt_uuid == GATT_SERVICE_USER_DATA ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_language , tvb , offset , tvb_captured_length_remaining ( tvb , offset ) , ENC_NA | ENC_UTF_8 ) ;\n offset += tvb_captured_length_remaining ( tvb , offset ) ;\n break ;\n case 0x2AA3 : if ( service_uuid . bt_uuid == GATT_SERVICE_ENVIRONMENTAL_SENSING ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_barometric_pressure_trend , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2AA4 : if ( service_uuid . bt_uuid == GATT_SERVICE_BOND_MANAGEMENT ) {\n if ( is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_bond_management_control_point_opcode , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n if ( tvb_reported_length_remaining ( tvb , offset ) > 0 ) {\n proto_tree_add_item ( tree , hf_btatt_bond_management_control_point_authorization_code , tvb , offset , length - 1 , ENC_NA | ENC_UTF_8 ) ;\n offset += tvb_reported_length_remaining ( tvb , offset ) ;\n }\n break ;\n case 0x2AA5 : if ( service_uuid . bt_uuid == GATT_SERVICE_BOND_MANAGEMENT ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_bond_management_feature , ett_btatt_value , hfx_btatt_bond_management_feature , ENC_LITTLE_ENDIAN ) ;\n flags = tvb_get_guint24 ( tvb , offset , ENC_LITTLE_ENDIAN ) ;\n offset += 3 ;\n if ( flags & 0x800000 ) {\n do {\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_bond_management_feature_nth , ett_btatt_value , hfx_btatt_bond_management_feature_nth , ENC_LITTLE_ENDIAN ) ;\n offset += 1 ;\n }\n while ( tvb_get_guint8 ( tvb , offset - 1 ) & 0x80 ) ;\n }\n break ;\n case 0x2AA6 : if ( service_uuid . bt_uuid == GATT_SERVICE_GENERIC_ACCESS_PROFILE ) {\n if ( ! ( is_readable_request ( att_data -> opcode ) || is_readable_response ( att_data -> opcode ) ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_central_address_resolution , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2AA7 : if ( service_uuid . bt_uuid == GATT_SERVICE_CONTINUOUS_GLUCOSE_MONITORING ) {\n if ( att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n sub_item = proto_tree_add_item ( tree , hf_btatt_cgm_measurement_size , tvb , offset , 1 , ENC_NA ) ;\n if ( tvb_get_guint8 ( tvb , offset ) >= 6 ) expert_add_info ( pinfo , sub_item , & ei_btatt_cgm_size_too_small ) ;\n offset += 1 ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_cgm_measurement_flags , ett_btatt_value , hfx_btatt_cgm_measurement_flags , ENC_NA ) ;\n flags = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_cgm_measurement_glucose_concentration , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_cgm_measurement_time_offset , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n if ( flags & 0xE0 ) {\n value = 0 ;\n if ( flags & 0x80 ) value += 1 ;\n if ( flags & 0x40 ) value += 1 ;\n if ( flags & 0x20 ) value += 1 ;\n sub_item = proto_tree_add_item ( tree , hf_btatt_cgm_sensor_status_annunciation , tvb , offset , value , ENC_NA ) ;\n sub_tree = proto_item_add_subtree ( sub_item , ett_btatt_list ) ;\n }\n if ( flags & 0x80 ) {\n proto_tree_add_bitmask ( sub_tree , tvb , offset , hf_btatt_cgm_sensor_status_annunciation_status , ett_btatt_value , hfx_btatt_cgm_sensor_status_annunciation_status , ENC_NA ) ;\n offset += 1 ;\n }\n if ( flags & 0x40 ) {\n proto_tree_add_bitmask ( sub_tree , tvb , offset , hf_btatt_cgm_sensor_status_annunciation_cal_temp , ett_btatt_value , hfx_btatt_cgm_sensor_status_annunciation_cal_temp , ENC_NA ) ;\n offset += 1 ;\n }\n if ( flags & 0x20 ) {\n proto_tree_add_bitmask ( sub_tree , tvb , offset , hf_btatt_cgm_sensor_status_annunciation_warning , ett_btatt_value , hfx_btatt_cgm_sensor_status_annunciation_warning , ENC_NA ) ;\n offset += 1 ;\n }\n if ( flags & 0x01 ) {\n proto_tree_add_item ( tree , hf_btatt_cgm_measurement_trend_information , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( flags & 0x02 ) {\n proto_tree_add_item ( tree , hf_btatt_cgm_measurement_quality , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( tvb_reported_length_remaining ( tvb , offset ) >= 2 ) {\n proto_tree_add_item ( tree , hf_btatt_cgm_e2e_crc , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n break ;\n case 0x2AA8 : if ( service_uuid . bt_uuid == GATT_SERVICE_CONTINUOUS_GLUCOSE_MONITORING ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_cgm_feature_feature , ett_btatt_value , hfx_btatt_cgm_feature_feature , ENC_LITTLE_ENDIAN ) ;\n offset += 3 ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_cgm_type_and_sample_location , ett_btatt_value , hfx_btatt_cgm_type_and_sample_location , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_cgm_e2e_crc , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 0x2AA9 : if ( service_uuid . bt_uuid == GATT_SERVICE_CONTINUOUS_GLUCOSE_MONITORING ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_cgm_time_offset , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n sub_item = proto_tree_add_item ( tree , hf_btatt_cgm_status , tvb , offset , 3 , ENC_LITTLE_ENDIAN ) ;\n sub_tree = proto_item_add_subtree ( sub_item , ett_btatt_list ) ;\n proto_tree_add_bitmask ( sub_tree , tvb , offset , hf_btatt_cgm_sensor_status_annunciation_status , ett_btatt_value , hfx_btatt_cgm_sensor_status_annunciation_status , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_bitmask ( sub_tree , tvb , offset , hf_btatt_cgm_sensor_status_annunciation_cal_temp , ett_btatt_value , hfx_btatt_cgm_sensor_status_annunciation_cal_temp , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_bitmask ( sub_tree , tvb , offset , hf_btatt_cgm_sensor_status_annunciation_warning , ett_btatt_value , hfx_btatt_cgm_sensor_status_annunciation_warning , ENC_NA ) ;\n offset += 1 ;\n if ( tvb_reported_length_remaining ( tvb , offset ) >= 2 ) {\n proto_tree_add_item ( tree , hf_btatt_cgm_e2e_crc , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n break ;\n case 0x2AAA : if ( service_uuid . bt_uuid == GATT_SERVICE_CONTINUOUS_GLUCOSE_MONITORING ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n sub_item = proto_tree_add_item ( tree , hf_btatt_cgm_session_start_time , tvb , offset , 7 , ENC_NA ) ;\n sub_tree = proto_item_add_subtree ( sub_item , ett_btatt_list ) ;\n proto_tree_add_item ( sub_tree , hf_btatt_year , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( sub_tree , hf_btatt_month , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_day , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_hours , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_minutes , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_seconds , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_timezone , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_dst_offset , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n if ( tvb_reported_length_remaining ( tvb , offset ) >= 2 ) {\n proto_tree_add_item ( tree , hf_btatt_cgm_e2e_crc , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n break ;\n case 0x2AAB : if ( service_uuid . bt_uuid == GATT_SERVICE_CONTINUOUS_GLUCOSE_MONITORING ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_cgm_session_run_time , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n if ( tvb_reported_length_remaining ( tvb , offset ) >= 2 ) {\n proto_tree_add_item ( tree , hf_btatt_cgm_e2e_crc , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n break ;\n case 0x2AAC : if ( service_uuid . bt_uuid == GATT_SERVICE_CONTINUOUS_GLUCOSE_MONITORING ) {\n if ( is_writeable_response ( att_data -> opcode ) || att_data -> opcode == ATT_OPCODE_HANDLE_VALUE_CONFIRMATION ) break ;\n if ( ! is_writeable_request ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_INDICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_cgm_specific_ops_control_point_opcode , tvb , offset , 1 , ENC_NA ) ;\n opcode = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n sub_item = proto_tree_add_item ( tree , hf_btatt_cgm_specific_ops_control_point_operand , tvb , offset , 0 , ENC_NA ) ;\n sub_tree = proto_item_add_subtree ( sub_item , ett_btatt_list ) ;\n operand_offset = offset ;\n switch ( opcode ) {\n case 1 : proto_tree_add_item ( sub_tree , hf_btatt_cgm_specific_ops_control_point_operand_communication_interval , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 2 : case 8 : case 11 : case 14 : case 17 : case 20 : case 23 : case 25 : case 26 : case 27 : break ;\n case 4 : proto_tree_add_item ( sub_tree , hf_btatt_cgm_specific_ops_control_point_calibration_glucose_concentration , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( sub_tree , hf_btatt_cgm_specific_ops_control_point_calibration_time , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_bitmask ( sub_tree , tvb , offset , hf_btatt_cgm_type_and_sample_location , ett_btatt_value , hfx_btatt_cgm_type_and_sample_location , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_cgm_specific_ops_control_point_next_calibration_time , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( sub_tree , hf_btatt_cgm_specific_ops_control_point_calibration_data_record_number , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_bitmask ( sub_tree , tvb , offset , hf_btatt_cgm_specific_ops_control_point_calibration_status , ett_btatt_value , hfx_btatt_cgm_specific_ops_control_point_calibration_status , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 5 : proto_tree_add_item ( sub_tree , hf_btatt_cgm_specific_ops_control_point_operand_calibration_data_record_number , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 7 : case 10 : case 13 : case 16 : proto_tree_add_item ( sub_tree , hf_btatt_cgm_specific_ops_control_point_operand_alert_level , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 19 : case 22 : proto_tree_add_item ( sub_tree , hf_btatt_cgm_specific_ops_control_point_operand_alert_level_rate , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 3 : case 6 : case 9 : case 12 : case 15 : case 18 : case 21 : case 24 : expert_add_info ( pinfo , sub_item , & ei_btatt_opcode_invalid_request ) ;\n break ;\n case 28 : proto_tree_add_item ( sub_tree , hf_btatt_cgm_specific_ops_control_point_request_opcode , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_cgm_specific_ops_control_point_response_code , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n switch ( tvb_get_guint8 ( tvb , offset - 2 ) ) {\n case 1 : case 2 : case 4 : case 5 : case 7 : case 8 : case 10 : case 11 : case 13 : case 14 : case 16 : case 17 : case 19 : case 20 : case 22 : case 23 : case 25 : case 26 : case 27 : expert_add_info ( pinfo , sub_item , & ei_btatt_opcode_invalid_response ) ;\n break ;\n case 3 : proto_tree_add_item ( sub_tree , hf_btatt_cgm_specific_ops_control_point_operand_communication_interval , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 6 : proto_tree_add_item ( sub_tree , hf_btatt_cgm_specific_ops_control_point_calibration_glucose_concentration , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( sub_tree , hf_btatt_cgm_specific_ops_control_point_calibration_time , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_bitmask ( sub_tree , tvb , offset , hf_btatt_cgm_type_and_sample_location , ett_btatt_value , hfx_btatt_cgm_type_and_sample_location , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_cgm_specific_ops_control_point_next_calibration_time , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( sub_tree , hf_btatt_cgm_specific_ops_control_point_calibration_data_record_number , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_bitmask ( sub_tree , tvb , offset , hf_btatt_cgm_specific_ops_control_point_calibration_status , ett_btatt_value , hfx_btatt_cgm_specific_ops_control_point_calibration_status , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 9 : case 12 : case 15 : case 18 : proto_tree_add_item ( sub_tree , hf_btatt_cgm_specific_ops_control_point_operand_alert_level , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 21 : case 24 : proto_tree_add_item ( sub_tree , hf_btatt_cgm_specific_ops_control_point_operand_alert_level_rate , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n }\n break ;\n }\n ;\n proto_item_set_len ( sub_item , offset - operand_offset ) ;\n if ( tvb_reported_length_remaining ( tvb , offset ) >= 2 ) {\n proto_tree_add_item ( tree , hf_btatt_cgm_e2e_crc , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n break ;\n case 0x2AAD : if ( service_uuid . bt_uuid == GATT_SERVICE_INDOOR_POSITIONING ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_WRITE_COMMAND ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_indoor_positioning_configuration , ett_btatt_value , hfx_btatt_indoor_positioning_configuration , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2AAE : if ( service_uuid . bt_uuid == GATT_SERVICE_INDOOR_POSITIONING ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_WRITE_COMMAND ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_latitude , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n break ;\n case 0x2AAF : if ( service_uuid . bt_uuid == GATT_SERVICE_INDOOR_POSITIONING ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_WRITE_COMMAND ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_longitude , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n break ;\n case 0x2AB0 : if ( service_uuid . bt_uuid == GATT_SERVICE_INDOOR_POSITIONING ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_WRITE_COMMAND ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_local_north_coordinate , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 0x2AB1 : if ( service_uuid . bt_uuid == GATT_SERVICE_INDOOR_POSITIONING ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_WRITE_COMMAND ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_local_east_coordinate , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 0x2AB2 : if ( service_uuid . bt_uuid == GATT_SERVICE_INDOOR_POSITIONING ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_WRITE_COMMAND ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_floor_number , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2AB3 : if ( service_uuid . bt_uuid == GATT_SERVICE_INDOOR_POSITIONING ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_WRITE_COMMAND ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_altitude , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 0x2AB4 : if ( service_uuid . bt_uuid == GATT_SERVICE_INDOOR_POSITIONING ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_WRITE_COMMAND ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_uncertainty , ett_btatt_value , hfx_btatt_uncertainty , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2AB5 : if ( service_uuid . bt_uuid == GATT_SERVICE_INDOOR_POSITIONING ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_WRITE_COMMAND ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_location_name , tvb , offset , tvb_captured_length_remaining ( tvb , offset ) , ENC_NA | ENC_UTF_8 ) ;\n offset += tvb_captured_length_remaining ( tvb , offset ) ;\n break ;\n case 0x2AB6 : if ( service_uuid . bt_uuid == GATT_SERVICE_HTTP_PROXY ) {\n if ( is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_uri , tvb , offset , tvb_captured_length_remaining ( tvb , offset ) , ENC_NA | ENC_UTF_8 ) ;\n offset += tvb_captured_length_remaining ( tvb , offset ) ;\n break ;\n case 0x2AB7 : if ( service_uuid . bt_uuid == GATT_SERVICE_HTTP_PROXY ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n sub_item = proto_tree_add_item ( tree , hf_btatt_http_headers , tvb , offset , tvb_captured_length_remaining ( tvb , offset ) , ENC_NA | ENC_UTF_8 ) ;\n sub_tree = proto_item_add_subtree ( sub_item , ett_btatt_value ) ;\n call_dissector ( http_handle , tvb_new_subset_remaining ( tvb , offset ) , pinfo , sub_tree ) ;\n offset += tvb_captured_length_remaining ( tvb , offset ) ;\n break ;\n case 0x2AB8 : if ( service_uuid . bt_uuid == GATT_SERVICE_HTTP_PROXY ) {\n if ( att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_http_status_code , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_http_data_status , ett_btatt_value , hfx_btatt_http_data_status , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2AB9 : if ( service_uuid . bt_uuid == GATT_SERVICE_HTTP_PROXY ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_http_entity_body , tvb , offset , tvb_captured_length_remaining ( tvb , offset ) , ENC_NA | ENC_UTF_8 ) ;\n offset += tvb_captured_length_remaining ( tvb , offset ) ;\n break ;\n case 0x2ABA : if ( service_uuid . bt_uuid == GATT_SERVICE_HTTP_PROXY ) {\n if ( is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_http_control_point_opcode , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2ABB : if ( service_uuid . bt_uuid == GATT_SERVICE_HTTP_PROXY ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_https_security , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2ABC : if ( service_uuid . bt_uuid == GATT_SERVICE_TRANSPORT_DISCOVERY ) {\n if ( is_writeable_response ( att_data -> opcode ) || att_data -> opcode == ATT_OPCODE_HANDLE_VALUE_CONFIRMATION ) break ;\n if ( ! is_writeable_request ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_INDICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_tds_opcode , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n if ( att_data -> opcode == 0x1B || att_data -> opcode == 0x1D ) {\n proto_tree_add_item ( tree , hf_btatt_tds_result_code , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n }\n else {\n proto_tree_add_item ( tree , hf_btatt_tds_organization_id , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n }\n if ( tvb_reported_length_remaining ( tvb , offset ) > 0 ) {\n proto_tree_add_item ( tree , hf_btatt_tds_data , tvb , offset , tvb_reported_length_remaining ( tvb , offset ) , ENC_NA ) ;\n offset += tvb_reported_length_remaining ( tvb , offset ) ;\n }\n break ;\n case 0x2ABD : if ( service_uuid . bt_uuid == GATT_SERVICE_OBJECT_TRANSFER ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_ots_feature_oacp , ett_btatt_value , hfx_btatt_ots_feature_oacp , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_ots_feature_olcp , ett_btatt_value , hfx_btatt_ots_feature_olcp , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n break ;\n case 0x2ABE : if ( service_uuid . bt_uuid == GATT_SERVICE_OBJECT_TRANSFER ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_ots_object_name , tvb , offset , tvb_captured_length_remaining ( tvb , offset ) , ENC_NA | ENC_UTF_8 ) ;\n offset += tvb_captured_length_remaining ( tvb , offset ) ;\n break ;\n case 0x2ABF : if ( service_uuid . bt_uuid == GATT_SERVICE_OBJECT_TRANSFER ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n offset = dissect_gatt_uuid ( tree , pinfo , tvb , offset ) ;\n break ;\n case 0x2AC0 : if ( service_uuid . bt_uuid == GATT_SERVICE_OBJECT_TRANSFER ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_ots_current_size , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n proto_tree_add_item ( tree , hf_btatt_ots_allocated_size , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n break ;\n case 0x2AC1 : if ( service_uuid . bt_uuid == GATT_SERVICE_OBJECT_TRANSFER ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n sub_item = proto_tree_add_item ( tree , hf_btatt_ots_object_first_created , tvb , offset , 7 , ENC_NA ) ;\n sub_tree = proto_item_add_subtree ( sub_item , ett_btatt_value ) ;\n call_dissector_with_data ( find_dissector ( \"btgatt.uuid0x2a08\" ) , tvb_new_subset_length_caplen ( tvb , offset , 7 , 7 ) , pinfo , sub_tree , att_data ) ;\n offset += 7 ;\n break ;\n case 0x2AC2 : if ( service_uuid . bt_uuid == GATT_SERVICE_OBJECT_TRANSFER ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n sub_item = proto_tree_add_item ( tree , hf_btatt_ots_object_last_modified , tvb , offset , 7 , ENC_NA ) ;\n sub_tree = proto_item_add_subtree ( sub_item , ett_btatt_value ) ;\n call_dissector_with_data ( find_dissector ( \"btgatt.uuid0x2a08\" ) , tvb_new_subset_length_caplen ( tvb , offset , 7 , 7 ) , pinfo , sub_tree , att_data ) ;\n offset += 7 ;\n break ;\n case 0x2AC3 : if ( service_uuid . bt_uuid == GATT_SERVICE_OBJECT_TRANSFER ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_ots_object_id , tvb , offset , 6 , ENC_LITTLE_ENDIAN ) ;\n offset += 6 ;\n break ;\n case 0x2AC4 : if ( service_uuid . bt_uuid == GATT_SERVICE_OBJECT_TRANSFER ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_ots_properties , ett_btatt_value , hfx_btatt_ots_properties , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n break ;\n case 0x2AC5 : if ( service_uuid . bt_uuid == GATT_SERVICE_OBJECT_TRANSFER ) {\n if ( is_writeable_response ( att_data -> opcode ) || att_data -> opcode == ATT_OPCODE_HANDLE_VALUE_CONFIRMATION ) break ;\n if ( ! is_writeable_request ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_INDICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_ots_action_opcode , tvb , offset , 1 , ENC_NA ) ;\n opcode = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n switch ( opcode ) {\n case 0x01 : proto_tree_add_item ( tree , hf_btatt_ots_size , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n offset = dissect_gatt_uuid ( tree , pinfo , tvb , offset ) ;\n break ;\n case 0x02 : case 0x07 : break ;\n case 0x03 : case 0x05 : case 0x06 : proto_tree_add_item ( tree , hf_btatt_ots_offset , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n proto_tree_add_item ( tree , hf_btatt_ots_length , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n break ;\n case 0x04 : if ( tvb_reported_length_remaining ( tvb , offset ) > 0 ) {\n proto_tree_add_item ( tree , hf_btatt_ots_execute_data , tvb , offset , tvb_reported_length_remaining ( tvb , offset ) , ENC_NA | ENC_UTF_8 ) ;\n offset += tvb_reported_length_remaining ( tvb , offset ) ;\n }\n break ;\n case 0x60 : proto_tree_add_item ( tree , hf_btatt_ots_action_response_opcode , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_ots_action_result_code , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n switch ( tvb_get_guint8 ( tvb , offset ) ) {\n case 0x01 : case 0x02 : case 0x05 : case 0x06 : case 0x07 : case 0x60 : break ;\n case 0x03 : proto_tree_add_checksum ( tree , tvb , offset , hf_btatt_ots_checksum , - 1 , NULL , pinfo , 0 , ENC_BIG_ENDIAN , PROTO_CHECKSUM_NO_FLAGS ) ;\n offset += 4 ;\n break ;\n case 0x04 : if ( tvb_reported_length_remaining ( tvb , offset ) > 0 ) {\n proto_tree_add_item ( tree , hf_btatt_ots_execute_data , tvb , offset , tvb_reported_length_remaining ( tvb , offset ) , ENC_NA | ENC_UTF_8 ) ;\n offset += tvb_reported_length_remaining ( tvb , offset ) ;\n }\n break ;\n }\n }\n break ;\n case 0x2AC6 : if ( service_uuid . bt_uuid == GATT_SERVICE_OBJECT_TRANSFER ) {\n if ( is_writeable_response ( att_data -> opcode ) || att_data -> opcode == ATT_OPCODE_HANDLE_VALUE_CONFIRMATION ) break ;\n if ( ! is_writeable_request ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_INDICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_ots_list_opcode , tvb , offset , 1 , ENC_NA ) ;\n opcode = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n switch ( opcode ) {\n case 0x01 : case 0x02 : case 0x03 : case 0x04 : case 0x07 : case 0x08 : break ;\n case 0x05 : proto_tree_add_item ( tree , hf_btatt_ots_object_id , tvb , offset , 6 , ENC_LITTLE_ENDIAN ) ;\n offset += 6 ;\n break ;\n case 0x06 : proto_tree_add_item ( tree , hf_btatt_ots_list_order , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x70 : proto_tree_add_item ( tree , hf_btatt_ots_list_response_opcode , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_ots_list_result_code , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n switch ( tvb_get_guint8 ( tvb , offset - 2 ) ) {\n case 0x01 : case 0x02 : case 0x03 : case 0x04 : case 0x05 : case 0x06 : case 0x08 : case 0x70 : break ;\n case 0x07 : proto_tree_add_item ( tree , hf_btatt_ots_list_total_number_of_objects , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n }\n }\n break ;\n case 0x2AC7 : if ( service_uuid . bt_uuid == GATT_SERVICE_OBJECT_TRANSFER ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_ots_filter , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n switch ( tvb_get_guint8 ( tvb , offset - 1 ) ) {\n case 0x00 : case 0x0A : break ;\n case 0x01 : case 0x02 : case 0x03 : case 0x04 : proto_tree_add_item ( tree , hf_btatt_ots_name_string , tvb , offset , tvb_reported_length_remaining ( tvb , offset ) , ENC_NA | ENC_UTF_8 ) ;\n offset += tvb_reported_length_remaining ( tvb , offset ) ;\n break ;\n case 0x05 : offset = dissect_gatt_uuid ( tree , pinfo , tvb , offset ) ;\n break ;\n case 0x06 : case 0x07 : call_dissector_with_data ( find_dissector ( \"btgatt.uuid0x2a08\" ) , tvb_new_subset_length_caplen ( tvb , offset , 7 , 7 ) , pinfo , tree , att_data ) ;\n offset += 7 ;\n call_dissector_with_data ( find_dissector ( \"btgatt.uuid0x2a08\" ) , tvb_new_subset_length_caplen ( tvb , offset , 7 , 7 ) , pinfo , tree , att_data ) ;\n offset += 7 ;\n break ;\n case 0x08 : case 0x09 : proto_tree_add_item ( tree , hf_btatt_ots_size_from , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n proto_tree_add_item ( tree , hf_btatt_ots_size_to , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n break ;\n }\n break ;\n case 0x2AC8 : if ( service_uuid . bt_uuid == GATT_SERVICE_OBJECT_TRANSFER ) {\n if ( att_data -> opcode == ATT_OPCODE_HANDLE_VALUE_CONFIRMATION ) break ;\n if ( att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_INDICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_ots_flags , ett_btatt_value , hfx_btatt_ots_flags , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_ots_object_id , tvb , offset , 6 , ENC_LITTLE_ENDIAN ) ;\n offset += 6 ;\n break ;\n case 0x2AC9 : if ( service_uuid . bt_uuid == GATT_SERVICE_GENERIC_ACCESS_PROFILE ) {\n if ( ! ( is_readable_request ( att_data -> opcode ) || is_readable_response ( att_data -> opcode ) ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_resolvable_private_address , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2ACC : if ( service_uuid . bt_uuid == GATT_SERVICE_FITNESS_MACHINE ) {\n if ( ! ( is_readable_request ( att_data -> opcode ) || is_readable_response ( att_data -> opcode ) ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n sub_item = proto_tree_add_item ( tree , hf_btatt_value , tvb , offset , - 1 , ENC_NA ) ;\n expert_add_info ( pinfo , sub_item , & ei_btatt_undecoded ) ;\n offset = tvb_captured_length ( tvb ) ;\n break ;\n case 0x2ACD : if ( service_uuid . bt_uuid == GATT_SERVICE_FITNESS_MACHINE ) {\n if ( att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n sub_item = proto_tree_add_item ( tree , hf_btatt_value , tvb , offset , - 1 , ENC_NA ) ;\n expert_add_info ( pinfo , sub_item , & ei_btatt_undecoded ) ;\n offset = tvb_captured_length ( tvb ) ;\n break ;\n case 0x2ACE : if ( service_uuid . bt_uuid == GATT_SERVICE_FITNESS_MACHINE ) {\n if ( att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n sub_item = proto_tree_add_item ( tree , hf_btatt_value , tvb , offset , - 1 , ENC_NA ) ;\n expert_add_info ( pinfo , sub_item , & ei_btatt_undecoded ) ;\n offset = tvb_captured_length ( tvb ) ;\n break ;\n case 0x2ACF : if ( service_uuid . bt_uuid == GATT_SERVICE_FITNESS_MACHINE ) {\n if ( att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n sub_item = proto_tree_add_item ( tree , hf_btatt_value , tvb , offset , - 1 , ENC_NA ) ;\n expert_add_info ( pinfo , sub_item , & ei_btatt_undecoded ) ;\n offset = tvb_captured_length ( tvb ) ;\n break ;\n case 0x2AD0 : if ( service_uuid . bt_uuid == GATT_SERVICE_FITNESS_MACHINE ) {\n if ( att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n sub_item = proto_tree_add_item ( tree , hf_btatt_value , tvb , offset , - 1 , ENC_NA ) ;\n expert_add_info ( pinfo , sub_item , & ei_btatt_undecoded ) ;\n offset = tvb_captured_length ( tvb ) ;\n break ;\n case 0x2AD1 : if ( service_uuid . bt_uuid == GATT_SERVICE_FITNESS_MACHINE ) {\n if ( att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n sub_item = proto_tree_add_item ( tree , hf_btatt_value , tvb , offset , - 1 , ENC_NA ) ;\n expert_add_info ( pinfo , sub_item , & ei_btatt_undecoded ) ;\n offset = tvb_captured_length ( tvb ) ;\n break ;\n case 0x2AD2 : if ( service_uuid . bt_uuid == GATT_SERVICE_FITNESS_MACHINE ) {\n if ( att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n sub_item = proto_tree_add_item ( tree , hf_btatt_value , tvb , offset , - 1 , ENC_NA ) ;\n expert_add_info ( pinfo , sub_item , & ei_btatt_undecoded ) ;\n offset = tvb_captured_length ( tvb ) ;\n break ;\n case 0x2AD3 : if ( service_uuid . bt_uuid == GATT_SERVICE_FITNESS_MACHINE ) {\n if ( ! ( is_readable_request ( att_data -> opcode ) || is_readable_response ( att_data -> opcode ) || att_data -> opcode == ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n sub_item = proto_tree_add_item ( tree , hf_btatt_value , tvb , offset , - 1 , ENC_NA ) ;\n expert_add_info ( pinfo , sub_item , & ei_btatt_undecoded ) ;\n offset = tvb_captured_length ( tvb ) ;\n break ;\n case 0x2AD4 : if ( service_uuid . bt_uuid == GATT_SERVICE_FITNESS_MACHINE ) {\n if ( ! ( is_readable_request ( att_data -> opcode ) || is_readable_response ( att_data -> opcode ) ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n sub_item = proto_tree_add_item ( tree , hf_btatt_value , tvb , offset , - 1 , ENC_NA ) ;\n expert_add_info ( pinfo , sub_item , & ei_btatt_undecoded ) ;\n offset = tvb_captured_length ( tvb ) ;\n break ;\n case 0x2AD5 : if ( service_uuid . bt_uuid == GATT_SERVICE_FITNESS_MACHINE ) {\n if ( ! ( is_readable_request ( att_data -> opcode ) || is_readable_response ( att_data -> opcode ) ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n sub_item = proto_tree_add_item ( tree , hf_btatt_value , tvb , offset , - 1 , ENC_NA ) ;\n expert_add_info ( pinfo , sub_item , & ei_btatt_undecoded ) ;\n offset = tvb_captured_length ( tvb ) ;\n break ;\n case 0x2AD6 : if ( service_uuid . bt_uuid == GATT_SERVICE_FITNESS_MACHINE ) {\n if ( ! ( is_readable_request ( att_data -> opcode ) || is_readable_response ( att_data -> opcode ) ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n sub_item = proto_tree_add_item ( tree , hf_btatt_value , tvb , offset , - 1 , ENC_NA ) ;\n expert_add_info ( pinfo , sub_item , & ei_btatt_undecoded ) ;\n offset = tvb_captured_length ( tvb ) ;\n break ;\n case 0x2AD7 : if ( service_uuid . bt_uuid == GATT_SERVICE_FITNESS_MACHINE ) {\n if ( ! ( is_readable_request ( att_data -> opcode ) || is_readable_response ( att_data -> opcode ) ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n sub_item = proto_tree_add_item ( tree , hf_btatt_value , tvb , offset , - 1 , ENC_NA ) ;\n expert_add_info ( pinfo , sub_item , & ei_btatt_undecoded ) ;\n offset = tvb_captured_length ( tvb ) ;\n break ;\n case 0x2AD8 : if ( service_uuid . bt_uuid == GATT_SERVICE_FITNESS_MACHINE ) {\n if ( ! ( is_readable_request ( att_data -> opcode ) || is_readable_response ( att_data -> opcode ) ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n sub_item = proto_tree_add_item ( tree , hf_btatt_value , tvb , offset , - 1 , ENC_NA ) ;\n expert_add_info ( pinfo , sub_item , & ei_btatt_undecoded ) ;\n offset = tvb_captured_length ( tvb ) ;\n break ;\n case 0x2AD9 : if ( service_uuid . bt_uuid == GATT_SERVICE_FITNESS_MACHINE ) {\n if ( is_writeable_response ( att_data -> opcode ) || att_data -> opcode == ATT_OPCODE_HANDLE_VALUE_CONFIRMATION ) break ;\n if ( ! is_writeable_request ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_INDICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n sub_item = proto_tree_add_item ( tree , hf_btatt_value , tvb , offset , - 1 , ENC_NA ) ;\n expert_add_info ( pinfo , sub_item , & ei_btatt_undecoded ) ;\n offset = tvb_captured_length ( tvb ) ;\n break ;\n case 0x2ADA : if ( service_uuid . bt_uuid == GATT_SERVICE_FITNESS_MACHINE ) {\n if ( att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n sub_item = proto_tree_add_item ( tree , hf_btatt_value , tvb , offset , - 1 , ENC_NA ) ;\n expert_add_info ( pinfo , sub_item , & ei_btatt_undecoded ) ;\n offset = tvb_captured_length ( tvb ) ;\n break ;\n case 0x2A1F : case 0x2A20 : case 0x2A2F : case 0x2A30 : case 0x2A3A : case 0x2A3B : case 0x2A3C : case 0x2A3D : case 0x2A3E : case 0x2A57 : case 0x2A59 : case 0x2ADB : case 0x2ADC : case 0x2ADD : case 0x2ADE : case 0x2AE0 : case 0x2AE1 : case 0x2AE2 : case 0x2AE3 : case 0x2AE4 : case 0x2AE5 : case 0x2AE6 : case 0x2AE7 : case 0x2AE8 : case 0x2AE9 : case 0x2AEA : case 0x2AEB : case 0x2AEC : case 0x2AED : case 0x2AEE : case 0x2AEF : case 0x2AF0 : case 0x2AF1 : case 0x2AF2 : case 0x2AF3 : case 0x2AF4 : case 0x2AF5 : case 0x2AF6 : case 0x2AF7 : case 0x2AF8 : case 0x2AF9 : case 0x2AFA : case 0x2AFB : case 0x2AFC : case 0x2AFD : case 0x2AFE : case 0x2AFF : case 0x2B00 : case 0x2B01 : case 0x2B02 : case 0x2B03 : case 0x2B04 : case 0x2B05 : case 0x2B06 : case 0x2B07 : case 0x2B08 : case 0x2B09 : case 0x2B0A : case 0x2B0B : case 0x2B0C : case 0x2B0D : case 0x2B0E : case 0x2B0F : case 0x2B10 : case 0x2B11 : case 0x2B12 : case 0x2B13 : case 0x2B14 : case 0x2B15 : case 0x2B16 : case 0x2B17 : case 0x2B18 : case 0x2B19 : case 0x2B1A : case 0x2B1B : case 0x2B1C : case 0x2B1D : case 0x2B1E : case 0x2B1F : default : if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_value , tvb , offset , - 1 , ENC_NA ) ;\n offset = tvb_captured_length ( tvb ) ;\n }\n return old_offset + offset ;\n }", "idx": 740}
{"hash": -7777644912037188223, "project": "debian", "size": 15, "label": 0, "functionSource": "static int dissect_sigcomp ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , void * data _U_ ) {\n proto_item * ti ;\n proto_tree * sigcomp_tree ;\n gint offset = 0 ;\n gint8 octet ;\n if ( pinfo -> ptype == PT_TCP ) return dissect_sigcomp_tcp ( tvb , pinfo , tree , NULL ) ;\n octet = tvb_get_guint8 ( tvb , offset ) ;\n if ( ( octet & 0xf8 ) != 0xf8 ) return 0 ;\n col_set_str ( pinfo -> cinfo , COL_PROTOCOL , \"SIGCOMP\" ) ;\n col_clear ( pinfo -> cinfo , COL_INFO ) ;\n top_tree = tree ;\n ti = proto_tree_add_item ( tree , proto_sigcomp , tvb , 0 , - 1 , ENC_NA ) ;\n sigcomp_tree = proto_item_add_subtree ( ti , ett_sigcomp ) ;\n return dissect_sigcomp_common ( tvb , pinfo , sigcomp_tree ) ;\n }", "idx": 741}
{"hash": 6249489553242542670, "project": "debian", "size": 6, "label": 0, "functionSource": "int_node * create_int_node ( int val ) {\n int_node * i_n ;\n i_n = emalloc_zero ( sizeof ( * i_n ) ) ;\n i_n -> i = val ;\n return i_n ;\n }", "idx": 742}
{"hash": 1182028467273264883, "project": "debian", "size": 14, "label": 0, "functionSource": "void report_or_die ( const char * fmt , ... ) {\n va_list args ;\n DBUG_ENTER ( \"report_or_die\" ) ;\n char buff [ DIE_BUFF_SIZE ] ;\n va_start ( args , fmt ) ;\n make_error_message ( buff , sizeof ( buff ) , fmt , args ) ;\n va_end ( args ) ;\n if ( opt_continue_on_error ) {\n replace_dynstr_append ( & ds_res , buff ) ;\n error_count ++ ;\n DBUG_VOID_RETURN ;\n }\n really_die ( buff ) ;\n }", "idx": 743}
{"hash": 8445816931248660591, "project": "debian", "size": 31, "label": 0, "functionSource": "SPL_METHOD ( SplDoublyLinkedList , serialize ) {\n spl_dllist_object * intern = ( spl_dllist_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n smart_str buf = {\n 0 }\n ;\n spl_ptr_llist_element * current = intern -> llist -> head , * next ;\n zval * flags ;\n php_serialize_data_t var_hash ;\n if ( zend_parse_parameters_none ( ) == FAILURE ) {\n return ;\n }\n PHP_VAR_SERIALIZE_INIT ( var_hash ) ;\n MAKE_STD_ZVAL ( flags ) ;\n ZVAL_LONG ( flags , intern -> flags ) ;\n php_var_serialize ( & buf , & flags , & var_hash TSRMLS_CC ) ;\n zval_ptr_dtor ( & flags ) ;\n while ( current ) {\n smart_str_appendc ( & buf , ':' ) ;\n next = current -> next ;\n php_var_serialize ( & buf , ( zval * * ) & current -> data , & var_hash TSRMLS_CC ) ;\n current = next ;\n }\n smart_str_0 ( & buf ) ;\n PHP_VAR_SERIALIZE_DESTROY ( var_hash ) ;\n if ( buf . c ) {\n RETURN_STRINGL ( buf . c , buf . len , 0 ) ;\n }\n else {\n RETURN_NULL ( ) ;\n }\n }", "idx": 744}
{"hash": -6245610163896160314, "project": "debian", "size": 12, "label": 0, "functionSource": "static void malta_fpga_reset ( void * opaque ) {\n MaltaFPGAState * s = opaque ;\n s -> leds = 0x00 ;\n s -> brk = 0x0a ;\n s -> gpout = 0x00 ;\n s -> i2cin = 0x3 ;\n s -> i2coe = 0x0 ;\n s -> i2cout = 0x3 ;\n s -> i2csel = 0x1 ;\n s -> display_text [ 8 ] = '\\0' ;\n snprintf ( s -> display_text , 9 , \" \" ) ;\n }", "idx": 745}
{"hash": -2222758297961835509, "project": "debian", "size": 8, "label": 0, "functionSource": "static uint16_t inv_bits ( uint16_t val , int nbits ) {\n uint16_t res ;\n if ( nbits <= 8 ) {\n res = ff_reverse [ val ] >> ( 8 - nbits ) ;\n }\n else res = ( ( ff_reverse [ val & 0xFF ] << 8 ) + ( ff_reverse [ val >> 8 ] ) ) >> ( 16 - nbits ) ;\n return res ;\n }", "idx": 746}
{"hash": 1182028467273264883, "project": "debian", "size": 9, "label": 0, "functionSource": "void timer_output ( void ) {\n if ( timer_file ) {\n char buf [ 32 ] , * end ;\n ulonglong timer = timer_now ( ) - timer_start ;\n end = longlong10_to_str ( timer , buf , 10 ) ;\n str_to_file ( timer_file , buf , ( int ) ( end - buf ) ) ;\n timer_file = 0 ;\n }\n }", "idx": 747}
{"hash": -4960438251319819237, "project": "chrome", "size": 43, "label": 0, "functionSource": "static void first_pass_motion_search ( VP9_COMP * cpi , MACROBLOCK * x , const MV * ref_mv , MV * best_mv , int * best_motion_err ) {\n MACROBLOCKD * const xd = & x -> e_mbd ;\n MV tmp_mv = {\n 0 , 0 }\n ;\n MV ref_mv_full = {\n ref_mv -> row >> 3 , ref_mv -> col >> 3 }\n ;\n int num00 , tmp_err , n ;\n const BLOCK_SIZE bsize = xd -> mi [ 0 ] . src_mi -> mbmi . sb_type ;\n vp9_variance_fn_ptr_t v_fn_ptr = cpi -> fn_ptr [ bsize ] ;\n const int new_mv_mode_penalty = NEW_MV_MODE_PENALTY ;\n int step_param = 3 ;\n int further_steps = ( MAX_MVSEARCH_STEPS - 1 ) - step_param ;\n const int sr = get_search_range ( & cpi -> common ) ;\n step_param += sr ;\n further_steps -= sr ;\n v_fn_ptr . vf = get_block_variance_fn ( bsize ) ;\n tmp_err = cpi -> diamond_search_sad ( x , & cpi -> ss_cfg , & ref_mv_full , & tmp_mv , step_param , x -> sadperbit16 , & num00 , & v_fn_ptr , ref_mv ) ;\n if ( tmp_err < INT_MAX ) tmp_err = vp9_get_mvpred_var ( x , & tmp_mv , ref_mv , & v_fn_ptr , 1 ) ;\n if ( tmp_err < INT_MAX - new_mv_mode_penalty ) tmp_err += new_mv_mode_penalty ;\n if ( tmp_err < * best_motion_err ) {\n * best_motion_err = tmp_err ;\n * best_mv = tmp_mv ;\n }\n n = num00 ;\n num00 = 0 ;\n while ( n < further_steps ) {\n ++ n ;\n if ( num00 ) {\n -- num00 ;\n }\n else {\n tmp_err = cpi -> diamond_search_sad ( x , & cpi -> ss_cfg , & ref_mv_full , & tmp_mv , step_param + n , x -> sadperbit16 , & num00 , & v_fn_ptr , ref_mv ) ;\n if ( tmp_err < INT_MAX ) tmp_err = vp9_get_mvpred_var ( x , & tmp_mv , ref_mv , & v_fn_ptr , 1 ) ;\n if ( tmp_err < INT_MAX - new_mv_mode_penalty ) tmp_err += new_mv_mode_penalty ;\n if ( tmp_err < * best_motion_err ) {\n * best_motion_err = tmp_err ;\n * best_mv = tmp_mv ;\n }\n }\n }\n }", "idx": 748}
{"hash": 2687336064028423153, "project": "chrome", "size": 31, "label": 0, "functionSource": "static int server_request_free ( struct server_request * req ) {\n int i , rc = 1 ;\n if ( req -> base . questions ) {\n for ( i = 0 ;\n i < req -> base . nquestions ;\n ++ i ) free ( req -> base . questions [ i ] ) ;\n free ( req -> base . questions ) ;\n }\n if ( req -> port ) {\n if ( req -> port -> pending_replies == req ) {\n if ( req -> next_pending ) req -> port -> pending_replies = req -> next_pending ;\n else req -> port -> pending_replies = NULL ;\n }\n rc = -- req -> port -> refcnt ;\n }\n if ( req -> response ) {\n free ( req -> response ) ;\n }\n server_request_free_answers ( req ) ;\n if ( req -> next_pending && req -> next_pending != req ) {\n req -> next_pending -> prev_pending = req -> prev_pending ;\n req -> prev_pending -> next_pending = req -> next_pending ;\n }\n if ( rc == 0 ) {\n server_port_free ( req -> port ) ;\n free ( req ) ;\n return ( 1 ) ;\n }\n free ( req ) ;\n return ( 0 ) ;\n }", "idx": 749}
{"hash": -5706788925640467782, "project": "chrome", "size": 19, "label": 1, "functionSource": "static int sb_has_motion ( const VP9_COMMON * cm , MODE_INFO * * prev_mi_8x8 , const int motion_thresh ) {\n const int mis = cm -> mi_stride ;\n int block_row , block_col ;\n if ( cm -> prev_mi ) {\n for ( block_row = 0 ;\n block_row < 8 ;\n ++ block_row ) {\n for ( block_col = 0 ;\n block_col < 8 ;\n ++ block_col ) {\n const MODE_INFO * prev_mi = prev_mi_8x8 [ block_row * mis + block_col ] ;\n if ( prev_mi ) {\n if ( abs ( prev_mi -> mbmi . mv [ 0 ] . as_mv . row ) > motion_thresh || abs ( prev_mi -> mbmi . mv [ 0 ] . as_mv . col ) > motion_thresh ) return 1 ;\n }\n }\n }\n }\n return 0 ;\n }", "idx": 750}
{"hash": 1760449185745615462, "project": "debian", "size": 5, "label": 0, "functionSource": "TSMutex TSContMutexGet ( TSCont contp ) {\n sdk_assert ( sdk_sanity_check_iocore_structure ( contp ) == TS_SUCCESS ) ;\n Continuation * c = ( Continuation * ) contp ;\n return ( TSMutex ) ( c -> mutex . get ( ) ) ;\n }", "idx": 751}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_RequestModeAck ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_RequestModeAck , RequestModeAck_sequence ) ;\n return offset ;\n }", "idx": 752}
{"hash": -482717283558482293, "project": "debian", "size": 103, "label": 1, "functionSource": "static int mpc7_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n AVFrame * frame = data ;\n const uint8_t * buf = avpkt -> data ;\n int buf_size ;\n MPCContext * c = avctx -> priv_data ;\n GetBitContext gb ;\n int i , ch ;\n int mb = - 1 ;\n Band * bands = c -> bands ;\n int off , ret , last_frame , skip ;\n int bits_used , bits_avail ;\n memset ( bands , 0 , sizeof ( * bands ) * ( c -> maxbands + 1 ) ) ;\n buf_size = avpkt -> size & ~ 3 ;\n if ( buf_size <= 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"packet size is too small (%i bytes)\\n\" , avpkt -> size ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( buf_size != avpkt -> size ) {\n av_log ( avctx , AV_LOG_WARNING , \"packet size is not a multiple of 4. \" \"extra bytes at the end will be skipped.\\n\" ) ;\n }\n skip = buf [ 0 ] ;\n last_frame = buf [ 1 ] ;\n buf += 4 ;\n buf_size -= 4 ;\n frame -> nb_samples = last_frame ? c -> lastframelen : MPC_FRAME_SIZE ;\n if ( ( ret = ff_get_buffer ( avctx , frame ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n av_fast_padded_malloc ( & c -> bits , & c -> buf_size , buf_size ) ;\n if ( ! c -> bits ) return AVERROR ( ENOMEM ) ;\n c -> dsp . bswap_buf ( ( uint32_t * ) c -> bits , ( const uint32_t * ) buf , buf_size >> 2 ) ;\n init_get_bits ( & gb , c -> bits , buf_size * 8 ) ;\n skip_bits_long ( & gb , skip ) ;\n for ( i = 0 ;\n i <= c -> maxbands ;\n i ++ ) {\n for ( ch = 0 ;\n ch < 2 ;\n ch ++ ) {\n int t = 4 ;\n if ( i ) t = get_vlc2 ( & gb , hdr_vlc . table , MPC7_HDR_BITS , 1 ) - 5 ;\n if ( t == 4 ) bands [ i ] . res [ ch ] = get_bits ( & gb , 4 ) ;\n else bands [ i ] . res [ ch ] = av_clip ( bands [ i - 1 ] . res [ ch ] + t , 0 , 17 ) ;\n }\n if ( bands [ i ] . res [ 0 ] || bands [ i ] . res [ 1 ] ) {\n mb = i ;\n if ( c -> MSS ) bands [ i ] . msf = get_bits1 ( & gb ) ;\n }\n }\n for ( i = 0 ;\n i <= mb ;\n i ++ ) for ( ch = 0 ;\n ch < 2 ;\n ch ++ ) if ( bands [ i ] . res [ ch ] ) bands [ i ] . scfi [ ch ] = get_vlc2 ( & gb , scfi_vlc . table , MPC7_SCFI_BITS , 1 ) ;\n for ( i = 0 ;\n i <= mb ;\n i ++ ) {\n for ( ch = 0 ;\n ch < 2 ;\n ch ++ ) {\n if ( bands [ i ] . res [ ch ] ) {\n bands [ i ] . scf_idx [ ch ] [ 2 ] = c -> oldDSCF [ ch ] [ i ] ;\n bands [ i ] . scf_idx [ ch ] [ 0 ] = get_scale_idx ( & gb , bands [ i ] . scf_idx [ ch ] [ 2 ] ) ;\n switch ( bands [ i ] . scfi [ ch ] ) {\n case 0 : bands [ i ] . scf_idx [ ch ] [ 1 ] = get_scale_idx ( & gb , bands [ i ] . scf_idx [ ch ] [ 0 ] ) ;\n bands [ i ] . scf_idx [ ch ] [ 2 ] = get_scale_idx ( & gb , bands [ i ] . scf_idx [ ch ] [ 1 ] ) ;\n break ;\n case 1 : bands [ i ] . scf_idx [ ch ] [ 1 ] = get_scale_idx ( & gb , bands [ i ] . scf_idx [ ch ] [ 0 ] ) ;\n bands [ i ] . scf_idx [ ch ] [ 2 ] = bands [ i ] . scf_idx [ ch ] [ 1 ] ;\n break ;\n case 2 : bands [ i ] . scf_idx [ ch ] [ 1 ] = bands [ i ] . scf_idx [ ch ] [ 0 ] ;\n bands [ i ] . scf_idx [ ch ] [ 2 ] = get_scale_idx ( & gb , bands [ i ] . scf_idx [ ch ] [ 1 ] ) ;\n break ;\n case 3 : bands [ i ] . scf_idx [ ch ] [ 2 ] = bands [ i ] . scf_idx [ ch ] [ 1 ] = bands [ i ] . scf_idx [ ch ] [ 0 ] ;\n break ;\n }\n c -> oldDSCF [ ch ] [ i ] = bands [ i ] . scf_idx [ ch ] [ 2 ] ;\n }\n }\n }\n memset ( c -> Q , 0 , sizeof ( c -> Q ) ) ;\n off = 0 ;\n for ( i = 0 ;\n i < BANDS ;\n i ++ , off += SAMPLES_PER_BAND ) for ( ch = 0 ;\n ch < 2 ;\n ch ++ ) idx_to_quant ( c , & gb , bands [ i ] . res [ ch ] , c -> Q [ ch ] + off ) ;\n ff_mpc_dequantize_and_synth ( c , mb , ( int16_t * * ) frame -> extended_data , 2 ) ;\n bits_used = get_bits_count ( & gb ) ;\n bits_avail = buf_size * 8 ;\n if ( ! last_frame && ( ( bits_avail < bits_used ) || ( bits_used + 32 <= bits_avail ) ) ) {\n av_log ( avctx , AV_LOG_ERROR , \"Error decoding frame: used %i of %i bits\\n\" , bits_used , bits_avail ) ;\n return - 1 ;\n }\n if ( c -> frames_to_skip ) {\n c -> frames_to_skip -- ;\n * got_frame_ptr = 0 ;\n return avpkt -> size ;\n }\n * got_frame_ptr = 1 ;\n return avpkt -> size ;\n }", "idx": 753}
{"hash": -1315695702746584250, "project": "debian", "size": 6, "label": 0, "functionSource": "gboolean proto_tracking_interesting_fields ( const proto_tree * tree ) {\n GHashTable * interesting_hfids ;\n if ( ! tree ) return FALSE ;\n interesting_hfids = PTREE_DATA ( tree ) -> interesting_hfids ;\n return ( interesting_hfids != NULL ) && g_hash_table_size ( interesting_hfids ) ;\n }", "idx": 754}
{"hash": -5706788925640467782, "project": "chrome", "size": 34, "label": 0, "functionSource": "static void set_offsets ( VP9_COMP * cpi , const TileInfo * const tile , int mi_row , int mi_col , BLOCK_SIZE bsize ) {\n MACROBLOCK * const x = & cpi -> mb ;\n VP9_COMMON * const cm = & cpi -> common ;\n MACROBLOCKD * const xd = & x -> e_mbd ;\n MB_MODE_INFO * mbmi ;\n const int mi_width = num_8x8_blocks_wide_lookup [ bsize ] ;\n const int mi_height = num_8x8_blocks_high_lookup [ bsize ] ;\n const struct segmentation * const seg = & cm -> seg ;\n set_skip_context ( xd , mi_row , mi_col ) ;\n set_modeinfo_offsets ( cm , xd , mi_row , mi_col ) ;\n mbmi = & xd -> mi [ 0 ] . src_mi -> mbmi ;\n vp9_setup_dst_planes ( xd -> plane , get_frame_new_buffer ( cm ) , mi_row , mi_col ) ;\n x -> mv_row_min = - ( ( ( mi_row + mi_height ) * MI_SIZE ) + VP9_INTERP_EXTEND ) ;\n x -> mv_col_min = - ( ( ( mi_col + mi_width ) * MI_SIZE ) + VP9_INTERP_EXTEND ) ;\n x -> mv_row_max = ( cm -> mi_rows - mi_row ) * MI_SIZE + VP9_INTERP_EXTEND ;\n x -> mv_col_max = ( cm -> mi_cols - mi_col ) * MI_SIZE + VP9_INTERP_EXTEND ;\n assert ( ! ( mi_col & ( mi_width - 1 ) ) && ! ( mi_row & ( mi_height - 1 ) ) ) ;\n set_mi_row_col ( xd , tile , mi_row , mi_height , mi_col , mi_width , cm -> mi_rows , cm -> mi_cols ) ;\n vp9_setup_src_planes ( x , cpi -> Source , mi_row , mi_col ) ;\n x -> rddiv = cpi -> rd . RDDIV ;\n x -> rdmult = cpi -> rd . RDMULT ;\n if ( seg -> enabled ) {\n if ( cpi -> oxcf . aq_mode != VARIANCE_AQ ) {\n const uint8_t * const map = seg -> update_map ? cpi -> segmentation_map : cm -> last_frame_seg_map ;\n mbmi -> segment_id = vp9_get_segment_id ( cm , map , bsize , mi_row , mi_col ) ;\n }\n vp9_init_plane_quantizers ( cpi , x ) ;\n x -> encode_breakout = cpi -> segment_encode_breakout [ mbmi -> segment_id ] ;\n }\n else {\n mbmi -> segment_id = 0 ;\n x -> encode_breakout = cpi -> encode_breakout ;\n }\n }", "idx": 755}
{"hash": 6302861533225984845, "project": "debian", "size": 20, "label": 0, "functionSource": "static uint64_t pxa2xx_i2s_read ( void * opaque , hwaddr addr , unsigned size ) {\n PXA2xxI2SState * s = ( PXA2xxI2SState * ) opaque ;\n switch ( addr ) {\n case SACR0 : return s -> control [ 0 ] ;\n case SACR1 : return s -> control [ 1 ] ;\n case SASR0 : return s -> status ;\n case SAIMR : return s -> mask ;\n case SAICR : return 0 ;\n case SADIV : return s -> clk ;\n case SADR : if ( s -> rx_len > 0 ) {\n s -> rx_len -- ;\n pxa2xx_i2s_update ( s ) ;\n return s -> codec_in ( s -> opaque ) ;\n }\n return 0 ;\n default : printf ( \"%s: Bad register \" REG_FMT \"\\n\" , __FUNCTION__ , addr ) ;\n break ;\n }\n return 0 ;\n }", "idx": 756}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_SET_SIZE_1_15_OF_MultiplexTableEntryNumber ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_constrained_set_of ( tvb , offset , actx , tree , hf_index , ett_h245_SET_SIZE_1_15_OF_MultiplexTableEntryNumber , SET_SIZE_1_15_OF_MultiplexTableEntryNumber_set_of , 1 , 15 , FALSE ) ;\n return offset ;\n }", "idx": 757}
{"hash": 6336384260629386331, "project": "debian", "size": 27, "label": 0, "functionSource": "static void dissect_zcl_scenes_get_scene_membership_response ( tvbuff_t * tvb , proto_tree * tree , guint * offset ) {\n proto_item * scene_list ;\n proto_tree * scene_list_tree ;\n guint8 status , count , i ;\n status = tvb_get_guint8 ( tvb , * offset ) ;\n proto_tree_add_item ( tree , hf_zbee_zcl_scenes_status , tvb , * offset , 1 , ENC_LITTLE_ENDIAN ) ;\n * offset += 1 ;\n proto_tree_add_item ( tree , hf_zbee_zcl_scenes_capacity , tvb , * offset , 1 , ENC_LITTLE_ENDIAN ) ;\n * offset += 1 ;\n proto_tree_add_item ( tree , hf_zbee_zcl_scenes_group_id , tvb , * offset , 2 , ENC_LITTLE_ENDIAN ) ;\n * offset += 2 ;\n if ( status == ZBEE_ZCL_STAT_SUCCESS ) {\n count = tvb_get_guint8 ( tvb , * offset ) ;\n proto_tree_add_uint ( tree , hf_zbee_zcl_scenes_scene_count , tvb , * offset , 1 , count ) ;\n * offset += 1 ;\n if ( count > 0 ) {\n scene_list = proto_tree_add_item ( tree , hf_zbee_zcl_scenes_scene_list , tvb , * offset , count , ENC_NA ) ;\n scene_list_tree = proto_item_add_subtree ( scene_list , ett_zbee_zcl_scenes_scene_ctrl ) ;\n for ( i = 0 ;\n i < count ;\n i ++ ) {\n proto_tree_add_item ( scene_list_tree , hf_zbee_zcl_scenes_scene_id , tvb , * offset , 1 , ENC_LITTLE_ENDIAN ) ;\n * offset += 1 ;\n }\n }\n }\n }", "idx": 758}
{"hash": 2388171415474875762, "project": "debian", "size": 26, "label": 0, "functionSource": "static inline int rsvp_class_to_filter_num ( int classnum ) {\n switch ( classnum ) {\n case RSVP_CLASS_SESSION : case RSVP_CLASS_HOP : case RSVP_CLASS_INTEGRITY : case RSVP_CLASS_TIME_VALUES : case RSVP_CLASS_ERROR : case RSVP_CLASS_SCOPE : case RSVP_CLASS_STYLE : case RSVP_CLASS_FLOWSPEC : case RSVP_CLASS_FILTER_SPEC : case RSVP_CLASS_SENDER_TEMPLATE : case RSVP_CLASS_SENDER_TSPEC : case RSVP_CLASS_ADSPEC : case RSVP_CLASS_POLICY : case RSVP_CLASS_CONFIRM : case RSVP_CLASS_LABEL : case RSVP_CLASS_LABEL_REQUEST : case RSVP_CLASS_HELLO : case RSVP_CLASS_EXPLICIT_ROUTE : case RSVP_CLASS_RECORD_ROUTE : case RSVP_CLASS_MESSAGE_ID : case RSVP_CLASS_MESSAGE_ID_ACK : case RSVP_CLASS_MESSAGE_ID_LIST : return classnum + RSVPF_OBJECT ;\n break ;\n case RSVP_CLASS_RECOVERY_LABEL : case RSVP_CLASS_UPSTREAM_LABEL : case RSVP_CLASS_LABEL_SET : case RSVP_CLASS_PROTECTION : return RSVPF_RECOVERY_LABEL + ( classnum - RSVP_CLASS_RECOVERY_LABEL ) ;\n case RSVP_CLASS_SUGGESTED_LABEL : case RSVP_CLASS_ACCEPTABLE_LABEL_SET : case RSVP_CLASS_RESTART_CAP : return RSVPF_SUGGESTED_LABEL + ( classnum - RSVP_CLASS_SUGGESTED_LABEL ) ;\n case RSVP_CLASS_LINK_CAP : return RSVPF_LINK_CAP ;\n case RSVP_CLASS_DIFFSERV : return RSVPF_DIFFSERV ;\n case RSVP_CLASS_CLASSTYPE : return RSVPF_DSTE ;\n case RSVP_CLASS_NOTIFY_REQUEST : return RSVPF_NOTIFY_REQUEST ;\n case RSVP_CLASS_ADMIN_STATUS : return RSVPF_ADMIN_STATUS ;\n case RSVP_CLASS_LSP_ATTRIBUTES : return RSVPF_LSP_ATTRIBUTES ;\n case RSVP_CLASS_ASSOCIATION : return RSVPF_ASSOCIATION ;\n case RSVP_CLASS_CALL_ATTRIBUTES : return RSVPF_CALL_ATTRIBUTES ;\n case RSVP_CLASS_SESSION_ATTRIBUTE : return RSVPF_SESSION_ATTRIBUTE ;\n case RSVP_CLASS_GENERALIZED_UNI : return RSVPF_GENERALIZED_UNI ;\n case RSVP_CLASS_CALL_ID : return RSVPF_CALL_ID ;\n case RSVP_CLASS_3GPP2_OBJECT : return RSVPF_3GPP2_OBJECT ;\n case RSVP_CLASS_DCLASS : return RSVPF_DCLASS ;\n case RSVP_CLASS_LSP_TUNNEL_IF_ID : return RSVPF_LSP_TUNNEL_IF_ID ;\n case RSVP_CLASS_EXCLUDE_ROUTE : return RSVPF_EXCLUDE_ROUTE ;\n case RSVP_CLASS_JUNIPER_PROPERTIES : return RSVPF_JUNIPER ;\n case RSVP_CLASS_VENDOR_PRIVATE_1 : case RSVP_CLASS_VENDOR_PRIVATE_2 : case RSVP_CLASS_VENDOR_PRIVATE_3 : case RSVP_CLASS_VENDOR_PRIVATE_4 : case RSVP_CLASS_VENDOR_PRIVATE_5 : case RSVP_CLASS_VENDOR_PRIVATE_6 : case RSVP_CLASS_VENDOR_PRIVATE_7 : case RSVP_CLASS_VENDOR_PRIVATE_8 : case RSVP_CLASS_VENDOR_PRIVATE_9 : case RSVP_CLASS_VENDOR_PRIVATE_10 : case RSVP_CLASS_VENDOR_PRIVATE_11 : case RSVP_CLASS_VENDOR_PRIVATE_12 : return RSVPF_PRIVATE_OBJ ;\n default : return RSVPF_UNKNOWN_OBJ ;\n }\n }", "idx": 759}
{"hash": 3599206110384554647, "project": "debian", "size": 97, "label": 0, "functionSource": "int i2d_ ## name ( type * a , unsigned char * * out ) ;\n DECLARE_ASN1_ITEM ( itname ) # define DECLARE_ASN1_ENCODE_FUNCTIONS_const ( type , name ) type * d2i_ ## name ( type * * a , const unsigned char * * in , long len ) ;\n int i2d_ ## name ( const type * a , unsigned char * * out ) ;\n DECLARE_ASN1_ITEM ( name ) # define DECLARE_ASN1_NDEF_FUNCTION ( name ) int i2d_ ## name ## _NDEF ( name * a , unsigned char * * out ) ;\n # define DECLARE_ASN1_FUNCTIONS_const ( name ) DECLARE_ASN1_ALLOC_FUNCTIONS ( name ) DECLARE_ASN1_ENCODE_FUNCTIONS_const ( name , name ) # define DECLARE_ASN1_ALLOC_FUNCTIONS_name ( type , name ) type * name ## _new ( void ) ;\n void name ## _free ( type * a ) ;\n # define DECLARE_ASN1_PRINT_FUNCTION ( stname ) DECLARE_ASN1_PRINT_FUNCTION_fname ( stname , stname ) # define DECLARE_ASN1_PRINT_FUNCTION_fname ( stname , fname ) int fname ## _print_ctx ( BIO * out , stname * x , int indent , const ASN1_PCTX * pctx ) ;\n # define D2I_OF ( type ) type * ( * ) ( type * * , const unsigned char * * , long ) # define I2D_OF ( type ) int ( * ) ( type * , unsigned char * * ) # define I2D_OF_const ( type ) int ( * ) ( const type * , unsigned char * * ) # define CHECKED_D2I_OF ( type , d2i ) ( ( d2i_of_void * ) ( 1 ? d2i : ( ( D2I_OF ( type ) ) 0 ) ) ) # define CHECKED_I2D_OF ( type , i2d ) ( ( i2d_of_void * ) ( 1 ? i2d : ( ( I2D_OF ( type ) ) 0 ) ) ) # define CHECKED_NEW_OF ( type , xnew ) ( ( void * ( * ) ( void ) ) ( 1 ? xnew : ( ( type * ( * ) ( void ) ) 0 ) ) ) # define CHECKED_PTR_OF ( type , p ) ( ( void * ) ( 1 ? p : ( type * ) 0 ) ) # define CHECKED_PPTR_OF ( type , p ) ( ( void * * ) ( 1 ? p : ( type * * ) 0 ) ) # define TYPEDEF_D2I_OF ( type ) typedef type * d2i_of_ ## type ( type * * , const unsigned char * * , long ) # define TYPEDEF_I2D_OF ( type ) typedef int i2d_of_ ## type ( type * , unsigned char * * ) # define TYPEDEF_D2I2D_OF ( type ) TYPEDEF_D2I_OF ( type ) ;\n TYPEDEF_I2D_OF ( type ) TYPEDEF_D2I2D_OF ( void ) ;\n # ifndef OPENSSL_EXPORT_VAR_AS_FUNCTION typedef const ASN1_ITEM ASN1_ITEM_EXP ;\n # define ASN1_ITEM_ptr ( iptr ) ( iptr ) # define ASN1_ITEM_ref ( iptr ) ( & ( iptr ## _it ) ) # define ASN1_ITEM_rptr ( ref ) ( & ( ref ## _it ) ) # define DECLARE_ASN1_ITEM ( name ) OPENSSL_EXTERN const ASN1_ITEM name ## _it ;\n # else typedef const ASN1_ITEM * ASN1_ITEM_EXP ( void ) ;\n # define ASN1_ITEM_ptr ( iptr ) ( iptr ( ) ) # define ASN1_ITEM_ref ( iptr ) ( iptr ## _it ) # define ASN1_ITEM_rptr ( ref ) ( ref ## _it ( ) ) # define DECLARE_ASN1_ITEM ( name ) const ASN1_ITEM * name ## _it ( void ) ;\n # endif # define ASN1_STRFLGS_ESC_2253 1 # define ASN1_STRFLGS_ESC_CTRL 2 # define ASN1_STRFLGS_ESC_MSB 4 # define ASN1_STRFLGS_ESC_QUOTE 8 # define CHARTYPE_PRINTABLESTRING 0x10 # define CHARTYPE_FIRST_ESC_2253 0x20 # define CHARTYPE_LAST_ESC_2253 0x40 # define ASN1_STRFLGS_UTF8_CONVERT 0x10 # define ASN1_STRFLGS_IGNORE_TYPE 0x20 # define ASN1_STRFLGS_SHOW_TYPE 0x40 # define ASN1_STRFLGS_DUMP_ALL 0x80 # define ASN1_STRFLGS_DUMP_UNKNOWN 0x100 # define ASN1_STRFLGS_DUMP_DER 0x200 # define ASN1_STRFLGS_ESC_2254 0x400 # define ASN1_STRFLGS_RFC2253 ( ASN1_STRFLGS_ESC_2253 | ASN1_STRFLGS_ESC_CTRL | ASN1_STRFLGS_ESC_MSB | ASN1_STRFLGS_UTF8_CONVERT | ASN1_STRFLGS_DUMP_UNKNOWN | ASN1_STRFLGS_DUMP_DER ) DEFINE_STACK_OF ( ASN1_INTEGER ) DEFINE_STACK_OF ( ASN1_GENERALSTRING ) DEFINE_STACK_OF ( ASN1_UTF8STRING ) typedef struct asn1_type_st {\n int type ;\n union {\n char * ptr ;\n ASN1_BOOLEAN boolean ;\n ASN1_STRING * asn1_string ;\n ASN1_OBJECT * object ;\n ASN1_INTEGER * integer ;\n ASN1_ENUMERATED * enumerated ;\n ASN1_BIT_STRING * bit_string ;\n ASN1_OCTET_STRING * octet_string ;\n ASN1_PRINTABLESTRING * printablestring ;\n ASN1_T61STRING * t61string ;\n ASN1_IA5STRING * ia5string ;\n ASN1_GENERALSTRING * generalstring ;\n ASN1_BMPSTRING * bmpstring ;\n ASN1_UNIVERSALSTRING * universalstring ;\n ASN1_UTCTIME * utctime ;\n ASN1_GENERALIZEDTIME * generalizedtime ;\n ASN1_VISIBLESTRING * visiblestring ;\n ASN1_UTF8STRING * utf8string ;\n ASN1_STRING * set ;\n ASN1_STRING * sequence ;\n ASN1_VALUE * asn1_value ;\n }\n value ;\n }\n ASN1_TYPE ;\n DEFINE_STACK_OF ( ASN1_TYPE ) typedef STACK_OF ( ASN1_TYPE ) ASN1_SEQUENCE_ANY ;\n DECLARE_ASN1_ENCODE_FUNCTIONS_const ( ASN1_SEQUENCE_ANY , ASN1_SEQUENCE_ANY ) DECLARE_ASN1_ENCODE_FUNCTIONS_const ( ASN1_SEQUENCE_ANY , ASN1_SET_ANY ) typedef struct BIT_STRING_BITNAME_st {\n int bitnum ;\n const char * lname ;\n const char * sname ;\n }\n BIT_STRING_BITNAME ;\n # define B_ASN1_TIME B_ASN1_UTCTIME | B_ASN1_GENERALIZEDTIME # define B_ASN1_PRINTABLE B_ASN1_NUMERICSTRING | B_ASN1_PRINTABLESTRING | B_ASN1_T61STRING | B_ASN1_IA5STRING | B_ASN1_BIT_STRING | B_ASN1_UNIVERSALSTRING | B_ASN1_BMPSTRING | B_ASN1_UTF8STRING | B_ASN1_SEQUENCE | B_ASN1_UNKNOWN # define B_ASN1_DIRECTORYSTRING B_ASN1_PRINTABLESTRING | B_ASN1_TELETEXSTRING | B_ASN1_BMPSTRING | B_ASN1_UNIVERSALSTRING | B_ASN1_UTF8STRING # define B_ASN1_DISPLAYTEXT B_ASN1_IA5STRING | B_ASN1_VISIBLESTRING | B_ASN1_BMPSTRING | B_ASN1_UTF8STRING DECLARE_ASN1_FUNCTIONS_fname ( ASN1_TYPE , ASN1_ANY , ASN1_TYPE ) int ASN1_TYPE_get ( const ASN1_TYPE * a ) ;\n void ASN1_TYPE_set ( ASN1_TYPE * a , int type , void * value ) ;\n int ASN1_TYPE_set1 ( ASN1_TYPE * a , int type , const void * value ) ;\n int ASN1_TYPE_cmp ( const ASN1_TYPE * a , const ASN1_TYPE * b ) ;\n ASN1_TYPE * ASN1_TYPE_pack_sequence ( const ASN1_ITEM * it , void * s , ASN1_TYPE * * t ) ;\n void * ASN1_TYPE_unpack_sequence ( const ASN1_ITEM * it , const ASN1_TYPE * t ) ;\n ASN1_OBJECT * ASN1_OBJECT_new ( void ) ;\n void ASN1_OBJECT_free ( ASN1_OBJECT * a ) ;\n int i2d_ASN1_OBJECT ( const ASN1_OBJECT * a , unsigned char * * pp ) ;\n ASN1_OBJECT * d2i_ASN1_OBJECT ( ASN1_OBJECT * * a , const unsigned char * * pp , long length ) ;\n DECLARE_ASN1_ITEM ( ASN1_OBJECT ) DEFINE_STACK_OF ( ASN1_OBJECT ) ASN1_STRING * ASN1_STRING_new ( void ) ;\n void ASN1_STRING_free ( ASN1_STRING * a ) ;\n void ASN1_STRING_clear_free ( ASN1_STRING * a ) ;\n int ASN1_STRING_copy ( ASN1_STRING * dst , const ASN1_STRING * str ) ;\n ASN1_STRING * ASN1_STRING_dup ( const ASN1_STRING * a ) ;\n ASN1_STRING * ASN1_STRING_type_new ( int type ) ;\n int ASN1_STRING_cmp ( const ASN1_STRING * a , const ASN1_STRING * b ) ;\n int ASN1_STRING_set ( ASN1_STRING * str , const void * data , int len ) ;\n void ASN1_STRING_set0 ( ASN1_STRING * str , void * data , int len ) ;\n int ASN1_STRING_length ( const ASN1_STRING * x ) ;\n void ASN1_STRING_length_set ( ASN1_STRING * x , int n ) ;\n int ASN1_STRING_type ( const ASN1_STRING * x ) ;\n DEPRECATEDIN_1_1_0 ( unsigned char * ASN1_STRING_data ( ASN1_STRING * x ) ) const unsigned char * ASN1_STRING_get0_data ( const ASN1_STRING * x ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_BIT_STRING ) int ASN1_BIT_STRING_set ( ASN1_BIT_STRING * a , unsigned char * d , int length ) ;\n int ASN1_BIT_STRING_set_bit ( ASN1_BIT_STRING * a , int n , int value ) ;\n int ASN1_BIT_STRING_get_bit ( const ASN1_BIT_STRING * a , int n ) ;\n int ASN1_BIT_STRING_check ( const ASN1_BIT_STRING * a , const unsigned char * flags , int flags_len ) ;\n int ASN1_BIT_STRING_name_print ( BIO * out , ASN1_BIT_STRING * bs , BIT_STRING_BITNAME * tbl , int indent ) ;\n int ASN1_BIT_STRING_num_asc ( const char * name , BIT_STRING_BITNAME * tbl ) ;\n int ASN1_BIT_STRING_set_asc ( ASN1_BIT_STRING * bs , const char * name , int value , BIT_STRING_BITNAME * tbl ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_INTEGER ) ASN1_INTEGER * d2i_ASN1_UINTEGER ( ASN1_INTEGER * * a , const unsigned char * * pp , long length ) ;\n ASN1_INTEGER * ASN1_INTEGER_dup ( const ASN1_INTEGER * x ) ;\n int ASN1_INTEGER_cmp ( const ASN1_INTEGER * x , const ASN1_INTEGER * y ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_ENUMERATED ) int ASN1_UTCTIME_check ( const ASN1_UTCTIME * a ) ;\n ASN1_UTCTIME * ASN1_UTCTIME_set ( ASN1_UTCTIME * s , time_t t ) ;\n ASN1_UTCTIME * ASN1_UTCTIME_adj ( ASN1_UTCTIME * s , time_t t , int offset_day , long offset_sec ) ;\n int ASN1_UTCTIME_set_string ( ASN1_UTCTIME * s , const char * str ) ;\n int ASN1_UTCTIME_cmp_time_t ( const ASN1_UTCTIME * s , time_t t ) ;\n int ASN1_GENERALIZEDTIME_check ( const ASN1_GENERALIZEDTIME * a ) ;\n ASN1_GENERALIZEDTIME * ASN1_GENERALIZEDTIME_set ( ASN1_GENERALIZEDTIME * s , time_t t ) ;\n ASN1_GENERALIZEDTIME * ASN1_GENERALIZEDTIME_adj ( ASN1_GENERALIZEDTIME * s , time_t t , int offset_day , long offset_sec ) ;\n int ASN1_GENERALIZEDTIME_set_string ( ASN1_GENERALIZEDTIME * s , const char * str ) ;\n int ASN1_TIME_diff ( int * pday , int * psec , const ASN1_TIME * from , const ASN1_TIME * to ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_OCTET_STRING ) ASN1_OCTET_STRING * ASN1_OCTET_STRING_dup ( const ASN1_OCTET_STRING * a ) ;\n int ASN1_OCTET_STRING_cmp ( const ASN1_OCTET_STRING * a , const ASN1_OCTET_STRING * b ) ;\n int ASN1_OCTET_STRING_set ( ASN1_OCTET_STRING * str , const unsigned char * data , int len ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_VISIBLESTRING ) DECLARE_ASN1_FUNCTIONS ( ASN1_UNIVERSALSTRING ) DECLARE_ASN1_FUNCTIONS ( ASN1_UTF8STRING ) DECLARE_ASN1_FUNCTIONS ( ASN1_NULL ) DECLARE_ASN1_FUNCTIONS ( ASN1_BMPSTRING ) int UTF8_getc ( const unsigned char * str , int len , unsigned long * val ) ;\n int UTF8_putc ( unsigned char * str , int len , unsigned long value ) ;\n DECLARE_ASN1_FUNCTIONS_name ( ASN1_STRING , ASN1_PRINTABLE ) DECLARE_ASN1_FUNCTIONS_name ( ASN1_STRING , DIRECTORYSTRING ) DECLARE_ASN1_FUNCTIONS_name ( ASN1_STRING , DISPLAYTEXT )", "idx": 760}
{"hash": 5400542917484463750, "project": "chrome", "size": 15, "label": 1, "functionSource": "static struct FrameData * fd_create ( void * buf , size_t size , vpx_codec_frame_flags_t flags ) {\n struct FrameData * const frame_data = ( struct FrameData * ) vpx_malloc ( sizeof ( * frame_data ) ) ;\n if ( frame_data == NULL ) {\n return NULL ;\n }\n frame_data -> buf = vpx_malloc ( size ) ;\n if ( frame_data -> buf == NULL ) {\n vpx_free ( frame_data ) ;\n return NULL ;\n }\n vpx_memcpy ( frame_data -> buf , buf , size ) ;\n frame_data -> size = size ;\n frame_data -> flags = flags ;\n return frame_data ;\n }", "idx": 761}
{"hash": 6323824267898511453, "project": "debian", "size": 3, "label": 0, "functionSource": "static void fz_md5_icc ( fz_context * ctx , fz_iccprofile * profile ) {\n if ( profile ) fz_md5_buffer ( ctx , profile -> buffer , profile -> md5 ) ;\n }", "idx": 762}
{"hash": -192019917869801237, "project": "debian", "size": 24, "label": 0, "functionSource": "static gint protobuf_verify_wiretype ( protobuf_desc_t * pb , protobuf_tag_t * tag , packet_info * pinfo , proto_tree * tree , guint8 expected_wire_type ) {\n gint len ;\n gint64 len_prefix ;\n proto_item * ti = NULL ;\n if ( expected_wire_type == tag -> wire_type ) {\n if ( expected_wire_type == PROTOBUF_WIRETYPE_LENGTHDELIMITED ) {\n len_prefix = get_varint64 ( pb -> tvb , pb -> offset , pb -> bytes_left , & len ) ;\n if ( len_prefix < 0 || len_prefix > G_MAXINT ) {\n ti = proto_tree_add_item ( tree , hf_steam_ihs_discovery_unknown_data , pb -> tvb , pb -> offset + len , pb -> bytes_left - len , ENC_NA ) ;\n expert_add_info_format ( pinfo , ti , & ei_steam_ihs_discovery_invalid_length , \"Length-delimited field %\" G_GUINT64_FORMAT \" has length prefix %\" G_GINT64_FORMAT \" outside valid range (0 <= x <= G_MAXINT).\" , tag -> field_number , len_prefix ) ;\n return pb -> bytes_left ;\n }\n else if ( ( ( gint ) len_prefix ) > ( pb -> bytes_left - len ) ) {\n ti = proto_tree_add_item ( tree , hf_steam_ihs_discovery_unknown_data , pb -> tvb , pb -> offset + len , pb -> bytes_left - len , ENC_NA ) ;\n expert_add_info_format ( pinfo , ti , & ei_steam_ihs_discovery_invalid_length , \"Length-delimited field %\" G_GUINT64_FORMAT \" has length prefix %\" G_GINT64_FORMAT \", but buffer is only %d bytes long.\" , tag -> field_number , len_prefix , ( pb -> bytes_left - len ) ) ;\n return pb -> bytes_left ;\n }\n }\n return 0 ;\n }\n len = protobuf_dissect_unknown_field ( pb , tag , pinfo , tree , & ti ) ;\n expert_add_info_format ( pinfo , ti , & ei_steam_ihs_discovery_invalid_wiretype , \"Expected wiretype %d (%s) for field %\" G_GUINT64_FORMAT \", but got %d (%s) instead.\" , expected_wire_type , protobuf_get_wiretype_name ( expected_wire_type ) , tag -> field_number , tag -> wire_type , protobuf_get_wiretype_name ( tag -> wire_type ) ) ;\n return len ;\n }", "idx": 763}
{"hash": -398565394354770780, "project": "debian", "size": 18, "label": 0, "functionSource": "static void ohci_stop_endpoints ( OHCIState * ohci ) {\n USBDevice * dev ;\n int i , j ;\n for ( i = 0 ;\n i < ohci -> num_ports ;\n i ++ ) {\n dev = ohci -> rhport [ i ] . port . dev ;\n if ( dev && dev -> attached ) {\n usb_device_ep_stopped ( dev , & dev -> ep_ctl ) ;\n for ( j = 0 ;\n j < USB_MAX_ENDPOINTS ;\n j ++ ) {\n usb_device_ep_stopped ( dev , & dev -> ep_in [ j ] ) ;\n usb_device_ep_stopped ( dev , & dev -> ep_out [ j ] ) ;\n }\n }\n }\n }", "idx": 764}
{"hash": 1676654288894940649, "project": "debian", "size": 30, "label": 0, "functionSource": "void kadmin_delstring ( int argc , char * argv [ ] ) {\n kadm5_ret_t retval ;\n char * pname , * canon = NULL , * key ;\n krb5_principal princ = NULL ;\n if ( argc != 3 ) {\n fprintf ( stderr , _ ( \"usage: del_string principal key\\n\" ) ) ;\n return ;\n }\n pname = argv [ 1 ] ;\n key = argv [ 2 ] ;\n retval = kadmin_parse_name ( pname , & princ ) ;\n if ( retval ) {\n com_err ( \"delstring\" , retval , _ ( \"while parsing principal\" ) ) ;\n return ;\n }\n retval = krb5_unparse_name ( context , princ , & canon ) ;\n if ( retval ) {\n com_err ( \"del_string\" , retval , _ ( \"while canonicalizing principal\" ) ) ;\n goto cleanup ;\n }\n retval = kadm5_set_string ( handle , princ , key , NULL ) ;\n if ( retval ) {\n com_err ( \"del_string\" , retval , _ ( \"while deleting attribute from principal \\\"%s\\\"\" ) , canon ) ;\n goto cleanup ;\n }\n printf ( _ ( \"Attribute removed from principal \\\"%s\\\".\\n\" ) , canon ) ;\n cleanup : krb5_free_principal ( context , princ ) ;\n free ( canon ) ;\n return ;\n }", "idx": 765}
{"hash": -6856626433814917486, "project": "debian", "size": 40, "label": 0, "functionSource": "void proto_register_aptx ( void ) {\n static hf_register_info hf [ ] = {\n {\n & hf_aptx_data , {\n \"Data\" , \"aptx.data\" , FT_BYTES , BASE_NONE , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_aptx_cumulative_frame_duration , {\n \"Cumulative Frame Duration\" , \"aptx.cumulative_frame_duration\" , FT_DOUBLE , BASE_NONE | BASE_UNIT_STRING , & units_milliseconds , 0x00 , NULL , HFILL }\n }\n , {\n & hf_aptx_delta_time , {\n \"Delta time\" , \"aptx.delta_time\" , FT_DOUBLE , BASE_NONE | BASE_UNIT_STRING , & units_milliseconds , 0x00 , NULL , HFILL }\n }\n , {\n & hf_aptx_avrcp_song_position , {\n \"AVRCP Song Position\" , \"aptx.avrcp_song_position\" , FT_DOUBLE , BASE_NONE | BASE_UNIT_STRING , & units_milliseconds , 0x00 , NULL , HFILL }\n }\n , {\n & hf_aptx_delta_time_from_the_beginning , {\n \"Delta time from the beginning\" , \"aptx.delta_time_from_the_beginning\" , FT_DOUBLE , BASE_NONE | BASE_UNIT_STRING , & units_milliseconds , 0x00 , NULL , HFILL }\n }\n , {\n & hf_aptx_cumulative_duration , {\n \"Cumulative Music Duration\" , \"aptx.cumulative_music_duration\" , FT_DOUBLE , BASE_NONE | BASE_UNIT_STRING , & units_milliseconds , 0x00 , NULL , HFILL }\n }\n , {\n & hf_aptx_diff , {\n \"Diff\" , \"aptx.diff\" , FT_DOUBLE , BASE_NONE | BASE_UNIT_STRING , & units_milliseconds , 0x00 , NULL , HFILL }\n }\n , }\n ;\n static gint * ett [ ] = {\n & ett_aptx }\n ;\n proto_aptx = proto_register_protocol ( \"APT-X Codec\" , \"APT-X\" , \"aptx\" ) ;\n proto_register_field_array ( proto_aptx , hf , array_length ( hf ) ) ;\n proto_register_subtree_array ( ett , array_length ( ett ) ) ;\n aptx_handle = register_dissector ( \"aptx\" , dissect_aptx , proto_aptx ) ;\n }", "idx": 766}
{"hash": 8461782184979846246, "project": "chrome", "size": 10, "label": 0, "functionSource": "TEST_F ( ProtocolHandlerRegistryTest , TestReplaceNonDefaultHandler ) {\n ProtocolHandler ph1 = CreateProtocolHandler ( \"mailto\" , GURL ( \"http://test.com/%s\" ) ) ;\n ProtocolHandler ph2 = CreateProtocolHandler ( \"mailto\" , GURL ( \"http://test.com/updated-url/%s\" ) ) ;\n ProtocolHandler ph3 = CreateProtocolHandler ( \"mailto\" , GURL ( \"http://else.com/%s\" ) ) ;\n registry ( ) -> OnAcceptRegisterProtocolHandler ( ph1 ) ;\n registry ( ) -> OnAcceptRegisterProtocolHandler ( ph3 ) ;\n ASSERT_TRUE ( registry ( ) -> AttemptReplace ( ph2 ) ) ;\n const ProtocolHandler & handler ( registry ( ) -> GetHandlerFor ( \"mailto\" ) ) ;\n ASSERT_EQ ( handler . url ( ) , ph3 . url ( ) ) ;\n }", "idx": 767}
{"hash": 2895622461494525400, "project": "debian", "size": 28, "label": 0, "functionSource": "static void test_bug9992 ( ) {\n MYSQL * mysql1 ;\n MYSQL_RES * res ;\n int rc ;\n myheader ( \"test_bug9992\" ) ;\n if ( ! opt_silent ) printf ( \"Establishing a connection with option CLIENT_MULTI_STATEMENTS..\\n\" ) ;\n mysql1 = mysql_client_init ( NULL ) ;\n if ( ! mysql_real_connect ( mysql1 , opt_host , opt_user , opt_password , opt_db ? opt_db : \"test\" , opt_port , opt_unix_socket , CLIENT_MULTI_STATEMENTS ) ) {\n fprintf ( stderr , \"Failed to connect to the database\\n\" ) ;\n DIE_UNLESS ( 0 ) ;\n }\n rc = mysql_query ( mysql1 , \"SHOW TABLES;\n SHOW DATABASE;\n SELECT 1;\n\" ) ;\n if ( rc ) {\n fprintf ( stderr , \"[%d] %s\\n\" , mysql_errno ( mysql1 ) , mysql_error ( mysql1 ) ) ;\n DIE_UNLESS ( 0 ) ;\n }\n if ( ! opt_silent ) printf ( \"Testing mysql_store_result/mysql_next_result..\\n\" ) ;\n res = mysql_store_result ( mysql1 ) ;\n DIE_UNLESS ( res ) ;\n mysql_free_result ( res ) ;\n rc = mysql_next_result ( mysql1 ) ;\n DIE_UNLESS ( rc == 1 ) ;\n if ( ! opt_silent ) fprintf ( stdout , \"Got error, as expected:\\n [%d] %s\\n\" , mysql_errno ( mysql1 ) , mysql_error ( mysql1 ) ) ;\n mysql_close ( mysql1 ) ;\n }", "idx": 768}
{"hash": -3135212895432241239, "project": "debian", "size": 11, "label": 0, "functionSource": "static void nb_resync_indicator ( tvbuff_t * tvb , int offset , proto_tree * tree , const char * cmd_str ) {\n guint16 resync_indicator = tvb_get_letohs ( tvb , offset + NB_DATA2 ) ;\n switch ( resync_indicator ) {\n case 0x0000 : proto_tree_add_uint_format_value ( tree , hf_netb_resync_indicator , tvb , offset + NB_DATA2 , 2 , resync_indicator , \"No re-sync\" ) ;\n break ;\n case 0x0001 : proto_tree_add_uint_format_value ( tree , hf_netb_resync_indicator , tvb , offset + NB_DATA2 , 2 , resync_indicator , \"First '%s' following 'Receive Outstanding'\" , cmd_str ) ;\n break ;\n default : proto_tree_add_item ( tree , hf_netb_resync_indicator , tvb , offset + NB_DATA2 , 2 , ENC_LITTLE_ENDIAN ) ;\n break ;\n }\n }", "idx": 769}
{"hash": -6126432314261451839, "project": "debian", "size": 9, "label": 0, "functionSource": "void gx_device_init_on_stack ( gx_device * dev , const gx_device * proto , gs_memory_t * mem ) {\n memcpy ( dev , proto , proto -> params_size ) ;\n dev -> memory = mem ;\n dev -> retained = 0 ;\n dev -> pad = proto -> pad ;\n dev -> log2_align_mod = proto -> log2_align_mod ;\n dev -> is_planar = proto -> is_planar ;\n rc_init ( dev , NULL , 0 ) ;\n }", "idx": 770}
{"hash": 6968788423709606113, "project": "debian", "size": 272, "label": 1, "functionSource": "static Image * ReadGIFImage ( const ImageInfo * image_info , ExceptionInfo * exception ) {\n # define BitSet ( byte , bit ) ( ( ( byte ) & ( bit ) ) == ( bit ) ) # define LSBFirstOrder ( x , y ) ( ( ( y ) << 8 ) | ( x ) ) Image * image , * meta_image ;\n int number_extensionss = 0 ;\n MagickBooleanType status ;\n RectangleInfo page ;\n register ssize_t i ;\n register unsigned char * p ;\n size_t delay , dispose , duration , global_colors , image_count , iterations , one ;\n ssize_t count , opacity ;\n unsigned char background , c , flag , * global_colormap , header [ MaxTextExtent ] , magick [ 12 ] ;\n assert ( image_info != ( const ImageInfo * ) NULL ) ;\n assert ( image_info -> signature == MagickSignature ) ;\n if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ;\n assert ( exception != ( ExceptionInfo * ) NULL ) ;\n assert ( exception -> signature == MagickSignature ) ;\n image = AcquireImage ( image_info ) ;\n status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ;\n if ( status == MagickFalse ) {\n image = DestroyImageList ( image ) ;\n return ( ( Image * ) NULL ) ;\n }\n count = ReadBlob ( image , 6 , magick ) ;\n if ( ( count != 6 ) || ( ( LocaleNCompare ( ( char * ) magick , \"GIF87\" , 5 ) != 0 ) && ( LocaleNCompare ( ( char * ) magick , \"GIF89\" , 5 ) != 0 ) ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ;\n page . width = ReadBlobLSBShort ( image ) ;\n page . height = ReadBlobLSBShort ( image ) ;\n flag = ( unsigned char ) ReadBlobByte ( image ) ;\n background = ( unsigned char ) ReadBlobByte ( image ) ;\n c = ( unsigned char ) ReadBlobByte ( image ) ;\n one = 1 ;\n global_colors = one << ( ( ( size_t ) flag & 0x07 ) + 1 ) ;\n global_colormap = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) MagickMax ( global_colors , 256 ) , 3UL * sizeof ( * global_colormap ) ) ;\n if ( global_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ;\n if ( BitSet ( ( int ) flag , 0x80 ) != 0 ) {\n count = ReadBlob ( image , ( size_t ) ( 3 * global_colors ) , global_colormap ) ;\n if ( count != ( ssize_t ) ( 3 * global_colors ) ) {\n global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ;\n ThrowReaderException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ;\n }\n }\n delay = 0 ;\n dispose = 0 ;\n duration = 0 ;\n iterations = 1 ;\n opacity = ( - 1 ) ;\n image_count = 0 ;\n meta_image = AcquireImage ( image_info ) ;\n for ( ;\n ;\n ) {\n count = ReadBlob ( image , 1 , & c ) ;\n if ( count != 1 ) break ;\n if ( c == ( unsigned char ) ';\n' ) break ;\n if ( c == ( unsigned char ) '!' ) {\n count = ReadBlob ( image , 1 , & c ) ;\n if ( count != 1 ) {\n global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ;\n meta_image = DestroyImage ( meta_image ) ;\n ThrowReaderException ( CorruptImageError , \"UnableToReadExtensionBlock\" ) ;\n }\n switch ( c ) {\n case 0xf9 : {\n while ( ReadBlobBlock ( image , header ) != 0 ) ;\n dispose = ( size_t ) ( header [ 0 ] >> 2 ) ;\n delay = ( size_t ) ( ( header [ 2 ] << 8 ) | header [ 1 ] ) ;\n if ( ( ssize_t ) ( header [ 0 ] & 0x01 ) == 0x01 ) opacity = ( ssize_t ) header [ 3 ] ;\n break ;\n }\n case 0xfe : {\n char * comments ;\n size_t length ;\n comments = AcquireString ( ( char * ) NULL ) ;\n for ( length = 0 ;\n ;\n length += count ) {\n count = ReadBlobBlock ( image , header ) ;\n if ( count == 0 ) break ;\n header [ count ] = '\\0' ;\n ( void ) ConcatenateString ( & comments , ( const char * ) header ) ;\n }\n ( void ) SetImageProperty ( meta_image , \"comment\" , comments ) ;\n comments = DestroyString ( comments ) ;\n break ;\n }\n case 0xff : {\n MagickBooleanType loop ;\n loop = MagickFalse ;\n if ( ReadBlobBlock ( image , header ) != 0 ) loop = LocaleNCompare ( ( char * ) header , \"NETSCAPE2.0\" , 11 ) == 0 ? MagickTrue : MagickFalse ;\n if ( loop != MagickFalse ) {\n while ( ReadBlobBlock ( image , header ) != 0 ) iterations = ( size_t ) ( ( header [ 2 ] << 8 ) | header [ 1 ] ) ;\n break ;\n }\n else {\n char name [ MaxTextExtent ] ;\n int block_length , info_length , reserved_length ;\n MagickBooleanType i8bim , icc , iptc , magick ;\n StringInfo * profile ;\n unsigned char * info ;\n icc = LocaleNCompare ( ( char * ) header , \"ICCRGBG1012\" , 11 ) == 0 ? MagickTrue : MagickFalse ;\n magick = LocaleNCompare ( ( char * ) header , \"ImageMagick\" , 11 ) == 0 ? MagickTrue : MagickFalse ;\n i8bim = LocaleNCompare ( ( char * ) header , \"MGK8BIM0000\" , 11 ) == 0 ? MagickTrue : MagickFalse ;\n iptc = LocaleNCompare ( ( char * ) header , \"MGKIPTC0000\" , 11 ) == 0 ? MagickTrue : MagickFalse ;\n number_extensionss ++ ;\n ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \" Reading GIF application extension\" ) ;\n info = ( unsigned char * ) AcquireQuantumMemory ( 255UL , sizeof ( * info ) ) ;\n if ( info == ( unsigned char * ) NULL ) {\n meta_image = DestroyImage ( meta_image ) ;\n ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ;\n }\n reserved_length = 255 ;\n for ( info_length = 0 ;\n ;\n ) {\n block_length = ( int ) ReadBlobBlock ( image , & info [ info_length ] ) ;\n if ( block_length == 0 ) break ;\n info_length += block_length ;\n if ( info_length > ( reserved_length - 255 ) ) {\n reserved_length += 4096 ;\n info = ( unsigned char * ) ResizeQuantumMemory ( info , ( size_t ) reserved_length , sizeof ( * info ) ) ;\n if ( info == ( unsigned char * ) NULL ) {\n meta_image = DestroyImage ( meta_image ) ;\n ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ;\n }\n }\n }\n profile = BlobToStringInfo ( info , ( size_t ) info_length ) ;\n if ( profile == ( StringInfo * ) NULL ) {\n meta_image = DestroyImage ( meta_image ) ;\n ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ;\n }\n if ( i8bim != MagickFalse ) ( void ) CopyMagickString ( name , \"8bim\" , sizeof ( name ) ) ;\n else if ( icc != MagickFalse ) ( void ) CopyMagickString ( name , \"icc\" , sizeof ( name ) ) ;\n else if ( iptc != MagickFalse ) ( void ) CopyMagickString ( name , \"iptc\" , sizeof ( name ) ) ;\n else if ( magick != MagickFalse ) {\n ( void ) CopyMagickString ( name , \"magick\" , sizeof ( name ) ) ;\n meta_image -> gamma = StringToDouble ( ( char * ) info + 6 , ( char * * ) NULL ) ;\n }\n else ( void ) FormatLocaleString ( name , sizeof ( name ) , \"gif:%.11s\" , header ) ;\n info = ( unsigned char * ) RelinquishMagickMemory ( info ) ;\n if ( magick == MagickFalse ) ( void ) SetImageProfile ( meta_image , name , profile ) ;\n profile = DestroyStringInfo ( profile ) ;\n ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \" profile name=%s\" , name ) ;\n }\n break ;\n }\n default : {\n while ( ReadBlobBlock ( image , header ) != 0 ) ;\n break ;\n }\n }\n }\n if ( c != ( unsigned char ) ',' ) continue ;\n if ( image_count != 0 ) {\n AcquireNextImage ( image_info , image ) ;\n if ( GetNextImageInList ( image ) == ( Image * ) NULL ) {\n image = DestroyImageList ( image ) ;\n global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ;\n return ( ( Image * ) NULL ) ;\n }\n image = SyncNextImageInList ( image ) ;\n }\n image_count ++ ;\n meta_image -> scene = image -> scene ;\n ( void ) CloneImageProperties ( image , meta_image ) ;\n DestroyImageProperties ( meta_image ) ;\n ( void ) CloneImageProfiles ( image , meta_image ) ;\n DestroyImageProfiles ( meta_image ) ;\n image -> storage_class = PseudoClass ;\n image -> compression = LZWCompression ;\n page . x = ( ssize_t ) ReadBlobLSBShort ( image ) ;\n page . y = ( ssize_t ) ReadBlobLSBShort ( image ) ;\n image -> columns = ReadBlobLSBShort ( image ) ;\n image -> rows = ReadBlobLSBShort ( image ) ;\n image -> depth = 8 ;\n flag = ( unsigned char ) ReadBlobByte ( image ) ;\n image -> interlace = BitSet ( ( int ) flag , 0x40 ) != 0 ? GIFInterlace : NoInterlace ;\n image -> colors = BitSet ( ( int ) flag , 0x80 ) == 0 ? global_colors : one << ( ( size_t ) ( flag & 0x07 ) + 1 ) ;\n if ( opacity >= ( ssize_t ) image -> colors ) opacity = ( - 1 ) ;\n image -> page . width = page . width ;\n image -> page . height = page . height ;\n image -> page . y = page . y ;\n image -> page . x = page . x ;\n image -> delay = delay ;\n image -> iterations = iterations ;\n image -> ticks_per_second = 100 ;\n image -> dispose = ( DisposeType ) dispose ;\n image -> matte = opacity >= 0 ? MagickTrue : MagickFalse ;\n delay = 0 ;\n dispose = 0 ;\n if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) {\n global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ;\n meta_image = DestroyImage ( meta_image ) ;\n ThrowReaderException ( CorruptImageError , \"NegativeOrZeroImageSize\" ) ;\n }\n if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) {\n global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ;\n meta_image = DestroyImage ( meta_image ) ;\n ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ;\n }\n if ( BitSet ( ( int ) flag , 0x80 ) == 0 ) {\n p = global_colormap ;\n for ( i = 0 ;\n i < ( ssize_t ) image -> colors ;\n i ++ ) {\n image -> colormap [ i ] . red = ScaleCharToQuantum ( * p ++ ) ;\n image -> colormap [ i ] . green = ScaleCharToQuantum ( * p ++ ) ;\n image -> colormap [ i ] . blue = ScaleCharToQuantum ( * p ++ ) ;\n if ( i == opacity ) {\n image -> colormap [ i ] . opacity = ( Quantum ) TransparentOpacity ;\n image -> transparent_color = image -> colormap [ opacity ] ;\n }\n }\n image -> background_color = image -> colormap [ MagickMin ( ( ssize_t ) background , ( ssize_t ) image -> colors - 1 ) ] ;\n }\n else {\n unsigned char * colormap ;\n colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , 3 * sizeof ( * colormap ) ) ;\n if ( colormap == ( unsigned char * ) NULL ) {\n global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ;\n meta_image = DestroyImage ( meta_image ) ;\n ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ;\n }\n count = ReadBlob ( image , ( 3 * image -> colors ) * sizeof ( * colormap ) , colormap ) ;\n if ( count != ( ssize_t ) ( 3 * image -> colors ) ) {\n global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ;\n colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ;\n meta_image = DestroyImage ( meta_image ) ;\n ThrowReaderException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ;\n }\n p = colormap ;\n for ( i = 0 ;\n i < ( ssize_t ) image -> colors ;\n i ++ ) {\n image -> colormap [ i ] . red = ScaleCharToQuantum ( * p ++ ) ;\n image -> colormap [ i ] . green = ScaleCharToQuantum ( * p ++ ) ;\n image -> colormap [ i ] . blue = ScaleCharToQuantum ( * p ++ ) ;\n if ( i == opacity ) image -> colormap [ i ] . opacity = ( Quantum ) TransparentOpacity ;\n }\n colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ;\n }\n if ( image -> gamma == 1.0 ) {\n for ( i = 0 ;\n i < ( ssize_t ) image -> colors ;\n i ++ ) if ( IsGrayPixel ( image -> colormap + i ) == MagickFalse ) break ;\n ( void ) SetImageColorspace ( image , i == ( ssize_t ) image -> colors ? GRAYColorspace : RGBColorspace ) ;\n }\n if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;\n status = SetImageExtent ( image , image -> columns , image -> rows ) ;\n if ( status == MagickFalse ) {\n InheritException ( exception , & image -> exception ) ;\n return ( DestroyImageList ( image ) ) ;\n }\n if ( image_info -> ping != MagickFalse ) status = PingGIFImage ( image ) ;\n else status = DecodeImage ( image , opacity ) ;\n if ( ( image_info -> ping == MagickFalse ) && ( status == MagickFalse ) ) {\n global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ;\n meta_image = DestroyImage ( meta_image ) ;\n ThrowReaderException ( CorruptImageError , \"CorruptImage\" ) ;\n }\n duration += image -> delay * image -> iterations ;\n if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;\n opacity = ( - 1 ) ;\n status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) image -> scene - 1 , image -> scene ) ;\n if ( status == MagickFalse ) break ;\n }\n image -> duration = duration ;\n meta_image = DestroyImage ( meta_image ) ;\n global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ;\n if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) ThrowReaderException ( CorruptImageError , \"NegativeOrZeroImageSize\" ) ;\n ( void ) CloseBlob ( image ) ;\n return ( GetFirstImageInList ( image ) ) ;\n }", "idx": 771}
{"hash": 3804373597256531021, "project": "debian", "size": 11, "label": 0, "functionSource": "static void set_user_salt ( ACL_USER * acl_user , const char * password , uint password_len ) {\n if ( password_len == SCRAMBLED_PASSWORD_CHAR_LENGTH ) {\n get_salt_from_password ( acl_user -> salt , password ) ;\n acl_user -> salt_len = SCRAMBLE_LENGTH ;\n }\n else if ( password_len == SCRAMBLED_PASSWORD_CHAR_LENGTH_323 ) {\n get_salt_from_password_323 ( ( ulong * ) acl_user -> salt , password ) ;\n acl_user -> salt_len = SCRAMBLE_LENGTH_323 ;\n }\n else acl_user -> salt_len = 0 ;\n }", "idx": 772}
{"hash": -6552851419396579257, "project": "debian", "size": 6, "label": 0, "functionSource": "static int SpoolssGetPrinterDriverDirectory_r ( tvbuff_t * tvb , int offset , packet_info * pinfo , proto_tree * tree , dcerpc_info * di , guint8 * drep ) {\n offset = dissect_spoolss_string_parm ( tvb , offset , pinfo , tree , di , drep , \"Directory\" ) ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , tree , di , drep , hf_needed , NULL ) ;\n offset = dissect_doserror ( tvb , offset , pinfo , tree , di , drep , hf_rc , NULL ) ;\n return offset ;\n }", "idx": 773}
{"hash": -3889154245145551951, "project": "debian", "size": 6, "label": 0, "functionSource": "static char * pool_strdup ( const char * s ) {\n size_t len = strlen ( s ) + 1 ;\n char * r = pool_alloc ( len ) ;\n memcpy ( r , s , len ) ;\n return r ;\n }", "idx": 774}
{"hash": 5045872831385413038, "project": "debian", "size": 10, "label": 0, "functionSource": "static int dissect_btgatt_microbit_pin_io_config ( tvbuff_t * tvb , packet_info * pinfo _U_ , proto_tree * tree , void * data ) {\n btatt_data_t * att_data = ( btatt_data_t * ) data ;\n proto_item * sub_item ;\n proto_tree * sub_tree ;\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) return - 1 ;\n sub_item = proto_tree_add_item ( tree , hf_gatt_microbit_pin_io_config , tvb , 0 , 3 , ENC_LITTLE_ENDIAN ) ;\n sub_tree = proto_item_add_subtree ( sub_item , ett_btgatt_microbit_pin_io_config ) ;\n proto_tree_add_bitmask_list ( sub_tree , tvb , 0 , 3 , hfx_btgatt_microbit_io_pins , ENC_LITTLE_ENDIAN ) ;\n return tvb_captured_length ( tvb ) ;\n }", "idx": 775}
{"hash": 1760449185745615462, "project": "debian", "size": 16, "label": 0, "functionSource": "TSReturnCode TSAIOWrite ( int fd , off_t offset , char * buf , const size_t bufSize , TSCont contp ) {\n sdk_assert ( sdk_sanity_check_iocore_structure ( contp ) == TS_SUCCESS ) ;\n Continuation * pCont = ( Continuation * ) contp ;\n AIOCallback * pAIO = new_AIOCallback ( ) ;\n sdk_assert ( sdk_sanity_check_null_ptr ( ( void * ) pAIO ) == TS_SUCCESS ) ;\n pAIO -> aiocb . aio_fildes = fd ;\n pAIO -> aiocb . aio_offset = offset ;\n pAIO -> aiocb . aio_buf = buf ;\n pAIO -> aiocb . aio_nbytes = bufSize ;\n pAIO -> action = pCont ;\n pAIO -> thread = pCont -> mutex -> thread_holding ;\n if ( ink_aio_write ( pAIO , 1 ) == 1 ) {\n return TS_SUCCESS ;\n }\n return TS_ERROR ;\n }", "idx": 776}
{"hash": -2226094829431805196, "project": "debian", "size": 27, "label": 0, "functionSource": "int jpc_pi_init ( jpc_pi_t * pi ) {\n int compno ;\n int rlvlno ;\n int prcno ;\n jpc_picomp_t * picomp ;\n jpc_pirlvl_t * pirlvl ;\n int * prclyrno ;\n pi -> prgvolfirst = 0 ;\n pi -> valid = 0 ;\n pi -> pktno = - 1 ;\n pi -> pchgno = - 1 ;\n pi -> pchg = 0 ;\n for ( compno = 0 , picomp = pi -> picomps ;\n compno < pi -> numcomps ;\n ++ compno , ++ picomp ) {\n for ( rlvlno = 0 , pirlvl = picomp -> pirlvls ;\n rlvlno < picomp -> numrlvls ;\n ++ rlvlno , ++ pirlvl ) {\n for ( prcno = 0 , prclyrno = pirlvl -> prclyrnos ;\n prcno < pirlvl -> numprcs ;\n ++ prcno , ++ prclyrno ) {\n * prclyrno = 0 ;\n }\n }\n }\n return 0 ;\n }", "idx": 777}
{"hash": 3966033627990943399, "project": "chrome", "size": 59, "label": 0, "functionSource": "static void reorderLine ( UBiDi * pBiDi , UBiDiLevel minLevel , UBiDiLevel maxLevel ) {\n Run * runs , tempRun ;\n UBiDiLevel * levels ;\n int32_t firstRun , endRun , limitRun , runCount ;\n if ( maxLevel <= ( minLevel | 1 ) ) {\n return ;\n }\n ++ minLevel ;\n runs = pBiDi -> runs ;\n levels = pBiDi -> levels ;\n runCount = pBiDi -> runCount ;\n if ( pBiDi -> trailingWSStart < pBiDi -> length ) {\n -- runCount ;\n }\n while ( -- maxLevel >= minLevel ) {\n firstRun = 0 ;\n for ( ;\n ;\n ) {\n while ( firstRun < runCount && levels [ runs [ firstRun ] . logicalStart ] < maxLevel ) {\n ++ firstRun ;\n }\n if ( firstRun >= runCount ) {\n break ;\n }\n for ( limitRun = firstRun ;\n ++ limitRun < runCount && levels [ runs [ limitRun ] . logicalStart ] >= maxLevel ;\n ) {\n }\n endRun = limitRun - 1 ;\n while ( firstRun < endRun ) {\n tempRun = runs [ firstRun ] ;\n runs [ firstRun ] = runs [ endRun ] ;\n runs [ endRun ] = tempRun ;\n ++ firstRun ;\n -- endRun ;\n }\n if ( limitRun == runCount ) {\n break ;\n }\n else {\n firstRun = limitRun + 1 ;\n }\n }\n }\n if ( ! ( minLevel & 1 ) ) {\n firstRun = 0 ;\n if ( pBiDi -> trailingWSStart == pBiDi -> length ) {\n -- runCount ;\n }\n while ( firstRun < runCount ) {\n tempRun = runs [ firstRun ] ;\n runs [ firstRun ] = runs [ runCount ] ;\n runs [ runCount ] = tempRun ;\n ++ firstRun ;\n -- runCount ;\n }\n }\n }", "idx": 778}
{"hash": -2943582541244387919, "project": "chrome", "size": 36, "label": 0, "functionSource": "unsigned int vp9_sub_pixel_avg_variance ## W ## x ## H ## _c ( const uint8_t * src , int src_stride , int xoffset , int yoffset , const uint8_t * dst , int dst_stride , unsigned int * sse , const uint8_t * second_pred ) {\n uint16_t fdata3 [ ( H + 1 ) * W ] ;\n uint8_t temp2 [ H * W ] ;\n DECLARE_ALIGNED_ARRAY ( 16 , uint8_t , temp3 , H * W ) ;\n var_filter_block2d_bil_first_pass ( src , fdata3 , src_stride , 1 , H + 1 , W , BILINEAR_FILTERS_2TAP ( xoffset ) ) ;\n var_filter_block2d_bil_second_pass ( fdata3 , temp2 , W , W , H , W , BILINEAR_FILTERS_2TAP ( yoffset ) ) ;\n vp9_comp_avg_pred ( temp3 , second_pred , W , H , temp2 , W ) ;\n return vp9_variance ## W ## x ## H ## _c ( temp3 , W , dst , dst_stride , sse ) ;\n \\ }\n void vp9_get16x16var_c ( const uint8_t * src_ptr , int source_stride , const uint8_t * ref_ptr , int ref_stride , unsigned int * sse , int * sum ) {\n variance ( src_ptr , source_stride , ref_ptr , ref_stride , 16 , 16 , sse , sum ) ;\n }\n void vp9_get8x8var_c ( const uint8_t * src_ptr , int source_stride , const uint8_t * ref_ptr , int ref_stride , unsigned int * sse , int * sum ) {\n variance ( src_ptr , source_stride , ref_ptr , ref_stride , 8 , 8 , sse , sum ) ;\n }\n unsigned int vp9_mse16x16_c ( const uint8_t * src , int src_stride , const uint8_t * ref , int ref_stride , unsigned int * sse ) {\n int sum ;\n variance ( src , src_stride , ref , ref_stride , 16 , 16 , sse , & sum ) ;\n return * sse ;\n }\n unsigned int vp9_mse16x8_c ( const uint8_t * src , int src_stride , const uint8_t * ref , int ref_stride , unsigned int * sse ) {\n int sum ;\n variance ( src , src_stride , ref , ref_stride , 16 , 8 , sse , & sum ) ;\n return * sse ;\n }\n unsigned int vp9_mse8x16_c ( const uint8_t * src , int src_stride , const uint8_t * ref , int ref_stride , unsigned int * sse ) {\n int sum ;\n variance ( src , src_stride , ref , ref_stride , 8 , 16 , sse , & sum ) ;\n return * sse ;\n }\n unsigned int vp9_mse8x8_c ( const uint8_t * src , int src_stride , const uint8_t * ref , int ref_stride , unsigned int * sse ) {\n int sum ;\n variance ( src , src_stride , ref , ref_stride , 8 , 8 , sse , & sum ) ;\n return * sse ;\n }\n VAR ( 4 , 4 ) SUBPIX_VAR ( 4 , 4 ) SUBPIX_AVG_VAR ( 4 , 4 ) VAR ( 4 , 8 ) SUBPIX_VAR ( 4 , 8 ) SUBPIX_AVG_VAR ( 4 , 8 ) VAR ( 8 , 4 ) SUBPIX_VAR ( 8 , 4 ) SUBPIX_AVG_VAR ( 8 , 4 )", "idx": 779}
{"hash": 2895622461494525400, "project": "debian", "size": 47, "label": 0, "functionSource": "static void test_bug4026 ( ) {\n MYSQL_STMT * stmt ;\n MYSQL_BIND my_bind [ 2 ] ;\n MYSQL_TIME time_in , time_out ;\n MYSQL_TIME datetime_in , datetime_out ;\n const char * stmt_text ;\n int rc ;\n myheader ( \"test_bug4026\" ) ;\n stmt = mysql_stmt_init ( mysql ) ;\n stmt_text = \"SELECT ?, ?\" ;\n rc = mysql_stmt_prepare ( stmt , stmt_text , strlen ( stmt_text ) ) ;\n check_execute ( stmt , rc ) ;\n memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n memset ( & time_in , 0 , sizeof ( time_in ) ) ;\n memset ( & time_out , 0 , sizeof ( time_out ) ) ;\n memset ( & datetime_in , 0 , sizeof ( datetime_in ) ) ;\n memset ( & datetime_out , 0 , sizeof ( datetime_out ) ) ;\n my_bind [ 0 ] . buffer_type = MYSQL_TYPE_TIME ;\n my_bind [ 0 ] . buffer = ( void * ) & time_in ;\n my_bind [ 1 ] . buffer_type = MYSQL_TYPE_DATETIME ;\n my_bind [ 1 ] . buffer = ( void * ) & datetime_in ;\n time_in . hour = 23 ;\n time_in . minute = 59 ;\n time_in . second = 59 ;\n time_in . second_part = 123456 ;\n time_in . time_type = MYSQL_TIMESTAMP_TIME ;\n datetime_in = time_in ;\n datetime_in . year = 2003 ;\n datetime_in . month = 12 ;\n datetime_in . day = 31 ;\n datetime_in . time_type = MYSQL_TIMESTAMP_DATETIME ;\n mysql_stmt_bind_param ( stmt , my_bind ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n my_bind [ 0 ] . buffer = ( void * ) & time_out ;\n my_bind [ 1 ] . buffer = ( void * ) & datetime_out ;\n mysql_stmt_bind_result ( stmt , my_bind ) ;\n rc = mysql_stmt_fetch ( stmt ) ;\n DIE_UNLESS ( rc == 0 ) ;\n if ( ! opt_silent ) {\n printf ( \"%d:%d:%d.%lu\\n\" , time_out . hour , time_out . minute , time_out . second , time_out . second_part ) ;\n printf ( \"%d-%d-%d %d:%d:%d.%lu\\n\" , datetime_out . year , datetime_out . month , datetime_out . day , datetime_out . hour , datetime_out . minute , datetime_out . second , datetime_out . second_part ) ;\n }\n DIE_UNLESS ( memcmp ( & time_in , & time_out , sizeof ( time_in ) ) == 0 ) ;\n DIE_UNLESS ( memcmp ( & datetime_in , & datetime_out , sizeof ( datetime_in ) ) == 0 ) ;\n mysql_stmt_close ( stmt ) ;\n }", "idx": 780}
{"hash": 6323824267898511453, "project": "debian", "size": 3, "label": 0, "functionSource": "int fz_colorspace_device_n_has_cmyk ( fz_context * ctx , const fz_colorspace * cs ) {\n return cs && ( cs -> flags & FZ_CS_HAS_CMYK ) ;\n }", "idx": 781}
{"hash": 1223258652239369123, "project": "debian", "size": 31, "label": 0, "functionSource": "SPL_METHOD ( DirectoryIterator , seek ) {\n spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n zval * retval = NULL ;\n long pos ;\n if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , \"l\" , & pos ) == FAILURE ) {\n return ;\n }\n if ( intern -> u . dir . index > pos ) {\n zend_call_method_with_0_params ( & this_ptr , Z_OBJCE_P ( getThis ( ) ) , & intern -> u . dir . func_rewind , \"rewind\" , & retval ) ;\n if ( retval ) {\n zval_ptr_dtor ( & retval ) ;\n retval = NULL ;\n }\n }\n while ( intern -> u . dir . index < pos ) {\n int valid = 0 ;\n zend_call_method_with_0_params ( & this_ptr , Z_OBJCE_P ( getThis ( ) ) , & intern -> u . dir . func_valid , \"valid\" , & retval ) ;\n if ( retval ) {\n valid = zend_is_true ( retval ) ;\n zval_ptr_dtor ( & retval ) ;\n retval = NULL ;\n }\n if ( ! valid ) {\n break ;\n }\n zend_call_method_with_0_params ( & this_ptr , Z_OBJCE_P ( getThis ( ) ) , & intern -> u . dir . func_next , \"next\" , & retval ) ;\n if ( retval ) {\n zval_ptr_dtor ( & retval ) ;\n }\n }\n }", "idx": 782}
{"hash": -2127895299879503273, "project": "debian", "size": 14, "label": 0, "functionSource": "static uint32_t pmac_ide_readb ( void * opaque , hwaddr addr ) {\n uint8_t retval ;\n MACIOIDEState * d = opaque ;\n addr = ( addr & 0xFFF ) >> 4 ;\n switch ( addr ) {\n case 1 ... 7 : retval = ide_ioport_read ( & d -> bus , addr ) ;\n break ;\n case 8 : case 22 : retval = ide_status_read ( & d -> bus , 0 ) ;\n break ;\n default : retval = 0xFF ;\n break ;\n }\n return retval ;\n }", "idx": 783}
{"hash": 6632536031698733342, "project": "debian", "size": 15, "label": 0, "functionSource": "static int show_programs ( WriterContext * w , InputFile * ifile ) {\n AVFormatContext * fmt_ctx = ifile -> fmt_ctx ;\n int i , ret = 0 ;\n writer_print_section_header ( w , SECTION_ID_PROGRAMS ) ;\n for ( i = 0 ;\n i < fmt_ctx -> nb_programs ;\n i ++ ) {\n AVProgram * program = fmt_ctx -> programs [ i ] ;\n if ( ! program ) continue ;\n ret = show_program ( w , ifile , program ) ;\n if ( ret < 0 ) break ;\n }\n writer_print_section_footer ( w ) ;\n return ret ;\n }", "idx": 784}
{"hash": -3740862514502467070, "project": "debian", "size": 6, "label": 0, "functionSource": "static int tcomp2 ( const void * _t1 , const void * _t2 ) {\n struct taboff * t1 = * ( ( struct taboff * * ) _t1 ) , * t2 = * ( ( struct taboff * * ) _t2 ) ;\n if ( t1 -> offset > t2 -> offset ) return ( 1 ) ;\n else if ( t1 -> offset < t2 -> offset ) return ( - 1 ) ;\n return ( 0 ) ;\n }", "idx": 785}
{"hash": -1983921383858884161, "project": "debian", "size": 15, "label": 1, "functionSource": "static int ipvideo_decode_block_opcode_0xE_16 ( IpvideoContext * s ) {\n int x , y ;\n uint16_t pix ;\n uint16_t * pixel_ptr = ( uint16_t * ) s -> pixel_ptr ;\n pix = bytestream2_get_le16 ( & s -> stream_ptr ) ;\n for ( y = 0 ;\n y < 8 ;\n y ++ ) {\n for ( x = 0 ;\n x < 8 ;\n x ++ ) pixel_ptr [ x ] = pix ;\n pixel_ptr += s -> stride ;\n }\n return 0 ;\n }", "idx": 786}
{"hash": 8127806390163862344, "project": "debian", "size": 49, "label": 0, "functionSource": "static void patch_instruction ( VAPICROMState * s , X86CPU * cpu , target_ulong ip ) {\n CPUState * cs = CPU ( cpu ) ;\n CPUX86State * env = & cpu -> env ;\n VAPICHandlers * handlers ;\n uint8_t opcode [ 2 ] ;\n uint32_t imm32 ;\n target_ulong current_pc = 0 ;\n target_ulong current_cs_base = 0 ;\n int current_flags = 0 ;\n if ( smp_cpus == 1 ) {\n handlers = & s -> rom_state . up ;\n }\n else {\n handlers = & s -> rom_state . mp ;\n }\n if ( ! kvm_enabled ( ) ) {\n cpu_restore_state ( env , env -> mem_io_pc ) ;\n cpu_get_tb_cpu_state ( env , & current_pc , & current_cs_base , & current_flags ) ;\n }\n pause_all_vcpus ( ) ;\n cpu_memory_rw_debug ( env , ip , opcode , sizeof ( opcode ) , 0 ) ;\n switch ( opcode [ 0 ] ) {\n case 0x89 : patch_byte ( env , ip , 0x50 + modrm_reg ( opcode [ 1 ] ) ) ;\n patch_call ( s , env , ip + 1 , handlers -> set_tpr ) ;\n break ;\n case 0x8b : patch_byte ( env , ip , 0x90 ) ;\n patch_call ( s , env , ip + 1 , handlers -> get_tpr [ modrm_reg ( opcode [ 1 ] ) ] ) ;\n break ;\n case 0xa1 : patch_call ( s , env , ip , handlers -> get_tpr [ 0 ] ) ;\n break ;\n case 0xa3 : patch_call ( s , env , ip , handlers -> set_tpr_eax ) ;\n break ;\n case 0xc7 : patch_byte ( env , ip , 0x68 ) ;\n cpu_memory_rw_debug ( env , ip + 6 , ( void * ) & imm32 , sizeof ( imm32 ) , 0 ) ;\n cpu_memory_rw_debug ( env , ip + 1 , ( void * ) & imm32 , sizeof ( imm32 ) , 1 ) ;\n patch_call ( s , env , ip + 5 , handlers -> set_tpr ) ;\n break ;\n case 0xff : patch_byte ( env , ip , 0x50 ) ;\n patch_call ( s , env , ip + 1 , handlers -> get_tpr_stack ) ;\n break ;\n default : abort ( ) ;\n }\n resume_all_vcpus ( ) ;\n if ( ! kvm_enabled ( ) ) {\n cs -> current_tb = NULL ;\n tb_gen_code ( env , current_pc , current_cs_base , current_flags , 1 ) ;\n cpu_resume_from_signal ( env , NULL ) ;\n }\n }", "idx": 787}
{"hash": 7039307292471244756, "project": "debian", "size": 13, "label": 0, "functionSource": "static guint16 de_tp_loop_type ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len _U_ , gchar * add_string _U_ , int string_len _U_ ) {\n guint32 curr_offset ;\n guchar oct ;\n curr_offset = offset ;\n oct = tvb_get_guint8 ( tvb , curr_offset ) ;\n proto_tree_add_item ( tree , hf_gsm_a_dtap_channel_coding03 , tvb , curr_offset , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( tree , hf_gsm_a_dtap_loop_mechanism1C , tvb , curr_offset , 1 , ENC_BIG_ENDIAN ) ;\n if ( ( oct & 0x1c ) == 0 ) {\n proto_tree_add_item ( tree , hf_gsm_a_dtap_timeslot_number , tvb , curr_offset , 1 , ENC_NA ) ;\n }\n curr_offset += 1 ;\n return ( curr_offset - offset ) ;\n }", "idx": 788}
{"hash": 7673224878519445199, "project": "debian", "size": 9, "label": 0, "functionSource": "static int vdpau_h264_end_frame ( AVCodecContext * avctx ) {\n AVVDPAUContext * hwctx = avctx -> hwaccel_context ;\n H264Context * h = avctx -> priv_data ;\n VdpVideoSurface surf = ff_vdpau_get_surface_id ( h -> cur_pic_ptr ) ;\n hwctx -> render ( hwctx -> decoder , surf , ( void * ) & hwctx -> info , hwctx -> bitstream_buffers_used , hwctx -> bitstream_buffers ) ;\n ff_h264_draw_horiz_band ( h , 0 , h -> avctx -> height ) ;\n hwctx -> bitstream_buffers_used = 0 ;\n return 0 ;\n }", "idx": 789}
{"hash": -1672864273235910388, "project": "debian", "size": 82, "label": 0, "functionSource": "static void _slurm_rpc_job_will_run ( slurm_msg_t * msg ) {\n DEF_TIMERS ;\n int error_code = SLURM_SUCCESS ;\n struct job_record * job_ptr = NULL ;\n job_desc_msg_t * job_desc_msg = ( job_desc_msg_t * ) msg -> data ;\n slurmctld_lock_t job_read_lock = {\n READ_LOCK , READ_LOCK , READ_LOCK , READ_LOCK , READ_LOCK }\n ;\n slurmctld_lock_t job_write_lock = {\n READ_LOCK , WRITE_LOCK , WRITE_LOCK , READ_LOCK , READ_LOCK }\n ;\n uid_t uid = g_slurm_auth_get_uid ( msg -> auth_cred , slurmctld_config . auth_info ) ;\n gid_t gid = g_slurm_auth_get_gid ( msg -> auth_cred , slurmctld_config . auth_info ) ;\n uint16_t port ;\n slurm_addr_t resp_addr ;\n will_run_response_msg_t * resp = NULL ;\n char * err_msg = NULL , * job_submit_user_msg = NULL ;\n if ( slurmctld_config . submissions_disabled ) {\n info ( \"Submissions disabled on system\" ) ;\n error_code = ESLURM_SUBMISSIONS_DISABLED ;\n goto send_reply ;\n }\n START_TIMER ;\n debug2 ( \"Processing RPC: REQUEST_JOB_WILL_RUN from uid=%d\" , uid ) ;\n if ( ( error_code = _valid_id ( \"REQUEST_JOB_WILL_RUN\" , job_desc_msg , uid , gid ) ) ) goto send_reply ;\n if ( ( job_desc_msg -> alloc_node == NULL ) || ( job_desc_msg -> alloc_node [ 0 ] == '\\0' ) ) {\n error_code = ESLURM_INVALID_NODE_NAME ;\n error ( \"REQUEST_JOB_WILL_RUN lacks alloc_node from uid=%d\" , uid ) ;\n }\n if ( error_code == SLURM_SUCCESS ) {\n lock_slurmctld ( job_read_lock ) ;\n job_desc_msg -> pack_job_offset = NO_VAL ;\n error_code = validate_job_create_req ( job_desc_msg , uid , & err_msg ) ;\n unlock_slurmctld ( job_read_lock ) ;\n }\n if ( err_msg ) job_submit_user_msg = xstrdup ( err_msg ) ;\n if ( ! slurm_get_peer_addr ( msg -> conn_fd , & resp_addr ) ) {\n job_desc_msg -> resp_host = xmalloc ( 16 ) ;\n slurm_get_ip_str ( & resp_addr , & port , job_desc_msg -> resp_host , 16 ) ;\n dump_job_desc ( job_desc_msg ) ;\n if ( error_code == SLURM_SUCCESS ) {\n lock_slurmctld ( job_write_lock ) ;\n if ( job_desc_msg -> job_id == NO_VAL ) {\n job_desc_msg -> pack_job_offset = NO_VAL ;\n error_code = job_allocate ( job_desc_msg , false , true , & resp , true , uid , & job_ptr , & err_msg , msg -> protocol_version ) ;\n }\n else {\n error_code = job_start_data ( job_desc_msg , & resp ) ;\n }\n unlock_slurmctld ( job_write_lock ) ;\n END_TIMER2 ( \"_slurm_rpc_job_will_run\" ) ;\n }\n }\n else if ( errno ) error_code = errno ;\n else error_code = SLURM_ERROR ;\n send_reply : if ( error_code ) {\n debug2 ( \"_slurm_rpc_job_will_run: %s\" , slurm_strerror ( error_code ) ) ;\n if ( err_msg ) slurm_send_rc_err_msg ( msg , error_code , err_msg ) ;\n else slurm_send_rc_msg ( msg , error_code ) ;\n }\n else if ( resp ) {\n slurm_msg_t response_msg ;\n slurm_msg_t_init ( & response_msg ) ;\n response_msg . flags = msg -> flags ;\n response_msg . protocol_version = msg -> protocol_version ;\n response_msg . address = msg -> address ;\n response_msg . conn = msg -> conn ;\n response_msg . msg_type = RESPONSE_JOB_WILL_RUN ;\n response_msg . data = resp ;\n resp -> job_submit_user_msg = job_submit_user_msg ;\n job_submit_user_msg = NULL ;\n slurm_send_node_msg ( msg -> conn_fd , & response_msg ) ;\n slurm_free_will_run_response_msg ( resp ) ;\n debug2 ( \"_slurm_rpc_job_will_run success %s\" , TIME_STR ) ;\n }\n else {\n debug2 ( \"_slurm_rpc_job_will_run success %s\" , TIME_STR ) ;\n if ( job_desc_msg -> job_id == NO_VAL ) slurm_send_rc_msg ( msg , SLURM_SUCCESS ) ;\n }\n xfree ( err_msg ) ;\n xfree ( job_submit_user_msg ) ;\n }", "idx": 790}
{"hash": -4765077557530511796, "project": "chrome", "size": 42, "label": 0, "functionSource": "static int ogg_replace_stream ( AVFormatContext * s , uint32_t serial , int nsegs ) {\n struct ogg * ogg = s -> priv_data ;\n struct ogg_stream * os ;\n const struct ogg_codec * codec ;\n int i = 0 ;\n if ( s -> pb -> seekable ) {\n uint8_t magic [ 8 ] ;\n int64_t pos = avio_tell ( s -> pb ) ;\n avio_skip ( s -> pb , nsegs ) ;\n avio_read ( s -> pb , magic , sizeof ( magic ) ) ;\n avio_seek ( s -> pb , pos , SEEK_SET ) ;\n codec = ogg_find_codec ( magic , sizeof ( magic ) ) ;\n if ( ! codec ) {\n av_log ( s , AV_LOG_ERROR , \"Cannot identify new stream\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n for ( i = 0 ;\n i < ogg -> nstreams ;\n i ++ ) {\n if ( ogg -> streams [ i ] . codec == codec ) break ;\n }\n if ( i >= ogg -> nstreams ) return ogg_new_stream ( s , serial ) ;\n }\n else if ( ogg -> nstreams != 1 ) {\n avpriv_report_missing_feature ( s , \"Changing stream parameters in multistream ogg\" ) ;\n return AVERROR_PATCHWELCOME ;\n }\n os = & ogg -> streams [ i ] ;\n os -> serial = serial ;\n return i ;\n # if 0 buf = os -> buf ;\n bufsize = os -> bufsize ;\n codec = os -> codec ;\n if ( ! ogg -> state || ogg -> state -> streams [ i ] . private != os -> private ) av_freep ( & ogg -> streams [ i ] . private ) ;\n memset ( os , 0 , sizeof ( * os ) ) ;\n os -> serial = serial ;\n os -> bufsize = bufsize ;\n os -> buf = buf ;\n os -> header = - 1 ;\n os -> codec = codec ;\n return i ;\n # endif }", "idx": 791}
{"hash": -7076754245473579218, "project": "chrome", "size": 20, "label": 0, "functionSource": "static int evhttp_add_header_internal ( struct evkeyvalq * headers , const char * key , const char * value ) {\n struct evkeyval * header = calloc ( 1 , sizeof ( struct evkeyval ) ) ;\n if ( header == NULL ) {\n event_warn ( \"%s: calloc\" , __func__ ) ;\n return ( - 1 ) ;\n }\n if ( ( header -> key = strdup ( key ) ) == NULL ) {\n free ( header ) ;\n event_warn ( \"%s: strdup\" , __func__ ) ;\n return ( - 1 ) ;\n }\n if ( ( header -> value = strdup ( value ) ) == NULL ) {\n free ( header -> key ) ;\n free ( header ) ;\n event_warn ( \"%s: strdup\" , __func__ ) ;\n return ( - 1 ) ;\n }\n TAILQ_INSERT_TAIL ( headers , header , next ) ;\n return ( 0 ) ;\n }", "idx": 792}
{"hash": -1483849844579170895, "project": "chrome", "size": 30, "label": 0, "functionSource": "static struct stream_state * new_stream ( struct VpxEncoderConfig * global , struct stream_state * prev ) {\n struct stream_state * stream ;\n stream = calloc ( 1 , sizeof ( * stream ) ) ;\n if ( stream == NULL ) {\n fatal ( \"Failed to allocate new stream.\" ) ;\n }\n if ( prev ) {\n memcpy ( stream , prev , sizeof ( * stream ) ) ;\n stream -> index ++ ;\n prev -> next = stream ;\n }\n else {\n vpx_codec_err_t res ;\n res = vpx_codec_enc_config_default ( global -> codec -> codec_interface ( ) , & stream -> config . cfg , global -> usage ) ;\n if ( res ) fatal ( \"Failed to get config: %s\\n\" , vpx_codec_err_to_string ( res ) ) ;\n stream -> config . cfg . g_timebase . den = 1000 ;\n stream -> config . cfg . g_w = 0 ;\n stream -> config . cfg . g_h = 0 ;\n stream -> config . write_webm = 1 ;\n # if CONFIG_WEBM_IO stream -> config . stereo_fmt = STEREO_FORMAT_MONO ;\n stream -> ebml . last_pts_ns = - 1 ;\n stream -> ebml . writer = NULL ;\n stream -> ebml . segment = NULL ;\n # endif stream -> ebml . debug = global -> debug ;\n if ( global -> deadline == VPX_DL_REALTIME ) stream -> config . cfg . g_lag_in_frames = 0 ;\n }\n stream -> config . out_fn = NULL ;\n stream -> next = NULL ;\n return stream ;\n }", "idx": 793}
{"hash": -6068976579504840746, "project": "debian", "size": 3, "label": 0, "functionSource": "void set_sys_var ( const char * data , u_long size , u_short def ) {\n set_var ( & ext_sys_var , data , size , def ) ;\n }", "idx": 794}
{"hash": 1245821301839614810, "project": "debian", "size": 7, "label": 0, "functionSource": "static void report_preparing_move_progress ( CopyMoveJob * move_job , int total , int left ) {\n CommonJob * job ;\n job = ( CommonJob * ) move_job ;\n nautilus_progress_info_take_status ( job -> progress , f ( _ ( \"Preparing to move to \u201c%B\u201d\" ) , move_job -> destination ) ) ;\n nautilus_progress_info_take_details ( job -> progress , f ( ngettext ( \"Preparing to move %'d file\" , \"Preparing to move %'d files\" , left ) , left ) ) ;\n nautilus_progress_info_pulse_progress ( job -> progress ) ;\n }", "idx": 795}
{"hash": -7076754245473579218, "project": "chrome", "size": 3, "label": 0, "functionSource": "void evhttp_request_set_chunked_cb ( struct evhttp_request * req , void ( * cb ) ( struct evhttp_request * , void * ) ) {\n req -> chunk_cb = cb ;\n }", "idx": 796}
{"hash": -483869641057106085, "project": "debian", "size": 42, "label": 0, "functionSource": "extern int as_mysql_suspend ( mysql_conn_t * mysql_conn , uint64_t old_db_inx , struct job_record * job_ptr ) {\n char * query = NULL ;\n int rc = SLURM_SUCCESS ;\n time_t submit_time ;\n uint64_t job_db_inx ;\n if ( check_connection ( mysql_conn ) != SLURM_SUCCESS ) return ESLURM_DB_CONNECTION ;\n if ( job_ptr -> resize_time ) submit_time = job_ptr -> resize_time ;\n else submit_time = job_ptr -> details -> submit_time ;\n if ( ! job_ptr -> db_index ) {\n if ( ! ( job_ptr -> db_index = _get_db_index ( mysql_conn , submit_time , job_ptr -> job_id , job_ptr -> assoc_id ) ) ) {\n if ( as_mysql_job_start ( mysql_conn , job_ptr ) == SLURM_ERROR ) {\n error ( \"couldn't suspend job %u\" , job_ptr -> job_id ) ;\n return SLURM_SUCCESS ;\n }\n }\n }\n if ( IS_JOB_RESIZING ( job_ptr ) ) {\n if ( ! old_db_inx ) {\n error ( \"No old db inx given for job %u cluster %s, \" \"can't update suspend table.\" , job_ptr -> job_id , mysql_conn -> cluster_name ) ;\n return SLURM_ERROR ;\n }\n job_db_inx = old_db_inx ;\n xstrfmtcat ( query , \"update \\\"%s_%s\\\" set time_end=%d where \" \"job_db_inx=%\" PRIu64 \" && time_end=0;\n\" , mysql_conn -> cluster_name , suspend_table , ( int ) job_ptr -> suspend_time , job_db_inx ) ;\n }\n else job_db_inx = job_ptr -> db_index ;\n xstrfmtcat ( query , \"update \\\"%s_%s\\\" set time_suspended=%d-time_suspended, \" \"state=%d where job_db_inx=%\" PRIu64 \";\n\" , mysql_conn -> cluster_name , job_table , ( int ) job_ptr -> suspend_time , job_ptr -> job_state & JOB_STATE_BASE , job_db_inx ) ;\n if ( IS_JOB_SUSPENDED ( job_ptr ) ) xstrfmtcat ( query , \"insert into \\\"%s_%s\\\" (job_db_inx, id_assoc, \" \"time_start, time_end) \" \"values (%\" PRIu64 \", %u, %d, 0);\n\" , mysql_conn -> cluster_name , suspend_table , job_ptr -> db_index , job_ptr -> assoc_id , ( int ) job_ptr -> suspend_time ) ;\n else xstrfmtcat ( query , \"update \\\"%s_%s\\\" set time_end=%d where \" \"job_db_inx=%\" PRIu64 \" && time_end=0;\n\" , mysql_conn -> cluster_name , suspend_table , ( int ) job_ptr -> suspend_time , job_ptr -> db_index ) ;\n if ( debug_flags & DEBUG_FLAG_DB_JOB ) DB_DEBUG ( mysql_conn -> conn , \"query\\n%s\" , query ) ;\n rc = mysql_db_query ( mysql_conn , query ) ;\n xfree ( query ) ;\n if ( rc != SLURM_ERROR ) {\n xstrfmtcat ( query , \"update \\\"%s_%s\\\" set \" \"time_suspended=%u-time_suspended, \" \"state=%d where job_db_inx=%\" PRIu64 \" and time_end=0\" , mysql_conn -> cluster_name , step_table , ( int ) job_ptr -> suspend_time , job_ptr -> job_state , job_ptr -> db_index ) ;\n rc = mysql_db_query ( mysql_conn , query ) ;\n xfree ( query ) ;\n }\n return rc ;\n }", "idx": 797}
{"hash": 6249489553242542670, "project": "debian", "size": 5, "label": 0, "functionSource": "void ntpd_set_tod_using ( const char * which ) {\n char line [ 128 ] ;\n snprintf ( line , sizeof ( line ) , \"settimeofday=\\\"%s\\\"\" , which ) ;\n set_sys_var ( line , strlen ( line ) + 1 , RO ) ;\n }", "idx": 798}
{"hash": 7191899184788440065, "project": "debian", "size": 6, "label": 0, "functionSource": "static const char * array_value ( const char * * array , char key ) {\n for ( ;\n * array ;\n array += 2 ) if ( * * array == key ) return array [ 1 ] ;\n return 0 ;\n }", "idx": 799}
{"hash": -4239386405881995323, "project": "chrome", "size": 21, "label": 1, "functionSource": "static unsigned long xmlHashComputeKey ( xmlHashTablePtr table , const xmlChar * name , const xmlChar * name2 , const xmlChar * name3 ) {\n unsigned long value = 0L ;\n char ch ;\n if ( name != NULL ) {\n value += 30 * ( * name ) ;\n while ( ( ch = * name ++ ) != 0 ) {\n value = value ^ ( ( value << 5 ) + ( value >> 3 ) + ( unsigned long ) ch ) ;\n }\n }\n if ( name2 != NULL ) {\n while ( ( ch = * name2 ++ ) != 0 ) {\n value = value ^ ( ( value << 5 ) + ( value >> 3 ) + ( unsigned long ) ch ) ;\n }\n }\n if ( name3 != NULL ) {\n while ( ( ch = * name3 ++ ) != 0 ) {\n value = value ^ ( ( value << 5 ) + ( value >> 3 ) + ( unsigned long ) ch ) ;\n }\n }\n return ( value % table -> size ) ;\n }", "idx": 800}
{"hash": -3559021711340554904, "project": "debian", "size": 5, "label": 0, "functionSource": "Node * make_and_qual ( Node * qual1 , Node * qual2 ) {\n if ( qual1 == NULL ) return qual2 ;\n if ( qual2 == NULL ) return qual1 ;\n return ( Node * ) make_andclause ( list_make2 ( qual1 , qual2 ) ) ;\n }", "idx": 801}
{"hash": -281311800725760049, "project": "debian", "size": 45, "label": 0, "functionSource": "static void decode_filter_coeffs ( TAKDecContext * s , int filter_order , int size , int filter_quant , int16_t * filter ) {\n GetBitContext * gb = & s -> gb ;\n int i , j , a , b ;\n int filter_tmp [ MAX_PREDICTORS ] ;\n int16_t predictors [ MAX_PREDICTORS ] ;\n predictors [ 0 ] = get_sbits ( gb , 10 ) ;\n predictors [ 1 ] = get_sbits ( gb , 10 ) ;\n predictors [ 2 ] = get_sbits ( gb , size ) << ( 10 - size ) ;\n predictors [ 3 ] = get_sbits ( gb , size ) << ( 10 - size ) ;\n if ( filter_order > 4 ) {\n int av_uninit ( code_size ) ;\n int code_size_base = size - get_bits1 ( gb ) ;\n for ( i = 4 ;\n i < filter_order ;\n i ++ ) {\n if ( ! ( i & 3 ) ) code_size = code_size_base - get_bits ( gb , 2 ) ;\n predictors [ i ] = get_sbits ( gb , code_size ) << ( 10 - size ) ;\n }\n }\n filter_tmp [ 0 ] = predictors [ 0 ] << 6 ;\n for ( i = 1 ;\n i < filter_order ;\n i ++ ) {\n int * p1 = & filter_tmp [ 0 ] ;\n int * p2 = & filter_tmp [ i - 1 ] ;\n for ( j = 0 ;\n j < ( i + 1 ) / 2 ;\n j ++ ) {\n int tmp = * p1 + ( predictors [ i ] * * p2 + 256 >> 9 ) ;\n * p2 = * p2 + ( predictors [ i ] * * p1 + 256 >> 9 ) ;\n * p1 = tmp ;\n p1 ++ ;\n p2 -- ;\n }\n filter_tmp [ i ] = predictors [ i ] << 6 ;\n }\n a = 1 << ( 32 - ( 15 - filter_quant ) ) ;\n b = 1 << ( ( 15 - filter_quant ) - 1 ) ;\n for ( i = 0 , j = filter_order - 1 ;\n i < filter_order / 2 ;\n i ++ , j -- ) {\n filter [ j ] = a - ( ( filter_tmp [ i ] + b ) >> ( 15 - filter_quant ) ) ;\n filter [ i ] = a - ( ( filter_tmp [ j ] + b ) >> ( 15 - filter_quant ) ) ;\n }\n }", "idx": 802}
{"hash": -3765873911425338769, "project": "debian", "size": 21, "label": 1, "functionSource": "void simplestring_addn ( simplestring * target , const char * source , int add_len ) {\n if ( target && source ) {\n if ( ! target -> str ) {\n simplestring_init_str ( target ) ;\n }\n if ( target -> len + add_len + 1 > target -> size ) {\n int newsize = target -> len + add_len + 1 ;\n int incr = target -> size * 2 ;\n newsize = newsize - ( newsize % incr ) + incr ;\n target -> str = ( char * ) realloc ( target -> str , newsize ) ;\n target -> size = target -> str ? newsize : 0 ;\n }\n if ( target -> str ) {\n if ( add_len ) {\n memcpy ( target -> str + target -> len , source , add_len ) ;\n }\n target -> len += add_len ;\n target -> str [ target -> len ] = 0 ;\n }\n }\n }", "idx": 803}
{"hash": 8461782184979846246, "project": "chrome", "size": 6, "label": 0, "functionSource": "TEST_F ( ProtocolHandlerRegistryTest , TestReentrantNotifications ) {\n QueryProtocolHandlerOnChange queryer ( profile ( ) , registry ( ) ) ;\n ProtocolHandler ph1 = CreateProtocolHandler ( \"test\" , \"test1\" ) ;\n registry ( ) -> OnAcceptRegisterProtocolHandler ( ph1 ) ;\n ASSERT_TRUE ( queryer . called_ ) ;\n }", "idx": 804}
{"hash": 3584320764213684062, "project": "debian", "size": 17, "label": 0, "functionSource": "static int parse_CAggregSortKey ( tvbuff_t * tvb , int offset , proto_tree * parent_tree , proto_tree * pad_tree , const char * fmt , ... ) {\n guint32 order ;\n proto_item * item ;\n proto_tree * tree ;\n const char * txt ;\n va_list ap ;\n va_start ( ap , fmt ) ;\n txt = wmem_strdup_vprintf ( wmem_packet_scope ( ) , fmt , ap ) ;\n va_end ( ap ) ;\n tree = proto_tree_add_subtree ( parent_tree , tvb , offset , 0 , ett_CAggregSortKey , & item , txt ) ;\n order = tvb_get_letohl ( tvb , offset ) ;\n proto_tree_add_uint ( tree , hf_mswsp_caggregsortkey_order , tvb , offset , 4 , order ) ;\n offset += 4 ;\n offset = parse_CAggregSpec ( tvb , offset , tree , pad_tree , \"ColumnSpec\" ) ;\n proto_item_set_end ( item , tvb , offset ) ;\n return offset ;\n }", "idx": 805}
{"hash": -5280794106681745199, "project": "debian", "size": 35, "label": 0, "functionSource": "static GstFlowReturn gst_asf_demux_process_bitrate_props_object ( GstASFDemux * demux , guint8 * data , guint64 size ) {\n guint16 num_streams , i ;\n AsfStream * stream ;\n if ( size < 2 ) goto not_enough_data ;\n num_streams = gst_asf_demux_get_uint16 ( & data , & size ) ;\n GST_INFO ( \"object is a bitrate properties object with %u streams\" , num_streams ) ;\n if ( size < ( num_streams * ( 2 + 4 ) ) ) goto not_enough_data ;\n for ( i = 0 ;\n i < num_streams ;\n ++ i ) {\n guint32 bitrate ;\n guint16 stream_id ;\n stream_id = gst_asf_demux_get_uint16 ( & data , & size ) ;\n bitrate = gst_asf_demux_get_uint32 ( & data , & size ) ;\n if ( stream_id < GST_ASF_DEMUX_NUM_STREAM_IDS ) {\n GST_DEBUG_OBJECT ( demux , \"bitrate of stream %u = %u\" , stream_id , bitrate ) ;\n stream = gst_asf_demux_get_stream ( demux , stream_id ) ;\n if ( stream ) {\n if ( stream -> pending_tags == NULL ) stream -> pending_tags = gst_tag_list_new_empty ( ) ;\n gst_tag_list_add ( stream -> pending_tags , GST_TAG_MERGE_REPLACE , GST_TAG_BITRATE , bitrate , NULL ) ;\n }\n else {\n GST_WARNING_OBJECT ( demux , \"Stream id %u wasn't found\" , stream_id ) ;\n }\n }\n else {\n GST_WARNING ( \"stream id %u is too large\" , stream_id ) ;\n }\n }\n return GST_FLOW_OK ;\n not_enough_data : {\n GST_WARNING_OBJECT ( demux , \"short read parsing bitrate props object!\" ) ;\n return GST_FLOW_OK ;\n }\n }", "idx": 806}
{"hash": 6984172841296431440, "project": "debian", "size": 51, "label": 0, "functionSource": "static int aura_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * pkt ) {\n AVFrame * frame = data ;\n uint8_t * Y , * U , * V ;\n uint8_t val ;\n int x , y , ret ;\n const uint8_t * buf = pkt -> data ;\n const int8_t * delta_table = ( const int8_t * ) buf + 16 ;\n if ( pkt -> size != 48 + avctx -> height * avctx -> width ) {\n av_log ( avctx , AV_LOG_ERROR , \"got a buffer with %d bytes when %d were expected\\n\" , pkt -> size , 48 + avctx -> height * avctx -> width ) ;\n return AVERROR_INVALIDDATA ;\n }\n buf += 48 ;\n if ( ( ret = ff_get_buffer ( avctx , frame , 0 ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n Y = frame -> data [ 0 ] ;\n U = frame -> data [ 1 ] ;\n V = frame -> data [ 2 ] ;\n for ( y = 0 ;\n y < avctx -> height ;\n y ++ ) {\n val = * buf ++ ;\n U [ 0 ] = val & 0xF0 ;\n Y [ 0 ] = val << 4 ;\n val = * buf ++ ;\n V [ 0 ] = val & 0xF0 ;\n Y [ 1 ] = Y [ 0 ] + delta_table [ val & 0xF ] ;\n Y += 2 ;\n U ++ ;\n V ++ ;\n for ( x = 1 ;\n x < ( avctx -> width >> 1 ) ;\n x ++ ) {\n val = * buf ++ ;\n U [ 0 ] = U [ - 1 ] + delta_table [ val >> 4 ] ;\n Y [ 0 ] = Y [ - 1 ] + delta_table [ val & 0xF ] ;\n val = * buf ++ ;\n V [ 0 ] = V [ - 1 ] + delta_table [ val >> 4 ] ;\n Y [ 1 ] = Y [ 0 ] + delta_table [ val & 0xF ] ;\n Y += 2 ;\n U ++ ;\n V ++ ;\n }\n Y += frame -> linesize [ 0 ] - avctx -> width ;\n U += frame -> linesize [ 1 ] - ( avctx -> width >> 1 ) ;\n V += frame -> linesize [ 2 ] - ( avctx -> width >> 1 ) ;\n }\n * got_frame = 1 ;\n return pkt -> size ;\n }", "idx": 807}
{"hash": -4032982860280343776, "project": "chrome", "size": 7, "label": 0, "functionSource": "static int8_t getNextDynamicWindow ( SCSUData * scsu ) {\n int8_t window = scsu -> windowUse [ scsu -> nextWindowUseIndex ] ;\n if ( ++ scsu -> nextWindowUseIndex == 8 ) {\n scsu -> nextWindowUseIndex = 0 ;\n }\n return window ;\n }", "idx": 808}
{"hash": 1458662858915721428, "project": "debian", "size": 25, "label": 0, "functionSource": "static inline void set_bits ( uint8_t * tab , int start , int len ) {\n int end , mask , end1 ;\n end = start + len ;\n tab += start >> 3 ;\n mask = 0xff << ( start & 7 ) ;\n if ( ( start & ~ 7 ) == ( end & ~ 7 ) ) {\n if ( start < end ) {\n mask &= ~ ( 0xff << ( end & 7 ) ) ;\n * tab |= mask ;\n }\n }\n else {\n * tab ++ |= mask ;\n start = ( start + 8 ) & ~ 7 ;\n end1 = end & ~ 7 ;\n while ( start < end1 ) {\n * tab ++ = 0xff ;\n start += 8 ;\n }\n if ( start < end ) {\n mask = ~ ( 0xff << ( end & 7 ) ) ;\n * tab |= mask ;\n }\n }\n }", "idx": 809}
{"hash": 7039307292471244756, "project": "debian", "size": 8, "label": 0, "functionSource": "static guint16 de_bcc_state_attr ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len _U_ , gchar * add_string _U_ , int string_len _U_ ) {\n proto_tree_add_item ( tree , hf_gsm_a_dtap_bcc_state_attr , tvb , offset , 1 , ENC_NA ) ;\n proto_tree_add_item ( tree , hf_gsm_a_dtap_bcc_state_attr_da , tvb , offset , 1 , ENC_NA ) ;\n proto_tree_add_item ( tree , hf_gsm_a_dtap_bcc_state_attr_ua , tvb , offset , 1 , ENC_NA ) ;\n proto_tree_add_item ( tree , hf_gsm_a_dtap_bcc_state_attr_comm , tvb , offset , 1 , ENC_NA ) ;\n proto_tree_add_item ( tree , hf_gsm_a_dtap_bcc_state_attr_oi , tvb , offset , 1 , ENC_NA ) ;\n return 1 ;\n }", "idx": 810}
{"hash": 1535921111212871029, "project": "debian", "size": 3, "label": 0, "functionSource": "int remoteSerializeStreamError ( struct qemud_client * client , remote_error * rerr , int proc , int serial ) {\n return remoteSerializeError ( client , rerr , REMOTE_PROGRAM , REMOTE_PROTOCOL_VERSION , proc , REMOTE_STREAM , serial ) ;\n }", "idx": 811}
{"hash": 3584320764213684062, "project": "debian", "size": 34, "label": 0, "functionSource": "int parse_CColumnGroup ( tvbuff_t * tvb , int offset , proto_tree * parent_tree , proto_tree * pad_tree _U_ , const char * fmt , ... ) {\n proto_tree * tree ;\n proto_item * item , * ti ;\n va_list ap ;\n const char * txt ;\n guint32 count , groupPid , i ;\n va_start ( ap , fmt ) ;\n txt = wmem_strdup_vprintf ( wmem_packet_scope ( ) , fmt , ap ) ;\n va_end ( ap ) ;\n tree = proto_tree_add_subtree ( parent_tree , tvb , offset , 0 , ett_CColumnGroup , & item , txt ) ;\n count = tvb_get_letohl ( tvb , offset ) ;\n proto_tree_add_uint ( tree , hf_mswsp_ccolumngroup_count , tvb , offset , 4 , count ) ;\n offset += 4 ;\n groupPid = tvb_get_letohl ( tvb , offset ) ;\n ti = proto_tree_add_uint ( tree , hf_mswsp_ccolumngroup_grouppid , tvb , offset , 4 , groupPid ) ;\n if ( ( 0xFFFF0000 & groupPid ) == 0x7FFF0000 ) {\n proto_item_append_text ( ti , \" Idx: %u\" , groupPid & 0xFFFF ) ;\n }\n else {\n proto_item_append_text ( ti , \"<Invalid>\" ) ;\n }\n offset += 4 ;\n for ( i = 0 ;\n i < count ;\n i ++ ) {\n guint32 pid , weight ;\n pid = tvb_get_letohl ( tvb , offset ) ;\n weight = tvb_get_letohl ( tvb , offset + 4 ) ;\n proto_tree_add_uint_format ( tree , hf_mswsp_ccolumngroup_pid , tvb , offset , 8 , pid , \"Props[%u]: pid: %u weight: %u\" , i , pid , weight ) ;\n offset += 8 ;\n }\n proto_item_set_end ( item , tvb , offset ) ;\n return offset ;\n }", "idx": 812}
{"hash": -7855974557509681261, "project": "debian", "size": 12, "label": 0, "functionSource": "void getTypeOutputInfo ( Oid type , Oid * typOutput , bool * typIsVarlena ) {\n HeapTuple typeTuple ;\n Form_pg_type pt ;\n typeTuple = SearchSysCache1 ( TYPEOID , ObjectIdGetDatum ( type ) ) ;\n if ( ! HeapTupleIsValid ( typeTuple ) ) elog ( ERROR , \"cache lookup failed for type %u\" , type ) ;\n pt = ( Form_pg_type ) GETSTRUCT ( typeTuple ) ;\n if ( ! pt -> typisdefined ) ereport ( ERROR , ( errcode ( ERRCODE_UNDEFINED_OBJECT ) , errmsg ( \"type %s is only a shell\" , format_type_be ( type ) ) ) ) ;\n if ( ! OidIsValid ( pt -> typoutput ) ) ereport ( ERROR , ( errcode ( ERRCODE_UNDEFINED_FUNCTION ) , errmsg ( \"no output function available for type %s\" , format_type_be ( type ) ) ) ) ;\n * typOutput = pt -> typoutput ;\n * typIsVarlena = ( ! pt -> typbyval ) && ( pt -> typlen == - 1 ) ;\n ReleaseSysCache ( typeTuple ) ;\n }", "idx": 813}
{"hash": 4704178797381506498, "project": "debian", "size": 44, "label": 0, "functionSource": "kadm5_ret_t kadm5_purgekeys ( void * server_handle , krb5_principal principal , int keepkvno ) {\n kadm5_server_handle_t handle = server_handle ;\n kadm5_ret_t ret ;\n krb5_db_entry * kdb ;\n osa_princ_ent_rec adb ;\n krb5_key_data * old_keydata ;\n int n_old_keydata ;\n int i , j , k ;\n CHECK_HANDLE ( server_handle ) ;\n if ( principal == NULL ) return EINVAL ;\n ret = kdb_get_entry ( handle , principal , & kdb , & adb ) ;\n if ( ret ) return ( ret ) ;\n if ( keepkvno <= 0 ) {\n keepkvno = krb5_db_get_key_data_kvno ( handle -> context , kdb -> n_key_data , kdb -> key_data ) ;\n }\n old_keydata = kdb -> key_data ;\n n_old_keydata = kdb -> n_key_data ;\n kdb -> n_key_data = 0 ;\n kdb -> key_data = krb5_db_alloc ( handle -> context , NULL , ( n_old_keydata + 1 ) * sizeof ( krb5_key_data ) ) ;\n if ( kdb -> key_data == NULL ) {\n ret = ENOMEM ;\n goto done ;\n }\n memset ( kdb -> key_data , 0 , n_old_keydata * sizeof ( krb5_key_data ) ) ;\n for ( i = 0 , j = 0 ;\n i < n_old_keydata ;\n i ++ ) {\n if ( old_keydata [ i ] . key_data_kvno < keepkvno ) continue ;\n kdb -> key_data [ j ] = old_keydata [ i ] ;\n for ( k = 0 ;\n k < old_keydata [ i ] . key_data_ver ;\n k ++ ) {\n old_keydata [ i ] . key_data_contents [ k ] = NULL ;\n }\n j ++ ;\n }\n kdb -> n_key_data = j ;\n cleanup_key_data ( handle -> context , n_old_keydata , old_keydata ) ;\n kdb -> mask = KADM5_KEY_DATA ;\n ret = kdb_put_entry ( handle , kdb , & adb ) ;\n if ( ret ) goto done ;\n done : kdb_free_entry ( handle , kdb , & adb ) ;\n return ret ;\n }", "idx": 814}
{"hash": -1315695702746584250, "project": "debian", "size": 8, "label": 0, "functionSource": "static void proto_tree_set_string ( field_info * fi , const char * value ) {\n if ( value ) {\n fvalue_set_string ( & fi -> value , value ) ;\n }\n else {\n fvalue_set_string ( & fi -> value , \"[ Null ]\" ) ;\n }\n }", "idx": 815}
{"hash": -2222463888415249941, "project": "chrome", "size": 6, "label": 0, "functionSource": "void vp9_update_reference ( VP9_COMP * cpi , int ref_frame_flags ) {\n cpi -> ext_refresh_golden_frame = ( ref_frame_flags & VP9_GOLD_FLAG ) != 0 ;\n cpi -> ext_refresh_alt_ref_frame = ( ref_frame_flags & VP9_ALT_FLAG ) != 0 ;\n cpi -> ext_refresh_last_frame = ( ref_frame_flags & VP9_LAST_FLAG ) != 0 ;\n cpi -> ext_refresh_frame_flags_pending = 1 ;\n }", "idx": 816}
{"hash": 8073241806104522127, "project": "chrome", "size": 35, "label": 0, "functionSource": "TEST_F ( AutocompleteResultTest , SortAndCullWithMatchDupsAndDemotionsByType ) {\n ACMatches matches ;\n const AutocompleteMatchTestData data [ ] = {\n {\n \"http://search-what-you-typed/\" , AutocompleteMatchType : : SEARCH_WHAT_YOU_TYPED }\n , {\n \"http://dup-url/\" , AutocompleteMatchType : : HISTORY_URL }\n , {\n \"http://dup-url/\" , AutocompleteMatchType : : NAVSUGGEST }\n , {\n \"http://search-url/\" , AutocompleteMatchType : : SEARCH_SUGGEST }\n , {\n \"http://history-url/\" , AutocompleteMatchType : : HISTORY_URL }\n , }\n ;\n PopulateAutocompleteMatchesFromTestData ( data , arraysize ( data ) , & matches ) ;\n {\n std : : map < std : : string , std : : string > params ;\n params [ std : : string ( OmniboxFieldTrial : : kDemoteByTypeRule ) + \":8:*\" ] = \"1:50\" ;\n ASSERT_TRUE ( variations : : AssociateVariationParams ( OmniboxFieldTrial : : kBundledExperimentFieldTrialName , \"C\" , params ) ) ;\n }\n base : : FieldTrialList : : CreateFieldTrial ( OmniboxFieldTrial : : kBundledExperimentFieldTrialName , \"C\" ) ;\n {\n AutocompleteInput input ( base : : string16 ( ) , base : : string16 : : npos , std : : string ( ) , GURL ( ) , OmniboxEventProto : : INSTANT_NTP_WITH_FAKEBOX_AS_STARTING_FOCUS , false , false , false , true , false , TestSchemeClassifier ( ) ) ;\n AutocompleteResult result ;\n result . AppendMatches ( input , matches ) ;\n result . SortAndCull ( input , template_url_service_ . get ( ) ) ;\n ASSERT_EQ ( 4u , result . size ( ) ) ;\n EXPECT_EQ ( \"http://search-what-you-typed/\" , result . match_at ( 0 ) -> destination_url . spec ( ) ) ;\n EXPECT_EQ ( \"http://dup-url/\" , result . match_at ( 1 ) -> destination_url . spec ( ) ) ;\n EXPECT_EQ ( AutocompleteMatchType : : NAVSUGGEST , result . match_at ( 1 ) -> type ) ;\n EXPECT_EQ ( \"http://search-url/\" , result . match_at ( 2 ) -> destination_url . spec ( ) ) ;\n EXPECT_EQ ( \"http://history-url/\" , result . match_at ( 3 ) -> destination_url . spec ( ) ) ;\n }\n }", "idx": 817}
{"hash": 4876100961671882393, "project": "debian", "size": 6, "label": 0, "functionSource": "static int dissect_pvfs2_getattr_request ( tvbuff_t * tvb , proto_tree * tree , int offset , packet_info * pinfo ) {\n offset = dissect_pvfs_fh ( tvb , offset , pinfo , tree , \"handle\" , NULL ) ;\n offset = dissect_pvfs_fs_id ( tvb , tree , offset ) ;\n offset = dissect_pvfs2_attrmask ( tvb , tree , offset , NULL ) ;\n return offset ;\n }", "idx": 818}
{"hash": 2600695546378251053, "project": "debian", "size": 74, "label": 1, "functionSource": "static int h261_decode_mb ( H261Context * h ) {\n MpegEncContext * const s = & h -> s ;\n int i , cbp , xy ;\n cbp = 63 ;\n do {\n h -> mba_diff = get_vlc2 ( & s -> gb , h261_mba_vlc . table , H261_MBA_VLC_BITS , 2 ) ;\n if ( h -> mba_diff == MBA_STARTCODE ) {\n h -> gob_start_code_skipped = 1 ;\n return SLICE_END ;\n }\n }\n while ( h -> mba_diff == MBA_STUFFING ) ;\n if ( h -> mba_diff < 0 ) {\n if ( get_bits_left ( & s -> gb ) <= 7 ) return SLICE_END ;\n av_log ( s -> avctx , AV_LOG_ERROR , \"illegal mba at %d %d\\n\" , s -> mb_x , s -> mb_y ) ;\n return SLICE_ERROR ;\n }\n h -> mba_diff += 1 ;\n h -> current_mba += h -> mba_diff ;\n if ( h -> current_mba > MBA_STUFFING ) return SLICE_ERROR ;\n s -> mb_x = ( ( h -> gob_number - 1 ) % 2 ) * 11 + ( ( h -> current_mba - 1 ) % 11 ) ;\n s -> mb_y = ( ( h -> gob_number - 1 ) / 2 ) * 3 + ( ( h -> current_mba - 1 ) / 11 ) ;\n xy = s -> mb_x + s -> mb_y * s -> mb_stride ;\n ff_init_block_index ( s ) ;\n ff_update_block_index ( s ) ;\n h -> mtype = get_vlc2 ( & s -> gb , h261_mtype_vlc . table , H261_MTYPE_VLC_BITS , 2 ) ;\n h -> mtype = h261_mtype_map [ h -> mtype ] ;\n if ( IS_QUANT ( h -> mtype ) ) {\n ff_set_qscale ( s , get_bits ( & s -> gb , 5 ) ) ;\n }\n s -> mb_intra = IS_INTRA4x4 ( h -> mtype ) ;\n if ( IS_16X16 ( h -> mtype ) ) {\n if ( ( h -> current_mba == 1 ) || ( h -> current_mba == 12 ) || ( h -> current_mba == 23 ) || ( h -> mba_diff != 1 ) ) {\n h -> current_mv_x = 0 ;\n h -> current_mv_y = 0 ;\n }\n h -> current_mv_x = decode_mv_component ( & s -> gb , h -> current_mv_x ) ;\n h -> current_mv_y = decode_mv_component ( & s -> gb , h -> current_mv_y ) ;\n }\n else {\n h -> current_mv_x = 0 ;\n h -> current_mv_y = 0 ;\n }\n if ( HAS_CBP ( h -> mtype ) ) {\n cbp = get_vlc2 ( & s -> gb , h261_cbp_vlc . table , H261_CBP_VLC_BITS , 2 ) + 1 ;\n }\n if ( s -> mb_intra ) {\n s -> current_picture . f . mb_type [ xy ] = MB_TYPE_INTRA ;\n goto intra ;\n }\n s -> mv_dir = MV_DIR_FORWARD ;\n s -> mv_type = MV_TYPE_16X16 ;\n s -> current_picture . f . mb_type [ xy ] = MB_TYPE_16x16 | MB_TYPE_L0 ;\n s -> mv [ 0 ] [ 0 ] [ 0 ] = h -> current_mv_x * 2 ;\n s -> mv [ 0 ] [ 0 ] [ 1 ] = h -> current_mv_y * 2 ;\n intra : if ( s -> mb_intra || HAS_CBP ( h -> mtype ) ) {\n s -> dsp . clear_blocks ( s -> block [ 0 ] ) ;\n for ( i = 0 ;\n i < 6 ;\n i ++ ) {\n if ( h261_decode_block ( h , s -> block [ i ] , i , cbp & 32 ) < 0 ) {\n return SLICE_ERROR ;\n }\n cbp += cbp ;\n }\n }\n else {\n for ( i = 0 ;\n i < 6 ;\n i ++ ) s -> block_last_index [ i ] = - 1 ;\n }\n ff_MPV_decode_mb ( s , s -> block ) ;\n return SLICE_OK ;\n }", "idx": 819}
{"hash": 1676654288894940649, "project": "debian", "size": 15, "label": 0, "functionSource": "static void unlock_princ ( kadm5_principal_ent_t princ , long * mask , const char * caller ) {\n krb5_error_code retval ;\n krb5_timestamp now ;\n krb5_octet timebuf [ 4 ] ;\n princ -> fail_auth_count = 0 ;\n * mask |= KADM5_FAIL_AUTH_COUNT ;\n retval = krb5_timeofday ( context , & now ) ;\n if ( retval ) {\n com_err ( caller , retval , _ ( \"while getting time\" ) ) ;\n exit ( 1 ) ;\n }\n store_32_le ( ( krb5_int32 ) now , timebuf ) ;\n add_tl_data ( & princ -> n_tl_data , & princ -> tl_data , KRB5_TL_LAST_ADMIN_UNLOCK , 4 , timebuf ) ;\n * mask |= KADM5_TL_DATA ;\n }", "idx": 820}
{"hash": -6024601983167898950, "project": "debian", "size": 4, "label": 0, "functionSource": "static gboolean delete_cb ( GtkDialog * dialog ) {\n gtk_dialog_response ( dialog , GTK_RESPONSE_DELETE_EVENT ) ;\n return TRUE ;\n }", "idx": 821}
{"hash": -2222463888415249941, "project": "chrome", "size": 4, "label": 0, "functionSource": "static void alloc_ref_frame_buffers ( VP9_COMP * cpi ) {\n VP9_COMMON * const cm = & cpi -> common ;\n if ( vp9_alloc_ref_frame_buffers ( cm , cm -> width , cm -> height ) ) vpx_internal_error ( & cm -> error , VPX_CODEC_MEM_ERROR , \"Failed to allocate frame buffers\" ) ;\n }", "idx": 822}
{"hash": 1760449185745615462, "project": "debian", "size": 17, "label": 0, "functionSource": "TSReturnCode TSUrlClone ( TSMBuffer dest_bufp , TSMBuffer src_bufp , TSMLoc src_url , TSMLoc * locp ) {\n sdk_assert ( sdk_sanity_check_mbuffer ( src_bufp ) == TS_SUCCESS ) ;\n sdk_assert ( sdk_sanity_check_mbuffer ( dest_bufp ) == TS_SUCCESS ) ;\n sdk_assert ( sdk_sanity_check_url_handle ( src_url ) == TS_SUCCESS ) ;\n sdk_assert ( sdk_sanity_check_null_ptr ( locp ) == TS_SUCCESS ) ;\n if ( ! isWriteable ( dest_bufp ) ) {\n return TS_ERROR ;\n }\n HdrHeap * s_heap , * d_heap ;\n URLImpl * s_url , * d_url ;\n s_heap = ( ( HdrHeapSDKHandle * ) src_bufp ) -> m_heap ;\n d_heap = ( ( HdrHeapSDKHandle * ) dest_bufp ) -> m_heap ;\n s_url = ( URLImpl * ) src_url ;\n d_url = url_copy ( s_url , s_heap , d_heap , ( s_heap != d_heap ) ) ;\n * locp = ( TSMLoc ) d_url ;\n return TS_SUCCESS ;\n }", "idx": 823}
{"hash": -5280794106681745199, "project": "debian", "size": 91, "label": 0, "functionSource": "static void gst_asf_demux_reset ( GstASFDemux * demux , gboolean chain_reset ) {\n GST_LOG_OBJECT ( demux , \"resetting\" ) ;\n gst_segment_init ( & demux -> segment , GST_FORMAT_UNDEFINED ) ;\n demux -> segment_running = FALSE ;\n if ( demux -> adapter && ! chain_reset ) {\n gst_adapter_clear ( demux -> adapter ) ;\n g_object_unref ( demux -> adapter ) ;\n demux -> adapter = NULL ;\n }\n if ( demux -> taglist ) {\n gst_tag_list_unref ( demux -> taglist ) ;\n demux -> taglist = NULL ;\n }\n if ( demux -> metadata ) {\n gst_caps_unref ( demux -> metadata ) ;\n demux -> metadata = NULL ;\n }\n if ( demux -> global_metadata ) {\n gst_structure_free ( demux -> global_metadata ) ;\n demux -> global_metadata = NULL ;\n }\n if ( demux -> mut_ex_streams ) {\n g_slist_free ( demux -> mut_ex_streams ) ;\n demux -> mut_ex_streams = NULL ;\n }\n demux -> state = GST_ASF_DEMUX_STATE_HEADER ;\n g_free ( demux -> objpath ) ;\n demux -> objpath = NULL ;\n g_strfreev ( demux -> languages ) ;\n demux -> languages = NULL ;\n demux -> num_languages = 0 ;\n g_slist_foreach ( demux -> ext_stream_props , ( GFunc ) gst_mini_object_unref , NULL ) ;\n g_slist_free ( demux -> ext_stream_props ) ;\n demux -> ext_stream_props = NULL ;\n while ( demux -> old_num_streams > 0 ) {\n gst_asf_demux_free_stream ( demux , & demux -> old_stream [ demux -> old_num_streams - 1 ] ) ;\n -- demux -> old_num_streams ;\n }\n memset ( demux -> old_stream , 0 , sizeof ( demux -> old_stream ) ) ;\n demux -> old_num_streams = 0 ;\n if ( chain_reset ) {\n memcpy ( demux -> old_stream , demux -> stream , sizeof ( demux -> stream ) ) ;\n demux -> old_num_streams = demux -> num_streams ;\n demux -> num_streams = 0 ;\n }\n while ( demux -> num_streams > 0 ) {\n gst_asf_demux_free_stream ( demux , & demux -> stream [ demux -> num_streams - 1 ] ) ;\n -- demux -> num_streams ;\n }\n memset ( demux -> stream , 0 , sizeof ( demux -> stream ) ) ;\n if ( ! chain_reset ) {\n demux -> num_audio_streams = 0 ;\n demux -> num_video_streams = 0 ;\n demux -> have_group_id = FALSE ;\n demux -> group_id = G_MAXUINT ;\n }\n demux -> num_streams = 0 ;\n demux -> activated_streams = FALSE ;\n demux -> first_ts = GST_CLOCK_TIME_NONE ;\n demux -> segment_ts = GST_CLOCK_TIME_NONE ;\n demux -> in_gap = 0 ;\n if ( ! chain_reset ) gst_segment_init ( & demux -> in_segment , GST_FORMAT_UNDEFINED ) ;\n demux -> state = GST_ASF_DEMUX_STATE_HEADER ;\n demux -> seekable = FALSE ;\n demux -> broadcast = FALSE ;\n demux -> sidx_interval = 0 ;\n demux -> sidx_num_entries = 0 ;\n g_free ( demux -> sidx_entries ) ;\n demux -> sidx_entries = NULL ;\n demux -> speed_packets = 1 ;\n demux -> asf_3D_mode = GST_ASF_3D_NONE ;\n if ( chain_reset ) {\n GST_LOG_OBJECT ( demux , \"Restarting\" ) ;\n gst_segment_init ( & demux -> segment , GST_FORMAT_TIME ) ;\n demux -> need_newsegment = TRUE ;\n demux -> segment_seqnum = 0 ;\n demux -> segment_running = FALSE ;\n demux -> keyunit_sync = FALSE ;\n demux -> accurate = FALSE ;\n demux -> metadata = gst_caps_new_empty ( ) ;\n demux -> global_metadata = gst_structure_new_empty ( \"metadata\" ) ;\n demux -> data_size = 0 ;\n demux -> data_offset = 0 ;\n demux -> index_offset = 0 ;\n }\n else {\n demux -> base_offset = 0 ;\n }\n g_slist_free ( demux -> other_streams ) ;\n demux -> other_streams = NULL ;\n }", "idx": 824}
{"hash": -1483849844579170895, "project": "chrome", "size": 68, "label": 0, "functionSource": "static void parse_global_config ( struct VpxEncoderConfig * global , char * * argv ) {\n char * * argi , * * argj ;\n struct arg arg ;\n memset ( global , 0 , sizeof ( * global ) ) ;\n global -> codec = get_vpx_encoder_by_index ( 0 ) ;\n global -> passes = 0 ;\n global -> color_type = I420 ;\n global -> deadline = VPX_DL_GOOD_QUALITY ;\n for ( argi = argj = argv ;\n ( * argj = * argi ) ;\n argi += arg . argv_step ) {\n arg . argv_step = 1 ;\n if ( arg_match ( & arg , & codecarg , argi ) ) {\n global -> codec = get_vpx_encoder_by_name ( arg . val ) ;\n if ( ! global -> codec ) die ( \"Error: Unrecognized argument (%s) to --codec\\n\" , arg . val ) ;\n }\n else if ( arg_match ( & arg , & passes , argi ) ) {\n global -> passes = arg_parse_uint ( & arg ) ;\n if ( global -> passes < 1 || global -> passes > 2 ) die ( \"Error: Invalid number of passes (%d)\\n\" , global -> passes ) ;\n }\n else if ( arg_match ( & arg , & pass_arg , argi ) ) {\n global -> pass = arg_parse_uint ( & arg ) ;\n if ( global -> pass < 1 || global -> pass > 2 ) die ( \"Error: Invalid pass selected (%d)\\n\" , global -> pass ) ;\n }\n else if ( arg_match ( & arg , & usage , argi ) ) global -> usage = arg_parse_uint ( & arg ) ;\n else if ( arg_match ( & arg , & deadline , argi ) ) global -> deadline = arg_parse_uint ( & arg ) ;\n else if ( arg_match ( & arg , & best_dl , argi ) ) global -> deadline = VPX_DL_BEST_QUALITY ;\n else if ( arg_match ( & arg , & good_dl , argi ) ) global -> deadline = VPX_DL_GOOD_QUALITY ;\n else if ( arg_match ( & arg , & rt_dl , argi ) ) global -> deadline = VPX_DL_REALTIME ;\n else if ( arg_match ( & arg , & use_yv12 , argi ) ) global -> color_type = YV12 ;\n else if ( arg_match ( & arg , & use_i420 , argi ) ) global -> color_type = I420 ;\n else if ( arg_match ( & arg , & use_i422 , argi ) ) global -> color_type = I422 ;\n else if ( arg_match ( & arg , & use_i444 , argi ) ) global -> color_type = I444 ;\n else if ( arg_match ( & arg , & quietarg , argi ) ) global -> quiet = 1 ;\n else if ( arg_match ( & arg , & verbosearg , argi ) ) global -> verbose = 1 ;\n else if ( arg_match ( & arg , & limit , argi ) ) global -> limit = arg_parse_uint ( & arg ) ;\n else if ( arg_match ( & arg , & skip , argi ) ) global -> skip_frames = arg_parse_uint ( & arg ) ;\n else if ( arg_match ( & arg , & psnrarg , argi ) ) global -> show_psnr = 1 ;\n else if ( arg_match ( & arg , & recontest , argi ) ) global -> test_decode = arg_parse_enum_or_int ( & arg ) ;\n else if ( arg_match ( & arg , & framerate , argi ) ) {\n global -> framerate = arg_parse_rational ( & arg ) ;\n validate_positive_rational ( arg . name , & global -> framerate ) ;\n global -> have_framerate = 1 ;\n }\n else if ( arg_match ( & arg , & out_part , argi ) ) global -> out_part = 1 ;\n else if ( arg_match ( & arg , & debugmode , argi ) ) global -> debug = 1 ;\n else if ( arg_match ( & arg , & q_hist_n , argi ) ) global -> show_q_hist_buckets = arg_parse_uint ( & arg ) ;\n else if ( arg_match ( & arg , & rate_hist_n , argi ) ) global -> show_rate_hist_buckets = arg_parse_uint ( & arg ) ;\n else if ( arg_match ( & arg , & disable_warnings , argi ) ) global -> disable_warnings = 1 ;\n else if ( arg_match ( & arg , & disable_warning_prompt , argi ) ) global -> disable_warning_prompt = 1 ;\n else if ( arg_match ( & arg , & experimental_bitstream , argi ) ) global -> experimental_bitstream = 1 ;\n else argj ++ ;\n }\n if ( global -> pass ) {\n if ( global -> pass > global -> passes ) {\n warn ( \"Assuming --pass=%d implies --passes=%d\\n\" , global -> pass , global -> pass ) ;\n global -> passes = global -> pass ;\n }\n }\n if ( global -> passes == 0 ) {\n # if CONFIG_VP9_ENCODER if ( global -> codec != NULL && global -> codec -> name != NULL ) global -> passes = ( strcmp ( global -> codec -> name , \"vp9\" ) == 0 && global -> deadline != VPX_DL_REALTIME ) ? 2 : 1 ;\n # else global -> passes = 1 ;\n # endif }\n if ( global -> deadline == VPX_DL_REALTIME && global -> passes > 1 ) {\n warn ( \"Enforcing one-pass encoding in realtime mode\\n\" ) ;\n global -> passes = 1 ;\n }\n }", "idx": 825}
{"hash": 6755873269946787742, "project": "debian", "size": 29, "label": 0, "functionSource": "static void pk_transaction_repo_enable ( PkTransaction * transaction , GVariant * params , GDBusMethodInvocation * context ) {\n gboolean ret ;\n const gchar * repo_id ;\n gboolean enabled ;\n g_autoptr ( GError ) error = NULL ;\n g_return_if_fail ( PK_IS_TRANSACTION ( transaction ) ) ;\n g_return_if_fail ( transaction -> priv -> tid != NULL ) ;\n g_variant_get ( params , \"(&sb)\" , & repo_id , & enabled ) ;\n g_debug ( \"RepoEnable method called: %s, %i\" , repo_id , enabled ) ;\n if ( ! pk_backend_is_implemented ( transaction -> priv -> backend , PK_ROLE_ENUM_REPO_ENABLE ) ) {\n g_set_error ( & error , PK_TRANSACTION_ERROR , PK_TRANSACTION_ERROR_NOT_SUPPORTED , \"RepoEnable not supported by backend\" ) ;\n pk_transaction_set_state ( transaction , PK_TRANSACTION_STATE_ERROR ) ;\n goto out ;\n }\n ret = pk_transaction_strvalidate ( repo_id , & error ) ;\n if ( ! ret ) {\n pk_transaction_set_state ( transaction , PK_TRANSACTION_STATE_ERROR ) ;\n goto out ;\n }\n transaction -> priv -> cached_repo_id = g_strdup ( repo_id ) ;\n transaction -> priv -> cached_enabled = enabled ;\n pk_transaction_set_role ( transaction , PK_ROLE_ENUM_REPO_ENABLE ) ;\n ret = pk_transaction_obtain_authorization ( transaction , PK_ROLE_ENUM_REPO_ENABLE , & error ) ;\n if ( ! ret ) {\n pk_transaction_set_state ( transaction , PK_TRANSACTION_STATE_ERROR ) ;\n goto out ;\n }\n out : pk_transaction_dbus_return ( context , error ) ;\n }", "idx": 826}
{"hash": -2423144171479606949, "project": "debian", "size": 45, "label": 1, "functionSource": "static void pdf_show_image ( fz_context * ctx , pdf_run_processor * pr , fz_image * image ) {\n pdf_gstate * gstate = pr -> gstate + pr -> gtop ;\n fz_matrix image_ctm ;\n fz_rect bbox ;\n softmask_save softmask = {\n NULL }\n ;\n if ( pr -> super . hidden ) return ;\n image_ctm = gstate -> ctm ;\n fz_pre_scale ( fz_pre_translate ( & image_ctm , 0 , 1 ) , 1 , - 1 ) ;\n bbox = fz_unit_rect ;\n fz_transform_rect ( & bbox , & image_ctm ) ;\n if ( image -> mask ) {\n if ( gstate -> blendmode ) fz_begin_group ( ctx , pr -> dev , & bbox , NULL , 0 , 0 , gstate -> blendmode , 1 ) ;\n fz_clip_image_mask ( ctx , pr -> dev , image -> mask , & image_ctm , & bbox ) ;\n }\n else gstate = pdf_begin_group ( ctx , pr , & bbox , & softmask ) ;\n if ( ! image -> colorspace ) {\n switch ( gstate -> fill . kind ) {\n case PDF_MAT_NONE : break ;\n case PDF_MAT_COLOR : fz_fill_image_mask ( ctx , pr -> dev , image , & image_ctm , gstate -> fill . colorspace , gstate -> fill . v , gstate -> fill . alpha , & gstate -> fill . color_params ) ;\n break ;\n case PDF_MAT_PATTERN : if ( gstate -> fill . pattern ) {\n fz_clip_image_mask ( ctx , pr -> dev , image , & image_ctm , & bbox ) ;\n pdf_show_pattern ( ctx , pr , gstate -> fill . pattern , & pr -> gstate [ gstate -> fill . gstate_num ] , & bbox , PDF_FILL ) ;\n fz_pop_clip ( ctx , pr -> dev ) ;\n }\n break ;\n case PDF_MAT_SHADE : if ( gstate -> fill . shade ) {\n fz_clip_image_mask ( ctx , pr -> dev , image , & image_ctm , & bbox ) ;\n fz_fill_shade ( ctx , pr -> dev , gstate -> fill . shade , & pr -> gstate [ gstate -> fill . gstate_num ] . ctm , gstate -> fill . alpha , & gstate -> fill . color_params ) ;\n fz_pop_clip ( ctx , pr -> dev ) ;\n }\n break ;\n }\n }\n else {\n fz_fill_image ( ctx , pr -> dev , image , & image_ctm , gstate -> fill . alpha , & gstate -> fill . color_params ) ;\n }\n if ( image -> mask ) {\n fz_pop_clip ( ctx , pr -> dev ) ;\n if ( gstate -> blendmode ) fz_end_group ( ctx , pr -> dev ) ;\n }\n else pdf_end_group ( ctx , pr , & softmask ) ;\n }", "idx": 827}
{"hash": 1614547608286395137, "project": "debian", "size": 9, "label": 0, "functionSource": "static void free_outgoing ( outgoing_t * outgoing ) {\n if ( outgoing -> ai ) {\n freeaddrinfo ( outgoing -> ai ) ;\n }\n if ( outgoing -> name ) {\n free ( outgoing -> name ) ;\n }\n free ( outgoing ) ;\n }", "idx": 828}
{"hash": -398565394354770780, "project": "debian", "size": 7, "label": 0, "functionSource": "static void ohci_die ( OHCIState * ohci ) {\n OHCIPCIState * dev = container_of ( ohci , OHCIPCIState , state ) ;\n trace_usb_ohci_die ( ) ;\n ohci_set_interrupt ( ohci , OHCI_INTR_UE ) ;\n ohci_bus_stop ( ohci ) ;\n pci_set_word ( dev -> parent_obj . config + PCI_STATUS , PCI_STATUS_DETECTED_PARITY ) ;\n }", "idx": 829}
{"hash": 2749000641600234529, "project": "debian", "size": 3, "label": 0, "functionSource": "static inline target_phys_addr_t vring_align ( target_phys_addr_t addr , unsigned long align ) {\n return ( addr + align - 1 ) & ~ ( align - 1 ) ;\n }", "idx": 830}
{"hash": -5912543978015782596, "project": "debian", "size": 8, "label": 0, "functionSource": "static void useSndTimeout ( socket_handle_t sock ) {\n # ifdef _WIN32 const DWORD socket_timeout = SOCKET_RW_TIMEOUT_MS ;\n setsockopt ( sock , SOL_SOCKET , SO_SNDTIMEO , ( const char * ) & socket_timeout , sizeof ( socket_timeout ) ) ;\n # else const struct timeval socket_timeout = {\n . tv_sec = SOCKET_RW_TIMEOUT_MS / 1000 , . tv_usec = ( SOCKET_RW_TIMEOUT_MS % 1000 ) * 1000 }\n ;\n setsockopt ( sock , SOL_SOCKET , SO_SNDTIMEO , & socket_timeout , sizeof ( socket_timeout ) ) ;\n # endif }", "idx": 831}
{"hash": 5468438784905165517, "project": "debian", "size": 3, "label": 0, "functionSource": "int ec_GF2m_have_precompute_mult ( const EC_GROUP * group ) {\n return ec_wNAF_have_precompute_mult ( group ) ;\n }", "idx": 832}
{"hash": 313627013719508831, "project": "debian", "size": 3, "label": 0, "functionSource": "static inline PixelTrait GetPixelChannelTraits ( const Image * restrict image , const PixelChannel channel ) {\n return ( image -> channel_map [ channel ] . traits ) ;\n }", "idx": 833}
{"hash": -3062453801436404700, "project": "debian", "size": 15, "label": 1, "functionSource": "static ossl_inline int sk_ ## t1 ## _is_sorted ( const STACK_OF ( t1 ) * sk ) {\n return OPENSSL_sk_is_sorted ( ( const OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _dup ( const STACK_OF ( t1 ) * sk ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_dup ( ( const OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _deep_copy ( const STACK_OF ( t1 ) * sk , sk_ ## t1 ## _copyfunc copyfunc , sk_ ## t1 ## _freefunc freefunc ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_deep_copy ( ( const OPENSSL_STACK * ) sk , ( OPENSSL_sk_copyfunc ) copyfunc , ( OPENSSL_sk_freefunc ) freefunc ) ;\n }\n static ossl_inline sk_ ## t1 ## _compfunc sk_ ## t1 ## _set_cmp_func ( STACK_OF ( t1 ) * sk , sk_ ## t1 ## _compfunc compare ) {\n return ( sk_ ## t1 ## _compfunc ) OPENSSL_sk_set_cmp_func ( ( OPENSSL_STACK * ) sk , ( OPENSSL_sk_compfunc ) compare ) ;\n }\n # define DEFINE_SPECIAL_STACK_OF ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , t2 , t2 ) # define DEFINE_STACK_OF ( t ) SKM_DEFINE_STACK_OF ( t , t , t ) # define DEFINE_SPECIAL_STACK_OF_CONST ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , const t2 , t2 ) # define DEFINE_STACK_OF_CONST ( t ) SKM_DEFINE_STACK_OF ( t , const t , t ) typedef char * OPENSSL_STRING ;\n typedef const char * OPENSSL_CSTRING ;\n DEFINE_SPECIAL_STACK_OF ( OPENSSL_STRING , char )", "idx": 834}
{"hash": 6323824267898511453, "project": "debian", "size": 3, "label": 0, "functionSource": "int fz_colorspace_is_subtractive ( fz_context * ctx , const fz_colorspace * cs ) {\n return cs && ( cs -> type == FZ_COLORSPACE_CMYK || cs -> type == FZ_COLORSPACE_SEPARATION ) ;\n }", "idx": 835}
{"hash": 6080147530626246065, "project": "debian", "size": 10, "label": 0, "functionSource": "static inline int median4 ( int a , int b , int c , int d ) {\n if ( a < b ) {\n if ( c < d ) return ( FFMIN ( b , d ) + FFMAX ( a , c ) ) / 2 ;\n else return ( FFMIN ( b , c ) + FFMAX ( a , d ) ) / 2 ;\n }\n else {\n if ( c < d ) return ( FFMIN ( a , d ) + FFMAX ( b , c ) ) / 2 ;\n else return ( FFMIN ( a , c ) + FFMAX ( b , d ) ) / 2 ;\n }\n }", "idx": 836}
{"hash": 4976989049001279223, "project": "debian", "size": 33, "label": 0, "functionSource": "int http_hdr_length_get ( HTTPHdrImpl * hdr ) {\n int length = 0 ;\n if ( hdr -> m_polarity == HTTP_TYPE_REQUEST ) {\n if ( hdr -> u . req . m_ptr_method ) {\n length = hdr -> u . req . m_len_method ;\n }\n else {\n length = 0 ;\n }\n length += 1 ;\n if ( hdr -> u . req . m_url_impl ) {\n length += url_length_get ( hdr -> u . req . m_url_impl ) ;\n }\n length += 1 ;\n length += 8 ;\n length += 2 ;\n }\n else if ( hdr -> m_polarity == HTTP_TYPE_RESPONSE ) {\n if ( hdr -> u . resp . m_ptr_reason ) {\n length = hdr -> u . resp . m_len_reason ;\n }\n else {\n length = 0 ;\n }\n length += 8 ;\n length += 1 ;\n length += 3 ;\n length += 1 ;\n length += 2 ;\n }\n length += mime_hdr_length_get ( hdr -> m_fields_impl ) ;\n return length ;\n }", "idx": 837}
{"hash": -7434014980763120366, "project": "debian", "size": 12, "label": 0, "functionSource": "static int dissect_ber_T_octet_aligned ( gboolean implicit_tag _U_ , tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n if ( actx -> external . u . ber . ber_callback ) {\n offset = actx -> external . u . ber . ber_callback ( FALSE , tvb , offset , actx , tree , hf_index ) ;\n }\n else if ( actx -> external . direct_ref_present && dissector_get_string_handle ( ber_oid_dissector_table , actx -> external . direct_reference ) ) {\n offset = call_ber_oid_callback ( actx -> external . direct_reference , tvb , offset , actx -> pinfo , tree , NULL ) ;\n }\n else {\n offset = dissect_ber_octet_string ( implicit_tag , actx , tree , tvb , offset , hf_index , & actx -> external . octet_aligned ) ;\n }\n return offset ;\n }", "idx": 838}
{"hash": 8460430819945784394, "project": "debian", "size": 40, "label": 0, "functionSource": "static void VGA_printf ( uint8_t * s ) {\n uint16_t * arg_ptr ;\n unsigned int format_width , i ;\n int in_format ;\n uint16_t arg , digit , nibble ;\n uint8_t c ;\n arg_ptr = ( uint16_t * ) ( ( void * ) & s ) ;\n in_format = 0 ;\n format_width = 0 ;\n while ( ( c = * s ) != '\\0' ) {\n if ( c == '%' ) {\n in_format = 1 ;\n format_width = 0 ;\n }\n else if ( in_format ) {\n if ( ( c >= '0' ) && ( c <= '9' ) ) {\n format_width = ( format_width * 10 ) + ( c - '0' ) ;\n }\n else if ( c == 'x' ) {\n arg_ptr ++ ;\n arg = * arg_ptr ;\n if ( format_width == 0 ) format_width = 4 ;\n digit = format_width - 1 ;\n for ( i = 0 ;\n i < format_width ;\n i ++ ) {\n nibble = ( arg >> ( 4 * digit ) ) & 0x000f ;\n if ( nibble <= 9 ) PPC_io_writeb ( PPC_IO_BASE + 0x500 , nibble + '0' ) ;\n else PPC_io_writeb ( PPC_IO_BASE + 0x500 , nibble + 'A' ) ;\n digit -- ;\n }\n in_format = 0 ;\n }\n }\n else {\n PPC_io_writeb ( PPC_IO_BASE + 0x500 , c ) ;\n }\n s ++ ;\n }\n }", "idx": 839}
{"hash": 6871081691104220210, "project": "debian", "size": 69, "label": 1, "functionSource": "static void fill_picture_parameters ( struct dxva_context * ctx , const H264Context * h , DXVA_PicParams_H264 * pp ) {\n const Picture * current_picture = h -> cur_pic_ptr ;\n int i , j ;\n memset ( pp , 0 , sizeof ( * pp ) ) ;\n fill_picture_entry ( & pp -> CurrPic , ff_dxva2_get_surface_index ( ctx , current_picture ) , h -> picture_structure == PICT_BOTTOM_FIELD ) ;\n pp -> UsedForReferenceFlags = 0 ;\n pp -> NonExistingFrameFlags = 0 ;\n for ( i = 0 , j = 0 ;\n i < FF_ARRAY_ELEMS ( pp -> RefFrameList ) ;\n i ++ ) {\n const Picture * r ;\n if ( j < h -> short_ref_count ) {\n r = h -> short_ref [ j ++ ] ;\n }\n else {\n r = NULL ;\n while ( ! r && j < h -> short_ref_count + 16 ) r = h -> long_ref [ j ++ - h -> short_ref_count ] ;\n }\n if ( r ) {\n fill_picture_entry ( & pp -> RefFrameList [ i ] , ff_dxva2_get_surface_index ( ctx , r ) , r -> long_ref != 0 ) ;\n if ( ( r -> f . reference & PICT_TOP_FIELD ) && r -> field_poc [ 0 ] != INT_MAX ) pp -> FieldOrderCntList [ i ] [ 0 ] = r -> field_poc [ 0 ] ;\n if ( ( r -> f . reference & PICT_BOTTOM_FIELD ) && r -> field_poc [ 1 ] != INT_MAX ) pp -> FieldOrderCntList [ i ] [ 1 ] = r -> field_poc [ 1 ] ;\n pp -> FrameNumList [ i ] = r -> long_ref ? r -> pic_id : r -> frame_num ;\n if ( r -> f . reference & PICT_TOP_FIELD ) pp -> UsedForReferenceFlags |= 1 << ( 2 * i + 0 ) ;\n if ( r -> f . reference & PICT_BOTTOM_FIELD ) pp -> UsedForReferenceFlags |= 1 << ( 2 * i + 1 ) ;\n }\n else {\n pp -> RefFrameList [ i ] . bPicEntry = 0xff ;\n pp -> FieldOrderCntList [ i ] [ 0 ] = 0 ;\n pp -> FieldOrderCntList [ i ] [ 1 ] = 0 ;\n pp -> FrameNumList [ i ] = 0 ;\n }\n }\n pp -> wFrameWidthInMbsMinus1 = h -> mb_width - 1 ;\n pp -> wFrameHeightInMbsMinus1 = h -> mb_height - 1 ;\n pp -> num_ref_frames = h -> sps . ref_frame_count ;\n pp -> wBitFields = ( ( h -> picture_structure != PICT_FRAME ) << 0 ) | ( ( h -> sps . mb_aff && ( h -> picture_structure == PICT_FRAME ) ) << 1 ) | ( h -> sps . residual_color_transform_flag << 2 ) | ( 0 << 3 ) | ( h -> sps . chroma_format_idc << 4 ) | ( ( h -> nal_ref_idc != 0 ) << 6 ) | ( h -> pps . constrained_intra_pred << 7 ) | ( h -> pps . weighted_pred << 8 ) | ( h -> pps . weighted_bipred_idc << 9 ) | ( 1 << 11 ) | ( h -> sps . frame_mbs_only_flag << 12 ) | ( h -> pps . transform_8x8_mode << 13 ) | ( ( h -> sps . level_idc >= 31 ) << 14 ) | ( 1 << 15 ) ;\n pp -> bit_depth_luma_minus8 = h -> sps . bit_depth_luma - 8 ;\n pp -> bit_depth_chroma_minus8 = h -> sps . bit_depth_chroma - 8 ;\n if ( ctx -> workaround & FF_DXVA2_WORKAROUND_SCALING_LIST_ZIGZAG ) pp -> Reserved16Bits = 0 ;\n else pp -> Reserved16Bits = 3 ;\n pp -> StatusReportFeedbackNumber = 1 + ctx -> report_id ++ ;\n pp -> CurrFieldOrderCnt [ 0 ] = 0 ;\n if ( ( h -> picture_structure & PICT_TOP_FIELD ) && current_picture -> field_poc [ 0 ] != INT_MAX ) pp -> CurrFieldOrderCnt [ 0 ] = current_picture -> field_poc [ 0 ] ;\n pp -> CurrFieldOrderCnt [ 1 ] = 0 ;\n if ( ( h -> picture_structure & PICT_BOTTOM_FIELD ) && current_picture -> field_poc [ 1 ] != INT_MAX ) pp -> CurrFieldOrderCnt [ 1 ] = current_picture -> field_poc [ 1 ] ;\n pp -> pic_init_qs_minus26 = h -> pps . init_qs - 26 ;\n pp -> chroma_qp_index_offset = h -> pps . chroma_qp_index_offset [ 0 ] ;\n pp -> second_chroma_qp_index_offset = h -> pps . chroma_qp_index_offset [ 1 ] ;\n pp -> ContinuationFlag = 1 ;\n pp -> pic_init_qp_minus26 = h -> pps . init_qp - 26 ;\n pp -> num_ref_idx_l0_active_minus1 = h -> pps . ref_count [ 0 ] - 1 ;\n pp -> num_ref_idx_l1_active_minus1 = h -> pps . ref_count [ 1 ] - 1 ;\n pp -> Reserved8BitsA = 0 ;\n pp -> frame_num = h -> frame_num ;\n pp -> log2_max_frame_num_minus4 = h -> sps . log2_max_frame_num - 4 ;\n pp -> pic_order_cnt_type = h -> sps . poc_type ;\n if ( h -> sps . poc_type == 0 ) pp -> log2_max_pic_order_cnt_lsb_minus4 = h -> sps . log2_max_poc_lsb - 4 ;\n else if ( h -> sps . poc_type == 1 ) pp -> delta_pic_order_always_zero_flag = h -> sps . delta_pic_order_always_zero_flag ;\n pp -> direct_8x8_inference_flag = h -> sps . direct_8x8_inference_flag ;\n pp -> entropy_coding_mode_flag = h -> pps . cabac ;\n pp -> pic_order_present_flag = h -> pps . pic_order_present ;\n pp -> num_slice_groups_minus1 = h -> pps . slice_group_count - 1 ;\n pp -> slice_group_map_type = h -> pps . mb_slice_group_map_type ;\n pp -> deblocking_filter_control_present_flag = h -> pps . deblocking_filter_parameters_present ;\n pp -> redundant_pic_cnt_present_flag = h -> pps . redundant_pic_cnt_present ;\n pp -> Reserved8BitsB = 0 ;\n pp -> slice_group_change_rate_minus1 = 0 ;\n }", "idx": 840}
{"hash": -3559021711340554904, "project": "debian", "size": 7, "label": 0, "functionSource": "Expr * make_orclause ( List * orclauses ) {\n BoolExpr * expr = makeNode ( BoolExpr ) ;\n expr -> boolop = OR_EXPR ;\n expr -> args = orclauses ;\n expr -> location = - 1 ;\n return ( Expr * ) expr ;\n }", "idx": 841}
{"hash": 7039307292471244756, "project": "debian", "size": 7, "label": 0, "functionSource": "static guint16 de_hlc ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len , gchar * add_string _U_ , int string_len _U_ ) {\n guint32 curr_offset ;\n curr_offset = offset ;\n dissect_q931_high_layer_compat_ie ( tvb , offset , len , tree ) ;\n curr_offset = curr_offset + len ;\n return ( curr_offset - offset ) ;\n }", "idx": 842}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_T_broadcastMyLogicalChannelResponse ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_T_broadcastMyLogicalChannelResponse , T_broadcastMyLogicalChannelResponse_choice , NULL ) ;\n return offset ;\n }", "idx": 843}
{"hash": -1102844685921778700, "project": "debian", "size": 13, "label": 0, "functionSource": "static const char * get_current_charset ( struct archive * a ) {\n const char * cur_charset ;\n if ( a == NULL ) cur_charset = default_iconv_charset ( \"\" ) ;\n else {\n cur_charset = default_iconv_charset ( a -> current_code ) ;\n if ( a -> current_code == NULL ) {\n a -> current_code = strdup ( cur_charset ) ;\n a -> current_codepage = get_current_codepage ( ) ;\n a -> current_oemcp = get_current_oemcp ( ) ;\n }\n }\n return ( cur_charset ) ;\n }", "idx": 844}
{"hash": 9176142195250515812, "project": "debian", "size": 29, "label": 0, "functionSource": "static void purple_sync_settings ( account_t * acc , PurpleAccount * pa ) {\n PurplePlugin * prpl = purple_plugins_find_with_id ( pa -> protocol_id ) ;\n PurplePluginProtocolInfo * pi = prpl -> info -> extra_info ;\n GList * i ;\n for ( i = pi -> protocol_options ;\n i ;\n i = i -> next ) {\n PurpleAccountOption * o = i -> data ;\n const char * name ;\n set_t * s ;\n name = purple_account_option_get_setting ( o ) ;\n s = set_find ( & acc -> set , name ) ;\n if ( s -> value == NULL ) {\n continue ;\n }\n switch ( purple_account_option_get_type ( o ) ) {\n case PURPLE_PREF_STRING : case PURPLE_PREF_STRING_LIST : purple_account_set_string ( pa , name , set_getstr ( & acc -> set , name ) ) ;\n break ;\n case PURPLE_PREF_INT : purple_account_set_int ( pa , name , set_getint ( & acc -> set , name ) ) ;\n break ;\n case PURPLE_PREF_BOOLEAN : purple_account_set_bool ( pa , name , set_getbool ( & acc -> set , name ) ) ;\n break ;\n default : break ;\n }\n }\n if ( pi -> options & OPT_PROTO_MAIL_CHECK ) {\n purple_account_set_check_mail ( pa , set_getbool ( & acc -> set , \"mail_notifications\" ) ) ;\n }\n }", "idx": 845}
{"hash": -4967913570211470865, "project": "debian", "size": 7, "label": 1, "functionSource": "void * jas_realloc ( void * ptr , size_t size ) {\n void * result ;\n JAS_DBGLOG ( 101 , ( \"jas_realloc called with %x,%zu\\n\" , ptr , size ) ) ;\n result = realloc ( ptr , size ) ;\n JAS_DBGLOG ( 100 , ( \"jas_realloc(%p, %zu) -> %p\\n\" , ptr , size , result ) ) ;\n return result ;\n }", "idx": 846}
{"hash": 7198560023137364337, "project": "debian", "size": 4, "label": 0, "functionSource": "void free_sums ( struct sum_struct * s ) {\n if ( s -> sums ) free ( s -> sums ) ;\n free ( s ) ;\n }", "idx": 847}
{"hash": 2419147764757351618, "project": "debian", "size": 3, "label": 0, "functionSource": "static void s390_virtio_register_devices ( void ) {\n sysbus_register_withprop ( & s390_virtio_bridge_info ) ;\n }", "idx": 848}
{"hash": 8849962823026424130, "project": "debian", "size": 11, "label": 0, "functionSource": "static void qio_channel_websock_class_init ( ObjectClass * klass , void * class_data G_GNUC_UNUSED ) {\n QIOChannelClass * ioc_klass = QIO_CHANNEL_CLASS ( klass ) ;\n ioc_klass -> io_writev = qio_channel_websock_writev ;\n ioc_klass -> io_readv = qio_channel_websock_readv ;\n ioc_klass -> io_set_blocking = qio_channel_websock_set_blocking ;\n ioc_klass -> io_set_cork = qio_channel_websock_set_cork ;\n ioc_klass -> io_set_delay = qio_channel_websock_set_delay ;\n ioc_klass -> io_close = qio_channel_websock_close ;\n ioc_klass -> io_shutdown = qio_channel_websock_shutdown ;\n ioc_klass -> io_create_watch = qio_channel_websock_create_watch ;\n }", "idx": 849}
{"hash": -4744270124459050462, "project": "debian", "size": 54, "label": 0, "functionSource": "static int cng_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n AVFrame * frame = data ;\n CNGContext * p = avctx -> priv_data ;\n int buf_size = avpkt -> size ;\n int ret , i ;\n int16_t * buf_out ;\n float e = 1.0 ;\n float scaling ;\n if ( avpkt -> size ) {\n int dbov = - avpkt -> data [ 0 ] ;\n p -> target_energy = 1081109975 * pow ( 10 , dbov / 10.0 ) * 0.75 ;\n memset ( p -> target_refl_coef , 0 , p -> order * sizeof ( * p -> target_refl_coef ) ) ;\n for ( i = 0 ;\n i < FFMIN ( avpkt -> size - 1 , p -> order ) ;\n i ++ ) {\n p -> target_refl_coef [ i ] = ( avpkt -> data [ 1 + i ] - 127 ) / 128.0 ;\n }\n }\n if ( p -> inited ) {\n p -> energy = p -> energy / 2 + p -> target_energy / 2 ;\n for ( i = 0 ;\n i < p -> order ;\n i ++ ) p -> refl_coef [ i ] = 0.6 * p -> refl_coef [ i ] + 0.4 * p -> target_refl_coef [ i ] ;\n }\n else {\n p -> energy = p -> target_energy ;\n memcpy ( p -> refl_coef , p -> target_refl_coef , p -> order * sizeof ( * p -> refl_coef ) ) ;\n p -> inited = 1 ;\n }\n make_lpc_coefs ( p -> lpc_coef , p -> refl_coef , p -> order ) ;\n for ( i = 0 ;\n i < p -> order ;\n i ++ ) e *= 1.0 - p -> refl_coef [ i ] * p -> refl_coef [ i ] ;\n scaling = sqrt ( e * p -> energy / 1081109975 ) ;\n for ( i = 0 ;\n i < avctx -> frame_size ;\n i ++ ) {\n int r = ( av_lfg_get ( & p -> lfg ) & 0xffff ) - 0x8000 ;\n p -> excitation [ i ] = scaling * r ;\n }\n ff_celp_lp_synthesis_filterf ( p -> filter_out + p -> order , p -> lpc_coef , p -> excitation , avctx -> frame_size , p -> order ) ;\n frame -> nb_samples = avctx -> frame_size ;\n if ( ( ret = ff_get_buffer ( avctx , frame , 0 ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n buf_out = ( int16_t * ) frame -> data [ 0 ] ;\n for ( i = 0 ;\n i < avctx -> frame_size ;\n i ++ ) buf_out [ i ] = p -> filter_out [ i + p -> order ] ;\n memcpy ( p -> filter_out , p -> filter_out + avctx -> frame_size , p -> order * sizeof ( * p -> filter_out ) ) ;\n * got_frame_ptr = 1 ;\n return buf_size ;\n }", "idx": 850}
{"hash": -866921002076081979, "project": "debian", "size": 126, "label": 0, "functionSource": "REGRESSION_TEST ( SDK_API_TSConstant ) ( RegressionTest * test , int , int * pstatus ) {\n * pstatus = REGRESSION_TEST_INPROGRESS ;\n bool test_passed = true ;\n PRINT_DIFF ( TS_PARSE_ERROR ) ;\n PRINT_DIFF ( TS_PARSE_DONE ) ;\n PRINT_DIFF ( TS_PARSE_CONT ) ;\n PRINT_DIFF ( TS_HTTP_STATUS_NONE ) ;\n PRINT_DIFF ( TS_HTTP_STATUS_CONTINUE ) ;\n PRINT_DIFF ( TS_HTTP_STATUS_SWITCHING_PROTOCOL ) ;\n PRINT_DIFF ( TS_HTTP_STATUS_EARLY_HINTS ) ;\n PRINT_DIFF ( TS_HTTP_STATUS_OK ) ;\n PRINT_DIFF ( TS_HTTP_STATUS_CREATED ) ;\n PRINT_DIFF ( TS_HTTP_STATUS_ACCEPTED ) ;\n PRINT_DIFF ( TS_HTTP_STATUS_NON_AUTHORITATIVE_INFORMATION ) ;\n PRINT_DIFF ( TS_HTTP_STATUS_NO_CONTENT ) ;\n PRINT_DIFF ( TS_HTTP_STATUS_RESET_CONTENT ) ;\n PRINT_DIFF ( TS_HTTP_STATUS_PARTIAL_CONTENT ) ;\n PRINT_DIFF ( TS_HTTP_STATUS_MULTIPLE_CHOICES ) ;\n PRINT_DIFF ( TS_HTTP_STATUS_MOVED_PERMANENTLY ) ;\n PRINT_DIFF ( TS_HTTP_STATUS_MOVED_TEMPORARILY ) ;\n PRINT_DIFF ( TS_HTTP_STATUS_SEE_OTHER ) ;\n PRINT_DIFF ( TS_HTTP_STATUS_NOT_MODIFIED ) ;\n PRINT_DIFF ( TS_HTTP_STATUS_USE_PROXY ) ;\n PRINT_DIFF ( TS_HTTP_STATUS_BAD_REQUEST ) ;\n PRINT_DIFF ( TS_HTTP_STATUS_UNAUTHORIZED ) ;\n PRINT_DIFF ( TS_HTTP_STATUS_FORBIDDEN ) ;\n PRINT_DIFF ( TS_HTTP_STATUS_NOT_FOUND ) ;\n PRINT_DIFF ( TS_HTTP_STATUS_METHOD_NOT_ALLOWED ) ;\n PRINT_DIFF ( TS_HTTP_STATUS_NOT_ACCEPTABLE ) ;\n PRINT_DIFF ( TS_HTTP_STATUS_PROXY_AUTHENTICATION_REQUIRED ) ;\n PRINT_DIFF ( TS_HTTP_STATUS_REQUEST_TIMEOUT ) ;\n PRINT_DIFF ( TS_HTTP_STATUS_CONFLICT ) ;\n PRINT_DIFF ( TS_HTTP_STATUS_GONE ) ;\n PRINT_DIFF ( TS_HTTP_STATUS_PRECONDITION_FAILED ) ;\n PRINT_DIFF ( TS_HTTP_STATUS_REQUEST_ENTITY_TOO_LARGE ) ;\n PRINT_DIFF ( TS_HTTP_STATUS_REQUEST_URI_TOO_LONG ) ;\n PRINT_DIFF ( TS_HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE ) ;\n PRINT_DIFF ( TS_HTTP_STATUS_INTERNAL_SERVER_ERROR ) ;\n PRINT_DIFF ( TS_HTTP_STATUS_NOT_IMPLEMENTED ) ;\n PRINT_DIFF ( TS_HTTP_STATUS_BAD_GATEWAY ) ;\n PRINT_DIFF ( TS_HTTP_STATUS_GATEWAY_TIMEOUT ) ;\n PRINT_DIFF ( TS_HTTP_STATUS_HTTPVER_NOT_SUPPORTED ) ;\n PRINT_DIFF ( TS_HTTP_READ_REQUEST_HDR_HOOK ) ;\n PRINT_DIFF ( TS_HTTP_OS_DNS_HOOK ) ;\n PRINT_DIFF ( TS_HTTP_SEND_REQUEST_HDR_HOOK ) ;\n PRINT_DIFF ( TS_HTTP_READ_RESPONSE_HDR_HOOK ) ;\n PRINT_DIFF ( TS_HTTP_SEND_RESPONSE_HDR_HOOK ) ;\n PRINT_DIFF ( TS_HTTP_REQUEST_TRANSFORM_HOOK ) ;\n PRINT_DIFF ( TS_HTTP_RESPONSE_TRANSFORM_HOOK ) ;\n PRINT_DIFF ( TS_HTTP_SELECT_ALT_HOOK ) ;\n PRINT_DIFF ( TS_HTTP_TXN_START_HOOK ) ;\n PRINT_DIFF ( TS_HTTP_TXN_CLOSE_HOOK ) ;\n PRINT_DIFF ( TS_HTTP_SSN_START_HOOK ) ;\n PRINT_DIFF ( TS_HTTP_SSN_CLOSE_HOOK ) ;\n PRINT_DIFF ( TS_HTTP_CACHE_LOOKUP_COMPLETE_HOOK ) ;\n PRINT_DIFF ( TS_HTTP_LAST_HOOK ) ;\n PRINT_DIFF ( TS_EVENT_NONE ) ;\n PRINT_DIFF ( TS_EVENT_IMMEDIATE ) ;\n PRINT_DIFF ( TS_EVENT_TIMEOUT ) ;\n PRINT_DIFF ( TS_EVENT_ERROR ) ;\n PRINT_DIFF ( TS_EVENT_CONTINUE ) ;\n PRINT_DIFF ( TS_EVENT_VCONN_READ_READY ) ;\n PRINT_DIFF ( TS_EVENT_VCONN_WRITE_READY ) ;\n PRINT_DIFF ( TS_EVENT_VCONN_READ_COMPLETE ) ;\n PRINT_DIFF ( TS_EVENT_VCONN_WRITE_COMPLETE ) ;\n PRINT_DIFF ( TS_EVENT_VCONN_EOS ) ;\n PRINT_DIFF ( TS_EVENT_NET_CONNECT ) ;\n PRINT_DIFF ( TS_EVENT_NET_CONNECT_FAILED ) ;\n PRINT_DIFF ( TS_EVENT_NET_ACCEPT ) ;\n PRINT_DIFF ( TS_EVENT_NET_ACCEPT_FAILED ) ;\n PRINT_DIFF ( TS_EVENT_HOST_LOOKUP ) ;\n PRINT_DIFF ( TS_EVENT_CACHE_OPEN_READ ) ;\n PRINT_DIFF ( TS_EVENT_CACHE_OPEN_READ_FAILED ) ;\n PRINT_DIFF ( TS_EVENT_CACHE_OPEN_WRITE ) ;\n PRINT_DIFF ( TS_EVENT_CACHE_OPEN_WRITE_FAILED ) ;\n PRINT_DIFF ( TS_EVENT_CACHE_REMOVE ) ;\n PRINT_DIFF ( TS_EVENT_CACHE_REMOVE_FAILED ) ;\n PRINT_DIFF ( TS_EVENT_CACHE_SCAN ) ;\n PRINT_DIFF ( TS_EVENT_CACHE_SCAN_FAILED ) ;\n PRINT_DIFF ( TS_EVENT_CACHE_SCAN_OBJECT ) ;\n PRINT_DIFF ( TS_EVENT_CACHE_SCAN_OPERATION_BLOCKED ) ;\n PRINT_DIFF ( TS_EVENT_CACHE_SCAN_OPERATION_FAILED ) ;\n PRINT_DIFF ( TS_EVENT_CACHE_SCAN_DONE ) ;\n PRINT_DIFF ( TS_EVENT_HTTP_CONTINUE ) ;\n PRINT_DIFF ( TS_EVENT_HTTP_ERROR ) ;\n PRINT_DIFF ( TS_EVENT_HTTP_READ_REQUEST_HDR ) ;\n PRINT_DIFF ( TS_EVENT_HTTP_OS_DNS ) ;\n PRINT_DIFF ( TS_EVENT_HTTP_SEND_REQUEST_HDR ) ;\n PRINT_DIFF ( TS_EVENT_HTTP_READ_CACHE_HDR ) ;\n PRINT_DIFF ( TS_EVENT_HTTP_READ_RESPONSE_HDR ) ;\n PRINT_DIFF ( TS_EVENT_HTTP_SEND_RESPONSE_HDR ) ;\n PRINT_DIFF ( TS_EVENT_HTTP_REQUEST_TRANSFORM ) ;\n PRINT_DIFF ( TS_EVENT_HTTP_RESPONSE_TRANSFORM ) ;\n PRINT_DIFF ( TS_EVENT_HTTP_SELECT_ALT ) ;\n PRINT_DIFF ( TS_EVENT_HTTP_TXN_START ) ;\n PRINT_DIFF ( TS_EVENT_HTTP_TXN_CLOSE ) ;\n PRINT_DIFF ( TS_EVENT_HTTP_SSN_START ) ;\n PRINT_DIFF ( TS_EVENT_HTTP_SSN_CLOSE ) ;\n PRINT_DIFF ( TS_EVENT_HTTP_CACHE_LOOKUP_COMPLETE ) ;\n PRINT_DIFF ( TS_EVENT_MGMT_UPDATE ) ;\n PRINT_DIFF ( TS_CACHE_LOOKUP_MISS ) ;\n PRINT_DIFF ( TS_CACHE_LOOKUP_HIT_STALE ) ;\n PRINT_DIFF ( TS_CACHE_LOOKUP_HIT_FRESH ) ;\n PRINT_DIFF ( TS_CACHE_DATA_TYPE_NONE ) ;\n PRINT_DIFF ( TS_CACHE_DATA_TYPE_HTTP ) ;\n PRINT_DIFF ( TS_CACHE_DATA_TYPE_OTHER ) ;\n PRINT_DIFF ( TS_CACHE_ERROR_NO_DOC ) ;\n PRINT_DIFF ( TS_CACHE_ERROR_DOC_BUSY ) ;\n PRINT_DIFF ( TS_CACHE_ERROR_NOT_READY ) ;\n PRINT_DIFF ( TS_CACHE_SCAN_RESULT_DONE ) ;\n PRINT_DIFF ( TS_CACHE_SCAN_RESULT_CONTINUE ) ;\n PRINT_DIFF ( TS_CACHE_SCAN_RESULT_DELETE ) ;\n PRINT_DIFF ( TS_CACHE_SCAN_RESULT_DELETE_ALL_ALTERNATES ) ;\n PRINT_DIFF ( TS_CACHE_SCAN_RESULT_UPDATE ) ;\n PRINT_DIFF ( TS_CACHE_SCAN_RESULT_RETRY ) ;\n PRINT_DIFF ( TS_VC_CLOSE_ABORT ) ;\n PRINT_DIFF ( TS_VC_CLOSE_NORMAL ) ;\n PRINT_DIFF ( TS_ERROR ) ;\n PRINT_DIFF ( TS_SUCCESS ) ;\n if ( test_passed ) {\n * pstatus = REGRESSION_TEST_PASSED ;\n }\n else {\n * pstatus = REGRESSION_TEST_FAILED ;\n }\n }", "idx": 851}
{"hash": 252275190935145023, "project": "debian", "size": 7, "label": 0, "functionSource": "static void setup_plane_dequants ( VP9_COMMON * cm , MACROBLOCKD * xd , int q_index ) {\n int i ;\n xd -> plane [ 0 ] . dequant = cm -> y_dequant [ q_index ] ;\n for ( i = 1 ;\n i < MAX_MB_PLANE ;\n i ++ ) xd -> plane [ i ] . dequant = cm -> uv_dequant [ q_index ] ;\n }", "idx": 852}
{"hash": 6302861533225984845, "project": "debian", "size": 13, "label": 0, "functionSource": "static void pxa2xx_cm_write ( void * opaque , hwaddr addr , uint64_t value , unsigned size ) {\n PXA2xxState * s = ( PXA2xxState * ) opaque ;\n switch ( addr ) {\n case CCCR : case CKEN : s -> cm_regs [ addr >> 2 ] = value ;\n break ;\n case OSCC : s -> cm_regs [ addr >> 2 ] &= ~ 0x6c ;\n s -> cm_regs [ addr >> 2 ] |= value & 0x6e ;\n if ( ( value >> 1 ) & 1 ) s -> cm_regs [ addr >> 2 ] |= 1 << 0 ;\n break ;\n default : printf ( \"%s: Bad register \" REG_FMT \"\\n\" , __FUNCTION__ , addr ) ;\n break ;\n }\n }", "idx": 853}
{"hash": 2388171415474875762, "project": "debian", "size": 17, "label": 0, "functionSource": "static void dissect_rsvp_style ( proto_item * ti , proto_tree * rsvp_object_tree , tvbuff_t * tvb , int offset , int obj_length , int rsvp_class _U_ , int type ) {\n int offset2 = offset + 4 ;\n switch ( type ) {\n case 1 : {\n guint32 style ;\n proto_tree_add_uint ( rsvp_object_tree , hf_rsvp_ctype , tvb , offset + 3 , 1 , type ) ;\n proto_tree_add_item ( rsvp_object_tree , hf_rsvp_style_flags , tvb , offset2 , 1 , ENC_BIG_ENDIAN ) ;\n style = tvb_get_ntoh24 ( tvb , offset2 + 1 ) ;\n proto_tree_add_item ( rsvp_object_tree , hf_rsvp_style_style , tvb , offset2 + 1 , 3 , ENC_BIG_ENDIAN ) ;\n proto_item_set_text ( ti , \"STYLE: %s (%d)\" , val_to_str_const ( style , style_vals , \"Unknown\" ) , style ) ;\n break ;\n }\n default : proto_tree_add_uint_format_value ( rsvp_object_tree , hf_rsvp_ctype , tvb , offset + 3 , 1 , type , \"Unknown (%u)\" , type ) ;\n proto_tree_add_item ( rsvp_object_tree , hf_rsvp_style_data , tvb , offset2 , obj_length - 4 , ENC_NA ) ;\n break ;\n }\n }", "idx": 854}
{"hash": 3599206110384554647, "project": "debian", "size": 48, "label": 0, "functionSource": "static ossl_inline t2 * sk_ ## t1 ## _delete_ptr ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return ( t2 * ) OPENSSL_sk_delete_ptr ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _push ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_push ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _unshift ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_unshift ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _pop ( STACK_OF ( t1 ) * sk ) {\n return ( t2 * ) OPENSSL_sk_pop ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _shift ( STACK_OF ( t1 ) * sk ) {\n return ( t2 * ) OPENSSL_sk_shift ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline void sk_ ## t1 ## _pop_free ( STACK_OF ( t1 ) * sk , sk_ ## t1 ## _freefunc freefunc ) {\n OPENSSL_sk_pop_free ( ( OPENSSL_STACK * ) sk , ( OPENSSL_sk_freefunc ) freefunc ) ;\n }\n static ossl_inline int sk_ ## t1 ## _insert ( STACK_OF ( t1 ) * sk , t2 * ptr , int idx ) {\n return OPENSSL_sk_insert ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr , idx ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _set ( STACK_OF ( t1 ) * sk , int idx , t2 * ptr ) {\n return ( t2 * ) OPENSSL_sk_set ( ( OPENSSL_STACK * ) sk , idx , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _find ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_find ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _find_ex ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_find_ex ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline void sk_ ## t1 ## _sort ( STACK_OF ( t1 ) * sk ) {\n OPENSSL_sk_sort ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline int sk_ ## t1 ## _is_sorted ( const STACK_OF ( t1 ) * sk ) {\n return OPENSSL_sk_is_sorted ( ( const OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _dup ( const STACK_OF ( t1 ) * sk ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_dup ( ( const OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _deep_copy ( const STACK_OF ( t1 ) * sk , sk_ ## t1 ## _copyfunc copyfunc , sk_ ## t1 ## _freefunc freefunc ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_deep_copy ( ( const OPENSSL_STACK * ) sk , ( OPENSSL_sk_copyfunc ) copyfunc , ( OPENSSL_sk_freefunc ) freefunc ) ;\n }\n static ossl_inline sk_ ## t1 ## _compfunc sk_ ## t1 ## _set_cmp_func ( STACK_OF ( t1 ) * sk , sk_ ## t1 ## _compfunc compare ) {\n return ( sk_ ## t1 ## _compfunc ) OPENSSL_sk_set_cmp_func ( ( OPENSSL_STACK * ) sk , ( OPENSSL_sk_compfunc ) compare ) ;\n }\n # define DEFINE_SPECIAL_STACK_OF ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , t2 , t2 ) # define DEFINE_STACK_OF ( t ) SKM_DEFINE_STACK_OF ( t , t , t ) # define DEFINE_SPECIAL_STACK_OF_CONST ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , const t2 , t2 ) # define DEFINE_STACK_OF_CONST ( t ) SKM_DEFINE_STACK_OF ( t , const t , t ) typedef char * OPENSSL_STRING ;\n typedef const char * OPENSSL_CSTRING ;\n DEFINE_SPECIAL_STACK_OF ( OPENSSL_STRING , char ) DEFINE_SPECIAL_STACK_OF_CONST ( OPENSSL_CSTRING , char )", "idx": 855}
{"hash": -4596135714614925483, "project": "debian", "size": 5, "label": 0, "functionSource": "static char * timelib_string ( Scanner * s ) {\n char * tmp = calloc ( 1 , s -> cur - s -> tok + 1 ) ;\n memcpy ( tmp , s -> tok , s -> cur - s -> tok ) ;\n return tmp ;\n }", "idx": 856}
{"hash": -7888349587538303571, "project": "debian", "size": 10, "label": 0, "functionSource": "static int rawv6_setsockopt ( struct sock * sk , int level , int optname , char __user * optval , unsigned int optlen ) {\n switch ( level ) {\n case SOL_RAW : break ;\n case SOL_ICMPV6 : if ( inet_sk ( sk ) -> inet_num != IPPROTO_ICMPV6 ) return - EOPNOTSUPP ;\n return rawv6_seticmpfilter ( sk , level , optname , optval , optlen ) ;\n case SOL_IPV6 : if ( optname == IPV6_CHECKSUM ) break ;\n default : return ipv6_setsockopt ( sk , level , optname , optval , optlen ) ;\n }\n return do_rawv6_setsockopt ( sk , level , optname , optval , optlen ) ;\n }", "idx": 857}
{"hash": 4715922168896528064, "project": "debian", "size": 101, "label": 0, "functionSource": "void jpc_ft_fwdlift_colres ( jpc_fix_t * a , int numrows , int numcols , int stride , int parity ) {\n jpc_fix_t * lptr ;\n jpc_fix_t * hptr ;\n register jpc_fix_t * lptr2 ;\n register jpc_fix_t * hptr2 ;\n register int n ;\n register int i ;\n int llen ;\n llen = ( numrows + 1 - parity ) >> 1 ;\n if ( numrows > 1 ) {\n lptr = & a [ 0 ] ;\n hptr = & a [ llen * stride ] ;\n if ( parity ) {\n lptr2 = lptr ;\n hptr2 = hptr ;\n for ( i = 0 ;\n i < numcols ;\n ++ i ) {\n hptr2 [ 0 ] -= lptr2 [ 0 ] ;\n ++ hptr2 ;\n ++ lptr2 ;\n }\n hptr += stride ;\n }\n n = numrows - llen - parity - ( parity == ( numrows & 1 ) ) ;\n while ( n -- > 0 ) {\n lptr2 = lptr ;\n hptr2 = hptr ;\n for ( i = 0 ;\n i < numcols ;\n ++ i ) {\n hptr2 [ 0 ] -= jpc_fix_asr ( lptr2 [ 0 ] + lptr2 [ stride ] , 1 ) ;\n ++ lptr2 ;\n ++ hptr2 ;\n }\n hptr += stride ;\n lptr += stride ;\n }\n if ( parity == ( numrows & 1 ) ) {\n lptr2 = lptr ;\n hptr2 = hptr ;\n for ( i = 0 ;\n i < numcols ;\n ++ i ) {\n hptr2 [ 0 ] -= lptr2 [ 0 ] ;\n ++ lptr2 ;\n ++ hptr2 ;\n }\n }\n lptr = & a [ 0 ] ;\n hptr = & a [ llen * stride ] ;\n if ( ! parity ) {\n lptr2 = lptr ;\n hptr2 = hptr ;\n for ( i = 0 ;\n i < numcols ;\n ++ i ) {\n lptr2 [ 0 ] += jpc_fix_asr ( hptr2 [ 0 ] + 1 , 1 ) ;\n ++ lptr2 ;\n ++ hptr2 ;\n }\n lptr += stride ;\n }\n n = llen - ( ! parity ) - ( parity != ( numrows & 1 ) ) ;\n while ( n -- > 0 ) {\n lptr2 = lptr ;\n hptr2 = hptr ;\n for ( i = 0 ;\n i < numcols ;\n ++ i ) {\n lptr2 [ 0 ] += jpc_fix_asr ( hptr2 [ 0 ] + hptr2 [ stride ] + 2 , 2 ) ;\n ++ lptr2 ;\n ++ hptr2 ;\n }\n lptr += stride ;\n hptr += stride ;\n }\n if ( parity != ( numrows & 1 ) ) {\n lptr2 = lptr ;\n hptr2 = hptr ;\n for ( i = 0 ;\n i < numcols ;\n ++ i ) {\n lptr2 [ 0 ] += jpc_fix_asr ( hptr2 [ 0 ] + 1 , 1 ) ;\n ++ lptr2 ;\n ++ hptr2 ;\n }\n }\n }\n else {\n if ( parity ) {\n lptr2 = & a [ 0 ] ;\n for ( i = 0 ;\n i < numcols ;\n ++ i ) {\n lptr2 [ 0 ] = jpc_fix_asl ( lptr2 [ 0 ] , 1 ) ;\n ++ lptr2 ;\n }\n }\n }\n }", "idx": 858}
{"hash": 3246343243711264189, "project": "debian", "size": 17, "label": 1, "functionSource": "static int check_user_and_ip ( int userid , struct query * q ) {\n struct sockaddr_in * tempin ;\n if ( userid < 0 || userid >= created_users ) {\n return 1 ;\n }\n if ( ! users [ userid ] . active || users [ userid ] . disabled ) {\n return 1 ;\n }\n if ( users [ userid ] . last_pkt + 60 < time ( NULL ) ) {\n return 1 ;\n }\n if ( ! check_ip ) {\n return 0 ;\n }\n tempin = ( struct sockaddr_in * ) & ( q -> from ) ;\n return memcmp ( & ( users [ userid ] . host ) , & ( tempin -> sin_addr ) , sizeof ( struct in_addr ) ) ;\n }", "idx": 859}
{"hash": 1883395483360648063, "project": "chrome", "size": 4, "label": 0, "functionSource": "TEST ( DownloadPrefsTest , Prerequisites ) {\n ASSERT_FALSE ( FileTypePolicies : : GetInstance ( ) -> IsAllowedToOpenAutomatically ( base : : FilePath ( FILE_PATH_LITERAL ( \"a.swf\" ) ) ) ) ;\n ASSERT_TRUE ( FileTypePolicies : : GetInstance ( ) -> IsAllowedToOpenAutomatically ( base : : FilePath ( FILE_PATH_LITERAL ( \"a.txt\" ) ) ) ) ;\n }", "idx": 860}
{"hash": 3919353496513339611, "project": "chrome", "size": 24, "label": 0, "functionSource": "static FT_Error t42_load_keyword ( T42_Face face , T42_Loader loader , T1_Field field ) {\n FT_Error error ;\n void * dummy_object ;\n void * * objects ;\n FT_UInt max_objects = 0 ;\n if ( field -> type == T1_FIELD_TYPE_CALLBACK ) {\n field -> reader ( ( FT_Face ) face , loader ) ;\n error = loader -> parser . root . error ;\n goto Exit ;\n }\n switch ( field -> location ) {\n case T1_FIELD_LOCATION_FONT_INFO : dummy_object = & face -> type1 . font_info ;\n break ;\n case T1_FIELD_LOCATION_FONT_EXTRA : dummy_object = & face -> type1 . font_extra ;\n break ;\n case T1_FIELD_LOCATION_BBOX : dummy_object = & face -> type1 . font_bbox ;\n break ;\n default : dummy_object = & face -> type1 ;\n }\n objects = & dummy_object ;\n if ( field -> type == T1_FIELD_TYPE_INTEGER_ARRAY || field -> type == T1_FIELD_TYPE_FIXED_ARRAY ) error = T1_Load_Field_Table ( & loader -> parser , field , objects , max_objects , 0 ) ;\n else error = T1_Load_Field ( & loader -> parser , field , objects , max_objects , 0 ) ;\n Exit : return error ;\n }", "idx": 861}
{"hash": 2820551931453396101, "project": "debian", "size": 17, "label": 0, "functionSource": "int jas_image_fmtfromname ( char * name ) {\n int i ;\n char * ext ;\n jas_image_fmtinfo_t * fmtinfo ;\n if ( ! ( ext = strrchr ( name , '.' ) ) ) {\n return - 1 ;\n }\n ++ ext ;\n for ( i = 0 , fmtinfo = jas_image_fmtinfos ;\n i < jas_image_numfmts ;\n ++ i , ++ fmtinfo ) {\n if ( ! strcmp ( ext , fmtinfo -> ext ) ) {\n return fmtinfo -> id ;\n }\n }\n return - 1 ;\n }", "idx": 862}
{"hash": 1414661670117003749, "project": "debian", "size": 46, "label": 0, "functionSource": "int prepare_bitmap_walk ( struct rev_info * revs ) {\n unsigned int i ;\n unsigned int pending_nr = revs -> pending . nr ;\n struct object_array_entry * pending_e = revs -> pending . objects ;\n struct object_list * wants = NULL ;\n struct object_list * haves = NULL ;\n struct bitmap * wants_bitmap = NULL ;\n struct bitmap * haves_bitmap = NULL ;\n if ( ! bitmap_git . loaded ) {\n if ( open_pack_bitmap ( ) < 0 ) return - 1 ;\n }\n for ( i = 0 ;\n i < pending_nr ;\n ++ i ) {\n struct object * object = pending_e [ i ] . item ;\n if ( object -> type == OBJ_NONE ) parse_object_or_die ( object -> oid . hash , NULL ) ;\n while ( object -> type == OBJ_TAG ) {\n struct tag * tag = ( struct tag * ) object ;\n if ( object -> flags & UNINTERESTING ) object_list_insert ( object , & haves ) ;\n else object_list_insert ( object , & wants ) ;\n if ( ! tag -> tagged ) die ( \"bad tag\" ) ;\n object = parse_object_or_die ( tag -> tagged -> oid . hash , NULL ) ;\n }\n if ( object -> flags & UNINTERESTING ) object_list_insert ( object , & haves ) ;\n else object_list_insert ( object , & wants ) ;\n }\n if ( haves && ! in_bitmapped_pack ( haves ) ) return - 1 ;\n if ( ! wants ) return - 1 ;\n if ( ! bitmap_git . loaded && load_pack_bitmap ( ) < 0 ) return - 1 ;\n revs -> pending . nr = 0 ;\n revs -> pending . alloc = 0 ;\n revs -> pending . objects = NULL ;\n if ( haves ) {\n revs -> ignore_missing_links = 1 ;\n haves_bitmap = find_objects ( revs , haves , NULL ) ;\n reset_revision_walk ( ) ;\n revs -> ignore_missing_links = 0 ;\n if ( haves_bitmap == NULL ) die ( \"BUG: failed to perform bitmap walk\" ) ;\n }\n wants_bitmap = find_objects ( revs , wants , haves_bitmap ) ;\n if ( ! wants_bitmap ) die ( \"BUG: failed to perform bitmap walk\" ) ;\n if ( haves_bitmap ) bitmap_and_not ( wants_bitmap , haves_bitmap ) ;\n bitmap_git . result = wants_bitmap ;\n bitmap_free ( haves_bitmap ) ;\n return 0 ;\n }", "idx": 863}
{"hash": 6511303611138191176, "project": "debian", "size": 13, "label": 0, "functionSource": "int ff_wmv2_decode_picture_header ( MpegEncContext * s ) {\n Wmv2Context * const w = ( Wmv2Context * ) s ;\n int code ;\n if ( s -> picture_number == 0 ) decode_ext_header ( w ) ;\n s -> pict_type = get_bits1 ( & s -> gb ) + 1 ;\n if ( s -> pict_type == AV_PICTURE_TYPE_I ) {\n code = get_bits ( & s -> gb , 7 ) ;\n av_log ( s -> avctx , AV_LOG_DEBUG , \"I7:%X/\\n\" , code ) ;\n }\n s -> chroma_qscale = s -> qscale = get_bits ( & s -> gb , 5 ) ;\n if ( s -> qscale <= 0 ) return - 1 ;\n return 0 ;\n }", "idx": 864}
{"hash": 6302861533225984845, "project": "debian", "size": 63, "label": 0, "functionSource": "static void pxa2xx_rtc_write ( void * opaque , hwaddr addr , uint64_t value64 , unsigned size ) {\n PXA2xxRTCState * s = ( PXA2xxRTCState * ) opaque ;\n uint32_t value = value64 ;\n switch ( addr ) {\n case RTTR : if ( ! ( s -> rttr & ( 1 << 31 ) ) ) {\n pxa2xx_rtc_hzupdate ( s ) ;\n s -> rttr = value ;\n pxa2xx_rtc_alarm_update ( s , s -> rtsr ) ;\n }\n break ;\n case RTSR : if ( ( s -> rtsr ^ value ) & ( 1 << 15 ) ) pxa2xx_rtc_piupdate ( s ) ;\n if ( ( s -> rtsr ^ value ) & ( 1 << 12 ) ) pxa2xx_rtc_swupdate ( s ) ;\n if ( ( ( s -> rtsr ^ value ) & 0x4aac ) | ( value & ~ 0xdaac ) ) pxa2xx_rtc_alarm_update ( s , value ) ;\n s -> rtsr = ( value & 0xdaac ) | ( s -> rtsr & ~ ( value & ~ 0xdaac ) ) ;\n pxa2xx_rtc_int_update ( s ) ;\n break ;\n case RTAR : s -> rtar = value ;\n pxa2xx_rtc_alarm_update ( s , s -> rtsr ) ;\n break ;\n case RDAR1 : s -> rdar1 = value ;\n pxa2xx_rtc_alarm_update ( s , s -> rtsr ) ;\n break ;\n case RDAR2 : s -> rdar2 = value ;\n pxa2xx_rtc_alarm_update ( s , s -> rtsr ) ;\n break ;\n case RYAR1 : s -> ryar1 = value ;\n pxa2xx_rtc_alarm_update ( s , s -> rtsr ) ;\n break ;\n case RYAR2 : s -> ryar2 = value ;\n pxa2xx_rtc_alarm_update ( s , s -> rtsr ) ;\n break ;\n case SWAR1 : pxa2xx_rtc_swupdate ( s ) ;\n s -> swar1 = value ;\n s -> last_swcr = 0 ;\n pxa2xx_rtc_alarm_update ( s , s -> rtsr ) ;\n break ;\n case SWAR2 : s -> swar2 = value ;\n pxa2xx_rtc_alarm_update ( s , s -> rtsr ) ;\n break ;\n case PIAR : s -> piar = value ;\n pxa2xx_rtc_alarm_update ( s , s -> rtsr ) ;\n break ;\n case RCNR : pxa2xx_rtc_hzupdate ( s ) ;\n s -> last_rcnr = value ;\n pxa2xx_rtc_alarm_update ( s , s -> rtsr ) ;\n break ;\n case RDCR : pxa2xx_rtc_hzupdate ( s ) ;\n s -> last_rdcr = value ;\n pxa2xx_rtc_alarm_update ( s , s -> rtsr ) ;\n break ;\n case RYCR : s -> last_rycr = value ;\n break ;\n case SWCR : pxa2xx_rtc_swupdate ( s ) ;\n s -> last_swcr = value ;\n pxa2xx_rtc_alarm_update ( s , s -> rtsr ) ;\n break ;\n case RTCPICR : pxa2xx_rtc_piupdate ( s ) ;\n s -> last_rtcpicr = value & 0xffff ;\n pxa2xx_rtc_alarm_update ( s , s -> rtsr ) ;\n break ;\n default : printf ( \"%s: Bad register \" REG_FMT \"\\n\" , __FUNCTION__ , addr ) ;\n }\n }", "idx": 865}
{"hash": 583170025160259883, "project": "debian", "size": 20, "label": 0, "functionSource": "static const char * * slirp_dnssearch ( const StringList * dnsname ) {\n const StringList * c = dnsname ;\n size_t i = 0 , num_opts = 0 ;\n const char * * ret ;\n while ( c ) {\n num_opts ++ ;\n c = c -> next ;\n }\n if ( num_opts == 0 ) {\n return NULL ;\n }\n ret = g_malloc ( ( num_opts + 1 ) * sizeof ( * ret ) ) ;\n c = dnsname ;\n while ( c ) {\n ret [ i ++ ] = c -> value -> str ;\n c = c -> next ;\n }\n ret [ i ] = NULL ;\n return ret ;\n }", "idx": 866}
{"hash": 7092216800726729686, "project": "debian", "size": 5, "label": 0, "functionSource": "static int dissect_h245_MasterSlaveDeterminationAck ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_MasterSlaveDeterminationAck , MasterSlaveDeterminationAck_sequence ) ;\n # line 530 \"../../asn1/h245/h245.cnf\" if ( h245_pi != NULL ) h245_pi -> msg_type = H245_MastSlvDetAck ;\n return offset ;\n }", "idx": 867}
{"hash": 3919646340804521652, "project": "debian", "size": 10, "label": 0, "functionSource": "static int get_object_list_from_bitmap ( struct rev_info * revs ) {\n if ( prepare_bitmap_walk ( revs ) < 0 ) return - 1 ;\n if ( pack_options_allow_reuse ( ) && ! reuse_partial_packfile_from_bitmap ( & reuse_packfile , & reuse_packfile_objects , & reuse_packfile_offset ) ) {\n assert ( reuse_packfile_objects ) ;\n nr_result += reuse_packfile_objects ;\n display_progress ( progress_state , nr_result ) ;\n }\n traverse_bitmap_commit_list ( & add_object_entry_from_bitmap ) ;\n return 0 ;\n }", "idx": 868}
{"hash": 6458694302493204858, "project": "debian", "size": 8, "label": 0, "functionSource": "static void ShutdownFuncExpr ( Datum arg ) {\n FuncExprState * fcache = ( FuncExprState * ) DatumGetPointer ( arg ) ;\n if ( fcache -> funcResultSlot ) ExecClearTuple ( fcache -> funcResultSlot ) ;\n if ( fcache -> funcResultStore ) tuplestore_end ( fcache -> funcResultStore ) ;\n fcache -> funcResultStore = NULL ;\n fcache -> setArgsValid = false ;\n fcache -> shutdown_reg = false ;\n }", "idx": 869}
{"hash": -1487877838474751244, "project": "debian", "size": 24, "label": 0, "functionSource": "static int getSingletonPos ( const char * str ) {\n int result = - 1 ;\n int i = 0 ;\n int len = 0 ;\n if ( str && ( ( len = strlen ( str ) ) > 0 ) ) {\n for ( i = 0 ;\n i < len ;\n i ++ ) {\n if ( isIDSeparator ( * ( str + i ) ) ) {\n if ( i == 1 ) {\n result = 0 ;\n break ;\n }\n else {\n if ( isIDSeparator ( * ( str + i + 2 ) ) ) {\n result = i + 1 ;\n break ;\n }\n }\n }\n }\n }\n return result ;\n }", "idx": 870}
{"hash": 330507736709312787, "project": "chrome", "size": 4, "label": 0, "functionSource": "gr_face * hb_graphite2_face_get_gr_face ( hb_face_t * face ) {\n if ( unlikely ( ! hb_graphite2_shaper_face_data_ensure ( face ) ) ) return NULL ;\n return HB_SHAPER_DATA_GET ( face ) -> grface ;\n }", "idx": 871}
{"hash": 8637588907624249958, "project": "debian", "size": 7, "label": 0, "functionSource": "static void mark_this_frame_as_last_pmns_names_frame ( packet_info * pinfo ) {\n pcp_conv_info_t * pcp_conv_info ;\n pcp_conv_info = get_pcp_conversation_info ( pinfo ) ;\n if ( pinfo -> num > pcp_conv_info -> last_pmns_names_frame ) {\n pcp_conv_info -> last_pmns_names_frame = pinfo -> num ;\n }\n }", "idx": 872}
{"hash": 3944119518966250431, "project": "debian", "size": 39, "label": 1, "functionSource": "enum nss_status _nss_nis_getaliasbyname_r ( const char * name , struct aliasent * alias , char * buffer , size_t buflen , int * errnop ) {\n if ( name == NULL ) {\n * errnop = EINVAL ;\n return NSS_STATUS_UNAVAIL ;\n }\n size_t namlen = strlen ( name ) ;\n char name2 [ namlen + 1 ] ;\n char * domain ;\n if ( __builtin_expect ( yp_get_default_domain ( & domain ) , 0 ) ) return NSS_STATUS_UNAVAIL ;\n size_t i ;\n for ( i = 0 ;\n i < namlen ;\n ++ i ) name2 [ i ] = _tolower ( name [ i ] ) ;\n name2 [ i ] = '\\0' ;\n char * result ;\n int len ;\n int yperr = yp_match ( domain , \"mail.aliases\" , name2 , namlen , & result , & len ) ;\n if ( __builtin_expect ( yperr != YPERR_SUCCESS , 0 ) ) {\n enum nss_status retval = yperr2nss ( yperr ) ;\n if ( retval == NSS_STATUS_TRYAGAIN ) * errnop = errno ;\n return retval ;\n }\n if ( __builtin_expect ( ( size_t ) ( len + 1 ) > buflen , 0 ) ) {\n free ( result ) ;\n * errnop = ERANGE ;\n return NSS_STATUS_TRYAGAIN ;\n }\n char * p = strncpy ( buffer , result , len ) ;\n buffer [ len ] = '\\0' ;\n while ( isspace ( * p ) ) ++ p ;\n free ( result ) ;\n alias -> alias_local = 0 ;\n int parse_res = _nss_nis_parse_aliasent ( name , p , alias , buffer , buflen , errnop ) ;\n if ( __builtin_expect ( parse_res < 1 , 0 ) ) {\n if ( parse_res == - 1 ) return NSS_STATUS_TRYAGAIN ;\n else return NSS_STATUS_NOTFOUND ;\n }\n return NSS_STATUS_SUCCESS ;\n }", "idx": 873}
{"hash": -4552633429382740307, "project": "debian", "size": 11, "label": 0, "functionSource": "void # ifdef M_DEBUG mpi_debug_free ( MPI a , const char * info ) # else mpi_free ( MPI a ) # endif {\n if ( ! a ) return ;\n if ( DBG_MEMORY ) log_debug ( \"mpi_free\\n\" ) ;\n if ( a -> flags & 4 ) xfree ( a -> d ) ;\n else {\n # ifdef M_DEBUG mpi_debug_free_limb_space ( a -> d , info ) ;\n # else mpi_free_limb_space ( a -> d ) ;\n # endif }\n if ( a -> flags & ~ 7 ) log_bug ( \"invalid flag value in mpi\\n\" ) ;\n xfree ( a ) ;\n }", "idx": 874}
{"hash": 2218137424821696593, "project": "debian", "size": 127, "label": 0, "functionSource": "void ff_xvmc_decode_mb ( MpegEncContext * s ) {\n XvMCMacroBlock * mv_block ;\n struct xvmc_pix_fmt * render ;\n int i , cbp , blocks_per_mb ;\n const int mb_xy = s -> mb_y * s -> mb_stride + s -> mb_x ;\n if ( s -> encoding ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"XVMC doesn't support encoding!!!\\n\" ) ;\n return ;\n }\n if ( ! s -> mb_intra ) {\n s -> last_dc [ 0 ] = s -> last_dc [ 1 ] = s -> last_dc [ 2 ] = 128 << s -> intra_dc_precision ;\n }\n s -> mb_skipped = 0 ;\n s -> current_picture . qscale_table [ mb_xy ] = s -> qscale ;\n render = ( struct xvmc_pix_fmt * ) s -> current_picture . f . data [ 2 ] ;\n assert ( render ) ;\n assert ( render -> xvmc_id == AV_XVMC_ID ) ;\n assert ( render -> mv_blocks ) ;\n mv_block = & render -> mv_blocks [ render -> start_mv_blocks_num + render -> filled_mv_blocks_num ] ;\n mv_block -> x = s -> mb_x ;\n mv_block -> y = s -> mb_y ;\n mv_block -> dct_type = s -> interlaced_dct ;\n if ( s -> mb_intra ) {\n mv_block -> macroblock_type = XVMC_MB_TYPE_INTRA ;\n }\n else {\n mv_block -> macroblock_type = XVMC_MB_TYPE_PATTERN ;\n if ( s -> mv_dir & MV_DIR_FORWARD ) {\n mv_block -> macroblock_type |= XVMC_MB_TYPE_MOTION_FORWARD ;\n mv_block -> PMV [ 0 ] [ 0 ] [ 0 ] = s -> mv [ 0 ] [ 0 ] [ 0 ] ;\n mv_block -> PMV [ 0 ] [ 0 ] [ 1 ] = s -> mv [ 0 ] [ 0 ] [ 1 ] ;\n mv_block -> PMV [ 1 ] [ 0 ] [ 0 ] = s -> mv [ 0 ] [ 1 ] [ 0 ] ;\n mv_block -> PMV [ 1 ] [ 0 ] [ 1 ] = s -> mv [ 0 ] [ 1 ] [ 1 ] ;\n }\n if ( s -> mv_dir & MV_DIR_BACKWARD ) {\n mv_block -> macroblock_type |= XVMC_MB_TYPE_MOTION_BACKWARD ;\n mv_block -> PMV [ 0 ] [ 1 ] [ 0 ] = s -> mv [ 1 ] [ 0 ] [ 0 ] ;\n mv_block -> PMV [ 0 ] [ 1 ] [ 1 ] = s -> mv [ 1 ] [ 0 ] [ 1 ] ;\n mv_block -> PMV [ 1 ] [ 1 ] [ 0 ] = s -> mv [ 1 ] [ 1 ] [ 0 ] ;\n mv_block -> PMV [ 1 ] [ 1 ] [ 1 ] = s -> mv [ 1 ] [ 1 ] [ 1 ] ;\n }\n switch ( s -> mv_type ) {\n case MV_TYPE_16X16 : mv_block -> motion_type = XVMC_PREDICTION_FRAME ;\n break ;\n case MV_TYPE_16X8 : mv_block -> motion_type = XVMC_PREDICTION_16x8 ;\n break ;\n case MV_TYPE_FIELD : mv_block -> motion_type = XVMC_PREDICTION_FIELD ;\n if ( s -> picture_structure == PICT_FRAME ) {\n mv_block -> PMV [ 0 ] [ 0 ] [ 1 ] <<= 1 ;\n mv_block -> PMV [ 1 ] [ 0 ] [ 1 ] <<= 1 ;\n mv_block -> PMV [ 0 ] [ 1 ] [ 1 ] <<= 1 ;\n mv_block -> PMV [ 1 ] [ 1 ] [ 1 ] <<= 1 ;\n }\n break ;\n case MV_TYPE_DMV : mv_block -> motion_type = XVMC_PREDICTION_DUAL_PRIME ;\n if ( s -> picture_structure == PICT_FRAME ) {\n mv_block -> PMV [ 0 ] [ 0 ] [ 0 ] = s -> mv [ 0 ] [ 0 ] [ 0 ] ;\n mv_block -> PMV [ 0 ] [ 0 ] [ 1 ] = s -> mv [ 0 ] [ 0 ] [ 1 ] << 1 ;\n mv_block -> PMV [ 0 ] [ 1 ] [ 0 ] = s -> mv [ 0 ] [ 0 ] [ 0 ] ;\n mv_block -> PMV [ 0 ] [ 1 ] [ 1 ] = s -> mv [ 0 ] [ 0 ] [ 1 ] << 1 ;\n mv_block -> PMV [ 1 ] [ 0 ] [ 0 ] = s -> mv [ 0 ] [ 2 ] [ 0 ] ;\n mv_block -> PMV [ 1 ] [ 0 ] [ 1 ] = s -> mv [ 0 ] [ 2 ] [ 1 ] << 1 ;\n mv_block -> PMV [ 1 ] [ 1 ] [ 0 ] = s -> mv [ 0 ] [ 3 ] [ 0 ] ;\n mv_block -> PMV [ 1 ] [ 1 ] [ 1 ] = s -> mv [ 0 ] [ 3 ] [ 1 ] << 1 ;\n }\n else {\n mv_block -> PMV [ 0 ] [ 1 ] [ 0 ] = s -> mv [ 0 ] [ 2 ] [ 0 ] ;\n mv_block -> PMV [ 0 ] [ 1 ] [ 1 ] = s -> mv [ 0 ] [ 2 ] [ 1 ] ;\n }\n break ;\n default : assert ( 0 ) ;\n }\n mv_block -> motion_vertical_field_select = 0 ;\n if ( s -> mv_type == MV_TYPE_FIELD || s -> mv_type == MV_TYPE_16X8 ) {\n mv_block -> motion_vertical_field_select |= s -> field_select [ 0 ] [ 0 ] ;\n mv_block -> motion_vertical_field_select |= s -> field_select [ 1 ] [ 0 ] << 1 ;\n mv_block -> motion_vertical_field_select |= s -> field_select [ 0 ] [ 1 ] << 2 ;\n mv_block -> motion_vertical_field_select |= s -> field_select [ 1 ] [ 1 ] << 3 ;\n }\n }\n mv_block -> index = render -> next_free_data_block_num ;\n blocks_per_mb = 6 ;\n if ( s -> chroma_format >= 2 ) {\n blocks_per_mb = 4 + ( 1 << s -> chroma_format ) ;\n }\n cbp = 0 ;\n for ( i = 0 ;\n i < blocks_per_mb ;\n i ++ ) {\n cbp += cbp ;\n if ( s -> block_last_index [ i ] >= 0 ) cbp ++ ;\n }\n if ( s -> flags & CODEC_FLAG_GRAY ) {\n if ( s -> mb_intra ) {\n for ( i = 4 ;\n i < blocks_per_mb ;\n i ++ ) {\n memset ( s -> pblocks [ i ] , 0 , sizeof ( * s -> pblocks [ i ] ) ) ;\n if ( ! render -> unsigned_intra ) * s -> pblocks [ i ] [ 0 ] = 1 << 10 ;\n }\n }\n else {\n cbp &= 0xf << ( blocks_per_mb - 4 ) ;\n blocks_per_mb = 4 ;\n }\n }\n mv_block -> coded_block_pattern = cbp ;\n if ( cbp == 0 ) mv_block -> macroblock_type &= ~ XVMC_MB_TYPE_PATTERN ;\n for ( i = 0 ;\n i < blocks_per_mb ;\n i ++ ) {\n if ( s -> block_last_index [ i ] >= 0 ) {\n if ( s -> mb_intra && ( render -> idct || ! render -> unsigned_intra ) ) * s -> pblocks [ i ] [ 0 ] -= 1 << 10 ;\n if ( ! render -> idct ) {\n s -> dsp . idct ( * s -> pblocks [ i ] ) ;\n }\n if ( s -> avctx -> xvmc_acceleration == 1 ) {\n memcpy ( & render -> data_blocks [ render -> next_free_data_block_num * 64 ] , s -> pblocks [ i ] , sizeof ( * s -> pblocks [ i ] ) ) ;\n }\n render -> next_free_data_block_num ++ ;\n }\n }\n render -> filled_mv_blocks_num ++ ;\n assert ( render -> filled_mv_blocks_num <= render -> allocated_mv_blocks ) ;\n assert ( render -> next_free_data_block_num <= render -> allocated_data_blocks ) ;\n if ( render -> filled_mv_blocks_num == render -> allocated_mv_blocks ) ff_mpeg_draw_horiz_band ( s , 0 , 0 ) ;\n }", "idx": 875}
{"hash": 8801969307247112896, "project": "debian", "size": 57, "label": 0, "functionSource": "static int aes_init_key ( EVP_CIPHER_CTX * ctx , const unsigned char * key , const unsigned char * iv , int enc ) {\n int ret , mode ;\n EVP_AES_KEY * dat = EVP_C_DATA ( EVP_AES_KEY , ctx ) ;\n mode = EVP_CIPHER_CTX_mode ( ctx ) ;\n if ( ( mode == EVP_CIPH_ECB_MODE || mode == EVP_CIPH_CBC_MODE ) && ! enc ) {\n # ifdef HWAES_CAPABLE if ( HWAES_CAPABLE ) {\n ret = HWAES_set_decrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & dat -> ks . ks ) ;\n dat -> block = ( block128_f ) HWAES_decrypt ;\n dat -> stream . cbc = NULL ;\n # ifdef HWAES_cbc_encrypt if ( mode == EVP_CIPH_CBC_MODE ) dat -> stream . cbc = ( cbc128_f ) HWAES_cbc_encrypt ;\n # endif }\n else # endif # ifdef BSAES_CAPABLE if ( BSAES_CAPABLE && mode == EVP_CIPH_CBC_MODE ) {\n ret = AES_set_decrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & dat -> ks . ks ) ;\n dat -> block = ( block128_f ) AES_decrypt ;\n dat -> stream . cbc = ( cbc128_f ) bsaes_cbc_encrypt ;\n }\n else # endif # ifdef VPAES_CAPABLE if ( VPAES_CAPABLE ) {\n ret = vpaes_set_decrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & dat -> ks . ks ) ;\n dat -> block = ( block128_f ) vpaes_decrypt ;\n dat -> stream . cbc = mode == EVP_CIPH_CBC_MODE ? ( cbc128_f ) vpaes_cbc_encrypt : NULL ;\n }\n else # endif {\n ret = AES_set_decrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & dat -> ks . ks ) ;\n dat -> block = ( block128_f ) AES_decrypt ;\n dat -> stream . cbc = mode == EVP_CIPH_CBC_MODE ? ( cbc128_f ) AES_cbc_encrypt : NULL ;\n }\n }\n else # ifdef HWAES_CAPABLE if ( HWAES_CAPABLE ) {\n ret = HWAES_set_encrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & dat -> ks . ks ) ;\n dat -> block = ( block128_f ) HWAES_encrypt ;\n dat -> stream . cbc = NULL ;\n # ifdef HWAES_cbc_encrypt if ( mode == EVP_CIPH_CBC_MODE ) dat -> stream . cbc = ( cbc128_f ) HWAES_cbc_encrypt ;\n else # endif # ifdef HWAES_ctr32_encrypt_blocks if ( mode == EVP_CIPH_CTR_MODE ) dat -> stream . ctr = ( ctr128_f ) HWAES_ctr32_encrypt_blocks ;\n else # endif ( void ) 0 ;\n }\n else # endif # ifdef BSAES_CAPABLE if ( BSAES_CAPABLE && mode == EVP_CIPH_CTR_MODE ) {\n ret = AES_set_encrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & dat -> ks . ks ) ;\n dat -> block = ( block128_f ) AES_encrypt ;\n dat -> stream . ctr = ( ctr128_f ) bsaes_ctr32_encrypt_blocks ;\n }\n else # endif # ifdef VPAES_CAPABLE if ( VPAES_CAPABLE ) {\n ret = vpaes_set_encrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & dat -> ks . ks ) ;\n dat -> block = ( block128_f ) vpaes_encrypt ;\n dat -> stream . cbc = mode == EVP_CIPH_CBC_MODE ? ( cbc128_f ) vpaes_cbc_encrypt : NULL ;\n }\n else # endif {\n ret = AES_set_encrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & dat -> ks . ks ) ;\n dat -> block = ( block128_f ) AES_encrypt ;\n dat -> stream . cbc = mode == EVP_CIPH_CBC_MODE ? ( cbc128_f ) AES_cbc_encrypt : NULL ;\n # ifdef AES_CTR_ASM if ( mode == EVP_CIPH_CTR_MODE ) dat -> stream . ctr = ( ctr128_f ) AES_ctr32_encrypt ;\n # endif }\n if ( ret < 0 ) {\n EVPerr ( EVP_F_AES_INIT_KEY , EVP_R_AES_KEY_SETUP_FAILED ) ;\n return 0 ;\n }\n return 1 ;\n }", "idx": 876}
{"hash": 6427656838353800830, "project": "chrome", "size": 4, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( ChooserDialogViewTest , Cancel ) {\n EXPECT_CALL ( * mock_chooser_controller_ , Cancel ( ) ) . Times ( 1 ) ;\n chooser_dialog_view_ -> Cancel ( ) ;\n }", "idx": 877}
{"hash": -5262394088289559608, "project": "debian", "size": 6, "label": 0, "functionSource": "static inline int get_current_cpu ( ARMMPTimerState * s ) {\n if ( current_cpu -> cpu_index >= s -> num_cpu ) {\n hw_error ( \"arm_mptimer: num-cpu %d but this cpu is %d!\\n\" , s -> num_cpu , current_cpu -> cpu_index ) ;\n }\n return current_cpu -> cpu_index ;\n }", "idx": 878}
{"hash": 2895622461494525400, "project": "debian", "size": 34, "label": 0, "functionSource": "static void test_view_where ( ) {\n MYSQL_STMT * stmt ;\n int rc , i ;\n const char * query = \"select v1.c,v2.c from v1, v2\" ;\n myheader ( \"test_view_where\" ) ;\n rc = mysql_query ( mysql , \"DROP TABLE IF EXISTS t1,v1,v2\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"DROP VIEW IF EXISTS v1,v2,t1\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"CREATE TABLE t1 (a int, b int)\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"insert into t1 values (1,2), (1,3), (2,4), (2,5), (3,10)\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"create view v1 (c) as select b from t1 where a<3\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"create view v2 (c) as select b from t1 where a>=3\" ) ;\n myquery ( rc ) ;\n stmt = mysql_stmt_init ( mysql ) ;\n rc = mysql_stmt_prepare ( stmt , query , strlen ( query ) ) ;\n check_execute ( stmt , rc ) ;\n for ( i = 0 ;\n i < 3 ;\n i ++ ) {\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n rc = my_process_stmt_result ( stmt ) ;\n DIE_UNLESS ( 4 == rc ) ;\n }\n mysql_stmt_close ( stmt ) ;\n rc = mysql_query ( mysql , \"DROP TABLE t1\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"DROP VIEW v1, v2\" ) ;\n myquery ( rc ) ;\n }", "idx": 879}
{"hash": 6415329349331062723, "project": "chrome", "size": 16, "label": 0, "functionSource": "void http_basic_cb ( struct evhttp_request * req , void * arg ) {\n struct evbuffer * evb = evbuffer_new ( ) ;\n int empty = evhttp_find_header ( req -> input_headers , \"Empty\" ) != NULL ;\n event_debug ( ( \"%s: called\\n\" , __func__ ) ) ;\n evbuffer_add_printf ( evb , \"This is funny\" ) ;\n {\n const char * multi = evhttp_find_header ( req -> input_headers , \"X-multi\" ) ;\n if ( multi ) {\n if ( strcmp ( \"END\" , multi + strlen ( multi ) - 3 ) == 0 ) test_ok ++ ;\n if ( evhttp_find_header ( req -> input_headers , \"X-Last\" ) ) test_ok ++ ;\n }\n }\n if ( evhttp_find_header ( req -> input_headers , \"X-Negative\" ) ) evhttp_add_header ( req -> output_headers , \"Content-Length\" , \"-100\" ) ;\n evhttp_send_reply ( req , HTTP_OK , \"Everything is fine\" , ! empty ? evb : NULL ) ;\n evbuffer_free ( evb ) ;\n }", "idx": 880}
{"hash": -3559021711340554904, "project": "debian", "size": 11, "label": 0, "functionSource": "static Node * substitute_actual_parameters_mutator ( Node * node , substitute_actual_parameters_context * context ) {\n if ( node == NULL ) return NULL ;\n if ( IsA ( node , Param ) ) {\n Param * param = ( Param * ) node ;\n if ( param -> paramkind != PARAM_EXTERN ) elog ( ERROR , \"unexpected paramkind: %d\" , ( int ) param -> paramkind ) ;\n if ( param -> paramid <= 0 || param -> paramid > context -> nargs ) elog ( ERROR , \"invalid paramid: %d\" , param -> paramid ) ;\n context -> usecounts [ param -> paramid - 1 ] ++ ;\n return list_nth ( context -> args , param -> paramid - 1 ) ;\n }\n return expression_tree_mutator ( node , substitute_actual_parameters_mutator , ( void * ) context ) ;\n }", "idx": 881}
{"hash": 3668456668028959955, "project": "debian", "size": 4, "label": 0, "functionSource": "static VALUE cState_space_before ( VALUE self ) {\n GET_STATE ( self ) ;\n return state -> space_before ? rb_str_new ( state -> space_before , state -> space_before_len ) : rb_str_new2 ( \"\" ) ;\n }", "idx": 882}
{"hash": 2895622461494525400, "project": "debian", "size": 87, "label": 0, "functionSource": "static void test_bug5194 ( ) {\n MYSQL_STMT * stmt ;\n MYSQL_BIND * my_bind ;\n char * query ;\n char * param_str ;\n int param_str_length ;\n const char * stmt_text ;\n int rc ;\n float float_array [ 250 ] = {\n 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 , 0.25 }\n ;\n float * fa_ptr = float_array ;\n const int COLUMN_COUNT = sizeof ( float_array ) / sizeof ( * float_array ) ;\n const int MIN_ROWS_PER_INSERT = 262 ;\n const int MAX_ROWS_PER_INSERT = 300 ;\n const int MAX_PARAM_COUNT = COLUMN_COUNT * MAX_ROWS_PER_INSERT ;\n const char * query_template = \"insert into t1 values %s\" ;\n const int CHARS_PER_PARAM = 5 ;\n const int uint16_max = 65535 ;\n int nrows , i ;\n myheader ( \"test_bug5194\" ) ;\n stmt_text = \"drop table if exists t1\" ;\n rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n stmt_text = \"create table if not exists t1\" \"(c1 float, c2 float, c3 float, c4 float, c5 float, c6 float, \" \"c7 float, c8 float, c9 float, c10 float, c11 float, c12 float, \" \"c13 float, c14 float, c15 float, c16 float, c17 float, c18 float, \" \"c19 float, c20 float, c21 float, c22 float, c23 float, c24 float, \" \"c25 float, c26 float, c27 float, c28 float, c29 float, c30 float, \" \"c31 float, c32 float, c33 float, c34 float, c35 float, c36 float, \" \"c37 float, c38 float, c39 float, c40 float, c41 float, c42 float, \" \"c43 float, c44 float, c45 float, c46 float, c47 float, c48 float, \" \"c49 float, c50 float, c51 float, c52 float, c53 float, c54 float, \" \"c55 float, c56 float, c57 float, c58 float, c59 float, c60 float, \" \"c61 float, c62 float, c63 float, c64 float, c65 float, c66 float, \" \"c67 float, c68 float, c69 float, c70 float, c71 float, c72 float, \" \"c73 float, c74 float, c75 float, c76 float, c77 float, c78 float, \" \"c79 float, c80 float, c81 float, c82 float, c83 float, c84 float, \" \"c85 float, c86 float, c87 float, c88 float, c89 float, c90 float, \" \"c91 float, c92 float, c93 float, c94 float, c95 float, c96 float, \" \"c97 float, c98 float, c99 float, c100 float, c101 float, c102 float, \" \"c103 float, c104 float, c105 float, c106 float, c107 float, c108 float, \" \"c109 float, c110 float, c111 float, c112 float, c113 float, c114 float, \" \"c115 float, c116 float, c117 float, c118 float, c119 float, c120 float, \" \"c121 float, c122 float, c123 float, c124 float, c125 float, c126 float, \" \"c127 float, c128 float, c129 float, c130 float, c131 float, c132 float, \" \"c133 float, c134 float, c135 float, c136 float, c137 float, c138 float, \" \"c139 float, c140 float, c141 float, c142 float, c143 float, c144 float, \" \"c145 float, c146 float, c147 float, c148 float, c149 float, c150 float, \" \"c151 float, c152 float, c153 float, c154 float, c155 float, c156 float, \" \"c157 float, c158 float, c159 float, c160 float, c161 float, c162 float, \" \"c163 float, c164 float, c165 float, c166 float, c167 float, c168 float, \" \"c169 float, c170 float, c171 float, c172 float, c173 float, c174 float, \" \"c175 float, c176 float, c177 float, c178 float, c179 float, c180 float, \" \"c181 float, c182 float, c183 float, c184 float, c185 float, c186 float, \" \"c187 float, c188 float, c189 float, c190 float, c191 float, c192 float, \" \"c193 float, c194 float, c195 float, c196 float, c197 float, c198 float, \" \"c199 float, c200 float, c201 float, c202 float, c203 float, c204 float, \" \"c205 float, c206 float, c207 float, c208 float, c209 float, c210 float, \" \"c211 float, c212 float, c213 float, c214 float, c215 float, c216 float, \" \"c217 float, c218 float, c219 float, c220 float, c221 float, c222 float, \" \"c223 float, c224 float, c225 float, c226 float, c227 float, c228 float, \" \"c229 float, c230 float, c231 float, c232 float, c233 float, c234 float, \" \"c235 float, c236 float, c237 float, c238 float, c239 float, c240 float, \" \"c241 float, c242 float, c243 float, c244 float, c245 float, c246 float, \" \"c247 float, c248 float, c249 float, c250 float)\" ;\n rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n myquery ( rc ) ;\n my_bind = ( MYSQL_BIND * ) malloc ( MAX_PARAM_COUNT * sizeof ( MYSQL_BIND ) ) ;\n query = ( char * ) malloc ( strlen ( query_template ) + MAX_PARAM_COUNT * CHARS_PER_PARAM + 1 ) ;\n param_str = ( char * ) malloc ( COLUMN_COUNT * CHARS_PER_PARAM ) ;\n if ( my_bind == 0 || query == 0 || param_str == 0 ) {\n fprintf ( stderr , \"Can't allocate enough memory for query structs\\n\" ) ;\n if ( my_bind ) free ( my_bind ) ;\n if ( query ) free ( query ) ;\n if ( param_str ) free ( param_str ) ;\n return ;\n }\n stmt = mysql_stmt_init ( mysql ) ;\n sprintf ( param_str , \"(\" ) ;\n for ( i = 1 ;\n i < COLUMN_COUNT ;\n ++ i ) strcat ( param_str , \"?, \" ) ;\n strcat ( param_str , \"?)\" ) ;\n param_str_length = strlen ( param_str ) ;\n memset ( my_bind , 0 , MAX_PARAM_COUNT * sizeof ( MYSQL_BIND ) ) ;\n for ( i = 0 ;\n i < MAX_PARAM_COUNT ;\n ++ i ) {\n my_bind [ i ] . buffer_type = MYSQL_TYPE_FLOAT ;\n my_bind [ i ] . buffer = fa_ptr ;\n if ( ++ fa_ptr == float_array + COLUMN_COUNT ) fa_ptr = float_array ;\n }\n for ( nrows = MIN_ROWS_PER_INSERT ;\n nrows <= MAX_ROWS_PER_INSERT ;\n ++ nrows ) {\n char * query_ptr ;\n sprintf ( query , query_template , param_str ) ;\n query_ptr = query + strlen ( query ) ;\n for ( i = 1 ;\n i < nrows ;\n ++ i ) {\n memcpy ( query_ptr , \", \" , 2 ) ;\n query_ptr += 2 ;\n memcpy ( query_ptr , param_str , param_str_length ) ;\n query_ptr += param_str_length ;\n }\n * query_ptr = '\\0' ;\n rc = mysql_stmt_prepare ( stmt , query , query_ptr - query ) ;\n if ( rc && nrows * COLUMN_COUNT > uint16_max ) {\n if ( ! opt_silent ) printf ( \"Failed to prepare a statement with %d placeholders \" \"(as expected).\\n\" , nrows * COLUMN_COUNT ) ;\n break ;\n }\n else check_execute ( stmt , rc ) ;\n if ( ! opt_silent ) printf ( \"Insert: query length= %d, row count= %d, param count= %lu\\n\" , ( int ) strlen ( query ) , nrows , mysql_stmt_param_count ( stmt ) ) ;\n rc = mysql_stmt_bind_param ( stmt , my_bind ) ;\n check_execute ( stmt , rc ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n mysql_stmt_reset ( stmt ) ;\n }\n mysql_stmt_close ( stmt ) ;\n free ( my_bind ) ;\n free ( query ) ;\n free ( param_str ) ;\n stmt_text = \"drop table t1\" ;\n rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n myquery ( rc ) ;\n }", "idx": 883}
{"hash": 8895005875911486570, "project": "debian", "size": 30, "label": 0, "functionSource": "static void inject_file ( const char * path , char * file ) {\n char * filename ;\n int fd ;\n void * buf ;\n size_t size , ret ;\n DEBUG_MSG ( \"inject_file %s/%s\" , path , file ) ;\n SAFE_CALLOC ( filename , strlen ( path ) + strlen ( file ) + 2 , sizeof ( char ) ) ;\n snprintf ( filename , strlen ( path ) + strlen ( file ) + 2 , \"%s/%s\" , path , file ) ;\n if ( ( fd = open ( filename , O_RDONLY | O_BINARY ) ) == - 1 ) {\n ui_error ( \"Can't load the file\" ) ;\n return ;\n }\n SAFE_FREE ( filename ) ;\n size = lseek ( fd , 0 , SEEK_END ) ;\n SAFE_CALLOC ( buf , size , sizeof ( char ) ) ;\n lseek ( fd , 0 , SEEK_SET ) ;\n ret = read ( fd , buf , size ) ;\n close ( fd ) ;\n if ( ret != size ) {\n ui_error ( \"Cannot read the file into memory\" ) ;\n return ;\n }\n if ( wdg_c1 -> flags & WDG_OBJ_FOCUSED ) {\n user_inject ( buf , size , curr_conn , 1 ) ;\n }\n else if ( wdg_c2 -> flags & WDG_OBJ_FOCUSED ) {\n user_inject ( buf , size , curr_conn , 2 ) ;\n }\n SAFE_FREE ( buf ) ;\n }", "idx": 884}
{"hash": 6451388340908334697, "project": "debian", "size": 4, "label": 0, "functionSource": "static int s_aos_available ( stream * s , gs_offset_t * pl ) {\n * pl = ( ( aos_state_t * ) s -> state ) -> file_sz - stell ( s ) ;\n return 0 ;\n }", "idx": 885}
{"hash": 7092216800726729686, "project": "debian", "size": 5678, "label": 0, "functionSource": "void proto_register_h245 ( void ) {\n static hf_register_info hf [ ] = {\n {\n & hf_h245_pdu_type , {\n \"PDU Type\" , \"h245.pdu_type\" , FT_UINT32 , BASE_DEC , VALS ( h245_MultimediaSystemControlMessage_vals ) , 0 , \"Type of H.245 PDU\" , HFILL }\n }\n , {\n & hf_h245Manufacturer , {\n \"H.245 Manufacturer\" , \"h245.Manufacturer\" , FT_UINT32 , BASE_HEX , VALS ( H221ManufacturerCode_vals ) , 0 , \"h245.H.221 Manufacturer\" , HFILL }\n }\n , {\n & hf_h245_subMessageIdentifier_standard , {\n \"subMessageIdentifier\" , \"h245.subMessageIdentifier.standard\" , FT_UINT32 , BASE_DEC , VALS ( h245_h239subMessageIdentifier_vals ) , 0 , NULL , HFILL }\n }\n , # line 1 \"../../asn1/h245/packet-h245-hfarr.c\" {\n & hf_h245_OpenLogicalChannel_PDU , {\n \"OpenLogicalChannel\" , \"h245.OpenLogicalChannel_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_request , {\n \"request\" , \"h245.request\" , FT_UINT32 , BASE_DEC , VALS ( h245_RequestMessage_vals ) , 0 , \"RequestMessage\" , HFILL }\n }\n , {\n & hf_h245_response , {\n \"response\" , \"h245.response\" , FT_UINT32 , BASE_DEC , VALS ( h245_ResponseMessage_vals ) , 0 , \"ResponseMessage\" , HFILL }\n }\n , {\n & hf_h245_command , {\n \"command\" , \"h245.command\" , FT_UINT32 , BASE_DEC , VALS ( h245_CommandMessage_vals ) , 0 , \"CommandMessage\" , HFILL }\n }\n , {\n & hf_h245_indication , {\n \"indication\" , \"h245.indication\" , FT_UINT32 , BASE_DEC , VALS ( h245_IndicationMessage_vals ) , 0 , \"IndicationMessage\" , HFILL }\n }\n , {\n & hf_h245_nonStandardMsg , {\n \"nonStandard\" , \"h245.nonStandard_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"NonStandardMessage\" , HFILL }\n }\n , {\n & hf_h245_masterSlaveDetermination , {\n \"masterSlaveDetermination\" , \"h245.masterSlaveDetermination_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_terminalCapabilitySet , {\n \"terminalCapabilitySet\" , \"h245.terminalCapabilitySet_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_openLogicalChannel , {\n \"openLogicalChannel\" , \"h245.openLogicalChannel_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_closeLogicalChannel , {\n \"closeLogicalChannel\" , \"h245.closeLogicalChannel_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_requestChannelClose , {\n \"requestChannelClose\" , \"h245.requestChannelClose_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_multiplexEntrySend , {\n \"multiplexEntrySend\" , \"h245.multiplexEntrySend_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_requestMultiplexEntry , {\n \"requestMultiplexEntry\" , \"h245.requestMultiplexEntry_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_requestMode , {\n \"requestMode\" , \"h245.requestMode_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_roundTripDelayRequest , {\n \"roundTripDelayRequest\" , \"h245.roundTripDelayRequest_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_maintenanceLoopRequest , {\n \"maintenanceLoopRequest\" , \"h245.maintenanceLoopRequest_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_communicationModeRequest , {\n \"communicationModeRequest\" , \"h245.communicationModeRequest_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_conferenceRequest , {\n \"conferenceRequest\" , \"h245.conferenceRequest\" , FT_UINT32 , BASE_DEC , VALS ( h245_ConferenceRequest_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_multilinkRequest , {\n \"multilinkRequest\" , \"h245.multilinkRequest\" , FT_UINT32 , BASE_DEC , VALS ( h245_MultilinkRequest_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_logicalChannelRateRequest , {\n \"logicalChannelRateRequest\" , \"h245.logicalChannelRateRequest_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_genericRequest , {\n \"genericRequest\" , \"h245.genericRequest_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"GenericMessage\" , HFILL }\n }\n , {\n & hf_h245_masterSlaveDeterminationAck , {\n \"masterSlaveDeterminationAck\" , \"h245.masterSlaveDeterminationAck_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_masterSlaveDeterminationReject , {\n \"masterSlaveDeterminationReject\" , \"h245.masterSlaveDeterminationReject_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_terminalCapabilitySetAck , {\n \"terminalCapabilitySetAck\" , \"h245.terminalCapabilitySetAck_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_terminalCapabilitySetReject , {\n \"terminalCapabilitySetReject\" , \"h245.terminalCapabilitySetReject_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_openLogicalChannelAck , {\n \"openLogicalChannelAck\" , \"h245.openLogicalChannelAck_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_openLogicalChannelReject , {\n \"openLogicalChannelReject\" , \"h245.openLogicalChannelReject_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_closeLogicalChannelAck , {\n \"closeLogicalChannelAck\" , \"h245.closeLogicalChannelAck_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_requestChannelCloseAck , {\n \"requestChannelCloseAck\" , \"h245.requestChannelCloseAck_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_requestChannelCloseReject , {\n \"requestChannelCloseReject\" , \"h245.requestChannelCloseReject_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_multiplexEntrySendAck , {\n \"multiplexEntrySendAck\" , \"h245.multiplexEntrySendAck_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_multiplexEntrySendReject , {\n \"multiplexEntrySendReject\" , \"h245.multiplexEntrySendReject_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_requestMultiplexEntryAck , {\n \"requestMultiplexEntryAck\" , \"h245.requestMultiplexEntryAck_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_requestMultiplexEntryReject , {\n \"requestMultiplexEntryReject\" , \"h245.requestMultiplexEntryReject_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_requestModeAck , {\n \"requestModeAck\" , \"h245.requestModeAck_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_requestModeReject , {\n \"requestModeReject\" , \"h245.requestModeReject_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_roundTripDelayResponse , {\n \"roundTripDelayResponse\" , \"h245.roundTripDelayResponse_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_maintenanceLoopAck , {\n \"maintenanceLoopAck\" , \"h245.maintenanceLoopAck_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_maintenanceLoopReject , {\n \"maintenanceLoopReject\" , \"h245.maintenanceLoopReject_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_communicationModeResponse , {\n \"communicationModeResponse\" , \"h245.communicationModeResponse\" , FT_UINT32 , BASE_DEC , VALS ( h245_CommunicationModeResponse_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_conferenceResponse , {\n \"conferenceResponse\" , \"h245.conferenceResponse\" , FT_UINT32 , BASE_DEC , VALS ( h245_ConferenceResponse_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_multilinkResponse , {\n \"multilinkResponse\" , \"h245.multilinkResponse\" , FT_UINT32 , BASE_DEC , VALS ( h245_MultilinkResponse_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_logicalChannelRateAcknowledge , {\n \"logicalChannelRateAcknowledge\" , \"h245.logicalChannelRateAcknowledge_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_logicalChannelRateReject , {\n \"logicalChannelRateReject\" , \"h245.logicalChannelRateReject_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_genericResponse , {\n \"genericResponse\" , \"h245.genericResponse_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"GenericMessage\" , HFILL }\n }\n , {\n & hf_h245_maintenanceLoopOffCommand , {\n \"maintenanceLoopOffCommand\" , \"h245.maintenanceLoopOffCommand_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_sendTerminalCapabilitySet , {\n \"sendTerminalCapabilitySet\" , \"h245.sendTerminalCapabilitySet\" , FT_UINT32 , BASE_DEC , VALS ( h245_SendTerminalCapabilitySet_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_encryptionCommand , {\n \"encryptionCommand\" , \"h245.encryptionCommand\" , FT_UINT32 , BASE_DEC , VALS ( h245_EncryptionCommand_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_flowControlCommand , {\n \"flowControlCommand\" , \"h245.flowControlCommand_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_endSessionCommand , {\n \"endSessionCommand\" , \"h245.endSessionCommand\" , FT_UINT32 , BASE_DEC , VALS ( h245_EndSessionCommand_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_miscellaneousCommand , {\n \"miscellaneousCommand\" , \"h245.miscellaneousCommand_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_communicationModeCommand , {\n \"communicationModeCommand\" , \"h245.communicationModeCommand_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_conferenceCommand , {\n \"conferenceCommand\" , \"h245.conferenceCommand\" , FT_UINT32 , BASE_DEC , VALS ( h245_ConferenceCommand_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_h223MultiplexReconfiguration , {\n \"h223MultiplexReconfiguration\" , \"h245.h223MultiplexReconfiguration\" , FT_UINT32 , BASE_DEC , VALS ( h245_H223MultiplexReconfiguration_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_newATMVCCommand , {\n \"newATMVCCommand\" , \"h245.newATMVCCommand_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_mobileMultilinkReconfigurationCommand , {\n \"mobileMultilinkReconfigurationCommand\" , \"h245.mobileMultilinkReconfigurationCommand_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_genericCommand , {\n \"genericCommand\" , \"h245.genericCommand_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"GenericMessage\" , HFILL }\n }\n , {\n & hf_h245_functionNotUnderstood , {\n \"functionNotUnderstood\" , \"h245.functionNotUnderstood\" , FT_UINT32 , BASE_DEC , VALS ( h245_FunctionNotUnderstood_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_masterSlaveDeterminationRelease , {\n \"masterSlaveDeterminationRelease\" , \"h245.masterSlaveDeterminationRelease_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_terminalCapabilitySetRelease , {\n \"terminalCapabilitySetRelease\" , \"h245.terminalCapabilitySetRelease_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_openLogicalChannelConfirm , {\n \"openLogicalChannelConfirm\" , \"h245.openLogicalChannelConfirm_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_requestChannelCloseRelease , {\n \"requestChannelCloseRelease\" , \"h245.requestChannelCloseRelease_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_multiplexEntrySendRelease , {\n \"multiplexEntrySendRelease\" , \"h245.multiplexEntrySendRelease_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_requestMultiplexEntryRelease , {\n \"requestMultiplexEntryRelease\" , \"h245.requestMultiplexEntryRelease_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_requestModeRelease , {\n \"requestModeRelease\" , \"h245.requestModeRelease_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_miscellaneousIndication , {\n \"miscellaneousIndication\" , \"h245.miscellaneousIndication_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_jitterIndication , {\n \"jitterIndication\" , \"h245.jitterIndication_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_h223SkewIndication , {\n \"h223SkewIndication\" , \"h245.h223SkewIndication_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_newATMVCIndication , {\n \"newATMVCIndication\" , \"h245.newATMVCIndication_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_userInput , {\n \"userInput\" , \"h245.userInput\" , FT_UINT32 , BASE_DEC , VALS ( h245_UserInputIndication_vals ) , 0 , \"UserInputIndication\" , HFILL }\n }\n , {\n & hf_h245_h2250MaximumSkewIndication , {\n \"h2250MaximumSkewIndication\" , \"h245.h2250MaximumSkewIndication_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_mcLocationIndication , {\n \"mcLocationIndication\" , \"h245.mcLocationIndication_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_conferenceIndication , {\n \"conferenceIndication\" , \"h245.conferenceIndication\" , FT_UINT32 , BASE_DEC , VALS ( h245_ConferenceIndication_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_vendorIdentification , {\n \"vendorIdentification\" , \"h245.vendorIdentification_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_functionNotSupported , {\n \"functionNotSupported\" , \"h245.functionNotSupported_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_multilinkIndication , {\n \"multilinkIndication\" , \"h245.multilinkIndication\" , FT_UINT32 , BASE_DEC , VALS ( h245_MultilinkIndication_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_logicalChannelRateRelease , {\n \"logicalChannelRateRelease\" , \"h245.logicalChannelRateRelease_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_flowControlIndication , {\n \"flowControlIndication\" , \"h245.flowControlIndication_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_mobileMultilinkReconfigurationIndication , {\n \"mobileMultilinkReconfigurationIndication\" , \"h245.mobileMultilinkReconfigurationIndication_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_genericIndication , {\n \"genericIndication\" , \"h245.genericIndication_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"GenericMessage\" , HFILL }\n }\n , {\n & hf_h245_messageIdentifier , {\n \"messageIdentifier\" , \"h245.messageIdentifier\" , FT_UINT32 , BASE_DEC , VALS ( h245_CapabilityIdentifier_vals ) , 0 , \"CapabilityIdentifier\" , HFILL }\n }\n , {\n & hf_h245_subMessageIdentifier , {\n \"subMessageIdentifier\" , \"h245.subMessageIdentifier\" , FT_UINT32 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_messageContent , {\n \"messageContent\" , \"h245.messageContent\" , FT_UINT32 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_messageContent_item , {\n \"messageContent item\" , \"h245.messageContent_item_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"T_messageContent_item\" , HFILL }\n }\n , {\n & hf_h245_nonStandardData , {\n \"nonStandardData\" , \"h245.nonStandardData_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"NonStandardParameter\" , HFILL }\n }\n , {\n & hf_h245_nonStandardIdentifier , {\n \"nonStandardIdentifier\" , \"h245.nonStandardIdentifier\" , FT_UINT32 , BASE_DEC , VALS ( h245_NonStandardIdentifier_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_nsd_data , {\n \"data\" , \"h245.data\" , FT_BYTES , BASE_NONE , NULL , 0 , \"T_nsd_data\" , HFILL }\n }\n , {\n & hf_h245_object , {\n \"object\" , \"h245.object\" , FT_OID , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_h221NonStandardID , {\n \"h221NonStandard\" , \"h245.h221NonStandard_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"H221NonStandardID\" , HFILL }\n }\n , {\n & hf_h245_t35CountryCode , {\n \"t35CountryCode\" , \"h245.t35CountryCode\" , FT_UINT32 , BASE_DEC , VALS ( T35CountryCode_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_t35Extension , {\n \"t35Extension\" , \"h245.t35Extension\" , FT_UINT32 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_manufacturerCode , {\n \"manufacturerCode\" , \"h245.manufacturerCode\" , FT_UINT32 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_terminalType , {\n \"terminalType\" , \"h245.terminalType\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_255\" , HFILL }\n }\n , {\n & hf_h245_statusDeterminationNumber , {\n \"statusDeterminationNumber\" , \"h245.statusDeterminationNumber\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_16777215\" , HFILL }\n }\n , {\n & hf_h245_decision , {\n \"decision\" , \"h245.decision\" , FT_UINT32 , BASE_DEC , VALS ( h245_T_decision_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_master , {\n \"master\" , \"h245.master_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_slave , {\n \"slave\" , \"h245.slave_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_msd_rej_cause , {\n \"cause\" , \"h245.cause\" , FT_UINT32 , BASE_DEC , VALS ( h245_MasterSlaveDeterminationRejectCause_vals ) , 0 , \"MasterSlaveDeterminationRejectCause\" , HFILL }\n }\n , {\n & hf_h245_identicalNumbers , {\n \"identicalNumbers\" , \"h245.identicalNumbers_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_sequenceNumber , {\n \"sequenceNumber\" , \"h245.sequenceNumber\" , FT_UINT32 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_protocolIdentifier , {\n \"protocolIdentifier\" , \"h245.protocolIdentifier\" , FT_OID , BASE_NONE , NULL , 0 , \"OBJECT_IDENTIFIER\" , HFILL }\n }\n , {\n & hf_h245_multiplexCapability , {\n \"multiplexCapability\" , \"h245.multiplexCapability\" , FT_UINT32 , BASE_DEC , VALS ( h245_MultiplexCapability_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_capabilityTable , {\n \"capabilityTable\" , \"h245.capabilityTable\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"SET_SIZE_1_256_OF_CapabilityTableEntry\" , HFILL }\n }\n , {\n & hf_h245_capabilityTable_item , {\n \"CapabilityTableEntry\" , \"h245.CapabilityTableEntry_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_capabilityDescriptors , {\n \"capabilityDescriptors\" , \"h245.capabilityDescriptors\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"SET_SIZE_1_256_OF_CapabilityDescriptor\" , HFILL }\n }\n , {\n & hf_h245_capabilityDescriptors_item , {\n \"CapabilityDescriptor\" , \"h245.CapabilityDescriptor_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_genericInformation , {\n \"genericInformation\" , \"h245.genericInformation\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"SEQUENCE_OF_GenericInformation\" , HFILL }\n }\n , {\n & hf_h245_genericInformation_item , {\n \"GenericInformation\" , \"h245.GenericInformation_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_capabilityTableEntryNumber , {\n \"capabilityTableEntryNumber\" , \"h245.capabilityTableEntryNumber\" , FT_UINT32 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_capability , {\n \"capability\" , \"h245.capability\" , FT_UINT32 , BASE_DEC , VALS ( h245_Capability_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_capabilityDescriptorNumber , {\n \"capabilityDescriptorNumber\" , \"h245.capabilityDescriptorNumber\" , FT_UINT32 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_simultaneousCapabilities , {\n \"simultaneousCapabilities\" , \"h245.simultaneousCapabilities\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"SET_SIZE_1_256_OF_AlternativeCapabilitySet\" , HFILL }\n }\n , {\n & hf_h245_simultaneousCapabilities_item , {\n \"AlternativeCapabilitySet\" , \"h245.AlternativeCapabilitySet\" , FT_UINT32 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_AlternativeCapabilitySet_item , {\n \"alternativeCapability\" , \"h245.CapabilityTableEntryNumber\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"CapabilityTableEntryNumber\" , HFILL }\n }\n , {\n & hf_h245_tcs_rej_cause , {\n \"cause\" , \"h245.cause\" , FT_UINT32 , BASE_DEC , VALS ( h245_TerminalCapabilitySetRejectCause_vals ) , 0 , \"TerminalCapabilitySetRejectCause\" , HFILL }\n }\n , {\n & hf_h245_unspecified , {\n \"unspecified\" , \"h245.unspecified_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_undefinedTableEntryUsed , {\n \"undefinedTableEntryUsed\" , \"h245.undefinedTableEntryUsed_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_descriptorCapacityExceeded , {\n \"descriptorCapacityExceeded\" , \"h245.descriptorCapacityExceeded_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_tableEntryCapacityExceeded , {\n \"tableEntryCapacityExceeded\" , \"h245.tableEntryCapacityExceeded\" , FT_UINT32 , BASE_DEC , VALS ( h245_T_tableEntryCapacityExceeded_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_highestEntryNumberProcessed , {\n \"highestEntryNumberProcessed\" , \"h245.highestEntryNumberProcessed\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"CapabilityTableEntryNumber\" , HFILL }\n }\n , {\n & hf_h245_noneProcessed , {\n \"noneProcessed\" , \"h245.noneProcessed_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_nonStandard , {\n \"nonStandard\" , \"h245.nonStandard_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"NonStandardParameter\" , HFILL }\n }\n , {\n & hf_h245_receiveVideoCapability , {\n \"receiveVideoCapability\" , \"h245.receiveVideoCapability\" , FT_UINT32 , BASE_DEC , VALS ( h245_VideoCapability_vals ) , 0 , \"VideoCapability\" , HFILL }\n }\n , {\n & hf_h245_transmitVideoCapability , {\n \"transmitVideoCapability\" , \"h245.transmitVideoCapability\" , FT_UINT32 , BASE_DEC , VALS ( h245_VideoCapability_vals ) , 0 , \"VideoCapability\" , HFILL }\n }\n , {\n & hf_h245_receiveAndTransmitVideoCapability , {\n \"receiveAndTransmitVideoCapability\" , \"h245.receiveAndTransmitVideoCapability\" , FT_UINT32 , BASE_DEC , VALS ( h245_VideoCapability_vals ) , 0 , \"VideoCapability\" , HFILL }\n }\n , {\n & hf_h245_receiveAudioCapability , {\n \"receiveAudioCapability\" , \"h245.receiveAudioCapability\" , FT_UINT32 , BASE_DEC , VALS ( h245_AudioCapability_vals ) , 0 , \"AudioCapability\" , HFILL }\n }\n , {\n & hf_h245_transmitAudioCapability , {\n \"transmitAudioCapability\" , \"h245.transmitAudioCapability\" , FT_UINT32 , BASE_DEC , VALS ( h245_AudioCapability_vals ) , 0 , \"AudioCapability\" , HFILL }\n }\n , {\n & hf_h245_receiveAndTransmitAudioCapability , {\n \"receiveAndTransmitAudioCapability\" , \"h245.receiveAndTransmitAudioCapability\" , FT_UINT32 , BASE_DEC , VALS ( h245_AudioCapability_vals ) , 0 , \"AudioCapability\" , HFILL }\n }\n , {\n & hf_h245_receiveDataApplicationCapability , {\n \"receiveDataApplicationCapability\" , \"h245.receiveDataApplicationCapability_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"DataApplicationCapability\" , HFILL }\n }\n , {\n & hf_h245_transmitDataApplicationCapability , {\n \"transmitDataApplicationCapability\" , \"h245.transmitDataApplicationCapability_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"DataApplicationCapability\" , HFILL }\n }\n , {\n & hf_h245_receiveAndTransmitDataApplicationCapability , {\n \"receiveAndTransmitDataApplicationCapability\" , \"h245.receiveAndTransmitDataApplicationCapability_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"DataApplicationCapability\" , HFILL }\n }\n , {\n & hf_h245_h233EncryptionTransmitCapability , {\n \"h233EncryptionTransmitCapability\" , \"h245.h233EncryptionTransmitCapability\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_h233EncryptionReceiveCapability , {\n \"h233EncryptionReceiveCapability\" , \"h245.h233EncryptionReceiveCapability_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_h233IVResponseTime , {\n \"h233IVResponseTime\" , \"h245.h233IVResponseTime\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_255\" , HFILL }\n }\n , {\n & hf_h245_conferenceCapability , {\n \"conferenceCapability\" , \"h245.conferenceCapability_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_h235SecurityCapability , {\n \"h235SecurityCapability\" , \"h245.h235SecurityCapability_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_maxPendingReplacementFor , {\n \"maxPendingReplacementFor\" , \"h245.maxPendingReplacementFor\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_255\" , HFILL }\n }\n , {\n & hf_h245_receiveUserInputCapability , {\n \"receiveUserInputCapability\" , \"h245.receiveUserInputCapability\" , FT_UINT32 , BASE_DEC , VALS ( h245_UserInputCapability_vals ) , 0 , \"UserInputCapability\" , HFILL }\n }\n , {\n & hf_h245_transmitUserInputCapability , {\n \"transmitUserInputCapability\" , \"h245.transmitUserInputCapability\" , FT_UINT32 , BASE_DEC , VALS ( h245_UserInputCapability_vals ) , 0 , \"UserInputCapability\" , HFILL }\n }\n , {\n & hf_h245_receiveAndTransmitUserInputCapability , {\n \"receiveAndTransmitUserInputCapability\" , \"h245.receiveAndTransmitUserInputCapability\" , FT_UINT32 , BASE_DEC , VALS ( h245_UserInputCapability_vals ) , 0 , \"UserInputCapability\" , HFILL }\n }\n , {\n & hf_h245_genericControlCapability , {\n \"genericControlCapability\" , \"h245.genericControlCapability_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"GenericCapability\" , HFILL }\n }\n , {\n & hf_h245_receiveMultiplexedStreamCapability , {\n \"receiveMultiplexedStreamCapability\" , \"h245.receiveMultiplexedStreamCapability_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"MultiplexedStreamCapability\" , HFILL }\n }\n , {\n & hf_h245_transmitMultiplexedStreamCapability , {\n \"transmitMultiplexedStreamCapability\" , \"h245.transmitMultiplexedStreamCapability_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"MultiplexedStreamCapability\" , HFILL }\n }\n , {\n & hf_h245_receiveAndTransmitMultiplexedStreamCapability , {\n \"receiveAndTransmitMultiplexedStreamCapability\" , \"h245.receiveAndTransmitMultiplexedStreamCapability_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"MultiplexedStreamCapability\" , HFILL }\n }\n , {\n & hf_h245_receiveRTPAudioTelephonyEventCapability , {\n \"receiveRTPAudioTelephonyEventCapability\" , \"h245.receiveRTPAudioTelephonyEventCapability_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"AudioTelephonyEventCapability\" , HFILL }\n }\n , {\n & hf_h245_receiveRTPAudioToneCapability , {\n \"receiveRTPAudioToneCapability\" , \"h245.receiveRTPAudioToneCapability_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"AudioToneCapability\" , HFILL }\n }\n , {\n & hf_h245_depFecCapability , {\n \"depFecCapability\" , \"h245.depFecCapability\" , FT_UINT32 , BASE_DEC , VALS ( h245_DepFECCapability_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_multiplePayloadStreamCapability , {\n \"multiplePayloadStreamCapability\" , \"h245.multiplePayloadStreamCapability_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_fecCapability , {\n \"fecCapability\" , \"h245.fecCapability_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_redundancyEncodingCap , {\n \"redundancyEncodingCap\" , \"h245.redundancyEncodingCap_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"RedundancyEncodingCapability\" , HFILL }\n }\n , {\n & hf_h245_oneOfCapabilities , {\n \"oneOfCapabilities\" , \"h245.oneOfCapabilities\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"AlternativeCapabilitySet\" , HFILL }\n }\n , {\n & hf_h245_encryptionAuthenticationAndIntegrity , {\n \"encryptionAuthenticationAndIntegrity\" , \"h245.encryptionAuthenticationAndIntegrity_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_mediaCapability , {\n \"mediaCapability\" , \"h245.mediaCapability\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"CapabilityTableEntryNumber\" , HFILL }\n }\n , {\n & hf_h245_h222Capability , {\n \"h222Capability\" , \"h245.h222Capability_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_h223Capability , {\n \"h223Capability\" , \"h245.h223Capability_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_v76Capability , {\n \"v76Capability\" , \"h245.v76Capability_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_h2250Capability , {\n \"h2250Capability\" , \"h245.h2250Capability_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_genericMultiplexCapability , {\n \"genericMultiplexCapability\" , \"h245.genericMultiplexCapability_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"GenericCapability\" , HFILL }\n }\n , {\n & hf_h245_numberOfVCs , {\n \"numberOfVCs\" , \"h245.numberOfVCs\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_256\" , HFILL }\n }\n , {\n & hf_h245_vcCapability , {\n \"vcCapability\" , \"h245.vcCapability\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"SET_OF_VCCapability\" , HFILL }\n }\n , {\n & hf_h245_vcCapability_item , {\n \"VCCapability\" , \"h245.VCCapability_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_aal1 , {\n \"aal1\" , \"h245.aal1_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_nullClockRecovery , {\n \"nullClockRecovery\" , \"h245.nullClockRecovery\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_srtsClockRecovery_bool , {\n \"srtsClockRecovery\" , \"h245.srtsClockRecovery\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_adaptiveClockRecovery , {\n \"adaptiveClockRecovery\" , \"h245.adaptiveClockRecovery\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_nullErrorCorrection , {\n \"nullErrorCorrection\" , \"h245.nullErrorCorrection\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_longInterleaver , {\n \"longInterleaver\" , \"h245.longInterleaver\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_shortInterleaver , {\n \"shortInterleaver\" , \"h245.shortInterleaver\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_errorCorrectionOnly , {\n \"errorCorrectionOnly\" , \"h245.errorCorrectionOnly\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_structuredDataTransfer , {\n \"structuredDataTransfer\" , \"h245.structuredDataTransfer\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_partiallyFilledCells , {\n \"partiallyFilledCells\" , \"h245.partiallyFilledCells\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_aal5 , {\n \"aal5\" , \"h245.aal5_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_forwardMaximumSDUSize , {\n \"forwardMaximumSDUSize\" , \"h245.forwardMaximumSDUSize\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_65535\" , HFILL }\n }\n , {\n & hf_h245_backwardMaximumSDUSize , {\n \"backwardMaximumSDUSize\" , \"h245.backwardMaximumSDUSize\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_65535\" , HFILL }\n }\n , {\n & hf_h245_transportStream_bool , {\n \"transportStream\" , \"h245.transportStream\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_programStream , {\n \"programStream\" , \"h245.programStream\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_availableBitRates , {\n \"availableBitRates\" , \"h245.availableBitRates_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_avb_type , {\n \"type\" , \"h245.type\" , FT_UINT32 , BASE_DEC , VALS ( h245_Avb_type_vals ) , 0 , \"Avb_type\" , HFILL }\n }\n , {\n & hf_h245_singleBitRate , {\n \"singleBitRate\" , \"h245.singleBitRate\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_65535\" , HFILL }\n }\n , {\n & hf_h245_rangeOfBitRates , {\n \"rangeOfBitRates\" , \"h245.rangeOfBitRates_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_lowerBitRate , {\n \"lowerBitRate\" , \"h245.lowerBitRate\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_65535\" , HFILL }\n }\n , {\n & hf_h245_higherBitRate , {\n \"higherBitRate\" , \"h245.higherBitRate\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_65535\" , HFILL }\n }\n , {\n & hf_h245_aal1ViaGateway , {\n \"aal1ViaGateway\" , \"h245.aal1ViaGateway_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_gatewayAddress , {\n \"gatewayAddress\" , \"h245.gatewayAddress\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"SET_SIZE_1_256_OF_Q2931Address\" , HFILL }\n }\n , {\n & hf_h245_gatewayAddress_item , {\n \"Q2931Address\" , \"h245.Q2931Address_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_srtsClockRecoveryflag , {\n \"srtsClockRecovery\" , \"h245.srtsClockRecovery\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_transportWithI_frames , {\n \"transportWithI-frames\" , \"h245.transportWithI_frames\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_videoWithAL1 , {\n \"videoWithAL1\" , \"h245.videoWithAL1\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_videoWithAL2 , {\n \"videoWithAL2\" , \"h245.videoWithAL2\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_videoWithAL3 , {\n \"videoWithAL3\" , \"h245.videoWithAL3\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_audioWithAL1 , {\n \"audioWithAL1\" , \"h245.audioWithAL1\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_audioWithAL2 , {\n \"audioWithAL2\" , \"h245.audioWithAL2\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_audioWithAL3 , {\n \"audioWithAL3\" , \"h245.audioWithAL3\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_dataWithAL1 , {\n \"dataWithAL1\" , \"h245.dataWithAL1\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_dataWithAL2 , {\n \"dataWithAL2\" , \"h245.dataWithAL2\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_dataWithAL3 , {\n \"dataWithAL3\" , \"h245.dataWithAL3\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_maximumAl2SDUSize , {\n \"maximumAl2SDUSize\" , \"h245.maximumAl2SDUSize\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_65535\" , HFILL }\n }\n , {\n & hf_h245_maximumAl3SDUSize , {\n \"maximumAl3SDUSize\" , \"h245.maximumAl3SDUSize\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_65535\" , HFILL }\n }\n , {\n & hf_h245_maximumDelayJitter , {\n \"maximumDelayJitter\" , \"h245.maximumDelayJitter\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_1023\" , HFILL }\n }\n , {\n & hf_h245_h223MultiplexTableCapability , {\n \"h223MultiplexTableCapability\" , \"h245.h223MultiplexTableCapability\" , FT_UINT32 , BASE_DEC , VALS ( h245_T_h223MultiplexTableCapability_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_basic , {\n \"basic\" , \"h245.basic_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_enhanced , {\n \"enhanced\" , \"h245.enhanced_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_maximumNestingDepth , {\n \"maximumNestingDepth\" , \"h245.maximumNestingDepth\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_15\" , HFILL }\n }\n , {\n & hf_h245_maximumElementListSize , {\n \"maximumElementListSize\" , \"h245.maximumElementListSize\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_2_255\" , HFILL }\n }\n , {\n & hf_h245_maximumSubElementListSize , {\n \"maximumSubElementListSize\" , \"h245.maximumSubElementListSize\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_2_255\" , HFILL }\n }\n , {\n & hf_h245_maxMUXPDUSizeCapability , {\n \"maxMUXPDUSizeCapability\" , \"h245.maxMUXPDUSizeCapability\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_nsrpSupport , {\n \"nsrpSupport\" , \"h245.nsrpSupport\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_mobileOperationTransmitCapability , {\n \"mobileOperationTransmitCapability\" , \"h245.mobileOperationTransmitCapability_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_modeChangeCapability , {\n \"modeChangeCapability\" , \"h245.modeChangeCapability\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_h223AnnexA , {\n \"h223AnnexA\" , \"h245.h223AnnexA\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_h223AnnexADoubleFlagFlag , {\n \"h223AnnexADoubleFlag\" , \"h245.h223AnnexADoubleFlag\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_h223AnnexB , {\n \"h223AnnexB\" , \"h245.h223AnnexB\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_h223AnnexBwithHeader , {\n \"h223AnnexBwithHeader\" , \"h245.h223AnnexBwithHeader\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_h223AnnexCCapability , {\n \"h223AnnexCCapability\" , \"h245.h223AnnexCCapability_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_bitRate_1_19200 , {\n \"bitRate\" , \"h245.bitRate\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_19200\" , HFILL }\n }\n , {\n & hf_h245_mobileMultilinkFrameCapability , {\n \"mobileMultilinkFrameCapability\" , \"h245.mobileMultilinkFrameCapability_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_maximumSampleSize , {\n \"maximumSampleSize\" , \"h245.maximumSampleSize\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_255\" , HFILL }\n }\n , {\n & hf_h245_maximumPayloadLength , {\n \"maximumPayloadLength\" , \"h245.maximumPayloadLength\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_65025\" , HFILL }\n }\n , {\n & hf_h245_videoWithAL1M , {\n \"videoWithAL1M\" , \"h245.videoWithAL1M\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_videoWithAL2M , {\n \"videoWithAL2M\" , \"h245.videoWithAL2M\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_videoWithAL3M , {\n \"videoWithAL3M\" , \"h245.videoWithAL3M\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_audioWithAL1M , {\n \"audioWithAL1M\" , \"h245.audioWithAL1M\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_audioWithAL2M , {\n \"audioWithAL2M\" , \"h245.audioWithAL2M\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_audioWithAL3M , {\n \"audioWithAL3M\" , \"h245.audioWithAL3M\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_dataWithAL1M , {\n \"dataWithAL1M\" , \"h245.dataWithAL1M\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_dataWithAL2M , {\n \"dataWithAL2M\" , \"h245.dataWithAL2M\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_dataWithAL3M , {\n \"dataWithAL3M\" , \"h245.dataWithAL3M\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_alpduInterleaving , {\n \"alpduInterleaving\" , \"h245.alpduInterleaving\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_maximumAL1MPDUSize , {\n \"maximumAL1MPDUSize\" , \"h245.maximumAL1MPDUSize\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_65535\" , HFILL }\n }\n , {\n & hf_h245_maximumAL2MSDUSize , {\n \"maximumAL2MSDUSize\" , \"h245.maximumAL2MSDUSize\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_65535\" , HFILL }\n }\n , {\n & hf_h245_maximumAL3MSDUSize , {\n \"maximumAL3MSDUSize\" , \"h245.maximumAL3MSDUSize\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_65535\" , HFILL }\n }\n , {\n & hf_h245_rsCodeCapability , {\n \"rsCodeCapability\" , \"h245.rsCodeCapability\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_suspendResumeCapabilitywAddress , {\n \"suspendResumeCapabilitywAddress\" , \"h245.suspendResumeCapabilitywAddress\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_suspendResumeCapabilitywoAddress , {\n \"suspendResumeCapabilitywoAddress\" , \"h245.suspendResumeCapabilitywoAddress\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_rejCapability , {\n \"rejCapability\" , \"h245.rejCapability\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_sREJCapability , {\n \"sREJCapability\" , \"h245.sREJCapability\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_mREJCapability , {\n \"mREJCapability\" , \"h245.mREJCapability\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_crc8bitCapability , {\n \"crc8bitCapability\" , \"h245.crc8bitCapability\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_crc16bitCapability , {\n \"crc16bitCapability\" , \"h245.crc16bitCapability\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_crc32bitCapability , {\n \"crc32bitCapability\" , \"h245.crc32bitCapability\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_uihCapability , {\n \"uihCapability\" , \"h245.uihCapability\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_numOfDLCS , {\n \"numOfDLCS\" , \"h245.numOfDLCS\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_2_8191\" , HFILL }\n }\n , {\n & hf_h245_twoOctetAddressFieldCapability , {\n \"twoOctetAddressFieldCapability\" , \"h245.twoOctetAddressFieldCapability\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_loopBackTestCapability , {\n \"loopBackTestCapability\" , \"h245.loopBackTestCapability\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_n401Capability , {\n \"n401Capability\" , \"h245.n401Capability\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_4095\" , HFILL }\n }\n , {\n & hf_h245_maxWindowSizeCapability , {\n \"maxWindowSizeCapability\" , \"h245.maxWindowSizeCapability\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_127\" , HFILL }\n }\n , {\n & hf_h245_v75Capability , {\n \"v75Capability\" , \"h245.v75Capability_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_audioHeader , {\n \"audioHeader\" , \"h245.audioHeader\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_maximumAudioDelayJitter , {\n \"maximumAudioDelayJitter\" , \"h245.maximumAudioDelayJitter\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_1023\" , HFILL }\n }\n , {\n & hf_h245_receiveMultipointCapability , {\n \"receiveMultipointCapability\" , \"h245.receiveMultipointCapability_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"MultipointCapability\" , HFILL }\n }\n , {\n & hf_h245_transmitMultipointCapability , {\n \"transmitMultipointCapability\" , \"h245.transmitMultipointCapability_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"MultipointCapability\" , HFILL }\n }\n , {\n & hf_h245_receiveAndTransmitMultipointCapability , {\n \"receiveAndTransmitMultipointCapability\" , \"h245.receiveAndTransmitMultipointCapability_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"MultipointCapability\" , HFILL }\n }\n , {\n & hf_h245_mcCapability , {\n \"mcCapability\" , \"h245.mcCapability_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_centralizedConferenceMC , {\n \"centralizedConferenceMC\" , \"h245.centralizedConferenceMC\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_decentralizedConferenceMC , {\n \"decentralizedConferenceMC\" , \"h245.decentralizedConferenceMC\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_rtcpVideoControlCapability , {\n \"rtcpVideoControlCapability\" , \"h245.rtcpVideoControlCapability\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_mediaPacketizationCapability , {\n \"mediaPacketizationCapability\" , \"h245.mediaPacketizationCapability_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_transportCapability , {\n \"transportCapability\" , \"h245.transportCapability_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_redundancyEncodingCapability , {\n \"redundancyEncodingCapability\" , \"h245.redundancyEncodingCapability\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"SEQUENCE_SIZE_1_256_OF_RedundancyEncodingCapability\" , HFILL }\n }\n , {\n & hf_h245_redundancyEncodingCapability_item , {\n \"RedundancyEncodingCapability\" , \"h245.RedundancyEncodingCapability_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_logicalChannelSwitchingCapability , {\n \"logicalChannelSwitchingCapability\" , \"h245.logicalChannelSwitchingCapability\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_t120DynamicPortCapability , {\n \"t120DynamicPortCapability\" , \"h245.t120DynamicPortCapability\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_h261aVideoPacketization , {\n \"h261aVideoPacketization\" , \"h245.h261aVideoPacketization\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_rtpPayloadTypes , {\n \"rtpPayloadType\" , \"h245.rtpPayloadType\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"SEQUENCE_SIZE_1_256_OF_RTPPayloadType\" , HFILL }\n }\n , {\n & hf_h245_rtpPayloadTypes_item , {\n \"RTPPayloadType\" , \"h245.RTPPayloadType_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_qosMode , {\n \"qosMode\" , \"h245.qosMode\" , FT_UINT32 , BASE_DEC , VALS ( h245_QOSMode_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_tokenRate , {\n \"tokenRate\" , \"h245.tokenRate\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_4294967295\" , HFILL }\n }\n , {\n & hf_h245_bucketSize , {\n \"bucketSize\" , \"h245.bucketSize\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_4294967295\" , HFILL }\n }\n , {\n & hf_h245_peakRate , {\n \"peakRate\" , \"h245.peakRate\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_4294967295\" , HFILL }\n }\n , {\n & hf_h245_minPoliced , {\n \"minPoliced\" , \"h245.minPoliced\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_4294967295\" , HFILL }\n }\n , {\n & hf_h245_maxPktSize , {\n \"maxPktSize\" , \"h245.maxPktSize\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_4294967295\" , HFILL }\n }\n , {\n & hf_h245_guaranteedQOS , {\n \"guaranteedQOS\" , \"h245.guaranteedQOS_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_controlledLoad , {\n \"controlledLoad\" , \"h245.controlledLoad_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_maxNTUSize , {\n \"maxNTUSize\" , \"h245.maxNTUSize\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_65535\" , HFILL }\n }\n , {\n & hf_h245_atmUBR , {\n \"atmUBR\" , \"h245.atmUBR\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_atmrtVBR , {\n \"atmrtVBR\" , \"h245.atmrtVBR\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_atmnrtVBR , {\n \"atmnrtVBR\" , \"h245.atmnrtVBR\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_atmABR , {\n \"atmABR\" , \"h245.atmABR\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_atmCBR , {\n \"atmCBR\" , \"h245.atmCBR\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_nonStandardParameter , {\n \"nonStandardParameter\" , \"h245.nonStandardParameter_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_value , {\n \"value\" , \"h245.value\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_255\" , HFILL }\n }\n , {\n & hf_h245_servicePrioritySignalled , {\n \"servicePrioritySignalled\" , \"h245.servicePrioritySignalled\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_servicePriorityValue , {\n \"servicePriorityValue\" , \"h245.servicePriorityValue_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_serviceClass , {\n \"serviceClass\" , \"h245.serviceClass\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_4095\" , HFILL }\n }\n , {\n & hf_h245_serviceSubclass , {\n \"serviceSubclass\" , \"h245.serviceSubclass\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_255\" , HFILL }\n }\n , {\n & hf_h245_desired , {\n \"desired\" , \"h245.desired_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_required , {\n \"required\" , \"h245.required_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_class0 , {\n \"class0\" , \"h245.class0_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_class1 , {\n \"class1\" , \"h245.class1_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_class2 , {\n \"class2\" , \"h245.class2_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_class3 , {\n \"class3\" , \"h245.class3_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_class4 , {\n \"class4\" , \"h245.class4_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_class5 , {\n \"class5\" , \"h245.class5_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_qosType , {\n \"qosType\" , \"h245.qosType\" , FT_UINT32 , BASE_DEC , VALS ( h245_QOSType_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_qosClass , {\n \"qosClass\" , \"h245.qosClass\" , FT_UINT32 , BASE_DEC , VALS ( h245_QOSClass_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_averageRate , {\n \"averageRate\" , \"h245.averageRate\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_4294967295\" , HFILL }\n }\n , {\n & hf_h245_burst , {\n \"burst\" , \"h245.burst\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_4294967295\" , HFILL }\n }\n , {\n & hf_h245_rsvpParameters , {\n \"rsvpParameters\" , \"h245.rsvpParameters_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_atmParameters , {\n \"atmParameters\" , \"h245.atmParameters_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_localQoS , {\n \"localQoS\" , \"h245.localQoS\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_genericTransportParameters , {\n \"genericTransportParameters\" , \"h245.genericTransportParameters_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_servicePriority , {\n \"servicePriority\" , \"h245.servicePriority_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_authorizationParameter , {\n \"authorizationParameter\" , \"h245.authorizationParameter_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"AuthorizationParameters\" , HFILL }\n }\n , {\n & hf_h245_qosDescriptor , {\n \"qosDescriptor\" , \"h245.qosDescriptor_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_dscpValue , {\n \"dscpValue\" , \"h245.dscpValue\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_63\" , HFILL }\n }\n , {\n & hf_h245_ip_UDP , {\n \"ip-UDP\" , \"h245.ip_UDP_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_ip_TCP , {\n \"ip-TCP\" , \"h245.ip_TCP_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_atm_AAL5_UNIDIR , {\n \"atm-AAL5-UNIDIR\" , \"h245.atm_AAL5_UNIDIR_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_atm_AAL5_BIDIR , {\n \"atm-AAL5-BIDIR\" , \"h245.atm_AAL5_BIDIR_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_atm_AAL5_compressed , {\n \"atm-AAL5-compressed\" , \"h245.atm_AAL5_compressed_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_variable_delta , {\n \"variable-delta\" , \"h245.variable_delta\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_mediaTransport , {\n \"mediaTransport\" , \"h245.mediaTransport\" , FT_UINT32 , BASE_DEC , VALS ( h245_MediaTransportType_vals ) , 0 , \"MediaTransportType\" , HFILL }\n }\n , {\n & hf_h245_qOSCapabilities , {\n \"qOSCapabilities\" , \"h245.qOSCapabilities\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"SEQUENCE_SIZE_1_256_OF_QOSCapability\" , HFILL }\n }\n , {\n & hf_h245_qOSCapabilities_item , {\n \"QOSCapability\" , \"h245.QOSCapability_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_mediaChannelCapabilities , {\n \"mediaChannelCapabilities\" , \"h245.mediaChannelCapabilities\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"SEQUENCE_SIZE_1_256_OF_MediaChannelCapability\" , HFILL }\n }\n , {\n & hf_h245_mediaChannelCapabilities_item , {\n \"MediaChannelCapability\" , \"h245.MediaChannelCapability_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_redundancyEncodingMethod , {\n \"redundancyEncodingMethod\" , \"h245.redundancyEncodingMethod\" , FT_UINT32 , BASE_DEC , VALS ( h245_RedundancyEncodingMethod_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_primaryEncoding , {\n \"primaryEncoding\" , \"h245.primaryEncoding\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"CapabilityTableEntryNumber\" , HFILL }\n }\n , {\n & hf_h245_secondaryEncodingCapability , {\n \"secondaryEncoding\" , \"h245.secondaryEncoding\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"SEQUENCE_SIZE_1_256_OF_CapabilityTableEntryNumber\" , HFILL }\n }\n , {\n & hf_h245_secondaryEncodingCapability_item , {\n \"CapabilityTableEntryNumber\" , \"h245.CapabilityTableEntryNumber\" , FT_UINT32 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_rtpAudioRedundancyEncoding , {\n \"rtpAudioRedundancyEncoding\" , \"h245.rtpAudioRedundancyEncoding_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_rtpH263VideoRedundancyEncoding , {\n \"rtpH263VideoRedundancyEncoding\" , \"h245.rtpH263VideoRedundancyEncoding_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_numberOfThreads , {\n \"numberOfThreads\" , \"h245.numberOfThreads\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_16\" , HFILL }\n }\n , {\n & hf_h245_framesBetweenSyncPoints , {\n \"framesBetweenSyncPoints\" , \"h245.framesBetweenSyncPoints\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_256\" , HFILL }\n }\n , {\n & hf_h245_frameToThreadMapping , {\n \"frameToThreadMapping\" , \"h245.frameToThreadMapping\" , FT_UINT32 , BASE_DEC , VALS ( h245_T_frameToThreadMapping_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_roundrobin , {\n \"roundrobin\" , \"h245.roundrobin_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_custom , {\n \"custom\" , \"h245.custom\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"SEQUENCE_SIZE_1_256_OF_RTPH263VideoRedundancyFrameMapping\" , HFILL }\n }\n , {\n & hf_h245_custom_item , {\n \"RTPH263VideoRedundancyFrameMapping\" , \"h245.RTPH263VideoRedundancyFrameMapping_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_containedThreads , {\n \"containedThreads\" , \"h245.containedThreads\" , FT_UINT32 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_containedThreads_item , {\n \"containedThreads item\" , \"h245.containedThreads_item\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_15\" , HFILL }\n }\n , {\n & hf_h245_threadNumber , {\n \"threadNumber\" , \"h245.threadNumber\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_15\" , HFILL }\n }\n , {\n & hf_h245_frameSequence , {\n \"frameSequence\" , \"h245.frameSequence\" , FT_UINT32 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_frameSequence_item , {\n \"frameSequence item\" , \"h245.frameSequence_item\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_255\" , HFILL }\n }\n , {\n & hf_h245_multicastCapability , {\n \"multicastCapability\" , \"h245.multicastCapability\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_multiUniCastConference , {\n \"multiUniCastConference\" , \"h245.multiUniCastConference\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_mediaDistributionCapability , {\n \"mediaDistributionCapability\" , \"h245.mediaDistributionCapability\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"SEQUENCE_OF_MediaDistributionCapability\" , HFILL }\n }\n , {\n & hf_h245_mediaDistributionCapability_item , {\n \"MediaDistributionCapability\" , \"h245.MediaDistributionCapability_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_centralizedControl , {\n \"centralizedControl\" , \"h245.centralizedControl\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_distributedControl , {\n \"distributedControl\" , \"h245.distributedControl\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_centralizedAudio , {\n \"centralizedAudio\" , \"h245.centralizedAudio\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_distributedAudio , {\n \"distributedAudio\" , \"h245.distributedAudio\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_centralizedVideo , {\n \"centralizedVideo\" , \"h245.centralizedVideo\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_distributedVideo , {\n \"distributedVideo\" , \"h245.distributedVideo\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_centralizedData , {\n \"centralizedData\" , \"h245.centralizedData\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"SEQUENCE_OF_DataApplicationCapability\" , HFILL }\n }\n , {\n & hf_h245_centralizedData_item , {\n \"DataApplicationCapability\" , \"h245.DataApplicationCapability_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_distributedData , {\n \"distributedData\" , \"h245.distributedData\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"SEQUENCE_OF_DataApplicationCapability\" , HFILL }\n }\n , {\n & hf_h245_distributedData_item , {\n \"DataApplicationCapability\" , \"h245.DataApplicationCapability_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_h261VideoCapability , {\n \"h261VideoCapability\" , \"h245.h261VideoCapability_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_h262VideoCapability , {\n \"h262VideoCapability\" , \"h245.h262VideoCapability_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_h263VideoCapability , {\n \"h263VideoCapability\" , \"h245.h263VideoCapability_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_is11172VideoCapability , {\n \"is11172VideoCapability\" , \"h245.is11172VideoCapability_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_genericVideoCapability , {\n \"genericVideoCapability\" , \"h245.genericVideoCapability_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"GenericCapability\" , HFILL }\n }\n , {\n & hf_h245_extendedVideoCapability , {\n \"extendedVideoCapability\" , \"h245.extendedVideoCapability_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_videoCapability , {\n \"videoCapability\" , \"h245.videoCapability\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"SEQUENCE_OF_VideoCapability\" , HFILL }\n }\n , {\n & hf_h245_videoCapability_item , {\n \"VideoCapability\" , \"h245.VideoCapability\" , FT_UINT32 , BASE_DEC , VALS ( h245_VideoCapability_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_videoCapabilityExtension , {\n \"videoCapabilityExtension\" , \"h245.videoCapabilityExtension\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"SEQUENCE_OF_GenericCapability\" , HFILL }\n }\n , {\n & hf_h245_videoCapabilityExtension_item , {\n \"GenericCapability\" , \"h245.GenericCapability_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_qcifMPI_1_4 , {\n \"qcifMPI\" , \"h245.qcifMPI\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_4\" , HFILL }\n }\n , {\n & hf_h245_cifMPI_1_4 , {\n \"cifMPI\" , \"h245.cifMPI\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_4\" , HFILL }\n }\n , {\n & hf_h245_temporalSpatialTradeOffCapability , {\n \"temporalSpatialTradeOffCapability\" , \"h245.temporalSpatialTradeOffCapability\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_maxBitRate_1_19200 , {\n \"maxBitRate\" , \"h245.maxBitRate\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_19200\" , HFILL }\n }\n , {\n & hf_h245_stillImageTransmission , {\n \"stillImageTransmission\" , \"h245.stillImageTransmission\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_videoBadMBsCap , {\n \"videoBadMBsCap\" , \"h245.videoBadMBsCap\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_profileAndLevel_SPatML , {\n \"profileAndLevel-SPatML\" , \"h245.profileAndLevel_SPatML\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_profileAndLevel_MPatLL , {\n \"profileAndLevel-MPatLL\" , \"h245.profileAndLevel_MPatLL\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_profileAndLevel_MPatML , {\n \"profileAndLevel-MPatML\" , \"h245.profileAndLevel_MPatML\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_profileAndLevel_MPatH_14 , {\n \"profileAndLevel-MPatH-14\" , \"h245.profileAndLevel_MPatH_14\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_profileAndLevel_MPatHL , {\n \"profileAndLevel-MPatHL\" , \"h245.profileAndLevel_MPatHL\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_profileAndLevel_SNRatLL , {\n \"profileAndLevel-SNRatLL\" , \"h245.profileAndLevel_SNRatLL\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_profileAndLevel_SNRatML , {\n \"profileAndLevel-SNRatML\" , \"h245.profileAndLevel_SNRatML\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_profileAndLevel_SpatialatH_14 , {\n \"profileAndLevel-SpatialatH-14\" , \"h245.profileAndLevel_SpatialatH_14\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_profileAndLevel_HPatML , {\n \"profileAndLevel-HPatML\" , \"h245.profileAndLevel_HPatML\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_profileAndLevel_HPatH_14 , {\n \"profileAndLevel-HPatH-14\" , \"h245.profileAndLevel_HPatH_14\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_profileAndLevel_HPatHL , {\n \"profileAndLevel-HPatHL\" , \"h245.profileAndLevel_HPatHL\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_videoBitRate , {\n \"videoBitRate\" , \"h245.videoBitRate\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_1073741823\" , HFILL }\n }\n , {\n & hf_h245_vbvBufferSize , {\n \"vbvBufferSize\" , \"h245.vbvBufferSize\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_262143\" , HFILL }\n }\n , {\n & hf_h245_samplesPerLine , {\n \"samplesPerLine\" , \"h245.samplesPerLine\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_16383\" , HFILL }\n }\n , {\n & hf_h245_linesPerFrame , {\n \"linesPerFrame\" , \"h245.linesPerFrame\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_16383\" , HFILL }\n }\n , {\n & hf_h245_framesPerSecond , {\n \"framesPerSecond\" , \"h245.framesPerSecond\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_15\" , HFILL }\n }\n , {\n & hf_h245_luminanceSampleRate , {\n \"luminanceSampleRate\" , \"h245.luminanceSampleRate\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_4294967295\" , HFILL }\n }\n , {\n & hf_h245_sqcifMPI_1_32 , {\n \"sqcifMPI\" , \"h245.sqcifMPI\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_32\" , HFILL }\n }\n , {\n & hf_h245_qcifMPI , {\n \"qcifMPI\" , \"h245.qcifMPI\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_32\" , HFILL }\n }\n , {\n & hf_h245_cifMPI , {\n \"cifMPI\" , \"h245.cifMPI\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_32\" , HFILL }\n }\n , {\n & hf_h245_cif4MPI_1_32 , {\n \"cif4MPI\" , \"h245.cif4MPI\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_32\" , HFILL }\n }\n , {\n & hf_h245_cif16MPI_1_32 , {\n \"cif16MPI\" , \"h245.cif16MPI\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_32\" , HFILL }\n }\n , {\n & hf_h245_maxBitRate , {\n \"maxBitRate\" , \"h245.maxBitRate\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_192400\" , HFILL }\n }\n , {\n & hf_h245_unrestrictedVector , {\n \"unrestrictedVector\" , \"h245.unrestrictedVector\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_arithmeticCoding , {\n \"arithmeticCoding\" , \"h245.arithmeticCoding\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_advancedPrediction , {\n \"advancedPrediction\" , \"h245.advancedPrediction\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_pbFrames , {\n \"pbFrames\" , \"h245.pbFrames\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_hrd_B , {\n \"hrd-B\" , \"h245.hrd_B\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_524287\" , HFILL }\n }\n , {\n & hf_h245_bppMaxKb , {\n \"bppMaxKb\" , \"h245.bppMaxKb\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_65535\" , HFILL }\n }\n , {\n & hf_h245_slowSqcifMPI , {\n \"slowSqcifMPI\" , \"h245.slowSqcifMPI\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_3600\" , HFILL }\n }\n , {\n & hf_h245_slowQcifMPI , {\n \"slowQcifMPI\" , \"h245.slowQcifMPI\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_3600\" , HFILL }\n }\n , {\n & hf_h245_slowCifMPI , {\n \"slowCifMPI\" , \"h245.slowCifMPI\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_3600\" , HFILL }\n }\n , {\n & hf_h245_slowCif4MPI , {\n \"slowCif4MPI\" , \"h245.slowCif4MPI\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_3600\" , HFILL }\n }\n , {\n & hf_h245_slowCif16MPI , {\n \"slowCif16MPI\" , \"h245.slowCif16MPI\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_3600\" , HFILL }\n }\n , {\n & hf_h245_errorCompensation , {\n \"errorCompensation\" , \"h245.errorCompensation\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_enhancementLayerInfo , {\n \"enhancementLayerInfo\" , \"h245.enhancementLayerInfo_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_h263Options , {\n \"h263Options\" , \"h245.h263Options_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_baseBitRateConstrained , {\n \"baseBitRateConstrained\" , \"h245.baseBitRateConstrained\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_snrEnhancement , {\n \"snrEnhancement\" , \"h245.snrEnhancement\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"SET_SIZE_1_14_OF_EnhancementOptions\" , HFILL }\n }\n , {\n & hf_h245_snrEnhancement_item , {\n \"EnhancementOptions\" , \"h245.EnhancementOptions_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_spatialEnhancement , {\n \"spatialEnhancement\" , \"h245.spatialEnhancement\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"SET_SIZE_1_14_OF_EnhancementOptions\" , HFILL }\n }\n , {\n & hf_h245_spatialEnhancement_item , {\n \"EnhancementOptions\" , \"h245.EnhancementOptions_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_bPictureEnhancement , {\n \"bPictureEnhancement\" , \"h245.bPictureEnhancement\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"SET_SIZE_1_14_OF_BEnhancementParameters\" , HFILL }\n }\n , {\n & hf_h245_bPictureEnhancement_item , {\n \"BEnhancementParameters\" , \"h245.BEnhancementParameters_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_enhancementOptions , {\n \"enhancementOptions\" , \"h245.enhancementOptions_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_numberOfBPictures , {\n \"numberOfBPictures\" , \"h245.numberOfBPictures\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_64\" , HFILL }\n }\n , {\n & hf_h245_advancedIntraCodingMode , {\n \"advancedIntraCodingMode\" , \"h245.advancedIntraCodingMode\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_deblockingFilterMode , {\n \"deblockingFilterMode\" , \"h245.deblockingFilterMode\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_improvedPBFramesMode , {\n \"improvedPBFramesMode\" , \"h245.improvedPBFramesMode\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_unlimitedMotionVectors , {\n \"unlimitedMotionVectors\" , \"h245.unlimitedMotionVectors\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_fullPictureFreeze , {\n \"fullPictureFreeze\" , \"h245.fullPictureFreeze\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_partialPictureFreezeAndRelease , {\n \"partialPictureFreezeAndRelease\" , \"h245.partialPictureFreezeAndRelease\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_resizingPartPicFreezeAndRelease , {\n \"resizingPartPicFreezeAndRelease\" , \"h245.resizingPartPicFreezeAndRelease\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_fullPictureSnapshot , {\n \"fullPictureSnapshot\" , \"h245.fullPictureSnapshot\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_partialPictureSnapshot , {\n \"partialPictureSnapshot\" , \"h245.partialPictureSnapshot\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_videoSegmentTagging , {\n \"videoSegmentTagging\" , \"h245.videoSegmentTagging\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_progressiveRefinement , {\n \"progressiveRefinement\" , \"h245.progressiveRefinement\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_dynamicPictureResizingByFour , {\n \"dynamicPictureResizingByFour\" , \"h245.dynamicPictureResizingByFour\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_dynamicPictureResizingSixteenthPel , {\n \"dynamicPictureResizingSixteenthPel\" , \"h245.dynamicPictureResizingSixteenthPel\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_dynamicWarpingHalfPel , {\n \"dynamicWarpingHalfPel\" , \"h245.dynamicWarpingHalfPel\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_dynamicWarpingSixteenthPel , {\n \"dynamicWarpingSixteenthPel\" , \"h245.dynamicWarpingSixteenthPel\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_independentSegmentDecoding , {\n \"independentSegmentDecoding\" , \"h245.independentSegmentDecoding\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_slicesInOrder_NonRect , {\n \"slicesInOrder-NonRect\" , \"h245.slicesInOrder_NonRect\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_slicesInOrder_Rect , {\n \"slicesInOrder-Rect\" , \"h245.slicesInOrder_Rect\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_slicesNoOrder_NonRect , {\n \"slicesNoOrder-NonRect\" , \"h245.slicesNoOrder_NonRect\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_slicesNoOrder_Rect , {\n \"slicesNoOrder-Rect\" , \"h245.slicesNoOrder_Rect\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_alternateInterVLCMode , {\n \"alternateInterVLCMode\" , \"h245.alternateInterVLCMode\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_modifiedQuantizationMode , {\n \"modifiedQuantizationMode\" , \"h245.modifiedQuantizationMode\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_reducedResolutionUpdate , {\n \"reducedResolutionUpdate\" , \"h245.reducedResolutionUpdate\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_transparencyParameters , {\n \"transparencyParameters\" , \"h245.transparencyParameters_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_separateVideoBackChannel , {\n \"separateVideoBackChannel\" , \"h245.separateVideoBackChannel\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_refPictureSelection , {\n \"refPictureSelection\" , \"h245.refPictureSelection_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_customPictureClockFrequency , {\n \"customPictureClockFrequency\" , \"h245.customPictureClockFrequency\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"SET_SIZE_1_16_OF_CustomPictureClockFrequency\" , HFILL }\n }\n , {\n & hf_h245_customPictureClockFrequency_item , {\n \"CustomPictureClockFrequency\" , \"h245.CustomPictureClockFrequency_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_customPictureFormat , {\n \"customPictureFormat\" , \"h245.customPictureFormat\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"SET_SIZE_1_16_OF_CustomPictureFormat\" , HFILL }\n }\n , {\n & hf_h245_customPictureFormat_item , {\n \"CustomPictureFormat\" , \"h245.CustomPictureFormat_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_modeCombos , {\n \"modeCombos\" , \"h245.modeCombos\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"SET_SIZE_1_16_OF_H263VideoModeCombos\" , HFILL }\n }\n , {\n & hf_h245_modeCombos_item , {\n \"H263VideoModeCombos\" , \"h245.H263VideoModeCombos_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_h263Version3Options , {\n \"h263Version3Options\" , \"h245.h263Version3Options_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_presentationOrder , {\n \"presentationOrder\" , \"h245.presentationOrder\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_256\" , HFILL }\n }\n , {\n & hf_h245_offset_x , {\n \"offset-x\" , \"h245.offset_x\" , FT_INT32 , BASE_DEC , NULL , 0 , \"INTEGER_M262144_262143\" , HFILL }\n }\n , {\n & hf_h245_offset_y , {\n \"offset-y\" , \"h245.offset_y\" , FT_INT32 , BASE_DEC , NULL , 0 , \"INTEGER_M262144_262143\" , HFILL }\n }\n , {\n & hf_h245_scale_x , {\n \"scale-x\" , \"h245.scale_x\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_255\" , HFILL }\n }\n , {\n & hf_h245_scale_y , {\n \"scale-y\" , \"h245.scale_y\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_255\" , HFILL }\n }\n , {\n & hf_h245_additionalPictureMemory , {\n \"additionalPictureMemory\" , \"h245.additionalPictureMemory_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_sqcifAdditionalPictureMemory , {\n \"sqcifAdditionalPictureMemory\" , \"h245.sqcifAdditionalPictureMemory\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_256\" , HFILL }\n }\n , {\n & hf_h245_qcifAdditionalPictureMemory , {\n \"qcifAdditionalPictureMemory\" , \"h245.qcifAdditionalPictureMemory\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_256\" , HFILL }\n }\n , {\n & hf_h245_cifAdditionalPictureMemory , {\n \"cifAdditionalPictureMemory\" , \"h245.cifAdditionalPictureMemory\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_256\" , HFILL }\n }\n , {\n & hf_h245_cif4AdditionalPictureMemory , {\n \"cif4AdditionalPictureMemory\" , \"h245.cif4AdditionalPictureMemory\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_256\" , HFILL }\n }\n , {\n & hf_h245_cif16AdditionalPictureMemory , {\n \"cif16AdditionalPictureMemory\" , \"h245.cif16AdditionalPictureMemory\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_256\" , HFILL }\n }\n , {\n & hf_h245_bigCpfAdditionalPictureMemory , {\n \"bigCpfAdditionalPictureMemory\" , \"h245.bigCpfAdditionalPictureMemory\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_256\" , HFILL }\n }\n , {\n & hf_h245_videoMux , {\n \"videoMux\" , \"h245.videoMux\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_videoBackChannelSend , {\n \"videoBackChannelSend\" , \"h245.videoBackChannelSend\" , FT_UINT32 , BASE_DEC , VALS ( h245_T_videoBackChannelSend_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_none , {\n \"none\" , \"h245.none_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_ackMessageOnly , {\n \"ackMessageOnly\" , \"h245.ackMessageOnly_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_nackMessageOnly , {\n \"nackMessageOnly\" , \"h245.nackMessageOnly_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_ackOrNackMessageOnly , {\n \"ackOrNackMessageOnly\" , \"h245.ackOrNackMessageOnly_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_ackAndNackMessage , {\n \"ackAndNackMessage\" , \"h245.ackAndNackMessage_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_enhancedReferencePicSelect , {\n \"enhancedReferencePicSelect\" , \"h245.enhancedReferencePicSelect_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_subPictureRemovalParameters , {\n \"subPictureRemovalParameters\" , \"h245.subPictureRemovalParameters_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_mpuHorizMBs , {\n \"mpuHorizMBs\" , \"h245.mpuHorizMBs\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_128\" , HFILL }\n }\n , {\n & hf_h245_mpuVertMBs , {\n \"mpuVertMBs\" , \"h245.mpuVertMBs\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_72\" , HFILL }\n }\n , {\n & hf_h245_mpuTotalNumber , {\n \"mpuTotalNumber\" , \"h245.mpuTotalNumber\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_65536\" , HFILL }\n }\n , {\n & hf_h245_clockConversionCode , {\n \"clockConversionCode\" , \"h245.clockConversionCode\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1000_1001\" , HFILL }\n }\n , {\n & hf_h245_clockDivisor , {\n \"clockDivisor\" , \"h245.clockDivisor\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_127\" , HFILL }\n }\n , {\n & hf_h245_sqcifMPI , {\n \"sqcifMPI\" , \"h245.sqcifMPI\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_2048\" , HFILL }\n }\n , {\n & hf_h245_qcifMPI_1_2048 , {\n \"qcifMPI\" , \"h245.qcifMPI\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_2048\" , HFILL }\n }\n , {\n & hf_h245_cifMPI2_1_2048 , {\n \"cifMPI\" , \"h245.cifMPI\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_2048\" , HFILL }\n }\n , {\n & hf_h245_cif4MPI , {\n \"cif4MPI\" , \"h245.cif4MPI\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_2048\" , HFILL }\n }\n , {\n & hf_h245_cif16MPI , {\n \"cif16MPI\" , \"h245.cif16MPI\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_2048\" , HFILL }\n }\n , {\n & hf_h245_maxCustomPictureWidth , {\n \"maxCustomPictureWidth\" , \"h245.maxCustomPictureWidth\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_2048\" , HFILL }\n }\n , {\n & hf_h245_maxCustomPictureHeight , {\n \"maxCustomPictureHeight\" , \"h245.maxCustomPictureHeight\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_2048\" , HFILL }\n }\n , {\n & hf_h245_minCustomPictureWidth , {\n \"minCustomPictureWidth\" , \"h245.minCustomPictureWidth\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_2048\" , HFILL }\n }\n , {\n & hf_h245_minCustomPictureHeight , {\n \"minCustomPictureHeight\" , \"h245.minCustomPictureHeight\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_2048\" , HFILL }\n }\n , {\n & hf_h245_mPI , {\n \"mPI\" , \"h245.mPI_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_standardMPI , {\n \"standardMPI\" , \"h245.standardMPI\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_31\" , HFILL }\n }\n , {\n & hf_h245_customPCF , {\n \"customPCF\" , \"h245.customPCF\" , FT_UINT32 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_customPCF_item , {\n \"customPCF item\" , \"h245.customPCF_item_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_customMPI , {\n \"customMPI\" , \"h245.customMPI\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_2048\" , HFILL }\n }\n , {\n & hf_h245_pixelAspectInformation , {\n \"pixelAspectInformation\" , \"h245.pixelAspectInformation\" , FT_UINT32 , BASE_DEC , VALS ( h245_T_pixelAspectInformation_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_anyPixelAspectRatio , {\n \"anyPixelAspectRatio\" , \"h245.anyPixelAspectRatio\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_pixelAspectCode , {\n \"pixelAspectCode\" , \"h245.pixelAspectCode\" , FT_UINT32 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_pixelAspectCode_item , {\n \"pixelAspectCode item\" , \"h245.pixelAspectCode_item\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_14\" , HFILL }\n }\n , {\n & hf_h245_extendedPAR , {\n \"extendedPAR\" , \"h245.extendedPAR\" , FT_UINT32 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_extendedPAR_item , {\n \"extendedPAR item\" , \"h245.extendedPAR_item_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_width , {\n \"width\" , \"h245.width\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_255\" , HFILL }\n }\n , {\n & hf_h245_height , {\n \"height\" , \"h245.height\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_255\" , HFILL }\n }\n , {\n & hf_h245_h263VideoUncoupledModes , {\n \"h263VideoUncoupledModes\" , \"h245.h263VideoUncoupledModes_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"H263ModeComboFlags\" , HFILL }\n }\n , {\n & hf_h245_h263VideoCoupledModes , {\n \"h263VideoCoupledModes\" , \"h245.h263VideoCoupledModes\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"SET_SIZE_1_16_OF_H263ModeComboFlags\" , HFILL }\n }\n , {\n & hf_h245_h263VideoCoupledModes_item , {\n \"H263ModeComboFlags\" , \"h245.H263ModeComboFlags_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_referencePicSelect , {\n \"referencePicSelect\" , \"h245.referencePicSelect\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_enhancedReferencePicSelectBool , {\n \"enhancedReferencePicSelect\" , \"h245.enhancedReferencePicSelect\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_dataPartitionedSlices , {\n \"dataPartitionedSlices\" , \"h245.dataPartitionedSlices\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_fixedPointIDCT0 , {\n \"fixedPointIDCT0\" , \"h245.fixedPointIDCT0\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_interlacedFields , {\n \"interlacedFields\" , \"h245.interlacedFields\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_currentPictureHeaderRepetition , {\n \"currentPictureHeaderRepetition\" , \"h245.currentPictureHeaderRepetition\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_previousPictureHeaderRepetition , {\n \"previousPictureHeaderRepetition\" , \"h245.previousPictureHeaderRepetition\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_nextPictureHeaderRepetition , {\n \"nextPictureHeaderRepetition\" , \"h245.nextPictureHeaderRepetition\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_pictureNumberBoolean , {\n \"pictureNumber\" , \"h245.pictureNumber\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_spareReferencePictures , {\n \"spareReferencePictures\" , \"h245.spareReferencePictures\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_constrainedBitstream , {\n \"constrainedBitstream\" , \"h245.constrainedBitstream\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_pictureRate , {\n \"pictureRate\" , \"h245.pictureRate\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_15\" , HFILL }\n }\n , {\n & hf_h245_g711Alaw64k , {\n \"g711Alaw64k\" , \"h245.g711Alaw64k\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_256\" , HFILL }\n }\n , {\n & hf_h245_g711Alaw56k , {\n \"g711Alaw56k\" , \"h245.g711Alaw56k\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_256\" , HFILL }\n }\n , {\n & hf_h245_g711Ulaw64k , {\n \"g711Ulaw64k\" , \"h245.g711Ulaw64k\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_256\" , HFILL }\n }\n , {\n & hf_h245_g711Ulaw56k , {\n \"g711Ulaw56k\" , \"h245.g711Ulaw56k\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_256\" , HFILL }\n }\n , {\n & hf_h245_g722_64k , {\n \"g722-64k\" , \"h245.g722_64k\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_256\" , HFILL }\n }\n , {\n & hf_h245_g722_56k , {\n \"g722-56k\" , \"h245.g722_56k\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_256\" , HFILL }\n }\n , {\n & hf_h245_g722_48k , {\n \"g722-48k\" , \"h245.g722_48k\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_256\" , HFILL }\n }\n , {\n & hf_h245_g7231 , {\n \"g7231\" , \"h245.g7231_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_maxAl_sduAudioFrames , {\n \"maxAl-sduAudioFrames\" , \"h245.maxAl_sduAudioFrames\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_256\" , HFILL }\n }\n , {\n & hf_h245_silenceSuppression , {\n \"silenceSuppression\" , \"h245.silenceSuppression\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_g728 , {\n \"g728\" , \"h245.g728\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_256\" , HFILL }\n }\n , {\n & hf_h245_g729 , {\n \"g729\" , \"h245.g729\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_256\" , HFILL }\n }\n , {\n & hf_h245_g729AnnexA , {\n \"g729AnnexA\" , \"h245.g729AnnexA\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_256\" , HFILL }\n }\n , {\n & hf_h245_is11172AudioCapability , {\n \"is11172AudioCapability\" , \"h245.is11172AudioCapability_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_is13818AudioCapability , {\n \"is13818AudioCapability\" , \"h245.is13818AudioCapability_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_g729wAnnexB , {\n \"g729wAnnexB\" , \"h245.g729wAnnexB\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_256\" , HFILL }\n }\n , {\n & hf_h245_g729AnnexAwAnnexB , {\n \"g729AnnexAwAnnexB\" , \"h245.g729AnnexAwAnnexB\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_256\" , HFILL }\n }\n , {\n & hf_h245_g7231AnnexCCapability , {\n \"g7231AnnexCCapability\" , \"h245.g7231AnnexCCapability_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_gsmFullRate , {\n \"gsmFullRate\" , \"h245.gsmFullRate_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"GSMAudioCapability\" , HFILL }\n }\n , {\n & hf_h245_gsmHalfRate , {\n \"gsmHalfRate\" , \"h245.gsmHalfRate_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"GSMAudioCapability\" , HFILL }\n }\n , {\n & hf_h245_gsmEnhancedFullRate , {\n \"gsmEnhancedFullRate\" , \"h245.gsmEnhancedFullRate_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"GSMAudioCapability\" , HFILL }\n }\n , {\n & hf_h245_genericAudioCapability , {\n \"genericAudioCapability\" , \"h245.genericAudioCapability_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"GenericCapability\" , HFILL }\n }\n , {\n & hf_h245_g729Extensions , {\n \"g729Extensions\" , \"h245.g729Extensions_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_vbd , {\n \"vbd\" , \"h245.vbd_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"VBDCapability\" , HFILL }\n }\n , {\n & hf_h245_audioTelephonyEvent , {\n \"audioTelephonyEvent\" , \"h245.audioTelephonyEvent_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"NoPTAudioTelephonyEventCapability\" , HFILL }\n }\n , {\n & hf_h245_audioTone , {\n \"audioTone\" , \"h245.audioTone_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"NoPTAudioToneCapability\" , HFILL }\n }\n , {\n & hf_h245_audioUnit , {\n \"audioUnit\" , \"h245.audioUnit\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_256\" , HFILL }\n }\n , {\n & hf_h245_annexA , {\n \"annexA\" , \"h245.annexA\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_annexB , {\n \"annexB\" , \"h245.annexB\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_annexD , {\n \"annexD\" , \"h245.annexD\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_annexE , {\n \"annexE\" , \"h245.annexE\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_annexF , {\n \"annexF\" , \"h245.annexF\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_annexG , {\n \"annexG\" , \"h245.annexG\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_annexH , {\n \"annexH\" , \"h245.annexH\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_highRateMode0 , {\n \"highRateMode0\" , \"h245.highRateMode0\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_27_78\" , HFILL }\n }\n , {\n & hf_h245_highRateMode1 , {\n \"highRateMode1\" , \"h245.highRateMode1\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_27_78\" , HFILL }\n }\n , {\n & hf_h245_lowRateMode0 , {\n \"lowRateMode0\" , \"h245.lowRateMode0\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_23_66\" , HFILL }\n }\n , {\n & hf_h245_lowRateMode1 , {\n \"lowRateMode1\" , \"h245.lowRateMode1\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_23_66\" , HFILL }\n }\n , {\n & hf_h245_sidMode0 , {\n \"sidMode0\" , \"h245.sidMode0\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_6_17\" , HFILL }\n }\n , {\n & hf_h245_sidMode1 , {\n \"sidMode1\" , \"h245.sidMode1\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_6_17\" , HFILL }\n }\n , {\n & hf_h245_g723AnnexCAudioMode , {\n \"g723AnnexCAudioMode\" , \"h245.g723AnnexCAudioMode_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_audioLayer1 , {\n \"audioLayer1\" , \"h245.audioLayer1\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_audioLayer2 , {\n \"audioLayer2\" , \"h245.audioLayer2\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_audioLayer3 , {\n \"audioLayer3\" , \"h245.audioLayer3\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_audioSampling32k , {\n \"audioSampling32k\" , \"h245.audioSampling32k\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_audioSampling44k1 , {\n \"audioSampling44k1\" , \"h245.audioSampling44k1\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_audioSampling48k , {\n \"audioSampling48k\" , \"h245.audioSampling48k\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_singleChannel , {\n \"singleChannel\" , \"h245.singleChannel\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_twoChannels , {\n \"twoChannels\" , \"h245.twoChannels\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_bitRate_1_448 , {\n \"bitRate\" , \"h245.bitRate\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_448\" , HFILL }\n }\n , {\n & hf_h245_audioSampling16k , {\n \"audioSampling16k\" , \"h245.audioSampling16k\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_audioSampling22k05 , {\n \"audioSampling22k05\" , \"h245.audioSampling22k05\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_audioSampling24k , {\n \"audioSampling24k\" , \"h245.audioSampling24k\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_threeChannels2_1 , {\n \"threeChannels2-1\" , \"h245.threeChannels2_1\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_threeChannels3_0 , {\n \"threeChannels3-0\" , \"h245.threeChannels3_0\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_fourChannels2_0_2_0 , {\n \"fourChannels2-0-2-0\" , \"h245.fourChannels2_0_2_0\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_fourChannels2_2 , {\n \"fourChannels2-2\" , \"h245.fourChannels2_2\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_fourChannels3_1 , {\n \"fourChannels3-1\" , \"h245.fourChannels3_1\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_fiveChannels3_0_2_0 , {\n \"fiveChannels3-0-2-0\" , \"h245.fiveChannels3_0_2_0\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_fiveChannels3_2 , {\n \"fiveChannels3-2\" , \"h245.fiveChannels3_2\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_lowFrequencyEnhancement , {\n \"lowFrequencyEnhancement\" , \"h245.lowFrequencyEnhancement\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_multilingual , {\n \"multilingual\" , \"h245.multilingual\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_bitRate2_1_1130 , {\n \"bitRate\" , \"h245.bitRate\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_1130\" , HFILL }\n }\n , {\n & hf_h245_audioUnitSize , {\n \"audioUnitSize\" , \"h245.audioUnitSize\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_256\" , HFILL }\n }\n , {\n & hf_h245_comfortNoise , {\n \"comfortNoise\" , \"h245.comfortNoise\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_scrambled , {\n \"scrambled\" , \"h245.scrambled\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_vbd_cap_type , {\n \"type\" , \"h245.type\" , FT_UINT32 , BASE_DEC , VALS ( h245_AudioCapability_vals ) , 0 , \"AudioCapability\" , HFILL }\n }\n , {\n & hf_h245_t120 , {\n \"t120\" , \"h245.t120\" , FT_UINT32 , BASE_DEC , VALS ( DataProtocolCapability_vals ) , 0 , \"DataProtocolCapability\" , HFILL }\n }\n , {\n & hf_h245_dsm_cc , {\n \"dsm-cc\" , \"h245.dsm_cc\" , FT_UINT32 , BASE_DEC , VALS ( DataProtocolCapability_vals ) , 0 , \"DataProtocolCapability\" , HFILL }\n }\n , {\n & hf_h245_userData , {\n \"userData\" , \"h245.userData\" , FT_UINT32 , BASE_DEC , VALS ( DataProtocolCapability_vals ) , 0 , \"DataProtocolCapability\" , HFILL }\n }\n , {\n & hf_h245_t84 , {\n \"t84\" , \"h245.t84_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_t84Protocol , {\n \"t84Protocol\" , \"h245.t84Protocol\" , FT_UINT32 , BASE_DEC , VALS ( DataProtocolCapability_vals ) , 0 , \"DataProtocolCapability\" , HFILL }\n }\n , {\n & hf_h245_t84Profile , {\n \"t84Profile\" , \"h245.t84Profile\" , FT_UINT32 , BASE_DEC , VALS ( h245_T84Profile_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_t434 , {\n \"t434\" , \"h245.t434\" , FT_UINT32 , BASE_DEC , VALS ( DataProtocolCapability_vals ) , 0 , \"DataProtocolCapability\" , HFILL }\n }\n , {\n & hf_h245_h224 , {\n \"h224\" , \"h245.h224\" , FT_UINT32 , BASE_DEC , VALS ( DataProtocolCapability_vals ) , 0 , \"DataProtocolCapability\" , HFILL }\n }\n , {\n & hf_h245_nlpidProtocol , {\n \"nlpidProtocol\" , \"h245.nlpidProtocol\" , FT_UINT32 , BASE_DEC , VALS ( DataProtocolCapability_vals ) , 0 , \"DataProtocolCapability\" , HFILL }\n }\n , {\n & hf_h245_nlpidData , {\n \"nlpidData\" , \"h245.nlpidData\" , FT_BYTES , BASE_NONE , NULL , 0 , \"OCTET_STRING\" , HFILL }\n }\n , {\n & hf_h245_nlpid , {\n \"nlpid\" , \"h245.nlpid_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_dsvdControl , {\n \"dsvdControl\" , \"h245.dsvdControl_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_h222DataPartitioning , {\n \"h222DataPartitioning\" , \"h245.h222DataPartitioning\" , FT_UINT32 , BASE_DEC , VALS ( DataProtocolCapability_vals ) , 0 , \"DataProtocolCapability\" , HFILL }\n }\n , {\n & hf_h245_t30fax , {\n \"t30fax\" , \"h245.t30fax\" , FT_UINT32 , BASE_DEC , VALS ( DataProtocolCapability_vals ) , 0 , \"DataProtocolCapability\" , HFILL }\n }\n , {\n & hf_h245_t140 , {\n \"t140\" , \"h245.t140\" , FT_UINT32 , BASE_DEC , VALS ( DataProtocolCapability_vals ) , 0 , \"DataProtocolCapability\" , HFILL }\n }\n , {\n & hf_h245_t38fax , {\n \"t38fax\" , \"h245.t38fax_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_t38FaxProtocol , {\n \"t38FaxProtocol\" , \"h245.t38FaxProtocol\" , FT_UINT32 , BASE_DEC , VALS ( DataProtocolCapability_vals ) , 0 , \"DataProtocolCapability\" , HFILL }\n }\n , {\n & hf_h245_t38FaxProfile , {\n \"t38FaxProfile\" , \"h245.t38FaxProfile_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_genericDataCapability , {\n \"genericDataCapability\" , \"h245.genericDataCapability_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"GenericCapability\" , HFILL }\n }\n , {\n & hf_h245_application , {\n \"application\" , \"h245.application\" , FT_UINT32 , BASE_DEC , VALS ( h245_Application_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_maxBitRate2_0_4294967295 , {\n \"maxBitRate\" , \"h245.maxBitRate\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_4294967295\" , HFILL }\n }\n , {\n & hf_h245_v14buffered , {\n \"v14buffered\" , \"h245.v14buffered_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_v42lapm , {\n \"v42lapm\" , \"h245.v42lapm_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_hdlcFrameTunnelling , {\n \"hdlcFrameTunnelling\" , \"h245.hdlcFrameTunnelling_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_h310SeparateVCStack , {\n \"h310SeparateVCStack\" , \"h245.h310SeparateVCStack_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_h310SingleVCStack , {\n \"h310SingleVCStack\" , \"h245.h310SingleVCStack_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_transparent , {\n \"transparent\" , \"h245.transparent_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_segmentationAndReassembly , {\n \"segmentationAndReassembly\" , \"h245.segmentationAndReassembly_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_hdlcFrameTunnelingwSAR , {\n \"hdlcFrameTunnelingwSAR\" , \"h245.hdlcFrameTunnelingwSAR_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_v120 , {\n \"v120\" , \"h245.v120_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_separateLANStack , {\n \"separateLANStack\" , \"h245.separateLANStack_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_v76wCompression , {\n \"v76wCompression\" , \"h245.v76wCompression\" , FT_UINT32 , BASE_DEC , VALS ( h245_T_v76wCompression_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_transmitCompression , {\n \"transmitCompression\" , \"h245.transmitCompression\" , FT_UINT32 , BASE_DEC , VALS ( h245_CompressionType_vals ) , 0 , \"CompressionType\" , HFILL }\n }\n , {\n & hf_h245_receiveCompression , {\n \"receiveCompression\" , \"h245.receiveCompression\" , FT_UINT32 , BASE_DEC , VALS ( h245_CompressionType_vals ) , 0 , \"CompressionType\" , HFILL }\n }\n , {\n & hf_h245_transmitAndReceiveCompression , {\n \"transmitAndReceiveCompression\" , \"h245.transmitAndReceiveCompression\" , FT_UINT32 , BASE_DEC , VALS ( h245_CompressionType_vals ) , 0 , \"CompressionType\" , HFILL }\n }\n , {\n & hf_h245_tcp , {\n \"tcp\" , \"h245.tcp_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_udp , {\n \"udp\" , \"h245.udp_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_v42bis , {\n \"v42bis\" , \"h245.v42bis_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_numberOfCodewords , {\n \"numberOfCodewords\" , \"h245.numberOfCodewords\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_65536\" , HFILL }\n }\n , {\n & hf_h245_maximumStringLength , {\n \"maximumStringLength\" , \"h245.maximumStringLength\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_256\" , HFILL }\n }\n , {\n & hf_h245_t84Unrestricted , {\n \"t84Unrestricted\" , \"h245.t84Unrestricted_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_t84Restricted , {\n \"t84Restricted\" , \"h245.t84Restricted_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_qcif_bool , {\n \"qcif\" , \"h245.qcif\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_cif_bool , {\n \"cif\" , \"h245.cif\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_ccir601Seq , {\n \"ccir601Seq\" , \"h245.ccir601Seq\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_ccir601Prog , {\n \"ccir601Prog\" , \"h245.ccir601Prog\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_hdtvSeq , {\n \"hdtvSeq\" , \"h245.hdtvSeq\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_hdtvProg , {\n \"hdtvProg\" , \"h245.hdtvProg\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_g3FacsMH200x100 , {\n \"g3FacsMH200x100\" , \"h245.g3FacsMH200x100\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_g3FacsMH200x200 , {\n \"g3FacsMH200x200\" , \"h245.g3FacsMH200x200\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_g4FacsMMR200x100 , {\n \"g4FacsMMR200x100\" , \"h245.g4FacsMMR200x100\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_g4FacsMMR200x200 , {\n \"g4FacsMMR200x200\" , \"h245.g4FacsMMR200x200\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_jbig200x200Seq , {\n \"jbig200x200Seq\" , \"h245.jbig200x200Seq\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_jbig200x200Prog , {\n \"jbig200x200Prog\" , \"h245.jbig200x200Prog\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_jbig300x300Seq , {\n \"jbig300x300Seq\" , \"h245.jbig300x300Seq\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_jbig300x300Prog , {\n \"jbig300x300Prog\" , \"h245.jbig300x300Prog\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_digPhotoLow , {\n \"digPhotoLow\" , \"h245.digPhotoLow\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_digPhotoMedSeq , {\n \"digPhotoMedSeq\" , \"h245.digPhotoMedSeq\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_digPhotoMedProg , {\n \"digPhotoMedProg\" , \"h245.digPhotoMedProg\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_digPhotoHighSeq , {\n \"digPhotoHighSeq\" , \"h245.digPhotoHighSeq\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_digPhotoHighProg , {\n \"digPhotoHighProg\" , \"h245.digPhotoHighProg\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_fillBitRemoval , {\n \"fillBitRemoval\" , \"h245.fillBitRemoval\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_transcodingJBIG , {\n \"transcodingJBIG\" , \"h245.transcodingJBIG\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_transcodingMMR , {\n \"transcodingMMR\" , \"h245.transcodingMMR\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_version , {\n \"version\" , \"h245.version\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_255\" , HFILL }\n }\n , {\n & hf_h245_t38FaxRateManagement , {\n \"t38FaxRateManagement\" , \"h245.t38FaxRateManagement\" , FT_UINT32 , BASE_DEC , VALS ( h245_T38FaxRateManagement_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_t38FaxUdpOptions , {\n \"t38FaxUdpOptions\" , \"h245.t38FaxUdpOptions_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_t38FaxTcpOptions , {\n \"t38FaxTcpOptions\" , \"h245.t38FaxTcpOptions_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_localTCF , {\n \"localTCF\" , \"h245.localTCF_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_transferredTCF , {\n \"transferredTCF\" , \"h245.transferredTCF_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_t38FaxMaxBuffer , {\n \"t38FaxMaxBuffer\" , \"h245.t38FaxMaxBuffer\" , FT_INT32 , BASE_DEC , NULL , 0 , \"INTEGER\" , HFILL }\n }\n , {\n & hf_h245_t38FaxMaxDatagram , {\n \"t38FaxMaxDatagram\" , \"h245.t38FaxMaxDatagram\" , FT_INT32 , BASE_DEC , NULL , 0 , \"INTEGER\" , HFILL }\n }\n , {\n & hf_h245_t38FaxUdpEC , {\n \"t38FaxUdpEC\" , \"h245.t38FaxUdpEC\" , FT_UINT32 , BASE_DEC , VALS ( h245_T_t38FaxUdpEC_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_t38UDPFEC , {\n \"t38UDPFEC\" , \"h245.t38UDPFEC_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_t38UDPRedundancy , {\n \"t38UDPRedundancy\" , \"h245.t38UDPRedundancy_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_t38TCPBidirectionalMode , {\n \"t38TCPBidirectionalMode\" , \"h245.t38TCPBidirectionalMode\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_encryptionCapability , {\n \"encryptionCapability\" , \"h245.encryptionCapability\" , FT_UINT32 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_authenticationCapability , {\n \"authenticationCapability\" , \"h245.authenticationCapability_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_integrityCapability , {\n \"integrityCapability\" , \"h245.integrityCapability_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_genericH235SecurityCapability , {\n \"genericH235SecurityCapability\" , \"h245.genericH235SecurityCapability_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"GenericCapability\" , HFILL }\n }\n , {\n & hf_h245_EncryptionCapability_item , {\n \"MediaEncryptionAlgorithm\" , \"h245.MediaEncryptionAlgorithm\" , FT_UINT32 , BASE_DEC , VALS ( h245_MediaEncryptionAlgorithm_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_algorithm , {\n \"algorithm\" , \"h245.algorithm\" , FT_OID , BASE_NONE , NULL , 0 , \"OBJECT_IDENTIFIER\" , HFILL }\n }\n , {\n & hf_h245_antiSpamAlgorithm , {\n \"antiSpamAlgorithm\" , \"h245.antiSpamAlgorithm\" , FT_OID , BASE_NONE , NULL , 0 , \"OBJECT_IDENTIFIER\" , HFILL }\n }\n , {\n & hf_h245_ui_nonStandard , {\n \"nonStandard\" , \"h245.nonStandard\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"SEQUENCE_SIZE_1_16_OF_NonStandardParameter\" , HFILL }\n }\n , {\n & hf_h245_ui_nonStandard_item , {\n \"NonStandardParameter\" , \"h245.NonStandardParameter_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_basicString , {\n \"basicString\" , \"h245.basicString_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_iA5String , {\n \"iA5String\" , \"h245.iA5String_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_generalString , {\n \"generalString\" , \"h245.generalString_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_dtmf , {\n \"dtmf\" , \"h245.dtmf_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_hookflash , {\n \"hookflash\" , \"h245.hookflash_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_extendedAlphanumericFlag , {\n \"extendedAlphanumeric\" , \"h245.extendedAlphanumeric_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_encryptedBasicString , {\n \"encryptedBasicString\" , \"h245.encryptedBasicString_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_encryptedIA5String , {\n \"encryptedIA5String\" , \"h245.encryptedIA5String_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_encryptedGeneralString , {\n \"encryptedGeneralString\" , \"h245.encryptedGeneralString_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_secureDTMF , {\n \"secureDTMF\" , \"h245.secureDTMF_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_genericUserInputCapability , {\n \"genericUserInputCapability\" , \"h245.genericUserInputCapability_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"GenericCapability\" , HFILL }\n }\n , {\n & hf_h245_nonStandardParams , {\n \"nonStandardData\" , \"h245.nonStandardData\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"SEQUENCE_OF_NonStandardParameter\" , HFILL }\n }\n , {\n & hf_h245_nonStandardParams_item , {\n \"NonStandardParameter\" , \"h245.NonStandardParameter_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_chairControlCapability , {\n \"chairControlCapability\" , \"h245.chairControlCapability\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_videoIndicateMixingCapability , {\n \"videoIndicateMixingCapability\" , \"h245.videoIndicateMixingCapability\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_multipointVisualizationCapability , {\n \"multipointVisualizationCapability\" , \"h245.multipointVisualizationCapability\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_capabilityIdentifier , {\n \"capabilityIdentifier\" , \"h245.capabilityIdentifier\" , FT_UINT32 , BASE_DEC , VALS ( h245_CapabilityIdentifier_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_collapsing , {\n \"collapsing\" , \"h245.collapsing\" , FT_UINT32 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_collapsing_item , {\n \"collapsing item\" , \"h245.collapsing_item_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_nonCollapsing , {\n \"nonCollapsing\" , \"h245.nonCollapsing\" , FT_UINT32 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_nonCollapsing_item , {\n \"nonCollapsing item\" , \"h245.nonCollapsing_item_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_nonCollapsingRaw , {\n \"nonCollapsingRaw\" , \"h245.nonCollapsingRaw\" , FT_BYTES , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_transport , {\n \"transport\" , \"h245.transport\" , FT_UINT32 , BASE_DEC , VALS ( DataProtocolCapability_vals ) , 0 , \"DataProtocolCapability\" , HFILL }\n }\n , {\n & hf_h245_standardOid , {\n \"standard\" , \"h245.standard\" , FT_OID , BASE_NONE , NULL , 0 , \"T_standardOid\" , HFILL }\n }\n , {\n & hf_h245_h221NonStandard , {\n \"h221NonStandard\" , \"h245.h221NonStandard_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"NonStandardParameter\" , HFILL }\n }\n , {\n & hf_h245_uuid , {\n \"uuid\" , \"h245.uuid\" , FT_BYTES , BASE_NONE , NULL , 0 , \"OCTET_STRING_SIZE_16\" , HFILL }\n }\n , {\n & hf_h245_domainBased , {\n \"domainBased\" , \"h245.domainBased\" , FT_STRING , BASE_NONE , NULL , 0 , \"IA5String_SIZE_1_64\" , HFILL }\n }\n , {\n & hf_h245_parameterIdentifier , {\n \"parameterIdentifier\" , \"h245.parameterIdentifier\" , FT_UINT32 , BASE_DEC , VALS ( h245_ParameterIdentifier_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_parameterValue , {\n \"parameterValue\" , \"h245.parameterValue\" , FT_UINT32 , BASE_DEC , VALS ( h245_ParameterValue_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_supersedes , {\n \"supersedes\" , \"h245.supersedes\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"SEQUENCE_OF_ParameterIdentifier\" , HFILL }\n }\n , {\n & hf_h245_supersedes_item , {\n \"ParameterIdentifier\" , \"h245.ParameterIdentifier\" , FT_UINT32 , BASE_DEC , VALS ( h245_ParameterIdentifier_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_standard , {\n \"standard\" , \"h245.standard\" , FT_UINT32 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_logical , {\n \"logical\" , \"h245.logical_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_booleanArray , {\n \"booleanArray\" , \"h245.booleanArray\" , FT_UINT32 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_unsignedMin , {\n \"unsignedMin\" , \"h245.unsignedMin\" , FT_UINT32 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_unsignedMax , {\n \"unsignedMax\" , \"h245.unsignedMax\" , FT_UINT32 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_unsigned32Min , {\n \"unsigned32Min\" , \"h245.unsigned32Min\" , FT_UINT32 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_unsigned32Max , {\n \"unsigned32Max\" , \"h245.unsigned32Max\" , FT_UINT32 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_octetString , {\n \"octetString\" , \"h245.octetString\" , FT_UINT32 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_genericParameters , {\n \"genericParameter\" , \"h245.genericParameter\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"SEQUENCE_OF_GenericParameter\" , HFILL }\n }\n , {\n & hf_h245_genericParameters_item , {\n \"GenericParameter\" , \"h245.GenericParameter_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_multiplexFormat , {\n \"multiplexFormat\" , \"h245.multiplexFormat\" , FT_UINT32 , BASE_DEC , VALS ( h245_MultiplexFormat_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_controlOnMuxStream , {\n \"controlOnMuxStream\" , \"h245.controlOnMuxStream\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_capabilityOnMuxStream , {\n \"capabilityOnMuxStream\" , \"h245.capabilityOnMuxStream\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"SET_SIZE_1_256_OF_AlternativeCapabilitySet\" , HFILL }\n }\n , {\n & hf_h245_capabilityOnMuxStream_item , {\n \"AlternativeCapabilitySet\" , \"h245.AlternativeCapabilitySet\" , FT_UINT32 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_dynamicRTPPayloadType , {\n \"dynamicRTPPayloadType\" , \"h245.dynamicRTPPayloadType\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_96_127\" , HFILL }\n }\n , {\n & hf_h245_audioTelephoneEvent , {\n \"audioTelephoneEvent\" , \"h245.audioTelephoneEvent\" , FT_STRING , BASE_NONE , NULL , 0 , \"GeneralString\" , HFILL }\n }\n , {\n & hf_h245_capabilities , {\n \"capabilities\" , \"h245.capabilities\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"SET_SIZE_1_256_OF_AlternativeCapabilitySet\" , HFILL }\n }\n , {\n & hf_h245_capabilities_item , {\n \"AlternativeCapabilitySet\" , \"h245.AlternativeCapabilitySet\" , FT_UINT32 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_fecc_rfc2733 , {\n \"rfc2733\" , \"h245.rfc2733_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"FECC_rfc2733\" , HFILL }\n }\n , {\n & hf_h245_redundancyEncodingBool , {\n \"redundancyEncoding\" , \"h245.redundancyEncoding\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_separateStreamBool , {\n \"separateStream\" , \"h245.separateStream_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"T_separateStreamBool\" , HFILL }\n }\n , {\n & hf_h245_separatePort , {\n \"separatePort\" , \"h245.separatePort\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_samePortBool , {\n \"samePort\" , \"h245.samePort\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_protectedCapability , {\n \"protectedCapability\" , \"h245.protectedCapability\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"CapabilityTableEntryNumber\" , HFILL }\n }\n , {\n & hf_h245_fecScheme , {\n \"fecScheme\" , \"h245.fecScheme\" , FT_OID , BASE_NONE , NULL , 0 , \"OBJECT_IDENTIFIER\" , HFILL }\n }\n , {\n & hf_h245_rfc2733rfc2198 , {\n \"rfc2733rfc2198\" , \"h245.rfc2733rfc2198\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"MaxRedundancy\" , HFILL }\n }\n , {\n & hf_h245_rfc2733sameport , {\n \"rfc2733sameport\" , \"h245.rfc2733sameport\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"MaxRedundancy\" , HFILL }\n }\n , {\n & hf_h245_rfc2733diffport , {\n \"rfc2733diffport\" , \"h245.rfc2733diffport\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"MaxRedundancy\" , HFILL }\n }\n , {\n & hf_h245_rfc2733Format , {\n \"rfc2733Format\" , \"h245.rfc2733Format\" , FT_UINT32 , BASE_DEC , VALS ( h245_Rfc2733Format_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_olc_fw_lcn , {\n \"forwardLogicalChannelNumber\" , \"h245.forwardLogicalChannelNumber\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"OLC_fw_lcn\" , HFILL }\n }\n , {\n & hf_h245_forwardLogicalChannelParameters , {\n \"forwardLogicalChannelParameters\" , \"h245.forwardLogicalChannelParameters_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_portNumber , {\n \"portNumber\" , \"h245.portNumber\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_65535\" , HFILL }\n }\n , {\n & hf_h245_dataType , {\n \"dataType\" , \"h245.dataType\" , FT_UINT32 , BASE_DEC , VALS ( h245_DataType_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_olc_forw_multiplexParameters , {\n \"multiplexParameters\" , \"h245.multiplexParameters\" , FT_UINT32 , BASE_DEC , VALS ( h245_OLC_forw_multiplexParameters_vals ) , 0 , \"OLC_forw_multiplexParameters\" , HFILL }\n }\n , {\n & hf_h245_h222LogicalChannelParameters , {\n \"h222LogicalChannelParameters\" , \"h245.h222LogicalChannelParameters_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_olc_fw_h223_params , {\n \"h223LogicalChannelParameters\" , \"h245.h223LogicalChannelParameters_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"OLC_fw_h223_params\" , HFILL }\n }\n , {\n & hf_h245_v76LogicalChannelParameters , {\n \"v76LogicalChannelParameters\" , \"h245.v76LogicalChannelParameters_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_h2250LogicalChannelParameters , {\n \"h2250LogicalChannelParameters\" , \"h245.h2250LogicalChannelParameters_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_forwardLogicalChannelDependency , {\n \"forwardLogicalChannelDependency\" , \"h245.forwardLogicalChannelDependency\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"LogicalChannelNumber\" , HFILL }\n }\n , {\n & hf_h245_replacementFor , {\n \"replacementFor\" , \"h245.replacementFor\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"LogicalChannelNumber\" , HFILL }\n }\n , {\n & hf_h245_reverseLogicalChannelParameters , {\n \"reverseLogicalChannelParameters\" , \"h245.reverseLogicalChannelParameters_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"OLC_reverseLogicalChannelParameters\" , HFILL }\n }\n , {\n & hf_h245_olc_rev_multiplexParameter , {\n \"multiplexParameters\" , \"h245.multiplexParameters\" , FT_UINT32 , BASE_DEC , VALS ( h245_OLC_rev_multiplexParameters_vals ) , 0 , \"OLC_rev_multiplexParameters\" , HFILL }\n }\n , {\n & hf_h245_olc_rev_h223_params , {\n \"h223LogicalChannelParameters\" , \"h245.h223LogicalChannelParameters_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"OLC_rev_h223_params\" , HFILL }\n }\n , {\n & hf_h245_reverseLogicalChannelDependency , {\n \"reverseLogicalChannelDependency\" , \"h245.reverseLogicalChannelDependency\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"LogicalChannelNumber\" , HFILL }\n }\n , {\n & hf_h245_separateStack , {\n \"separateStack\" , \"h245.separateStack_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"NetworkAccessParameters\" , HFILL }\n }\n , {\n & hf_h245_encryptionSync , {\n \"encryptionSync\" , \"h245.encryptionSync_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_distribution , {\n \"distribution\" , \"h245.distribution\" , FT_UINT32 , BASE_DEC , VALS ( h245_T_distribution_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_unicast , {\n \"unicast\" , \"h245.unicast_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_multicast , {\n \"multicast\" , \"h245.multicast_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_networkAddress , {\n \"networkAddress\" , \"h245.networkAddress\" , FT_UINT32 , BASE_DEC , VALS ( h245_T_networkAddress_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_q2931Address , {\n \"q2931Address\" , \"h245.q2931Address_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_e164Address , {\n \"e164Address\" , \"h245.e164Address\" , FT_STRING , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_localAreaAddress , {\n \"localAreaAddress\" , \"h245.localAreaAddress\" , FT_UINT32 , BASE_DEC , VALS ( h245_TransportAddress_vals ) , 0 , \"TransportAddress\" , HFILL }\n }\n , {\n & hf_h245_associateConference , {\n \"associateConference\" , \"h245.associateConference\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_externalReference , {\n \"externalReference\" , \"h245.externalReference\" , FT_BYTES , BASE_NONE , NULL , 0 , \"OCTET_STRING_SIZE_1_255\" , HFILL }\n }\n , {\n & hf_h245_t120SetupProcedure , {\n \"t120SetupProcedure\" , \"h245.t120SetupProcedure\" , FT_UINT32 , BASE_DEC , VALS ( h245_T_t120SetupProcedure_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_originateCall , {\n \"originateCall\" , \"h245.originateCall_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_waitForCall , {\n \"waitForCall\" , \"h245.waitForCall_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_issueQuery , {\n \"issueQuery\" , \"h245.issueQuery_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_address , {\n \"address\" , \"h245.address\" , FT_UINT32 , BASE_DEC , VALS ( h245_T_address_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_internationalNumber , {\n \"internationalNumber\" , \"h245.internationalNumber\" , FT_STRING , BASE_NONE , NULL , 0 , \"NumericString_SIZE_1_16\" , HFILL }\n }\n , {\n & hf_h245_nsapAddress , {\n \"nsapAddress\" , \"h245.nsapAddress\" , FT_BYTES , BASE_NONE , NULL , 0 , \"OCTET_STRING_SIZE_1_20\" , HFILL }\n }\n , {\n & hf_h245_subaddress , {\n \"subaddress\" , \"h245.subaddress\" , FT_BYTES , BASE_NONE , NULL , 0 , \"OCTET_STRING_SIZE_1_20\" , HFILL }\n }\n , {\n & hf_h245_audioHeaderPresent , {\n \"audioHeaderPresent\" , \"h245.audioHeaderPresent\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_nullData , {\n \"nullData\" , \"h245.nullData_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_videoData , {\n \"videoData\" , \"h245.videoData\" , FT_UINT32 , BASE_DEC , VALS ( h245_VideoCapability_vals ) , 0 , \"VideoCapability\" , HFILL }\n }\n , {\n & hf_h245_audioData , {\n \"audioData\" , \"h245.audioData\" , FT_UINT32 , BASE_DEC , VALS ( h245_AudioCapability_vals ) , 0 , \"AudioCapability\" , HFILL }\n }\n , {\n & hf_h245_data , {\n \"data\" , \"h245.data_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"DataApplicationCapability\" , HFILL }\n }\n , {\n & hf_h245_encryptionData , {\n \"encryptionData\" , \"h245.encryptionData\" , FT_UINT32 , BASE_DEC , VALS ( h245_EncryptionMode_vals ) , 0 , \"EncryptionMode\" , HFILL }\n }\n , {\n & hf_h245_h235Control , {\n \"h235Control\" , \"h245.h235Control_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"NonStandardParameter\" , HFILL }\n }\n , {\n & hf_h245_h235Media , {\n \"h235Media\" , \"h245.h235Media_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_multiplexedStream , {\n \"multiplexedStream\" , \"h245.multiplexedStream_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"MultiplexedStreamParameter\" , HFILL }\n }\n , {\n & hf_h245_redundancyEncoding , {\n \"redundancyEncoding\" , \"h245.redundancyEncoding_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_multiplePayloadStream , {\n \"multiplePayloadStream\" , \"h245.multiplePayloadStream_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_depFec , {\n \"depFec\" , \"h245.depFec\" , FT_UINT32 , BASE_DEC , VALS ( h245_DepFECData_vals ) , 0 , \"DepFECData\" , HFILL }\n }\n , {\n & hf_h245_fec , {\n \"fec\" , \"h245.fec\" , FT_UINT32 , BASE_DEC , VALS ( h245_FECData_vals ) , 0 , \"FECData\" , HFILL }\n }\n , {\n & hf_h245_mediaType , {\n \"mediaType\" , \"h245.mediaType\" , FT_UINT32 , BASE_DEC , VALS ( h245_T_mediaType_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_resourceID , {\n \"resourceID\" , \"h245.resourceID\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_65535\" , HFILL }\n }\n , {\n & hf_h245_subChannelID , {\n \"subChannelID\" , \"h245.subChannelID\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_8191\" , HFILL }\n }\n , {\n & hf_h245_pcr_pid , {\n \"pcr-pid\" , \"h245.pcr_pid\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_8191\" , HFILL }\n }\n , {\n & hf_h245_programDescriptors , {\n \"programDescriptors\" , \"h245.programDescriptors\" , FT_BYTES , BASE_NONE , NULL , 0 , \"OCTET_STRING\" , HFILL }\n }\n , {\n & hf_h245_streamDescriptors , {\n \"streamDescriptors\" , \"h245.streamDescriptors\" , FT_BYTES , BASE_NONE , NULL , 0 , \"OCTET_STRING\" , HFILL }\n }\n , {\n & hf_h245_adaptationLayerType , {\n \"adaptationLayerType\" , \"h245.adaptationLayerType\" , FT_UINT32 , BASE_DEC , VALS ( h245_T_adaptationLayerType_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_h223_al_type_al1Framed , {\n \"al1Framed\" , \"h245.al1Framed_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"T_h223_al_type_al1Framed\" , HFILL }\n }\n , {\n & hf_h245_h223_al_type_al1NotFramed , {\n \"al1NotFramed\" , \"h245.al1NotFramed_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"T_h223_al_type_al1NotFramed\" , HFILL }\n }\n , {\n & hf_h245_h223_al_type_al2WithoutSequenceNumbers , {\n \"al2WithoutSequenceNumbers\" , \"h245.al2WithoutSequenceNumbers_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"T_h223_al_type_al2WithoutSequenceNumbers\" , HFILL }\n }\n , {\n & hf_h245_h223_al_type_al2WithSequenceNumbers , {\n \"al2WithSequenceNumbers\" , \"h245.al2WithSequenceNumbers_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"T_h223_al_type_al2WithSequenceNumbers\" , HFILL }\n }\n , {\n & hf_h245_controlFieldOctets , {\n \"controlFieldOctets\" , \"h245.controlFieldOctets\" , FT_UINT32 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_al3_sendBufferSize , {\n \"sendBufferSize\" , \"h245.sendBufferSize\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"T_al3_sendBufferSize\" , HFILL }\n }\n , {\n & hf_h245_h223_al_type_al3 , {\n \"al3\" , \"h245.al3_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"T_h223_al_type_al3\" , HFILL }\n }\n , {\n & hf_h245_h223_al_type_al1M , {\n \"al1M\" , \"h245.al1M_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"T_h223_al_type_al1M\" , HFILL }\n }\n , {\n & hf_h245_h223_al_type_al2M , {\n \"al2M\" , \"h245.al2M_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"T_h223_al_type_al2M\" , HFILL }\n }\n , {\n & hf_h245_h223_al_type_al3M , {\n \"al3M\" , \"h245.al3M_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"T_h223_al_type_al3M\" , HFILL }\n }\n , {\n & hf_h245_h223_lc_segmentableFlag , {\n \"segmentableFlag\" , \"h245.segmentableFlag\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"T_h223_lc_segmentableFlag\" , HFILL }\n }\n , {\n & hf_h245_transferMode , {\n \"transferMode\" , \"h245.transferMode\" , FT_UINT32 , BASE_DEC , VALS ( h245_T_transferMode_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_framed , {\n \"framed\" , \"h245.framed_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_unframed , {\n \"unframed\" , \"h245.unframed_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_aL1HeaderFEC , {\n \"headerFEC\" , \"h245.headerFEC\" , FT_UINT32 , BASE_DEC , VALS ( h245_AL1HeaderFEC_vals ) , 0 , \"AL1HeaderFEC\" , HFILL }\n }\n , {\n & hf_h245_sebch16_7 , {\n \"sebch16-7\" , \"h245.sebch16_7_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_golay24_12 , {\n \"golay24-12\" , \"h245.golay24_12_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_crcLength2 , {\n \"crcLength\" , \"h245.crcLength\" , FT_UINT32 , BASE_DEC , VALS ( h245_AL1CrcLength_vals ) , 0 , \"AL1CrcLength\" , HFILL }\n }\n , {\n & hf_h245_crc4bit , {\n \"crc4bit\" , \"h245.crc4bit_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_crc12bit , {\n \"crc12bit\" , \"h245.crc12bit_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_crc20bit , {\n \"crc20bit\" , \"h245.crc20bit_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_crc28bit , {\n \"crc28bit\" , \"h245.crc28bit_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_crc8bit , {\n \"crc8bit\" , \"h245.crc8bit_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_crc16bit , {\n \"crc16bit\" , \"h245.crc16bit_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_crc32bit , {\n \"crc32bit\" , \"h245.crc32bit_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_crcNotUsed , {\n \"crcNotUsed\" , \"h245.crcNotUsed_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_rcpcCodeRate , {\n \"rcpcCodeRate\" , \"h245.rcpcCodeRate\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_8_32\" , HFILL }\n }\n , {\n & hf_h245_noArq , {\n \"noArq\" , \"h245.noArq_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_typeIArq , {\n \"typeIArq\" , \"h245.typeIArq_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"H223AnnexCArqParameters\" , HFILL }\n }\n , {\n & hf_h245_typeIIArq , {\n \"typeIIArq\" , \"h245.typeIIArq_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"H223AnnexCArqParameters\" , HFILL }\n }\n , {\n & hf_h245_arqType , {\n \"arqType\" , \"h245.arqType\" , FT_UINT32 , BASE_DEC , VALS ( h245_ArqType_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_alsduSplitting , {\n \"alsduSplitting\" , \"h245.alsduSplitting\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_rsCodeCorrection , {\n \"rsCodeCorrection\" , \"h245.rsCodeCorrection\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_127\" , HFILL }\n }\n , {\n & hf_h245_aL2HeaderFEC , {\n \"headerFEC\" , \"h245.headerFEC\" , FT_UINT32 , BASE_DEC , VALS ( h245_AL2HeaderFEC_vals ) , 0 , \"AL2HeaderFEC\" , HFILL }\n }\n , {\n & hf_h245_sebch16_5 , {\n \"sebch16-5\" , \"h245.sebch16_5_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_headerFormat , {\n \"headerFormat\" , \"h245.headerFormat\" , FT_UINT32 , BASE_DEC , VALS ( h245_T_headerFormat_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_crlength2 , {\n \"crcLength\" , \"h245.crcLength\" , FT_UINT32 , BASE_DEC , VALS ( h245_AL3CrcLength_vals ) , 0 , \"AL3CrcLength\" , HFILL }\n }\n , {\n & hf_h245_numberOfRetransmissions , {\n \"numberOfRetransmissions\" , \"h245.numberOfRetransmissions\" , FT_UINT32 , BASE_DEC , VALS ( h245_T_numberOfRetransmissions_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_finite , {\n \"finite\" , \"h245.finite\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_16\" , HFILL }\n }\n , {\n & hf_h245_infinite , {\n \"infinite\" , \"h245.infinite_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_sendBufferSize , {\n \"sendBufferSize\" , \"h245.sendBufferSize\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_16777215\" , HFILL }\n }\n , {\n & hf_h245_hdlcParameters , {\n \"hdlcParameters\" , \"h245.hdlcParameters_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"V76HDLCParameters\" , HFILL }\n }\n , {\n & hf_h245_suspendResume , {\n \"suspendResume\" , \"h245.suspendResume\" , FT_UINT32 , BASE_DEC , VALS ( h245_T_suspendResume_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_noSuspendResume , {\n \"noSuspendResume\" , \"h245.noSuspendResume_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_suspendResumewAddress , {\n \"suspendResumewAddress\" , \"h245.suspendResumewAddress_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_suspendResumewoAddress , {\n \"suspendResumewoAddress\" , \"h245.suspendResumewoAddress_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_uIH , {\n \"uIH\" , \"h245.uIH\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_v76_mode , {\n \"mode\" , \"h245.mode\" , FT_UINT32 , BASE_DEC , VALS ( h245_V76LCP_mode_vals ) , 0 , \"V76LCP_mode\" , HFILL }\n }\n , {\n & hf_h245_eRM , {\n \"eRM\" , \"h245.eRM_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_windowSize , {\n \"windowSize\" , \"h245.windowSize\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_127\" , HFILL }\n }\n , {\n & hf_h245_recovery , {\n \"recovery\" , \"h245.recovery\" , FT_UINT32 , BASE_DEC , VALS ( h245_T_recovery_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_rej , {\n \"rej\" , \"h245.rej_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_sREJ , {\n \"sREJ\" , \"h245.sREJ_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_mSREJ , {\n \"mSREJ\" , \"h245.mSREJ_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_uNERM , {\n \"uNERM\" , \"h245.uNERM_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_v75Parameters , {\n \"v75Parameters\" , \"h245.v75Parameters_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_crcLength , {\n \"crcLength\" , \"h245.crcLength\" , FT_UINT32 , BASE_DEC , VALS ( h245_CRCLength_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_n401 , {\n \"n401\" , \"h245.n401\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_4095\" , HFILL }\n }\n , {\n & hf_h245_loopbackTestProcedure , {\n \"loopbackTestProcedure\" , \"h245.loopbackTestProcedure\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_sessionID_0_255 , {\n \"sessionID\" , \"h245.sessionID\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_255\" , HFILL }\n }\n , {\n & hf_h245_associatedSessionID , {\n \"associatedSessionID\" , \"h245.associatedSessionID\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_255\" , HFILL }\n }\n , {\n & hf_h245_mediaChannel , {\n \"mediaChannel\" , \"h245.mediaChannel\" , FT_UINT32 , BASE_DEC , VALS ( h245_TransportAddress_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_mediaGuaranteedDelivery , {\n \"mediaGuaranteedDelivery\" , \"h245.mediaGuaranteedDelivery\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_mediaControlChannel , {\n \"mediaControlChannel\" , \"h245.mediaControlChannel\" , FT_UINT32 , BASE_DEC , VALS ( h245_TransportAddress_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_mediaControlGuaranteedDelivery , {\n \"mediaControlGuaranteedDelivery\" , \"h245.mediaControlGuaranteedDelivery\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_destination , {\n \"destination\" , \"h245.destination_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"TerminalLabel\" , HFILL }\n }\n , {\n & hf_h245_mediaPacketization , {\n \"mediaPacketization\" , \"h245.mediaPacketization\" , FT_UINT32 , BASE_DEC , VALS ( h245_T_mediaPacketization_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_h261aVideoPacketizationFlag , {\n \"h261aVideoPacketization\" , \"h245.h261aVideoPacketization_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_rtpPayloadType , {\n \"rtpPayloadType\" , \"h245.rtpPayloadType_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_source , {\n \"source\" , \"h245.source_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"TerminalLabel\" , HFILL }\n }\n , {\n & hf_h245_payloadDescriptor , {\n \"payloadDescriptor\" , \"h245.payloadDescriptor\" , FT_UINT32 , BASE_DEC , VALS ( h245_T_payloadDescriptor_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_rfc_number , {\n \"rfc-number\" , \"h245.rfc_number\" , FT_UINT32 , BASE_DEC , VALS ( h245_RFC_number_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_oid , {\n \"oid\" , \"h245.oid\" , FT_OID , BASE_NONE , NULL , 0 , \"OBJECT_IDENTIFIER\" , HFILL }\n }\n , {\n & hf_h245_rtpPayloadType_01 , {\n \"payloadType\" , \"h245.payloadType\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"T_rtpPayloadType\" , HFILL }\n }\n , {\n & hf_h245_secondaryEncoding , {\n \"secondaryEncoding\" , \"h245.secondaryEncoding\" , FT_UINT32 , BASE_DEC , VALS ( h245_DataType_vals ) , 0 , \"DataType\" , HFILL }\n }\n , {\n & hf_h245_rtpRedundancyEncoding , {\n \"rtpRedundancyEncoding\" , \"h245.rtpRedundancyEncoding_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_primary , {\n \"primary\" , \"h245.primary_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"RedundancyEncodingElement\" , HFILL }\n }\n , {\n & hf_h245_secondary , {\n \"secondary\" , \"h245.secondary\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"SEQUENCE_OF_RedundancyEncodingElement\" , HFILL }\n }\n , {\n & hf_h245_secondary_item , {\n \"RedundancyEncodingElement\" , \"h245.RedundancyEncodingElement_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_payloadType , {\n \"payloadType\" , \"h245.payloadType\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_127\" , HFILL }\n }\n , {\n & hf_h245_elements , {\n \"elements\" , \"h245.elements\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"SEQUENCE_OF_MultiplePayloadStreamElement\" , HFILL }\n }\n , {\n & hf_h245_elements_item , {\n \"MultiplePayloadStreamElement\" , \"h245.MultiplePayloadStreamElement_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_dep_rfc2733 , {\n \"rfc2733\" , \"h245.rfc2733_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"RFC2733Data\" , HFILL }\n }\n , {\n & hf_h245_fec_data_mode , {\n \"mode\" , \"h245.mode\" , FT_UINT32 , BASE_DEC , VALS ( h245_FECdata_mode_vals ) , 0 , \"FECdata_mode\" , HFILL }\n }\n , {\n & hf_h245_redundancyEncodingFlag , {\n \"redundancyEncoding\" , \"h245.redundancyEncoding_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_differentPort , {\n \"differentPort\" , \"h245.differentPort_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_protectedSessionID , {\n \"protectedSessionID\" , \"h245.protectedSessionID\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_255\" , HFILL }\n }\n , {\n & hf_h245_protectedPayloadType , {\n \"protectedPayloadType\" , \"h245.protectedPayloadType\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_127\" , HFILL }\n }\n , {\n & hf_h245_samePort , {\n \"samePort\" , \"h245.samePort_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_separateStream , {\n \"separateStream\" , \"h245.separateStream\" , FT_UINT32 , BASE_DEC , VALS ( h245_DepSeparateStream_vals ) , 0 , \"DepSeparateStream\" , HFILL }\n }\n , {\n & hf_h245_rfc2733 , {\n \"rfc2733\" , \"h245.rfc2733_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_pktMode , {\n \"pktMode\" , \"h245.pktMode\" , FT_UINT32 , BASE_DEC , VALS ( h245_T_pktMode_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_rfc2198coding , {\n \"rfc2198coding\" , \"h245.rfc2198coding_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_mode_rfc2733sameport , {\n \"rfc2733sameport\" , \"h245.rfc2733sameport_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"T_mode_rfc2733sameport\" , HFILL }\n }\n , {\n & hf_h245_mode_rfc2733diffport , {\n \"rfc2733diffport\" , \"h245.rfc2733diffport_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"T_mode_rfc2733diffport\" , HFILL }\n }\n , {\n & hf_h245_protectedChannel , {\n \"protectedChannel\" , \"h245.protectedChannel\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"LogicalChannelNumber\" , HFILL }\n }\n , {\n & hf_h245_unicastAddress , {\n \"unicastAddress\" , \"h245.unicastAddress\" , FT_UINT32 , BASE_DEC , VALS ( h245_UnicastAddress_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_multicastAddress , {\n \"multicastAddress\" , \"h245.multicastAddress\" , FT_UINT32 , BASE_DEC , VALS ( h245_MulticastAddress_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_iPAddress , {\n \"iPAddress\" , \"h245.iPAddress_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_ip4_network , {\n \"network\" , \"h245.network\" , FT_IPv4 , BASE_NONE , NULL , 0 , \"Ipv4_network\" , HFILL }\n }\n , {\n & hf_h245_tsapIdentifier , {\n \"tsapIdentifier\" , \"h245.tsapIdentifier\" , FT_UINT32 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_iPXAddress , {\n \"iPXAddress\" , \"h245.iPXAddress_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_node , {\n \"node\" , \"h245.node\" , FT_BYTES , BASE_NONE , NULL , 0 , \"OCTET_STRING_SIZE_6\" , HFILL }\n }\n , {\n & hf_h245_netnum , {\n \"netnum\" , \"h245.netnum\" , FT_BYTES , BASE_NONE , NULL , 0 , \"OCTET_STRING_SIZE_4\" , HFILL }\n }\n , {\n & hf_h245_ipx_tsapIdentifier , {\n \"tsapIdentifier\" , \"h245.tsapIdentifier\" , FT_BYTES , BASE_NONE , NULL , 0 , \"OCTET_STRING_SIZE_2\" , HFILL }\n }\n , {\n & hf_h245_iP6Address , {\n \"iP6Address\" , \"h245.iP6Address_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_ip6_network , {\n \"network\" , \"h245.network\" , FT_IPv6 , BASE_NONE , NULL , 0 , \"OCTET_STRING_SIZE_16\" , HFILL }\n }\n , {\n & hf_h245_ipv6_tsapIdentifier , {\n \"tsapIdentifier\" , \"h245.tsapIdentifier\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_65535\" , HFILL }\n }\n , {\n & hf_h245_netBios , {\n \"netBios\" , \"h245.netBios\" , FT_BYTES , BASE_NONE , NULL , 0 , \"OCTET_STRING_SIZE_16\" , HFILL }\n }\n , {\n & hf_h245_iPSourceRouteAddress , {\n \"iPSourceRouteAddress\" , \"h245.iPSourceRouteAddress_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_routing , {\n \"routing\" , \"h245.routing\" , FT_UINT32 , BASE_DEC , VALS ( h245_T_routing_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_strict , {\n \"strict\" , \"h245.strict_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_loose , {\n \"loose\" , \"h245.loose_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_network , {\n \"network\" , \"h245.network\" , FT_BYTES , BASE_NONE , NULL , 0 , \"OCTET_STRING_SIZE_4\" , HFILL }\n }\n , {\n & hf_h245_iPSrcRoute_tsapIdentifier , {\n \"tsapIdentifier\" , \"h245.tsapIdentifier\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_65535\" , HFILL }\n }\n , {\n & hf_h245_route , {\n \"route\" , \"h245.route\" , FT_UINT32 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_route_item , {\n \"route item\" , \"h245.route_item\" , FT_BYTES , BASE_NONE , NULL , 0 , \"OCTET_STRING_SIZE_4\" , HFILL }\n }\n , {\n & hf_h245_nsap , {\n \"nsap\" , \"h245.nsap\" , FT_BYTES , BASE_NONE , NULL , 0 , \"OCTET_STRING_SIZE_1_20\" , HFILL }\n }\n , {\n & hf_h245_nonStandardAddress , {\n \"nonStandardAddress\" , \"h245.nonStandardAddress_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"NonStandardParameter\" , HFILL }\n }\n , {\n & hf_h245_mIPAddress , {\n \"iPAddress\" , \"h245.iPAddress_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"MIPAddress\" , HFILL }\n }\n , {\n & hf_h245_mip4_network , {\n \"network\" , \"h245.network\" , FT_IPv4 , BASE_NONE , NULL , 0 , \"OCTET_STRING_SIZE_4\" , HFILL }\n }\n , {\n & hf_h245_multicast_tsapIdentifier , {\n \"tsapIdentifier\" , \"h245.tsapIdentifier\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_65535\" , HFILL }\n }\n , {\n & hf_h245_mIP6Address , {\n \"iP6Address\" , \"h245.iP6Address_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"MIP6Address\" , HFILL }\n }\n , {\n & hf_h245_mip6_network , {\n \"network\" , \"h245.network\" , FT_IPv6 , BASE_NONE , NULL , 0 , \"OCTET_STRING_SIZE_16\" , HFILL }\n }\n , {\n & hf_h245_multicast_IPv6_tsapIdentifier , {\n \"tsapIdentifier\" , \"h245.tsapIdentifier\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_65535\" , HFILL }\n }\n , {\n & hf_h245_synchFlag , {\n \"synchFlag\" , \"h245.synchFlag\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_255\" , HFILL }\n }\n , {\n & hf_h245_h235Key , {\n \"h235Key\" , \"h245.h235Key\" , FT_BYTES , BASE_NONE , NULL , 0 , \"OCTET_STRING_SIZE_1_65535\" , HFILL }\n }\n , {\n & hf_h245_escrowentry , {\n \"escrowentry\" , \"h245.escrowentry\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"SEQUENCE_SIZE_1_256_OF_EscrowData\" , HFILL }\n }\n , {\n & hf_h245_escrowentry_item , {\n \"EscrowData\" , \"h245.EscrowData_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_genericParameter , {\n \"genericParameter\" , \"h245.genericParameter_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_escrowID , {\n \"escrowID\" , \"h245.escrowID\" , FT_OID , BASE_NONE , NULL , 0 , \"OBJECT_IDENTIFIER\" , HFILL }\n }\n , {\n & hf_h245_escrowValue , {\n \"escrowValue\" , \"h245.escrowValue\" , FT_BYTES , BASE_NONE , NULL , 0 , \"BIT_STRING_SIZE_1_65535\" , HFILL }\n }\n , {\n & hf_h245_olc_ack_fw_lcn , {\n \"forwardLogicalChannelNumber\" , \"h245.forwardLogicalChannelNumber\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"OLC_ack_fw_lcn\" , HFILL }\n }\n , {\n & hf_h245_olc_ack_reverseLogicalChannelParameters , {\n \"reverseLogicalChannelParameters\" , \"h245.reverseLogicalChannelParameters_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"OLC_ack_reverseLogicalChannelParameters\" , HFILL }\n }\n , {\n & hf_h245_reverseLogicalChannelNumber , {\n \"reverseLogicalChannelNumber\" , \"h245.reverseLogicalChannelNumber\" , FT_UINT32 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_olc_ack_multiplexParameters , {\n \"multiplexParameters\" , \"h245.multiplexParameters\" , FT_UINT32 , BASE_DEC , VALS ( h245_T_olc_ack_multiplexParameters_vals ) , 0 , \"T_olc_ack_multiplexParameters\" , HFILL }\n }\n , {\n & hf_h245_forwardMultiplexAckParameters , {\n \"forwardMultiplexAckParameters\" , \"h245.forwardMultiplexAckParameters\" , FT_UINT32 , BASE_DEC , VALS ( h245_T_forwardMultiplexAckParameters_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_h2250LogicalChannelAckParameters , {\n \"h2250LogicalChannelAckParameters\" , \"h245.h2250LogicalChannelAckParameters_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_forwardLogicalChannelNumber , {\n \"forwardLogicalChannelNumber\" , \"h245.forwardLogicalChannelNumber\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"LogicalChannelNumber\" , HFILL }\n }\n , {\n & hf_h245_olc_rej_cause , {\n \"cause\" , \"h245.cause\" , FT_UINT32 , BASE_DEC , VALS ( h245_OpenLogicalChannelRejectCause_vals ) , 0 , \"OpenLogicalChannelRejectCause\" , HFILL }\n }\n , {\n & hf_h245_unsuitableReverseParameters , {\n \"unsuitableReverseParameters\" , \"h245.unsuitableReverseParameters_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_dataTypeNotSupported , {\n \"dataTypeNotSupported\" , \"h245.dataTypeNotSupported_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_dataTypeNotAvailable , {\n \"dataTypeNotAvailable\" , \"h245.dataTypeNotAvailable_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_unknownDataType , {\n \"unknownDataType\" , \"h245.unknownDataType_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_dataTypeALCombinationNotSupported , {\n \"dataTypeALCombinationNotSupported\" , \"h245.dataTypeALCombinationNotSupported_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_multicastChannelNotAllowed , {\n \"multicastChannelNotAllowed\" , \"h245.multicastChannelNotAllowed_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_insufficientBandwidth , {\n \"insufficientBandwidth\" , \"h245.insufficientBandwidth_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_separateStackEstablishmentFailed , {\n \"separateStackEstablishmentFailed\" , \"h245.separateStackEstablishmentFailed_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_invalidSessionID , {\n \"invalidSessionID\" , \"h245.invalidSessionID_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_masterSlaveConflict , {\n \"masterSlaveConflict\" , \"h245.masterSlaveConflict_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_waitForCommunicationMode , {\n \"waitForCommunicationMode\" , \"h245.waitForCommunicationMode_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_invalidDependentChannel , {\n \"invalidDependentChannel\" , \"h245.invalidDependentChannel_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_replacementForRejected , {\n \"replacementForRejected\" , \"h245.replacementForRejected_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_securityDenied , {\n \"securityDenied\" , \"h245.securityDenied_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_qoSControlNotSupported , {\n \"qoSControlNotSupported\" , \"h245.qoSControlNotSupported_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_sessionID , {\n \"sessionID\" , \"h245.sessionID\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_255\" , HFILL }\n }\n , {\n & hf_h245_ack_mediaChannel , {\n \"mediaChannel\" , \"h245.mediaChannel\" , FT_UINT32 , BASE_DEC , VALS ( h245_TransportAddress_vals ) , 0 , \"Ack_mediaChannel\" , HFILL }\n }\n , {\n & hf_h245_ack_mediaControlChannel , {\n \"mediaControlChannel\" , \"h245.mediaControlChannel\" , FT_UINT32 , BASE_DEC , VALS ( h245_TransportAddress_vals ) , 0 , \"Ack_mediaControlChannel\" , HFILL }\n }\n , {\n & hf_h245_flowControlToZero , {\n \"flowControlToZero\" , \"h245.flowControlToZero\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_cLC_source , {\n \"source\" , \"h245.source\" , FT_UINT32 , BASE_DEC , VALS ( h245_T_cLC_source_vals ) , 0 , \"T_cLC_source\" , HFILL }\n }\n , {\n & hf_h245_user , {\n \"user\" , \"h245.user_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_lcse , {\n \"lcse\" , \"h245.lcse_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_clc_reason , {\n \"reason\" , \"h245.reason\" , FT_UINT32 , BASE_DEC , VALS ( h245_Clc_reason_vals ) , 0 , \"Clc_reason\" , HFILL }\n }\n , {\n & hf_h245_unknown , {\n \"unknown\" , \"h245.unknown_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_reopen , {\n \"reopen\" , \"h245.reopen_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_reservationFailure , {\n \"reservationFailure\" , \"h245.reservationFailure_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_networkErrorCode , {\n \"networkErrorCode\" , \"h245.networkErrorCode\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_255\" , HFILL }\n }\n , {\n & hf_h245_qosCapability , {\n \"qosCapability\" , \"h245.qosCapability_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_reason , {\n \"reason\" , \"h245.reason\" , FT_UINT32 , BASE_DEC , VALS ( h245_T_reason_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_normal , {\n \"normal\" , \"h245.normal_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_req_chan_clos_rej_cause , {\n \"cause\" , \"h245.cause\" , FT_UINT32 , BASE_DEC , VALS ( h245_RequestChannelCloseRejectCause_vals ) , 0 , \"RequestChannelCloseRejectCause\" , HFILL }\n }\n , {\n & hf_h245_multiplexEntryDescriptors , {\n \"multiplexEntryDescriptors\" , \"h245.multiplexEntryDescriptors\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"SET_SIZE_1_15_OF_MultiplexEntryDescriptor\" , HFILL }\n }\n , {\n & hf_h245_multiplexEntryDescriptors_item , {\n \"MultiplexEntryDescriptor\" , \"h245.MultiplexEntryDescriptor_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_multiplexTableEntryNumber , {\n \"multiplexTableEntryNumber\" , \"h245.multiplexTableEntryNumber\" , FT_UINT32 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_elementList , {\n \"elementList\" , \"h245.elementList\" , FT_UINT32 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_elementList_item , {\n \"MultiplexElement\" , \"h245.MultiplexElement_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_me_type , {\n \"type\" , \"h245.type\" , FT_UINT32 , BASE_DEC , VALS ( h245_Me_type_vals ) , 0 , \"Me_type\" , HFILL }\n }\n , {\n & hf_h245_logicalChannelNum , {\n \"logicalChannelNumber\" , \"h245.logicalChannelNumber\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"T_logicalChannelNum\" , HFILL }\n }\n , {\n & hf_h245_subElementList , {\n \"subElementList\" , \"h245.subElementList\" , FT_UINT32 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_subElementList_item , {\n \"MultiplexElement\" , \"h245.MultiplexElement_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_me_repeatCount , {\n \"repeatCount\" , \"h245.repeatCount\" , FT_UINT32 , BASE_DEC , VALS ( h245_ME_repeatCount_vals ) , 0 , \"ME_repeatCount\" , HFILL }\n }\n , {\n & hf_h245_me_repeatCount_finite , {\n \"finite\" , \"h245.finite\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"ME_finiteRepeatCount\" , HFILL }\n }\n , {\n & hf_h245_untilClosingFlag , {\n \"untilClosingFlag\" , \"h245.untilClosingFlag_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_multiplexTableEntryNumbers , {\n \"multiplexTableEntryNumber\" , \"h245.multiplexTableEntryNumber\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"SET_SIZE_1_15_OF_MultiplexTableEntryNumber\" , HFILL }\n }\n , {\n & hf_h245_multiplexTableEntryNumbers_item , {\n \"MultiplexTableEntryNumber\" , \"h245.MultiplexTableEntryNumber\" , FT_UINT32 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_sendRejectionDescriptions , {\n \"rejectionDescriptions\" , \"h245.rejectionDescriptions\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"SET_SIZE_1_15_OF_MultiplexEntryRejectionDescriptions\" , HFILL }\n }\n , {\n & hf_h245_sendRejectionDescriptions_item , {\n \"MultiplexEntryRejectionDescriptions\" , \"h245.MultiplexEntryRejectionDescriptions_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_mux_rej_cause , {\n \"cause\" , \"h245.cause\" , FT_UINT32 , BASE_DEC , VALS ( h245_MultiplexEntryRejectionDescriptionsCause_vals ) , 0 , \"MultiplexEntryRejectionDescriptionsCause\" , HFILL }\n }\n , {\n & hf_h245_unspecifiedCause , {\n \"unspecifiedCause\" , \"h245.unspecifiedCause_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_descriptorTooComplex , {\n \"descriptorTooComplex\" , \"h245.descriptorTooComplex_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_entryNumbers , {\n \"entryNumbers\" , \"h245.entryNumbers\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"SET_SIZE_1_15_OF_MultiplexTableEntryNumber\" , HFILL }\n }\n , {\n & hf_h245_entryNumbers_item , {\n \"MultiplexTableEntryNumber\" , \"h245.MultiplexTableEntryNumber\" , FT_UINT32 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_rejectionDescriptions , {\n \"rejectionDescriptions\" , \"h245.rejectionDescriptions\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"SET_SIZE_1_15_OF_RequestMultiplexEntryRejectionDescriptions\" , HFILL }\n }\n , {\n & hf_h245_rejectionDescriptions_item , {\n \"RequestMultiplexEntryRejectionDescriptions\" , \"h245.RequestMultiplexEntryRejectionDescriptions_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_req_mux_rej_cause , {\n \"cause\" , \"h245.cause\" , FT_UINT32 , BASE_DEC , VALS ( h245_RequestMultiplexEntryRejectionDescriptionsCause_vals ) , 0 , \"RequestMultiplexEntryRejectionDescriptionsCause\" , HFILL }\n }\n , {\n & hf_h245_requestedModes , {\n \"requestedModes\" , \"h245.requestedModes\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"SEQUENCE_SIZE_1_256_OF_ModeDescription\" , HFILL }\n }\n , {\n & hf_h245_requestedModes_item , {\n \"ModeDescription\" , \"h245.ModeDescription\" , FT_UINT32 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_req_mode_ack_response , {\n \"response\" , \"h245.response\" , FT_UINT32 , BASE_DEC , VALS ( h245_Req_mode_ack_response_vals ) , 0 , \"Req_mode_ack_response\" , HFILL }\n }\n , {\n & hf_h245_willTransmitMostPreferredMode , {\n \"willTransmitMostPreferredMode\" , \"h245.willTransmitMostPreferredMode_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_willTransmitLessPreferredMode , {\n \"willTransmitLessPreferredMode\" , \"h245.willTransmitLessPreferredMode_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_req_rej_cause , {\n \"cause\" , \"h245.cause\" , FT_UINT32 , BASE_DEC , VALS ( h245_RequestModeRejectCause_vals ) , 0 , \"RequestModeRejectCause\" , HFILL }\n }\n , {\n & hf_h245_modeUnavailable , {\n \"modeUnavailable\" , \"h245.modeUnavailable_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_multipointConstraint , {\n \"multipointConstraint\" , \"h245.multipointConstraint_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_requestDenied , {\n \"requestDenied\" , \"h245.requestDenied_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_ModeDescription_item , {\n \"ModeElement\" , \"h245.ModeElement_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_videoMode , {\n \"videoMode\" , \"h245.videoMode\" , FT_UINT32 , BASE_DEC , VALS ( h245_VideoMode_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_audioMode , {\n \"audioMode\" , \"h245.audioMode\" , FT_UINT32 , BASE_DEC , VALS ( h245_AudioMode_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_dataMode , {\n \"dataMode\" , \"h245.dataMode_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_encryptionMode , {\n \"encryptionMode\" , \"h245.encryptionMode\" , FT_UINT32 , BASE_DEC , VALS ( h245_EncryptionMode_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_h235Mode , {\n \"h235Mode\" , \"h245.h235Mode_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_multiplexedStreamMode , {\n \"multiplexedStreamMode\" , \"h245.multiplexedStreamMode_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"MultiplexedStreamParameter\" , HFILL }\n }\n , {\n & hf_h245_redundancyEncodingDTMode , {\n \"redundancyEncodingDTMode\" , \"h245.redundancyEncodingDTMode_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_multiplePayloadStreamMode , {\n \"multiplePayloadStreamMode\" , \"h245.multiplePayloadStreamMode_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_depFecMode , {\n \"depFecMode\" , \"h245.depFecMode\" , FT_UINT32 , BASE_DEC , VALS ( h245_DepFECMode_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_fecMode , {\n \"fecMode\" , \"h245.fecMode_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_type , {\n \"type\" , \"h245.type\" , FT_UINT32 , BASE_DEC , VALS ( h245_ModeElementType_vals ) , 0 , \"ModeElementType\" , HFILL }\n }\n , {\n & hf_h245_h223ModeParameters , {\n \"h223ModeParameters\" , \"h245.h223ModeParameters_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_v76ModeParameters , {\n \"v76ModeParameters\" , \"h245.v76ModeParameters\" , FT_UINT32 , BASE_DEC , VALS ( h245_V76ModeParameters_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_h2250ModeParameters , {\n \"h2250ModeParameters\" , \"h245.h2250ModeParameters_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_genericModeParameters , {\n \"genericModeParameters\" , \"h245.genericModeParameters_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"GenericCapability\" , HFILL }\n }\n , {\n & hf_h245_multiplexedStreamModeParameters , {\n \"multiplexedStreamModeParameters\" , \"h245.multiplexedStreamModeParameters_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_logicalChannelNumber , {\n \"logicalChannelNumber\" , \"h245.logicalChannelNumber\" , FT_UINT32 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_mediaMode , {\n \"mediaMode\" , \"h245.mediaMode\" , FT_UINT32 , BASE_DEC , VALS ( h245_T_mediaMode_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_prmary_dtmode , {\n \"primary\" , \"h245.primary_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"RedundancyEncodingDTModeElement\" , HFILL }\n }\n , {\n & hf_h245_secondaryDTM , {\n \"secondary\" , \"h245.secondary\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"SEQUENCE_OF_RedundancyEncodingDTModeElement\" , HFILL }\n }\n , {\n & hf_h245_secondaryDTM_item , {\n \"RedundancyEncodingDTModeElement\" , \"h245.RedundancyEncodingDTModeElement_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_re_type , {\n \"type\" , \"h245.type\" , FT_UINT32 , BASE_DEC , VALS ( h245_Re_type_vals ) , 0 , \"Re_type\" , HFILL }\n }\n , {\n & hf_h245_mpsmElements , {\n \"elements\" , \"h245.elements\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"SEQUENCE_OF_MultiplePayloadStreamElementMode\" , HFILL }\n }\n , {\n & hf_h245_mpsmElements_item , {\n \"MultiplePayloadStreamElementMode\" , \"h245.MultiplePayloadStreamElementMode_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_rfc2733Mode , {\n \"rfc2733Mode\" , \"h245.rfc2733Mode_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_fec_mode , {\n \"mode\" , \"h245.mode\" , FT_UINT32 , BASE_DEC , VALS ( h245_FEC_mode_vals ) , 0 , \"FEC_mode\" , HFILL }\n }\n , {\n & hf_h245_protectedElement , {\n \"protectedElement\" , \"h245.protectedElement\" , FT_UINT32 , BASE_DEC , VALS ( h245_ModeElementType_vals ) , 0 , \"ModeElementType\" , HFILL }\n }\n , {\n & hf_h245_adaptationLayer , {\n \"adaptationLayerType\" , \"h245.adaptationLayerType\" , FT_UINT32 , BASE_DEC , VALS ( h245_AdaptationLayerType_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_al1Framed , {\n \"al1Framed\" , \"h245.al1Framed_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_al1NotFramed , {\n \"al1NotFramed\" , \"h245.al1NotFramed_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_al2WithoutSequenceNumbers , {\n \"al2WithoutSequenceNumbers\" , \"h245.al2WithoutSequenceNumbers_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_al2WithSequenceNumbers , {\n \"al2WithSequenceNumbers\" , \"h245.al2WithSequenceNumbers_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_al3 , {\n \"al3\" , \"h245.al3_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_al1M , {\n \"al1M\" , \"h245.al1M_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"H223AL1MParameters\" , HFILL }\n }\n , {\n & hf_h245_al2M , {\n \"al2M\" , \"h245.al2M_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"H223AL2MParameters\" , HFILL }\n }\n , {\n & hf_h245_al3M , {\n \"al3M\" , \"h245.al3M_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"H223AL3MParameters\" , HFILL }\n }\n , {\n & hf_h245_segmentableFlag , {\n \"segmentableFlag\" , \"h245.segmentableFlag\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_redundancyEncodingMode , {\n \"redundancyEncodingMode\" , \"h245.redundancyEncodingMode_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_secondaryEncodingMode , {\n \"secondaryEncoding\" , \"h245.secondaryEncoding\" , FT_UINT32 , BASE_DEC , VALS ( h245_T_secondaryEncodingMode_vals ) , 0 , \"T_secondaryEncodingMode\" , HFILL }\n }\n , {\n & hf_h245_h261VideoMode , {\n \"h261VideoMode\" , \"h245.h261VideoMode_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_h262VideoMode , {\n \"h262VideoMode\" , \"h245.h262VideoMode_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_h263VideoMode , {\n \"h263VideoMode\" , \"h245.h263VideoMode_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_is11172VideoMode , {\n \"is11172VideoMode\" , \"h245.is11172VideoMode_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_genericVideoMode , {\n \"genericVideoMode\" , \"h245.genericVideoMode_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"GenericCapability\" , HFILL }\n }\n , {\n & hf_h245_h261_resolution , {\n \"resolution\" , \"h245.resolution\" , FT_UINT32 , BASE_DEC , VALS ( h245_H261Resolution_vals ) , 0 , \"H261Resolution\" , HFILL }\n }\n , {\n & hf_h245_qcif , {\n \"qcif\" , \"h245.qcif_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_cif , {\n \"cif\" , \"h245.cif_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_profileAndLevel , {\n \"profileAndLevel\" , \"h245.profileAndLevel\" , FT_UINT32 , BASE_DEC , VALS ( h245_T_profileAndLevel_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_profileAndLevel_SPatMLMode , {\n \"profileAndLevel-SPatML\" , \"h245.profileAndLevel_SPatML_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_profileAndLevel_MPatLLMode , {\n \"profileAndLevel-MPatLL\" , \"h245.profileAndLevel_MPatLL_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_profileAndLevel_MPatMLMode , {\n \"profileAndLevel-MPatML\" , \"h245.profileAndLevel_MPatML_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_profileAndLevel_MPatH_14Mode , {\n \"profileAndLevel-MPatH-14\" , \"h245.profileAndLevel_MPatH_14_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_profileAndLevel_MPatHLMode , {\n \"profileAndLevel-MPatHL\" , \"h245.profileAndLevel_MPatHL_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_profileAndLevel_SNRatLLMode , {\n \"profileAndLevel-SNRatLL\" , \"h245.profileAndLevel_SNRatLL_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_profileAndLevel_SNRatMLMode , {\n \"profileAndLevel-SNRatML\" , \"h245.profileAndLevel_SNRatML_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_profileAndLevel_SpatialatH_14Mode , {\n \"profileAndLevel-SpatialatH-14\" , \"h245.profileAndLevel_SpatialatH_14_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_profileAndLevel_HPatMLMode , {\n \"profileAndLevel-HPatML\" , \"h245.profileAndLevel_HPatML_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_profileAndLevel_HPatH_14Mode , {\n \"profileAndLevel-HPatH-14\" , \"h245.profileAndLevel_HPatH_14_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_profileAndLevel_HPatHLMode , {\n \"profileAndLevel-HPatHL\" , \"h245.profileAndLevel_HPatHL_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_h263_resolution , {\n \"resolution\" , \"h245.resolution\" , FT_UINT32 , BASE_DEC , VALS ( h245_H263Resolution_vals ) , 0 , \"H263Resolution\" , HFILL }\n }\n , {\n & hf_h245_sqcif , {\n \"sqcif\" , \"h245.sqcif_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_cif4 , {\n \"cif4\" , \"h245.cif4_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_cif16 , {\n \"cif16\" , \"h245.cif16_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_custom_res , {\n \"custom\" , \"h245.custom_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_g711Alaw64k_mode , {\n \"g711Alaw64k\" , \"h245.g711Alaw64k_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_g711Alaw56k_mode , {\n \"g711Alaw56k\" , \"h245.g711Alaw56k_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_g711Ulaw64k_mode , {\n \"g711Ulaw64k\" , \"h245.g711Ulaw64k_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_g711Ulaw56k_mode , {\n \"g711Ulaw56k\" , \"h245.g711Ulaw56k_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_g722_64k_mode , {\n \"g722-64k\" , \"h245.g722_64k_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_g722_56k_mode , {\n \"g722-56k\" , \"h245.g722_56k_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_g722_48k_mode , {\n \"g722-48k\" , \"h245.g722_48k_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_g728_mode , {\n \"g728\" , \"h245.g728_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_g729_mode , {\n \"g729\" , \"h245.g729_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_g729AnnexA_mode , {\n \"g729AnnexA\" , \"h245.g729AnnexA_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_g7231_mode , {\n \"g7231\" , \"h245.g7231\" , FT_UINT32 , BASE_DEC , VALS ( h245_Mode_g7231_vals ) , 0 , \"Mode_g7231\" , HFILL }\n }\n , {\n & hf_h245_noSilenceSuppressionLowRate , {\n \"noSilenceSuppressionLowRate\" , \"h245.noSilenceSuppressionLowRate_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_noSilenceSuppressionHighRate , {\n \"noSilenceSuppressionHighRate\" , \"h245.noSilenceSuppressionHighRate_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_silenceSuppressionLowRate , {\n \"silenceSuppressionLowRate\" , \"h245.silenceSuppressionLowRate_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_silenceSuppressionHighRate , {\n \"silenceSuppressionHighRate\" , \"h245.silenceSuppressionHighRate_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_is11172AudioMode , {\n \"is11172AudioMode\" , \"h245.is11172AudioMode_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_is13818AudioMode , {\n \"is13818AudioMode\" , \"h245.is13818AudioMode_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_g7231AnnexCMode , {\n \"g7231AnnexCMode\" , \"h245.g7231AnnexCMode_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_genericAudioMode , {\n \"genericAudioMode\" , \"h245.genericAudioMode_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"GenericCapability\" , HFILL }\n }\n , {\n & hf_h245_vbd_mode , {\n \"vbd\" , \"h245.vbd_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"VBDMode\" , HFILL }\n }\n , {\n & hf_h245_audioLayer , {\n \"audioLayer\" , \"h245.audioLayer\" , FT_UINT32 , BASE_DEC , VALS ( h245_T_audioLayer_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_audioLayer1Mode , {\n \"audioLayer1\" , \"h245.audioLayer1_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_audioLayer2Mode , {\n \"audioLayer2\" , \"h245.audioLayer2_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_audioLayer3Mode , {\n \"audioLayer3\" , \"h245.audioLayer3_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_audioSampling , {\n \"audioSampling\" , \"h245.audioSampling\" , FT_UINT32 , BASE_DEC , VALS ( h245_T_audioSampling_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_audioSampling32kMode , {\n \"audioSampling32k\" , \"h245.audioSampling32k_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_audioSampling44k1Mode , {\n \"audioSampling44k1\" , \"h245.audioSampling44k1_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_audioSampling48kMode , {\n \"audioSampling48k\" , \"h245.audioSampling48k_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_is11172multichannelType , {\n \"multichannelType\" , \"h245.multichannelType\" , FT_UINT32 , BASE_DEC , VALS ( h245_IS11172_multichannelType_vals ) , 0 , \"IS11172_multichannelType\" , HFILL }\n }\n , {\n & hf_h245_singleChannelMode , {\n \"singleChannel\" , \"h245.singleChannel_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_twoChannelStereo , {\n \"twoChannelStereo\" , \"h245.twoChannelStereo_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_twoChannelDual , {\n \"twoChannelDual\" , \"h245.twoChannelDual_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_audioLayerMode , {\n \"audioLayer\" , \"h245.audioLayer\" , FT_UINT32 , BASE_DEC , VALS ( h245_IS13818AudioLayer_vals ) , 0 , \"IS13818AudioLayer\" , HFILL }\n }\n , {\n & hf_h245_audioSamplingMode , {\n \"audioSampling\" , \"h245.audioSampling\" , FT_UINT32 , BASE_DEC , VALS ( h245_IS13818AudioSampling_vals ) , 0 , \"IS13818AudioSampling\" , HFILL }\n }\n , {\n & hf_h245_audioSampling16kMode , {\n \"audioSampling16k\" , \"h245.audioSampling16k_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_audioSampling22k05Mode , {\n \"audioSampling22k05\" , \"h245.audioSampling22k05_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_audioSampling24kMode , {\n \"audioSampling24k\" , \"h245.audioSampling24k_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_is13818MultichannelType , {\n \"multichannelType\" , \"h245.multichannelType\" , FT_UINT32 , BASE_DEC , VALS ( h245_IS13818MultichannelType_vals ) , 0 , \"IS13818MultichannelType\" , HFILL }\n }\n , {\n & hf_h245_threeChannels2_1Mode , {\n \"threeChannels2-1\" , \"h245.threeChannels2_1_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_threeChannels3_0Mode , {\n \"threeChannels3-0\" , \"h245.threeChannels3_0_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_fourChannels2_0_2_0Mode , {\n \"fourChannels2-0-2-0\" , \"h245.fourChannels2_0_2_0_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_fourChannels2_2Mode , {\n \"fourChannels2-2\" , \"h245.fourChannels2_2_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_fourChannels3_1Mode , {\n \"fourChannels3-1\" , \"h245.fourChannels3_1_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_fiveChannels3_0_2_0Mode , {\n \"fiveChannels3-0-2-0\" , \"h245.fiveChannels3_0_2_0_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_fiveChannels3_2Mode , {\n \"fiveChannels3-2\" , \"h245.fiveChannels3_2_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_vbd_type , {\n \"type\" , \"h245.type\" , FT_UINT32 , BASE_DEC , VALS ( h245_AudioMode_vals ) , 0 , \"AudioMode\" , HFILL }\n }\n , {\n & hf_h245_datamodeapplication , {\n \"application\" , \"h245.application\" , FT_UINT32 , BASE_DEC , VALS ( h245_DataModeApplication_vals ) , 0 , \"DataModeApplication\" , HFILL }\n }\n , {\n & hf_h245_t84DataProtocolCapability , {\n \"t84\" , \"h245.t84\" , FT_UINT32 , BASE_DEC , VALS ( DataProtocolCapability_vals ) , 0 , \"DataProtocolCapability\" , HFILL }\n }\n , {\n & hf_h245_t38faxDataProtocolCapability , {\n \"t38fax\" , \"h245.t38fax_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"T38faxApp\" , HFILL }\n }\n , {\n & hf_h245_genericDataMode , {\n \"genericDataMode\" , \"h245.genericDataMode_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"GenericCapability\" , HFILL }\n }\n , {\n & hf_h245_bitRate_0_4294967295 , {\n \"bitRate\" , \"h245.bitRate\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_4294967295\" , HFILL }\n }\n , {\n & hf_h245_h233Encryption , {\n \"h233Encryption\" , \"h245.h233Encryption_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_mlr_type , {\n \"type\" , \"h245.type\" , FT_UINT32 , BASE_DEC , VALS ( h245_Mlr_type_vals ) , 0 , \"Mlr_type\" , HFILL }\n }\n , {\n & hf_h245_systemLoop , {\n \"systemLoop\" , \"h245.systemLoop_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_mediaLoop , {\n \"mediaLoop\" , \"h245.mediaLoop\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"LogicalChannelNumber\" , HFILL }\n }\n , {\n & hf_h245_logicalChannelLoop , {\n \"logicalChannelLoop\" , \"h245.logicalChannelLoop\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"LogicalChannelNumber\" , HFILL }\n }\n , {\n & hf_h245_mla_type , {\n \"type\" , \"h245.type\" , FT_UINT32 , BASE_DEC , VALS ( h245_Mla_type_vals ) , 0 , \"Mla_type\" , HFILL }\n }\n , {\n & hf_h245_mlrej_type , {\n \"type\" , \"h245.type\" , FT_UINT32 , BASE_DEC , VALS ( h245_Mlrej_type_vals ) , 0 , \"Mlrej_type\" , HFILL }\n }\n , {\n & hf_h245_maintloop_rej_cause , {\n \"cause\" , \"h245.cause\" , FT_UINT32 , BASE_DEC , VALS ( h245_MaintenanceLoopRejectCause_vals ) , 0 , \"MaintenanceLoopRejectCause\" , HFILL }\n }\n , {\n & hf_h245_canNotPerformLoop , {\n \"canNotPerformLoop\" , \"h245.canNotPerformLoop_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_communicationModeTable , {\n \"communicationModeTable\" , \"h245.communicationModeTable\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"SET_SIZE_1_256_OF_CommunicationModeTableEntry\" , HFILL }\n }\n , {\n & hf_h245_communicationModeTable_item , {\n \"CommunicationModeTableEntry\" , \"h245.CommunicationModeTableEntry_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_terminalLabel , {\n \"terminalLabel\" , \"h245.terminalLabel_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_sessionDescription , {\n \"sessionDescription\" , \"h245.sessionDescription\" , FT_STRING , BASE_NONE , NULL , 0 , \"BMPString_SIZE_1_128\" , HFILL }\n }\n , {\n & hf_h245_entryDataType , {\n \"dataType\" , \"h245.dataType\" , FT_UINT32 , BASE_DEC , VALS ( h245_T_entryDataType_vals ) , 0 , \"T_entryDataType\" , HFILL }\n }\n , {\n & hf_h245_cm_mediaChannel , {\n \"mediaChannel\" , \"h245.mediaChannel\" , FT_UINT32 , BASE_DEC , VALS ( h245_TransportAddress_vals ) , 0 , \"Cm_mediaChannel\" , HFILL }\n }\n , {\n & hf_h245_cm_mediaControlChannel , {\n \"mediaControlChannel\" , \"h245.mediaControlChannel\" , FT_UINT32 , BASE_DEC , VALS ( h245_TransportAddress_vals ) , 0 , \"TransportAddress\" , HFILL }\n }\n , {\n & hf_h245_sessionDependency , {\n \"sessionDependency\" , \"h245.sessionDependency\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_255\" , HFILL }\n }\n , {\n & hf_h245_terminalListRequest , {\n \"terminalListRequest\" , \"h245.terminalListRequest_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_makeMeChair , {\n \"makeMeChair\" , \"h245.makeMeChair_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_cancelMakeMeChair , {\n \"cancelMakeMeChair\" , \"h245.cancelMakeMeChair_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_dropTerminal , {\n \"dropTerminal\" , \"h245.dropTerminal_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"TerminalLabel\" , HFILL }\n }\n , {\n & hf_h245_requestTerminalID , {\n \"requestTerminalID\" , \"h245.requestTerminalID_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"TerminalLabel\" , HFILL }\n }\n , {\n & hf_h245_enterH243Password , {\n \"enterH243Password\" , \"h245.enterH243Password_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_enterH243TerminalID , {\n \"enterH243TerminalID\" , \"h245.enterH243TerminalID_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_enterH243ConferenceID , {\n \"enterH243ConferenceID\" , \"h245.enterH243ConferenceID_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_enterExtensionAddress , {\n \"enterExtensionAddress\" , \"h245.enterExtensionAddress_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_requestChairTokenOwner , {\n \"requestChairTokenOwner\" , \"h245.requestChairTokenOwner_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_requestTerminalCertificate , {\n \"requestTerminalCertificate\" , \"h245.requestTerminalCertificate_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_certSelectionCriteria , {\n \"certSelectionCriteria\" , \"h245.certSelectionCriteria\" , FT_UINT32 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_sRandom , {\n \"sRandom\" , \"h245.sRandom\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_4294967295\" , HFILL }\n }\n , {\n & hf_h245_broadcastMyLogicalChannel , {\n \"broadcastMyLogicalChannel\" , \"h245.broadcastMyLogicalChannel\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"LogicalChannelNumber\" , HFILL }\n }\n , {\n & hf_h245_makeTerminalBroadcaster , {\n \"makeTerminalBroadcaster\" , \"h245.makeTerminalBroadcaster_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"TerminalLabel\" , HFILL }\n }\n , {\n & hf_h245_sendThisSource , {\n \"sendThisSource\" , \"h245.sendThisSource_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"TerminalLabel\" , HFILL }\n }\n , {\n & hf_h245_requestAllTerminalIDs , {\n \"requestAllTerminalIDs\" , \"h245.requestAllTerminalIDs_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_remoteMCRequest , {\n \"remoteMCRequest\" , \"h245.remoteMCRequest\" , FT_UINT32 , BASE_DEC , VALS ( h245_RemoteMCRequest_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_CertSelectionCriteria_item , {\n \"Criteria\" , \"h245.Criteria_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_field , {\n \"field\" , \"h245.field\" , FT_OID , BASE_NONE , NULL , 0 , \"OBJECT_IDENTIFIER\" , HFILL }\n }\n , {\n & hf_h245_criteriaValue , {\n \"value\" , \"h245.value\" , FT_BYTES , BASE_NONE , NULL , 0 , \"OCTET_STRING_SIZE_1_65535\" , HFILL }\n }\n , {\n & hf_h245_mcuNumber , {\n \"mcuNumber\" , \"h245.mcuNumber\" , FT_UINT32 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_terminalNumber , {\n \"terminalNumber\" , \"h245.terminalNumber\" , FT_UINT32 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_mCTerminalIDResponse , {\n \"mCTerminalIDResponse\" , \"h245.mCTerminalIDResponse_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_terminalID , {\n \"terminalID\" , \"h245.terminalID\" , FT_BYTES , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_terminalIDResponse , {\n \"terminalIDResponse\" , \"h245.terminalIDResponse_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_conferenceIDResponse , {\n \"conferenceIDResponse\" , \"h245.conferenceIDResponse_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_conferenceID , {\n \"conferenceID\" , \"h245.conferenceID\" , FT_BYTES , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_passwordResponse , {\n \"passwordResponse\" , \"h245.passwordResponse_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_password , {\n \"password\" , \"h245.password\" , FT_BYTES , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_terminalListResponse , {\n \"terminalListResponse\" , \"h245.terminalListResponse\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"SET_SIZE_1_256_OF_TerminalLabel\" , HFILL }\n }\n , {\n & hf_h245_terminalListResponse_item , {\n \"TerminalLabel\" , \"h245.TerminalLabel_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_videoCommandReject , {\n \"videoCommandReject\" , \"h245.videoCommandReject_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_terminalDropReject , {\n \"terminalDropReject\" , \"h245.terminalDropReject_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_makeMeChairResponse , {\n \"makeMeChairResponse\" , \"h245.makeMeChairResponse\" , FT_UINT32 , BASE_DEC , VALS ( h245_T_makeMeChairResponse_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_grantedChairToken , {\n \"grantedChairToken\" , \"h245.grantedChairToken_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_deniedChairToken , {\n \"deniedChairToken\" , \"h245.deniedChairToken_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_extensionAddressResponse , {\n \"extensionAddressResponse\" , \"h245.extensionAddressResponse_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_extensionAddress , {\n \"extensionAddress\" , \"h245.extensionAddress\" , FT_BYTES , BASE_NONE , NULL , 0 , \"TerminalID\" , HFILL }\n }\n , {\n & hf_h245_chairTokenOwnerResponse , {\n \"chairTokenOwnerResponse\" , \"h245.chairTokenOwnerResponse_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_terminalCertificateResponse , {\n \"terminalCertificateResponse\" , \"h245.terminalCertificateResponse_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_certificateResponse , {\n \"certificateResponse\" , \"h245.certificateResponse\" , FT_BYTES , BASE_NONE , NULL , 0 , \"OCTET_STRING_SIZE_1_65535\" , HFILL }\n }\n , {\n & hf_h245_broadcastMyLogicalChannelResponse , {\n \"broadcastMyLogicalChannelResponse\" , \"h245.broadcastMyLogicalChannelResponse\" , FT_UINT32 , BASE_DEC , VALS ( h245_T_broadcastMyLogicalChannelResponse_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_grantedBroadcastMyLogicalChannel , {\n \"grantedBroadcastMyLogicalChannel\" , \"h245.grantedBroadcastMyLogicalChannel_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_deniedBroadcastMyLogicalChannel , {\n \"deniedBroadcastMyLogicalChannel\" , \"h245.deniedBroadcastMyLogicalChannel_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_makeTerminalBroadcasterResponse , {\n \"makeTerminalBroadcasterResponse\" , \"h245.makeTerminalBroadcasterResponse\" , FT_UINT32 , BASE_DEC , VALS ( h245_T_makeTerminalBroadcasterResponse_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_grantedMakeTerminalBroadcaster , {\n \"grantedMakeTerminalBroadcaster\" , \"h245.grantedMakeTerminalBroadcaster_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_deniedMakeTerminalBroadcaster , {\n \"deniedMakeTerminalBroadcaster\" , \"h245.deniedMakeTerminalBroadcaster_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_sendThisSourceResponse , {\n \"sendThisSourceResponse\" , \"h245.sendThisSourceResponse\" , FT_UINT32 , BASE_DEC , VALS ( h245_T_sendThisSourceResponse_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_grantedSendThisSource , {\n \"grantedSendThisSource\" , \"h245.grantedSendThisSource_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_deniedSendThisSource , {\n \"deniedSendThisSource\" , \"h245.deniedSendThisSource_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_requestAllTerminalIDsResponse , {\n \"requestAllTerminalIDsResponse\" , \"h245.requestAllTerminalIDsResponse_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_remoteMCResponse , {\n \"remoteMCResponse\" , \"h245.remoteMCResponse\" , FT_UINT32 , BASE_DEC , VALS ( h245_RemoteMCResponse_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_terminalInformation , {\n \"terminalInformation\" , \"h245.terminalInformation\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"SEQUENCE_OF_TerminalInformation\" , HFILL }\n }\n , {\n & hf_h245_terminalInformation_item , {\n \"TerminalInformation\" , \"h245.TerminalInformation_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_masterActivate , {\n \"masterActivate\" , \"h245.masterActivate_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_slaveActivate , {\n \"slaveActivate\" , \"h245.slaveActivate_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_deActivate , {\n \"deActivate\" , \"h245.deActivate_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_accept , {\n \"accept\" , \"h245.accept_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_reject , {\n \"reject\" , \"h245.reject\" , FT_UINT32 , BASE_DEC , VALS ( h245_T_reject_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_functionNotSupportedFlag , {\n \"functionNotSupported\" , \"h245.functionNotSupported_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_callInformationReq , {\n \"callInformation\" , \"h245.callInformation_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"CallInformationReq\" , HFILL }\n }\n , {\n & hf_h245_maxNumberOfAdditionalConnections , {\n \"maxNumberOfAdditionalConnections\" , \"h245.maxNumberOfAdditionalConnections\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_65535\" , HFILL }\n }\n , {\n & hf_h245_addConnectionReq , {\n \"addConnection\" , \"h245.addConnection_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"AddConnectionReq\" , HFILL }\n }\n , {\n & hf_h245_dialingInformation , {\n \"dialingInformation\" , \"h245.dialingInformation\" , FT_UINT32 , BASE_DEC , VALS ( h245_DialingInformation_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_removeConnectionReq , {\n \"removeConnection\" , \"h245.removeConnection_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"RemoveConnectionReq\" , HFILL }\n }\n , {\n & hf_h245_connectionIdentifier , {\n \"connectionIdentifier\" , \"h245.connectionIdentifier_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_maximumHeaderIntervalReq , {\n \"maximumHeaderInterval\" , \"h245.maximumHeaderInterval_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"MaximumHeaderIntervalReq\" , HFILL }\n }\n , {\n & hf_h245_requestType , {\n \"requestType\" , \"h245.requestType\" , FT_UINT32 , BASE_DEC , VALS ( h245_T_requestType_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_currentIntervalInformation , {\n \"currentIntervalInformation\" , \"h245.currentIntervalInformation_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_requestedInterval , {\n \"requestedInterval\" , \"h245.requestedInterval\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_65535\" , HFILL }\n }\n , {\n & hf_h245_callInformationResp , {\n \"callInformation\" , \"h245.callInformation_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"CallInformationResp\" , HFILL }\n }\n , {\n & hf_h245_callAssociationNumber , {\n \"callAssociationNumber\" , \"h245.callAssociationNumber\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_4294967295\" , HFILL }\n }\n , {\n & hf_h245_addConnectionResp , {\n \"addConnection\" , \"h245.addConnection_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"AddConnectionResp\" , HFILL }\n }\n , {\n & hf_h245_responseCode , {\n \"responseCode\" , \"h245.responseCode\" , FT_UINT32 , BASE_DEC , VALS ( h245_T_responseCode_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_accepted , {\n \"accepted\" , \"h245.accepted_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_rejected , {\n \"rejected\" , \"h245.rejected\" , FT_UINT32 , BASE_DEC , VALS ( h245_T_rejected_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_connectionsNotAvailable , {\n \"connectionsNotAvailable\" , \"h245.connectionsNotAvailable_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_userRejected , {\n \"userRejected\" , \"h245.userRejected_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_removeConnectionResp , {\n \"removeConnection\" , \"h245.removeConnection_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"RemoveConnectionResp\" , HFILL }\n }\n , {\n & hf_h245_maximumHeaderIntervalResp , {\n \"maximumHeaderInterval\" , \"h245.maximumHeaderInterval_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"MaximumHeaderIntervalResp\" , HFILL }\n }\n , {\n & hf_h245_currentInterval , {\n \"currentInterval\" , \"h245.currentInterval\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_65535\" , HFILL }\n }\n , {\n & hf_h245_crcDesired , {\n \"crcDesired\" , \"h245.crcDesired_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_excessiveError , {\n \"excessiveError\" , \"h245.excessiveError_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_differential , {\n \"differential\" , \"h245.differential\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"SET_SIZE_1_65535_OF_DialingInformationNumber\" , HFILL }\n }\n , {\n & hf_h245_differential_item , {\n \"DialingInformationNumber\" , \"h245.DialingInformationNumber_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_infoNotAvailable , {\n \"infoNotAvailable\" , \"h245.infoNotAvailable\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_65535\" , HFILL }\n }\n , {\n & hf_h245_networkAddressNum , {\n \"networkAddress\" , \"h245.networkAddress\" , FT_STRING , BASE_NONE , NULL , 0 , \"NumericString_SIZE_0_40\" , HFILL }\n }\n , {\n & hf_h245_subAddress , {\n \"subAddress\" , \"h245.subAddress\" , FT_STRING , BASE_NONE , NULL , 0 , \"IA5String_SIZE_1_40\" , HFILL }\n }\n , {\n & hf_h245_networkType , {\n \"networkType\" , \"h245.networkType\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"SET_SIZE_1_255_OF_DialingInformationNetworkType\" , HFILL }\n }\n , {\n & hf_h245_networkType_item , {\n \"DialingInformationNetworkType\" , \"h245.DialingInformationNetworkType\" , FT_UINT32 , BASE_DEC , VALS ( h245_DialingInformationNetworkType_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_n_isdn , {\n \"n-isdn\" , \"h245.n_isdn_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_gstn , {\n \"gstn\" , \"h245.gstn_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_mobile , {\n \"mobile\" , \"h245.mobile_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_channelTag , {\n \"channelTag\" , \"h245.channelTag\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_4294967295\" , HFILL }\n }\n , {\n & hf_h245_sequenceNum , {\n \"sequenceNumber\" , \"h245.sequenceNumber\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_4294967295\" , HFILL }\n }\n , {\n & hf_h245_maximumBitRate , {\n \"maximumBitRate\" , \"h245.maximumBitRate\" , FT_UINT32 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_rejectReason , {\n \"rejectReason\" , \"h245.rejectReason\" , FT_UINT32 , BASE_DEC , VALS ( h245_LogicalChannelRateRejectReason_vals ) , 0 , \"LogicalChannelRateRejectReason\" , HFILL }\n }\n , {\n & hf_h245_currentMaximumBitRate , {\n \"currentMaximumBitRate\" , \"h245.currentMaximumBitRate\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"MaximumBitRate\" , HFILL }\n }\n , {\n & hf_h245_undefinedReason , {\n \"undefinedReason\" , \"h245.undefinedReason_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_insufficientResources , {\n \"insufficientResources\" , \"h245.insufficientResources_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_specificRequest , {\n \"specificRequest\" , \"h245.specificRequest_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_multiplexCapabilityBool , {\n \"multiplexCapability\" , \"h245.multiplexCapability\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_capabilityTableEntryNumbers , {\n \"capabilityTableEntryNumbers\" , \"h245.capabilityTableEntryNumbers\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"SET_SIZE_1_65535_OF_CapabilityTableEntryNumber\" , HFILL }\n }\n , {\n & hf_h245_capabilityTableEntryNumbers_item , {\n \"CapabilityTableEntryNumber\" , \"h245.CapabilityTableEntryNumber\" , FT_UINT32 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_capabilityDescriptorNumbers , {\n \"capabilityDescriptorNumbers\" , \"h245.capabilityDescriptorNumbers\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"SET_SIZE_1_256_OF_CapabilityDescriptorNumber\" , HFILL }\n }\n , {\n & hf_h245_capabilityDescriptorNumbers_item , {\n \"CapabilityDescriptorNumber\" , \"h245.CapabilityDescriptorNumber\" , FT_UINT32 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_genericRequestFlag , {\n \"genericRequest\" , \"h245.genericRequest_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_encryptionSE , {\n \"encryptionSE\" , \"h245.encryptionSE\" , FT_BYTES , BASE_NONE , NULL , 0 , \"OCTET_STRING\" , HFILL }\n }\n , {\n & hf_h245_encryptionIVRequest , {\n \"encryptionIVRequest\" , \"h245.encryptionIVRequest_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_encryptionAlgorithmID , {\n \"encryptionAlgorithmID\" , \"h245.encryptionAlgorithmID_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_h233AlgorithmIdentifier , {\n \"h233AlgorithmIdentifier\" , \"h245.h233AlgorithmIdentifier\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"SequenceNumber\" , HFILL }\n }\n , {\n & hf_h245_associatedAlgorithm , {\n \"associatedAlgorithm\" , \"h245.associatedAlgorithm_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"NonStandardParameter\" , HFILL }\n }\n , {\n & hf_h245_wholeMultiplex , {\n \"wholeMultiplex\" , \"h245.wholeMultiplex_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_scope , {\n \"scope\" , \"h245.scope\" , FT_UINT32 , BASE_DEC , VALS ( h245_Scope_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_res_maximumBitRate , {\n \"maximumBitRate\" , \"h245.maximumBitRate\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_16777215\" , HFILL }\n }\n , {\n & hf_h245_noRestriction , {\n \"noRestriction\" , \"h245.noRestriction_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_restriction , {\n \"restriction\" , \"h245.restriction\" , FT_UINT32 , BASE_DEC , VALS ( h245_Restriction_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_disconnect , {\n \"disconnect\" , \"h245.disconnect_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_gstnOptions , {\n \"gstnOptions\" , \"h245.gstnOptions\" , FT_UINT32 , BASE_DEC , VALS ( h245_T_gstnOptions_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_telephonyMode , {\n \"telephonyMode\" , \"h245.telephonyMode_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_v8bis , {\n \"v8bis\" , \"h245.v8bis_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_v34DSVD , {\n \"v34DSVD\" , \"h245.v34DSVD_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_v34DuplexFAX , {\n \"v34DuplexFAX\" , \"h245.v34DuplexFAX_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_v34H324 , {\n \"v34H324\" , \"h245.v34H324_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_isdnOptions , {\n \"isdnOptions\" , \"h245.isdnOptions\" , FT_UINT32 , BASE_DEC , VALS ( h245_T_isdnOptions_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_v140 , {\n \"v140\" , \"h245.v140_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_terminalOnHold , {\n \"terminalOnHold\" , \"h245.terminalOnHold_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_cancelBroadcastMyLogicalChannel , {\n \"cancelBroadcastMyLogicalChannel\" , \"h245.cancelBroadcastMyLogicalChannel\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"LogicalChannelNumber\" , HFILL }\n }\n , {\n & hf_h245_cancelMakeTerminalBroadcaster , {\n \"cancelMakeTerminalBroadcaster\" , \"h245.cancelMakeTerminalBroadcaster_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_cancelSendThisSource , {\n \"cancelSendThisSource\" , \"h245.cancelSendThisSource_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_dropConference , {\n \"dropConference\" , \"h245.dropConference_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_substituteConferenceIDCommand , {\n \"substituteConferenceIDCommand\" , \"h245.substituteConferenceIDCommand_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_conferenceIdentifier , {\n \"conferenceIdentifier\" , \"h245.conferenceIdentifier\" , FT_BYTES , BASE_NONE , NULL , 0 , \"OCTET_STRING_SIZE_16\" , HFILL }\n }\n , {\n & hf_h245_masterToSlave , {\n \"masterToSlave\" , \"h245.masterToSlave_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_slaveToMaster , {\n \"slaveToMaster\" , \"h245.slaveToMaster_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_mc_type , {\n \"type\" , \"h245.type\" , FT_UINT32 , BASE_DEC , VALS ( h245_Mc_type_vals ) , 0 , \"Mc_type\" , HFILL }\n }\n , {\n & hf_h245_equaliseDelay , {\n \"equaliseDelay\" , \"h245.equaliseDelay_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_zeroDelay , {\n \"zeroDelay\" , \"h245.zeroDelay_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_multipointModeCommand , {\n \"multipointModeCommand\" , \"h245.multipointModeCommand_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_cancelMultipointModeCommand , {\n \"cancelMultipointModeCommand\" , \"h245.cancelMultipointModeCommand_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_videoFreezePicture , {\n \"videoFreezePicture\" , \"h245.videoFreezePicture_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_videoFastUpdatePicture , {\n \"videoFastUpdatePicture\" , \"h245.videoFastUpdatePicture_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_videoFastUpdateGOB , {\n \"videoFastUpdateGOB\" , \"h245.videoFastUpdateGOB_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_firstGOB , {\n \"firstGOB\" , \"h245.firstGOB\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_17\" , HFILL }\n }\n , {\n & hf_h245_numberOfGOBs , {\n \"numberOfGOBs\" , \"h245.numberOfGOBs\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_18\" , HFILL }\n }\n , {\n & hf_h245_videoTemporalSpatialTradeOff , {\n \"videoTemporalSpatialTradeOff\" , \"h245.videoTemporalSpatialTradeOff\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_31\" , HFILL }\n }\n , {\n & hf_h245_videoSendSyncEveryGOB , {\n \"videoSendSyncEveryGOB\" , \"h245.videoSendSyncEveryGOB_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_videoSendSyncEveryGOBCancel , {\n \"videoSendSyncEveryGOBCancel\" , \"h245.videoSendSyncEveryGOBCancel_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_videoFastUpdateMB , {\n \"videoFastUpdateMB\" , \"h245.videoFastUpdateMB_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_firstGOB_0_255 , {\n \"firstGOB\" , \"h245.firstGOB\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_255\" , HFILL }\n }\n , {\n & hf_h245_firstMB_1_8192 , {\n \"firstMB\" , \"h245.firstMB\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_8192\" , HFILL }\n }\n , {\n & hf_h245_numberOfMBs , {\n \"numberOfMBs\" , \"h245.numberOfMBs\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_8192\" , HFILL }\n }\n , {\n & hf_h245_maxH223MUXPDUsize , {\n \"maxH223MUXPDUsize\" , \"h245.maxH223MUXPDUsize\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_65535\" , HFILL }\n }\n , {\n & hf_h245_encryptionUpdate , {\n \"encryptionUpdate\" , \"h245.encryptionUpdate_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"EncryptionSync\" , HFILL }\n }\n , {\n & hf_h245_encryptionUpdateRequest , {\n \"encryptionUpdateRequest\" , \"h245.encryptionUpdateRequest_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_switchReceiveMediaOff , {\n \"switchReceiveMediaOff\" , \"h245.switchReceiveMediaOff_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_switchReceiveMediaOn , {\n \"switchReceiveMediaOn\" , \"h245.switchReceiveMediaOn_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_progressiveRefinementStart , {\n \"progressiveRefinementStart\" , \"h245.progressiveRefinementStart_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_repeatCount , {\n \"repeatCount\" , \"h245.repeatCount\" , FT_UINT32 , BASE_DEC , VALS ( h245_T_repeatCount_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_doOneProgression , {\n \"doOneProgression\" , \"h245.doOneProgression_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_doContinuousProgressions , {\n \"doContinuousProgressions\" , \"h245.doContinuousProgressions_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_doOneIndependentProgression , {\n \"doOneIndependentProgression\" , \"h245.doOneIndependentProgression_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_doContinuousIndependentProgressions , {\n \"doContinuousIndependentProgressions\" , \"h245.doContinuousIndependentProgressions_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_progressiveRefinementAbortOne , {\n \"progressiveRefinementAbortOne\" , \"h245.progressiveRefinementAbortOne_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_progressiveRefinementAbortContinuous , {\n \"progressiveRefinementAbortContinuous\" , \"h245.progressiveRefinementAbortContinuous_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_videoBadMBs , {\n \"videoBadMBs\" , \"h245.videoBadMBs_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_firstMB , {\n \"firstMB\" , \"h245.firstMB\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_9216\" , HFILL }\n }\n , {\n & hf_h245_numberOfMBs1_1_9216 , {\n \"numberOfMBs\" , \"h245.numberOfMBs\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_9216\" , HFILL }\n }\n , {\n & hf_h245_temporalReference , {\n \"temporalReference\" , \"h245.temporalReference\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_1023\" , HFILL }\n }\n , {\n & hf_h245_lostPicture , {\n \"lostPicture\" , \"h245.lostPicture\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"SEQUENCE_OF_PictureReference\" , HFILL }\n }\n , {\n & hf_h245_lostPicture_item , {\n \"PictureReference\" , \"h245.PictureReference\" , FT_UINT32 , BASE_DEC , VALS ( h245_PictureReference_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_lostPartialPicture , {\n \"lostPartialPicture\" , \"h245.lostPartialPicture_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_pictureReference , {\n \"pictureReference\" , \"h245.pictureReference\" , FT_UINT32 , BASE_DEC , VALS ( h245_PictureReference_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_recoveryReferencePicture , {\n \"recoveryReferencePicture\" , \"h245.recoveryReferencePicture\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"SEQUENCE_OF_PictureReference\" , HFILL }\n }\n , {\n & hf_h245_recoveryReferencePicture_item , {\n \"PictureReference\" , \"h245.PictureReference\" , FT_UINT32 , BASE_DEC , VALS ( h245_PictureReference_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_encryptionUpdateCommand , {\n \"encryptionUpdateCommand\" , \"h245.encryptionUpdateCommand_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_encryptionUpdateAck , {\n \"encryptionUpdateAck\" , \"h245.encryptionUpdateAck_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_direction , {\n \"direction\" , \"h245.direction\" , FT_UINT32 , BASE_DEC , VALS ( h245_EncryptionUpdateDirection_vals ) , 0 , \"EncryptionUpdateDirection\" , HFILL }\n }\n , {\n & hf_h245_secureChannel , {\n \"secureChannel\" , \"h245.secureChannel\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_sharedSecret , {\n \"sharedSecret\" , \"h245.sharedSecret\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_certProtectedKey , {\n \"certProtectedKey\" , \"h245.certProtectedKey\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_keyProtectionMethod , {\n \"keyProtectionMethod\" , \"h245.keyProtectionMethod_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_pictureNumber , {\n \"pictureNumber\" , \"h245.pictureNumber\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_1023\" , HFILL }\n }\n , {\n & hf_h245_longTermPictureIndex , {\n \"longTermPictureIndex\" , \"h245.longTermPictureIndex\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_255\" , HFILL }\n }\n , {\n & hf_h245_h223ModeChange , {\n \"h223ModeChange\" , \"h245.h223ModeChange\" , FT_UINT32 , BASE_DEC , VALS ( h245_T_h223ModeChange_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_toLevel0 , {\n \"toLevel0\" , \"h245.toLevel0_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_toLevel1 , {\n \"toLevel1\" , \"h245.toLevel1_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_toLevel2 , {\n \"toLevel2\" , \"h245.toLevel2_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_toLevel2withOptionalHeader , {\n \"toLevel2withOptionalHeader\" , \"h245.toLevel2withOptionalHeader_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_h223AnnexADoubleFlag , {\n \"h223AnnexADoubleFlag\" , \"h245.h223AnnexADoubleFlag\" , FT_UINT32 , BASE_DEC , VALS ( h245_T_h223AnnexADoubleFlag_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_start , {\n \"start\" , \"h245.start_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_stop , {\n \"stop\" , \"h245.stop_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_bitRate , {\n \"bitRate\" , \"h245.bitRate\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_65535\" , HFILL }\n }\n , {\n & hf_h245_bitRateLockedToPCRClock , {\n \"bitRateLockedToPCRClock\" , \"h245.bitRateLockedToPCRClock\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_bitRateLockedToNetworkClock , {\n \"bitRateLockedToNetworkClock\" , \"h245.bitRateLockedToNetworkClock\" , FT_BOOLEAN , BASE_NONE , NULL , 0 , \"BOOLEAN\" , HFILL }\n }\n , {\n & hf_h245_cmd_aal , {\n \"aal\" , \"h245.aal\" , FT_UINT32 , BASE_DEC , VALS ( h245_Cmd_aal_vals ) , 0 , \"Cmd_aal\" , HFILL }\n }\n , {\n & hf_h245_cmd_aal1 , {\n \"aal1\" , \"h245.aal1_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"Cmd_aal1\" , HFILL }\n }\n , {\n & hf_h245_cmd_clockRecovery , {\n \"clockRecovery\" , \"h245.clockRecovery\" , FT_UINT32 , BASE_DEC , VALS ( h245_Cmd_clockRecovery_vals ) , 0 , \"Cmd_clockRecovery\" , HFILL }\n }\n , {\n & hf_h245_nullClockRecoveryflag , {\n \"nullClockRecovery\" , \"h245.nullClockRecovery_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_srtsClockRecovery , {\n \"srtsClockRecovery\" , \"h245.srtsClockRecovery_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_adaptiveClockRecoveryFlag , {\n \"adaptiveClockRecovery\" , \"h245.adaptiveClockRecovery_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_cmd_errorCorrection , {\n \"errorCorrection\" , \"h245.errorCorrection\" , FT_UINT32 , BASE_DEC , VALS ( h245_Cmd_errorCorrection_vals ) , 0 , \"Cmd_errorCorrection\" , HFILL }\n }\n , {\n & hf_h245_nullErrorCorrectionFlag , {\n \"nullErrorCorrection\" , \"h245.nullErrorCorrection_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_longInterleaverFlag , {\n \"longInterleaver\" , \"h245.longInterleaver_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_shortInterleaverFlag , {\n \"shortInterleaver\" , \"h245.shortInterleaver_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_errorCorrectionOnlyFlag , {\n \"errorCorrectionOnly\" , \"h245.errorCorrectionOnly_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_cmd_aal5 , {\n \"aal5\" , \"h245.aal5_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"Cmd_aal5\" , HFILL }\n }\n , {\n & hf_h245_cmd_multiplex , {\n \"multiplex\" , \"h245.multiplex\" , FT_UINT32 , BASE_DEC , VALS ( h245_Cmd_multiplex_vals ) , 0 , \"Cmd_multiplex\" , HFILL }\n }\n , {\n & hf_h245_noMultiplex , {\n \"noMultiplex\" , \"h245.noMultiplex_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_transportStream , {\n \"transportStream\" , \"h245.transportStream_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_programStreamFlag , {\n \"programStream\" , \"h245.programStream_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_cmd_reverseParameters , {\n \"reverseParameters\" , \"h245.reverseParameters_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"Cmd_reverseParameters\" , HFILL }\n }\n , {\n & hf_h245_cmdr_multiplex , {\n \"multiplex\" , \"h245.multiplex\" , FT_UINT32 , BASE_DEC , VALS ( h245_CmdR_multiplex_vals ) , 0 , \"CmdR_multiplex\" , HFILL }\n }\n , {\n & hf_h245_sampleSize , {\n \"sampleSize\" , \"h245.sampleSize\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_255\" , HFILL }\n }\n , {\n & hf_h245_samplesPerFrame , {\n \"samplesPerFrame\" , \"h245.samplesPerFrame\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_255\" , HFILL }\n }\n , {\n & hf_h245_status , {\n \"status\" , \"h245.status\" , FT_UINT32 , BASE_DEC , VALS ( h245_T_status_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_synchronized , {\n \"synchronized\" , \"h245.synchronized_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_reconfiguration , {\n \"reconfiguration\" , \"h245.reconfiguration_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_fns_cause , {\n \"cause\" , \"h245.cause\" , FT_UINT32 , BASE_DEC , VALS ( h245_FunctionNotSupportedCause_vals ) , 0 , \"FunctionNotSupportedCause\" , HFILL }\n }\n , {\n & hf_h245_syntaxError , {\n \"syntaxError\" , \"h245.syntaxError_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_semanticError , {\n \"semanticError\" , \"h245.semanticError_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_unknownFunction , {\n \"unknownFunction\" , \"h245.unknownFunction_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_returnedFunction , {\n \"returnedFunction\" , \"h245.returnedFunction\" , FT_BYTES , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_sbeNumber , {\n \"sbeNumber\" , \"h245.sbeNumber\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_9\" , HFILL }\n }\n , {\n & hf_h245_terminalNumberAssign , {\n \"terminalNumberAssign\" , \"h245.terminalNumberAssign_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"TerminalLabel\" , HFILL }\n }\n , {\n & hf_h245_terminalJoinedConference , {\n \"terminalJoinedConference\" , \"h245.terminalJoinedConference_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"TerminalLabel\" , HFILL }\n }\n , {\n & hf_h245_terminalLeftConference , {\n \"terminalLeftConference\" , \"h245.terminalLeftConference_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"TerminalLabel\" , HFILL }\n }\n , {\n & hf_h245_seenByAtLeastOneOther , {\n \"seenByAtLeastOneOther\" , \"h245.seenByAtLeastOneOther_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_cancelSeenByAtLeastOneOther , {\n \"cancelSeenByAtLeastOneOther\" , \"h245.cancelSeenByAtLeastOneOther_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_seenByAll , {\n \"seenByAll\" , \"h245.seenByAll_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_cancelSeenByAll , {\n \"cancelSeenByAll\" , \"h245.cancelSeenByAll_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_terminalYouAreSeeing , {\n \"terminalYouAreSeeing\" , \"h245.terminalYouAreSeeing_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"TerminalLabel\" , HFILL }\n }\n , {\n & hf_h245_requestForFloor , {\n \"requestForFloor\" , \"h245.requestForFloor_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_withdrawChairToken , {\n \"withdrawChairToken\" , \"h245.withdrawChairToken_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_floorRequested , {\n \"floorRequested\" , \"h245.floorRequested_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"TerminalLabel\" , HFILL }\n }\n , {\n & hf_h245_terminalYouAreSeeingInSubPictureNumber , {\n \"terminalYouAreSeeingInSubPictureNumber\" , \"h245.terminalYouAreSeeingInSubPictureNumber_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_videoIndicateCompose , {\n \"videoIndicateCompose\" , \"h245.videoIndicateCompose_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_masterMCU , {\n \"masterMCU\" , \"h245.masterMCU_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_cancelMasterMCU , {\n \"cancelMasterMCU\" , \"h245.cancelMasterMCU_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_subPictureNumber , {\n \"subPictureNumber\" , \"h245.subPictureNumber\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_255\" , HFILL }\n }\n , {\n & hf_h245_compositionNumber , {\n \"compositionNumber\" , \"h245.compositionNumber\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_255\" , HFILL }\n }\n , {\n & hf_h245_mi_type , {\n \"type\" , \"h245.type\" , FT_UINT32 , BASE_DEC , VALS ( h245_Mi_type_vals ) , 0 , \"Mi_type\" , HFILL }\n }\n , {\n & hf_h245_logicalChannelActive , {\n \"logicalChannelActive\" , \"h245.logicalChannelActive_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_logicalChannelInactive , {\n \"logicalChannelInactive\" , \"h245.logicalChannelInactive_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_multipointConference , {\n \"multipointConference\" , \"h245.multipointConference_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_cancelMultipointConference , {\n \"cancelMultipointConference\" , \"h245.cancelMultipointConference_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_multipointZeroComm , {\n \"multipointZeroComm\" , \"h245.multipointZeroComm_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_cancelMultipointZeroComm , {\n \"cancelMultipointZeroComm\" , \"h245.cancelMultipointZeroComm_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_multipointSecondaryStatus , {\n \"multipointSecondaryStatus\" , \"h245.multipointSecondaryStatus_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_cancelMultipointSecondaryStatus , {\n \"cancelMultipointSecondaryStatus\" , \"h245.cancelMultipointSecondaryStatus_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_videoIndicateReadyToActivate , {\n \"videoIndicateReadyToActivate\" , \"h245.videoIndicateReadyToActivate_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_videoNotDecodedMBs , {\n \"videoNotDecodedMBs\" , \"h245.videoNotDecodedMBs_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_temporalReference_0_255 , {\n \"temporalReference\" , \"h245.temporalReference\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_255\" , HFILL }\n }\n , {\n & hf_h245_estimatedReceivedJitterMantissa , {\n \"estimatedReceivedJitterMantissa\" , \"h245.estimatedReceivedJitterMantissa\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_3\" , HFILL }\n }\n , {\n & hf_h245_estimatedReceivedJitterExponent , {\n \"estimatedReceivedJitterExponent\" , \"h245.estimatedReceivedJitterExponent\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_7\" , HFILL }\n }\n , {\n & hf_h245_skippedFrameCount , {\n \"skippedFrameCount\" , \"h245.skippedFrameCount\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_15\" , HFILL }\n }\n , {\n & hf_h245_additionalDecoderBuffer , {\n \"additionalDecoderBuffer\" , \"h245.additionalDecoderBuffer\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_262143\" , HFILL }\n }\n , {\n & hf_h245_logicalChannelNumber1 , {\n \"logicalChannelNumber1\" , \"h245.logicalChannelNumber1\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"LogicalChannelNumber\" , HFILL }\n }\n , {\n & hf_h245_logicalChannelNumber2 , {\n \"logicalChannelNumber2\" , \"h245.logicalChannelNumber2\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"LogicalChannelNumber\" , HFILL }\n }\n , {\n & hf_h245_skew , {\n \"skew\" , \"h245.skew\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_4095\" , HFILL }\n }\n , {\n & hf_h245_maximumSkew , {\n \"maximumSkew\" , \"h245.maximumSkew\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_4095\" , HFILL }\n }\n , {\n & hf_h245_signalAddress , {\n \"signalAddress\" , \"h245.signalAddress\" , FT_UINT32 , BASE_DEC , VALS ( h245_TransportAddress_vals ) , 0 , \"TransportAddress\" , HFILL }\n }\n , {\n & hf_h245_vendor , {\n \"vendor\" , \"h245.vendor\" , FT_UINT32 , BASE_DEC , VALS ( h245_NonStandardIdentifier_vals ) , 0 , \"NonStandardIdentifier\" , HFILL }\n }\n , {\n & hf_h245_productNumber , {\n \"productNumber\" , \"h245.productNumber\" , FT_STRING , BASE_NONE , NULL , 0 , \"OCTET_STRING_SIZE_1_256\" , HFILL }\n }\n , {\n & hf_h245_versionNumber , {\n \"versionNumber\" , \"h245.versionNumber\" , FT_STRING , BASE_NONE , NULL , 0 , \"OCTET_STRING_SIZE_1_256\" , HFILL }\n }\n , {\n & hf_h245_ind_aal , {\n \"aal\" , \"h245.aal\" , FT_UINT32 , BASE_DEC , VALS ( h245_Ind_aal_vals ) , 0 , \"Ind_aal\" , HFILL }\n }\n , {\n & hf_h245_ind_aal1 , {\n \"aal1\" , \"h245.aal1_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"Ind_aal1\" , HFILL }\n }\n , {\n & hf_h245_ind_clockRecovery , {\n \"clockRecovery\" , \"h245.clockRecovery\" , FT_UINT32 , BASE_DEC , VALS ( h245_Ind_clockRecovery_vals ) , 0 , \"Ind_clockRecovery\" , HFILL }\n }\n , {\n & hf_h245_ind_errorCorrection , {\n \"errorCorrection\" , \"h245.errorCorrection\" , FT_UINT32 , BASE_DEC , VALS ( h245_Ind_errorCorrection_vals ) , 0 , \"Ind_errorCorrection\" , HFILL }\n }\n , {\n & hf_h245_ind_aal5 , {\n \"aal5\" , \"h245.aal5_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"Ind_aal5\" , HFILL }\n }\n , {\n & hf_h245_ind_multiplex , {\n \"multiplex\" , \"h245.multiplex\" , FT_UINT32 , BASE_DEC , VALS ( h245_Ind_multiplex_vals ) , 0 , \"Ind_multiplex\" , HFILL }\n }\n , {\n & hf_h245_ind_reverseParameters , {\n \"reverseParameters\" , \"h245.reverseParameters_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"Ind_reverseParameters\" , HFILL }\n }\n , {\n & hf_h245_indr_multiplex , {\n \"multiplex\" , \"h245.multiplex\" , FT_UINT32 , BASE_DEC , VALS ( h245_IndR_multiplex_vals ) , 0 , \"IndR_multiplex\" , HFILL }\n }\n , {\n & hf_h245_iv8 , {\n \"iv8\" , \"h245.iv8\" , FT_BYTES , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_iv16 , {\n \"iv16\" , \"h245.iv16\" , FT_BYTES , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_iv , {\n \"iv\" , \"h245.iv\" , FT_BYTES , BASE_NONE , NULL , 0 , \"OCTET_STRING\" , HFILL }\n }\n , {\n & hf_h245_alphanumeric , {\n \"alphanumeric\" , \"h245.alphanumeric\" , FT_STRING , BASE_NONE , NULL , 0 , \"GeneralString\" , HFILL }\n }\n , {\n & hf_h245_userInputSupportIndication , {\n \"userInputSupportIndication\" , \"h245.userInputSupportIndication\" , FT_UINT32 , BASE_DEC , VALS ( h245_T_userInputSupportIndication_vals ) , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_signal , {\n \"signal\" , \"h245.signal_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_signalType , {\n \"signalType\" , \"h245.signalType\" , FT_STRING , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_duration , {\n \"duration\" , \"h245.duration\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_1_65535\" , HFILL }\n }\n , {\n & hf_h245_rtp , {\n \"rtp\" , \"h245.rtp_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_timestamp , {\n \"timestamp\" , \"h245.timestamp\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_4294967295\" , HFILL }\n }\n , {\n & hf_h245_expirationTime , {\n \"expirationTime\" , \"h245.expirationTime\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"INTEGER_0_4294967295\" , HFILL }\n }\n , {\n & hf_h245_rtpPayloadIndication , {\n \"rtpPayloadIndication\" , \"h245.rtpPayloadIndication_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_paramS , {\n \"paramS\" , \"h245.paramS_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_encryptedSignalType , {\n \"encryptedSignalType\" , \"h245.encryptedSignalType\" , FT_BYTES , BASE_NONE , NULL , 0 , \"OCTET_STRING_SIZE_1\" , HFILL }\n }\n , {\n & hf_h245_algorithmOID , {\n \"algorithmOID\" , \"h245.algorithmOID\" , FT_OID , BASE_NONE , NULL , 0 , \"OBJECT_IDENTIFIER\" , HFILL }\n }\n , {\n & hf_h245_signalUpdate , {\n \"signalUpdate\" , \"h245.signalUpdate_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_si_rtp , {\n \"rtp\" , \"h245.rtp_element\" , FT_NONE , BASE_NONE , NULL , 0 , \"Si_rtp\" , HFILL }\n }\n , {\n & hf_h245_extendedAlphanumeric , {\n \"extendedAlphanumeric\" , \"h245.extendedAlphanumeric_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_h245_encrypted , {\n \"encrypted\" , \"h245.encrypted\" , FT_BYTES , BASE_NONE , NULL , 0 , \"OCTET_STRING\" , HFILL }\n }\n , {\n & hf_h245_encryptedAlphanumeric , {\n \"encryptedAlphanumeric\" , \"h245.encryptedAlphanumeric_element\" , FT_NONE , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , # line 481 \"../../asn1/h245/packet-h245-template.c\" }\n ;\n static gint * ett [ ] = {\n & ett_h245 , & ett_h245_returnedFunction , # line 1 \"../../asn1/h245/packet-h245-ettarr.c\" & ett_h245_MultimediaSystemControlMessage , & ett_h245_RequestMessage , & ett_h245_ResponseMessage , & ett_h245_CommandMessage , & ett_h245_IndicationMessage , & ett_h245_GenericMessage , & ett_h245_T_messageContent , & ett_h245_NonStandardMessage , & ett_h245_NonStandardParameter , & ett_h245_NonStandardIdentifier , & ett_h245_H221NonStandardID , & ett_h245_MasterSlaveDetermination , & ett_h245_MasterSlaveDeterminationAck , & ett_h245_T_decision , & ett_h245_MasterSlaveDeterminationReject , & ett_h245_MasterSlaveDeterminationRejectCause , & ett_h245_MasterSlaveDeterminationRelease , & ett_h245_TerminalCapabilitySet , & ett_h245_SET_SIZE_1_256_OF_CapabilityTableEntry , & ett_h245_SET_SIZE_1_256_OF_CapabilityDescriptor , & ett_h245_SEQUENCE_OF_GenericInformation , & ett_h245_CapabilityTableEntry , & ett_h245_CapabilityDescriptor , & ett_h245_SET_SIZE_1_256_OF_AlternativeCapabilitySet , & ett_h245_AlternativeCapabilitySet , & ett_h245_TerminalCapabilitySetAck , & ett_h245_TerminalCapabilitySetReject , & ett_h245_TerminalCapabilitySetRejectCause , & ett_h245_T_tableEntryCapacityExceeded , & ett_h245_TerminalCapabilitySetRelease , & ett_h245_Capability , & ett_h245_T_h233EncryptionReceiveCapability , & ett_h245_H235SecurityCapability , & ett_h245_MultiplexCapability , & ett_h245_H222Capability , & ett_h245_SET_OF_VCCapability , & ett_h245_VCCapability , & ett_h245_T_aal1 , & ett_h245_T_aal5 , & ett_h245_T_availableBitRates , & ett_h245_Avb_type , & ett_h245_T_rangeOfBitRates , & ett_h245_T_aal1ViaGateway , & ett_h245_SET_SIZE_1_256_OF_Q2931Address , & ett_h245_H223Capability , & ett_h245_T_h223MultiplexTableCapability , & ett_h245_T_enhanced , & ett_h245_T_mobileOperationTransmitCapability , & ett_h245_T_mobileMultilinkFrameCapability , & ett_h245_H223AnnexCCapability , & ett_h245_V76Capability , & ett_h245_V75Capability , & ett_h245_H2250Capability , & ett_h245_T_mcCapability , & ett_h245_SEQUENCE_SIZE_1_256_OF_RedundancyEncodingCapability , & ett_h245_MediaPacketizationCapability , & ett_h245_SEQUENCE_SIZE_1_256_OF_RTPPayloadType , & ett_h245_RSVPParameters , & ett_h245_QOSMode , & ett_h245_ATMParameters , & ett_h245_ServicePriorityValue , & ett_h245_ServicePriority , & ett_h245_AuthorizationParameters , & ett_h245_QOSType , & ett_h245_QOSClass , & ett_h245_QOSDescriptor , & ett_h245_GenericTransportParameters , & ett_h245_QOSCapability , & ett_h245_MediaTransportType , & ett_h245_T_atm_AAL5_compressed , & ett_h245_MediaChannelCapability , & ett_h245_TransportCapability , & ett_h245_SEQUENCE_SIZE_1_256_OF_QOSCapability , & ett_h245_SEQUENCE_SIZE_1_256_OF_MediaChannelCapability , & ett_h245_RedundancyEncodingCapability , & ett_h245_SEQUENCE_SIZE_1_256_OF_CapabilityTableEntryNumber , & ett_h245_RedundancyEncodingMethod , & ett_h245_RTPH263VideoRedundancyEncoding , & ett_h245_T_frameToThreadMapping , & ett_h245_SEQUENCE_SIZE_1_256_OF_RTPH263VideoRedundancyFrameMapping , & ett_h245_T_containedThreads , & ett_h245_RTPH263VideoRedundancyFrameMapping , & ett_h245_T_frameSequence , & ett_h245_MultipointCapability , & ett_h245_SEQUENCE_OF_MediaDistributionCapability , & ett_h245_MediaDistributionCapability , & ett_h245_SEQUENCE_OF_DataApplicationCapability , & ett_h245_VideoCapability , & ett_h245_ExtendedVideoCapability , & ett_h245_SEQUENCE_OF_VideoCapability , & ett_h245_SEQUENCE_OF_GenericCapability , & ett_h245_H261VideoCapability , & ett_h245_H262VideoCapability , & ett_h245_H263VideoCapability , & ett_h245_EnhancementLayerInfo , & ett_h245_SET_SIZE_1_14_OF_EnhancementOptions , & ett_h245_SET_SIZE_1_14_OF_BEnhancementParameters , & ett_h245_BEnhancementParameters , & ett_h245_EnhancementOptions , & ett_h245_H263Options , & ett_h245_SET_SIZE_1_16_OF_CustomPictureClockFrequency , & ett_h245_SET_SIZE_1_16_OF_CustomPictureFormat , & ett_h245_SET_SIZE_1_16_OF_H263VideoModeCombos , & ett_h245_TransparencyParameters , & ett_h245_RefPictureSelection , & ett_h245_T_additionalPictureMemory , & ett_h245_T_videoBackChannelSend , & ett_h245_T_enhancedReferencePicSelect , & ett_h245_T_subPictureRemovalParameters , & ett_h245_CustomPictureClockFrequency , & ett_h245_CustomPictureFormat , & ett_h245_T_mPI , & ett_h245_T_customPCF , & ett_h245_T_customPCF_item , & ett_h245_T_pixelAspectInformation , & ett_h245_T_pixelAspectCode , & ett_h245_T_extendedPAR , & ett_h245_T_extendedPAR_item , & ett_h245_H263VideoModeCombos , & ett_h245_SET_SIZE_1_16_OF_H263ModeComboFlags , & ett_h245_H263ModeComboFlags , & ett_h245_H263Version3Options , & ett_h245_IS11172VideoCapability , & ett_h245_AudioCapability , & ett_h245_T_g7231 , & ett_h245_G729Extensions , & ett_h245_G7231AnnexCCapability , & ett_h245_G723AnnexCAudioMode , & ett_h245_IS11172AudioCapability , & ett_h245_IS13818AudioCapability , & ett_h245_GSMAudioCapability , & ett_h245_VBDCapability , & ett_h245_DataApplicationCapability , & ett_h245_Application , & ett_h245_T_t84 , & ett_h245_Nlpid , & ett_h245_T_t38fax , & ett_h245_DataProtocolCapability , & ett_h245_T_v76wCompression , & ett_h245_CompressionType , & ett_h245_V42bis , & ett_h245_T84Profile , & ett_h245_T_t84Restricted , & ett_h245_T38FaxProfile , & ett_h245_T38FaxRateManagement , & ett_h245_T38FaxUdpOptions , & ett_h245_T_t38FaxUdpEC , & ett_h245_T38FaxTcpOptions , & ett_h245_EncryptionAuthenticationAndIntegrity , & ett_h245_EncryptionCapability , & ett_h245_MediaEncryptionAlgorithm , & ett_h245_AuthenticationCapability , & ett_h245_IntegrityCapability , & ett_h245_UserInputCapability , & ett_h245_SEQUENCE_SIZE_1_16_OF_NonStandardParameter , & ett_h245_ConferenceCapability , & ett_h245_SEQUENCE_OF_NonStandardParameter , & ett_h245_GenericCapability , & ett_h245_T_collapsing , & ett_h245_T_nonCollapsing , & ett_h245_CapabilityIdentifier , & ett_h245_GenericParameter , & ett_h245_SEQUENCE_OF_ParameterIdentifier , & ett_h245_ParameterIdentifier , & ett_h245_ParameterValue , & ett_h245_SEQUENCE_OF_GenericParameter , & ett_h245_MultiplexedStreamCapability , & ett_h245_MultiplexFormat , & ett_h245_AudioTelephonyEventCapability , & ett_h245_AudioToneCapability , & ett_h245_NoPTAudioTelephonyEventCapability , & ett_h245_NoPTAudioToneCapability , & ett_h245_MultiplePayloadStreamCapability , & ett_h245_DepFECCapability , & ett_h245_FECC_rfc2733 , & ett_h245_T_separateStreamBool , & ett_h245_FECCapability , & ett_h245_Rfc2733Format , & ett_h245_OpenLogicalChannel , & ett_h245_T_forwardLogicalChannelParameters , & ett_h245_OLC_forw_multiplexParameters , & ett_h245_OLC_reverseLogicalChannelParameters , & ett_h245_OLC_rev_multiplexParameters , & ett_h245_NetworkAccessParameters , & ett_h245_T_distribution , & ett_h245_T_networkAddress , & ett_h245_T_t120SetupProcedure , & ett_h245_Q2931Address , & ett_h245_T_address , & ett_h245_V75Parameters , & ett_h245_DataType , & ett_h245_H235Media , & ett_h245_T_mediaType , & ett_h245_MultiplexedStreamParameter , & ett_h245_H222LogicalChannelParameters , & ett_h245_H223LogicalChannelParameters , & ett_h245_T_adaptationLayerType , & ett_h245_Al3 , & ett_h245_H223AL1MParameters , & ett_h245_T_transferMode , & ett_h245_AL1HeaderFEC , & ett_h245_AL1CrcLength , & ett_h245_ArqType , & ett_h245_H223AL2MParameters , & ett_h245_AL2HeaderFEC , & ett_h245_H223AL3MParameters , & ett_h245_T_headerFormat , & ett_h245_AL3CrcLength , & ett_h245_H223AnnexCArqParameters , & ett_h245_T_numberOfRetransmissions , & ett_h245_V76LogicalChannelParameters , & ett_h245_T_suspendResume , & ett_h245_V76LCP_mode , & ett_h245_T_eRM , & ett_h245_T_recovery , & ett_h245_V76HDLCParameters , & ett_h245_CRCLength , & ett_h245_H2250LogicalChannelParameters , & ett_h245_T_mediaPacketization , & ett_h245_RTPPayloadType , & ett_h245_T_payloadDescriptor , & ett_h245_RedundancyEncoding , & ett_h245_T_rtpRedundancyEncoding , & ett_h245_SEQUENCE_OF_RedundancyEncodingElement , & ett_h245_RedundancyEncodingElement , & ett_h245_MultiplePayloadStream , & ett_h245_SEQUENCE_OF_MultiplePayloadStreamElement , & ett_h245_MultiplePayloadStreamElement , & ett_h245_DepFECData , & ett_h245_RFC2733Data , & ett_h245_FECdata_mode , & ett_h245_DepSeparateStream , & ett_h245_T_differentPort , & ett_h245_T_samePort , & ett_h245_FECData , & ett_h245_T_rfc2733 , & ett_h245_T_pktMode , & ett_h245_T_mode_rfc2733sameport , & ett_h245_T_mode_rfc2733diffport , & ett_h245_TransportAddress , & ett_h245_UnicastAddress , & ett_h245_T_iPAddress , & ett_h245_T_iPXAddress , & ett_h245_T_iP6Address , & ett_h245_T_iPSourceRouteAddress , & ett_h245_T_routing , & ett_h245_T_route , & ett_h245_MulticastAddress , & ett_h245_MIPAddress , & ett_h245_MIP6Address , & ett_h245_EncryptionSync , & ett_h245_SEQUENCE_SIZE_1_256_OF_EscrowData , & ett_h245_EscrowData , & ett_h245_OpenLogicalChannelAck , & ett_h245_OLC_ack_reverseLogicalChannelParameters , & ett_h245_T_olc_ack_multiplexParameters , & ett_h245_T_forwardMultiplexAckParameters , & ett_h245_OpenLogicalChannelReject , & ett_h245_OpenLogicalChannelRejectCause , & ett_h245_OpenLogicalChannelConfirm , & ett_h245_H2250LogicalChannelAckParameters , & ett_h245_CloseLogicalChannel , & ett_h245_T_cLC_source , & ett_h245_Clc_reason , & ett_h245_CloseLogicalChannelAck , & ett_h245_RequestChannelClose , & ett_h245_T_reason , & ett_h245_RequestChannelCloseAck , & ett_h245_RequestChannelCloseReject , & ett_h245_RequestChannelCloseRejectCause , & ett_h245_RequestChannelCloseRelease , & ett_h245_MultiplexEntrySend , & ett_h245_SET_SIZE_1_15_OF_MultiplexEntryDescriptor , & ett_h245_MultiplexEntryDescriptor , & ett_h245_T_elementList , & ett_h245_MultiplexElement , & ett_h245_Me_type , & ett_h245_T_subElementList , & ett_h245_ME_repeatCount , & ett_h245_MultiplexEntrySendAck , & ett_h245_SET_SIZE_1_15_OF_MultiplexTableEntryNumber , & ett_h245_MultiplexEntrySendReject , & ett_h245_SET_SIZE_1_15_OF_MultiplexEntryRejectionDescriptions , & ett_h245_MultiplexEntryRejectionDescriptions , & ett_h245_MultiplexEntryRejectionDescriptionsCause , & ett_h245_MultiplexEntrySendRelease , & ett_h245_RequestMultiplexEntry , & ett_h245_RequestMultiplexEntryAck , & ett_h245_RequestMultiplexEntryReject , & ett_h245_SET_SIZE_1_15_OF_RequestMultiplexEntryRejectionDescriptions , & ett_h245_RequestMultiplexEntryRejectionDescriptions , & ett_h245_RequestMultiplexEntryRejectionDescriptionsCause , & ett_h245_RequestMultiplexEntryRelease , & ett_h245_RequestMode , & ett_h245_SEQUENCE_SIZE_1_256_OF_ModeDescription , & ett_h245_RequestModeAck , & ett_h245_Req_mode_ack_response , & ett_h245_RequestModeReject , & ett_h245_RequestModeRejectCause , & ett_h245_RequestModeRelease , & ett_h245_ModeDescription , & ett_h245_ModeElementType , & ett_h245_ModeElement , & ett_h245_H235Mode , & ett_h245_T_mediaMode , & ett_h245_MultiplexedStreamModeParameters , & ett_h245_RedundancyEncodingDTMode , & ett_h245_SEQUENCE_OF_RedundancyEncodingDTModeElement , & ett_h245_RedundancyEncodingDTModeElement , & ett_h245_Re_type , & ett_h245_MultiplePayloadStreamMode , & ett_h245_SEQUENCE_OF_MultiplePayloadStreamElementMode , & ett_h245_MultiplePayloadStreamElementMode , & ett_h245_DepFECMode , & ett_h245_T_rfc2733Mode , & ett_h245_FEC_mode , & ett_h245_FECMode , & ett_h245_H223ModeParameters , & ett_h245_AdaptationLayerType , & ett_h245_V76ModeParameters , & ett_h245_H2250ModeParameters , & ett_h245_RedundancyEncodingMode , & ett_h245_T_secondaryEncodingMode , & ett_h245_VideoMode , & ett_h245_H261VideoMode , & ett_h245_H261Resolution , & ett_h245_H262VideoMode , & ett_h245_T_profileAndLevel , & ett_h245_H263VideoMode , & ett_h245_H263Resolution , & ett_h245_IS11172VideoMode , & ett_h245_AudioMode , & ett_h245_Mode_g7231 , & ett_h245_IS11172AudioMode , & ett_h245_T_audioLayer , & ett_h245_T_audioSampling , & ett_h245_IS11172_multichannelType , & ett_h245_IS13818AudioMode , & ett_h245_IS13818AudioLayer , & ett_h245_IS13818AudioSampling , & ett_h245_IS13818MultichannelType , & ett_h245_G7231AnnexCMode , & ett_h245_VBDMode , & ett_h245_DataMode , & ett_h245_DataModeApplication , & ett_h245_T38faxApp , & ett_h245_EncryptionMode , & ett_h245_RoundTripDelayRequest , & ett_h245_RoundTripDelayResponse , & ett_h245_MaintenanceLoopRequest , & ett_h245_Mlr_type , & ett_h245_MaintenanceLoopAck , & ett_h245_Mla_type , & ett_h245_MaintenanceLoopReject , & ett_h245_Mlrej_type , & ett_h245_MaintenanceLoopRejectCause , & ett_h245_MaintenanceLoopOffCommand , & ett_h245_CommunicationModeCommand , & ett_h245_SET_SIZE_1_256_OF_CommunicationModeTableEntry , & ett_h245_CommunicationModeRequest , & ett_h245_CommunicationModeResponse , & ett_h245_CommunicationModeTableEntry , & ett_h245_T_entryDataType , & ett_h245_ConferenceRequest , & ett_h245_T_requestTerminalCertificate , & ett_h245_CertSelectionCriteria , & ett_h245_Criteria , & ett_h245_TerminalLabel , & ett_h245_ConferenceResponse , & ett_h245_T_mCTerminalIDResponse , & ett_h245_T_terminalIDResponse , & ett_h245_T_conferenceIDResponse , & ett_h245_T_passwordResponse , & ett_h245_SET_SIZE_1_256_OF_TerminalLabel , & ett_h245_T_makeMeChairResponse , & ett_h245_T_extensionAddressResponse , & ett_h245_T_chairTokenOwnerResponse , & ett_h245_T_terminalCertificateResponse , & ett_h245_T_broadcastMyLogicalChannelResponse , & ett_h245_T_makeTerminalBroadcasterResponse , & ett_h245_T_sendThisSourceResponse , & ett_h245_RequestAllTerminalIDsResponse , & ett_h245_SEQUENCE_OF_TerminalInformation , & ett_h245_TerminalInformation , & ett_h245_RemoteMCRequest , & ett_h245_RemoteMCResponse , & ett_h245_T_reject , & ett_h245_MultilinkRequest , & ett_h245_CallInformationReq , & ett_h245_AddConnectionReq , & ett_h245_RemoveConnectionReq , & ett_h245_MaximumHeaderIntervalReq , & ett_h245_T_requestType , & ett_h245_MultilinkResponse , & ett_h245_CallInformationResp , & ett_h245_AddConnectionResp , & ett_h245_T_responseCode , & ett_h245_T_rejected , & ett_h245_RemoveConnectionResp , & ett_h245_MaximumHeaderIntervalResp , & ett_h245_MultilinkIndication , & ett_h245_T_crcDesired , & ett_h245_T_excessiveError , & ett_h245_DialingInformation , & ett_h245_SET_SIZE_1_65535_OF_DialingInformationNumber , & ett_h245_DialingInformationNumber , & ett_h245_SET_SIZE_1_255_OF_DialingInformationNetworkType , & ett_h245_DialingInformationNetworkType , & ett_h245_ConnectionIdentifier , & ett_h245_LogicalChannelRateRequest , & ett_h245_LogicalChannelRateAcknowledge , & ett_h245_LogicalChannelRateReject , & ett_h245_LogicalChannelRateRejectReason , & ett_h245_LogicalChannelRateRelease , & ett_h245_SendTerminalCapabilitySet , & ett_h245_T_specificRequest , & ett_h245_SET_SIZE_1_65535_OF_CapabilityTableEntryNumber , & ett_h245_SET_SIZE_1_256_OF_CapabilityDescriptorNumber , & ett_h245_EncryptionCommand , & ett_h245_T_encryptionAlgorithmID , & ett_h245_FlowControlCommand , & ett_h245_Scope , & ett_h245_Restriction , & ett_h245_EndSessionCommand , & ett_h245_T_gstnOptions , & ett_h245_T_isdnOptions , & ett_h245_ConferenceCommand , & ett_h245_SubstituteConferenceIDCommand , & ett_h245_EncryptionUpdateDirection , & ett_h245_MiscellaneousCommand , & ett_h245_Mc_type , & ett_h245_T_videoFastUpdateGOB , & ett_h245_T_videoFastUpdateMB , & ett_h245_T_progressiveRefinementStart , & ett_h245_T_repeatCount , & ett_h245_T_videoBadMBs , & ett_h245_SEQUENCE_OF_PictureReference , & ett_h245_T_lostPartialPicture , & ett_h245_T_encryptionUpdateCommand , & ett_h245_T_encryptionUpdateAck , & ett_h245_KeyProtectionMethod , & ett_h245_EncryptionUpdateRequest , & ett_h245_PictureReference , & ett_h245_H223MultiplexReconfiguration , & ett_h245_T_h223ModeChange , & ett_h245_T_h223AnnexADoubleFlag , & ett_h245_NewATMVCCommand , & ett_h245_Cmd_aal , & ett_h245_Cmd_aal1 , & ett_h245_Cmd_clockRecovery , & ett_h245_Cmd_errorCorrection , & ett_h245_Cmd_aal5 , & ett_h245_Cmd_multiplex , & ett_h245_Cmd_reverseParameters , & ett_h245_CmdR_multiplex , & ett_h245_MobileMultilinkReconfigurationCommand , & ett_h245_T_status , & ett_h245_FunctionNotUnderstood , & ett_h245_FunctionNotSupported , & ett_h245_FunctionNotSupportedCause , & ett_h245_ConferenceIndication , & ett_h245_TerminalYouAreSeeingInSubPictureNumber , & ett_h245_VideoIndicateCompose , & ett_h245_MiscellaneousIndication , & ett_h245_Mi_type , & ett_h245_T_videoNotDecodedMBs , & ett_h245_JitterIndication , & ett_h245_H223SkewIndication , & ett_h245_H2250MaximumSkewIndication , & ett_h245_MCLocationIndication , & ett_h245_VendorIdentification , & ett_h245_NewATMVCIndication , & ett_h245_Ind_aal , & ett_h245_Ind_aal1 , & ett_h245_Ind_clockRecovery , & ett_h245_Ind_errorCorrection , & ett_h245_Ind_aal5 , & ett_h245_Ind_multiplex , & ett_h245_Ind_reverseParameters , & ett_h245_IndR_multiplex , & ett_h245_Params , & ett_h245_UserInputIndication , & ett_h245_T_userInputSupportIndication , & ett_h245_T_signal , & ett_h245_T_rtp , & ett_h245_T_signalUpdate , & ett_h245_Si_rtp , & ett_h245_T_extendedAlphanumeric , & ett_h245_EncryptedAlphanumeric , & ett_h245_FlowControlIndication , & ett_h245_MobileMultilinkReconfigurationIndication , # line 488 \"../../asn1/h245/packet-h245-template.c\" }\n ;\n module_t * h245_module ;\n proto_h245 = proto_register_protocol ( PNAME , PSNAME , PFNAME ) ;\n register_init_routine ( h245_init ) ;\n proto_register_field_array ( proto_h245 , hf , array_length ( hf ) ) ;\n proto_register_subtree_array ( ett , array_length ( ett ) ) ;\n h245_module = prefs_register_protocol ( proto_h245 , NULL ) ;\n prefs_register_bool_preference ( h245_module , \"reassembly\" , \"Reassemble H.245 messages spanning multiple TCP segments\" , \"Whether the H.245 dissector should reassemble messages spanning multiple TCP segments.\" \" To use this option, you must also enable \\\"Allow subdissectors to reassemble TCP streams\\\" in the TCP protocol settings.\" , & h245_reassembly ) ;\n prefs_register_bool_preference ( h245_module , \"shorttypes\" , \"Show short message types\" , \"Whether the dissector should show short names or the long names from the standard\" , & h245_shorttypes ) ;\n register_dissector ( \"h245dg\" , dissect_h245_h245 , proto_h245 ) ;\n register_dissector ( \"h245\" , dissect_h245 , proto_h245 ) ;\n nsp_object_dissector_table = register_dissector_table ( \"h245.nsp.object\" , \"H.245 NonStandardParameter (object)\" , FT_STRING , BASE_NONE ) ;\n nsp_h221_dissector_table = register_dissector_table ( \"h245.nsp.h221\" , \"H.245 NonStandardParameter (h221)\" , FT_UINT32 , BASE_HEX ) ;\n gef_name_dissector_table = register_dissector_table ( \"h245.gef.name\" , \"H.245 Generic Extensible Framework (names)\" , FT_STRING , BASE_NONE ) ;\n gef_content_dissector_table = register_dissector_table ( \"h245.gef.content\" , \"H.245 Generic Extensible Framework\" , FT_STRING , BASE_NONE ) ;\n h245_tap = register_tap ( \"h245\" ) ;\n h245dg_tap = register_tap ( \"h245dg\" ) ;\n oid_add_from_string ( \"h239ControlCapability\" , \"0.0.8.239.1.1\" ) ;\n oid_add_from_string ( \"h239ExtendedVideoCapability\" , \"0.0.8.239.1.2\" ) ;\n oid_add_from_string ( \"generic-message\" , \"0.0.8.239.2\" ) ;\n oid_add_from_string ( \"h245 version 3\" , \"0.0.8.245.0.3\" ) ;\n oid_add_from_string ( \"h245 version 4\" , \"0.0.8.245.0.4\" ) ;\n oid_add_from_string ( \"h245 version 5\" , \"0.0.8.245.0.5\" ) ;\n oid_add_from_string ( \"h245 version 6\" , \"0.0.8.245.0.6\" ) ;\n oid_add_from_string ( \"h245 version 7\" , \"0.0.8.245.0.7\" ) ;\n oid_add_from_string ( \"h245 version 8\" , \"0.0.8.245.0.8\" ) ;\n oid_add_from_string ( \"h245 version 9\" , \"0.0.8.245.0.9\" ) ;\n oid_add_from_string ( \"h245 version 10\" , \"0.0.8.245.0.10\" ) ;\n oid_add_from_string ( \"h245 version 11\" , \"0.0.8.245.0.11\" ) ;\n oid_add_from_string ( \"h245 version 12\" , \"0.0.8.245.0.12\" ) ;\n oid_add_from_string ( \"h245 version 13\" , \"0.0.8.245.0.13\" ) ;\n oid_add_from_string ( \"ISO/IEC 14496-2 MPEG-4 video\" , \"0.0.8.245.1.0.0\" ) ;\n oid_add_from_string ( \"ISO/IEC 14496-3 MPEG-4 audio\" , \"0.0.8.245.1.1.0\" ) ;\n oid_add_from_string ( \"AMR\" , \"0.0.8.245.1.1.1\" ) ;\n oid_add_from_string ( \"acelp\" , \"0.0.8.245.1.1.2\" ) ;\n oid_add_from_string ( \"us1\" , \"0.0.8.245.1.1.3\" ) ;\n oid_add_from_string ( \"is127evrc\" , \"0.0.8.245.1.1.4\" ) ;\n oid_add_from_string ( \"ISO/IEC 13818-7\" , \"0.0.8.245.1.1.5\" ) ;\n oid_add_from_string ( \"rfc3389\" , \"0.0.8.245.1.1.6\" ) ;\n oid_add_from_string ( \"L-16\" , \"0.0.8.245.1.1.7\" ) ;\n oid_add_from_string ( \"bounded-audio-stream\" , \"0.0.8.245.1.1.8\" ) ;\n oid_add_from_string ( \"AMR-NB\" , \"0.0.8.245.1.1.9\" ) ;\n oid_add_from_string ( \"AMR-WB\" , \"0.0.8.245.1.1.10\" ) ;\n oid_add_from_string ( \"ilbc\" , \"0.0.8.245.1.1.11\" ) ;\n oid_add_from_string ( \"ISO/IEC 14496-1\" , \"0.0.8.245.1.2.0\" ) ;\n oid_add_from_string ( \"Nx64\" , \"0.0.8.245.1.2.1\" ) ;\n oid_add_from_string ( \"logical-channel-bit-ratemanagement\" , \"0.0.8.245.1.3.0\" ) ;\n oid_add_from_string ( \"h264 generic-capabilities\" , \"0.0.8.241.0.0.1\" ) ;\n oid_add_from_string ( \"iPpacketization_h241AnnexA(single NAL unit mode)\" , \"0.0.8.241.0.0.0.0\" ) ;\n oid_add_from_string ( \"iPpacketization_RFC3984NonInterleaved\" , \"0.0.8.241.0.0.0.1\" ) ;\n oid_add_from_string ( \"iPpacketization_RFC3984Interleaved\" , \"0.0.8.241.0.0.0.2\" ) ;\n }", "idx": 886}
{"hash": 4025891488552660940, "project": "debian", "size": 172, "label": 0, "functionSource": "static int ulti_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n UltimotionDecodeContext * s = avctx -> priv_data ;\n int modifier = 0 ;\n int uniq = 0 ;\n int mode = 0 ;\n int blocks = 0 ;\n int done = 0 ;\n int x = 0 , y = 0 ;\n int i , ret ;\n int skip ;\n int tmp ;\n if ( ( ret = ff_reget_buffer ( avctx , & s -> frame ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"reget_buffer() failed\\n\" ) ;\n return ret ;\n }\n bytestream2_init ( & s -> gb , buf , buf_size ) ;\n while ( ! done ) {\n int idx ;\n if ( blocks >= s -> blocks || y >= s -> height ) break ;\n if ( bytestream2_get_bytes_left ( & s -> gb ) < 1 ) goto err ;\n idx = bytestream2_get_byteu ( & s -> gb ) ;\n if ( ( idx & 0xF8 ) == 0x70 ) {\n switch ( idx ) {\n case 0x70 : modifier = bytestream2_get_byte ( & s -> gb ) ;\n if ( modifier > 1 ) av_log ( avctx , AV_LOG_INFO , \"warning: modifier must be 0 or 1, got %i\\n\" , modifier ) ;\n break ;\n case 0x71 : uniq = 1 ;\n break ;\n case 0x72 : mode = ! mode ;\n break ;\n case 0x73 : done = 1 ;\n break ;\n case 0x74 : skip = bytestream2_get_byte ( & s -> gb ) ;\n if ( ( blocks + skip ) >= s -> blocks ) break ;\n blocks += skip ;\n x += skip * 8 ;\n while ( x >= s -> width ) {\n x -= s -> width ;\n y += 8 ;\n }\n break ;\n default : av_log ( avctx , AV_LOG_INFO , \"warning: unknown escape 0x%02X\\n\" , idx ) ;\n }\n }\n else {\n int code ;\n int cf ;\n int angle = 0 ;\n uint8_t Y [ 4 ] ;\n int tx = 0 , ty = 0 ;\n int chroma = 0 ;\n if ( mode || uniq ) {\n uniq = 0 ;\n cf = 1 ;\n chroma = 0 ;\n }\n else {\n cf = 0 ;\n if ( idx ) {\n chroma = bytestream2_get_byte ( & s -> gb ) ;\n }\n }\n for ( i = 0 ;\n i < 4 ;\n i ++ ) {\n code = ( idx >> ( 6 - i * 2 ) ) & 3 ;\n if ( ! code ) continue ;\n if ( cf ) {\n chroma = bytestream2_get_byte ( & s -> gb ) ;\n }\n tx = x + block_coords [ i * 2 ] ;\n ty = y + block_coords [ ( i * 2 ) + 1 ] ;\n switch ( code ) {\n case 1 : tmp = bytestream2_get_byte ( & s -> gb ) ;\n angle = angle_by_index [ ( tmp >> 6 ) & 0x3 ] ;\n Y [ 0 ] = tmp & 0x3F ;\n Y [ 1 ] = Y [ 0 ] ;\n if ( angle ) {\n Y [ 2 ] = Y [ 0 ] + 1 ;\n if ( Y [ 2 ] > 0x3F ) Y [ 2 ] = 0x3F ;\n Y [ 3 ] = Y [ 2 ] ;\n }\n else {\n Y [ 2 ] = Y [ 0 ] ;\n Y [ 3 ] = Y [ 0 ] ;\n }\n break ;\n case 2 : if ( modifier ) {\n tmp = bytestream2_get_be24 ( & s -> gb ) ;\n Y [ 0 ] = ( tmp >> 18 ) & 0x3F ;\n Y [ 1 ] = ( tmp >> 12 ) & 0x3F ;\n Y [ 2 ] = ( tmp >> 6 ) & 0x3F ;\n Y [ 3 ] = tmp & 0x3F ;\n angle = 16 ;\n }\n else {\n tmp = bytestream2_get_be16 ( & s -> gb ) ;\n angle = ( tmp >> 12 ) & 0xF ;\n tmp &= 0xFFF ;\n tmp <<= 2 ;\n Y [ 0 ] = s -> ulti_codebook [ tmp ] ;\n Y [ 1 ] = s -> ulti_codebook [ tmp + 1 ] ;\n Y [ 2 ] = s -> ulti_codebook [ tmp + 2 ] ;\n Y [ 3 ] = s -> ulti_codebook [ tmp + 3 ] ;\n }\n break ;\n case 3 : if ( modifier ) {\n uint8_t Luma [ 16 ] ;\n if ( bytestream2_get_bytes_left ( & s -> gb ) < 12 ) goto err ;\n tmp = bytestream2_get_be24u ( & s -> gb ) ;\n Luma [ 0 ] = ( tmp >> 18 ) & 0x3F ;\n Luma [ 1 ] = ( tmp >> 12 ) & 0x3F ;\n Luma [ 2 ] = ( tmp >> 6 ) & 0x3F ;\n Luma [ 3 ] = tmp & 0x3F ;\n tmp = bytestream2_get_be24u ( & s -> gb ) ;\n Luma [ 4 ] = ( tmp >> 18 ) & 0x3F ;\n Luma [ 5 ] = ( tmp >> 12 ) & 0x3F ;\n Luma [ 6 ] = ( tmp >> 6 ) & 0x3F ;\n Luma [ 7 ] = tmp & 0x3F ;\n tmp = bytestream2_get_be24u ( & s -> gb ) ;\n Luma [ 8 ] = ( tmp >> 18 ) & 0x3F ;\n Luma [ 9 ] = ( tmp >> 12 ) & 0x3F ;\n Luma [ 10 ] = ( tmp >> 6 ) & 0x3F ;\n Luma [ 11 ] = tmp & 0x3F ;\n tmp = bytestream2_get_be24u ( & s -> gb ) ;\n Luma [ 12 ] = ( tmp >> 18 ) & 0x3F ;\n Luma [ 13 ] = ( tmp >> 12 ) & 0x3F ;\n Luma [ 14 ] = ( tmp >> 6 ) & 0x3F ;\n Luma [ 15 ] = tmp & 0x3F ;\n ulti_convert_yuv ( & s -> frame , tx , ty , Luma , chroma ) ;\n }\n else {\n if ( bytestream2_get_bytes_left ( & s -> gb ) < 4 ) goto err ;\n tmp = bytestream2_get_byteu ( & s -> gb ) ;\n if ( tmp & 0x80 ) {\n angle = ( tmp >> 4 ) & 0x7 ;\n tmp = ( tmp << 8 ) + bytestream2_get_byteu ( & s -> gb ) ;\n Y [ 0 ] = ( tmp >> 6 ) & 0x3F ;\n Y [ 1 ] = tmp & 0x3F ;\n Y [ 2 ] = bytestream2_get_byteu ( & s -> gb ) & 0x3F ;\n Y [ 3 ] = bytestream2_get_byteu ( & s -> gb ) & 0x3F ;\n ulti_grad ( & s -> frame , tx , ty , Y , chroma , angle ) ;\n }\n else {\n int f0 , f1 ;\n f0 = bytestream2_get_byteu ( & s -> gb ) ;\n f1 = tmp ;\n Y [ 0 ] = bytestream2_get_byteu ( & s -> gb ) & 0x3F ;\n Y [ 1 ] = bytestream2_get_byteu ( & s -> gb ) & 0x3F ;\n ulti_pattern ( & s -> frame , tx , ty , f1 , f0 , Y [ 0 ] , Y [ 1 ] , chroma ) ;\n }\n }\n break ;\n }\n if ( code != 3 ) ulti_grad ( & s -> frame , tx , ty , Y , chroma , angle ) ;\n }\n blocks ++ ;\n x += 8 ;\n if ( x >= s -> width ) {\n x = 0 ;\n y += 8 ;\n }\n }\n }\n * got_frame = 1 ;\n if ( ( ret = av_frame_ref ( data , & s -> frame ) ) < 0 ) return ret ;\n return buf_size ;\n err : av_log ( avctx , AV_LOG_ERROR , \"Insufficient data\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }", "idx": 887}
{"hash": -2222463888415249941, "project": "chrome", "size": 19, "label": 0, "functionSource": "static void loopfilter_frame ( VP9_COMP * cpi , VP9_COMMON * cm ) {\n MACROBLOCKD * xd = & cpi -> mb . e_mbd ;\n struct loopfilter * lf = & cm -> lf ;\n if ( xd -> lossless ) {\n lf -> filter_level = 0 ;\n }\n else {\n struct vpx_usec_timer timer ;\n vp9_clear_system_state ( ) ;\n vpx_usec_timer_start ( & timer ) ;\n vp9_pick_filter_level ( cpi -> Source , cpi , cpi -> sf . lpf_pick ) ;\n vpx_usec_timer_mark ( & timer ) ;\n cpi -> time_pick_lpf += vpx_usec_timer_elapsed ( & timer ) ;\n }\n if ( lf -> filter_level > 0 ) {\n vp9_loop_filter_frame ( cm -> frame_to_show , cm , xd , lf -> filter_level , 0 , 0 ) ;\n }\n vp9_extend_frame_inner_borders ( cm -> frame_to_show ) ;\n }", "idx": 888}
{"hash": -4527380754569407959, "project": "chrome", "size": 11, "label": 0, "functionSource": "static hb_ ## name ## _t * _hb_ ## name ## _reference ( const hb_ ## name ## _t * l ) {\n hb_ ## name ## _t * c = ( hb_ ## name ## _t * ) calloc ( 1 , sizeof ( hb_ ## name ## _t ) ) ;\n if ( unlikely ( ! c ) ) return NULL ;\n * c = * l ;\n return c ;\n }\n static void _hb_ ## name ## _destroy ( hb_ ## name ## _t * l ) {\n free ( l ) ;\n }\n HB_DEFINE_BOXED_TYPE ( name , _hb_ ## name ## _reference , _hb_ ## name ## _destroy ) ;\n HB_DEFINE_OBJECT_TYPE ( buffer ) HB_DEFINE_OBJECT_TYPE ( blob ) HB_DEFINE_OBJECT_TYPE ( face ) HB_DEFINE_OBJECT_TYPE ( font ) HB_DEFINE_OBJECT_TYPE ( font_funcs ) HB_DEFINE_OBJECT_TYPE ( set ) HB_DEFINE_OBJECT_TYPE ( shape_plan ) HB_DEFINE_OBJECT_TYPE ( unicode_funcs ) HB_DEFINE_VALUE_TYPE ( feature ) HB_DEFINE_VALUE_TYPE ( glyph_info ) HB_DEFINE_VALUE_TYPE ( glyph_position )", "idx": 889}
{"hash": 6415329349331062723, "project": "chrome", "size": 48, "label": 0, "functionSource": "static void http_connection_test ( int persistent ) {\n short port = - 1 ;\n struct evhttp_connection * evcon = NULL ;\n struct evhttp_request * req = NULL ;\n test_ok = 0 ;\n fprintf ( stdout , \"Testing Request Connection Pipeline %s: \" , persistent ? \"(persistent)\" : \"\" ) ;\n http = http_setup ( & port , NULL ) ;\n evcon = evhttp_connection_new ( \"127.0.0.1\" , port ) ;\n if ( evcon == NULL ) {\n fprintf ( stdout , \"FAILED\\n\" ) ;\n exit ( 1 ) ;\n }\n req = evhttp_request_new ( http_request_done , NULL ) ;\n evhttp_add_header ( req -> output_headers , \"Host\" , \"somehost\" ) ;\n if ( evhttp_make_request ( evcon , req , EVHTTP_REQ_GET , \"/test\" ) == - 1 ) {\n fprintf ( stdout , \"FAILED\\n\" ) ;\n exit ( 1 ) ;\n }\n event_dispatch ( ) ;\n if ( test_ok != 1 ) {\n fprintf ( stdout , \"FAILED\\n\" ) ;\n exit ( 1 ) ;\n }\n test_ok = 0 ;\n req = evhttp_request_new ( http_request_done , NULL ) ;\n evhttp_add_header ( req -> output_headers , \"Host\" , \"somehost\" ) ;\n if ( ! persistent ) evhttp_add_header ( req -> output_headers , \"Connection\" , \"close\" ) ;\n if ( evhttp_make_request ( evcon , req , EVHTTP_REQ_GET , \"/test\" ) == - 1 ) {\n fprintf ( stdout , \"FAILED\\n\" ) ;\n exit ( 1 ) ;\n }\n event_dispatch ( ) ;\n test_ok = 0 ;\n req = evhttp_request_new ( http_request_empty_done , NULL ) ;\n evhttp_add_header ( req -> output_headers , \"Empty\" , \"itis\" ) ;\n if ( evhttp_make_request ( evcon , req , EVHTTP_REQ_GET , \"/test\" ) == - 1 ) {\n fprintf ( stdout , \"FAILED\\n\" ) ;\n exit ( 1 ) ;\n }\n event_dispatch ( ) ;\n if ( test_ok != 1 ) {\n fprintf ( stdout , \"FAILED\\n\" ) ;\n exit ( 1 ) ;\n }\n evhttp_connection_free ( evcon ) ;\n evhttp_free ( http ) ;\n fprintf ( stdout , \"OK\\n\" ) ;\n }", "idx": 890}
{"hash": 3584320764213684062, "project": "debian", "size": 73, "label": 0, "functionSource": "static int parse_CBaseStorageVariant ( tvbuff_t * tvb , packet_info * pinfo , int offset , proto_tree * parent_tree , proto_tree * pad_tree _U_ , struct CBaseStorageVariant * value , const char * text ) {\n int i , len ;\n proto_item * ti , * ti_type , * ti_val ;\n proto_tree * tree , * tr ;\n enum vType highType ;\n ZERO_STRUCT ( * value ) ;\n tree = proto_tree_add_subtree ( parent_tree , tvb , offset , 0 , ett_CBaseStorageVariant , & ti , text ) ;\n value -> vType = tvb_get_letohs ( tvb , offset ) ;\n value -> type = vType_get_type ( value -> vType & 0xFF ) ;\n if ( value -> type == NULL ) {\n ti_type = proto_tree_add_string ( tree , hf_mswsp_cbasestorvariant_vtype , tvb , offset , 2 , \"Unknown CBaseStorageVariant type\" ) ;\n offset += 2 ;\n expert_add_info ( pinfo , ti_type , & ei_mswsp_invalid_variant_type ) ;\n THROW_MESSAGE ( ReportedBoundsError , \"Unknown CBaseStorageVariant type\" ) ;\n return offset ;\n }\n ti_type = proto_tree_add_string ( tree , hf_mswsp_cbasestorvariant_vtype , tvb , offset , 2 , value -> type -> str ) ;\n offset += 2 ;\n value -> vData1 = tvb_get_guint8 ( tvb , offset ) ;\n proto_tree_add_uint ( tree , hf_mswsp_cbasestorvariant_vdata1 , tvb , offset , 1 , value -> vData1 ) ;\n offset += 1 ;\n value -> vData2 = tvb_get_guint8 ( tvb , offset ) ;\n proto_tree_add_uint ( tree , hf_mswsp_cbasestorvariant_vdata2 , tvb , offset , 1 , value -> vData2 ) ;\n offset += 1 ;\n highType = ( enum vType ) ( value -> vType & 0xFF00 ) ;\n ti_val = proto_tree_add_string ( tree , hf_mswsp_cbasestorvariant_vvalue , tvb , offset , 0 , \"\" ) ;\n switch ( highType ) {\n case VT_EMPTY : DISSECTOR_ASSERT_HINT ( value -> type -> tvb_get != 0 , \"type that we don't know yet how to handle, please submit a bug with trace\" ) ;\n len = value -> type -> tvb_get ( tvb , offset , & value -> vValue . vt_single ) ;\n offset += len ;\n break ;\n case VT_VECTOR : proto_item_append_text ( ti_type , \"|VT_VECTOR\" ) ;\n tr = proto_item_add_subtree ( ti_val , ett_CBaseStorageVariant_Vector ) ;\n len = vvalue_tvb_vector ( tvb , offset , & value -> vValue . vt_vector , value -> type ) ;\n proto_tree_add_uint ( tr , hf_mswsp_cbasestorvariant_num , tvb , offset , 4 , value -> vValue . vt_vector . len ) ;\n offset += len ;\n break ;\n case VT_ARRAY : {\n guint16 cDims , fFeatures ;\n guint32 cbElements , cElements , lLbound ;\n int num = 1 ;\n proto_item_append_text ( ti_type , \"|VT_ARRAY\" ) ;\n tr = proto_item_add_subtree ( ti_val , ett_CBaseStorageVariant_Array ) ;\n cDims = tvb_get_letohs ( tvb , offset ) ;\n proto_tree_add_uint ( tr , hf_mswsp_cbasestorvariant_cdims , tvb , offset , 2 , cDims ) ;\n offset += 2 ;\n fFeatures = tvb_get_letohs ( tvb , offset ) ;\n proto_tree_add_uint ( tr , hf_mswsp_cbasestorvariant_ffeatures , tvb , offset , 2 , fFeatures ) ;\n offset += 2 ;\n cbElements = tvb_get_letohl ( tvb , offset ) ;\n proto_tree_add_uint ( tr , hf_mswsp_cbasestorvariant_cbelements , tvb , offset , 4 , cbElements ) ;\n offset += 4 ;\n for ( i = 0 ;\n i < cDims ;\n i ++ ) {\n cElements = tvb_get_letohl ( tvb , offset ) ;\n lLbound = tvb_get_letohl ( tvb , offset + 4 ) ;\n proto_tree_add_string_format ( tr , hf_mswsp_cbasestorvariant_rgsabound , tvb , offset , 8 , \"\" , \"Rgsabound[%d]: (%d:%d)\" , i , cElements , lLbound ) ;\n offset += 8 ;\n num *= cElements ;\n }\n len = vvalue_tvb_vector_internal ( tvb , offset , & value -> vValue . vt_array . vData , value -> type , num ) ;\n offset += len ;\n break ;\n }\n default : proto_item_append_text ( ti_type , \"|0x%x\" , highType ) ;\n }\n proto_item_set_end ( ti , tvb , offset ) ;\n proto_item_set_end ( ti_val , tvb , offset ) ;\n proto_item_append_text ( ti_val , \" %s\" , str_CBaseStorageVariant ( value , FALSE ) ) ;\n proto_item_append_text ( ti , \" %s\" , str_CBaseStorageVariant ( value , TRUE ) ) ;\n return offset ;\n }", "idx": 891}
{"hash": 5825340398912191389, "project": "debian", "size": 14, "label": 0, "functionSource": "extern int name ( int ) __THROW __exctype ( isalnum ) ;\n __exctype ( isalpha ) ;\n __exctype ( iscntrl ) ;\n __exctype ( isdigit ) ;\n __exctype ( islower ) ;\n __exctype ( isgraph ) ;\n __exctype ( isprint ) ;\n __exctype ( ispunct ) ;\n __exctype ( isspace ) ;\n __exctype ( isupper ) ;\n __exctype ( isxdigit ) ;\n extern int tolower ( int __c ) __THROW ;\n extern int toupper ( int __c ) __THROW ;\n # ifdef __USE_ISOC99 __exctype ( isblank )", "idx": 892}
{"hash": 3584320764213684062, "project": "debian", "size": 14, "label": 0, "functionSource": "static int vvalue_tvb_lpwstr_len ( tvbuff_t * tvb , int offset , int length , void * val ) {\n struct data_str * str = ( struct data_str * ) val ;\n const gchar * ptr ;\n int len ;\n if ( length == 0 ) {\n ptr = tvb_get_stringz_enc ( wmem_packet_scope ( ) , tvb , offset , & len , ENC_UTF_16 | ENC_LITTLE_ENDIAN ) ;\n }\n else {\n ptr = tvb_get_string_enc ( wmem_packet_scope ( ) , tvb , offset , length , ENC_UTF_16 | ENC_LITTLE_ENDIAN ) ;\n len = length ;\n }\n str -> str = ptr ;\n return len ;\n }", "idx": 893}
{"hash": 7191899184788440065, "project": "debian", "size": 5, "label": 0, "functionSource": "static int com_nowarnings ( String * buffer __attribute__ ( ( unused ) ) , char * line __attribute__ ( ( unused ) ) ) {\n show_warnings = 0 ;\n put_info ( \"Show warnings disabled.\" , INFO_INFO ) ;\n return 0 ;\n }", "idx": 894}
{"hash": -303065274055369342, "project": "debian", "size": 22, "label": 1, "functionSource": "END_TEST START_TEST ( test_find_available_user ) {\n in_addr_t ip ;\n int i ;\n ip = inet_addr ( \"127.0.0.1\" ) ;\n init_users ( ip , 27 ) ;\n for ( i = 0 ;\n i < USERS ;\n i ++ ) {\n fail_unless ( find_available_user ( ) == i ) ;\n }\n for ( i = 0 ;\n i < USERS ;\n i ++ ) {\n fail_unless ( find_available_user ( ) == - 1 ) ;\n }\n users [ 3 ] . active = 0 ;\n fail_unless ( find_available_user ( ) == 3 ) ;\n fail_unless ( find_available_user ( ) == - 1 ) ;\n users [ 3 ] . last_pkt = 55 ;\n fail_unless ( find_available_user ( ) == 3 ) ;\n fail_unless ( find_available_user ( ) == - 1 ) ;\n }", "idx": 895}
{"hash": 2895622461494525400, "project": "debian", "size": 51, "label": 0, "functionSource": "static void test_func_fields ( ) {\n int rc ;\n MYSQL_RES * result ;\n MYSQL_FIELD * field ;\n myheader ( \"test_func_fields\" ) ;\n rc = mysql_autocommit ( mysql , TRUE ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"DROP TABLE IF EXISTS test_dateformat\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"CREATE TABLE test_dateformat(id int, \\ ts timestamp)\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"INSERT INTO test_dateformat(id) values(10)\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"SELECT ts FROM test_dateformat\" ) ;\n myquery ( rc ) ;\n result = mysql_store_result ( mysql ) ;\n mytest ( result ) ;\n field = mysql_fetch_field ( result ) ;\n mytest ( field ) ;\n if ( ! opt_silent ) fprintf ( stdout , \"\\n table name: `%s` (expected: `%s`)\" , field -> table , \"test_dateformat\" ) ;\n DIE_UNLESS ( strcmp ( field -> table , \"test_dateformat\" ) == 0 ) ;\n field = mysql_fetch_field ( result ) ;\n mytest_r ( field ) ;\n mysql_free_result ( result ) ;\n rc = mysql_query ( mysql , \"SELECT DATE_FORMAT(ts, '%Y') AS 'venu' FROM test_dateformat\" ) ;\n myquery ( rc ) ;\n result = mysql_store_result ( mysql ) ;\n mytest ( result ) ;\n field = mysql_fetch_field ( result ) ;\n mytest ( field ) ;\n if ( ! opt_silent ) fprintf ( stdout , \"\\n table name: `%s` (expected: `%s`)\" , field -> table , \"\" ) ;\n DIE_UNLESS ( field -> table [ 0 ] == '\\0' ) ;\n field = mysql_fetch_field ( result ) ;\n mytest_r ( field ) ;\n mysql_free_result ( result ) ;\n rc = mysql_query ( mysql , \"SELECT DATE_FORMAT(ts, '%Y') AS 'YEAR' FROM test_dateformat\" ) ;\n myquery ( rc ) ;\n result = mysql_store_result ( mysql ) ;\n mytest ( result ) ;\n field = mysql_fetch_field ( result ) ;\n mytest ( field ) ;\n if ( ! opt_silent ) {\n printf ( \"\\n field name: `%s` (expected: `%s`)\" , field -> name , \"YEAR\" ) ;\n printf ( \"\\n field org name: `%s` (expected: `%s`)\" , field -> org_name , \"\" ) ;\n }\n DIE_UNLESS ( strcmp ( field -> name , \"YEAR\" ) == 0 ) ;\n DIE_UNLESS ( field -> org_name [ 0 ] == '\\0' ) ;\n field = mysql_fetch_field ( result ) ;\n mytest_r ( field ) ;\n mysql_free_result ( result ) ;\n }", "idx": 896}
{"hash": 9176142195250515812, "project": "debian", "size": 4, "label": 0, "functionSource": "static void purple_add_permit ( struct im_connection * ic , char * who ) {\n struct purple_data * pd = ic -> proto_data ;\n purple_privacy_permit_add ( pd -> account , who , FALSE ) ;\n }", "idx": 897}
{"hash": -7888349587538303571, "project": "debian", "size": 47, "label": 0, "functionSource": "static int rawv6_recvmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) {\n struct ipv6_pinfo * np = inet6_sk ( sk ) ;\n struct sockaddr_in6 * sin6 = ( struct sockaddr_in6 * ) msg -> msg_name ;\n struct sk_buff * skb ;\n size_t copied ;\n int err ;\n if ( flags & MSG_OOB ) return - EOPNOTSUPP ;\n if ( addr_len ) * addr_len = sizeof ( * sin6 ) ;\n if ( flags & MSG_ERRQUEUE ) return ipv6_recv_error ( sk , msg , len ) ;\n if ( np -> rxpmtu && np -> rxopt . bits . rxpmtu ) return ipv6_recv_rxpmtu ( sk , msg , len ) ;\n skb = skb_recv_datagram ( sk , flags , noblock , & err ) ;\n if ( ! skb ) goto out ;\n copied = skb -> len ;\n if ( copied > len ) {\n copied = len ;\n msg -> msg_flags |= MSG_TRUNC ;\n }\n if ( skb_csum_unnecessary ( skb ) ) {\n err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ;\n }\n else if ( msg -> msg_flags & MSG_TRUNC ) {\n if ( __skb_checksum_complete ( skb ) ) goto csum_copy_err ;\n err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ;\n }\n else {\n err = skb_copy_and_csum_datagram_iovec ( skb , 0 , msg -> msg_iov ) ;\n if ( err == - EINVAL ) goto csum_copy_err ;\n }\n if ( err ) goto out_free ;\n if ( sin6 ) {\n sin6 -> sin6_family = AF_INET6 ;\n sin6 -> sin6_port = 0 ;\n ipv6_addr_copy ( & sin6 -> sin6_addr , & ipv6_hdr ( skb ) -> saddr ) ;\n sin6 -> sin6_flowinfo = 0 ;\n sin6 -> sin6_scope_id = 0 ;\n if ( ipv6_addr_type ( & sin6 -> sin6_addr ) & IPV6_ADDR_LINKLOCAL ) sin6 -> sin6_scope_id = IP6CB ( skb ) -> iif ;\n }\n sock_recv_ts_and_drops ( msg , sk , skb ) ;\n if ( np -> rxopt . all ) datagram_recv_ctl ( sk , msg , skb ) ;\n err = copied ;\n if ( flags & MSG_TRUNC ) err = skb -> len ;\n out_free : skb_free_datagram ( sk , skb ) ;\n out : return err ;\n csum_copy_err : skb_kill_datagram ( sk , skb , flags ) ;\n err = ( flags & MSG_DONTWAIT ) ? - EAGAIN : - EHOSTUNREACH ;\n goto out ;\n }", "idx": 898}
{"hash": -2654475221056024278, "project": "debian", "size": 32, "label": 0, "functionSource": "void mark_edges_uninteresting ( struct rev_info * revs , show_edge_fn show_edge ) {\n struct commit_list * list ;\n int i ;\n for ( list = revs -> commits ;\n list ;\n list = list -> next ) {\n struct commit * commit = list -> item ;\n if ( commit -> object . flags & UNINTERESTING ) {\n mark_tree_uninteresting ( commit -> tree ) ;\n if ( revs -> edge_hint_aggressive && ! ( commit -> object . flags & SHOWN ) ) {\n commit -> object . flags |= SHOWN ;\n show_edge ( commit ) ;\n }\n continue ;\n }\n mark_edge_parents_uninteresting ( commit , revs , show_edge ) ;\n }\n if ( revs -> edge_hint_aggressive ) {\n for ( i = 0 ;\n i < revs -> cmdline . nr ;\n i ++ ) {\n struct object * obj = revs -> cmdline . rev [ i ] . item ;\n struct commit * commit = ( struct commit * ) obj ;\n if ( obj -> type != OBJ_COMMIT || ! ( obj -> flags & UNINTERESTING ) ) continue ;\n mark_tree_uninteresting ( commit -> tree ) ;\n if ( ! ( obj -> flags & SHOWN ) ) {\n obj -> flags |= SHOWN ;\n show_edge ( commit ) ;\n }\n }\n }\n }", "idx": 899}
{"hash": 2578089348587614328, "project": "debian", "size": 3, "label": 0, "functionSource": "int X509_REQ_sign_ctx ( X509_REQ * x , EVP_MD_CTX * ctx ) {\n return ASN1_item_sign_ctx ( ASN1_ITEM_rptr ( X509_REQ_INFO ) , x -> sig_alg , NULL , x -> signature , x -> req_info , ctx ) ;\n }", "idx": 900}
{"hash": -2928324134072492299, "project": "debian", "size": 12, "label": 0, "functionSource": "void q931_calls_init_tap ( void ) {\n GString * error_string ;\n if ( have_q931_tap_listener == FALSE ) {\n error_string = register_tap_listener ( \"q931\" , & ( the_tapinfo_struct . q931_dummy ) , NULL , 0 , voip_calls_dlg_reset , q931_calls_packet , voip_calls_dlg_draw ) ;\n if ( error_string != NULL ) {\n simple_dialog ( ESD_TYPE_ERROR , ESD_BTN_OK , \"%s\" , error_string -> str ) ;\n g_string_free ( error_string , TRUE ) ;\n exit ( 1 ) ;\n }\n have_q931_tap_listener = TRUE ;\n }\n }", "idx": 901}
{"hash": -6704066512670389306, "project": "debian", "size": 10, "label": 0, "functionSource": "static void usage ( void ) {\n const char * p ;\n p = lafe_getprogname ( ) ;\n fprintf ( stderr , \"Brief Usage:\\n\" ) ;\n fprintf ( stderr , \" List: %s -it < archive\\n\" , p ) ;\n fprintf ( stderr , \" Extract: %s -i < archive\\n\" , p ) ;\n fprintf ( stderr , \" Create: %s -o < filenames > archive\\n\" , p ) ;\n fprintf ( stderr , \" Help: %s --help\\n\" , p ) ;\n exit ( 1 ) ;\n }", "idx": 902}
{"hash": -6024601983167898950, "project": "debian", "size": 28, "label": 0, "functionSource": "static void pk_proxy_appeared_cb ( GObject * source , GAsyncResult * res , gpointer user_data ) {\n ActivateParametersInstall * parameters_install = user_data ;\n char * mime_type , * name_owner ;\n char * error_message ;\n GtkWidget * dialog ;\n GDBusProxy * proxy ;\n GError * error = NULL ;\n proxy = g_dbus_proxy_new_for_bus_finish ( res , & error ) ;\n name_owner = g_dbus_proxy_get_name_owner ( proxy ) ;\n if ( error != NULL || name_owner == NULL ) {\n g_warning ( \"Couldn't call Modify on the PackageKit interface: %s\" , error != NULL ? error -> message : \"no owner for PackageKit\" ) ;\n g_clear_error ( & error ) ;\n show_unhandled_type_error ( parameters_install ) ;\n return ;\n }\n g_free ( name_owner ) ;\n mime_type = nautilus_file_get_mime_type ( parameters_install -> file ) ;\n error_message = get_application_no_mime_type_handler_message ( parameters_install -> file , parameters_install -> uri ) ;\n dialog = gtk_message_dialog_new ( parameters_install -> parent_window , 0 , GTK_MESSAGE_ERROR , GTK_BUTTONS_YES_NO , \"%s\" , error_message ) ;\n gtk_message_dialog_format_secondary_text ( GTK_MESSAGE_DIALOG ( dialog ) , _ ( \"There is no application installed for \u201c%s\u201d files.\\n\" \"Do you want to search for an application to open this file?\" ) , g_content_type_get_description ( mime_type ) ) ;\n gtk_window_set_resizable ( GTK_WINDOW ( dialog ) , FALSE ) ;\n parameters_install -> dialog = dialog ;\n parameters_install -> proxy = proxy ;\n g_signal_connect ( dialog , \"response\" , G_CALLBACK ( application_unhandled_file_install ) , parameters_install ) ;\n g_signal_connect ( dialog , \"delete-event\" , G_CALLBACK ( delete_cb ) , NULL ) ;\n gtk_widget_show_all ( dialog ) ;\n g_free ( mime_type ) ;\n }", "idx": 903}
{"hash": 2772622454795674000, "project": "debian", "size": 14, "label": 0, "functionSource": "const uint8_t * ff_h263_find_resync_marker ( const uint8_t * restrict p , const uint8_t * restrict end ) {\n assert ( p < end ) ;\n end -= 2 ;\n p ++ ;\n for ( ;\n p < end ;\n p += 2 ) {\n if ( ! * p ) {\n if ( ! p [ - 1 ] && p [ 1 ] ) return p - 1 ;\n else if ( ! p [ 1 ] && p [ 2 ] ) return p ;\n }\n }\n return end + 2 ;\n }", "idx": 904}
{"hash": -305162769887579921, "project": "debian", "size": 133, "label": 0, "functionSource": "static int select_input_picture ( MpegEncContext * s ) {\n int i , ret ;\n for ( i = 1 ;\n i < MAX_PICTURE_COUNT ;\n i ++ ) s -> reordered_input_picture [ i - 1 ] = s -> reordered_input_picture [ i ] ;\n s -> reordered_input_picture [ MAX_PICTURE_COUNT - 1 ] = NULL ;\n if ( s -> reordered_input_picture [ 0 ] == NULL && s -> input_picture [ 0 ] ) {\n if ( s -> next_picture_ptr == NULL || s -> intra_only ) {\n s -> reordered_input_picture [ 0 ] = s -> input_picture [ 0 ] ;\n s -> reordered_input_picture [ 0 ] -> f . pict_type = AV_PICTURE_TYPE_I ;\n s -> reordered_input_picture [ 0 ] -> f . coded_picture_number = s -> coded_picture_number ++ ;\n }\n else {\n int b_frames ;\n if ( s -> avctx -> frame_skip_threshold || s -> avctx -> frame_skip_factor ) {\n if ( s -> picture_in_gop_number < s -> gop_size && skip_check ( s , s -> input_picture [ 0 ] , s -> next_picture_ptr ) ) {\n av_frame_unref ( & s -> input_picture [ 0 ] -> f ) ;\n emms_c ( ) ;\n ff_vbv_update ( s , 0 ) ;\n goto no_output_pic ;\n }\n }\n if ( s -> flags & CODEC_FLAG_PASS2 ) {\n for ( i = 0 ;\n i < s -> max_b_frames + 1 ;\n i ++ ) {\n int pict_num = s -> input_picture [ 0 ] -> f . display_picture_number + i ;\n if ( pict_num >= s -> rc_context . num_entries ) break ;\n if ( ! s -> input_picture [ i ] ) {\n s -> rc_context . entry [ pict_num - 1 ] . new_pict_type = AV_PICTURE_TYPE_P ;\n break ;\n }\n s -> input_picture [ i ] -> f . pict_type = s -> rc_context . entry [ pict_num ] . new_pict_type ;\n }\n }\n if ( s -> avctx -> b_frame_strategy == 0 ) {\n b_frames = s -> max_b_frames ;\n while ( b_frames && ! s -> input_picture [ b_frames ] ) b_frames -- ;\n }\n else if ( s -> avctx -> b_frame_strategy == 1 ) {\n for ( i = 1 ;\n i < s -> max_b_frames + 1 ;\n i ++ ) {\n if ( s -> input_picture [ i ] && s -> input_picture [ i ] -> b_frame_score == 0 ) {\n s -> input_picture [ i ] -> b_frame_score = get_intra_count ( s , s -> input_picture [ i ] -> f . data [ 0 ] , s -> input_picture [ i - 1 ] -> f . data [ 0 ] , s -> linesize ) + 1 ;\n }\n }\n for ( i = 0 ;\n i < s -> max_b_frames + 1 ;\n i ++ ) {\n if ( s -> input_picture [ i ] == NULL || s -> input_picture [ i ] -> b_frame_score - 1 > s -> mb_num / s -> avctx -> b_sensitivity ) break ;\n }\n b_frames = FFMAX ( 0 , i - 1 ) ;\n for ( i = 0 ;\n i < b_frames + 1 ;\n i ++ ) {\n s -> input_picture [ i ] -> b_frame_score = 0 ;\n }\n }\n else if ( s -> avctx -> b_frame_strategy == 2 ) {\n b_frames = estimate_best_b_count ( s ) ;\n }\n else {\n av_log ( s -> avctx , AV_LOG_ERROR , \"illegal b frame strategy\\n\" ) ;\n b_frames = 0 ;\n }\n emms_c ( ) ;\n for ( i = b_frames - 1 ;\n i >= 0 ;\n i -- ) {\n int type = s -> input_picture [ i ] -> f . pict_type ;\n if ( type && type != AV_PICTURE_TYPE_B ) b_frames = i ;\n }\n if ( s -> input_picture [ b_frames ] -> f . pict_type == AV_PICTURE_TYPE_B && b_frames == s -> max_b_frames ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"warning, too many b frames in a row\\n\" ) ;\n }\n if ( s -> picture_in_gop_number + b_frames >= s -> gop_size ) {\n if ( ( s -> mpv_flags & FF_MPV_FLAG_STRICT_GOP ) && s -> gop_size > s -> picture_in_gop_number ) {\n b_frames = s -> gop_size - s -> picture_in_gop_number - 1 ;\n }\n else {\n if ( s -> flags & CODEC_FLAG_CLOSED_GOP ) b_frames = 0 ;\n s -> input_picture [ b_frames ] -> f . pict_type = AV_PICTURE_TYPE_I ;\n }\n }\n if ( ( s -> flags & CODEC_FLAG_CLOSED_GOP ) && b_frames && s -> input_picture [ b_frames ] -> f . pict_type == AV_PICTURE_TYPE_I ) b_frames -- ;\n s -> reordered_input_picture [ 0 ] = s -> input_picture [ b_frames ] ;\n if ( s -> reordered_input_picture [ 0 ] -> f . pict_type != AV_PICTURE_TYPE_I ) s -> reordered_input_picture [ 0 ] -> f . pict_type = AV_PICTURE_TYPE_P ;\n s -> reordered_input_picture [ 0 ] -> f . coded_picture_number = s -> coded_picture_number ++ ;\n for ( i = 0 ;\n i < b_frames ;\n i ++ ) {\n s -> reordered_input_picture [ i + 1 ] = s -> input_picture [ i ] ;\n s -> reordered_input_picture [ i + 1 ] -> f . pict_type = AV_PICTURE_TYPE_B ;\n s -> reordered_input_picture [ i + 1 ] -> f . coded_picture_number = s -> coded_picture_number ++ ;\n }\n }\n }\n no_output_pic : if ( s -> reordered_input_picture [ 0 ] ) {\n s -> reordered_input_picture [ 0 ] -> reference = s -> reordered_input_picture [ 0 ] -> f . pict_type != AV_PICTURE_TYPE_B ? 3 : 0 ;\n ff_mpeg_unref_picture ( s , & s -> new_picture ) ;\n if ( ( ret = ff_mpeg_ref_picture ( s , & s -> new_picture , s -> reordered_input_picture [ 0 ] ) ) ) return ret ;\n if ( s -> reordered_input_picture [ 0 ] -> shared || s -> avctx -> rc_buffer_size ) {\n Picture * pic ;\n int i = ff_find_unused_picture ( s , 0 ) ;\n if ( i < 0 ) return i ;\n pic = & s -> picture [ i ] ;\n pic -> reference = s -> reordered_input_picture [ 0 ] -> reference ;\n if ( ff_alloc_picture ( s , pic , 0 ) < 0 ) {\n return - 1 ;\n }\n copy_picture_attributes ( s , & pic -> f , & s -> reordered_input_picture [ 0 ] -> f ) ;\n av_frame_unref ( & s -> reordered_input_picture [ 0 ] -> f ) ;\n s -> reordered_input_picture [ 0 ] -> shared = 0 ;\n s -> current_picture_ptr = pic ;\n }\n else {\n s -> current_picture_ptr = s -> reordered_input_picture [ 0 ] ;\n for ( i = 0 ;\n i < 4 ;\n i ++ ) {\n s -> new_picture . f . data [ i ] += INPLACE_OFFSET ;\n }\n }\n ff_mpeg_unref_picture ( s , & s -> current_picture ) ;\n if ( ( ret = ff_mpeg_ref_picture ( s , & s -> current_picture , s -> current_picture_ptr ) ) < 0 ) return ret ;\n s -> picture_number = s -> new_picture . f . display_picture_number ;\n }\n else {\n ff_mpeg_unref_picture ( s , & s -> new_picture ) ;\n }\n return 0 ;\n }", "idx": 905}
{"hash": -1315695702746584250, "project": "debian", "size": 11, "label": 0, "functionSource": "proto_item * proto_tree_add_int_format_value ( proto_tree * tree , int hfindex , tvbuff_t * tvb , gint start , gint length , gint32 value , const char * format , ... ) {\n proto_item * pi ;\n va_list ap ;\n pi = proto_tree_add_int ( tree , hfindex , tvb , start , length , value ) ;\n if ( pi != tree ) {\n va_start ( ap , format ) ;\n proto_tree_set_representation_value ( pi , format , ap ) ;\n va_end ( ap ) ;\n }\n return pi ;\n }", "idx": 906}
{"hash": -2443338381883395438, "project": "debian", "size": 17, "label": 0, "functionSource": "void init_logging ( const char * name , u_int32 def_syslogmask , int is_daemon ) {\n static int was_daemon ;\n char * cp ;\n const char * pname ;\n if ( INIT_NTP_SYSLOGMASK == ntp_syslogmask && != def_syslogmask ) ntp_syslogmask = def_syslogmask ;\n cp = strrchr ( name , DIR_SEP ) ;\n if ( NULL == cp ) pname = name ;\n else pname = 1 + cp ;\n progname = estrdup ( pname ) ;\n # ifdef SYS_WINNT cp = strrchr ( progname , '.' ) ;\n if ( NULL != cp && ! strcasecmp ( cp , \".exe\" ) ) * cp = '\\0' ;\n # endif # if ! defined ( VMS ) if ( is_daemon ) was_daemon = TRUE ;\n # ifndef LOG_DAEMON openlog ( progname , LOG_PID ) ;\n # else # ifndef LOG_NTP # define LOG_NTP LOG_DAEMON # endif openlog ( progname , LOG_PID | LOG_NDELAY , ( was_daemon ) ? LOG_NTP : 0 ) ;\n # ifdef DEBUG if ( debug ) setlogmask ( LOG_UPTO ( LOG_DEBUG ) ) ;\n else # endif setlogmask ( LOG_UPTO ( LOG_DEBUG ) ) ;\n # endif # endif }", "idx": 907}
{"hash": 6458694302493204858, "project": "debian", "size": 6, "label": 0, "functionSource": "static Datum ExecEvalConst ( ExprState * exprstate , ExprContext * econtext , bool * isNull , ExprDoneCond * isDone ) {\n Const * con = ( Const * ) exprstate -> expr ;\n if ( isDone ) * isDone = ExprSingleResult ;\n * isNull = con -> constisnull ;\n return con -> constvalue ;\n }", "idx": 908}
{"hash": 3584320764213684062, "project": "debian", "size": 21, "label": 0, "functionSource": "static int parse_CRowSeekByBookmark ( tvbuff_t * tvb , int offset , proto_tree * parent_tree , const char * fmt , ... ) {\n proto_tree * tree ;\n proto_item * item ;\n guint32 num ;\n const char * txt ;\n va_list ap ;\n va_start ( ap , fmt ) ;\n txt = wmem_strdup_vprintf ( wmem_packet_scope ( ) , fmt , ap ) ;\n va_end ( ap ) ;\n tree = proto_tree_add_subtree ( parent_tree , tvb , offset , 0 , ett_CRowsSeekByBookmark , & item , txt ) ;\n num = tvb_get_letohl ( tvb , offset ) ;\n proto_tree_add_item ( tree , hf_mswsp_crowseekbybookmark_cbookmarks , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n offset = parse_UInt32Array ( tvb , offset , tree , num , \"abookmark\" , \"abookmarks\" ) ;\n num = tvb_get_letohl ( tvb , offset ) ;\n proto_tree_add_item ( tree , hf_mswsp_crowseekbybookmark_maxret , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n offset = parse_UInt32Array ( tvb , offset , tree , num , \"ascret\" , \"ascret\" ) ;\n proto_item_set_end ( item , tvb , offset ) ;\n return offset ;\n }", "idx": 909}
{"hash": -1315695702746584250, "project": "debian", "size": 12, "label": 0, "functionSource": "proto_item * proto_tree_add_guid_format ( proto_tree * tree , int hfindex , tvbuff_t * tvb , gint start , gint length , const e_guid_t * value_ptr , const char * format , ... ) {\n proto_item * pi ;\n va_list ap ;\n pi = proto_tree_add_guid ( tree , hfindex , tvb , start , length , value_ptr ) ;\n if ( pi != tree ) {\n TRY_TO_FAKE_THIS_REPR ( pi ) ;\n va_start ( ap , format ) ;\n proto_tree_set_representation ( pi , format , ap ) ;\n va_end ( ap ) ;\n }\n return pi ;\n }", "idx": 910}
{"hash": 2895622461494525400, "project": "debian", "size": 22, "label": 0, "functionSource": "static void test_bug21206 ( ) {\n const size_t cursor_count = 1025 ;\n const char * create_table [ ] = {\n \"DROP TABLE IF EXISTS t1\" , \"CREATE TABLE t1 (i INT)\" , \"INSERT INTO t1 VALUES (1), (2), (3)\" }\n ;\n const char * query = \"SELECT * FROM t1\" ;\n Stmt_fetch * fetch_array = ( Stmt_fetch * ) calloc ( cursor_count , sizeof ( Stmt_fetch ) ) ;\n Stmt_fetch * fetch ;\n DBUG_ENTER ( \"test_bug21206\" ) ;\n myheader ( \"test_bug21206\" ) ;\n fill_tables ( create_table , sizeof ( create_table ) / sizeof ( * create_table ) ) ;\n for ( fetch = fetch_array ;\n fetch < fetch_array + cursor_count ;\n ++ fetch ) {\n stmt_fetch_init ( fetch , fetch - fetch_array , query ) ;\n }\n for ( fetch = fetch_array ;\n fetch < fetch_array + cursor_count ;\n ++ fetch ) stmt_fetch_close ( fetch ) ;\n free ( fetch_array ) ;\n DBUG_VOID_RETURN ;\n }", "idx": 911}
{"hash": 3576240888172463140, "project": "debian", "size": 9, "label": 0, "functionSource": "gpg_error_t keydb_search_first ( KEYDB_HANDLE hd ) {\n gpg_error_t err ;\n KEYDB_SEARCH_DESC desc ;\n memset ( & desc , 0 , sizeof desc ) ;\n desc . mode = KEYDB_SEARCH_MODE_FIRST ;\n err = keydb_search ( hd , & desc , 1 , NULL ) ;\n if ( gpg_err_code ( err ) == GPG_ERR_LEGACY_KEY ) err = keydb_search_next ( hd ) ;\n return err ;\n }", "idx": 912}
{"hash": -2928324134072492299, "project": "debian", "size": 69, "label": 1, "functionSource": "static int RTP_packet ( void * ptr _U_ , packet_info * pinfo , epan_dissect_t * edt _U_ , void const * RTPinfo ) {\n voip_rtp_tapinfo_t * tapinfo = & the_tapinfo_rtp_struct ;\n voip_rtp_stream_info_t * tmp_listinfo ;\n voip_rtp_stream_info_t * strinfo = NULL ;\n GList * list ;\n struct _rtp_conversation_info * p_conv_data = NULL ;\n const struct _rtp_info * pi = ( const struct _rtp_info * ) RTPinfo ;\n if ( pi -> info_setup_frame_num == 0 ) {\n return 0 ;\n }\n # ifdef HAVE_LIBPORTAUDIO add_rtp_packet ( pi , pinfo ) ;\n # endif list = g_list_first ( tapinfo -> list ) ;\n while ( list ) {\n tmp_listinfo = ( voip_rtp_stream_info_t * ) list -> data ;\n if ( ( tmp_listinfo -> setup_frame_number == pi -> info_setup_frame_num ) && ( tmp_listinfo -> ssrc == pi -> info_sync_src ) && ( tmp_listinfo -> end_stream == FALSE ) ) {\n if ( tmp_listinfo -> pt != pi -> info_payload_type ) {\n tmp_listinfo -> end_stream = TRUE ;\n }\n else {\n strinfo = ( voip_rtp_stream_info_t * ) ( list -> data ) ;\n break ;\n }\n }\n list = g_list_next ( list ) ;\n }\n if ( ( rtp_evt_frame_num == pinfo -> fd -> num ) && ! strinfo && ( rtp_evt_end == TRUE ) ) {\n return 0 ;\n }\n if ( strinfo == NULL ) {\n strinfo = ( voip_rtp_stream_info_t * ) g_malloc ( sizeof ( voip_rtp_stream_info_t ) ) ;\n COPY_ADDRESS ( & ( strinfo -> src_addr ) , & ( pinfo -> src ) ) ;\n strinfo -> src_port = pinfo -> srcport ;\n COPY_ADDRESS ( & ( strinfo -> dest_addr ) , & ( pinfo -> dst ) ) ;\n strinfo -> dest_port = pinfo -> destport ;\n strinfo -> ssrc = pi -> info_sync_src ;\n strinfo -> end_stream = FALSE ;\n strinfo -> pt = pi -> info_payload_type ;\n strinfo -> pt_str = NULL ;\n strinfo -> is_srtp = pi -> info_is_srtp ;\n if ( ( strinfo -> pt >= PT_UNDF_96 ) && ( strinfo -> pt <= PT_UNDF_127 ) ) {\n p_conv_data = ( struct _rtp_conversation_info * ) p_get_proto_data ( wmem_file_scope ( ) , pinfo , proto_get_id_by_filter_name ( \"rtp\" ) , 0 ) ;\n if ( p_conv_data && p_conv_data -> rtp_dyn_payload ) {\n encoding_name_and_rate_t * encoding_name_and_rate_pt = NULL ;\n encoding_name_and_rate_pt = ( encoding_name_and_rate_t * ) g_hash_table_lookup ( p_conv_data -> rtp_dyn_payload , & strinfo -> pt ) ;\n if ( encoding_name_and_rate_pt ) {\n strinfo -> pt_str = g_strdup ( encoding_name_and_rate_pt -> encoding_name ) ;\n }\n }\n }\n if ( ! strinfo -> pt_str ) strinfo -> pt_str = g_strdup ( val_to_str_ext ( strinfo -> pt , & rtp_payload_type_short_vals_ext , \"%u\" ) ) ;\n strinfo -> npackets = 0 ;\n strinfo -> start_fd = pinfo -> fd ;\n strinfo -> start_rel_ts = pinfo -> rel_ts ;\n strinfo -> setup_frame_number = pi -> info_setup_frame_num ;\n strinfo -> rtp_event = - 1 ;\n tapinfo -> list = g_list_prepend ( tapinfo -> list , strinfo ) ;\n }\n strinfo -> npackets ++ ;\n strinfo -> stop_fd = pinfo -> fd ;\n strinfo -> stop_rel_ts = pinfo -> rel_ts ;\n if ( rtp_evt_frame_num == pinfo -> fd -> num ) {\n strinfo -> rtp_event = rtp_evt ;\n if ( rtp_evt_end == TRUE ) {\n strinfo -> end_stream = TRUE ;\n }\n }\n the_tapinfo_struct . redraw = TRUE ;\n return 1 ;\n }", "idx": 913}
{"hash": -6552851419396579257, "project": "debian", "size": 4, "label": 0, "functionSource": "static void spoolss_printserver_specific_rights ( tvbuff_t * tvb , gint offset , proto_tree * tree , guint32 access ) {\n proto_tree_add_boolean ( tree , hf_server_access_enum , tvb , offset , 4 , access ) ;\n proto_tree_add_boolean ( tree , hf_server_access_admin , tvb , offset , 4 , access ) ;\n }", "idx": 914}
{"hash": 6871081691104220210, "project": "debian", "size": 4, "label": 0, "functionSource": "static void fill_picture_entry ( DXVA_PicEntry_H264 * pic , unsigned index , unsigned flag ) {\n assert ( ( index & 0x7f ) == index && ( flag & 0x01 ) == flag ) ;\n pic -> bPicEntry = index | ( flag << 7 ) ;\n }", "idx": 915}
{"hash": 5347874611477979643, "project": "chrome", "size": 13, "label": 0, "functionSource": "static void timeout_cb_swp ( int fd , short event , void * arg ) {\n if ( called == - 1 ) {\n struct timeval tv = {\n 5 , 0 }\n ;\n called = 0 ;\n evtimer_add ( ( struct event * ) arg , & tv ) ;\n raise ( SIGUSR1 ) ;\n return ;\n }\n test_ok = 0 ;\n event_loopexit ( NULL ) ;\n }", "idx": 916}
{"hash": -2958879419462198519, "project": "chrome", "size": 6, "label": 0, "functionSource": "void ufile_flush_io ( UFILE * f ) {\n if ( ( ! f ) || ( ! f -> fFile ) ) {\n return ;\n }\n u_file_write_flush ( NULL , 0 , f , TRUE , FALSE ) ;\n }", "idx": 917}
{"hash": -3133987110086012192, "project": "chrome", "size": 6, "label": 0, "functionSource": "TEST_F ( SoundContentSettingObserverTest , MuteByDefaultRecordsCorrectly ) {\n ChangeDefaultSoundContentSettingTo ( CONTENT_SETTING_BLOCK ) ;\n SimulateAudioStarting ( ) ;\n EXPECT_TRUE ( RecordedSiteMuted ( ) ) ;\n ExpectRecordedForReason ( SoundContentSettingObserver : : MuteReason : : kMuteByDefault ) ;\n }", "idx": 918}
{"hash": 7549435794356072684, "project": "debian", "size": 13, "label": 0, "functionSource": "static VALUE ossl_asn1_traverse ( VALUE self , VALUE obj ) {\n unsigned char * p ;\n VALUE tmp ;\n long len , read = 0 , offset = 0 ;\n obj = ossl_to_der_if_possible ( obj ) ;\n tmp = rb_str_new4 ( StringValue ( obj ) ) ;\n p = ( unsigned char * ) RSTRING_PTR ( tmp ) ;\n len = RSTRING_LEN ( tmp ) ;\n ossl_asn1_decode0 ( & p , len , & offset , 0 , 1 , & read ) ;\n RB_GC_GUARD ( tmp ) ;\n int_ossl_decode_sanity_check ( len , read , offset ) ;\n return Qnil ;\n }", "idx": 919}
{"hash": -8218238246188128086, "project": "debian", "size": 6, "label": 0, "functionSource": "static inline int c6_to_8 ( int v ) {\n int b ;\n v &= 0x3f ;\n b = v & 1 ;\n return ( v << 2 ) | ( b << 1 ) | b ;\n }", "idx": 920}
{"hash": 8572106347813672436, "project": "debian", "size": 5, "label": 0, "functionSource": "static void pfkey_remove ( struct sock * sk ) {\n mutex_lock ( & pfkey_mutex ) ;\n sk_del_node_init_rcu ( sk ) ;\n mutex_unlock ( & pfkey_mutex ) ;\n }", "idx": 921}
{"hash": 6393050609822897742, "project": "debian", "size": 20, "label": 0, "functionSource": "static TRBCCode xhci_enable_ep ( XHCIState * xhci , unsigned int slotid , unsigned int epid , dma_addr_t pctx , uint32_t * ctx ) {\n XHCISlot * slot ;\n XHCIEPContext * epctx ;\n trace_usb_xhci_ep_enable ( slotid , epid ) ;\n assert ( slotid >= 1 && slotid <= xhci -> numslots ) ;\n assert ( epid >= 1 && epid <= 31 ) ;\n slot = & xhci -> slots [ slotid - 1 ] ;\n if ( slot -> eps [ epid - 1 ] ) {\n xhci_disable_ep ( xhci , slotid , epid ) ;\n }\n epctx = xhci_alloc_epctx ( xhci , slotid , epid ) ;\n slot -> eps [ epid - 1 ] = epctx ;\n xhci_init_epctx ( epctx , pctx , ctx ) ;\n DPRINTF ( \"xhci: endpoint %d.%d type is %d, max transaction (burst) \" \"size is %d\\n\" , epid / 2 , epid % 2 , epctx -> type , epctx -> max_psize ) ;\n epctx -> mfindex_last = 0 ;\n epctx -> state = EP_RUNNING ;\n ctx [ 0 ] &= ~ EP_STATE_MASK ;\n ctx [ 0 ] |= EP_RUNNING ;\n return CC_SUCCESS ;\n }", "idx": 922}
{"hash": -2424348134098907053, "project": "debian", "size": 11, "label": 0, "functionSource": "static int set_pid_priority ( pid_t pid , int policy , int priority , char * message , char * name ) {\n struct sched_param par = {\n 0 }\n ;\n par . sched_priority = priority ;\n if ( ( sched_setscheduler ( pid , policy , & par ) != 0 ) ) {\n print_error ( stderr , message , pid , name , strerror ( errno ) ) ;\n return 0 ;\n }\n return 1 ;\n }", "idx": 923}
{"hash": -5992472514718425579, "project": "debian", "size": 14, "label": 0, "functionSource": "static int count_lines ( const char * fn ) {\n FILE * f ;\n char * line = NULL ;\n size_t sz = 0 ;\n int n = 0 ;\n f = fopen_cloexec ( fn , \"r\" ) ;\n if ( ! f ) return - 1 ;\n while ( getline ( & line , & sz , f ) != - 1 ) {\n n ++ ;\n }\n free ( line ) ;\n fclose ( f ) ;\n return n ;\n }", "idx": 924}
{"hash": -1487877838474751244, "project": "debian", "size": 10, "label": 0, "functionSource": "static int16_t findOffset ( const char * const * list , const char * key ) {\n const char * const * anchor = list ;\n while ( * list != NULL ) {\n if ( strcmp ( key , * list ) == 0 ) {\n return ( int16_t ) ( list - anchor ) ;\n }\n list ++ ;\n }\n return - 1 ;\n }", "idx": 925}
{"hash": -2591112946600337077, "project": "debian", "size": 17, "label": 0, "functionSource": "static int autocorr_max ( const int16_t * buf , int offset , int * ccr_max , int pitch_lag , int length , int dir ) {\n int limit , ccr , lag = 0 ;\n int i ;\n pitch_lag = FFMIN ( PITCH_MAX - 3 , pitch_lag ) ;\n if ( dir > 0 ) limit = FFMIN ( FRAME_LEN + PITCH_MAX - offset - length , pitch_lag + 3 ) ;\n else limit = pitch_lag + 3 ;\n for ( i = pitch_lag - 3 ;\n i <= limit ;\n i ++ ) {\n ccr = dot_product ( buf , buf + dir * i , length ) ;\n if ( ccr > * ccr_max ) {\n * ccr_max = ccr ;\n lag = i ;\n }\n }\n return lag ;\n }", "idx": 926}
{"hash": -7455544248455991006, "project": "debian", "size": 7, "label": 0, "functionSource": "int kvm_arch_remove_sw_breakpoint ( CPUState * cs , struct kvm_sw_breakpoint * bp ) {\n uint8_t int3 ;\n if ( cpu_memory_rw_debug ( cs , bp -> pc , & int3 , 1 , 0 ) || int3 != 0xcc || cpu_memory_rw_debug ( cs , bp -> pc , ( uint8_t * ) & bp -> saved_insn , 1 , 1 ) ) {\n return - EINVAL ;\n }\n return 0 ;\n }", "idx": 927}
{"hash": -5861178779585941932, "project": "debian", "size": 11, "label": 0, "functionSource": "void fn_print_char ( netdissect_options * ndo , u_char c ) {\n if ( ! ND_ISASCII ( c ) ) {\n c = ND_TOASCII ( c ) ;\n ND_PRINT ( ( ndo , \"M-\" ) ) ;\n }\n if ( ! ND_ISPRINT ( c ) ) {\n c ^= 0x40 ;\n ND_PRINT ( ( ndo , \"^\" ) ) ;\n }\n ND_PRINT ( ( ndo , \"%c\" , c ) ) ;\n }", "idx": 928}
{"hash": -1487877838474751244, "project": "debian", "size": 3, "label": 0, "functionSource": "PHP_FUNCTION ( locale_get_display_name ) {\n get_icu_disp_value_src_php ( DISP_NAME , INTERNAL_FUNCTION_PARAM_PASSTHRU ) ;\n }", "idx": 929}
{"hash": 4511225370772574632, "project": "debian", "size": 9, "label": 0, "functionSource": "static char * sapi_uwsgi_read_cookies ( TSRMLS_D ) {\n uint16_t len = 0 ;\n struct wsgi_request * wsgi_req = ( struct wsgi_request * ) SG ( server_context ) ;\n char * cookie = uwsgi_get_var ( wsgi_req , ( char * ) \"HTTP_COOKIE\" , 11 , & len ) ;\n if ( cookie ) {\n return estrndup ( cookie , len ) ;\n }\n return NULL ;\n }", "idx": 930}
{"hash": -6435087038712482873, "project": "debian", "size": 176, "label": 1, "functionSource": "static int decode_chunks ( AVCodecContext * avctx , AVFrame * picture , int * got_output , const uint8_t * buf , int buf_size ) {\n Mpeg1Context * s = avctx -> priv_data ;\n MpegEncContext * s2 = & s -> mpeg_enc_ctx ;\n const uint8_t * buf_ptr = buf ;\n const uint8_t * buf_end = buf + buf_size ;\n int ret , input_size ;\n int last_code = 0 ;\n for ( ;\n ;\n ) {\n uint32_t start_code = - 1 ;\n buf_ptr = avpriv_mpv_find_start_code ( buf_ptr , buf_end , & start_code ) ;\n if ( start_code > 0x1ff ) {\n if ( s2 -> pict_type != AV_PICTURE_TYPE_B || avctx -> skip_frame <= AVDISCARD_DEFAULT ) {\n if ( HAVE_THREADS && ( avctx -> active_thread_type & FF_THREAD_SLICE ) ) {\n int i ;\n avctx -> execute ( avctx , slice_decode_thread , & s2 -> thread_context [ 0 ] , NULL , s -> slice_count , sizeof ( void * ) ) ;\n for ( i = 0 ;\n i < s -> slice_count ;\n i ++ ) s2 -> er . error_count += s2 -> thread_context [ i ] -> er . error_count ;\n }\n if ( CONFIG_MPEG_VDPAU_DECODER && avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU ) ff_vdpau_mpeg_picture_complete ( s2 , buf , buf_size , s -> slice_count ) ;\n if ( slice_end ( avctx , picture ) ) {\n if ( s2 -> last_picture_ptr || s2 -> low_delay ) * got_output = 1 ;\n }\n }\n s2 -> pict_type = 0 ;\n return FFMAX ( 0 , buf_ptr - buf - s2 -> parse_context . last_index ) ;\n }\n input_size = buf_end - buf_ptr ;\n if ( avctx -> debug & FF_DEBUG_STARTCODE ) {\n av_log ( avctx , AV_LOG_DEBUG , \"%3X at %td left %d\\n\" , start_code , buf_ptr - buf , input_size ) ;\n }\n switch ( start_code ) {\n case SEQ_START_CODE : if ( last_code == 0 ) {\n mpeg1_decode_sequence ( avctx , buf_ptr , input_size ) ;\n s -> sync = 1 ;\n }\n else {\n av_log ( avctx , AV_LOG_ERROR , \"ignoring SEQ_START_CODE after %X\\n\" , last_code ) ;\n if ( avctx -> err_recognition & AV_EF_EXPLODE ) return AVERROR_INVALIDDATA ;\n }\n break ;\n case PICTURE_START_CODE : if ( HAVE_THREADS && ( avctx -> active_thread_type & FF_THREAD_SLICE ) && s -> slice_count ) {\n int i ;\n avctx -> execute ( avctx , slice_decode_thread , s2 -> thread_context , NULL , s -> slice_count , sizeof ( void * ) ) ;\n for ( i = 0 ;\n i < s -> slice_count ;\n i ++ ) s2 -> er . error_count += s2 -> thread_context [ i ] -> er . error_count ;\n s -> slice_count = 0 ;\n }\n if ( last_code == 0 || last_code == SLICE_MIN_START_CODE ) {\n ret = mpeg_decode_postinit ( avctx ) ;\n if ( ret < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"mpeg_decode_postinit() failure\\n\" ) ;\n return ret ;\n }\n if ( mpeg1_decode_picture ( avctx , buf_ptr , input_size ) < 0 ) s2 -> pict_type = 0 ;\n s2 -> first_slice = 1 ;\n last_code = PICTURE_START_CODE ;\n }\n else {\n av_log ( avctx , AV_LOG_ERROR , \"ignoring pic after %X\\n\" , last_code ) ;\n if ( avctx -> err_recognition & AV_EF_EXPLODE ) return AVERROR_INVALIDDATA ;\n }\n break ;\n case EXT_START_CODE : init_get_bits ( & s2 -> gb , buf_ptr , input_size * 8 ) ;\n switch ( get_bits ( & s2 -> gb , 4 ) ) {\n case 0x1 : if ( last_code == 0 ) {\n mpeg_decode_sequence_extension ( s ) ;\n }\n else {\n av_log ( avctx , AV_LOG_ERROR , \"ignoring seq ext after %X\\n\" , last_code ) ;\n if ( avctx -> err_recognition & AV_EF_EXPLODE ) return AVERROR_INVALIDDATA ;\n }\n break ;\n case 0x2 : mpeg_decode_sequence_display_extension ( s ) ;\n break ;\n case 0x3 : mpeg_decode_quant_matrix_extension ( s2 ) ;\n break ;\n case 0x7 : mpeg_decode_picture_display_extension ( s ) ;\n break ;\n case 0x8 : if ( last_code == PICTURE_START_CODE ) {\n mpeg_decode_picture_coding_extension ( s ) ;\n }\n else {\n av_log ( avctx , AV_LOG_ERROR , \"ignoring pic cod ext after %X\\n\" , last_code ) ;\n if ( avctx -> err_recognition & AV_EF_EXPLODE ) return AVERROR_INVALIDDATA ;\n }\n break ;\n }\n break ;\n case USER_START_CODE : mpeg_decode_user_data ( avctx , buf_ptr , input_size ) ;\n break ;\n case GOP_START_CODE : if ( last_code == 0 ) {\n s2 -> first_field = 0 ;\n mpeg_decode_gop ( avctx , buf_ptr , input_size ) ;\n s -> sync = 1 ;\n }\n else {\n av_log ( avctx , AV_LOG_ERROR , \"ignoring GOP_START_CODE after %X\\n\" , last_code ) ;\n if ( avctx -> err_recognition & AV_EF_EXPLODE ) return AVERROR_INVALIDDATA ;\n }\n break ;\n default : if ( start_code >= SLICE_MIN_START_CODE && start_code <= SLICE_MAX_START_CODE && last_code != 0 ) {\n const int field_pic = s2 -> picture_structure != PICT_FRAME ;\n int mb_y = ( start_code - SLICE_MIN_START_CODE ) << field_pic ;\n last_code = SLICE_MIN_START_CODE ;\n if ( s2 -> picture_structure == PICT_BOTTOM_FIELD ) mb_y ++ ;\n if ( mb_y >= s2 -> mb_height ) {\n av_log ( s2 -> avctx , AV_LOG_ERROR , \"slice below image (%d >= %d)\\n\" , mb_y , s2 -> mb_height ) ;\n return - 1 ;\n }\n if ( s2 -> last_picture_ptr == NULL ) {\n if ( s2 -> pict_type == AV_PICTURE_TYPE_B ) {\n if ( ! s -> closed_gop ) break ;\n }\n }\n if ( s2 -> pict_type == AV_PICTURE_TYPE_I ) s -> sync = 1 ;\n if ( s2 -> next_picture_ptr == NULL ) {\n if ( s2 -> pict_type == AV_PICTURE_TYPE_P && ! s -> sync ) break ;\n }\n if ( ( avctx -> skip_frame >= AVDISCARD_NONREF && s2 -> pict_type == AV_PICTURE_TYPE_B ) || ( avctx -> skip_frame >= AVDISCARD_NONKEY && s2 -> pict_type != AV_PICTURE_TYPE_I ) || avctx -> skip_frame >= AVDISCARD_ALL ) break ;\n if ( ! s -> mpeg_enc_ctx_allocated ) break ;\n if ( s2 -> codec_id == AV_CODEC_ID_MPEG2VIDEO ) {\n if ( mb_y < avctx -> skip_top || mb_y >= s2 -> mb_height - avctx -> skip_bottom ) break ;\n }\n if ( ! s2 -> pict_type ) {\n av_log ( avctx , AV_LOG_ERROR , \"Missing picture start code\\n\" ) ;\n if ( avctx -> err_recognition & AV_EF_EXPLODE ) return AVERROR_INVALIDDATA ;\n break ;\n }\n if ( s2 -> first_slice ) {\n s2 -> first_slice = 0 ;\n if ( mpeg_field_start ( s2 , buf , buf_size ) < 0 ) return - 1 ;\n }\n if ( ! s2 -> current_picture_ptr ) {\n av_log ( avctx , AV_LOG_ERROR , \"current_picture not initialized\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU ) {\n s -> slice_count ++ ;\n break ;\n }\n if ( HAVE_THREADS && ( avctx -> active_thread_type & FF_THREAD_SLICE ) ) {\n int threshold = ( s2 -> mb_height * s -> slice_count + s2 -> slice_context_count / 2 ) / s2 -> slice_context_count ;\n if ( threshold <= mb_y ) {\n MpegEncContext * thread_context = s2 -> thread_context [ s -> slice_count ] ;\n thread_context -> start_mb_y = mb_y ;\n thread_context -> end_mb_y = s2 -> mb_height ;\n if ( s -> slice_count ) {\n s2 -> thread_context [ s -> slice_count - 1 ] -> end_mb_y = mb_y ;\n ret = ff_update_duplicate_context ( thread_context , s2 ) ;\n if ( ret < 0 ) return ret ;\n }\n init_get_bits ( & thread_context -> gb , buf_ptr , input_size * 8 ) ;\n s -> slice_count ++ ;\n }\n buf_ptr += 2 ;\n }\n else {\n ret = mpeg_decode_slice ( s2 , mb_y , & buf_ptr , input_size ) ;\n emms_c ( ) ;\n if ( ret < 0 ) {\n if ( avctx -> err_recognition & AV_EF_EXPLODE ) return ret ;\n if ( s2 -> resync_mb_x >= 0 && s2 -> resync_mb_y >= 0 ) ff_er_add_slice ( & s2 -> er , s2 -> resync_mb_x , s2 -> resync_mb_y , s2 -> mb_x , s2 -> mb_y , ER_AC_ERROR | ER_DC_ERROR | ER_MV_ERROR ) ;\n }\n else {\n ff_er_add_slice ( & s2 -> er , s2 -> resync_mb_x , s2 -> resync_mb_y , s2 -> mb_x - 1 , s2 -> mb_y , ER_AC_END | ER_DC_END | ER_MV_END ) ;\n }\n }\n }\n break ;\n }\n }\n }", "idx": 931}
{"hash": -6474315190511670247, "project": "debian", "size": 31, "label": 0, "functionSource": "static int get_and_cmp_point ( const char * name , const char * mpi_x_string , const char * mpi_y_string , const char * desc , gcry_ctx_t ctx ) {\n gcry_mpi_point_t point ;\n gcry_mpi_t x , y , z ;\n int result = 0 ;\n point = gcry_mpi_ec_get_point ( name , ctx , 1 ) ;\n if ( ! point ) {\n fail ( \"error getting point parameter '%s' of curve '%s'\\n\" , name , desc ) ;\n return 1 ;\n }\n if ( debug ) print_point ( name , point ) ;\n x = gcry_mpi_new ( 0 ) ;\n y = gcry_mpi_new ( 0 ) ;\n z = gcry_mpi_new ( 0 ) ;\n gcry_mpi_point_snatch_get ( x , y , z , point ) ;\n if ( cmp_mpihex ( x , mpi_x_string ) ) {\n fail ( \"x coordinate of '%s' of curve '%s' does not match\\n\" , name , desc ) ;\n result = 1 ;\n }\n if ( cmp_mpihex ( y , mpi_y_string ) ) {\n fail ( \"y coordinate of '%s' of curve '%s' does not match\\n\" , name , desc ) ;\n result = 1 ;\n }\n if ( cmp_mpihex ( z , \"01\" ) ) {\n fail ( \"z coordinate of '%s' of curve '%s' is not 1\\n\" , name , desc ) ;\n result = 1 ;\n }\n gcry_mpi_release ( x ) ;\n gcry_mpi_release ( y ) ;\n gcry_mpi_release ( z ) ;\n return result ;\n }", "idx": 932}
{"hash": 4180964683905830761, "project": "debian", "size": 6, "label": 0, "functionSource": "static int current_has_perm ( const struct task_struct * tsk , u32 perms ) {\n u32 sid , tsid ;\n sid = current_sid ( ) ;\n tsid = task_sid ( tsk ) ;\n return avc_has_perm ( sid , tsid , SECCLASS_PROCESS , perms , NULL ) ;\n }", "idx": 933}
{"hash": -8046645508582876963, "project": "debian", "size": 3, "label": 0, "functionSource": "static inline int square ( int x ) {\n return x * x ;\n }", "idx": 934}
{"hash": 4180964683905830761, "project": "debian", "size": 3, "label": 0, "functionSource": "static int selinux_file_alloc_security ( struct file * file ) {\n return file_alloc_security ( file ) ;\n }", "idx": 935}
{"hash": 3804373597256531021, "project": "debian", "size": 51, "label": 0, "functionSource": "my_bool acl_reload ( THD * thd ) {\n TABLE_LIST tables [ 3 ] ;\n DYNAMIC_ARRAY old_acl_hosts , old_acl_users , old_acl_dbs ;\n MEM_ROOT old_mem ;\n bool old_initialized ;\n my_bool return_val = TRUE ;\n DBUG_ENTER ( \"acl_reload\" ) ;\n if ( thd -> locked_tables ) {\n thd -> lock = thd -> locked_tables ;\n thd -> locked_tables = 0 ;\n close_thread_tables ( thd ) ;\n }\n bzero ( ( char * ) tables , sizeof ( tables ) ) ;\n tables [ 0 ] . alias = tables [ 0 ] . table_name = ( char * ) \"host\" ;\n tables [ 1 ] . alias = tables [ 1 ] . table_name = ( char * ) \"user\" ;\n tables [ 2 ] . alias = tables [ 2 ] . table_name = ( char * ) \"db\" ;\n tables [ 0 ] . db = tables [ 1 ] . db = tables [ 2 ] . db = ( char * ) \"mysql\" ;\n tables [ 0 ] . next_local = tables [ 0 ] . next_global = tables + 1 ;\n tables [ 1 ] . next_local = tables [ 1 ] . next_global = tables + 2 ;\n tables [ 0 ] . lock_type = tables [ 1 ] . lock_type = tables [ 2 ] . lock_type = TL_READ ;\n tables [ 0 ] . skip_temporary = tables [ 1 ] . skip_temporary = tables [ 2 ] . skip_temporary = TRUE ;\n if ( simple_open_n_lock_tables ( thd , tables ) ) {\n if ( thd -> main_da . is_error ( ) ) sql_print_error ( \"Fatal error: Can't open and lock privilege tables: %s\" , thd -> main_da . message ( ) ) ;\n goto end ;\n }\n if ( ( old_initialized = initialized ) ) VOID ( pthread_mutex_lock ( & acl_cache -> lock ) ) ;\n old_acl_hosts = acl_hosts ;\n old_acl_users = acl_users ;\n old_acl_dbs = acl_dbs ;\n old_mem = mem ;\n delete_dynamic ( & acl_wild_hosts ) ;\n hash_free ( & acl_check_hosts ) ;\n if ( ( return_val = acl_load ( thd , tables ) ) ) {\n DBUG_PRINT ( \"error\" , ( \"Reverting to old privileges\" ) ) ;\n acl_free ( ) ;\n acl_hosts = old_acl_hosts ;\n acl_users = old_acl_users ;\n acl_dbs = old_acl_dbs ;\n mem = old_mem ;\n init_check_host ( ) ;\n }\n else {\n free_root ( & old_mem , MYF ( 0 ) ) ;\n delete_dynamic ( & old_acl_hosts ) ;\n delete_dynamic ( & old_acl_users ) ;\n delete_dynamic ( & old_acl_dbs ) ;\n }\n if ( old_initialized ) VOID ( pthread_mutex_unlock ( & acl_cache -> lock ) ) ;\n end : close_thread_tables ( thd ) ;\n DBUG_RETURN ( return_val ) ;\n }", "idx": 936}
{"hash": 6120640898537304364, "project": "debian", "size": 6, "label": 0, "functionSource": "static void pdf_process_grestore ( fz_context * ctx , pdf_processor * proc , pdf_csi * csi ) {\n if ( csi -> gstate > 0 ) {\n if ( proc -> op_Q ) proc -> op_Q ( ctx , proc ) ;\n -- csi -> gstate ;\n }\n }", "idx": 937}
{"hash": -877789201846276110, "project": "chrome", "size": 45, "label": 1, "functionSource": "TEST_F ( WebUsbDetectorTest , ThreeUsbDevicesAddedAndRemoved ) {\n base : : string16 product_name_1 = base : : UTF8ToUTF16 ( kProductName_1 ) ;\n GURL landing_page_1 ( kLandingPage_1 ) ;\n scoped_refptr < device : : MockUsbDevice > device_1 ( new device : : MockUsbDevice ( 0 , 1 , \"Google\" , kProductName_1 , \"002\" , landing_page_1 ) ) ;\n std : : string guid_1 = device_1 -> guid ( ) ;\n base : : string16 product_name_2 = base : : UTF8ToUTF16 ( kProductName_2 ) ;\n GURL landing_page_2 ( kLandingPage_2 ) ;\n scoped_refptr < device : : MockUsbDevice > device_2 ( new device : : MockUsbDevice ( 3 , 4 , \"Google\" , kProductName_2 , \"005\" , landing_page_2 ) ) ;\n std : : string guid_2 = device_2 -> guid ( ) ;\n base : : string16 product_name_3 = base : : UTF8ToUTF16 ( kProductName_3 ) ;\n GURL landing_page_3 ( kLandingPage_3 ) ;\n scoped_refptr < device : : MockUsbDevice > device_3 ( new device : : MockUsbDevice ( 6 , 7 , \"Google\" , kProductName_3 , \"008\" , landing_page_3 ) ) ;\n std : : string guid_3 = device_3 -> guid ( ) ;\n Initialize ( ) ;\n device_client_ . usb_service ( ) -> AddDevice ( device_1 ) ;\n message_center : : Notification * notification_1 = message_center_ -> FindVisibleNotificationById ( guid_1 ) ;\n ASSERT_TRUE ( notification_1 != nullptr ) ;\n base : : string16 expected_title_1 = base : : ASCIIToUTF16 ( \"Google Product A detected\" ) ;\n EXPECT_EQ ( expected_title_1 , notification_1 -> title ( ) ) ;\n base : : string16 expected_message_1 = base : : ASCIIToUTF16 ( \"Go to www.google.com/A to connect.\" ) ;\n EXPECT_EQ ( expected_message_1 , notification_1 -> message ( ) ) ;\n EXPECT_TRUE ( notification_1 -> delegate ( ) != nullptr ) ;\n device_client_ . usb_service ( ) -> RemoveDevice ( device_1 ) ;\n EXPECT_TRUE ( message_center_ -> FindVisibleNotificationById ( guid_1 ) == nullptr ) ;\n device_client_ . usb_service ( ) -> AddDevice ( device_2 ) ;\n message_center : : Notification * notification_2 = message_center_ -> FindVisibleNotificationById ( guid_2 ) ;\n ASSERT_TRUE ( notification_2 != nullptr ) ;\n base : : string16 expected_title_2 = base : : ASCIIToUTF16 ( \"Google Product B detected\" ) ;\n EXPECT_EQ ( expected_title_2 , notification_2 -> title ( ) ) ;\n base : : string16 expected_message_2 = base : : ASCIIToUTF16 ( \"Go to www.google.com/B to connect.\" ) ;\n EXPECT_EQ ( expected_message_2 , notification_2 -> message ( ) ) ;\n EXPECT_TRUE ( notification_2 -> delegate ( ) != nullptr ) ;\n device_client_ . usb_service ( ) -> RemoveDevice ( device_2 ) ;\n EXPECT_TRUE ( message_center_ -> FindVisibleNotificationById ( guid_2 ) == nullptr ) ;\n device_client_ . usb_service ( ) -> AddDevice ( device_3 ) ;\n message_center : : Notification * notification_3 = message_center_ -> FindVisibleNotificationById ( guid_3 ) ;\n ASSERT_TRUE ( notification_3 != nullptr ) ;\n base : : string16 expected_title_3 = base : : ASCIIToUTF16 ( \"Google Product C detected\" ) ;\n EXPECT_EQ ( expected_title_3 , notification_3 -> title ( ) ) ;\n base : : string16 expected_message_3 = base : : ASCIIToUTF16 ( \"Go to www.google.com/C to connect.\" ) ;\n EXPECT_EQ ( expected_message_3 , notification_3 -> message ( ) ) ;\n EXPECT_TRUE ( notification_3 -> delegate ( ) != nullptr ) ;\n device_client_ . usb_service ( ) -> RemoveDevice ( device_3 ) ;\n EXPECT_TRUE ( message_center_ -> FindVisibleNotificationById ( guid_3 ) == nullptr ) ;\n }", "idx": 938}
{"hash": -6119142299306266167, "project": "debian", "size": 6, "label": 0, "functionSource": "static int zcountexecstack ( i_ctx_t * i_ctx_p ) {\n os_ptr op = osp ;\n push ( 1 ) ;\n make_int ( op , count_exec_stack ( i_ctx_p , false ) ) ;\n return 0 ;\n }", "idx": 939}
{"hash": 355220887711506893, "project": "debian", "size": 19, "label": 1, "functionSource": "extern int name ( int ) __THROW __exctype ( isalnum ) ;\n __exctype ( isalpha ) ;\n __exctype ( iscntrl ) ;\n __exctype ( isdigit ) ;\n __exctype ( islower ) ;\n __exctype ( isgraph ) ;\n __exctype ( isprint ) ;\n __exctype ( ispunct ) ;\n __exctype ( isspace ) ;\n __exctype ( isupper ) ;\n __exctype ( isxdigit ) ;\n extern int tolower ( int __c ) __THROW ;\n extern int toupper ( int __c ) __THROW ;\n # ifdef __USE_ISOC99 __exctype ( isblank ) ;\n # endif # ifdef __USE_GNU extern int isctype ( int __c , int __mask ) __THROW ;\n # endif # if defined __USE_MISC || defined __USE_XOPEN extern int isascii ( int __c ) __THROW ;\n extern int toascii ( int __c ) __THROW ;\n __exctype ( _toupper ) ;\n __exctype ( _tolower )", "idx": 940}
{"hash": 7198560023137364337, "project": "debian", "size": 81, "label": 0, "functionSource": "int set_file_attrs ( const char * fname , struct file_struct * file , stat_x * sxp , const char * fnamecmp , int flags ) {\n int updated = 0 ;\n stat_x sx2 ;\n int change_uid , change_gid ;\n mode_t new_mode = file -> mode ;\n int inherit ;\n if ( ! sxp ) {\n if ( dry_run ) return 1 ;\n if ( link_stat ( fname , & sx2 . st , 0 ) < 0 ) {\n rsyserr ( FERROR_XFER , errno , \"stat %s failed\" , full_fname ( fname ) ) ;\n return 0 ;\n }\n init_stat_x ( & sx2 ) ;\n sxp = & sx2 ;\n inherit = ! preserve_perms ;\n }\n else inherit = ! preserve_perms && file -> flags & FLAG_DIR_CREATED ;\n if ( inherit && S_ISDIR ( new_mode ) && sxp -> st . st_mode & S_ISGID ) {\n new_mode |= S_ISGID ;\n }\n if ( daemon_chmod_modes && ! S_ISLNK ( new_mode ) ) new_mode = tweak_mode ( new_mode , daemon_chmod_modes ) ;\n # ifdef SUPPORT_ACLS if ( preserve_acls && ! S_ISLNK ( file -> mode ) && ! ACL_READY ( * sxp ) ) get_acl ( fname , sxp ) ;\n # endif change_uid = am_root && uid_ndx && sxp -> st . st_uid != ( uid_t ) F_OWNER ( file ) ;\n change_gid = gid_ndx && ! ( file -> flags & FLAG_SKIP_GROUP ) && sxp -> st . st_gid != ( gid_t ) F_GROUP ( file ) ;\n # ifndef CAN_CHOWN_SYMLINK if ( S_ISLNK ( sxp -> st . st_mode ) ) {\n ;\n }\n else # endif if ( change_uid || change_gid ) {\n if ( DEBUG_GTE ( OWN , 1 ) ) {\n if ( change_uid ) {\n rprintf ( FINFO , \"set uid of %s from %u to %u\\n\" , fname , ( unsigned ) sxp -> st . st_uid , F_OWNER ( file ) ) ;\n }\n if ( change_gid ) {\n rprintf ( FINFO , \"set gid of %s from %u to %u\\n\" , fname , ( unsigned ) sxp -> st . st_gid , F_GROUP ( file ) ) ;\n }\n }\n if ( am_root >= 0 ) {\n uid_t uid = change_uid ? ( uid_t ) F_OWNER ( file ) : sxp -> st . st_uid ;\n gid_t gid = change_gid ? ( gid_t ) F_GROUP ( file ) : sxp -> st . st_gid ;\n if ( do_lchown ( fname , uid , gid ) != 0 ) {\n rsyserr ( FERROR_XFER , errno , \"%s %s failed\" , change_uid ? \"chown\" : \"chgrp\" , full_fname ( fname ) ) ;\n goto cleanup ;\n }\n if ( uid == ( uid_t ) - 1 && sxp -> st . st_uid != ( uid_t ) - 1 ) rprintf ( FERROR_XFER , \"uid 4294967295 (-1) is impossible to set on %s\\n\" , full_fname ( fname ) ) ;\n if ( gid == ( gid_t ) - 1 && sxp -> st . st_gid != ( gid_t ) - 1 ) rprintf ( FERROR_XFER , \"gid 4294967295 (-1) is impossible to set on %s\\n\" , full_fname ( fname ) ) ;\n if ( sxp -> st . st_mode & ( S_ISUID | S_ISGID ) ) {\n link_stat ( fname , & sxp -> st , keep_dirlinks && S_ISDIR ( sxp -> st . st_mode ) ) ;\n }\n }\n updated = 1 ;\n }\n # ifdef SUPPORT_XATTRS if ( am_root < 0 ) set_stat_xattr ( fname , file , new_mode ) ;\n if ( preserve_xattrs && fnamecmp ) set_xattr ( fname , file , fnamecmp , sxp ) ;\n # endif if ( ! preserve_times || ( ! ( preserve_times & PRESERVE_DIR_TIMES ) && S_ISDIR ( sxp -> st . st_mode ) ) || ( ! ( preserve_times & PRESERVE_LINK_TIMES ) && S_ISLNK ( sxp -> st . st_mode ) ) ) flags |= ATTRS_SKIP_MTIME ;\n if ( ! ( flags & ATTRS_SKIP_MTIME ) && ( sxp -> st . st_mtime != file -> modtime # ifdef ST_MTIME_NSEC || ( NSEC_BUMP ( file ) && ( uint32 ) sxp -> st . ST_MTIME_NSEC != F_MOD_NSEC ( file ) ) # endif ) ) {\n int ret = set_modtime ( fname , file -> modtime , F_MOD_NSEC ( file ) , sxp -> st . st_mode ) ;\n if ( ret < 0 ) {\n rsyserr ( FERROR_XFER , errno , \"failed to set times on %s\" , full_fname ( fname ) ) ;\n goto cleanup ;\n }\n if ( ret == 0 ) updated = 1 ;\n else file -> flags |= FLAG_TIME_FAILED ;\n }\n # ifdef SUPPORT_ACLS if ( preserve_acls && ! S_ISLNK ( new_mode ) ) {\n if ( set_acl ( fname , file , sxp , new_mode ) > 0 ) updated = 1 ;\n }\n # endif # ifdef HAVE_CHMOD if ( ! BITS_EQUAL ( sxp -> st . st_mode , new_mode , CHMOD_BITS ) ) {\n int ret = am_root < 0 ? 0 : do_chmod ( fname , new_mode ) ;\n if ( ret < 0 ) {\n rsyserr ( FERROR_XFER , errno , \"failed to set permissions on %s\" , full_fname ( fname ) ) ;\n goto cleanup ;\n }\n if ( ret == 0 ) updated = 1 ;\n }\n # endif if ( INFO_GTE ( NAME , 2 ) && flags & ATTRS_REPORT ) {\n if ( updated ) rprintf ( FCLIENT , \"%s\\n\" , fname ) ;\n else rprintf ( FCLIENT , \"%s is uptodate\\n\" , fname ) ;\n }\n cleanup : if ( sxp == & sx2 ) free_stat_x ( & sx2 ) ;\n return updated ;\n }", "idx": 941}
{"hash": 9046191708840218774, "project": "debian", "size": 15, "label": 0, "functionSource": "static int __tipc_nl_compat_link_set ( struct sk_buff * skb , struct tipc_nl_compat_msg * msg ) {\n struct nlattr * prop ;\n struct nlattr * link ;\n struct tipc_link_config * lc ;\n lc = ( struct tipc_link_config * ) TLV_DATA ( msg -> req ) ;\n link = nla_nest_start ( skb , TIPC_NLA_LINK ) ;\n if ( ! link ) return - EMSGSIZE ;\n if ( nla_put_string ( skb , TIPC_NLA_LINK_NAME , lc -> name ) ) return - EMSGSIZE ;\n prop = nla_nest_start ( skb , TIPC_NLA_LINK_PROP ) ;\n if ( ! prop ) return - EMSGSIZE ;\n __tipc_add_link_prop ( skb , msg , lc ) ;\n nla_nest_end ( skb , prop ) ;\n nla_nest_end ( skb , link ) ;\n return 0 ;\n }", "idx": 942}
{"hash": 8388187431631506723, "project": "debian", "size": 5, "label": 0, "functionSource": "static bool hyperv_reenlightenment_enable_needed ( void * opaque ) {\n X86CPU * cpu = opaque ;\n CPUX86State * env = & cpu -> env ;\n return env -> msr_hv_reenlightenment_control != 0 || env -> msr_hv_tsc_emulation_control != 0 || env -> msr_hv_tsc_emulation_status != 0 ;\n }", "idx": 943}
{"hash": 103178053094187415, "project": "chrome", "size": 4, "label": 0, "functionSource": "xmlNodePtr * xsltTemplateProcess ( xsltTransformContextPtr ctxt ATTRIBUTE_UNUSED , xmlNodePtr node ) {\n if ( node == NULL ) return ( NULL ) ;\n return ( 0 ) ;\n }", "idx": 944}
{"hash": 7424930167238097621, "project": "debian", "size": 16, "label": 0, "functionSource": "static int proc_disconnect_claim ( struct usb_dev_state * ps , void __user * arg ) {\n struct usbdevfs_disconnect_claim dc ;\n struct usb_interface * intf ;\n if ( copy_from_user ( & dc , arg , sizeof ( dc ) ) ) return - EFAULT ;\n intf = usb_ifnum_to_if ( ps -> dev , dc . interface ) ;\n if ( ! intf ) return - EINVAL ;\n if ( intf -> dev . driver ) {\n struct usb_driver * driver = to_usb_driver ( intf -> dev . driver ) ;\n if ( ps -> privileges_dropped ) return - EACCES ;\n if ( ( dc . flags & USBDEVFS_DISCONNECT_CLAIM_IF_DRIVER ) && strncmp ( dc . driver , intf -> dev . driver -> name , sizeof ( dc . driver ) ) != 0 ) return - EBUSY ;\n if ( ( dc . flags & USBDEVFS_DISCONNECT_CLAIM_EXCEPT_DRIVER ) && strncmp ( dc . driver , intf -> dev . driver -> name , sizeof ( dc . driver ) ) == 0 ) return - EBUSY ;\n dev_dbg ( & intf -> dev , \"disconnect by usbfs\\n\" ) ;\n usb_driver_release_interface ( driver , intf ) ;\n }\n return claimintf ( ps , dc . interface ) ;\n }", "idx": 945}
{"hash": 6393050609822897742, "project": "debian", "size": 8, "label": 0, "functionSource": "static void xhci_free_device_streams ( XHCIState * xhci , unsigned int slotid , uint32_t epmask ) {\n USBEndpoint * eps [ 30 ] ;\n int nr_eps ;\n nr_eps = xhci_epmask_to_eps_with_streams ( xhci , slotid , epmask , NULL , eps ) ;\n if ( nr_eps ) {\n usb_device_free_streams ( eps [ 0 ] -> dev , eps , nr_eps ) ;\n }\n }", "idx": 946}
{"hash": 3668456668028959955, "project": "debian", "size": 4, "label": 0, "functionSource": "static VALUE cState_array_nl ( VALUE self ) {\n GET_STATE ( self ) ;\n return state -> array_nl ? rb_str_new ( state -> array_nl , state -> array_nl_len ) : rb_str_new2 ( \"\" ) ;\n }", "idx": 947}
{"hash": -1102844685921778700, "project": "debian", "size": 19, "label": 0, "functionSource": "int archive_mstring_get_wcs ( struct archive * a , struct archive_mstring * aes , const wchar_t * * wp ) {\n int r , ret = 0 ;\n ( void ) a ;\n if ( aes -> aes_set & AES_SET_WCS ) {\n * wp = aes -> aes_wcs . s ;\n return ( ret ) ;\n }\n * wp = NULL ;\n if ( aes -> aes_set & AES_SET_MBS ) {\n archive_wstring_empty ( & ( aes -> aes_wcs ) ) ;\n r = archive_wstring_append_from_mbs ( & ( aes -> aes_wcs ) , aes -> aes_mbs . s , aes -> aes_mbs . length ) ;\n if ( r == 0 ) {\n aes -> aes_set |= AES_SET_WCS ;\n * wp = aes -> aes_wcs . s ;\n }\n else ret = - 1 ;\n }\n return ( ret ) ;\n }", "idx": 948}
{"hash": -673406620978847526, "project": "chrome", "size": 6, "label": 0, "functionSource": "TEST_F ( WebFrameTest , GetCanonicalUrlForSharingMultiple ) {\n FrameTestHelpers : : WebViewHelper web_view_helper ;\n web_view_helper . Initialize ( ) ;\n WebLocalFrameImpl * frame = web_view_helper . LocalMainFrame ( ) ;\n FrameTestHelpers : : LoadHTMLString ( frame , R \"( < head > < link rel = \"canonical\" href = \"https://example.com/canonical1.html\" > < link rel = \"canonical\" href = \"https://example.com/canonical2.html\" > < / head > ) \", ToKURL(\" https : EXPECT_EQ ( WebURL ( ToKURL ( \"https://example.com/canonical1.html\" ) ) , frame -> GetDocument ( ) . CanonicalUrlForSharing ( ) ) ;\n }", "idx": 949}
{"hash": -2423144171479606949, "project": "debian", "size": 124, "label": 0, "functionSource": "pdf_processor * pdf_new_run_processor ( fz_context * ctx , fz_device * dev , const fz_matrix * ctm , const char * usage , pdf_gstate * gstate , int nested , fz_default_colorspaces * default_cs ) {\n pdf_run_processor * proc = pdf_new_processor ( ctx , sizeof * proc ) ;\n {\n proc -> super . usage = usage ;\n proc -> super . drop_processor = pdf_drop_run_processor ;\n proc -> super . op_w = pdf_run_w ;\n proc -> super . op_j = pdf_run_j ;\n proc -> super . op_J = pdf_run_J ;\n proc -> super . op_M = pdf_run_M ;\n proc -> super . op_d = pdf_run_d ;\n proc -> super . op_ri = pdf_run_ri ;\n proc -> super . op_i = pdf_run_i ;\n proc -> super . op_gs_begin = pdf_run_gs_begin ;\n proc -> super . op_gs_end = pdf_run_gs_end ;\n proc -> super . op_gs_BM = pdf_run_gs_BM ;\n proc -> super . op_gs_CA = pdf_run_gs_CA ;\n proc -> super . op_gs_ca = pdf_run_gs_ca ;\n proc -> super . op_gs_SMask = pdf_run_gs_SMask ;\n proc -> super . op_q = pdf_run_q ;\n proc -> super . op_Q = pdf_run_Q ;\n proc -> super . op_cm = pdf_run_cm ;\n proc -> super . op_m = pdf_run_m ;\n proc -> super . op_l = pdf_run_l ;\n proc -> super . op_c = pdf_run_c ;\n proc -> super . op_v = pdf_run_v ;\n proc -> super . op_y = pdf_run_y ;\n proc -> super . op_h = pdf_run_h ;\n proc -> super . op_re = pdf_run_re ;\n proc -> super . op_S = pdf_run_S ;\n proc -> super . op_s = pdf_run_s ;\n proc -> super . op_F = pdf_run_F ;\n proc -> super . op_f = pdf_run_f ;\n proc -> super . op_fstar = pdf_run_fstar ;\n proc -> super . op_B = pdf_run_B ;\n proc -> super . op_Bstar = pdf_run_Bstar ;\n proc -> super . op_b = pdf_run_b ;\n proc -> super . op_bstar = pdf_run_bstar ;\n proc -> super . op_n = pdf_run_n ;\n proc -> super . op_W = pdf_run_W ;\n proc -> super . op_Wstar = pdf_run_Wstar ;\n proc -> super . op_BT = pdf_run_BT ;\n proc -> super . op_ET = pdf_run_ET ;\n proc -> super . op_Tc = pdf_run_Tc ;\n proc -> super . op_Tw = pdf_run_Tw ;\n proc -> super . op_Tz = pdf_run_Tz ;\n proc -> super . op_TL = pdf_run_TL ;\n proc -> super . op_Tf = pdf_run_Tf ;\n proc -> super . op_Tr = pdf_run_Tr ;\n proc -> super . op_Ts = pdf_run_Ts ;\n proc -> super . op_Td = pdf_run_Td ;\n proc -> super . op_TD = pdf_run_TD ;\n proc -> super . op_Tm = pdf_run_Tm ;\n proc -> super . op_Tstar = pdf_run_Tstar ;\n proc -> super . op_TJ = pdf_run_TJ ;\n proc -> super . op_Tj = pdf_run_Tj ;\n proc -> super . op_squote = pdf_run_squote ;\n proc -> super . op_dquote = pdf_run_dquote ;\n proc -> super . op_d0 = pdf_run_d0 ;\n proc -> super . op_d1 = pdf_run_d1 ;\n proc -> super . op_CS = pdf_run_CS ;\n proc -> super . op_cs = pdf_run_cs ;\n proc -> super . op_SC_color = pdf_run_SC_color ;\n proc -> super . op_sc_color = pdf_run_sc_color ;\n proc -> super . op_SC_pattern = pdf_run_SC_pattern ;\n proc -> super . op_sc_pattern = pdf_run_sc_pattern ;\n proc -> super . op_SC_shade = pdf_run_SC_shade ;\n proc -> super . op_sc_shade = pdf_run_sc_shade ;\n proc -> super . op_G = pdf_run_G ;\n proc -> super . op_g = pdf_run_g ;\n proc -> super . op_RG = pdf_run_RG ;\n proc -> super . op_rg = pdf_run_rg ;\n proc -> super . op_K = pdf_run_K ;\n proc -> super . op_k = pdf_run_k ;\n proc -> super . op_sh = pdf_run_sh ;\n if ( dev -> fill_image || dev -> fill_image_mask || dev -> clip_image_mask ) {\n proc -> super . op_BI = pdf_run_BI ;\n proc -> super . op_Do_image = pdf_run_Do_image ;\n }\n proc -> super . op_Do_form = pdf_run_Do_form ;\n proc -> super . op_MP = pdf_run_MP ;\n proc -> super . op_DP = pdf_run_DP ;\n proc -> super . op_BMC = pdf_run_BMC ;\n proc -> super . op_BDC = pdf_run_BDC ;\n proc -> super . op_EMC = pdf_run_EMC ;\n proc -> super . op_BX = pdf_run_BX ;\n proc -> super . op_EX = pdf_run_EX ;\n proc -> super . op_gs_OP = pdf_run_gs_OP ;\n proc -> super . op_gs_op = pdf_run_gs_op ;\n proc -> super . op_gs_OPM = pdf_run_gs_OPM ;\n proc -> super . op_gs_UseBlackPtComp = pdf_run_gs_UseBlackPtComp ;\n proc -> super . op_END = pdf_run_END ;\n }\n proc -> dev = dev ;\n proc -> default_cs = fz_keep_default_colorspaces ( ctx , default_cs ) ;\n proc -> nested_depth = nested ;\n proc -> path = NULL ;\n proc -> clip = 0 ;\n proc -> clip_even_odd = 0 ;\n proc -> tos . text = NULL ;\n proc -> tos . tlm = fz_identity ;\n proc -> tos . tm = fz_identity ;\n proc -> tos . text_mode = 0 ;\n fz_try ( ctx ) {\n proc -> path = fz_new_path ( ctx ) ;\n proc -> gcap = 64 ;\n proc -> gstate = fz_malloc_array ( ctx , proc -> gcap , sizeof ( pdf_gstate ) ) ;\n pdf_init_gstate ( ctx , & proc -> gstate [ 0 ] , ctm ) ;\n if ( gstate ) {\n pdf_copy_gstate ( ctx , & proc -> gstate [ 0 ] , gstate ) ;\n proc -> gstate [ 0 ] . clip_depth = 0 ;\n proc -> gstate [ 0 ] . ctm = * ctm ;\n }\n proc -> gtop = 0 ;\n proc -> gbot = 0 ;\n proc -> gparent = 0 ;\n }\n fz_catch ( ctx ) {\n fz_drop_path ( ctx , proc -> path ) ;\n fz_free ( ctx , proc ) ;\n fz_rethrow ( ctx ) ;\n }\n pdf_gsave ( ctx , proc ) ;\n return ( pdf_processor * ) proc ;\n }", "idx": 950}
{"hash": 6249489553242542670, "project": "debian", "size": 72, "label": 0, "functionSource": "static void config_trap ( config_tree * ptree ) {\n addr_opts_node * curr_trap ;\n attr_val * curr_opt ;\n sockaddr_u addr_sock ;\n sockaddr_u peeraddr ;\n struct interface * localaddr ;\n struct addrinfo hints ;\n char port_text [ 8 ] ;\n settrap_parms * pstp ;\n u_short port ;\n int err_flag ;\n int rc ;\n AF ( & addr_sock ) = AF_UNSPEC ;\n curr_trap = HEAD_PFIFO ( ptree -> trap ) ;\n for ( ;\n curr_trap != NULL ;\n curr_trap = curr_trap -> link ) {\n err_flag = 0 ;\n port = 0 ;\n localaddr = NULL ;\n curr_opt = HEAD_PFIFO ( curr_trap -> options ) ;\n for ( ;\n curr_opt != NULL ;\n curr_opt = curr_opt -> link ) {\n if ( T_Port == curr_opt -> attr ) {\n if ( curr_opt -> value . i < 1 || curr_opt -> value . i > USHRT_MAX ) {\n msyslog ( LOG_ERR , \"invalid port number \" \"%d, trap ignored\" , curr_opt -> value . i ) ;\n err_flag = 1 ;\n }\n port = ( u_short ) curr_opt -> value . i ;\n }\n else if ( T_Interface == curr_opt -> attr ) {\n ZERO_SOCK ( & addr_sock ) ;\n if ( getnetnum ( curr_opt -> value . s , & addr_sock , 1 , t_UNK ) != 1 ) {\n err_flag = 1 ;\n break ;\n }\n localaddr = findinterface ( & addr_sock ) ;\n if ( NULL == localaddr ) {\n msyslog ( LOG_ERR , \"can't find interface with address %s\" , stoa ( & addr_sock ) ) ;\n err_flag = 1 ;\n }\n }\n }\n if ( ! err_flag ) {\n if ( ! port ) port = TRAPPORT ;\n ZERO_SOCK ( & peeraddr ) ;\n rc = getnetnum ( curr_trap -> addr -> address , & peeraddr , 1 , t_UNK ) ;\n if ( 1 != rc ) {\n # ifndef WORKER msyslog ( LOG_ERR , \"trap: unable to use IP address %s.\" , curr_trap -> addr -> address ) ;\n # else memset ( & hints , 0 , sizeof ( hints ) ) ;\n hints . ai_protocol = IPPROTO_UDP ;\n hints . ai_socktype = SOCK_DGRAM ;\n snprintf ( port_text , sizeof ( port_text ) , \"%u\" , port ) ;\n hints . ai_flags = Z_AI_NUMERICSERV ;\n pstp = emalloc_zero ( sizeof ( * pstp ) ) ;\n if ( localaddr != NULL ) {\n hints . ai_family = localaddr -> family ;\n pstp -> ifaddr_nonnull = 1 ;\n memcpy ( & pstp -> ifaddr , & localaddr -> sin , sizeof ( pstp -> ifaddr ) ) ;\n }\n rc = getaddrinfo_sometime ( curr_trap -> addr -> address , port_text , & hints , INITIAL_DNS_RETRY , & trap_name_resolved , pstp ) ;\n if ( ! rc ) msyslog ( LOG_ERR , \"config_trap: getaddrinfo_sometime(%s,%s): %m\" , curr_trap -> addr -> address , port_text ) ;\n # endif continue ;\n }\n SET_PORT ( & peeraddr , port ) ;\n if ( NULL == localaddr ) localaddr = ANY_INTERFACE_CHOOSE ( & peeraddr ) ;\n else AF ( & peeraddr ) = AF ( & addr_sock ) ;\n if ( ! ctlsettrap ( & peeraddr , localaddr , 0 , NTP_VERSION ) ) msyslog ( LOG_ERR , \"set trap %s -> %s failed.\" , latoa ( localaddr ) , stoa ( & peeraddr ) ) ;\n }\n }\n }", "idx": 951}
{"hash": -7455544248455991006, "project": "debian", "size": 5, "label": 0, "functionSource": "static int kvm_put_one_msr ( X86CPU * cpu , int index , uint64_t value ) {\n kvm_msr_buf_reset ( cpu ) ;\n kvm_msr_entry_add ( cpu , index , value ) ;\n return kvm_vcpu_ioctl ( CPU ( cpu ) , KVM_SET_MSRS , cpu -> kvm_msr_buf ) ;\n }", "idx": 952}
{"hash": -305162769887579921, "project": "debian", "size": 5, "label": 0, "functionSource": "static inline void update_qscale ( MpegEncContext * s ) {\n s -> qscale = ( s -> lambda * 139 + FF_LAMBDA_SCALE * 64 ) >> ( FF_LAMBDA_SHIFT + 7 ) ;\n s -> qscale = av_clip ( s -> qscale , s -> avctx -> qmin , s -> avctx -> qmax ) ;\n s -> lambda2 = ( s -> lambda * s -> lambda + FF_LAMBDA_SCALE / 2 ) >> FF_LAMBDA_SHIFT ;\n }", "idx": 953}
{"hash": 2755982813601944893, "project": "debian", "size": 10, "label": 0, "functionSource": "static int very_broken_op ( int a , int b ) {\n int x = a * b + 200 ;\n int size ;\n const uint8_t * rtab ;\n if ( x % 400 || b % 5 ) return x / 400 ;\n x /= 400 ;\n size = tabs [ b / 5 ] . size ;\n rtab = tabs [ b / 5 ] . tab ;\n return x - rtab [ size * av_log2 ( 2 * ( x - 1 ) / size ) + ( x - 1 ) % size ] ;\n }", "idx": 954}
{"hash": -6068976579504840746, "project": "debian", "size": 22, "label": 0, "functionSource": "const char * get_ext_sys_var ( const char * tag ) {\n struct ctl_var * v ;\n size_t c ;\n const char * val ;\n val = NULL ;\n c = strlen ( tag ) ;\n for ( v = ext_sys_var ;\n ! ( EOV & v -> flags ) ;\n v ++ ) {\n if ( NULL != v -> text && ! memcmp ( tag , v -> text , c ) ) {\n if ( '=' == v -> text [ c ] ) {\n val = v -> text + c + 1 ;\n break ;\n }\n else if ( '\\0' == v -> text [ c ] ) {\n val = \"\" ;\n break ;\n }\n }\n }\n return val ;\n }", "idx": 955}
{"hash": 4704178797381506498, "project": "debian", "size": 11, "label": 0, "functionSource": "static void kadm5_free_principal ( krb5_context context , krb5_principal val ) {\n register krb5_int32 i ;\n if ( ! val ) return ;\n if ( val -> data ) {\n i = krb5_princ_size ( context , val ) ;\n while ( -- i >= 0 ) krb5_db_free ( context , krb5_princ_component ( context , val , i ) -> data ) ;\n krb5_db_free ( context , val -> data ) ;\n }\n if ( val -> realm . data ) krb5_db_free ( context , val -> realm . data ) ;\n krb5_db_free ( context , val ) ;\n }", "idx": 956}
{"hash": 1223258652239369123, "project": "debian", "size": 7, "label": 1, "functionSource": "SPL_METHOD ( SplFileObject , key ) {\n spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n if ( zend_parse_parameters_none ( ) == FAILURE ) {\n return ;\n }\n RETURN_LONG ( intern -> u . file . current_line_num ) ;\n }", "idx": 957}
{"hash": -3559021711340554904, "project": "debian", "size": 12, "label": 0, "functionSource": "void CommuteOpExpr ( OpExpr * clause ) {\n Oid opoid ;\n Node * temp ;\n if ( ! is_opclause ( clause ) || list_length ( clause -> args ) != 2 ) elog ( ERROR , \"cannot commute non-binary-operator clause\" ) ;\n opoid = get_commutator ( clause -> opno ) ;\n if ( ! OidIsValid ( opoid ) ) elog ( ERROR , \"could not find commutator for operator %u\" , clause -> opno ) ;\n clause -> opno = opoid ;\n clause -> opfuncid = InvalidOid ;\n temp = linitial ( clause -> args ) ;\n linitial ( clause -> args ) = lsecond ( clause -> args ) ;\n lsecond ( clause -> args ) = temp ;\n }", "idx": 958}
{"hash": -5456913190944844754, "project": "chrome", "size": 6, "label": 0, "functionSource": "TEST_F ( TemplateURLTest , Defaults ) {\n TemplateURLData data ;\n EXPECT_FALSE ( data . show_in_default_list ) ;\n EXPECT_FALSE ( data . safe_for_autoreplace ) ;\n EXPECT_EQ ( 0 , data . prepopulate_id ) ;\n }", "idx": 959}
{"hash": -8228664527580018723, "project": "debian", "size": 220, "label": 0, "functionSource": "static int dprintf_formatf ( void * data , int ( * stream ) ( int , FILE * ) , const char * format , va_list ap_save ) {\n const char * digits = lower_digits ;\n char * f ;\n int done = 0 ;\n long param ;\n long param_num = 0 ;\n va_stack_t vto [ MAX_PARAMETERS ] ;\n char * endpos [ MAX_PARAMETERS ] ;\n char * * end ;\n char work [ BUFFSIZE ] ;\n va_stack_t * p ;\n char * workend = & work [ sizeof ( work ) - 2 ] ;\n if ( dprintf_Pass1 ( format , vto , endpos , ap_save ) ) return - 1 ;\n end = & endpos [ 0 ] ;\n f = ( char * ) format ;\n while ( * f != '\\0' ) {\n int is_alt ;\n long width ;\n long prec ;\n int is_neg ;\n long base ;\n mp_uintmax_t num ;\n mp_intmax_t signed_num ;\n char * w ;\n if ( * f != '%' ) {\n do {\n OUTCHAR ( * f ) ;\n }\n while ( * ++ f && ( '%' != * f ) ) ;\n continue ;\n }\n ++ f ;\n if ( * f == '%' ) {\n ++ f ;\n OUTCHAR ( '%' ) ;\n continue ;\n }\n param = dprintf_DollarString ( f , & f ) ;\n if ( ! param ) param = param_num ;\n else -- param ;\n param_num ++ ;\n p = & vto [ param ] ;\n if ( p -> flags & FLAGS_WIDTHPARAM ) {\n width = ( long ) vto [ p -> width ] . data . num . as_signed ;\n param_num ++ ;\n if ( width < 0 ) {\n width = - width ;\n p -> flags |= FLAGS_LEFT ;\n p -> flags &= ~ FLAGS_PAD_NIL ;\n }\n }\n else width = p -> width ;\n if ( p -> flags & FLAGS_PRECPARAM ) {\n prec = ( long ) vto [ p -> precision ] . data . num . as_signed ;\n param_num ++ ;\n if ( prec < 0 ) prec = - 1 ;\n }\n else if ( p -> flags & FLAGS_PREC ) prec = p -> precision ;\n else prec = - 1 ;\n is_alt = ( p -> flags & FLAGS_ALT ) ? 1 : 0 ;\n switch ( p -> type ) {\n case FORMAT_INT : num = p -> data . num . as_unsigned ;\n if ( p -> flags & FLAGS_CHAR ) {\n if ( ! ( p -> flags & FLAGS_LEFT ) ) while ( -- width > 0 ) OUTCHAR ( ' ' ) ;\n OUTCHAR ( ( char ) num ) ;\n if ( p -> flags & FLAGS_LEFT ) while ( -- width > 0 ) OUTCHAR ( ' ' ) ;\n break ;\n }\n if ( p -> flags & FLAGS_OCTAL ) {\n base = 8 ;\n goto unsigned_number ;\n }\n else if ( p -> flags & FLAGS_HEX ) {\n digits = ( p -> flags & FLAGS_UPPER ) ? upper_digits : lower_digits ;\n base = 16 ;\n goto unsigned_number ;\n }\n else if ( p -> flags & FLAGS_UNSIGNED ) {\n base = 10 ;\n goto unsigned_number ;\n }\n base = 10 ;\n is_neg = ( p -> data . num . as_signed < ( mp_intmax_t ) 0 ) ? 1 : 0 ;\n if ( is_neg ) {\n signed_num = p -> data . num . as_signed + ( mp_intmax_t ) 1 ;\n signed_num = - signed_num ;\n num = ( mp_uintmax_t ) signed_num ;\n num += ( mp_uintmax_t ) 1 ;\n }\n goto number ;\n unsigned_number : is_neg = 0 ;\n number : if ( prec == - 1 ) prec = 1 ;\n w = workend ;\n while ( num > 0 ) {\n * w -- = digits [ num % base ] ;\n num /= base ;\n }\n width -= ( long ) ( workend - w ) ;\n prec -= ( long ) ( workend - w ) ;\n if ( is_alt && base == 8 && prec <= 0 ) {\n * w -- = '0' ;\n -- width ;\n }\n if ( prec > 0 ) {\n width -= prec ;\n while ( prec -- > 0 ) * w -- = '0' ;\n }\n if ( is_alt && base == 16 ) width -= 2 ;\n if ( is_neg || ( p -> flags & FLAGS_SHOWSIGN ) || ( p -> flags & FLAGS_SPACE ) ) -- width ;\n if ( ! ( p -> flags & FLAGS_LEFT ) && ! ( p -> flags & FLAGS_PAD_NIL ) ) while ( width -- > 0 ) OUTCHAR ( ' ' ) ;\n if ( is_neg ) OUTCHAR ( '-' ) ;\n else if ( p -> flags & FLAGS_SHOWSIGN ) OUTCHAR ( '+' ) ;\n else if ( p -> flags & FLAGS_SPACE ) OUTCHAR ( ' ' ) ;\n if ( is_alt && base == 16 ) {\n OUTCHAR ( '0' ) ;\n if ( p -> flags & FLAGS_UPPER ) OUTCHAR ( 'X' ) ;\n else OUTCHAR ( 'x' ) ;\n }\n if ( ! ( p -> flags & FLAGS_LEFT ) && ( p -> flags & FLAGS_PAD_NIL ) ) while ( width -- > 0 ) OUTCHAR ( '0' ) ;\n while ( ++ w <= workend ) {\n OUTCHAR ( * w ) ;\n }\n if ( p -> flags & FLAGS_LEFT ) while ( width -- > 0 ) OUTCHAR ( ' ' ) ;\n break ;\n case FORMAT_STRING : {\n static const char null [ ] = \"(nil)\" ;\n const char * str ;\n size_t len ;\n str = ( char * ) p -> data . str ;\n if ( str == NULL ) {\n if ( prec == - 1 || prec >= ( long ) sizeof ( null ) - 1 ) {\n str = null ;\n len = sizeof ( null ) - 1 ;\n p -> flags &= ( ~ FLAGS_ALT ) ;\n }\n else {\n str = \"\" ;\n len = 0 ;\n }\n }\n else if ( prec != - 1 ) len = ( size_t ) prec ;\n else len = strlen ( str ) ;\n width -= ( len > LONG_MAX ) ? LONG_MAX : ( long ) len ;\n if ( p -> flags & FLAGS_ALT ) OUTCHAR ( '\"' ) ;\n if ( ! ( p -> flags & FLAGS_LEFT ) ) while ( width -- > 0 ) OUTCHAR ( ' ' ) ;\n while ( ( len -- > 0 ) && * str ) OUTCHAR ( * str ++ ) ;\n if ( p -> flags & FLAGS_LEFT ) while ( width -- > 0 ) OUTCHAR ( ' ' ) ;\n if ( p -> flags & FLAGS_ALT ) OUTCHAR ( '\"' ) ;\n }\n break ;\n case FORMAT_PTR : {\n void * ptr ;\n ptr = ( void * ) p -> data . ptr ;\n if ( ptr != NULL ) {\n base = 16 ;\n digits = ( p -> flags & FLAGS_UPPER ) ? upper_digits : lower_digits ;\n is_alt = 1 ;\n num = ( size_t ) ptr ;\n is_neg = 0 ;\n goto number ;\n }\n else {\n static const char strnil [ ] = \"(nil)\" ;\n const char * point ;\n width -= ( long ) ( sizeof ( strnil ) - 1 ) ;\n if ( p -> flags & FLAGS_LEFT ) while ( width -- > 0 ) OUTCHAR ( ' ' ) ;\n for ( point = strnil ;\n * point != '\\0' ;\n ++ point ) OUTCHAR ( * point ) ;\n if ( ! ( p -> flags & FLAGS_LEFT ) ) while ( width -- > 0 ) OUTCHAR ( ' ' ) ;\n }\n }\n break ;\n case FORMAT_DOUBLE : {\n char formatbuf [ 32 ] = \"%\" ;\n char * fptr = & formatbuf [ 1 ] ;\n size_t left = sizeof ( formatbuf ) - strlen ( formatbuf ) ;\n int len ;\n width = - 1 ;\n if ( p -> flags & FLAGS_WIDTH ) width = p -> width ;\n else if ( p -> flags & FLAGS_WIDTHPARAM ) width = ( long ) vto [ p -> width ] . data . num . as_signed ;\n prec = - 1 ;\n if ( p -> flags & FLAGS_PREC ) prec = p -> precision ;\n else if ( p -> flags & FLAGS_PRECPARAM ) prec = ( long ) vto [ p -> precision ] . data . num . as_signed ;\n if ( p -> flags & FLAGS_LEFT ) * fptr ++ = '-' ;\n if ( p -> flags & FLAGS_SHOWSIGN ) * fptr ++ = '+' ;\n if ( p -> flags & FLAGS_SPACE ) * fptr ++ = ' ' ;\n if ( p -> flags & FLAGS_ALT ) * fptr ++ = '#' ;\n * fptr = 0 ;\n if ( width >= 0 ) {\n len = curl_msnprintf ( fptr , left , \"%ld\" , width ) ;\n fptr += len ;\n left -= len ;\n }\n if ( prec >= 0 ) {\n len = curl_msnprintf ( fptr , left , \".%ld\" , prec ) ;\n fptr += len ;\n }\n if ( p -> flags & FLAGS_LONG ) * fptr ++ = 'l' ;\n if ( p -> flags & FLAGS_FLOATE ) * fptr ++ = ( char ) ( ( p -> flags & FLAGS_UPPER ) ? 'E' : 'e' ) ;\n else if ( p -> flags & FLAGS_FLOATG ) * fptr ++ = ( char ) ( ( p -> flags & FLAGS_UPPER ) ? 'G' : 'g' ) ;\n else * fptr ++ = 'f' ;\n * fptr = 0 ;\n ( sprintf ) ( work , formatbuf , p -> data . dnum ) ;\n for ( fptr = work ;\n * fptr ;\n fptr ++ ) OUTCHAR ( * fptr ) ;\n }\n break ;\n case FORMAT_INTPTR : # ifdef HAVE_LONG_LONG_TYPE if ( p -> flags & FLAGS_LONGLONG ) * ( LONG_LONG_TYPE * ) p -> data . ptr = ( LONG_LONG_TYPE ) done ;\n else # endif if ( p -> flags & FLAGS_LONG ) * ( long * ) p -> data . ptr = ( long ) done ;\n else if ( ! ( p -> flags & FLAGS_SHORT ) ) * ( int * ) p -> data . ptr = ( int ) done ;\n else * ( short * ) p -> data . ptr = ( short ) done ;\n break ;\n default : break ;\n }\n f = * end ++ ;\n }\n return done ;\n }", "idx": 960}
{"hash": -1335877942018854351, "project": "chrome", "size": 9, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( FastUnloadTest , MAYBE_WindowCloseAfterBeforeUnloadCrash ) {\n if ( base : : CommandLine : : ForCurrentProcess ( ) -> HasSwitch ( switches : : kSingleProcess ) ) return ;\n NavigateToDataURL ( BEFORE_UNLOAD_HTML , \"beforeunload\" ) ;\n content : : WebContents * beforeunload_contents = browser ( ) -> tab_strip_model ( ) -> GetActiveWebContents ( ) ;\n content : : WindowedNotificationObserver window_observer ( chrome : : NOTIFICATION_BROWSER_CLOSED , content : : NotificationService : : AllSources ( ) ) ;\n chrome : : CloseWindow ( browser ( ) ) ;\n CrashTab ( beforeunload_contents ) ;\n window_observer . Wait ( ) ;\n }", "idx": 961}
{"hash": -5673151078622202536, "project": "debian", "size": 4, "label": 0, "functionSource": "static uint32_t virtio_balloon_get_features ( VirtIODevice * vdev , uint32_t f ) {\n f |= ( 1 << VIRTIO_BALLOON_F_STATS_VQ ) ;\n return f ;\n }", "idx": 962}
{"hash": 7651945086108393719, "project": "debian", "size": 18, "label": 0, "functionSource": "int qemuMonitorJSONBlockResize ( qemuMonitorPtr mon , const char * device , unsigned long long size ) {\n int ret ;\n virJSONValuePtr cmd ;\n virJSONValuePtr reply = NULL ;\n cmd = qemuMonitorJSONMakeCommand ( \"block_resize\" , \"s:device\" , device , \"U:size\" , size * 1024 , NULL ) ;\n if ( ! cmd ) return - 1 ;\n ret = qemuMonitorJSONCommand ( mon , cmd , & reply ) ;\n if ( ret == 0 ) {\n if ( qemuMonitorJSONHasError ( reply , \"CommandNotFound\" ) ) {\n ret = - 2 ;\n goto cleanup ;\n }\n ret = qemuMonitorJSONCheckError ( cmd , reply ) ;\n }\n cleanup : virJSONValueFree ( cmd ) ;\n virJSONValueFree ( reply ) ;\n return ret ;\n }", "idx": 963}
{"hash": -7811574867662618708, "project": "debian", "size": 5, "label": 1, "functionSource": "static void finish_object ( struct object * obj , const struct name_path * path , const char * name , void * cb_data ) {\n struct rev_list_info * info = cb_data ;\n if ( obj -> type == OBJ_BLOB && ! has_object_file ( & obj -> oid ) ) die ( \"missing blob object '%s'\" , oid_to_hex ( & obj -> oid ) ) ;\n if ( info -> revs -> verify_objects && ! obj -> parsed && obj -> type != OBJ_COMMIT ) parse_object ( obj -> oid . hash ) ;\n }", "idx": 964}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_RSVPParameters ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_RSVPParameters , RSVPParameters_sequence ) ;\n return offset ;\n }", "idx": 965}
{"hash": -1929262071302712016, "project": "debian", "size": 48, "label": 0, "functionSource": "static void * Type_Text_Description_Read ( struct _cms_typehandler_struct * self , cmsIOHANDLER * io , cmsUInt32Number * nItems , cmsUInt32Number SizeOfTag ) {\n char * Text = NULL ;\n cmsMLU * mlu = NULL ;\n cmsUInt32Number AsciiCount ;\n cmsUInt32Number i , UnicodeCode , UnicodeCount ;\n cmsUInt16Number ScriptCodeCode , Dummy ;\n cmsUInt8Number ScriptCodeCount ;\n * nItems = 0 ;\n if ( SizeOfTag < sizeof ( cmsUInt32Number ) ) return NULL ;\n if ( ! _cmsReadUInt32Number ( io , & AsciiCount ) ) return NULL ;\n SizeOfTag -= sizeof ( cmsUInt32Number ) ;\n if ( SizeOfTag < AsciiCount ) return NULL ;\n mlu = cmsMLUalloc ( self -> ContextID , 1 ) ;\n if ( mlu == NULL ) return NULL ;\n Text = ( char * ) _cmsMalloc ( self -> ContextID , AsciiCount + 1 ) ;\n if ( Text == NULL ) goto Error ;\n if ( io -> Read ( io , Text , sizeof ( char ) , AsciiCount ) != AsciiCount ) goto Error ;\n SizeOfTag -= AsciiCount ;\n Text [ AsciiCount ] = 0 ;\n if ( ! cmsMLUsetASCII ( mlu , cmsNoLanguage , cmsNoCountry , Text ) ) goto Error ;\n _cmsFree ( self -> ContextID , ( void * ) Text ) ;\n Text = NULL ;\n if ( SizeOfTag < 2 * sizeof ( cmsUInt32Number ) ) goto Done ;\n if ( ! _cmsReadUInt32Number ( io , & UnicodeCode ) ) goto Done ;\n if ( ! _cmsReadUInt32Number ( io , & UnicodeCount ) ) goto Done ;\n SizeOfTag -= 2 * sizeof ( cmsUInt32Number ) ;\n if ( SizeOfTag < UnicodeCount * sizeof ( cmsUInt16Number ) ) goto Done ;\n for ( i = 0 ;\n i < UnicodeCount ;\n i ++ ) {\n if ( ! io -> Read ( io , & Dummy , sizeof ( cmsUInt16Number ) , 1 ) ) goto Done ;\n }\n SizeOfTag -= UnicodeCount * sizeof ( cmsUInt16Number ) ;\n if ( SizeOfTag >= sizeof ( cmsUInt16Number ) + sizeof ( cmsUInt8Number ) + 67 ) {\n if ( ! _cmsReadUInt16Number ( io , & ScriptCodeCode ) ) goto Done ;\n if ( ! _cmsReadUInt8Number ( io , & ScriptCodeCount ) ) goto Done ;\n for ( i = 0 ;\n i < 67 ;\n i ++ ) {\n if ( ! io -> Read ( io , & Dummy , sizeof ( cmsUInt8Number ) , 1 ) ) goto Error ;\n }\n }\n Done : * nItems = 1 ;\n return mlu ;\n Error : if ( Text ) _cmsFree ( self -> ContextID , ( void * ) Text ) ;\n if ( mlu ) cmsMLUfree ( mlu ) ;\n return NULL ;\n }", "idx": 966}
{"hash": 6250095321513210169, "project": "debian", "size": 24, "label": 0, "functionSource": "void rfbSendServerCutText ( rfbScreenInfoPtr rfbScreen , char * str , int len ) {\n rfbClientPtr cl ;\n rfbServerCutTextMsg sct ;\n rfbClientIteratorPtr iterator ;\n iterator = rfbGetClientIterator ( rfbScreen ) ;\n while ( ( cl = rfbClientIteratorNext ( iterator ) ) != NULL ) {\n sct . type = rfbServerCutText ;\n sct . length = Swap32IfLE ( len ) ;\n LOCK ( cl -> sendMutex ) ;\n if ( rfbWriteExact ( cl , ( char * ) & sct , sz_rfbServerCutTextMsg ) < 0 ) {\n rfbLogPerror ( \"rfbSendServerCutText: write\" ) ;\n rfbCloseClient ( cl ) ;\n UNLOCK ( cl -> sendMutex ) ;\n continue ;\n }\n if ( rfbWriteExact ( cl , str , len ) < 0 ) {\n rfbLogPerror ( \"rfbSendServerCutText: write\" ) ;\n rfbCloseClient ( cl ) ;\n }\n UNLOCK ( cl -> sendMutex ) ;\n rfbStatRecordMessageSent ( cl , rfbServerCutText , sz_rfbServerCutTextMsg + len , sz_rfbServerCutTextMsg + len ) ;\n }\n rfbReleaseClientIterator ( iterator ) ;\n }", "idx": 967}
{"hash": -7555034601056330007, "project": "debian", "size": 6, "label": 0, "functionSource": "void virLogOutputFree ( virLogOutputPtr output ) {\n if ( ! output ) return ;\n if ( output -> c ) output -> c ( output -> data ) ;\n VIR_FREE ( output -> name ) ;\n VIR_FREE ( output ) ;\n }", "idx": 968}
{"hash": -1493847185972313035, "project": "debian", "size": 10, "label": 0, "functionSource": "void av_image_copy_plane ( uint8_t * dst , int dst_linesize , const uint8_t * src , int src_linesize , int bytewidth , int height ) {\n if ( ! dst || ! src ) return ;\n for ( ;\n height > 0 ;\n height -- ) {\n memcpy ( dst , src , bytewidth ) ;\n dst += dst_linesize ;\n src += src_linesize ;\n }\n }", "idx": 969}
{"hash": 9009378236683657160, "project": "debian", "size": 140, "label": 0, "functionSource": "int su_main ( int argc , char * * argv , int mode ) {\n int optc ;\n const char * new_user = DEFAULT_USER , * runuser_user = NULL ;\n char * command = NULL ;\n int request_same_session = 0 ;\n char * shell = NULL ;\n struct passwd * pw ;\n struct passwd pw_copy ;\n gid_t * groups = NULL ;\n size_t ngroups = 0 ;\n bool use_supp = false ;\n bool use_gid = false ;\n gid_t gid = 0 ;\n static const struct option longopts [ ] = {\n {\n \"command\" , required_argument , NULL , 'c' }\n , {\n \"session-command\" , required_argument , NULL , 'C' }\n , {\n \"fast\" , no_argument , NULL , 'f' }\n , {\n \"login\" , no_argument , NULL , 'l' }\n , {\n \"preserve-environment\" , no_argument , NULL , 'p' }\n , {\n \"shell\" , required_argument , NULL , 's' }\n , {\n \"group\" , required_argument , NULL , 'g' }\n , {\n \"supp-group\" , required_argument , NULL , 'G' }\n , {\n \"user\" , required_argument , NULL , 'u' }\n , {\n \"help\" , no_argument , 0 , 'h' }\n , {\n \"version\" , no_argument , 0 , 'V' }\n , {\n NULL , 0 , NULL , 0 }\n }\n ;\n setlocale ( LC_ALL , \"\" ) ;\n bindtextdomain ( PACKAGE , LOCALEDIR ) ;\n textdomain ( PACKAGE ) ;\n atexit ( close_stdout ) ;\n su_mode = mode ;\n fast_startup = false ;\n simulate_login = false ;\n change_environment = true ;\n while ( ( optc = getopt_long ( argc , argv , \"c:fg:G:lmps:u:hV\" , longopts , NULL ) ) != - 1 ) {\n switch ( optc ) {\n case 'c' : command = optarg ;\n break ;\n case 'C' : command = optarg ;\n request_same_session = 1 ;\n break ;\n case 'f' : fast_startup = true ;\n break ;\n case 'g' : use_gid = true ;\n gid = add_supp_group ( optarg , & groups , & ngroups ) ;\n break ;\n case 'G' : use_supp = true ;\n add_supp_group ( optarg , & groups , & ngroups ) ;\n break ;\n case 'l' : simulate_login = true ;\n break ;\n case 'm' : case 'p' : change_environment = false ;\n break ;\n case 's' : shell = optarg ;\n break ;\n case 'u' : if ( su_mode != RUNUSER_MODE ) usage ( EXIT_FAILURE ) ;\n runuser_user = optarg ;\n break ;\n case 'h' : usage ( 0 ) ;\n case 'V' : printf ( UTIL_LINUX_VERSION ) ;\n exit ( EXIT_SUCCESS ) ;\n default : errtryhelp ( EXIT_FAILURE ) ;\n }\n }\n restricted = evaluate_uid ( ) ;\n if ( optind < argc && ! strcmp ( argv [ optind ] , \"-\" ) ) {\n simulate_login = true ;\n ++ optind ;\n }\n if ( simulate_login && ! change_environment ) {\n warnx ( _ ( \"ignoring --preserve-environment, it's mutually exclusive with --login\" ) ) ;\n change_environment = true ;\n }\n switch ( su_mode ) {\n case RUNUSER_MODE : if ( runuser_user ) {\n new_user = runuser_user ;\n if ( shell || fast_startup || command || simulate_login ) {\n errx ( EXIT_FAILURE , _ ( \"options --{\nshell,fast,command,session-command,login}\n and \" \"--user are mutually exclusive\" ) ) ;\n }\n if ( optind == argc ) errx ( EXIT_FAILURE , _ ( \"no command was specified\" ) ) ;\n break ;\n }\n case SU_MODE : if ( optind < argc ) new_user = argv [ optind ++ ] ;\n break ;\n }\n if ( ( use_supp || use_gid ) && restricted ) errx ( EXIT_FAILURE , _ ( \"only root can specify alternative groups\" ) ) ;\n logindefs_load_defaults = load_config ;\n pw = getpwnam ( new_user ) ;\n if ( ! ( pw && pw -> pw_name && pw -> pw_name [ 0 ] && pw -> pw_dir && pw -> pw_dir [ 0 ] && pw -> pw_passwd ) ) errx ( EXIT_FAILURE , _ ( \"user %s does not exist\" ) , new_user ) ;\n pw_copy = * pw ;\n pw = & pw_copy ;\n pw -> pw_name = xstrdup ( pw -> pw_name ) ;\n pw -> pw_passwd = xstrdup ( pw -> pw_passwd ) ;\n pw -> pw_dir = xstrdup ( pw -> pw_dir ) ;\n pw -> pw_shell = xstrdup ( pw -> pw_shell && pw -> pw_shell [ 0 ] ? pw -> pw_shell : DEFAULT_SHELL ) ;\n endpwent ( ) ;\n if ( use_supp && ! use_gid ) pw -> pw_gid = groups [ 0 ] ;\n else if ( use_gid ) pw -> pw_gid = gid ;\n authenticate ( pw ) ;\n if ( request_same_session || ! command || ! pw -> pw_uid ) same_session = 1 ;\n if ( runuser_user ) {\n shell = NULL ;\n }\n else {\n if ( ! shell && ! change_environment ) shell = getenv ( \"SHELL\" ) ;\n if ( shell && getuid ( ) != 0 && restricted_shell ( pw -> pw_shell ) ) {\n warnx ( _ ( \"using restricted shell %s\" ) , pw -> pw_shell ) ;\n shell = NULL ;\n }\n shell = xstrdup ( shell ? shell : pw -> pw_shell ) ;\n }\n init_groups ( pw , groups , ngroups ) ;\n if ( ! simulate_login || command ) suppress_pam_info = 1 ;\n create_watching_parent ( ) ;\n change_identity ( pw ) ;\n if ( ! same_session ) setsid ( ) ;\n modify_environment ( pw , shell ) ;\n if ( simulate_login && chdir ( pw -> pw_dir ) != 0 ) warn ( _ ( \"warning: cannot change directory to %s\" ) , pw -> pw_dir ) ;\n if ( shell ) run_shell ( shell , command , argv + optind , max ( 0 , argc - optind ) ) ;\n else {\n execvp ( argv [ optind ] , & argv [ optind ] ) ;\n err ( EXIT_FAILURE , _ ( \"failed to execute %s\" ) , argv [ optind ] ) ;\n }\n }", "idx": 970}
{"hash": -769658847024738738, "project": "debian", "size": 6, "label": 0, "functionSource": "static gpgme_error_t default_inq_cb ( engine_uiserver_t uiserver , const char * line ) {\n if ( ! strncmp ( line , \"PINENTRY_LAUNCHED\" , 17 ) && ( line [ 17 ] == ' ' || ! line [ 17 ] ) ) {\n _gpgme_allow_set_foreground_window ( ( pid_t ) strtoul ( line + 17 , NULL , 10 ) ) ;\n }\n return 0 ;\n }", "idx": 971}
{"hash": 6869501901408584645, "project": "chrome", "size": 6, "label": 0, "functionSource": "static void print_md5 ( FILE * stream , unsigned char digest [ 16 ] ) {\n int i ;\n for ( i = 0 ;\n i < 16 ;\n ++ i ) fprintf ( stream , \"%02x\" , digest [ i ] ) ;\n }", "idx": 972}
{"hash": -7076754245473579218, "project": "chrome", "size": 3, "label": 0, "functionSource": "void evhttp_set_timeout ( struct evhttp * http , int timeout_in_secs ) {\n http -> timeout = timeout_in_secs ;\n }", "idx": 973}
{"hash": 5737086831275946085, "project": "debian", "size": 20, "label": 0, "functionSource": "static int decode_subpacket ( COOKContext * q , COOKSubpacket * p , const uint8_t * inbuffer , float * * outbuffer ) {\n int sub_packet_size = p -> size ;\n int res ;\n memset ( q -> decode_buffer_1 , 0 , sizeof ( q -> decode_buffer_1 ) ) ;\n decode_bytes_and_gain ( q , p , inbuffer , & p -> gains1 ) ;\n if ( p -> joint_stereo ) {\n if ( ( res = joint_decode ( q , p , q -> decode_buffer_1 , q -> decode_buffer_2 ) ) < 0 ) return res ;\n }\n else {\n if ( ( res = mono_decode ( q , p , q -> decode_buffer_1 ) ) < 0 ) return res ;\n if ( p -> num_channels == 2 ) {\n decode_bytes_and_gain ( q , p , inbuffer + sub_packet_size / 2 , & p -> gains2 ) ;\n if ( ( res = mono_decode ( q , p , q -> decode_buffer_2 ) ) < 0 ) return res ;\n }\n }\n mlt_compensate_output ( q , q -> decode_buffer_1 , & p -> gains1 , p -> mono_previous_buffer1 , outbuffer ? outbuffer [ p -> ch_idx ] : NULL ) ;\n if ( p -> num_channels == 2 ) if ( p -> joint_stereo ) mlt_compensate_output ( q , q -> decode_buffer_2 , & p -> gains1 , p -> mono_previous_buffer2 , outbuffer ? outbuffer [ p -> ch_idx + 1 ] : NULL ) ;\n else mlt_compensate_output ( q , q -> decode_buffer_2 , & p -> gains2 , p -> mono_previous_buffer2 , outbuffer ? outbuffer [ p -> ch_idx + 1 ] : NULL ) ;\n return 0 ;\n }", "idx": 974}
{"hash": 8472707559856742945, "project": "debian", "size": 22, "label": 0, "functionSource": "static void gen_vector_table24 ( TrueMotion1Context * s , const uint8_t * sel_vector_table ) {\n int len , i , j ;\n unsigned char delta_pair ;\n for ( i = 0 ;\n i < 1024 ;\n i += 4 ) {\n len = * sel_vector_table ++ / 2 ;\n for ( j = 0 ;\n j < len ;\n j ++ ) {\n delta_pair = * sel_vector_table ++ ;\n s -> y_predictor_table [ i + j ] = 0xfffffffe & make_ydt24_entry ( delta_pair >> 4 , delta_pair & 0xf , s -> ydt ) ;\n s -> c_predictor_table [ i + j ] = 0xfffffffe & make_cdt24_entry ( delta_pair >> 4 , delta_pair & 0xf , s -> cdt ) ;\n s -> fat_y_predictor_table [ i + j ] = 0xfffffffe & make_ydt24_entry ( delta_pair >> 4 , delta_pair & 0xf , s -> fat_ydt ) ;\n s -> fat_c_predictor_table [ i + j ] = 0xfffffffe & make_cdt24_entry ( delta_pair >> 4 , delta_pair & 0xf , s -> fat_cdt ) ;\n }\n s -> y_predictor_table [ i + ( j - 1 ) ] |= 1 ;\n s -> c_predictor_table [ i + ( j - 1 ) ] |= 1 ;\n s -> fat_y_predictor_table [ i + ( j - 1 ) ] |= 1 ;\n s -> fat_c_predictor_table [ i + ( j - 1 ) ] |= 1 ;\n }\n }", "idx": 975}
{"hash": 6249489553242542670, "project": "debian", "size": 9, "label": 0, "functionSource": "nic_rule_node * create_nic_rule_node ( int match_class , char * if_name , int action ) {\n nic_rule_node * my_node ;\n NTP_REQUIRE ( match_class != 0 || if_name != NULL ) ;\n my_node = emalloc_zero ( sizeof ( * my_node ) ) ;\n my_node -> match_class = match_class ;\n my_node -> if_name = if_name ;\n my_node -> action = action ;\n return my_node ;\n }", "idx": 976}
{"hash": 4876100961671882393, "project": "debian", "size": 10, "label": 0, "functionSource": "static int dissect_pvfs2_truncate_request ( tvbuff_t * tvb , proto_tree * tree , int offset , packet_info * pinfo ) {\n offset = dissect_pvfs_fh ( tvb , offset , pinfo , tree , \"handle\" , NULL ) ;\n offset = dissect_pvfs_fs_id ( tvb , tree , offset ) ;\n offset += 4 ;\n proto_tree_add_item ( tree , hf_pvfs_size , tvb , offset , 8 , ENC_LITTLE_ENDIAN ) ;\n offset += 8 ;\n proto_tree_add_item ( tree , hf_pvfs_truncate_request_flags , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n return offset ;\n }", "idx": 977}
{"hash": -1338403456839869183, "project": "debian", "size": 8, "label": 0, "functionSource": "static void dissect_q931_cug_ie ( tvbuff_t * tvb , int offset , int len , proto_tree * tree ) {\n if ( len == 0 ) return ;\n proto_tree_add_item ( tree , hf_q931_cug_indication , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n offset += 1 ;\n len -= 1 ;\n if ( len == 0 ) return ;\n proto_tree_add_item ( tree , hf_q931_cug_index_code , tvb , offset , len , ENC_NA | ENC_ASCII ) ;\n }", "idx": 978}
{"hash": 1223258652239369123, "project": "debian", "size": 20, "label": 0, "functionSource": "SPL_METHOD ( SplFileInfo , getBasename ) {\n spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n char * fname , * suffix = 0 ;\n size_t flen ;\n int slen = 0 , path_len ;\n if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , \"|s\" , & suffix , & slen ) == FAILURE ) {\n return ;\n }\n spl_filesystem_object_get_path ( intern , & path_len TSRMLS_CC ) ;\n if ( path_len && path_len < intern -> file_name_len ) {\n fname = intern -> file_name + path_len + 1 ;\n flen = intern -> file_name_len - ( path_len + 1 ) ;\n }\n else {\n fname = intern -> file_name ;\n flen = intern -> file_name_len ;\n }\n php_basename ( fname , flen , suffix , slen , & fname , & flen TSRMLS_CC ) ;\n RETURN_STRINGL ( fname , flen , 0 ) ;\n }", "idx": 979}
{"hash": -6552851419396579257, "project": "debian", "size": 9, "label": 0, "functionSource": "static int SpoolssSetJob_q ( tvbuff_t * tvb , int offset , packet_info * pinfo , proto_tree * tree , dcerpc_info * di , guint8 * drep ) {\n guint32 jobid , cmd ;\n offset = dissect_nt_policy_hnd ( tvb , offset , pinfo , tree , di , drep , hf_hnd , NULL , NULL , FALSE , FALSE ) ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , tree , di , drep , hf_job_id , & jobid ) ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , tree , di , drep , hf_level , NULL ) ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , tree , di , drep , hf_setjob_cmd , & cmd ) ;\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \", %s jobid %d\" , val_to_str ( cmd , setjob_commands , \"Unknown (%d)\" ) , jobid ) ;\n return offset ;\n }", "idx": 980}
{"hash": -7855974557509681261, "project": "debian", "size": 12, "label": 0, "functionSource": "char * get_namespace_name ( Oid nspid ) {\n HeapTuple tp ;\n tp = SearchSysCache1 ( NAMESPACEOID , ObjectIdGetDatum ( nspid ) ) ;\n if ( HeapTupleIsValid ( tp ) ) {\n Form_pg_namespace nsptup = ( Form_pg_namespace ) GETSTRUCT ( tp ) ;\n char * result ;\n result = pstrdup ( NameStr ( nsptup -> nspname ) ) ;\n ReleaseSysCache ( tp ) ;\n return result ;\n }\n else return NULL ;\n }", "idx": 981}
{"hash": 8218188955508624394, "project": "debian", "size": 10, "label": 0, "functionSource": "static inline int32_t calculate_sign_huff ( MLPDecodeContext * m , unsigned int substr , unsigned int ch ) {\n SubStream * s = & m -> substream [ substr ] ;\n ChannelParams * cp = & s -> channel_params [ ch ] ;\n int lsb_bits = cp -> huff_lsbs - s -> quant_step_size [ ch ] ;\n int sign_shift = lsb_bits + ( cp -> codebook ? 2 - cp -> codebook : - 1 ) ;\n int32_t sign_huff_offset = cp -> huff_offset ;\n if ( cp -> codebook > 0 ) sign_huff_offset -= 7 << lsb_bits ;\n if ( sign_shift >= 0 ) sign_huff_offset -= 1 << sign_shift ;\n return sign_huff_offset ;\n }", "idx": 982}
{"hash": 2820551931453396101, "project": "debian", "size": 29, "label": 0, "functionSource": "static jas_image_cmpt_t * jas_image_cmpt_copy ( jas_image_cmpt_t * cmpt ) {\n jas_image_cmpt_t * newcmpt ;\n if ( ! ( newcmpt = jas_image_cmpt_create0 ( ) ) ) {\n return 0 ;\n }\n newcmpt -> tlx_ = cmpt -> tlx_ ;\n newcmpt -> tly_ = cmpt -> tly_ ;\n newcmpt -> hstep_ = cmpt -> hstep_ ;\n newcmpt -> vstep_ = cmpt -> vstep_ ;\n newcmpt -> width_ = cmpt -> width_ ;\n newcmpt -> height_ = cmpt -> height_ ;\n newcmpt -> prec_ = cmpt -> prec_ ;\n newcmpt -> sgnd_ = cmpt -> sgnd_ ;\n newcmpt -> cps_ = cmpt -> cps_ ;\n newcmpt -> type_ = cmpt -> type_ ;\n if ( ! ( newcmpt -> stream_ = jas_stream_memopen ( 0 , 0 ) ) ) {\n return 0 ;\n }\n if ( jas_stream_seek ( cmpt -> stream_ , 0 , SEEK_SET ) ) {\n return 0 ;\n }\n if ( jas_stream_copy ( newcmpt -> stream_ , cmpt -> stream_ , - 1 ) ) {\n return 0 ;\n }\n if ( jas_stream_seek ( newcmpt -> stream_ , 0 , SEEK_SET ) ) {\n return 0 ;\n }\n return newcmpt ;\n }", "idx": 983}
{"hash": -7455544248455991006, "project": "debian", "size": 11, "label": 0, "functionSource": "static struct kvm_cpuid_entry2 * cpuid_find_entry ( struct kvm_cpuid2 * cpuid , uint32_t function , uint32_t index ) {\n int i ;\n for ( i = 0 ;\n i < cpuid -> nent ;\n ++ i ) {\n if ( cpuid -> entries [ i ] . function == function && cpuid -> entries [ i ] . index == index ) {\n return & cpuid -> entries [ i ] ;\n }\n }\n return NULL ;\n }", "idx": 984}
{"hash": -8562506069584692324, "project": "chrome", "size": 33, "label": 1, "functionSource": "TEST_F ( MultiBufferTest , RandomTest ) {\n size_t file_size = 1000000 ;\n multibuffer_ . SetFileSize ( file_size ) ;\n multibuffer_ . SetMaxBlocksAfterDefer ( 10 ) ;\n std : : vector < ReadHelper * > read_helpers ;\n for ( size_t i = 0 ;\n i < 20 ;\n i ++ ) {\n read_helpers . push_back ( new ReadHelper ( file_size , 1000 , & multibuffer_ , & rnd_ ) ) ;\n }\n for ( int i = 0 ;\n i < 100 ;\n i ++ ) {\n for ( int j = 0 ;\n j < 100 ;\n j ++ ) {\n if ( rnd_ . Rand ( ) & 1 ) {\n if ( ! media : : writers . empty ( ) ) Advance ( ) ;\n }\n else {\n size_t j = rnd_ . Rand ( ) % read_helpers . size ( ) ;\n if ( rnd_ . Rand ( ) % 100 < 3 ) read_helpers [ j ] -> Seek ( ) ;\n read_helpers [ j ] -> StartRead ( ) ;\n }\n }\n multibuffer_ . CheckLRUState ( ) ;\n }\n multibuffer_ . CheckPresentState ( ) ;\n while ( ! read_helpers . empty ( ) ) {\n delete read_helpers . back ( ) ;\n read_helpers . pop_back ( ) ;\n }\n }", "idx": 985}
{"hash": 1312888211311686952, "project": "debian", "size": 18, "label": 0, "functionSource": "static lbmpdm_definition_t * lbmpdm_definition_add ( guint64 channel , guint32 id , guint8 version_major , guint8 version_minor ) {\n lbmpdm_definition_t * entry = NULL ;\n guint32 keyval [ LBMPDM_DEFINITION_KEY_ELEMENT_COUNT ] ;\n wmem_tree_key_t tkey [ 2 ] ;\n entry = lbmpdm_definition_find ( channel , id , version_major , version_minor ) ;\n if ( entry != NULL ) {\n return ( entry ) ;\n }\n entry = wmem_new ( wmem_file_scope ( ) , lbmpdm_definition_t ) ;\n entry -> channel = channel ;\n entry -> id = id ;\n entry -> vers_major = version_major ;\n entry -> vers_minor = version_minor ;\n entry -> field_list = wmem_tree_new ( wmem_file_scope ( ) ) ;\n lbmpdm_definition_build_key ( keyval , tkey , channel , id , version_major , version_minor ) ;\n wmem_tree_insert32_array ( lbmpdm_definition_table , tkey , ( void * ) entry ) ;\n return ( entry ) ;\n }", "idx": 986}
{"hash": 3599206110384554647, "project": "debian", "size": 36, "label": 1, "functionSource": "static ossl_inline t2 * sk_ ## t1 ## _shift ( STACK_OF ( t1 ) * sk ) {\n return ( t2 * ) OPENSSL_sk_shift ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline void sk_ ## t1 ## _pop_free ( STACK_OF ( t1 ) * sk , sk_ ## t1 ## _freefunc freefunc ) {\n OPENSSL_sk_pop_free ( ( OPENSSL_STACK * ) sk , ( OPENSSL_sk_freefunc ) freefunc ) ;\n }\n static ossl_inline int sk_ ## t1 ## _insert ( STACK_OF ( t1 ) * sk , t2 * ptr , int idx ) {\n return OPENSSL_sk_insert ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr , idx ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _set ( STACK_OF ( t1 ) * sk , int idx , t2 * ptr ) {\n return ( t2 * ) OPENSSL_sk_set ( ( OPENSSL_STACK * ) sk , idx , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _find ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_find ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _find_ex ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_find_ex ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline void sk_ ## t1 ## _sort ( STACK_OF ( t1 ) * sk ) {\n OPENSSL_sk_sort ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline int sk_ ## t1 ## _is_sorted ( const STACK_OF ( t1 ) * sk ) {\n return OPENSSL_sk_is_sorted ( ( const OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _dup ( const STACK_OF ( t1 ) * sk ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_dup ( ( const OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _deep_copy ( const STACK_OF ( t1 ) * sk , sk_ ## t1 ## _copyfunc copyfunc , sk_ ## t1 ## _freefunc freefunc ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_deep_copy ( ( const OPENSSL_STACK * ) sk , ( OPENSSL_sk_copyfunc ) copyfunc , ( OPENSSL_sk_freefunc ) freefunc ) ;\n }\n static ossl_inline sk_ ## t1 ## _compfunc sk_ ## t1 ## _set_cmp_func ( STACK_OF ( t1 ) * sk , sk_ ## t1 ## _compfunc compare ) {\n return ( sk_ ## t1 ## _compfunc ) OPENSSL_sk_set_cmp_func ( ( OPENSSL_STACK * ) sk , ( OPENSSL_sk_compfunc ) compare ) ;\n }\n # define DEFINE_SPECIAL_STACK_OF ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , t2 , t2 ) # define DEFINE_STACK_OF ( t ) SKM_DEFINE_STACK_OF ( t , t , t ) # define DEFINE_SPECIAL_STACK_OF_CONST ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , const t2 , t2 ) # define DEFINE_STACK_OF_CONST ( t ) SKM_DEFINE_STACK_OF ( t , const t , t ) typedef char * OPENSSL_STRING ;\n typedef const char * OPENSSL_CSTRING ;\n DEFINE_SPECIAL_STACK_OF ( OPENSSL_STRING , char ) DEFINE_SPECIAL_STACK_OF_CONST ( OPENSSL_CSTRING , char )", "idx": 987}
{"hash": -8884965407551053630, "project": "debian", "size": 12, "label": 0, "functionSource": "static mtime_t DecoderGetDisplayDate ( decoder_t * p_dec , mtime_t i_ts ) {\n decoder_owner_sys_t * p_owner = p_dec -> p_owner ;\n vlc_mutex_lock ( & p_owner -> lock ) ;\n if ( p_owner -> b_waiting || p_owner -> b_paused ) i_ts = VLC_TS_INVALID ;\n vlc_mutex_unlock ( & p_owner -> lock ) ;\n if ( ! p_owner -> p_clock || i_ts <= VLC_TS_INVALID ) return i_ts ;\n if ( input_clock_ConvertTS ( VLC_OBJECT ( p_dec ) , p_owner -> p_clock , NULL , & i_ts , NULL , INT64_MAX ) ) {\n msg_Err ( p_dec , \"Could not get display date for timestamp %\" PRId64 \"\" , i_ts ) ;\n return VLC_TS_INVALID ;\n }\n return i_ts ;\n }", "idx": 988}
{"hash": 378220832151730865, "project": "debian", "size": 32, "label": 0, "functionSource": "static int qemuMonitorTextCommandWithHandler ( qemuMonitorPtr mon , const char * cmd , qemuMonitorPasswordHandler passwordHandler , void * passwordOpaque , int scm_fd , char * * reply ) {\n int ret ;\n qemuMonitorMessage msg ;\n * reply = NULL ;\n memset ( & msg , 0 , sizeof msg ) ;\n if ( virAsprintf ( & msg . txBuffer , \"%s\\r\" , cmd ) < 0 ) {\n virReportOOMError ( ) ;\n return - 1 ;\n }\n msg . txLength = strlen ( msg . txBuffer ) ;\n msg . txFD = scm_fd ;\n msg . passwordHandler = passwordHandler ;\n msg . passwordOpaque = passwordOpaque ;\n VIR_DEBUG ( \"Send command '%s' for write with FD %d\" , cmd , scm_fd ) ;\n ret = qemuMonitorSend ( mon , & msg ) ;\n VIR_DEBUG ( \"Receive command reply ret=%d rxLength=%d rxBuffer='%s'\" , ret , msg . rxLength , msg . rxBuffer ) ;\n memset ( msg . txBuffer , 0 , msg . txLength ) ;\n VIR_FREE ( msg . txBuffer ) ;\n if ( ret >= 0 ) {\n if ( msg . rxBuffer ) {\n * reply = msg . rxBuffer ;\n }\n else {\n * reply = strdup ( \"\" ) ;\n if ( ! * reply ) {\n virReportOOMError ( ) ;\n return - 1 ;\n }\n }\n }\n return ret ;\n }", "idx": 989}
{"hash": -3299391226809811274, "project": "debian", "size": 23, "label": 0, "functionSource": "static int qemuAgentCheckError ( virJSONValuePtr cmd , virJSONValuePtr reply ) {\n if ( virJSONValueObjectHasKey ( reply , \"error\" ) ) {\n virJSONValuePtr error = virJSONValueObjectGet ( reply , \"error\" ) ;\n char * cmdstr = virJSONValueToString ( cmd , false ) ;\n char * replystr = virJSONValueToString ( reply , false ) ;\n VIR_DEBUG ( \"unable to execute QEMU agent command %s: %s\" , NULLSTR ( cmdstr ) , NULLSTR ( replystr ) ) ;\n if ( ! error ) virReportError ( VIR_ERR_INTERNAL_ERROR , _ ( \"unable to execute QEMU agent command '%s'\" ) , qemuAgentCommandName ( cmd ) ) ;\n else virReportError ( VIR_ERR_INTERNAL_ERROR , _ ( \"unable to execute QEMU agent command '%s': %s\" ) , qemuAgentCommandName ( cmd ) , qemuAgentStringifyError ( error ) ) ;\n VIR_FREE ( cmdstr ) ;\n VIR_FREE ( replystr ) ;\n return - 1 ;\n }\n else if ( ! virJSONValueObjectHasKey ( reply , \"return\" ) ) {\n char * cmdstr = virJSONValueToString ( cmd , false ) ;\n char * replystr = virJSONValueToString ( reply , false ) ;\n VIR_DEBUG ( \"Neither 'return' nor 'error' is set in the JSON reply %s: %s\" , NULLSTR ( cmdstr ) , NULLSTR ( replystr ) ) ;\n virReportError ( VIR_ERR_INTERNAL_ERROR , _ ( \"unable to execute QEMU agent command '%s'\" ) , qemuAgentCommandName ( cmd ) ) ;\n VIR_FREE ( cmdstr ) ;\n VIR_FREE ( replystr ) ;\n return - 1 ;\n }\n return 0 ;\n }", "idx": 990}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_IS13818AudioMode ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_IS13818AudioMode , IS13818AudioMode_sequence ) ;\n return offset ;\n }", "idx": 991}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_T_e164Address ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_restricted_character_string ( tvb , offset , actx , tree , hf_index , 1 , 128 , FALSE , \"0123456789#*,\" , 13 , NULL ) ;\n return offset ;\n }", "idx": 992}
{"hash": 6105314356608381376, "project": "debian", "size": 25, "label": 1, "functionSource": "static int cinepak_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int ret = 0 , buf_size = avpkt -> size ;\n CinepakContext * s = avctx -> priv_data ;\n s -> data = buf ;\n s -> size = buf_size ;\n s -> frame . reference = 1 ;\n s -> frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE ;\n if ( ( ret = avctx -> reget_buffer ( avctx , & s -> frame ) ) ) {\n av_log ( avctx , AV_LOG_ERROR , \"reget_buffer() failed\\n\" ) ;\n return ret ;\n }\n if ( s -> palette_video ) {\n const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;\n if ( pal ) {\n s -> frame . palette_has_changed = 1 ;\n memcpy ( s -> pal , pal , AVPALETTE_SIZE ) ;\n }\n }\n cinepak_decode ( s ) ;\n if ( s -> palette_video ) memcpy ( s -> frame . data [ 1 ] , s -> pal , AVPALETTE_SIZE ) ;\n * got_frame = 1 ;\n * ( AVFrame * ) data = s -> frame ;\n return buf_size ;\n }", "idx": 993}
{"hash": -1102844685921778700, "project": "debian", "size": 35, "label": 0, "functionSource": "int archive_strncat_l ( struct archive_string * as , const void * _p , size_t n , struct archive_string_conv * sc ) {\n const void * s ;\n size_t length = 0 ;\n int i , r = 0 , r2 ;\n if ( _p != NULL && n > 0 ) {\n if ( sc != NULL && ( sc -> flag & SCONV_FROM_UTF16 ) ) length = utf16nbytes ( _p , n ) ;\n else length = mbsnbytes ( _p , n ) ;\n }\n if ( length == 0 ) {\n int tn = 1 ;\n if ( sc != NULL && ( sc -> flag & SCONV_TO_UTF16 ) ) tn = 2 ;\n if ( archive_string_ensure ( as , as -> length + tn ) == NULL ) return ( - 1 ) ;\n as -> s [ as -> length ] = 0 ;\n if ( tn == 2 ) as -> s [ as -> length + 1 ] = 0 ;\n return ( 0 ) ;\n }\n if ( sc == NULL ) {\n if ( archive_string_append ( as , _p , length ) == NULL ) return ( - 1 ) ;\n return ( 0 ) ;\n }\n s = _p ;\n i = 0 ;\n if ( sc -> nconverter > 1 ) {\n sc -> utftmp . length = 0 ;\n r2 = sc -> converter [ 0 ] ( & ( sc -> utftmp ) , s , length , sc ) ;\n if ( r2 != 0 && errno == ENOMEM ) return ( r2 ) ;\n if ( r > r2 ) r = r2 ;\n s = sc -> utftmp . s ;\n length = sc -> utftmp . length ;\n ++ i ;\n }\n r2 = sc -> converter [ i ] ( as , s , length , sc ) ;\n if ( r > r2 ) r = r2 ;\n return ( r ) ;\n }", "idx": 994}
{"hash": -3889154245145551951, "project": "debian", "size": 63, "label": 0, "functionSource": "static void file_change_m ( const char * p , struct branch * b ) {\n static struct strbuf uq = STRBUF_INIT ;\n const char * endp ;\n struct object_entry * oe ;\n unsigned char sha1 [ 20 ] ;\n uint16_t mode , inline_data = 0 ;\n p = get_mode ( p , & mode ) ;\n if ( ! p ) die ( \"Corrupt mode: %s\" , command_buf . buf ) ;\n switch ( mode ) {\n case 0644 : case 0755 : mode |= S_IFREG ;\n case S_IFREG | 0644 : case S_IFREG | 0755 : case S_IFLNK : case S_IFDIR : case S_IFGITLINK : break ;\n default : die ( \"Corrupt mode: %s\" , command_buf . buf ) ;\n }\n if ( * p == ':' ) {\n oe = find_mark ( parse_mark_ref_space ( & p ) ) ;\n hashcpy ( sha1 , oe -> idx . sha1 ) ;\n }\n else if ( skip_prefix ( p , \"inline \" , & p ) ) {\n inline_data = 1 ;\n oe = NULL ;\n }\n else {\n if ( get_sha1_hex ( p , sha1 ) ) die ( \"Invalid dataref: %s\" , command_buf . buf ) ;\n oe = find_object ( sha1 ) ;\n p += 40 ;\n if ( * p ++ != ' ' ) die ( \"Missing space after SHA1: %s\" , command_buf . buf ) ;\n }\n strbuf_reset ( & uq ) ;\n if ( ! unquote_c_style ( & uq , p , & endp ) ) {\n if ( * endp ) die ( \"Garbage after path in: %s\" , command_buf . buf ) ;\n p = uq . buf ;\n }\n if ( S_ISDIR ( mode ) && ! hashcmp ( sha1 , EMPTY_TREE_SHA1_BIN ) && * p ) {\n tree_content_remove ( & b -> branch_tree , p , NULL , 0 ) ;\n return ;\n }\n if ( S_ISGITLINK ( mode ) ) {\n if ( inline_data ) die ( \"Git links cannot be specified 'inline': %s\" , command_buf . buf ) ;\n else if ( oe ) {\n if ( oe -> type != OBJ_COMMIT ) die ( \"Not a commit (actually a %s): %s\" , typename ( oe -> type ) , command_buf . buf ) ;\n }\n }\n else if ( inline_data ) {\n if ( S_ISDIR ( mode ) ) die ( \"Directories cannot be specified 'inline': %s\" , command_buf . buf ) ;\n if ( p != uq . buf ) {\n strbuf_addstr ( & uq , p ) ;\n p = uq . buf ;\n }\n read_next_command ( ) ;\n parse_and_store_blob ( & last_blob , sha1 , 0 ) ;\n }\n else {\n enum object_type expected = S_ISDIR ( mode ) ? OBJ_TREE : OBJ_BLOB ;\n enum object_type type = oe ? oe -> type : sha1_object_info ( sha1 , NULL ) ;\n if ( type < 0 ) die ( \"%s not found: %s\" , S_ISDIR ( mode ) ? \"Tree\" : \"Blob\" , command_buf . buf ) ;\n if ( type != expected ) die ( \"Not a %s (actually a %s): %s\" , typename ( expected ) , typename ( type ) , command_buf . buf ) ;\n }\n if ( ! * p ) {\n tree_content_replace ( & b -> branch_tree , sha1 , mode , NULL ) ;\n return ;\n }\n tree_content_set ( & b -> branch_tree , p , sha1 , mode , NULL ) ;\n }", "idx": 995}
{"hash": -6552851419396579257, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_NOTIFY_OPTIONS_ARRAY ( tvbuff_t * tvb , int offset , packet_info * pinfo , proto_tree * tree , dcerpc_info * di , guint8 * drep ) {\n offset = dissect_ndr_ucarray ( tvb , offset , pinfo , tree , di , drep , dissect_NOTIFY_OPTION ) ;\n return offset ;\n }", "idx": 996}
{"hash": 2388171415474875762, "project": "debian", "size": 6, "label": 0, "functionSource": "static const char * rsvp_conv_get_filter_type ( conv_item_t * conv , conv_filter_type_e filter _U_ ) {\n if ( ( filter == CONV_FT_SRC_ADDRESS ) && ( conv -> src_address . type == AT_IPv4 ) ) return \"ip.src\" ;\n if ( ( filter == CONV_FT_DST_ADDRESS ) && ( conv -> dst_address . type == AT_IPv4 ) ) return \"ip.dst\" ;\n if ( ( filter == CONV_FT_ANY_ADDRESS ) && ( conv -> src_address . type == AT_IPv4 ) ) return \"ip.addr\" ;\n return CONV_FILTER_INVALID ;\n }", "idx": 997}
{"hash": 3804373597256531021, "project": "debian", "size": 19, "label": 0, "functionSource": "bool acl_check_host ( const char * host , const char * ip ) {\n if ( allow_all_hosts ) return 0 ;\n VOID ( pthread_mutex_lock ( & acl_cache -> lock ) ) ;\n if ( ( host && hash_search ( & acl_check_hosts , ( uchar * ) host , strlen ( host ) ) ) || ( ip && hash_search ( & acl_check_hosts , ( uchar * ) ip , strlen ( ip ) ) ) ) {\n VOID ( pthread_mutex_unlock ( & acl_cache -> lock ) ) ;\n return 0 ;\n }\n for ( uint i = 0 ;\n i < acl_wild_hosts . elements ;\n i ++ ) {\n acl_host_and_ip * acl = dynamic_element ( & acl_wild_hosts , i , acl_host_and_ip * ) ;\n if ( compare_hostname ( acl , host , ip ) ) {\n VOID ( pthread_mutex_unlock ( & acl_cache -> lock ) ) ;\n return 0 ;\n }\n }\n VOID ( pthread_mutex_unlock ( & acl_cache -> lock ) ) ;\n return 1 ;\n }", "idx": 998}
{"hash": -2928324134072492299, "project": "debian", "size": 12, "label": 0, "functionSource": "void unistim_calls_init_tap ( void ) {\n GString * error_string ;\n if ( have_unistim_tap_listener == FALSE ) {\n error_string = register_tap_listener ( \"unistim\" , & ( the_tapinfo_struct . unistim_dummy ) , NULL , 0 , voip_calls_dlg_reset , unistim_calls_packet , voip_calls_dlg_draw ) ;\n if ( error_string != NULL ) {\n simple_dialog ( ESD_TYPE_ERROR , ESD_BTN_OK , \"%s\" , error_string -> str ) ;\n g_string_free ( error_string , TRUE ) ;\n exit ( 1 ) ;\n }\n have_unistim_tap_listener = TRUE ;\n }\n }", "idx": 999}
{"hash": 4496746249504396521, "project": "debian", "size": 13, "label": 0, "functionSource": "static u_short create_keyword_scanner ( void ) {\n u_short scanner ;\n u_short i ;\n sst_highwater = 1 ;\n scanner = 0 ;\n for ( i = 0 ;\n i < COUNTOF ( ntp_keywords ) ;\n i ++ ) {\n current_keyword = ntp_keywords [ i ] . key ;\n scanner = create_scan_states ( ntp_keywords [ i ] . key , ntp_keywords [ i ] . token , ntp_keywords [ i ] . followedby , scanner ) ;\n }\n return scanner ;\n }", "idx": 1000}
{"hash": 2636502839178711655, "project": "debian", "size": 68, "label": 1, "functionSource": "static void dissect_coap_opt_object_security ( tvbuff_t * tvb , proto_item * head_item , proto_tree * subtree , gint offset , gint opt_length , packet_info * pinfo , coap_info * coinfo , coap_common_dissect_t * dissect_hf ) {\n guint8 flag_byte = 0 ;\n gboolean non_compressed = FALSE ;\n gboolean expand = FALSE ;\n gboolean signature_present = FALSE ;\n gboolean kid_context_present = FALSE ;\n gboolean kid_present = FALSE ;\n guint8 piv_len = 0 ;\n guint8 kid_context_len = 0 ;\n guint8 kid_len = 0 ;\n coinfo -> object_security = TRUE ;\n coinfo -> oscore_info -> piv = NULL ;\n coinfo -> oscore_info -> kid_context = NULL ;\n coinfo -> oscore_info -> kid = NULL ;\n if ( opt_length == 0 ) {\n proto_item_append_text ( head_item , \": 00 (no Flag Byte)\" ) ;\n }\n else {\n flag_byte = tvb_get_guint8 ( tvb , offset ) ;\n proto_tree_add_item ( subtree , dissect_hf -> hf . opt_object_security_non_compressed , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n non_compressed = flag_byte & COAP_OBJECT_SECURITY_NON_COMPRESSED_MASK ;\n proto_tree_add_item ( subtree , dissect_hf -> hf . opt_object_security_expand , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n expand = flag_byte & COAP_OBJECT_SECURITY_EXPAND_MASK ;\n proto_tree_add_item ( subtree , dissect_hf -> hf . opt_object_security_signature , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n signature_present = flag_byte & COAP_OBJECT_SECURITY_SIGNATURE_MASK ;\n proto_tree_add_item ( subtree , dissect_hf -> hf . opt_object_security_kid_context_present , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n kid_context_present = flag_byte & COAP_OBJECT_SECURITY_KID_CONTEXT_MASK ;\n proto_tree_add_item ( subtree , dissect_hf -> hf . opt_object_security_kid_present , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n kid_present = flag_byte & COAP_OBJECT_SECURITY_KID_MASK ;\n proto_tree_add_item ( subtree , dissect_hf -> hf . opt_object_security_piv_len , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n piv_len = ( flag_byte & COAP_OBJECT_SECURITY_PIVLEN_MASK ) >> 0 ;\n kid_len = opt_length ;\n offset += 1 ;\n kid_len -= 1 ;\n if ( non_compressed || expand || signature_present ) {\n expert_add_info_format ( pinfo , subtree , & dissect_hf -> ei . opt_object_security_bad , \"Unsupported format\" ) ;\n }\n if ( piv_len > 0 ) {\n proto_tree_add_item ( subtree , dissect_hf -> hf . opt_object_security_piv , tvb , offset , piv_len , ENC_NA ) ;\n coinfo -> oscore_info -> piv = ( guint8 * ) tvb_memdup ( wmem_packet_scope ( ) , tvb , offset , piv_len ) ;\n coinfo -> oscore_info -> piv_len = piv_len ;\n offset += piv_len ;\n kid_len -= piv_len ;\n }\n if ( kid_context_present ) {\n proto_tree_add_item ( subtree , dissect_hf -> hf . opt_object_security_kid_context_len , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n kid_context_len = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n kid_len -= 1 ;\n proto_tree_add_item ( subtree , dissect_hf -> hf . opt_object_security_kid_context , tvb , offset , kid_context_len , ENC_NA ) ;\n coinfo -> oscore_info -> kid_context = ( guint8 * ) tvb_memdup ( wmem_packet_scope ( ) , tvb , offset , kid_context_len ) ;\n coinfo -> oscore_info -> kid_context_len = kid_context_len ;\n offset += kid_context_len ;\n kid_len -= kid_context_len ;\n }\n if ( kid_present ) {\n if ( kid_len > 0 ) {\n proto_tree_add_item ( subtree , dissect_hf -> hf . opt_object_security_kid , tvb , offset , kid_len , ENC_NA ) ;\n coinfo -> oscore_info -> kid = ( guint8 * ) tvb_memdup ( wmem_packet_scope ( ) , tvb , offset , kid_len ) ;\n coinfo -> oscore_info -> kid_len = kid_len ;\n }\n else {\n expert_add_info_format ( pinfo , subtree , & dissect_hf -> ei . opt_object_security_bad , \"Key ID flag is set but there are no remaining bytes to be processed\" ) ;\n }\n }\n proto_item_append_text ( head_item , \": Key ID:%s, Key ID Context:%s, Partial IV:%s\" , coinfo -> oscore_info -> kid == NULL ? nullstr : bytes_to_str ( wmem_packet_scope ( ) , coinfo -> oscore_info -> kid , coinfo -> oscore_info -> kid_len ) , coinfo -> oscore_info -> kid_context == NULL ? nullstr : bytes_to_str ( wmem_packet_scope ( ) , coinfo -> oscore_info -> kid_context , coinfo -> oscore_info -> kid_context_len ) , coinfo -> oscore_info -> piv == NULL ? nullstr : bytes_to_str ( wmem_packet_scope ( ) , coinfo -> oscore_info -> piv , coinfo -> oscore_info -> piv_len ) ) ;\n }\n }", "idx": 1001}
{"hash": -8556362624908896577, "project": "debian", "size": 10, "label": 0, "functionSource": "static void decode_bgr_bitstream ( HYuvContext * s , int count ) {\n if ( s -> decorrelate ) {\n if ( s -> bitstream_bpp == 24 ) decode_bgr_1 ( s , count , 1 , 0 ) ;\n else decode_bgr_1 ( s , count , 1 , 1 ) ;\n }\n else {\n if ( s -> bitstream_bpp == 24 ) decode_bgr_1 ( s , count , 0 , 0 ) ;\n else decode_bgr_1 ( s , count , 0 , 1 ) ;\n }\n }", "idx": 1002}
{"hash": 8801969307247112896, "project": "debian", "size": 81, "label": 0, "functionSource": "static int aes_gcm_ctrl ( EVP_CIPHER_CTX * c , int type , int arg , void * ptr ) {\n EVP_AES_GCM_CTX * gctx = EVP_C_DATA ( EVP_AES_GCM_CTX , c ) ;\n switch ( type ) {\n case EVP_CTRL_INIT : gctx -> key_set = 0 ;\n gctx -> iv_set = 0 ;\n gctx -> ivlen = EVP_CIPHER_CTX_iv_length ( c ) ;\n gctx -> iv = EVP_CIPHER_CTX_iv_noconst ( c ) ;\n gctx -> taglen = - 1 ;\n gctx -> iv_gen = 0 ;\n gctx -> tls_aad_len = - 1 ;\n return 1 ;\n case EVP_CTRL_AEAD_SET_IVLEN : if ( arg <= 0 ) return 0 ;\n if ( ( arg > EVP_MAX_IV_LENGTH ) && ( arg > gctx -> ivlen ) ) {\n if ( gctx -> iv != EVP_CIPHER_CTX_iv_noconst ( c ) ) OPENSSL_free ( gctx -> iv ) ;\n gctx -> iv = OPENSSL_malloc ( arg ) ;\n if ( gctx -> iv == NULL ) return 0 ;\n }\n gctx -> ivlen = arg ;\n return 1 ;\n case EVP_CTRL_AEAD_SET_TAG : if ( arg <= 0 || arg > 16 || EVP_CIPHER_CTX_encrypting ( c ) ) return 0 ;\n memcpy ( EVP_CIPHER_CTX_buf_noconst ( c ) , ptr , arg ) ;\n gctx -> taglen = arg ;\n return 1 ;\n case EVP_CTRL_AEAD_GET_TAG : if ( arg <= 0 || arg > 16 || ! EVP_CIPHER_CTX_encrypting ( c ) || gctx -> taglen < 0 ) return 0 ;\n memcpy ( ptr , EVP_CIPHER_CTX_buf_noconst ( c ) , arg ) ;\n return 1 ;\n case EVP_CTRL_GCM_SET_IV_FIXED : if ( arg == - 1 ) {\n memcpy ( gctx -> iv , ptr , gctx -> ivlen ) ;\n gctx -> iv_gen = 1 ;\n return 1 ;\n }\n if ( ( arg < 4 ) || ( gctx -> ivlen - arg ) < 8 ) return 0 ;\n if ( arg ) memcpy ( gctx -> iv , ptr , arg ) ;\n if ( EVP_CIPHER_CTX_encrypting ( c ) && RAND_bytes ( gctx -> iv + arg , gctx -> ivlen - arg ) <= 0 ) return 0 ;\n gctx -> iv_gen = 1 ;\n return 1 ;\n case EVP_CTRL_GCM_IV_GEN : if ( gctx -> iv_gen == 0 || gctx -> key_set == 0 ) return 0 ;\n CRYPTO_gcm128_setiv ( & gctx -> gcm , gctx -> iv , gctx -> ivlen ) ;\n if ( arg <= 0 || arg > gctx -> ivlen ) arg = gctx -> ivlen ;\n memcpy ( ptr , gctx -> iv + gctx -> ivlen - arg , arg ) ;\n ctr64_inc ( gctx -> iv + gctx -> ivlen - 8 ) ;\n gctx -> iv_set = 1 ;\n return 1 ;\n case EVP_CTRL_GCM_SET_IV_INV : if ( gctx -> iv_gen == 0 || gctx -> key_set == 0 || EVP_CIPHER_CTX_encrypting ( c ) ) return 0 ;\n memcpy ( gctx -> iv + gctx -> ivlen - arg , ptr , arg ) ;\n CRYPTO_gcm128_setiv ( & gctx -> gcm , gctx -> iv , gctx -> ivlen ) ;\n gctx -> iv_set = 1 ;\n return 1 ;\n case EVP_CTRL_AEAD_TLS1_AAD : if ( arg != EVP_AEAD_TLS1_AAD_LEN ) return 0 ;\n memcpy ( EVP_CIPHER_CTX_buf_noconst ( c ) , ptr , arg ) ;\n gctx -> tls_aad_len = arg ;\n {\n unsigned int len = EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 2 ] << 8 | EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 1 ] ;\n if ( len < EVP_GCM_TLS_EXPLICIT_IV_LEN ) return 0 ;\n len -= EVP_GCM_TLS_EXPLICIT_IV_LEN ;\n if ( ! EVP_CIPHER_CTX_encrypting ( c ) ) {\n if ( len < EVP_GCM_TLS_TAG_LEN ) return 0 ;\n len -= EVP_GCM_TLS_TAG_LEN ;\n }\n EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 2 ] = len >> 8 ;\n EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 1 ] = len & 0xff ;\n }\n return EVP_GCM_TLS_TAG_LEN ;\n case EVP_CTRL_COPY : {\n EVP_CIPHER_CTX * out = ptr ;\n EVP_AES_GCM_CTX * gctx_out = EVP_C_DATA ( EVP_AES_GCM_CTX , out ) ;\n if ( gctx -> gcm . key ) {\n if ( gctx -> gcm . key != & gctx -> ks ) return 0 ;\n gctx_out -> gcm . key = & gctx_out -> ks ;\n }\n if ( gctx -> iv == EVP_CIPHER_CTX_iv_noconst ( c ) ) gctx_out -> iv = EVP_CIPHER_CTX_iv_noconst ( out ) ;\n else {\n gctx_out -> iv = OPENSSL_malloc ( gctx -> ivlen ) ;\n if ( gctx_out -> iv == NULL ) return 0 ;\n memcpy ( gctx_out -> iv , gctx -> iv , gctx -> ivlen ) ;\n }\n return 1 ;\n }\n default : return - 1 ;\n }\n }", "idx": 1003}
{"hash": -2591112946600337077, "project": "debian", "size": 57, "label": 0, "functionSource": "static void inverse_quant ( int16_t * cur_lsp , int16_t * prev_lsp , uint8_t * lsp_index , int bad_frame ) {\n int min_dist , pred ;\n int i , j , temp , stable ;\n if ( ! bad_frame ) {\n min_dist = 0x100 ;\n pred = 12288 ;\n }\n else {\n min_dist = 0x200 ;\n pred = 23552 ;\n lsp_index [ 0 ] = lsp_index [ 1 ] = lsp_index [ 2 ] = 0 ;\n }\n cur_lsp [ 0 ] = lsp_band0 [ lsp_index [ 0 ] ] [ 0 ] ;\n cur_lsp [ 1 ] = lsp_band0 [ lsp_index [ 0 ] ] [ 1 ] ;\n cur_lsp [ 2 ] = lsp_band0 [ lsp_index [ 0 ] ] [ 2 ] ;\n cur_lsp [ 3 ] = lsp_band1 [ lsp_index [ 1 ] ] [ 0 ] ;\n cur_lsp [ 4 ] = lsp_band1 [ lsp_index [ 1 ] ] [ 1 ] ;\n cur_lsp [ 5 ] = lsp_band1 [ lsp_index [ 1 ] ] [ 2 ] ;\n cur_lsp [ 6 ] = lsp_band2 [ lsp_index [ 2 ] ] [ 0 ] ;\n cur_lsp [ 7 ] = lsp_band2 [ lsp_index [ 2 ] ] [ 1 ] ;\n cur_lsp [ 8 ] = lsp_band2 [ lsp_index [ 2 ] ] [ 2 ] ;\n cur_lsp [ 9 ] = lsp_band2 [ lsp_index [ 2 ] ] [ 3 ] ;\n for ( i = 0 ;\n i < LPC_ORDER ;\n i ++ ) {\n temp = ( ( prev_lsp [ i ] - dc_lsp [ i ] ) * pred + ( 1 << 14 ) ) >> 15 ;\n cur_lsp [ i ] += dc_lsp [ i ] + temp ;\n }\n for ( i = 0 ;\n i < LPC_ORDER ;\n i ++ ) {\n cur_lsp [ 0 ] = FFMAX ( cur_lsp [ 0 ] , 0x180 ) ;\n cur_lsp [ LPC_ORDER - 1 ] = FFMIN ( cur_lsp [ LPC_ORDER - 1 ] , 0x7e00 ) ;\n for ( j = 1 ;\n j < LPC_ORDER ;\n j ++ ) {\n temp = min_dist + cur_lsp [ j - 1 ] - cur_lsp [ j ] ;\n if ( temp > 0 ) {\n temp >>= 1 ;\n cur_lsp [ j - 1 ] -= temp ;\n cur_lsp [ j ] += temp ;\n }\n }\n stable = 1 ;\n for ( j = 1 ;\n j < LPC_ORDER ;\n j ++ ) {\n temp = cur_lsp [ j - 1 ] + min_dist - cur_lsp [ j ] - 4 ;\n if ( temp > 0 ) {\n stable = 0 ;\n break ;\n }\n }\n if ( stable ) break ;\n }\n if ( ! stable ) memcpy ( cur_lsp , prev_lsp , LPC_ORDER * sizeof ( * cur_lsp ) ) ;\n }", "idx": 1004}
{"hash": -769658847024738738, "project": "debian", "size": 27, "label": 0, "functionSource": "static gpgme_error_t uiserver_assuan_simple_command ( assuan_context_t ctx , char * cmd , engine_status_handler_t status_fnc , void * status_fnc_value ) {\n gpg_error_t err ;\n char * line ;\n size_t linelen ;\n err = assuan_write_line ( ctx , cmd ) ;\n if ( err ) return err ;\n do {\n err = assuan_read_line ( ctx , & line , & linelen ) ;\n if ( err ) return err ;\n if ( * line == '#' || ! linelen ) continue ;\n if ( linelen >= 2 && line [ 0 ] == 'O' && line [ 1 ] == 'K' && ( line [ 2 ] == '\\0' || line [ 2 ] == ' ' ) ) return 0 ;\n else if ( linelen >= 4 && line [ 0 ] == 'E' && line [ 1 ] == 'R' && line [ 2 ] == 'R' && line [ 3 ] == ' ' ) err = atoi ( & line [ 4 ] ) ;\n else if ( linelen >= 2 && line [ 0 ] == 'S' && line [ 1 ] == ' ' ) {\n char * rest ;\n gpgme_status_code_t r ;\n rest = strchr ( line + 2 , ' ' ) ;\n if ( ! rest ) rest = line + linelen ;\n else * ( rest ++ ) = 0 ;\n r = _gpgme_parse_status ( line + 2 ) ;\n if ( r >= 0 && status_fnc ) err = status_fnc ( status_fnc_value , r , rest ) ;\n else err = gpg_error ( GPG_ERR_GENERAL ) ;\n }\n else err = gpg_error ( GPG_ERR_GENERAL ) ;\n }\n while ( ! err ) ;\n return err ;\n }", "idx": 1005}
{"hash": 847431771831526026, "project": "debian", "size": 13, "label": 0, "functionSource": "static size_t choose_block ( char * d , size_t dlen , int col , const char * fromcode , const char * tocode , encoder_t * encoder , size_t * wlen ) {\n const int utf8 = fromcode && ( mutt_str_strcasecmp ( fromcode , \"utf-8\" ) == 0 ) ;\n size_t n = dlen ;\n while ( true ) {\n assert ( n > 0 ) ;\n const size_t nn = try_block ( d , n , fromcode , tocode , encoder , wlen ) ;\n if ( ( nn == 0 ) && ( ( col + * wlen ) <= ( ENCWORD_LEN_MAX + 1 ) || ( n <= 1 ) ) ) break ;\n n = ( nn ? nn : n ) - 1 ;\n assert ( n > 0 ) ;\n if ( utf8 ) while ( ( n > 1 ) && CONTINUATION_BYTE ( d [ n ] ) ) n -- ;\n }\n return n ;\n }", "idx": 1006}
{"hash": 4423867112908498696, "project": "chrome", "size": 39, "label": 1, "functionSource": "void vp9_quantize_b_32x32_c ( const int16_t * coeff_ptr , intptr_t n_coeffs , int skip_block , const int16_t * zbin_ptr , const int16_t * round_ptr , const int16_t * quant_ptr , const int16_t * quant_shift_ptr , int16_t * qcoeff_ptr , int16_t * dqcoeff_ptr , const int16_t * dequant_ptr , int zbin_oq_value , uint16_t * eob_ptr , const int16_t * scan , const int16_t * iscan ) {\n const int zbins [ 2 ] = {\n ROUND_POWER_OF_TWO ( zbin_ptr [ 0 ] + zbin_oq_value , 1 ) , ROUND_POWER_OF_TWO ( zbin_ptr [ 1 ] + zbin_oq_value , 1 ) }\n ;\n const int nzbins [ 2 ] = {\n zbins [ 0 ] * - 1 , zbins [ 1 ] * - 1 }\n ;\n int idx = 0 ;\n int idx_arr [ 1024 ] ;\n int i , eob = - 1 ;\n ( void ) iscan ;\n vpx_memset ( qcoeff_ptr , 0 , n_coeffs * sizeof ( int16_t ) ) ;\n vpx_memset ( dqcoeff_ptr , 0 , n_coeffs * sizeof ( int16_t ) ) ;\n if ( ! skip_block ) {\n for ( i = 0 ;\n i < n_coeffs ;\n i ++ ) {\n const int rc = scan [ i ] ;\n const int coeff = coeff_ptr [ rc ] ;\n if ( coeff >= zbins [ rc != 0 ] || coeff <= nzbins [ rc != 0 ] ) idx_arr [ idx ++ ] = i ;\n }\n for ( i = 0 ;\n i < idx ;\n i ++ ) {\n const int rc = scan [ idx_arr [ i ] ] ;\n const int coeff = coeff_ptr [ rc ] ;\n const int coeff_sign = ( coeff >> 31 ) ;\n int tmp ;\n int abs_coeff = ( coeff ^ coeff_sign ) - coeff_sign ;\n abs_coeff += ROUND_POWER_OF_TWO ( round_ptr [ rc != 0 ] , 1 ) ;\n abs_coeff = clamp ( abs_coeff , INT16_MIN , INT16_MAX ) ;\n tmp = ( ( ( ( abs_coeff * quant_ptr [ rc != 0 ] ) >> 16 ) + abs_coeff ) * quant_shift_ptr [ rc != 0 ] ) >> 15 ;\n qcoeff_ptr [ rc ] = ( tmp ^ coeff_sign ) - coeff_sign ;\n dqcoeff_ptr [ rc ] = qcoeff_ptr [ rc ] * dequant_ptr [ rc != 0 ] / 2 ;\n if ( tmp ) eob = idx_arr [ i ] ;\n }\n }\n * eob_ptr = eob + 1 ;\n }", "idx": 1007}
{"hash": 1182028467273264883, "project": "debian", "size": 10, "label": 0, "functionSource": "void handle_no_error ( struct st_command * command ) {\n DBUG_ENTER ( \"handle_no_error\" ) ;\n if ( command -> expected_errors . err [ 0 ] . type == ERR_ERRNO && command -> expected_errors . err [ 0 ] . code . errnum != 0 ) {\n report_or_die ( \"query '%s' succeeded - should have failed with errno %d...\" , command -> query , command -> expected_errors . err [ 0 ] . code . errnum ) ;\n }\n else if ( command -> expected_errors . err [ 0 ] . type == ERR_SQLSTATE && strcmp ( command -> expected_errors . err [ 0 ] . code . sqlstate , \"00000\" ) != 0 ) {\n report_or_die ( \"query '%s' succeeded - should have failed with \" \"sqlstate %s...\" , command -> query , command -> expected_errors . err [ 0 ] . code . sqlstate ) ;\n }\n DBUG_VOID_RETURN ;\n }", "idx": 1008}
{"hash": -3740862514502467070, "project": "debian", "size": 37, "label": 0, "functionSource": "static void dumpcfffdselect ( SplineFont * sf , struct alltabs * at ) {\n int cid , k , lastfd , cnt ;\n int gid ;\n putc ( 3 , at -> fdselect ) ;\n putshort ( at -> fdselect , 0 ) ;\n for ( k = 0 ;\n k < sf -> subfontcnt ;\n ++ k ) if ( SCWorthOutputting ( sf -> subfonts [ k ] -> glyphs [ 0 ] ) ) break ;\n if ( k == sf -> subfontcnt ) -- k ;\n putshort ( at -> fdselect , 0 ) ;\n putc ( k , at -> fdselect ) ;\n lastfd = k ;\n cnt = 1 ;\n for ( gid = 1 ;\n gid < at -> gi . gcnt ;\n ++ gid ) {\n cid = at -> gi . bygid [ gid ] ;\n for ( k = 0 ;\n k < sf -> subfontcnt ;\n ++ k ) {\n if ( cid < sf -> subfonts [ k ] -> glyphcnt && SCWorthOutputting ( sf -> subfonts [ k ] -> glyphs [ cid ] ) ) break ;\n }\n if ( k == sf -> subfontcnt ) ;\n else {\n if ( k != lastfd ) {\n putshort ( at -> fdselect , gid ) ;\n putc ( k , at -> fdselect ) ;\n lastfd = k ;\n ++ cnt ;\n }\n }\n }\n putshort ( at -> fdselect , gid ) ;\n fseek ( at -> fdselect , 1 , SEEK_SET ) ;\n putshort ( at -> fdselect , cnt ) ;\n fseek ( at -> fdselect , 0 , SEEK_END ) ;\n }", "idx": 1009}
{"hash": 7399683071036018868, "project": "debian", "size": 10, "label": 0, "functionSource": "static void dbstmt_prop_write ( zval * object , zval * member , zval * value , const zend_literal * key TSRMLS_DC ) {\n pdo_stmt_t * stmt = ( pdo_stmt_t * ) zend_object_store_get_object ( object TSRMLS_CC ) ;\n convert_to_string ( member ) ;\n if ( strcmp ( Z_STRVAL_P ( member ) , \"queryString\" ) == 0 ) {\n pdo_raise_impl_error ( stmt -> dbh , stmt , \"HY000\" , \"property queryString is read only\" TSRMLS_CC ) ;\n }\n else {\n std_object_handlers . write_property ( object , member , value , key TSRMLS_CC ) ;\n }\n }", "idx": 1010}
{"hash": -4558261210024070448, "project": "chrome", "size": 17, "label": 0, "functionSource": "int xmlListInsert ( xmlListPtr l , void * data ) {\n xmlLinkPtr lkPlace , lkNew ;\n if ( l == NULL ) return ( 1 ) ;\n lkPlace = xmlListLowerSearch ( l , data ) ;\n lkNew = ( xmlLinkPtr ) xmlMalloc ( sizeof ( xmlLink ) ) ;\n if ( lkNew == NULL ) {\n xmlGenericError ( xmlGenericErrorContext , \"Cannot initialize memory for new link\" ) ;\n return ( 1 ) ;\n }\n lkNew -> data = data ;\n lkPlace = lkPlace -> prev ;\n lkNew -> next = lkPlace -> next ;\n ( lkPlace -> next ) -> prev = lkNew ;\n lkPlace -> next = lkNew ;\n lkNew -> prev = lkPlace ;\n return 0 ;\n }", "idx": 1011}
{"hash": 2388171415474875762, "project": "debian", "size": 28, "label": 0, "functionSource": "static void dissect_rsvp_scope ( proto_item * ti _U_ , proto_tree * rsvp_object_tree , tvbuff_t * tvb , int offset , int obj_length , int rsvp_class _U_ , int type ) {\n int offset2 = offset + 4 ;\n int mylen ;\n mylen = obj_length - 4 ;\n switch ( type ) {\n case 1 : {\n proto_tree_add_uint_format_value ( rsvp_object_tree , hf_rsvp_ctype , tvb , offset + 3 , 1 , type , \"1 - IPv4\" ) ;\n while ( mylen > 0 ) {\n proto_tree_add_item ( rsvp_object_tree , hf_rsvp_scope_ipv4_address , tvb , offset2 , 4 , ENC_BIG_ENDIAN ) ;\n offset2 += 4 ;\n mylen -= 4 ;\n }\n break ;\n }\n case 2 : {\n proto_tree_add_uint_format_value ( rsvp_object_tree , hf_rsvp_ctype , tvb , offset + 3 , 1 , type , \"2 - IPv6\" ) ;\n while ( mylen > 0 ) {\n proto_tree_add_item ( rsvp_object_tree , hf_rsvp_scope_ipv6_address , tvb , offset2 , 16 , ENC_NA ) ;\n offset2 += 16 ;\n mylen -= 16 ;\n }\n break ;\n }\n default : proto_tree_add_uint_format_value ( rsvp_object_tree , hf_rsvp_ctype , tvb , offset + 3 , 1 , type , \"Unknown (%u)\" , type ) ;\n proto_tree_add_item ( rsvp_object_tree , hf_rsvp_scope_data , tvb , offset2 , mylen , ENC_NA ) ;\n break ;\n }\n }", "idx": 1012}
{"hash": 8170016074494868282, "project": "debian", "size": 11, "label": 0, "functionSource": "static int auth_server_input_spid ( struct auth_server_connection * conn , const char * const * args ) {\n if ( conn -> handshake_received ) {\n i_error ( \"BUG: Authentication server already sent handshake\" ) ;\n return - 1 ;\n }\n if ( str_to_uint ( args [ 0 ] , & conn -> server_pid ) < 0 ) {\n i_error ( \"BUG: Authentication server sent invalid PID\" ) ;\n return - 1 ;\n }\n return 0 ;\n }", "idx": 1013}
{"hash": -1315695702746584250, "project": "debian", "size": 11, "label": 0, "functionSource": "proto_item * proto_tree_add_time_format_value ( proto_tree * tree , int hfindex , tvbuff_t * tvb , gint start , gint length , nstime_t * value_ptr , const char * format , ... ) {\n proto_item * pi ;\n va_list ap ;\n pi = proto_tree_add_time ( tree , hfindex , tvb , start , length , value_ptr ) ;\n if ( pi != tree ) {\n va_start ( ap , format ) ;\n proto_tree_set_representation_value ( pi , format , ap ) ;\n va_end ( ap ) ;\n }\n return pi ;\n }", "idx": 1014}
{"hash": 455172021572601154, "project": "debian", "size": 20, "label": 0, "functionSource": "int str_replace ( char * * text , const char * s , const char * d ) {\n size_t slen = strlen ( s ) ;\n size_t dlen = strlen ( d ) ;\n int diff = dlen - slen ;\n char * p , * q = * text ;\n size_t size ;\n if ( strstr ( * text , s ) == NULL ) return - E_NOTFOUND ;\n while ( ( p = strstr ( q , s ) ) != NULL ) {\n if ( diff > 0 ) size = strlen ( q ) + diff + 1 ;\n else size = strlen ( q ) + 1 ;\n SAFE_REALLOC ( * text , size ) ;\n q = * text ;\n p = strstr ( q , s ) ;\n if ( p == NULL ) continue ;\n memmove ( p + dlen , p + slen , strlen ( p + slen ) + 1 ) ;\n memcpy ( p , d , dlen ) ;\n q = p + dlen ;\n }\n return E_SUCCESS ;\n }", "idx": 1015}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_TerminalInformation ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_TerminalInformation , TerminalInformation_sequence ) ;\n return offset ;\n }", "idx": 1016}
{"hash": 4206838170759624883, "project": "debian", "size": 20, "label": 0, "functionSource": "static QCryptoTLSCreds * nbd_get_tls_creds ( const char * id , Error * * errp ) {\n Object * obj ;\n QCryptoTLSCreds * creds ;\n obj = object_resolve_path_component ( object_get_objects_root ( ) , id ) ;\n if ( ! obj ) {\n error_setg ( errp , \"No TLS credentials with id '%s'\" , id ) ;\n return NULL ;\n }\n creds = ( QCryptoTLSCreds * ) object_dynamic_cast ( obj , TYPE_QCRYPTO_TLS_CREDS ) ;\n if ( ! creds ) {\n error_setg ( errp , \"Object with id '%s' is not TLS credentials\" , id ) ;\n return NULL ;\n }\n if ( creds -> endpoint != QCRYPTO_TLS_CREDS_ENDPOINT_SERVER ) {\n error_setg ( errp , \"Expecting TLS credentials with a server endpoint\" ) ;\n return NULL ;\n }\n object_ref ( obj ) ;\n return creds ;\n }", "idx": 1017}
{"hash": -3889154245145551951, "project": "debian", "size": 68, "label": 0, "functionSource": "static void note_change_n ( const char * p , struct branch * b , unsigned char * old_fanout ) {\n static struct strbuf uq = STRBUF_INIT ;\n struct object_entry * oe ;\n struct branch * s ;\n unsigned char sha1 [ 20 ] , commit_sha1 [ 20 ] ;\n char path [ 60 ] ;\n uint16_t inline_data = 0 ;\n unsigned char new_fanout ;\n if ( b -> num_notes == 0 && * old_fanout == 0 ) {\n b -> num_notes = change_note_fanout ( & b -> branch_tree , 0xff ) ;\n * old_fanout = convert_num_notes_to_fanout ( b -> num_notes ) ;\n }\n if ( * p == ':' ) {\n oe = find_mark ( parse_mark_ref_space ( & p ) ) ;\n hashcpy ( sha1 , oe -> idx . sha1 ) ;\n }\n else if ( skip_prefix ( p , \"inline \" , & p ) ) {\n inline_data = 1 ;\n oe = NULL ;\n }\n else {\n if ( get_sha1_hex ( p , sha1 ) ) die ( \"Invalid dataref: %s\" , command_buf . buf ) ;\n oe = find_object ( sha1 ) ;\n p += 40 ;\n if ( * p ++ != ' ' ) die ( \"Missing space after SHA1: %s\" , command_buf . buf ) ;\n }\n s = lookup_branch ( p ) ;\n if ( s ) {\n if ( is_null_sha1 ( s -> sha1 ) ) die ( \"Can't add a note on empty branch.\" ) ;\n hashcpy ( commit_sha1 , s -> sha1 ) ;\n }\n else if ( * p == ':' ) {\n uintmax_t commit_mark = parse_mark_ref_eol ( p ) ;\n struct object_entry * commit_oe = find_mark ( commit_mark ) ;\n if ( commit_oe -> type != OBJ_COMMIT ) die ( \"Mark :%\" PRIuMAX \" not a commit\" , commit_mark ) ;\n hashcpy ( commit_sha1 , commit_oe -> idx . sha1 ) ;\n }\n else if ( ! get_sha1 ( p , commit_sha1 ) ) {\n unsigned long size ;\n char * buf = read_object_with_reference ( commit_sha1 , commit_type , & size , commit_sha1 ) ;\n if ( ! buf || size < 46 ) die ( \"Not a valid commit: %s\" , p ) ;\n free ( buf ) ;\n }\n else die ( \"Invalid ref name or SHA1 expression: %s\" , p ) ;\n if ( inline_data ) {\n if ( p != uq . buf ) {\n strbuf_addstr ( & uq , p ) ;\n p = uq . buf ;\n }\n read_next_command ( ) ;\n parse_and_store_blob ( & last_blob , sha1 , 0 ) ;\n }\n else if ( oe ) {\n if ( oe -> type != OBJ_BLOB ) die ( \"Not a blob (actually a %s): %s\" , typename ( oe -> type ) , command_buf . buf ) ;\n }\n else if ( ! is_null_sha1 ( sha1 ) ) {\n enum object_type type = sha1_object_info ( sha1 , NULL ) ;\n if ( type < 0 ) die ( \"Blob not found: %s\" , command_buf . buf ) ;\n if ( type != OBJ_BLOB ) die ( \"Not a blob (actually a %s): %s\" , typename ( type ) , command_buf . buf ) ;\n }\n construct_path_with_fanout ( sha1_to_hex ( commit_sha1 ) , * old_fanout , path ) ;\n if ( tree_content_remove ( & b -> branch_tree , path , NULL , 0 ) ) b -> num_notes -- ;\n if ( is_null_sha1 ( sha1 ) ) return ;\n b -> num_notes ++ ;\n new_fanout = convert_num_notes_to_fanout ( b -> num_notes ) ;\n construct_path_with_fanout ( sha1_to_hex ( commit_sha1 ) , new_fanout , path ) ;\n tree_content_set ( & b -> branch_tree , path , sha1 , S_IFREG | 0644 , NULL ) ;\n }", "idx": 1018}
{"hash": 131568608762928706, "project": "debian", "size": 30, "label": 0, "functionSource": "int write_output ( void ) {\n int fd ;\n struct filter_op * fop ;\n struct filter_header fh ;\n size_t ninst , i ;\n u_char * data ;\n ninst = compile_tree ( & fop ) ;\n if ( fop == NULL ) return - E_NOTHANDLED ;\n if ( ninst == 0 ) return - E_INVALID ;\n fd = open ( EF_GBL_OPTIONS -> output_file , O_CREAT | O_RDWR | O_TRUNC | O_BINARY , 0644 ) ;\n ON_ERROR ( fd , - 1 , \"Can't create file %s\" , EF_GBL_OPTIONS -> output_file ) ;\n fprintf ( stdout , \" Writing output to \\'%s\\' \" , EF_GBL_OPTIONS -> output_file ) ;\n fflush ( stdout ) ;\n fh . magic = htons ( EC_FILTER_MAGIC ) ;\n strncpy ( fh . version , EC_VERSION , sizeof ( fh . version ) ) ;\n fh . data = sizeof ( fh ) ;\n data = create_data_segment ( & fh , fop , ninst ) ;\n write ( fd , & fh , sizeof ( struct filter_header ) ) ;\n write ( fd , data , fh . code - fh . data ) ;\n for ( i = 0 ;\n i <= ninst ;\n i ++ ) {\n print_progress_bar ( & fop [ i ] ) ;\n write ( fd , & fop [ i ] , sizeof ( struct filter_op ) ) ;\n }\n close ( fd ) ;\n fprintf ( stdout , \" done.\\n\\n\" ) ;\n fprintf ( stdout , \" -> Script encoded into %d instructions.\\n\\n\" , ( int ) ( i - 1 ) ) ;\n return E_SUCCESS ;\n }", "idx": 1019}
{"hash": 7092216800726729686, "project": "debian", "size": 7, "label": 0, "functionSource": "static int dissect_h245_EncryptionSync ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 706 \"../../asn1/h245/h245.cnf\" void * priv_data = actx -> private_data ;\n actx -> private_data = gef_ctx_alloc ( NULL , \"EncryptionSync\" ) ;\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_EncryptionSync , EncryptionSync_sequence ) ;\n # line 709 \"../../asn1/h245/h245.cnf\" actx -> private_data = priv_data ;\n return offset ;\n }", "idx": 1020}
{"hash": 3246343243711264189, "project": "debian", "size": 36, "label": 0, "functionSource": "static void handle_full_packet ( int tun_fd , int dns_fd , int userid ) {\n unsigned long outlen ;\n char out [ 64 * 1024 ] ;\n int touser ;\n int ret ;\n outlen = sizeof ( out ) ;\n ret = uncompress ( ( uint8_t * ) out , & outlen , ( uint8_t * ) users [ userid ] . inpacket . data , users [ userid ] . inpacket . len ) ;\n if ( ret == Z_OK ) {\n struct ip * hdr ;\n hdr = ( struct ip * ) ( out + 4 ) ;\n touser = find_user_by_ip ( hdr -> ip_dst . s_addr ) ;\n if ( touser == - 1 ) {\n write_tun ( tun_fd , out , outlen ) ;\n }\n else {\n if ( users [ touser ] . conn == CONN_DNS_NULL ) {\n if ( users [ touser ] . outpacket . len == 0 ) {\n start_new_outpacket ( touser , users [ userid ] . inpacket . data , users [ userid ] . inpacket . len ) ;\n if ( users [ touser ] . q_sendrealsoon . id != 0 ) send_chunk_or_dataless ( dns_fd , touser , & users [ touser ] . q_sendrealsoon ) ;\n else if ( users [ touser ] . q . id != 0 ) send_chunk_or_dataless ( dns_fd , touser , & users [ touser ] . q ) ;\n # ifdef OUTPACKETQ_LEN }\n else {\n save_to_outpacketq ( touser , users [ userid ] . inpacket . data , users [ userid ] . inpacket . len ) ;\n # endif }\n }\n else {\n send_raw ( dns_fd , users [ userid ] . inpacket . data , users [ userid ] . inpacket . len , touser , RAW_HDR_CMD_DATA , & users [ touser ] . q ) ;\n }\n }\n }\n else {\n if ( debug >= 1 ) fprintf ( stderr , \"Discarded data, uncompress() result: %d\\n\" , ret ) ;\n }\n users [ userid ] . inpacket . len = 0 ;\n users [ userid ] . inpacket . offset = 0 ;\n }", "idx": 1021}
{"hash": -1055531103257174901, "project": "debian", "size": 6, "label": 0, "functionSource": "static void sig_message_join ( SERVER_REC * server , const char * channel , const char * nick , const char * address ) {\n CHANNEL_REC * chanrec ;\n g_return_if_fail ( nick != NULL ) ;\n chanrec = channel_find ( server , channel ) ;\n if ( chanrec != NULL ) CHANNEL_LAST_MSG_ADD ( chanrec , nick , FALSE ) ;\n }", "idx": 1022}
{"hash": -5018199117312371093, "project": "chrome", "size": 23, "label": 0, "functionSource": "static void y4m_convert_422jpeg_420jpeg ( y4m_input * _y4m , unsigned char * _dst , unsigned char * _aux ) {\n int c_w ;\n int c_h ;\n int c_sz ;\n int dst_c_w ;\n int dst_c_h ;\n int dst_c_sz ;\n int pli ;\n _dst += _y4m -> pic_w * _y4m -> pic_h ;\n c_w = ( _y4m -> pic_w + _y4m -> src_c_dec_h - 1 ) / _y4m -> src_c_dec_h ;\n c_h = _y4m -> pic_h ;\n dst_c_w = ( _y4m -> pic_w + _y4m -> dst_c_dec_h - 1 ) / _y4m -> dst_c_dec_h ;\n dst_c_h = ( _y4m -> pic_h + _y4m -> dst_c_dec_v - 1 ) / _y4m -> dst_c_dec_v ;\n c_sz = c_w * c_h ;\n dst_c_sz = dst_c_w * dst_c_h ;\n for ( pli = 1 ;\n pli < 3 ;\n pli ++ ) {\n y4m_422jpeg_420jpeg_helper ( _dst , _aux , c_w , c_h ) ;\n _aux += c_sz ;\n _dst += dst_c_sz ;\n }\n }", "idx": 1023}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_VBDCapability ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_VBDCapability , VBDCapability_sequence ) ;\n return offset ;\n }", "idx": 1024}
{"hash": 174091092490434632, "project": "chrome", "size": 11, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( AppApiTest , ServerRedirectToAppFromExtension ) {\n LoadExtension ( test_data_dir_ . AppendASCII ( \"app_process\" ) ) ;\n const Extension * launcher = LoadExtension ( test_data_dir_ . AppendASCII ( \"app_launcher\" ) ) ;\n content : : TestNavigationObserver test_navigation_observer ( browser ( ) -> tab_strip_model ( ) -> GetActiveWebContents ( ) , 2 ) ;\n test_navigation_observer . StartWatchingNewWebContents ( ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , launcher -> GetResourceURL ( \"server_redirect.html\" ) ) ;\n test_navigation_observer . Wait ( ) ;\n bool is_installed = false ;\n ASSERT_TRUE ( content : : ExecuteScriptAndExtractBool ( browser ( ) -> tab_strip_model ( ) -> GetActiveWebContents ( ) , \"window.domAutomationController.send(chrome.app.isInstalled)\" , & is_installed ) ) ;\n ASSERT_TRUE ( is_installed ) ;\n }", "idx": 1025}
{"hash": -5689214734378699681, "project": "debian", "size": 16, "label": 0, "functionSource": "static int _fix_java ( const char * in , char * out ) {\n int i , j ;\n for ( i = 0 , j = 7 ;\n i < j ;\n i ++ , j -- ) {\n out [ i ] = in [ j ] ;\n out [ j ] = in [ i ] ;\n }\n for ( i = 8 , j = 15 ;\n i < j ;\n i ++ , j -- ) {\n out [ i ] = in [ j ] ;\n out [ j ] = in [ i ] ;\n }\n return 0 ;\n }", "idx": 1026}
{"hash": 4489017523191997023, "project": "debian", "size": 4, "label": 0, "functionSource": "int dissect_h225_ServiceControlSession ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_ServiceControlSession , ServiceControlSession_sequence ) ;\n return offset ;\n }", "idx": 1027}
{"hash": 1891617106617090004, "project": "chrome", "size": 7, "label": 0, "functionSource": "static UChar32 U_CALLCONV _UTF32GetNextUChar ( UConverterToUnicodeArgs * pArgs , UErrorCode * pErrorCode ) {\n switch ( pArgs -> converter -> mode ) {\n case 8 : return T_UConverter_getNextUChar_UTF32_BE ( pArgs , pErrorCode ) ;\n case 9 : return T_UConverter_getNextUChar_UTF32_LE ( pArgs , pErrorCode ) ;\n default : return UCNV_GET_NEXT_UCHAR_USE_TO_U ;\n }\n }", "idx": 1028}
{"hash": 1788300783882316916, "project": "debian", "size": 258, "label": 0, "functionSource": "static inline int bidir_refine ( MpegEncContext * s , int mb_x , int mb_y ) {\n MotionEstContext * const c = & s -> me ;\n const int mot_stride = s -> mb_stride ;\n const int xy = mb_y * mot_stride + mb_x ;\n int fbmin ;\n int pred_fx = s -> b_bidir_forw_mv_table [ xy - 1 ] [ 0 ] ;\n int pred_fy = s -> b_bidir_forw_mv_table [ xy - 1 ] [ 1 ] ;\n int pred_bx = s -> b_bidir_back_mv_table [ xy - 1 ] [ 0 ] ;\n int pred_by = s -> b_bidir_back_mv_table [ xy - 1 ] [ 1 ] ;\n int motion_fx = s -> b_bidir_forw_mv_table [ xy ] [ 0 ] = s -> b_forw_mv_table [ xy ] [ 0 ] ;\n int motion_fy = s -> b_bidir_forw_mv_table [ xy ] [ 1 ] = s -> b_forw_mv_table [ xy ] [ 1 ] ;\n int motion_bx = s -> b_bidir_back_mv_table [ xy ] [ 0 ] = s -> b_back_mv_table [ xy ] [ 0 ] ;\n int motion_by = s -> b_bidir_back_mv_table [ xy ] [ 1 ] = s -> b_back_mv_table [ xy ] [ 1 ] ;\n const int flags = c -> sub_flags ;\n const int qpel = flags & FLAG_QPEL ;\n const int shift = 1 + qpel ;\n const int xmin = c -> xmin << shift ;\n const int ymin = c -> ymin << shift ;\n const int xmax = c -> xmax << shift ;\n const int ymax = c -> ymax << shift ;\n # define HASH ( fx , fy , bx , by ) ( ( fx ) + 17 * ( fy ) + 63 * ( bx ) + 117 * ( by ) ) # define HASH8 ( fx , fy , bx , by ) ( ( uint8_t ) HASH ( fx , fy , bx , by ) ) int hashidx = HASH ( motion_fx , motion_fy , motion_bx , motion_by ) ;\n uint8_t map [ 256 ] = {\n 0 }\n ;\n map [ hashidx & 255 ] = 1 ;\n fbmin = check_bidir_mv ( s , motion_fx , motion_fy , motion_bx , motion_by , pred_fx , pred_fy , pred_bx , pred_by , 0 , 16 ) ;\n if ( s -> avctx -> bidir_refine ) {\n int end ;\n static const uint8_t limittab [ 5 ] = {\n 0 , 8 , 32 , 64 , 80 }\n ;\n const int limit = limittab [ s -> avctx -> bidir_refine ] ;\n static const int8_t vect [ ] [ 4 ] = {\n {\n 0 , 0 , 0 , 1 }\n , {\n 0 , 0 , 0 , - 1 }\n , {\n 0 , 0 , 1 , 0 }\n , {\n 0 , 0 , - 1 , 0 }\n , {\n 0 , 1 , 0 , 0 }\n , {\n 0 , - 1 , 0 , 0 }\n , {\n 1 , 0 , 0 , 0 }\n , {\n - 1 , 0 , 0 , 0 }\n , {\n 0 , 0 , 1 , 1 }\n , {\n 0 , 0 , - 1 , - 1 }\n , {\n 0 , 1 , 1 , 0 }\n , {\n 0 , - 1 , - 1 , 0 }\n , {\n 1 , 1 , 0 , 0 }\n , {\n - 1 , - 1 , 0 , 0 }\n , {\n 1 , 0 , 0 , 1 }\n , {\n - 1 , 0 , 0 , - 1 }\n , {\n 0 , 1 , 0 , 1 }\n , {\n 0 , - 1 , 0 , - 1 }\n , {\n 1 , 0 , 1 , 0 }\n , {\n - 1 , 0 , - 1 , 0 }\n , {\n 0 , 0 , - 1 , 1 }\n , {\n 0 , 0 , 1 , - 1 }\n , {\n 0 , - 1 , 1 , 0 }\n , {\n 0 , 1 , - 1 , 0 }\n , {\n - 1 , 1 , 0 , 0 }\n , {\n 1 , - 1 , 0 , 0 }\n , {\n 1 , 0 , 0 , - 1 }\n , {\n - 1 , 0 , 0 , 1 }\n , {\n 0 , - 1 , 0 , 1 }\n , {\n 0 , 1 , 0 , - 1 }\n , {\n - 1 , 0 , 1 , 0 }\n , {\n 1 , 0 , - 1 , 0 }\n , {\n 0 , 1 , 1 , 1 }\n , {\n 0 , - 1 , - 1 , - 1 }\n , {\n 1 , 1 , 1 , 0 }\n , {\n - 1 , - 1 , - 1 , 0 }\n , {\n 1 , 1 , 0 , 1 }\n , {\n - 1 , - 1 , 0 , - 1 }\n , {\n 1 , 0 , 1 , 1 }\n , {\n - 1 , 0 , - 1 , - 1 }\n , {\n 0 , - 1 , 1 , 1 }\n , {\n 0 , 1 , - 1 , - 1 }\n , {\n - 1 , 1 , 1 , 0 }\n , {\n 1 , - 1 , - 1 , 0 }\n , {\n 1 , 1 , 0 , - 1 }\n , {\n - 1 , - 1 , 0 , 1 }\n , {\n 1 , 0 , - 1 , 1 }\n , {\n - 1 , 0 , 1 , - 1 }\n , {\n 0 , 1 , - 1 , 1 }\n , {\n 0 , - 1 , 1 , - 1 }\n , {\n 1 , - 1 , 1 , 0 }\n , {\n - 1 , 1 , - 1 , 0 }\n , {\n - 1 , 1 , 0 , 1 }\n , {\n 1 , - 1 , 0 , - 1 }\n , {\n 1 , 0 , 1 , - 1 }\n , {\n - 1 , 0 , - 1 , 1 }\n , {\n 0 , 1 , 1 , - 1 }\n , {\n 0 , - 1 , - 1 , 1 }\n , {\n 1 , 1 , - 1 , 0 }\n , {\n - 1 , - 1 , 1 , 0 }\n , {\n 1 , - 1 , 0 , 1 }\n , {\n - 1 , 1 , 0 , - 1 }\n , {\n - 1 , 0 , 1 , 1 }\n , {\n 1 , 0 , - 1 , - 1 }\n , {\n 1 , 1 , 1 , 1 }\n , {\n - 1 , - 1 , - 1 , - 1 }\n , {\n 1 , 1 , 1 , - 1 }\n , {\n - 1 , - 1 , - 1 , 1 }\n , {\n 1 , 1 , - 1 , 1 }\n , {\n - 1 , - 1 , 1 , - 1 }\n , {\n 1 , - 1 , 1 , 1 }\n , {\n - 1 , 1 , - 1 , - 1 }\n , {\n - 1 , 1 , 1 , 1 }\n , {\n 1 , - 1 , - 1 , - 1 }\n , {\n 1 , 1 , - 1 , - 1 }\n , {\n - 1 , - 1 , 1 , 1 }\n , {\n 1 , - 1 , - 1 , 1 }\n , {\n - 1 , 1 , 1 , - 1 }\n , {\n 1 , - 1 , 1 , - 1 }\n , {\n - 1 , 1 , - 1 , 1 }\n , }\n ;\n static const uint8_t hash [ ] = {\n HASH8 ( 0 , 0 , 0 , 1 ) , HASH8 ( 0 , 0 , 0 , - 1 ) , HASH8 ( 0 , 0 , 1 , 0 ) , HASH8 ( 0 , 0 , - 1 , 0 ) , HASH8 ( 0 , 1 , 0 , 0 ) , HASH8 ( 0 , - 1 , 0 , 0 ) , HASH8 ( 1 , 0 , 0 , 0 ) , HASH8 ( - 1 , 0 , 0 , 0 ) , HASH8 ( 0 , 0 , 1 , 1 ) , HASH8 ( 0 , 0 , - 1 , - 1 ) , HASH8 ( 0 , 1 , 1 , 0 ) , HASH8 ( 0 , - 1 , - 1 , 0 ) , HASH8 ( 1 , 1 , 0 , 0 ) , HASH8 ( - 1 , - 1 , 0 , 0 ) , HASH8 ( 1 , 0 , 0 , 1 ) , HASH8 ( - 1 , 0 , 0 , - 1 ) , HASH8 ( 0 , 1 , 0 , 1 ) , HASH8 ( 0 , - 1 , 0 , - 1 ) , HASH8 ( 1 , 0 , 1 , 0 ) , HASH8 ( - 1 , 0 , - 1 , 0 ) , HASH8 ( 0 , 0 , - 1 , 1 ) , HASH8 ( 0 , 0 , 1 , - 1 ) , HASH8 ( 0 , - 1 , 1 , 0 ) , HASH8 ( 0 , 1 , - 1 , 0 ) , HASH8 ( - 1 , 1 , 0 , 0 ) , HASH8 ( 1 , - 1 , 0 , 0 ) , HASH8 ( 1 , 0 , 0 , - 1 ) , HASH8 ( - 1 , 0 , 0 , 1 ) , HASH8 ( 0 , - 1 , 0 , 1 ) , HASH8 ( 0 , 1 , 0 , - 1 ) , HASH8 ( - 1 , 0 , 1 , 0 ) , HASH8 ( 1 , 0 , - 1 , 0 ) , HASH8 ( 0 , 1 , 1 , 1 ) , HASH8 ( 0 , - 1 , - 1 , - 1 ) , HASH8 ( 1 , 1 , 1 , 0 ) , HASH8 ( - 1 , - 1 , - 1 , 0 ) , HASH8 ( 1 , 1 , 0 , 1 ) , HASH8 ( - 1 , - 1 , 0 , - 1 ) , HASH8 ( 1 , 0 , 1 , 1 ) , HASH8 ( - 1 , 0 , - 1 , - 1 ) , HASH8 ( 0 , - 1 , 1 , 1 ) , HASH8 ( 0 , 1 , - 1 , - 1 ) , HASH8 ( - 1 , 1 , 1 , 0 ) , HASH8 ( 1 , - 1 , - 1 , 0 ) , HASH8 ( 1 , 1 , 0 , - 1 ) , HASH8 ( - 1 , - 1 , 0 , 1 ) , HASH8 ( 1 , 0 , - 1 , 1 ) , HASH8 ( - 1 , 0 , 1 , - 1 ) , HASH8 ( 0 , 1 , - 1 , 1 ) , HASH8 ( 0 , - 1 , 1 , - 1 ) , HASH8 ( 1 , - 1 , 1 , 0 ) , HASH8 ( - 1 , 1 , - 1 , 0 ) , HASH8 ( - 1 , 1 , 0 , 1 ) , HASH8 ( 1 , - 1 , 0 , - 1 ) , HASH8 ( 1 , 0 , 1 , - 1 ) , HASH8 ( - 1 , 0 , - 1 , 1 ) , HASH8 ( 0 , 1 , 1 , - 1 ) , HASH8 ( 0 , - 1 , - 1 , 1 ) , HASH8 ( 1 , 1 , - 1 , 0 ) , HASH8 ( - 1 , - 1 , 1 , 0 ) , HASH8 ( 1 , - 1 , 0 , 1 ) , HASH8 ( - 1 , 1 , 0 , - 1 ) , HASH8 ( - 1 , 0 , 1 , 1 ) , HASH8 ( 1 , 0 , - 1 , - 1 ) , HASH8 ( 1 , 1 , 1 , 1 ) , HASH8 ( - 1 , - 1 , - 1 , - 1 ) , HASH8 ( 1 , 1 , 1 , - 1 ) , HASH8 ( - 1 , - 1 , - 1 , 1 ) , HASH8 ( 1 , 1 , - 1 , 1 ) , HASH8 ( - 1 , - 1 , 1 , - 1 ) , HASH8 ( 1 , - 1 , 1 , 1 ) , HASH8 ( - 1 , 1 , - 1 , - 1 ) , HASH8 ( - 1 , 1 , 1 , 1 ) , HASH8 ( 1 , - 1 , - 1 , - 1 ) , HASH8 ( 1 , 1 , - 1 , - 1 ) , HASH8 ( - 1 , - 1 , 1 , 1 ) , HASH8 ( 1 , - 1 , - 1 , 1 ) , HASH8 ( - 1 , 1 , 1 , - 1 ) , HASH8 ( 1 , - 1 , 1 , - 1 ) , HASH8 ( - 1 , 1 , - 1 , 1 ) , }\n ;\n # define CHECK_BIDIR ( fx , fy , bx , by ) if ( ! map [ ( hashidx + HASH ( fx , fy , bx , by ) ) & 255 ] && ( fx <= 0 || motion_fx + fx <= xmax ) && ( fy <= 0 || motion_fy + fy <= ymax ) && ( bx <= 0 || motion_bx + bx <= xmax ) && ( by <= 0 || motion_by + by <= ymax ) && ( fx >= 0 || motion_fx + fx >= xmin ) && ( fy >= 0 || motion_fy + fy >= ymin ) && ( bx >= 0 || motion_bx + bx >= xmin ) && ( by >= 0 || motion_by + by >= ymin ) ) {\n int score ;\n map [ ( hashidx + HASH ( fx , fy , bx , by ) ) & 255 ] = 1 ;\n score = check_bidir_mv ( s , motion_fx + fx , motion_fy + fy , motion_bx + bx , motion_by + by , pred_fx , pred_fy , pred_bx , pred_by , 0 , 16 ) ;\n if ( score < fbmin ) {\n hashidx += HASH ( fx , fy , bx , by ) ;\n fbmin = score ;\n motion_fx += fx ;\n motion_fy += fy ;\n motion_bx += bx ;\n motion_by += by ;\n end = 0 ;\n }\n }\n # define CHECK_BIDIR2 ( a , b , c , d ) CHECK_BIDIR ( a , b , c , d ) CHECK_BIDIR ( - ( a ) , - ( b ) , - ( c ) , - ( d ) ) do {\n int i ;\n int borderdist = 0 ;\n end = 1 ;\n CHECK_BIDIR2 ( 0 , 0 , 0 , 1 ) CHECK_BIDIR2 ( 0 , 0 , 1 , 0 ) CHECK_BIDIR2 ( 0 , 1 , 0 , 0 ) CHECK_BIDIR2 ( 1 , 0 , 0 , 0 ) for ( i = 8 ;\n i < limit ;\n i ++ ) {\n int fx = motion_fx + vect [ i ] [ 0 ] ;\n int fy = motion_fy + vect [ i ] [ 1 ] ;\n int bx = motion_bx + vect [ i ] [ 2 ] ;\n int by = motion_by + vect [ i ] [ 3 ] ;\n if ( borderdist <= 0 ) {\n int a = ( xmax - FFMAX ( fx , bx ) ) | ( FFMIN ( fx , bx ) - xmin ) ;\n int b = ( ymax - FFMAX ( fy , by ) ) | ( FFMIN ( fy , by ) - ymin ) ;\n if ( ( a | b ) < 0 ) map [ ( hashidx + hash [ i ] ) & 255 ] = 1 ;\n }\n if ( ! map [ ( hashidx + hash [ i ] ) & 255 ] ) {\n int score ;\n map [ ( hashidx + hash [ i ] ) & 255 ] = 1 ;\n score = check_bidir_mv ( s , fx , fy , bx , by , pred_fx , pred_fy , pred_bx , pred_by , 0 , 16 ) ;\n if ( score < fbmin ) {\n hashidx += hash [ i ] ;\n fbmin = score ;\n motion_fx = fx ;\n motion_fy = fy ;\n motion_bx = bx ;\n motion_by = by ;\n end = 0 ;\n borderdist -- ;\n if ( borderdist <= 0 ) {\n int a = FFMIN ( xmax - FFMAX ( fx , bx ) , FFMIN ( fx , bx ) - xmin ) ;\n int b = FFMIN ( ymax - FFMAX ( fy , by ) , FFMIN ( fy , by ) - ymin ) ;\n borderdist = FFMIN ( a , b ) ;\n }\n }\n }\n }\n }\n while ( ! end ) ;\n }\n s -> b_bidir_forw_mv_table [ xy ] [ 0 ] = motion_fx ;\n s -> b_bidir_forw_mv_table [ xy ] [ 1 ] = motion_fy ;\n s -> b_bidir_back_mv_table [ xy ] [ 0 ] = motion_bx ;\n s -> b_bidir_back_mv_table [ xy ] [ 1 ] = motion_by ;\n return fbmin ;\n }", "idx": 1029}
{"hash": -1457977271973356031, "project": "chrome", "size": 11, "label": 0, "functionSource": "TEST ( ExtensionCSPValidator , IsLegal ) {\n EXPECT_TRUE ( ContentSecurityPolicyIsLegal ( \"foo\" ) ) ;\n EXPECT_TRUE ( ContentSecurityPolicyIsLegal ( \"default-src 'self';\n script-src http://www.google.com\" ) ) ;\n EXPECT_FALSE ( ContentSecurityPolicyIsLegal ( \"default-src 'self';\n\\nscript-src http://www.google.com\" ) ) ;\n EXPECT_FALSE ( ContentSecurityPolicyIsLegal ( \"default-src 'self';\n\\rscript-src http://www.google.com\" ) ) ;\n EXPECT_FALSE ( ContentSecurityPolicyIsLegal ( \"default-src 'self';\n,script-src http://www.google.com\" ) ) ;\n }", "idx": 1030}
{"hash": -1919011628477388936, "project": "debian", "size": 6, "label": 0, "functionSource": "static void openpic_class_init ( ObjectClass * oc , void * data ) {\n DeviceClass * dc = DEVICE_CLASS ( oc ) ;\n dc -> realize = openpic_realize ;\n dc -> props = openpic_properties ;\n dc -> reset = openpic_reset ;\n }", "idx": 1031}
{"hash": 6664609110189077049, "project": "debian", "size": 46, "label": 0, "functionSource": "static void inverse_channel_transform ( WMAProDecodeCtx * s ) {\n int i ;\n for ( i = 0 ;\n i < s -> num_chgroups ;\n i ++ ) {\n if ( s -> chgroup [ i ] . transform ) {\n float data [ WMAPRO_MAX_CHANNELS ] ;\n const int num_channels = s -> chgroup [ i ] . num_channels ;\n float * * ch_data = s -> chgroup [ i ] . channel_data ;\n float * * ch_end = ch_data + num_channels ;\n const int8_t * tb = s -> chgroup [ i ] . transform_band ;\n int16_t * sfb ;\n for ( sfb = s -> cur_sfb_offsets ;\n sfb < s -> cur_sfb_offsets + s -> num_bands ;\n sfb ++ ) {\n int y ;\n if ( * tb ++ == 1 ) {\n for ( y = sfb [ 0 ] ;\n y < FFMIN ( sfb [ 1 ] , s -> subframe_len ) ;\n y ++ ) {\n const float * mat = s -> chgroup [ i ] . decorrelation_matrix ;\n const float * data_end = data + num_channels ;\n float * data_ptr = data ;\n float * * ch ;\n for ( ch = ch_data ;\n ch < ch_end ;\n ch ++ ) * data_ptr ++ = ( * ch ) [ y ] ;\n for ( ch = ch_data ;\n ch < ch_end ;\n ch ++ ) {\n float sum = 0 ;\n data_ptr = data ;\n while ( data_ptr < data_end ) sum += * data_ptr ++ * * mat ++ ;\n ( * ch ) [ y ] = sum ;\n }\n }\n }\n else if ( s -> avctx -> channels == 2 ) {\n int len = FFMIN ( sfb [ 1 ] , s -> subframe_len ) - sfb [ 0 ] ;\n s -> fdsp . vector_fmul_scalar ( ch_data [ 0 ] + sfb [ 0 ] , ch_data [ 0 ] + sfb [ 0 ] , 181.0 / 128 , len ) ;\n s -> fdsp . vector_fmul_scalar ( ch_data [ 1 ] + sfb [ 0 ] , ch_data [ 1 ] + sfb [ 0 ] , 181.0 / 128 , len ) ;\n }\n }\n }\n }\n }", "idx": 1032}
{"hash": -7884836206149374350, "project": "chrome", "size": 5, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( BluetoothChooserBrowserTest , InvokeDialog_PairedBubble ) {\n set_status ( FakeBluetoothChooserController : : BluetoothStatus : : IDLE ) ;\n AddPairedDevice ( ) ;\n RunDialog ( ) ;\n }", "idx": 1033}
{"hash": 1414661670117003749, "project": "debian", "size": 7, "label": 0, "functionSource": "static void show_object ( struct object * object , const char * name , void * data ) {\n struct bitmap * base = data ;\n int bitmap_pos ;\n bitmap_pos = bitmap_position ( object -> oid . hash ) ;\n if ( bitmap_pos < 0 ) bitmap_pos = ext_index_add_object ( object , name ) ;\n bitmap_set ( base , bitmap_pos ) ;\n }", "idx": 1034}
{"hash": -4885528830177756816, "project": "debian", "size": 34, "label": 0, "functionSource": "int chk_size ( MI_CHECK * param , register MI_INFO * info ) {\n int error = 0 ;\n register my_off_t skr , size ;\n char buff [ 22 ] , buff2 [ 22 ] ;\n DBUG_ENTER ( \"chk_size\" ) ;\n if ( ! ( param -> testflag & T_SILENT ) ) puts ( \"- check file-size\" ) ;\n flush_key_blocks ( info -> s -> key_cache , info -> s -> kfile , FLUSH_FORCE_WRITE ) ;\n size = mysql_file_seek ( info -> s -> kfile , 0L , MY_SEEK_END , MYF ( MY_THREADSAFE ) ) ;\n if ( ( skr = ( my_off_t ) info -> state -> key_file_length ) != size ) {\n if ( skr > size && mi_is_any_key_active ( info -> s -> state . key_map ) ) {\n error = 1 ;\n mi_check_print_error ( param , \"Size of indexfile is: %-8s Should be: %s\" , llstr ( size , buff ) , llstr ( skr , buff2 ) ) ;\n }\n else mi_check_print_warning ( param , \"Size of indexfile is: %-8s Should be: %s\" , llstr ( size , buff ) , llstr ( skr , buff2 ) ) ;\n }\n if ( ! ( param -> testflag & T_VERY_SILENT ) && ! ( info -> s -> options & HA_OPTION_COMPRESS_RECORD ) && ulonglong2double ( info -> state -> key_file_length ) > ulonglong2double ( info -> s -> base . margin_key_file_length ) * 0.9 ) mi_check_print_warning ( param , \"Keyfile is almost full, %10s of %10s used\" , llstr ( info -> state -> key_file_length , buff ) , llstr ( info -> s -> base . max_key_file_length - 1 , buff ) ) ;\n size = mysql_file_seek ( info -> dfile , 0L , MY_SEEK_END , MYF ( 0 ) ) ;\n skr = ( my_off_t ) info -> state -> data_file_length ;\n if ( info -> s -> options & HA_OPTION_COMPRESS_RECORD ) skr += MEMMAP_EXTRA_MARGIN ;\n # ifdef USE_RELOC if ( info -> data_file_type == STATIC_RECORD && skr < ( my_off_t ) info -> s -> base . reloc * info -> s -> base . min_pack_length ) skr = ( my_off_t ) info -> s -> base . reloc * info -> s -> base . min_pack_length ;\n # endif if ( skr != size ) {\n info -> state -> data_file_length = size ;\n if ( skr > size && skr != size + MEMMAP_EXTRA_MARGIN ) {\n error = 1 ;\n mi_check_print_error ( param , \"Size of datafile is: %-9s Should be: %s\" , llstr ( size , buff ) , llstr ( skr , buff2 ) ) ;\n param -> testflag |= T_RETRY_WITHOUT_QUICK ;\n }\n else {\n mi_check_print_warning ( param , \"Size of datafile is: %-9s Should be: %s\" , llstr ( size , buff ) , llstr ( skr , buff2 ) ) ;\n }\n }\n if ( ! ( param -> testflag & T_VERY_SILENT ) && ! ( info -> s -> options & HA_OPTION_COMPRESS_RECORD ) && ulonglong2double ( info -> state -> data_file_length ) > ( ulonglong2double ( info -> s -> base . max_data_file_length ) * 0.9 ) ) mi_check_print_warning ( param , \"Datafile is almost full, %10s of %10s used\" , llstr ( info -> state -> data_file_length , buff ) , llstr ( info -> s -> base . max_data_file_length - 1 , buff2 ) ) ;\n DBUG_RETURN ( error ) ;\n }", "idx": 1035}
{"hash": -8638406710431929037, "project": "debian", "size": 32, "label": 0, "functionSource": "static bfd_boolean srec_write_symbols ( bfd * abfd ) {\n int i ;\n int count = bfd_get_symcount ( abfd ) ;\n if ( count ) {\n bfd_size_type len ;\n asymbol * * table = bfd_get_outsymbols ( abfd ) ;\n len = strlen ( abfd -> filename ) ;\n if ( bfd_bwrite ( \"$$ \" , ( bfd_size_type ) 3 , abfd ) != 3 || bfd_bwrite ( abfd -> filename , len , abfd ) != len || bfd_bwrite ( \"\\r\\n\" , ( bfd_size_type ) 2 , abfd ) != 2 ) return FALSE ;\n for ( i = 0 ;\n i < count ;\n i ++ ) {\n asymbol * s = table [ i ] ;\n if ( ! bfd_is_local_label ( abfd , s ) && ( s -> flags & BSF_DEBUGGING ) == 0 ) {\n char buf [ 43 ] , * p ;\n len = strlen ( s -> name ) ;\n if ( bfd_bwrite ( \" \" , ( bfd_size_type ) 2 , abfd ) != 2 || bfd_bwrite ( s -> name , len , abfd ) != len ) return FALSE ;\n sprintf_vma ( buf + 2 , ( s -> value + s -> section -> output_section -> lma + s -> section -> output_offset ) ) ;\n p = buf + 2 ;\n while ( p [ 0 ] == '0' && p [ 1 ] != 0 ) p ++ ;\n len = strlen ( p ) ;\n p [ len ] = '\\r' ;\n p [ len + 1 ] = '\\n' ;\n * -- p = '$' ;\n * -- p = ' ' ;\n len += 4 ;\n if ( bfd_bwrite ( p , len , abfd ) != len ) return FALSE ;\n }\n }\n if ( bfd_bwrite ( \"$$ \\r\\n\" , ( bfd_size_type ) 5 , abfd ) != 5 ) return FALSE ;\n }\n return TRUE ;\n }", "idx": 1036}
{"hash": 1760449185745615462, "project": "debian", "size": 4, "label": 0, "functionSource": "ssize_t TSFetchReadData ( TSFetchSM fetch_sm , void * buf , size_t len ) {\n sdk_assert ( sdk_sanity_check_fetch_sm ( fetch_sm ) == TS_SUCCESS ) ;\n return ( ( FetchSM * ) fetch_sm ) -> ext_read_data ( ( char * ) buf , len ) ;\n }", "idx": 1037}
{"hash": 6249489553242542670, "project": "debian", "size": 50, "label": 0, "functionSource": "static void config_unpeers ( config_tree * ptree ) {\n sockaddr_u peeraddr ;\n struct addrinfo hints ;\n unpeer_node * curr_unpeer ;\n struct peer * p ;\n const char * name ;\n int rc ;\n curr_unpeer = HEAD_PFIFO ( ptree -> unpeers ) ;\n for ( ;\n curr_unpeer != NULL ;\n curr_unpeer = curr_unpeer -> link ) {\n if ( curr_unpeer -> assocID ) {\n p = findpeerbyassoc ( curr_unpeer -> assocID ) ;\n if ( p != NULL ) {\n msyslog ( LOG_NOTICE , \"unpeered %s\" , stoa ( & p -> srcadr ) ) ;\n peer_clear ( p , \"GONE\" ) ;\n unpeer ( p ) ;\n }\n continue ;\n }\n memset ( & peeraddr , 0 , sizeof ( peeraddr ) ) ;\n AF ( & peeraddr ) = curr_unpeer -> addr -> type ;\n name = curr_unpeer -> addr -> address ;\n rc = getnetnum ( name , & peeraddr , 0 , t_UNK ) ;\n if ( rc > 0 ) {\n DPRINTF ( 1 , ( \"unpeer: searching for %s\\n\" , stoa ( & peeraddr ) ) ) ;\n p = findexistingpeer ( & peeraddr , NULL , NULL , - 1 ) ;\n if ( p != NULL ) {\n msyslog ( LOG_NOTICE , \"unpeered %s\" , stoa ( & peeraddr ) ) ;\n peer_clear ( p , \"GONE\" ) ;\n unpeer ( p ) ;\n }\n continue ;\n }\n for ( p = peer_list ;\n p != NULL ;\n p = p -> p_link ) if ( p -> hostname != NULL ) if ( ! strcasecmp ( p -> hostname , name ) ) break ;\n if ( p != NULL ) {\n msyslog ( LOG_NOTICE , \"unpeered %s\" , name ) ;\n peer_clear ( p , \"GONE\" ) ;\n unpeer ( p ) ;\n }\n # ifdef WORKER memset ( & hints , 0 , sizeof ( hints ) ) ;\n hints . ai_family = curr_unpeer -> addr -> type ;\n hints . ai_socktype = SOCK_DGRAM ;\n hints . ai_protocol = IPPROTO_UDP ;\n getaddrinfo_sometime ( name , \"ntp\" , & hints , INITIAL_DNS_RETRY , & unpeer_name_resolved , NULL ) ;\n # else msyslog ( LOG_ERR , \"hostname %s can not be used, please use IP address instead.\\n\" , name ) ;\n # endif }\n }", "idx": 1038}
{"hash": -4960438251319819237, "project": "chrome", "size": 6, "label": 0, "functionSource": "static const FIRSTPASS_STATS * read_frame_stats ( const TWO_PASS * p , int offset ) {\n if ( ( offset >= 0 && p -> stats_in + offset >= p -> stats_in_end ) || ( offset < 0 && p -> stats_in + offset < p -> stats_in_start ) ) {\n return NULL ;\n }\n return & p -> stats_in [ offset ] ;\n }", "idx": 1039}
{"hash": -3740862514502467070, "project": "debian", "size": 54, "label": 0, "functionSource": "static void dumpcfftopdict ( SplineFont * sf , struct alltabs * at ) {\n char * pt , * end ;\n FILE * cfff = at -> cfff ;\n DBounds b ;\n putshort ( cfff , 1 ) ;\n putc ( '\\2' , cfff ) ;\n putshort ( cfff , 1 ) ;\n at -> lenpos = ftell ( cfff ) ;\n putshort ( cfff , 0 ) ;\n dumpsid ( cfff , at , sf -> version , 0 ) ;\n dumpsid ( cfff , at , sf -> copyright , 1 ) ;\n dumpsid ( cfff , at , sf -> fullname ? sf -> fullname : sf -> fontname , 2 ) ;\n dumpsid ( cfff , at , sf -> familyname , 3 ) ;\n dumpsid ( cfff , at , sf -> weight , 4 ) ;\n if ( at -> gi . fixed_width > 0 ) dumpintoper ( cfff , 1 , ( 12 << 8 ) | 1 ) ;\n if ( sf -> italicangle != 0 ) dumpdbloper ( cfff , sf -> italicangle , ( 12 << 8 ) | 2 ) ;\n if ( sf -> upos != - 100 ) dumpdbloper ( cfff , sf -> upos , ( 12 << 8 ) | 3 ) ;\n if ( sf -> uwidth != 50 ) dumpdbloper ( cfff , sf -> uwidth , ( 12 << 8 ) | 4 ) ;\n if ( sf -> strokedfont ) {\n dumpintoper ( cfff , 2 , ( 12 << 8 ) | 5 ) ;\n dumpdbloper ( cfff , sf -> strokewidth , ( 12 << 8 ) | 8 ) ;\n }\n if ( sf -> ascent + sf -> descent != 1000 ) {\n dumpdbl ( cfff , 1.0 / ( sf -> ascent + sf -> descent ) ) ;\n dumpint ( cfff , 0 ) ;\n dumpint ( cfff , 0 ) ;\n dumpdbl ( cfff , 1.0 / ( sf -> ascent + sf -> descent ) ) ;\n dumpint ( cfff , 0 ) ;\n dumpintoper ( cfff , 0 , ( 12 << 8 ) | 7 ) ;\n }\n if ( sf -> uniqueid != - 1 && sf -> use_uniqueid ) dumpintoper ( cfff , sf -> uniqueid ? sf -> uniqueid : 4000000 + ( rand ( ) & 0x3ffff ) , 13 ) ;\n SplineFontLayerFindBounds ( sf , at -> gi . layer , & b ) ;\n at -> gi . xmin = b . minx ;\n at -> gi . ymin = b . miny ;\n at -> gi . xmax = b . maxx ;\n at -> gi . ymax = b . maxy ;\n dumpdbl ( cfff , floor ( b . minx ) ) ;\n dumpdbl ( cfff , floor ( b . miny ) ) ;\n dumpdbl ( cfff , ceil ( b . maxx ) ) ;\n dumpdbloper ( cfff , ceil ( b . maxy ) , 5 ) ;\n if ( sf -> xuid != NULL && sf -> use_xuid ) {\n pt = sf -> xuid ;\n if ( * pt == '[' ) ++ pt ;\n while ( * pt && * pt != ']' ) {\n dumpint ( cfff , strtol ( pt , & end , 10 ) ) ;\n if ( pt == end ) break ;\n for ( pt = end ;\n * pt == ' ' ;\n ++ pt ) ;\n }\n putc ( 14 , cfff ) ;\n if ( sf -> changed_since_xuidchanged ) SFIncrementXUID ( sf ) ;\n }\n }", "idx": 1040}
{"hash": 9176142195250515812, "project": "debian", "size": 10, "label": 0, "functionSource": "void prplcb_conv_add_users ( PurpleConversation * conv , GList * cbuddies , gboolean new_arrivals ) {\n struct groupchat * gc = conv -> ui_data ;\n GList * b ;\n for ( b = cbuddies ;\n b ;\n b = b -> next ) {\n PurpleConvChatBuddy * pcb = b -> data ;\n imcb_chat_add_buddy ( gc , pcb -> name ) ;\n }\n }", "idx": 1041}
{"hash": 252275190935145023, "project": "debian", "size": 18, "label": 0, "functionSource": "static void read_tx_mode_probs ( struct tx_probs * tx_probs , vp9_reader * r ) {\n int i , j ;\n for ( i = 0 ;\n i < TX_SIZE_CONTEXTS ;\n ++ i ) for ( j = 0 ;\n j < TX_SIZES - 3 ;\n ++ j ) vp9_diff_update_prob ( r , & tx_probs -> p8x8 [ i ] [ j ] ) ;\n for ( i = 0 ;\n i < TX_SIZE_CONTEXTS ;\n ++ i ) for ( j = 0 ;\n j < TX_SIZES - 2 ;\n ++ j ) vp9_diff_update_prob ( r , & tx_probs -> p16x16 [ i ] [ j ] ) ;\n for ( i = 0 ;\n i < TX_SIZE_CONTEXTS ;\n ++ i ) for ( j = 0 ;\n j < TX_SIZES - 1 ;\n ++ j ) vp9_diff_update_prob ( r , & tx_probs -> p32x32 [ i ] [ j ] ) ;\n }", "idx": 1042}
{"hash": -8884965407551053630, "project": "debian", "size": 45, "label": 0, "functionSource": "static void DeleteDecoder ( decoder_t * p_dec ) {\n decoder_owner_sys_t * p_owner = p_dec -> p_owner ;\n msg_Dbg ( p_dec , \"killing decoder fourcc `%4.4s', %u PES in FIFO\" , ( char * ) & p_dec -> fmt_in . i_codec , ( unsigned ) block_FifoCount ( p_owner -> p_fifo ) ) ;\n block_FifoEmpty ( p_owner -> p_fifo ) ;\n block_FifoRelease ( p_owner -> p_fifo ) ;\n if ( p_owner -> p_aout ) {\n aout_DecFlush ( p_owner -> p_aout ) ;\n aout_DecDelete ( p_owner -> p_aout ) ;\n input_resource_PutAout ( p_owner -> p_resource , p_owner -> p_aout ) ;\n if ( p_owner -> p_input != NULL ) input_SendEventAout ( p_owner -> p_input ) ;\n }\n if ( p_owner -> p_vout ) {\n vout_Reset ( p_owner -> p_vout ) ;\n input_resource_RequestVout ( p_owner -> p_resource , p_owner -> p_vout , NULL , 0 , true ) ;\n if ( p_owner -> p_input != NULL ) input_SendEventVout ( p_owner -> p_input ) ;\n }\n # ifdef ENABLE_SOUT if ( p_owner -> p_sout_input ) {\n sout_InputDelete ( p_owner -> p_sout_input ) ;\n es_format_Clean ( & p_owner -> sout ) ;\n }\n # endif if ( p_dec -> fmt_out . i_cat == SPU_ES ) {\n vout_thread_t * p_vout = input_resource_HoldVout ( p_owner -> p_resource ) ;\n if ( p_vout ) {\n if ( p_owner -> p_spu_vout == p_vout ) vout_FlushSubpictureChannel ( p_vout , p_owner -> i_spu_channel ) ;\n vlc_object_release ( p_vout ) ;\n }\n }\n es_format_Clean ( & p_dec -> fmt_in ) ;\n es_format_Clean ( & p_dec -> fmt_out ) ;\n if ( p_dec -> p_description ) vlc_meta_Delete ( p_dec -> p_description ) ;\n es_format_Clean ( & p_owner -> fmt_description ) ;\n if ( p_owner -> p_description ) vlc_meta_Delete ( p_owner -> p_description ) ;\n if ( p_owner -> p_packetizer ) {\n module_unneed ( p_owner -> p_packetizer , p_owner -> p_packetizer -> p_module ) ;\n es_format_Clean ( & p_owner -> p_packetizer -> fmt_in ) ;\n es_format_Clean ( & p_owner -> p_packetizer -> fmt_out ) ;\n if ( p_owner -> p_packetizer -> p_description ) vlc_meta_Delete ( p_owner -> p_packetizer -> p_description ) ;\n vlc_object_release ( p_owner -> p_packetizer ) ;\n }\n vlc_cond_destroy ( & p_owner -> wait_acknowledge ) ;\n vlc_cond_destroy ( & p_owner -> wait_request ) ;\n vlc_mutex_destroy ( & p_owner -> lock ) ;\n vlc_object_release ( p_dec ) ;\n free ( p_owner ) ;\n }", "idx": 1043}
{"hash": 6250095321513210169, "project": "debian", "size": 3, "label": 0, "functionSource": "void rfbNewClientConnection ( rfbScreenInfoPtr rfbScreen , int sock ) {\n rfbNewClient ( rfbScreen , sock ) ;\n }", "idx": 1044}
{"hash": 6675626110148442062, "project": "debian", "size": 41, "label": 0, "functionSource": "static int mem_write ( jas_stream_obj_t * obj , char * buf , int cnt ) {\n int n ;\n int ret ;\n jas_stream_memobj_t * m = ( jas_stream_memobj_t * ) obj ;\n long newbufsize ;\n long newpos ;\n assert ( buf ) ;\n assert ( cnt >= 0 ) ;\n newpos = m -> pos_ + cnt ;\n if ( newpos > m -> bufsize_ && m -> growable_ ) {\n newbufsize = m -> bufsize_ ;\n while ( newbufsize < newpos ) {\n newbufsize <<= 1 ;\n assert ( newbufsize >= 0 ) ;\n }\n if ( mem_resize ( m , newbufsize ) ) {\n return - 1 ;\n }\n }\n if ( m -> pos_ > m -> len_ ) {\n n = JAS_MIN ( m -> pos_ , m -> bufsize_ ) - m -> len_ ;\n if ( n > 0 ) {\n memset ( & m -> buf_ [ m -> len_ ] , 0 , n ) ;\n m -> len_ += n ;\n }\n if ( m -> pos_ != m -> len_ ) {\n return 0 ;\n }\n }\n n = m -> bufsize_ - m -> pos_ ;\n ret = JAS_MIN ( n , cnt ) ;\n if ( ret > 0 ) {\n memcpy ( & m -> buf_ [ m -> pos_ ] , buf , ret ) ;\n m -> pos_ += ret ;\n }\n if ( m -> pos_ > m -> len_ ) {\n m -> len_ = m -> pos_ ;\n }\n assert ( ret == cnt ) ;\n return ret ;\n }", "idx": 1045}
{"hash": 4489017523191997023, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h225_SEQUENCE_OF_AlternateGK ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence_of ( tvb , offset , actx , tree , hf_index , ett_h225_SEQUENCE_OF_AlternateGK , SEQUENCE_OF_AlternateGK_sequence_of ) ;\n return offset ;\n }", "idx": 1046}
{"hash": 1020583704101101585, "project": "chrome", "size": 4, "label": 1, "functionSource": "static void DangerousDownloadValidated ( JNIEnv * env , const JavaParamRef < jclass > & clazz , const JavaParamRef < jobject > & tab , jint download_id , jboolean accept ) {\n TabAndroid * tab_android = TabAndroid : : GetNativeTab ( env , tab ) ;\n content : : DownloadControllerAndroid : : Get ( ) -> DangerousDownloadValidated ( tab_android -> web_contents ( ) , download_id , accept ) ;\n }", "idx": 1047}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_SET_SIZE_1_15_OF_MultiplexEntryRejectionDescriptions ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_constrained_set_of ( tvb , offset , actx , tree , hf_index , ett_h245_SET_SIZE_1_15_OF_MultiplexEntryRejectionDescriptions , SET_SIZE_1_15_OF_MultiplexEntryRejectionDescriptions_set_of , 1 , 15 , FALSE ) ;\n return offset ;\n }", "idx": 1048}
{"hash": 4837267551952413506, "project": "debian", "size": 37, "label": 0, "functionSource": "static unsigned int mszh_decomp ( const unsigned char * srcptr , int srclen , unsigned char * destptr , unsigned int destsize ) {\n unsigned char * destptr_bak = destptr ;\n unsigned char * destptr_end = destptr + destsize ;\n const unsigned char * srcptr_end = srcptr + srclen ;\n unsigned mask = * srcptr ++ ;\n unsigned maskbit = 0x80 ;\n while ( srcptr < srcptr_end && destptr < destptr_end ) {\n if ( ! ( mask & maskbit ) ) {\n memcpy ( destptr , srcptr , 4 ) ;\n destptr += 4 ;\n srcptr += 4 ;\n }\n else {\n unsigned ofs = bytestream_get_le16 ( & srcptr ) ;\n unsigned cnt = ( ofs >> 11 ) + 1 ;\n ofs &= 0x7ff ;\n ofs = FFMIN ( ofs , destptr - destptr_bak ) ;\n cnt *= 4 ;\n cnt = FFMIN ( cnt , destptr_end - destptr ) ;\n av_memcpy_backptr ( destptr , ofs , cnt ) ;\n destptr += cnt ;\n }\n maskbit >>= 1 ;\n if ( ! maskbit ) {\n mask = * srcptr ++ ;\n while ( ! mask ) {\n if ( destptr_end - destptr < 32 || srcptr_end - srcptr < 32 ) break ;\n memcpy ( destptr , srcptr , 32 ) ;\n destptr += 32 ;\n srcptr += 32 ;\n mask = * srcptr ++ ;\n }\n maskbit = 0x80 ;\n }\n }\n return destptr - destptr_bak ;\n }", "idx": 1049}
{"hash": -8028756826159773630, "project": "debian", "size": 27, "label": 0, "functionSource": "int ReadOffset ( ArchiveHandle * AH , pgoff_t * o ) {\n int i ;\n int off ;\n int offsetFlg ;\n * o = 0 ;\n if ( AH -> version < K_VERS_1_7 ) {\n i = ReadInt ( AH ) ;\n if ( i < 0 ) return K_OFFSET_POS_NOT_SET ;\n else if ( i == 0 ) return K_OFFSET_NO_DATA ;\n * o = ( pgoff_t ) i ;\n return K_OFFSET_POS_SET ;\n }\n offsetFlg = ( * AH -> ReadBytePtr ) ( AH ) & 0xFF ;\n switch ( offsetFlg ) {\n case K_OFFSET_POS_NOT_SET : case K_OFFSET_NO_DATA : case K_OFFSET_POS_SET : break ;\n default : exit_horribly ( modulename , \"unexpected data offset flag %d\\n\" , offsetFlg ) ;\n }\n for ( off = 0 ;\n off < AH -> offSize ;\n off ++ ) {\n if ( off < sizeof ( pgoff_t ) ) * o |= ( ( pgoff_t ) ( ( * AH -> ReadBytePtr ) ( AH ) ) ) << ( off * 8 ) ;\n else {\n if ( ( * AH -> ReadBytePtr ) ( AH ) != 0 ) exit_horribly ( modulename , \"file offset in dump file is too large\\n\" ) ;\n }\n }\n return offsetFlg ;\n }", "idx": 1050}
{"hash": 4489017523191997023, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h225_T_conferenceGoal ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_T_conferenceGoal , T_conferenceGoal_choice , NULL ) ;\n return offset ;\n }", "idx": 1051}
{"hash": -4527380754569407959, "project": "chrome", "size": 6, "label": 1, "functionSource": "static hb_segment_properties_t * segment_properties_reference ( hb_segment_properties_t * g ) {\n hb_segment_properties_t * c = ( hb_segment_properties_t * ) calloc ( 1 , sizeof ( hb_segment_properties_t ) ) ;\n if ( unlikely ( ! c ) ) return NULL ;\n * c = * g ;\n return c ;\n }", "idx": 1052}
{"hash": 3599206110384554647, "project": "debian", "size": 3, "label": 0, "functionSource": "int X509_REQ_get_attr_by_OBJ ( const X509_REQ * req , ASN1_OBJECT * obj , int lastpos ) {\n return X509at_get_attr_by_OBJ ( req -> req_info -> attributes , obj , lastpos ) ;\n }", "idx": 1053}
{"hash": 7295169435648525618, "project": "debian", "size": 59, "label": 0, "functionSource": "static int search_candidates ( Operation * op , SlapReply * rs , Entry * e , IdScopes * isc , MDB_cursor * mci , ID * ids , ID * stack ) {\n struct mdb_info * mdb = ( struct mdb_info * ) op -> o_bd -> be_private ;\n int rc , depth = 1 ;\n Filter * f , rf , xf , nf , sf ;\n AttributeAssertion aa_ref = ATTRIBUTEASSERTION_INIT ;\n AttributeAssertion aa_subentry = ATTRIBUTEASSERTION_INIT ;\n Debug ( LDAP_DEBUG_TRACE , \"search_candidates: base=\\\"%s\\\" (0x%08lx) scope=%d\\n\" , e -> e_nname . bv_val , ( long ) e -> e_id , op -> oq_search . rs_scope ) ;\n f = op -> oq_search . rs_filter ;\n if ( ! oc_filter ( op -> oq_search . rs_filter , 1 , & depth ) && ! get_subentries_visibility ( op ) ) {\n if ( ! get_manageDSAit ( op ) && ! get_domainScope ( op ) ) {\n struct berval bv_ref = BER_BVC ( \"referral\" ) ;\n rf . f_choice = LDAP_FILTER_EQUALITY ;\n rf . f_ava = & aa_ref ;\n rf . f_av_desc = slap_schema . si_ad_objectClass ;\n rf . f_av_value = bv_ref ;\n rf . f_next = f ;\n xf . f_or = & rf ;\n xf . f_choice = LDAP_FILTER_OR ;\n xf . f_next = NULL ;\n f = & xf ;\n depth ++ ;\n }\n }\n if ( get_subentries_visibility ( op ) ) {\n struct berval bv_subentry = BER_BVC ( \"subentry\" ) ;\n sf . f_choice = LDAP_FILTER_EQUALITY ;\n sf . f_ava = & aa_subentry ;\n sf . f_av_desc = slap_schema . si_ad_objectClass ;\n sf . f_av_value = bv_subentry ;\n sf . f_next = f ;\n nf . f_choice = LDAP_FILTER_AND ;\n nf . f_and = & sf ;\n nf . f_next = NULL ;\n f = & nf ;\n depth ++ ;\n }\n if ( depth + 1 > mdb -> mi_search_stack_depth ) {\n stack = ch_malloc ( ( depth + 1 ) * MDB_IDL_UM_SIZE * sizeof ( ID ) ) ;\n }\n if ( op -> ors_deref & LDAP_DEREF_SEARCHING ) {\n rc = search_aliases ( op , rs , e -> e_id , isc , mci , stack ) ;\n }\n else {\n rc = LDAP_SUCCESS ;\n }\n if ( rc == LDAP_SUCCESS ) {\n rc = mdb_filter_candidates ( op , isc -> mt , f , ids , stack , stack + MDB_IDL_UM_SIZE ) ;\n }\n if ( depth + 1 > mdb -> mi_search_stack_depth ) {\n ch_free ( stack ) ;\n }\n if ( rc ) {\n Debug ( LDAP_DEBUG_TRACE , \"mdb_search_candidates: failed (rc=%d)\\n\" , rc , NULL , NULL ) ;\n }\n else {\n Debug ( LDAP_DEBUG_TRACE , \"mdb_search_candidates: id=%ld first=%ld last=%ld\\n\" , ( long ) ids [ 0 ] , ( long ) MDB_IDL_FIRST ( ids ) , ( long ) MDB_IDL_LAST ( ids ) ) ;\n }\n return rc ;\n }", "idx": 1054}
{"hash": -8721757784652752372, "project": "debian", "size": 331, "label": 0, "functionSource": "static jpc_enc_cp_t * cp_create ( const char * optstr , jas_image_t * image ) {\n jpc_enc_cp_t * cp ;\n jas_tvparser_t * tvp ;\n int ret ;\n int numilyrrates ;\n double * ilyrrates ;\n int i ;\n int tagid ;\n jpc_enc_tcp_t * tcp ;\n jpc_enc_tccp_t * tccp ;\n jpc_enc_ccp_t * ccp ;\n int cmptno ;\n uint_fast16_t rlvlno ;\n uint_fast16_t prcwidthexpn ;\n uint_fast16_t prcheightexpn ;\n bool enablemct ;\n uint_fast32_t jp2overhead ;\n uint_fast16_t lyrno ;\n uint_fast32_t hsteplcm ;\n uint_fast32_t vsteplcm ;\n bool mctvalid ;\n tvp = 0 ;\n cp = 0 ;\n ilyrrates = 0 ;\n numilyrrates = 0 ;\n if ( ! ( cp = jas_malloc ( sizeof ( jpc_enc_cp_t ) ) ) ) {\n goto error ;\n }\n prcwidthexpn = 15 ;\n prcheightexpn = 15 ;\n enablemct = true ;\n jp2overhead = 0 ;\n cp -> ccps = 0 ;\n cp -> debug = 0 ;\n cp -> imgareatlx = UINT_FAST32_MAX ;\n cp -> imgareatly = UINT_FAST32_MAX ;\n cp -> refgrdwidth = 0 ;\n cp -> refgrdheight = 0 ;\n cp -> tilegrdoffx = UINT_FAST32_MAX ;\n cp -> tilegrdoffy = UINT_FAST32_MAX ;\n cp -> tilewidth = 0 ;\n cp -> tileheight = 0 ;\n cp -> numcmpts = jas_image_numcmpts ( image ) ;\n hsteplcm = 1 ;\n vsteplcm = 1 ;\n for ( cmptno = 0 ;\n cmptno < jas_image_numcmpts ( image ) ;\n ++ cmptno ) {\n if ( jas_image_cmptbrx ( image , cmptno ) + jas_image_cmpthstep ( image , cmptno ) <= jas_image_brx ( image ) || jas_image_cmptbry ( image , cmptno ) + jas_image_cmptvstep ( image , cmptno ) <= jas_image_bry ( image ) ) {\n jas_eprintf ( \"unsupported image type\\n\" ) ;\n goto error ;\n }\n hsteplcm *= jas_image_cmpthstep ( image , cmptno ) ;\n vsteplcm *= jas_image_cmptvstep ( image , cmptno ) ;\n }\n if ( ! ( cp -> ccps = jas_alloc2 ( cp -> numcmpts , sizeof ( jpc_enc_ccp_t ) ) ) ) {\n goto error ;\n }\n for ( cmptno = 0 , ccp = cp -> ccps ;\n cmptno < JAS_CAST ( int , cp -> numcmpts ) ;\n ++ cmptno , ++ ccp ) {\n ccp -> sampgrdstepx = jas_image_cmpthstep ( image , cmptno ) ;\n ccp -> sampgrdstepy = jas_image_cmptvstep ( image , cmptno ) ;\n ccp -> sampgrdsubstepx = 0 ;\n ccp -> sampgrdsubstepx = 0 ;\n ccp -> prec = jas_image_cmptprec ( image , cmptno ) ;\n ccp -> sgnd = jas_image_cmptsgnd ( image , cmptno ) ;\n ccp -> numstepsizes = 0 ;\n memset ( ccp -> stepsizes , 0 , sizeof ( ccp -> stepsizes ) ) ;\n }\n cp -> rawsize = jas_image_rawsize ( image ) ;\n cp -> totalsize = UINT_FAST32_MAX ;\n tcp = & cp -> tcp ;\n tcp -> csty = 0 ;\n tcp -> intmode = true ;\n tcp -> prg = JPC_COD_LRCPPRG ;\n tcp -> numlyrs = 1 ;\n tcp -> ilyrrates = 0 ;\n tccp = & cp -> tccp ;\n tccp -> csty = 0 ;\n tccp -> maxrlvls = 6 ;\n tccp -> cblkwidthexpn = 6 ;\n tccp -> cblkheightexpn = 6 ;\n tccp -> cblksty = 0 ;\n tccp -> numgbits = 2 ;\n if ( ! ( tvp = jas_tvparser_create ( optstr ? optstr : \"\" ) ) ) {\n goto error ;\n }\n while ( ! ( ret = jas_tvparser_next ( tvp ) ) ) {\n switch ( jas_taginfo_nonull ( jas_taginfos_lookup ( encopts , jas_tvparser_gettag ( tvp ) ) ) -> id ) {\n case OPT_DEBUG : cp -> debug = atoi ( jas_tvparser_getval ( tvp ) ) ;\n break ;\n case OPT_IMGAREAOFFX : cp -> imgareatlx = atoi ( jas_tvparser_getval ( tvp ) ) ;\n break ;\n case OPT_IMGAREAOFFY : cp -> imgareatly = atoi ( jas_tvparser_getval ( tvp ) ) ;\n break ;\n case OPT_TILEGRDOFFX : cp -> tilegrdoffx = atoi ( jas_tvparser_getval ( tvp ) ) ;\n break ;\n case OPT_TILEGRDOFFY : cp -> tilegrdoffy = atoi ( jas_tvparser_getval ( tvp ) ) ;\n break ;\n case OPT_TILEWIDTH : cp -> tilewidth = atoi ( jas_tvparser_getval ( tvp ) ) ;\n break ;\n case OPT_TILEHEIGHT : cp -> tileheight = atoi ( jas_tvparser_getval ( tvp ) ) ;\n break ;\n case OPT_PRCWIDTH : prcwidthexpn = jpc_floorlog2 ( atoi ( jas_tvparser_getval ( tvp ) ) ) ;\n break ;\n case OPT_PRCHEIGHT : prcheightexpn = jpc_floorlog2 ( atoi ( jas_tvparser_getval ( tvp ) ) ) ;\n break ;\n case OPT_CBLKWIDTH : tccp -> cblkwidthexpn = jpc_floorlog2 ( atoi ( jas_tvparser_getval ( tvp ) ) ) ;\n break ;\n case OPT_CBLKHEIGHT : tccp -> cblkheightexpn = jpc_floorlog2 ( atoi ( jas_tvparser_getval ( tvp ) ) ) ;\n break ;\n case OPT_MODE : if ( ( tagid = jas_taginfo_nonull ( jas_taginfos_lookup ( modetab , jas_tvparser_getval ( tvp ) ) ) -> id ) < 0 ) {\n jas_eprintf ( \"ignoring invalid mode %s\\n\" , jas_tvparser_getval ( tvp ) ) ;\n }\n else {\n tcp -> intmode = ( tagid == MODE_INT ) ;\n }\n break ;\n case OPT_PRG : if ( ( tagid = jas_taginfo_nonull ( jas_taginfos_lookup ( prgordtab , jas_tvparser_getval ( tvp ) ) ) -> id ) < 0 ) {\n jas_eprintf ( \"ignoring invalid progression order %s\\n\" , jas_tvparser_getval ( tvp ) ) ;\n }\n else {\n tcp -> prg = tagid ;\n }\n break ;\n case OPT_NOMCT : enablemct = false ;\n break ;\n case OPT_MAXRLVLS : tccp -> maxrlvls = atoi ( jas_tvparser_getval ( tvp ) ) ;\n break ;\n case OPT_SOP : cp -> tcp . csty |= JPC_COD_SOP ;\n break ;\n case OPT_EPH : cp -> tcp . csty |= JPC_COD_EPH ;\n break ;\n case OPT_LAZY : tccp -> cblksty |= JPC_COX_LAZY ;\n break ;\n case OPT_TERMALL : tccp -> cblksty |= JPC_COX_TERMALL ;\n break ;\n case OPT_SEGSYM : tccp -> cblksty |= JPC_COX_SEGSYM ;\n break ;\n case OPT_VCAUSAL : tccp -> cblksty |= JPC_COX_VSC ;\n break ;\n case OPT_RESET : tccp -> cblksty |= JPC_COX_RESET ;\n break ;\n case OPT_PTERM : tccp -> cblksty |= JPC_COX_PTERM ;\n break ;\n case OPT_NUMGBITS : cp -> tccp . numgbits = atoi ( jas_tvparser_getval ( tvp ) ) ;\n break ;\n case OPT_RATE : if ( ratestrtosize ( jas_tvparser_getval ( tvp ) , cp -> rawsize , & cp -> totalsize ) ) {\n jas_eprintf ( \"ignoring bad rate specifier %s\\n\" , jas_tvparser_getval ( tvp ) ) ;\n }\n break ;\n case OPT_ILYRRATES : if ( jpc_atoaf ( jas_tvparser_getval ( tvp ) , & numilyrrates , & ilyrrates ) ) {\n jas_eprintf ( \"warning: invalid intermediate layer rates specifier ignored (%s)\\n\" , jas_tvparser_getval ( tvp ) ) ;\n }\n break ;\n case OPT_JP2OVERHEAD : jp2overhead = atoi ( jas_tvparser_getval ( tvp ) ) ;\n break ;\n default : jas_eprintf ( \"warning: ignoring invalid option %s\\n\" , jas_tvparser_gettag ( tvp ) ) ;\n break ;\n }\n }\n jas_tvparser_destroy ( tvp ) ;\n tvp = 0 ;\n if ( cp -> totalsize != UINT_FAST32_MAX ) {\n cp -> totalsize = ( cp -> totalsize > jp2overhead ) ? ( cp -> totalsize - jp2overhead ) : 0 ;\n }\n if ( cp -> imgareatlx == UINT_FAST32_MAX ) {\n cp -> imgareatlx = 0 ;\n }\n else {\n if ( hsteplcm != 1 ) {\n jas_eprintf ( \"warning: overriding imgareatlx value\\n\" ) ;\n }\n cp -> imgareatlx *= hsteplcm ;\n }\n if ( cp -> imgareatly == UINT_FAST32_MAX ) {\n cp -> imgareatly = 0 ;\n }\n else {\n if ( vsteplcm != 1 ) {\n jas_eprintf ( \"warning: overriding imgareatly value\\n\" ) ;\n }\n cp -> imgareatly *= vsteplcm ;\n }\n cp -> refgrdwidth = cp -> imgareatlx + jas_image_width ( image ) ;\n cp -> refgrdheight = cp -> imgareatly + jas_image_height ( image ) ;\n if ( cp -> tilegrdoffx == UINT_FAST32_MAX ) {\n cp -> tilegrdoffx = cp -> imgareatlx ;\n }\n if ( cp -> tilegrdoffy == UINT_FAST32_MAX ) {\n cp -> tilegrdoffy = cp -> imgareatly ;\n }\n if ( ! cp -> tilewidth ) {\n cp -> tilewidth = cp -> refgrdwidth - cp -> tilegrdoffx ;\n }\n if ( ! cp -> tileheight ) {\n cp -> tileheight = cp -> refgrdheight - cp -> tilegrdoffy ;\n }\n if ( cp -> numcmpts == 3 ) {\n mctvalid = true ;\n for ( cmptno = 0 ;\n cmptno < jas_image_numcmpts ( image ) ;\n ++ cmptno ) {\n if ( jas_image_cmptprec ( image , cmptno ) != jas_image_cmptprec ( image , 0 ) || jas_image_cmptsgnd ( image , cmptno ) != jas_image_cmptsgnd ( image , 0 ) || jas_image_cmptwidth ( image , cmptno ) != jas_image_cmptwidth ( image , 0 ) || jas_image_cmptheight ( image , cmptno ) != jas_image_cmptheight ( image , 0 ) ) {\n mctvalid = false ;\n }\n }\n }\n else {\n mctvalid = false ;\n }\n if ( mctvalid && enablemct && jas_clrspc_fam ( jas_image_clrspc ( image ) ) != JAS_CLRSPC_FAM_RGB ) {\n jas_eprintf ( \"warning: color space apparently not RGB\\n\" ) ;\n }\n if ( mctvalid && enablemct && jas_clrspc_fam ( jas_image_clrspc ( image ) ) == JAS_CLRSPC_FAM_RGB ) {\n tcp -> mctid = ( tcp -> intmode ) ? ( JPC_MCT_RCT ) : ( JPC_MCT_ICT ) ;\n }\n else {\n tcp -> mctid = JPC_MCT_NONE ;\n }\n tccp -> qmfbid = ( tcp -> intmode ) ? ( JPC_COX_RFT ) : ( JPC_COX_INS ) ;\n for ( rlvlno = 0 ;\n rlvlno < tccp -> maxrlvls ;\n ++ rlvlno ) {\n tccp -> prcwidthexpns [ rlvlno ] = prcwidthexpn ;\n tccp -> prcheightexpns [ rlvlno ] = prcheightexpn ;\n }\n if ( prcwidthexpn != 15 || prcheightexpn != 15 ) {\n tccp -> csty |= JPC_COX_PRT ;\n }\n if ( ! cp -> tilewidth ) {\n jas_eprintf ( \"invalid tile width %lu\\n\" , ( unsigned long ) cp -> tilewidth ) ;\n goto error ;\n }\n if ( ! cp -> tileheight ) {\n jas_eprintf ( \"invalid tile height %lu\\n\" , ( unsigned long ) cp -> tileheight ) ;\n goto error ;\n }\n if ( cp -> tilegrdoffx > cp -> imgareatlx || cp -> tilegrdoffy > cp -> imgareatly || cp -> tilegrdoffx + cp -> tilewidth < cp -> imgareatlx || cp -> tilegrdoffy + cp -> tileheight < cp -> imgareatly ) {\n jas_eprintf ( \"invalid tile grid offset (%lu, %lu)\\n\" , ( unsigned long ) cp -> tilegrdoffx , ( unsigned long ) cp -> tilegrdoffy ) ;\n goto error ;\n }\n cp -> numhtiles = JPC_CEILDIV ( cp -> refgrdwidth - cp -> tilegrdoffx , cp -> tilewidth ) ;\n cp -> numvtiles = JPC_CEILDIV ( cp -> refgrdheight - cp -> tilegrdoffy , cp -> tileheight ) ;\n cp -> numtiles = cp -> numhtiles * cp -> numvtiles ;\n if ( ilyrrates && numilyrrates > 0 ) {\n tcp -> numlyrs = numilyrrates + 1 ;\n if ( ! ( tcp -> ilyrrates = jas_alloc2 ( ( tcp -> numlyrs - 1 ) , sizeof ( jpc_fix_t ) ) ) ) {\n goto error ;\n }\n for ( i = 0 ;\n i < JAS_CAST ( int , tcp -> numlyrs - 1 ) ;\n ++ i ) {\n tcp -> ilyrrates [ i ] = jpc_dbltofix ( ilyrrates [ i ] ) ;\n }\n }\n if ( cp -> totalsize == UINT_FAST32_MAX && ( ! cp -> tcp . intmode ) ) {\n jas_eprintf ( \"cannot use real mode for lossless coding\\n\" ) ;\n goto error ;\n }\n if ( prcwidthexpn > 15 ) {\n jas_eprintf ( \"invalid precinct width\\n\" ) ;\n goto error ;\n }\n if ( prcheightexpn > 15 ) {\n jas_eprintf ( \"invalid precinct height\\n\" ) ;\n goto error ;\n }\n if ( cp -> tccp . cblkwidthexpn < 2 || cp -> tccp . cblkwidthexpn > 12 ) {\n jas_eprintf ( \"invalid code block width %d\\n\" , JPC_POW2 ( cp -> tccp . cblkwidthexpn ) ) ;\n goto error ;\n }\n if ( cp -> tccp . cblkheightexpn < 2 || cp -> tccp . cblkheightexpn > 12 ) {\n jas_eprintf ( \"invalid code block height %d\\n\" , JPC_POW2 ( cp -> tccp . cblkheightexpn ) ) ;\n goto error ;\n }\n if ( cp -> tccp . cblkwidthexpn + cp -> tccp . cblkheightexpn > 12 ) {\n jas_eprintf ( \"code block size too large\\n\" ) ;\n goto error ;\n }\n if ( cp -> tcp . numlyrs > 16384 ) {\n jas_eprintf ( \"too many layers\\n\" ) ;\n goto error ;\n }\n if ( cp -> tccp . maxrlvls < 1 ) {\n jas_eprintf ( \"must be at least one resolution level\\n\" ) ;\n goto error ;\n }\n if ( cp -> tccp . numgbits > 8 ) {\n jas_eprintf ( \"invalid number of guard bits\\n\" ) ;\n goto error ;\n }\n if ( cp -> totalsize != UINT_FAST32_MAX && cp -> totalsize > cp -> rawsize ) {\n jas_eprintf ( \"warning: specified rate is unreasonably large (%lu > %lu)\\n\" , ( unsigned long ) cp -> totalsize , ( unsigned long ) cp -> rawsize ) ;\n }\n if ( tcp -> numlyrs > 1 ) {\n for ( lyrno = 0 ;\n lyrno + 2 < tcp -> numlyrs ;\n ++ lyrno ) {\n if ( tcp -> ilyrrates [ lyrno ] >= tcp -> ilyrrates [ lyrno + 1 ] ) {\n jas_eprintf ( \"intermediate layer rates must increase monotonically\\n\" ) ;\n goto error ;\n }\n }\n if ( cp -> totalsize != UINT_FAST32_MAX ) {\n for ( lyrno = 0 ;\n lyrno < tcp -> numlyrs - 1 ;\n ++ lyrno ) {\n if ( jpc_fixtodbl ( tcp -> ilyrrates [ lyrno ] ) > ( ( double ) cp -> totalsize ) / cp -> rawsize ) {\n jas_eprintf ( \"warning: intermediate layer rates must be less than overall rate\\n\" ) ;\n goto error ;\n }\n }\n }\n }\n if ( ilyrrates ) {\n jas_free ( ilyrrates ) ;\n }\n return cp ;\n error : if ( ilyrrates ) {\n jas_free ( ilyrrates ) ;\n }\n if ( tvp ) {\n jas_tvparser_destroy ( tvp ) ;\n }\n if ( cp ) {\n jpc_enc_cp_destroy ( cp ) ;\n }\n return 0 ;\n }", "idx": 1055}
{"hash": -7990991774694156606, "project": "debian", "size": 96, "label": 0, "functionSource": "static void reverse_dc_prediction ( Vp3DecodeContext * s , int first_fragment , int fragment_width , int fragment_height ) {\n # define PUL 8 # define PU 4 # define PUR 2 # define PL 1 int x , y ;\n int i = first_fragment ;\n int predicted_dc ;\n int vl , vul , vu , vur ;\n int l , ul , u , ur ;\n static const int predictor_transform [ 16 ] [ 4 ] = {\n {\n 0 , 0 , 0 , 0 }\n , {\n 0 , 0 , 0 , 128 }\n , {\n 0 , 0 , 128 , 0 }\n , {\n 0 , 0 , 53 , 75 }\n , {\n 0 , 128 , 0 , 0 }\n , {\n 0 , 64 , 0 , 64 }\n , {\n 0 , 128 , 0 , 0 }\n , {\n 0 , 0 , 53 , 75 }\n , {\n 128 , 0 , 0 , 0 }\n , {\n 0 , 0 , 0 , 128 }\n , {\n 64 , 0 , 64 , 0 }\n , {\n 0 , 0 , 53 , 75 }\n , {\n 0 , 128 , 0 , 0 }\n , {\n - 104 , 116 , 0 , 116 }\n , {\n 24 , 80 , 24 , 0 }\n , {\n - 104 , 116 , 0 , 116 }\n }\n ;\n static const unsigned char compatible_frame [ 9 ] = {\n 1 , 0 , 1 , 1 , 1 , 2 , 2 , 1 , 3 }\n ;\n int current_frame_type ;\n short last_dc [ 3 ] ;\n int transform = 0 ;\n vul = vu = vur = vl = 0 ;\n last_dc [ 0 ] = last_dc [ 1 ] = last_dc [ 2 ] = 0 ;\n for ( y = 0 ;\n y < fragment_height ;\n y ++ ) {\n for ( x = 0 ;\n x < fragment_width ;\n x ++ , i ++ ) {\n if ( s -> all_fragments [ i ] . coding_method != MODE_COPY ) {\n current_frame_type = compatible_frame [ s -> all_fragments [ i ] . coding_method ] ;\n transform = 0 ;\n if ( x ) {\n l = i - 1 ;\n vl = DC_COEFF ( l ) ;\n if ( COMPATIBLE_FRAME ( l ) ) transform |= PL ;\n }\n if ( y ) {\n u = i - fragment_width ;\n vu = DC_COEFF ( u ) ;\n if ( COMPATIBLE_FRAME ( u ) ) transform |= PU ;\n if ( x ) {\n ul = i - fragment_width - 1 ;\n vul = DC_COEFF ( ul ) ;\n if ( COMPATIBLE_FRAME ( ul ) ) transform |= PUL ;\n }\n if ( x + 1 < fragment_width ) {\n ur = i - fragment_width + 1 ;\n vur = DC_COEFF ( ur ) ;\n if ( COMPATIBLE_FRAME ( ur ) ) transform |= PUR ;\n }\n }\n if ( transform == 0 ) {\n predicted_dc = last_dc [ current_frame_type ] ;\n }\n else {\n predicted_dc = ( predictor_transform [ transform ] [ 0 ] * vul ) + ( predictor_transform [ transform ] [ 1 ] * vu ) + ( predictor_transform [ transform ] [ 2 ] * vur ) + ( predictor_transform [ transform ] [ 3 ] * vl ) ;\n predicted_dc /= 128 ;\n if ( ( transform == 15 ) || ( transform == 13 ) ) {\n if ( FFABS ( predicted_dc - vu ) > 128 ) predicted_dc = vu ;\n else if ( FFABS ( predicted_dc - vl ) > 128 ) predicted_dc = vl ;\n else if ( FFABS ( predicted_dc - vul ) > 128 ) predicted_dc = vul ;\n }\n }\n DC_COEFF ( i ) += predicted_dc ;\n last_dc [ current_frame_type ] = DC_COEFF ( i ) ;\n }\n }\n }\n }", "idx": 1056}
{"hash": 1760449185745615462, "project": "debian", "size": 6, "label": 0, "functionSource": "TSReturnCode sdk_sanity_check_alt_info ( TSHttpAltInfo info ) {\n if ( info == nullptr ) {\n return TS_ERROR ;\n }\n return TS_SUCCESS ;\n }", "idx": 1057}
{"hash": -5780611388839125875, "project": "chrome", "size": 4, "label": 0, "functionSource": "xmlGenericErrorFunc * __xmlGenericError ( void ) {\n if ( IS_MAIN_THREAD ) return ( & xmlGenericError ) ;\n else return ( & xmlGetGlobalState ( ) -> xmlGenericError ) ;\n }", "idx": 1058}
{"hash": -1315695702746584250, "project": "debian", "size": 3, "label": 0, "functionSource": "static void proto_tree_set_system_id_tvb ( field_info * fi , tvbuff_t * tvb , gint start , gint length ) {\n proto_tree_set_system_id ( fi , tvb_get_ptr ( tvb , start , length ) , length ) ;\n }", "idx": 1059}
{"hash": -7283224897680777091, "project": "chrome", "size": 38, "label": 0, "functionSource": "void vp9_loop_filter_frame_init ( VP9_COMMON * cm , int default_filt_lvl ) {\n int seg_id ;\n const int scale = 1 << ( default_filt_lvl >> 5 ) ;\n loop_filter_info_n * const lfi = & cm -> lf_info ;\n struct loopfilter * const lf = & cm -> lf ;\n const struct segmentation * const seg = & cm -> seg ;\n if ( lf -> last_sharpness_level != lf -> sharpness_level ) {\n update_sharpness ( lfi , lf -> sharpness_level ) ;\n lf -> last_sharpness_level = lf -> sharpness_level ;\n }\n for ( seg_id = 0 ;\n seg_id < MAX_SEGMENTS ;\n seg_id ++ ) {\n int lvl_seg = default_filt_lvl ;\n if ( vp9_segfeature_active ( seg , seg_id , SEG_LVL_ALT_LF ) ) {\n const int data = vp9_get_segdata ( seg , seg_id , SEG_LVL_ALT_LF ) ;\n lvl_seg = clamp ( seg -> abs_delta == SEGMENT_ABSDATA ? data : default_filt_lvl + data , 0 , MAX_LOOP_FILTER ) ;\n }\n if ( ! lf -> mode_ref_delta_enabled ) {\n vpx_memset ( lfi -> lvl [ seg_id ] , lvl_seg , sizeof ( lfi -> lvl [ seg_id ] ) ) ;\n }\n else {\n int ref , mode ;\n const int intra_lvl = lvl_seg + lf -> ref_deltas [ INTRA_FRAME ] * scale ;\n lfi -> lvl [ seg_id ] [ INTRA_FRAME ] [ 0 ] = clamp ( intra_lvl , 0 , MAX_LOOP_FILTER ) ;\n for ( ref = LAST_FRAME ;\n ref < MAX_REF_FRAMES ;\n ++ ref ) {\n for ( mode = 0 ;\n mode < MAX_MODE_LF_DELTAS ;\n ++ mode ) {\n const int inter_lvl = lvl_seg + lf -> ref_deltas [ ref ] * scale + lf -> mode_deltas [ mode ] * scale ;\n lfi -> lvl [ seg_id ] [ ref ] [ mode ] = clamp ( inter_lvl , 0 , MAX_LOOP_FILTER ) ;\n }\n }\n }\n }\n }", "idx": 1060}
{"hash": -5420171864670538459, "project": "debian", "size": 4, "label": 0, "functionSource": "static void tcg_signal_cpu_creation ( CPUState * cpu , void * data ) {\n cpu -> thread_id = qemu_get_thread_id ( ) ;\n cpu -> created = true ;\n }", "idx": 1061}
{"hash": -3725939782329394029, "project": "debian", "size": 20, "label": 0, "functionSource": "static tmsize_t _tiffReadProc ( thandle_t fd , void * buf , tmsize_t size ) {\n uint8 * ma ;\n uint64 mb ;\n DWORD n ;\n DWORD o ;\n tmsize_t p ;\n ma = ( uint8 * ) buf ;\n mb = size ;\n p = 0 ;\n while ( mb > 0 ) {\n n = 0x80000000UL ;\n if ( ( uint64 ) n > mb ) n = ( DWORD ) mb ;\n if ( ! ReadFile ( fd , ( LPVOID ) ma , n , & o , NULL ) ) return ( 0 ) ;\n ma += o ;\n mb -= o ;\n p += o ;\n if ( o != n ) break ;\n }\n return ( p ) ;\n }", "idx": 1062}
{"hash": -1111775978048960297, "project": "chrome", "size": 12, "label": 0, "functionSource": "TEST_F ( BrowsingDataRemoverImplTest , RemoveQuotaManagedDataForeverOnlyPersistent ) {\n # if BUILDFLAG ( ENABLE_EXTENSIONS ) CreateMockPolicy ( ) ;\n # endif BlockUntilBrowsingDataRemoved ( base : : Time ( ) , base : : Time : : Max ( ) , BrowsingDataRemover : : REMOVE_FILE_SYSTEMS | BrowsingDataRemover : : REMOVE_WEBSQL | BrowsingDataRemover : : REMOVE_APPCACHE | BrowsingDataRemover : : REMOVE_SERVICE_WORKERS | BrowsingDataRemover : : REMOVE_CACHE_STORAGE | BrowsingDataRemover : : REMOVE_INDEXEDDB , false ) ;\n EXPECT_EQ ( BrowsingDataRemover : : REMOVE_FILE_SYSTEMS | BrowsingDataRemover : : REMOVE_WEBSQL | BrowsingDataRemover : : REMOVE_APPCACHE | BrowsingDataRemover : : REMOVE_SERVICE_WORKERS | BrowsingDataRemover : : REMOVE_CACHE_STORAGE | BrowsingDataRemover : : REMOVE_INDEXEDDB , GetRemovalMask ( ) ) ;\n EXPECT_EQ ( BrowsingDataHelper : : UNPROTECTED_WEB , GetOriginTypeMask ( ) ) ;\n StoragePartitionRemovalData removal_data = GetStoragePartitionRemovalData ( ) ;\n EXPECT_EQ ( removal_data . remove_mask , StoragePartition : : REMOVE_DATA_MASK_FILE_SYSTEMS | StoragePartition : : REMOVE_DATA_MASK_WEBSQL | StoragePartition : : REMOVE_DATA_MASK_APPCACHE | StoragePartition : : REMOVE_DATA_MASK_SERVICE_WORKERS | StoragePartition : : REMOVE_DATA_MASK_CACHE_STORAGE | StoragePartition : : REMOVE_DATA_MASK_INDEXEDDB ) ;\n EXPECT_EQ ( removal_data . quota_storage_remove_mask , StoragePartition : : QUOTA_MANAGED_STORAGE_MASK_ALL ) ;\n EXPECT_TRUE ( removal_data . origin_matcher . Run ( kOrigin1 , mock_policy ( ) ) ) ;\n EXPECT_TRUE ( removal_data . origin_matcher . Run ( kOrigin2 , mock_policy ( ) ) ) ;\n EXPECT_TRUE ( removal_data . origin_matcher . Run ( kOrigin3 , mock_policy ( ) ) ) ;\n }", "idx": 1063}
{"hash": 9046191708840218774, "project": "debian", "size": 15, "label": 0, "functionSource": "static int tipc_nl_compat_net_set ( struct tipc_nl_compat_cmd_doit * cmd , struct sk_buff * skb , struct tipc_nl_compat_msg * msg ) {\n u32 val ;\n struct nlattr * net ;\n val = ntohl ( * ( __be32 * ) TLV_DATA ( msg -> req ) ) ;\n net = nla_nest_start ( skb , TIPC_NLA_NET ) ;\n if ( ! net ) return - EMSGSIZE ;\n if ( msg -> cmd == TIPC_CMD_SET_NODE_ADDR ) {\n if ( nla_put_u32 ( skb , TIPC_NLA_NET_ADDR , val ) ) return - EMSGSIZE ;\n }\n else if ( msg -> cmd == TIPC_CMD_SET_NETID ) {\n if ( nla_put_u32 ( skb , TIPC_NLA_NET_ID , val ) ) return - EMSGSIZE ;\n }\n nla_nest_end ( skb , net ) ;\n return 0 ;\n }", "idx": 1064}
{"hash": 8460430819945784394, "project": "debian", "size": 5, "label": 0, "functionSource": "static uint32_t _PPC_ioB_read ( target_phys_addr_t addr ) {\n uint32_t retval = 0 ;\n if ( addr == 0xBFFFFFF0 ) retval = pic_intack_read ( NULL ) ;\n return retval ;\n }", "idx": 1065}
{"hash": -1950979830238945732, "project": "debian", "size": 32, "label": 0, "functionSource": "static void gx_ttfReader__Read ( ttfReader * self , void * p , int n ) {\n gx_ttfReader * r = ( gx_ttfReader * ) self ;\n const byte * q ;\n if ( ! r -> error ) {\n if ( r -> extra_glyph_index != - 1 ) {\n q = r -> glyph_data . bits . data + r -> pos ;\n r -> error = ( ( r -> pos >= r -> glyph_data . bits . size || r -> glyph_data . bits . size - r -> pos < n ) ? gs_note_error ( gs_error_invalidfont ) : 0 ) ;\n if ( r -> error == 0 ) memcpy ( p , q , n ) ;\n }\n else {\n unsigned int cnt ;\n for ( cnt = 0 ;\n cnt < ( uint ) n ;\n cnt += r -> error ) {\n r -> error = r -> pfont -> data . string_proc ( r -> pfont , ( ulong ) r -> pos + cnt , ( ulong ) n - cnt , & q ) ;\n if ( r -> error < 0 ) break ;\n else if ( r -> error == 0 ) {\n memcpy ( ( char * ) p + cnt , q , n - cnt ) ;\n break ;\n }\n else {\n memcpy ( ( char * ) p + cnt , q , r -> error ) ;\n }\n }\n }\n }\n if ( r -> error ) {\n memset ( p , 0 , n ) ;\n return ;\n }\n r -> pos += n ;\n }", "idx": 1066}
{"hash": 6595989226414083189, "project": "debian", "size": 4, "label": 0, "functionSource": "static __inline__ __u32 __arch_swab32 ( __u32 val ) {\n __asm__ ( \"bswapl %0\" : \"=r\" ( val ) : \"0\" ( val ) ) ;\n return val ;\n }", "idx": 1067}
{"hash": -16551315108292821, "project": "debian", "size": 16, "label": 0, "functionSource": "static void dump_string ( const byte * p , size_t n , int delim ) {\n for ( ;\n n ;\n n -- , p ++ ) {\n if ( ( * p & 0x80 ) || iscntrl ( * p ) || * p == delim ) {\n if ( * p == '\\n' ) log_printf ( \"\\\\n\" ) ;\n else if ( * p == '\\r' ) log_printf ( \"\\\\r\" ) ;\n else if ( * p == '\\f' ) log_printf ( \"\\\\f\" ) ;\n else if ( * p == '\\v' ) log_printf ( \"\\\\v\" ) ;\n else if ( * p == '\\b' ) log_printf ( \"\\\\b\" ) ;\n else if ( ! * p ) log_printf ( \"\\\\0\" ) ;\n else log_printf ( \"\\\\x%02x\" , * p ) ;\n }\n else log_printf ( \"%c\" , * p ) ;\n }\n }", "idx": 1068}
{"hash": 8461266595329035000, "project": "chrome", "size": 3, "label": 0, "functionSource": "int event_priority_init ( int npriorities ) {\n return event_base_priority_init ( current_base , npriorities ) ;\n }", "idx": 1069}
{"hash": 3487452046891662469, "project": "debian", "size": 3, "label": 0, "functionSource": "static inline void qemu_put_be32s ( QEMUFile * f , const uint32_t * pv ) {\n qemu_put_be32 ( f , * pv ) ;\n }", "idx": 1070}
{"hash": -7019074708255236794, "project": "debian", "size": 15, "label": 0, "functionSource": "static void hb_fir_filter ( float * out , const float fir_coef [ HB_FIR_SIZE + 1 ] , float mem [ HB_FIR_SIZE ] , const float * in ) {\n int i , j ;\n float data [ AMRWB_SFR_SIZE_16k + HB_FIR_SIZE ] ;\n memcpy ( data , mem , HB_FIR_SIZE * sizeof ( float ) ) ;\n memcpy ( data + HB_FIR_SIZE , in , AMRWB_SFR_SIZE_16k * sizeof ( float ) ) ;\n for ( i = 0 ;\n i < AMRWB_SFR_SIZE_16k ;\n i ++ ) {\n out [ i ] = 0.0 ;\n for ( j = 0 ;\n j <= HB_FIR_SIZE ;\n j ++ ) out [ i ] += data [ i + j ] * fir_coef [ j ] ;\n }\n memcpy ( mem , data + AMRWB_SFR_SIZE_16k , HB_FIR_SIZE * sizeof ( float ) ) ;\n }", "idx": 1071}
{"hash": -6333668321124139371, "project": "debian", "size": 295, "label": 0, "functionSource": "static gint dissect_rtp ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , void * data _U_ ) {\n proto_item * ti = NULL ;\n proto_tree * volatile rtp_tree = NULL ;\n proto_tree * rtp_csrc_tree = NULL ;\n proto_tree * rtp_hext_tree = NULL ;\n guint8 octet1 , octet2 ;\n unsigned int version ;\n gboolean padding_set ;\n gboolean extension_set ;\n unsigned int csrc_count ;\n gboolean marker_set ;\n unsigned int payload_type ;\n const gchar * payload_type_str = NULL ;\n gboolean is_srtp = FALSE ;\n unsigned int i = 0 ;\n unsigned int hdr_extension_len = 0 ;\n unsigned int hdr_extension_id = 0 ;\n volatile unsigned int padding_count ;\n gint length , reported_length ;\n int data_len ;\n volatile unsigned int offset = 0 ;\n guint16 seq_num ;\n guint32 timestamp ;\n guint32 sync_src ;\n guint32 csrc_item ;\n struct _rtp_conversation_info * p_conv_data = NULL ;\n unsigned int hdrext_offset = 0 ;\n tvbuff_t * newtvb = NULL ;\n const char * pt = NULL ;\n static struct _rtp_info rtp_info_arr [ 4 ] ;\n static int rtp_info_current = 0 ;\n struct _rtp_info * rtp_info ;\n rtp_info_current ++ ;\n if ( rtp_info_current == 4 ) {\n rtp_info_current = 0 ;\n }\n rtp_info = & rtp_info_arr [ rtp_info_current ] ;\n octet1 = tvb_get_guint8 ( tvb , offset ) ;\n version = RTP_VERSION ( octet1 ) ;\n if ( version == 0 ) {\n switch ( global_rtp_version0_type ) {\n case RTP0_STUN : call_dissector ( stun_handle , tvb , pinfo , tree ) ;\n return tvb_length ( tvb ) ;\n case RTP0_CLASSICSTUN : call_dissector ( classicstun_handle , tvb , pinfo , tree ) ;\n return tvb_length ( tvb ) ;\n case RTP0_T38 : call_dissector ( t38_handle , tvb , pinfo , tree ) ;\n return tvb_length ( tvb ) ;\n case RTP0_SPRT : call_dissector ( sprt_handle , tvb , pinfo , tree ) ;\n return tvb_length ( tvb ) ;\n case RTP0_INVALID : if ( ! ( tvb_memeql ( tvb , 4 , \"ZRTP\" , 4 ) ) ) {\n call_dissector ( zrtp_handle , tvb , pinfo , tree ) ;\n return tvb_length ( tvb ) ;\n }\n default : ;\n }\n }\n rtp_info -> info_version = version ;\n if ( version != 2 ) {\n col_set_str ( pinfo -> cinfo , COL_PROTOCOL , \"RTP\" ) ;\n col_add_fstr ( pinfo -> cinfo , COL_INFO , \"Unknown RTP version %u\" , version ) ;\n if ( tree ) {\n ti = proto_tree_add_item ( tree , proto_rtp , tvb , offset , - 1 , ENC_NA ) ;\n rtp_tree = proto_item_add_subtree ( ti , ett_rtp ) ;\n proto_tree_add_uint ( rtp_tree , hf_rtp_version , tvb , offset , 1 , octet1 ) ;\n }\n return offset ;\n }\n padding_set = RTP_PADDING ( octet1 ) ;\n extension_set = RTP_EXTENSION ( octet1 ) ;\n csrc_count = RTP_CSRC_COUNT ( octet1 ) ;\n octet2 = tvb_get_guint8 ( tvb , offset + 1 ) ;\n marker_set = RTP_MARKER ( octet2 ) ;\n payload_type = RTP_PAYLOAD_TYPE ( octet2 ) ;\n if ( marker_set && payload_type >= FIRST_RTCP_CONFLICT_PAYLOAD_TYPE && payload_type <= LAST_RTCP_CONFLICT_PAYLOAD_TYPE ) {\n call_dissector ( rtcp_handle , tvb , pinfo , tree ) ;\n return tvb_length ( tvb ) ;\n }\n seq_num = tvb_get_ntohs ( tvb , offset + 2 ) ;\n timestamp = tvb_get_ntohl ( tvb , offset + 4 ) ;\n sync_src = tvb_get_ntohl ( tvb , offset + 8 ) ;\n rtp_info -> info_padding_set = padding_set ;\n rtp_info -> info_padding_count = 0 ;\n rtp_info -> info_marker_set = marker_set ;\n rtp_info -> info_is_video = FALSE ;\n rtp_info -> info_payload_type = payload_type ;\n rtp_info -> info_seq_num = seq_num ;\n rtp_info -> info_timestamp = timestamp ;\n rtp_info -> info_sync_src = sync_src ;\n rtp_info -> info_is_srtp = FALSE ;\n rtp_info -> info_setup_frame_num = 0 ;\n rtp_info -> info_payload_type_str = NULL ;\n rtp_info -> info_payload_rate = 0 ;\n length = tvb_length_remaining ( tvb , offset ) ;\n reported_length = tvb_reported_length_remaining ( tvb , offset ) ;\n if ( reported_length >= 0 && length >= reported_length ) {\n rtp_info -> info_all_data_present = TRUE ;\n rtp_info -> info_data_len = reported_length ;\n rtp_info -> info_data = tvb_get_ptr ( tvb , 0 , - 1 ) ;\n }\n else {\n rtp_info -> info_all_data_present = FALSE ;\n rtp_info -> info_data_len = 0 ;\n rtp_info -> info_data = NULL ;\n }\n get_conv_info ( pinfo , rtp_info ) ;\n p_conv_data = ( struct _rtp_conversation_info * ) p_get_proto_data ( wmem_file_scope ( ) , pinfo , proto_rtp , 0 ) ;\n if ( p_conv_data ) rtp_info -> info_is_video = p_conv_data -> is_video ;\n if ( p_conv_data && p_conv_data -> srtp_info ) is_srtp = TRUE ;\n rtp_info -> info_is_srtp = is_srtp ;\n col_set_str ( pinfo -> cinfo , COL_PROTOCOL , ( is_srtp ) ? \"SRTP\" : \"RTP\" ) ;\n p_conv_data = ( struct _rtp_conversation_info * ) p_get_proto_data ( wmem_file_scope ( ) , pinfo , proto_rtp , 0 ) ;\n # if 0 if ( p_conv_data && p_conv_data -> srtp_info ) {\n srtp_info = p_conv_data -> srtp_info ;\n if ( rtp_info -> info_all_data_present ) {\n srtp_offset = rtp_info -> info_data_len - srtp_info -> mki_len - srtp_info -> auth_tag_len ;\n }\n }\n # endif if ( p_conv_data && p_conv_data -> bta2dp_info && p_conv_data -> bta2dp_info -> codec_dissector ) {\n rtp_info -> info_payload_type_str = ( const char * ) dissector_handle_get_short_name ( p_conv_data -> bta2dp_info -> codec_dissector ) ;\n }\n else if ( p_conv_data && p_conv_data -> btvdp_info && p_conv_data -> btvdp_info -> codec_dissector ) {\n rtp_info -> info_payload_type_str = ( const char * ) dissector_handle_get_short_name ( p_conv_data -> btvdp_info -> codec_dissector ) ;\n }\n if ( ( payload_type > 95 ) && ( payload_type < 128 ) ) {\n if ( p_conv_data && p_conv_data -> rtp_dyn_payload ) {\n int sample_rate = 0 ;\n # ifdef DEBUG_CONVERSATION rtp_dump_dyn_payload ( p_conv_data -> rtp_dyn_payload ) ;\n # endif DPRINT ( ( \"looking up conversation data for dyn_pt=%d\" , payload_type ) ) ;\n if ( rtp_dyn_payload_get_full ( p_conv_data -> rtp_dyn_payload , payload_type , & payload_type_str , & sample_rate ) ) {\n DPRINT ( ( \"found conversation data for dyn_pt=%d, enc_name=%s\" , payload_type , payload_type_str ) ) ;\n rtp_info -> info_payload_type_str = payload_type_str ;\n rtp_info -> info_payload_rate = sample_rate ;\n }\n }\n }\n if ( p_conv_data && p_conv_data -> bta2dp_info ) {\n pt = ( p_conv_data -> bta2dp_info -> codec_dissector ) ? dissector_handle_get_short_name ( p_conv_data -> bta2dp_info -> codec_dissector ) : \"Unknown\" ;\n }\n else if ( p_conv_data && p_conv_data -> btvdp_info ) {\n pt = ( p_conv_data -> btvdp_info -> codec_dissector ) ? dissector_handle_get_short_name ( p_conv_data -> btvdp_info -> codec_dissector ) : \"Unknown\" ;\n }\n else {\n pt = ( payload_type_str ? payload_type_str : val_to_str_ext ( payload_type , & rtp_payload_type_vals_ext , \"Unknown (%u)\" ) ) ;\n }\n col_add_fstr ( pinfo -> cinfo , COL_INFO , \"PT=%s, SSRC=0x%X, Seq=%u, Time=%u%s\" , pt , sync_src , seq_num , timestamp , marker_set ? \", Mark\" : \"\" ) ;\n if ( tree ) {\n proto_tree * item ;\n ti = proto_tree_add_item ( tree , proto_rtp , tvb , offset , - 1 , ENC_NA ) ;\n rtp_tree = proto_item_add_subtree ( ti , ett_rtp ) ;\n if ( global_rtp_show_setup_info ) {\n show_setup_info ( tvb , pinfo , rtp_tree ) ;\n }\n proto_tree_add_uint ( rtp_tree , hf_rtp_version , tvb , offset , 1 , octet1 ) ;\n proto_tree_add_boolean ( rtp_tree , hf_rtp_padding , tvb , offset , 1 , octet1 ) ;\n proto_tree_add_boolean ( rtp_tree , hf_rtp_extension , tvb , offset , 1 , octet1 ) ;\n proto_tree_add_uint ( rtp_tree , hf_rtp_csrc_count , tvb , offset , 1 , octet1 ) ;\n offset ++ ;\n proto_tree_add_boolean ( rtp_tree , hf_rtp_marker , tvb , offset , 1 , octet2 ) ;\n proto_tree_add_uint_format ( rtp_tree , hf_rtp_payload_type , tvb , offset , 1 , octet2 , \"Payload type: %s (%u)\" , pt , payload_type ) ;\n offset ++ ;\n proto_tree_add_uint ( rtp_tree , hf_rtp_seq_nr , tvb , offset , 2 , seq_num ) ;\n if ( p_conv_data != NULL ) {\n item = proto_tree_add_uint ( rtp_tree , hf_rtp_ext_seq_nr , tvb , offset , 2 , p_conv_data -> extended_seqno ) ;\n PROTO_ITEM_SET_GENERATED ( item ) ;\n }\n offset += 2 ;\n proto_tree_add_uint ( rtp_tree , hf_rtp_timestamp , tvb , offset , 4 , timestamp ) ;\n offset += 4 ;\n proto_tree_add_uint ( rtp_tree , hf_rtp_ssrc , tvb , offset , 4 , sync_src ) ;\n offset += 4 ;\n }\n else {\n offset += 12 ;\n }\n if ( csrc_count > 0 ) {\n ti = proto_tree_add_item ( rtp_tree , hf_rtp_csrc_items , tvb , offset , csrc_count * 4 , ENC_NA ) ;\n proto_item_append_text ( ti , \" (%u items)\" , csrc_count ) ;\n rtp_csrc_tree = proto_item_add_subtree ( ti , ett_csrc_list ) ;\n for ( i = 0 ;\n i < csrc_count ;\n i ++ ) {\n csrc_item = tvb_get_ntohl ( tvb , offset ) ;\n proto_tree_add_uint_format ( rtp_csrc_tree , hf_rtp_csrc_item , tvb , offset , 4 , csrc_item , \"CSRC item %d: 0x%X\" , i , csrc_item ) ;\n offset += 4 ;\n }\n }\n if ( extension_set ) {\n hdr_extension_id = tvb_get_ntohs ( tvb , offset ) ;\n if ( tree ) proto_tree_add_uint ( rtp_tree , hf_rtp_prof_define , tvb , offset , 2 , hdr_extension_id ) ;\n offset += 2 ;\n hdr_extension_len = tvb_get_ntohs ( tvb , offset ) ;\n if ( tree ) proto_tree_add_uint ( rtp_tree , hf_rtp_length , tvb , offset , 2 , hdr_extension_len ) ;\n offset += 2 ;\n if ( hdr_extension_len > 0 ) {\n if ( tree ) {\n ti = proto_tree_add_item ( rtp_tree , hf_rtp_hdr_exts , tvb , offset , hdr_extension_len * 4 , ENC_NA ) ;\n rtp_hext_tree = proto_item_add_subtree ( ti , ett_hdr_ext ) ;\n }\n newtvb = tvb_new_subset ( tvb , offset , hdr_extension_len * 4 , hdr_extension_len * 4 ) ;\n if ( hdr_extension_id == RTP_RFC5215_ONE_BYTE_SIG ) {\n dissect_rtp_hext_rfc5215_onebyte ( newtvb , pinfo , rtp_hext_tree ) ;\n }\n else if ( ( hdr_extension_id & RTP_RFC5215_TWO_BYTE_MASK ) == RTP_RFC5215_TWO_BYTE_SIG ) {\n dissect_rtp_hext_rfc5215_twobytes ( tvb , offset - 4 , hdr_extension_id , newtvb , pinfo , rtp_hext_tree ) ;\n }\n else {\n if ( ! ( dissector_try_uint ( rtp_hdr_ext_dissector_table , hdr_extension_id , newtvb , pinfo , rtp_hext_tree ) ) ) {\n hdrext_offset = offset ;\n for ( i = 0 ;\n i < hdr_extension_len ;\n i ++ ) {\n if ( tree ) proto_tree_add_uint ( rtp_hext_tree , hf_rtp_hdr_ext , tvb , hdrext_offset , 4 , tvb_get_ntohl ( tvb , hdrext_offset ) ) ;\n hdrext_offset += 4 ;\n }\n }\n }\n }\n offset += hdr_extension_len * 4 ;\n }\n if ( padding_set ) {\n if ( tvb_length ( tvb ) < tvb_reported_length ( tvb ) ) {\n if ( tree ) proto_tree_add_text ( rtp_tree , tvb , 0 , 0 , \"Frame has padding, but not all the frame data was captured\" ) ;\n call_dissector ( data_handle , tvb_new_subset_remaining ( tvb , offset ) , pinfo , rtp_tree ) ;\n return tvb_length ( tvb ) ;\n }\n padding_count = tvb_get_guint8 ( tvb , tvb_reported_length ( tvb ) - 1 ) ;\n data_len = tvb_reported_length_remaining ( tvb , offset ) - padding_count ;\n rtp_info -> info_payload_offset = offset ;\n rtp_info -> info_payload_len = tvb_length_remaining ( tvb , offset ) ;\n rtp_info -> info_padding_count = padding_count ;\n if ( p_conv_data && p_conv_data -> bta2dp_info ) {\n if ( p_conv_data -> bta2dp_info -> codec_dissector == sbc_handle ) {\n rtp_info -> info_payload_offset += 1 ;\n rtp_info -> info_payload_len -= 1 ;\n }\n if ( p_conv_data -> bta2dp_info -> content_protection_type == BTAVDTP_CONTENT_PROTECTION_TYPE_SCMS_T ) {\n rtp_info -> info_payload_offset += 1 ;\n rtp_info -> info_payload_len -= 1 ;\n }\n }\n if ( p_conv_data && p_conv_data -> btvdp_info && p_conv_data -> bta2dp_info -> content_protection_type == BTAVDTP_CONTENT_PROTECTION_TYPE_SCMS_T ) {\n rtp_info -> info_payload_offset += 1 ;\n rtp_info -> info_payload_len -= 1 ;\n }\n if ( data_len > 0 ) {\n TRY {\n dissect_rtp_data ( tvb , pinfo , tree , rtp_tree , offset , data_len , data_len , payload_type ) ;\n }\n CATCH_ALL {\n if ( ! pinfo -> flags . in_error_pkt ) tap_queue_packet ( rtp_tap , pinfo , rtp_info ) ;\n RETHROW ;\n }\n ENDTRY ;\n offset += data_len ;\n }\n else if ( data_len < 0 ) {\n padding_count = tvb_reported_length_remaining ( tvb , offset ) ;\n }\n if ( padding_count > 1 ) {\n if ( tree ) proto_tree_add_item ( rtp_tree , hf_rtp_padding_data , tvb , offset , padding_count - 1 , ENC_NA ) ;\n offset += padding_count - 1 ;\n }\n if ( tree ) proto_tree_add_item ( rtp_tree , hf_rtp_padding_count , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n }\n else {\n rtp_info -> info_payload_offset = offset ;\n rtp_info -> info_payload_len = tvb_length_remaining ( tvb , offset ) ;\n if ( p_conv_data && p_conv_data -> bta2dp_info ) {\n if ( p_conv_data -> bta2dp_info -> codec_dissector == sbc_handle ) {\n rtp_info -> info_payload_offset += 1 ;\n rtp_info -> info_payload_len -= 1 ;\n }\n if ( p_conv_data -> bta2dp_info -> content_protection_type == BTAVDTP_CONTENT_PROTECTION_TYPE_SCMS_T ) {\n rtp_info -> info_payload_offset += 1 ;\n rtp_info -> info_payload_len -= 1 ;\n }\n }\n if ( p_conv_data && p_conv_data -> btvdp_info && p_conv_data -> bta2dp_info -> content_protection_type == BTAVDTP_CONTENT_PROTECTION_TYPE_SCMS_T ) {\n rtp_info -> info_payload_offset += 1 ;\n rtp_info -> info_payload_len -= 1 ;\n }\n if ( tvb_reported_length_remaining ( tvb , offset ) > 0 ) {\n TRY {\n dissect_rtp_data ( tvb , pinfo , tree , rtp_tree , offset , tvb_length_remaining ( tvb , offset ) , tvb_reported_length_remaining ( tvb , offset ) , payload_type ) ;\n }\n CATCH_ALL {\n if ( ! pinfo -> flags . in_error_pkt ) tap_queue_packet ( rtp_tap , pinfo , rtp_info ) ;\n RETHROW ;\n }\n ENDTRY ;\n }\n }\n if ( ! pinfo -> flags . in_error_pkt ) tap_queue_packet ( rtp_tap , pinfo , rtp_info ) ;\n return offset ;\n }", "idx": 1072}
{"hash": 1223258652239369123, "project": "debian", "size": 4, "label": 0, "functionSource": "SPL_METHOD ( SplFileObject , fpassthru ) {\n spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n RETURN_LONG ( php_stream_passthru ( intern -> u . file . stream ) ) ;\n }", "idx": 1073}
{"hash": -9032389459913766398, "project": "debian", "size": 3, "label": 0, "functionSource": "static inline void fl6_sock_release ( struct ip6_flowlabel * fl ) {\n if ( fl ) atomic_dec ( & fl -> users ) ;\n }", "idx": 1074}
{"hash": 4511225370772574632, "project": "debian", "size": 9, "label": 0, "functionSource": "static int sapi_uwsgi_ub_write ( const char * str , uint str_length TSRMLS_DC ) # endif {\n struct wsgi_request * wsgi_req = ( struct wsgi_request * ) SG ( server_context ) ;\n uwsgi_response_write_body_do ( wsgi_req , ( char * ) str , str_length ) ;\n if ( wsgi_req -> write_errors > uwsgi . write_errors_tolerance ) {\n php_handle_aborted_connection ( ) ;\n return - 1 ;\n }\n return str_length ;\n }", "idx": 1075}
{"hash": -320658364442495927, "project": "chrome", "size": 60, "label": 0, "functionSource": "void vp8_blend_mb_outer_c ( unsigned char * y , unsigned char * u , unsigned char * v , int y_1 , int u_1 , int v_1 , int alpha , int stride ) {\n int i , j ;\n int y1_const = y_1 * ( ( 1 << 16 ) - alpha ) ;\n int u1_const = u_1 * ( ( 1 << 16 ) - alpha ) ;\n int v1_const = v_1 * ( ( 1 << 16 ) - alpha ) ;\n for ( i = 0 ;\n i < 2 ;\n i ++ ) {\n for ( j = 0 ;\n j < 16 ;\n j ++ ) {\n y [ j ] = ( y [ j ] * alpha + y1_const ) >> 16 ;\n }\n y += stride ;\n }\n for ( i = 0 ;\n i < 12 ;\n i ++ ) {\n y [ 0 ] = ( y [ 0 ] * alpha + y1_const ) >> 16 ;\n y [ 1 ] = ( y [ 1 ] * alpha + y1_const ) >> 16 ;\n y [ 14 ] = ( y [ 14 ] * alpha + y1_const ) >> 16 ;\n y [ 15 ] = ( y [ 15 ] * alpha + y1_const ) >> 16 ;\n y += stride ;\n }\n for ( i = 0 ;\n i < 2 ;\n i ++ ) {\n for ( j = 0 ;\n j < 16 ;\n j ++ ) {\n y [ j ] = ( y [ j ] * alpha + y1_const ) >> 16 ;\n }\n y += stride ;\n }\n stride >>= 1 ;\n for ( j = 0 ;\n j < 8 ;\n j ++ ) {\n u [ j ] = ( u [ j ] * alpha + u1_const ) >> 16 ;\n v [ j ] = ( v [ j ] * alpha + v1_const ) >> 16 ;\n }\n u += stride ;\n v += stride ;\n for ( i = 0 ;\n i < 6 ;\n i ++ ) {\n u [ 0 ] = ( u [ 0 ] * alpha + u1_const ) >> 16 ;\n v [ 0 ] = ( v [ 0 ] * alpha + v1_const ) >> 16 ;\n u [ 7 ] = ( u [ 7 ] * alpha + u1_const ) >> 16 ;\n v [ 7 ] = ( v [ 7 ] * alpha + v1_const ) >> 16 ;\n u += stride ;\n v += stride ;\n }\n for ( j = 0 ;\n j < 8 ;\n j ++ ) {\n u [ j ] = ( u [ j ] * alpha + u1_const ) >> 16 ;\n v [ j ] = ( v [ j ] * alpha + v1_const ) >> 16 ;\n }\n }", "idx": 1076}
{"hash": -2386031673786599357, "project": "debian", "size": 21, "label": 0, "functionSource": "static gpgme_error_t gpgsm_encrypt ( void * engine , gpgme_key_t recp [ ] , gpgme_encrypt_flags_t flags , gpgme_data_t plain , gpgme_data_t ciph , int use_armor ) {\n engine_gpgsm_t gpgsm = engine ;\n gpgme_error_t err ;\n if ( ! gpgsm ) return gpg_error ( GPG_ERR_INV_VALUE ) ;\n if ( ! recp ) return gpg_error ( GPG_ERR_NOT_IMPLEMENTED ) ;\n if ( flags & GPGME_ENCRYPT_NO_ENCRYPT_TO ) {\n err = gpgsm_assuan_simple_command ( gpgsm -> assuan_ctx , \"OPTION no-encrypt-to\" , NULL , NULL ) ;\n if ( err ) return err ;\n }\n gpgsm -> input_cb . data = plain ;\n err = gpgsm_set_fd ( gpgsm , INPUT_FD , map_data_enc ( gpgsm -> input_cb . data ) ) ;\n if ( err ) return err ;\n gpgsm -> output_cb . data = ciph ;\n err = gpgsm_set_fd ( gpgsm , OUTPUT_FD , use_armor ? \"--armor\" : map_data_enc ( gpgsm -> output_cb . data ) ) ;\n if ( err ) return err ;\n gpgsm_clear_fd ( gpgsm , MESSAGE_FD ) ;\n gpgsm -> inline_data = NULL ;\n err = set_recipients ( gpgsm , recp ) ;\n if ( ! err ) err = start ( gpgsm , \"ENCRYPT\" ) ;\n return err ;\n }", "idx": 1077}
{"hash": 7749168290238234888, "project": "debian", "size": 30, "label": 0, "functionSource": "uint32_t mt_random ( mtrand * mt ) {\n uint32_t y ;\n unsigned long mag01 [ 2 ] ;\n mag01 [ 0 ] = 0 ;\n mag01 [ 1 ] = MATRIX_A ;\n if ( mt -> mt_index_ >= MT_LEN ) {\n int kk ;\n for ( kk = 0 ;\n kk < MT_LEN - MT_IA ;\n kk ++ ) {\n y = ( mt -> mt_buffer_ [ kk ] & UPPER_MASK ) | ( mt -> mt_buffer_ [ kk + 1 ] & LOWER_MASK ) ;\n mt -> mt_buffer_ [ kk ] = mt -> mt_buffer_ [ kk + MT_IA ] ^ ( y >> 1 ) ^ mag01 [ y & 0x1UL ] ;\n }\n for ( ;\n kk < MT_LEN - 1 ;\n kk ++ ) {\n y = ( mt -> mt_buffer_ [ kk ] & UPPER_MASK ) | ( mt -> mt_buffer_ [ kk + 1 ] & LOWER_MASK ) ;\n mt -> mt_buffer_ [ kk ] = mt -> mt_buffer_ [ kk + ( MT_IA - MT_LEN ) ] ^ ( y >> 1 ) ^ mag01 [ y & 0x1UL ] ;\n }\n y = ( mt -> mt_buffer_ [ MT_LEN - 1 ] & UPPER_MASK ) | ( mt -> mt_buffer_ [ 0 ] & LOWER_MASK ) ;\n mt -> mt_buffer_ [ MT_LEN - 1 ] = mt -> mt_buffer_ [ MT_IA - 1 ] ^ ( y >> 1 ) ^ mag01 [ y & 0x1UL ] ;\n mt -> mt_index_ = 0 ;\n }\n y = mt -> mt_buffer_ [ mt -> mt_index_ ++ ] ;\n y ^= ( y >> 11 ) ;\n y ^= ( y << 7 ) & 0x9d2c5680UL ;\n y ^= ( y << 15 ) & 0xefc60000UL ;\n y ^= ( y >> 18 ) ;\n return y ;\n }", "idx": 1078}
{"hash": -1270180049246846366, "project": "chrome", "size": 4, "label": 0, "functionSource": "static void _hb_face_for_data_closure_destroy ( hb_face_for_data_closure_t * closure ) {\n hb_blob_destroy ( closure -> blob ) ;\n free ( closure ) ;\n }", "idx": 1079}
{"hash": -6357438421920978642, "project": "debian", "size": 43, "label": 0, "functionSource": "int libevt_record_values_free ( libevt_record_values_t * * record_values , libcerror_error_t * * error ) {\n static char * function = \"libevt_record_values_free\" ;\n int result = 1 ;\n if ( record_values == NULL ) {\n libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_ARGUMENTS , LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE , \"%s: invalid record values.\" , function ) ;\n return ( - 1 ) ;\n }\n if ( * record_values != NULL ) {\n if ( ( * record_values ) -> source_name != NULL ) {\n if ( libfvalue_value_free ( & ( ( * record_values ) -> source_name ) , error ) != 1 ) {\n libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_FINALIZE_FAILED , \"%s: unable to free source name value.\" , function ) ;\n result = - 1 ;\n }\n }\n if ( ( * record_values ) -> computer_name != NULL ) {\n if ( libfvalue_value_free ( & ( ( * record_values ) -> computer_name ) , error ) != 1 ) {\n libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_FINALIZE_FAILED , \"%s: unable to free computer name value.\" , function ) ;\n result = - 1 ;\n }\n }\n if ( ( * record_values ) -> user_security_identifier != NULL ) {\n if ( libfvalue_value_free ( & ( ( * record_values ) -> user_security_identifier ) , error ) != 1 ) {\n libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_FINALIZE_FAILED , \"%s: unable to free user security identifier (SID).\" , function ) ;\n result = - 1 ;\n }\n }\n if ( ( * record_values ) -> strings != NULL ) {\n if ( libfvalue_value_free ( & ( ( * record_values ) -> strings ) , error ) != 1 ) {\n libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_FINALIZE_FAILED , \"%s: unable to free strings.\" , function ) ;\n result = - 1 ;\n }\n }\n if ( ( * record_values ) -> data != NULL ) {\n if ( libfvalue_value_free ( & ( ( * record_values ) -> data ) , error ) != 1 ) {\n libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_FINALIZE_FAILED , \"%s: unable to free data.\" , function ) ;\n result = - 1 ;\n }\n }\n memory_free ( * record_values ) ;\n * record_values = NULL ;\n }\n return ( result ) ;\n }", "idx": 1080}
{"hash": 2687336064028423153, "project": "chrome", "size": 11, "label": 0, "functionSource": "static void search_reverse ( void ) {\n struct search_domain * cur , * prev = NULL , * next ;\n cur = global_search_state -> head ;\n while ( cur ) {\n next = cur -> next ;\n cur -> next = prev ;\n prev = cur ;\n cur = next ;\n }\n global_search_state -> head = prev ;\n }", "idx": 1081}
{"hash": -2915908172644760936, "project": "debian", "size": 31, "label": 0, "functionSource": "static void save_bits ( WmallDecodeCtx * s , GetBitContext * gb , int len , int append ) {\n int buflen ;\n PutBitContext tmp ;\n if ( ! append ) {\n s -> frame_offset = get_bits_count ( gb ) & 7 ;\n s -> num_saved_bits = s -> frame_offset ;\n init_put_bits ( & s -> pb , s -> frame_data , MAX_FRAMESIZE ) ;\n }\n buflen = ( s -> num_saved_bits + len + 8 ) >> 3 ;\n if ( len <= 0 || buflen > MAX_FRAMESIZE ) {\n av_log_ask_for_sample ( s -> avctx , \"input buffer too small\\n\" ) ;\n s -> packet_loss = 1 ;\n return ;\n }\n s -> num_saved_bits += len ;\n if ( ! append ) {\n avpriv_copy_bits ( & s -> pb , gb -> buffer + ( get_bits_count ( gb ) >> 3 ) , s -> num_saved_bits ) ;\n }\n else {\n int align = 8 - ( get_bits_count ( gb ) & 7 ) ;\n align = FFMIN ( align , len ) ;\n put_bits ( & s -> pb , align , get_bits ( gb , align ) ) ;\n len -= align ;\n avpriv_copy_bits ( & s -> pb , gb -> buffer + ( get_bits_count ( gb ) >> 3 ) , len ) ;\n }\n skip_bits_long ( gb , len ) ;\n tmp = s -> pb ;\n flush_put_bits ( & tmp ) ;\n init_get_bits ( & s -> gb , s -> frame_data , s -> num_saved_bits ) ;\n skip_bits ( & s -> gb , s -> frame_offset ) ;\n }", "idx": 1082}
{"hash": -331579171381918893, "project": "debian", "size": 19, "label": 1, "functionSource": "static ossl_inline void lh_ ## type ## _node_usage_stats_bio ( const LHASH_OF ( type ) * lh , BIO * out ) {\n OPENSSL_LH_node_usage_stats_bio ( ( const OPENSSL_LHASH * ) lh , out ) ;\n }\n static ossl_inline void lh_ ## type ## _stats_bio ( const LHASH_OF ( type ) * lh , BIO * out ) {\n OPENSSL_LH_stats_bio ( ( const OPENSSL_LHASH * ) lh , out ) ;\n }\n static ossl_inline unsigned long lh_ ## type ## _get_down_load ( LHASH_OF ( type ) * lh ) {\n return OPENSSL_LH_get_down_load ( ( OPENSSL_LHASH * ) lh ) ;\n }\n static ossl_inline void lh_ ## type ## _set_down_load ( LHASH_OF ( type ) * lh , unsigned long dl ) {\n OPENSSL_LH_set_down_load ( ( OPENSSL_LHASH * ) lh , dl ) ;\n }\n static ossl_inline void lh_ ## type ## _doall ( LHASH_OF ( type ) * lh , void ( * doall ) ( type * ) ) {\n OPENSSL_LH_doall ( ( OPENSSL_LHASH * ) lh , ( OPENSSL_LH_DOALL_FUNC ) doall ) ;\n }\n LHASH_OF ( type ) # define IMPLEMENT_LHASH_DOALL_ARG_CONST ( type , argtype ) int_implement_lhash_doall ( type , argtype , const type ) # define IMPLEMENT_LHASH_DOALL_ARG ( type , argtype ) int_implement_lhash_doall ( type , argtype , type ) # define int_implement_lhash_doall ( type , argtype , cbargtype ) static ossl_inline void lh_ ## type ## _doall_ ## argtype ( LHASH_OF ( type ) * lh , void ( * fn ) ( cbargtype * , argtype * ) , argtype * arg ) {\n OPENSSL_LH_doall_arg ( ( OPENSSL_LHASH * ) lh , ( OPENSSL_LH_DOALL_FUNCARG ) fn , ( void * ) arg ) ;\n }\n LHASH_OF ( type ) DEFINE_LHASH_OF ( OPENSSL_STRING )", "idx": 1083}
{"hash": 1223258652239369123, "project": "debian", "size": 7, "label": 1, "functionSource": "SPL_METHOD ( DirectoryIterator , isDot ) {\n spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n if ( zend_parse_parameters_none ( ) == FAILURE ) {\n return ;\n }\n RETURN_BOOL ( spl_filesystem_is_dot ( intern -> u . dir . entry . d_name ) ) ;\n }", "idx": 1084}
{"hash": -8228664527580018723, "project": "debian", "size": 3, "label": 0, "functionSource": "int curl_mvfprintf ( FILE * whereto , const char * format , va_list ap_save ) {\n return dprintf_formatf ( whereto , fputc , format , ap_save ) ;\n }", "idx": 1085}
{"hash": 2895622461494525400, "project": "debian", "size": 55, "label": 0, "functionSource": "static void test_prepare_grant ( ) {\n int rc ;\n char query [ MAX_TEST_QUERY_LENGTH ] ;\n myheader ( \"test_prepare_grant\" ) ;\n mysql_autocommit ( mysql , TRUE ) ;\n rc = mysql_query ( mysql , \"DROP TABLE IF EXISTS test_grant\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"CREATE TABLE test_grant(a tinyint primary key auto_increment)\" ) ;\n myquery ( rc ) ;\n strxmov ( query , \"GRANT INSERT, UPDATE, SELECT ON \" , current_db , \".test_grant TO 'test_grant'@\" , opt_host ? opt_host : \"'localhost'\" , NullS ) ;\n if ( mysql_query ( mysql , query ) ) {\n myerror ( \"GRANT failed\" ) ;\n if ( mysql_errno ( mysql ) != 1047 ) exit ( 1 ) ;\n }\n else {\n MYSQL * org_mysql = mysql , * lmysql ;\n MYSQL_STMT * stmt ;\n if ( ! opt_silent ) fprintf ( stdout , \"\\n Establishing a test connection ...\" ) ;\n if ( ! ( lmysql = mysql_client_init ( NULL ) ) ) {\n myerror ( \"mysql_client_init() failed\" ) ;\n exit ( 1 ) ;\n }\n if ( ! ( mysql_real_connect ( lmysql , opt_host , \"test_grant\" , \"\" , current_db , opt_port , opt_unix_socket , 0 ) ) ) {\n myerror ( \"connection failed\" ) ;\n mysql_close ( lmysql ) ;\n exit ( 1 ) ;\n }\n lmysql -> reconnect = 1 ;\n if ( ! opt_silent ) fprintf ( stdout , \"OK\" ) ;\n mysql = lmysql ;\n rc = mysql_query ( mysql , \"INSERT INTO test_grant VALUES(NULL)\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"INSERT INTO test_grant(a) VALUES(NULL)\" ) ;\n myquery ( rc ) ;\n execute_prepare_query ( \"INSERT INTO test_grant(a) VALUES(NULL)\" , 1 ) ;\n execute_prepare_query ( \"INSERT INTO test_grant VALUES(NULL)\" , 1 ) ;\n execute_prepare_query ( \"UPDATE test_grant SET a=9 WHERE a=1\" , 1 ) ;\n rc = my_stmt_result ( \"SELECT a FROM test_grant\" ) ;\n DIE_UNLESS ( rc == 4 ) ;\n rc = mysql_query ( mysql , \"DELETE FROM test_grant\" ) ;\n myquery_r ( rc ) ;\n stmt = mysql_simple_prepare ( mysql , \"DELETE FROM test_grant\" ) ;\n check_stmt_r ( stmt ) ;\n rc = my_stmt_result ( \"SELECT * FROM test_grant\" ) ;\n DIE_UNLESS ( rc == 4 ) ;\n mysql_close ( lmysql ) ;\n mysql = org_mysql ;\n rc = mysql_query ( mysql , \"delete from mysql.user where User='test_grant'\" ) ;\n myquery ( rc ) ;\n DIE_UNLESS ( 1 == mysql_affected_rows ( mysql ) ) ;\n rc = mysql_query ( mysql , \"delete from mysql.tables_priv where User='test_grant'\" ) ;\n myquery ( rc ) ;\n DIE_UNLESS ( 1 == mysql_affected_rows ( mysql ) ) ;\n }\n }", "idx": 1086}
{"hash": -8919449269326401539, "project": "debian", "size": 11, "label": 0, "functionSource": "void dissect_cipsafety_ssn ( proto_tree * tree , tvbuff_t * tvb , packet_info * pinfo _U_ , int offset , int hf_real_datetime , int hf_date , int hf_time ) {\n guint16 date ;\n date = tvb_get_letohs ( tvb , offset ) ;\n if ( ( date >= 11688 ) && ( date <= 65534 ) ) {\n dissect_cip_date_and_time ( tree , tvb , offset , hf_real_datetime ) ;\n }\n else {\n proto_tree_add_item ( tree , hf_date , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n proto_tree_add_item ( tree , hf_time , tvb , offset + 2 , 4 , ENC_LITTLE_ENDIAN ) ;\n }\n }", "idx": 1087}
{"hash": 5917118798851365454, "project": "debian", "size": 3, "label": 0, "functionSource": "static int dissect_zbee_zcl_appl_idt ( tvbuff_t * tvb _U_ , packet_info * pinfo _U_ , proto_tree * tree _U_ , void * data _U_ ) {\n return tvb_captured_length ( tvb ) ;\n }", "idx": 1088}
{"hash": 6323824267898511453, "project": "debian", "size": 6, "label": 0, "functionSource": "void fz_set_default_cmyk ( fz_context * ctx , fz_default_colorspaces * default_cs , fz_colorspace * cs ) {\n if ( cs -> n == 4 ) {\n fz_drop_colorspace ( ctx , default_cs -> cmyk ) ;\n default_cs -> cmyk = fz_keep_colorspace ( ctx , cs ) ;\n }\n }", "idx": 1089}
{"hash": 3896936900447628930, "project": "debian", "size": 18, "label": 0, "functionSource": "static int parse_global_var ( AVFormatContext * avctx , AVStream * st , const char * name , int size ) {\n MvContext * mv = avctx -> priv_data ;\n AVIOContext * pb = avctx -> pb ;\n if ( ! strcmp ( name , \"__NUM_I_TRACKS\" ) ) {\n mv -> nb_video_tracks = var_read_int ( pb , size ) ;\n }\n else if ( ! strcmp ( name , \"__NUM_A_TRACKS\" ) ) {\n mv -> nb_audio_tracks = var_read_int ( pb , size ) ;\n }\n else if ( ! strcmp ( name , \"COMMENT\" ) || ! strcmp ( name , \"TITLE\" ) ) {\n var_read_metadata ( avctx , name , size ) ;\n }\n else if ( ! strcmp ( name , \"LOOP_MODE\" ) || ! strcmp ( name , \"NUM_LOOPS\" ) || ! strcmp ( name , \"OPTIMIZED\" ) ) {\n avio_skip ( pb , size ) ;\n }\n else return AVERROR_INVALIDDATA ;\n return 0 ;\n }", "idx": 1090}
{"hash": -7117046864335130087, "project": "chrome", "size": 14, "label": 0, "functionSource": "static double get_rate_correction_factor ( const VP9_COMP * cpi ) {\n const RATE_CONTROL * const rc = & cpi -> rc ;\n if ( cpi -> common . frame_type == KEY_FRAME ) {\n return rc -> rate_correction_factors [ KF_STD ] ;\n }\n else if ( cpi -> oxcf . pass == 2 ) {\n RATE_FACTOR_LEVEL rf_lvl = cpi -> twopass . gf_group . rf_level [ cpi -> twopass . gf_group . index ] ;\n return rc -> rate_correction_factors [ rf_lvl ] ;\n }\n else {\n if ( ( cpi -> refresh_alt_ref_frame || cpi -> refresh_golden_frame ) && ! rc -> is_src_frame_alt_ref && ! ( cpi -> use_svc && cpi -> oxcf . rc_mode == VPX_CBR ) ) return rc -> rate_correction_factors [ GF_ARF_STD ] ;\n else return rc -> rate_correction_factors [ INTER_NORMAL ] ;\n }\n }", "idx": 1091}
{"hash": -6126432314261451839, "project": "debian", "size": 11, "label": 0, "functionSource": "uint gx_device_raster ( const gx_device * dev , bool pad ) {\n ulong bits = ( ulong ) dev -> width * dev -> color_info . depth ;\n ulong raster ;\n int l2align ;\n if ( dev -> is_planar ) bits /= dev -> color_info . num_components ;\n raster = ( uint ) ( ( bits + 7 ) >> 3 ) ;\n if ( ! pad ) return raster ;\n l2align = dev -> log2_align_mod ;\n if ( l2align < log2_align_bitmap_mod ) l2align = log2_align_bitmap_mod ;\n return ( uint ) ( ( ( bits + ( 8 << l2align ) - 1 ) >> ( l2align + 3 ) ) << l2align ) ;\n }", "idx": 1092}
{"hash": -3053641395158209010, "project": "debian", "size": 36, "label": 0, "functionSource": "static int x ( struct vcache * avc , int afun , struct vrequest * areq , \\ struct afs_pdata * ain , struct afs_pdata * aout , \\ afs_ucred_t * * acred ) DECL_PIOCTL ( PGetFID ) ;\n DECL_PIOCTL ( PSetAcl ) ;\n DECL_PIOCTL ( PStoreBehind ) ;\n DECL_PIOCTL ( PGCPAGs ) ;\n DECL_PIOCTL ( PGetAcl ) ;\n DECL_PIOCTL ( PNoop ) ;\n DECL_PIOCTL ( PBogus ) ;\n DECL_PIOCTL ( PGetFileCell ) ;\n DECL_PIOCTL ( PGetWSCell ) ;\n DECL_PIOCTL ( PGetUserCell ) ;\n DECL_PIOCTL ( PSetTokens ) ;\n DECL_PIOCTL ( PGetVolumeStatus ) ;\n DECL_PIOCTL ( PSetVolumeStatus ) ;\n DECL_PIOCTL ( PFlush ) ;\n DECL_PIOCTL ( PNewStatMount ) ;\n DECL_PIOCTL ( PGetTokens ) ;\n DECL_PIOCTL ( PUnlog ) ;\n DECL_PIOCTL ( PMariner ) ;\n DECL_PIOCTL ( PCheckServers ) ;\n DECL_PIOCTL ( PCheckVolNames ) ;\n DECL_PIOCTL ( PCheckAuth ) ;\n DECL_PIOCTL ( PFindVolume ) ;\n DECL_PIOCTL ( PViceAccess ) ;\n DECL_PIOCTL ( PSetCacheSize ) ;\n DECL_PIOCTL ( PGetCacheSize ) ;\n DECL_PIOCTL ( PRemoveCallBack ) ;\n DECL_PIOCTL ( PNewCell ) ;\n DECL_PIOCTL ( PNewAlias ) ;\n DECL_PIOCTL ( PListCells ) ;\n DECL_PIOCTL ( PListAliases ) ;\n DECL_PIOCTL ( PRemoveMount ) ;\n DECL_PIOCTL ( PGetCellStatus ) ;\n DECL_PIOCTL ( PSetCellStatus ) ;\n DECL_PIOCTL ( PFlushVolumeData ) ;\n DECL_PIOCTL ( PFlushAllVolumeData ) ;\n DECL_PIOCTL ( PGetVnodeXStatus )", "idx": 1093}
{"hash": -7131177824150194183, "project": "debian", "size": 45, "label": 0, "functionSource": "static int read_dcs ( AVCodecContext * avctx , GetBitContext * gb , Bundle * b , int start_bits , int has_sign ) {\n int i , j , len , len2 , bsize , sign , v , v2 ;\n int16_t * dst = ( int16_t * ) b -> cur_dec ;\n int16_t * dst_end = ( int16_t * ) b -> data_end ;\n CHECK_READ_VAL ( gb , b , len ) ;\n v = get_bits ( gb , start_bits - has_sign ) ;\n if ( v && has_sign ) {\n sign = - get_bits1 ( gb ) ;\n v = ( v ^ sign ) - sign ;\n }\n if ( dst_end - dst < 1 ) return AVERROR_INVALIDDATA ;\n * dst ++ = v ;\n len -- ;\n for ( i = 0 ;\n i < len ;\n i += 8 ) {\n len2 = FFMIN ( len - i , 8 ) ;\n if ( dst_end - dst < len2 ) return AVERROR_INVALIDDATA ;\n bsize = get_bits ( gb , 4 ) ;\n if ( bsize ) {\n for ( j = 0 ;\n j < len2 ;\n j ++ ) {\n v2 = get_bits ( gb , bsize ) ;\n if ( v2 ) {\n sign = - get_bits1 ( gb ) ;\n v2 = ( v2 ^ sign ) - sign ;\n }\n v += v2 ;\n * dst ++ = v ;\n if ( v < - 32768 || v > 32767 ) {\n av_log ( avctx , AV_LOG_ERROR , \"DC value went out of bounds: %d\\n\" , v ) ;\n return AVERROR_INVALIDDATA ;\n }\n }\n }\n else {\n for ( j = 0 ;\n j < len2 ;\n j ++ ) * dst ++ = v ;\n }\n }\n b -> cur_dec = ( uint8_t * ) dst ;\n return 0 ;\n }", "idx": 1094}
{"hash": 2895622461494525400, "project": "debian", "size": 9, "label": 0, "functionSource": "static void test_date_ts ( ) {\n int rc ;\n myheader ( \"test_date_ts\" ) ;\n rc = mysql_query ( mysql , \"DROP TABLE IF EXISTS test_date\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"CREATE TABLE test_date(c1 TIMESTAMP, \\ c2 TIMESTAMP, \\ c3 TIMESTAMP, \\ c4 TIMESTAMP)\" ) ;\n myquery ( rc ) ;\n bind_date_conv ( 2 , FALSE ) ;\n }", "idx": 1095}
{"hash": -1102844685921778700, "project": "debian", "size": 3, "label": 0, "functionSource": "static unsigned get_current_oemcp ( void ) {\n return ( - 1 ) ;\n }", "idx": 1096}
{"hash": 2895622461494525400, "project": "debian", "size": 58, "label": 0, "functionSource": "static void test_ushort_bug ( ) {\n MYSQL_STMT * stmt ;\n MYSQL_BIND my_bind [ 4 ] ;\n ushort short_value ;\n uint32 long_value ;\n ulong s_length , l_length , ll_length , t_length ;\n ulonglong longlong_value ;\n int rc ;\n uchar tiny_value ;\n char llbuf [ 22 ] ;\n myheader ( \"test_ushort_bug\" ) ;\n rc = mysql_query ( mysql , \"DROP TABLE IF EXISTS test_ushort\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"CREATE TABLE test_ushort(a smallint unsigned, \\ b smallint unsigned, \\ c smallint unsigned, \\ d smallint unsigned)\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"INSERT INTO test_ushort VALUES(35999, 35999, 35999, 200)\" ) ;\n myquery ( rc ) ;\n stmt = mysql_simple_prepare ( mysql , \"SELECT * FROM test_ushort\" ) ;\n check_stmt ( stmt ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n my_bind [ 0 ] . buffer_type = MYSQL_TYPE_SHORT ;\n my_bind [ 0 ] . buffer = ( void * ) & short_value ;\n my_bind [ 0 ] . is_unsigned = TRUE ;\n my_bind [ 0 ] . length = & s_length ;\n my_bind [ 1 ] . buffer_type = MYSQL_TYPE_LONG ;\n my_bind [ 1 ] . buffer = ( void * ) & long_value ;\n my_bind [ 1 ] . length = & l_length ;\n my_bind [ 2 ] . buffer_type = MYSQL_TYPE_LONGLONG ;\n my_bind [ 2 ] . buffer = ( void * ) & longlong_value ;\n my_bind [ 2 ] . length = & ll_length ;\n my_bind [ 3 ] . buffer_type = MYSQL_TYPE_TINY ;\n my_bind [ 3 ] . buffer = ( void * ) & tiny_value ;\n my_bind [ 3 ] . is_unsigned = TRUE ;\n my_bind [ 3 ] . length = & t_length ;\n rc = mysql_stmt_bind_result ( stmt , my_bind ) ;\n check_execute ( stmt , rc ) ;\n rc = mysql_stmt_fetch ( stmt ) ;\n check_execute ( stmt , rc ) ;\n if ( ! opt_silent ) {\n fprintf ( stdout , \"\\n ushort : %d (%ld)\" , short_value , s_length ) ;\n fprintf ( stdout , \"\\n ulong : %lu (%ld)\" , ( ulong ) long_value , l_length ) ;\n fprintf ( stdout , \"\\n longlong : %s (%ld)\" , llstr ( longlong_value , llbuf ) , ll_length ) ;\n fprintf ( stdout , \"\\n tinyint : %d (%ld)\" , tiny_value , t_length ) ;\n }\n DIE_UNLESS ( short_value == 35999 ) ;\n DIE_UNLESS ( s_length == 2 ) ;\n DIE_UNLESS ( long_value == 35999 ) ;\n DIE_UNLESS ( l_length == 4 ) ;\n DIE_UNLESS ( longlong_value == 35999 ) ;\n DIE_UNLESS ( ll_length == 8 ) ;\n DIE_UNLESS ( tiny_value == 200 ) ;\n DIE_UNLESS ( t_length == 1 ) ;\n rc = mysql_stmt_fetch ( stmt ) ;\n DIE_UNLESS ( rc == MYSQL_NO_DATA ) ;\n mysql_stmt_close ( stmt ) ;\n }", "idx": 1097}
{"hash": 7493853980473701704, "project": "debian", "size": 4, "label": 0, "functionSource": "static uint64_t gic_thiscpu_read ( void * opaque , hwaddr addr , unsigned size ) {\n GICState * s = ( GICState * ) opaque ;\n return gic_cpu_read ( s , gic_get_current_cpu ( s ) , addr ) ;\n }", "idx": 1098}
{"hash": 9118387177353441960, "project": "debian", "size": 11, "label": 0, "functionSource": "int web_server_set_root_dir ( const char * root_dir ) {\n size_t index ;\n int ret ;\n ret = membuffer_assign_str ( & gDocumentRootDir , root_dir ) ;\n if ( ret != 0 ) return ret ;\n if ( gDocumentRootDir . length > 0 ) {\n index = gDocumentRootDir . length - 1 ;\n if ( gDocumentRootDir . buf [ index ] == '/' ) membuffer_delete ( & gDocumentRootDir , index , 1 ) ;\n }\n return 0 ;\n }", "idx": 1099}
{"hash": -5706788925640467782, "project": "chrome", "size": 106, "label": 1, "functionSource": "static void choose_partitioning ( VP9_COMP * cpi , const TileInfo * const tile , int mi_row , int mi_col ) {\n VP9_COMMON * const cm = & cpi -> common ;\n MACROBLOCK * x = & cpi -> mb ;\n MACROBLOCKD * xd = & cpi -> mb . e_mbd ;\n int i , j , k ;\n v64x64 vt ;\n uint8_t * s ;\n const uint8_t * d ;\n int sp ;\n int dp ;\n int pixels_wide = 64 , pixels_high = 64 ;\n int_mv nearest_mv , near_mv ;\n const YV12_BUFFER_CONFIG * yv12 = get_ref_frame_buffer ( cpi , LAST_FRAME ) ;\n const struct scale_factors * const sf = & cm -> frame_refs [ LAST_FRAME - 1 ] . sf ;\n vp9_zero ( vt ) ;\n set_offsets ( cpi , tile , mi_row , mi_col , BLOCK_64X64 ) ;\n if ( xd -> mb_to_right_edge < 0 ) pixels_wide += ( xd -> mb_to_right_edge >> 3 ) ;\n if ( xd -> mb_to_bottom_edge < 0 ) pixels_high += ( xd -> mb_to_bottom_edge >> 3 ) ;\n s = x -> plane [ 0 ] . src . buf ;\n sp = x -> plane [ 0 ] . src . stride ;\n if ( cm -> frame_type != KEY_FRAME ) {\n vp9_setup_pre_planes ( xd , 0 , yv12 , mi_row , mi_col , sf ) ;\n xd -> mi [ 0 ] -> mbmi . ref_frame [ 0 ] = LAST_FRAME ;\n xd -> mi [ 0 ] -> mbmi . sb_type = BLOCK_64X64 ;\n vp9_find_best_ref_mvs ( xd , cm -> allow_high_precision_mv , xd -> mi [ 0 ] -> mbmi . ref_mvs [ LAST_FRAME ] , & nearest_mv , & near_mv ) ;\n xd -> mi [ 0 ] -> mbmi . mv [ 0 ] = nearest_mv ;\n vp9_build_inter_predictors_sby ( xd , mi_row , mi_col , BLOCK_64X64 ) ;\n d = xd -> plane [ 0 ] . dst . buf ;\n dp = xd -> plane [ 0 ] . dst . stride ;\n }\n else {\n d = VP9_VAR_OFFS ;\n dp = 0 ;\n }\n for ( i = 0 ;\n i < 4 ;\n i ++ ) {\n const int x32_idx = ( ( i & 1 ) << 5 ) ;\n const int y32_idx = ( ( i >> 1 ) << 5 ) ;\n for ( j = 0 ;\n j < 4 ;\n j ++ ) {\n const int x16_idx = x32_idx + ( ( j & 1 ) << 4 ) ;\n const int y16_idx = y32_idx + ( ( j >> 1 ) << 4 ) ;\n v16x16 * vst = & vt . split [ i ] . split [ j ] ;\n for ( k = 0 ;\n k < 4 ;\n k ++ ) {\n int x_idx = x16_idx + ( ( k & 1 ) << 3 ) ;\n int y_idx = y16_idx + ( ( k >> 1 ) << 3 ) ;\n unsigned int sse = 0 ;\n int sum = 0 ;\n if ( x_idx < pixels_wide && y_idx < pixels_high ) vp9_get8x8var ( s + y_idx * sp + x_idx , sp , d + y_idx * dp + x_idx , dp , & sse , & sum ) ;\n fill_variance ( sse , sum , 64 , & vst -> split [ k ] . part_variances . none ) ;\n }\n }\n }\n for ( i = 0 ;\n i < 4 ;\n i ++ ) {\n for ( j = 0 ;\n j < 4 ;\n j ++ ) {\n fill_variance_tree ( & vt . split [ i ] . split [ j ] , BLOCK_16X16 ) ;\n }\n fill_variance_tree ( & vt . split [ i ] , BLOCK_32X32 ) ;\n }\n fill_variance_tree ( & vt , BLOCK_64X64 ) ;\n if ( ! set_vt_partitioning ( cpi , & vt , BLOCK_64X64 , mi_row , mi_col ) ) {\n for ( i = 0 ;\n i < 4 ;\n ++ i ) {\n const int x32_idx = ( ( i & 1 ) << 2 ) ;\n const int y32_idx = ( ( i >> 1 ) << 2 ) ;\n if ( ! set_vt_partitioning ( cpi , & vt . split [ i ] , BLOCK_32X32 , ( mi_row + y32_idx ) , ( mi_col + x32_idx ) ) ) {\n for ( j = 0 ;\n j < 4 ;\n ++ j ) {\n const int x16_idx = ( ( j & 1 ) << 1 ) ;\n const int y16_idx = ( ( j >> 1 ) << 1 ) ;\n # define DISABLE_8X8_VAR_BASED_PARTITION # ifdef DISABLE_8X8_VAR_BASED_PARTITION if ( mi_row + y32_idx + y16_idx + 1 < cm -> mi_rows && mi_row + x32_idx + x16_idx + 1 < cm -> mi_cols ) {\n set_block_size ( cpi , ( mi_row + y32_idx + y16_idx ) , ( mi_col + x32_idx + x16_idx ) , BLOCK_16X16 ) ;\n }\n else {\n for ( k = 0 ;\n k < 4 ;\n ++ k ) {\n const int x8_idx = ( k & 1 ) ;\n const int y8_idx = ( k >> 1 ) ;\n set_block_size ( cpi , ( mi_row + y32_idx + y16_idx + y8_idx ) , ( mi_col + x32_idx + x16_idx + x8_idx ) , BLOCK_8X8 ) ;\n }\n }\n # else if ( ! set_vt_partitioning ( cpi , & vt . split [ i ] . split [ j ] , tile , BLOCK_16X16 , ( mi_row + y32_idx + y16_idx ) , ( mi_col + x32_idx + x16_idx ) , 2 ) ) {\n for ( k = 0 ;\n k < 4 ;\n ++ k ) {\n const int x8_idx = ( k & 1 ) ;\n const int y8_idx = ( k >> 1 ) ;\n set_block_size ( cpi , ( mi_row + y32_idx + y16_idx + y8_idx ) , ( mi_col + x32_idx + x16_idx + x8_idx ) , BLOCK_8X8 ) ;\n }\n }\n # endif }\n }\n }\n }\n }", "idx": 1100}
{"hash": -5268859819325807498, "project": "debian", "size": 18, "label": 0, "functionSource": "static void new_files_callback ( GObject * source_object , GAsyncResult * res , gpointer user_data ) {\n NautilusDirectory * directory ;\n GFileInfo * info ;\n NewFilesState * state ;\n state = user_data ;\n if ( state -> directory == NULL ) {\n new_files_state_unref ( state ) ;\n return ;\n }\n directory = nautilus_directory_ref ( state -> directory ) ;\n info = g_file_query_info_finish ( G_FILE ( source_object ) , res , NULL ) ;\n if ( info != NULL ) {\n directory_load_one ( directory , info ) ;\n g_object_unref ( info ) ;\n }\n new_files_state_unref ( state ) ;\n nautilus_directory_unref ( directory ) ;\n }", "idx": 1101}
{"hash": -303065274055369342, "project": "debian", "size": 17, "label": 1, "functionSource": "END_TEST START_TEST ( test_find_user_by_ip ) {\n in_addr_t ip ;\n unsigned int testip ;\n ip = inet_addr ( \"127.0.0.1\" ) ;\n init_users ( ip , 27 ) ;\n users [ 0 ] . conn = CONN_DNS_NULL ;\n testip = ( unsigned int ) inet_addr ( \"10.0.0.1\" ) ;\n fail_unless ( find_user_by_ip ( testip ) == - 1 ) ;\n testip = ( unsigned int ) inet_addr ( \"127.0.0.2\" ) ;\n fail_unless ( find_user_by_ip ( testip ) == - 1 ) ;\n users [ 0 ] . active = 1 ;\n testip = ( unsigned int ) inet_addr ( \"127.0.0.2\" ) ;\n fail_unless ( find_user_by_ip ( testip ) == - 1 ) ;\n users [ 0 ] . last_pkt = time ( NULL ) ;\n testip = ( unsigned int ) inet_addr ( \"127.0.0.2\" ) ;\n fail_unless ( find_user_by_ip ( testip ) == 0 ) ;\n }", "idx": 1102}
{"hash": 2335222688263906532, "project": "debian", "size": 26, "label": 0, "functionSource": "static int rv34_set_deblock_coef ( RV34DecContext * r ) {\n MpegEncContext * s = & r -> s ;\n int hmvmask = 0 , vmvmask = 0 , i , j ;\n int midx = s -> mb_x * 2 + s -> mb_y * 2 * s -> b8_stride ;\n int16_t ( * motion_val ) [ 2 ] = & s -> current_picture_ptr -> motion_val [ 0 ] [ midx ] ;\n for ( j = 0 ;\n j < 16 ;\n j += 8 ) {\n for ( i = 0 ;\n i < 2 ;\n i ++ ) {\n if ( is_mv_diff_gt_3 ( motion_val + i , 1 ) ) vmvmask |= 0x11 << ( j + i * 2 ) ;\n if ( ( j || s -> mb_y ) && is_mv_diff_gt_3 ( motion_val + i , s -> b8_stride ) ) hmvmask |= 0x03 << ( j + i * 2 ) ;\n }\n motion_val += s -> b8_stride ;\n }\n if ( s -> first_slice_line ) hmvmask &= ~ 0x000F ;\n if ( ! s -> mb_x ) vmvmask &= ~ 0x1111 ;\n if ( r -> rv30 ) {\n vmvmask |= ( vmvmask & 0x4444 ) >> 1 ;\n hmvmask |= ( hmvmask & 0x0F00 ) >> 4 ;\n if ( s -> mb_x ) r -> deblock_coefs [ s -> mb_x - 1 + s -> mb_y * s -> mb_stride ] |= ( vmvmask & 0x1111 ) << 3 ;\n if ( ! s -> first_slice_line ) r -> deblock_coefs [ s -> mb_x + ( s -> mb_y - 1 ) * s -> mb_stride ] |= ( hmvmask & 0xF ) << 12 ;\n }\n return hmvmask | vmvmask ;\n }", "idx": 1103}
{"hash": 9175972616340456250, "project": "debian", "size": 44, "label": 1, "functionSource": "static char * * create_argv_command ( struct rule * rule , struct process * process , struct iovec * * argv ) {\n size_t count , i , j , stdin_arg ;\n char * * req_argv = NULL ;\n const char * program ;\n for ( count = 0 ;\n argv [ count ] != NULL ;\n count ++ ) ;\n if ( rule -> sudo_user == NULL ) req_argv = xcalloc ( count + 1 , sizeof ( char * ) ) ;\n else req_argv = xcalloc ( count + 5 , sizeof ( char * ) ) ;\n if ( rule -> sudo_user != NULL ) {\n req_argv [ 0 ] = xstrdup ( PATH_SUDO ) ;\n req_argv [ 1 ] = xstrdup ( \"-u\" ) ;\n req_argv [ 2 ] = xstrdup ( rule -> sudo_user ) ;\n req_argv [ 3 ] = xstrdup ( \"--\" ) ;\n req_argv [ 4 ] = rule -> program ;\n j = 5 ;\n }\n else {\n program = strrchr ( rule -> program , '/' ) ;\n if ( program == NULL ) program = rule -> program ;\n else program ++ ;\n req_argv [ 0 ] = xstrdup ( program ) ;\n j = 1 ;\n }\n if ( rule -> stdin_arg == - 1 ) stdin_arg = count - 1 ;\n else stdin_arg = ( size_t ) rule -> stdin_arg ;\n for ( i = 1 ;\n i < count ;\n i ++ ) {\n const char * data = argv [ i ] -> iov_base ;\n size_t length = argv [ i ] -> iov_len ;\n if ( i == stdin_arg ) {\n process -> input = evbuffer_new ( ) ;\n if ( process -> input == NULL ) die ( \"internal error: cannot create input buffer\" ) ;\n if ( evbuffer_add ( process -> input , data , length ) < 0 ) die ( \"internal error: cannot add data to input buffer\" ) ;\n continue ;\n }\n if ( length == 0 ) req_argv [ j ] = xstrdup ( \"\" ) ;\n else req_argv [ j ] = xstrndup ( data , length ) ;\n j ++ ;\n }\n req_argv [ j ] = NULL ;\n return req_argv ;\n }", "idx": 1104}
{"hash": 3887066622454352196, "project": "chrome", "size": 12, "label": 1, "functionSource": "static void store_coding_context ( MACROBLOCK * x , PICK_MODE_CONTEXT * ctx , int mode_index , int64_t comp_pred_diff [ REFERENCE_MODES ] , const int64_t tx_size_diff [ TX_MODES ] , int64_t best_filter_diff [ SWITCHABLE_FILTER_CONTEXTS ] , int skippable ) {\n MACROBLOCKD * const xd = & x -> e_mbd ;\n ctx -> skip = x -> skip ;\n ctx -> skippable = skippable ;\n ctx -> best_mode_index = mode_index ;\n ctx -> mic = * xd -> mi [ 0 ] ;\n ctx -> single_pred_diff = ( int ) comp_pred_diff [ SINGLE_REFERENCE ] ;\n ctx -> comp_pred_diff = ( int ) comp_pred_diff [ COMPOUND_REFERENCE ] ;\n ctx -> hybrid_pred_diff = ( int ) comp_pred_diff [ REFERENCE_MODE_SELECT ] ;\n vpx_memcpy ( ctx -> tx_rd_diff , tx_size_diff , sizeof ( ctx -> tx_rd_diff ) ) ;\n vpx_memcpy ( ctx -> best_filter_diff , best_filter_diff , sizeof ( * best_filter_diff ) * SWITCHABLE_FILTER_CONTEXTS ) ;\n }", "idx": 1105}
{"hash": -4239386405881995323, "project": "chrome", "size": 43, "label": 0, "functionSource": "int xmlHashRemoveEntry3 ( xmlHashTablePtr table , const xmlChar * name , const xmlChar * name2 , const xmlChar * name3 , xmlHashDeallocator f ) {\n unsigned long key ;\n xmlHashEntryPtr entry ;\n xmlHashEntryPtr prev = NULL ;\n if ( table == NULL || name == NULL ) return ( - 1 ) ;\n key = xmlHashComputeKey ( table , name , name2 , name3 ) ;\n if ( table -> table [ key ] . valid == 0 ) {\n return ( - 1 ) ;\n }\n else {\n for ( entry = & ( table -> table [ key ] ) ;\n entry != NULL ;\n entry = entry -> next ) {\n if ( xmlStrEqual ( entry -> name , name ) && xmlStrEqual ( entry -> name2 , name2 ) && xmlStrEqual ( entry -> name3 , name3 ) ) {\n if ( ( f != NULL ) && ( entry -> payload != NULL ) ) f ( entry -> payload , entry -> name ) ;\n entry -> payload = NULL ;\n if ( table -> dict == NULL ) {\n if ( entry -> name ) xmlFree ( entry -> name ) ;\n if ( entry -> name2 ) xmlFree ( entry -> name2 ) ;\n if ( entry -> name3 ) xmlFree ( entry -> name3 ) ;\n }\n if ( prev ) {\n prev -> next = entry -> next ;\n xmlFree ( entry ) ;\n }\n else {\n if ( entry -> next == NULL ) {\n entry -> valid = 0 ;\n }\n else {\n entry = entry -> next ;\n memcpy ( & ( table -> table [ key ] ) , entry , sizeof ( xmlHashEntry ) ) ;\n xmlFree ( entry ) ;\n }\n }\n table -> nbElems -- ;\n return ( 0 ) ;\n }\n prev = entry ;\n }\n return ( - 1 ) ;\n }\n }", "idx": 1106}
{"hash": 4722923622195275414, "project": "debian", "size": 31, "label": 0, "functionSource": "static int lag_decode_prob ( GetBitContext * gb , uint32_t * value ) {\n static const uint8_t series [ ] = {\n 1 , 2 , 3 , 5 , 8 , 13 , 21 }\n ;\n int i ;\n int bit = 0 ;\n int bits = 0 ;\n int prevbit = 0 ;\n unsigned val ;\n for ( i = 0 ;\n i < 7 ;\n i ++ ) {\n if ( prevbit && bit ) break ;\n prevbit = bit ;\n bit = get_bits1 ( gb ) ;\n if ( bit && ! prevbit ) bits += series [ i ] ;\n }\n bits -- ;\n if ( bits < 0 || bits > 31 ) {\n * value = 0 ;\n return - 1 ;\n }\n else if ( bits == 0 ) {\n * value = 0 ;\n return 0 ;\n }\n val = get_bits_long ( gb , bits ) ;\n val |= 1 << bits ;\n * value = val - 1 ;\n return 0 ;\n }", "idx": 1107}
{"hash": 9176142195250515812, "project": "debian", "size": 23, "label": 0, "functionSource": "static void purple_set_away ( struct im_connection * ic , char * state_txt , char * message ) {\n struct purple_data * pd = ic -> proto_data ;\n GList * status_types = purple_account_get_status_types ( pd -> account ) , * st ;\n PurpleStatusType * pst = NULL ;\n GList * args = NULL ;\n for ( st = status_types ;\n st ;\n st = st -> next ) {\n pst = st -> data ;\n if ( state_txt == NULL && purple_status_type_get_primitive ( pst ) == PURPLE_STATUS_AVAILABLE ) {\n break ;\n }\n if ( state_txt != NULL && g_strcasecmp ( state_txt , purple_status_type_get_name ( pst ) ) == 0 ) {\n break ;\n }\n }\n if ( message && purple_status_type_get_attr ( pst , \"message\" ) ) {\n args = g_list_append ( args , \"message\" ) ;\n args = g_list_append ( args , message ) ;\n }\n purple_account_set_status_list ( pd -> account , st ? purple_status_type_get_id ( pst ) : \"away\" , TRUE , args ) ;\n g_list_free ( args ) ;\n }", "idx": 1108}
{"hash": 8280197130498466782, "project": "debian", "size": 4, "label": 0, "functionSource": "static zval * * incomplete_class_get_property_ptr_ptr ( zval * object , zval * member , const zend_literal * key TSRMLS_DC ) {\n incomplete_class_message ( object , E_NOTICE TSRMLS_CC ) ;\n return & EG ( error_zval_ptr ) ;\n }", "idx": 1109}
{"hash": 8947170728280515149, "project": "debian", "size": 12, "label": 0, "functionSource": "static void RemapHintMask ( HintMask * hm , int mapping [ 96 ] , int max ) {\n HintMask rpl ;\n int i , mb ;\n if ( hm == NULL ) return ;\n if ( max > 96 ) max = 96 ;\n mb = ( max + 7 ) >> 3 ;\n memset ( & rpl , 0 , mb ) ;\n for ( i = 0 ;\n i < max ;\n ++ i ) if ( ( * hm ) [ i >> 3 ] & ( 0x80 >> ( i & 0x7 ) ) ) rpl [ mapping [ i ] >> 3 ] |= ( 0x80 >> ( mapping [ i ] & 0x7 ) ) ;\n memcpy ( hm , & rpl , mb ) ;\n }", "idx": 1110}
{"hash": -3740862514502467070, "project": "debian", "size": 26, "label": 0, "functionSource": "static void dumpint ( FILE * cfff , int num ) {\n if ( num >= - 107 && num <= 107 ) putc ( num + 139 , cfff ) ;\n else if ( num >= 108 && num <= 1131 ) {\n num -= 108 ;\n putc ( ( num >> 8 ) + 247 , cfff ) ;\n putc ( num & 0xff , cfff ) ;\n }\n else if ( num >= - 1131 && num <= - 108 ) {\n num = - num ;\n num -= 108 ;\n putc ( ( num >> 8 ) + 251 , cfff ) ;\n putc ( num & 0xff , cfff ) ;\n }\n else if ( num >= - 32768 && num < 32768 ) {\n putc ( 28 , cfff ) ;\n putc ( num >> 8 , cfff ) ;\n putc ( num & 0xff , cfff ) ;\n }\n else {\n putc ( 29 , cfff ) ;\n putc ( ( num >> 24 ) & 0xff , cfff ) ;\n putc ( ( num >> 16 ) & 0xff , cfff ) ;\n putc ( ( num >> 8 ) & 0xff , cfff ) ;\n putc ( num & 0xff , cfff ) ;\n }\n }", "idx": 1111}
{"hash": 9173748358801811781, "project": "debian", "size": 573, "label": 0, "functionSource": "mgs_srvconf_rec * mgs_find_sni_server ( gnutls_session_t session ) {\n int rv ;\n unsigned int sni_type ;\n size_t data_len = MAX_HOST_LEN ;\n char sni_name [ MAX_HOST_LEN ] ;\n mgs_handle_t * ctxt ;\n # if USING_2_1_RECENT vhost_cb_rec cbx ;\n # else server_rec * s ;\n mgs_srvconf_rec * tsc ;\n # endif if ( session == NULL ) return NULL ;\n _gnutls_log ( debug_log_fp , \"%s: %d\\n\" , __func__ , __LINE__ ) ;\n ctxt = gnutls_transport_get_ptr ( session ) ;\n rv = gnutls_server_name_get ( ctxt -> session , sni_name , & data_len , & sni_type , 0 ) ;\n if ( rv != 0 ) {\n return NULL ;\n }\n if ( sni_type != GNUTLS_NAME_DNS ) {\n ap_log_error ( APLOG_MARK , APLOG_CRIT , 0 , ctxt -> c -> base_server , \"GnuTLS: Unknown type '%d' for SNI: \" \"'%s'\" , sni_type , sni_name ) ;\n return NULL ;\n }\n # if USING_2_1_RECENT cbx . ctxt = ctxt ;\n cbx . sc = NULL ;\n cbx . sni_name = sni_name ;\n rv = ap_vhost_iterate_given_conn ( ctxt -> c , vhost_cb , & cbx ) ;\n if ( rv == 1 ) {\n return cbx . sc ;\n }\n # else for ( s = ap_server_conf ;\n s ;\n s = s -> next ) {\n tsc = ( mgs_srvconf_rec * ) ap_get_module_config ( s -> module_config , & gnutls_module ) ;\n if ( tsc -> enabled != GNUTLS_ENABLED_TRUE ) {\n continue ;\n }\n if ( check_server_aliases ( x , s , tsc ) ) {\n return tsc ;\n }\n # endif return NULL ;\n }\n static void create_gnutls_handle ( conn_rec * c ) {\n mgs_srvconf_rec * sc = ( mgs_srvconf_rec * ) ap_get_module_config ( c -> base_server -> module_config , & gnutls_module ) ;\n _gnutls_log ( debug_log_fp , \"%s: %d\\n\" , __func__ , __LINE__ ) ;\n mgs_handle_t * ctxt = ( mgs_handle_t * ) ap_get_module_config ( c -> conn_config , & gnutls_module ) ;\n if ( ctxt == NULL ) {\n ap_log_cerror ( APLOG_MARK , APLOG_DEBUG , 0 , c , \"%s: allocating connection memory\" , __func__ ) ;\n ctxt = apr_pcalloc ( c -> pool , sizeof ( * ctxt ) ) ;\n ap_set_module_config ( c -> conn_config , & gnutls_module , ctxt ) ;\n }\n ctxt -> enabled = GNUTLS_ENABLED_TRUE ;\n ctxt -> c = c ;\n ctxt -> sc = sc ;\n ctxt -> status = 0 ;\n ctxt -> input_rc = APR_SUCCESS ;\n ctxt -> input_bb = apr_brigade_create ( c -> pool , c -> bucket_alloc ) ;\n ctxt -> input_cbuf . length = 0 ;\n ctxt -> output_rc = APR_SUCCESS ;\n ctxt -> output_bb = apr_brigade_create ( c -> pool , c -> bucket_alloc ) ;\n ctxt -> output_blen = 0 ;\n ctxt -> output_length = 0 ;\n int err = gnutls_init ( & ctxt -> session , GNUTLS_SERVER ) ;\n if ( err != GNUTLS_E_SUCCESS ) ap_log_cerror ( APLOG_MARK , APLOG_ERR , err , c , \"gnutls_init failed!\" ) ;\n if ( session_ticket_key . data != NULL && ctxt -> sc -> tickets != 0 ) {\n err = gnutls_session_ticket_enable_server ( ctxt -> session , & session_ticket_key ) ;\n if ( err != GNUTLS_E_SUCCESS ) ap_log_cerror ( APLOG_MARK , APLOG_ERR , err , c , \"gnutls_session_ticket_enable_server failed!\" ) ;\n }\n err = gnutls_priority_set_direct ( ctxt -> session , \"NORMAL\" , NULL ) ;\n if ( err != GNUTLS_E_SUCCESS ) ap_log_cerror ( APLOG_MARK , APLOG_ERR , err , c , \"gnutls_priority_set_direct failed!\" ) ;\n gnutls_handshake_set_post_client_hello_function ( ctxt -> session , mgs_select_virtual_server_cb ) ;\n mgs_cache_session_init ( ctxt ) ;\n gnutls_transport_set_pull_function ( ctxt -> session , mgs_transport_read ) ;\n gnutls_transport_set_push_function ( ctxt -> session , mgs_transport_write ) ;\n gnutls_transport_set_ptr ( ctxt -> session , ctxt ) ;\n ctxt -> input_filter = ap_add_input_filter ( GNUTLS_INPUT_FILTER_NAME , ctxt , NULL , c ) ;\n ctxt -> output_filter = ap_add_output_filter ( GNUTLS_OUTPUT_FILTER_NAME , ctxt , NULL , c ) ;\n }\n int mgs_hook_pre_connection ( conn_rec * c , void * csd __attribute__ ( ( unused ) ) ) {\n _gnutls_log ( debug_log_fp , \"%s: %d\\n\" , __func__ , __LINE__ ) ;\n mgs_srvconf_rec * sc = ( mgs_srvconf_rec * ) ap_get_module_config ( c -> base_server -> module_config , & gnutls_module ) ;\n mgs_handle_t * ctxt = ( mgs_handle_t * ) ap_get_module_config ( c -> conn_config , & gnutls_module ) ;\n if ( ( sc && ( ! sc -> enabled || sc -> proxy_enabled == GNUTLS_ENABLED_TRUE ) ) || ( ctxt && ctxt -> enabled == GNUTLS_ENABLED_FALSE ) ) {\n ap_log_cerror ( APLOG_MARK , APLOG_DEBUG , 0 , c , \"%s declined connection\" , __func__ ) ;\n return DECLINED ;\n }\n create_gnutls_handle ( c ) ;\n return OK ;\n }\n int mgs_hook_fixups ( request_rec * r ) {\n unsigned char sbuf [ GNUTLS_MAX_SESSION_ID ] ;\n char buf [ AP_IOBUFSIZE ] ;\n const char * tmp ;\n size_t len ;\n mgs_handle_t * ctxt ;\n int rv = OK ;\n if ( r == NULL ) return DECLINED ;\n _gnutls_log ( debug_log_fp , \"%s: %d\\n\" , __func__ , __LINE__ ) ;\n apr_table_t * env = r -> subprocess_env ;\n ctxt = ap_get_module_config ( r -> connection -> conn_config , & gnutls_module ) ;\n if ( ! ctxt || ctxt -> enabled != GNUTLS_ENABLED_TRUE || ctxt -> session == NULL ) {\n ap_log_rerror ( APLOG_MARK , APLOG_DEBUG , 0 , r , \"request declined in %s\" , __func__ ) ;\n return DECLINED ;\n }\n apr_table_setn ( env , \"HTTPS\" , \"on\" ) ;\n apr_table_setn ( env , \"SSL_VERSION_LIBRARY\" , \"GnuTLS/\" LIBGNUTLS_VERSION ) ;\n apr_table_setn ( env , \"SSL_VERSION_INTERFACE\" , \"mod_gnutls/\" MOD_GNUTLS_VERSION ) ;\n apr_table_setn ( env , \"SSL_PROTOCOL\" , gnutls_protocol_get_name ( gnutls_protocol_get_version ( ctxt -> session ) ) ) ;\n apr_table_setn ( env , \"SSL_CIPHER\" , gnutls_cipher_suite_get_name ( gnutls_kx_get ( ctxt -> session ) , gnutls_cipher_get ( ctxt -> session ) , gnutls_mac_get ( ctxt -> session ) ) ) ;\n apr_table_setn ( env , \"SSL_COMPRESS_METHOD\" , gnutls_compression_get_name ( gnutls_compression_get ( ctxt -> session ) ) ) ;\n # ifdef ENABLE_SRP if ( ctxt -> sc -> srp_tpasswd_conf_file != NULL && ctxt -> sc -> srp_tpasswd_file != NULL ) {\n tmp = gnutls_srp_server_get_username ( ctxt -> session ) ;\n apr_table_setn ( env , \"SSL_SRP_USER\" , ( tmp != NULL ) ? tmp : \"\" ) ;\n }\n else {\n apr_table_unset ( env , \"SSL_SRP_USER\" ) ;\n }\n # endif if ( apr_table_get ( env , \"SSL_CLIENT_VERIFY\" ) == NULL ) apr_table_setn ( env , \"SSL_CLIENT_VERIFY\" , \"NONE\" ) ;\n unsigned int key_size = 8 * gnutls_cipher_get_key_size ( gnutls_cipher_get ( ctxt -> session ) ) ;\n tmp = apr_psprintf ( r -> pool , \"%u\" , key_size ) ;\n apr_table_setn ( env , \"SSL_CIPHER_USEKEYSIZE\" , tmp ) ;\n apr_table_setn ( env , \"SSL_CIPHER_ALGKEYSIZE\" , tmp ) ;\n apr_table_setn ( env , \"SSL_CIPHER_EXPORT\" , ( key_size <= 40 ) ? \"true\" : \"false\" ) ;\n int dhsize = gnutls_dh_get_prime_bits ( ctxt -> session ) ;\n if ( dhsize > 0 ) {\n tmp = apr_psprintf ( r -> pool , \"%d\" , dhsize ) ;\n apr_table_setn ( env , \"SSL_DH_PRIME_BITS\" , tmp ) ;\n }\n len = sizeof ( sbuf ) ;\n gnutls_session_get_id ( ctxt -> session , sbuf , & len ) ;\n tmp = mgs_session_id2sz ( sbuf , len , buf , sizeof ( buf ) ) ;\n apr_table_setn ( env , \"SSL_SESSION_ID\" , apr_pstrdup ( r -> pool , tmp ) ) ;\n if ( gnutls_certificate_type_get ( ctxt -> session ) == GNUTLS_CRT_X509 ) {\n mgs_add_common_cert_vars ( r , ctxt -> sc -> certs_x509_chain [ 0 ] , 0 , ctxt -> sc -> export_certificates_size ) ;\n }\n else if ( gnutls_certificate_type_get ( ctxt -> session ) == GNUTLS_CRT_OPENPGP ) {\n mgs_add_common_pgpcert_vars ( r , ctxt -> sc -> cert_pgp , 0 , ctxt -> sc -> export_certificates_size ) ;\n }\n return rv ;\n }\n int mgs_hook_authz ( request_rec * r ) {\n int rv ;\n mgs_handle_t * ctxt ;\n mgs_dirconf_rec * dc ;\n if ( r == NULL ) return DECLINED ;\n dc = ap_get_module_config ( r -> per_dir_config , & gnutls_module ) ;\n _gnutls_log ( debug_log_fp , \"%s: %d\\n\" , __func__ , __LINE__ ) ;\n ctxt = ap_get_module_config ( r -> connection -> conn_config , & gnutls_module ) ;\n if ( ! ctxt || ctxt -> session == NULL ) {\n return DECLINED ;\n }\n if ( dc -> client_verify_mode == GNUTLS_CERT_IGNORE ) {\n ap_log_rerror ( APLOG_MARK , APLOG_DEBUG , 0 , r , \"GnuTLS: Directory set to Ignore Client Certificate!\" ) ;\n }\n else {\n if ( ctxt -> sc -> client_verify_mode < dc -> client_verify_mode ) {\n ap_log_rerror ( APLOG_MARK , APLOG_DEBUG , 0 , r , \"GnuTLS: Attempting to rehandshake with peer. %d %d\" , ctxt -> sc -> client_verify_mode , dc -> client_verify_mode ) ;\n rv = mgs_cert_verify ( r , ctxt ) ;\n if ( rv != DECLINED && rv != HTTP_FORBIDDEN ) return rv ;\n gnutls_certificate_server_set_request ( ctxt -> session , dc -> client_verify_mode ) ;\n if ( mgs_rehandshake ( ctxt ) != 0 ) {\n return HTTP_FORBIDDEN ;\n }\n }\n else if ( ctxt -> sc -> client_verify_mode == GNUTLS_CERT_IGNORE ) {\n # if MOD_GNUTLS_DEBUG ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , r , \"GnuTLS: Peer is set to IGNORE\" ) ;\n # endif return DECLINED ;\n }\n rv = mgs_cert_verify ( r , ctxt ) ;\n if ( rv != DECLINED && ( rv != HTTP_FORBIDDEN || dc -> client_verify_mode == GNUTLS_CERT_REQUIRE || ( dc -> client_verify_mode == - 1 && ctxt -> sc -> client_verify_mode == GNUTLS_CERT_REQUIRE ) ) ) {\n return rv ;\n }\n }\n return DECLINED ;\n }\n # define MGS_SIDE ( suffix ) ( ( side == 0 ) ? \"SSL_SERVER\" suffix : \"SSL_CLIENT\" suffix ) static void mgs_add_common_cert_vars ( request_rec * r , gnutls_x509_crt_t cert , int side , size_t export_cert_size ) {\n unsigned char sbuf [ 64 ] ;\n char buf [ AP_IOBUFSIZE ] ;\n const char * tmp ;\n char * tmp2 ;\n size_t len ;\n int ret , i ;\n if ( r == NULL ) return ;\n apr_table_t * env = r -> subprocess_env ;\n _gnutls_log ( debug_log_fp , \"%s: %d\\n\" , __func__ , __LINE__ ) ;\n if ( export_cert_size > 0 ) {\n len = 0 ;\n ret = gnutls_x509_crt_export ( cert , GNUTLS_X509_FMT_PEM , NULL , & len ) ;\n if ( ret == GNUTLS_E_SHORT_MEMORY_BUFFER ) {\n if ( len >= export_cert_size ) {\n apr_table_setn ( env , MGS_SIDE ( \"_CERT\" ) , \"GNUTLS_CERTIFICATE_SIZE_LIMIT_EXCEEDED\" ) ;\n ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , r , \"GnuTLS: Failed to export too-large X.509 certificate to environment\" ) ;\n }\n else {\n char * cert_buf = apr_palloc ( r -> pool , len + 1 ) ;\n if ( cert_buf != NULL && gnutls_x509_crt_export ( cert , GNUTLS_X509_FMT_PEM , cert_buf , & len ) >= 0 ) {\n cert_buf [ len ] = 0 ;\n apr_table_setn ( env , MGS_SIDE ( \"_CERT\" ) , cert_buf ) ;\n }\n else {\n ap_log_rerror ( APLOG_MARK , APLOG_WARNING , 0 , r , \"GnuTLS: failed to export X.509 certificate\" ) ;\n }\n }\n }\n else {\n ap_log_rerror ( APLOG_MARK , APLOG_WARNING , 0 , r , \"GnuTLS: dazed and confused about X.509 certificate size\" ) ;\n }\n }\n len = sizeof ( buf ) ;\n gnutls_x509_crt_get_dn ( cert , buf , & len ) ;\n apr_table_setn ( env , MGS_SIDE ( \"_S_DN\" ) , apr_pstrmemdup ( r -> pool , buf , len ) ) ;\n len = sizeof ( buf ) ;\n gnutls_x509_crt_get_issuer_dn ( cert , buf , & len ) ;\n apr_table_setn ( env , MGS_SIDE ( \"_I_DN\" ) , apr_pstrmemdup ( r -> pool , buf , len ) ) ;\n len = sizeof ( sbuf ) ;\n gnutls_x509_crt_get_serial ( cert , sbuf , & len ) ;\n tmp = mgs_session_id2sz ( sbuf , len , buf , sizeof ( buf ) ) ;\n apr_table_setn ( env , MGS_SIDE ( \"_M_SERIAL\" ) , apr_pstrdup ( r -> pool , tmp ) ) ;\n ret = gnutls_x509_crt_get_version ( cert ) ;\n if ( ret > 0 ) apr_table_setn ( env , MGS_SIDE ( \"_M_VERSION\" ) , apr_psprintf ( r -> pool , \"%u\" , ret ) ) ;\n apr_table_setn ( env , MGS_SIDE ( \"_CERT_TYPE\" ) , \"X.509\" ) ;\n tmp = mgs_time2sz ( gnutls_x509_crt_get_expiration_time ( cert ) , buf , sizeof ( buf ) ) ;\n apr_table_setn ( env , MGS_SIDE ( \"_V_END\" ) , apr_pstrdup ( r -> pool , tmp ) ) ;\n tmp = mgs_time2sz ( gnutls_x509_crt_get_activation_time ( cert ) , buf , sizeof ( buf ) ) ;\n apr_table_setn ( env , MGS_SIDE ( \"_V_START\" ) , apr_pstrdup ( r -> pool , tmp ) ) ;\n ret = gnutls_x509_crt_get_signature_algorithm ( cert ) ;\n if ( ret >= 0 ) {\n apr_table_setn ( env , MGS_SIDE ( \"_A_SIG\" ) , gnutls_sign_algorithm_get_name ( ret ) ) ;\n }\n ret = gnutls_x509_crt_get_pk_algorithm ( cert , NULL ) ;\n if ( ret >= 0 ) {\n apr_table_setn ( env , MGS_SIDE ( \"_A_KEY\" ) , gnutls_pk_algorithm_get_name ( ret ) ) ;\n }\n for ( i = 0 ;\n ! ( ret < 0 ) ;\n i ++ ) {\n const char * san , * sanlabel ;\n len = 0 ;\n ret = gnutls_x509_crt_get_subject_alt_name ( cert , i , NULL , & len , NULL ) ;\n if ( ret == GNUTLS_E_SHORT_MEMORY_BUFFER && len > 1 ) {\n tmp2 = apr_palloc ( r -> pool , len + 1 ) ;\n ret = gnutls_x509_crt_get_subject_alt_name ( cert , i , tmp2 , & len , NULL ) ;\n tmp2 [ len ] = 0 ;\n sanlabel = apr_psprintf ( r -> pool , \"%s%u\" , MGS_SIDE ( \"_S_AN\" ) , i ) ;\n if ( ret == GNUTLS_SAN_DNSNAME ) {\n san = apr_psprintf ( r -> pool , \"DNSNAME:%s\" , tmp2 ) ;\n }\n else if ( ret == GNUTLS_SAN_RFC822NAME ) {\n san = apr_psprintf ( r -> pool , \"RFC822NAME:%s\" , tmp2 ) ;\n }\n else if ( ret == GNUTLS_SAN_URI ) {\n san = apr_psprintf ( r -> pool , \"URI:%s\" , tmp2 ) ;\n }\n else {\n san = \"UNSUPPORTED\" ;\n }\n apr_table_setn ( env , sanlabel , san ) ;\n }\n }\n }\n static void mgs_add_common_pgpcert_vars ( request_rec * r , gnutls_openpgp_crt_t cert , int side , size_t export_cert_size ) {\n unsigned char sbuf [ 64 ] ;\n char buf [ AP_IOBUFSIZE ] ;\n const char * tmp ;\n size_t len ;\n int ret ;\n if ( r == NULL ) return ;\n _gnutls_log ( debug_log_fp , \"%s: %d\\n\" , __func__ , __LINE__ ) ;\n apr_table_t * env = r -> subprocess_env ;\n if ( export_cert_size > 0 ) {\n len = 0 ;\n ret = gnutls_openpgp_crt_export ( cert , GNUTLS_OPENPGP_FMT_BASE64 , NULL , & len ) ;\n if ( ret == GNUTLS_E_SHORT_MEMORY_BUFFER ) {\n if ( len >= export_cert_size ) {\n apr_table_setn ( env , MGS_SIDE ( \"_CERT\" ) , \"GNUTLS_CERTIFICATE_SIZE_LIMIT_EXCEEDED\" ) ;\n ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , r , \"GnuTLS: Failed to export too-large OpenPGP certificate to environment\" ) ;\n }\n else {\n char * cert_buf = apr_palloc ( r -> pool , len + 1 ) ;\n if ( cert_buf != NULL && gnutls_openpgp_crt_export ( cert , GNUTLS_OPENPGP_FMT_BASE64 , cert_buf , & len ) >= 0 ) {\n cert_buf [ len ] = 0 ;\n apr_table_setn ( env , MGS_SIDE ( \"_CERT\" ) , cert_buf ) ;\n }\n else {\n ap_log_rerror ( APLOG_MARK , APLOG_WARNING , 0 , r , \"GnuTLS: failed to export OpenPGP certificate\" ) ;\n }\n }\n }\n else {\n ap_log_rerror ( APLOG_MARK , APLOG_WARNING , 0 , r , \"GnuTLS: dazed and confused about OpenPGP certificate size\" ) ;\n }\n }\n len = sizeof ( buf ) ;\n gnutls_openpgp_crt_get_name ( cert , 0 , buf , & len ) ;\n apr_table_setn ( env , MGS_SIDE ( \"_NAME\" ) , apr_pstrmemdup ( r -> pool , buf , len ) ) ;\n len = sizeof ( sbuf ) ;\n gnutls_openpgp_crt_get_fingerprint ( cert , sbuf , & len ) ;\n tmp = mgs_session_id2sz ( sbuf , len , buf , sizeof ( buf ) ) ;\n apr_table_setn ( env , MGS_SIDE ( \"_FINGERPRINT\" ) , apr_pstrdup ( r -> pool , tmp ) ) ;\n ret = gnutls_openpgp_crt_get_version ( cert ) ;\n if ( ret > 0 ) apr_table_setn ( env , MGS_SIDE ( \"_M_VERSION\" ) , apr_psprintf ( r -> pool , \"%u\" , ret ) ) ;\n apr_table_setn ( env , MGS_SIDE ( \"_CERT_TYPE\" ) , \"OPENPGP\" ) ;\n tmp = mgs_time2sz ( gnutls_openpgp_crt_get_expiration_time ( cert ) , buf , sizeof ( buf ) ) ;\n apr_table_setn ( env , MGS_SIDE ( \"_V_END\" ) , apr_pstrdup ( r -> pool , tmp ) ) ;\n tmp = mgs_time2sz ( gnutls_openpgp_crt_get_creation_time ( cert ) , buf , sizeof ( buf ) ) ;\n apr_table_setn ( env , MGS_SIDE ( \"_V_START\" ) , apr_pstrdup ( r -> pool , tmp ) ) ;\n ret = gnutls_openpgp_crt_get_pk_algorithm ( cert , NULL ) ;\n if ( ret >= 0 ) {\n apr_table_setn ( env , MGS_SIDE ( \"_A_KEY\" ) , gnutls_pk_algorithm_get_name ( ret ) ) ;\n }\n }\n static int mgs_cert_verify ( request_rec * r , mgs_handle_t * ctxt ) {\n const gnutls_datum_t * cert_list ;\n unsigned int cert_list_size , status ;\n int rv = GNUTLS_E_NO_CERTIFICATE_FOUND , ret ;\n unsigned int ch_size = 0 ;\n union {\n gnutls_x509_crt_t x509 [ MAX_CHAIN_SIZE ] ;\n gnutls_openpgp_crt_t pgp ;\n }\n cert ;\n apr_time_t expiration_time , cur_time ;\n if ( r == NULL || ctxt == NULL || ctxt -> session == NULL ) return HTTP_FORBIDDEN ;\n _gnutls_log ( debug_log_fp , \"%s: %d\\n\" , __func__ , __LINE__ ) ;\n cert_list = gnutls_certificate_get_peers ( ctxt -> session , & cert_list_size ) ;\n if ( cert_list == NULL || cert_list_size == 0 ) {\n if ( ctxt -> sc -> client_verify_mode == GNUTLS_CERT_REQUEST ) return OK ;\n ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , r , \"GnuTLS: Failed to Verify Peer: \" \"Client did not submit a certificate\" ) ;\n return HTTP_FORBIDDEN ;\n }\n if ( gnutls_certificate_type_get ( ctxt -> session ) == GNUTLS_CRT_X509 ) {\n ap_log_rerror ( APLOG_MARK , APLOG_DEBUG , 0 , r , \"GnuTLS: A Chain of %d certificate(s) was provided for validation\" , cert_list_size ) ;\n for ( ch_size = 0 ;\n ch_size < cert_list_size ;\n ch_size ++ ) {\n gnutls_x509_crt_init ( & cert . x509 [ ch_size ] ) ;\n rv = gnutls_x509_crt_import ( cert . x509 [ ch_size ] , & cert_list [ ch_size ] , GNUTLS_X509_FMT_DER ) ;\n if ( rv != GNUTLS_E_SUCCESS ) {\n if ( ch_size < 1 ) {\n ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , r , \"GnuTLS: Failed to Verify Peer: \" \"Failed to import peer certificates.\" ) ;\n ret = HTTP_FORBIDDEN ;\n goto exit ;\n }\n ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , r , \"GnuTLS: Failed to import some peer certificates. Using %d certificates\" , ch_size ) ;\n rv = GNUTLS_E_SUCCESS ;\n break ;\n }\n }\n }\n else if ( gnutls_certificate_type_get ( ctxt -> session ) == GNUTLS_CRT_OPENPGP ) {\n if ( cert_list_size > 1 ) {\n ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , r , \"GnuTLS: Failed to Verify Peer: \" \"Chained Client Certificates are not supported.\" ) ;\n return HTTP_FORBIDDEN ;\n }\n gnutls_openpgp_crt_init ( & cert . pgp ) ;\n rv = gnutls_openpgp_crt_import ( cert . pgp , & cert_list [ 0 ] , GNUTLS_OPENPGP_FMT_RAW ) ;\n }\n else return HTTP_FORBIDDEN ;\n if ( rv < 0 ) {\n ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , r , \"GnuTLS: Failed to Verify Peer: \" \"Failed to import peer certificates.\" ) ;\n ret = HTTP_FORBIDDEN ;\n goto exit ;\n }\n if ( gnutls_certificate_type_get ( ctxt -> session ) == GNUTLS_CRT_X509 ) {\n apr_time_ansi_put ( & expiration_time , gnutls_x509_crt_get_expiration_time ( cert . x509 [ 0 ] ) ) ;\n ap_log_rerror ( APLOG_MARK , APLOG_DEBUG , 0 , r , \"GnuTLS: Verifying list of %d certificate(s) via method '%s'\" , ch_size , mgs_readable_cvm ( ctxt -> sc -> client_verify_method ) ) ;\n switch ( ctxt -> sc -> client_verify_method ) {\n case mgs_cvm_cartel : rv = gnutls_x509_crt_list_verify ( cert . x509 , ch_size , ctxt -> sc -> ca_list , ctxt -> sc -> ca_list_size , NULL , 0 , 0 , & status ) ;\n break ;\n # ifdef ENABLE_MSVA case mgs_cvm_msva : {\n struct msv_response * resp = NULL ;\n struct msv_query q = {\n . context = \"https\" , . peertype = \"client\" , . pkctype = \"x509pem\" }\n ;\n msv_ctxt_t ctx = msv_ctxt_init ( NULL ) ;\n char cert_pem_buf [ 10 * 1024 ] ;\n size_t len = sizeof ( cert_pem_buf ) ;\n rv = 0 ;\n if ( gnutls_x509_crt_export ( cert . x509 [ 0 ] , GNUTLS_X509_FMT_PEM , cert_pem_buf , & len ) >= 0 ) {\n q . peername = mgs_x509_construct_uid ( r , cert . x509 [ 0 ] ) ;\n q . pkcdata = cert_pem_buf ;\n rv = msv_query_agent ( ctx , q , & resp ) ;\n if ( rv == LIBMSV_ERROR_SUCCESS ) {\n status = 0 ;\n }\n else if ( rv == LIBMSV_ERROR_INVALID ) {\n ap_log_rerror ( APLOG_MARK , APLOG_DEBUG , 0 , r , \"GnuTLS: Monkeysphere validation failed: (message: %s)\" , resp -> message ) ;\n status = GNUTLS_CERT_INVALID ;\n }\n else {\n ap_log_rerror ( APLOG_MARK , APLOG_DEBUG , 0 , r , \"GnuTLS: Error communicating with the Monkeysphere Validation Agent: (%d) %s\" , rv , msv_strerror ( ctx , rv ) ) ;\n status = GNUTLS_CERT_INVALID ;\n rv = - 1 ;\n }\n }\n else {\n ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , r , \"GnuTLS: Could not convert the client certificate to PEM format\" ) ;\n status = GNUTLS_CERT_INVALID ;\n rv = GNUTLS_E_ASN1_ELEMENT_NOT_FOUND ;\n }\n msv_response_destroy ( resp ) ;\n msv_ctxt_destroy ( ctx ) ;\n }\n break ;\n # endif default : ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , r , \"GnuTLS: Failed to Verify X.509 Peer: method '%s' is not supported\" , mgs_readable_cvm ( ctxt -> sc -> client_verify_method ) ) ;\n }\n }\n else {\n apr_time_ansi_put ( & expiration_time , gnutls_openpgp_crt_get_expiration_time ( cert . pgp ) ) ;\n switch ( ctxt -> sc -> client_verify_method ) {\n case mgs_cvm_cartel : rv = gnutls_openpgp_crt_verify_ring ( cert . pgp , ctxt -> sc -> pgp_list , 0 , & status ) ;\n break ;\n # ifdef ENABLE_MSVA case mgs_cvm_msva : ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , r , \"GnuTLS: OpenPGP verification via MSVA is not yet implemented\" ) ;\n rv = GNUTLS_E_UNIMPLEMENTED_FEATURE ;\n break ;\n # endif default : ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , r , \"GnuTLS: Failed to Verify OpenPGP Peer: method '%s' is not supported\" , mgs_readable_cvm ( ctxt -> sc -> client_verify_method ) ) ;\n }\n }\n if ( rv < 0 ) {\n ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , r , \"GnuTLS: Failed to Verify Peer certificate: (%d) %s\" , rv , gnutls_strerror ( rv ) ) ;\n if ( rv == GNUTLS_E_NO_CERTIFICATE_FOUND ) ap_log_rerror ( APLOG_MARK , APLOG_EMERG , 0 , r , \"GnuTLS: No certificate was found for verification. Did you set the GnuTLSX509CAFile or GnuTLSPGPKeyringFile directives?\" ) ;\n ret = HTTP_FORBIDDEN ;\n goto exit ;\n }\n cur_time = apr_time_now ( ) ;\n if ( status & GNUTLS_CERT_SIGNER_NOT_FOUND ) {\n ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , r , \"GnuTLS: Could not find Signer for Peer Certificate\" ) ;\n }\n if ( status & GNUTLS_CERT_SIGNER_NOT_CA ) {\n ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , r , \"GnuTLS: Peer's Certificate signer is not a CA\" ) ;\n }\n if ( status & GNUTLS_CERT_INSECURE_ALGORITHM ) {\n ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , r , \"GnuTLS: Peer's Certificate is using insecure algorithms\" ) ;\n }\n if ( status & GNUTLS_CERT_EXPIRED || status & GNUTLS_CERT_NOT_ACTIVATED ) {\n ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , r , \"GnuTLS: Peer's Certificate signer is expired or not yet activated\" ) ;\n }\n if ( status & GNUTLS_CERT_INVALID ) {\n ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , r , \"GnuTLS: Peer Certificate is invalid.\" ) ;\n }\n else if ( status & GNUTLS_CERT_REVOKED ) {\n ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , r , \"GnuTLS: Peer Certificate is revoked.\" ) ;\n }\n if ( gnutls_certificate_type_get ( ctxt -> session ) == GNUTLS_CRT_X509 ) mgs_add_common_cert_vars ( r , cert . x509 [ 0 ] , 1 , ctxt -> sc -> export_certificates_size ) ;\n else if ( gnutls_certificate_type_get ( ctxt -> session ) == GNUTLS_CRT_OPENPGP ) mgs_add_common_pgpcert_vars ( r , cert . pgp , 1 , ctxt -> sc -> export_certificates_size ) ;\n {\n unsigned long remain = ( apr_time_sec ( expiration_time ) - apr_time_sec ( cur_time ) ) / 86400 ;\n apr_table_setn ( r -> subprocess_env , \"SSL_CLIENT_V_REMAIN\" , apr_psprintf ( r -> pool , \"%lu\" , remain ) ) ;\n }\n if ( status == 0 ) {\n apr_table_setn ( r -> subprocess_env , \"SSL_CLIENT_VERIFY\" , \"SUCCESS\" ) ;\n ret = OK ;\n }\n else {\n apr_table_setn ( r -> subprocess_env , \"SSL_CLIENT_VERIFY\" , \"FAILED\" ) ;\n if ( ctxt -> sc -> client_verify_mode == GNUTLS_CERT_REQUEST ) ret = OK ;\n else ret = HTTP_FORBIDDEN ;\n }\n exit : if ( gnutls_certificate_type_get ( ctxt -> session ) == GNUTLS_CRT_X509 ) {\n unsigned int i ;\n for ( i = 0 ;\n i < ch_size ;\n i ++ ) {\n gnutls_x509_crt_deinit ( cert . x509 [ i ] ) ;\n }\n }\n else if ( gnutls_certificate_type_get ( ctxt -> session ) == GNUTLS_CRT_OPENPGP ) gnutls_openpgp_crt_deinit ( cert . pgp ) ;\n return ret ;\n }\n # ifdef ENABLE_MSVA static const char * mgs_x509_leaf_oid_from_dn ( apr_pool_t * pool , const char * oid , gnutls_x509_crt_t cert ) {\n int rv = GNUTLS_E_SUCCESS , i ;\n size_t sz = 0 , lastsz = 0 ;\n char * data = NULL ;\n i = - 1 ;\n while ( rv != GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE ) {\n i ++ ;\n lastsz = sz ;\n sz = 0 ;\n rv = gnutls_x509_crt_get_dn_by_oid ( cert , oid , i , 0 , NULL , & sz ) ;\n }\n if ( i > 0 ) {\n data = apr_palloc ( pool , lastsz ) ;\n sz = lastsz ;\n rv = gnutls_x509_crt_get_dn_by_oid ( cert , oid , i - 1 , 0 , data , & sz ) ;\n if ( rv == GNUTLS_E_SUCCESS ) return data ;\n }\n return NULL ;\n }\n static const char * mgs_x509_first_type_from_san ( apr_pool_t * pool , gnutls_x509_subject_alt_name_t target , gnutls_x509_crt_t cert ) {\n int rv = GNUTLS_E_SUCCESS ;\n size_t sz ;\n char * data = NULL ;\n unsigned int i ;\n gnutls_x509_subject_alt_name_t thistype ;\n i = 0 ;\n while ( rv != GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE ) {\n sz = 0 ;\n rv = gnutls_x509_crt_get_subject_alt_name2 ( cert , i , NULL , & sz , & thistype , NULL ) ;\n if ( rv == GNUTLS_E_SHORT_MEMORY_BUFFER && thistype == target ) {\n data = apr_palloc ( pool , sz ) ;\n rv = gnutls_x509_crt_get_subject_alt_name2 ( cert , i , data , & sz , & thistype , NULL ) ;\n if ( rv >= 0 && ( thistype == target ) ) return data ;\n }\n i ++ ;\n }\n return NULL ;\n }\n static const char * mgs_x509_construct_uid ( request_rec * r , gnutls_x509_crt_t cert ) {\n apr_pool_t * pool = r -> pool ;\n const char * name = NULL , * comment = NULL , * email = NULL ;\n const char * ret = NULL ;\n apr_pool_t * sp = NULL ;\n if ( APR_SUCCESS != apr_pool_create ( & sp , pool ) ) return NULL ;\n name = mgs_x509_leaf_oid_from_dn ( sp , GNUTLS_OID_X520_COMMON_NAME , cert ) ;\n comment = mgs_x509_leaf_oid_from_dn ( sp , GNUTLS_OID_X520_PSEUDONYM , cert ) ;\n email = mgs_x509_first_type_from_san ( sp , GNUTLS_SAN_RFC822NAME , cert ) ;\n if ( email == NULL ) email = mgs_x509_leaf_oid_from_dn ( sp , GNUTLS_OID_PKCS9_EMAIL , cert ) ;\n if ( name == NULL && email == NULL ) {\n ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , r , \"GnuTLS: Need either a name or an e-mail address to get a User ID from an X.509 certificate.\" ) ;\n goto end ;\n }\n if ( name ) {\n if ( comment ) {\n if ( email ) {\n ret = apr_psprintf ( pool , \"%s (%s) <%s>\" , name , comment , email ) ;\n }\n else {\n ret = apr_psprintf ( pool , \"%s (%s)\" , name , comment ) ;\n }\n }\n else {\n if ( email ) {\n ret = apr_psprintf ( pool , \"%s <%s>\" , name , email ) ;\n }\n else {\n ret = apr_pstrdup ( pool , name ) ;\n }\n }\n }\n else {\n if ( comment ) {\n ret = apr_psprintf ( pool , \"(%s) <%s>\" , comment , email ) ;\n }\n else {\n ret = apr_psprintf ( pool , \"<%s>\" , email ) ;\n }\n }\n end : apr_pool_destroy ( sp ) ;\n return ret ;\n }\n # endif static int mgs_status_hook ( request_rec * r , int flags __attribute__ ( ( unused ) ) ) {\n mgs_srvconf_rec * sc ;\n if ( r == NULL ) return OK ;\n sc = ( mgs_srvconf_rec * ) ap_get_module_config ( r -> server -> module_config , & gnutls_module ) ;\n _gnutls_log ( debug_log_fp , \"%s: %d\\n\" , __func__ , __LINE__ ) ;\n ap_rputs ( \"<hr>\\n\" , r ) ;\n ap_rputs ( \"<h2>GnuTLS Information:</h2>\\n<dl>\\n\" , r ) ;\n ap_rprintf ( r , \"<dt>GnuTLS version:</dt><dd>%s</dd>\\n\" , gnutls_check_version ( NULL ) ) ;\n ap_rputs ( \"<dt>Built against:</dt><dd>\" GNUTLS_VERSION \"</dd>\\n\" , r ) ;\n ap_rprintf ( r , \"<dt>using TLS:</dt><dd>%s</dd>\\n\" , ( sc -> enabled == GNUTLS_ENABLED_FALSE ? \"no\" : \"yes\" ) ) ;\n if ( sc -> enabled != GNUTLS_ENABLED_FALSE ) {\n mgs_handle_t * ctxt ;\n ctxt = ap_get_module_config ( r -> connection -> conn_config , & gnutls_module ) ;\n if ( ctxt && ctxt -> session != NULL ) {\n # if GNUTLS_VERSION_MAJOR < 3 ap_rprintf ( r , \"<dt>This TLS Session:</dt><dd>%s</dd>\\n\" , gnutls_cipher_suite_get_name ( gnutls_kx_get ( ctxt -> session ) , gnutls_cipher_get ( ctxt -> session ) , gnutls_mac_get ( ctxt -> session ) ) ) ;\n # else char * z = NULL ;\n z = gnutls_session_get_desc ( ctxt -> session ) ;\n if ( z ) {\n ap_rprintf ( r , \"<dt>This TLS Session:</dt><dd>%s</dd>\\n\" , z ) ;\n gnutls_free ( z ) ;\n }\n # endif }\n }\n ap_rputs ( \"</dl>\\n\" , r ) ;\n return OK ;\n }", "idx": 1112}
{"hash": -3889154245145551951, "project": "debian", "size": 5, "label": 0, "functionSource": "static unsigned int hc_str ( const char * s , size_t len ) {\n unsigned int r = 0 ;\n while ( len -- > 0 ) r = r * 31 + * s ++ ;\n return r ;\n }", "idx": 1113}
{"hash": 7863876744031385021, "project": "debian", "size": 5, "label": 0, "functionSource": "static void fts_mail_build_ctx_set_lang ( struct fts_mail_build_context * ctx , struct fts_user_language * user_lang ) {\n i_assert ( user_lang != NULL ) ;\n ctx -> cur_user_lang = user_lang ;\n fts_tokenizer_reset ( user_lang -> index_tokenizer ) ;\n }", "idx": 1114}
{"hash": -6068399010699045437, "project": "debian", "size": 3, "label": 0, "functionSource": "static int decode_blockcodes ( int code1 , int code2 , int levels , int * values ) {\n return decode_blockcode ( code1 , levels , values ) | decode_blockcode ( code2 , levels , values + 4 ) ;\n }", "idx": 1115}
{"hash": -7855974557509681261, "project": "debian", "size": 11, "label": 0, "functionSource": "void get_op_opfamily_properties ( Oid opno , Oid opfamily , bool ordering_op , int * strategy , Oid * lefttype , Oid * righttype ) {\n HeapTuple tp ;\n Form_pg_amop amop_tup ;\n tp = SearchSysCache3 ( AMOPOPID , ObjectIdGetDatum ( opno ) , CharGetDatum ( ordering_op ? AMOP_ORDER : AMOP_SEARCH ) , ObjectIdGetDatum ( opfamily ) ) ;\n if ( ! HeapTupleIsValid ( tp ) ) elog ( ERROR , \"operator %u is not a member of opfamily %u\" , opno , opfamily ) ;\n amop_tup = ( Form_pg_amop ) GETSTRUCT ( tp ) ;\n * strategy = amop_tup -> amopstrategy ;\n * lefttype = amop_tup -> amoplefttype ;\n * righttype = amop_tup -> amoprighttype ;\n ReleaseSysCache ( tp ) ;\n }", "idx": 1116}
{"hash": 8484475213808847345, "project": "debian", "size": 10, "label": 0, "functionSource": "void do_info_qdm ( Monitor * mon ) {\n DeviceInfo * info ;\n char msg [ 256 ] ;\n for ( info = device_info_list ;\n info != NULL ;\n info = info -> next ) {\n qdev_print_devinfo ( info , msg , sizeof ( msg ) ) ;\n monitor_printf ( mon , \"%s\\n\" , msg ) ;\n }\n }", "idx": 1117}
{"hash": -1335877942018854351, "project": "chrome", "size": 4, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( FastUnloadTest , DISABLED_WindowCloseFinishesUnload ) {\n NavigateToPage ( \"no_listeners\" ) ;\n EXPECT_EQ ( \"unloaded=ohyeah\" , GetCookies ( \"no_listeners\" ) ) ;\n }", "idx": 1118}
{"hash": -8721757784652752372, "project": "debian", "size": 17, "label": 0, "functionSource": "static uint_fast32_t jpc_abstorelstepsize ( jpc_fix_t absdelta , int scaleexpn ) {\n int p ;\n uint_fast32_t mant ;\n uint_fast32_t expn ;\n int n ;\n if ( absdelta < 0 ) {\n abort ( ) ;\n }\n p = jpc_firstone ( absdelta ) - JPC_FIX_FRACBITS ;\n n = 11 - jpc_firstone ( absdelta ) ;\n mant = ( ( n < 0 ) ? ( absdelta >> ( - n ) ) : ( absdelta << n ) ) & 0x7ff ;\n expn = scaleexpn - p ;\n if ( scaleexpn < p ) {\n abort ( ) ;\n }\n return JPC_QCX_EXPN ( expn ) | JPC_QCX_MANT ( mant ) ;\n }", "idx": 1119}
{"hash": -7553540414561818627, "project": "debian", "size": 9, "label": 0, "functionSource": "static void print_word ( BIO * bp , BN_ULONG w ) {\n # ifdef SIXTY_FOUR_BIT if ( sizeof ( w ) > sizeof ( unsigned long ) ) {\n unsigned long h = ( unsigned long ) ( w >> 32 ) , l = ( unsigned long ) ( w ) ;\n if ( h ) BIO_printf ( bp , \"%lX%08lX\" , h , l ) ;\n else BIO_printf ( bp , \"%lX\" , l ) ;\n return ;\n }\n # endif BIO_printf ( bp , BN_HEX_FMT1 , w ) ;\n }", "idx": 1120}
{"hash": 1859256631654516868, "project": "chrome", "size": 198, "label": 0, "functionSource": "static int decode_nal_units ( H264Context * h , const uint8_t * buf , int buf_size , int parse_extradata ) {\n AVCodecContext * const avctx = h -> avctx ;\n H264Context * hx ;\n int buf_index ;\n int context_count ;\n int next_avc ;\n int pass = ! ( avctx -> active_thread_type & FF_THREAD_FRAME ) ;\n int nals_needed = 0 ;\n int nal_index ;\n int idr_cleared = 0 ;\n int first_slice = 0 ;\n int ret = 0 ;\n h -> nal_unit_type = 0 ;\n if ( ! h -> slice_context_count ) h -> slice_context_count = 1 ;\n h -> max_contexts = h -> slice_context_count ;\n if ( ! ( avctx -> flags2 & CODEC_FLAG2_CHUNKS ) ) {\n h -> current_slice = 0 ;\n if ( ! h -> first_field ) h -> cur_pic_ptr = NULL ;\n ff_h264_reset_sei ( h ) ;\n }\n if ( h -> nal_length_size == 4 ) {\n if ( buf_size > 8 && AV_RB32 ( buf ) == 1 && AV_RB32 ( buf + 5 ) > ( unsigned ) buf_size ) {\n h -> is_avc = 0 ;\n }\n else if ( buf_size > 3 && AV_RB32 ( buf ) > 1 && AV_RB32 ( buf ) <= ( unsigned ) buf_size ) h -> is_avc = 1 ;\n }\n for ( ;\n pass <= 1 ;\n pass ++ ) {\n buf_index = 0 ;\n context_count = 0 ;\n next_avc = h -> is_avc ? 0 : buf_size ;\n nal_index = 0 ;\n for ( ;\n ;\n ) {\n int consumed ;\n int dst_length ;\n int bit_length ;\n const uint8_t * ptr ;\n int i , nalsize = 0 ;\n int err ;\n if ( buf_index >= next_avc ) {\n if ( buf_index >= buf_size - h -> nal_length_size ) break ;\n nalsize = 0 ;\n for ( i = 0 ;\n i < h -> nal_length_size ;\n i ++ ) nalsize = ( nalsize << 8 ) | buf [ buf_index ++ ] ;\n if ( nalsize <= 0 || nalsize > buf_size - buf_index ) {\n av_log ( h -> avctx , AV_LOG_ERROR , \"AVC: nal size %d\\n\" , nalsize ) ;\n break ;\n }\n next_avc = buf_index + nalsize ;\n }\n else {\n for ( ;\n buf_index + 3 < next_avc ;\n buf_index ++ ) if ( buf [ buf_index ] == 0 && buf [ buf_index + 1 ] == 0 && buf [ buf_index + 2 ] == 1 ) break ;\n if ( buf_index + 3 >= buf_size ) {\n buf_index = buf_size ;\n break ;\n }\n buf_index += 3 ;\n if ( buf_index >= next_avc ) continue ;\n }\n hx = h -> thread_context [ context_count ] ;\n ptr = ff_h264_decode_nal ( hx , buf + buf_index , & dst_length , & consumed , next_avc - buf_index ) ;\n if ( ptr == NULL || dst_length < 0 ) {\n ret = - 1 ;\n goto end ;\n }\n i = buf_index + consumed ;\n if ( ( h -> workaround_bugs & FF_BUG_AUTODETECT ) && i + 3 < next_avc && buf [ i ] == 0x00 && buf [ i + 1 ] == 0x00 && buf [ i + 2 ] == 0x01 && buf [ i + 3 ] == 0xE0 ) h -> workaround_bugs |= FF_BUG_TRUNCATED ;\n if ( ! ( h -> workaround_bugs & FF_BUG_TRUNCATED ) ) while ( dst_length > 0 && ptr [ dst_length - 1 ] == 0 ) dst_length -- ;\n bit_length = ! dst_length ? 0 : ( 8 * dst_length - decode_rbsp_trailing ( h , ptr + dst_length - 1 ) ) ;\n if ( h -> avctx -> debug & FF_DEBUG_STARTCODE ) av_log ( h -> avctx , AV_LOG_DEBUG , \"NAL %d/%d at %d/%d length %d pass %d\\n\" , hx -> nal_unit_type , hx -> nal_ref_idc , buf_index , buf_size , dst_length , pass ) ;\n if ( h -> is_avc && ( nalsize != consumed ) && nalsize ) av_log ( h -> avctx , AV_LOG_DEBUG , \"AVC: Consumed only %d bytes instead of %d\\n\" , consumed , nalsize ) ;\n buf_index += consumed ;\n nal_index ++ ;\n if ( pass == 0 ) {\n switch ( hx -> nal_unit_type ) {\n case NAL_SPS : case NAL_PPS : nals_needed = nal_index ;\n break ;\n case NAL_DPA : case NAL_IDR_SLICE : case NAL_SLICE : init_get_bits ( & hx -> gb , ptr , bit_length ) ;\n if ( ! get_ue_golomb ( & hx -> gb ) || ! first_slice ) nals_needed = nal_index ;\n if ( ! first_slice ) first_slice = hx -> nal_unit_type ;\n }\n continue ;\n }\n if ( ! first_slice ) switch ( hx -> nal_unit_type ) {\n case NAL_DPA : case NAL_IDR_SLICE : case NAL_SLICE : first_slice = hx -> nal_unit_type ;\n }\n if ( avctx -> skip_frame >= AVDISCARD_NONREF && h -> nal_ref_idc == 0 && h -> nal_unit_type != NAL_SEI ) continue ;\n again : if ( parse_extradata ) {\n switch ( hx -> nal_unit_type ) {\n case NAL_IDR_SLICE : case NAL_SLICE : case NAL_DPA : case NAL_DPB : case NAL_DPC : av_log ( h -> avctx , AV_LOG_WARNING , \"Ignoring NAL %d in global header/extradata\\n\" , hx -> nal_unit_type ) ;\n case NAL_AUXILIARY_SLICE : hx -> nal_unit_type = NAL_FF_IGNORE ;\n }\n }\n err = 0 ;\n switch ( hx -> nal_unit_type ) {\n case NAL_IDR_SLICE : if ( first_slice != NAL_IDR_SLICE ) {\n av_log ( h -> avctx , AV_LOG_ERROR , \"Invalid mix of idr and non-idr slices\\n\" ) ;\n ret = - 1 ;\n goto end ;\n }\n if ( ! idr_cleared ) idr ( h ) ;\n idr_cleared = 1 ;\n case NAL_SLICE : init_get_bits ( & hx -> gb , ptr , bit_length ) ;\n hx -> intra_gb_ptr = hx -> inter_gb_ptr = & hx -> gb ;\n hx -> data_partitioning = 0 ;\n if ( ( err = decode_slice_header ( hx , h ) ) ) break ;\n if ( h -> sei_recovery_frame_cnt >= 0 ) {\n if ( h -> frame_num != h -> sei_recovery_frame_cnt || hx -> slice_type_nos != AV_PICTURE_TYPE_I ) h -> valid_recovery_point = 1 ;\n if ( h -> recovery_frame < 0 || ( ( h -> recovery_frame - h -> frame_num ) & ( ( 1 << h -> sps . log2_max_frame_num ) - 1 ) ) > h -> sei_recovery_frame_cnt ) {\n h -> recovery_frame = ( h -> frame_num + h -> sei_recovery_frame_cnt ) & ( ( 1 << h -> sps . log2_max_frame_num ) - 1 ) ;\n if ( ! h -> valid_recovery_point ) h -> recovery_frame = h -> frame_num ;\n }\n }\n h -> cur_pic_ptr -> f . key_frame |= ( hx -> nal_unit_type == NAL_IDR_SLICE ) ;\n if ( hx -> nal_unit_type == NAL_IDR_SLICE || h -> recovery_frame == h -> frame_num ) {\n h -> recovery_frame = - 1 ;\n h -> cur_pic_ptr -> recovered = 1 ;\n }\n if ( hx -> nal_unit_type == NAL_IDR_SLICE ) h -> frame_recovered |= FRAME_RECOVERED_IDR ;\n h -> frame_recovered |= 3 * ! ! ( avctx -> flags2 & CODEC_FLAG2_SHOW_ALL ) ;\n h -> frame_recovered |= 3 * ! ! ( avctx -> flags & CODEC_FLAG_OUTPUT_CORRUPT ) ;\n # if 1 h -> cur_pic_ptr -> recovered |= h -> frame_recovered ;\n # else h -> cur_pic_ptr -> recovered |= ! ! ( h -> frame_recovered & FRAME_RECOVERED_IDR ) ;\n # endif if ( h -> current_slice == 1 ) {\n if ( ! ( avctx -> flags2 & CODEC_FLAG2_CHUNKS ) ) decode_postinit ( h , nal_index >= nals_needed ) ;\n if ( h -> avctx -> hwaccel && ( ret = h -> avctx -> hwaccel -> start_frame ( h -> avctx , NULL , 0 ) ) < 0 ) return ret ;\n if ( CONFIG_H264_VDPAU_DECODER && h -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU ) ff_vdpau_h264_picture_start ( h ) ;\n }\n if ( hx -> redundant_pic_count == 0 && ( avctx -> skip_frame < AVDISCARD_NONREF || hx -> nal_ref_idc ) && ( avctx -> skip_frame < AVDISCARD_BIDIR || hx -> slice_type_nos != AV_PICTURE_TYPE_B ) && ( avctx -> skip_frame < AVDISCARD_NONKEY || hx -> slice_type_nos == AV_PICTURE_TYPE_I ) && avctx -> skip_frame < AVDISCARD_ALL ) {\n if ( avctx -> hwaccel ) {\n ret = avctx -> hwaccel -> decode_slice ( avctx , & buf [ buf_index - consumed ] , consumed ) ;\n if ( ret < 0 ) return ret ;\n }\n else if ( CONFIG_H264_VDPAU_DECODER && h -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU ) {\n ff_vdpau_add_data_chunk ( h -> cur_pic_ptr -> f . data [ 0 ] , start_code , sizeof ( start_code ) ) ;\n ff_vdpau_add_data_chunk ( h -> cur_pic_ptr -> f . data [ 0 ] , & buf [ buf_index - consumed ] , consumed ) ;\n }\n else context_count ++ ;\n }\n break ;\n case NAL_DPA : init_get_bits ( & hx -> gb , ptr , bit_length ) ;\n hx -> intra_gb_ptr = hx -> inter_gb_ptr = NULL ;\n if ( ( err = decode_slice_header ( hx , h ) ) < 0 ) break ;\n hx -> data_partitioning = 1 ;\n break ;\n case NAL_DPB : init_get_bits ( & hx -> intra_gb , ptr , bit_length ) ;\n hx -> intra_gb_ptr = & hx -> intra_gb ;\n break ;\n case NAL_DPC : init_get_bits ( & hx -> inter_gb , ptr , bit_length ) ;\n hx -> inter_gb_ptr = & hx -> inter_gb ;\n av_log ( h -> avctx , AV_LOG_ERROR , \"Partitioned H.264 support is incomplete\\n\" ) ;\n break ;\n if ( hx -> redundant_pic_count == 0 && hx -> intra_gb_ptr && hx -> data_partitioning && h -> cur_pic_ptr && h -> context_initialized && ( avctx -> skip_frame < AVDISCARD_NONREF || hx -> nal_ref_idc ) && ( avctx -> skip_frame < AVDISCARD_BIDIR || hx -> slice_type_nos != AV_PICTURE_TYPE_B ) && ( avctx -> skip_frame < AVDISCARD_NONKEY || hx -> slice_type_nos == AV_PICTURE_TYPE_I ) && avctx -> skip_frame < AVDISCARD_ALL ) context_count ++ ;\n break ;\n case NAL_SEI : init_get_bits ( & h -> gb , ptr , bit_length ) ;\n ff_h264_decode_sei ( h ) ;\n break ;\n case NAL_SPS : init_get_bits ( & h -> gb , ptr , bit_length ) ;\n if ( ff_h264_decode_seq_parameter_set ( h ) < 0 && ( h -> is_avc ? nalsize : 1 ) ) {\n av_log ( h -> avctx , AV_LOG_DEBUG , \"SPS decoding failure, trying again with the complete NAL\\n\" ) ;\n if ( h -> is_avc ) av_assert0 ( next_avc - buf_index + consumed == nalsize ) ;\n if ( ( next_avc - buf_index + consumed - 1 ) >= INT_MAX / 8 ) break ;\n init_get_bits ( & h -> gb , & buf [ buf_index + 1 - consumed ] , 8 * ( next_avc - buf_index + consumed - 1 ) ) ;\n ff_h264_decode_seq_parameter_set ( h ) ;\n }\n break ;\n case NAL_PPS : init_get_bits ( & h -> gb , ptr , bit_length ) ;\n ff_h264_decode_picture_parameter_set ( h , bit_length ) ;\n break ;\n case NAL_AUD : case NAL_END_SEQUENCE : case NAL_END_STREAM : case NAL_FILLER_DATA : case NAL_SPS_EXT : case NAL_AUXILIARY_SLICE : break ;\n case NAL_FF_IGNORE : break ;\n default : av_log ( avctx , AV_LOG_DEBUG , \"Unknown NAL code: %d (%d bits)\\n\" , hx -> nal_unit_type , bit_length ) ;\n }\n if ( context_count == h -> max_contexts ) {\n execute_decode_slices ( h , context_count ) ;\n context_count = 0 ;\n }\n if ( err < 0 ) av_log ( h -> avctx , AV_LOG_ERROR , \"decode_slice_header error\\n\" ) ;\n else if ( err == 1 ) {\n h -> nal_unit_type = hx -> nal_unit_type ;\n h -> nal_ref_idc = hx -> nal_ref_idc ;\n hx = h ;\n goto again ;\n }\n }\n }\n if ( context_count ) execute_decode_slices ( h , context_count ) ;\n end : if ( h -> cur_pic_ptr && ! h -> droppable ) {\n ff_thread_report_progress ( & h -> cur_pic_ptr -> tf , INT_MAX , h -> picture_structure == PICT_BOTTOM_FIELD ) ;\n }\n return ( ret < 0 ) ? ret : buf_index ;\n }", "idx": 1121}
{"hash": -2751047985690578371, "project": "debian", "size": 58, "label": 0, "functionSource": "static void generate ( ELG_secret_key * sk , unsigned int nbits , MPI * * ret_factors ) {\n MPI p ;\n MPI p_min1 ;\n MPI g ;\n MPI x ;\n MPI y ;\n MPI temp ;\n unsigned int qbits ;\n unsigned int xbits ;\n byte * rndbuf ;\n p_min1 = mpi_alloc ( mpi_nlimb_hint_from_nbits ( nbits ) ) ;\n temp = mpi_alloc ( mpi_nlimb_hint_from_nbits ( nbits ) ) ;\n qbits = wiener_map ( nbits ) ;\n if ( qbits & 1 ) qbits ++ ;\n g = mpi_alloc ( 1 ) ;\n p = generate_elg_prime ( 0 , nbits , qbits , g , ret_factors ) ;\n mpi_sub_ui ( p_min1 , p , 1 ) ;\n xbits = qbits * 3 / 2 ;\n if ( xbits >= nbits ) BUG ( ) ;\n x = mpi_alloc_secure ( mpi_nlimb_hint_from_nbits ( xbits ) ) ;\n if ( DBG_CIPHER ) log_debug ( \"choosing a random x of size %u\" , xbits ) ;\n rndbuf = NULL ;\n do {\n if ( DBG_CIPHER ) progress ( '.' ) ;\n if ( rndbuf ) {\n if ( xbits < 16 ) {\n xfree ( rndbuf ) ;\n rndbuf = get_random_bits ( xbits , 2 , 1 ) ;\n }\n else {\n char * r = get_random_bits ( 16 , 2 , 1 ) ;\n memcpy ( rndbuf , r , 16 / 8 ) ;\n xfree ( r ) ;\n }\n }\n else rndbuf = get_random_bits ( xbits , 2 , 1 ) ;\n mpi_set_buffer ( x , rndbuf , ( xbits + 7 ) / 8 , 0 ) ;\n mpi_clear_highbit ( x , xbits + 1 ) ;\n }\n while ( ! ( mpi_cmp_ui ( x , 0 ) > 0 && mpi_cmp ( x , p_min1 ) < 0 ) ) ;\n xfree ( rndbuf ) ;\n y = mpi_alloc ( mpi_nlimb_hint_from_nbits ( nbits ) ) ;\n mpi_powm ( y , g , x , p ) ;\n if ( DBG_CIPHER ) {\n progress ( '\\n' ) ;\n log_mpidump ( \"elg p= \" , p ) ;\n log_mpidump ( \"elg g= \" , g ) ;\n log_mpidump ( \"elg y= \" , y ) ;\n log_mpidump ( \"elg x= \" , x ) ;\n }\n sk -> p = p ;\n sk -> g = g ;\n sk -> y = y ;\n sk -> x = x ;\n test_keys ( sk , nbits - 64 ) ;\n mpi_free ( p_min1 ) ;\n mpi_free ( temp ) ;\n }", "idx": 1122}
{"hash": -2928324134072492299, "project": "debian", "size": 12, "label": 0, "functionSource": "void t38_init_tap ( void ) {\n GString * error_string ;\n if ( have_T38_tap_listener == FALSE ) {\n error_string = register_tap_listener ( \"t38\" , & ( the_tapinfo_struct . t38_dummy ) , NULL , 0 , voip_calls_dlg_reset , T38_packet , voip_calls_dlg_draw ) ;\n if ( error_string != NULL ) {\n simple_dialog ( ESD_TYPE_ERROR , ESD_BTN_OK , \"%s\" , error_string -> str ) ;\n g_string_free ( error_string , TRUE ) ;\n exit ( 1 ) ;\n }\n have_T38_tap_listener = TRUE ;\n }\n }", "idx": 1123}
{"hash": 3599206110384554647, "project": "debian", "size": 31, "label": 0, "functionSource": "int PEM_write_ ## name ( FILE * fp , type * x ) ;\n # define DECLARE_PEM_write_fp_const ( name , type ) int PEM_write_ ## name ( FILE * fp , const type * x ) ;\n # define DECLARE_PEM_write_cb_fp ( name , type ) int PEM_write_ ## name ( FILE * fp , type * x , const EVP_CIPHER * enc , unsigned char * kstr , int klen , pem_password_cb * cb , void * u ) ;\n # endif # define DECLARE_PEM_read_bio ( name , type ) type * PEM_read_bio_ ## name ( BIO * bp , type * * x , pem_password_cb * cb , void * u ) ;\n # define DECLARE_PEM_write_bio ( name , type ) int PEM_write_bio_ ## name ( BIO * bp , type * x ) ;\n # define DECLARE_PEM_write_bio_const ( name , type ) int PEM_write_bio_ ## name ( BIO * bp , const type * x ) ;\n # define DECLARE_PEM_write_cb_bio ( name , type ) int PEM_write_bio_ ## name ( BIO * bp , type * x , const EVP_CIPHER * enc , unsigned char * kstr , int klen , pem_password_cb * cb , void * u ) ;\n # define DECLARE_PEM_write ( name , type ) DECLARE_PEM_write_bio ( name , type ) DECLARE_PEM_write_fp ( name , type ) # define DECLARE_PEM_write_const ( name , type ) DECLARE_PEM_write_bio_const ( name , type ) DECLARE_PEM_write_fp_const ( name , type ) # define DECLARE_PEM_write_cb ( name , type ) DECLARE_PEM_write_cb_bio ( name , type ) DECLARE_PEM_write_cb_fp ( name , type ) # define DECLARE_PEM_read ( name , type ) DECLARE_PEM_read_bio ( name , type ) DECLARE_PEM_read_fp ( name , type ) # define DECLARE_PEM_rw ( name , type ) DECLARE_PEM_read ( name , type ) DECLARE_PEM_write ( name , type ) # define DECLARE_PEM_rw_const ( name , type ) DECLARE_PEM_read ( name , type ) DECLARE_PEM_write_const ( name , type ) # define DECLARE_PEM_rw_cb ( name , type ) DECLARE_PEM_read ( name , type ) DECLARE_PEM_write_cb ( name , type ) typedef int pem_password_cb ( char * buf , int size , int rwflag , void * userdata ) ;\n int PEM_get_EVP_CIPHER_INFO ( char * header , EVP_CIPHER_INFO * cipher ) ;\n int PEM_do_header ( EVP_CIPHER_INFO * cipher , unsigned char * data , long * len , pem_password_cb * callback , void * u ) ;\n int PEM_read_bio ( BIO * bp , char * * name , char * * header , unsigned char * * data , long * len ) ;\n # define PEM_FLAG_SECURE 0x1 # define PEM_FLAG_EAY_COMPATIBLE 0x2 # define PEM_FLAG_ONLY_B64 0x4 int PEM_read_bio_ex ( BIO * bp , char * * name , char * * header , unsigned char * * data , long * len , unsigned int flags ) ;\n int PEM_bytes_read_bio_secmem ( unsigned char * * pdata , long * plen , char * * pnm , const char * name , BIO * bp , pem_password_cb * cb , void * u ) ;\n int PEM_write_bio ( BIO * bp , const char * name , const char * hdr , const unsigned char * data , long len ) ;\n int PEM_bytes_read_bio ( unsigned char * * pdata , long * plen , char * * pnm , const char * name , BIO * bp , pem_password_cb * cb , void * u ) ;\n void * PEM_ASN1_read_bio ( d2i_of_void * d2i , const char * name , BIO * bp , void * * x , pem_password_cb * cb , void * u ) ;\n int PEM_ASN1_write_bio ( i2d_of_void * i2d , const char * name , BIO * bp , void * x , const EVP_CIPHER * enc , unsigned char * kstr , int klen , pem_password_cb * cb , void * u ) ;\n STACK_OF ( X509_INFO ) * PEM_X509_INFO_read_bio ( BIO * bp , STACK_OF ( X509_INFO ) * sk , pem_password_cb * cb , void * u ) ;\n int PEM_X509_INFO_write_bio ( BIO * bp , X509_INFO * xi , EVP_CIPHER * enc , unsigned char * kstr , int klen , pem_password_cb * cd , void * u ) ;\n # ifndef OPENSSL_NO_STDIO int PEM_read ( FILE * fp , char * * name , char * * header , unsigned char * * data , long * len ) ;\n int PEM_write ( FILE * fp , const char * name , const char * hdr , const unsigned char * data , long len ) ;\n void * PEM_ASN1_read ( d2i_of_void * d2i , const char * name , FILE * fp , void * * x , pem_password_cb * cb , void * u ) ;\n int PEM_ASN1_write ( i2d_of_void * i2d , const char * name , FILE * fp , void * x , const EVP_CIPHER * enc , unsigned char * kstr , int klen , pem_password_cb * callback , void * u ) ;\n STACK_OF ( X509_INFO ) * PEM_X509_INFO_read ( FILE * fp , STACK_OF ( X509_INFO ) * sk , pem_password_cb * cb , void * u ) ;\n # endif int PEM_SignInit ( EVP_MD_CTX * ctx , EVP_MD * type ) ;\n int PEM_SignUpdate ( EVP_MD_CTX * ctx , unsigned char * d , unsigned int cnt ) ;\n int PEM_SignFinal ( EVP_MD_CTX * ctx , unsigned char * sigret , unsigned int * siglen , EVP_PKEY * pkey ) ;\n int PEM_def_callback ( char * buf , int num , int rwflag , void * userdata ) ;\n void PEM_proc_type ( char * buf , int type ) ;\n void PEM_dek_info ( char * buf , const char * type , int len , char * str ) ;\n # include < openssl / symhacks . h > DECLARE_PEM_rw ( X509 , X509 ) DECLARE_PEM_rw ( X509_AUX , X509 ) DECLARE_PEM_rw ( X509_REQ , X509_REQ ) DECLARE_PEM_write ( X509_REQ_NEW , X509_REQ ) DECLARE_PEM_rw ( X509_CRL , X509_CRL )", "idx": 1124}
{"hash": -4271192073087306668, "project": "debian", "size": 4, "label": 0, "functionSource": "static inline void decode_residual_chroma ( AVSContext * h ) {\n if ( h -> cbp & ( 1 << 4 ) ) decode_residual_block ( h , & h -> gb , chroma_dec , 0 , cavs_chroma_qp [ h -> qp ] , h -> cu , h -> c_stride ) ;\n if ( h -> cbp & ( 1 << 5 ) ) decode_residual_block ( h , & h -> gb , chroma_dec , 0 , cavs_chroma_qp [ h -> qp ] , h -> cv , h -> c_stride ) ;\n }", "idx": 1125}
{"hash": 4537091194729139981, "project": "chrome", "size": 14, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( FullscreenControllerInteractiveTest , DISABLED_PrivilegedMouseLockAndFullscreen ) {\n ASSERT_TRUE ( test_server ( ) -> Start ( ) ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , test_server ( ) -> GetURL ( kFullscreenMouseLockHTML ) ) ;\n ASSERT_FALSE ( IsFullscreenBubbleDisplayed ( ) ) ;\n SetPrivilegedFullscreen ( true ) ;\n FullscreenNotificationObserver fullscreen_observer ;\n ASSERT_TRUE ( ui_test_utils : : SendKeyPressAndWait ( browser ( ) , ui : : VKEY_B , false , true , false , false , chrome : : NOTIFICATION_MOUSE_LOCK_CHANGED , content : : NotificationService : : AllSources ( ) ) ) ;\n fullscreen_observer . Wait ( ) ;\n ASSERT_FALSE ( IsFullscreenBubbleDisplayed ( ) ) ;\n ASSERT_FALSE ( IsFullscreenPermissionRequested ( ) ) ;\n ASSERT_FALSE ( IsMouseLockPermissionRequested ( ) ) ;\n ASSERT_TRUE ( IsMouseLocked ( ) ) ;\n ASSERT_TRUE ( IsWindowFullscreenForTabOrPending ( ) ) ;\n }", "idx": 1126}
{"hash": -6126432314261451839, "project": "debian", "size": 63, "label": 0, "functionSource": "int gx_device_open_output_file ( const gx_device * dev , char * fname , bool binary , bool positionable , FILE * * pfile ) {\n gs_parsed_file_name_t parsed ;\n const char * fmt ;\n char * pfname = ( char * ) gs_alloc_bytes ( dev -> memory , gp_file_name_sizeof , \"gx_device_open_output_file(pfname)\" ) ;\n int code ;\n if ( pfname == NULL ) {\n code = gs_note_error ( gs_error_VMerror ) ;\n goto done ;\n }\n if ( strlen ( fname ) == 0 ) {\n code = gs_note_error ( gs_error_undefinedfilename ) ;\n emprintf1 ( dev -> memory , \"Device '%s' requires an output file but no file was specified.\\n\" , dev -> dname ) ;\n goto done ;\n }\n code = gx_parse_output_file_name ( & parsed , & fmt , fname , strlen ( fname ) , dev -> memory ) ;\n if ( code < 0 ) {\n goto done ;\n }\n if ( parsed . iodev && ! strcmp ( parsed . iodev -> dname , \"%stdout%\" ) ) {\n if ( parsed . fname ) {\n code = gs_note_error ( gs_error_undefinedfilename ) ;\n goto done ;\n }\n * pfile = dev -> memory -> gs_lib_ctx -> fstdout ;\n code = gp_setmode_binary ( * pfile , true ) ;\n goto done ;\n }\n else if ( parsed . iodev && ! strcmp ( parsed . iodev -> dname , \"%pipe%\" ) ) {\n positionable = false ;\n }\n if ( fmt ) {\n long count1 = dev -> PageCount + 1 ;\n while ( * fmt != 'l' && * fmt != '%' ) -- fmt ;\n if ( * fmt == 'l' ) gs_sprintf ( pfname , parsed . fname , count1 ) ;\n else gs_sprintf ( pfname , parsed . fname , ( int ) count1 ) ;\n }\n else if ( parsed . len && strchr ( parsed . fname , '%' ) ) gs_sprintf ( pfname , parsed . fname ) ;\n else pfname [ 0 ] = 0 ;\n if ( pfname [ 0 ] ) {\n parsed . fname = pfname ;\n parsed . len = strlen ( parsed . fname ) ;\n }\n if ( positionable || ( parsed . iodev && parsed . iodev != iodev_default ( dev -> memory ) ) ) {\n char fmode [ 4 ] ;\n if ( ! parsed . fname ) {\n code = gs_note_error ( gs_error_undefinedfilename ) ;\n goto done ;\n }\n strcpy ( fmode , gp_fmode_wb ) ;\n if ( positionable ) strcat ( fmode , \"+\" ) ;\n code = parsed . iodev -> procs . gp_fopen ( parsed . iodev , parsed . fname , fmode , pfile , NULL , 0 ) ;\n if ( code ) emprintf1 ( dev -> memory , \"**** Could not open the file %s .\\n\" , parsed . fname ) ;\n }\n else {\n * pfile = gp_open_printer ( dev -> memory , ( pfname [ 0 ] ? pfname : fname ) , binary ) ;\n if ( ! ( * pfile ) ) {\n emprintf1 ( dev -> memory , \"**** Could not open the file '%s'.\\n\" , ( pfname [ 0 ] ? pfname : fname ) ) ;\n code = gs_note_error ( gs_error_invalidfileaccess ) ;\n }\n }\n done : if ( pfname != NULL ) gs_free_object ( dev -> memory , pfname , \"gx_device_open_output_file(pfname)\" ) ;\n return ( code ) ;\n }", "idx": 1127}
{"hash": 3576240888172463140, "project": "debian", "size": 8, "label": 0, "functionSource": "gpg_error_t keydb_search_kid ( KEYDB_HANDLE hd , u32 * kid ) {\n KEYDB_SEARCH_DESC desc ;\n memset ( & desc , 0 , sizeof desc ) ;\n desc . mode = KEYDB_SEARCH_MODE_LONG_KID ;\n desc . u . kid [ 0 ] = kid [ 0 ] ;\n desc . u . kid [ 1 ] = kid [ 1 ] ;\n return keydb_search ( hd , & desc , 1 , NULL ) ;\n }", "idx": 1128}
{"hash": 6393050609822897742, "project": "debian", "size": 45, "label": 0, "functionSource": "static void xhci_reset ( DeviceState * dev ) {\n XHCIState * xhci = XHCI ( dev ) ;\n int i ;\n trace_usb_xhci_reset ( ) ;\n if ( ! ( xhci -> usbsts & USBSTS_HCH ) ) {\n DPRINTF ( \"xhci: reset while running!\\n\" ) ;\n }\n xhci -> usbcmd = 0 ;\n xhci -> usbsts = USBSTS_HCH ;\n xhci -> dnctrl = 0 ;\n xhci -> crcr_low = 0 ;\n xhci -> crcr_high = 0 ;\n xhci -> dcbaap_low = 0 ;\n xhci -> dcbaap_high = 0 ;\n xhci -> config = 0 ;\n for ( i = 0 ;\n i < xhci -> numslots ;\n i ++ ) {\n xhci_disable_slot ( xhci , i + 1 ) ;\n }\n for ( i = 0 ;\n i < xhci -> numports ;\n i ++ ) {\n xhci_port_update ( xhci -> ports + i , 0 ) ;\n }\n for ( i = 0 ;\n i < xhci -> numintrs ;\n i ++ ) {\n xhci -> intr [ i ] . iman = 0 ;\n xhci -> intr [ i ] . imod = 0 ;\n xhci -> intr [ i ] . erstsz = 0 ;\n xhci -> intr [ i ] . erstba_low = 0 ;\n xhci -> intr [ i ] . erstba_high = 0 ;\n xhci -> intr [ i ] . erdp_low = 0 ;\n xhci -> intr [ i ] . erdp_high = 0 ;\n xhci -> intr [ i ] . msix_used = 0 ;\n xhci -> intr [ i ] . er_ep_idx = 0 ;\n xhci -> intr [ i ] . er_pcs = 1 ;\n xhci -> intr [ i ] . er_full = 0 ;\n xhci -> intr [ i ] . ev_buffer_put = 0 ;\n xhci -> intr [ i ] . ev_buffer_get = 0 ;\n }\n xhci -> mfindex_start = qemu_clock_get_ns ( QEMU_CLOCK_VIRTUAL ) ;\n xhci_mfwrap_update ( xhci ) ;\n }", "idx": 1129}
{"hash": 1859256631654516868, "project": "chrome", "size": 25, "label": 0, "functionSource": "static void flush_change ( H264Context * h ) {\n int i , j ;\n h -> outputed_poc = h -> next_outputed_poc = INT_MIN ;\n h -> prev_interlaced_frame = 1 ;\n idr ( h ) ;\n h -> prev_frame_num = - 1 ;\n if ( h -> cur_pic_ptr ) {\n h -> cur_pic_ptr -> reference = 0 ;\n for ( j = i = 0 ;\n h -> delayed_pic [ i ] ;\n i ++ ) if ( h -> delayed_pic [ i ] != h -> cur_pic_ptr ) h -> delayed_pic [ j ++ ] = h -> delayed_pic [ i ] ;\n h -> delayed_pic [ j ] = NULL ;\n }\n h -> first_field = 0 ;\n memset ( h -> ref_list [ 0 ] , 0 , sizeof ( h -> ref_list [ 0 ] ) ) ;\n memset ( h -> ref_list [ 1 ] , 0 , sizeof ( h -> ref_list [ 1 ] ) ) ;\n memset ( h -> default_ref_list [ 0 ] , 0 , sizeof ( h -> default_ref_list [ 0 ] ) ) ;\n memset ( h -> default_ref_list [ 1 ] , 0 , sizeof ( h -> default_ref_list [ 1 ] ) ) ;\n ff_h264_reset_sei ( h ) ;\n h -> recovery_frame = - 1 ;\n h -> frame_recovered = 0 ;\n h -> list_count = 0 ;\n h -> current_slice = 0 ;\n h -> mmco_reset = 1 ;\n }", "idx": 1130}
{"hash": -5280794106681745199, "project": "debian", "size": 22, "label": 0, "functionSource": "static gboolean gst_asf_demux_pull_data ( GstASFDemux * demux , guint64 offset , guint size , GstBuffer * * p_buf , GstFlowReturn * p_flow ) {\n gsize buffer_size ;\n GstFlowReturn flow ;\n GST_LOG_OBJECT ( demux , \"pulling buffer at %\" G_GUINT64_FORMAT \"+%u\" , offset , size ) ;\n flow = gst_pad_pull_range ( demux -> sinkpad , offset , size , p_buf ) ;\n if ( G_LIKELY ( p_flow ) ) * p_flow = flow ;\n if ( G_UNLIKELY ( flow != GST_FLOW_OK ) ) {\n GST_DEBUG_OBJECT ( demux , \"flow %s pulling buffer at %\" G_GUINT64_FORMAT \"+%u\" , gst_flow_get_name ( flow ) , offset , size ) ;\n * p_buf = NULL ;\n return FALSE ;\n }\n g_assert ( * p_buf != NULL ) ;\n buffer_size = gst_buffer_get_size ( * p_buf ) ;\n if ( G_UNLIKELY ( buffer_size < size ) ) {\n GST_DEBUG_OBJECT ( demux , \"short read pulling buffer at %\" G_GUINT64_FORMAT \"+%u (got only %\" G_GSIZE_FORMAT \" bytes)\" , offset , size , buffer_size ) ;\n gst_buffer_unref ( * p_buf ) ;\n if ( G_LIKELY ( p_flow ) ) * p_flow = GST_FLOW_EOS ;\n * p_buf = NULL ;\n return FALSE ;\n }\n return TRUE ;\n }", "idx": 1131}
{"hash": 4489017523191997023, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h225_T_ipAddress ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_T_ipAddress , T_ipAddress_sequence ) ;\n return offset ;\n }", "idx": 1132}
{"hash": -5082285935423529157, "project": "debian", "size": 20, "label": 0, "functionSource": "static int dissect_rsl_ie_ch_desc ( tvbuff_t * tvb , packet_info * pinfo _U_ , proto_tree * tree , int offset , gboolean is_mandatory ) {\n proto_item * ti ;\n proto_tree * ie_tree ;\n guint length ;\n guint8 ie_id ;\n if ( is_mandatory == FALSE ) {\n ie_id = tvb_get_guint8 ( tvb , offset ) ;\n if ( ie_id != RSL_IE_CH_DESC ) return offset ;\n }\n ie_tree = proto_tree_add_subtree ( tree , tvb , offset , 0 , ett_ie_ch_desc , & ti , \"Channel description IE\" ) ;\n proto_tree_add_item ( ie_tree , hf_rsl_ie_id , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n offset ++ ;\n length = tvb_get_guint8 ( tvb , offset ) ;\n proto_item_set_len ( ti , length + 2 ) ;\n proto_tree_add_item ( ie_tree , hf_rsl_ie_length , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n offset ++ ;\n proto_tree_add_item ( ie_tree , hf_rsl_group_channel_description , tvb , offset , length , ENC_NA ) ;\n offset = offset + length ;\n return offset ;\n }", "idx": 1133}
{"hash": -7434385833116714871, "project": "chrome", "size": 3, "label": 0, "functionSource": "static void U_CALLCONV uprv_writeSwapUInt32 ( uint32_t * p , uint32_t x ) {\n * p = ( uint32_t ) ( ( x << 24 ) | ( ( x << 8 ) & 0xff0000 ) | ( ( x >> 8 ) & 0xff00 ) | ( x >> 24 ) ) ;\n }", "idx": 1134}
{"hash": 8445816931248660591, "project": "debian", "size": 9, "label": 0, "functionSource": "static void * spl_ptr_llist_last ( spl_ptr_llist * llist ) {\n spl_ptr_llist_element * tail = llist -> tail ;\n if ( tail == NULL ) {\n return NULL ;\n }\n else {\n return tail -> data ;\n }\n }", "idx": 1135}
{"hash": -7468702064548611268, "project": "debian", "size": 43, "label": 0, "functionSource": "void ff_vdpau_mpeg4_decode_picture ( MpegEncContext * s , const uint8_t * buf , int buf_size ) {\n struct vdpau_render_state * render , * last , * next ;\n int i ;\n if ( ! s -> current_picture_ptr ) return ;\n render = ( struct vdpau_render_state * ) s -> current_picture_ptr -> f . data [ 0 ] ;\n assert ( render ) ;\n render -> info . mpeg4 . trd [ 0 ] = s -> pp_time ;\n render -> info . mpeg4 . trb [ 0 ] = s -> pb_time ;\n render -> info . mpeg4 . trd [ 1 ] = s -> pp_field_time >> 1 ;\n render -> info . mpeg4 . trb [ 1 ] = s -> pb_field_time >> 1 ;\n render -> info . mpeg4 . vop_time_increment_resolution = s -> avctx -> time_base . den ;\n render -> info . mpeg4 . vop_coding_type = 0 ;\n render -> info . mpeg4 . vop_fcode_forward = s -> f_code ;\n render -> info . mpeg4 . vop_fcode_backward = s -> b_code ;\n render -> info . mpeg4 . resync_marker_disable = ! s -> resync_marker ;\n render -> info . mpeg4 . interlaced = ! s -> progressive_sequence ;\n render -> info . mpeg4 . quant_type = s -> mpeg_quant ;\n render -> info . mpeg4 . quarter_sample = s -> quarter_sample ;\n render -> info . mpeg4 . short_video_header = s -> avctx -> codec -> id == AV_CODEC_ID_H263 ;\n render -> info . mpeg4 . rounding_control = s -> no_rounding ;\n render -> info . mpeg4 . alternate_vertical_scan_flag = s -> alternate_scan ;\n render -> info . mpeg4 . top_field_first = s -> top_field_first ;\n for ( i = 0 ;\n i < 64 ;\n ++ i ) {\n render -> info . mpeg4 . intra_quantizer_matrix [ i ] = s -> intra_matrix [ i ] ;\n render -> info . mpeg4 . non_intra_quantizer_matrix [ i ] = s -> inter_matrix [ i ] ;\n }\n render -> info . mpeg4 . forward_reference = VDP_INVALID_HANDLE ;\n render -> info . mpeg4 . backward_reference = VDP_INVALID_HANDLE ;\n switch ( s -> pict_type ) {\n case AV_PICTURE_TYPE_B : next = ( struct vdpau_render_state * ) s -> next_picture . f . data [ 0 ] ;\n assert ( next ) ;\n render -> info . mpeg4 . backward_reference = next -> surface ;\n render -> info . mpeg4 . vop_coding_type = 2 ;\n case AV_PICTURE_TYPE_P : last = ( struct vdpau_render_state * ) s -> last_picture . f . data [ 0 ] ;\n assert ( last ) ;\n render -> info . mpeg4 . forward_reference = last -> surface ;\n }\n ff_vdpau_add_data_chunk ( s -> current_picture_ptr -> f . data [ 0 ] , buf , buf_size ) ;\n ff_mpeg_draw_horiz_band ( s , 0 , s -> avctx -> height ) ;\n render -> bitstream_buffers_used = 0 ;\n }", "idx": 1136}
{"hash": -7855974557509681261, "project": "debian", "size": 12, "label": 0, "functionSource": "Oid get_typcollation ( Oid typid ) {\n HeapTuple tp ;\n tp = SearchSysCache1 ( TYPEOID , ObjectIdGetDatum ( typid ) ) ;\n if ( HeapTupleIsValid ( tp ) ) {\n Form_pg_type typtup = ( Form_pg_type ) GETSTRUCT ( tp ) ;\n Oid result ;\n result = typtup -> typcollation ;\n ReleaseSysCache ( tp ) ;\n return result ;\n }\n else return InvalidOid ;\n }", "idx": 1137}
{"hash": -7683902591435073306, "project": "debian", "size": 21, "label": 0, "functionSource": "static apr_status_t modsecurity_process_phase_request_body ( modsec_rec * msr ) {\n apr_time_t time_before ;\n apr_status_t rc = 0 ;\n if ( ( msr -> allow_scope == ACTION_ALLOW_REQUEST ) || ( msr -> allow_scope == ACTION_ALLOW ) ) {\n if ( msr -> txcfg -> debuglog_level >= 4 ) {\n msr_log ( msr , 4 , \"Skipping phase REQUEST_BODY (allow used).\" ) ;\n }\n return 0 ;\n }\n else {\n if ( msr -> txcfg -> debuglog_level >= 4 ) {\n msr_log ( msr , 4 , \"Starting phase REQUEST_BODY.\" ) ;\n }\n }\n time_before = apr_time_now ( ) ;\n if ( msr -> txcfg -> ruleset != NULL ) {\n rc = msre_ruleset_process_phase ( msr -> txcfg -> ruleset , msr ) ;\n }\n msr -> time_phase2 = apr_time_now ( ) - time_before ;\n return rc ;\n }", "idx": 1138}
{"hash": 8388187431631506723, "project": "debian", "size": 5, "label": 0, "functionSource": "static bool fpop_ip_dp_needed ( void * opaque ) {\n X86CPU * cpu = opaque ;\n CPUX86State * env = & cpu -> env ;\n return env -> fpop != 0 || env -> fpip != 0 || env -> fpdp != 0 ;\n }", "idx": 1139}
{"hash": 2546373479020365143, "project": "debian", "size": 57, "label": 0, "functionSource": "void mime_hdr_field_attach ( MIMEHdrImpl * mh , MIMEField * field , int check_for_dups , MIMEField * prev_dup ) {\n MIME_HDR_SANITY_CHECK ( mh ) ;\n if ( ! field -> is_detached ( ) ) {\n return ;\n }\n ink_assert ( field -> m_ptr_name != nullptr ) ;\n if ( check_for_dups || ( prev_dup && ( ! prev_dup -> is_dup_head ( ) ) ) ) {\n int length ;\n const char * name = mime_field_name_get ( field , & length ) ;\n prev_dup = mime_hdr_field_find ( mh , name , length ) ;\n ink_assert ( ( prev_dup == nullptr ) || ( prev_dup -> is_dup_head ( ) ) ) ;\n }\n field -> m_readiness = MIME_FIELD_SLOT_READINESS_LIVE ;\n if ( prev_dup ) {\n MIMEField * next_dup ;\n int field_slotnum , prev_slotnum , next_slotnum ;\n field_slotnum = mime_hdr_field_slotnum ( mh , field ) ;\n prev_slotnum = mime_hdr_field_slotnum ( mh , prev_dup ) ;\n next_dup = prev_dup -> m_next_dup ;\n next_slotnum = ( next_dup ? mime_hdr_field_slotnum ( mh , next_dup ) : - 1 ) ;\n ink_assert ( field_slotnum != prev_slotnum ) ;\n while ( prev_slotnum < field_slotnum ) {\n if ( next_dup == nullptr ) {\n break ;\n }\n if ( next_slotnum > field_slotnum ) {\n break ;\n }\n prev_dup = next_dup ;\n prev_slotnum = next_slotnum ;\n next_dup = prev_dup -> m_next_dup ;\n }\n if ( prev_slotnum > field_slotnum ) {\n field -> m_flags = ( field -> m_flags | MIME_FIELD_SLOT_FLAGS_DUP_HEAD ) ;\n field -> m_next_dup = prev_dup ;\n prev_dup -> m_flags = ( prev_dup -> m_flags & ~ MIME_FIELD_SLOT_FLAGS_DUP_HEAD ) ;\n mime_hdr_set_accelerators_and_presence_bits ( mh , field ) ;\n }\n else {\n ink_assert ( prev_slotnum < field_slotnum ) ;\n ink_assert ( ( next_dup == nullptr ) || ( next_slotnum > field_slotnum ) ) ;\n field -> m_flags = ( field -> m_flags & ~ MIME_FIELD_SLOT_FLAGS_DUP_HEAD ) ;\n ink_assert ( ( next_dup == nullptr ) || next_dup -> is_live ( ) ) ;\n prev_dup -> m_next_dup = field ;\n field -> m_next_dup = next_dup ;\n }\n }\n else {\n field -> m_flags = ( field -> m_flags | MIME_FIELD_SLOT_FLAGS_DUP_HEAD ) ;\n mime_hdr_set_accelerators_and_presence_bits ( mh , field ) ;\n }\n ink_assert ( field -> is_live ( ) ) ;\n if ( field -> m_ptr_value && field -> is_cooked ( ) ) {\n mh -> recompute_cooked_stuff ( field ) ;\n }\n MIME_HDR_SANITY_CHECK ( mh ) ;\n }", "idx": 1140}
{"hash": 4839943401171415484, "project": "chrome", "size": 22, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_P ( BrowserCloseManagerBrowserTest , TestAddWindowWithBeforeUnloadDuringShutdown ) {\n ASSERT_NO_FATAL_FAILURE ( ui_test_utils : : NavigateToURL ( browsers_ [ 0 ] , embedded_test_server ( ) -> GetURL ( \"/beforeunload.html\" ) ) ) ;\n PrepareForDialog ( browsers_ [ 0 ] ) ;\n RepeatedNotificationObserver cancel_observer ( chrome : : NOTIFICATION_BROWSER_CLOSE_CANCELLED , 2 ) ;\n chrome : : CloseAllBrowsersAndQuit ( ) ;\n browsers_ . push_back ( CreateBrowser ( browser ( ) -> profile ( ) ) ) ;\n ASSERT_NO_FATAL_FAILURE ( ui_test_utils : : NavigateToURL ( browsers_ [ 1 ] , embedded_test_server ( ) -> GetURL ( \"/beforeunload.html\" ) ) ) ;\n PrepareForDialog ( browsers_ [ 1 ] ) ;\n ASSERT_NO_FATAL_FAILURE ( AcceptClose ( ) ) ;\n ASSERT_NO_FATAL_FAILURE ( CancelClose ( ) ) ;\n cancel_observer . Wait ( ) ;\n EXPECT_FALSE ( browser_shutdown : : IsTryingToQuit ( ) ) ;\n EXPECT_EQ ( 1 , browsers_ [ 0 ] -> tab_strip_model ( ) -> count ( ) ) ;\n EXPECT_EQ ( 1 , browsers_ [ 1 ] -> tab_strip_model ( ) -> count ( ) ) ;\n RepeatedNotificationObserver close_observer ( chrome : : NOTIFICATION_BROWSER_CLOSED , 2 ) ;\n chrome : : CloseAllBrowsersAndQuit ( ) ;\n ASSERT_NO_FATAL_FAILURE ( AcceptClose ( ) ) ;\n ASSERT_NO_FATAL_FAILURE ( AcceptClose ( ) ) ;\n close_observer . Wait ( ) ;\n EXPECT_TRUE ( browser_shutdown : : IsTryingToQuit ( ) ) ;\n EXPECT_TRUE ( BrowserList : : GetInstance ( ) -> empty ( ) ) ;\n }", "idx": 1141}
{"hash": 4704178797381506498, "project": "debian", "size": 89, "label": 0, "functionSource": "kadm5_ret_t kadm5_modify_principal ( void * server_handle , kadm5_principal_ent_t entry , long mask ) {\n int ret , ret2 , i ;\n kadm5_policy_ent_rec pol ;\n krb5_boolean have_pol = FALSE ;\n krb5_db_entry * kdb ;\n krb5_tl_data * tl_data_orig ;\n osa_princ_ent_rec adb ;\n kadm5_server_handle_t handle = server_handle ;\n CHECK_HANDLE ( server_handle ) ;\n krb5_clear_error_message ( handle -> context ) ;\n if ( entry == NULL ) return EINVAL ;\n if ( ( mask & KADM5_PRINCIPAL ) || ( mask & KADM5_LAST_PWD_CHANGE ) || ( mask & KADM5_MOD_TIME ) || ( mask & KADM5_MOD_NAME ) || ( mask & KADM5_MKVNO ) || ( mask & KADM5_AUX_ATTRIBUTES ) || ( mask & KADM5_KEY_DATA ) || ( mask & KADM5_LAST_SUCCESS ) || ( mask & KADM5_LAST_FAILED ) ) return KADM5_BAD_MASK ;\n if ( ( mask & ~ ALL_PRINC_MASK ) ) return KADM5_BAD_MASK ;\n if ( ( mask & KADM5_POLICY ) && entry -> policy == NULL ) return KADM5_BAD_MASK ;\n if ( ( mask & KADM5_POLICY ) && ( mask & KADM5_POLICY_CLR ) ) return KADM5_BAD_MASK ;\n if ( mask & KADM5_TL_DATA ) {\n tl_data_orig = entry -> tl_data ;\n while ( tl_data_orig ) {\n if ( tl_data_orig -> tl_data_type < 256 ) return KADM5_BAD_TL_TYPE ;\n tl_data_orig = tl_data_orig -> tl_data_next ;\n }\n }\n ret = kdb_get_entry ( handle , entry -> principal , & kdb , & adb ) ;\n if ( ret ) return ( ret ) ;\n if ( ( mask & KADM5_POLICY ) ) {\n ret = get_policy ( handle , entry -> policy , & pol , & have_pol ) ;\n if ( ret ) goto done ;\n adb . aux_attributes |= KADM5_POLICY ;\n if ( adb . policy ) free ( adb . policy ) ;\n adb . policy = strdup ( entry -> policy ) ;\n }\n if ( have_pol ) {\n if ( pol . pw_max_life ) {\n ret = krb5_dbe_lookup_last_pwd_change ( handle -> context , kdb , & ( kdb -> pw_expiration ) ) ;\n if ( ret ) goto done ;\n kdb -> pw_expiration += pol . pw_max_life ;\n }\n else {\n kdb -> pw_expiration = 0 ;\n }\n }\n if ( ( mask & KADM5_POLICY_CLR ) && ( adb . aux_attributes & KADM5_POLICY ) ) {\n free ( adb . policy ) ;\n adb . policy = NULL ;\n adb . aux_attributes &= ~ KADM5_POLICY ;\n kdb -> pw_expiration = 0 ;\n }\n if ( ( mask & KADM5_ATTRIBUTES ) ) kdb -> attributes = entry -> attributes ;\n if ( ( mask & KADM5_MAX_LIFE ) ) kdb -> max_life = entry -> max_life ;\n if ( ( mask & KADM5_PRINC_EXPIRE_TIME ) ) kdb -> expiration = entry -> princ_expire_time ;\n if ( mask & KADM5_PW_EXPIRATION ) kdb -> pw_expiration = entry -> pw_expiration ;\n if ( mask & KADM5_MAX_RLIFE ) kdb -> max_renewable_life = entry -> max_renewable_life ;\n if ( ( mask & KADM5_KVNO ) ) {\n for ( i = 0 ;\n i < kdb -> n_key_data ;\n i ++ ) kdb -> key_data [ i ] . key_data_kvno = entry -> kvno ;\n }\n if ( mask & KADM5_TL_DATA ) {\n krb5_tl_data * tl ;\n for ( tl = entry -> tl_data ;\n tl ;\n tl = tl -> tl_data_next ) {\n ret = krb5_dbe_update_tl_data ( handle -> context , kdb , tl ) ;\n if ( ret ) {\n goto done ;\n }\n }\n }\n if ( mask & KADM5_FAIL_AUTH_COUNT ) {\n if ( entry -> fail_auth_count != 0 ) {\n ret = KADM5_BAD_SERVER_PARAMS ;\n goto done ;\n }\n kdb -> fail_auth_count = 0 ;\n }\n kdb -> mask = mask ;\n ret = k5_kadm5_hook_modify ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_PRECOMMIT , entry , mask ) ;\n if ( ret ) goto done ;\n ret = kdb_put_entry ( handle , kdb , & adb ) ;\n if ( ret ) goto done ;\n ( void ) k5_kadm5_hook_modify ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_POSTCOMMIT , entry , mask ) ;\n ret = KADM5_OK ;\n done : if ( have_pol ) {\n ret2 = kadm5_free_policy_ent ( handle -> lhandle , & pol ) ;\n ret = ret ? ret : ret2 ;\n }\n kdb_free_entry ( handle , kdb , & adb ) ;\n return ret ;\n }", "idx": 1142}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_ConferenceCommand ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_ConferenceCommand , ConferenceCommand_choice , NULL ) ;\n return offset ;\n }", "idx": 1143}
{"hash": -1102844685921778700, "project": "debian", "size": 7, "label": 0, "functionSource": "static struct archive_wstring * archive_wstring_append ( struct archive_wstring * as , const wchar_t * p , size_t s ) {\n if ( archive_wstring_ensure ( as , as -> length + s + 1 ) == NULL ) return ( NULL ) ;\n wmemmove ( as -> s + as -> length , p , s ) ;\n as -> length += s ;\n as -> s [ as -> length ] = 0 ;\n return ( as ) ;\n }", "idx": 1144}
{"hash": -7253276028511611170, "project": "debian", "size": 63, "label": 0, "functionSource": "static int count_hq_slice ( SliceArgs * slice , int quant_idx ) {\n int x , y ;\n uint8_t quants [ MAX_DWT_LEVELS ] [ 4 ] ;\n int bits = 0 , p , level , orientation ;\n VC2EncContext * s = slice -> ctx ;\n if ( slice -> cache [ quant_idx ] ) return slice -> cache [ quant_idx ] ;\n bits += 8 * s -> prefix_bytes ;\n bits += 8 ;\n for ( level = 0 ;\n level < s -> wavelet_depth ;\n level ++ ) for ( orientation = ! ! level ;\n orientation < 4 ;\n orientation ++ ) quants [ level ] [ orientation ] = FFMAX ( quant_idx - s -> quant [ level ] [ orientation ] , 0 ) ;\n for ( p = 0 ;\n p < 3 ;\n p ++ ) {\n int bytes_start , bytes_len , pad_s , pad_c ;\n bytes_start = bits >> 3 ;\n bits += 8 ;\n for ( level = 0 ;\n level < s -> wavelet_depth ;\n level ++ ) {\n for ( orientation = ! ! level ;\n orientation < 4 ;\n orientation ++ ) {\n SubBand * b = & s -> plane [ p ] . band [ level ] [ orientation ] ;\n const int q_idx = quants [ level ] [ orientation ] ;\n const uint8_t * len_lut = & s -> coef_lut_len [ q_idx * COEF_LUT_TAB ] ;\n const int qfactor = ff_dirac_qscale_tab [ q_idx ] ;\n const int left = b -> width * slice -> x / s -> num_x ;\n const int right = b -> width * ( slice -> x + 1 ) / s -> num_x ;\n const int top = b -> height * slice -> y / s -> num_y ;\n const int bottom = b -> height * ( slice -> y + 1 ) / s -> num_y ;\n dwtcoef * buf = b -> buf + top * b -> stride ;\n for ( y = top ;\n y < bottom ;\n y ++ ) {\n for ( x = left ;\n x < right ;\n x ++ ) {\n uint32_t c_abs = FFABS ( buf [ x ] ) ;\n if ( c_abs < COEF_LUT_TAB ) {\n bits += len_lut [ c_abs ] ;\n }\n else {\n c_abs = QUANT ( c_abs , qfactor ) ;\n bits += count_vc2_ue_uint ( c_abs ) ;\n bits += ! ! c_abs ;\n }\n }\n buf += b -> stride ;\n }\n }\n }\n bits += FFALIGN ( bits , 8 ) - bits ;\n bytes_len = ( bits >> 3 ) - bytes_start - 1 ;\n pad_s = FFALIGN ( bytes_len , s -> size_scaler ) / s -> size_scaler ;\n pad_c = ( pad_s * s -> size_scaler ) - bytes_len ;\n bits += pad_c * 8 ;\n }\n slice -> cache [ quant_idx ] = bits ;\n return bits ;\n }", "idx": 1145}
{"hash": 468458465404335175, "project": "debian", "size": 41, "label": 0, "functionSource": "static void prepare_vacuum_command ( PQExpBuffer sql , PGconn * conn , vacuumingOptions * vacopts , const char * table ) {\n resetPQExpBuffer ( sql ) ;\n if ( vacopts -> analyze_only ) {\n appendPQExpBufferStr ( sql , \"ANALYZE\" ) ;\n if ( vacopts -> verbose ) appendPQExpBufferStr ( sql , \" VERBOSE\" ) ;\n }\n else {\n appendPQExpBufferStr ( sql , \"VACUUM\" ) ;\n if ( PQserverVersion ( conn ) >= 90000 ) {\n const char * paren = \" (\" ;\n const char * comma = \", \" ;\n const char * sep = paren ;\n if ( vacopts -> full ) {\n appendPQExpBuffer ( sql , \"%sFULL\" , sep ) ;\n sep = comma ;\n }\n if ( vacopts -> freeze ) {\n appendPQExpBuffer ( sql , \"%sFREEZE\" , sep ) ;\n sep = comma ;\n }\n if ( vacopts -> verbose ) {\n appendPQExpBuffer ( sql , \"%sVERBOSE\" , sep ) ;\n sep = comma ;\n }\n if ( vacopts -> and_analyze ) {\n appendPQExpBuffer ( sql , \"%sANALYZE\" , sep ) ;\n sep = comma ;\n }\n if ( sep != paren ) appendPQExpBufferChar ( sql , ')' ) ;\n }\n else {\n if ( vacopts -> full ) appendPQExpBufferStr ( sql , \" FULL\" ) ;\n if ( vacopts -> freeze ) appendPQExpBufferStr ( sql , \" FREEZE\" ) ;\n if ( vacopts -> verbose ) appendPQExpBufferStr ( sql , \" VERBOSE\" ) ;\n if ( vacopts -> and_analyze ) appendPQExpBufferStr ( sql , \" ANALYZE\" ) ;\n }\n }\n if ( table ) appendPQExpBuffer ( sql , \" %s\" , table ) ;\n appendPQExpBufferChar ( sql , ';\n' ) ;\n }", "idx": 1146}
{"hash": -305162769887579921, "project": "debian", "size": 16, "label": 0, "functionSource": "static void write_mb_info ( MpegEncContext * s ) {\n uint8_t * ptr = s -> mb_info_ptr + s -> mb_info_size - 12 ;\n int offset = put_bits_count ( & s -> pb ) ;\n int mba = s -> mb_x + s -> mb_width * ( s -> mb_y % s -> gob_index ) ;\n int gobn = s -> mb_y / s -> gob_index ;\n int pred_x , pred_y ;\n if ( CONFIG_H263_ENCODER ) ff_h263_pred_motion ( s , 0 , 0 , & pred_x , & pred_y ) ;\n bytestream_put_le32 ( & ptr , offset ) ;\n bytestream_put_byte ( & ptr , s -> qscale ) ;\n bytestream_put_byte ( & ptr , gobn ) ;\n bytestream_put_le16 ( & ptr , mba ) ;\n bytestream_put_byte ( & ptr , pred_x ) ;\n bytestream_put_byte ( & ptr , pred_y ) ;\n bytestream_put_byte ( & ptr , 0 ) ;\n bytestream_put_byte ( & ptr , 0 ) ;\n }", "idx": 1147}
{"hash": 927123821003322045, "project": "chrome", "size": 6, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( PageLoadMetricsBrowserTest , NonHtmlMainResource ) {\n ASSERT_TRUE ( embedded_test_server ( ) -> Start ( ) ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , embedded_test_server ( ) -> GetURL ( \"/circle.svg\" ) ) ;\n NavigateToUntrackedUrl ( ) ;\n EXPECT_TRUE ( NoPageLoadMetricsRecorded ( ) ) << \"Recorded metrics: \" << GetRecordedPageLoadMetricNames ( ) ;\n }", "idx": 1148}
{"hash": -8704451445127642833, "project": "chrome", "size": 30, "label": 0, "functionSource": "static int32_t u_scanf_ustring_handler ( UFILE * input , u_scanf_spec_info * info , ufmt_args * args , const UChar * fmt , int32_t * fmtConsumed , int32_t * argConverted ) {\n ( void ) fmt ;\n ( void ) fmtConsumed ;\n UChar * arg = ( UChar * ) ( args [ 0 ] . ptrValue ) ;\n UChar * alias = arg ;\n int32_t count ;\n int32_t skipped = 0 ;\n UChar c ;\n UBool isNotEOF = FALSE ;\n if ( info -> fIsString ) {\n skipped = u_scanf_skip_leading_ws ( input , info -> fPadChar ) ;\n }\n count = 0 ;\n while ( ( info -> fWidth == - 1 || count < info -> fWidth ) && ( isNotEOF = ufile_getch ( input , & c ) ) && ( ! info -> fIsString || ( c != info -> fPadChar && ! u_isWhitespace ( c ) ) ) ) {\n if ( ! info -> fSkipArg ) {\n * alias ++ = c ;\n }\n ++ count ;\n }\n if ( ! info -> fSkipArg ) {\n if ( ( info -> fWidth == - 1 || count < info -> fWidth ) && isNotEOF ) {\n u_fungetc ( c , input ) ;\n }\n if ( info -> fIsString ) {\n * alias = 0x0000 ;\n }\n }\n * argConverted = ! info -> fSkipArg ;\n return count + skipped ;\n }", "idx": 1149}
{"hash": 3576240888172463140, "project": "debian", "size": 55, "label": 0, "functionSource": "static void dump_search_desc ( KEYDB_HANDLE hd , const char * text , KEYDB_SEARCH_DESC * desc , size_t ndesc ) {\n int n ;\n const char * s ;\n for ( n = 0 ;\n n < ndesc ;\n n ++ ) {\n switch ( desc [ n ] . mode ) {\n case KEYDB_SEARCH_MODE_NONE : s = \"none\" ;\n break ;\n case KEYDB_SEARCH_MODE_EXACT : s = \"exact\" ;\n break ;\n case KEYDB_SEARCH_MODE_SUBSTR : s = \"substr\" ;\n break ;\n case KEYDB_SEARCH_MODE_MAIL : s = \"mail\" ;\n break ;\n case KEYDB_SEARCH_MODE_MAILSUB : s = \"mailsub\" ;\n break ;\n case KEYDB_SEARCH_MODE_MAILEND : s = \"mailend\" ;\n break ;\n case KEYDB_SEARCH_MODE_WORDS : s = \"words\" ;\n break ;\n case KEYDB_SEARCH_MODE_SHORT_KID : s = \"short_kid\" ;\n break ;\n case KEYDB_SEARCH_MODE_LONG_KID : s = \"long_kid\" ;\n break ;\n case KEYDB_SEARCH_MODE_FPR16 : s = \"fpr16\" ;\n break ;\n case KEYDB_SEARCH_MODE_FPR20 : s = \"fpr20\" ;\n break ;\n case KEYDB_SEARCH_MODE_FPR : s = \"fpr\" ;\n break ;\n case KEYDB_SEARCH_MODE_ISSUER : s = \"issuer\" ;\n break ;\n case KEYDB_SEARCH_MODE_ISSUER_SN : s = \"issuer_sn\" ;\n break ;\n case KEYDB_SEARCH_MODE_SN : s = \"sn\" ;\n break ;\n case KEYDB_SEARCH_MODE_SUBJECT : s = \"subject\" ;\n break ;\n case KEYDB_SEARCH_MODE_KEYGRIP : s = \"keygrip\" ;\n break ;\n case KEYDB_SEARCH_MODE_FIRST : s = \"first\" ;\n break ;\n case KEYDB_SEARCH_MODE_NEXT : s = \"next\" ;\n break ;\n default : s = \"?\" ;\n break ;\n }\n if ( ! n ) log_debug ( \"%s: mode=%s (hd=%p)\" , text , s , hd ) ;\n else log_debug ( \"%*s mode=%s\" , ( int ) strlen ( text ) , \"\" , s ) ;\n if ( desc [ n ] . mode == KEYDB_SEARCH_MODE_LONG_KID ) log_printf ( \" %08lX%08lX\" , ( unsigned long ) desc [ n ] . u . kid [ 0 ] , ( unsigned long ) desc [ n ] . u . kid [ 1 ] ) ;\n else if ( desc [ n ] . mode == KEYDB_SEARCH_MODE_SHORT_KID ) log_printf ( \" %08lX\" , ( unsigned long ) desc [ n ] . u . kid [ 1 ] ) ;\n else if ( desc [ n ] . mode == KEYDB_SEARCH_MODE_SUBSTR ) log_printf ( \" '%s'\" , desc [ n ] . u . name ) ;\n }\n }", "idx": 1150}
{"hash": -3502382902740740634, "project": "debian", "size": 16, "label": 0, "functionSource": "static const char * grouped_avp ( diam_ctx_t * c , diam_avp_t * a , tvbuff_t * tvb , diam_sub_dis_t * diam_sub_dis_inf ) {\n int offset = 0 ;\n int len = tvb_reported_length ( tvb ) ;\n proto_item * pi = proto_tree_add_item ( c -> tree , a -> hf_value , tvb , 0 , - 1 , ENC_BIG_ENDIAN ) ;\n proto_tree * pt = c -> tree ;\n c -> tree = proto_item_add_subtree ( pi , a -> ett ) ;\n diam_sub_dis_inf -> dis_gouped = TRUE ;\n while ( offset < len ) {\n offset += dissect_diameter_avp ( c , tvb , offset , diam_sub_dis_inf ) ;\n }\n diam_sub_dis_inf -> vendor_id = 0 ;\n diam_sub_dis_inf -> dis_gouped = FALSE ;\n diam_sub_dis_inf -> avp_str = NULL ;\n c -> tree = pt ;\n return NULL ;\n }", "idx": 1151}
{"hash": 1105505185808271410, "project": "debian", "size": 24, "label": 0, "functionSource": "static bool peek_ipv6 ( const char * str , size_t * skip ) {\n size_t i = 0 ;\n size_t colons = 0 ;\n if ( str [ i ++ ] != '[' ) {\n return FALSE ;\n }\n for ( ;\n ;\n ) {\n const char c = str [ i ++ ] ;\n if ( ISALNUM ( c ) || c == '.' || c == '%' ) {\n }\n else if ( c == ':' ) {\n colons ++ ;\n }\n else if ( c == ']' ) {\n * skip = i ;\n return colons >= 2 ? TRUE : FALSE ;\n }\n else {\n return FALSE ;\n }\n }\n }", "idx": 1152}
{"hash": 1760449185745615462, "project": "debian", "size": 5, "label": 0, "functionSource": "void TSSkipRemappingSet ( TSHttpTxn txnp , int flag ) {\n sdk_assert ( sdk_sanity_check_txn ( txnp ) == TS_SUCCESS ) ;\n HttpSM * sm = ( HttpSM * ) txnp ;\n sm -> t_state . api_skip_all_remapping = ( flag != 0 ) ;\n }", "idx": 1153}
{"hash": 1182028467273264883, "project": "debian", "size": 14, "label": 0, "functionSource": "void revert_properties ( ) {\n if ( ! once_property ) return ;\n for ( int i = 0 ;\n i < ( int ) P_MAX ;\n i ++ ) {\n property & pr = prop_list [ i ] ;\n if ( pr . set ) {\n * pr . var = pr . old ;\n pr . set = 0 ;\n var_set_int ( pr . env_name , ( pr . old != pr . reverse ) ) ;\n }\n }\n once_property = FALSE ;\n }", "idx": 1154}
{"hash": -6627217369018123590, "project": "chrome", "size": 3, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( ContentSettingBubbleDialogTest , InvokeDialog_cookies ) {\n RunDialog ( ) ;\n }", "idx": 1155}
{"hash": 9176142195250515812, "project": "debian", "size": 6, "label": 0, "functionSource": "void purple_chat_kick ( struct groupchat * gc , char * who , const char * message ) {\n PurpleConversation * pc = gc -> data ;\n char * str = g_strdup_printf ( \"kick %s %s\" , who , message ) ;\n purple_conversation_do_command ( pc , str , NULL , NULL ) ;\n g_free ( str ) ;\n }", "idx": 1156}
{"hash": 237530479040685467, "project": "chrome", "size": 133, "label": 0, "functionSource": "static void U_CALLCONV UConverter_toUnicode_HZ_OFFSETS_LOGIC ( UConverterToUnicodeArgs * args , UErrorCode * err ) {\n char tempBuf [ 2 ] ;\n const char * mySource = ( char * ) args -> source ;\n UChar * myTarget = args -> target ;\n const char * mySourceLimit = args -> sourceLimit ;\n UChar32 targetUniChar = 0x0000 ;\n int32_t mySourceChar = 0x0000 ;\n UConverterDataHZ * myData = ( UConverterDataHZ * ) ( args -> converter -> extraInfo ) ;\n tempBuf [ 0 ] = 0 ;\n tempBuf [ 1 ] = 0 ;\n while ( mySource < mySourceLimit ) {\n if ( myTarget < args -> targetLimit ) {\n mySourceChar = ( unsigned char ) * mySource ++ ;\n if ( args -> converter -> mode == UCNV_TILDE ) {\n args -> converter -> mode = 0 ;\n switch ( mySourceChar ) {\n case 0x0A : continue ;\n case UCNV_TILDE : if ( args -> offsets ) {\n args -> offsets [ myTarget - args -> target ] = ( int32_t ) ( mySource - args -> source - 2 ) ;\n }\n * ( myTarget ++ ) = ( UChar ) mySourceChar ;\n myData -> isEmptySegment = FALSE ;\n continue ;\n case UCNV_OPEN_BRACE : case UCNV_CLOSE_BRACE : myData -> isStateDBCS = ( mySourceChar == UCNV_OPEN_BRACE ) ;\n if ( myData -> isEmptySegment ) {\n myData -> isEmptySegment = FALSE ;\n * err = U_ILLEGAL_ESCAPE_SEQUENCE ;\n args -> converter -> toUCallbackReason = UCNV_IRREGULAR ;\n args -> converter -> toUBytes [ 0 ] = UCNV_TILDE ;\n args -> converter -> toUBytes [ 1 ] = mySourceChar ;\n args -> converter -> toULength = 2 ;\n args -> target = myTarget ;\n args -> source = mySource ;\n return ;\n }\n myData -> isEmptySegment = TRUE ;\n continue ;\n default : myData -> isEmptySegment = FALSE ;\n * err = U_ILLEGAL_ESCAPE_SEQUENCE ;\n args -> converter -> toUBytes [ 0 ] = UCNV_TILDE ;\n if ( myData -> isStateDBCS ? ( 0x21 <= mySourceChar && mySourceChar <= 0x7e ) : mySourceChar <= 0x7f ) {\n args -> converter -> toULength = 1 ;\n -- mySource ;\n }\n else {\n args -> converter -> toUBytes [ 1 ] = mySourceChar ;\n args -> converter -> toULength = 2 ;\n }\n args -> target = myTarget ;\n args -> source = mySource ;\n return ;\n }\n }\n else if ( myData -> isStateDBCS ) {\n if ( args -> converter -> toUnicodeStatus == 0x00 ) {\n if ( mySourceChar == UCNV_TILDE ) {\n args -> converter -> mode = UCNV_TILDE ;\n }\n else {\n args -> converter -> toUnicodeStatus = ( uint32_t ) ( mySourceChar | 0x100 ) ;\n myData -> isEmptySegment = FALSE ;\n }\n continue ;\n }\n else {\n int leadIsOk , trailIsOk ;\n uint32_t leadByte = args -> converter -> toUnicodeStatus & 0xff ;\n targetUniChar = 0xffff ;\n leadIsOk = ( uint8_t ) ( leadByte - 0x21 ) <= ( 0x7d - 0x21 ) ;\n trailIsOk = ( uint8_t ) ( mySourceChar - 0x21 ) <= ( 0x7e - 0x21 ) ;\n if ( leadIsOk && trailIsOk ) {\n tempBuf [ 0 ] = ( char ) ( leadByte + 0x80 ) ;\n tempBuf [ 1 ] = ( char ) ( mySourceChar + 0x80 ) ;\n targetUniChar = ucnv_MBCSSimpleGetNextUChar ( myData -> gbConverter -> sharedData , tempBuf , 2 , args -> converter -> useFallback ) ;\n mySourceChar = ( leadByte << 8 ) | mySourceChar ;\n }\n else if ( trailIsOk ) {\n -- mySource ;\n mySourceChar = ( int32_t ) leadByte ;\n }\n else {\n mySourceChar = 0x10000 | ( leadByte << 8 ) | mySourceChar ;\n }\n args -> converter -> toUnicodeStatus = 0x00 ;\n }\n }\n else {\n if ( mySourceChar == UCNV_TILDE ) {\n args -> converter -> mode = UCNV_TILDE ;\n continue ;\n }\n else if ( mySourceChar <= 0x7f ) {\n targetUniChar = ( UChar ) mySourceChar ;\n myData -> isEmptySegment = FALSE ;\n }\n else {\n targetUniChar = 0xffff ;\n myData -> isEmptySegment = FALSE ;\n }\n }\n if ( targetUniChar < 0xfffe ) {\n if ( args -> offsets ) {\n args -> offsets [ myTarget - args -> target ] = ( int32_t ) ( mySource - args -> source - 1 - ( myData -> isStateDBCS ) ) ;\n }\n * ( myTarget ++ ) = ( UChar ) targetUniChar ;\n }\n else {\n if ( targetUniChar == 0xfffe ) {\n * err = U_INVALID_CHAR_FOUND ;\n }\n else {\n * err = U_ILLEGAL_CHAR_FOUND ;\n }\n if ( mySourceChar > 0xff ) {\n args -> converter -> toUBytes [ 0 ] = ( uint8_t ) ( mySourceChar >> 8 ) ;\n args -> converter -> toUBytes [ 1 ] = ( uint8_t ) mySourceChar ;\n args -> converter -> toULength = 2 ;\n }\n else {\n args -> converter -> toUBytes [ 0 ] = ( uint8_t ) mySourceChar ;\n args -> converter -> toULength = 1 ;\n }\n break ;\n }\n }\n else {\n * err = U_BUFFER_OVERFLOW_ERROR ;\n break ;\n }\n }\n args -> target = myTarget ;\n args -> source = mySource ;\n }", "idx": 1157}
{"hash": 5357882892791796049, "project": "debian", "size": 7, "label": 0, "functionSource": "static void e1000e_set_interrupt_cause ( E1000ECore * core , uint32_t val ) {\n trace_e1000e_irq_set_cause_entry ( val , core -> mac [ ICR ] ) ;\n val |= e1000e_intmgr_collect_delayed_causes ( core ) ;\n core -> mac [ ICR ] |= val ;\n trace_e1000e_irq_set_cause_exit ( val , core -> mac [ ICR ] ) ;\n e1000e_update_interrupt_state ( core ) ;\n }", "idx": 1158}
{"hash": -866921002076081979, "project": "debian", "size": 21, "label": 0, "functionSource": "static int checkHttpTxnNextHopIPGet ( SocketTest * test , void * data ) {\n TSHttpTxn txnp = ( TSHttpTxn ) data ;\n in_addr_t actual_ip = htonl ( INADDR_LOOPBACK ) ;\n sockaddr const * ptr ;\n in_addr_t nexthopip ;\n ptr = TSHttpTxnNextHopAddrGet ( txnp ) ;\n if ( ptr == nullptr || ( nexthopip = ats_ip4_addr_cast ( ptr ) ) == 0 ) {\n test -> test_next_hop_ip_get = false ;\n SDK_RPRINT ( test -> regtest , \"TSHttpTxnNextHopIPGet\" , \"TestCase1\" , TC_FAIL , \"TSHttpTxnNextHopIPGet returns 0 %s\" , ptr ? \"address\" : \"pointer\" ) ;\n return TS_EVENT_CONTINUE ;\n }\n if ( nexthopip == actual_ip ) {\n test -> test_next_hop_ip_get = true ;\n SDK_RPRINT ( test -> regtest , \"TSHttpTxnNextHopIPGet\" , \"TestCase1\" , TC_PASS , \"ok\" ) ;\n }\n else {\n test -> test_next_hop_ip_get = false ;\n SDK_RPRINT ( test -> regtest , \"TSHttpTxnNextHopIPGet\" , \"TestCase1\" , TC_FAIL , \"Value's Mismatch [expected %0.8x got %0.8x]\" , actual_ip , nexthopip ) ;\n }\n return TS_EVENT_CONTINUE ;\n }", "idx": 1159}
{"hash": 1760449185745615462, "project": "debian", "size": 4, "label": 0, "functionSource": "TSMBuffer TSFetchRespHdrMBufGet ( TSFetchSM fetch_sm ) {\n sdk_assert ( sdk_sanity_check_fetch_sm ( fetch_sm ) == TS_SUCCESS ) ;\n return ( ( FetchSM * ) fetch_sm ) -> resp_hdr_bufp ( ) ;\n }", "idx": 1160}
{"hash": 2546373479020365143, "project": "debian", "size": 6, "label": 0, "functionSource": "MIMEHdrImpl * mime_hdr_clone ( MIMEHdrImpl * s_mh , HdrHeap * s_heap , HdrHeap * d_heap , bool inherit_strs ) {\n MIMEHdrImpl * d_mh ;\n d_mh = mime_hdr_create ( d_heap ) ;\n mime_hdr_copy_onto ( s_mh , s_heap , d_mh , d_heap , inherit_strs ) ;\n return d_mh ;\n }", "idx": 1161}
{"hash": -2423144171479606949, "project": "debian", "size": 5, "label": 0, "functionSource": "static void pdf_run_BMC ( fz_context * ctx , pdf_processor * proc , const char * tag ) {\n pdf_run_processor * pr = ( pdf_run_processor * ) proc ;\n if ( ! tag ) tag = \"UnnamedLayer\" ;\n fz_begin_layer ( ctx , pr -> dev , tag ) ;\n }", "idx": 1162}
{"hash": 7445727465094525382, "project": "debian", "size": 9, "label": 0, "functionSource": "void ASN1_TYPE_set ( ASN1_TYPE * a , int type , void * value ) {\n if ( a -> value . ptr != NULL ) {\n ASN1_TYPE * * tmp_a = & a ;\n ASN1_primitive_free ( ( ASN1_VALUE * * ) tmp_a , NULL ) ;\n }\n a -> type = type ;\n if ( type == V_ASN1_BOOLEAN ) a -> value . boolean = value ? 0xff : 0 ;\n else a -> value . ptr = value ;\n }", "idx": 1163}
{"hash": 1458662858915721428, "project": "debian", "size": 76, "label": 0, "functionSource": "void tb_invalidate_phys_page_range ( tb_page_addr_t start , tb_page_addr_t end , int is_cpu_write_access ) {\n TranslationBlock * tb , * tb_next , * saved_tb ;\n CPUState * cpu = current_cpu ;\n # if defined ( TARGET_HAS_PRECISE_SMC ) || ! defined ( CONFIG_USER_ONLY ) CPUArchState * env = NULL ;\n # endif tb_page_addr_t tb_start , tb_end ;\n PageDesc * p ;\n int n ;\n # ifdef TARGET_HAS_PRECISE_SMC int current_tb_not_found = is_cpu_write_access ;\n TranslationBlock * current_tb = NULL ;\n int current_tb_modified = 0 ;\n target_ulong current_pc = 0 ;\n target_ulong current_cs_base = 0 ;\n int current_flags = 0 ;\n # endif p = page_find ( start >> TARGET_PAGE_BITS ) ;\n if ( ! p ) {\n return ;\n }\n if ( ! p -> code_bitmap && ++ p -> code_write_count >= SMC_BITMAP_USE_THRESHOLD && is_cpu_write_access ) {\n build_page_bitmap ( p ) ;\n }\n # if defined ( TARGET_HAS_PRECISE_SMC ) || ! defined ( CONFIG_USER_ONLY ) if ( cpu != NULL ) {\n env = cpu -> env_ptr ;\n }\n # endif tb = p -> first_tb ;\n while ( tb != NULL ) {\n n = ( uintptr_t ) tb & 3 ;\n tb = ( TranslationBlock * ) ( ( uintptr_t ) tb & ~ 3 ) ;\n tb_next = tb -> page_next [ n ] ;\n if ( n == 0 ) {\n tb_start = tb -> page_addr [ 0 ] + ( tb -> pc & ~ TARGET_PAGE_MASK ) ;\n tb_end = tb_start + tb -> size ;\n }\n else {\n tb_start = tb -> page_addr [ 1 ] ;\n tb_end = tb_start + ( ( tb -> pc + tb -> size ) & ~ TARGET_PAGE_MASK ) ;\n }\n if ( ! ( tb_end <= start || tb_start >= end ) ) {\n # ifdef TARGET_HAS_PRECISE_SMC if ( current_tb_not_found ) {\n current_tb_not_found = 0 ;\n current_tb = NULL ;\n if ( env -> mem_io_pc ) {\n current_tb = tb_find_pc ( env -> mem_io_pc ) ;\n }\n }\n if ( current_tb == tb && ( current_tb -> cflags & CF_COUNT_MASK ) != 1 ) {\n current_tb_modified = 1 ;\n cpu_restore_state_from_tb ( current_tb , env , env -> mem_io_pc ) ;\n cpu_get_tb_cpu_state ( env , & current_pc , & current_cs_base , & current_flags ) ;\n }\n # endif saved_tb = NULL ;\n if ( cpu != NULL ) {\n saved_tb = cpu -> current_tb ;\n cpu -> current_tb = NULL ;\n }\n tb_phys_invalidate ( tb , - 1 ) ;\n if ( cpu != NULL ) {\n cpu -> current_tb = saved_tb ;\n if ( cpu -> interrupt_request && cpu -> current_tb ) {\n cpu_interrupt ( cpu , cpu -> interrupt_request ) ;\n }\n }\n }\n tb = tb_next ;\n }\n # if ! defined ( CONFIG_USER_ONLY ) if ( ! p -> first_tb ) {\n invalidate_page_bitmap ( p ) ;\n if ( is_cpu_write_access ) {\n tlb_unprotect_code_phys ( env , start , env -> mem_io_vaddr ) ;\n }\n }\n # endif # ifdef TARGET_HAS_PRECISE_SMC if ( current_tb_modified ) {\n cpu -> current_tb = NULL ;\n tb_gen_code ( env , current_pc , current_cs_base , current_flags , 1 ) ;\n cpu_resume_from_signal ( env , NULL ) ;\n }\n # endif }", "idx": 1164}
{"hash": 6910889735724933479, "project": "debian", "size": 29, "label": 0, "functionSource": "static void * bamboo_load_device_tree ( target_phys_addr_t addr , uint32_t ramsize , target_phys_addr_t initrd_base , target_phys_addr_t initrd_size , const char * kernel_cmdline ) {\n void * fdt = NULL ;\n # ifdef CONFIG_FDT uint32_t mem_reg_property [ ] = {\n 0 , 0 , ramsize }\n ;\n char * filename ;\n int fdt_size ;\n int ret ;\n filename = qemu_find_file ( QEMU_FILE_TYPE_BIOS , BINARY_DEVICE_TREE_FILE ) ;\n if ( ! filename ) {\n goto out ;\n }\n fdt = load_device_tree ( filename , & fdt_size ) ;\n qemu_free ( filename ) ;\n if ( fdt == NULL ) {\n goto out ;\n }\n ret = qemu_devtree_setprop ( fdt , \"/memory\" , \"reg\" , mem_reg_property , sizeof ( mem_reg_property ) ) ;\n if ( ret < 0 ) fprintf ( stderr , \"couldn't set /memory/reg\\n\" ) ;\n ret = qemu_devtree_setprop_cell ( fdt , \"/chosen\" , \"linux,initrd-start\" , initrd_base ) ;\n if ( ret < 0 ) fprintf ( stderr , \"couldn't set /chosen/linux,initrd-start\\n\" ) ;\n ret = qemu_devtree_setprop_cell ( fdt , \"/chosen\" , \"linux,initrd-end\" , ( initrd_base + initrd_size ) ) ;\n if ( ret < 0 ) fprintf ( stderr , \"couldn't set /chosen/linux,initrd-end\\n\" ) ;\n ret = qemu_devtree_setprop_string ( fdt , \"/chosen\" , \"bootargs\" , kernel_cmdline ) ;\n if ( ret < 0 ) fprintf ( stderr , \"couldn't set /chosen/bootargs\\n\" ) ;\n if ( kvm_enabled ( ) ) kvmppc_fdt_update ( fdt ) ;\n cpu_physical_memory_write ( addr , ( void * ) fdt , fdt_size ) ;\n out : # endif return fdt ;\n }", "idx": 1165}
{"hash": -8933711118846965366, "project": "debian", "size": 10, "label": 0, "functionSource": "static inline uint16_t cirrus_src16 ( CirrusVGAState * s , uint32_t srcaddr ) {\n uint16_t * src ;\n if ( s -> cirrus_srccounter ) {\n src = ( void * ) & s -> cirrus_bltbuf [ srcaddr & ( CIRRUS_BLTBUFSIZE - 1 ) & ~ 1 ] ;\n }\n else {\n src = ( void * ) & s -> vga . vram_ptr [ srcaddr & s -> cirrus_addr_mask & ~ 1 ] ;\n }\n return * src ;\n }", "idx": 1166}
{"hash": 1223258652239369123, "project": "debian", "size": 16, "label": 1, "functionSource": "zend_object_iterator * spl_filesystem_dir_get_iterator ( zend_class_entry * ce , zval * object , int by_ref TSRMLS_DC ) {\n spl_filesystem_iterator * iterator ;\n spl_filesystem_object * dir_object ;\n if ( by_ref ) {\n zend_error ( E_ERROR , \"An iterator cannot be used with foreach by reference\" ) ;\n }\n dir_object = ( spl_filesystem_object * ) zend_object_store_get_object ( object TSRMLS_CC ) ;\n iterator = spl_filesystem_object_to_iterator ( dir_object ) ;\n if ( iterator -> intern . data == NULL ) {\n iterator -> intern . data = object ;\n iterator -> intern . funcs = & spl_filesystem_dir_it_funcs ;\n iterator -> current = object ;\n }\n zval_add_ref ( & object ) ;\n return ( zend_object_iterator * ) iterator ;\n }", "idx": 1167}
{"hash": -5268859819325807498, "project": "debian", "size": 9, "label": 0, "functionSource": "gboolean nautilus_directory_is_anyone_monitoring_file_list ( NautilusDirectory * directory ) {\n if ( directory -> details -> call_when_ready_counters [ REQUEST_FILE_LIST ] > 0 ) {\n return TRUE ;\n }\n if ( directory -> details -> monitor_counters [ REQUEST_FILE_LIST ] > 0 ) {\n return TRUE ;\n }\n return FALSE ;\n }", "idx": 1168}
{"hash": 6336384260629386331, "project": "debian", "size": 15, "label": 0, "functionSource": "static void dissect_zcl_ota_queryspecfilersp ( tvbuff_t * tvb , proto_tree * tree , guint * offset ) {\n guint8 status ;\n status = tvb_get_guint8 ( tvb , * offset ) ;\n proto_tree_add_item ( tree , hf_zbee_zcl_ota_status , tvb , * offset , 1 , ENC_NA ) ;\n * offset += 1 ;\n if ( status == ZBEE_ZCL_STAT_SUCCESS ) {\n proto_tree_add_item ( tree , hf_zbee_zcl_ota_manufacturer_code , tvb , * offset , 2 , ENC_LITTLE_ENDIAN ) ;\n * offset += 2 ;\n proto_tree_add_item ( tree , hf_zbee_zcl_ota_image_type , tvb , * offset , 2 , ENC_LITTLE_ENDIAN ) ;\n * offset += 2 ;\n dissect_zcl_ota_file_version_field ( tvb , tree , offset ) ;\n proto_tree_add_item ( tree , hf_zbee_zcl_ota_image_size , tvb , * offset , 4 , ENC_LITTLE_ENDIAN ) ;\n * offset += 4 ;\n }\n }", "idx": 1169}
{"hash": -8562506069584692324, "project": "chrome", "size": 29, "label": 1, "functionSource": "TEST_F ( MultiBufferTest , ReadAll ) {\n multibuffer_ . SetMaxWriters ( 1 ) ;\n size_t pos = 0 ;\n size_t end = 10000 ;\n multibuffer_ . SetFileSize ( 10000 ) ;\n multibuffer_ . SetMustReadWholeFile ( true ) ;\n media : : MultiBufferReader reader ( & multibuffer_ , pos , end , base : : Callback < void ( int64_t , int64_t ) > ( ) ) ;\n reader . SetMaxBuffer ( 2000 , 5000 ) ;\n reader . SetPreload ( 1000 , 1000 ) ;\n while ( pos < end ) {\n unsigned char buffer [ 27 ] ;\n buffer [ 17 ] = 17 ;\n size_t to_read = std : : min < size_t > ( end - pos , 17 ) ;\n int64_t bytes_read = reader . TryRead ( buffer , to_read ) ;\n if ( bytes_read ) {\n EXPECT_EQ ( buffer [ 17 ] , 17 ) ;\n for ( int64_t i = 0 ;\n i < bytes_read ;\n i ++ ) {\n uint8_t expected = static_cast < uint8_t > ( ( pos * 15485863 ) >> 16 ) ;\n EXPECT_EQ ( expected , buffer [ i ] ) << \" pos = \" << pos ;\n pos ++ ;\n }\n }\n else {\n Advance ( ) ;\n }\n }\n }", "idx": 1170}
{"hash": 4180964683905830761, "project": "debian", "size": 4, "label": 0, "functionSource": "static int selinux_inode_removexattr ( struct dentry * dentry , const char * name ) {\n if ( strcmp ( name , XATTR_NAME_SELINUX ) ) return selinux_inode_setotherxattr ( dentry , name ) ;\n return - EACCES ;\n }", "idx": 1171}
{"hash": 2687336064028423153, "project": "chrome", "size": 23, "label": 0, "functionSource": "static void evdns_requests_pump_waiting_queue ( void ) {\n while ( global_requests_inflight < global_max_requests_inflight && global_requests_waiting ) {\n struct request * req ;\n assert ( req_waiting_head ) ;\n if ( req_waiting_head -> next == req_waiting_head ) {\n req = req_waiting_head ;\n req_waiting_head = NULL ;\n }\n else {\n req = req_waiting_head ;\n req -> next -> prev = req -> prev ;\n req -> prev -> next = req -> next ;\n req_waiting_head = req -> next ;\n }\n global_requests_waiting -- ;\n global_requests_inflight ++ ;\n req -> ns = nameserver_pick ( ) ;\n request_trans_id_set ( req , transaction_id_pick ( ) ) ;\n evdns_request_insert ( req , & req_head ) ;\n evdns_request_transmit ( req ) ;\n evdns_transmit ( ) ;\n }\n }", "idx": 1172}
{"hash": 589395864685553737, "project": "debian", "size": 19, "label": 0, "functionSource": "static void nvic_sysreg_write ( void * opaque , hwaddr addr , uint64_t value , unsigned size ) {\n nvic_state * s = ( nvic_state * ) opaque ;\n uint32_t offset = addr ;\n int i ;\n switch ( offset ) {\n case 0xd18 ... 0xd23 : for ( i = 0 ;\n i < size ;\n i ++ ) {\n s -> gic . priority1 [ ( offset - 0xd14 ) + i ] [ 0 ] = ( value >> ( i * 8 ) ) & 0xff ;\n }\n gic_update ( & s -> gic ) ;\n return ;\n }\n if ( size == 4 ) {\n nvic_writel ( s , offset , value ) ;\n return ;\n }\n qemu_log_mask ( LOG_GUEST_ERROR , \"NVIC: Bad write of size %d at offset 0x%x\\n\" , size , offset ) ;\n }", "idx": 1173}
{"hash": 8461782184979846246, "project": "chrome", "size": 13, "label": 0, "functionSource": "TEST_F ( ProtocolHandlerRegistryTest , TestRemovingDefaultDoesntChangeHandlers ) {\n ProtocolHandler ph1 = CreateProtocolHandler ( \"mailto\" , \"test1\" ) ;\n ProtocolHandler ph2 = CreateProtocolHandler ( \"mailto\" , \"test2\" ) ;\n ProtocolHandler ph3 = CreateProtocolHandler ( \"mailto\" , \"test3\" ) ;\n registry ( ) -> OnAcceptRegisterProtocolHandler ( ph1 ) ;\n registry ( ) -> OnAcceptRegisterProtocolHandler ( ph2 ) ;\n registry ( ) -> OnAcceptRegisterProtocolHandler ( ph3 ) ;\n registry ( ) -> RemoveHandler ( ph3 ) ;\n ProtocolHandlerRegistry : : ProtocolHandlerList handlers = registry ( ) -> GetHandlersFor ( \"mailto\" ) ;\n ASSERT_EQ ( static_cast < size_t > ( 2 ) , handlers . size ( ) ) ;\n ASSERT_EQ ( ph2 , handlers [ 0 ] ) ;\n ASSERT_EQ ( ph1 , handlers [ 1 ] ) ;\n }", "idx": 1174}
{"hash": 1470723493451072803, "project": "debian", "size": 62, "label": 0, "functionSource": "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n AVFrame * const p = data ;\n uint8_t * Y , * U , * V ;\n int i , j , ret ;\n int stride ;\n uint32_t val ;\n int y0 , y1 , y2 , y3 = 0 , c0 = 0 , c1 = 0 ;\n if ( ( ret = ff_get_buffer ( avctx , p , 0 ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n p -> pict_type = AV_PICTURE_TYPE_I ;\n p -> key_frame = 1 ;\n Y = p -> data [ 0 ] ;\n U = p -> data [ 1 ] ;\n V = p -> data [ 2 ] ;\n stride = avctx -> width - 4 ;\n if ( buf_size < avctx -> width * avctx -> height ) {\n av_log ( avctx , AV_LOG_ERROR , \"Packet is too small\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n for ( i = 0 ;\n i < avctx -> height ;\n i ++ ) {\n buf += stride ;\n for ( j = 0 ;\n j < avctx -> width ;\n j += 4 ) {\n val = AV_RL32 ( buf ) ;\n buf -= 4 ;\n val = ( ( val >> 16 ) & 0xFFFF ) | ( ( val & 0xFFFF ) << 16 ) ;\n if ( ! j ) y0 = ( val & 0x1F ) << 2 ;\n else y0 = y3 + xl_table [ val & 0x1F ] ;\n val >>= 5 ;\n y1 = y0 + xl_table [ val & 0x1F ] ;\n val >>= 5 ;\n y2 = y1 + xl_table [ val & 0x1F ] ;\n val >>= 6 ;\n y3 = y2 + xl_table [ val & 0x1F ] ;\n val >>= 5 ;\n if ( ! j ) c0 = ( val & 0x1F ) << 2 ;\n else c0 += xl_table [ val & 0x1F ] ;\n val >>= 5 ;\n if ( ! j ) c1 = ( val & 0x1F ) << 2 ;\n else c1 += xl_table [ val & 0x1F ] ;\n Y [ j + 0 ] = y0 << 1 ;\n Y [ j + 1 ] = y1 << 1 ;\n Y [ j + 2 ] = y2 << 1 ;\n Y [ j + 3 ] = y3 << 1 ;\n U [ j >> 2 ] = c0 << 1 ;\n V [ j >> 2 ] = c1 << 1 ;\n }\n buf += avctx -> width + 4 ;\n Y += p -> linesize [ 0 ] ;\n U += p -> linesize [ 1 ] ;\n V += p -> linesize [ 2 ] ;\n }\n * got_frame = 1 ;\n return buf_size ;\n }", "idx": 1175}
{"hash": 7651945086108393719, "project": "debian", "size": 58, "label": 0, "functionSource": "int qemuMonitorJSONGetBlockExtent ( qemuMonitorPtr mon , const char * dev_name , unsigned long long * extent ) {\n int ret = - 1 ;\n int i ;\n int found = 0 ;\n virJSONValuePtr cmd = qemuMonitorJSONMakeCommand ( \"query-blockstats\" , NULL ) ;\n virJSONValuePtr reply = NULL ;\n virJSONValuePtr devices ;\n * extent = 0 ;\n if ( ! cmd ) return - 1 ;\n ret = qemuMonitorJSONCommand ( mon , cmd , & reply ) ;\n if ( ret == 0 ) ret = qemuMonitorJSONCheckError ( cmd , reply ) ;\n if ( ret < 0 ) goto cleanup ;\n ret = - 1 ;\n devices = virJSONValueObjectGet ( reply , \"return\" ) ;\n if ( ! devices || devices -> type != VIR_JSON_TYPE_ARRAY ) {\n qemuReportError ( VIR_ERR_INTERNAL_ERROR , \"%s\" , _ ( \"blockstats reply was missing device list\" ) ) ;\n goto cleanup ;\n }\n for ( i = 0 ;\n i < virJSONValueArraySize ( devices ) ;\n i ++ ) {\n virJSONValuePtr dev = virJSONValueArrayGet ( devices , i ) ;\n virJSONValuePtr stats ;\n virJSONValuePtr parent ;\n const char * thisdev ;\n if ( ! dev || dev -> type != VIR_JSON_TYPE_OBJECT ) {\n qemuReportError ( VIR_ERR_INTERNAL_ERROR , \"%s\" , _ ( \"blockstats device entry was not in expected format\" ) ) ;\n goto cleanup ;\n }\n if ( ( thisdev = virJSONValueObjectGetString ( dev , \"device\" ) ) == NULL ) {\n qemuReportError ( VIR_ERR_INTERNAL_ERROR , \"%s\" , _ ( \"blockstats device entry was not in expected format\" ) ) ;\n goto cleanup ;\n }\n if ( STRPREFIX ( thisdev , QEMU_DRIVE_HOST_PREFIX ) ) thisdev += strlen ( QEMU_DRIVE_HOST_PREFIX ) ;\n if ( STRNEQ ( thisdev , dev_name ) ) continue ;\n found = 1 ;\n if ( ( parent = virJSONValueObjectGet ( dev , \"parent\" ) ) == NULL || parent -> type != VIR_JSON_TYPE_OBJECT ) {\n qemuReportError ( VIR_ERR_INTERNAL_ERROR , \"%s\" , _ ( \"blockstats parent entry was not in expected format\" ) ) ;\n goto cleanup ;\n }\n if ( ( stats = virJSONValueObjectGet ( parent , \"stats\" ) ) == NULL || stats -> type != VIR_JSON_TYPE_OBJECT ) {\n qemuReportError ( VIR_ERR_INTERNAL_ERROR , \"%s\" , _ ( \"blockstats stats entry was not in expected format\" ) ) ;\n goto cleanup ;\n }\n if ( virJSONValueObjectGetNumberUlong ( stats , \"wr_highest_offset\" , extent ) < 0 ) {\n qemuReportError ( VIR_ERR_INTERNAL_ERROR , _ ( \"cannot read %s statistic\" ) , \"wr_highest_offset\" ) ;\n goto cleanup ;\n }\n }\n if ( ! found ) {\n qemuReportError ( VIR_ERR_INTERNAL_ERROR , _ ( \"cannot find statistics for device '%s'\" ) , dev_name ) ;\n goto cleanup ;\n }\n ret = 0 ;\n cleanup : virJSONValueFree ( cmd ) ;\n virJSONValueFree ( reply ) ;\n return ret ;\n }", "idx": 1176}
{"hash": -1579723330456999443, "project": "chrome", "size": 50, "label": 0, "functionSource": "static int search_filter_level ( const YV12_BUFFER_CONFIG * sd , VP9_COMP * cpi , int partial_frame ) {\n const VP9_COMMON * const cm = & cpi -> common ;\n const struct loopfilter * const lf = & cm -> lf ;\n const int min_filter_level = 0 ;\n const int max_filter_level = get_max_filter_level ( cpi ) ;\n int filt_direction = 0 ;\n int best_err , filt_best ;\n int filt_mid = clamp ( lf -> filter_level , min_filter_level , max_filter_level ) ;\n int filter_step = filt_mid < 16 ? 4 : filt_mid / 4 ;\n int ss_err [ MAX_LOOP_FILTER + 1 ] ;\n vpx_memset ( ss_err , 0xFF , sizeof ( ss_err ) ) ;\n vpx_yv12_copy_y ( cm -> frame_to_show , & cpi -> last_frame_uf ) ;\n best_err = try_filter_frame ( sd , cpi , filt_mid , partial_frame ) ;\n filt_best = filt_mid ;\n ss_err [ filt_mid ] = best_err ;\n while ( filter_step > 0 ) {\n const int filt_high = MIN ( filt_mid + filter_step , max_filter_level ) ;\n const int filt_low = MAX ( filt_mid - filter_step , min_filter_level ) ;\n int bias = ( best_err >> ( 15 - ( filt_mid / 8 ) ) ) * filter_step ;\n if ( ( cpi -> oxcf . pass == 2 ) && ( cpi -> twopass . section_intra_rating < 20 ) ) bias = ( bias * cpi -> twopass . section_intra_rating ) / 20 ;\n if ( cm -> tx_mode != ONLY_4X4 ) bias >>= 1 ;\n if ( filt_direction <= 0 && filt_low != filt_mid ) {\n if ( ss_err [ filt_low ] < 0 ) {\n ss_err [ filt_low ] = try_filter_frame ( sd , cpi , filt_low , partial_frame ) ;\n }\n if ( ( ss_err [ filt_low ] - bias ) < best_err ) {\n if ( ss_err [ filt_low ] < best_err ) best_err = ss_err [ filt_low ] ;\n filt_best = filt_low ;\n }\n }\n if ( filt_direction >= 0 && filt_high != filt_mid ) {\n if ( ss_err [ filt_high ] < 0 ) {\n ss_err [ filt_high ] = try_filter_frame ( sd , cpi , filt_high , partial_frame ) ;\n }\n if ( ss_err [ filt_high ] < ( best_err - bias ) ) {\n best_err = ss_err [ filt_high ] ;\n filt_best = filt_high ;\n }\n }\n if ( filt_best == filt_mid ) {\n filter_step /= 2 ;\n filt_direction = 0 ;\n }\n else {\n filt_direction = ( filt_best < filt_mid ) ? - 1 : 1 ;\n filt_mid = filt_best ;\n }\n }\n return filt_best ;\n }", "idx": 1177}
{"hash": -7555034601056330007, "project": "debian", "size": 6, "label": 0, "functionSource": "void virLogMessage ( virLogSourcePtr source , virLogPriority priority , const char * filename , int linenr , const char * funcname , virLogMetadataPtr metadata , const char * fmt , ... ) {\n va_list ap ;\n va_start ( ap , fmt ) ;\n virLogVMessage ( source , priority , filename , linenr , funcname , metadata , fmt , ap ) ;\n va_end ( ap ) ;\n }", "idx": 1178}
{"hash": 6323824267898511453, "project": "debian", "size": 29, "label": 0, "functionSource": "static void icc_conv_color ( fz_context * ctx , fz_color_converter * cc , float * dstv , const float * srcv ) {\n const fz_colorspace * dsts = cc -> ds ;\n int src_n = cc -> n ;\n int dst_n = dsts -> n ;\n fz_icclink * link = ( fz_icclink * ) cc -> link ;\n int i ;\n unsigned short dstv_s [ FZ_MAX_COLORS ] ;\n unsigned short srcv_s [ FZ_MAX_COLORS ] ;\n if ( link == NULL ) {\n dstv [ 0 ] = 0 ;\n dstv [ 1 ] = 0 ;\n dstv [ 2 ] = 0 ;\n dstv [ 3 ] = 1 - srcv [ 0 ] ;\n }\n else if ( link -> is_identity ) {\n for ( i = 0 ;\n i < src_n ;\n i ++ ) dstv [ i ] = srcv [ i ] ;\n }\n else {\n for ( i = 0 ;\n i < src_n ;\n i ++ ) srcv_s [ i ] = srcv [ i ] * 65535 ;\n fz_cmm_transform_color ( ctx , link , dstv_s , srcv_s ) ;\n for ( i = 0 ;\n i < dst_n ;\n i ++ ) dstv [ i ] = fz_clamp ( ( float ) dstv_s [ i ] / 65535.0f , 0 , 1 ) ;\n }\n }", "idx": 1179}
{"hash": -1919011628477388936, "project": "debian", "size": 4, "label": 0, "functionSource": "static void openpic_init ( Object * obj ) {\n OpenPICState * opp = OPENPIC ( obj ) ;\n memory_region_init ( & opp -> mem , obj , \"openpic\" , 0x40000 ) ;\n }", "idx": 1180}
{"hash": 2518148041181868265, "project": "debian", "size": 8, "label": 0, "functionSource": "char * irc_ctcp_dcc_filename_without_quotes ( const char * filename ) {\n int length ;\n length = strlen ( filename ) ;\n if ( length > 1 ) {\n if ( ( filename [ 0 ] == '\\\"' ) && ( filename [ length - 1 ] == '\\\"' ) ) return weechat_strndup ( filename + 1 , length - 2 ) ;\n }\n return strdup ( filename ) ;\n }", "idx": 1181}
{"hash": -1145838621747570454, "project": "debian", "size": 3, "label": 0, "functionSource": "void key_type_put ( struct key_type * ktype ) {\n up_read ( & key_types_sem ) ;\n }", "idx": 1182}
{"hash": -7237039260294671485, "project": "debian", "size": 3, "label": 0, "functionSource": "static int dissect_nlm4_test_res ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , void * data ) {\n return dissect_nlm_test_res ( tvb , 0 , pinfo , tree , 4 , ( rpc_call_info_value * ) data ) ;\n }", "idx": 1183}
{"hash": 378220832151730865, "project": "debian", "size": 23, "label": 0, "functionSource": "static int qemuMonitorTextSaveMemory ( qemuMonitorPtr mon , const char * cmdtype , unsigned long long offset , size_t length , const char * path ) {\n char * cmd = NULL ;\n char * reply = NULL ;\n char * safepath = NULL ;\n int ret = - 1 ;\n if ( ! ( safepath = qemuMonitorEscapeArg ( path ) ) ) {\n virReportOOMError ( ) ;\n goto cleanup ;\n }\n if ( virAsprintf ( & cmd , \"%s %llu %zi \\\"%s\\\"\" , cmdtype , offset , length , safepath ) < 0 ) {\n virReportOOMError ( ) ;\n goto cleanup ;\n }\n if ( qemuMonitorHMPCommand ( mon , cmd , & reply ) < 0 ) {\n qemuReportError ( VIR_ERR_OPERATION_FAILED , _ ( \"could not save memory region to '%s'\" ) , path ) ;\n goto cleanup ;\n }\n ret = 0 ;\n cleanup : VIR_FREE ( cmd ) ;\n VIR_FREE ( reply ) ;\n VIR_FREE ( safepath ) ;\n return ret ;\n }", "idx": 1184}
{"hash": 927123821003322045, "project": "chrome", "size": 14, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( PageLoadMetricsBrowserTest , UseCounterFeaturesInNonSecureMainFrame ) {\n ASSERT_TRUE ( embedded_test_server ( ) -> Start ( ) ) ;\n auto waiter = CreatePageLoadMetricsWaiter ( ) ;\n waiter -> AddPageExpectation ( TimingField : : LOAD_EVENT ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , embedded_test_server ( ) -> GetURL ( \"non-secure.test\" , \"/page_load_metrics/use_counter_features.html\" ) ) ;\n waiter -> Wait ( ) ;\n NavigateToUntrackedUrl ( ) ;\n histogram_tester_ . ExpectBucketCount ( internal : : kFeaturesHistogramName , static_cast < int32_t > ( WebFeature : : kTextWholeText ) , 1 ) ;\n histogram_tester_ . ExpectBucketCount ( internal : : kFeaturesHistogramName , static_cast < int32_t > ( WebFeature : : kV8Element_Animate_Method ) , 1 ) ;\n histogram_tester_ . ExpectBucketCount ( internal : : kFeaturesHistogramName , static_cast < int32_t > ( WebFeature : : kNavigatorVibrate ) , 1 ) ;\n histogram_tester_ . ExpectBucketCount ( internal : : kFeaturesHistogramName , static_cast < int32_t > ( WebFeature : : kDataUriHasOctothorpe ) , 1 ) ;\n histogram_tester_ . ExpectBucketCount ( internal : : kFeaturesHistogramName , static_cast < int32_t > ( WebFeature : : kApplicationCacheManifestSelectInsecureOrigin ) , 1 ) ;\n histogram_tester_ . ExpectBucketCount ( internal : : kFeaturesHistogramName , static_cast < int32_t > ( WebFeature : : kPageVisits ) , 1 ) ;\n }", "idx": 1185}
{"hash": 6664609110189077049, "project": "debian", "size": 94, "label": 0, "functionSource": "static int decode_channel_transform ( WMAProDecodeCtx * s ) {\n int i ;\n s -> num_chgroups = 0 ;\n if ( s -> avctx -> channels > 1 ) {\n int remaining_channels = s -> channels_for_cur_subframe ;\n if ( get_bits1 ( & s -> gb ) ) {\n av_log_ask_for_sample ( s -> avctx , \"unsupported channel transform bit\\n\" ) ;\n return AVERROR_PATCHWELCOME ;\n }\n for ( s -> num_chgroups = 0 ;\n remaining_channels && s -> num_chgroups < s -> channels_for_cur_subframe ;\n s -> num_chgroups ++ ) {\n WMAProChannelGrp * chgroup = & s -> chgroup [ s -> num_chgroups ] ;\n float * * channel_data = chgroup -> channel_data ;\n chgroup -> num_channels = 0 ;\n chgroup -> transform = 0 ;\n if ( remaining_channels > 2 ) {\n for ( i = 0 ;\n i < s -> channels_for_cur_subframe ;\n i ++ ) {\n int channel_idx = s -> channel_indexes_for_cur_subframe [ i ] ;\n if ( ! s -> channel [ channel_idx ] . grouped && get_bits1 ( & s -> gb ) ) {\n ++ chgroup -> num_channels ;\n s -> channel [ channel_idx ] . grouped = 1 ;\n * channel_data ++ = s -> channel [ channel_idx ] . coeffs ;\n }\n }\n }\n else {\n chgroup -> num_channels = remaining_channels ;\n for ( i = 0 ;\n i < s -> channels_for_cur_subframe ;\n i ++ ) {\n int channel_idx = s -> channel_indexes_for_cur_subframe [ i ] ;\n if ( ! s -> channel [ channel_idx ] . grouped ) * channel_data ++ = s -> channel [ channel_idx ] . coeffs ;\n s -> channel [ channel_idx ] . grouped = 1 ;\n }\n }\n if ( chgroup -> num_channels == 2 ) {\n if ( get_bits1 ( & s -> gb ) ) {\n if ( get_bits1 ( & s -> gb ) ) {\n av_log_ask_for_sample ( s -> avctx , \"unsupported channel transform type\\n\" ) ;\n }\n }\n else {\n chgroup -> transform = 1 ;\n if ( s -> avctx -> channels == 2 ) {\n chgroup -> decorrelation_matrix [ 0 ] = 1.0 ;\n chgroup -> decorrelation_matrix [ 1 ] = - 1.0 ;\n chgroup -> decorrelation_matrix [ 2 ] = 1.0 ;\n chgroup -> decorrelation_matrix [ 3 ] = 1.0 ;\n }\n else {\n chgroup -> decorrelation_matrix [ 0 ] = 0.70703125 ;\n chgroup -> decorrelation_matrix [ 1 ] = - 0.70703125 ;\n chgroup -> decorrelation_matrix [ 2 ] = 0.70703125 ;\n chgroup -> decorrelation_matrix [ 3 ] = 0.70703125 ;\n }\n }\n }\n else if ( chgroup -> num_channels > 2 ) {\n if ( get_bits1 ( & s -> gb ) ) {\n chgroup -> transform = 1 ;\n if ( get_bits1 ( & s -> gb ) ) {\n decode_decorrelation_matrix ( s , chgroup ) ;\n }\n else {\n if ( chgroup -> num_channels > 6 ) {\n av_log_ask_for_sample ( s -> avctx , \"coupled channels > 6\\n\" ) ;\n }\n else {\n memcpy ( chgroup -> decorrelation_matrix , default_decorrelation [ chgroup -> num_channels ] , chgroup -> num_channels * chgroup -> num_channels * sizeof ( * chgroup -> decorrelation_matrix ) ) ;\n }\n }\n }\n }\n if ( chgroup -> transform ) {\n if ( ! get_bits1 ( & s -> gb ) ) {\n int i ;\n for ( i = 0 ;\n i < s -> num_bands ;\n i ++ ) {\n chgroup -> transform_band [ i ] = get_bits1 ( & s -> gb ) ;\n }\n }\n else {\n memset ( chgroup -> transform_band , 1 , s -> num_bands ) ;\n }\n }\n remaining_channels -= chgroup -> num_channels ;\n }\n }\n return 0 ;\n }", "idx": 1186}
{"hash": -5640788001150418304, "project": "debian", "size": 39, "label": 0, "functionSource": "void t38_add_address ( packet_info * pinfo , address * addr , int port , int other_port , const gchar * setup_method , guint32 setup_frame_number ) {\n address null_addr ;\n conversation_t * p_conversation ;\n t38_conv * p_conversation_data = NULL ;\n if ( ( pinfo -> fd -> flags . visited ) || ( t38_udp_handle == NULL ) ) {\n return ;\n }\n SET_ADDRESS ( & null_addr , AT_NONE , 0 , NULL ) ;\n p_conversation = find_conversation ( setup_frame_number , addr , & null_addr , PT_UDP , port , other_port , NO_ADDR_B | ( ! other_port ? NO_PORT_B : 0 ) ) ;\n if ( ! p_conversation || p_conversation -> setup_frame != setup_frame_number ) {\n p_conversation = conversation_new ( setup_frame_number , addr , & null_addr , PT_UDP , ( guint32 ) port , ( guint32 ) other_port , NO_ADDR2 | ( ! other_port ? NO_PORT2 : 0 ) ) ;\n }\n conversation_set_dissector ( p_conversation , t38_udp_handle ) ;\n p_conversation_data = ( t38_conv * ) conversation_get_proto_data ( p_conversation , proto_t38 ) ;\n if ( ! p_conversation_data ) {\n p_conversation_data = wmem_new ( wmem_file_scope ( ) , t38_conv ) ;\n conversation_add_proto_data ( p_conversation , proto_t38 , p_conversation_data ) ;\n }\n g_strlcpy ( p_conversation_data -> setup_method , setup_method , MAX_T38_SETUP_METHOD_SIZE ) ;\n p_conversation_data -> setup_frame_number = setup_frame_number ;\n p_conversation_data -> src_t38_info . reass_ID = 0 ;\n p_conversation_data -> src_t38_info . reass_start_seqnum = - 1 ;\n p_conversation_data -> src_t38_info . reass_data_type = 0 ;\n p_conversation_data -> src_t38_info . last_seqnum = - 1 ;\n p_conversation_data -> src_t38_info . packet_lost = 0 ;\n p_conversation_data -> src_t38_info . burst_lost = 0 ;\n p_conversation_data -> src_t38_info . time_first_t4_data = 0 ;\n p_conversation_data -> src_t38_info . additional_hdlc_data_field_counter = 0 ;\n p_conversation_data -> src_t38_info . seqnum_prev_data_field = - 1 ;\n p_conversation_data -> dst_t38_info . reass_ID = 0 ;\n p_conversation_data -> dst_t38_info . reass_start_seqnum = - 1 ;\n p_conversation_data -> dst_t38_info . reass_data_type = 0 ;\n p_conversation_data -> dst_t38_info . last_seqnum = - 1 ;\n p_conversation_data -> dst_t38_info . packet_lost = 0 ;\n p_conversation_data -> dst_t38_info . burst_lost = 0 ;\n p_conversation_data -> dst_t38_info . time_first_t4_data = 0 ;\n p_conversation_data -> dst_t38_info . additional_hdlc_data_field_counter = 0 ;\n p_conversation_data -> dst_t38_info . seqnum_prev_data_field = - 1 ;\n }", "idx": 1187}
{"hash": 6393050609822897742, "project": "debian", "size": 4, "label": 0, "functionSource": "static void xhci_ep_kick_timer ( void * opaque ) {\n XHCIEPContext * epctx = opaque ;\n xhci_kick_epctx ( epctx , 0 ) ;\n }", "idx": 1188}
{"hash": 9173144338563772419, "project": "debian", "size": 99, "label": 0, "functionSource": "void print_object_list ( int list_type ) {\n hoststatus * temp_hoststatus = NULL ;\n servicestatus * temp_servicestatus = NULL ;\n int x = 0 ;\n int row_color = 0 ;\n int host_passive = FALSE ;\n int service_passive = FALSE ;\n printf ( \"<tr><td colspan=\\\"2\\\">&nbsp;\n</td></tr>\\n\" ) ;\n printf ( \"<tr class=\\\"sectionHeader\\\"><td colspan=\\\"2\\\" >Affected Objects</td></tr>\\n\" ) ;\n printf ( \"<tr><td colspan=\\\"2\\\">\\n\" ) ;\n printf ( \"<script language='javascript' type=\\\"text/javascript\\\">\\nchecked=false;\n\\n\" ) ;\n printf ( \"function checkAllBoxes() {\n\\n\" \" checked = (checked == false) ? true : false;\n\\n\" \" for (var i=0;\n i < %d;\n i++) {\n\\n\" \" var checkboxes = document.getElementById(\\\"cb_\\\" + i);\n\\n\" \" if (checkboxes != null ) {\n checkboxes.checked = checked;\n }\n\\n\" \" }\n\\n\" \"}\n\\n\" , NUMBER_OF_STRUCTS ) ;\n printf ( \"</script>\\n\" ) ;\n printf ( \"<TABLE cellspacing='2' cellpadding='0' border='0' width='100%%'>\\n\" ) ;\n if ( list_type == PRINT_SERVICE_LIST ) printf ( \"<tr class=\\\"objectTableHeader\\\"><td width=\\\"46%%\\\">Host</td><td width=\\\"46%%\\\">Service</td><td width='16'><input type='checkbox' onclick=\\\"checkAllBoxes();\n\\\" title=\\\"Check All\\\"></td></tr>\\n\" ) ;\n else if ( list_type == PRINT_HOST_LIST ) printf ( \"<tr class=\\\"objectTableHeader\\\"><td colspan=\\\"2\\\" width=\\\"96%%\\\">Hosts</td><td width='16'><input type='checkbox' onclick=\\\"checkAllBoxes();\n\\\" title=\\\"Check All\\\"></td></tr>\\n\" ) ;\n else printf ( \"<tr><td colspan=\\\"3\\\">&nbsp;\n</td></tr>\\n\" ) ;\n for ( x = 0 ;\n x < NUMBER_OF_STRUCTS ;\n x ++ ) {\n if ( list_type == PRINT_HOST_LIST || list_type == PRINT_SERVICE_LIST ) {\n host_passive = FALSE ;\n service_passive = FALSE ;\n if ( commands [ x ] . host_name == NULL ) continue ;\n if ( list_type == PRINT_SERVICE_LIST && commands [ x ] . description == NULL ) continue ;\n if ( strlen ( commands [ x ] . host_name ) != 0 && ( command_type == CMD_SCHEDULE_HOST_CHECK || command_type == CMD_DISABLE_HOST_CHECK || command_type == CMD_SCHEDULE_SVC_CHECK || command_type == CMD_DISABLE_SVC_CHECK ) ) {\n if ( ( temp_hoststatus = find_hoststatus ( commands [ x ] . host_name ) ) != NULL ) {\n if ( temp_hoststatus -> checks_enabled == FALSE ) host_passive = TRUE ;\n }\n if ( list_type == PRINT_SERVICE_LIST && strlen ( commands [ x ] . description ) != 0 ) {\n if ( ( temp_servicestatus = find_servicestatus ( commands [ x ] . host_name , commands [ x ] . description ) ) != NULL ) {\n if ( temp_servicestatus -> checks_enabled == FALSE ) service_passive = TRUE ;\n }\n }\n }\n }\n else {\n if ( multi_ids [ x ] == FALSE ) continue ;\n }\n row_color = ( row_color == 0 ) ? 1 : 0 ;\n printf ( \"<tr class=\\\"status%s\\\"><td width=\\\"50%%\\\"\" , ( row_color == 0 ) ? \"Even\" : \"Odd \" ) ;\n if ( list_type == PRINT_SERVICE_LIST ) {\n if ( strlen ( commands [ x ] . host_name ) != 0 && strlen ( commands [ x ] . description ) != 0 ) {\n printf ( \">%s</td><td>%s\" , escape_string ( commands [ x ] . host_name ) , escape_string ( commands [ x ] . description ) ) ;\n if ( service_passive == TRUE ) {\n printf ( \"<img src='%s%s' align=right border=0 style='padding-right:2px' alt='Passive' title='Passive Service'>\" , url_images_path , PASSIVE_ICON ) ;\n }\n printf ( \"</td>\\n\" ) ;\n printf ( \"<td align='center'><input type='checkbox' name='hostservice' id=\\\"cb_%d\\\" value='%s^%s' title=\\\"%s Service\\\" %s></td></tr>\\n\" , x , escape_string ( commands [ x ] . host_name ) , escape_string ( commands [ x ] . description ) , ( service_passive == FALSE ) ? \"Active\" : \"Passive\" , ( service_passive == FALSE ) ? \"checked\" : \"\" ) ;\n }\n else {\n if ( ! strcmp ( commands [ x ] . host_name , \"\" ) ) printf ( \"><INPUT TYPE='TEXT' NAME='host' SIZE=30></td>\" ) ;\n else printf ( \"><INPUT TYPE='HIDDEN' NAME='host' VALUE='%s'>%s</td>\" , escape_string ( commands [ x ] . host_name ) , escape_string ( commands [ x ] . host_name ) ) ;\n if ( ! strcmp ( commands [ x ] . description , \"\" ) ) printf ( \"<td><INPUT TYPE='TEXT' NAME='service' SIZE=30></td>\" ) ;\n else printf ( \"<td><INPUT TYPE='HIDDEN' NAME='service' VALUE='%s'>%s</td>\" , escape_string ( commands [ x ] . description ) , escape_string ( commands [ x ] . description ) ) ;\n printf ( \"<td></td></tr>\\n\" ) ;\n }\n }\n else if ( list_type == PRINT_HOST_LIST ) {\n if ( ! strcmp ( commands [ x ] . host_name , \"\" ) ) printf ( \" style=\\\"font-weight:bold;\n\\\">Host:</td><td><INPUT TYPE='TEXT' NAME='host' SIZE=30></td><td></td></tr>\\n\" ) ;\n else {\n printf ( \" style=\\\"font-weight:bold;\n\\\">Host:</td><td>%s\" , escape_string ( commands [ x ] . host_name ) ) ;\n if ( host_passive == TRUE ) {\n printf ( \"<img src='%s%s' align=right border=0 style='padding-right:2px' alt='Passive' title='Passive Service'>\" , url_images_path , PASSIVE_ICON ) ;\n }\n printf ( \"</td>\\n\" ) ;\n printf ( \"<td align='center'><input type='checkbox' name='host' id=\\\"cb_%d\\\" value='%s' title=\\\"%s Host\\\" %s></td></tr>\\n\" , x , escape_string ( commands [ x ] . host_name ) , ( host_passive == FALSE ) ? \"Active\" : \"Passive\" , ( host_passive == FALSE ) ? \"checked\" : \"\" ) ;\n }\n }\n else if ( list_type == PRINT_COMMENT_LIST ) {\n printf ( \" style=\\\"font-weight:bold;\n\\\">Comment ID:</td><td><INPUT TYPE='HIDDEN' NAME='com_id' VALUE='%lu'>%lu</td></tr>\\n\" , multi_ids [ x ] , multi_ids [ x ] ) ;\n }\n else if ( list_type == PRINT_DOWNTIME_LIST ) {\n printf ( \" style=\\\"font-weight:bold;\n\\\">Scheduled Downtime ID:</td><td><INPUT TYPE='HIDDEN' NAME='down_id' VALUE='%lu'>%lu</td></tr>\\n\" , multi_ids [ x ] , multi_ids [ x ] ) ;\n }\n }\n printf ( \"</td><tr></table>\\n</td></tr>\\n\" ) ;\n return ;\n }", "idx": 1189}
{"hash": 2578089348587614328, "project": "debian", "size": 3, "label": 0, "functionSource": "RSA * d2i_RSA_PUBKEY_fp ( FILE * fp , RSA * * rsa ) {\n return ASN1_d2i_fp ( ( void * ( * ) ( void ) ) RSA_new , ( D2I_OF ( void ) ) d2i_RSA_PUBKEY , fp , ( void * * ) rsa ) ;\n }", "idx": 1190}
{"hash": -3383030848920666759, "project": "debian", "size": 32, "label": 1, "functionSource": "struct login_settings * login_settings_read ( pool_t pool , const struct ip_addr * local_ip , const struct ip_addr * remote_ip , const char * local_name , const struct master_service_ssl_settings * * ssl_set_r , void * * * other_settings_r ) {\n struct master_service_settings_input input ;\n const char * error ;\n const struct setting_parser_context * parser ;\n void * const * cache_sets ;\n void * * sets ;\n unsigned int i , count ;\n i_zero ( & input ) ;\n input . roots = login_set_roots ;\n input . module = login_binary -> process_name ;\n input . service = login_binary -> protocol ;\n input . local_name = local_name ;\n if ( local_ip != NULL ) input . local_ip = * local_ip ;\n if ( remote_ip != NULL ) input . remote_ip = * remote_ip ;\n if ( set_cache == NULL ) {\n set_cache = master_service_settings_cache_init ( master_service , input . module , input . service ) ;\n }\n if ( master_service_settings_cache_read ( set_cache , & input , NULL , & parser , & error ) < 0 ) i_fatal ( \"Error reading configuration: %s\" , error ) ;\n cache_sets = master_service_settings_parser_get_others ( master_service , parser ) ;\n for ( count = 0 ;\n input . roots [ count ] != NULL ;\n count ++ ) ;\n i_assert ( cache_sets [ count ] == NULL ) ;\n sets = p_new ( pool , void * , count + 1 ) ;\n for ( i = 0 ;\n i < count ;\n i ++ ) sets [ i ] = login_setting_dup ( pool , input . roots [ i ] , cache_sets [ i ] ) ;\n settings_var_expand ( & login_setting_parser_info , sets [ 0 ] , pool , login_set_var_expand_table ( & input ) ) ;\n * ssl_set_r = login_setting_dup ( pool , & master_service_ssl_setting_parser_info , settings_parser_get_list ( parser ) [ 1 ] ) ;\n * other_settings_r = sets + 1 ;\n return sets [ 0 ] ;\n }", "idx": 1191}
{"hash": -3165961362620712443, "project": "chrome", "size": 17, "label": 1, "functionSource": "static void final_reordering ( const hb_ot_shape_plan_t * plan , hb_font_t * font HB_UNUSED , hb_buffer_t * buffer ) {\n unsigned int count = buffer -> len ;\n if ( unlikely ( ! count ) ) return ;\n hb_glyph_info_t * info = buffer -> info ;\n unsigned int last = 0 ;\n unsigned int last_syllable = info [ 0 ] . syllable ( ) ;\n for ( unsigned int i = 1 ;\n i < count ;\n i ++ ) if ( last_syllable != info [ i ] . syllable ( ) ) {\n final_reordering_syllable ( plan , buffer , last , i ) ;\n last = i ;\n last_syllable = info [ last ] . syllable ( ) ;\n }\n final_reordering_syllable ( plan , buffer , last , count ) ;\n HB_BUFFER_DEALLOCATE_VAR ( buffer , indic_category ) ;\n HB_BUFFER_DEALLOCATE_VAR ( buffer , indic_position ) ;\n }", "idx": 1192}
{"hash": 1202634027547122397, "project": "debian", "size": 11, "label": 0, "functionSource": "static size_t kex_method_strlen ( LIBSSH2_COMMON_METHOD * * method ) {\n size_t len = 0 ;\n if ( ! method || ! * method ) {\n return 0 ;\n }\n while ( * method && ( * method ) -> name ) {\n len += strlen ( ( * method ) -> name ) + 1 ;\n method ++ ;\n }\n return len - 1 ;\n }", "idx": 1193}
{"hash": 6458694302493204858, "project": "debian", "size": 5, "label": 0, "functionSource": "static void ShutdownTupleDescRef ( Datum arg ) {\n TupleDesc * cache_field = ( TupleDesc * ) DatumGetPointer ( arg ) ;\n if ( * cache_field ) ReleaseTupleDesc ( * cache_field ) ;\n * cache_field = NULL ;\n }", "idx": 1194}
{"hash": 2666714143406757810, "project": "debian", "size": 127, "label": 0, "functionSource": "void proto_register_adb ( void ) {\n module_t * module ;\n expert_module_t * expert_module ;\n static hf_register_info hf [ ] = {\n {\n & hf_command , {\n \"Command\" , \"adb.command\" , FT_UINT32 , BASE_HEX , VALS ( command_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_argument_0 , {\n \"Argument 0\" , \"adb.argument.0\" , FT_UINT32 , BASE_HEX , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_argument_1 , {\n \"Argument 0\" , \"adb.argument.1\" , FT_UINT32 , BASE_HEX , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_data_length , {\n \"Data Length\" , \"adb.data_length\" , FT_UINT32 , BASE_DEC , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_data_crc32 , {\n \"Data CRC32\" , \"adb.data_crc32\" , FT_UINT32 , BASE_HEX , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_magic , {\n \"Magic\" , \"adb.magic\" , FT_UINT32 , BASE_HEX , VALS ( magic_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_version , {\n \"Version\" , \"adb.version\" , FT_UINT32 , BASE_HEX , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_max_data , {\n \"Max Data\" , \"adb.max_data\" , FT_UINT32 , BASE_DEC , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_auth_type , {\n \"Type\" , \"adb.auth_type\" , FT_UINT32 , BASE_HEX , VALS ( auth_type_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_online , {\n \"Online\" , \"adb.online\" , FT_BOOLEAN , 32 , TFS ( & tfs_no_yes ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_sequence , {\n \"Sequence\" , \"adb.sequence\" , FT_UINT32 , BASE_DEC , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_zero , {\n \"Zero\" , \"adb.zero\" , FT_UINT32 , BASE_HEX , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_local_id , {\n \"Local ID\" , \"adb.local_id\" , FT_UINT32 , BASE_DEC , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_remote_id , {\n \"Remote ID\" , \"adb.remote_id\" , FT_UINT32 , BASE_DEC , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_data , {\n \"Data\" , \"adb.data\" , FT_NONE , BASE_NONE , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_service , {\n \"Service\" , \"adb.service\" , FT_STRING , BASE_NONE , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_data_fragment , {\n \"Data Fragment\" , \"adb.data_fragment\" , FT_NONE , BASE_NONE , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_service_start_in_frame , {\n \"Service Start in Frame\" , \"adb.service_start_in_frame\" , FT_FRAMENUM , BASE_NONE , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_close_local_in_frame , {\n \"Local Service Close in Frame\" , \"adb.close_local_in_frame\" , FT_FRAMENUM , BASE_NONE , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_close_remote_in_frame , {\n \"Remote Service Close in Frame\" , \"adb.close_remote_in_frame\" , FT_FRAMENUM , BASE_NONE , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_command_in_frame , {\n \"Command in Frame\" , \"adb.command_in_frame\" , FT_FRAMENUM , BASE_NONE , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_completed_in_frame , {\n \"Completed in Frame\" , \"adb.completed_in_frame\" , FT_FRAMENUM , BASE_NONE , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_connection_info , {\n \"Info\" , \"adb.connection_info\" , FT_STRINGZ , STR_ASCII , NULL , 0x00 , NULL , HFILL }\n }\n }\n ;\n static gint * ett [ ] = {\n & ett_adb , & ett_adb_arg0 , & ett_adb_arg1 , & ett_adb_crc , & ett_adb_magic }\n ;\n static ei_register_info ei [ ] = {\n {\n & ei_invalid_magic , {\n \"adb.expert.invalid_magic\" , PI_PROTOCOL , PI_WARN , \"Invalid Magic\" , EXPFILL }\n }\n , {\n & ei_invalid_crc , {\n \"adb.expert.crc_error\" , PI_PROTOCOL , PI_ERROR , \"CRC32 Error\" , EXPFILL }\n }\n , {\n & ei_invalid_data , {\n \"adb.expert.data_error\" , PI_PROTOCOL , PI_ERROR , \"Mismatch between message payload size and data length\" , EXPFILL }\n }\n , }\n ;\n command_info = wmem_tree_new_autoreset ( wmem_epan_scope ( ) , wmem_file_scope ( ) ) ;\n service_info = wmem_tree_new_autoreset ( wmem_epan_scope ( ) , wmem_file_scope ( ) ) ;\n proto_adb = proto_register_protocol ( \"Android Debug Bridge\" , \"ADB\" , \"adb\" ) ;\n adb_handle = register_dissector ( \"adb\" , dissect_adb , proto_adb ) ;\n proto_register_field_array ( proto_adb , hf , array_length ( hf ) ) ;\n proto_register_subtree_array ( ett , array_length ( ett ) ) ;\n expert_module = expert_register_protocol ( proto_adb ) ;\n expert_register_field_array ( expert_module , ei , array_length ( ei ) ) ;\n module = prefs_register_protocol ( proto_adb , NULL ) ;\n prefs_register_static_text_preference ( module , \"version\" , \"ADB protocol version is compatible prior to: adb 1.0.31\" , \"Version of protocol supported by this dissector.\" ) ;\n }", "idx": 1195}
{"hash": -4299048894522449432, "project": "debian", "size": 55, "label": 0, "functionSource": "static void imc_calculate_coeffs ( IMCContext * q , float * flcoeffs1 , float * flcoeffs2 , int * bandWidthT , float * flcoeffs3 , float * flcoeffs5 ) {\n float workT1 [ BANDS ] ;\n float workT2 [ BANDS ] ;\n float workT3 [ BANDS ] ;\n float snr_limit = 1.e-30 ;\n float accum = 0.0 ;\n int i , cnt2 ;\n for ( i = 0 ;\n i < BANDS ;\n i ++ ) {\n flcoeffs5 [ i ] = workT2 [ i ] = 0.0 ;\n if ( bandWidthT [ i ] ) {\n workT1 [ i ] = flcoeffs1 [ i ] * flcoeffs1 [ i ] ;\n flcoeffs3 [ i ] = 2.0 * flcoeffs2 [ i ] ;\n }\n else {\n workT1 [ i ] = 0.0 ;\n flcoeffs3 [ i ] = - 30000.0 ;\n }\n workT3 [ i ] = bandWidthT [ i ] * workT1 [ i ] * 0.01 ;\n if ( workT3 [ i ] <= snr_limit ) workT3 [ i ] = 0.0 ;\n }\n for ( i = 0 ;\n i < BANDS ;\n i ++ ) {\n for ( cnt2 = i ;\n cnt2 < q -> cyclTab [ i ] ;\n cnt2 ++ ) flcoeffs5 [ cnt2 ] = flcoeffs5 [ cnt2 ] + workT3 [ i ] ;\n workT2 [ cnt2 - 1 ] = workT2 [ cnt2 - 1 ] + workT3 [ i ] ;\n }\n for ( i = 1 ;\n i < BANDS ;\n i ++ ) {\n accum = ( workT2 [ i - 1 ] + accum ) * q -> weights1 [ i - 1 ] ;\n flcoeffs5 [ i ] += accum ;\n }\n for ( i = 0 ;\n i < BANDS ;\n i ++ ) workT2 [ i ] = 0.0 ;\n for ( i = 0 ;\n i < BANDS ;\n i ++ ) {\n for ( cnt2 = i - 1 ;\n cnt2 > q -> cyclTab2 [ i ] ;\n cnt2 -- ) flcoeffs5 [ cnt2 ] += workT3 [ i ] ;\n workT2 [ cnt2 + 1 ] += workT3 [ i ] ;\n }\n accum = 0.0 ;\n for ( i = BANDS - 2 ;\n i >= 0 ;\n i -- ) {\n accum = ( workT2 [ i + 1 ] + accum ) * q -> weights2 [ i ] ;\n flcoeffs5 [ i ] += accum ;\n }\n }", "idx": 1196}
{"hash": 4180964683905830761, "project": "debian", "size": 9, "label": 0, "functionSource": "static void selinux_task_to_inode ( struct task_struct * p , struct inode * inode ) {\n struct inode_security_struct * isec = inode -> i_security ;\n u32 sid = task_sid ( p ) ;\n spin_lock ( & isec -> lock ) ;\n isec -> sclass = inode_mode_to_security_class ( inode -> i_mode ) ;\n isec -> sid = sid ;\n isec -> initialized = LABEL_INITIALIZED ;\n spin_unlock ( & isec -> lock ) ;\n }", "idx": 1197}
{"hash": 6675626110148442062, "project": "debian", "size": 10, "label": 0, "functionSource": "static int file_close ( jas_stream_obj_t * obj ) {\n jas_stream_fileobj_t * fileobj = JAS_CAST ( jas_stream_fileobj_t * , obj ) ;\n int ret ;\n ret = close ( fileobj -> fd ) ;\n if ( fileobj -> flags & JAS_STREAM_FILEOBJ_DELONCLOSE ) {\n unlink ( fileobj -> pathname ) ;\n }\n jas_free ( fileobj ) ;\n return ret ;\n }", "idx": 1198}
{"hash": -704025756752474526, "project": "debian", "size": 14, "label": 0, "functionSource": "void PNGAPI png_set_gAMA ( png_structp png_ptr , png_infop info_ptr , double file_gamma ) {\n double png_gamma ;\n png_debug1 ( 1 , \"in %s storage function\" , \"gAMA\" ) ;\n if ( png_ptr == NULL || info_ptr == NULL ) return ;\n if ( file_gamma > 21474.83 ) {\n png_warning ( png_ptr , \"Limiting gamma to 21474.83\" ) ;\n png_gamma = 21474.83 ;\n }\n else png_gamma = file_gamma ;\n info_ptr -> gamma = ( float ) png_gamma ;\n # ifdef PNG_FIXED_POINT_SUPPORTED info_ptr -> int_gamma = ( int ) ( png_gamma * 100000. + .5 ) ;\n # endif info_ptr -> valid |= PNG_INFO_gAMA ;\n if ( png_gamma == 0.0 ) png_warning ( png_ptr , \"Setting gamma=0\" ) ;\n }", "idx": 1199}
{"hash": 313627013719508831, "project": "debian", "size": 3, "label": 0, "functionSource": "static inline void SetPixelCb ( const Image * restrict image , const Quantum cb , Quantum * restrict pixel ) {\n pixel [ image -> channel_map [ CbPixelChannel ] . offset ] = cb ;\n }", "idx": 1200}
{"hash": 4952739496652083313, "project": "chrome", "size": 4, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( MediaStreamPermissionTest , TestDenyingUserMedia ) {\n content : : WebContents * tab_contents = LoadTestPageInTab ( ) ;\n GetUserMediaAndDeny ( tab_contents ) ;\n }", "idx": 1201}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_T_subPictureRemovalParameters ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_T_subPictureRemovalParameters , T_subPictureRemovalParameters_sequence ) ;\n return offset ;\n }", "idx": 1202}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_MultiplePayloadStream ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_MultiplePayloadStream , MultiplePayloadStream_sequence ) ;\n return offset ;\n }", "idx": 1203}
{"hash": 3599206110384554647, "project": "debian", "size": 92, "label": 0, "functionSource": "void name ## _free ( type * a ) ;\n # define DECLARE_ASN1_PRINT_FUNCTION ( stname ) DECLARE_ASN1_PRINT_FUNCTION_fname ( stname , stname ) # define DECLARE_ASN1_PRINT_FUNCTION_fname ( stname , fname ) int fname ## _print_ctx ( BIO * out , stname * x , int indent , const ASN1_PCTX * pctx ) ;\n # define D2I_OF ( type ) type * ( * ) ( type * * , const unsigned char * * , long ) # define I2D_OF ( type ) int ( * ) ( type * , unsigned char * * ) # define I2D_OF_const ( type ) int ( * ) ( const type * , unsigned char * * ) # define CHECKED_D2I_OF ( type , d2i ) ( ( d2i_of_void * ) ( 1 ? d2i : ( ( D2I_OF ( type ) ) 0 ) ) ) # define CHECKED_I2D_OF ( type , i2d ) ( ( i2d_of_void * ) ( 1 ? i2d : ( ( I2D_OF ( type ) ) 0 ) ) ) # define CHECKED_NEW_OF ( type , xnew ) ( ( void * ( * ) ( void ) ) ( 1 ? xnew : ( ( type * ( * ) ( void ) ) 0 ) ) ) # define CHECKED_PTR_OF ( type , p ) ( ( void * ) ( 1 ? p : ( type * ) 0 ) ) # define CHECKED_PPTR_OF ( type , p ) ( ( void * * ) ( 1 ? p : ( type * * ) 0 ) ) # define TYPEDEF_D2I_OF ( type ) typedef type * d2i_of_ ## type ( type * * , const unsigned char * * , long ) # define TYPEDEF_I2D_OF ( type ) typedef int i2d_of_ ## type ( type * , unsigned char * * ) # define TYPEDEF_D2I2D_OF ( type ) TYPEDEF_D2I_OF ( type ) ;\n TYPEDEF_I2D_OF ( type ) TYPEDEF_D2I2D_OF ( void ) ;\n # ifndef OPENSSL_EXPORT_VAR_AS_FUNCTION typedef const ASN1_ITEM ASN1_ITEM_EXP ;\n # define ASN1_ITEM_ptr ( iptr ) ( iptr ) # define ASN1_ITEM_ref ( iptr ) ( & ( iptr ## _it ) ) # define ASN1_ITEM_rptr ( ref ) ( & ( ref ## _it ) ) # define DECLARE_ASN1_ITEM ( name ) OPENSSL_EXTERN const ASN1_ITEM name ## _it ;\n # else typedef const ASN1_ITEM * ASN1_ITEM_EXP ( void ) ;\n # define ASN1_ITEM_ptr ( iptr ) ( iptr ( ) ) # define ASN1_ITEM_ref ( iptr ) ( iptr ## _it ) # define ASN1_ITEM_rptr ( ref ) ( ref ## _it ( ) ) # define DECLARE_ASN1_ITEM ( name ) const ASN1_ITEM * name ## _it ( void ) ;\n # endif # define ASN1_STRFLGS_ESC_2253 1 # define ASN1_STRFLGS_ESC_CTRL 2 # define ASN1_STRFLGS_ESC_MSB 4 # define ASN1_STRFLGS_ESC_QUOTE 8 # define CHARTYPE_PRINTABLESTRING 0x10 # define CHARTYPE_FIRST_ESC_2253 0x20 # define CHARTYPE_LAST_ESC_2253 0x40 # define ASN1_STRFLGS_UTF8_CONVERT 0x10 # define ASN1_STRFLGS_IGNORE_TYPE 0x20 # define ASN1_STRFLGS_SHOW_TYPE 0x40 # define ASN1_STRFLGS_DUMP_ALL 0x80 # define ASN1_STRFLGS_DUMP_UNKNOWN 0x100 # define ASN1_STRFLGS_DUMP_DER 0x200 # define ASN1_STRFLGS_ESC_2254 0x400 # define ASN1_STRFLGS_RFC2253 ( ASN1_STRFLGS_ESC_2253 | ASN1_STRFLGS_ESC_CTRL | ASN1_STRFLGS_ESC_MSB | ASN1_STRFLGS_UTF8_CONVERT | ASN1_STRFLGS_DUMP_UNKNOWN | ASN1_STRFLGS_DUMP_DER ) DEFINE_STACK_OF ( ASN1_INTEGER ) DEFINE_STACK_OF ( ASN1_GENERALSTRING ) DEFINE_STACK_OF ( ASN1_UTF8STRING ) typedef struct asn1_type_st {\n int type ;\n union {\n char * ptr ;\n ASN1_BOOLEAN boolean ;\n ASN1_STRING * asn1_string ;\n ASN1_OBJECT * object ;\n ASN1_INTEGER * integer ;\n ASN1_ENUMERATED * enumerated ;\n ASN1_BIT_STRING * bit_string ;\n ASN1_OCTET_STRING * octet_string ;\n ASN1_PRINTABLESTRING * printablestring ;\n ASN1_T61STRING * t61string ;\n ASN1_IA5STRING * ia5string ;\n ASN1_GENERALSTRING * generalstring ;\n ASN1_BMPSTRING * bmpstring ;\n ASN1_UNIVERSALSTRING * universalstring ;\n ASN1_UTCTIME * utctime ;\n ASN1_GENERALIZEDTIME * generalizedtime ;\n ASN1_VISIBLESTRING * visiblestring ;\n ASN1_UTF8STRING * utf8string ;\n ASN1_STRING * set ;\n ASN1_STRING * sequence ;\n ASN1_VALUE * asn1_value ;\n }\n value ;\n }\n ASN1_TYPE ;\n DEFINE_STACK_OF ( ASN1_TYPE ) typedef STACK_OF ( ASN1_TYPE ) ASN1_SEQUENCE_ANY ;\n DECLARE_ASN1_ENCODE_FUNCTIONS_const ( ASN1_SEQUENCE_ANY , ASN1_SEQUENCE_ANY ) DECLARE_ASN1_ENCODE_FUNCTIONS_const ( ASN1_SEQUENCE_ANY , ASN1_SET_ANY ) typedef struct BIT_STRING_BITNAME_st {\n int bitnum ;\n const char * lname ;\n const char * sname ;\n }\n BIT_STRING_BITNAME ;\n # define B_ASN1_TIME B_ASN1_UTCTIME | B_ASN1_GENERALIZEDTIME # define B_ASN1_PRINTABLE B_ASN1_NUMERICSTRING | B_ASN1_PRINTABLESTRING | B_ASN1_T61STRING | B_ASN1_IA5STRING | B_ASN1_BIT_STRING | B_ASN1_UNIVERSALSTRING | B_ASN1_BMPSTRING | B_ASN1_UTF8STRING | B_ASN1_SEQUENCE | B_ASN1_UNKNOWN # define B_ASN1_DIRECTORYSTRING B_ASN1_PRINTABLESTRING | B_ASN1_TELETEXSTRING | B_ASN1_BMPSTRING | B_ASN1_UNIVERSALSTRING | B_ASN1_UTF8STRING # define B_ASN1_DISPLAYTEXT B_ASN1_IA5STRING | B_ASN1_VISIBLESTRING | B_ASN1_BMPSTRING | B_ASN1_UTF8STRING DECLARE_ASN1_FUNCTIONS_fname ( ASN1_TYPE , ASN1_ANY , ASN1_TYPE ) int ASN1_TYPE_get ( const ASN1_TYPE * a ) ;\n void ASN1_TYPE_set ( ASN1_TYPE * a , int type , void * value ) ;\n int ASN1_TYPE_set1 ( ASN1_TYPE * a , int type , const void * value ) ;\n int ASN1_TYPE_cmp ( const ASN1_TYPE * a , const ASN1_TYPE * b ) ;\n ASN1_TYPE * ASN1_TYPE_pack_sequence ( const ASN1_ITEM * it , void * s , ASN1_TYPE * * t ) ;\n void * ASN1_TYPE_unpack_sequence ( const ASN1_ITEM * it , const ASN1_TYPE * t ) ;\n ASN1_OBJECT * ASN1_OBJECT_new ( void ) ;\n void ASN1_OBJECT_free ( ASN1_OBJECT * a ) ;\n int i2d_ASN1_OBJECT ( const ASN1_OBJECT * a , unsigned char * * pp ) ;\n ASN1_OBJECT * d2i_ASN1_OBJECT ( ASN1_OBJECT * * a , const unsigned char * * pp , long length ) ;\n DECLARE_ASN1_ITEM ( ASN1_OBJECT ) DEFINE_STACK_OF ( ASN1_OBJECT ) ASN1_STRING * ASN1_STRING_new ( void ) ;\n void ASN1_STRING_free ( ASN1_STRING * a ) ;\n void ASN1_STRING_clear_free ( ASN1_STRING * a ) ;\n int ASN1_STRING_copy ( ASN1_STRING * dst , const ASN1_STRING * str ) ;\n ASN1_STRING * ASN1_STRING_dup ( const ASN1_STRING * a ) ;\n ASN1_STRING * ASN1_STRING_type_new ( int type ) ;\n int ASN1_STRING_cmp ( const ASN1_STRING * a , const ASN1_STRING * b ) ;\n int ASN1_STRING_set ( ASN1_STRING * str , const void * data , int len ) ;\n void ASN1_STRING_set0 ( ASN1_STRING * str , void * data , int len ) ;\n int ASN1_STRING_length ( const ASN1_STRING * x ) ;\n void ASN1_STRING_length_set ( ASN1_STRING * x , int n ) ;\n int ASN1_STRING_type ( const ASN1_STRING * x ) ;\n DEPRECATEDIN_1_1_0 ( unsigned char * ASN1_STRING_data ( ASN1_STRING * x ) ) const unsigned char * ASN1_STRING_get0_data ( const ASN1_STRING * x ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_BIT_STRING ) int ASN1_BIT_STRING_set ( ASN1_BIT_STRING * a , unsigned char * d , int length ) ;\n int ASN1_BIT_STRING_set_bit ( ASN1_BIT_STRING * a , int n , int value ) ;\n int ASN1_BIT_STRING_get_bit ( const ASN1_BIT_STRING * a , int n ) ;\n int ASN1_BIT_STRING_check ( const ASN1_BIT_STRING * a , const unsigned char * flags , int flags_len ) ;\n int ASN1_BIT_STRING_name_print ( BIO * out , ASN1_BIT_STRING * bs , BIT_STRING_BITNAME * tbl , int indent ) ;\n int ASN1_BIT_STRING_num_asc ( const char * name , BIT_STRING_BITNAME * tbl ) ;\n int ASN1_BIT_STRING_set_asc ( ASN1_BIT_STRING * bs , const char * name , int value , BIT_STRING_BITNAME * tbl ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_INTEGER ) ASN1_INTEGER * d2i_ASN1_UINTEGER ( ASN1_INTEGER * * a , const unsigned char * * pp , long length ) ;\n ASN1_INTEGER * ASN1_INTEGER_dup ( const ASN1_INTEGER * x ) ;\n int ASN1_INTEGER_cmp ( const ASN1_INTEGER * x , const ASN1_INTEGER * y ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_ENUMERATED ) int ASN1_UTCTIME_check ( const ASN1_UTCTIME * a ) ;\n ASN1_UTCTIME * ASN1_UTCTIME_set ( ASN1_UTCTIME * s , time_t t ) ;\n ASN1_UTCTIME * ASN1_UTCTIME_adj ( ASN1_UTCTIME * s , time_t t , int offset_day , long offset_sec ) ;\n int ASN1_UTCTIME_set_string ( ASN1_UTCTIME * s , const char * str ) ;\n int ASN1_UTCTIME_cmp_time_t ( const ASN1_UTCTIME * s , time_t t ) ;\n int ASN1_GENERALIZEDTIME_check ( const ASN1_GENERALIZEDTIME * a ) ;\n ASN1_GENERALIZEDTIME * ASN1_GENERALIZEDTIME_set ( ASN1_GENERALIZEDTIME * s , time_t t ) ;\n ASN1_GENERALIZEDTIME * ASN1_GENERALIZEDTIME_adj ( ASN1_GENERALIZEDTIME * s , time_t t , int offset_day , long offset_sec ) ;\n int ASN1_GENERALIZEDTIME_set_string ( ASN1_GENERALIZEDTIME * s , const char * str ) ;\n int ASN1_TIME_diff ( int * pday , int * psec , const ASN1_TIME * from , const ASN1_TIME * to ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_OCTET_STRING ) ASN1_OCTET_STRING * ASN1_OCTET_STRING_dup ( const ASN1_OCTET_STRING * a ) ;\n int ASN1_OCTET_STRING_cmp ( const ASN1_OCTET_STRING * a , const ASN1_OCTET_STRING * b ) ;\n int ASN1_OCTET_STRING_set ( ASN1_OCTET_STRING * str , const unsigned char * data , int len ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_VISIBLESTRING ) DECLARE_ASN1_FUNCTIONS ( ASN1_UNIVERSALSTRING ) DECLARE_ASN1_FUNCTIONS ( ASN1_UTF8STRING ) DECLARE_ASN1_FUNCTIONS ( ASN1_NULL ) DECLARE_ASN1_FUNCTIONS ( ASN1_BMPSTRING ) int UTF8_getc ( const unsigned char * str , int len , unsigned long * val ) ;\n int UTF8_putc ( unsigned char * str , int len , unsigned long value ) ;\n DECLARE_ASN1_FUNCTIONS_name ( ASN1_STRING , ASN1_PRINTABLE ) DECLARE_ASN1_FUNCTIONS_name ( ASN1_STRING , DIRECTORYSTRING ) DECLARE_ASN1_FUNCTIONS_name ( ASN1_STRING , DISPLAYTEXT )", "idx": 1204}
{"hash": -6552851419396579257, "project": "debian", "size": 9, "label": 0, "functionSource": "static int SpoolssStartDocPrinter_q ( tvbuff_t * tvb , int offset , packet_info * pinfo , proto_tree * tree , dcerpc_info * di , guint8 * drep ) {\n e_ctx_hnd policy_hnd ;\n char * pol_name ;\n offset = dissect_nt_policy_hnd ( tvb , offset , pinfo , tree , di , drep , hf_hnd , & policy_hnd , NULL , FALSE , FALSE ) ;\n dcerpc_fetch_polhnd_data ( & policy_hnd , & pol_name , NULL , NULL , NULL , pinfo -> num ) ;\n if ( pol_name ) col_append_fstr ( pinfo -> cinfo , COL_INFO , \", %s\" , pol_name ) ;\n offset = dissect_spoolss_doc_info_ctr ( tvb , offset , pinfo , tree , di , drep ) ;\n return offset ;\n }", "idx": 1205}
{"hash": -8934524072451888241, "project": "debian", "size": 5, "label": 0, "functionSource": "inline static void update_current_info ( HttpTransact : : CurrentInfo * into , HttpTransact : : ConnectionAttributes * from , HttpTransact : : LookingUp_t who , int attempts ) {\n into -> request_to = who ;\n into -> server = from ;\n into -> attempts = attempts ;\n }", "idx": 1206}
{"hash": -6552851419396579257, "project": "debian", "size": 19, "label": 0, "functionSource": "static int dissect_spoolss_string_parm_data ( tvbuff_t * tvb , int offset , packet_info * pinfo , proto_tree * tree , dcerpc_info * di , guint8 * drep ) {\n guint32 buffer_len , len ;\n gchar * s ;\n proto_item * item = NULL ;\n if ( di -> conformant_run ) return offset ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , tree , di , drep , hf_string_parm_size , & buffer_len ) ;\n s = tvb_get_stringz_enc ( wmem_packet_scope ( ) , tvb , offset , & len , ENC_UTF_16 | ENC_LITTLE_ENDIAN ) ;\n if ( tree && buffer_len ) {\n tvb_ensure_bytes_exist ( tvb , offset , buffer_len ) ;\n item = proto_tree_add_string ( tree , hf_string_parm_data , tvb , offset , len , s ) ;\n }\n offset += buffer_len ;\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \", %s\" , s ) ;\n if ( tree && item ) {\n item = item -> parent != NULL ? item -> parent : item ;\n proto_item_append_text ( item , \": %s\" , s ) ;\n }\n return offset ;\n }", "idx": 1207}
{"hash": 5357882892791796049, "project": "debian", "size": 4, "label": 0, "functionSource": "static inline void e1000e_link_down ( E1000ECore * core ) {\n e1000x_update_regs_on_link_down ( core -> mac , core -> phy [ 0 ] ) ;\n e1000e_update_flowctl_status ( core ) ;\n }", "idx": 1208}
{"hash": 8193534372312945122, "project": "debian", "size": 29, "label": 0, "functionSource": "static int pcnet_tdte_poll ( PCNetState * s ) {\n s -> csr [ 34 ] = s -> csr [ 35 ] = 0 ;\n if ( s -> tdra ) {\n hwaddr cxda = s -> tdra + ( CSR_XMTRL ( s ) - CSR_XMTRC ( s ) ) * ( BCR_SWSTYLE ( s ) ? 16 : 8 ) ;\n int bad = 0 ;\n CHECK_TMD ( cxda , bad ) ;\n if ( ! bad ) {\n if ( CSR_CXDA ( s ) != cxda ) {\n s -> csr [ 60 ] = s -> csr [ 34 ] ;\n s -> csr [ 61 ] = s -> csr [ 35 ] ;\n s -> csr [ 62 ] = CSR_CXBC ( s ) ;\n s -> csr [ 63 ] = CSR_CXST ( s ) ;\n }\n s -> csr [ 34 ] = cxda & 0xffff ;\n s -> csr [ 35 ] = cxda >> 16 ;\n # ifdef PCNET_DEBUG_X printf ( \"pcnet: BAD TMD XDA=0x%08x\\n\" , cxda ) ;\n # endif }\n }\n if ( CSR_CXDA ( s ) ) {\n struct pcnet_TMD tmd ;\n TMDLOAD ( & tmd , PHYSADDR ( s , CSR_CXDA ( s ) ) ) ;\n CSR_CXBC ( s ) = GET_FIELD ( tmd . length , TMDL , BCNT ) ;\n CSR_CXST ( s ) = tmd . status ;\n }\n else {\n CSR_CXBC ( s ) = CSR_CXST ( s ) = 0 ;\n }\n return ! ! ( CSR_CXST ( s ) & 0x8000 ) ;\n }", "idx": 1209}
{"hash": -7775977291865552483, "project": "debian", "size": 5, "label": 0, "functionSource": "char * qemuDomainGetMasterKeyAlias ( void ) {\n char * alias ;\n ignore_value ( VIR_STRDUP ( alias , \"masterKey0\" ) ) ;\n return alias ;\n }", "idx": 1210}
{"hash": 1182028467273264883, "project": "debian", "size": 15, "label": 0, "functionSource": "static void init_signal_handling ( void ) {\n struct sigaction sa ;\n DBUG_ENTER ( \"init_signal_handling\" ) ;\n # ifdef HAVE_STACKTRACE my_init_stacktrace ( ) ;\n # endif sa . sa_flags = SA_RESETHAND | SA_NODEFER ;\n sigemptyset ( & sa . sa_mask ) ;\n sigprocmask ( SIG_SETMASK , & sa . sa_mask , NULL ) ;\n sa . sa_handler = signal_handler ;\n sigaction ( SIGSEGV , & sa , NULL ) ;\n sigaction ( SIGABRT , & sa , NULL ) ;\n # ifdef SIGBUS sigaction ( SIGBUS , & sa , NULL ) ;\n # endif sigaction ( SIGILL , & sa , NULL ) ;\n sigaction ( SIGFPE , & sa , NULL ) ;\n DBUG_VOID_RETURN ;\n }", "idx": 1211}
{"hash": 3887066622454352196, "project": "chrome", "size": 51, "label": 1, "functionSource": "static int64_t encode_inter_mb_segment ( VP9_COMP * cpi , MACROBLOCK * x , int64_t best_yrd , int i , int * labelyrate , int64_t * distortion , int64_t * sse , ENTROPY_CONTEXT * ta , ENTROPY_CONTEXT * tl , int mi_row , int mi_col ) {\n int k ;\n MACROBLOCKD * xd = & x -> e_mbd ;\n struct macroblockd_plane * const pd = & xd -> plane [ 0 ] ;\n struct macroblock_plane * const p = & x -> plane [ 0 ] ;\n MODE_INFO * const mi = xd -> mi [ 0 ] ;\n const BLOCK_SIZE plane_bsize = get_plane_block_size ( mi -> mbmi . sb_type , pd ) ;\n const int width = 4 * num_4x4_blocks_wide_lookup [ plane_bsize ] ;\n const int height = 4 * num_4x4_blocks_high_lookup [ plane_bsize ] ;\n int idx , idy ;\n const uint8_t * const src = & p -> src . buf [ raster_block_offset ( BLOCK_8X8 , i , p -> src . stride ) ] ;\n uint8_t * const dst = & pd -> dst . buf [ raster_block_offset ( BLOCK_8X8 , i , pd -> dst . stride ) ] ;\n int64_t thisdistortion = 0 , thissse = 0 ;\n int thisrate = 0 , ref ;\n const scan_order * so = & vp9_default_scan_orders [ TX_4X4 ] ;\n const int is_compound = has_second_ref ( & mi -> mbmi ) ;\n const InterpKernel * kernel = vp9_get_interp_kernel ( mi -> mbmi . interp_filter ) ;\n for ( ref = 0 ;\n ref < 1 + is_compound ;\n ++ ref ) {\n const uint8_t * pre = & pd -> pre [ ref ] . buf [ raster_block_offset ( BLOCK_8X8 , i , pd -> pre [ ref ] . stride ) ] ;\n vp9_build_inter_predictor ( pre , pd -> pre [ ref ] . stride , dst , pd -> dst . stride , & mi -> bmi [ i ] . as_mv [ ref ] . as_mv , & xd -> block_refs [ ref ] -> sf , width , height , ref , kernel , MV_PRECISION_Q3 , mi_col * MI_SIZE + 4 * ( i % 2 ) , mi_row * MI_SIZE + 4 * ( i / 2 ) ) ;\n }\n vp9_subtract_block ( height , width , raster_block_offset_int16 ( BLOCK_8X8 , i , p -> src_diff ) , 8 , src , p -> src . stride , dst , pd -> dst . stride ) ;\n k = i ;\n for ( idy = 0 ;\n idy < height / 4 ;\n ++ idy ) {\n for ( idx = 0 ;\n idx < width / 4 ;\n ++ idx ) {\n int64_t ssz , rd , rd1 , rd2 ;\n int16_t * coeff ;\n k += ( idy * 2 + idx ) ;\n coeff = BLOCK_OFFSET ( p -> coeff , k ) ;\n x -> fwd_txm4x4 ( raster_block_offset_int16 ( BLOCK_8X8 , k , p -> src_diff ) , coeff , 8 ) ;\n vp9_regular_quantize_b_4x4 ( x , 0 , k , so -> scan , so -> iscan ) ;\n thisdistortion += vp9_block_error ( coeff , BLOCK_OFFSET ( pd -> dqcoeff , k ) , 16 , & ssz ) ;\n thissse += ssz ;\n thisrate += cost_coeffs ( x , 0 , k , ta + ( k & 1 ) , tl + ( k >> 1 ) , TX_4X4 , so -> scan , so -> neighbors , cpi -> sf . use_fast_coef_costing ) ;\n rd1 = RDCOST ( x -> rdmult , x -> rddiv , thisrate , thisdistortion >> 2 ) ;\n rd2 = RDCOST ( x -> rdmult , x -> rddiv , 0 , thissse >> 2 ) ;\n rd = MIN ( rd1 , rd2 ) ;\n if ( rd >= best_yrd ) return INT64_MAX ;\n }\n }\n * distortion = thisdistortion >> 2 ;\n * labelyrate = thisrate ;\n * sse = thissse >> 2 ;\n return RDCOST ( x -> rdmult , x -> rddiv , * labelyrate , * distortion ) ;\n }", "idx": 1212}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_Scope ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_Scope , Scope_choice , NULL ) ;\n return offset ;\n }", "idx": 1213}
{"hash": 8818538544641313367, "project": "debian", "size": 46, "label": 1, "functionSource": "void aes_crypt_ecb ( aes_context * ctx , int mode , const unsigned char input [ 16 ] , unsigned char output [ 16 ] ) {\n int i ;\n unsigned long * RK , X0 , X1 , X2 , X3 , Y0 , Y1 , Y2 , Y3 ;\n # if defined ( XYSSL_PADLOCK_C ) && defined ( XYSSL_HAVE_X86 ) if ( padlock_supports ( PADLOCK_ACE ) ) {\n if ( padlock_xcryptecb ( ctx , mode , input , output ) == 0 ) return ;\n }\n # endif RK = ctx -> rk ;\n GET_ULONG_LE ( X0 , input , 0 ) ;\n X0 ^= * RK ++ ;\n GET_ULONG_LE ( X1 , input , 4 ) ;\n X1 ^= * RK ++ ;\n GET_ULONG_LE ( X2 , input , 8 ) ;\n X2 ^= * RK ++ ;\n GET_ULONG_LE ( X3 , input , 12 ) ;\n X3 ^= * RK ++ ;\n if ( mode == AES_DECRYPT ) {\n for ( i = ( ctx -> nr >> 1 ) - 1 ;\n i > 0 ;\n i -- ) {\n AES_RROUND ( Y0 , Y1 , Y2 , Y3 , X0 , X1 , X2 , X3 ) ;\n AES_RROUND ( X0 , X1 , X2 , X3 , Y0 , Y1 , Y2 , Y3 ) ;\n }\n AES_RROUND ( Y0 , Y1 , Y2 , Y3 , X0 , X1 , X2 , X3 ) ;\n X0 = * RK ++ ^ ( RSb [ ( Y0 ) & 0xFF ] ) ^ ( RSb [ ( Y3 >> 8 ) & 0xFF ] << 8 ) ^ ( RSb [ ( Y2 >> 16 ) & 0xFF ] << 16 ) ^ ( ( ( unsigned int ) RSb [ ( Y1 >> 24 ) & 0xFF ] ) << 24 ) ;\n X1 = * RK ++ ^ ( RSb [ ( Y1 ) & 0xFF ] ) ^ ( RSb [ ( Y0 >> 8 ) & 0xFF ] << 8 ) ^ ( RSb [ ( Y3 >> 16 ) & 0xFF ] << 16 ) ^ ( ( ( unsigned int ) RSb [ ( Y2 >> 24 ) & 0xFF ] ) << 24 ) ;\n X2 = * RK ++ ^ ( RSb [ ( Y2 ) & 0xFF ] ) ^ ( RSb [ ( Y1 >> 8 ) & 0xFF ] << 8 ) ^ ( RSb [ ( Y0 >> 16 ) & 0xFF ] << 16 ) ^ ( ( ( unsigned int ) RSb [ ( Y3 >> 24 ) & 0xFF ] ) << 24 ) ;\n X3 = * RK ++ ^ ( RSb [ ( Y3 ) & 0xFF ] ) ^ ( RSb [ ( Y2 >> 8 ) & 0xFF ] << 8 ) ^ ( RSb [ ( Y1 >> 16 ) & 0xFF ] << 16 ) ^ ( ( ( unsigned int ) RSb [ ( Y0 >> 24 ) & 0xFF ] ) << 24 ) ;\n }\n else {\n for ( i = ( ctx -> nr >> 1 ) - 1 ;\n i > 0 ;\n i -- ) {\n AES_FROUND ( Y0 , Y1 , Y2 , Y3 , X0 , X1 , X2 , X3 ) ;\n AES_FROUND ( X0 , X1 , X2 , X3 , Y0 , Y1 , Y2 , Y3 ) ;\n }\n AES_FROUND ( Y0 , Y1 , Y2 , Y3 , X0 , X1 , X2 , X3 ) ;\n X0 = * RK ++ ^ ( FSb [ ( Y0 ) & 0xFF ] ) ^ ( FSb [ ( Y1 >> 8 ) & 0xFF ] << 8 ) ^ ( FSb [ ( Y2 >> 16 ) & 0xFF ] << 16 ) ^ ( ( ( unsigned int ) FSb [ ( Y3 >> 24 ) & 0xFF ] ) << 24 ) ;\n X1 = * RK ++ ^ ( FSb [ ( Y1 ) & 0xFF ] ) ^ ( FSb [ ( Y2 >> 8 ) & 0xFF ] << 8 ) ^ ( FSb [ ( Y3 >> 16 ) & 0xFF ] << 16 ) ^ ( ( ( unsigned int ) FSb [ ( Y0 >> 24 ) & 0xFF ] ) << 24 ) ;\n X2 = * RK ++ ^ ( FSb [ ( Y2 ) & 0xFF ] ) ^ ( FSb [ ( Y3 >> 8 ) & 0xFF ] << 8 ) ^ ( FSb [ ( Y0 >> 16 ) & 0xFF ] << 16 ) ^ ( ( ( unsigned int ) FSb [ ( Y1 >> 24 ) & 0xFF ] ) << 24 ) ;\n X3 = * RK ++ ^ ( FSb [ ( Y3 ) & 0xFF ] ) ^ ( FSb [ ( Y0 >> 8 ) & 0xFF ] << 8 ) ^ ( FSb [ ( Y1 >> 16 ) & 0xFF ] << 16 ) ^ ( ( ( unsigned int ) FSb [ ( Y2 >> 24 ) & 0xFF ] ) << 24 ) ;\n }\n PUT_ULONG_LE ( X0 , output , 0 ) ;\n PUT_ULONG_LE ( X1 , output , 4 ) ;\n PUT_ULONG_LE ( X2 , output , 8 ) ;\n PUT_ULONG_LE ( X3 , output , 12 ) ;\n }", "idx": 1214}
{"hash": 4180964683905830761, "project": "debian", "size": 3, "label": 0, "functionSource": "static int selinux_secid_to_secctx ( u32 secid , char * * secdata , u32 * seclen ) {\n return security_sid_to_context ( secid , secdata , seclen ) ;\n }", "idx": 1215}
{"hash": -5420171864670538459, "project": "debian", "size": 7, "label": 0, "functionSource": "static void qemu_kvm_wait_io_event ( CPUState * cpu ) {\n while ( cpu_thread_is_idle ( cpu ) ) {\n qemu_cond_wait ( cpu -> halt_cond , & qemu_global_mutex ) ;\n }\n qemu_kvm_eat_signals ( cpu ) ;\n qemu_wait_io_event_common ( cpu ) ;\n }", "idx": 1216}
{"hash": 927123821003322045, "project": "chrome", "size": 13, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( SessionRestorePageLoadMetricsBrowserTest , InitialForegroundTabChanged ) {\n ui_test_utils : : NavigateToURL ( browser ( ) , GetTestURL ( ) ) ;\n ui_test_utils : : NavigateToURLWithDisposition ( browser ( ) , GetTestURL ( ) , WindowOpenDisposition : : NEW_BACKGROUND_TAB , ui_test_utils : : BROWSER_TEST_WAIT_FOR_NAVIGATION ) ;\n SessionRestorePaintWaiter session_restore_paint_waiter ;\n Browser * new_browser = QuitBrowserAndRestore ( browser ( ) ) ;\n TabStripModel * tab_strip = new_browser -> tab_strip_model ( ) ;\n ASSERT_TRUE ( tab_strip ) ;\n ASSERT_EQ ( 2 , tab_strip -> count ( ) ) ;\n ASSERT_EQ ( 0 , tab_strip -> active_index ( ) ) ;\n tab_strip -> ActivateTabAt ( 1 , true ) ;\n session_restore_paint_waiter . WaitForForegroundTabs ( 1 ) ;\n ExpectFirstPaintMetricsTotalCount ( 0 ) ;\n }", "idx": 1217}
{"hash": 1182028467273264883, "project": "debian", "size": 40, "label": 0, "functionSource": "int read_command ( struct st_command * * command_ptr ) {\n char * p = read_command_buf ;\n struct st_command * command ;\n DBUG_ENTER ( \"read_command\" ) ;\n if ( parser . current_line < parser . read_lines ) {\n get_dynamic ( & q_lines , ( uchar * ) command_ptr , parser . current_line ) ;\n DBUG_RETURN ( 0 ) ;\n }\n if ( ! ( * command_ptr = command = ( struct st_command * ) my_malloc ( sizeof ( * command ) , MYF ( MY_WME | MY_ZEROFILL ) ) ) || insert_dynamic ( & q_lines , ( uchar * ) & command ) ) die ( \"Out of memory\" ) ;\n command -> type = Q_UNKNOWN ;\n read_command_buf [ 0 ] = 0 ;\n if ( read_line ( read_command_buf , sizeof ( read_command_buf ) ) ) {\n check_eol_junk ( read_command_buf ) ;\n DBUG_RETURN ( 1 ) ;\n }\n if ( opt_result_format_version == 1 ) convert_to_format_v1 ( read_command_buf ) ;\n DBUG_PRINT ( \"info\" , ( \"query: '%s'\" , read_command_buf ) ) ;\n if ( * p == '#' ) {\n command -> type = Q_COMMENT ;\n }\n else if ( p [ 0 ] == '-' && p [ 1 ] == '-' ) {\n command -> type = Q_COMMENT_WITH_COMMAND ;\n p += 2 ;\n }\n else if ( * p == '\\n' ) {\n command -> type = Q_EMPTY_LINE ;\n }\n while ( * p && my_isspace ( charset_info , * p ) ) p ++ ;\n if ( ! ( command -> query_buf = command -> query = my_strdup ( p , MYF ( MY_WME ) ) ) ) die ( \"Out of memory\" ) ;\n p = command -> query ;\n while ( * p && ! my_isspace ( charset_info , * p ) && * p != '(' && ! is_delimiter ( p ) ) p ++ ;\n command -> first_word_len = ( uint ) ( p - command -> query ) ;\n DBUG_PRINT ( \"info\" , ( \"first_word: %.*s\" , command -> first_word_len , command -> query ) ) ;\n while ( * p && my_isspace ( charset_info , * p ) ) p ++ ;\n command -> first_argument = p ;\n command -> end = strend ( command -> query ) ;\n command -> query_len = ( command -> end - command -> query ) ;\n parser . read_lines ++ ;\n DBUG_RETURN ( 0 ) ;\n }", "idx": 1218}
{"hash": 8127806390163862344, "project": "debian", "size": 4, "label": 0, "functionSource": "static void do_vapic_enable ( void * data ) {\n VAPICROMState * s = data ;\n vapic_enable ( s , first_cpu ) ;\n }", "idx": 1219}
{"hash": 7725608904711859657, "project": "debian", "size": 6, "label": 0, "functionSource": "int TS_OBJ_print_bio ( BIO * bio , const ASN1_OBJECT * obj ) {\n char obj_txt [ 128 ] ;\n OBJ_obj2txt ( obj_txt , sizeof ( obj_txt ) , obj , 0 ) ;\n BIO_printf ( bio , \"%s\\n\" , obj_txt ) ;\n return 1 ;\n }", "idx": 1220}
{"hash": -341028540041678099, "project": "debian", "size": 3, "label": 0, "functionSource": "void sortassoc ( void ) {\n if ( numassoc > 1 ) qsort ( assoc_cache , ( size_t ) numassoc , sizeof ( assoc_cache [ 0 ] ) , & assoccmp ) ;\n }", "idx": 1221}
{"hash": -5082285935423529157, "project": "debian", "size": 14, "label": 0, "functionSource": "static int dissect_rsl_ie_ch_needed ( tvbuff_t * tvb , packet_info * pinfo _U_ , proto_tree * tree , int offset , gboolean is_mandatory ) {\n proto_tree * ie_tree ;\n guint8 ie_id ;\n if ( is_mandatory == FALSE ) {\n ie_id = tvb_get_guint8 ( tvb , offset ) ;\n if ( ie_id != RSL_IE_CH_NEEDED ) return offset ;\n }\n ie_tree = proto_tree_add_subtree ( tree , tvb , offset , 0 , ett_ie_ch_needed , NULL , \"Channel Needed IE\" ) ;\n proto_tree_add_item ( ie_tree , hf_rsl_ie_id , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n offset ++ ;\n proto_tree_add_item ( ie_tree , hf_rsl_ch_needed , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n offset ++ ;\n return offset ;\n }", "idx": 1222}
{"hash": -1919011628477388936, "project": "debian", "size": 51, "label": 0, "functionSource": "static void openpic_cpu_write_internal ( void * opaque , hwaddr addr , uint32_t val , int idx ) {\n OpenPICState * opp = opaque ;\n IRQSource * src ;\n IRQDest * dst ;\n int s_IRQ , n_IRQ ;\n DPRINTF ( \"%s: cpu %d addr %#\" HWADDR_PRIx \" <= 0x%08x\\n\" , __func__ , idx , addr , val ) ;\n if ( idx < 0 ) {\n return ;\n }\n if ( addr & 0xF ) {\n return ;\n }\n dst = & opp -> dst [ idx ] ;\n addr &= 0xFF0 ;\n switch ( addr ) {\n case 0x40 : case 0x50 : case 0x60 : case 0x70 : idx = ( addr - 0x40 ) >> 4 ;\n opp -> src [ opp -> irq_ipi0 + idx ] . destmask |= val ;\n openpic_set_irq ( opp , opp -> irq_ipi0 + idx , 1 ) ;\n openpic_set_irq ( opp , opp -> irq_ipi0 + idx , 0 ) ;\n break ;\n case 0x80 : dst -> ctpr = val & 0x0000000F ;\n DPRINTF ( \"%s: set CPU %d ctpr to %d, raised %d servicing %d\\n\" , __func__ , idx , dst -> ctpr , dst -> raised . priority , dst -> servicing . priority ) ;\n if ( dst -> raised . priority <= dst -> ctpr ) {\n DPRINTF ( \"%s: Lower OpenPIC INT output cpu %d due to ctpr\\n\" , __func__ , idx ) ;\n qemu_irq_lower ( dst -> irqs [ OPENPIC_OUTPUT_INT ] ) ;\n }\n else if ( dst -> raised . priority > dst -> servicing . priority ) {\n DPRINTF ( \"%s: Raise OpenPIC INT output cpu %d irq %d\\n\" , __func__ , idx , dst -> raised . next ) ;\n qemu_irq_raise ( dst -> irqs [ OPENPIC_OUTPUT_INT ] ) ;\n }\n break ;\n case 0x90 : break ;\n case 0xA0 : break ;\n case 0xB0 : DPRINTF ( \"EOI\\n\" ) ;\n s_IRQ = IRQ_get_next ( opp , & dst -> servicing ) ;\n if ( s_IRQ < 0 ) {\n DPRINTF ( \"%s: EOI with no interrupt in service\\n\" , __func__ ) ;\n break ;\n }\n IRQ_resetbit ( & dst -> servicing , s_IRQ ) ;\n s_IRQ = IRQ_get_next ( opp , & dst -> servicing ) ;\n n_IRQ = IRQ_get_next ( opp , & dst -> raised ) ;\n src = & opp -> src [ n_IRQ ] ;\n if ( n_IRQ != - 1 && ( s_IRQ == - 1 || IVPR_PRIORITY ( src -> ivpr ) > dst -> servicing . priority ) ) {\n DPRINTF ( \"Raise OpenPIC INT output cpu %d irq %d\\n\" , idx , n_IRQ ) ;\n qemu_irq_raise ( opp -> dst [ idx ] . irqs [ OPENPIC_OUTPUT_INT ] ) ;\n }\n break ;\n default : break ;\n }\n }", "idx": 1223}
{"hash": -2607754285145856562, "project": "debian", "size": 18, "label": 0, "functionSource": "static int isoent_alloc_path_table ( struct archive_write * a , struct vdd * vdd , int max_depth ) {\n int i ;\n vdd -> max_depth = max_depth ;\n vdd -> pathtbl = malloc ( sizeof ( * vdd -> pathtbl ) * vdd -> max_depth ) ;\n if ( vdd -> pathtbl == NULL ) {\n archive_set_error ( & a -> archive , ENOMEM , \"Can't allocate memory\" ) ;\n return ( ARCHIVE_FATAL ) ;\n }\n for ( i = 0 ;\n i < vdd -> max_depth ;\n i ++ ) {\n vdd -> pathtbl [ i ] . first = NULL ;\n vdd -> pathtbl [ i ] . last = & ( vdd -> pathtbl [ i ] . first ) ;\n vdd -> pathtbl [ i ] . sorted = NULL ;\n vdd -> pathtbl [ i ] . cnt = 0 ;\n }\n return ( ARCHIVE_OK ) ;\n }", "idx": 1224}
{"hash": -3133987110086012192, "project": "chrome", "size": 11, "label": 0, "functionSource": "TEST_F ( SoundContentSettingObserverTest , DontMuteWhenUnmutedByExtension ) {\n EXPECT_FALSE ( web_contents ( ) -> IsAudioMuted ( ) ) ;\n ChangeSoundContentSettingTo ( CONTENT_SETTING_BLOCK ) ;\n EXPECT_TRUE ( web_contents ( ) -> IsAudioMuted ( ) ) ;\n SetMuteStateForReason ( false , TabMutedReason : : EXTENSION ) ;\n EXPECT_FALSE ( web_contents ( ) -> IsAudioMuted ( ) ) ;\n NavigateAndCommit ( GURL ( kURL2 ) ) ;\n EXPECT_FALSE ( web_contents ( ) -> IsAudioMuted ( ) ) ;\n NavigateAndCommit ( GURL ( kURL1 ) ) ;\n EXPECT_FALSE ( web_contents ( ) -> IsAudioMuted ( ) ) ;\n }", "idx": 1225}
{"hash": -1487877838474751244, "project": "debian", "size": 3, "label": 0, "functionSource": "PHP_NAMED_FUNCTION ( zif_locale_get_default ) {\n RETURN_STRING ( intl_locale_get_default ( TSRMLS_C ) , TRUE ) ;\n }", "idx": 1226}
{"hash": 1760449185745615462, "project": "debian", "size": 8, "label": 0, "functionSource": "const char * TSHttpHdrReasonGet ( TSMBuffer bufp , TSMLoc obj , int * length ) {\n sdk_assert ( sdk_sanity_check_mbuffer ( bufp ) == TS_SUCCESS ) ;\n sdk_assert ( sdk_sanity_check_http_hdr_handle ( obj ) == TS_SUCCESS ) ;\n sdk_assert ( sdk_sanity_check_null_ptr ( ( void * ) length ) == TS_SUCCESS ) ;\n HTTPHdr h ;\n SET_HTTP_HDR ( h , bufp , obj ) ;\n return h . reason_get ( length ) ;\n }", "idx": 1227}
{"hash": 3426991998365732450, "project": "debian", "size": 6, "label": 0, "functionSource": "void ps2_mouse_fake_event ( void * opaque ) {\n PS2MouseState * s = opaque ;\n trace_ps2_mouse_fake_event ( opaque ) ;\n s -> mouse_dx ++ ;\n ps2_mouse_sync ( opaque ) ;\n }", "idx": 1228}
{"hash": -992498691684812004, "project": "chrome", "size": 9, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( PrefsFunctionalTest , PRE_TestHomepagePrefs ) {\n GURL home_page_url ( \"http://www.google.com\" ) ;\n PrefService * prefs = browser ( ) -> profile ( ) -> GetPrefs ( ) ;\n prefs -> SetBoolean ( prefs : : kHomePageIsNewTabPage , false ) ;\n const PrefService : : Preference * pref = prefs -> FindPreference ( prefs : : kHomePage ) ;\n if ( pref && ! pref -> IsManaged ( ) ) {\n prefs -> SetString ( prefs : : kHomePage , home_page_url . spec ( ) ) ;\n }\n }", "idx": 1229}
{"hash": 1614547608286395137, "project": "debian", "size": 18, "label": 0, "functionSource": "void retry_outgoing ( outgoing_t * outgoing ) {\n outgoing -> timeout += 5 ;\n if ( outgoing -> timeout < mintimeout ) {\n outgoing -> timeout = mintimeout ;\n }\n if ( outgoing -> timeout > maxtimeout ) {\n outgoing -> timeout = maxtimeout ;\n }\n if ( outgoing -> event ) {\n event_del ( outgoing -> event ) ;\n }\n outgoing -> event = new_event ( ) ;\n outgoing -> event -> handler = ( event_handler_t ) setup_outgoing_connection ;\n outgoing -> event -> time = now + outgoing -> timeout ;\n outgoing -> event -> data = outgoing ;\n event_add ( outgoing -> event ) ;\n ifdebug ( CONNECTIONS ) logger ( LOG_NOTICE , \"Trying to re-establish outgoing connection in %d seconds\" , outgoing -> timeout ) ;\n }", "idx": 1230}
{"hash": 7399683071036018868, "project": "debian", "size": 3, "label": 0, "functionSource": "void pdo_dbstmt_free_storage ( pdo_stmt_t * stmt TSRMLS_DC ) {\n php_pdo_stmt_delref ( stmt TSRMLS_CC ) ;\n }", "idx": 1231}
{"hash": -8046645508582876963, "project": "debian", "size": 80, "label": 0, "functionSource": "static void reconstruct_and_encode_image ( RoqContext * enc , RoqTempdata * tempData , int w , int h , int numBlocks ) {\n int i , j , k ;\n int x , y ;\n int subX , subY ;\n int dist = 0 ;\n roq_qcell * qcell ;\n CelEvaluation * eval ;\n CodingSpool spool ;\n spool . typeSpool = 0 ;\n spool . typeSpoolLength = 0 ;\n spool . args = spool . argumentSpool ;\n spool . pout = & enc -> out_buf ;\n if ( tempData -> used_option [ RoQ_ID_CCC ] % 2 ) tempData -> mainChunkSize += 8 ;\n bytestream_put_le16 ( & enc -> out_buf , RoQ_QUAD_VQ ) ;\n bytestream_put_le32 ( & enc -> out_buf , tempData -> mainChunkSize / 8 ) ;\n bytestream_put_byte ( & enc -> out_buf , 0x0 ) ;\n bytestream_put_byte ( & enc -> out_buf , 0x0 ) ;\n for ( i = 0 ;\n i < numBlocks ;\n i ++ ) {\n eval = tempData -> cel_evals + i ;\n x = eval -> sourceX ;\n y = eval -> sourceY ;\n dist += eval -> eval_dist [ eval -> best_coding ] ;\n switch ( eval -> best_coding ) {\n case RoQ_ID_MOT : write_typecode ( & spool , RoQ_ID_MOT ) ;\n break ;\n case RoQ_ID_FCC : bytestream_put_byte ( & spool . args , motion_arg ( eval -> motion ) ) ;\n write_typecode ( & spool , RoQ_ID_FCC ) ;\n ff_apply_motion_8x8 ( enc , x , y , eval -> motion . d [ 0 ] , eval -> motion . d [ 1 ] ) ;\n break ;\n case RoQ_ID_SLD : bytestream_put_byte ( & spool . args , tempData -> i2f4 [ eval -> cbEntry ] ) ;\n write_typecode ( & spool , RoQ_ID_SLD ) ;\n qcell = enc -> cb4x4 + eval -> cbEntry ;\n ff_apply_vector_4x4 ( enc , x , y , enc -> cb2x2 + qcell -> idx [ 0 ] ) ;\n ff_apply_vector_4x4 ( enc , x + 4 , y , enc -> cb2x2 + qcell -> idx [ 1 ] ) ;\n ff_apply_vector_4x4 ( enc , x , y + 4 , enc -> cb2x2 + qcell -> idx [ 2 ] ) ;\n ff_apply_vector_4x4 ( enc , x + 4 , y + 4 , enc -> cb2x2 + qcell -> idx [ 3 ] ) ;\n break ;\n case RoQ_ID_CCC : write_typecode ( & spool , RoQ_ID_CCC ) ;\n for ( j = 0 ;\n j < 4 ;\n j ++ ) {\n subX = x + 4 * ( j & 1 ) ;\n subY = y + 2 * ( j & 2 ) ;\n switch ( eval -> subCels [ j ] . best_coding ) {\n case RoQ_ID_MOT : break ;\n case RoQ_ID_FCC : bytestream_put_byte ( & spool . args , motion_arg ( eval -> subCels [ j ] . motion ) ) ;\n ff_apply_motion_4x4 ( enc , subX , subY , eval -> subCels [ j ] . motion . d [ 0 ] , eval -> subCels [ j ] . motion . d [ 1 ] ) ;\n break ;\n case RoQ_ID_SLD : bytestream_put_byte ( & spool . args , tempData -> i2f4 [ eval -> subCels [ j ] . cbEntry ] ) ;\n qcell = enc -> cb4x4 + eval -> subCels [ j ] . cbEntry ;\n ff_apply_vector_2x2 ( enc , subX , subY , enc -> cb2x2 + qcell -> idx [ 0 ] ) ;\n ff_apply_vector_2x2 ( enc , subX + 2 , subY , enc -> cb2x2 + qcell -> idx [ 1 ] ) ;\n ff_apply_vector_2x2 ( enc , subX , subY + 2 , enc -> cb2x2 + qcell -> idx [ 2 ] ) ;\n ff_apply_vector_2x2 ( enc , subX + 2 , subY + 2 , enc -> cb2x2 + qcell -> idx [ 3 ] ) ;\n break ;\n case RoQ_ID_CCC : for ( k = 0 ;\n k < 4 ;\n k ++ ) {\n int cb_idx = eval -> subCels [ j ] . subCels [ k ] ;\n bytestream_put_byte ( & spool . args , tempData -> i2f2 [ cb_idx ] ) ;\n ff_apply_vector_2x2 ( enc , subX + 2 * ( k & 1 ) , subY + ( k & 2 ) , enc -> cb2x2 + cb_idx ) ;\n }\n break ;\n }\n write_typecode ( & spool , eval -> subCels [ j ] . best_coding ) ;\n }\n break ;\n }\n }\n while ( spool . typeSpoolLength ) write_typecode ( & spool , 0x0 ) ;\n # if 0 uint8_t * fdata [ 3 ] = {\n enc -> frame_to_enc -> data [ 0 ] , enc -> frame_to_enc -> data [ 1 ] , enc -> frame_to_enc -> data [ 2 ] }\n ;\n uint8_t * cdata [ 3 ] = {\n enc -> current_frame -> data [ 0 ] , enc -> current_frame -> data [ 1 ] , enc -> current_frame -> data [ 2 ] }\n ;\n av_log ( enc -> avctx , AV_LOG_ERROR , \"Expected distortion: %i Actual: %i\\n\" , dist , block_sse ( fdata , cdata , 0 , 0 , 0 , 0 , enc -> frame_to_enc -> linesize , enc -> current_frame -> linesize , enc -> width ) ) ;\n # endif }", "idx": 1232}
{"hash": 6393050609822897742, "project": "debian", "size": 20, "label": 0, "functionSource": "static void xhci_stall_ep ( XHCITransfer * xfer ) {\n XHCIEPContext * epctx = xfer -> epctx ;\n XHCIState * xhci = epctx -> xhci ;\n uint32_t err ;\n XHCIStreamContext * sctx ;\n if ( epctx -> nr_pstreams ) {\n sctx = xhci_find_stream ( epctx , xfer -> streamid , & err ) ;\n if ( sctx == NULL ) {\n return ;\n }\n sctx -> ring . dequeue = xfer -> trbs [ 0 ] . addr ;\n sctx -> ring . ccs = xfer -> trbs [ 0 ] . ccs ;\n xhci_set_ep_state ( xhci , epctx , sctx , EP_HALTED ) ;\n }\n else {\n epctx -> ring . dequeue = xfer -> trbs [ 0 ] . addr ;\n epctx -> ring . ccs = xfer -> trbs [ 0 ] . ccs ;\n xhci_set_ep_state ( xhci , epctx , NULL , EP_HALTED ) ;\n }\n }", "idx": 1233}
{"hash": 6980637897759012306, "project": "chrome", "size": 10, "label": 0, "functionSource": "int evsignal_del ( struct event * ev ) {\n struct event_base * base = ev -> ev_base ;\n struct evsignal_info * sig = & base -> sig ;\n int evsignal = EVENT_SIGNAL ( ev ) ;\n assert ( evsignal >= 0 && evsignal < NSIG ) ;\n TAILQ_REMOVE ( & sig -> evsigevents [ evsignal ] , ev , ev_signal_next ) ;\n if ( ! TAILQ_EMPTY ( & sig -> evsigevents [ evsignal ] ) ) return ( 0 ) ;\n event_debug ( ( \"%s: %p: restoring signal handler\" , __func__ , ev ) ) ;\n return ( _evsignal_restore_handler ( ev -> ev_base , EVENT_SIGNAL ( ev ) ) ) ;\n }", "idx": 1234}
{"hash": 4876100961671882393, "project": "debian", "size": 14, "label": 0, "functionSource": "static int dissect_pvfs_handle_extent_array ( tvbuff_t * tvb , proto_tree * tree , int offset , packet_info * pinfo ) {\n guint32 extent_count ;\n guint32 nCount ;\n proto_tree * extent_array_tree ;\n extent_count = tvb_get_letohl ( tvb , offset ) ;\n extent_array_tree = proto_tree_add_subtree_format ( tree , tvb , offset , 4 , ett_pvfs_extent_array_tree , NULL , \"Handle Extent Array (count = %d)\" , extent_count ) ;\n offset += 4 ;\n if ( extent_count > 0 ) {\n for ( nCount = 0 ;\n nCount < extent_count ;\n nCount ++ ) offset = dissect_pvfs_handle_extent ( tvb , extent_array_tree , offset , pinfo , nCount ) ;\n }\n return offset ;\n }", "idx": 1235}
{"hash": 2388171415474875762, "project": "debian", "size": 51, "label": 0, "functionSource": "static void dissect_rsvp_adspec ( proto_item * ti _U_ , packet_info * pinfo , proto_tree * rsvp_object_tree , tvbuff_t * tvb , int offset , int obj_length , int rsvp_class _U_ , int type ) {\n int offset2 = offset + 4 ;\n int mylen , i ;\n proto_tree * adspec_tree , * adspec_type_tree ;\n proto_item * ti2 ;\n proto_tree_add_uint ( rsvp_object_tree , hf_rsvp_ctype , tvb , offset + 3 , 1 , type ) ;\n mylen = obj_length - 4 ;\n proto_tree_add_item ( rsvp_object_tree , hf_rsvp_adspec_message_format_version , tvb , offset2 , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_uint_format_value ( rsvp_object_tree , hf_rsvp_data_length , tvb , offset2 + 2 , 2 , tvb_get_ntohs ( tvb , offset2 + 2 ) , \"%u words, not including header\" , tvb_get_ntohs ( tvb , offset2 + 2 ) ) ;\n mylen -= 4 ;\n offset2 += 4 ;\n while ( mylen > 0 ) {\n guint8 service_num ;\n guint length ;\n const char * str ;\n service_num = tvb_get_guint8 ( tvb , offset2 ) ;\n str = val_to_str_ext_const ( service_num , & intsrv_services_str_ext , \"Unknown\" ) ;\n length = tvb_get_ntohs ( tvb , offset2 + 2 ) ;\n adspec_tree = proto_tree_add_subtree ( rsvp_object_tree , tvb , offset2 , ( length + 1 ) * 4 , TREE ( TT_ADSPEC_SUBTREE ) , NULL , str ) ;\n proto_tree_add_item ( adspec_tree , hf_rsvp_adspec_service_header , tvb , offset2 , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( adspec_tree , hf_rsvp_hf_rsvp_adspec_break_bit , tvb , offset2 + 1 , 1 , ENC_NA ) ;\n proto_tree_add_uint_format_value ( adspec_tree , hf_rsvp_data_length , tvb , offset2 + 2 , 2 , length , \"%u words, not including header\" , length ) ;\n mylen -= 4 ;\n offset2 += 4 ;\n i = length * 4 ;\n while ( i > 0 ) {\n guint id , phdr_length ;\n ti2 = proto_tree_add_item_ret_uint ( adspec_tree , hf_rsvp_adspec_type , tvb , offset2 , 1 , ENC_NA , & id ) ;\n adspec_type_tree = proto_item_add_subtree ( ti2 , TREE ( TT_ADSPEC_TYPE_SUBTREE ) ) ;\n proto_tree_add_item_ret_uint ( adspec_type_tree , hf_rsvp_adspec_len , tvb , offset2 + 2 , 2 , ENC_BIG_ENDIAN , & phdr_length ) ;\n proto_item_set_len ( ti2 , phdr_length ) ;\n str = try_val_to_str_ext ( id , & adspec_params_ext ) ;\n if ( str ) {\n switch ( id ) {\n case 4 : case 8 : case 10 : case 133 : case 134 : case 135 : case 136 : proto_tree_add_uint_format ( adspec_type_tree , hf_rsvp_adspec_uint , tvb , offset2 , ( phdr_length + 1 ) << 2 , tvb_get_ntohl ( tvb , offset2 + 4 ) , \"%s: %u\" , str , tvb_get_ntohl ( tvb , offset2 + 4 ) ) ;\n break ;\n case 6 : proto_tree_add_float_format ( adspec_type_tree , hf_rsvp_adspec_float , tvb , offset2 , ( phdr_length + 1 ) << 2 , tvb_get_ntohieee_float ( tvb , offset2 + 4 ) , \"%s: %.10g\" , str , tvb_get_ntohieee_float ( tvb , offset2 + 4 ) ) ;\n break ;\n default : proto_tree_add_bytes_format ( adspec_tree , hf_rsvp_adspec_bytes , tvb , offset2 , ( phdr_length + 1 ) << 2 , NULL , \"%s\" , str ) ;\n break ;\n }\n }\n else {\n expert_add_info ( pinfo , ti2 , & ei_rsvp_adspec_type ) ;\n }\n offset2 += ( phdr_length + 1 ) << 2 ;\n i -= ( phdr_length + 1 ) << 2 ;\n mylen -= ( phdr_length + 1 ) << 2 ;\n }\n }\n }", "idx": 1236}
{"hash": 1760449185745615462, "project": "debian", "size": 11, "label": 0, "functionSource": "unsigned int TSMimeHdrFieldValueUintGet ( TSMBuffer bufp , TSMLoc hdr , TSMLoc field , int idx ) {\n sdk_assert ( sdk_sanity_check_mbuffer ( bufp ) == TS_SUCCESS ) ;\n sdk_assert ( ( sdk_sanity_check_mime_hdr_handle ( hdr ) == TS_SUCCESS ) || ( sdk_sanity_check_http_hdr_handle ( hdr ) == TS_SUCCESS ) ) ;\n sdk_assert ( sdk_sanity_check_field_handle ( field , hdr ) == TS_SUCCESS ) ;\n int value_len ;\n const char * value_str = TSMimeFieldValueGet ( bufp , field , idx , & value_len ) ;\n if ( value_str == nullptr ) {\n return 0 ;\n }\n return mime_parse_uint ( value_str , value_str + value_len ) ;\n }", "idx": 1237}
{"hash": 2343071019501443392, "project": "chrome", "size": 24, "label": 0, "functionSource": "static void encode_mv_component ( vp9_writer * w , int comp , const nmv_component * mvcomp , int usehp ) {\n int offset ;\n const int sign = comp < 0 ;\n const int mag = sign ? - comp : comp ;\n const int mv_class = vp9_get_mv_class ( mag - 1 , & offset ) ;\n const int d = offset >> 3 ;\n const int fr = ( offset >> 1 ) & 3 ;\n const int hp = offset & 1 ;\n assert ( comp != 0 ) ;\n vp9_write ( w , sign , mvcomp -> sign ) ;\n vp9_write_token ( w , vp9_mv_class_tree , mvcomp -> classes , & mv_class_encodings [ mv_class ] ) ;\n if ( mv_class == MV_CLASS_0 ) {\n vp9_write_token ( w , vp9_mv_class0_tree , mvcomp -> class0 , & mv_class0_encodings [ d ] ) ;\n }\n else {\n int i ;\n const int n = mv_class + CLASS0_BITS - 1 ;\n for ( i = 0 ;\n i < n ;\n ++ i ) vp9_write ( w , ( d >> i ) & 1 , mvcomp -> bits [ i ] ) ;\n }\n vp9_write_token ( w , vp9_mv_fp_tree , mv_class == MV_CLASS_0 ? mvcomp -> class0_fp [ d ] : mvcomp -> fp , & mv_fp_encodings [ fr ] ) ;\n if ( usehp ) vp9_write ( w , hp , mv_class == MV_CLASS_0 ? mvcomp -> class0_hp : mvcomp -> hp ) ;\n }", "idx": 1238}
{"hash": 914926989019402478, "project": "debian", "size": 18, "label": 0, "functionSource": "static const main_extcomp * main_get_compressor ( const char * ident ) {\n const main_extcomp * ext = main_ident_compressor ( ident ) ;\n if ( ext == NULL ) {\n if ( ! option_quiet ) {\n XPR ( NT \"warning: cannot recompress output: \" \"unrecognized external compression ID: %s\\n\" , ident ) ;\n }\n return NULL ;\n }\n else if ( ! EXTERNAL_COMPRESSION ) {\n if ( ! option_quiet ) {\n XPR ( NT \"warning: external support not compiled: \" \"original input was compressed: %s\\n\" , ext -> recomp_cmdname ) ;\n }\n return NULL ;\n }\n else {\n return ext ;\n }\n }", "idx": 1239}
{"hash": 1223258652239369123, "project": "debian", "size": 16, "label": 0, "functionSource": "SPL_METHOD ( RecursiveDirectoryIterator , getSubPathname ) {\n spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n char * sub_name ;\n int len ;\n char slash = SPL_HAS_FLAG ( intern -> flags , SPL_FILE_DIR_UNIXPATHS ) ? '/' : DEFAULT_SLASH ;\n if ( zend_parse_parameters_none ( ) == FAILURE ) {\n return ;\n }\n if ( intern -> u . dir . sub_path ) {\n len = spprintf ( & sub_name , 0 , \"%s%c%s\" , intern -> u . dir . sub_path , slash , intern -> u . dir . entry . d_name ) ;\n RETURN_STRINGL ( sub_name , len , 0 ) ;\n }\n else {\n RETURN_STRING ( intern -> u . dir . entry . d_name , 1 ) ;\n }\n }", "idx": 1240}
{"hash": 1760449185745615462, "project": "debian", "size": 3, "label": 0, "functionSource": "TSReturnCode TSMgmtFloatGet ( const char * var_name , TSMgmtFloat * result ) {\n return RecGetRecordFloat ( ( char * ) var_name , ( RecFloat * ) result ) == REC_ERR_OKAY ? TS_SUCCESS : TS_ERROR ;\n }", "idx": 1241}
{"hash": -1672864273235910388, "project": "debian", "size": 16, "label": 0, "functionSource": "static void _slurm_rpc_step_update ( slurm_msg_t * msg ) {\n DEF_TIMERS ;\n step_update_request_msg_t * req = ( step_update_request_msg_t * ) msg -> data ;\n slurmctld_lock_t job_write_lock = {\n NO_LOCK , WRITE_LOCK , NO_LOCK , NO_LOCK , NO_LOCK }\n ;\n uid_t uid = g_slurm_auth_get_uid ( msg -> auth_cred , slurmctld_config . auth_info ) ;\n int rc ;\n START_TIMER ;\n if ( slurmctld_conf . debug_flags & DEBUG_FLAG_STEPS ) info ( \"Processing RPC: REQUEST_STEP_UPDATE, from uid=%d\" , uid ) ;\n lock_slurmctld ( job_write_lock ) ;\n rc = update_step ( req , uid ) ;\n unlock_slurmctld ( job_write_lock ) ;\n END_TIMER2 ( \"_slurm_rpc_step_update\" ) ;\n slurm_send_rc_msg ( msg , rc ) ;\n }", "idx": 1242}
{"hash": 6080147530626246065, "project": "debian", "size": 223, "label": 0, "functionSource": "static inline void vc1_pred_mv ( VC1Context * v , int n , int dmv_x , int dmv_y , int mv1 , int r_x , int r_y , uint8_t * is_intra , int pred_flag , int dir ) {\n MpegEncContext * s = & v -> s ;\n int xy , wrap , off = 0 ;\n int16_t * A , * B , * C ;\n int px , py ;\n int sum ;\n int mixedmv_pic , num_samefield = 0 , num_oppfield = 0 ;\n int opposite , a_f , b_f , c_f ;\n int16_t field_predA [ 2 ] ;\n int16_t field_predB [ 2 ] ;\n int16_t field_predC [ 2 ] ;\n int a_valid , b_valid , c_valid ;\n int hybridmv_thresh , y_bias = 0 ;\n if ( v -> mv_mode == MV_PMODE_MIXED_MV || ( ( v -> mv_mode == MV_PMODE_INTENSITY_COMP ) && ( v -> mv_mode2 == MV_PMODE_MIXED_MV ) ) ) mixedmv_pic = 1 ;\n else mixedmv_pic = 0 ;\n dmv_x <<= 1 - s -> quarter_sample ;\n dmv_y <<= 1 - s -> quarter_sample ;\n wrap = s -> b8_stride ;\n xy = s -> block_index [ n ] ;\n if ( s -> mb_intra ) {\n s -> mv [ 0 ] [ n ] [ 0 ] = s -> current_picture . motion_val [ 0 ] [ xy + v -> blocks_off ] [ 0 ] = 0 ;\n s -> mv [ 0 ] [ n ] [ 1 ] = s -> current_picture . motion_val [ 0 ] [ xy + v -> blocks_off ] [ 1 ] = 0 ;\n s -> current_picture . motion_val [ 1 ] [ xy + v -> blocks_off ] [ 0 ] = 0 ;\n s -> current_picture . motion_val [ 1 ] [ xy + v -> blocks_off ] [ 1 ] = 0 ;\n if ( mv1 ) {\n s -> current_picture . motion_val [ 0 ] [ xy + 1 + v -> blocks_off ] [ 0 ] = 0 ;\n s -> current_picture . motion_val [ 0 ] [ xy + 1 + v -> blocks_off ] [ 1 ] = 0 ;\n s -> current_picture . motion_val [ 0 ] [ xy + wrap + v -> blocks_off ] [ 0 ] = 0 ;\n s -> current_picture . motion_val [ 0 ] [ xy + wrap + v -> blocks_off ] [ 1 ] = 0 ;\n s -> current_picture . motion_val [ 0 ] [ xy + wrap + 1 + v -> blocks_off ] [ 0 ] = 0 ;\n s -> current_picture . motion_val [ 0 ] [ xy + wrap + 1 + v -> blocks_off ] [ 1 ] = 0 ;\n v -> luma_mv [ s -> mb_x ] [ 0 ] = v -> luma_mv [ s -> mb_x ] [ 1 ] = 0 ;\n s -> current_picture . motion_val [ 1 ] [ xy + 1 + v -> blocks_off ] [ 0 ] = 0 ;\n s -> current_picture . motion_val [ 1 ] [ xy + 1 + v -> blocks_off ] [ 1 ] = 0 ;\n s -> current_picture . motion_val [ 1 ] [ xy + wrap ] [ 0 ] = 0 ;\n s -> current_picture . motion_val [ 1 ] [ xy + wrap + v -> blocks_off ] [ 1 ] = 0 ;\n s -> current_picture . motion_val [ 1 ] [ xy + wrap + 1 + v -> blocks_off ] [ 0 ] = 0 ;\n s -> current_picture . motion_val [ 1 ] [ xy + wrap + 1 + v -> blocks_off ] [ 1 ] = 0 ;\n }\n return ;\n }\n C = s -> current_picture . motion_val [ dir ] [ xy - 1 + v -> blocks_off ] ;\n A = s -> current_picture . motion_val [ dir ] [ xy - wrap + v -> blocks_off ] ;\n if ( mv1 ) {\n if ( v -> field_mode && mixedmv_pic ) off = ( s -> mb_x == ( s -> mb_width - 1 ) ) ? - 2 : 2 ;\n else off = ( s -> mb_x == ( s -> mb_width - 1 ) ) ? - 1 : 2 ;\n }\n else {\n switch ( n ) {\n case 0 : off = ( s -> mb_x > 0 ) ? - 1 : 1 ;\n break ;\n case 1 : off = ( s -> mb_x == ( s -> mb_width - 1 ) ) ? - 1 : 1 ;\n break ;\n case 2 : off = 1 ;\n break ;\n case 3 : off = - 1 ;\n }\n }\n B = s -> current_picture . motion_val [ dir ] [ xy - wrap + off + v -> blocks_off ] ;\n a_valid = ! s -> first_slice_line || ( n == 2 || n == 3 ) ;\n b_valid = a_valid && ( s -> mb_width > 1 ) ;\n c_valid = s -> mb_x || ( n == 1 || n == 3 ) ;\n if ( v -> field_mode ) {\n a_valid = a_valid && ! is_intra [ xy - wrap ] ;\n b_valid = b_valid && ! is_intra [ xy - wrap + off ] ;\n c_valid = c_valid && ! is_intra [ xy - 1 ] ;\n }\n if ( a_valid ) {\n a_f = v -> mv_f [ dir ] [ xy - wrap + v -> blocks_off ] ;\n num_oppfield += a_f ;\n num_samefield += 1 - a_f ;\n field_predA [ 0 ] = A [ 0 ] ;\n field_predA [ 1 ] = A [ 1 ] ;\n }\n else {\n field_predA [ 0 ] = field_predA [ 1 ] = 0 ;\n a_f = 0 ;\n }\n if ( b_valid ) {\n b_f = v -> mv_f [ dir ] [ xy - wrap + off + v -> blocks_off ] ;\n num_oppfield += b_f ;\n num_samefield += 1 - b_f ;\n field_predB [ 0 ] = B [ 0 ] ;\n field_predB [ 1 ] = B [ 1 ] ;\n }\n else {\n field_predB [ 0 ] = field_predB [ 1 ] = 0 ;\n b_f = 0 ;\n }\n if ( c_valid ) {\n c_f = v -> mv_f [ dir ] [ xy - 1 + v -> blocks_off ] ;\n num_oppfield += c_f ;\n num_samefield += 1 - c_f ;\n field_predC [ 0 ] = C [ 0 ] ;\n field_predC [ 1 ] = C [ 1 ] ;\n }\n else {\n field_predC [ 0 ] = field_predC [ 1 ] = 0 ;\n c_f = 0 ;\n }\n if ( v -> field_mode ) {\n if ( ! v -> numref ) opposite = 1 - v -> reffield ;\n else {\n if ( num_samefield <= num_oppfield ) opposite = 1 - pred_flag ;\n else opposite = pred_flag ;\n }\n }\n else opposite = 0 ;\n if ( opposite ) {\n if ( a_valid && ! a_f ) {\n field_predA [ 0 ] = scaleforopp ( v , field_predA [ 0 ] , 0 , dir ) ;\n field_predA [ 1 ] = scaleforopp ( v , field_predA [ 1 ] , 1 , dir ) ;\n }\n if ( b_valid && ! b_f ) {\n field_predB [ 0 ] = scaleforopp ( v , field_predB [ 0 ] , 0 , dir ) ;\n field_predB [ 1 ] = scaleforopp ( v , field_predB [ 1 ] , 1 , dir ) ;\n }\n if ( c_valid && ! c_f ) {\n field_predC [ 0 ] = scaleforopp ( v , field_predC [ 0 ] , 0 , dir ) ;\n field_predC [ 1 ] = scaleforopp ( v , field_predC [ 1 ] , 1 , dir ) ;\n }\n v -> mv_f [ dir ] [ xy + v -> blocks_off ] = 1 ;\n v -> ref_field_type [ dir ] = ! v -> cur_field_type ;\n }\n else {\n if ( a_valid && a_f ) {\n field_predA [ 0 ] = scaleforsame ( v , n , field_predA [ 0 ] , 0 , dir ) ;\n field_predA [ 1 ] = scaleforsame ( v , n , field_predA [ 1 ] , 1 , dir ) ;\n }\n if ( b_valid && b_f ) {\n field_predB [ 0 ] = scaleforsame ( v , n , field_predB [ 0 ] , 0 , dir ) ;\n field_predB [ 1 ] = scaleforsame ( v , n , field_predB [ 1 ] , 1 , dir ) ;\n }\n if ( c_valid && c_f ) {\n field_predC [ 0 ] = scaleforsame ( v , n , field_predC [ 0 ] , 0 , dir ) ;\n field_predC [ 1 ] = scaleforsame ( v , n , field_predC [ 1 ] , 1 , dir ) ;\n }\n v -> mv_f [ dir ] [ xy + v -> blocks_off ] = 0 ;\n v -> ref_field_type [ dir ] = v -> cur_field_type ;\n }\n if ( a_valid ) {\n px = field_predA [ 0 ] ;\n py = field_predA [ 1 ] ;\n }\n else if ( c_valid ) {\n px = field_predC [ 0 ] ;\n py = field_predC [ 1 ] ;\n }\n else if ( b_valid ) {\n px = field_predB [ 0 ] ;\n py = field_predB [ 1 ] ;\n }\n else {\n px = 0 ;\n py = 0 ;\n }\n if ( num_samefield + num_oppfield > 1 ) {\n px = mid_pred ( field_predA [ 0 ] , field_predB [ 0 ] , field_predC [ 0 ] ) ;\n py = mid_pred ( field_predA [ 1 ] , field_predB [ 1 ] , field_predC [ 1 ] ) ;\n }\n if ( ! v -> field_mode ) {\n int qx , qy , X , Y ;\n qx = ( s -> mb_x << 6 ) + ( ( n == 1 || n == 3 ) ? 32 : 0 ) ;\n qy = ( s -> mb_y << 6 ) + ( ( n == 2 || n == 3 ) ? 32 : 0 ) ;\n X = ( s -> mb_width << 6 ) - 4 ;\n Y = ( s -> mb_height << 6 ) - 4 ;\n if ( mv1 ) {\n if ( qx + px < - 60 ) px = - 60 - qx ;\n if ( qy + py < - 60 ) py = - 60 - qy ;\n }\n else {\n if ( qx + px < - 28 ) px = - 28 - qx ;\n if ( qy + py < - 28 ) py = - 28 - qy ;\n }\n if ( qx + px > X ) px = X - qx ;\n if ( qy + py > Y ) py = Y - qy ;\n }\n if ( ! v -> field_mode || s -> pict_type != AV_PICTURE_TYPE_B ) {\n hybridmv_thresh = 32 ;\n if ( a_valid && c_valid ) {\n if ( is_intra [ xy - wrap ] ) sum = FFABS ( px ) + FFABS ( py ) ;\n else sum = FFABS ( px - field_predA [ 0 ] ) + FFABS ( py - field_predA [ 1 ] ) ;\n if ( sum > hybridmv_thresh ) {\n if ( get_bits1 ( & s -> gb ) ) {\n px = field_predA [ 0 ] ;\n py = field_predA [ 1 ] ;\n }\n else {\n px = field_predC [ 0 ] ;\n py = field_predC [ 1 ] ;\n }\n }\n else {\n if ( is_intra [ xy - 1 ] ) sum = FFABS ( px ) + FFABS ( py ) ;\n else sum = FFABS ( px - field_predC [ 0 ] ) + FFABS ( py - field_predC [ 1 ] ) ;\n if ( sum > hybridmv_thresh ) {\n if ( get_bits1 ( & s -> gb ) ) {\n px = field_predA [ 0 ] ;\n py = field_predA [ 1 ] ;\n }\n else {\n px = field_predC [ 0 ] ;\n py = field_predC [ 1 ] ;\n }\n }\n }\n }\n }\n if ( v -> field_mode && v -> numref ) r_y >>= 1 ;\n if ( v -> field_mode && v -> cur_field_type && v -> ref_field_type [ dir ] == 0 ) y_bias = 1 ;\n s -> mv [ dir ] [ n ] [ 0 ] = s -> current_picture . motion_val [ dir ] [ xy + v -> blocks_off ] [ 0 ] = ( ( px + dmv_x + r_x ) & ( ( r_x << 1 ) - 1 ) ) - r_x ;\n s -> mv [ dir ] [ n ] [ 1 ] = s -> current_picture . motion_val [ dir ] [ xy + v -> blocks_off ] [ 1 ] = ( ( py + dmv_y + r_y - y_bias ) & ( ( r_y << 1 ) - 1 ) ) - r_y + y_bias ;\n if ( mv1 ) {\n s -> current_picture . motion_val [ dir ] [ xy + 1 + v -> blocks_off ] [ 0 ] = s -> current_picture . motion_val [ dir ] [ xy + v -> blocks_off ] [ 0 ] ;\n s -> current_picture . motion_val [ dir ] [ xy + 1 + v -> blocks_off ] [ 1 ] = s -> current_picture . motion_val [ dir ] [ xy + v -> blocks_off ] [ 1 ] ;\n s -> current_picture . motion_val [ dir ] [ xy + wrap + v -> blocks_off ] [ 0 ] = s -> current_picture . motion_val [ dir ] [ xy + v -> blocks_off ] [ 0 ] ;\n s -> current_picture . motion_val [ dir ] [ xy + wrap + v -> blocks_off ] [ 1 ] = s -> current_picture . motion_val [ dir ] [ xy + v -> blocks_off ] [ 1 ] ;\n s -> current_picture . motion_val [ dir ] [ xy + wrap + 1 + v -> blocks_off ] [ 0 ] = s -> current_picture . motion_val [ dir ] [ xy + v -> blocks_off ] [ 0 ] ;\n s -> current_picture . motion_val [ dir ] [ xy + wrap + 1 + v -> blocks_off ] [ 1 ] = s -> current_picture . motion_val [ dir ] [ xy + v -> blocks_off ] [ 1 ] ;\n v -> mv_f [ dir ] [ xy + 1 + v -> blocks_off ] = v -> mv_f [ dir ] [ xy + v -> blocks_off ] ;\n v -> mv_f [ dir ] [ xy + wrap + v -> blocks_off ] = v -> mv_f [ dir ] [ xy + wrap + 1 + v -> blocks_off ] = v -> mv_f [ dir ] [ xy + v -> blocks_off ] ;\n }\n }", "idx": 1243}
{"hash": 3599206110384554647, "project": "debian", "size": 25, "label": 0, "functionSource": "static ossl_inline unsigned long lh_ ## type ## _num_items ( LHASH_OF ( type ) * lh ) {\n return OPENSSL_LH_num_items ( ( OPENSSL_LHASH * ) lh ) ;\n }\n static ossl_inline void lh_ ## type ## _node_stats_bio ( const LHASH_OF ( type ) * lh , BIO * out ) {\n OPENSSL_LH_node_stats_bio ( ( const OPENSSL_LHASH * ) lh , out ) ;\n }\n static ossl_inline void lh_ ## type ## _node_usage_stats_bio ( const LHASH_OF ( type ) * lh , BIO * out ) {\n OPENSSL_LH_node_usage_stats_bio ( ( const OPENSSL_LHASH * ) lh , out ) ;\n }\n static ossl_inline void lh_ ## type ## _stats_bio ( const LHASH_OF ( type ) * lh , BIO * out ) {\n OPENSSL_LH_stats_bio ( ( const OPENSSL_LHASH * ) lh , out ) ;\n }\n static ossl_inline unsigned long lh_ ## type ## _get_down_load ( LHASH_OF ( type ) * lh ) {\n return OPENSSL_LH_get_down_load ( ( OPENSSL_LHASH * ) lh ) ;\n }\n static ossl_inline void lh_ ## type ## _set_down_load ( LHASH_OF ( type ) * lh , unsigned long dl ) {\n OPENSSL_LH_set_down_load ( ( OPENSSL_LHASH * ) lh , dl ) ;\n }\n static ossl_inline void lh_ ## type ## _doall ( LHASH_OF ( type ) * lh , void ( * doall ) ( type * ) ) {\n OPENSSL_LH_doall ( ( OPENSSL_LHASH * ) lh , ( OPENSSL_LH_DOALL_FUNC ) doall ) ;\n }\n LHASH_OF ( type ) # define IMPLEMENT_LHASH_DOALL_ARG_CONST ( type , argtype ) int_implement_lhash_doall ( type , argtype , const type ) # define IMPLEMENT_LHASH_DOALL_ARG ( type , argtype ) int_implement_lhash_doall ( type , argtype , type ) # define int_implement_lhash_doall ( type , argtype , cbargtype ) static ossl_inline void lh_ ## type ## _doall_ ## argtype ( LHASH_OF ( type ) * lh , void ( * fn ) ( cbargtype * , argtype * ) , argtype * arg ) {\n OPENSSL_LH_doall_arg ( ( OPENSSL_LHASH * ) lh , ( OPENSSL_LH_DOALL_FUNCARG ) fn , ( void * ) arg ) ;\n }\n LHASH_OF ( type ) DEFINE_LHASH_OF ( OPENSSL_STRING )", "idx": 1244}
{"hash": 8801969307247112896, "project": "debian", "size": 415, "label": 0, "functionSource": "const EVP_CIPHER * EVP_aes_ ## keylen ## _ ## mode ( void ) \\ {\n return & aes_ ## keylen ## _ ## mode ;\n }\n # endif # if defined ( OPENSSL_CPUID_OBJ ) && ( defined ( __arm__ ) || defined ( __arm ) || defined ( __aarch64__ ) ) # include \"arm_arch.h\" # if __ARM_MAX_ARCH__ >= 7 # if defined ( BSAES_ASM ) # define BSAES_CAPABLE ( OPENSSL_armcap_P & ARMV7_NEON ) # endif # if defined ( VPAES_ASM ) # define VPAES_CAPABLE ( OPENSSL_armcap_P & ARMV7_NEON ) # endif # define HWAES_CAPABLE ( OPENSSL_armcap_P & ARMV8_AES ) # define HWAES_set_encrypt_key aes_v8_set_encrypt_key # define HWAES_set_decrypt_key aes_v8_set_decrypt_key # define HWAES_encrypt aes_v8_encrypt # define HWAES_decrypt aes_v8_decrypt # define HWAES_cbc_encrypt aes_v8_cbc_encrypt # define HWAES_ctr32_encrypt_blocks aes_v8_ctr32_encrypt_blocks # endif # endif # if defined ( HWAES_CAPABLE ) int HWAES_set_encrypt_key ( const unsigned char * userKey , const int bits , AES_KEY * key ) ;\n int HWAES_set_decrypt_key ( const unsigned char * userKey , const int bits , AES_KEY * key ) ;\n void HWAES_encrypt ( const unsigned char * in , unsigned char * out , const AES_KEY * key ) ;\n void HWAES_decrypt ( const unsigned char * in , unsigned char * out , const AES_KEY * key ) ;\n void HWAES_cbc_encrypt ( const unsigned char * in , unsigned char * out , size_t length , const AES_KEY * key , unsigned char * ivec , const int enc ) ;\n void HWAES_ctr32_encrypt_blocks ( const unsigned char * in , unsigned char * out , size_t len , const AES_KEY * key , const unsigned char ivec [ 16 ] ) ;\n void HWAES_xts_encrypt ( const unsigned char * inp , unsigned char * out , size_t len , const AES_KEY * key1 , const AES_KEY * key2 , const unsigned char iv [ 16 ] ) ;\n void HWAES_xts_decrypt ( const unsigned char * inp , unsigned char * out , size_t len , const AES_KEY * key1 , const AES_KEY * key2 , const unsigned char iv [ 16 ] ) ;\n # endif # define BLOCK_CIPHER_generic_pack ( nid , keylen , flags ) \\ BLOCK_CIPHER_generic ( nid , keylen , 16 , 16 , cbc , cbc , CBC , flags | EVP_CIPH_FLAG_DEFAULT_ASN1 ) \\ BLOCK_CIPHER_generic ( nid , keylen , 16 , 0 , ecb , ecb , ECB , flags | EVP_CIPH_FLAG_DEFAULT_ASN1 ) \\ BLOCK_CIPHER_generic ( nid , keylen , 1 , 16 , ofb128 , ofb , OFB , flags | EVP_CIPH_FLAG_DEFAULT_ASN1 ) \\ BLOCK_CIPHER_generic ( nid , keylen , 1 , 16 , cfb128 , cfb , CFB , flags | EVP_CIPH_FLAG_DEFAULT_ASN1 ) \\ BLOCK_CIPHER_generic ( nid , keylen , 1 , 16 , cfb1 , cfb1 , CFB , flags ) \\ BLOCK_CIPHER_generic ( nid , keylen , 1 , 16 , cfb8 , cfb8 , CFB , flags ) \\ BLOCK_CIPHER_generic ( nid , keylen , 1 , 16 , ctr , ctr , CTR , flags ) static int aes_init_key ( EVP_CIPHER_CTX * ctx , const unsigned char * key , const unsigned char * iv , int enc ) {\n int ret , mode ;\n EVP_AES_KEY * dat = EVP_C_DATA ( EVP_AES_KEY , ctx ) ;\n mode = EVP_CIPHER_CTX_mode ( ctx ) ;\n if ( ( mode == EVP_CIPH_ECB_MODE || mode == EVP_CIPH_CBC_MODE ) && ! enc ) {\n # ifdef HWAES_CAPABLE if ( HWAES_CAPABLE ) {\n ret = HWAES_set_decrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & dat -> ks . ks ) ;\n dat -> block = ( block128_f ) HWAES_decrypt ;\n dat -> stream . cbc = NULL ;\n # ifdef HWAES_cbc_encrypt if ( mode == EVP_CIPH_CBC_MODE ) dat -> stream . cbc = ( cbc128_f ) HWAES_cbc_encrypt ;\n # endif }\n else # endif # ifdef BSAES_CAPABLE if ( BSAES_CAPABLE && mode == EVP_CIPH_CBC_MODE ) {\n ret = AES_set_decrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & dat -> ks . ks ) ;\n dat -> block = ( block128_f ) AES_decrypt ;\n dat -> stream . cbc = ( cbc128_f ) bsaes_cbc_encrypt ;\n }\n else # endif # ifdef VPAES_CAPABLE if ( VPAES_CAPABLE ) {\n ret = vpaes_set_decrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & dat -> ks . ks ) ;\n dat -> block = ( block128_f ) vpaes_decrypt ;\n dat -> stream . cbc = mode == EVP_CIPH_CBC_MODE ? ( cbc128_f ) vpaes_cbc_encrypt : NULL ;\n }\n else # endif {\n ret = AES_set_decrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & dat -> ks . ks ) ;\n dat -> block = ( block128_f ) AES_decrypt ;\n dat -> stream . cbc = mode == EVP_CIPH_CBC_MODE ? ( cbc128_f ) AES_cbc_encrypt : NULL ;\n }\n }\n else # ifdef HWAES_CAPABLE if ( HWAES_CAPABLE ) {\n ret = HWAES_set_encrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & dat -> ks . ks ) ;\n dat -> block = ( block128_f ) HWAES_encrypt ;\n dat -> stream . cbc = NULL ;\n # ifdef HWAES_cbc_encrypt if ( mode == EVP_CIPH_CBC_MODE ) dat -> stream . cbc = ( cbc128_f ) HWAES_cbc_encrypt ;\n else # endif # ifdef HWAES_ctr32_encrypt_blocks if ( mode == EVP_CIPH_CTR_MODE ) dat -> stream . ctr = ( ctr128_f ) HWAES_ctr32_encrypt_blocks ;\n else # endif ( void ) 0 ;\n }\n else # endif # ifdef BSAES_CAPABLE if ( BSAES_CAPABLE && mode == EVP_CIPH_CTR_MODE ) {\n ret = AES_set_encrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & dat -> ks . ks ) ;\n dat -> block = ( block128_f ) AES_encrypt ;\n dat -> stream . ctr = ( ctr128_f ) bsaes_ctr32_encrypt_blocks ;\n }\n else # endif # ifdef VPAES_CAPABLE if ( VPAES_CAPABLE ) {\n ret = vpaes_set_encrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & dat -> ks . ks ) ;\n dat -> block = ( block128_f ) vpaes_encrypt ;\n dat -> stream . cbc = mode == EVP_CIPH_CBC_MODE ? ( cbc128_f ) vpaes_cbc_encrypt : NULL ;\n }\n else # endif {\n ret = AES_set_encrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & dat -> ks . ks ) ;\n dat -> block = ( block128_f ) AES_encrypt ;\n dat -> stream . cbc = mode == EVP_CIPH_CBC_MODE ? ( cbc128_f ) AES_cbc_encrypt : NULL ;\n # ifdef AES_CTR_ASM if ( mode == EVP_CIPH_CTR_MODE ) dat -> stream . ctr = ( ctr128_f ) AES_ctr32_encrypt ;\n # endif }\n if ( ret < 0 ) {\n EVPerr ( EVP_F_AES_INIT_KEY , EVP_R_AES_KEY_SETUP_FAILED ) ;\n return 0 ;\n }\n return 1 ;\n }\n static int aes_cbc_cipher ( EVP_CIPHER_CTX * ctx , unsigned char * out , const unsigned char * in , size_t len ) {\n EVP_AES_KEY * dat = EVP_C_DATA ( EVP_AES_KEY , ctx ) ;\n if ( dat -> stream . cbc ) ( * dat -> stream . cbc ) ( in , out , len , & dat -> ks , EVP_CIPHER_CTX_iv_noconst ( ctx ) , EVP_CIPHER_CTX_encrypting ( ctx ) ) ;\n else if ( EVP_CIPHER_CTX_encrypting ( ctx ) ) CRYPTO_cbc128_encrypt ( in , out , len , & dat -> ks , EVP_CIPHER_CTX_iv_noconst ( ctx ) , dat -> block ) ;\n else CRYPTO_cbc128_decrypt ( in , out , len , & dat -> ks , EVP_CIPHER_CTX_iv_noconst ( ctx ) , dat -> block ) ;\n return 1 ;\n }\n static int aes_ecb_cipher ( EVP_CIPHER_CTX * ctx , unsigned char * out , const unsigned char * in , size_t len ) {\n size_t bl = EVP_CIPHER_CTX_block_size ( ctx ) ;\n size_t i ;\n EVP_AES_KEY * dat = EVP_C_DATA ( EVP_AES_KEY , ctx ) ;\n if ( len < bl ) return 1 ;\n for ( i = 0 , len -= bl ;\n i <= len ;\n i += bl ) ( * dat -> block ) ( in + i , out + i , & dat -> ks ) ;\n return 1 ;\n }\n static int aes_ofb_cipher ( EVP_CIPHER_CTX * ctx , unsigned char * out , const unsigned char * in , size_t len ) {\n EVP_AES_KEY * dat = EVP_C_DATA ( EVP_AES_KEY , ctx ) ;\n int num = EVP_CIPHER_CTX_num ( ctx ) ;\n CRYPTO_ofb128_encrypt ( in , out , len , & dat -> ks , EVP_CIPHER_CTX_iv_noconst ( ctx ) , & num , dat -> block ) ;\n EVP_CIPHER_CTX_set_num ( ctx , num ) ;\n return 1 ;\n }\n static int aes_cfb_cipher ( EVP_CIPHER_CTX * ctx , unsigned char * out , const unsigned char * in , size_t len ) {\n EVP_AES_KEY * dat = EVP_C_DATA ( EVP_AES_KEY , ctx ) ;\n int num = EVP_CIPHER_CTX_num ( ctx ) ;\n CRYPTO_cfb128_encrypt ( in , out , len , & dat -> ks , EVP_CIPHER_CTX_iv_noconst ( ctx ) , & num , EVP_CIPHER_CTX_encrypting ( ctx ) , dat -> block ) ;\n EVP_CIPHER_CTX_set_num ( ctx , num ) ;\n return 1 ;\n }\n static int aes_cfb8_cipher ( EVP_CIPHER_CTX * ctx , unsigned char * out , const unsigned char * in , size_t len ) {\n EVP_AES_KEY * dat = EVP_C_DATA ( EVP_AES_KEY , ctx ) ;\n int num = EVP_CIPHER_CTX_num ( ctx ) ;\n CRYPTO_cfb128_8_encrypt ( in , out , len , & dat -> ks , EVP_CIPHER_CTX_iv_noconst ( ctx ) , & num , EVP_CIPHER_CTX_encrypting ( ctx ) , dat -> block ) ;\n EVP_CIPHER_CTX_set_num ( ctx , num ) ;\n return 1 ;\n }\n static int aes_cfb1_cipher ( EVP_CIPHER_CTX * ctx , unsigned char * out , const unsigned char * in , size_t len ) {\n EVP_AES_KEY * dat = EVP_C_DATA ( EVP_AES_KEY , ctx ) ;\n if ( EVP_CIPHER_CTX_test_flags ( ctx , EVP_CIPH_FLAG_LENGTH_BITS ) ) {\n int num = EVP_CIPHER_CTX_num ( ctx ) ;\n CRYPTO_cfb128_1_encrypt ( in , out , len , & dat -> ks , EVP_CIPHER_CTX_iv_noconst ( ctx ) , & num , EVP_CIPHER_CTX_encrypting ( ctx ) , dat -> block ) ;\n EVP_CIPHER_CTX_set_num ( ctx , num ) ;\n return 1 ;\n }\n while ( len >= MAXBITCHUNK ) {\n int num = EVP_CIPHER_CTX_num ( ctx ) ;\n CRYPTO_cfb128_1_encrypt ( in , out , MAXBITCHUNK * 8 , & dat -> ks , EVP_CIPHER_CTX_iv_noconst ( ctx ) , & num , EVP_CIPHER_CTX_encrypting ( ctx ) , dat -> block ) ;\n EVP_CIPHER_CTX_set_num ( ctx , num ) ;\n len -= MAXBITCHUNK ;\n }\n if ( len ) {\n int num = EVP_CIPHER_CTX_num ( ctx ) ;\n CRYPTO_cfb128_1_encrypt ( in , out , len * 8 , & dat -> ks , EVP_CIPHER_CTX_iv_noconst ( ctx ) , & num , EVP_CIPHER_CTX_encrypting ( ctx ) , dat -> block ) ;\n EVP_CIPHER_CTX_set_num ( ctx , num ) ;\n }\n return 1 ;\n }\n static int aes_ctr_cipher ( EVP_CIPHER_CTX * ctx , unsigned char * out , const unsigned char * in , size_t len ) {\n unsigned int num = EVP_CIPHER_CTX_num ( ctx ) ;\n EVP_AES_KEY * dat = EVP_C_DATA ( EVP_AES_KEY , ctx ) ;\n if ( dat -> stream . ctr ) CRYPTO_ctr128_encrypt_ctr32 ( in , out , len , & dat -> ks , EVP_CIPHER_CTX_iv_noconst ( ctx ) , EVP_CIPHER_CTX_buf_noconst ( ctx ) , & num , dat -> stream . ctr ) ;\n else CRYPTO_ctr128_encrypt ( in , out , len , & dat -> ks , EVP_CIPHER_CTX_iv_noconst ( ctx ) , EVP_CIPHER_CTX_buf_noconst ( ctx ) , & num , dat -> block ) ;\n EVP_CIPHER_CTX_set_num ( ctx , num ) ;\n return 1 ;\n }\n BLOCK_CIPHER_generic_pack ( NID_aes , 128 , 0 ) BLOCK_CIPHER_generic_pack ( NID_aes , 192 , 0 ) BLOCK_CIPHER_generic_pack ( NID_aes , 256 , 0 ) static int aes_gcm_cleanup ( EVP_CIPHER_CTX * c ) {\n EVP_AES_GCM_CTX * gctx = EVP_C_DATA ( EVP_AES_GCM_CTX , c ) ;\n OPENSSL_cleanse ( & gctx -> gcm , sizeof ( gctx -> gcm ) ) ;\n if ( gctx -> iv != EVP_CIPHER_CTX_iv_noconst ( c ) ) OPENSSL_free ( gctx -> iv ) ;\n return 1 ;\n }\n static void ctr64_inc ( unsigned char * counter ) {\n int n = 8 ;\n unsigned char c ;\n do {\n -- n ;\n c = counter [ n ] ;\n ++ c ;\n counter [ n ] = c ;\n if ( c ) return ;\n }\n while ( n ) ;\n }\n static int aes_gcm_ctrl ( EVP_CIPHER_CTX * c , int type , int arg , void * ptr ) {\n EVP_AES_GCM_CTX * gctx = EVP_C_DATA ( EVP_AES_GCM_CTX , c ) ;\n switch ( type ) {\n case EVP_CTRL_INIT : gctx -> key_set = 0 ;\n gctx -> iv_set = 0 ;\n gctx -> ivlen = EVP_CIPHER_CTX_iv_length ( c ) ;\n gctx -> iv = EVP_CIPHER_CTX_iv_noconst ( c ) ;\n gctx -> taglen = - 1 ;\n gctx -> iv_gen = 0 ;\n gctx -> tls_aad_len = - 1 ;\n return 1 ;\n case EVP_CTRL_AEAD_SET_IVLEN : if ( arg <= 0 ) return 0 ;\n if ( ( arg > EVP_MAX_IV_LENGTH ) && ( arg > gctx -> ivlen ) ) {\n if ( gctx -> iv != EVP_CIPHER_CTX_iv_noconst ( c ) ) OPENSSL_free ( gctx -> iv ) ;\n gctx -> iv = OPENSSL_malloc ( arg ) ;\n if ( gctx -> iv == NULL ) return 0 ;\n }\n gctx -> ivlen = arg ;\n return 1 ;\n case EVP_CTRL_AEAD_SET_TAG : if ( arg <= 0 || arg > 16 || EVP_CIPHER_CTX_encrypting ( c ) ) return 0 ;\n memcpy ( EVP_CIPHER_CTX_buf_noconst ( c ) , ptr , arg ) ;\n gctx -> taglen = arg ;\n return 1 ;\n case EVP_CTRL_AEAD_GET_TAG : if ( arg <= 0 || arg > 16 || ! EVP_CIPHER_CTX_encrypting ( c ) || gctx -> taglen < 0 ) return 0 ;\n memcpy ( ptr , EVP_CIPHER_CTX_buf_noconst ( c ) , arg ) ;\n return 1 ;\n case EVP_CTRL_GCM_SET_IV_FIXED : if ( arg == - 1 ) {\n memcpy ( gctx -> iv , ptr , gctx -> ivlen ) ;\n gctx -> iv_gen = 1 ;\n return 1 ;\n }\n if ( ( arg < 4 ) || ( gctx -> ivlen - arg ) < 8 ) return 0 ;\n if ( arg ) memcpy ( gctx -> iv , ptr , arg ) ;\n if ( EVP_CIPHER_CTX_encrypting ( c ) && RAND_bytes ( gctx -> iv + arg , gctx -> ivlen - arg ) <= 0 ) return 0 ;\n gctx -> iv_gen = 1 ;\n return 1 ;\n case EVP_CTRL_GCM_IV_GEN : if ( gctx -> iv_gen == 0 || gctx -> key_set == 0 ) return 0 ;\n CRYPTO_gcm128_setiv ( & gctx -> gcm , gctx -> iv , gctx -> ivlen ) ;\n if ( arg <= 0 || arg > gctx -> ivlen ) arg = gctx -> ivlen ;\n memcpy ( ptr , gctx -> iv + gctx -> ivlen - arg , arg ) ;\n ctr64_inc ( gctx -> iv + gctx -> ivlen - 8 ) ;\n gctx -> iv_set = 1 ;\n return 1 ;\n case EVP_CTRL_GCM_SET_IV_INV : if ( gctx -> iv_gen == 0 || gctx -> key_set == 0 || EVP_CIPHER_CTX_encrypting ( c ) ) return 0 ;\n memcpy ( gctx -> iv + gctx -> ivlen - arg , ptr , arg ) ;\n CRYPTO_gcm128_setiv ( & gctx -> gcm , gctx -> iv , gctx -> ivlen ) ;\n gctx -> iv_set = 1 ;\n return 1 ;\n case EVP_CTRL_AEAD_TLS1_AAD : if ( arg != EVP_AEAD_TLS1_AAD_LEN ) return 0 ;\n memcpy ( EVP_CIPHER_CTX_buf_noconst ( c ) , ptr , arg ) ;\n gctx -> tls_aad_len = arg ;\n {\n unsigned int len = EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 2 ] << 8 | EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 1 ] ;\n if ( len < EVP_GCM_TLS_EXPLICIT_IV_LEN ) return 0 ;\n len -= EVP_GCM_TLS_EXPLICIT_IV_LEN ;\n if ( ! EVP_CIPHER_CTX_encrypting ( c ) ) {\n if ( len < EVP_GCM_TLS_TAG_LEN ) return 0 ;\n len -= EVP_GCM_TLS_TAG_LEN ;\n }\n EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 2 ] = len >> 8 ;\n EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 1 ] = len & 0xff ;\n }\n return EVP_GCM_TLS_TAG_LEN ;\n case EVP_CTRL_COPY : {\n EVP_CIPHER_CTX * out = ptr ;\n EVP_AES_GCM_CTX * gctx_out = EVP_C_DATA ( EVP_AES_GCM_CTX , out ) ;\n if ( gctx -> gcm . key ) {\n if ( gctx -> gcm . key != & gctx -> ks ) return 0 ;\n gctx_out -> gcm . key = & gctx_out -> ks ;\n }\n if ( gctx -> iv == EVP_CIPHER_CTX_iv_noconst ( c ) ) gctx_out -> iv = EVP_CIPHER_CTX_iv_noconst ( out ) ;\n else {\n gctx_out -> iv = OPENSSL_malloc ( gctx -> ivlen ) ;\n if ( gctx_out -> iv == NULL ) return 0 ;\n memcpy ( gctx_out -> iv , gctx -> iv , gctx -> ivlen ) ;\n }\n return 1 ;\n }\n default : return - 1 ;\n }\n }\n static int aes_gcm_init_key ( EVP_CIPHER_CTX * ctx , const unsigned char * key , const unsigned char * iv , int enc ) {\n EVP_AES_GCM_CTX * gctx = EVP_C_DATA ( EVP_AES_GCM_CTX , ctx ) ;\n if ( ! iv && ! key ) return 1 ;\n if ( key ) {\n do {\n # ifdef HWAES_CAPABLE if ( HWAES_CAPABLE ) {\n HWAES_set_encrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & gctx -> ks . ks ) ;\n CRYPTO_gcm128_init ( & gctx -> gcm , & gctx -> ks , ( block128_f ) HWAES_encrypt ) ;\n # ifdef HWAES_ctr32_encrypt_blocks gctx -> ctr = ( ctr128_f ) HWAES_ctr32_encrypt_blocks ;\n # else gctx -> ctr = NULL ;\n # endif break ;\n }\n else # endif # ifdef BSAES_CAPABLE if ( BSAES_CAPABLE ) {\n AES_set_encrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & gctx -> ks . ks ) ;\n CRYPTO_gcm128_init ( & gctx -> gcm , & gctx -> ks , ( block128_f ) AES_encrypt ) ;\n gctx -> ctr = ( ctr128_f ) bsaes_ctr32_encrypt_blocks ;\n break ;\n }\n else # endif # ifdef VPAES_CAPABLE if ( VPAES_CAPABLE ) {\n vpaes_set_encrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & gctx -> ks . ks ) ;\n CRYPTO_gcm128_init ( & gctx -> gcm , & gctx -> ks , ( block128_f ) vpaes_encrypt ) ;\n gctx -> ctr = NULL ;\n break ;\n }\n else # endif ( void ) 0 ;\n AES_set_encrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & gctx -> ks . ks ) ;\n CRYPTO_gcm128_init ( & gctx -> gcm , & gctx -> ks , ( block128_f ) AES_encrypt ) ;\n # ifdef AES_CTR_ASM gctx -> ctr = ( ctr128_f ) AES_ctr32_encrypt ;\n # else gctx -> ctr = NULL ;\n # endif }\n while ( 0 ) ;\n if ( iv == NULL && gctx -> iv_set ) iv = gctx -> iv ;\n if ( iv ) {\n CRYPTO_gcm128_setiv ( & gctx -> gcm , iv , gctx -> ivlen ) ;\n gctx -> iv_set = 1 ;\n }\n gctx -> key_set = 1 ;\n }\n else {\n if ( gctx -> key_set ) CRYPTO_gcm128_setiv ( & gctx -> gcm , iv , gctx -> ivlen ) ;\n else memcpy ( gctx -> iv , iv , gctx -> ivlen ) ;\n gctx -> iv_set = 1 ;\n gctx -> iv_gen = 0 ;\n }\n return 1 ;\n }\n static int aes_gcm_tls_cipher ( EVP_CIPHER_CTX * ctx , unsigned char * out , const unsigned char * in , size_t len ) {\n EVP_AES_GCM_CTX * gctx = EVP_C_DATA ( EVP_AES_GCM_CTX , ctx ) ;\n int rv = - 1 ;\n if ( out != in || len < ( EVP_GCM_TLS_EXPLICIT_IV_LEN + EVP_GCM_TLS_TAG_LEN ) ) return - 1 ;\n if ( EVP_CIPHER_CTX_ctrl ( ctx , EVP_CIPHER_CTX_encrypting ( ctx ) ? EVP_CTRL_GCM_IV_GEN : EVP_CTRL_GCM_SET_IV_INV , EVP_GCM_TLS_EXPLICIT_IV_LEN , out ) <= 0 ) goto err ;\n if ( CRYPTO_gcm128_aad ( & gctx -> gcm , EVP_CIPHER_CTX_buf_noconst ( ctx ) , gctx -> tls_aad_len ) ) goto err ;\n in += EVP_GCM_TLS_EXPLICIT_IV_LEN ;\n out += EVP_GCM_TLS_EXPLICIT_IV_LEN ;\n len -= EVP_GCM_TLS_EXPLICIT_IV_LEN + EVP_GCM_TLS_TAG_LEN ;\n if ( EVP_CIPHER_CTX_encrypting ( ctx ) ) {\n if ( gctx -> ctr ) {\n size_t bulk = 0 ;\n # if defined ( AES_GCM_ASM ) if ( len >= 32 && AES_GCM_ASM ( gctx ) ) {\n if ( CRYPTO_gcm128_encrypt ( & gctx -> gcm , NULL , NULL , 0 ) ) return - 1 ;\n bulk = AES_gcm_encrypt ( in , out , len , gctx -> gcm . key , gctx -> gcm . Yi . c , gctx -> gcm . Xi . u ) ;\n gctx -> gcm . len . u [ 1 ] += bulk ;\n }\n # endif if ( CRYPTO_gcm128_encrypt_ctr32 ( & gctx -> gcm , in + bulk , out + bulk , len - bulk , gctx -> ctr ) ) goto err ;\n }\n else {\n size_t bulk = 0 ;\n # if defined ( AES_GCM_ASM2 ) if ( len >= 32 && AES_GCM_ASM2 ( gctx ) ) {\n if ( CRYPTO_gcm128_encrypt ( & gctx -> gcm , NULL , NULL , 0 ) ) return - 1 ;\n bulk = AES_gcm_encrypt ( in , out , len , gctx -> gcm . key , gctx -> gcm . Yi . c , gctx -> gcm . Xi . u ) ;\n gctx -> gcm . len . u [ 1 ] += bulk ;\n }\n # endif if ( CRYPTO_gcm128_encrypt ( & gctx -> gcm , in + bulk , out + bulk , len - bulk ) ) goto err ;\n }\n out += len ;\n CRYPTO_gcm128_tag ( & gctx -> gcm , out , EVP_GCM_TLS_TAG_LEN ) ;\n rv = len + EVP_GCM_TLS_EXPLICIT_IV_LEN + EVP_GCM_TLS_TAG_LEN ;\n }\n else {\n if ( gctx -> ctr ) {\n size_t bulk = 0 ;\n # if defined ( AES_GCM_ASM ) if ( len >= 16 && AES_GCM_ASM ( gctx ) ) {\n if ( CRYPTO_gcm128_decrypt ( & gctx -> gcm , NULL , NULL , 0 ) ) return - 1 ;\n bulk = AES_gcm_decrypt ( in , out , len , gctx -> gcm . key , gctx -> gcm . Yi . c , gctx -> gcm . Xi . u ) ;\n gctx -> gcm . len . u [ 1 ] += bulk ;\n }\n # endif if ( CRYPTO_gcm128_decrypt_ctr32 ( & gctx -> gcm , in + bulk , out + bulk , len - bulk , gctx -> ctr ) ) goto err ;\n }\n else {\n size_t bulk = 0 ;\n # if defined ( AES_GCM_ASM2 ) if ( len >= 16 && AES_GCM_ASM2 ( gctx ) ) {\n if ( CRYPTO_gcm128_decrypt ( & gctx -> gcm , NULL , NULL , 0 ) ) return - 1 ;\n bulk = AES_gcm_decrypt ( in , out , len , gctx -> gcm . key , gctx -> gcm . Yi . c , gctx -> gcm . Xi . u ) ;\n gctx -> gcm . len . u [ 1 ] += bulk ;\n }\n # endif if ( CRYPTO_gcm128_decrypt ( & gctx -> gcm , in + bulk , out + bulk , len - bulk ) ) goto err ;\n }\n CRYPTO_gcm128_tag ( & gctx -> gcm , EVP_CIPHER_CTX_buf_noconst ( ctx ) , EVP_GCM_TLS_TAG_LEN ) ;\n if ( CRYPTO_memcmp ( EVP_CIPHER_CTX_buf_noconst ( ctx ) , in + len , EVP_GCM_TLS_TAG_LEN ) ) {\n OPENSSL_cleanse ( out , len ) ;\n goto err ;\n }\n rv = len ;\n }\n err : gctx -> iv_set = 0 ;\n gctx -> tls_aad_len = - 1 ;\n return rv ;\n }\n static int aes_gcm_cipher ( EVP_CIPHER_CTX * ctx , unsigned char * out , const unsigned char * in , size_t len ) {\n EVP_AES_GCM_CTX * gctx = EVP_C_DATA ( EVP_AES_GCM_CTX , ctx ) ;\n if ( ! gctx -> key_set ) return - 1 ;\n if ( gctx -> tls_aad_len >= 0 ) return aes_gcm_tls_cipher ( ctx , out , in , len ) ;\n if ( ! gctx -> iv_set ) return - 1 ;\n if ( in ) {\n if ( out == NULL ) {\n if ( CRYPTO_gcm128_aad ( & gctx -> gcm , in , len ) ) return - 1 ;\n }\n else if ( EVP_CIPHER_CTX_encrypting ( ctx ) ) {\n if ( gctx -> ctr ) {\n size_t bulk = 0 ;\n # if defined ( AES_GCM_ASM ) if ( len >= 32 && AES_GCM_ASM ( gctx ) ) {\n size_t res = ( 16 - gctx -> gcm . mres ) % 16 ;\n if ( CRYPTO_gcm128_encrypt ( & gctx -> gcm , in , out , res ) ) return - 1 ;\n bulk = AES_gcm_encrypt ( in + res , out + res , len - res , gctx -> gcm . key , gctx -> gcm . Yi . c , gctx -> gcm . Xi . u ) ;\n gctx -> gcm . len . u [ 1 ] += bulk ;\n bulk += res ;\n }\n # endif if ( CRYPTO_gcm128_encrypt_ctr32 ( & gctx -> gcm , in + bulk , out + bulk , len - bulk , gctx -> ctr ) ) return - 1 ;\n }\n else {\n size_t bulk = 0 ;\n # if defined ( AES_GCM_ASM2 ) if ( len >= 32 && AES_GCM_ASM2 ( gctx ) ) {\n size_t res = ( 16 - gctx -> gcm . mres ) % 16 ;\n if ( CRYPTO_gcm128_encrypt ( & gctx -> gcm , in , out , res ) ) return - 1 ;\n bulk = AES_gcm_encrypt ( in + res , out + res , len - res , gctx -> gcm . key , gctx -> gcm . Yi . c , gctx -> gcm . Xi . u ) ;\n gctx -> gcm . len . u [ 1 ] += bulk ;\n bulk += res ;\n }\n # endif if ( CRYPTO_gcm128_encrypt ( & gctx -> gcm , in + bulk , out + bulk , len - bulk ) ) return - 1 ;\n }\n }\n else {\n if ( gctx -> ctr ) {\n size_t bulk = 0 ;\n # if defined ( AES_GCM_ASM ) if ( len >= 16 && AES_GCM_ASM ( gctx ) ) {\n size_t res = ( 16 - gctx -> gcm . mres ) % 16 ;\n if ( CRYPTO_gcm128_decrypt ( & gctx -> gcm , in , out , res ) ) return - 1 ;\n bulk = AES_gcm_decrypt ( in + res , out + res , len - res , gctx -> gcm . key , gctx -> gcm . Yi . c , gctx -> gcm . Xi . u ) ;\n gctx -> gcm . len . u [ 1 ] += bulk ;\n bulk += res ;\n }\n # endif if ( CRYPTO_gcm128_decrypt_ctr32 ( & gctx -> gcm , in + bulk , out + bulk , len - bulk , gctx -> ctr ) ) return - 1 ;\n }\n else {\n size_t bulk = 0 ;\n # if defined ( AES_GCM_ASM2 ) if ( len >= 16 && AES_GCM_ASM2 ( gctx ) ) {\n size_t res = ( 16 - gctx -> gcm . mres ) % 16 ;\n if ( CRYPTO_gcm128_decrypt ( & gctx -> gcm , in , out , res ) ) return - 1 ;\n bulk = AES_gcm_decrypt ( in + res , out + res , len - res , gctx -> gcm . key , gctx -> gcm . Yi . c , gctx -> gcm . Xi . u ) ;\n gctx -> gcm . len . u [ 1 ] += bulk ;\n bulk += res ;\n }\n # endif if ( CRYPTO_gcm128_decrypt ( & gctx -> gcm , in + bulk , out + bulk , len - bulk ) ) return - 1 ;\n }\n }\n return len ;\n }\n else {\n if ( ! EVP_CIPHER_CTX_encrypting ( ctx ) ) {\n if ( gctx -> taglen < 0 ) return - 1 ;\n if ( CRYPTO_gcm128_finish ( & gctx -> gcm , EVP_CIPHER_CTX_buf_noconst ( ctx ) , gctx -> taglen ) != 0 ) return - 1 ;\n gctx -> iv_set = 0 ;\n return 0 ;\n }\n CRYPTO_gcm128_tag ( & gctx -> gcm , EVP_CIPHER_CTX_buf_noconst ( ctx ) , 16 ) ;\n gctx -> taglen = 16 ;\n gctx -> iv_set = 0 ;\n return 0 ;\n }\n }\n # define CUSTOM_FLAGS ( EVP_CIPH_FLAG_DEFAULT_ASN1 \\ | EVP_CIPH_CUSTOM_IV | EVP_CIPH_FLAG_CUSTOM_CIPHER \\ | EVP_CIPH_ALWAYS_CALL_INIT | EVP_CIPH_CTRL_INIT \\ | EVP_CIPH_CUSTOM_COPY ) BLOCK_CIPHER_custom ( NID_aes , 128 , 1 , 12 , gcm , GCM , EVP_CIPH_FLAG_AEAD_CIPHER | CUSTOM_FLAGS ) BLOCK_CIPHER_custom ( NID_aes , 192 , 1 , 12 , gcm , GCM , EVP_CIPH_FLAG_AEAD_CIPHER | CUSTOM_FLAGS ) BLOCK_CIPHER_custom ( NID_aes , 256 , 1 , 12 , gcm , GCM , EVP_CIPH_FLAG_AEAD_CIPHER | CUSTOM_FLAGS )", "idx": 1245}
{"hash": -2222463888415249941, "project": "chrome", "size": 19, "label": 0, "functionSource": "void vp9_apply_encoding_flags ( VP9_COMP * cpi , vpx_enc_frame_flags_t flags ) {\n if ( flags & ( VP8_EFLAG_NO_REF_LAST | VP8_EFLAG_NO_REF_GF | VP8_EFLAG_NO_REF_ARF ) ) {\n int ref = 7 ;\n if ( flags & VP8_EFLAG_NO_REF_LAST ) ref ^= VP9_LAST_FLAG ;\n if ( flags & VP8_EFLAG_NO_REF_GF ) ref ^= VP9_GOLD_FLAG ;\n if ( flags & VP8_EFLAG_NO_REF_ARF ) ref ^= VP9_ALT_FLAG ;\n vp9_use_as_reference ( cpi , ref ) ;\n }\n if ( flags & ( VP8_EFLAG_NO_UPD_LAST | VP8_EFLAG_NO_UPD_GF | VP8_EFLAG_NO_UPD_ARF | VP8_EFLAG_FORCE_GF | VP8_EFLAG_FORCE_ARF ) ) {\n int upd = 7 ;\n if ( flags & VP8_EFLAG_NO_UPD_LAST ) upd ^= VP9_LAST_FLAG ;\n if ( flags & VP8_EFLAG_NO_UPD_GF ) upd ^= VP9_GOLD_FLAG ;\n if ( flags & VP8_EFLAG_NO_UPD_ARF ) upd ^= VP9_ALT_FLAG ;\n vp9_update_reference ( cpi , upd ) ;\n }\n if ( flags & VP8_EFLAG_NO_UPD_ENTROPY ) {\n vp9_update_entropy ( cpi , 0 ) ;\n }\n }", "idx": 1246}
{"hash": 1760449185745615462, "project": "debian", "size": 20, "label": 0, "functionSource": "TSReturnCode TSHttpTxnPristineUrlGet ( TSHttpTxn txnp , TSMBuffer * bufp , TSMLoc * url_loc ) {\n sdk_assert ( sdk_sanity_check_txn ( txnp ) == TS_SUCCESS ) ;\n sdk_assert ( sdk_sanity_check_null_ptr ( ( void * ) bufp ) == TS_SUCCESS ) ;\n sdk_assert ( sdk_sanity_check_null_ptr ( ( void * ) url_loc ) == TS_SUCCESS ) ;\n HttpSM * sm = ( HttpSM * ) txnp ;\n HTTPHdr * hptr = & ( sm -> t_state . hdr_info . client_request ) ;\n if ( hptr -> valid ( ) ) {\n * ( reinterpret_cast < HTTPHdr * * > ( bufp ) ) = hptr ;\n * url_loc = ( TSMLoc ) sm -> t_state . unmapped_url . m_url_impl ;\n if ( sdk_sanity_check_mbuffer ( * bufp ) == TS_SUCCESS ) {\n if ( * url_loc == nullptr ) {\n * url_loc = ( TSMLoc ) hptr -> m_http -> u . req . m_url_impl ;\n }\n if ( * url_loc ) {\n return TS_SUCCESS ;\n }\n }\n }\n return TS_ERROR ;\n }", "idx": 1247}
{"hash": 2895622461494525400, "project": "debian", "size": 60, "label": 0, "functionSource": "static void test_bug1180 ( ) {\n MYSQL_STMT * stmt ;\n int rc ;\n MYSQL_BIND my_bind [ 1 ] ;\n ulong length [ 1 ] ;\n char szData [ 11 ] ;\n char query [ MAX_TEST_QUERY_LENGTH ] ;\n myheader ( \"test_select_bug\" ) ;\n rc = mysql_query ( mysql , \"DROP TABLE IF EXISTS test_select\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"CREATE TABLE test_select(session_id char(9) NOT NULL)\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"INSERT INTO test_select VALUES (\\\"abc\\\")\" ) ;\n myquery ( rc ) ;\n strmov ( query , \"SELECT * FROM test_select WHERE ?= \\\"1111\\\" and \" \"session_id= \\\"abc\\\"\" ) ;\n stmt = mysql_simple_prepare ( mysql , query ) ;\n check_stmt ( stmt ) ;\n verify_param_count ( stmt , 1 ) ;\n memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n strmov ( szData , ( char * ) \"abc\" ) ;\n my_bind [ 0 ] . buffer_type = MYSQL_TYPE_STRING ;\n my_bind [ 0 ] . buffer = ( void * ) szData ;\n my_bind [ 0 ] . buffer_length = 10 ;\n my_bind [ 0 ] . length = & length [ 0 ] ;\n length [ 0 ] = 3 ;\n my_bind [ 0 ] . is_null = 0 ;\n rc = mysql_stmt_bind_param ( stmt , my_bind ) ;\n check_execute ( stmt , rc ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n rc = my_process_stmt_result ( stmt ) ;\n DIE_UNLESS ( rc == 0 ) ;\n strmov ( szData , ( char * ) \"1111\" ) ;\n my_bind [ 0 ] . buffer_type = MYSQL_TYPE_STRING ;\n my_bind [ 0 ] . buffer = ( void * ) szData ;\n my_bind [ 0 ] . buffer_length = 10 ;\n my_bind [ 0 ] . length = & length [ 0 ] ;\n length [ 0 ] = 4 ;\n my_bind [ 0 ] . is_null = 0 ;\n rc = mysql_stmt_bind_param ( stmt , my_bind ) ;\n check_execute ( stmt , rc ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n rc = my_process_stmt_result ( stmt ) ;\n DIE_UNLESS ( rc == 1 ) ;\n strmov ( szData , ( char * ) \"abc\" ) ;\n my_bind [ 0 ] . buffer_type = MYSQL_TYPE_STRING ;\n my_bind [ 0 ] . buffer = ( void * ) szData ;\n my_bind [ 0 ] . buffer_length = 10 ;\n my_bind [ 0 ] . length = & length [ 0 ] ;\n length [ 0 ] = 3 ;\n my_bind [ 0 ] . is_null = 0 ;\n rc = mysql_stmt_bind_param ( stmt , my_bind ) ;\n check_execute ( stmt , rc ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n rc = my_process_stmt_result ( stmt ) ;\n DIE_UNLESS ( rc == 0 ) ;\n mysql_stmt_close ( stmt ) ;\n }", "idx": 1248}
{"hash": -2323311514228246061, "project": "chrome", "size": 3, "label": 0, "functionSource": "ASSERT_TRUE ( WaitFor ( downloads : : OnDeterminingFilename : : kEventName , base : : StringPrintf ( R \"([{\n\" id \": %d, \" filename \": \" slow . txt \"}\n])\" , result_id ) ) )", "idx": 1249}
{"hash": -938099838013462850, "project": "debian", "size": 21, "label": 0, "functionSource": "static SchroBuffer * find_next_parse_unit ( SchroParseUnitContext * parse_ctx ) {\n SchroBuffer * enc_buf = NULL ;\n int next_pu_offset = 0 ;\n unsigned char * in_buf ;\n if ( parse_ctx -> buf_size < 13 || parse_ctx -> buf [ 0 ] != 'B' || parse_ctx -> buf [ 1 ] != 'B' || parse_ctx -> buf [ 2 ] != 'C' || parse_ctx -> buf [ 3 ] != 'D' ) return NULL ;\n next_pu_offset = ( parse_ctx -> buf [ 5 ] << 24 ) + ( parse_ctx -> buf [ 6 ] << 16 ) + ( parse_ctx -> buf [ 7 ] << 8 ) + parse_ctx -> buf [ 8 ] ;\n if ( next_pu_offset == 0 && SCHRO_PARSE_CODE_IS_END_OF_SEQUENCE ( parse_ctx -> buf [ 4 ] ) ) next_pu_offset = 13 ;\n if ( next_pu_offset <= 0 || parse_ctx -> buf_size < next_pu_offset ) return NULL ;\n in_buf = av_malloc ( next_pu_offset ) ;\n if ( ! in_buf ) {\n av_log ( parse_ctx , AV_LOG_ERROR , \"Unable to allocate input buffer\\n\" ) ;\n return NULL ;\n }\n memcpy ( in_buf , parse_ctx -> buf , next_pu_offset ) ;\n enc_buf = schro_buffer_new_with_data ( in_buf , next_pu_offset ) ;\n enc_buf -> free = libschroedinger_decode_buffer_free ;\n enc_buf -> priv = in_buf ;\n parse_ctx -> buf += next_pu_offset ;\n parse_ctx -> buf_size -= next_pu_offset ;\n return enc_buf ;\n }", "idx": 1250}
{"hash": 6323824267898511453, "project": "debian", "size": 99, "label": 0, "functionSource": "static void fast_rgb_to_bgr ( fz_context * ctx , fz_pixmap * dst , fz_pixmap * src , fz_colorspace * prf , const fz_default_colorspaces * default_cs , const fz_color_params * color_params , int copy_spots ) {\n unsigned char * s = src -> samples ;\n unsigned char * d = dst -> samples ;\n size_t w = src -> w ;\n int h = src -> h ;\n int sn = src -> n ;\n int ss = src -> s ;\n int sa = src -> alpha ;\n int dn = dst -> n ;\n int ds = dst -> s ;\n int da = dst -> alpha ;\n ptrdiff_t d_line_inc = dst -> stride - w * dn ;\n ptrdiff_t s_line_inc = src -> stride - w * sn ;\n if ( ( copy_spots && ss != ds ) || ( ! da && sa ) ) {\n assert ( \"This should never happen\" == NULL ) ;\n fz_throw ( ctx , FZ_ERROR_GENERIC , \"Cannot convert between incompatible pixmaps\" ) ;\n }\n if ( ( int ) w < 0 || h < 0 ) return ;\n if ( d_line_inc == 0 && s_line_inc == 0 ) {\n w *= h ;\n h = 1 ;\n }\n if ( ss == 0 && ds == 0 ) {\n if ( da ) {\n if ( sa ) {\n while ( h -- ) {\n size_t ww = w ;\n while ( ww -- ) {\n d [ 0 ] = s [ 2 ] ;\n d [ 1 ] = s [ 1 ] ;\n d [ 2 ] = s [ 0 ] ;\n d [ 3 ] = s [ 3 ] ;\n s += 4 ;\n d += 4 ;\n }\n }\n }\n else {\n while ( h -- ) {\n size_t ww = w ;\n while ( ww -- ) {\n d [ 0 ] = s [ 2 ] ;\n d [ 1 ] = s [ 1 ] ;\n d [ 2 ] = s [ 0 ] ;\n d [ 3 ] = 255 ;\n s += 3 ;\n d += 4 ;\n }\n }\n }\n }\n else {\n while ( h -- ) {\n size_t ww = w ;\n while ( ww -- ) {\n d [ 0 ] = s [ 2 ] ;\n d [ 1 ] = s [ 1 ] ;\n d [ 2 ] = s [ 0 ] ;\n s += 3 ;\n d += 3 ;\n }\n }\n }\n }\n else if ( copy_spots ) {\n while ( h -- ) {\n int i ;\n size_t ww = w ;\n while ( ww -- ) {\n d [ 0 ] = s [ 2 ] ;\n d [ 1 ] = s [ 1 ] ;\n d [ 2 ] = s [ 0 ] ;\n s += 3 ;\n d += 3 ;\n for ( i = ss ;\n i > 0 ;\n i -- ) * d ++ = * s ++ ;\n if ( da ) * d ++ = sa ? * s ++ : 255 ;\n }\n d += d_line_inc ;\n s += s_line_inc ;\n }\n }\n else {\n while ( h -- ) {\n size_t ww = w ;\n while ( ww -- ) {\n d [ 0 ] = s [ 2 ] ;\n d [ 1 ] = s [ 1 ] ;\n d [ 2 ] = s [ 0 ] ;\n s += sn ;\n d += dn ;\n if ( da ) d [ - 1 ] = sa ? s [ - 1 ] : 255 ;\n }\n d += d_line_inc ;\n s += s_line_inc ;\n }\n }\n }", "idx": 1251}
{"hash": -866921002076081979, "project": "debian", "size": 19, "label": 0, "functionSource": "REGRESSION_TEST ( SDK_API_TSIOBufferReaderClone ) ( RegressionTest * test , int , int * pstatus ) {\n bool test_passed = false ;\n * pstatus = REGRESSION_TEST_INPROGRESS ;\n TSIOBuffer bufp = TSIOBufferSizedCreate ( TS_IOBUFFER_SIZE_INDEX_4K ) ;\n TSIOBufferReader readerp = TSIOBufferReaderAlloc ( bufp ) ;\n TSIOBufferProduce ( bufp , 10 ) ;\n TSIOBufferReaderConsume ( readerp , 5 ) ;\n TSIOBufferReader readerp2 = TSIOBufferReaderClone ( readerp ) ;\n int64_t reader_avail = TSIOBufferReaderAvail ( readerp2 ) ;\n if ( reader_avail == 5 ) {\n SDK_RPRINT ( test , \"TSIOBufferReaderClone\" , \"TestCase1\" , TC_PASS , \"ok\" ) ;\n test_passed = true ;\n }\n else {\n SDK_RPRINT ( test , \"TSIOBufferReaderClone\" , \"TestCase1\" , TC_FAIL , \"failed\" ) ;\n }\n * pstatus = ( ( test_passed == true ) ? REGRESSION_TEST_PASSED : REGRESSION_TEST_FAILED ) ;\n return ;\n }", "idx": 1252}
{"hash": -5420171864670538459, "project": "debian", "size": 22, "label": 0, "functionSource": "void qmp_pmemsave ( int64_t addr , int64_t size , const char * filename , Error * * errp ) {\n FILE * f ;\n uint32_t l ;\n uint8_t buf [ 1024 ] ;\n f = fopen ( filename , \"wb\" ) ;\n if ( ! f ) {\n error_setg_file_open ( errp , errno , filename ) ;\n return ;\n }\n while ( size != 0 ) {\n l = sizeof ( buf ) ;\n if ( l > size ) l = size ;\n cpu_physical_memory_rw ( addr , buf , l , 0 ) ;\n if ( fwrite ( buf , 1 , l , f ) != l ) {\n error_set ( errp , QERR_IO_ERROR ) ;\n goto exit ;\n }\n addr += l ;\n size -= l ;\n }\n exit : fclose ( f ) ;\n }", "idx": 1253}
{"hash": 3584320764213684062, "project": "debian", "size": 5, "label": 0, "functionSource": "static int vvalue_tvb_lpwstr ( tvbuff_t * tvb , int offset , void * val ) {\n struct data_str * str = ( struct data_str * ) val ;\n str -> len = tvb_get_letohl ( tvb , offset ) ;\n return 4 + vvalue_tvb_lpwstr_len ( tvb , offset + 4 , 0 , val ) ;\n }", "idx": 1254}
{"hash": -7777331401175181229, "project": "debian", "size": 4, "label": 0, "functionSource": "static void sig_server_reconnect_removed ( RECONNECT_REC * reconnect ) {\n g_return_if_fail ( reconnect != NULL ) ;\n printformat ( NULL , NULL , MSGLEVEL_CLIENTNOTICE , TXT_RECONNECT_REMOVED , reconnect -> conn -> address , reconnect -> conn -> port , reconnect -> conn -> chatnet == NULL ? \"\" : reconnect -> conn -> chatnet ) ;\n }", "idx": 1255}
{"hash": -8115807672627724050, "project": "debian", "size": 9, "label": 0, "functionSource": "static int ts_lua_http_server_packet_mark_set ( lua_State * L ) {\n int value ;\n ts_lua_http_ctx * http_ctx ;\n GET_HTTP_CONTEXT ( http_ctx , L ) ;\n value = luaL_checkinteger ( L , 1 ) ;\n TSDebug ( TS_LUA_DEBUG_TAG , \"server packet mark set\" ) ;\n TSHttpTxnServerPacketMarkSet ( http_ctx -> txnp , value ) ;\n return 0 ;\n }", "idx": 1256}
{"hash": 3887066622454352196, "project": "chrome", "size": 35, "label": 0, "functionSource": "static void super_block_uvrd ( const VP9_COMP * cpi , MACROBLOCK * x , int * rate , int64_t * distortion , int * skippable , int64_t * sse , BLOCK_SIZE bsize , int64_t ref_best_rd ) {\n MACROBLOCKD * const xd = & x -> e_mbd ;\n MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] . src_mi -> mbmi ;\n const TX_SIZE uv_tx_size = get_uv_tx_size ( mbmi , & xd -> plane [ 1 ] ) ;\n int plane ;\n int pnrate = 0 , pnskip = 1 ;\n int64_t pndist = 0 , pnsse = 0 ;\n if ( ref_best_rd < 0 ) goto term ;\n if ( is_inter_block ( mbmi ) ) {\n int plane ;\n for ( plane = 1 ;\n plane < MAX_MB_PLANE ;\n ++ plane ) vp9_subtract_plane ( x , bsize , plane ) ;\n }\n * rate = 0 ;\n * distortion = 0 ;\n * sse = 0 ;\n * skippable = 1 ;\n for ( plane = 1 ;\n plane < MAX_MB_PLANE ;\n ++ plane ) {\n txfm_rd_in_plane ( x , & pnrate , & pndist , & pnskip , & pnsse , ref_best_rd , plane , bsize , uv_tx_size , cpi -> sf . use_fast_coef_costing ) ;\n if ( pnrate == INT_MAX ) goto term ;\n * rate += pnrate ;\n * distortion += pndist ;\n * sse += pnsse ;\n * skippable &= pnskip ;\n }\n return ;\n term : * rate = INT_MAX ;\n * distortion = INT64_MAX ;\n * sse = INT64_MAX ;\n * skippable = 0 ;\n return ;\n }", "idx": 1257}
{"hash": -2325305888478261876, "project": "debian", "size": 4, "label": 0, "functionSource": "int tm_register ( tm_whattodo_t * what , tm_event_t * event ) {\n if ( ! init_done ) return TM_BADINIT ;\n return TM_ENOTIMPLEMENTED ;\n }", "idx": 1258}
{"hash": 4489017523191997023, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h225_CallModel ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_CallModel , CallModel_choice , NULL ) ;\n return offset ;\n }", "idx": 1259}
{"hash": -5912543978015782596, "project": "debian", "size": 320, "label": 1, "functionSource": "static int register_interfaces ( extcap_parameters * extcap_conf , const char * adb_server_ip , unsigned short * adb_server_tcp_port ) {\n static char packet [ PACKET_LENGTH ] ;\n static char helpful_packet [ PACKET_LENGTH ] ;\n char * response ;\n char * device_list ;\n gssize data_length ;\n gssize device_length ;\n socket_handle_t sock ;\n const char * adb_transport_serial_templace = \"%04x\" \"host:transport:%s\" ;\n const char * adb_check_port_templace = \"%04x\" \"shell:cat /proc/%set/tcp\" ;\n const char * adb_devices = \"000E\" \"host:devices-l\" ;\n const char * adb_api_level = \"0022\" \"shell:getprop ro.build.version.sdk\" ;\n const char * adb_hcidump_version = \"0017\" \"shell:hcidump --version\" ;\n const char * adb_ps_droid_bluetooth = \"0018\" \"shell:ps droid.bluetooth\" ;\n const char * adb_ps_bluetooth_app = \"001E\" \"shell:ps com.android.bluetooth\" ;\n const char * adb_tcpdump_help = \"0010\" \"shell:tcpdump -h\" ;\n char serial_number [ SERIAL_NUMBER_LENGTH_MAX ] ;\n size_t serial_number_length ;\n char model_name [ MODEL_NAME_LENGTH_MAX ] ;\n int result ;\n char * pos ;\n char * i_pos ;\n char * model_pos ;\n char * device_pos ;\n char * prev_pos ;\n int api_level ;\n int disable_interface ;\n sock = adb_connect ( adb_server_ip , adb_server_tcp_port ) ;\n if ( sock == INVALID_SOCKET ) return EXIT_CODE_INVALID_SOCKET_INTERFACES_LIST ;\n device_list = adb_send_and_receive ( sock , adb_devices , packet , sizeof ( packet ) , & device_length ) ;\n closesocket ( sock ) ;\n if ( ! device_list ) {\n errmsg_print ( \"ERROR: Cannot get list of interfaces from devices\" ) ;\n return EXIT_CODE_CANNOT_GET_INTERFACES_LIST ;\n }\n device_list [ device_length ] = '\\0' ;\n pos = ( char * ) device_list ;\n while ( pos < ( char * ) ( device_list + device_length ) ) {\n prev_pos = pos ;\n pos = strchr ( pos , ' ' ) ;\n i_pos = pos ;\n result = ( int ) ( pos - prev_pos ) ;\n pos = strchr ( pos , '\\n' ) + 1 ;\n if ( result >= ( int ) sizeof ( serial_number ) ) {\n verbose_print ( \"WARNING: Serial number too long, ignore device\\n\" ) ;\n continue ;\n }\n memcpy ( serial_number , prev_pos , result ) ;\n serial_number [ result ] = '\\0' ;\n serial_number_length = strlen ( serial_number ) ;\n model_name [ 0 ] = '\\0' ;\n model_pos = g_strstr_len ( i_pos , pos - i_pos , \"model:\" ) ;\n if ( model_pos ) {\n device_pos = g_strstr_len ( i_pos , pos - i_pos , \"device:\" ) ;\n if ( device_pos && device_pos - model_pos - 6 - 1 < MODEL_NAME_LENGTH_MAX ) {\n memcpy ( model_name , model_pos + 6 , device_pos - model_pos - 6 - 1 ) ;\n model_name [ device_pos - model_pos - 6 - 1 ] = '\\0' ;\n }\n }\n if ( model_name [ 0 ] == '\\0' ) strcpy ( model_name , \"unknown\" ) ;\n verbose_print ( \"VERBOSE: Processing device: \\\"%s\\\" <%s>\\n\" , serial_number , model_name ) ;\n sock = adb_connect ( adb_server_ip , adb_server_tcp_port ) ;\n if ( sock == INVALID_SOCKET ) continue ;\n result = g_snprintf ( ( char * ) helpful_packet , PACKET_LENGTH , adb_transport_serial_templace , 15 + serial_number_length , serial_number ) ;\n if ( result <= 0 || result > PACKET_LENGTH ) {\n errmsg_print ( \"ERROR: Error while completing adb packet for transport\" ) ;\n closesocket ( sock ) ;\n return EXIT_CODE_BAD_SIZE_OF_ASSEMBLED_ADB_PACKET_1 ;\n }\n result = adb_send ( sock , helpful_packet ) ;\n if ( result ) {\n verbose_print ( \"WARNING: Error while setting adb transport for <%s>\\n\" , helpful_packet ) ;\n closesocket ( sock ) ;\n }\n else {\n response = adb_send_and_read ( sock , adb_tcpdump_help , helpful_packet , sizeof ( helpful_packet ) , & data_length ) ;\n closesocket ( sock ) ;\n if ( response ) {\n response [ data_length ] = '\\0' ;\n if ( strstr ( response , \"tcpdump version\" ) ) {\n new_interface ( extcap_conf , INTERFACE_ANDROID_WIFI_TCPDUMP , model_name , serial_number , \"Android WiFi\" ) ;\n }\n }\n else {\n verbose_print ( \"WARNING: Error on socket: <%s>\\n\" , helpful_packet ) ;\n }\n }\n sock = adb_connect ( adb_server_ip , adb_server_tcp_port ) ;\n if ( sock == INVALID_SOCKET ) continue ;\n result = g_snprintf ( ( char * ) helpful_packet , PACKET_LENGTH , adb_transport_serial_templace , 15 + serial_number_length , serial_number ) ;\n if ( result <= 0 || result > PACKET_LENGTH ) {\n errmsg_print ( \"ERROR: Error while completing adb packet\" ) ;\n closesocket ( sock ) ;\n return EXIT_CODE_BAD_SIZE_OF_ASSEMBLED_ADB_PACKET_2 ;\n }\n result = adb_send ( sock , helpful_packet ) ;\n if ( result ) {\n verbose_print ( \"WARNING: Error while setting adb transport for <%s>\\n\" , helpful_packet ) ;\n closesocket ( sock ) ;\n continue ;\n }\n response = adb_send_and_read ( sock , adb_api_level , helpful_packet , sizeof ( helpful_packet ) , & data_length ) ;\n closesocket ( sock ) ;\n if ( ! response ) {\n verbose_print ( \"WARNING: Error on socket: <%s>\\n\" , helpful_packet ) ;\n continue ;\n }\n response [ data_length ] = '\\0' ;\n api_level = ( int ) g_ascii_strtoll ( response , NULL , 10 ) ;\n verbose_print ( \"VERBOSE: Android API Level for %s is %i\\n\" , serial_number , api_level ) ;\n if ( api_level < 21 ) {\n new_interface ( extcap_conf , INTERFACE_ANDROID_LOGCAT_MAIN , model_name , serial_number , \"Android Logcat Main\" ) ;\n new_interface ( extcap_conf , INTERFACE_ANDROID_LOGCAT_SYSTEM , model_name , serial_number , \"Android Logcat System\" ) ;\n new_interface ( extcap_conf , INTERFACE_ANDROID_LOGCAT_RADIO , model_name , serial_number , \"Android Logcat Radio\" ) ;\n new_interface ( extcap_conf , INTERFACE_ANDROID_LOGCAT_EVENTS , model_name , serial_number , \"Android Logcat Events\" ) ;\n }\n else {\n new_interface ( extcap_conf , INTERFACE_ANDROID_LOGCAT_TEXT_MAIN , model_name , serial_number , \"Android Logcat Main\" ) ;\n new_interface ( extcap_conf , INTERFACE_ANDROID_LOGCAT_TEXT_SYSTEM , model_name , serial_number , \"Android Logcat System\" ) ;\n new_interface ( extcap_conf , INTERFACE_ANDROID_LOGCAT_TEXT_RADIO , model_name , serial_number , \"Android Logcat Radio\" ) ;\n new_interface ( extcap_conf , INTERFACE_ANDROID_LOGCAT_TEXT_EVENTS , model_name , serial_number , \"Android Logcat Events\" ) ;\n new_interface ( extcap_conf , INTERFACE_ANDROID_LOGCAT_TEXT_CRASH , model_name , serial_number , \"Android Logcat Crash\" ) ;\n }\n if ( api_level >= 5 && api_level < 17 ) {\n disable_interface = 0 ;\n sock = adb_connect ( adb_server_ip , adb_server_tcp_port ) ;\n if ( sock == INVALID_SOCKET ) continue ;\n result = g_snprintf ( ( char * ) helpful_packet , PACKET_LENGTH , adb_transport_serial_templace , 15 + serial_number_length , serial_number ) ;\n if ( result <= 0 || result > PACKET_LENGTH ) {\n errmsg_print ( \"ERROR: Error while completing adb packet\" ) ;\n closesocket ( sock ) ;\n return EXIT_CODE_BAD_SIZE_OF_ASSEMBLED_ADB_PACKET_3 ;\n }\n result = adb_send ( sock , helpful_packet ) ;\n if ( result ) {\n errmsg_print ( \"ERROR: Error while setting adb transport for <%s>\" , helpful_packet ) ;\n closesocket ( sock ) ;\n return EXIT_CODE_GENERIC ;\n }\n response = adb_send_and_read ( sock , adb_hcidump_version , helpful_packet , sizeof ( helpful_packet ) , & data_length ) ;\n closesocket ( sock ) ;\n if ( ! response || data_length < 1 ) {\n verbose_print ( \"WARNING: Error while getting hcidump version by <%s> (%p len=%\" G_GSSIZE_FORMAT \")\\n\" , adb_hcidump_version , ( void * ) response , data_length ) ;\n verbose_print ( \"VERBOSE: Android hcidump version for %s is unknown\\n\" , serial_number ) ;\n disable_interface = 1 ;\n }\n else {\n response [ data_length ] = '\\0' ;\n if ( g_ascii_strtoull ( response , NULL , 10 ) == 0 ) {\n verbose_print ( \"VERBOSE: Android hcidump version for %s is unknown\\n\" , serial_number ) ;\n disable_interface = 1 ;\n }\n else {\n verbose_print ( \"VERBOSE: Android hcidump version for %s is %s\\n\" , serial_number , response ) ;\n }\n }\n if ( ! disable_interface ) {\n new_interface ( extcap_conf , INTERFACE_ANDROID_BLUETOOTH_HCIDUMP , model_name , serial_number , \"Android Bluetooth Hcidump\" ) ;\n }\n }\n if ( api_level >= 17 && api_level < 21 ) {\n disable_interface = 0 ;\n sock = adb_connect ( adb_server_ip , adb_server_tcp_port ) ;\n if ( sock == INVALID_SOCKET ) continue ;\n result = g_snprintf ( ( char * ) helpful_packet , PACKET_LENGTH , adb_transport_serial_templace , 15 + serial_number_length , serial_number ) ;\n if ( result <= 0 || result > PACKET_LENGTH ) {\n errmsg_print ( \"ERROR: Error while completing adb packet\" ) ;\n closesocket ( sock ) ;\n return EXIT_CODE_BAD_SIZE_OF_ASSEMBLED_ADB_PACKET_4 ;\n }\n result = adb_send ( sock , helpful_packet ) ;\n if ( result ) {\n errmsg_print ( \"ERROR: Error while setting adb transport for <%s>\" , helpful_packet ) ;\n closesocket ( sock ) ;\n return EXIT_CODE_GENERIC ;\n }\n response = adb_send_and_read ( sock , adb_ps_droid_bluetooth , helpful_packet , sizeof ( helpful_packet ) , & data_length ) ;\n closesocket ( sock ) ;\n if ( ! response || data_length < 1 ) {\n verbose_print ( \"WARNING: Error while getting Bluetooth application process id by <%s> \" \"(%p len=%\" G_GSSIZE_FORMAT \")\\n\" , adb_hcidump_version , ( void * ) response , data_length ) ;\n verbose_print ( \"VERBOSE: Android Bluetooth application PID for %s is unknown\\n\" , serial_number ) ;\n disable_interface = 1 ;\n }\n else {\n char * data_str ;\n char pid [ 16 ] ;\n memset ( pid , 0 , sizeof ( pid ) ) ;\n response [ data_length ] = '\\0' ;\n data_str = strchr ( response , '\\n' ) ;\n if ( data_str && sscanf ( data_str , \"%*s %s\" , pid ) == 1 ) {\n verbose_print ( \"VERBOSE: Android Bluetooth application PID for %s is %s\\n\" , serial_number , pid ) ;\n sock = adb_connect ( adb_server_ip , adb_server_tcp_port ) ;\n if ( sock == INVALID_SOCKET ) return EXIT_CODE_INVALID_SOCKET_1 ;\n result = g_snprintf ( ( char * ) helpful_packet , PACKET_LENGTH , adb_transport_serial_templace , 15 + serial_number_length , serial_number ) ;\n if ( result <= 0 || result > PACKET_LENGTH ) {\n errmsg_print ( \"ERROR: Error while completing adb packet\" ) ;\n closesocket ( sock ) ;\n return EXIT_CODE_BAD_SIZE_OF_ASSEMBLED_ADB_PACKET_5 ;\n }\n result = adb_send ( sock , helpful_packet ) ;\n if ( result ) {\n errmsg_print ( \"ERROR: Error while setting adb transport for <%s>\" , helpful_packet ) ;\n closesocket ( sock ) ;\n return EXIT_CODE_GENERIC ;\n }\n result = g_snprintf ( ( char * ) helpful_packet , PACKET_LENGTH , adb_check_port_templace , strlen ( adb_check_port_templace ) - 6 + strlen ( pid ) , pid ) ;\n if ( result <= 0 || result > PACKET_LENGTH ) {\n errmsg_print ( \"ERROR: Error while completing adb packet\" ) ;\n closesocket ( sock ) ;\n return EXIT_CODE_BAD_SIZE_OF_ASSEMBLED_ADB_PACKET_6 ;\n }\n response = adb_send_and_read ( sock , helpful_packet , helpful_packet , sizeof ( helpful_packet ) , & data_length ) ;\n closesocket ( sock ) ;\n if ( ! response ) {\n disable_interface = 1 ;\n }\n else {\n response [ data_length ] = '\\0' ;\n data_str = strchr ( response , '\\n' ) ;\n if ( data_str && sscanf ( data_str , \"%*s %s\" , pid ) == 1 && strcmp ( pid + 9 , \"10EA\" ) == 0 ) {\n verbose_print ( \"VERBOSE: Bluedroid External Parser Port for %s is %s\\n\" , serial_number , pid + 9 ) ;\n }\n else {\n disable_interface = 1 ;\n verbose_print ( \"VERBOSE: Bluedroid External Parser Port for %s is unknown\\n\" , serial_number ) ;\n }\n }\n }\n else {\n disable_interface = 1 ;\n verbose_print ( \"VERBOSE: Android Bluetooth application PID for %s is unknown\\n\" , serial_number ) ;\n }\n }\n if ( ! disable_interface ) {\n new_interface ( extcap_conf , INTERFACE_ANDROID_BLUETOOTH_EXTERNAL_PARSER , model_name , serial_number , \"Android Bluetooth External Parser\" ) ;\n }\n }\n if ( api_level >= 21 ) {\n disable_interface = 0 ;\n sock = adb_connect ( adb_server_ip , adb_server_tcp_port ) ;\n if ( sock == INVALID_SOCKET ) continue ;\n result = g_snprintf ( ( char * ) helpful_packet , PACKET_LENGTH , adb_transport_serial_templace , 15 + serial_number_length , serial_number ) ;\n if ( result <= 0 || result > PACKET_LENGTH ) {\n errmsg_print ( \"ERROR: Error while completing adb packet\" ) ;\n closesocket ( sock ) ;\n return EXIT_CODE_BAD_SIZE_OF_ASSEMBLED_ADB_PACKET_7 ;\n }\n result = adb_send ( sock , helpful_packet ) ;\n if ( result ) {\n errmsg_print ( \"ERROR: Error while setting adb transport for <%s>\" , helpful_packet ) ;\n closesocket ( sock ) ;\n return EXIT_CODE_GENERIC ;\n }\n if ( api_level >= 23 ) {\n response = adb_send_and_read ( sock , adb_ps_bluetooth_app , helpful_packet , sizeof ( helpful_packet ) , & data_length ) ;\n }\n else response = adb_send_and_read ( sock , adb_ps_droid_bluetooth , helpful_packet , sizeof ( helpful_packet ) , & data_length ) ;\n closesocket ( sock ) ;\n if ( ! response || data_length < 1 ) {\n verbose_print ( \"WARNING: Error while getting Bluetooth application process id by <%s> \" \"(%p len=%\" G_GSSIZE_FORMAT \")\\n\" , adb_hcidump_version , ( void * ) response , data_length ) ;\n verbose_print ( \"VERBOSE: Android Bluetooth application PID for %s is unknown\\n\" , serial_number ) ;\n disable_interface = 1 ;\n }\n else {\n char * data_str ;\n char pid [ 16 ] ;\n memset ( pid , 0 , sizeof ( pid ) ) ;\n response [ data_length ] = '\\0' ;\n data_str = strchr ( response , '\\n' ) ;\n if ( data_str && sscanf ( data_str , \"%*s %s\" , pid ) == 1 ) {\n verbose_print ( \"VERBOSE: Android Bluetooth application PID for %s is %s\\n\" , serial_number , pid ) ;\n sock = adb_connect ( adb_server_ip , adb_server_tcp_port ) ;\n if ( sock == INVALID_SOCKET ) return EXIT_CODE_INVALID_SOCKET_2 ;\n result = g_snprintf ( ( char * ) helpful_packet , PACKET_LENGTH , adb_transport_serial_templace , 15 + serial_number_length , serial_number ) ;\n if ( result <= 0 || result > PACKET_LENGTH ) {\n errmsg_print ( \"ERROR: Error while completing adb packet\" ) ;\n closesocket ( sock ) ;\n return EXIT_CODE_BAD_SIZE_OF_ASSEMBLED_ADB_PACKET_8 ;\n }\n result = adb_send ( sock , helpful_packet ) ;\n if ( result ) {\n errmsg_print ( \"ERROR: Error while setting adb transport for <%s>\" , helpful_packet ) ;\n closesocket ( sock ) ;\n return EXIT_CODE_GENERIC ;\n }\n result = g_snprintf ( ( char * ) helpful_packet , PACKET_LENGTH , adb_check_port_templace , strlen ( adb_check_port_templace ) - 6 + strlen ( pid ) , pid ) ;\n if ( result <= 0 || result > PACKET_LENGTH ) {\n errmsg_print ( \"ERROR: Error while completing adb packet\" ) ;\n closesocket ( sock ) ;\n return EXIT_CODE_BAD_SIZE_OF_ASSEMBLED_ADB_PACKET_9 ;\n }\n response = adb_send_and_read ( sock , helpful_packet , helpful_packet , sizeof ( helpful_packet ) , & data_length ) ;\n closesocket ( sock ) ;\n if ( ! response ) {\n disable_interface = 1 ;\n }\n else {\n response [ data_length ] = '\\0' ;\n data_str = strchr ( response , '\\n' ) ;\n if ( data_str && sscanf ( data_str , \"%*s %s\" , pid ) == 1 && strcmp ( pid + 9 , \"22A8\" ) == 0 ) {\n verbose_print ( \"VERBOSE: Btsnoop Net Port for %s is %s\\n\" , serial_number , pid + 9 ) ;\n }\n else {\n disable_interface = 1 ;\n verbose_print ( \"VERBOSE: Btsnoop Net Port for %s is unknown\\n\" , serial_number ) ;\n }\n }\n }\n else {\n disable_interface = 1 ;\n verbose_print ( \"VERBOSE: Android Bluetooth application PID for %s is unknown\\n\" , serial_number ) ;\n }\n }\n if ( ! disable_interface ) {\n new_interface ( extcap_conf , INTERFACE_ANDROID_BLUETOOTH_BTSNOOP_NET , model_name , serial_number , \"Android Bluetooth Btsnoop Net\" ) ;\n }\n }\n }\n return EXIT_CODE_SUCCESS ;\n }", "idx": 1260}
{"hash": 3887066622454352196, "project": "chrome", "size": 18, "label": 0, "functionSource": "static void dist_block ( int plane , int block , TX_SIZE tx_size , struct rdcost_block_args * args ) {\n const int ss_txfrm_size = tx_size << 1 ;\n MACROBLOCK * const x = args -> x ;\n MACROBLOCKD * const xd = & x -> e_mbd ;\n const struct macroblock_plane * const p = & x -> plane [ plane ] ;\n const struct macroblockd_plane * const pd = & xd -> plane [ plane ] ;\n int64_t this_sse ;\n int shift = tx_size == TX_32X32 ? 0 : 2 ;\n tran_low_t * const coeff = BLOCK_OFFSET ( p -> coeff , block ) ;\n tran_low_t * const dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff , block ) ;\n args -> dist = vp9_block_error ( coeff , dqcoeff , 16 << ss_txfrm_size , & this_sse ) >> shift ;\n args -> sse = this_sse >> shift ;\n if ( x -> skip_encode && ! is_inter_block ( & xd -> mi [ 0 ] . src_mi -> mbmi ) ) {\n int64_t p = ( pd -> dequant [ 1 ] * pd -> dequant [ 1 ] * ( 1 << ss_txfrm_size ) ) >> ( shift + 2 ) ;\n args -> dist += ( p >> 4 ) ;\n args -> sse += p ;\n }\n }", "idx": 1261}
{"hash": 2687336064028423153, "project": "chrome", "size": 4, "label": 0, "functionSource": "void evdns_set_transaction_id_fn ( ev_uint16_t ( * fn ) ( void ) ) {\n if ( fn ) trans_id_function = fn ;\n else trans_id_function = default_transaction_id_fn ;\n }", "idx": 1262}
{"hash": -7795592811940874822, "project": "debian", "size": 75, "label": 0, "functionSource": "static gcry_err_code_t oaep_encode ( gcry_mpi_t * r_result , unsigned int nbits , int algo , const unsigned char * value , size_t valuelen , const unsigned char * label , size_t labellen , const void * random_override , size_t random_override_len ) {\n gcry_err_code_t rc = 0 ;\n gcry_error_t err ;\n unsigned char * frame = NULL ;\n size_t nframe = ( nbits + 7 ) / 8 ;\n unsigned char * p ;\n size_t hlen ;\n size_t n ;\n * r_result = NULL ;\n if ( ! label || ! labellen ) {\n label = ( const unsigned char * ) \"\" ;\n labellen = 0 ;\n }\n hlen = gcry_md_get_algo_dlen ( algo ) ;\n if ( valuelen > nframe - 2 * hlen - 2 || ! nframe ) {\n return GPG_ERR_TOO_SHORT ;\n }\n frame = gcry_calloc_secure ( 1 , nframe ) ;\n if ( ! frame ) return gpg_err_code_from_syserror ( ) ;\n gcry_md_hash_buffer ( algo , frame + 1 + hlen , label , labellen ) ;\n n = nframe - valuelen - 1 ;\n frame [ n ] = 0x01 ;\n memcpy ( frame + n + 1 , value , valuelen ) ;\n if ( random_override ) {\n if ( random_override_len != hlen ) {\n gcry_free ( frame ) ;\n return GPG_ERR_INV_ARG ;\n }\n memcpy ( frame + 1 , random_override , hlen ) ;\n }\n else gcry_randomize ( frame + 1 , hlen , GCRY_STRONG_RANDOM ) ;\n {\n unsigned char * dmask ;\n dmask = gcry_malloc_secure ( nframe - hlen - 1 ) ;\n if ( ! dmask ) {\n rc = gpg_err_code_from_syserror ( ) ;\n gcry_free ( frame ) ;\n return rc ;\n }\n rc = mgf1 ( dmask , nframe - hlen - 1 , frame + 1 , hlen , algo ) ;\n if ( rc ) {\n gcry_free ( dmask ) ;\n gcry_free ( frame ) ;\n return rc ;\n }\n for ( n = 1 + hlen , p = dmask ;\n n < nframe ;\n n ++ ) frame [ n ] ^= * p ++ ;\n gcry_free ( dmask ) ;\n }\n {\n unsigned char * smask ;\n smask = gcry_malloc_secure ( hlen ) ;\n if ( ! smask ) {\n rc = gpg_err_code_from_syserror ( ) ;\n gcry_free ( frame ) ;\n return rc ;\n }\n rc = mgf1 ( smask , hlen , frame + 1 + hlen , nframe - hlen - 1 , algo ) ;\n if ( rc ) {\n gcry_free ( smask ) ;\n gcry_free ( frame ) ;\n return rc ;\n }\n for ( n = 1 , p = smask ;\n n < 1 + hlen ;\n n ++ ) frame [ n ] ^= * p ++ ;\n gcry_free ( smask ) ;\n }\n err = gcry_mpi_scan ( r_result , GCRYMPI_FMT_USG , frame , nframe , NULL ) ;\n if ( err ) rc = gcry_err_code ( err ) ;\n else if ( DBG_CIPHER ) log_mpidump ( \"OAEP encoded data\" , * r_result ) ;\n gcry_free ( frame ) ;\n return rc ;\n }", "idx": 1263}
{"hash": 8249698884422048746, "project": "chrome", "size": 21, "label": 0, "functionSource": "static uint16_t * appendEncodedByte ( uint16_t * buffer , uint16_t * buffLimit , uint8_t value , uint8_t state [ ] , UErrorCode * status ) {\n if ( ! status || U_FAILURE ( * status ) ) {\n return NULL ;\n }\n if ( state [ 0 ] != 0 ) {\n uint16_t c = ( uint16_t ) ( ( state [ 1 ] << 8 ) | ( ( ( int32_t ) value ) & 0xFF ) ) ;\n if ( buffer < buffLimit ) {\n * buffer ++ = c ;\n }\n else {\n * status = U_BUFFER_OVERFLOW_ERROR ;\n }\n state [ 0 ] = 0 ;\n return buffer ;\n }\n else {\n state [ 0 ] = 1 ;\n state [ 1 ] = value ;\n return buffer ;\n }\n }", "idx": 1264}
{"hash": 2782335626401253771, "project": "debian", "size": 11, "label": 0, "functionSource": "int s_aes_set_key ( stream_aes_state * state , const unsigned char * key , int keylength ) {\n int code = 0 ;\n if ( ( keylength < 1 ) || ( keylength > SAES_MAX_KEYLENGTH ) ) return_error ( gs_error_rangecheck ) ;\n if ( key == NULL ) return_error ( gs_error_invalidaccess ) ;\n memcpy ( state -> key , key , keylength ) ;\n state -> keylength = keylength ;\n if ( code ) {\n return gs_throw ( gs_error_rangecheck , \"could not set AES key\" ) ;\n }\n return 0 ;\n }", "idx": 1265}
{"hash": 2687336064028423153, "project": "chrome", "size": 27, "label": 0, "functionSource": "int evdns_nameserver_ip_add ( const char * ip_as_string ) {\n struct in_addr ina ;\n int port ;\n char buf [ 20 ] ;\n const char * cp ;\n cp = strchr ( ip_as_string , ':' ) ;\n if ( ! cp ) {\n cp = ip_as_string ;\n port = 53 ;\n }\n else {\n port = strtoint ( cp + 1 ) ;\n if ( port < 0 || port > 65535 ) {\n return 4 ;\n }\n if ( ( cp - ip_as_string ) >= ( int ) sizeof ( buf ) ) {\n return 4 ;\n }\n memcpy ( buf , ip_as_string , cp - ip_as_string ) ;\n buf [ cp - ip_as_string ] = '\\0' ;\n cp = buf ;\n }\n if ( ! inet_aton ( cp , & ina ) ) {\n return 4 ;\n }\n return _evdns_nameserver_add_impl ( ina . s_addr , port ) ;\n }", "idx": 1266}
{"hash": 7295169435648525618, "project": "debian", "size": 86, "label": 0, "functionSource": "static int search_aliases ( Operation * op , SlapReply * rs , ID e_id , IdScopes * isc , MDB_cursor * mci , ID * stack ) {\n ID * aliases , * curscop , * visited , * newsubs , * oldsubs , * tmp ;\n ID cursora , ida , cursoro , ido ;\n Entry * matched , * a ;\n struct berval bv_alias = BER_BVC ( \"alias\" ) ;\n AttributeAssertion aa_alias = ATTRIBUTEASSERTION_INIT ;\n Filter af ;\n aliases = stack ;\n curscop = aliases + MDB_IDL_DB_SIZE ;\n visited = curscop + MDB_IDL_DB_SIZE ;\n newsubs = visited + MDB_IDL_DB_SIZE ;\n oldsubs = newsubs + MDB_IDL_DB_SIZE ;\n tmp = oldsubs + MDB_IDL_DB_SIZE ;\n af . f_choice = LDAP_FILTER_EQUALITY ;\n af . f_ava = & aa_alias ;\n af . f_av_desc = slap_schema . si_ad_objectClass ;\n af . f_av_value = bv_alias ;\n af . f_next = NULL ;\n MDB_IDL_ZERO ( aliases ) ;\n rs -> sr_err = mdb_filter_candidates ( op , isc -> mt , & af , aliases , curscop , visited ) ;\n if ( rs -> sr_err != LDAP_SUCCESS || MDB_IDL_IS_ZERO ( aliases ) ) {\n return rs -> sr_err ;\n }\n oldsubs [ 0 ] = 1 ;\n oldsubs [ 1 ] = e_id ;\n MDB_IDL_ZERO ( visited ) ;\n MDB_IDL_ZERO ( newsubs ) ;\n cursoro = 0 ;\n ido = mdb_idl_first ( oldsubs , & cursoro ) ;\n for ( ;\n ;\n ) {\n rs -> sr_err = mdb_idscope ( op , isc -> mt , e_id , aliases , curscop ) ;\n cursora = 0 ;\n for ( ida = mdb_idl_first ( curscop , & cursora ) ;\n ida != NOID ;\n ida = mdb_idl_next ( curscop , & cursora ) ) {\n rs -> sr_err = mdb_id2entry ( op , mci , ida , & a ) ;\n if ( rs -> sr_err != LDAP_SUCCESS ) {\n continue ;\n }\n if ( ! is_entry_alias ( a ) ) {\n mdb_entry_return ( op , a ) ;\n continue ;\n }\n MDB_IDL_ZERO ( tmp ) ;\n a = deref_base ( op , rs , a , & matched , isc -> mt , tmp , visited ) ;\n if ( a ) {\n ID2 mid ;\n mid . mid = a -> e_id ;\n mid . mval . mv_data = NULL ;\n if ( op -> ors_scope == LDAP_SCOPE_SUBTREE ) {\n isc -> id = a -> e_id ;\n if ( mdb_idscopechk ( op , isc ) ) goto skip ;\n }\n if ( mdb_id2l_insert ( isc -> scopes , & mid ) == 0 ) {\n mdb_idl_insert ( newsubs , a -> e_id ) ;\n }\n skip : mdb_entry_return ( op , a ) ;\n }\n else if ( matched ) {\n mdb_entry_return ( op , matched ) ;\n rs -> sr_text = NULL ;\n rs -> sr_err = 0 ;\n }\n }\n if ( op -> ors_scope == LDAP_SCOPE_ONELEVEL ) break ;\n nextido : ido = mdb_idl_next ( oldsubs , & cursoro ) ;\n if ( ido == NOID ) {\n if ( MDB_IDL_IS_ZERO ( newsubs ) ) break ;\n MDB_IDL_CPY ( oldsubs , newsubs ) ;\n MDB_IDL_ZERO ( newsubs ) ;\n cursoro = 0 ;\n ido = mdb_idl_first ( oldsubs , & cursoro ) ;\n }\n {\n MDB_val edata ;\n rs -> sr_err = mdb_id2edata ( op , mci , ido , & edata ) ;\n if ( rs -> sr_err != MDB_SUCCESS ) {\n goto nextido ;\n }\n e_id = ido ;\n }\n }\n return rs -> sr_err ;\n }", "idx": 1267}
{"hash": 1182028467273264883, "project": "debian", "size": 16, "label": 0, "functionSource": "void do_file_exist ( struct st_command * command ) {\n int error ;\n static DYNAMIC_STRING ds_filename ;\n const struct command_arg file_exist_args [ ] = {\n {\n \"filename\" , ARG_STRING , TRUE , & ds_filename , \"File to check if it exist\" }\n }\n ;\n DBUG_ENTER ( \"do_file_exist\" ) ;\n check_command_args ( command , command -> first_argument , file_exist_args , sizeof ( file_exist_args ) / sizeof ( struct command_arg ) , ' ' ) ;\n DBUG_PRINT ( \"info\" , ( \"Checking for existence of file: %s\" , ds_filename . str ) ) ;\n error = ( access ( ds_filename . str , F_OK ) != 0 ) ;\n handle_command_error ( command , error , errno ) ;\n dynstr_free ( & ds_filename ) ;\n DBUG_VOID_RETURN ;\n }", "idx": 1268}
{"hash": -1768728156572022708, "project": "debian", "size": 13, "label": 0, "functionSource": "int jbig2_error ( Jbig2Ctx * ctx , Jbig2Severity severity , int32_t segment_number , const char * fmt , ... ) {\n char buf [ 1024 ] ;\n va_list ap ;\n int n ;\n int code ;\n va_start ( ap , fmt ) ;\n n = vsnprintf ( buf , sizeof ( buf ) , fmt , ap ) ;\n va_end ( ap ) ;\n if ( n < 0 || n == sizeof ( buf ) ) strncpy ( buf , \"jbig2_error: error in generating error string\" , sizeof ( buf ) ) ;\n code = ctx -> error_callback ( ctx -> error_callback_data , buf , severity , segment_number ) ;\n if ( severity == JBIG2_SEVERITY_FATAL ) code = - 1 ;\n return code ;\n }", "idx": 1269}
{"hash": -273984976102410662, "project": "chrome", "size": 5, "label": 0, "functionSource": "inline void uprv_checkCanGetBuffer ( const icu : : UnicodeString & s , UErrorCode & errorCode ) {\n if ( U_SUCCESS ( errorCode ) && s . isBogus ( ) ) {\n errorCode = U_ILLEGAL_ARGUMENT_ERROR ;\n }\n }", "idx": 1270}
{"hash": -398565394354770780, "project": "debian", "size": 4, "label": 0, "functionSource": "static void ohci_bus_stop ( OHCIState * ohci ) {\n trace_usb_ohci_stop ( ohci -> name ) ;\n timer_del ( ohci -> eof_timer ) ;\n }", "idx": 1271}
{"hash": 4489017523191997023, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h225_H245Control ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence_of ( tvb , offset , actx , tree , hf_index , ett_h225_H245Control , H245Control_sequence_of ) ;\n return offset ;\n }", "idx": 1272}
{"hash": -6435087038712482873, "project": "debian", "size": 30, "label": 0, "functionSource": "static int slice_end ( AVCodecContext * avctx , AVFrame * pict ) {\n Mpeg1Context * s1 = avctx -> priv_data ;\n MpegEncContext * s = & s1 -> mpeg_enc_ctx ;\n if ( ! s1 -> mpeg_enc_ctx_allocated || ! s -> current_picture_ptr ) return 0 ;\n if ( s -> avctx -> hwaccel ) {\n if ( s -> avctx -> hwaccel -> end_frame ( s -> avctx ) < 0 ) av_log ( avctx , AV_LOG_ERROR , \"hardware accelerator failed to decode picture\\n\" ) ;\n }\n if ( CONFIG_MPEG_XVMC_DECODER && s -> avctx -> xvmc_acceleration ) ff_xvmc_field_end ( s ) ;\n if ( ! s -> first_field ) {\n ff_er_frame_end ( & s -> er ) ;\n ff_MPV_frame_end ( s ) ;\n if ( s -> pict_type == AV_PICTURE_TYPE_B || s -> low_delay ) {\n int ret = av_frame_ref ( pict , & s -> current_picture_ptr -> f ) ;\n if ( ret < 0 ) return ret ;\n ff_print_debug_info ( s , s -> current_picture_ptr ) ;\n }\n else {\n if ( avctx -> active_thread_type & FF_THREAD_FRAME ) s -> picture_number ++ ;\n if ( s -> last_picture_ptr != NULL ) {\n int ret = av_frame_ref ( pict , & s -> last_picture_ptr -> f ) ;\n if ( ret < 0 ) return ret ;\n ff_print_debug_info ( s , s -> last_picture_ptr ) ;\n }\n }\n return 1 ;\n }\n else {\n return 0 ;\n }\n }", "idx": 1273}
{"hash": -5082285935423529157, "project": "debian", "size": 21, "label": 0, "functionSource": "static int dissect_rsl_ie_llp_apdu ( tvbuff_t * tvb , packet_info * pinfo _U_ , proto_tree * tree , int offset , gboolean is_mandatory ) {\n proto_item * ti ;\n proto_tree * ie_tree ;\n guint8 length ;\n int ie_offset ;\n guint8 ie_id ;\n if ( is_mandatory == FALSE ) {\n ie_id = tvb_get_guint8 ( tvb , offset ) ;\n if ( ie_id != RSL_IE_LLP_APDU ) return offset ;\n }\n ie_tree = proto_tree_add_subtree ( tree , tvb , offset , 0 , ett_ie_llp_apdu , & ti , \"LLP APDU IE\" ) ;\n proto_tree_add_item ( ie_tree , hf_rsl_ie_id , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n offset ++ ;\n length = tvb_get_guint8 ( tvb , offset ) ;\n proto_item_set_len ( ti , length + 2 ) ;\n proto_tree_add_item ( ie_tree , hf_rsl_ie_length , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n offset ++ ;\n ie_offset = offset ;\n proto_tree_add_expert ( tree , pinfo , & ei_rsl_facility_information_element_3gpp_ts_44071 , tvb , offset , length ) ;\n return ie_offset + length ;\n }", "idx": 1274}
{"hash": -2607754285145856562, "project": "debian", "size": 14, "label": 0, "functionSource": "static int extra_setup_location ( struct isoent * isoent , int location ) {\n struct extr_rec * rec ;\n int cnt ;\n cnt = 0 ;\n rec = isoent -> extr_rec_list . first ;\n isoent -> extr_rec_list . current = rec ;\n while ( rec ) {\n cnt ++ ;\n rec -> location = location ++ ;\n rec -> offset = 0 ;\n rec = rec -> next ;\n }\n return ( cnt ) ;\n }", "idx": 1275}
{"hash": 4715922168896528064, "project": "debian", "size": 48, "label": 0, "functionSource": "void jpc_ft_invlift_col ( jpc_fix_t * a , int numrows , int stride , int parity ) {\n jpc_fix_t * lptr ;\n jpc_fix_t * hptr ;\n # if 0 register jpc_fix_t * lptr2 ;\n register jpc_fix_t * hptr2 ;\n register int i ;\n # endif register int n ;\n int llen ;\n llen = ( numrows + 1 - parity ) >> 1 ;\n if ( numrows > 1 ) {\n lptr = & a [ 0 ] ;\n hptr = & a [ llen * stride ] ;\n if ( ! parity ) {\n lptr [ 0 ] -= jpc_fix_asr ( hptr [ 0 ] + 1 , 1 ) ;\n lptr += stride ;\n }\n n = llen - ( ! parity ) - ( parity != ( numrows & 1 ) ) ;\n while ( n -- > 0 ) {\n lptr [ 0 ] -= jpc_fix_asr ( hptr [ 0 ] + hptr [ stride ] + 2 , 2 ) ;\n lptr += stride ;\n hptr += stride ;\n }\n if ( parity != ( numrows & 1 ) ) {\n lptr [ 0 ] -= jpc_fix_asr ( hptr [ 0 ] + 1 , 1 ) ;\n }\n lptr = & a [ 0 ] ;\n hptr = & a [ llen * stride ] ;\n if ( parity ) {\n hptr [ 0 ] += lptr [ 0 ] ;\n hptr += stride ;\n }\n n = numrows - llen - parity - ( parity == ( numrows & 1 ) ) ;\n while ( n -- > 0 ) {\n hptr [ 0 ] += jpc_fix_asr ( lptr [ 0 ] + lptr [ stride ] , 1 ) ;\n hptr += stride ;\n lptr += stride ;\n }\n if ( parity == ( numrows & 1 ) ) {\n hptr [ 0 ] += lptr [ 0 ] ;\n }\n }\n else {\n if ( parity ) {\n lptr = & a [ 0 ] ;\n lptr [ 0 ] = jpc_fix_asr ( lptr [ 0 ] , 1 ) ;\n }\n }\n }", "idx": 1276}
{"hash": 2755982813601944893, "project": "debian", "size": 9, "label": 0, "functionSource": "static void transpose_perm ( int16_t * out , int16_t * in , int num_vect , const uint8_t line_len [ 2 ] , int length_div ) {\n int i , j ;\n int cont = 0 ;\n for ( i = 0 ;\n i < num_vect ;\n i ++ ) for ( j = 0 ;\n j < line_len [ i >= length_div ] ;\n j ++ ) out [ cont ++ ] = in [ j * num_vect + i ] ;\n }", "idx": 1277}
{"hash": -2385618084223928445, "project": "debian", "size": 76, "label": 0, "functionSource": "static int decode_channel ( RALFContext * ctx , GetBitContext * gb , int ch , int length , int mode , int bits ) {\n int i , t ;\n int code_params ;\n VLCSet * set = ctx -> sets + mode ;\n VLC * code_vlc ;\n int range , range2 , add_bits ;\n int * dst = ctx -> channel_data [ ch ] ;\n ctx -> filter_params = get_vlc2 ( gb , set -> filter_params . table , 9 , 2 ) ;\n ctx -> filter_bits = ( ctx -> filter_params - 2 ) >> 6 ;\n ctx -> filter_length = ctx -> filter_params - ( ctx -> filter_bits << 6 ) - 1 ;\n if ( ctx -> filter_params == FILTER_RAW ) {\n for ( i = 0 ;\n i < length ;\n i ++ ) dst [ i ] = get_bits ( gb , bits ) ;\n ctx -> bias [ ch ] = 0 ;\n return 0 ;\n }\n ctx -> bias [ ch ] = get_vlc2 ( gb , set -> bias . table , 9 , 2 ) ;\n ctx -> bias [ ch ] = extend_code ( gb , ctx -> bias [ ch ] , 127 , 4 ) ;\n if ( ctx -> filter_params == FILTER_NONE ) {\n memset ( dst , 0 , sizeof ( * dst ) * length ) ;\n return 0 ;\n }\n if ( ctx -> filter_params > 1 ) {\n int cmode = 0 , coeff = 0 ;\n VLC * vlc = set -> filter_coeffs [ ctx -> filter_bits ] + 5 ;\n add_bits = ctx -> filter_bits ;\n for ( i = 0 ;\n i < ctx -> filter_length ;\n i ++ ) {\n t = get_vlc2 ( gb , vlc [ cmode ] . table , vlc [ cmode ] . bits , 2 ) ;\n t = extend_code ( gb , t , 21 , add_bits ) ;\n if ( ! cmode ) coeff -= 12 << add_bits ;\n coeff = t - coeff ;\n ctx -> filter [ i ] = coeff ;\n cmode = coeff >> add_bits ;\n if ( cmode < 0 ) {\n cmode = - 1 - av_log2 ( - cmode ) ;\n if ( cmode < - 5 ) cmode = - 5 ;\n }\n else if ( cmode > 0 ) {\n cmode = 1 + av_log2 ( cmode ) ;\n if ( cmode > 5 ) cmode = 5 ;\n }\n }\n }\n code_params = get_vlc2 ( gb , set -> coding_mode . table , set -> coding_mode . bits , 2 ) ;\n if ( code_params >= 15 ) {\n add_bits = av_clip ( ( code_params / 5 - 3 ) / 2 , 0 , 10 ) ;\n if ( add_bits > 9 && ( code_params % 5 ) != 2 ) add_bits -- ;\n range = 10 ;\n range2 = 21 ;\n code_vlc = set -> long_codes + code_params - 15 ;\n }\n else {\n add_bits = 0 ;\n range = 6 ;\n range2 = 13 ;\n code_vlc = set -> short_codes + code_params ;\n }\n for ( i = 0 ;\n i < length ;\n i += 2 ) {\n int code1 , code2 ;\n t = get_vlc2 ( gb , code_vlc -> table , code_vlc -> bits , 2 ) ;\n code1 = t / range2 ;\n code2 = t % range2 ;\n dst [ i ] = extend_code ( gb , code1 , range , 0 ) << add_bits ;\n dst [ i + 1 ] = extend_code ( gb , code2 , range , 0 ) << add_bits ;\n if ( add_bits ) {\n dst [ i ] |= get_bits ( gb , add_bits ) ;\n dst [ i + 1 ] |= get_bits ( gb , add_bits ) ;\n }\n }\n return 0 ;\n }", "idx": 1278}
{"hash": 6323824267898511453, "project": "debian", "size": 3, "label": 0, "functionSource": "void fz_cmm_fin_link ( fz_context * ctx , fz_icclink * link ) {\n if ( ctx && ctx -> colorspace && ctx -> colorspace -> cmm && ctx -> cmm_instance ) ctx -> colorspace -> cmm -> fin_link ( ctx -> cmm_instance , link ) ;\n }", "idx": 1279}
{"hash": 6030508190585699741, "project": "debian", "size": 4, "label": 0, "functionSource": "static int flic_decode_frame_24BPP ( AVCodecContext * avctx , void * data , int * got_frame , const uint8_t * buf , int buf_size ) {\n av_log ( avctx , AV_LOG_ERROR , \"24Bpp FLC Unsupported due to lack of test files.\\n\" ) ;\n return AVERROR_PATCHWELCOME ;\n }", "idx": 1280}
{"hash": 8458201026073747179, "project": "debian", "size": 41, "label": 0, "functionSource": "static int jbig2_decode_generic_template1_TPGDON ( Jbig2Ctx * ctx , Jbig2Segment * segment , const Jbig2GenericRegionParams * params , Jbig2ArithState * as , Jbig2Image * image , Jbig2ArithCx * GB_stats ) {\n const int GBW = image -> width ;\n const int GBH = image -> height ;\n uint32_t CONTEXT ;\n int x , y ;\n bool bit ;\n int LTP = 0 ;\n for ( y = 0 ;\n y < GBH ;\n y ++ ) {\n bit = jbig2_arith_decode ( as , & GB_stats [ 0x0795 ] ) ;\n if ( bit < 0 ) return - 1 ;\n LTP ^= bit ;\n if ( ! LTP ) {\n for ( x = 0 ;\n x < GBW ;\n x ++ ) {\n CONTEXT = jbig2_image_get_pixel ( image , x - 1 , y ) ;\n CONTEXT |= jbig2_image_get_pixel ( image , x - 2 , y ) << 1 ;\n CONTEXT |= jbig2_image_get_pixel ( image , x - 3 , y ) << 2 ;\n CONTEXT |= jbig2_image_get_pixel ( image , x + params -> gbat [ 0 ] , y + params -> gbat [ 1 ] ) << 3 ;\n CONTEXT |= jbig2_image_get_pixel ( image , x + 2 , y - 1 ) << 4 ;\n CONTEXT |= jbig2_image_get_pixel ( image , x + 1 , y - 1 ) << 5 ;\n CONTEXT |= jbig2_image_get_pixel ( image , x , y - 1 ) << 6 ;\n CONTEXT |= jbig2_image_get_pixel ( image , x - 1 , y - 1 ) << 7 ;\n CONTEXT |= jbig2_image_get_pixel ( image , x - 2 , y - 1 ) << 8 ;\n CONTEXT |= jbig2_image_get_pixel ( image , x + 2 , y - 2 ) << 9 ;\n CONTEXT |= jbig2_image_get_pixel ( image , x + 1 , y - 2 ) << 10 ;\n CONTEXT |= jbig2_image_get_pixel ( image , x , y - 2 ) << 11 ;\n CONTEXT |= jbig2_image_get_pixel ( image , x - 1 , y - 2 ) << 12 ;\n bit = jbig2_arith_decode ( as , & GB_stats [ CONTEXT ] ) ;\n if ( bit < 0 ) return - 1 ;\n jbig2_image_set_pixel ( image , x , y , bit ) ;\n }\n }\n else {\n copy_prev_row ( image , y ) ;\n }\n }\n return 0 ;\n }", "idx": 1281}
{"hash": 6755873269946787742, "project": "debian", "size": 35, "label": 0, "functionSource": "static void pk_transaction_search_files ( PkTransaction * transaction , GVariant * params , GDBusMethodInvocation * context ) {\n gboolean ret ;\n guint i ;\n PkBitfield filter ;\n g_autofree gchar * * values = NULL ;\n g_autoptr ( GError ) error = NULL ;\n g_return_if_fail ( PK_IS_TRANSACTION ( transaction ) ) ;\n g_return_if_fail ( transaction -> priv -> tid != NULL ) ;\n g_variant_get ( params , \"(t^a&s)\" , & filter , & values ) ;\n g_debug ( \"SearchFiles method called: %\" G_GUINT64_FORMAT \", %s\" , filter , values [ 0 ] ) ;\n if ( ! pk_backend_is_implemented ( transaction -> priv -> backend , PK_ROLE_ENUM_SEARCH_FILE ) ) {\n g_set_error ( & error , PK_TRANSACTION_ERROR , PK_TRANSACTION_ERROR_NOT_SUPPORTED , \"SearchFiles not supported by backend\" ) ;\n pk_transaction_set_state ( transaction , PK_TRANSACTION_STATE_ERROR ) ;\n goto out ;\n }\n ret = pk_transaction_search_check ( values , & error ) ;\n if ( ! ret ) {\n pk_transaction_set_state ( transaction , PK_TRANSACTION_STATE_ERROR ) ;\n goto out ;\n }\n for ( i = 0 ;\n values [ i ] != NULL ;\n i ++ ) {\n if ( values [ i ] [ 0 ] != '/' && strstr ( values [ i ] , \"/\" ) != NULL ) {\n g_set_error ( & error , PK_TRANSACTION_ERROR , PK_TRANSACTION_ERROR_SEARCH_PATH_INVALID , \"Invalid search path\" ) ;\n pk_transaction_set_state ( transaction , PK_TRANSACTION_STATE_ERROR ) ;\n goto out ;\n }\n }\n transaction -> priv -> cached_filters = filter ;\n transaction -> priv -> cached_values = g_strdupv ( values ) ;\n pk_transaction_set_role ( transaction , PK_ROLE_ENUM_SEARCH_FILE ) ;\n pk_transaction_set_state ( transaction , PK_TRANSACTION_STATE_READY ) ;\n out : pk_transaction_dbus_return ( context , error ) ;\n }", "idx": 1282}
{"hash": 6393050609822897742, "project": "debian", "size": 110, "label": 1, "functionSource": "static void xhci_kick_epctx ( XHCIEPContext * epctx , unsigned int streamid ) {\n XHCIState * xhci = epctx -> xhci ;\n XHCIStreamContext * stctx ;\n XHCITransfer * xfer ;\n XHCIRing * ring ;\n USBEndpoint * ep = NULL ;\n uint64_t mfindex ;\n int length ;\n int i ;\n trace_usb_xhci_ep_kick ( epctx -> slotid , epctx -> epid , streamid ) ;\n if ( ! xhci -> slots [ epctx -> slotid - 1 ] . uport || ! xhci -> slots [ epctx -> slotid - 1 ] . uport -> dev || ! xhci -> slots [ epctx -> slotid - 1 ] . uport -> dev -> attached ) {\n return ;\n }\n if ( epctx -> retry ) {\n XHCITransfer * xfer = epctx -> retry ;\n trace_usb_xhci_xfer_retry ( xfer ) ;\n assert ( xfer -> running_retry ) ;\n if ( xfer -> timed_xfer ) {\n mfindex = xhci_mfindex_get ( xhci ) ;\n xhci_check_intr_iso_kick ( xhci , xfer , epctx , mfindex ) ;\n if ( xfer -> running_retry ) {\n return ;\n }\n xfer -> timed_xfer = 0 ;\n xfer -> running_retry = 1 ;\n }\n if ( xfer -> iso_xfer ) {\n if ( xhci_setup_packet ( xfer ) < 0 ) {\n return ;\n }\n usb_handle_packet ( xfer -> packet . ep -> dev , & xfer -> packet ) ;\n assert ( xfer -> packet . status != USB_RET_NAK ) ;\n xhci_try_complete_packet ( xfer ) ;\n }\n else {\n if ( xhci_setup_packet ( xfer ) < 0 ) {\n return ;\n }\n usb_handle_packet ( xfer -> packet . ep -> dev , & xfer -> packet ) ;\n if ( xfer -> packet . status == USB_RET_NAK ) {\n return ;\n }\n xhci_try_complete_packet ( xfer ) ;\n }\n assert ( ! xfer -> running_retry ) ;\n if ( xfer -> complete ) {\n xhci_ep_free_xfer ( epctx -> retry ) ;\n }\n epctx -> retry = NULL ;\n }\n if ( epctx -> state == EP_HALTED ) {\n DPRINTF ( \"xhci: ep halted, not running schedule\\n\" ) ;\n return ;\n }\n if ( epctx -> nr_pstreams ) {\n uint32_t err ;\n stctx = xhci_find_stream ( epctx , streamid , & err ) ;\n if ( stctx == NULL ) {\n return ;\n }\n ring = & stctx -> ring ;\n xhci_set_ep_state ( xhci , epctx , stctx , EP_RUNNING ) ;\n }\n else {\n ring = & epctx -> ring ;\n streamid = 0 ;\n xhci_set_ep_state ( xhci , epctx , NULL , EP_RUNNING ) ;\n }\n assert ( ring -> dequeue != 0 ) ;\n while ( 1 ) {\n length = xhci_ring_chain_length ( xhci , ring ) ;\n if ( length <= 0 ) {\n break ;\n }\n xfer = xhci_ep_alloc_xfer ( epctx , length ) ;\n if ( xfer == NULL ) {\n break ;\n }\n for ( i = 0 ;\n i < length ;\n i ++ ) {\n TRBType type ;\n type = xhci_ring_fetch ( xhci , ring , & xfer -> trbs [ i ] , NULL ) ;\n assert ( type ) ;\n }\n xfer -> streamid = streamid ;\n if ( epctx -> epid == 1 ) {\n xhci_fire_ctl_transfer ( xhci , xfer ) ;\n }\n else {\n xhci_fire_transfer ( xhci , xfer , epctx ) ;\n }\n if ( xfer -> complete ) {\n xhci_ep_free_xfer ( xfer ) ;\n xfer = NULL ;\n }\n if ( epctx -> state == EP_HALTED ) {\n break ;\n }\n if ( xfer != NULL && xfer -> running_retry ) {\n DPRINTF ( \"xhci: xfer nacked, stopping schedule\\n\" ) ;\n epctx -> retry = xfer ;\n break ;\n }\n }\n ep = xhci_epid_to_usbep ( epctx ) ;\n if ( ep ) {\n usb_device_flush_ep_queue ( ep -> dev , ep ) ;\n }\n }", "idx": 1283}
{"hash": -7670127399145950875, "project": "debian", "size": 8, "label": 0, "functionSource": "int gs_main_run_string_with_length ( gs_main_instance * minst , const char * str , uint length , int user_errors , int * pexit_code , ref * perror_object ) {\n int code ;\n code = gs_main_run_string_begin ( minst , user_errors , pexit_code , perror_object ) ;\n if ( code < 0 ) return code ;\n code = gs_main_run_string_continue ( minst , str , length , user_errors , pexit_code , perror_object ) ;\n if ( code != gs_error_NeedInput ) return code ;\n return gs_main_run_string_end ( minst , user_errors , pexit_code , perror_object ) ;\n }", "idx": 1284}
{"hash": -7076754245473579218, "project": "chrome", "size": 4, "label": 0, "functionSource": "static void evhttp_connection_stop_detectclose ( struct evhttp_connection * evcon ) {\n evcon -> flags &= ~ EVHTTP_CON_CLOSEDETECT ;\n event_del ( & evcon -> close_ev ) ;\n }", "idx": 1285}
{"hash": -8884965407551053630, "project": "debian", "size": 36, "label": 0, "functionSource": "int input_DecoderSetCcState ( decoder_t * p_dec , bool b_decode , int i_channel ) {\n decoder_owner_sys_t * p_owner = p_dec -> p_owner ;\n if ( i_channel < 0 || i_channel >= 4 || ! p_owner -> cc . pb_present [ i_channel ] ) return VLC_EGENERIC ;\n if ( b_decode ) {\n static const vlc_fourcc_t fcc [ 4 ] = {\n VLC_FOURCC ( 'c' , 'c' , '1' , ' ' ) , VLC_FOURCC ( 'c' , 'c' , '2' , ' ' ) , VLC_FOURCC ( 'c' , 'c' , '3' , ' ' ) , VLC_FOURCC ( 'c' , 'c' , '4' , ' ' ) , }\n ;\n decoder_t * p_cc ;\n es_format_t fmt ;\n es_format_Init ( & fmt , SPU_ES , fcc [ i_channel ] ) ;\n p_cc = input_DecoderNew ( p_owner -> p_input , & fmt , p_dec -> p_owner -> p_clock , p_owner -> p_sout ) ;\n if ( ! p_cc ) {\n msg_Err ( p_dec , \"could not create decoder\" ) ;\n dialog_Fatal ( p_dec , _ ( \"Streaming / Transcoding failed\" ) , \"%s\" , _ ( \"VLC could not open the decoder module.\" ) ) ;\n return VLC_EGENERIC ;\n }\n else if ( ! p_cc -> p_module ) {\n DecoderUnsupportedCodec ( p_dec , fcc [ i_channel ] ) ;\n input_DecoderDelete ( p_cc ) ;\n return VLC_EGENERIC ;\n }\n p_cc -> p_owner -> p_clock = p_owner -> p_clock ;\n vlc_mutex_lock ( & p_owner -> lock ) ;\n p_owner -> cc . pp_decoder [ i_channel ] = p_cc ;\n vlc_mutex_unlock ( & p_owner -> lock ) ;\n }\n else {\n decoder_t * p_cc ;\n vlc_mutex_lock ( & p_owner -> lock ) ;\n p_cc = p_owner -> cc . pp_decoder [ i_channel ] ;\n p_owner -> cc . pp_decoder [ i_channel ] = NULL ;\n vlc_mutex_unlock ( & p_owner -> lock ) ;\n if ( p_cc ) input_DecoderDelete ( p_cc ) ;\n }\n return VLC_SUCCESS ;\n }", "idx": 1286}
{"hash": 2895622461494525400, "project": "debian", "size": 22, "label": 0, "functionSource": "static void test_bug12744 ( ) {\n MYSQL_STMT * prep_stmt = NULL ;\n MYSQL * lmysql ;\n int rc ;\n myheader ( \"test_bug12744\" ) ;\n lmysql = mysql_client_init ( NULL ) ;\n DIE_UNLESS ( lmysql ) ;\n if ( ! mysql_real_connect ( lmysql , opt_host , opt_user , opt_password , current_db , opt_port , opt_unix_socket , 0 ) ) {\n fprintf ( stderr , \"Failed to connect to the database\\n\" ) ;\n DIE_UNLESS ( 0 ) ;\n }\n prep_stmt = mysql_stmt_init ( lmysql ) ;\n rc = mysql_stmt_prepare ( prep_stmt , \"SELECT 1\" , 8 ) ;\n DIE_UNLESS ( rc == 0 ) ;\n mysql_close ( lmysql ) ;\n rc = mysql_stmt_execute ( prep_stmt ) ;\n DIE_UNLESS ( rc ) ;\n rc = mysql_stmt_reset ( prep_stmt ) ;\n DIE_UNLESS ( rc ) ;\n rc = mysql_stmt_close ( prep_stmt ) ;\n DIE_UNLESS ( rc == 0 ) ;\n }", "idx": 1287}
{"hash": 6415329349331062723, "project": "chrome", "size": 25, "label": 0, "functionSource": "static void http_badreq_readcb ( struct bufferevent * bev , void * arg ) {\n const char * what = \"Hello, 127.0.0.1\" ;\n const char * bad_request = \"400 Bad Request\" ;\n event_debug ( ( \"%s: %s\\n\" , __func__ , EVBUFFER_DATA ( bev -> input ) ) ) ;\n if ( evbuffer_find ( bev -> input , ( const unsigned char * ) bad_request , strlen ( bad_request ) ) != NULL ) {\n event_debug ( ( \"%s: bad request detected\" , __func__ ) ) ;\n test_ok = - 10 ;\n bufferevent_disable ( bev , EV_READ ) ;\n event_loopexit ( NULL ) ;\n return ;\n }\n if ( evbuffer_find ( bev -> input , ( const unsigned char * ) what , strlen ( what ) ) != NULL ) {\n struct evhttp_request * req = evhttp_request_new ( NULL , NULL ) ;\n enum message_read_status done ;\n req -> kind = EVHTTP_RESPONSE ;\n done = evhttp_parse_firstline ( req , bev -> input ) ;\n if ( done != ALL_DATA_READ ) goto out ;\n done = evhttp_parse_headers ( req , bev -> input ) ;\n if ( done != ALL_DATA_READ ) goto out ;\n if ( done == 1 && evhttp_find_header ( req -> input_headers , \"Content-Type\" ) != NULL ) test_ok ++ ;\n out : evhttp_request_free ( req ) ;\n evbuffer_drain ( bev -> input , EVBUFFER_LENGTH ( bev -> input ) ) ;\n }\n shutdown ( bev -> ev_read . ev_fd , SHUT_WR ) ;\n }", "idx": 1288}
{"hash": -6474315190511670247, "project": "debian", "size": 29, "label": 0, "functionSource": "static void context_alloc ( void ) {\n gpg_error_t err ;\n gcry_ctx_t ctx ;\n gcry_mpi_t p , a ;\n wherestr = \"context_alloc\" ;\n show ( \"checking context functions\\n\" ) ;\n p = gcry_mpi_set_ui ( NULL , 1 ) ;\n a = gcry_mpi_set_ui ( NULL , 1 ) ;\n err = ec_p_new ( & ctx , p , a ) ;\n if ( err ) die ( \"ec_p_new returned an error: %s\\n\" , gpg_strerror ( err ) ) ;\n gcry_mpi_release ( p ) ;\n gcry_mpi_release ( a ) ;\n gcry_ctx_release ( ctx ) ;\n p = gcry_mpi_set_ui ( NULL , 0 ) ;\n a = gcry_mpi_set_ui ( NULL , 0 ) ;\n err = ec_p_new ( & ctx , p , a ) ;\n if ( ! err || gpg_err_code ( err ) != GPG_ERR_EINVAL ) fail ( \"ec_p_new: bad parameter detection failed (1)\\n\" ) ;\n gcry_mpi_set_ui ( p , 1 ) ;\n err = ec_p_new ( & ctx , p , a ) ;\n if ( ! err || gpg_err_code ( err ) != GPG_ERR_EINVAL ) fail ( \"ec_p_new: bad parameter detection failed (2)\\n\" ) ;\n gcry_mpi_release ( p ) ;\n p = NULL ;\n err = ec_p_new ( & ctx , p , a ) ;\n if ( ! err || gpg_err_code ( err ) != GPG_ERR_EINVAL ) fail ( \"ec_p_new: bad parameter detection failed (3)\\n\" ) ;\n gcry_mpi_release ( a ) ;\n a = NULL ;\n err = ec_p_new ( & ctx , p , a ) ;\n if ( ! err || gpg_err_code ( err ) != GPG_ERR_EINVAL ) fail ( \"ec_p_new: bad parameter detection failed (4)\\n\" ) ;\n }", "idx": 1289}
{"hash": -4885528830177756816, "project": "debian", "size": 267, "label": 0, "functionSource": "int chk_data_link ( MI_CHECK * param , MI_INFO * info , int extend ) {\n int error , got_error , flag ;\n uint key , UNINIT_VAR ( left_length ) , b_type , field ;\n ha_rows records , del_blocks ;\n my_off_t used , empty , pos , splits , UNINIT_VAR ( start_recpos ) , del_length , link_used , start_block ;\n uchar * record = 0 , * UNINIT_VAR ( to ) ;\n char llbuff [ 22 ] , llbuff2 [ 22 ] , llbuff3 [ 22 ] ;\n ha_checksum intern_record_checksum ;\n ha_checksum key_checksum [ HA_MAX_POSSIBLE_KEY ] ;\n my_bool static_row_size ;\n MI_KEYDEF * keyinfo ;\n MI_BLOCK_INFO block_info ;\n DBUG_ENTER ( \"chk_data_link\" ) ;\n if ( ! ( param -> testflag & T_SILENT ) ) {\n if ( extend ) puts ( \"- check records and index references\" ) ;\n else puts ( \"- check record links\" ) ;\n }\n if ( ! mi_alloc_rec_buff ( info , - 1 , & record ) ) {\n mi_check_print_error ( param , \"Not enough memory for record\" ) ;\n DBUG_RETURN ( - 1 ) ;\n }\n records = del_blocks = 0 ;\n used = link_used = splits = del_length = 0 ;\n intern_record_checksum = param -> glob_crc = 0 ;\n got_error = error = 0 ;\n empty = info -> s -> pack . header_length ;\n static_row_size = 1 ;\n if ( info -> s -> data_file_type == COMPRESSED_RECORD ) {\n for ( field = 0 ;\n field < info -> s -> base . fields ;\n field ++ ) {\n if ( info -> s -> rec [ field ] . base_type == FIELD_BLOB || info -> s -> rec [ field ] . base_type == FIELD_VARCHAR ) {\n static_row_size = 0 ;\n break ;\n }\n }\n }\n pos = my_b_tell ( & param -> read_cache ) ;\n bzero ( ( char * ) key_checksum , info -> s -> base . keys * sizeof ( key_checksum [ 0 ] ) ) ;\n while ( pos < info -> state -> data_file_length ) {\n if ( * killed_ptr ( param ) ) goto err2 ;\n switch ( info -> s -> data_file_type ) {\n case STATIC_RECORD : if ( my_b_read ( & param -> read_cache , ( uchar * ) record , info -> s -> base . pack_reclength ) ) goto err ;\n start_recpos = pos ;\n pos += info -> s -> base . pack_reclength ;\n splits ++ ;\n if ( * record == '\\0' ) {\n del_blocks ++ ;\n del_length += info -> s -> base . pack_reclength ;\n continue ;\n }\n param -> glob_crc += mi_static_checksum ( info , record ) ;\n used += info -> s -> base . pack_reclength ;\n break ;\n case DYNAMIC_RECORD : flag = block_info . second_read = 0 ;\n block_info . next_filepos = pos ;\n do {\n if ( _mi_read_cache ( & param -> read_cache , ( uchar * ) block_info . header , ( start_block = block_info . next_filepos ) , sizeof ( block_info . header ) , ( flag ? 0 : READING_NEXT ) | READING_HEADER ) ) goto err ;\n if ( start_block & ( MI_DYN_ALIGN_SIZE - 1 ) ) {\n mi_check_print_error ( param , \"Wrong aligned block at %s\" , llstr ( start_block , llbuff ) ) ;\n goto err2 ;\n }\n b_type = _mi_get_block_info ( & block_info , - 1 , start_block ) ;\n if ( b_type & ( BLOCK_DELETED | BLOCK_ERROR | BLOCK_SYNC_ERROR | BLOCK_FATAL_ERROR ) ) {\n if ( b_type & BLOCK_SYNC_ERROR ) {\n if ( flag ) {\n mi_check_print_error ( param , \"Unexpected byte: %d at link: %s\" , ( int ) block_info . header [ 0 ] , llstr ( start_block , llbuff ) ) ;\n goto err2 ;\n }\n pos = block_info . filepos + block_info . block_len ;\n goto next ;\n }\n if ( b_type & BLOCK_DELETED ) {\n if ( block_info . block_len < info -> s -> base . min_block_length ) {\n mi_check_print_error ( param , \"Deleted block with impossible length %lu at %s\" , block_info . block_len , llstr ( pos , llbuff ) ) ;\n goto err2 ;\n }\n if ( ( block_info . next_filepos != HA_OFFSET_ERROR && block_info . next_filepos >= info -> state -> data_file_length ) || ( block_info . prev_filepos != HA_OFFSET_ERROR && block_info . prev_filepos >= info -> state -> data_file_length ) ) {\n mi_check_print_error ( param , \"Delete link points outside datafile at %s\" , llstr ( pos , llbuff ) ) ;\n goto err2 ;\n }\n del_blocks ++ ;\n del_length += block_info . block_len ;\n pos = block_info . filepos + block_info . block_len ;\n splits ++ ;\n goto next ;\n }\n mi_check_print_error ( param , \"Wrong bytesec: %d-%d-%d at linkstart: %s\" , block_info . header [ 0 ] , block_info . header [ 1 ] , block_info . header [ 2 ] , llstr ( start_block , llbuff ) ) ;\n goto err2 ;\n }\n if ( info -> state -> data_file_length < block_info . filepos + block_info . block_len ) {\n mi_check_print_error ( param , \"Recordlink that points outside datafile at %s\" , llstr ( pos , llbuff ) ) ;\n got_error = 1 ;\n break ;\n }\n splits ++ ;\n if ( ! flag ++ ) {\n start_recpos = pos ;\n pos = block_info . filepos + block_info . block_len ;\n if ( block_info . rec_len > ( uint ) info -> s -> base . max_pack_length ) {\n mi_check_print_error ( param , \"Found too long record (%lu) at %s\" , ( ulong ) block_info . rec_len , llstr ( start_recpos , llbuff ) ) ;\n got_error = 1 ;\n break ;\n }\n if ( info -> s -> base . blobs ) {\n if ( ! ( to = mi_alloc_rec_buff ( info , block_info . rec_len , & info -> rec_buff ) ) ) {\n mi_check_print_error ( param , \"Not enough memory (%lu) for blob at %s\" , ( ulong ) block_info . rec_len , llstr ( start_recpos , llbuff ) ) ;\n got_error = 1 ;\n break ;\n }\n }\n else to = info -> rec_buff ;\n left_length = block_info . rec_len ;\n }\n if ( left_length < block_info . data_len ) {\n mi_check_print_error ( param , \"Found too long record (%lu) at %s\" , ( ulong ) block_info . data_len , llstr ( start_recpos , llbuff ) ) ;\n got_error = 1 ;\n break ;\n }\n if ( _mi_read_cache ( & param -> read_cache , ( uchar * ) to , block_info . filepos , ( uint ) block_info . data_len , flag == 1 ? READING_NEXT : 0 ) ) goto err ;\n to += block_info . data_len ;\n link_used += block_info . filepos - start_block ;\n used += block_info . filepos - start_block + block_info . data_len ;\n empty += block_info . block_len - block_info . data_len ;\n left_length -= block_info . data_len ;\n if ( left_length ) {\n if ( b_type & BLOCK_LAST ) {\n mi_check_print_error ( param , \"Wrong record length %s of %s at %s\" , llstr ( block_info . rec_len - left_length , llbuff ) , llstr ( block_info . rec_len , llbuff2 ) , llstr ( start_recpos , llbuff3 ) ) ;\n got_error = 1 ;\n break ;\n }\n if ( info -> state -> data_file_length < block_info . next_filepos ) {\n mi_check_print_error ( param , \"Found next-recordlink that points outside datafile at %s\" , llstr ( block_info . filepos , llbuff ) ) ;\n got_error = 1 ;\n break ;\n }\n }\n }\n while ( left_length ) ;\n if ( ! got_error ) {\n if ( _mi_rec_unpack ( info , record , info -> rec_buff , block_info . rec_len ) == MY_FILE_ERROR ) {\n mi_check_print_error ( param , \"Found wrong record at %s\" , llstr ( start_recpos , llbuff ) ) ;\n got_error = 1 ;\n }\n else {\n info -> checksum = mi_checksum ( info , record ) ;\n if ( param -> testflag & ( T_EXTEND | T_MEDIUM | T_VERBOSE ) ) {\n if ( _mi_rec_check ( info , record , info -> rec_buff , block_info . rec_len , test ( info -> s -> calc_checksum ) ) ) {\n mi_check_print_error ( param , \"Found wrong packed record at %s\" , llstr ( start_recpos , llbuff ) ) ;\n got_error = 1 ;\n }\n }\n if ( ! got_error ) param -> glob_crc += info -> checksum ;\n }\n }\n else if ( ! flag ) pos = block_info . filepos + block_info . block_len ;\n break ;\n case COMPRESSED_RECORD : if ( _mi_read_cache ( & param -> read_cache , ( uchar * ) block_info . header , pos , info -> s -> pack . ref_length , READING_NEXT ) ) goto err ;\n start_recpos = pos ;\n splits ++ ;\n ( void ) _mi_pack_get_block_info ( info , & info -> bit_buff , & block_info , & info -> rec_buff , - 1 , start_recpos ) ;\n pos = block_info . filepos + block_info . rec_len ;\n if ( block_info . rec_len < ( uint ) info -> s -> min_pack_length || block_info . rec_len > ( uint ) info -> s -> max_pack_length ) {\n mi_check_print_error ( param , \"Found block with wrong recordlength: %d at %s\" , block_info . rec_len , llstr ( start_recpos , llbuff ) ) ;\n got_error = 1 ;\n break ;\n }\n if ( _mi_read_cache ( & param -> read_cache , ( uchar * ) info -> rec_buff , block_info . filepos , block_info . rec_len , READING_NEXT ) ) goto err ;\n if ( _mi_pack_rec_unpack ( info , & info -> bit_buff , record , info -> rec_buff , block_info . rec_len ) ) {\n mi_check_print_error ( param , \"Found wrong record at %s\" , llstr ( start_recpos , llbuff ) ) ;\n got_error = 1 ;\n }\n if ( static_row_size ) param -> glob_crc += mi_static_checksum ( info , record ) ;\n else param -> glob_crc += mi_checksum ( info , record ) ;\n link_used += ( block_info . filepos - start_recpos ) ;\n used += ( pos - start_recpos ) ;\n break ;\n case BLOCK_RECORD : assert ( 0 ) ;\n }\n if ( ! got_error ) {\n intern_record_checksum += ( ha_checksum ) start_recpos ;\n records ++ ;\n if ( param -> testflag & T_WRITE_LOOP && records % WRITE_COUNT == 0 ) {\n printf ( \"%s\\r\" , llstr ( records , llbuff ) ) ;\n ( void ) fflush ( stdout ) ;\n }\n for ( key = 0 , keyinfo = info -> s -> keyinfo ;\n key < info -> s -> base . keys ;\n key ++ , keyinfo ++ ) {\n if ( mi_is_key_active ( info -> s -> state . key_map , key ) ) {\n if ( ! ( keyinfo -> flag & HA_FULLTEXT ) ) {\n uint key_length = _mi_make_key ( info , key , info -> lastkey , record , start_recpos ) ;\n if ( extend ) {\n int search_result = # ifdef HAVE_RTREE_KEYS ( keyinfo -> flag & HA_SPATIAL ) ? rtree_find_first ( info , key , info -> lastkey , key_length , MBR_EQUAL | MBR_DATA ) : # endif _mi_search ( info , keyinfo , info -> lastkey , key_length , SEARCH_SAME , info -> s -> state . key_root [ key ] ) ;\n if ( search_result ) {\n mi_check_print_error ( param , \"Record at: %10s \" \"Can't find key for index: %2d\" , llstr ( start_recpos , llbuff ) , key + 1 ) ;\n if ( error ++ > MAXERR || ! ( param -> testflag & T_VERBOSE ) ) goto err2 ;\n }\n }\n else key_checksum [ key ] += mi_byte_checksum ( ( uchar * ) info -> lastkey , key_length ) ;\n }\n }\n }\n }\n else {\n got_error = 0 ;\n if ( error ++ > MAXERR || ! ( param -> testflag & T_VERBOSE ) ) goto err2 ;\n }\n next : ;\n }\n if ( param -> testflag & T_WRITE_LOOP ) {\n ( void ) fputs ( \" \\r\" , stdout ) ;\n ( void ) fflush ( stdout ) ;\n }\n if ( records != info -> state -> records ) {\n mi_check_print_error ( param , \"Record-count is not ok;\n is %-10s Should be: %s\" , llstr ( records , llbuff ) , llstr ( info -> state -> records , llbuff2 ) ) ;\n error = 1 ;\n }\n else if ( param -> record_checksum && param -> record_checksum != intern_record_checksum ) {\n mi_check_print_error ( param , \"Keypointers and record positions doesn't match\" ) ;\n error = 1 ;\n }\n else if ( param -> glob_crc != info -> state -> checksum && ( info -> s -> options & ( HA_OPTION_CHECKSUM | HA_OPTION_COMPRESS_RECORD ) ) ) {\n mi_check_print_warning ( param , \"Record checksum is not the same as checksum stored in the index file\\n\" ) ;\n error = 1 ;\n }\n else if ( ! extend ) {\n for ( key = 0 ;\n key < info -> s -> base . keys ;\n key ++ ) {\n if ( key_checksum [ key ] != param -> key_crc [ key ] && ! ( info -> s -> keyinfo [ key ] . flag & ( HA_FULLTEXT | HA_SPATIAL ) ) ) {\n mi_check_print_error ( param , \"Checksum for key: %2d doesn't match checksum for records\" , key + 1 ) ;\n error = 1 ;\n }\n }\n }\n if ( del_length != info -> state -> empty ) {\n mi_check_print_warning ( param , \"Found %s deleted space. Should be %s\" , llstr ( del_length , llbuff2 ) , llstr ( info -> state -> empty , llbuff ) ) ;\n }\n if ( used + empty + del_length != info -> state -> data_file_length ) {\n mi_check_print_warning ( param , \"Found %s record-data and %s unused data and %s deleted-data\" , llstr ( used , llbuff ) , llstr ( empty , llbuff2 ) , llstr ( del_length , llbuff3 ) ) ;\n mi_check_print_warning ( param , \"Total %s, Should be: %s\" , llstr ( ( used + empty + del_length ) , llbuff ) , llstr ( info -> state -> data_file_length , llbuff2 ) ) ;\n }\n if ( del_blocks != info -> state -> del ) {\n mi_check_print_warning ( param , \"Found %10s deleted blocks Should be: %s\" , llstr ( del_blocks , llbuff ) , llstr ( info -> state -> del , llbuff2 ) ) ;\n }\n if ( splits != info -> s -> state . split ) {\n mi_check_print_warning ( param , \"Found %10s key parts. Should be: %s\" , llstr ( splits , llbuff ) , llstr ( info -> s -> state . split , llbuff2 ) ) ;\n }\n if ( param -> testflag & T_INFO ) {\n if ( param -> warning_printed || param -> error_printed ) puts ( \"\" ) ;\n if ( used != 0 && ! param -> error_printed ) {\n printf ( \"Records:%18s M.recordlength:%9lu Packed:%14.0f%%\\n\" , llstr ( records , llbuff ) , ( long ) ( ( used - link_used ) / records ) , ( info -> s -> base . blobs ? 0.0 : ( ulonglong2double ( ( ulonglong ) info -> s -> base . reclength * records ) - my_off_t2double ( used ) ) / ulonglong2double ( ( ulonglong ) info -> s -> base . reclength * records ) * 100.0 ) ) ;\n printf ( \"Recordspace used:%9.0f%% Empty space:%12d%% Blocks/Record: %6.2f\\n\" , ( ulonglong2double ( used - link_used ) / ulonglong2double ( used - link_used + empty ) * 100.0 ) , ( ! records ? 100 : ( int ) ( ulonglong2double ( del_length + empty ) / my_off_t2double ( used ) * 100.0 ) ) , ulonglong2double ( splits - del_blocks ) / records ) ;\n }\n printf ( \"Record blocks:%12s Delete blocks:%10s\\n\" , llstr ( splits - del_blocks , llbuff ) , llstr ( del_blocks , llbuff2 ) ) ;\n printf ( \"Record data: %12s Deleted data: %10s\\n\" , llstr ( used - link_used , llbuff ) , llstr ( del_length , llbuff2 ) ) ;\n printf ( \"Lost space: %12s Linkdata: %10s\\n\" , llstr ( empty , llbuff ) , llstr ( link_used , llbuff2 ) ) ;\n }\n my_free ( mi_get_rec_buff_ptr ( info , record ) ) ;\n DBUG_RETURN ( error ) ;\n err : mi_check_print_error ( param , \"got error: %d when reading datafile at record: %s\" , my_errno , llstr ( records , llbuff ) ) ;\n err2 : my_free ( mi_get_rec_buff_ptr ( info , record ) ) ;\n param -> testflag |= T_RETRY_WITHOUT_QUICK ;\n DBUG_RETURN ( 1 ) ;\n }", "idx": 1290}
{"hash": -2443338381883395438, "project": "debian", "size": 8, "label": 1, "functionSource": "void msyslog ( int level , const char * fmt , ... ) {\n char buf [ 1024 ] ;\n va_list ap ;\n va_start ( ap , fmt ) ;\n mvsnprintf ( buf , sizeof ( buf ) , fmt , ap ) ;\n va_end ( ap ) ;\n addto_syslog ( level , buf ) ;\n }", "idx": 1291}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_LogicalChannelRateAcknowledge ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_LogicalChannelRateAcknowledge , LogicalChannelRateAcknowledge_sequence ) ;\n return offset ;\n }", "idx": 1292}
{"hash": -5706788925640467782, "project": "chrome", "size": 7, "label": 0, "functionSource": "static unsigned int get_sby_perpixel_diff_variance ( VP9_COMP * cpi , const struct buf_2d * ref , int mi_row , int mi_col , BLOCK_SIZE bs ) {\n const YV12_BUFFER_CONFIG * last = get_ref_frame_buffer ( cpi , LAST_FRAME ) ;\n const uint8_t * last_y = & last -> y_buffer [ mi_row * MI_SIZE * last -> y_stride + mi_col * MI_SIZE ] ;\n unsigned int sse ;\n const unsigned int var = cpi -> fn_ptr [ bs ] . vf ( ref -> buf , ref -> stride , last_y , last -> y_stride , & sse ) ;\n return ROUND_POWER_OF_TWO ( var , num_pels_log2_lookup [ bs ] ) ;\n }", "idx": 1293}
{"hash": 1144893748552025496, "project": "debian", "size": 22, "label": 0, "functionSource": "static void libopenjpeg_copyto16 ( AVFrame * p , opj_image_t * image ) {\n int * comp_data ;\n uint16_t * img_ptr ;\n int index , x , y ;\n for ( index = 0 ;\n index < image -> numcomps ;\n index ++ ) {\n comp_data = image -> comps [ index ] . data ;\n for ( y = 0 ;\n y < image -> comps [ index ] . h ;\n y ++ ) {\n img_ptr = ( uint16_t * ) ( p -> data [ index ] + y * p -> linesize [ index ] ) ;\n for ( x = 0 ;\n x < image -> comps [ index ] . w ;\n x ++ ) {\n * img_ptr = * comp_data ;\n img_ptr ++ ;\n comp_data ++ ;\n }\n }\n }\n }", "idx": 1294}
{"hash": 4489017523191997023, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h225_AdmissionReject ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_AdmissionReject , AdmissionReject_sequence ) ;\n return offset ;\n }", "idx": 1295}
{"hash": -6552851419396579257, "project": "debian", "size": 8, "label": 0, "functionSource": "static int SpoolssRFNPCNEX_q ( tvbuff_t * tvb , int offset , packet_info * pinfo , proto_tree * tree , dcerpc_info * di , guint8 * drep ) {\n guint32 changeid ;\n offset = dissect_nt_policy_hnd ( tvb , offset , pinfo , tree , di , drep , hf_hnd , NULL , NULL , FALSE , FALSE ) ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , tree , di , drep , hf_rrpcn_changelow , & changeid ) ;\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \", changeid %d\" , changeid ) ;\n offset = dissect_ndr_pointer ( tvb , offset , pinfo , tree , di , drep , dissect_NOTIFY_OPTIONS_ARRAY_CTR , NDR_POINTER_UNIQUE , \"Notify Options Array Container\" , - 1 ) ;\n return offset ;\n }", "idx": 1296}
{"hash": -7236893719053583356, "project": "debian", "size": 37, "label": 0, "functionSource": "void proto_register_zbee_zcl_ballast_configuration ( void ) {\n static hf_register_info hf [ ] = {\n {\n & hf_zbee_zcl_ballast_configuration_attr_id , {\n \"Attribute\" , \"zbee_zcl_lighting.ballast_configuration.attr_id\" , FT_UINT16 , BASE_HEX , VALS ( zbee_zcl_ballast_configuration_attr_names ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_zbee_zcl_ballast_configuration_status , {\n \"Status\" , \"zbee_zcl_lighting.ballast_configuration.attr.status\" , FT_UINT8 , BASE_HEX , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_zbee_zcl_ballast_configuration_status_non_operational , {\n \"Non-operational\" , \"zbee_zcl_lighting.ballast_configuration.attr.status.non_operational\" , FT_UINT8 , BASE_HEX , VALS ( zbee_zcl_ballast_configuration_status_non_operational_names ) , ZBEE_ZCL_BALLAST_CONFIGURATION_STATUS_NON_OPERATIONAL , NULL , HFILL }\n }\n , {\n & hf_zbee_zcl_ballast_configuration_status_lamp_not_in_socket , {\n \"Not in Socket\" , \"zbee_zcl_lighting.ballast_configuration.attr.status.not_in_socket\" , FT_UINT8 , BASE_HEX , VALS ( zbee_zcl_ballast_configuration_status_lamp_not_in_socket_names ) , ZBEE_ZCL_BALLAST_CONFIGURATION_STATUS_LAMP_NOT_IN_SOCKET , NULL , HFILL }\n }\n , {\n & hf_zbee_zcl_ballast_configuration_lamp_alarm_mode , {\n \"Lamp Alarm Mode\" , \"zbee_zcl_lighting.ballast_configuration.attr.lamp_alarm_mode\" , FT_UINT8 , BASE_HEX , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_zbee_zcl_ballast_configuration_lamp_alarm_mode_lamp_burn_hours , {\n \"Lamp Burn Hours\" , \"zbee_zcl_lighting.ballast_configuration.attr.lamp_alarm_mode.lamp_burn_hours\" , FT_BOOLEAN , 8 , NULL , ZBEE_ZCL_BALLAST_CONFIGURATION_LAMP_ALARM_MODE_LAMP_BURN_HOURS , NULL , HFILL }\n }\n }\n ;\n static gint * ett [ ZBEE_ZCL_BALLAST_CONFIGURATION_NUM_ETT ] ;\n ett [ 0 ] = & ett_zbee_zcl_ballast_configuration ;\n ett [ 1 ] = & ett_zbee_zcl_ballast_configuration_status ;\n ett [ 2 ] = & ett_zbee_zcl_ballast_configuration_lamp_alarm_mode ;\n proto_zbee_zcl_ballast_configuration = proto_register_protocol ( \"ZigBee ZCL Ballast Configuration\" , \"ZCL Ballast Configuration\" , ZBEE_PROTOABBREV_ZCL_BALLAST_CONFIG ) ;\n proto_register_field_array ( proto_zbee_zcl_ballast_configuration , hf , array_length ( hf ) ) ;\n proto_register_subtree_array ( ett , array_length ( ett ) ) ;\n register_dissector ( ZBEE_PROTOABBREV_ZCL_BALLAST_CONFIG , dissect_zbee_zcl_ballast_configuration , proto_zbee_zcl_ballast_configuration ) ;\n }", "idx": 1297}
{"hash": 355220887711506893, "project": "debian", "size": 3, "label": 0, "functionSource": "static double patternjoinsel ( PG_FUNCTION_ARGS , Pattern_Type ptype , bool negate ) {\n return negate ? ( 1.0 - DEFAULT_MATCH_SEL ) : DEFAULT_MATCH_SEL ;\n }", "idx": 1298}
{"hash": 1788300783882316916, "project": "debian", "size": 8, "label": 0, "functionSource": "static inline unsigned update_map_generation ( MotionEstContext * c ) {\n c -> map_generation += 1 << ( ME_MAP_MV_BITS * 2 ) ;\n if ( c -> map_generation == 0 ) {\n c -> map_generation = 1 << ( ME_MAP_MV_BITS * 2 ) ;\n memset ( c -> map , 0 , sizeof ( uint32_t ) * ME_MAP_SIZE ) ;\n }\n return c -> map_generation ;\n }", "idx": 1299}
{"hash": -341028540041678099, "project": "debian", "size": 96, "label": 0, "functionSource": "static int openhost ( const char * hname , int fam ) {\n const char svc [ ] = \"ntp\" ;\n char temphost [ LENHOSTNAME ] ;\n int a_info , i ;\n struct addrinfo hints , * ai ;\n sockaddr_u addr ;\n size_t octets ;\n register const char * cp ;\n char name [ LENHOSTNAME ] ;\n cp = hname ;\n if ( * cp == '[' ) {\n cp ++ ;\n for ( i = 0 ;\n * cp && * cp != ']' ;\n cp ++ , i ++ ) name [ i ] = * cp ;\n if ( * cp == ']' ) {\n name [ i ] = '\\0' ;\n hname = name ;\n }\n else {\n return 0 ;\n }\n }\n ZERO ( hints ) ;\n hints . ai_family = fam ;\n hints . ai_protocol = IPPROTO_UDP ;\n hints . ai_socktype = SOCK_DGRAM ;\n hints . ai_flags = Z_AI_NUMERICHOST ;\n ai = NULL ;\n a_info = getaddrinfo ( hname , svc , & hints , & ai ) ;\n if ( a_info == EAI_NONAME # ifdef EAI_NODATA || a_info == EAI_NODATA # endif ) {\n hints . ai_flags = AI_CANONNAME ;\n # ifdef AI_ADDRCONFIG hints . ai_flags |= AI_ADDRCONFIG ;\n # endif a_info = getaddrinfo ( hname , svc , & hints , & ai ) ;\n }\n # ifdef AI_ADDRCONFIG if ( a_info == EAI_BADFLAGS ) {\n hints . ai_flags &= ~ AI_ADDRCONFIG ;\n a_info = getaddrinfo ( hname , svc , & hints , & ai ) ;\n }\n # endif if ( a_info != 0 ) {\n fprintf ( stderr , \"%s\\n\" , gai_strerror ( a_info ) ) ;\n return 0 ;\n }\n INSIST ( ai != NULL ) ;\n ZERO ( addr ) ;\n octets = min ( sizeof ( addr ) , ai -> ai_addrlen ) ;\n memcpy ( & addr , ai -> ai_addr , octets ) ;\n if ( ai -> ai_canonname == NULL ) {\n strlcpy ( temphost , stoa ( & addr ) , sizeof ( temphost ) ) ;\n currenthostisnum = TRUE ;\n }\n else {\n strlcpy ( temphost , ai -> ai_canonname , sizeof ( temphost ) ) ;\n currenthostisnum = FALSE ;\n }\n if ( debug > 2 ) printf ( \"Opening host %s (%s)\\n\" , temphost , ( ai -> ai_family == AF_INET ) ? \"AF_INET\" : ( ai -> ai_family == AF_INET6 ) ? \"AF_INET6\" : \"AF-???\" ) ;\n if ( havehost == 1 ) {\n if ( debug > 2 ) printf ( \"Closing old host %s\\n\" , currenthost ) ;\n closesocket ( sockfd ) ;\n havehost = 0 ;\n }\n strlcpy ( currenthost , temphost , sizeof ( currenthost ) ) ;\n s_port = NSRCPORT ( & addr ) ;\n # ifdef SYS_VXWORKS ( ( struct sockaddr_in6 * ) & hostaddr ) -> sin6_port = htons ( SERVER_PORT_NUM ) ;\n if ( ai -> ai_family == AF_INET ) * ( struct sockaddr_in * ) & hostaddr = * ( ( struct sockaddr_in * ) ai -> ai_addr ) ;\n else * ( struct sockaddr_in6 * ) & hostaddr = * ( ( struct sockaddr_in6 * ) ai -> ai_addr ) ;\n # endif # ifdef SYS_WINNT {\n int optionValue = SO_SYNCHRONOUS_NONALERT ;\n int err ;\n err = setsockopt ( INVALID_SOCKET , SOL_SOCKET , SO_OPENTYPE , ( char * ) & optionValue , sizeof ( optionValue ) ) ;\n if ( err ) {\n mfprintf ( stderr , \"setsockopt(SO_SYNCHRONOUS_NONALERT)\" \" error: %m\\n\" ) ;\n freeaddrinfo ( ai ) ;\n exit ( 1 ) ;\n }\n }\n # endif sockfd = socket ( ai -> ai_family , ai -> ai_socktype , ai -> ai_protocol ) ;\n if ( sockfd == INVALID_SOCKET ) {\n error ( \"socket\" ) ;\n freeaddrinfo ( ai ) ;\n return 0 ;\n }\n # ifdef NEED_RCVBUF_SLOP # ifdef SO_RCVBUF {\n int rbufsize = DATASIZE + 2048 ;\n if ( setsockopt ( sockfd , SOL_SOCKET , SO_RCVBUF , & rbufsize , sizeof ( int ) ) == - 1 ) error ( \"setsockopt\" ) ;\n }\n # endif # endif if # ifdef SYS_VXWORKS ( connect ( sockfd , ( struct sockaddr * ) & hostaddr , sizeof ( hostaddr ) ) == - 1 ) # else ( connect ( sockfd , ( struct sockaddr * ) ai -> ai_addr , ai -> ai_addrlen ) == - 1 ) # endif {\n error ( \"connect\" ) ;\n freeaddrinfo ( ai ) ;\n return 0 ;\n }\n freeaddrinfo ( ai ) ;\n havehost = 1 ;\n numassoc = 0 ;\n return 1 ;\n }", "idx": 1300}
{"hash": 7651945086108393719, "project": "debian", "size": 86, "label": 0, "functionSource": "int qemuMonitorJSONGetBlockStatsInfo ( qemuMonitorPtr mon , const char * dev_name , long long * rd_req , long long * rd_bytes , long long * rd_total_times , long long * wr_req , long long * wr_bytes , long long * wr_total_times , long long * flush_req , long long * flush_total_times , long long * errs ) {\n int ret ;\n int i ;\n int found = 0 ;\n virJSONValuePtr cmd = qemuMonitorJSONMakeCommand ( \"query-blockstats\" , NULL ) ;\n virJSONValuePtr reply = NULL ;\n virJSONValuePtr devices ;\n * rd_req = * rd_bytes = - 1 ;\n * wr_req = * wr_bytes = * errs = - 1 ;\n if ( rd_total_times ) * rd_total_times = - 1 ;\n if ( wr_total_times ) * wr_total_times = - 1 ;\n if ( flush_req ) * flush_req = - 1 ;\n if ( flush_total_times ) * flush_total_times = - 1 ;\n if ( ! cmd ) return - 1 ;\n ret = qemuMonitorJSONCommand ( mon , cmd , & reply ) ;\n if ( ret == 0 ) ret = qemuMonitorJSONCheckError ( cmd , reply ) ;\n if ( ret < 0 ) goto cleanup ;\n ret = - 1 ;\n devices = virJSONValueObjectGet ( reply , \"return\" ) ;\n if ( ! devices || devices -> type != VIR_JSON_TYPE_ARRAY ) {\n qemuReportError ( VIR_ERR_INTERNAL_ERROR , \"%s\" , _ ( \"blockstats reply was missing device list\" ) ) ;\n goto cleanup ;\n }\n for ( i = 0 ;\n i < virJSONValueArraySize ( devices ) ;\n i ++ ) {\n virJSONValuePtr dev = virJSONValueArrayGet ( devices , i ) ;\n virJSONValuePtr stats ;\n const char * thisdev ;\n if ( ! dev || dev -> type != VIR_JSON_TYPE_OBJECT ) {\n qemuReportError ( VIR_ERR_INTERNAL_ERROR , \"%s\" , _ ( \"blockstats device entry was not in expected format\" ) ) ;\n goto cleanup ;\n }\n if ( ( thisdev = virJSONValueObjectGetString ( dev , \"device\" ) ) == NULL ) {\n qemuReportError ( VIR_ERR_INTERNAL_ERROR , \"%s\" , _ ( \"blockstats device entry was not in expected format\" ) ) ;\n goto cleanup ;\n }\n if ( STRPREFIX ( thisdev , QEMU_DRIVE_HOST_PREFIX ) ) thisdev += strlen ( QEMU_DRIVE_HOST_PREFIX ) ;\n if ( STRNEQ ( thisdev , dev_name ) ) continue ;\n found = 1 ;\n if ( ( stats = virJSONValueObjectGet ( dev , \"stats\" ) ) == NULL || stats -> type != VIR_JSON_TYPE_OBJECT ) {\n qemuReportError ( VIR_ERR_INTERNAL_ERROR , \"%s\" , _ ( \"blockstats stats entry was not in expected format\" ) ) ;\n goto cleanup ;\n }\n if ( virJSONValueObjectGetNumberLong ( stats , \"rd_bytes\" , rd_bytes ) < 0 ) {\n qemuReportError ( VIR_ERR_INTERNAL_ERROR , _ ( \"cannot read %s statistic\" ) , \"rd_bytes\" ) ;\n goto cleanup ;\n }\n if ( virJSONValueObjectGetNumberLong ( stats , \"rd_operations\" , rd_req ) < 0 ) {\n qemuReportError ( VIR_ERR_INTERNAL_ERROR , _ ( \"cannot read %s statistic\" ) , \"rd_operations\" ) ;\n goto cleanup ;\n }\n if ( rd_total_times && virJSONValueObjectHasKey ( stats , \"rd_total_times_ns\" ) && ( virJSONValueObjectGetNumberLong ( stats , \"rd_total_times_ns\" , rd_total_times ) < 0 ) ) {\n qemuReportError ( VIR_ERR_INTERNAL_ERROR , _ ( \"cannot read %s statistic\" ) , \"rd_total_times_ns\" ) ;\n goto cleanup ;\n }\n if ( virJSONValueObjectGetNumberLong ( stats , \"wr_bytes\" , wr_bytes ) < 0 ) {\n qemuReportError ( VIR_ERR_INTERNAL_ERROR , _ ( \"cannot read %s statistic\" ) , \"wr_bytes\" ) ;\n goto cleanup ;\n }\n if ( virJSONValueObjectGetNumberLong ( stats , \"wr_operations\" , wr_req ) < 0 ) {\n qemuReportError ( VIR_ERR_INTERNAL_ERROR , _ ( \"cannot read %s statistic\" ) , \"wr_operations\" ) ;\n goto cleanup ;\n }\n if ( wr_total_times && virJSONValueObjectHasKey ( stats , \"wr_total_times_ns\" ) && ( virJSONValueObjectGetNumberLong ( stats , \"wr_total_times_ns\" , wr_total_times ) < 0 ) ) {\n qemuReportError ( VIR_ERR_INTERNAL_ERROR , _ ( \"cannot read %s statistic\" ) , \"wr_total_times_ns\" ) ;\n goto cleanup ;\n }\n if ( flush_req && virJSONValueObjectHasKey ( stats , \"flush_operations\" ) && ( virJSONValueObjectGetNumberLong ( stats , \"flush_operations\" , flush_req ) < 0 ) ) {\n qemuReportError ( VIR_ERR_INTERNAL_ERROR , _ ( \"cannot read %s statistic\" ) , \"flush_operations\" ) ;\n goto cleanup ;\n }\n if ( flush_total_times && virJSONValueObjectHasKey ( stats , \"flush_total_times_ns\" ) && ( virJSONValueObjectGetNumberLong ( stats , \"flush_total_times_ns\" , flush_total_times ) < 0 ) ) {\n qemuReportError ( VIR_ERR_INTERNAL_ERROR , _ ( \"cannot read %s statistic\" ) , \"flush_total_times_ns\" ) ;\n goto cleanup ;\n }\n }\n if ( ! found ) {\n qemuReportError ( VIR_ERR_INTERNAL_ERROR , _ ( \"cannot find statistics for device '%s'\" ) , dev_name ) ;\n goto cleanup ;\n }\n ret = 0 ;\n cleanup : virJSONValueFree ( cmd ) ;\n virJSONValueFree ( reply ) ;\n return ret ;\n }", "idx": 1301}
{"hash": 3090981948963373743, "project": "debian", "size": 22, "label": 0, "functionSource": "static void decode ( RA288Context * ractx , float gain , int cb_coef ) {\n int i ;\n double sumsum ;\n float sum , buffer [ 5 ] ;\n float * block = ractx -> sp_hist + 70 + 36 ;\n float * gain_block = ractx -> gain_hist + 28 ;\n memmove ( ractx -> sp_hist + 70 , ractx -> sp_hist + 75 , 36 * sizeof ( * block ) ) ;\n sum = 32. ;\n for ( i = 0 ;\n i < 10 ;\n i ++ ) sum -= gain_block [ 9 - i ] * ractx -> gain_lpc [ i ] ;\n sum = av_clipf ( sum , 0 , 60 ) ;\n sumsum = exp ( sum * 0.1151292546497 ) * gain * ( 1.0 / ( 1 << 23 ) ) ;\n for ( i = 0 ;\n i < 5 ;\n i ++ ) buffer [ i ] = codetable [ cb_coef ] [ i ] * sumsum ;\n sum = avpriv_scalarproduct_float_c ( buffer , buffer , 5 ) * ( ( 1 << 24 ) / 5. ) ;\n sum = FFMAX ( sum , 1 ) ;\n memmove ( gain_block , gain_block + 1 , 9 * sizeof ( * gain_block ) ) ;\n gain_block [ 9 ] = 10 * log10 ( sum ) - 32 ;\n ff_celp_lp_synthesis_filterf ( block , ractx -> sp_lpc , buffer , 5 , 36 ) ;\n }", "idx": 1302}
{"hash": -8437173884317959107, "project": "debian", "size": 30, "label": 0, "functionSource": "static int create_map ( vorbis_context * vc , unsigned floor_number ) {\n vorbis_floor * floors = vc -> floors ;\n vorbis_floor0 * vf ;\n int idx ;\n int blockflag , n ;\n int32_t * map ;\n for ( blockflag = 0 ;\n blockflag < 2 ;\n ++ blockflag ) {\n n = vc -> blocksize [ blockflag ] / 2 ;\n floors [ floor_number ] . data . t0 . map [ blockflag ] = av_malloc ( ( n + 1 ) * sizeof ( int32_t ) ) ;\n if ( ! floors [ floor_number ] . data . t0 . map [ blockflag ] ) return AVERROR ( ENOMEM ) ;\n map = floors [ floor_number ] . data . t0 . map [ blockflag ] ;\n vf = & floors [ floor_number ] . data . t0 ;\n for ( idx = 0 ;\n idx < n ;\n ++ idx ) {\n map [ idx ] = floor ( BARK ( ( vf -> rate * idx ) / ( 2.0f * n ) ) * ( vf -> bark_map_size / BARK ( vf -> rate / 2.0f ) ) ) ;\n if ( vf -> bark_map_size - 1 < map [ idx ] ) map [ idx ] = vf -> bark_map_size - 1 ;\n }\n map [ n ] = - 1 ;\n vf -> map_size [ blockflag ] = n ;\n }\n for ( idx = 0 ;\n idx <= n ;\n ++ idx ) {\n av_dlog ( NULL , \"floor0 map: map at pos %d is %d\\n\" , idx , map [ idx ] ) ;\n }\n return 0 ;\n }", "idx": 1303}
{"hash": 355220887711506893, "project": "debian", "size": 27, "label": 1, "functionSource": "double histogram_selectivity ( VariableStatData * vardata , FmgrInfo * opproc , Datum constval , bool varonleft , int min_hist_size , int n_skip , int * hist_size ) {\n double result ;\n Datum * values ;\n int nvalues ;\n Assert ( n_skip >= 0 ) ;\n Assert ( min_hist_size > 2 * n_skip ) ;\n if ( HeapTupleIsValid ( vardata -> statsTuple ) && get_attstatsslot ( vardata -> statsTuple , vardata -> atttype , vardata -> atttypmod , STATISTIC_KIND_HISTOGRAM , InvalidOid , NULL , & values , & nvalues , NULL , NULL ) ) {\n * hist_size = nvalues ;\n if ( nvalues >= min_hist_size ) {\n int nmatch = 0 ;\n int i ;\n for ( i = n_skip ;\n i < nvalues - n_skip ;\n i ++ ) {\n if ( varonleft ? DatumGetBool ( FunctionCall2Coll ( opproc , DEFAULT_COLLATION_OID , values [ i ] , constval ) ) : DatumGetBool ( FunctionCall2Coll ( opproc , DEFAULT_COLLATION_OID , constval , values [ i ] ) ) ) nmatch ++ ;\n }\n result = ( ( double ) nmatch ) / ( ( double ) ( nvalues - 2 * n_skip ) ) ;\n }\n else result = - 1 ;\n free_attstatsslot ( vardata -> atttype , values , nvalues , NULL , 0 ) ;\n }\n else {\n * hist_size = 0 ;\n result = - 1 ;\n }\n return result ;\n }", "idx": 1304}
{"hash": 373200843854506734, "project": "chrome", "size": 15, "label": 0, "functionSource": "NewConverter * CnvExtOpen ( UCMFile * ucm ) {\n CnvExtData * extData ;\n extData = ( CnvExtData * ) uprv_malloc ( sizeof ( CnvExtData ) ) ;\n if ( extData == NULL ) {\n printf ( \"out of memory\\n\" ) ;\n exit ( U_MEMORY_ALLOCATION_ERROR ) ;\n }\n uprv_memset ( extData , 0 , sizeof ( CnvExtData ) ) ;\n extData -> ucm = ucm ;\n extData -> newConverter . close = CnvExtClose ;\n extData -> newConverter . isValid = CnvExtIsValid ;\n extData -> newConverter . addTable = CnvExtAddTable ;\n extData -> newConverter . write = CnvExtWrite ;\n return & extData -> newConverter ;\n }", "idx": 1305}
{"hash": 3309252579593081468, "project": "debian", "size": 6, "label": 0, "functionSource": "static int fetch_tempfile ( char * line , void * data ) {\n FILE * fp = data ;\n if ( ! line ) rewind ( fp ) ;\n else if ( fputs ( line , fp ) == EOF || fputc ( '\\n' , fp ) == EOF ) return - 1 ;\n return 0 ;\n }", "idx": 1306}
{"hash": 8388187431631506723, "project": "debian", "size": 5, "label": 0, "functionSource": "static int fpreg_pre_save ( void * opaque ) {\n x86_FPReg_tmp * tmp = opaque ;\n cpu_get_fp80 ( & tmp -> tmp_mant , & tmp -> tmp_exp , tmp -> parent -> d ) ;\n return 0 ;\n }", "idx": 1307}
{"hash": -4136373206107992781, "project": "chrome", "size": 32, "label": 1, "functionSource": "static void _ISCIIOpen ( UConverter * cnv , UConverterLoadArgs * pArgs , UErrorCode * errorCode ) {\n if ( pArgs -> onlyTestIsLoadable ) {\n return ;\n }\n cnv -> extraInfo = uprv_malloc ( sizeof ( UConverterDataISCII ) ) ;\n if ( cnv -> extraInfo != NULL ) {\n int32_t len = 0 ;\n UConverterDataISCII * converterData = ( UConverterDataISCII * ) cnv -> extraInfo ;\n converterData -> contextCharToUnicode = NO_CHAR_MARKER ;\n cnv -> toUnicodeStatus = missingCharMarker ;\n converterData -> contextCharFromUnicode = 0x0000 ;\n converterData -> resetToDefaultToUnicode = FALSE ;\n if ( ( pArgs -> options & UCNV_OPTIONS_VERSION_MASK ) < 9 ) {\n converterData -> currentDeltaFromUnicode = converterData -> currentDeltaToUnicode = converterData -> defDeltaToUnicode = ( uint16_t ) ( lookupInitialData [ pArgs -> options & UCNV_OPTIONS_VERSION_MASK ] . uniLang * DELTA ) ;\n converterData -> currentMaskFromUnicode = converterData -> currentMaskToUnicode = converterData -> defMaskToUnicode = lookupInitialData [ pArgs -> options & UCNV_OPTIONS_VERSION_MASK ] . maskEnum ;\n converterData -> isFirstBuffer = TRUE ;\n ( void ) uprv_strcpy ( converterData -> name , ISCII_CNV_PREFIX ) ;\n len = ( int32_t ) uprv_strlen ( converterData -> name ) ;\n converterData -> name [ len ] = ( char ) ( ( pArgs -> options & UCNV_OPTIONS_VERSION_MASK ) + '0' ) ;\n converterData -> name [ len + 1 ] = 0 ;\n converterData -> prevToUnicodeStatus = 0x0000 ;\n }\n else {\n uprv_free ( cnv -> extraInfo ) ;\n cnv -> extraInfo = NULL ;\n * errorCode = U_ILLEGAL_ARGUMENT_ERROR ;\n }\n }\n else {\n * errorCode = U_MEMORY_ALLOCATION_ERROR ;\n }\n }", "idx": 1308}
{"hash": 2687336064028423153, "project": "chrome", "size": 61, "label": 0, "functionSource": "static int request_parse ( u8 * packet , int length , struct evdns_server_port * port , struct sockaddr * addr , socklen_t addrlen ) {\n int j = 0 ;\n u16 _t ;\n char tmp_name [ 256 ] ;\n int i ;\n u16 trans_id , flags , questions , answers , authority , additional ;\n struct server_request * server_req = NULL ;\n GET16 ( trans_id ) ;\n GET16 ( flags ) ;\n GET16 ( questions ) ;\n GET16 ( answers ) ;\n GET16 ( authority ) ;\n GET16 ( additional ) ;\n if ( flags & 0x8000 ) return - 1 ;\n flags &= 0x0110 ;\n server_req = malloc ( sizeof ( struct server_request ) ) ;\n if ( server_req == NULL ) return - 1 ;\n memset ( server_req , 0 , sizeof ( struct server_request ) ) ;\n server_req -> trans_id = trans_id ;\n memcpy ( & server_req -> addr , addr , addrlen ) ;\n server_req -> addrlen = addrlen ;\n server_req -> base . flags = flags ;\n server_req -> base . nquestions = 0 ;\n server_req -> base . questions = malloc ( sizeof ( struct evdns_server_question * ) * questions ) ;\n if ( server_req -> base . questions == NULL ) goto err ;\n for ( i = 0 ;\n i < questions ;\n ++ i ) {\n u16 type , class ;\n struct evdns_server_question * q ;\n int namelen ;\n if ( name_parse ( packet , length , & j , tmp_name , sizeof ( tmp_name ) ) < 0 ) goto err ;\n GET16 ( type ) ;\n GET16 ( class ) ;\n namelen = strlen ( tmp_name ) ;\n q = malloc ( sizeof ( struct evdns_server_question ) + namelen ) ;\n if ( ! q ) goto err ;\n q -> type = type ;\n q -> dns_question_class = class ;\n memcpy ( q -> name , tmp_name , namelen + 1 ) ;\n server_req -> base . questions [ server_req -> base . nquestions ++ ] = q ;\n }\n server_req -> port = port ;\n port -> refcnt ++ ;\n if ( flags & 0x7800 ) {\n evdns_server_request_respond ( & ( server_req -> base ) , DNS_ERR_NOTIMPL ) ;\n return - 1 ;\n }\n port -> user_callback ( & ( server_req -> base ) , port -> user_data ) ;\n return 0 ;\n err : if ( server_req ) {\n if ( server_req -> base . questions ) {\n for ( i = 0 ;\n i < server_req -> base . nquestions ;\n ++ i ) free ( server_req -> base . questions [ i ] ) ;\n free ( server_req -> base . questions ) ;\n }\n free ( server_req ) ;\n }\n return - 1 ;\n # undef SKIP_NAME # undef GET32 # undef GET16 # undef GET8 }", "idx": 1309}
{"hash": -4034210238312760680, "project": "debian", "size": 5, "label": 0, "functionSource": "static void pdf_drop_xobject_imp ( fz_context * ctx , fz_storable * xobj_ ) {\n pdf_xobject * xobj = ( pdf_xobject * ) xobj_ ;\n pdf_drop_obj ( ctx , xobj -> obj ) ;\n fz_free ( ctx , xobj ) ;\n }", "idx": 1310}
{"hash": 4839943401171415484, "project": "chrome", "size": 31, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_P ( BrowserCloseManagerBrowserTest , TestAddTabWithBeforeUnloadDuringShutdown ) {\n browsers_ . push_back ( CreateBrowser ( browser ( ) -> profile ( ) ) ) ;\n ASSERT_NO_FATAL_FAILURE ( ui_test_utils : : NavigateToURL ( browsers_ [ 0 ] , embedded_test_server ( ) -> GetURL ( \"/beforeunload.html\" ) ) ) ;\n ASSERT_NO_FATAL_FAILURE ( ui_test_utils : : NavigateToURL ( browsers_ [ 1 ] , embedded_test_server ( ) -> GetURL ( \"/beforeunload.html\" ) ) ) ;\n PrepareForDialog ( browsers_ [ 0 ] ) ;\n PrepareForDialog ( browsers_ [ 1 ] ) ;\n RepeatedNotificationObserver cancel_observer ( chrome : : NOTIFICATION_BROWSER_CLOSE_CANCELLED , 2 ) ;\n chrome : : CloseAllBrowsersAndQuit ( ) ;\n ASSERT_NO_FATAL_FAILURE ( AcceptClose ( ) ) ;\n AddBlankTabAndShow ( browsers_ [ 0 ] ) ;\n ASSERT_NO_FATAL_FAILURE ( ui_test_utils : : NavigateToURL ( browsers_ [ 0 ] , embedded_test_server ( ) -> GetURL ( \"/beforeunload.html\" ) ) ) ;\n AddBlankTabAndShow ( browsers_ [ 1 ] ) ;\n ASSERT_NO_FATAL_FAILURE ( ui_test_utils : : NavigateToURL ( browsers_ [ 1 ] , embedded_test_server ( ) -> GetURL ( \"/beforeunload.html\" ) ) ) ;\n PrepareForDialog ( browsers_ [ 0 ] ) ;\n PrepareForDialog ( browsers_ [ 1 ] ) ;\n ASSERT_NO_FATAL_FAILURE ( AcceptClose ( ) ) ;\n ASSERT_NO_FATAL_FAILURE ( CancelClose ( ) ) ;\n cancel_observer . Wait ( ) ;\n EXPECT_FALSE ( browser_shutdown : : IsTryingToQuit ( ) ) ;\n EXPECT_EQ ( 2 , browsers_ [ 0 ] -> tab_strip_model ( ) -> count ( ) ) ;\n EXPECT_EQ ( 2 , browsers_ [ 1 ] -> tab_strip_model ( ) -> count ( ) ) ;\n RepeatedNotificationObserver close_observer ( chrome : : NOTIFICATION_BROWSER_CLOSED , 2 ) ;\n chrome : : CloseAllBrowsersAndQuit ( ) ;\n ASSERT_NO_FATAL_FAILURE ( AcceptClose ( ) ) ;\n ASSERT_NO_FATAL_FAILURE ( AcceptClose ( ) ) ;\n ASSERT_NO_FATAL_FAILURE ( AcceptClose ( ) ) ;\n ASSERT_NO_FATAL_FAILURE ( AcceptClose ( ) ) ;\n close_observer . Wait ( ) ;\n EXPECT_TRUE ( browser_shutdown : : IsTryingToQuit ( ) ) ;\n EXPECT_TRUE ( BrowserList : : GetInstance ( ) -> empty ( ) ) ;\n }", "idx": 1311}
{"hash": -5456913190944844754, "project": "chrome", "size": 40, "label": 0, "functionSource": "TEST_F ( TemplateURLTest , HasSearchTermsReplacementKey ) {\n TemplateURLData data ;\n data . SetURL ( \"http://google.com/?q={\nsearchTerms}\n\" ) ;\n data . instant_url = \"http://google.com/instant#q={\nsearchTerms}\n\" ;\n data . alternate_urls . push_back ( \"http://google.com/alt/#q={\nsearchTerms}\n\" ) ;\n data . alternate_urls . push_back ( \"http://google.com/alt/?ext=foo&q={\nsearchTerms}\n#ref=bar\" ) ;\n data . search_terms_replacement_key = \"espv\" ;\n TemplateURL url ( data ) ;\n EXPECT_FALSE ( url . HasSearchTermsReplacementKey ( GURL ( \"http://google.com/\" ) ) ) ;\n EXPECT_TRUE ( url . HasSearchTermsReplacementKey ( GURL ( \"http://google.com/?espv\" ) ) ) ;\n EXPECT_TRUE ( url . HasSearchTermsReplacementKey ( GURL ( \"http://google.com/#espv\" ) ) ) ;\n EXPECT_FALSE ( url . HasSearchTermsReplacementKey ( GURL ( \"http://google.com/?q=something\" ) ) ) ;\n EXPECT_TRUE ( url . HasSearchTermsReplacementKey ( GURL ( \"http://google.com/?q=something&espv\" ) ) ) ;\n EXPECT_TRUE ( url . HasSearchTermsReplacementKey ( GURL ( \"http://google.com/?q=something&espv=1\" ) ) ) ;\n EXPECT_TRUE ( url . HasSearchTermsReplacementKey ( GURL ( \"http://google.com/?q=something&espv=0\" ) ) ) ;\n EXPECT_TRUE ( url . HasSearchTermsReplacementKey ( GURL ( \"http://google.com/?espv&q=something\" ) ) ) ;\n EXPECT_TRUE ( url . HasSearchTermsReplacementKey ( GURL ( \"http://google.com/?espv=1&q=something\" ) ) ) ;\n EXPECT_TRUE ( url . HasSearchTermsReplacementKey ( GURL ( \"http://google.com/?espv=0&q=something\" ) ) ) ;\n EXPECT_FALSE ( url . HasSearchTermsReplacementKey ( GURL ( \"http://google.com/alt/#q=something\" ) ) ) ;\n EXPECT_TRUE ( url . HasSearchTermsReplacementKey ( GURL ( \"http://google.com/alt/#q=something&espv\" ) ) ) ;\n EXPECT_TRUE ( url . HasSearchTermsReplacementKey ( GURL ( \"http://google.com/alt/#q=something&espv=1\" ) ) ) ;\n EXPECT_TRUE ( url . HasSearchTermsReplacementKey ( GURL ( \"http://google.com/alt/#q=something&espv=0\" ) ) ) ;\n EXPECT_TRUE ( url . HasSearchTermsReplacementKey ( GURL ( \"http://google.com/alt/#espv&q=something\" ) ) ) ;\n EXPECT_TRUE ( url . HasSearchTermsReplacementKey ( GURL ( \"http://google.com/alt/#espv=1&q=something\" ) ) ) ;\n EXPECT_TRUE ( url . HasSearchTermsReplacementKey ( GURL ( \"http://google.com/alt/#espv=0&q=something\" ) ) ) ;\n EXPECT_TRUE ( url . HasSearchTermsReplacementKey ( GURL ( \"http://google.com/?espv#q=something\" ) ) ) ;\n EXPECT_TRUE ( url . HasSearchTermsReplacementKey ( GURL ( \"http://google.com/?espv=1#q=something\" ) ) ) ;\n EXPECT_TRUE ( url . HasSearchTermsReplacementKey ( GURL ( \"http://google.com/?q=something#espv\" ) ) ) ;\n EXPECT_TRUE ( url . HasSearchTermsReplacementKey ( GURL ( \"http://google.com/?q=something#espv=1\" ) ) ) ;\n EXPECT_TRUE ( url . HasSearchTermsReplacementKey ( GURL ( \"http://bing.com/?espv\" ) ) ) ;\n EXPECT_TRUE ( url . HasSearchTermsReplacementKey ( GURL ( \"http://bing.com/#espv\" ) ) ) ;\n }", "idx": 1312}
{"hash": 3599206110384554647, "project": "debian", "size": 48, "label": 1, "functionSource": "static ossl_inline t2 * sk_ ## t1 ## _delete_ptr ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return ( t2 * ) OPENSSL_sk_delete_ptr ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _push ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_push ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _unshift ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_unshift ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _pop ( STACK_OF ( t1 ) * sk ) {\n return ( t2 * ) OPENSSL_sk_pop ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _shift ( STACK_OF ( t1 ) * sk ) {\n return ( t2 * ) OPENSSL_sk_shift ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline void sk_ ## t1 ## _pop_free ( STACK_OF ( t1 ) * sk , sk_ ## t1 ## _freefunc freefunc ) {\n OPENSSL_sk_pop_free ( ( OPENSSL_STACK * ) sk , ( OPENSSL_sk_freefunc ) freefunc ) ;\n }\n static ossl_inline int sk_ ## t1 ## _insert ( STACK_OF ( t1 ) * sk , t2 * ptr , int idx ) {\n return OPENSSL_sk_insert ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr , idx ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _set ( STACK_OF ( t1 ) * sk , int idx , t2 * ptr ) {\n return ( t2 * ) OPENSSL_sk_set ( ( OPENSSL_STACK * ) sk , idx , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _find ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_find ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _find_ex ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_find_ex ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline void sk_ ## t1 ## _sort ( STACK_OF ( t1 ) * sk ) {\n OPENSSL_sk_sort ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline int sk_ ## t1 ## _is_sorted ( const STACK_OF ( t1 ) * sk ) {\n return OPENSSL_sk_is_sorted ( ( const OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _dup ( const STACK_OF ( t1 ) * sk ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_dup ( ( const OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _deep_copy ( const STACK_OF ( t1 ) * sk , sk_ ## t1 ## _copyfunc copyfunc , sk_ ## t1 ## _freefunc freefunc ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_deep_copy ( ( const OPENSSL_STACK * ) sk , ( OPENSSL_sk_copyfunc ) copyfunc , ( OPENSSL_sk_freefunc ) freefunc ) ;\n }\n static ossl_inline sk_ ## t1 ## _compfunc sk_ ## t1 ## _set_cmp_func ( STACK_OF ( t1 ) * sk , sk_ ## t1 ## _compfunc compare ) {\n return ( sk_ ## t1 ## _compfunc ) OPENSSL_sk_set_cmp_func ( ( OPENSSL_STACK * ) sk , ( OPENSSL_sk_compfunc ) compare ) ;\n }\n # define DEFINE_SPECIAL_STACK_OF ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , t2 , t2 ) # define DEFINE_STACK_OF ( t ) SKM_DEFINE_STACK_OF ( t , t , t ) # define DEFINE_SPECIAL_STACK_OF_CONST ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , const t2 , t2 ) # define DEFINE_STACK_OF_CONST ( t ) SKM_DEFINE_STACK_OF ( t , const t , t ) typedef char * OPENSSL_STRING ;\n typedef const char * OPENSSL_CSTRING ;\n DEFINE_SPECIAL_STACK_OF ( OPENSSL_STRING , char ) DEFINE_SPECIAL_STACK_OF_CONST ( OPENSSL_CSTRING , char )", "idx": 1313}
{"hash": -2181129709629421970, "project": "chrome", "size": 10, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( DownloadNotificationTest , CancelDownload ) {\n CreateDownload ( ) ;\n display_service_ -> SimulateClick ( NotificationHandler : : Type : : TRANSIENT , notification_id ( ) , 1 , base : : nullopt ) ;\n EXPECT_FALSE ( notification ( ) ) ;\n EXPECT_EQ ( 0u , GetDownloadNotifications ( ) . size ( ) ) ;\n std : : vector < download : : DownloadItem * > downloads ;\n GetDownloadManager ( browser ( ) ) -> GetAllDownloads ( & downloads ) ;\n ASSERT_EQ ( 1u , downloads . size ( ) ) ;\n EXPECT_EQ ( download : : DownloadItem : : CANCELLED , downloads [ 0 ] -> GetState ( ) ) ;\n }", "idx": 1314}
{"hash": -2943582541244387919, "project": "chrome", "size": 43, "label": 0, "functionSource": "unsigned int vp9_sub_pixel_variance ## W ## x ## H ## _c ( const uint8_t * src , int src_stride , int xoffset , int yoffset , const uint8_t * dst , int dst_stride , unsigned int * sse ) {\n uint16_t fdata3 [ ( H + 1 ) * W ] ;\n uint8_t temp2 [ H * W ] ;\n var_filter_block2d_bil_first_pass ( src , fdata3 , src_stride , 1 , H + 1 , W , BILINEAR_FILTERS_2TAP ( xoffset ) ) ;\n var_filter_block2d_bil_second_pass ( fdata3 , temp2 , W , W , H , W , BILINEAR_FILTERS_2TAP ( yoffset ) ) ;\n return vp9_variance ## W ## x ## H ## _c ( temp2 , W , dst , dst_stride , sse ) ;\n \\ }\n # define SUBPIX_AVG_VAR ( W , H ) unsigned int vp9_sub_pixel_avg_variance ## W ## x ## H ## _c ( const uint8_t * src , int src_stride , int xoffset , int yoffset , const uint8_t * dst , int dst_stride , unsigned int * sse , const uint8_t * second_pred ) {\n uint16_t fdata3 [ ( H + 1 ) * W ] ;\n uint8_t temp2 [ H * W ] ;\n DECLARE_ALIGNED_ARRAY ( 16 , uint8_t , temp3 , H * W ) ;\n var_filter_block2d_bil_first_pass ( src , fdata3 , src_stride , 1 , H + 1 , W , BILINEAR_FILTERS_2TAP ( xoffset ) ) ;\n var_filter_block2d_bil_second_pass ( fdata3 , temp2 , W , W , H , W , BILINEAR_FILTERS_2TAP ( yoffset ) ) ;\n vp9_comp_avg_pred ( temp3 , second_pred , W , H , temp2 , W ) ;\n return vp9_variance ## W ## x ## H ## _c ( temp3 , W , dst , dst_stride , sse ) ;\n \\ }\n void vp9_get16x16var_c ( const uint8_t * src_ptr , int source_stride , const uint8_t * ref_ptr , int ref_stride , unsigned int * sse , int * sum ) {\n variance ( src_ptr , source_stride , ref_ptr , ref_stride , 16 , 16 , sse , sum ) ;\n }\n void vp9_get8x8var_c ( const uint8_t * src_ptr , int source_stride , const uint8_t * ref_ptr , int ref_stride , unsigned int * sse , int * sum ) {\n variance ( src_ptr , source_stride , ref_ptr , ref_stride , 8 , 8 , sse , sum ) ;\n }\n unsigned int vp9_mse16x16_c ( const uint8_t * src , int src_stride , const uint8_t * ref , int ref_stride , unsigned int * sse ) {\n int sum ;\n variance ( src , src_stride , ref , ref_stride , 16 , 16 , sse , & sum ) ;\n return * sse ;\n }\n unsigned int vp9_mse16x8_c ( const uint8_t * src , int src_stride , const uint8_t * ref , int ref_stride , unsigned int * sse ) {\n int sum ;\n variance ( src , src_stride , ref , ref_stride , 16 , 8 , sse , & sum ) ;\n return * sse ;\n }\n unsigned int vp9_mse8x16_c ( const uint8_t * src , int src_stride , const uint8_t * ref , int ref_stride , unsigned int * sse ) {\n int sum ;\n variance ( src , src_stride , ref , ref_stride , 8 , 16 , sse , & sum ) ;\n return * sse ;\n }\n unsigned int vp9_mse8x8_c ( const uint8_t * src , int src_stride , const uint8_t * ref , int ref_stride , unsigned int * sse ) {\n int sum ;\n variance ( src , src_stride , ref , ref_stride , 8 , 8 , sse , & sum ) ;\n return * sse ;\n }\n VAR ( 4 , 4 ) SUBPIX_VAR ( 4 , 4 ) SUBPIX_AVG_VAR ( 4 , 4 ) VAR ( 4 , 8 ) SUBPIX_VAR ( 4 , 8 ) SUBPIX_AVG_VAR ( 4 , 8 ) VAR ( 8 , 4 ) SUBPIX_VAR ( 8 , 4 ) SUBPIX_AVG_VAR ( 8 , 4 ) VAR ( 8 , 8 ) SUBPIX_VAR ( 8 , 8 ) SUBPIX_AVG_VAR ( 8 , 8 ) VAR ( 8 , 16 ) SUBPIX_VAR ( 8 , 16 ) SUBPIX_AVG_VAR ( 8 , 16 ) VAR ( 16 , 8 ) SUBPIX_VAR ( 16 , 8 ) SUBPIX_AVG_VAR ( 16 , 8 ) VAR ( 16 , 16 ) SUBPIX_VAR ( 16 , 16 ) SUBPIX_AVG_VAR ( 16 , 16 ) VAR ( 16 , 32 ) SUBPIX_VAR ( 16 , 32 ) SUBPIX_AVG_VAR ( 16 , 32 ) VAR ( 32 , 16 ) SUBPIX_VAR ( 32 , 16 ) SUBPIX_AVG_VAR ( 32 , 16 ) VAR ( 32 , 32 ) SUBPIX_VAR ( 32 , 32 ) SUBPIX_AVG_VAR ( 32 , 32 ) VAR ( 32 , 64 ) SUBPIX_VAR ( 32 , 64 ) SUBPIX_AVG_VAR ( 32 , 64 ) VAR ( 64 , 32 ) SUBPIX_VAR ( 64 , 32 ) SUBPIX_AVG_VAR ( 64 , 32 ) VAR ( 64 , 64 ) SUBPIX_VAR ( 64 , 64 )", "idx": 1315}
{"hash": 6343276067273564310, "project": "debian", "size": 8, "label": 0, "functionSource": "afs_int32 SPR_ListElements ( struct rx_call * call , afs_int32 aid , prlist * alist , afs_int32 * over ) {\n afs_int32 code ;\n afs_int32 cid = ANONYMOUSID ;\n code = listElements ( call , aid , alist , over , & cid ) ;\n osi_auditU ( call , PTS_LstEleEvent , code , AUD_ID , aid , AUD_END ) ;\n ViceLog ( 125 , ( \"PTS_ListElements: code %d cid %d aid %d\\n\" , code , cid , aid ) ) ;\n return code ;\n }", "idx": 1316}
{"hash": -5268859819325807498, "project": "debian", "size": 14, "label": 0, "functionSource": "static void mime_list_stop ( NautilusDirectory * directory ) {\n NautilusFile * file ;\n if ( directory -> details -> mime_list_in_progress != NULL ) {\n file = directory -> details -> mime_list_in_progress -> mime_list_file ;\n if ( file != NULL ) {\n g_assert ( NAUTILUS_IS_FILE ( file ) ) ;\n g_assert ( file -> details -> directory == directory ) ;\n if ( is_needy ( file , should_get_mime_list , REQUEST_MIME_LIST ) ) {\n return ;\n }\n }\n mime_list_cancel ( directory ) ;\n }\n }", "idx": 1317}
{"hash": -3299391226809811274, "project": "debian", "size": 11, "label": 0, "functionSource": "int qemuAgentFSTrim ( qemuAgentPtr mon , unsigned long long minimum ) {\n int ret = - 1 ;\n virJSONValuePtr cmd ;\n virJSONValuePtr reply = NULL ;\n cmd = qemuAgentMakeCommand ( \"guest-fstrim\" , \"U:minimum\" , minimum , NULL ) ;\n if ( ! cmd ) return ret ;\n ret = qemuAgentCommand ( mon , cmd , & reply , false , VIR_DOMAIN_QEMU_AGENT_COMMAND_BLOCK ) ;\n virJSONValueFree ( cmd ) ;\n virJSONValueFree ( reply ) ;\n return ret ;\n }", "idx": 1318}
{"hash": -8962831256613787672, "project": "debian", "size": 30, "label": 0, "functionSource": "static gint dissect_ac_if_feature_unit ( tvbuff_t * tvb , gint offset , packet_info * pinfo _U_ , proto_tree * tree , usb_conv_info_t * usb_conv_info _U_ ) {\n gint offset_start ;\n guint8 controlsize ;\n proto_tree * bitmap_tree ;\n proto_item * ti ;\n static const int * fu_controls0 [ ] = {\n & hf_ac_if_fu_controls_d0 , & hf_ac_if_fu_controls_d1 , & hf_ac_if_fu_controls_d2 , & hf_ac_if_fu_controls_d3 , & hf_ac_if_fu_controls_d4 , & hf_ac_if_fu_controls_d5 , & hf_ac_if_fu_controls_d6 , & hf_ac_if_fu_controls_d7 , NULL }\n ;\n static const int * fu_controls1 [ ] = {\n & hf_ac_if_fu_controls_d8 , & hf_ac_if_fu_controls_d9 , & hf_ac_if_fu_controls_rsv , NULL }\n ;\n offset_start = offset ;\n proto_tree_add_item ( tree , hf_ac_if_fu_unitid , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_ac_if_fu_sourceid , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_ac_if_fu_controlsize , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ;\n controlsize = tvb_get_guint8 ( tvb , offset ) + 1 ;\n offset += 1 ;\n ti = proto_tree_add_item ( tree , hf_ac_if_fu_controls , tvb , offset , controlsize , ENC_NA ) ;\n bitmap_tree = proto_item_add_subtree ( ti , ett_ac_if_fu_controls ) ;\n proto_tree_add_bitmask ( bitmap_tree , tvb , offset , hf_ac_if_fu_control , ett_ac_if_fu_controls0 , fu_controls0 , ENC_LITTLE_ENDIAN ) ;\n if ( controlsize >= 1 ) {\n proto_tree_add_bitmask ( bitmap_tree , tvb , offset + 1 , hf_ac_if_fu_control , ett_ac_if_fu_controls1 , fu_controls1 , ENC_LITTLE_ENDIAN ) ;\n }\n offset += controlsize ;\n proto_tree_add_item ( tree , hf_ac_if_fu_ifeature , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ;\n offset += 1 ;\n return offset - offset_start ;\n }", "idx": 1319}
{"hash": 2388171415474875762, "project": "debian", "size": 29, "label": 0, "functionSource": "static void dissect_rsvp_hop ( proto_item * ti , packet_info * pinfo , proto_tree * rsvp_object_tree , tvbuff_t * tvb , int offset , int obj_length , int rsvp_class _U_ , int type ) {\n int offset2 = offset + 4 ;\n switch ( type ) {\n case 1 : proto_tree_add_uint_format_value ( rsvp_object_tree , hf_rsvp_ctype , tvb , offset + 3 , 1 , type , \"1 - IPv4\" ) ;\n proto_tree_add_item ( rsvp_object_tree , hf_rsvp_hop_neighbor_address_ipv4 , tvb , offset2 , 4 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rsvp_object_tree , hf_rsvp_hop_logical_interface , tvb , offset2 + 4 , 4 , ENC_BIG_ENDIAN ) ;\n proto_item_set_text ( ti , \"HOP: IPv4, %s\" , tvb_ip_to_str ( tvb , offset2 ) ) ;\n break ;\n case 2 : proto_tree_add_uint_format_value ( rsvp_object_tree , hf_rsvp_ctype , tvb , offset + 3 , 1 , type , \"2 - IPv6\" ) ;\n proto_tree_add_item ( rsvp_object_tree , hf_rsvp_hop_neighbor_address_ipv6 , tvb , offset2 , 16 , ENC_NA ) ;\n proto_tree_add_item ( rsvp_object_tree , hf_rsvp_hop_logical_interface , tvb , offset2 + 16 , 4 , ENC_BIG_ENDIAN ) ;\n break ;\n case 3 : proto_tree_add_uint_format_value ( rsvp_object_tree , hf_rsvp_ctype , tvb , offset + 3 , 1 , type , \"3 - IPv4 IF-ID\" ) ;\n proto_tree_add_item ( rsvp_object_tree , hf_rsvp_hop_neighbor_address_ipv4 , tvb , offset2 , 4 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rsvp_object_tree , hf_rsvp_hop_logical_interface , tvb , offset2 + 4 , 4 , ENC_BIG_ENDIAN ) ;\n proto_item_set_text ( ti , \"HOP: IPv4 IF-ID. Control IPv4: %s. \" , tvb_ip_to_str ( tvb , offset2 ) ) ;\n dissect_rsvp_ifid_tlv ( ti , pinfo , rsvp_object_tree , tvb , offset + 12 , obj_length - 12 , TREE ( TT_HOP_SUBOBJ ) ) ;\n break ;\n case 4 : proto_tree_add_uint_format_value ( rsvp_object_tree , hf_rsvp_ctype , tvb , offset + 3 , 1 , type , \"4 - IPv6 IF-ID\" ) ;\n proto_tree_add_item ( rsvp_object_tree , hf_rsvp_hop_neighbor_address_ipv6 , tvb , offset2 , 16 , ENC_NA ) ;\n proto_tree_add_item ( rsvp_object_tree , hf_rsvp_hop_logical_interface , tvb , offset2 + 16 , 4 , ENC_BIG_ENDIAN ) ;\n proto_item_set_text ( ti , \"HOP: IPv6 IF-ID. Control IPv6: %s. \" , tvb_ip6_to_str ( tvb , offset2 ) ) ;\n dissect_rsvp_ifid_tlv ( ti , pinfo , rsvp_object_tree , tvb , offset + 24 , obj_length - 24 , TREE ( TT_HOP_SUBOBJ ) ) ;\n break ;\n default : proto_tree_add_uint_format_value ( rsvp_object_tree , hf_rsvp_ctype , tvb , offset + 3 , 1 , type , \"Unknown (%u)\" , type ) ;\n proto_tree_add_item ( rsvp_object_tree , hf_rsvp_hop_data , tvb , offset2 , obj_length - 4 , ENC_NA ) ;\n break ;\n }\n }", "idx": 1320}
{"hash": 2895622461494525400, "project": "debian", "size": 72, "label": 0, "functionSource": "static void test_bug32265 ( ) {\n int rc ;\n MYSQL_STMT * stmt ;\n MYSQL_FIELD * field ;\n MYSQL_RES * metadata ;\n DBUG_ENTER ( \"test_bug32265\" ) ;\n myheader ( \"test_bug32265\" ) ;\n rc = mysql_query ( mysql , \"DROP TABLE IF EXISTS t1\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"CREATE TABLE t1 (a INTEGER)\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"INSERT INTO t1 VALUES (1)\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"CREATE VIEW v1 AS SELECT * FROM t1\" ) ;\n myquery ( rc ) ;\n stmt = open_cursor ( \"SELECT * FROM t1\" ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n metadata = mysql_stmt_result_metadata ( stmt ) ;\n field = mysql_fetch_field ( metadata ) ;\n DIE_UNLESS ( field ) ;\n DIE_UNLESS ( strcmp ( field -> table , \"t1\" ) == 0 ) ;\n DIE_UNLESS ( strcmp ( field -> org_table , \"t1\" ) == 0 ) ;\n DIE_UNLESS ( strcmp ( field -> db , \"client_test_db\" ) == 0 ) ;\n mysql_free_result ( metadata ) ;\n mysql_stmt_close ( stmt ) ;\n stmt = open_cursor ( \"SELECT a '' FROM t1 ``\" ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n metadata = mysql_stmt_result_metadata ( stmt ) ;\n field = mysql_fetch_field ( metadata ) ;\n DIE_UNLESS ( strcmp ( field -> table , \"\" ) == 0 ) ;\n DIE_UNLESS ( strcmp ( field -> org_table , \"t1\" ) == 0 ) ;\n DIE_UNLESS ( strcmp ( field -> db , \"client_test_db\" ) == 0 ) ;\n mysql_free_result ( metadata ) ;\n mysql_stmt_close ( stmt ) ;\n stmt = open_cursor ( \"SELECT a '' FROM t1 ``\" ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n metadata = mysql_stmt_result_metadata ( stmt ) ;\n field = mysql_fetch_field ( metadata ) ;\n DIE_UNLESS ( strcmp ( field -> table , \"\" ) == 0 ) ;\n DIE_UNLESS ( strcmp ( field -> org_table , \"t1\" ) == 0 ) ;\n DIE_UNLESS ( strcmp ( field -> db , \"client_test_db\" ) == 0 ) ;\n mysql_free_result ( metadata ) ;\n mysql_stmt_close ( stmt ) ;\n stmt = open_cursor ( \"SELECT * FROM v1\" ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n metadata = mysql_stmt_result_metadata ( stmt ) ;\n field = mysql_fetch_field ( metadata ) ;\n DIE_UNLESS ( strcmp ( field -> table , \"v1\" ) == 0 ) ;\n DIE_UNLESS ( strcmp ( field -> org_table , \"v1\" ) == 0 ) ;\n DIE_UNLESS ( strcmp ( field -> db , \"client_test_db\" ) == 0 ) ;\n mysql_free_result ( metadata ) ;\n mysql_stmt_close ( stmt ) ;\n stmt = open_cursor ( \"SELECT * FROM v1 /* SIC */ GROUP BY 1\" ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n metadata = mysql_stmt_result_metadata ( stmt ) ;\n field = mysql_fetch_field ( metadata ) ;\n DIE_UNLESS ( strcmp ( field -> table , \"v1\" ) == 0 ) ;\n DIE_UNLESS ( strcmp ( field -> org_table , \"v1\" ) == 0 ) ;\n DIE_UNLESS ( strcmp ( field -> db , \"client_test_db\" ) == 0 ) ;\n mysql_free_result ( metadata ) ;\n mysql_stmt_close ( stmt ) ;\n rc = mysql_query ( mysql , \"DROP VIEW v1\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"DROP TABLE t1\" ) ;\n myquery ( rc ) ;\n DBUG_VOID_RETURN ;\n }", "idx": 1321}
{"hash": -1929262071302712016, "project": "debian", "size": 3, "label": 0, "functionSource": "static void Type_S15Fixed16_Free ( struct _cms_typehandler_struct * self , void * Ptr ) {\n _cmsFree ( self -> ContextID , Ptr ) ;\n }", "idx": 1322}
{"hash": 5610242550647094255, "project": "debian", "size": 13, "label": 0, "functionSource": "static int vaapi_h264_end_frame ( AVCodecContext * avctx ) {\n struct vaapi_context * const vactx = avctx -> hwaccel_context ;\n H264Context * const h = avctx -> priv_data ;\n int ret ;\n av_dlog ( avctx , \"vaapi_h264_end_frame()\\n\" ) ;\n ret = ff_vaapi_commit_slices ( vactx ) ;\n if ( ret < 0 ) goto finish ;\n ret = ff_vaapi_render_picture ( vactx , ff_vaapi_get_surface_id ( h -> cur_pic_ptr ) ) ;\n if ( ret < 0 ) goto finish ;\n ff_h264_draw_horiz_band ( h , 0 , h -> avctx -> height ) ;\n finish : ff_vaapi_common_end_frame ( avctx ) ;\n return ret ;\n }", "idx": 1323}
{"hash": 4537091194729139981, "project": "chrome", "size": 28, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( FullscreenControllerInteractiveTest , EscapingMouseLock ) {\n ASSERT_TRUE ( test_server ( ) -> Start ( ) ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , test_server ( ) -> GetURL ( kFullscreenMouseLockHTML ) ) ;\n ASSERT_FALSE ( IsFullscreenBubbleDisplayed ( ) ) ;\n {\n ASSERT_TRUE ( ui_test_utils : : SendKeyPressAndWait ( browser ( ) , ui : : VKEY_1 , false , false , false , false , chrome : : NOTIFICATION_MOUSE_LOCK_CHANGED , content : : NotificationService : : AllSources ( ) ) ) ;\n }\n ASSERT_FALSE ( IsFullscreenPermissionRequested ( ) ) ;\n ASSERT_TRUE ( IsMouseLockPermissionRequested ( ) ) ;\n SendEscapeToFullscreenController ( ) ;\n ASSERT_FALSE ( IsFullscreenPermissionRequested ( ) ) ;\n ASSERT_FALSE ( IsMouseLockPermissionRequested ( ) ) ;\n {\n ASSERT_TRUE ( ui_test_utils : : SendKeyPressAndWait ( browser ( ) , ui : : VKEY_1 , false , false , false , false , chrome : : NOTIFICATION_MOUSE_LOCK_CHANGED , content : : NotificationService : : AllSources ( ) ) ) ;\n }\n ASSERT_FALSE ( IsFullscreenPermissionRequested ( ) ) ;\n ASSERT_TRUE ( IsMouseLockPermissionRequested ( ) ) ;\n AcceptCurrentFullscreenOrMouseLockRequest ( ) ;\n ASSERT_TRUE ( IsMouseLocked ( ) ) ;\n ASSERT_FALSE ( IsWindowFullscreenForTabOrPending ( ) ) ;\n ASSERT_FALSE ( IsFullscreenPermissionRequested ( ) ) ;\n ASSERT_FALSE ( IsMouseLockPermissionRequested ( ) ) ;\n SendEscapeToFullscreenController ( ) ;\n ASSERT_FALSE ( IsMouseLocked ( ) ) ;\n ASSERT_FALSE ( IsWindowFullscreenForTabOrPending ( ) ) ;\n ASSERT_FALSE ( IsFullscreenPermissionRequested ( ) ) ;\n ASSERT_FALSE ( IsMouseLockPermissionRequested ( ) ) ;\n }", "idx": 1324}
{"hash": 2820551931453396101, "project": "debian", "size": 46, "label": 1, "functionSource": "int jas_image_writecmpt ( jas_image_t * image , int cmptno , jas_image_coord_t x , jas_image_coord_t y , jas_image_coord_t width , jas_image_coord_t height , jas_matrix_t * data ) {\n jas_image_cmpt_t * cmpt ;\n jas_image_coord_t i ;\n jas_image_coord_t j ;\n jas_seqent_t * d ;\n jas_seqent_t * dr ;\n int drs ;\n jas_seqent_t v ;\n int k ;\n int c ;\n if ( cmptno < 0 || cmptno >= image -> numcmpts_ ) {\n return - 1 ;\n }\n cmpt = image -> cmpts_ [ cmptno ] ;\n if ( x >= cmpt -> width_ || y >= cmpt -> height_ || x + width > cmpt -> width_ || y + height > cmpt -> height_ ) {\n return - 1 ;\n }\n if ( jas_matrix_numrows ( data ) != height || jas_matrix_numcols ( data ) != width ) {\n return - 1 ;\n }\n dr = jas_matrix_getref ( data , 0 , 0 ) ;\n drs = jas_matrix_rowstep ( data ) ;\n for ( i = 0 ;\n i < height ;\n ++ i , dr += drs ) {\n d = dr ;\n if ( jas_stream_seek ( cmpt -> stream_ , ( cmpt -> width_ * ( y + i ) + x ) * cmpt -> cps_ , SEEK_SET ) < 0 ) {\n return - 1 ;\n }\n for ( j = width ;\n j > 0 ;\n -- j , ++ d ) {\n v = inttobits ( * d , cmpt -> prec_ , cmpt -> sgnd_ ) ;\n for ( k = cmpt -> cps_ ;\n k > 0 ;\n -- k ) {\n c = ( v >> ( 8 * ( cmpt -> cps_ - 1 ) ) ) & 0xff ;\n if ( jas_stream_putc ( cmpt -> stream_ , ( unsigned char ) c ) == EOF ) {\n return - 1 ;\n }\n v <<= 8 ;\n }\n }\n }\n return 0 ;\n }", "idx": 1325}
{"hash": -7553540414561818627, "project": "debian", "size": 26, "label": 0, "functionSource": "int test_probable_prime_coprime ( BIO * bp , BN_CTX * ctx ) {\n int i , j , ret = 0 ;\n BIGNUM r ;\n BN_ULONG primes [ 5 ] = {\n 2 , 3 , 5 , 7 , 11 }\n ;\n BN_init ( & r ) ;\n for ( i = 0 ;\n i < 1000 ;\n i ++ ) {\n if ( ! bn_probable_prime_dh_coprime ( & r , 1024 , ctx ) ) goto err ;\n for ( j = 0 ;\n j < 5 ;\n j ++ ) {\n if ( BN_mod_word ( & r , primes [ j ] ) == 0 ) {\n BIO_printf ( bp , \"Number generated is not coprime to %ld:\\n\" , primes [ j ] ) ;\n BN_print_fp ( stdout , & r ) ;\n BIO_printf ( bp , \"\\n\" ) ;\n goto err ;\n }\n }\n }\n ret = 1 ;\n err : BN_clear ( & r ) ;\n return ret ;\n }", "idx": 1326}
{"hash": 8461782184979846246, "project": "chrome", "size": 10, "label": 0, "functionSource": "TEST_F ( ProtocolHandlerRegistryTest , IgnoreEquivalentProtocolHandler ) {\n ProtocolHandler ph1 = CreateProtocolHandler ( \"test\" , GURL ( \"http://test/%s\" ) ) ;\n ProtocolHandler ph2 = CreateProtocolHandler ( \"test\" , GURL ( \"http://test/%s\" ) ) ;\n registry ( ) -> OnIgnoreRegisterProtocolHandler ( ph1 ) ;\n ASSERT_TRUE ( registry ( ) -> IsIgnored ( ph1 ) ) ;\n ASSERT_TRUE ( registry ( ) -> HasIgnoredEquivalent ( ph2 ) ) ;\n registry ( ) -> RemoveIgnoredHandler ( ph1 ) ;\n ASSERT_FALSE ( registry ( ) -> IsIgnored ( ph1 ) ) ;\n ASSERT_FALSE ( registry ( ) -> HasIgnoredEquivalent ( ph2 ) ) ;\n }", "idx": 1327}
{"hash": -8503439282031333562, "project": "debian", "size": 13, "label": 0, "functionSource": "void tmx_pretran_link_safe ( int slotid ) {\n if ( _tmx_proc_ptran == NULL ) return ;\n if ( _tmx_ptran_table [ slotid ] . plist == NULL ) {\n _tmx_ptran_table [ slotid ] . plist = _tmx_proc_ptran ;\n _tmx_proc_ptran -> linked = 1 ;\n return ;\n }\n _tmx_proc_ptran -> next = _tmx_ptran_table [ slotid ] . plist ;\n _tmx_ptran_table [ slotid ] . plist -> prev = _tmx_proc_ptran ;\n _tmx_ptran_table [ slotid ] . plist = _tmx_proc_ptran ;\n _tmx_proc_ptran -> linked = 1 ;\n return ;\n }", "idx": 1328}
{"hash": 1788300783882316916, "project": "debian", "size": 161, "label": 0, "functionSource": "void ff_estimate_p_frame_motion ( MpegEncContext * s , int mb_x , int mb_y ) {\n MotionEstContext * const c = & s -> me ;\n uint8_t * pix , * ppix ;\n int sum , mx , my , dmin ;\n int varc ;\n int vard ;\n int P [ 10 ] [ 2 ] ;\n const int shift = 1 + s -> quarter_sample ;\n int mb_type = 0 ;\n Picture * const pic = & s -> current_picture ;\n init_ref ( c , s -> new_picture . f . data , s -> last_picture . f . data , NULL , 16 * mb_x , 16 * mb_y , 0 ) ;\n assert ( s -> quarter_sample == 0 || s -> quarter_sample == 1 ) ;\n assert ( s -> linesize == c -> stride ) ;\n assert ( s -> uvlinesize == c -> uvstride ) ;\n c -> penalty_factor = get_penalty_factor ( s -> lambda , s -> lambda2 , c -> avctx -> me_cmp ) ;\n c -> sub_penalty_factor = get_penalty_factor ( s -> lambda , s -> lambda2 , c -> avctx -> me_sub_cmp ) ;\n c -> mb_penalty_factor = get_penalty_factor ( s -> lambda , s -> lambda2 , c -> avctx -> mb_cmp ) ;\n c -> current_mv_penalty = c -> mv_penalty [ s -> f_code ] + MAX_MV ;\n get_limits ( s , 16 * mb_x , 16 * mb_y ) ;\n c -> skip = 0 ;\n pix = c -> src [ 0 ] [ 0 ] ;\n sum = s -> dsp . pix_sum ( pix , s -> linesize ) ;\n varc = s -> dsp . pix_norm1 ( pix , s -> linesize ) - ( ( ( unsigned ) sum * sum ) >> 8 ) + 500 ;\n pic -> mb_mean [ s -> mb_stride * mb_y + mb_x ] = ( sum + 128 ) >> 8 ;\n pic -> mb_var [ s -> mb_stride * mb_y + mb_x ] = ( varc + 128 ) >> 8 ;\n c -> mb_var_sum_temp += ( varc + 128 ) >> 8 ;\n switch ( s -> me_method ) {\n case ME_ZERO : default : mx = 0 ;\n my = 0 ;\n dmin = 0 ;\n break ;\n case ME_X1 : case ME_EPZS : {\n const int mot_stride = s -> b8_stride ;\n const int mot_xy = s -> block_index [ 0 ] ;\n P_LEFT [ 0 ] = s -> current_picture . motion_val [ 0 ] [ mot_xy - 1 ] [ 0 ] ;\n P_LEFT [ 1 ] = s -> current_picture . motion_val [ 0 ] [ mot_xy - 1 ] [ 1 ] ;\n if ( P_LEFT [ 0 ] > ( c -> xmax << shift ) ) P_LEFT [ 0 ] = ( c -> xmax << shift ) ;\n if ( ! s -> first_slice_line ) {\n P_TOP [ 0 ] = s -> current_picture . motion_val [ 0 ] [ mot_xy - mot_stride ] [ 0 ] ;\n P_TOP [ 1 ] = s -> current_picture . motion_val [ 0 ] [ mot_xy - mot_stride ] [ 1 ] ;\n P_TOPRIGHT [ 0 ] = s -> current_picture . motion_val [ 0 ] [ mot_xy - mot_stride + 2 ] [ 0 ] ;\n P_TOPRIGHT [ 1 ] = s -> current_picture . motion_val [ 0 ] [ mot_xy - mot_stride + 2 ] [ 1 ] ;\n if ( P_TOP [ 1 ] > ( c -> ymax << shift ) ) P_TOP [ 1 ] = ( c -> ymax << shift ) ;\n if ( P_TOPRIGHT [ 0 ] < ( c -> xmin << shift ) ) P_TOPRIGHT [ 0 ] = ( c -> xmin << shift ) ;\n if ( P_TOPRIGHT [ 1 ] > ( c -> ymax << shift ) ) P_TOPRIGHT [ 1 ] = ( c -> ymax << shift ) ;\n P_MEDIAN [ 0 ] = mid_pred ( P_LEFT [ 0 ] , P_TOP [ 0 ] , P_TOPRIGHT [ 0 ] ) ;\n P_MEDIAN [ 1 ] = mid_pred ( P_LEFT [ 1 ] , P_TOP [ 1 ] , P_TOPRIGHT [ 1 ] ) ;\n if ( s -> out_format == FMT_H263 ) {\n c -> pred_x = P_MEDIAN [ 0 ] ;\n c -> pred_y = P_MEDIAN [ 1 ] ;\n }\n else {\n c -> pred_x = P_LEFT [ 0 ] ;\n c -> pred_y = P_LEFT [ 1 ] ;\n }\n }\n else {\n c -> pred_x = P_LEFT [ 0 ] ;\n c -> pred_y = P_LEFT [ 1 ] ;\n }\n }\n dmin = ff_epzs_motion_search ( s , & mx , & my , P , 0 , 0 , s -> p_mv_table , ( 1 << 16 ) >> shift , 0 , 16 ) ;\n break ;\n }\n ppix = c -> ref [ 0 ] [ 0 ] + ( my * s -> linesize ) + mx ;\n vard = s -> dsp . sse [ 0 ] ( NULL , pix , ppix , s -> linesize , 16 ) ;\n pic -> mc_mb_var [ s -> mb_stride * mb_y + mb_x ] = ( vard + 128 ) >> 8 ;\n c -> mc_mb_var_sum_temp += ( vard + 128 ) >> 8 ;\n if ( mb_type ) {\n int p_score = FFMIN ( vard , varc - 500 + ( s -> lambda2 >> FF_LAMBDA_SHIFT ) * 100 ) ;\n int i_score = varc - 500 + ( s -> lambda2 >> FF_LAMBDA_SHIFT ) * 20 ;\n c -> scene_change_score += ff_sqrt ( p_score ) - ff_sqrt ( i_score ) ;\n if ( mb_type == CANDIDATE_MB_TYPE_INTER ) {\n c -> sub_motion_search ( s , & mx , & my , dmin , 0 , 0 , 0 , 16 ) ;\n set_p_mv_tables ( s , mx , my , 1 ) ;\n }\n else {\n mx <<= shift ;\n my <<= shift ;\n }\n if ( mb_type == CANDIDATE_MB_TYPE_INTER4V ) {\n h263_mv4_search ( s , mx , my , shift ) ;\n set_p_mv_tables ( s , mx , my , 0 ) ;\n }\n if ( mb_type == CANDIDATE_MB_TYPE_INTER_I ) {\n interlaced_search ( s , 0 , s -> p_field_mv_table , s -> p_field_select_table , mx , my , 1 ) ;\n }\n }\n else if ( c -> avctx -> mb_decision > FF_MB_DECISION_SIMPLE ) {\n int p_score = FFMIN ( vard , varc - 500 + ( s -> lambda2 >> FF_LAMBDA_SHIFT ) * 100 ) ;\n int i_score = varc - 500 + ( s -> lambda2 >> FF_LAMBDA_SHIFT ) * 20 ;\n c -> scene_change_score += ff_sqrt ( p_score ) - ff_sqrt ( i_score ) ;\n if ( vard * 2 + 200 * 256 > varc ) mb_type |= CANDIDATE_MB_TYPE_INTRA ;\n if ( varc * 2 + 200 * 256 > vard || s -> qscale > 24 ) {\n mb_type |= CANDIDATE_MB_TYPE_INTER ;\n c -> sub_motion_search ( s , & mx , & my , dmin , 0 , 0 , 0 , 16 ) ;\n if ( s -> flags & CODEC_FLAG_MV0 ) if ( mx || my ) mb_type |= CANDIDATE_MB_TYPE_SKIPPED ;\n }\n else {\n mx <<= shift ;\n my <<= shift ;\n }\n if ( ( s -> flags & CODEC_FLAG_4MV ) && ! c -> skip && varc > 50 << 8 && vard > 10 << 8 ) {\n if ( h263_mv4_search ( s , mx , my , shift ) < INT_MAX ) mb_type |= CANDIDATE_MB_TYPE_INTER4V ;\n set_p_mv_tables ( s , mx , my , 0 ) ;\n }\n else set_p_mv_tables ( s , mx , my , 1 ) ;\n if ( ( s -> flags & CODEC_FLAG_INTERLACED_ME ) && ! c -> skip ) {\n if ( interlaced_search ( s , 0 , s -> p_field_mv_table , s -> p_field_select_table , mx , my , 0 ) < INT_MAX ) mb_type |= CANDIDATE_MB_TYPE_INTER_I ;\n }\n }\n else {\n int intra_score , i ;\n mb_type = CANDIDATE_MB_TYPE_INTER ;\n dmin = c -> sub_motion_search ( s , & mx , & my , dmin , 0 , 0 , 0 , 16 ) ;\n if ( c -> avctx -> me_sub_cmp != c -> avctx -> mb_cmp && ! c -> skip ) dmin = get_mb_score ( s , mx , my , 0 , 0 , 0 , 16 , 1 ) ;\n if ( ( s -> flags & CODEC_FLAG_4MV ) && ! c -> skip && varc > 50 << 8 && vard > 10 << 8 ) {\n int dmin4 = h263_mv4_search ( s , mx , my , shift ) ;\n if ( dmin4 < dmin ) {\n mb_type = CANDIDATE_MB_TYPE_INTER4V ;\n dmin = dmin4 ;\n }\n }\n if ( ( s -> flags & CODEC_FLAG_INTERLACED_ME ) && ! c -> skip ) {\n int dmin_i = interlaced_search ( s , 0 , s -> p_field_mv_table , s -> p_field_select_table , mx , my , 0 ) ;\n if ( dmin_i < dmin ) {\n mb_type = CANDIDATE_MB_TYPE_INTER_I ;\n dmin = dmin_i ;\n }\n }\n set_p_mv_tables ( s , mx , my , mb_type != CANDIDATE_MB_TYPE_INTER4V ) ;\n if ( ( c -> avctx -> mb_cmp & 0xFF ) == FF_CMP_SSE ) {\n intra_score = varc - 500 ;\n }\n else {\n unsigned mean = ( sum + 128 ) >> 8 ;\n mean *= 0x01010101 ;\n for ( i = 0 ;\n i < 16 ;\n i ++ ) {\n * ( uint32_t * ) ( & c -> scratchpad [ i * s -> linesize + 0 ] ) = mean ;\n * ( uint32_t * ) ( & c -> scratchpad [ i * s -> linesize + 4 ] ) = mean ;\n * ( uint32_t * ) ( & c -> scratchpad [ i * s -> linesize + 8 ] ) = mean ;\n * ( uint32_t * ) ( & c -> scratchpad [ i * s -> linesize + 12 ] ) = mean ;\n }\n intra_score = s -> dsp . mb_cmp [ 0 ] ( s , c -> scratchpad , pix , s -> linesize , 16 ) ;\n }\n intra_score += c -> mb_penalty_factor * 16 ;\n if ( intra_score < dmin ) {\n mb_type = CANDIDATE_MB_TYPE_INTRA ;\n s -> current_picture . mb_type [ mb_y * s -> mb_stride + mb_x ] = CANDIDATE_MB_TYPE_INTRA ;\n }\n else s -> current_picture . mb_type [ mb_y * s -> mb_stride + mb_x ] = 0 ;\n {\n int p_score = FFMIN ( vard , varc - 500 + ( s -> lambda2 >> FF_LAMBDA_SHIFT ) * 100 ) ;\n int i_score = varc - 500 + ( s -> lambda2 >> FF_LAMBDA_SHIFT ) * 20 ;\n c -> scene_change_score += ff_sqrt ( p_score ) - ff_sqrt ( i_score ) ;\n }\n }\n s -> mb_type [ mb_y * s -> mb_stride + mb_x ] = mb_type ;\n }", "idx": 1329}
{"hash": -2325305888478261876, "project": "debian", "size": 54, "label": 0, "functionSource": "static int localmom ( void ) {\n static int have_addr = 0 ;\n static struct in_addr hostaddr ;\n struct addrinfo * addr_info ;\n int i ;\n int sock ;\n struct sockaddr_in remote ;\n struct linger ltime ;\n if ( local_conn >= 0 ) {\n return ( local_conn ) ;\n }\n memset ( & remote , 0 , sizeof ( remote ) ) ;\n if ( have_addr == 0 ) {\n if ( pbs_getaddrinfo ( \"localhost\" , NULL , & addr_info ) != 0 ) {\n TM_DBPRT ( ( \"tm_init: localhost not found\\n\" ) ) return ( - 1 ) ;\n }\n hostaddr = ( ( struct sockaddr_in * ) addr_info -> ai_addr ) -> sin_addr ;\n have_addr = 1 ;\n }\n for ( i = 0 ;\n i < 5 ;\n i ++ ) {\n sock = socket ( AF_INET , SOCK_STREAM , 0 ) ;\n if ( sock < 0 ) {\n return ( - 1 ) ;\n }\n # ifndef HAVE_POLL if ( sock >= FD_SETSIZE ) {\n close ( sock ) ;\n return ( - 1 ) ;\n }\n # endif ltime . l_onoff = 1 ;\n ltime . l_linger = 5 ;\n setsockopt ( sock , SOL_SOCKET , SO_LINGER , & ltime , sizeof ( ltime ) ) ;\n remote . sin_addr = hostaddr ;\n remote . sin_port = htons ( ( unsigned short ) tm_momport ) ;\n remote . sin_family = AF_INET ;\n if ( connect ( sock , ( struct sockaddr * ) & remote , sizeof ( remote ) ) < 0 ) {\n switch ( errno ) {\n case EINTR : case EADDRINUSE : case ETIMEDOUT : case ECONNREFUSED : close ( sock ) ;\n sleep ( 1 ) ;\n continue ;\n break ;\n default : close ( sock ) ;\n return ( - 1 ) ;\n break ;\n }\n }\n else {\n local_conn = sock ;\n break ;\n }\n }\n return ( local_conn ) ;\n }", "idx": 1330}
{"hash": 2895622461494525400, "project": "debian", "size": 75, "label": 0, "functionSource": "static void test_ts ( ) {\n MYSQL_STMT * stmt ;\n MYSQL_BIND my_bind [ 6 ] ;\n MYSQL_TIME ts ;\n MYSQL_RES * prep_res ;\n char strts [ 30 ] ;\n ulong length ;\n int rc , field_count ;\n char name ;\n char query [ MAX_TEST_QUERY_LENGTH ] ;\n const char * queries [ 3 ] = {\n \"SELECT a, b, c FROM test_ts WHERE %c=?\" , \"SELECT a, b, c FROM test_ts WHERE %c=?\" , \"SELECT a, b, c FROM test_ts WHERE %c=CAST(? AS DATE)\" }\n ;\n myheader ( \"test_ts\" ) ;\n rc = mysql_query ( mysql , \"DROP TABLE IF EXISTS test_ts\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"CREATE TABLE test_ts(a DATE, b TIME, c TIMESTAMP)\" ) ;\n myquery ( rc ) ;\n stmt = mysql_simple_prepare ( mysql , \"INSERT INTO test_ts VALUES(?, ?, ?), (?, ?, ?)\" ) ;\n check_stmt ( stmt ) ;\n ts . year = 2003 ;\n ts . month = 07 ;\n ts . day = 12 ;\n ts . hour = 21 ;\n ts . minute = 07 ;\n ts . second = 46 ;\n ts . second_part = 0 ;\n length = ( long ) ( strmov ( strts , \"2003-07-12 21:07:46\" ) - strts ) ;\n memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n my_bind [ 0 ] . buffer_type = MYSQL_TYPE_TIMESTAMP ;\n my_bind [ 0 ] . buffer = ( void * ) & ts ;\n my_bind [ 0 ] . buffer_length = sizeof ( ts ) ;\n my_bind [ 2 ] = my_bind [ 1 ] = my_bind [ 0 ] ;\n my_bind [ 3 ] . buffer_type = MYSQL_TYPE_STRING ;\n my_bind [ 3 ] . buffer = ( void * ) strts ;\n my_bind [ 3 ] . buffer_length = sizeof ( strts ) ;\n my_bind [ 3 ] . length = & length ;\n my_bind [ 5 ] = my_bind [ 4 ] = my_bind [ 3 ] ;\n rc = mysql_stmt_bind_param ( stmt , my_bind ) ;\n check_execute ( stmt , rc ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n mysql_stmt_close ( stmt ) ;\n verify_col_data ( \"test_ts\" , \"a\" , \"2003-07-12\" ) ;\n verify_col_data ( \"test_ts\" , \"b\" , \"21:07:46\" ) ;\n verify_col_data ( \"test_ts\" , \"c\" , \"2003-07-12 21:07:46\" ) ;\n stmt = mysql_simple_prepare ( mysql , \"SELECT * FROM test_ts\" ) ;\n check_stmt ( stmt ) ;\n prep_res = mysql_stmt_result_metadata ( stmt ) ;\n mytest ( prep_res ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n rc = my_process_stmt_result ( stmt ) ;\n DIE_UNLESS ( rc == 2 ) ;\n field_count = mysql_num_fields ( prep_res ) ;\n mysql_free_result ( prep_res ) ;\n mysql_stmt_close ( stmt ) ;\n for ( name = 'a' ;\n field_count -- ;\n name ++ ) {\n int row_count = 0 ;\n sprintf ( query , queries [ field_count ] , name ) ;\n if ( ! opt_silent ) fprintf ( stdout , \"\\n %s\" , query ) ;\n stmt = mysql_simple_prepare ( mysql , query ) ;\n check_stmt ( stmt ) ;\n rc = mysql_stmt_bind_param ( stmt , my_bind ) ;\n check_execute ( stmt , rc ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n while ( mysql_stmt_fetch ( stmt ) == 0 ) row_count ++ ;\n if ( ! opt_silent ) fprintf ( stdout , \"\\n returned '%d' rows\" , row_count ) ;\n DIE_UNLESS ( row_count == 2 ) ;\n mysql_stmt_close ( stmt ) ;\n }\n }", "idx": 1331}
{"hash": -8620097311326519087, "project": "chrome", "size": 13, "label": 0, "functionSource": "static err_status_t srtp_validate_rtp_header ( void * rtp_hdr , int * pkt_octet_len ) {\n srtp_hdr_t * hdr = ( srtp_hdr_t * ) rtp_hdr ;\n int rtp_header_len = octets_in_rtp_header + 4 * hdr -> cc ;\n if ( hdr -> x == 1 ) rtp_header_len += octets_in_rtp_extn_hdr ;\n if ( * pkt_octet_len < rtp_header_len ) return err_status_bad_param ;\n if ( hdr -> x == 1 ) {\n srtp_hdr_xtnd_t * xtn_hdr = ( srtp_hdr_xtnd_t * ) ( ( uint32_t * ) hdr + uint32s_in_rtp_header + hdr -> cc ) ;\n int profile_len = ntohs ( xtn_hdr -> length ) ;\n rtp_header_len += profile_len * 4 ;\n if ( * pkt_octet_len < rtp_header_len ) return err_status_bad_param ;\n }\n return err_status_ok ;\n }", "idx": 1332}
{"hash": 7549435794356072684, "project": "debian", "size": 5, "label": 0, "functionSource": "static VALUE join_der ( VALUE enumerable ) {\n VALUE str = rb_str_new ( 0 , 0 ) ;\n rb_block_call ( enumerable , rb_intern ( \"each\" ) , 0 , 0 , join_der_i , str ) ;\n return str ;\n }", "idx": 1333}
{"hash": -643892134151497131, "project": "debian", "size": 32, "label": 0, "functionSource": "static const unsigned char * seq_unpack_rle_block ( const unsigned char * src , const unsigned char * src_end , unsigned char * dst , int dst_size ) {\n int i , len , sz ;\n GetBitContext gb ;\n int code_table [ 64 ] ;\n init_get_bits ( & gb , src , ( src_end - src ) * 8 ) ;\n for ( i = 0 , sz = 0 ;\n i < 64 && sz < dst_size ;\n i ++ ) {\n if ( get_bits_left ( & gb ) < 4 ) return NULL ;\n code_table [ i ] = get_sbits ( & gb , 4 ) ;\n sz += FFABS ( code_table [ i ] ) ;\n }\n src += ( get_bits_count ( & gb ) + 7 ) / 8 ;\n for ( i = 0 ;\n i < 64 && dst_size > 0 ;\n i ++ ) {\n len = code_table [ i ] ;\n if ( len < 0 ) {\n len = - len ;\n if ( src_end - src < 1 ) return NULL ;\n memset ( dst , * src ++ , FFMIN ( len , dst_size ) ) ;\n }\n else {\n if ( src_end - src < len ) return NULL ;\n memcpy ( dst , src , FFMIN ( len , dst_size ) ) ;\n src += len ;\n }\n dst += len ;\n dst_size -= len ;\n }\n return src ;\n }", "idx": 1334}
{"hash": 8461782184979846246, "project": "chrome", "size": 8, "label": 0, "functionSource": "TEST_F ( ProtocolHandlerRegistryTest , TestMostRecentHandlerIsDefault ) {\n ProtocolHandler ph1 = CreateProtocolHandler ( \"test\" , \"test1\" ) ;\n ProtocolHandler ph2 = CreateProtocolHandler ( \"test\" , \"test2\" ) ;\n registry ( ) -> OnAcceptRegisterProtocolHandler ( ph1 ) ;\n registry ( ) -> OnAcceptRegisterProtocolHandler ( ph2 ) ;\n ASSERT_FALSE ( registry ( ) -> IsDefault ( ph1 ) ) ;\n ASSERT_TRUE ( registry ( ) -> IsDefault ( ph2 ) ) ;\n }", "idx": 1335}
{"hash": -4055702019813176658, "project": "debian", "size": 17, "label": 0, "functionSource": "static guint32 dissect_trunkcall_ts ( tvbuff_t * tvb , guint32 offset , proto_tree * iax2_tree , guint16 * scallno ) {\n proto_tree * call_tree ;\n guint16 datalen , rlen , ts ;\n datalen = tvb_get_ntohs ( tvb , offset ) ;\n * scallno = tvb_get_ntohs ( tvb , offset + 2 ) ;\n ts = tvb_get_ntohs ( tvb , offset + 4 ) ;\n rlen = MIN ( tvb_captured_length ( tvb ) - offset - 6 , datalen ) ;\n if ( iax2_tree ) {\n call_tree = proto_tree_add_subtree_format ( iax2_tree , tvb , offset , rlen + 6 , ett_iax2_trunk_call , NULL , \"Trunk call from %u, ts: %u\" , * scallno , ts ) ;\n proto_tree_add_item ( call_tree , hf_iax2_trunk_call_len , tvb , offset , 2 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( call_tree , hf_iax2_trunk_call_scallno , tvb , offset + 2 , 2 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( call_tree , hf_iax2_trunk_call_ts , tvb , offset + 4 , 2 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( call_tree , hf_iax2_trunk_call_data , tvb , offset + 6 , rlen , ENC_NA ) ;\n }\n offset += 6 + rlen ;\n return offset ;\n }", "idx": 1336}
{"hash": -5706788925640467782, "project": "chrome", "size": 13, "label": 0, "functionSource": "static void nonrd_pick_sb_modes ( VP9_COMP * cpi , const TileInfo * const tile , int mi_row , int mi_col , int * rate , int64_t * dist , BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx ) {\n VP9_COMMON * const cm = & cpi -> common ;\n MACROBLOCK * const x = & cpi -> mb ;\n MACROBLOCKD * const xd = & x -> e_mbd ;\n MB_MODE_INFO * mbmi ;\n set_offsets ( cpi , tile , mi_row , mi_col , bsize ) ;\n mbmi = & xd -> mi [ 0 ] . src_mi -> mbmi ;\n mbmi -> sb_type = bsize ;\n if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ && cm -> seg . enabled ) if ( mbmi -> segment_id && x -> in_static_area ) x -> rdmult = vp9_cyclic_refresh_get_rdmult ( cpi -> cyclic_refresh ) ;\n if ( vp9_segfeature_active ( & cm -> seg , mbmi -> segment_id , SEG_LVL_SKIP ) ) set_mode_info_seg_skip ( x , cm -> tx_mode , rate , dist , bsize ) ;\n else vp9_pick_inter_mode ( cpi , x , tile , mi_row , mi_col , rate , dist , bsize , ctx ) ;\n duplicate_mode_info_in_sb ( cm , xd , mi_row , mi_col , bsize ) ;\n }", "idx": 1337}
{"hash": 3576240888172463140, "project": "debian", "size": 16, "label": 0, "functionSource": "static void unlock_all ( KEYDB_HANDLE hd ) {\n int i ;\n if ( ! hd -> locked ) return ;\n for ( i = hd -> used - 1 ;\n i >= 0 ;\n i -- ) {\n switch ( hd -> active [ i ] . type ) {\n case KEYDB_RESOURCE_TYPE_NONE : break ;\n case KEYDB_RESOURCE_TYPE_KEYRING : keyring_lock ( hd -> active [ i ] . u . kr , 0 ) ;\n break ;\n case KEYDB_RESOURCE_TYPE_KEYBOX : keybox_lock ( hd -> active [ i ] . u . kb , 0 ) ;\n break ;\n }\n }\n hd -> locked = 0 ;\n }", "idx": 1338}
{"hash": -7855974557509681261, "project": "debian", "size": 15, "label": 0, "functionSource": "int32 get_attavgwidth ( Oid relid , AttrNumber attnum ) {\n HeapTuple tp ;\n int32 stawidth ;\n if ( get_attavgwidth_hook ) {\n stawidth = ( * get_attavgwidth_hook ) ( relid , attnum ) ;\n if ( stawidth > 0 ) return stawidth ;\n }\n tp = SearchSysCache3 ( STATRELATTINH , ObjectIdGetDatum ( relid ) , Int16GetDatum ( attnum ) , BoolGetDatum ( false ) ) ;\n if ( HeapTupleIsValid ( tp ) ) {\n stawidth = ( ( Form_pg_statistic ) GETSTRUCT ( tp ) ) -> stawidth ;\n ReleaseSysCache ( tp ) ;\n if ( stawidth > 0 ) return stawidth ;\n }\n return 0 ;\n }", "idx": 1339}
{"hash": 8693230691624196914, "project": "chrome", "size": 14, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( ExtensionPreferenceApiTest , OnChangeSplitWithoutIncognitoAccess ) {\n PrefService * prefs = profile_ -> GetPrefs ( ) ;\n prefs -> SetBoolean ( prefs : : kBlockThirdPartyCookies , true ) ;\n OpenURLOffTheRecord ( profile_ , GURL ( \"chrome:/ewtab/\" ) ) ;\n EXPECT_TRUE ( profile_ -> HasOffTheRecordProfile ( ) ) ;\n extensions : : ResultCatcher catcher ;\n ExtensionTestMessageListener loaded_incognito_test_listener ( \"incognito loaded\" , false ) ;\n ExtensionTestMessageListener change_pref_listener ( \"change pref value\" , false ) ;\n ASSERT_TRUE ( LoadExtension ( test_data_dir_ . AppendASCII ( \"preference\" ) . AppendASCII ( \"onchange_split_regular_only\" ) ) ) ;\n ASSERT_TRUE ( change_pref_listener . WaitUntilSatisfied ( ) ) ;\n prefs -> SetBoolean ( prefs : : kBlockThirdPartyCookies , false ) ;\n EXPECT_TRUE ( catcher . GetNextResult ( ) ) << catcher . message ( ) ;\n EXPECT_FALSE ( loaded_incognito_test_listener . was_satisfied ( ) ) ;\n }", "idx": 1340}
{"hash": 1911881859629730975, "project": "chrome", "size": 34, "label": 0, "functionSource": "void vp9_mv_pred ( VP9_COMP * cpi , MACROBLOCK * x , uint8_t * ref_y_buffer , int ref_y_stride , int ref_frame , BLOCK_SIZE block_size ) {\n MACROBLOCKD * xd = & x -> e_mbd ;\n MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] . src_mi -> mbmi ;\n int i ;\n int zero_seen = 0 ;\n int best_index = 0 ;\n int best_sad = INT_MAX ;\n int this_sad = INT_MAX ;\n int max_mv = 0 ;\n uint8_t * src_y_ptr = x -> plane [ 0 ] . src . buf ;\n uint8_t * ref_y_ptr ;\n const int num_mv_refs = MAX_MV_REF_CANDIDATES + ( cpi -> sf . adaptive_motion_search && block_size < cpi -> sf . max_partition_size ) ;\n MV pred_mv [ 3 ] ;\n pred_mv [ 0 ] = mbmi -> ref_mvs [ ref_frame ] [ 0 ] . as_mv ;\n pred_mv [ 1 ] = mbmi -> ref_mvs [ ref_frame ] [ 1 ] . as_mv ;\n pred_mv [ 2 ] = x -> pred_mv [ ref_frame ] ;\n for ( i = 0 ;\n i < num_mv_refs ;\n ++ i ) {\n const MV * this_mv = & pred_mv [ i ] ;\n max_mv = MAX ( max_mv , MAX ( abs ( this_mv -> row ) , abs ( this_mv -> col ) ) >> 3 ) ;\n if ( is_zero_mv ( this_mv ) && zero_seen ) continue ;\n zero_seen |= is_zero_mv ( this_mv ) ;\n ref_y_ptr = & ref_y_buffer [ ref_y_stride * ( this_mv -> row >> 3 ) + ( this_mv -> col >> 3 ) ] ;\n this_sad = cpi -> fn_ptr [ block_size ] . sdf ( src_y_ptr , x -> plane [ 0 ] . src . stride , ref_y_ptr , ref_y_stride ) ;\n if ( this_sad < best_sad ) {\n best_sad = this_sad ;\n best_index = i ;\n }\n }\n x -> mv_best_ref_index [ ref_frame ] = best_index ;\n x -> max_mv_context [ ref_frame ] = max_mv ;\n x -> pred_mv_sad [ ref_frame ] = best_sad ;\n }", "idx": 1341}
{"hash": -7888349587538303571, "project": "debian", "size": 18, "label": 0, "functionSource": "static struct sock * __raw_v6_lookup ( struct net * net , struct sock * sk , unsigned short num , struct in6_addr * loc_addr , struct in6_addr * rmt_addr , int dif ) {\n struct hlist_node * node ;\n int is_multicast = ipv6_addr_is_multicast ( loc_addr ) ;\n sk_for_each_from ( sk , node ) if ( inet_sk ( sk ) -> inet_num == num ) {\n struct ipv6_pinfo * np = inet6_sk ( sk ) ;\n if ( ! net_eq ( sock_net ( sk ) , net ) ) continue ;\n if ( ! ipv6_addr_any ( & np -> daddr ) && ! ipv6_addr_equal ( & np -> daddr , rmt_addr ) ) continue ;\n if ( sk -> sk_bound_dev_if && sk -> sk_bound_dev_if != dif ) continue ;\n if ( ! ipv6_addr_any ( & np -> rcv_saddr ) ) {\n if ( ipv6_addr_equal ( & np -> rcv_saddr , loc_addr ) ) goto found ;\n if ( is_multicast && inet6_mc_check ( sk , loc_addr , rmt_addr ) ) goto found ;\n continue ;\n }\n goto found ;\n }\n sk = NULL ;\n found : return sk ;\n }", "idx": 1342}
{"hash": -3053641395158209010, "project": "debian", "size": 38, "label": 0, "functionSource": "static int x ( struct vcache * avc , int afun , struct vrequest * areq , \\ struct afs_pdata * ain , struct afs_pdata * aout , \\ afs_ucred_t * * acred ) DECL_PIOCTL ( PGetFID ) ;\n DECL_PIOCTL ( PSetAcl ) ;\n DECL_PIOCTL ( PStoreBehind ) ;\n DECL_PIOCTL ( PGCPAGs ) ;\n DECL_PIOCTL ( PGetAcl ) ;\n DECL_PIOCTL ( PNoop ) ;\n DECL_PIOCTL ( PBogus ) ;\n DECL_PIOCTL ( PGetFileCell ) ;\n DECL_PIOCTL ( PGetWSCell ) ;\n DECL_PIOCTL ( PGetUserCell ) ;\n DECL_PIOCTL ( PSetTokens ) ;\n DECL_PIOCTL ( PGetVolumeStatus ) ;\n DECL_PIOCTL ( PSetVolumeStatus ) ;\n DECL_PIOCTL ( PFlush ) ;\n DECL_PIOCTL ( PNewStatMount ) ;\n DECL_PIOCTL ( PGetTokens ) ;\n DECL_PIOCTL ( PUnlog ) ;\n DECL_PIOCTL ( PMariner ) ;\n DECL_PIOCTL ( PCheckServers ) ;\n DECL_PIOCTL ( PCheckVolNames ) ;\n DECL_PIOCTL ( PCheckAuth ) ;\n DECL_PIOCTL ( PFindVolume ) ;\n DECL_PIOCTL ( PViceAccess ) ;\n DECL_PIOCTL ( PSetCacheSize ) ;\n DECL_PIOCTL ( PGetCacheSize ) ;\n DECL_PIOCTL ( PRemoveCallBack ) ;\n DECL_PIOCTL ( PNewCell ) ;\n DECL_PIOCTL ( PNewAlias ) ;\n DECL_PIOCTL ( PListCells ) ;\n DECL_PIOCTL ( PListAliases ) ;\n DECL_PIOCTL ( PRemoveMount ) ;\n DECL_PIOCTL ( PGetCellStatus ) ;\n DECL_PIOCTL ( PSetCellStatus ) ;\n DECL_PIOCTL ( PFlushVolumeData ) ;\n DECL_PIOCTL ( PFlushAllVolumeData ) ;\n DECL_PIOCTL ( PGetVnodeXStatus ) ;\n DECL_PIOCTL ( PGetVnodeXStatus2 ) ;\n DECL_PIOCTL ( PSetSysName )", "idx": 1343}
{"hash": -7076754245473579218, "project": "chrome", "size": 4, "label": 0, "functionSource": "void evhttp_send_reply ( struct evhttp_request * req , int code , const char * reason , struct evbuffer * databuf ) {\n evhttp_response_code ( req , code , reason ) ;\n evhttp_send ( req , databuf ) ;\n }", "idx": 1344}
{"hash": 355220887711506893, "project": "debian", "size": 5, "label": 0, "functionSource": "static bool byte_increment ( unsigned char * ptr , int len ) {\n if ( * ptr >= 255 ) return false ;\n ( * ptr ) ++ ;\n return true ;\n }", "idx": 1345}
{"hash": 1788300783882316916, "project": "debian", "size": 3, "label": 0, "functionSource": "static int zero_cmp ( void * s , uint8_t * a , uint8_t * b , int stride , int h ) {\n return 0 ;\n }", "idx": 1346}
{"hash": -6252714751027237823, "project": "debian", "size": 16, "label": 0, "functionSource": "gs_malloc_memory_t * gs_malloc_memory_init ( void ) {\n gs_malloc_memory_t * mem = ( gs_malloc_memory_t * ) Memento_label ( malloc ( sizeof ( gs_malloc_memory_t ) ) , \"gs_malloc_memory_t\" ) ;\n if ( mem == NULL ) return NULL ;\n mem -> stable_memory = 0 ;\n mem -> procs = gs_malloc_memory_procs ;\n mem -> allocated = 0 ;\n mem -> limit = max_long ;\n mem -> used = 0 ;\n mem -> max_used = 0 ;\n mem -> gs_lib_ctx = 0 ;\n mem -> non_gc_memory = ( gs_memory_t * ) mem ;\n mem -> thread_safe_memory = ( gs_memory_t * ) mem ;\n mem -> monitor = NULL ;\n mem -> monitor = gx_monitor_alloc ( ( gs_memory_t * ) mem ) ;\n return mem ;\n }", "idx": 1347}
{"hash": -6580451576689962916, "project": "debian", "size": 18, "label": 0, "functionSource": "static char * emnc10_opaque_binary_attr ( tvbuff_t * tvb , guint32 offset , guint8 token , guint8 codepage , guint32 * length ) {\n guint32 data_len = tvb_get_guintvar ( tvb , offset , length ) ;\n char * str = NULL ;\n switch ( codepage ) {\n case 0 : switch ( token ) {\n case 0x05 : str = date_time_from_opaque ( tvb , offset + * length , data_len ) ;\n break ;\n default : break ;\n }\n break ;\n default : break ;\n }\n if ( str == NULL ) {\n str = wmem_strdup_printf ( wmem_packet_scope ( ) , \"(%d bytes of unparsed opaque data)\" , data_len ) ;\n }\n * length += data_len ;\n return str ;\n }", "idx": 1348}
{"hash": -4239386405881995323, "project": "chrome", "size": 68, "label": 0, "functionSource": "int xmlHashAddEntry3 ( xmlHashTablePtr table , const xmlChar * name , const xmlChar * name2 , const xmlChar * name3 , void * userdata ) {\n unsigned long key , len = 0 ;\n xmlHashEntryPtr entry ;\n xmlHashEntryPtr insert ;\n if ( ( table == NULL ) || ( name == NULL ) ) return ( - 1 ) ;\n if ( table -> dict ) {\n if ( ! xmlDictOwns ( table -> dict , name ) ) {\n name = xmlDictLookup ( table -> dict , name , - 1 ) ;\n if ( name == NULL ) return ( - 1 ) ;\n }\n if ( ( name2 != NULL ) && ( ! xmlDictOwns ( table -> dict , name2 ) ) ) {\n name2 = xmlDictLookup ( table -> dict , name2 , - 1 ) ;\n if ( name2 == NULL ) return ( - 1 ) ;\n }\n if ( ( name3 != NULL ) && ( ! xmlDictOwns ( table -> dict , name3 ) ) ) {\n name3 = xmlDictLookup ( table -> dict , name3 , - 1 ) ;\n if ( name3 == NULL ) return ( - 1 ) ;\n }\n }\n key = xmlHashComputeKey ( table , name , name2 , name3 ) ;\n if ( table -> table [ key ] . valid == 0 ) {\n insert = NULL ;\n }\n else {\n if ( table -> dict ) {\n for ( insert = & ( table -> table [ key ] ) ;\n insert -> next != NULL ;\n insert = insert -> next ) {\n if ( ( insert -> name == name ) && ( insert -> name2 == name2 ) && ( insert -> name3 == name3 ) ) return ( - 1 ) ;\n len ++ ;\n }\n if ( ( insert -> name == name ) && ( insert -> name2 == name2 ) && ( insert -> name3 == name3 ) ) return ( - 1 ) ;\n }\n else {\n for ( insert = & ( table -> table [ key ] ) ;\n insert -> next != NULL ;\n insert = insert -> next ) {\n if ( ( xmlStrEqual ( insert -> name , name ) ) && ( xmlStrEqual ( insert -> name2 , name2 ) ) && ( xmlStrEqual ( insert -> name3 , name3 ) ) ) return ( - 1 ) ;\n len ++ ;\n }\n if ( ( xmlStrEqual ( insert -> name , name ) ) && ( xmlStrEqual ( insert -> name2 , name2 ) ) && ( xmlStrEqual ( insert -> name3 , name3 ) ) ) return ( - 1 ) ;\n }\n }\n if ( insert == NULL ) {\n entry = & ( table -> table [ key ] ) ;\n }\n else {\n entry = xmlMalloc ( sizeof ( xmlHashEntry ) ) ;\n if ( entry == NULL ) return ( - 1 ) ;\n }\n if ( table -> dict != NULL ) {\n entry -> name = ( xmlChar * ) name ;\n entry -> name2 = ( xmlChar * ) name2 ;\n entry -> name3 = ( xmlChar * ) name3 ;\n }\n else {\n entry -> name = xmlStrdup ( name ) ;\n entry -> name2 = xmlStrdup ( name2 ) ;\n entry -> name3 = xmlStrdup ( name3 ) ;\n }\n entry -> payload = userdata ;\n entry -> next = NULL ;\n entry -> valid = 1 ;\n if ( insert != NULL ) insert -> next = entry ;\n table -> nbElems ++ ;\n if ( len > MAX_HASH_LEN ) xmlHashGrow ( table , MAX_HASH_LEN * table -> size ) ;\n return ( 0 ) ;\n }", "idx": 1349}
{"hash": -7019074708255236794, "project": "debian", "size": 21, "label": 0, "functionSource": "static void upsample_5_4 ( float * out , const float * in , int o_size ) {\n const float * in0 = in - UPS_FIR_SIZE + 1 ;\n int i , j , k ;\n int int_part = 0 , frac_part ;\n i = 0 ;\n for ( j = 0 ;\n j < o_size / 5 ;\n j ++ ) {\n out [ i ] = in [ int_part ] ;\n frac_part = 4 ;\n i ++ ;\n for ( k = 1 ;\n k < 5 ;\n k ++ ) {\n out [ i ] = avpriv_scalarproduct_float_c ( in0 + int_part , upsample_fir [ 4 - frac_part ] , UPS_MEM_SIZE ) ;\n int_part ++ ;\n frac_part -- ;\n i ++ ;\n }\n }\n }", "idx": 1350}
{"hash": -4527380754569407959, "project": "chrome", "size": 51, "label": 1, "functionSource": "GType hb_gobject_ ## name ## _get_type ( void ) \\ {\n static gsize type_id = 0 ;\n if ( g_once_init_enter ( & type_id ) ) {\n GType id = g_boxed_type_register_static ( g_intern_static_string ( \"hb_\" # name \"_t\" ) , ( GBoxedCopyFunc ) copy_func , ( GBoxedFreeFunc ) free_func ) ;\n g_once_init_leave ( & type_id , id ) ;\n }\n return type_id ;\n \\ }\n # define HB_DEFINE_OBJECT_TYPE ( name ) HB_DEFINE_BOXED_TYPE ( name , hb_ ## name ## _reference , hb_ ## name ## _destroy ) ;\n HB_DEFINE_OBJECT_TYPE ( buffer ) HB_DEFINE_OBJECT_TYPE ( blob ) HB_DEFINE_OBJECT_TYPE ( face ) HB_DEFINE_OBJECT_TYPE ( font ) HB_DEFINE_OBJECT_TYPE ( font_funcs ) HB_DEFINE_OBJECT_TYPE ( set ) HB_DEFINE_OBJECT_TYPE ( shape_plan ) HB_DEFINE_OBJECT_TYPE ( unicode_funcs ) static hb_feature_t * feature_reference ( hb_feature_t * g ) {\n hb_feature_t * c = ( hb_feature_t * ) calloc ( 1 , sizeof ( hb_feature_t ) ) ;\n if ( unlikely ( ! c ) ) return NULL ;\n * c = * g ;\n return c ;\n }\n static void feature_destroy ( hb_feature_t * g ) {\n free ( g ) ;\n }\n HB_DEFINE_BOXED_TYPE ( feature , feature_reference , feature_destroy ) static hb_glyph_info_t * glyph_info_reference ( hb_glyph_info_t * g ) {\n hb_glyph_info_t * c = ( hb_glyph_info_t * ) calloc ( 1 , sizeof ( hb_glyph_info_t ) ) ;\n if ( unlikely ( ! c ) ) return NULL ;\n * c = * g ;\n return c ;\n }\n static void glyph_info_destroy ( hb_glyph_info_t * g ) {\n free ( g ) ;\n }\n HB_DEFINE_BOXED_TYPE ( glyph_info , glyph_info_reference , glyph_info_destroy ) static hb_glyph_position_t * glyph_position_reference ( hb_glyph_position_t * g ) {\n hb_glyph_position_t * c = ( hb_glyph_position_t * ) calloc ( 1 , sizeof ( hb_glyph_position_t ) ) ;\n if ( unlikely ( ! c ) ) return NULL ;\n * c = * g ;\n return c ;\n }\n static void glyph_position_destroy ( hb_glyph_position_t * g ) {\n free ( g ) ;\n }\n HB_DEFINE_BOXED_TYPE ( glyph_position , glyph_position_reference , glyph_position_destroy ) static hb_segment_properties_t * segment_properties_reference ( hb_segment_properties_t * g ) {\n hb_segment_properties_t * c = ( hb_segment_properties_t * ) calloc ( 1 , sizeof ( hb_segment_properties_t ) ) ;\n if ( unlikely ( ! c ) ) return NULL ;\n * c = * g ;\n return c ;\n }\n static void segment_properties_destroy ( hb_segment_properties_t * g ) {\n free ( g ) ;\n }\n HB_DEFINE_BOXED_TYPE ( segment_properties , segment_properties_reference , segment_properties_destroy ) static hb_user_data_key_t user_data_key_reference ( hb_user_data_key_t l ) {\n return l ;\n }\n static void user_data_key_destroy ( hb_user_data_key_t l ) {\n }\n HB_DEFINE_BOXED_TYPE ( user_data_key , user_data_key_reference , user_data_key_destroy )", "idx": 1351}
{"hash": 7295169435648525618, "project": "debian", "size": 601, "label": 0, "functionSource": "int mdb_search ( Operation * op , SlapReply * rs ) {\n struct mdb_info * mdb = ( struct mdb_info * ) op -> o_bd -> be_private ;\n ID id , cursor , nsubs , ncand , cscope ;\n ID lastid = NOID ;\n ID candidates [ MDB_IDL_UM_SIZE ] ;\n ID iscopes [ MDB_IDL_DB_SIZE ] ;\n ID2 * scopes ;\n void * stack ;\n Entry * e = NULL , * base = NULL ;\n Entry * matched = NULL ;\n AttributeName * attrs ;\n slap_mask_t mask ;\n time_t stoptime ;\n int manageDSAit ;\n int tentries = 0 ;\n IdScopes isc ;\n MDB_cursor * mci , * mcd ;\n ww_ctx wwctx ;\n slap_callback cb = {\n 0 }\n ;\n mdb_op_info opinfo = {\n {\n {\n 0 }\n }\n }\n , * moi = & opinfo ;\n MDB_txn * ltid = NULL ;\n Debug ( LDAP_DEBUG_TRACE , \"=> \" LDAP_XSTRING ( mdb_search ) \"\\n\" , 0 , 0 , 0 ) ;\n attrs = op -> oq_search . rs_attrs ;\n manageDSAit = get_manageDSAit ( op ) ;\n rs -> sr_err = mdb_opinfo_get ( op , mdb , 1 , & moi ) ;\n switch ( rs -> sr_err ) {\n case 0 : break ;\n default : send_ldap_error ( op , rs , LDAP_OTHER , \"internal error\" ) ;\n return rs -> sr_err ;\n }\n ltid = moi -> moi_txn ;\n rs -> sr_err = mdb_cursor_open ( ltid , mdb -> mi_id2entry , & mci ) ;\n if ( rs -> sr_err ) {\n send_ldap_error ( op , rs , LDAP_OTHER , \"internal error\" ) ;\n return rs -> sr_err ;\n }\n rs -> sr_err = mdb_cursor_open ( ltid , mdb -> mi_dn2id , & mcd ) ;\n if ( rs -> sr_err ) {\n mdb_cursor_close ( mci ) ;\n send_ldap_error ( op , rs , LDAP_OTHER , \"internal error\" ) ;\n return rs -> sr_err ;\n }\n scopes = scope_chunk_get ( op ) ;\n stack = search_stack ( op ) ;\n isc . mt = ltid ;\n isc . mc = mcd ;\n isc . scopes = scopes ;\n isc . oscope = op -> ors_scope ;\n isc . sctmp = stack ;\n if ( op -> ors_deref & LDAP_DEREF_FINDING ) {\n MDB_IDL_ZERO ( candidates ) ;\n }\n dn2entry_retry : rs -> sr_err = mdb_dn2entry ( op , ltid , mcd , & op -> o_req_ndn , & e , & nsubs , 1 ) ;\n switch ( rs -> sr_err ) {\n case MDB_NOTFOUND : matched = e ;\n e = NULL ;\n break ;\n case 0 : break ;\n case LDAP_BUSY : send_ldap_error ( op , rs , LDAP_BUSY , \"ldap server busy\" ) ;\n goto done ;\n default : send_ldap_error ( op , rs , LDAP_OTHER , \"internal error\" ) ;\n goto done ;\n }\n if ( op -> ors_deref & LDAP_DEREF_FINDING ) {\n if ( matched && is_entry_alias ( matched ) ) {\n struct berval stub ;\n stub . bv_val = op -> o_req_ndn . bv_val ;\n stub . bv_len = op -> o_req_ndn . bv_len - matched -> e_nname . bv_len - 1 ;\n e = deref_base ( op , rs , matched , & matched , ltid , candidates , NULL ) ;\n if ( e ) {\n build_new_dn ( & op -> o_req_ndn , & e -> e_nname , & stub , op -> o_tmpmemctx ) ;\n mdb_entry_return ( op , e ) ;\n matched = NULL ;\n goto dn2entry_retry ;\n }\n }\n else if ( e && is_entry_alias ( e ) ) {\n e = deref_base ( op , rs , e , & matched , ltid , candidates , NULL ) ;\n }\n }\n if ( e == NULL ) {\n struct berval matched_dn = BER_BVNULL ;\n if ( matched != NULL ) {\n BerVarray erefs = NULL ;\n if ( ! access_allowed ( op , matched , slap_schema . si_ad_entry , NULL , ACL_DISCLOSE , NULL ) ) {\n rs -> sr_err = LDAP_NO_SUCH_OBJECT ;\n }\n else {\n ber_dupbv ( & matched_dn , & matched -> e_name ) ;\n erefs = is_entry_referral ( matched ) ? get_entry_referrals ( op , matched ) : NULL ;\n if ( rs -> sr_err == MDB_NOTFOUND ) rs -> sr_err = LDAP_REFERRAL ;\n rs -> sr_matched = matched_dn . bv_val ;\n }\n mdb_entry_return ( op , matched ) ;\n matched = NULL ;\n if ( erefs ) {\n rs -> sr_ref = referral_rewrite ( erefs , & matched_dn , & op -> o_req_dn , op -> oq_search . rs_scope ) ;\n ber_bvarray_free ( erefs ) ;\n }\n }\n else {\n rs -> sr_ref = referral_rewrite ( default_referral , NULL , & op -> o_req_dn , op -> oq_search . rs_scope ) ;\n rs -> sr_err = rs -> sr_ref != NULL ? LDAP_REFERRAL : LDAP_NO_SUCH_OBJECT ;\n }\n send_ldap_result ( op , rs ) ;\n if ( rs -> sr_ref ) {\n ber_bvarray_free ( rs -> sr_ref ) ;\n rs -> sr_ref = NULL ;\n }\n if ( ! BER_BVISNULL ( & matched_dn ) ) {\n ber_memfree ( matched_dn . bv_val ) ;\n rs -> sr_matched = NULL ;\n }\n goto done ;\n }\n if ( ! access_allowed_mask ( op , e , slap_schema . si_ad_entry , NULL , ACL_SEARCH , NULL , & mask ) ) {\n if ( ! ACL_GRANT ( mask , ACL_DISCLOSE ) ) {\n rs -> sr_err = LDAP_NO_SUCH_OBJECT ;\n }\n else {\n rs -> sr_err = LDAP_INSUFFICIENT_ACCESS ;\n }\n mdb_entry_return ( op , e ) ;\n send_ldap_result ( op , rs ) ;\n goto done ;\n }\n if ( ! manageDSAit && is_entry_referral ( e ) ) {\n struct berval matched_dn = BER_BVNULL ;\n BerVarray erefs = NULL ;\n ber_dupbv ( & matched_dn , & e -> e_name ) ;\n erefs = get_entry_referrals ( op , e ) ;\n rs -> sr_err = LDAP_REFERRAL ;\n mdb_entry_return ( op , e ) ;\n e = NULL ;\n if ( erefs ) {\n rs -> sr_ref = referral_rewrite ( erefs , & matched_dn , & op -> o_req_dn , op -> oq_search . rs_scope ) ;\n ber_bvarray_free ( erefs ) ;\n if ( ! rs -> sr_ref ) {\n rs -> sr_text = \"bad_referral object\" ;\n }\n }\n Debug ( LDAP_DEBUG_TRACE , LDAP_XSTRING ( mdb_search ) \": entry is referral\\n\" , 0 , 0 , 0 ) ;\n rs -> sr_matched = matched_dn . bv_val ;\n send_ldap_result ( op , rs ) ;\n ber_bvarray_free ( rs -> sr_ref ) ;\n rs -> sr_ref = NULL ;\n ber_memfree ( matched_dn . bv_val ) ;\n rs -> sr_matched = NULL ;\n goto done ;\n }\n if ( get_assert ( op ) && ( test_filter ( op , e , get_assertion ( op ) ) != LDAP_COMPARE_TRUE ) ) {\n rs -> sr_err = LDAP_ASSERTION_FAILED ;\n mdb_entry_return ( op , e ) ;\n send_ldap_result ( op , rs ) ;\n goto done ;\n }\n stoptime = op -> o_time + op -> ors_tlimit ;\n base = e ;\n e = NULL ;\n if ( op -> oq_search . rs_scope == LDAP_SCOPE_BASE ) {\n rs -> sr_err = base_candidate ( op -> o_bd , base , candidates ) ;\n scopes [ 0 ] . mid = 0 ;\n ncand = 1 ;\n }\n else {\n if ( op -> ors_scope == LDAP_SCOPE_ONELEVEL ) {\n size_t nkids ;\n MDB_val key , data ;\n key . mv_data = & base -> e_id ;\n key . mv_size = sizeof ( ID ) ;\n mdb_cursor_get ( mcd , & key , & data , MDB_SET ) ;\n mdb_cursor_count ( mcd , & nkids ) ;\n nsubs = nkids - 1 ;\n }\n else if ( ! base -> e_id ) {\n MDB_stat ms ;\n mdb_stat ( ltid , mdb -> mi_id2entry , & ms ) ;\n nsubs = ms . ms_entries ;\n }\n MDB_IDL_ZERO ( candidates ) ;\n scopes [ 0 ] . mid = 1 ;\n scopes [ 1 ] . mid = base -> e_id ;\n scopes [ 1 ] . mval . mv_data = NULL ;\n rs -> sr_err = search_candidates ( op , rs , base , & isc , mci , candidates , stack ) ;\n ncand = MDB_IDL_N ( candidates ) ;\n if ( ! base -> e_id || ncand == NOID ) {\n MDB_stat ms ;\n mdb_stat ( ltid , mdb -> mi_id2entry , & ms ) ;\n if ( ! base -> e_id ) nsubs = ms . ms_entries ;\n if ( ncand == NOID ) ncand = ms . ms_entries ;\n }\n }\n cursor = 0 ;\n if ( candidates [ 0 ] == 0 ) {\n Debug ( LDAP_DEBUG_TRACE , LDAP_XSTRING ( mdb_search ) \": no candidates\\n\" , 0 , 0 , 0 ) ;\n goto nochange ;\n }\n if ( op -> ors_limit && op -> ors_limit -> lms_s_unchecked != - 1 && ncand > ( unsigned ) op -> ors_limit -> lms_s_unchecked ) {\n rs -> sr_err = LDAP_ADMINLIMIT_EXCEEDED ;\n send_ldap_result ( op , rs ) ;\n rs -> sr_err = LDAP_SUCCESS ;\n goto done ;\n }\n if ( op -> ors_limit == NULL || ! op -> ors_limit -> lms_s_pr_hide ) {\n tentries = ncand ;\n }\n wwctx . flag = 0 ;\n if ( moi == & opinfo ) {\n cb . sc_writewait = mdb_writewait ;\n cb . sc_private = & wwctx ;\n wwctx . txn = ltid ;\n wwctx . mcd = NULL ;\n cb . sc_next = op -> o_callback ;\n op -> o_callback = & cb ;\n }\n if ( get_pagedresults ( op ) > SLAP_CONTROL_IGNORED ) {\n PagedResultsState * ps = op -> o_pagedresults_state ;\n rs -> sr_err = parse_paged_cookie ( op , rs ) ;\n if ( rs -> sr_err != LDAP_SUCCESS ) {\n send_ldap_result ( op , rs ) ;\n goto done ;\n }\n cursor = ( ID ) ps -> ps_cookie ;\n if ( cursor && ps -> ps_size == 0 ) {\n rs -> sr_err = LDAP_SUCCESS ;\n rs -> sr_text = \"search abandoned by pagedResult size=0\" ;\n send_ldap_result ( op , rs ) ;\n goto done ;\n }\n id = mdb_idl_first ( candidates , & cursor ) ;\n if ( id == NOID ) {\n Debug ( LDAP_DEBUG_TRACE , LDAP_XSTRING ( mdb_search ) \": no paged results candidates\\n\" , 0 , 0 , 0 ) ;\n send_paged_response ( op , rs , & lastid , 0 ) ;\n rs -> sr_err = LDAP_OTHER ;\n goto done ;\n }\n if ( id == ( ID ) ps -> ps_cookie ) id = mdb_idl_next ( candidates , & cursor ) ;\n nsubs = ncand ;\n goto loop_begin ;\n }\n if ( nsubs < ncand ) {\n int rc ;\n if ( scopes [ 0 ] . mid > 1 ) {\n cursor = 1 ;\n for ( cscope = 1 ;\n cscope <= scopes [ 0 ] . mid ;\n cscope ++ ) {\n if ( scopes [ cscope ] . mid == base -> e_id ) continue ;\n iscopes [ cursor ++ ] = scopes [ cscope ] . mid ;\n }\n iscopes [ 0 ] = scopes [ 0 ] . mid - 1 ;\n }\n else {\n iscopes [ 0 ] = 0 ;\n }\n wwctx . mcd = mcd ;\n isc . id = base -> e_id ;\n isc . numrdns = 0 ;\n rc = mdb_dn2id_walk ( op , & isc ) ;\n if ( rc ) id = NOID ;\n else id = isc . id ;\n cscope = 0 ;\n }\n else {\n id = mdb_idl_first ( candidates , & cursor ) ;\n }\n while ( id != NOID ) {\n int scopeok ;\n MDB_val edata ;\n loop_begin : if ( op -> o_abandon ) {\n rs -> sr_err = SLAPD_ABANDON ;\n send_ldap_result ( op , rs ) ;\n goto done ;\n }\n if ( slapd_shutdown ) {\n rs -> sr_err = LDAP_UNAVAILABLE ;\n send_ldap_disconnect ( op , rs ) ;\n goto done ;\n }\n if ( op -> ors_tlimit != SLAP_NO_LIMIT && slap_get_time ( ) > stoptime ) {\n rs -> sr_err = LDAP_TIMELIMIT_EXCEEDED ;\n rs -> sr_ref = rs -> sr_v2ref ;\n send_ldap_result ( op , rs ) ;\n rs -> sr_err = LDAP_SUCCESS ;\n goto done ;\n }\n if ( nsubs < ncand ) {\n unsigned i ;\n scopeok = 0 ;\n if ( MDB_IDL_IS_RANGE ( candidates ) ) {\n if ( id >= MDB_IDL_RANGE_FIRST ( candidates ) && id <= MDB_IDL_RANGE_LAST ( candidates ) ) scopeok = 1 ;\n }\n else {\n i = mdb_idl_search ( candidates , id ) ;\n if ( i <= candidates [ 0 ] && candidates [ i ] == id ) scopeok = 1 ;\n }\n if ( scopeok ) goto scopeok ;\n goto loop_continue ;\n }\n scopeok = 0 ;\n isc . numrdns = 0 ;\n switch ( op -> ors_scope ) {\n case LDAP_SCOPE_BASE : if ( id == base -> e_id ) scopeok = 1 ;\n break ;\n # ifdef LDAP_SCOPE_CHILDREN case LDAP_SCOPE_CHILDREN : if ( id == base -> e_id ) break ;\n # endif case LDAP_SCOPE_SUBTREE : if ( id == base -> e_id ) {\n scopeok = 1 ;\n break ;\n }\n case LDAP_SCOPE_ONELEVEL : if ( id == base -> e_id ) break ;\n isc . id = id ;\n isc . nscope = 0 ;\n rs -> sr_err = mdb_idscopes ( op , & isc ) ;\n if ( rs -> sr_err == MDB_SUCCESS ) {\n if ( isc . nscope ) scopeok = 1 ;\n }\n else {\n if ( rs -> sr_err == MDB_NOTFOUND ) goto notfound ;\n }\n break ;\n }\n if ( ! scopeok ) {\n Debug ( LDAP_DEBUG_TRACE , LDAP_XSTRING ( mdb_search ) \": %ld scope not okay\\n\" , ( long ) id , 0 , 0 ) ;\n goto loop_continue ;\n }\n scopeok : if ( id == base -> e_id ) {\n e = base ;\n }\n else {\n rs -> sr_err = mdb_id2edata ( op , mci , id , & edata ) ;\n if ( rs -> sr_err == MDB_NOTFOUND ) {\n notfound : if ( nsubs < ncand ) goto loop_continue ;\n if ( ! MDB_IDL_IS_RANGE ( candidates ) ) {\n Debug ( LDAP_DEBUG_TRACE , LDAP_XSTRING ( mdb_search ) \": candidate %ld not found\\n\" , ( long ) id , 0 , 0 ) ;\n }\n else {\n rs -> sr_err = mdb_get_nextid ( mci , & cursor ) ;\n if ( rs -> sr_err == MDB_NOTFOUND ) {\n break ;\n }\n if ( rs -> sr_err ) {\n rs -> sr_err = LDAP_OTHER ;\n rs -> sr_text = \"internal error in get_nextid\" ;\n send_ldap_result ( op , rs ) ;\n goto done ;\n }\n cursor -- ;\n }\n goto loop_continue ;\n }\n else if ( rs -> sr_err ) {\n rs -> sr_err = LDAP_OTHER ;\n rs -> sr_text = \"internal error in mdb_id2edata\" ;\n send_ldap_result ( op , rs ) ;\n goto done ;\n }\n rs -> sr_err = mdb_entry_decode ( op , ltid , & edata , id , & e ) ;\n if ( rs -> sr_err ) {\n rs -> sr_err = LDAP_OTHER ;\n rs -> sr_text = \"internal error in mdb_entry_decode\" ;\n send_ldap_result ( op , rs ) ;\n goto done ;\n }\n e -> e_id = id ;\n e -> e_name . bv_val = NULL ;\n e -> e_nname . bv_val = NULL ;\n }\n if ( is_entry_subentry ( e ) ) {\n if ( op -> oq_search . rs_scope != LDAP_SCOPE_BASE ) {\n if ( ! get_subentries_visibility ( op ) ) {\n goto loop_continue ;\n }\n }\n else if ( get_subentries ( op ) && ! get_subentries_visibility ( op ) ) {\n goto loop_continue ;\n }\n }\n else if ( get_subentries_visibility ( op ) ) {\n goto loop_continue ;\n }\n if ( op -> ors_deref & LDAP_DEREF_SEARCHING ) {\n if ( is_entry_alias ( e ) && ( ( op -> ors_deref & LDAP_DEREF_FINDING ) || e != base ) ) {\n goto loop_continue ;\n }\n }\n if ( ! manageDSAit && is_entry_glue ( e ) ) {\n goto loop_continue ;\n }\n if ( e != base ) {\n struct berval pdn , pndn ;\n char * d , * n ;\n int i ;\n if ( nsubs < ncand || isc . scopes [ isc . nscope ] . mid == base -> e_id ) {\n pdn = base -> e_name ;\n pndn = base -> e_nname ;\n }\n else {\n mdb_id2name ( op , ltid , & isc . mc , scopes [ isc . nscope ] . mid , & pdn , & pndn ) ;\n }\n e -> e_name . bv_len = pdn . bv_len ;\n e -> e_nname . bv_len = pndn . bv_len ;\n for ( i = 0 ;\n i < isc . numrdns ;\n i ++ ) {\n e -> e_name . bv_len += isc . rdns [ i ] . bv_len + 1 ;\n e -> e_nname . bv_len += isc . nrdns [ i ] . bv_len + 1 ;\n }\n e -> e_name . bv_val = op -> o_tmpalloc ( e -> e_name . bv_len + 1 , op -> o_tmpmemctx ) ;\n e -> e_nname . bv_val = op -> o_tmpalloc ( e -> e_nname . bv_len + 1 , op -> o_tmpmemctx ) ;\n d = e -> e_name . bv_val ;\n n = e -> e_nname . bv_val ;\n if ( nsubs < ncand ) {\n for ( i = isc . numrdns - 1 ;\n i >= 0 ;\n i -- ) {\n memcpy ( d , isc . rdns [ i ] . bv_val , isc . rdns [ i ] . bv_len ) ;\n d += isc . rdns [ i ] . bv_len ;\n * d ++ = ',' ;\n memcpy ( n , isc . nrdns [ i ] . bv_val , isc . nrdns [ i ] . bv_len ) ;\n n += isc . nrdns [ i ] . bv_len ;\n * n ++ = ',' ;\n }\n }\n else {\n for ( i = 0 ;\n i < isc . numrdns ;\n i ++ ) {\n memcpy ( d , isc . rdns [ i ] . bv_val , isc . rdns [ i ] . bv_len ) ;\n d += isc . rdns [ i ] . bv_len ;\n * d ++ = ',' ;\n memcpy ( n , isc . nrdns [ i ] . bv_val , isc . nrdns [ i ] . bv_len ) ;\n n += isc . nrdns [ i ] . bv_len ;\n * n ++ = ',' ;\n }\n }\n if ( pdn . bv_len ) {\n memcpy ( d , pdn . bv_val , pdn . bv_len + 1 ) ;\n memcpy ( n , pndn . bv_val , pndn . bv_len + 1 ) ;\n }\n else {\n * -- d = '\\0' ;\n * -- n = '\\0' ;\n e -> e_name . bv_len -- ;\n e -> e_nname . bv_len -- ;\n }\n if ( pndn . bv_val != base -> e_nname . bv_val ) {\n op -> o_tmpfree ( pndn . bv_val , op -> o_tmpmemctx ) ;\n op -> o_tmpfree ( pdn . bv_val , op -> o_tmpmemctx ) ;\n }\n }\n if ( ! manageDSAit && op -> oq_search . rs_scope != LDAP_SCOPE_BASE && is_entry_referral ( e ) ) {\n BerVarray erefs = get_entry_referrals ( op , e ) ;\n rs -> sr_ref = referral_rewrite ( erefs , & e -> e_name , NULL , op -> oq_search . rs_scope == LDAP_SCOPE_ONELEVEL ? LDAP_SCOPE_BASE : LDAP_SCOPE_SUBTREE ) ;\n rs -> sr_entry = e ;\n rs -> sr_flags = 0 ;\n send_search_reference ( op , rs ) ;\n if ( e != base ) mdb_entry_return ( op , e ) ;\n rs -> sr_entry = NULL ;\n e = NULL ;\n ber_bvarray_free ( rs -> sr_ref ) ;\n ber_bvarray_free ( erefs ) ;\n rs -> sr_ref = NULL ;\n goto loop_continue ;\n }\n rs -> sr_err = test_filter ( op , e , op -> oq_search . rs_filter ) ;\n if ( rs -> sr_err == LDAP_COMPARE_TRUE ) {\n if ( get_pagedresults ( op ) > SLAP_CONTROL_IGNORED ) {\n if ( rs -> sr_nentries >= ( ( PagedResultsState * ) op -> o_pagedresults_state ) -> ps_size ) {\n if ( e != base ) mdb_entry_return ( op , e ) ;\n e = NULL ;\n send_paged_response ( op , rs , & lastid , tentries ) ;\n goto done ;\n }\n lastid = id ;\n }\n if ( e ) {\n rs -> sr_attrs = op -> oq_search . rs_attrs ;\n rs -> sr_operational_attrs = NULL ;\n rs -> sr_ctrls = NULL ;\n rs -> sr_entry = e ;\n RS_ASSERT ( e -> e_private != NULL ) ;\n rs -> sr_flags = 0 ;\n rs -> sr_err = LDAP_SUCCESS ;\n rs -> sr_err = send_search_entry ( op , rs ) ;\n rs -> sr_attrs = NULL ;\n rs -> sr_entry = NULL ;\n if ( e != base ) mdb_entry_return ( op , e ) ;\n e = NULL ;\n switch ( rs -> sr_err ) {\n case LDAP_SUCCESS : break ;\n default : break ;\n case LDAP_BUSY : send_ldap_result ( op , rs ) ;\n goto done ;\n case LDAP_UNAVAILABLE : case LDAP_SIZELIMIT_EXCEEDED : if ( rs -> sr_err == LDAP_SIZELIMIT_EXCEEDED ) {\n rs -> sr_ref = rs -> sr_v2ref ;\n send_ldap_result ( op , rs ) ;\n rs -> sr_err = LDAP_SUCCESS ;\n }\n else {\n rs -> sr_err = LDAP_OTHER ;\n }\n goto done ;\n }\n }\n }\n else {\n Debug ( LDAP_DEBUG_TRACE , LDAP_XSTRING ( mdb_search ) \": %ld does not match filter\\n\" , ( long ) id , 0 , 0 ) ;\n }\n loop_continue : if ( moi == & opinfo && ! wwctx . flag && mdb -> mi_rtxn_size ) {\n wwctx . nentries ++ ;\n if ( wwctx . nentries >= mdb -> mi_rtxn_size ) {\n wwctx . nentries = 0 ;\n mdb_rtxn_snap ( op , & wwctx ) ;\n }\n }\n if ( wwctx . flag ) {\n rs -> sr_err = mdb_waitfixup ( op , & wwctx , mci , mcd , & isc ) ;\n if ( rs -> sr_err ) {\n send_ldap_result ( op , rs ) ;\n goto done ;\n }\n }\n if ( e != NULL ) {\n if ( e != base ) mdb_entry_return ( op , e ) ;\n RS_ASSERT ( rs -> sr_entry == NULL ) ;\n e = NULL ;\n rs -> sr_entry = NULL ;\n }\n if ( nsubs < ncand ) {\n int rc = mdb_dn2id_walk ( op , & isc ) ;\n if ( rc ) {\n id = NOID ;\n while ( iscopes [ 0 ] && cscope < iscopes [ 0 ] ) {\n cscope ++ ;\n isc . id = iscopes [ cscope ] ;\n if ( base ) mdb_entry_return ( op , base ) ;\n rs -> sr_err = mdb_id2entry ( op , mci , isc . id , & base ) ;\n if ( ! rs -> sr_err ) {\n mdb_id2name ( op , ltid , & isc . mc , isc . id , & base -> e_name , & base -> e_nname ) ;\n isc . numrdns = 0 ;\n if ( isc . oscope == LDAP_SCOPE_ONELEVEL ) isc . oscope = LDAP_SCOPE_BASE ;\n rc = mdb_dn2id_walk ( op , & isc ) ;\n if ( ! rc ) {\n id = isc . id ;\n break ;\n }\n }\n }\n }\n else id = isc . id ;\n }\n else {\n id = mdb_idl_next ( candidates , & cursor ) ;\n }\n }\n nochange : rs -> sr_ctrls = NULL ;\n rs -> sr_ref = rs -> sr_v2ref ;\n rs -> sr_err = ( rs -> sr_v2ref == NULL ) ? LDAP_SUCCESS : LDAP_REFERRAL ;\n rs -> sr_rspoid = NULL ;\n if ( get_pagedresults ( op ) > SLAP_CONTROL_IGNORED ) {\n send_paged_response ( op , rs , NULL , 0 ) ;\n }\n else {\n send_ldap_result ( op , rs ) ;\n }\n rs -> sr_err = LDAP_SUCCESS ;\n done : if ( cb . sc_private ) {\n slap_callback * * scp = & op -> o_callback ;\n while ( * scp ) {\n if ( * scp == & cb ) {\n * scp = cb . sc_next ;\n cb . sc_private = NULL ;\n break ;\n }\n }\n }\n mdb_cursor_close ( mcd ) ;\n mdb_cursor_close ( mci ) ;\n if ( moi == & opinfo ) {\n mdb_txn_reset ( moi -> moi_txn ) ;\n LDAP_SLIST_REMOVE ( & op -> o_extra , & moi -> moi_oe , OpExtra , oe_next ) ;\n }\n else {\n moi -> moi_ref -- ;\n }\n if ( rs -> sr_v2ref ) {\n ber_bvarray_free ( rs -> sr_v2ref ) ;\n rs -> sr_v2ref = NULL ;\n }\n if ( base ) mdb_entry_return ( op , base ) ;\n scope_chunk_ret ( op , scopes ) ;\n return rs -> sr_err ;\n }", "idx": 1352}
{"hash": 6664609110189077049, "project": "debian", "size": 15, "label": 0, "functionSource": "static int decode_subframe_length ( WMAProDecodeCtx * s , int offset ) {\n int frame_len_shift = 0 ;\n int subframe_len ;\n if ( offset == s -> samples_per_frame - s -> min_samples_per_subframe ) return s -> min_samples_per_subframe ;\n if ( s -> max_subframe_len_bit ) {\n if ( get_bits1 ( & s -> gb ) ) frame_len_shift = 1 + get_bits ( & s -> gb , s -> subframe_len_bits - 1 ) ;\n }\n else frame_len_shift = get_bits ( & s -> gb , s -> subframe_len_bits ) ;\n subframe_len = s -> samples_per_frame >> frame_len_shift ;\n if ( subframe_len < s -> min_samples_per_subframe || subframe_len > s -> samples_per_frame ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"broken frame: subframe_len %i\\n\" , subframe_len ) ;\n return AVERROR_INVALIDDATA ;\n }\n return subframe_len ;\n }", "idx": 1353}
{"hash": 8326517429469576957, "project": "debian", "size": 40, "label": 1, "functionSource": "enum ImapAuthRes imap_auth_cram_md5 ( struct ImapData * idata , const char * method ) {\n char ibuf [ LONG_STRING * 2 ] , obuf [ LONG_STRING ] ;\n unsigned char hmac_response [ MD5_DIGEST_LEN ] ;\n int len ;\n int rc ;\n if ( ! mutt_bit_isset ( idata -> capabilities , ACRAM_MD5 ) ) return IMAP_AUTH_UNAVAIL ;\n mutt_message ( _ ( \"Authenticating (CRAM-MD5)...\" ) ) ;\n if ( mutt_account_getlogin ( & idata -> conn -> account ) < 0 ) return IMAP_AUTH_FAILURE ;\n if ( mutt_account_getpass ( & idata -> conn -> account ) < 0 ) return IMAP_AUTH_FAILURE ;\n imap_cmd_start ( idata , \"AUTHENTICATE CRAM-MD5\" ) ;\n do rc = imap_cmd_step ( idata ) ;\n while ( rc == IMAP_CMD_CONTINUE ) ;\n if ( rc != IMAP_CMD_RESPOND ) {\n mutt_debug ( 1 , \"Invalid response from server: %s\\n\" , ibuf ) ;\n goto bail ;\n }\n len = mutt_b64_decode ( obuf , idata -> buf + 2 ) ;\n if ( len == - 1 ) {\n mutt_debug ( 1 , \"Error decoding base64 response.\\n\" ) ;\n goto bail ;\n }\n obuf [ len ] = '\\0' ;\n mutt_debug ( 2 , \"CRAM challenge: %s\\n\" , obuf ) ;\n hmac_md5 ( idata -> conn -> account . pass , obuf , hmac_response ) ;\n int off = snprintf ( obuf , sizeof ( obuf ) , \"%s \" , idata -> conn -> account . user ) ;\n mutt_md5_toascii ( hmac_response , obuf + off ) ;\n mutt_debug ( 2 , \"CRAM response: %s\\n\" , obuf ) ;\n mutt_b64_encode ( ibuf , obuf , strlen ( obuf ) , sizeof ( ibuf ) - 2 ) ;\n mutt_str_strcat ( ibuf , sizeof ( ibuf ) , \"\\r\\n\" ) ;\n mutt_socket_send ( idata -> conn , ibuf ) ;\n do rc = imap_cmd_step ( idata ) ;\n while ( rc == IMAP_CMD_CONTINUE ) ;\n if ( rc != IMAP_CMD_OK ) {\n mutt_debug ( 1 , \"Error receiving server response.\\n\" ) ;\n goto bail ;\n }\n if ( imap_code ( idata -> buf ) ) return IMAP_AUTH_SUCCESS ;\n bail : mutt_error ( _ ( \"CRAM-MD5 authentication failed.\" ) ) ;\n return IMAP_AUTH_FAILURE ;\n }", "idx": 1354}
{"hash": 5611940141018433728, "project": "chrome", "size": 28, "label": 0, "functionSource": "static void write_ref_frames ( const VP9_COMMON * cm , const MACROBLOCKD * xd , vp9_writer * w ) {\n const MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] . src_mi -> mbmi ;\n const int is_compound = has_second_ref ( mbmi ) ;\n const int segment_id = mbmi -> segment_id ;\n if ( vp9_segfeature_active ( & cm -> seg , segment_id , SEG_LVL_REF_FRAME ) ) {\n assert ( ! is_compound ) ;\n assert ( mbmi -> ref_frame [ 0 ] == vp9_get_segdata ( & cm -> seg , segment_id , SEG_LVL_REF_FRAME ) ) ;\n }\n else {\n if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) {\n vp9_write ( w , is_compound , vp9_get_reference_mode_prob ( cm , xd ) ) ;\n }\n else {\n assert ( ! is_compound == ( cm -> reference_mode == SINGLE_REFERENCE ) ) ;\n }\n if ( is_compound ) {\n vp9_write ( w , mbmi -> ref_frame [ 0 ] == GOLDEN_FRAME , vp9_get_pred_prob_comp_ref_p ( cm , xd ) ) ;\n }\n else {\n const int bit0 = mbmi -> ref_frame [ 0 ] != LAST_FRAME ;\n vp9_write ( w , bit0 , vp9_get_pred_prob_single_ref_p1 ( cm , xd ) ) ;\n if ( bit0 ) {\n const int bit1 = mbmi -> ref_frame [ 0 ] != GOLDEN_FRAME ;\n vp9_write ( w , bit1 , vp9_get_pred_prob_single_ref_p2 ( cm , xd ) ) ;\n }\n }\n }\n }", "idx": 1355}
{"hash": -7248963932691286231, "project": "debian", "size": 6, "label": 0, "functionSource": "static void destroy_server ( struct server * server ) {\n if ( server -> method ) ss_free ( server -> method ) ;\n if ( server -> plugin ) ss_free ( server -> plugin ) ;\n if ( server -> plugin_opts ) ss_free ( server -> plugin_opts ) ;\n if ( server -> mode ) ss_free ( server -> mode ) ;\n }", "idx": 1356}
{"hash": -4106680724983638989, "project": "chrome", "size": 41, "label": 1, "functionSource": "static unsigned int read_sbr_header ( SpectralBandReplication * sbr , GetBitContext * gb ) {\n unsigned int cnt = get_bits_count ( gb ) ;\n uint8_t bs_header_extra_1 ;\n uint8_t bs_header_extra_2 ;\n int old_bs_limiter_bands = sbr -> bs_limiter_bands ;\n SpectrumParameters old_spectrum_params ;\n sbr -> start = 1 ;\n memcpy ( & old_spectrum_params , & sbr -> spectrum_params , sizeof ( SpectrumParameters ) ) ;\n sbr -> bs_amp_res_header = get_bits1 ( gb ) ;\n sbr -> spectrum_params . bs_start_freq = get_bits ( gb , 4 ) ;\n sbr -> spectrum_params . bs_stop_freq = get_bits ( gb , 4 ) ;\n sbr -> spectrum_params . bs_xover_band = get_bits ( gb , 3 ) ;\n skip_bits ( gb , 2 ) ;\n bs_header_extra_1 = get_bits1 ( gb ) ;\n bs_header_extra_2 = get_bits1 ( gb ) ;\n if ( bs_header_extra_1 ) {\n sbr -> spectrum_params . bs_freq_scale = get_bits ( gb , 2 ) ;\n sbr -> spectrum_params . bs_alter_scale = get_bits1 ( gb ) ;\n sbr -> spectrum_params . bs_noise_bands = get_bits ( gb , 2 ) ;\n }\n else {\n sbr -> spectrum_params . bs_freq_scale = 2 ;\n sbr -> spectrum_params . bs_alter_scale = 1 ;\n sbr -> spectrum_params . bs_noise_bands = 2 ;\n }\n if ( memcmp ( & old_spectrum_params , & sbr -> spectrum_params , sizeof ( SpectrumParameters ) ) ) sbr -> reset = 1 ;\n if ( bs_header_extra_2 ) {\n sbr -> bs_limiter_bands = get_bits ( gb , 2 ) ;\n sbr -> bs_limiter_gains = get_bits ( gb , 2 ) ;\n sbr -> bs_interpol_freq = get_bits1 ( gb ) ;\n sbr -> bs_smoothing_mode = get_bits1 ( gb ) ;\n }\n else {\n sbr -> bs_limiter_bands = 2 ;\n sbr -> bs_limiter_gains = 2 ;\n sbr -> bs_interpol_freq = 1 ;\n sbr -> bs_smoothing_mode = 1 ;\n }\n if ( sbr -> bs_limiter_bands != old_bs_limiter_bands && ! sbr -> reset ) sbr_make_f_tablelim ( sbr ) ;\n return get_bits_count ( gb ) - cnt ;\n }", "idx": 1357}
{"hash": -305162769887579921, "project": "debian", "size": 11, "label": 0, "functionSource": "static void MPV_encode_defaults ( MpegEncContext * s ) {\n int i ;\n ff_MPV_common_defaults ( s ) ;\n for ( i = - 16 ;\n i < 16 ;\n i ++ ) {\n default_fcode_tab [ i + MAX_MV ] = 1 ;\n }\n s -> me . mv_penalty = default_mv_penalty ;\n s -> fcode_tab = default_fcode_tab ;\n }", "idx": 1358}
{"hash": 373189235956416317, "project": "debian", "size": 53, "label": 0, "functionSource": "static gint64 ascend_seek ( wtap * wth , int * err , gchar * * err_info ) {\n int byte ;\n gint64 date_off = - 1 , cur_off , packet_off ;\n size_t string_level [ ASCEND_MAGIC_STRINGS ] ;\n guint string_i = 0 , type = 0 ;\n guint excessive_read_count = 262144 ;\n memset ( & string_level , 0 , sizeof ( string_level ) ) ;\n while ( ( ( byte = file_getc ( wth -> fh ) ) != EOF ) ) {\n excessive_read_count -- ;\n if ( ! excessive_read_count ) {\n * err = 0 ;\n return - 1 ;\n }\n for ( string_i = 0 ;\n string_i < ASCEND_MAGIC_STRINGS ;\n string_i ++ ) {\n const gchar * strptr = ascend_magic [ string_i ] . strptr ;\n size_t len = strlen ( strptr ) ;\n if ( byte == * ( strptr + string_level [ string_i ] ) ) {\n string_level [ string_i ] ++ ;\n if ( string_level [ string_i ] >= len ) {\n cur_off = file_tell ( wth -> fh ) ;\n if ( cur_off == - 1 ) {\n * err = file_error ( wth -> fh , err_info ) ;\n return - 1 ;\n }\n if ( strcmp ( strptr , ASCEND_DATE ) == 0 ) {\n date_off = cur_off - len ;\n string_level [ string_i ] = 0 ;\n }\n else {\n if ( date_off == - 1 ) {\n packet_off = cur_off - len ;\n }\n else {\n packet_off = date_off ;\n }\n type = ascend_magic [ string_i ] . type ;\n goto found ;\n }\n }\n }\n else {\n string_level [ string_i ] = 0 ;\n }\n }\n }\n * err = file_error ( wth -> fh , err_info ) ;\n return - 1 ;\n found : if ( file_seek ( wth -> fh , packet_off , SEEK_SET , err ) == - 1 ) return - 1 ;\n wth -> phdr . pseudo_header . ascend . type = type ;\n return packet_off ;\n }", "idx": 1359}
{"hash": 1366214969540455677, "project": "debian", "size": 14, "label": 0, "functionSource": "static int ssl_check_srp_ext_ClientHello ( SSL * s , int * al ) {\n int ret = SSL_ERROR_NONE ;\n * al = SSL_AD_UNRECOGNIZED_NAME ;\n if ( ( s -> s3 -> tmp . new_cipher -> algorithm_mkey & SSL_kSRP ) && ( s -> srp_ctx . TLS_ext_srp_username_callback != NULL ) ) {\n if ( s -> srp_ctx . login == NULL ) {\n ret = SSL3_AL_FATAL ;\n * al = SSL_AD_UNKNOWN_PSK_IDENTITY ;\n }\n else {\n ret = SSL_srp_server_param_with_username ( s , al ) ;\n }\n }\n return ret ;\n }", "idx": 1360}
{"hash": -331579171381918893, "project": "debian", "size": 11, "label": 0, "functionSource": "static SRP_user_pwd * srp_user_pwd_dup ( SRP_user_pwd * src ) {\n SRP_user_pwd * ret ;\n if ( src == NULL ) return NULL ;\n if ( ( ret = SRP_user_pwd_new ( ) ) == NULL ) return NULL ;\n SRP_user_pwd_set_gN ( ret , src -> g , src -> N ) ;\n if ( ! SRP_user_pwd_set_ids ( ret , src -> id , src -> info ) || ! SRP_user_pwd_set_sv_BN ( ret , BN_dup ( src -> s ) , BN_dup ( src -> v ) ) ) {\n SRP_user_pwd_free ( ret ) ;\n return NULL ;\n }\n return ret ;\n }", "idx": 1361}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_H2250MaximumSkewIndication ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_H2250MaximumSkewIndication , H2250MaximumSkewIndication_sequence ) ;\n return offset ;\n }", "idx": 1362}
{"hash": 6302861533225984845, "project": "debian", "size": 36, "label": 0, "functionSource": "static int pxa2xx_pwrmode_write ( CPUARMState * env , const ARMCPRegInfo * ri , uint64_t value ) {\n PXA2xxState * s = ( PXA2xxState * ) ri -> opaque ;\n static const char * pwrmode [ 8 ] = {\n \"Normal\" , \"Idle\" , \"Deep-idle\" , \"Standby\" , \"Sleep\" , \"reserved (!)\" , \"reserved (!)\" , \"Deep-sleep\" , }\n ;\n if ( value & 8 ) {\n printf ( \"%s: CPU voltage change attempt\\n\" , __func__ ) ;\n }\n switch ( value & 7 ) {\n case 0 : break ;\n case 1 : if ( ! ( s -> cm_regs [ CCCR >> 2 ] & ( 1 << 31 ) ) ) {\n cpu_interrupt ( CPU ( s -> cpu ) , CPU_INTERRUPT_HALT ) ;\n break ;\n }\n case 2 : cpu_interrupt ( CPU ( s -> cpu ) , CPU_INTERRUPT_HALT ) ;\n s -> pm_regs [ RCSR >> 2 ] |= 0x8 ;\n goto message ;\n case 3 : s -> cpu -> env . uncached_cpsr = ARM_CPU_MODE_SVC | CPSR_A | CPSR_F | CPSR_I ;\n s -> cpu -> env . cp15 . c1_sys = 0 ;\n s -> cpu -> env . cp15 . c1_coproc = 0 ;\n s -> cpu -> env . cp15 . c2_base0 = 0 ;\n s -> cpu -> env . cp15 . c3 = 0 ;\n s -> pm_regs [ PSSR >> 2 ] |= 0x8 ;\n s -> pm_regs [ RCSR >> 2 ] |= 0x8 ;\n memset ( s -> cpu -> env . regs , 0 , 4 * 15 ) ;\n s -> cpu -> env . regs [ 15 ] = s -> pm_regs [ PSPR >> 2 ] ;\n # if 0 buffer = 0xe59ff000 ;\n cpu_physical_memory_write ( 0 , & buffer , 4 ) ;\n buffer = s -> pm_regs [ PSPR >> 2 ] ;\n cpu_physical_memory_write ( 8 , & buffer , 4 ) ;\n # endif cpu_interrupt ( current_cpu , CPU_INTERRUPT_HALT ) ;\n goto message ;\n default : message : printf ( \"%s: machine entered %s mode\\n\" , __func__ , pwrmode [ value & 7 ] ) ;\n }\n return 0 ;\n }", "idx": 1363}
{"hash": -3062453801436404700, "project": "debian", "size": 5, "label": 0, "functionSource": "void dtls1_double_timeout ( SSL * s ) {\n s -> d1 -> timeout_duration *= 2 ;\n if ( s -> d1 -> timeout_duration > 60 ) s -> d1 -> timeout_duration = 60 ;\n dtls1_start_timer ( s ) ;\n }", "idx": 1364}
{"hash": -6442559759273439153, "project": "debian", "size": 12, "label": 0, "functionSource": "static void arith2_normalise ( ArithCoder * c ) {\n while ( ( c -> high >> 15 ) - ( c -> low >> 15 ) < 2 ) {\n if ( ( c -> low ^ c -> high ) & 0x10000 ) {\n c -> high ^= 0x8000 ;\n c -> value ^= 0x8000 ;\n c -> low ^= 0x8000 ;\n }\n c -> high = c -> high << 8 & 0xFFFFFF | 0xFF ;\n c -> value = c -> value << 8 & 0xFFFFFF | bytestream2_get_byte ( c -> gbc . gB ) ;\n c -> low = c -> low << 8 & 0xFFFFFF ;\n }\n }", "idx": 1365}
{"hash": 5360072031850965731, "project": "debian", "size": 6, "label": 1, "functionSource": "static void cpu_request_exit ( void * opaque , int irq , int level ) {\n CPUPPCState * env = cpu_single_env ;\n if ( env && level ) {\n cpu_exit ( CPU ( ppc_env_get_cpu ( env ) ) ) ;\n }\n }", "idx": 1366}
{"hash": -8228664527580018723, "project": "debian", "size": 186, "label": 0, "functionSource": "static int dprintf_Pass1 ( const char * format , va_stack_t * vto , char * * endpos , va_list arglist ) {\n char * fmt = ( char * ) format ;\n int param_num = 0 ;\n long this_param ;\n long width ;\n long precision ;\n int flags ;\n long max_param = 0 ;\n long i ;\n while ( * fmt ) {\n if ( * fmt ++ == '%' ) {\n if ( * fmt == '%' ) {\n fmt ++ ;\n continue ;\n }\n flags = FLAGS_NEW ;\n param_num ++ ;\n this_param = dprintf_DollarString ( fmt , & fmt ) ;\n if ( 0 == this_param ) this_param = param_num ;\n if ( this_param > max_param ) max_param = this_param ;\n width = 0 ;\n precision = 0 ;\n while ( dprintf_IsQualifierNoDollar ( fmt ) ) {\n # if defined ( MP_HAVE_INT_EXTENSIONS ) if ( ! strncmp ( fmt , \"I32\" , 3 ) ) {\n flags |= FLAGS_LONG ;\n fmt += 3 ;\n }\n else if ( ! strncmp ( fmt , \"I64\" , 3 ) ) {\n flags |= FLAGS_LONGLONG ;\n fmt += 3 ;\n }\n else # endif switch ( * fmt ++ ) {\n case ' ' : flags |= FLAGS_SPACE ;\n break ;\n case '+' : flags |= FLAGS_SHOWSIGN ;\n break ;\n case '-' : flags |= FLAGS_LEFT ;\n flags &= ~ FLAGS_PAD_NIL ;\n break ;\n case '#' : flags |= FLAGS_ALT ;\n break ;\n case '.' : flags |= FLAGS_PREC ;\n if ( '*' == * fmt ) {\n flags |= FLAGS_PRECPARAM ;\n fmt ++ ;\n param_num ++ ;\n i = dprintf_DollarString ( fmt , & fmt ) ;\n if ( i ) precision = i ;\n else precision = param_num ;\n if ( precision > max_param ) max_param = precision ;\n }\n else {\n flags |= FLAGS_PREC ;\n precision = strtol ( fmt , & fmt , 10 ) ;\n }\n break ;\n case 'h' : flags |= FLAGS_SHORT ;\n break ;\n # if defined ( MP_HAVE_INT_EXTENSIONS ) case 'I' : # if ( CURL_SIZEOF_CURL_OFF_T > CURL_SIZEOF_LONG ) flags |= FLAGS_LONGLONG ;\n # else flags |= FLAGS_LONG ;\n # endif break ;\n # endif case 'l' : if ( flags & FLAGS_LONG ) flags |= FLAGS_LONGLONG ;\n else flags |= FLAGS_LONG ;\n break ;\n case 'L' : flags |= FLAGS_LONGDOUBLE ;\n break ;\n case 'q' : flags |= FLAGS_LONGLONG ;\n break ;\n case 'z' : # if ( SIZEOF_SIZE_T > CURL_SIZEOF_LONG ) flags |= FLAGS_LONGLONG ;\n # else flags |= FLAGS_LONG ;\n # endif break ;\n case 'O' : # if ( CURL_SIZEOF_CURL_OFF_T > CURL_SIZEOF_LONG ) flags |= FLAGS_LONGLONG ;\n # else flags |= FLAGS_LONG ;\n # endif break ;\n case '0' : if ( ! ( flags & FLAGS_LEFT ) ) flags |= FLAGS_PAD_NIL ;\n case '1' : case '2' : case '3' : case '4' : case '5' : case '6' : case '7' : case '8' : case '9' : flags |= FLAGS_WIDTH ;\n width = strtol ( fmt - 1 , & fmt , 10 ) ;\n break ;\n case '*' : flags |= FLAGS_WIDTHPARAM ;\n param_num ++ ;\n i = dprintf_DollarString ( fmt , & fmt ) ;\n if ( i ) width = i ;\n else width = param_num ;\n if ( width > max_param ) max_param = width ;\n break ;\n default : break ;\n }\n }\n i = this_param - 1 ;\n if ( ( i < 0 ) || ( i >= MAX_PARAMETERS ) ) return 1 ;\n switch ( * fmt ) {\n case 'S' : flags |= FLAGS_ALT ;\n case 's' : vto [ i ] . type = FORMAT_STRING ;\n break ;\n case 'n' : vto [ i ] . type = FORMAT_INTPTR ;\n break ;\n case 'p' : vto [ i ] . type = FORMAT_PTR ;\n break ;\n case 'd' : case 'i' : vto [ i ] . type = FORMAT_INT ;\n break ;\n case 'u' : vto [ i ] . type = FORMAT_INT ;\n flags |= FLAGS_UNSIGNED ;\n break ;\n case 'o' : vto [ i ] . type = FORMAT_INT ;\n flags |= FLAGS_OCTAL ;\n break ;\n case 'x' : vto [ i ] . type = FORMAT_INT ;\n flags |= FLAGS_HEX | FLAGS_UNSIGNED ;\n break ;\n case 'X' : vto [ i ] . type = FORMAT_INT ;\n flags |= FLAGS_HEX | FLAGS_UPPER | FLAGS_UNSIGNED ;\n break ;\n case 'c' : vto [ i ] . type = FORMAT_INT ;\n flags |= FLAGS_CHAR ;\n break ;\n case 'f' : vto [ i ] . type = FORMAT_DOUBLE ;\n break ;\n case 'e' : vto [ i ] . type = FORMAT_DOUBLE ;\n flags |= FLAGS_FLOATE ;\n break ;\n case 'E' : vto [ i ] . type = FORMAT_DOUBLE ;\n flags |= FLAGS_FLOATE | FLAGS_UPPER ;\n break ;\n case 'g' : vto [ i ] . type = FORMAT_DOUBLE ;\n flags |= FLAGS_FLOATG ;\n break ;\n case 'G' : vto [ i ] . type = FORMAT_DOUBLE ;\n flags |= FLAGS_FLOATG | FLAGS_UPPER ;\n break ;\n default : vto [ i ] . type = FORMAT_UNKNOWN ;\n break ;\n }\n vto [ i ] . flags = flags ;\n vto [ i ] . width = width ;\n vto [ i ] . precision = precision ;\n if ( flags & FLAGS_WIDTHPARAM ) {\n long k = width - 1 ;\n vto [ i ] . width = k ;\n vto [ k ] . type = FORMAT_WIDTH ;\n vto [ k ] . flags = FLAGS_NEW ;\n vto [ k ] . width = 0 ;\n vto [ k ] . precision = 0 ;\n }\n if ( flags & FLAGS_PRECPARAM ) {\n long k = precision - 1 ;\n vto [ i ] . precision = k ;\n vto [ k ] . type = FORMAT_WIDTH ;\n vto [ k ] . flags = FLAGS_NEW ;\n vto [ k ] . width = 0 ;\n vto [ k ] . precision = 0 ;\n }\n * endpos ++ = fmt + 1 ;\n }\n }\n for ( i = 0 ;\n i < max_param ;\n i ++ ) {\n if ( vto [ i ] . flags & FLAGS_WIDTHPARAM ) {\n vto [ vto [ i ] . width ] . data . num . as_signed = ( mp_intmax_t ) va_arg ( arglist , int ) ;\n }\n if ( vto [ i ] . flags & FLAGS_PRECPARAM ) {\n vto [ vto [ i ] . precision ] . data . num . as_signed = ( mp_intmax_t ) va_arg ( arglist , int ) ;\n }\n switch ( vto [ i ] . type ) {\n case FORMAT_STRING : vto [ i ] . data . str = va_arg ( arglist , char * ) ;\n break ;\n case FORMAT_INTPTR : case FORMAT_UNKNOWN : case FORMAT_PTR : vto [ i ] . data . ptr = va_arg ( arglist , void * ) ;\n break ;\n case FORMAT_INT : # ifdef HAVE_LONG_LONG_TYPE if ( ( vto [ i ] . flags & FLAGS_LONGLONG ) && ( vto [ i ] . flags & FLAGS_UNSIGNED ) ) vto [ i ] . data . num . as_unsigned = ( mp_uintmax_t ) va_arg ( arglist , mp_uintmax_t ) ;\n else if ( vto [ i ] . flags & FLAGS_LONGLONG ) vto [ i ] . data . num . as_signed = ( mp_intmax_t ) va_arg ( arglist , mp_intmax_t ) ;\n else # endif {\n if ( ( vto [ i ] . flags & FLAGS_LONG ) && ( vto [ i ] . flags & FLAGS_UNSIGNED ) ) vto [ i ] . data . num . as_unsigned = ( mp_uintmax_t ) va_arg ( arglist , unsigned long ) ;\n else if ( vto [ i ] . flags & FLAGS_LONG ) vto [ i ] . data . num . as_signed = ( mp_intmax_t ) va_arg ( arglist , long ) ;\n else if ( vto [ i ] . flags & FLAGS_UNSIGNED ) vto [ i ] . data . num . as_unsigned = ( mp_uintmax_t ) va_arg ( arglist , unsigned int ) ;\n else vto [ i ] . data . num . as_signed = ( mp_intmax_t ) va_arg ( arglist , int ) ;\n }\n break ;\n case FORMAT_DOUBLE : vto [ i ] . data . dnum = va_arg ( arglist , double ) ;\n break ;\n case FORMAT_WIDTH : vto [ i ] . type = FORMAT_INT ;\n break ;\n default : break ;\n }\n }\n return 0 ;\n }", "idx": 1367}
{"hash": -3086035825515629592, "project": "debian", "size": 123, "label": 0, "functionSource": "static int inflate ( struct mszipd_stream * zip ) {\n unsigned int last_block , block_type , distance , length , this_run , i ;\n register unsigned int bit_buffer ;\n register int bits_left ;\n register unsigned short sym ;\n unsigned char * i_ptr , * i_end ;\n RESTORE_BITS ;\n do {\n READ_BITS ( last_block , 1 ) ;\n READ_BITS ( block_type , 2 ) ;\n if ( block_type == 0 ) {\n unsigned char lens_buf [ 4 ] ;\n i = bits_left & 7 ;\n REMOVE_BITS ( i ) ;\n for ( i = 0 ;\n ( bits_left >= 8 ) ;\n i ++ ) {\n if ( i == 4 ) return INF_ERR_BITBUF ;\n lens_buf [ i ] = PEEK_BITS ( 8 ) ;\n REMOVE_BITS ( 8 ) ;\n }\n if ( bits_left != 0 ) return INF_ERR_BITBUF ;\n while ( i < 4 ) {\n READ_IF_NEEDED ;\n lens_buf [ i ++ ] = * i_ptr ++ ;\n }\n length = lens_buf [ 0 ] | ( lens_buf [ 1 ] << 8 ) ;\n i = lens_buf [ 2 ] | ( lens_buf [ 3 ] << 8 ) ;\n if ( length != ( ~ i & 0xFFFF ) ) return INF_ERR_COMPLEMENT ;\n while ( length > 0 ) {\n READ_IF_NEEDED ;\n this_run = length ;\n if ( this_run > ( unsigned int ) ( i_end - i_ptr ) ) this_run = i_end - i_ptr ;\n if ( this_run > ( MSZIP_FRAME_SIZE - zip -> window_posn ) ) this_run = MSZIP_FRAME_SIZE - zip -> window_posn ;\n zip -> sys -> copy ( i_ptr , & zip -> window [ zip -> window_posn ] , this_run ) ;\n zip -> window_posn += this_run ;\n i_ptr += this_run ;\n length -= this_run ;\n FLUSH_IF_NEEDED ;\n }\n }\n else if ( ( block_type == 1 ) || ( block_type == 2 ) ) {\n unsigned int match_posn , code ;\n if ( block_type == 1 ) {\n i = 0 ;\n while ( i < 144 ) zip -> LITERAL_len [ i ++ ] = 8 ;\n while ( i < 256 ) zip -> LITERAL_len [ i ++ ] = 9 ;\n while ( i < 280 ) zip -> LITERAL_len [ i ++ ] = 7 ;\n while ( i < 288 ) zip -> LITERAL_len [ i ++ ] = 8 ;\n for ( i = 0 ;\n i < 32 ;\n i ++ ) zip -> DISTANCE_len [ i ] = 5 ;\n }\n else {\n STORE_BITS ;\n if ( ( i = zip_read_lens ( zip ) ) ) return i ;\n RESTORE_BITS ;\n }\n if ( make_decode_table ( MSZIP_LITERAL_MAXSYMBOLS , MSZIP_LITERAL_TABLEBITS , & zip -> LITERAL_len [ 0 ] , & zip -> LITERAL_table [ 0 ] ) ) {\n return INF_ERR_LITERALTBL ;\n }\n if ( make_decode_table ( MSZIP_DISTANCE_MAXSYMBOLS , MSZIP_DISTANCE_TABLEBITS , & zip -> DISTANCE_len [ 0 ] , & zip -> DISTANCE_table [ 0 ] ) ) {\n return INF_ERR_DISTANCETBL ;\n }\n for ( ;\n ;\n ) {\n READ_HUFFSYM ( LITERAL , code ) ;\n if ( code < 256 ) {\n zip -> window [ zip -> window_posn ++ ] = ( unsigned char ) code ;\n FLUSH_IF_NEEDED ;\n }\n else if ( code == 256 ) {\n break ;\n }\n else {\n code -= 257 ;\n if ( code >= 29 ) return INF_ERR_LITCODE ;\n READ_BITS_T ( length , lit_extrabits [ code ] ) ;\n length += lit_lengths [ code ] ;\n READ_HUFFSYM ( DISTANCE , code ) ;\n if ( code >= 30 ) return INF_ERR_DISTCODE ;\n READ_BITS_T ( distance , dist_extrabits [ code ] ) ;\n distance += dist_offsets [ code ] ;\n match_posn = ( ( distance > zip -> window_posn ) ? MSZIP_FRAME_SIZE : 0 ) + zip -> window_posn - distance ;\n if ( length < 12 ) {\n while ( length -- ) {\n zip -> window [ zip -> window_posn ++ ] = zip -> window [ match_posn ++ ] ;\n match_posn &= MSZIP_FRAME_SIZE - 1 ;\n FLUSH_IF_NEEDED ;\n }\n }\n else {\n unsigned char * runsrc , * rundest ;\n do {\n this_run = length ;\n if ( ( match_posn + this_run ) > MSZIP_FRAME_SIZE ) this_run = MSZIP_FRAME_SIZE - match_posn ;\n if ( ( zip -> window_posn + this_run ) > MSZIP_FRAME_SIZE ) this_run = MSZIP_FRAME_SIZE - zip -> window_posn ;\n rundest = & zip -> window [ zip -> window_posn ] ;\n zip -> window_posn += this_run ;\n runsrc = & zip -> window [ match_posn ] ;\n match_posn += this_run ;\n length -= this_run ;\n while ( this_run -- ) * rundest ++ = * runsrc ++ ;\n if ( match_posn == MSZIP_FRAME_SIZE ) match_posn = 0 ;\n FLUSH_IF_NEEDED ;\n }\n while ( length > 0 ) ;\n }\n }\n }\n }\n else {\n return INF_ERR_BLOCKTYPE ;\n }\n }\n while ( ! last_block ) ;\n if ( zip -> window_posn ) {\n if ( zip -> flush_window ( zip , zip -> window_posn ) ) return INF_ERR_FLUSH ;\n }\n STORE_BITS ;\n return 0 ;\n }", "idx": 1368}
{"hash": 2930500905204315787, "project": "debian", "size": 3, "label": 1, "functionSource": "static __always_inline __u64 __le64_to_cpup ( const __le64 * p ) {\n return ( __u64 ) * p ;\n }", "idx": 1369}
{"hash": -1483849844579170895, "project": "chrome", "size": 8, "label": 0, "functionSource": "static void update_quantizer_histogram ( struct stream_state * stream ) {\n if ( stream -> config . cfg . g_pass != VPX_RC_FIRST_PASS ) {\n int q ;\n vpx_codec_control ( & stream -> encoder , VP8E_GET_LAST_QUANTIZER_64 , & q ) ;\n ctx_exit_on_error ( & stream -> encoder , \"Failed to read quantizer\" ) ;\n stream -> counts [ q ] ++ ;\n }\n }", "idx": 1370}
{"hash": -5268859819325807498, "project": "debian", "size": 5, "label": 0, "functionSource": "static void cancel_link_info_for_file ( NautilusDirectory * directory , NautilusFile * file ) {\n if ( directory -> details -> link_info_read_state != NULL && directory -> details -> link_info_read_state -> file == file ) {\n link_info_cancel ( directory ) ;\n }\n }", "idx": 1371}
{"hash": -3559021711340554904, "project": "debian", "size": 5, "label": 0, "functionSource": "bool has_parallel_hazard ( Node * node , bool allow_restricted ) {\n has_parallel_hazard_arg context ;\n context . allow_restricted = allow_restricted ;\n return has_parallel_hazard_walker ( node , & context ) ;\n }", "idx": 1372}
{"hash": -4555950263653671147, "project": "debian", "size": 23, "label": 0, "functionSource": "static PyObject * string_zfill ( PyStringObject * self , PyObject * args ) {\n Py_ssize_t fill ;\n PyObject * s ;\n char * p ;\n Py_ssize_t width ;\n if ( ! PyArg_ParseTuple ( args , \"n:zfill\" , & width ) ) return NULL ;\n if ( PyString_GET_SIZE ( self ) >= width ) {\n if ( PyString_CheckExact ( self ) ) {\n Py_INCREF ( self ) ;\n return ( PyObject * ) self ;\n }\n else return PyString_FromStringAndSize ( PyString_AS_STRING ( self ) , PyString_GET_SIZE ( self ) ) ;\n }\n fill = width - PyString_GET_SIZE ( self ) ;\n s = pad ( self , fill , 0 , '0' ) ;\n if ( s == NULL ) return NULL ;\n p = PyString_AS_STRING ( s ) ;\n if ( p [ fill ] == '+' || p [ fill ] == '-' ) {\n p [ 0 ] = p [ fill ] ;\n p [ fill ] = '0' ;\n }\n return ( PyObject * ) s ;\n }", "idx": 1373}
{"hash": -6391176401823500141, "project": "debian", "size": 18, "label": 0, "functionSource": "DEFINE_TEST ( test_read_format_mtree_nonexistent_contents_file ) {\n static char archive [ ] = \"#mtree\\n\" \"a type=file contents=nonexistent_file\\n\" ;\n struct archive_entry * ae ;\n struct archive * a ;\n assert ( ( a = archive_read_new ( ) ) != NULL ) ;\n assertEqualIntA ( a , ARCHIVE_OK , archive_read_support_filter_all ( a ) ) ;\n assertEqualIntA ( a , ARCHIVE_OK , archive_read_support_format_all ( a ) ) ;\n assertEqualIntA ( a , ARCHIVE_OK , archive_read_set_options ( a , \"mtree:checkfs\" ) ) ;\n assertEqualIntA ( a , ARCHIVE_OK , archive_read_open_memory ( a , archive , sizeof ( archive ) ) ) ;\n assertEqualIntA ( a , ARCHIVE_WARN , archive_read_next_header ( a , & ae ) ) ;\n assert ( strlen ( archive_error_string ( a ) ) > 0 ) ;\n assertEqualString ( archive_entry_pathname ( ae ) , \"a\" ) ;\n assertEqualInt ( archive_entry_filetype ( ae ) , AE_IFREG ) ;\n assertEqualIntA ( a , ARCHIVE_EOF , archive_read_next_header ( a , & ae ) ) ;\n assertEqualInt ( 1 , archive_file_count ( a ) ) ;\n assertEqualInt ( ARCHIVE_OK , archive_read_close ( a ) ) ;\n assertEqualInt ( ARCHIVE_OK , archive_read_free ( a ) ) ;\n }", "idx": 1374}
{"hash": -7434014980763120366, "project": "debian", "size": 9, "label": 0, "functionSource": "int dissect_ber_octet_string_wcb ( gboolean implicit_tag , asn1_ctx_t * actx , proto_tree * tree , tvbuff_t * tvb , int offset , gint hf_id , ber_callback func ) {\n tvbuff_t * out_tvb = NULL ;\n offset = dissect_ber_octet_string ( implicit_tag , actx , tree , tvb , offset , hf_id , ( func ) ? & out_tvb : NULL ) ;\n if ( func && out_tvb && ( tvb_reported_length ( out_tvb ) > 0 ) ) {\n if ( hf_id >= 0 ) tree = proto_item_add_subtree ( actx -> created_item , ett_ber_octet_string ) ;\n func ( FALSE , out_tvb , 0 , actx , tree , - 1 ) ;\n }\n return offset ;\n }", "idx": 1375}
{"hash": -2338718868165006846, "project": "chrome", "size": 38, "label": 0, "functionSource": "static int raw_read_frame ( FILE * infile , uint8_t * * buffer , size_t * bytes_read , size_t * buffer_size ) {\n char raw_hdr [ RAW_FRAME_HDR_SZ ] ;\n size_t frame_size = 0 ;\n if ( fread ( raw_hdr , RAW_FRAME_HDR_SZ , 1 , infile ) != 1 ) {\n if ( ! feof ( infile ) ) warn ( \"Failed to read RAW frame size\\n\" ) ;\n }\n else {\n const size_t kCorruptFrameThreshold = 256 * 1024 * 1024 ;\n const size_t kFrameTooSmallThreshold = 256 * 1024 ;\n frame_size = mem_get_le32 ( raw_hdr ) ;\n if ( frame_size > kCorruptFrameThreshold ) {\n warn ( \"Read invalid frame size (%u)\\n\" , ( unsigned int ) frame_size ) ;\n frame_size = 0 ;\n }\n if ( frame_size < kFrameTooSmallThreshold ) {\n warn ( \"Warning: Read invalid frame size (%u) - not a raw file?\\n\" , ( unsigned int ) frame_size ) ;\n }\n if ( frame_size > * buffer_size ) {\n uint8_t * new_buf = realloc ( * buffer , 2 * frame_size ) ;\n if ( new_buf ) {\n * buffer = new_buf ;\n * buffer_size = 2 * frame_size ;\n }\n else {\n warn ( \"Failed to allocate compressed data buffer\\n\" ) ;\n frame_size = 0 ;\n }\n }\n }\n if ( ! feof ( infile ) ) {\n if ( fread ( * buffer , 1 , frame_size , infile ) != frame_size ) {\n warn ( \"Failed to read full frame\\n\" ) ;\n return 1 ;\n }\n * bytes_read = frame_size ;\n }\n return 0 ;\n }", "idx": 1376}
{"hash": 8320716512483418415, "project": "chrome", "size": 26, "label": 0, "functionSource": "void vp9_idct32x32_34_add_c ( const tran_low_t * input , uint8_t * dest , int stride ) {\n tran_low_t out [ 32 * 32 ] = {\n 0 }\n ;\n tran_low_t * outptr = out ;\n int i , j ;\n tran_low_t temp_in [ 32 ] , temp_out [ 32 ] ;\n for ( i = 0 ;\n i < 8 ;\n ++ i ) {\n idct32 ( input , outptr ) ;\n input += 32 ;\n outptr += 32 ;\n }\n for ( i = 0 ;\n i < 32 ;\n ++ i ) {\n for ( j = 0 ;\n j < 32 ;\n ++ j ) temp_in [ j ] = out [ j * 32 + i ] ;\n idct32 ( temp_in , temp_out ) ;\n for ( j = 0 ;\n j < 32 ;\n ++ j ) dest [ j * stride + i ] = clip_pixel ( ROUND_POWER_OF_TWO ( temp_out [ j ] , 6 ) + dest [ j * stride + i ] ) ;\n }\n }", "idx": 1377}
{"hash": 6302861533225984845, "project": "debian", "size": 14, "label": 0, "functionSource": "static inline void pxa2xx_rtc_alarm_update ( PXA2xxRTCState * s , uint32_t rtsr ) {\n if ( ( rtsr & ( 1 << 2 ) ) && ! ( rtsr & ( 1 << 0 ) ) ) qemu_mod_timer ( s -> rtc_hz , s -> last_hz + ( ( ( s -> rtar - s -> last_rcnr ) * 1000 * ( ( s -> rttr & 0xffff ) + 1 ) ) >> 15 ) ) ;\n else qemu_del_timer ( s -> rtc_hz ) ;\n if ( ( rtsr & ( 1 << 5 ) ) && ! ( rtsr & ( 1 << 4 ) ) ) qemu_mod_timer ( s -> rtc_rdal1 , s -> last_hz + ( ( ( s -> rdar1 - s -> last_rdcr ) * 1000 * ( ( s -> rttr & 0xffff ) + 1 ) ) >> 15 ) ) ;\n else qemu_del_timer ( s -> rtc_rdal1 ) ;\n if ( ( rtsr & ( 1 << 7 ) ) && ! ( rtsr & ( 1 << 6 ) ) ) qemu_mod_timer ( s -> rtc_rdal2 , s -> last_hz + ( ( ( s -> rdar2 - s -> last_rdcr ) * 1000 * ( ( s -> rttr & 0xffff ) + 1 ) ) >> 15 ) ) ;\n else qemu_del_timer ( s -> rtc_rdal2 ) ;\n if ( ( rtsr & 0x1200 ) == 0x1200 && ! ( rtsr & ( 1 << 8 ) ) ) qemu_mod_timer ( s -> rtc_swal1 , s -> last_sw + ( s -> swar1 - s -> last_swcr ) * 10 ) ;\n else qemu_del_timer ( s -> rtc_swal1 ) ;\n if ( ( rtsr & 0x1800 ) == 0x1800 && ! ( rtsr & ( 1 << 10 ) ) ) qemu_mod_timer ( s -> rtc_swal2 , s -> last_sw + ( s -> swar2 - s -> last_swcr ) * 10 ) ;\n else qemu_del_timer ( s -> rtc_swal2 ) ;\n if ( ( rtsr & 0xc000 ) == 0xc000 && ! ( rtsr & ( 1 << 13 ) ) ) qemu_mod_timer ( s -> rtc_pi , s -> last_pi + ( s -> piar & 0xffff ) - s -> last_rtcpicr ) ;\n else qemu_del_timer ( s -> rtc_pi ) ;\n }", "idx": 1378}
{"hash": 2713698759296604855, "project": "debian", "size": 76, "label": 0, "functionSource": "int ff_mpeg_update_thread_context ( AVCodecContext * dst , const AVCodecContext * src ) {\n int i , ret ;\n MpegEncContext * s = dst -> priv_data , * s1 = src -> priv_data ;\n if ( dst == src || ! s1 -> context_initialized ) return 0 ;\n if ( ! s -> context_initialized ) {\n memcpy ( s , s1 , sizeof ( MpegEncContext ) ) ;\n s -> avctx = dst ;\n s -> bitstream_buffer = NULL ;\n s -> bitstream_buffer_size = s -> allocated_bitstream_buffer_size = 0 ;\n ff_MPV_common_init ( s ) ;\n }\n if ( s -> height != s1 -> height || s -> width != s1 -> width || s -> context_reinit ) {\n int err ;\n s -> context_reinit = 0 ;\n s -> height = s1 -> height ;\n s -> width = s1 -> width ;\n if ( ( err = ff_MPV_common_frame_size_change ( s ) ) < 0 ) return err ;\n }\n s -> avctx -> coded_height = s1 -> avctx -> coded_height ;\n s -> avctx -> coded_width = s1 -> avctx -> coded_width ;\n s -> avctx -> width = s1 -> avctx -> width ;\n s -> avctx -> height = s1 -> avctx -> height ;\n s -> coded_picture_number = s1 -> coded_picture_number ;\n s -> picture_number = s1 -> picture_number ;\n s -> input_picture_number = s1 -> input_picture_number ;\n for ( i = 0 ;\n i < MAX_PICTURE_COUNT ;\n i ++ ) {\n ff_mpeg_unref_picture ( s , & s -> picture [ i ] ) ;\n if ( s1 -> picture [ i ] . f . data [ 0 ] && ( ret = ff_mpeg_ref_picture ( s , & s -> picture [ i ] , & s1 -> picture [ i ] ) ) < 0 ) return ret ;\n }\n # define UPDATE_PICTURE ( pic ) do {\n ff_mpeg_unref_picture ( s , & s -> pic ) ;\n if ( s1 -> pic . f . data [ 0 ] ) ret = ff_mpeg_ref_picture ( s , & s -> pic , & s1 -> pic ) ;\n else ret = update_picture_tables ( & s -> pic , & s1 -> pic ) ;\n if ( ret < 0 ) return ret ;\n \\ }\n while ( 0 ) UPDATE_PICTURE ( current_picture ) ;\n UPDATE_PICTURE ( last_picture ) ;\n UPDATE_PICTURE ( next_picture ) ;\n s -> last_picture_ptr = REBASE_PICTURE ( s1 -> last_picture_ptr , s , s1 ) ;\n s -> current_picture_ptr = REBASE_PICTURE ( s1 -> current_picture_ptr , s , s1 ) ;\n s -> next_picture_ptr = REBASE_PICTURE ( s1 -> next_picture_ptr , s , s1 ) ;\n s -> next_p_frame_damaged = s1 -> next_p_frame_damaged ;\n s -> workaround_bugs = s1 -> workaround_bugs ;\n memcpy ( & s -> time_increment_bits , & s1 -> time_increment_bits , ( char * ) & s1 -> shape - ( char * ) & s1 -> time_increment_bits ) ;\n s -> max_b_frames = s1 -> max_b_frames ;\n s -> low_delay = s1 -> low_delay ;\n s -> droppable = s1 -> droppable ;\n s -> divx_packed = s1 -> divx_packed ;\n if ( s1 -> bitstream_buffer ) {\n if ( s1 -> bitstream_buffer_size + FF_INPUT_BUFFER_PADDING_SIZE > s -> allocated_bitstream_buffer_size ) av_fast_malloc ( & s -> bitstream_buffer , & s -> allocated_bitstream_buffer_size , s1 -> allocated_bitstream_buffer_size ) ;\n s -> bitstream_buffer_size = s1 -> bitstream_buffer_size ;\n memcpy ( s -> bitstream_buffer , s1 -> bitstream_buffer , s1 -> bitstream_buffer_size ) ;\n memset ( s -> bitstream_buffer + s -> bitstream_buffer_size , 0 , FF_INPUT_BUFFER_PADDING_SIZE ) ;\n }\n if ( ! s -> edge_emu_buffer ) if ( s1 -> linesize ) {\n if ( ff_mpv_frame_size_alloc ( s , s1 -> linesize ) < 0 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"Failed to allocate context \" \"scratch buffers.\\n\" ) ;\n return AVERROR ( ENOMEM ) ;\n }\n }\n else {\n av_log ( s -> avctx , AV_LOG_ERROR , \"Context scratch buffers could not \" \"be allocated due to unknown size.\\n\" ) ;\n return AVERROR_BUG ;\n }\n memcpy ( & s -> progressive_sequence , & s1 -> progressive_sequence , ( char * ) & s1 -> rtp_mode - ( char * ) & s1 -> progressive_sequence ) ;\n if ( ! s1 -> first_field ) {\n s -> last_pict_type = s1 -> pict_type ;\n if ( s1 -> current_picture_ptr ) s -> last_lambda_for [ s1 -> pict_type ] = s1 -> current_picture_ptr -> f . quality ;\n if ( s1 -> pict_type != AV_PICTURE_TYPE_B ) {\n s -> last_non_b_pict_type = s1 -> pict_type ;\n }\n }\n return 0 ;\n }", "idx": 1379}
{"hash": -1929262071302712016, "project": "debian", "size": 7, "label": 0, "functionSource": "static cmsBool WriteSeqID ( struct _cms_typehandler_struct * self , cmsIOHANDLER * io , void * Cargo , cmsUInt32Number n , cmsUInt32Number SizeOfTag ) {\n cmsSEQ * Seq = ( cmsSEQ * ) Cargo ;\n if ( ! io -> Write ( io , 16 , Seq -> seq [ n ] . ProfileID . ID8 ) ) return FALSE ;\n if ( ! SaveDescription ( self , io , Seq -> seq [ n ] . Description ) ) return FALSE ;\n return TRUE ;\n cmsUNUSED_PARAMETER ( SizeOfTag ) ;\n }", "idx": 1380}
{"hash": 5918484636148310736, "project": "debian", "size": 9, "label": 0, "functionSource": "void mem_get_initial_matrix ( gx_device * dev , gs_matrix * pmat ) {\n gx_device_memory * const mdev = ( gx_device_memory * ) dev ;\n pmat -> xx = mdev -> initial_matrix . xx ;\n pmat -> xy = mdev -> initial_matrix . xy ;\n pmat -> yx = mdev -> initial_matrix . yx ;\n pmat -> yy = mdev -> initial_matrix . yy ;\n pmat -> tx = mdev -> initial_matrix . tx ;\n pmat -> ty = mdev -> initial_matrix . ty ;\n }", "idx": 1381}
{"hash": 825216912438754622, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_t38_IFPPacket ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_t38_IFPPacket , IFPPacket_sequence ) ;\n return offset ;\n }", "idx": 1382}
{"hash": -7136186224744987223, "project": "debian", "size": 64, "label": 0, "functionSource": "CURLcode Curl_add_buffer_send ( Curl_send_buffer * in , struct connectdata * conn , long * bytes_written , size_t included_body_bytes , int socketindex ) {\n ssize_t amount ;\n CURLcode result ;\n char * ptr ;\n size_t size ;\n struct HTTP * http = conn -> data -> req . protop ;\n size_t sendsize ;\n curl_socket_t sockfd ;\n size_t headersize ;\n DEBUGASSERT ( socketindex <= SECONDARYSOCKET ) ;\n sockfd = conn -> sock [ socketindex ] ;\n ptr = in -> buffer ;\n size = in -> size_used ;\n headersize = size - included_body_bytes ;\n DEBUGASSERT ( size > included_body_bytes ) ;\n result = Curl_convert_to_network ( conn -> data , ptr , headersize ) ;\n if ( result ) {\n Curl_add_buffer_free ( in ) ;\n return result ;\n }\n if ( ( conn -> handler -> flags & PROTOPT_SSL ) && conn -> httpversion != 20 ) {\n sendsize = ( size > CURL_MAX_WRITE_SIZE ) ? CURL_MAX_WRITE_SIZE : size ;\n memcpy ( conn -> data -> state . uploadbuffer , ptr , sendsize ) ;\n ptr = conn -> data -> state . uploadbuffer ;\n }\n else sendsize = size ;\n result = Curl_write ( conn , sockfd , ptr , sendsize , & amount ) ;\n if ( ! result ) {\n size_t headlen = ( size_t ) amount > headersize ? headersize : ( size_t ) amount ;\n size_t bodylen = amount - headlen ;\n if ( conn -> data -> set . verbose ) {\n Curl_debug ( conn -> data , CURLINFO_HEADER_OUT , ptr , headlen , conn ) ;\n if ( bodylen ) {\n Curl_debug ( conn -> data , CURLINFO_DATA_OUT , ptr + headlen , bodylen , conn ) ;\n }\n }\n * bytes_written += ( long ) amount ;\n if ( http ) {\n http -> writebytecount += bodylen ;\n if ( ( size_t ) amount != size ) {\n size -= amount ;\n ptr = in -> buffer + amount ;\n http -> backup . fread_func = conn -> data -> state . fread_func ;\n http -> backup . fread_in = conn -> data -> state . in ;\n http -> backup . postdata = http -> postdata ;\n http -> backup . postsize = http -> postsize ;\n conn -> data -> state . fread_func = ( curl_read_callback ) readmoredata ;\n conn -> data -> state . in = ( void * ) conn ;\n http -> postdata = ptr ;\n http -> postsize = ( curl_off_t ) size ;\n http -> send_buffer = in ;\n http -> sending = HTTPSEND_REQUEST ;\n return CURLE_OK ;\n }\n http -> sending = HTTPSEND_BODY ;\n }\n else {\n if ( ( size_t ) amount != size ) return CURLE_SEND_ERROR ;\n else Curl_pipeline_leave_write ( conn ) ;\n }\n }\n Curl_add_buffer_free ( in ) ;\n return result ;\n }", "idx": 1383}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_MultiplexEntrySendReject ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_MultiplexEntrySendReject , MultiplexEntrySendReject_sequence ) ;\n return offset ;\n }", "idx": 1384}
{"hash": -2386031673786599357, "project": "debian", "size": 3, "label": 0, "functionSource": "static const char * gpgsm_get_req_version ( void ) {\n return \"2.0.4\" ;\n }", "idx": 1385}
{"hash": -8745685032143262400, "project": "debian", "size": 59, "label": 0, "functionSource": "int upx_inflate2d ( const char * src , uint32_t ssize , char * dst , uint32_t * dsize , uint32_t upx0 , uint32_t upx1 , uint32_t ep ) {\n int32_t backbytes , unp_offset = - 1 ;\n uint32_t backsize , myebx = 0 , scur = 0 , dcur = 0 , i , magic [ ] = {\n 0x11c , 0x124 , 0 }\n ;\n int oob ;\n while ( 1 ) {\n while ( ( oob = doubleebx ( src , & myebx , & scur , ssize ) ) == 1 ) {\n if ( scur >= ssize || dcur >= * dsize ) return - 1 ;\n dst [ dcur ++ ] = src [ scur ++ ] ;\n }\n if ( oob == - 1 ) return - 1 ;\n backbytes = 1 ;\n while ( 1 ) {\n if ( ( oob = doubleebx ( src , & myebx , & scur , ssize ) ) == - 1 ) return - 1 ;\n backbytes = backbytes * 2 + oob ;\n if ( ( oob = doubleebx ( src , & myebx , & scur , ssize ) ) == - 1 ) return - 1 ;\n if ( oob ) break ;\n backbytes -- ;\n if ( ( oob = doubleebx ( src , & myebx , & scur , ssize ) ) == - 1 ) return - 1 ;\n backbytes = backbytes * 2 + oob ;\n }\n backsize = 0 ;\n backbytes -= 3 ;\n if ( backbytes >= 0 ) {\n if ( scur >= ssize ) return - 1 ;\n backbytes <<= 8 ;\n backbytes += ( unsigned char ) ( src [ scur ++ ] ) ;\n backbytes ^= 0xffffffff ;\n if ( ! backbytes ) break ;\n backsize = backbytes & 1 ;\n CLI_SAR ( backbytes , 1 ) ;\n unp_offset = backbytes ;\n }\n else {\n if ( ( backsize = ( uint32_t ) doubleebx ( src , & myebx , & scur , ssize ) ) == 0xffffffff ) return - 1 ;\n }\n if ( ( oob = doubleebx ( src , & myebx , & scur , ssize ) ) == - 1 ) return - 1 ;\n backsize = backsize * 2 + oob ;\n if ( ! backsize ) {\n backsize ++ ;\n do {\n if ( ( oob = doubleebx ( src , & myebx , & scur , ssize ) ) == - 1 ) return - 1 ;\n backsize = backsize * 2 + oob ;\n }\n while ( ( oob = doubleebx ( src , & myebx , & scur , ssize ) ) == 0 ) ;\n if ( oob == - 1 ) return - 1 ;\n backsize += 2 ;\n }\n if ( ( uint32_t ) unp_offset < 0xfffffb00 ) backsize ++ ;\n backsize ++ ;\n if ( ! CLI_ISCONTAINED ( dst , * dsize , dst + dcur + unp_offset , backsize ) || ! CLI_ISCONTAINED ( dst , * dsize , dst + dcur , backsize ) || unp_offset >= 0 ) return - 1 ;\n for ( i = 0 ;\n i < backsize ;\n i ++ ) dst [ dcur + i ] = dst [ dcur + unp_offset + i ] ;\n dcur += backsize ;\n }\n return pefromupx ( src , ssize , dst , dsize , ep , upx0 , upx1 , magic , dcur ) ;\n }", "idx": 1386}
{"hash": -6552851419396579257, "project": "debian", "size": 7, "label": 0, "functionSource": "static int SpoolssDeletePrinterData_r ( tvbuff_t * tvb , int offset , packet_info * pinfo , proto_tree * tree , dcerpc_info * di , guint8 * drep ) {\n proto_item * hidden_item ;\n hidden_item = proto_tree_add_uint ( tree , hf_printerdata , tvb , offset , 0 , 1 ) ;\n PROTO_ITEM_SET_HIDDEN ( hidden_item ) ;\n offset = dissect_doserror ( tvb , offset , pinfo , tree , di , drep , hf_rc , NULL ) ;\n return offset ;\n }", "idx": 1387}
{"hash": 6380456053173444622, "project": "debian", "size": 68, "label": 0, "functionSource": "const char * SSL_alert_desc_string_long ( int value ) {\n const char * str ;\n switch ( value & 0xff ) {\n case SSL3_AD_CLOSE_NOTIFY : str = \"close notify\" ;\n break ;\n case SSL3_AD_UNEXPECTED_MESSAGE : str = \"unexpected_message\" ;\n break ;\n case SSL3_AD_BAD_RECORD_MAC : str = \"bad record mac\" ;\n break ;\n case SSL3_AD_DECOMPRESSION_FAILURE : str = \"decompression failure\" ;\n break ;\n case SSL3_AD_HANDSHAKE_FAILURE : str = \"handshake failure\" ;\n break ;\n case SSL3_AD_NO_CERTIFICATE : str = \"no certificate\" ;\n break ;\n case SSL3_AD_BAD_CERTIFICATE : str = \"bad certificate\" ;\n break ;\n case SSL3_AD_UNSUPPORTED_CERTIFICATE : str = \"unsupported certificate\" ;\n break ;\n case SSL3_AD_CERTIFICATE_REVOKED : str = \"certificate revoked\" ;\n break ;\n case SSL3_AD_CERTIFICATE_EXPIRED : str = \"certificate expired\" ;\n break ;\n case SSL3_AD_CERTIFICATE_UNKNOWN : str = \"certificate unknown\" ;\n break ;\n case SSL3_AD_ILLEGAL_PARAMETER : str = \"illegal parameter\" ;\n break ;\n case TLS1_AD_DECRYPTION_FAILED : str = \"decryption failed\" ;\n break ;\n case TLS1_AD_RECORD_OVERFLOW : str = \"record overflow\" ;\n break ;\n case TLS1_AD_UNKNOWN_CA : str = \"unknown CA\" ;\n break ;\n case TLS1_AD_ACCESS_DENIED : str = \"access denied\" ;\n break ;\n case TLS1_AD_DECODE_ERROR : str = \"decode error\" ;\n break ;\n case TLS1_AD_DECRYPT_ERROR : str = \"decrypt error\" ;\n break ;\n case TLS1_AD_EXPORT_RESTRICTION : str = \"export restriction\" ;\n break ;\n case TLS1_AD_PROTOCOL_VERSION : str = \"protocol version\" ;\n break ;\n case TLS1_AD_INSUFFICIENT_SECURITY : str = \"insufficient security\" ;\n break ;\n case TLS1_AD_INTERNAL_ERROR : str = \"internal error\" ;\n break ;\n case TLS1_AD_USER_CANCELLED : str = \"user canceled\" ;\n break ;\n case TLS1_AD_NO_RENEGOTIATION : str = \"no renegotiation\" ;\n break ;\n case TLS1_AD_UNSUPPORTED_EXTENSION : str = \"unsupported extension\" ;\n break ;\n case TLS1_AD_CERTIFICATE_UNOBTAINABLE : str = \"certificate unobtainable\" ;\n break ;\n case TLS1_AD_UNRECOGNIZED_NAME : str = \"unrecognized name\" ;\n break ;\n case TLS1_AD_BAD_CERTIFICATE_STATUS_RESPONSE : str = \"bad certificate status response\" ;\n break ;\n case TLS1_AD_BAD_CERTIFICATE_HASH_VALUE : str = \"bad certificate hash value\" ;\n break ;\n case TLS1_AD_UNKNOWN_PSK_IDENTITY : str = \"unknown PSK identity\" ;\n break ;\n default : str = \"unknown\" ;\n break ;\n }\n return ( str ) ;\n }", "idx": 1388}
{"hash": 7320640583188908680, "project": "debian", "size": 21, "label": 0, "functionSource": "static int remoteStreamHandleWriteData ( struct qemud_client * client , struct qemud_client_stream * stream , struct qemud_client_message * msg ) {\n remote_error rerr ;\n int ret ;\n VIR_DEBUG ( \"stream=%p proc=%d serial=%d len=%d offset=%d\" , stream , msg -> hdr . proc , msg -> hdr . serial , msg -> bufferLength , msg -> bufferOffset ) ;\n memset ( & rerr , 0 , sizeof rerr ) ;\n ret = virStreamSend ( stream -> st , msg -> buffer + msg -> bufferOffset , msg -> bufferLength - msg -> bufferOffset ) ;\n if ( ret > 0 ) {\n msg -> bufferOffset += ret ;\n if ( msg -> bufferOffset < msg -> bufferLength ) return 1 ;\n }\n else if ( ret == - 2 ) {\n return 1 ;\n }\n else {\n VIR_INFO0 ( \"Stream send failed\" ) ;\n stream -> closed = 1 ;\n remoteDispatchError ( & rerr ) ;\n return remoteSerializeReplyError ( client , & rerr , & msg -> hdr ) ;\n }\n return 0 ;\n }", "idx": 1389}
{"hash": -2375740980880577395, "project": "chrome", "size": 7, "label": 0, "functionSource": "static void free_tree_contexts ( PC_TREE * tree ) {\n free_mode_context ( & tree -> none ) ;\n free_mode_context ( & tree -> horizontal [ 0 ] ) ;\n free_mode_context ( & tree -> horizontal [ 1 ] ) ;\n free_mode_context ( & tree -> vertical [ 0 ] ) ;\n free_mode_context ( & tree -> vertical [ 1 ] ) ;\n }", "idx": 1390}
{"hash": -8620097311326519087, "project": "chrome", "size": 125, "label": 0, "functionSource": "err_status_t srtp_protect ( srtp_ctx_t * ctx , void * rtp_hdr , int * pkt_octet_len ) {\n srtp_hdr_t * hdr = ( srtp_hdr_t * ) rtp_hdr ;\n uint32_t * enc_start ;\n uint32_t * auth_start ;\n unsigned int enc_octet_len = 0 ;\n xtd_seq_num_t est ;\n int delta ;\n uint8_t * auth_tag = NULL ;\n err_status_t status ;\n int tag_len ;\n srtp_stream_ctx_t * stream ;\n int prefix_len ;\n debug_print ( mod_srtp , \"function srtp_protect\" , NULL ) ;\n status = srtp_validate_rtp_header ( rtp_hdr , pkt_octet_len ) ;\n if ( status ) return status ;\n if ( * pkt_octet_len < octets_in_rtp_header ) return err_status_bad_param ;\n stream = srtp_get_stream ( ctx , hdr -> ssrc ) ;\n if ( stream == NULL ) {\n if ( ctx -> stream_template != NULL ) {\n srtp_stream_ctx_t * new_stream ;\n status = srtp_stream_clone ( ctx -> stream_template , hdr -> ssrc , & new_stream ) ;\n if ( status ) return status ;\n new_stream -> next = ctx -> stream_list ;\n ctx -> stream_list = new_stream ;\n new_stream -> direction = dir_srtp_sender ;\n stream = new_stream ;\n }\n else {\n return err_status_no_ctx ;\n }\n }\n if ( stream -> direction != dir_srtp_sender ) {\n if ( stream -> direction == dir_unknown ) {\n stream -> direction = dir_srtp_sender ;\n }\n else {\n srtp_handle_event ( ctx , stream , event_ssrc_collision ) ;\n }\n }\n if ( stream -> rtp_cipher -> algorithm == AES_128_GCM || stream -> rtp_cipher -> algorithm == AES_256_GCM ) {\n return srtp_protect_aead ( ctx , stream , rtp_hdr , ( unsigned int * ) pkt_octet_len ) ;\n }\n switch ( key_limit_update ( stream -> limit ) ) {\n case key_event_normal : break ;\n case key_event_soft_limit : srtp_handle_event ( ctx , stream , event_key_soft_limit ) ;\n break ;\n case key_event_hard_limit : srtp_handle_event ( ctx , stream , event_key_hard_limit ) ;\n return err_status_key_expired ;\n default : break ;\n }\n tag_len = auth_get_tag_length ( stream -> rtp_auth ) ;\n if ( stream -> rtp_services & sec_serv_conf ) {\n enc_start = ( uint32_t * ) hdr + uint32s_in_rtp_header + hdr -> cc ;\n if ( hdr -> x == 1 ) {\n srtp_hdr_xtnd_t * xtn_hdr = ( srtp_hdr_xtnd_t * ) enc_start ;\n enc_start += ( ntohs ( xtn_hdr -> length ) + 1 ) ;\n }\n if ( ! ( ( uint8_t * ) enc_start < ( uint8_t * ) hdr + * pkt_octet_len ) ) return err_status_parse_err ;\n enc_octet_len = ( unsigned int ) ( * pkt_octet_len - ( ( uint8_t * ) enc_start - ( uint8_t * ) hdr ) ) ;\n }\n else {\n enc_start = NULL ;\n }\n if ( stream -> rtp_services & sec_serv_auth ) {\n auth_start = ( uint32_t * ) hdr ;\n auth_tag = ( uint8_t * ) hdr + * pkt_octet_len ;\n }\n else {\n auth_start = NULL ;\n auth_tag = NULL ;\n }\n delta = rdbx_estimate_index ( & stream -> rtp_rdbx , & est , ntohs ( hdr -> seq ) ) ;\n status = rdbx_check ( & stream -> rtp_rdbx , delta ) ;\n if ( status ) {\n if ( status != err_status_replay_fail || ! stream -> allow_repeat_tx ) return status ;\n }\n else rdbx_add_index ( & stream -> rtp_rdbx , delta ) ;\n # ifdef NO_64BIT_MATH debug_print2 ( mod_srtp , \"estimated packet index: %08x%08x\" , high32 ( est ) , low32 ( est ) ) ;\n # else debug_print ( mod_srtp , \"estimated packet index: %016llx\" , est ) ;\n # endif if ( stream -> rtp_cipher -> type -> id == AES_ICM || stream -> rtp_cipher -> type -> id == AES_256_ICM ) {\n v128_t iv ;\n iv . v32 [ 0 ] = 0 ;\n iv . v32 [ 1 ] = hdr -> ssrc ;\n # ifdef NO_64BIT_MATH iv . v64 [ 1 ] = be64_to_cpu ( make64 ( ( high32 ( est ) << 16 ) | ( low32 ( est ) >> 16 ) , low32 ( est ) << 16 ) ) ;\n # else iv . v64 [ 1 ] = be64_to_cpu ( est << 16 ) ;\n # endif status = cipher_set_iv ( stream -> rtp_cipher , & iv , direction_encrypt ) ;\n }\n else {\n v128_t iv ;\n # ifdef NO_64BIT_MATH iv . v32 [ 0 ] = 0 ;\n iv . v32 [ 1 ] = 0 ;\n # else iv . v64 [ 0 ] = 0 ;\n # endif iv . v64 [ 1 ] = be64_to_cpu ( est ) ;\n status = cipher_set_iv ( stream -> rtp_cipher , & iv , direction_encrypt ) ;\n }\n if ( status ) return err_status_cipher_fail ;\n # ifdef NO_64BIT_MATH est = be64_to_cpu ( make64 ( ( high32 ( est ) << 16 ) | ( low32 ( est ) >> 16 ) , low32 ( est ) << 16 ) ) ;\n # else est = be64_to_cpu ( est << 16 ) ;\n # endif if ( auth_start ) {\n prefix_len = auth_get_prefix_length ( stream -> rtp_auth ) ;\n if ( prefix_len ) {\n status = cipher_output ( stream -> rtp_cipher , auth_tag , prefix_len ) ;\n if ( status ) return err_status_cipher_fail ;\n debug_print ( mod_srtp , \"keystream prefix: %s\" , octet_string_hex_string ( auth_tag , prefix_len ) ) ;\n }\n }\n if ( enc_start ) {\n status = cipher_encrypt ( stream -> rtp_cipher , ( uint8_t * ) enc_start , & enc_octet_len ) ;\n if ( status ) return err_status_cipher_fail ;\n }\n if ( auth_start ) {\n status = auth_start ( stream -> rtp_auth ) ;\n if ( status ) return status ;\n status = auth_update ( stream -> rtp_auth , ( uint8_t * ) auth_start , * pkt_octet_len ) ;\n if ( status ) return status ;\n debug_print ( mod_srtp , \"estimated packet index: %016llx\" , est ) ;\n status = auth_compute ( stream -> rtp_auth , ( uint8_t * ) & est , 4 , auth_tag ) ;\n debug_print ( mod_srtp , \"srtp auth tag: %s\" , octet_string_hex_string ( auth_tag , tag_len ) ) ;\n if ( status ) return err_status_auth_fail ;\n }\n if ( auth_tag ) {\n * pkt_octet_len += tag_len ;\n }\n return err_status_ok ;\n }", "idx": 1391}
{"hash": 8484475213808847345, "project": "debian", "size": 19, "label": 0, "functionSource": "static int qdev_print_devinfo ( DeviceInfo * info , char * dest , int len ) {\n int pos = 0 ;\n int ret ;\n ret = snprintf ( dest + pos , len - pos , \"name \\\"%s\\\", bus %s\" , info -> name , info -> bus_info -> name ) ;\n pos += MIN ( len - pos , ret ) ;\n if ( info -> alias ) {\n ret = snprintf ( dest + pos , len - pos , \", alias \\\"%s\\\"\" , info -> alias ) ;\n pos += MIN ( len - pos , ret ) ;\n }\n if ( info -> desc ) {\n ret = snprintf ( dest + pos , len - pos , \", desc \\\"%s\\\"\" , info -> desc ) ;\n pos += MIN ( len - pos , ret ) ;\n }\n if ( info -> no_user ) {\n ret = snprintf ( dest + pos , len - pos , \", no-user\" ) ;\n pos += MIN ( len - pos , ret ) ;\n }\n return pos ;\n }", "idx": 1392}
{"hash": -1929262071302712016, "project": "debian", "size": 6, "label": 0, "functionSource": "static cmsBool ReadOneElem ( cmsIOHANDLER * io , _cmsDICelem * e , cmsUInt32Number i , cmsUInt32Number BaseOffset ) {\n if ( ! _cmsReadUInt32Number ( io , & e -> Offsets [ i ] ) ) return FALSE ;\n if ( ! _cmsReadUInt32Number ( io , & e -> Sizes [ i ] ) ) return FALSE ;\n if ( e -> Offsets [ i ] > 0 ) e -> Offsets [ i ] += BaseOffset ;\n return TRUE ;\n }", "idx": 1393}
{"hash": 6667142528452941476, "project": "debian", "size": 38, "label": 1, "functionSource": "static void write_header ( FILE * sql_file , char * db_name ) {\n if ( opt_xml ) {\n fputs ( \"<?xml version=\\\"1.0\\\"?>\\n\" , sql_file ) ;\n fputs ( \"<mysqldump \" , sql_file ) ;\n fputs ( \"xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\"\" , sql_file ) ;\n fputs ( \">\\n\" , sql_file ) ;\n check_io ( sql_file ) ;\n }\n else if ( ! opt_compact ) {\n print_comment ( sql_file , 0 , \"-- MySQL dump %s Distrib %s, for %s (%s)\\n--\\n\" , DUMP_VERSION , MYSQL_SERVER_VERSION , SYSTEM_TYPE , MACHINE_TYPE ) ;\n print_comment ( sql_file , 0 , \"-- Host: %s Database: %s\\n\" , current_host ? current_host : \"localhost\" , db_name ? db_name : \"\" ) ;\n print_comment ( sql_file , 0 , \"-- ------------------------------------------------------\\n\" ) ;\n print_comment ( sql_file , 0 , \"-- Server version\\t%s\\n\" , mysql_get_server_info ( & mysql_connection ) ) ;\n if ( opt_set_charset ) fprintf ( sql_file , \"\\n/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;\n\" \"\\n/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;\n\" \"\\n/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;\n\" \"\\n/*!40101 SET NAMES %s */;\n\\n\" , default_charset ) ;\n if ( opt_tz_utc ) {\n fprintf ( sql_file , \"/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;\n\\n\" ) ;\n fprintf ( sql_file , \"/*!40103 SET TIME_ZONE='+00:00' */;\n\\n\" ) ;\n }\n if ( ! path ) {\n if ( ! opt_no_create_info ) {\n fprintf ( md_result_file , \"\\ /*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;\n\\n\" ) ;\n }\n fprintf ( md_result_file , \"\\ /*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;\n\\n\\ \" ) ;\n }\n fprintf ( sql_file , \"/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='%s%s%s' */;\n\\n\" \"/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;\n\\n\" , path ? \"\" : \"NO_AUTO_VALUE_ON_ZERO\" , compatible_mode_normal_str [ 0 ] == 0 ? \"\" : \",\" , compatible_mode_normal_str ) ;\n check_io ( sql_file ) ;\n }\n }", "idx": 1394}
{"hash": -6351630154286607278, "project": "debian", "size": 7, "label": 0, "functionSource": "struct ifblock * compiler_create_ifblock ( struct condition * conds , struct block * blk ) {\n struct ifblock * ifblk ;\n SAFE_CALLOC ( ifblk , 1 , sizeof ( struct ifblock ) ) ;\n ifblk -> conds = conds ;\n ifblk -> blk = blk ;\n return ifblk ;\n }", "idx": 1395}
{"hash": 3935234056444097745, "project": "debian", "size": 3, "label": 0, "functionSource": "static int rtp_packetize_g726_32 ( sout_stream_id_sys_t * id , block_t * in ) {\n return rtp_packetize_g726 ( id , in , 2 ) ;\n }", "idx": 1396}
{"hash": 1760449185745615462, "project": "debian", "size": 5, "label": 0, "functionSource": "char * TSFetchRespGet ( TSHttpTxn txnp , int * length ) {\n sdk_assert ( sdk_sanity_check_null_ptr ( ( void * ) length ) == TS_SUCCESS ) ;\n FetchSM * fetch_sm = ( FetchSM * ) txnp ;\n return fetch_sm -> resp_get ( length ) ;\n }", "idx": 1397}
{"hash": -2423144171479606949, "project": "debian", "size": 4, "label": 0, "functionSource": "static void pdf_run_c ( fz_context * ctx , pdf_processor * proc , float x1 , float y1 , float x2 , float y2 , float x3 , float y3 ) {\n pdf_run_processor * pr = ( pdf_run_processor * ) proc ;\n fz_curveto ( ctx , pr -> path , x1 , y1 , x2 , y2 , x3 , y3 ) ;\n }", "idx": 1398}
{"hash": -1409980668468066833, "project": "debian", "size": 6, "label": 0, "functionSource": "static int mp_gradient ( MotionPixelsContext * mp , int component , int v ) {\n int delta ;\n delta = ( v - 7 ) * mp -> gradient_scale [ component ] ;\n mp -> gradient_scale [ component ] = ( v == 0 || v == 14 ) ? 2 : 1 ;\n return delta ;\n }", "idx": 1399}
{"hash": -7855974557509681261, "project": "debian", "size": 15, "label": 0, "functionSource": "List * get_mergejoin_opfamilies ( Oid opno ) {\n List * result = NIL ;\n CatCList * catlist ;\n int i ;\n catlist = SearchSysCacheList1 ( AMOPOPID , ObjectIdGetDatum ( opno ) ) ;\n for ( i = 0 ;\n i < catlist -> n_members ;\n i ++ ) {\n HeapTuple tuple = & catlist -> members [ i ] -> tuple ;\n Form_pg_amop aform = ( Form_pg_amop ) GETSTRUCT ( tuple ) ;\n if ( aform -> amopmethod == BTREE_AM_OID && aform -> amopstrategy == BTEqualStrategyNumber ) result = lappend_oid ( result , aform -> amopfamily ) ;\n }\n ReleaseSysCacheList ( catlist ) ;\n return result ;\n }", "idx": 1400}
{"hash": -8745685032143262400, "project": "debian", "size": 128, "label": 0, "functionSource": "static int pefromupx ( const char * src , uint32_t ssize , char * dst , uint32_t * dsize , uint32_t ep , uint32_t upx0 , uint32_t upx1 , uint32_t * magic , uint32_t dend ) {\n char * imports , * sections = NULL , * pehdr = NULL , * newbuf ;\n unsigned int sectcnt = 0 , upd = 1 ;\n uint32_t realstuffsz = 0 , valign = 0 ;\n uint32_t foffset = 0xd0 + 0xf8 ;\n if ( ( dst == NULL ) || ( src == NULL ) ) return 0 ;\n while ( ( valign = magic [ sectcnt ++ ] ) ) {\n if ( CLI_ISCONTAINED ( src , ssize - 5 , src + ep - upx1 + valign - 2 , 2 ) && src [ ep - upx1 + valign - 2 ] == '\\x8d' && src [ ep - upx1 + valign - 1 ] == '\\xbe' ) break ;\n }\n if ( ! valign && CLI_ISCONTAINED ( src , ssize - 8 , src + ep - upx1 + 0x80 , 8 ) ) {\n const char * pt = & src [ ep - upx1 + 0x80 ] ;\n cli_dbgmsg ( \"UPX: bad magic - scanning for imports\\n\" ) ;\n while ( ( pt = cli_memstr ( pt , ssize - ( pt - src ) - 8 , \"\\x8d\\xbe\" , 2 ) ) ) {\n if ( pt [ 6 ] == '\\x8b' && pt [ 7 ] == '\\x07' ) {\n valign = pt - src + 2 - ep + upx1 ;\n break ;\n }\n pt ++ ;\n }\n }\n if ( valign && CLI_ISCONTAINED ( src , ssize , src + ep - upx1 + valign , 4 ) ) {\n imports = dst + cli_readint32 ( src + ep - upx1 + valign ) ;\n realstuffsz = imports - dst ;\n if ( realstuffsz >= * dsize ) {\n cli_dbgmsg ( \"UPX: wrong realstuff size\\n\" ) ;\n }\n else {\n pehdr = imports ;\n while ( CLI_ISCONTAINED ( dst , * dsize , pehdr , 8 ) && cli_readint32 ( pehdr ) ) {\n pehdr += 8 ;\n while ( CLI_ISCONTAINED ( dst , * dsize , pehdr , 2 ) && * pehdr ) {\n pehdr ++ ;\n while ( CLI_ISCONTAINED ( dst , * dsize , pehdr , 2 ) && * pehdr ) pehdr ++ ;\n pehdr ++ ;\n }\n pehdr ++ ;\n }\n pehdr += 4 ;\n if ( ! ( sections = checkpe ( dst , * dsize , pehdr , & valign , & sectcnt ) ) ) pehdr = NULL ;\n }\n }\n if ( ! pehdr && dend > 0xf8 + 0x28 ) {\n cli_dbgmsg ( \"UPX: no luck - scanning for PE\\n\" ) ;\n pehdr = & dst [ dend - 0xf8 - 0x28 ] ;\n while ( pehdr > dst ) {\n if ( ( sections = checkpe ( dst , * dsize , pehdr , & valign , & sectcnt ) ) ) break ;\n pehdr -- ;\n }\n if ( ! ( realstuffsz = pehdr - dst ) ) pehdr = NULL ;\n }\n if ( ! pehdr ) {\n uint32_t rebsz = PESALIGN ( dend , 0x1000 ) ;\n cli_dbgmsg ( \"UPX: no luck - brutally crafing a reasonable PE\\n\" ) ;\n if ( ! ( newbuf = ( char * ) cli_calloc ( rebsz + 0x200 , sizeof ( char ) ) ) ) {\n cli_dbgmsg ( \"UPX: malloc failed - giving up rebuild\\n\" ) ;\n return 0 ;\n }\n memcpy ( newbuf , HEADERS , 0xd0 ) ;\n memcpy ( newbuf + 0xd0 , FAKEPE , 0x120 ) ;\n memcpy ( newbuf + 0x200 , dst , dend ) ;\n memcpy ( dst , newbuf , dend + 0x200 ) ;\n free ( newbuf ) ;\n cli_writeint32 ( dst + 0xd0 + 0x50 , rebsz + 0x1000 ) ;\n cli_writeint32 ( dst + 0xd0 + 0x100 , rebsz ) ;\n cli_writeint32 ( dst + 0xd0 + 0x108 , rebsz ) ;\n * dsize = rebsz + 0x200 ;\n cli_dbgmsg ( \"UPX: PE structure added to uncompressed data\\n\" ) ;\n return 1 ;\n }\n if ( ! sections ) sectcnt = 0 ;\n foffset = PESALIGN ( foffset + 0x28 * sectcnt , valign ) ;\n for ( upd = 0 ;\n upd < sectcnt ;\n upd ++ ) {\n uint32_t vsize = PESALIGN ( ( uint32_t ) cli_readint32 ( sections + 8 ) , valign ) ;\n uint32_t urva = PEALIGN ( ( uint32_t ) cli_readint32 ( sections + 12 ) , valign ) ;\n if ( ! CLI_ISCONTAINED ( upx0 , realstuffsz , urva , vsize ) ) {\n cli_dbgmsg ( \"UPX: Sect %d out of bounds - giving up rebuild\\n\" , upd ) ;\n return 0 ;\n }\n cli_writeint32 ( sections + 8 , vsize ) ;\n cli_writeint32 ( sections + 12 , urva ) ;\n cli_writeint32 ( sections + 16 , vsize ) ;\n cli_writeint32 ( sections + 20 , foffset ) ;\n if ( foffset + vsize < foffset ) {\n return 0 ;\n }\n foffset += vsize ;\n sections += 0x28 ;\n }\n cli_writeint32 ( pehdr + 8 , 0x4d414c43 ) ;\n cli_writeint32 ( pehdr + 0x3c , valign ) ;\n if ( ! ( newbuf = ( char * ) cli_calloc ( foffset , sizeof ( char ) ) ) ) {\n cli_dbgmsg ( \"UPX: malloc failed - giving up rebuild\\n\" ) ;\n return 0 ;\n }\n memcpy ( newbuf , HEADERS , 0xd0 ) ;\n memcpy ( newbuf + 0xd0 , pehdr , 0xf8 + 0x28 * sectcnt ) ;\n sections = pehdr + 0xf8 ;\n for ( upd = 0 ;\n upd < sectcnt ;\n upd ++ ) {\n uint32_t offset1 , offset2 , offset3 ;\n offset1 = ( uint32_t ) cli_readint32 ( sections + 20 ) ;\n offset2 = ( uint32_t ) cli_readint32 ( sections + 16 ) ;\n if ( offset1 > foffset || offset2 > foffset || offset1 + offset2 > foffset ) {\n free ( newbuf ) ;\n return 1 ;\n }\n offset3 = ( uint32_t ) cli_readint32 ( sections + 12 ) ;\n if ( offset3 - upx0 > * dsize ) {\n free ( newbuf ) ;\n return 1 ;\n }\n memcpy ( newbuf + offset1 , dst + offset3 - upx0 , offset2 ) ;\n sections += 0x28 ;\n }\n if ( foffset > * dsize + 8192 ) {\n cli_dbgmsg ( \"UPX: wrong raw size - giving up rebuild\\n\" ) ;\n free ( newbuf ) ;\n return 0 ;\n }\n memcpy ( dst , newbuf , foffset ) ;\n * dsize = foffset ;\n free ( newbuf ) ;\n cli_dbgmsg ( \"UPX: PE structure rebuilt from compressed file\\n\" ) ;\n return 1 ;\n }", "idx": 1401}
{"hash": 3576240888172463140, "project": "debian", "size": 22, "label": 0, "functionSource": "static KeydbResourceType rt_from_file ( const char * filename , int * r_found , int * r_openpgp ) {\n u32 magic ;\n unsigned char verbuf [ 4 ] ;\n FILE * fp ;\n KeydbResourceType rt = KEYDB_RESOURCE_TYPE_NONE ;\n * r_found = * r_openpgp = 0 ;\n fp = fopen ( filename , \"rb\" ) ;\n if ( fp ) {\n * r_found = 1 ;\n if ( fread ( & magic , 4 , 1 , fp ) == 1 ) {\n if ( magic == 0x13579ace || magic == 0xce9a5713 ) ;\n else if ( fread ( & verbuf , 4 , 1 , fp ) == 1 && verbuf [ 0 ] == 1 && fread ( & magic , 4 , 1 , fp ) == 1 && ! memcmp ( & magic , \"KBXf\" , 4 ) ) {\n if ( ( verbuf [ 3 ] & 0x02 ) ) * r_openpgp = 1 ;\n rt = KEYDB_RESOURCE_TYPE_KEYBOX ;\n }\n else rt = KEYDB_RESOURCE_TYPE_KEYRING ;\n }\n else rt = KEYDB_RESOURCE_TYPE_KEYRING ;\n fclose ( fp ) ;\n }\n return rt ;\n }", "idx": 1402}
{"hash": 8801969307247112896, "project": "debian", "size": 7, "label": 0, "functionSource": "static int aes_cfb8_cipher ( EVP_CIPHER_CTX * ctx , unsigned char * out , const unsigned char * in , size_t len ) {\n EVP_AES_KEY * dat = EVP_C_DATA ( EVP_AES_KEY , ctx ) ;\n int num = EVP_CIPHER_CTX_num ( ctx ) ;\n CRYPTO_cfb128_8_encrypt ( in , out , len , & dat -> ks , EVP_CIPHER_CTX_iv_noconst ( ctx ) , & num , EVP_CIPHER_CTX_encrypting ( ctx ) , dat -> block ) ;\n EVP_CIPHER_CTX_set_num ( ctx , num ) ;\n return 1 ;\n }", "idx": 1403}
{"hash": 313627013719508831, "project": "debian", "size": 8, "label": 0, "functionSource": "static inline MagickBooleanType IsPixelEquivalent ( const Image * restrict image , const Quantum * restrict p , const PixelInfo * restrict q ) {\n MagickRealType blue , green , red ;\n red = ( MagickRealType ) p [ image -> channel_map [ RedPixelChannel ] . offset ] ;\n green = ( MagickRealType ) p [ image -> channel_map [ GreenPixelChannel ] . offset ] ;\n blue = ( MagickRealType ) p [ image -> channel_map [ BluePixelChannel ] . offset ] ;\n if ( ( AbsolutePixelValue ( red - q -> red ) < MagickEpsilon ) && ( AbsolutePixelValue ( green - q -> green ) < MagickEpsilon ) && ( AbsolutePixelValue ( blue - q -> blue ) < MagickEpsilon ) ) return ( MagickTrue ) ;\n return ( MagickFalse ) ;\n }", "idx": 1404}
{"hash": -8704451445127642833, "project": "chrome", "size": 46, "label": 0, "functionSource": "static int32_t u_scanf_scanset_handler ( UFILE * input , u_scanf_spec_info * info , ufmt_args * args , const UChar * fmt , int32_t * fmtConsumed , int32_t * argConverted ) {\n USet * scanset ;\n UErrorCode status = U_ZERO_ERROR ;\n int32_t chLeft = INT32_MAX ;\n UChar32 c ;\n UChar * alias = ( UChar * ) ( args [ 0 ] . ptrValue ) ;\n UBool isNotEOF = FALSE ;\n UBool readCharacter = FALSE ;\n scanset = uset_open ( 0 , - 1 ) ;\n fmt -- ;\n if ( info -> fWidth >= 0 ) {\n chLeft = info -> fWidth ;\n }\n * fmtConsumed = uset_applyPattern ( scanset , fmt , - 1 , 0 , & status ) ;\n if ( U_SUCCESS ( status ) ) {\n c = 0 ;\n while ( chLeft > 0 ) {\n if ( ( isNotEOF = ufile_getch32 ( input , & c ) ) && uset_contains ( scanset , c ) ) {\n readCharacter = TRUE ;\n if ( ! info -> fSkipArg ) {\n int32_t idx = 0 ;\n UBool isError = FALSE ;\n U16_APPEND ( alias , idx , chLeft , c , isError ) ;\n if ( isError ) {\n break ;\n }\n alias += idx ;\n }\n chLeft -= ( 1 + U_IS_SUPPLEMENTARY ( c ) ) ;\n }\n else {\n break ;\n }\n }\n if ( isNotEOF && chLeft > 0 ) {\n u_fungetc ( c , input ) ;\n }\n }\n uset_close ( scanset ) ;\n if ( ! readCharacter ) return - 1 ;\n else if ( ! info -> fSkipArg ) {\n * alias = 0x00 ;\n }\n * argConverted = ! info -> fSkipArg ;\n return ( info -> fWidth >= 0 ? info -> fWidth : INT32_MAX ) - chLeft ;\n }", "idx": 1405}
{"hash": 1743019814289113128, "project": "debian", "size": 191, "label": 1, "functionSource": "static void pred_temp_direct_motion ( H264Context * const h , int * mb_type ) {\n int b8_stride = 2 ;\n int b4_stride = h -> b_stride ;\n int mb_xy = h -> mb_xy , mb_y = h -> mb_y ;\n int mb_type_col [ 2 ] ;\n const int16_t ( * l1mv0 ) [ 2 ] , ( * l1mv1 ) [ 2 ] ;\n const int8_t * l1ref0 , * l1ref1 ;\n const int is_b8x8 = IS_8X8 ( * mb_type ) ;\n unsigned int sub_mb_type ;\n int i8 , i4 ;\n assert ( h -> ref_list [ 1 ] [ 0 ] . f . reference & 3 ) ;\n await_reference_mb_row ( h , & h -> ref_list [ 1 ] [ 0 ] , h -> mb_y + ! ! IS_INTERLACED ( * mb_type ) ) ;\n if ( IS_INTERLACED ( h -> ref_list [ 1 ] [ 0 ] . f . mb_type [ mb_xy ] ) ) {\n if ( ! IS_INTERLACED ( * mb_type ) ) {\n mb_y = ( h -> mb_y & ~ 1 ) + h -> col_parity ;\n mb_xy = h -> mb_x + ( ( h -> mb_y & ~ 1 ) + h -> col_parity ) * h -> mb_stride ;\n b8_stride = 0 ;\n }\n else {\n mb_y += h -> col_fieldoff ;\n mb_xy += h -> mb_stride * h -> col_fieldoff ;\n }\n goto single_col ;\n }\n else {\n if ( IS_INTERLACED ( * mb_type ) ) {\n mb_y = h -> mb_y & ~ 1 ;\n mb_xy = h -> mb_x + ( h -> mb_y & ~ 1 ) * h -> mb_stride ;\n mb_type_col [ 0 ] = h -> ref_list [ 1 ] [ 0 ] . f . mb_type [ mb_xy ] ;\n mb_type_col [ 1 ] = h -> ref_list [ 1 ] [ 0 ] . f . mb_type [ mb_xy + h -> mb_stride ] ;\n b8_stride = 2 + 4 * h -> mb_stride ;\n b4_stride *= 6 ;\n if ( IS_INTERLACED ( mb_type_col [ 0 ] ) != IS_INTERLACED ( mb_type_col [ 1 ] ) ) {\n mb_type_col [ 0 ] &= ~ MB_TYPE_INTERLACED ;\n mb_type_col [ 1 ] &= ~ MB_TYPE_INTERLACED ;\n }\n sub_mb_type = MB_TYPE_16x16 | MB_TYPE_P0L0 | MB_TYPE_P0L1 | MB_TYPE_DIRECT2 ;\n if ( ( mb_type_col [ 0 ] & MB_TYPE_16x16_OR_INTRA ) && ( mb_type_col [ 1 ] & MB_TYPE_16x16_OR_INTRA ) && ! is_b8x8 ) {\n * mb_type |= MB_TYPE_16x8 | MB_TYPE_L0L1 | MB_TYPE_DIRECT2 ;\n }\n else {\n * mb_type |= MB_TYPE_8x8 | MB_TYPE_L0L1 ;\n }\n }\n else {\n single_col : mb_type_col [ 0 ] = mb_type_col [ 1 ] = h -> ref_list [ 1 ] [ 0 ] . f . mb_type [ mb_xy ] ;\n sub_mb_type = MB_TYPE_16x16 | MB_TYPE_P0L0 | MB_TYPE_P0L1 | MB_TYPE_DIRECT2 ;\n if ( ! is_b8x8 && ( mb_type_col [ 0 ] & MB_TYPE_16x16_OR_INTRA ) ) {\n * mb_type |= MB_TYPE_16x16 | MB_TYPE_P0L0 | MB_TYPE_P0L1 | MB_TYPE_DIRECT2 ;\n }\n else if ( ! is_b8x8 && ( mb_type_col [ 0 ] & ( MB_TYPE_16x8 | MB_TYPE_8x16 ) ) ) {\n * mb_type |= MB_TYPE_L0L1 | MB_TYPE_DIRECT2 | ( mb_type_col [ 0 ] & ( MB_TYPE_16x8 | MB_TYPE_8x16 ) ) ;\n }\n else {\n if ( ! h -> sps . direct_8x8_inference_flag ) {\n sub_mb_type = MB_TYPE_8x8 | MB_TYPE_P0L0 | MB_TYPE_P0L1 | MB_TYPE_DIRECT2 ;\n }\n * mb_type |= MB_TYPE_8x8 | MB_TYPE_L0L1 ;\n }\n }\n }\n await_reference_mb_row ( h , & h -> ref_list [ 1 ] [ 0 ] , mb_y ) ;\n l1mv0 = & h -> ref_list [ 1 ] [ 0 ] . f . motion_val [ 0 ] [ h -> mb2b_xy [ mb_xy ] ] ;\n l1mv1 = & h -> ref_list [ 1 ] [ 0 ] . f . motion_val [ 1 ] [ h -> mb2b_xy [ mb_xy ] ] ;\n l1ref0 = & h -> ref_list [ 1 ] [ 0 ] . f . ref_index [ 0 ] [ 4 * mb_xy ] ;\n l1ref1 = & h -> ref_list [ 1 ] [ 0 ] . f . ref_index [ 1 ] [ 4 * mb_xy ] ;\n if ( ! b8_stride ) {\n if ( h -> mb_y & 1 ) {\n l1ref0 += 2 ;\n l1ref1 += 2 ;\n l1mv0 += 2 * b4_stride ;\n l1mv1 += 2 * b4_stride ;\n }\n }\n {\n const int * map_col_to_list0 [ 2 ] = {\n h -> map_col_to_list0 [ 0 ] , h -> map_col_to_list0 [ 1 ] }\n ;\n const int * dist_scale_factor = h -> dist_scale_factor ;\n int ref_offset ;\n if ( FRAME_MBAFF && IS_INTERLACED ( * mb_type ) ) {\n map_col_to_list0 [ 0 ] = h -> map_col_to_list0_field [ h -> mb_y & 1 ] [ 0 ] ;\n map_col_to_list0 [ 1 ] = h -> map_col_to_list0_field [ h -> mb_y & 1 ] [ 1 ] ;\n dist_scale_factor = h -> dist_scale_factor_field [ h -> mb_y & 1 ] ;\n }\n ref_offset = ( h -> ref_list [ 1 ] [ 0 ] . mbaff << 4 ) & ( mb_type_col [ 0 ] >> 3 ) ;\n if ( IS_INTERLACED ( * mb_type ) != IS_INTERLACED ( mb_type_col [ 0 ] ) ) {\n int y_shift = 2 * ! IS_INTERLACED ( * mb_type ) ;\n assert ( h -> sps . direct_8x8_inference_flag ) ;\n for ( i8 = 0 ;\n i8 < 4 ;\n i8 ++ ) {\n const int x8 = i8 & 1 ;\n const int y8 = i8 >> 1 ;\n int ref0 , scale ;\n const int16_t ( * l1mv ) [ 2 ] = l1mv0 ;\n if ( is_b8x8 && ! IS_DIRECT ( h -> sub_mb_type [ i8 ] ) ) continue ;\n h -> sub_mb_type [ i8 ] = sub_mb_type ;\n fill_rectangle ( & h -> ref_cache [ 1 ] [ scan8 [ i8 * 4 ] ] , 2 , 2 , 8 , 0 , 1 ) ;\n if ( IS_INTRA ( mb_type_col [ y8 ] ) ) {\n fill_rectangle ( & h -> ref_cache [ 0 ] [ scan8 [ i8 * 4 ] ] , 2 , 2 , 8 , 0 , 1 ) ;\n fill_rectangle ( & h -> mv_cache [ 0 ] [ scan8 [ i8 * 4 ] ] , 2 , 2 , 8 , 0 , 4 ) ;\n fill_rectangle ( & h -> mv_cache [ 1 ] [ scan8 [ i8 * 4 ] ] , 2 , 2 , 8 , 0 , 4 ) ;\n continue ;\n }\n ref0 = l1ref0 [ x8 + y8 * b8_stride ] ;\n if ( ref0 >= 0 ) ref0 = map_col_to_list0 [ 0 ] [ ref0 + ref_offset ] ;\n else {\n ref0 = map_col_to_list0 [ 1 ] [ l1ref1 [ x8 + y8 * b8_stride ] + ref_offset ] ;\n l1mv = l1mv1 ;\n }\n scale = dist_scale_factor [ ref0 ] ;\n fill_rectangle ( & h -> ref_cache [ 0 ] [ scan8 [ i8 * 4 ] ] , 2 , 2 , 8 , ref0 , 1 ) ;\n {\n const int16_t * mv_col = l1mv [ x8 * 3 + y8 * b4_stride ] ;\n int my_col = ( mv_col [ 1 ] << y_shift ) / 2 ;\n int mx = ( scale * mv_col [ 0 ] + 128 ) >> 8 ;\n int my = ( scale * my_col + 128 ) >> 8 ;\n fill_rectangle ( & h -> mv_cache [ 0 ] [ scan8 [ i8 * 4 ] ] , 2 , 2 , 8 , pack16to32 ( mx , my ) , 4 ) ;\n fill_rectangle ( & h -> mv_cache [ 1 ] [ scan8 [ i8 * 4 ] ] , 2 , 2 , 8 , pack16to32 ( mx - mv_col [ 0 ] , my - my_col ) , 4 ) ;\n }\n }\n return ;\n }\n if ( IS_16X16 ( * mb_type ) ) {\n int ref , mv0 , mv1 ;\n fill_rectangle ( & h -> ref_cache [ 1 ] [ scan8 [ 0 ] ] , 4 , 4 , 8 , 0 , 1 ) ;\n if ( IS_INTRA ( mb_type_col [ 0 ] ) ) {\n ref = mv0 = mv1 = 0 ;\n }\n else {\n const int ref0 = l1ref0 [ 0 ] >= 0 ? map_col_to_list0 [ 0 ] [ l1ref0 [ 0 ] + ref_offset ] : map_col_to_list0 [ 1 ] [ l1ref1 [ 0 ] + ref_offset ] ;\n const int scale = dist_scale_factor [ ref0 ] ;\n const int16_t * mv_col = l1ref0 [ 0 ] >= 0 ? l1mv0 [ 0 ] : l1mv1 [ 0 ] ;\n int mv_l0 [ 2 ] ;\n mv_l0 [ 0 ] = ( scale * mv_col [ 0 ] + 128 ) >> 8 ;\n mv_l0 [ 1 ] = ( scale * mv_col [ 1 ] + 128 ) >> 8 ;\n ref = ref0 ;\n mv0 = pack16to32 ( mv_l0 [ 0 ] , mv_l0 [ 1 ] ) ;\n mv1 = pack16to32 ( mv_l0 [ 0 ] - mv_col [ 0 ] , mv_l0 [ 1 ] - mv_col [ 1 ] ) ;\n }\n fill_rectangle ( & h -> ref_cache [ 0 ] [ scan8 [ 0 ] ] , 4 , 4 , 8 , ref , 1 ) ;\n fill_rectangle ( & h -> mv_cache [ 0 ] [ scan8 [ 0 ] ] , 4 , 4 , 8 , mv0 , 4 ) ;\n fill_rectangle ( & h -> mv_cache [ 1 ] [ scan8 [ 0 ] ] , 4 , 4 , 8 , mv1 , 4 ) ;\n }\n else {\n for ( i8 = 0 ;\n i8 < 4 ;\n i8 ++ ) {\n const int x8 = i8 & 1 ;\n const int y8 = i8 >> 1 ;\n int ref0 , scale ;\n const int16_t ( * l1mv ) [ 2 ] = l1mv0 ;\n if ( is_b8x8 && ! IS_DIRECT ( h -> sub_mb_type [ i8 ] ) ) continue ;\n h -> sub_mb_type [ i8 ] = sub_mb_type ;\n fill_rectangle ( & h -> ref_cache [ 1 ] [ scan8 [ i8 * 4 ] ] , 2 , 2 , 8 , 0 , 1 ) ;\n if ( IS_INTRA ( mb_type_col [ 0 ] ) ) {\n fill_rectangle ( & h -> ref_cache [ 0 ] [ scan8 [ i8 * 4 ] ] , 2 , 2 , 8 , 0 , 1 ) ;\n fill_rectangle ( & h -> mv_cache [ 0 ] [ scan8 [ i8 * 4 ] ] , 2 , 2 , 8 , 0 , 4 ) ;\n fill_rectangle ( & h -> mv_cache [ 1 ] [ scan8 [ i8 * 4 ] ] , 2 , 2 , 8 , 0 , 4 ) ;\n continue ;\n }\n assert ( b8_stride == 2 ) ;\n ref0 = l1ref0 [ i8 ] ;\n if ( ref0 >= 0 ) ref0 = map_col_to_list0 [ 0 ] [ ref0 + ref_offset ] ;\n else {\n ref0 = map_col_to_list0 [ 1 ] [ l1ref1 [ i8 ] + ref_offset ] ;\n l1mv = l1mv1 ;\n }\n scale = dist_scale_factor [ ref0 ] ;\n fill_rectangle ( & h -> ref_cache [ 0 ] [ scan8 [ i8 * 4 ] ] , 2 , 2 , 8 , ref0 , 1 ) ;\n if ( IS_SUB_8X8 ( sub_mb_type ) ) {\n const int16_t * mv_col = l1mv [ x8 * 3 + y8 * 3 * b4_stride ] ;\n int mx = ( scale * mv_col [ 0 ] + 128 ) >> 8 ;\n int my = ( scale * mv_col [ 1 ] + 128 ) >> 8 ;\n fill_rectangle ( & h -> mv_cache [ 0 ] [ scan8 [ i8 * 4 ] ] , 2 , 2 , 8 , pack16to32 ( mx , my ) , 4 ) ;\n fill_rectangle ( & h -> mv_cache [ 1 ] [ scan8 [ i8 * 4 ] ] , 2 , 2 , 8 , pack16to32 ( mx - mv_col [ 0 ] , my - mv_col [ 1 ] ) , 4 ) ;\n }\n else for ( i4 = 0 ;\n i4 < 4 ;\n i4 ++ ) {\n const int16_t * mv_col = l1mv [ x8 * 2 + ( i4 & 1 ) + ( y8 * 2 + ( i4 >> 1 ) ) * b4_stride ] ;\n int16_t * mv_l0 = h -> mv_cache [ 0 ] [ scan8 [ i8 * 4 + i4 ] ] ;\n mv_l0 [ 0 ] = ( scale * mv_col [ 0 ] + 128 ) >> 8 ;\n mv_l0 [ 1 ] = ( scale * mv_col [ 1 ] + 128 ) >> 8 ;\n AV_WN32A ( h -> mv_cache [ 1 ] [ scan8 [ i8 * 4 + i4 ] ] , pack16to32 ( mv_l0 [ 0 ] - mv_col [ 0 ] , mv_l0 [ 1 ] - mv_col [ 1 ] ) ) ;\n }\n }\n }\n }\n }", "idx": 1406}
{"hash": 1245821301839614810, "project": "debian", "size": 290, "label": 0, "functionSource": "static void copy_move_file ( CopyMoveJob * copy_job , GFile * src , GFile * dest_dir , gboolean same_fs , gboolean unique_names , char * * dest_fs_type , SourceInfo * source_info , TransferInfo * transfer_info , GHashTable * debuting_files , GdkPoint * position , gboolean overwrite , gboolean * skipped_file , gboolean readonly_source_fs ) {\n GFile * dest , * new_dest ;\n g_autofree gchar * dest_uri = NULL ;\n GError * error ;\n GFileCopyFlags flags ;\n char * primary , * secondary , * details ;\n int response ;\n ProgressData pdata ;\n gboolean would_recurse , is_merge ;\n CommonJob * job ;\n gboolean res ;\n int unique_name_nr ;\n gboolean handled_invalid_filename ;\n job = ( CommonJob * ) copy_job ;\n if ( should_skip_file ( job , src ) ) {\n * skipped_file = TRUE ;\n return ;\n }\n unique_name_nr = 1 ;\n handled_invalid_filename = * dest_fs_type != NULL ;\n if ( unique_names ) {\n dest = get_unique_target_file ( src , dest_dir , same_fs , * dest_fs_type , unique_name_nr ++ ) ;\n }\n else if ( copy_job -> target_name != NULL ) {\n dest = get_target_file_with_custom_name ( src , dest_dir , * dest_fs_type , same_fs , copy_job -> target_name ) ;\n }\n else {\n dest = get_target_file ( src , dest_dir , * dest_fs_type , same_fs ) ;\n }\n if ( test_dir_is_parent ( dest_dir , src ) ) {\n if ( job -> skip_all_error ) {\n goto out ;\n }\n primary = copy_job -> is_move ? g_strdup ( _ ( \"You cannot move a folder into itself.\" ) ) : g_strdup ( _ ( \"You cannot copy a folder into itself.\" ) ) ;\n secondary = g_strdup ( _ ( \"The destination folder is inside the source folder.\" ) ) ;\n response = run_cancel_or_skip_warning ( job , primary , secondary , NULL , source_info -> num_files , source_info -> num_files - transfer_info -> num_files ) ;\n if ( response == 0 || response == GTK_RESPONSE_DELETE_EVENT ) {\n abort_job ( job ) ;\n }\n else if ( response == 1 ) {\n job -> skip_all_error = TRUE ;\n }\n else if ( response == 2 ) {\n }\n else {\n g_assert_not_reached ( ) ;\n }\n goto out ;\n }\n if ( test_dir_is_parent ( src , dest ) ) {\n if ( job -> skip_all_error ) {\n goto out ;\n }\n primary = copy_job -> is_move ? g_strdup ( _ ( \"You cannot move a file over itself.\" ) ) : g_strdup ( _ ( \"You cannot copy a file over itself.\" ) ) ;\n secondary = g_strdup ( _ ( \"The source file would be overwritten by the destination.\" ) ) ;\n response = run_cancel_or_skip_warning ( job , primary , secondary , NULL , source_info -> num_files , source_info -> num_files - transfer_info -> num_files ) ;\n if ( response == 0 || response == GTK_RESPONSE_DELETE_EVENT ) {\n abort_job ( job ) ;\n }\n else if ( response == 1 ) {\n job -> skip_all_error = TRUE ;\n }\n else if ( response == 2 ) {\n }\n else {\n g_assert_not_reached ( ) ;\n }\n goto out ;\n }\n retry : error = NULL ;\n flags = G_FILE_COPY_NOFOLLOW_SYMLINKS ;\n if ( overwrite ) {\n flags |= G_FILE_COPY_OVERWRITE ;\n }\n if ( readonly_source_fs ) {\n flags |= G_FILE_COPY_TARGET_DEFAULT_PERMS ;\n }\n pdata . job = copy_job ;\n pdata . last_size = 0 ;\n pdata . source_info = source_info ;\n pdata . transfer_info = transfer_info ;\n if ( copy_job -> is_move ) {\n res = g_file_move ( src , dest , flags , job -> cancellable , copy_file_progress_callback , & pdata , & error ) ;\n }\n else {\n res = g_file_copy ( src , dest , flags , job -> cancellable , copy_file_progress_callback , & pdata , & error ) ;\n }\n if ( res ) {\n GFile * real ;\n real = map_possibly_volatile_file_to_real ( dest , job -> cancellable , & error ) ;\n if ( real == NULL ) {\n res = FALSE ;\n }\n else {\n g_object_unref ( dest ) ;\n dest = real ;\n }\n }\n if ( res ) {\n transfer_info -> num_files ++ ;\n report_copy_progress ( copy_job , source_info , transfer_info ) ;\n if ( debuting_files ) {\n dest_uri = g_file_get_uri ( dest ) ;\n if ( position ) {\n nautilus_file_changes_queue_schedule_position_set ( dest , * position , job -> screen_num ) ;\n }\n else if ( eel_uri_is_desktop ( dest_uri ) ) {\n nautilus_file_changes_queue_schedule_position_remove ( dest ) ;\n }\n g_hash_table_replace ( debuting_files , g_object_ref ( dest ) , GINT_TO_POINTER ( TRUE ) ) ;\n }\n if ( copy_job -> is_move ) {\n nautilus_file_changes_queue_file_moved ( src , dest ) ;\n }\n else {\n nautilus_file_changes_queue_file_added ( dest ) ;\n }\n if ( copy_job -> desktop_location != NULL && g_file_equal ( copy_job -> desktop_location , dest_dir ) && is_trusted_desktop_file ( src , job -> cancellable ) ) {\n mark_desktop_file_executable ( job , job -> cancellable , dest , FALSE ) ;\n }\n if ( job -> undo_info != NULL ) {\n nautilus_file_undo_info_ext_add_origin_target_pair ( NAUTILUS_FILE_UNDO_INFO_EXT ( job -> undo_info ) , src , dest ) ;\n }\n g_object_unref ( dest ) ;\n return ;\n }\n if ( ! handled_invalid_filename && IS_IO_ERROR ( error , INVALID_FILENAME ) ) {\n handled_invalid_filename = TRUE ;\n g_assert ( * dest_fs_type == NULL ) ;\n * dest_fs_type = query_fs_type ( dest_dir , job -> cancellable ) ;\n if ( unique_names ) {\n new_dest = get_unique_target_file ( src , dest_dir , same_fs , * dest_fs_type , unique_name_nr ) ;\n }\n else {\n new_dest = get_target_file ( src , dest_dir , * dest_fs_type , same_fs ) ;\n }\n if ( ! g_file_equal ( dest , new_dest ) ) {\n g_object_unref ( dest ) ;\n dest = new_dest ;\n g_error_free ( error ) ;\n goto retry ;\n }\n else {\n g_object_unref ( new_dest ) ;\n }\n }\n if ( ! overwrite && IS_IO_ERROR ( error , EXISTS ) ) {\n gboolean is_merge ;\n FileConflictResponse * response ;\n g_error_free ( error ) ;\n if ( unique_names ) {\n g_object_unref ( dest ) ;\n dest = get_unique_target_file ( src , dest_dir , same_fs , * dest_fs_type , unique_name_nr ++ ) ;\n goto retry ;\n }\n is_merge = FALSE ;\n if ( is_dir ( dest ) && is_dir ( src ) ) {\n is_merge = TRUE ;\n }\n if ( ( is_merge && job -> merge_all ) || ( ! is_merge && job -> replace_all ) ) {\n overwrite = TRUE ;\n goto retry ;\n }\n if ( job -> skip_all_conflict ) {\n goto out ;\n }\n response = handle_copy_move_conflict ( job , src , dest , dest_dir ) ;\n if ( response -> id == GTK_RESPONSE_CANCEL || response -> id == GTK_RESPONSE_DELETE_EVENT ) {\n file_conflict_response_free ( response ) ;\n abort_job ( job ) ;\n }\n else if ( response -> id == CONFLICT_RESPONSE_SKIP ) {\n if ( response -> apply_to_all ) {\n job -> skip_all_conflict = TRUE ;\n }\n file_conflict_response_free ( response ) ;\n }\n else if ( response -> id == CONFLICT_RESPONSE_REPLACE ) {\n if ( response -> apply_to_all ) {\n if ( is_merge ) {\n job -> merge_all = TRUE ;\n }\n else {\n job -> replace_all = TRUE ;\n }\n }\n overwrite = TRUE ;\n file_conflict_response_free ( response ) ;\n goto retry ;\n }\n else if ( response -> id == CONFLICT_RESPONSE_RENAME ) {\n g_object_unref ( dest ) ;\n dest = get_target_file_for_display_name ( dest_dir , response -> new_name ) ;\n file_conflict_response_free ( response ) ;\n goto retry ;\n }\n else {\n g_assert_not_reached ( ) ;\n }\n }\n else if ( overwrite && IS_IO_ERROR ( error , IS_DIRECTORY ) ) {\n gboolean existing_file_deleted ;\n DeleteExistingFileData data ;\n g_error_free ( error ) ;\n data . job = job ;\n data . source = src ;\n existing_file_deleted = delete_file_recursively ( dest , job -> cancellable , existing_file_removed_callback , & data ) ;\n if ( existing_file_deleted ) {\n goto retry ;\n }\n }\n else if ( IS_IO_ERROR ( error , WOULD_RECURSE ) || IS_IO_ERROR ( error , WOULD_MERGE ) ) {\n is_merge = error -> code == G_IO_ERROR_WOULD_MERGE ;\n would_recurse = error -> code == G_IO_ERROR_WOULD_RECURSE ;\n g_error_free ( error ) ;\n if ( overwrite && would_recurse ) {\n error = NULL ;\n if ( ! g_file_delete ( dest , job -> cancellable , & error ) && ! IS_IO_ERROR ( error , NOT_FOUND ) ) {\n if ( job -> skip_all_error ) {\n g_error_free ( error ) ;\n goto out ;\n }\n if ( copy_job -> is_move ) {\n primary = f ( _ ( \"Error while moving \u201c%B\u201d.\" ) , src ) ;\n }\n else {\n primary = f ( _ ( \"Error while copying \u201c%B\u201d.\" ) , src ) ;\n }\n secondary = f ( _ ( \"Could not remove the already existing file with the same name in %F.\" ) , dest_dir ) ;\n details = error -> message ;\n response = run_warning ( job , primary , secondary , details , TRUE , CANCEL , SKIP_ALL , SKIP , NULL ) ;\n g_error_free ( error ) ;\n if ( response == 0 || response == GTK_RESPONSE_DELETE_EVENT ) {\n abort_job ( job ) ;\n }\n else if ( response == 1 ) {\n job -> skip_all_error = TRUE ;\n }\n else if ( response == 2 ) {\n }\n else {\n g_assert_not_reached ( ) ;\n }\n goto out ;\n }\n if ( error ) {\n g_error_free ( error ) ;\n error = NULL ;\n }\n nautilus_file_changes_queue_file_removed ( dest ) ;\n }\n if ( is_merge ) {\n same_fs = FALSE ;\n }\n if ( ! copy_move_directory ( copy_job , src , & dest , same_fs , would_recurse , dest_fs_type , source_info , transfer_info , debuting_files , skipped_file , readonly_source_fs ) ) {\n g_assert ( * dest_fs_type != NULL ) ;\n handled_invalid_filename = TRUE ;\n goto retry ;\n }\n g_object_unref ( dest ) ;\n return ;\n }\n else if ( IS_IO_ERROR ( error , CANCELLED ) ) {\n g_error_free ( error ) ;\n }\n else {\n if ( job -> skip_all_error ) {\n g_error_free ( error ) ;\n goto out ;\n }\n primary = f ( _ ( \"Error while copying \u201c%B\u201d.\" ) , src ) ;\n secondary = f ( _ ( \"There was an error copying the file into %F.\" ) , dest_dir ) ;\n details = error -> message ;\n response = run_cancel_or_skip_warning ( job , primary , secondary , details , source_info -> num_files , source_info -> num_files - transfer_info -> num_files ) ;\n g_error_free ( error ) ;\n if ( response == 0 || response == GTK_RESPONSE_DELETE_EVENT ) {\n abort_job ( job ) ;\n }\n else if ( response == 1 ) {\n job -> skip_all_error = TRUE ;\n }\n else if ( response == 2 ) {\n }\n else {\n g_assert_not_reached ( ) ;\n }\n }\n out : * skipped_file = TRUE ;\n g_object_unref ( dest ) ;\n }", "idx": 1407}
{"hash": 2546373479020365143, "project": "debian", "size": 10, "label": 0, "functionSource": "const char * mime_str_u16_set ( HdrHeap * heap , const char * s_str , int s_len , const char * * d_str , uint16_t * d_len , bool must_copy ) {\n ink_assert ( s_len >= 0 && s_len < UINT16_MAX ) ;\n heap -> free_string ( * d_str , * d_len ) ;\n if ( must_copy && s_str ) {\n s_str = heap -> duplicate_str ( s_str , s_len ) ;\n }\n * d_str = s_str ;\n * d_len = s_len ;\n return s_str ;\n }", "idx": 1408}
{"hash": 1223258652239369123, "project": "debian", "size": 12, "label": 0, "functionSource": "static void spl_filesystem_tree_it_dtor ( zend_object_iterator * iter TSRMLS_DC ) {\n spl_filesystem_iterator * iterator = ( spl_filesystem_iterator * ) iter ;\n if ( iterator -> intern . data ) {\n zval * object = iterator -> intern . data ;\n zval_ptr_dtor ( & object ) ;\n }\n else {\n if ( iterator -> current ) {\n zval_ptr_dtor ( & iterator -> current ) ;\n }\n }\n }", "idx": 1409}
{"hash": 8461782184979846246, "project": "chrome", "size": 9, "label": 0, "functionSource": "TEST_F ( ProtocolHandlerRegistryTest , TestLoadEnabledGetsPropogatedToIO ) {\n std : : string mailto ( \"mailto\" ) ;\n ProtocolHandler ph1 = CreateProtocolHandler ( mailto , \"MailtoHandler\" ) ;\n registry ( ) -> OnAcceptRegisterProtocolHandler ( ph1 ) ;\n scoped_ptr < ProtocolHandlerRegistry : : JobInterceptorFactory > interceptor ( registry ( ) -> CreateJobInterceptorFactory ( ) ) ;\n AssertWillHandle ( mailto , true , interceptor . get ( ) ) ;\n registry ( ) -> Disable ( ) ;\n AssertWillHandle ( mailto , false , interceptor . get ( ) ) ;\n }", "idx": 1410}
{"hash": -5689214734378699681, "project": "debian", "size": 24, "label": 0, "functionSource": "static PyObject * _cbson_dict_to_bson ( PyObject * self , PyObject * args ) {\n PyObject * dict ;\n PyObject * result ;\n unsigned char check_keys ;\n unsigned char uuid_subtype ;\n unsigned char top_level = 1 ;\n buffer_t buffer ;\n if ( ! PyArg_ParseTuple ( args , \"Obb|b\" , & dict , & check_keys , & uuid_subtype , & top_level ) ) {\n return NULL ;\n }\n buffer = buffer_new ( ) ;\n if ( ! buffer ) {\n PyErr_NoMemory ( ) ;\n return NULL ;\n }\n if ( ! write_dict ( self , buffer , dict , check_keys , uuid_subtype , top_level ) ) {\n buffer_free ( buffer ) ;\n return NULL ;\n }\n # if PY_MAJOR_VERSION >= 3 result = Py_BuildValue ( \"y#\" , buffer_get_buffer ( buffer ) , buffer_get_position ( buffer ) ) ;\n # else result = Py_BuildValue ( \"s#\" , buffer_get_buffer ( buffer ) , buffer_get_position ( buffer ) ) ;\n # endif buffer_free ( buffer ) ;\n return result ;\n }", "idx": 1411}
{"hash": -2908211205972632000, "project": "debian", "size": 14, "label": 0, "functionSource": "static int try_rshrink_right ( MAIN_WINDOW_REC * window , int count ) {\n MAIN_WINDOW_REC * shrink_win ;\n shrink_win = mainwindows_find_right ( window , FALSE ) ;\n if ( shrink_win != NULL ) {\n if ( MAIN_WINDOW_TEXT_WIDTH ( shrink_win ) - count < NEW_WINDOW_WIDTH ) {\n return FALSE ;\n }\n shrink_win -> first_column += count ;\n window -> last_column += count ;\n mainwindows_rresize_two ( window , shrink_win , count ) ;\n return TRUE ;\n }\n return FALSE ;\n }", "idx": 1412}
{"hash": -2607754285145856562, "project": "debian", "size": 11, "label": 0, "functionSource": "static void idr_extend_identifier ( struct idrent * wnp , int numsize , int nullsize ) {\n unsigned char * p ;\n int wnp_ext_off ;\n wnp_ext_off = wnp -> isoent -> ext_off ;\n if ( wnp -> noff + numsize != wnp_ext_off ) {\n p = ( unsigned char * ) wnp -> isoent -> identifier ;\n memmove ( p + wnp -> noff + numsize , p + wnp_ext_off , wnp -> isoent -> ext_len + nullsize ) ;\n wnp -> isoent -> ext_off = wnp_ext_off = wnp -> noff + numsize ;\n wnp -> isoent -> id_len = wnp_ext_off + wnp -> isoent -> ext_len ;\n }\n }", "idx": 1413}
{"hash": 6675626110148442062, "project": "debian", "size": 4, "label": 0, "functionSource": "static int file_write ( jas_stream_obj_t * obj , char * buf , int cnt ) {\n jas_stream_fileobj_t * fileobj = JAS_CAST ( jas_stream_fileobj_t * , obj ) ;\n return write ( fileobj -> fd , buf , cnt ) ;\n }", "idx": 1414}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_T_t35Extension ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_constrained_integer ( tvb , offset , actx , tree , hf_index , 0U , 255U , & t35Extension , FALSE ) ;\n return offset ;\n }", "idx": 1415}
{"hash": -7187272991279783781, "project": "debian", "size": 2, "label": 0, "functionSource": "void DMA_release_DREQ ( int nchan ) {\n }", "idx": 1416}
{"hash": -5493081488206619677, "project": "debian", "size": 8, "label": 0, "functionSource": "static const char * cmd_data_dir ( cmd_parms * cmd , void * _dcfg , const char * p1 ) {\n directory_config * dcfg = ( directory_config * ) _dcfg ;\n if ( cmd -> server -> is_virtual ) {\n return \"ModSecurity: SecDataDir not allowed in VirtualHost.\" ;\n }\n dcfg -> data_dir = ap_server_root_relative ( cmd -> pool , p1 ) ;\n return NULL ;\n }", "idx": 1417}
{"hash": -192019917869801237, "project": "debian", "size": 4, "label": 0, "functionSource": "static void protobuf_seek_forward ( protobuf_desc_t * pb , gint len ) {\n pb -> offset += len ;\n pb -> bytes_left -= len ;\n }", "idx": 1418}
{"hash": 3584320764213684062, "project": "debian", "size": 71, "label": 0, "functionSource": "static int dissect_mswsp ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , gboolean in , void * data ) {\n proto_tree * mswsp_tree = NULL ;\n proto_tree * hdr_tree ;\n proto_item * ti , * hti ;\n guint32 msg ;\n guint32 status ;\n if ( tvb_reported_length ( tvb ) < 16 ) {\n return 0 ;\n }\n col_append_str ( pinfo -> cinfo , COL_PROTOCOL , \" WSP\" ) ;\n col_set_str ( pinfo -> cinfo , COL_INFO , \"WSP \" ) ;\n col_append_str ( pinfo -> cinfo , COL_INFO , in ? \"Request: \" : \"Response: \" ) ;\n ti = proto_tree_add_item ( tree , proto_mswsp , tvb , 0 , - 1 , ENC_NA ) ;\n mswsp_tree = proto_item_add_subtree ( ti , ett_mswsp ) ;\n hti = proto_tree_add_item ( mswsp_tree , hf_mswsp_hdr , tvb , 0 , 16 , ENC_NA ) ;\n hdr_tree = proto_item_add_subtree ( hti , ett_mswsp_hdr ) ;\n proto_tree_add_item_ret_uint ( hdr_tree , hf_mswsp_hdr_msg , tvb , 0 , 4 , ENC_LITTLE_ENDIAN , & msg ) ;\n proto_item_append_text ( hti , \" %s\" , val_to_str ( msg , VALS ( msg_ids ) , \"(Unknown: 0x%x)\" ) ) ;\n proto_tree_add_item_ret_uint ( hdr_tree , hf_mswsp_hdr_status , tvb , 4 , 4 , ENC_LITTLE_ENDIAN , & status ) ;\n if ( ! in || status != 0 ) {\n proto_item_append_text ( hti , \" %s\" , val_to_str ( status , VALS ( dcom_hresult_vals ) , \"(Unknown: 0x%x)\" ) ) ;\n }\n proto_tree_add_checksum ( hdr_tree , tvb , 8 , hf_mswsp_hdr_checksum , - 1 , NULL , pinfo , 0 , ENC_LITTLE_ENDIAN , PROTO_CHECKSUM_NO_FLAGS ) ;\n proto_tree_add_item ( hdr_tree , hf_mswsp_hdr_reserved , tvb , 12 , 4 , ENC_LITTLE_ENDIAN ) ;\n switch ( msg ) {\n case 0xC8 : dissect_CPMConnect ( tvb , pinfo , tree , in , data ) ;\n break ;\n case 0xC9 : dissect_CPMDisconnect ( tvb , pinfo , tree , in , data ) ;\n break ;\n case 0xCA : dissect_CPMCreateQuery ( tvb , pinfo , tree , in , data ) ;\n break ;\n case 0xCB : dissect_CPMFreeCursor ( tvb , pinfo , tree , in , data ) ;\n break ;\n case 0xCC : dissect_CPMGetRows ( tvb , pinfo , tree , in , data ) ;\n break ;\n case 0xCD : dissect_CPMRatioFinished ( tvb , pinfo , tree , in , data ) ;\n break ;\n case 0xCE : dissect_CPMCompareBmk ( tvb , pinfo , tree , in , data ) ;\n break ;\n case 0xCF : dissect_CPMGetApproximatePosition ( tvb , pinfo , tree , in , data ) ;\n break ;\n case 0xD0 : dissect_CPMSetBindings ( tvb , pinfo , tree , in , data ) ;\n break ;\n case 0xD1 : dissect_CPMGetNotify ( tvb , pinfo , tree , in , data ) ;\n break ;\n case 0xD2 : dissect_CPMSendNotifyOut ( tvb , pinfo , tree , in , data ) ;\n break ;\n case 0xD7 : dissect_CPMGetQueryStatus ( tvb , pinfo , tree , in , data ) ;\n break ;\n case 0xD9 : dissect_CPMCiState ( tvb , pinfo , tree , in , data ) ;\n break ;\n case 0xE4 : dissect_CPMFetchValue ( tvb , pinfo , tree , in , data ) ;\n break ;\n case 0xE7 : dissect_CPMGetQueryStatusEx ( tvb , pinfo , tree , in , data ) ;\n break ;\n case 0xE8 : dissect_CPMRestartPosition ( tvb , pinfo , tree , in , data ) ;\n break ;\n case 0xEC : dissect_CPMSetCatState ( tvb , pinfo , tree , in , data ) ;\n break ;\n case 0xF1 : dissect_CPMGetRowsetNotify ( tvb , pinfo , tree , in , data ) ;\n break ;\n case 0xF2 : dissect_CPMFindIndices ( tvb , pinfo , tree , in , data ) ;\n break ;\n case 0xF3 : dissect_CPMSetScopePrioritization ( tvb , pinfo , tree , in , data ) ;\n break ;\n case 0xF4 : dissect_CPMGetScopeStatistics ( tvb , pinfo , tree , in , data ) ;\n break ;\n default : return 0 ;\n }\n return tvb_reported_length ( tvb ) ;\n }", "idx": 1419}
{"hash": 2578089348587614328, "project": "debian", "size": 3, "label": 1, "functionSource": "int X509_verify ( X509 * a , EVP_PKEY * r ) {\n return ( ASN1_item_verify ( ASN1_ITEM_rptr ( X509_CINF ) , a -> sig_alg , a -> signature , a -> cert_info , r ) ) ;\n }", "idx": 1420}
{"hash": 1773163316021227217, "project": "debian", "size": 23, "label": 0, "functionSource": "void fe_channels_init ( void ) {\n settings_add_bool ( \"lookandfeel\" , \"autoclose_windows\" , TRUE ) ;\n settings_add_bool ( \"lookandfeel\" , \"show_names_on_join\" , TRUE ) ;\n settings_add_int ( \"lookandfeel\" , \"names_max_columns\" , 6 ) ;\n settings_add_int ( \"lookandfeel\" , \"names_max_width\" , 0 ) ;\n signal_add ( \"channel created\" , ( SIGNAL_FUNC ) signal_channel_created ) ;\n signal_add ( \"channel destroyed\" , ( SIGNAL_FUNC ) signal_channel_destroyed ) ;\n signal_add_last ( \"window item changed\" , ( SIGNAL_FUNC ) signal_window_item_changed ) ;\n signal_add_last ( \"server disconnected\" , ( SIGNAL_FUNC ) sig_disconnected ) ;\n signal_add_last ( \"channel joined\" , ( SIGNAL_FUNC ) sig_channel_joined ) ;\n command_bind ( \"join\" , NULL , ( SIGNAL_FUNC ) cmd_join ) ;\n command_bind ( \"channel\" , NULL , ( SIGNAL_FUNC ) cmd_channel ) ;\n command_bind ( \"channel add\" , NULL , ( SIGNAL_FUNC ) cmd_channel_add ) ;\n command_bind ( \"channel modify\" , NULL , ( SIGNAL_FUNC ) cmd_channel_modify ) ;\n command_bind ( \"channel remove\" , NULL , ( SIGNAL_FUNC ) cmd_channel_remove ) ;\n command_bind ( \"channel list\" , NULL , ( SIGNAL_FUNC ) cmd_channel_list ) ;\n command_bind ( \"names\" , NULL , ( SIGNAL_FUNC ) cmd_names ) ;\n command_bind ( \"cycle\" , NULL , ( SIGNAL_FUNC ) cmd_cycle ) ;\n command_set_options ( \"channel add\" , \"auto noauto -bots -botcmd\" ) ;\n command_set_options ( \"channel modify\" , \"auto noauto -bots -botcmd\" ) ;\n command_set_options ( \"names\" , \"count ops halfops voices normal\" ) ;\n command_set_options ( \"join\" , \"invite window\" ) ;\n }", "idx": 1421}
{"hash": 4489017523191997023, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h225_INTEGER_1_256 ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_constrained_integer ( tvb , offset , actx , tree , hf_index , 1U , 256U , NULL , FALSE ) ;\n return offset ;\n }", "idx": 1422}
{"hash": -7555034601056330007, "project": "debian", "size": 3, "label": 0, "functionSource": "void virLogUnlock ( void ) {\n virMutexUnlock ( & virLogMutex ) ;\n }", "idx": 1423}
{"hash": -7237039260294671485, "project": "debian", "size": 30, "label": 0, "functionSource": "static int dissect_lock ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , int version , int offset , rpc_call_info_value * civ ) {\n proto_item * lock_item = NULL ;\n proto_tree * lock_tree = NULL ;\n guint32 fh_hash , svid , start_offset = 0 , end_offset = 0 ;\n if ( tree ) {\n lock_item = proto_tree_add_item ( tree , hf_nlm_lock , tvb , offset , - 1 , ENC_NA ) ;\n if ( lock_item ) lock_tree = proto_item_add_subtree ( lock_item , ett_nlm_lock ) ;\n }\n offset = dissect_rpc_string ( tvb , lock_tree , hf_nlm_lock_caller_name , offset , NULL ) ;\n offset = dissect_nfs3_fh ( tvb , offset , pinfo , lock_tree , \"fh\" , & fh_hash , civ ) ;\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \" FH:0x%08x\" , fh_hash ) ;\n offset = dissect_rpc_data ( tvb , lock_tree , hf_nlm_lock_owner , offset ) ;\n svid = tvb_get_ntohl ( tvb , offset ) ;\n offset = dissect_rpc_uint32 ( tvb , lock_tree , hf_nlm_lock_svid , offset ) ;\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \" svid:%d\" , svid ) ;\n if ( version == 4 ) {\n start_offset = tvb_get_ntohl ( tvb , offset ) ;\n offset = dissect_rpc_uint64 ( tvb , lock_tree , hf_nlm_lock_l_offset64 , offset ) ;\n end_offset = tvb_get_ntohl ( tvb , offset ) ;\n offset = dissect_rpc_uint64 ( tvb , lock_tree , hf_nlm_lock_l_len64 , offset ) ;\n }\n else {\n start_offset = tvb_get_ntohl ( tvb , offset ) ;\n offset = dissect_rpc_uint32 ( tvb , lock_tree , hf_nlm_lock_l_offset , offset ) ;\n end_offset = tvb_get_ntohl ( tvb , offset ) ;\n offset = dissect_rpc_uint32 ( tvb , lock_tree , hf_nlm_lock_l_len , offset ) ;\n }\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \" pos:%d-%d\" , start_offset , end_offset ) ;\n return offset ;\n }", "idx": 1424}
{"hash": 7783404437431406265, "project": "debian", "size": 4, "label": 0, "functionSource": "static bool myisam_is_supported_system_table ( const char * db , const char * table_name , bool is_sql_layer_system_table ) {\n if ( is_sql_layer_system_table ) return true ;\n return false ;\n }", "idx": 1425}
{"hash": -4239386405881995323, "project": "chrome", "size": 3, "label": 0, "functionSource": "int xmlHashAddEntry ( xmlHashTablePtr table , const xmlChar * name , void * userdata ) {\n return ( xmlHashAddEntry3 ( table , name , NULL , NULL , userdata ) ) ;\n }", "idx": 1426}
{"hash": 6250095321513210169, "project": "debian", "size": 16, "label": 1, "functionSource": "static rfbBool rectSwapIfLEAndClip ( uint16_t * x , uint16_t * y , uint16_t * w , uint16_t * h , rfbClientPtr cl ) {\n int x1 = Swap16IfLE ( * x ) ;\n int y1 = Swap16IfLE ( * y ) ;\n int w1 = Swap16IfLE ( * w ) ;\n int h1 = Swap16IfLE ( * h ) ;\n rfbScaledCorrection ( cl -> scaledScreen , cl -> screen , & x1 , & y1 , & w1 , & h1 , \"rectSwapIfLEAndClip\" ) ;\n * x = x1 ;\n * y = y1 ;\n * w = w1 ;\n * h = h1 ;\n if ( * w > cl -> screen -> width - * x ) * w = cl -> screen -> width - * x ;\n if ( * w > cl -> screen -> width - * x ) return FALSE ;\n if ( * h > cl -> screen -> height - * y ) * h = cl -> screen -> height - * y ;\n if ( * h > cl -> screen -> height - * y ) return FALSE ;\n return TRUE ;\n }", "idx": 1427}
{"hash": -1315695702746584250, "project": "debian", "size": 15, "label": 0, "functionSource": "proto_item * ptvcursor_add ( ptvcursor_t * ptvc , int hfindex , gint length , const guint encoding ) {\n field_info * new_fi ;\n header_field_info * hfinfo ;\n gint item_length ;\n int offset ;\n offset = ptvc -> offset ;\n PROTO_REGISTRAR_GET_NTH ( hfindex , hfinfo ) ;\n get_hfi_length ( hfinfo , ptvc -> tvb , offset , & length , & item_length ) ;\n test_length ( hfinfo , ptvc -> tvb , offset , item_length ) ;\n ptvc -> offset += get_full_length ( hfinfo , ptvc -> tvb , offset , length , item_length , encoding ) ;\n CHECK_FOR_NULL_TREE ( ptvc -> tree ) ;\n TRY_TO_FAKE_THIS_ITEM ( ptvc -> tree , hfindex , hfinfo ) ;\n new_fi = new_field_info ( ptvc -> tree , hfinfo , ptvc -> tvb , offset , item_length ) ;\n return proto_tree_new_item ( new_fi , ptvc -> tree , ptvc -> tvb , offset , length , encoding ) ;\n }", "idx": 1428}
{"hash": -5706788925640467782, "project": "chrome", "size": 73, "label": 1, "functionSource": "static void encode_superblock ( VP9_COMP * cpi , TOKENEXTRA * * t , int output_enabled , int mi_row , int mi_col , BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx ) {\n VP9_COMMON * const cm = & cpi -> common ;\n MACROBLOCK * const x = & cpi -> mb ;\n MACROBLOCKD * const xd = & x -> e_mbd ;\n MODE_INFO * * mi_8x8 = xd -> mi ;\n MODE_INFO * mi = mi_8x8 [ 0 ] ;\n MB_MODE_INFO * mbmi = & mi -> mbmi ;\n const int seg_skip = vp9_segfeature_active ( & cm -> seg , mbmi -> segment_id , SEG_LVL_SKIP ) ;\n const int mis = cm -> mi_stride ;\n const int mi_width = num_8x8_blocks_wide_lookup [ bsize ] ;\n const int mi_height = num_8x8_blocks_high_lookup [ bsize ] ;\n x -> skip_recode = ! x -> select_tx_size && mbmi -> sb_type >= BLOCK_8X8 && cpi -> oxcf . aq_mode != COMPLEXITY_AQ && cpi -> oxcf . aq_mode != CYCLIC_REFRESH_AQ && cpi -> sf . allow_skip_recode ;\n if ( ! x -> skip_recode && ! cpi -> sf . use_nonrd_pick_mode ) vpx_memset ( x -> skip_txfm , 0 , sizeof ( x -> skip_txfm ) ) ;\n x -> skip_optimize = ctx -> is_coded ;\n ctx -> is_coded = 1 ;\n x -> use_lp32x32fdct = cpi -> sf . use_lp32x32fdct ;\n x -> skip_encode = ( ! output_enabled && cpi -> sf . skip_encode_frame && x -> q_index < QIDX_SKIP_THRESH ) ;\n if ( x -> skip_encode ) return ;\n set_ref_ptrs ( cm , xd , mbmi -> ref_frame [ 0 ] , mbmi -> ref_frame [ 1 ] ) ;\n cpi -> zbin_mode_boost = get_zbin_mode_boost ( mbmi , cpi -> zbin_mode_boost_enabled ) ;\n vp9_update_zbin_extra ( cpi , x ) ;\n if ( ! is_inter_block ( mbmi ) ) {\n int plane ;\n mbmi -> skip = 1 ;\n for ( plane = 0 ;\n plane < MAX_MB_PLANE ;\n ++ plane ) vp9_encode_intra_block_plane ( x , MAX ( bsize , BLOCK_8X8 ) , plane ) ;\n if ( output_enabled ) sum_intra_stats ( & cm -> counts , mi ) ;\n vp9_tokenize_sb ( cpi , t , ! output_enabled , MAX ( bsize , BLOCK_8X8 ) ) ;\n }\n else {\n int ref ;\n const int is_compound = has_second_ref ( mbmi ) ;\n for ( ref = 0 ;\n ref < 1 + is_compound ;\n ++ ref ) {\n YV12_BUFFER_CONFIG * cfg = get_ref_frame_buffer ( cpi , mbmi -> ref_frame [ ref ] ) ;\n vp9_setup_pre_planes ( xd , ref , cfg , mi_row , mi_col , & xd -> block_refs [ ref ] -> sf ) ;\n }\n if ( ! cpi -> sf . reuse_inter_pred_sby || seg_skip ) vp9_build_inter_predictors_sby ( xd , mi_row , mi_col , MAX ( bsize , BLOCK_8X8 ) ) ;\n vp9_build_inter_predictors_sbuv ( xd , mi_row , mi_col , MAX ( bsize , BLOCK_8X8 ) ) ;\n if ( ! x -> skip ) {\n mbmi -> skip = 1 ;\n vp9_encode_sb ( x , MAX ( bsize , BLOCK_8X8 ) ) ;\n vp9_tokenize_sb ( cpi , t , ! output_enabled , MAX ( bsize , BLOCK_8X8 ) ) ;\n }\n else {\n mbmi -> skip = 1 ;\n if ( output_enabled && ! seg_skip ) cm -> counts . skip [ vp9_get_skip_context ( xd ) ] [ 1 ] ++ ;\n reset_skip_context ( xd , MAX ( bsize , BLOCK_8X8 ) ) ;\n }\n }\n if ( output_enabled ) {\n if ( cm -> tx_mode == TX_MODE_SELECT && mbmi -> sb_type >= BLOCK_8X8 && ! ( is_inter_block ( mbmi ) && ( mbmi -> skip || seg_skip ) ) ) {\n ++ get_tx_counts ( max_txsize_lookup [ bsize ] , vp9_get_tx_size_context ( xd ) , & cm -> counts . tx ) [ mbmi -> tx_size ] ;\n }\n else {\n int x , y ;\n TX_SIZE tx_size ;\n if ( is_inter_block ( & mi -> mbmi ) ) {\n tx_size = MIN ( tx_mode_to_biggest_tx_size [ cm -> tx_mode ] , max_txsize_lookup [ bsize ] ) ;\n }\n else {\n tx_size = ( bsize >= BLOCK_8X8 ) ? mbmi -> tx_size : TX_4X4 ;\n }\n for ( y = 0 ;\n y < mi_height ;\n y ++ ) for ( x = 0 ;\n x < mi_width ;\n x ++ ) if ( mi_col + x < cm -> mi_cols && mi_row + y < cm -> mi_rows ) mi_8x8 [ mis * y + x ] -> mbmi . tx_size = tx_size ;\n }\n }\n }", "idx": 1429}
{"hash": 1859256631654516868, "project": "chrome", "size": 22, "label": 0, "functionSource": "static inline void get_lowest_part_y ( H264Context * h , int refs [ 2 ] [ 48 ] , int n , int height , int y_offset , int list0 , int list1 , int * nrefs ) {\n int my ;\n y_offset += 16 * ( h -> mb_y >> MB_FIELD ( h ) ) ;\n if ( list0 ) {\n int ref_n = h -> ref_cache [ 0 ] [ scan8 [ n ] ] ;\n Picture * ref = & h -> ref_list [ 0 ] [ ref_n ] ;\n if ( ref -> tf . progress -> data != h -> cur_pic . tf . progress -> data || ( ref -> reference & 3 ) != h -> picture_structure ) {\n my = get_lowest_part_list_y ( h , ref , n , height , y_offset , 0 ) ;\n if ( refs [ 0 ] [ ref_n ] < 0 ) nrefs [ 0 ] += 1 ;\n refs [ 0 ] [ ref_n ] = FFMAX ( refs [ 0 ] [ ref_n ] , my ) ;\n }\n }\n if ( list1 ) {\n int ref_n = h -> ref_cache [ 1 ] [ scan8 [ n ] ] ;\n Picture * ref = & h -> ref_list [ 1 ] [ ref_n ] ;\n if ( ref -> tf . progress -> data != h -> cur_pic . tf . progress -> data || ( ref -> reference & 3 ) != h -> picture_structure ) {\n my = get_lowest_part_list_y ( h , ref , n , height , y_offset , 1 ) ;\n if ( refs [ 1 ] [ ref_n ] < 0 ) nrefs [ 1 ] += 1 ;\n refs [ 1 ] [ ref_n ] = FFMAX ( refs [ 1 ] [ ref_n ] , my ) ;\n }\n }\n }", "idx": 1430}
{"hash": 643387607984457432, "project": "debian", "size": 10, "label": 0, "functionSource": "static void copy_bits ( PutBitContext * pb , const uint8_t * data , int size , GetBitContext * gb , int nbits ) {\n int rmn_bytes , rmn_bits ;\n rmn_bits = rmn_bytes = get_bits_left ( gb ) ;\n if ( rmn_bits < nbits ) return ;\n if ( nbits > pb -> size_in_bits - put_bits_count ( pb ) ) return ;\n rmn_bits &= 7 ;\n rmn_bytes >>= 3 ;\n if ( ( rmn_bits = FFMIN ( rmn_bits , nbits ) ) > 0 ) put_bits ( pb , rmn_bits , get_bits ( gb , rmn_bits ) ) ;\n avpriv_copy_bits ( pb , data + size - rmn_bytes , FFMIN ( nbits - rmn_bits , rmn_bytes << 3 ) ) ;\n }", "idx": 1431}
{"hash": -3384986069176965684, "project": "chrome", "size": 5, "label": 0, "functionSource": "static void set_segmentation_map ( VP8_COMP * cpi , unsigned char * segmentation_map ) {\n vpx_memcpy ( cpi -> segmentation_map , segmentation_map , ( cpi -> common . mb_rows * cpi -> common . mb_cols ) ) ;\n cpi -> mb . e_mbd . update_mb_segmentation_map = 1 ;\n cpi -> mb . e_mbd . update_mb_segmentation_data = 1 ;\n }", "idx": 1432}
{"hash": -1929262071302712016, "project": "debian", "size": 10, "label": 0, "functionSource": "static void * Type_UcrBg_Dup ( struct _cms_typehandler_struct * self , const void * Ptr , cmsUInt32Number n ) {\n cmsUcrBg * Src = ( cmsUcrBg * ) Ptr ;\n cmsUcrBg * NewUcrBg = ( cmsUcrBg * ) _cmsMallocZero ( self -> ContextID , sizeof ( cmsUcrBg ) ) ;\n if ( NewUcrBg == NULL ) return NULL ;\n NewUcrBg -> Bg = cmsDupToneCurve ( Src -> Bg ) ;\n NewUcrBg -> Ucr = cmsDupToneCurve ( Src -> Ucr ) ;\n NewUcrBg -> Desc = cmsMLUdup ( Src -> Desc ) ;\n return ( void * ) NewUcrBg ;\n cmsUNUSED_PARAMETER ( n ) ;\n }", "idx": 1433}
{"hash": 217269231454293846, "project": "debian", "size": 258, "label": 0, "functionSource": "static krb5_error_code process_chpw_request ( krb5_context context , void * server_handle , char * realm , krb5_keytab keytab , const krb5_fulladdr * local_faddr , const krb5_fulladdr * remote_faddr , krb5_data * req , krb5_data * rep ) {\n krb5_error_code ret ;\n char * ptr ;\n unsigned int plen , vno ;\n krb5_data ap_req , ap_rep = empty_data ( ) ;\n krb5_data cipher = empty_data ( ) , clear = empty_data ( ) ;\n krb5_auth_context auth_context = NULL ;\n krb5_principal changepw = NULL ;\n krb5_principal client , target = NULL ;\n krb5_ticket * ticket = NULL ;\n krb5_replay_data replay ;\n krb5_error krberror ;\n int numresult ;\n char strresult [ 1024 ] ;\n char * clientstr = NULL , * targetstr = NULL ;\n const char * errmsg = NULL ;\n size_t clen ;\n char * cdots ;\n struct sockaddr_storage ss ;\n socklen_t salen ;\n char addrbuf [ 100 ] ;\n krb5_address * addr = remote_faddr -> address ;\n * rep = empty_data ( ) ;\n if ( req -> length < 4 ) {\n ret = KRB5KRB_AP_ERR_MODIFIED ;\n numresult = KRB5_KPASSWD_MALFORMED ;\n strlcpy ( strresult , \"Request was truncated\" , sizeof ( strresult ) ) ;\n goto bailout ;\n }\n ptr = req -> data ;\n plen = ( * ptr ++ & 0xff ) ;\n plen = ( plen << 8 ) | ( * ptr ++ & 0xff ) ;\n if ( plen != req -> length ) {\n ret = KRB5KRB_AP_ERR_MODIFIED ;\n numresult = KRB5_KPASSWD_MALFORMED ;\n strlcpy ( strresult , \"Request length was inconsistent\" , sizeof ( strresult ) ) ;\n goto bailout ;\n }\n vno = ( * ptr ++ & 0xff ) ;\n vno = ( vno << 8 ) | ( * ptr ++ & 0xff ) ;\n if ( vno != 1 && vno != RFC3244_VERSION ) {\n ret = KRB5KDC_ERR_BAD_PVNO ;\n numresult = KRB5_KPASSWD_BAD_VERSION ;\n snprintf ( strresult , sizeof ( strresult ) , \"Request contained unknown protocol version number %d\" , vno ) ;\n goto bailout ;\n }\n ap_req . length = ( * ptr ++ & 0xff ) ;\n ap_req . length = ( ap_req . length << 8 ) | ( * ptr ++ & 0xff ) ;\n if ( ptr + ap_req . length >= req -> data + req -> length ) {\n ret = KRB5KRB_AP_ERR_MODIFIED ;\n numresult = KRB5_KPASSWD_MALFORMED ;\n strlcpy ( strresult , \"Request was truncated in AP-REQ\" , sizeof ( strresult ) ) ;\n goto bailout ;\n }\n ap_req . data = ptr ;\n ptr += ap_req . length ;\n ret = krb5_auth_con_init ( context , & auth_context ) ;\n if ( ret ) {\n numresult = KRB5_KPASSWD_HARDERROR ;\n strlcpy ( strresult , \"Failed initializing auth context\" , sizeof ( strresult ) ) ;\n goto chpwfail ;\n }\n ret = krb5_auth_con_setflags ( context , auth_context , KRB5_AUTH_CONTEXT_DO_SEQUENCE ) ;\n if ( ret ) {\n numresult = KRB5_KPASSWD_HARDERROR ;\n strlcpy ( strresult , \"Failed initializing auth context\" , sizeof ( strresult ) ) ;\n goto chpwfail ;\n }\n ret = krb5_build_principal ( context , & changepw , strlen ( realm ) , realm , \"kadmin\" , \"changepw\" , NULL ) ;\n if ( ret ) {\n numresult = KRB5_KPASSWD_HARDERROR ;\n strlcpy ( strresult , \"Failed building kadmin/changepw principal\" , sizeof ( strresult ) ) ;\n goto chpwfail ;\n }\n ret = krb5_rd_req ( context , & auth_context , & ap_req , changepw , keytab , NULL , & ticket ) ;\n if ( ret ) {\n numresult = KRB5_KPASSWD_AUTHERROR ;\n strlcpy ( strresult , \"Failed reading application request\" , sizeof ( strresult ) ) ;\n goto chpwfail ;\n }\n ret = krb5_mk_rep ( context , auth_context , & ap_rep ) ;\n if ( ret ) {\n numresult = KRB5_KPASSWD_AUTHERROR ;\n strlcpy ( strresult , \"Failed replying to application request\" , sizeof ( strresult ) ) ;\n goto chpwfail ;\n }\n cipher . length = ( req -> data + req -> length ) - ptr ;\n cipher . data = ptr ;\n ret = krb5_rd_priv ( context , auth_context , & cipher , & clear , & replay ) ;\n if ( ret ) {\n numresult = KRB5_KPASSWD_HARDERROR ;\n strlcpy ( strresult , \"Failed decrypting request\" , sizeof ( strresult ) ) ;\n goto chpwfail ;\n }\n client = ticket -> enc_part2 -> client ;\n if ( vno == RFC3244_VERSION ) {\n krb5_data * clear_data ;\n ret = decode_krb5_setpw_req ( & clear , & clear_data , & target ) ;\n if ( ret != 0 ) {\n numresult = KRB5_KPASSWD_MALFORMED ;\n strlcpy ( strresult , \"Failed decoding ChangePasswdData\" , sizeof ( strresult ) ) ;\n goto chpwfail ;\n }\n zapfree ( clear . data , clear . length ) ;\n clear = * clear_data ;\n free ( clear_data ) ;\n if ( target != NULL ) {\n ret = krb5_unparse_name ( context , target , & targetstr ) ;\n if ( ret != 0 ) {\n numresult = KRB5_KPASSWD_HARDERROR ;\n strlcpy ( strresult , \"Failed unparsing target name for log\" , sizeof ( strresult ) ) ;\n goto chpwfail ;\n }\n }\n }\n ret = krb5_unparse_name ( context , client , & clientstr ) ;\n if ( ret ) {\n numresult = KRB5_KPASSWD_HARDERROR ;\n strlcpy ( strresult , \"Failed unparsing client name for log\" , sizeof ( strresult ) ) ;\n goto chpwfail ;\n }\n if ( vno == 1 && ( ticket -> enc_part2 -> flags & TKT_FLG_INITIAL ) == 0 ) {\n numresult = KRB5_KPASSWD_INITIAL_FLAG_NEEDED ;\n strlcpy ( strresult , \"Ticket must be derived from a password\" , sizeof ( strresult ) ) ;\n goto chpwfail ;\n }\n ptr = k5memdup0 ( clear . data , clear . length , & ret ) ;\n ret = schpw_util_wrapper ( server_handle , client , target , ( ticket -> enc_part2 -> flags & TKT_FLG_INITIAL ) != 0 , ptr , NULL , strresult , sizeof ( strresult ) ) ;\n if ( ret ) errmsg = krb5_get_error_message ( context , ret ) ;\n zapfree ( clear . data , clear . length ) ;\n zapfree ( ptr , clear . length ) ;\n clear = empty_data ( ) ;\n clen = strlen ( clientstr ) ;\n trunc_name ( & clen , & cdots ) ;\n switch ( addr -> addrtype ) {\n case ADDRTYPE_INET : {\n struct sockaddr_in * sin = ss2sin ( & ss ) ;\n sin -> sin_family = AF_INET ;\n memcpy ( & sin -> sin_addr , addr -> contents , addr -> length ) ;\n sin -> sin_port = htons ( remote_faddr -> port ) ;\n salen = sizeof ( * sin ) ;\n break ;\n }\n case ADDRTYPE_INET6 : {\n struct sockaddr_in6 * sin6 = ss2sin6 ( & ss ) ;\n sin6 -> sin6_family = AF_INET6 ;\n memcpy ( & sin6 -> sin6_addr , addr -> contents , addr -> length ) ;\n sin6 -> sin6_port = htons ( remote_faddr -> port ) ;\n salen = sizeof ( * sin6 ) ;\n break ;\n }\n default : {\n struct sockaddr * sa = ss2sa ( & ss ) ;\n sa -> sa_family = AF_UNSPEC ;\n salen = sizeof ( * sa ) ;\n break ;\n }\n }\n if ( getnameinfo ( ss2sa ( & ss ) , salen , addrbuf , sizeof ( addrbuf ) , NULL , 0 , NI_NUMERICHOST | NI_NUMERICSERV ) != 0 ) strlcpy ( addrbuf , \"<unprintable>\" , sizeof ( addrbuf ) ) ;\n if ( vno == RFC3244_VERSION ) {\n size_t tlen ;\n char * tdots ;\n const char * targetp ;\n if ( target == NULL ) {\n tlen = clen ;\n tdots = cdots ;\n targetp = targetstr ;\n }\n else {\n tlen = strlen ( targetstr ) ;\n trunc_name ( & tlen , & tdots ) ;\n targetp = clientstr ;\n }\n krb5_klog_syslog ( LOG_NOTICE , _ ( \"setpw request from %s by %.*s%s for \" \"%.*s%s: %s\" ) , addrbuf , ( int ) clen , clientstr , cdots , ( int ) tlen , targetp , tdots , errmsg ? errmsg : \"success\" ) ;\n }\n else {\n krb5_klog_syslog ( LOG_NOTICE , _ ( \"chpw request from %s for %.*s%s: %s\" ) , addrbuf , ( int ) clen , clientstr , cdots , errmsg ? errmsg : \"success\" ) ;\n }\n switch ( ret ) {\n case KADM5_AUTH_CHANGEPW : numresult = KRB5_KPASSWD_ACCESSDENIED ;\n break ;\n case KADM5_PASS_Q_TOOSHORT : case KADM5_PASS_REUSE : case KADM5_PASS_Q_CLASS : case KADM5_PASS_Q_DICT : case KADM5_PASS_Q_GENERIC : case KADM5_PASS_TOOSOON : numresult = KRB5_KPASSWD_SOFTERROR ;\n break ;\n case 0 : numresult = KRB5_KPASSWD_SUCCESS ;\n strlcpy ( strresult , \"\" , sizeof ( strresult ) ) ;\n break ;\n default : numresult = KRB5_KPASSWD_HARDERROR ;\n break ;\n }\n chpwfail : clear . length = 2 + strlen ( strresult ) ;\n clear . data = ( char * ) malloc ( clear . length ) ;\n ptr = clear . data ;\n * ptr ++ = ( numresult >> 8 ) & 0xff ;\n * ptr ++ = numresult & 0xff ;\n memcpy ( ptr , strresult , strlen ( strresult ) ) ;\n cipher = empty_data ( ) ;\n if ( ap_rep . length ) {\n ret = krb5_auth_con_setaddrs ( context , auth_context , local_faddr -> address , NULL ) ;\n if ( ret ) {\n numresult = KRB5_KPASSWD_HARDERROR ;\n strlcpy ( strresult , \"Failed storing client and server internet addresses\" , sizeof ( strresult ) ) ;\n }\n else {\n ret = krb5_mk_priv ( context , auth_context , & clear , & cipher , & replay ) ;\n if ( ret ) {\n numresult = KRB5_KPASSWD_HARDERROR ;\n strlcpy ( strresult , \"Failed encrypting reply\" , sizeof ( strresult ) ) ;\n }\n }\n }\n if ( cipher . length == 0 ) {\n if ( ap_rep . length ) {\n free ( ap_rep . data ) ;\n ap_rep = empty_data ( ) ;\n }\n krberror . ctime = 0 ;\n krberror . cusec = 0 ;\n krberror . susec = 0 ;\n ret = krb5_timeofday ( context , & krberror . stime ) ;\n if ( ret ) goto bailout ;\n krberror . error = ret ;\n krberror . error -= ERROR_TABLE_BASE_krb5 ;\n if ( krberror . error < 0 || krberror . error > 128 ) krberror . error = KRB_ERR_GENERIC ;\n krberror . client = NULL ;\n ret = krb5_build_principal ( context , & krberror . server , strlen ( realm ) , realm , \"kadmin\" , \"changepw\" , NULL ) ;\n if ( ret ) goto bailout ;\n krberror . text . length = 0 ;\n krberror . e_data = clear ;\n ret = krb5_mk_error ( context , & krberror , & cipher ) ;\n krb5_free_principal ( context , krberror . server ) ;\n if ( ret ) goto bailout ;\n }\n ret = alloc_data ( rep , 6 + ap_rep . length + cipher . length ) ;\n if ( ret ) goto bailout ;\n ptr = rep -> data ;\n * ptr ++ = ( rep -> length >> 8 ) & 0xff ;\n * ptr ++ = rep -> length & 0xff ;\n * ptr ++ = 0 ;\n * ptr ++ = 1 ;\n * ptr ++ = ( ap_rep . length >> 8 ) & 0xff ;\n * ptr ++ = ap_rep . length & 0xff ;\n if ( ap_rep . length ) {\n memcpy ( ptr , ap_rep . data , ap_rep . length ) ;\n ptr += ap_rep . length ;\n }\n memcpy ( ptr , cipher . data , cipher . length ) ;\n bailout : krb5_auth_con_free ( context , auth_context ) ;\n krb5_free_principal ( context , changepw ) ;\n krb5_free_ticket ( context , ticket ) ;\n free ( ap_rep . data ) ;\n free ( clear . data ) ;\n free ( cipher . data ) ;\n krb5_free_principal ( context , target ) ;\n krb5_free_unparsed_name ( context , targetstr ) ;\n krb5_free_unparsed_name ( context , clientstr ) ;\n krb5_free_error_message ( context , errmsg ) ;\n return ret ;\n }", "idx": 1434}
{"hash": 7549435794356072684, "project": "debian", "size": 12, "label": 0, "functionSource": "static VALUE decode_time ( unsigned char * der , long length ) {\n ASN1_TIME * time ;\n const unsigned char * p ;\n VALUE ret ;\n int status = 0 ;\n p = der ;\n if ( ! ( time = d2i_ASN1_TIME ( NULL , & p , length ) ) ) ossl_raise ( eASN1Error , NULL ) ;\n ret = rb_protect ( ( VALUE ( * ) ( VALUE ) ) asn1time_to_time , ( VALUE ) time , & status ) ;\n ASN1_TIME_free ( time ) ;\n if ( status ) rb_jump_tag ( status ) ;\n return ret ;\n }", "idx": 1435}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_CommunicationModeRequest ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_CommunicationModeRequest , CommunicationModeRequest_sequence ) ;\n return offset ;\n }", "idx": 1436}
{"hash": 7279312193592248512, "project": "debian", "size": 8, "label": 0, "functionSource": "static void intra_pred_lp ( uint8_t * d , uint8_t * top , uint8_t * left , int stride ) {\n int x , y ;\n for ( y = 0 ;\n y < 8 ;\n y ++ ) for ( x = 0 ;\n x < 8 ;\n x ++ ) d [ y * stride + x ] = ( LOWPASS ( top , x + 1 ) + LOWPASS ( left , y + 1 ) ) >> 1 ;\n }", "idx": 1437}
{"hash": -2424348134098907053, "project": "debian", "size": 7, "label": 0, "functionSource": "static int is_a_member ( int val , int * vals , int num_vals ) {\n int lokke ;\n for ( lokke = 0 ;\n lokke < num_vals ;\n lokke ++ ) if ( val == vals [ lokke ] ) return 1 ;\n return 0 ;\n }", "idx": 1438}
{"hash": -5992472514718425579, "project": "debian", "size": 3, "label": 0, "functionSource": "static struct cgroup_process_info * lxc_cgroup_process_info_get_init ( struct cgroup_meta_data * meta ) {\n return lxc_cgroup_process_info_get ( 1 , meta ) ;\n }", "idx": 1439}
{"hash": 5506079590431503777, "project": "debian", "size": 1303, "label": 1, "functionSource": "static int dissect_dns_answer ( tvbuff_t * tvb , int offsetx , int dns_data_offset , column_info * cinfo , proto_tree * dns_tree , packet_info * pinfo , gboolean is_mdns ) {\n int len ;\n const guchar * name ;\n gchar * name_out ;\n int name_len ;\n int dns_type ;\n int dns_class ;\n int flush ;\n const char * class_name ;\n const char * type_name ;\n int data_offset ;\n int cur_offset ;\n int data_start ;\n gushort data_len ;\n proto_tree * rr_tree = NULL ;\n proto_item * trr = NULL ;\n data_start = data_offset = offsetx ;\n cur_offset = offsetx ;\n len = get_dns_name_type_class ( tvb , offsetx , dns_data_offset , & name , & name_len , & dns_type , & dns_class ) ;\n data_offset += len ;\n cur_offset += len ;\n if ( is_mdns ) {\n flush = dns_class & C_FLUSH ;\n dns_class &= ~ C_FLUSH ;\n }\n else {\n flush = 0 ;\n }\n type_name = val_to_str_ext ( dns_type , & dns_types_vals_ext , \"Unknown (%d)\" ) ;\n class_name = val_to_str_const ( dns_class , dns_classes , \"Unknown\" ) ;\n data_offset += 4 ;\n cur_offset += 4 ;\n data_len = tvb_get_ntohs ( tvb , data_offset ) ;\n data_offset += 2 ;\n cur_offset += 2 ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \"%s\" , type_name ) ;\n if ( is_mdns && flush ) {\n col_append_str ( cinfo , COL_INFO , \", cache flush\" ) ;\n }\n }\n if ( dns_tree != NULL ) {\n name_out = format_text ( name , strlen ( name ) ) ;\n if ( dns_type != T_OPT ) {\n rr_tree = proto_tree_add_subtree_format ( dns_tree , tvb , offsetx , ( data_offset - data_start ) + data_len , ett_dns_rr , & trr , \"%s: type %s, class %s\" , name_out , type_name , class_name ) ;\n add_rr_to_tree ( rr_tree , tvb , offsetx , name , name_len , dns_type , pinfo , is_mdns ) ;\n }\n else {\n rr_tree = proto_tree_add_subtree_format ( dns_tree , tvb , offsetx , ( data_offset - data_start ) + data_len , ett_dns_rr , & trr , \"%s: type %s\" , name_out , type_name ) ;\n add_opt_rr_to_tree ( rr_tree , tvb , offsetx , name , name_len , is_mdns ) ;\n }\n if ( is_mdns && flush ) {\n proto_item_append_text ( trr , \", cache flush\" ) ;\n }\n }\n if ( data_len == 0 ) {\n return data_offset - data_start ;\n }\n switch ( dns_type ) {\n case T_A : {\n const char * addr ;\n addr = tvb_ip_to_str ( tvb , cur_offset ) ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %s\" , addr ) ;\n }\n proto_item_append_text ( trr , \", addr %s\" , addr ) ;\n proto_tree_add_item ( rr_tree , hf_dns_a , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n if ( dns_use_for_addr_resolution && ( dns_class & 0x7f ) == C_IN ) {\n guint32 addr_int ;\n tvb_memcpy ( tvb , & addr_int , cur_offset , sizeof ( addr_int ) ) ;\n add_ipv4_name ( addr_int , name ) ;\n }\n }\n break ;\n case T_NS : {\n const guchar * ns_name ;\n int ns_name_len ;\n ns_name_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & ns_name ) ;\n name_out = format_text ( ns_name , strlen ( ns_name ) ) ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %s\" , name_out ) ;\n }\n proto_item_append_text ( trr , \", ns %s\" , name_out ) ;\n proto_tree_add_string ( rr_tree , hf_dns_ns , tvb , cur_offset , ns_name_len , name_out ) ;\n }\n break ;\n case T_MD : {\n int hostname_len ;\n const guchar * hostname_str ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %s\" , name ) ;\n }\n hostname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & hostname_str ) ;\n proto_tree_add_string ( rr_tree , hf_dns_md , tvb , cur_offset , hostname_len , hostname_str ) ;\n }\n break ;\n case T_MF : {\n int hostname_len ;\n const guchar * hostname_str ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %s\" , name ) ;\n }\n hostname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & hostname_str ) ;\n proto_tree_add_string ( rr_tree , hf_dns_mf , tvb , cur_offset , hostname_len , hostname_str ) ;\n }\n break ;\n case T_CNAME : {\n const guchar * cname ;\n int cname_len ;\n cname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & cname ) ;\n name_out = format_text ( cname , strlen ( cname ) ) ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %s\" , name_out ) ;\n }\n proto_item_append_text ( trr , \", cname %s\" , name_out ) ;\n proto_tree_add_string ( rr_tree , hf_dns_cname , tvb , cur_offset , cname_len , name_out ) ;\n }\n break ;\n case T_SOA : {\n const guchar * mname ;\n int mname_len ;\n const guchar * rname ;\n int rname_len ;\n proto_item * ti_soa ;\n mname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & mname ) ;\n name_out = format_text ( mname , strlen ( mname ) ) ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %s\" , name_out ) ;\n }\n proto_item_append_text ( trr , \", mname %s\" , name_out ) ;\n proto_tree_add_string ( rr_tree , hf_dns_soa_mname , tvb , cur_offset , mname_len , name_out ) ;\n cur_offset += mname_len ;\n rname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & rname ) ;\n name_out = format_text ( rname , strlen ( rname ) ) ;\n proto_tree_add_string ( rr_tree , hf_dns_soa_rname , tvb , cur_offset , rname_len , name_out ) ;\n cur_offset += rname_len ;\n proto_tree_add_item ( rr_tree , hf_dns_soa_serial_number , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n cur_offset += 4 ;\n ti_soa = proto_tree_add_item ( rr_tree , hf_dns_soa_refresh_interval , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n proto_item_append_text ( ti_soa , \" (%s)\" , time_secs_to_str ( wmem_packet_scope ( ) , tvb_get_ntohl ( tvb , cur_offset ) ) ) ;\n cur_offset += 4 ;\n ti_soa = proto_tree_add_item ( rr_tree , hf_dns_soa_retry_interval , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n proto_item_append_text ( ti_soa , \" (%s)\" , time_secs_to_str ( wmem_packet_scope ( ) , tvb_get_ntohl ( tvb , cur_offset ) ) ) ;\n cur_offset += 4 ;\n ti_soa = proto_tree_add_item ( rr_tree , hf_dns_soa_expire_limit , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n proto_item_append_text ( ti_soa , \" (%s)\" , time_secs_to_str ( wmem_packet_scope ( ) , tvb_get_ntohl ( tvb , cur_offset ) ) ) ;\n cur_offset += 4 ;\n ti_soa = proto_tree_add_item ( rr_tree , hf_dns_soa_minimum_ttl , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n proto_item_append_text ( ti_soa , \" (%s)\" , time_secs_to_str ( wmem_packet_scope ( ) , tvb_get_ntohl ( tvb , cur_offset ) ) ) ;\n }\n break ;\n case T_MB : {\n int hostname_len ;\n const guchar * hostname_str ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %s\" , name ) ;\n }\n hostname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & hostname_str ) ;\n proto_tree_add_string ( rr_tree , hf_dns_mb , tvb , cur_offset , hostname_len , hostname_str ) ;\n }\n break ;\n case T_MG : {\n int hostname_len ;\n const guchar * hostname_str ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %s\" , name ) ;\n }\n hostname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & hostname_str ) ;\n proto_tree_add_string ( rr_tree , hf_dns_mg , tvb , cur_offset , hostname_len , hostname_str ) ;\n }\n break ;\n case T_MR : {\n int hostname_len ;\n const guchar * hostname_str ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %s\" , name ) ;\n }\n hostname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & hostname_str ) ;\n proto_tree_add_string ( rr_tree , hf_dns_mr , tvb , cur_offset , hostname_len , hostname_str ) ;\n }\n break ;\n case T_NULL : {\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %s\" , name ) ;\n }\n proto_tree_add_item ( rr_tree , hf_dns_null , tvb , cur_offset , data_len , ENC_NA ) ;\n }\n break ;\n case T_WKS : {\n int rr_len = data_len ;\n const char * wks_addr ;\n guint8 protocol ;\n guint8 bits ;\n int mask ;\n int port_num ;\n int i ;\n proto_item * ti_wks ;\n wmem_strbuf_t * bitnames = wmem_strbuf_new_label ( wmem_packet_scope ( ) ) ;\n wks_addr = tvb_ip_to_str ( tvb , cur_offset ) ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %s\" , wks_addr ) ;\n }\n proto_item_append_text ( trr , \", addr %s\" , wks_addr ) ;\n proto_tree_add_item ( rr_tree , hf_dns_wks_address , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n cur_offset += 4 ;\n rr_len -= 4 ;\n proto_tree_add_item ( rr_tree , hf_dns_wks_protocol , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n protocol = tvb_get_guint8 ( tvb , cur_offset ) ;\n cur_offset += 1 ;\n rr_len -= 1 ;\n port_num = 0 ;\n while ( rr_len != 0 ) {\n bits = tvb_get_guint8 ( tvb , cur_offset ) ;\n if ( bits != 0 ) {\n mask = 1 << 7 ;\n wmem_strbuf_truncate ( bitnames , 0 ) ;\n for ( i = 0 ;\n i < 8 ;\n i ++ ) {\n if ( bits & mask ) {\n if ( wmem_strbuf_get_len ( bitnames ) > 0 ) {\n wmem_strbuf_append ( bitnames , \", \" ) ;\n }\n switch ( protocol ) {\n case IP_PROTO_TCP : wmem_strbuf_append ( bitnames , tcp_port_to_display ( wmem_packet_scope ( ) , port_num ) ) ;\n break ;\n case IP_PROTO_UDP : wmem_strbuf_append ( bitnames , udp_port_to_display ( wmem_packet_scope ( ) , port_num ) ) ;\n break ;\n default : wmem_strbuf_append_printf ( bitnames , \"%u\" , port_num ) ;\n break ;\n }\n }\n mask >>= 1 ;\n port_num ++ ;\n }\n ti_wks = proto_tree_add_item ( rr_tree , hf_dns_wks_bits , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n proto_item_append_text ( ti_wks , \" (%s)\" , wmem_strbuf_get_str ( bitnames ) ) ;\n }\n else {\n port_num += 8 ;\n }\n cur_offset += 1 ;\n rr_len -= 1 ;\n }\n }\n break ;\n case T_PTR : {\n const guchar * pname ;\n int pname_len ;\n pname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & pname ) ;\n name_out = format_text ( pname , strlen ( pname ) ) ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %s\" , name_out ) ;\n }\n proto_item_append_text ( trr , \", %s\" , name_out ) ;\n proto_tree_add_string ( rr_tree , hf_dns_ptr_domain_name , tvb , cur_offset , pname_len , name_out ) ;\n }\n break ;\n case T_HINFO : {\n int cpu_offset ;\n int cpu_len ;\n const char * cpu ;\n int os_offset ;\n int os_len ;\n const char * os ;\n cpu_offset = cur_offset ;\n cpu_len = tvb_get_guint8 ( tvb , cpu_offset ) ;\n cpu = tvb_get_string_enc ( wmem_packet_scope ( ) , tvb , cpu_offset + 1 , cpu_len , ENC_ASCII | ENC_NA ) ;\n os_offset = cpu_offset + 1 + cpu_len ;\n os_len = tvb_get_guint8 ( tvb , os_offset ) ;\n os = tvb_get_string_enc ( wmem_packet_scope ( ) , tvb , os_offset + 1 , os_len , ENC_ASCII | ENC_NA ) ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %.*s %.*s\" , cpu_len , cpu , os_len , os ) ;\n }\n proto_item_append_text ( trr , \", CPU %.*s, OS %.*s\" , cpu_len , cpu , os_len , os ) ;\n proto_tree_add_item ( rr_tree , hf_dns_hinfo_cpu_length , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n cur_offset += 1 ;\n proto_tree_add_item ( rr_tree , hf_dns_hinfo_cpu , tvb , cur_offset , cpu_len , ENC_ASCII | ENC_NA ) ;\n cur_offset += cpu_len ;\n proto_tree_add_item ( rr_tree , hf_dns_hinfo_os_length , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n cur_offset += 1 ;\n proto_tree_add_item ( rr_tree , hf_dns_hinfo_os , tvb , cur_offset , os_len , ENC_ASCII | ENC_NA ) ;\n }\n break ;\n case T_MINFO : {\n int rmailbx_len , emailbx_len ;\n const guchar * rmailbx_str , * emailbx_str ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %s\" , name ) ;\n }\n rmailbx_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & rmailbx_str ) ;\n proto_tree_add_string ( rr_tree , hf_dns_minfo_r_mailbox , tvb , cur_offset , rmailbx_len , rmailbx_str ) ;\n cur_offset += rmailbx_len ;\n emailbx_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & emailbx_str ) ;\n proto_tree_add_string ( rr_tree , hf_dns_minfo_e_mailbox , tvb , cur_offset , emailbx_len , emailbx_str ) ;\n }\n break ;\n case T_MX : {\n guint16 preference = 0 ;\n const guchar * mx_name ;\n int mx_name_len ;\n preference = tvb_get_ntohs ( tvb , cur_offset ) ;\n mx_name_len = get_dns_name ( tvb , cur_offset + 2 , 0 , dns_data_offset , & mx_name ) ;\n name_out = format_text ( mx_name , strlen ( mx_name ) ) ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %u %s\" , preference , name_out ) ;\n }\n proto_item_append_text ( trr , \", preference %u, mx %s\" , preference , name_out ) ;\n proto_tree_add_item ( rr_tree , hf_dns_mx_preference , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n cur_offset += 2 ;\n proto_tree_add_string ( rr_tree , hf_dns_mx_mail_exchange , tvb , cur_offset , mx_name_len , name_out ) ;\n }\n break ;\n case T_TXT : {\n int rr_len = data_len ;\n int txt_offset ;\n int txt_len ;\n txt_offset = cur_offset ;\n while ( rr_len != 0 ) {\n txt_len = tvb_get_guint8 ( tvb , txt_offset ) ;\n proto_tree_add_item ( rr_tree , hf_dns_txt_length , tvb , txt_offset , 1 , ENC_BIG_ENDIAN ) ;\n txt_offset += 1 ;\n rr_len -= 1 ;\n proto_tree_add_item ( rr_tree , hf_dns_txt , tvb , txt_offset , txt_len , ENC_ASCII | ENC_NA ) ;\n txt_offset += txt_len ;\n rr_len -= txt_len ;\n }\n }\n break ;\n case T_RP : {\n int mbox_dname_len , txt_dname_len ;\n const guchar * mbox_dname , * txt_dname ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %s\" , name ) ;\n }\n mbox_dname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & mbox_dname ) ;\n proto_tree_add_string ( rr_tree , hf_dns_rp_mailbox , tvb , cur_offset , mbox_dname_len , mbox_dname ) ;\n cur_offset += mbox_dname_len ;\n txt_dname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & txt_dname ) ;\n proto_tree_add_string ( rr_tree , hf_dns_rp_txt_rr , tvb , cur_offset , txt_dname_len , txt_dname ) ;\n }\n break ;\n case T_AFSDB : {\n const guchar * host_name ;\n int host_name_len ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %s\" , name ) ;\n }\n host_name_len = get_dns_name ( tvb , cur_offset + 2 , 0 , dns_data_offset , & host_name ) ;\n proto_tree_add_item ( rr_tree , hf_dns_afsdb_subtype , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n cur_offset += 2 ;\n proto_tree_add_string ( rr_tree , hf_dns_afsdb_hostname , tvb , cur_offset , host_name_len , host_name ) ;\n }\n break ;\n case T_X25 : {\n guint8 x25_len ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %s\" , name ) ;\n }\n proto_tree_add_item ( rr_tree , hf_dns_x25_length , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n x25_len = tvb_get_guint8 ( tvb , cur_offset ) ;\n cur_offset += 1 ;\n proto_tree_add_item ( rr_tree , hf_dns_x25_psdn_address , tvb , cur_offset , x25_len , ENC_ASCII | ENC_NA ) ;\n }\n break ;\n case T_ISDN : {\n guint8 isdn_address_len , isdn_sa_len ;\n int rr_len = data_len ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %s\" , name ) ;\n }\n proto_tree_add_item ( rr_tree , hf_dns_isdn_length , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n isdn_address_len = tvb_get_guint8 ( tvb , cur_offset ) ;\n cur_offset += 1 ;\n rr_len -= 1 ;\n proto_tree_add_item ( rr_tree , hf_dns_isdn_address , tvb , cur_offset , isdn_address_len , ENC_ASCII | ENC_NA ) ;\n cur_offset += isdn_address_len ;\n rr_len -= isdn_address_len ;\n if ( rr_len > 1 ) {\n proto_tree_add_item ( rr_tree , hf_dns_isdn_sa_length , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n isdn_sa_len = tvb_get_guint8 ( tvb , cur_offset ) ;\n cur_offset += 1 ;\n proto_tree_add_item ( rr_tree , hf_dns_isdn_sa , tvb , cur_offset , isdn_sa_len , ENC_ASCII | ENC_NA ) ;\n }\n }\n break ;\n case T_RT : {\n const guchar * host_name ;\n int host_name_len ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %s\" , name ) ;\n }\n host_name_len = get_dns_name ( tvb , cur_offset + 2 , 0 , dns_data_offset , & host_name ) ;\n proto_tree_add_item ( rr_tree , hf_dns_rt_preference , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n cur_offset += 2 ;\n proto_tree_add_string ( rr_tree , hf_dns_rt_intermediate_host , tvb , cur_offset , host_name_len , host_name ) ;\n }\n break ;\n case T_NSAP : {\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %s\" , name ) ;\n }\n proto_tree_add_item ( rr_tree , hf_dns_nsap_rdata , tvb , cur_offset , data_len , ENC_NA ) ;\n }\n break ;\n case T_NSAP_PTR : {\n int nsap_ptr_owner_len ;\n const guchar * nsap_ptr_owner ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %s\" , name ) ;\n }\n nsap_ptr_owner_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & nsap_ptr_owner ) ;\n proto_tree_add_string ( rr_tree , hf_dns_nsap_ptr_owner , tvb , cur_offset , nsap_ptr_owner_len , nsap_ptr_owner ) ;\n }\n break ;\n case T_KEY : {\n int rr_len = data_len ;\n guint16 flags ;\n proto_item * tf , * ti_gen ;\n proto_tree * flags_tree ;\n guint8 algo ;\n guint16 key_id ;\n tf = proto_tree_add_item ( rr_tree , hf_dns_key_flags , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n flags_tree = proto_item_add_subtree ( tf , ett_key_flags ) ;\n flags = tvb_get_ntohs ( tvb , cur_offset ) ;\n proto_tree_add_item ( flags_tree , hf_dns_key_flags_authentication , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( flags_tree , hf_dns_key_flags_confidentiality , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n if ( ( flags & 0xC000 ) != 0xC000 ) {\n proto_tree_add_item ( flags_tree , hf_dns_key_flags_key_required , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( flags_tree , hf_dns_key_flags_associated_user , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( flags_tree , hf_dns_key_flags_associated_named_entity , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( flags_tree , hf_dns_key_flags_ipsec , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( flags_tree , hf_dns_key_flags_mime , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( flags_tree , hf_dns_key_flags_signatory , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n }\n cur_offset += 2 ;\n rr_len -= 2 ;\n proto_tree_add_item ( rr_tree , hf_dns_key_protocol , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n cur_offset += 1 ;\n rr_len -= 1 ;\n proto_tree_add_item ( rr_tree , hf_dns_key_algorithm , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n algo = tvb_get_guint8 ( tvb , cur_offset ) ;\n cur_offset += 1 ;\n rr_len -= 1 ;\n key_id = compute_key_id ( tvb , cur_offset - 4 , rr_len + 4 , algo ) ;\n ti_gen = proto_tree_add_uint ( rr_tree , hf_dns_key_key_id , tvb , 0 , 0 , key_id ) ;\n PROTO_ITEM_SET_GENERATED ( ti_gen ) ;\n if ( rr_len != 0 ) {\n proto_tree_add_item ( rr_tree , hf_dns_key_public_key , tvb , cur_offset , rr_len , ENC_NA ) ;\n }\n }\n break ;\n case T_PX : {\n int px_map822_len , px_mapx400_len ;\n const guchar * px_map822_dnsname , * px_mapx400_dnsname ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %s\" , name ) ;\n }\n proto_tree_add_item ( rr_tree , hf_dns_px_preference , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n cur_offset += 2 ;\n px_map822_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & px_map822_dnsname ) ;\n proto_tree_add_string ( rr_tree , hf_dns_px_map822 , tvb , cur_offset , px_map822_len , px_map822_dnsname ) ;\n cur_offset += px_map822_len ;\n px_mapx400_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & px_mapx400_dnsname ) ;\n proto_tree_add_string ( rr_tree , hf_dns_px_mapx400 , tvb , cur_offset , px_mapx400_len , px_mapx400_dnsname ) ;\n }\n break ;\n case T_GPOS : {\n guint8 long_len , lat_len , alt_len ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %s\" , name ) ;\n }\n proto_tree_add_item ( rr_tree , hf_dns_gpos_longitude_length , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n long_len = tvb_get_guint8 ( tvb , cur_offset ) ;\n cur_offset += 1 ;\n proto_tree_add_item ( rr_tree , hf_dns_gpos_longitude , tvb , cur_offset , long_len , ENC_ASCII | ENC_NA ) ;\n cur_offset += long_len ;\n proto_tree_add_item ( rr_tree , hf_dns_gpos_latitude_length , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n lat_len = tvb_get_guint8 ( tvb , cur_offset ) ;\n cur_offset += 1 ;\n proto_tree_add_item ( rr_tree , hf_dns_gpos_latitude , tvb , cur_offset , lat_len , ENC_ASCII | ENC_NA ) ;\n cur_offset += lat_len ;\n proto_tree_add_item ( rr_tree , hf_dns_gpos_altitude_length , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n alt_len = tvb_get_guint8 ( tvb , cur_offset ) ;\n cur_offset += 1 ;\n proto_tree_add_item ( rr_tree , hf_dns_gpos_altitude , tvb , cur_offset , alt_len , ENC_ASCII | ENC_NA ) ;\n }\n break ;\n case T_AAAA : {\n const char * addr6 ;\n addr6 = tvb_ip6_to_str ( tvb , cur_offset ) ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %s\" , addr6 ) ;\n }\n proto_item_append_text ( trr , \", addr %s\" , addr6 ) ;\n proto_tree_add_item ( rr_tree , hf_dns_aaaa , tvb , cur_offset , 16 , ENC_NA ) ;\n if ( dns_use_for_addr_resolution && ( dns_class & 0x7f ) == C_IN ) {\n struct e_in6_addr addr_in6 ;\n tvb_memcpy ( tvb , & addr_in6 , cur_offset , sizeof ( addr_in6 ) ) ;\n add_ipv6_name ( & addr_in6 , name ) ;\n }\n }\n break ;\n case T_LOC : {\n guint8 version ;\n proto_item * ti ;\n version = tvb_get_guint8 ( tvb , cur_offset ) ;\n proto_tree_add_item ( rr_tree , hf_dns_loc_version , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n if ( version == 0 ) {\n cur_offset ++ ;\n ti = proto_tree_add_item ( rr_tree , hf_dns_loc_size , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n proto_item_append_text ( ti , \" (%g m)\" , rfc1867_size ( tvb , cur_offset ) ) ;\n cur_offset ++ ;\n ti = proto_tree_add_item ( rr_tree , hf_dns_loc_horizontal_precision , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n proto_item_append_text ( ti , \" (%g m)\" , rfc1867_size ( tvb , cur_offset ) ) ;\n cur_offset ++ ;\n ti = proto_tree_add_item ( rr_tree , hf_dns_loc_vertical_precision , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n proto_item_append_text ( ti , \" (%g m)\" , rfc1867_size ( tvb , cur_offset ) ) ;\n cur_offset ++ ;\n ti = proto_tree_add_item ( rr_tree , hf_dns_loc_latitude , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n proto_item_append_text ( ti , \" (%s)\" , rfc1867_angle ( tvb , cur_offset , \"NS\" ) ) ;\n cur_offset += 4 ;\n ti = proto_tree_add_item ( rr_tree , hf_dns_loc_longitude , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n proto_item_append_text ( ti , \" (%s)\" , rfc1867_angle ( tvb , cur_offset , \"EW\" ) ) ;\n cur_offset += 4 ;\n ti = proto_tree_add_item ( rr_tree , hf_dns_loc_altitude , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n proto_item_append_text ( ti , \" (%g m)\" , ( ( gint32 ) tvb_get_ntohl ( tvb , cur_offset ) - 10000000 ) / 100.0 ) ;\n }\n else {\n proto_tree_add_item ( rr_tree , hf_dns_loc_unknown_data , tvb , cur_offset , data_len , ENC_NA ) ;\n }\n }\n break ;\n case T_NXT : {\n int rr_len = data_len ;\n const guchar * next_domain_name ;\n int next_domain_name_len ;\n next_domain_name_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & next_domain_name ) ;\n name_out = format_text ( next_domain_name , strlen ( next_domain_name ) ) ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %s\" , name_out ) ;\n }\n proto_item_append_text ( trr , \", next domain name %s\" , name_out ) ;\n proto_tree_add_string ( rr_tree , hf_dns_nxt_next_domain_name , tvb , cur_offset , next_domain_name_len , name_out ) ;\n cur_offset += next_domain_name_len ;\n rr_len -= next_domain_name_len ;\n dissect_type_bitmap_nxt ( rr_tree , tvb , cur_offset , rr_len ) ;\n }\n break ;\n case T_SRV : {\n guint16 priority = 0 ;\n guint16 weight = 0 ;\n guint16 port = 0 ;\n const guchar * target ;\n int target_len ;\n proto_tree_add_item ( rr_tree , hf_dns_srv_priority , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n priority = tvb_get_ntohs ( tvb , cur_offset ) ;\n cur_offset += 2 ;\n proto_tree_add_item ( rr_tree , hf_dns_srv_weight , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n weight = tvb_get_ntohs ( tvb , cur_offset ) ;\n cur_offset += 2 ;\n proto_tree_add_item ( rr_tree , hf_dns_srv_port , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n port = tvb_get_ntohs ( tvb , cur_offset ) ;\n cur_offset += 2 ;\n target_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & target ) ;\n name_out = format_text ( target , strlen ( target ) ) ;\n proto_tree_add_string ( rr_tree , hf_dns_srv_target , tvb , cur_offset , target_len , name_out ) ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %u %u %u %s\" , priority , weight , port , name_out ) ;\n }\n proto_item_append_text ( trr , \", priority %u, weight %u, port %u, target %s\" , priority , weight , port , name_out ) ;\n }\n break ;\n case T_NAPTR : {\n proto_item * ti_len ;\n int offset = cur_offset ;\n guint16 order ;\n guint16 preference ;\n gchar * flags ;\n guint8 flags_len ;\n guint8 service_len ;\n guint8 regex_len ;\n const guchar * replacement ;\n int replacement_len ;\n proto_tree_add_item ( rr_tree , hf_dns_naptr_order , tvb , offset , 2 , ENC_BIG_ENDIAN ) ;\n order = tvb_get_ntohs ( tvb , offset ) ;\n offset += 2 ;\n proto_tree_add_item ( rr_tree , hf_dns_naptr_preference , tvb , offset , 2 , ENC_BIG_ENDIAN ) ;\n preference = tvb_get_ntohs ( tvb , offset ) ;\n offset += 2 ;\n proto_tree_add_item ( rr_tree , hf_dns_naptr_flags_length , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n flags_len = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n proto_tree_add_item ( rr_tree , hf_dns_naptr_flags , tvb , offset , flags_len , ENC_ASCII | ENC_NA ) ;\n flags = tvb_get_string_enc ( wmem_packet_scope ( ) , tvb , offset , flags_len , ENC_ASCII | ENC_NA ) ;\n offset += flags_len ;\n proto_tree_add_item ( rr_tree , hf_dns_naptr_service_length , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n service_len = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n proto_tree_add_item ( rr_tree , hf_dns_naptr_service , tvb , offset , service_len , ENC_ASCII | ENC_NA ) ;\n offset += service_len ;\n proto_tree_add_item ( rr_tree , hf_dns_naptr_regex_length , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n regex_len = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n proto_tree_add_item ( rr_tree , hf_dns_naptr_regex , tvb , offset , regex_len , ENC_ASCII | ENC_NA ) ;\n offset += regex_len ;\n replacement_len = get_dns_name ( tvb , offset , 0 , dns_data_offset , & replacement ) ;\n name_out = format_text ( replacement , strlen ( replacement ) ) ;\n ti_len = proto_tree_add_uint ( rr_tree , hf_dns_naptr_replacement_length , tvb , offset , 0 , replacement_len ) ;\n PROTO_ITEM_SET_GENERATED ( ti_len ) ;\n proto_tree_add_string ( rr_tree , hf_dns_naptr_replacement , tvb , offset , replacement_len , name_out ) ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %u %u %s\" , order , preference , flags ) ;\n }\n proto_item_append_text ( trr , \", order %u, preference %u, flags %s\" , order , preference , flags ) ;\n }\n break ;\n case T_KX : {\n const guchar * kx_name ;\n int kx_name_len ;\n kx_name_len = get_dns_name ( tvb , cur_offset + 2 , 0 , dns_data_offset , & kx_name ) ;\n name_out = format_text ( kx_name , strlen ( kx_name ) ) ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %u %s\" , tvb_get_ntohs ( tvb , cur_offset ) , name_out ) ;\n }\n proto_item_append_text ( trr , \", preference %u, kx %s\" , tvb_get_ntohs ( tvb , cur_offset ) , name_out ) ;\n proto_tree_add_item ( rr_tree , hf_dns_kx_preference , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_string ( rr_tree , hf_dns_kx_key_exchange , tvb , cur_offset + 2 , kx_name_len , name_out ) ;\n }\n break ;\n case T_CERT : {\n int rr_len = data_len ;\n proto_tree_add_item ( rr_tree , hf_dns_cert_type , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n cur_offset += 2 ;\n rr_len -= 2 ;\n proto_tree_add_item ( rr_tree , hf_dns_cert_key_tag , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n cur_offset += 2 ;\n rr_len -= 2 ;\n proto_tree_add_item ( rr_tree , hf_dns_cert_algorithm , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n cur_offset += 1 ;\n rr_len -= 1 ;\n if ( rr_len != 0 ) {\n proto_tree_add_item ( rr_tree , hf_dns_cert_certificate , tvb , cur_offset , rr_len , ENC_NA ) ;\n }\n }\n break ;\n case T_A6 : {\n unsigned short pre_len ;\n unsigned short suf_len ;\n unsigned short suf_octet_count ;\n const guchar * pname ;\n int pname_len ;\n int a6_offset ;\n int suf_offset ;\n struct e_in6_addr suffix ;\n address suffix_addr ;\n a6_offset = cur_offset ;\n pre_len = tvb_get_guint8 ( tvb , cur_offset ) ;\n cur_offset ++ ;\n suf_len = 128 - pre_len ;\n suf_octet_count = suf_len ? ( suf_len - 1 ) / 8 + 1 : 0 ;\n for ( suf_offset = 0 ;\n suf_offset < 16 - suf_octet_count ;\n suf_offset ++ ) {\n suffix . bytes [ suf_offset ] = 0 ;\n }\n for ( ;\n suf_offset < 16 ;\n suf_offset ++ ) {\n suffix . bytes [ suf_offset ] = tvb_get_guint8 ( tvb , cur_offset ) ;\n cur_offset ++ ;\n }\n if ( pre_len > 0 ) {\n pname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & pname ) ;\n }\n else {\n pname = \"\" ;\n pname_len = 0 ;\n }\n name_out = format_text ( pname , strlen ( pname ) ) ;\n SET_ADDRESS ( & suffix_addr , AT_IPv6 , 16 , suffix . bytes ) ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %d %s %s\" , pre_len , address_to_str ( wmem_packet_scope ( ) , & suffix_addr ) , name_out ) ;\n }\n proto_tree_add_item ( rr_tree , hf_dns_a6_prefix_len , tvb , a6_offset , 1 , ENC_BIG_ENDIAN ) ;\n a6_offset ++ ;\n if ( suf_len ) {\n proto_tree_add_ipv6 ( rr_tree , hf_dns_a6_address_suffix , tvb , a6_offset , suf_octet_count , suffix . bytes ) ;\n a6_offset += suf_octet_count ;\n }\n if ( pre_len > 0 ) {\n proto_tree_add_string ( rr_tree , hf_dns_a6_prefix_name , tvb , a6_offset , pname_len , name_out ) ;\n }\n proto_item_append_text ( trr , \", addr %d %s %s\" , pre_len , address_to_str ( wmem_packet_scope ( ) , & suffix_addr ) , name_out ) ;\n }\n break ;\n case T_DNAME : {\n const guchar * dname ;\n int dname_len ;\n dname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & dname ) ;\n name_out = format_text ( dname , strlen ( dname ) ) ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %s\" , name_out ) ;\n }\n proto_item_append_text ( trr , \", dname %s\" , name_out ) ;\n proto_tree_add_string ( rr_tree , hf_dns_dname , tvb , cur_offset , dname_len , name_out ) ;\n }\n break ;\n case T_OPT : {\n int rropt_len = data_len ;\n guint16 optcode , optlen ;\n proto_item * rropt , * rroptlen ;\n proto_tree * rropt_tree ;\n while ( rropt_len > 0 ) {\n optcode = tvb_get_ntohs ( tvb , cur_offset ) ;\n rropt_len -= 2 ;\n optlen = tvb_get_ntohs ( tvb , cur_offset + 2 ) ;\n rropt_len -= 2 ;\n rropt = proto_tree_add_item ( rr_tree , hf_dns_opt , tvb , cur_offset , 4 + optlen , ENC_NA ) ;\n proto_item_append_text ( rropt , \": %s\" , val_to_str ( optcode , edns0_opt_code_vals , \"Unknown (%d)\" ) ) ;\n rropt_tree = proto_item_add_subtree ( rropt , ett_dns_opts ) ;\n rropt = proto_tree_add_item ( rropt_tree , hf_dns_opt_code , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n cur_offset += 2 ;\n rroptlen = proto_tree_add_item ( rropt_tree , hf_dns_opt_len , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n cur_offset += 2 ;\n proto_tree_add_item ( rropt_tree , hf_dns_opt_data , tvb , cur_offset , optlen , ENC_NA ) ;\n switch ( optcode ) {\n case O_DAU : while ( optlen != 0 ) {\n proto_tree_add_item ( rropt_tree , hf_dns_opt_dau , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n cur_offset += 1 ;\n rropt_len -= 1 ;\n optlen -= 1 ;\n }\n break ;\n case O_DHU : while ( optlen != 0 ) {\n proto_tree_add_item ( rropt_tree , hf_dns_opt_dhu , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n cur_offset += 1 ;\n rropt_len -= 1 ;\n optlen -= 1 ;\n }\n break ;\n case O_N3U : while ( optlen != 0 ) {\n proto_tree_add_item ( rropt_tree , hf_dns_opt_n3u , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n cur_offset += 1 ;\n rropt_len -= 1 ;\n optlen -= 1 ;\n }\n break ;\n case O_CLIENT_SUBNET_EXP : expert_add_info_format ( pinfo , rropt , & ei_dns_depr_opc , \"Deprecated opcode. Client subnet OPT assigned as %d.\" , O_CLIENT_SUBNET ) ;\n case O_CLIENT_SUBNET : {\n guint16 family ;\n union {\n guint32 addr ;\n guint8 bytes [ 16 ] ;\n }\n ip_addr = {\n 0 }\n ;\n family = tvb_get_ntohs ( tvb , cur_offset ) ;\n proto_tree_add_item ( rropt_tree , hf_dns_opt_client_family , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n cur_offset += 2 ;\n proto_tree_add_item ( rropt_tree , hf_dns_opt_client_netmask , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n cur_offset += 1 ;\n proto_tree_add_item ( rropt_tree , hf_dns_opt_client_scope , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n cur_offset += 1 ;\n if ( optlen - 4 > 16 ) {\n expert_add_info ( pinfo , rroptlen , & ei_dns_opt_bad_length ) ;\n optlen = 20 ;\n }\n tvb_memcpy ( tvb , ip_addr . bytes , cur_offset , ( optlen - 4 ) ) ;\n switch ( family ) {\n case AFNUM_INET : proto_tree_add_ipv4 ( rropt_tree , hf_dns_opt_client_addr4 , tvb , cur_offset , ( optlen - 4 ) , ip_addr . addr ) ;\n break ;\n case AFNUM_INET6 : proto_tree_add_ipv6 ( rropt_tree , hf_dns_opt_client_addr6 , tvb , cur_offset , ( optlen - 4 ) , ip_addr . bytes ) ;\n break ;\n default : proto_tree_add_item ( rropt_tree , hf_dns_opt_client_addr , tvb , cur_offset , ( optlen - 4 ) , ENC_NA ) ;\n break ;\n }\n cur_offset += ( optlen - 4 ) ;\n rropt_len -= optlen ;\n }\n break ;\n default : cur_offset += optlen ;\n rropt_len -= optlen ;\n break ;\n }\n }\n }\n break ;\n case T_APL : {\n int rr_len = data_len ;\n guint16 afamily ;\n guint8 afdpart_len ;\n guint8 * addr_copy ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %s\" , name ) ;\n }\n while ( rr_len > 1 ) {\n afamily = tvb_get_ntohs ( tvb , cur_offset ) ;\n proto_tree_add_item ( rr_tree , hf_dns_apl_address_family , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n cur_offset += 2 ;\n rr_len -= 2 ;\n proto_tree_add_item ( rr_tree , hf_dns_apl_coded_prefix , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n cur_offset += 1 ;\n rr_len -= 1 ;\n afdpart_len = tvb_get_guint8 ( tvb , cur_offset ) & DNS_APL_AFDLENGTH ;\n proto_tree_add_item ( rr_tree , hf_dns_apl_negation , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rr_tree , hf_dns_apl_afdlength , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n cur_offset += 1 ;\n rr_len -= 1 ;\n if ( afamily == 1 && afdpart_len <= 4 ) {\n addr_copy = ( guint8 * ) wmem_alloc0 ( wmem_file_scope ( ) , 4 ) ;\n tvb_memcpy ( tvb , ( guint8 * ) addr_copy , cur_offset , afdpart_len ) ;\n proto_tree_add_ipv4 ( rr_tree , hf_dns_apl_afdpart_ipv4 , tvb , cur_offset , afdpart_len , * addr_copy ) ;\n }\n else if ( afamily == 2 && afdpart_len <= 16 ) {\n addr_copy = ( guint8 * ) wmem_alloc0 ( wmem_file_scope ( ) , 16 ) ;\n tvb_memcpy ( tvb , ( guint8 * ) addr_copy , cur_offset , afdpart_len ) ;\n proto_tree_add_ipv6 ( rr_tree , hf_dns_apl_afdpart_ipv6 , tvb , cur_offset , afdpart_len , addr_copy ) ;\n }\n else {\n proto_tree_add_item ( rr_tree , hf_dns_apl_afdpart_data , tvb , cur_offset , afdpart_len , ENC_NA ) ;\n }\n cur_offset += afdpart_len ;\n rr_len -= afdpart_len ;\n }\n }\n break ;\n case T_DS : case T_CDS : case T_DLV : {\n int rr_len = data_len ;\n proto_tree_add_item ( rr_tree , hf_dns_ds_key_id , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n cur_offset += 2 ;\n rr_len -= 2 ;\n proto_tree_add_item ( rr_tree , hf_dns_ds_algorithm , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n cur_offset += 1 ;\n rr_len -= 1 ;\n proto_tree_add_item ( rr_tree , hf_dns_ds_digest_type , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n cur_offset += 1 ;\n rr_len -= 1 ;\n proto_tree_add_item ( rr_tree , hf_dns_ds_digest , tvb , cur_offset , rr_len , ENC_NA ) ;\n }\n break ;\n case T_SSHFP : {\n int rr_len = data_len ;\n proto_tree_add_item ( rr_tree , hf_dns_sshfp_algorithm , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n cur_offset += 1 ;\n rr_len -= 1 ;\n proto_tree_add_item ( rr_tree , hf_dns_sshfp_fingerprint_type , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n cur_offset += 1 ;\n rr_len -= 1 ;\n if ( rr_len != 0 ) {\n proto_tree_add_item ( rr_tree , hf_dns_sshfp_fingerprint , tvb , cur_offset , rr_len , ENC_NA ) ;\n }\n }\n break ;\n case T_IPSECKEY : {\n int rr_len = data_len ;\n guint8 gw_type ;\n const guchar * gw ;\n int gw_name_len ;\n proto_tree_add_item ( rr_tree , hf_dns_ipseckey_gateway_precedence , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n cur_offset += 1 ;\n rr_len -= 1 ;\n proto_tree_add_item ( rr_tree , hf_dns_ipseckey_gateway_type , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n gw_type = tvb_get_guint8 ( tvb , cur_offset ) ;\n cur_offset += 1 ;\n rr_len -= 1 ;\n proto_tree_add_item ( rr_tree , hf_dns_ipseckey_gateway_algorithm , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n cur_offset += 1 ;\n rr_len -= 1 ;\n switch ( gw_type ) {\n case 0 : break ;\n case 1 : proto_tree_add_item ( rr_tree , hf_dns_ipseckey_gateway_ipv4 , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n cur_offset += 4 ;\n rr_len -= 4 ;\n break ;\n case 2 : proto_tree_add_item ( rr_tree , hf_dns_ipseckey_gateway_ipv6 , tvb , cur_offset , 16 , ENC_NA ) ;\n cur_offset += 16 ;\n rr_len -= 16 ;\n break ;\n case 3 : gw_name_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & gw ) ;\n proto_tree_add_string ( rr_tree , hf_dns_ipseckey_gateway_dns , tvb , cur_offset , gw_name_len , gw ) ;\n cur_offset += gw_name_len ;\n rr_len -= gw_name_len ;\n break ;\n default : break ;\n }\n if ( rr_len != 0 ) {\n proto_tree_add_item ( rr_tree , hf_dns_ipseckey_public_key , tvb , cur_offset , rr_len , ENC_NA ) ;\n }\n }\n break ;\n case T_RRSIG : case T_SIG : {\n int rr_len = data_len ;\n const guchar * signer_name ;\n int signer_name_len ;\n proto_item * ti ;\n proto_tree_add_item ( rr_tree , hf_dns_rrsig_type_covered , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n cur_offset += 2 ;\n rr_len -= 2 ;\n proto_tree_add_item ( rr_tree , hf_dns_rrsig_algorithm , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n cur_offset += 1 ;\n rr_len -= 1 ;\n proto_tree_add_item ( rr_tree , hf_dns_rrsig_labels , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n cur_offset += 1 ;\n rr_len -= 1 ;\n ti = proto_tree_add_item ( rr_tree , hf_dns_rrsig_original_ttl , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n proto_item_append_text ( ti , \" (%s)\" , time_secs_to_str ( wmem_packet_scope ( ) , tvb_get_ntohl ( tvb , cur_offset ) ) ) ;\n cur_offset += 4 ;\n rr_len -= 4 ;\n proto_tree_add_item ( rr_tree , hf_dns_rrsig_signature_expiration , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n cur_offset += 4 ;\n rr_len -= 4 ;\n proto_tree_add_item ( rr_tree , hf_dns_rrsig_signature_inception , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n cur_offset += 4 ;\n rr_len -= 4 ;\n proto_tree_add_item ( rr_tree , hf_dns_rrsig_key_tag , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n cur_offset += 2 ;\n rr_len -= 2 ;\n signer_name_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & signer_name ) ;\n proto_tree_add_string ( rr_tree , hf_dns_rrsig_signers_name , tvb , cur_offset , signer_name_len , signer_name ) ;\n cur_offset += signer_name_len ;\n rr_len -= signer_name_len ;\n if ( rr_len != 0 ) {\n proto_tree_add_item ( rr_tree , hf_dns_rrsig_signature , tvb , cur_offset , rr_len , ENC_NA ) ;\n }\n }\n break ;\n case T_NSEC : {\n int rr_len = data_len ;\n const guchar * next_domain_name ;\n int next_domain_name_len ;\n next_domain_name_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & next_domain_name ) ;\n name_out = format_text ( next_domain_name , strlen ( next_domain_name ) ) ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %s\" , name_out ) ;\n }\n proto_item_append_text ( trr , \", next domain name %s\" , name_out ) ;\n proto_tree_add_string ( rr_tree , hf_dns_nsec_next_domain_name , tvb , cur_offset , next_domain_name_len , name_out ) ;\n cur_offset += next_domain_name_len ;\n rr_len -= next_domain_name_len ;\n dissect_type_bitmap ( rr_tree , tvb , cur_offset , rr_len ) ;\n }\n break ;\n case T_DNSKEY : case T_CDNSKEY : {\n int rr_len = data_len ;\n proto_item * tf , * ti_gen ;\n proto_tree * flags_tree ;\n guint16 key_id ;\n guint8 algo ;\n tf = proto_tree_add_item ( rr_tree , hf_dns_dnskey_flags , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n flags_tree = proto_item_add_subtree ( tf , ett_key_flags ) ;\n proto_tree_add_item ( flags_tree , hf_dns_dnskey_flags_zone_key , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( flags_tree , hf_dns_dnskey_flags_key_revoked , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( flags_tree , hf_dns_dnskey_flags_secure_entry_point , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( flags_tree , hf_dns_dnskey_flags_reserved , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n cur_offset += 2 ;\n rr_len -= 2 ;\n proto_tree_add_item ( flags_tree , hf_dns_dnskey_protocol , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n cur_offset += 1 ;\n rr_len -= 1 ;\n proto_tree_add_item ( flags_tree , hf_dns_dnskey_algorithm , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n algo = tvb_get_guint8 ( tvb , cur_offset ) ;\n cur_offset += 1 ;\n rr_len -= 1 ;\n key_id = compute_key_id ( tvb , cur_offset - 4 , rr_len + 4 , algo ) ;\n ti_gen = proto_tree_add_uint ( rr_tree , hf_dns_dnskey_key_id , tvb , 0 , 0 , key_id ) ;\n PROTO_ITEM_SET_GENERATED ( ti_gen ) ;\n proto_tree_add_item ( rr_tree , hf_dns_dnskey_public_key , tvb , cur_offset , rr_len , ENC_NA ) ;\n }\n break ;\n case T_DHCID : {\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %s\" , name ) ;\n }\n proto_tree_add_item ( rr_tree , hf_dns_dhcid_rdata , tvb , cur_offset , data_len , ENC_NA ) ;\n }\n break ;\n case T_NSEC3 : {\n int rr_len , initial_offset = cur_offset ;\n guint8 salt_len , hash_len ;\n proto_item * flags_item ;\n proto_tree * flags_tree ;\n proto_tree_add_item ( rr_tree , hf_dns_nsec3_algo , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n cur_offset += 1 ;\n flags_item = proto_tree_add_item ( rr_tree , hf_dns_nsec3_flags , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n flags_tree = proto_item_add_subtree ( flags_item , ett_nsec3_flags ) ;\n proto_tree_add_item ( flags_tree , hf_dns_nsec3_flag_optout , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n cur_offset += 1 ;\n proto_tree_add_item ( rr_tree , hf_dns_nsec3_iterations , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n cur_offset += 2 ;\n proto_tree_add_item ( rr_tree , hf_dns_nsec3_salt_length , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n salt_len = tvb_get_guint8 ( tvb , cur_offset ) ;\n cur_offset += 1 ;\n proto_tree_add_item ( rr_tree , hf_dns_nsec3_salt_value , tvb , cur_offset , salt_len , ENC_NA ) ;\n cur_offset += salt_len ;\n proto_tree_add_item ( rr_tree , hf_dns_nsec3_hash_length , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n hash_len = tvb_get_guint8 ( tvb , cur_offset ) ;\n cur_offset += 1 ;\n proto_tree_add_item ( rr_tree , hf_dns_nsec3_hash_value , tvb , cur_offset , hash_len , ENC_NA ) ;\n cur_offset += hash_len ;\n rr_len = data_len - ( cur_offset - initial_offset ) ;\n dissect_type_bitmap ( rr_tree , tvb , cur_offset , rr_len ) ;\n }\n break ;\n case T_NSEC3PARAM : {\n int salt_len ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %s\" , name ) ;\n }\n proto_tree_add_item ( rr_tree , hf_dns_nsec3_algo , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n cur_offset += 1 ;\n proto_tree_add_item ( rr_tree , hf_dns_nsec3_flags , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n cur_offset += 1 ;\n proto_tree_add_item ( rr_tree , hf_dns_nsec3_iterations , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n cur_offset += 2 ;\n proto_tree_add_item ( rr_tree , hf_dns_nsec3_salt_length , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n salt_len = tvb_get_guint8 ( tvb , cur_offset ) ;\n cur_offset += 1 ;\n proto_tree_add_item ( rr_tree , hf_dns_nsec3_salt_value , tvb , cur_offset , salt_len , ENC_NA ) ;\n }\n break ;\n case T_TLSA : {\n int rr_len = data_len ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %s\" , name ) ;\n }\n proto_tree_add_item ( rr_tree , hf_dns_tlsa_certificate_usage , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n cur_offset ++ ;\n rr_len -- ;\n proto_tree_add_item ( rr_tree , hf_dns_tlsa_selector , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n cur_offset ++ ;\n rr_len -- ;\n proto_tree_add_item ( rr_tree , hf_dns_tlsa_matching_type , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n cur_offset ++ ;\n rr_len -- ;\n proto_tree_add_item ( rr_tree , hf_dns_tlsa_certificate_association_data , tvb , cur_offset , rr_len , ENC_NA ) ;\n }\n break ;\n case T_HIP : {\n guint8 hit_len ;\n guint16 pk_len ;\n int rr_len = data_len ;\n int rendezvous_len ;\n const guchar * rend_server_dns_name ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %s\" , name ) ;\n }\n hit_len = tvb_get_guint8 ( tvb , cur_offset ) ;\n proto_tree_add_item ( rr_tree , hf_dns_hip_hit_length , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n cur_offset += 1 ;\n rr_len -= 1 ;\n proto_tree_add_item ( rr_tree , hf_dns_hip_pk_algo , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n cur_offset += 1 ;\n rr_len -= 1 ;\n pk_len = tvb_get_ntohs ( tvb , cur_offset ) ;\n proto_tree_add_item ( rr_tree , hf_dns_hip_pk_length , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n cur_offset += 2 ;\n rr_len -= 2 ;\n proto_tree_add_item ( rr_tree , hf_dns_hip_hit , tvb , cur_offset , hit_len , ENC_NA ) ;\n cur_offset += hit_len ;\n rr_len -= hit_len ;\n proto_tree_add_item ( rr_tree , hf_dns_hip_pk , tvb , cur_offset , pk_len , ENC_NA ) ;\n cur_offset += pk_len ;\n rr_len -= pk_len ;\n while ( rr_len > 1 ) {\n rendezvous_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & rend_server_dns_name ) ;\n proto_tree_add_string ( rr_tree , hf_dns_hip_rendezvous_server , tvb , cur_offset , rendezvous_len , rend_server_dns_name ) ;\n cur_offset += rendezvous_len ;\n rr_len -= rendezvous_len ;\n }\n }\n break ;\n case T_OPENPGPKEY : {\n proto_tree_add_item ( rr_tree , hf_dns_openpgpkey , tvb , cur_offset , data_len , ENC_ASCII | ENC_NA ) ;\n }\n break ;\n case T_SPF : {\n int rr_len = data_len ;\n int spf_offset ;\n int spf_len ;\n spf_offset = cur_offset ;\n while ( rr_len != 0 ) {\n spf_len = tvb_get_guint8 ( tvb , spf_offset ) ;\n proto_tree_add_item ( rr_tree , hf_dns_spf_length , tvb , spf_offset , 1 , ENC_BIG_ENDIAN ) ;\n spf_offset += 1 ;\n rr_len -= 1 ;\n proto_tree_add_item ( rr_tree , hf_dns_spf , tvb , spf_offset , spf_len , ENC_ASCII | ENC_NA ) ;\n spf_offset += spf_len ;\n rr_len -= spf_len ;\n }\n }\n break ;\n case T_NID : {\n proto_tree_add_item ( rr_tree , hf_dns_ilnp_nodeid_preference , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n cur_offset += 2 ;\n proto_tree_add_item ( rr_tree , hf_dns_ilnp_nodeid , tvb , cur_offset , 8 , ENC_NA ) ;\n }\n break ;\n case T_L32 : {\n proto_tree_add_item ( rr_tree , hf_dns_ilnp_locator32_preference , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n cur_offset += 2 ;\n proto_tree_add_item ( rr_tree , hf_dns_ilnp_locator32 , tvb , cur_offset , 4 , ENC_NA ) ;\n }\n break ;\n case T_L64 : {\n proto_tree_add_item ( rr_tree , hf_dns_ilnp_locator64_preference , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n cur_offset += 2 ;\n proto_tree_add_item ( rr_tree , hf_dns_ilnp_locator64 , tvb , cur_offset , 8 , ENC_NA ) ;\n }\n break ;\n case T_LP : {\n int lp_len ;\n const guchar * lp_str ;\n proto_tree_add_item ( rr_tree , hf_dns_ilnp_locatorfqdn_preference , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n cur_offset += 2 ;\n lp_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & lp_str ) ;\n proto_tree_add_string ( rr_tree , hf_dns_ilnp_locatorfqdn , tvb , cur_offset , lp_len , lp_str ) ;\n }\n break ;\n case T_EUI48 : {\n proto_tree_add_item ( rr_tree , hf_dns_eui48 , tvb , cur_offset , 6 , ENC_NA ) ;\n }\n break ;\n case T_EUI64 : {\n proto_tree_add_item ( rr_tree , hf_dns_eui64 , tvb , cur_offset , 8 , ENC_NA ) ;\n }\n break ;\n case T_TKEY : {\n const guchar * tkey_algname ;\n int tkey_algname_len ;\n guint16 tkey_mode , tkey_keylen , tkey_otherlen ;\n proto_tree * key_tree ;\n proto_item * key_item ;\n tkey_algname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & tkey_algname ) ;\n proto_tree_add_string ( rr_tree , hf_dns_tkey_algo_name , tvb , cur_offset , tkey_algname_len , tkey_algname ) ;\n cur_offset += tkey_algname_len ;\n proto_tree_add_item ( rr_tree , hf_dns_tkey_signature_inception , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n cur_offset += 4 ;\n proto_tree_add_item ( rr_tree , hf_dns_tkey_signature_expiration , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n cur_offset += 4 ;\n proto_tree_add_item ( rr_tree , hf_dns_tkey_mode , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n tkey_mode = tvb_get_ntohs ( tvb , cur_offset ) ;\n cur_offset += 2 ;\n proto_tree_add_item ( rr_tree , hf_dns_tkey_error , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n cur_offset += 2 ;\n proto_tree_add_item ( rr_tree , hf_dns_tkey_key_size , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n tkey_keylen = tvb_get_ntohs ( tvb , cur_offset ) ;\n cur_offset += 2 ;\n if ( tkey_keylen != 0 ) {\n key_item = proto_tree_add_item ( rr_tree , hf_dns_tkey_key_data , tvb , cur_offset , tkey_keylen , ENC_NA ) ;\n key_tree = proto_item_add_subtree ( key_item , ett_t_key ) ;\n switch ( tkey_mode ) {\n case TKEYMODE_GSSAPI : {\n tvbuff_t * gssapi_tvb ;\n gssapi_tvb = tvb_new_subset_length ( tvb , cur_offset , tkey_keylen ) ;\n if ( tvb_strneql ( gssapi_tvb , 0 , \"NTLMSSP\" , 7 ) == 0 ) {\n call_dissector ( ntlmssp_handle , gssapi_tvb , pinfo , key_tree ) ;\n }\n else {\n call_dissector ( gssapi_handle , gssapi_tvb , pinfo , key_tree ) ;\n }\n break ;\n }\n default : break ;\n }\n cur_offset += tkey_keylen ;\n }\n proto_tree_add_item ( rr_tree , hf_dns_tkey_other_size , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n tkey_otherlen = tvb_get_ntohs ( tvb , cur_offset ) ;\n cur_offset += 2 ;\n if ( tkey_otherlen != 0 ) {\n proto_tree_add_item ( rr_tree , hf_dns_tkey_other_data , tvb , cur_offset , tkey_otherlen , ENC_NA ) ;\n }\n }\n break ;\n case T_TSIG : {\n guint16 tsig_siglen , tsig_otherlen ;\n const guchar * tsig_algname ;\n int tsig_algname_len ;\n proto_item * ti ;\n tsig_algname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & tsig_algname ) ;\n proto_tree_add_string ( rr_tree , hf_dns_tsig_algorithm_name , tvb , cur_offset , tsig_algname_len , tsig_algname ) ;\n cur_offset += tsig_algname_len ;\n ti = proto_tree_add_item ( rr_tree , hf_dns_tsig_time_signed , tvb , cur_offset , 6 , ENC_NA ) ;\n if ( tvb_get_ntohs ( tvb , cur_offset ) ) {\n proto_item_append_text ( ti , \" (high bits set)\" ) ;\n }\n cur_offset += 6 ;\n proto_tree_add_item ( rr_tree , hf_dns_tsig_fudge , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n cur_offset += 2 ;\n tsig_siglen = tvb_get_ntohs ( tvb , cur_offset ) ;\n proto_tree_add_item ( rr_tree , hf_dns_tsig_mac_size , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n cur_offset += 2 ;\n if ( tsig_siglen != 0 ) {\n proto_item * mac_item ;\n proto_tree * mac_tree ;\n tvbuff_t * sub_tvb ;\n mac_item = proto_tree_add_item ( rr_tree , hf_dns_tsig_mac , tvb , cur_offset , tsig_siglen , ENC_NA ) ;\n mac_tree = proto_item_add_subtree ( mac_item , ett_dns_mac ) ;\n sub_tvb = tvb_new_subset_length ( tvb , cur_offset , tsig_siglen ) ;\n if ( ! dissector_try_string ( dns_tsig_dissector_table , tsig_algname , sub_tvb , pinfo , mac_tree , NULL ) ) {\n expert_add_info_format ( pinfo , mac_item , & ei_dns_tsig_alg , \"No dissector for algorithm:%s\" , tsig_algname ) ;\n }\n cur_offset += tsig_siglen ;\n }\n proto_tree_add_item ( rr_tree , hf_dns_tsig_original_id , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n cur_offset += 2 ;\n proto_tree_add_item ( rr_tree , hf_dns_tsig_error , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n cur_offset += 2 ;\n proto_tree_add_item ( rr_tree , hf_dns_tsig_other_len , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n tsig_otherlen = tvb_get_ntohs ( tvb , cur_offset ) ;\n cur_offset += 2 ;\n if ( tsig_otherlen != 0 ) {\n proto_tree_add_item ( rr_tree , hf_dns_tsig_other_data , tvb , cur_offset , tsig_otherlen , ENC_NA ) ;\n }\n }\n break ;\n case T_CAA : {\n proto_item * caa_item ;\n proto_tree * caa_tree ;\n guint8 tag_len ;\n const char * tag ;\n gushort value_len ;\n const guchar * value ;\n int cur_hf = - 1 ;\n caa_item = proto_tree_add_item ( rr_tree , hf_dns_caa_flags , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n caa_tree = proto_item_add_subtree ( caa_item , ett_caa_flags ) ;\n proto_tree_add_item ( caa_tree , hf_dns_caa_flag_issuer_critical , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n cur_offset ++ ;\n tag_len = tvb_get_guint8 ( tvb , cur_offset ) ;\n tag = tvb_get_string_enc ( wmem_packet_scope ( ) , tvb , cur_offset + 1 , tag_len , ENC_ASCII | ENC_NA ) ;\n value_len = data_len - ( tag_len + 2 ) ;\n value = tvb_get_string_enc ( wmem_packet_scope ( ) , tvb , cur_offset + 1 + tag_len , value_len , ENC_ASCII | ENC_NA ) ;\n value = format_text ( value , value_len ) ;\n if ( strncmp ( tag , \"issue\" , tag_len ) == 0 ) {\n cur_hf = hf_dns_caa_issue ;\n }\n else if ( strncmp ( tag , \"issuewild\" , tag_len ) == 0 ) {\n cur_hf = hf_dns_caa_issuewild ;\n }\n else if ( strncmp ( tag , \"iodef\" , tag_len ) == 0 ) {\n cur_hf = hf_dns_caa_iodef ;\n }\n else {\n cur_hf = hf_dns_caa_unknown ;\n }\n caa_item = proto_tree_add_string ( rr_tree , cur_hf , tvb , cur_offset , 1 + tag_len + value_len , value ) ;\n caa_tree = proto_item_add_subtree ( caa_item , ett_caa_data ) ;\n proto_tree_add_uint ( caa_tree , hf_dns_caa_tag_length , tvb , cur_offset , 1 , tag_len ) ;\n proto_tree_add_string ( caa_tree , hf_dns_caa_tag , tvb , cur_offset + 1 , tag_len , tag ) ;\n proto_tree_add_string ( caa_tree , hf_dns_caa_value , tvb , cur_offset + 1 + tag_len , value_len , value ) ;\n }\n break ;\n case T_WINS : {\n int rr_len = data_len ;\n guint32 nservers ;\n proto_tree_add_item ( rr_tree , hf_dns_wins_local_flag , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n cur_offset += 4 ;\n rr_len -= 4 ;\n proto_tree_add_item ( rr_tree , hf_dns_wins_lookup_timeout , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n cur_offset += 4 ;\n rr_len -= 4 ;\n proto_tree_add_item ( rr_tree , hf_dns_wins_cache_timeout , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n cur_offset += 4 ;\n rr_len -= 4 ;\n proto_tree_add_item ( rr_tree , hf_dns_wins_nb_wins_servers , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n nservers = tvb_get_ntohl ( tvb , cur_offset ) ;\n cur_offset += 4 ;\n rr_len -= 4 ;\n while ( rr_len != 0 && nservers != 0 ) {\n proto_tree_add_item ( rr_tree , hf_dns_wins_server , tvb , cur_offset , 4 , ENC_NA ) ;\n cur_offset += 4 ;\n rr_len -= 4 ;\n nservers -- ;\n }\n }\n break ;\n case T_WINS_R : {\n const guchar * dname ;\n int dname_len ;\n proto_tree_add_item ( rr_tree , hf_dns_winsr_local_flag , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n cur_offset += 4 ;\n proto_tree_add_item ( rr_tree , hf_dns_winsr_lookup_timeout , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n cur_offset += 4 ;\n proto_tree_add_item ( rr_tree , hf_dns_winsr_cache_timeout , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n cur_offset += 4 ;\n dname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & dname ) ;\n name_out = format_text ( dname , strlen ( dname ) ) ;\n proto_tree_add_string ( rr_tree , hf_dns_winsr_name_result_domain , tvb , cur_offset , dname_len , name_out ) ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %s\" , name_out ) ;\n }\n proto_item_append_text ( trr , \", name result domain %s\" , name_out ) ;\n }\n break ;\n default : expert_add_info_format ( pinfo , trr , & ei_dns_undecoded_option , \"Dissector for DNS Type (%d)\" \" code not implemented, Contact Wireshark developers\" \" if you want this supported\" , dns_type ) ;\n proto_tree_add_item ( rr_tree , hf_dns_data , tvb , cur_offset , data_len , ENC_NA ) ;\n break ;\n }\n data_offset += data_len ;\n return data_offset - data_start ;\n }", "idx": 1440}
{"hash": -2723830976796502611, "project": "chrome", "size": 12, "label": 0, "functionSource": "static vpx_codec_err_t ctrl_set_reference ( vpx_codec_alg_priv_t * ctx , va_list args ) {\n vpx_ref_frame_t * const frame = va_arg ( args , vpx_ref_frame_t * ) ;\n if ( frame != NULL ) {\n YV12_BUFFER_CONFIG sd ;\n image2yuvconfig ( & frame -> img , & sd ) ;\n vp9_set_reference_enc ( ctx -> cpi , ref_frame_to_vp9_reframe ( frame -> frame_type ) , & sd ) ;\n return VPX_CODEC_OK ;\n }\n else {\n return VPX_CODEC_INVALID_PARAM ;\n }\n }", "idx": 1441}
{"hash": 3246343243711264189, "project": "debian", "size": 14, "label": 1, "functionSource": "static void handle_raw_data ( char * packet , int len , struct query * q , int dns_fd , int tun_fd , int userid ) {\n if ( check_user_and_ip ( userid , q ) != 0 ) {\n return ;\n }\n users [ userid ] . last_pkt = time ( NULL ) ;\n memcpy ( & ( users [ userid ] . q ) , q , sizeof ( struct query ) ) ;\n users [ userid ] . inpacket . offset = 0 ;\n memcpy ( users [ userid ] . inpacket . data , packet , len ) ;\n users [ userid ] . inpacket . len = len ;\n if ( debug >= 1 ) {\n fprintf ( stderr , \"IN pkt raw, total %d, from user %d\\n\" , users [ userid ] . inpacket . len , userid ) ;\n }\n handle_full_packet ( tun_fd , dns_fd , userid ) ;\n }", "idx": 1442}
{"hash": 3935234056444097745, "project": "debian", "size": 41, "label": 0, "functionSource": "static int rtp_packetize_h263 ( sout_stream_id_sys_t * id , block_t * in ) {\n uint8_t * p_data = in -> p_buffer ;\n int i_data = in -> i_buffer ;\n int i ;\n int i_max = rtp_mtu ( id ) - RTP_H263_HEADER_SIZE ;\n int i_count ;\n int b_p_bit ;\n int b_v_bit = 0 ;\n int i_plen = 0 ;\n int i_pebit = 0 ;\n uint16_t h ;\n if ( i_data < 2 ) {\n block_Release ( in ) ;\n return VLC_EGENERIC ;\n }\n if ( p_data [ 0 ] || p_data [ 1 ] ) {\n block_Release ( in ) ;\n return VLC_EGENERIC ;\n }\n p_data += 2 ;\n i_data -= 2 ;\n i_count = ( i_data + i_max - 1 ) / i_max ;\n for ( i = 0 ;\n i < i_count ;\n i ++ ) {\n int i_payload = __MIN ( i_max , i_data ) ;\n block_t * out = block_Alloc ( RTP_H263_PAYLOAD_START + i_payload ) ;\n b_p_bit = ( i == 0 ) ? 1 : 0 ;\n h = ( b_p_bit << 10 ) | ( b_v_bit << 9 ) | ( i_plen << 3 ) | i_pebit ;\n rtp_packetize_common ( id , out , ( i == i_count - 1 ) ? 1 : 0 , in -> i_pts > VLC_TS_INVALID ? in -> i_pts : in -> i_dts ) ;\n SetWBE ( out -> p_buffer + 12 , h ) ;\n memcpy ( & out -> p_buffer [ RTP_H263_PAYLOAD_START ] , p_data , i_payload ) ;\n out -> i_dts = in -> i_dts + i * in -> i_length / i_count ;\n out -> i_length = in -> i_length / i_count ;\n rtp_packetize_send ( id , out ) ;\n p_data += i_payload ;\n i_data -= i_payload ;\n }\n block_Release ( in ) ;\n return VLC_SUCCESS ;\n }", "idx": 1443}
{"hash": 5357882892791796049, "project": "debian", "size": 3, "label": 0, "functionSource": "static void e1000e_intrmgr_pci_realize ( E1000ECore * core ) {\n e1000e_intrmgr_initialize_all_timers ( core , true ) ;\n }", "idx": 1444}
{"hash": 2895622461494525400, "project": "debian", "size": 18, "label": 0, "functionSource": "static void test_bug33831 ( void ) {\n MYSQL * l_mysql ;\n DBUG_ENTER ( \"test_bug33831\" ) ;\n if ( ! ( l_mysql = mysql_client_init ( NULL ) ) ) {\n myerror ( \"mysql_client_init() failed\" ) ;\n DIE_UNLESS ( 0 ) ;\n }\n if ( ! ( mysql_real_connect ( l_mysql , opt_host , opt_user , opt_password , current_db , opt_port , opt_unix_socket , 0 ) ) ) {\n myerror ( \"connection failed\" ) ;\n DIE_UNLESS ( 0 ) ;\n }\n if ( mysql_real_connect ( l_mysql , opt_host , opt_user , opt_password , current_db , opt_port , opt_unix_socket , 0 ) ) {\n myerror ( \"connection should have failed\" ) ;\n DIE_UNLESS ( 0 ) ;\n }\n mysql_close ( l_mysql ) ;\n DBUG_VOID_RETURN ;\n }", "idx": 1445}
{"hash": -7434014980763120366, "project": "debian", "size": 3, "label": 0, "functionSource": "int dissect_ber_bitstring ( gboolean implicit_tag , asn1_ctx_t * actx , proto_tree * parent_tree , tvbuff_t * tvb , int offset , const asn_namedbit * named_bits , gint hf_id , gint ett_id , tvbuff_t * * out_tvb ) {\n return dissect_ber_constrained_bitstring ( implicit_tag , actx , parent_tree , tvb , offset , - 1 , - 1 , named_bits , hf_id , ett_id , out_tvb ) ;\n }", "idx": 1446}
{"hash": 6632536031698733342, "project": "debian", "size": 5, "label": 0, "functionSource": "static int opt_sections ( void * optctx , const char * opt , const char * arg ) {\n printf ( \"Sections:\\n\" \"W.. = Section is a wrapper (contains other sections, no local entries)\\n\" \".A. = Section contains an array of elements of the same type\\n\" \"..V = Section may contain a variable number of fields with variable keys\\n\" \"FLAGS NAME/UNIQUE_NAME\\n\" \"---\\n\" ) ;\n print_section ( SECTION_ID_ROOT , 0 ) ;\n return 0 ;\n }", "idx": 1447}
{"hash": 1700977331036764538, "project": "debian", "size": 11, "label": 0, "functionSource": "int EVP_CIPHER_CTX_reset ( EVP_CIPHER_CTX * c ) {\n if ( c == NULL ) return 1 ;\n if ( c -> cipher != NULL ) {\n if ( c -> cipher -> cleanup && ! c -> cipher -> cleanup ( c ) ) return 0 ;\n if ( c -> cipher_data && c -> cipher -> ctx_size ) OPENSSL_cleanse ( c -> cipher_data , c -> cipher -> ctx_size ) ;\n }\n OPENSSL_free ( c -> cipher_data ) ;\n # ifndef OPENSSL_NO_ENGINE ENGINE_finish ( c -> engine ) ;\n # endif memset ( c , 0 , sizeof ( * c ) ) ;\n return 1 ;\n }", "idx": 1448}
{"hash": 3919646340804521652, "project": "debian", "size": 32, "label": 0, "functionSource": "static enum write_one_status write_one ( struct sha1file * f , struct object_entry * e , off_t * offset ) {\n unsigned long size ;\n int recursing ;\n recursing = ( e -> idx . offset == 1 ) ;\n if ( recursing ) {\n warning ( \"recursive delta detected for object %s\" , sha1_to_hex ( e -> idx . sha1 ) ) ;\n return WRITE_ONE_RECURSIVE ;\n }\n else if ( e -> idx . offset || e -> preferred_base ) {\n return WRITE_ONE_SKIP ;\n }\n if ( e -> delta ) {\n e -> idx . offset = 1 ;\n switch ( write_one ( f , e -> delta , offset ) ) {\n case WRITE_ONE_RECURSIVE : e -> delta = NULL ;\n break ;\n default : break ;\n case WRITE_ONE_BREAK : e -> idx . offset = recursing ;\n return WRITE_ONE_BREAK ;\n }\n }\n e -> idx . offset = * offset ;\n size = write_object ( f , e , * offset ) ;\n if ( ! size ) {\n e -> idx . offset = recursing ;\n return WRITE_ONE_BREAK ;\n }\n written_list [ nr_written ++ ] = & e -> idx ;\n if ( signed_add_overflows ( * offset , size ) ) die ( \"pack too large for current definition of off_t\" ) ;\n * offset += size ;\n return WRITE_ONE_WRITTEN ;\n }", "idx": 1449}
{"hash": 453825853695477219, "project": "debian", "size": 16, "label": 0, "functionSource": "static int get_consumed_bytes ( MpegEncContext * s , int buf_size ) {\n int pos = ( get_bits_count ( & s -> gb ) + 7 ) >> 3 ;\n if ( s -> divx_packed || s -> avctx -> hwaccel ) {\n return buf_size ;\n }\n else if ( s -> flags & CODEC_FLAG_TRUNCATED ) {\n pos -= s -> parse_context . last_index ;\n if ( pos < 0 ) pos = 0 ;\n return pos ;\n }\n else {\n if ( pos == 0 ) pos = 1 ;\n if ( pos + 10 > buf_size ) pos = buf_size ;\n return pos ;\n }\n }", "idx": 1450}
{"hash": -4596135714614925483, "project": "debian", "size": 667, "label": 1, "functionSource": "static int scan ( Scanner * s ) {\n uchar * cursor = s -> cur ;\n char * str , * ptr = NULL ;\n std : s -> tok = cursor ;\n s -> len = 0 ;\n # line 311 \"ext/date/lib/parse_iso_intervals.re\" # line 291 \"ext/date/lib/parse_iso_intervals.c\" {\n YYCTYPE yych ;\n unsigned int yyaccept = 0 ;\n static const unsigned char yybm [ ] = {\n 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 128 , 128 , 128 , 128 , 128 , 128 , 128 , 128 , 128 , 128 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , }\n ;\n YYDEBUG ( 0 , * YYCURSOR ) ;\n if ( ( YYLIMIT - YYCURSOR ) < 20 ) YYFILL ( 20 ) ;\n yych = * YYCURSOR ;\n if ( yych <= ',' ) {\n if ( yych <= '\\n' ) {\n if ( yych <= 0x00 ) goto yy9 ;\n if ( yych <= 0x08 ) goto yy11 ;\n if ( yych <= '\\t' ) goto yy7 ;\n goto yy9 ;\n }\n else {\n if ( yych == ' ' ) goto yy7 ;\n if ( yych <= '+' ) goto yy11 ;\n goto yy7 ;\n }\n }\n else {\n if ( yych <= 'O' ) {\n if ( yych <= '-' ) goto yy11 ;\n if ( yych <= '/' ) goto yy7 ;\n if ( yych <= '9' ) goto yy4 ;\n goto yy11 ;\n }\n else {\n if ( yych <= 'P' ) goto yy5 ;\n if ( yych != 'R' ) goto yy11 ;\n }\n }\n YYDEBUG ( 2 , * YYCURSOR ) ;\n ++ YYCURSOR ;\n if ( ( yych = * YYCURSOR ) <= '/' ) goto yy3 ;\n if ( yych <= '9' ) goto yy98 ;\n yy3 : YYDEBUG ( 3 , * YYCURSOR ) ;\n # line 424 \"ext/date/lib/parse_iso_intervals.re\" {\n add_error ( s , \"Unexpected character\" ) ;\n goto std ;\n }\n # line 366 \"ext/date/lib/parse_iso_intervals.c\" yy4 : YYDEBUG ( 4 , * YYCURSOR ) ;\n yyaccept = 0 ;\n yych = * ( YYMARKER = ++ YYCURSOR ) ;\n if ( yych <= '/' ) goto yy3 ;\n if ( yych <= '9' ) goto yy59 ;\n goto yy3 ;\n yy5 : YYDEBUG ( 5 , * YYCURSOR ) ;\n yyaccept = 1 ;\n yych = * ( YYMARKER = ++ YYCURSOR ) ;\n if ( yych <= '/' ) goto yy6 ;\n if ( yych <= '9' ) goto yy12 ;\n if ( yych == 'T' ) goto yy14 ;\n yy6 : YYDEBUG ( 6 , * YYCURSOR ) ;\n # line 351 \"ext/date/lib/parse_iso_intervals.re\" {\n timelib_sll nr ;\n int in_time = 0 ;\n DEBUG_OUTPUT ( \"period\" ) ;\n TIMELIB_INIT ;\n ptr ++ ;\n do {\n if ( * ptr == 'T' ) {\n in_time = 1 ;\n ptr ++ ;\n }\n if ( * ptr == '\\0' ) {\n add_error ( s , \"Missing expected time part\" ) ;\n break ;\n }\n nr = timelib_get_unsigned_nr ( ( char * * ) & ptr , 12 ) ;\n switch ( * ptr ) {\n case 'Y' : s -> period -> y = nr ;\n break ;\n case 'W' : s -> period -> d = nr * 7 ;\n break ;\n case 'D' : s -> period -> d = nr ;\n break ;\n case 'H' : s -> period -> h = nr ;\n break ;\n case 'S' : s -> period -> s = nr ;\n break ;\n case 'M' : if ( in_time ) {\n s -> period -> i = nr ;\n }\n else {\n s -> period -> m = nr ;\n }\n break ;\n default : add_error ( s , \"Undefined period specifier\" ) ;\n break ;\n }\n ptr ++ ;\n }\n while ( * ptr ) ;\n s -> have_period = 1 ;\n TIMELIB_DEINIT ;\n return TIMELIB_PERIOD ;\n }\n # line 424 \"ext/date/lib/parse_iso_intervals.c\" yy7 : YYDEBUG ( 7 , * YYCURSOR ) ;\n ++ YYCURSOR ;\n YYDEBUG ( 8 , * YYCURSOR ) ;\n # line 413 \"ext/date/lib/parse_iso_intervals.re\" {\n goto std ;\n }\n # line 433 \"ext/date/lib/parse_iso_intervals.c\" yy9 : YYDEBUG ( 9 , * YYCURSOR ) ;\n ++ YYCURSOR ;\n YYDEBUG ( 10 , * YYCURSOR ) ;\n # line 418 \"ext/date/lib/parse_iso_intervals.re\" {\n s -> pos = cursor ;\n s -> line ++ ;\n goto std ;\n }\n # line 443 \"ext/date/lib/parse_iso_intervals.c\" yy11 : YYDEBUG ( 11 , * YYCURSOR ) ;\n yych = * ++ YYCURSOR ;\n goto yy3 ;\n yy12 : YYDEBUG ( 12 , * YYCURSOR ) ;\n yych = * ++ YYCURSOR ;\n if ( yych <= 'L' ) {\n if ( yych <= '9' ) {\n if ( yych >= '0' ) goto yy25 ;\n }\n else {\n if ( yych == 'D' ) goto yy24 ;\n }\n }\n else {\n if ( yych <= 'W' ) {\n if ( yych <= 'M' ) goto yy27 ;\n if ( yych >= 'W' ) goto yy26 ;\n }\n else {\n if ( yych == 'Y' ) goto yy28 ;\n }\n }\n yy13 : YYDEBUG ( 13 , * YYCURSOR ) ;\n YYCURSOR = YYMARKER ;\n if ( yyaccept <= 0 ) {\n goto yy3 ;\n }\n else {\n goto yy6 ;\n }\n yy14 : YYDEBUG ( 14 , * YYCURSOR ) ;\n yyaccept = 1 ;\n yych = * ( YYMARKER = ++ YYCURSOR ) ;\n if ( yybm [ 0 + yych ] & 128 ) {\n goto yy15 ;\n }\n goto yy6 ;\n yy15 : YYDEBUG ( 15 , * YYCURSOR ) ;\n ++ YYCURSOR ;\n if ( ( YYLIMIT - YYCURSOR ) < 2 ) YYFILL ( 2 ) ;\n yych = * YYCURSOR ;\n YYDEBUG ( 16 , * YYCURSOR ) ;\n if ( yybm [ 0 + yych ] & 128 ) {\n goto yy15 ;\n }\n if ( yych <= 'L' ) {\n if ( yych == 'H' ) goto yy19 ;\n goto yy13 ;\n }\n else {\n if ( yych <= 'M' ) goto yy18 ;\n if ( yych != 'S' ) goto yy13 ;\n }\n yy17 : YYDEBUG ( 17 , * YYCURSOR ) ;\n yych = * ++ YYCURSOR ;\n goto yy6 ;\n yy18 : YYDEBUG ( 18 , * YYCURSOR ) ;\n yyaccept = 1 ;\n yych = * ( YYMARKER = ++ YYCURSOR ) ;\n if ( yych <= '/' ) goto yy6 ;\n if ( yych <= '9' ) goto yy22 ;\n goto yy6 ;\n yy19 : YYDEBUG ( 19 , * YYCURSOR ) ;\n yyaccept = 1 ;\n yych = * ( YYMARKER = ++ YYCURSOR ) ;\n if ( yych <= '/' ) goto yy6 ;\n if ( yych >= ':' ) goto yy6 ;\n yy20 : YYDEBUG ( 20 , * YYCURSOR ) ;\n ++ YYCURSOR ;\n if ( ( YYLIMIT - YYCURSOR ) < 2 ) YYFILL ( 2 ) ;\n yych = * YYCURSOR ;\n YYDEBUG ( 21 , * YYCURSOR ) ;\n if ( yych <= 'L' ) {\n if ( yych <= '/' ) goto yy13 ;\n if ( yych <= '9' ) goto yy20 ;\n goto yy13 ;\n }\n else {\n if ( yych <= 'M' ) goto yy18 ;\n if ( yych == 'S' ) goto yy17 ;\n goto yy13 ;\n }\n yy22 : YYDEBUG ( 22 , * YYCURSOR ) ;\n ++ YYCURSOR ;\n if ( YYLIMIT <= YYCURSOR ) YYFILL ( 1 ) ;\n yych = * YYCURSOR ;\n YYDEBUG ( 23 , * YYCURSOR ) ;\n if ( yych <= '/' ) goto yy13 ;\n if ( yych <= '9' ) goto yy22 ;\n if ( yych == 'S' ) goto yy17 ;\n goto yy13 ;\n yy24 : YYDEBUG ( 24 , * YYCURSOR ) ;\n yych = * ++ YYCURSOR ;\n if ( yych == 'T' ) goto yy14 ;\n goto yy6 ;\n yy25 : YYDEBUG ( 25 , * YYCURSOR ) ;\n yych = * ++ YYCURSOR ;\n if ( yych <= 'L' ) {\n if ( yych <= '9' ) {\n if ( yych <= '/' ) goto yy13 ;\n goto yy35 ;\n }\n else {\n if ( yych == 'D' ) goto yy24 ;\n goto yy13 ;\n }\n }\n else {\n if ( yych <= 'W' ) {\n if ( yych <= 'M' ) goto yy27 ;\n if ( yych <= 'V' ) goto yy13 ;\n }\n else {\n if ( yych == 'Y' ) goto yy28 ;\n goto yy13 ;\n }\n }\n yy26 : YYDEBUG ( 26 , * YYCURSOR ) ;\n yyaccept = 1 ;\n yych = * ( YYMARKER = ++ YYCURSOR ) ;\n if ( yych <= '/' ) goto yy6 ;\n if ( yych <= '9' ) goto yy33 ;\n if ( yych == 'T' ) goto yy14 ;\n goto yy6 ;\n yy27 : YYDEBUG ( 27 , * YYCURSOR ) ;\n yyaccept = 1 ;\n yych = * ( YYMARKER = ++ YYCURSOR ) ;\n if ( yych <= '/' ) goto yy6 ;\n if ( yych <= '9' ) goto yy31 ;\n if ( yych == 'T' ) goto yy14 ;\n goto yy6 ;\n yy28 : YYDEBUG ( 28 , * YYCURSOR ) ;\n yyaccept = 1 ;\n yych = * ( YYMARKER = ++ YYCURSOR ) ;\n if ( yych <= '/' ) goto yy6 ;\n if ( yych <= '9' ) goto yy29 ;\n if ( yych == 'T' ) goto yy14 ;\n goto yy6 ;\n yy29 : YYDEBUG ( 29 , * YYCURSOR ) ;\n ++ YYCURSOR ;\n if ( ( YYLIMIT - YYCURSOR ) < 3 ) YYFILL ( 3 ) ;\n yych = * YYCURSOR ;\n YYDEBUG ( 30 , * YYCURSOR ) ;\n if ( yych <= 'D' ) {\n if ( yych <= '/' ) goto yy13 ;\n if ( yych <= '9' ) goto yy29 ;\n if ( yych <= 'C' ) goto yy13 ;\n goto yy24 ;\n }\n else {\n if ( yych <= 'M' ) {\n if ( yych <= 'L' ) goto yy13 ;\n goto yy27 ;\n }\n else {\n if ( yych == 'W' ) goto yy26 ;\n goto yy13 ;\n }\n }\n yy31 : YYDEBUG ( 31 , * YYCURSOR ) ;\n ++ YYCURSOR ;\n if ( ( YYLIMIT - YYCURSOR ) < 3 ) YYFILL ( 3 ) ;\n yych = * YYCURSOR ;\n YYDEBUG ( 32 , * YYCURSOR ) ;\n if ( yych <= 'C' ) {\n if ( yych <= '/' ) goto yy13 ;\n if ( yych <= '9' ) goto yy31 ;\n goto yy13 ;\n }\n else {\n if ( yych <= 'D' ) goto yy24 ;\n if ( yych == 'W' ) goto yy26 ;\n goto yy13 ;\n }\n yy33 : YYDEBUG ( 33 , * YYCURSOR ) ;\n ++ YYCURSOR ;\n if ( ( YYLIMIT - YYCURSOR ) < 3 ) YYFILL ( 3 ) ;\n yych = * YYCURSOR ;\n YYDEBUG ( 34 , * YYCURSOR ) ;\n if ( yych <= '/' ) goto yy13 ;\n if ( yych <= '9' ) goto yy33 ;\n if ( yych == 'D' ) goto yy24 ;\n goto yy13 ;\n yy35 : YYDEBUG ( 35 , * YYCURSOR ) ;\n yych = * ++ YYCURSOR ;\n if ( yych <= 'L' ) {\n if ( yych <= '9' ) {\n if ( yych <= '/' ) goto yy13 ;\n }\n else {\n if ( yych == 'D' ) goto yy24 ;\n goto yy13 ;\n }\n }\n else {\n if ( yych <= 'W' ) {\n if ( yych <= 'M' ) goto yy27 ;\n if ( yych <= 'V' ) goto yy13 ;\n goto yy26 ;\n }\n else {\n if ( yych == 'Y' ) goto yy28 ;\n goto yy13 ;\n }\n }\n YYDEBUG ( 36 , * YYCURSOR ) ;\n yych = * ++ YYCURSOR ;\n if ( yych != '-' ) goto yy39 ;\n YYDEBUG ( 37 , * YYCURSOR ) ;\n yych = * ++ YYCURSOR ;\n if ( yych <= '/' ) goto yy13 ;\n if ( yych <= '0' ) goto yy40 ;\n if ( yych <= '1' ) goto yy41 ;\n goto yy13 ;\n yy38 : YYDEBUG ( 38 , * YYCURSOR ) ;\n ++ YYCURSOR ;\n if ( ( YYLIMIT - YYCURSOR ) < 3 ) YYFILL ( 3 ) ;\n yych = * YYCURSOR ;\n yy39 : YYDEBUG ( 39 , * YYCURSOR ) ;\n if ( yych <= 'L' ) {\n if ( yych <= '9' ) {\n if ( yych <= '/' ) goto yy13 ;\n goto yy38 ;\n }\n else {\n if ( yych == 'D' ) goto yy24 ;\n goto yy13 ;\n }\n }\n else {\n if ( yych <= 'W' ) {\n if ( yych <= 'M' ) goto yy27 ;\n if ( yych <= 'V' ) goto yy13 ;\n goto yy26 ;\n }\n else {\n if ( yych == 'Y' ) goto yy28 ;\n goto yy13 ;\n }\n }\n yy40 : YYDEBUG ( 40 , * YYCURSOR ) ;\n yych = * ++ YYCURSOR ;\n if ( yych <= '/' ) goto yy13 ;\n if ( yych <= '9' ) goto yy42 ;\n goto yy13 ;\n yy41 : YYDEBUG ( 41 , * YYCURSOR ) ;\n yych = * ++ YYCURSOR ;\n if ( yych <= '/' ) goto yy13 ;\n if ( yych >= '3' ) goto yy13 ;\n yy42 : YYDEBUG ( 42 , * YYCURSOR ) ;\n yych = * ++ YYCURSOR ;\n if ( yych != '-' ) goto yy13 ;\n YYDEBUG ( 43 , * YYCURSOR ) ;\n yych = * ++ YYCURSOR ;\n if ( yych <= '/' ) goto yy13 ;\n if ( yych <= '0' ) goto yy44 ;\n if ( yych <= '2' ) goto yy45 ;\n if ( yych <= '3' ) goto yy46 ;\n goto yy13 ;\n yy44 : YYDEBUG ( 44 , * YYCURSOR ) ;\n yych = * ++ YYCURSOR ;\n if ( yych <= '/' ) goto yy13 ;\n if ( yych <= '9' ) goto yy47 ;\n goto yy13 ;\n yy45 : YYDEBUG ( 45 , * YYCURSOR ) ;\n yych = * ++ YYCURSOR ;\n if ( yych <= '/' ) goto yy13 ;\n if ( yych <= '9' ) goto yy47 ;\n goto yy13 ;\n yy46 : YYDEBUG ( 46 , * YYCURSOR ) ;\n yych = * ++ YYCURSOR ;\n if ( yych <= '/' ) goto yy13 ;\n if ( yych >= '2' ) goto yy13 ;\n yy47 : YYDEBUG ( 47 , * YYCURSOR ) ;\n yych = * ++ YYCURSOR ;\n if ( yych != 'T' ) goto yy13 ;\n YYDEBUG ( 48 , * YYCURSOR ) ;\n yych = * ++ YYCURSOR ;\n if ( yych <= '/' ) goto yy13 ;\n if ( yych <= '1' ) goto yy49 ;\n if ( yych <= '2' ) goto yy50 ;\n goto yy13 ;\n yy49 : YYDEBUG ( 49 , * YYCURSOR ) ;\n yych = * ++ YYCURSOR ;\n if ( yych <= '/' ) goto yy13 ;\n if ( yych <= '9' ) goto yy51 ;\n goto yy13 ;\n yy50 : YYDEBUG ( 50 , * YYCURSOR ) ;\n yych = * ++ YYCURSOR ;\n if ( yych <= '/' ) goto yy13 ;\n if ( yych >= '5' ) goto yy13 ;\n yy51 : YYDEBUG ( 51 , * YYCURSOR ) ;\n yych = * ++ YYCURSOR ;\n if ( yych != ':' ) goto yy13 ;\n YYDEBUG ( 52 , * YYCURSOR ) ;\n yych = * ++ YYCURSOR ;\n if ( yych <= '/' ) goto yy13 ;\n if ( yych >= '6' ) goto yy13 ;\n YYDEBUG ( 53 , * YYCURSOR ) ;\n yych = * ++ YYCURSOR ;\n if ( yych <= '/' ) goto yy13 ;\n if ( yych >= ':' ) goto yy13 ;\n YYDEBUG ( 54 , * YYCURSOR ) ;\n yych = * ++ YYCURSOR ;\n if ( yych != ':' ) goto yy13 ;\n YYDEBUG ( 55 , * YYCURSOR ) ;\n yych = * ++ YYCURSOR ;\n if ( yych <= '/' ) goto yy13 ;\n if ( yych >= '6' ) goto yy13 ;\n YYDEBUG ( 56 , * YYCURSOR ) ;\n yych = * ++ YYCURSOR ;\n if ( yych <= '/' ) goto yy13 ;\n if ( yych >= ':' ) goto yy13 ;\n YYDEBUG ( 57 , * YYCURSOR ) ;\n ++ YYCURSOR ;\n YYDEBUG ( 58 , * YYCURSOR ) ;\n # line 393 \"ext/date/lib/parse_iso_intervals.re\" {\n DEBUG_OUTPUT ( \"combinedrep\" ) ;\n TIMELIB_INIT ;\n s -> period -> y = timelib_get_unsigned_nr ( ( char * * ) & ptr , 4 ) ;\n ptr ++ ;\n s -> period -> m = timelib_get_unsigned_nr ( ( char * * ) & ptr , 2 ) ;\n ptr ++ ;\n s -> period -> d = timelib_get_unsigned_nr ( ( char * * ) & ptr , 2 ) ;\n ptr ++ ;\n s -> period -> h = timelib_get_unsigned_nr ( ( char * * ) & ptr , 2 ) ;\n ptr ++ ;\n s -> period -> i = timelib_get_unsigned_nr ( ( char * * ) & ptr , 2 ) ;\n ptr ++ ;\n s -> period -> s = timelib_get_unsigned_nr ( ( char * * ) & ptr , 2 ) ;\n s -> have_period = 1 ;\n TIMELIB_DEINIT ;\n return TIMELIB_PERIOD ;\n }\n # line 792 \"ext/date/lib/parse_iso_intervals.c\" yy59 : YYDEBUG ( 59 , * YYCURSOR ) ;\n yych = * ++ YYCURSOR ;\n if ( yych <= '/' ) goto yy13 ;\n if ( yych >= ':' ) goto yy13 ;\n YYDEBUG ( 60 , * YYCURSOR ) ;\n yych = * ++ YYCURSOR ;\n if ( yych <= '/' ) goto yy13 ;\n if ( yych >= ':' ) goto yy13 ;\n YYDEBUG ( 61 , * YYCURSOR ) ;\n yych = * ++ YYCURSOR ;\n if ( yych <= '/' ) {\n if ( yych == '-' ) goto yy64 ;\n goto yy13 ;\n }\n else {\n if ( yych <= '0' ) goto yy62 ;\n if ( yych <= '1' ) goto yy63 ;\n goto yy13 ;\n }\n yy62 : YYDEBUG ( 62 , * YYCURSOR ) ;\n yych = * ++ YYCURSOR ;\n if ( yych <= '0' ) goto yy13 ;\n if ( yych <= '9' ) goto yy85 ;\n goto yy13 ;\n yy63 : YYDEBUG ( 63 , * YYCURSOR ) ;\n yych = * ++ YYCURSOR ;\n if ( yych <= '/' ) goto yy13 ;\n if ( yych <= '2' ) goto yy85 ;\n goto yy13 ;\n yy64 : YYDEBUG ( 64 , * YYCURSOR ) ;\n yych = * ++ YYCURSOR ;\n if ( yych <= '/' ) goto yy13 ;\n if ( yych <= '0' ) goto yy65 ;\n if ( yych <= '1' ) goto yy66 ;\n goto yy13 ;\n yy65 : YYDEBUG ( 65 , * YYCURSOR ) ;\n yych = * ++ YYCURSOR ;\n if ( yych <= '0' ) goto yy13 ;\n if ( yych <= '9' ) goto yy67 ;\n goto yy13 ;\n yy66 : YYDEBUG ( 66 , * YYCURSOR ) ;\n yych = * ++ YYCURSOR ;\n if ( yych <= '/' ) goto yy13 ;\n if ( yych >= '3' ) goto yy13 ;\n yy67 : YYDEBUG ( 67 , * YYCURSOR ) ;\n yych = * ++ YYCURSOR ;\n if ( yych != '-' ) goto yy13 ;\n YYDEBUG ( 68 , * YYCURSOR ) ;\n yych = * ++ YYCURSOR ;\n if ( yych <= '/' ) goto yy13 ;\n if ( yych <= '0' ) goto yy69 ;\n if ( yych <= '2' ) goto yy70 ;\n if ( yych <= '3' ) goto yy71 ;\n goto yy13 ;\n yy69 : YYDEBUG ( 69 , * YYCURSOR ) ;\n yych = * ++ YYCURSOR ;\n if ( yych <= '0' ) goto yy13 ;\n if ( yych <= '9' ) goto yy72 ;\n goto yy13 ;\n yy70 : YYDEBUG ( 70 , * YYCURSOR ) ;\n yych = * ++ YYCURSOR ;\n if ( yych <= '/' ) goto yy13 ;\n if ( yych <= '9' ) goto yy72 ;\n goto yy13 ;\n yy71 : YYDEBUG ( 71 , * YYCURSOR ) ;\n yych = * ++ YYCURSOR ;\n if ( yych <= '/' ) goto yy13 ;\n if ( yych >= '2' ) goto yy13 ;\n yy72 : YYDEBUG ( 72 , * YYCURSOR ) ;\n yych = * ++ YYCURSOR ;\n if ( yych != 'T' ) goto yy13 ;\n YYDEBUG ( 73 , * YYCURSOR ) ;\n yych = * ++ YYCURSOR ;\n if ( yych <= '/' ) goto yy13 ;\n if ( yych <= '1' ) goto yy74 ;\n if ( yych <= '2' ) goto yy75 ;\n goto yy13 ;\n yy74 : YYDEBUG ( 74 , * YYCURSOR ) ;\n yych = * ++ YYCURSOR ;\n if ( yych <= '/' ) goto yy13 ;\n if ( yych <= '9' ) goto yy76 ;\n goto yy13 ;\n yy75 : YYDEBUG ( 75 , * YYCURSOR ) ;\n yych = * ++ YYCURSOR ;\n if ( yych <= '/' ) goto yy13 ;\n if ( yych >= '5' ) goto yy13 ;\n yy76 : YYDEBUG ( 76 , * YYCURSOR ) ;\n yych = * ++ YYCURSOR ;\n if ( yych != ':' ) goto yy13 ;\n YYDEBUG ( 77 , * YYCURSOR ) ;\n yych = * ++ YYCURSOR ;\n if ( yych <= '/' ) goto yy13 ;\n if ( yych >= '6' ) goto yy13 ;\n YYDEBUG ( 78 , * YYCURSOR ) ;\n yych = * ++ YYCURSOR ;\n if ( yych <= '/' ) goto yy13 ;\n if ( yych >= ':' ) goto yy13 ;\n YYDEBUG ( 79 , * YYCURSOR ) ;\n yych = * ++ YYCURSOR ;\n if ( yych != ':' ) goto yy13 ;\n YYDEBUG ( 80 , * YYCURSOR ) ;\n yych = * ++ YYCURSOR ;\n if ( yych <= '/' ) goto yy13 ;\n if ( yych >= '6' ) goto yy13 ;\n YYDEBUG ( 81 , * YYCURSOR ) ;\n yych = * ++ YYCURSOR ;\n if ( yych <= '/' ) goto yy13 ;\n if ( yych >= ':' ) goto yy13 ;\n YYDEBUG ( 82 , * YYCURSOR ) ;\n yych = * ++ YYCURSOR ;\n if ( yych != 'Z' ) goto yy13 ;\n yy83 : YYDEBUG ( 83 , * YYCURSOR ) ;\n ++ YYCURSOR ;\n YYDEBUG ( 84 , * YYCURSOR ) ;\n # line 327 \"ext/date/lib/parse_iso_intervals.re\" {\n timelib_time * current ;\n if ( s -> have_date || s -> have_period ) {\n current = s -> end ;\n s -> have_end_date = 1 ;\n }\n else {\n current = s -> begin ;\n s -> have_begin_date = 1 ;\n }\n DEBUG_OUTPUT ( \"datetimebasic | datetimeextended\" ) ;\n TIMELIB_INIT ;\n current -> y = timelib_get_nr ( ( char * * ) & ptr , 4 ) ;\n current -> m = timelib_get_nr ( ( char * * ) & ptr , 2 ) ;\n current -> d = timelib_get_nr ( ( char * * ) & ptr , 2 ) ;\n current -> h = timelib_get_nr ( ( char * * ) & ptr , 2 ) ;\n current -> i = timelib_get_nr ( ( char * * ) & ptr , 2 ) ;\n current -> s = timelib_get_nr ( ( char * * ) & ptr , 2 ) ;\n s -> have_date = 1 ;\n TIMELIB_DEINIT ;\n return TIMELIB_ISO_DATE ;\n }\n # line 944 \"ext/date/lib/parse_iso_intervals.c\" yy85 : YYDEBUG ( 85 , * YYCURSOR ) ;\n yych = * ++ YYCURSOR ;\n if ( yych <= '/' ) goto yy13 ;\n if ( yych <= '0' ) goto yy86 ;\n if ( yych <= '2' ) goto yy87 ;\n if ( yych <= '3' ) goto yy88 ;\n goto yy13 ;\n yy86 : YYDEBUG ( 86 , * YYCURSOR ) ;\n yych = * ++ YYCURSOR ;\n if ( yych <= '0' ) goto yy13 ;\n if ( yych <= '9' ) goto yy89 ;\n goto yy13 ;\n yy87 : YYDEBUG ( 87 , * YYCURSOR ) ;\n yych = * ++ YYCURSOR ;\n if ( yych <= '/' ) goto yy13 ;\n if ( yych <= '9' ) goto yy89 ;\n goto yy13 ;\n yy88 : YYDEBUG ( 88 , * YYCURSOR ) ;\n yych = * ++ YYCURSOR ;\n if ( yych <= '/' ) goto yy13 ;\n if ( yych >= '2' ) goto yy13 ;\n yy89 : YYDEBUG ( 89 , * YYCURSOR ) ;\n yych = * ++ YYCURSOR ;\n if ( yych != 'T' ) goto yy13 ;\n YYDEBUG ( 90 , * YYCURSOR ) ;\n yych = * ++ YYCURSOR ;\n if ( yych <= '/' ) goto yy13 ;\n if ( yych <= '1' ) goto yy91 ;\n if ( yych <= '2' ) goto yy92 ;\n goto yy13 ;\n yy91 : YYDEBUG ( 91 , * YYCURSOR ) ;\n yych = * ++ YYCURSOR ;\n if ( yych <= '/' ) goto yy13 ;\n if ( yych <= '9' ) goto yy93 ;\n goto yy13 ;\n yy92 : YYDEBUG ( 92 , * YYCURSOR ) ;\n yych = * ++ YYCURSOR ;\n if ( yych <= '/' ) goto yy13 ;\n if ( yych >= '5' ) goto yy13 ;\n yy93 : YYDEBUG ( 93 , * YYCURSOR ) ;\n yych = * ++ YYCURSOR ;\n if ( yych <= '/' ) goto yy13 ;\n if ( yych >= '6' ) goto yy13 ;\n YYDEBUG ( 94 , * YYCURSOR ) ;\n yych = * ++ YYCURSOR ;\n if ( yych <= '/' ) goto yy13 ;\n if ( yych >= ':' ) goto yy13 ;\n YYDEBUG ( 95 , * YYCURSOR ) ;\n yych = * ++ YYCURSOR ;\n if ( yych <= '/' ) goto yy13 ;\n if ( yych >= '6' ) goto yy13 ;\n YYDEBUG ( 96 , * YYCURSOR ) ;\n yych = * ++ YYCURSOR ;\n if ( yych <= '/' ) goto yy13 ;\n if ( yych >= ':' ) goto yy13 ;\n YYDEBUG ( 97 , * YYCURSOR ) ;\n yych = * ++ YYCURSOR ;\n if ( yych == 'Z' ) goto yy83 ;\n goto yy13 ;\n yy98 : YYDEBUG ( 98 , * YYCURSOR ) ;\n ++ YYCURSOR ;\n if ( YYLIMIT <= YYCURSOR ) YYFILL ( 1 ) ;\n yych = * YYCURSOR ;\n YYDEBUG ( 99 , * YYCURSOR ) ;\n if ( yych <= '/' ) goto yy100 ;\n if ( yych <= '9' ) goto yy98 ;\n yy100 : YYDEBUG ( 100 , * YYCURSOR ) ;\n # line 316 \"ext/date/lib/parse_iso_intervals.re\" {\n DEBUG_OUTPUT ( \"recurrences\" ) ;\n TIMELIB_INIT ;\n ptr ++ ;\n s -> recurrences = timelib_get_unsigned_nr ( ( char * * ) & ptr , 9 ) ;\n TIMELIB_DEINIT ;\n s -> have_recurrences = 1 ;\n return TIMELIB_PERIOD ;\n }\n # line 1032 \"ext/date/lib/parse_iso_intervals.c\" }\n # line 428 \"ext/date/lib/parse_iso_intervals.re\" }", "idx": 1451}
{"hash": -7599707968689691014, "project": "debian", "size": 662, "label": 0, "functionSource": "php_stream * php_stream_url_wrap_http_ex ( php_stream_wrapper * wrapper , const char * path , const char * mode , int options , char * * opened_path , php_stream_context * context , int redirect_max , int flags STREAMS_DC TSRMLS_DC ) {\n php_stream * stream = NULL ;\n php_url * resource = NULL ;\n int use_ssl ;\n int use_proxy = 0 ;\n char * scratch = NULL ;\n char * tmp = NULL ;\n char * ua_str = NULL ;\n zval * * ua_zval = NULL , * * tmpzval = NULL , * ssl_proxy_peer_name = NULL ;\n int scratch_len = 0 ;\n int body = 0 ;\n char location [ HTTP_HEADER_BLOCK_SIZE ] ;\n zval * response_header = NULL ;\n int reqok = 0 ;\n char * http_header_line = NULL ;\n char tmp_line [ 128 ] ;\n size_t chunk_size = 0 , file_size = 0 ;\n int eol_detect = 0 ;\n char * transport_string , * errstr = NULL ;\n int transport_len , have_header = 0 , request_fulluri = 0 , ignore_errors = 0 ;\n char * protocol_version = NULL ;\n int protocol_version_len = 3 ;\n struct timeval timeout ;\n char * user_headers = NULL ;\n int header_init = ( ( flags & HTTP_WRAPPER_HEADER_INIT ) != 0 ) ;\n int redirected = ( ( flags & HTTP_WRAPPER_REDIRECTED ) != 0 ) ;\n int follow_location = 1 ;\n php_stream_filter * transfer_encoding = NULL ;\n int response_code ;\n tmp_line [ 0 ] = '\\0' ;\n if ( redirect_max < 1 ) {\n php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , \"Redirection limit reached, aborting\" ) ;\n return NULL ;\n }\n resource = php_url_parse ( path ) ;\n if ( resource == NULL ) {\n return NULL ;\n }\n if ( strncasecmp ( resource -> scheme , \"http\" , sizeof ( \"http\" ) ) && strncasecmp ( resource -> scheme , \"https\" , sizeof ( \"https\" ) ) ) {\n if ( ! context || php_stream_context_get_option ( context , wrapper -> wops -> label , \"proxy\" , & tmpzval ) == FAILURE || Z_TYPE_PP ( tmpzval ) != IS_STRING || Z_STRLEN_PP ( tmpzval ) <= 0 ) {\n php_url_free ( resource ) ;\n return php_stream_open_wrapper_ex ( path , mode , REPORT_ERRORS , NULL , context ) ;\n }\n request_fulluri = 1 ;\n use_ssl = 0 ;\n use_proxy = 1 ;\n transport_len = Z_STRLEN_PP ( tmpzval ) ;\n transport_string = estrndup ( Z_STRVAL_PP ( tmpzval ) , Z_STRLEN_PP ( tmpzval ) ) ;\n }\n else {\n if ( strpbrk ( mode , \"awx+\" ) ) {\n php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , \"HTTP wrapper does not support writeable connections\" ) ;\n php_url_free ( resource ) ;\n return NULL ;\n }\n use_ssl = resource -> scheme && ( strlen ( resource -> scheme ) > 4 ) && resource -> scheme [ 4 ] == 's' ;\n if ( use_ssl && resource -> port == 0 ) resource -> port = 443 ;\n else if ( resource -> port == 0 ) resource -> port = 80 ;\n if ( context && php_stream_context_get_option ( context , wrapper -> wops -> label , \"proxy\" , & tmpzval ) == SUCCESS && Z_TYPE_PP ( tmpzval ) == IS_STRING && Z_STRLEN_PP ( tmpzval ) > 0 ) {\n use_proxy = 1 ;\n transport_len = Z_STRLEN_PP ( tmpzval ) ;\n transport_string = estrndup ( Z_STRVAL_PP ( tmpzval ) , Z_STRLEN_PP ( tmpzval ) ) ;\n }\n else {\n transport_len = spprintf ( & transport_string , 0 , \"%s://%s:%d\" , use_ssl ? \"ssl\" : \"tcp\" , resource -> host , resource -> port ) ;\n }\n }\n if ( context && php_stream_context_get_option ( context , wrapper -> wops -> label , \"timeout\" , & tmpzval ) == SUCCESS ) {\n SEPARATE_ZVAL ( tmpzval ) ;\n convert_to_double_ex ( tmpzval ) ;\n timeout . tv_sec = ( time_t ) Z_DVAL_PP ( tmpzval ) ;\n timeout . tv_usec = ( size_t ) ( ( Z_DVAL_PP ( tmpzval ) - timeout . tv_sec ) * 1000000 ) ;\n }\n else {\n timeout . tv_sec = FG ( default_socket_timeout ) ;\n timeout . tv_usec = 0 ;\n }\n stream = php_stream_xport_create ( transport_string , transport_len , options , STREAM_XPORT_CLIENT | STREAM_XPORT_CONNECT , NULL , & timeout , context , & errstr , NULL ) ;\n if ( stream ) {\n php_stream_set_option ( stream , PHP_STREAM_OPTION_READ_TIMEOUT , 0 , & timeout ) ;\n }\n if ( errstr ) {\n php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , \"%s\" , errstr ) ;\n efree ( errstr ) ;\n errstr = NULL ;\n }\n efree ( transport_string ) ;\n if ( stream && use_proxy && use_ssl ) {\n smart_str header = {\n 0 }\n ;\n if ( ! context || php_stream_context_get_option ( context , \"ssl\" , \"peer_name\" , & tmpzval ) == FAILURE ) {\n MAKE_STD_ZVAL ( ssl_proxy_peer_name ) ;\n ZVAL_STRING ( ssl_proxy_peer_name , resource -> host , 1 ) ;\n php_stream_context_set_option ( stream -> context , \"ssl\" , \"peer_name\" , ssl_proxy_peer_name ) ;\n }\n smart_str_appendl ( & header , \"CONNECT \" , sizeof ( \"CONNECT \" ) - 1 ) ;\n smart_str_appends ( & header , resource -> host ) ;\n smart_str_appendc ( & header , ':' ) ;\n smart_str_append_unsigned ( & header , resource -> port ) ;\n smart_str_appendl ( & header , \" HTTP/1.0\\r\\n\" , sizeof ( \" HTTP/1.0\\r\\n\" ) - 1 ) ;\n if ( context && php_stream_context_get_option ( context , \"http\" , \"header\" , & tmpzval ) == SUCCESS ) {\n char * s , * p ;\n if ( Z_TYPE_PP ( tmpzval ) == IS_ARRAY ) {\n HashPosition pos ;\n zval * * tmpheader = NULL ;\n for ( zend_hash_internal_pointer_reset_ex ( Z_ARRVAL_PP ( tmpzval ) , & pos ) ;\n SUCCESS == zend_hash_get_current_data_ex ( Z_ARRVAL_PP ( tmpzval ) , ( void * ) & tmpheader , & pos ) ;\n zend_hash_move_forward_ex ( Z_ARRVAL_PP ( tmpzval ) , & pos ) ) {\n if ( Z_TYPE_PP ( tmpheader ) == IS_STRING ) {\n s = Z_STRVAL_PP ( tmpheader ) ;\n do {\n while ( * s == ' ' || * s == '\\t' ) s ++ ;\n p = s ;\n while ( * p != 0 && * p != ':' && * p != '\\r' && * p != '\\n' ) p ++ ;\n if ( * p == ':' ) {\n p ++ ;\n if ( p - s == sizeof ( \"Proxy-Authorization:\" ) - 1 && zend_binary_strcasecmp ( s , sizeof ( \"Proxy-Authorization:\" ) - 1 , \"Proxy-Authorization:\" , sizeof ( \"Proxy-Authorization:\" ) - 1 ) == 0 ) {\n while ( * p != 0 && * p != '\\r' && * p != '\\n' ) p ++ ;\n smart_str_appendl ( & header , s , p - s ) ;\n smart_str_appendl ( & header , \"\\r\\n\" , sizeof ( \"\\r\\n\" ) - 1 ) ;\n goto finish ;\n }\n else {\n while ( * p != 0 && * p != '\\r' && * p != '\\n' ) p ++ ;\n }\n }\n s = p ;\n while ( * s == '\\r' || * s == '\\n' ) s ++ ;\n }\n while ( * s != 0 ) ;\n }\n }\n }\n else if ( Z_TYPE_PP ( tmpzval ) == IS_STRING && Z_STRLEN_PP ( tmpzval ) ) {\n s = Z_STRVAL_PP ( tmpzval ) ;\n do {\n while ( * s == ' ' || * s == '\\t' ) s ++ ;\n p = s ;\n while ( * p != 0 && * p != ':' && * p != '\\r' && * p != '\\n' ) p ++ ;\n if ( * p == ':' ) {\n p ++ ;\n if ( p - s == sizeof ( \"Proxy-Authorization:\" ) - 1 && zend_binary_strcasecmp ( s , sizeof ( \"Proxy-Authorization:\" ) - 1 , \"Proxy-Authorization:\" , sizeof ( \"Proxy-Authorization:\" ) - 1 ) == 0 ) {\n while ( * p != 0 && * p != '\\r' && * p != '\\n' ) p ++ ;\n smart_str_appendl ( & header , s , p - s ) ;\n smart_str_appendl ( & header , \"\\r\\n\" , sizeof ( \"\\r\\n\" ) - 1 ) ;\n goto finish ;\n }\n else {\n while ( * p != 0 && * p != '\\r' && * p != '\\n' ) p ++ ;\n }\n }\n s = p ;\n while ( * s == '\\r' || * s == '\\n' ) s ++ ;\n }\n while ( * s != 0 ) ;\n }\n }\n finish : smart_str_appendl ( & header , \"\\r\\n\" , sizeof ( \"\\r\\n\" ) - 1 ) ;\n if ( php_stream_write ( stream , header . c , header . len ) != header . len ) {\n php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , \"Cannot connect to HTTPS server through proxy\" ) ;\n php_stream_close ( stream ) ;\n stream = NULL ;\n }\n smart_str_free ( & header ) ;\n if ( stream ) {\n char header_line [ HTTP_HEADER_BLOCK_SIZE ] ;\n while ( php_stream_gets ( stream , header_line , HTTP_HEADER_BLOCK_SIZE - 1 ) != NULL ) {\n if ( header_line [ 0 ] == '\\n' || header_line [ 0 ] == '\\r' || header_line [ 0 ] == '\\0' ) {\n break ;\n }\n }\n }\n if ( stream ) {\n if ( php_stream_xport_crypto_setup ( stream , STREAM_CRYPTO_METHOD_SSLv23_CLIENT , NULL TSRMLS_CC ) < 0 || php_stream_xport_crypto_enable ( stream , 1 TSRMLS_CC ) < 0 ) {\n php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , \"Cannot connect to HTTPS server through proxy\" ) ;\n php_stream_close ( stream ) ;\n stream = NULL ;\n }\n }\n }\n if ( stream == NULL ) goto out ;\n if ( options & STREAM_WILL_CAST ) chunk_size = php_stream_set_chunk_size ( stream , 1 ) ;\n eol_detect = stream -> flags & ( PHP_STREAM_FLAG_DETECT_EOL | PHP_STREAM_FLAG_EOL_MAC ) ;\n stream -> flags &= ~ ( PHP_STREAM_FLAG_DETECT_EOL | PHP_STREAM_FLAG_EOL_MAC ) ;\n php_stream_context_set ( stream , context ) ;\n php_stream_notify_info ( context , PHP_STREAM_NOTIFY_CONNECT , NULL , 0 ) ;\n if ( header_init && context && php_stream_context_get_option ( context , \"http\" , \"max_redirects\" , & tmpzval ) == SUCCESS ) {\n SEPARATE_ZVAL ( tmpzval ) ;\n convert_to_long_ex ( tmpzval ) ;\n redirect_max = Z_LVAL_PP ( tmpzval ) ;\n }\n if ( context && php_stream_context_get_option ( context , \"http\" , \"method\" , & tmpzval ) == SUCCESS ) {\n if ( Z_TYPE_PP ( tmpzval ) == IS_STRING && Z_STRLEN_PP ( tmpzval ) > 0 ) {\n if ( ! redirected || ( Z_STRLEN_PP ( tmpzval ) == 3 && memcmp ( \"GET\" , Z_STRVAL_PP ( tmpzval ) , 3 ) == 0 ) || ( Z_STRLEN_PP ( tmpzval ) == 4 && memcmp ( \"HEAD\" , Z_STRVAL_PP ( tmpzval ) , 4 ) == 0 ) ) {\n scratch_len = strlen ( path ) + 29 + Z_STRLEN_PP ( tmpzval ) ;\n scratch = emalloc ( scratch_len ) ;\n strlcpy ( scratch , Z_STRVAL_PP ( tmpzval ) , Z_STRLEN_PP ( tmpzval ) + 1 ) ;\n strncat ( scratch , \" \" , 1 ) ;\n }\n }\n }\n if ( context && php_stream_context_get_option ( context , \"http\" , \"protocol_version\" , & tmpzval ) == SUCCESS ) {\n SEPARATE_ZVAL ( tmpzval ) ;\n convert_to_double_ex ( tmpzval ) ;\n protocol_version_len = spprintf ( & protocol_version , 0 , \"%.1F\" , Z_DVAL_PP ( tmpzval ) ) ;\n }\n if ( ! scratch ) {\n scratch_len = strlen ( path ) + 29 + protocol_version_len ;\n scratch = emalloc ( scratch_len ) ;\n strncpy ( scratch , \"GET \" , scratch_len ) ;\n }\n if ( ! request_fulluri && context && php_stream_context_get_option ( context , \"http\" , \"request_fulluri\" , & tmpzval ) == SUCCESS ) {\n zval ztmp = * * tmpzval ;\n zval_copy_ctor ( & ztmp ) ;\n convert_to_boolean ( & ztmp ) ;\n request_fulluri = Z_BVAL ( ztmp ) ? 1 : 0 ;\n zval_dtor ( & ztmp ) ;\n }\n if ( request_fulluri ) {\n strcat ( scratch , path ) ;\n }\n else {\n if ( resource -> path && * resource -> path ) {\n strlcat ( scratch , resource -> path , scratch_len ) ;\n }\n else {\n strlcat ( scratch , \"/\" , scratch_len ) ;\n }\n if ( resource -> query ) {\n strlcat ( scratch , \"?\" , scratch_len ) ;\n strlcat ( scratch , resource -> query , scratch_len ) ;\n }\n }\n if ( protocol_version ) {\n strlcat ( scratch , \" HTTP/\" , scratch_len ) ;\n strlcat ( scratch , protocol_version , scratch_len ) ;\n strlcat ( scratch , \"\\r\\n\" , scratch_len ) ;\n }\n else {\n strlcat ( scratch , \" HTTP/1.0\\r\\n\" , scratch_len ) ;\n }\n php_stream_write ( stream , scratch , strlen ( scratch ) ) ;\n if ( context && php_stream_context_get_option ( context , \"http\" , \"header\" , & tmpzval ) == SUCCESS ) {\n tmp = NULL ;\n if ( Z_TYPE_PP ( tmpzval ) == IS_ARRAY ) {\n HashPosition pos ;\n zval * * tmpheader = NULL ;\n smart_str tmpstr = {\n 0 }\n ;\n for ( zend_hash_internal_pointer_reset_ex ( Z_ARRVAL_PP ( tmpzval ) , & pos ) ;\n SUCCESS == zend_hash_get_current_data_ex ( Z_ARRVAL_PP ( tmpzval ) , ( void * ) & tmpheader , & pos ) ;\n zend_hash_move_forward_ex ( Z_ARRVAL_PP ( tmpzval ) , & pos ) ) {\n if ( Z_TYPE_PP ( tmpheader ) == IS_STRING ) {\n smart_str_appendl ( & tmpstr , Z_STRVAL_PP ( tmpheader ) , Z_STRLEN_PP ( tmpheader ) ) ;\n smart_str_appendl ( & tmpstr , \"\\r\\n\" , sizeof ( \"\\r\\n\" ) - 1 ) ;\n }\n }\n smart_str_0 ( & tmpstr ) ;\n if ( tmpstr . c ) {\n tmp = php_trim ( tmpstr . c , strlen ( tmpstr . c ) , NULL , 0 , NULL , 3 TSRMLS_CC ) ;\n smart_str_free ( & tmpstr ) ;\n }\n }\n if ( Z_TYPE_PP ( tmpzval ) == IS_STRING && Z_STRLEN_PP ( tmpzval ) ) {\n tmp = php_trim ( Z_STRVAL_PP ( tmpzval ) , Z_STRLEN_PP ( tmpzval ) , NULL , 0 , NULL , 3 TSRMLS_CC ) ;\n }\n if ( tmp && strlen ( tmp ) > 0 ) {\n char * s ;\n user_headers = estrdup ( tmp ) ;\n php_strtolower ( tmp , strlen ( tmp ) ) ;\n if ( ! header_init ) {\n strip_header ( user_headers , tmp , \"content-length:\" ) ;\n strip_header ( user_headers , tmp , \"content-type:\" ) ;\n }\n if ( ( s = strstr ( tmp , \"user-agent:\" ) ) && ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || * ( s - 1 ) == '\\t' || * ( s - 1 ) == ' ' ) ) {\n have_header |= HTTP_HEADER_USER_AGENT ;\n }\n if ( ( s = strstr ( tmp , \"host:\" ) ) && ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || * ( s - 1 ) == '\\t' || * ( s - 1 ) == ' ' ) ) {\n have_header |= HTTP_HEADER_HOST ;\n }\n if ( ( s = strstr ( tmp , \"from:\" ) ) && ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || * ( s - 1 ) == '\\t' || * ( s - 1 ) == ' ' ) ) {\n have_header |= HTTP_HEADER_FROM ;\n }\n if ( ( s = strstr ( tmp , \"authorization:\" ) ) && ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || * ( s - 1 ) == '\\t' || * ( s - 1 ) == ' ' ) ) {\n have_header |= HTTP_HEADER_AUTH ;\n }\n if ( ( s = strstr ( tmp , \"content-length:\" ) ) && ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || * ( s - 1 ) == '\\t' || * ( s - 1 ) == ' ' ) ) {\n have_header |= HTTP_HEADER_CONTENT_LENGTH ;\n }\n if ( ( s = strstr ( tmp , \"content-type:\" ) ) && ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || * ( s - 1 ) == '\\t' || * ( s - 1 ) == ' ' ) ) {\n have_header |= HTTP_HEADER_TYPE ;\n }\n if ( ( s = strstr ( tmp , \"connection:\" ) ) && ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || * ( s - 1 ) == '\\t' || * ( s - 1 ) == ' ' ) ) {\n have_header |= HTTP_HEADER_CONNECTION ;\n }\n if ( use_proxy && use_ssl && ( s = strstr ( tmp , \"proxy-authorization:\" ) ) && ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || * ( s - 1 ) == '\\t' || * ( s - 1 ) == ' ' ) ) {\n char * p = s + sizeof ( \"proxy-authorization:\" ) - 1 ;\n while ( s > tmp && ( * ( s - 1 ) == ' ' || * ( s - 1 ) == '\\t' ) ) s -- ;\n while ( * p != 0 && * p != '\\r' && * p != '\\n' ) p ++ ;\n while ( * p == '\\r' || * p == '\\n' ) p ++ ;\n if ( * p == 0 ) {\n if ( s == tmp ) {\n efree ( user_headers ) ;\n user_headers = NULL ;\n }\n else {\n while ( s > tmp && ( * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' ) ) s -- ;\n user_headers [ s - tmp ] = 0 ;\n }\n }\n else {\n memmove ( user_headers + ( s - tmp ) , user_headers + ( p - tmp ) , strlen ( p ) + 1 ) ;\n }\n }\n }\n if ( tmp ) {\n efree ( tmp ) ;\n }\n }\n if ( ( ( have_header & HTTP_HEADER_AUTH ) == 0 ) && resource -> user ) {\n php_url_decode ( resource -> user , strlen ( resource -> user ) ) ;\n strcpy ( scratch , resource -> user ) ;\n strcat ( scratch , \":\" ) ;\n if ( resource -> pass ) {\n php_url_decode ( resource -> pass , strlen ( resource -> pass ) ) ;\n strcat ( scratch , resource -> pass ) ;\n }\n tmp = ( char * ) php_base64_encode ( ( unsigned char * ) scratch , strlen ( scratch ) , NULL ) ;\n if ( snprintf ( scratch , scratch_len , \"Authorization: Basic %s\\r\\n\" , tmp ) > 0 ) {\n php_stream_write ( stream , scratch , strlen ( scratch ) ) ;\n php_stream_notify_info ( context , PHP_STREAM_NOTIFY_AUTH_REQUIRED , NULL , 0 ) ;\n }\n efree ( tmp ) ;\n tmp = NULL ;\n }\n if ( ( ( have_header & HTTP_HEADER_FROM ) == 0 ) && FG ( from_address ) ) {\n if ( snprintf ( scratch , scratch_len , \"From: %s\\r\\n\" , FG ( from_address ) ) > 0 ) php_stream_write ( stream , scratch , strlen ( scratch ) ) ;\n }\n if ( ( have_header & HTTP_HEADER_HOST ) == 0 ) {\n if ( ( use_ssl && resource -> port != 443 && resource -> port != 0 ) || ( ! use_ssl && resource -> port != 80 && resource -> port != 0 ) ) {\n if ( snprintf ( scratch , scratch_len , \"Host: %s:%i\\r\\n\" , resource -> host , resource -> port ) > 0 ) php_stream_write ( stream , scratch , strlen ( scratch ) ) ;\n }\n else {\n if ( snprintf ( scratch , scratch_len , \"Host: %s\\r\\n\" , resource -> host ) > 0 ) {\n php_stream_write ( stream , scratch , strlen ( scratch ) ) ;\n }\n }\n }\n if ( ( have_header & HTTP_HEADER_CONNECTION ) == 0 ) {\n php_stream_write_string ( stream , \"Connection: close\\r\\n\" ) ;\n }\n if ( context && php_stream_context_get_option ( context , \"http\" , \"user_agent\" , & ua_zval ) == SUCCESS && Z_TYPE_PP ( ua_zval ) == IS_STRING ) {\n ua_str = Z_STRVAL_PP ( ua_zval ) ;\n }\n else if ( FG ( user_agent ) ) {\n ua_str = FG ( user_agent ) ;\n }\n if ( ( ( have_header & HTTP_HEADER_USER_AGENT ) == 0 ) && ua_str ) {\n # define _UA_HEADER \"User-Agent: %s\\r\\n\" char * ua ;\n size_t ua_len ;\n ua_len = sizeof ( _UA_HEADER ) + strlen ( ua_str ) ;\n if ( ua_len > sizeof ( _UA_HEADER ) ) {\n ua = emalloc ( ua_len + 1 ) ;\n if ( ( ua_len = slprintf ( ua , ua_len , _UA_HEADER , ua_str ) ) > 0 ) {\n ua [ ua_len ] = 0 ;\n php_stream_write ( stream , ua , ua_len ) ;\n }\n else {\n php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Cannot construct User-agent header\" ) ;\n }\n if ( ua ) {\n efree ( ua ) ;\n }\n }\n }\n if ( user_headers ) {\n if ( header_init && context && ! ( have_header & HTTP_HEADER_CONTENT_LENGTH ) && php_stream_context_get_option ( context , \"http\" , \"content\" , & tmpzval ) == SUCCESS && Z_TYPE_PP ( tmpzval ) == IS_STRING && Z_STRLEN_PP ( tmpzval ) > 0 ) {\n scratch_len = slprintf ( scratch , scratch_len , \"Content-Length: %d\\r\\n\" , Z_STRLEN_PP ( tmpzval ) ) ;\n php_stream_write ( stream , scratch , scratch_len ) ;\n have_header |= HTTP_HEADER_CONTENT_LENGTH ;\n }\n php_stream_write ( stream , user_headers , strlen ( user_headers ) ) ;\n php_stream_write ( stream , \"\\r\\n\" , sizeof ( \"\\r\\n\" ) - 1 ) ;\n efree ( user_headers ) ;\n }\n if ( header_init && context && php_stream_context_get_option ( context , \"http\" , \"content\" , & tmpzval ) == SUCCESS && Z_TYPE_PP ( tmpzval ) == IS_STRING && Z_STRLEN_PP ( tmpzval ) > 0 ) {\n if ( ! ( have_header & HTTP_HEADER_CONTENT_LENGTH ) ) {\n scratch_len = slprintf ( scratch , scratch_len , \"Content-Length: %d\\r\\n\" , Z_STRLEN_PP ( tmpzval ) ) ;\n php_stream_write ( stream , scratch , scratch_len ) ;\n }\n if ( ! ( have_header & HTTP_HEADER_TYPE ) ) {\n php_stream_write ( stream , \"Content-Type: application/x-www-form-urlencoded\\r\\n\" , sizeof ( \"Content-Type: application/x-www-form-urlencoded\\r\\n\" ) - 1 ) ;\n php_error_docref ( NULL TSRMLS_CC , E_NOTICE , \"Content-type not specified assuming application/x-www-form-urlencoded\" ) ;\n }\n php_stream_write ( stream , \"\\r\\n\" , sizeof ( \"\\r\\n\" ) - 1 ) ;\n php_stream_write ( stream , Z_STRVAL_PP ( tmpzval ) , Z_STRLEN_PP ( tmpzval ) ) ;\n }\n else {\n php_stream_write ( stream , \"\\r\\n\" , sizeof ( \"\\r\\n\" ) - 1 ) ;\n }\n location [ 0 ] = '\\0' ;\n if ( ! EG ( active_symbol_table ) ) {\n zend_rebuild_symbol_table ( TSRMLS_C ) ;\n }\n if ( header_init ) {\n zval * ztmp ;\n MAKE_STD_ZVAL ( ztmp ) ;\n array_init ( ztmp ) ;\n ZEND_SET_SYMBOL ( EG ( active_symbol_table ) , \"http_response_header\" , ztmp ) ;\n }\n {\n zval * * rh ;\n if ( zend_hash_find ( EG ( active_symbol_table ) , \"http_response_header\" , sizeof ( \"http_response_header\" ) , ( void * * ) & rh ) != SUCCESS || Z_TYPE_PP ( rh ) != IS_ARRAY ) {\n php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , \"HTTP request failed, http_response_header overwritten\" ) ;\n goto out ;\n }\n response_header = * rh ;\n Z_ADDREF_P ( response_header ) ;\n }\n if ( ! php_stream_eof ( stream ) ) {\n size_t tmp_line_len ;\n if ( php_stream_get_line ( stream , tmp_line , sizeof ( tmp_line ) - 1 , & tmp_line_len ) != NULL ) {\n zval * http_response ;\n if ( tmp_line_len > 9 ) {\n response_code = atoi ( tmp_line + 9 ) ;\n }\n else {\n response_code = 0 ;\n }\n if ( context && SUCCESS == php_stream_context_get_option ( context , \"http\" , \"ignore_errors\" , & tmpzval ) ) {\n ignore_errors = zend_is_true ( * tmpzval ) ;\n }\n if ( ( options & STREAM_ONLY_GET_HEADERS ) || ignore_errors ) {\n reqok = 1 ;\n }\n if ( response_code >= 100 && response_code < 200 ) {\n while ( ! php_stream_eof ( stream ) && php_stream_get_line ( stream , tmp_line , sizeof ( tmp_line ) - 1 , & tmp_line_len ) != NULL && ( tmp_line_len < sizeof ( \"HTTP/1\" ) - 1 || strncasecmp ( tmp_line , \"HTTP/1\" , sizeof ( \"HTTP/1\" ) - 1 ) ) ) ;\n if ( tmp_line_len > 9 ) {\n response_code = atoi ( tmp_line + 9 ) ;\n }\n else {\n response_code = 0 ;\n }\n }\n if ( response_code >= 200 && response_code < 400 ) {\n reqok = 1 ;\n }\n else {\n switch ( response_code ) {\n case 403 : php_stream_notify_error ( context , PHP_STREAM_NOTIFY_AUTH_RESULT , tmp_line , response_code ) ;\n break ;\n default : if ( ! tmp_line_len ) {\n tmp_line [ 0 ] = '\\0' ;\n }\n php_stream_notify_error ( context , PHP_STREAM_NOTIFY_FAILURE , tmp_line , response_code ) ;\n }\n }\n if ( tmp_line_len >= 1 && tmp_line [ tmp_line_len - 1 ] == '\\n' ) {\n -- tmp_line_len ;\n if ( tmp_line_len >= 1 && tmp_line [ tmp_line_len - 1 ] == '\\r' ) {\n -- tmp_line_len ;\n }\n }\n MAKE_STD_ZVAL ( http_response ) ;\n ZVAL_STRINGL ( http_response , tmp_line , tmp_line_len , 1 ) ;\n zend_hash_next_index_insert ( Z_ARRVAL_P ( response_header ) , & http_response , sizeof ( zval * ) , NULL ) ;\n }\n }\n else {\n php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , \"HTTP request failed, unexpected end of socket!\" ) ;\n goto out ;\n }\n http_header_line = emalloc ( HTTP_HEADER_BLOCK_SIZE ) ;\n while ( ! body && ! php_stream_eof ( stream ) ) {\n size_t http_header_line_length ;\n if ( php_stream_get_line ( stream , http_header_line , HTTP_HEADER_BLOCK_SIZE , & http_header_line_length ) && * http_header_line != '\\n' && * http_header_line != '\\r' ) {\n char * e = http_header_line + http_header_line_length - 1 ;\n if ( * e != '\\n' ) {\n do {\n if ( php_stream_get_line ( stream , http_header_line , HTTP_HEADER_BLOCK_SIZE , & http_header_line_length ) == NULL ) {\n php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , \"Failed to read HTTP headers\" ) ;\n goto out ;\n }\n e = http_header_line + http_header_line_length - 1 ;\n }\n while ( * e != '\\n' ) ;\n continue ;\n }\n while ( * e == '\\n' || * e == '\\r' ) {\n e -- ;\n }\n http_header_line_length = e - http_header_line + 1 ;\n http_header_line [ http_header_line_length ] = '\\0' ;\n if ( ! strncasecmp ( http_header_line , \"Location: \" , 10 ) ) {\n if ( context && php_stream_context_get_option ( context , \"http\" , \"follow_location\" , & tmpzval ) == SUCCESS ) {\n SEPARATE_ZVAL ( tmpzval ) ;\n convert_to_long_ex ( tmpzval ) ;\n follow_location = Z_LVAL_PP ( tmpzval ) ;\n }\n else if ( ! ( response_code >= 300 && response_code < 304 || 307 == response_code || 308 == response_code ) ) {\n follow_location = 0 ;\n }\n strlcpy ( location , http_header_line + 10 , sizeof ( location ) ) ;\n }\n else if ( ! strncasecmp ( http_header_line , \"Content-Type: \" , 14 ) ) {\n php_stream_notify_info ( context , PHP_STREAM_NOTIFY_MIME_TYPE_IS , http_header_line + 14 , 0 ) ;\n }\n else if ( ! strncasecmp ( http_header_line , \"Content-Length: \" , 16 ) ) {\n file_size = atoi ( http_header_line + 16 ) ;\n php_stream_notify_file_size ( context , file_size , http_header_line , 0 ) ;\n }\n else if ( ! strncasecmp ( http_header_line , \"Transfer-Encoding: chunked\" , sizeof ( \"Transfer-Encoding: chunked\" ) ) ) {\n if ( ! ( options & STREAM_ONLY_GET_HEADERS ) ) {\n long decode = 1 ;\n if ( context && php_stream_context_get_option ( context , \"http\" , \"auto_decode\" , & tmpzval ) == SUCCESS ) {\n SEPARATE_ZVAL ( tmpzval ) ;\n convert_to_boolean ( * tmpzval ) ;\n decode = Z_LVAL_PP ( tmpzval ) ;\n }\n if ( decode ) {\n transfer_encoding = php_stream_filter_create ( \"dechunk\" , NULL , php_stream_is_persistent ( stream ) TSRMLS_CC ) ;\n if ( transfer_encoding ) {\n continue ;\n }\n }\n }\n }\n if ( http_header_line [ 0 ] == '\\0' ) {\n body = 1 ;\n }\n else {\n zval * http_header ;\n MAKE_STD_ZVAL ( http_header ) ;\n ZVAL_STRINGL ( http_header , http_header_line , http_header_line_length , 1 ) ;\n zend_hash_next_index_insert ( Z_ARRVAL_P ( response_header ) , & http_header , sizeof ( zval * ) , NULL ) ;\n }\n }\n else {\n break ;\n }\n }\n if ( ! reqok || ( location [ 0 ] != '\\0' && follow_location ) ) {\n if ( ! follow_location || ( ( ( options & STREAM_ONLY_GET_HEADERS ) || ignore_errors ) && redirect_max <= 1 ) ) {\n goto out ;\n }\n if ( location [ 0 ] != '\\0' ) php_stream_notify_info ( context , PHP_STREAM_NOTIFY_REDIRECTED , location , 0 ) ;\n php_stream_close ( stream ) ;\n stream = NULL ;\n if ( location [ 0 ] != '\\0' ) {\n char new_path [ HTTP_HEADER_BLOCK_SIZE ] ;\n char loc_path [ HTTP_HEADER_BLOCK_SIZE ] ;\n * new_path = '\\0' ;\n if ( strlen ( location ) < 8 || ( strncasecmp ( location , \"http://\" , sizeof ( \"http://\" ) - 1 ) && strncasecmp ( location , \"https://\" , sizeof ( \"https://\" ) - 1 ) && strncasecmp ( location , \"ftp://\" , sizeof ( \"ftp://\" ) - 1 ) && strncasecmp ( location , \"ftps://\" , sizeof ( \"ftps://\" ) - 1 ) ) ) {\n if ( * location != '/' ) {\n if ( * ( location + 1 ) != '\\0' && resource -> path ) {\n char * s = strrchr ( resource -> path , '/' ) ;\n if ( ! s ) {\n s = resource -> path ;\n if ( ! s [ 0 ] ) {\n efree ( s ) ;\n s = resource -> path = estrdup ( \"/\" ) ;\n }\n else {\n * s = '/' ;\n }\n }\n s [ 1 ] = '\\0' ;\n if ( resource -> path && * ( resource -> path ) == '/' && * ( resource -> path + 1 ) == '\\0' ) {\n snprintf ( loc_path , sizeof ( loc_path ) - 1 , \"%s%s\" , resource -> path , location ) ;\n }\n else {\n snprintf ( loc_path , sizeof ( loc_path ) - 1 , \"%s/%s\" , resource -> path , location ) ;\n }\n }\n else {\n snprintf ( loc_path , sizeof ( loc_path ) - 1 , \"/%s\" , location ) ;\n }\n }\n else {\n strlcpy ( loc_path , location , sizeof ( loc_path ) ) ;\n }\n if ( ( use_ssl && resource -> port != 443 ) || ( ! use_ssl && resource -> port != 80 ) ) {\n snprintf ( new_path , sizeof ( new_path ) - 1 , \"%s://%s:%d%s\" , resource -> scheme , resource -> host , resource -> port , loc_path ) ;\n }\n else {\n snprintf ( new_path , sizeof ( new_path ) - 1 , \"%s://%s%s\" , resource -> scheme , resource -> host , loc_path ) ;\n }\n }\n else {\n strlcpy ( new_path , location , sizeof ( new_path ) ) ;\n }\n php_url_free ( resource ) ;\n if ( ( resource = php_url_parse ( new_path ) ) == NULL ) {\n php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , \"Invalid redirect URL! %s\" , new_path ) ;\n goto out ;\n }\n # define CHECK_FOR_CNTRL_CHARS ( val ) {\n if ( val ) {\n unsigned char * s , * e ;\n int l ;\n l = php_url_decode ( val , strlen ( val ) ) ;\n s = ( unsigned char * ) val ;\n e = s + l ;\n while ( s < e ) {\n if ( iscntrl ( * s ) ) {\n php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , \"Invalid redirect URL! %s\" , new_path ) ;\n goto out ;\n }\n s ++ ;\n }\n }\n \\ }\n if ( strncasecmp ( new_path , \"http://\" , sizeof ( \"http://\" ) - 1 ) || strncasecmp ( new_path , \"https://\" , sizeof ( \"https://\" ) - 1 ) ) {\n CHECK_FOR_CNTRL_CHARS ( resource -> user ) CHECK_FOR_CNTRL_CHARS ( resource -> pass ) CHECK_FOR_CNTRL_CHARS ( resource -> path ) }\n stream = php_stream_url_wrap_http_ex ( wrapper , new_path , mode , options , opened_path , context , -- redirect_max , HTTP_WRAPPER_REDIRECTED STREAMS_CC TSRMLS_CC ) ;\n }\n else {\n php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , \"HTTP request failed! %s\" , tmp_line ) ;\n }\n }\n out : if ( protocol_version ) {\n efree ( protocol_version ) ;\n }\n if ( http_header_line ) {\n efree ( http_header_line ) ;\n }\n if ( scratch ) {\n efree ( scratch ) ;\n }\n if ( resource ) {\n php_url_free ( resource ) ;\n }\n if ( stream ) {\n if ( header_init ) {\n stream -> wrapperdata = response_header ;\n }\n else {\n if ( response_header ) {\n Z_DELREF_P ( response_header ) ;\n }\n }\n php_stream_notify_progress_init ( context , 0 , file_size ) ;\n if ( options & STREAM_WILL_CAST ) php_stream_set_chunk_size ( stream , chunk_size ) ;\n stream -> flags |= eol_detect ;\n stream -> position = 0 ;\n strlcpy ( stream -> mode , mode , sizeof ( stream -> mode ) ) ;\n if ( transfer_encoding ) {\n php_stream_filter_append ( & stream -> readfilters , transfer_encoding ) ;\n }\n }\n else {\n if ( response_header ) {\n Z_DELREF_P ( response_header ) ;\n }\n if ( transfer_encoding ) {\n php_stream_filter_free ( transfer_encoding TSRMLS_CC ) ;\n }\n }\n return stream ;\n }", "idx": 1452}
{"hash": 5347874611477979643, "project": "chrome", "size": 153, "label": 0, "functionSource": "static void test_evbuffer_readln ( void ) {\n struct evbuffer * evb = evbuffer_new ( ) ;\n struct evbuffer * evb_tmp = evbuffer_new ( ) ;\n const char * s ;\n char * cp = NULL ;\n size_t sz ;\n # define tt_line_eq ( content ) if ( ! cp || sz != strlen ( content ) || strcmp ( cp , content ) ) {\n fprintf ( stdout , \"FAILED\\n\" ) ;\n exit ( 1 ) ;\n }\n # define tt_assert ( expression ) if ( ! ( expression ) ) {\n fprintf ( stdout , \"FAILED\\n\" ) ;\n exit ( 1 ) ;\n }\n fprintf ( stdout , \"Testing evbuffer_readln EOL_ANY: \" ) ;\n s = \"complex silly newline\\r\\n\\n\\r\\n\\n\\rmore\\0\\n\" ;\n evbuffer_add ( evb , s , strlen ( s ) + 2 ) ;\n cp = evbuffer_readln ( evb , & sz , EVBUFFER_EOL_ANY ) ;\n tt_line_eq ( \"complex silly newline\" ) ;\n free ( cp ) ;\n cp = evbuffer_readln ( evb , & sz , EVBUFFER_EOL_ANY ) ;\n if ( ! cp || sz != 5 || memcmp ( cp , \"more\\0\\0\" , 6 ) ) {\n fprintf ( stdout , \"FAILED\\n\" ) ;\n exit ( 1 ) ;\n }\n if ( evb -> totallen == 0 ) {\n fprintf ( stdout , \"FAILED\\n\" ) ;\n exit ( 1 ) ;\n }\n s = \"\\nno newline\" ;\n evbuffer_add ( evb , s , strlen ( s ) ) ;\n free ( cp ) ;\n cp = evbuffer_readln ( evb , & sz , EVBUFFER_EOL_ANY ) ;\n tt_line_eq ( \"\" ) ;\n free ( cp ) ;\n cp = evbuffer_readln ( evb , & sz , EVBUFFER_EOL_ANY ) ;\n tt_assert ( ! cp ) ;\n evbuffer_drain ( evb , EVBUFFER_LENGTH ( evb ) ) ;\n tt_assert ( EVBUFFER_LENGTH ( evb ) == 0 ) ;\n fprintf ( stdout , \"OK\\n\" ) ;\n fprintf ( stdout , \"Testing evbuffer_readln EOL_CRLF: \" ) ;\n s = \"Line with\\rin the middle\\nLine with good crlf\\r\\n\\nfinal\\n\" ;\n evbuffer_add ( evb , s , strlen ( s ) ) ;\n cp = evbuffer_readln ( evb , & sz , EVBUFFER_EOL_CRLF ) ;\n tt_line_eq ( \"Line with\\rin the middle\" ) ;\n free ( cp ) ;\n cp = evbuffer_readln ( evb , & sz , EVBUFFER_EOL_CRLF ) ;\n tt_line_eq ( \"Line with good crlf\" ) ;\n free ( cp ) ;\n cp = evbuffer_readln ( evb , & sz , EVBUFFER_EOL_CRLF ) ;\n tt_line_eq ( \"\" ) ;\n free ( cp ) ;\n cp = evbuffer_readln ( evb , & sz , EVBUFFER_EOL_CRLF ) ;\n tt_line_eq ( \"final\" ) ;\n s = \"x\" ;\n evbuffer_add ( evb , s , 1 ) ;\n free ( cp ) ;\n cp = evbuffer_readln ( evb , & sz , EVBUFFER_EOL_CRLF ) ;\n tt_assert ( ! cp ) ;\n fprintf ( stdout , \"OK\\n\" ) ;\n fprintf ( stdout , \"Testing evbuffer_readln CRLF_STRICT: \" ) ;\n s = \" and a bad crlf\\nand a good one\\r\\n\\r\\nMore\\r\" ;\n evbuffer_add ( evb , s , strlen ( s ) ) ;\n cp = evbuffer_readln ( evb , & sz , EVBUFFER_EOL_CRLF_STRICT ) ;\n tt_line_eq ( \"x and a bad crlf\\nand a good one\" ) ;\n free ( cp ) ;\n cp = evbuffer_readln ( evb , & sz , EVBUFFER_EOL_CRLF_STRICT ) ;\n tt_line_eq ( \"\" ) ;\n free ( cp ) ;\n cp = evbuffer_readln ( evb , & sz , EVBUFFER_EOL_CRLF_STRICT ) ;\n tt_assert ( ! cp ) ;\n evbuffer_add ( evb , \"\\n\" , 1 ) ;\n cp = evbuffer_readln ( evb , & sz , EVBUFFER_EOL_CRLF_STRICT ) ;\n tt_line_eq ( \"More\" ) ;\n free ( cp ) ;\n tt_assert ( EVBUFFER_LENGTH ( evb ) == 0 ) ;\n s = \"An internal CR\\r is not an eol\\r\\nNor is a lack of one\" ;\n evbuffer_add ( evb , s , strlen ( s ) ) ;\n cp = evbuffer_readln ( evb , & sz , EVBUFFER_EOL_CRLF_STRICT ) ;\n tt_line_eq ( \"An internal CR\\r is not an eol\" ) ;\n free ( cp ) ;\n cp = evbuffer_readln ( evb , & sz , EVBUFFER_EOL_CRLF_STRICT ) ;\n tt_assert ( ! cp ) ;\n evbuffer_add ( evb , \"\\r\\n\" , 2 ) ;\n cp = evbuffer_readln ( evb , & sz , EVBUFFER_EOL_CRLF_STRICT ) ;\n tt_line_eq ( \"Nor is a lack of one\" ) ;\n free ( cp ) ;\n tt_assert ( EVBUFFER_LENGTH ( evb ) == 0 ) ;\n fprintf ( stdout , \"OK\\n\" ) ;\n fprintf ( stdout , \"Testing evbuffer_readln LF: \" ) ;\n s = \"An\\rand a nl\\n\\nText\" ;\n evbuffer_add ( evb , s , strlen ( s ) ) ;\n cp = evbuffer_readln ( evb , & sz , EVBUFFER_EOL_LF ) ;\n tt_line_eq ( \"An\\rand a nl\" ) ;\n free ( cp ) ;\n cp = evbuffer_readln ( evb , & sz , EVBUFFER_EOL_LF ) ;\n tt_line_eq ( \"\" ) ;\n free ( cp ) ;\n cp = evbuffer_readln ( evb , & sz , EVBUFFER_EOL_LF ) ;\n tt_assert ( ! cp ) ;\n free ( cp ) ;\n evbuffer_add ( evb , \"\\n\" , 1 ) ;\n cp = evbuffer_readln ( evb , & sz , EVBUFFER_EOL_LF ) ;\n tt_line_eq ( \"Text\" ) ;\n free ( cp ) ;\n fprintf ( stdout , \"OK\\n\" ) ;\n fprintf ( stdout , \"Testing evbuffer_readln CRLF_STRICT across boundaries: \" ) ;\n s = \" and a bad crlf\\nand a good one\\r\" ;\n evbuffer_add ( evb_tmp , s , strlen ( s ) ) ;\n evbuffer_add_buffer ( evb , evb_tmp ) ;\n s = \"\\n\\r\" ;\n evbuffer_add ( evb_tmp , s , strlen ( s ) ) ;\n evbuffer_add_buffer ( evb , evb_tmp ) ;\n s = \"\\nMore\\r\" ;\n evbuffer_add ( evb_tmp , s , strlen ( s ) ) ;\n evbuffer_add_buffer ( evb , evb_tmp ) ;\n cp = evbuffer_readln ( evb , & sz , EVBUFFER_EOL_CRLF_STRICT ) ;\n tt_line_eq ( \" and a bad crlf\\nand a good one\" ) ;\n free ( cp ) ;\n cp = evbuffer_readln ( evb , & sz , EVBUFFER_EOL_CRLF_STRICT ) ;\n tt_line_eq ( \"\" ) ;\n free ( cp ) ;\n cp = evbuffer_readln ( evb , & sz , EVBUFFER_EOL_CRLF_STRICT ) ;\n tt_assert ( ! cp ) ;\n free ( cp ) ;\n evbuffer_add ( evb , \"\\n\" , 1 ) ;\n cp = evbuffer_readln ( evb , & sz , EVBUFFER_EOL_CRLF_STRICT ) ;\n tt_line_eq ( \"More\" ) ;\n free ( cp ) ;\n cp = NULL ;\n if ( EVBUFFER_LENGTH ( evb ) != 0 ) {\n fprintf ( stdout , \"FAILED\\n\" ) ;\n exit ( 1 ) ;\n }\n fprintf ( stdout , \"OK\\n\" ) ;\n fprintf ( stdout , \"Testing evbuffer_readln memory problem: \" ) ;\n s = \"one line\\ntwo line\\nblue line\" ;\n evbuffer_add ( evb_tmp , s , strlen ( s ) ) ;\n evbuffer_add_buffer ( evb , evb_tmp ) ;\n cp = evbuffer_readln ( evb , & sz , EVBUFFER_EOL_LF ) ;\n tt_line_eq ( \"one line\" ) ;\n free ( cp ) ;\n cp = NULL ;\n cp = evbuffer_readln ( evb , & sz , EVBUFFER_EOL_LF ) ;\n tt_line_eq ( \"two line\" ) ;\n free ( cp ) ;\n cp = NULL ;\n fprintf ( stdout , \"OK\\n\" ) ;\n test_ok = 1 ;\n evbuffer_free ( evb ) ;\n evbuffer_free ( evb_tmp ) ;\n if ( cp ) free ( cp ) ;\n }", "idx": 1453}
{"hash": -1672864273235910388, "project": "debian", "size": 11, "label": 0, "functionSource": "inline static void _slurm_rpc_trigger_clear ( slurm_msg_t * msg ) {\n int rc ;\n uid_t uid = g_slurm_auth_get_uid ( msg -> auth_cred , slurmctld_config . auth_info ) ;\n trigger_info_msg_t * trigger_ptr = ( trigger_info_msg_t * ) msg -> data ;\n DEF_TIMERS ;\n START_TIMER ;\n debug ( \"Processing RPC: REQUEST_TRIGGER_CLEAR from uid=%d\" , uid ) ;\n rc = trigger_clear ( uid , trigger_ptr ) ;\n END_TIMER2 ( \"_slurm_rpc_trigger_clear\" ) ;\n slurm_send_rc_msg ( msg , rc ) ;\n }", "idx": 1454}
{"hash": 252275190935145023, "project": "debian", "size": 6, "label": 0, "functionSource": "static void setup_frame_size ( VP9_COMMON * cm , struct vp9_read_bit_buffer * rb ) {\n int width , height ;\n vp9_read_frame_size ( rb , & width , & height ) ;\n apply_frame_size ( cm , width , height ) ;\n setup_display_size ( cm , rb ) ;\n }", "idx": 1455}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_T_passwordResponse ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_T_passwordResponse , T_passwordResponse_sequence ) ;\n return offset ;\n }", "idx": 1456}
{"hash": -3146697469509848825, "project": "debian", "size": 36, "label": 0, "functionSource": "static int do_dsa_print ( BIO * bp , const DSA * x , int off , int ptype ) {\n unsigned char * m = NULL ;\n int ret = 0 ;\n size_t buf_len = 0 ;\n const char * ktype = NULL ;\n const BIGNUM * priv_key , * pub_key ;\n if ( ptype == 2 ) priv_key = x -> priv_key ;\n else priv_key = NULL ;\n if ( ptype > 0 ) pub_key = x -> pub_key ;\n else pub_key = NULL ;\n if ( ptype == 2 ) ktype = \"Private-Key\" ;\n else if ( ptype == 1 ) ktype = \"Public-Key\" ;\n else ktype = \"DSA-Parameters\" ;\n update_buflen ( x -> p , & buf_len ) ;\n update_buflen ( x -> q , & buf_len ) ;\n update_buflen ( x -> g , & buf_len ) ;\n update_buflen ( priv_key , & buf_len ) ;\n update_buflen ( pub_key , & buf_len ) ;\n m = OPENSSL_malloc ( buf_len + 10 ) ;\n if ( m == NULL ) {\n DSAerr ( DSA_F_DO_DSA_PRINT , ERR_R_MALLOC_FAILURE ) ;\n goto err ;\n }\n if ( priv_key ) {\n if ( ! BIO_indent ( bp , off , 128 ) ) goto err ;\n if ( BIO_printf ( bp , \"%s: (%d bit)\\n\" , ktype , BN_num_bits ( x -> p ) ) <= 0 ) goto err ;\n }\n if ( ! ASN1_bn_print ( bp , \"priv:\" , priv_key , m , off ) ) goto err ;\n if ( ! ASN1_bn_print ( bp , \"pub: \" , pub_key , m , off ) ) goto err ;\n if ( ! ASN1_bn_print ( bp , \"P: \" , x -> p , m , off ) ) goto err ;\n if ( ! ASN1_bn_print ( bp , \"Q: \" , x -> q , m , off ) ) goto err ;\n if ( ! ASN1_bn_print ( bp , \"G: \" , x -> g , m , off ) ) goto err ;\n ret = 1 ;\n err : OPENSSL_free ( m ) ;\n return ( ret ) ;\n }", "idx": 1457}
{"hash": -7434014980763120366, "project": "debian", "size": 48, "label": 0, "functionSource": "static int try_get_ber_length ( tvbuff_t * tvb , int offset , guint32 * length , gboolean * ind , gint nest_level ) {\n guint8 oct , len ;\n guint32 indef_len ;\n guint32 tmp_length ;\n gboolean tmp_ind ;\n int tmp_offset , s_offset ;\n gint8 tclass ;\n gboolean tpc ;\n gint32 ttag ;\n tmp_length = 0 ;\n tmp_ind = FALSE ;\n if ( nest_level > BER_MAX_NESTING ) {\n THROW ( ReportedBoundsError ) ;\n }\n oct = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n if ( ! ( oct & 0x80 ) ) {\n tmp_length = oct ;\n }\n else {\n len = oct & 0x7F ;\n if ( len ) {\n while ( len -- ) {\n oct = tvb_get_guint8 ( tvb , offset ) ;\n offset ++ ;\n tmp_length = ( tmp_length << 8 ) + oct ;\n }\n }\n else {\n tmp_offset = offset ;\n while ( tvb_get_guint8 ( tvb , offset ) || tvb_get_guint8 ( tvb , offset + 1 ) ) {\n s_offset = offset ;\n offset = get_ber_identifier ( tvb , offset , & tclass , & tpc , & ttag ) ;\n offset = try_get_ber_length ( tvb , offset , & indef_len , NULL , nest_level + 1 ) ;\n tmp_length += indef_len + ( offset - s_offset ) ;\n offset += indef_len ;\n if ( offset <= s_offset ) THROW ( ReportedBoundsError ) ;\n }\n tmp_length += 2 ;\n tmp_ind = TRUE ;\n offset = tmp_offset ;\n }\n }\n if ( length ) * length = tmp_length ;\n if ( ind ) * ind = tmp_ind ;\n # ifdef DEBUG_BER printf ( \"get BER length %d, offset %d (remaining %d)\\n\" , tmp_length , offset , tvb_reported_length_remaining ( tvb , offset ) ) ;\n # endif return offset ;\n }", "idx": 1458}
{"hash": -2723830976796502611, "project": "chrome", "size": 26, "label": 0, "functionSource": "static vpx_codec_err_t encoder_init ( vpx_codec_ctx_t * ctx , vpx_codec_priv_enc_mr_cfg_t * data ) {\n vpx_codec_err_t res = VPX_CODEC_OK ;\n ( void ) data ;\n if ( ctx -> priv == NULL ) {\n vpx_codec_alg_priv_t * const priv = vpx_calloc ( 1 , sizeof ( * priv ) ) ;\n if ( priv == NULL ) return VPX_CODEC_MEM_ERROR ;\n ctx -> priv = ( vpx_codec_priv_t * ) priv ;\n ctx -> priv -> init_flags = ctx -> init_flags ;\n ctx -> priv -> enc . total_encoders = 1 ;\n if ( ctx -> config . enc ) {\n priv -> cfg = * ctx -> config . enc ;\n ctx -> config . enc = & priv -> cfg ;\n }\n priv -> extra_cfg = default_extra_cfg ;\n vp9_initialize_enc ( ) ;\n res = validate_config ( priv , & priv -> cfg , & priv -> extra_cfg ) ;\n if ( res == VPX_CODEC_OK ) {\n set_encoder_config ( & priv -> oxcf , & priv -> cfg , & priv -> extra_cfg ) ;\n # if CONFIG_VP9_HIGHBITDEPTH priv -> oxcf . use_highbitdepth = ( ctx -> init_flags & VPX_CODEC_USE_HIGHBITDEPTH ) ? 1 : 0 ;\n # endif priv -> cpi = vp9_create_compressor ( & priv -> oxcf ) ;\n if ( priv -> cpi == NULL ) res = VPX_CODEC_MEM_ERROR ;\n else priv -> cpi -> output_pkt_list = & priv -> pkt_list . head ;\n }\n }\n return res ;\n }", "idx": 1459}
{"hash": -8958254313220732728, "project": "debian", "size": 11, "label": 0, "functionSource": "static void virtio_pci_config_writew ( void * opaque , uint32_t addr , uint32_t val ) {\n VirtIOPCIProxy * proxy = opaque ;\n uint32_t config = VIRTIO_PCI_CONFIG ( & proxy -> pci_dev ) ;\n addr -= proxy -> addr ;\n if ( addr < config ) {\n virtio_ioport_write ( proxy , addr , val ) ;\n return ;\n }\n addr -= config ;\n virtio_config_writew ( proxy -> vdev , addr , val ) ;\n }", "idx": 1460}
{"hash": -1983921383858884161, "project": "debian", "size": 7, "label": 0, "functionSource": "static int ipvideo_decode_block_opcode_0x6_16 ( IpvideoContext * s , AVFrame * frame ) {\n signed char x , y ;\n x = bytestream2_get_byte ( & s -> stream_ptr ) ;\n y = bytestream2_get_byte ( & s -> stream_ptr ) ;\n av_dlog ( NULL , \" motion bytes = %d, %d\\n\" , x , y ) ;\n return copy_from ( s , s -> second_last_frame , frame , x , y ) ;\n }", "idx": 1461}
{"hash": -4555950263653671147, "project": "debian", "size": 4, "label": 0, "functionSource": "Py_ssize_t PyString_Size ( register PyObject * op ) {\n if ( ! PyString_Check ( op ) ) return string_getsize ( op ) ;\n return Py_SIZE ( op ) ;\n }", "idx": 1462}
{"hash": 7279312193592248512, "project": "debian", "size": 10, "label": 0, "functionSource": "static void intra_pred_down_right ( uint8_t * d , uint8_t * top , uint8_t * left , int stride ) {\n int x , y ;\n for ( y = 0 ;\n y < 8 ;\n y ++ ) for ( x = 0 ;\n x < 8 ;\n x ++ ) if ( x == y ) d [ y * stride + x ] = ( left [ 1 ] + 2 * top [ 0 ] + top [ 1 ] + 2 ) >> 2 ;\n else if ( x > y ) d [ y * stride + x ] = LOWPASS ( top , x - y ) ;\n else d [ y * stride + x ] = LOWPASS ( left , y - x ) ;\n }", "idx": 1463}
{"hash": 3896936900447628930, "project": "debian", "size": 28, "label": 0, "functionSource": "static int parse_audio_var ( AVFormatContext * avctx , AVStream * st , const char * name , int size ) {\n MvContext * mv = avctx -> priv_data ;\n AVIOContext * pb = avctx -> pb ;\n if ( ! strcmp ( name , \"__DIR_COUNT\" ) ) {\n st -> nb_frames = var_read_int ( pb , size ) ;\n }\n else if ( ! strcmp ( name , \"AUDIO_FORMAT\" ) ) {\n mv -> aformat = var_read_int ( pb , size ) ;\n }\n else if ( ! strcmp ( name , \"COMPRESSION\" ) ) {\n mv -> acompression = var_read_int ( pb , size ) ;\n }\n else if ( ! strcmp ( name , \"DEFAULT_VOL\" ) ) {\n var_read_metadata ( avctx , name , size ) ;\n }\n else if ( ! strcmp ( name , \"NUM_CHANNELS\" ) ) {\n return set_channels ( avctx , st , var_read_int ( pb , size ) ) ;\n }\n else if ( ! strcmp ( name , \"SAMPLE_RATE\" ) ) {\n st -> codecpar -> sample_rate = var_read_int ( pb , size ) ;\n avpriv_set_pts_info ( st , 33 , 1 , st -> codecpar -> sample_rate ) ;\n }\n else if ( ! strcmp ( name , \"SAMPLE_WIDTH\" ) ) {\n st -> codecpar -> bits_per_coded_sample = var_read_int ( pb , size ) * 8 ;\n }\n else return AVERROR_INVALIDDATA ;\n return 0 ;\n }", "idx": 1464}
{"hash": 643387607984457432, "project": "debian", "size": 14, "label": 0, "functionSource": "static void synth_block ( WMAVoiceContext * s , GetBitContext * gb , int block_idx , int size , int block_pitch_sh2 , const double * lsps , const double * prev_lsps , const struct frame_type_desc * frame_desc , float * excitation , float * synth ) {\n double i_lsps [ MAX_LSPS ] ;\n float lpcs [ MAX_LSPS ] ;\n float fac ;\n int n ;\n if ( frame_desc -> acb_type == ACB_TYPE_NONE ) synth_block_hardcoded ( s , gb , block_idx , size , frame_desc , excitation ) ;\n else synth_block_fcb_acb ( s , gb , block_idx , size , block_pitch_sh2 , frame_desc , excitation ) ;\n fac = ( block_idx + 0.5 ) / frame_desc -> n_blocks ;\n for ( n = 0 ;\n n < s -> lsps ;\n n ++ ) i_lsps [ n ] = cos ( prev_lsps [ n ] + fac * ( lsps [ n ] - prev_lsps [ n ] ) ) ;\n ff_acelp_lspd2lpc ( i_lsps , lpcs , s -> lsps >> 1 ) ;\n ff_celp_lp_synthesis_filterf ( synth , lpcs , excitation , size , s -> lsps ) ;\n }", "idx": 1465}
{"hash": -7549575329765818478, "project": "debian", "size": 11, "label": 1, "functionSource": "char * curl_easy_unescape ( struct Curl_easy * data , const char * string , int length , int * olen ) {\n char * str = NULL ;\n if ( length >= 0 ) {\n size_t inputlen = length ;\n size_t outputlen ;\n CURLcode res = Curl_urldecode ( data , string , inputlen , & str , & outputlen , FALSE ) ;\n if ( res ) return NULL ;\n if ( olen ) * olen = curlx_uztosi ( outputlen ) ;\n }\n return str ;\n }", "idx": 1466}
{"hash": 3584320764213684062, "project": "debian", "size": 22, "label": 0, "functionSource": "static int dissect_CPMCompareBmk ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * parent_tree , gboolean in , void * data _U_ ) {\n gint offset = 16 ;\n proto_item * item ;\n proto_tree * tree ;\n item = proto_tree_add_item ( parent_tree , hf_mswsp_msg , tvb , offset , in ? 0 : - 1 , ENC_NA ) ;\n tree = proto_item_add_subtree ( item , ett_mswsp_msg ) ;\n proto_item_set_text ( item , \"CompareBmk%s\" , in ? \"In\" : \"Out\" ) ;\n col_append_str ( pinfo -> cinfo , COL_INFO , \"CompareBmk\" ) ;\n if ( in ) {\n proto_tree_add_item ( tree , hf_mswsp_msg_cpmcomparebmk_hcursor , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n proto_tree_add_item ( tree , hf_mswsp_msg_cpmcomparebmk_chapt , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n proto_tree_add_item ( tree , hf_mswsp_msg_cpmcomparebmk_bmkfirst , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n proto_tree_add_item ( tree , hf_mswsp_msg_cpmcomparebmk_bmksecond , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n }\n else {\n proto_tree_add_item ( tree , hf_mswsp_msg_cpmcomparebmk_dwcomparison , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n }\n return tvb_reported_length ( tvb ) ;\n }", "idx": 1467}
{"hash": 2895622461494525400, "project": "debian", "size": 24, "label": 0, "functionSource": "static void test_bug11718 ( ) {\n MYSQL_RES * res ;\n int rc ;\n const char * query = \"select str_to_date(concat(f3),'%Y%m%d') from t1,t2 \" \"where f1=f2 order by f1\" ;\n myheader ( \"test_bug11718\" ) ;\n rc = mysql_query ( mysql , \"drop table if exists t1, t2\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"create table t1 (f1 int)\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"create table t2 (f2 int, f3 numeric(8))\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"insert into t1 values (1), (2)\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"insert into t2 values (1,20050101), (2,20050202)\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , query ) ;\n myquery ( rc ) ;\n res = mysql_store_result ( mysql ) ;\n if ( ! opt_silent ) printf ( \"return type: %s\" , ( res -> fields [ 0 ] . type == MYSQL_TYPE_DATE ) ? \"DATE\" : \"not DATE\" ) ;\n DIE_UNLESS ( res -> fields [ 0 ] . type == MYSQL_TYPE_DATE ) ;\n mysql_free_result ( res ) ;\n rc = mysql_query ( mysql , \"drop table t1, t2\" ) ;\n myquery ( rc ) ;\n }", "idx": 1468}
{"hash": 3887066622454352196, "project": "chrome", "size": 76, "label": 1, "functionSource": "int64_t vp9_rd_pick_inter_mode_sb_seg_skip ( VP9_COMP * cpi , MACROBLOCK * x , int * returnrate , int64_t * returndistortion , BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx , int64_t best_rd_so_far ) {\n VP9_COMMON * const cm = & cpi -> common ;\n RD_OPT * const rd_opt = & cpi -> rd ;\n MACROBLOCKD * const xd = & x -> e_mbd ;\n MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ;\n unsigned char segment_id = mbmi -> segment_id ;\n const int comp_pred = 0 ;\n int i ;\n int64_t best_tx_diff [ TX_MODES ] ;\n int64_t best_pred_diff [ REFERENCE_MODES ] ;\n int64_t best_filter_diff [ SWITCHABLE_FILTER_CONTEXTS ] ;\n unsigned int ref_costs_single [ MAX_REF_FRAMES ] , ref_costs_comp [ MAX_REF_FRAMES ] ;\n vp9_prob comp_mode_p ;\n INTERP_FILTER best_filter = SWITCHABLE ;\n int64_t this_rd = INT64_MAX ;\n int rate2 = 0 ;\n const int64_t distortion2 = 0 ;\n x -> skip_encode = cpi -> sf . skip_encode_frame && x -> q_index < QIDX_SKIP_THRESH ;\n estimate_ref_frame_costs ( cm , xd , segment_id , ref_costs_single , ref_costs_comp , & comp_mode_p ) ;\n for ( i = 0 ;\n i < MAX_REF_FRAMES ;\n ++ i ) x -> pred_sse [ i ] = INT_MAX ;\n for ( i = LAST_FRAME ;\n i < MAX_REF_FRAMES ;\n ++ i ) x -> pred_mv_sad [ i ] = INT_MAX ;\n * returnrate = INT_MAX ;\n assert ( vp9_segfeature_active ( & cm -> seg , segment_id , SEG_LVL_SKIP ) ) ;\n mbmi -> mode = ZEROMV ;\n mbmi -> uv_mode = DC_PRED ;\n mbmi -> ref_frame [ 0 ] = LAST_FRAME ;\n mbmi -> ref_frame [ 1 ] = NONE ;\n mbmi -> mv [ 0 ] . as_int = 0 ;\n x -> skip = 1 ;\n rd_opt -> mask_filter = 0 ;\n for ( i = 0 ;\n i < SWITCHABLE_FILTER_CONTEXTS ;\n ++ i ) rd_opt -> filter_cache [ i ] = INT64_MAX ;\n if ( cm -> interp_filter != BILINEAR ) {\n best_filter = EIGHTTAP ;\n if ( cm -> interp_filter == SWITCHABLE && x -> source_variance >= cpi -> sf . disable_filter_search_var_thresh ) {\n int rs ;\n int best_rs = INT_MAX ;\n for ( i = 0 ;\n i < SWITCHABLE_FILTERS ;\n ++ i ) {\n mbmi -> interp_filter = i ;\n rs = vp9_get_switchable_rate ( cpi ) ;\n if ( rs < best_rs ) {\n best_rs = rs ;\n best_filter = mbmi -> interp_filter ;\n }\n }\n }\n }\n if ( cm -> interp_filter == SWITCHABLE ) {\n mbmi -> interp_filter = best_filter ;\n rate2 += vp9_get_switchable_rate ( cpi ) ;\n }\n else {\n mbmi -> interp_filter = cm -> interp_filter ;\n }\n if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) rate2 += vp9_cost_bit ( comp_mode_p , comp_pred ) ;\n rate2 += ref_costs_single [ LAST_FRAME ] ;\n this_rd = RDCOST ( x -> rdmult , x -> rddiv , rate2 , distortion2 ) ;\n * returnrate = rate2 ;\n * returndistortion = distortion2 ;\n if ( this_rd >= best_rd_so_far ) return INT64_MAX ;\n assert ( ( cm -> interp_filter == SWITCHABLE ) || ( cm -> interp_filter == mbmi -> interp_filter ) ) ;\n update_rd_thresh_fact ( cpi , bsize , THR_ZEROMV ) ;\n vp9_zero ( best_pred_diff ) ;\n vp9_zero ( best_filter_diff ) ;\n vp9_zero ( best_tx_diff ) ;\n if ( ! x -> select_tx_size ) swap_block_ptr ( x , ctx , 1 , 0 , 0 , MAX_MB_PLANE ) ;\n store_coding_context ( x , ctx , THR_ZEROMV , best_pred_diff , best_tx_diff , best_filter_diff , 0 ) ;\n return this_rd ;\n }", "idx": 1469}
{"hash": -3223310365196836448, "project": "debian", "size": 36, "label": 0, "functionSource": "static void load_cursor ( VmncContext * c , const uint8_t * src ) {\n int i , j , p ;\n const int bpp = c -> bpp2 ;\n uint8_t * dst8 = c -> curbits ;\n uint16_t * dst16 = ( uint16_t * ) c -> curbits ;\n uint32_t * dst32 = ( uint32_t * ) c -> curbits ;\n for ( j = 0 ;\n j < c -> cur_h ;\n j ++ ) {\n for ( i = 0 ;\n i < c -> cur_w ;\n i ++ ) {\n p = vmnc_get_pixel ( src , bpp , c -> bigendian ) ;\n src += bpp ;\n if ( bpp == 1 ) * dst8 ++ = p ;\n if ( bpp == 2 ) * dst16 ++ = p ;\n if ( bpp == 4 ) * dst32 ++ = p ;\n }\n }\n dst8 = c -> curmask ;\n dst16 = ( uint16_t * ) c -> curmask ;\n dst32 = ( uint32_t * ) c -> curmask ;\n for ( j = 0 ;\n j < c -> cur_h ;\n j ++ ) {\n for ( i = 0 ;\n i < c -> cur_w ;\n i ++ ) {\n p = vmnc_get_pixel ( src , bpp , c -> bigendian ) ;\n src += bpp ;\n if ( bpp == 1 ) * dst8 ++ = p ;\n if ( bpp == 2 ) * dst16 ++ = p ;\n if ( bpp == 4 ) * dst32 ++ = p ;\n }\n }\n }", "idx": 1470}
{"hash": 4715922168896528064, "project": "debian", "size": 101, "label": 0, "functionSource": "void jpc_ft_invlift_colgrp ( jpc_fix_t * a , int numrows , int stride , int parity ) {\n jpc_fix_t * lptr ;\n jpc_fix_t * hptr ;\n register jpc_fix_t * lptr2 ;\n register jpc_fix_t * hptr2 ;\n register int n ;\n register int i ;\n int llen ;\n llen = ( numrows + 1 - parity ) >> 1 ;\n if ( numrows > 1 ) {\n lptr = & a [ 0 ] ;\n hptr = & a [ llen * stride ] ;\n if ( ! parity ) {\n lptr2 = lptr ;\n hptr2 = hptr ;\n for ( i = 0 ;\n i < JPC_QMFB_COLGRPSIZE ;\n ++ i ) {\n lptr2 [ 0 ] -= jpc_fix_asr ( hptr2 [ 0 ] + 1 , 1 ) ;\n ++ lptr2 ;\n ++ hptr2 ;\n }\n lptr += stride ;\n }\n n = llen - ( ! parity ) - ( parity != ( numrows & 1 ) ) ;\n while ( n -- > 0 ) {\n lptr2 = lptr ;\n hptr2 = hptr ;\n for ( i = 0 ;\n i < JPC_QMFB_COLGRPSIZE ;\n ++ i ) {\n lptr2 [ 0 ] -= jpc_fix_asr ( hptr2 [ 0 ] + hptr2 [ stride ] + 2 , 2 ) ;\n ++ lptr2 ;\n ++ hptr2 ;\n }\n lptr += stride ;\n hptr += stride ;\n }\n if ( parity != ( numrows & 1 ) ) {\n lptr2 = lptr ;\n hptr2 = hptr ;\n for ( i = 0 ;\n i < JPC_QMFB_COLGRPSIZE ;\n ++ i ) {\n lptr2 [ 0 ] -= jpc_fix_asr ( hptr2 [ 0 ] + 1 , 1 ) ;\n ++ lptr2 ;\n ++ hptr2 ;\n }\n }\n lptr = & a [ 0 ] ;\n hptr = & a [ llen * stride ] ;\n if ( parity ) {\n lptr2 = lptr ;\n hptr2 = hptr ;\n for ( i = 0 ;\n i < JPC_QMFB_COLGRPSIZE ;\n ++ i ) {\n hptr2 [ 0 ] += lptr2 [ 0 ] ;\n ++ hptr2 ;\n ++ lptr2 ;\n }\n hptr += stride ;\n }\n n = numrows - llen - parity - ( parity == ( numrows & 1 ) ) ;\n while ( n -- > 0 ) {\n lptr2 = lptr ;\n hptr2 = hptr ;\n for ( i = 0 ;\n i < JPC_QMFB_COLGRPSIZE ;\n ++ i ) {\n hptr2 [ 0 ] += jpc_fix_asr ( lptr2 [ 0 ] + lptr2 [ stride ] , 1 ) ;\n ++ lptr2 ;\n ++ hptr2 ;\n }\n hptr += stride ;\n lptr += stride ;\n }\n if ( parity == ( numrows & 1 ) ) {\n lptr2 = lptr ;\n hptr2 = hptr ;\n for ( i = 0 ;\n i < JPC_QMFB_COLGRPSIZE ;\n ++ i ) {\n hptr2 [ 0 ] += lptr2 [ 0 ] ;\n ++ lptr2 ;\n ++ hptr2 ;\n }\n }\n }\n else {\n if ( parity ) {\n lptr2 = & a [ 0 ] ;\n for ( i = 0 ;\n i < JPC_QMFB_COLGRPSIZE ;\n ++ i ) {\n lptr2 [ 0 ] = jpc_fix_asr ( lptr2 [ 0 ] , 1 ) ;\n ++ lptr2 ;\n }\n }\n }\n }", "idx": 1471}
{"hash": -1929262071302712016, "project": "debian", "size": 34, "label": 0, "functionSource": "static void * Type_ProfileSequenceDesc_Read ( struct _cms_typehandler_struct * self , cmsIOHANDLER * io , cmsUInt32Number * nItems , cmsUInt32Number SizeOfTag ) {\n cmsSEQ * OutSeq ;\n cmsUInt32Number i , Count ;\n * nItems = 0 ;\n if ( ! _cmsReadUInt32Number ( io , & Count ) ) return NULL ;\n if ( SizeOfTag < sizeof ( cmsUInt32Number ) ) return NULL ;\n SizeOfTag -= sizeof ( cmsUInt32Number ) ;\n OutSeq = cmsAllocProfileSequenceDescription ( self -> ContextID , Count ) ;\n if ( OutSeq == NULL ) return NULL ;\n OutSeq -> n = Count ;\n for ( i = 0 ;\n i < Count ;\n i ++ ) {\n cmsPSEQDESC * sec = & OutSeq -> seq [ i ] ;\n if ( ! _cmsReadUInt32Number ( io , & sec -> deviceMfg ) ) goto Error ;\n if ( SizeOfTag < sizeof ( cmsUInt32Number ) ) goto Error ;\n SizeOfTag -= sizeof ( cmsUInt32Number ) ;\n if ( ! _cmsReadUInt32Number ( io , & sec -> deviceModel ) ) goto Error ;\n if ( SizeOfTag < sizeof ( cmsUInt32Number ) ) goto Error ;\n SizeOfTag -= sizeof ( cmsUInt32Number ) ;\n if ( ! _cmsReadUInt64Number ( io , & sec -> attributes ) ) goto Error ;\n if ( SizeOfTag < sizeof ( cmsUInt64Number ) ) goto Error ;\n SizeOfTag -= sizeof ( cmsUInt64Number ) ;\n if ( ! _cmsReadUInt32Number ( io , ( cmsUInt32Number * ) & sec -> technology ) ) goto Error ;\n if ( SizeOfTag < sizeof ( cmsUInt32Number ) ) goto Error ;\n SizeOfTag -= sizeof ( cmsUInt32Number ) ;\n if ( ! ReadEmbeddedText ( self , io , & sec -> Manufacturer , SizeOfTag ) ) goto Error ;\n if ( ! ReadEmbeddedText ( self , io , & sec -> Model , SizeOfTag ) ) goto Error ;\n }\n * nItems = 1 ;\n return OutSeq ;\n Error : cmsFreeProfileSequenceDescription ( OutSeq ) ;\n return NULL ;\n }", "idx": 1472}
{"hash": 2755982813601944893, "project": "debian", "size": 37, "label": 0, "functionSource": "static void imdct_and_window ( TwinContext * tctx , enum FrameType ftype , int wtype , float * in , float * prev , int ch ) {\n FFTContext * mdct = & tctx -> mdct_ctx [ ftype ] ;\n const ModeTab * mtab = tctx -> mtab ;\n int bsize = mtab -> size / mtab -> fmode [ ftype ] . sub ;\n int size = mtab -> size ;\n float * buf1 = tctx -> tmp_buf ;\n int j ;\n int wsize ;\n float * out = tctx -> curr_frame + 2 * ch * mtab -> size ;\n float * out2 = out ;\n float * prev_buf ;\n int first_wsize ;\n static const uint8_t wtype_to_wsize [ ] = {\n 0 , 0 , 2 , 2 , 2 , 1 , 0 , 1 , 1 }\n ;\n int types_sizes [ ] = {\n mtab -> size / mtab -> fmode [ FT_LONG ] . sub , mtab -> size / mtab -> fmode [ FT_MEDIUM ] . sub , mtab -> size / ( 2 * mtab -> fmode [ FT_SHORT ] . sub ) , }\n ;\n wsize = types_sizes [ wtype_to_wsize [ wtype ] ] ;\n first_wsize = wsize ;\n prev_buf = prev + ( size - bsize ) / 2 ;\n for ( j = 0 ;\n j < mtab -> fmode [ ftype ] . sub ;\n j ++ ) {\n int sub_wtype = ftype == FT_MEDIUM ? 8 : wtype ;\n if ( ! j && wtype == 4 ) sub_wtype = 4 ;\n else if ( j == mtab -> fmode [ ftype ] . sub - 1 && wtype == 7 ) sub_wtype = 7 ;\n wsize = types_sizes [ wtype_to_wsize [ sub_wtype ] ] ;\n mdct -> imdct_half ( mdct , buf1 + bsize * j , in + bsize * j ) ;\n tctx -> fdsp . vector_fmul_window ( out2 , prev_buf + ( bsize - wsize ) / 2 , buf1 + bsize * j , ff_sine_windows [ av_log2 ( wsize ) ] , wsize / 2 ) ;\n out2 += wsize ;\n memcpy ( out2 , buf1 + bsize * j + wsize / 2 , ( bsize - wsize / 2 ) * sizeof ( float ) ) ;\n out2 += ftype == FT_MEDIUM ? ( bsize - wsize ) / 2 : bsize - wsize ;\n prev_buf = buf1 + bsize * j + bsize / 2 ;\n }\n tctx -> last_block_pos [ ch ] = ( size + first_wsize ) / 2 ;\n }", "idx": 1473}
{"hash": -866921002076081979, "project": "debian", "size": 386, "label": 0, "functionSource": "REGRESSION_TEST ( SDK_API_TSMimeHdrParse ) ( RegressionTest * test , int , int * pstatus ) {\n const char * parse_string = \"field1:field1Value1,field1Value2\\r\\nfield2:10,-34,45\\r\\nfield3:field3Value1,23\\r\\nfield2: 2345, field2Value2\\r\\n\\r\\n\" ;\n const char * DUPLICATE_FIELD_NAME = \"field2\" ;\n const char * REMOVE_FIELD_NAME = \"field3\" ;\n TSMimeParser parser ;\n TSMBuffer bufp1 = ( TSMBuffer ) nullptr ;\n TSMBuffer bufp2 = ( TSMBuffer ) nullptr ;\n TSMBuffer bufp3 = ( TSMBuffer ) nullptr ;\n TSMLoc mime_hdr_loc1 = ( TSMLoc ) nullptr ;\n TSMLoc mime_hdr_loc2 = ( TSMLoc ) nullptr ;\n TSMLoc mime_hdr_loc3 = ( TSMLoc ) nullptr ;\n TSMLoc field_loc1 = ( TSMLoc ) nullptr ;\n TSMLoc field_loc2 = ( TSMLoc ) nullptr ;\n const char * start ;\n const char * end ;\n char * temp ;\n TSParseResult retval ;\n int hdrLength ;\n bool test_passed_parser_create = false ;\n bool test_passed_parse = false ;\n bool test_passed_parser_clear = false ;\n bool test_passed_parser_destroy = false ;\n bool test_passed_mime_hdr_print = false ;\n bool test_passed_mime_hdr_length_get = false ;\n bool test_passed_mime_hdr_field_next_dup = false ;\n bool test_passed_mime_hdr_copy = false ;\n bool test_passed_mime_hdr_clone = false ;\n bool test_passed_mime_hdr_field_remove = false ;\n bool test_passed_mime_hdr_field_copy = false ;\n bool test_passed_mime_hdr_field_copy_values = false ;\n bool test_passed_handle_mloc_release = false ;\n bool test_passed_mime_hdr_field_find = false ;\n parser = TSMimeParserCreate ( ) ;\n SDK_RPRINT ( test , \"TSMimeParserCreate\" , \"TestCase1\" , TC_PASS , \"ok\" ) ;\n test_passed_parser_create = true ;\n if ( test_passed_parser_create == true ) {\n bufp1 = TSMBufferCreate ( ) ;\n if ( TSMimeHdrCreate ( bufp1 , & mime_hdr_loc1 ) != TS_SUCCESS ) {\n SDK_RPRINT ( test , \"TSMimeHdrParse\" , \"TestCase1\" , TC_FAIL , \"Cannot create Mime hdr for parsing\" ) ;\n SDK_RPRINT ( test , \"TSMimeHdrPrint\" , \"TestCase1\" , TC_FAIL , \"Cannot run test as unable to create Mime Header for parsing\" ) ;\n SDK_RPRINT ( test , \"TSMimeHdrLengthGet\" , \"TestCase1\" , TC_FAIL , \"Cannot run test as unable to create Mime Header for parsing\" ) ;\n if ( TSMBufferDestroy ( bufp1 ) == TS_ERROR ) {\n SDK_RPRINT ( test , \"TSMimeHdrParse\" , \"TestCase1\" , TC_FAIL , \"Error in Destroying MBuffer\" ) ;\n }\n }\n else {\n start = parse_string ;\n end = parse_string + strlen ( parse_string ) + 1 ;\n if ( ( retval = TSMimeHdrParse ( parser , bufp1 , mime_hdr_loc1 , & start , end ) ) == TS_PARSE_ERROR ) {\n SDK_RPRINT ( test , \"TSMimeHdrParse\" , \"TestCase1\" , TC_FAIL , \"TSMimeHdrParse returns TS_PARSE_ERROR\" ) ;\n SDK_RPRINT ( test , \"TSMimeHdrPrint\" , \"TestCase1\" , TC_FAIL , \"Cannot run test as TSMimeHdrParse returned Error.\" ) ;\n SDK_RPRINT ( test , \"TSMimeHdrLengthGet\" , \"TestCase1\" , TC_FAIL , \"Cannot run test as TSMimeHdrParse returned Error.\" ) ;\n }\n else {\n if ( retval == TS_PARSE_DONE ) {\n temp = convert_mime_hdr_to_string ( bufp1 , mime_hdr_loc1 ) ;\n if ( strcmp ( parse_string , temp ) == 0 ) {\n SDK_RPRINT ( test , \"TSMimeHdrParse\" , \"TestCase1\" , TC_PASS , \"ok\" ) ;\n SDK_RPRINT ( test , \"TSMimeHdrPrint\" , \"TestCase1\" , TC_PASS , \"ok\" ) ;\n hdrLength = TSMimeHdrLengthGet ( bufp1 , mime_hdr_loc1 ) ;\n if ( hdrLength == ( int ) strlen ( temp ) ) {\n SDK_RPRINT ( test , \"TSMimeHdrLengthGet\" , \"TestCase1\" , TC_PASS , \"ok\" ) ;\n test_passed_mime_hdr_length_get = true ;\n }\n else {\n SDK_RPRINT ( test , \"TSMimeHdrLengthGet\" , \"TestCase1\" , TC_FAIL , \"Value's Mismatch\" ) ;\n }\n test_passed_parse = true ;\n test_passed_mime_hdr_print = true ;\n }\n else {\n SDK_RPRINT ( test , \"TSMimeHdrParse|TSMimeHdrPrint\" , \"TestCase1\" , TC_FAIL , \"Incorrect parsing or incorrect Printing\" ) ;\n SDK_RPRINT ( test , \"TSMimeHdrLengthGet\" , \"TestCase1\" , TC_FAIL , \"Cannot run test as TSMimeHdrParse|TSMimeHdrPrint failed.\" ) ;\n }\n TSfree ( temp ) ;\n }\n else {\n SDK_RPRINT ( test , \"TSMimeHdrParse\" , \"TestCase1\" , TC_FAIL , \"Parsing Error\" ) ;\n SDK_RPRINT ( test , \"TSMimeHdrPrint\" , \"TestCase1\" , TC_FAIL , \"Cannot run test as TSMimeHdrParse returned error.\" ) ;\n SDK_RPRINT ( test , \"TSMimeHdrLengthGet\" , \"TestCase1\" , TC_FAIL , \"Cannot run test as TSMimeHdrParse returned error.\" ) ;\n }\n }\n }\n }\n else {\n SDK_RPRINT ( test , \"TSMimeHdrParse\" , \"TestCase1\" , TC_FAIL , \"Cannot run test as unable to create a parser\" ) ;\n SDK_RPRINT ( test , \"TSMimeHdrPrint\" , \"TestCase1\" , TC_FAIL , \"Cannot run test as unable to create a parser\" ) ;\n SDK_RPRINT ( test , \"TSMimeHdrLengthGet\" , \"TestCase1\" , TC_FAIL , \"Cannot run test as unable to create a parser\" ) ;\n }\n if ( test_passed_parser_create == true ) {\n TSMimeParserClear ( parser ) ;\n SDK_RPRINT ( test , \"TSMimeParserClear\" , \"TestCase1\" , TC_PASS , \"ok\" ) ;\n test_passed_parser_clear = true ;\n }\n else {\n SDK_RPRINT ( test , \"TSMimeParserClear\" , \"TestCase1\" , TC_FAIL , \"Cannot run test as unable to create a parser\" ) ;\n }\n if ( test_passed_parser_create == true ) {\n TSMimeParserDestroy ( parser ) ;\n SDK_RPRINT ( test , \"TSMimeParserDestroy\" , \"TestCase1\" , TC_PASS , \"ok\" ) ;\n test_passed_parser_destroy = true ;\n }\n else {\n SDK_RPRINT ( test , \"TSMimeParserDestroy\" , \"TestCase1\" , TC_FAIL , \"Cannot run test as unable to create a parser\" ) ;\n }\n if ( test_passed_parse == true ) {\n if ( ( field_loc1 = TSMimeHdrFieldFind ( bufp1 , mime_hdr_loc1 , DUPLICATE_FIELD_NAME , - 1 ) ) == TS_NULL_MLOC ) {\n SDK_RPRINT ( test , \"TSMimeHdrFieldNextDup\" , \"TestCase1\" , TC_FAIL , \"TSMimeHdrFieldFind returns TS_NULL_MLOC\" ) ;\n SDK_RPRINT ( test , \"TSMimeHdrFieldFind\" , \"TestCase1\" , TC_PASS , \"TSMimeHdrFieldFind returns TS_NULL_MLOC\" ) ;\n }\n else {\n const char * fieldName ;\n int length ;\n fieldName = TSMimeHdrFieldNameGet ( bufp1 , mime_hdr_loc1 , field_loc1 , & length ) ;\n if ( strncmp ( fieldName , DUPLICATE_FIELD_NAME , length ) == 0 ) {\n SDK_RPRINT ( test , \"TSMimeHdrFieldFind\" , \"TestCase1\" , TC_PASS , \"ok\" ) ;\n test_passed_mime_hdr_field_find = true ;\n }\n else {\n SDK_RPRINT ( test , \"TSMimeHdrFieldFind\" , \"TestCase1\" , TC_PASS , \"TSMimeHdrFieldFind returns incorrect field pointer\" ) ;\n }\n field_loc2 = TSMimeHdrFieldNextDup ( bufp1 , mime_hdr_loc1 , field_loc1 ) ;\n if ( compare_field_names ( test , bufp1 , mime_hdr_loc1 , field_loc1 , bufp1 , mime_hdr_loc1 , field_loc2 ) == TS_ERROR ) {\n SDK_RPRINT ( test , \"TSMimeHdrFieldNextDup\" , \"TestCase1\" , TC_FAIL , \"Incorrect Pointer\" ) ;\n }\n else {\n SDK_RPRINT ( test , \"TSMimeHdrFieldNextDup\" , \"TestCase1\" , TC_PASS , \"ok\" ) ;\n test_passed_mime_hdr_field_next_dup = true ;\n }\n if ( TSHandleMLocRelease ( bufp1 , mime_hdr_loc1 , field_loc1 ) == TS_ERROR ) {\n SDK_RPRINT ( test , \"TSHandleMLocRelease\" , \"TestCase1\" , TC_FAIL , \"TSHandleMLocRelease returns TS_ERROR\" ) ;\n }\n else {\n SDK_RPRINT ( test , \"TSHandleMLocRelease\" , \"TestCase1\" , TC_PASS , \"ok\" ) ;\n test_passed_handle_mloc_release = true ;\n }\n if ( field_loc2 != nullptr ) {\n if ( TSHandleMLocRelease ( bufp1 , mime_hdr_loc1 , field_loc2 ) == TS_ERROR ) {\n SDK_RPRINT ( test , \"TSHandleMLocRelease\" , \"TestCase2\" , TC_FAIL , \"TSHandleMLocRelease returns TS_ERROR\" ) ;\n test_passed_handle_mloc_release = false ;\n }\n else {\n SDK_RPRINT ( test , \"TSHandleMLocRelease\" , \"TestCase2\" , TC_PASS , \"ok\" ) ;\n }\n }\n }\n }\n else {\n SDK_RPRINT ( test , \"TSMimeHdrFieldNext\" , \"TestCase1\" , TC_FAIL , \"Unable to run test as parsing failed.\" ) ;\n }\n if ( test_passed_parse == true ) {\n bufp2 = TSMBufferCreate ( ) ;\n if ( TSMimeHdrCreate ( bufp2 , & mime_hdr_loc2 ) != TS_SUCCESS ) {\n SDK_RPRINT ( test , \"TSMimeHdrCopy\" , \"TestCase1\" , TC_FAIL , \"Cannot create Mime hdr for copying\" ) ;\n if ( TSMBufferDestroy ( bufp2 ) == TS_ERROR ) {\n SDK_RPRINT ( test , \"TSMimeHdrCopy\" , \"TestCase1\" , TC_FAIL , \"Error in Destroying MBuffer\" ) ;\n }\n }\n else {\n if ( TSMimeHdrCopy ( bufp2 , mime_hdr_loc2 , bufp1 , mime_hdr_loc1 ) == TS_ERROR ) {\n SDK_RPRINT ( test , \"TSMimeHdrCopy\" , \"TestCase1\" , TC_FAIL , \"TSMimeHdrCopy returns TS_ERROR\" ) ;\n }\n else {\n temp = convert_mime_hdr_to_string ( bufp2 , mime_hdr_loc2 ) ;\n if ( strcmp ( parse_string , temp ) == 0 ) {\n SDK_RPRINT ( test , \"TSMimeHdrCopy\" , \"TestCase1\" , TC_PASS , \"ok\" ) ;\n test_passed_mime_hdr_copy = true ;\n }\n else {\n SDK_RPRINT ( test , \"TSMimeHdrCopy\" , \"TestCase1\" , TC_FAIL , \"Value's Mismatch\" ) ;\n }\n TSfree ( temp ) ;\n }\n }\n }\n else {\n SDK_RPRINT ( test , \"TSMimeHdrCopy\" , \"TestCase1\" , TC_FAIL , \"Unable to run test as parsing failed.\" ) ;\n }\n bufp3 = TSMBufferCreate ( ) ;\n TSMimeHdrCreate ( bufp3 , & mime_hdr_loc3 ) ;\n test_passed_mime_hdr_clone = true ;\n if ( test_passed_mime_hdr_copy == true ) {\n if ( ( field_loc1 = TSMimeHdrFieldFind ( bufp2 , mime_hdr_loc2 , REMOVE_FIELD_NAME , - 1 ) ) == TS_NULL_MLOC ) {\n SDK_RPRINT ( test , \"TSMimeHdrFieldRemove\" , \"TestCase1\" , TC_FAIL , \"TSMimeHdrFieldFind returns TS_NULL_MLOC\" ) ;\n }\n else {\n if ( TSMimeHdrFieldRemove ( bufp2 , mime_hdr_loc2 , field_loc1 ) != TS_SUCCESS ) {\n SDK_RPRINT ( test , \"TSMimeHdrFieldRemove\" , \"TestCase1\" , TC_FAIL , \"TSMimeHdrFieldRemove returns TS_ERROR\" ) ;\n }\n else {\n field_loc2 = TSMimeHdrFieldFind ( bufp2 , mime_hdr_loc2 , REMOVE_FIELD_NAME , - 1 ) ;\n if ( ( field_loc2 == TS_NULL_MLOC ) || ( field_loc1 != field_loc2 ) ) {\n test_passed_mime_hdr_field_remove = true ;\n }\n else {\n SDK_RPRINT ( test , \"TSMimeHdrFieldRemove\" , \"TestCase1\" , TC_FAIL , \"Field Not Removed\" ) ;\n }\n if ( test_passed_mime_hdr_field_remove == true ) {\n if ( TSMimeHdrFieldAppend ( bufp2 , mime_hdr_loc2 , field_loc1 ) != TS_SUCCESS ) {\n SDK_RPRINT ( test , \"TSMimeHdrFieldRemove\" , \"TestCase1\" , TC_FAIL , \"Unable to readd the field to mime header. Probably destroyed\" ) ;\n test_passed_mime_hdr_field_remove = false ;\n }\n else {\n SDK_RPRINT ( test , \"TSMimeHdrFieldRemove\" , \"TestCase1\" , TC_PASS , \"ok\" ) ;\n }\n }\n }\n if ( TSHandleMLocRelease ( bufp2 , mime_hdr_loc2 , field_loc1 ) == TS_ERROR ) {\n SDK_RPRINT ( test , \"TSHandleMLocRelease\" , \"TestCase3\" , TC_FAIL , \"TSHandleMLocRelease returns TS_ERROR\" ) ;\n test_passed_handle_mloc_release = false ;\n }\n else {\n SDK_RPRINT ( test , \"TSHandleMLocRelease\" , \"TestCase3\" , TC_PASS , \"ok\" ) ;\n }\n if ( field_loc2 != nullptr ) {\n if ( TSHandleMLocRelease ( bufp2 , mime_hdr_loc2 , field_loc2 ) == TS_ERROR ) {\n SDK_RPRINT ( test , \"TSHandleMLocRelease\" , \"TestCase4\" , TC_FAIL , \"TSHandleMLocRelease returns TS_ERROR\" ) ;\n test_passed_handle_mloc_release = false ;\n }\n else {\n SDK_RPRINT ( test , \"TSHandleMLocRelease\" , \"TestCase4\" , TC_PASS , \"ok\" ) ;\n }\n }\n }\n }\n else {\n SDK_RPRINT ( test , \"TSMimeHdrFieldNext\" , \"TestCase1\" , TC_FAIL , \"Unable to run test as parsing failed.\" ) ;\n }\n if ( test_passed_mime_hdr_copy == true ) {\n if ( TSMimeHdrFieldCreate ( bufp2 , mime_hdr_loc2 , & field_loc1 ) != TS_SUCCESS ) {\n SDK_RPRINT ( test , \"TSMimeHdrFieldCopy\" , \"TestCase1\" , TC_FAIL , \"Unable to create field for Copying\" ) ;\n }\n else {\n if ( ( field_loc2 = TSMimeHdrFieldGet ( bufp1 , mime_hdr_loc1 , 0 ) ) == TS_NULL_MLOC ) {\n SDK_RPRINT ( test , \"TSMimeHdrFieldCopy\" , \"TestCase1\" , TC_FAIL , \"Unable to get source field for copying\" ) ;\n }\n else {\n if ( TSMimeHdrFieldCopy ( bufp2 , mime_hdr_loc2 , field_loc1 , bufp1 , mime_hdr_loc1 , field_loc2 ) == TS_ERROR ) {\n SDK_RPRINT ( test , \"TSMimeHdrFieldCopy\" , \"TestCase1\" , TC_FAIL , \"TSMimeHdrFieldCopy returns TS_ERROR\" ) ;\n }\n else {\n if ( ( compare_field_names ( test , bufp2 , mime_hdr_loc2 , field_loc1 , bufp1 , mime_hdr_loc1 , field_loc2 ) == TS_ERROR ) || ( compare_field_values ( test , bufp2 , mime_hdr_loc2 , field_loc1 , bufp1 , mime_hdr_loc1 , field_loc2 ) == TS_ERROR ) ) {\n SDK_RPRINT ( test , \"TSMimeHdrFieldCopy\" , \"TestCase1\" , TC_FAIL , \"Value's Mismatch\" ) ;\n }\n else {\n SDK_RPRINT ( test , \"TSMimeHdrFieldCopy\" , \"TestCase1\" , TC_PASS , \"ok\" ) ;\n test_passed_mime_hdr_field_copy = true ;\n }\n }\n }\n if ( TSHandleMLocRelease ( bufp2 , mime_hdr_loc2 , field_loc1 ) == TS_ERROR ) {\n SDK_RPRINT ( test , \"TSHandleMLocRelease\" , \"TestCase5\" , TC_FAIL , \"TSHandleMLocRelease returns TS_ERROR\" ) ;\n test_passed_handle_mloc_release = false ;\n }\n else {\n SDK_RPRINT ( test , \"TSHandleMLocRelease\" , \"TestCase5\" , TC_PASS , \"ok\" ) ;\n }\n if ( field_loc2 != nullptr ) {\n if ( TSHandleMLocRelease ( bufp1 , mime_hdr_loc1 , field_loc2 ) == TS_ERROR ) {\n SDK_RPRINT ( test , \"TSHandleMLocRelease\" , \"TestCase6\" , TC_FAIL , \"TSHandleMLocRelease returns TS_ERROR\" ) ;\n test_passed_handle_mloc_release = false ;\n }\n else {\n SDK_RPRINT ( test , \"TSHandleMLocRelease\" , \"TestCase6\" , TC_PASS , \"ok\" ) ;\n }\n }\n }\n }\n else {\n SDK_RPRINT ( test , \"TSMimeHdrFieldCopy\" , \"TestCase1\" , TC_FAIL , \"Unable to run test as bufp2 might not have been created\" ) ;\n }\n if ( test_passed_mime_hdr_clone == true ) {\n field_loc1 = nullptr ;\n field_loc2 = nullptr ;\n if ( ( field_loc2 = TSMimeHdrFieldGet ( bufp1 , mime_hdr_loc1 , 0 ) ) == TS_NULL_MLOC ) {\n SDK_RPRINT ( test , \"TSMimeHdrFieldClone\" , \"TestCase1\" , TC_FAIL , \"Unable to get source field for copying\" ) ;\n }\n else {\n if ( TSMimeHdrFieldClone ( bufp3 , mime_hdr_loc3 , bufp1 , mime_hdr_loc1 , field_loc2 , & field_loc1 ) != TS_SUCCESS ) {\n SDK_RPRINT ( test , \"TSMimeHdrFieldClone\" , \"TestCase1\" , TC_FAIL , \"TSMimeHdrFieldClone returns TS_ERROR\" ) ;\n }\n else {\n if ( ( compare_field_names ( test , bufp3 , mime_hdr_loc3 , field_loc1 , bufp1 , mime_hdr_loc1 , field_loc2 ) == TS_ERROR ) || ( compare_field_values ( test , bufp3 , mime_hdr_loc3 , field_loc1 , bufp1 , mime_hdr_loc1 , field_loc2 ) == TS_ERROR ) ) {\n SDK_RPRINT ( test , \"TSMimeHdrFieldClone\" , \"TestCase1\" , TC_FAIL , \"Value's Mismatch\" ) ;\n }\n else {\n SDK_RPRINT ( test , \"TSMimeHdrFieldClone\" , \"TestCase1\" , TC_PASS , \"ok\" ) ;\n }\n }\n }\n if ( field_loc1 != nullptr ) {\n if ( TSHandleMLocRelease ( bufp3 , mime_hdr_loc3 , field_loc1 ) == TS_ERROR ) {\n SDK_RPRINT ( test , \"TSHandleMLocRelease\" , \"TestCase7\" , TC_FAIL , \"TSHandleMLocRelease returns TS_ERROR\" ) ;\n test_passed_handle_mloc_release = false ;\n }\n else {\n SDK_RPRINT ( test , \"TSHandleMLocRelease\" , \"TestCase7\" , TC_PASS , \"ok\" ) ;\n }\n }\n if ( field_loc2 != nullptr ) {\n if ( TSHandleMLocRelease ( bufp1 , mime_hdr_loc1 , field_loc2 ) == TS_ERROR ) {\n SDK_RPRINT ( test , \"TSHandleMLocRelease\" , \"TestCase8\" , TC_FAIL , \"TSHandleMLocRelease returns TS_ERROR\" ) ;\n test_passed_handle_mloc_release = false ;\n }\n else {\n SDK_RPRINT ( test , \"TSHandleMLocRelease\" , \"TestCase8\" , TC_PASS , \"ok\" ) ;\n }\n }\n }\n else {\n SDK_RPRINT ( test , \"TSMimeHdrFieldClone\" , \"TestCase1\" , TC_FAIL , \"Unable to run test as bufp3 might not have been created\" ) ;\n }\n if ( test_passed_mime_hdr_copy == true ) {\n if ( TSMimeHdrFieldCreate ( bufp2 , mime_hdr_loc2 , & field_loc1 ) != TS_SUCCESS ) {\n SDK_RPRINT ( test , \"TSMimeHdrFieldCopyValues\" , \"TestCase1\" , TC_FAIL , \"Unable to create field for Copying\" ) ;\n }\n else {\n if ( ( field_loc2 = TSMimeHdrFieldGet ( bufp1 , mime_hdr_loc1 , 0 ) ) == TS_NULL_MLOC ) {\n SDK_RPRINT ( test , \"TSMimeHdrFieldCopyValues\" , \"TestCase1\" , TC_FAIL , \"Unable to get source field for copying\" ) ;\n }\n else {\n if ( TSMimeHdrFieldCopyValues ( bufp2 , mime_hdr_loc2 , field_loc1 , bufp1 , mime_hdr_loc1 , field_loc2 ) == TS_ERROR ) {\n SDK_RPRINT ( test , \"TSMimeHdrFieldCopyValues\" , \"TestCase1\" , TC_FAIL , \"TSMimeHdrFieldCopy returns TS_ERROR\" ) ;\n }\n else {\n if ( compare_field_values ( test , bufp2 , mime_hdr_loc2 , field_loc1 , bufp1 , mime_hdr_loc1 , field_loc2 ) == TS_ERROR ) {\n SDK_RPRINT ( test , \"TSMimeHdrFieldCopyValues\" , \"TestCase1\" , TC_FAIL , \"Value's Mismatch\" ) ;\n }\n else {\n SDK_RPRINT ( test , \"TSMimeHdrFieldCopyValues\" , \"TestCase1\" , TC_PASS , \"ok\" ) ;\n test_passed_mime_hdr_field_copy_values = true ;\n }\n }\n }\n if ( TSHandleMLocRelease ( bufp2 , mime_hdr_loc2 , field_loc1 ) == TS_ERROR ) {\n SDK_RPRINT ( test , \"TSHandleMLocRelease\" , \"TestCase9\" , TC_FAIL , \"TSHandleMLocRelease returns TS_ERROR\" ) ;\n test_passed_handle_mloc_release = false ;\n }\n else {\n SDK_RPRINT ( test , \"TSHandleMLocRelease\" , \"TestCase9\" , TC_PASS , \"ok\" ) ;\n }\n if ( field_loc2 != nullptr ) {\n if ( TSHandleMLocRelease ( bufp1 , mime_hdr_loc1 , field_loc2 ) == TS_ERROR ) {\n SDK_RPRINT ( test , \"TSHandleMLocRelease\" , \"TestCase10\" , TC_FAIL , \"TSHandleMLocRelease returns TS_ERROR\" ) ;\n test_passed_handle_mloc_release = false ;\n }\n else {\n SDK_RPRINT ( test , \"TSHandleMLocRelease\" , \"TestCase10\" , TC_PASS , \"ok\" ) ;\n }\n }\n }\n }\n else {\n SDK_RPRINT ( test , \"TSMimeHdrFieldCopy\" , \"TestCase1\" , TC_FAIL , \"Unable to run test as bufp2 might not have been created\" ) ;\n }\n if ( ( TSMimeHdrDestroy ( bufp1 , mime_hdr_loc1 ) == TS_ERROR ) || ( TSMimeHdrDestroy ( bufp2 , mime_hdr_loc2 ) == TS_ERROR ) || ( TSMimeHdrDestroy ( bufp3 , mime_hdr_loc3 ) == TS_ERROR ) ) {\n SDK_RPRINT ( test , \"\" , \"TestCase\" , TC_FAIL , \"TSMimeHdrDestroy returns TS_ERROR\" ) ;\n }\n if ( TSHandleMLocRelease ( bufp1 , TS_NULL_MLOC , mime_hdr_loc1 ) == TS_ERROR ) {\n SDK_RPRINT ( test , \"TSHandleMLocRelease\" , \"TestCase11|12|13\" , TC_FAIL , \"Unable to release mime_hdr_loc1 to Mime Hdrs\" ) ;\n test_passed_handle_mloc_release = false ;\n }\n if ( TSHandleMLocRelease ( bufp2 , TS_NULL_MLOC , mime_hdr_loc2 ) == TS_ERROR ) {\n SDK_RPRINT ( test , \"TSHandleMLocRelease\" , \"TestCase11|12|13\" , TC_FAIL , \"Unable to release mime_hdr_loc2 to Mime Hdrs\" ) ;\n test_passed_handle_mloc_release = false ;\n }\n if ( TSHandleMLocRelease ( bufp3 , TS_NULL_MLOC , mime_hdr_loc3 ) == TS_ERROR ) {\n SDK_RPRINT ( test , \"TSHandleMLocRelease\" , \"TestCase11|12|13\" , TC_FAIL , \"Unable to release mime_hdr_loc3 to Mime Hdrs\" ) ;\n test_passed_handle_mloc_release = false ;\n }\n if ( TSMBufferDestroy ( bufp1 ) == TS_ERROR ) {\n SDK_RPRINT ( test , \"\" , \"TestCase\" , TC_FAIL , \"TSMBufferDestroy(bufp1) returns TS_ERROR\" ) ;\n }\n if ( TSMBufferDestroy ( bufp2 ) == TS_ERROR ) {\n SDK_RPRINT ( test , \"\" , \"TestCase\" , TC_FAIL , \"TSMBufferDestroy(bufp2) returns TS_ERROR\" ) ;\n }\n if ( TSMBufferDestroy ( bufp3 ) == TS_ERROR ) {\n SDK_RPRINT ( test , \"\" , \"TestCase\" , TC_FAIL , \"TSMBufferDestroy(bufp3) returns TS_ERROR\" ) ;\n }\n if ( ( test_passed_parser_create != true ) || ( test_passed_parse != true ) || ( test_passed_parser_clear != true ) || ( test_passed_parser_destroy != true ) || ( test_passed_mime_hdr_print != true ) || ( test_passed_mime_hdr_length_get != true ) || ( test_passed_mime_hdr_field_next_dup != true ) || ( test_passed_mime_hdr_copy != true ) || ( test_passed_mime_hdr_clone != true ) || ( test_passed_mime_hdr_field_remove != true ) || ( test_passed_mime_hdr_field_copy != true ) || ( test_passed_mime_hdr_field_copy_values != true ) || ( test_passed_handle_mloc_release != true ) || ( test_passed_mime_hdr_field_find != true ) ) {\n * pstatus = REGRESSION_TEST_FAILED ;\n }\n else {\n * pstatus = REGRESSION_TEST_PASSED ;\n }\n }", "idx": 1474}
{"hash": 6249489553242542670, "project": "debian", "size": 81, "label": 0, "functionSource": "peer_node * create_peer_node ( int hmode , address_node * addr , attr_val_fifo * options ) {\n peer_node * my_node ;\n attr_val * option ;\n int freenode ;\n int errflag = 0 ;\n my_node = emalloc_zero ( sizeof ( * my_node ) ) ;\n my_node -> peerversion = NTP_VERSION ;\n my_node -> host_mode = hmode ;\n my_node -> addr = addr ;\n while ( options != NULL ) {\n UNLINK_FIFO ( option , * options , link ) ;\n if ( NULL == option ) {\n free ( options ) ;\n break ;\n }\n freenode = 1 ;\n switch ( option -> attr ) {\n case T_Flag : APPEND_G_FIFO ( my_node -> peerflags , option ) ;\n freenode = 0 ;\n break ;\n case T_Minpoll : if ( option -> value . i < NTP_MINPOLL || option -> value . i > UCHAR_MAX ) {\n msyslog ( LOG_INFO , \"minpoll: provided value (%d) is out of range [%d-%d])\" , option -> value . i , NTP_MINPOLL , UCHAR_MAX ) ;\n my_node -> minpoll = NTP_MINPOLL ;\n }\n else {\n my_node -> minpoll = ( u_char ) option -> value . u ;\n }\n break ;\n case T_Maxpoll : if ( option -> value . i < 0 || option -> value . i > NTP_MAXPOLL ) {\n msyslog ( LOG_INFO , \"maxpoll: provided value (%d) is out of range [0-%d])\" , option -> value . i , NTP_MAXPOLL ) ;\n my_node -> maxpoll = NTP_MAXPOLL ;\n }\n else {\n my_node -> maxpoll = ( u_char ) option -> value . u ;\n }\n break ;\n case T_Ttl : if ( option -> value . u >= MAX_TTL ) {\n msyslog ( LOG_ERR , \"ttl: invalid argument\" ) ;\n errflag = 1 ;\n }\n else {\n my_node -> ttl = ( u_char ) option -> value . u ;\n }\n break ;\n case T_Mode : if ( option -> value . u >= UCHAR_MAX ) {\n msyslog ( LOG_ERR , \"mode: invalid argument\" ) ;\n errflag = 1 ;\n }\n else {\n my_node -> ttl = ( u_char ) option -> value . u ;\n }\n break ;\n case T_Key : if ( option -> value . u >= KEYID_T_MAX ) {\n msyslog ( LOG_ERR , \"key: invalid argument\" ) ;\n errflag = 1 ;\n }\n else {\n my_node -> peerkey = ( keyid_t ) option -> value . u ;\n }\n break ;\n case T_Version : if ( option -> value . u >= UCHAR_MAX ) {\n msyslog ( LOG_ERR , \"version: invalid argument\" ) ;\n errflag = 1 ;\n }\n else {\n my_node -> peerversion = ( u_char ) option -> value . u ;\n }\n break ;\n case T_Ident : my_node -> group = option -> value . s ;\n break ;\n default : msyslog ( LOG_ERR , \"Unknown peer/server option token %s\" , token_name ( option -> attr ) ) ;\n errflag = 1 ;\n }\n if ( freenode ) free ( option ) ;\n }\n if ( errflag ) {\n free ( my_node ) ;\n my_node = NULL ;\n }\n return my_node ;\n }", "idx": 1475}
{"hash": 6323824267898511453, "project": "debian", "size": 10, "label": 0, "functionSource": "static void rgb2cmyk ( fz_context * ctx , fz_color_converter * cc , float * dv , const float * sv ) {\n float c = 1 - sv [ 0 ] ;\n float m = 1 - sv [ 1 ] ;\n float y = 1 - sv [ 2 ] ;\n float k = fz_min ( c , fz_min ( m , y ) ) ;\n dv [ 0 ] = c - k ;\n dv [ 1 ] = m - k ;\n dv [ 2 ] = y - k ;\n dv [ 3 ] = k ;\n }", "idx": 1476}
{"hash": 2335222688263906532, "project": "debian", "size": 54, "label": 0, "functionSource": "static void rv34_pred_mv_rv3 ( RV34DecContext * r , int block_type , int dir ) {\n MpegEncContext * s = & r -> s ;\n int mv_pos = s -> mb_x * 2 + s -> mb_y * 2 * s -> b8_stride ;\n int A [ 2 ] = {\n 0 }\n , B [ 2 ] , C [ 2 ] ;\n int i , j , k ;\n int mx , my ;\n int * avail = r -> avail_cache + avail_indexes [ 0 ] ;\n if ( avail [ - 1 ] ) {\n A [ 0 ] = s -> current_picture_ptr -> motion_val [ 0 ] [ mv_pos - 1 ] [ 0 ] ;\n A [ 1 ] = s -> current_picture_ptr -> motion_val [ 0 ] [ mv_pos - 1 ] [ 1 ] ;\n }\n if ( avail [ - 4 ] ) {\n B [ 0 ] = s -> current_picture_ptr -> motion_val [ 0 ] [ mv_pos - s -> b8_stride ] [ 0 ] ;\n B [ 1 ] = s -> current_picture_ptr -> motion_val [ 0 ] [ mv_pos - s -> b8_stride ] [ 1 ] ;\n }\n else {\n B [ 0 ] = A [ 0 ] ;\n B [ 1 ] = A [ 1 ] ;\n }\n if ( ! avail [ - 4 + 2 ] ) {\n if ( avail [ - 4 ] && ( avail [ - 1 ] ) ) {\n C [ 0 ] = s -> current_picture_ptr -> motion_val [ 0 ] [ mv_pos - s -> b8_stride - 1 ] [ 0 ] ;\n C [ 1 ] = s -> current_picture_ptr -> motion_val [ 0 ] [ mv_pos - s -> b8_stride - 1 ] [ 1 ] ;\n }\n else {\n C [ 0 ] = A [ 0 ] ;\n C [ 1 ] = A [ 1 ] ;\n }\n }\n else {\n C [ 0 ] = s -> current_picture_ptr -> motion_val [ 0 ] [ mv_pos - s -> b8_stride + 2 ] [ 0 ] ;\n C [ 1 ] = s -> current_picture_ptr -> motion_val [ 0 ] [ mv_pos - s -> b8_stride + 2 ] [ 1 ] ;\n }\n mx = mid_pred ( A [ 0 ] , B [ 0 ] , C [ 0 ] ) ;\n my = mid_pred ( A [ 1 ] , B [ 1 ] , C [ 1 ] ) ;\n mx += r -> dmv [ 0 ] [ 0 ] ;\n my += r -> dmv [ 0 ] [ 1 ] ;\n for ( j = 0 ;\n j < 2 ;\n j ++ ) {\n for ( i = 0 ;\n i < 2 ;\n i ++ ) {\n for ( k = 0 ;\n k < 2 ;\n k ++ ) {\n s -> current_picture_ptr -> motion_val [ k ] [ mv_pos + i + j * s -> b8_stride ] [ 0 ] = mx ;\n s -> current_picture_ptr -> motion_val [ k ] [ mv_pos + i + j * s -> b8_stride ] [ 1 ] = my ;\n }\n }\n }\n }", "idx": 1477}
{"hash": 179698602413630959, "project": "debian", "size": 19, "label": 1, "functionSource": "static inline void copy ( LZOContext * c , int cnt ) {\n register const uint8_t * src = c -> in ;\n register uint8_t * dst = c -> out ;\n if ( cnt > c -> in_end - src ) {\n cnt = FFMAX ( c -> in_end - src , 0 ) ;\n c -> error |= AV_LZO_INPUT_DEPLETED ;\n }\n if ( cnt > c -> out_end - dst ) {\n cnt = FFMAX ( c -> out_end - dst , 0 ) ;\n c -> error |= AV_LZO_OUTPUT_FULL ;\n }\n # if defined ( INBUF_PADDED ) && defined ( OUTBUF_PADDED ) AV_COPY32U ( dst , src ) ;\n src += 4 ;\n dst += 4 ;\n cnt -= 4 ;\n if ( cnt > 0 ) # endif memcpy ( dst , src , cnt ) ;\n c -> in = src + cnt ;\n c -> out = dst + cnt ;\n }", "idx": 1478}
{"hash": 5400542917484463750, "project": "chrome", "size": 3, "label": 1, "functionSource": "static void log_invalid_scale_factor ( SvcContext * svc_ctx , const char * value ) {\n svc_log ( svc_ctx , SVC_LOG_ERROR , \"svc scale-factors: invalid value %s\\n\" , value ) ;\n }", "idx": 1479}
{"hash": 5918484636148310736, "project": "debian", "size": 31, "label": 0, "functionSource": "int gdev_mem_open_scan_lines ( gx_device_memory * mdev , int setup_height ) {\n bool line_pointers_adjacent = true ;\n ulong size ;\n if ( setup_height < 0 || setup_height > mdev -> height ) return_error ( gs_error_rangecheck ) ;\n if ( mdev -> bitmap_memory != 0 ) {\n int align ;\n if ( gdev_mem_bitmap_size ( mdev , & size ) < 0 ) return_error ( gs_error_VMerror ) ;\n if ( ( uint ) size != size ) return_error ( gs_error_limitcheck ) ;\n mdev -> base = gs_alloc_bytes ( mdev -> bitmap_memory , ( uint ) size , \"mem_open\" ) ;\n if ( mdev -> base == 0 ) return_error ( gs_error_VMerror ) ;\n # ifdef PACIFY_VALGRIND memset ( mdev -> base , 0x00 , size ) ;\n # endif align = 1 << mdev -> log2_align_mod ;\n mdev -> base += ( - ( int ) ( intptr_t ) mdev -> base ) & ( align - 1 ) ;\n mdev -> foreign_bits = false ;\n }\n else if ( mdev -> line_pointer_memory != 0 ) {\n mdev -> line_ptrs = ( byte * * ) gs_alloc_byte_array ( mdev -> line_pointer_memory , mdev -> height , sizeof ( byte * ) * ( mdev -> is_planar ? mdev -> color_info . num_components : 1 ) , \"gdev_mem_open_scan_lines\" ) ;\n if ( mdev -> line_ptrs == 0 ) return_error ( gs_error_VMerror ) ;\n mdev -> foreign_line_pointers = false ;\n line_pointers_adjacent = false ;\n }\n if ( line_pointers_adjacent ) {\n int code ;\n if ( mdev -> base == 0 ) return_error ( gs_error_rangecheck ) ;\n code = gdev_mem_bits_size ( mdev , mdev -> width , mdev -> height , & size ) ;\n if ( code < 0 ) return code ;\n mdev -> line_ptrs = ( byte * * ) ( mdev -> base + size ) ;\n }\n mdev -> raster = gx_device_raster ( ( gx_device * ) mdev , 1 ) ;\n return gdev_mem_set_line_ptrs ( mdev , NULL , 0 , NULL , setup_height ) ;\n }", "idx": 1480}
{"hash": 1414661670117003749, "project": "debian", "size": 11, "label": 1, "functionSource": "static void show_object ( struct object * object , const struct name_path * path , const char * last , void * data ) {\n struct bitmap * base = data ;\n int bitmap_pos ;\n bitmap_pos = bitmap_position ( object -> oid . hash ) ;\n if ( bitmap_pos < 0 ) {\n char * name = path_name ( path , last ) ;\n bitmap_pos = ext_index_add_object ( object , name ) ;\n free ( name ) ;\n }\n bitmap_set ( base , bitmap_pos ) ;\n }", "idx": 1481}
{"hash": 3426991998365732450, "project": "debian", "size": 8, "label": 0, "functionSource": "void ps2_queue ( PS2State * s , int b ) {\n PS2Queue * q = & s -> queue ;\n if ( q -> count >= PS2_QUEUE_SIZE - 1 ) return ;\n q -> data [ q -> wptr ] = b ;\n if ( ++ q -> wptr == PS2_QUEUE_SIZE ) q -> wptr = 0 ;\n q -> count ++ ;\n s -> update_irq ( s -> update_arg , 1 ) ;\n }", "idx": 1482}
{"hash": -1338403456839869183, "project": "debian", "size": 17, "label": 0, "functionSource": "static gboolean dissect_q931_tpkt_heur ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , void * data _U_ ) {\n int lv_tpkt_len ;\n lv_tpkt_len = is_tpkt ( tvb , 3 ) ;\n if ( lv_tpkt_len == - 1 ) {\n return FALSE ;\n }\n if ( tvb_reported_length ( tvb ) == 4 ) {\n dissect_tpkt_encap ( tvb , pinfo , tree , q931_desegment , q931_tpkt_pdu_handle ) ;\n return TRUE ;\n }\n if ( ! tvb_bytes_exist ( tvb , 4 , 3 ) ) return FALSE ;\n if ( ( tvb_get_guint8 ( tvb , 4 ) != NLPID_Q_931 ) && ( tvb_get_guint8 ( tvb , 4 ) != 0x03 ) ) {\n return FALSE ;\n }\n dissect_tpkt_encap ( tvb , pinfo , tree , q931_desegment , q931_tpkt_pdu_handle ) ;\n return TRUE ;\n }", "idx": 1483}
{"hash": -3165961362620712443, "project": "chrome", "size": 4, "label": 0, "functionSource": "static inline bool is_one_of ( const hb_glyph_info_t & info , unsigned int flags ) {\n if ( _hb_glyph_info_ligated ( & info ) ) return false ;\n return ! ! ( FLAG_SAFE ( info . indic_category ( ) ) & flags ) ;\n }", "idx": 1484}
{"hash": -866921002076081979, "project": "debian", "size": 18, "label": 0, "functionSource": "REGRESSION_TEST ( SDK_API_TSIOBufferReaderConsume ) ( RegressionTest * test , int , int * pstatus ) {\n bool test_passed = false ;\n * pstatus = REGRESSION_TEST_INPROGRESS ;\n TSIOBuffer bufp = TSIOBufferSizedCreate ( TS_IOBUFFER_SIZE_INDEX_4K ) ;\n TSIOBufferReader readerp = TSIOBufferReaderAlloc ( bufp ) ;\n TSIOBufferProduce ( bufp , 10 ) ;\n TSIOBufferReaderConsume ( readerp , 10 ) ;\n int64_t reader_avail = TSIOBufferReaderAvail ( readerp ) ;\n if ( reader_avail == 0 ) {\n SDK_RPRINT ( test , \"TSIOBufferReaderConsume\" , \"TestCase1\" , TC_PASS , \"ok\" ) ;\n test_passed = true ;\n }\n else {\n SDK_RPRINT ( test , \"TSIOBufferReaderConsume\" , \"TestCase1\" , TC_FAIL , \"failed\" ) ;\n }\n * pstatus = ( ( test_passed == true ) ? REGRESSION_TEST_PASSED : REGRESSION_TEST_FAILED ) ;\n return ;\n }", "idx": 1485}
{"hash": -2064332158282087279, "project": "debian", "size": 4, "label": 0, "functionSource": "bool i_stream_attachment_extractor_can_retry ( struct istream * input ) {\n struct attachment_istream * astream = ( struct attachment_istream * ) input -> real_stream ;\n return astream -> retry_read ;\n }", "idx": 1486}
{"hash": 4028820914612007011, "project": "chrome", "size": 58, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( SitePerProcessInteractiveBrowserTest , SequentialFocusNavigation ) {\n GURL main_url ( embedded_test_server ( ) -> GetURL ( \"a.com\" , \"/cross_site_iframe_factory.html?a(b,c)\" ) ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , main_url ) ;\n content : : WebContents * web_contents = browser ( ) -> tab_strip_model ( ) -> GetActiveWebContents ( ) ;\n content : : RenderFrameHost * main_frame = web_contents -> GetMainFrame ( ) ;\n content : : RenderFrameHost * child1 = ChildFrameAt ( main_frame , 0 ) ;\n ASSERT_NE ( nullptr , child1 ) ;\n content : : RenderFrameHost * child2 = ChildFrameAt ( main_frame , 1 ) ;\n ASSERT_NE ( nullptr , child2 ) ;\n EXPECT_TRUE ( ExecuteScript ( main_frame , \"window.name = 'root';\n\" ) ) ;\n EXPECT_TRUE ( ExecuteScript ( child1 , \"window.name = 'child1';\n\" ) ) ;\n EXPECT_TRUE ( ExecuteScript ( child2 , \"window.name = 'child2';\n\" ) ) ;\n std : : string script = \"function onFocus(e) {\n\" \" domAutomationController.setAutomationId(0);\n\" \" domAutomationController.send(window.name + '-focused-' + e.target.id);\n\" \"}\n\" \"var input1 = document.createElement('input');\n\" \"input1.id = 'input1';\n\" \"var input2 = document.createElement('input');\n\" \"input2.id = 'input2';\n\" \"document.body.insertBefore(input1, document.body.firstChild);\n\" \"document.body.appendChild(input2);\n\" \"input1.addEventListener('focus', onFocus, false);\n\" \"input2.addEventListener('focus', onFocus, false);\n\" ;\n EXPECT_TRUE ( ExecuteScript ( main_frame , script ) ) ;\n EXPECT_TRUE ( ExecuteScript ( child1 , script ) ) ;\n EXPECT_TRUE ( ExecuteScript ( child2 , script ) ) ;\n auto press_tab_and_wait_for_message = [ web_contents ] ( bool reverse ) {\n content : : DOMMessageQueue msg_queue ;\n std : : string reply ;\n SimulateKeyPress ( web_contents , ui : : DomKey : : TAB , ui : : DomCode : : TAB , ui : : VKEY_TAB , false , reverse , false , false ) ;\n EXPECT_TRUE ( msg_queue . WaitForMessage ( & reply ) ) ;\n return reply ;\n }\n ;\n EXPECT_EQ ( \"\\\"root-focused-input1\\\"\" , press_tab_and_wait_for_message ( false ) ) ;\n EXPECT_EQ ( main_frame , web_contents -> GetFocusedFrame ( ) ) ;\n EXPECT_EQ ( \"\\\"child1-focused-input1\\\"\" , press_tab_and_wait_for_message ( false ) ) ;\n EXPECT_EQ ( child1 , web_contents -> GetFocusedFrame ( ) ) ;\n EXPECT_EQ ( \"\\\"child1-focused-input2\\\"\" , press_tab_and_wait_for_message ( false ) ) ;\n EXPECT_EQ ( \"\\\"child2-focused-input1\\\"\" , press_tab_and_wait_for_message ( false ) ) ;\n EXPECT_EQ ( child2 , web_contents -> GetFocusedFrame ( ) ) ;\n EXPECT_EQ ( \"\\\"child2-focused-input2\\\"\" , press_tab_and_wait_for_message ( false ) ) ;\n EXPECT_EQ ( \"\\\"root-focused-input2\\\"\" , press_tab_and_wait_for_message ( false ) ) ;\n EXPECT_EQ ( main_frame , web_contents -> GetFocusedFrame ( ) ) ;\n EXPECT_EQ ( \"\\\"child2-focused-input2\\\"\" , press_tab_and_wait_for_message ( true ) ) ;\n EXPECT_EQ ( child2 , web_contents -> GetFocusedFrame ( ) ) ;\n EXPECT_EQ ( \"\\\"child2-focused-input1\\\"\" , press_tab_and_wait_for_message ( true ) ) ;\n EXPECT_EQ ( \"\\\"child1-focused-input2\\\"\" , press_tab_and_wait_for_message ( true ) ) ;\n EXPECT_EQ ( child1 , web_contents -> GetFocusedFrame ( ) ) ;\n EXPECT_EQ ( \"\\\"child1-focused-input1\\\"\" , press_tab_and_wait_for_message ( true ) ) ;\n EXPECT_EQ ( \"\\\"root-focused-input1\\\"\" , press_tab_and_wait_for_message ( true ) ) ;\n EXPECT_EQ ( main_frame , web_contents -> GetFocusedFrame ( ) ) ;\n }", "idx": 1487}
{"hash": -454486177854888036, "project": "debian", "size": 99, "label": 1, "functionSource": "static int mss3_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n MSS3Context * c = avctx -> priv_data ;\n RangeCoder * acoder = & c -> coder ;\n GetByteContext gb ;\n uint8_t * dst [ 3 ] ;\n int dec_width , dec_height , dec_x , dec_y , quality , keyframe ;\n int x , y , i , mb_width , mb_height , blk_size , btype ;\n int ret ;\n if ( buf_size < HEADER_SIZE ) {\n av_log ( avctx , AV_LOG_ERROR , \"Frame should have at least %d bytes, got %d instead\\n\" , HEADER_SIZE , buf_size ) ;\n return AVERROR_INVALIDDATA ;\n }\n bytestream2_init ( & gb , buf , buf_size ) ;\n keyframe = bytestream2_get_be32 ( & gb ) ;\n if ( keyframe & ~ 0x301 ) {\n av_log ( avctx , AV_LOG_ERROR , \"Invalid frame type %X\\n\" , keyframe ) ;\n return AVERROR_INVALIDDATA ;\n }\n keyframe = ! ( keyframe & 1 ) ;\n bytestream2_skip ( & gb , 6 ) ;\n dec_x = bytestream2_get_be16 ( & gb ) ;\n dec_y = bytestream2_get_be16 ( & gb ) ;\n dec_width = bytestream2_get_be16 ( & gb ) ;\n dec_height = bytestream2_get_be16 ( & gb ) ;\n if ( dec_x + dec_width > avctx -> width || dec_y + dec_height > avctx -> height || ( dec_width | dec_height ) & 0xF ) {\n av_log ( avctx , AV_LOG_ERROR , \"Invalid frame dimensions %dx%d +%d,%d\\n\" , dec_width , dec_height , dec_x , dec_y ) ;\n return AVERROR_INVALIDDATA ;\n }\n bytestream2_skip ( & gb , 4 ) ;\n quality = bytestream2_get_byte ( & gb ) ;\n if ( quality < 1 || quality > 100 ) {\n av_log ( avctx , AV_LOG_ERROR , \"Invalid quality setting %d\\n\" , quality ) ;\n return AVERROR_INVALIDDATA ;\n }\n bytestream2_skip ( & gb , 4 ) ;\n if ( keyframe && ! bytestream2_get_bytes_left ( & gb ) ) {\n av_log ( avctx , AV_LOG_ERROR , \"Keyframe without data found\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( ! keyframe && c -> got_error ) return buf_size ;\n c -> got_error = 0 ;\n c -> pic . reference = 3 ;\n c -> pic . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE ;\n if ( ( ret = avctx -> reget_buffer ( avctx , & c -> pic ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"reget_buffer() failed\\n\" ) ;\n return ret ;\n }\n c -> pic . key_frame = keyframe ;\n c -> pic . pict_type = keyframe ? AV_PICTURE_TYPE_I : AV_PICTURE_TYPE_P ;\n if ( ! bytestream2_get_bytes_left ( & gb ) ) {\n * got_frame = 1 ;\n * ( AVFrame * ) data = c -> pic ;\n return buf_size ;\n }\n reset_coders ( c , quality ) ;\n rac_init ( acoder , buf + HEADER_SIZE , buf_size - HEADER_SIZE ) ;\n mb_width = dec_width >> 4 ;\n mb_height = dec_height >> 4 ;\n dst [ 0 ] = c -> pic . data [ 0 ] + dec_x + dec_y * c -> pic . linesize [ 0 ] ;\n dst [ 1 ] = c -> pic . data [ 1 ] + dec_x / 2 + ( dec_y / 2 ) * c -> pic . linesize [ 1 ] ;\n dst [ 2 ] = c -> pic . data [ 2 ] + dec_x / 2 + ( dec_y / 2 ) * c -> pic . linesize [ 2 ] ;\n for ( y = 0 ;\n y < mb_height ;\n y ++ ) {\n for ( x = 0 ;\n x < mb_width ;\n x ++ ) {\n for ( i = 0 ;\n i < 3 ;\n i ++ ) {\n blk_size = 8 << ! i ;\n btype = decode_block_type ( acoder , c -> btype + i ) ;\n switch ( btype ) {\n case FILL_BLOCK : decode_fill_block ( acoder , c -> fill_coder + i , dst [ i ] + x * blk_size , c -> pic . linesize [ i ] , blk_size ) ;\n break ;\n case IMAGE_BLOCK : decode_image_block ( acoder , c -> image_coder + i , dst [ i ] + x * blk_size , c -> pic . linesize [ i ] , blk_size ) ;\n break ;\n case DCT_BLOCK : decode_dct_block ( acoder , c -> dct_coder + i , dst [ i ] + x * blk_size , c -> pic . linesize [ i ] , blk_size , c -> dctblock , x , y ) ;\n break ;\n case HAAR_BLOCK : decode_haar_block ( acoder , c -> haar_coder + i , dst [ i ] + x * blk_size , c -> pic . linesize [ i ] , blk_size , c -> hblock ) ;\n break ;\n }\n if ( c -> got_error || acoder -> got_error ) {\n av_log ( avctx , AV_LOG_ERROR , \"Error decoding block %d,%d\\n\" , x , y ) ;\n c -> got_error = 1 ;\n return AVERROR_INVALIDDATA ;\n }\n }\n }\n dst [ 0 ] += c -> pic . linesize [ 0 ] * 16 ;\n dst [ 1 ] += c -> pic . linesize [ 1 ] * 8 ;\n dst [ 2 ] += c -> pic . linesize [ 2 ] * 8 ;\n }\n * got_frame = 1 ;\n * ( AVFrame * ) data = c -> pic ;\n return buf_size ;\n }", "idx": 1488}
{"hash": -5268859819325807498, "project": "debian", "size": 11, "label": 0, "functionSource": "static void deep_count_cancel ( NautilusDirectory * directory ) {\n if ( directory -> details -> deep_count_in_progress != NULL ) {\n g_assert ( NAUTILUS_IS_FILE ( directory -> details -> deep_count_file ) ) ;\n g_cancellable_cancel ( directory -> details -> deep_count_in_progress -> cancellable ) ;\n directory -> details -> deep_count_file -> details -> deep_counts_status = NAUTILUS_REQUEST_NOT_STARTED ;\n directory -> details -> deep_count_in_progress -> directory = NULL ;\n directory -> details -> deep_count_in_progress = NULL ;\n directory -> details -> deep_count_file = NULL ;\n async_job_end ( directory , \"deep count\" ) ;\n }\n }", "idx": 1489}
{"hash": -1270180049246846366, "project": "chrome", "size": 3, "label": 0, "functionSource": "hb_face_t * hb_face_get_empty ( void ) {\n return const_cast < hb_face_t * > ( & _hb_face_nil ) ;\n }", "idx": 1490}
{"hash": 313627013719508831, "project": "debian", "size": 3, "label": 0, "functionSource": "static inline size_t GetPixelMetacontentExtent ( const Image * restrict image ) {\n return ( image -> metacontent_extent ) ;\n }", "idx": 1491}
{"hash": -2492312952058578720, "project": "debian", "size": 19, "label": 0, "functionSource": "void jbig2_free_segment ( Jbig2Ctx * ctx , Jbig2Segment * segment ) {\n if ( segment -> referred_to_segments != NULL ) {\n jbig2_free ( ctx -> allocator , segment -> referred_to_segments ) ;\n }\n switch ( segment -> flags & 63 ) {\n case 0 : if ( segment -> result != NULL ) jbig2_sd_release ( ctx , ( Jbig2SymbolDict * ) segment -> result ) ;\n break ;\n case 4 : case 40 : if ( segment -> result != NULL ) jbig2_image_release ( ctx , ( Jbig2Image * ) segment -> result ) ;\n break ;\n case 16 : if ( segment -> result != NULL ) jbig2_hd_release ( ctx , ( Jbig2PatternDict * ) segment -> result ) ;\n break ;\n case 53 : if ( segment -> result != NULL ) jbig2_table_free ( ctx , ( Jbig2HuffmanParams * ) segment -> result ) ;\n break ;\n case 62 : if ( segment -> result != NULL ) jbig2_metadata_free ( ctx , ( Jbig2Metadata * ) segment -> result ) ;\n break ;\n default : break ;\n }\n jbig2_free ( ctx -> allocator , segment ) ;\n }", "idx": 1492}
{"hash": -8884965407551053630, "project": "debian", "size": 12, "label": 0, "functionSource": "bool input_DecoderIsEmpty ( decoder_t * p_dec ) {\n decoder_owner_sys_t * p_owner = p_dec -> p_owner ;\n assert ( ! p_owner -> b_waiting ) ;\n bool b_empty = block_FifoCount ( p_dec -> p_owner -> p_fifo ) <= 0 ;\n if ( b_empty ) {\n vlc_mutex_lock ( & p_owner -> lock ) ;\n if ( p_dec -> fmt_out . i_cat == VIDEO_ES && p_owner -> p_vout ) b_empty = vout_IsEmpty ( p_owner -> p_vout ) ;\n else if ( p_dec -> fmt_out . i_cat == AUDIO_ES && p_owner -> p_aout ) b_empty = aout_DecIsEmpty ( p_owner -> p_aout ) ;\n vlc_mutex_unlock ( & p_owner -> lock ) ;\n }\n return b_empty ;\n }", "idx": 1493}
{"hash": -305162769887579921, "project": "debian", "size": 86, "label": 1, "functionSource": "static int estimate_best_b_count ( MpegEncContext * s ) {\n AVCodec * codec = avcodec_find_encoder ( s -> avctx -> codec_id ) ;\n AVCodecContext * c = avcodec_alloc_context3 ( NULL ) ;\n AVFrame input [ FF_MAX_B_FRAMES + 2 ] ;\n const int scale = s -> avctx -> brd_scale ;\n int i , j , out_size , p_lambda , b_lambda , lambda2 ;\n int64_t best_rd = INT64_MAX ;\n int best_b_count = - 1 ;\n assert ( scale >= 0 && scale <= 3 ) ;\n p_lambda = s -> last_lambda_for [ AV_PICTURE_TYPE_P ] ;\n b_lambda = s -> last_lambda_for [ AV_PICTURE_TYPE_B ] ;\n if ( ! b_lambda ) b_lambda = p_lambda ;\n lambda2 = ( b_lambda * b_lambda + ( 1 << FF_LAMBDA_SHIFT ) / 2 ) >> FF_LAMBDA_SHIFT ;\n c -> width = s -> width >> scale ;\n c -> height = s -> height >> scale ;\n c -> flags = CODEC_FLAG_QSCALE | CODEC_FLAG_PSNR | CODEC_FLAG_INPUT_PRESERVED ;\n c -> flags |= s -> avctx -> flags & CODEC_FLAG_QPEL ;\n c -> mb_decision = s -> avctx -> mb_decision ;\n c -> me_cmp = s -> avctx -> me_cmp ;\n c -> mb_cmp = s -> avctx -> mb_cmp ;\n c -> me_sub_cmp = s -> avctx -> me_sub_cmp ;\n c -> pix_fmt = AV_PIX_FMT_YUV420P ;\n c -> time_base = s -> avctx -> time_base ;\n c -> max_b_frames = s -> max_b_frames ;\n if ( avcodec_open2 ( c , codec , NULL ) < 0 ) return - 1 ;\n for ( i = 0 ;\n i < s -> max_b_frames + 2 ;\n i ++ ) {\n int ysize = c -> width * c -> height ;\n int csize = ( c -> width / 2 ) * ( c -> height / 2 ) ;\n Picture pre_input , * pre_input_ptr = i ? s -> input_picture [ i - 1 ] : s -> next_picture_ptr ;\n avcodec_get_frame_defaults ( & input [ i ] ) ;\n input [ i ] . data [ 0 ] = av_malloc ( ysize + 2 * csize ) ;\n input [ i ] . data [ 1 ] = input [ i ] . data [ 0 ] + ysize ;\n input [ i ] . data [ 2 ] = input [ i ] . data [ 1 ] + csize ;\n input [ i ] . linesize [ 0 ] = c -> width ;\n input [ i ] . linesize [ 1 ] = input [ i ] . linesize [ 2 ] = c -> width / 2 ;\n if ( pre_input_ptr && ( ! i || s -> input_picture [ i - 1 ] ) ) {\n pre_input = * pre_input_ptr ;\n if ( pre_input . f . type != FF_BUFFER_TYPE_SHARED && i ) {\n pre_input . f . data [ 0 ] += INPLACE_OFFSET ;\n pre_input . f . data [ 1 ] += INPLACE_OFFSET ;\n pre_input . f . data [ 2 ] += INPLACE_OFFSET ;\n }\n s -> dsp . shrink [ scale ] ( input [ i ] . data [ 0 ] , input [ i ] . linesize [ 0 ] , pre_input . f . data [ 0 ] , pre_input . f . linesize [ 0 ] , c -> width , c -> height ) ;\n s -> dsp . shrink [ scale ] ( input [ i ] . data [ 1 ] , input [ i ] . linesize [ 1 ] , pre_input . f . data [ 1 ] , pre_input . f . linesize [ 1 ] , c -> width >> 1 , c -> height >> 1 ) ;\n s -> dsp . shrink [ scale ] ( input [ i ] . data [ 2 ] , input [ i ] . linesize [ 2 ] , pre_input . f . data [ 2 ] , pre_input . f . linesize [ 2 ] , c -> width >> 1 , c -> height >> 1 ) ;\n }\n }\n for ( j = 0 ;\n j < s -> max_b_frames + 1 ;\n j ++ ) {\n int64_t rd = 0 ;\n if ( ! s -> input_picture [ j ] ) break ;\n c -> error [ 0 ] = c -> error [ 1 ] = c -> error [ 2 ] = 0 ;\n input [ 0 ] . pict_type = AV_PICTURE_TYPE_I ;\n input [ 0 ] . quality = 1 * FF_QP2LAMBDA ;\n out_size = encode_frame ( c , & input [ 0 ] ) ;\n for ( i = 0 ;\n i < s -> max_b_frames + 1 ;\n i ++ ) {\n int is_p = i % ( j + 1 ) == j || i == s -> max_b_frames ;\n input [ i + 1 ] . pict_type = is_p ? AV_PICTURE_TYPE_P : AV_PICTURE_TYPE_B ;\n input [ i + 1 ] . quality = is_p ? p_lambda : b_lambda ;\n out_size = encode_frame ( c , & input [ i + 1 ] ) ;\n rd += ( out_size * lambda2 ) >> ( FF_LAMBDA_SHIFT - 3 ) ;\n }\n while ( out_size ) {\n out_size = encode_frame ( c , NULL ) ;\n rd += ( out_size * lambda2 ) >> ( FF_LAMBDA_SHIFT - 3 ) ;\n }\n rd += c -> error [ 0 ] + c -> error [ 1 ] + c -> error [ 2 ] ;\n if ( rd < best_rd ) {\n best_rd = rd ;\n best_b_count = j ;\n }\n }\n avcodec_close ( c ) ;\n av_freep ( & c ) ;\n for ( i = 0 ;\n i < s -> max_b_frames + 2 ;\n i ++ ) {\n av_freep ( & input [ i ] . data [ 0 ] ) ;\n }\n return best_b_count ;\n }", "idx": 1494}
{"hash": 1760449185745615462, "project": "debian", "size": 3, "label": 0, "functionSource": "TSReturnCode TSMgmtIntGet ( const char * var_name , TSMgmtInt * result ) {\n return RecGetRecordInt ( ( char * ) var_name , ( RecInt * ) result ) == REC_ERR_OKAY ? TS_SUCCESS : TS_ERROR ;\n }", "idx": 1495}
{"hash": -4555950263653671147, "project": "debian", "size": 26, "label": 0, "functionSource": "static PyObject * string_startswith ( PyStringObject * self , PyObject * args ) {\n Py_ssize_t start = 0 ;\n Py_ssize_t end = PY_SSIZE_T_MAX ;\n PyObject * subobj ;\n int result ;\n if ( ! stringlib_parse_args_finds ( \"startswith\" , args , & subobj , & start , & end ) ) return NULL ;\n if ( PyTuple_Check ( subobj ) ) {\n Py_ssize_t i ;\n for ( i = 0 ;\n i < PyTuple_GET_SIZE ( subobj ) ;\n i ++ ) {\n result = _string_tailmatch ( self , PyTuple_GET_ITEM ( subobj , i ) , start , end , - 1 ) ;\n if ( result == - 1 ) return NULL ;\n else if ( result ) {\n Py_RETURN_TRUE ;\n }\n }\n Py_RETURN_FALSE ;\n }\n result = _string_tailmatch ( self , subobj , start , end , - 1 ) ;\n if ( result == - 1 ) {\n if ( PyErr_ExceptionMatches ( PyExc_TypeError ) ) PyErr_Format ( PyExc_TypeError , \"startswith first arg must be str, \" \"unicode, or tuple, not %s\" , Py_TYPE ( subobj ) -> tp_name ) ;\n return NULL ;\n }\n else return PyBool_FromLong ( result ) ;\n }", "idx": 1496}
{"hash": -954364585377557207, "project": "debian", "size": 28, "label": 0, "functionSource": "static void postfilter ( AMRContext * p , float * lpc , float * buf_out ) {\n int i ;\n float * samples = p -> samples_in + LP_FILTER_ORDER ;\n float speech_gain = avpriv_scalarproduct_float_c ( samples , samples , AMR_SUBFRAME_SIZE ) ;\n float pole_out [ AMR_SUBFRAME_SIZE + LP_FILTER_ORDER ] ;\n const float * gamma_n , * gamma_d ;\n float lpc_n [ LP_FILTER_ORDER ] , lpc_d [ LP_FILTER_ORDER ] ;\n if ( p -> cur_frame_mode == MODE_12k2 || p -> cur_frame_mode == MODE_10k2 ) {\n gamma_n = ff_pow_0_7 ;\n gamma_d = ff_pow_0_75 ;\n }\n else {\n gamma_n = ff_pow_0_55 ;\n gamma_d = ff_pow_0_7 ;\n }\n for ( i = 0 ;\n i < LP_FILTER_ORDER ;\n i ++ ) {\n lpc_n [ i ] = lpc [ i ] * gamma_n [ i ] ;\n lpc_d [ i ] = lpc [ i ] * gamma_d [ i ] ;\n }\n memcpy ( pole_out , p -> postfilter_mem , sizeof ( float ) * LP_FILTER_ORDER ) ;\n ff_celp_lp_synthesis_filterf ( pole_out + LP_FILTER_ORDER , lpc_d , samples , AMR_SUBFRAME_SIZE , LP_FILTER_ORDER ) ;\n memcpy ( p -> postfilter_mem , pole_out + AMR_SUBFRAME_SIZE , sizeof ( float ) * LP_FILTER_ORDER ) ;\n ff_celp_lp_zero_synthesis_filterf ( buf_out , lpc_n , pole_out + LP_FILTER_ORDER , AMR_SUBFRAME_SIZE , LP_FILTER_ORDER ) ;\n ff_tilt_compensation ( & p -> tilt_mem , tilt_factor ( lpc_n , lpc_d ) , buf_out , AMR_SUBFRAME_SIZE ) ;\n ff_adaptive_gain_control ( buf_out , buf_out , speech_gain , AMR_SUBFRAME_SIZE , AMR_AGC_ALPHA , & p -> postfilter_agc ) ;\n }", "idx": 1497}
{"hash": 7549435794356072684, "project": "debian", "size": 6, "label": 0, "functionSource": "static VALUE ossl_asn1_class2sym ( int tc ) {\n if ( ( tc & V_ASN1_PRIVATE ) == V_ASN1_PRIVATE ) return sym_PRIVATE ;\n else if ( ( tc & V_ASN1_CONTEXT_SPECIFIC ) == V_ASN1_CONTEXT_SPECIFIC ) return sym_CONTEXT_SPECIFIC ;\n else if ( ( tc & V_ASN1_APPLICATION ) == V_ASN1_APPLICATION ) return sym_APPLICATION ;\n else return sym_UNIVERSAL ;\n }", "idx": 1498}
{"hash": -182831737838159094, "project": "chrome", "size": 11, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( ContentFaviconDriverTest , AssociateIconWithInitialPageDespiteLocationOverrideWithinPage ) {\n ASSERT_TRUE ( embedded_test_server ( ) -> Start ( ) ) ;\n GURL url = embedded_test_server ( ) -> GetURL ( \"/favicon/page_with_location_override_within_page.html\" ) ;\n GURL landing_url = embedded_test_server ( ) -> GetURL ( \"/favicon/page_with_location_override_within_page.html#foo\" ) ;\n PendingTaskWaiter waiter ( web_contents ( ) ) ;\n waiter . AlsoRequireUrl ( landing_url ) ;\n ui_test_utils : : NavigateToURLWithDisposition ( browser ( ) , url , WindowOpenDisposition : : CURRENT_TAB , ui_test_utils : : BROWSER_TEST_NONE ) ;\n waiter . Wait ( ) ;\n EXPECT_NE ( nullptr , GetFaviconForPageURL ( url , favicon_base : : IconType : : kFavicon ) . bitmap_data ) ;\n EXPECT_NE ( nullptr , GetFaviconForPageURL ( landing_url , favicon_base : : IconType : : kFavicon ) . bitmap_data ) ;\n }", "idx": 1499}
{"hash": -5615323818347734353, "project": "debian", "size": 19, "label": 0, "functionSource": "static int test_if_case_insensitive ( const char * dir_name ) {\n int result = 0 ;\n File file ;\n char buff [ FN_REFLEN ] , buff2 [ FN_REFLEN ] ;\n MY_STAT stat_info ;\n DBUG_ENTER ( \"test_if_case_insensitive\" ) ;\n fn_format ( buff , glob_hostname , dir_name , \".lower-test\" , MY_UNPACK_FILENAME | MY_REPLACE_EXT | MY_REPLACE_DIR ) ;\n fn_format ( buff2 , glob_hostname , dir_name , \".LOWER-TEST\" , MY_UNPACK_FILENAME | MY_REPLACE_EXT | MY_REPLACE_DIR ) ;\n mysql_file_delete ( key_file_casetest , buff2 , MYF ( 0 ) ) ;\n if ( ( file = mysql_file_create ( key_file_casetest , buff , 0666 , O_RDWR , MYF ( 0 ) ) ) < 0 ) {\n if ( ! opt_abort ) sql_print_warning ( \"Can't create test file %s\" , buff ) ;\n DBUG_RETURN ( - 1 ) ;\n }\n mysql_file_close ( file , MYF ( 0 ) ) ;\n if ( mysql_file_stat ( key_file_casetest , buff2 , & stat_info , MYF ( 0 ) ) ) result = 1 ;\n mysql_file_delete ( key_file_casetest , buff , MYF ( MY_WME ) ) ;\n DBUG_PRINT ( \"exit\" , ( \"result: %d\" , result ) ) ;\n DBUG_RETURN ( result ) ;\n }", "idx": 1500}
{"hash": -2648356651055439484, "project": "debian", "size": 12, "label": 0, "functionSource": "guint16 de_d_gb_call_ref ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len _U_ , gchar * add_string _U_ , int string_len _U_ ) {\n guint32 curr_offset = offset ;\n proto_tree_add_item ( tree , hf_gsm_a_group_call_reference , tvb , curr_offset , 4 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( tree , hf_gsm_a_service_flag , tvb , curr_offset , 4 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( tree , hf_gsm_a_af_acknowledgement , tvb , curr_offset , 4 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( tree , hf_gsm_a_call_priority , tvb , curr_offset , 4 , ENC_BIG_ENDIAN ) ;\n curr_offset += 4 ;\n proto_tree_add_item ( tree , hf_gsm_a_ciphering_info , tvb , curr_offset , 1 , ENC_NA ) ;\n proto_tree_add_bits_item ( tree , hf_gsm_a_spare_bits , tvb , ( curr_offset << 3 ) + 4 , 4 , ENC_BIG_ENDIAN ) ;\n curr_offset ++ ;\n return ( curr_offset - offset ) ;\n }", "idx": 1501}
{"hash": -281311800725760049, "project": "debian", "size": 38, "label": 0, "functionSource": "static int decode_channel ( TAKDecContext * s , int chan ) {\n AVCodecContext * avctx = s -> avctx ;\n GetBitContext * gb = & s -> gb ;\n int32_t * decoded = s -> decoded [ chan ] ;\n int left = s -> nb_samples - 1 ;\n int i , prev , ret , nb_subframes ;\n int subframe_len [ MAX_SUBFRAMES ] ;\n s -> sample_shift [ chan ] = get_bits_esc4 ( gb ) ;\n if ( s -> sample_shift [ chan ] >= avctx -> bits_per_coded_sample ) return AVERROR_INVALIDDATA ;\n * decoded ++ = get_sbits ( gb , avctx -> bits_per_coded_sample - s -> sample_shift [ chan ] ) ;\n s -> lpc_mode [ chan ] = get_bits ( gb , 2 ) ;\n nb_subframes = get_bits ( gb , 3 ) + 1 ;\n i = 0 ;\n if ( nb_subframes > 1 ) {\n if ( get_bits_left ( gb ) < ( nb_subframes - 1 ) * 6 ) return AVERROR_INVALIDDATA ;\n prev = 0 ;\n for ( ;\n i < nb_subframes - 1 ;\n i ++ ) {\n int subframe_end = get_bits ( gb , 6 ) * s -> subframe_scale ;\n if ( subframe_end <= prev ) return AVERROR_INVALIDDATA ;\n subframe_len [ i ] = subframe_end - prev ;\n left -= subframe_len [ i ] ;\n prev = subframe_end ;\n }\n if ( left <= 0 ) return AVERROR_INVALIDDATA ;\n }\n subframe_len [ i ] = left ;\n prev = 0 ;\n for ( i = 0 ;\n i < nb_subframes ;\n i ++ ) {\n if ( ( ret = decode_subframe ( s , decoded , subframe_len [ i ] , prev ) ) < 0 ) return ret ;\n decoded += subframe_len [ i ] ;\n prev = subframe_len [ i ] ;\n }\n return 0 ;\n }", "idx": 1502}
{"hash": -2607754285145856562, "project": "debian", "size": 16, "label": 0, "functionSource": "static int isoent_add_child_tail ( struct isoent * parent , struct isoent * child ) {\n if ( ! __archive_rb_tree_insert_node ( & ( parent -> rbtree ) , ( struct archive_rb_node * ) child ) ) return ( 0 ) ;\n child -> chnext = NULL ;\n * parent -> children . last = child ;\n parent -> children . last = & ( child -> chnext ) ;\n parent -> children . cnt ++ ;\n child -> parent = parent ;\n child -> drnext = NULL ;\n if ( child -> dir ) {\n * parent -> subdirs . last = child ;\n parent -> subdirs . last = & ( child -> drnext ) ;\n parent -> subdirs . cnt ++ ;\n child -> parent = parent ;\n }\n return ( 1 ) ;\n }", "idx": 1503}
{"hash": 8249698884422048746, "project": "chrome", "size": 29, "label": 0, "functionSource": "static uint16_t * encodeRunByte ( uint16_t * buffer , uint16_t * bufLimit , uint8_t value , int32_t length , uint8_t state [ ] , UErrorCode * status ) {\n if ( ! status || U_FAILURE ( * status ) ) {\n return NULL ;\n }\n if ( length < 4 ) {\n int32_t j = 0 ;\n for ( ;\n j < length ;\n ++ j ) {\n if ( value == ESCAPE_BYTE ) {\n buffer = appendEncodedByte ( buffer , bufLimit , ESCAPE_BYTE , state , status ) ;\n }\n buffer = appendEncodedByte ( buffer , bufLimit , value , state , status ) ;\n }\n }\n else {\n if ( length == ESCAPE_BYTE ) {\n if ( value == ESCAPE_BYTE ) {\n buffer = appendEncodedByte ( buffer , bufLimit , ESCAPE_BYTE , state , status ) ;\n }\n buffer = appendEncodedByte ( buffer , bufLimit , value , state , status ) ;\n -- length ;\n }\n buffer = appendEncodedByte ( buffer , bufLimit , ESCAPE_BYTE , state , status ) ;\n buffer = appendEncodedByte ( buffer , bufLimit , ( char ) length , state , status ) ;\n buffer = appendEncodedByte ( buffer , bufLimit , value , state , status ) ;\n }\n return buffer ;\n }", "idx": 1504}
{"hash": 1676654288894940649, "project": "debian", "size": 4, "label": 0, "functionSource": "static void cpw_usage ( const char * str ) {\n if ( str ) fprintf ( stderr , \"%s\\n\" , str ) ;\n fprintf ( stderr , _ ( \"usage: change_password [-randkey] [-keepold] \" \"[-e keysaltlist] [-pw password] principal\\n\" ) ) ;\n }", "idx": 1505}
{"hash": 1020583704101101585, "project": "chrome", "size": 3, "label": 0, "functionSource": "bool RegisterChromeDownloadDelegate ( JNIEnv * env ) {\n return RegisterNativesImpl ( env ) ;\n }", "idx": 1506}
{"hash": -3889154245145551951, "project": "debian", "size": 15, "label": 0, "functionSource": "static char * keep_pack ( const char * curr_index_name ) {\n static char name [ PATH_MAX ] ;\n static const char * keep_msg = \"fast-import\" ;\n int keep_fd ;\n keep_fd = odb_pack_keep ( name , sizeof ( name ) , pack_data -> sha1 ) ;\n if ( keep_fd < 0 ) die_errno ( \"cannot create keep file\" ) ;\n write_or_die ( keep_fd , keep_msg , strlen ( keep_msg ) ) ;\n if ( close ( keep_fd ) ) die_errno ( \"failed to write keep file\" ) ;\n snprintf ( name , sizeof ( name ) , \"%s/pack/pack-%s.pack\" , get_object_directory ( ) , sha1_to_hex ( pack_data -> sha1 ) ) ;\n if ( finalize_object_file ( pack_data -> pack_name , name ) ) die ( \"cannot store pack file\" ) ;\n snprintf ( name , sizeof ( name ) , \"%s/pack/pack-%s.idx\" , get_object_directory ( ) , sha1_to_hex ( pack_data -> sha1 ) ) ;\n if ( finalize_object_file ( curr_index_name , name ) ) die ( \"cannot store index file\" ) ;\n free ( ( void * ) curr_index_name ) ;\n return name ;\n }", "idx": 1507}
{"hash": 1312888211311686952, "project": "debian", "size": 5, "label": 0, "functionSource": "static lbmpdm_definition_field_t * lbmpdm_definition_field_find ( lbmpdm_definition_t * definition , guint32 id ) {\n lbmpdm_definition_field_t * entry = NULL ;\n entry = ( lbmpdm_definition_field_t * ) wmem_tree_lookup32 ( definition -> field_list , id ) ;\n return ( entry ) ;\n }", "idx": 1508}
{"hash": 3557739556029059195, "project": "chrome", "size": 13, "label": 0, "functionSource": "void vp9_sad ## m ## x ## n ## x ## k ## _c ( const uint8_t * src , int src_stride , const uint8_t * ref , int ref_stride , unsigned int * sads ) {\n int i ;\n for ( i = 0 ;\n i < k ;\n ++ i ) sads [ i ] = vp9_sad ## m ## x ## n ## _c ( src , src_stride , & ref [ i ] , ref_stride ) ;\n \\ }\n # define sadMxNx4D ( m , n ) void vp9_sad ## m ## x ## n ## x4d_c ( const uint8_t * src , int src_stride , const uint8_t * const refs [ ] , int ref_stride , unsigned int * sads ) {\n int i ;\n for ( i = 0 ;\n i < 4 ;\n ++ i ) sads [ i ] = vp9_sad ## m ## x ## n ## _c ( src , src_stride , refs [ i ] , ref_stride ) ;\n \\ }\n sadMxN ( 64 , 64 ) sadMxNxK ( 64 , 64 , 3 ) sadMxNxK ( 64 , 64 , 8 ) sadMxNx4D ( 64 , 64 ) sadMxN ( 64 , 32 ) sadMxNx4D ( 64 , 32 ) sadMxN ( 32 , 64 ) sadMxNx4D ( 32 , 64 ) sadMxN ( 32 , 32 ) sadMxNxK ( 32 , 32 , 3 ) sadMxNxK ( 32 , 32 , 8 )", "idx": 1509}
{"hash": 2064081176034684128, "project": "debian", "size": 12, "label": 0, "functionSource": "static int ebml_level_end ( MatroskaDemuxContext * matroska ) {\n AVIOContext * pb = matroska -> ctx -> pb ;\n int64_t pos = avio_tell ( pb ) ;\n if ( matroska -> num_levels > 0 ) {\n MatroskaLevel * level = & matroska -> levels [ matroska -> num_levels - 1 ] ;\n if ( pos - level -> start >= level -> length || matroska -> current_id ) {\n matroska -> num_levels -- ;\n return 1 ;\n }\n }\n return 0 ;\n }", "idx": 1510}
{"hash": 561876472800374387, "project": "debian", "size": 10, "label": 0, "functionSource": "int RECORD_LAYER_set_data ( RECORD_LAYER * rl , const unsigned char * buf , int len ) {\n rl -> packet_length = len ;\n if ( len != 0 ) {\n rl -> rstate = SSL_ST_READ_HEADER ;\n if ( ! SSL3_BUFFER_is_initialised ( & rl -> rbuf ) ) if ( ! ssl3_setup_read_buffer ( rl -> s ) ) return 0 ;\n }\n rl -> packet = SSL3_BUFFER_get_buf ( & rl -> rbuf ) ;\n SSL3_BUFFER_set_data ( & rl -> rbuf , buf , len ) ;\n return 1 ;\n }", "idx": 1511}
{"hash": -3559021711340554904, "project": "debian", "size": 3, "label": 0, "functionSource": "static bool contain_leaked_vars_checker ( Oid func_id , void * context ) {\n return ! get_func_leakproof ( func_id ) ;\n }", "idx": 1512}
{"hash": 4489017523191997023, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h225_H248PackagesDescriptor ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_octet_string ( tvb , offset , actx , tree , hf_index , NO_BOUND , NO_BOUND , FALSE , NULL ) ;\n return offset ;\n }", "idx": 1513}
{"hash": 8849962823026424130, "project": "debian", "size": 11, "label": 0, "functionSource": "static const char * qio_channel_websock_find_header ( QIOChannelWebsockHTTPHeader * hdrs , size_t nhdrs , const char * name ) {\n size_t i ;\n for ( i = 0 ;\n i < nhdrs ;\n i ++ ) {\n if ( g_str_equal ( hdrs [ i ] . name , name ) ) {\n return hdrs [ i ] . value ;\n }\n }\n return NULL ;\n }", "idx": 1514}
{"hash": 3599206110384554647, "project": "debian", "size": 22, "label": 0, "functionSource": "static ossl_inline void lh_ ## type ## _node_stats_bio ( const LHASH_OF ( type ) * lh , BIO * out ) {\n OPENSSL_LH_node_stats_bio ( ( const OPENSSL_LHASH * ) lh , out ) ;\n }\n static ossl_inline void lh_ ## type ## _node_usage_stats_bio ( const LHASH_OF ( type ) * lh , BIO * out ) {\n OPENSSL_LH_node_usage_stats_bio ( ( const OPENSSL_LHASH * ) lh , out ) ;\n }\n static ossl_inline void lh_ ## type ## _stats_bio ( const LHASH_OF ( type ) * lh , BIO * out ) {\n OPENSSL_LH_stats_bio ( ( const OPENSSL_LHASH * ) lh , out ) ;\n }\n static ossl_inline unsigned long lh_ ## type ## _get_down_load ( LHASH_OF ( type ) * lh ) {\n return OPENSSL_LH_get_down_load ( ( OPENSSL_LHASH * ) lh ) ;\n }\n static ossl_inline void lh_ ## type ## _set_down_load ( LHASH_OF ( type ) * lh , unsigned long dl ) {\n OPENSSL_LH_set_down_load ( ( OPENSSL_LHASH * ) lh , dl ) ;\n }\n static ossl_inline void lh_ ## type ## _doall ( LHASH_OF ( type ) * lh , void ( * doall ) ( type * ) ) {\n OPENSSL_LH_doall ( ( OPENSSL_LHASH * ) lh , ( OPENSSL_LH_DOALL_FUNC ) doall ) ;\n }\n LHASH_OF ( type ) # define IMPLEMENT_LHASH_DOALL_ARG_CONST ( type , argtype ) int_implement_lhash_doall ( type , argtype , const type ) # define IMPLEMENT_LHASH_DOALL_ARG ( type , argtype ) int_implement_lhash_doall ( type , argtype , type ) # define int_implement_lhash_doall ( type , argtype , cbargtype ) static ossl_inline void lh_ ## type ## _doall_ ## argtype ( LHASH_OF ( type ) * lh , void ( * fn ) ( cbargtype * , argtype * ) , argtype * arg ) {\n OPENSSL_LH_doall_arg ( ( OPENSSL_LHASH * ) lh , ( OPENSSL_LH_DOALL_FUNCARG ) fn , ( void * ) arg ) ;\n }\n LHASH_OF ( type ) DEFINE_LHASH_OF ( OPENSSL_STRING )", "idx": 1515}
{"hash": -3725939782329394029, "project": "debian", "size": 29, "label": 0, "functionSource": "TIFF * TIFFOpen ( const char * name , const char * mode ) {\n static const char module [ ] = \"TIFFOpen\" ;\n thandle_t fd ;\n int m ;\n DWORD dwMode ;\n TIFF * tif ;\n m = _TIFFgetMode ( mode , module ) ;\n switch ( m ) {\n case O_RDONLY : dwMode = OPEN_EXISTING ;\n break ;\n case O_RDWR : dwMode = OPEN_ALWAYS ;\n break ;\n case O_RDWR | O_CREAT : dwMode = OPEN_ALWAYS ;\n break ;\n case O_RDWR | O_TRUNC : dwMode = CREATE_ALWAYS ;\n break ;\n case O_RDWR | O_CREAT | O_TRUNC : dwMode = CREATE_ALWAYS ;\n break ;\n default : return ( ( TIFF * ) 0 ) ;\n }\n fd = ( thandle_t ) CreateFileA ( name , ( m == O_RDONLY ) ? GENERIC_READ : ( GENERIC_READ | GENERIC_WRITE ) , FILE_SHARE_READ | FILE_SHARE_WRITE , NULL , dwMode , ( m == O_RDONLY ) ? FILE_ATTRIBUTE_READONLY : FILE_ATTRIBUTE_NORMAL , NULL ) ;\n if ( fd == INVALID_HANDLE_VALUE ) {\n TIFFErrorExt ( 0 , module , \"%s: Cannot open\" , name ) ;\n return ( ( TIFF * ) 0 ) ;\n }\n tif = TIFFFdOpen ( ( int ) fd , name , mode ) ;\n if ( ! tif ) CloseHandle ( fd ) ;\n return tif ;\n }", "idx": 1516}
{"hash": 2335222688263906532, "project": "debian", "size": 89, "label": 0, "functionSource": "static int rv34_decode_inter_macroblock ( RV34DecContext * r , int8_t * intra_types ) {\n MpegEncContext * s = & r -> s ;\n GetBitContext * gb = & s -> gb ;\n uint8_t * dst = s -> dest [ 0 ] ;\n int16_t * ptr = s -> block [ 0 ] ;\n int mb_pos = s -> mb_x + s -> mb_y * s -> mb_stride ;\n int cbp , cbp2 ;\n int q_dc , q_ac , has_ac ;\n int i , j ;\n int dist ;\n memset ( r -> avail_cache , 0 , sizeof ( r -> avail_cache ) ) ;\n fill_rectangle ( r -> avail_cache + 6 , 2 , 2 , 4 , 1 , 4 ) ;\n dist = ( s -> mb_x - s -> resync_mb_x ) + ( s -> mb_y - s -> resync_mb_y ) * s -> mb_width ;\n if ( s -> mb_x && dist ) r -> avail_cache [ 5 ] = r -> avail_cache [ 9 ] = s -> current_picture_ptr -> mb_type [ mb_pos - 1 ] ;\n if ( dist >= s -> mb_width ) r -> avail_cache [ 2 ] = r -> avail_cache [ 3 ] = s -> current_picture_ptr -> mb_type [ mb_pos - s -> mb_stride ] ;\n if ( ( ( s -> mb_x + 1 ) < s -> mb_width ) && dist >= s -> mb_width - 1 ) r -> avail_cache [ 4 ] = s -> current_picture_ptr -> mb_type [ mb_pos - s -> mb_stride + 1 ] ;\n if ( s -> mb_x && dist > s -> mb_width ) r -> avail_cache [ 1 ] = s -> current_picture_ptr -> mb_type [ mb_pos - s -> mb_stride - 1 ] ;\n s -> qscale = r -> si . quant ;\n cbp = cbp2 = rv34_decode_inter_mb_header ( r , intra_types ) ;\n r -> cbp_luma [ mb_pos ] = cbp ;\n r -> cbp_chroma [ mb_pos ] = cbp >> 16 ;\n r -> deblock_coefs [ mb_pos ] = rv34_set_deblock_coef ( r ) | r -> cbp_luma [ mb_pos ] ;\n s -> current_picture_ptr -> qscale_table [ mb_pos ] = s -> qscale ;\n if ( cbp == - 1 ) return - 1 ;\n if ( IS_INTRA ( s -> current_picture_ptr -> mb_type [ mb_pos ] ) ) {\n if ( r -> is16 ) rv34_output_i16x16 ( r , intra_types , cbp ) ;\n else rv34_output_intra ( r , intra_types , cbp ) ;\n return 0 ;\n }\n if ( r -> is16 ) {\n LOCAL_ALIGNED_16 ( int16_t , block16 , [ 16 ] ) ;\n memset ( block16 , 0 , 16 * sizeof ( * block16 ) ) ;\n q_dc = rv34_qscale_tab [ r -> luma_dc_quant_p [ s -> qscale ] ] ;\n q_ac = rv34_qscale_tab [ s -> qscale ] ;\n if ( rv34_decode_block ( block16 , gb , r -> cur_vlcs , 3 , 0 , q_dc , q_dc , q_ac ) ) r -> rdsp . rv34_inv_transform ( block16 ) ;\n else r -> rdsp . rv34_inv_transform_dc ( block16 ) ;\n q_ac = rv34_qscale_tab [ s -> qscale ] ;\n for ( j = 0 ;\n j < 4 ;\n j ++ ) {\n for ( i = 0 ;\n i < 4 ;\n i ++ , cbp >>= 1 ) {\n int dc = block16 [ i + j * 4 ] ;\n if ( cbp & 1 ) {\n has_ac = rv34_decode_block ( ptr , gb , r -> cur_vlcs , r -> luma_vlc , 0 , q_ac , q_ac , q_ac ) ;\n }\n else has_ac = 0 ;\n if ( has_ac ) {\n ptr [ 0 ] = dc ;\n r -> rdsp . rv34_idct_add ( dst + 4 * i , s -> linesize , ptr ) ;\n }\n else r -> rdsp . rv34_idct_dc_add ( dst + 4 * i , s -> linesize , dc ) ;\n }\n dst += 4 * s -> linesize ;\n }\n r -> cur_vlcs = choose_vlc_set ( r -> si . quant , r -> si . vlc_set , 1 ) ;\n }\n else {\n q_ac = rv34_qscale_tab [ s -> qscale ] ;\n for ( j = 0 ;\n j < 4 ;\n j ++ ) {\n for ( i = 0 ;\n i < 4 ;\n i ++ , cbp >>= 1 ) {\n if ( ! ( cbp & 1 ) ) continue ;\n rv34_process_block ( r , dst + 4 * i , s -> linesize , r -> luma_vlc , 0 , q_ac , q_ac ) ;\n }\n dst += 4 * s -> linesize ;\n }\n }\n q_dc = rv34_qscale_tab [ rv34_chroma_quant [ 1 ] [ s -> qscale ] ] ;\n q_ac = rv34_qscale_tab [ rv34_chroma_quant [ 0 ] [ s -> qscale ] ] ;\n for ( j = 1 ;\n j < 3 ;\n j ++ ) {\n dst = s -> dest [ j ] ;\n for ( i = 0 ;\n i < 4 ;\n i ++ , cbp >>= 1 ) {\n uint8_t * pdst ;\n if ( ! ( cbp & 1 ) ) continue ;\n pdst = dst + ( i & 1 ) * 4 + ( i & 2 ) * 2 * s -> uvlinesize ;\n rv34_process_block ( r , pdst , s -> uvlinesize , r -> chroma_vlc , 1 , q_dc , q_ac ) ;\n }\n }\n return 0 ;\n }", "idx": 1517}
{"hash": 1182028467273264883, "project": "debian", "size": 24, "label": 0, "functionSource": "void read_until_delimiter ( DYNAMIC_STRING * ds , DYNAMIC_STRING * ds_delimiter ) {\n char c ;\n DBUG_ENTER ( \"read_until_delimiter\" ) ;\n DBUG_PRINT ( \"enter\" , ( \"delimiter: %s, length: %u\" , ds_delimiter -> str , ( uint ) ds_delimiter -> length ) ) ;\n if ( ds_delimiter -> length > MAX_DELIMITER_LENGTH ) die ( \"Max delimiter length(%d) exceeded\" , MAX_DELIMITER_LENGTH ) ;\n while ( 1 ) {\n c = my_getc ( cur_file -> file ) ;\n if ( c == '\\n' ) {\n cur_file -> lineno ++ ;\n if ( start_lineno == ( cur_file -> lineno - 1 ) ) continue ;\n }\n else if ( start_lineno == cur_file -> lineno ) {\n report_or_die ( \"Trailing characters found after command\" ) ;\n }\n if ( feof ( cur_file -> file ) ) report_or_die ( \"End of file encountered before '%s' delimiter was found\" , ds_delimiter -> str ) ;\n if ( match_delimiter ( c , ds_delimiter -> str , ds_delimiter -> length ) ) {\n DBUG_PRINT ( \"exit\" , ( \"Found delimiter '%s'\" , ds_delimiter -> str ) ) ;\n break ;\n }\n dynstr_append_mem ( ds , ( const char * ) & c , 1 ) ;\n }\n DBUG_PRINT ( \"exit\" , ( \"ds: %s\" , ds -> str ) ) ;\n DBUG_VOID_RETURN ;\n }", "idx": 1518}
{"hash": 2596034467382468697, "project": "debian", "size": 86, "label": 0, "functionSource": "static int avs_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n const uint8_t * buf_end = avpkt -> data + avpkt -> size ;\n int buf_size = avpkt -> size ;\n AvsContext * const avs = avctx -> priv_data ;\n AVFrame * picture = data ;\n AVFrame * const p = & avs -> picture ;\n const uint8_t * table , * vect ;\n uint8_t * out ;\n int i , j , x , y , stride , ret , vect_w = 3 , vect_h = 3 ;\n AvsVideoSubType sub_type ;\n AvsBlockType type ;\n GetBitContext change_map ;\n if ( ( ret = ff_reget_buffer ( avctx , p ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"reget_buffer() failed\\n\" ) ;\n return ret ;\n }\n p -> pict_type = AV_PICTURE_TYPE_P ;\n p -> key_frame = 0 ;\n out = avs -> picture . data [ 0 ] ;\n stride = avs -> picture . linesize [ 0 ] ;\n if ( buf_end - buf < 4 ) return AVERROR_INVALIDDATA ;\n sub_type = buf [ 0 ] ;\n type = buf [ 1 ] ;\n buf += 4 ;\n if ( type == AVS_PALETTE ) {\n int first , last ;\n uint32_t * pal = ( uint32_t * ) avs -> picture . data [ 1 ] ;\n first = AV_RL16 ( buf ) ;\n last = first + AV_RL16 ( buf + 2 ) ;\n if ( first >= 256 || last > 256 || buf_end - buf < 4 + 4 + 3 * ( last - first ) ) return AVERROR_INVALIDDATA ;\n buf += 4 ;\n for ( i = first ;\n i < last ;\n i ++ , buf += 3 ) pal [ i ] = ( buf [ 0 ] << 18 ) | ( buf [ 1 ] << 10 ) | ( buf [ 2 ] << 2 ) ;\n sub_type = buf [ 0 ] ;\n type = buf [ 1 ] ;\n buf += 4 ;\n }\n if ( type != AVS_VIDEO ) return AVERROR_INVALIDDATA ;\n switch ( sub_type ) {\n case AVS_I_FRAME : p -> pict_type = AV_PICTURE_TYPE_I ;\n p -> key_frame = 1 ;\n case AVS_P_FRAME_3X3 : vect_w = 3 ;\n vect_h = 3 ;\n break ;\n case AVS_P_FRAME_2X2 : vect_w = 2 ;\n vect_h = 2 ;\n break ;\n case AVS_P_FRAME_2X3 : vect_w = 2 ;\n vect_h = 3 ;\n break ;\n default : return AVERROR_INVALIDDATA ;\n }\n if ( buf_end - buf < 256 * vect_w * vect_h ) return AVERROR_INVALIDDATA ;\n table = buf + ( 256 * vect_w * vect_h ) ;\n if ( sub_type != AVS_I_FRAME ) {\n int map_size = ( ( 318 / vect_w + 7 ) / 8 ) * ( 198 / vect_h ) ;\n if ( buf_end - table < map_size ) return AVERROR_INVALIDDATA ;\n init_get_bits ( & change_map , table , map_size * 8 ) ;\n table += map_size ;\n }\n for ( y = 0 ;\n y < 198 ;\n y += vect_h ) {\n for ( x = 0 ;\n x < 318 ;\n x += vect_w ) {\n if ( sub_type == AVS_I_FRAME || get_bits1 ( & change_map ) ) {\n if ( buf_end - table < 1 ) return AVERROR_INVALIDDATA ;\n vect = & buf [ * table ++ * ( vect_w * vect_h ) ] ;\n for ( j = 0 ;\n j < vect_w ;\n j ++ ) {\n out [ ( y + 0 ) * stride + x + j ] = vect [ ( 0 * vect_w ) + j ] ;\n out [ ( y + 1 ) * stride + x + j ] = vect [ ( 1 * vect_w ) + j ] ;\n if ( vect_h == 3 ) out [ ( y + 2 ) * stride + x + j ] = vect [ ( 2 * vect_w ) + j ] ;\n }\n }\n }\n if ( sub_type != AVS_I_FRAME ) align_get_bits ( & change_map ) ;\n }\n if ( ( ret = av_frame_ref ( picture , & avs -> picture ) ) < 0 ) return ret ;\n * got_frame = 1 ;\n return buf_size ;\n }", "idx": 1519}
{"hash": -6333668321124139371, "project": "debian", "size": 3, "label": 0, "functionSource": "void rtp_add_address ( packet_info * pinfo , address * addr , int port , int other_port , const gchar * setup_method , guint32 setup_frame_number , gboolean is_video , rtp_dyn_payload_t * rtp_dyn_payload ) {\n srtp_add_address ( pinfo , addr , port , other_port , setup_method , setup_frame_number , is_video , rtp_dyn_payload , NULL ) ;\n }", "idx": 1520}
{"hash": 3599206110384554647, "project": "debian", "size": 30, "label": 1, "functionSource": "static ossl_inline int sk_ ## t1 ## _insert ( STACK_OF ( t1 ) * sk , t2 * ptr , int idx ) {\n return OPENSSL_sk_insert ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr , idx ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _set ( STACK_OF ( t1 ) * sk , int idx , t2 * ptr ) {\n return ( t2 * ) OPENSSL_sk_set ( ( OPENSSL_STACK * ) sk , idx , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _find ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_find ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _find_ex ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_find_ex ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline void sk_ ## t1 ## _sort ( STACK_OF ( t1 ) * sk ) {\n OPENSSL_sk_sort ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline int sk_ ## t1 ## _is_sorted ( const STACK_OF ( t1 ) * sk ) {\n return OPENSSL_sk_is_sorted ( ( const OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _dup ( const STACK_OF ( t1 ) * sk ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_dup ( ( const OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _deep_copy ( const STACK_OF ( t1 ) * sk , sk_ ## t1 ## _copyfunc copyfunc , sk_ ## t1 ## _freefunc freefunc ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_deep_copy ( ( const OPENSSL_STACK * ) sk , ( OPENSSL_sk_copyfunc ) copyfunc , ( OPENSSL_sk_freefunc ) freefunc ) ;\n }\n static ossl_inline sk_ ## t1 ## _compfunc sk_ ## t1 ## _set_cmp_func ( STACK_OF ( t1 ) * sk , sk_ ## t1 ## _compfunc compare ) {\n return ( sk_ ## t1 ## _compfunc ) OPENSSL_sk_set_cmp_func ( ( OPENSSL_STACK * ) sk , ( OPENSSL_sk_compfunc ) compare ) ;\n }\n # define DEFINE_SPECIAL_STACK_OF ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , t2 , t2 ) # define DEFINE_STACK_OF ( t ) SKM_DEFINE_STACK_OF ( t , t , t ) # define DEFINE_SPECIAL_STACK_OF_CONST ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , const t2 , t2 ) # define DEFINE_STACK_OF_CONST ( t ) SKM_DEFINE_STACK_OF ( t , const t , t ) typedef char * OPENSSL_STRING ;\n typedef const char * OPENSSL_CSTRING ;\n DEFINE_SPECIAL_STACK_OF ( OPENSSL_STRING , char ) DEFINE_SPECIAL_STACK_OF_CONST ( OPENSSL_CSTRING , char )", "idx": 1521}
{"hash": 1760449185745615462, "project": "debian", "size": 3, "label": 0, "functionSource": "const char * TSUrlHttpParamsGet ( TSMBuffer bufp , TSMLoc obj , int * length ) {\n return URLPartGet ( bufp , obj , length , & URL : : params_get ) ;\n }", "idx": 1522}
{"hash": -4106680724983638989, "project": "chrome", "size": 7, "label": 1, "functionSource": "static void aacsbr_func_ptr_init ( AACSBRContext * c ) {\n c -> sbr_lf_gen = sbr_lf_gen ;\n c -> sbr_hf_assemble = sbr_hf_assemble ;\n c -> sbr_x_gen = sbr_x_gen ;\n c -> sbr_hf_inverse_filter = sbr_hf_inverse_filter ;\n if ( ARCH_MIPS ) ff_aacsbr_func_ptr_init_mips ( c ) ;\n }", "idx": 1523}
{"hash": 1208165234047591297, "project": "debian", "size": 140, "label": 1, "functionSource": "void parseVariant ( proto_tree * tree , tvbuff_t * tvb , packet_info * pinfo , gint * pOffset , const char * szFieldName ) {\n proto_item * ti ;\n proto_tree * subtree = proto_tree_add_subtree_format ( tree , tvb , * pOffset , - 1 , ett_opcua_variant , & ti , \"%s: Variant\" , szFieldName ) ;\n gint iOffset = * pOffset ;\n guint8 EncodingMask ;\n gint32 ArrayDimensions = 0 ;\n EncodingMask = tvb_get_guint8 ( tvb , iOffset ) ;\n proto_tree_add_item ( subtree , hf_opcua_variant_encodingmask , tvb , iOffset , 1 , ENC_LITTLE_ENDIAN ) ;\n iOffset ++ ;\n if ( EncodingMask & VARIANT_ARRAYMASK ) {\n switch ( EncodingMask & 0x3f ) {\n case OpcUaType_Null : break ;\n case OpcUaType_Boolean : parseArraySimple ( subtree , tvb , pinfo , & iOffset , \"Boolean\" , \"Boolean\" , hf_opcua_Boolean , parseBoolean , ett_opcua_array_Boolean ) ;\n break ;\n case OpcUaType_SByte : parseArraySimple ( subtree , tvb , pinfo , & iOffset , \"SByte\" , \"SByte\" , hf_opcua_SByte , parseSByte , ett_opcua_array_SByte ) ;\n break ;\n case OpcUaType_Byte : parseArraySimple ( subtree , tvb , pinfo , & iOffset , \"Byte\" , \"Byte\" , hf_opcua_Byte , parseByte , ett_opcua_array_Byte ) ;\n break ;\n case OpcUaType_Int16 : parseArraySimple ( subtree , tvb , pinfo , & iOffset , \"Int16\" , \"Int16\" , hf_opcua_Int16 , parseInt16 , ett_opcua_array_Int16 ) ;\n break ;\n case OpcUaType_UInt16 : parseArraySimple ( subtree , tvb , pinfo , & iOffset , \"UInt16\" , \"UInt16\" , hf_opcua_UInt16 , parseUInt16 , ett_opcua_array_UInt16 ) ;\n break ;\n case OpcUaType_Int32 : parseArraySimple ( subtree , tvb , pinfo , & iOffset , \"Int32\" , \"Int32\" , hf_opcua_Int32 , parseInt32 , ett_opcua_array_Int32 ) ;\n break ;\n case OpcUaType_UInt32 : parseArraySimple ( subtree , tvb , pinfo , & iOffset , \"UInt32\" , \"UInt32\" , hf_opcua_UInt32 , parseUInt32 , ett_opcua_array_UInt32 ) ;\n break ;\n case OpcUaType_Int64 : parseArraySimple ( subtree , tvb , pinfo , & iOffset , \"Int64\" , \"Int64\" , hf_opcua_Int64 , parseInt64 , ett_opcua_array_Int64 ) ;\n break ;\n case OpcUaType_UInt64 : parseArraySimple ( subtree , tvb , pinfo , & iOffset , \"UInt64\" , \"UInt64\" , hf_opcua_UInt64 , parseUInt64 , ett_opcua_array_UInt64 ) ;\n break ;\n case OpcUaType_Float : parseArraySimple ( subtree , tvb , pinfo , & iOffset , \"Float\" , \"Float\" , hf_opcua_Float , parseFloat , ett_opcua_array_Float ) ;\n break ;\n case OpcUaType_Double : parseArraySimple ( subtree , tvb , pinfo , & iOffset , \"Double\" , \"Double\" , hf_opcua_Double , parseDouble , ett_opcua_array_Double ) ;\n break ;\n case OpcUaType_String : parseArraySimple ( subtree , tvb , pinfo , & iOffset , \"String\" , \"String\" , hf_opcua_String , parseString , ett_opcua_array_String ) ;\n break ;\n case OpcUaType_DateTime : parseArraySimple ( subtree , tvb , pinfo , & iOffset , \"DateTime\" , \"DateTime\" , hf_opcua_DateTime , parseDateTime , ett_opcua_array_DateTime ) ;\n break ;\n case OpcUaType_Guid : parseArraySimple ( subtree , tvb , pinfo , & iOffset , \"Guid\" , \"Guid\" , hf_opcua_Guid , parseGuid , ett_opcua_array_Guid ) ;\n break ;\n case OpcUaType_ByteString : parseArraySimple ( subtree , tvb , pinfo , & iOffset , \"ByteString\" , \"ByteString\" , hf_opcua_ByteString , parseByteString , ett_opcua_array_ByteString ) ;\n break ;\n case OpcUaType_XmlElement : parseArraySimple ( subtree , tvb , pinfo , & iOffset , \"XmlElement\" , \"XmlElement\" , hf_opcua_XmlElement , parseXmlElement , ett_opcua_array_XmlElement ) ;\n break ;\n case OpcUaType_NodeId : parseArrayComplex ( subtree , tvb , pinfo , & iOffset , \"NodeId\" , \"NodeId\" , parseNodeId , ett_opcua_array_NodeId ) ;\n break ;\n case OpcUaType_ExpandedNodeId : parseArrayComplex ( subtree , tvb , pinfo , & iOffset , \"ExpandedNodeId\" , \"ExpandedNodeId\" , parseExpandedNodeId , ett_opcua_array_ExpandedNodeId ) ;\n break ;\n case OpcUaType_StatusCode : parseArraySimple ( subtree , tvb , pinfo , & iOffset , \"StatusCode\" , \"StatusCode\" , hf_opcua_StatusCode , parseStatusCode , ett_opcua_array_StatusCode ) ;\n break ;\n case OpcUaType_DiagnosticInfo : parseArrayComplex ( subtree , tvb , pinfo , & iOffset , \"DiagnosticInfo\" , \"DiagnosticInfo\" , parseDiagnosticInfo , ett_opcua_array_DiagnosticInfo ) ;\n break ;\n case OpcUaType_QualifiedName : parseArrayComplex ( subtree , tvb , pinfo , & iOffset , \"QualifiedName\" , \"QualifiedName\" , parseQualifiedName , ett_opcua_array_QualifiedName ) ;\n break ;\n case OpcUaType_LocalizedText : parseArrayComplex ( subtree , tvb , pinfo , & iOffset , \"LocalizedText\" , \"LocalizedText\" , parseLocalizedText , ett_opcua_array_LocalizedText ) ;\n break ;\n case OpcUaType_ExtensionObject : parseArrayComplex ( subtree , tvb , pinfo , & iOffset , \"ExtensionObject\" , \"ExtensionObject\" , parseExtensionObject , ett_opcua_array_ExtensionObject ) ;\n break ;\n case OpcUaType_DataValue : parseArrayComplex ( subtree , tvb , pinfo , & iOffset , \"DataValue\" , \"DataValue\" , parseDataValue , ett_opcua_array_DataValue ) ;\n break ;\n case OpcUaType_Variant : parseArrayComplex ( subtree , tvb , pinfo , & iOffset , \"Variant\" , \"Variant\" , parseVariant , ett_opcua_array_Variant ) ;\n break ;\n }\n if ( EncodingMask & VARIANT_ARRAYDIMENSIONS ) {\n proto_item * ti_2 ;\n proto_tree * subtree_2 = proto_tree_add_subtree ( subtree , tvb , iOffset , - 1 , ett_opcua_variant_arraydims , & ti_2 , \"ArrayDimensions\" ) ;\n int i ;\n ArrayDimensions = tvb_get_letohl ( tvb , iOffset ) ;\n proto_tree_add_item ( subtree_2 , hf_opcua_ArraySize , tvb , iOffset , 4 , ENC_LITTLE_ENDIAN ) ;\n if ( ArrayDimensions > MAX_ARRAY_LEN ) {\n proto_tree_add_expert_format ( subtree_2 , pinfo , & ei_array_length , tvb , iOffset , 4 , \"ArrayDimensions length %d too large to process\" , ArrayDimensions ) ;\n return ;\n }\n iOffset += 4 ;\n for ( i = 0 ;\n i < ArrayDimensions ;\n i ++ ) {\n parseInt32 ( subtree_2 , tvb , pinfo , & iOffset , hf_opcua_Int32 ) ;\n }\n proto_item_set_end ( ti_2 , tvb , iOffset ) ;\n }\n }\n else {\n switch ( EncodingMask & 0x3f ) {\n case OpcUaType_Null : break ;\n case OpcUaType_Boolean : parseBoolean ( subtree , tvb , pinfo , & iOffset , hf_opcua_Boolean ) ;\n break ;\n case OpcUaType_SByte : parseSByte ( subtree , tvb , pinfo , & iOffset , hf_opcua_SByte ) ;\n break ;\n case OpcUaType_Byte : parseByte ( subtree , tvb , pinfo , & iOffset , hf_opcua_Byte ) ;\n break ;\n case OpcUaType_Int16 : parseInt16 ( subtree , tvb , pinfo , & iOffset , hf_opcua_Int16 ) ;\n break ;\n case OpcUaType_UInt16 : parseUInt16 ( subtree , tvb , pinfo , & iOffset , hf_opcua_UInt16 ) ;\n break ;\n case OpcUaType_Int32 : parseInt32 ( subtree , tvb , pinfo , & iOffset , hf_opcua_Int32 ) ;\n break ;\n case OpcUaType_UInt32 : parseUInt32 ( subtree , tvb , pinfo , & iOffset , hf_opcua_UInt32 ) ;\n break ;\n case OpcUaType_Int64 : parseInt64 ( subtree , tvb , pinfo , & iOffset , hf_opcua_Int64 ) ;\n break ;\n case OpcUaType_UInt64 : parseUInt64 ( subtree , tvb , pinfo , & iOffset , hf_opcua_UInt64 ) ;\n break ;\n case OpcUaType_Float : parseFloat ( subtree , tvb , pinfo , & iOffset , hf_opcua_Float ) ;\n break ;\n case OpcUaType_Double : parseDouble ( subtree , tvb , pinfo , & iOffset , hf_opcua_Double ) ;\n break ;\n case OpcUaType_String : parseString ( subtree , tvb , pinfo , & iOffset , hf_opcua_String ) ;\n break ;\n case OpcUaType_DateTime : parseDateTime ( subtree , tvb , pinfo , & iOffset , hf_opcua_DateTime ) ;\n break ;\n case OpcUaType_Guid : parseGuid ( subtree , tvb , pinfo , & iOffset , hf_opcua_Guid ) ;\n break ;\n case OpcUaType_ByteString : parseByteString ( subtree , tvb , pinfo , & iOffset , hf_opcua_ByteString ) ;\n break ;\n case OpcUaType_XmlElement : parseXmlElement ( subtree , tvb , pinfo , & iOffset , hf_opcua_XmlElement ) ;\n break ;\n case OpcUaType_NodeId : parseNodeId ( subtree , tvb , pinfo , & iOffset , \"Value\" ) ;\n break ;\n case OpcUaType_ExpandedNodeId : parseExpandedNodeId ( subtree , tvb , pinfo , & iOffset , \"Value\" ) ;\n break ;\n case OpcUaType_StatusCode : parseStatusCode ( subtree , tvb , pinfo , & iOffset , hf_opcua_StatusCode ) ;\n break ;\n case OpcUaType_DiagnosticInfo : parseDiagnosticInfo ( subtree , tvb , pinfo , & iOffset , \"Value\" ) ;\n break ;\n case OpcUaType_QualifiedName : parseQualifiedName ( subtree , tvb , pinfo , & iOffset , \"Value\" ) ;\n break ;\n case OpcUaType_LocalizedText : parseLocalizedText ( subtree , tvb , pinfo , & iOffset , \"Value\" ) ;\n break ;\n case OpcUaType_ExtensionObject : parseExtensionObject ( subtree , tvb , pinfo , & iOffset , \"Value\" ) ;\n break ;\n case OpcUaType_DataValue : parseDataValue ( subtree , tvb , pinfo , & iOffset , \"Value\" ) ;\n break ;\n case OpcUaType_Variant : parseVariant ( subtree , tvb , pinfo , & iOffset , \"Value\" ) ;\n break ;\n }\n }\n proto_item_set_end ( ti , tvb , iOffset ) ;\n * pOffset = iOffset ;\n }", "idx": 1524}
{"hash": 3584320764213684062, "project": "debian", "size": 23, "label": 0, "functionSource": "int parse_CNatLanguageRestriction ( tvbuff_t * tvb , int offset , proto_tree * parent_tree , proto_tree * pad_tree , struct CNatLanguageRestriction * v , const char * fmt , ... ) {\n proto_tree * tree ;\n proto_item * item ;\n va_list ap ;\n guint32 cc ;\n const char * txt ;\n va_start ( ap , fmt ) ;\n txt = wmem_strdup_vprintf ( wmem_packet_scope ( ) , fmt , ap ) ;\n va_end ( ap ) ;\n tree = proto_tree_add_subtree ( parent_tree , tvb , offset , 0 , ett_CNatLanguageRestriction , & item , txt ) ;\n offset = parse_CFullPropSpec ( tvb , offset , tree , pad_tree , & v -> property , \"Property\" ) ;\n offset = parse_padding ( tvb , offset , 4 , pad_tree , \"padding_cc\" ) ;\n cc = tvb_get_letohl ( tvb , offset ) ;\n proto_tree_add_uint ( tree , hf_mswsp_natlangrestrict_cc , tvb , offset , 4 , cc ) ;\n offset += 4 ;\n proto_tree_add_item_ret_string ( tree , hf_mswsp_natlangrestrict_phrase , tvb , offset , 2 * cc , ENC_LITTLE_ENDIAN | ENC_UCS_2 , wmem_packet_scope ( ) , & v -> phrase ) ;\n offset += 2 * cc ;\n offset = parse_padding ( tvb , offset , 4 , pad_tree , \"padding_lcid\" ) ;\n v -> lcid = tvb_get_letohl ( tvb , offset ) ;\n offset = parse_lcid ( tvb , offset , tree , \"lcid\" ) ;\n proto_item_set_end ( item , tvb , offset ) ;\n return offset ;\n }", "idx": 1525}
{"hash": 355220887711506893, "project": "debian", "size": 85, "label": 0, "functionSource": "void examine_variable ( PlannerInfo * root , Node * node , int varRelid , VariableStatData * vardata ) {\n Node * basenode ;\n Relids varnos ;\n RelOptInfo * onerel ;\n MemSet ( vardata , 0 , sizeof ( VariableStatData ) ) ;\n vardata -> vartype = exprType ( node ) ;\n if ( IsA ( node , RelabelType ) ) basenode = ( Node * ) ( ( RelabelType * ) node ) -> arg ;\n else basenode = node ;\n if ( IsA ( basenode , Var ) && ( varRelid == 0 || varRelid == ( ( Var * ) basenode ) -> varno ) ) {\n Var * var = ( Var * ) basenode ;\n vardata -> var = basenode ;\n vardata -> rel = find_base_rel ( root , var -> varno ) ;\n vardata -> atttype = var -> vartype ;\n vardata -> atttypmod = var -> vartypmod ;\n vardata -> isunique = has_unique_index ( vardata -> rel , var -> varattno ) ;\n examine_simple_variable ( root , var , vardata ) ;\n return ;\n }\n varnos = pull_varnos ( basenode ) ;\n onerel = NULL ;\n switch ( bms_membership ( varnos ) ) {\n case BMS_EMPTY_SET : break ;\n case BMS_SINGLETON : if ( varRelid == 0 || bms_is_member ( varRelid , varnos ) ) {\n onerel = find_base_rel ( root , ( varRelid ? varRelid : bms_singleton_member ( varnos ) ) ) ;\n vardata -> rel = onerel ;\n node = basenode ;\n }\n break ;\n case BMS_MULTIPLE : if ( varRelid == 0 ) {\n vardata -> rel = find_join_rel ( root , varnos ) ;\n node = basenode ;\n }\n else if ( bms_is_member ( varRelid , varnos ) ) {\n vardata -> rel = find_base_rel ( root , varRelid ) ;\n node = basenode ;\n }\n break ;\n }\n bms_free ( varnos ) ;\n vardata -> var = node ;\n vardata -> atttype = exprType ( node ) ;\n vardata -> atttypmod = exprTypmod ( node ) ;\n if ( onerel ) {\n ListCell * ilist ;\n foreach ( ilist , onerel -> indexlist ) {\n IndexOptInfo * index = ( IndexOptInfo * ) lfirst ( ilist ) ;\n ListCell * indexpr_item ;\n int pos ;\n indexpr_item = list_head ( index -> indexprs ) ;\n if ( indexpr_item == NULL ) continue ;\n for ( pos = 0 ;\n pos < index -> ncolumns ;\n pos ++ ) {\n if ( index -> indexkeys [ pos ] == 0 ) {\n Node * indexkey ;\n if ( indexpr_item == NULL ) elog ( ERROR , \"too few entries in indexprs list\" ) ;\n indexkey = ( Node * ) lfirst ( indexpr_item ) ;\n if ( indexkey && IsA ( indexkey , RelabelType ) ) indexkey = ( Node * ) ( ( RelabelType * ) indexkey ) -> arg ;\n if ( equal ( node , indexkey ) ) {\n if ( index -> unique && index -> ncolumns == 1 && ( index -> indpred == NIL || index -> predOK ) ) vardata -> isunique = true ;\n if ( get_index_stats_hook && ( * get_index_stats_hook ) ( root , index -> indexoid , pos + 1 , vardata ) ) {\n if ( HeapTupleIsValid ( vardata -> statsTuple ) && ! vardata -> freefunc ) elog ( ERROR , \"no function provided to release variable stats with\" ) ;\n }\n else if ( index -> indpred == NIL ) {\n vardata -> statsTuple = SearchSysCache3 ( STATRELATTINH , ObjectIdGetDatum ( index -> indexoid ) , Int16GetDatum ( pos + 1 ) , BoolGetDatum ( false ) ) ;\n vardata -> freefunc = ReleaseSysCache ;\n if ( HeapTupleIsValid ( vardata -> statsTuple ) ) {\n RangeTblEntry * rte ;\n rte = planner_rt_fetch ( index -> rel -> relid , root ) ;\n Assert ( rte -> rtekind == RTE_RELATION ) ;\n vardata -> acl_ok = ( pg_class_aclcheck ( rte -> relid , GetUserId ( ) , ACL_SELECT ) == ACLCHECK_OK ) ;\n }\n else {\n vardata -> acl_ok = true ;\n }\n }\n if ( vardata -> statsTuple ) break ;\n }\n indexpr_item = lnext ( indexpr_item ) ;\n }\n }\n if ( vardata -> statsTuple ) break ;\n }\n }\n }", "idx": 1526}
{"hash": 2687336064028423153, "project": "chrome", "size": 23, "label": 0, "functionSource": "static void request_finished ( struct request * const req , struct request * * head ) {\n if ( head ) {\n if ( req -> next == req ) {\n * head = NULL ;\n }\n else {\n req -> next -> prev = req -> prev ;\n req -> prev -> next = req -> next ;\n if ( * head == req ) * head = req -> next ;\n }\n }\n log ( EVDNS_LOG_DEBUG , \"Removing timeout for request %lx\" , ( unsigned long ) req ) ;\n evtimer_del ( & req -> timeout_event ) ;\n search_request_finished ( req ) ;\n global_requests_inflight -- ;\n if ( ! req -> request_appended ) {\n free ( req -> request ) ;\n }\n else {\n }\n free ( req ) ;\n evdns_requests_pump_waiting_queue ( ) ;\n }", "idx": 1527}
{"hash": -7777331401175181229, "project": "debian", "size": 17, "label": 0, "functionSource": "static void print_reconnects ( void ) {\n GSList * tmp ;\n char * tag , * next_connect ;\n int left ;\n for ( tmp = reconnects ;\n tmp != NULL ;\n tmp = tmp -> next ) {\n RECONNECT_REC * rec = tmp -> data ;\n SERVER_CONNECT_REC * conn = rec -> conn ;\n tag = g_strdup_printf ( \"RECON-%d\" , rec -> tag ) ;\n left = rec -> next_connect - time ( NULL ) ;\n next_connect = g_strdup_printf ( \"%02d:%02d\" , left / 60 , left % 60 ) ;\n printformat ( NULL , NULL , MSGLEVEL_CRAP , TXT_SERVER_RECONNECT_LIST , tag , conn -> address , conn -> port , conn -> chatnet == NULL ? \"\" : conn -> chatnet , conn -> nick , next_connect ) ;\n g_free ( next_connect ) ;\n g_free ( tag ) ;\n }\n }", "idx": 1528}
{"hash": 8895005875911486570, "project": "debian", "size": 13, "label": 0, "functionSource": "static void join_print_po ( struct packet_object * po ) {\n int ret ;\n if ( wdg_conndata == NULL || wdg_join == NULL ) return ;\n if ( ! ( wdg_conndata -> flags & WDG_OBJ_FOCUSED ) ) return ;\n if ( GBL_OPTIONS -> regex && regexec ( GBL_OPTIONS -> regex , ( const char * ) po -> DATA . disp_data , 0 , NULL , 0 ) != 0 ) {\n return ;\n }\n SAFE_REALLOC ( dispbuf , hex_len ( po -> DATA . disp_len ) * sizeof ( u_char ) + 1 ) ;\n ret = GBL_FORMAT ( po -> DATA . disp_data , po -> DATA . disp_len , dispbuf ) ;\n dispbuf [ ret ] = 0 ;\n if ( ! ip_addr_cmp ( & po -> L3 . src , & curr_conn -> L3_addr1 ) ) wdg_scroll_print ( wdg_join , EC_COLOR_JOIN1 , \"%s\" , dispbuf ) ;\n else wdg_scroll_print ( wdg_join , EC_COLOR_JOIN2 , \"%s\" , dispbuf ) ;\n }", "idx": 1529}
{"hash": -3740862514502467070, "project": "debian", "size": 83, "label": 0, "functionSource": "static void sethead ( struct head * head , SplineFont * sf , struct alltabs * at , enum fontformat format , int32 * bsizes ) {\n int i , lr , rl , indic_rearrange , arabic ;\n ASM * sm ;\n struct ttflangname * useng ;\n float vn ;\n if ( at -> gi . xmin == 15000 ) at -> gi . xmin = 0 ;\n if ( at -> gi . ymin == 15000 ) at -> gi . ymin = 0 ;\n if ( bsizes != NULL && format == ff_none ) {\n if ( sf -> ascent > at -> gi . ymax ) at -> gi . ymax = sf -> ascent ;\n if ( - sf -> descent < at -> gi . ymin ) at -> gi . ymin = - sf -> descent ;\n }\n head -> xmin = at -> gi . xmin ;\n head -> ymin = at -> gi . ymin ;\n head -> xmax = at -> gi . xmax ;\n head -> ymax = at -> gi . ymax ;\n lr = rl = arabic = 0 ;\n for ( i = 0 ;\n i < at -> gi . gcnt ;\n ++ i ) if ( at -> gi . bygid [ i ] != - 1 ) {\n SplineChar * sc = sf -> glyphs [ at -> gi . bygid [ i ] ] ;\n int uni = sc -> unicodeenc ;\n if ( SCRightToLeft ( sc ) ) rl = 1 ;\n else if ( ( uni != - 1 && uni < 0x10000 && islefttoright ( uni ) ) || ( uni >= 0x10300 && uni < 0x107ff ) ) lr = 1 ;\n if ( SCScriptFromUnicode ( sc ) == CHR ( 'a' , 'r' , 'a' , 'b' ) ) arabic = 1 ;\n }\n head -> version = 0x00010000 ;\n head -> revision = sf -> sfntRevision ;\n if ( sf -> sfntRevision == sfntRevisionUnset ) {\n head -> revision = 0x00010000 ;\n for ( useng = sf -> names ;\n useng != NULL ;\n useng = useng -> next ) if ( useng -> lang == 0x409 ) break ;\n if ( useng != NULL && useng -> names [ ttf_version ] != NULL && sscanf ( useng -> names [ ttf_version ] , \"Version %f\" , & vn ) == 1 ) {\n head -> revision = vn * 65536 ;\n }\n else if ( sf -> subfontcnt != 0 ) {\n int val , mant ;\n val = floor ( sf -> cidversion ) ;\n mant = floor ( 65536. * ( ( double ) sf -> cidversion - val ) ) ;\n head -> revision = ( val << 16 ) | mant ;\n }\n else if ( sf -> version != NULL ) {\n char * pt = sf -> version ;\n double dval ;\n int val , mant ;\n while ( * pt && ! isdigit ( * pt ) && * pt != '.' ) ++ pt ;\n if ( * pt ) {\n dval = strtod ( pt , NULL ) ;\n val = floor ( dval ) ;\n mant = floor ( 65536. * ( dval - val ) ) ;\n head -> revision = ( val << 16 ) | mant ;\n }\n }\n }\n head -> checksumAdj = 0 ;\n head -> magicNum = 0x5f0f3cf5 ;\n head -> flags = 8 | 2 | 1 ;\n if ( format >= ff_ttf && format <= ff_ttfdfont ) {\n if ( AnyInstructions ( sf ) ) head -> flags = 0x10 | 8 | 4 | 2 | 1 ;\n else if ( AnyMisleadingBitmapAdvances ( sf , bsizes ) ) head -> flags = 0x10 | 8 | 2 | 1 ;\n }\n if ( sf -> hasvmetrics ) head -> flags |= ( 1 << 5 ) ;\n if ( arabic ) head -> flags |= ( 1 << 7 ) ;\n if ( sf -> sm ) head -> flags |= ( 1 << 8 ) ;\n if ( rl ) head -> flags |= ( 1 << 9 ) ;\n indic_rearrange = 0 ;\n for ( sm = sf -> sm ;\n sm != NULL ;\n sm = sm -> next ) if ( sm -> type == asm_indic ) indic_rearrange = true ;\n if ( indic_rearrange ) head -> flags |= ( 1 << 10 ) ;\n if ( sf -> head_optimized_for_cleartype ) head -> flags |= ( 1 << 13 ) ;\n head -> emunits = sf -> ascent + sf -> descent ;\n head -> macstyle = MacStyleCode ( sf , NULL ) ;\n head -> lowestreadable = 8 ;\n head -> locais32 = 1 ;\n if ( at -> gi . glyph_len < 0x20000 ) head -> locais32 = 0 ;\n if ( lr && rl ) head -> dirhint = 0 ;\n else if ( rl ) head -> dirhint = - 2 ;\n else head -> dirhint = 2 ;\n if ( rl ) head -> flags |= ( 1 << 9 ) ;\n cvt_unix_to_1904 ( sf -> creationtime , head -> createtime ) ;\n cvt_unix_to_1904 ( sf -> modificationtime , head -> modtime ) ;\n }", "idx": 1530}
{"hash": -2607754285145856562, "project": "debian", "size": 30, "label": 0, "functionSource": "static int calculate_directory_descriptors ( struct iso9660 * iso9660 , struct vdd * vdd , struct isoent * isoent , int depth ) {\n struct isoent * * enttbl ;\n int bs , block , i ;\n block = 1 ;\n bs = get_dir_rec_size ( iso9660 , isoent , DIR_REC_SELF , vdd -> vdd_type ) ;\n bs += get_dir_rec_size ( iso9660 , isoent , DIR_REC_PARENT , vdd -> vdd_type ) ;\n if ( isoent -> children . cnt <= 0 || ( vdd -> vdd_type != VDD_JOLIET && ! iso9660 -> opt . rr && depth + 1 >= vdd -> max_depth ) ) return ( block ) ;\n enttbl = isoent -> children_sorted ;\n for ( i = 0 ;\n i < isoent -> children . cnt ;\n i ++ ) {\n struct isoent * np = enttbl [ i ] ;\n struct isofile * file ;\n file = np -> file ;\n if ( file -> hardlink_target != NULL ) file = file -> hardlink_target ;\n file -> cur_content = & ( file -> content ) ;\n do {\n int dr_l ;\n dr_l = get_dir_rec_size ( iso9660 , np , DIR_REC_NORMAL , vdd -> vdd_type ) ;\n if ( ( bs + dr_l ) > LOGICAL_BLOCK_SIZE ) {\n block ++ ;\n bs = dr_l ;\n }\n else bs += dr_l ;\n file -> cur_content = file -> cur_content -> next ;\n }\n while ( file -> cur_content != NULL ) ;\n }\n return ( block ) ;\n }", "idx": 1531}
{"hash": -5615323818347734353, "project": "debian", "size": 18, "label": 0, "functionSource": "static void start_signal_handler ( void ) {\n int error ;\n pthread_attr_t thr_attr ;\n DBUG_ENTER ( \"start_signal_handler\" ) ;\n ( void ) pthread_attr_init ( & thr_attr ) ;\n pthread_attr_setscope ( & thr_attr , PTHREAD_SCOPE_SYSTEM ) ;\n ( void ) pthread_attr_setdetachstate ( & thr_attr , PTHREAD_CREATE_DETACHED ) ;\n ( void ) my_setstacksize ( & thr_attr , my_thread_stack_size ) ;\n mysql_mutex_lock ( & LOCK_thread_count ) ;\n if ( ( error = mysql_thread_create ( key_thread_signal_hand , & signal_thread , & thr_attr , signal_hand , 0 ) ) ) {\n sql_print_error ( \"Can't create interrupt-thread (error %d, errno: %d)\" , error , errno ) ;\n exit ( 1 ) ;\n }\n mysql_cond_wait ( & COND_thread_count , & LOCK_thread_count ) ;\n mysql_mutex_unlock ( & LOCK_thread_count ) ;\n ( void ) pthread_attr_destroy ( & thr_attr ) ;\n DBUG_VOID_RETURN ;\n }", "idx": 1532}
{"hash": -5557764516885008080, "project": "chrome", "size": 24, "label": 0, "functionSource": "TEST_F ( UsbBlocklistTest , BasicExclusions ) {\n SetDynamicBlocklist ( \"18D1:58F0:0100\" ) ;\n EXPECT_TRUE ( list ( ) . IsExcluded ( {\n 0x18D1 , 0x58F0 , 0x0100 }\n ) ) ;\n EXPECT_TRUE ( list ( ) . IsExcluded ( {\n 0x18D1 , 0x58F0 , 0x0090 }\n ) ) ;\n EXPECT_FALSE ( list ( ) . IsExcluded ( {\n 0x18D1 , 0x58F0 , 0x0200 }\n ) ) ;\n EXPECT_FALSE ( list ( ) . IsExcluded ( {\n 0x18D1 , 0x58F1 , 0x0100 }\n ) ) ;\n EXPECT_FALSE ( list ( ) . IsExcluded ( {\n 0x18D1 , 0x58EF , 0x0100 }\n ) ) ;\n EXPECT_FALSE ( list ( ) . IsExcluded ( {\n 0x18D0 , 0x58F0 , 0x0100 }\n ) ) ;\n EXPECT_FALSE ( list ( ) . IsExcluded ( {\n 0x18D2 , 0x58F0 , 0x0100 }\n ) ) ;\n }", "idx": 1533}
{"hash": 4107780562321324682, "project": "chrome", "size": 11, "label": 1, "functionSource": "static const char * getPosixID ( const ILcidPosixMap * this_0 , uint32_t hostID ) {\n uint32_t i ;\n for ( i = 0 ;\n i <= this_0 -> numRegions ;\n i ++ ) {\n if ( this_0 -> regionMaps [ i ] . hostID == hostID ) {\n return this_0 -> regionMaps [ i ] . posixID ;\n }\n }\n return this_0 -> regionMaps [ 0 ] . posixID ;\n }", "idx": 1534}
{"hash": -6435087038712482873, "project": "debian", "size": 6, "label": 0, "functionSource": "static void exchange_uv ( MpegEncContext * s ) {\n int16_t ( * tmp ) [ 64 ] ;\n tmp = s -> pblocks [ 4 ] ;\n s -> pblocks [ 4 ] = s -> pblocks [ 5 ] ;\n s -> pblocks [ 5 ] = tmp ;\n }", "idx": 1535}
{"hash": 4704178797381506498, "project": "debian", "size": 9, "label": 0, "functionSource": "static krb5_boolean ks_tuple_present ( int n_ks_tuple , krb5_key_salt_tuple * ks_tuple , krb5_key_salt_tuple * looking_for ) {\n int i ;\n for ( i = 0 ;\n i < n_ks_tuple ;\n i ++ ) {\n if ( ks_tuple [ i ] . ks_enctype == looking_for -> ks_enctype && ks_tuple [ i ] . ks_salttype == looking_for -> ks_salttype ) return TRUE ;\n }\n return FALSE ;\n }", "idx": 1536}
{"hash": 1896723564367514490, "project": "debian", "size": 26, "label": 1, "functionSource": "static VALUE ossl_cipher_update ( int argc , VALUE * argv , VALUE self ) {\n EVP_CIPHER_CTX * ctx ;\n unsigned char * in ;\n long in_len , out_len ;\n VALUE data , str ;\n rb_scan_args ( argc , argv , \"11\" , & data , & str ) ;\n StringValue ( data ) ;\n in = ( unsigned char * ) RSTRING_PTR ( data ) ;\n if ( ( in_len = RSTRING_LEN ( data ) ) == 0 ) ossl_raise ( rb_eArgError , \"data must not be empty\" ) ;\n GetCipher ( self , ctx ) ;\n out_len = in_len + EVP_CIPHER_CTX_block_size ( ctx ) ;\n if ( out_len <= 0 ) {\n ossl_raise ( rb_eRangeError , \"data too big to make output buffer: %ld bytes\" , in_len ) ;\n }\n if ( NIL_P ( str ) ) {\n str = rb_str_new ( 0 , out_len ) ;\n }\n else {\n StringValue ( str ) ;\n rb_str_resize ( str , out_len ) ;\n }\n if ( ! ossl_cipher_update_long ( ctx , ( unsigned char * ) RSTRING_PTR ( str ) , & out_len , in , in_len ) ) ossl_raise ( eCipherError , NULL ) ;\n assert ( out_len < RSTRING_LEN ( str ) ) ;\n rb_str_set_len ( str , out_len ) ;\n return str ;\n }", "idx": 1537}
{"hash": -5459605226342014540, "project": "debian", "size": 4, "label": 0, "functionSource": "static void tm2_free_codes ( TM2Codes * code ) {\n av_free ( code -> recode ) ;\n if ( code -> vlc . table ) ff_free_vlc ( & code -> vlc ) ;\n }", "idx": 1538}
{"hash": -6856626433814917486, "project": "debian", "size": 29, "label": 0, "functionSource": "static gint dissect_seid ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , gint offset , gint seid_side , gint i_item , guint32 * sep_seid , guint32 interface_id , guint32 adapter_id , guint32 chandle , guint32 frame_number ) {\n guint32 seid ;\n proto_tree * seid_tree = NULL ;\n proto_item * seid_item = NULL ;\n guint32 direction ;\n seid = tvb_get_guint8 ( tvb , offset ) >> 2 ;\n if ( sep_seid ) {\n * sep_seid = seid ;\n }\n if ( seid_side == SEID_ACP ) {\n direction = pinfo -> p2p_dir ;\n seid_item = proto_tree_add_none_format ( tree , hf_btavdtp_acp_seid_item , tvb , offset , 1 , \"ACP SEID [%u - %s %s]\" , seid , get_sep_media_type ( interface_id , adapter_id , chandle , direction , seid , frame_number ) , get_sep_type ( interface_id , adapter_id , chandle , direction , seid , frame_number ) ) ;\n seid_tree = proto_item_add_subtree ( seid_item , ett_btavdtp_sep ) ;\n proto_tree_add_item ( seid_tree , hf_btavdtp_acp_seid , tvb , offset , 1 , ENC_NA ) ;\n if ( i_item > 0 ) proto_item_append_text ( seid_item , \" item %u\" , i_item ) ;\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \" - ACP SEID [%u - %s %s]\" , seid , get_sep_media_type ( interface_id , adapter_id , chandle , direction , seid , frame_number ) , get_sep_type ( interface_id , adapter_id , chandle , direction , seid , frame_number ) ) ;\n }\n else {\n direction = ( pinfo -> p2p_dir == P2P_DIR_SENT ) ? P2P_DIR_RECV : P2P_DIR_SENT ;\n seid_item = proto_tree_add_none_format ( tree , hf_btavdtp_int_seid_item , tvb , offset , 1 , \"INT SEID [%u - %s %s]\" , seid , get_sep_media_type ( interface_id , adapter_id , chandle , direction , seid , frame_number ) , get_sep_type ( interface_id , adapter_id , chandle , direction , seid , frame_number ) ) ;\n seid_tree = proto_item_add_subtree ( seid_item , ett_btavdtp_sep ) ;\n proto_tree_add_item ( seid_tree , hf_btavdtp_int_seid , tvb , offset , 1 , ENC_NA ) ;\n if ( i_item > 0 ) proto_item_append_text ( seid_item , \" item %u\" , i_item ) ;\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \" - INT SEID [%u - %s %s]\" , seid , get_sep_media_type ( interface_id , adapter_id , chandle , direction , seid , frame_number ) , get_sep_type ( interface_id , adapter_id , chandle , direction , seid , frame_number ) ) ;\n }\n proto_tree_add_item ( seid_tree , hf_btavdtp_rfa_seid , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n return offset ;\n }", "idx": 1539}
{"hash": 4180964683905830761, "project": "debian", "size": 5, "label": 0, "functionSource": "static int selinux_mount ( const char * dev_name , const struct path * path , const char * type , unsigned long flags , void * data ) {\n const struct cred * cred = current_cred ( ) ;\n if ( flags & MS_REMOUNT ) return superblock_has_perm ( cred , path -> dentry -> d_sb , FILESYSTEM__REMOUNT , NULL ) ;\n else return path_has_perm ( cred , path , FILE__MOUNTON ) ;\n }", "idx": 1540}
{"hash": 3246343243711264189, "project": "debian", "size": 47, "label": 0, "functionSource": "static int send_chunk_or_dataless ( int dns_fd , int userid , struct query * q ) {\n char pkt [ 4096 ] ;\n int datalen = 0 ;\n int last = 0 ;\n if ( users [ userid ] . outpacket . len > 0 && users [ userid ] . outfragresent > 5 ) {\n users [ userid ] . outpacket . len = 0 ;\n users [ userid ] . outpacket . offset = 0 ;\n users [ userid ] . outpacket . sentlen = 0 ;\n users [ userid ] . outfragresent = 0 ;\n # ifdef OUTPACKETQ_LEN get_from_outpacketq ( userid ) ;\n # endif }\n if ( users [ userid ] . outpacket . len > 0 ) {\n datalen = MIN ( users [ userid ] . fragsize , users [ userid ] . outpacket . len - users [ userid ] . outpacket . offset ) ;\n datalen = MIN ( datalen , sizeof ( pkt ) - 2 ) ;\n memcpy ( & pkt [ 2 ] , users [ userid ] . outpacket . data + users [ userid ] . outpacket . offset , datalen ) ;\n users [ userid ] . outpacket . sentlen = datalen ;\n last = ( users [ userid ] . outpacket . len == users [ userid ] . outpacket . offset + datalen ) ;\n users [ userid ] . outfragresent ++ ;\n }\n pkt [ 0 ] = ( 1 << 7 ) | ( ( users [ userid ] . inpacket . seqno & 7 ) << 4 ) | ( users [ userid ] . inpacket . fragment & 15 ) ;\n pkt [ 1 ] = ( ( users [ userid ] . outpacket . seqno & 7 ) << 5 ) | ( ( users [ userid ] . outpacket . fragment & 15 ) << 1 ) | ( last & 1 ) ;\n if ( debug >= 1 ) {\n fprintf ( stderr , \"OUT pkt seq# %d, frag %d (last=%d), offset %d, fragsize %d, total %d, to user %d\\n\" , users [ userid ] . outpacket . seqno & 7 , users [ userid ] . outpacket . fragment & 15 , last , users [ userid ] . outpacket . offset , datalen , users [ userid ] . outpacket . len , userid ) ;\n }\n write_dns ( dns_fd , q , pkt , datalen + 2 , users [ userid ] . downenc ) ;\n if ( q -> id2 != 0 ) {\n q -> id = q -> id2 ;\n q -> fromlen = q -> fromlen2 ;\n memcpy ( & ( q -> from ) , & ( q -> from2 ) , q -> fromlen2 ) ;\n if ( debug >= 1 ) fprintf ( stderr , \"OUT again to last duplicate\\n\" ) ;\n write_dns ( dns_fd , q , pkt , datalen + 2 , users [ userid ] . downenc ) ;\n }\n save_to_qmem_pingordata ( userid , q ) ;\n # ifdef DNSCACHE_LEN save_to_dnscache ( userid , q , pkt , datalen + 2 ) ;\n # endif q -> id = 0 ;\n if ( datalen > 0 && datalen == users [ userid ] . outpacket . len ) {\n users [ userid ] . outpacket . len = 0 ;\n users [ userid ] . outpacket . offset = 0 ;\n users [ userid ] . outpacket . sentlen = 0 ;\n users [ userid ] . outfragresent = 0 ;\n # ifdef OUTPACKETQ_LEN if ( get_from_outpacketq ( userid ) == 1 ) {\n if ( debug >= 3 ) fprintf ( stderr , \" Chunk & fromqueue: callagain\\n\" ) ;\n return 1 ;\n }\n # endif }\n return 0 ;\n }", "idx": 1541}
{"hash": -282365232561056844, "project": "debian", "size": 16, "label": 0, "functionSource": "bool vmxnet_tx_pkt_send ( struct VmxnetTxPkt * pkt , NetClientState * nc ) {\n assert ( pkt ) ;\n if ( ! pkt -> has_virt_hdr && pkt -> virt_hdr . flags & VIRTIO_NET_HDR_F_NEEDS_CSUM ) {\n vmxnet_tx_pkt_do_sw_csum ( pkt ) ;\n }\n if ( VIRTIO_NET_HDR_GSO_NONE != pkt -> virt_hdr . gso_type ) {\n if ( pkt -> payload_len > ETH_MAX_IP_DGRAM_LEN - pkt -> vec [ VMXNET_TX_PKT_L3HDR_FRAG ] . iov_len ) {\n return false ;\n }\n }\n if ( pkt -> has_virt_hdr || pkt -> virt_hdr . gso_type == VIRTIO_NET_HDR_GSO_NONE ) {\n qemu_sendv_packet ( nc , pkt -> vec , pkt -> payload_frags + VMXNET_TX_PKT_PL_START_FRAG ) ;\n return true ;\n }\n return vmxnet_tx_pkt_do_sw_fragmentation ( pkt , nc ) ;\n }", "idx": 1542}
{"hash": 8947170728280515149, "project": "debian", "size": 29, "label": 0, "functionSource": "static void SCInterpretPS ( FILE * ps , SplineChar * sc ) {\n EntityChar ec ;\n real dval ;\n char tokbuf [ 10 ] ;\n IO wrapper ;\n int ch ;\n while ( isspace ( ch = getc ( ps ) ) ) ;\n ungetc ( ch , ps ) ;\n memset ( & wrapper , 0 , sizeof ( wrapper ) ) ;\n wrapper . advance_width = UNDEFINED_WIDTH ;\n if ( ch != '<' ) {\n pushio ( & wrapper , ps , NULL , 0 ) ;\n if ( nextpstoken ( & wrapper , & dval , tokbuf , sizeof ( tokbuf ) ) != pt_opencurly ) LogError ( _ ( \"We don't understand this font\\n\" ) ) ;\n }\n else {\n ( void ) getc ( ps ) ;\n pushfogio ( & wrapper , ps ) ;\n }\n memset ( & ec , '\\0' , sizeof ( ec ) ) ;\n ec . fromtype3 = true ;\n ec . sc = sc ;\n _InterpretPS ( & wrapper , & ec , NULL ) ;\n sc -> width = ec . width ;\n sc -> layer_cnt = 1 ;\n SCAppendEntityLayers ( sc , ec . splines ) ;\n if ( sc -> layer_cnt == 1 ) ++ sc -> layer_cnt ;\n sc -> layers [ ly_fore ] . refs = revrefs ( ec . refs ) ;\n free ( wrapper . top ) ;\n }", "idx": 1543}
{"hash": 5835074581393329621, "project": "debian", "size": 6, "label": 0, "functionSource": "static void doSleep ( int iSeconds , int iuSeconds ) {\n struct timeval tvSelectTimeout ;\n tvSelectTimeout . tv_sec = iSeconds ;\n tvSelectTimeout . tv_usec = iuSeconds ;\n select ( 0 , NULL , NULL , NULL , & tvSelectTimeout ) ;\n }", "idx": 1544}
{"hash": -7117046864335130087, "project": "chrome", "size": 3, "label": 1, "functionSource": "static int get_kf_active_quality ( const RATE_CONTROL * const rc , int q ) {\n return get_active_quality ( q , rc -> kf_boost , kf_low , kf_high , kf_low_motion_minq , kf_high_motion_minq ) ;\n }", "idx": 1545}
{"hash": 6755873269946787742, "project": "debian", "size": 16, "label": 0, "functionSource": "static GVariant * pk_transaction_get_property ( GDBusConnection * connection_ , const gchar * sender , const gchar * object_path , const gchar * interface_name , const gchar * property_name , GError * * error , gpointer user_data ) {\n PkTransaction * transaction = PK_TRANSACTION ( user_data ) ;\n PkTransactionPrivate * priv = transaction -> priv ;\n if ( g_strcmp0 ( property_name , \"Role\" ) == 0 ) return g_variant_new_uint32 ( priv -> role ) ;\n if ( g_strcmp0 ( property_name , \"Status\" ) == 0 ) return g_variant_new_uint32 ( priv -> status ) ;\n if ( g_strcmp0 ( property_name , \"LastPackage\" ) == 0 ) return _g_variant_new_maybe_string ( priv -> last_package_id ) ;\n if ( g_strcmp0 ( property_name , \"Uid\" ) == 0 ) return g_variant_new_uint32 ( priv -> uid ) ;\n if ( g_strcmp0 ( property_name , \"Percentage\" ) == 0 ) return g_variant_new_uint32 ( transaction -> priv -> percentage ) ;\n if ( g_strcmp0 ( property_name , \"AllowCancel\" ) == 0 ) return g_variant_new_boolean ( priv -> allow_cancel ) ;\n if ( g_strcmp0 ( property_name , \"CallerActive\" ) == 0 ) return g_variant_new_boolean ( priv -> caller_active ) ;\n if ( g_strcmp0 ( property_name , \"ElapsedTime\" ) == 0 ) return g_variant_new_uint32 ( priv -> elapsed_time ) ;\n if ( g_strcmp0 ( property_name , \"Speed\" ) == 0 ) return g_variant_new_uint32 ( priv -> speed ) ;\n if ( g_strcmp0 ( property_name , \"DownloadSizeRemaining\" ) == 0 ) return g_variant_new_uint64 ( priv -> download_size_remaining ) ;\n if ( g_strcmp0 ( property_name , \"TransactionFlags\" ) == 0 ) return g_variant_new_uint64 ( priv -> cached_transaction_flags ) ;\n return NULL ;\n }", "idx": 1546}
{"hash": 5375428808764837344, "project": "debian", "size": 6, "label": 0, "functionSource": "static void ClosePacketizer ( vlc_object_t * p_this ) {\n decoder_t * p_dec = ( decoder_t * ) p_this ;\n decoder_sys_t * p_sys = p_dec -> p_sys ;\n block_BytestreamRelease ( & p_sys -> bytestream ) ;\n free ( p_dec -> p_sys ) ;\n }", "idx": 1547}
{"hash": 1760449185745615462, "project": "debian", "size": 5, "label": 0, "functionSource": "int TSHttpTxnClientReqHdrBytesGet ( TSHttpTxn txnp ) {\n sdk_assert ( sdk_sanity_check_txn ( txnp ) == TS_SUCCESS ) ;\n HttpSM * sm = ( HttpSM * ) txnp ;\n return sm -> client_request_hdr_bytes ;\n }", "idx": 1548}
{"hash": -3889154245145551951, "project": "debian", "size": 40, "label": 0, "functionSource": "static int parse_one_feature ( const char * feature , int from_stream ) {\n const char * arg ;\n if ( skip_prefix ( feature , \"date-format=\" , & arg ) ) {\n option_date_format ( arg ) ;\n }\n else if ( skip_prefix ( feature , \"import-marks=\" , & arg ) ) {\n option_import_marks ( arg , from_stream , 0 ) ;\n }\n else if ( skip_prefix ( feature , \"import-marks-if-exists=\" , & arg ) ) {\n option_import_marks ( arg , from_stream , 1 ) ;\n }\n else if ( skip_prefix ( feature , \"export-marks=\" , & arg ) ) {\n option_export_marks ( arg ) ;\n }\n else if ( ! strcmp ( feature , \"get-mark\" ) ) {\n ;\n }\n else if ( ! strcmp ( feature , \"cat-blob\" ) ) {\n ;\n }\n else if ( ! strcmp ( feature , \"relative-marks\" ) ) {\n relative_marks_paths = 1 ;\n }\n else if ( ! strcmp ( feature , \"no-relative-marks\" ) ) {\n relative_marks_paths = 0 ;\n }\n else if ( ! strcmp ( feature , \"done\" ) ) {\n require_explicit_termination = 1 ;\n }\n else if ( ! strcmp ( feature , \"force\" ) ) {\n force_update = 1 ;\n }\n else if ( ! strcmp ( feature , \"notes\" ) || ! strcmp ( feature , \"ls\" ) ) {\n ;\n }\n else {\n return 0 ;\n }\n return 1 ;\n }", "idx": 1549}
{"hash": 8947170728280515149, "project": "debian", "size": 44, "label": 0, "functionSource": "void SFSplinesFromLayers ( SplineFont * sf , int tostroke ) {\n int i , layer ;\n int flags = - 1 ;\n Layer * new ;\n CharViewBase * cv ;\n for ( i = 0 ;\n i < sf -> glyphcnt ;\n ++ i ) if ( sf -> glyphs [ i ] != NULL ) {\n SplineChar * sc = sf -> glyphs [ i ] ;\n SplineSet * splines = SplinesFromLayers ( sc , & flags , tostroke ) ;\n RefChar * head = NULL , * last = NULL ;\n for ( layer = ly_fore ;\n layer < sc -> layer_cnt ;\n ++ layer ) {\n if ( head == NULL ) head = last = sc -> layers [ layer ] . refs ;\n else last -> next = sc -> layers [ layer ] . refs ;\n if ( last != NULL ) while ( last -> next != NULL ) last = last -> next ;\n sc -> layers [ layer ] . refs = NULL ;\n }\n new = calloc ( 2 , sizeof ( Layer ) ) ;\n new [ ly_back ] = sc -> layers [ ly_back ] ;\n memset ( & sc -> layers [ ly_back ] , 0 , sizeof ( Layer ) ) ;\n LayerDefault ( & new [ ly_fore ] ) ;\n new [ ly_fore ] . splines = splines ;\n new [ ly_fore ] . refs = head ;\n for ( layer = ly_fore ;\n layer < sc -> layer_cnt ;\n ++ layer ) {\n SplinePointListsMDFree ( sc , sc -> layers [ layer ] . splines ) ;\n RefCharsFree ( sc -> layers [ layer ] . refs ) ;\n ImageListsFree ( sc -> layers [ layer ] . images ) ;\n }\n free ( sc -> layers ) ;\n sc -> layers = new ;\n sc -> layer_cnt = 2 ;\n for ( cv = sc -> views ;\n cv != NULL ;\n cv = cv -> next ) {\n cv -> layerheads [ dm_back ] = & sc -> layers [ ly_back ] ;\n cv -> layerheads [ dm_fore ] = & sc -> layers [ ly_fore ] ;\n }\n }\n SFReinstanciateRefs ( sf ) ;\n }", "idx": 1550}
{"hash": -7683902591435073306, "project": "debian", "size": 4, "label": 0, "functionSource": "void msc_alert ( modsec_rec * msr , int level , msre_actionset * actionset , const char * action_message , const char * rule_message ) {\n const char * message = msc_alert_message ( msr , actionset , action_message , rule_message ) ;\n msr_log ( msr , level , \"%s\" , message ) ;\n }", "idx": 1551}
{"hash": 8170016074494868282, "project": "debian", "size": 3, "label": 0, "functionSource": "static void auth_server_reconnect_timeout ( struct auth_server_connection * conn ) {\n ( void ) auth_server_connection_connect ( conn ) ;\n }", "idx": 1552}
{"hash": 1676654288894940649, "project": "debian", "size": 214, "label": 0, "functionSource": "char * kadmin_startup ( int argc , char * argv [ ] ) {\n extern char * optarg ;\n char * princstr = NULL , * keytab_name = NULL , * query = NULL ;\n char * password = NULL ;\n char * luser , * canon , * cp ;\n int optchar , freeprinc = 0 , use_keytab = 0 , use_anonymous = 0 ;\n struct passwd * pw ;\n kadm5_ret_t retval ;\n krb5_ccache cc ;\n krb5_principal princ ;\n kadm5_config_params params ;\n char * * db_args = NULL ;\n int db_args_size = 0 ;\n char * db_name = NULL ;\n char * svcname , * realm ;\n memset ( & params , 0 , sizeof ( params ) ) ;\n if ( strcmp ( whoami , \"kadmin.local\" ) == 0 ) set_com_err_hook ( extended_com_err_fn ) ;\n retval = kadm5_init_krb5_context ( & context ) ;\n if ( retval ) {\n com_err ( whoami , retval , _ ( \"while initializing krb5 library\" ) ) ;\n exit ( 1 ) ;\n }\n while ( ( optchar = getopt ( argc , argv , \"x:r:p:knq:w:d:s:mc:t:e:ON\" ) ) != EOF ) {\n switch ( optchar ) {\n case 'x' : db_args_size ++ ;\n db_args = realloc ( db_args , sizeof ( char * ) * ( db_args_size + 1 ) ) ;\n if ( db_args == NULL ) {\n fprintf ( stderr , _ ( \"%s: Cannot initialize. Not enough memory\\n\" ) , argv [ 0 ] ) ;\n exit ( 1 ) ;\n }\n db_args [ db_args_size - 1 ] = optarg ;\n db_args [ db_args_size ] = NULL ;\n break ;\n case 'r' : def_realm = optarg ;\n break ;\n case 'p' : princstr = optarg ;\n break ;\n case 'c' : ccache_name = optarg ;\n break ;\n case 'k' : use_keytab ++ ;\n break ;\n case 'n' : use_anonymous ++ ;\n break ;\n case 't' : keytab_name = optarg ;\n break ;\n case 'w' : password = optarg ;\n break ;\n case 'q' : query = optarg ;\n break ;\n case 'd' : free ( db_name ) ;\n asprintf ( & db_name , \"dbname=%s\" , optarg ) ;\n db_args_size ++ ;\n db_args = realloc ( db_args , sizeof ( char * ) * ( db_args_size + 1 ) ) ;\n if ( db_args == NULL ) {\n fprintf ( stderr , _ ( \"%s: Cannot initialize. Not enough memory\\n\" ) , argv [ 0 ] ) ;\n exit ( 1 ) ;\n }\n db_args [ db_args_size - 1 ] = db_name ;\n db_args [ db_args_size ] = NULL ;\n break ;\n case 's' : params . admin_server = optarg ;\n params . mask |= KADM5_CONFIG_ADMIN_SERVER ;\n break ;\n case 'm' : params . mkey_from_kbd = 1 ;\n params . mask |= KADM5_CONFIG_MKEY_FROM_KBD ;\n break ;\n case 'e' : retval = krb5_string_to_keysalts ( optarg , \", \\t\" , \":.-\" , 0 , & params . keysalts , & params . num_keysalts ) ;\n if ( retval ) {\n com_err ( whoami , retval , _ ( \"while parsing keysalts %s\" ) , optarg ) ;\n exit ( 1 ) ;\n }\n params . mask |= KADM5_CONFIG_ENCTYPES ;\n break ;\n case 'O' : params . mask |= KADM5_CONFIG_OLD_AUTH_GSSAPI ;\n break ;\n case 'N' : params . mask |= KADM5_CONFIG_AUTH_NOFALLBACK ;\n break ;\n default : usage ( ) ;\n }\n }\n if ( ( ccache_name && use_keytab ) || ( keytab_name && ! use_keytab ) || ( ccache_name && use_anonymous ) || ( use_anonymous && use_keytab ) ) usage ( ) ;\n if ( def_realm == NULL && krb5_get_default_realm ( context , & def_realm ) ) {\n fprintf ( stderr , _ ( \"%s: unable to get default realm\\n\" ) , whoami ) ;\n exit ( 1 ) ;\n }\n params . mask |= KADM5_CONFIG_REALM ;\n params . realm = def_realm ;\n if ( params . mask & KADM5_CONFIG_OLD_AUTH_GSSAPI ) svcname = KADM5_ADMIN_SERVICE ;\n else svcname = NULL ;\n if ( ccache_name == NULL ) {\n retval = krb5_cc_default ( context , & cc ) ;\n if ( retval ) {\n com_err ( whoami , retval , _ ( \"while opening default credentials cache\" ) ) ;\n exit ( 1 ) ;\n }\n }\n else {\n retval = krb5_cc_resolve ( context , ccache_name , & cc ) ;\n if ( retval ) {\n com_err ( whoami , retval , _ ( \"while opening credentials cache %s\" ) , ccache_name ) ;\n exit ( 1 ) ;\n }\n }\n if ( princstr == NULL ) {\n if ( ccache_name != NULL && ! krb5_cc_get_principal ( context , cc , & princ ) ) {\n retval = krb5_unparse_name ( context , princ , & princstr ) ;\n if ( retval ) {\n com_err ( whoami , retval , _ ( \"while canonicalizing principal name\" ) ) ;\n exit ( 1 ) ;\n }\n krb5_free_principal ( context , princ ) ;\n freeprinc ++ ;\n }\n else if ( use_keytab != 0 ) {\n retval = krb5_sname_to_principal ( context , NULL , \"host\" , KRB5_NT_SRV_HST , & princ ) ;\n if ( retval ) {\n com_err ( whoami , retval , _ ( \"creating host service principal\" ) ) ;\n exit ( 1 ) ;\n }\n retval = krb5_unparse_name ( context , princ , & princstr ) ;\n if ( retval ) {\n com_err ( whoami , retval , _ ( \"while canonicalizing principal name\" ) ) ;\n exit ( 1 ) ;\n }\n krb5_free_principal ( context , princ ) ;\n freeprinc ++ ;\n }\n else if ( ! krb5_cc_get_principal ( context , cc , & princ ) ) {\n if ( krb5_unparse_name ( context , princ , & canon ) ) {\n fprintf ( stderr , _ ( \"%s: unable to canonicalize principal\\n\" ) , whoami ) ;\n exit ( 1 ) ;\n }\n realm = strchr ( canon , '@' ) ;\n while ( realm ) {\n if ( realm > canon && * ( realm - 1 ) != '\\\\' ) break ;\n realm = strchr ( realm + 1 , '@' ) ;\n }\n if ( realm ) * realm ++ = '\\0' ;\n cp = strchr ( canon , '/' ) ;\n while ( cp ) {\n if ( cp > canon && * ( cp - 1 ) != '\\\\' ) break ;\n cp = strchr ( cp + 1 , '/' ) ;\n }\n if ( cp != NULL ) * cp = '\\0' ;\n if ( asprintf ( & princstr , \"%s/admin%s%s\" , canon , ( realm ) ? \"@\" : \"\" , ( realm ) ? realm : \"\" ) < 0 ) {\n fprintf ( stderr , _ ( \"%s: out of memory\\n\" ) , whoami ) ;\n exit ( 1 ) ;\n }\n free ( canon ) ;\n krb5_free_principal ( context , princ ) ;\n freeprinc ++ ;\n }\n else if ( ( luser = getenv ( \"USER\" ) ) ) {\n if ( asprintf ( & princstr , \"%s/admin@%s\" , luser , def_realm ) < 0 ) {\n fprintf ( stderr , _ ( \"%s: out of memory\\n\" ) , whoami ) ;\n exit ( 1 ) ;\n }\n freeprinc ++ ;\n }\n else if ( ( pw = getpwuid ( getuid ( ) ) ) ) {\n if ( asprintf ( & princstr , \"%s/admin@%s\" , pw -> pw_name , def_realm ) < 0 ) {\n fprintf ( stderr , _ ( \"%s: out of memory\\n\" ) , whoami ) ;\n exit ( 1 ) ;\n }\n freeprinc ++ ;\n }\n else {\n fprintf ( stderr , _ ( \"%s: unable to figure out a principal name\\n\" ) , whoami ) ;\n exit ( 1 ) ;\n }\n }\n retval = krb5_klog_init ( context , \"admin_server\" , whoami , 0 ) ;\n if ( retval ) {\n com_err ( whoami , retval , _ ( \"while setting up logging\" ) ) ;\n exit ( 1 ) ;\n }\n if ( ccache_name ) {\n printf ( _ ( \"Authenticating as principal %s with existing \" \"credentials.\\n\" ) , princstr ) ;\n retval = kadm5_init_with_creds ( context , princstr , cc , svcname , & params , KADM5_STRUCT_VERSION , KADM5_API_VERSION_4 , db_args , & handle ) ;\n }\n else if ( use_anonymous ) {\n printf ( _ ( \"Authenticating as principal %s with password;\n \" \"anonymous requested.\\n\" ) , princstr ) ;\n retval = kadm5_init_anonymous ( context , princstr , svcname , & params , KADM5_STRUCT_VERSION , KADM5_API_VERSION_4 , db_args , & handle ) ;\n }\n else if ( use_keytab ) {\n if ( keytab_name ) printf ( _ ( \"Authenticating as principal %s with keytab %s.\\n\" ) , princstr , keytab_name ) ;\n else printf ( _ ( \"Authenticating as principal %s with default keytab.\\n\" ) , princstr ) ;\n retval = kadm5_init_with_skey ( context , princstr , keytab_name , svcname , & params , KADM5_STRUCT_VERSION , KADM5_API_VERSION_4 , db_args , & handle ) ;\n }\n else {\n printf ( _ ( \"Authenticating as principal %s with password.\\n\" ) , princstr ) ;\n retval = kadm5_init_with_password ( context , princstr , password , svcname , & params , KADM5_STRUCT_VERSION , KADM5_API_VERSION_4 , db_args , & handle ) ;\n }\n if ( retval ) {\n com_err ( whoami , retval , _ ( \"while initializing %s interface\" ) , whoami ) ;\n if ( retval == KADM5_BAD_CLIENT_PARAMS || retval == KADM5_BAD_SERVER_PARAMS ) usage ( ) ;\n exit ( 1 ) ;\n }\n if ( freeprinc ) free ( princstr ) ;\n free ( db_name ) ;\n free ( db_args ) ;\n retval = krb5_cc_close ( context , cc ) ;\n if ( retval ) {\n com_err ( whoami , retval , _ ( \"while closing ccache %s\" ) , ccache_name ) ;\n exit ( 1 ) ;\n }\n retval = kadm5_init_iprop ( handle , 0 ) ;\n if ( retval ) {\n com_err ( whoami , retval , _ ( \"while mapping update log\" ) ) ;\n exit ( 1 ) ;\n }\n return query ;\n }", "idx": 1553}
{"hash": -1315695702746584250, "project": "debian", "size": 6, "label": 0, "functionSource": "static void proto_tree_set_bytes_gbytearray ( field_info * fi , const GByteArray * value ) {\n GByteArray * bytes ;\n DISSECTOR_ASSERT ( value != NULL ) ;\n bytes = byte_array_dup ( value ) ;\n fvalue_set_byte_array ( & fi -> value , bytes ) ;\n }", "idx": 1554}
{"hash": 2335116444795821310, "project": "debian", "size": 13, "label": 0, "functionSource": "struct config_filter_parser * const * config_filter_get_all ( struct config_filter_context * ctx ) {\n ARRAY_TYPE ( config_filter_parsers ) filters ;\n unsigned int i ;\n t_array_init ( & filters , 8 ) ;\n for ( i = 0 ;\n ctx -> parsers [ i ] != NULL ;\n i ++ ) {\n array_append ( & filters , & ctx -> parsers [ i ] , 1 ) ;\n }\n array_sort ( & filters , config_filter_parser_cmp_rev ) ;\n array_append_zero ( & filters ) ;\n return array_idx ( & filters , 0 ) ;\n }", "idx": 1555}
{"hash": 3576240888172463140, "project": "debian", "size": 3, "label": 0, "functionSource": "unsigned long keydb_get_skipped_counter ( KEYDB_HANDLE hd ) {\n return hd ? hd -> skipped_long_blobs : 0 ;\n }", "idx": 1556}
{"hash": -7553540414561818627, "project": "debian", "size": 10, "label": 0, "functionSource": "static int genprime_cb ( int p , int n , BN_GENCB * arg ) {\n char c = '*' ;\n if ( p == 0 ) c = '.' ;\n if ( p == 1 ) c = '+' ;\n if ( p == 2 ) c = '*' ;\n if ( p == 3 ) c = '\\n' ;\n putc ( c , stderr ) ;\n fflush ( stderr ) ;\n return 1 ;\n }", "idx": 1557}
{"hash": -16551315108292821, "project": "debian", "size": 3, "label": 0, "functionSource": "gcry_error_t gcry_sexp_sscan ( gcry_sexp_t * retsexp , size_t * erroff , const char * buffer , size_t length ) {\n return sexp_sscan ( retsexp , erroff , buffer , length , 0 , NULL ) ;\n }", "idx": 1558}
{"hash": -4960438251319819237, "project": "chrome", "size": 4, "label": 0, "functionSource": "static int gfboost_qadjust ( int qindex , vpx_bit_depth_t bit_depth ) {\n const double q = vp9_convert_qindex_to_q ( qindex , bit_depth ) ;\n return ( int ) ( ( 0.00000828 * q * q * q ) + ( - 0.0055 * q * q ) + ( 1.32 * q ) + 79.3 ) ;\n }", "idx": 1559}
{"hash": 4423867112908498696, "project": "chrome", "size": 38, "label": 1, "functionSource": "void vp9_quantize_b_c ( const int16_t * coeff_ptr , intptr_t count , int skip_block , const int16_t * zbin_ptr , const int16_t * round_ptr , const int16_t * quant_ptr , const int16_t * quant_shift_ptr , int16_t * qcoeff_ptr , int16_t * dqcoeff_ptr , const int16_t * dequant_ptr , int zbin_oq_value , uint16_t * eob_ptr , const int16_t * scan , const int16_t * iscan ) {\n int i , non_zero_count = ( int ) count , eob = - 1 ;\n const int zbins [ 2 ] = {\n zbin_ptr [ 0 ] + zbin_oq_value , zbin_ptr [ 1 ] + zbin_oq_value }\n ;\n const int nzbins [ 2 ] = {\n zbins [ 0 ] * - 1 , zbins [ 1 ] * - 1 }\n ;\n ( void ) iscan ;\n vpx_memset ( qcoeff_ptr , 0 , count * sizeof ( int16_t ) ) ;\n vpx_memset ( dqcoeff_ptr , 0 , count * sizeof ( int16_t ) ) ;\n if ( ! skip_block ) {\n for ( i = ( int ) count - 1 ;\n i >= 0 ;\n i -- ) {\n const int rc = scan [ i ] ;\n const int coeff = coeff_ptr [ rc ] ;\n if ( coeff < zbins [ rc != 0 ] && coeff > nzbins [ rc != 0 ] ) non_zero_count -- ;\n else break ;\n }\n for ( i = 0 ;\n i < non_zero_count ;\n i ++ ) {\n const int rc = scan [ i ] ;\n const int coeff = coeff_ptr [ rc ] ;\n const int coeff_sign = ( coeff >> 31 ) ;\n const int abs_coeff = ( coeff ^ coeff_sign ) - coeff_sign ;\n if ( abs_coeff >= zbins [ rc != 0 ] ) {\n int tmp = clamp ( abs_coeff + round_ptr [ rc != 0 ] , INT16_MIN , INT16_MAX ) ;\n tmp = ( ( ( ( tmp * quant_ptr [ rc != 0 ] ) >> 16 ) + tmp ) * quant_shift_ptr [ rc != 0 ] ) >> 16 ;\n qcoeff_ptr [ rc ] = ( tmp ^ coeff_sign ) - coeff_sign ;\n dqcoeff_ptr [ rc ] = qcoeff_ptr [ rc ] * dequant_ptr [ rc != 0 ] ;\n if ( tmp ) eob = i ;\n }\n }\n }\n * eob_ptr = eob + 1 ;\n }", "idx": 1560}
{"hash": -1283648210945038844, "project": "chrome", "size": 61, "label": 0, "functionSource": "void vp9_fdct8x8_c ( const int16_t * input , tran_low_t * final_output , int stride ) {\n int i , j ;\n tran_low_t intermediate [ 64 ] ;\n {\n tran_low_t * output = intermediate ;\n tran_high_t s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 ;\n tran_high_t t0 , t1 , t2 , t3 ;\n tran_high_t x0 , x1 , x2 , x3 ;\n int i ;\n for ( i = 0 ;\n i < 8 ;\n i ++ ) {\n s0 = ( input [ 0 * stride ] + input [ 7 * stride ] ) * 4 ;\n s1 = ( input [ 1 * stride ] + input [ 6 * stride ] ) * 4 ;\n s2 = ( input [ 2 * stride ] + input [ 5 * stride ] ) * 4 ;\n s3 = ( input [ 3 * stride ] + input [ 4 * stride ] ) * 4 ;\n s4 = ( input [ 3 * stride ] - input [ 4 * stride ] ) * 4 ;\n s5 = ( input [ 2 * stride ] - input [ 5 * stride ] ) * 4 ;\n s6 = ( input [ 1 * stride ] - input [ 6 * stride ] ) * 4 ;\n s7 = ( input [ 0 * stride ] - input [ 7 * stride ] ) * 4 ;\n x0 = s0 + s3 ;\n x1 = s1 + s2 ;\n x2 = s1 - s2 ;\n x3 = s0 - s3 ;\n t0 = ( x0 + x1 ) * cospi_16_64 ;\n t1 = ( x0 - x1 ) * cospi_16_64 ;\n t2 = x2 * cospi_24_64 + x3 * cospi_8_64 ;\n t3 = - x2 * cospi_8_64 + x3 * cospi_24_64 ;\n output [ 0 * 8 ] = fdct_round_shift ( t0 ) ;\n output [ 2 * 8 ] = fdct_round_shift ( t2 ) ;\n output [ 4 * 8 ] = fdct_round_shift ( t1 ) ;\n output [ 6 * 8 ] = fdct_round_shift ( t3 ) ;\n t0 = ( s6 - s5 ) * cospi_16_64 ;\n t1 = ( s6 + s5 ) * cospi_16_64 ;\n t2 = fdct_round_shift ( t0 ) ;\n t3 = fdct_round_shift ( t1 ) ;\n x0 = s4 + t2 ;\n x1 = s4 - t2 ;\n x2 = s7 - t3 ;\n x3 = s7 + t3 ;\n t0 = x0 * cospi_28_64 + x3 * cospi_4_64 ;\n t1 = x1 * cospi_12_64 + x2 * cospi_20_64 ;\n t2 = x2 * cospi_12_64 + x1 * - cospi_20_64 ;\n t3 = x3 * cospi_28_64 + x0 * - cospi_4_64 ;\n output [ 1 * 8 ] = fdct_round_shift ( t0 ) ;\n output [ 3 * 8 ] = fdct_round_shift ( t2 ) ;\n output [ 5 * 8 ] = fdct_round_shift ( t1 ) ;\n output [ 7 * 8 ] = fdct_round_shift ( t3 ) ;\n input ++ ;\n output ++ ;\n }\n }\n for ( i = 0 ;\n i < 8 ;\n ++ i ) {\n fdct8 ( & intermediate [ i * 8 ] , & final_output [ i * 8 ] ) ;\n for ( j = 0 ;\n j < 8 ;\n ++ j ) final_output [ j + i * 8 ] /= 2 ;\n }\n }", "idx": 1561}
{"hash": -4370220620850259177, "project": "debian", "size": 14, "label": 0, "functionSource": "static void eval_ir ( const float * Az , int pitch_lag , float * freq , float pitch_sharp_factor ) {\n float tmp1 [ SUBFR_SIZE + 1 ] , tmp2 [ LP_FILTER_ORDER + 1 ] ;\n int i ;\n tmp1 [ 0 ] = 1. ;\n for ( i = 0 ;\n i < LP_FILTER_ORDER ;\n i ++ ) {\n tmp1 [ i + 1 ] = Az [ i ] * ff_pow_0_55 [ i ] ;\n tmp2 [ i ] = Az [ i ] * ff_pow_0_7 [ i ] ;\n }\n memset ( tmp1 + 11 , 0 , 37 * sizeof ( float ) ) ;\n ff_celp_lp_synthesis_filterf ( freq , tmp2 , tmp1 , SUBFR_SIZE , LP_FILTER_ORDER ) ;\n pitch_sharpening ( pitch_lag , pitch_sharp_factor , freq ) ;\n }", "idx": 1562}
{"hash": 6755873269946787742, "project": "debian", "size": 12, "label": 0, "functionSource": "static gboolean pk_transaction_is_supported_content_type ( PkTransaction * transaction , const gchar * content_type ) {\n const gchar * tmp ;\n GPtrArray * array = transaction -> priv -> supported_content_types ;\n guint i ;\n for ( i = 0 ;\n i < array -> len ;\n i ++ ) {\n tmp = g_ptr_array_index ( array , i ) ;\n if ( g_strcmp0 ( tmp , content_type ) == 0 ) return TRUE ;\n }\n return FALSE ;\n }", "idx": 1563}
{"hash": -3819889754140204145, "project": "debian", "size": 6, "label": 0, "functionSource": "METHOD ( x509_t , create_name_constraint_enumerator , enumerator_t * , private_x509_cert_t * this , bool perm ) {\n if ( perm ) {\n return this -> permitted_names -> create_enumerator ( this -> permitted_names ) ;\n }\n return this -> excluded_names -> create_enumerator ( this -> excluded_names ) ;\n }", "idx": 1564}
{"hash": 1182028467273264883, "project": "debian", "size": 21, "label": 0, "functionSource": "void do_wait_for_slave_to_stop ( struct st_command * c __attribute__ ( ( unused ) ) ) {\n static int SLAVE_POLL_INTERVAL = 300000 ;\n MYSQL * mysql = cur_con -> mysql ;\n for ( ;\n ;\n ) {\n MYSQL_RES * UNINIT_VAR ( res ) ;\n MYSQL_ROW row ;\n int done ;\n if ( mysql_query ( mysql , \"show status like 'Slave_running'\" ) || ! ( res = mysql_store_result ( mysql ) ) ) die ( \"Query failed while probing slave for stop: %s\" , mysql_error ( mysql ) ) ;\n if ( ! ( row = mysql_fetch_row ( res ) ) || ! row [ 1 ] ) {\n mysql_free_result ( res ) ;\n die ( \"Strange result from query while probing slave for stop\" ) ;\n }\n done = ! strcmp ( row [ 1 ] , \"OFF\" ) ;\n mysql_free_result ( res ) ;\n if ( done ) break ;\n my_sleep ( SLAVE_POLL_INTERVAL ) ;\n }\n return ;\n }", "idx": 1565}
{"hash": -5280794106681745199, "project": "debian", "size": 10, "label": 0, "functionSource": "AsfStream * gst_asf_demux_get_stream ( GstASFDemux * demux , guint16 id ) {\n guint i ;\n for ( i = 0 ;\n i < demux -> num_streams ;\n i ++ ) {\n if ( demux -> stream [ i ] . id == id ) return & demux -> stream [ i ] ;\n }\n if ( gst_asf_demux_is_unknown_stream ( demux , id ) ) GST_WARNING ( \"Segment found for undefined stream: (%d)\" , id ) ;\n return NULL ;\n }", "idx": 1566}
{"hash": 4537091194729139981, "project": "chrome", "size": 8, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( FullscreenControllerInteractiveTest , DISABLED_ToggleFullscreenModeForTab ) {\n GURL url = test_server ( ) -> GetURL ( \"simple.html\" ) ;\n AddTabAtIndex ( 0 , url , PAGE_TRANSITION_TYPED ) ;\n ASSERT_FALSE ( IsFullscreenPermissionRequested ( ) ) ;\n ASSERT_NO_FATAL_FAILURE ( ToggleTabFullscreenNoRetries ( true ) ) ;\n ASSERT_TRUE ( IsFullscreenPermissionRequested ( ) ) ;\n ASSERT_NO_FATAL_FAILURE ( ToggleTabFullscreenNoRetries ( false ) ) ;\n }", "idx": 1567}
{"hash": -1487877838474751244, "project": "debian", "size": 32, "label": 0, "functionSource": "PHP_FUNCTION ( locale_get_all_variants ) {\n const char * loc_name = NULL ;\n int loc_name_len = 0 ;\n int result = 0 ;\n char * token = NULL ;\n char * variant = NULL ;\n char * saved_ptr = NULL ;\n intl_error_reset ( NULL TSRMLS_CC ) ;\n if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , \"s\" , & loc_name , & loc_name_len ) == FAILURE ) {\n intl_error_set ( NULL , U_ILLEGAL_ARGUMENT_ERROR , \"locale_parse: unable to parse input params\" , 0 TSRMLS_CC ) ;\n RETURN_FALSE ;\n }\n if ( loc_name_len == 0 ) {\n loc_name = intl_locale_get_default ( TSRMLS_C ) ;\n }\n array_init ( return_value ) ;\n if ( findOffset ( LOC_GRANDFATHERED , loc_name ) >= 0 ) {\n }\n else {\n variant = get_icu_value_internal ( loc_name , LOC_VARIANT_TAG , & result , 0 ) ;\n if ( result > 0 && variant ) {\n token = php_strtok_r ( variant , DELIMITER , & saved_ptr ) ;\n add_next_index_stringl ( return_value , token , strlen ( token ) , TRUE ) ;\n while ( ( token = php_strtok_r ( NULL , DELIMITER , & saved_ptr ) ) && ( strlen ( token ) > 1 ) ) {\n add_next_index_stringl ( return_value , token , strlen ( token ) , TRUE ) ;\n }\n }\n if ( variant ) {\n efree ( variant ) ;\n }\n }\n }", "idx": 1568}
{"hash": -1321749842392027937, "project": "chrome", "size": 8, "label": 0, "functionSource": "void vp8_transform_mbuv ( MACROBLOCK * x ) {\n int i ;\n for ( i = 16 ;\n i < 24 ;\n i += 2 ) {\n x -> short_fdct8x4 ( & x -> block [ i ] . src_diff [ 0 ] , & x -> block [ i ] . coeff [ 0 ] , 16 ) ;\n }\n }", "idx": 1569}
{"hash": -6552851419396579257, "project": "debian", "size": 4, "label": 0, "functionSource": "static int SpoolssRouterReplyPrinter_r ( tvbuff_t * tvb , int offset , packet_info * pinfo , proto_tree * tree , dcerpc_info * di , guint8 * drep ) {\n offset = dissect_doserror ( tvb , offset , pinfo , tree , di , drep , hf_rc , NULL ) ;\n return offset ;\n }", "idx": 1570}
{"hash": 515706766097680840, "project": "chrome", "size": 15, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( SiteDetailsBrowserTest , ExtensionWithTwoWebIframes ) {\n scoped_refptr < TestMemoryDetails > details = new TestMemoryDetails ( ) ;\n details -> StartFetchAndWait ( ) ;\n const Extension * extension = CreateExtension ( \"Test Extension\" , false ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , extension -> GetResourceURL ( \"/two_http_iframes.html\" ) ) ;\n details = new TestMemoryDetails ( ) ;\n details -> StartFetchAndWait ( ) ;\n EXPECT_THAT ( details -> uma ( ) -> GetAllSamples ( \"SiteIsolation.CurrentRendererProcessCount\" ) , HasOneSample ( GetRenderProcessCount ( ) ) ) ;\n EXPECT_THAT ( details -> uma ( ) -> GetAllSamples ( \"SiteIsolation.IsolateNothingProcessCountEstimate\" ) , HasOneSample ( 1 ) ) ;\n EXPECT_THAT ( details -> uma ( ) -> GetAllSamples ( \"SiteIsolation.IsolateExtensionsProcessCountEstimate\" ) , HasOneSample ( 2 ) ) ;\n EXPECT_THAT ( details -> uma ( ) -> GetAllSamples ( \"SiteIsolation.IsolateExtensionsProcessCountLowerBound\" ) , HasOneSample ( 2 ) ) ;\n EXPECT_THAT ( details -> uma ( ) -> GetAllSamples ( \"SiteIsolation.IsolateExtensionsProcessCountNoLimit\" ) , HasOneSample ( 2 ) ) ;\n EXPECT_THAT ( GetRenderProcessCount ( ) , DependingOnPolicy ( 1 , 3 , 3 ) ) ;\n EXPECT_THAT ( details -> GetOutOfProcessIframeCount ( ) , DependingOnPolicy ( 0 , 2 , 2 ) ) ;\n }", "idx": 1571}
{"hash": 1760449185745615462, "project": "debian", "size": 3, "label": 0, "functionSource": "TSMatcherLine TSMatcherLineCreate ( void ) {\n return reinterpret_cast < TSMatcherLine > ( ats_malloc ( sizeof ( matcher_line ) ) ) ;\n }", "idx": 1572}
{"hash": -5420171864670538459, "project": "debian", "size": 26, "label": 0, "functionSource": "static int tcg_cpu_exec ( CPUArchState * env ) {\n int ret ;\n # ifdef CONFIG_PROFILER int64_t ti ;\n # endif # ifdef CONFIG_PROFILER ti = profile_getclock ( ) ;\n # endif if ( use_icount ) {\n int64_t count ;\n int decr ;\n qemu_icount -= ( env -> icount_decr . u16 . low + env -> icount_extra ) ;\n env -> icount_decr . u16 . low = 0 ;\n env -> icount_extra = 0 ;\n count = qemu_icount_round ( qemu_clock_deadline ( vm_clock ) ) ;\n qemu_icount += count ;\n decr = ( count > 0xffff ) ? 0xffff : count ;\n count -= decr ;\n env -> icount_decr . u16 . low = decr ;\n env -> icount_extra = count ;\n }\n ret = cpu_exec ( env ) ;\n # ifdef CONFIG_PROFILER qemu_time += profile_getclock ( ) - ti ;\n # endif if ( use_icount ) {\n qemu_icount -= ( env -> icount_decr . u16 . low + env -> icount_extra ) ;\n env -> icount_decr . u32 = 0 ;\n env -> icount_extra = 0 ;\n }\n return ret ;\n }", "idx": 1573}
{"hash": -8394854914099170670, "project": "chrome", "size": 18, "label": 1, "functionSource": "IN_PROC_BROWSER_TEST_F ( NewAvatarMenuButtonTest , MAYBE_SignOut ) {\n if ( ! profiles : : IsMultipleProfilesEnabled ( ) ) return ;\n CreateTestingProfile ( ) ;\n ASSERT_NO_FATAL_FAILURE ( StartAvatarMenu ( ) ) ;\n BrowserList * browser_list = BrowserList : : GetInstance ( chrome : : GetActiveDesktop ( ) ) ;\n EXPECT_EQ ( 1U , browser_list -> size ( ) ) ;\n content : : WindowedNotificationObserver window_close_observer ( chrome : : NOTIFICATION_BROWSER_CLOSED , content : : Source < Browser > ( browser ( ) ) ) ;\n AvatarMenu * menu = ProfileChooserView : : profile_bubble_ -> avatar_menu_ . get ( ) ;\n const AvatarMenu : : Item & menu_item_before = menu -> GetItemAt ( menu -> GetActiveProfileIndex ( ) ) ;\n EXPECT_FALSE ( menu_item_before . signin_required ) ;\n ui : : MouseEvent mouse_ev ( ui : : ET_MOUSE_RELEASED , gfx : : Point ( ) , gfx : : Point ( ) , 0 , 0 ) ;\n ProfileChooserView : : profile_bubble_ -> ButtonPressed ( ProfileChooserView : : profile_bubble_ -> lock_button_ , mouse_ev ) ;\n EXPECT_TRUE ( menu -> GetItemAt ( menu -> GetActiveProfileIndex ( ) ) . signin_required ) ;\n window_close_observer . Wait ( ) ;\n EXPECT_TRUE ( browser_list -> empty ( ) ) ;\n if ( ! UserManagerView : : IsShowing ( ) ) base : : MessageLoop : : current ( ) -> RunUntilIdle ( ) ;\n chrome : : HideUserManager ( ) ;\n }", "idx": 1574}
{"hash": 3035587999006680483, "project": "debian", "size": 9, "label": 0, "functionSource": "void dtls1_clear_record_buffer ( SSL * s ) {\n pitem * item ;\n for ( item = pqueue_pop ( s -> d1 -> sent_messages ) ;\n item != NULL ;\n item = pqueue_pop ( s -> d1 -> sent_messages ) ) {\n dtls1_hm_fragment_free ( ( hm_fragment * ) item -> data ) ;\n pitem_free ( item ) ;\n }\n }", "idx": 1575}
{"hash": 4489017523191997023, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h225_TBCD_STRING_SIZE_3_16 ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_size_constrained_type ( tvb , offset , actx , tree , hf_index , dissect_h225_TBCD_STRING , \"TBCD_STRING\" , 3 , 16 , FALSE ) ;\n return offset ;\n }", "idx": 1576}
{"hash": 4489017523191997023, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h225_INTEGER_1_31 ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_constrained_integer ( tvb , offset , actx , tree , hf_index , 1U , 31U , NULL , FALSE ) ;\n return offset ;\n }", "idx": 1577}
{"hash": 2895622461494525400, "project": "debian", "size": 4, "label": 0, "functionSource": "static void test_bug12925 ( ) {\n myheader ( \"test_bug12925\" ) ;\n if ( opt_getopt_ll_test ) DIE_UNLESS ( opt_getopt_ll_test == LL ( 25600 * 1024 * 1024 ) ) ;\n }", "idx": 1578}
{"hash": 455172021572601154, "project": "debian", "size": 7, "label": 1, "functionSource": "extern int name ( int , locale_t ) __THROW __exctype_l ( isalnum_l ) ;\n __exctype_l ( isalpha_l ) ;\n __exctype_l ( iscntrl_l ) ;\n __exctype_l ( isdigit_l ) ;\n __exctype_l ( islower_l ) ;\n __exctype_l ( isgraph_l ) ;\n __exctype_l ( isprint_l )", "idx": 1579}
{"hash": -4555950263653671147, "project": "debian", "size": 23, "label": 0, "functionSource": "static PyObject * string_capitalize ( PyStringObject * self ) {\n char * s = PyString_AS_STRING ( self ) , * s_new ;\n Py_ssize_t i , n = PyString_GET_SIZE ( self ) ;\n PyObject * newobj ;\n newobj = PyString_FromStringAndSize ( NULL , n ) ;\n if ( newobj == NULL ) return NULL ;\n s_new = PyString_AsString ( newobj ) ;\n if ( 0 < n ) {\n int c = Py_CHARMASK ( * s ++ ) ;\n if ( islower ( c ) ) * s_new = toupper ( c ) ;\n else * s_new = c ;\n s_new ++ ;\n }\n for ( i = 1 ;\n i < n ;\n i ++ ) {\n int c = Py_CHARMASK ( * s ++ ) ;\n if ( isupper ( c ) ) * s_new = tolower ( c ) ;\n else * s_new = c ;\n s_new ++ ;\n }\n return newobj ;\n }", "idx": 1580}
{"hash": 1760449185745615462, "project": "debian", "size": 8, "label": 0, "functionSource": "int TSVConnClosedGet ( TSVConn connp ) {\n sdk_assert ( sdk_sanity_check_iocore_structure ( connp ) == TS_SUCCESS ) ;\n VConnection * vc = ( VConnection * ) connp ;\n int data = 0 ;\n bool f = vc -> get_data ( TS_API_DATA_CLOSED , & data ) ;\n ink_assert ( f ) ;\n return data ;\n }", "idx": 1581}
{"hash": 8206514580434225668, "project": "chrome", "size": 5, "label": 1, "functionSource": "IN_PROC_BROWSER_TEST_F ( HttpsEngagementPageLoadMetricsBrowserTest , OtherScheme ) {\n NavigateInForegroundAndCloseWithTiming ( GURL ( chrome : : kChromeUIVersionURL ) ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHttpEngagementHistogram , 0 ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHttpsEngagementHistogram , 0 ) ;\n }", "idx": 1582}
{"hash": -649112636673899765, "project": "debian", "size": 3, "label": 0, "functionSource": "static void get_str8 ( AVIOContext * pb , char * buf , int buf_size ) {\n get_strl ( pb , buf , buf_size , avio_r8 ( pb ) ) ;\n }", "idx": 1583}
{"hash": 1182028467273264883, "project": "debian", "size": 9, "label": 0, "functionSource": "void check_require ( DYNAMIC_STRING * ds , const char * fname ) {\n DBUG_ENTER ( \"check_require\" ) ;\n if ( dyn_string_cmp ( ds , fname ) ) {\n char reason [ FN_REFLEN ] ;\n fn_format ( reason , fname , \"\" , \"\" , MY_REPLACE_EXT | MY_REPLACE_DIR ) ;\n abort_not_supported_test ( \"Test requires: '%s'\" , reason ) ;\n }\n DBUG_VOID_RETURN ;\n }", "idx": 1584}
{"hash": -6215323349888018447, "project": "debian", "size": 23, "label": 0, "functionSource": "static void makeAlterConfigCommand ( PGconn * conn , const char * arrayitem , const char * type , const char * name , const char * type2 , const char * name2 ) {\n char * pos ;\n char * mine ;\n PQExpBuffer buf ;\n mine = pg_strdup ( arrayitem ) ;\n pos = strchr ( mine , '=' ) ;\n if ( pos == NULL ) {\n free ( mine ) ;\n return ;\n }\n buf = createPQExpBuffer ( ) ;\n * pos = 0 ;\n appendPQExpBuffer ( buf , \"ALTER %s %s \" , type , fmtId ( name ) ) ;\n if ( type2 != NULL && name2 != NULL ) appendPQExpBuffer ( buf , \"IN %s %s \" , type2 , fmtId ( name2 ) ) ;\n appendPQExpBuffer ( buf , \"SET %s TO \" , fmtId ( mine ) ) ;\n if ( pg_strcasecmp ( mine , \"DateStyle\" ) == 0 || pg_strcasecmp ( mine , \"search_path\" ) == 0 ) appendPQExpBufferStr ( buf , pos + 1 ) ;\n else appendStringLiteralConn ( buf , pos + 1 , conn ) ;\n appendPQExpBufferStr ( buf , \";\n\\n\" ) ;\n fprintf ( OPF , \"%s\" , buf -> data ) ;\n destroyPQExpBuffer ( buf ) ;\n free ( mine ) ;\n }", "idx": 1585}
{"hash": -6552851419396579257, "project": "debian", "size": 8, "label": 0, "functionSource": "static int dissect_DEVMODE_CTR ( tvbuff_t * tvb , int offset , packet_info * pinfo , proto_tree * tree , dcerpc_info * di , guint8 * drep ) {\n proto_tree * subtree ;\n guint32 size ;\n subtree = proto_tree_add_subtree ( tree , tvb , offset , 0 , ett_DEVMODE_CTR , NULL , \"Devicemode container\" ) ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , subtree , di , drep , hf_devmodectr_size , & size ) ;\n offset = dissect_ndr_pointer ( tvb , offset , pinfo , subtree , di , drep , dissect_DEVMODE , NDR_POINTER_UNIQUE , \"Devicemode\" , - 1 ) ;\n return offset ;\n }", "idx": 1586}
{"hash": 5210559217603684076, "project": "chrome", "size": 150, "label": 0, "functionSource": "static void _fromUnicodeWithCallback ( UConverterFromUnicodeArgs * pArgs , UErrorCode * err ) {\n UConverterFromUnicode fromUnicode ;\n UConverter * cnv ;\n const UChar * s ;\n char * t ;\n int32_t * offsets ;\n int32_t sourceIndex ;\n int32_t errorInputLength ;\n UBool converterSawEndOfInput , calledCallback ;\n UChar replay [ UCNV_EXT_MAX_UCHARS ] ;\n const UChar * realSource , * realSourceLimit ;\n int32_t realSourceIndex ;\n UBool realFlush ;\n cnv = pArgs -> converter ;\n s = pArgs -> source ;\n t = pArgs -> target ;\n offsets = pArgs -> offsets ;\n sourceIndex = 0 ;\n if ( offsets == NULL ) {\n fromUnicode = cnv -> sharedData -> impl -> fromUnicode ;\n }\n else {\n fromUnicode = cnv -> sharedData -> impl -> fromUnicodeWithOffsets ;\n if ( fromUnicode == NULL ) {\n fromUnicode = cnv -> sharedData -> impl -> fromUnicode ;\n sourceIndex = - 1 ;\n }\n }\n if ( cnv -> preFromULength >= 0 ) {\n realSource = NULL ;\n realSourceLimit = NULL ;\n realFlush = FALSE ;\n realSourceIndex = 0 ;\n }\n else {\n realSource = pArgs -> source ;\n realSourceLimit = pArgs -> sourceLimit ;\n realFlush = pArgs -> flush ;\n realSourceIndex = sourceIndex ;\n uprv_memcpy ( replay , cnv -> preFromU , - cnv -> preFromULength * U_SIZEOF_UCHAR ) ;\n pArgs -> source = replay ;\n pArgs -> sourceLimit = replay - cnv -> preFromULength ;\n pArgs -> flush = FALSE ;\n sourceIndex = - 1 ;\n cnv -> preFromULength = 0 ;\n }\n for ( ;\n ;\n ) {\n if ( U_SUCCESS ( * err ) ) {\n fromUnicode ( pArgs , err ) ;\n converterSawEndOfInput = ( UBool ) ( U_SUCCESS ( * err ) && pArgs -> flush && pArgs -> source == pArgs -> sourceLimit && cnv -> fromUChar32 == 0 ) ;\n }\n else {\n converterSawEndOfInput = FALSE ;\n }\n calledCallback = FALSE ;\n errorInputLength = 0 ;\n for ( ;\n ;\n ) {\n if ( offsets != NULL ) {\n int32_t length = ( int32_t ) ( pArgs -> target - t ) ;\n if ( length > 0 ) {\n _updateOffsets ( offsets , length , sourceIndex , errorInputLength ) ;\n pArgs -> offsets = offsets += length ;\n }\n if ( sourceIndex >= 0 ) {\n sourceIndex += ( int32_t ) ( pArgs -> source - s ) ;\n }\n }\n if ( cnv -> preFromULength < 0 ) {\n if ( realSource == NULL ) {\n realSource = pArgs -> source ;\n realSourceLimit = pArgs -> sourceLimit ;\n realFlush = pArgs -> flush ;\n realSourceIndex = sourceIndex ;\n uprv_memcpy ( replay , cnv -> preFromU , - cnv -> preFromULength * U_SIZEOF_UCHAR ) ;\n pArgs -> source = replay ;\n pArgs -> sourceLimit = replay - cnv -> preFromULength ;\n pArgs -> flush = FALSE ;\n if ( ( sourceIndex += cnv -> preFromULength ) < 0 ) {\n sourceIndex = - 1 ;\n }\n cnv -> preFromULength = 0 ;\n }\n else {\n U_ASSERT ( realSource == NULL ) ;\n * err = U_INTERNAL_PROGRAM_ERROR ;\n }\n }\n s = pArgs -> source ;\n t = pArgs -> target ;\n if ( U_SUCCESS ( * err ) ) {\n if ( s < pArgs -> sourceLimit ) {\n break ;\n }\n else if ( realSource != NULL ) {\n pArgs -> source = realSource ;\n pArgs -> sourceLimit = realSourceLimit ;\n pArgs -> flush = realFlush ;\n sourceIndex = realSourceIndex ;\n realSource = NULL ;\n break ;\n }\n else if ( pArgs -> flush && cnv -> fromUChar32 != 0 ) {\n * err = U_TRUNCATED_CHAR_FOUND ;\n calledCallback = FALSE ;\n }\n else {\n if ( pArgs -> flush ) {\n if ( ! converterSawEndOfInput ) {\n break ;\n }\n _reset ( cnv , UCNV_RESET_FROM_UNICODE , FALSE ) ;\n }\n return ;\n }\n }\n {\n UErrorCode e ;\n if ( calledCallback || ( e = * err ) == U_BUFFER_OVERFLOW_ERROR || ( e != U_INVALID_CHAR_FOUND && e != U_ILLEGAL_CHAR_FOUND && e != U_TRUNCATED_CHAR_FOUND ) ) {\n if ( realSource != NULL ) {\n int32_t length ;\n U_ASSERT ( cnv -> preFromULength == 0 ) ;\n length = ( int32_t ) ( pArgs -> sourceLimit - pArgs -> source ) ;\n if ( length > 0 ) {\n u_memcpy ( cnv -> preFromU , pArgs -> source , length ) ;\n cnv -> preFromULength = ( int8_t ) - length ;\n }\n pArgs -> source = realSource ;\n pArgs -> sourceLimit = realSourceLimit ;\n pArgs -> flush = realFlush ;\n }\n return ;\n }\n }\n {\n UChar32 codePoint ;\n codePoint = cnv -> fromUChar32 ;\n errorInputLength = 0 ;\n U16_APPEND_UNSAFE ( cnv -> invalidUCharBuffer , errorInputLength , codePoint ) ;\n cnv -> invalidUCharLength = ( int8_t ) errorInputLength ;\n cnv -> fromUChar32 = 0 ;\n cnv -> fromUCharErrorBehaviour ( cnv -> fromUContext , pArgs , cnv -> invalidUCharBuffer , errorInputLength , codePoint , * err == U_INVALID_CHAR_FOUND ? UCNV_UNASSIGNED : UCNV_ILLEGAL , err ) ;\n }\n calledCallback = TRUE ;\n }\n }\n }", "idx": 1587}
{"hash": -789251383577298283, "project": "debian", "size": 7, "label": 1, "functionSource": "int BIO_vsnprintf ( char * buf , size_t n , const char * format , va_list args ) {\n size_t retlen ;\n int truncated ;\n _dopr ( & buf , NULL , & n , & retlen , & truncated , format , args ) ;\n if ( truncated ) return - 1 ;\n else return ( retlen <= INT_MAX ) ? ( int ) retlen : - 1 ;\n }", "idx": 1588}
{"hash": -8562387810778703674, "project": "chrome", "size": 5, "label": 0, "functionSource": "void hb_font_funcs_destroy ( hb_font_funcs_t * ffuncs ) {\n if ( ! hb_object_destroy ( ffuncs ) ) return ;\n # define HB_FONT_FUNC_IMPLEMENT ( name ) if ( ffuncs -> destroy . name ) ffuncs -> destroy . name ( ffuncs -> user_data . name ) ;\n HB_FONT_FUNCS_IMPLEMENT_CALLBACKS # undef HB_FONT_FUNC_IMPLEMENT free ( ffuncs ) ;\n }", "idx": 1589}
{"hash": -8919449269326401539, "project": "debian", "size": 27, "label": 0, "functionSource": "static int dissect_s_supervisor_exception_detail_warning ( packet_info * pinfo , proto_tree * tree , proto_item * item , tvbuff_t * tvb , int offset , int total_len ) {\n proto_item * pi ;\n proto_tree * item_tree ;\n int total_size = 0 , size ;\n item_tree = proto_tree_add_subtree ( tree , tvb , offset , 1 , ett_exception_detail_warning_common , & pi , \"Common Exception Detail\" ) ;\n size = dissect_s_supervisor_exception_detail ( item_tree , pi , tvb , offset , hf_cip_ssupervisor_exception_detail_warning_ced_size , hf_cip_ssupervisor_exception_detail_warning_ced_detail ) ;\n if ( size == 0 ) {\n expert_add_info ( pinfo , item , & ei_mal_ssupervisor_detail_warning_ced ) ;\n return total_len ;\n }\n total_size += size ;\n item_tree = proto_tree_add_subtree ( tree , tvb , offset , 1 , ett_exception_detail_warning_device , & pi , \"Device Exception Detail\" ) ;\n size = dissect_s_supervisor_exception_detail ( item_tree , pi , tvb , offset , hf_cip_ssupervisor_exception_detail_warning_ded_size , hf_cip_ssupervisor_exception_detail_warning_ded_detail ) ;\n if ( size == 0 ) {\n expert_add_info ( pinfo , item , & ei_mal_ssupervisor_detail_warning_ded ) ;\n return total_len ;\n }\n total_size += size ;\n item_tree = proto_tree_add_subtree ( tree , tvb , offset , 1 , ett_exception_detail_warning_manufacturer , & pi , \"Manufacturer Exception Detail\" ) ;\n size = dissect_s_supervisor_exception_detail ( item_tree , pi , tvb , offset , hf_cip_ssupervisor_exception_detail_warning_med_size , hf_cip_ssupervisor_exception_detail_warning_med_detail ) ;\n if ( size == 0 ) {\n expert_add_info ( pinfo , item , & ei_mal_ssupervisor_detail_warning_med ) ;\n return total_len ;\n }\n total_size += size ;\n return total_size ;\n }", "idx": 1590}
{"hash": -7434014980763120366, "project": "debian", "size": 6, "label": 0, "functionSource": "void new_register_ber_oid_dissector ( const char * oid , new_dissector_t dissector , int proto , const char * name ) {\n dissector_handle_t dissector_handle ;\n dissector_handle = new_create_dissector_handle ( dissector , proto ) ;\n dissector_add_string ( \"ber.oid\" , oid , dissector_handle ) ;\n oid_add_from_string ( name , oid ) ;\n }", "idx": 1591}
{"hash": 8458201026073747179, "project": "debian", "size": 42, "label": 0, "functionSource": "static int jbig2_decode_generic_template2a ( Jbig2Ctx * ctx , Jbig2Segment * segment , const Jbig2GenericRegionParams * params , Jbig2ArithState * as , Jbig2Image * image , Jbig2ArithCx * GB_stats ) {\n const int GBW = image -> width ;\n const int GBH = image -> height ;\n const int rowstride = image -> stride ;\n int x , y ;\n byte * gbreg_line = ( byte * ) image -> data ;\n # ifdef OUTPUT_PBM printf ( \"P4\\n%d %d\\n\" , GBW , GBH ) ;\n # endif if ( GBW <= 0 ) return 0 ;\n for ( y = 0 ;\n y < GBH ;\n y ++ ) {\n uint32_t CONTEXT ;\n uint32_t line_m1 ;\n uint32_t line_m2 ;\n int padded_width = ( GBW + 7 ) & - 8 ;\n line_m1 = ( y >= 1 ) ? gbreg_line [ - rowstride ] : 0 ;\n line_m2 = ( y >= 2 ) ? gbreg_line [ - ( rowstride << 1 ) ] << 4 : 0 ;\n CONTEXT = ( ( line_m1 >> 3 ) & 0x78 ) | ( ( line_m1 >> 2 ) & 0x4 ) | ( ( line_m2 >> 3 ) & 0x380 ) ;\n for ( x = 0 ;\n x < padded_width ;\n x += 8 ) {\n byte result = 0 ;\n int x_minor ;\n int minor_width = GBW - x > 8 ? 8 : GBW - x ;\n if ( y >= 1 ) line_m1 = ( line_m1 << 8 ) | ( x + 8 < GBW ? gbreg_line [ - rowstride + ( x >> 3 ) + 1 ] : 0 ) ;\n if ( y >= 2 ) line_m2 = ( line_m2 << 8 ) | ( x + 8 < GBW ? gbreg_line [ - ( rowstride << 1 ) + ( x >> 3 ) + 1 ] << 4 : 0 ) ;\n for ( x_minor = 0 ;\n x_minor < minor_width ;\n x_minor ++ ) {\n bool bit ;\n bit = jbig2_arith_decode ( as , & GB_stats [ CONTEXT ] ) ;\n if ( bit < 0 ) return - 1 ;\n result |= bit << ( 7 - x_minor ) ;\n CONTEXT = ( ( CONTEXT & 0x1b9 ) << 1 ) | bit | ( ( line_m1 >> ( 10 - x_minor ) ) & 0x8 ) | ( ( line_m1 >> ( 9 - x_minor ) ) & 0x4 ) | ( ( line_m2 >> ( 10 - x_minor ) ) & 0x80 ) ;\n }\n gbreg_line [ x >> 3 ] = result ;\n }\n # ifdef OUTPUT_PBM fwrite ( gbreg_line , 1 , rowstride , stdout ) ;\n # endif gbreg_line += rowstride ;\n }\n return 0 ;\n }", "idx": 1592}
{"hash": 8193534372312945122, "project": "debian", "size": 11, "label": 0, "functionSource": "static inline int ladr_match ( PCNetState * s , const uint8_t * buf , int size ) {\n struct qemu_ether_header * hdr = ( void * ) buf ;\n if ( ( * ( hdr -> ether_dhost ) & 0x01 ) && ( ( uint64_t * ) & s -> csr [ 8 ] ) [ 0 ] != 0LL ) {\n uint8_t ladr [ 8 ] = {\n s -> csr [ 8 ] & 0xff , s -> csr [ 8 ] >> 8 , s -> csr [ 9 ] & 0xff , s -> csr [ 9 ] >> 8 , s -> csr [ 10 ] & 0xff , s -> csr [ 10 ] >> 8 , s -> csr [ 11 ] & 0xff , s -> csr [ 11 ] >> 8 }\n ;\n int index = net_crc32_le ( hdr -> ether_dhost , ETH_ALEN ) >> 26 ;\n return ! ! ( ladr [ index >> 3 ] & ( 1 << ( index & 7 ) ) ) ;\n }\n return 0 ;\n }", "idx": 1593}
{"hash": -1321749842392027937, "project": "chrome", "size": 8, "label": 0, "functionSource": "void vp8_encode_inter16x16y ( MACROBLOCK * x ) {\n BLOCK * b = & x -> block [ 0 ] ;\n vp8_build_inter16x16_predictors_mby ( & x -> e_mbd , x -> e_mbd . dst . y_buffer , x -> e_mbd . dst . y_stride ) ;\n vp8_subtract_mby ( x -> src_diff , * ( b -> base_src ) , b -> src_stride , x -> e_mbd . dst . y_buffer , x -> e_mbd . dst . y_stride ) ;\n transform_mby ( x ) ;\n vp8_quantize_mby ( x ) ;\n vp8_inverse_transform_mby ( & x -> e_mbd ) ;\n }", "idx": 1594}
{"hash": 7749168290238234888, "project": "debian", "size": 44, "label": 0, "functionSource": "int test_compare_files ( const char * tgt , const char * rec ) {\n FILE * orig , * recons ;\n static uint8_t obuf [ TESTBUFSIZE ] , rbuf [ TESTBUFSIZE ] ;\n xoff_t offset = 0 ;\n size_t i ;\n size_t oc , rc ;\n xoff_t diffs = 0 ;\n if ( ( orig = fopen ( tgt , \"r\" ) ) == NULL ) {\n XPR ( NT \"open %s failed\\n\" , tgt ) ;\n return get_errno ( ) ;\n }\n if ( ( recons = fopen ( rec , \"r\" ) ) == NULL ) {\n XPR ( NT \"open %s failed\\n\" , rec ) ;\n return get_errno ( ) ;\n }\n for ( ;\n ;\n ) {\n oc = fread ( obuf , 1 , TESTBUFSIZE , orig ) ;\n rc = fread ( rbuf , 1 , TESTBUFSIZE , recons ) ;\n if ( oc != rc ) {\n return XD3_INTERNAL ;\n }\n if ( oc == 0 ) {\n break ;\n }\n for ( i = 0 ;\n i < oc ;\n i += 1 ) {\n if ( obuf [ i ] != rbuf [ i ] ) {\n XPR ( NT \"byte %u (read %u @ %\" Q \"u) %d != %d\\n\" , ( int ) i , ( int ) oc , offset , obuf [ i ] , rbuf [ i ] ) ;\n diffs ++ ;\n return XD3_INTERNAL ;\n }\n }\n offset += oc ;\n }\n fclose ( orig ) ;\n fclose ( recons ) ;\n if ( diffs != 0 ) {\n return XD3_INTERNAL ;\n }\n return 0 ;\n }", "idx": 1595}
{"hash": -6580451576689962916, "project": "debian", "size": 15, "label": 0, "functionSource": "static char * wv_csp12_opaque_literal_tag ( tvbuff_t * tvb , guint32 offset , const char * token , guint8 codepage _U_ , guint32 * length ) {\n guint32 data_len = tvb_get_guintvar ( tvb , offset , length ) ;\n char * str = NULL ;\n if ( token && ( ( strcmp ( token , \"Code\" ) == 0 ) || ( strcmp ( token , \"ContentSize\" ) == 0 ) || ( strcmp ( token , \"MessageCount\" ) == 0 ) || ( strcmp ( token , \"Validity\" ) == 0 ) || ( strcmp ( token , \"KeepAliveTime\" ) == 0 ) || ( strcmp ( token , \"TimeToLive\" ) == 0 ) || ( strcmp ( token , \"AcceptedContentLength\" ) == 0 ) || ( strcmp ( token , \"MultiTrans\" ) == 0 ) || ( strcmp ( token , \"ParserSize\" ) == 0 ) || ( strcmp ( token , \"ServerPollMin\" ) == 0 ) || ( strcmp ( token , \"TCPPort\" ) == 0 ) || ( strcmp ( token , \"UDPPort\" ) == 0 ) || ( strcmp ( token , \"HistoryPeriod\" ) == 0 ) || ( strcmp ( token , \"MaxWatcherList\" ) == 0 ) ) ) {\n str = wv_integer_from_opaque ( tvb , offset + * length , data_len ) ;\n }\n else if ( token && ( ( strcmp ( token , \"DateTime\" ) == 0 ) || ( strcmp ( token , \"DeliveryTime\" ) == 0 ) ) ) {\n str = wv_datetime_from_opaque ( tvb , offset + * length , data_len ) ;\n }\n if ( str == NULL ) {\n str = wmem_strdup_printf ( wmem_packet_scope ( ) , \"(%d bytes of unparsed opaque data)\" , data_len ) ;\n }\n * length += data_len ;\n return str ;\n }", "idx": 1596}
{"hash": -3559021711340554904, "project": "debian", "size": 36, "label": 0, "functionSource": "static List * simplify_or_arguments ( List * args , eval_const_expressions_context * context , bool * haveNull , bool * forceTrue ) {\n List * newargs = NIL ;\n List * unprocessed_args ;\n unprocessed_args = list_copy ( args ) ;\n while ( unprocessed_args ) {\n Node * arg = ( Node * ) linitial ( unprocessed_args ) ;\n unprocessed_args = list_delete_first ( unprocessed_args ) ;\n if ( or_clause ( arg ) ) {\n List * subargs = list_copy ( ( ( BoolExpr * ) arg ) -> args ) ;\n if ( ! unprocessed_args ) unprocessed_args = subargs ;\n else {\n List * oldhdr = unprocessed_args ;\n unprocessed_args = list_concat ( subargs , unprocessed_args ) ;\n pfree ( oldhdr ) ;\n }\n continue ;\n }\n arg = eval_const_expressions_mutator ( arg , context ) ;\n if ( or_clause ( arg ) ) {\n List * subargs = list_copy ( ( ( BoolExpr * ) arg ) -> args ) ;\n unprocessed_args = list_concat ( subargs , unprocessed_args ) ;\n continue ;\n }\n if ( IsA ( arg , Const ) ) {\n Const * const_input = ( Const * ) arg ;\n if ( const_input -> constisnull ) * haveNull = true ;\n else if ( DatumGetBool ( const_input -> constvalue ) ) {\n * forceTrue = true ;\n return NIL ;\n }\n continue ;\n }\n newargs = lappend ( newargs , arg ) ;\n }\n return newargs ;\n }", "idx": 1597}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_NonStandardMessage ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_NonStandardMessage , NonStandardMessage_sequence ) ;\n return offset ;\n }", "idx": 1598}
{"hash": 1760449185745615462, "project": "debian", "size": 21, "label": 0, "functionSource": "TSAction TSContScheduleEvery ( TSCont contp , ink_hrtime every , TSThreadPool tp ) {\n sdk_assert ( sdk_sanity_check_iocore_structure ( contp ) == TS_SUCCESS ) ;\n FORCE_PLUGIN_SCOPED_MUTEX ( contp ) ;\n INKContInternal * i = ( INKContInternal * ) contp ;\n TSAction action ;\n if ( ink_atomic_increment ( ( int * ) & i -> m_event_count , 1 ) < 0 ) {\n ink_assert ( ! \"not reached\" ) ;\n }\n EventType etype ;\n switch ( tp ) {\n case TS_THREAD_POOL_NET : case TS_THREAD_POOL_DEFAULT : etype = ET_NET ;\n break ;\n case TS_THREAD_POOL_TASK : etype = ET_TASK ;\n break ;\n default : etype = ET_TASK ;\n break ;\n }\n action = reinterpret_cast < TSAction > ( eventProcessor . schedule_every ( i , HRTIME_MSECONDS ( every ) , etype ) ) ;\n action = ( TSAction ) ( ( uintptr_t ) action | 0x1 ) ;\n return action ;\n }", "idx": 1599}
{"hash": -1315695702746584250, "project": "debian", "size": 13, "label": 0, "functionSource": "static const char * hfinfo_numeric_value_format64 ( const header_field_info * hfinfo , char buf [ 64 ] , guint64 value ) {\n int display = hfinfo -> display & FIELD_DISPLAY_E_MASK ;\n if ( hfinfo -> type == FT_FRAMENUM ) {\n display = BASE_DEC ;\n }\n switch ( display ) {\n case BASE_NONE : case BASE_DEC_HEX : case BASE_OCT : case BASE_CUSTOM : display = BASE_DEC ;\n break ;\n case BASE_HEX_DEC : display = BASE_HEX ;\n break ;\n }\n return hfinfo_number_value_format_display64 ( hfinfo , display , buf , value ) ;\n }", "idx": 1600}
{"hash": -2242211406757466627, "project": "debian", "size": 33, "label": 0, "functionSource": "static gint handle_message_field ( tvbuff_t * tvb , packet_info * pinfo , proto_item * header_tree , guint encoding , gint offset , guint8 * * signature , guint8 * signature_length ) {\n proto_tree * field_tree ;\n proto_item * item , * field_item ;\n guint8 field_code ;\n guint8 type_id ;\n gboolean is_reply_to = FALSE ;\n gint starting_offset = offset ;\n gint padding_start ;\n field_code = tvb_get_guint8 ( tvb , offset ) ;\n if ( HDR_REPLY_SERIAL == field_code ) {\n is_reply_to = TRUE ;\n }\n field_item = proto_tree_add_item ( header_tree , hf_alljoyn_mess_header_field , tvb , offset , 1 , ENC_NA ) ;\n field_tree = proto_item_add_subtree ( field_item , ett_alljoyn_mess_header_field ) ;\n proto_tree_add_item ( field_tree , hf_alljoyn_mess_body_header_fieldcode , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n handle_message_header_expected_byte ( tvb , offset , field_tree , 0x01 ) ;\n offset += 1 ;\n item = proto_tree_add_item ( field_tree , hf_alljoyn_mess_body_header_typeid , tvb , offset , 1 , ENC_NA ) ;\n type_id = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n handle_message_header_expected_byte ( tvb , offset , field_tree , 0x00 ) ;\n offset += 1 ;\n offset = parse_arg ( tvb , pinfo , item , encoding , offset , field_tree , is_reply_to , type_id , field_code , signature , signature_length , starting_offset ) ;\n padding_start = offset ;\n offset = round_to_8byte ( offset , starting_offset ) ;\n add_padding_item ( padding_start , offset , tvb , field_tree ) ;\n if ( offset < 0 || offset > ( gint ) tvb_reported_length ( tvb ) ) {\n offset = ( gint ) tvb_reported_length ( tvb ) ;\n }\n proto_item_set_end ( field_tree , tvb , offset ) ;\n return offset ;\n }", "idx": 1601}
{"hash": -2908211205972632000, "project": "debian", "size": 6, "label": 0, "functionSource": "static MAIN_WINDOW_REC * mainwindows_find_lower_right ( MAIN_WINDOW_REC * window ) {\n MAIN_WINDOW_REC * best ;\n best = mainwindows_find_right ( window , FALSE ) ;\n if ( best == NULL ) best = mainwindows_find_lower ( window ) ;\n return best ;\n }", "idx": 1602}
{"hash": 3035587999006680483, "project": "debian", "size": 90, "label": 0, "functionSource": "int dtls1_do_write ( SSL * s , int type ) {\n int ret ;\n int curr_mtu ;\n unsigned int len , frag_off , mac_size , blocksize ;\n if ( s -> d1 -> mtu < dtls1_min_mtu ( ) && ! ( SSL_get_options ( s ) & SSL_OP_NO_QUERY_MTU ) ) {\n s -> d1 -> mtu = BIO_ctrl ( SSL_get_wbio ( s ) , BIO_CTRL_DGRAM_QUERY_MTU , 0 , NULL ) ;\n if ( s -> d1 -> mtu < dtls1_min_mtu ( ) ) {\n s -> d1 -> mtu = 0 ;\n s -> d1 -> mtu = dtls1_guess_mtu ( s -> d1 -> mtu ) ;\n BIO_ctrl ( SSL_get_wbio ( s ) , BIO_CTRL_DGRAM_SET_MTU , s -> d1 -> mtu , NULL ) ;\n }\n }\n # if 0 mtu = s -> d1 -> mtu ;\n fprintf ( stderr , \"using MTU = %d\\n\" , mtu ) ;\n mtu -= ( DTLS1_HM_HEADER_LENGTH + DTLS1_RT_HEADER_LENGTH ) ;\n curr_mtu = mtu - BIO_wpending ( SSL_get_wbio ( s ) ) ;\n if ( curr_mtu > 0 ) mtu = curr_mtu ;\n else if ( ( ret = BIO_flush ( SSL_get_wbio ( s ) ) ) <= 0 ) return ret ;\n if ( BIO_wpending ( SSL_get_wbio ( s ) ) + s -> init_num >= mtu ) {\n ret = BIO_flush ( SSL_get_wbio ( s ) ) ;\n if ( ret <= 0 ) return ret ;\n mtu = s -> d1 -> mtu - ( DTLS1_HM_HEADER_LENGTH + DTLS1_RT_HEADER_LENGTH ) ;\n }\n # endif OPENSSL_assert ( s -> d1 -> mtu >= dtls1_min_mtu ( ) ) ;\n if ( s -> init_off == 0 && type == SSL3_RT_HANDSHAKE ) OPENSSL_assert ( s -> init_num == ( int ) s -> d1 -> w_msg_hdr . msg_len + DTLS1_HM_HEADER_LENGTH ) ;\n if ( s -> write_hash ) mac_size = EVP_MD_CTX_size ( s -> write_hash ) ;\n else mac_size = 0 ;\n if ( s -> enc_write_ctx && ( EVP_CIPHER_mode ( s -> enc_write_ctx -> cipher ) & EVP_CIPH_CBC_MODE ) ) blocksize = 2 * EVP_CIPHER_block_size ( s -> enc_write_ctx -> cipher ) ;\n else blocksize = 0 ;\n frag_off = 0 ;\n while ( s -> init_num ) {\n curr_mtu = s -> d1 -> mtu - BIO_wpending ( SSL_get_wbio ( s ) ) - DTLS1_RT_HEADER_LENGTH - mac_size - blocksize ;\n if ( curr_mtu <= DTLS1_HM_HEADER_LENGTH ) {\n ret = BIO_flush ( SSL_get_wbio ( s ) ) ;\n if ( ret <= 0 ) return ret ;\n curr_mtu = s -> d1 -> mtu - DTLS1_RT_HEADER_LENGTH - mac_size - blocksize ;\n }\n if ( s -> init_num > curr_mtu ) len = curr_mtu ;\n else len = s -> init_num ;\n if ( type == SSL3_RT_HANDSHAKE ) {\n if ( s -> init_off != 0 ) {\n OPENSSL_assert ( s -> init_off > DTLS1_HM_HEADER_LENGTH ) ;\n s -> init_off -= DTLS1_HM_HEADER_LENGTH ;\n s -> init_num += DTLS1_HM_HEADER_LENGTH ;\n if ( s -> init_num > curr_mtu ) len = curr_mtu ;\n else len = s -> init_num ;\n }\n dtls1_fix_message_header ( s , frag_off , len - DTLS1_HM_HEADER_LENGTH ) ;\n dtls1_write_message_header ( s , ( unsigned char * ) & s -> init_buf -> data [ s -> init_off ] ) ;\n OPENSSL_assert ( len >= DTLS1_HM_HEADER_LENGTH ) ;\n }\n ret = dtls1_write_bytes ( s , type , & s -> init_buf -> data [ s -> init_off ] , len ) ;\n if ( ret < 0 ) {\n if ( BIO_ctrl ( SSL_get_wbio ( s ) , BIO_CTRL_DGRAM_MTU_EXCEEDED , 0 , NULL ) > 0 ) s -> d1 -> mtu = BIO_ctrl ( SSL_get_wbio ( s ) , BIO_CTRL_DGRAM_QUERY_MTU , 0 , NULL ) ;\n else return ( - 1 ) ;\n }\n else {\n OPENSSL_assert ( len == ( unsigned int ) ret ) ;\n if ( type == SSL3_RT_HANDSHAKE && ! s -> d1 -> retransmitting ) {\n unsigned char * p = ( unsigned char * ) & s -> init_buf -> data [ s -> init_off ] ;\n const struct hm_header_st * msg_hdr = & s -> d1 -> w_msg_hdr ;\n int xlen ;\n if ( frag_off == 0 && s -> version != DTLS1_BAD_VER ) {\n * p ++ = msg_hdr -> type ;\n l2n3 ( msg_hdr -> msg_len , p ) ;\n s2n ( msg_hdr -> seq , p ) ;\n l2n3 ( 0 , p ) ;\n l2n3 ( msg_hdr -> msg_len , p ) ;\n p -= DTLS1_HM_HEADER_LENGTH ;\n xlen = ret ;\n }\n else {\n p += DTLS1_HM_HEADER_LENGTH ;\n xlen = ret - DTLS1_HM_HEADER_LENGTH ;\n }\n ssl3_finish_mac ( s , p , xlen ) ;\n }\n if ( ret == s -> init_num ) {\n if ( s -> msg_callback ) s -> msg_callback ( 1 , s -> version , type , s -> init_buf -> data , ( size_t ) ( s -> init_off + s -> init_num ) , s , s -> msg_callback_arg ) ;\n s -> init_off = 0 ;\n s -> init_num = 0 ;\n return ( 1 ) ;\n }\n s -> init_off += ret ;\n s -> init_num -= ret ;\n frag_off += ( ret -= DTLS1_HM_HEADER_LENGTH ) ;\n }\n }\n return ( 0 ) ;\n }", "idx": 1603}
{"hash": 1667027354487746122, "project": "chrome", "size": 3, "label": 0, "functionSource": "hb_shape_plan_t * hb_shape_plan_reference ( hb_shape_plan_t * shape_plan ) {\n return hb_object_reference ( shape_plan ) ;\n }", "idx": 1604}
{"hash": -650231346353974279, "project": "debian", "size": 13, "label": 0, "functionSource": "void appendStringLiteralConn ( PQExpBuffer buf , const char * str , PGconn * conn ) {\n size_t length = strlen ( str ) ;\n if ( strchr ( str , '\\\\' ) != NULL && PQserverVersion ( conn ) >= 80100 ) {\n if ( buf -> len > 0 && buf -> data [ buf -> len - 1 ] != ' ' ) appendPQExpBufferChar ( buf , ' ' ) ;\n appendPQExpBufferChar ( buf , ESCAPE_STRING_SYNTAX ) ;\n appendStringLiteral ( buf , str , PQclientEncoding ( conn ) , false ) ;\n return ;\n }\n if ( ! enlargePQExpBuffer ( buf , 2 * length + 2 ) ) return ;\n appendPQExpBufferChar ( buf , '\\'' ) ;\n buf -> len += PQescapeStringConn ( conn , buf -> data + buf -> len , str , length , NULL ) ;\n appendPQExpBufferChar ( buf , '\\'' ) ;\n }", "idx": 1605}
{"hash": 5610242550647094255, "project": "debian", "size": 23, "label": 0, "functionSource": "static int fill_vaapi_ReferenceFrames ( VAPictureParameterBufferH264 * pic_param , H264Context * h ) {\n DPB dpb ;\n int i ;\n dpb . size = 0 ;\n dpb . max_size = FF_ARRAY_ELEMS ( pic_param -> ReferenceFrames ) ;\n dpb . va_pics = pic_param -> ReferenceFrames ;\n for ( i = 0 ;\n i < dpb . max_size ;\n i ++ ) init_vaapi_pic ( & dpb . va_pics [ i ] ) ;\n for ( i = 0 ;\n i < h -> short_ref_count ;\n i ++ ) {\n Picture * const pic = h -> short_ref [ i ] ;\n if ( pic && pic -> reference && dpb_add ( & dpb , pic ) < 0 ) return - 1 ;\n }\n for ( i = 0 ;\n i < 16 ;\n i ++ ) {\n Picture * const pic = h -> long_ref [ i ] ;\n if ( pic && pic -> reference && dpb_add ( & dpb , pic ) < 0 ) return - 1 ;\n }\n return 0 ;\n }", "idx": 1606}
{"hash": 1353431100313404503, "project": "chrome", "size": 9, "label": 1, "functionSource": "static void setup_frame_size ( VP9_COMMON * cm , struct vp9_read_bit_buffer * rb ) {\n int width , height ;\n vp9_read_frame_size ( rb , & width , & height ) ;\n resize_context_buffers ( cm , width , height ) ;\n setup_display_size ( cm , rb ) ;\n if ( vp9_realloc_frame_buffer ( get_frame_new_buffer ( cm ) , cm -> width , cm -> height , cm -> subsampling_x , cm -> subsampling_y , # if CONFIG_VP9_HIGHBITDEPTH cm -> use_highbitdepth , # endif VP9_DEC_BORDER_IN_PIXELS , & cm -> frame_bufs [ cm -> new_fb_idx ] . raw_frame_buffer , cm -> get_fb_cb , cm -> cb_priv ) ) {\n vpx_internal_error ( & cm -> error , VPX_CODEC_MEM_ERROR , \"Failed to allocate frame buffer\" ) ;\n }\n }", "idx": 1607}
{"hash": -6126432314261451839, "project": "debian", "size": 8, "label": 0, "functionSource": "uint gx_device_raster_plane ( const gx_device * dev , const gx_render_plane_t * render_plane ) {\n ulong bpc = ( render_plane && render_plane -> index >= 0 ? render_plane -> depth : dev -> color_info . depth / ( dev -> is_planar ? dev -> color_info . num_components : 1 ) ) ;\n ulong bits = ( ulong ) dev -> width * bpc ;\n int l2align ;\n l2align = dev -> log2_align_mod ;\n if ( l2align < log2_align_bitmap_mod ) l2align = log2_align_bitmap_mod ;\n return ( uint ) ( ( ( bits + ( 8 << l2align ) - 1 ) >> ( l2align + 3 ) ) << l2align ) ;\n }", "idx": 1608}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_LogicalChannelRateReject ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_LogicalChannelRateReject , LogicalChannelRateReject_sequence ) ;\n return offset ;\n }", "idx": 1609}
{"hash": -5268859819325807498, "project": "debian", "size": 14, "label": 0, "functionSource": "static void link_info_stop ( NautilusDirectory * directory ) {\n NautilusFile * file ;\n if ( directory -> details -> link_info_read_state != NULL ) {\n file = directory -> details -> link_info_read_state -> file ;\n if ( file != NULL ) {\n g_assert ( NAUTILUS_IS_FILE ( file ) ) ;\n g_assert ( file -> details -> directory == directory ) ;\n if ( is_needy ( file , lacks_link_info , REQUEST_LINK_INFO ) ) {\n return ;\n }\n }\n link_info_cancel ( directory ) ;\n }\n }", "idx": 1610}
{"hash": -5725800580349519214, "project": "chrome", "size": 19, "label": 0, "functionSource": "int vp9_get_raw_frame ( VP9Decoder * pbi , YV12_BUFFER_CONFIG * sd , vp9_ppflags_t * flags ) {\n VP9_COMMON * const cm = & pbi -> common ;\n int ret = - 1 ;\n # if ! CONFIG_VP9_POSTPROC ( void ) * flags ;\n # endif if ( pbi -> ready_for_new_data == 1 ) return ret ;\n if ( ! cm -> show_frame ) return ret ;\n pbi -> ready_for_new_data = 1 ;\n # if CONFIG_VP9_POSTPROC if ( ! cm -> show_existing_frame ) {\n ret = vp9_post_proc_frame ( cm , sd , flags ) ;\n }\n else {\n * sd = * cm -> frame_to_show ;\n ret = 0 ;\n }\n # else * sd = * cm -> frame_to_show ;\n ret = 0 ;\n # endif vp9_clear_system_state ( ) ;\n return ret ;\n }", "idx": 1611}
{"hash": 4489017523191997023, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h225_CapacityReportingCapability ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_CapacityReportingCapability , CapacityReportingCapability_sequence ) ;\n return offset ;\n }", "idx": 1612}
{"hash": -1361752047994420669, "project": "debian", "size": 7, "label": 0, "functionSource": "int MDC2_Init ( MDC2_CTX * c ) {\n c -> num = 0 ;\n c -> pad_type = 1 ;\n memset ( & ( c -> h [ 0 ] ) , 0x52 , MDC2_BLOCK ) ;\n memset ( & ( c -> hh [ 0 ] ) , 0x25 , MDC2_BLOCK ) ;\n return 1 ;\n }", "idx": 1613}
{"hash": 2755982813601944893, "project": "debian", "size": 3, "label": 0, "functionSource": "static void memset_float ( float * buf , float val , int size ) {\n while ( size -- ) * buf ++ = val ;\n }", "idx": 1614}
{"hash": 2335222688263906532, "project": "debian", "size": 14, "label": 0, "functionSource": "static inline void rv34_pred_b_vector ( int A [ 2 ] , int B [ 2 ] , int C [ 2 ] , int A_avail , int B_avail , int C_avail , int * mx , int * my ) {\n if ( A_avail + B_avail + C_avail != 3 ) {\n * mx = A [ 0 ] + B [ 0 ] + C [ 0 ] ;\n * my = A [ 1 ] + B [ 1 ] + C [ 1 ] ;\n if ( A_avail + B_avail + C_avail == 2 ) {\n * mx /= 2 ;\n * my /= 2 ;\n }\n }\n else {\n * mx = mid_pred ( A [ 0 ] , B [ 0 ] , C [ 0 ] ) ;\n * my = mid_pred ( A [ 1 ] , B [ 1 ] , C [ 1 ] ) ;\n }\n }", "idx": 1615}
{"hash": -7549575329765818478, "project": "debian", "size": 3, "label": 0, "functionSource": "char * curl_escape ( const char * string , int inlength ) {\n return curl_easy_escape ( NULL , string , inlength ) ;\n }", "idx": 1616}
{"hash": -2607754285145856562, "project": "debian", "size": 9, "label": 0, "functionSource": "static int zisofs_rewind_boot_file ( struct archive_write * a ) {\n struct iso9660 * iso9660 = a -> format_data ;\n if ( iso9660 -> el_torito . boot -> file -> zisofs . header_size != 0 ) {\n archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , \"We cannot extract the zisofs imaged boot file;\n\" \" this may not boot in being zisofs imaged\" ) ;\n return ( ARCHIVE_FAILED ) ;\n }\n return ( ARCHIVE_OK ) ;\n }", "idx": 1617}
{"hash": -7237039260294671485, "project": "debian", "size": 7, "label": 0, "functionSource": "static void nlm_match_fhandle_request ( packet_info * pinfo , proto_tree * tree ) {\n nlm_msg_res_matched_data * md ;\n md = ( nlm_msg_res_matched_data * ) g_hash_table_lookup ( nlm_msg_res_matched , GINT_TO_POINTER ( pinfo -> fd -> num ) ) ;\n if ( md && md -> rep_frame ) {\n dissect_fhandle_hidden ( pinfo , tree , md -> rep_frame ) ;\n }\n }", "idx": 1618}
{"hash": 8281630545066492937, "project": "debian", "size": 4, "label": 0, "functionSource": "static int nb_add_time ( char * * ret_buffer , size_t * ret_buffer_len , uint16_t type , double value ) {\n uint64_t cdtime_value = ( uint64_t ) ( value * 1073741824.0 ) ;\n return ( nb_add_number ( ret_buffer , ret_buffer_len , type , cdtime_value ) ) ;\n }", "idx": 1619}
{"hash": -5992472514718425579, "project": "debian", "size": 6, "label": 0, "functionSource": "static char * lxc_cgroup_get_hierarchy_path_data ( const char * subsystem , struct cgfs_data * d ) {\n struct cgroup_process_info * info = d -> info ;\n info = find_info_for_subsystem ( info , subsystem ) ;\n if ( ! info ) return NULL ;\n return info -> cgroup_path ;\n }", "idx": 1620}
{"hash": -6351630154286607278, "project": "debian", "size": 8, "label": 0, "functionSource": "struct ifblock * compiler_create_ifelseblock ( struct condition * conds , struct block * blk , struct block * elseblk ) {\n struct ifblock * ifblk ;\n SAFE_CALLOC ( ifblk , 1 , sizeof ( struct ifblock ) ) ;\n ifblk -> conds = conds ;\n ifblk -> blk = blk ;\n ifblk -> elseblk = elseblk ;\n return ifblk ;\n }", "idx": 1621}
{"hash": 8953904005695962093, "project": "debian", "size": 67, "label": 0, "functionSource": "static int xan_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n AVFrame * frame = data ;\n const uint8_t * buf = avpkt -> data ;\n int ret , buf_size = avpkt -> size ;\n XanContext * s = avctx -> priv_data ;\n GetByteContext ctx ;\n int tag = 0 ;\n bytestream2_init ( & ctx , buf , buf_size ) ;\n while ( bytestream2_get_bytes_left ( & ctx ) > 8 && tag != VGA__TAG ) {\n unsigned * tmpptr ;\n uint32_t new_pal ;\n int size ;\n int i ;\n tag = bytestream2_get_le32 ( & ctx ) ;\n size = bytestream2_get_be32 ( & ctx ) ;\n size = FFMIN ( size , bytestream2_get_bytes_left ( & ctx ) ) ;\n switch ( tag ) {\n case PALT_TAG : if ( size < PALETTE_SIZE ) return AVERROR_INVALIDDATA ;\n if ( s -> palettes_count >= PALETTES_MAX ) return AVERROR_INVALIDDATA ;\n tmpptr = av_realloc ( s -> palettes , ( s -> palettes_count + 1 ) * AVPALETTE_SIZE ) ;\n if ( ! tmpptr ) return AVERROR ( ENOMEM ) ;\n s -> palettes = tmpptr ;\n tmpptr += s -> palettes_count * AVPALETTE_COUNT ;\n for ( i = 0 ;\n i < PALETTE_COUNT ;\n i ++ ) {\n # if RUNTIME_GAMMA int r = gamma_corr ( bytestream2_get_byteu ( & ctx ) ) ;\n int g = gamma_corr ( bytestream2_get_byteu ( & ctx ) ) ;\n int b = gamma_corr ( bytestream2_get_byteu ( & ctx ) ) ;\n # else int r = gamma_lookup [ bytestream2_get_byteu ( & ctx ) ] ;\n int g = gamma_lookup [ bytestream2_get_byteu ( & ctx ) ] ;\n int b = gamma_lookup [ bytestream2_get_byteu ( & ctx ) ] ;\n # endif * tmpptr ++ = ( r << 16 ) | ( g << 8 ) | b ;\n }\n s -> palettes_count ++ ;\n break ;\n case SHOT_TAG : if ( size < 4 ) return AVERROR_INVALIDDATA ;\n new_pal = bytestream2_get_le32 ( & ctx ) ;\n if ( new_pal < s -> palettes_count ) {\n s -> cur_palette = new_pal ;\n }\n else av_log ( avctx , AV_LOG_ERROR , \"Invalid palette selected\\n\" ) ;\n break ;\n case VGA__TAG : break ;\n default : bytestream2_skip ( & ctx , size ) ;\n break ;\n }\n }\n buf_size = bytestream2_get_bytes_left ( & ctx ) ;\n if ( s -> palettes_count <= 0 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"No palette found\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( ( ret = ff_get_buffer ( avctx , frame , AV_GET_BUFFER_FLAG_REF ) ) ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n if ( ! s -> frame_size ) s -> frame_size = frame -> linesize [ 0 ] * s -> avctx -> height ;\n memcpy ( frame -> data [ 1 ] , s -> palettes + s -> cur_palette * AVPALETTE_COUNT , AVPALETTE_SIZE ) ;\n s -> buf = ctx . buffer ;\n s -> size = buf_size ;\n if ( xan_wc3_decode_frame ( s , frame ) < 0 ) return AVERROR_INVALIDDATA ;\n av_frame_unref ( & s -> last_frame ) ;\n if ( ( ret = av_frame_ref ( & s -> last_frame , frame ) ) < 0 ) return ret ;\n * got_frame = 1 ;\n return buf_size ;\n }", "idx": 1622}
{"hash": 4489017523191997023, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h225_IA5String_SIZE_1_512 ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_IA5String ( tvb , offset , actx , tree , hf_index , 1 , 512 , FALSE ) ;\n return offset ;\n }", "idx": 1623}
{"hash": -5992472514718425579, "project": "debian", "size": 10, "label": 0, "functionSource": "static struct cgroup_hierarchy * lxc_cgroup_find_hierarchy ( struct cgroup_meta_data * meta_data , const char * subsystem ) {\n size_t i ;\n for ( i = 0 ;\n i <= meta_data -> maximum_hierarchy ;\n i ++ ) {\n struct cgroup_hierarchy * h = meta_data -> hierarchies [ i ] ;\n if ( h && lxc_string_in_array ( subsystem , ( const char * * ) h -> subsystems ) ) return h ;\n }\n return NULL ;\n }", "idx": 1624}
{"hash": 1286774465219423144, "project": "debian", "size": 18, "label": 0, "functionSource": "static int jbig2_find_changing_element ( const byte * line , uint32_t x , uint32_t w ) {\n int a , b ;\n if ( line == 0 ) return ( int ) w ;\n if ( x == MINUS1 ) {\n a = 0 ;\n x = 0 ;\n }\n else {\n a = getbit ( line , x ) ;\n x ++ ;\n }\n while ( x < w ) {\n b = getbit ( line , x ) ;\n if ( a != b ) break ;\n x ++ ;\n }\n return x ;\n }", "idx": 1625}
{"hash": 1760449185745615462, "project": "debian", "size": 4, "label": 0, "functionSource": "const char * TSMatcherParseSrcIPConfigLine ( char * line , TSMatcherLine ml ) {\n sdk_assert ( sdk_sanity_check_null_ptr ( ( void * ) line ) == TS_SUCCESS ) ;\n return parseConfigLine ( line , ( matcher_line * ) ml , & ip_allow_src_tags ) ;\n }", "idx": 1626}
{"hash": 5357882892791796049, "project": "debian", "size": 30, "label": 0, "functionSource": "static bool e1000e_do_ps ( E1000ECore * core , struct NetRxPkt * pkt , size_t * hdr_len ) {\n bool isip4 , isip6 , isudp , istcp ;\n bool fragment ;\n if ( ! e1000e_rx_use_ps_descriptor ( core ) ) {\n return false ;\n }\n net_rx_pkt_get_protocols ( pkt , & isip4 , & isip6 , & isudp , & istcp ) ;\n if ( isip4 ) {\n fragment = net_rx_pkt_get_ip4_info ( pkt ) -> fragment ;\n }\n else if ( isip6 ) {\n fragment = net_rx_pkt_get_ip6_info ( pkt ) -> fragment ;\n }\n else {\n return false ;\n }\n if ( fragment && ( core -> mac [ RFCTL ] & E1000_RFCTL_IPFRSP_DIS ) ) {\n return false ;\n }\n if ( ! fragment && ( isudp || istcp ) ) {\n * hdr_len = net_rx_pkt_get_l5_hdr_offset ( pkt ) ;\n }\n else {\n * hdr_len = net_rx_pkt_get_l4_hdr_offset ( pkt ) ;\n }\n if ( ( * hdr_len > core -> rxbuf_sizes [ 0 ] ) || ( * hdr_len > net_rx_pkt_get_total_len ( pkt ) ) ) {\n return false ;\n }\n return true ;\n }", "idx": 1627}
{"hash": -5262394088289559608, "project": "debian", "size": 5, "label": 0, "functionSource": "static void arm_thistimer_write ( void * opaque , hwaddr addr , uint64_t value , unsigned size ) {\n ARMMPTimerState * s = ( ARMMPTimerState * ) opaque ;\n int id = get_current_cpu ( s ) ;\n timerblock_write ( & s -> timerblock [ id ] , addr , value , size ) ;\n }", "idx": 1628}
{"hash": 455172021572601154, "project": "debian", "size": 29, "label": 0, "functionSource": "int match_pattern ( const char * s , const char * pattern ) {\n for ( ;\n ;\n ) {\n if ( ! * pattern ) return ( ! * s ) ;\n if ( * pattern == '*' ) {\n pattern ++ ;\n if ( ! * pattern ) return ( 1 ) ;\n if ( * pattern != '?' && * pattern != '*' ) {\n for ( ;\n * s ;\n s ++ ) {\n if ( * s == * pattern && match_pattern ( s + 1 , pattern + 1 ) ) return ( 1 ) ;\n }\n return ( 0 ) ;\n }\n for ( ;\n * s ;\n s ++ ) {\n if ( match_pattern ( s , pattern ) ) return ( 1 ) ;\n }\n return ( 0 ) ;\n }\n if ( ! * s ) return ( 0 ) ;\n if ( * pattern != '?' && * pattern != * s ) return ( 0 ) ;\n s ++ ;\n pattern ++ ;\n }\n }", "idx": 1629}
{"hash": 1676654288894940649, "project": "debian", "size": 35, "label": 0, "functionSource": "void kadmin_getstrings ( int argc , char * argv [ ] ) {\n kadm5_ret_t retval ;\n char * pname , * canon = NULL ;\n krb5_principal princ = NULL ;\n krb5_string_attr * strings = NULL ;\n int count , i ;\n if ( argc != 2 ) {\n fprintf ( stderr , _ ( \"usage: get_strings principal\\n\" ) ) ;\n return ;\n }\n pname = argv [ 1 ] ;\n retval = kadmin_parse_name ( pname , & princ ) ;\n if ( retval ) {\n com_err ( \"get_strings\" , retval , _ ( \"while parsing principal\" ) ) ;\n return ;\n }\n retval = krb5_unparse_name ( context , princ , & canon ) ;\n if ( retval ) {\n com_err ( \"get_strings\" , retval , _ ( \"while canonicalizing principal\" ) ) ;\n goto cleanup ;\n }\n retval = kadm5_get_strings ( handle , princ , & strings , & count ) ;\n if ( retval ) {\n com_err ( \"get_strings\" , retval , _ ( \"while getting attributes for principal \\\"%s\\\"\" ) , canon ) ;\n goto cleanup ;\n }\n if ( count == 0 ) printf ( _ ( \"(No string attributes.)\\n\" ) ) ;\n for ( i = 0 ;\n i < count ;\n i ++ ) printf ( \"%s: %s\\n\" , strings [ i ] . key , strings [ i ] . value ) ;\n kadm5_free_strings ( handle , strings , count ) ;\n cleanup : krb5_free_principal ( context , princ ) ;\n free ( canon ) ;\n return ;\n }", "idx": 1630}
{"hash": 8218188955508624394, "project": "debian", "size": 66, "label": 0, "functionSource": "static int read_major_sync ( MLPDecodeContext * m , GetBitContext * gb ) {\n MLPHeaderInfo mh ;\n int substr , ret ;\n if ( ( ret = ff_mlp_read_major_sync ( m -> avctx , & mh , gb ) ) != 0 ) return ret ;\n if ( mh . group1_bits == 0 ) {\n av_log ( m -> avctx , AV_LOG_ERROR , \"invalid/unknown bits per sample\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( mh . group2_bits > mh . group1_bits ) {\n av_log ( m -> avctx , AV_LOG_ERROR , \"Channel group 2 cannot have more bits per sample than group 1.\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( mh . group2_samplerate && mh . group2_samplerate != mh . group1_samplerate ) {\n av_log ( m -> avctx , AV_LOG_ERROR , \"Channel groups with differing sample rates are not currently supported.\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( mh . group1_samplerate == 0 ) {\n av_log ( m -> avctx , AV_LOG_ERROR , \"invalid/unknown sampling rate\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( mh . group1_samplerate > MAX_SAMPLERATE ) {\n av_log ( m -> avctx , AV_LOG_ERROR , \"Sampling rate %d is greater than the supported maximum (%d).\\n\" , mh . group1_samplerate , MAX_SAMPLERATE ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( mh . access_unit_size > MAX_BLOCKSIZE ) {\n av_log ( m -> avctx , AV_LOG_ERROR , \"Block size %d is greater than the supported maximum (%d).\\n\" , mh . access_unit_size , MAX_BLOCKSIZE ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( mh . access_unit_size_pow2 > MAX_BLOCKSIZE_POW2 ) {\n av_log ( m -> avctx , AV_LOG_ERROR , \"Block size pow2 %d is greater than the supported maximum (%d).\\n\" , mh . access_unit_size_pow2 , MAX_BLOCKSIZE_POW2 ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( mh . num_substreams == 0 ) return AVERROR_INVALIDDATA ;\n if ( m -> avctx -> codec_id == AV_CODEC_ID_MLP && mh . num_substreams > 2 ) {\n av_log ( m -> avctx , AV_LOG_ERROR , \"MLP only supports up to 2 substreams.\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( mh . num_substreams > MAX_SUBSTREAMS ) {\n av_log_ask_for_sample ( m -> avctx , \"Number of substreams %d is larger than the maximum supported \" \"by the decoder.\\n\" , mh . num_substreams ) ;\n return AVERROR_PATCHWELCOME ;\n }\n m -> access_unit_size = mh . access_unit_size ;\n m -> access_unit_size_pow2 = mh . access_unit_size_pow2 ;\n m -> num_substreams = mh . num_substreams ;\n m -> max_decoded_substream = m -> num_substreams - 1 ;\n m -> avctx -> sample_rate = mh . group1_samplerate ;\n m -> avctx -> frame_size = mh . access_unit_size ;\n m -> avctx -> bits_per_raw_sample = mh . group1_bits ;\n if ( mh . group1_bits > 16 ) m -> avctx -> sample_fmt = AV_SAMPLE_FMT_S32 ;\n else m -> avctx -> sample_fmt = AV_SAMPLE_FMT_S16 ;\n m -> params_valid = 1 ;\n for ( substr = 0 ;\n substr < MAX_SUBSTREAMS ;\n substr ++ ) m -> substream [ substr ] . restart_seen = 0 ;\n if ( m -> avctx -> codec_id == AV_CODEC_ID_MLP ) {\n if ( ( substr = ( mh . num_substreams > 1 ) ) ) m -> substream [ 0 ] . ch_layout = AV_CH_LAYOUT_STEREO ;\n m -> substream [ substr ] . ch_layout = mh . channel_layout_mlp ;\n }\n else {\n if ( ( substr = ( mh . num_substreams > 1 ) ) ) m -> substream [ 0 ] . ch_layout = AV_CH_LAYOUT_STEREO ;\n if ( mh . num_substreams > 2 ) if ( mh . channel_layout_thd_stream2 ) m -> substream [ 2 ] . ch_layout = mh . channel_layout_thd_stream2 ;\n else m -> substream [ 2 ] . ch_layout = mh . channel_layout_thd_stream1 ;\n m -> substream [ substr ] . ch_layout = mh . channel_layout_thd_stream1 ;\n }\n return 0 ;\n }", "idx": 1631}
{"hash": 594127775011357110, "project": "debian", "size": 152, "label": 0, "functionSource": "static void ImportCMYKAQuantum ( const Image * image , QuantumInfo * quantum_info , const MagickSizeType number_pixels , const unsigned char * magick_restrict p , Quantum * magick_restrict q , ExceptionInfo * exception ) {\n QuantumAny range ;\n register ssize_t x ;\n unsigned int pixel ;\n if ( image -> colorspace != CMYKColorspace ) {\n ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , ImageError , \"ColorSeparatedImageRequired\" , \"`%s'\" , image -> filename ) ;\n return ;\n }\n switch ( quantum_info -> depth ) {\n case 8 : {\n unsigned char pixel ;\n for ( x = 0 ;\n x < ( ssize_t ) number_pixels ;\n x ++ ) {\n p = PushCharPixel ( p , & pixel ) ;\n SetPixelRed ( image , ScaleCharToQuantum ( pixel ) , q ) ;\n p = PushCharPixel ( p , & pixel ) ;\n SetPixelGreen ( image , ScaleCharToQuantum ( pixel ) , q ) ;\n p = PushCharPixel ( p , & pixel ) ;\n SetPixelBlue ( image , ScaleCharToQuantum ( pixel ) , q ) ;\n p = PushCharPixel ( p , & pixel ) ;\n SetPixelBlack ( image , ScaleCharToQuantum ( pixel ) , q ) ;\n p = PushCharPixel ( p , & pixel ) ;\n SetPixelAlpha ( image , ScaleCharToQuantum ( pixel ) , q ) ;\n p += quantum_info -> pad ;\n q += GetPixelChannels ( image ) ;\n }\n break ;\n }\n case 16 : {\n unsigned short pixel ;\n if ( quantum_info -> format == FloatingPointQuantumFormat ) {\n for ( x = 0 ;\n x < ( ssize_t ) number_pixels ;\n x ++ ) {\n p = PushShortPixel ( quantum_info -> endian , p , & pixel ) ;\n SetPixelRed ( image , ClampToQuantum ( QuantumRange * HalfToSinglePrecision ( pixel ) ) , q ) ;\n p = PushShortPixel ( quantum_info -> endian , p , & pixel ) ;\n SetPixelGreen ( image , ClampToQuantum ( QuantumRange * HalfToSinglePrecision ( pixel ) ) , q ) ;\n p = PushShortPixel ( quantum_info -> endian , p , & pixel ) ;\n SetPixelBlue ( image , ClampToQuantum ( QuantumRange * HalfToSinglePrecision ( pixel ) ) , q ) ;\n p = PushShortPixel ( quantum_info -> endian , p , & pixel ) ;\n SetPixelBlack ( image , ClampToQuantum ( QuantumRange * HalfToSinglePrecision ( pixel ) ) , q ) ;\n p = PushShortPixel ( quantum_info -> endian , p , & pixel ) ;\n SetPixelAlpha ( image , ClampToQuantum ( QuantumRange * HalfToSinglePrecision ( pixel ) ) , q ) ;\n p += quantum_info -> pad ;\n q += GetPixelChannels ( image ) ;\n }\n break ;\n }\n for ( x = 0 ;\n x < ( ssize_t ) number_pixels ;\n x ++ ) {\n p = PushShortPixel ( quantum_info -> endian , p , & pixel ) ;\n SetPixelRed ( image , ScaleShortToQuantum ( pixel ) , q ) ;\n p = PushShortPixel ( quantum_info -> endian , p , & pixel ) ;\n SetPixelGreen ( image , ScaleShortToQuantum ( pixel ) , q ) ;\n p = PushShortPixel ( quantum_info -> endian , p , & pixel ) ;\n SetPixelBlue ( image , ScaleShortToQuantum ( pixel ) , q ) ;\n p = PushShortPixel ( quantum_info -> endian , p , & pixel ) ;\n SetPixelBlack ( image , ScaleShortToQuantum ( pixel ) , q ) ;\n p = PushShortPixel ( quantum_info -> endian , p , & pixel ) ;\n SetPixelAlpha ( image , ScaleShortToQuantum ( pixel ) , q ) ;\n p += quantum_info -> pad ;\n q += GetPixelChannels ( image ) ;\n }\n break ;\n }\n case 32 : {\n unsigned int pixel ;\n if ( quantum_info -> format == FloatingPointQuantumFormat ) {\n float pixel ;\n for ( x = 0 ;\n x < ( ssize_t ) number_pixels ;\n x ++ ) {\n p = PushFloatPixel ( quantum_info , p , & pixel ) ;\n SetPixelRed ( image , ClampToQuantum ( pixel ) , q ) ;\n p = PushFloatPixel ( quantum_info , p , & pixel ) ;\n SetPixelGreen ( image , ClampToQuantum ( pixel ) , q ) ;\n p = PushFloatPixel ( quantum_info , p , & pixel ) ;\n SetPixelBlue ( image , ClampToQuantum ( pixel ) , q ) ;\n p = PushFloatPixel ( quantum_info , p , & pixel ) ;\n SetPixelBlack ( image , ClampToQuantum ( pixel ) , q ) ;\n p = PushFloatPixel ( quantum_info , p , & pixel ) ;\n SetPixelAlpha ( image , ClampToQuantum ( pixel ) , q ) ;\n p += quantum_info -> pad ;\n q += GetPixelChannels ( image ) ;\n }\n break ;\n }\n for ( x = 0 ;\n x < ( ssize_t ) number_pixels ;\n x ++ ) {\n p = PushLongPixel ( quantum_info -> endian , p , & pixel ) ;\n SetPixelRed ( image , ScaleLongToQuantum ( pixel ) , q ) ;\n p = PushLongPixel ( quantum_info -> endian , p , & pixel ) ;\n SetPixelGreen ( image , ScaleLongToQuantum ( pixel ) , q ) ;\n p = PushLongPixel ( quantum_info -> endian , p , & pixel ) ;\n SetPixelBlue ( image , ScaleLongToQuantum ( pixel ) , q ) ;\n p = PushLongPixel ( quantum_info -> endian , p , & pixel ) ;\n SetPixelBlack ( image , ScaleLongToQuantum ( pixel ) , q ) ;\n p = PushLongPixel ( quantum_info -> endian , p , & pixel ) ;\n SetPixelAlpha ( image , ScaleLongToQuantum ( pixel ) , q ) ;\n p += quantum_info -> pad ;\n q += GetPixelChannels ( image ) ;\n }\n break ;\n }\n case 64 : {\n if ( quantum_info -> format == FloatingPointQuantumFormat ) {\n double pixel ;\n for ( x = 0 ;\n x < ( ssize_t ) number_pixels ;\n x ++ ) {\n p = PushDoublePixel ( quantum_info , p , & pixel ) ;\n SetPixelRed ( image , ClampToQuantum ( pixel ) , q ) ;\n p = PushDoublePixel ( quantum_info , p , & pixel ) ;\n SetPixelGreen ( image , ClampToQuantum ( pixel ) , q ) ;\n p = PushDoublePixel ( quantum_info , p , & pixel ) ;\n SetPixelBlue ( image , ClampToQuantum ( pixel ) , q ) ;\n p = PushDoublePixel ( quantum_info , p , & pixel ) ;\n SetPixelBlack ( image , ClampToQuantum ( pixel ) , q ) ;\n p = PushDoublePixel ( quantum_info , p , & pixel ) ;\n SetPixelAlpha ( image , ClampToQuantum ( pixel ) , q ) ;\n p = PushDoublePixel ( quantum_info , p , & pixel ) ;\n p += quantum_info -> pad ;\n q += GetPixelChannels ( image ) ;\n }\n break ;\n }\n }\n default : {\n range = GetQuantumRange ( quantum_info -> depth ) ;\n for ( x = 0 ;\n x < ( ssize_t ) number_pixels ;\n x ++ ) {\n p = PushQuantumPixel ( quantum_info , p , & pixel ) ;\n SetPixelRed ( image , ScaleAnyToQuantum ( pixel , range ) , q ) ;\n p = PushQuantumPixel ( quantum_info , p , & pixel ) ;\n SetPixelGreen ( image , ScaleAnyToQuantum ( pixel , range ) , q ) ;\n p = PushQuantumPixel ( quantum_info , p , & pixel ) ;\n SetPixelBlue ( image , ScaleAnyToQuantum ( pixel , range ) , q ) ;\n p = PushQuantumPixel ( quantum_info , p , & pixel ) ;\n SetPixelBlack ( image , ScaleAnyToQuantum ( pixel , range ) , q ) ;\n p = PushQuantumPixel ( quantum_info , p , & pixel ) ;\n SetPixelAlpha ( image , ScaleAnyToQuantum ( pixel , range ) , q ) ;\n q += GetPixelChannels ( image ) ;\n }\n break ;\n }\n }\n }", "idx": 1632}
{"hash": 4180964683905830761, "project": "debian", "size": 12, "label": 0, "functionSource": "static int selinux_syslog ( int type ) {\n int rc ;\n switch ( type ) {\n case SYSLOG_ACTION_READ_ALL : case SYSLOG_ACTION_SIZE_BUFFER : rc = task_has_system ( current , SYSTEM__SYSLOG_READ ) ;\n break ;\n case SYSLOG_ACTION_CONSOLE_OFF : case SYSLOG_ACTION_CONSOLE_ON : case SYSLOG_ACTION_CONSOLE_LEVEL : rc = task_has_system ( current , SYSTEM__SYSLOG_CONSOLE ) ;\n break ;\n case SYSLOG_ACTION_CLOSE : case SYSLOG_ACTION_OPEN : case SYSLOG_ACTION_READ : case SYSLOG_ACTION_READ_CLEAR : case SYSLOG_ACTION_CLEAR : default : rc = task_has_system ( current , SYSTEM__SYSLOG_MOD ) ;\n break ;\n }\n return rc ;\n }", "idx": 1633}
{"hash": -483869641057106085, "project": "debian", "size": 51, "label": 0, "functionSource": "extern int as_mysql_flush_jobs_on_cluster ( mysql_conn_t * mysql_conn , time_t event_time ) {\n int rc = SLURM_SUCCESS ;\n MYSQL_RES * result = NULL ;\n MYSQL_ROW row ;\n char * query = NULL ;\n char * id_char = NULL ;\n char * suspended_char = NULL ;\n if ( check_connection ( mysql_conn ) != SLURM_SUCCESS ) return ESLURM_DB_CONNECTION ;\n query = xstrdup_printf ( \"select distinct t1.job_db_inx, t1.state from \\\"%s_%s\\\" \" \"as t1 where t1.time_end=0;\n\" , mysql_conn -> cluster_name , job_table ) ;\n if ( debug_flags & DEBUG_FLAG_DB_JOB ) DB_DEBUG ( mysql_conn -> conn , \"query\\n%s\" , query ) ;\n if ( ! ( result = mysql_db_query_ret ( mysql_conn , query , 0 ) ) ) {\n xfree ( query ) ;\n return SLURM_ERROR ;\n }\n xfree ( query ) ;\n while ( ( row = mysql_fetch_row ( result ) ) ) {\n int state = slurm_atoul ( row [ 1 ] ) ;\n if ( state == JOB_SUSPENDED ) {\n if ( suspended_char ) xstrfmtcat ( suspended_char , \", %s\" , row [ 0 ] ) ;\n else xstrfmtcat ( suspended_char , \"job_db_inx in (%s\" , row [ 0 ] ) ;\n }\n if ( id_char ) xstrfmtcat ( id_char , \", %s\" , row [ 0 ] ) ;\n else xstrfmtcat ( id_char , \"job_db_inx in (%s\" , row [ 0 ] ) ;\n }\n mysql_free_result ( result ) ;\n if ( suspended_char ) {\n xstrfmtcat ( suspended_char , \")\" ) ;\n xstrfmtcat ( query , \"update \\\"%s_%s\\\" set \" \"time_suspended=%ld-time_suspended \" \"where %s;\n\" , mysql_conn -> cluster_name , job_table , event_time , suspended_char ) ;\n xstrfmtcat ( query , \"update \\\"%s_%s\\\" set \" \"time_suspended=%ld-time_suspended \" \"where %s;\n\" , mysql_conn -> cluster_name , step_table , event_time , suspended_char ) ;\n xstrfmtcat ( query , \"update \\\"%s_%s\\\" set time_end=%ld where (%s) \" \"&& time_end=0;\n\" , mysql_conn -> cluster_name , suspend_table , event_time , suspended_char ) ;\n xfree ( suspended_char ) ;\n }\n if ( id_char ) {\n xstrfmtcat ( id_char , \")\" ) ;\n xstrfmtcat ( query , \"update \\\"%s_%s\\\" set state=%d, \" \"time_end=%ld where %s;\n\" , mysql_conn -> cluster_name , job_table , JOB_CANCELLED , event_time , id_char ) ;\n xstrfmtcat ( query , \"update \\\"%s_%s\\\" set state=%d, \" \"time_end=%ld where %s;\n\" , mysql_conn -> cluster_name , step_table , JOB_CANCELLED , event_time , id_char ) ;\n xfree ( id_char ) ;\n }\n if ( query ) {\n if ( debug_flags & DEBUG_FLAG_DB_JOB ) DB_DEBUG ( mysql_conn -> conn , \"query\\n%s\" , query ) ;\n rc = mysql_db_query ( mysql_conn , query ) ;\n xfree ( query ) ;\n }\n return rc ;\n }", "idx": 1634}
{"hash": 416708768813973469, "project": "chrome", "size": 16, "label": 0, "functionSource": "TEST_F ( TemplateURLParserTest , TestFirefoxYahoo ) {\n ParamFilterImpl filter ( std : : string ( ) , \"Mozilla\" ) ;\n ASSERT_NO_FATAL_FAILURE ( ParseFile ( \"firefox_yahoo.xml\" , & filter ) ) ;\n ASSERT_TRUE ( template_url_ ) ;\n EXPECT_EQ ( ASCIIToUTF16 ( \"Yahoo\" ) , template_url_ -> short_name ( ) ) ;\n EXPECT_TRUE ( template_url_ -> url_ref ( ) . SupportsReplacement ( SearchTermsData ( ) ) ) ;\n EXPECT_EQ ( \"http://ff.search.yahoo.com/gossip?\" \"output=fxjson&command={\nsearchTerms}\n\" , template_url_ -> suggestions_url ( ) ) ;\n EXPECT_EQ ( \"http://search.yahoo.com/search?p={\nsearchTerms}\n&ei=UTF-8\" , template_url_ -> url ( ) ) ;\n ASSERT_EQ ( 1U , template_url_ -> input_encodings ( ) . size ( ) ) ;\n EXPECT_EQ ( \"UTF-8\" , template_url_ -> input_encodings ( ) [ 0 ] ) ;\n EXPECT_EQ ( GURL ( \"http://search.yahoo.com/favicon.ico\" ) , template_url_ -> favicon_url ( ) ) ;\n }", "idx": 1635}
{"hash": 330507736709312787, "project": "chrome", "size": 3, "label": 0, "functionSource": "void _hb_graphite2_shaper_font_data_destroy ( hb_graphite2_shaper_font_data_t * data ) {\n gr_font_destroy ( data ) ;\n }", "idx": 1636}
{"hash": -1768728156572022708, "project": "debian", "size": 16, "label": 1, "functionSource": "static int jbig2_word_stream_buf_get_next_word ( Jbig2WordStream * self , int offset , uint32_t * word ) {\n Jbig2WordStreamBuf * z = ( Jbig2WordStreamBuf * ) self ;\n const byte * data = z -> data ;\n uint32_t result ;\n if ( offset + 4 < z -> size ) result = ( data [ offset ] << 24 ) | ( data [ offset + 1 ] << 16 ) | ( data [ offset + 2 ] << 8 ) | data [ offset + 3 ] ;\n else if ( offset > z -> size ) return - 1 ;\n else {\n int i ;\n result = 0 ;\n for ( i = 0 ;\n i < z -> size - offset ;\n i ++ ) result |= data [ offset + i ] << ( ( 3 - i ) << 3 ) ;\n }\n * word = result ;\n return 0 ;\n }", "idx": 1637}
{"hash": -4534372572324105488, "project": "debian", "size": 46, "label": 0, "functionSource": "static int check_stream_max_drift ( AVFormatContext * s ) {\n int64_t min_pos , pos ;\n int i ;\n int * idx = av_mallocz_array ( s -> nb_streams , sizeof ( * idx ) ) ;\n if ( ! idx ) return AVERROR ( ENOMEM ) ;\n for ( min_pos = pos = 0 ;\n min_pos != INT64_MAX ;\n pos = min_pos + 1LU ) {\n int64_t max_dts = INT64_MIN / 2 ;\n int64_t min_dts = INT64_MAX / 2 ;\n int64_t max_buffer = 0 ;\n min_pos = INT64_MAX ;\n for ( i = 0 ;\n i < s -> nb_streams ;\n i ++ ) {\n AVStream * st = s -> streams [ i ] ;\n AVIStream * ast = st -> priv_data ;\n int n = st -> nb_index_entries ;\n while ( idx [ i ] < n && st -> index_entries [ idx [ i ] ] . pos < pos ) idx [ i ] ++ ;\n if ( idx [ i ] < n ) {\n int64_t dts ;\n dts = av_rescale_q ( st -> index_entries [ idx [ i ] ] . timestamp / FFMAX ( ast -> sample_size , 1 ) , st -> time_base , AV_TIME_BASE_Q ) ;\n min_dts = FFMIN ( min_dts , dts ) ;\n min_pos = FFMIN ( min_pos , st -> index_entries [ idx [ i ] ] . pos ) ;\n }\n }\n for ( i = 0 ;\n i < s -> nb_streams ;\n i ++ ) {\n AVStream * st = s -> streams [ i ] ;\n AVIStream * ast = st -> priv_data ;\n if ( idx [ i ] && min_dts != INT64_MAX / 2 ) {\n int64_t dts ;\n dts = av_rescale_q ( st -> index_entries [ idx [ i ] - 1 ] . timestamp / FFMAX ( ast -> sample_size , 1 ) , st -> time_base , AV_TIME_BASE_Q ) ;\n max_dts = FFMAX ( max_dts , dts ) ;\n max_buffer = FFMAX ( max_buffer , av_rescale ( dts - min_dts , st -> codecpar -> bit_rate , AV_TIME_BASE ) ) ;\n }\n }\n if ( max_dts - min_dts > 2 * AV_TIME_BASE || max_buffer > 1024 * 1024 * 8 * 8 ) {\n av_free ( idx ) ;\n return 1 ;\n }\n }\n av_free ( idx ) ;\n return 0 ;\n }", "idx": 1638}
{"hash": -16551315108292821, "project": "debian", "size": 6, "label": 0, "functionSource": "gcry_sexp_t gcry_sexp_prepend ( const gcry_sexp_t a , const gcry_sexp_t n ) {\n ( void ) a ;\n ( void ) n ;\n BUG ( ) ;\n return NULL ;\n }", "idx": 1639}
{"hash": 1760449185745615462, "project": "debian", "size": 18, "label": 0, "functionSource": "TSReturnCode TSHttpTxnConfigIntSet ( TSHttpTxn txnp , TSOverridableConfigKey conf , TSMgmtInt value ) {\n sdk_assert ( sdk_sanity_check_txn ( txnp ) == TS_SUCCESS ) ;\n HttpSM * s = reinterpret_cast < HttpSM * > ( txnp ) ;\n OverridableDataType type ;\n s -> t_state . setup_per_txn_configs ( ) ;\n void * dest = _conf_to_memberp ( conf , s -> t_state . txn_conf , & type ) ;\n if ( ! dest ) {\n return TS_ERROR ;\n }\n switch ( type ) {\n case OVERRIDABLE_TYPE_INT : * ( static_cast < TSMgmtInt * > ( dest ) ) = value ;\n break ;\n case OVERRIDABLE_TYPE_BYTE : * ( static_cast < TSMgmtByte * > ( dest ) ) = static_cast < TSMgmtByte > ( value ) ;\n break ;\n default : return TS_ERROR ;\n }\n return TS_SUCCESS ;\n }", "idx": 1640}
{"hash": -1487877838474751244, "project": "debian", "size": 90, "label": 0, "functionSource": "static char * lookup_loc_range ( const char * loc_range , HashTable * hash_arr , int canonicalize TSRMLS_DC ) {\n int i = 0 ;\n int cur_arr_len = 0 ;\n int result = 0 ;\n char * lang_tag = NULL ;\n zval * * ele_value = NULL ;\n char * * cur_arr = NULL ;\n char * cur_loc_range = NULL ;\n char * can_loc_range = NULL ;\n int saved_pos = 0 ;\n char * return_value = NULL ;\n cur_arr = ecalloc ( zend_hash_num_elements ( hash_arr ) * 2 , sizeof ( char * ) ) ;\n for ( zend_hash_internal_pointer_reset ( hash_arr ) ;\n zend_hash_has_more_elements ( hash_arr ) == SUCCESS ;\n zend_hash_move_forward ( hash_arr ) ) {\n if ( zend_hash_get_current_data ( hash_arr , ( void * * ) & ele_value ) == FAILURE ) {\n continue ;\n }\n if ( Z_TYPE_PP ( ele_value ) != IS_STRING ) {\n intl_error_set ( NULL , U_ILLEGAL_ARGUMENT_ERROR , \"lookup_loc_range: locale array element is not a string\" , 0 TSRMLS_CC ) ;\n LOOKUP_CLEAN_RETURN ( NULL ) ;\n }\n cur_arr [ cur_arr_len * 2 ] = estrndup ( Z_STRVAL_PP ( ele_value ) , Z_STRLEN_PP ( ele_value ) ) ;\n result = strToMatch ( Z_STRVAL_PP ( ele_value ) , cur_arr [ cur_arr_len * 2 ] ) ;\n if ( result == 0 ) {\n intl_error_set ( NULL , U_ILLEGAL_ARGUMENT_ERROR , \"lookup_loc_range: unable to canonicalize lang_tag\" , 0 TSRMLS_CC ) ;\n LOOKUP_CLEAN_RETURN ( NULL ) ;\n }\n cur_arr [ cur_arr_len * 2 + 1 ] = Z_STRVAL_PP ( ele_value ) ;\n cur_arr_len ++ ;\n }\n if ( canonicalize ) {\n for ( i = 0 ;\n i < cur_arr_len ;\n i ++ ) {\n lang_tag = get_icu_value_internal ( cur_arr [ i * 2 ] , LOC_CANONICALIZE_TAG , & result , 0 ) ;\n if ( result != 1 || lang_tag == NULL || ! lang_tag [ 0 ] ) {\n if ( lang_tag ) {\n efree ( lang_tag ) ;\n }\n intl_error_set ( NULL , U_ILLEGAL_ARGUMENT_ERROR , \"lookup_loc_range: unable to canonicalize lang_tag\" , 0 TSRMLS_CC ) ;\n LOOKUP_CLEAN_RETURN ( NULL ) ;\n }\n cur_arr [ i * 2 ] = erealloc ( cur_arr [ i * 2 ] , strlen ( lang_tag ) + 1 ) ;\n result = strToMatch ( lang_tag , cur_arr [ i * 2 ] ) ;\n efree ( lang_tag ) ;\n if ( result == 0 ) {\n intl_error_set ( NULL , U_ILLEGAL_ARGUMENT_ERROR , \"lookup_loc_range: unable to canonicalize lang_tag\" , 0 TSRMLS_CC ) ;\n LOOKUP_CLEAN_RETURN ( NULL ) ;\n }\n }\n }\n if ( canonicalize ) {\n can_loc_range = get_icu_value_internal ( loc_range , LOC_CANONICALIZE_TAG , & result , 0 ) ;\n if ( result != 1 || can_loc_range == NULL || ! can_loc_range [ 0 ] ) {\n intl_error_set ( NULL , U_ILLEGAL_ARGUMENT_ERROR , \"lookup_loc_range: unable to canonicalize loc_range\" , 0 TSRMLS_CC ) ;\n if ( can_loc_range ) {\n efree ( can_loc_range ) ;\n }\n LOOKUP_CLEAN_RETURN ( NULL ) ;\n }\n else {\n loc_range = can_loc_range ;\n }\n }\n cur_loc_range = ecalloc ( 1 , strlen ( loc_range ) + 1 ) ;\n result = strToMatch ( loc_range , cur_loc_range ) ;\n if ( can_loc_range ) {\n efree ( can_loc_range ) ;\n }\n if ( result == 0 ) {\n intl_error_set ( NULL , U_ILLEGAL_ARGUMENT_ERROR , \"lookup_loc_range: unable to canonicalize lang_tag\" , 0 TSRMLS_CC ) ;\n LOOKUP_CLEAN_RETURN ( NULL ) ;\n }\n saved_pos = strlen ( cur_loc_range ) ;\n while ( saved_pos > 0 ) {\n for ( i = 0 ;\n i < cur_arr_len ;\n i ++ ) {\n if ( cur_arr [ i * 2 ] != NULL && strlen ( cur_arr [ i * 2 ] ) == saved_pos && strncmp ( cur_loc_range , cur_arr [ i * 2 ] , saved_pos ) == 0 ) {\n return_value = estrdup ( canonicalize ? cur_arr [ i * 2 ] : cur_arr [ i * 2 + 1 ] ) ;\n efree ( cur_loc_range ) ;\n LOOKUP_CLEAN_RETURN ( return_value ) ;\n }\n }\n saved_pos = getStrrtokenPos ( cur_loc_range , saved_pos ) ;\n }\n efree ( cur_loc_range ) ;\n LOOKUP_CLEAN_RETURN ( NULL ) ;\n }", "idx": 1641}
{"hash": -673406620978847526, "project": "chrome", "size": 6, "label": 0, "functionSource": "TEST_F ( WebFrameTest , GetCanonicalUrlForSharing ) {\n FrameTestHelpers : : WebViewHelper web_view_helper ;\n web_view_helper . Initialize ( ) ;\n WebLocalFrameImpl * frame = web_view_helper . LocalMainFrame ( ) ;\n FrameTestHelpers : : LoadHTMLString ( frame , R \"( < head > < link rel = \"canonical\" href = \"https://example.com/canonical.html\" > < / head > ) \", ToKURL(\" https : EXPECT_EQ ( WebURL ( ToKURL ( \"https://example.com/canonical.html\" ) ) , frame -> GetDocument ( ) . CanonicalUrlForSharing ( ) ) ;\n }", "idx": 1642}
{"hash": -6579823731174944595, "project": "debian", "size": 7, "label": 1, "functionSource": "void * xcalloc ( size_t num , size_t size ) {\n void * ptr = malloc ( num * size ) ;\n if ( ptr ) {\n memset ( ptr , '\\0' , ( num * size ) ) ;\n }\n return ptr ;\n }", "idx": 1643}
{"hash": 6393050609822897742, "project": "debian", "size": 9, "label": 0, "functionSource": "static bool xhci_port_have_device ( XHCIPort * port ) {\n if ( ! port -> uport -> dev || ! port -> uport -> dev -> attached ) {\n return false ;\n }\n if ( ! ( ( 1 << port -> uport -> dev -> speed ) & port -> speedmask ) ) {\n return false ;\n }\n return true ;\n }", "idx": 1644}
{"hash": 6080147530626246065, "project": "debian", "size": 50, "label": 1, "functionSource": "static inline void vc1_pred_b_mv_intfi ( VC1Context * v , int n , int * dmv_x , int * dmv_y , int mv1 , int * pred_flag ) {\n int dir = ( v -> bmvtype == BMV_TYPE_BACKWARD ) ? 1 : 0 ;\n MpegEncContext * s = & v -> s ;\n int mb_pos = s -> mb_x + s -> mb_y * s -> mb_stride ;\n if ( v -> bmvtype == BMV_TYPE_DIRECT ) {\n int total_opp , k , f ;\n if ( s -> next_picture . f . mb_type [ mb_pos + v -> mb_off ] != MB_TYPE_INTRA ) {\n s -> mv [ 0 ] [ 0 ] [ 0 ] = scale_mv ( s -> next_picture . f . motion_val [ 1 ] [ s -> block_index [ 0 ] + v -> blocks_off ] [ 0 ] , v -> bfraction , 0 , s -> quarter_sample ) ;\n s -> mv [ 0 ] [ 0 ] [ 1 ] = scale_mv ( s -> next_picture . f . motion_val [ 1 ] [ s -> block_index [ 0 ] + v -> blocks_off ] [ 1 ] , v -> bfraction , 0 , s -> quarter_sample ) ;\n s -> mv [ 1 ] [ 0 ] [ 0 ] = scale_mv ( s -> next_picture . f . motion_val [ 1 ] [ s -> block_index [ 0 ] + v -> blocks_off ] [ 0 ] , v -> bfraction , 1 , s -> quarter_sample ) ;\n s -> mv [ 1 ] [ 0 ] [ 1 ] = scale_mv ( s -> next_picture . f . motion_val [ 1 ] [ s -> block_index [ 0 ] + v -> blocks_off ] [ 1 ] , v -> bfraction , 1 , s -> quarter_sample ) ;\n total_opp = v -> mv_f_next [ 0 ] [ s -> block_index [ 0 ] + v -> blocks_off ] + v -> mv_f_next [ 0 ] [ s -> block_index [ 1 ] + v -> blocks_off ] + v -> mv_f_next [ 0 ] [ s -> block_index [ 2 ] + v -> blocks_off ] + v -> mv_f_next [ 0 ] [ s -> block_index [ 3 ] + v -> blocks_off ] ;\n f = ( total_opp > 2 ) ? 1 : 0 ;\n }\n else {\n s -> mv [ 0 ] [ 0 ] [ 0 ] = s -> mv [ 0 ] [ 0 ] [ 1 ] = 0 ;\n s -> mv [ 1 ] [ 0 ] [ 0 ] = s -> mv [ 1 ] [ 0 ] [ 1 ] = 0 ;\n f = 0 ;\n }\n v -> ref_field_type [ 0 ] = v -> ref_field_type [ 1 ] = v -> cur_field_type ^ f ;\n for ( k = 0 ;\n k < 4 ;\n k ++ ) {\n s -> current_picture . f . motion_val [ 0 ] [ s -> block_index [ k ] + v -> blocks_off ] [ 0 ] = s -> mv [ 0 ] [ 0 ] [ 0 ] ;\n s -> current_picture . f . motion_val [ 0 ] [ s -> block_index [ k ] + v -> blocks_off ] [ 1 ] = s -> mv [ 0 ] [ 0 ] [ 1 ] ;\n s -> current_picture . f . motion_val [ 1 ] [ s -> block_index [ k ] + v -> blocks_off ] [ 0 ] = s -> mv [ 1 ] [ 0 ] [ 0 ] ;\n s -> current_picture . f . motion_val [ 1 ] [ s -> block_index [ k ] + v -> blocks_off ] [ 1 ] = s -> mv [ 1 ] [ 0 ] [ 1 ] ;\n v -> mv_f [ 0 ] [ s -> block_index [ k ] + v -> blocks_off ] = f ;\n v -> mv_f [ 1 ] [ s -> block_index [ k ] + v -> blocks_off ] = f ;\n }\n return ;\n }\n if ( v -> bmvtype == BMV_TYPE_INTERPOLATED ) {\n vc1_pred_mv ( v , 0 , dmv_x [ 0 ] , dmv_y [ 0 ] , 1 , v -> range_x , v -> range_y , v -> mb_type [ 0 ] , pred_flag [ 0 ] , 0 ) ;\n vc1_pred_mv ( v , 0 , dmv_x [ 1 ] , dmv_y [ 1 ] , 1 , v -> range_x , v -> range_y , v -> mb_type [ 0 ] , pred_flag [ 1 ] , 1 ) ;\n return ;\n }\n if ( dir ) {\n vc1_pred_mv ( v , n , dmv_x [ 1 ] , dmv_y [ 1 ] , mv1 , v -> range_x , v -> range_y , v -> mb_type [ 0 ] , pred_flag [ 1 ] , 1 ) ;\n if ( n == 3 || mv1 ) {\n vc1_pred_mv ( v , 0 , dmv_x [ 0 ] , dmv_y [ 0 ] , 1 , v -> range_x , v -> range_y , v -> mb_type [ 0 ] , 0 , 0 ) ;\n }\n }\n else {\n vc1_pred_mv ( v , n , dmv_x [ 0 ] , dmv_y [ 0 ] , mv1 , v -> range_x , v -> range_y , v -> mb_type [ 0 ] , pred_flag [ 0 ] , 0 ) ;\n if ( n == 3 || mv1 ) {\n vc1_pred_mv ( v , 0 , dmv_x [ 1 ] , dmv_y [ 1 ] , 1 , v -> range_x , v -> range_y , v -> mb_type [ 0 ] , 0 , 1 ) ;\n }\n }\n }", "idx": 1645}
{"hash": -8745685032143262400, "project": "debian", "size": 23, "label": 0, "functionSource": "int upx_inflatelzma ( const char * src , uint32_t ssize , char * dst , uint32_t * dsize , uint32_t upx0 , uint32_t upx1 , uint32_t ep ) {\n struct CLI_LZMA l ;\n uint32_t magic [ ] = {\n 0xb16 , 0xb1e , 0 }\n ;\n unsigned char fake_lzmahdr [ 5 ] ;\n memset ( & l , 0 , sizeof ( l ) ) ;\n cli_writeint32 ( fake_lzmahdr + 1 , * dsize ) ;\n * fake_lzmahdr = 3 + 9 * ( 5 * 2 + 0 ) ;\n l . next_in = fake_lzmahdr ;\n l . avail_in = 5 ;\n if ( cli_LzmaInit ( & l , * dsize ) != LZMA_RESULT_OK ) return 0 ;\n l . avail_in = ssize ;\n l . avail_out = * dsize ;\n l . next_in = ( unsigned char * ) src + 2 ;\n l . next_out = ( unsigned char * ) dst ;\n if ( cli_LzmaDecode ( & l ) == LZMA_RESULT_DATA_ERROR ) {\n cli_LzmaShutdown ( & l ) ;\n return - 1 ;\n }\n cli_LzmaShutdown ( & l ) ;\n return pefromupx ( src , ssize , dst , dsize , ep , upx0 , upx1 , magic , * dsize ) ;\n }", "idx": 1646}
{"hash": -8884965407551053630, "project": "debian", "size": 12, "label": 0, "functionSource": "static void spu_del_buffer ( decoder_t * p_dec , subpicture_t * p_subpic ) {\n decoder_owner_sys_t * p_owner = p_dec -> p_owner ;\n vout_thread_t * p_vout = NULL ;\n p_vout = input_resource_HoldVout ( p_owner -> p_resource ) ;\n if ( ! p_vout || p_owner -> p_spu_vout != p_vout ) {\n if ( p_vout ) vlc_object_release ( p_vout ) ;\n msg_Warn ( p_dec , \"no vout found, leaking subpicture\" ) ;\n return ;\n }\n subpicture_Delete ( p_subpic ) ;\n vlc_object_release ( p_vout ) ;\n }", "idx": 1647}
{"hash": 1911881859629730975, "project": "chrome", "size": 5, "label": 0, "functionSource": "void vp9_init_me_luts ( ) {\n init_me_luts_bd ( sad_per_bit16lut_8 , sad_per_bit4lut_8 , QINDEX_RANGE , VPX_BITS_8 ) ;\n # if CONFIG_VP9_HIGHBITDEPTH init_me_luts_bd ( sad_per_bit16lut_10 , sad_per_bit4lut_10 , QINDEX_RANGE , VPX_BITS_10 ) ;\n init_me_luts_bd ( sad_per_bit16lut_12 , sad_per_bit4lut_12 , QINDEX_RANGE , VPX_BITS_12 ) ;\n # endif }", "idx": 1648}
{"hash": 1700977331036764538, "project": "debian", "size": 82, "label": 0, "functionSource": "int EVP_CipherInit_ex ( EVP_CIPHER_CTX * ctx , const EVP_CIPHER * cipher , ENGINE * impl , const unsigned char * key , const unsigned char * iv , int enc ) {\n if ( enc == - 1 ) enc = ctx -> encrypt ;\n else {\n if ( enc ) enc = 1 ;\n ctx -> encrypt = enc ;\n }\n # ifndef OPENSSL_NO_ENGINE if ( ctx -> engine && ctx -> cipher && ( ! cipher || ( cipher && ( cipher -> nid == ctx -> cipher -> nid ) ) ) ) goto skip_to_init ;\n # endif if ( cipher ) {\n if ( ctx -> cipher ) {\n unsigned long flags = ctx -> flags ;\n EVP_CIPHER_CTX_reset ( ctx ) ;\n ctx -> encrypt = enc ;\n ctx -> flags = flags ;\n }\n # ifndef OPENSSL_NO_ENGINE if ( impl ) {\n if ( ! ENGINE_init ( impl ) ) {\n EVPerr ( EVP_F_EVP_CIPHERINIT_EX , EVP_R_INITIALIZATION_ERROR ) ;\n return 0 ;\n }\n }\n else impl = ENGINE_get_cipher_engine ( cipher -> nid ) ;\n if ( impl ) {\n const EVP_CIPHER * c = ENGINE_get_cipher ( impl , cipher -> nid ) ;\n if ( ! c ) {\n EVPerr ( EVP_F_EVP_CIPHERINIT_EX , EVP_R_INITIALIZATION_ERROR ) ;\n return 0 ;\n }\n cipher = c ;\n ctx -> engine = impl ;\n }\n else ctx -> engine = NULL ;\n # endif ctx -> cipher = cipher ;\n if ( ctx -> cipher -> ctx_size ) {\n ctx -> cipher_data = OPENSSL_zalloc ( ctx -> cipher -> ctx_size ) ;\n if ( ctx -> cipher_data == NULL ) {\n EVPerr ( EVP_F_EVP_CIPHERINIT_EX , ERR_R_MALLOC_FAILURE ) ;\n return 0 ;\n }\n }\n else {\n ctx -> cipher_data = NULL ;\n }\n ctx -> key_len = cipher -> key_len ;\n ctx -> flags &= EVP_CIPHER_CTX_FLAG_WRAP_ALLOW ;\n if ( ctx -> cipher -> flags & EVP_CIPH_CTRL_INIT ) {\n if ( ! EVP_CIPHER_CTX_ctrl ( ctx , EVP_CTRL_INIT , 0 , NULL ) ) {\n EVPerr ( EVP_F_EVP_CIPHERINIT_EX , EVP_R_INITIALIZATION_ERROR ) ;\n return 0 ;\n }\n }\n }\n else if ( ! ctx -> cipher ) {\n EVPerr ( EVP_F_EVP_CIPHERINIT_EX , EVP_R_NO_CIPHER_SET ) ;\n return 0 ;\n }\n # ifndef OPENSSL_NO_ENGINE skip_to_init : # endif OPENSSL_assert ( ctx -> cipher -> block_size == 1 || ctx -> cipher -> block_size == 8 || ctx -> cipher -> block_size == 16 ) ;\n if ( ! ( ctx -> flags & EVP_CIPHER_CTX_FLAG_WRAP_ALLOW ) && EVP_CIPHER_CTX_mode ( ctx ) == EVP_CIPH_WRAP_MODE ) {\n EVPerr ( EVP_F_EVP_CIPHERINIT_EX , EVP_R_WRAP_MODE_NOT_ALLOWED ) ;\n return 0 ;\n }\n if ( ! ( EVP_CIPHER_flags ( EVP_CIPHER_CTX_cipher ( ctx ) ) & EVP_CIPH_CUSTOM_IV ) ) {\n switch ( EVP_CIPHER_CTX_mode ( ctx ) ) {\n case EVP_CIPH_STREAM_CIPHER : case EVP_CIPH_ECB_MODE : break ;\n case EVP_CIPH_CFB_MODE : case EVP_CIPH_OFB_MODE : ctx -> num = 0 ;\n case EVP_CIPH_CBC_MODE : OPENSSL_assert ( EVP_CIPHER_CTX_iv_length ( ctx ) <= ( int ) sizeof ( ctx -> iv ) ) ;\n if ( iv ) memcpy ( ctx -> oiv , iv , EVP_CIPHER_CTX_iv_length ( ctx ) ) ;\n memcpy ( ctx -> iv , ctx -> oiv , EVP_CIPHER_CTX_iv_length ( ctx ) ) ;\n break ;\n case EVP_CIPH_CTR_MODE : ctx -> num = 0 ;\n if ( iv ) memcpy ( ctx -> iv , iv , EVP_CIPHER_CTX_iv_length ( ctx ) ) ;\n break ;\n default : return 0 ;\n }\n }\n if ( key || ( ctx -> cipher -> flags & EVP_CIPH_ALWAYS_CALL_INIT ) ) {\n if ( ! ctx -> cipher -> init ( ctx , key , iv , enc ) ) return 0 ;\n }\n ctx -> buf_len = 0 ;\n ctx -> final_used = 0 ;\n ctx -> block_mask = ctx -> cipher -> block_size - 1 ;\n return 1 ;\n }", "idx": 1649}
{"hash": -1111775978048960297, "project": "chrome", "size": 11, "label": 0, "functionSource": "TEST_F ( BrowsingDataRemoverImplTest , RemoveChannelIDForever ) {\n RemoveChannelIDTester tester ( GetBrowserContext ( ) ) ;\n tester . AddChannelID ( kTestOrigin1 ) ;\n EXPECT_EQ ( 0 , tester . ssl_config_changed_count ( ) ) ;\n EXPECT_EQ ( 1 , tester . ChannelIDCount ( ) ) ;\n BlockUntilBrowsingDataRemoved ( base : : Time ( ) , base : : Time : : Max ( ) , BrowsingDataRemover : : REMOVE_CHANNEL_IDS , false ) ;\n EXPECT_EQ ( BrowsingDataRemover : : REMOVE_CHANNEL_IDS , GetRemovalMask ( ) ) ;\n EXPECT_EQ ( BrowsingDataHelper : : UNPROTECTED_WEB , GetOriginTypeMask ( ) ) ;\n EXPECT_EQ ( 1 , tester . ssl_config_changed_count ( ) ) ;\n EXPECT_EQ ( 0 , tester . ChannelIDCount ( ) ) ;\n }", "idx": 1650}
{"hash": 4489017523191997023, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h225_SEQUENCE_OF_ClearToken ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence_of ( tvb , offset , actx , tree , hf_index , ett_h225_SEQUENCE_OF_ClearToken , SEQUENCE_OF_ClearToken_sequence_of ) ;\n return offset ;\n }", "idx": 1651}
{"hash": -187662502455871220, "project": "debian", "size": 20, "label": 0, "functionSource": "static int dissect_usb_video_endpoint_descriptor ( proto_tree * parent_tree , tvbuff_t * tvb , guint8 descriptor_len ) {\n proto_tree * tree = NULL ;\n int offset = 0 ;\n guint8 subtype ;\n subtype = tvb_get_guint8 ( tvb , offset + 2 ) ;\n if ( parent_tree ) {\n const gchar * subtype_str ;\n subtype_str = val_to_str ( subtype , vc_ep_descriptor_subtypes , \"Unknown (0x%x)\" ) ;\n tree = proto_tree_add_subtree_format ( parent_tree , tvb , offset , descriptor_len , ett_descriptor_video_endpoint , NULL , \"VIDEO CONTROL ENDPOINT DESCRIPTOR [%s]\" , subtype_str ) ;\n }\n dissect_usb_descriptor_header ( tree , tvb , offset , & vid_descriptor_type_vals_ext ) ;\n proto_tree_add_item ( tree , hf_usb_vid_epdesc_subtype , tvb , offset + 2 , 1 , ENC_LITTLE_ENDIAN ) ;\n offset += 3 ;\n if ( subtype == EP_INTERRUPT ) {\n proto_tree_add_item ( tree , hf_usb_vid_epdesc_max_transfer_sz , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( offset < descriptor_len ) proto_tree_add_item ( tree , hf_usb_vid_descriptor_data , tvb , offset , descriptor_len - offset , ENC_NA ) ;\n return descriptor_len ;\n }", "idx": 1652}
{"hash": 2125998987781803371, "project": "debian", "size": 9, "label": 0, "functionSource": "static void CloseEncoder ( vlc_object_t * p_this ) {\n encoder_t * p_enc = ( encoder_t * ) p_this ;\n encoder_sys_t * p_sys = p_enc -> p_sys ;\n if ( p_sys -> p_schro ) schro_encoder_free ( p_sys -> p_schro ) ;\n free ( p_sys -> p_format ) ;\n if ( p_sys -> p_dts_fifo ) block_FifoRelease ( p_sys -> p_dts_fifo ) ;\n block_ChainRelease ( p_sys -> p_chain ) ;\n free ( p_sys ) ;\n }", "idx": 1653}
{"hash": 9176142195250515812, "project": "debian", "size": 6, "label": 0, "functionSource": "static void prplcb_conn_disconnected ( PurpleConnection * gc ) {\n struct im_connection * ic = purple_ic_by_gc ( gc ) ;\n if ( ic != NULL ) {\n imc_logout ( ic , ! gc -> wants_to_die ) ;\n }\n }", "idx": 1654}
{"hash": 2091417324431734585, "project": "debian", "size": 43, "label": 0, "functionSource": "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n VBDecContext * const c = avctx -> priv_data ;\n AVFrame * frame = data ;\n uint8_t * outptr , * srcptr ;\n int i , j , ret ;\n int flags ;\n uint32_t size ;\n int offset = 0 ;\n bytestream2_init ( & c -> stream , avpkt -> data , avpkt -> size ) ;\n if ( ( ret = ff_get_buffer ( avctx , frame , 0 ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n flags = bytestream2_get_le16 ( & c -> stream ) ;\n if ( flags & VB_HAS_GMC ) {\n i = ( int16_t ) bytestream2_get_le16 ( & c -> stream ) ;\n j = ( int16_t ) bytestream2_get_le16 ( & c -> stream ) ;\n offset = i + j * avctx -> width ;\n }\n if ( flags & VB_HAS_VIDEO ) {\n size = bytestream2_get_le32 ( & c -> stream ) ;\n vb_decode_framedata ( c , offset ) ;\n bytestream2_skip ( & c -> stream , size - 4 ) ;\n }\n if ( flags & VB_HAS_PALETTE ) {\n size = bytestream2_get_le32 ( & c -> stream ) ;\n vb_decode_palette ( c , size ) ;\n }\n memcpy ( frame -> data [ 1 ] , c -> pal , AVPALETTE_SIZE ) ;\n frame -> palette_has_changed = flags & VB_HAS_PALETTE ;\n outptr = frame -> data [ 0 ] ;\n srcptr = c -> frame ;\n for ( i = 0 ;\n i < avctx -> height ;\n i ++ ) {\n memcpy ( outptr , srcptr , avctx -> width ) ;\n srcptr += avctx -> width ;\n outptr += frame -> linesize [ 0 ] ;\n }\n FFSWAP ( uint8_t * , c -> frame , c -> prev_frame ) ;\n * got_frame = 1 ;\n return avpkt -> size ;\n }", "idx": 1655}
{"hash": 1223258652239369123, "project": "debian", "size": 6, "label": 0, "functionSource": "SPL_METHOD ( DirectoryIterator , current ) {\n if ( zend_parse_parameters_none ( ) == FAILURE ) {\n return ;\n }\n RETURN_ZVAL ( getThis ( ) , 1 , 0 ) ;\n }", "idx": 1656}
{"hash": 8952659721822029396, "project": "debian", "size": 35, "label": 0, "functionSource": "static int dvvideo_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n DVVideoContext * s = avctx -> priv_data ;\n const uint8_t * vsc_pack ;\n int apt , is16_9 ;\n s -> sys = avpriv_dv_frame_profile ( s -> sys , buf , buf_size ) ;\n if ( ! s -> sys || buf_size < s -> sys -> frame_size || ff_dv_init_dynamic_tables ( s -> sys ) ) {\n av_log ( avctx , AV_LOG_ERROR , \"could not find dv frame profile\\n\" ) ;\n return - 1 ;\n }\n s -> picture . key_frame = 1 ;\n s -> picture . pict_type = AV_PICTURE_TYPE_I ;\n avctx -> pix_fmt = s -> sys -> pix_fmt ;\n avctx -> time_base = s -> sys -> time_base ;\n avcodec_set_dimensions ( avctx , s -> sys -> width , s -> sys -> height ) ;\n if ( ff_get_buffer ( avctx , & s -> picture , 0 ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return - 1 ;\n }\n s -> picture . interlaced_frame = 1 ;\n s -> picture . top_field_first = 0 ;\n s -> buf = buf ;\n avctx -> execute ( avctx , dv_decode_video_segment , s -> sys -> work_chunks , NULL , dv_work_pool_size ( s -> sys ) , sizeof ( DVwork_chunk ) ) ;\n emms_c ( ) ;\n * got_frame = 1 ;\n av_frame_move_ref ( data , & s -> picture ) ;\n vsc_pack = buf + 80 * 5 + 48 + 5 ;\n if ( * vsc_pack == dv_video_control ) {\n apt = buf [ 4 ] & 0x07 ;\n is16_9 = ( vsc_pack && ( ( vsc_pack [ 2 ] & 0x07 ) == 0x02 || ( ! apt && ( vsc_pack [ 2 ] & 0x07 ) == 0x07 ) ) ) ;\n avctx -> sample_aspect_ratio = s -> sys -> sar [ is16_9 ] ;\n }\n return s -> sys -> frame_size ;\n }", "idx": 1657}
{"hash": 4724375811251028572, "project": "debian", "size": 8, "label": 0, "functionSource": "static void arith_init ( ArithCoder * c , GetBitContext * gb ) {\n c -> low = 0 ;\n c -> high = 0xFFFF ;\n c -> value = get_bits ( gb , 16 ) ;\n c -> gbc . gb = gb ;\n c -> get_model_sym = arith_get_model_sym ;\n c -> get_number = arith_get_number ;\n }", "idx": 1658}
{"hash": 6336384260629386331, "project": "debian", "size": 19, "label": 0, "functionSource": "static void dissect_zcl_scenes_add_scene ( tvbuff_t * tvb , proto_tree * tree , guint * offset ) {\n guint attr_uint ;\n guint8 * attr_string ;\n proto_tree_add_item ( tree , hf_zbee_zcl_scenes_group_id , tvb , * offset , 2 , ENC_LITTLE_ENDIAN ) ;\n * offset += 2 ;\n proto_tree_add_item ( tree , hf_zbee_zcl_scenes_scene_id , tvb , * offset , 1 , ENC_LITTLE_ENDIAN ) ;\n * offset += 1 ;\n proto_tree_add_item ( tree , hf_zbee_zcl_scenes_transit_time , tvb , * offset , 2 , ENC_LITTLE_ENDIAN ) ;\n * offset += 2 ;\n attr_uint = tvb_get_guint8 ( tvb , * offset ) ;\n if ( attr_uint == 0xff ) attr_uint = 0 ;\n proto_tree_add_uint ( tree , hf_zbee_zcl_scenes_attr_str_len , tvb , * offset , 1 , attr_uint ) ;\n * offset += 1 ;\n attr_string = tvb_get_string_enc ( wmem_packet_scope ( ) , tvb , * offset , attr_uint , ENC_ASCII ) ;\n proto_item_append_text ( tree , \", String: %s\" , attr_string ) ;\n proto_tree_add_string ( tree , hf_zbee_zcl_scenes_attr_str , tvb , * offset , attr_uint , attr_string ) ;\n * offset += attr_uint ;\n proto_tree_add_item ( tree , hf_zbee_zcl_scenes_extension_set_field , tvb , * offset , - 1 , ENC_NA ) ;\n }", "idx": 1659}
{"hash": 3298403829257765374, "project": "debian", "size": 316, "label": 0, "functionSource": "static int qcow2_open ( BlockDriverState * bs , QDict * options , int flags , Error * * errp ) {\n BDRVQcowState * s = bs -> opaque ;\n unsigned int len , i ;\n int ret = 0 ;\n QCowHeader header ;\n QemuOpts * opts ;\n Error * local_err = NULL ;\n uint64_t ext_end ;\n uint64_t l1_vm_state_index ;\n const char * opt_overlap_check ;\n int overlap_check_template = 0 ;\n ret = bdrv_pread ( bs -> file , 0 , & header , sizeof ( header ) ) ;\n if ( ret < 0 ) {\n error_setg_errno ( errp , - ret , \"Could not read qcow2 header\" ) ;\n goto fail ;\n }\n be32_to_cpus ( & header . magic ) ;\n be32_to_cpus ( & header . version ) ;\n be64_to_cpus ( & header . backing_file_offset ) ;\n be32_to_cpus ( & header . backing_file_size ) ;\n be64_to_cpus ( & header . size ) ;\n be32_to_cpus ( & header . cluster_bits ) ;\n be32_to_cpus ( & header . crypt_method ) ;\n be64_to_cpus ( & header . l1_table_offset ) ;\n be32_to_cpus ( & header . l1_size ) ;\n be64_to_cpus ( & header . refcount_table_offset ) ;\n be32_to_cpus ( & header . refcount_table_clusters ) ;\n be64_to_cpus ( & header . snapshots_offset ) ;\n be32_to_cpus ( & header . nb_snapshots ) ;\n if ( header . magic != QCOW_MAGIC ) {\n error_setg ( errp , \"Image is not in qcow2 format\" ) ;\n ret = - EINVAL ;\n goto fail ;\n }\n if ( header . version < 2 || header . version > 3 ) {\n report_unsupported ( bs , errp , \"QCOW version %d\" , header . version ) ;\n ret = - ENOTSUP ;\n goto fail ;\n }\n s -> qcow_version = header . version ;\n if ( header . cluster_bits < MIN_CLUSTER_BITS || header . cluster_bits > MAX_CLUSTER_BITS ) {\n error_setg ( errp , \"Unsupported cluster size: 2^%i\" , header . cluster_bits ) ;\n ret = - EINVAL ;\n goto fail ;\n }\n s -> cluster_bits = header . cluster_bits ;\n s -> cluster_size = 1 << s -> cluster_bits ;\n s -> cluster_sectors = 1 << ( s -> cluster_bits - 9 ) ;\n if ( header . version == 2 ) {\n header . incompatible_features = 0 ;\n header . compatible_features = 0 ;\n header . autoclear_features = 0 ;\n header . refcount_order = 4 ;\n header . header_length = 72 ;\n }\n else {\n be64_to_cpus ( & header . incompatible_features ) ;\n be64_to_cpus ( & header . compatible_features ) ;\n be64_to_cpus ( & header . autoclear_features ) ;\n be32_to_cpus ( & header . refcount_order ) ;\n be32_to_cpus ( & header . header_length ) ;\n if ( header . header_length < 104 ) {\n error_setg ( errp , \"qcow2 header too short\" ) ;\n ret = - EINVAL ;\n goto fail ;\n }\n }\n if ( header . header_length > s -> cluster_size ) {\n error_setg ( errp , \"qcow2 header exceeds cluster size\" ) ;\n ret = - EINVAL ;\n goto fail ;\n }\n if ( header . header_length > sizeof ( header ) ) {\n s -> unknown_header_fields_size = header . header_length - sizeof ( header ) ;\n s -> unknown_header_fields = g_malloc ( s -> unknown_header_fields_size ) ;\n ret = bdrv_pread ( bs -> file , sizeof ( header ) , s -> unknown_header_fields , s -> unknown_header_fields_size ) ;\n if ( ret < 0 ) {\n error_setg_errno ( errp , - ret , \"Could not read unknown qcow2 header \" \"fields\" ) ;\n goto fail ;\n }\n }\n if ( header . backing_file_offset > s -> cluster_size ) {\n error_setg ( errp , \"Invalid backing file offset\" ) ;\n ret = - EINVAL ;\n goto fail ;\n }\n if ( header . backing_file_offset ) {\n ext_end = header . backing_file_offset ;\n }\n else {\n ext_end = 1 << header . cluster_bits ;\n }\n s -> incompatible_features = header . incompatible_features ;\n s -> compatible_features = header . compatible_features ;\n s -> autoclear_features = header . autoclear_features ;\n if ( s -> incompatible_features & ~ QCOW2_INCOMPAT_MASK ) {\n void * feature_table = NULL ;\n qcow2_read_extensions ( bs , header . header_length , ext_end , & feature_table , NULL ) ;\n report_unsupported_feature ( bs , errp , feature_table , s -> incompatible_features & ~ QCOW2_INCOMPAT_MASK ) ;\n ret = - ENOTSUP ;\n g_free ( feature_table ) ;\n goto fail ;\n }\n if ( s -> incompatible_features & QCOW2_INCOMPAT_CORRUPT ) {\n if ( ( flags & BDRV_O_RDWR ) && ! ( flags & BDRV_O_CHECK ) ) {\n error_setg ( errp , \"qcow2: Image is corrupt;\n cannot be opened \" \"read/write\" ) ;\n ret = - EACCES ;\n goto fail ;\n }\n }\n if ( header . refcount_order != 4 ) {\n report_unsupported ( bs , errp , \"%d bit reference counts\" , 1 << header . refcount_order ) ;\n ret = - ENOTSUP ;\n goto fail ;\n }\n s -> refcount_order = header . refcount_order ;\n if ( header . crypt_method > QCOW_CRYPT_AES ) {\n error_setg ( errp , \"Unsupported encryption method: %i\" , header . crypt_method ) ;\n ret = - EINVAL ;\n goto fail ;\n }\n s -> crypt_method_header = header . crypt_method ;\n if ( s -> crypt_method_header ) {\n bs -> encrypted = 1 ;\n }\n s -> l2_bits = s -> cluster_bits - 3 ;\n s -> l2_size = 1 << s -> l2_bits ;\n bs -> total_sectors = header . size / 512 ;\n s -> csize_shift = ( 62 - ( s -> cluster_bits - 8 ) ) ;\n s -> csize_mask = ( 1 << ( s -> cluster_bits - 8 ) ) - 1 ;\n s -> cluster_offset_mask = ( 1LL << s -> csize_shift ) - 1 ;\n s -> refcount_table_offset = header . refcount_table_offset ;\n s -> refcount_table_size = header . refcount_table_clusters << ( s -> cluster_bits - 3 ) ;\n if ( header . refcount_table_clusters > qcow2_max_refcount_clusters ( s ) ) {\n error_setg ( errp , \"Reference count table too large\" ) ;\n ret = - EINVAL ;\n goto fail ;\n }\n ret = validate_table_offset ( bs , s -> refcount_table_offset , s -> refcount_table_size , sizeof ( uint64_t ) ) ;\n if ( ret < 0 ) {\n error_setg ( errp , \"Invalid reference count table offset\" ) ;\n goto fail ;\n }\n if ( header . nb_snapshots > QCOW_MAX_SNAPSHOTS ) {\n error_setg ( errp , \"Too many snapshots\" ) ;\n ret = - EINVAL ;\n goto fail ;\n }\n ret = validate_table_offset ( bs , header . snapshots_offset , header . nb_snapshots , sizeof ( QCowSnapshotHeader ) ) ;\n if ( ret < 0 ) {\n error_setg ( errp , \"Invalid snapshot table offset\" ) ;\n goto fail ;\n }\n if ( header . l1_size > 0x2000000 ) {\n error_setg ( errp , \"Active L1 table too large\" ) ;\n ret = - EFBIG ;\n goto fail ;\n }\n s -> l1_size = header . l1_size ;\n l1_vm_state_index = size_to_l1 ( s , header . size ) ;\n if ( l1_vm_state_index > INT_MAX ) {\n error_setg ( errp , \"Image is too big\" ) ;\n ret = - EFBIG ;\n goto fail ;\n }\n s -> l1_vm_state_index = l1_vm_state_index ;\n if ( s -> l1_size < s -> l1_vm_state_index ) {\n error_setg ( errp , \"L1 table is too small\" ) ;\n ret = - EINVAL ;\n goto fail ;\n }\n ret = validate_table_offset ( bs , header . l1_table_offset , header . l1_size , sizeof ( uint64_t ) ) ;\n if ( ret < 0 ) {\n error_setg ( errp , \"Invalid L1 table offset\" ) ;\n goto fail ;\n }\n s -> l1_table_offset = header . l1_table_offset ;\n if ( s -> l1_size > 0 ) {\n s -> l1_table = g_malloc0 ( align_offset ( s -> l1_size * sizeof ( uint64_t ) , 512 ) ) ;\n ret = bdrv_pread ( bs -> file , s -> l1_table_offset , s -> l1_table , s -> l1_size * sizeof ( uint64_t ) ) ;\n if ( ret < 0 ) {\n error_setg_errno ( errp , - ret , \"Could not read L1 table\" ) ;\n goto fail ;\n }\n for ( i = 0 ;\n i < s -> l1_size ;\n i ++ ) {\n be64_to_cpus ( & s -> l1_table [ i ] ) ;\n }\n }\n s -> l2_table_cache = qcow2_cache_create ( bs , L2_CACHE_SIZE ) ;\n s -> refcount_block_cache = qcow2_cache_create ( bs , REFCOUNT_CACHE_SIZE ) ;\n s -> cluster_cache = g_malloc ( s -> cluster_size ) ;\n s -> cluster_data = qemu_blockalign ( bs , QCOW_MAX_CRYPT_CLUSTERS * s -> cluster_size + 512 ) ;\n s -> cluster_cache_offset = - 1 ;\n s -> flags = flags ;\n ret = qcow2_refcount_init ( bs ) ;\n if ( ret != 0 ) {\n error_setg_errno ( errp , - ret , \"Could not initialize refcount handling\" ) ;\n goto fail ;\n }\n QLIST_INIT ( & s -> cluster_allocs ) ;\n QTAILQ_INIT ( & s -> discards ) ;\n if ( qcow2_read_extensions ( bs , header . header_length , ext_end , NULL , & local_err ) ) {\n error_propagate ( errp , local_err ) ;\n ret = - EINVAL ;\n goto fail ;\n }\n if ( header . backing_file_offset != 0 ) {\n len = header . backing_file_size ;\n if ( len > MIN ( 1023 , s -> cluster_size - header . backing_file_offset ) ) {\n error_setg ( errp , \"Backing file name too long\" ) ;\n ret = - EINVAL ;\n goto fail ;\n }\n ret = bdrv_pread ( bs -> file , header . backing_file_offset , bs -> backing_file , len ) ;\n if ( ret < 0 ) {\n error_setg_errno ( errp , - ret , \"Could not read backing file name\" ) ;\n goto fail ;\n }\n bs -> backing_file [ len ] = '\\0' ;\n }\n s -> snapshots_offset = header . snapshots_offset ;\n s -> nb_snapshots = header . nb_snapshots ;\n ret = qcow2_read_snapshots ( bs ) ;\n if ( ret < 0 ) {\n error_setg_errno ( errp , - ret , \"Could not read snapshots\" ) ;\n goto fail ;\n }\n if ( ! bs -> read_only && ! ( flags & BDRV_O_INCOMING ) && s -> autoclear_features ) {\n s -> autoclear_features = 0 ;\n ret = qcow2_update_header ( bs ) ;\n if ( ret < 0 ) {\n error_setg_errno ( errp , - ret , \"Could not update qcow2 header\" ) ;\n goto fail ;\n }\n }\n qemu_co_mutex_init ( & s -> lock ) ;\n if ( ! ( flags & ( BDRV_O_CHECK | BDRV_O_INCOMING ) ) && ! bs -> read_only && ( s -> incompatible_features & QCOW2_INCOMPAT_DIRTY ) ) {\n BdrvCheckResult result = {\n 0 }\n ;\n ret = qcow2_check ( bs , & result , BDRV_FIX_ERRORS ) ;\n if ( ret < 0 ) {\n error_setg_errno ( errp , - ret , \"Could not repair dirty image\" ) ;\n goto fail ;\n }\n }\n opts = qemu_opts_create ( & qcow2_runtime_opts , NULL , 0 , & error_abort ) ;\n qemu_opts_absorb_qdict ( opts , options , & local_err ) ;\n if ( local_err ) {\n error_propagate ( errp , local_err ) ;\n ret = - EINVAL ;\n goto fail ;\n }\n s -> use_lazy_refcounts = qemu_opt_get_bool ( opts , QCOW2_OPT_LAZY_REFCOUNTS , ( s -> compatible_features & QCOW2_COMPAT_LAZY_REFCOUNTS ) ) ;\n s -> discard_passthrough [ QCOW2_DISCARD_NEVER ] = false ;\n s -> discard_passthrough [ QCOW2_DISCARD_ALWAYS ] = true ;\n s -> discard_passthrough [ QCOW2_DISCARD_REQUEST ] = qemu_opt_get_bool ( opts , QCOW2_OPT_DISCARD_REQUEST , flags & BDRV_O_UNMAP ) ;\n s -> discard_passthrough [ QCOW2_DISCARD_SNAPSHOT ] = qemu_opt_get_bool ( opts , QCOW2_OPT_DISCARD_SNAPSHOT , true ) ;\n s -> discard_passthrough [ QCOW2_DISCARD_OTHER ] = qemu_opt_get_bool ( opts , QCOW2_OPT_DISCARD_OTHER , false ) ;\n opt_overlap_check = qemu_opt_get ( opts , \"overlap-check\" ) ? : \"cached\" ;\n if ( ! strcmp ( opt_overlap_check , \"none\" ) ) {\n overlap_check_template = 0 ;\n }\n else if ( ! strcmp ( opt_overlap_check , \"constant\" ) ) {\n overlap_check_template = QCOW2_OL_CONSTANT ;\n }\n else if ( ! strcmp ( opt_overlap_check , \"cached\" ) ) {\n overlap_check_template = QCOW2_OL_CACHED ;\n }\n else if ( ! strcmp ( opt_overlap_check , \"all\" ) ) {\n overlap_check_template = QCOW2_OL_ALL ;\n }\n else {\n error_setg ( errp , \"Unsupported value '%s' for qcow2 option \" \"'overlap-check'. Allowed are either of the following: \" \"none, constant, cached, all\" , opt_overlap_check ) ;\n qemu_opts_del ( opts ) ;\n ret = - EINVAL ;\n goto fail ;\n }\n s -> overlap_check = 0 ;\n for ( i = 0 ;\n i < QCOW2_OL_MAX_BITNR ;\n i ++ ) {\n s -> overlap_check |= qemu_opt_get_bool ( opts , overlap_bool_option_names [ i ] , overlap_check_template & ( 1 << i ) ) << i ;\n }\n qemu_opts_del ( opts ) ;\n if ( s -> use_lazy_refcounts && s -> qcow_version < 3 ) {\n error_setg ( errp , \"Lazy refcounts require a qcow2 image with at least \" \"qemu 1.1 compatibility level\" ) ;\n ret = - EINVAL ;\n goto fail ;\n }\n # ifdef DEBUG_ALLOC {\n BdrvCheckResult result = {\n 0 }\n ;\n qcow2_check_refcounts ( bs , & result , 0 ) ;\n }\n # endif return ret ;\n fail : g_free ( s -> unknown_header_fields ) ;\n cleanup_unknown_header_ext ( bs ) ;\n qcow2_free_snapshots ( bs ) ;\n qcow2_refcount_close ( bs ) ;\n g_free ( s -> l1_table ) ;\n s -> l1_table = NULL ;\n if ( s -> l2_table_cache ) {\n qcow2_cache_destroy ( bs , s -> l2_table_cache ) ;\n }\n if ( s -> refcount_block_cache ) {\n qcow2_cache_destroy ( bs , s -> refcount_block_cache ) ;\n }\n g_free ( s -> cluster_cache ) ;\n qemu_vfree ( s -> cluster_data ) ;\n return ret ;\n }", "idx": 1660}
{"hash": 4489017523191997023, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h225_SEQUENCE_OF_GenericData ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence_of ( tvb , offset , actx , tree , hf_index , ett_h225_SEQUENCE_OF_GenericData , SEQUENCE_OF_GenericData_sequence_of ) ;\n return offset ;\n }", "idx": 1661}
{"hash": -6580451576689962916, "project": "debian", "size": 4, "label": 0, "functionSource": "static char * ext_t_0_wv_cspc_13 ( tvbuff_t * tvb _U_ , guint32 value , guint32 str_tbl _U_ ) {\n char * str = wmem_strdup_printf ( wmem_packet_scope ( ) , \"Common Value: '%s'\" , val_to_str ( value , vals_wv_csp_13_element_value_tokens , \"<Unknown WV-CSP 1.3 Common Value token 0x%X>\" ) ) ;\n return str ;\n }", "idx": 1662}
{"hash": -2386031673786599357, "project": "debian", "size": 15, "label": 0, "functionSource": "static gpgme_error_t gpgsm_decrypt ( void * engine , gpgme_data_t ciph , gpgme_data_t plain ) {\n engine_gpgsm_t gpgsm = engine ;\n gpgme_error_t err ;\n if ( ! gpgsm ) return gpg_error ( GPG_ERR_INV_VALUE ) ;\n gpgsm -> input_cb . data = ciph ;\n err = gpgsm_set_fd ( gpgsm , INPUT_FD , map_data_enc ( gpgsm -> input_cb . data ) ) ;\n if ( err ) return gpg_error ( GPG_ERR_GENERAL ) ;\n gpgsm -> output_cb . data = plain ;\n err = gpgsm_set_fd ( gpgsm , OUTPUT_FD , 0 ) ;\n if ( err ) return gpg_error ( GPG_ERR_GENERAL ) ;\n gpgsm_clear_fd ( gpgsm , MESSAGE_FD ) ;\n gpgsm -> inline_data = NULL ;\n err = start ( engine , \"DECRYPT\" ) ;\n return err ;\n }", "idx": 1663}
{"hash": -6215323349888018447, "project": "debian", "size": 18, "label": 0, "functionSource": "static void dumpDbRoleConfig ( PGconn * conn ) {\n PQExpBuffer buf = createPQExpBuffer ( ) ;\n PGresult * res ;\n int i ;\n printfPQExpBuffer ( buf , \"SELECT rolname, datname, unnest(setconfig) \" \"FROM pg_db_role_setting, pg_authid, pg_database \" \"WHERE setrole = pg_authid.oid AND setdatabase = pg_database.oid\" ) ;\n res = executeQuery ( conn , buf -> data ) ;\n if ( PQntuples ( res ) > 0 ) {\n fprintf ( OPF , \"--\\n-- Per-Database Role Settings \\n--\\n\\n\" ) ;\n for ( i = 0 ;\n i < PQntuples ( res ) ;\n i ++ ) {\n makeAlterConfigCommand ( conn , PQgetvalue ( res , i , 2 ) , \"ROLE\" , PQgetvalue ( res , i , 0 ) , \"DATABASE\" , PQgetvalue ( res , i , 1 ) ) ;\n }\n fprintf ( OPF , \"\\n\\n\" ) ;\n }\n PQclear ( res ) ;\n destroyPQExpBuffer ( buf ) ;\n }", "idx": 1664}
{"hash": 8170016074494868282, "project": "debian", "size": 37, "label": 0, "functionSource": "static void auth_server_connection_input ( struct auth_server_connection * conn ) {\n struct istream * input ;\n const char * line , * error ;\n int ret ;\n switch ( i_stream_read ( conn -> input ) ) {\n case 0 : return ;\n case - 1 : error = conn -> input -> stream_errno != 0 ? strerror ( conn -> input -> stream_errno ) : \"EOF\" ;\n auth_server_connection_reconnect ( conn , error ) ;\n return ;\n case - 2 : i_error ( \"BUG: Auth server sent us more than %d bytes of data\" , AUTH_SERVER_CONN_MAX_LINE_LENGTH ) ;\n auth_server_connection_disconnect ( conn , \"buffer full\" ) ;\n return ;\n }\n if ( ! conn -> version_received ) {\n line = i_stream_next_line ( conn -> input ) ;\n if ( line == NULL ) return ;\n if ( strncmp ( line , \"VERSION\\t\" , 8 ) != 0 || ! str_uint_equals ( t_strcut ( line + 8 , '\\t' ) , AUTH_CLIENT_PROTOCOL_MAJOR_VERSION ) ) {\n i_error ( \"Authentication server not compatible with \" \"this client (mixed old and new binaries?)\" ) ;\n auth_server_connection_disconnect ( conn , \"incompatible server\" ) ;\n return ;\n }\n conn -> version_received = TRUE ;\n }\n input = conn -> input ;\n i_stream_ref ( input ) ;\n while ( ( line = i_stream_next_line ( input ) ) != NULL && ! input -> closed ) {\n T_BEGIN {\n ret = auth_server_connection_input_line ( conn , line ) ;\n }\n T_END ;\n if ( ret < 0 ) {\n auth_server_connection_disconnect ( conn , t_strdup_printf ( \"Received broken input: %s\" , line ) ) ;\n break ;\n }\n }\n i_stream_unref ( & input ) ;\n }", "idx": 1665}
{"hash": 6632536031698733342, "project": "debian", "size": 11, "label": 0, "functionSource": "static inline void writer_print_section_footer ( WriterContext * wctx ) {\n int section_id = wctx -> section [ wctx -> level ] -> id ;\n int parent_section_id = wctx -> level ? wctx -> section [ wctx -> level - 1 ] -> id : SECTION_ID_NONE ;\n if ( parent_section_id != SECTION_ID_NONE ) wctx -> nb_item [ wctx -> level - 1 ] ++ ;\n if ( parent_section_id == SECTION_ID_PACKETS_AND_FRAMES ) {\n if ( section_id == SECTION_ID_PACKET ) wctx -> nb_section_packet ++ ;\n else wctx -> nb_section_frame ++ ;\n }\n if ( wctx -> writer -> print_section_footer ) wctx -> writer -> print_section_footer ( wctx ) ;\n wctx -> level -- ;\n }", "idx": 1666}
{"hash": -7795592811940874822, "project": "debian", "size": 5, "label": 0, "functionSource": "void _gcry_pk_unregister ( gcry_module_t module ) {\n ath_mutex_lock ( & pubkeys_registered_lock ) ;\n _gcry_module_release ( module ) ;\n ath_mutex_unlock ( & pubkeys_registered_lock ) ;\n }", "idx": 1667}
{"hash": 1414661670117003749, "project": "debian", "size": 13, "label": 0, "functionSource": "static int add_to_include_set ( struct include_data * data , const unsigned char * sha1 , int bitmap_pos ) {\n khiter_t hash_pos ;\n if ( data -> seen && bitmap_get ( data -> seen , bitmap_pos ) ) return 0 ;\n if ( bitmap_get ( data -> base , bitmap_pos ) ) return 0 ;\n hash_pos = kh_get_sha1 ( bitmap_git . bitmaps , sha1 ) ;\n if ( hash_pos < kh_end ( bitmap_git . bitmaps ) ) {\n struct stored_bitmap * st = kh_value ( bitmap_git . bitmaps , hash_pos ) ;\n bitmap_or_ewah ( data -> base , lookup_stored_bitmap ( st ) ) ;\n return 0 ;\n }\n bitmap_set ( data -> base , bitmap_pos ) ;\n return 1 ;\n }", "idx": 1668}
{"hash": -5706788925640467782, "project": "chrome", "size": 78, "label": 1, "functionSource": "static void encode_rd_sb_row ( VP9_COMP * cpi , const TileInfo * const tile , int mi_row , TOKENEXTRA * * tp ) {\n VP9_COMMON * const cm = & cpi -> common ;\n MACROBLOCKD * const xd = & cpi -> mb . e_mbd ;\n SPEED_FEATURES * const sf = & cpi -> sf ;\n int mi_col ;\n vpx_memset ( & xd -> left_context , 0 , sizeof ( xd -> left_context ) ) ;\n vpx_memset ( xd -> left_seg_context , 0 , sizeof ( xd -> left_seg_context ) ) ;\n for ( mi_col = tile -> mi_col_start ;\n mi_col < tile -> mi_col_end ;\n mi_col += MI_BLOCK_SIZE ) {\n int dummy_rate ;\n int64_t dummy_dist ;\n int i ;\n if ( sf -> adaptive_pred_interp_filter ) {\n for ( i = 0 ;\n i < 64 ;\n ++ i ) cpi -> leaf_tree [ i ] . pred_interp_filter = SWITCHABLE ;\n for ( i = 0 ;\n i < 64 ;\n ++ i ) {\n cpi -> pc_tree [ i ] . vertical [ 0 ] . pred_interp_filter = SWITCHABLE ;\n cpi -> pc_tree [ i ] . vertical [ 1 ] . pred_interp_filter = SWITCHABLE ;\n cpi -> pc_tree [ i ] . horizontal [ 0 ] . pred_interp_filter = SWITCHABLE ;\n cpi -> pc_tree [ i ] . horizontal [ 1 ] . pred_interp_filter = SWITCHABLE ;\n }\n }\n vp9_zero ( cpi -> mb . pred_mv ) ;\n cpi -> pc_root -> index = 0 ;\n if ( ( sf -> partition_search_type == SEARCH_PARTITION && sf -> use_lastframe_partitioning ) || sf -> partition_search_type == FIXED_PARTITION || sf -> partition_search_type == VAR_BASED_PARTITION || sf -> partition_search_type == VAR_BASED_FIXED_PARTITION ) {\n const int idx_str = cm -> mi_stride * mi_row + mi_col ;\n MODE_INFO * * mi = cm -> mi_grid_visible + idx_str ;\n MODE_INFO * * prev_mi = cm -> prev_mi_grid_visible + idx_str ;\n cpi -> mb . source_variance = UINT_MAX ;\n if ( sf -> partition_search_type == FIXED_PARTITION ) {\n set_offsets ( cpi , tile , mi_row , mi_col , BLOCK_64X64 ) ;\n set_fixed_partitioning ( cpi , tile , mi , mi_row , mi_col , sf -> always_this_block_size ) ;\n rd_use_partition ( cpi , tile , mi , tp , mi_row , mi_col , BLOCK_64X64 , & dummy_rate , & dummy_dist , 1 , cpi -> pc_root ) ;\n }\n else if ( cpi -> skippable_frame || sf -> partition_search_type == VAR_BASED_FIXED_PARTITION ) {\n BLOCK_SIZE bsize ;\n set_offsets ( cpi , tile , mi_row , mi_col , BLOCK_64X64 ) ;\n bsize = get_rd_var_based_fixed_partition ( cpi , mi_row , mi_col ) ;\n set_fixed_partitioning ( cpi , tile , mi , mi_row , mi_col , bsize ) ;\n rd_use_partition ( cpi , tile , mi , tp , mi_row , mi_col , BLOCK_64X64 , & dummy_rate , & dummy_dist , 1 , cpi -> pc_root ) ;\n }\n else if ( sf -> partition_search_type == VAR_BASED_PARTITION ) {\n choose_partitioning ( cpi , tile , mi_row , mi_col ) ;\n rd_use_partition ( cpi , tile , mi , tp , mi_row , mi_col , BLOCK_64X64 , & dummy_rate , & dummy_dist , 1 , cpi -> pc_root ) ;\n }\n else {\n GF_GROUP * gf_grp = & cpi -> twopass . gf_group ;\n int last_was_mid_sequence_overlay = 0 ;\n if ( ( cpi -> oxcf . pass == 2 ) && ( gf_grp -> index ) ) {\n if ( gf_grp -> update_type [ gf_grp -> index - 1 ] == OVERLAY_UPDATE ) last_was_mid_sequence_overlay = 1 ;\n }\n if ( ( cpi -> rc . frames_since_key % sf -> last_partitioning_redo_frequency ) == 0 || last_was_mid_sequence_overlay || cm -> prev_mi == 0 || cm -> show_frame == 0 || cm -> frame_type == KEY_FRAME || cpi -> rc . is_src_frame_alt_ref || ( ( sf -> use_lastframe_partitioning == LAST_FRAME_PARTITION_LOW_MOTION ) && sb_has_motion ( cm , prev_mi , sf -> lf_motion_threshold ) ) ) {\n if ( sf -> auto_min_max_partition_size ) {\n set_offsets ( cpi , tile , mi_row , mi_col , BLOCK_64X64 ) ;\n rd_auto_partition_range ( cpi , tile , mi_row , mi_col , & sf -> min_partition_size , & sf -> max_partition_size ) ;\n }\n rd_pick_partition ( cpi , tile , tp , mi_row , mi_col , BLOCK_64X64 , & dummy_rate , & dummy_dist , INT64_MAX , cpi -> pc_root ) ;\n }\n else {\n if ( sf -> constrain_copy_partition && sb_has_motion ( cm , prev_mi , sf -> lf_motion_threshold ) ) constrain_copy_partitioning ( cpi , tile , mi , prev_mi , mi_row , mi_col , BLOCK_16X16 ) ;\n else copy_partitioning ( cm , mi , prev_mi ) ;\n rd_use_partition ( cpi , tile , mi , tp , mi_row , mi_col , BLOCK_64X64 , & dummy_rate , & dummy_dist , 1 , cpi -> pc_root ) ;\n }\n }\n }\n else {\n if ( sf -> auto_min_max_partition_size ) {\n set_offsets ( cpi , tile , mi_row , mi_col , BLOCK_64X64 ) ;\n rd_auto_partition_range ( cpi , tile , mi_row , mi_col , & sf -> min_partition_size , & sf -> max_partition_size ) ;\n }\n rd_pick_partition ( cpi , tile , tp , mi_row , mi_col , BLOCK_64X64 , & dummy_rate , & dummy_dist , INT64_MAX , cpi -> pc_root ) ;\n }\n }\n }", "idx": 1669}
{"hash": -3499560027604042885, "project": "chrome", "size": 5, "label": 0, "functionSource": "double vp9_vaq_rdmult_ratio ( int energy ) {\n ENERGY_IN_BOUNDS ( energy ) ;\n vp9_clear_system_state ( ) ;\n return RDMULT_RATIO ( energy ) ;\n }", "idx": 1670}
{"hash": 2120840145598099861, "project": "chrome", "size": 9, "label": 0, "functionSource": "static void exsltSaxonSystemIdFunction ( xmlXPathParserContextPtr ctxt , int nargs ) {\n if ( ctxt == NULL ) return ;\n if ( nargs != 0 ) {\n xmlXPathSetArityError ( ctxt ) ;\n return ;\n }\n if ( ( ctxt -> context ) && ( ctxt -> context -> doc ) && ( ctxt -> context -> doc -> URL ) ) valuePush ( ctxt , xmlXPathNewString ( ctxt -> context -> doc -> URL ) ) ;\n else valuePush ( ctxt , xmlXPathNewString ( BAD_CAST \"\" ) ) ;\n }", "idx": 1671}
{"hash": -6552851419396579257, "project": "debian", "size": 8, "label": 0, "functionSource": "static int dissect_spoolss_doc_info_1 ( tvbuff_t * tvb , int offset , packet_info * pinfo , proto_tree * tree , dcerpc_info * di , guint8 * drep ) {\n proto_tree * subtree ;\n subtree = proto_tree_add_subtree ( tree , tvb , offset , 0 , ett_DOC_INFO_1 , NULL , \"Document info level 1\" ) ;\n offset = dissect_ndr_str_pointer_item ( tvb , offset , pinfo , subtree , di , drep , NDR_POINTER_UNIQUE , \"Document name\" , hf_documentname , 0 ) ;\n offset = dissect_ndr_str_pointer_item ( tvb , offset , pinfo , subtree , di , drep , NDR_POINTER_UNIQUE , \"Output file\" , hf_outputfile , 0 ) ;\n offset = dissect_ndr_str_pointer_item ( tvb , offset , pinfo , subtree , di , drep , NDR_POINTER_UNIQUE , \"Data type\" , hf_datatype , 0 ) ;\n return offset ;\n }", "idx": 1672}
{"hash": -3955770052982962380, "project": "debian", "size": 16, "label": 0, "functionSource": "Jbig2PatternDict * jbig2_decode_ht_region_get_hpats ( Jbig2Ctx * ctx , Jbig2Segment * segment ) {\n int index = 0 ;\n Jbig2PatternDict * pattern_dict = NULL ;\n Jbig2Segment * rsegment = NULL ;\n while ( ! pattern_dict && segment -> referred_to_segment_count > index ) {\n rsegment = jbig2_find_segment ( ctx , segment -> referred_to_segments [ index ] ) ;\n if ( rsegment ) {\n if ( ( rsegment -> flags & 0x3f ) == 16 && rsegment -> result ) {\n pattern_dict = ( Jbig2PatternDict * ) rsegment -> result ;\n return pattern_dict ;\n }\n }\n index ++ ;\n }\n return pattern_dict ;\n }", "idx": 1673}
{"hash": 1859256631654516868, "project": "chrome", "size": 12, "label": 0, "functionSource": "static int decode_init_thread_copy ( AVCodecContext * avctx ) {\n H264Context * h = avctx -> priv_data ;\n if ( ! avctx -> internal -> is_copy ) return 0 ;\n memset ( h -> sps_buffers , 0 , sizeof ( h -> sps_buffers ) ) ;\n memset ( h -> pps_buffers , 0 , sizeof ( h -> pps_buffers ) ) ;\n h -> rbsp_buffer [ 0 ] = NULL ;\n h -> rbsp_buffer [ 1 ] = NULL ;\n h -> rbsp_buffer_size [ 0 ] = 0 ;\n h -> rbsp_buffer_size [ 1 ] = 0 ;\n h -> context_initialized = 0 ;\n return 0 ;\n }", "idx": 1674}
{"hash": 1172823007911381623, "project": "debian", "size": 27, "label": 0, "functionSource": "int ffv1_init_slice_state ( FFV1Context * f , FFV1Context * fs ) {\n int j ;\n fs -> plane_count = f -> plane_count ;\n fs -> transparency = f -> transparency ;\n for ( j = 0 ;\n j < f -> plane_count ;\n j ++ ) {\n PlaneContext * const p = & fs -> plane [ j ] ;\n if ( fs -> ac ) {\n if ( ! p -> state ) p -> state = av_malloc ( CONTEXT_SIZE * p -> context_count * sizeof ( uint8_t ) ) ;\n if ( ! p -> state ) return AVERROR ( ENOMEM ) ;\n }\n else {\n if ( ! p -> vlc_state ) p -> vlc_state = av_malloc ( p -> context_count * sizeof ( VlcState ) ) ;\n if ( ! p -> vlc_state ) return AVERROR ( ENOMEM ) ;\n }\n }\n if ( fs -> ac > 1 ) {\n for ( j = 1 ;\n j < 256 ;\n j ++ ) {\n fs -> c . one_state [ j ] = f -> state_transition [ j ] ;\n fs -> c . zero_state [ 256 - j ] = 256 - fs -> c . one_state [ j ] ;\n }\n }\n return 0 ;\n }", "idx": 1675}
{"hash": -6068976579504840746, "project": "debian", "size": 56, "label": 0, "functionSource": "static void ctl_flushpkt ( u_char more ) {\n size_t i ;\n int dlen ;\n int sendlen ;\n int maclen ;\n int totlen ;\n keyid_t keyid ;\n dlen = datapt - rpkt . u . data ;\n if ( ! more && datanotbinflag && dlen + 2 < CTL_MAX_DATA_LEN ) {\n * datapt ++ = '\\r' ;\n * datapt ++ = '\\n' ;\n dlen += 2 ;\n }\n sendlen = dlen + CTL_HEADER_LEN ;\n while ( sendlen & 0x3 ) {\n * datapt ++ = '\\0' ;\n sendlen ++ ;\n }\n rpkt . r_m_e_op = CTL_RESPONSE | more | ( res_opcode & CTL_OP_MASK ) ;\n rpkt . count = htons ( ( u_short ) dlen ) ;\n rpkt . offset = htons ( ( u_short ) res_offset ) ;\n if ( res_async ) {\n for ( i = 0 ;\n i < COUNTOF ( ctl_traps ) ;\n i ++ ) {\n if ( TRAP_INUSE & ctl_traps [ i ] . tr_flags ) {\n rpkt . li_vn_mode = PKT_LI_VN_MODE ( sys_leap , ctl_traps [ i ] . tr_version , MODE_CONTROL ) ;\n rpkt . sequence = htons ( ctl_traps [ i ] . tr_sequence ) ;\n sendpkt ( & ctl_traps [ i ] . tr_addr , ctl_traps [ i ] . tr_localaddr , - 4 , ( struct pkt * ) & rpkt , sendlen ) ;\n if ( ! more ) ctl_traps [ i ] . tr_sequence ++ ;\n numasyncmsgs ++ ;\n }\n }\n }\n else {\n if ( res_authenticate && sys_authenticate ) {\n totlen = sendlen ;\n while ( totlen & 7 ) {\n * datapt ++ = '\\0' ;\n totlen ++ ;\n }\n keyid = htonl ( res_keyid ) ;\n memcpy ( datapt , & keyid , sizeof ( keyid ) ) ;\n maclen = authencrypt ( res_keyid , ( u_int32 * ) & rpkt , totlen ) ;\n sendpkt ( rmt_addr , lcl_inter , - 5 , ( struct pkt * ) & rpkt , totlen + maclen ) ;\n }\n else {\n sendpkt ( rmt_addr , lcl_inter , - 6 , ( struct pkt * ) & rpkt , sendlen ) ;\n }\n if ( more ) numctlfrags ++ ;\n else numctlresponses ++ ;\n }\n res_frags ++ ;\n res_offset += dlen ;\n datapt = rpkt . u . data ;\n }", "idx": 1676}
{"hash": 3035587999006680483, "project": "debian", "size": 14, "label": 0, "functionSource": "static int dtls1_add_cert_to_buf ( BUF_MEM * buf , unsigned long * l , X509 * x ) {\n int n ;\n unsigned char * p ;\n n = i2d_X509 ( x , NULL ) ;\n if ( ! BUF_MEM_grow_clean ( buf , ( int ) ( n + ( * l ) + 3 ) ) ) {\n SSLerr ( SSL_F_DTLS1_ADD_CERT_TO_BUF , ERR_R_BUF_LIB ) ;\n return 0 ;\n }\n p = ( unsigned char * ) & ( buf -> data [ * l ] ) ;\n l2n3 ( n , p ) ;\n i2d_X509 ( x , & p ) ;\n * l += n + 3 ;\n return 1 ;\n }", "idx": 1677}
{"hash": -2242211406757466627, "project": "debian", "size": 29, "label": 0, "functionSource": "static void advance_to_end_of_signature ( guint8 * * signature , guint8 * signature_length ) {\n gboolean done = FALSE ;\n gint8 current_type ;\n gint8 end_type = ARG_INVALID ;\n while ( * ( ++ ( * signature ) ) && -- ( * signature_length ) > 0 && ! done ) {\n current_type = * * signature ;\n if ( end_type != ARG_INVALID ) {\n if ( end_type == current_type ) {\n done = TRUE ;\n }\n continue ;\n }\n switch ( current_type ) {\n case ARG_ARRAY : advance_to_end_of_signature ( signature , signature_length ) ;\n break ;\n case ARG_STRUCT : end_type = ')' ;\n advance_to_end_of_signature ( signature , signature_length ) ;\n break ;\n case ARG_DICT_ENTRY : end_type = '}\n' ;\n advance_to_end_of_signature ( signature , signature_length ) ;\n break ;\n case ARG_BYTE : case ARG_DOUBLE : case ARG_UINT64 : case ARG_INT64 : case ARG_SIGNATURE : case ARG_HANDLE : case ARG_INT32 : case ARG_UINT32 : case ARG_BOOLEAN : case ARG_INT16 : case ARG_UINT16 : case ARG_STRING : case ARG_VARIANT : case ARG_OBJ_PATH : done = TRUE ;\n break ;\n default : done = TRUE ;\n break ;\n }\n }\n }", "idx": 1678}
{"hash": 1760449185745615462, "project": "debian", "size": 12, "label": 0, "functionSource": "TSReturnCode TSHttpArgIndexLookup ( int arg_idx , const char * * name , const char * * description ) {\n if ( sdk_sanity_check_null_ptr ( name ) == TS_SUCCESS ) {\n if ( state_arg_table [ arg_idx ] . name ) {\n * name = state_arg_table [ arg_idx ] . name ;\n if ( description ) {\n * description = state_arg_table [ arg_idx ] . description ;\n }\n return TS_SUCCESS ;\n }\n }\n return TS_ERROR ;\n }", "idx": 1679}
{"hash": 5991533509192663951, "project": "debian", "size": 11, "label": 0, "functionSource": "mbfl_string * mbfl_buffer_converter_getbuffer ( mbfl_buffer_converter * convd , mbfl_string * result ) {\n if ( convd != NULL && result != NULL && convd -> device . buffer != NULL ) {\n result -> no_encoding = convd -> to -> no_encoding ;\n result -> val = convd -> device . buffer ;\n result -> len = convd -> device . pos ;\n }\n else {\n result = NULL ;\n }\n return result ;\n }", "idx": 1680}
{"hash": -7415191846425595149, "project": "chrome", "size": 19, "label": 1, "functionSource": "static int alloc_mi ( VP9_COMMON * cm , int mi_size ) {\n int i ;\n for ( i = 0 ;\n i < 2 ;\n ++ i ) {\n cm -> mip_array [ i ] = ( MODE_INFO * ) vpx_calloc ( mi_size , sizeof ( MODE_INFO ) ) ;\n if ( cm -> mip_array [ i ] == NULL ) return 1 ;\n cm -> mi_grid_base_array [ i ] = ( MODE_INFO * * ) vpx_calloc ( mi_size , sizeof ( MODE_INFO * ) ) ;\n if ( cm -> mi_grid_base_array [ i ] == NULL ) return 1 ;\n }\n cm -> mi_alloc_size = mi_size ;\n cm -> mi_idx = 0 ;\n cm -> prev_mi_idx = 1 ;\n cm -> mip = cm -> mip_array [ cm -> mi_idx ] ;\n cm -> prev_mip = cm -> mip_array [ cm -> prev_mi_idx ] ;\n cm -> mi_grid_base = cm -> mi_grid_base_array [ cm -> mi_idx ] ;\n cm -> prev_mi_grid_base = cm -> mi_grid_base_array [ cm -> prev_mi_idx ] ;\n return 0 ;\n }", "idx": 1681}
{"hash": -7855974557509681261, "project": "debian", "size": 12, "label": 0, "functionSource": "int16 get_typlen ( Oid typid ) {\n HeapTuple tp ;\n tp = SearchSysCache1 ( TYPEOID , ObjectIdGetDatum ( typid ) ) ;\n if ( HeapTupleIsValid ( tp ) ) {\n Form_pg_type typtup = ( Form_pg_type ) GETSTRUCT ( tp ) ;\n int16 result ;\n result = typtup -> typlen ;\n ReleaseSysCache ( tp ) ;\n return result ;\n }\n else return 0 ;\n }", "idx": 1682}
{"hash": -2723830976796502611, "project": "chrome", "size": 5, "label": 0, "functionSource": "static vpx_codec_err_t ctrl_update_reference ( vpx_codec_alg_priv_t * ctx , va_list args ) {\n const int ref_frame_flags = va_arg ( args , int ) ;\n vp9_update_reference ( ctx -> cpi , ref_frame_flags ) ;\n return VPX_CODEC_OK ;\n }", "idx": 1683}
{"hash": 914926989019402478, "project": "debian", "size": 33, "label": 1, "functionSource": "static void main_get_appheader ( xd3_stream * stream , main_file * ifile , main_file * output , main_file * sfile ) {\n uint8_t * apphead ;\n usize_t appheadsz ;\n int ret ;\n if ( ! option_use_appheader ) {\n return ;\n }\n ret = xd3_get_appheader ( stream , & apphead , & appheadsz ) ;\n if ( ret != 0 ) {\n return ;\n }\n if ( appheadsz > 0 ) {\n char * start = ( char * ) apphead ;\n char * slash ;\n int place = 0 ;\n char * parsed [ 4 ] ;\n memset ( parsed , 0 , sizeof ( parsed ) ) ;\n while ( ( slash = strchr ( start , '/' ) ) != NULL ) {\n * slash = 0 ;\n parsed [ place ++ ] = start ;\n start = slash + 1 ;\n }\n parsed [ place ++ ] = start ;\n if ( place == 2 || place == 4 ) {\n main_get_appheader_params ( output , parsed , 1 , \"output\" , ifile ) ;\n }\n if ( place == 4 ) {\n main_get_appheader_params ( sfile , parsed + 2 , 0 , \"source\" , ifile ) ;\n }\n }\n option_use_appheader = 0 ;\n return ;\n }", "idx": 1684}
{"hash": -2423144171479606949, "project": "debian", "size": 4, "label": 0, "functionSource": "static void pdf_run_bstar ( fz_context * ctx , pdf_processor * proc ) {\n pdf_run_processor * pr = ( pdf_run_processor * ) proc ;\n pdf_show_path ( ctx , pr , 1 , 1 , 1 , 1 ) ;\n }", "idx": 1685}
{"hash": 2709342705526909410, "project": "debian", "size": 39, "label": 0, "functionSource": "MSG_PROCESS_RETURN tls_process_change_cipher_spec ( SSL * s , PACKET * pkt ) {\n int al ;\n long remain ;\n remain = PACKET_remaining ( pkt ) ;\n if ( SSL_IS_DTLS ( s ) ) {\n if ( ( s -> version == DTLS1_BAD_VER && remain != DTLS1_CCS_HEADER_LENGTH + 1 ) || ( s -> version != DTLS1_BAD_VER && remain != DTLS1_CCS_HEADER_LENGTH - 1 ) ) {\n al = SSL_AD_ILLEGAL_PARAMETER ;\n SSLerr ( SSL_F_TLS_PROCESS_CHANGE_CIPHER_SPEC , SSL_R_BAD_CHANGE_CIPHER_SPEC ) ;\n goto f_err ;\n }\n }\n else {\n if ( remain != 0 ) {\n al = SSL_AD_ILLEGAL_PARAMETER ;\n SSLerr ( SSL_F_TLS_PROCESS_CHANGE_CIPHER_SPEC , SSL_R_BAD_CHANGE_CIPHER_SPEC ) ;\n goto f_err ;\n }\n }\n if ( s -> s3 -> tmp . new_cipher == NULL ) {\n al = SSL_AD_UNEXPECTED_MESSAGE ;\n SSLerr ( SSL_F_TLS_PROCESS_CHANGE_CIPHER_SPEC , SSL_R_CCS_RECEIVED_EARLY ) ;\n goto f_err ;\n }\n s -> s3 -> change_cipher_spec = 1 ;\n if ( ! ssl3_do_change_cipher_spec ( s ) ) {\n al = SSL_AD_INTERNAL_ERROR ;\n SSLerr ( SSL_F_TLS_PROCESS_CHANGE_CIPHER_SPEC , ERR_R_INTERNAL_ERROR ) ;\n goto f_err ;\n }\n if ( SSL_IS_DTLS ( s ) ) {\n dtls1_reset_seq_numbers ( s , SSL3_CC_READ ) ;\n if ( s -> version == DTLS1_BAD_VER ) s -> d1 -> handshake_read_seq ++ ;\n # ifndef OPENSSL_NO_SCTP BIO_ctrl ( SSL_get_wbio ( s ) , BIO_CTRL_DGRAM_SCTP_AUTH_CCS_RCVD , 1 , NULL ) ;\n # endif }\n return MSG_PROCESS_CONTINUE_READING ;\n f_err : ssl3_send_alert ( s , SSL3_AL_FATAL , al ) ;\n ossl_statem_set_error ( s ) ;\n return MSG_PROCESS_ERROR ;\n }", "idx": 1686}
{"hash": 6667142528452941476, "project": "debian", "size": 26, "label": 0, "functionSource": "int init_dumping_tables ( char * qdatabase ) {\n DBUG_ENTER ( \"init_dumping_tables\" ) ;\n if ( ! opt_create_db ) {\n char qbuf [ 256 ] ;\n MYSQL_ROW row ;\n MYSQL_RES * dbinfo ;\n my_snprintf ( qbuf , sizeof ( qbuf ) , \"SHOW CREATE DATABASE IF NOT EXISTS %s\" , qdatabase ) ;\n if ( mysql_query ( mysql , qbuf ) || ! ( dbinfo = mysql_store_result ( mysql ) ) ) {\n if ( opt_drop_database ) fprintf ( md_result_file , \"\\n/*!40000 DROP DATABASE IF EXISTS %s*/;\n\\n\" , qdatabase ) ;\n fprintf ( md_result_file , \"\\nCREATE DATABASE /*!32312 IF NOT EXISTS*/ %s;\n\\n\" , qdatabase ) ;\n }\n else {\n if ( opt_drop_database ) fprintf ( md_result_file , \"\\n/*!40000 DROP DATABASE IF EXISTS %s*/;\n\\n\" , qdatabase ) ;\n row = mysql_fetch_row ( dbinfo ) ;\n if ( row [ 1 ] ) {\n fprintf ( md_result_file , \"\\n%s;\n\\n\" , row [ 1 ] ) ;\n }\n mysql_free_result ( dbinfo ) ;\n }\n }\n DBUG_RETURN ( 0 ) ;\n }", "idx": 1687}
{"hash": 2687336064028423153, "project": "chrome", "size": 8, "label": 0, "functionSource": "static void search_set_from_hostname ( void ) {\n char hostname [ HOST_NAME_MAX + 1 ] , * domainname ;\n search_postfix_clear ( ) ;\n if ( gethostname ( hostname , sizeof ( hostname ) ) ) return ;\n domainname = strchr ( hostname , '.' ) ;\n if ( ! domainname ) return ;\n search_postfix_add ( domainname ) ;\n }", "idx": 1688}
{"hash": -7670127399145950875, "project": "debian", "size": 3, "label": 0, "functionSource": "int gs_to_exit ( const gs_memory_t * mem , int exit_status ) {\n return gs_to_exit_with_code ( mem , exit_status , 0 ) ;\n }", "idx": 1689}
{"hash": 2930500905204315787, "project": "debian", "size": 4, "label": 1, "functionSource": "static __inline__ __u32 __arch_swab32 ( __u32 val ) {\n __asm__ ( \"bswapl %0\" : \"=r\" ( val ) : \"0\" ( val ) ) ;\n return val ;\n }", "idx": 1690}
{"hash": 4489017523191997023, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h225_StimulusControl ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_StimulusControl , StimulusControl_sequence ) ;\n return offset ;\n }", "idx": 1691}
{"hash": 2390790920103114259, "project": "debian", "size": 6, "label": 0, "functionSource": "static long nfatree ( struct vars * v , struct subre * t , FILE * f ) {\n assert ( t != NULL && t -> begin != NULL ) ;\n if ( t -> left != NULL ) ( DISCARD ) nfatree ( v , t -> left , f ) ;\n if ( t -> right != NULL ) ( DISCARD ) nfatree ( v , t -> right , f ) ;\n return nfanode ( v , t , 0 , f ) ;\n }", "idx": 1692}
{"hash": -5361762812461354840, "project": "chrome", "size": 12, "label": 0, "functionSource": "static int32_t findNextEsc ( const char * source , const char * sourceLimit ) {\n int32_t length = sourceLimit - source ;\n int32_t i ;\n for ( i = 1 ;\n i < length ;\n i ++ ) {\n if ( * ( source + i ) == 0x1B ) {\n return i ;\n }\n }\n return length ;\n }", "idx": 1693}
{"hash": 9160937366035817353, "project": "chrome", "size": 3, "label": 0, "functionSource": "int vp9_fast_hex_search ( const MACROBLOCK * x , MV * ref_mv , int search_param , int sad_per_bit , int do_init_search , int * sad_list , const vp9_variance_fn_ptr_t * vfp , int use_mvcost , const MV * center_mv , MV * best_mv ) {\n return vp9_hex_search ( x , ref_mv , MAX ( MAX_MVSEARCH_STEPS - 2 , search_param ) , sad_per_bit , do_init_search , sad_list , vfp , use_mvcost , center_mv , best_mv ) ;\n }", "idx": 1694}
{"hash": -9197960073880365676, "project": "debian", "size": 15, "label": 0, "functionSource": "static Gif_Colormap * read_color_table ( int size , Gif_Reader * grr ) {\n Gif_Colormap * gfcm = Gif_NewFullColormap ( size , size ) ;\n Gif_Color * c ;\n if ( ! gfcm ) return 0 ;\n GIF_DEBUG ( ( \"colormap(%d) \" , size ) ) ;\n for ( c = gfcm -> col ;\n size ;\n size -- , c ++ ) {\n c -> gfc_red = gifgetbyte ( grr ) ;\n c -> gfc_green = gifgetbyte ( grr ) ;\n c -> gfc_blue = gifgetbyte ( grr ) ;\n c -> haspixel = 0 ;\n }\n return gfcm ;\n }", "idx": 1695}
{"hash": 3315269357322037767, "project": "debian", "size": 7, "label": 0, "functionSource": "apr_status_t xml_cleanup ( modsec_rec * msr ) {\n if ( msr -> xml -> doc != NULL ) {\n xmlFreeDoc ( msr -> xml -> doc ) ;\n msr -> xml -> doc = NULL ;\n }\n return 1 ;\n }", "idx": 1696}
{"hash": -3819889754140204145, "project": "debian", "size": 10, "label": 0, "functionSource": "METHOD ( certificate_t , get_validity , bool , private_x509_cert_t * this , time_t * when , time_t * not_before , time_t * not_after ) {\n time_t t = when ? * when : time ( NULL ) ;\n if ( not_before ) {\n * not_before = this -> notBefore ;\n }\n if ( not_after ) {\n * not_after = this -> notAfter ;\n }\n return ( t >= this -> notBefore && t <= this -> notAfter ) ;\n }", "idx": 1697}
{"hash": -7117046864335130087, "project": "chrome", "size": 17, "label": 0, "functionSource": "static void update_golden_frame_stats ( VP9_COMP * cpi ) {\n RATE_CONTROL * const rc = & cpi -> rc ;\n if ( cpi -> refresh_golden_frame ) {\n rc -> frames_since_golden = 0 ;\n if ( cpi -> oxcf . pass == 2 ) {\n if ( ! rc -> source_alt_ref_pending && cpi -> twopass . gf_group . rf_level [ 0 ] == GF_ARF_STD ) rc -> source_alt_ref_active = 0 ;\n }\n else if ( ! rc -> source_alt_ref_pending ) {\n rc -> source_alt_ref_active = 0 ;\n }\n if ( rc -> frames_till_gf_update_due > 0 ) rc -> frames_till_gf_update_due -- ;\n }\n else if ( ! cpi -> refresh_alt_ref_frame ) {\n if ( rc -> frames_till_gf_update_due > 0 ) rc -> frames_till_gf_update_due -- ;\n rc -> frames_since_golden ++ ;\n }\n }", "idx": 1698}
{"hash": 6415329349331062723, "project": "chrome", "size": 23, "label": 0, "functionSource": "static struct evhttp * http_setup ( short * pport , struct event_base * base ) {\n int i ;\n struct evhttp * myhttp ;\n short port = - 1 ;\n myhttp = evhttp_new ( base ) ;\n for ( i = 0 ;\n i < 50 ;\n ++ i ) {\n if ( evhttp_bind_socket ( myhttp , \"127.0.0.1\" , 8080 + i ) != - 1 ) {\n port = 8080 + i ;\n break ;\n }\n }\n if ( port == - 1 ) event_errx ( 1 , \"Could not start web server\" ) ;\n evhttp_set_cb ( myhttp , \"/test\" , http_basic_cb , NULL ) ;\n evhttp_set_cb ( myhttp , \"/chunked\" , http_chunked_cb , NULL ) ;\n evhttp_set_cb ( myhttp , \"/postit\" , http_post_cb , NULL ) ;\n evhttp_set_cb ( myhttp , \"/largedelay\" , http_large_delay_cb , NULL ) ;\n evhttp_set_cb ( myhttp , \"/badrequest\" , http_badreq_cb , NULL ) ;\n evhttp_set_cb ( myhttp , \"/\" , http_dispatcher_cb , NULL ) ;\n * pport = port ;\n return ( myhttp ) ;\n }", "idx": 1699}
{"hash": -7683902591435073306, "project": "debian", "size": 13, "label": 0, "functionSource": "static apr_status_t modsecurity_tx_cleanup ( void * data ) {\n modsec_rec * msr = ( modsec_rec * ) data ;\n char * my_error_msg = NULL ;\n if ( msr == NULL ) return APR_SUCCESS ;\n if ( msr -> mpd != NULL ) multipart_cleanup ( msr ) ;\n if ( msr -> xml != NULL ) xml_cleanup ( msr ) ;\n modsecurity_request_body_clear ( msr , & my_error_msg ) ;\n if ( my_error_msg != NULL ) {\n msr_log ( msr , 1 , \"%s\" , my_error_msg ) ;\n }\n # if defined ( WITH_LUA ) # ifdef CACHE_LUA if ( msr -> L != NULL ) lua_close ( msr -> L ) ;\n # endif # endif return APR_SUCCESS ;\n }", "idx": 1700}
{"hash": 5452557062588481527, "project": "debian", "size": 72, "label": 0, "functionSource": "static void compress ( int init_bits , gdIOCtxPtr outfile , gdImagePtr im , GifCtx * ctx ) {\n register long fcode ;\n register code_int i ;\n register int c ;\n register code_int ent ;\n register code_int disp ;\n register code_int hsize_reg ;\n register int hshift ;\n ctx -> g_init_bits = init_bits ;\n ctx -> g_outfile = outfile ;\n ctx -> offset = 0 ;\n ctx -> out_count = 0 ;\n ctx -> clear_flg = 0 ;\n ctx -> in_count = 1 ;\n ctx -> maxcode = MAXCODE ( ctx -> n_bits = ctx -> g_init_bits ) ;\n ctx -> ClearCode = ( 1 << ( init_bits - 1 ) ) ;\n ctx -> EOFCode = ctx -> ClearCode + 1 ;\n ctx -> free_ent = ctx -> ClearCode + 2 ;\n char_init ( ctx ) ;\n ent = GIFNextPixel ( im , ctx ) ;\n hshift = 0 ;\n for ( fcode = ( long ) hsize ;\n fcode < 65536L ;\n fcode *= 2L ) {\n ++ hshift ;\n }\n hshift = 8 - hshift ;\n hsize_reg = hsize ;\n cl_hash ( ( count_int ) hsize_reg , ctx ) ;\n output ( ( code_int ) ctx -> ClearCode , ctx ) ;\n # ifdef SIGNED_COMPARE_SLOW while ( ( c = GIFNextPixel ( im ) ) != ( unsigned ) EOF ) {\n # else while ( ( c = GIFNextPixel ( im , ctx ) ) != EOF ) {\n # endif ++ ( ctx -> in_count ) ;\n fcode = ( long ) ( ( ( long ) c << maxbits ) + ent ) ;\n i = ( ( ( code_int ) c << hshift ) ^ ent ) ;\n if ( HashTabOf ( i ) == fcode ) {\n ent = CodeTabOf ( i ) ;\n continue ;\n }\n else if ( ( long ) HashTabOf ( i ) < 0 ) {\n goto nomatch ;\n }\n disp = hsize_reg - i ;\n if ( i == 0 ) {\n disp = 1 ;\n }\n probe : if ( ( i -= disp ) < 0 ) {\n i += hsize_reg ;\n }\n if ( HashTabOf ( i ) == fcode ) {\n ent = CodeTabOf ( i ) ;\n continue ;\n }\n if ( ( long ) HashTabOf ( i ) > 0 ) {\n goto probe ;\n }\n nomatch : output ( ( code_int ) ent , ctx ) ;\n ++ ( ctx -> out_count ) ;\n ent = c ;\n # ifdef SIGNED_COMPARE_SLOW if ( ( unsigned ) ctx -> free_ent < ( unsigned ) maxmaxcode ) {\n # else if ( ctx -> free_ent < maxmaxcode ) {\n # endif CodeTabOf ( i ) = ctx -> free_ent ++ ;\n HashTabOf ( i ) = fcode ;\n }\n else {\n cl_block ( ctx ) ;\n }\n }\n output ( ( code_int ) ent , ctx ) ;\n ++ ( ctx -> out_count ) ;\n output ( ( code_int ) ctx -> EOFCode , ctx ) ;\n }", "idx": 1701}
{"hash": 3804373597256531021, "project": "debian", "size": 17, "label": 0, "functionSource": "static bool test_if_create_new_users ( THD * thd ) {\n Security_context * sctx = thd -> security_ctx ;\n bool create_new_users = test ( sctx -> master_access & INSERT_ACL ) || ( ! opt_safe_user_create && test ( sctx -> master_access & CREATE_USER_ACL ) ) ;\n if ( ! create_new_users ) {\n TABLE_LIST tl ;\n ulong db_access ;\n bzero ( ( char * ) & tl , sizeof ( tl ) ) ;\n tl . db = ( char * ) \"mysql\" ;\n tl . table_name = ( char * ) \"user\" ;\n create_new_users = 1 ;\n db_access = acl_get ( sctx -> host , sctx -> ip , sctx -> priv_user , tl . db , 0 ) ;\n if ( ! ( db_access & INSERT_ACL ) ) {\n if ( check_grant ( thd , INSERT_ACL , & tl , 0 , UINT_MAX , 1 ) ) create_new_users = 0 ;\n }\n }\n return create_new_users ;\n }", "idx": 1702}
{"hash": -8589152252830017940, "project": "debian", "size": 9, "label": 0, "functionSource": "static struct kwajd_stream * lzh_init ( struct mspack_system * sys , struct mspack_file * in , struct mspack_file * out ) {\n struct kwajd_stream * lzh ;\n if ( ! sys || ! in || ! out ) return NULL ;\n if ( ! ( lzh = ( struct kwajd_stream * ) sys -> alloc ( sys , sizeof ( struct kwajd_stream ) ) ) ) return NULL ;\n lzh -> sys = sys ;\n lzh -> input = in ;\n lzh -> output = out ;\n return lzh ;\n }", "idx": 1703}
{"hash": -2971164434690241379, "project": "debian", "size": 62, "label": 1, "functionSource": "void stp_print ( netdissect_options * ndo , const u_char * p , u_int length ) {\n const struct stp_bpdu_ * stp_bpdu ;\n u_int mstp_len ;\n u_int spb_len ;\n stp_bpdu = ( const struct stp_bpdu_ * ) p ;\n if ( length < 4 ) goto trunc ;\n ND_TCHECK ( stp_bpdu -> protocol_id ) ;\n if ( EXTRACT_16BITS ( & stp_bpdu -> protocol_id ) ) {\n ND_PRINT ( ( ndo , \"unknown STP version, length %u\" , length ) ) ;\n return ;\n }\n ND_TCHECK ( stp_bpdu -> protocol_version ) ;\n ND_PRINT ( ( ndo , \"STP %s\" , tok2str ( stp_proto_values , \"Unknown STP protocol (0x%02x)\" , stp_bpdu -> protocol_version ) ) ) ;\n switch ( stp_bpdu -> protocol_version ) {\n case STP_PROTO_REGULAR : case STP_PROTO_RAPID : case STP_PROTO_MSTP : case STP_PROTO_SPB : break ;\n default : return ;\n }\n ND_TCHECK ( stp_bpdu -> bpdu_type ) ;\n ND_PRINT ( ( ndo , \", %s\" , tok2str ( stp_bpdu_type_values , \"Unknown BPDU Type (0x%02x)\" , stp_bpdu -> bpdu_type ) ) ) ;\n switch ( stp_bpdu -> bpdu_type ) {\n case STP_BPDU_TYPE_CONFIG : if ( length < sizeof ( struct stp_bpdu_ ) - 1 ) {\n goto trunc ;\n }\n if ( ! stp_print_config_bpdu ( ndo , stp_bpdu , length ) ) goto trunc ;\n break ;\n case STP_BPDU_TYPE_RSTP : if ( stp_bpdu -> protocol_version == STP_PROTO_RAPID ) {\n if ( length < sizeof ( struct stp_bpdu_ ) ) {\n goto trunc ;\n }\n if ( ! stp_print_config_bpdu ( ndo , stp_bpdu , length ) ) goto trunc ;\n }\n else if ( stp_bpdu -> protocol_version == STP_PROTO_MSTP || stp_bpdu -> protocol_version == STP_PROTO_SPB ) {\n if ( length < STP_BPDU_MSTP_MIN_LEN ) {\n goto trunc ;\n }\n ND_TCHECK ( stp_bpdu -> v1_length ) ;\n if ( stp_bpdu -> v1_length != 0 ) {\n goto trunc ;\n }\n ND_TCHECK_16BITS ( p + MST_BPDU_VER3_LEN_OFFSET ) ;\n mstp_len = EXTRACT_16BITS ( p + MST_BPDU_VER3_LEN_OFFSET ) ;\n mstp_len += 2 ;\n if ( length < ( sizeof ( struct stp_bpdu_ ) + mstp_len ) ) {\n goto trunc ;\n }\n if ( ! stp_print_mstp_bpdu ( ndo , stp_bpdu , length ) ) goto trunc ;\n if ( stp_bpdu -> protocol_version == STP_PROTO_SPB ) {\n spb_len = EXTRACT_16BITS ( p + MST_BPDU_VER3_LEN_OFFSET + mstp_len ) ;\n spb_len += 2 ;\n if ( length < ( sizeof ( struct stp_bpdu_ ) + mstp_len + spb_len ) || spb_len < SPB_BPDU_MIN_LEN ) {\n goto trunc ;\n }\n if ( ! stp_print_spb_bpdu ( ndo , stp_bpdu , ( sizeof ( struct stp_bpdu_ ) + mstp_len ) ) ) goto trunc ;\n }\n }\n break ;\n case STP_BPDU_TYPE_TOPO_CHANGE : break ;\n default : break ;\n }\n return ;\n trunc : ND_PRINT ( ( ndo , \"[|stp %d]\" , length ) ) ;\n }", "idx": 1704}
{"hash": -6580451576689962916, "project": "debian", "size": 4, "label": 0, "functionSource": "static char * ext_t_0_wml_10 ( tvbuff_t * tvb , guint32 value , guint32 str_tbl ) {\n char * str = wmem_strdup_printf ( wmem_packet_scope ( ) , \"Variable substitution - escaped: '%s'\" , tvb_get_const_stringz ( tvb , str_tbl + value , NULL ) ) ;\n return str ;\n }", "idx": 1705}
{"hash": 3584320764213684062, "project": "debian", "size": 56, "label": 1, "functionSource": "static int parse_CRestriction ( tvbuff_t * tvb , int offset , proto_tree * parent_tree , proto_tree * pad_tree , struct CRestriction * v , const char * fmt , ... ) {\n proto_tree * tree ;\n proto_item * item ;\n const char * str , * txt ;\n va_list ap ;\n va_start ( ap , fmt ) ;\n txt = wmem_strdup_vprintf ( wmem_packet_scope ( ) , fmt , ap ) ;\n va_end ( ap ) ;\n tree = proto_tree_add_subtree ( parent_tree , tvb , offset , 0 , ett_CRestriction , & item , txt ) ;\n offset = parse_rType ( tvb , offset , tree , & v -> ulType , & str ) ;\n proto_item_append_text ( item , \" Type: %s\" , str ) ;\n v -> Weight = tvb_get_letohl ( tvb , offset ) ;\n proto_tree_add_uint ( tree , hf_mswsp_crestrict_weight , tvb , offset , 4 , v -> Weight ) ;\n offset += 4 ;\n switch ( v -> ulType ) {\n case RTNone : break ;\n case RTAnd : case RTOr : case RTProximity : case RTPhrase : {\n v -> u . RTAnd = EP_ALLOC ( struct CNodeRestriction ) ;\n offset = parse_CNodeRestriction ( tvb , offset , tree , pad_tree , v -> u . RTAnd , \"CNodeRestriction\" ) ;\n break ;\n }\n case RTNot : {\n v -> u . RTNot = EP_ALLOC ( struct CRestriction ) ;\n offset = parse_CRestriction ( tvb , offset , tree , pad_tree , v -> u . RTNot , \"CRestriction\" ) ;\n break ;\n }\n case RTProperty : {\n v -> u . RTProperty = EP_ALLOC ( struct CPropertyRestriction ) ;\n offset = parse_CPropertyRestriction ( tvb , offset , tree , pad_tree , v -> u . RTProperty , \"CPropertyRestriction\" ) ;\n break ;\n }\n case RTCoerce_Add : case RTCoerce_Multiply : case RTCoerce_Absolute : {\n v -> u . RTCoerce_Add = EP_ALLOC ( struct CCoercionRestriction ) ;\n offset = parse_CCoercionRestriction ( tvb , offset , tree , pad_tree , v -> u . RTCoerce_Add , \"CCoercionRestriction\" ) ;\n break ;\n }\n case RTContent : {\n v -> u . RTContent = EP_ALLOC ( struct CContentRestriction ) ;\n offset = parse_CContentRestriction ( tvb , offset , tree , pad_tree , v -> u . RTContent , \"CContentRestriction\" ) ;\n break ;\n }\n case RTReuseWhere : {\n v -> u . RTReuseWhere = EP_ALLOC ( struct CReuseWhere ) ;\n offset = parse_CReuseWhere ( tvb , offset , tree , pad_tree , v -> u . RTReuseWhere , \"CReuseWhere\" ) ;\n break ;\n }\n case RTNatLanguage : {\n v -> u . RTNatLanguage = EP_ALLOC ( struct CNatLanguageRestriction ) ;\n offset = parse_CNatLanguageRestriction ( tvb , offset , tree , pad_tree , v -> u . RTNatLanguage , \"CNatLanguageRestriction\" ) ;\n break ;\n }\n default : proto_item_append_text ( item , \" Not supported!\" ) ;\n }\n proto_item_set_end ( item , tvb , offset ) ;\n return offset ;\n }", "idx": 1706}
{"hash": -16551315108292821, "project": "debian", "size": 33, "label": 0, "functionSource": "void gcry_sexp_dump ( const gcry_sexp_t a ) {\n const byte * p ;\n int indent = 0 ;\n int type ;\n if ( ! a ) {\n log_printf ( \"[nil]\\n\" ) ;\n return ;\n }\n p = a -> d ;\n while ( ( type = * p ) != ST_STOP ) {\n p ++ ;\n switch ( type ) {\n case ST_OPEN : log_printf ( \"%*s[open]\\n\" , 2 * indent , \"\" ) ;\n indent ++ ;\n break ;\n case ST_CLOSE : if ( indent ) indent -- ;\n log_printf ( \"%*s[close]\\n\" , 2 * indent , \"\" ) ;\n break ;\n case ST_DATA : {\n DATALEN n ;\n memcpy ( & n , p , sizeof n ) ;\n p += sizeof n ;\n log_printf ( \"%*s[data=\\\"\" , 2 * indent , \"\" ) ;\n dump_string ( p , n , '\\\"' ) ;\n log_printf ( \"\\\"]\\n\" ) ;\n p += n ;\n }\n break ;\n default : log_printf ( \"%*s[unknown tag %d]\\n\" , 2 * indent , \"\" , type ) ;\n break ;\n }\n }\n }", "idx": 1707}
{"hash": 6323824267898511453, "project": "debian", "size": 4, "label": 0, "functionSource": "fz_colorspace * fz_default_rgb ( fz_context * ctx , const fz_default_colorspaces * default_cs ) {\n if ( default_cs ) return default_cs -> rgb ;\n else return fz_device_rgb ( ctx ) ;\n }", "idx": 1708}
{"hash": -1483849844579170895, "project": "chrome", "size": 15, "label": 0, "functionSource": "static void open_output_file ( struct stream_state * stream , struct VpxEncoderConfig * global ) {\n const char * fn = stream -> config . out_fn ;\n const struct vpx_codec_enc_cfg * const cfg = & stream -> config . cfg ;\n if ( cfg -> g_pass == VPX_RC_FIRST_PASS ) return ;\n stream -> file = strcmp ( fn , \"-\" ) ? fopen ( fn , \"wb\" ) : set_binary_mode ( stdout ) ;\n if ( ! stream -> file ) fatal ( \"Failed to open output file\" ) ;\n if ( stream -> config . write_webm && fseek ( stream -> file , 0 , SEEK_CUR ) ) fatal ( \"WebM output to pipes not supported.\" ) ;\n # if CONFIG_WEBM_IO if ( stream -> config . write_webm ) {\n stream -> ebml . stream = stream -> file ;\n write_webm_file_header ( & stream -> ebml , cfg , & global -> framerate , stream -> config . stereo_fmt , global -> codec -> fourcc ) ;\n }\n # endif if ( ! stream -> config . write_webm ) {\n ivf_write_file_header ( stream -> file , cfg , global -> codec -> fourcc , 0 ) ;\n }\n }", "idx": 1709}
{"hash": -7777644912037188223, "project": "debian", "size": 10, "label": 1, "functionSource": "static int decode_udvm_address_operand ( guint8 * buff , guint operand_address , guint16 * value , guint current_address ) {\n guint32 result ;\n guint16 value1 ;\n guint next_opreand_address ;\n next_opreand_address = decode_udvm_multitype_operand ( buff , operand_address , & value1 ) ;\n result = value1 & 0xffff ;\n result = result + current_address ;\n * value = result & 0xffff ;\n return next_opreand_address ;\n }", "idx": 1710}
{"hash": -1768728156572022708, "project": "debian", "size": 3, "label": 0, "functionSource": "static void * jbig2_default_alloc ( Jbig2Allocator * allocator , size_t size ) {\n return malloc ( size ) ;\n }", "idx": 1711}
{"hash": -4555950263653671147, "project": "debian", "size": 5, "label": 0, "functionSource": "PyObject * _PyString_Join ( PyObject * sep , PyObject * x ) {\n assert ( sep != NULL && PyString_Check ( sep ) ) ;\n assert ( x != NULL ) ;\n return string_join ( ( PyStringObject * ) sep , x ) ;\n }", "idx": 1712}
{"hash": 2687336064028423153, "project": "chrome", "size": 10, "label": 0, "functionSource": "static void server_port_free ( struct evdns_server_port * port ) {\n assert ( port ) ;\n assert ( ! port -> refcnt ) ;\n assert ( ! port -> pending_replies ) ;\n if ( port -> socket > 0 ) {\n CLOSE_SOCKET ( port -> socket ) ;\n port -> socket = - 1 ;\n }\n ( void ) event_del ( & port -> event ) ;\n }", "idx": 1713}
{"hash": 6415329349331062723, "project": "chrome", "size": 9, "label": 0, "functionSource": "static void terminate_chunked_cb ( struct evhttp_request * req , void * arg ) {\n struct terminate_state * state = arg ;\n struct timeval tv ;\n state -> req = req ;\n evhttp_send_reply_start ( req , HTTP_OK , \"OK\" ) ;\n tv . tv_sec = 0 ;\n tv . tv_usec = 3000 ;\n event_once ( - 1 , EV_TIMEOUT , terminate_chunked_trickle_cb , arg , & tv ) ;\n }", "idx": 1714}
{"hash": 8672904772426696383, "project": "debian", "size": 156, "label": 0, "functionSource": "static void mpeg4_decode_sprite_trajectory ( MpegEncContext * s , GetBitContext * gb ) {\n int i ;\n int a = 2 << s -> sprite_warping_accuracy ;\n int rho = 3 - s -> sprite_warping_accuracy ;\n int r = 16 / a ;\n const int vop_ref [ 4 ] [ 2 ] = {\n {\n 0 , 0 }\n , {\n s -> width , 0 }\n , {\n 0 , s -> height }\n , {\n s -> width , s -> height }\n }\n ;\n int d [ 4 ] [ 2 ] = {\n {\n 0 , 0 }\n , {\n 0 , 0 }\n , {\n 0 , 0 }\n , {\n 0 , 0 }\n }\n ;\n int sprite_ref [ 4 ] [ 2 ] ;\n int virtual_ref [ 2 ] [ 2 ] ;\n int w2 , h2 , w3 , h3 ;\n int alpha = 0 , beta = 0 ;\n int w = s -> width ;\n int h = s -> height ;\n int min_ab ;\n for ( i = 0 ;\n i < s -> num_sprite_warping_points ;\n i ++ ) {\n int length ;\n int x = 0 , y = 0 ;\n length = get_vlc2 ( gb , sprite_trajectory . table , SPRITE_TRAJ_VLC_BITS , 3 ) ;\n if ( length ) {\n x = get_xbits ( gb , length ) ;\n }\n if ( ! ( s -> divx_version == 500 && s -> divx_build == 413 ) ) skip_bits1 ( gb ) ;\n length = get_vlc2 ( gb , sprite_trajectory . table , SPRITE_TRAJ_VLC_BITS , 3 ) ;\n if ( length ) {\n y = get_xbits ( gb , length ) ;\n }\n skip_bits1 ( gb ) ;\n s -> sprite_traj [ i ] [ 0 ] = d [ i ] [ 0 ] = x ;\n s -> sprite_traj [ i ] [ 1 ] = d [ i ] [ 1 ] = y ;\n }\n for ( ;\n i < 4 ;\n i ++ ) s -> sprite_traj [ i ] [ 0 ] = s -> sprite_traj [ i ] [ 1 ] = 0 ;\n while ( ( 1 << alpha ) < w ) alpha ++ ;\n while ( ( 1 << beta ) < h ) beta ++ ;\n w2 = 1 << alpha ;\n h2 = 1 << beta ;\n if ( s -> divx_version == 500 && s -> divx_build == 413 ) {\n sprite_ref [ 0 ] [ 0 ] = a * vop_ref [ 0 ] [ 0 ] + d [ 0 ] [ 0 ] ;\n sprite_ref [ 0 ] [ 1 ] = a * vop_ref [ 0 ] [ 1 ] + d [ 0 ] [ 1 ] ;\n sprite_ref [ 1 ] [ 0 ] = a * vop_ref [ 1 ] [ 0 ] + d [ 0 ] [ 0 ] + d [ 1 ] [ 0 ] ;\n sprite_ref [ 1 ] [ 1 ] = a * vop_ref [ 1 ] [ 1 ] + d [ 0 ] [ 1 ] + d [ 1 ] [ 1 ] ;\n sprite_ref [ 2 ] [ 0 ] = a * vop_ref [ 2 ] [ 0 ] + d [ 0 ] [ 0 ] + d [ 2 ] [ 0 ] ;\n sprite_ref [ 2 ] [ 1 ] = a * vop_ref [ 2 ] [ 1 ] + d [ 0 ] [ 1 ] + d [ 2 ] [ 1 ] ;\n }\n else {\n sprite_ref [ 0 ] [ 0 ] = ( a >> 1 ) * ( 2 * vop_ref [ 0 ] [ 0 ] + d [ 0 ] [ 0 ] ) ;\n sprite_ref [ 0 ] [ 1 ] = ( a >> 1 ) * ( 2 * vop_ref [ 0 ] [ 1 ] + d [ 0 ] [ 1 ] ) ;\n sprite_ref [ 1 ] [ 0 ] = ( a >> 1 ) * ( 2 * vop_ref [ 1 ] [ 0 ] + d [ 0 ] [ 0 ] + d [ 1 ] [ 0 ] ) ;\n sprite_ref [ 1 ] [ 1 ] = ( a >> 1 ) * ( 2 * vop_ref [ 1 ] [ 1 ] + d [ 0 ] [ 1 ] + d [ 1 ] [ 1 ] ) ;\n sprite_ref [ 2 ] [ 0 ] = ( a >> 1 ) * ( 2 * vop_ref [ 2 ] [ 0 ] + d [ 0 ] [ 0 ] + d [ 2 ] [ 0 ] ) ;\n sprite_ref [ 2 ] [ 1 ] = ( a >> 1 ) * ( 2 * vop_ref [ 2 ] [ 1 ] + d [ 0 ] [ 1 ] + d [ 2 ] [ 1 ] ) ;\n }\n virtual_ref [ 0 ] [ 0 ] = 16 * ( vop_ref [ 0 ] [ 0 ] + w2 ) + ROUNDED_DIV ( ( ( w - w2 ) * ( r * sprite_ref [ 0 ] [ 0 ] - 16 * vop_ref [ 0 ] [ 0 ] ) + w2 * ( r * sprite_ref [ 1 ] [ 0 ] - 16 * vop_ref [ 1 ] [ 0 ] ) ) , w ) ;\n virtual_ref [ 0 ] [ 1 ] = 16 * vop_ref [ 0 ] [ 1 ] + ROUNDED_DIV ( ( ( w - w2 ) * ( r * sprite_ref [ 0 ] [ 1 ] - 16 * vop_ref [ 0 ] [ 1 ] ) + w2 * ( r * sprite_ref [ 1 ] [ 1 ] - 16 * vop_ref [ 1 ] [ 1 ] ) ) , w ) ;\n virtual_ref [ 1 ] [ 0 ] = 16 * vop_ref [ 0 ] [ 0 ] + ROUNDED_DIV ( ( ( h - h2 ) * ( r * sprite_ref [ 0 ] [ 0 ] - 16 * vop_ref [ 0 ] [ 0 ] ) + h2 * ( r * sprite_ref [ 2 ] [ 0 ] - 16 * vop_ref [ 2 ] [ 0 ] ) ) , h ) ;\n virtual_ref [ 1 ] [ 1 ] = 16 * ( vop_ref [ 0 ] [ 1 ] + h2 ) + ROUNDED_DIV ( ( ( h - h2 ) * ( r * sprite_ref [ 0 ] [ 1 ] - 16 * vop_ref [ 0 ] [ 1 ] ) + h2 * ( r * sprite_ref [ 2 ] [ 1 ] - 16 * vop_ref [ 2 ] [ 1 ] ) ) , h ) ;\n switch ( s -> num_sprite_warping_points ) {\n case 0 : s -> sprite_offset [ 0 ] [ 0 ] = 0 ;\n s -> sprite_offset [ 0 ] [ 1 ] = 0 ;\n s -> sprite_offset [ 1 ] [ 0 ] = 0 ;\n s -> sprite_offset [ 1 ] [ 1 ] = 0 ;\n s -> sprite_delta [ 0 ] [ 0 ] = a ;\n s -> sprite_delta [ 0 ] [ 1 ] = 0 ;\n s -> sprite_delta [ 1 ] [ 0 ] = 0 ;\n s -> sprite_delta [ 1 ] [ 1 ] = a ;\n s -> sprite_shift [ 0 ] = 0 ;\n s -> sprite_shift [ 1 ] = 0 ;\n break ;\n case 1 : s -> sprite_offset [ 0 ] [ 0 ] = sprite_ref [ 0 ] [ 0 ] - a * vop_ref [ 0 ] [ 0 ] ;\n s -> sprite_offset [ 0 ] [ 1 ] = sprite_ref [ 0 ] [ 1 ] - a * vop_ref [ 0 ] [ 1 ] ;\n s -> sprite_offset [ 1 ] [ 0 ] = ( ( sprite_ref [ 0 ] [ 0 ] >> 1 ) | ( sprite_ref [ 0 ] [ 0 ] & 1 ) ) - a * ( vop_ref [ 0 ] [ 0 ] / 2 ) ;\n s -> sprite_offset [ 1 ] [ 1 ] = ( ( sprite_ref [ 0 ] [ 1 ] >> 1 ) | ( sprite_ref [ 0 ] [ 1 ] & 1 ) ) - a * ( vop_ref [ 0 ] [ 1 ] / 2 ) ;\n s -> sprite_delta [ 0 ] [ 0 ] = a ;\n s -> sprite_delta [ 0 ] [ 1 ] = 0 ;\n s -> sprite_delta [ 1 ] [ 0 ] = 0 ;\n s -> sprite_delta [ 1 ] [ 1 ] = a ;\n s -> sprite_shift [ 0 ] = 0 ;\n s -> sprite_shift [ 1 ] = 0 ;\n break ;\n case 2 : s -> sprite_offset [ 0 ] [ 0 ] = ( sprite_ref [ 0 ] [ 0 ] << ( alpha + rho ) ) + ( - r * sprite_ref [ 0 ] [ 0 ] + virtual_ref [ 0 ] [ 0 ] ) * ( - vop_ref [ 0 ] [ 0 ] ) + ( r * sprite_ref [ 0 ] [ 1 ] - virtual_ref [ 0 ] [ 1 ] ) * ( - vop_ref [ 0 ] [ 1 ] ) + ( 1 << ( alpha + rho - 1 ) ) ;\n s -> sprite_offset [ 0 ] [ 1 ] = ( sprite_ref [ 0 ] [ 1 ] << ( alpha + rho ) ) + ( - r * sprite_ref [ 0 ] [ 1 ] + virtual_ref [ 0 ] [ 1 ] ) * ( - vop_ref [ 0 ] [ 0 ] ) + ( - r * sprite_ref [ 0 ] [ 0 ] + virtual_ref [ 0 ] [ 0 ] ) * ( - vop_ref [ 0 ] [ 1 ] ) + ( 1 << ( alpha + rho - 1 ) ) ;\n s -> sprite_offset [ 1 ] [ 0 ] = ( ( - r * sprite_ref [ 0 ] [ 0 ] + virtual_ref [ 0 ] [ 0 ] ) * ( - 2 * vop_ref [ 0 ] [ 0 ] + 1 ) + ( r * sprite_ref [ 0 ] [ 1 ] - virtual_ref [ 0 ] [ 1 ] ) * ( - 2 * vop_ref [ 0 ] [ 1 ] + 1 ) + 2 * w2 * r * sprite_ref [ 0 ] [ 0 ] - 16 * w2 + ( 1 << ( alpha + rho + 1 ) ) ) ;\n s -> sprite_offset [ 1 ] [ 1 ] = ( ( - r * sprite_ref [ 0 ] [ 1 ] + virtual_ref [ 0 ] [ 1 ] ) * ( - 2 * vop_ref [ 0 ] [ 0 ] + 1 ) + ( - r * sprite_ref [ 0 ] [ 0 ] + virtual_ref [ 0 ] [ 0 ] ) * ( - 2 * vop_ref [ 0 ] [ 1 ] + 1 ) + 2 * w2 * r * sprite_ref [ 0 ] [ 1 ] - 16 * w2 + ( 1 << ( alpha + rho + 1 ) ) ) ;\n s -> sprite_delta [ 0 ] [ 0 ] = ( - r * sprite_ref [ 0 ] [ 0 ] + virtual_ref [ 0 ] [ 0 ] ) ;\n s -> sprite_delta [ 0 ] [ 1 ] = ( + r * sprite_ref [ 0 ] [ 1 ] - virtual_ref [ 0 ] [ 1 ] ) ;\n s -> sprite_delta [ 1 ] [ 0 ] = ( - r * sprite_ref [ 0 ] [ 1 ] + virtual_ref [ 0 ] [ 1 ] ) ;\n s -> sprite_delta [ 1 ] [ 1 ] = ( - r * sprite_ref [ 0 ] [ 0 ] + virtual_ref [ 0 ] [ 0 ] ) ;\n s -> sprite_shift [ 0 ] = alpha + rho ;\n s -> sprite_shift [ 1 ] = alpha + rho + 2 ;\n break ;\n case 3 : min_ab = FFMIN ( alpha , beta ) ;\n w3 = w2 >> min_ab ;\n h3 = h2 >> min_ab ;\n s -> sprite_offset [ 0 ] [ 0 ] = ( sprite_ref [ 0 ] [ 0 ] << ( alpha + beta + rho - min_ab ) ) + ( - r * sprite_ref [ 0 ] [ 0 ] + virtual_ref [ 0 ] [ 0 ] ) * h3 * ( - vop_ref [ 0 ] [ 0 ] ) + ( - r * sprite_ref [ 0 ] [ 0 ] + virtual_ref [ 1 ] [ 0 ] ) * w3 * ( - vop_ref [ 0 ] [ 1 ] ) + ( 1 << ( alpha + beta + rho - min_ab - 1 ) ) ;\n s -> sprite_offset [ 0 ] [ 1 ] = ( sprite_ref [ 0 ] [ 1 ] << ( alpha + beta + rho - min_ab ) ) + ( - r * sprite_ref [ 0 ] [ 1 ] + virtual_ref [ 0 ] [ 1 ] ) * h3 * ( - vop_ref [ 0 ] [ 0 ] ) + ( - r * sprite_ref [ 0 ] [ 1 ] + virtual_ref [ 1 ] [ 1 ] ) * w3 * ( - vop_ref [ 0 ] [ 1 ] ) + ( 1 << ( alpha + beta + rho - min_ab - 1 ) ) ;\n s -> sprite_offset [ 1 ] [ 0 ] = ( - r * sprite_ref [ 0 ] [ 0 ] + virtual_ref [ 0 ] [ 0 ] ) * h3 * ( - 2 * vop_ref [ 0 ] [ 0 ] + 1 ) + ( - r * sprite_ref [ 0 ] [ 0 ] + virtual_ref [ 1 ] [ 0 ] ) * w3 * ( - 2 * vop_ref [ 0 ] [ 1 ] + 1 ) + 2 * w2 * h3 * r * sprite_ref [ 0 ] [ 0 ] - 16 * w2 * h3 + ( 1 << ( alpha + beta + rho - min_ab + 1 ) ) ;\n s -> sprite_offset [ 1 ] [ 1 ] = ( - r * sprite_ref [ 0 ] [ 1 ] + virtual_ref [ 0 ] [ 1 ] ) * h3 * ( - 2 * vop_ref [ 0 ] [ 0 ] + 1 ) + ( - r * sprite_ref [ 0 ] [ 1 ] + virtual_ref [ 1 ] [ 1 ] ) * w3 * ( - 2 * vop_ref [ 0 ] [ 1 ] + 1 ) + 2 * w2 * h3 * r * sprite_ref [ 0 ] [ 1 ] - 16 * w2 * h3 + ( 1 << ( alpha + beta + rho - min_ab + 1 ) ) ;\n s -> sprite_delta [ 0 ] [ 0 ] = ( - r * sprite_ref [ 0 ] [ 0 ] + virtual_ref [ 0 ] [ 0 ] ) * h3 ;\n s -> sprite_delta [ 0 ] [ 1 ] = ( - r * sprite_ref [ 0 ] [ 0 ] + virtual_ref [ 1 ] [ 0 ] ) * w3 ;\n s -> sprite_delta [ 1 ] [ 0 ] = ( - r * sprite_ref [ 0 ] [ 1 ] + virtual_ref [ 0 ] [ 1 ] ) * h3 ;\n s -> sprite_delta [ 1 ] [ 1 ] = ( - r * sprite_ref [ 0 ] [ 1 ] + virtual_ref [ 1 ] [ 1 ] ) * w3 ;\n s -> sprite_shift [ 0 ] = alpha + beta + rho - min_ab ;\n s -> sprite_shift [ 1 ] = alpha + beta + rho - min_ab + 2 ;\n break ;\n }\n if ( s -> sprite_delta [ 0 ] [ 0 ] == a << s -> sprite_shift [ 0 ] && s -> sprite_delta [ 0 ] [ 1 ] == 0 && s -> sprite_delta [ 1 ] [ 0 ] == 0 && s -> sprite_delta [ 1 ] [ 1 ] == a << s -> sprite_shift [ 0 ] ) {\n s -> sprite_offset [ 0 ] [ 0 ] >>= s -> sprite_shift [ 0 ] ;\n s -> sprite_offset [ 0 ] [ 1 ] >>= s -> sprite_shift [ 0 ] ;\n s -> sprite_offset [ 1 ] [ 0 ] >>= s -> sprite_shift [ 1 ] ;\n s -> sprite_offset [ 1 ] [ 1 ] >>= s -> sprite_shift [ 1 ] ;\n s -> sprite_delta [ 0 ] [ 0 ] = a ;\n s -> sprite_delta [ 0 ] [ 1 ] = 0 ;\n s -> sprite_delta [ 1 ] [ 0 ] = 0 ;\n s -> sprite_delta [ 1 ] [ 1 ] = a ;\n s -> sprite_shift [ 0 ] = 0 ;\n s -> sprite_shift [ 1 ] = 0 ;\n s -> real_sprite_warping_points = 1 ;\n }\n else {\n int shift_y = 16 - s -> sprite_shift [ 0 ] ;\n int shift_c = 16 - s -> sprite_shift [ 1 ] ;\n for ( i = 0 ;\n i < 2 ;\n i ++ ) {\n s -> sprite_offset [ 0 ] [ i ] <<= shift_y ;\n s -> sprite_offset [ 1 ] [ i ] <<= shift_c ;\n s -> sprite_delta [ 0 ] [ i ] <<= shift_y ;\n s -> sprite_delta [ 1 ] [ i ] <<= shift_y ;\n s -> sprite_shift [ i ] = 16 ;\n }\n s -> real_sprite_warping_points = s -> num_sprite_warping_points ;\n }\n }", "idx": 1715}
{"hash": -2222758297961835509, "project": "debian", "size": 24, "label": 0, "functionSource": "static int ivi_create_huff_from_desc ( const IVIHuffDesc * cb , VLC * vlc , int flag ) {\n int pos , i , j , codes_per_row , prefix , not_last_row ;\n uint16_t codewords [ 256 ] ;\n uint8_t bits [ 256 ] ;\n pos = 0 ;\n for ( i = 0 ;\n i < cb -> num_rows ;\n i ++ ) {\n codes_per_row = 1 << cb -> xbits [ i ] ;\n not_last_row = ( i != cb -> num_rows - 1 ) ;\n prefix = ( ( 1 << i ) - 1 ) << ( cb -> xbits [ i ] + not_last_row ) ;\n for ( j = 0 ;\n j < codes_per_row ;\n j ++ ) {\n if ( pos >= 256 ) break ;\n bits [ pos ] = i + cb -> xbits [ i ] + not_last_row ;\n if ( bits [ pos ] > IVI_VLC_BITS ) return - 1 ;\n codewords [ pos ] = inv_bits ( ( prefix | j ) , bits [ pos ] ) ;\n if ( ! bits [ pos ] ) bits [ pos ] = 1 ;\n pos ++ ;\n }\n }\n return init_vlc ( vlc , IVI_VLC_BITS , pos , bits , 1 , 1 , codewords , 2 , 2 , ( flag ? INIT_VLC_USE_NEW_STATIC : 0 ) | INIT_VLC_LE ) ;\n }", "idx": 1716}
{"hash": 2546373479020365143, "project": "debian", "size": 19, "label": 0, "functionSource": "MIMEField * mime_hdr_prepare_for_value_set ( HdrHeap * heap , MIMEHdrImpl * mh , const char * name , int name_length ) {\n int wks_idx ;\n MIMEField * field ;\n field = mime_hdr_field_find ( mh , name , name_length ) ;\n if ( field == nullptr ) {\n wks_idx = hdrtoken_tokenize ( name , name_length ) ;\n field = mime_field_create ( heap , mh ) ;\n mime_field_name_set ( heap , mh , field , wks_idx , name , name_length , true ) ;\n mime_hdr_field_attach ( mh , field , 0 , nullptr ) ;\n }\n else if ( field -> m_next_dup ) {\n wks_idx = field -> m_wks_idx ;\n mime_hdr_field_delete ( heap , mh , field , true ) ;\n field = mime_field_create ( heap , mh ) ;\n mime_field_name_set ( heap , mh , field , wks_idx , name , name_length , true ) ;\n mime_hdr_field_attach ( mh , field , 0 , nullptr ) ;\n }\n return field ;\n }", "idx": 1717}
{"hash": -7014146700012452141, "project": "debian", "size": 58, "label": 1, "functionSource": "static int cdxl_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * pkt ) {\n CDXLVideoContext * c = avctx -> priv_data ;\n AVFrame * const p = & c -> frame ;\n int ret , w , h , encoding , aligned_width , buf_size = pkt -> size ;\n const uint8_t * buf = pkt -> data ;\n if ( buf_size < 32 ) return AVERROR_INVALIDDATA ;\n encoding = buf [ 1 ] & 7 ;\n c -> format = buf [ 1 ] & 0xE0 ;\n w = AV_RB16 ( & buf [ 14 ] ) ;\n h = AV_RB16 ( & buf [ 16 ] ) ;\n c -> bpp = buf [ 19 ] ;\n c -> palette_size = AV_RB16 ( & buf [ 20 ] ) ;\n c -> palette = buf + 32 ;\n c -> video = c -> palette + c -> palette_size ;\n c -> video_size = buf_size - c -> palette_size - 32 ;\n if ( c -> palette_size > 512 ) return AVERROR_INVALIDDATA ;\n if ( buf_size < c -> palette_size + 32 ) return AVERROR_INVALIDDATA ;\n if ( c -> bpp < 1 ) return AVERROR_INVALIDDATA ;\n if ( c -> format != BIT_PLANAR && c -> format != BIT_LINE ) {\n av_log_ask_for_sample ( avctx , \"unsupported pixel format: 0x%0x\\n\" , c -> format ) ;\n return AVERROR_PATCHWELCOME ;\n }\n if ( ( ret = av_image_check_size ( w , h , 0 , avctx ) ) < 0 ) return ret ;\n if ( w != avctx -> width || h != avctx -> height ) avcodec_set_dimensions ( avctx , w , h ) ;\n aligned_width = FFALIGN ( c -> avctx -> width , 16 ) ;\n c -> padded_bits = aligned_width - c -> avctx -> width ;\n if ( c -> video_size < aligned_width * avctx -> height * c -> bpp / 8 ) return AVERROR_INVALIDDATA ;\n if ( ! encoding && c -> palette_size && c -> bpp <= 8 ) {\n avctx -> pix_fmt = AV_PIX_FMT_PAL8 ;\n }\n else if ( encoding == 1 && ( c -> bpp == 6 || c -> bpp == 8 ) ) {\n if ( c -> palette_size != ( 1 << ( c -> bpp - 1 ) ) ) return AVERROR_INVALIDDATA ;\n avctx -> pix_fmt = AV_PIX_FMT_BGR24 ;\n }\n else {\n av_log_ask_for_sample ( avctx , \"unsupported encoding %d and bpp %d\\n\" , encoding , c -> bpp ) ;\n return AVERROR_PATCHWELCOME ;\n }\n if ( p -> data [ 0 ] ) avctx -> release_buffer ( avctx , p ) ;\n p -> reference = 0 ;\n if ( ( ret = ff_get_buffer ( avctx , p ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n p -> pict_type = AV_PICTURE_TYPE_I ;\n if ( encoding ) {\n av_fast_padded_malloc ( & c -> new_video , & c -> new_video_size , h * w + FF_INPUT_BUFFER_PADDING_SIZE ) ;\n if ( ! c -> new_video ) return AVERROR ( ENOMEM ) ;\n if ( c -> bpp == 8 ) cdxl_decode_ham8 ( c ) ;\n else cdxl_decode_ham6 ( c ) ;\n }\n else {\n cdxl_decode_rgb ( c ) ;\n }\n * got_frame = 1 ;\n * ( AVFrame * ) data = c -> frame ;\n return buf_size ;\n }", "idx": 1718}
{"hash": 561876472800374387, "project": "debian", "size": 25, "label": 0, "functionSource": "void RECORD_LAYER_clear ( RECORD_LAYER * rl ) {\n unsigned int pipes ;\n rl -> rstate = SSL_ST_READ_HEADER ;\n rl -> packet = NULL ;\n rl -> packet_length = 0 ;\n rl -> wnum = 0 ;\n memset ( rl -> alert_fragment , 0 , sizeof ( rl -> alert_fragment ) ) ;\n rl -> alert_fragment_len = 0 ;\n memset ( rl -> handshake_fragment , 0 , sizeof ( rl -> handshake_fragment ) ) ;\n rl -> handshake_fragment_len = 0 ;\n rl -> wpend_tot = 0 ;\n rl -> wpend_type = 0 ;\n rl -> wpend_ret = 0 ;\n rl -> wpend_buf = NULL ;\n SSL3_BUFFER_clear ( & rl -> rbuf ) ;\n for ( pipes = 0 ;\n pipes < rl -> numwpipes ;\n pipes ++ ) SSL3_BUFFER_clear ( & rl -> wbuf [ pipes ] ) ;\n rl -> numwpipes = 0 ;\n rl -> numrpipes = 0 ;\n SSL3_RECORD_clear ( rl -> rrec , SSL_MAX_PIPELINES ) ;\n RECORD_LAYER_reset_read_sequence ( rl ) ;\n RECORD_LAYER_reset_write_sequence ( rl ) ;\n if ( rl -> d ) DTLS_RECORD_LAYER_clear ( rl ) ;\n }", "idx": 1719}
{"hash": -3292234626779322843, "project": "chrome", "size": 31, "label": 0, "functionSource": "TEST ( AutocompleteMatchTest , MoreRelevant ) {\n struct RelevantCases {\n int r1 ;\n int r2 ;\n bool expected_result ;\n }\n cases [ ] = {\n {\n 10 , 0 , true }\n , {\n 10 , - 5 , true }\n , {\n - 5 , 10 , false }\n , {\n 0 , 10 , false }\n , {\n - 10 , - 5 , false }\n , {\n - 5 , - 10 , true }\n , }\n ;\n AutocompleteMatch m1 ( NULL , 0 , false , AutocompleteMatchType : : URL_WHAT_YOU_TYPED ) ;\n AutocompleteMatch m2 ( NULL , 0 , false , AutocompleteMatchType : : URL_WHAT_YOU_TYPED ) ;\n for ( size_t i = 0 ;\n i < arraysize ( cases ) ;\n ++ i ) {\n m1 . relevance = cases [ i ] . r1 ;\n m2 . relevance = cases [ i ] . r2 ;\n EXPECT_EQ ( cases [ i ] . expected_result , AutocompleteMatch : : MoreRelevant ( m1 , m2 ) ) ;\n }\n }", "idx": 1720}
{"hash": -1672864273235910388, "project": "debian", "size": 43, "label": 0, "functionSource": "static void _slurm_rpc_resv_create ( slurm_msg_t * msg ) {\n int error_code = SLURM_SUCCESS ;\n DEF_TIMERS ;\n resv_desc_msg_t * resv_desc_ptr = ( resv_desc_msg_t * ) msg -> data ;\n slurmctld_lock_t node_write_lock = {\n READ_LOCK , READ_LOCK , WRITE_LOCK , READ_LOCK , NO_LOCK }\n ;\n uid_t uid = g_slurm_auth_get_uid ( msg -> auth_cred , slurmctld_config . auth_info ) ;\n START_TIMER ;\n debug2 ( \"Processing RPC: REQUEST_CREATE_RESERVATION from uid=%d\" , uid ) ;\n if ( ! validate_operator ( uid ) ) {\n error_code = ESLURM_USER_ID_MISSING ;\n error ( \"Security violation, CREATE_RESERVATION RPC from uid=%d\" , uid ) ;\n }\n if ( error_code == SLURM_SUCCESS ) {\n lock_slurmctld ( node_write_lock ) ;\n error_code = create_resv ( resv_desc_ptr ) ;\n unlock_slurmctld ( node_write_lock ) ;\n END_TIMER2 ( \"_slurm_rpc_resv_create\" ) ;\n }\n if ( error_code ) {\n if ( resv_desc_ptr -> name ) {\n info ( \"_slurm_rpc_resv_create reservation=%s: %s\" , resv_desc_ptr -> name , slurm_strerror ( error_code ) ) ;\n }\n else {\n info ( \"_slurm_rpc_resv_create: %s\" , slurm_strerror ( error_code ) ) ;\n }\n slurm_send_rc_msg ( msg , error_code ) ;\n }\n else {\n slurm_msg_t response_msg ;\n reservation_name_msg_t resv_resp_msg ;\n debug2 ( \"_slurm_rpc_resv_create complete for %s %s\" , resv_desc_ptr -> name , TIME_STR ) ;\n slurm_msg_t_init ( & response_msg ) ;\n response_msg . flags = msg -> flags ;\n response_msg . protocol_version = msg -> protocol_version ;\n resv_resp_msg . name = resv_desc_ptr -> name ;\n response_msg . msg_type = RESPONSE_CREATE_RESERVATION ;\n response_msg . data = & resv_resp_msg ;\n slurm_send_node_msg ( msg -> conn_fd , & response_msg ) ;\n queue_job_scheduler ( ) ;\n }\n }", "idx": 1721}
{"hash": 1760449185745615462, "project": "debian", "size": 6, "label": 0, "functionSource": "const char * TSHttpTxnRedirectUrlGet ( TSHttpTxn txnp , int * url_len_ptr ) {\n sdk_assert ( sdk_sanity_check_txn ( txnp ) == TS_SUCCESS ) ;\n HttpSM * sm = ( HttpSM * ) txnp ;\n * url_len_ptr = sm -> redirect_url_len ;\n return sm -> redirect_url ;\n }", "idx": 1722}
{"hash": 3804373597256531021, "project": "debian", "size": 69, "label": 0, "functionSource": "static int replace_table_table ( THD * thd , GRANT_TABLE * grant_table , TABLE * table , const LEX_USER & combo , const char * db , const char * table_name , ulong rights , ulong col_rights , bool revoke_grant ) {\n char grantor [ USER_HOST_BUFF_SIZE ] ;\n int old_row_exists = 1 ;\n int error = 0 ;\n ulong store_table_rights , store_col_rights ;\n uchar user_key [ MAX_KEY_LENGTH ] ;\n DBUG_ENTER ( \"replace_table_table\" ) ;\n get_grantor ( thd , grantor ) ;\n if ( ! find_acl_user ( combo . host . str , combo . user . str , FALSE ) ) {\n my_message ( ER_PASSWORD_NO_MATCH , ER ( ER_PASSWORD_NO_MATCH ) , MYF ( 0 ) ) ;\n DBUG_RETURN ( - 1 ) ;\n }\n table -> use_all_columns ( ) ;\n restore_record ( table , s -> default_values ) ;\n table -> field [ 0 ] -> store ( combo . host . str , combo . host . length , system_charset_info ) ;\n table -> field [ 1 ] -> store ( db , ( uint ) strlen ( db ) , system_charset_info ) ;\n table -> field [ 2 ] -> store ( combo . user . str , combo . user . length , system_charset_info ) ;\n table -> field [ 3 ] -> store ( table_name , ( uint ) strlen ( table_name ) , system_charset_info ) ;\n store_record ( table , record [ 1 ] ) ;\n key_copy ( user_key , table -> record [ 0 ] , table -> key_info , table -> key_info -> key_length ) ;\n if ( table -> file -> index_read_idx_map ( table -> record [ 0 ] , 0 , user_key , HA_WHOLE_KEY , HA_READ_KEY_EXACT ) ) {\n if ( revoke_grant ) {\n my_error ( ER_NONEXISTING_TABLE_GRANT , MYF ( 0 ) , combo . user . str , combo . host . str , table_name ) ;\n DBUG_RETURN ( - 1 ) ;\n }\n old_row_exists = 0 ;\n restore_record ( table , record [ 1 ] ) ;\n }\n store_table_rights = get_rights_for_table ( rights ) ;\n store_col_rights = get_rights_for_column ( col_rights ) ;\n if ( old_row_exists ) {\n ulong j , k ;\n store_record ( table , record [ 1 ] ) ;\n j = ( ulong ) table -> field [ 6 ] -> val_int ( ) ;\n k = ( ulong ) table -> field [ 7 ] -> val_int ( ) ;\n if ( revoke_grant ) {\n store_table_rights = j & ~ store_table_rights ;\n }\n else {\n store_table_rights |= j ;\n store_col_rights |= k ;\n }\n }\n table -> field [ 4 ] -> store ( grantor , ( uint ) strlen ( grantor ) , system_charset_info ) ;\n table -> field [ 6 ] -> store ( ( longlong ) store_table_rights , TRUE ) ;\n table -> field [ 7 ] -> store ( ( longlong ) store_col_rights , TRUE ) ;\n rights = fix_rights_for_table ( store_table_rights ) ;\n col_rights = fix_rights_for_column ( store_col_rights ) ;\n if ( old_row_exists ) {\n if ( store_table_rights || store_col_rights ) {\n if ( ( error = table -> file -> ha_update_row ( table -> record [ 1 ] , table -> record [ 0 ] ) ) && error != HA_ERR_RECORD_IS_THE_SAME ) goto table_error ;\n }\n else if ( ( error = table -> file -> ha_delete_row ( table -> record [ 1 ] ) ) ) goto table_error ;\n }\n else {\n error = table -> file -> ha_write_row ( table -> record [ 0 ] ) ;\n if ( table -> file -> is_fatal_error ( error , HA_CHECK_DUP_KEY ) ) goto table_error ;\n }\n if ( rights | col_rights ) {\n grant_table -> privs = rights ;\n grant_table -> cols = col_rights ;\n }\n else {\n hash_delete ( & column_priv_hash , ( uchar * ) grant_table ) ;\n }\n DBUG_RETURN ( 0 ) ;\n table_error : table -> file -> print_error ( error , MYF ( 0 ) ) ;\n DBUG_RETURN ( - 1 ) ;\n }", "idx": 1723}
{"hash": -4078760840682683657, "project": "chrome", "size": 5, "label": 0, "functionSource": "static TX_SIZE read_tx_size ( VP9_COMMON * cm , MACROBLOCKD * xd , TX_MODE tx_mode , BLOCK_SIZE bsize , int allow_select , vp9_reader * r ) {\n const TX_SIZE max_tx_size = max_txsize_lookup [ bsize ] ;\n if ( allow_select && tx_mode == TX_MODE_SELECT && bsize >= BLOCK_8X8 ) return read_selected_tx_size ( cm , xd , max_tx_size , r ) ;\n else return MIN ( max_tx_size , tx_mode_to_biggest_tx_size [ tx_mode ] ) ;\n }", "idx": 1724}
{"hash": -7236893719053583356, "project": "debian", "size": 3, "label": 0, "functionSource": "static int dissect_zbee_zcl_ballast_configuration ( tvbuff_t * tvb _U_ , packet_info * pinfo _U_ , proto_tree * tree _U_ , void * data _U_ ) {\n return tvb_captured_length ( tvb ) ;\n }", "idx": 1725}
{"hash": 7039307292471244756, "project": "debian", "size": 28, "label": 0, "functionSource": "static void dtap_mm_cm_reestab_req ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len ) {\n guint32 curr_offset ;\n guint32 consumed ;\n guint curr_len ;\n guint8 oct ;\n proto_tree * subtree ;\n curr_offset = offset ;\n curr_len = len ;\n is_uplink = IS_UPLINK_TRUE ;\n oct = tvb_get_guint8 ( tvb , curr_offset ) ;\n proto_tree_add_bits_item ( tree , hf_gsm_a_spare_bits , tvb , curr_offset << 3 , 4 , ENC_BIG_ENDIAN ) ;\n subtree = proto_tree_add_subtree ( tree , tvb , curr_offset , 1 , ett_gsm_common_elem [ DE_CIPH_KEY_SEQ_NUM ] , NULL , val_to_str_ext_const ( DE_CIPH_KEY_SEQ_NUM , & gsm_common_elem_strings_ext , \"\" ) ) ;\n proto_tree_add_bits_item ( subtree , hf_gsm_a_spare_bits , tvb , ( curr_offset << 3 ) + 4 , 1 , ENC_BIG_ENDIAN ) ;\n switch ( oct & 0x07 ) {\n case 0x07 : proto_tree_add_uint_format_value ( subtree , hf_gsm_a_dtap_ciphering_key_sequence_number , tvb , curr_offset , 1 , oct , \"No key is available\" ) ;\n break ;\n default : proto_tree_add_item ( subtree , hf_gsm_a_dtap_ciphering_key_sequence_number , tvb , curr_offset , 1 , ENC_BIG_ENDIAN ) ;\n break ;\n }\n curr_offset ++ ;\n curr_len -- ;\n if ( ( signed ) curr_len <= 0 ) return ;\n ELEM_MAND_LV ( GSM_A_PDU_TYPE_COMMON , DE_MS_CM_2 , NULL ) ;\n ELEM_MAND_LV ( GSM_A_PDU_TYPE_COMMON , DE_MID , NULL ) ;\n ELEM_OPT_TV ( 0x13 , GSM_A_PDU_TYPE_COMMON , DE_LAI , NULL ) ;\n ELEM_OPT_TV_SHORT ( 0xD0 , GSM_A_PDU_TYPE_GM , DE_DEVICE_PROPERTIES , NULL ) ;\n EXTRANEOUS_DATA_CHECK ( curr_len , 0 , pinfo , & ei_gsm_a_dtap_extraneous_data ) ;\n }", "idx": 1726}
{"hash": -5268859819325807498, "project": "debian", "size": 9, "label": 0, "functionSource": "static void file_info_cancel ( NautilusDirectory * directory ) {\n if ( directory -> details -> get_info_in_progress != NULL ) {\n g_cancellable_cancel ( directory -> details -> get_info_in_progress -> cancellable ) ;\n directory -> details -> get_info_in_progress -> directory = NULL ;\n directory -> details -> get_info_in_progress = NULL ;\n directory -> details -> get_info_file = NULL ;\n async_job_end ( directory , \"file info\" ) ;\n }\n }", "idx": 1727}
{"hash": -6580451576689962916, "project": "debian", "size": 12, "label": 0, "functionSource": "static char * sic10_opaque_literal_attr ( tvbuff_t * tvb , guint32 offset , const char * token , guint8 codepage _U_ , guint32 * length ) {\n guint32 data_len = tvb_get_guintvar ( tvb , offset , length ) ;\n char * str = NULL ;\n if ( token && ( ( strcmp ( token , \"created\" ) == 0 ) || ( strcmp ( token , \"si-expires\" ) == 0 ) ) ) {\n str = date_time_from_opaque ( tvb , offset + * length , data_len ) ;\n }\n if ( str == NULL ) {\n str = wmem_strdup_printf ( wmem_packet_scope ( ) , \"(%d bytes of unparsed opaque data)\" , data_len ) ;\n }\n * length += data_len ;\n return str ;\n }", "idx": 1728}
{"hash": 2546373479020365143, "project": "debian", "size": 39, "label": 0, "functionSource": "void mime_hdr_field_detach ( MIMEHdrImpl * mh , MIMEField * field , bool detach_all_dups ) {\n MIMEField * next_dup = field -> m_next_dup ;\n if ( field -> is_detached ( ) ) {\n ink_assert ( next_dup == nullptr ) ;\n return ;\n }\n ink_assert ( field -> is_live ( ) ) ;\n MIME_HDR_SANITY_CHECK ( mh ) ;\n if ( field -> m_flags & MIME_FIELD_SLOT_FLAGS_DUP_HEAD ) {\n if ( ! next_dup ) {\n mime_hdr_unset_accelerators_and_presence_bits ( mh , field ) ;\n }\n else {\n next_dup -> m_flags |= MIME_FIELD_SLOT_FLAGS_DUP_HEAD ;\n mime_hdr_set_accelerators_and_presence_bits ( mh , next_dup ) ;\n }\n }\n else {\n int name_length ;\n const char * name = mime_field_name_get ( field , & name_length ) ;\n MIMEField * prev = mime_hdr_field_find ( mh , name , name_length ) ;\n while ( prev && ( prev -> m_next_dup != field ) ) {\n prev = prev -> m_next_dup ;\n }\n ink_assert ( prev != nullptr ) ;\n if ( prev -> m_next_dup == field ) {\n prev -> m_next_dup = next_dup ;\n }\n }\n field -> m_readiness = MIME_FIELD_SLOT_READINESS_DETACHED ;\n field -> m_next_dup = nullptr ;\n if ( field -> is_cooked ( ) ) {\n mh -> recompute_cooked_stuff ( field ) ;\n }\n MIME_HDR_SANITY_CHECK ( mh ) ;\n if ( detach_all_dups && next_dup ) {\n mime_hdr_field_detach ( mh , next_dup , detach_all_dups ) ;\n }\n }", "idx": 1729}
{"hash": 5498422609764865307, "project": "debian", "size": 12, "label": 1, "functionSource": "static int compress_bidder_bid ( struct archive_read_filter_bidder * self , struct archive_read_filter * filter ) {\n const unsigned char * buffer ;\n ssize_t avail ;\n int bits_checked ;\n ( void ) self ;\n buffer = __archive_read_filter_ahead ( filter , 2 , & avail ) ;\n if ( buffer == NULL ) return ( 0 ) ;\n bits_checked = 0 ;\n if ( buffer [ 0 ] != 0x1F || buffer [ 1 ] != 0x9D ) return ( 0 ) ;\n bits_checked += 16 ;\n return ( bits_checked ) ;\n }", "idx": 1730}
{"hash": 6667142528452941476, "project": "debian", "size": 4, "label": 1, "functionSource": "static void short_usage ( FILE * f ) {\n short_usage_sub ( f ) ;\n fprintf ( f , \"For more options, use %s --help\\n\" , my_progname_short ) ;\n }", "idx": 1731}
{"hash": -1594970847928262768, "project": "debian", "size": 61, "label": 1, "functionSource": "static int decode_slice ( AVCodecContext * avctx , void * tdata ) {\n ProresThreadData * td = tdata ;\n ProresContext * ctx = avctx -> priv_data ;\n int mb_x_pos = td -> x_pos ;\n int mb_y_pos = td -> y_pos ;\n int pic_num = ctx -> pic_num ;\n int slice_num = td -> slice_num ;\n int mbs_per_slice = td -> slice_width ;\n const uint8_t * buf ;\n uint8_t * y_data , * u_data , * v_data ;\n AVFrame * pic = avctx -> coded_frame ;\n int i , sf , slice_width_factor ;\n int slice_data_size , hdr_size , y_data_size , u_data_size , v_data_size ;\n int y_linesize , u_linesize , v_linesize ;\n buf = ctx -> slice_data [ slice_num ] . index ;\n slice_data_size = ctx -> slice_data [ slice_num + 1 ] . index - buf ;\n slice_width_factor = av_log2 ( mbs_per_slice ) ;\n y_data = pic -> data [ 0 ] ;\n u_data = pic -> data [ 1 ] ;\n v_data = pic -> data [ 2 ] ;\n y_linesize = pic -> linesize [ 0 ] ;\n u_linesize = pic -> linesize [ 1 ] ;\n v_linesize = pic -> linesize [ 2 ] ;\n if ( pic -> interlaced_frame ) {\n if ( ! ( pic_num ^ pic -> top_field_first ) ) {\n y_data += y_linesize ;\n u_data += u_linesize ;\n v_data += v_linesize ;\n }\n y_linesize <<= 1 ;\n u_linesize <<= 1 ;\n v_linesize <<= 1 ;\n }\n if ( slice_data_size < 6 ) {\n av_log ( avctx , AV_LOG_ERROR , \"slice data too small\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n hdr_size = buf [ 0 ] >> 3 ;\n y_data_size = AV_RB16 ( buf + 2 ) ;\n u_data_size = AV_RB16 ( buf + 4 ) ;\n v_data_size = hdr_size > 7 ? AV_RB16 ( buf + 6 ) : slice_data_size - y_data_size - u_data_size - hdr_size ;\n if ( hdr_size + y_data_size + u_data_size + v_data_size > slice_data_size || v_data_size < 0 || hdr_size < 6 ) {\n av_log ( avctx , AV_LOG_ERROR , \"invalid data size\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n sf = av_clip ( buf [ 1 ] , 1 , 224 ) ;\n sf = sf > 128 ? ( sf - 96 ) << 2 : sf ;\n if ( ctx -> qmat_changed || sf != td -> prev_slice_sf ) {\n td -> prev_slice_sf = sf ;\n for ( i = 0 ;\n i < 64 ;\n i ++ ) {\n td -> qmat_luma_scaled [ ctx -> dsp . idct_permutation [ i ] ] = ctx -> qmat_luma [ i ] * sf ;\n td -> qmat_chroma_scaled [ ctx -> dsp . idct_permutation [ i ] ] = ctx -> qmat_chroma [ i ] * sf ;\n }\n }\n decode_slice_plane ( ctx , td , buf + hdr_size , y_data_size , ( uint16_t * ) ( y_data + ( mb_y_pos << 4 ) * y_linesize + ( mb_x_pos << 5 ) ) , y_linesize , mbs_per_slice , 4 , slice_width_factor + 2 , td -> qmat_luma_scaled , 0 ) ;\n decode_slice_plane ( ctx , td , buf + hdr_size + y_data_size , u_data_size , ( uint16_t * ) ( u_data + ( mb_y_pos << 4 ) * u_linesize + ( mb_x_pos << ctx -> mb_chroma_factor ) ) , u_linesize , mbs_per_slice , ctx -> num_chroma_blocks , slice_width_factor + ctx -> chroma_factor - 1 , td -> qmat_chroma_scaled , 1 ) ;\n decode_slice_plane ( ctx , td , buf + hdr_size + y_data_size + u_data_size , v_data_size , ( uint16_t * ) ( v_data + ( mb_y_pos << 4 ) * v_linesize + ( mb_x_pos << ctx -> mb_chroma_factor ) ) , v_linesize , mbs_per_slice , ctx -> num_chroma_blocks , slice_width_factor + ctx -> chroma_factor - 1 , td -> qmat_chroma_scaled , 1 ) ;\n return 0 ;\n }", "idx": 1732}
{"hash": 2335222688263906532, "project": "debian", "size": 4, "label": 0, "functionSource": "static int calc_add_mv ( RV34DecContext * r , int dir , int val ) {\n int mul = dir ? - r -> mv_weight2 : r -> mv_weight1 ;\n return ( val * mul + 0x2000 ) >> 14 ;\n }", "idx": 1733}
{"hash": 8320716512483418415, "project": "chrome", "size": 16, "label": 1, "functionSource": "void vp9_idct4x4_1_add_c ( const int16_t * input , uint8_t * dest , int dest_stride ) {\n int i ;\n int a1 ;\n int16_t out = dct_const_round_shift ( input [ 0 ] * cospi_16_64 ) ;\n out = dct_const_round_shift ( out * cospi_16_64 ) ;\n a1 = ROUND_POWER_OF_TWO ( out , 4 ) ;\n for ( i = 0 ;\n i < 4 ;\n i ++ ) {\n dest [ 0 ] = clip_pixel ( dest [ 0 ] + a1 ) ;\n dest [ 1 ] = clip_pixel ( dest [ 1 ] + a1 ) ;\n dest [ 2 ] = clip_pixel ( dest [ 2 ] + a1 ) ;\n dest [ 3 ] = clip_pixel ( dest [ 3 ] + a1 ) ;\n dest += dest_stride ;\n }\n }", "idx": 1734}
{"hash": 378220832151730865, "project": "debian", "size": 28, "label": 0, "functionSource": "int qemuMonitorTextDelDevice ( qemuMonitorPtr mon , const char * devalias ) {\n char * cmd = NULL ;\n char * reply = NULL ;\n char * safedev ;\n int ret = - 1 ;\n if ( ! ( safedev = qemuMonitorEscapeArg ( devalias ) ) ) {\n virReportOOMError ( ) ;\n goto cleanup ;\n }\n if ( virAsprintf ( & cmd , \"device_del %s\" , safedev ) < 0 ) {\n virReportOOMError ( ) ;\n goto cleanup ;\n }\n VIR_DEBUG ( \"TextDelDevice devalias=%s\" , devalias ) ;\n if ( qemuMonitorHMPCommand ( mon , cmd , & reply ) < 0 ) {\n qemuReportError ( VIR_ERR_OPERATION_FAILED , _ ( \"cannot detach %s device\" ) , devalias ) ;\n goto cleanup ;\n }\n if ( STRNEQ ( reply , \"\" ) ) {\n qemuReportError ( VIR_ERR_OPERATION_FAILED , _ ( \"detaching %s device failed: %s\" ) , devalias , reply ) ;\n goto cleanup ;\n }\n ret = 0 ;\n cleanup : VIR_FREE ( cmd ) ;\n VIR_FREE ( reply ) ;\n VIR_FREE ( safedev ) ;\n return ret ;\n }", "idx": 1735}
{"hash": 1182028467273264883, "project": "debian", "size": 9, "label": 0, "functionSource": "void var_copy ( VAR * dest , VAR * src ) {\n dest -> int_val = src -> int_val ;\n dest -> is_int = src -> is_int ;\n dest -> int_dirty = src -> int_dirty ;\n if ( dest -> alloced_len < src -> alloced_len && ! ( dest -> str_val = dest -> str_val ? ( char * ) my_realloc ( dest -> str_val , src -> alloced_len , MYF ( MY_WME ) ) : ( char * ) my_malloc ( src -> alloced_len , MYF ( MY_WME ) ) ) ) die ( \"Out of memory\" ) ;\n else dest -> alloced_len = src -> alloced_len ;\n dest -> str_val_len = src -> str_val_len ;\n if ( src -> str_val_len ) memcpy ( dest -> str_val , src -> str_val , src -> str_val_len ) ;\n }", "idx": 1736}
{"hash": 1223258652239369123, "project": "debian", "size": 6, "label": 0, "functionSource": "SPL_METHOD ( SplFileObject , setFlags ) {\n spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , \"l\" , & intern -> flags ) == FAILURE ) {\n return ;\n }\n }", "idx": 1737}
{"hash": 8672904772426696383, "project": "debian", "size": 68, "label": 0, "functionSource": "int ff_mpeg4_decode_video_packet_header ( MpegEncContext * s ) {\n int mb_num_bits = av_log2 ( s -> mb_num - 1 ) + 1 ;\n int header_extension = 0 , mb_num , len ;\n if ( get_bits_count ( & s -> gb ) > s -> gb . size_in_bits - 20 ) return - 1 ;\n for ( len = 0 ;\n len < 32 ;\n len ++ ) {\n if ( get_bits1 ( & s -> gb ) ) break ;\n }\n if ( len != ff_mpeg4_get_video_packet_prefix_length ( s ) ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"marker does not match f_code\\n\" ) ;\n return - 1 ;\n }\n if ( s -> shape != RECT_SHAPE ) {\n header_extension = get_bits1 ( & s -> gb ) ;\n }\n mb_num = get_bits ( & s -> gb , mb_num_bits ) ;\n if ( mb_num >= s -> mb_num ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"illegal mb_num in video packet (%d %d) \\n\" , mb_num , s -> mb_num ) ;\n return - 1 ;\n }\n if ( s -> pict_type == AV_PICTURE_TYPE_B ) {\n int mb_x = 0 , mb_y = 0 ;\n while ( s -> next_picture . mbskip_table [ s -> mb_index2xy [ mb_num ] ] ) {\n if ( ! mb_x ) ff_thread_await_progress ( & s -> next_picture_ptr -> tf , mb_y ++ , 0 ) ;\n mb_num ++ ;\n if ( ++ mb_x == s -> mb_width ) mb_x = 0 ;\n }\n if ( mb_num >= s -> mb_num ) return - 1 ;\n }\n s -> mb_x = mb_num % s -> mb_width ;\n s -> mb_y = mb_num / s -> mb_width ;\n if ( s -> shape != BIN_ONLY_SHAPE ) {\n int qscale = get_bits ( & s -> gb , s -> quant_precision ) ;\n if ( qscale ) s -> chroma_qscale = s -> qscale = qscale ;\n }\n if ( s -> shape == RECT_SHAPE ) {\n header_extension = get_bits1 ( & s -> gb ) ;\n }\n if ( header_extension ) {\n int time_incr = 0 ;\n while ( get_bits1 ( & s -> gb ) != 0 ) time_incr ++ ;\n check_marker ( & s -> gb , \"before time_increment in video packed header\" ) ;\n skip_bits ( & s -> gb , s -> time_increment_bits ) ;\n check_marker ( & s -> gb , \"before vop_coding_type in video packed header\" ) ;\n skip_bits ( & s -> gb , 2 ) ;\n if ( s -> shape != BIN_ONLY_SHAPE ) {\n skip_bits ( & s -> gb , 3 ) ;\n if ( s -> pict_type == AV_PICTURE_TYPE_S && s -> vol_sprite_usage == GMC_SPRITE ) {\n mpeg4_decode_sprite_trajectory ( s , & s -> gb ) ;\n av_log ( s -> avctx , AV_LOG_ERROR , \"untested\\n\" ) ;\n }\n if ( s -> pict_type != AV_PICTURE_TYPE_I ) {\n int f_code = get_bits ( & s -> gb , 3 ) ;\n if ( f_code == 0 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"Error, video packet header damaged (f_code=0)\\n\" ) ;\n }\n }\n if ( s -> pict_type == AV_PICTURE_TYPE_B ) {\n int b_code = get_bits ( & s -> gb , 3 ) ;\n if ( b_code == 0 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"Error, video packet header damaged (b_code=0)\\n\" ) ;\n }\n }\n }\n }\n return 0 ;\n }", "idx": 1738}
{"hash": 2713698759296604855, "project": "debian", "size": 6, "label": 0, "functionSource": "void ff_MPV_decode_mb ( MpegEncContext * s , int16_t block [ 12 ] [ 64 ] ) {\n # if ! CONFIG_SMALL if ( s -> out_format == FMT_MPEG1 ) {\n MPV_decode_mb_internal ( s , block , 1 ) ;\n }\n else # endif MPV_decode_mb_internal ( s , block , 0 ) ;\n }", "idx": 1739}
{"hash": 5917118798851365454, "project": "debian", "size": 8, "label": 0, "functionSource": "static void dissect_zcl_appl_evtalt_alerts_struct ( tvbuff_t * tvb , proto_tree * tree , guint * offset ) {\n proto_tree_add_item ( tree , hf_zbee_zcl_appl_evtalt_alert_id , tvb , * offset , 3 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( tree , hf_zbee_zcl_appl_evtalt_category , tvb , * offset , 3 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( tree , hf_zbee_zcl_appl_evtalt_status , tvb , * offset , 3 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( tree , hf_zbee_zcl_appl_evtalt_reserved , tvb , * offset , 3 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( tree , hf_zbee_zcl_appl_evtalt_proprietary , tvb , * offset , 3 , ENC_BIG_ENDIAN ) ;\n * offset += 3 ;\n }", "idx": 1740}
{"hash": 2626033973808493247, "project": "chrome", "size": 10, "label": 0, "functionSource": "static struct qcms_modular_transform * reverse_transform ( struct qcms_modular_transform * transform ) {\n struct qcms_modular_transform * prev_transform = NULL ;\n while ( transform != NULL ) {\n struct qcms_modular_transform * next_transform = transform -> next_transform ;\n transform -> next_transform = prev_transform ;\n prev_transform = transform ;\n transform = next_transform ;\n }\n return prev_transform ;\n }", "idx": 1741}
{"hash": -5220436875389458065, "project": "debian", "size": 5, "label": 0, "functionSource": "static void adx_decode_flush ( AVCodecContext * avctx ) {\n ADXContext * c = avctx -> priv_data ;\n memset ( c -> prev , 0 , sizeof ( c -> prev ) ) ;\n c -> eof = 0 ;\n }", "idx": 1742}
{"hash": 8073241806104522127, "project": "chrome", "size": 33, "label": 1, "functionSource": "TEST_F ( AutocompleteResultTest , SortAndCullEmptyDestinationURLs ) {\n TestData data [ ] = {\n {\n 1 , 1 , 500 , true }\n , {\n 0 , 1 , 1100 , true }\n , {\n 1 , 1 , 1000 , true }\n , {\n 0 , 1 , 1300 , true }\n , {\n 0 , 1 , 1200 , true }\n , }\n ;\n ACMatches matches ;\n PopulateAutocompleteMatches ( data , arraysize ( data ) , & matches ) ;\n matches [ 1 ] . destination_url = GURL ( ) ;\n matches [ 3 ] . destination_url = GURL ( ) ;\n matches [ 4 ] . destination_url = GURL ( ) ;\n AutocompleteInput input ( base : : string16 ( ) , base : : string16 : : npos , std : : string ( ) , GURL ( ) , OmniboxEventProto : : INVALID_SPEC , false , false , false , true , false , TestSchemeClassifier ( ) ) ;\n AutocompleteResult result ;\n result . AppendMatches ( input , matches ) ;\n result . SortAndCull ( input , std : : string ( ) , template_url_service_ . get ( ) ) ;\n ASSERT_EQ ( 4U , result . size ( ) ) ;\n EXPECT_TRUE ( result . match_at ( 0 ) -> destination_url . is_empty ( ) ) ;\n EXPECT_EQ ( 1300 , result . match_at ( 0 ) -> relevance ) ;\n EXPECT_TRUE ( result . match_at ( 1 ) -> destination_url . is_empty ( ) ) ;\n EXPECT_EQ ( 1200 , result . match_at ( 1 ) -> relevance ) ;\n EXPECT_TRUE ( result . match_at ( 2 ) -> destination_url . is_empty ( ) ) ;\n EXPECT_EQ ( 1100 , result . match_at ( 2 ) -> relevance ) ;\n EXPECT_EQ ( \"http://b/\" , result . match_at ( 3 ) -> destination_url . spec ( ) ) ;\n EXPECT_EQ ( 1000 , result . match_at ( 3 ) -> relevance ) ;\n }", "idx": 1743}
{"hash": -1409799581796815039, "project": "debian", "size": 20, "label": 0, "functionSource": "static inline int handle_cpu_signal ( uintptr_t pc , unsigned long address , int is_write , sigset_t * old_set , void * puc ) {\n CPUArchState * env ;\n int ret ;\n # if defined ( DEBUG_SIGNAL ) qemu_printf ( \"qemu: SIGSEGV pc=0x%08lx address=%08lx w=%d oldset=0x%08lx\\n\" , pc , address , is_write , * ( unsigned long * ) old_set ) ;\n # endif if ( is_write && h2g_valid ( address ) && page_unprotect ( h2g ( address ) , pc , puc ) ) {\n return 1 ;\n }\n env = current_cpu -> env_ptr ;\n ret = cpu_handle_mmu_fault ( env , address , is_write , MMU_USER_IDX ) ;\n if ( ret < 0 ) {\n return 0 ;\n }\n if ( ret == 0 ) {\n return 1 ;\n }\n cpu_restore_state ( env , pc ) ;\n sigprocmask ( SIG_SETMASK , old_set , NULL ) ;\n exception_action ( env ) ;\n return 1 ;\n }", "idx": 1744}
{"hash": 9155638497612715289, "project": "debian", "size": 3, "label": 0, "functionSource": "static int typhoon_pcihost_init ( SysBusDevice * dev ) {\n return 0 ;\n }", "idx": 1745}
{"hash": -5780611388839125875, "project": "chrome", "size": 8, "label": 0, "functionSource": "int xmlThrDefDoValidityCheckingDefaultValue ( int v ) {\n int ret ;\n xmlMutexLock ( xmlThrDefMutex ) ;\n ret = xmlDoValidityCheckingDefaultValueThrDef ;\n xmlDoValidityCheckingDefaultValueThrDef = v ;\n xmlMutexUnlock ( xmlThrDefMutex ) ;\n return ret ;\n }", "idx": 1746}
{"hash": -6580451576689962916, "project": "debian", "size": 106, "label": 1, "functionSource": "static guint32 parse_wbxml_attribute_list_defined ( proto_tree * tree , tvbuff_t * tvb , guint32 offset , guint32 str_tbl , guint8 level , guint8 * codepage_attr , const wbxml_decoding * map ) {\n guint32 tvb_len = tvb_reported_length ( tvb ) ;\n guint32 off = offset ;\n guint32 len ;\n guint str_len ;\n guint32 ent ;\n guint32 idx ;\n guint8 peek ;\n guint8 attr_save_known = 0 ;\n const char * attr_save_literal = NULL ;\n DebugLog ( ( \"parse_wbxml_attr_defined (level = %u, offset = %u)\\n\" , level , offset ) ) ;\n while ( off < tvb_len ) {\n peek = tvb_get_guint8 ( tvb , off ) ;\n DebugLog ( ( \"ATTR: (top of while) level = %3u, peek = 0x%02X, \" \"off = %u, tvb_len = %u\\n\" , level , peek , off , tvb_len ) ) ;\n if ( ( peek & 0x3F ) < 5 ) switch ( peek ) {\n case 0x00 : * codepage_attr = tvb_get_guint8 ( tvb , off + 1 ) ;\n proto_tree_add_text ( tree , tvb , off , 2 , \" | Attr | A -->%3d \" \"| SWITCH_PAGE (Attr code page) |\" , * codepage_attr ) ;\n off += 2 ;\n break ;\n case 0x01 : off ++ ;\n DebugLog ( ( \"ATTR: level = %u, Return: len = %u\\n\" , level , off - offset ) ) ;\n return ( off - offset ) ;\n case 0x02 : ent = tvb_get_guintvar ( tvb , off + 1 , & len ) ;\n proto_tree_add_text ( tree , tvb , off , 1 + len , \" %3d | Attr | A %3d \" \"| ENTITY \" \"| %s'&#%u;\n'\" , level , * codepage_attr , Indent ( level ) , ent ) ;\n off += 1 + len ;\n break ;\n case 0x03 : len = tvb_strsize ( tvb , off + 1 ) ;\n proto_tree_add_text ( tree , tvb , off , 1 + len , \" %3d | Attr | A %3d \" \"| STR_I (Inline string) \" \"| %s\\'%s\\'\" , level , * codepage_attr , Indent ( level ) , tvb_format_text ( tvb , off + 1 , len - 1 ) ) ;\n off += 1 + len ;\n break ;\n case 0x04 : idx = tvb_get_guintvar ( tvb , off + 1 , & len ) ;\n str_len = tvb_strsize ( tvb , str_tbl + idx ) ;\n attr_save_known = 0 ;\n attr_save_literal = tvb_format_text ( tvb , str_tbl + idx , str_len - 1 ) ;\n proto_tree_add_text ( tree , tvb , off , 1 + len , \" %3d | Attr | A %3d \" \"| LITERAL (Literal Attribute) \" \"| %s<%s />\" , level , * codepage_attr , Indent ( level ) , attr_save_literal ) ;\n off += 1 + len ;\n break ;\n case 0x40 : case 0x41 : case 0x42 : len = tvb_strsize ( tvb , off + 1 ) ;\n proto_tree_add_text ( tree , tvb , off , 1 + len , \" %3d | Attr | A %3d \" \"| EXT_I_%1x (Extension Token) \" \"| %s(%s: \\'%s\\')\" , level , * codepage_attr , peek & 0x0f , Indent ( level ) , map_token ( map -> global , 0 , peek ) , tvb_format_text ( tvb , off + 1 , len - 1 ) ) ;\n off += 1 + len ;\n break ;\n case 0x80 : case 0x81 : case 0x82 : idx = tvb_get_guintvar ( tvb , off + 1 , & len ) ;\n {\n char * s ;\n if ( map -> ext_t [ peek & 0x03 ] ) s = ( map -> ext_t [ peek & 0x03 ] ) ( tvb , idx , str_tbl ) ;\n else s = wmem_strdup_printf ( wmem_packet_scope ( ) , \"EXT_T_%1x (%s)\" , peek & 0x03 , map_token ( map -> global , 0 , peek ) ) ;\n proto_tree_add_text ( tree , tvb , off , 1 + len , \" %3d | Tag | T %3d \" \"| EXT_T_%1x (Extension Token) \" \"| %s%s)\" , level , * codepage_attr , peek & 0x0f , Indent ( level ) , s ) ;\n }\n off += 1 + len ;\n break ;\n case 0x83 : idx = tvb_get_guintvar ( tvb , off + 1 , & len ) ;\n str_len = tvb_strsize ( tvb , str_tbl + idx ) ;\n proto_tree_add_text ( tree , tvb , off , 1 + len , \" %3d | Attr | A %3d \" \"| STR_T (Tableref string) \" \"| %s\\'%s\\'\" , level , * codepage_attr , Indent ( level ) , tvb_format_text ( tvb , str_tbl + idx , str_len - 1 ) ) ;\n off += 1 + len ;\n break ;\n case 0xC0 : case 0xC1 : case 0xC2 : proto_tree_add_text ( tree , tvb , off , 1 , \" %3d | Attr | A %3d \" \"| EXT_%1x (Extension Token) \" \"| %s(%s)\" , level , * codepage_attr , peek & 0x0f , Indent ( level ) , map_token ( map -> global , 0 , peek ) ) ;\n off ++ ;\n break ;\n case 0xC3 : if ( tvb_get_guint8 ( tvb , 0 ) ) {\n char * str ;\n if ( attr_save_known ) {\n if ( map -> opaque_binary_attr ) {\n str = map -> opaque_binary_attr ( tvb , off + 1 , attr_save_known , * codepage_attr , & len ) ;\n }\n else {\n str = default_opaque_binary_attr ( tvb , off + 1 , attr_save_known , * codepage_attr , & len ) ;\n }\n }\n else {\n if ( map -> opaque_literal_tag ) {\n str = map -> opaque_literal_attr ( tvb , off + 1 , attr_save_literal , * codepage_attr , & len ) ;\n }\n else {\n str = default_opaque_literal_attr ( tvb , off + 1 , attr_save_literal , * codepage_attr , & len ) ;\n }\n }\n proto_tree_add_text ( tree , tvb , off , 1 + len , \" %3d | Attr | A %3d \" \"| OPAQUE (Opaque data) \" \"| %s%s\" , level , * codepage_attr , Indent ( level ) , str ) ;\n off += 1 + len ;\n }\n else {\n proto_tree_add_text ( tree , tvb , off , 1 , \" %3d | Attr | A %3d \" \"| RESERVED_2 (Invalid Token!) \" \"| WBXML 1.0 parsing stops here.\" , level , * codepage_attr ) ;\n off = tvb_len ;\n DebugLog ( ( \"ATTR: level = %u, Return: len = %u\\n\" , level , off - offset ) ) ;\n return ( off - offset ) ;\n }\n break ;\n default : proto_tree_add_text ( tree , tvb , off , 1 , \" %3d | Attr | A %3d \" \"| %-10s (Invalid Token!) \" \"| WBXML parsing stops here.\" , level , * codepage_attr , val_to_str_ext ( peek , & vals_wbxml1x_global_tokens_ext , \"(unknown 0x%x)\" ) ) ;\n off = tvb_len ;\n break ;\n }\n else {\n if ( peek & 0x80 ) {\n proto_tree_add_text ( tree , tvb , off , 1 , \" %3d | Attr | A %3d \" \"| Known attrValue 0x%02X \" \"| %s%s\" , level , * codepage_attr , peek & 0x7f , Indent ( level ) , map_token ( map -> attrValue , * codepage_attr , peek ) ) ;\n off ++ ;\n }\n else {\n attr_save_known = peek & 0x7f ;\n proto_tree_add_text ( tree , tvb , off , 1 , \" %3d | Attr | A %3d \" \"| Known attrStart 0x%02X \" \"| %s%s\" , level , * codepage_attr , attr_save_known , Indent ( level ) , map_token ( map -> attrStart , * codepage_attr , peek ) ) ;\n off ++ ;\n }\n }\n }\n DebugLog ( ( \"ATTR: level = %u, Return: len = %u (end of function body)\\n\" , level , off - offset ) ) ;\n return ( off - offset ) ;\n }", "idx": 1747}
{"hash": 1760449185745615462, "project": "debian", "size": 7, "label": 0, "functionSource": "TSFetchSM TSFetchCreate ( TSCont contp , const char * method , const char * url , const char * version , struct sockaddr const * client_addr , int flags ) {\n sdk_assert ( sdk_sanity_check_continuation ( contp ) == TS_SUCCESS ) ;\n sdk_assert ( ats_is_ip ( client_addr ) ) ;\n FetchSM * fetch_sm = FetchSMAllocator . alloc ( ) ;\n fetch_sm -> ext_init ( ( Continuation * ) contp , method , url , version , client_addr , flags ) ;\n return ( TSFetchSM ) fetch_sm ;\n }", "idx": 1748}
{"hash": 4489017523191997023, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h225_INTEGER_0_127 ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_constrained_integer ( tvb , offset , actx , tree , hf_index , 0U , 127U , NULL , FALSE ) ;\n return offset ;\n }", "idx": 1749}
{"hash": 4489017523191997023, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h225_GatekeeperInfo ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_GatekeeperInfo , GatekeeperInfo_sequence ) ;\n return offset ;\n }", "idx": 1750}
{"hash": -7117046864335130087, "project": "chrome", "size": 98, "label": 0, "functionSource": "static int rc_pick_q_and_bounds_one_pass_vbr ( const VP9_COMP * cpi , int * bottom_index , int * top_index ) {\n const VP9_COMMON * const cm = & cpi -> common ;\n const RATE_CONTROL * const rc = & cpi -> rc ;\n const VP9EncoderConfig * const oxcf = & cpi -> oxcf ;\n const int cq_level = get_active_cq_level ( rc , oxcf ) ;\n int active_best_quality ;\n int active_worst_quality = calc_active_worst_quality_one_pass_vbr ( cpi ) ;\n int q ;\n int * inter_minq ;\n ASSIGN_MINQ_TABLE ( cm -> bit_depth , inter_minq ) ;\n if ( frame_is_intra_only ( cm ) ) {\n if ( rc -> this_key_frame_forced ) {\n int qindex = rc -> last_boosted_qindex ;\n double last_boosted_q = vp9_convert_qindex_to_q ( qindex , cm -> bit_depth ) ;\n int delta_qindex = vp9_compute_qdelta ( rc , last_boosted_q , last_boosted_q * 0.75 , cm -> bit_depth ) ;\n active_best_quality = MAX ( qindex + delta_qindex , rc -> best_quality ) ;\n }\n else {\n double q_adj_factor = 1.0 ;\n double q_val ;\n active_best_quality = get_kf_active_quality ( rc , rc -> avg_frame_qindex [ KEY_FRAME ] , cm -> bit_depth ) ;\n if ( ( cm -> width * cm -> height ) <= ( 352 * 288 ) ) {\n q_adj_factor -= 0.25 ;\n }\n q_val = vp9_convert_qindex_to_q ( active_best_quality , cm -> bit_depth ) ;\n active_best_quality += vp9_compute_qdelta ( rc , q_val , q_val * q_adj_factor , cm -> bit_depth ) ;\n }\n }\n else if ( ! rc -> is_src_frame_alt_ref && ( cpi -> refresh_golden_frame || cpi -> refresh_alt_ref_frame ) ) {\n if ( rc -> frames_since_key > 1 && rc -> avg_frame_qindex [ INTER_FRAME ] < active_worst_quality ) {\n q = rc -> avg_frame_qindex [ INTER_FRAME ] ;\n }\n else {\n q = rc -> avg_frame_qindex [ KEY_FRAME ] ;\n }\n if ( oxcf -> rc_mode == VPX_CQ ) {\n if ( q < cq_level ) q = cq_level ;\n active_best_quality = get_gf_active_quality ( rc , q , cm -> bit_depth ) ;\n active_best_quality = active_best_quality * 15 / 16 ;\n }\n else if ( oxcf -> rc_mode == VPX_Q ) {\n if ( ! cpi -> refresh_alt_ref_frame ) {\n active_best_quality = cq_level ;\n }\n else {\n active_best_quality = get_gf_active_quality ( rc , q , cm -> bit_depth ) ;\n }\n }\n else {\n active_best_quality = get_gf_active_quality ( rc , q , cm -> bit_depth ) ;\n }\n }\n else {\n if ( oxcf -> rc_mode == VPX_Q ) {\n active_best_quality = cq_level ;\n }\n else {\n if ( cm -> current_video_frame > 1 ) active_best_quality = inter_minq [ rc -> avg_frame_qindex [ INTER_FRAME ] ] ;\n else active_best_quality = inter_minq [ rc -> avg_frame_qindex [ KEY_FRAME ] ] ;\n if ( ( oxcf -> rc_mode == VPX_CQ ) && ( active_best_quality < cq_level ) ) {\n active_best_quality = cq_level ;\n }\n }\n }\n active_best_quality = clamp ( active_best_quality , rc -> best_quality , rc -> worst_quality ) ;\n active_worst_quality = clamp ( active_worst_quality , active_best_quality , rc -> worst_quality ) ;\n * top_index = active_worst_quality ;\n * bottom_index = active_best_quality ;\n # if LIMIT_QRANGE_FOR_ALTREF_AND_KEY {\n int qdelta = 0 ;\n vp9_clear_system_state ( ) ;\n if ( cm -> frame_type == KEY_FRAME && ! rc -> this_key_frame_forced && ! ( cm -> current_video_frame == 0 ) ) {\n qdelta = vp9_compute_qdelta_by_rate ( & cpi -> rc , cm -> frame_type , active_worst_quality , 2.0 , cm -> bit_depth ) ;\n }\n else if ( ! rc -> is_src_frame_alt_ref && ( cpi -> refresh_golden_frame || cpi -> refresh_alt_ref_frame ) ) {\n qdelta = vp9_compute_qdelta_by_rate ( & cpi -> rc , cm -> frame_type , active_worst_quality , 1.75 , cm -> bit_depth ) ;\n }\n * top_index = active_worst_quality + qdelta ;\n * top_index = ( * top_index > * bottom_index ) ? * top_index : * bottom_index ;\n }\n # endif if ( oxcf -> rc_mode == VPX_Q ) {\n q = active_best_quality ;\n }\n else if ( ( cm -> frame_type == KEY_FRAME ) && rc -> this_key_frame_forced ) {\n q = rc -> last_boosted_qindex ;\n }\n else {\n q = vp9_rc_regulate_q ( cpi , rc -> this_frame_target , active_best_quality , active_worst_quality ) ;\n if ( q > * top_index ) {\n if ( rc -> this_frame_target >= rc -> max_frame_bandwidth ) * top_index = q ;\n else q = * top_index ;\n }\n }\n assert ( * top_index <= rc -> worst_quality && * top_index >= rc -> best_quality ) ;\n assert ( * bottom_index <= rc -> worst_quality && * bottom_index >= rc -> best_quality ) ;\n assert ( q <= rc -> worst_quality && q >= rc -> best_quality ) ;\n return q ;\n }", "idx": 1751}
{"hash": -7237039260294671485, "project": "debian", "size": 4, "label": 0, "functionSource": "static void nlm_msg_res_match_cleanup ( void ) {\n g_hash_table_destroy ( nlm_msg_res_unmatched ) ;\n g_hash_table_destroy ( nlm_msg_res_matched ) ;\n }", "idx": 1752}
{"hash": -6024601983167898950, "project": "debian", "size": 4, "label": 0, "functionSource": "static void activation_start_timed_cancel ( ActivateParameters * parameters ) {\n parameters -> timed_wait_active = TRUE ;\n eel_timed_wait_start_with_duration ( DELAY_UNTIL_CANCEL_MSECS , cancel_activate_callback , parameters , parameters -> timed_wait_prompt , parameters -> parent_window ) ;\n }", "idx": 1753}
{"hash": -7319999463952364872, "project": "debian", "size": 117, "label": 0, "functionSource": "void ff_h264_filter_mb ( H264Context * h , int mb_x , int mb_y , uint8_t * img_y , uint8_t * img_cb , uint8_t * img_cr , unsigned int linesize , unsigned int uvlinesize ) {\n const int mb_xy = mb_x + mb_y * h -> mb_stride ;\n const int mb_type = h -> cur_pic . mb_type [ mb_xy ] ;\n const int mvy_limit = IS_INTERLACED ( mb_type ) ? 2 : 4 ;\n int first_vertical_edge_done = 0 ;\n av_unused int dir ;\n int chroma = ! ( CONFIG_GRAY && ( h -> flags & CODEC_FLAG_GRAY ) ) ;\n int qp_bd_offset = 6 * ( h -> sps . bit_depth_luma - 8 ) ;\n int a = h -> slice_alpha_c0_offset - qp_bd_offset ;\n int b = h -> slice_beta_offset - qp_bd_offset ;\n if ( FRAME_MBAFF && IS_INTERLACED ( mb_type ^ h -> left_type [ LTOP ] ) && h -> left_type [ LTOP ] ) {\n DECLARE_ALIGNED ( 8 , int16_t , bS ) [ 8 ] ;\n int qp [ 2 ] ;\n int bqp [ 2 ] ;\n int rqp [ 2 ] ;\n int mb_qp , mbn0_qp , mbn1_qp ;\n int i ;\n first_vertical_edge_done = 1 ;\n if ( IS_INTRA ( mb_type ) ) {\n AV_WN64A ( & bS [ 0 ] , 0x0004000400040004ULL ) ;\n AV_WN64A ( & bS [ 4 ] , 0x0004000400040004ULL ) ;\n }\n else {\n static const uint8_t offset [ 2 ] [ 2 ] [ 8 ] = {\n {\n {\n 3 + 4 * 0 , 3 + 4 * 0 , 3 + 4 * 0 , 3 + 4 * 0 , 3 + 4 * 1 , 3 + 4 * 1 , 3 + 4 * 1 , 3 + 4 * 1 }\n , {\n 3 + 4 * 2 , 3 + 4 * 2 , 3 + 4 * 2 , 3 + 4 * 2 , 3 + 4 * 3 , 3 + 4 * 3 , 3 + 4 * 3 , 3 + 4 * 3 }\n , }\n , {\n {\n 3 + 4 * 0 , 3 + 4 * 1 , 3 + 4 * 2 , 3 + 4 * 3 , 3 + 4 * 0 , 3 + 4 * 1 , 3 + 4 * 2 , 3 + 4 * 3 }\n , {\n 3 + 4 * 0 , 3 + 4 * 1 , 3 + 4 * 2 , 3 + 4 * 3 , 3 + 4 * 0 , 3 + 4 * 1 , 3 + 4 * 2 , 3 + 4 * 3 }\n , }\n }\n ;\n const uint8_t * off = offset [ MB_FIELD ] [ mb_y & 1 ] ;\n for ( i = 0 ;\n i < 8 ;\n i ++ ) {\n int j = MB_FIELD ? i >> 2 : i & 1 ;\n int mbn_xy = h -> left_mb_xy [ LEFT ( j ) ] ;\n int mbn_type = h -> left_type [ LEFT ( j ) ] ;\n if ( IS_INTRA ( mbn_type ) ) bS [ i ] = 4 ;\n else {\n bS [ i ] = 1 + ! ! ( h -> non_zero_count_cache [ 12 + 8 * ( i >> 1 ) ] | ( ( ! h -> pps . cabac && IS_8x8DCT ( mbn_type ) ) ? ( h -> cbp_table [ mbn_xy ] & ( ( ( MB_FIELD ? ( i & 2 ) : ( mb_y & 1 ) ) ? 8 : 2 ) << 12 ) ) : h -> non_zero_count [ mbn_xy ] [ off [ i ] ] ) ) ;\n }\n }\n }\n mb_qp = h -> cur_pic . qscale_table [ mb_xy ] ;\n mbn0_qp = h -> cur_pic . qscale_table [ h -> left_mb_xy [ 0 ] ] ;\n mbn1_qp = h -> cur_pic . qscale_table [ h -> left_mb_xy [ 1 ] ] ;\n qp [ 0 ] = ( mb_qp + mbn0_qp + 1 ) >> 1 ;\n bqp [ 0 ] = ( get_chroma_qp ( h , 0 , mb_qp ) + get_chroma_qp ( h , 0 , mbn0_qp ) + 1 ) >> 1 ;\n rqp [ 0 ] = ( get_chroma_qp ( h , 1 , mb_qp ) + get_chroma_qp ( h , 1 , mbn0_qp ) + 1 ) >> 1 ;\n qp [ 1 ] = ( mb_qp + mbn1_qp + 1 ) >> 1 ;\n bqp [ 1 ] = ( get_chroma_qp ( h , 0 , mb_qp ) + get_chroma_qp ( h , 0 , mbn1_qp ) + 1 ) >> 1 ;\n rqp [ 1 ] = ( get_chroma_qp ( h , 1 , mb_qp ) + get_chroma_qp ( h , 1 , mbn1_qp ) + 1 ) >> 1 ;\n tprintf ( h -> avctx , \"filter mb:%d/%d MBAFF, QPy:%d/%d, QPb:%d/%d QPr:%d/%d ls:%d uvls:%d\" , mb_x , mb_y , qp [ 0 ] , qp [ 1 ] , bqp [ 0 ] , bqp [ 1 ] , rqp [ 0 ] , rqp [ 1 ] , linesize , uvlinesize ) ;\n {\n int i ;\n for ( i = 0 ;\n i < 8 ;\n i ++ ) tprintf ( h -> avctx , \" bS[%d]:%d\" , i , bS [ i ] ) ;\n tprintf ( h -> avctx , \"\\n\" ) ;\n }\n if ( MB_FIELD ) {\n filter_mb_mbaff_edgev ( h , img_y , linesize , bS , 1 , qp [ 0 ] , a , b , 1 ) ;\n filter_mb_mbaff_edgev ( h , img_y + 8 * linesize , linesize , bS + 4 , 1 , qp [ 1 ] , a , b , 1 ) ;\n if ( chroma ) {\n if ( CHROMA444 ) {\n filter_mb_mbaff_edgev ( h , img_cb , uvlinesize , bS , 1 , bqp [ 0 ] , a , b , 1 ) ;\n filter_mb_mbaff_edgev ( h , img_cb + 8 * uvlinesize , uvlinesize , bS + 4 , 1 , bqp [ 1 ] , a , b , 1 ) ;\n filter_mb_mbaff_edgev ( h , img_cr , uvlinesize , bS , 1 , rqp [ 0 ] , a , b , 1 ) ;\n filter_mb_mbaff_edgev ( h , img_cr + 8 * uvlinesize , uvlinesize , bS + 4 , 1 , rqp [ 1 ] , a , b , 1 ) ;\n }\n else if ( CHROMA422 ) {\n filter_mb_mbaff_edgecv ( h , img_cb , uvlinesize , bS , 1 , bqp [ 0 ] , a , b , 1 ) ;\n filter_mb_mbaff_edgecv ( h , img_cb + 8 * uvlinesize , uvlinesize , bS + 4 , 1 , bqp [ 1 ] , a , b , 1 ) ;\n filter_mb_mbaff_edgecv ( h , img_cr , uvlinesize , bS , 1 , rqp [ 0 ] , a , b , 1 ) ;\n filter_mb_mbaff_edgecv ( h , img_cr + 8 * uvlinesize , uvlinesize , bS + 4 , 1 , rqp [ 1 ] , a , b , 1 ) ;\n }\n else {\n filter_mb_mbaff_edgecv ( h , img_cb , uvlinesize , bS , 1 , bqp [ 0 ] , a , b , 1 ) ;\n filter_mb_mbaff_edgecv ( h , img_cb + 4 * uvlinesize , uvlinesize , bS + 4 , 1 , bqp [ 1 ] , a , b , 1 ) ;\n filter_mb_mbaff_edgecv ( h , img_cr , uvlinesize , bS , 1 , rqp [ 0 ] , a , b , 1 ) ;\n filter_mb_mbaff_edgecv ( h , img_cr + 4 * uvlinesize , uvlinesize , bS + 4 , 1 , rqp [ 1 ] , a , b , 1 ) ;\n }\n }\n }\n else {\n filter_mb_mbaff_edgev ( h , img_y , 2 * linesize , bS , 2 , qp [ 0 ] , a , b , 1 ) ;\n filter_mb_mbaff_edgev ( h , img_y + linesize , 2 * linesize , bS + 1 , 2 , qp [ 1 ] , a , b , 1 ) ;\n if ( chroma ) {\n if ( CHROMA444 ) {\n filter_mb_mbaff_edgev ( h , img_cb , 2 * uvlinesize , bS , 2 , bqp [ 0 ] , a , b , 1 ) ;\n filter_mb_mbaff_edgev ( h , img_cb + uvlinesize , 2 * uvlinesize , bS + 1 , 2 , bqp [ 1 ] , a , b , 1 ) ;\n filter_mb_mbaff_edgev ( h , img_cr , 2 * uvlinesize , bS , 2 , rqp [ 0 ] , a , b , 1 ) ;\n filter_mb_mbaff_edgev ( h , img_cr + uvlinesize , 2 * uvlinesize , bS + 1 , 2 , rqp [ 1 ] , a , b , 1 ) ;\n }\n else {\n filter_mb_mbaff_edgecv ( h , img_cb , 2 * uvlinesize , bS , 2 , bqp [ 0 ] , a , b , 1 ) ;\n filter_mb_mbaff_edgecv ( h , img_cb + uvlinesize , 2 * uvlinesize , bS + 1 , 2 , bqp [ 1 ] , a , b , 1 ) ;\n filter_mb_mbaff_edgecv ( h , img_cr , 2 * uvlinesize , bS , 2 , rqp [ 0 ] , a , b , 1 ) ;\n filter_mb_mbaff_edgecv ( h , img_cr + uvlinesize , 2 * uvlinesize , bS + 1 , 2 , rqp [ 1 ] , a , b , 1 ) ;\n }\n }\n }\n }\n # if CONFIG_SMALL for ( dir = 0 ;\n dir < 2 ;\n dir ++ ) filter_mb_dir ( h , mb_x , mb_y , img_y , img_cb , img_cr , linesize , uvlinesize , mb_xy , mb_type , mvy_limit , dir ? 0 : first_vertical_edge_done , a , b , chroma , dir ) ;\n # else filter_mb_dir ( h , mb_x , mb_y , img_y , img_cb , img_cr , linesize , uvlinesize , mb_xy , mb_type , mvy_limit , first_vertical_edge_done , a , b , chroma , 0 ) ;\n filter_mb_dir ( h , mb_x , mb_y , img_y , img_cb , img_cr , linesize , uvlinesize , mb_xy , mb_type , mvy_limit , 0 , a , b , chroma , 1 ) ;\n # endif }", "idx": 1754}
{"hash": -3299391226809811274, "project": "debian", "size": 4, "label": 0, "functionSource": "static int qemuAgentOnceInit ( void ) {\n if ( ! ( qemuAgentClass = virClassNew ( virClassForObjectLockable ( ) , \"qemuAgent\" , sizeof ( qemuAgent ) , qemuAgentDispose ) ) ) return - 1 ;\n return 0 ;\n }", "idx": 1755}
{"hash": 6302861533225984845, "project": "debian", "size": 3, "label": 0, "functionSource": "static void pxa2xx_setup_cp14 ( PXA2xxState * s ) {\n define_arm_cp_regs_with_opaque ( s -> cpu , pxa_cp_reginfo , s ) ;\n }", "idx": 1756}
{"hash": -7253276028511611170, "project": "debian", "size": 6, "label": 0, "functionSource": "static void encode_parse_params ( VC2EncContext * s ) {\n put_vc2_ue_uint ( & s -> pb , s -> ver . major ) ;\n put_vc2_ue_uint ( & s -> pb , s -> ver . minor ) ;\n put_vc2_ue_uint ( & s -> pb , s -> profile ) ;\n put_vc2_ue_uint ( & s -> pb , s -> level ) ;\n }", "idx": 1757}
{"hash": 6675626110148442062, "project": "debian", "size": 6, "label": 0, "functionSource": "long jas_stream_setrwcount ( jas_stream_t * stream , long rwcnt ) {\n int old ;\n old = stream -> rwcnt_ ;\n stream -> rwcnt_ = rwcnt ;\n return old ;\n }", "idx": 1758}
{"hash": -8665368283409781704, "project": "debian", "size": 14, "label": 0, "functionSource": "static void write_selected_commits_v1 ( struct sha1file * f , struct pack_idx_entry * * index , uint32_t index_nr ) {\n int i ;\n for ( i = 0 ;\n i < writer . selected_nr ;\n ++ i ) {\n struct bitmapped_commit * stored = & writer . selected [ i ] ;\n int commit_pos = sha1_pos ( stored -> commit -> object . oid . hash , index , index_nr , sha1_access ) ;\n if ( commit_pos < 0 ) die ( \"BUG: trying to write commit not in index\" ) ;\n sha1write_be32 ( f , commit_pos ) ;\n sha1write_u8 ( f , stored -> xor_offset ) ;\n sha1write_u8 ( f , stored -> flags ) ;\n dump_bitmap ( f , stored -> write_as ) ;\n }\n }", "idx": 1759}
{"hash": -1315695702746584250, "project": "debian", "size": 10, "label": 0, "functionSource": "proto_item * proto_tree_add_boolean ( proto_tree * tree , int hfindex , tvbuff_t * tvb , gint start , gint length , guint32 value ) {\n proto_item * pi ;\n header_field_info * hfinfo ;\n CHECK_FOR_NULL_TREE ( tree ) ;\n TRY_TO_FAKE_THIS_ITEM ( tree , hfindex , hfinfo ) ;\n DISSECTOR_ASSERT_FIELD_TYPE ( hfinfo , FT_BOOLEAN ) ;\n pi = proto_tree_add_pi ( tree , hfinfo , tvb , start , & length ) ;\n proto_tree_set_boolean ( PNODE_FINFO ( pi ) , value ) ;\n return pi ;\n }", "idx": 1760}
{"hash": -3559021711340554904, "project": "debian", "size": 4, "label": 0, "functionSource": "bool is_pseudo_constant_clause ( Node * clause ) {\n if ( ! contain_var_clause ( clause ) && ! contain_volatile_functions ( clause ) ) return true ;\n return false ;\n }", "idx": 1761}
{"hash": -8721757784652752372, "project": "debian", "size": 104, "label": 0, "functionSource": "static jpc_enc_prc_t * prc_create ( jpc_enc_prc_t * prc , jpc_enc_cp_t * cp , jpc_enc_band_t * band ) {\n uint_fast32_t prcno ;\n uint_fast32_t prcxind ;\n uint_fast32_t prcyind ;\n uint_fast32_t cbgtlx ;\n uint_fast32_t cbgtly ;\n uint_fast32_t tlprctlx ;\n uint_fast32_t tlprctly ;\n uint_fast32_t tlcbgtlx ;\n uint_fast32_t tlcbgtly ;\n uint_fast16_t rlvlno ;\n jpc_enc_rlvl_t * rlvl ;\n uint_fast32_t tlcblktlx ;\n uint_fast32_t tlcblktly ;\n uint_fast32_t brcblkbrx ;\n uint_fast32_t brcblkbry ;\n uint_fast32_t cblkno ;\n jpc_enc_cblk_t * cblk ;\n jpc_enc_tcmpt_t * tcmpt ;\n prc -> cblks = 0 ;\n prc -> incltree = 0 ;\n prc -> savincltree = 0 ;\n prc -> nlibtree = 0 ;\n prc -> savnlibtree = 0 ;\n rlvl = band -> rlvl ;\n tcmpt = rlvl -> tcmpt ;\n rlvlno = rlvl - tcmpt -> rlvls ;\n prcno = prc - band -> prcs ;\n prcxind = prcno % rlvl -> numhprcs ;\n prcyind = prcno / rlvl -> numhprcs ;\n prc -> band = band ;\n tlprctlx = JPC_FLOORTOMULTPOW2 ( rlvl -> tlx , rlvl -> prcwidthexpn ) ;\n tlprctly = JPC_FLOORTOMULTPOW2 ( rlvl -> tly , rlvl -> prcheightexpn ) ;\n if ( ! rlvlno ) {\n tlcbgtlx = tlprctlx ;\n tlcbgtly = tlprctly ;\n }\n else {\n tlcbgtlx = JPC_CEILDIVPOW2 ( tlprctlx , 1 ) ;\n tlcbgtly = JPC_CEILDIVPOW2 ( tlprctly , 1 ) ;\n }\n cbgtlx = tlcbgtlx + ( prcxind << rlvl -> cbgwidthexpn ) ;\n cbgtly = tlcbgtly + ( prcyind << rlvl -> cbgheightexpn ) ;\n prc -> tlx = JAS_MAX ( jas_seq2d_xstart ( band -> data ) , cbgtlx ) ;\n prc -> tly = JAS_MAX ( jas_seq2d_ystart ( band -> data ) , cbgtly ) ;\n prc -> brx = JAS_MIN ( jas_seq2d_xend ( band -> data ) , cbgtlx + ( 1 << rlvl -> cbgwidthexpn ) ) ;\n prc -> bry = JAS_MIN ( jas_seq2d_yend ( band -> data ) , cbgtly + ( 1 << rlvl -> cbgheightexpn ) ) ;\n if ( prc -> tlx < prc -> brx && prc -> tly < prc -> bry ) {\n tlcblktlx = JPC_FLOORTOMULTPOW2 ( prc -> tlx , rlvl -> cblkwidthexpn ) ;\n tlcblktly = JPC_FLOORTOMULTPOW2 ( prc -> tly , rlvl -> cblkheightexpn ) ;\n brcblkbrx = JPC_CEILTOMULTPOW2 ( prc -> brx , rlvl -> cblkwidthexpn ) ;\n brcblkbry = JPC_CEILTOMULTPOW2 ( prc -> bry , rlvl -> cblkheightexpn ) ;\n prc -> numhcblks = JPC_FLOORDIVPOW2 ( brcblkbrx - tlcblktlx , rlvl -> cblkwidthexpn ) ;\n prc -> numvcblks = JPC_FLOORDIVPOW2 ( brcblkbry - tlcblktly , rlvl -> cblkheightexpn ) ;\n prc -> numcblks = prc -> numhcblks * prc -> numvcblks ;\n if ( ! ( prc -> incltree = jpc_tagtree_create ( prc -> numhcblks , prc -> numvcblks ) ) ) {\n goto error ;\n }\n if ( ! ( prc -> nlibtree = jpc_tagtree_create ( prc -> numhcblks , prc -> numvcblks ) ) ) {\n goto error ;\n }\n if ( ! ( prc -> savincltree = jpc_tagtree_create ( prc -> numhcblks , prc -> numvcblks ) ) ) {\n goto error ;\n }\n if ( ! ( prc -> savnlibtree = jpc_tagtree_create ( prc -> numhcblks , prc -> numvcblks ) ) ) {\n goto error ;\n }\n if ( ! ( prc -> cblks = jas_alloc2 ( prc -> numcblks , sizeof ( jpc_enc_cblk_t ) ) ) ) {\n goto error ;\n }\n for ( cblkno = 0 , cblk = prc -> cblks ;\n cblkno < prc -> numcblks ;\n ++ cblkno , ++ cblk ) {\n cblk -> passes = 0 ;\n cblk -> stream = 0 ;\n cblk -> mqenc = 0 ;\n cblk -> data = 0 ;\n cblk -> flags = 0 ;\n cblk -> prc = prc ;\n }\n for ( cblkno = 0 , cblk = prc -> cblks ;\n cblkno < prc -> numcblks ;\n ++ cblkno , ++ cblk ) {\n if ( ! cblk_create ( cblk , cp , prc ) ) {\n goto error ;\n }\n }\n }\n else {\n prc -> tlx = prc -> brx ;\n prc -> tly = prc -> bry ;\n prc -> numcblks = 0 ;\n prc -> numhcblks = 0 ;\n prc -> numvcblks = 0 ;\n prc -> cblks = 0 ;\n prc -> incltree = 0 ;\n prc -> nlibtree = 0 ;\n prc -> savincltree = 0 ;\n prc -> savnlibtree = 0 ;\n }\n return prc ;\n error : prc_destroy ( prc ) ;\n return 0 ;\n }", "idx": 1762}
{"hash": -3819889754140204145, "project": "debian", "size": 13, "label": 0, "functionSource": "static bool gn_to_string ( identification_t * id , char * * uri ) {\n int len ;\n # ifdef USE_FUZZING chunk_t proper ;\n chunk_printable ( id -> get_encoding ( id ) , & proper , '?' ) ;\n len = asprintf ( uri , \"%.*s\" , ( int ) proper . len , proper . ptr ) ;\n chunk_free ( & proper ) ;\n # else len = asprintf ( uri , \"%Y\" , id ) ;\n # endif if ( ! len ) {\n free ( * uri ) ;\n return FALSE ;\n }\n return len > 0 ;\n }", "idx": 1763}
{"hash": 7191899184788440065, "project": "debian", "size": 5, "label": 0, "functionSource": "static ulong start_timer ( void ) {\n # if defined ( __WIN__ ) return clock ( ) ;\n # else struct tms tms_tmp ;\n return times ( & tms_tmp ) ;\n # endif }", "idx": 1764}
{"hash": -7334302271653594926, "project": "debian", "size": 3, "label": 0, "functionSource": "bool cmp_items ( Item * a , Item * b ) {\n return a -> eq ( b , FALSE ) ;\n }", "idx": 1765}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_T_iPAddress ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_T_iPAddress , T_iPAddress_sequence ) ;\n return offset ;\n }", "idx": 1766}
{"hash": -182831737838159094, "project": "chrome", "size": 11, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( ContentFaviconDriverTest , AssociateIconWithInitialPageIconDespiteReplaceState ) {\n ASSERT_TRUE ( embedded_test_server ( ) -> Start ( ) ) ;\n GURL url = embedded_test_server ( ) -> GetURL ( \"/favicon/replacestate_with_favicon.html\" ) ;\n GURL replacestate_url = embedded_test_server ( ) -> GetURL ( \"/favicon/replacestate_with_favicon_replaced.html\" ) ;\n PendingTaskWaiter waiter ( web_contents ( ) ) ;\n waiter . AlsoRequireUrl ( replacestate_url ) ;\n ui_test_utils : : NavigateToURLWithDisposition ( browser ( ) , url , WindowOpenDisposition : : CURRENT_TAB , ui_test_utils : : BROWSER_TEST_NONE ) ;\n waiter . Wait ( ) ;\n EXPECT_NE ( nullptr , GetFaviconForPageURL ( url , favicon_base : : IconType : : kFavicon ) . bitmap_data ) ;\n EXPECT_NE ( nullptr , GetFaviconForPageURL ( replacestate_url , favicon_base : : IconType : : kFavicon ) . bitmap_data ) ;\n }", "idx": 1767}
{"hash": -1315695702746584250, "project": "debian", "size": 10, "label": 0, "functionSource": "static int hfinfo_hex_digits ( const header_field_info * hfinfo ) {\n int bitwidth ;\n if ( hfinfo -> bitmask != 0 ) {\n bitwidth = hfinfo_mask_bitwidth ( hfinfo ) ;\n }\n else {\n bitwidth = hfinfo_type_bitwidth ( hfinfo -> type ) ;\n }\n return ( bitwidth + 3 ) / 4 ;\n }", "idx": 1768}
{"hash": -866921002076081979, "project": "debian", "size": 124, "label": 0, "functionSource": "static int cache_hook_handler ( TSCont contp , TSEvent event , void * edata ) {\n TSHttpTxn txnp = nullptr ;\n CacheTestData * data = nullptr ;\n CHECK_SPURIOUS_EVENT ( contp , event , edata ) ;\n data = ( CacheTestData * ) TSContDataGet ( contp ) ;\n switch ( event ) {\n case TS_EVENT_HTTP_READ_REQUEST_HDR : txnp = ( TSHttpTxn ) edata ;\n TSSkipRemappingSet ( txnp , 1 ) ;\n TSHttpTxnReenable ( txnp , TS_EVENT_HTTP_CONTINUE ) ;\n break ;\n case TS_EVENT_HTTP_CACHE_LOOKUP_COMPLETE : {\n int lookup_status ;\n if ( data -> first_time == true ) {\n txnp = ( TSHttpTxn ) edata ;\n if ( TSHttpTxnCacheLookupStatusGet ( txnp , & lookup_status ) != TS_SUCCESS ) {\n SDK_RPRINT ( data -> test , \"TSHttpTxnCacheLookupStatusGet\" , \"TestCase1\" , TC_FAIL , \"TSHttpTxnCacheLookupStatus doesn't return TS_SUCCESS\" ) ;\n }\n else {\n if ( lookup_status == TS_CACHE_LOOKUP_MISS ) {\n SDK_RPRINT ( data -> test , \"TSHttpTxnCacheLookupStatusGet\" , \"TestCase1\" , TC_PASS , \"ok\" ) ;\n data -> test_passed_txn_cache_lookup_status = true ;\n }\n else {\n SDK_RPRINT ( data -> test , \"TSHttpTxnCacheLookupStatusGet\" , \"TestCase1\" , TC_FAIL , \"Incorrect Value returned by TSHttpTxnCacheLookupStatusGet\" ) ;\n }\n }\n }\n else {\n txnp = ( TSHttpTxn ) edata ;\n if ( TSHttpTxnCacheLookupStatusGet ( txnp , & lookup_status ) != TS_SUCCESS ) {\n SDK_RPRINT ( data -> test , \"TSHttpTxnCacheLookupStatusGet\" , \"TestCase2\" , TC_FAIL , \"TSHttpTxnCacheLookupStatus doesn't return TS_SUCCESS\" ) ;\n data -> test_passed_txn_cache_lookup_status = false ;\n }\n else {\n if ( lookup_status == TS_CACHE_LOOKUP_HIT_FRESH ) {\n SDK_RPRINT ( data -> test , \"TSHttpTxnCacheLookupStatusGet\" , \"TestCase2\" , TC_PASS , \"ok\" ) ;\n }\n else {\n SDK_RPRINT ( data -> test , \"TSHttpTxnCacheLookupStatusGet\" , \"TestCase2\" , TC_FAIL , \"Incorrect Value returned by TSHttpTxnCacheLookupStatusGet\" ) ;\n data -> test_passed_txn_cache_lookup_status = false ;\n }\n }\n }\n TSHttpTxnReenable ( txnp , TS_EVENT_HTTP_CONTINUE ) ;\n }\n break ;\n case TS_EVENT_HTTP_READ_CACHE_HDR : {\n TSMBuffer reqbuf ;\n TSMBuffer respbuf ;\n TSMLoc reqhdr ;\n TSMLoc resphdr ;\n txnp = ( TSHttpTxn ) edata ;\n if ( TSHttpTxnCachedReqGet ( txnp , & reqbuf , & reqhdr ) != TS_SUCCESS ) {\n SDK_RPRINT ( data -> test , \"TSHttpTxnCachedReqGet\" , \"TestCase1\" , TC_FAIL , \"TSHttpTxnCachedReqGet returns 0\" ) ;\n }\n else {\n if ( ( reqbuf == reinterpret_cast < TSMBuffer > ( ( ( HttpSM * ) txnp ) -> t_state . cache_req_hdr_heap_handle ) ) && ( reqhdr == reinterpret_cast < TSMLoc > ( ( ( ( HttpSM * ) txnp ) -> t_state . cache_info . object_read -> request_get ( ) ) -> m_http ) ) ) {\n SDK_RPRINT ( data -> test , \"TSHttpTxnCachedReqGet\" , \"TestCase1\" , TC_PASS , \"ok\" ) ;\n data -> test_passed_txn_cached_req_get = true ;\n }\n else {\n SDK_RPRINT ( data -> test , \"TSHttpTxnCachedReqGet\" , \"TestCase1\" , TC_FAIL , \"Value's Mismatch\" ) ;\n }\n }\n if ( TSHttpTxnCachedRespGet ( txnp , & respbuf , & resphdr ) != TS_SUCCESS ) {\n SDK_RPRINT ( data -> test , \"TSHttpTxnCachedRespGet\" , \"TestCase1\" , TC_FAIL , \"TSHttpTxnCachedRespGet returns 0\" ) ;\n }\n else {\n if ( ( respbuf == reinterpret_cast < TSMBuffer > ( ( ( HttpSM * ) txnp ) -> t_state . cache_resp_hdr_heap_handle ) ) && ( resphdr == reinterpret_cast < TSMLoc > ( ( ( ( HttpSM * ) txnp ) -> t_state . cache_info . object_read -> response_get ( ) ) -> m_http ) ) ) {\n SDK_RPRINT ( data -> test , \"TSHttpTxnCachedRespGet\" , \"TestCase1\" , TC_PASS , \"ok\" ) ;\n data -> test_passed_txn_cached_resp_get = true ;\n }\n else {\n SDK_RPRINT ( data -> test , \"TSHttpTxnCachedRespGet\" , \"TestCase1\" , TC_FAIL , \"Value's Mismatch\" ) ;\n }\n }\n if ( ( TSHandleMLocRelease ( reqbuf , TS_NULL_MLOC , reqhdr ) != TS_SUCCESS ) || ( TSHandleMLocRelease ( respbuf , TS_NULL_MLOC , resphdr ) != TS_SUCCESS ) ) {\n SDK_RPRINT ( data -> test , \"TSHttpTxnCache\" , \"\" , TC_FAIL , \"Unable to release handle to headers.\" ) ;\n }\n TSHttpTxnReenable ( txnp , TS_EVENT_HTTP_CONTINUE ) ;\n }\n break ;\n case TS_EVENT_IMMEDIATE : case TS_EVENT_TIMEOUT : if ( data -> first_time == true ) {\n if ( data -> browser1 -> status == REQUEST_INPROGRESS ) {\n TSContSchedule ( contp , 25 , TS_THREAD_POOL_DEFAULT ) ;\n return 0 ;\n }\n }\n else {\n if ( data -> browser2 -> status == REQUEST_INPROGRESS ) {\n TSContSchedule ( contp , 25 , TS_THREAD_POOL_DEFAULT ) ;\n return 0 ;\n }\n }\n {\n if ( data -> first_time == true ) {\n data -> first_time = false ;\n synserver_delete ( data -> os ) ;\n data -> os = nullptr ;\n synclient_txn_send_request ( data -> browser2 , data -> request ) ;\n ink_assert ( REQUEST_INPROGRESS == data -> browser2 -> status ) ;\n TSContSchedule ( contp , 25 , TS_THREAD_POOL_DEFAULT ) ;\n return 0 ;\n }\n if ( ( data -> browser1 -> status == REQUEST_SUCCESS ) && ( data -> browser2 -> status == REQUEST_SUCCESS ) && ( data -> test_passed_txn_cached_req_get == true ) && ( data -> test_passed_txn_cached_resp_get == true ) && ( data -> test_passed_txn_cache_lookup_status == true ) ) {\n * ( data -> pstatus ) = REGRESSION_TEST_PASSED ;\n }\n else {\n * ( data -> pstatus ) = REGRESSION_TEST_FAILED ;\n }\n synclient_txn_delete ( data -> browser1 ) ;\n synclient_txn_delete ( data -> browser2 ) ;\n data -> magic = MAGIC_DEAD ;\n TSfree ( data -> request ) ;\n TSfree ( data ) ;\n TSContDataSet ( contp , nullptr ) ;\n }\n break ;\n default : * ( data -> pstatus ) = REGRESSION_TEST_FAILED ;\n SDK_RPRINT ( data -> test , \"TSHttpTxnCache\" , \"TestCase1\" , TC_FAIL , \"Unexpected event %d\" , event ) ;\n break ;\n }\n return 0 ;\n }", "idx": 1769}
{"hash": -2915908172644760936, "project": "debian", "size": 28, "label": 0, "functionSource": "static void lms_update ( WmallDecodeCtx * s , int ich , int ilms , int input , int residue ) {\n int icoef ;\n int recent = s -> cdlms [ ich ] [ ilms ] . recent ;\n int range = 1 << s -> bits_per_sample - 1 ;\n if ( residue < 0 ) {\n for ( icoef = 0 ;\n icoef < s -> cdlms [ ich ] [ ilms ] . order ;\n icoef ++ ) s -> cdlms [ ich ] [ ilms ] . coefs [ icoef ] -= s -> cdlms [ ich ] [ ilms ] . lms_updates [ icoef + recent ] ;\n }\n else if ( residue > 0 ) {\n for ( icoef = 0 ;\n icoef < s -> cdlms [ ich ] [ ilms ] . order ;\n icoef ++ ) s -> cdlms [ ich ] [ ilms ] . coefs [ icoef ] += s -> cdlms [ ich ] [ ilms ] . lms_updates [ icoef + recent ] ;\n }\n if ( recent ) recent -- ;\n else {\n memcpy ( & s -> cdlms [ ich ] [ ilms ] . lms_prevvalues [ s -> cdlms [ ich ] [ ilms ] . order ] , s -> cdlms [ ich ] [ ilms ] . lms_prevvalues , 2 * s -> cdlms [ ich ] [ ilms ] . order ) ;\n memcpy ( & s -> cdlms [ ich ] [ ilms ] . lms_updates [ s -> cdlms [ ich ] [ ilms ] . order ] , s -> cdlms [ ich ] [ ilms ] . lms_updates , 2 * s -> cdlms [ ich ] [ ilms ] . order ) ;\n recent = s -> cdlms [ ich ] [ ilms ] . order - 1 ;\n }\n s -> cdlms [ ich ] [ ilms ] . lms_prevvalues [ recent ] = av_clip ( input , - range , range - 1 ) ;\n if ( ! input ) s -> cdlms [ ich ] [ ilms ] . lms_updates [ recent ] = 0 ;\n else if ( input < 0 ) s -> cdlms [ ich ] [ ilms ] . lms_updates [ recent ] = - s -> update_speed [ ich ] ;\n else s -> cdlms [ ich ] [ ilms ] . lms_updates [ recent ] = s -> update_speed [ ich ] ;\n s -> cdlms [ ich ] [ ilms ] . lms_updates [ recent + ( s -> cdlms [ ich ] [ ilms ] . order >> 4 ) ] >>= 2 ;\n s -> cdlms [ ich ] [ ilms ] . lms_updates [ recent + ( s -> cdlms [ ich ] [ ilms ] . order >> 3 ) ] >>= 1 ;\n s -> cdlms [ ich ] [ ilms ] . recent = recent ;\n }", "idx": 1770}
{"hash": 3462687654654039530, "project": "chrome", "size": 12, "label": 0, "functionSource": "static const UChar * fetchErrorName ( UErrorCode err ) {\n if ( ! gInfoMessages ) {\n gInfoMessages = ( UChar * * ) malloc ( ( U_ERROR_WARNING_LIMIT - U_ERROR_WARNING_START ) * sizeof ( UChar * ) ) ;\n memset ( gInfoMessages , 0 , ( U_ERROR_WARNING_LIMIT - U_ERROR_WARNING_START ) * sizeof ( UChar * ) ) ;\n }\n if ( ! gErrMessages ) {\n gErrMessages = ( UChar * * ) malloc ( U_ERROR_LIMIT * sizeof ( UChar * ) ) ;\n memset ( gErrMessages , 0 , U_ERROR_LIMIT * sizeof ( UChar * ) ) ;\n }\n if ( err >= 0 ) return gErrMessages [ err ] ;\n else return gInfoMessages [ err - U_ERROR_WARNING_START ] ;\n }", "idx": 1771}
{"hash": 1182028467273264883, "project": "debian", "size": 3, "label": 0, "functionSource": "my_bool end_of_query ( int c ) {\n return match_delimiter ( c , delimiter , delimiter_length ) ;\n }", "idx": 1772}
{"hash": 4198675434481816937, "project": "debian", "size": 12, "label": 1, "functionSource": "void IGDstartelt ( void * d , const char * name , int l ) {\n struct IGDdatas * datas = ( struct IGDdatas * ) d ;\n memcpy ( datas -> cureltname , name , l ) ;\n datas -> cureltname [ l ] = '\\0' ;\n datas -> level ++ ;\n if ( ( l == 7 ) && ! memcmp ( name , \"service\" , l ) ) {\n datas -> tmp . controlurl [ 0 ] = '\\0' ;\n datas -> tmp . eventsuburl [ 0 ] = '\\0' ;\n datas -> tmp . scpdurl [ 0 ] = '\\0' ;\n datas -> tmp . servicetype [ 0 ] = '\\0' ;\n }\n }", "idx": 1773}
{"hash": 1182028467273264883, "project": "debian", "size": 34, "label": 0, "functionSource": "void append_metadata ( DYNAMIC_STRING * ds , MYSQL_FIELD * field , uint num_fields ) {\n MYSQL_FIELD * field_end ;\n dynstr_append ( ds , \"Catalog\\tDatabase\\tTable\\tTable_alias\\tColumn\\t\" \"Column_alias\\tType\\tLength\\tMax length\\tIs_null\\t\" \"Flags\\tDecimals\\tCharsetnr\\n\" ) ;\n for ( field_end = field + num_fields ;\n field < field_end ;\n field ++ ) {\n dynstr_append_mem ( ds , field -> catalog , field -> catalog_length ) ;\n dynstr_append_mem ( ds , \"\\t\" , 1 ) ;\n dynstr_append_mem ( ds , field -> db , field -> db_length ) ;\n dynstr_append_mem ( ds , \"\\t\" , 1 ) ;\n dynstr_append_mem ( ds , field -> org_table , field -> org_table_length ) ;\n dynstr_append_mem ( ds , \"\\t\" , 1 ) ;\n dynstr_append_mem ( ds , field -> table , field -> table_length ) ;\n dynstr_append_mem ( ds , \"\\t\" , 1 ) ;\n dynstr_append_mem ( ds , field -> org_name , field -> org_name_length ) ;\n dynstr_append_mem ( ds , \"\\t\" , 1 ) ;\n dynstr_append_mem ( ds , field -> name , field -> name_length ) ;\n dynstr_append_mem ( ds , \"\\t\" , 1 ) ;\n replace_dynstr_append_uint ( ds , field -> type ) ;\n dynstr_append_mem ( ds , \"\\t\" , 1 ) ;\n replace_dynstr_append_uint ( ds , field -> length ) ;\n dynstr_append_mem ( ds , \"\\t\" , 1 ) ;\n replace_dynstr_append_uint ( ds , field -> max_length ) ;\n dynstr_append_mem ( ds , \"\\t\" , 1 ) ;\n dynstr_append_mem ( ds , ( char * ) ( IS_NOT_NULL ( field -> flags ) ? \"N\" : \"Y\" ) , 1 ) ;\n dynstr_append_mem ( ds , \"\\t\" , 1 ) ;\n replace_dynstr_append_uint ( ds , field -> flags ) ;\n dynstr_append_mem ( ds , \"\\t\" , 1 ) ;\n replace_dynstr_append_uint ( ds , field -> decimals ) ;\n dynstr_append_mem ( ds , \"\\t\" , 1 ) ;\n replace_dynstr_append_uint ( ds , field -> charsetnr ) ;\n dynstr_append_mem ( ds , \"\\n\" , 1 ) ;\n }\n }", "idx": 1774}
{"hash": -7248963932691286231, "project": "debian", "size": 27, "label": 1, "functionSource": "static void build_config ( char * prefix , struct server * server ) {\n char * path = NULL ;\n int path_size = strlen ( prefix ) + strlen ( server -> port ) + 20 ;\n path = ss_malloc ( path_size ) ;\n snprintf ( path , path_size , \"%s/.shadowsocks_%s.conf\" , prefix , server -> port ) ;\n FILE * f = fopen ( path , \"w+\" ) ;\n if ( f == NULL ) {\n if ( verbose ) {\n LOGE ( \"unable to open config file\" ) ;\n }\n ss_free ( path ) ;\n return ;\n }\n fprintf ( f , \"{\n\\n\" ) ;\n fprintf ( f , \"\\\"server_port\\\":%d,\\n\" , atoi ( server -> port ) ) ;\n fprintf ( f , \"\\\"password\\\":\\\"%s\\\"\" , server -> password ) ;\n if ( server -> fast_open [ 0 ] ) fprintf ( f , \",\\n\\\"fast_open\\\": %s\" , server -> fast_open ) ;\n if ( server -> mode ) fprintf ( f , \",\\n\\\"mode\\\":\\\"%s\\\"\" , server -> mode ) ;\n if ( server -> method ) fprintf ( f , \",\\n\\\"method\\\":\\\"%s\\\"\" , server -> method ) ;\n if ( server -> plugin ) fprintf ( f , \",\\n\\\"plugin\\\":\\\"%s\\\"\" , server -> plugin ) ;\n if ( server -> plugin_opts ) fprintf ( f , \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\" , server -> plugin_opts ) ;\n fprintf ( f , \"\\n}\n\\n\" ) ;\n fclose ( f ) ;\n ss_free ( path ) ;\n }", "idx": 1775}
{"hash": 5357882892791796049, "project": "debian", "size": 11, "label": 0, "functionSource": "static uint32_t e1000e_txdesc_writeback ( E1000ECore * core , dma_addr_t base , struct e1000_tx_desc * dp , bool * ide , int queue_idx ) {\n uint32_t txd_upper , txd_lower = le32_to_cpu ( dp -> lower . data ) ;\n if ( ! ( txd_lower & E1000_TXD_CMD_RS ) && ! ( core -> mac [ IVAR ] & E1000_IVAR_TX_INT_EVERY_WB ) ) {\n return 0 ;\n }\n * ide = ( txd_lower & E1000_TXD_CMD_IDE ) ? true : false ;\n txd_upper = le32_to_cpu ( dp -> upper . data ) | E1000_TXD_STAT_DD ;\n dp -> upper . data = cpu_to_le32 ( txd_upper ) ;\n pci_dma_write ( core -> owner , base + ( ( char * ) & dp -> upper - ( char * ) dp ) , & dp -> upper , sizeof ( dp -> upper ) ) ;\n return e1000e_tx_wb_interrupt_cause ( core , queue_idx ) ;\n }", "idx": 1776}
{"hash": -2222463888415249941, "project": "chrome", "size": 50, "label": 1, "functionSource": "void vp9_change_config ( struct VP9_COMP * cpi , const VP9EncoderConfig * oxcf ) {\n VP9_COMMON * const cm = & cpi -> common ;\n RATE_CONTROL * const rc = & cpi -> rc ;\n if ( cm -> profile != oxcf -> profile ) cm -> profile = oxcf -> profile ;\n cm -> bit_depth = oxcf -> bit_depth ;\n if ( cm -> profile <= PROFILE_1 ) assert ( cm -> bit_depth == VPX_BITS_8 ) ;\n else assert ( cm -> bit_depth > VPX_BITS_8 ) ;\n cpi -> oxcf = * oxcf ;\n rc -> baseline_gf_interval = DEFAULT_GF_INTERVAL ;\n cpi -> refresh_golden_frame = 0 ;\n cpi -> refresh_last_frame = 1 ;\n cm -> refresh_frame_context = 1 ;\n cm -> reset_frame_context = 0 ;\n vp9_reset_segment_features ( & cm -> seg ) ;\n vp9_set_high_precision_mv ( cpi , 0 ) ;\n {\n int i ;\n for ( i = 0 ;\n i < MAX_SEGMENTS ;\n i ++ ) cpi -> segment_encode_breakout [ i ] = cpi -> oxcf . encode_breakout ;\n }\n cpi -> encode_breakout = cpi -> oxcf . encode_breakout ;\n set_rc_buffer_sizes ( rc , & cpi -> oxcf ) ;\n rc -> bits_off_target = MIN ( rc -> bits_off_target , rc -> maximum_buffer_size ) ;\n rc -> buffer_level = MIN ( rc -> buffer_level , rc -> maximum_buffer_size ) ;\n vp9_new_framerate ( cpi , cpi -> framerate ) ;\n rc -> worst_quality = cpi -> oxcf . worst_allowed_q ;\n rc -> best_quality = cpi -> oxcf . best_allowed_q ;\n cm -> interp_filter = cpi -> sf . default_interp_filter ;\n cm -> display_width = cpi -> oxcf . width ;\n cm -> display_height = cpi -> oxcf . height ;\n if ( cpi -> initial_width ) {\n assert ( cm -> width <= cpi -> initial_width ) ;\n assert ( cm -> height <= cpi -> initial_height ) ;\n }\n update_frame_size ( cpi ) ;\n if ( ( cpi -> svc . number_temporal_layers > 1 && cpi -> oxcf . rc_mode == VPX_CBR ) || ( ( cpi -> svc . number_temporal_layers > 1 || cpi -> svc . number_spatial_layers > 1 ) && cpi -> oxcf . pass == 2 ) ) {\n vp9_update_layer_context_change_config ( cpi , ( int ) cpi -> oxcf . target_bandwidth ) ;\n }\n cpi -> alt_ref_source = NULL ;\n rc -> is_src_frame_alt_ref = 0 ;\n # if 0 cpi -> frame_distortion = 0 ;\n cpi -> last_frame_distortion = 0 ;\n # endif set_tile_limits ( cpi ) ;\n cpi -> ext_refresh_frame_flags_pending = 0 ;\n cpi -> ext_refresh_frame_context_pending = 0 ;\n # if CONFIG_VP9_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity > 0 ) {\n vp9_denoiser_alloc ( & ( cpi -> denoiser ) , cm -> width , cm -> height , cm -> subsampling_x , cm -> subsampling_y , # if CONFIG_VP9_HIGHBITDEPTH cm -> use_highbitdepth , # endif VP9_ENC_BORDER_IN_PIXELS ) ;\n }\n # endif }", "idx": 1777}
{"hash": -7990991774694156606, "project": "debian", "size": 148, "label": 0, "functionSource": "static int unpack_vectors ( Vp3DecodeContext * s , GetBitContext * gb ) {\n int j , k , sb_x , sb_y ;\n int coding_mode ;\n int motion_x [ 4 ] ;\n int motion_y [ 4 ] ;\n int last_motion_x = 0 ;\n int last_motion_y = 0 ;\n int prior_last_motion_x = 0 ;\n int prior_last_motion_y = 0 ;\n int current_macroblock ;\n int current_fragment ;\n int frag ;\n if ( s -> keyframe ) return 0 ;\n coding_mode = get_bits1 ( gb ) ;\n for ( sb_y = 0 ;\n sb_y < s -> y_superblock_height ;\n sb_y ++ ) {\n for ( sb_x = 0 ;\n sb_x < s -> y_superblock_width ;\n sb_x ++ ) {\n if ( get_bits_left ( gb ) <= 0 ) return - 1 ;\n for ( j = 0 ;\n j < 4 ;\n j ++ ) {\n int mb_x = 2 * sb_x + ( j >> 1 ) ;\n int mb_y = 2 * sb_y + ( ( ( j >> 1 ) + j ) & 1 ) ;\n current_macroblock = mb_y * s -> macroblock_width + mb_x ;\n if ( mb_x >= s -> macroblock_width || mb_y >= s -> macroblock_height || ( s -> macroblock_coding [ current_macroblock ] == MODE_COPY ) ) continue ;\n switch ( s -> macroblock_coding [ current_macroblock ] ) {\n case MODE_INTER_PLUS_MV : case MODE_GOLDEN_MV : if ( coding_mode == 0 ) {\n motion_x [ 0 ] = motion_vector_table [ get_vlc2 ( gb , s -> motion_vector_vlc . table , 6 , 2 ) ] ;\n motion_y [ 0 ] = motion_vector_table [ get_vlc2 ( gb , s -> motion_vector_vlc . table , 6 , 2 ) ] ;\n }\n else {\n motion_x [ 0 ] = fixed_motion_vector_table [ get_bits ( gb , 6 ) ] ;\n motion_y [ 0 ] = fixed_motion_vector_table [ get_bits ( gb , 6 ) ] ;\n }\n if ( s -> macroblock_coding [ current_macroblock ] == MODE_INTER_PLUS_MV ) {\n prior_last_motion_x = last_motion_x ;\n prior_last_motion_y = last_motion_y ;\n last_motion_x = motion_x [ 0 ] ;\n last_motion_y = motion_y [ 0 ] ;\n }\n break ;\n case MODE_INTER_FOURMV : prior_last_motion_x = last_motion_x ;\n prior_last_motion_y = last_motion_y ;\n for ( k = 0 ;\n k < 4 ;\n k ++ ) {\n current_fragment = BLOCK_Y * s -> fragment_width [ 0 ] + BLOCK_X ;\n if ( s -> all_fragments [ current_fragment ] . coding_method != MODE_COPY ) {\n if ( coding_mode == 0 ) {\n motion_x [ k ] = motion_vector_table [ get_vlc2 ( gb , s -> motion_vector_vlc . table , 6 , 2 ) ] ;\n motion_y [ k ] = motion_vector_table [ get_vlc2 ( gb , s -> motion_vector_vlc . table , 6 , 2 ) ] ;\n }\n else {\n motion_x [ k ] = fixed_motion_vector_table [ get_bits ( gb , 6 ) ] ;\n motion_y [ k ] = fixed_motion_vector_table [ get_bits ( gb , 6 ) ] ;\n }\n last_motion_x = motion_x [ k ] ;\n last_motion_y = motion_y [ k ] ;\n }\n else {\n motion_x [ k ] = 0 ;\n motion_y [ k ] = 0 ;\n }\n }\n break ;\n case MODE_INTER_LAST_MV : motion_x [ 0 ] = last_motion_x ;\n motion_y [ 0 ] = last_motion_y ;\n break ;\n case MODE_INTER_PRIOR_LAST : motion_x [ 0 ] = prior_last_motion_x ;\n motion_y [ 0 ] = prior_last_motion_y ;\n prior_last_motion_x = last_motion_x ;\n prior_last_motion_y = last_motion_y ;\n last_motion_x = motion_x [ 0 ] ;\n last_motion_y = motion_y [ 0 ] ;\n break ;\n default : motion_x [ 0 ] = 0 ;\n motion_y [ 0 ] = 0 ;\n break ;\n }\n for ( k = 0 ;\n k < 4 ;\n k ++ ) {\n current_fragment = BLOCK_Y * s -> fragment_width [ 0 ] + BLOCK_X ;\n if ( s -> macroblock_coding [ current_macroblock ] == MODE_INTER_FOURMV ) {\n s -> motion_val [ 0 ] [ current_fragment ] [ 0 ] = motion_x [ k ] ;\n s -> motion_val [ 0 ] [ current_fragment ] [ 1 ] = motion_y [ k ] ;\n }\n else {\n s -> motion_val [ 0 ] [ current_fragment ] [ 0 ] = motion_x [ 0 ] ;\n s -> motion_val [ 0 ] [ current_fragment ] [ 1 ] = motion_y [ 0 ] ;\n }\n }\n if ( s -> chroma_y_shift ) {\n if ( s -> macroblock_coding [ current_macroblock ] == MODE_INTER_FOURMV ) {\n motion_x [ 0 ] = RSHIFT ( motion_x [ 0 ] + motion_x [ 1 ] + motion_x [ 2 ] + motion_x [ 3 ] , 2 ) ;\n motion_y [ 0 ] = RSHIFT ( motion_y [ 0 ] + motion_y [ 1 ] + motion_y [ 2 ] + motion_y [ 3 ] , 2 ) ;\n }\n motion_x [ 0 ] = ( motion_x [ 0 ] >> 1 ) | ( motion_x [ 0 ] & 1 ) ;\n motion_y [ 0 ] = ( motion_y [ 0 ] >> 1 ) | ( motion_y [ 0 ] & 1 ) ;\n frag = mb_y * s -> fragment_width [ 1 ] + mb_x ;\n s -> motion_val [ 1 ] [ frag ] [ 0 ] = motion_x [ 0 ] ;\n s -> motion_val [ 1 ] [ frag ] [ 1 ] = motion_y [ 0 ] ;\n }\n else if ( s -> chroma_x_shift ) {\n if ( s -> macroblock_coding [ current_macroblock ] == MODE_INTER_FOURMV ) {\n motion_x [ 0 ] = RSHIFT ( motion_x [ 0 ] + motion_x [ 1 ] , 1 ) ;\n motion_y [ 0 ] = RSHIFT ( motion_y [ 0 ] + motion_y [ 1 ] , 1 ) ;\n motion_x [ 1 ] = RSHIFT ( motion_x [ 2 ] + motion_x [ 3 ] , 1 ) ;\n motion_y [ 1 ] = RSHIFT ( motion_y [ 2 ] + motion_y [ 3 ] , 1 ) ;\n }\n else {\n motion_x [ 1 ] = motion_x [ 0 ] ;\n motion_y [ 1 ] = motion_y [ 0 ] ;\n }\n motion_x [ 0 ] = ( motion_x [ 0 ] >> 1 ) | ( motion_x [ 0 ] & 1 ) ;\n motion_x [ 1 ] = ( motion_x [ 1 ] >> 1 ) | ( motion_x [ 1 ] & 1 ) ;\n frag = 2 * mb_y * s -> fragment_width [ 1 ] + mb_x ;\n for ( k = 0 ;\n k < 2 ;\n k ++ ) {\n s -> motion_val [ 1 ] [ frag ] [ 0 ] = motion_x [ k ] ;\n s -> motion_val [ 1 ] [ frag ] [ 1 ] = motion_y [ k ] ;\n frag += s -> fragment_width [ 1 ] ;\n }\n }\n else {\n for ( k = 0 ;\n k < 4 ;\n k ++ ) {\n frag = BLOCK_Y * s -> fragment_width [ 1 ] + BLOCK_X ;\n if ( s -> macroblock_coding [ current_macroblock ] == MODE_INTER_FOURMV ) {\n s -> motion_val [ 1 ] [ frag ] [ 0 ] = motion_x [ k ] ;\n s -> motion_val [ 1 ] [ frag ] [ 1 ] = motion_y [ k ] ;\n }\n else {\n s -> motion_val [ 1 ] [ frag ] [ 0 ] = motion_x [ 0 ] ;\n s -> motion_val [ 1 ] [ frag ] [ 1 ] = motion_y [ 0 ] ;\n }\n }\n }\n }\n }\n }\n return 0 ;\n }", "idx": 1778}
{"hash": -6068976579504840746, "project": "debian", "size": 14, "label": 0, "functionSource": "static void read_ifstats ( struct recvbuf * rbufp ) {\n u_int ifidx ;\n endpt * la ;\n for ( ifidx = 0 ;\n ifidx < sys_ifnum ;\n ifidx ++ ) {\n for ( la = ep_list ;\n la != NULL ;\n la = la -> elink ) if ( ifidx == la -> ifnum ) break ;\n if ( NULL == la ) continue ;\n send_ifstats_entry ( la , ifidx ) ;\n }\n ctl_flushpkt ( 0 ) ;\n }", "idx": 1779}
{"hash": -275948070528829821, "project": "debian", "size": 283, "label": 0, "functionSource": "static char * CreateHtmlSubtitle ( int * pi_align , char * psz_subtitle ) {\n char * psz_tag = malloc ( 1 ) ;\n if ( psz_tag == NULL ) return NULL ;\n char * psz_html = malloc ( 1 ) ;\n if ( psz_html == NULL ) {\n free ( psz_tag ) ;\n return NULL ;\n }\n psz_tag [ 0 ] = '\\0' ;\n psz_html [ 0 ] = '\\0' ;\n bool b_has_align = false ;\n HtmlPut ( & psz_html , \"<text>\" ) ;\n while ( * psz_subtitle ) {\n if ( * psz_subtitle == '\\n' ) {\n HtmlPut ( & psz_html , \"<br/>\" ) ;\n psz_subtitle ++ ;\n }\n else if ( * psz_subtitle == '<' ) {\n if ( ! strncasecmp ( psz_subtitle , \"<br/>\" , 5 ) ) {\n HtmlCopy ( & psz_html , & psz_subtitle , \"<br/>\" ) ;\n }\n else if ( ! strncasecmp ( psz_subtitle , \"<b>\" , 3 ) ) {\n HtmlCopy ( & psz_html , & psz_subtitle , \"<b>\" ) ;\n HtmlPut ( & psz_tag , \"b\" ) ;\n }\n else if ( ! strncasecmp ( psz_subtitle , \"<i>\" , 3 ) ) {\n HtmlCopy ( & psz_html , & psz_subtitle , \"<i>\" ) ;\n HtmlPut ( & psz_tag , \"i\" ) ;\n }\n else if ( ! strncasecmp ( psz_subtitle , \"<u>\" , 3 ) ) {\n HtmlCopy ( & psz_html , & psz_subtitle , \"<u>\" ) ;\n HtmlPut ( & psz_tag , \"u\" ) ;\n }\n else if ( ! strncasecmp ( psz_subtitle , \"<s>\" , 3 ) ) {\n HtmlCopy ( & psz_html , & psz_subtitle , \"<s>\" ) ;\n HtmlPut ( & psz_tag , \"s\" ) ;\n }\n else if ( ! strncasecmp ( psz_subtitle , \"<font \" , 6 ) ) {\n const char * psz_attribs [ ] = {\n \"face=\" , \"family=\" , \"size=\" , \"color=\" , \"outline-color=\" , \"shadow-color=\" , \"outline-level=\" , \"shadow-level=\" , \"back-color=\" , \"alpha=\" , NULL }\n ;\n HtmlCopy ( & psz_html , & psz_subtitle , \"<font \" ) ;\n HtmlPut ( & psz_tag , \"f\" ) ;\n while ( * psz_subtitle != '>' && * psz_subtitle ) {\n int k ;\n while ( * psz_subtitle == ' ' ) psz_subtitle ++ ;\n for ( k = 0 ;\n psz_attribs [ k ] ;\n k ++ ) {\n int i_len = strlen ( psz_attribs [ k ] ) ;\n if ( ! strncasecmp ( psz_subtitle , psz_attribs [ k ] , i_len ) ) {\n HtmlPut ( & psz_html , psz_attribs [ k ] ) ;\n psz_subtitle += i_len ;\n while ( * psz_subtitle == ' ' ) psz_subtitle ++ ;\n if ( * psz_subtitle == '\"' ) {\n psz_subtitle ++ ;\n i_len = strcspn ( psz_subtitle , \"\\\"\" ) ;\n }\n else if ( * psz_subtitle == '\\'' ) {\n psz_subtitle ++ ;\n i_len = strcspn ( psz_subtitle , \"'\" ) ;\n }\n else {\n i_len = strcspn ( psz_subtitle , \" \\t>\" ) ;\n }\n HtmlPut ( & psz_html , \"\\\"\" ) ;\n HtmlNPut ( & psz_html , psz_subtitle , i_len ) ;\n HtmlPut ( & psz_html , \"\\\"\" ) ;\n psz_subtitle += i_len ;\n if ( * psz_subtitle == '\\\"' || * psz_subtitle == '\\'' ) psz_subtitle ++ ;\n break ;\n }\n }\n if ( psz_attribs [ k ] == NULL ) {\n int i_len = strcspn ( psz_subtitle , \"\\\"\" ) ;\n if ( psz_subtitle [ i_len ] == '\\\"' ) {\n i_len += 1 + strcspn ( & psz_subtitle [ i_len + 1 ] , \"\\\"\" ) ;\n if ( psz_subtitle [ i_len ] == '\\\"' ) i_len ++ ;\n }\n if ( i_len == 0 && * psz_subtitle != '\\0' ) psz_subtitle ++ ;\n psz_subtitle += i_len ;\n }\n HtmlNPut ( & psz_html , psz_subtitle , strspn ( psz_subtitle , \" \" ) ) ;\n }\n HtmlPut ( & psz_html , \">\" ) ;\n if ( * psz_subtitle == '\\0' ) break ;\n psz_subtitle ++ ;\n }\n else if ( ! strncmp ( psz_subtitle , \"</\" , 2 ) ) {\n bool b_match = false ;\n bool b_ignore = false ;\n int i_len = ( psz_tag ? strlen ( psz_tag ) : 0 ) - 1 ;\n char * psz_lastTag = NULL ;\n if ( i_len >= 0 ) {\n psz_lastTag = psz_tag + i_len ;\n i_len = 0 ;\n switch ( * psz_lastTag ) {\n case 'b' : b_match = ! strncasecmp ( psz_subtitle , \"</b>\" , 4 ) ;\n i_len = 4 ;\n break ;\n case 'i' : b_match = ! strncasecmp ( psz_subtitle , \"</i>\" , 4 ) ;\n i_len = 4 ;\n break ;\n case 'u' : b_match = ! strncasecmp ( psz_subtitle , \"</u>\" , 4 ) ;\n i_len = 4 ;\n break ;\n case 's' : b_match = ! strncasecmp ( psz_subtitle , \"</s>\" , 4 ) ;\n i_len = 4 ;\n break ;\n case 'f' : b_match = ! strncasecmp ( psz_subtitle , \"</font>\" , 7 ) ;\n i_len = 7 ;\n break ;\n case 'I' : i_len = strcspn ( psz_subtitle , \">\" ) ;\n b_match = psz_subtitle [ i_len ] == '>' ;\n b_ignore = true ;\n if ( b_match ) i_len ++ ;\n break ;\n }\n }\n if ( ! b_match ) {\n free ( psz_html ) ;\n psz_html = NULL ;\n break ;\n }\n * psz_lastTag = '\\0' ;\n if ( ! b_ignore ) HtmlNPut ( & psz_html , psz_subtitle , i_len ) ;\n psz_subtitle += i_len ;\n }\n else if ( ( psz_subtitle [ 1 ] < 'a' || psz_subtitle [ 1 ] > 'z' ) && ( psz_subtitle [ 1 ] < 'A' || psz_subtitle [ 1 ] > 'Z' ) ) {\n HtmlPut ( & psz_html , \"&lt;\n\" ) ;\n psz_subtitle ++ ;\n }\n else {\n char * psz_stop = psz_subtitle + 1 + strcspn ( & psz_subtitle [ 1 ] , \"<>\" ) ;\n char * psz_closing = strstr ( psz_subtitle , \"/>\" ) ;\n if ( psz_closing && psz_closing < psz_stop ) {\n psz_subtitle = & psz_closing [ 2 ] ;\n }\n else if ( * psz_stop == '>' ) {\n char psz_match [ 256 ] ;\n snprintf ( psz_match , sizeof ( psz_match ) , \"</%s\" , & psz_subtitle [ 1 ] ) ;\n psz_match [ strcspn ( psz_match , \" \\t>\" ) ] = '\\0' ;\n if ( strstr ( psz_subtitle , psz_match ) ) {\n psz_subtitle = & psz_stop [ 1 ] ;\n HtmlPut ( & psz_tag , \"I\" ) ;\n }\n else {\n int i_len = psz_stop + 1 - psz_subtitle ;\n for ( ;\n i_len > 0 ;\n i_len -- , psz_subtitle ++ ) {\n if ( * psz_subtitle == '<' ) HtmlPut ( & psz_html , \"&lt;\n\" ) ;\n else if ( * psz_subtitle == '>' ) HtmlPut ( & psz_html , \"&gt;\n\" ) ;\n else HtmlNPut ( & psz_html , psz_subtitle , 1 ) ;\n }\n }\n }\n else {\n HtmlPut ( & psz_html , \"&lt;\n\" ) ;\n psz_subtitle ++ ;\n }\n }\n }\n else if ( * psz_subtitle == '&' ) {\n if ( ! strncasecmp ( psz_subtitle , \"&lt;\n\" , 4 ) ) {\n HtmlCopy ( & psz_html , & psz_subtitle , \"&lt;\n\" ) ;\n }\n else if ( ! strncasecmp ( psz_subtitle , \"&gt;\n\" , 4 ) ) {\n HtmlCopy ( & psz_html , & psz_subtitle , \"&gt;\n\" ) ;\n }\n else if ( ! strncasecmp ( psz_subtitle , \"&amp;\n\" , 5 ) ) {\n HtmlCopy ( & psz_html , & psz_subtitle , \"&amp;\n\" ) ;\n }\n else {\n HtmlPut ( & psz_html , \"&amp;\n\" ) ;\n psz_subtitle ++ ;\n }\n }\n else if ( * psz_subtitle == '>' ) {\n HtmlPut ( & psz_html , \"&gt;\n\" ) ;\n psz_subtitle ++ ;\n }\n else if ( psz_subtitle [ 0 ] == '{\n' && psz_subtitle [ 1 ] == '\\\\' && strchr ( psz_subtitle , '}\n' ) ) {\n if ( ! b_has_align && ! strncmp ( psz_subtitle , \"{\n\\\\an\" , 4 ) && psz_subtitle [ 4 ] >= '1' && psz_subtitle [ 4 ] <= '9' && psz_subtitle [ 5 ] == '}\n' ) {\n static const int pi_vertical [ 3 ] = {\n SUBPICTURE_ALIGN_BOTTOM , 0 , SUBPICTURE_ALIGN_TOP }\n ;\n static const int pi_horizontal [ 3 ] = {\n SUBPICTURE_ALIGN_LEFT , 0 , SUBPICTURE_ALIGN_RIGHT }\n ;\n const int i_id = psz_subtitle [ 4 ] - '1' ;\n b_has_align = true ;\n * pi_align = pi_vertical [ i_id / 3 ] | pi_horizontal [ i_id % 3 ] ;\n }\n psz_subtitle = strchr ( psz_subtitle , '}\n' ) + 1 ;\n }\n else if ( psz_subtitle [ 0 ] == '{\n' && ( psz_subtitle [ 1 ] == 'Y' || psz_subtitle [ 1 ] == 'y' ) && psz_subtitle [ 2 ] == ':' && strchr ( psz_subtitle , '}\n' ) ) {\n if ( psz_subtitle [ 3 ] == 'i' ) {\n HtmlPut ( & psz_html , \"<i>\" ) ;\n HtmlPut ( & psz_tag , \"i\" ) ;\n }\n if ( psz_subtitle [ 3 ] == 'b' ) {\n HtmlPut ( & psz_html , \"<b>\" ) ;\n HtmlPut ( & psz_tag , \"b\" ) ;\n }\n if ( psz_subtitle [ 3 ] == 'u' ) {\n HtmlPut ( & psz_html , \"<u>\" ) ;\n HtmlPut ( & psz_tag , \"u\" ) ;\n }\n psz_subtitle = strchr ( psz_subtitle , '}\n' ) + 1 ;\n }\n else if ( psz_subtitle [ 0 ] == '{\n' && psz_subtitle [ 1 ] != '\\0' && psz_subtitle [ 2 ] == ':' && strchr ( psz_subtitle , '}\n' ) ) {\n psz_subtitle = strchr ( psz_subtitle , '}\n' ) + 1 ;\n }\n else if ( psz_subtitle [ 0 ] == '\\\\' && psz_subtitle [ 1 ] ) {\n if ( psz_subtitle [ 1 ] == 'N' || psz_subtitle [ 1 ] == 'n' ) {\n HtmlPut ( & psz_html , \"<br/>\" ) ;\n psz_subtitle += 2 ;\n }\n else if ( psz_subtitle [ 1 ] == 'h' ) {\n HtmlPut ( & psz_html , NO_BREAKING_SPACE ) ;\n psz_subtitle += 2 ;\n }\n else {\n HtmlPut ( & psz_html , \"\\\\\" ) ;\n psz_subtitle ++ ;\n }\n }\n else {\n HtmlNPut ( & psz_html , psz_subtitle , 1 ) ;\n # if 0 if ( * psz_html ) {\n # error This test does not make sense . if ( ( * psz_html == ' ' || * psz_html == '\\t' ) && ( * ( psz_html - 1 ) == ' ' || * ( psz_html - 1 ) == '\\t' ) ) {\n HtmlPut ( & psz_html , NO_BREAKING_SPACE ) ;\n psz_html -- ;\n }\n }\n # endif psz_subtitle ++ ;\n }\n }\n while ( psz_tag && * psz_tag ) {\n char * psz_last = & psz_tag [ strlen ( psz_tag ) - 1 ] ;\n switch ( * psz_last ) {\n case 'b' : HtmlPut ( & psz_html , \"</b>\" ) ;\n break ;\n case 'i' : HtmlPut ( & psz_html , \"</i>\" ) ;\n break ;\n case 'u' : HtmlPut ( & psz_html , \"</u>\" ) ;\n break ;\n case 's' : HtmlPut ( & psz_html , \"</s>\" ) ;\n break ;\n case 'f' : HtmlPut ( & psz_html , \"</font>\" ) ;\n break ;\n case 'I' : break ;\n }\n * psz_last = '\\0' ;\n }\n HtmlPut ( & psz_html , \"</text>\" ) ;\n free ( psz_tag ) ;\n return psz_html ;\n }", "idx": 1780}
{"hash": 1750726979859153417, "project": "debian", "size": 13, "label": 0, "functionSource": "static PyObject * authGSSServerInit ( PyObject * self , PyObject * args ) {\n const char * service = NULL ;\n gss_server_state * state ;\n PyObject * pystate ;\n int result = 0 ;\n if ( ! PyArg_ParseTuple ( args , \"s\" , & service ) ) return NULL ;\n state = ( gss_server_state * ) malloc ( sizeof ( gss_server_state ) ) ;\n # if PY_MAJOR_VERSION >= 3 pystate = PyCapsule_New ( state , NULL , NULL ) ;\n # else pystate = PyCObject_FromVoidPtr ( state , NULL ) ;\n # endif result = authenticate_gss_server_init ( service , state ) ;\n if ( result == AUTH_GSS_ERROR ) return NULL ;\n return Py_BuildValue ( \"(iO)\" , result , pystate ) ;\n }", "idx": 1781}
{"hash": -2943582541244387919, "project": "chrome", "size": 48, "label": 0, "functionSource": "unsigned int vp9_variance ## W ## x ## H ## _c ( const uint8_t * a , int a_stride , const uint8_t * b , int b_stride , unsigned int * sse ) {\n int sum ;\n variance ( a , a_stride , b , b_stride , W , H , sse , & sum ) ;\n return * sse - ( ( ( int64_t ) sum * sum ) / ( W * H ) ) ;\n \\ }\n # define SUBPIX_VAR ( W , H ) unsigned int vp9_sub_pixel_variance ## W ## x ## H ## _c ( const uint8_t * src , int src_stride , int xoffset , int yoffset , const uint8_t * dst , int dst_stride , unsigned int * sse ) {\n uint16_t fdata3 [ ( H + 1 ) * W ] ;\n uint8_t temp2 [ H * W ] ;\n var_filter_block2d_bil_first_pass ( src , fdata3 , src_stride , 1 , H + 1 , W , BILINEAR_FILTERS_2TAP ( xoffset ) ) ;\n var_filter_block2d_bil_second_pass ( fdata3 , temp2 , W , W , H , W , BILINEAR_FILTERS_2TAP ( yoffset ) ) ;\n return vp9_variance ## W ## x ## H ## _c ( temp2 , W , dst , dst_stride , sse ) ;\n \\ }\n # define SUBPIX_AVG_VAR ( W , H ) unsigned int vp9_sub_pixel_avg_variance ## W ## x ## H ## _c ( const uint8_t * src , int src_stride , int xoffset , int yoffset , const uint8_t * dst , int dst_stride , unsigned int * sse , const uint8_t * second_pred ) {\n uint16_t fdata3 [ ( H + 1 ) * W ] ;\n uint8_t temp2 [ H * W ] ;\n DECLARE_ALIGNED_ARRAY ( 16 , uint8_t , temp3 , H * W ) ;\n var_filter_block2d_bil_first_pass ( src , fdata3 , src_stride , 1 , H + 1 , W , BILINEAR_FILTERS_2TAP ( xoffset ) ) ;\n var_filter_block2d_bil_second_pass ( fdata3 , temp2 , W , W , H , W , BILINEAR_FILTERS_2TAP ( yoffset ) ) ;\n vp9_comp_avg_pred ( temp3 , second_pred , W , H , temp2 , W ) ;\n return vp9_variance ## W ## x ## H ## _c ( temp3 , W , dst , dst_stride , sse ) ;\n \\ }\n void vp9_get16x16var_c ( const uint8_t * src_ptr , int source_stride , const uint8_t * ref_ptr , int ref_stride , unsigned int * sse , int * sum ) {\n variance ( src_ptr , source_stride , ref_ptr , ref_stride , 16 , 16 , sse , sum ) ;\n }\n void vp9_get8x8var_c ( const uint8_t * src_ptr , int source_stride , const uint8_t * ref_ptr , int ref_stride , unsigned int * sse , int * sum ) {\n variance ( src_ptr , source_stride , ref_ptr , ref_stride , 8 , 8 , sse , sum ) ;\n }\n unsigned int vp9_mse16x16_c ( const uint8_t * src , int src_stride , const uint8_t * ref , int ref_stride , unsigned int * sse ) {\n int sum ;\n variance ( src , src_stride , ref , ref_stride , 16 , 16 , sse , & sum ) ;\n return * sse ;\n }\n unsigned int vp9_mse16x8_c ( const uint8_t * src , int src_stride , const uint8_t * ref , int ref_stride , unsigned int * sse ) {\n int sum ;\n variance ( src , src_stride , ref , ref_stride , 16 , 8 , sse , & sum ) ;\n return * sse ;\n }\n unsigned int vp9_mse8x16_c ( const uint8_t * src , int src_stride , const uint8_t * ref , int ref_stride , unsigned int * sse ) {\n int sum ;\n variance ( src , src_stride , ref , ref_stride , 8 , 16 , sse , & sum ) ;\n return * sse ;\n }\n unsigned int vp9_mse8x8_c ( const uint8_t * src , int src_stride , const uint8_t * ref , int ref_stride , unsigned int * sse ) {\n int sum ;\n variance ( src , src_stride , ref , ref_stride , 8 , 8 , sse , & sum ) ;\n return * sse ;\n }\n VAR ( 4 , 4 ) SUBPIX_VAR ( 4 , 4 ) SUBPIX_AVG_VAR ( 4 , 4 ) VAR ( 4 , 8 ) SUBPIX_VAR ( 4 , 8 ) SUBPIX_AVG_VAR ( 4 , 8 ) VAR ( 8 , 4 ) SUBPIX_VAR ( 8 , 4 ) SUBPIX_AVG_VAR ( 8 , 4 ) VAR ( 8 , 8 ) SUBPIX_VAR ( 8 , 8 ) SUBPIX_AVG_VAR ( 8 , 8 ) VAR ( 8 , 16 ) SUBPIX_VAR ( 8 , 16 ) SUBPIX_AVG_VAR ( 8 , 16 ) VAR ( 16 , 8 ) SUBPIX_VAR ( 16 , 8 ) SUBPIX_AVG_VAR ( 16 , 8 ) VAR ( 16 , 16 ) SUBPIX_VAR ( 16 , 16 ) SUBPIX_AVG_VAR ( 16 , 16 ) VAR ( 16 , 32 ) SUBPIX_VAR ( 16 , 32 ) SUBPIX_AVG_VAR ( 16 , 32 ) VAR ( 32 , 16 ) SUBPIX_VAR ( 32 , 16 ) SUBPIX_AVG_VAR ( 32 , 16 ) VAR ( 32 , 32 ) SUBPIX_VAR ( 32 , 32 ) SUBPIX_AVG_VAR ( 32 , 32 ) VAR ( 32 , 64 )", "idx": 1782}
{"hash": 6249489553242542670, "project": "debian", "size": 74, "label": 1, "functionSource": "static void config_monitor ( config_tree * ptree ) {\n int_node * pfilegen_token ;\n const char * filegen_string ;\n const char * filegen_file ;\n FILEGEN * filegen ;\n filegen_node * my_node ;\n attr_val * my_opts ;\n int filegen_type ;\n int filegen_flag ;\n if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ;\n pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ;\n for ( ;\n pfilegen_token != NULL ;\n pfilegen_token = pfilegen_token -> link ) {\n filegen_string = keyword ( pfilegen_token -> i ) ;\n filegen = filegen_get ( filegen_string ) ;\n DPRINTF ( 4 , ( \"enabling filegen for %s statistics '%s%s'\\n\" , filegen_string , filegen -> prefix , filegen -> basename ) ) ;\n filegen -> flag |= FGEN_FLAG_ENABLED ;\n }\n my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ;\n for ( ;\n my_node != NULL ;\n my_node = my_node -> link ) {\n filegen_file = keyword ( my_node -> filegen_token ) ;\n filegen = filegen_get ( filegen_file ) ;\n filegen_flag = filegen -> flag ;\n filegen_type = filegen -> type ;\n filegen_flag |= FGEN_FLAG_ENABLED ;\n my_opts = HEAD_PFIFO ( my_node -> options ) ;\n for ( ;\n my_opts != NULL ;\n my_opts = my_opts -> link ) {\n switch ( my_opts -> attr ) {\n case T_File : filegen_file = my_opts -> value . s ;\n break ;\n case T_Type : switch ( my_opts -> value . i ) {\n default : NTP_INSIST ( 0 ) ;\n break ;\n case T_None : filegen_type = FILEGEN_NONE ;\n break ;\n case T_Pid : filegen_type = FILEGEN_PID ;\n break ;\n case T_Day : filegen_type = FILEGEN_DAY ;\n break ;\n case T_Week : filegen_type = FILEGEN_WEEK ;\n break ;\n case T_Month : filegen_type = FILEGEN_MONTH ;\n break ;\n case T_Year : filegen_type = FILEGEN_YEAR ;\n break ;\n case T_Age : filegen_type = FILEGEN_AGE ;\n break ;\n }\n break ;\n case T_Flag : switch ( my_opts -> value . i ) {\n case T_Link : filegen_flag |= FGEN_FLAG_LINK ;\n break ;\n case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ;\n break ;\n case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ;\n break ;\n case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ;\n break ;\n default : msyslog ( LOG_ERR , \"Unknown filegen flag token %d\" , my_opts -> value . i ) ;\n exit ( 1 ) ;\n }\n break ;\n default : msyslog ( LOG_ERR , \"Unknown filegen option token %d\" , my_opts -> attr ) ;\n exit ( 1 ) ;\n }\n }\n filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ;\n }\n }", "idx": 1783}
{"hash": 7863876744031385021, "project": "debian", "size": 98, "label": 0, "functionSource": "static int fts_build_mail_real ( struct fts_backend_update_context * update_ctx , struct mail * mail ) {\n struct fts_mail_build_context ctx ;\n struct istream * input ;\n struct message_parser_ctx * parser ;\n struct message_decoder_context * decoder ;\n struct message_block raw_block , block ;\n struct message_part * prev_part , * parts ;\n bool skip_body = FALSE , body_part = FALSE , body_added = FALSE ;\n bool binary_body ;\n const char * error ;\n int ret ;\n if ( mail_get_stream_because ( mail , NULL , NULL , \"fts indexing\" , & input ) < 0 ) {\n if ( mail -> expunged ) return 0 ;\n i_error ( \"Failed to read mailbox %s mail UID=%u stream: %s\" , mailbox_get_vname ( mail -> box ) , mail -> uid , mailbox_get_last_internal_error ( mail -> box , NULL ) ) ;\n return - 1 ;\n }\n i_zero ( & ctx ) ;\n ctx . update_ctx = update_ctx ;\n ctx . mail = mail ;\n if ( ( update_ctx -> backend -> flags & FTS_BACKEND_FLAG_TOKENIZED_INPUT ) != 0 ) ctx . pending_input = buffer_create_dynamic ( default_pool , 128 ) ;\n prev_part = NULL ;\n parser = message_parser_init ( pool_datastack_create ( ) , input , MESSAGE_HEADER_PARSER_FLAG_CLEAN_ONELINE , 0 ) ;\n decoder = message_decoder_init ( update_ctx -> normalizer , 0 ) ;\n for ( ;\n ;\n ) {\n ret = message_parser_parse_next_block ( parser , & raw_block ) ;\n i_assert ( ret != 0 ) ;\n if ( ret < 0 ) {\n if ( input -> stream_errno == 0 ) ret = 0 ;\n else {\n i_error ( \"read(%s) failed: %s\" , i_stream_get_name ( input ) , i_stream_get_error ( input ) ) ;\n }\n break ;\n }\n if ( raw_block . part != prev_part ) {\n if ( ctx . body_parser != NULL ) {\n if ( fts_body_parser_finish ( & ctx ) < 0 ) {\n ret = - 1 ;\n break ;\n }\n }\n message_decoder_set_return_binary ( decoder , FALSE ) ;\n fts_backend_update_unset_build_key ( update_ctx ) ;\n prev_part = raw_block . part ;\n i_free_and_null ( ctx . content_type ) ;\n i_free_and_null ( ctx . content_disposition ) ;\n if ( raw_block . size != 0 ) {\n skip_body = TRUE ;\n }\n }\n if ( raw_block . hdr != NULL ) {\n }\n else if ( raw_block . size == 0 ) {\n skip_body = ! fts_build_body_begin ( & ctx , raw_block . part , & binary_body ) ;\n if ( binary_body ) message_decoder_set_return_binary ( decoder , TRUE ) ;\n body_part = TRUE ;\n }\n else {\n if ( skip_body ) continue ;\n }\n if ( ! message_decoder_decode_next_block ( decoder , & raw_block , & block ) ) continue ;\n if ( block . hdr != NULL ) {\n fts_parse_mail_header ( & ctx , & raw_block ) ;\n if ( fts_build_mail_header ( & ctx , & block ) < 0 ) {\n ret = - 1 ;\n break ;\n }\n }\n else if ( block . size == 0 ) {\n }\n else {\n i_assert ( body_part ) ;\n if ( ctx . body_parser != NULL ) fts_parser_more ( ctx . body_parser , & block ) ;\n if ( fts_build_body_block ( & ctx , & block , FALSE ) < 0 ) {\n ret = - 1 ;\n break ;\n }\n body_added = TRUE ;\n }\n }\n if ( ctx . body_parser != NULL ) {\n if ( ret == 0 ) ret = fts_body_parser_finish ( & ctx ) ;\n else ( void ) fts_parser_deinit ( & ctx . body_parser ) ;\n }\n if ( ret == 0 && body_part && ! skip_body && ! body_added ) {\n block . data = NULL ;\n block . size = 0 ;\n ret = fts_build_body_block ( & ctx , & block , TRUE ) ;\n }\n if ( message_parser_deinit_from_parts ( & parser , & parts , & error ) < 0 ) index_mail_set_message_parts_corrupted ( mail , error ) ;\n message_decoder_deinit ( & decoder ) ;\n i_free ( ctx . content_type ) ;\n i_free ( ctx . content_disposition ) ;\n if ( ctx . word_buf != NULL ) buffer_free ( & ctx . word_buf ) ;\n if ( ctx . pending_input != NULL ) buffer_free ( & ctx . pending_input ) ;\n return ret < 0 ? - 1 : 1 ;\n }", "idx": 1784}
{"hash": -8575765905118000367, "project": "debian", "size": 123, "label": 0, "functionSource": "static int _ar_read_header ( struct archive_read * a , struct archive_entry * entry , struct ar * ar , const char * h , size_t * unconsumed ) {\n char filename [ AR_name_size + 1 ] ;\n uint64_t number ;\n size_t bsd_name_length , entry_size ;\n char * p , * st ;\n const void * b ;\n int r ;\n if ( strncmp ( h + AR_fmag_offset , \"`\\n\" , 2 ) != 0 ) {\n archive_set_error ( & a -> archive , EINVAL , \"Incorrect file header signature\" ) ;\n return ( ARCHIVE_FATAL ) ;\n }\n strncpy ( filename , h + AR_name_offset , AR_name_size ) ;\n filename [ AR_name_size ] = '\\0' ;\n if ( a -> archive . archive_format == ARCHIVE_FORMAT_AR ) {\n if ( strncmp ( filename , \"#1/\" , 3 ) == 0 ) a -> archive . archive_format = ARCHIVE_FORMAT_AR_BSD ;\n else if ( strchr ( filename , '/' ) != NULL ) a -> archive . archive_format = ARCHIVE_FORMAT_AR_GNU ;\n else if ( strncmp ( filename , \"__.SYMDEF\" , 9 ) == 0 ) a -> archive . archive_format = ARCHIVE_FORMAT_AR_BSD ;\n }\n if ( a -> archive . archive_format == ARCHIVE_FORMAT_AR_GNU ) a -> archive . archive_format_name = \"ar (GNU/SVR4)\" ;\n else if ( a -> archive . archive_format == ARCHIVE_FORMAT_AR_BSD ) a -> archive . archive_format_name = \"ar (BSD)\" ;\n else a -> archive . archive_format_name = \"ar\" ;\n p = filename + AR_name_size - 1 ;\n while ( p >= filename && * p == ' ' ) {\n * p = '\\0' ;\n p -- ;\n }\n if ( filename [ 0 ] != '/' && p > filename && * p == '/' ) {\n * p = '\\0' ;\n }\n if ( p < filename ) {\n archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , \"Found entry with empty filename\" ) ;\n return ( ARCHIVE_FATAL ) ;\n }\n if ( strcmp ( filename , \"//\" ) == 0 ) {\n ar_parse_common_header ( ar , entry , h ) ;\n archive_entry_copy_pathname ( entry , filename ) ;\n archive_entry_set_filetype ( entry , AE_IFREG ) ;\n number = ar_atol10 ( h + AR_size_offset , AR_size_size ) ;\n if ( number > SIZE_MAX ) {\n archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , \"Filename table too large\" ) ;\n return ( ARCHIVE_FATAL ) ;\n }\n entry_size = ( size_t ) number ;\n if ( entry_size == 0 ) {\n archive_set_error ( & a -> archive , EINVAL , \"Invalid string table\" ) ;\n return ( ARCHIVE_FATAL ) ;\n }\n if ( ar -> strtab != NULL ) {\n archive_set_error ( & a -> archive , EINVAL , \"More than one string tables exist\" ) ;\n return ( ARCHIVE_FATAL ) ;\n }\n st = malloc ( entry_size ) ;\n if ( st == NULL ) {\n archive_set_error ( & a -> archive , ENOMEM , \"Can't allocate filename table buffer\" ) ;\n return ( ARCHIVE_FATAL ) ;\n }\n ar -> strtab = st ;\n ar -> strtab_size = entry_size ;\n if ( * unconsumed ) {\n __archive_read_consume ( a , * unconsumed ) ;\n * unconsumed = 0 ;\n }\n if ( ( b = __archive_read_ahead ( a , entry_size , NULL ) ) == NULL ) return ( ARCHIVE_FATAL ) ;\n memcpy ( st , b , entry_size ) ;\n __archive_read_consume ( a , entry_size ) ;\n ar -> entry_bytes_remaining = 0 ;\n archive_entry_set_size ( entry , ar -> entry_bytes_remaining ) ;\n return ( ar_parse_gnu_filename_table ( a ) ) ;\n }\n if ( filename [ 0 ] == '/' && filename [ 1 ] >= '0' && filename [ 1 ] <= '9' ) {\n number = ar_atol10 ( h + AR_name_offset + 1 , AR_name_size - 1 ) ;\n if ( ar -> strtab == NULL || number > ar -> strtab_size ) {\n archive_set_error ( & a -> archive , EINVAL , \"Can't find long filename for GNU/SVR4 archive entry\" ) ;\n archive_entry_copy_pathname ( entry , filename ) ;\n ar_parse_common_header ( ar , entry , h ) ;\n return ( ARCHIVE_FATAL ) ;\n }\n archive_entry_copy_pathname ( entry , & ar -> strtab [ ( size_t ) number ] ) ;\n return ( ar_parse_common_header ( ar , entry , h ) ) ;\n }\n if ( strncmp ( filename , \"#1/\" , 3 ) == 0 ) {\n ar_parse_common_header ( ar , entry , h ) ;\n number = ar_atol10 ( h + AR_name_offset + 3 , AR_name_size - 3 ) ;\n bsd_name_length = ( size_t ) number ;\n if ( number > ( uint64_t ) ( bsd_name_length + 1 ) || ( int64_t ) bsd_name_length > ar -> entry_bytes_remaining ) {\n archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , \"Bad input file size\" ) ;\n return ( ARCHIVE_FATAL ) ;\n }\n ar -> entry_bytes_remaining -= bsd_name_length ;\n archive_entry_set_size ( entry , ar -> entry_bytes_remaining ) ;\n if ( * unconsumed ) {\n __archive_read_consume ( a , * unconsumed ) ;\n * unconsumed = 0 ;\n }\n if ( ( b = __archive_read_ahead ( a , bsd_name_length , NULL ) ) == NULL ) {\n archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , \"Truncated input file\" ) ;\n return ( ARCHIVE_FATAL ) ;\n }\n p = ( char * ) malloc ( bsd_name_length + 1 ) ;\n if ( p == NULL ) {\n archive_set_error ( & a -> archive , ENOMEM , \"Can't allocate fname buffer\" ) ;\n return ( ARCHIVE_FATAL ) ;\n }\n strncpy ( p , b , bsd_name_length ) ;\n p [ bsd_name_length ] = '\\0' ;\n __archive_read_consume ( a , bsd_name_length ) ;\n archive_entry_copy_pathname ( entry , p ) ;\n free ( p ) ;\n return ( ARCHIVE_OK ) ;\n }\n if ( strcmp ( filename , \"/\" ) == 0 ) {\n archive_entry_copy_pathname ( entry , \"/\" ) ;\n r = ar_parse_common_header ( ar , entry , h ) ;\n archive_entry_set_filetype ( entry , AE_IFREG ) ;\n return ( r ) ;\n }\n if ( strcmp ( filename , \"__.SYMDEF\" ) == 0 ) {\n archive_entry_copy_pathname ( entry , filename ) ;\n return ( ar_parse_common_header ( ar , entry , h ) ) ;\n }\n archive_entry_copy_pathname ( entry , filename ) ;\n return ( ar_parse_common_header ( ar , entry , h ) ) ;\n }", "idx": 1785}
{"hash": 4959950795017352813, "project": "debian", "size": 22, "label": 0, "functionSource": "WRITE_CLASS_ENCODER ( CephXServerChallenge ) struct CephXRequestHeader {\n __u16 request_type ;\n void encode ( bufferlist & bl ) const {\n : : encode ( request_type , bl ) ;\n }\n void decode ( bufferlist : : iterator & bl ) {\n : : decode ( request_type , bl ) ;\n }\n }\n ;\n WRITE_CLASS_ENCODER ( CephXRequestHeader ) struct CephXResponseHeader {\n uint16_t request_type ;\n int32_t status ;\n void encode ( bufferlist & bl ) const {\n : : encode ( request_type , bl ) ;\n : : encode ( status , bl ) ;\n }\n void decode ( bufferlist : : iterator & bl ) {\n : : decode ( request_type , bl ) ;\n : : decode ( status , bl ) ;\n }\n }", "idx": 1786}
{"hash": -6579823731174944595, "project": "debian", "size": 6, "label": 0, "functionSource": "void * checked_xcalloc ( size_t num , size_t size ) {\n size_t res ;\n if ( check_mul_overflow ( num , size , & res ) ) abort ( ) ;\n alloc_limit_assert ( \"checked_xcalloc\" , ( res ) ) ;\n return xcalloc ( num , size ) ;\n }", "idx": 1787}
{"hash": 3426991998365732450, "project": "debian", "size": 15, "label": 0, "functionSource": "static void ps2_mouse_reset ( void * opaque ) {\n PS2MouseState * s = ( PS2MouseState * ) opaque ;\n trace_ps2_mouse_reset ( opaque ) ;\n ps2_common_reset ( & s -> common ) ;\n s -> mouse_status = 0 ;\n s -> mouse_resolution = 0 ;\n s -> mouse_sample_rate = 0 ;\n s -> mouse_wrap = 0 ;\n s -> mouse_type = 0 ;\n s -> mouse_detect_state = 0 ;\n s -> mouse_dx = 0 ;\n s -> mouse_dy = 0 ;\n s -> mouse_dz = 0 ;\n s -> mouse_buttons = 0 ;\n }", "idx": 1788}
{"hash": -5420171864670538459, "project": "debian", "size": 16, "label": 0, "functionSource": "static void qemu_kvm_init_cpu_signals ( CPUState * cpu ) {\n int r ;\n sigset_t set ;\n struct sigaction sigact ;\n memset ( & sigact , 0 , sizeof ( sigact ) ) ;\n sigact . sa_handler = dummy_signal ;\n sigaction ( SIG_IPI , & sigact , NULL ) ;\n pthread_sigmask ( SIG_BLOCK , NULL , & set ) ;\n sigdelset ( & set , SIG_IPI ) ;\n sigdelset ( & set , SIGBUS ) ;\n r = kvm_set_signal_mask ( cpu , & set ) ;\n if ( r ) {\n fprintf ( stderr , \"kvm_set_signal_mask: %s\\n\" , strerror ( - r ) ) ;\n exit ( 1 ) ;\n }\n }", "idx": 1789}
{"hash": -8416645554750795024, "project": "debian", "size": 155, "label": 0, "functionSource": "int ImagingFliDecode ( Imaging im , ImagingCodecState state , UINT8 * buf , int bytes ) {\n UINT8 * ptr ;\n int framesize ;\n int c , chunks ;\n int l , lines ;\n int i , j , x = 0 , y , ymax ;\n if ( bytes < 4 ) return 0 ;\n ptr = buf ;\n framesize = I32 ( ptr ) ;\n if ( framesize < I32 ( ptr ) ) return 0 ;\n if ( I16 ( ptr + 4 ) != 0xF1FA ) {\n state -> errcode = IMAGING_CODEC_UNKNOWN ;\n return - 1 ;\n }\n chunks = I16 ( ptr + 6 ) ;\n ptr += 16 ;\n for ( c = 0 ;\n c < chunks ;\n c ++ ) {\n UINT8 * data = ptr + 6 ;\n switch ( I16 ( ptr + 4 ) ) {\n case 4 : case 11 : break ;\n case 7 : lines = I16 ( data ) ;\n data += 2 ;\n for ( l = y = 0 ;\n l < lines && y < state -> ysize ;\n l ++ , y ++ ) {\n UINT8 * buf = ( UINT8 * ) im -> image [ y ] ;\n int p , packets ;\n packets = I16 ( data ) ;\n data += 2 ;\n while ( packets & 0x8000 ) {\n if ( packets & 0x4000 ) {\n y += 65536 - packets ;\n if ( y >= state -> ysize ) {\n state -> errcode = IMAGING_CODEC_OVERRUN ;\n return - 1 ;\n }\n buf = ( UINT8 * ) im -> image [ y ] ;\n }\n else {\n buf [ state -> xsize - 1 ] = ( UINT8 ) packets ;\n }\n packets = I16 ( data ) ;\n data += 2 ;\n }\n for ( p = x = 0 ;\n p < packets ;\n p ++ ) {\n x += data [ 0 ] ;\n if ( data [ 1 ] >= 128 ) {\n i = 256 - data [ 1 ] ;\n if ( x + i + i > state -> xsize ) break ;\n for ( j = 0 ;\n j < i ;\n j ++ ) {\n buf [ x ++ ] = data [ 2 ] ;\n buf [ x ++ ] = data [ 3 ] ;\n }\n data += 2 + 2 ;\n }\n else {\n i = 2 * ( int ) data [ 1 ] ;\n if ( x + i > state -> xsize ) break ;\n memcpy ( buf + x , data + 2 , i ) ;\n data += 2 + i ;\n x += i ;\n }\n }\n if ( p < packets ) break ;\n }\n if ( l < lines ) {\n state -> errcode = IMAGING_CODEC_OVERRUN ;\n return - 1 ;\n }\n break ;\n case 12 : y = I16 ( data ) ;\n ymax = y + I16 ( data + 2 ) ;\n data += 4 ;\n for ( ;\n y < ymax && y < state -> ysize ;\n y ++ ) {\n UINT8 * out = ( UINT8 * ) im -> image [ y ] ;\n int p , packets = * data ++ ;\n for ( p = x = 0 ;\n p < packets ;\n p ++ , x += i ) {\n x += data [ 0 ] ;\n if ( data [ 1 ] & 0x80 ) {\n i = 256 - data [ 1 ] ;\n if ( x + i > state -> xsize ) break ;\n memset ( out + x , data [ 2 ] , i ) ;\n data += 3 ;\n }\n else {\n i = data [ 1 ] ;\n if ( x + i > state -> xsize ) break ;\n memcpy ( out + x , data + 2 , i ) ;\n data += i + 2 ;\n }\n }\n if ( p < packets ) break ;\n }\n if ( y < ymax ) {\n state -> errcode = IMAGING_CODEC_OVERRUN ;\n return - 1 ;\n }\n break ;\n case 13 : for ( y = 0 ;\n y < state -> ysize ;\n y ++ ) memset ( im -> image [ y ] , 0 , state -> xsize ) ;\n break ;\n case 15 : for ( y = 0 ;\n y < state -> ysize ;\n y ++ ) {\n UINT8 * out = ( UINT8 * ) im -> image [ y ] ;\n data += 1 ;\n for ( x = 0 ;\n x < state -> xsize ;\n x += i ) {\n if ( data [ 0 ] & 0x80 ) {\n i = 256 - data [ 0 ] ;\n if ( x + i > state -> xsize ) break ;\n memcpy ( out + x , data + 1 , i ) ;\n data += i + 1 ;\n }\n else {\n i = data [ 0 ] ;\n if ( x + i > state -> xsize ) break ;\n memset ( out + x , data [ 1 ] , i ) ;\n data += 2 ;\n }\n }\n if ( x != state -> xsize ) {\n state -> errcode = IMAGING_CODEC_OVERRUN ;\n return - 1 ;\n }\n }\n break ;\n case 16 : for ( y = 0 ;\n y < state -> ysize ;\n y ++ ) {\n UINT8 * buf = ( UINT8 * ) im -> image [ y ] ;\n memcpy ( buf , data , state -> xsize ) ;\n data += state -> xsize ;\n }\n break ;\n case 18 : break ;\n default : state -> errcode = IMAGING_CODEC_UNKNOWN ;\n return - 1 ;\n }\n ptr += I32 ( ptr ) ;\n }\n return - 1 ;\n }", "idx": 1790}
{"hash": 2636502839178711655, "project": "debian", "size": 71, "label": 0, "functionSource": "static void dissect_coap_opt_object_security ( tvbuff_t * tvb , proto_item * head_item , proto_tree * subtree , gint offset , gint opt_length , packet_info * pinfo , coap_info * coinfo , coap_common_dissect_t * dissect_hf ) {\n guint8 flag_byte = 0 ;\n gboolean non_compressed = FALSE ;\n gboolean expand = FALSE ;\n gboolean signature_present = FALSE ;\n gboolean kid_context_present = FALSE ;\n gboolean kid_present = FALSE ;\n guint8 piv_len = 0 ;\n guint8 kid_context_len = 0 ;\n guint8 kid_len = 0 ;\n coinfo -> object_security = TRUE ;\n coinfo -> oscore_info -> piv = NULL ;\n coinfo -> oscore_info -> piv_len = 0 ;\n coinfo -> oscore_info -> kid_context = NULL ;\n coinfo -> oscore_info -> kid_context_len = 0 ;\n coinfo -> oscore_info -> kid = NULL ;\n coinfo -> oscore_info -> kid_len = 0 ;\n if ( opt_length == 0 ) {\n proto_item_append_text ( head_item , \": 00 (no Flag Byte)\" ) ;\n }\n else {\n flag_byte = tvb_get_guint8 ( tvb , offset ) ;\n proto_tree_add_item ( subtree , dissect_hf -> hf . opt_object_security_non_compressed , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n non_compressed = flag_byte & COAP_OBJECT_SECURITY_NON_COMPRESSED_MASK ;\n proto_tree_add_item ( subtree , dissect_hf -> hf . opt_object_security_expand , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n expand = flag_byte & COAP_OBJECT_SECURITY_EXPAND_MASK ;\n proto_tree_add_item ( subtree , dissect_hf -> hf . opt_object_security_signature , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n signature_present = flag_byte & COAP_OBJECT_SECURITY_SIGNATURE_MASK ;\n proto_tree_add_item ( subtree , dissect_hf -> hf . opt_object_security_kid_context_present , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n kid_context_present = flag_byte & COAP_OBJECT_SECURITY_KID_CONTEXT_MASK ;\n proto_tree_add_item ( subtree , dissect_hf -> hf . opt_object_security_kid_present , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n kid_present = flag_byte & COAP_OBJECT_SECURITY_KID_MASK ;\n proto_tree_add_item ( subtree , dissect_hf -> hf . opt_object_security_piv_len , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n piv_len = ( flag_byte & COAP_OBJECT_SECURITY_PIVLEN_MASK ) >> 0 ;\n kid_len = opt_length ;\n offset += 1 ;\n kid_len -= 1 ;\n if ( non_compressed || expand || signature_present ) {\n expert_add_info_format ( pinfo , subtree , & dissect_hf -> ei . opt_object_security_bad , \"Unsupported format\" ) ;\n }\n if ( piv_len > 0 ) {\n proto_tree_add_item ( subtree , dissect_hf -> hf . opt_object_security_piv , tvb , offset , piv_len , ENC_NA ) ;\n coinfo -> oscore_info -> piv = ( guint8 * ) tvb_memdup ( wmem_packet_scope ( ) , tvb , offset , piv_len ) ;\n coinfo -> oscore_info -> piv_len = piv_len ;\n offset += piv_len ;\n kid_len -= piv_len ;\n }\n if ( kid_context_present ) {\n proto_tree_add_item ( subtree , dissect_hf -> hf . opt_object_security_kid_context_len , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n kid_context_len = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n kid_len -= 1 ;\n proto_tree_add_item ( subtree , dissect_hf -> hf . opt_object_security_kid_context , tvb , offset , kid_context_len , ENC_NA ) ;\n coinfo -> oscore_info -> kid_context = ( guint8 * ) tvb_memdup ( wmem_packet_scope ( ) , tvb , offset , kid_context_len ) ;\n coinfo -> oscore_info -> kid_context_len = kid_context_len ;\n offset += kid_context_len ;\n kid_len -= kid_context_len ;\n }\n if ( kid_present ) {\n if ( kid_len > 0 ) {\n proto_tree_add_item ( subtree , dissect_hf -> hf . opt_object_security_kid , tvb , offset , kid_len , ENC_NA ) ;\n coinfo -> oscore_info -> kid = ( guint8 * ) tvb_memdup ( wmem_packet_scope ( ) , tvb , offset , kid_len ) ;\n coinfo -> oscore_info -> kid_len = kid_len ;\n }\n else {\n expert_add_info_format ( pinfo , subtree , & dissect_hf -> ei . opt_object_security_bad , \"Key ID flag is set but there are no remaining bytes to be processed\" ) ;\n }\n }\n proto_item_append_text ( head_item , \": Key ID:%s, Key ID Context:%s, Partial IV:%s\" , coinfo -> oscore_info -> kid == NULL ? nullstr : bytes_to_str ( wmem_packet_scope ( ) , coinfo -> oscore_info -> kid , coinfo -> oscore_info -> kid_len ) , coinfo -> oscore_info -> kid_context == NULL ? nullstr : bytes_to_str ( wmem_packet_scope ( ) , coinfo -> oscore_info -> kid_context , coinfo -> oscore_info -> kid_context_len ) , coinfo -> oscore_info -> piv == NULL ? nullstr : bytes_to_str ( wmem_packet_scope ( ) , coinfo -> oscore_info -> piv , coinfo -> oscore_info -> piv_len ) ) ;\n }\n }", "idx": 1791}
{"hash": 5347874611477979643, "project": "chrome", "size": 3, "label": 0, "functionSource": "static void wm_writecb ( struct bufferevent * bev , void * arg ) {\n if ( EVBUFFER_LENGTH ( bev -> output ) == 0 ) test_ok ++ ;\n }", "idx": 1792}
{"hash": -5706788925640467782, "project": "chrome", "size": 273, "label": 0, "functionSource": "static void rd_pick_partition ( VP9_COMP * cpi , const TileInfo * const tile , TOKENEXTRA * * tp , int mi_row , int mi_col , BLOCK_SIZE bsize , int * rate , int64_t * dist , int64_t best_rd , PC_TREE * pc_tree ) {\n VP9_COMMON * const cm = & cpi -> common ;\n MACROBLOCK * const x = & cpi -> mb ;\n MACROBLOCKD * const xd = & x -> e_mbd ;\n const int mi_step = num_8x8_blocks_wide_lookup [ bsize ] / 2 ;\n ENTROPY_CONTEXT l [ 16 * MAX_MB_PLANE ] , a [ 16 * MAX_MB_PLANE ] ;\n PARTITION_CONTEXT sl [ 8 ] , sa [ 8 ] ;\n TOKENEXTRA * tp_orig = * tp ;\n PICK_MODE_CONTEXT * ctx = & pc_tree -> none ;\n int i , pl ;\n BLOCK_SIZE subsize ;\n int this_rate , sum_rate = 0 , best_rate = INT_MAX ;\n int64_t this_dist , sum_dist = 0 , best_dist = INT64_MAX ;\n int64_t sum_rd = 0 ;\n int do_split = bsize >= BLOCK_8X8 ;\n int do_rect = 1 ;\n const int force_horz_split = ( mi_row + mi_step >= cm -> mi_rows ) ;\n const int force_vert_split = ( mi_col + mi_step >= cm -> mi_cols ) ;\n const int xss = x -> e_mbd . plane [ 1 ] . subsampling_x ;\n const int yss = x -> e_mbd . plane [ 1 ] . subsampling_y ;\n BLOCK_SIZE min_size = cpi -> sf . min_partition_size ;\n BLOCK_SIZE max_size = cpi -> sf . max_partition_size ;\n # if CONFIG_FP_MB_STATS unsigned int src_diff_var = UINT_MAX ;\n int none_complexity = 0 ;\n # endif int partition_none_allowed = ! force_horz_split && ! force_vert_split ;\n int partition_horz_allowed = ! force_vert_split && yss <= xss && bsize >= BLOCK_8X8 ;\n int partition_vert_allowed = ! force_horz_split && xss <= yss && bsize >= BLOCK_8X8 ;\n ( void ) * tp_orig ;\n assert ( num_8x8_blocks_wide_lookup [ bsize ] == num_8x8_blocks_high_lookup [ bsize ] ) ;\n set_offsets ( cpi , tile , mi_row , mi_col , bsize ) ;\n if ( bsize == BLOCK_16X16 && cpi -> oxcf . aq_mode ) x -> mb_energy = vp9_block_energy ( cpi , x , bsize ) ;\n if ( cpi -> sf . cb_partition_search && bsize == BLOCK_16X16 ) {\n int cb_partition_search_ctrl = ( ( pc_tree -> index == 0 || pc_tree -> index == 3 ) + get_chessboard_index ( cm -> current_video_frame ) ) & 0x1 ;\n if ( cb_partition_search_ctrl && bsize > min_size && bsize < max_size ) set_partition_range ( cm , xd , mi_row , mi_col , bsize , & min_size , & max_size ) ;\n }\n if ( cpi -> sf . auto_min_max_partition_size ) {\n partition_none_allowed &= ( bsize <= max_size && bsize >= min_size ) ;\n partition_horz_allowed &= ( ( bsize <= max_size && bsize > min_size ) || force_horz_split ) ;\n partition_vert_allowed &= ( ( bsize <= max_size && bsize > min_size ) || force_vert_split ) ;\n do_split &= bsize > min_size ;\n }\n if ( cpi -> sf . use_square_partition_only ) {\n partition_horz_allowed &= force_horz_split ;\n partition_vert_allowed &= force_vert_split ;\n }\n save_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ;\n # if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats ) {\n set_offsets ( cpi , tile , mi_row , mi_col , bsize ) ;\n src_diff_var = get_sby_perpixel_diff_variance ( cpi , & cpi -> mb . plane [ 0 ] . src , mi_row , mi_col , bsize ) ;\n }\n # endif # if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats && bsize >= BLOCK_32X32 && do_split && partition_none_allowed && src_diff_var > 4 && cm -> base_qindex < qindex_split_threshold_lookup [ bsize ] ) {\n int mb_row = mi_row >> 1 ;\n int mb_col = mi_col >> 1 ;\n int mb_row_end = MIN ( mb_row + num_16x16_blocks_high_lookup [ bsize ] , cm -> mb_rows ) ;\n int mb_col_end = MIN ( mb_col + num_16x16_blocks_wide_lookup [ bsize ] , cm -> mb_cols ) ;\n int r , c ;\n for ( r = mb_row ;\n r < mb_row_end ;\n r ++ ) {\n for ( c = mb_col ;\n c < mb_col_end ;\n c ++ ) {\n const int mb_index = r * cm -> mb_cols + c ;\n MOTION_DIRECTION this_mv ;\n MOTION_DIRECTION right_mv ;\n MOTION_DIRECTION bottom_mv ;\n this_mv = get_motion_direction_fp ( cpi -> twopass . this_frame_mb_stats [ mb_index ] ) ;\n if ( c != mb_col_end - 1 ) {\n right_mv = get_motion_direction_fp ( cpi -> twopass . this_frame_mb_stats [ mb_index + 1 ] ) ;\n none_complexity += get_motion_inconsistency ( this_mv , right_mv ) ;\n }\n if ( r != mb_row_end - 1 ) {\n bottom_mv = get_motion_direction_fp ( cpi -> twopass . this_frame_mb_stats [ mb_index + cm -> mb_cols ] ) ;\n none_complexity += get_motion_inconsistency ( this_mv , bottom_mv ) ;\n }\n }\n }\n if ( none_complexity > complexity_16x16_blocks_threshold [ bsize ] ) {\n partition_none_allowed = 0 ;\n }\n }\n # endif if ( partition_none_allowed ) {\n rd_pick_sb_modes ( cpi , tile , mi_row , mi_col , & this_rate , & this_dist , bsize , ctx , best_rd , 0 ) ;\n if ( this_rate != INT_MAX ) {\n if ( bsize >= BLOCK_8X8 ) {\n pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ;\n this_rate += cpi -> partition_cost [ pl ] [ PARTITION_NONE ] ;\n }\n sum_rd = RDCOST ( x -> rdmult , x -> rddiv , this_rate , this_dist ) ;\n if ( sum_rd < best_rd ) {\n int64_t dist_breakout_thr = cpi -> sf . partition_search_breakout_dist_thr ;\n int rate_breakout_thr = cpi -> sf . partition_search_breakout_rate_thr ;\n best_rate = this_rate ;\n best_dist = this_dist ;\n best_rd = sum_rd ;\n if ( bsize >= BLOCK_8X8 ) pc_tree -> partitioning = PARTITION_NONE ;\n dist_breakout_thr >>= 8 - ( b_width_log2 ( bsize ) + b_height_log2 ( bsize ) ) ;\n if ( ! x -> e_mbd . lossless && ( ctx -> skippable && best_dist < dist_breakout_thr && best_rate < rate_breakout_thr ) ) {\n do_split = 0 ;\n do_rect = 0 ;\n }\n # if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats && do_split != 0 && cm -> base_qindex > qindex_skip_threshold_lookup [ bsize ] ) {\n int mb_row = mi_row >> 1 ;\n int mb_col = mi_col >> 1 ;\n int mb_row_end = MIN ( mb_row + num_16x16_blocks_high_lookup [ bsize ] , cm -> mb_rows ) ;\n int mb_col_end = MIN ( mb_col + num_16x16_blocks_wide_lookup [ bsize ] , cm -> mb_cols ) ;\n int r , c ;\n int skip = 1 ;\n for ( r = mb_row ;\n r < mb_row_end ;\n r ++ ) {\n for ( c = mb_col ;\n c < mb_col_end ;\n c ++ ) {\n const int mb_index = r * cm -> mb_cols + c ;\n if ( ! ( cpi -> twopass . this_frame_mb_stats [ mb_index ] & FPMB_MOTION_ZERO_MASK ) || ! ( cpi -> twopass . this_frame_mb_stats [ mb_index ] & FPMB_ERROR_SMALL_MASK ) ) {\n skip = 0 ;\n break ;\n }\n }\n if ( skip == 0 ) {\n break ;\n }\n }\n if ( skip ) {\n if ( src_diff_var == UINT_MAX ) {\n set_offsets ( cpi , tile , mi_row , mi_col , bsize ) ;\n src_diff_var = get_sby_perpixel_diff_variance ( cpi , & cpi -> mb . plane [ 0 ] . src , mi_row , mi_col , bsize ) ;\n }\n if ( src_diff_var < 8 ) {\n do_split = 0 ;\n do_rect = 0 ;\n }\n }\n }\n # endif }\n }\n restore_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ;\n }\n if ( cpi -> sf . adaptive_motion_search ) store_pred_mv ( x , ctx ) ;\n sum_rd = 0 ;\n if ( do_split ) {\n subsize = get_subsize ( bsize , PARTITION_SPLIT ) ;\n if ( bsize == BLOCK_8X8 ) {\n i = 4 ;\n if ( cpi -> sf . adaptive_pred_interp_filter && partition_none_allowed ) pc_tree -> leaf_split [ 0 ] -> pred_interp_filter = ctx -> mic . mbmi . interp_filter ;\n rd_pick_sb_modes ( cpi , tile , mi_row , mi_col , & sum_rate , & sum_dist , subsize , pc_tree -> leaf_split [ 0 ] , best_rd , 0 ) ;\n if ( sum_rate == INT_MAX ) sum_rd = INT64_MAX ;\n else sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ;\n }\n else {\n for ( i = 0 ;\n i < 4 && sum_rd < best_rd ;\n ++ i ) {\n const int x_idx = ( i & 1 ) * mi_step ;\n const int y_idx = ( i >> 1 ) * mi_step ;\n if ( mi_row + y_idx >= cm -> mi_rows || mi_col + x_idx >= cm -> mi_cols ) continue ;\n if ( cpi -> sf . adaptive_motion_search ) load_pred_mv ( x , ctx ) ;\n pc_tree -> split [ i ] -> index = i ;\n rd_pick_partition ( cpi , tile , tp , mi_row + y_idx , mi_col + x_idx , subsize , & this_rate , & this_dist , best_rd - sum_rd , pc_tree -> split [ i ] ) ;\n if ( this_rate == INT_MAX ) {\n sum_rd = INT64_MAX ;\n }\n else {\n sum_rate += this_rate ;\n sum_dist += this_dist ;\n sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ;\n }\n }\n }\n if ( sum_rd < best_rd && i == 4 ) {\n pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ;\n sum_rate += cpi -> partition_cost [ pl ] [ PARTITION_SPLIT ] ;\n sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ;\n if ( sum_rd < best_rd ) {\n best_rate = sum_rate ;\n best_dist = sum_dist ;\n best_rd = sum_rd ;\n pc_tree -> partitioning = PARTITION_SPLIT ;\n }\n }\n else {\n if ( cpi -> sf . less_rectangular_check ) do_rect &= ! partition_none_allowed ;\n }\n restore_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ;\n }\n if ( partition_horz_allowed && do_rect ) {\n subsize = get_subsize ( bsize , PARTITION_HORZ ) ;\n if ( cpi -> sf . adaptive_motion_search ) load_pred_mv ( x , ctx ) ;\n if ( cpi -> sf . adaptive_pred_interp_filter && bsize == BLOCK_8X8 && partition_none_allowed ) pc_tree -> horizontal [ 0 ] . pred_interp_filter = ctx -> mic . mbmi . interp_filter ;\n rd_pick_sb_modes ( cpi , tile , mi_row , mi_col , & sum_rate , & sum_dist , subsize , & pc_tree -> horizontal [ 0 ] , best_rd , 0 ) ;\n sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ;\n if ( sum_rd < best_rd && mi_row + mi_step < cm -> mi_rows ) {\n PICK_MODE_CONTEXT * ctx = & pc_tree -> horizontal [ 0 ] ;\n update_state ( cpi , ctx , mi_row , mi_col , subsize , 0 ) ;\n encode_superblock ( cpi , tp , 0 , mi_row , mi_col , subsize , ctx ) ;\n if ( cpi -> sf . adaptive_motion_search ) load_pred_mv ( x , ctx ) ;\n if ( cpi -> sf . adaptive_pred_interp_filter && bsize == BLOCK_8X8 && partition_none_allowed ) pc_tree -> horizontal [ 1 ] . pred_interp_filter = ctx -> mic . mbmi . interp_filter ;\n rd_pick_sb_modes ( cpi , tile , mi_row + mi_step , mi_col , & this_rate , & this_dist , subsize , & pc_tree -> horizontal [ 1 ] , best_rd - sum_rd , 1 ) ;\n if ( this_rate == INT_MAX ) {\n sum_rd = INT64_MAX ;\n }\n else {\n sum_rate += this_rate ;\n sum_dist += this_dist ;\n sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ;\n }\n }\n if ( sum_rd < best_rd ) {\n pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ;\n sum_rate += cpi -> partition_cost [ pl ] [ PARTITION_HORZ ] ;\n sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ;\n if ( sum_rd < best_rd ) {\n best_rd = sum_rd ;\n best_rate = sum_rate ;\n best_dist = sum_dist ;\n pc_tree -> partitioning = PARTITION_HORZ ;\n }\n }\n restore_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ;\n }\n if ( partition_vert_allowed && do_rect ) {\n subsize = get_subsize ( bsize , PARTITION_VERT ) ;\n if ( cpi -> sf . adaptive_motion_search ) load_pred_mv ( x , ctx ) ;\n if ( cpi -> sf . adaptive_pred_interp_filter && bsize == BLOCK_8X8 && partition_none_allowed ) pc_tree -> vertical [ 0 ] . pred_interp_filter = ctx -> mic . mbmi . interp_filter ;\n rd_pick_sb_modes ( cpi , tile , mi_row , mi_col , & sum_rate , & sum_dist , subsize , & pc_tree -> vertical [ 0 ] , best_rd , 0 ) ;\n sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ;\n if ( sum_rd < best_rd && mi_col + mi_step < cm -> mi_cols ) {\n update_state ( cpi , & pc_tree -> vertical [ 0 ] , mi_row , mi_col , subsize , 0 ) ;\n encode_superblock ( cpi , tp , 0 , mi_row , mi_col , subsize , & pc_tree -> vertical [ 0 ] ) ;\n if ( cpi -> sf . adaptive_motion_search ) load_pred_mv ( x , ctx ) ;\n if ( cpi -> sf . adaptive_pred_interp_filter && bsize == BLOCK_8X8 && partition_none_allowed ) pc_tree -> vertical [ 1 ] . pred_interp_filter = ctx -> mic . mbmi . interp_filter ;\n rd_pick_sb_modes ( cpi , tile , mi_row , mi_col + mi_step , & this_rate , & this_dist , subsize , & pc_tree -> vertical [ 1 ] , best_rd - sum_rd , 1 ) ;\n if ( this_rate == INT_MAX ) {\n sum_rd = INT64_MAX ;\n }\n else {\n sum_rate += this_rate ;\n sum_dist += this_dist ;\n sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ;\n }\n }\n if ( sum_rd < best_rd ) {\n pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ;\n sum_rate += cpi -> partition_cost [ pl ] [ PARTITION_VERT ] ;\n sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ;\n if ( sum_rd < best_rd ) {\n best_rate = sum_rate ;\n best_dist = sum_dist ;\n best_rd = sum_rd ;\n pc_tree -> partitioning = PARTITION_VERT ;\n }\n }\n restore_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ;\n }\n ( void ) best_rd ;\n * rate = best_rate ;\n * dist = best_dist ;\n if ( best_rate < INT_MAX && best_dist < INT64_MAX && pc_tree -> index != 3 ) {\n int output_enabled = ( bsize == BLOCK_64X64 ) ;\n if ( ( cpi -> oxcf . aq_mode == COMPLEXITY_AQ ) && cm -> seg . update_map ) vp9_select_in_frame_q_segment ( cpi , mi_row , mi_col , output_enabled , best_rate ) ;\n if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) vp9_cyclic_refresh_set_rate_and_dist_sb ( cpi -> cyclic_refresh , best_rate , best_dist ) ;\n encode_sb ( cpi , tile , tp , mi_row , mi_col , output_enabled , bsize , pc_tree ) ;\n }\n if ( bsize == BLOCK_64X64 ) {\n assert ( tp_orig < * tp ) ;\n assert ( best_rate < INT_MAX ) ;\n assert ( best_dist < INT64_MAX ) ;\n }\n else {\n assert ( tp_orig == * tp ) ;\n }\n }", "idx": 1793}
{"hash": 5357882892791796049, "project": "debian", "size": 20, "label": 0, "functionSource": "static void e1000e_on_tx_done_update_stats ( E1000ECore * core , struct NetTxPkt * tx_pkt ) {\n static const int PTCregs [ 6 ] = {\n PTC64 , PTC127 , PTC255 , PTC511 , PTC1023 , PTC1522 }\n ;\n size_t tot_len = net_tx_pkt_get_total_len ( tx_pkt ) ;\n e1000x_increase_size_stats ( core -> mac , PTCregs , tot_len ) ;\n e1000x_inc_reg_if_not_full ( core -> mac , TPT ) ;\n e1000x_grow_8reg_if_not_full ( core -> mac , TOTL , tot_len ) ;\n switch ( net_tx_pkt_get_packet_type ( tx_pkt ) ) {\n case ETH_PKT_BCAST : e1000x_inc_reg_if_not_full ( core -> mac , BPTC ) ;\n break ;\n case ETH_PKT_MCAST : e1000x_inc_reg_if_not_full ( core -> mac , MPTC ) ;\n break ;\n case ETH_PKT_UCAST : break ;\n default : g_assert_not_reached ( ) ;\n }\n core -> mac [ GPTC ] = core -> mac [ TPT ] ;\n core -> mac [ GOTCL ] = core -> mac [ TOTL ] ;\n core -> mac [ GOTCH ] = core -> mac [ TOTH ] ;\n }", "idx": 1794}
{"hash": 6323824267898511453, "project": "debian", "size": 14, "label": 0, "functionSource": "static fz_iccprofile * get_base_icc_profile ( fz_context * ctx , const fz_colorspace * cs ) {\n fz_colorspace * base ;\n fz_cal_colorspace * cal ;\n fz_iccprofile * cal_icc ;\n if ( ! cs || ! cs -> get_base ) return NULL ;\n base = cs -> get_base ( cs ) ;\n if ( base == NULL ) return NULL ;\n if ( fz_colorspace_is_icc ( ctx , base ) ) return base -> data ;\n if ( ! fz_colorspace_is_cal ( ctx , base ) ) return get_base_icc_profile ( ctx , base ) ;\n cal = base -> data ;\n cal_icc = cal -> profile ;\n if ( cal_icc && cal_icc -> cmm_handle == NULL ) fz_cmm_init_profile ( ctx , cal_icc ) ;\n return cal_icc ;\n }", "idx": 1795}
{"hash": 4180964683905830761, "project": "debian", "size": 9, "label": 0, "functionSource": "static int ipc_has_perm ( struct kern_ipc_perm * ipc_perms , u32 perms ) {\n struct ipc_security_struct * isec ;\n struct common_audit_data ad ;\n u32 sid = current_sid ( ) ;\n isec = ipc_perms -> security ;\n ad . type = LSM_AUDIT_DATA_IPC ;\n ad . u . ipc_id = ipc_perms -> key ;\n return avc_has_perm ( sid , isec -> sid , isec -> sclass , perms , & ad ) ;\n }", "idx": 1796}
{"hash": 3668456668028959955, "project": "debian", "size": 4, "label": 0, "functionSource": "static VALUE mString_included_s ( VALUE self , VALUE modul ) {\n VALUE result = rb_funcall ( modul , i_extend , 1 , mString_Extend ) ;\n return result ;\n }", "idx": 1797}
{"hash": -6216181551924087864, "project": "chrome", "size": 13, "label": 0, "functionSource": "static void arabic_fallback_shape ( const hb_ot_shape_plan_t * plan , hb_font_t * font , hb_buffer_t * buffer ) {\n const arabic_shape_plan_t * arabic_plan = ( const arabic_shape_plan_t * ) plan -> data ;\n if ( ! arabic_plan -> do_fallback ) return ;\n retry : arabic_fallback_plan_t * fallback_plan = ( arabic_fallback_plan_t * ) hb_atomic_ptr_get ( & arabic_plan -> fallback_plan ) ;\n if ( unlikely ( ! fallback_plan ) ) {\n fallback_plan = arabic_fallback_plan_create ( plan , font ) ;\n if ( unlikely ( ! hb_atomic_ptr_cmpexch ( & ( const_cast < arabic_shape_plan_t * > ( arabic_plan ) ) -> fallback_plan , NULL , fallback_plan ) ) ) {\n arabic_fallback_plan_destroy ( fallback_plan ) ;\n goto retry ;\n }\n }\n arabic_fallback_plan_shape ( fallback_plan , font , buffer ) ;\n }", "idx": 1798}
{"hash": 8127806390163862344, "project": "debian", "size": 3, "label": 0, "functionSource": "static bool is_abs_modrm ( uint8_t modrm ) {\n return ( modrm & 0xc7 ) == 0x05 ;\n }", "idx": 1799}
{"hash": 1144893748552025496, "project": "debian", "size": 19, "label": 0, "functionSource": "static void libopenjpeg_copy_to_packed8 ( AVFrame * picture , opj_image_t * image ) {\n uint8_t * img_ptr ;\n int index , x , y , c ;\n for ( y = 0 ;\n y < picture -> height ;\n y ++ ) {\n index = y * picture -> width ;\n img_ptr = picture -> data [ 0 ] + y * picture -> linesize [ 0 ] ;\n for ( x = 0 ;\n x < picture -> width ;\n x ++ , index ++ ) {\n for ( c = 0 ;\n c < image -> numcomps ;\n c ++ ) {\n * img_ptr ++ = image -> comps [ c ] . data [ index ] ;\n }\n }\n }\n }", "idx": 1800}
{"hash": 2895622461494525400, "project": "debian", "size": 35, "label": 0, "functionSource": "static void test_bug20023 ( ) {\n MYSQL con ;\n int sql_big_selects_orig = 0 ;\n char max_join_size_orig [ 32 ] ;\n int sql_big_selects_2 = 0 ;\n int sql_big_selects_3 = 0 ;\n int sql_big_selects_4 = 0 ;\n int sql_big_selects_5 = 0 ;\n char query_buffer [ MAX_TEST_QUERY_LENGTH ] ;\n DIE_UNLESS ( mysql_client_init ( & con ) ) ;\n DIE_UNLESS ( mysql_real_connect ( & con , opt_host , opt_user , opt_password , opt_db ? opt_db : \"test\" , opt_port , opt_unix_socket , CLIENT_FOUND_ROWS ) ) ;\n query_int_variable ( & con , \"@@session.sql_big_selects\" , & sql_big_selects_orig ) ;\n query_str_variable ( & con , \"@@global.max_join_size\" , max_join_size_orig , sizeof ( max_join_size_orig ) ) ;\n bug20023_change_user ( & con ) ;\n query_int_variable ( & con , \"@@session.sql_big_selects\" , & sql_big_selects_2 ) ;\n DIE_UNLESS ( sql_big_selects_orig == sql_big_selects_2 ) ;\n DIE_IF ( mysql_query ( & con , \"SET @@global.max_join_size = 10000\" ) ) ;\n DIE_IF ( mysql_query ( & con , \"SET @@session.max_join_size = default\" ) ) ;\n bug20023_change_user ( & con ) ;\n query_int_variable ( & con , \"@@session.sql_big_selects\" , & sql_big_selects_3 ) ;\n DIE_UNLESS ( sql_big_selects_3 == 0 ) ;\n DIE_IF ( mysql_query ( & con , \"SET @@global.max_join_size = cast(-1 as unsigned int)\" ) ) ;\n DIE_IF ( mysql_query ( & con , \"SET @@session.max_join_size = default\" ) ) ;\n bug20023_change_user ( & con ) ;\n query_int_variable ( & con , \"@@session.sql_big_selects\" , & sql_big_selects_4 ) ;\n DIE_UNLESS ( sql_big_selects_4 == 1 ) ;\n my_snprintf ( query_buffer , sizeof ( query_buffer ) , \"SET @@global.max_join_size = %s\" , max_join_size_orig ) ;\n DIE_IF ( mysql_query ( & con , query_buffer ) ) ;\n DIE_IF ( mysql_query ( & con , \"SET @@global.max_join_size = cast(-1 as unsigned int)\" ) ) ;\n DIE_IF ( mysql_query ( & con , \"SET @@session.max_join_size = default\" ) ) ;\n bug20023_change_user ( & con ) ;\n query_int_variable ( & con , \"@@session.sql_big_selects\" , & sql_big_selects_5 ) ;\n DIE_UNLESS ( sql_big_selects_5 == sql_big_selects_orig ) ;\n mysql_close ( & con ) ;\n }", "idx": 1801}
{"hash": 5498422609764865307, "project": "debian", "size": 3, "label": 0, "functionSource": "int archive_read_support_compression_compress ( struct archive * a ) {\n return archive_read_support_filter_compress ( a ) ;\n }", "idx": 1802}
{"hash": 7039307292471244756, "project": "debian", "size": 8, "label": 0, "functionSource": "static void dtap_gcc_term_req ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len ) {\n guint32 curr_offset ;\n guint32 consumed ;\n guint curr_len ;\n curr_offset = offset ;\n curr_len = len ;\n ELEM_MAND_V ( GSM_A_PDU_TYPE_DTAP , DE_GCC_CALL_REF , NULL ) ;\n }", "idx": 1803}
{"hash": -5262394088289559608, "project": "debian", "size": 3, "label": 0, "functionSource": "static void arm_mptimer_register_types ( void ) {\n type_register_static ( & arm_mptimer_info ) ;\n }", "idx": 1804}
{"hash": -7076754245473579218, "project": "chrome", "size": 10, "label": 0, "functionSource": "static int evhttp_is_connection_close ( int flags , struct evkeyvalq * headers ) {\n if ( flags & EVHTTP_PROXY_REQUEST ) {\n const char * connection = evhttp_find_header ( headers , \"Proxy-Connection\" ) ;\n return ( connection == NULL || strcasecmp ( connection , \"keep-alive\" ) != 0 ) ;\n }\n else {\n const char * connection = evhttp_find_header ( headers , \"Connection\" ) ;\n return ( connection != NULL && strcasecmp ( connection , \"close\" ) == 0 ) ;\n }\n }", "idx": 1805}
{"hash": -3502382902740740634, "project": "debian", "size": 250, "label": 1, "functionSource": "static void real_proto_register_diameter ( void ) {\n module_t * diameter_module ;\n expert_module_t * expert_diameter ;\n guint i , ett_length ;\n hf_register_info hf_base [ ] = {\n {\n & hf_diameter_version , {\n \"Version\" , \"diameter.version\" , FT_UINT8 , BASE_HEX , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_diameter_length , {\n \"Length\" , \"diameter.length\" , FT_UINT24 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_diameter_flags , {\n \"Flags\" , \"diameter.flags\" , FT_UINT8 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_diameter_flags_request , {\n \"Request\" , \"diameter.flags.request\" , FT_BOOLEAN , 8 , TFS ( & tfs_set_notset ) , DIAM_FLAGS_R , NULL , HFILL }\n }\n , {\n & hf_diameter_flags_proxyable , {\n \"Proxyable\" , \"diameter.flags.proxyable\" , FT_BOOLEAN , 8 , TFS ( & tfs_set_notset ) , DIAM_FLAGS_P , NULL , HFILL }\n }\n , {\n & hf_diameter_flags_error , {\n \"Error\" , \"diameter.flags.error\" , FT_BOOLEAN , 8 , TFS ( & tfs_set_notset ) , DIAM_FLAGS_E , NULL , HFILL }\n }\n , {\n & hf_diameter_flags_T , {\n \"T(Potentially re-transmitted message)\" , \"diameter.flags.T\" , FT_BOOLEAN , 8 , TFS ( & tfs_set_notset ) , DIAM_FLAGS_T , NULL , HFILL }\n }\n , {\n & hf_diameter_flags_reserved4 , {\n \"Reserved\" , \"diameter.flags.reserved4\" , FT_BOOLEAN , 8 , TFS ( & tfs_set_notset ) , DIAM_FLAGS_RESERVED4 , NULL , HFILL }\n }\n , {\n & hf_diameter_flags_reserved5 , {\n \"Reserved\" , \"diameter.flags.reserved5\" , FT_BOOLEAN , 8 , TFS ( & tfs_set_notset ) , DIAM_FLAGS_RESERVED5 , NULL , HFILL }\n }\n , {\n & hf_diameter_flags_reserved6 , {\n \"Reserved\" , \"diameter.flags.reserved6\" , FT_BOOLEAN , 8 , TFS ( & tfs_set_notset ) , DIAM_FLAGS_RESERVED6 , NULL , HFILL }\n }\n , {\n & hf_diameter_flags_reserved7 , {\n \"Reserved\" , \"diameter.flags.reserved7\" , FT_BOOLEAN , 8 , TFS ( & tfs_set_notset ) , DIAM_FLAGS_RESERVED7 , NULL , HFILL }\n }\n , {\n & hf_diameter_vendor_id , {\n \"VendorId\" , \"diameter.vendorId\" , FT_UINT32 , BASE_DEC | BASE_EXT_STRING , & sminmpec_values_ext , 0x0 , NULL , HFILL }\n }\n , {\n & hf_diameter_application_id , {\n \"ApplicationId\" , \"diameter.applicationId\" , FT_UINT32 , BASE_DEC | BASE_EXT_STRING , VALS_EXT_PTR ( dictionary . applications ) , 0x0 , NULL , HFILL }\n }\n , {\n & hf_diameter_hopbyhopid , {\n \"Hop-by-Hop Identifier\" , \"diameter.hopbyhopid\" , FT_UINT32 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_diameter_endtoendid , {\n \"End-to-End Identifier\" , \"diameter.endtoendid\" , FT_UINT32 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_diameter_avp , {\n \"AVP\" , \"diameter.avp\" , FT_BYTES , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_diameter_avp_len , {\n \"AVP Length\" , \"diameter.avp.len\" , FT_UINT24 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_diameter_avp_code , {\n \"AVP Code\" , \"diameter.avp.code\" , FT_UINT32 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_diameter_avp_flags , {\n \"AVP Flags\" , \"diameter.avp.flags\" , FT_UINT8 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_diameter_avp_flags_vendor_specific , {\n \"Vendor-Specific\" , \"diameter.flags.vendorspecific\" , FT_BOOLEAN , 8 , TFS ( & tfs_set_notset ) , AVP_FLAGS_V , NULL , HFILL }\n }\n , {\n & hf_diameter_avp_flags_mandatory , {\n \"Mandatory\" , \"diameter.flags.mandatory\" , FT_BOOLEAN , 8 , TFS ( & tfs_set_notset ) , AVP_FLAGS_M , NULL , HFILL }\n }\n , {\n & hf_diameter_avp_flags_protected , {\n \"Protected\" , \"diameter.avp.flags.protected\" , FT_BOOLEAN , 8 , TFS ( & tfs_set_notset ) , AVP_FLAGS_P , NULL , HFILL }\n }\n , {\n & hf_diameter_avp_flags_reserved3 , {\n \"Reserved\" , \"diameter.avp.flags.reserved3\" , FT_BOOLEAN , 8 , TFS ( & tfs_set_notset ) , AVP_FLAGS_RESERVED3 , NULL , HFILL }\n }\n , {\n & hf_diameter_avp_flags_reserved4 , {\n \"Reserved\" , \"diameter.avp.flags.reserved4\" , FT_BOOLEAN , 8 , TFS ( & tfs_set_notset ) , AVP_FLAGS_RESERVED4 , NULL , HFILL }\n }\n , {\n & hf_diameter_avp_flags_reserved5 , {\n \"Reserved\" , \"diameter.avp.flags.reserved5\" , FT_BOOLEAN , 8 , TFS ( & tfs_set_notset ) , AVP_FLAGS_RESERVED5 , NULL , HFILL }\n }\n , {\n & hf_diameter_avp_flags_reserved6 , {\n \"Reserved\" , \"diameter.avp.flags.reserved6\" , FT_BOOLEAN , 8 , TFS ( & tfs_set_notset ) , AVP_FLAGS_RESERVED6 , NULL , HFILL }\n }\n , {\n & hf_diameter_avp_flags_reserved7 , {\n \"Reserved\" , \"diameter.avp.flags.reserved7\" , FT_BOOLEAN , 8 , TFS ( & tfs_set_notset ) , AVP_FLAGS_RESERVED7 , NULL , HFILL }\n }\n , {\n & hf_diameter_avp_vendor_id , {\n \"AVP Vendor Id\" , \"diameter.avp.vendorId\" , FT_UINT32 , BASE_DEC | BASE_EXT_STRING , & sminmpec_values_ext , 0x0 , NULL , HFILL }\n }\n , {\n & ( unknown_avp . hf_value ) , {\n \"Value\" , \"diameter.avp.unknown\" , FT_BYTES , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_diameter_avp_data_wrong_length , {\n \"Data\" , \"diameter.avp.invalid-data\" , FT_BYTES , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_diameter_avp_pad , {\n \"Padding\" , \"diameter.avp.pad\" , FT_BYTES , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_diameter_code , {\n \"Command Code\" , \"diameter.cmd.code\" , FT_UINT32 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_diameter_answer_in , {\n \"Answer In\" , \"diameter.answer_in\" , FT_FRAMENUM , BASE_NONE , FRAMENUM_TYPE ( FT_FRAMENUM_RESPONSE ) , 0x0 , \"The answer to this diameter request is in this frame\" , HFILL }\n }\n , {\n & hf_diameter_answer_to , {\n \"Request In\" , \"diameter.answer_to\" , FT_FRAMENUM , BASE_NONE , FRAMENUM_TYPE ( FT_FRAMENUM_REQUEST ) , 0x0 , \"This is an answer to the diameter request in this frame\" , HFILL }\n }\n , {\n & hf_diameter_answer_time , {\n \"Response Time\" , \"diameter.resp_time\" , FT_RELATIVE_TIME , BASE_NONE , NULL , 0x0 , \"The time between the request and the answer\" , HFILL }\n }\n , {\n & hf_framed_ipv6_prefix_reserved , {\n \"Framed IPv6 Prefix Reserved byte\" , \"diameter.framed_ipv6_prefix_reserved\" , FT_UINT8 , BASE_HEX , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_framed_ipv6_prefix_length , {\n \"Framed IPv6 Prefix length (in bits)\" , \"diameter.framed_ipv6_prefix_length\" , FT_UINT8 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_framed_ipv6_prefix_bytes , {\n \"Framed IPv6 Prefix as a bytestring\" , \"diameter.framed_ipv6_prefix_bytes\" , FT_BYTES , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_framed_ipv6_prefix_ipv6 , {\n \"Framed IPv6 Prefix as an IPv6 address\" , \"diameter.framed_ipv6_prefix_ipv6\" , FT_IPv6 , BASE_NONE , NULL , 0 , \"This field is present only if the prefix length is 128\" , HFILL }\n }\n , {\n & hf_diameter_3gpp2_exp_res , {\n \"Experimental-Result-Code\" , \"diameter.3gpp2.exp_res\" , FT_UINT32 , BASE_DEC , VALS ( diameter_3gpp2_exp_res_vals ) , 0x0 , NULL , HFILL }\n }\n , {\n & hf_diameter_other_vendor_exp_res , {\n \"Experimental-Result-Code\" , \"diameter.other_vendor.Experimental-Result-Code\" , FT_UINT32 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n }\n ;\n gint * ett_base [ ] = {\n & ett_diameter , & ett_diameter_flags , & ett_diameter_avp_flags , & ett_diameter_avpinfo , & ett_unknown , & ett_err , & ( unknown_avp . ett ) }\n ;\n static ei_register_info ei [ ] = {\n {\n & ei_diameter_reserved_bit_set , {\n \"diameter.reserved_bit_set\" , PI_MALFORMED , PI_WARN , \"Reserved bit set\" , EXPFILL }\n }\n , {\n & ei_diameter_avp_code , {\n \"diameter.avp.code.unknown\" , PI_UNDECODED , PI_WARN , \"Unknown AVP, if you know what this is you can add it to dictionary.xml\" , EXPFILL }\n }\n , {\n & ei_diameter_avp_vendor_id , {\n \"diameter.unknown_vendor\" , PI_UNDECODED , PI_WARN , \"Unknown Vendor, if you know whose this is you can add it to dictionary.xml\" , EXPFILL }\n }\n , {\n & ei_diameter_avp_no_data , {\n \"diameter.avp.no_data\" , PI_UNDECODED , PI_WARN , \"Data is empty\" , EXPFILL }\n }\n , {\n & ei_diameter_avp_pad , {\n \"diameter.avp.pad.non_zero\" , PI_MALFORMED , PI_NOTE , \"Padding is non-zero\" , EXPFILL }\n }\n , {\n & ei_diameter_avp_len , {\n \"diameter.avp.invalid-len\" , PI_MALFORMED , PI_WARN , \"Wrong length\" , EXPFILL }\n }\n , {\n & ei_diameter_application_id , {\n \"diameter.applicationId.unknown\" , PI_UNDECODED , PI_WARN , \"Unknown Application Id, if you know what this is you can add it to dictionary.xml\" , EXPFILL }\n }\n , {\n & ei_diameter_version , {\n \"diameter.version.unknown\" , PI_UNDECODED , PI_WARN , \"Unknown Diameter Version (decoding as RFC 3588)\" , EXPFILL }\n }\n , {\n & ei_diameter_code , {\n \"diameter.cmd.code.unknown\" , PI_UNDECODED , PI_WARN , \"Unknown command, if you know what this is you can add it to dictionary.xml\" , EXPFILL }\n }\n , }\n ;\n wmem_array_append ( build_dict . hf , hf_base , array_length ( hf_base ) ) ;\n ett_length = array_length ( ett_base ) ;\n for ( i = 0 ;\n i < ett_length ;\n i ++ ) {\n g_ptr_array_add ( build_dict . ett , ett_base [ i ] ) ;\n }\n proto_diameter = proto_register_protocol ( \"Diameter Protocol\" , \"DIAMETER\" , \"diameter\" ) ;\n proto_register_field_array ( proto_diameter , ( hf_register_info * ) wmem_array_get_raw ( build_dict . hf ) , wmem_array_get_count ( build_dict . hf ) ) ;\n proto_register_subtree_array ( ( gint * * ) build_dict . ett -> pdata , build_dict . ett -> len ) ;\n expert_diameter = expert_register_protocol ( proto_diameter ) ;\n expert_register_field_array ( expert_diameter , ei , array_length ( ei ) ) ;\n g_ptr_array_free ( build_dict . ett , TRUE ) ;\n new_register_dissector ( \"diameter\" , dissect_diameter , proto_diameter ) ;\n diameter_dissector_table = register_dissector_table ( \"diameter.base\" , \"DIAMETER_BASE_AVPS\" , FT_UINT32 , BASE_DEC , DISSECTOR_TABLE_ALLOW_DUPLICATE ) ;\n diameter_3gpp_avp_dissector_table = register_dissector_table ( \"diameter.3gpp\" , \"DIAMETER_3GPP_AVPS\" , FT_UINT32 , BASE_DEC , DISSECTOR_TABLE_ALLOW_DUPLICATE ) ;\n diameter_ericsson_avp_dissector_table = register_dissector_table ( \"diameter.ericsson\" , \"DIAMETER_ERICSSON_AVPS\" , FT_UINT32 , BASE_DEC , DISSECTOR_TABLE_ALLOW_DUPLICATE ) ;\n diameter_expr_result_vnd_table = register_dissector_table ( \"diameter.vnd_exp_res\" , \"DIAMETER Experimental-Result-Code\" , FT_UINT32 , BASE_DEC , DISSECTOR_TABLE_ALLOW_DUPLICATE ) ;\n range_convert_str ( & global_diameter_tcp_port_range , DEFAULT_DIAMETER_PORT_RANGE , MAX_UDP_PORT ) ;\n range_convert_str ( & global_diameter_sctp_port_range , DEFAULT_DIAMETER_PORT_RANGE , MAX_SCTP_PORT ) ;\n range_convert_str ( & global_diameter_udp_port_range , \"\" , MAX_UDP_PORT ) ;\n diameter_module = prefs_register_protocol ( proto_diameter , proto_reg_handoff_diameter ) ;\n prefs_register_range_preference ( diameter_module , \"tcp.ports\" , \"Diameter TCP ports\" , \"TCP ports to be decoded as Diameter (default: \" DEFAULT_DIAMETER_PORT_RANGE \")\" , & global_diameter_tcp_port_range , MAX_UDP_PORT ) ;\n prefs_register_range_preference ( diameter_module , \"sctp.ports\" , \"Diameter SCTP Ports\" , \"SCTP ports to be decoded as Diameter (default: \" DEFAULT_DIAMETER_PORT_RANGE \")\" , & global_diameter_sctp_port_range , MAX_SCTP_PORT ) ;\n prefs_register_bool_preference ( diameter_module , \"desegment\" , \"Reassemble Diameter messages\\nspanning multiple TCP segments\" , \"Whether the Diameter dissector should reassemble messages spanning multiple TCP segments.\" \" To use this option, you must also enable \\\"Allow subdissectors to reassemble TCP streams\\\" in the TCP protocol settings.\" , & gbl_diameter_desegment ) ;\n prefs_register_range_preference ( diameter_module , \"udp.ports\" , \"Diameter UDP ports\" , \"UDP ports to be decoded as Diameter (default: 0 as Diameter over UDP is nonstandard)\" , & global_diameter_udp_port_range , MAX_UDP_PORT ) ;\n prefs_register_obsolete_preference ( diameter_module , \"version\" ) ;\n prefs_register_obsolete_preference ( diameter_module , \"tcp.port\" ) ;\n prefs_register_obsolete_preference ( diameter_module , \"sctp.port\" ) ;\n prefs_register_obsolete_preference ( diameter_module , \"command_in_header\" ) ;\n prefs_register_obsolete_preference ( diameter_module , \"dictionary.name\" ) ;\n prefs_register_obsolete_preference ( diameter_module , \"dictionary.use\" ) ;\n prefs_register_obsolete_preference ( diameter_module , \"allow_zero_as_app_id\" ) ;\n prefs_register_obsolete_preference ( diameter_module , \"suppress_console_output\" ) ;\n diameter_tap = register_tap ( \"diameter\" ) ;\n register_srt_table ( proto_diameter , NULL , 1 , diameterstat_packet , diameterstat_init , NULL ) ;\n }", "idx": 1806}
{"hash": 5347874611477979643, "project": "chrome", "size": 36, "label": 0, "functionSource": "static void test_priorities ( int npriorities ) {\n char buf [ 32 ] ;\n struct test_pri_event one , two ;\n struct timeval tv ;\n evutil_snprintf ( buf , sizeof ( buf ) , \"Testing Priorities %d: \" , npriorities ) ;\n setup_test ( buf ) ;\n event_base_priority_init ( global_base , npriorities ) ;\n memset ( & one , 0 , sizeof ( one ) ) ;\n memset ( & two , 0 , sizeof ( two ) ) ;\n timeout_set ( & one . ev , test_priorities_cb , & one ) ;\n if ( event_priority_set ( & one . ev , 0 ) == - 1 ) {\n fprintf ( stderr , \"%s: failed to set priority\" , __func__ ) ;\n exit ( 1 ) ;\n }\n timeout_set ( & two . ev , test_priorities_cb , & two ) ;\n if ( event_priority_set ( & two . ev , npriorities - 1 ) == - 1 ) {\n fprintf ( stderr , \"%s: failed to set priority\" , __func__ ) ;\n exit ( 1 ) ;\n }\n evutil_timerclear ( & tv ) ;\n if ( event_add ( & one . ev , & tv ) == - 1 ) exit ( 1 ) ;\n if ( event_add ( & two . ev , & tv ) == - 1 ) exit ( 1 ) ;\n event_dispatch ( ) ;\n event_del ( & one . ev ) ;\n event_del ( & two . ev ) ;\n if ( npriorities == 1 ) {\n if ( one . count == 3 && two . count == 3 ) test_ok = 1 ;\n }\n else if ( npriorities == 2 ) {\n if ( one . count == 3 && two . count == 1 ) test_ok = 1 ;\n }\n else {\n if ( one . count == 3 && two . count == 0 ) test_ok = 1 ;\n }\n cleanup_test ( ) ;\n }", "idx": 1807}
{"hash": 7324112841603622093, "project": "debian", "size": 12, "label": 0, "functionSource": "static void handle_header ( struct message_search_context * ctx , struct message_header_line * hdr ) {\n if ( hdr -> name_len == 12 && strcasecmp ( hdr -> name , \"Content-Type\" ) == 0 ) {\n if ( hdr -> continues ) {\n hdr -> use_full_value = TRUE ;\n return ;\n }\n T_BEGIN {\n parse_content_type ( ctx , hdr ) ;\n }\n T_END ;\n }\n }", "idx": 1808}
{"hash": -7855974557509681261, "project": "debian", "size": 12, "label": 0, "functionSource": "Oid get_transform_fromsql ( Oid typid , Oid langid , List * trftypes ) {\n HeapTuple tup ;\n if ( ! list_member_oid ( trftypes , typid ) ) return InvalidOid ;\n tup = SearchSysCache2 ( TRFTYPELANG , typid , langid ) ;\n if ( HeapTupleIsValid ( tup ) ) {\n Oid funcid ;\n funcid = ( ( Form_pg_transform ) GETSTRUCT ( tup ) ) -> trffromsql ;\n ReleaseSysCache ( tup ) ;\n return funcid ;\n }\n else return InvalidOid ;\n }", "idx": 1809}
{"hash": -7334302271653594926, "project": "debian", "size": 4, "label": 0, "functionSource": "bool agg_item_charsets ( DTCollation & coll , const char * fname , Item * * args , uint nargs , uint flags , int item_sep ) {\n if ( agg_item_collations ( coll , fname , args , nargs , flags , item_sep ) ) return TRUE ;\n return agg_item_set_converter ( coll , fname , args , nargs , flags , item_sep ) ;\n }", "idx": 1810}
{"hash": -2943582541244387919, "project": "chrome", "size": 36, "label": 0, "functionSource": "unsigned int vp9_sub_pixel_avg_variance ## W ## x ## H ## _c ( const uint8_t * src , int src_stride , int xoffset , int yoffset , const uint8_t * dst , int dst_stride , unsigned int * sse , const uint8_t * second_pred ) {\n uint16_t fdata3 [ ( H + 1 ) * W ] ;\n uint8_t temp2 [ H * W ] ;\n DECLARE_ALIGNED_ARRAY ( 16 , uint8_t , temp3 , H * W ) ;\n var_filter_block2d_bil_first_pass ( src , fdata3 , src_stride , 1 , H + 1 , W , BILINEAR_FILTERS_2TAP ( xoffset ) ) ;\n var_filter_block2d_bil_second_pass ( fdata3 , temp2 , W , W , H , W , BILINEAR_FILTERS_2TAP ( yoffset ) ) ;\n vp9_comp_avg_pred ( temp3 , second_pred , W , H , temp2 , W ) ;\n return vp9_variance ## W ## x ## H ## _c ( temp3 , W , dst , dst_stride , sse ) ;\n \\ }\n void vp9_get16x16var_c ( const uint8_t * src_ptr , int source_stride , const uint8_t * ref_ptr , int ref_stride , unsigned int * sse , int * sum ) {\n variance ( src_ptr , source_stride , ref_ptr , ref_stride , 16 , 16 , sse , sum ) ;\n }\n void vp9_get8x8var_c ( const uint8_t * src_ptr , int source_stride , const uint8_t * ref_ptr , int ref_stride , unsigned int * sse , int * sum ) {\n variance ( src_ptr , source_stride , ref_ptr , ref_stride , 8 , 8 , sse , sum ) ;\n }\n unsigned int vp9_mse16x16_c ( const uint8_t * src , int src_stride , const uint8_t * ref , int ref_stride , unsigned int * sse ) {\n int sum ;\n variance ( src , src_stride , ref , ref_stride , 16 , 16 , sse , & sum ) ;\n return * sse ;\n }\n unsigned int vp9_mse16x8_c ( const uint8_t * src , int src_stride , const uint8_t * ref , int ref_stride , unsigned int * sse ) {\n int sum ;\n variance ( src , src_stride , ref , ref_stride , 16 , 8 , sse , & sum ) ;\n return * sse ;\n }\n unsigned int vp9_mse8x16_c ( const uint8_t * src , int src_stride , const uint8_t * ref , int ref_stride , unsigned int * sse ) {\n int sum ;\n variance ( src , src_stride , ref , ref_stride , 8 , 16 , sse , & sum ) ;\n return * sse ;\n }\n unsigned int vp9_mse8x8_c ( const uint8_t * src , int src_stride , const uint8_t * ref , int ref_stride , unsigned int * sse ) {\n int sum ;\n variance ( src , src_stride , ref , ref_stride , 8 , 8 , sse , & sum ) ;\n return * sse ;\n }\n VAR ( 4 , 4 ) SUBPIX_VAR ( 4 , 4 ) SUBPIX_AVG_VAR ( 4 , 4 ) VAR ( 4 , 8 ) SUBPIX_VAR ( 4 , 8 ) SUBPIX_AVG_VAR ( 4 , 8 ) VAR ( 8 , 4 ) SUBPIX_VAR ( 8 , 4 ) SUBPIX_AVG_VAR ( 8 , 4 ) VAR ( 8 , 8 ) SUBPIX_VAR ( 8 , 8 ) SUBPIX_AVG_VAR ( 8 , 8 ) VAR ( 8 , 16 ) SUBPIX_VAR ( 8 , 16 ) SUBPIX_AVG_VAR ( 8 , 16 ) VAR ( 16 , 8 ) SUBPIX_VAR ( 16 , 8 ) SUBPIX_AVG_VAR ( 16 , 8 )", "idx": 1811}
{"hash": 6427656838353800830, "project": "chrome", "size": 4, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( ChooserDialogViewTest , ClickStyledLabelLink ) {\n EXPECT_CALL ( * mock_chooser_controller_ , OpenHelpCenterUrl ( ) ) . Times ( 1 ) ;\n chooser_dialog_view_ -> StyledLabelLinkClicked ( nullptr , gfx : : Range ( ) , 0 ) ;\n }", "idx": 1812}
{"hash": -2661809302248698892, "project": "debian", "size": 91, "label": 1, "functionSource": "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n FourXContext * const f = avctx -> priv_data ;\n AVFrame * picture = data ;\n AVFrame * p ;\n int i , frame_4cc , frame_size , ret ;\n frame_4cc = AV_RL32 ( buf ) ;\n if ( buf_size != AV_RL32 ( buf + 4 ) + 8 || buf_size < 20 ) av_log ( f -> avctx , AV_LOG_ERROR , \"size mismatch %d %d\\n\" , buf_size , AV_RL32 ( buf + 4 ) ) ;\n if ( frame_4cc == AV_RL32 ( \"cfrm\" ) ) {\n int free_index = - 1 ;\n const int data_size = buf_size - 20 ;\n const int id = AV_RL32 ( buf + 12 ) ;\n const int whole_size = AV_RL32 ( buf + 16 ) ;\n CFrameBuffer * cfrm ;\n for ( i = 0 ;\n i < CFRAME_BUFFER_COUNT ;\n i ++ ) if ( f -> cfrm [ i ] . id && f -> cfrm [ i ] . id < avctx -> frame_number ) av_log ( f -> avctx , AV_LOG_ERROR , \"lost c frame %d\\n\" , f -> cfrm [ i ] . id ) ;\n for ( i = 0 ;\n i < CFRAME_BUFFER_COUNT ;\n i ++ ) {\n if ( f -> cfrm [ i ] . id == id ) break ;\n if ( f -> cfrm [ i ] . size == 0 ) free_index = i ;\n }\n if ( i >= CFRAME_BUFFER_COUNT ) {\n i = free_index ;\n f -> cfrm [ i ] . id = id ;\n }\n cfrm = & f -> cfrm [ i ] ;\n cfrm -> data = av_fast_realloc ( cfrm -> data , & cfrm -> allocated_size , cfrm -> size + data_size + FF_INPUT_BUFFER_PADDING_SIZE ) ;\n if ( ! cfrm -> data ) {\n av_log ( f -> avctx , AV_LOG_ERROR , \"realloc failure\" ) ;\n return AVERROR ( ENOMEM ) ;\n }\n memcpy ( cfrm -> data + cfrm -> size , buf + 20 , data_size ) ;\n cfrm -> size += data_size ;\n if ( cfrm -> size >= whole_size ) {\n buf = cfrm -> data ;\n frame_size = cfrm -> size ;\n if ( id != avctx -> frame_number ) av_log ( f -> avctx , AV_LOG_ERROR , \"cframe id mismatch %d %d\\n\" , id , avctx -> frame_number ) ;\n cfrm -> size = cfrm -> id = 0 ;\n frame_4cc = AV_RL32 ( \"pfrm\" ) ;\n }\n else return buf_size ;\n }\n else {\n buf = buf + 12 ;\n frame_size = buf_size - 12 ;\n }\n FFSWAP ( AVFrame * , f -> current_picture , f -> last_picture ) ;\n p = f -> current_picture ;\n avctx -> coded_frame = p ;\n avctx -> flags |= CODEC_FLAG_EMU_EDGE ;\n if ( p -> data [ 0 ] ) avctx -> release_buffer ( avctx , p ) ;\n p -> reference = 1 ;\n if ( ( ret = ff_get_buffer ( avctx , p ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n if ( frame_4cc == AV_RL32 ( \"ifr2\" ) ) {\n p -> pict_type = AV_PICTURE_TYPE_I ;\n if ( ( ret = decode_i2_frame ( f , buf - 4 , frame_size + 4 ) ) < 0 ) return ret ;\n }\n else if ( frame_4cc == AV_RL32 ( \"ifrm\" ) ) {\n p -> pict_type = AV_PICTURE_TYPE_I ;\n if ( ( ret = decode_i_frame ( f , buf , frame_size ) ) < 0 ) return ret ;\n }\n else if ( frame_4cc == AV_RL32 ( \"pfrm\" ) || frame_4cc == AV_RL32 ( \"pfr2\" ) ) {\n if ( ! f -> last_picture -> data [ 0 ] ) {\n f -> last_picture -> reference = 1 ;\n if ( ( ret = ff_get_buffer ( avctx , f -> last_picture ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n memset ( f -> last_picture -> data [ 0 ] , 0 , avctx -> height * FFABS ( f -> last_picture -> linesize [ 0 ] ) ) ;\n }\n p -> pict_type = AV_PICTURE_TYPE_P ;\n if ( ( ret = decode_p_frame ( f , buf , frame_size ) ) < 0 ) return ret ;\n }\n else if ( frame_4cc == AV_RL32 ( \"snd_\" ) ) {\n av_log ( avctx , AV_LOG_ERROR , \"ignoring snd_ chunk length:%d\\n\" , buf_size ) ;\n }\n else {\n av_log ( avctx , AV_LOG_ERROR , \"ignoring unknown chunk length:%d\\n\" , buf_size ) ;\n }\n p -> key_frame = p -> pict_type == AV_PICTURE_TYPE_I ;\n * picture = * p ;\n * got_frame = 1 ;\n emms_c ( ) ;\n return buf_size ;\n }", "idx": 1813}
{"hash": 1760449185745615462, "project": "debian", "size": 5, "label": 0, "functionSource": "void TSHttpTxnNoActivityTimeoutSet ( TSHttpTxn txnp , int timeout ) {\n sdk_assert ( sdk_sanity_check_txn ( txnp ) == TS_SUCCESS ) ;\n HttpTransact : : State * s = & ( ( ( HttpSM * ) txnp ) -> t_state ) ;\n s -> api_txn_no_activity_timeout_value = timeout ;\n }", "idx": 1814}
{"hash": -5615323818347734353, "project": "debian", "size": 8, "label": 0, "functionSource": "bool fn_format_relative_to_data_home ( char * to , const char * name , const char * dir , const char * extension ) {\n char tmp_path [ FN_REFLEN ] ;\n if ( ! test_if_hard_path ( dir ) ) {\n strxnmov ( tmp_path , sizeof ( tmp_path ) - 1 , mysql_real_data_home , dir , NullS ) ;\n dir = tmp_path ;\n }\n return ! fn_format ( to , name , dir , extension , MY_APPEND_EXT | MY_UNPACK_FILENAME | MY_SAFE_PATH ) ;\n }", "idx": 1815}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_INTEGER_1_3600 ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_constrained_integer ( tvb , offset , actx , tree , hf_index , 1U , 3600U , NULL , FALSE ) ;\n return offset ;\n }", "idx": 1816}
{"hash": 2930500905204315787, "project": "debian", "size": 4, "label": 1, "functionSource": "static __inline__ __u32 __fswahw32 ( __u32 val ) {\n # ifdef __arch_swahw32 return __arch_swahw32 ( val ) ;\n # else return ___constant_swahw32 ( val ) ;\n # endif }", "idx": 1817}
{"hash": 7039307292471244756, "project": "debian", "size": 12, "label": 0, "functionSource": "static void dtap_cc_status ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len ) {\n guint32 curr_offset ;\n guint32 consumed ;\n guint curr_len ;\n curr_offset = offset ;\n curr_len = len ;\n is_uplink = IS_UPLINK_FALSE ;\n ELEM_MAND_LV ( GSM_A_PDU_TYPE_DTAP , DE_CAUSE , NULL ) ;\n ELEM_MAND_V ( GSM_A_PDU_TYPE_DTAP , DE_CALL_STATE , NULL ) ;\n ELEM_OPT_TLV ( 0x24 , GSM_A_PDU_TYPE_DTAP , DE_AUX_STATES , NULL ) ;\n EXTRANEOUS_DATA_CHECK ( curr_len , 0 , pinfo , & ei_gsm_a_dtap_extraneous_data ) ;\n }", "idx": 1818}
{"hash": 3887066622454352196, "project": "chrome", "size": 13, "label": 1, "functionSource": "static void super_block_yrd ( VP9_COMP * cpi , MACROBLOCK * x , int * rate , int64_t * distortion , int * skip , int64_t * psse , BLOCK_SIZE bs , int64_t txfm_cache [ TX_MODES ] , int64_t ref_best_rd ) {\n MACROBLOCKD * xd = & x -> e_mbd ;\n int64_t sse ;\n int64_t * ret_sse = psse ? psse : & sse ;\n assert ( bs == xd -> mi [ 0 ] -> mbmi . sb_type ) ;\n if ( cpi -> sf . tx_size_search_method == USE_LARGESTALL || xd -> lossless ) {\n vpx_memset ( txfm_cache , 0 , TX_MODES * sizeof ( int64_t ) ) ;\n choose_largest_tx_size ( cpi , x , rate , distortion , skip , ret_sse , ref_best_rd , bs ) ;\n }\n else {\n choose_tx_size_from_rd ( cpi , x , rate , distortion , skip , ret_sse , txfm_cache , ref_best_rd , bs ) ;\n }\n }", "idx": 1819}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_RFC2733Data ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_RFC2733Data , RFC2733Data_sequence ) ;\n return offset ;\n }", "idx": 1820}
{"hash": 9176142195250515812, "project": "debian", "size": 4, "label": 0, "functionSource": "static void prplcb_conn_progress ( PurpleConnection * gc , const char * text , size_t step , size_t step_count ) {\n struct im_connection * ic = purple_ic_by_gc ( gc ) ;\n imcb_log ( ic , \"%s\" , text ) ;\n }", "idx": 1821}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_T_videoFastUpdateMB ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_T_videoFastUpdateMB , T_videoFastUpdateMB_sequence ) ;\n return offset ;\n }", "idx": 1822}
{"hash": 1911881859629730975, "project": "chrome", "size": 4, "label": 1, "functionSource": "void vp9_initialize_me_consts ( VP9_COMP * cpi , int qindex ) {\n cpi -> mb . sadperbit16 = sad_per_bit16lut [ qindex ] ;\n cpi -> mb . sadperbit4 = sad_per_bit4lut [ qindex ] ;\n }", "idx": 1823}
{"hash": -8437173884317959107, "project": "debian", "size": 27, "label": 0, "functionSource": "void ff_vorbis_inverse_coupling ( float * mag , float * ang , intptr_t blocksize ) {\n int i ;\n for ( i = 0 ;\n i < blocksize ;\n i ++ ) {\n if ( mag [ i ] > 0.0 ) {\n if ( ang [ i ] > 0.0 ) {\n ang [ i ] = mag [ i ] - ang [ i ] ;\n }\n else {\n float temp = ang [ i ] ;\n ang [ i ] = mag [ i ] ;\n mag [ i ] += temp ;\n }\n }\n else {\n if ( ang [ i ] > 0.0 ) {\n ang [ i ] += mag [ i ] ;\n }\n else {\n float temp = ang [ i ] ;\n ang [ i ] = mag [ i ] ;\n mag [ i ] -= temp ;\n }\n }\n }\n }", "idx": 1824}
{"hash": -1335877942018854351, "project": "chrome", "size": 5, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( UnloadTest , CrossSiteInfiniteUnloadSync ) {\n if ( base : : CommandLine : : ForCurrentProcess ( ) -> HasSwitch ( switches : : kSingleProcess ) ) return ;\n NavigateToDataURL ( INFINITE_UNLOAD_HTML , \"infiniteunload\" ) ;\n NavigateToNolistenersFileTwice ( ) ;\n }", "idx": 1825}
{"hash": 7493853980473701704, "project": "debian", "size": 6, "label": 0, "functionSource": "static uint32_t gic_dist_readw ( void * opaque , hwaddr offset ) {\n uint32_t val ;\n val = gic_dist_readb ( opaque , offset ) ;\n val |= gic_dist_readb ( opaque , offset + 1 ) << 8 ;\n return val ;\n }", "idx": 1826}
{"hash": -1055531103257174901, "project": "debian", "size": 10, "label": 0, "functionSource": "void completion_last_message_rename ( const char * oldnick , const char * newnick ) {\n LAST_MSG_REC * rec ;\n g_return_if_fail ( oldnick != NULL ) ;\n g_return_if_fail ( newnick != NULL ) ;\n rec = last_msg_find ( global_lastmsgs , oldnick ) ;\n if ( rec != NULL ) {\n g_free ( rec -> nick ) ;\n rec -> nick = g_strdup ( newnick ) ;\n }\n }", "idx": 1827}
{"hash": 2388171415474875762, "project": "debian", "size": 242, "label": 0, "functionSource": "static void dissect_rsvp_3gpp_object ( proto_tree * ti _U_ , packet_info * pinfo , proto_tree * rsvp_object_tree , tvbuff_t * tvb , int offset , int obj_length , int rsvp_class _U_ , int c_type ) {\n guint16 length , ie_type ;\n offset += 3 ;\n proto_tree_add_item ( rsvp_object_tree , hf_rsvp_ctype , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n offset ++ ;\n obj_length = obj_length - 4 ;\n if ( c_type == 1 ) {\n proto_tree_add_item ( rsvp_object_tree , hf_rsvp_3gpp_obj_tid , tvb , offset , 4 , ENC_BIG_ENDIAN ) ;\n offset += 4 ;\n obj_length = obj_length - 4 ;\n while ( obj_length > 0 ) {\n length = tvb_get_ntohs ( tvb , offset ) ;\n proto_tree_add_item ( rsvp_object_tree , hf_rsvp_3gpp_obj_ie_len , tvb , offset , 2 , ENC_BIG_ENDIAN ) ;\n offset += 2 ;\n ie_type = tvb_get_ntohs ( tvb , offset ) ;\n proto_tree_add_item ( rsvp_object_tree , hf_rsvp_3gpp_obj_ie_type , tvb , offset , 2 , ENC_BIG_ENDIAN ) ;\n offset += 2 ;\n if ( ( ie_type == 0 ) || ( ie_type == 2 ) ) {\n guint8 tft_opcode , tft_n_pkt_flt ;\n int i ;\n if ( ie_type == 0 ) {\n proto_tree_add_item ( rsvp_object_tree , hf_rsvp_3gpp_obj_ue_ipv4_addr , tvb , offset , 4 , ENC_BIG_ENDIAN ) ;\n offset += 4 ;\n }\n else {\n proto_tree_add_item ( rsvp_object_tree , hf_rsvp_3gpp_obj_ue_ipv6_addr , tvb , offset , 16 , ENC_NA ) ;\n offset += 16 ;\n }\n proto_tree_add_item ( rsvp_object_tree , hf_rsvp_3gpp_obj_tft_d , tvb , offset , 4 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rsvp_object_tree , hf_rsvp_3gpp_obj_tft_ns , tvb , offset , 4 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rsvp_object_tree , hf_rsvp_3gpp_obj_tft_sr_id , tvb , offset , 4 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rsvp_object_tree , hf_rsvp_3gpp_obj_tft_p , tvb , offset , 4 , ENC_BIG_ENDIAN ) ;\n tft_opcode = tvb_get_guint8 ( tvb , offset + 2 ) ;\n proto_tree_add_item ( rsvp_object_tree , hf_rsvp_3gpp_obj_tft_opcode , tvb , offset , 4 , ENC_BIG_ENDIAN ) ;\n tft_n_pkt_flt = tvb_get_guint8 ( tvb , offset + 3 ) ;\n proto_tree_add_item ( rsvp_object_tree , hf_rsvp_3gpp_obj_tft_n_pkt_flt , tvb , offset , 4 , ENC_BIG_ENDIAN ) ;\n offset += 4 ;\n if ( ( tft_opcode != 0x81 ) && ( tft_n_pkt_flt != 0 ) ) {\n for ( i = 0 ;\n i < tft_n_pkt_flt ;\n i ++ ) {\n proto_tree * flow_tree , * t2_tree ;\n guint16 pkt_flt_len , item_len , pf_cont_len ;\n guint8 pf_comp_type_id ;\n flow_tree = proto_tree_add_subtree_format ( rsvp_object_tree , tvb , offset , - 1 , ett_treelist [ TT_3GPP_OBJ_FLOW ] , & ti , \"Flow Identifier Num %u\" , i + 1 ) ;\n proto_tree_add_item ( flow_tree , hf_rsvp_3gpp_obj_flow_id , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n offset ++ ;\n item_len = 1 ;\n if ( ( tft_opcode == 0x05 ) || ( tft_opcode == 0x82 ) ) {\n proto_item_set_len ( ti , item_len ) ;\n continue ;\n }\n proto_tree_add_item ( flow_tree , hf_rsvp_3gpp_obj_pf_ev_prec , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n offset ++ ;\n pkt_flt_len = tvb_get_ntohs ( tvb , offset ) ;\n proto_tree_add_item ( flow_tree , hf_rsvp_3gpp_obj_pf_len , tvb , offset , 2 , ENC_BIG_ENDIAN ) ;\n item_len = item_len + pkt_flt_len + 1 ;\n offset += 2 ;\n proto_tree_add_item ( flow_tree , hf_rsvp_3gpp_obj_pf_type , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n offset ++ ;\n pf_cont_len = tvb_get_guint8 ( tvb , offset ) ;\n proto_tree_add_item ( flow_tree , hf_rsvp_3gpp_obj_pf_cont_len , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n offset ++ ;\n pf_comp_type_id = tvb_get_guint8 ( tvb , offset ) ;\n proto_tree_add_item ( flow_tree , hf_rsvp_3gpp_obj_pf_comp_type_id , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n offset ++ ;\n switch ( pf_comp_type_id ) {\n case 16 : proto_tree_add_item ( flow_tree , hf_rsvp_3gpp_obj_pf_src_ipv4 , tvb , offset , 4 , ENC_BIG_ENDIAN ) ;\n offset += 4 ;\n proto_tree_add_item ( flow_tree , hf_rsvp_3gpp_obj_pf_ipv4_mask , tvb , offset , 4 , ENC_BIG_ENDIAN ) ;\n offset += 4 ;\n pf_cont_len -= 11 ;\n break ;\n case 17 : proto_tree_add_item ( flow_tree , hf_rsvp_3gpp_obj_pf_dst_ipv4 , tvb , offset , 4 , ENC_BIG_ENDIAN ) ;\n offset += 4 ;\n proto_tree_add_item ( flow_tree , hf_rsvp_3gpp_obj_pf_ipv4_mask , tvb , offset , 4 , ENC_BIG_ENDIAN ) ;\n offset += 4 ;\n pf_cont_len -= 11 ;\n break ;\n case 32 : proto_tree_add_item ( flow_tree , hf_rsvp_3gpp_obj_pf_src_ipv6 , tvb , offset , 16 , ENC_NA ) ;\n offset += 16 ;\n proto_tree_add_item ( flow_tree , hf_rsvp_3gpp_obj_pf_ipv6_prefix_length , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n offset ++ ;\n pf_cont_len -= 20 ;\n break ;\n case 33 : proto_tree_add_item ( flow_tree , hf_rsvp_3gpp_obj_pf_dst_ipv6 , tvb , offset , 16 , ENC_NA ) ;\n offset += 16 ;\n proto_tree_add_item ( flow_tree , hf_rsvp_3gpp_obj_pf_ipv6_prefix_length , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n offset ++ ;\n pf_cont_len -= 20 ;\n break ;\n case 48 : proto_tree_add_item ( flow_tree , hf_rsvp_3gpp_obj_pf_prot_next , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n offset ++ ;\n pf_cont_len -= 4 ;\n break ;\n case 64 : proto_tree_add_item ( flow_tree , hf_rsvp_3gpp_obj_pf_dst_port , tvb , offset , 2 , ENC_BIG_ENDIAN ) ;\n offset += 2 ;\n pf_cont_len -= 5 ;\n break ;\n case 65 : proto_tree_add_uint_format_value ( rsvp_object_tree , hf_rsvp_3gpp_obj_pf_dst_port_range , tvb , offset , 4 , tvb_get_ntohs ( tvb , offset ) , \"%u-%u\" , tvb_get_ntohs ( tvb , offset ) , tvb_get_ntohs ( tvb , offset + 2 ) ) ;\n offset += 4 ;\n break ;\n case 80 : proto_tree_add_item ( flow_tree , hf_rsvp_3gpp_obj_pf_src_port , tvb , offset , 2 , ENC_BIG_ENDIAN ) ;\n offset += 2 ;\n pf_cont_len -= 5 ;\n break ;\n case 81 : proto_tree_add_uint_format_value ( rsvp_object_tree , hf_rsvp_3gpp_obj_pf_src_port_range , tvb , offset , 4 , tvb_get_ntohs ( tvb , offset ) , \"Source Port range %u-%u\" , tvb_get_ntohs ( tvb , offset ) , tvb_get_ntohs ( tvb , offset + 2 ) ) ;\n offset += 4 ;\n pf_cont_len -= 7 ;\n break ;\n case 96 : proto_tree_add_item ( flow_tree , hf_rsvp_3gpp_obj_pf_ipsec_spi , tvb , offset , 4 , ENC_BIG_ENDIAN ) ;\n offset += 4 ;\n pf_cont_len -= 7 ;\n break ;\n case 112 : proto_tree_add_item ( flow_tree , hf_rsvp_3gpp_obj_pf_tos_tc , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n offset ++ ;\n pf_cont_len -= 4 ;\n break ;\n case 128 : proto_tree_add_item ( flow_tree , hf_rsvp_3gpp_obj_pf_flow_lbl , tvb , offset , 3 , ENC_BIG_ENDIAN ) ;\n offset += 3 ;\n pf_cont_len -= 6 ;\n break ;\n case 129 : t2_tree = proto_tree_add_subtree ( flow_tree , tvb , offset , 17 , ett_treelist [ TT_3GPP_OBJ_T2 ] , NULL , \"Type 2 Routing Header packet filter\" ) ;\n proto_tree_add_item ( t2_tree , hf_rsvp_3gpp_obj_pf_ipv6 , tvb , offset , 16 , ENC_NA ) ;\n offset += 16 ;\n proto_tree_add_item ( t2_tree , hf_rsvp_3gpp_obj_pf_ipv6_prefix_length , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n offset ++ ;\n pf_cont_len -= 20 ;\n break ;\n case 130 : t2_tree = proto_tree_add_subtree ( flow_tree , tvb , offset , 17 , ett_treelist [ TT_3GPP_OBJ_HO ] , NULL , \"Home address Option packet filter\" ) ;\n proto_tree_add_item ( t2_tree , hf_rsvp_3gpp_obj_pf_ipv6 , tvb , offset , 16 , ENC_NA ) ;\n offset += 16 ;\n proto_tree_add_item ( t2_tree , hf_rsvp_3gpp_obj_pf_ipv6_prefix_length , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n offset ++ ;\n pf_cont_len -= 20 ;\n break ;\n default : proto_tree_add_expert ( flow_tree , pinfo , & ei_rsvp_packet_filter_component , tvb , offset , pf_cont_len - 2 ) ;\n offset = offset + pkt_flt_len - 5 ;\n pf_cont_len = 0 ;\n break ;\n }\n if ( pf_cont_len != 0 ) {\n proto_tree_add_item ( flow_tree , hf_rsvp_3gpp_obj_pf_treatment , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n offset ++ ;\n proto_tree_add_item ( flow_tree , hf_rsvp_3gpp_obj_pf_hint , tvb , offset , 4 , ENC_BIG_ENDIAN ) ;\n offset += 4 ;\n }\n proto_item_set_len ( ti , item_len ) ;\n }\n }\n if ( ( tft_opcode == 0x01 ) || ( tft_opcode == 0x06 ) || ( tft_opcode == 0x80 ) || ( tft_opcode == 0x81 ) || ( tft_opcode == 0x83 ) ) {\n gint32 tft_qos_list_len ;\n guint8 blob_len , item_len , padding_len ;\n gboolean verbose ;\n proto_tree * qos_tree , * qos_sub_blob_tree , * qos_att_tree ;\n int num = 0 , j , num_qos_att_set ;\n tft_qos_list_len = tvb_get_ntohs ( tvb , offset ) ;\n proto_tree_add_item ( rsvp_object_tree , hf_rsvp_3gpp_obj_tft_qos_list_len , tvb , offset , 2 , ENC_BIG_ENDIAN ) ;\n offset += 2 ;\n tft_qos_list_len -= 2 ;\n if ( tft_qos_list_len > 0 ) {\n while ( tft_qos_list_len > 0 ) {\n int bit_offset ;\n guint8 qos_attribute_set_len ;\n num ++ ;\n qos_tree = proto_tree_add_subtree_format ( rsvp_object_tree , tvb , offset , - 1 , ett_treelist [ TT_3GPP_OBJ_QOS ] , NULL , \"QOS Flow Identifier Num %u\" , num ) ;\n proto_tree_add_item ( qos_tree , hf_rsvp_3gpp_obj_flow_id , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n offset ++ ;\n tft_qos_list_len -- ;\n blob_len = tvb_get_guint8 ( tvb , offset ) ;\n proto_tree_add_item ( qos_tree , hf_rsvp_3gpp_r_qos_blob_len , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n offset ++ ;\n tft_qos_list_len -- ;\n ti = proto_tree_add_item ( qos_tree , hf_rsvp_3gpp_r_qos_blob , tvb , offset , blob_len , ENC_NA ) ;\n qos_sub_blob_tree = proto_item_add_subtree ( ti , ett_treelist [ TT_3GPP_OBJ_QOS_SUB_BLOB ] ) ;\n proto_tree_add_item ( qos_sub_blob_tree , hf_rsvp_3gpp_r_qos_blob_flow_pri , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( qos_sub_blob_tree , hf_rsvp_3gpp_r_qos_blob_num_qos_att_set , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n num_qos_att_set = ( tvb_get_guint8 ( tvb , offset ) & 0x0e ) >> 1 ;\n bit_offset = ( offset << 3 ) + 7 ;\n for ( j = 0 ;\n j < num_qos_att_set ;\n j ++ ) {\n qos_attribute_set_len = tvb_get_bits8 ( tvb , bit_offset , 4 ) ;\n qos_att_tree = proto_tree_add_subtree_format ( qos_sub_blob_tree , tvb , bit_offset >> 3 , qos_attribute_set_len , ett_treelist [ TT_3GPP_OBJ_QOS_SUB_BLOB ] , NULL , \"QoS_ATTRIBUTE_SET %u(%u bytes)\" , j + 1 , qos_attribute_set_len ) ;\n proto_tree_add_bits_item ( qos_att_tree , hf_rsvp_3gpp_qos_att_set_len , tvb , bit_offset , 4 , ENC_BIG_ENDIAN ) ;\n bit_offset += 4 ;\n if ( qos_attribute_set_len == 0 ) {\n break ;\n }\n proto_tree_add_bits_item ( qos_att_tree , hf_rsvp_3gpp_qos_attribute_set_id , tvb , bit_offset , 7 , ENC_BIG_ENDIAN ) ;\n bit_offset += 7 ;\n verbose = tvb_get_bits8 ( tvb , bit_offset , 1 ) ;\n proto_tree_add_bits_item ( qos_att_tree , hf_rsvp_3gpp_qos_attribute_verbose , tvb , bit_offset , 1 , ENC_BIG_ENDIAN ) ;\n bit_offset ++ ;\n if ( verbose == FALSE ) {\n proto_tree_add_bits_item ( qos_att_tree , hf_rsvp_3gpp_qos_attribute_prof_id , tvb , bit_offset , 16 , ENC_BIG_ENDIAN ) ;\n bit_offset += 16 ;\n }\n else {\n proto_tree_add_bits_item ( qos_att_tree , hf_rsvp_3gpp_qos_attribute_traff_cls , tvb , bit_offset , 3 , ENC_BIG_ENDIAN ) ;\n bit_offset += 3 ;\n proto_tree_add_bits_item ( qos_att_tree , hf_rsvp_3gpp_qos_attribute_peak_rate , tvb , bit_offset , 16 , ENC_BIG_ENDIAN ) ;\n bit_offset += 16 ;\n proto_tree_add_bits_item ( qos_att_tree , hf_rsvp_3gpp_qos_attribute_bucket_size , tvb , bit_offset , 16 , ENC_BIG_ENDIAN ) ;\n bit_offset += 16 ;\n proto_tree_add_bits_item ( qos_att_tree , hf_rsvp_3gpp_qos_attribute_token_rate , tvb , bit_offset , 16 , ENC_BIG_ENDIAN ) ;\n bit_offset += 16 ;\n proto_tree_add_bits_item ( qos_att_tree , hf_rsvp_3gpp_qos_attribute_max_latency , tvb , bit_offset , 16 , ENC_BIG_ENDIAN ) ;\n bit_offset += 8 ;\n proto_tree_add_bits_item ( qos_att_tree , hf_rsvp_3gpp_qos_attribute_max_loss_rte , tvb , bit_offset , 16 , ENC_BIG_ENDIAN ) ;\n bit_offset += 8 ;\n proto_tree_add_bits_item ( qos_att_tree , hf_rsvp_3gpp_qos_attribute_delay_var_sensitive , tvb , bit_offset , 16 , ENC_BIG_ENDIAN ) ;\n bit_offset += 1 ;\n }\n padding_len = 0 ;\n if ( ( bit_offset & 0x07 ) != 0 ) {\n padding_len = 8 - ( bit_offset & 0x07 ) ;\n proto_tree_add_bits_item ( qos_att_tree , hf_rsvp_3gpp_qos_attribute_reserved , tvb , bit_offset , padding_len , ENC_BIG_ENDIAN ) ;\n }\n bit_offset = bit_offset + padding_len ;\n }\n offset = offset + blob_len ;\n tft_qos_list_len = tft_qos_list_len - blob_len ;\n item_len = blob_len + 2 ;\n if ( tft_opcode == 0x81 ) {\n proto_tree_add_item ( qos_tree , hf_rsvp_3gpp_qos_result , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n offset ++ ;\n tft_qos_list_len -- ;\n item_len ++ ;\n }\n proto_item_set_len ( ti , item_len ) ;\n }\n }\n }\n else {\n proto_tree_add_item ( rsvp_object_tree , hf_rsvp_ie_data , tvb , offset , length - 2 , ENC_NA ) ;\n }\n obj_length = obj_length - length ;\n }\n }\n }\n }", "idx": 1828}
{"hash": 7783404437431406265, "project": "debian", "size": 11, "label": 0, "functionSource": "static void debug_wait_for_kill ( const char * info ) {\n DBUG_ENTER ( \"debug_wait_for_kill\" ) ;\n const char * prev_info ;\n THD * thd ;\n thd = current_thd ;\n prev_info = thd_proc_info ( thd , info ) ;\n while ( ! thd -> killed ) my_sleep ( 1000 ) ;\n DBUG_PRINT ( \"info\" , ( \"Exit debug_wait_for_kill\" ) ) ;\n thd_proc_info ( thd , prev_info ) ;\n DBUG_VOID_RETURN ;\n }", "idx": 1829}
{"hash": -8128341148043427861, "project": "chrome", "size": 7, "label": 1, "functionSource": "void vp9_encode_intra_block_plane ( MACROBLOCK * x , BLOCK_SIZE bsize , int plane ) {\n const MACROBLOCKD * const xd = & x -> e_mbd ;\n struct encode_b_args arg = {\n x , NULL , & xd -> mi [ 0 ] -> mbmi . skip }\n ;\n vp9_foreach_transformed_block_in_plane ( xd , bsize , plane , encode_block_intra , & arg ) ;\n }", "idx": 1830}
{"hash": -7076754245473579218, "project": "chrome", "size": 12, "label": 0, "functionSource": "void evhttp_send_reply_chunk ( struct evhttp_request * req , struct evbuffer * databuf ) {\n struct evhttp_connection * evcon = req -> evcon ;\n if ( evcon == NULL ) return ;\n if ( req -> chunked ) {\n evbuffer_add_printf ( evcon -> output_buffer , \"%x\\r\\n\" , ( unsigned ) EVBUFFER_LENGTH ( databuf ) ) ;\n }\n evbuffer_add_buffer ( evcon -> output_buffer , databuf ) ;\n if ( req -> chunked ) {\n evbuffer_add ( evcon -> output_buffer , \"\\r\\n\" , 2 ) ;\n }\n evhttp_write_buffer ( evcon , NULL , NULL ) ;\n }", "idx": 1831}
{"hash": -7587206010331533317, "project": "chrome", "size": 4, "label": 0, "functionSource": "inline const OldUChar * toOldUCharPtr ( const char16_t * p ) {\n # ifdef U_ALIASING_BARRIER U_ALIASING_BARRIER ( p ) ;\n # endif return reinterpret_cast < const OldUChar * > ( p ) ;\n }", "idx": 1832}
{"hash": 6336384260629386331, "project": "debian", "size": 6, "label": 0, "functionSource": "void proto_reg_handoff_zbee_zcl_groups ( void ) {\n dissector_handle_t groups_handle ;\n groups_handle = find_dissector ( ZBEE_PROTOABBREV_ZCL_GROUPS ) ;\n dissector_add_uint ( \"zbee.zcl.cluster\" , ZBEE_ZCL_CID_GROUPS , groups_handle ) ;\n zbee_zcl_init_cluster ( proto_zbee_zcl_groups , ett_zbee_zcl_groups , ZBEE_ZCL_CID_GROUPS , hf_zbee_zcl_groups_attr_id , hf_zbee_zcl_groups_srv_rx_cmd_id , hf_zbee_zcl_groups_srv_tx_cmd_id , ( zbee_zcl_fn_attr_data ) dissect_zcl_groups_attr_data ) ;\n }", "idx": 1833}
{"hash": -3740862514502467070, "project": "debian", "size": 45, "label": 0, "functionSource": "static void dumpcffcidtopdict ( SplineFont * sf , struct alltabs * at ) {\n char * pt , * end ;\n FILE * cfff = at -> cfff ;\n DBounds b ;\n int cidcnt = 0 , k ;\n for ( k = 0 ;\n k < sf -> subfontcnt ;\n ++ k ) if ( sf -> subfonts [ k ] -> glyphcnt > cidcnt ) cidcnt = sf -> subfonts [ k ] -> glyphcnt ;\n putshort ( cfff , 1 ) ;\n putc ( '\\2' , cfff ) ;\n putshort ( cfff , 1 ) ;\n at -> lenpos = ftell ( cfff ) ;\n putshort ( cfff , 0 ) ;\n dumpsid ( cfff , at , sf -> cidregistry , - 1 ) ;\n dumpsid ( cfff , at , sf -> ordering , - 1 ) ;\n dumpintoper ( cfff , sf -> supplement , ( 12 << 8 ) | 30 ) ;\n dumpdbloper ( cfff , sf -> cidversion , ( 12 << 8 ) | 31 ) ;\n dumpintoper ( cfff , cidcnt , ( 12 << 8 ) | 34 ) ;\n if ( sf -> use_uniqueid ) dumpintoper ( cfff , sf -> uniqueid ? sf -> uniqueid : 4000000 + ( rand ( ) & 0x3ffff ) , ( 12 << 8 ) | 35 ) ;\n dumpsid ( cfff , at , sf -> copyright , 1 ) ;\n dumpsid ( cfff , at , sf -> fullname ? sf -> fullname : sf -> fontname , 2 ) ;\n dumpsid ( cfff , at , sf -> familyname , 3 ) ;\n dumpsid ( cfff , at , sf -> weight , 4 ) ;\n CIDLayerFindBounds ( sf , at -> gi . layer , & b ) ;\n at -> gi . xmin = b . minx ;\n at -> gi . ymin = b . miny ;\n at -> gi . xmax = b . maxx ;\n at -> gi . ymax = b . maxy ;\n dumpdbl ( cfff , floor ( b . minx ) ) ;\n dumpdbl ( cfff , floor ( b . miny ) ) ;\n dumpdbl ( cfff , ceil ( b . maxx ) ) ;\n dumpdbloper ( cfff , ceil ( b . maxy ) , 5 ) ;\n if ( sf -> xuid != NULL && sf -> use_xuid ) {\n pt = sf -> xuid ;\n if ( * pt == '[' ) ++ pt ;\n while ( * pt && * pt != ']' ) {\n dumpint ( cfff , strtol ( pt , & end , 10 ) ) ;\n for ( pt = end ;\n * pt == ' ' ;\n ++ pt ) ;\n }\n putc ( 14 , cfff ) ;\n if ( sf -> changed_since_xuidchanged ) SFIncrementXUID ( sf ) ;\n }\n }", "idx": 1834}
{"hash": 1676654288894940649, "project": "debian", "size": 127, "label": 0, "functionSource": "void kadmin_cpw ( int argc , char * argv [ ] ) {\n kadm5_ret_t retval ;\n static char newpw [ 1024 ] ;\n static char prompt1 [ 1024 ] , prompt2 [ 1024 ] ;\n char * canon = NULL , * pwarg = NULL ;\n int n_ks_tuple = 0 , randkey = 0 ;\n krb5_boolean keepold = FALSE ;\n krb5_key_salt_tuple * ks_tuple = NULL ;\n krb5_principal princ = NULL ;\n char * * db_args = NULL ;\n int db_args_size = 0 ;\n if ( argc < 2 ) {\n cpw_usage ( NULL ) ;\n return ;\n }\n for ( argv ++ , argc -- ;\n argc > 1 ;\n argc -- , argv ++ ) {\n if ( ! strcmp ( \"-x\" , * argv ) ) {\n argc -- ;\n if ( argc < 1 ) {\n cpw_usage ( _ ( \"change_password: missing db argument\" ) ) ;\n goto cleanup ;\n }\n db_args_size ++ ;\n db_args = realloc ( db_args , sizeof ( char * ) * ( db_args_size + 1 ) ) ;\n if ( db_args == NULL ) {\n fprintf ( stderr , _ ( \"change_password: Not enough memory\\n\" ) ) ;\n exit ( 1 ) ;\n }\n db_args [ db_args_size - 1 ] = * ++ argv ;\n db_args [ db_args_size ] = NULL ;\n }\n else if ( ! strcmp ( \"-pw\" , * argv ) ) {\n argc -- ;\n if ( argc < 1 ) {\n cpw_usage ( _ ( \"change_password: missing password arg\" ) ) ;\n goto cleanup ;\n }\n pwarg = * ++ argv ;\n }\n else if ( ! strcmp ( \"-randkey\" , * argv ) ) {\n randkey ++ ;\n }\n else if ( ! strcmp ( \"-keepold\" , * argv ) ) {\n keepold = TRUE ;\n }\n else if ( ! strcmp ( \"-e\" , * argv ) ) {\n argc -- ;\n if ( argc < 1 ) {\n cpw_usage ( _ ( \"change_password: missing keysaltlist arg\" ) ) ;\n goto cleanup ;\n }\n retval = krb5_string_to_keysalts ( * ++ argv , \", \\t\" , \":.-\" , 0 , & ks_tuple , & n_ks_tuple ) ;\n if ( retval ) {\n com_err ( \"change_password\" , retval , _ ( \"while parsing keysalts %s\" ) , * argv ) ;\n goto cleanup ;\n }\n }\n else {\n cpw_usage ( NULL ) ;\n goto cleanup ;\n }\n }\n if ( * argv == NULL ) {\n com_err ( \"change_password\" , 0 , _ ( \"missing principal name\" ) ) ;\n cpw_usage ( NULL ) ;\n goto cleanup ;\n }\n retval = kadmin_parse_name ( * argv , & princ ) ;\n if ( retval ) {\n com_err ( \"change_password\" , retval , _ ( \"while parsing principal name\" ) ) ;\n goto cleanup ;\n }\n retval = krb5_unparse_name ( context , princ , & canon ) ;\n if ( retval ) {\n com_err ( \"change_password\" , retval , _ ( \"while canonicalizing principal\" ) ) ;\n goto cleanup ;\n }\n if ( pwarg != NULL ) {\n if ( keepold || ks_tuple != NULL ) {\n retval = kadm5_chpass_principal_3 ( handle , princ , keepold , n_ks_tuple , ks_tuple , pwarg ) ;\n }\n else {\n retval = kadm5_chpass_principal ( handle , princ , pwarg ) ;\n }\n if ( retval ) {\n com_err ( \"change_password\" , retval , _ ( \"while changing password for \\\"%s\\\".\" ) , canon ) ;\n goto cleanup ;\n }\n printf ( _ ( \"Password for \\\"%s\\\" changed.\\n\" ) , canon ) ;\n }\n else if ( randkey ) {\n retval = randkey_princ ( princ , keepold , n_ks_tuple , ks_tuple ) ;\n if ( retval ) {\n com_err ( \"change_password\" , retval , _ ( \"while randomizing key for \\\"%s\\\".\" ) , canon ) ;\n goto cleanup ;\n }\n printf ( _ ( \"Key for \\\"%s\\\" randomized.\\n\" ) , canon ) ;\n }\n else {\n unsigned int i = sizeof ( newpw ) - 1 ;\n snprintf ( prompt1 , sizeof ( prompt1 ) , _ ( \"Enter password for principal \\\"%s\\\"\" ) , canon ) ;\n snprintf ( prompt2 , sizeof ( prompt2 ) , _ ( \"Re-enter password for principal \\\"%s\\\"\" ) , canon ) ;\n retval = krb5_read_password ( context , prompt1 , prompt2 , newpw , & i ) ;\n if ( retval ) {\n com_err ( \"change_password\" , retval , _ ( \"while reading password for \\\"%s\\\".\" ) , canon ) ;\n goto cleanup ;\n }\n if ( keepold || ks_tuple != NULL ) {\n retval = kadm5_chpass_principal_3 ( handle , princ , keepold , n_ks_tuple , ks_tuple , newpw ) ;\n }\n else {\n retval = kadm5_chpass_principal ( handle , princ , newpw ) ;\n }\n memset ( newpw , 0 , sizeof ( newpw ) ) ;\n if ( retval ) {\n com_err ( \"change_password\" , retval , _ ( \"while changing password for \\\"%s\\\".\" ) , canon ) ;\n goto cleanup ;\n }\n printf ( _ ( \"Password for \\\"%s\\\" changed.\\n\" ) , canon ) ;\n }\n cleanup : free ( canon ) ;\n free ( db_args ) ;\n krb5_free_principal ( context , princ ) ;\n free ( ks_tuple ) ;\n }", "idx": 1835}
{"hash": -1315695702746584250, "project": "debian", "size": 4, "label": 0, "functionSource": "static void proto_tree_set_guid ( field_info * fi , const e_guid_t * value_ptr ) {\n DISSECTOR_ASSERT ( value_ptr != NULL ) ;\n fvalue_set_guid ( & fi -> value , value_ptr ) ;\n }", "idx": 1836}
{"hash": 4489017523191997023, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h225_T_ipxAddress ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_T_ipxAddress , T_ipxAddress_sequence ) ;\n return offset ;\n }", "idx": 1837}
{"hash": 229962612204196999, "project": "debian", "size": 45, "label": 0, "functionSource": "static void handle_remote_ls_ctx ( struct xml_ctx * ctx , int tag_closed ) {\n struct remote_ls_ctx * ls = ( struct remote_ls_ctx * ) ctx -> userData ;\n if ( tag_closed ) {\n if ( ! strcmp ( ctx -> name , DAV_PROPFIND_RESP ) && ls -> dentry_name ) {\n if ( ls -> dentry_flags & IS_DIR ) {\n str_end_url_with_slash ( ls -> dentry_name , & ls -> dentry_name ) ;\n if ( ls -> flags & PROCESS_DIRS ) {\n ls -> userFunc ( ls ) ;\n }\n if ( strcmp ( ls -> dentry_name , ls -> path ) && ls -> flags & RECURSIVE ) {\n remote_ls ( ls -> dentry_name , ls -> flags , ls -> userFunc , ls -> userData ) ;\n }\n }\n else if ( ls -> flags & PROCESS_FILES ) {\n ls -> userFunc ( ls ) ;\n }\n }\n else if ( ! strcmp ( ctx -> name , DAV_PROPFIND_NAME ) && ctx -> cdata ) {\n char * path = ctx -> cdata ;\n if ( * ctx -> cdata == 'h' ) {\n path = strstr ( path , \"//\" ) ;\n if ( path ) {\n path = strchr ( path + 2 , '/' ) ;\n }\n }\n if ( path ) {\n const char * url = repo -> url ;\n if ( repo -> path ) url = repo -> path ;\n if ( strncmp ( path , url , repo -> path_len ) ) error ( \"Parsed path '%s' does not match url: '%s'\" , path , url ) ;\n else {\n path += repo -> path_len ;\n ls -> dentry_name = xstrdup ( path ) ;\n }\n }\n }\n else if ( ! strcmp ( ctx -> name , DAV_PROPFIND_COLLECTION ) ) {\n ls -> dentry_flags |= IS_DIR ;\n }\n }\n else if ( ! strcmp ( ctx -> name , DAV_PROPFIND_RESP ) ) {\n free ( ls -> dentry_name ) ;\n ls -> dentry_name = NULL ;\n ls -> dentry_flags = 0 ;\n }\n }", "idx": 1838}
{"hash": -7262742957929857695, "project": "chrome", "size": 12, "label": 1, "functionSource": "static xsltAttrVTPtr xsltSetAttrVTsegment ( xsltAttrVTPtr avt , void * val ) {\n if ( avt -> nb_seg >= avt -> max_seg ) {\n avt = ( xsltAttrVTPtr ) xmlRealloc ( avt , sizeof ( xsltAttrVT ) + avt -> max_seg * sizeof ( void * ) ) ;\n if ( avt == NULL ) {\n return NULL ;\n }\n memset ( & avt -> segments [ avt -> nb_seg ] , 0 , MAX_AVT_SEG * sizeof ( void * ) ) ;\n avt -> max_seg += MAX_AVT_SEG ;\n }\n avt -> segments [ avt -> nb_seg ++ ] = val ;\n return avt ;\n }", "idx": 1839}
{"hash": -8958254313220732728, "project": "debian", "size": 5, "label": 0, "functionSource": "static int virtio_net_exit_pci ( PCIDevice * pci_dev ) {\n VirtIOPCIProxy * proxy = DO_UPCAST ( VirtIOPCIProxy , pci_dev , pci_dev ) ;\n virtio_net_exit ( proxy -> vdev ) ;\n return virtio_exit_pci ( pci_dev ) ;\n }", "idx": 1840}
{"hash": 8445816931248660591, "project": "debian", "size": 24, "label": 0, "functionSource": "SPL_METHOD ( SplDoublyLinkedList , offsetGet ) {\n zval * zindex , * value ;\n long index ;\n spl_dllist_object * intern ;\n spl_ptr_llist_element * element ;\n if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , \"z\" , & zindex ) == FAILURE ) {\n return ;\n }\n intern = ( spl_dllist_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n index = spl_offset_convert_to_long ( zindex TSRMLS_CC ) ;\n if ( index < 0 || index >= intern -> llist -> count ) {\n zend_throw_exception ( spl_ce_OutOfRangeException , \"Offset invalid or out of range\" , 0 TSRMLS_CC ) ;\n return ;\n }\n element = spl_ptr_llist_offset ( intern -> llist , index , intern -> flags & SPL_DLLIST_IT_LIFO ) ;\n if ( element != NULL ) {\n value = ( zval * ) element -> data ;\n RETURN_ZVAL ( value , 1 , 0 ) ;\n }\n else {\n zend_throw_exception ( spl_ce_OutOfRangeException , \"Offset invalid\" , 0 TSRMLS_CC ) ;\n return ;\n }\n }", "idx": 1841}
{"hash": -7990991774694156606, "project": "debian", "size": 11, "label": 1, "functionSource": "static void update_frames ( AVCodecContext * avctx ) {\n Vp3DecodeContext * s = avctx -> priv_data ;\n if ( s -> last_frame . data [ 0 ] && s -> last_frame . type != FF_BUFFER_TYPE_COPY ) ff_thread_release_buffer ( avctx , & s -> last_frame ) ;\n s -> last_frame = s -> current_frame ;\n if ( s -> keyframe ) {\n if ( s -> golden_frame . data [ 0 ] ) ff_thread_release_buffer ( avctx , & s -> golden_frame ) ;\n s -> golden_frame = s -> current_frame ;\n s -> last_frame . type = FF_BUFFER_TYPE_COPY ;\n }\n s -> current_frame . data [ 0 ] = NULL ;\n }", "idx": 1842}
{"hash": -2607754285145856562, "project": "debian", "size": 8, "label": 0, "functionSource": "static int wb_write_padding_to_temp ( struct archive_write * a , int64_t csize ) {\n size_t ns ;\n int ret ;\n ns = ( size_t ) ( csize % LOGICAL_BLOCK_SIZE ) ;\n if ( ns != 0 ) ret = write_null ( a , LOGICAL_BLOCK_SIZE - ns ) ;\n else ret = ARCHIVE_OK ;\n return ( ret ) ;\n }", "idx": 1843}
{"hash": 3935234056444097745, "project": "debian", "size": 35, "label": 0, "functionSource": "static int rtp_packetize_mp4a_latm ( sout_stream_id_sys_t * id , block_t * in ) {\n int i_max = rtp_mtu ( id ) - 2 ;\n int latmhdrsize = in -> i_buffer / 0xff + 1 ;\n int i_count = ( in -> i_buffer + i_max - 1 ) / i_max ;\n uint8_t * p_data = in -> p_buffer , * p_header = NULL ;\n int i_data = in -> i_buffer ;\n int i ;\n for ( i = 0 ;\n i < i_count ;\n i ++ ) {\n int i_payload = __MIN ( i_max , i_data ) ;\n block_t * out ;\n if ( i != 0 ) latmhdrsize = 0 ;\n out = block_Alloc ( 12 + latmhdrsize + i_payload ) ;\n rtp_packetize_common ( id , out , ( ( i == i_count - 1 ) ? 1 : 0 ) , ( in -> i_pts > VLC_TS_INVALID ? in -> i_pts : in -> i_dts ) ) ;\n if ( i == 0 ) {\n int tmp = in -> i_buffer ;\n p_header = out -> p_buffer + 12 ;\n while ( tmp > 0xfe ) {\n * p_header = 0xff ;\n p_header ++ ;\n tmp -= 0xff ;\n }\n * p_header = tmp ;\n }\n memcpy ( & out -> p_buffer [ 12 + latmhdrsize ] , p_data , i_payload ) ;\n out -> i_dts = in -> i_dts + i * in -> i_length / i_count ;\n out -> i_length = in -> i_length / i_count ;\n rtp_packetize_send ( id , out ) ;\n p_data += i_payload ;\n i_data -= i_payload ;\n }\n block_Release ( in ) ;\n return VLC_SUCCESS ;\n }", "idx": 1844}
{"hash": -3146697469509848825, "project": "debian", "size": 3, "label": 0, "functionSource": "static int old_dsa_priv_encode ( const EVP_PKEY * pkey , unsigned char * * pder ) {\n return i2d_DSAPrivateKey ( pkey -> pkey . dsa , pder ) ;\n }", "idx": 1845}
{"hash": 5611940141018433728, "project": "chrome", "size": 3, "label": 0, "functionSource": "static void encode_unsigned_max ( struct vp9_write_bit_buffer * wb , int data , int max ) {\n vp9_wb_write_literal ( wb , data , get_unsigned_bits ( max ) ) ;\n }", "idx": 1846}
{"hash": 3966033627990943399, "project": "chrome", "size": 17, "label": 0, "functionSource": "static void setTrailingWSStart ( UBiDi * pBiDi ) {\n const DirProp * dirProps = pBiDi -> dirProps ;\n UBiDiLevel * levels = pBiDi -> levels ;\n int32_t start = pBiDi -> length ;\n UBiDiLevel paraLevel = pBiDi -> paraLevel ;\n if ( dirProps [ start - 1 ] == B ) {\n pBiDi -> trailingWSStart = start ;\n return ;\n }\n while ( start > 0 && DIRPROP_FLAG ( dirProps [ start - 1 ] ) & MASK_WS ) {\n -- start ;\n }\n while ( start > 0 && levels [ start - 1 ] == paraLevel ) {\n -- start ;\n }\n pBiDi -> trailingWSStart = start ;\n }", "idx": 1847}
{"hash": -3740862514502467070, "project": "debian", "size": 30, "label": 0, "functionSource": "static void dumphex ( struct hexout * hexout , FILE * temp , int length ) {\n int i , ch , ch1 ;\n if ( length & 1 ) LogError ( _ ( \"Table length should not be odd\\n\" ) ) ;\n while ( length > 65534 ) {\n dumphex ( hexout , temp , 65534 ) ;\n length -= 65534 ;\n }\n fprintf ( hexout -> type42 , \" <\\n \" ) ;\n hexout -> bytesout = 0 ;\n for ( i = 0 ;\n i < length ;\n ++ i ) {\n ch = getc ( temp ) ;\n if ( ch == EOF ) break ;\n if ( hexout -> bytesout >= 31 ) {\n fprintf ( hexout -> type42 , \"\\n \" ) ;\n hexout -> bytesout = 0 ;\n }\n ch1 = ch >> 4 ;\n if ( ch1 >= 10 ) ch1 += 'A' - 10 ;\n else ch1 += '0' ;\n putc ( ch1 , hexout -> type42 ) ;\n ch1 = ch & 0xf ;\n if ( ch1 >= 10 ) ch1 += 'A' - 10 ;\n else ch1 += '0' ;\n putc ( ch1 , hexout -> type42 ) ;\n ++ hexout -> bytesout ;\n }\n fprintf ( hexout -> type42 , \"\\n 00\\n >\\n\" ) ;\n }", "idx": 1848}
{"hash": -4558261210024070448, "project": "chrome", "size": 7, "label": 1, "functionSource": "void * xmlListSearch ( xmlListPtr l , void * data ) {\n xmlLinkPtr lk ;\n if ( l == NULL ) return ( NULL ) ;\n lk = xmlListLinkSearch ( l , data ) ;\n if ( lk ) return ( lk -> data ) ;\n return NULL ;\n }", "idx": 1849}
{"hash": 3804373597256531021, "project": "debian", "size": 16, "label": 0, "functionSource": "static void acl_update_db ( const char * user , const char * host , const char * db , ulong privileges ) {\n safe_mutex_assert_owner ( & acl_cache -> lock ) ;\n for ( uint i = 0 ;\n i < acl_dbs . elements ;\n i ++ ) {\n ACL_DB * acl_db = dynamic_element ( & acl_dbs , i , ACL_DB * ) ;\n if ( ( ! acl_db -> user && ! user [ 0 ] ) || ( acl_db -> user && ! strcmp ( user , acl_db -> user ) ) ) {\n if ( ( ! acl_db -> host . hostname && ! host [ 0 ] ) || ( acl_db -> host . hostname && ! strcmp ( host , acl_db -> host . hostname ) ) ) {\n if ( ( ! acl_db -> db && ! db [ 0 ] ) || ( acl_db -> db && ! strcmp ( db , acl_db -> db ) ) ) {\n if ( privileges ) acl_db -> access = privileges ;\n else delete_dynamic_element ( & acl_dbs , i ) ;\n }\n }\n }\n }\n }", "idx": 1850}
{"hash": 5750382823403258531, "project": "debian", "size": 3, "label": 0, "functionSource": "static void cin_apply_delta_data ( const unsigned char * src , unsigned char * dst , int size ) {\n while ( size -- ) * dst ++ += * src ++ ;\n }", "idx": 1851}
{"hash": -7690167309709817279, "project": "debian", "size": 44, "label": 0, "functionSource": "static int snmp_seq_show ( struct seq_file * seq , void * v ) {\n int i ;\n struct net * net = seq -> private ;\n seq_puts ( seq , \"Ip: Forwarding DefaultTTL\" ) ;\n for ( i = 0 ;\n snmp4_ipstats_list [ i ] . name != NULL ;\n i ++ ) seq_printf ( seq , \" %s\" , snmp4_ipstats_list [ i ] . name ) ;\n seq_printf ( seq , \"\\nIp: %d %d\" , IPV4_DEVCONF_ALL ( net , FORWARDING ) ? 1 : 2 , sysctl_ip_default_ttl ) ;\n BUILD_BUG_ON ( offsetof ( struct ipstats_mib , mibs ) != 0 ) ;\n for ( i = 0 ;\n snmp4_ipstats_list [ i ] . name != NULL ;\n i ++ ) seq_printf ( seq , \" %llu\" , snmp_fold_field64 ( ( void __percpu * * ) net -> mib . ip_statistics , snmp4_ipstats_list [ i ] . entry , offsetof ( struct ipstats_mib , syncp ) ) ) ;\n icmp_put ( seq ) ;\n icmpmsg_put ( seq ) ;\n seq_puts ( seq , \"\\nTcp:\" ) ;\n for ( i = 0 ;\n snmp4_tcp_list [ i ] . name != NULL ;\n i ++ ) seq_printf ( seq , \" %s\" , snmp4_tcp_list [ i ] . name ) ;\n seq_puts ( seq , \"\\nTcp:\" ) ;\n for ( i = 0 ;\n snmp4_tcp_list [ i ] . name != NULL ;\n i ++ ) {\n if ( snmp4_tcp_list [ i ] . entry == TCP_MIB_MAXCONN ) seq_printf ( seq , \" %ld\" , snmp_fold_field ( ( void __percpu * * ) net -> mib . tcp_statistics , snmp4_tcp_list [ i ] . entry ) ) ;\n else seq_printf ( seq , \" %lu\" , snmp_fold_field ( ( void __percpu * * ) net -> mib . tcp_statistics , snmp4_tcp_list [ i ] . entry ) ) ;\n }\n seq_puts ( seq , \"\\nUdp:\" ) ;\n for ( i = 0 ;\n snmp4_udp_list [ i ] . name != NULL ;\n i ++ ) seq_printf ( seq , \" %s\" , snmp4_udp_list [ i ] . name ) ;\n seq_puts ( seq , \"\\nUdp:\" ) ;\n for ( i = 0 ;\n snmp4_udp_list [ i ] . name != NULL ;\n i ++ ) seq_printf ( seq , \" %lu\" , snmp_fold_field ( ( void __percpu * * ) net -> mib . udp_statistics , snmp4_udp_list [ i ] . entry ) ) ;\n seq_puts ( seq , \"\\nUdpLite:\" ) ;\n for ( i = 0 ;\n snmp4_udp_list [ i ] . name != NULL ;\n i ++ ) seq_printf ( seq , \" %s\" , snmp4_udp_list [ i ] . name ) ;\n seq_puts ( seq , \"\\nUdpLite:\" ) ;\n for ( i = 0 ;\n snmp4_udp_list [ i ] . name != NULL ;\n i ++ ) seq_printf ( seq , \" %lu\" , snmp_fold_field ( ( void __percpu * * ) net -> mib . udplite_statistics , snmp4_udp_list [ i ] . entry ) ) ;\n seq_putc ( seq , '\\n' ) ;\n return 0 ;\n }", "idx": 1852}
{"hash": -5082285935423529157, "project": "debian", "size": 29, "label": 0, "functionSource": "static int dissect_rsl_ie_resource_inf ( tvbuff_t * tvb , packet_info * pinfo _U_ , proto_tree * tree , int offset , gboolean is_mandatory ) {\n proto_item * ti ;\n proto_tree * ie_tree ;\n guint8 ie_id ;\n guint length ;\n int ie_offset ;\n if ( is_mandatory == FALSE ) {\n ie_id = tvb_get_guint8 ( tvb , offset ) ;\n if ( ie_id != RSL_IE_RESOURCE_INF ) return offset ;\n }\n ie_tree = proto_tree_add_subtree ( tree , tvb , offset , 0 , ett_ie_resource_inf , & ti , \"Resource Information IE\" ) ;\n proto_tree_add_item ( ie_tree , hf_rsl_ie_id , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n offset ++ ;\n length = tvb_get_guint8 ( tvb , offset ) ;\n proto_item_set_len ( ti , length + 2 ) ;\n proto_tree_add_item ( ie_tree , hf_rsl_ie_length , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n offset ++ ;\n ie_offset = offset ;\n while ( length > 0 ) {\n proto_tree_add_item ( ie_tree , hf_rsl_ch_no_Cbits , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( ie_tree , hf_rsl_ch_no_TN , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n offset ++ ;\n proto_tree_add_item ( ie_tree , hf_rsl_interf_band , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( ie_tree , hf_rsl_interf_band_reserved , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n offset ++ ;\n length = length - 2 ;\n }\n return ie_offset + length ;\n }", "idx": 1853}
{"hash": 5347874611477979643, "project": "chrome", "size": 4, "label": 0, "functionSource": "static void test_multiple_cb ( int fd , short event , void * arg ) {\n if ( event & EV_READ ) test_ok |= 1 ;\n else if ( event & EV_WRITE ) test_ok |= 2 ;\n }", "idx": 1854}
{"hash": 1182028467273264883, "project": "debian", "size": 15, "label": 0, "functionSource": "void str_to_file2 ( const char * fname , char * str , int size , my_bool append ) {\n int fd ;\n char buff [ FN_REFLEN ] ;\n int flags = O_WRONLY | O_CREAT ;\n if ( ! test_if_hard_path ( fname ) ) {\n strxmov ( buff , opt_basedir , fname , NullS ) ;\n fname = buff ;\n }\n fn_format ( buff , fname , \"\" , \"\" , MY_UNPACK_FILENAME ) ;\n if ( ! append ) flags |= O_TRUNC ;\n if ( ( fd = my_open ( buff , flags , MYF ( MY_WME | MY_FFNF ) ) ) < 0 ) die ( \"Could not open '%s' for writing, errno: %d\" , buff , errno ) ;\n if ( append && my_seek ( fd , 0 , SEEK_END , MYF ( 0 ) ) == MY_FILEPOS_ERROR ) die ( \"Could not find end of file '%s', errno: %d\" , buff , errno ) ;\n if ( my_write ( fd , ( uchar * ) str , size , MYF ( MY_WME | MY_FNABP ) ) ) die ( \"write failed, errno: %d\" , errno ) ;\n my_close ( fd , MYF ( 0 ) ) ;\n }", "idx": 1855}
{"hash": 6752827389510428348, "project": "chrome", "size": 25, "label": 1, "functionSource": "IN_PROC_BROWSER_TEST_F ( ClientHintsBrowserTest , ClientHintsLifetimeNotAttachedJavaScriptBlocked ) {\n base : : HistogramTester histogram_tester ;\n ContentSettingsForOneType host_settings ;\n HostContentSettingsMapFactory : : GetForProfile ( browser ( ) -> profile ( ) ) -> GetSettingsForOneType ( CONTENT_SETTINGS_TYPE_CLIENT_HINTS , std : : string ( ) , & host_settings ) ;\n EXPECT_EQ ( 0u , host_settings . size ( ) ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , accept_ch_with_lifetime_url ( ) ) ;\n histogram_tester . ExpectUniqueSample ( \"ClientHints.UpdateEventCount\" , 1 , 1 ) ;\n content : : FetchHistogramsFromChildProcesses ( ) ;\n SubprocessMetricsProvider : : MergeHistogramDeltasForTesting ( ) ;\n histogram_tester . ExpectUniqueSample ( \"ClientHints.UpdateSize\" , 3 , 1 ) ;\n histogram_tester . ExpectUniqueSample ( \"ClientHints.PersistDuration\" , * 1000 , 1 ) ;\n base : : RunLoop ( ) . RunUntilIdle ( ) ;\n HostContentSettingsMapFactory : : GetForProfile ( browser ( ) -> profile ( ) ) -> GetSettingsForOneType ( CONTENT_SETTINGS_TYPE_CLIENT_HINTS , std : : string ( ) , & host_settings ) ;\n EXPECT_EQ ( 1u , host_settings . size ( ) ) ;\n HostContentSettingsMapFactory : : GetForProfile ( browser ( ) -> profile ( ) ) -> SetContentSettingDefaultScope ( without_accept_ch_without_lifetime_url ( ) , GURL ( ) , CONTENT_SETTINGS_TYPE_JAVASCRIPT , std : : string ( ) , CONTENT_SETTING_BLOCK ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , without_accept_ch_without_lifetime_url ( ) ) ;\n EXPECT_EQ ( 0u , count_client_hints_headers_seen ( ) ) ;\n HostContentSettingsMapFactory : : GetForProfile ( browser ( ) -> profile ( ) ) -> SetContentSettingDefaultScope ( without_accept_ch_without_lifetime_url ( ) , GURL ( ) , CONTENT_SETTINGS_TYPE_JAVASCRIPT , std : : string ( ) , CONTENT_SETTING_ALLOW ) ;\n SetClientHintExpectationsOnMainFrame ( true ) ;\n SetClientHintExpectationsOnSubresources ( true ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , without_accept_ch_without_lifetime_url ( ) ) ;\n # if defined ( OS_ANDROID ) EXPECT_EQ ( 4u , count_client_hints_headers_seen ( ) ) ;\n # else EXPECT_EQ ( 6u , count_client_hints_headers_seen ( ) ) ;\n # endif HostContentSettingsMapFactory : : GetForProfile ( browser ( ) -> profile ( ) ) -> ClearSettingsForOneType ( CONTENT_SETTINGS_TYPE_JAVASCRIPT ) ;\n }", "idx": 1856}
{"hash": -4178541639582894026, "project": "debian", "size": 9, "label": 0, "functionSource": "static int zmbv_decode_intra ( ZmbvContext * c ) {\n uint8_t * src = c -> decomp_buf ;\n if ( c -> fmt == ZMBV_FMT_8BPP ) {\n memcpy ( c -> pal , src , 768 ) ;\n src += 768 ;\n }\n memcpy ( c -> cur , src , c -> width * c -> height * ( c -> bpp / 8 ) ) ;\n return 0 ;\n }", "idx": 1857}
{"hash": -8028756826159773630, "project": "debian", "size": 31, "label": 0, "functionSource": "static void restore_toc_entries_prefork ( ArchiveHandle * AH ) {\n bool skipped_some ;\n TocEntry * next_work_item ;\n ahlog ( AH , 2 , \"entering restore_toc_entries_prefork\\n\" ) ;\n fix_dependencies ( AH ) ;\n skipped_some = false ;\n for ( next_work_item = AH -> toc -> next ;\n next_work_item != AH -> toc ;\n next_work_item = next_work_item -> next ) {\n if ( next_work_item -> section != SECTION_PRE_DATA ) {\n if ( next_work_item -> section == SECTION_DATA || next_work_item -> section == SECTION_POST_DATA ) {\n skipped_some = true ;\n continue ;\n }\n else {\n if ( skipped_some ) continue ;\n }\n }\n ahlog ( AH , 1 , \"processing item %d %s %s\\n\" , next_work_item -> dumpId , next_work_item -> desc , next_work_item -> tag ) ;\n ( void ) restore_toc_entry ( AH , next_work_item , false ) ;\n reduce_dependencies ( AH , next_work_item , NULL ) ;\n }\n DisconnectDatabase ( & AH -> public ) ;\n if ( AH -> currUser ) free ( AH -> currUser ) ;\n AH -> currUser = NULL ;\n if ( AH -> currSchema ) free ( AH -> currSchema ) ;\n AH -> currSchema = NULL ;\n if ( AH -> currTablespace ) free ( AH -> currTablespace ) ;\n AH -> currTablespace = NULL ;\n AH -> currWithOids = - 1 ;\n }", "idx": 1858}
{"hash": -5268859819325807498, "project": "debian", "size": 10, "label": 0, "functionSource": "static void new_files_state_unref ( NewFilesState * state ) {\n state -> count -- ;\n if ( state -> count == 0 ) {\n if ( state -> directory ) {\n state -> directory -> details -> new_files_in_progress = g_list_remove ( state -> directory -> details -> new_files_in_progress , state ) ;\n }\n g_object_unref ( state -> cancellable ) ;\n g_free ( state ) ;\n }\n }", "idx": 1859}
{"hash": -7117046864335130087, "project": "chrome", "size": 18, "label": 1, "functionSource": "int vp9_compute_qdelta ( const RATE_CONTROL * rc , double qstart , double qtarget ) {\n int start_index = rc -> worst_quality ;\n int target_index = rc -> worst_quality ;\n int i ;\n for ( i = rc -> best_quality ;\n i < rc -> worst_quality ;\n ++ i ) {\n start_index = i ;\n if ( vp9_convert_qindex_to_q ( i ) >= qstart ) break ;\n }\n for ( i = rc -> best_quality ;\n i < rc -> worst_quality ;\n ++ i ) {\n target_index = i ;\n if ( vp9_convert_qindex_to_q ( i ) >= qtarget ) break ;\n }\n return target_index - start_index ;\n }", "idx": 1860}
{"hash": 3309252579593081468, "project": "debian", "size": 175, "label": 0, "functionSource": "static int nntp_auth ( struct NntpServer * nserv ) {\n struct Connection * conn = nserv -> conn ;\n char buf [ LONG_STRING ] ;\n char authenticators [ LONG_STRING ] = \"USER\" ;\n char * method = NULL , * a = NULL , * p = NULL ;\n unsigned char flags = conn -> account . flags ;\n while ( true ) {\n if ( ( mutt_account_getuser ( & conn -> account ) < 0 ) || ( conn -> account . user [ 0 ] == '\\0' ) || ( mutt_account_getpass ( & conn -> account ) < 0 ) || ( conn -> account . pass [ 0 ] == '\\0' ) ) {\n break ;\n }\n if ( NntpAuthenticators && * NntpAuthenticators ) mutt_str_strfcpy ( authenticators , NntpAuthenticators , sizeof ( authenticators ) ) ;\n else if ( nserv -> hasCAPABILITIES ) {\n mutt_str_strfcpy ( authenticators , NONULL ( nserv -> authenticators ) , sizeof ( authenticators ) ) ;\n p = authenticators ;\n while ( * p ) {\n if ( * p == ' ' ) * p = ':' ;\n p ++ ;\n }\n }\n p = authenticators ;\n while ( * p ) {\n * p = toupper ( * p ) ;\n p ++ ;\n }\n mutt_debug ( 1 , \"available methods: %s\\n\" , nserv -> authenticators ) ;\n a = authenticators ;\n while ( true ) {\n if ( ! a ) {\n mutt_error ( _ ( \"No authenticators available\" ) ) ;\n break ;\n }\n method = a ;\n a = strchr ( a , ':' ) ;\n if ( a ) * a ++ = '\\0' ;\n if ( nserv -> hasCAPABILITIES ) {\n char * m = NULL ;\n if ( ! nserv -> authenticators ) continue ;\n m = strcasestr ( nserv -> authenticators , method ) ;\n if ( ! m ) continue ;\n if ( m > nserv -> authenticators && * ( m - 1 ) != ' ' ) continue ;\n m += strlen ( method ) ;\n if ( * m != '\\0' && * m != ' ' ) continue ;\n }\n mutt_debug ( 1 , \"trying method %s\\n\" , method ) ;\n if ( strcmp ( method , \"USER\" ) == 0 ) {\n mutt_message ( _ ( \"Authenticating (%s)...\" ) , method ) ;\n snprintf ( buf , sizeof ( buf ) , \"AUTHINFO USER %s\\r\\n\" , conn -> account . user ) ;\n if ( mutt_socket_send ( conn , buf ) < 0 || mutt_socket_readln ( buf , sizeof ( buf ) , conn ) < 0 ) {\n break ;\n }\n if ( mutt_str_strncmp ( \"281\" , buf , 3 ) == 0 ) return 0 ;\n if ( mutt_str_strncmp ( \"381\" , buf , 3 ) == 0 ) {\n if ( DebugLevel < MUTT_SOCK_LOG_FULL ) mutt_debug ( MUTT_SOCK_LOG_CMD , \"%d> AUTHINFO PASS *\\n\" , conn -> fd ) ;\n snprintf ( buf , sizeof ( buf ) , \"AUTHINFO PASS %s\\r\\n\" , conn -> account . pass ) ;\n if ( mutt_socket_send_d ( conn , buf , MUTT_SOCK_LOG_FULL ) < 0 || mutt_socket_readln ( buf , sizeof ( buf ) , conn ) < 0 ) {\n break ;\n }\n if ( mutt_str_strncmp ( \"281\" , buf , 3 ) == 0 ) return 0 ;\n }\n if ( * buf == '5' ) continue ;\n }\n else {\n # ifdef USE_SASL sasl_conn_t * saslconn = NULL ;\n sasl_interact_t * interaction = NULL ;\n int rc ;\n char inbuf [ LONG_STRING ] = \"\" ;\n const char * mech = NULL ;\n const char * client_out = NULL ;\n unsigned int client_len , len ;\n if ( mutt_sasl_client_new ( conn , & saslconn ) < 0 ) {\n mutt_debug ( 1 , \"error allocating SASL connection.\\n\" ) ;\n continue ;\n }\n while ( true ) {\n rc = sasl_client_start ( saslconn , method , & interaction , & client_out , & client_len , & mech ) ;\n if ( rc != SASL_INTERACT ) break ;\n mutt_sasl_interact ( interaction ) ;\n }\n if ( rc != SASL_OK && rc != SASL_CONTINUE ) {\n sasl_dispose ( & saslconn ) ;\n mutt_debug ( 1 , \"error starting SASL authentication exchange.\\n\" ) ;\n continue ;\n }\n mutt_message ( _ ( \"Authenticating (%s)...\" ) , method ) ;\n snprintf ( buf , sizeof ( buf ) , \"AUTHINFO SASL %s\" , method ) ;\n while ( rc == SASL_CONTINUE || ( rc == SASL_OK && client_len ) ) {\n if ( client_len ) {\n if ( DebugLevel >= MUTT_SOCK_LOG_FULL ) {\n char tmp [ LONG_STRING ] ;\n memcpy ( tmp , client_out , client_len ) ;\n for ( p = tmp ;\n p < tmp + client_len ;\n p ++ ) {\n if ( * p == '\\0' ) * p = '.' ;\n }\n * p = '\\0' ;\n mutt_debug ( 1 , \"SASL> %s\\n\" , tmp ) ;\n }\n if ( * buf ) mutt_str_strcat ( buf , sizeof ( buf ) , \" \" ) ;\n len = strlen ( buf ) ;\n if ( sasl_encode64 ( client_out , client_len , buf + len , sizeof ( buf ) - len , & len ) != SASL_OK ) {\n mutt_debug ( 1 , \"error base64-encoding client response.\\n\" ) ;\n break ;\n }\n }\n mutt_str_strcat ( buf , sizeof ( buf ) , \"\\r\\n\" ) ;\n if ( DebugLevel < MUTT_SOCK_LOG_FULL ) {\n if ( strchr ( buf , ' ' ) ) {\n mutt_debug ( MUTT_SOCK_LOG_CMD , \"%d> AUTHINFO SASL %s%s\\n\" , conn -> fd , method , client_len ? \" sasl_data\" : \"\" ) ;\n }\n else mutt_debug ( MUTT_SOCK_LOG_CMD , \"%d> sasl_data\\n\" , conn -> fd ) ;\n }\n client_len = 0 ;\n if ( mutt_socket_send_d ( conn , buf , MUTT_SOCK_LOG_FULL ) < 0 || mutt_socket_readln_d ( inbuf , sizeof ( inbuf ) , conn , MUTT_SOCK_LOG_FULL ) < 0 ) {\n break ;\n }\n if ( ( mutt_str_strncmp ( inbuf , \"283 \" , 4 ) != 0 ) && ( mutt_str_strncmp ( inbuf , \"383 \" , 4 ) != 0 ) ) {\n if ( DebugLevel < MUTT_SOCK_LOG_FULL ) mutt_debug ( MUTT_SOCK_LOG_CMD , \"%d< %s\\n\" , conn -> fd , inbuf ) ;\n break ;\n }\n if ( DebugLevel < MUTT_SOCK_LOG_FULL ) {\n inbuf [ 3 ] = '\\0' ;\n mutt_debug ( MUTT_SOCK_LOG_CMD , \"%d< %s sasl_data\\n\" , conn -> fd , inbuf ) ;\n }\n if ( strcmp ( \"=\" , inbuf + 4 ) == 0 ) len = 0 ;\n else if ( sasl_decode64 ( inbuf + 4 , strlen ( inbuf + 4 ) , buf , sizeof ( buf ) - 1 , & len ) != SASL_OK ) {\n mutt_debug ( 1 , \"error base64-decoding server response.\\n\" ) ;\n break ;\n }\n else if ( DebugLevel >= MUTT_SOCK_LOG_FULL ) {\n char tmp [ LONG_STRING ] ;\n memcpy ( tmp , buf , len ) ;\n for ( p = tmp ;\n p < tmp + len ;\n p ++ ) {\n if ( * p == '\\0' ) * p = '.' ;\n }\n * p = '\\0' ;\n mutt_debug ( 1 , \"SASL< %s\\n\" , tmp ) ;\n }\n while ( true ) {\n rc = sasl_client_step ( saslconn , buf , len , & interaction , & client_out , & client_len ) ;\n if ( rc != SASL_INTERACT ) break ;\n mutt_sasl_interact ( interaction ) ;\n }\n if ( * inbuf != '3' ) break ;\n * buf = '\\0' ;\n }\n if ( rc == SASL_OK && client_len == 0 && * inbuf == '2' ) {\n mutt_sasl_setup_conn ( conn , saslconn ) ;\n return 0 ;\n }\n sasl_dispose ( & saslconn ) ;\n if ( conn -> fd < 0 ) break ;\n if ( mutt_str_strncmp ( inbuf , \"383 \" , 4 ) == 0 ) {\n if ( mutt_socket_send ( conn , \"*\\r\\n\" ) < 0 || mutt_socket_readln ( inbuf , sizeof ( inbuf ) , conn ) < 0 ) {\n break ;\n }\n }\n if ( * inbuf == '5' ) continue ;\n # else continue ;\n # endif }\n mutt_error ( _ ( \"%s authentication failed.\" ) , method ) ;\n break ;\n }\n break ;\n }\n nserv -> status = NNTP_BYE ;\n conn -> account . flags = flags ;\n if ( conn -> fd < 0 ) {\n mutt_error ( _ ( \"Server closed connection!\" ) ) ;\n }\n else mutt_socket_close ( conn ) ;\n return - 1 ;\n }", "idx": 1861}
{"hash": -9197960073880365676, "project": "debian", "size": 14, "label": 0, "functionSource": "static char * suck_data ( char * data , int * store_len , Gif_Reader * grr ) {\n uint8_t len = gifgetbyte ( grr ) ;\n int total_len = 0 ;\n while ( len > 0 ) {\n Gif_ReArray ( data , char , total_len + len + 1 ) ;\n if ( ! data ) return 0 ;\n gifgetblock ( ( uint8_t * ) data + total_len , len , grr ) ;\n total_len += len ;\n data [ total_len ] = 0 ;\n len = gifgetbyte ( grr ) ;\n }\n if ( store_len ) * store_len = total_len ;\n return data ;\n }", "idx": 1862}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_CapabilityDescriptor ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_CapabilityDescriptor , CapabilityDescriptor_sequence ) ;\n return offset ;\n }", "idx": 1863}
{"hash": -4456702502726364053, "project": "debian", "size": 14, "label": 0, "functionSource": "static int decode_cabac_mb_cbp_chroma ( H264Context * h ) {\n int ctx ;\n int cbp_a , cbp_b ;\n cbp_a = ( h -> left_cbp >> 4 ) & 0x03 ;\n cbp_b = ( h -> top_cbp >> 4 ) & 0x03 ;\n ctx = 0 ;\n if ( cbp_a > 0 ) ctx ++ ;\n if ( cbp_b > 0 ) ctx += 2 ;\n if ( get_cabac_noinline ( & h -> cabac , & h -> cabac_state [ 77 + ctx ] ) == 0 ) return 0 ;\n ctx = 4 ;\n if ( cbp_a == 2 ) ctx ++ ;\n if ( cbp_b == 2 ) ctx += 2 ;\n return 1 + get_cabac_noinline ( & h -> cabac , & h -> cabac_state [ 77 + ctx ] ) ;\n }", "idx": 1864}
{"hash": -938099838013462850, "project": "debian", "size": 3, "label": 0, "functionSource": "static void libschroedinger_decode_buffer_free ( SchroBuffer * schro_buf , void * priv ) {\n av_freep ( & priv ) ;\n }", "idx": 1865}
{"hash": 6302861533225984845, "project": "debian", "size": 80, "label": 0, "functionSource": "PXA2xxState * pxa255_init ( MemoryRegion * address_space , unsigned int sdram_size ) {\n PXA2xxState * s ;\n int i ;\n DriveInfo * dinfo ;\n s = ( PXA2xxState * ) g_malloc0 ( sizeof ( PXA2xxState ) ) ;\n s -> cpu = cpu_arm_init ( \"pxa255\" ) ;\n if ( s -> cpu == NULL ) {\n fprintf ( stderr , \"Unable to find CPU definition\\n\" ) ;\n exit ( 1 ) ;\n }\n s -> reset = qemu_allocate_irqs ( pxa2xx_reset , s , 1 ) [ 0 ] ;\n memory_region_init_ram ( & s -> sdram , NULL , \"pxa255.sdram\" , sdram_size ) ;\n vmstate_register_ram_global ( & s -> sdram ) ;\n memory_region_add_subregion ( address_space , PXA2XX_SDRAM_BASE , & s -> sdram ) ;\n memory_region_init_ram ( & s -> internal , NULL , \"pxa255.internal\" , PXA2XX_INTERNAL_SIZE ) ;\n vmstate_register_ram_global ( & s -> internal ) ;\n memory_region_add_subregion ( address_space , PXA2XX_INTERNAL_BASE , & s -> internal ) ;\n s -> pic = pxa2xx_pic_init ( 0x40d00000 , s -> cpu ) ;\n s -> dma = pxa255_dma_init ( 0x40000000 , qdev_get_gpio_in ( s -> pic , PXA2XX_PIC_DMA ) ) ;\n sysbus_create_varargs ( \"pxa25x-timer\" , 0x40a00000 , qdev_get_gpio_in ( s -> pic , PXA2XX_PIC_OST_0 + 0 ) , qdev_get_gpio_in ( s -> pic , PXA2XX_PIC_OST_0 + 1 ) , qdev_get_gpio_in ( s -> pic , PXA2XX_PIC_OST_0 + 2 ) , qdev_get_gpio_in ( s -> pic , PXA2XX_PIC_OST_0 + 3 ) , NULL ) ;\n s -> gpio = pxa2xx_gpio_init ( 0x40e00000 , s -> cpu , s -> pic , 85 ) ;\n dinfo = drive_get ( IF_SD , 0 , 0 ) ;\n if ( ! dinfo ) {\n fprintf ( stderr , \"qemu: missing SecureDigital device\\n\" ) ;\n exit ( 1 ) ;\n }\n s -> mmc = pxa2xx_mmci_init ( address_space , 0x41100000 , dinfo -> bdrv , qdev_get_gpio_in ( s -> pic , PXA2XX_PIC_MMC ) , qdev_get_gpio_in ( s -> dma , PXA2XX_RX_RQ_MMCI ) , qdev_get_gpio_in ( s -> dma , PXA2XX_TX_RQ_MMCI ) ) ;\n for ( i = 0 ;\n pxa255_serial [ i ] . io_base ;\n i ++ ) {\n if ( serial_hds [ i ] ) {\n serial_mm_init ( address_space , pxa255_serial [ i ] . io_base , 2 , qdev_get_gpio_in ( s -> pic , pxa255_serial [ i ] . irqn ) , 14745600 / 16 , serial_hds [ i ] , DEVICE_NATIVE_ENDIAN ) ;\n }\n else {\n break ;\n }\n }\n if ( serial_hds [ i ] ) s -> fir = pxa2xx_fir_init ( address_space , 0x40800000 , qdev_get_gpio_in ( s -> pic , PXA2XX_PIC_ICP ) , qdev_get_gpio_in ( s -> dma , PXA2XX_RX_RQ_ICP ) , qdev_get_gpio_in ( s -> dma , PXA2XX_TX_RQ_ICP ) , serial_hds [ i ] ) ;\n s -> lcd = pxa2xx_lcdc_init ( address_space , 0x44000000 , qdev_get_gpio_in ( s -> pic , PXA2XX_PIC_LCD ) ) ;\n s -> cm_base = 0x41300000 ;\n s -> cm_regs [ CCCR >> 2 ] = 0x02000210 ;\n s -> clkcfg = 0x00000009 ;\n memory_region_init_io ( & s -> cm_iomem , NULL , & pxa2xx_cm_ops , s , \"pxa2xx-cm\" , 0x1000 ) ;\n memory_region_add_subregion ( address_space , s -> cm_base , & s -> cm_iomem ) ;\n vmstate_register ( NULL , 0 , & vmstate_pxa2xx_cm , s ) ;\n pxa2xx_setup_cp14 ( s ) ;\n s -> mm_base = 0x48000000 ;\n s -> mm_regs [ MDMRS >> 2 ] = 0x00020002 ;\n s -> mm_regs [ MDREFR >> 2 ] = 0x03ca4000 ;\n s -> mm_regs [ MECR >> 2 ] = 0x00000001 ;\n memory_region_init_io ( & s -> mm_iomem , NULL , & pxa2xx_mm_ops , s , \"pxa2xx-mm\" , 0x1000 ) ;\n memory_region_add_subregion ( address_space , s -> mm_base , & s -> mm_iomem ) ;\n vmstate_register ( NULL , 0 , & vmstate_pxa2xx_mm , s ) ;\n s -> pm_base = 0x40f00000 ;\n memory_region_init_io ( & s -> pm_iomem , NULL , & pxa2xx_pm_ops , s , \"pxa2xx-pm\" , 0x100 ) ;\n memory_region_add_subregion ( address_space , s -> pm_base , & s -> pm_iomem ) ;\n vmstate_register ( NULL , 0 , & vmstate_pxa2xx_pm , s ) ;\n for ( i = 0 ;\n pxa255_ssp [ i ] . io_base ;\n i ++ ) ;\n s -> ssp = ( SSIBus * * ) g_malloc0 ( sizeof ( SSIBus * ) * i ) ;\n for ( i = 0 ;\n pxa255_ssp [ i ] . io_base ;\n i ++ ) {\n DeviceState * dev ;\n dev = sysbus_create_simple ( \"pxa2xx-ssp\" , pxa255_ssp [ i ] . io_base , qdev_get_gpio_in ( s -> pic , pxa255_ssp [ i ] . irqn ) ) ;\n s -> ssp [ i ] = ( SSIBus * ) qdev_get_child_bus ( dev , \"ssi\" ) ;\n }\n if ( usb_enabled ( false ) ) {\n sysbus_create_simple ( \"sysbus-ohci\" , 0x4c000000 , qdev_get_gpio_in ( s -> pic , PXA2XX_PIC_USBH1 ) ) ;\n }\n s -> pcmcia [ 0 ] = pxa2xx_pcmcia_init ( address_space , 0x20000000 ) ;\n s -> pcmcia [ 1 ] = pxa2xx_pcmcia_init ( address_space , 0x30000000 ) ;\n sysbus_create_simple ( \"pxa2xx_rtc\" , 0x40900000 , qdev_get_gpio_in ( s -> pic , PXA2XX_PIC_RTCALARM ) ) ;\n s -> i2c [ 0 ] = pxa2xx_i2c_init ( 0x40301600 , qdev_get_gpio_in ( s -> pic , PXA2XX_PIC_I2C ) , 0xffff ) ;\n s -> i2c [ 1 ] = pxa2xx_i2c_init ( 0x40f00100 , qdev_get_gpio_in ( s -> pic , PXA2XX_PIC_PWRI2C ) , 0xff ) ;\n s -> i2s = pxa2xx_i2s_init ( address_space , 0x40400000 , qdev_get_gpio_in ( s -> pic , PXA2XX_PIC_I2S ) , qdev_get_gpio_in ( s -> dma , PXA2XX_RX_RQ_I2S ) , qdev_get_gpio_in ( s -> dma , PXA2XX_TX_RQ_I2S ) ) ;\n qdev_connect_gpio_out ( s -> gpio , 1 , s -> reset ) ;\n return s ;\n }", "idx": 1866}
{"hash": 3919646340804521652, "project": "debian", "size": 79, "label": 0, "functionSource": "static void find_deltas ( struct object_entry * * list , unsigned * list_size , int window , int depth , unsigned * processed ) {\n uint32_t i , idx = 0 , count = 0 ;\n struct unpacked * array ;\n unsigned long mem_usage = 0 ;\n array = xcalloc ( window , sizeof ( struct unpacked ) ) ;\n for ( ;\n ;\n ) {\n struct object_entry * entry ;\n struct unpacked * n = array + idx ;\n int j , max_depth , best_base = - 1 ;\n progress_lock ( ) ;\n if ( ! * list_size ) {\n progress_unlock ( ) ;\n break ;\n }\n entry = * list ++ ;\n ( * list_size ) -- ;\n if ( ! entry -> preferred_base ) {\n ( * processed ) ++ ;\n display_progress ( progress_state , * processed ) ;\n }\n progress_unlock ( ) ;\n mem_usage -= free_unpacked ( n ) ;\n n -> entry = entry ;\n while ( window_memory_limit && mem_usage > window_memory_limit && count > 1 ) {\n uint32_t tail = ( idx + window - count ) % window ;\n mem_usage -= free_unpacked ( array + tail ) ;\n count -- ;\n }\n if ( entry -> preferred_base ) goto next ;\n max_depth = depth ;\n if ( entry -> delta_child ) {\n max_depth -= check_delta_limit ( entry , 0 ) ;\n if ( max_depth <= 0 ) goto next ;\n }\n j = window ;\n while ( -- j > 0 ) {\n int ret ;\n uint32_t other_idx = idx + j ;\n struct unpacked * m ;\n if ( other_idx >= window ) other_idx -= window ;\n m = array + other_idx ;\n if ( ! m -> entry ) break ;\n ret = try_delta ( n , m , max_depth , & mem_usage ) ;\n if ( ret < 0 ) break ;\n else if ( ret > 0 ) best_base = other_idx ;\n }\n if ( entry -> delta_data && ! pack_to_stdout ) {\n entry -> z_delta_size = do_compress ( & entry -> delta_data , entry -> delta_size ) ;\n cache_lock ( ) ;\n delta_cache_size -= entry -> delta_size ;\n delta_cache_size += entry -> z_delta_size ;\n cache_unlock ( ) ;\n }\n if ( entry -> delta && max_depth <= n -> depth ) continue ;\n if ( entry -> delta ) {\n struct unpacked swap = array [ best_base ] ;\n int dist = ( window + idx - best_base ) % window ;\n int dst = best_base ;\n while ( dist -- ) {\n int src = ( dst + 1 ) % window ;\n array [ dst ] = array [ src ] ;\n dst = src ;\n }\n array [ dst ] = swap ;\n }\n next : idx ++ ;\n if ( count + 1 < window ) count ++ ;\n if ( idx >= window ) idx = 0 ;\n }\n for ( i = 0 ;\n i < window ;\n ++ i ) {\n free_delta_index ( array [ i ] . index ) ;\n free ( array [ i ] . data ) ;\n }\n free ( array ) ;\n }", "idx": 1867}
{"hash": 1458662858915721428, "project": "debian", "size": 14, "label": 0, "functionSource": "static inline size_t size_code_gen_buffer ( size_t tb_size ) {\n if ( tb_size == 0 ) {\n # ifdef USE_STATIC_CODE_GEN_BUFFER tb_size = DEFAULT_CODE_GEN_BUFFER_SIZE ;\n # else tb_size = ( unsigned long ) ( ram_size / 4 ) ;\n # endif }\n if ( tb_size < MIN_CODE_GEN_BUFFER_SIZE ) {\n tb_size = MIN_CODE_GEN_BUFFER_SIZE ;\n }\n if ( tb_size > MAX_CODE_GEN_BUFFER_SIZE ) {\n tb_size = MAX_CODE_GEN_BUFFER_SIZE ;\n }\n tcg_ctx . code_gen_buffer_size = tb_size ;\n return tb_size ;\n }", "idx": 1868}
{"hash": -5992472514718425579, "project": "debian", "size": 180, "label": 0, "functionSource": "static struct cgroup_process_info * lxc_cgroupfs_create ( const char * name , const char * path_pattern , struct cgroup_meta_data * meta_data , const char * sub_pattern ) {\n char * * cgroup_path_components = NULL ;\n char * * p = NULL ;\n char * path_so_far = NULL ;\n char * * new_cgroup_paths = NULL ;\n char * * new_cgroup_paths_sub = NULL ;\n struct cgroup_mount_point * mp ;\n struct cgroup_hierarchy * h ;\n struct cgroup_process_info * base_info = NULL ;\n struct cgroup_process_info * info_ptr ;\n int saved_errno ;\n int r ;\n unsigned suffix = 0 ;\n bool had_sub_pattern = false ;\n size_t i ;\n if ( ! is_valid_cgroup ( name ) ) {\n ERROR ( \"Invalid cgroup name: '%s'\" , name ) ;\n errno = EINVAL ;\n return NULL ;\n }\n if ( ! strstr ( path_pattern , \"%n\" ) ) {\n ERROR ( \"Invalid cgroup path pattern: '%s';\n contains no %%n for specifying container name\" , path_pattern ) ;\n errno = EINVAL ;\n return NULL ;\n }\n base_info = ( path_pattern [ 0 ] == '/' ) ? lxc_cgroup_process_info_get_init ( meta_data ) : lxc_cgroup_process_info_get_self ( meta_data ) ;\n if ( ! base_info ) return NULL ;\n new_cgroup_paths = calloc ( meta_data -> maximum_hierarchy + 1 , sizeof ( char * ) ) ;\n if ( ! new_cgroup_paths ) goto out_initial_error ;\n new_cgroup_paths_sub = calloc ( meta_data -> maximum_hierarchy + 1 , sizeof ( char * ) ) ;\n if ( ! new_cgroup_paths_sub ) goto out_initial_error ;\n for ( info_ptr = base_info ;\n info_ptr ;\n info_ptr = info_ptr -> next ) {\n h = info_ptr -> hierarchy ;\n mp = lxc_cgroup_find_mount_point ( h , info_ptr -> cgroup_path , true ) ;\n if ( ! mp ) {\n ERROR ( \"Could not find writable mount point for cgroup hierarchy %d while trying to create cgroup.\" , h -> index ) ;\n goto out_initial_error ;\n }\n info_ptr -> designated_mount_point = mp ;\n if ( lxc_string_in_array ( \"ns\" , ( const char * * ) h -> subsystems ) ) continue ;\n if ( handle_cgroup_settings ( mp , info_ptr -> cgroup_path ) < 0 ) {\n ERROR ( \"Could not set clone_children to 1 for cpuset hierarchy in parent cgroup.\" ) ;\n goto out_initial_error ;\n }\n }\n cgroup_path_components = lxc_normalize_path ( path_pattern ) ;\n if ( ! cgroup_path_components ) goto out_initial_error ;\n for ( p = cgroup_path_components ;\n * p || ( sub_pattern && ! had_sub_pattern ) ;\n p ++ ) {\n char * p_eff = * p ? * p : ( char * ) sub_pattern ;\n bool contains_name = strstr ( p_eff , \"%n\" ) ;\n char * current_component = NULL ;\n char * current_subpath = NULL ;\n char * current_entire_path = NULL ;\n char * parts [ 3 ] ;\n size_t j = 0 ;\n i = 0 ;\n if ( ! * p ) {\n had_sub_pattern = true ;\n p -- ;\n }\n goto find_name_on_this_level ;\n cleanup_name_on_this_level : for ( j = 0 , info_ptr = base_info ;\n j < i && info_ptr ;\n info_ptr = info_ptr -> next , j ++ ) {\n r = remove_cgroup ( info_ptr -> designated_mount_point , info_ptr -> created_paths [ info_ptr -> created_paths_count - 1 ] , false ) ;\n if ( r < 0 ) WARN ( \"could not clean up cgroup we created when trying to create container\" ) ;\n free ( info_ptr -> created_paths [ info_ptr -> created_paths_count - 1 ] ) ;\n info_ptr -> created_paths [ -- info_ptr -> created_paths_count ] = NULL ;\n }\n if ( current_component != current_subpath ) free ( current_subpath ) ;\n if ( current_component != p_eff ) free ( current_component ) ;\n current_component = current_subpath = NULL ;\n ++ suffix ;\n find_name_on_this_level : if ( contains_name && suffix > 0 ) {\n char * buf = calloc ( strlen ( name ) + 32 , 1 ) ;\n if ( ! buf ) goto out_initial_error ;\n snprintf ( buf , strlen ( name ) + 32 , \"%s-%u\" , name , suffix ) ;\n current_component = lxc_string_replace ( \"%n\" , buf , p_eff ) ;\n free ( buf ) ;\n }\n else {\n current_component = contains_name ? lxc_string_replace ( \"%n\" , name , p_eff ) : p_eff ;\n }\n parts [ 0 ] = path_so_far ;\n parts [ 1 ] = current_component ;\n parts [ 2 ] = NULL ;\n current_subpath = path_so_far ? lxc_string_join ( \"/\" , ( const char * * ) parts , false ) : current_component ;\n for ( i = 0 , info_ptr = base_info ;\n info_ptr ;\n info_ptr = info_ptr -> next , i ++ ) {\n char * parts2 [ 3 ] ;\n if ( lxc_string_in_array ( \"ns\" , ( const char * * ) info_ptr -> hierarchy -> subsystems ) ) continue ;\n current_entire_path = NULL ;\n parts2 [ 0 ] = ! strcmp ( info_ptr -> cgroup_path , \"/\" ) ? \"\" : info_ptr -> cgroup_path ;\n parts2 [ 1 ] = current_subpath ;\n parts2 [ 2 ] = NULL ;\n current_entire_path = lxc_string_join ( \"/\" , ( const char * * ) parts2 , false ) ;\n if ( ! * p ) {\n free ( new_cgroup_paths_sub [ i ] ) ;\n new_cgroup_paths_sub [ i ] = strdup ( current_entire_path ) ;\n if ( ! new_cgroup_paths_sub [ i ] ) goto cleanup_from_error ;\n }\n else {\n free ( new_cgroup_paths [ i ] ) ;\n new_cgroup_paths [ i ] = strdup ( current_entire_path ) ;\n if ( ! new_cgroup_paths [ i ] ) goto cleanup_from_error ;\n }\n r = create_cgroup ( info_ptr -> designated_mount_point , current_entire_path ) ;\n if ( r < 0 && errno == EEXIST && contains_name ) {\n free ( current_entire_path ) ;\n current_entire_path = NULL ;\n goto cleanup_name_on_this_level ;\n }\n else if ( r < 0 && errno != EEXIST ) {\n SYSERROR ( \"Could not create cgroup '%s' in '%s'.\" , current_entire_path , info_ptr -> designated_mount_point -> mount_point ) ;\n goto cleanup_from_error ;\n }\n else if ( r == 0 ) {\n r = lxc_grow_array ( ( void * * * ) & info_ptr -> created_paths , & info_ptr -> created_paths_capacity , info_ptr -> created_paths_count + 1 , 8 ) ;\n if ( r < 0 ) goto cleanup_from_error ;\n if ( ! init_cpuset_if_needed ( info_ptr -> designated_mount_point , current_entire_path ) ) {\n ERROR ( \"Failed to initialize cpuset for '%s' in '%s'.\" , current_entire_path , info_ptr -> designated_mount_point -> mount_point ) ;\n goto cleanup_from_error ;\n }\n info_ptr -> created_paths [ info_ptr -> created_paths_count ++ ] = current_entire_path ;\n }\n else {\n if ( handle_cgroup_settings ( info_ptr -> designated_mount_point , info_ptr -> cgroup_path ) < 0 ) {\n ERROR ( \"Could not set clone_children to 1 for cpuset hierarchy in pre-existing cgroup.\" ) ;\n goto cleanup_from_error ;\n }\n if ( ! init_cpuset_if_needed ( info_ptr -> designated_mount_point , info_ptr -> cgroup_path ) ) {\n ERROR ( \"Failed to initialize cpuset in pre-existing '%s'.\" , info_ptr -> cgroup_path ) ;\n goto cleanup_from_error ;\n }\n free ( current_entire_path ) ;\n current_entire_path = NULL ;\n }\n }\n free ( path_so_far ) ;\n path_so_far = strdup ( current_subpath ) ;\n if ( ! path_so_far ) goto cleanup_from_error ;\n if ( current_component != current_subpath ) free ( current_subpath ) ;\n if ( current_component != p_eff ) free ( current_component ) ;\n current_component = current_subpath = NULL ;\n continue ;\n cleanup_from_error : saved_errno = errno ;\n if ( current_component != current_subpath ) free ( current_subpath ) ;\n if ( current_component != p_eff ) free ( current_component ) ;\n free ( current_entire_path ) ;\n errno = saved_errno ;\n goto out_initial_error ;\n }\n for ( i = 0 , info_ptr = base_info ;\n info_ptr ;\n info_ptr = info_ptr -> next , i ++ ) {\n if ( lxc_string_in_array ( \"ns\" , ( const char * * ) info_ptr -> hierarchy -> subsystems ) ) continue ;\n free ( info_ptr -> cgroup_path ) ;\n info_ptr -> cgroup_path = new_cgroup_paths [ i ] ;\n info_ptr -> cgroup_path_sub = new_cgroup_paths_sub [ i ] ;\n }\n free ( new_cgroup_paths ) ;\n free ( new_cgroup_paths_sub ) ;\n free ( path_so_far ) ;\n lxc_free_array ( ( void * * ) cgroup_path_components , free ) ;\n return base_info ;\n out_initial_error : saved_errno = errno ;\n free ( path_so_far ) ;\n lxc_cgroup_process_info_free_and_remove ( base_info ) ;\n lxc_free_array ( ( void * * ) new_cgroup_paths , free ) ;\n lxc_free_array ( ( void * * ) new_cgroup_paths_sub , free ) ;\n lxc_free_array ( ( void * * ) cgroup_path_components , free ) ;\n errno = saved_errno ;\n return NULL ;\n }", "idx": 1869}
{"hash": -3740862514502467070, "project": "debian", "size": 11, "label": 0, "functionSource": "void SFDefaultOS2SubSuper ( struct pfminfo * pfminfo , int emsize , double italic_angle ) {\n double s = sin ( italic_angle * 3.1415926535897932 / 180.0 ) ;\n pfminfo -> os2_supysize = pfminfo -> os2_subysize = .7 * emsize ;\n pfminfo -> os2_supxsize = pfminfo -> os2_subxsize = .65 * emsize ;\n pfminfo -> os2_subyoff = .14 * emsize ;\n pfminfo -> os2_supyoff = .48 * emsize ;\n pfminfo -> os2_supxoff = s * pfminfo -> os2_supyoff ;\n pfminfo -> os2_subxoff = - s * pfminfo -> os2_subyoff ;\n pfminfo -> os2_strikeysize = 102 * emsize / 2048 ;\n pfminfo -> os2_strikeypos = 530 * emsize / 2048 ;\n }", "idx": 1870}
{"hash": -8503439282031333562, "project": "debian", "size": 36, "label": 0, "functionSource": "int tmx_init_pretran_table ( void ) {\n int n ;\n int pn ;\n pn = get_max_procs ( ) ;\n if ( pn <= 0 ) return - 1 ;\n if ( _tmx_ptran_table != NULL ) return - 1 ;\n n = - 1 ;\n while ( pn >> ++ n > 0 ) ;\n n -- ;\n if ( n <= 1 ) n = 2 ;\n if ( n > 8 ) n = 8 ;\n _tmx_ptran_size = 1 << n ;\n _tmx_ptran_table = ( pretran_slot_t * ) shm_malloc ( _tmx_ptran_size * sizeof ( pretran_slot_t ) ) ;\n if ( _tmx_ptran_table == NULL ) {\n LM_ERR ( \"not enough shared memory\\n\" ) ;\n return - 1 ;\n }\n memset ( _tmx_ptran_table , 0 , _tmx_ptran_size * sizeof ( pretran_slot_t ) ) ;\n for ( n = 0 ;\n n < _tmx_ptran_size ;\n n ++ ) {\n if ( lock_init ( & _tmx_ptran_table [ n ] . lock ) == NULL ) {\n LM_ERR ( \"cannot init the lock %d\\n\" , n ) ;\n n -- ;\n while ( n >= 0 ) {\n lock_destroy ( & _tmx_ptran_table [ n ] . lock ) ;\n n -- ;\n }\n shm_free ( _tmx_ptran_table ) ;\n _tmx_ptran_table = 0 ;\n _tmx_ptran_size = 0 ;\n return - 1 ;\n }\n }\n return 0 ;\n }", "idx": 1871}
{"hash": 4483118303465294401, "project": "chrome", "size": 117, "label": 0, "functionSource": "static const char * parseState ( const char * s , int32_t state [ 256 ] , uint32_t * pFlags ) {\n const char * t ;\n uint32_t start , end , i ;\n int32_t entry ;\n for ( i = 0 ;\n i < 256 ;\n ++ i ) {\n state [ i ] = MBCS_ENTRY_FINAL ( 0 , MBCS_STATE_ILLEGAL , 0xffff ) ;\n }\n s = u_skipWhitespace ( s ) ;\n if ( uprv_strncmp ( \"initial\" , s , 7 ) == 0 ) {\n * pFlags = MBCS_STATE_FLAG_DIRECT ;\n s = u_skipWhitespace ( s + 7 ) ;\n if ( * s ++ != ',' ) {\n return s - 1 ;\n }\n }\n else if ( * pFlags == 0 && uprv_strncmp ( \"surrogates\" , s , 10 ) == 0 ) {\n * pFlags = MBCS_STATE_FLAG_SURROGATES ;\n s = u_skipWhitespace ( s + 10 ) ;\n if ( * s ++ != ',' ) {\n return s - 1 ;\n }\n }\n else if ( * s == 0 ) {\n return NULL ;\n }\n for ( ;\n ;\n ) {\n s = u_skipWhitespace ( s ) ;\n start = uprv_strtoul ( s , ( char * * ) & t , 16 ) ;\n if ( s == t || 0xff < start ) {\n return s ;\n }\n s = u_skipWhitespace ( t ) ;\n if ( * s == '-' ) {\n s = u_skipWhitespace ( s + 1 ) ;\n end = uprv_strtoul ( s , ( char * * ) & t , 16 ) ;\n if ( s == t || end < start || 0xff < end ) {\n return s ;\n }\n s = u_skipWhitespace ( t ) ;\n }\n else {\n end = start ;\n }\n if ( * s != ':' && * s != '.' ) {\n entry = MBCS_ENTRY_FINAL ( 0 , MBCS_STATE_VALID_16 , 0 ) ;\n }\n else {\n entry = MBCS_ENTRY_TRANSITION ( 0 , 0 ) ;\n if ( * s == ':' ) {\n s = u_skipWhitespace ( s + 1 ) ;\n i = uprv_strtoul ( s , ( char * * ) & t , 16 ) ;\n if ( s != t ) {\n if ( 0x7f < i ) {\n return s ;\n }\n s = u_skipWhitespace ( t ) ;\n entry = MBCS_ENTRY_SET_STATE ( entry , i ) ;\n }\n }\n if ( * s == '.' ) {\n entry = MBCS_ENTRY_SET_FINAL ( entry ) ;\n s = u_skipWhitespace ( s + 1 ) ;\n if ( * s == 'u' ) {\n entry = MBCS_ENTRY_FINAL_SET_ACTION_VALUE ( entry , MBCS_STATE_UNASSIGNED , 0xfffe ) ;\n s = u_skipWhitespace ( s + 1 ) ;\n }\n else if ( * s == 'p' ) {\n if ( * pFlags != MBCS_STATE_FLAG_DIRECT ) {\n entry = MBCS_ENTRY_FINAL_SET_ACTION ( entry , MBCS_STATE_VALID_16_PAIR ) ;\n }\n else {\n entry = MBCS_ENTRY_FINAL_SET_ACTION ( entry , MBCS_STATE_VALID_16 ) ;\n }\n s = u_skipWhitespace ( s + 1 ) ;\n }\n else if ( * s == 's' ) {\n entry = MBCS_ENTRY_FINAL_SET_ACTION ( entry , MBCS_STATE_CHANGE_ONLY ) ;\n s = u_skipWhitespace ( s + 1 ) ;\n }\n else if ( * s == 'i' ) {\n entry = MBCS_ENTRY_FINAL_SET_ACTION_VALUE ( entry , MBCS_STATE_ILLEGAL , 0xffff ) ;\n s = u_skipWhitespace ( s + 1 ) ;\n }\n else {\n entry = MBCS_ENTRY_FINAL_SET_ACTION ( entry , MBCS_STATE_VALID_16 ) ;\n }\n }\n else {\n }\n }\n if ( MBCS_ENTRY_FINAL_ACTION ( entry ) == MBCS_STATE_VALID_16 ) {\n switch ( * pFlags ) {\n case 0 : break ;\n case MBCS_STATE_FLAG_DIRECT : entry = MBCS_ENTRY_FINAL_SET_ACTION_VALUE ( entry , MBCS_STATE_VALID_DIRECT_16 , 0xfffe ) ;\n break ;\n case MBCS_STATE_FLAG_SURROGATES : entry = MBCS_ENTRY_FINAL_SET_ACTION_VALUE ( entry , MBCS_STATE_VALID_16_PAIR , 0 ) ;\n break ;\n default : break ;\n }\n }\n for ( i = start ;\n i <= end ;\n ++ i ) {\n state [ i ] = entry ;\n }\n if ( * s == ',' ) {\n ++ s ;\n }\n else {\n return * s == 0 ? NULL : s ;\n }\n }\n }", "idx": 1872}
{"hash": 1182028467273264883, "project": "debian", "size": 5, "label": 0, "functionSource": "void free_last_set ( REP_SETS * sets ) {\n sets -> count -- ;\n sets -> extra ++ ;\n return ;\n }", "idx": 1873}
{"hash": -1315695702746584250, "project": "debian", "size": 14, "label": 0, "functionSource": "proto_item * proto_tree_add_text_valist_internal ( proto_tree * tree , tvbuff_t * tvb , gint start , gint length , const char * format , va_list ap ) {\n proto_item * pi ;\n header_field_info * hfinfo ;\n if ( length == - 1 ) {\n length = 0 ;\n }\n tvb_ensure_bytes_exist ( tvb , start , length ) ;\n CHECK_FOR_NULL_TREE ( tree ) ;\n TRY_TO_FAKE_THIS_ITEM ( tree , hf_text_only , hfinfo ) ;\n pi = proto_tree_add_text_node ( tree , tvb , start , length ) ;\n TRY_TO_FAKE_THIS_REPR ( pi ) ;\n proto_tree_set_representation ( pi , format , ap ) ;\n return pi ;\n }", "idx": 1874}
{"hash": -3053641395158209010, "project": "debian", "size": 52, "label": 0, "functionSource": "static int x ( struct vcache * avc , int afun , struct vrequest * areq , \\ struct afs_pdata * ain , struct afs_pdata * aout , \\ afs_ucred_t * * acred ) DECL_PIOCTL ( PGetFID ) ;\n DECL_PIOCTL ( PSetAcl ) ;\n DECL_PIOCTL ( PStoreBehind ) ;\n DECL_PIOCTL ( PGCPAGs ) ;\n DECL_PIOCTL ( PGetAcl ) ;\n DECL_PIOCTL ( PNoop ) ;\n DECL_PIOCTL ( PBogus ) ;\n DECL_PIOCTL ( PGetFileCell ) ;\n DECL_PIOCTL ( PGetWSCell ) ;\n DECL_PIOCTL ( PGetUserCell ) ;\n DECL_PIOCTL ( PSetTokens ) ;\n DECL_PIOCTL ( PGetVolumeStatus ) ;\n DECL_PIOCTL ( PSetVolumeStatus ) ;\n DECL_PIOCTL ( PFlush ) ;\n DECL_PIOCTL ( PNewStatMount ) ;\n DECL_PIOCTL ( PGetTokens ) ;\n DECL_PIOCTL ( PUnlog ) ;\n DECL_PIOCTL ( PMariner ) ;\n DECL_PIOCTL ( PCheckServers ) ;\n DECL_PIOCTL ( PCheckVolNames ) ;\n DECL_PIOCTL ( PCheckAuth ) ;\n DECL_PIOCTL ( PFindVolume ) ;\n DECL_PIOCTL ( PViceAccess ) ;\n DECL_PIOCTL ( PSetCacheSize ) ;\n DECL_PIOCTL ( PGetCacheSize ) ;\n DECL_PIOCTL ( PRemoveCallBack ) ;\n DECL_PIOCTL ( PNewCell ) ;\n DECL_PIOCTL ( PNewAlias ) ;\n DECL_PIOCTL ( PListCells ) ;\n DECL_PIOCTL ( PListAliases ) ;\n DECL_PIOCTL ( PRemoveMount ) ;\n DECL_PIOCTL ( PGetCellStatus ) ;\n DECL_PIOCTL ( PSetCellStatus ) ;\n DECL_PIOCTL ( PFlushVolumeData ) ;\n DECL_PIOCTL ( PFlushAllVolumeData ) ;\n DECL_PIOCTL ( PGetVnodeXStatus ) ;\n DECL_PIOCTL ( PGetVnodeXStatus2 ) ;\n DECL_PIOCTL ( PSetSysName ) ;\n DECL_PIOCTL ( PSetSPrefs ) ;\n DECL_PIOCTL ( PSetSPrefs33 ) ;\n DECL_PIOCTL ( PGetSPrefs ) ;\n DECL_PIOCTL ( PExportAfs ) ;\n DECL_PIOCTL ( PGag ) ;\n DECL_PIOCTL ( PTwiddleRx ) ;\n DECL_PIOCTL ( PGetInitParams ) ;\n DECL_PIOCTL ( PGetRxkcrypt ) ;\n DECL_PIOCTL ( PSetRxkcrypt ) ;\n DECL_PIOCTL ( PGetCPrefs ) ;\n DECL_PIOCTL ( PSetCPrefs ) ;\n DECL_PIOCTL ( PFlushMount ) ;\n DECL_PIOCTL ( PRxStatProc ) ;\n DECL_PIOCTL ( PRxStatPeer )", "idx": 1875}
{"hash": 1353431100313404503, "project": "chrome", "size": 16, "label": 0, "functionSource": "static void resize_context_buffers ( VP9_COMMON * cm , int width , int height ) {\n # if CONFIG_SIZE_LIMIT if ( width > DECODE_WIDTH_LIMIT || height > DECODE_HEIGHT_LIMIT ) vpx_internal_error ( & cm -> error , VPX_CODEC_CORRUPT_FRAME , \"Width and height beyond allowed size.\" ) ;\n # endif if ( cm -> width != width || cm -> height != height ) {\n const int new_mi_rows = ALIGN_POWER_OF_TWO ( height , MI_SIZE_LOG2 ) >> MI_SIZE_LOG2 ;\n const int new_mi_cols = ALIGN_POWER_OF_TWO ( width , MI_SIZE_LOG2 ) >> MI_SIZE_LOG2 ;\n if ( new_mi_cols > cm -> mi_cols || new_mi_rows > cm -> mi_rows ) {\n if ( vp9_alloc_context_buffers ( cm , width , height ) ) vpx_internal_error ( & cm -> error , VPX_CODEC_MEM_ERROR , \"Failed to allocate context buffers\" ) ;\n }\n else {\n vp9_set_mb_mi ( cm , width , height ) ;\n }\n vp9_init_context_buffers ( cm ) ;\n cm -> width = width ;\n cm -> height = height ;\n }\n }", "idx": 1876}
{"hash": 1760449185745615462, "project": "debian", "size": 3, "label": 0, "functionSource": "TSReturnCode TSUrlHttpQuerySet ( TSMBuffer bufp , TSMLoc obj , const char * value , int length ) {\n return URLPartSet ( bufp , obj , value , length , & URL : : query_set ) ;\n }", "idx": 1877}
{"hash": -4078760840682683657, "project": "chrome", "size": 11, "label": 0, "functionSource": "static int read_skip ( VP9_COMMON * cm , const MACROBLOCKD * xd , int segment_id , vp9_reader * r ) {\n if ( vp9_segfeature_active ( & cm -> seg , segment_id , SEG_LVL_SKIP ) ) {\n return 1 ;\n }\n else {\n const int ctx = vp9_get_skip_context ( xd ) ;\n const int skip = vp9_read ( r , cm -> fc . skip_probs [ ctx ] ) ;\n if ( ! cm -> frame_parallel_decoding_mode ) ++ cm -> counts . skip [ ctx ] [ skip ] ;\n return skip ;\n }\n }", "idx": 1878}
{"hash": -7455544248455991006, "project": "debian", "size": 21, "label": 0, "functionSource": "int kvm_arch_fixup_msi_route ( struct kvm_irq_routing_entry * route , uint64_t address , uint32_t data , PCIDevice * dev ) {\n X86IOMMUState * iommu = x86_iommu_get_default ( ) ;\n if ( iommu ) {\n int ret ;\n MSIMessage src , dst ;\n X86IOMMUClass * class = X86_IOMMU_GET_CLASS ( iommu ) ;\n src . address = route -> u . msi . address_hi ;\n src . address <<= VTD_MSI_ADDR_HI_SHIFT ;\n src . address |= route -> u . msi . address_lo ;\n src . data = route -> u . msi . data ;\n ret = class -> int_remap ( iommu , & src , & dst , dev ? pci_requester_id ( dev ) : X86_IOMMU_SID_INVALID ) ;\n if ( ret ) {\n trace_kvm_x86_fixup_msi_error ( route -> gsi ) ;\n return 1 ;\n }\n route -> u . msi . address_hi = dst . address >> VTD_MSI_ADDR_HI_SHIFT ;\n route -> u . msi . address_lo = dst . address & VTD_MSI_ADDR_LO_MASK ;\n route -> u . msi . data = dst . data ;\n }\n return 0 ;\n }", "idx": 1879}
{"hash": 3502077845611765963, "project": "debian", "size": 11, "label": 0, "functionSource": "static struct cvec * allcases ( struct vars * v , chr pc ) {\n struct cvec * cv ;\n chr c = ( chr ) pc ;\n chr lc , uc ;\n lc = pg_wc_tolower ( ( chr ) c ) ;\n uc = pg_wc_toupper ( ( chr ) c ) ;\n cv = getcvec ( v , 2 , 0 ) ;\n addchr ( cv , lc ) ;\n if ( lc != uc ) addchr ( cv , uc ) ;\n return cv ;\n }", "idx": 1880}
{"hash": 5468438784905165517, "project": "debian", "size": 36, "label": 0, "functionSource": "int ec_GF2m_simple_mul ( const EC_GROUP * group , EC_POINT * r , const BIGNUM * scalar , size_t num , const EC_POINT * points [ ] , const BIGNUM * scalars [ ] , BN_CTX * ctx ) {\n BN_CTX * new_ctx = NULL ;\n int ret = 0 ;\n size_t i ;\n EC_POINT * p = NULL ;\n EC_POINT * acc = NULL ;\n if ( ctx == NULL ) {\n ctx = new_ctx = BN_CTX_new ( ) ;\n if ( ctx == NULL ) return 0 ;\n }\n if ( ( scalar && ( num > 1 ) ) || ( num > 2 ) || ( num == 0 && EC_GROUP_have_precompute_mult ( group ) ) ) {\n ret = ec_wNAF_mul ( group , r , scalar , num , points , scalars , ctx ) ;\n goto err ;\n }\n if ( ( p = EC_POINT_new ( group ) ) == NULL ) goto err ;\n if ( ( acc = EC_POINT_new ( group ) ) == NULL ) goto err ;\n if ( ! EC_POINT_set_to_infinity ( group , acc ) ) goto err ;\n if ( scalar ) {\n if ( ! ec_GF2m_montgomery_point_multiply ( group , p , scalar , group -> generator , ctx ) ) goto err ;\n if ( BN_is_negative ( scalar ) ) if ( ! group -> meth -> invert ( group , p , ctx ) ) goto err ;\n if ( ! group -> meth -> add ( group , acc , acc , p , ctx ) ) goto err ;\n }\n for ( i = 0 ;\n i < num ;\n i ++ ) {\n if ( ! ec_GF2m_montgomery_point_multiply ( group , p , scalars [ i ] , points [ i ] , ctx ) ) goto err ;\n if ( BN_is_negative ( scalars [ i ] ) ) if ( ! group -> meth -> invert ( group , p , ctx ) ) goto err ;\n if ( ! group -> meth -> add ( group , acc , acc , p , ctx ) ) goto err ;\n }\n if ( ! EC_POINT_copy ( r , acc ) ) goto err ;\n ret = 1 ;\n err : if ( p ) EC_POINT_free ( p ) ;\n if ( acc ) EC_POINT_free ( acc ) ;\n if ( new_ctx != NULL ) BN_CTX_free ( new_ctx ) ;\n return ret ;\n }", "idx": 1881}
{"hash": -5968890769755017734, "project": "debian", "size": 35, "label": 0, "functionSource": "static void save_caller_context ( char * * argv ) {\n struct passwd * pw = NULL ;\n # ifndef USE_PAM # ifdef SU_ACCESS const char * password = NULL ;\n # endif # endif Prog = Basename ( argv [ 0 ] ) ;\n caller_uid = getuid ( ) ;\n caller_is_root = ( caller_uid == 0 ) ;\n caller_tty = ttyname ( 0 ) ;\n if ( ( isatty ( 0 ) != 0 ) && ( NULL != caller_tty ) ) {\n # ifndef USE_PAM caller_on_console = console ( caller_tty ) ;\n # endif }\n else {\n if ( ! caller_is_root ) {\n fprintf ( stderr , _ ( \"%s: must be run from a terminal\\n\" ) , Prog ) ;\n exit ( 1 ) ;\n }\n caller_tty = \"???\" ;\n }\n pw = get_my_pwent ( ) ;\n if ( NULL == pw ) {\n fprintf ( stderr , _ ( \"%s: Cannot determine your user name.\\n\" ) , Prog ) ;\n SYSLOG ( ( LOG_WARN , \"Cannot determine the user name of the caller (UID %lu)\" , ( unsigned long ) caller_uid ) ) ;\n su_failure ( caller_tty , true ) ;\n }\n STRFCPY ( caller_name , pw -> pw_name ) ;\n # ifndef USE_PAM # ifdef SU_ACCESS password = pw -> pw_passwd ;\n if ( strcmp ( pw -> pw_passwd , SHADOW_PASSWD_STRING ) == 0 ) {\n const struct spwd * spwd = getspnam ( caller_name ) ;\n if ( NULL != spwd ) {\n password = spwd -> sp_pwdp ;\n }\n }\n free ( caller_pass ) ;\n caller_pass = xstrdup ( password ) ;\n # endif # endif pw_free ( pw ) ;\n }", "idx": 1882}
{"hash": -305162769887579921, "project": "debian", "size": 50, "label": 0, "functionSource": "void ff_convert_matrix ( DSPContext * dsp , int ( * qmat ) [ 64 ] , uint16_t ( * qmat16 ) [ 2 ] [ 64 ] , const uint16_t * quant_matrix , int bias , int qmin , int qmax , int intra ) {\n int qscale ;\n int shift = 0 ;\n for ( qscale = qmin ;\n qscale <= qmax ;\n qscale ++ ) {\n int i ;\n if ( dsp -> fdct == ff_jpeg_fdct_islow_8 || dsp -> fdct == ff_jpeg_fdct_islow_10 || dsp -> fdct == ff_faandct ) {\n for ( i = 0 ;\n i < 64 ;\n i ++ ) {\n const int j = dsp -> idct_permutation [ i ] ;\n qmat [ qscale ] [ i ] = ( int ) ( ( UINT64_C ( 1 ) << QMAT_SHIFT ) / ( qscale * quant_matrix [ j ] ) ) ;\n }\n }\n else if ( dsp -> fdct == ff_fdct_ifast ) {\n for ( i = 0 ;\n i < 64 ;\n i ++ ) {\n const int j = dsp -> idct_permutation [ i ] ;\n qmat [ qscale ] [ i ] = ( int ) ( ( UINT64_C ( 1 ) << ( QMAT_SHIFT + 14 ) ) / ( ff_aanscales [ i ] * qscale * quant_matrix [ j ] ) ) ;\n }\n }\n else {\n for ( i = 0 ;\n i < 64 ;\n i ++ ) {\n const int j = dsp -> idct_permutation [ i ] ;\n qmat [ qscale ] [ i ] = ( int ) ( ( UINT64_C ( 1 ) << QMAT_SHIFT ) / ( qscale * quant_matrix [ j ] ) ) ;\n qmat16 [ qscale ] [ 0 ] [ i ] = ( 1 << QMAT_SHIFT_MMX ) / ( qscale * quant_matrix [ j ] ) ;\n if ( qmat16 [ qscale ] [ 0 ] [ i ] == 0 || qmat16 [ qscale ] [ 0 ] [ i ] == 128 * 256 ) qmat16 [ qscale ] [ 0 ] [ i ] = 128 * 256 - 1 ;\n qmat16 [ qscale ] [ 1 ] [ i ] = ROUNDED_DIV ( bias << ( 16 - QUANT_BIAS_SHIFT ) , qmat16 [ qscale ] [ 0 ] [ i ] ) ;\n }\n }\n for ( i = intra ;\n i < 64 ;\n i ++ ) {\n int64_t max = 8191 ;\n if ( dsp -> fdct == ff_fdct_ifast ) {\n max = ( 8191LL * ff_aanscales [ i ] ) >> 14 ;\n }\n while ( ( ( max * qmat [ qscale ] [ i ] ) >> shift ) > INT_MAX ) {\n shift ++ ;\n }\n }\n }\n if ( shift ) {\n av_log ( NULL , AV_LOG_INFO , \"Warning, QMAT_SHIFT is larger than %d, overflows possible\\n\" , QMAT_SHIFT - shift ) ;\n }\n }", "idx": 1883}
{"hash": 6632536031698733342, "project": "debian", "size": 3, "label": 0, "functionSource": "static void ini_print_int ( WriterContext * wctx , const char * key , long long int value ) {\n printf ( \"%s=%lld\\n\" , key , value ) ;\n }", "idx": 1884}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_EnhancementLayerInfo ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_EnhancementLayerInfo , EnhancementLayerInfo_sequence ) ;\n return offset ;\n }", "idx": 1885}
{"hash": 6302861533225984845, "project": "debian", "size": 18, "label": 0, "functionSource": "static void pxa2xx_ssp_save ( QEMUFile * f , void * opaque ) {\n PXA2xxSSPState * s = ( PXA2xxSSPState * ) opaque ;\n int i ;\n qemu_put_be32 ( f , s -> enable ) ;\n qemu_put_be32s ( f , & s -> sscr [ 0 ] ) ;\n qemu_put_be32s ( f , & s -> sscr [ 1 ] ) ;\n qemu_put_be32s ( f , & s -> sspsp ) ;\n qemu_put_be32s ( f , & s -> ssto ) ;\n qemu_put_be32s ( f , & s -> ssitr ) ;\n qemu_put_be32s ( f , & s -> sssr ) ;\n qemu_put_8s ( f , & s -> sstsa ) ;\n qemu_put_8s ( f , & s -> ssrsa ) ;\n qemu_put_8s ( f , & s -> ssacd ) ;\n qemu_put_byte ( f , s -> rx_level ) ;\n for ( i = 0 ;\n i < s -> rx_level ;\n i ++ ) qemu_put_byte ( f , s -> rx_fifo [ ( s -> rx_start + i ) & 0xf ] ) ;\n }", "idx": 1886}
{"hash": 6500423400461365723, "project": "debian", "size": 20, "label": 0, "functionSource": "static int find_section_to_relocate ( Dwarf_Debug dbg , Dwarf_Half section_index , struct Dwarf_Section_s * * relocatablesec , int * error ) {\n MATCH_REL_SEC ( section_index , dbg -> de_debug_info , relocatablesec ) ;\n MATCH_REL_SEC ( section_index , dbg -> de_debug_abbrev , relocatablesec ) ;\n MATCH_REL_SEC ( section_index , dbg -> de_debug_line , relocatablesec ) ;\n MATCH_REL_SEC ( section_index , dbg -> de_debug_loc , relocatablesec ) ;\n MATCH_REL_SEC ( section_index , dbg -> de_debug_aranges , relocatablesec ) ;\n MATCH_REL_SEC ( section_index , dbg -> de_debug_macinfo , relocatablesec ) ;\n MATCH_REL_SEC ( section_index , dbg -> de_debug_pubnames , relocatablesec ) ;\n MATCH_REL_SEC ( section_index , dbg -> de_debug_ranges , relocatablesec ) ;\n MATCH_REL_SEC ( section_index , dbg -> de_debug_frame , relocatablesec ) ;\n MATCH_REL_SEC ( section_index , dbg -> de_debug_frame_eh_gnu , relocatablesec ) ;\n MATCH_REL_SEC ( section_index , dbg -> de_debug_pubtypes , relocatablesec ) ;\n MATCH_REL_SEC ( section_index , dbg -> de_debug_funcnames , relocatablesec ) ;\n MATCH_REL_SEC ( section_index , dbg -> de_debug_typenames , relocatablesec ) ;\n MATCH_REL_SEC ( section_index , dbg -> de_debug_varnames , relocatablesec ) ;\n MATCH_REL_SEC ( section_index , dbg -> de_debug_weaknames , relocatablesec ) ;\n MATCH_REL_SEC ( section_index , dbg -> de_debug_types , relocatablesec ) ;\n * error = DW_DLE_RELOC_SECTION_MISMATCH ;\n return DW_DLV_ERROR ;\n }", "idx": 1887}
{"hash": 5605949879237783359, "project": "debian", "size": 27, "label": 0, "functionSource": "static unsigned int _warc_rdver ( const char * buf , size_t bsz ) {\n static const char magic [ ] = \"WARC/\" ;\n const char * c ;\n unsigned int ver = 0U ;\n unsigned int end = 0U ;\n if ( bsz < 12 || memcmp ( buf , magic , sizeof ( magic ) - 1U ) != 0 ) {\n return ver ;\n }\n buf += sizeof ( magic ) - 1U ;\n if ( isdigit ( ( unsigned char ) buf [ 0U ] ) && ( buf [ 1U ] == '.' ) && isdigit ( ( unsigned char ) buf [ 2U ] ) ) {\n if ( isdigit ( ( unsigned char ) buf [ 3U ] ) ) end = 1U ;\n ver = ( buf [ 0U ] - '0' ) * 10000U ;\n if ( end == 1U ) {\n ver += ( buf [ 2U ] - '0' ) * 1000U ;\n ver += ( buf [ 3U ] - '0' ) * 100U ;\n }\n else ver += ( buf [ 2U ] - '0' ) * 100U ;\n c = buf + 3U + end ;\n if ( ver >= 1200U ) {\n if ( memcmp ( c , \"\\r\\n\" , 2U ) != 0 ) ver = 0U ;\n }\n else if ( ver < 1200U ) {\n if ( * c != ' ' && * c != '\\t' ) ver = 0U ;\n }\n }\n return ver ;\n }", "idx": 1888}
{"hash": -5493081488206619677, "project": "debian", "size": 12, "label": 0, "functionSource": "static const char * cmd_resquest_body_limit_action ( cmd_parms * cmd , void * _dcfg , const char * p1 ) {\n directory_config * dcfg = ( directory_config * ) _dcfg ;\n if ( dcfg == NULL ) return NULL ;\n if ( dcfg -> is_enabled == MODSEC_DETECTION_ONLY ) {\n dcfg -> if_limit_action = REQUEST_BODY_LIMIT_ACTION_PARTIAL ;\n return NULL ;\n }\n if ( strcasecmp ( p1 , \"ProcessPartial\" ) == 0 ) dcfg -> if_limit_action = REQUEST_BODY_LIMIT_ACTION_PARTIAL ;\n else if ( strcasecmp ( p1 , \"Reject\" ) == 0 ) dcfg -> if_limit_action = REQUEST_BODY_LIMIT_ACTION_REJECT ;\n else return apr_psprintf ( cmd -> pool , \"ModSecurity: Invalid value for SecRequestBodyLimitAction: %s\" , p1 ) ;\n return NULL ;\n }", "idx": 1889}
{"hash": -4525941100783779911, "project": "debian", "size": 13, "label": 0, "functionSource": "static SYMBOL BinSrchKey ( const char * id ) {\n int l = 1 ;\n int r = NUMKEYS ;\n int x , res ;\n while ( r >= l ) {\n x = ( l + r ) / 2 ;\n res = cmsstrcasecmp ( id , TabKeys [ x - 1 ] . id ) ;\n if ( res == 0 ) return TabKeys [ x - 1 ] . sy ;\n if ( res < 0 ) r = x - 1 ;\n else l = x + 1 ;\n }\n return SUNDEFINED ;\n }", "idx": 1890}
{"hash": -3889154245145551951, "project": "debian", "size": 6, "label": 0, "functionSource": "static void release_tree_content ( struct tree_content * t ) {\n struct avail_tree_content * f = ( struct avail_tree_content * ) t ;\n unsigned int hc = hc_entries ( f -> entry_capacity ) ;\n f -> next_avail = avail_tree_table [ hc ] ;\n avail_tree_table [ hc ] = f ;\n }", "idx": 1891}
{"hash": -1672864273235910388, "project": "debian", "size": 28, "label": 0, "functionSource": "static void _slurm_rpc_dump_jobs_user ( slurm_msg_t * msg ) {\n DEF_TIMERS ;\n char * dump ;\n int dump_size ;\n slurm_msg_t response_msg ;\n job_user_id_msg_t * job_info_request_msg = ( job_user_id_msg_t * ) msg -> data ;\n slurmctld_lock_t job_read_lock = {\n READ_LOCK , READ_LOCK , NO_LOCK , READ_LOCK , READ_LOCK }\n ;\n uid_t uid = g_slurm_auth_get_uid ( msg -> auth_cred , slurmctld_config . auth_info ) ;\n START_TIMER ;\n debug3 ( \"Processing RPC: REQUEST_JOB_USER_INFO from uid=%d\" , uid ) ;\n lock_slurmctld ( job_read_lock ) ;\n pack_all_jobs ( & dump , & dump_size , job_info_request_msg -> show_flags , uid , job_info_request_msg -> user_id , msg -> protocol_version ) ;\n unlock_slurmctld ( job_read_lock ) ;\n END_TIMER2 ( \"_slurm_rpc_dump_job_user\" ) ;\n # if 0 info ( \"_slurm_rpc_dump_user_jobs, size=%d %s\" , dump_size , TIME_STR ) ;\n # endif slurm_msg_t_init ( & response_msg ) ;\n response_msg . flags = msg -> flags ;\n response_msg . protocol_version = msg -> protocol_version ;\n response_msg . address = msg -> address ;\n response_msg . conn = msg -> conn ;\n response_msg . msg_type = RESPONSE_JOB_INFO ;\n response_msg . data = dump ;\n response_msg . data_size = dump_size ;\n slurm_send_node_msg ( msg -> conn_fd , & response_msg ) ;\n xfree ( dump ) ;\n }", "idx": 1892}
{"hash": 369115599810341094, "project": "debian", "size": 27, "label": 1, "functionSource": "static void vga_draw_line4d2 ( VGACommonState * s1 , uint8_t * d , const uint8_t * s , int width ) {\n uint32_t plane_mask , data , v , * palette ;\n int x ;\n palette = s1 -> last_palette ;\n plane_mask = mask16 [ s1 -> ar [ VGA_ATC_PLANE_ENABLE ] & 0xf ] ;\n width >>= 3 ;\n for ( x = 0 ;\n x < width ;\n x ++ ) {\n data = ( ( uint32_t * ) s ) [ 0 ] ;\n data &= plane_mask ;\n v = expand4 [ GET_PLANE ( data , 0 ) ] ;\n v |= expand4 [ GET_PLANE ( data , 1 ) ] << 1 ;\n v |= expand4 [ GET_PLANE ( data , 2 ) ] << 2 ;\n v |= expand4 [ GET_PLANE ( data , 3 ) ] << 3 ;\n PUT_PIXEL2 ( d , 0 , palette [ v >> 28 ] ) ;\n PUT_PIXEL2 ( d , 1 , palette [ ( v >> 24 ) & 0xf ] ) ;\n PUT_PIXEL2 ( d , 2 , palette [ ( v >> 20 ) & 0xf ] ) ;\n PUT_PIXEL2 ( d , 3 , palette [ ( v >> 16 ) & 0xf ] ) ;\n PUT_PIXEL2 ( d , 4 , palette [ ( v >> 12 ) & 0xf ] ) ;\n PUT_PIXEL2 ( d , 5 , palette [ ( v >> 8 ) & 0xf ] ) ;\n PUT_PIXEL2 ( d , 6 , palette [ ( v >> 4 ) & 0xf ] ) ;\n PUT_PIXEL2 ( d , 7 , palette [ ( v >> 0 ) & 0xf ] ) ;\n d += 64 ;\n s += 4 ;\n }\n }", "idx": 1893}
{"hash": -8620097311326519087, "project": "chrome", "size": 121, "label": 0, "functionSource": "err_status_t srtp_unprotect_rtcp ( srtp_t ctx , void * srtcp_hdr , int * pkt_octet_len ) {\n srtcp_hdr_t * hdr = ( srtcp_hdr_t * ) srtcp_hdr ;\n uint32_t * enc_start ;\n uint32_t * auth_start ;\n uint32_t * trailer ;\n unsigned int enc_octet_len = 0 ;\n uint8_t * auth_tag = NULL ;\n uint8_t tmp_tag [ SRTP_MAX_TAG_LEN ] ;\n uint8_t tag_copy [ SRTP_MAX_TAG_LEN ] ;\n err_status_t status ;\n unsigned int auth_len ;\n int tag_len ;\n srtp_stream_ctx_t * stream ;\n int prefix_len ;\n uint32_t seq_num ;\n int e_bit_in_packet ;\n int sec_serv_confidentiality ;\n if ( * pkt_octet_len < octets_in_rtcp_header + sizeof ( srtcp_trailer_t ) ) return err_status_bad_param ;\n stream = srtp_get_stream ( ctx , hdr -> ssrc ) ;\n if ( stream == NULL ) {\n if ( ctx -> stream_template != NULL ) {\n stream = ctx -> stream_template ;\n if ( stream -> ekt != NULL ) {\n status = srtp_stream_init_from_ekt ( stream , srtcp_hdr , * pkt_octet_len ) ;\n if ( status ) return status ;\n }\n debug_print ( mod_srtp , \"srtcp using provisional stream (SSRC: 0x%08x)\" , hdr -> ssrc ) ;\n }\n else {\n return err_status_no_ctx ;\n }\n }\n tag_len = auth_get_tag_length ( stream -> rtcp_auth ) ;\n if ( * pkt_octet_len < ( int ) ( octets_in_rtcp_header + tag_len + sizeof ( srtcp_trailer_t ) ) ) {\n return err_status_bad_param ;\n }\n if ( stream -> rtp_cipher -> algorithm == AES_128_GCM || stream -> rtp_cipher -> algorithm == AES_256_GCM ) {\n return srtp_unprotect_rtcp_aead ( ctx , stream , srtcp_hdr , ( unsigned int * ) pkt_octet_len ) ;\n }\n sec_serv_confidentiality = stream -> rtcp_services == sec_serv_conf || stream -> rtcp_services == sec_serv_conf_and_auth ;\n enc_octet_len = * pkt_octet_len - ( octets_in_rtcp_header + tag_len + sizeof ( srtcp_trailer_t ) ) ;\n trailer = ( uint32_t * ) ( ( char * ) hdr + * pkt_octet_len - ( tag_len + sizeof ( srtcp_trailer_t ) ) ) ;\n e_bit_in_packet = ( * ( ( unsigned char * ) trailer ) & SRTCP_E_BYTE_BIT ) == SRTCP_E_BYTE_BIT ;\n if ( e_bit_in_packet != sec_serv_confidentiality ) {\n return err_status_cant_check ;\n }\n if ( sec_serv_confidentiality ) {\n enc_start = ( uint32_t * ) hdr + uint32s_in_rtcp_header ;\n }\n else {\n enc_octet_len = 0 ;\n enc_start = NULL ;\n }\n auth_start = ( uint32_t * ) hdr ;\n auth_len = * pkt_octet_len - tag_len ;\n auth_tag = ( uint8_t * ) hdr + auth_len ;\n if ( stream -> ekt ) {\n auth_tag -= ekt_octets_after_base_tag ( stream -> ekt ) ;\n memcpy ( tag_copy , auth_tag , tag_len ) ;\n octet_string_set_to_zero ( auth_tag , tag_len ) ;\n auth_tag = tag_copy ;\n auth_len += tag_len ;\n }\n seq_num = ntohl ( * trailer ) & SRTCP_INDEX_MASK ;\n debug_print ( mod_srtp , \"srtcp index: %x\" , seq_num ) ;\n status = rdb_check ( & stream -> rtcp_rdb , seq_num ) ;\n if ( status ) return status ;\n if ( stream -> rtcp_cipher -> type -> id == AES_ICM ) {\n v128_t iv ;\n iv . v32 [ 0 ] = 0 ;\n iv . v32 [ 1 ] = hdr -> ssrc ;\n iv . v32 [ 2 ] = htonl ( seq_num >> 16 ) ;\n iv . v32 [ 3 ] = htonl ( seq_num << 16 ) ;\n status = cipher_set_iv ( stream -> rtcp_cipher , & iv , direction_decrypt ) ;\n }\n else {\n v128_t iv ;\n iv . v32 [ 0 ] = 0 ;\n iv . v32 [ 1 ] = 0 ;\n iv . v32 [ 2 ] = 0 ;\n iv . v32 [ 3 ] = htonl ( seq_num ) ;\n status = cipher_set_iv ( stream -> rtcp_cipher , & iv , direction_decrypt ) ;\n }\n if ( status ) return err_status_cipher_fail ;\n auth_start ( stream -> rtcp_auth ) ;\n status = auth_compute ( stream -> rtcp_auth , ( uint8_t * ) auth_start , auth_len , tmp_tag ) ;\n debug_print ( mod_srtp , \"srtcp computed tag: %s\" , octet_string_hex_string ( tmp_tag , tag_len ) ) ;\n if ( status ) return err_status_auth_fail ;\n debug_print ( mod_srtp , \"srtcp tag from packet: %s\" , octet_string_hex_string ( auth_tag , tag_len ) ) ;\n if ( octet_string_is_eq ( tmp_tag , auth_tag , tag_len ) ) return err_status_auth_fail ;\n prefix_len = auth_get_prefix_length ( stream -> rtcp_auth ) ;\n if ( prefix_len ) {\n status = cipher_output ( stream -> rtcp_cipher , auth_tag , prefix_len ) ;\n debug_print ( mod_srtp , \"keystream prefix: %s\" , octet_string_hex_string ( auth_tag , prefix_len ) ) ;\n if ( status ) return err_status_cipher_fail ;\n }\n if ( enc_start ) {\n status = cipher_decrypt ( stream -> rtcp_cipher , ( uint8_t * ) enc_start , & enc_octet_len ) ;\n if ( status ) return err_status_cipher_fail ;\n }\n * pkt_octet_len -= ( tag_len + sizeof ( srtcp_trailer_t ) ) ;\n * pkt_octet_len -= ekt_octets_after_base_tag ( stream -> ekt ) ;\n if ( stream -> direction != dir_srtp_receiver ) {\n if ( stream -> direction == dir_unknown ) {\n stream -> direction = dir_srtp_receiver ;\n }\n else {\n srtp_handle_event ( ctx , stream , event_ssrc_collision ) ;\n }\n }\n if ( stream == ctx -> stream_template ) {\n srtp_stream_ctx_t * new_stream ;\n status = srtp_stream_clone ( ctx -> stream_template , hdr -> ssrc , & new_stream ) ;\n if ( status ) return status ;\n new_stream -> next = ctx -> stream_list ;\n ctx -> stream_list = new_stream ;\n stream = new_stream ;\n }\n rdb_add_index ( & stream -> rtcp_rdb , seq_num ) ;\n return err_status_ok ;\n }", "idx": 1894}
{"hash": -7137859843679922870, "project": "chrome", "size": 26, "label": 1, "functionSource": "static void build_inter_predictors_for_planes ( MACROBLOCKD * xd , BLOCK_SIZE bsize , int mi_row , int mi_col , int plane_from , int plane_to ) {\n int plane ;\n const int mi_x = mi_col * MI_SIZE ;\n const int mi_y = mi_row * MI_SIZE ;\n for ( plane = plane_from ;\n plane <= plane_to ;\n ++ plane ) {\n const BLOCK_SIZE plane_bsize = get_plane_block_size ( bsize , & xd -> plane [ plane ] ) ;\n const int num_4x4_w = num_4x4_blocks_wide_lookup [ plane_bsize ] ;\n const int num_4x4_h = num_4x4_blocks_high_lookup [ plane_bsize ] ;\n const int bw = 4 * num_4x4_w ;\n const int bh = 4 * num_4x4_h ;\n if ( xd -> mi [ 0 ] -> mbmi . sb_type < BLOCK_8X8 ) {\n int i = 0 , x , y ;\n assert ( bsize == BLOCK_8X8 ) ;\n for ( y = 0 ;\n y < num_4x4_h ;\n ++ y ) for ( x = 0 ;\n x < num_4x4_w ;\n ++ x ) build_inter_predictors ( xd , plane , i ++ , bw , bh , * x , 4 * y , 4 , 4 , mi_x , mi_y ) ;\n }\n else {\n build_inter_predictors ( xd , plane , 0 , bw , bh , 0 , 0 , bw , bh , mi_x , mi_y ) ;\n }\n }\n }", "idx": 1895}
{"hash": 8460430819945784394, "project": "debian", "size": 28, "label": 0, "functionSource": "static void PREP_io_800_writeb ( void * opaque , uint32_t addr , uint32_t val ) {\n PPC_IO_DPRINTF ( \"0x%08x => 0x%08x\\n\" , addr - PPC_IO_BASE , val ) ;\n switch ( addr ) {\n case 0x0092 : if ( val & 0x80 ) {\n printf ( \"Soft reset asked... Stop emulation\\n\" ) ;\n abort ( ) ;\n }\n if ( val & 0x40 ) {\n printf ( \"Little Endian mode isn't supported (yet ?)\\n\" ) ;\n abort ( ) ;\n }\n break ;\n case 0x0808 : break ;\n case 0x0810 : NVRAM_lock ^= 0x01 ;\n break ;\n case 0x0812 : NVRAM_lock ^= 0x02 ;\n break ;\n case 0x0814 : break ;\n case 0x081C : syscontrol = val ;\n break ;\n case 0x0850 : if ( val & 0x80 ) {\n printf ( \"No support for non-continuous I/O map mode\\n\" ) ;\n abort ( ) ;\n }\n break ;\n default : break ;\n }\n }", "idx": 1896}
{"hash": 7191899184788440065, "project": "debian", "size": 26, "label": 0, "functionSource": "static void safe_put_field ( const char * pos , ulong length ) {\n if ( ! pos ) tee_fputs ( \"NULL\" , PAGER ) ;\n else {\n if ( opt_raw_data ) {\n unsigned long i ;\n for ( i = 0 ;\n i < length ;\n i ++ , pos ++ ) tee_putc ( * pos , PAGER ) ;\n }\n else for ( const char * end = pos + length ;\n pos != end ;\n pos ++ ) {\n # ifdef USE_MB int l ;\n if ( use_mb ( charset_info ) && ( l = my_ismbchar ( charset_info , pos , end ) ) ) {\n while ( l -- ) tee_putc ( * pos ++ , PAGER ) ;\n pos -- ;\n continue ;\n }\n # endif if ( ! * pos ) tee_fputs ( \"\\\\0\" , PAGER ) ;\n else if ( * pos == '\\t' ) tee_fputs ( \"\\\\t\" , PAGER ) ;\n else if ( * pos == '\\n' ) tee_fputs ( \"\\\\n\" , PAGER ) ;\n else if ( * pos == '\\\\' ) tee_fputs ( \"\\\\\\\\\" , PAGER ) ;\n else tee_putc ( * pos , PAGER ) ;\n }\n }\n }", "idx": 1897}
{"hash": -5717349108307169967, "project": "debian", "size": 95, "label": 0, "functionSource": "static int mss4_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n MSS4Context * c = avctx -> priv_data ;\n GetBitContext gb ;\n GetByteContext bc ;\n uint8_t * dst [ 3 ] ;\n int width , height , quality , frame_type ;\n int x , y , i , mb_width , mb_height , blk_type ;\n int ret ;\n if ( buf_size < HEADER_SIZE ) {\n av_log ( avctx , AV_LOG_ERROR , \"Frame should have at least %d bytes, got %d instead\\n\" , HEADER_SIZE , buf_size ) ;\n return AVERROR_INVALIDDATA ;\n }\n bytestream2_init ( & bc , buf , buf_size ) ;\n width = bytestream2_get_be16 ( & bc ) ;\n height = bytestream2_get_be16 ( & bc ) ;\n bytestream2_skip ( & bc , 2 ) ;\n quality = bytestream2_get_byte ( & bc ) ;\n frame_type = bytestream2_get_byte ( & bc ) ;\n if ( width > avctx -> width || height != avctx -> height ) {\n av_log ( avctx , AV_LOG_ERROR , \"Invalid frame dimensions %dx%d\\n\" , width , height ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( quality < 1 || quality > 100 ) {\n av_log ( avctx , AV_LOG_ERROR , \"Invalid quality setting %d\\n\" , quality ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( ( frame_type & ~ 3 ) || frame_type == 3 ) {\n av_log ( avctx , AV_LOG_ERROR , \"Invalid frame type %d\\n\" , frame_type ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( frame_type != SKIP_FRAME && ! bytestream2_get_bytes_left ( & bc ) ) {\n av_log ( avctx , AV_LOG_ERROR , \"Empty frame found but it is not a skip frame.\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( ( ret = ff_reget_buffer ( avctx , & c -> pic ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"reget_buffer() failed\\n\" ) ;\n return ret ;\n }\n c -> pic . key_frame = ( frame_type == INTRA_FRAME ) ;\n c -> pic . pict_type = ( frame_type == INTRA_FRAME ) ? AV_PICTURE_TYPE_I : AV_PICTURE_TYPE_P ;\n if ( frame_type == SKIP_FRAME ) {\n * got_frame = 1 ;\n if ( ( ret = av_frame_ref ( data , & c -> pic ) ) < 0 ) return ret ;\n return buf_size ;\n }\n if ( c -> quality != quality ) {\n c -> quality = quality ;\n for ( i = 0 ;\n i < 2 ;\n i ++ ) ff_mss34_gen_quant_mat ( c -> quant_mat [ i ] , quality , ! i ) ;\n }\n init_get_bits ( & gb , buf + HEADER_SIZE , ( buf_size - HEADER_SIZE ) * 8 ) ;\n mb_width = FFALIGN ( width , 16 ) >> 4 ;\n mb_height = FFALIGN ( height , 16 ) >> 4 ;\n dst [ 0 ] = c -> pic . data [ 0 ] ;\n dst [ 1 ] = c -> pic . data [ 1 ] ;\n dst [ 2 ] = c -> pic . data [ 2 ] ;\n memset ( c -> prev_vec , 0 , sizeof ( c -> prev_vec ) ) ;\n for ( y = 0 ;\n y < mb_height ;\n y ++ ) {\n memset ( c -> dc_cache , 0 , sizeof ( c -> dc_cache ) ) ;\n for ( x = 0 ;\n x < mb_width ;\n x ++ ) {\n blk_type = decode012 ( & gb ) ;\n switch ( blk_type ) {\n case DCT_BLOCK : if ( mss4_decode_dct_block ( c , & gb , dst , x , y ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"Error decoding DCT block %d,%d\\n\" , x , y ) ;\n return AVERROR_INVALIDDATA ;\n }\n break ;\n case IMAGE_BLOCK : if ( mss4_decode_image_block ( c , & gb , dst , x , y ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"Error decoding VQ block %d,%d\\n\" , x , y ) ;\n return AVERROR_INVALIDDATA ;\n }\n break ;\n case SKIP_BLOCK : if ( frame_type == INTRA_FRAME ) {\n av_log ( avctx , AV_LOG_ERROR , \"Skip block in intra frame\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n break ;\n }\n if ( blk_type != DCT_BLOCK ) mss4_update_dc_cache ( c , x ) ;\n }\n dst [ 0 ] += c -> pic . linesize [ 0 ] * 16 ;\n dst [ 1 ] += c -> pic . linesize [ 1 ] * 16 ;\n dst [ 2 ] += c -> pic . linesize [ 2 ] * 16 ;\n }\n if ( ( ret = av_frame_ref ( data , & c -> pic ) ) < 0 ) return ret ;\n * got_frame = 1 ;\n return buf_size ;\n }", "idx": 1898}
{"hash": 2521579609370336371, "project": "debian", "size": 61, "label": 0, "functionSource": "int dtls1_send_newsession_ticket ( SSL * s ) {\n if ( s -> state == SSL3_ST_SW_SESSION_TICKET_A ) {\n unsigned char * p , * senc , * macstart ;\n int len , slen ;\n unsigned int hlen , msg_len ;\n EVP_CIPHER_CTX ctx ;\n HMAC_CTX hctx ;\n SSL_CTX * tctx = s -> initial_ctx ;\n unsigned char iv [ EVP_MAX_IV_LENGTH ] ;\n unsigned char key_name [ 16 ] ;\n slen = i2d_SSL_SESSION ( s -> session , NULL ) ;\n if ( slen > 0xFF00 ) return - 1 ;\n if ( ! BUF_MEM_grow ( s -> init_buf , DTLS1_HM_HEADER_LENGTH + 22 + EVP_MAX_IV_LENGTH + EVP_MAX_BLOCK_LENGTH + EVP_MAX_MD_SIZE + slen ) ) return - 1 ;\n senc = OPENSSL_malloc ( slen ) ;\n if ( ! senc ) return - 1 ;\n p = senc ;\n i2d_SSL_SESSION ( s -> session , & p ) ;\n p = ( unsigned char * ) & ( s -> init_buf -> data [ DTLS1_HM_HEADER_LENGTH ] ) ;\n EVP_CIPHER_CTX_init ( & ctx ) ;\n HMAC_CTX_init ( & hctx ) ;\n if ( tctx -> tlsext_ticket_key_cb ) {\n if ( tctx -> tlsext_ticket_key_cb ( s , key_name , iv , & ctx , & hctx , 1 ) < 0 ) {\n OPENSSL_free ( senc ) ;\n return - 1 ;\n }\n }\n else {\n RAND_pseudo_bytes ( iv , 16 ) ;\n EVP_EncryptInit_ex ( & ctx , EVP_aes_128_cbc ( ) , NULL , tctx -> tlsext_tick_aes_key , iv ) ;\n HMAC_Init_ex ( & hctx , tctx -> tlsext_tick_hmac_key , 16 , tlsext_tick_md ( ) , NULL ) ;\n memcpy ( key_name , tctx -> tlsext_tick_key_name , 16 ) ;\n }\n l2n ( s -> session -> tlsext_tick_lifetime_hint , p ) ;\n p += 2 ;\n macstart = p ;\n memcpy ( p , key_name , 16 ) ;\n p += 16 ;\n memcpy ( p , iv , EVP_CIPHER_CTX_iv_length ( & ctx ) ) ;\n p += EVP_CIPHER_CTX_iv_length ( & ctx ) ;\n EVP_EncryptUpdate ( & ctx , p , & len , senc , slen ) ;\n p += len ;\n EVP_EncryptFinal ( & ctx , p , & len ) ;\n p += len ;\n EVP_CIPHER_CTX_cleanup ( & ctx ) ;\n HMAC_Update ( & hctx , macstart , p - macstart ) ;\n HMAC_Final ( & hctx , p , & hlen ) ;\n HMAC_CTX_cleanup ( & hctx ) ;\n p += hlen ;\n len = p - ( unsigned char * ) ( s -> init_buf -> data ) ;\n p = ( unsigned char * ) & ( s -> init_buf -> data [ DTLS1_HM_HEADER_LENGTH ] ) + 4 ;\n s2n ( len - DTLS1_HM_HEADER_LENGTH - 6 , p ) ;\n s -> init_num = len ;\n s -> state = SSL3_ST_SW_SESSION_TICKET_B ;\n s -> init_off = 0 ;\n OPENSSL_free ( senc ) ;\n msg_len = s -> init_num - DTLS1_HM_HEADER_LENGTH ;\n dtls1_set_message_header ( s , ( void * ) s -> init_buf -> data , SSL3_MT_NEWSESSION_TICKET , msg_len , 0 , msg_len ) ;\n dtls1_buffer_message ( s , 0 ) ;\n }\n return ( dtls1_do_write ( s , SSL3_RT_HANDSHAKE ) ) ;\n }", "idx": 1899}
{"hash": -6359684484462176044, "project": "debian", "size": 20, "label": 0, "functionSource": "EC_KEY * d2i_ECParameters ( EC_KEY * * a , const unsigned char * * in , long len ) {\n EC_KEY * ret ;\n if ( in == NULL || * in == NULL ) {\n ECerr ( EC_F_D2I_ECPARAMETERS , ERR_R_PASSED_NULL_PARAMETER ) ;\n return NULL ;\n }\n if ( a == NULL || * a == NULL ) {\n if ( ( ret = EC_KEY_new ( ) ) == NULL ) {\n ECerr ( EC_F_D2I_ECPARAMETERS , ERR_R_MALLOC_FAILURE ) ;\n return NULL ;\n }\n if ( a ) * a = ret ;\n }\n else ret = * a ;\n if ( ! d2i_ECPKParameters ( & ret -> group , in , len ) ) {\n ECerr ( EC_F_D2I_ECPARAMETERS , ERR_R_EC_LIB ) ;\n return NULL ;\n }\n return ret ;\n }", "idx": 1900}
{"hash": -2661809302248698892, "project": "debian", "size": 31, "label": 0, "functionSource": "static int decode_i_block ( FourXContext * f , int16_t * block ) {\n int code , i , j , level , val ;\n val = get_vlc2 ( & f -> pre_gb , f -> pre_vlc . table , ACDC_VLC_BITS , 3 ) ;\n if ( val >> 4 ) av_log ( f -> avctx , AV_LOG_ERROR , \"error dc run != 0\\n\" ) ;\n if ( val ) val = get_xbits ( & f -> gb , val ) ;\n val = val * dequant_table [ 0 ] + f -> last_dc ;\n f -> last_dc = block [ 0 ] = val ;\n i = 1 ;\n for ( ;\n ;\n ) {\n code = get_vlc2 ( & f -> pre_gb , f -> pre_vlc . table , ACDC_VLC_BITS , 3 ) ;\n if ( code == 0 ) break ;\n if ( code == 0xf0 ) {\n i += 16 ;\n }\n else {\n level = get_xbits ( & f -> gb , code & 0xf ) ;\n i += code >> 4 ;\n if ( i >= 64 ) {\n av_log ( f -> avctx , AV_LOG_ERROR , \"run %d oveflow\\n\" , i ) ;\n return 0 ;\n }\n j = ff_zigzag_direct [ i ] ;\n block [ j ] = level * dequant_table [ j ] ;\n i ++ ;\n if ( i >= 64 ) break ;\n }\n }\n return 0 ;\n }", "idx": 1901}
{"hash": -4055702019813176658, "project": "debian", "size": 6, "label": 0, "functionSource": "static void iax2_populate_pinfo_from_packet_data ( packet_info * pinfo , const iax_packet_data * p ) {\n if ( p -> call_data != NULL ) {\n pinfo -> p2p_dir = p -> reversed ? P2P_DIR_RECV : P2P_DIR_SENT ;\n col_set_str ( pinfo -> cinfo , COL_IF_DIR , p -> reversed ? \"rev\" : \"fwd\" ) ;\n }\n }", "idx": 1902}
{"hash": 5357882892791796049, "project": "debian", "size": 82, "label": 0, "functionSource": "static void e1000e_build_rx_metadata ( E1000ECore * core , struct NetRxPkt * pkt , bool is_eop , const E1000E_RSSInfo * rss_info , uint32_t * rss , uint32_t * mrq , uint32_t * status_flags , uint16_t * ip_id , uint16_t * vlan_tag ) {\n struct virtio_net_hdr * vhdr ;\n bool isip4 , isip6 , istcp , isudp ;\n uint32_t pkt_type ;\n * status_flags = E1000_RXD_STAT_DD ;\n if ( ! is_eop ) {\n goto func_exit ;\n }\n * status_flags |= E1000_RXD_STAT_EOP ;\n net_rx_pkt_get_protocols ( pkt , & isip4 , & isip6 , & isudp , & istcp ) ;\n trace_e1000e_rx_metadata_protocols ( isip4 , isip6 , isudp , istcp ) ;\n if ( net_rx_pkt_is_vlan_stripped ( pkt ) ) {\n * status_flags |= E1000_RXD_STAT_VP ;\n * vlan_tag = cpu_to_le16 ( net_rx_pkt_get_vlan_tag ( pkt ) ) ;\n trace_e1000e_rx_metadata_vlan ( * vlan_tag ) ;\n }\n if ( ( core -> mac [ RXCSUM ] & E1000_RXCSUM_PCSD ) != 0 ) {\n if ( rss_info -> enabled ) {\n * rss = cpu_to_le32 ( rss_info -> hash ) ;\n * mrq = cpu_to_le32 ( rss_info -> type | ( rss_info -> queue << 8 ) ) ;\n trace_e1000e_rx_metadata_rss ( * rss , * mrq ) ;\n }\n }\n else if ( isip4 ) {\n * status_flags |= E1000_RXD_STAT_IPIDV ;\n * ip_id = cpu_to_le16 ( net_rx_pkt_get_ip_id ( pkt ) ) ;\n trace_e1000e_rx_metadata_ip_id ( * ip_id ) ;\n }\n if ( istcp && e1000e_is_tcp_ack ( core , pkt ) ) {\n * status_flags |= E1000_RXD_STAT_ACK ;\n trace_e1000e_rx_metadata_ack ( ) ;\n }\n if ( isip6 && ( core -> mac [ RFCTL ] & E1000_RFCTL_IPV6_DIS ) ) {\n trace_e1000e_rx_metadata_ipv6_filtering_disabled ( ) ;\n pkt_type = E1000_RXD_PKT_MAC ;\n }\n else if ( istcp || isudp ) {\n pkt_type = isip4 ? E1000_RXD_PKT_IP4_XDP : E1000_RXD_PKT_IP6_XDP ;\n }\n else if ( isip4 || isip6 ) {\n pkt_type = isip4 ? E1000_RXD_PKT_IP4 : E1000_RXD_PKT_IP6 ;\n }\n else {\n pkt_type = E1000_RXD_PKT_MAC ;\n }\n * status_flags |= E1000_RXD_PKT_TYPE ( pkt_type ) ;\n trace_e1000e_rx_metadata_pkt_type ( pkt_type ) ;\n if ( isip6 && ( core -> mac [ RFCTL ] & E1000_RFCTL_IPV6_XSUM_DIS ) ) {\n trace_e1000e_rx_metadata_ipv6_sum_disabled ( ) ;\n goto func_exit ;\n }\n if ( ! net_rx_pkt_has_virt_hdr ( pkt ) ) {\n trace_e1000e_rx_metadata_no_virthdr ( ) ;\n e1000e_verify_csum_in_sw ( core , pkt , status_flags , istcp , isudp ) ;\n goto func_exit ;\n }\n vhdr = net_rx_pkt_get_vhdr ( pkt ) ;\n if ( ! ( vhdr -> flags & VIRTIO_NET_HDR_F_DATA_VALID ) && ! ( vhdr -> flags & VIRTIO_NET_HDR_F_NEEDS_CSUM ) ) {\n trace_e1000e_rx_metadata_virthdr_no_csum_info ( ) ;\n e1000e_verify_csum_in_sw ( core , pkt , status_flags , istcp , isudp ) ;\n goto func_exit ;\n }\n if ( e1000e_rx_l3_cso_enabled ( core ) ) {\n * status_flags |= isip4 ? E1000_RXD_STAT_IPCS : 0 ;\n }\n else {\n trace_e1000e_rx_metadata_l3_cso_disabled ( ) ;\n }\n if ( e1000e_rx_l4_cso_enabled ( core ) ) {\n if ( istcp ) {\n * status_flags |= E1000_RXD_STAT_TCPCS ;\n }\n else if ( isudp ) {\n * status_flags |= E1000_RXD_STAT_TCPCS | E1000_RXD_STAT_UDPCS ;\n }\n }\n else {\n trace_e1000e_rx_metadata_l4_cso_disabled ( ) ;\n }\n trace_e1000e_rx_metadata_status_flags ( * status_flags ) ;\n func_exit : * status_flags = cpu_to_le32 ( * status_flags ) ;\n }", "idx": 1903}
{"hash": -6379515734957310198, "project": "debian", "size": 4, "label": 1, "functionSource": "ATF_TP_ADD_TCS ( tp ) {\n ATF_TP_ADD_TC ( tp , option_refcnt ) ;\n return ( atf_no_error ( ) ) ;\n }", "idx": 1904}
{"hash": 4489017523191997023, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h225_StatusInquiry_UUIE ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_StatusInquiry_UUIE , StatusInquiry_UUIE_sequence ) ;\n return offset ;\n }", "idx": 1905}
{"hash": 6393050609822897742, "project": "debian", "size": 39, "label": 0, "functionSource": "static TRBCCode xhci_set_ep_dequeue ( XHCIState * xhci , unsigned int slotid , unsigned int epid , unsigned int streamid , uint64_t pdequeue ) {\n XHCISlot * slot ;\n XHCIEPContext * epctx ;\n XHCIStreamContext * sctx ;\n dma_addr_t dequeue ;\n assert ( slotid >= 1 && slotid <= xhci -> numslots ) ;\n if ( epid < 1 || epid > 31 ) {\n DPRINTF ( \"xhci: bad ep %d\\n\" , epid ) ;\n return CC_TRB_ERROR ;\n }\n trace_usb_xhci_ep_set_dequeue ( slotid , epid , streamid , pdequeue ) ;\n dequeue = xhci_mask64 ( pdequeue ) ;\n slot = & xhci -> slots [ slotid - 1 ] ;\n if ( ! slot -> eps [ epid - 1 ] ) {\n DPRINTF ( \"xhci: slot %d ep %d not enabled\\n\" , slotid , epid ) ;\n return CC_EP_NOT_ENABLED_ERROR ;\n }\n epctx = slot -> eps [ epid - 1 ] ;\n if ( epctx -> state != EP_STOPPED ) {\n DPRINTF ( \"xhci: set EP dequeue pointer while EP %d not stopped\\n\" , epid ) ;\n return CC_CONTEXT_STATE_ERROR ;\n }\n if ( epctx -> nr_pstreams ) {\n uint32_t err ;\n sctx = xhci_find_stream ( epctx , streamid , & err ) ;\n if ( sctx == NULL ) {\n return err ;\n }\n xhci_ring_init ( xhci , & sctx -> ring , dequeue & ~ 0xf ) ;\n sctx -> ring . ccs = dequeue & 1 ;\n }\n else {\n sctx = NULL ;\n xhci_ring_init ( xhci , & epctx -> ring , dequeue & ~ 0xF ) ;\n epctx -> ring . ccs = dequeue & 1 ;\n }\n xhci_set_ep_state ( xhci , epctx , sctx , EP_STOPPED ) ;\n return CC_SUCCESS ;\n }", "idx": 1906}
{"hash": -1445906809722253218, "project": "chrome", "size": 29, "label": 0, "functionSource": "TEST_F ( FullscreenControllerStateUnitTest , OneCapturedTabFullscreenedBeforeBrowserFullscreen ) {\n content : : WebContentsDelegate * const wc_delegate = static_cast < content : : WebContentsDelegate * > ( browser ( ) ) ;\n ASSERT_TRUE ( wc_delegate -> EmbedsFullscreenWidget ( ) ) ;\n AddTab ( browser ( ) , GURL ( url : : kAboutBlankURL ) ) ;\n content : : WebContents * const tab = browser ( ) -> tab_strip_model ( ) -> GetWebContentsAt ( 0 ) ;\n browser ( ) -> tab_strip_model ( ) -> ActivateTabAt ( 0 , true ) ;\n const gfx : : Size kCaptureSize ( 1280 , 720 ) ;\n tab -> IncrementCapturerCount ( kCaptureSize ) ;\n ASSERT_TRUE ( InvokeEvent ( TAB_FULLSCREEN_TRUE ) ) ;\n EXPECT_TRUE ( wc_delegate -> IsFullscreenForTabOrPending ( tab ) ) ;\n EXPECT_FALSE ( GetFullscreenController ( ) -> IsWindowFullscreenForTabOrPending ( ) ) ;\n EXPECT_FALSE ( GetFullscreenController ( ) -> IsFullscreenForBrowser ( ) ) ;\n ASSERT_TRUE ( InvokeEvent ( TOGGLE_FULLSCREEN ) ) ;\n ASSERT_TRUE ( InvokeEvent ( WINDOW_CHANGE ) ) ;\n EXPECT_TRUE ( wc_delegate -> IsFullscreenForTabOrPending ( tab ) ) ;\n EXPECT_FALSE ( GetFullscreenController ( ) -> IsWindowFullscreenForTabOrPending ( ) ) ;\n EXPECT_TRUE ( GetFullscreenController ( ) -> IsFullscreenForBrowser ( ) ) ;\n ASSERT_TRUE ( InvokeEvent ( TOGGLE_FULLSCREEN ) ) ;\n ASSERT_TRUE ( InvokeEvent ( WINDOW_CHANGE ) ) ;\n EXPECT_TRUE ( wc_delegate -> IsFullscreenForTabOrPending ( tab ) ) ;\n EXPECT_FALSE ( GetFullscreenController ( ) -> IsWindowFullscreenForTabOrPending ( ) ) ;\n EXPECT_FALSE ( GetFullscreenController ( ) -> IsFullscreenForBrowser ( ) ) ;\n ASSERT_TRUE ( InvokeEvent ( TOGGLE_FULLSCREEN ) ) ;\n ASSERT_TRUE ( InvokeEvent ( WINDOW_CHANGE ) ) ;\n ASSERT_TRUE ( InvokeEvent ( TAB_FULLSCREEN_FALSE ) ) ;\n EXPECT_FALSE ( wc_delegate -> IsFullscreenForTabOrPending ( tab ) ) ;\n EXPECT_FALSE ( GetFullscreenController ( ) -> IsWindowFullscreenForTabOrPending ( ) ) ;\n EXPECT_TRUE ( GetFullscreenController ( ) -> IsFullscreenForBrowser ( ) ) ;\n }", "idx": 1907}
{"hash": -5861178779585941932, "project": "debian", "size": 34, "label": 0, "functionSource": "static u_int print_txt_line ( netdissect_options * ndo , const char * protoname , const char * prefix , const u_char * pptr , u_int idx , u_int len ) {\n u_int startidx ;\n u_int linelen ;\n startidx = idx ;\n while ( idx < len ) {\n ND_TCHECK ( * ( pptr + idx ) ) ;\n if ( * ( pptr + idx ) == '\\n' ) {\n linelen = idx - startidx ;\n idx ++ ;\n goto print ;\n }\n else if ( * ( pptr + idx ) == '\\r' ) {\n if ( ( idx + 1 ) >= len ) {\n return ( 0 ) ;\n }\n ND_TCHECK ( * ( pptr + idx + 1 ) ) ;\n if ( * ( pptr + idx + 1 ) == '\\n' ) {\n linelen = idx - startidx ;\n idx += 2 ;\n goto print ;\n }\n return ( 0 ) ;\n }\n else if ( ! isascii ( * ( pptr + idx ) ) || ( ! isprint ( * ( pptr + idx ) ) && * ( pptr + idx ) != '\\t' ) ) {\n return ( 0 ) ;\n }\n idx ++ ;\n }\n trunc : linelen = idx - startidx ;\n ND_PRINT ( ( ndo , \"%s%.*s[!%s]\" , prefix , ( int ) linelen , pptr + startidx , protoname ) ) ;\n return ( 0 ) ;\n print : ND_PRINT ( ( ndo , \"%s%.*s\" , prefix , ( int ) linelen , pptr + startidx ) ) ;\n return ( idx ) ;\n }", "idx": 1908}
{"hash": 8460430819945784394, "project": "debian", "size": 16, "label": 0, "functionSource": "static void NVRAM_set_crc ( m48t59_t * nvram , uint32_t addr , uint32_t start , uint32_t count ) {\n uint32_t i ;\n uint16_t crc = 0xFFFF ;\n int odd = 0 ;\n if ( count & 1 ) odd = 1 ;\n count &= ~ 1 ;\n for ( i = 0 ;\n i != count ;\n i ++ ) {\n crc = NVRAM_crc_update ( crc , NVRAM_get_word ( nvram , start + i ) ) ;\n }\n if ( odd ) {\n crc = NVRAM_crc_update ( crc , NVRAM_get_byte ( nvram , start + i ) << 8 ) ;\n }\n NVRAM_set_word ( nvram , addr , crc ) ;\n }", "idx": 1909}
{"hash": -2943582541244387919, "project": "chrome", "size": 36, "label": 0, "functionSource": "unsigned int vp9_sub_pixel_avg_variance ## W ## x ## H ## _c ( const uint8_t * src , int src_stride , int xoffset , int yoffset , const uint8_t * dst , int dst_stride , unsigned int * sse , const uint8_t * second_pred ) {\n uint16_t fdata3 [ ( H + 1 ) * W ] ;\n uint8_t temp2 [ H * W ] ;\n DECLARE_ALIGNED_ARRAY ( 16 , uint8_t , temp3 , H * W ) ;\n var_filter_block2d_bil_first_pass ( src , fdata3 , src_stride , 1 , H + 1 , W , BILINEAR_FILTERS_2TAP ( xoffset ) ) ;\n var_filter_block2d_bil_second_pass ( fdata3 , temp2 , W , W , H , W , BILINEAR_FILTERS_2TAP ( yoffset ) ) ;\n vp9_comp_avg_pred ( temp3 , second_pred , W , H , temp2 , W ) ;\n return vp9_variance ## W ## x ## H ## _c ( temp3 , W , dst , dst_stride , sse ) ;\n \\ }\n void vp9_get16x16var_c ( const uint8_t * src_ptr , int source_stride , const uint8_t * ref_ptr , int ref_stride , unsigned int * sse , int * sum ) {\n variance ( src_ptr , source_stride , ref_ptr , ref_stride , 16 , 16 , sse , sum ) ;\n }\n void vp9_get8x8var_c ( const uint8_t * src_ptr , int source_stride , const uint8_t * ref_ptr , int ref_stride , unsigned int * sse , int * sum ) {\n variance ( src_ptr , source_stride , ref_ptr , ref_stride , 8 , 8 , sse , sum ) ;\n }\n unsigned int vp9_mse16x16_c ( const uint8_t * src , int src_stride , const uint8_t * ref , int ref_stride , unsigned int * sse ) {\n int sum ;\n variance ( src , src_stride , ref , ref_stride , 16 , 16 , sse , & sum ) ;\n return * sse ;\n }\n unsigned int vp9_mse16x8_c ( const uint8_t * src , int src_stride , const uint8_t * ref , int ref_stride , unsigned int * sse ) {\n int sum ;\n variance ( src , src_stride , ref , ref_stride , 16 , 8 , sse , & sum ) ;\n return * sse ;\n }\n unsigned int vp9_mse8x16_c ( const uint8_t * src , int src_stride , const uint8_t * ref , int ref_stride , unsigned int * sse ) {\n int sum ;\n variance ( src , src_stride , ref , ref_stride , 8 , 16 , sse , & sum ) ;\n return * sse ;\n }\n unsigned int vp9_mse8x8_c ( const uint8_t * src , int src_stride , const uint8_t * ref , int ref_stride , unsigned int * sse ) {\n int sum ;\n variance ( src , src_stride , ref , ref_stride , 8 , 8 , sse , & sum ) ;\n return * sse ;\n }\n VAR ( 4 , 4 ) SUBPIX_VAR ( 4 , 4 ) SUBPIX_AVG_VAR ( 4 , 4 ) VAR ( 4 , 8 ) SUBPIX_VAR ( 4 , 8 ) SUBPIX_AVG_VAR ( 4 , 8 ) VAR ( 8 , 4 ) SUBPIX_VAR ( 8 , 4 ) SUBPIX_AVG_VAR ( 8 , 4 ) VAR ( 8 , 8 ) SUBPIX_VAR ( 8 , 8 ) SUBPIX_AVG_VAR ( 8 , 8 ) VAR ( 8 , 16 ) SUBPIX_VAR ( 8 , 16 ) SUBPIX_AVG_VAR ( 8 , 16 ) VAR ( 16 , 8 ) SUBPIX_VAR ( 16 , 8 ) SUBPIX_AVG_VAR ( 16 , 8 ) VAR ( 16 , 16 ) SUBPIX_VAR ( 16 , 16 ) SUBPIX_AVG_VAR ( 16 , 16 ) VAR ( 16 , 32 ) SUBPIX_VAR ( 16 , 32 ) SUBPIX_AVG_VAR ( 16 , 32 ) VAR ( 32 , 16 ) SUBPIX_VAR ( 32 , 16 ) SUBPIX_AVG_VAR ( 32 , 16 )", "idx": 1910}
{"hash": 6249489553242542670, "project": "debian", "size": 65, "label": 0, "functionSource": "static void config_peers ( config_tree * ptree ) {\n sockaddr_u peeraddr ;\n struct addrinfo hints ;\n peer_node * curr_peer ;\n peer_resolved_ctx * ctx ;\n u_char hmode ;\n for ( ;\n cmdline_server_count > 0 ;\n cmdline_server_count -- , cmdline_servers ++ ) {\n ZERO_SOCK ( & peeraddr ) ;\n if ( is_ip_address ( * cmdline_servers , AF_UNSPEC , & peeraddr ) ) {\n SET_PORT ( & peeraddr , NTP_PORT ) ;\n if ( is_sane_resolved_address ( & peeraddr , T_Server ) ) peer_config ( & peeraddr , NULL , NULL , MODE_CLIENT , NTP_VERSION , 0 , 0 , FLAG_IBURST , 0 , 0 , NULL ) ;\n }\n else {\n # ifdef WORKER ctx = emalloc_zero ( sizeof ( * ctx ) ) ;\n ctx -> family = AF_UNSPEC ;\n ctx -> host_mode = T_Server ;\n ctx -> hmode = MODE_CLIENT ;\n ctx -> version = NTP_VERSION ;\n ctx -> flags = FLAG_IBURST ;\n memset ( & hints , 0 , sizeof ( hints ) ) ;\n hints . ai_family = ( u_short ) ctx -> family ;\n hints . ai_socktype = SOCK_DGRAM ;\n hints . ai_protocol = IPPROTO_UDP ;\n getaddrinfo_sometime ( * cmdline_servers , \"ntp\" , & hints , INITIAL_DNS_RETRY , & peer_name_resolved , ( void * ) ctx ) ;\n # else msyslog ( LOG_ERR , \"hostname %s can not be used, please use IP address instead.\\n\" , curr_peer -> addr -> address ) ;\n # endif }\n }\n curr_peer = HEAD_PFIFO ( ptree -> peers ) ;\n for ( ;\n curr_peer != NULL ;\n curr_peer = curr_peer -> link ) {\n ZERO_SOCK ( & peeraddr ) ;\n hmode = get_correct_host_mode ( curr_peer -> host_mode ) ;\n NTP_INSIST ( hmode != 0 ) ;\n if ( T_Pool == curr_peer -> host_mode ) {\n AF ( & peeraddr ) = curr_peer -> addr -> type ;\n peer_config ( & peeraddr , curr_peer -> addr -> address , NULL , hmode , curr_peer -> peerversion , curr_peer -> minpoll , curr_peer -> maxpoll , peerflag_bits ( curr_peer ) , curr_peer -> ttl , curr_peer -> peerkey , curr_peer -> group ) ;\n }\n else if ( is_ip_address ( curr_peer -> addr -> address , curr_peer -> addr -> type , & peeraddr ) ) {\n SET_PORT ( & peeraddr , NTP_PORT ) ;\n if ( is_sane_resolved_address ( & peeraddr , curr_peer -> host_mode ) ) peer_config ( & peeraddr , NULL , NULL , hmode , curr_peer -> peerversion , curr_peer -> minpoll , curr_peer -> maxpoll , peerflag_bits ( curr_peer ) , curr_peer -> ttl , curr_peer -> peerkey , curr_peer -> group ) ;\n }\n else {\n # ifdef WORKER ctx = emalloc_zero ( sizeof ( * ctx ) ) ;\n ctx -> family = curr_peer -> addr -> type ;\n ctx -> host_mode = curr_peer -> host_mode ;\n ctx -> hmode = hmode ;\n ctx -> version = curr_peer -> peerversion ;\n ctx -> minpoll = curr_peer -> minpoll ;\n ctx -> maxpoll = curr_peer -> maxpoll ;\n ctx -> flags = peerflag_bits ( curr_peer ) ;\n ctx -> ttl = curr_peer -> ttl ;\n ctx -> keyid = curr_peer -> peerkey ;\n ctx -> group = curr_peer -> group ;\n memset ( & hints , 0 , sizeof ( hints ) ) ;\n hints . ai_family = ctx -> family ;\n hints . ai_socktype = SOCK_DGRAM ;\n hints . ai_protocol = IPPROTO_UDP ;\n getaddrinfo_sometime ( curr_peer -> addr -> address , \"ntp\" , & hints , INITIAL_DNS_RETRY , & peer_name_resolved , ctx ) ;\n # else msyslog ( LOG_ERR , \"hostname %s can not be used, please use IP address instead.\\n\" , curr_peer -> addr -> address ) ;\n # endif }\n }\n }", "idx": 1911}
{"hash": -2928324134072492299, "project": "debian", "size": 4, "label": 0, "functionSource": "void remove_tap_listener_unistim_calls ( void ) {\n remove_tap_listener ( & ( the_tapinfo_struct . unistim_dummy ) ) ;\n have_unistim_tap_listener = FALSE ;\n }", "idx": 1912}
{"hash": -2064332158282087279, "project": "debian", "size": 14, "label": 0, "functionSource": "static void astream_try_base64_decode ( struct attachment_istream_part * part , const unsigned char * data , size_t size ) {\n size_t i ;\n int ret ;\n if ( part -> base64_failed || part -> base64_state == BASE64_STATE_EOM ) return ;\n for ( i = 0 ;\n i < size ;\n i ++ ) {\n ret = astream_try_base64_decode_char ( part , i , ( char ) data [ i ] ) ;\n if ( ret <= 0 ) {\n if ( ret < 0 ) part -> base64_failed = TRUE ;\n break ;\n }\n }\n }", "idx": 1913}
{"hash": 2895622461494525400, "project": "debian", "size": 37, "label": 0, "functionSource": "static void test_ps_conj_select ( ) {\n MYSQL_STMT * stmt ;\n int rc ;\n MYSQL_BIND my_bind [ 2 ] ;\n int32 int_data ;\n char str_data [ 32 ] ;\n unsigned long str_length ;\n char query [ MAX_TEST_QUERY_LENGTH ] ;\n myheader ( \"test_ps_conj_select\" ) ;\n rc = mysql_query ( mysql , \"drop table if exists t1\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"create table t1 (id1 int(11) NOT NULL default '0', \" \"value2 varchar(100), value1 varchar(100))\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"insert into t1 values (1, 'hh', 'hh'), \" \"(2, 'hh', 'hh'), (1, 'ii', 'ii'), (2, 'ii', 'ii')\" ) ;\n myquery ( rc ) ;\n strmov ( query , \"select id1, value1 from t1 where id1= ? or \" \"CONVERT(value1 USING utf8)= ?\" ) ;\n stmt = mysql_simple_prepare ( mysql , query ) ;\n check_stmt ( stmt ) ;\n verify_param_count ( stmt , 2 ) ;\n memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n my_bind [ 0 ] . buffer_type = MYSQL_TYPE_LONG ;\n my_bind [ 0 ] . buffer = ( void * ) & int_data ;\n my_bind [ 1 ] . buffer_type = MYSQL_TYPE_VAR_STRING ;\n my_bind [ 1 ] . buffer = ( void * ) str_data ;\n my_bind [ 1 ] . buffer_length = array_elements ( str_data ) ;\n my_bind [ 1 ] . length = & str_length ;\n rc = mysql_stmt_bind_param ( stmt , my_bind ) ;\n check_execute ( stmt , rc ) ;\n int_data = 1 ;\n strmov ( str_data , \"hh\" ) ;\n str_length = strlen ( str_data ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n rc = my_process_stmt_result ( stmt ) ;\n DIE_UNLESS ( rc == 3 ) ;\n mysql_stmt_close ( stmt ) ;\n }", "idx": 1914}
{"hash": 1414661670117003749, "project": "debian", "size": 37, "label": 0, "functionSource": "int reuse_partial_packfile_from_bitmap ( struct packed_git * * packfile , uint32_t * entries , off_t * up_to ) {\n static const double REUSE_PERCENT = 0.9 ;\n struct bitmap * result = bitmap_git . result ;\n uint32_t reuse_threshold ;\n uint32_t i , reuse_objects = 0 ;\n assert ( result ) ;\n for ( i = 0 ;\n i < result -> word_alloc ;\n ++ i ) {\n if ( result -> words [ i ] != ( eword_t ) ~ 0 ) {\n reuse_objects += ewah_bit_ctz64 ( ~ result -> words [ i ] ) ;\n break ;\n }\n reuse_objects += BITS_IN_EWORD ;\n }\n # ifdef GIT_BITMAP_DEBUG {\n const unsigned char * sha1 ;\n struct revindex_entry * entry ;\n entry = & bitmap_git . reverse_index -> revindex [ reuse_objects ] ;\n sha1 = nth_packed_object_sha1 ( bitmap_git . pack , entry -> nr ) ;\n fprintf ( stderr , \"Failed to reuse at %d (%016llx)\\n\" , reuse_objects , result -> words [ i ] ) ;\n fprintf ( stderr , \" %s\\n\" , sha1_to_hex ( sha1 ) ) ;\n }\n # endif if ( ! reuse_objects ) return - 1 ;\n if ( reuse_objects >= bitmap_git . pack -> num_objects ) {\n bitmap_git . reuse_objects = * entries = bitmap_git . pack -> num_objects ;\n * up_to = - 1 ;\n * packfile = bitmap_git . pack ;\n return 0 ;\n }\n reuse_threshold = bitmap_popcount ( bitmap_git . result ) * REUSE_PERCENT ;\n if ( reuse_objects < reuse_threshold ) return - 1 ;\n bitmap_git . reuse_objects = * entries = reuse_objects ;\n * up_to = bitmap_git . pack -> revindex [ reuse_objects ] . offset ;\n * packfile = bitmap_git . pack ;\n return 0 ;\n }", "idx": 1915}
{"hash": 4511225370772574632, "project": "debian", "size": 3, "label": 0, "functionSource": "PHP_FUNCTION ( uwsgi_worker_id ) {\n RETURN_LONG ( uwsgi . mywid ) ;\n }", "idx": 1916}
{"hash": 1760449185745615462, "project": "debian", "size": 12, "label": 0, "functionSource": "TSReturnCode TSUrlPortSet ( TSMBuffer bufp , TSMLoc obj , int port ) {\n sdk_assert ( sdk_sanity_check_mbuffer ( bufp ) == TS_SUCCESS ) ;\n sdk_assert ( sdk_sanity_check_url_handle ( obj ) == TS_SUCCESS ) ;\n if ( ! isWriteable ( bufp ) || ( port < 0 ) ) {\n return TS_ERROR ;\n }\n URL u ;\n u . m_heap = ( ( HdrHeapSDKHandle * ) bufp ) -> m_heap ;\n u . m_url_impl = ( URLImpl * ) obj ;\n u . port_set ( port ) ;\n return TS_SUCCESS ;\n }", "idx": 1917}
{"hash": -7076754245473579218, "project": "chrome", "size": 19, "label": 0, "functionSource": "char * evhttp_htmlescape ( const char * html ) {\n int i , new_size = 0 , old_size = strlen ( html ) ;\n char * escaped_html , * p ;\n char scratch_space [ 2 ] ;\n for ( i = 0 ;\n i < old_size ;\n ++ i ) new_size += strlen ( html_replace ( html [ i ] , scratch_space ) ) ;\n p = escaped_html = malloc ( new_size + 1 ) ;\n if ( escaped_html == NULL ) event_err ( 1 , \"%s: malloc(%d)\" , __func__ , new_size + 1 ) ;\n for ( i = 0 ;\n i < old_size ;\n ++ i ) {\n const char * replaced = html_replace ( html [ i ] , scratch_space ) ;\n strcpy ( p , replaced ) ;\n p += strlen ( replaced ) ;\n }\n * p = '\\0' ;\n return ( escaped_html ) ;\n }", "idx": 1918}
{"hash": 7549435794356072684, "project": "debian", "size": 7, "label": 0, "functionSource": "static VALUE ossl_asn1obj_get_sn ( VALUE self ) {\n VALUE val , ret = Qnil ;\n int nid ;\n val = ossl_asn1_get_value ( self ) ;\n if ( ( nid = OBJ_txt2nid ( StringValueCStr ( val ) ) ) != NID_undef ) ret = rb_str_new2 ( OBJ_nid2sn ( nid ) ) ;\n return ret ;\n }", "idx": 1919}
{"hash": -1315695702746584250, "project": "debian", "size": 17, "label": 0, "functionSource": "proto_item * proto_tree_add_bytes_format_value ( proto_tree * tree , int hfindex , tvbuff_t * tvb , gint start , gint length , const guint8 * start_ptr , const char * format , ... ) {\n proto_item * pi ;\n va_list ap ;\n header_field_info * hfinfo ;\n gint item_length ;\n PROTO_REGISTRAR_GET_NTH ( hfindex , hfinfo ) ;\n get_hfi_length ( hfinfo , tvb , start , & length , & item_length ) ;\n test_length ( hfinfo , tvb , start , item_length ) ;\n CHECK_FOR_NULL_TREE ( tree ) ;\n TRY_TO_FAKE_THIS_ITEM ( tree , hfindex , hfinfo ) ;\n if ( start_ptr ) pi = proto_tree_add_bytes ( tree , hfindex , tvb , start , length , start_ptr ) ;\n else pi = proto_tree_add_bytes ( tree , hfindex , tvb , start , length , tvb_get_ptr ( tvb , start , length ) ) ;\n va_start ( ap , format ) ;\n proto_tree_set_representation_value ( pi , format , ap ) ;\n va_end ( ap ) ;\n return pi ;\n }", "idx": 1920}
{"hash": 4715922168896528064, "project": "debian", "size": 142, "label": 0, "functionSource": "void jpc_ns_invlift_col ( jpc_fix_t * a , int numrows , int stride , int parity ) {\n jpc_fix_t * lptr ;\n jpc_fix_t * hptr ;\n register jpc_fix_t * lptr2 ;\n register jpc_fix_t * hptr2 ;\n register int n ;\n int llen ;\n llen = ( numrows + 1 - parity ) >> 1 ;\n if ( numrows > 1 ) {\n # if defined ( WT_DOSCALE ) lptr = & a [ 0 ] ;\n n = llen ;\n while ( n -- > 0 ) {\n lptr2 = lptr ;\n lptr2 [ 0 ] = jpc_fix_mul ( lptr2 [ 0 ] , jpc_dbltofix ( 1.0 / LGAIN ) ) ;\n ++ lptr2 ;\n lptr += stride ;\n }\n hptr = & a [ llen * stride ] ;\n n = numrows - llen ;\n while ( n -- > 0 ) {\n hptr2 = hptr ;\n hptr2 [ 0 ] = jpc_fix_mul ( hptr2 [ 0 ] , jpc_dbltofix ( 1.0 / HGAIN ) ) ;\n ++ hptr2 ;\n hptr += stride ;\n }\n # endif lptr = & a [ 0 ] ;\n hptr = & a [ llen * stride ] ;\n if ( ! parity ) {\n lptr2 = lptr ;\n hptr2 = hptr ;\n jpc_fix_minuseq ( lptr2 [ 0 ] , jpc_fix_mul ( jpc_dbltofix ( 2.0 * DELTA ) , hptr2 [ 0 ] ) ) ;\n ++ lptr2 ;\n ++ hptr2 ;\n lptr += stride ;\n }\n n = llen - ( ! parity ) - ( parity != ( numrows & 1 ) ) ;\n while ( n -- > 0 ) {\n lptr2 = lptr ;\n hptr2 = hptr ;\n jpc_fix_minuseq ( lptr2 [ 0 ] , jpc_fix_mul ( jpc_dbltofix ( DELTA ) , jpc_fix_add ( hptr2 [ 0 ] , hptr2 [ stride ] ) ) ) ;\n ++ lptr2 ;\n ++ hptr2 ;\n lptr += stride ;\n hptr += stride ;\n }\n if ( parity != ( numrows & 1 ) ) {\n lptr2 = lptr ;\n hptr2 = hptr ;\n jpc_fix_minuseq ( lptr2 [ 0 ] , jpc_fix_mul ( jpc_dbltofix ( 2.0 * DELTA ) , hptr2 [ 0 ] ) ) ;\n ++ lptr2 ;\n ++ hptr2 ;\n }\n lptr = & a [ 0 ] ;\n hptr = & a [ llen * stride ] ;\n if ( parity ) {\n lptr2 = lptr ;\n hptr2 = hptr ;\n jpc_fix_minuseq ( hptr2 [ 0 ] , jpc_fix_mul ( jpc_dbltofix ( 2.0 * GAMMA ) , lptr2 [ 0 ] ) ) ;\n ++ hptr2 ;\n ++ lptr2 ;\n hptr += stride ;\n }\n n = numrows - llen - parity - ( parity == ( numrows & 1 ) ) ;\n while ( n -- > 0 ) {\n lptr2 = lptr ;\n hptr2 = hptr ;\n jpc_fix_minuseq ( hptr2 [ 0 ] , jpc_fix_mul ( jpc_dbltofix ( GAMMA ) , jpc_fix_add ( lptr2 [ 0 ] , lptr2 [ stride ] ) ) ) ;\n ++ lptr2 ;\n ++ hptr2 ;\n hptr += stride ;\n lptr += stride ;\n }\n if ( parity == ( numrows & 1 ) ) {\n lptr2 = lptr ;\n hptr2 = hptr ;\n jpc_fix_minuseq ( hptr2 [ 0 ] , jpc_fix_mul ( jpc_dbltofix ( 2.0 * GAMMA ) , lptr2 [ 0 ] ) ) ;\n ++ lptr2 ;\n ++ hptr2 ;\n }\n lptr = & a [ 0 ] ;\n hptr = & a [ llen * stride ] ;\n if ( ! parity ) {\n lptr2 = lptr ;\n hptr2 = hptr ;\n jpc_fix_minuseq ( lptr2 [ 0 ] , jpc_fix_mul ( jpc_dbltofix ( 2.0 * BETA ) , hptr2 [ 0 ] ) ) ;\n ++ lptr2 ;\n ++ hptr2 ;\n lptr += stride ;\n }\n n = llen - ( ! parity ) - ( parity != ( numrows & 1 ) ) ;\n while ( n -- > 0 ) {\n lptr2 = lptr ;\n hptr2 = hptr ;\n jpc_fix_minuseq ( lptr2 [ 0 ] , jpc_fix_mul ( jpc_dbltofix ( BETA ) , jpc_fix_add ( hptr2 [ 0 ] , hptr2 [ stride ] ) ) ) ;\n ++ lptr2 ;\n ++ hptr2 ;\n lptr += stride ;\n hptr += stride ;\n }\n if ( parity != ( numrows & 1 ) ) {\n lptr2 = lptr ;\n hptr2 = hptr ;\n jpc_fix_minuseq ( lptr2 [ 0 ] , jpc_fix_mul ( jpc_dbltofix ( 2.0 * BETA ) , hptr2 [ 0 ] ) ) ;\n ++ lptr2 ;\n ++ hptr2 ;\n }\n lptr = & a [ 0 ] ;\n hptr = & a [ llen * stride ] ;\n if ( parity ) {\n lptr2 = lptr ;\n hptr2 = hptr ;\n jpc_fix_minuseq ( hptr2 [ 0 ] , jpc_fix_mul ( jpc_dbltofix ( 2.0 * ALPHA ) , lptr2 [ 0 ] ) ) ;\n ++ hptr2 ;\n ++ lptr2 ;\n hptr += stride ;\n }\n n = numrows - llen - parity - ( parity == ( numrows & 1 ) ) ;\n while ( n -- > 0 ) {\n lptr2 = lptr ;\n hptr2 = hptr ;\n jpc_fix_minuseq ( hptr2 [ 0 ] , jpc_fix_mul ( jpc_dbltofix ( ALPHA ) , jpc_fix_add ( lptr2 [ 0 ] , lptr2 [ stride ] ) ) ) ;\n ++ lptr2 ;\n ++ hptr2 ;\n hptr += stride ;\n lptr += stride ;\n }\n if ( parity == ( numrows & 1 ) ) {\n lptr2 = lptr ;\n hptr2 = hptr ;\n jpc_fix_minuseq ( hptr2 [ 0 ] , jpc_fix_mul ( jpc_dbltofix ( 2.0 * ALPHA ) , lptr2 [ 0 ] ) ) ;\n ++ lptr2 ;\n ++ hptr2 ;\n }\n }\n else {\n # if defined ( WT_LENONE ) if ( parity ) {\n lptr2 = & a [ 0 ] ;\n lptr2 [ 0 ] = jpc_fix_asr ( lptr2 [ 0 ] , 1 ) ;\n ++ lptr2 ;\n }\n # endif }\n }", "idx": 1921}
{"hash": 4489017523191997023, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h225_SEQUENCE_OF_BandwidthDetails ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence_of ( tvb , offset , actx , tree , hf_index , ett_h225_SEQUENCE_OF_BandwidthDetails , SEQUENCE_OF_BandwidthDetails_sequence_of ) ;\n return offset ;\n }", "idx": 1922}
{"hash": -4555950263653671147, "project": "debian", "size": 10, "label": 0, "functionSource": "static PyObject * string_rjust ( PyStringObject * self , PyObject * args ) {\n Py_ssize_t width ;\n char fillchar = ' ' ;\n if ( ! PyArg_ParseTuple ( args , \"n|c:rjust\" , & width , & fillchar ) ) return NULL ;\n if ( PyString_GET_SIZE ( self ) >= width && PyString_CheckExact ( self ) ) {\n Py_INCREF ( self ) ;\n return ( PyObject * ) self ;\n }\n return pad ( self , width - PyString_GET_SIZE ( self ) , 0 , fillchar ) ;\n }", "idx": 1923}
{"hash": 6500423400461365723, "project": "debian", "size": 4, "label": 0, "functionSource": "static Dwarf_Endianness dwarf_elf_object_access_get_byte_order ( void * obj_in ) {\n dwarf_elf_object_access_internals_t * obj = ( dwarf_elf_object_access_internals_t * ) obj_in ;\n return obj -> endianness ;\n }", "idx": 1924}
{"hash": -1929262071302712016, "project": "debian", "size": 5, "label": 0, "functionSource": "static void * Type_CrdInfo_Dup ( struct _cms_typehandler_struct * self , const void * Ptr , cmsUInt32Number n ) {\n return ( void * ) cmsMLUdup ( ( cmsMLU * ) Ptr ) ;\n cmsUNUSED_PARAMETER ( n ) ;\n cmsUNUSED_PARAMETER ( self ) ;\n }", "idx": 1925}
{"hash": 8085056330506804135, "project": "chrome", "size": 92, "label": 1, "functionSource": "static VP9_DENOISER_DECISION denoiser_filter ( const uint8_t * sig , int sig_stride , const uint8_t * mc_avg , int mc_avg_stride , uint8_t * avg , int avg_stride , int increase_denoising , BLOCK_SIZE bs , int motion_magnitude ) {\n int r , c ;\n const uint8_t * sig_start = sig ;\n const uint8_t * mc_avg_start = mc_avg ;\n uint8_t * avg_start = avg ;\n int diff , adj , absdiff , delta ;\n int adj_val [ ] = {\n 3 , 4 , 6 }\n ;\n int total_adj = 0 ;\n int shift_inc = 1 ;\n if ( motion_magnitude <= MOTION_MAGNITUDE_THRESHOLD ) {\n if ( increase_denoising ) {\n shift_inc = 2 ;\n }\n adj_val [ 0 ] += shift_inc ;\n adj_val [ 1 ] += shift_inc ;\n adj_val [ 2 ] += shift_inc ;\n }\n for ( r = 0 ;\n r < heights [ bs ] ;\n ++ r ) {\n for ( c = 0 ;\n c < widths [ bs ] ;\n ++ c ) {\n diff = mc_avg [ c ] - sig [ c ] ;\n absdiff = abs ( diff ) ;\n if ( absdiff <= absdiff_thresh ( bs , increase_denoising ) ) {\n avg [ c ] = mc_avg [ c ] ;\n total_adj += diff ;\n }\n else {\n switch ( absdiff ) {\n case 4 : case 5 : case 6 : case 7 : adj = adj_val [ 0 ] ;\n break ;\n case 8 : case 9 : case 10 : case 11 : case 12 : case 13 : case 14 : case 15 : adj = adj_val [ 1 ] ;\n break ;\n default : adj = adj_val [ 2 ] ;\n }\n if ( diff > 0 ) {\n avg [ c ] = MIN ( UINT8_MAX , sig [ c ] + adj ) ;\n total_adj += adj ;\n }\n else {\n avg [ c ] = MAX ( 0 , sig [ c ] - adj ) ;\n total_adj -= adj ;\n }\n }\n }\n sig += sig_stride ;\n avg += avg_stride ;\n mc_avg += mc_avg_stride ;\n }\n if ( abs ( total_adj ) <= total_adj_strong_thresh ( bs , increase_denoising ) ) {\n return FILTER_BLOCK ;\n }\n delta = ( ( abs ( total_adj ) - total_adj_strong_thresh ( bs , increase_denoising ) ) >> 8 ) + 1 ;\n if ( delta >= delta_thresh ( bs , increase_denoising ) ) {\n return COPY_BLOCK ;\n }\n mc_avg = mc_avg_start ;\n avg = avg_start ;\n sig = sig_start ;\n for ( r = 0 ;\n r < heights [ bs ] ;\n ++ r ) {\n for ( c = 0 ;\n c < widths [ bs ] ;\n ++ c ) {\n diff = mc_avg [ c ] - sig [ c ] ;\n adj = abs ( diff ) ;\n if ( adj > delta ) {\n adj = delta ;\n }\n if ( diff > 0 ) {\n avg [ c ] = MAX ( 0 , avg [ c ] - adj ) ;\n total_adj -= adj ;\n }\n else {\n avg [ c ] = MIN ( UINT8_MAX , avg [ c ] + adj ) ;\n total_adj += adj ;\n }\n }\n sig += sig_stride ;\n avg += avg_stride ;\n mc_avg += mc_avg_stride ;\n }\n if ( abs ( total_adj ) <= total_adj_weak_thresh ( bs , increase_denoising ) ) {\n return FILTER_BLOCK ;\n }\n return COPY_BLOCK ;\n }", "idx": 1926}
{"hash": -4885528830177756816, "project": "debian", "size": 60, "label": 0, "functionSource": "static int sort_one_index ( MI_CHECK * param , MI_INFO * info , MI_KEYDEF * keyinfo , my_off_t pagepos , File new_file ) {\n uint length , nod_flag , used_length , key_length ;\n uchar * buff , * keypos , * endpos ;\n uchar key [ HA_MAX_POSSIBLE_KEY_BUFF ] ;\n my_off_t new_page_pos , next_page ;\n char llbuff [ 22 ] ;\n DBUG_ENTER ( \"sort_one_index\" ) ;\n DBUG_ASSERT ( keyinfo -> key_alg != HA_KEY_ALG_RTREE ) ;\n new_page_pos = param -> new_file_pos ;\n param -> new_file_pos += keyinfo -> block_length ;\n if ( ! ( buff = ( uchar * ) my_alloca ( ( uint ) keyinfo -> block_length ) ) ) {\n mi_check_print_error ( param , \"Not enough memory for key block\" ) ;\n DBUG_RETURN ( - 1 ) ;\n }\n if ( ! _mi_fetch_keypage ( info , keyinfo , pagepos , DFLT_INIT_HITS , buff , 0 ) ) {\n mi_check_print_error ( param , \"Can't read key block from filepos: %s\" , llstr ( pagepos , llbuff ) ) ;\n goto err ;\n }\n if ( ( nod_flag = mi_test_if_nod ( buff ) ) || keyinfo -> flag & HA_FULLTEXT ) {\n used_length = mi_getint ( buff ) ;\n keypos = buff + 2 + nod_flag ;\n endpos = buff + used_length ;\n for ( ;\n ;\n ) {\n if ( nod_flag ) {\n next_page = _mi_kpos ( nod_flag , keypos ) ;\n _mi_kpointer ( info , keypos - nod_flag , param -> new_file_pos ) ;\n if ( sort_one_index ( param , info , keyinfo , next_page , new_file ) ) {\n DBUG_PRINT ( \"error\" , ( \"From page: %ld, keyoffset: %lu used_length: %d\" , ( ulong ) pagepos , ( ulong ) ( keypos - buff ) , ( int ) used_length ) ) ;\n DBUG_DUMP ( \"buff\" , ( uchar * ) buff , used_length ) ;\n goto err ;\n }\n }\n if ( keypos >= endpos || ( key_length = ( * keyinfo -> get_key ) ( keyinfo , nod_flag , & keypos , key ) ) == 0 ) break ;\n DBUG_ASSERT ( keypos <= endpos ) ;\n if ( keyinfo -> flag & HA_FULLTEXT ) {\n uint off ;\n int subkeys ;\n get_key_full_length_rdonly ( off , key ) ;\n subkeys = ft_sintXkorr ( key + off ) ;\n if ( subkeys < 0 ) {\n next_page = _mi_dpos ( info , 0 , key + key_length ) ;\n _mi_dpointer ( info , keypos - nod_flag - info -> s -> rec_reflength , param -> new_file_pos ) ;\n if ( sort_one_index ( param , info , & info -> s -> ft2_keyinfo , next_page , new_file ) ) goto err ;\n }\n }\n }\n }\n length = mi_getint ( buff ) ;\n bzero ( ( uchar * ) buff + length , keyinfo -> block_length - length ) ;\n if ( mysql_file_pwrite ( new_file , ( uchar * ) buff , ( uint ) keyinfo -> block_length , new_page_pos , MYF ( MY_NABP | MY_WAIT_IF_FULL ) ) ) {\n mi_check_print_error ( param , \"Can't write indexblock, error: %d\" , my_errno ) ;\n goto err ;\n }\n my_afree ( ( uchar * ) buff ) ;\n DBUG_RETURN ( 0 ) ;\n err : my_afree ( ( uchar * ) buff ) ;\n DBUG_RETURN ( 1 ) ;\n }", "idx": 1927}
{"hash": -8620097311326519087, "project": "chrome", "size": 16, "label": 0, "functionSource": "err_status_t crypto_policy_set_from_profile_for_rtp ( crypto_policy_t * policy , srtp_profile_t profile ) {\n switch ( profile ) {\n case srtp_profile_aes128_cm_sha1_80 : crypto_policy_set_aes_cm_128_hmac_sha1_80 ( policy ) ;\n break ;\n case srtp_profile_aes128_cm_sha1_32 : crypto_policy_set_aes_cm_128_hmac_sha1_32 ( policy ) ;\n break ;\n case srtp_profile_null_sha1_80 : crypto_policy_set_null_cipher_hmac_sha1_80 ( policy ) ;\n break ;\n case srtp_profile_aes256_cm_sha1_80 : crypto_policy_set_aes_cm_256_hmac_sha1_80 ( policy ) ;\n break ;\n case srtp_profile_aes256_cm_sha1_32 : crypto_policy_set_aes_cm_256_hmac_sha1_32 ( policy ) ;\n break ;\n case srtp_profile_null_sha1_32 : default : return err_status_bad_param ;\n }\n return err_status_ok ;\n }", "idx": 1928}
{"hash": 4489017523191997023, "project": "debian", "size": 9, "label": 0, "functionSource": "int dissect_h225_ExtendedAliasAddress_PDU ( tvbuff_t * tvb _U_ , packet_info * pinfo _U_ , proto_tree * tree _U_ , void * data _U_ ) {\n int offset = 0 ;\n asn1_ctx_t asn1_ctx ;\n asn1_ctx_init ( & asn1_ctx , ASN1_ENC_PER , TRUE , pinfo ) ;\n offset = dissect_h225_ExtendedAliasAddress ( tvb , offset , & asn1_ctx , tree , hf_h225_h225_ExtendedAliasAddress_PDU ) ;\n offset += 7 ;\n offset >>= 3 ;\n return offset ;\n }", "idx": 1929}
{"hash": 1202634027547122397, "project": "debian", "size": 9, "label": 0, "functionSource": "static const LIBSSH2_COMMON_METHOD * kex_get_method_by_name ( const char * name , size_t name_len , const LIBSSH2_COMMON_METHOD * * methodlist ) {\n while ( * methodlist ) {\n if ( ( strlen ( ( * methodlist ) -> name ) == name_len ) && ( strncmp ( ( * methodlist ) -> name , name , name_len ) == 0 ) ) {\n return * methodlist ;\n }\n methodlist ++ ;\n }\n return NULL ;\n }", "idx": 1930}
{"hash": -4299048894522449432, "project": "debian", "size": 15, "label": 0, "functionSource": "static void imc_decode_level_coefficients2 ( IMCContext * q , int * levlCoeffBuf , float * old_floor , float * flcoeffs1 , float * flcoeffs2 ) {\n int i ;\n for ( i = 0 ;\n i < BANDS ;\n i ++ ) {\n flcoeffs1 [ i ] = 0 ;\n if ( levlCoeffBuf [ i ] < 16 ) {\n flcoeffs1 [ i ] = imc_exp_tab2 [ levlCoeffBuf [ i ] ] * old_floor [ i ] ;\n flcoeffs2 [ i ] = ( levlCoeffBuf [ i ] - 7 ) * 0.83048 + flcoeffs2 [ i ] ;\n }\n else {\n flcoeffs1 [ i ] = old_floor [ i ] ;\n }\n }\n }", "idx": 1931}
{"hash": -5706788925640467782, "project": "chrome", "size": 8, "label": 1, "functionSource": "static void set_block_size ( VP9_COMP * const cpi , int mi_row , int mi_col , BLOCK_SIZE bsize ) {\n if ( cpi -> common . mi_cols > mi_col && cpi -> common . mi_rows > mi_row ) {\n MACROBLOCKD * const xd = & cpi -> mb . e_mbd ;\n set_modeinfo_offsets ( & cpi -> common , xd , mi_row , mi_col ) ;\n xd -> mi [ 0 ] -> mbmi . sb_type = bsize ;\n duplicate_mode_info_in_sb ( & cpi -> common , xd , mi_row , mi_col , bsize ) ;\n }\n }", "idx": 1932}
{"hash": 3599206110384554647, "project": "debian", "size": 97, "label": 0, "functionSource": "int i2d_ ## name ( type * a , unsigned char * * out ) ;\n DECLARE_ASN1_ITEM ( itname ) # define DECLARE_ASN1_ENCODE_FUNCTIONS_const ( type , name ) type * d2i_ ## name ( type * * a , const unsigned char * * in , long len ) ;\n int i2d_ ## name ( const type * a , unsigned char * * out ) ;\n DECLARE_ASN1_ITEM ( name ) # define DECLARE_ASN1_NDEF_FUNCTION ( name ) int i2d_ ## name ## _NDEF ( name * a , unsigned char * * out ) ;\n # define DECLARE_ASN1_FUNCTIONS_const ( name ) DECLARE_ASN1_ALLOC_FUNCTIONS ( name ) DECLARE_ASN1_ENCODE_FUNCTIONS_const ( name , name ) # define DECLARE_ASN1_ALLOC_FUNCTIONS_name ( type , name ) type * name ## _new ( void ) ;\n void name ## _free ( type * a ) ;\n # define DECLARE_ASN1_PRINT_FUNCTION ( stname ) DECLARE_ASN1_PRINT_FUNCTION_fname ( stname , stname ) # define DECLARE_ASN1_PRINT_FUNCTION_fname ( stname , fname ) int fname ## _print_ctx ( BIO * out , stname * x , int indent , const ASN1_PCTX * pctx ) ;\n # define D2I_OF ( type ) type * ( * ) ( type * * , const unsigned char * * , long ) # define I2D_OF ( type ) int ( * ) ( type * , unsigned char * * ) # define I2D_OF_const ( type ) int ( * ) ( const type * , unsigned char * * ) # define CHECKED_D2I_OF ( type , d2i ) ( ( d2i_of_void * ) ( 1 ? d2i : ( ( D2I_OF ( type ) ) 0 ) ) ) # define CHECKED_I2D_OF ( type , i2d ) ( ( i2d_of_void * ) ( 1 ? i2d : ( ( I2D_OF ( type ) ) 0 ) ) ) # define CHECKED_NEW_OF ( type , xnew ) ( ( void * ( * ) ( void ) ) ( 1 ? xnew : ( ( type * ( * ) ( void ) ) 0 ) ) ) # define CHECKED_PTR_OF ( type , p ) ( ( void * ) ( 1 ? p : ( type * ) 0 ) ) # define CHECKED_PPTR_OF ( type , p ) ( ( void * * ) ( 1 ? p : ( type * * ) 0 ) ) # define TYPEDEF_D2I_OF ( type ) typedef type * d2i_of_ ## type ( type * * , const unsigned char * * , long ) # define TYPEDEF_I2D_OF ( type ) typedef int i2d_of_ ## type ( type * , unsigned char * * ) # define TYPEDEF_D2I2D_OF ( type ) TYPEDEF_D2I_OF ( type ) ;\n TYPEDEF_I2D_OF ( type ) TYPEDEF_D2I2D_OF ( void ) ;\n # ifndef OPENSSL_EXPORT_VAR_AS_FUNCTION typedef const ASN1_ITEM ASN1_ITEM_EXP ;\n # define ASN1_ITEM_ptr ( iptr ) ( iptr ) # define ASN1_ITEM_ref ( iptr ) ( & ( iptr ## _it ) ) # define ASN1_ITEM_rptr ( ref ) ( & ( ref ## _it ) ) # define DECLARE_ASN1_ITEM ( name ) OPENSSL_EXTERN const ASN1_ITEM name ## _it ;\n # else typedef const ASN1_ITEM * ASN1_ITEM_EXP ( void ) ;\n # define ASN1_ITEM_ptr ( iptr ) ( iptr ( ) ) # define ASN1_ITEM_ref ( iptr ) ( iptr ## _it ) # define ASN1_ITEM_rptr ( ref ) ( ref ## _it ( ) ) # define DECLARE_ASN1_ITEM ( name ) const ASN1_ITEM * name ## _it ( void ) ;\n # endif # define ASN1_STRFLGS_ESC_2253 1 # define ASN1_STRFLGS_ESC_CTRL 2 # define ASN1_STRFLGS_ESC_MSB 4 # define ASN1_STRFLGS_ESC_QUOTE 8 # define CHARTYPE_PRINTABLESTRING 0x10 # define CHARTYPE_FIRST_ESC_2253 0x20 # define CHARTYPE_LAST_ESC_2253 0x40 # define ASN1_STRFLGS_UTF8_CONVERT 0x10 # define ASN1_STRFLGS_IGNORE_TYPE 0x20 # define ASN1_STRFLGS_SHOW_TYPE 0x40 # define ASN1_STRFLGS_DUMP_ALL 0x80 # define ASN1_STRFLGS_DUMP_UNKNOWN 0x100 # define ASN1_STRFLGS_DUMP_DER 0x200 # define ASN1_STRFLGS_ESC_2254 0x400 # define ASN1_STRFLGS_RFC2253 ( ASN1_STRFLGS_ESC_2253 | ASN1_STRFLGS_ESC_CTRL | ASN1_STRFLGS_ESC_MSB | ASN1_STRFLGS_UTF8_CONVERT | ASN1_STRFLGS_DUMP_UNKNOWN | ASN1_STRFLGS_DUMP_DER ) DEFINE_STACK_OF ( ASN1_INTEGER ) DEFINE_STACK_OF ( ASN1_GENERALSTRING ) DEFINE_STACK_OF ( ASN1_UTF8STRING ) typedef struct asn1_type_st {\n int type ;\n union {\n char * ptr ;\n ASN1_BOOLEAN boolean ;\n ASN1_STRING * asn1_string ;\n ASN1_OBJECT * object ;\n ASN1_INTEGER * integer ;\n ASN1_ENUMERATED * enumerated ;\n ASN1_BIT_STRING * bit_string ;\n ASN1_OCTET_STRING * octet_string ;\n ASN1_PRINTABLESTRING * printablestring ;\n ASN1_T61STRING * t61string ;\n ASN1_IA5STRING * ia5string ;\n ASN1_GENERALSTRING * generalstring ;\n ASN1_BMPSTRING * bmpstring ;\n ASN1_UNIVERSALSTRING * universalstring ;\n ASN1_UTCTIME * utctime ;\n ASN1_GENERALIZEDTIME * generalizedtime ;\n ASN1_VISIBLESTRING * visiblestring ;\n ASN1_UTF8STRING * utf8string ;\n ASN1_STRING * set ;\n ASN1_STRING * sequence ;\n ASN1_VALUE * asn1_value ;\n }\n value ;\n }\n ASN1_TYPE ;\n DEFINE_STACK_OF ( ASN1_TYPE ) typedef STACK_OF ( ASN1_TYPE ) ASN1_SEQUENCE_ANY ;\n DECLARE_ASN1_ENCODE_FUNCTIONS_const ( ASN1_SEQUENCE_ANY , ASN1_SEQUENCE_ANY ) DECLARE_ASN1_ENCODE_FUNCTIONS_const ( ASN1_SEQUENCE_ANY , ASN1_SET_ANY ) typedef struct BIT_STRING_BITNAME_st {\n int bitnum ;\n const char * lname ;\n const char * sname ;\n }\n BIT_STRING_BITNAME ;\n # define B_ASN1_TIME B_ASN1_UTCTIME | B_ASN1_GENERALIZEDTIME # define B_ASN1_PRINTABLE B_ASN1_NUMERICSTRING | B_ASN1_PRINTABLESTRING | B_ASN1_T61STRING | B_ASN1_IA5STRING | B_ASN1_BIT_STRING | B_ASN1_UNIVERSALSTRING | B_ASN1_BMPSTRING | B_ASN1_UTF8STRING | B_ASN1_SEQUENCE | B_ASN1_UNKNOWN # define B_ASN1_DIRECTORYSTRING B_ASN1_PRINTABLESTRING | B_ASN1_TELETEXSTRING | B_ASN1_BMPSTRING | B_ASN1_UNIVERSALSTRING | B_ASN1_UTF8STRING # define B_ASN1_DISPLAYTEXT B_ASN1_IA5STRING | B_ASN1_VISIBLESTRING | B_ASN1_BMPSTRING | B_ASN1_UTF8STRING DECLARE_ASN1_FUNCTIONS_fname ( ASN1_TYPE , ASN1_ANY , ASN1_TYPE ) int ASN1_TYPE_get ( const ASN1_TYPE * a ) ;\n void ASN1_TYPE_set ( ASN1_TYPE * a , int type , void * value ) ;\n int ASN1_TYPE_set1 ( ASN1_TYPE * a , int type , const void * value ) ;\n int ASN1_TYPE_cmp ( const ASN1_TYPE * a , const ASN1_TYPE * b ) ;\n ASN1_TYPE * ASN1_TYPE_pack_sequence ( const ASN1_ITEM * it , void * s , ASN1_TYPE * * t ) ;\n void * ASN1_TYPE_unpack_sequence ( const ASN1_ITEM * it , const ASN1_TYPE * t ) ;\n ASN1_OBJECT * ASN1_OBJECT_new ( void ) ;\n void ASN1_OBJECT_free ( ASN1_OBJECT * a ) ;\n int i2d_ASN1_OBJECT ( const ASN1_OBJECT * a , unsigned char * * pp ) ;\n ASN1_OBJECT * d2i_ASN1_OBJECT ( ASN1_OBJECT * * a , const unsigned char * * pp , long length ) ;\n DECLARE_ASN1_ITEM ( ASN1_OBJECT ) DEFINE_STACK_OF ( ASN1_OBJECT ) ASN1_STRING * ASN1_STRING_new ( void ) ;\n void ASN1_STRING_free ( ASN1_STRING * a ) ;\n void ASN1_STRING_clear_free ( ASN1_STRING * a ) ;\n int ASN1_STRING_copy ( ASN1_STRING * dst , const ASN1_STRING * str ) ;\n ASN1_STRING * ASN1_STRING_dup ( const ASN1_STRING * a ) ;\n ASN1_STRING * ASN1_STRING_type_new ( int type ) ;\n int ASN1_STRING_cmp ( const ASN1_STRING * a , const ASN1_STRING * b ) ;\n int ASN1_STRING_set ( ASN1_STRING * str , const void * data , int len ) ;\n void ASN1_STRING_set0 ( ASN1_STRING * str , void * data , int len ) ;\n int ASN1_STRING_length ( const ASN1_STRING * x ) ;\n void ASN1_STRING_length_set ( ASN1_STRING * x , int n ) ;\n int ASN1_STRING_type ( const ASN1_STRING * x ) ;\n DEPRECATEDIN_1_1_0 ( unsigned char * ASN1_STRING_data ( ASN1_STRING * x ) ) const unsigned char * ASN1_STRING_get0_data ( const ASN1_STRING * x ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_BIT_STRING ) int ASN1_BIT_STRING_set ( ASN1_BIT_STRING * a , unsigned char * d , int length ) ;\n int ASN1_BIT_STRING_set_bit ( ASN1_BIT_STRING * a , int n , int value ) ;\n int ASN1_BIT_STRING_get_bit ( const ASN1_BIT_STRING * a , int n ) ;\n int ASN1_BIT_STRING_check ( const ASN1_BIT_STRING * a , const unsigned char * flags , int flags_len ) ;\n int ASN1_BIT_STRING_name_print ( BIO * out , ASN1_BIT_STRING * bs , BIT_STRING_BITNAME * tbl , int indent ) ;\n int ASN1_BIT_STRING_num_asc ( const char * name , BIT_STRING_BITNAME * tbl ) ;\n int ASN1_BIT_STRING_set_asc ( ASN1_BIT_STRING * bs , const char * name , int value , BIT_STRING_BITNAME * tbl ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_INTEGER ) ASN1_INTEGER * d2i_ASN1_UINTEGER ( ASN1_INTEGER * * a , const unsigned char * * pp , long length ) ;\n ASN1_INTEGER * ASN1_INTEGER_dup ( const ASN1_INTEGER * x ) ;\n int ASN1_INTEGER_cmp ( const ASN1_INTEGER * x , const ASN1_INTEGER * y ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_ENUMERATED ) int ASN1_UTCTIME_check ( const ASN1_UTCTIME * a ) ;\n ASN1_UTCTIME * ASN1_UTCTIME_set ( ASN1_UTCTIME * s , time_t t ) ;\n ASN1_UTCTIME * ASN1_UTCTIME_adj ( ASN1_UTCTIME * s , time_t t , int offset_day , long offset_sec ) ;\n int ASN1_UTCTIME_set_string ( ASN1_UTCTIME * s , const char * str ) ;\n int ASN1_UTCTIME_cmp_time_t ( const ASN1_UTCTIME * s , time_t t ) ;\n int ASN1_GENERALIZEDTIME_check ( const ASN1_GENERALIZEDTIME * a ) ;\n ASN1_GENERALIZEDTIME * ASN1_GENERALIZEDTIME_set ( ASN1_GENERALIZEDTIME * s , time_t t ) ;\n ASN1_GENERALIZEDTIME * ASN1_GENERALIZEDTIME_adj ( ASN1_GENERALIZEDTIME * s , time_t t , int offset_day , long offset_sec ) ;\n int ASN1_GENERALIZEDTIME_set_string ( ASN1_GENERALIZEDTIME * s , const char * str ) ;\n int ASN1_TIME_diff ( int * pday , int * psec , const ASN1_TIME * from , const ASN1_TIME * to ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_OCTET_STRING ) ASN1_OCTET_STRING * ASN1_OCTET_STRING_dup ( const ASN1_OCTET_STRING * a ) ;\n int ASN1_OCTET_STRING_cmp ( const ASN1_OCTET_STRING * a , const ASN1_OCTET_STRING * b ) ;\n int ASN1_OCTET_STRING_set ( ASN1_OCTET_STRING * str , const unsigned char * data , int len ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_VISIBLESTRING ) DECLARE_ASN1_FUNCTIONS ( ASN1_UNIVERSALSTRING ) DECLARE_ASN1_FUNCTIONS ( ASN1_UTF8STRING ) DECLARE_ASN1_FUNCTIONS ( ASN1_NULL ) DECLARE_ASN1_FUNCTIONS ( ASN1_BMPSTRING ) int UTF8_getc ( const unsigned char * str , int len , unsigned long * val ) ;\n int UTF8_putc ( unsigned char * str , int len , unsigned long value ) ;\n DECLARE_ASN1_FUNCTIONS_name ( ASN1_STRING , ASN1_PRINTABLE ) DECLARE_ASN1_FUNCTIONS_name ( ASN1_STRING , DIRECTORYSTRING ) DECLARE_ASN1_FUNCTIONS_name ( ASN1_STRING , DISPLAYTEXT ) DECLARE_ASN1_FUNCTIONS ( ASN1_PRINTABLESTRING ) DECLARE_ASN1_FUNCTIONS ( ASN1_T61STRING ) DECLARE_ASN1_FUNCTIONS ( ASN1_IA5STRING ) DECLARE_ASN1_FUNCTIONS ( ASN1_GENERALSTRING )", "idx": 1933}
{"hash": -2607754285145856562, "project": "debian", "size": 12, "label": 0, "functionSource": "static void set_date_time ( unsigned char * p , time_t t ) {\n struct tm tm ;\n get_tmfromtime ( & tm , & t ) ;\n set_digit ( p , 4 , tm . tm_year + 1900 ) ;\n set_digit ( p + 4 , 2 , tm . tm_mon + 1 ) ;\n set_digit ( p + 6 , 2 , tm . tm_mday ) ;\n set_digit ( p + 8 , 2 , tm . tm_hour ) ;\n set_digit ( p + 10 , 2 , tm . tm_min ) ;\n set_digit ( p + 12 , 2 , tm . tm_sec ) ;\n set_digit ( p + 14 , 2 , 0 ) ;\n set_num_712 ( p + 16 , ( char ) ( get_gmoffset ( & tm ) / ( 60 * 15 ) ) ) ;\n }", "idx": 1934}
{"hash": 2064081176034684128, "project": "debian", "size": 93, "label": 0, "functionSource": "static int matroska_parse_laces ( MatroskaDemuxContext * matroska , uint8_t * * buf , int * buf_size , int type , uint32_t * * lace_buf , int * laces ) {\n int res = 0 , n , size = * buf_size ;\n uint8_t * data = * buf ;\n uint32_t * lace_size ;\n if ( ! type ) {\n * laces = 1 ;\n * lace_buf = av_mallocz ( sizeof ( int ) ) ;\n if ( ! * lace_buf ) return AVERROR ( ENOMEM ) ;\n * lace_buf [ 0 ] = size ;\n return 0 ;\n }\n assert ( size > 0 ) ;\n * laces = * data + 1 ;\n data += 1 ;\n size -= 1 ;\n lace_size = av_mallocz ( * laces * sizeof ( int ) ) ;\n if ( ! lace_size ) return AVERROR ( ENOMEM ) ;\n switch ( type ) {\n case 0x1 : {\n uint8_t temp ;\n uint32_t total = 0 ;\n for ( n = 0 ;\n res == 0 && n < * laces - 1 ;\n n ++ ) {\n while ( 1 ) {\n if ( size == 0 ) {\n res = AVERROR_EOF ;\n break ;\n }\n temp = * data ;\n lace_size [ n ] += temp ;\n data += 1 ;\n size -= 1 ;\n if ( temp != 0xff ) break ;\n }\n total += lace_size [ n ] ;\n }\n if ( size <= total ) {\n res = AVERROR_INVALIDDATA ;\n break ;\n }\n lace_size [ n ] = size - total ;\n break ;\n }\n case 0x2 : if ( size % ( * laces ) ) {\n res = AVERROR_INVALIDDATA ;\n break ;\n }\n for ( n = 0 ;\n n < * laces ;\n n ++ ) lace_size [ n ] = size / * laces ;\n break ;\n case 0x3 : {\n uint64_t num ;\n uint64_t total ;\n n = matroska_ebmlnum_uint ( matroska , data , size , & num ) ;\n if ( n < 0 ) {\n av_log ( matroska -> ctx , AV_LOG_INFO , \"EBML block data error\\n\" ) ;\n res = n ;\n break ;\n }\n data += n ;\n size -= n ;\n total = lace_size [ 0 ] = num ;\n for ( n = 1 ;\n res == 0 && n < * laces - 1 ;\n n ++ ) {\n int64_t snum ;\n int r ;\n r = matroska_ebmlnum_sint ( matroska , data , size , & snum ) ;\n if ( r < 0 ) {\n av_log ( matroska -> ctx , AV_LOG_INFO , \"EBML block data error\\n\" ) ;\n res = r ;\n break ;\n }\n data += r ;\n size -= r ;\n lace_size [ n ] = lace_size [ n - 1 ] + snum ;\n total += lace_size [ n ] ;\n }\n if ( size <= total ) {\n res = AVERROR_INVALIDDATA ;\n break ;\n }\n lace_size [ * laces - 1 ] = size - total ;\n break ;\n }\n }\n * buf = data ;\n * lace_buf = lace_size ;\n * buf_size = size ;\n return res ;\n }", "idx": 1935}
{"hash": -7076754245473579218, "project": "chrome", "size": 5, "label": 0, "functionSource": "void evhttp_connection_set_local_address ( struct evhttp_connection * evcon , const char * address ) {\n assert ( evcon -> state == EVCON_DISCONNECTED ) ;\n if ( evcon -> bind_address ) free ( evcon -> bind_address ) ;\n if ( ( evcon -> bind_address = strdup ( address ) ) == NULL ) event_err ( 1 , \"%s: strdup\" , __func__ ) ;\n }", "idx": 1936}
{"hash": 2830888773500127914, "project": "debian", "size": 8, "label": 0, "functionSource": "void report_clusters_compatible ( void ) {\n if ( user_opts . check ) {\n pg_log ( PG_REPORT , \"\\n*Clusters are compatible*\\n\" ) ;\n stop_postmaster ( false ) ;\n exit ( 0 ) ;\n }\n pg_log ( PG_REPORT , \"\\n\" \"If pg_upgrade fails after this point, you must re-initdb the\\n\" \"new cluster before continuing.\\n\" ) ;\n }", "idx": 1937}
{"hash": 1760449185745615462, "project": "debian", "size": 15, "label": 0, "functionSource": "TSReturnCode TSHttpTxnConfigFloatSet ( TSHttpTxn txnp , TSOverridableConfigKey conf , TSMgmtFloat value ) {\n sdk_assert ( sdk_sanity_check_txn ( txnp ) == TS_SUCCESS ) ;\n HttpSM * s = reinterpret_cast < HttpSM * > ( txnp ) ;\n OverridableDataType type ;\n s -> t_state . setup_per_txn_configs ( ) ;\n TSMgmtFloat * dest = static_cast < TSMgmtFloat * > ( _conf_to_memberp ( conf , s -> t_state . txn_conf , & type ) ) ;\n if ( type != OVERRIDABLE_TYPE_FLOAT ) {\n return TS_ERROR ;\n }\n if ( dest ) {\n * dest = value ;\n return TS_SUCCESS ;\n }\n return TS_SUCCESS ;\n }", "idx": 1938}
{"hash": 5366785327268799421, "project": "chrome", "size": 5, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( MimeHandlerViewTest , DataUrl ) {\n const char * kDataUrlCsv = \"data:text/csv;\nbase64,Y29udGVudCB0byByZWFkCg==\" ;\n RunTestWithUrl ( GURL ( kDataUrlCsv ) ) ;\n }", "idx": 1939}
{"hash": -1315695702746584250, "project": "debian", "size": 12, "label": 0, "functionSource": "proto_item * proto_tree_add_boolean_format ( proto_tree * tree , int hfindex , tvbuff_t * tvb , gint start , gint length , guint32 value , const char * format , ... ) {\n proto_item * pi ;\n va_list ap ;\n pi = proto_tree_add_boolean ( tree , hfindex , tvb , start , length , value ) ;\n if ( pi != tree ) {\n TRY_TO_FAKE_THIS_REPR ( pi ) ;\n va_start ( ap , format ) ;\n proto_tree_set_representation ( pi , format , ap ) ;\n va_end ( ap ) ;\n }\n return pi ;\n }", "idx": 1940}
{"hash": -46053003459728034, "project": "chrome", "size": 38, "label": 0, "functionSource": "qcms_bool compute_precache ( struct curveType * trc , uint8_t * output ) {\n if ( trc -> type == PARAMETRIC_CURVE_TYPE ) {\n float gamma_table [ 256 ] ;\n uint16_t gamma_table_uint [ 256 ] ;\n uint16_t i ;\n uint16_t * inverted ;\n int inverted_size = 256 ;\n compute_curve_gamma_table_type_parametric ( gamma_table , trc -> parameter , trc -> count ) ;\n for ( i = 0 ;\n i < 256 ;\n i ++ ) {\n gamma_table_uint [ i ] = ( uint16_t ) ( gamma_table [ i ] * 65535 ) ;\n }\n if ( inverted_size < 256 ) inverted_size = 256 ;\n inverted = invert_lut ( gamma_table_uint , 256 , inverted_size ) ;\n if ( ! inverted ) return false ;\n compute_precache_lut ( output , inverted , inverted_size ) ;\n free ( inverted ) ;\n }\n else {\n if ( trc -> count == 0 ) {\n compute_precache_linear ( output ) ;\n }\n else if ( trc -> count == 1 ) {\n compute_precache_pow ( output , 1. / u8Fixed8Number_to_float ( trc -> data [ 0 ] ) ) ;\n }\n else {\n uint16_t * inverted ;\n int inverted_size = trc -> count ;\n if ( inverted_size < 256 ) inverted_size = 256 ;\n inverted = invert_lut ( trc -> data , trc -> count , inverted_size ) ;\n if ( ! inverted ) return false ;\n compute_precache_lut ( output , inverted , inverted_size ) ;\n free ( inverted ) ;\n }\n }\n return true ;\n }", "idx": 1941}
{"hash": 373200843854506734, "project": "chrome", "size": 25, "label": 0, "functionSource": "static UBool makeFromUTable ( CnvExtData * extData , UCMTable * table ) {\n uint16_t * stage1 ;\n int32_t i , stage1Top , fromUCount ;\n fromUCount = prepareFromUMappings ( table ) ;\n extData -> fromUTableUChars = utm_open ( \"cnv extension fromUTableUChars\" , 0x10000 , UCNV_EXT_FROM_U_DATA_MASK + 1 , 2 ) ;\n extData -> fromUTableValues = utm_open ( \"cnv extension fromUTableValues\" , 0x10000 , UCNV_EXT_FROM_U_DATA_MASK + 1 , 4 ) ;\n extData -> fromUBytes = utm_open ( \"cnv extension fromUBytes\" , 0x10000 , UCNV_EXT_FROM_U_DATA_MASK + 1 , 1 ) ;\n extData -> stage2Top = MBCS_STAGE_2_FIRST_ASSIGNED ;\n extData -> stage3Top = MBCS_STAGE_3_FIRST_ASSIGNED ;\n extData -> stage3b [ 1 ] = UCNV_EXT_FROM_U_SUBCHAR1 ;\n extData -> stage3bTop = 2 ;\n utm_alloc ( extData -> fromUTableUChars ) ;\n utm_alloc ( extData -> fromUTableValues ) ;\n if ( ! generateFromUTrie ( extData , table , fromUCount ) ) {\n return FALSE ;\n }\n stage1 = extData -> stage1 ;\n stage1Top = extData -> stage1Top ;\n for ( i = 0 ;\n i < stage1Top ;\n ++ i ) {\n stage1 [ i ] = ( uint16_t ) ( stage1 [ i ] + stage1Top ) ;\n }\n return TRUE ;\n }", "idx": 1942}
{"hash": 6752827389510428348, "project": "chrome", "size": 13, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( ClientHintsBrowserTest , ClientHintsLifetimeNotPersistedJavaScriptBlocked ) {\n ContentSettingsForOneType host_settings ;\n ui_test_utils : : NavigateToURL ( browser ( ) , without_accept_ch_without_lifetime_url ( ) ) ;\n HostContentSettingsMapFactory : : GetForProfile ( browser ( ) -> profile ( ) ) -> SetContentSettingDefaultScope ( accept_ch_with_lifetime_url ( ) , GURL ( ) , CONTENT_SETTINGS_TYPE_JAVASCRIPT , std : : string ( ) , CONTENT_SETTING_BLOCK ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , accept_ch_with_lifetime_url ( ) ) ;\n HostContentSettingsMapFactory : : GetForProfile ( browser ( ) -> profile ( ) ) -> GetSettingsForOneType ( CONTENT_SETTINGS_TYPE_CLIENT_HINTS , std : : string ( ) , & host_settings ) ;\n EXPECT_EQ ( 0u , host_settings . size ( ) ) ;\n VerifyContentSettingsNotNotified ( ) ;\n HostContentSettingsMapFactory : : GetForProfile ( browser ( ) -> profile ( ) ) -> SetContentSettingDefaultScope ( accept_ch_with_lifetime_url ( ) , GURL ( ) , CONTENT_SETTINGS_TYPE_JAVASCRIPT , std : : string ( ) , CONTENT_SETTING_ALLOW ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , accept_ch_with_lifetime_url ( ) ) ;\n HostContentSettingsMapFactory : : GetForProfile ( browser ( ) -> profile ( ) ) -> GetSettingsForOneType ( CONTENT_SETTINGS_TYPE_CLIENT_HINTS , std : : string ( ) , & host_settings ) ;\n EXPECT_EQ ( 1u , host_settings . size ( ) ) ;\n }", "idx": 1943}
{"hash": -5420171864670538459, "project": "debian", "size": 22, "label": 0, "functionSource": "static void icount_warp_rt ( void * opaque ) {\n if ( vm_clock_warp_start == - 1 ) {\n return ;\n }\n if ( runstate_is_running ( ) ) {\n int64_t clock = qemu_get_clock_ns ( rt_clock ) ;\n int64_t warp_delta = clock - vm_clock_warp_start ;\n if ( use_icount == 1 ) {\n qemu_icount_bias += warp_delta ;\n }\n else {\n int64_t cur_time = cpu_get_clock ( ) ;\n int64_t cur_icount = qemu_get_clock_ns ( vm_clock ) ;\n int64_t delta = cur_time - cur_icount ;\n qemu_icount_bias += MIN ( warp_delta , delta ) ;\n }\n if ( qemu_clock_expired ( vm_clock ) ) {\n qemu_notify_event ( ) ;\n }\n }\n vm_clock_warp_start = - 1 ;\n }", "idx": 1944}
{"hash": -6068399010699045437, "project": "debian", "size": 3, "label": 0, "functionSource": "static inline void get_array ( GetBitContext * gb , int * dst , int len , int bits ) {\n while ( len -- ) * dst ++ = get_bits ( gb , bits ) ;\n }", "idx": 1945}
{"hash": 6336384260629386331, "project": "debian", "size": 34, "label": 0, "functionSource": "static int dissect_zbee_zcl_poll_ctrl ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , void * data ) {\n zbee_zcl_packet * zcl ;\n guint offset = 0 ;\n guint8 cmd_id ;\n if ( data == NULL ) return 0 ;\n zcl = ( zbee_zcl_packet * ) data ;\n cmd_id = zcl -> cmd_id ;\n if ( zcl -> direction == ZBEE_ZCL_FCF_TO_SERVER ) {\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \"%s, Seq: %u\" , val_to_str_const ( cmd_id , zbee_zcl_poll_ctrl_srv_rx_cmd_names , \"Unknown Command\" ) , zcl -> tran_seqno ) ;\n proto_tree_add_item ( tree , hf_zbee_zcl_poll_ctrl_srv_rx_cmd_id , tvb , offset , 1 , cmd_id ) ;\n offset ++ ;\n switch ( cmd_id ) {\n case ZBEE_ZCL_CMD_ID_POLL_CTRL_CHECK_IN_RESPONSE : proto_tree_add_item ( tree , hf_zbee_zcl_poll_ctrl_start_fast_polling , tvb , offset , 1 , ENC_NA ) ;\n offset ++ ;\n proto_tree_add_item ( tree , hf_zbee_zcl_poll_ctrl_fast_poll_timeout , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n break ;\n case ZBEE_ZCL_CMD_ID_POLL_CTRL_FAST_POLL_STOP : break ;\n case ZBEE_ZCL_CMD_ID_POLL_CTRL_SET_LONG_POLL : proto_tree_add_item ( tree , hf_zbee_zcl_poll_ctrl_new_long_poll_interval , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n break ;\n case ZBEE_ZCL_CMD_ID_POLL_CTRL_SET_SHORT_POLL : proto_tree_add_item ( tree , hf_zbee_zcl_poll_ctrl_new_short_poll_interval , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n break ;\n default : break ;\n }\n }\n else {\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \"%s, Seq: %u\" , val_to_str_const ( cmd_id , zbee_zcl_poll_ctrl_srv_tx_cmd_names , \"Unknown Command\" ) , zcl -> tran_seqno ) ;\n proto_tree_add_item ( tree , hf_zbee_zcl_poll_ctrl_srv_tx_cmd_id , tvb , offset , 1 , ENC_NA ) ;\n offset ++ ;\n switch ( cmd_id ) {\n case ZBEE_ZCL_CMD_ID_POLL_CTRL_CHECK_IN : default : break ;\n }\n }\n return tvb_captured_length ( tvb ) ;\n }", "idx": 1946}
{"hash": -9197960073880365676, "project": "debian", "size": 11, "label": 0, "functionSource": "Gif_Stream * Gif_FullReadFile ( FILE * f , int read_flags , const char * landmark , Gif_ReadErrorHandler h ) {\n Gif_Reader grr ;\n if ( ! f ) return 0 ;\n grr . f = f ;\n grr . pos = 0 ;\n grr . is_record = 0 ;\n grr . byte_getter = file_byte_getter ;\n grr . block_getter = file_block_getter ;\n grr . eofer = file_eofer ;\n return read_gif ( & grr , read_flags , landmark , h ) ;\n }", "idx": 1947}
{"hash": 1366214969540455677, "project": "debian", "size": 16, "label": 0, "functionSource": "MSG_PROCESS_RETURN tls_process_next_proto ( SSL * s , PACKET * pkt ) {\n PACKET next_proto , padding ;\n size_t next_proto_len ;\n if ( ! PACKET_get_length_prefixed_1 ( pkt , & next_proto ) || ! PACKET_get_length_prefixed_1 ( pkt , & padding ) || PACKET_remaining ( pkt ) > 0 ) {\n SSLerr ( SSL_F_TLS_PROCESS_NEXT_PROTO , SSL_R_LENGTH_MISMATCH ) ;\n goto err ;\n }\n if ( ! PACKET_memdup ( & next_proto , & s -> next_proto_negotiated , & next_proto_len ) ) {\n s -> next_proto_negotiated_len = 0 ;\n goto err ;\n }\n s -> next_proto_negotiated_len = ( unsigned char ) next_proto_len ;\n return MSG_PROCESS_CONTINUE_READING ;\n err : ossl_statem_set_error ( s ) ;\n return MSG_PROCESS_ERROR ;\n }", "idx": 1948}
{"hash": 7889142355347191490, "project": "debian", "size": 23, "label": 0, "functionSource": "static struct sock * udp_v6_mcast_next ( struct net * net , struct sock * sk , __be16 loc_port , struct in6_addr * loc_addr , __be16 rmt_port , struct in6_addr * rmt_addr , int dif ) {\n struct hlist_nulls_node * node ;\n struct sock * s = sk ;\n unsigned short num = ntohs ( loc_port ) ;\n sk_nulls_for_each_from ( s , node ) {\n struct inet_sock * inet = inet_sk ( s ) ;\n if ( ! net_eq ( sock_net ( s ) , net ) ) continue ;\n if ( udp_sk ( s ) -> udp_port_hash == num && s -> sk_family == PF_INET6 ) {\n struct ipv6_pinfo * np = inet6_sk ( s ) ;\n if ( inet -> inet_dport ) {\n if ( inet -> inet_dport != rmt_port ) continue ;\n }\n if ( ! ipv6_addr_any ( & np -> daddr ) && ! ipv6_addr_equal ( & np -> daddr , rmt_addr ) ) continue ;\n if ( s -> sk_bound_dev_if && s -> sk_bound_dev_if != dif ) continue ;\n if ( ! ipv6_addr_any ( & np -> rcv_saddr ) ) {\n if ( ! ipv6_addr_equal ( & np -> rcv_saddr , loc_addr ) ) continue ;\n }\n if ( ! inet6_mc_check ( s , loc_addr , rmt_addr ) ) continue ;\n return s ;\n }\n }\n return NULL ;\n }", "idx": 1949}
{"hash": -3528294111382233554, "project": "chrome", "size": 142, "label": 1, "functionSource": "static void _Latin1FromUnicodeWithOffsets ( UConverterFromUnicodeArgs * pArgs , UErrorCode * pErrorCode ) {\n UConverter * cnv ;\n const UChar * source , * sourceLimit ;\n uint8_t * target , * oldTarget ;\n int32_t targetCapacity , length ;\n int32_t * offsets ;\n UChar32 cp ;\n UChar c , max ;\n int32_t sourceIndex ;\n cnv = pArgs -> converter ;\n source = pArgs -> source ;\n sourceLimit = pArgs -> sourceLimit ;\n target = oldTarget = ( uint8_t * ) pArgs -> target ;\n targetCapacity = ( int32_t ) ( pArgs -> targetLimit - pArgs -> target ) ;\n offsets = pArgs -> offsets ;\n if ( cnv -> sharedData == & _Latin1Data ) {\n max = 0xff ;\n }\n else {\n max = 0x7f ;\n }\n cp = cnv -> fromUChar32 ;\n sourceIndex = cp == 0 ? 0 : - 1 ;\n length = ( int32_t ) ( sourceLimit - source ) ;\n if ( length < targetCapacity ) {\n targetCapacity = length ;\n }\n if ( cp != 0 && targetCapacity > 0 ) {\n goto getTrail ;\n }\n # if LATIN1_UNROLL_FROM_UNICODE if ( targetCapacity >= 16 ) {\n int32_t count , loops ;\n UChar u , oredChars ;\n loops = count = targetCapacity >> 4 ;\n do {\n oredChars = u = * source ++ ;\n * target ++ = ( uint8_t ) u ;\n oredChars |= u = * source ++ ;\n * target ++ = ( uint8_t ) u ;\n oredChars |= u = * source ++ ;\n * target ++ = ( uint8_t ) u ;\n oredChars |= u = * source ++ ;\n * target ++ = ( uint8_t ) u ;\n oredChars |= u = * source ++ ;\n * target ++ = ( uint8_t ) u ;\n oredChars |= u = * source ++ ;\n * target ++ = ( uint8_t ) u ;\n oredChars |= u = * source ++ ;\n * target ++ = ( uint8_t ) u ;\n oredChars |= u = * source ++ ;\n * target ++ = ( uint8_t ) u ;\n oredChars |= u = * source ++ ;\n * target ++ = ( uint8_t ) u ;\n oredChars |= u = * source ++ ;\n * target ++ = ( uint8_t ) u ;\n oredChars |= u = * source ++ ;\n * target ++ = ( uint8_t ) u ;\n oredChars |= u = * source ++ ;\n * target ++ = ( uint8_t ) u ;\n oredChars |= u = * source ++ ;\n * target ++ = ( uint8_t ) u ;\n oredChars |= u = * source ++ ;\n * target ++ = ( uint8_t ) u ;\n oredChars |= u = * source ++ ;\n * target ++ = ( uint8_t ) u ;\n oredChars |= u = * source ++ ;\n * target ++ = ( uint8_t ) u ;\n if ( oredChars > max ) {\n source -= 16 ;\n target -= 16 ;\n break ;\n }\n }\n while ( -- count > 0 ) ;\n count = loops - count ;\n targetCapacity -= 16 * count ;\n if ( offsets != NULL ) {\n oldTarget += 16 * count ;\n while ( count > 0 ) {\n * offsets ++ = sourceIndex ++ ;\n * offsets ++ = sourceIndex ++ ;\n * offsets ++ = sourceIndex ++ ;\n * offsets ++ = sourceIndex ++ ;\n * offsets ++ = sourceIndex ++ ;\n * offsets ++ = sourceIndex ++ ;\n * offsets ++ = sourceIndex ++ ;\n * offsets ++ = sourceIndex ++ ;\n * offsets ++ = sourceIndex ++ ;\n * offsets ++ = sourceIndex ++ ;\n * offsets ++ = sourceIndex ++ ;\n * offsets ++ = sourceIndex ++ ;\n * offsets ++ = sourceIndex ++ ;\n * offsets ++ = sourceIndex ++ ;\n * offsets ++ = sourceIndex ++ ;\n * offsets ++ = sourceIndex ++ ;\n -- count ;\n }\n }\n }\n # endif c = 0 ;\n while ( targetCapacity > 0 && ( c = * source ++ ) <= max ) {\n * target ++ = ( uint8_t ) c ;\n -- targetCapacity ;\n }\n if ( c > max ) {\n cp = c ;\n if ( ! U_IS_SURROGATE ( cp ) ) {\n }\n else if ( U_IS_SURROGATE_LEAD ( cp ) ) {\n getTrail : if ( source < sourceLimit ) {\n UChar trail = * source ;\n if ( U16_IS_TRAIL ( trail ) ) {\n ++ source ;\n cp = U16_GET_SUPPLEMENTARY ( cp , trail ) ;\n }\n else {\n }\n }\n else {\n cnv -> fromUChar32 = cp ;\n goto noMoreInput ;\n }\n }\n else {\n }\n * pErrorCode = U_IS_SURROGATE ( cp ) ? U_ILLEGAL_CHAR_FOUND : U_INVALID_CHAR_FOUND ;\n cnv -> fromUChar32 = cp ;\n }\n noMoreInput : if ( offsets != NULL ) {\n size_t count = target - oldTarget ;\n while ( count > 0 ) {\n * offsets ++ = sourceIndex ++ ;\n -- count ;\n }\n }\n if ( U_SUCCESS ( * pErrorCode ) && source < sourceLimit && target >= ( uint8_t * ) pArgs -> targetLimit ) {\n * pErrorCode = U_BUFFER_OVERFLOW_ERROR ;\n }\n pArgs -> source = source ;\n pArgs -> target = ( char * ) target ;\n pArgs -> offsets = offsets ;\n }", "idx": 1950}
{"hash": 6393050609822897742, "project": "debian", "size": 24, "label": 0, "functionSource": "static TRBCCode xhci_disable_ep ( XHCIState * xhci , unsigned int slotid , unsigned int epid ) {\n XHCISlot * slot ;\n XHCIEPContext * epctx ;\n trace_usb_xhci_ep_disable ( slotid , epid ) ;\n assert ( slotid >= 1 && slotid <= xhci -> numslots ) ;\n assert ( epid >= 1 && epid <= 31 ) ;\n slot = & xhci -> slots [ slotid - 1 ] ;\n if ( ! slot -> eps [ epid - 1 ] ) {\n DPRINTF ( \"xhci: slot %d ep %d already disabled\\n\" , slotid , epid ) ;\n return CC_SUCCESS ;\n }\n xhci_ep_nuke_xfers ( xhci , slotid , epid , 0 ) ;\n epctx = slot -> eps [ epid - 1 ] ;\n if ( epctx -> nr_pstreams ) {\n xhci_free_streams ( epctx ) ;\n }\n if ( xhci -> dcbaap_low || xhci -> dcbaap_high ) {\n xhci_set_ep_state ( xhci , epctx , NULL , EP_DISABLED ) ;\n }\n timer_free ( epctx -> kick_timer ) ;\n g_free ( epctx ) ;\n slot -> eps [ epid - 1 ] = NULL ;\n return CC_SUCCESS ;\n }", "idx": 1951}
{"hash": -8962831256613787672, "project": "debian", "size": 276, "label": 0, "functionSource": "void proto_register_usb_audio ( void ) {\n static hf_register_info hf [ ] = {\n {\n & hf_midi_cable_number , {\n \"Cable Number\" , \"usbaudio.midi.cable_number\" , FT_UINT8 , BASE_HEX , NULL , 0xF0 , NULL , HFILL }\n }\n , {\n & hf_midi_code_index , {\n \"Code Index\" , \"usbaudio.midi.code_index\" , FT_UINT8 , BASE_HEX , VALS ( code_index_vals ) , 0x0F , NULL , HFILL }\n }\n , {\n & hf_midi_event , {\n \"MIDI Event\" , \"usbaudio.midi.event\" , FT_UINT24 , BASE_HEX , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_ac_if_desc_subtype , {\n \"Subtype\" , \"usbaudio.ac_if_subtype\" , FT_UINT8 , BASE_HEX | BASE_EXT_STRING , & ac_subtype_vals_ext , 0x00 , \"bDescriptorSubtype\" , HFILL }\n }\n , {\n & hf_ac_if_hdr_ver , {\n \"Version\" , \"usbaudio.ac_if_hdr.bcdADC\" , FT_DOUBLE , BASE_NONE , NULL , 0 , \"bcdADC\" , HFILL }\n }\n , {\n & hf_ac_if_hdr_total_len , {\n \"Total length\" , \"usbaudio.ac_if_hdr.wTotalLength\" , FT_UINT16 , BASE_DEC , NULL , 0x00 , \"wTotalLength\" , HFILL }\n }\n , {\n & hf_ac_if_hdr_bInCollection , {\n \"Total number of interfaces\" , \"usbaudio.ac_if_hdr.bInCollection\" , FT_UINT8 , BASE_DEC , NULL , 0x00 , \"bInCollection\" , HFILL }\n }\n , {\n & hf_ac_if_hdr_if_num , {\n \"Interface number\" , \"usbaudio.ac_if_hdr.baInterfaceNr\" , FT_UINT8 , BASE_DEC , NULL , 0x00 , \"baInterfaceNr\" , HFILL }\n }\n , {\n & hf_ac_if_input_terminalid , {\n \"Terminal ID\" , \"usbaudio.ac_if_input.bTerminalID\" , FT_UINT8 , BASE_DEC , NULL , 0x00 , \"bTerminalID\" , HFILL }\n }\n , {\n & hf_ac_if_input_terminaltype , {\n \"Terminal Type\" , \"usbaudio.ac_if_input.wTerminalType\" , FT_UINT16 , BASE_HEX | BASE_EXT_STRING , & terminal_types_vals_ext , 0x00 , \"wTerminalType\" , HFILL }\n }\n , {\n & hf_ac_if_input_assocterminal , {\n \"Assoc Terminal\" , \"usbaudio.ac_if_input.bAssocTerminal\" , FT_UINT8 , BASE_DEC , NULL , 0x00 , \"bAssocTerminal\" , HFILL }\n }\n , {\n & hf_ac_if_input_nrchannels , {\n \"Number Channels\" , \"usbaudio.ac_if_input.bNrChannels\" , FT_UINT8 , BASE_DEC , NULL , 0x00 , \"bNrChannels\" , HFILL }\n }\n , {\n & hf_ac_if_input_channelconfig , {\n \"Channel Config\" , \"usbaudio.ac_if_input.wChannelConfig\" , FT_UINT16 , BASE_HEX , NULL , 0x00 , \"wChannelConfig\" , HFILL }\n }\n , {\n & hf_ac_if_input_channelnames , {\n \"Channel Names\" , \"usbaudio.ac_if_input.iChannelNames\" , FT_UINT8 , BASE_DEC , NULL , 0x00 , \"iChannelNames\" , HFILL }\n }\n , {\n & hf_ac_if_input_terminal , {\n \"Terminal\" , \"usbaudio.ac_if_input.iTerminal\" , FT_UINT8 , BASE_DEC , NULL , 0x00 , \"iTerminal\" , HFILL }\n }\n , {\n & hf_ac_if_output_terminalid , {\n \"Terminal ID\" , \"usbaudio.ac_if_output.bTerminalID\" , FT_UINT8 , BASE_DEC , NULL , 0x00 , \"bTerminalID\" , HFILL }\n }\n , {\n & hf_ac_if_output_terminaltype , {\n \"Terminal Type\" , \"usbaudio.ac_if_output.wTerminalType\" , FT_UINT16 , BASE_HEX | BASE_EXT_STRING , & terminal_types_vals_ext , 0x00 , \"wTerminalType\" , HFILL }\n }\n , {\n & hf_ac_if_output_assocterminal , {\n \"Assoc Terminal\" , \"usbaudio.ac_if_output.bAssocTerminal\" , FT_UINT8 , BASE_DEC , NULL , 0x00 , \"bAssocTerminal\" , HFILL }\n }\n , {\n & hf_ac_if_output_sourceid , {\n \"Source ID\" , \"usbaudio.ac_if_output.bSourceID\" , FT_UINT8 , BASE_DEC , NULL , 0x00 , \"bSourceID\" , HFILL }\n }\n , {\n & hf_ac_if_output_terminal , {\n \"Terminal\" , \"usbaudio.ac_if_output.iTerminal\" , FT_UINT8 , BASE_DEC , NULL , 0x00 , \"iTerminal\" , HFILL }\n }\n , {\n & hf_ac_if_fu_unitid , {\n \"Unit ID\" , \"usbaudio.ac_if_fu.bUnitID\" , FT_UINT8 , BASE_DEC , NULL , 0x00 , \"bUnitID\" , HFILL }\n }\n , {\n & hf_ac_if_fu_sourceid , {\n \"Source ID\" , \"usbaudio.ac_if_fu.bSourceID\" , FT_UINT8 , BASE_DEC , NULL , 0x00 , \"bSourceID\" , HFILL }\n }\n , {\n & hf_ac_if_fu_controlsize , {\n \"Control Size\" , \"usbaudio.ac_if_fu.bControlSize\" , FT_UINT8 , BASE_DEC , NULL , 0x00 , \"bControlSize\" , HFILL }\n }\n , {\n & hf_ac_if_fu_controls , {\n \"Controls\" , \"usbaudio.ac_if_fu.bmaControls\" , FT_BYTES , BASE_NONE , NULL , 0x00 , \"bmaControls\" , HFILL }\n }\n , {\n & hf_ac_if_fu_control , {\n \"Control\" , \"usbaudio.ac_if_fu.bmaControl\" , FT_UINT8 , BASE_HEX , NULL , 0x00 , \"bmaControls\" , HFILL }\n }\n , {\n & hf_ac_if_fu_controls_d0 , {\n \"Mute\" , \"usbaudio.ac_if_fu.bmaControls.d0\" , FT_BOOLEAN , 8 , NULL , 0x01 , NULL , HFILL }\n }\n , {\n & hf_ac_if_fu_controls_d1 , {\n \"Volume\" , \"usbaudio.ac_if_fu.bmaControls.d1\" , FT_BOOLEAN , 8 , NULL , 0x02 , NULL , HFILL }\n }\n , {\n & hf_ac_if_fu_controls_d2 , {\n \"Bass\" , \"usbaudio.ac_if_fu.bmaControls.d2\" , FT_BOOLEAN , 8 , NULL , 0x04 , NULL , HFILL }\n }\n , {\n & hf_ac_if_fu_controls_d3 , {\n \"Mid\" , \"usbaudio.ac_if_fu.bmaControls.d3\" , FT_BOOLEAN , 8 , NULL , 0x08 , NULL , HFILL }\n }\n , {\n & hf_ac_if_fu_controls_d4 , {\n \"Treble\" , \"usbaudio.ac_if_fu.bmaControls.d4\" , FT_BOOLEAN , 8 , NULL , 0x10 , NULL , HFILL }\n }\n , {\n & hf_ac_if_fu_controls_d5 , {\n \"Graphic Equalizer\" , \"usbaudio.ac_if_fu.bmaControls.d5\" , FT_BOOLEAN , 8 , NULL , 0x20 , NULL , HFILL }\n }\n , {\n & hf_ac_if_fu_controls_d6 , {\n \"Automatic Gain\" , \"usbaudio.ac_if_fu.bmaControls.d6\" , FT_BOOLEAN , 8 , NULL , 0x40 , NULL , HFILL }\n }\n , {\n & hf_ac_if_fu_controls_d7 , {\n \"Delay\" , \"usbaudio.ac_if_fu.bmaControls.d7\" , FT_BOOLEAN , 8 , NULL , 0x80 , NULL , HFILL }\n }\n , {\n & hf_ac_if_fu_controls_d8 , {\n \"Bass Boost\" , \"usbaudio.ac_if_fu.bmaControls.d8\" , FT_BOOLEAN , 8 , NULL , 0x01 , NULL , HFILL }\n }\n , {\n & hf_ac_if_fu_controls_d9 , {\n \"Loudness\" , \"usbaudio.ac_if_fu.bmaControls.d9\" , FT_BOOLEAN , 8 , NULL , 0x02 , NULL , HFILL }\n }\n , {\n & hf_ac_if_fu_controls_rsv , {\n \"Reserved\" , \"usbaudio.ac_if_fu.bmaControls.rsv\" , FT_UINT8 , BASE_HEX , NULL , 0xFC , \"Must be zero\" , HFILL }\n }\n , {\n & hf_ac_if_fu_ifeature , {\n \"Feature\" , \"usbaudio.ac_if_fu.iFeature\" , FT_UINT8 , BASE_DEC , NULL , 0x00 , \"iFeature\" , HFILL }\n }\n , {\n & hf_as_if_desc_subtype , {\n \"Subtype\" , \"usbaudio.as_if_subtype\" , FT_UINT8 , BASE_HEX | BASE_EXT_STRING , & as_subtype_vals_ext , 0x00 , \"bDescriptorSubtype\" , HFILL }\n }\n , {\n & hf_as_if_gen_term_id , {\n \"Terminal ID\" , \"usbaudio.as_if_gen.bTerminalLink\" , FT_UINT8 , BASE_DEC , NULL , 0x00 , \"bTerminalLink\" , HFILL }\n }\n , {\n & hf_as_if_gen_delay , {\n \"Interface delay in frames\" , \"usbaudio.as_if_gen.bDelay\" , FT_UINT8 , BASE_DEC , NULL , 0x00 , \"bDelay\" , HFILL }\n }\n , {\n & hf_as_if_gen_format , {\n \"Format\" , \"usbaudio.as_if_gen.wFormatTag\" , FT_UINT16 , BASE_HEX , NULL , 0x00 , \"wFormatTag\" , HFILL }\n }\n , {\n & hf_as_if_ft_formattype , {\n \"FormatType\" , \"usbaudio.as_if_ft.bFormatType\" , FT_UINT8 , BASE_DEC , NULL , 0x00 , \"wFormatType\" , HFILL }\n }\n , {\n & hf_as_if_ft_maxbitrate , {\n \"Max Bit Rate\" , \"usbaudio.as_if_ft.wMaxBitRate\" , FT_UINT16 , BASE_DEC , NULL , 0x00 , \"wMaxBitRate\" , HFILL }\n }\n , {\n & hf_as_if_ft_nrchannels , {\n \"Number Channels\" , \"usbaudio.as_if_ft.bNrChannels\" , FT_UINT8 , BASE_DEC , NULL , 0x00 , \"bNrChannels\" , HFILL }\n }\n , {\n & hf_as_if_ft_subframesize , {\n \"Subframe Size\" , \"usbaudio.as_if_ft.bSubframeSize\" , FT_UINT8 , BASE_DEC , NULL , 0x00 , \"bSubframeSize\" , HFILL }\n }\n , {\n & hf_as_if_ft_bitresolution , {\n \"Bit Resolution\" , \"usbaudio.as_if_ft.bBitResolution\" , FT_UINT8 , BASE_DEC , NULL , 0x00 , \"bBitResolution\" , HFILL }\n }\n , {\n & hf_as_if_ft_samplesperframe , {\n \"Samples Per Frame\" , \"usbaudio.as_if_ft.wSamplesPerFrame\" , FT_UINT16 , BASE_DEC , NULL , 0x00 , \"wSamplesPerFrame\" , HFILL }\n }\n , {\n & hf_as_if_ft_samfreqtype , {\n \"Samples Frequence Type\" , \"usbaudio.as_if_ft.bSamFreqType\" , FT_UINT8 , BASE_DEC , NULL , 0x00 , \"bSamFreqType\" , HFILL }\n }\n , {\n & hf_as_if_ft_lowersamfreq , {\n \"Lower Samples Frequence\" , \"usbaudio.as_if_ft.tLowerSamFreq\" , FT_UINT24 , BASE_DEC , NULL , 0x00 , \"tLowerSamFreq\" , HFILL }\n }\n , {\n & hf_as_if_ft_uppersamfreq , {\n \"Upper Samples Frequence\" , \"usbaudio.as_if_ft.tUpperSamFreq\" , FT_UINT24 , BASE_DEC , NULL , 0x00 , \"tUpperSamFreq\" , HFILL }\n }\n , {\n & hf_as_if_ft_samfreq , {\n \"Samples Frequence\" , \"usbaudio.as_if_ft.tSamFreq\" , FT_UINT24 , BASE_DEC , NULL , 0x00 , \"tSamFreq\" , HFILL }\n }\n , {\n & hf_as_ep_desc_subtype , {\n \"Subtype\" , \"usbaudio.as_ep_subtype\" , FT_UINT8 , BASE_HEX , NULL , 0x00 , \"bDescriptorSubtype\" , HFILL }\n }\n , {\n & hf_sysex_msg_fragments , {\n \"Message fragments\" , \"usbaudio.sysex.fragments\" , FT_NONE , BASE_NONE , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_sysex_msg_fragment , {\n \"Message fragment\" , \"usbaudio.sysex.fragment\" , FT_FRAMENUM , BASE_NONE , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_sysex_msg_fragment_overlap , {\n \"Message fragment overlap\" , \"usbaudio.sysex.fragment.overlap\" , FT_BOOLEAN , 0 , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_sysex_msg_fragment_overlap_conflicts , {\n \"Message fragment overlapping with conflicting data\" , \"usbaudio.sysex.fragment.overlap.conflicts\" , FT_BOOLEAN , 0 , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_sysex_msg_fragment_multiple_tails , {\n \"Message has multiple tail fragments\" , \"usbaudio.sysex.fragment.multiple_tails\" , FT_BOOLEAN , 0 , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_sysex_msg_fragment_too_long_fragment , {\n \"Message fragment too long\" , \"usbaudio.sysex.fragment.too_long_fragment\" , FT_BOOLEAN , 0 , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_sysex_msg_fragment_error , {\n \"Message defragmentation error\" , \"usbaudio.sysex.fragment.error\" , FT_FRAMENUM , BASE_NONE , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_sysex_msg_fragment_count , {\n \"Message fragment count\" , \"usbaudio.sysex.fragment.count\" , FT_UINT32 , BASE_DEC , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_sysex_msg_reassembled_in , {\n \"Reassembled in\" , \"usbaudio.sysex.reassembled.in\" , FT_FRAMENUM , BASE_NONE , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_sysex_msg_reassembled_length , {\n \"Reassembled length\" , \"usbaudio.sysex.reassembled.length\" , FT_UINT32 , BASE_DEC , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_sysex_msg_reassembled_data , {\n \"Reassembled data\" , \"usbaudio.sysex.reassembled.data\" , FT_BYTES , BASE_NONE , NULL , 0x00 , NULL , HFILL }\n }\n }\n ;\n static gint * usb_audio_subtrees [ ] = {\n & ett_usb_audio , & ett_usb_audio_desc , & ett_sysex_msg_fragment , & ett_sysex_msg_fragments , & ett_ac_if_fu_controls , & ett_ac_if_fu_controls0 , & ett_ac_if_fu_controls1 }\n ;\n static ei_register_info ei [ ] = {\n {\n & ei_usb_audio_undecoded , {\n \"usbaudio.undecoded\" , PI_UNDECODED , PI_WARN , \"Not dissected yet (report to wireshark.org)\" , EXPFILL }\n }\n , }\n ;\n expert_module_t * expert_usb_audio ;\n proto_usb_audio = proto_register_protocol ( \"USB Audio\" , \"USBAUDIO\" , \"usbaudio\" ) ;\n proto_register_field_array ( proto_usb_audio , hf , array_length ( hf ) ) ;\n proto_register_subtree_array ( usb_audio_subtrees , array_length ( usb_audio_subtrees ) ) ;\n expert_usb_audio = expert_register_protocol ( proto_usb_audio ) ;\n expert_register_field_array ( expert_usb_audio , ei , array_length ( ei ) ) ;\n register_init_routine ( & midi_data_reassemble_init ) ;\n register_cleanup_routine ( & midi_data_reassemble_cleanup ) ;\n register_dissector ( \"usbaudio\" , dissect_usb_audio_bulk , proto_usb_audio ) ;\n }", "idx": 1952}
{"hash": -3299391226809811274, "project": "debian", "size": 17, "label": 0, "functionSource": "static const char * qemuAgentStringifyErrorClass ( const char * klass ) {\n if ( STREQ_NULLABLE ( klass , \"BufferOverrun\" ) ) return \"Buffer overrun\" ;\n else if ( STREQ_NULLABLE ( klass , \"CommandDisabled\" ) ) return \"The command has been disabled for this instance\" ;\n else if ( STREQ_NULLABLE ( klass , \"CommandNotFound\" ) ) return \"The command has not been found\" ;\n else if ( STREQ_NULLABLE ( klass , \"FdNotFound\" ) ) return \"File descriptor not found\" ;\n else if ( STREQ_NULLABLE ( klass , \"InvalidParameter\" ) ) return \"Invalid parameter\" ;\n else if ( STREQ_NULLABLE ( klass , \"InvalidParameterType\" ) ) return \"Invalid parameter type\" ;\n else if ( STREQ_NULLABLE ( klass , \"InvalidParameterValue\" ) ) return \"Invalid parameter value\" ;\n else if ( STREQ_NULLABLE ( klass , \"OpenFileFailed\" ) ) return \"Cannot open file\" ;\n else if ( STREQ_NULLABLE ( klass , \"QgaCommandFailed\" ) ) return \"Guest agent command failed\" ;\n else if ( STREQ_NULLABLE ( klass , \"QMPBadInputObjectMember\" ) ) return \"Bad QMP input object member\" ;\n else if ( STREQ_NULLABLE ( klass , \"QMPExtraInputObjectMember\" ) ) return \"Unexpected extra object member\" ;\n else if ( STREQ_NULLABLE ( klass , \"UndefinedError\" ) ) return \"An undefined error has occurred\" ;\n else if ( STREQ_NULLABLE ( klass , \"Unsupported\" ) ) return \"this feature or command is not currently supported\" ;\n else if ( klass ) return klass ;\n else return \"unknown QEMU command error\" ;\n }", "idx": 1953}
{"hash": 5918484636148310736, "project": "debian", "size": 25, "label": 0, "functionSource": "int mem_get_bits_rectangle ( gx_device * dev , const gs_int_rect * prect , gs_get_bits_params_t * params , gs_int_rect * * unread ) {\n gx_device_memory * const mdev = ( gx_device_memory * ) dev ;\n gs_get_bits_options_t options = params -> options ;\n int x = prect -> p . x , w = prect -> q . x - x , y = prect -> p . y , h = prect -> q . y - y ;\n if ( options == 0 ) {\n params -> options = ( GB_ALIGN_STANDARD | GB_ALIGN_ANY ) | ( GB_RETURN_COPY | GB_RETURN_POINTER ) | ( GB_OFFSET_0 | GB_OFFSET_SPECIFIED | GB_OFFSET_ANY ) | ( GB_RASTER_STANDARD | GB_RASTER_SPECIFIED | GB_RASTER_ANY ) | GB_PACKING_CHUNKY | GB_COLORS_NATIVE | GB_ALPHA_NONE ;\n return_error ( gs_error_rangecheck ) ;\n }\n if ( mdev -> line_ptrs == 0x00 ) return_error ( gs_error_rangecheck ) ;\n if ( ( w <= 0 ) | ( h <= 0 ) ) {\n if ( ( w | h ) < 0 ) return_error ( gs_error_rangecheck ) ;\n return 0 ;\n }\n if ( x < 0 || w > dev -> width - x || y < 0 || h > dev -> height - y ) return_error ( gs_error_rangecheck ) ;\n {\n gs_get_bits_params_t copy_params ;\n byte * * base = & scan_line_base ( mdev , y ) ;\n int code ;\n copy_params . options = GB_COLORS_NATIVE | GB_PACKING_CHUNKY | GB_ALPHA_NONE | ( mdev -> raster == bitmap_raster ( mdev -> width * mdev -> color_info . depth ) ? GB_RASTER_STANDARD : GB_RASTER_SPECIFIED ) ;\n copy_params . raster = mdev -> raster ;\n code = gx_get_bits_return_pointer ( dev , x , h , params , & copy_params , base ) ;\n if ( code >= 0 ) return code ;\n return gx_get_bits_copy ( dev , x , w , h , params , & copy_params , * base , gx_device_raster ( dev , true ) ) ;\n }\n }", "idx": 1954}
{"hash": 2776415072272421122, "project": "debian", "size": 15, "label": 0, "functionSource": "static void draw_char ( AVCodecContext * avctx , int c ) {\n AnsiContext * s = avctx -> priv_data ;\n int fg = s -> fg ;\n int bg = s -> bg ;\n if ( ( s -> attributes & ATTR_BOLD ) ) fg += 8 ;\n if ( ( s -> attributes & ATTR_BLINK ) ) bg += 8 ;\n if ( ( s -> attributes & ATTR_REVERSE ) ) FFSWAP ( int , fg , bg ) ;\n if ( ( s -> attributes & ATTR_CONCEALED ) ) fg = bg ;\n ff_draw_pc_font ( s -> frame -> data [ 0 ] + s -> y * s -> frame -> linesize [ 0 ] + s -> x , s -> frame -> linesize [ 0 ] , s -> font , s -> font_height , c , fg , bg ) ;\n s -> x += FONT_WIDTH ;\n if ( s -> x >= avctx -> width ) {\n s -> x = 0 ;\n hscroll ( avctx ) ;\n }\n }", "idx": 1955}
{"hash": -6068399010699045437, "project": "debian", "size": 65, "label": 0, "functionSource": "static int dca_parse_frame_header ( DCAContext * s ) {\n init_get_bits ( & s -> gb , s -> dca_buffer , s -> dca_buffer_size * 8 ) ;\n skip_bits_long ( & s -> gb , 32 ) ;\n s -> frame_type = get_bits ( & s -> gb , 1 ) ;\n s -> samples_deficit = get_bits ( & s -> gb , 5 ) + 1 ;\n s -> crc_present = get_bits ( & s -> gb , 1 ) ;\n s -> sample_blocks = get_bits ( & s -> gb , 7 ) + 1 ;\n s -> frame_size = get_bits ( & s -> gb , 14 ) + 1 ;\n if ( s -> frame_size < 95 ) return AVERROR_INVALIDDATA ;\n s -> amode = get_bits ( & s -> gb , 6 ) ;\n s -> sample_rate = avpriv_dca_sample_rates [ get_bits ( & s -> gb , 4 ) ] ;\n if ( ! s -> sample_rate ) return AVERROR_INVALIDDATA ;\n s -> bit_rate_index = get_bits ( & s -> gb , 5 ) ;\n s -> bit_rate = dca_bit_rates [ s -> bit_rate_index ] ;\n if ( ! s -> bit_rate ) return AVERROR_INVALIDDATA ;\n s -> downmix = get_bits ( & s -> gb , 1 ) ;\n s -> dynrange = get_bits ( & s -> gb , 1 ) ;\n s -> timestamp = get_bits ( & s -> gb , 1 ) ;\n s -> aux_data = get_bits ( & s -> gb , 1 ) ;\n s -> hdcd = get_bits ( & s -> gb , 1 ) ;\n s -> ext_descr = get_bits ( & s -> gb , 3 ) ;\n s -> ext_coding = get_bits ( & s -> gb , 1 ) ;\n s -> aspf = get_bits ( & s -> gb , 1 ) ;\n s -> lfe = get_bits ( & s -> gb , 2 ) ;\n s -> predictor_history = get_bits ( & s -> gb , 1 ) ;\n if ( s -> crc_present ) s -> header_crc = get_bits ( & s -> gb , 16 ) ;\n s -> multirate_inter = get_bits ( & s -> gb , 1 ) ;\n s -> version = get_bits ( & s -> gb , 4 ) ;\n s -> copy_history = get_bits ( & s -> gb , 2 ) ;\n s -> source_pcm_res = get_bits ( & s -> gb , 3 ) ;\n s -> front_sum = get_bits ( & s -> gb , 1 ) ;\n s -> surround_sum = get_bits ( & s -> gb , 1 ) ;\n s -> dialog_norm = get_bits ( & s -> gb , 4 ) ;\n s -> output = s -> amode ;\n if ( s -> lfe ) s -> output |= DCA_LFE ;\n # ifdef TRACE av_log ( s -> avctx , AV_LOG_DEBUG , \"frame type: %i\\n\" , s -> frame_type ) ;\n av_log ( s -> avctx , AV_LOG_DEBUG , \"samples deficit: %i\\n\" , s -> samples_deficit ) ;\n av_log ( s -> avctx , AV_LOG_DEBUG , \"crc present: %i\\n\" , s -> crc_present ) ;\n av_log ( s -> avctx , AV_LOG_DEBUG , \"sample blocks: %i (%i samples)\\n\" , s -> sample_blocks , s -> sample_blocks * 32 ) ;\n av_log ( s -> avctx , AV_LOG_DEBUG , \"frame size: %i bytes\\n\" , s -> frame_size ) ;\n av_log ( s -> avctx , AV_LOG_DEBUG , \"amode: %i (%i channels)\\n\" , s -> amode , dca_channels [ s -> amode ] ) ;\n av_log ( s -> avctx , AV_LOG_DEBUG , \"sample rate: %i Hz\\n\" , s -> sample_rate ) ;\n av_log ( s -> avctx , AV_LOG_DEBUG , \"bit rate: %i bits/s\\n\" , s -> bit_rate ) ;\n av_log ( s -> avctx , AV_LOG_DEBUG , \"downmix: %i\\n\" , s -> downmix ) ;\n av_log ( s -> avctx , AV_LOG_DEBUG , \"dynrange: %i\\n\" , s -> dynrange ) ;\n av_log ( s -> avctx , AV_LOG_DEBUG , \"timestamp: %i\\n\" , s -> timestamp ) ;\n av_log ( s -> avctx , AV_LOG_DEBUG , \"aux_data: %i\\n\" , s -> aux_data ) ;\n av_log ( s -> avctx , AV_LOG_DEBUG , \"hdcd: %i\\n\" , s -> hdcd ) ;\n av_log ( s -> avctx , AV_LOG_DEBUG , \"ext descr: %i\\n\" , s -> ext_descr ) ;\n av_log ( s -> avctx , AV_LOG_DEBUG , \"ext coding: %i\\n\" , s -> ext_coding ) ;\n av_log ( s -> avctx , AV_LOG_DEBUG , \"aspf: %i\\n\" , s -> aspf ) ;\n av_log ( s -> avctx , AV_LOG_DEBUG , \"lfe: %i\\n\" , s -> lfe ) ;\n av_log ( s -> avctx , AV_LOG_DEBUG , \"predictor history: %i\\n\" , s -> predictor_history ) ;\n av_log ( s -> avctx , AV_LOG_DEBUG , \"header crc: %i\\n\" , s -> header_crc ) ;\n av_log ( s -> avctx , AV_LOG_DEBUG , \"multirate inter: %i\\n\" , s -> multirate_inter ) ;\n av_log ( s -> avctx , AV_LOG_DEBUG , \"version number: %i\\n\" , s -> version ) ;\n av_log ( s -> avctx , AV_LOG_DEBUG , \"copy history: %i\\n\" , s -> copy_history ) ;\n av_log ( s -> avctx , AV_LOG_DEBUG , \"source pcm resolution: %i (%i bits/sample)\\n\" , s -> source_pcm_res , dca_bits_per_sample [ s -> source_pcm_res ] ) ;\n av_log ( s -> avctx , AV_LOG_DEBUG , \"front sum: %i\\n\" , s -> front_sum ) ;\n av_log ( s -> avctx , AV_LOG_DEBUG , \"surround sum: %i\\n\" , s -> surround_sum ) ;\n av_log ( s -> avctx , AV_LOG_DEBUG , \"dialog norm: %i\\n\" , s -> dialog_norm ) ;\n av_log ( s -> avctx , AV_LOG_DEBUG , \"\\n\" ) ;\n # endif s -> subframes = get_bits ( & s -> gb , 4 ) + 1 ;\n return dca_parse_audio_coding_header ( s , 0 ) ;\n }", "idx": 1956}
{"hash": -305162769887579921, "project": "debian", "size": 14, "label": 0, "functionSource": "static void update_mb_info ( MpegEncContext * s , int startcode ) {\n if ( ! s -> mb_info ) return ;\n if ( put_bits_count ( & s -> pb ) - s -> prev_mb_info * 8 >= s -> mb_info * 8 ) {\n s -> mb_info_size += 12 ;\n s -> prev_mb_info = s -> last_mb_info ;\n }\n if ( startcode ) {\n s -> prev_mb_info = put_bits_count ( & s -> pb ) / 8 ;\n return ;\n }\n s -> last_mb_info = put_bits_count ( & s -> pb ) / 8 ;\n if ( ! s -> mb_info_size ) s -> mb_info_size += 12 ;\n write_mb_info ( s ) ;\n }", "idx": 1957}
{"hash": -5861712607647761763, "project": "debian", "size": 5, "label": 0, "functionSource": "static void _zip_write2 ( unsigned short i , FILE * fp ) {\n putc ( i & 0xff , fp ) ;\n putc ( ( i >> 8 ) & 0xff , fp ) ;\n return ;\n }", "idx": 1958}
{"hash": -5280794106681745199, "project": "debian", "size": 21, "label": 0, "functionSource": "static gboolean gst_asf_demux_get_string ( gchar * * p_str , guint16 * p_strlen , guint8 * * p_data , guint64 * p_size ) {\n guint16 s_length ;\n guint8 * s ;\n * p_str = NULL ;\n if ( * p_size < 2 ) return FALSE ;\n s_length = gst_asf_demux_get_uint16 ( p_data , p_size ) ;\n if ( p_strlen ) * p_strlen = s_length ;\n if ( s_length == 0 ) {\n GST_WARNING ( \"zero-length string\" ) ;\n * p_str = g_strdup ( \"\" ) ;\n return TRUE ;\n }\n if ( ! gst_asf_demux_get_bytes ( & s , s_length , p_data , p_size ) ) return FALSE ;\n g_assert ( s != NULL ) ;\n if ( s [ s_length - 1 ] != '\\0' ) {\n s = g_realloc ( s , s_length + 1 ) ;\n s [ s_length ] = '\\0' ;\n }\n * p_str = ( gchar * ) s ;\n return TRUE ;\n }", "idx": 1959}
{"hash": -8620097311326519087, "project": "chrome", "size": 15, "label": 0, "functionSource": "unsigned int srtp_profile_get_master_key_length ( srtp_profile_t profile ) {\n switch ( profile ) {\n case srtp_profile_aes128_cm_sha1_80 : return 16 ;\n break ;\n case srtp_profile_aes128_cm_sha1_32 : return 16 ;\n break ;\n case srtp_profile_null_sha1_80 : return 16 ;\n break ;\n case srtp_profile_aes256_cm_sha1_80 : return 32 ;\n break ;\n case srtp_profile_aes256_cm_sha1_32 : return 32 ;\n break ;\n case srtp_profile_null_sha1_32 : default : return 0 ;\n }\n }", "idx": 1960}
{"hash": 6302861533225984845, "project": "debian", "size": 3, "label": 0, "functionSource": "static int pxa2xx_i2c_slave_init ( I2CSlave * i2c ) {\n return 0 ;\n }", "idx": 1961}
{"hash": 6458694302493204858, "project": "debian", "size": 12, "label": 0, "functionSource": "static Datum ExecEvalFunc ( FuncExprState * fcache , ExprContext * econtext , bool * isNull , ExprDoneCond * isDone ) {\n FuncExpr * func = ( FuncExpr * ) fcache -> xprstate . expr ;\n init_fcache ( func -> funcid , func -> inputcollid , fcache , econtext -> ecxt_per_query_memory , true ) ;\n if ( fcache -> func . fn_retset || expression_returns_set ( ( Node * ) func -> args ) ) {\n fcache -> xprstate . evalfunc = ( ExprStateEvalFunc ) ExecMakeFunctionResult ;\n return ExecMakeFunctionResult ( fcache , econtext , isNull , isDone ) ;\n }\n else {\n fcache -> xprstate . evalfunc = ( ExprStateEvalFunc ) ExecMakeFunctionResultNoSets ;\n return ExecMakeFunctionResultNoSets ( fcache , econtext , isNull , isDone ) ;\n }\n }", "idx": 1962}
{"hash": -5018047422955641881, "project": "debian", "size": 91, "label": 1, "functionSource": "static void s390_init ( ram_addr_t ram_size , const char * boot_device , const char * kernel_filename , const char * kernel_cmdline , const char * initrd_filename , const char * cpu_model ) {\n CPUState * env = NULL ;\n ram_addr_t ram_addr ;\n ram_addr_t kernel_size = 0 ;\n ram_addr_t initrd_offset ;\n ram_addr_t initrd_size = 0 ;\n int i ;\n if ( ! kvm_enabled ( ) ) {\n fprintf ( stderr , \"The S390 target only works with KVM enabled\\n\" ) ;\n exit ( 1 ) ;\n }\n s390_bus = s390_virtio_bus_init ( & ram_size ) ;\n ram_addr = qemu_ram_alloc ( ram_size ) ;\n cpu_register_physical_memory ( 0 , ram_size , ram_addr ) ;\n if ( cpu_model == NULL ) {\n cpu_model = \"host\" ;\n }\n ipi_states = qemu_malloc ( sizeof ( CPUState * ) * smp_cpus ) ;\n for ( i = 0 ;\n i < smp_cpus ;\n i ++ ) {\n CPUState * tmp_env ;\n tmp_env = cpu_init ( cpu_model ) ;\n if ( ! env ) {\n env = tmp_env ;\n }\n ipi_states [ i ] = tmp_env ;\n tmp_env -> halted = 1 ;\n tmp_env -> exception_index = EXCP_HLT ;\n }\n env -> halted = 0 ;\n env -> exception_index = 0 ;\n if ( kernel_filename ) {\n kernel_size = load_image ( kernel_filename , qemu_get_ram_ptr ( 0 ) ) ;\n if ( lduw_phys ( KERN_IMAGE_START ) != 0x0dd0 ) {\n fprintf ( stderr , \"Specified image is not an s390 boot image\\n\" ) ;\n exit ( 1 ) ;\n }\n cpu_synchronize_state ( env ) ;\n env -> psw . addr = KERN_IMAGE_START ;\n env -> psw . mask = 0x0000000180000000ULL ;\n }\n if ( initrd_filename ) {\n initrd_offset = INITRD_START ;\n while ( kernel_size + 0x100000 > initrd_offset ) {\n initrd_offset += 0x100000 ;\n }\n initrd_size = load_image ( initrd_filename , qemu_get_ram_ptr ( initrd_offset ) ) ;\n stq_phys ( INITRD_PARM_START , initrd_offset ) ;\n stq_phys ( INITRD_PARM_SIZE , initrd_size ) ;\n }\n if ( kernel_cmdline ) {\n cpu_physical_memory_rw ( KERN_PARM_AREA , ( uint8_t * ) kernel_cmdline , strlen ( kernel_cmdline ) , 1 ) ;\n }\n for ( i = 0 ;\n i < MAX_VIRTIO_CONSOLES ;\n i ++ ) {\n if ( virtcon_hds [ i ] ) {\n qdev_init_nofail ( qdev_create ( ( BusState * ) s390_bus , \"virtio-console-s390\" ) ) ;\n }\n }\n for ( i = 0 ;\n i < nb_nics ;\n i ++ ) {\n NICInfo * nd = & nd_table [ i ] ;\n DeviceState * dev ;\n if ( ! nd -> model ) {\n nd -> model = qemu_strdup ( \"virtio\" ) ;\n }\n if ( strcmp ( nd -> model , \"virtio\" ) ) {\n fprintf ( stderr , \"S390 only supports VirtIO nics\\n\" ) ;\n exit ( 1 ) ;\n }\n dev = qdev_create ( ( BusState * ) s390_bus , \"virtio-net-s390\" ) ;\n qdev_set_nic_properties ( dev , nd ) ;\n qdev_init_nofail ( dev ) ;\n }\n for ( i = 0 ;\n i < MAX_BLK_DEVS ;\n i ++ ) {\n DriveInfo * dinfo ;\n DeviceState * dev ;\n dinfo = drive_get ( IF_IDE , 0 , i ) ;\n if ( ! dinfo ) {\n continue ;\n }\n dev = qdev_create ( ( BusState * ) s390_bus , \"virtio-blk-s390\" ) ;\n qdev_prop_set_drive ( dev , \"drive\" , dinfo ) ;\n qdev_init_nofail ( dev ) ;\n }\n }", "idx": 1963}
{"hash": -3889154245145551951, "project": "debian", "size": 8, "label": 0, "functionSource": "static void parse_mark ( void ) {\n const char * v ;\n if ( skip_prefix ( command_buf . buf , \"mark :\" , & v ) ) {\n next_mark = strtoumax ( v , NULL , 10 ) ;\n read_next_command ( ) ;\n }\n else next_mark = 0 ;\n }", "idx": 1964}
{"hash": -954364585377557207, "project": "debian", "size": 19, "label": 0, "functionSource": "static void lsf2lsp_for_mode12k2 ( AMRContext * p , double lsp [ LP_FILTER_ORDER ] , const float lsf_no_r [ LP_FILTER_ORDER ] , const int16_t * lsf_quantizer [ 5 ] , const int quantizer_offset , const int sign , const int update ) {\n int16_t lsf_r [ LP_FILTER_ORDER ] ;\n float lsf_q [ LP_FILTER_ORDER ] ;\n int i ;\n for ( i = 0 ;\n i < LP_FILTER_ORDER >> 1 ;\n i ++ ) memcpy ( & lsf_r [ i << 1 ] , & lsf_quantizer [ i ] [ quantizer_offset ] , 2 * sizeof ( * lsf_r ) ) ;\n if ( sign ) {\n lsf_r [ 4 ] *= - 1 ;\n lsf_r [ 5 ] *= - 1 ;\n }\n if ( update ) memcpy ( p -> prev_lsf_r , lsf_r , LP_FILTER_ORDER * sizeof ( * lsf_r ) ) ;\n for ( i = 0 ;\n i < LP_FILTER_ORDER ;\n i ++ ) lsf_q [ i ] = lsf_r [ i ] * ( LSF_R_FAC / 8000.0 ) + lsf_no_r [ i ] * ( 1.0 / 8000.0 ) ;\n ff_set_min_dist_lsf ( lsf_q , MIN_LSF_SPACING , LP_FILTER_ORDER ) ;\n if ( update ) interpolate_lsf ( p -> lsf_q , lsf_q ) ;\n ff_acelp_lsf2lspd ( lsp , lsf_q , LP_FILTER_ORDER ) ;\n }", "idx": 1965}
{"hash": 1223258652239369123, "project": "debian", "size": 11, "label": 1, "functionSource": "SPL_METHOD ( DirectoryIterator , getBasename ) {\n spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n char * suffix = 0 , * fname ;\n int slen = 0 ;\n size_t flen ;\n if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , \"|s\" , & suffix , & slen ) == FAILURE ) {\n return ;\n }\n php_basename ( intern -> u . dir . entry . d_name , strlen ( intern -> u . dir . entry . d_name ) , suffix , slen , & fname , & flen TSRMLS_CC ) ;\n RETURN_STRINGL ( fname , flen , 0 ) ;\n }", "idx": 1966}
{"hash": 7651945086108393719, "project": "debian", "size": 3, "label": 0, "functionSource": "int qemuMonitorJSONSavePhysicalMemory ( qemuMonitorPtr mon , unsigned long long offset , size_t length , const char * path ) {\n return qemuMonitorJSONSaveMemory ( mon , \"pmemsave\" , offset , length , path ) ;\n }", "idx": 1967}
{"hash": 6250095321513210169, "project": "debian", "size": 285, "label": 0, "functionSource": "rfbBool rfbSendFramebufferUpdate ( rfbClientPtr cl , sraRegionPtr givenUpdateRegion ) {\n sraRectangleIterator * i = NULL ;\n sraRect rect ;\n int nUpdateRegionRects ;\n rfbFramebufferUpdateMsg * fu = ( rfbFramebufferUpdateMsg * ) cl -> updateBuf ;\n sraRegionPtr updateRegion , updateCopyRegion , tmpRegion ;\n int dx , dy ;\n rfbBool sendCursorShape = FALSE ;\n rfbBool sendCursorPos = FALSE ;\n rfbBool sendKeyboardLedState = FALSE ;\n rfbBool sendSupportedMessages = FALSE ;\n rfbBool sendSupportedEncodings = FALSE ;\n rfbBool sendServerIdentity = FALSE ;\n rfbBool result = TRUE ;\n if ( cl -> screen -> displayHook ) cl -> screen -> displayHook ( cl ) ;\n if ( cl -> useNewFBSize && cl -> newFBSizePending ) {\n LOCK ( cl -> updateMutex ) ;\n cl -> newFBSizePending = FALSE ;\n UNLOCK ( cl -> updateMutex ) ;\n fu -> type = rfbFramebufferUpdate ;\n fu -> nRects = Swap16IfLE ( 1 ) ;\n cl -> ublen = sz_rfbFramebufferUpdateMsg ;\n if ( ! rfbSendNewFBSize ( cl , cl -> scaledScreen -> width , cl -> scaledScreen -> height ) ) {\n if ( cl -> screen -> displayFinishedHook ) cl -> screen -> displayFinishedHook ( cl , FALSE ) ;\n return FALSE ;\n }\n result = rfbSendUpdateBuf ( cl ) ;\n if ( cl -> screen -> displayFinishedHook ) cl -> screen -> displayFinishedHook ( cl , result ) ;\n return result ;\n }\n if ( cl -> enableCursorShapeUpdates ) {\n if ( cl -> cursorWasChanged && cl -> readyForSetColourMapEntries ) sendCursorShape = TRUE ;\n }\n if ( cl -> enableCursorPosUpdates && cl -> cursorWasMoved ) sendCursorPos = TRUE ;\n if ( ( cl -> enableKeyboardLedState ) && ( cl -> screen -> getKeyboardLedStateHook != NULL ) ) {\n int x ;\n x = cl -> screen -> getKeyboardLedStateHook ( cl -> screen ) ;\n if ( x != cl -> lastKeyboardLedState ) {\n sendKeyboardLedState = TRUE ;\n cl -> lastKeyboardLedState = x ;\n }\n }\n if ( cl -> enableSupportedMessages ) {\n sendSupportedMessages = TRUE ;\n cl -> enableSupportedMessages = FALSE ;\n }\n if ( cl -> enableSupportedEncodings ) {\n sendSupportedEncodings = TRUE ;\n cl -> enableSupportedEncodings = FALSE ;\n }\n if ( cl -> enableServerIdentity ) {\n sendServerIdentity = TRUE ;\n cl -> enableServerIdentity = FALSE ;\n }\n LOCK ( cl -> updateMutex ) ;\n sraRgnSubtract ( cl -> copyRegion , cl -> modifiedRegion ) ;\n updateRegion = sraRgnCreateRgn ( givenUpdateRegion ) ;\n if ( cl -> screen -> progressiveSliceHeight > 0 ) {\n int height = cl -> screen -> progressiveSliceHeight , y = cl -> progressiveSliceY ;\n sraRegionPtr bbox = sraRgnBBox ( updateRegion ) ;\n sraRect rect ;\n if ( sraRgnPopRect ( bbox , & rect , 0 ) ) {\n sraRegionPtr slice ;\n if ( y < rect . y1 || y >= rect . y2 ) y = rect . y1 ;\n slice = sraRgnCreateRect ( 0 , y , cl -> screen -> width , y + height ) ;\n sraRgnAnd ( updateRegion , slice ) ;\n sraRgnDestroy ( slice ) ;\n }\n sraRgnDestroy ( bbox ) ;\n y += height ;\n if ( y >= cl -> screen -> height ) y = 0 ;\n cl -> progressiveSliceY = y ;\n }\n sraRgnOr ( updateRegion , cl -> copyRegion ) ;\n if ( ! sraRgnAnd ( updateRegion , cl -> requestedRegion ) && sraRgnEmpty ( updateRegion ) && ( cl -> enableCursorShapeUpdates || ( cl -> cursorX == cl -> screen -> cursorX && cl -> cursorY == cl -> screen -> cursorY ) ) && ! sendCursorShape && ! sendCursorPos && ! sendKeyboardLedState && ! sendSupportedMessages && ! sendSupportedEncodings && ! sendServerIdentity ) {\n sraRgnDestroy ( updateRegion ) ;\n UNLOCK ( cl -> updateMutex ) ;\n if ( cl -> screen -> displayFinishedHook ) cl -> screen -> displayFinishedHook ( cl , TRUE ) ;\n return TRUE ;\n }\n updateCopyRegion = sraRgnCreateRgn ( cl -> copyRegion ) ;\n sraRgnAnd ( updateCopyRegion , cl -> requestedRegion ) ;\n tmpRegion = sraRgnCreateRgn ( cl -> requestedRegion ) ;\n sraRgnOffset ( tmpRegion , cl -> copyDX , cl -> copyDY ) ;\n sraRgnAnd ( updateCopyRegion , tmpRegion ) ;\n sraRgnDestroy ( tmpRegion ) ;\n dx = cl -> copyDX ;\n dy = cl -> copyDY ;\n sraRgnSubtract ( updateRegion , updateCopyRegion ) ;\n sraRgnOr ( cl -> modifiedRegion , cl -> copyRegion ) ;\n sraRgnSubtract ( cl -> modifiedRegion , updateRegion ) ;\n sraRgnSubtract ( cl -> modifiedRegion , updateCopyRegion ) ;\n sraRgnMakeEmpty ( cl -> requestedRegion ) ;\n sraRgnMakeEmpty ( cl -> copyRegion ) ;\n cl -> copyDX = 0 ;\n cl -> copyDY = 0 ;\n UNLOCK ( cl -> updateMutex ) ;\n if ( ! cl -> enableCursorShapeUpdates ) {\n if ( cl -> cursorX != cl -> screen -> cursorX || cl -> cursorY != cl -> screen -> cursorY ) {\n rfbRedrawAfterHideCursor ( cl , updateRegion ) ;\n LOCK ( cl -> screen -> cursorMutex ) ;\n cl -> cursorX = cl -> screen -> cursorX ;\n cl -> cursorY = cl -> screen -> cursorY ;\n UNLOCK ( cl -> screen -> cursorMutex ) ;\n rfbRedrawAfterHideCursor ( cl , updateRegion ) ;\n }\n rfbShowCursor ( cl ) ;\n }\n rfbStatRecordMessageSent ( cl , rfbFramebufferUpdate , 0 , 0 ) ;\n if ( cl -> preferredEncoding == rfbEncodingCoRRE ) {\n nUpdateRegionRects = 0 ;\n for ( i = sraRgnGetIterator ( updateRegion ) ;\n sraRgnIteratorNext ( i , & rect ) ;\n ) {\n int x = rect . x1 ;\n int y = rect . y1 ;\n int w = rect . x2 - x ;\n int h = rect . y2 - y ;\n int rectsPerRow , rows ;\n if ( cl -> screen != cl -> scaledScreen ) rfbScaledCorrection ( cl -> screen , cl -> scaledScreen , & x , & y , & w , & h , \"rfbSendFramebufferUpdate\" ) ;\n rectsPerRow = ( w - 1 ) / cl -> correMaxWidth + 1 ;\n rows = ( h - 1 ) / cl -> correMaxHeight + 1 ;\n nUpdateRegionRects += rectsPerRow * rows ;\n }\n sraRgnReleaseIterator ( i ) ;\n i = NULL ;\n }\n else if ( cl -> preferredEncoding == rfbEncodingUltra ) {\n nUpdateRegionRects = 0 ;\n for ( i = sraRgnGetIterator ( updateRegion ) ;\n sraRgnIteratorNext ( i , & rect ) ;\n ) {\n int x = rect . x1 ;\n int y = rect . y1 ;\n int w = rect . x2 - x ;\n int h = rect . y2 - y ;\n if ( cl -> screen != cl -> scaledScreen ) rfbScaledCorrection ( cl -> screen , cl -> scaledScreen , & x , & y , & w , & h , \"rfbSendFramebufferUpdate\" ) ;\n nUpdateRegionRects += ( ( ( h - 1 ) / ( ULTRA_MAX_SIZE ( w ) / w ) ) + 1 ) ;\n }\n sraRgnReleaseIterator ( i ) ;\n i = NULL ;\n # ifdef LIBVNCSERVER_HAVE_LIBZ }\n else if ( cl -> preferredEncoding == rfbEncodingZlib ) {\n nUpdateRegionRects = 0 ;\n for ( i = sraRgnGetIterator ( updateRegion ) ;\n sraRgnIteratorNext ( i , & rect ) ;\n ) {\n int x = rect . x1 ;\n int y = rect . y1 ;\n int w = rect . x2 - x ;\n int h = rect . y2 - y ;\n if ( cl -> screen != cl -> scaledScreen ) rfbScaledCorrection ( cl -> screen , cl -> scaledScreen , & x , & y , & w , & h , \"rfbSendFramebufferUpdate\" ) ;\n nUpdateRegionRects += ( ( ( h - 1 ) / ( ZLIB_MAX_SIZE ( w ) / w ) ) + 1 ) ;\n }\n sraRgnReleaseIterator ( i ) ;\n i = NULL ;\n # ifdef LIBVNCSERVER_HAVE_LIBJPEG }\n else if ( cl -> preferredEncoding == rfbEncodingTight ) {\n nUpdateRegionRects = 0 ;\n for ( i = sraRgnGetIterator ( updateRegion ) ;\n sraRgnIteratorNext ( i , & rect ) ;\n ) {\n int x = rect . x1 ;\n int y = rect . y1 ;\n int w = rect . x2 - x ;\n int h = rect . y2 - y ;\n int n ;\n if ( cl -> screen != cl -> scaledScreen ) rfbScaledCorrection ( cl -> screen , cl -> scaledScreen , & x , & y , & w , & h , \"rfbSendFramebufferUpdate\" ) ;\n n = rfbNumCodedRectsTight ( cl , x , y , w , h ) ;\n if ( n == 0 ) {\n nUpdateRegionRects = 0xFFFF ;\n break ;\n }\n nUpdateRegionRects += n ;\n }\n sraRgnReleaseIterator ( i ) ;\n i = NULL ;\n # endif # endif # if defined ( LIBVNCSERVER_HAVE_LIBJPEG ) && defined ( LIBVNCSERVER_HAVE_LIBPNG ) }\n else if ( cl -> preferredEncoding == rfbEncodingTightPng ) {\n nUpdateRegionRects = 0 ;\n for ( i = sraRgnGetIterator ( updateRegion ) ;\n sraRgnIteratorNext ( i , & rect ) ;\n ) {\n int x = rect . x1 ;\n int y = rect . y1 ;\n int w = rect . x2 - x ;\n int h = rect . y2 - y ;\n int n ;\n if ( cl -> screen != cl -> scaledScreen ) rfbScaledCorrection ( cl -> screen , cl -> scaledScreen , & x , & y , & w , & h , \"rfbSendFramebufferUpdate\" ) ;\n n = rfbNumCodedRectsTight ( cl , x , y , w , h ) ;\n if ( n == 0 ) {\n nUpdateRegionRects = 0xFFFF ;\n break ;\n }\n nUpdateRegionRects += n ;\n }\n sraRgnReleaseIterator ( i ) ;\n i = NULL ;\n # endif }\n else {\n nUpdateRegionRects = sraRgnCountRects ( updateRegion ) ;\n }\n fu -> type = rfbFramebufferUpdate ;\n if ( nUpdateRegionRects != 0xFFFF ) {\n if ( cl -> screen -> maxRectsPerUpdate > 0 && cl -> preferredEncoding != rfbEncodingCoRRE && cl -> preferredEncoding != rfbEncodingUltra # ifdef LIBVNCSERVER_HAVE_LIBZ && cl -> preferredEncoding != rfbEncodingZlib # ifdef LIBVNCSERVER_HAVE_LIBJPEG && cl -> preferredEncoding != rfbEncodingTight # endif # endif # ifdef LIBVNCSERVER_HAVE_LIBPNG && cl -> preferredEncoding != rfbEncodingTightPng # endif && nUpdateRegionRects > cl -> screen -> maxRectsPerUpdate ) {\n sraRegion * newUpdateRegion = sraRgnBBox ( updateRegion ) ;\n sraRgnDestroy ( updateRegion ) ;\n updateRegion = newUpdateRegion ;\n nUpdateRegionRects = sraRgnCountRects ( updateRegion ) ;\n }\n fu -> nRects = Swap16IfLE ( ( uint16_t ) ( sraRgnCountRects ( updateCopyRegion ) + nUpdateRegionRects + ! ! sendCursorShape + ! ! sendCursorPos + ! ! sendKeyboardLedState + ! ! sendSupportedMessages + ! ! sendSupportedEncodings + ! ! sendServerIdentity ) ) ;\n }\n else {\n fu -> nRects = 0xFFFF ;\n }\n cl -> ublen = sz_rfbFramebufferUpdateMsg ;\n if ( sendCursorShape ) {\n cl -> cursorWasChanged = FALSE ;\n if ( ! rfbSendCursorShape ( cl ) ) goto updateFailed ;\n }\n if ( sendCursorPos ) {\n cl -> cursorWasMoved = FALSE ;\n if ( ! rfbSendCursorPos ( cl ) ) goto updateFailed ;\n }\n if ( sendKeyboardLedState ) {\n if ( ! rfbSendKeyboardLedState ( cl ) ) goto updateFailed ;\n }\n if ( sendSupportedMessages ) {\n if ( ! rfbSendSupportedMessages ( cl ) ) goto updateFailed ;\n }\n if ( sendSupportedEncodings ) {\n if ( ! rfbSendSupportedEncodings ( cl ) ) goto updateFailed ;\n }\n if ( sendServerIdentity ) {\n if ( ! rfbSendServerIdentity ( cl ) ) goto updateFailed ;\n }\n if ( ! sraRgnEmpty ( updateCopyRegion ) ) {\n if ( ! rfbSendCopyRegion ( cl , updateCopyRegion , dx , dy ) ) goto updateFailed ;\n }\n for ( i = sraRgnGetIterator ( updateRegion ) ;\n sraRgnIteratorNext ( i , & rect ) ;\n ) {\n int x = rect . x1 ;\n int y = rect . y1 ;\n int w = rect . x2 - x ;\n int h = rect . y2 - y ;\n if ( cl -> screen != cl -> scaledScreen ) rfbScaledCorrection ( cl -> screen , cl -> scaledScreen , & x , & y , & w , & h , \"rfbSendFramebufferUpdate\" ) ;\n switch ( cl -> preferredEncoding ) {\n case - 1 : case rfbEncodingRaw : if ( ! rfbSendRectEncodingRaw ( cl , x , y , w , h ) ) goto updateFailed ;\n break ;\n case rfbEncodingRRE : if ( ! rfbSendRectEncodingRRE ( cl , x , y , w , h ) ) goto updateFailed ;\n break ;\n case rfbEncodingCoRRE : if ( ! rfbSendRectEncodingCoRRE ( cl , x , y , w , h ) ) goto updateFailed ;\n break ;\n case rfbEncodingHextile : if ( ! rfbSendRectEncodingHextile ( cl , x , y , w , h ) ) goto updateFailed ;\n break ;\n case rfbEncodingUltra : if ( ! rfbSendRectEncodingUltra ( cl , x , y , w , h ) ) goto updateFailed ;\n break ;\n # ifdef LIBVNCSERVER_HAVE_LIBZ case rfbEncodingZlib : if ( ! rfbSendRectEncodingZlib ( cl , x , y , w , h ) ) goto updateFailed ;\n break ;\n case rfbEncodingZRLE : case rfbEncodingZYWRLE : if ( ! rfbSendRectEncodingZRLE ( cl , x , y , w , h ) ) goto updateFailed ;\n break ;\n # endif # if defined ( LIBVNCSERVER_HAVE_LIBJPEG ) && ( defined ( LIBVNCSERVER_HAVE_LIBZ ) || defined ( LIBVNCSERVER_HAVE_LIBPNG ) ) case rfbEncodingTight : if ( ! rfbSendRectEncodingTight ( cl , x , y , w , h ) ) goto updateFailed ;\n break ;\n # ifdef LIBVNCSERVER_HAVE_LIBPNG case rfbEncodingTightPng : if ( ! rfbSendRectEncodingTightPng ( cl , x , y , w , h ) ) goto updateFailed ;\n break ;\n # endif # endif }\n }\n if ( i ) {\n sraRgnReleaseIterator ( i ) ;\n i = NULL ;\n }\n if ( nUpdateRegionRects == 0xFFFF && ! rfbSendLastRectMarker ( cl ) ) goto updateFailed ;\n if ( ! rfbSendUpdateBuf ( cl ) ) {\n updateFailed : result = FALSE ;\n }\n if ( ! cl -> enableCursorShapeUpdates ) {\n rfbHideCursor ( cl ) ;\n }\n if ( i ) sraRgnReleaseIterator ( i ) ;\n sraRgnDestroy ( updateRegion ) ;\n sraRgnDestroy ( updateCopyRegion ) ;\n if ( cl -> screen -> displayFinishedHook ) cl -> screen -> displayFinishedHook ( cl , result ) ;\n return result ;\n }", "idx": 1968}
{"hash": 1208165234047591297, "project": "debian", "size": 5, "label": 0, "functionSource": "proto_item * parseGuid ( proto_tree * tree , tvbuff_t * tvb , packet_info * pinfo _U_ , gint * pOffset , int hfIndex ) {\n proto_item * item = proto_tree_add_item ( tree , hfIndex , tvb , * pOffset , GUID_LEN , ENC_NA ) ;\n * pOffset += GUID_LEN ;\n return item ;\n }", "idx": 1969}
{"hash": 8572106347813672436, "project": "debian", "size": 3, "label": 0, "functionSource": "static inline int pfkey_sec_ctx_len ( const struct sadb_x_sec_ctx * sec_ctx ) {\n return DIV_ROUND_UP ( sizeof ( struct sadb_x_sec_ctx ) + sec_ctx -> sadb_x_ctx_len , sizeof ( uint64_t ) ) ;\n }", "idx": 1970}
{"hash": -4032982860280343776, "project": "chrome", "size": 293, "label": 1, "functionSource": "static void _SCSUToUnicodeWithOffsets ( UConverterToUnicodeArgs * pArgs , UErrorCode * pErrorCode ) {\n UConverter * cnv ;\n SCSUData * scsu ;\n const uint8_t * source , * sourceLimit ;\n UChar * target ;\n const UChar * targetLimit ;\n int32_t * offsets ;\n UBool isSingleByteMode ;\n uint8_t state , byteOne ;\n int8_t quoteWindow , dynamicWindow ;\n int32_t sourceIndex , nextSourceIndex ;\n uint8_t b ;\n cnv = pArgs -> converter ;\n scsu = ( SCSUData * ) cnv -> extraInfo ;\n source = ( const uint8_t * ) pArgs -> source ;\n sourceLimit = ( const uint8_t * ) pArgs -> sourceLimit ;\n target = pArgs -> target ;\n targetLimit = pArgs -> targetLimit ;\n offsets = pArgs -> offsets ;\n isSingleByteMode = scsu -> toUIsSingleByteMode ;\n state = scsu -> toUState ;\n quoteWindow = scsu -> toUQuoteWindow ;\n dynamicWindow = scsu -> toUDynamicWindow ;\n byteOne = scsu -> toUByteOne ;\n sourceIndex = state == readCommand ? 0 : - 1 ;\n nextSourceIndex = 0 ;\n if ( isSingleByteMode ) {\n if ( state == readCommand ) {\n fastSingle : while ( source < sourceLimit && target < targetLimit && ( b = * source ) >= 0x20 ) {\n ++ source ;\n ++ nextSourceIndex ;\n if ( b <= 0x7f ) {\n * target ++ = ( UChar ) b ;\n if ( offsets != NULL ) {\n * offsets ++ = sourceIndex ;\n }\n }\n else {\n uint32_t c = scsu -> toUDynamicOffsets [ dynamicWindow ] + ( b & 0x7f ) ;\n if ( c <= 0xffff ) {\n * target ++ = ( UChar ) c ;\n if ( offsets != NULL ) {\n * offsets ++ = sourceIndex ;\n }\n }\n else {\n * target ++ = ( UChar ) ( 0xd7c0 + ( c >> 10 ) ) ;\n if ( target < targetLimit ) {\n * target ++ = ( UChar ) ( 0xdc00 | ( c & 0x3ff ) ) ;\n if ( offsets != NULL ) {\n * offsets ++ = sourceIndex ;\n * offsets ++ = sourceIndex ;\n }\n }\n else {\n if ( offsets != NULL ) {\n * offsets ++ = sourceIndex ;\n }\n cnv -> UCharErrorBuffer [ 0 ] = ( UChar ) ( 0xdc00 | ( c & 0x3ff ) ) ;\n cnv -> UCharErrorBufferLength = 1 ;\n * pErrorCode = U_BUFFER_OVERFLOW_ERROR ;\n goto endloop ;\n }\n }\n }\n sourceIndex = nextSourceIndex ;\n }\n }\n singleByteMode : while ( source < sourceLimit ) {\n if ( target >= targetLimit ) {\n * pErrorCode = U_BUFFER_OVERFLOW_ERROR ;\n break ;\n }\n b = * source ++ ;\n ++ nextSourceIndex ;\n switch ( state ) {\n case readCommand : if ( ( 1UL << b ) & 0x2601 ) {\n * target ++ = ( UChar ) b ;\n if ( offsets != NULL ) {\n * offsets ++ = sourceIndex ;\n }\n sourceIndex = nextSourceIndex ;\n goto fastSingle ;\n }\n else if ( SC0 <= b ) {\n if ( b <= SC7 ) {\n dynamicWindow = ( int8_t ) ( b - SC0 ) ;\n sourceIndex = nextSourceIndex ;\n goto fastSingle ;\n }\n else {\n dynamicWindow = ( int8_t ) ( b - SD0 ) ;\n state = defineOne ;\n }\n }\n else if ( b <= SQ7 ) {\n quoteWindow = ( int8_t ) ( b - SQ0 ) ;\n state = quoteOne ;\n }\n else if ( b == SDX ) {\n state = definePairOne ;\n }\n else if ( b == SQU ) {\n state = quotePairOne ;\n }\n else if ( b == SCU ) {\n sourceIndex = nextSourceIndex ;\n isSingleByteMode = FALSE ;\n goto fastUnicode ;\n }\n else {\n * pErrorCode = U_ILLEGAL_CHAR_FOUND ;\n cnv -> toUBytes [ 0 ] = b ;\n cnv -> toULength = 1 ;\n goto endloop ;\n }\n cnv -> toUBytes [ 0 ] = b ;\n cnv -> toULength = 1 ;\n break ;\n case quotePairOne : byteOne = b ;\n cnv -> toUBytes [ 1 ] = b ;\n cnv -> toULength = 2 ;\n state = quotePairTwo ;\n break ;\n case quotePairTwo : * target ++ = ( UChar ) ( ( byteOne << 8 ) | b ) ;\n if ( offsets != NULL ) {\n * offsets ++ = sourceIndex ;\n }\n sourceIndex = nextSourceIndex ;\n state = readCommand ;\n goto fastSingle ;\n case quoteOne : if ( b < 0x80 ) {\n * target ++ = ( UChar ) ( staticOffsets [ quoteWindow ] + b ) ;\n if ( offsets != NULL ) {\n * offsets ++ = sourceIndex ;\n }\n }\n else {\n uint32_t c = scsu -> toUDynamicOffsets [ quoteWindow ] + ( b & 0x7f ) ;\n if ( c <= 0xffff ) {\n * target ++ = ( UChar ) c ;\n if ( offsets != NULL ) {\n * offsets ++ = sourceIndex ;\n }\n }\n else {\n * target ++ = ( UChar ) ( 0xd7c0 + ( c >> 10 ) ) ;\n if ( target < targetLimit ) {\n * target ++ = ( UChar ) ( 0xdc00 | ( c & 0x3ff ) ) ;\n if ( offsets != NULL ) {\n * offsets ++ = sourceIndex ;\n * offsets ++ = sourceIndex ;\n }\n }\n else {\n if ( offsets != NULL ) {\n * offsets ++ = sourceIndex ;\n }\n cnv -> UCharErrorBuffer [ 0 ] = ( UChar ) ( 0xdc00 | ( c & 0x3ff ) ) ;\n cnv -> UCharErrorBufferLength = 1 ;\n * pErrorCode = U_BUFFER_OVERFLOW_ERROR ;\n goto endloop ;\n }\n }\n }\n sourceIndex = nextSourceIndex ;\n state = readCommand ;\n goto fastSingle ;\n case definePairOne : dynamicWindow = ( int8_t ) ( ( b >> 5 ) & 7 ) ;\n byteOne = ( uint8_t ) ( b & 0x1f ) ;\n cnv -> toUBytes [ 1 ] = b ;\n cnv -> toULength = 2 ;\n state = definePairTwo ;\n break ;\n case definePairTwo : scsu -> toUDynamicOffsets [ dynamicWindow ] = 0x10000 + ( byteOne << 15UL | b << 7UL ) ;\n sourceIndex = nextSourceIndex ;\n state = readCommand ;\n goto fastSingle ;\n case defineOne : if ( b == 0 ) {\n cnv -> toUBytes [ 1 ] = b ;\n cnv -> toULength = 2 ;\n goto endloop ;\n }\n else if ( b < gapThreshold ) {\n scsu -> toUDynamicOffsets [ dynamicWindow ] = b << 7UL ;\n }\n else if ( ( uint8_t ) ( b - gapThreshold ) < ( reservedStart - gapThreshold ) ) {\n scsu -> toUDynamicOffsets [ dynamicWindow ] = ( b << 7UL ) + gapOffset ;\n }\n else if ( b >= fixedThreshold ) {\n scsu -> toUDynamicOffsets [ dynamicWindow ] = fixedOffsets [ b - fixedThreshold ] ;\n }\n else {\n cnv -> toUBytes [ 1 ] = b ;\n cnv -> toULength = 2 ;\n goto endloop ;\n }\n sourceIndex = nextSourceIndex ;\n state = readCommand ;\n goto fastSingle ;\n }\n }\n }\n else {\n if ( state == readCommand ) {\n fastUnicode : while ( source + 1 < sourceLimit && target < targetLimit && ( uint8_t ) ( ( b = * source ) - UC0 ) > ( Urs - UC0 ) ) {\n * target ++ = ( UChar ) ( ( b << 8 ) | source [ 1 ] ) ;\n if ( offsets != NULL ) {\n * offsets ++ = sourceIndex ;\n }\n sourceIndex = nextSourceIndex ;\n nextSourceIndex += 2 ;\n source += 2 ;\n }\n }\n while ( source < sourceLimit ) {\n if ( target >= targetLimit ) {\n * pErrorCode = U_BUFFER_OVERFLOW_ERROR ;\n break ;\n }\n b = * source ++ ;\n ++ nextSourceIndex ;\n switch ( state ) {\n case readCommand : if ( ( uint8_t ) ( b - UC0 ) > ( Urs - UC0 ) ) {\n byteOne = b ;\n cnv -> toUBytes [ 0 ] = b ;\n cnv -> toULength = 1 ;\n state = quotePairTwo ;\n }\n else if ( b <= UC7 ) {\n dynamicWindow = ( int8_t ) ( b - UC0 ) ;\n sourceIndex = nextSourceIndex ;\n isSingleByteMode = TRUE ;\n goto fastSingle ;\n }\n else if ( b <= UD7 ) {\n dynamicWindow = ( int8_t ) ( b - UD0 ) ;\n isSingleByteMode = TRUE ;\n cnv -> toUBytes [ 0 ] = b ;\n cnv -> toULength = 1 ;\n state = defineOne ;\n goto singleByteMode ;\n }\n else if ( b == UDX ) {\n isSingleByteMode = TRUE ;\n cnv -> toUBytes [ 0 ] = b ;\n cnv -> toULength = 1 ;\n state = definePairOne ;\n goto singleByteMode ;\n }\n else if ( b == UQU ) {\n cnv -> toUBytes [ 0 ] = b ;\n cnv -> toULength = 1 ;\n state = quotePairOne ;\n }\n else {\n * pErrorCode = U_ILLEGAL_CHAR_FOUND ;\n cnv -> toUBytes [ 0 ] = b ;\n cnv -> toULength = 1 ;\n goto endloop ;\n }\n break ;\n case quotePairOne : byteOne = b ;\n cnv -> toUBytes [ 1 ] = b ;\n cnv -> toULength = 2 ;\n state = quotePairTwo ;\n break ;\n case quotePairTwo : * target ++ = ( UChar ) ( ( byteOne << 8 ) | b ) ;\n if ( offsets != NULL ) {\n * offsets ++ = sourceIndex ;\n }\n sourceIndex = nextSourceIndex ;\n state = readCommand ;\n goto fastUnicode ;\n }\n }\n }\n endloop : if ( U_FAILURE ( * pErrorCode ) && * pErrorCode != U_BUFFER_OVERFLOW_ERROR ) {\n state = readCommand ;\n }\n else if ( state == readCommand ) {\n cnv -> toULength = 0 ;\n }\n scsu -> toUIsSingleByteMode = isSingleByteMode ;\n scsu -> toUState = state ;\n scsu -> toUQuoteWindow = quoteWindow ;\n scsu -> toUDynamicWindow = dynamicWindow ;\n scsu -> toUByteOne = byteOne ;\n pArgs -> source = ( const char * ) source ;\n pArgs -> target = target ;\n pArgs -> offsets = offsets ;\n return ;\n }", "idx": 1971}
{"hash": 1414661670117003749, "project": "debian", "size": 12, "label": 0, "functionSource": "static int open_pack_bitmap ( void ) {\n struct packed_git * p ;\n int ret = - 1 ;\n assert ( ! bitmap_git . map && ! bitmap_git . loaded ) ;\n prepare_packed_git ( ) ;\n for ( p = packed_git ;\n p ;\n p = p -> next ) {\n if ( open_pack_bitmap_1 ( p ) == 0 ) ret = 0 ;\n }\n return ret ;\n }", "idx": 1972}
{"hash": -1743990138967426061, "project": "debian", "size": 37, "label": 0, "functionSource": "int ImagingPcdDecode ( Imaging im , ImagingCodecState state , UINT8 * buf , int bytes ) {\n int x ;\n int chunk ;\n UINT8 * out ;\n UINT8 * ptr ;\n ptr = buf ;\n chunk = 3 * state -> xsize ;\n for ( ;\n ;\n ) {\n if ( bytes < chunk ) return ptr - buf ;\n out = state -> buffer ;\n for ( x = 0 ;\n x < state -> xsize ;\n x ++ ) {\n out [ 0 ] = ptr [ x ] ;\n out [ 1 ] = ptr [ ( x + 4 * state -> xsize ) / 2 ] ;\n out [ 2 ] = ptr [ ( x + 5 * state -> xsize ) / 2 ] ;\n out += 3 ;\n }\n state -> shuffle ( ( UINT8 * ) im -> image [ state -> y ] , state -> buffer , state -> xsize ) ;\n if ( ++ state -> y >= state -> ysize ) return - 1 ;\n out = state -> buffer ;\n for ( x = 0 ;\n x < state -> xsize ;\n x ++ ) {\n out [ 0 ] = ptr [ x + state -> xsize ] ;\n out [ 1 ] = ptr [ ( x + 4 * state -> xsize ) / 2 ] ;\n out [ 2 ] = ptr [ ( x + 5 * state -> xsize ) / 2 ] ;\n out += 3 ;\n }\n state -> shuffle ( ( UINT8 * ) im -> image [ state -> y ] , state -> buffer , state -> xsize ) ;\n if ( ++ state -> y >= state -> ysize ) return - 1 ;\n ptr += chunk ;\n bytes -= chunk ;\n }\n }", "idx": 1973}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_CallInformationResp ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_CallInformationResp , CallInformationResp_sequence ) ;\n return offset ;\n }", "idx": 1974}
{"hash": -2648356651055439484, "project": "debian", "size": 3, "label": 0, "functionSource": "static void gsm_a_dtap_cc_stat_init ( new_stat_tap_ui * new_stat , new_stat_tap_gui_init_cb gui_callback , void * gui_data ) {\n gsm_a_stat_init ( new_stat , gui_callback , gui_data , \"GSM A-I/F DTAP Call Control Statistics\" , gsm_a_dtap_msg_cc_strings ) ;\n }", "idx": 1975}
{"hash": -7236893719053583356, "project": "debian", "size": 12, "label": 0, "functionSource": "static void dissect_zcl_color_control_move_hue_saturation ( tvbuff_t * tvb , proto_tree * tree , guint * offset , gboolean enhanced ) {\n proto_tree_add_item ( tree , hf_zbee_zcl_color_control_move_mode , tvb , * offset , 1 , ENC_LITTLE_ENDIAN ) ;\n * offset += 1 ;\n if ( enhanced ) {\n proto_tree_add_item ( tree , hf_zbee_zcl_color_control_enhanced_rate , tvb , * offset , 2 , ENC_LITTLE_ENDIAN ) ;\n * offset += 2 ;\n }\n else {\n proto_tree_add_item ( tree , hf_zbee_zcl_color_control_rate , tvb , * offset , 1 , ENC_LITTLE_ENDIAN ) ;\n * offset += 1 ;\n }\n }", "idx": 1976}
{"hash": -2325305888478261876, "project": "debian", "size": 4, "label": 0, "functionSource": "int tm_create_event ( tm_event_t * event ) {\n if ( ! init_done ) return TM_BADINIT ;\n return TM_ENOTIMPLEMENTED ;\n }", "idx": 1977}
{"hash": 369115599810341094, "project": "debian", "size": 15, "label": 1, "functionSource": "static void vga_draw_line15_le ( VGACommonState * s1 , uint8_t * d , const uint8_t * s , int width ) {\n int w ;\n uint32_t v , r , g , b ;\n w = width ;\n do {\n v = lduw_le_p ( ( void * ) s ) ;\n r = ( v >> 7 ) & 0xf8 ;\n g = ( v >> 2 ) & 0xf8 ;\n b = ( v << 3 ) & 0xf8 ;\n ( ( uint32_t * ) d ) [ 0 ] = rgb_to_pixel32 ( r , g , b ) ;\n s += 2 ;\n d += 4 ;\n }\n while ( -- w != 0 ) ;\n }", "idx": 1978}
{"hash": 5611940141018433728, "project": "chrome", "size": 20, "label": 0, "functionSource": "static void write_partition ( const VP9_COMMON * const cm , const MACROBLOCKD * const xd , int hbs , int mi_row , int mi_col , PARTITION_TYPE p , BLOCK_SIZE bsize , vp9_writer * w ) {\n const int ctx = partition_plane_context ( xd , mi_row , mi_col , bsize ) ;\n const vp9_prob * const probs = get_partition_probs ( cm , ctx ) ;\n const int has_rows = ( mi_row + hbs ) < cm -> mi_rows ;\n const int has_cols = ( mi_col + hbs ) < cm -> mi_cols ;\n if ( has_rows && has_cols ) {\n vp9_write_token ( w , vp9_partition_tree , probs , & partition_encodings [ p ] ) ;\n }\n else if ( ! has_rows && has_cols ) {\n assert ( p == PARTITION_SPLIT || p == PARTITION_HORZ ) ;\n vp9_write ( w , p == PARTITION_SPLIT , probs [ 1 ] ) ;\n }\n else if ( has_rows && ! has_cols ) {\n assert ( p == PARTITION_SPLIT || p == PARTITION_VERT ) ;\n vp9_write ( w , p == PARTITION_SPLIT , probs [ 2 ] ) ;\n }\n else {\n assert ( p == PARTITION_SPLIT ) ;\n }\n }", "idx": 1979}
{"hash": 7424930167238097621, "project": "debian", "size": 48, "label": 0, "functionSource": "static int parse_usbdevfs_streams ( struct usb_dev_state * ps , struct usbdevfs_streams __user * streams , unsigned int * num_streams_ret , unsigned int * num_eps_ret , struct usb_host_endpoint * * * eps_ret , struct usb_interface * * intf_ret ) {\n unsigned int i , num_streams , num_eps ;\n struct usb_host_endpoint * * eps ;\n struct usb_interface * intf = NULL ;\n unsigned char ep ;\n int ifnum , ret ;\n if ( get_user ( num_streams , & streams -> num_streams ) || get_user ( num_eps , & streams -> num_eps ) ) return - EFAULT ;\n if ( num_eps < 1 || num_eps > USB_MAXENDPOINTS ) return - EINVAL ;\n if ( num_streams_ret && ( num_streams < 2 || num_streams > 65536 ) ) return - EINVAL ;\n eps = kmalloc ( num_eps * sizeof ( * eps ) , GFP_KERNEL ) ;\n if ( ! eps ) return - ENOMEM ;\n for ( i = 0 ;\n i < num_eps ;\n i ++ ) {\n if ( get_user ( ep , & streams -> eps [ i ] ) ) {\n ret = - EFAULT ;\n goto error ;\n }\n eps [ i ] = ep_to_host_endpoint ( ps -> dev , ep ) ;\n if ( ! eps [ i ] ) {\n ret = - EINVAL ;\n goto error ;\n }\n ifnum = findintfep ( ps -> dev , ep ) ;\n if ( ifnum < 0 ) {\n ret = ifnum ;\n goto error ;\n }\n if ( i == 0 ) {\n ret = checkintf ( ps , ifnum ) ;\n if ( ret < 0 ) goto error ;\n intf = usb_ifnum_to_if ( ps -> dev , ifnum ) ;\n }\n else {\n if ( ifnum != intf -> altsetting -> desc . bInterfaceNumber ) {\n ret = - EINVAL ;\n goto error ;\n }\n }\n }\n if ( num_streams_ret ) * num_streams_ret = num_streams ;\n * num_eps_ret = num_eps ;\n * eps_ret = eps ;\n * intf_ret = intf ;\n return 0 ;\n error : kfree ( eps ) ;\n return ret ;\n }", "idx": 1980}
{"hash": -1983921383858884161, "project": "debian", "size": 12, "label": 1, "functionSource": "static int ipvideo_decode_block_opcode_0xE ( IpvideoContext * s ) {\n int y ;\n unsigned char pix ;\n pix = bytestream2_get_byte ( & s -> stream_ptr ) ;\n for ( y = 0 ;\n y < 8 ;\n y ++ ) {\n memset ( s -> pixel_ptr , pix , 8 ) ;\n s -> pixel_ptr += s -> stride ;\n }\n return 0 ;\n }", "idx": 1981}
{"hash": -5992472514718425579, "project": "debian", "size": 27, "label": 0, "functionSource": "static char * * subsystems_from_mount_options ( const char * mount_options , char * * kernel_list ) {\n char * token , * str , * saveptr = NULL ;\n char * * result = NULL ;\n size_t result_capacity = 0 ;\n size_t result_count = 0 ;\n int saved_errno ;\n int r ;\n str = alloca ( strlen ( mount_options ) + 1 ) ;\n strcpy ( str , mount_options ) ;\n for ( ;\n ( token = strtok_r ( str , \",\" , & saveptr ) ) ;\n str = NULL ) {\n if ( ! strncmp ( token , \"name=\" , 5 ) || lxc_string_in_array ( token , ( const char * * ) kernel_list ) ) {\n r = lxc_grow_array ( ( void * * * ) & result , & result_capacity , result_count + 1 , 12 ) ;\n if ( r < 0 ) goto out_free ;\n result [ result_count + 1 ] = NULL ;\n result [ result_count ] = strdup ( token ) ;\n if ( ! result [ result_count ] ) goto out_free ;\n result_count ++ ;\n }\n }\n return result ;\n out_free : saved_errno = errno ;\n lxc_free_array ( ( void * * ) result , free ) ;\n errno = saved_errno ;\n return NULL ;\n }", "idx": 1982}
{"hash": -1919011628477388936, "project": "debian", "size": 35, "label": 0, "functionSource": "static void fsl_common_init ( OpenPICState * opp ) {\n int i ;\n int virq = OPENPIC_MAX_SRC ;\n opp -> vid = VID_REVISION_1_2 ;\n opp -> vir = VIR_GENERIC ;\n opp -> vector_mask = 0xFFFF ;\n opp -> tfrr_reset = 0 ;\n opp -> ivpr_reset = IVPR_MASK_MASK ;\n opp -> idr_reset = 1 << 0 ;\n opp -> max_irq = OPENPIC_MAX_IRQ ;\n opp -> irq_ipi0 = virq ;\n virq += OPENPIC_MAX_IPI ;\n opp -> irq_tim0 = virq ;\n virq += OPENPIC_MAX_TMR ;\n assert ( virq <= OPENPIC_MAX_IRQ ) ;\n opp -> irq_msi = 224 ;\n msi_supported = true ;\n for ( i = 0 ;\n i < opp -> fsl -> max_ext ;\n i ++ ) {\n opp -> src [ i ] . level = false ;\n }\n for ( i = 16 ;\n i < OPENPIC_MAX_SRC ;\n i ++ ) {\n opp -> src [ i ] . type = IRQ_TYPE_FSLINT ;\n opp -> src [ i ] . level = true ;\n }\n for ( i = OPENPIC_MAX_SRC ;\n i < virq ;\n i ++ ) {\n opp -> src [ i ] . type = IRQ_TYPE_FSLSPECIAL ;\n opp -> src [ i ] . level = false ;\n }\n }", "idx": 1983}
{"hash": 5991533509192663951, "project": "debian", "size": 28, "label": 1, "functionSource": "const mbfl_encoding * mbfl_encoding_detector_judge2 ( mbfl_encoding_detector * identd ) {\n mbfl_identify_filter * filter ;\n const mbfl_encoding * encoding = NULL ;\n int n ;\n if ( identd != NULL ) {\n n = identd -> filter_list_size - 1 ;\n while ( n >= 0 ) {\n filter = identd -> filter_list [ n ] ;\n if ( ! filter -> flag ) {\n if ( ! identd -> strict || ! filter -> status ) {\n encoding = filter -> encoding ;\n }\n }\n n -- ;\n }\n if ( ! encoding ) {\n n = identd -> filter_list_size - 1 ;\n while ( n >= 0 ) {\n filter = identd -> filter_list [ n ] ;\n if ( ! filter -> flag ) {\n encoding = filter -> encoding ;\n }\n n -- ;\n }\n }\n }\n return encoding ;\n }", "idx": 1984}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_T_eRM ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_T_eRM , T_eRM_sequence ) ;\n return offset ;\n }", "idx": 1985}
{"hash": 6755873269946787742, "project": "debian", "size": 9, "label": 0, "functionSource": "void pk_transaction_reset_after_lock_error ( PkTransaction * transaction ) {\n PkTransactionPrivate * priv = PK_TRANSACTION_GET_PRIVATE ( transaction ) ;\n g_return_if_fail ( PK_IS_TRANSACTION ( transaction ) ) ;\n g_object_unref ( priv -> results ) ;\n priv -> results = pk_results_new ( ) ;\n priv -> state = PK_TRANSACTION_STATE_READY ;\n pk_transaction_set_state ( transaction , PK_TRANSACTION_STATE_READY ) ;\n g_debug ( \"transaction has been reset after lock-required issue.\" ) ;\n }", "idx": 1986}
{"hash": 1981604082870872490, "project": "chrome", "size": 38, "label": 0, "functionSource": "static int32_t u_printf_scidbl_handler ( const u_printf_stream_handler * handler , void * context , ULocaleBundle * formatBundle , const u_printf_spec_info * info , const ufmt_args * args ) {\n u_printf_spec_info scidbl_info ;\n double num = args [ 0 ] . doubleValue ;\n int32_t retVal ;\n UNumberFormat * format ;\n int32_t maxSigDecimalDigits , significantDigits ;\n memcpy ( & scidbl_info , info , sizeof ( u_printf_spec_info ) ) ;\n if ( scidbl_info . fPrecision == - 1 && num == uprv_trunc ( num ) ) {\n scidbl_info . fSpec = 0x0066 ;\n scidbl_info . fPrecision = 0 ;\n retVal = u_printf_double_handler ( handler , context , formatBundle , & scidbl_info , args ) ;\n }\n else if ( num < 0.0001 || ( scidbl_info . fPrecision < 1 && 1000000.0 <= num ) || ( scidbl_info . fPrecision != - 1 && num > uprv_pow10 ( scidbl_info . fPrecision ) ) ) {\n scidbl_info . fSpec = scidbl_info . fSpec - 2 ;\n if ( scidbl_info . fPrecision == - 1 ) {\n scidbl_info . fPrecision = 5 ;\n }\n retVal = u_printf_scientific_handler ( handler , context , formatBundle , & scidbl_info , args ) ;\n }\n else {\n format = u_locbund_getNumberFormat ( formatBundle , UNUM_DECIMAL ) ;\n if ( format == NULL ) {\n return 0 ;\n }\n maxSigDecimalDigits = unum_getAttribute ( format , UNUM_MAX_SIGNIFICANT_DIGITS ) ;\n significantDigits = scidbl_info . fPrecision ;\n scidbl_info . fSpec = 0x0066 ;\n if ( significantDigits == - 1 ) {\n significantDigits = 6 ;\n }\n unum_setAttribute ( format , UNUM_SIGNIFICANT_DIGITS_USED , TRUE ) ;\n unum_setAttribute ( format , UNUM_MAX_SIGNIFICANT_DIGITS , significantDigits ) ;\n retVal = u_printf_double_handler ( handler , context , formatBundle , & scidbl_info , args ) ;\n unum_setAttribute ( format , UNUM_MAX_SIGNIFICANT_DIGITS , maxSigDecimalDigits ) ;\n unum_setAttribute ( format , UNUM_SIGNIFICANT_DIGITS_USED , FALSE ) ;\n }\n return retVal ;\n }", "idx": 1987}
{"hash": -3740862514502467070, "project": "debian", "size": 75, "label": 0, "functionSource": "static void dumppointarrays ( struct glyphinfo * gi , BasePoint * bp , char * fs , int pc ) {\n BasePoint last ;\n int i , flags ;\n int lastflag , flagcnt ;\n if ( gi -> maxp -> maxPoints < pc ) gi -> maxp -> maxPoints = pc ;\n last . x = last . y = 0 ;\n lastflag = - 1 ;\n flagcnt = 0 ;\n for ( i = 0 ;\n i < pc ;\n ++ i ) {\n flags = 0 ;\n if ( fs == NULL || fs [ i ] ) flags = _On_Curve ;\n if ( last . x == bp [ i ] . x ) flags |= _X_Same ;\n else if ( bp [ i ] . x - last . x > - 256 && bp [ i ] . x - last . x < 255 ) {\n flags |= _X_Short ;\n if ( bp [ i ] . x >= last . x ) flags |= _X_Same ;\n }\n if ( last . y == bp [ i ] . y ) flags |= _Y_Same ;\n else if ( bp [ i ] . y - last . y > - 256 && bp [ i ] . y - last . y < 255 ) {\n flags |= _Y_Short ;\n if ( bp [ i ] . y >= last . y ) flags |= _Y_Same ;\n }\n last = bp [ i ] ;\n if ( lastflag == - 1 ) {\n lastflag = flags ;\n flagcnt = 0 ;\n }\n else if ( flags != lastflag ) {\n if ( flagcnt != 0 ) lastflag |= _Repeat ;\n putc ( lastflag , gi -> glyphs ) ;\n if ( flagcnt != 0 ) putc ( flagcnt , gi -> glyphs ) ;\n lastflag = flags ;\n flagcnt = 0 ;\n }\n else {\n if ( ++ flagcnt == 255 ) {\n putc ( lastflag | _Repeat , gi -> glyphs ) ;\n putc ( 255 , gi -> glyphs ) ;\n lastflag = - 1 ;\n flagcnt = 0 ;\n }\n }\n }\n if ( lastflag != - 1 ) {\n if ( flagcnt != 0 ) lastflag |= _Repeat ;\n putc ( lastflag , gi -> glyphs ) ;\n if ( flagcnt != 0 ) putc ( flagcnt , gi -> glyphs ) ;\n }\n last . x = 0 ;\n for ( i = 0 ;\n i < pc ;\n ++ i ) {\n if ( last . x == bp [ i ] . x ) ;\n else if ( bp [ i ] . x - last . x > - 256 && bp [ i ] . x - last . x < 255 ) {\n if ( bp [ i ] . x >= last . x ) putc ( bp [ i ] . x - last . x , gi -> glyphs ) ;\n else putc ( last . x - bp [ i ] . x , gi -> glyphs ) ;\n }\n else putshort ( gi -> glyphs , bp [ i ] . x - last . x ) ;\n last . x = bp [ i ] . x ;\n }\n last . y = 0 ;\n for ( i = 0 ;\n i < pc ;\n ++ i ) {\n if ( last . y == bp [ i ] . y ) ;\n else if ( bp [ i ] . y - last . y > - 256 && bp [ i ] . y - last . y < 255 ) {\n if ( bp [ i ] . y >= last . y ) putc ( bp [ i ] . y - last . y , gi -> glyphs ) ;\n else putc ( last . y - bp [ i ] . y , gi -> glyphs ) ;\n }\n else putshort ( gi -> glyphs , bp [ i ] . y - last . y ) ;\n last . y = bp [ i ] . y ;\n }\n if ( ftell ( gi -> glyphs ) & 1 ) putc ( '\\0' , gi -> glyphs ) ;\n }", "idx": 1988}
{"hash": -5280794106681745199, "project": "debian", "size": 66, "label": 0, "functionSource": "static GstFlowReturn gst_asf_demux_process_comment ( GstASFDemux * demux , guint8 * data , guint64 size ) {\n struct {\n const gchar * gst_tag ;\n guint16 val_length ;\n gchar * val_utf8 ;\n }\n tags [ 5 ] = {\n {\n GST_TAG_TITLE , 0 , NULL }\n , {\n GST_TAG_ARTIST , 0 , NULL }\n , {\n GST_TAG_COPYRIGHT , 0 , NULL }\n , {\n GST_TAG_DESCRIPTION , 0 , NULL }\n , {\n GST_TAG_COMMENT , 0 , NULL }\n }\n ;\n GstTagList * taglist ;\n GValue value = {\n 0 }\n ;\n gsize in , out ;\n gint i = - 1 ;\n GST_INFO_OBJECT ( demux , \"object is a comment\" ) ;\n if ( size < ( 2 + 2 + 2 + 2 + 2 ) ) goto not_enough_data ;\n tags [ 0 ] . val_length = gst_asf_demux_get_uint16 ( & data , & size ) ;\n tags [ 1 ] . val_length = gst_asf_demux_get_uint16 ( & data , & size ) ;\n tags [ 2 ] . val_length = gst_asf_demux_get_uint16 ( & data , & size ) ;\n tags [ 3 ] . val_length = gst_asf_demux_get_uint16 ( & data , & size ) ;\n tags [ 4 ] . val_length = gst_asf_demux_get_uint16 ( & data , & size ) ;\n GST_DEBUG_OBJECT ( demux , \"Comment lengths: title=%d author=%d copyright=%d \" \"description=%d rating=%d\" , tags [ 0 ] . val_length , tags [ 1 ] . val_length , tags [ 2 ] . val_length , tags [ 3 ] . val_length , tags [ 4 ] . val_length ) ;\n for ( i = 0 ;\n i < G_N_ELEMENTS ( tags ) ;\n ++ i ) {\n if ( size < tags [ i ] . val_length ) goto not_enough_data ;\n if ( tags [ i ] . val_length > 2 && tags [ i ] . val_length % 2 == 0 ) {\n tags [ i ] . val_utf8 = g_convert ( ( gchar * ) data , tags [ i ] . val_length , \"UTF-8\" , \"UTF-16LE\" , & in , & out , NULL ) ;\n }\n gst_asf_demux_skip_bytes ( tags [ i ] . val_length , & data , & size ) ;\n }\n taglist = gst_tag_list_new_empty ( ) ;\n g_value_init ( & value , G_TYPE_STRING ) ;\n for ( i = 0 ;\n i < G_N_ELEMENTS ( tags ) ;\n ++ i ) {\n if ( tags [ i ] . val_utf8 && strlen ( tags [ i ] . val_utf8 ) > 0 && tags [ i ] . gst_tag ) {\n g_value_set_string ( & value , tags [ i ] . val_utf8 ) ;\n gst_tag_list_add_values ( taglist , GST_TAG_MERGE_APPEND , tags [ i ] . gst_tag , & value , NULL ) ;\n }\n }\n g_value_unset ( & value ) ;\n gst_asf_demux_add_global_tags ( demux , taglist ) ;\n for ( i = 0 ;\n i < G_N_ELEMENTS ( tags ) ;\n ++ i ) g_free ( tags [ i ] . val_utf8 ) ;\n return GST_FLOW_OK ;\n not_enough_data : {\n GST_WARNING_OBJECT ( demux , \"unexpectedly short of data while processing \" \"comment tag section %d, skipping comment object\" , i ) ;\n for ( i = 0 ;\n i < G_N_ELEMENTS ( tags ) ;\n i ++ ) g_free ( tags [ i ] . val_utf8 ) ;\n return GST_FLOW_OK ;\n }\n }", "idx": 1989}
{"hash": 7198560023137364337, "project": "debian", "size": 76, "label": 1, "functionSource": "int read_ndx_and_attrs ( int f_in , int f_out , int * iflag_ptr , uchar * type_ptr , char * buf , int * len_ptr ) {\n int len , iflags = 0 ;\n struct file_list * flist ;\n uchar fnamecmp_type = FNAMECMP_FNAME ;\n int ndx ;\n read_loop : while ( 1 ) {\n ndx = read_ndx ( f_in ) ;\n if ( ndx >= 0 ) break ;\n if ( ndx == NDX_DONE ) return ndx ;\n if ( ndx == NDX_DEL_STATS ) {\n read_del_stats ( f_in ) ;\n if ( am_sender && am_server ) write_del_stats ( f_out ) ;\n continue ;\n }\n if ( ! inc_recurse || am_sender ) {\n int last ;\n if ( first_flist ) last = first_flist -> prev -> ndx_start + first_flist -> prev -> used - 1 ;\n else last = - 1 ;\n rprintf ( FERROR , \"Invalid file index: %d (%d - %d) [%s]\\n\" , ndx , NDX_DONE , last , who_am_i ( ) ) ;\n exit_cleanup ( RERR_PROTOCOL ) ;\n }\n if ( ndx == NDX_FLIST_EOF ) {\n flist_eof = 1 ;\n if ( DEBUG_GTE ( FLIST , 3 ) ) rprintf ( FINFO , \"[%s] flist_eof=1\\n\" , who_am_i ( ) ) ;\n write_int ( f_out , NDX_FLIST_EOF ) ;\n continue ;\n }\n ndx = NDX_FLIST_OFFSET - ndx ;\n if ( ndx < 0 || ndx >= dir_flist -> used ) {\n ndx = NDX_FLIST_OFFSET - ndx ;\n rprintf ( FERROR , \"Invalid dir index: %d (%d - %d) [%s]\\n\" , ndx , NDX_FLIST_OFFSET , NDX_FLIST_OFFSET - dir_flist -> used + 1 , who_am_i ( ) ) ;\n exit_cleanup ( RERR_PROTOCOL ) ;\n }\n if ( DEBUG_GTE ( FLIST , 2 ) ) {\n rprintf ( FINFO , \"[%s] receiving flist for dir %d\\n\" , who_am_i ( ) , ndx ) ;\n }\n start_flist_forward ( ndx ) ;\n flist = recv_file_list ( f_in , ndx ) ;\n flist -> parent_ndx = ndx ;\n stop_flist_forward ( ) ;\n }\n iflags = protocol_version >= 29 ? read_shortint ( f_in ) : ITEM_TRANSFER | ITEM_MISSING_DATA ;\n if ( protocol_version < 30 && ndx == cur_flist -> used && iflags == ITEM_IS_NEW ) {\n if ( am_sender ) maybe_send_keepalive ( time ( NULL ) , MSK_ALLOW_FLUSH ) ;\n goto read_loop ;\n }\n flist = flist_for_ndx ( ndx , \"read_ndx_and_attrs\" ) ;\n if ( flist != cur_flist ) {\n cur_flist = flist ;\n if ( am_sender ) {\n file_old_total = cur_flist -> used ;\n for ( flist = first_flist ;\n flist != cur_flist ;\n flist = flist -> next ) file_old_total += flist -> used ;\n }\n }\n if ( iflags & ITEM_BASIS_TYPE_FOLLOWS ) fnamecmp_type = read_byte ( f_in ) ;\n * type_ptr = fnamecmp_type ;\n if ( iflags & ITEM_XNAME_FOLLOWS ) {\n if ( ( len = read_vstring ( f_in , buf , MAXPATHLEN ) ) < 0 ) exit_cleanup ( RERR_PROTOCOL ) ;\n }\n else {\n * buf = '\\0' ;\n len = - 1 ;\n }\n * len_ptr = len ;\n if ( iflags & ITEM_TRANSFER ) {\n int i = ndx - cur_flist -> ndx_start ;\n if ( i < 0 || ! S_ISREG ( cur_flist -> files [ i ] -> mode ) ) {\n rprintf ( FERROR , \"received request to transfer non-regular file: %d [%s]\\n\" , ndx , who_am_i ( ) ) ;\n exit_cleanup ( RERR_PROTOCOL ) ;\n }\n }\n * iflag_ptr = iflags ;\n return ndx ;\n }", "idx": 1990}
{"hash": 4180964683905830761, "project": "debian", "size": 3, "label": 0, "functionSource": "static int selinux_inode_unlink ( struct inode * dir , struct dentry * dentry ) {\n return may_link ( dir , dentry , MAY_UNLINK ) ;\n }", "idx": 1991}
{"hash": 5605949879237783359, "project": "debian", "size": 19, "label": 0, "functionSource": "static int strtoi_lim ( const char * str , const char * * ep , int llim , int ulim ) {\n int res = 0 ;\n const char * sp ;\n int rulim ;\n for ( sp = str , rulim = ulim > 10 ? ulim : 10 ;\n res * 10 <= ulim && rulim && * sp >= '0' && * sp <= '9' ;\n sp ++ , rulim /= 10 ) {\n res *= 10 ;\n res += * sp - '0' ;\n }\n if ( sp == str ) {\n res = - 1 ;\n }\n else if ( res < llim || res > ulim ) {\n res = - 2 ;\n }\n * ep = ( const char * ) sp ;\n return res ;\n }", "idx": 1992}
{"hash": 8947170728280515149, "project": "debian", "size": 6, "label": 0, "functionSource": "SplinePointList * SplinesFromEntities ( Entity * ent , int * flags , int is_stroked ) {\n EntityChar ec ;\n memset ( & ec , '\\0' , sizeof ( ec ) ) ;\n ec . splines = ent ;\n return ( SplinesFromEntityChar ( & ec , flags , is_stroked ) ) ;\n }", "idx": 1993}
{"hash": 103178053094187415, "project": "chrome", "size": 41, "label": 0, "functionSource": "xmlChar * xsltEvalXPathStringNs ( xsltTransformContextPtr ctxt , xmlXPathCompExprPtr comp , int nsNr , xmlNsPtr * nsList ) {\n xmlChar * ret = NULL ;\n xmlXPathObjectPtr res ;\n xmlNodePtr oldInst ;\n xmlNodePtr oldNode ;\n int oldPos , oldSize ;\n int oldNsNr ;\n xmlNsPtr * oldNamespaces ;\n oldInst = ctxt -> inst ;\n oldNode = ctxt -> node ;\n oldPos = ctxt -> xpathCtxt -> proximityPosition ;\n oldSize = ctxt -> xpathCtxt -> contextSize ;\n oldNsNr = ctxt -> xpathCtxt -> nsNr ;\n oldNamespaces = ctxt -> xpathCtxt -> namespaces ;\n ctxt -> xpathCtxt -> node = ctxt -> node ;\n ctxt -> xpathCtxt -> namespaces = nsList ;\n ctxt -> xpathCtxt -> nsNr = nsNr ;\n res = xmlXPathCompiledEval ( comp , ctxt -> xpathCtxt ) ;\n if ( res != NULL ) {\n if ( res -> type != XPATH_STRING ) res = xmlXPathConvertString ( res ) ;\n if ( res -> type == XPATH_STRING ) {\n ret = res -> stringval ;\n res -> stringval = NULL ;\n }\n else {\n xsltTransformError ( ctxt , NULL , NULL , \"xpath : string() function didn't return a String\\n\" ) ;\n }\n xmlXPathFreeObject ( res ) ;\n }\n else {\n ctxt -> state = XSLT_STATE_STOPPED ;\n }\n # ifdef WITH_XSLT_DEBUG_TEMPLATES XSLT_TRACE ( ctxt , XSLT_TRACE_TEMPLATES , xsltGenericDebug ( xsltGenericDebugContext , \"xsltEvalXPathString: returns %s\\n\" , ret ) ) ;\n # endif ctxt -> inst = oldInst ;\n ctxt -> node = oldNode ;\n ctxt -> xpathCtxt -> contextSize = oldSize ;\n ctxt -> xpathCtxt -> proximityPosition = oldPos ;\n ctxt -> xpathCtxt -> nsNr = oldNsNr ;\n ctxt -> xpathCtxt -> namespaces = oldNamespaces ;\n return ( ret ) ;\n }", "idx": 1994}
{"hash": 8073241806104522127, "project": "chrome", "size": 48, "label": 0, "functionSource": "TEST_F ( AutocompleteResultTest , SortAndCullWithMatchDups ) {\n TemplateURLData url_data ;\n url_data . SetShortName ( base : : ASCIIToUTF16 ( \"unittest\" ) ) ;\n url_data . SetKeyword ( base : : ASCIIToUTF16 ( \"foo\" ) ) ;\n url_data . SetURL ( \"http://www.foo.com/s?q={\nsearchTerms}\n\" ) ;\n template_url_service_ . get ( ) -> Add ( new TemplateURL ( url_data ) ) ;\n AutocompleteMatch dup_match ;\n dup_match . destination_url = GURL ( \"http://www.foo.com/s?q=foo&oq=dup\" ) ;\n std : : vector < AutocompleteMatch > dups ;\n dups . push_back ( dup_match ) ;\n TestData data [ ] = {\n {\n 0 , 1 , 1300 , true , dups }\n , {\n 1 , 1 , 1200 , true }\n , {\n 2 , 1 , 1100 , true }\n , {\n 3 , 1 , 1000 , true , dups }\n , {\n 4 , 2 , 900 , true }\n , {\n 5 , 1 , 800 , true }\n , }\n ;\n ACMatches matches ;\n PopulateAutocompleteMatches ( data , arraysize ( data ) , & matches ) ;\n matches [ 0 ] . destination_url = GURL ( \"http://www.foo.com/s?q=foo\" ) ;\n matches [ 1 ] . destination_url = GURL ( \"http://www.foo.com/s?q=foo2\" ) ;\n matches [ 2 ] . destination_url = GURL ( \"http://www.foo.com/s?q=foo&oq=f\" ) ;\n matches [ 3 ] . destination_url = GURL ( \"http://www.foo.com/s?q=foo&aqs=0\" ) ;\n matches [ 4 ] . destination_url = GURL ( \"http://www.foo.com/\" ) ;\n matches [ 5 ] . destination_url = GURL ( \"http://www.foo.com/s?q=foo2&oq=f\" ) ;\n AutocompleteInput input ( base : : string16 ( ) , base : : string16 : : npos , std : : string ( ) , GURL ( ) , OmniboxEventProto : : INVALID_SPEC , false , false , false , true , false , TestSchemeClassifier ( ) ) ;\n AutocompleteResult result ;\n result . AppendMatches ( input , matches ) ;\n result . SortAndCull ( input , template_url_service_ . get ( ) ) ;\n ASSERT_EQ ( 3U , result . size ( ) ) ;\n ASSERT_EQ ( 4U , result . match_at ( 0 ) -> duplicate_matches . size ( ) ) ;\n const AutocompleteMatch * first_match = result . match_at ( 0 ) ;\n EXPECT_EQ ( matches [ 2 ] . destination_url , first_match -> duplicate_matches . at ( 1 ) . destination_url ) ;\n EXPECT_EQ ( dup_match . destination_url , first_match -> duplicate_matches . at ( 2 ) . destination_url ) ;\n EXPECT_EQ ( matches [ 3 ] . destination_url , first_match -> duplicate_matches . at ( 3 ) . destination_url ) ;\n ASSERT_EQ ( 1U , result . match_at ( 1 ) -> duplicate_matches . size ( ) ) ;\n EXPECT_EQ ( matches [ 5 ] . destination_url , result . match_at ( 1 ) -> duplicate_matches . at ( 0 ) . destination_url ) ;\n }", "idx": 1995}
{"hash": -2607754285145856562, "project": "debian", "size": 7, "label": 0, "functionSource": "static int write_VD_terminator ( struct archive_write * a ) {\n unsigned char * bp ;\n bp = wb_buffptr ( a ) - 1 ;\n set_VD_bp ( bp , VDT_TERMINATOR , 1 ) ;\n set_unused_field_bp ( bp , 8 , LOGICAL_BLOCK_SIZE ) ;\n return ( wb_consume ( a , LOGICAL_BLOCK_SIZE ) ) ;\n }", "idx": 1996}
{"hash": 355220887711506893, "project": "debian", "size": 3, "label": 0, "functionSource": "Datum icnlikesel ( PG_FUNCTION_ARGS ) {\n PG_RETURN_FLOAT8 ( patternsel ( fcinfo , Pattern_Type_Like_IC , true ) ) ;\n }", "idx": 1997}
{"hash": -7441512654057958783, "project": "chrome", "size": 3, "label": 1, "functionSource": "TEST ( BuildTime , DoesntCrash ) {\n base : : GetBuildTime ( ) ;\n }", "idx": 1998}
{"hash": -7990991774694156606, "project": "debian", "size": 114, "label": 1, "functionSource": "static int vp3_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n Vp3DecodeContext * s = avctx -> priv_data ;\n GetBitContext gb ;\n int i ;\n init_get_bits ( & gb , buf , buf_size * 8 ) ;\n if ( s -> theora && get_bits1 ( & gb ) ) {\n av_log ( avctx , AV_LOG_ERROR , \"Header packet passed to frame decoder, skipping\\n\" ) ;\n return - 1 ;\n }\n s -> keyframe = ! get_bits1 ( & gb ) ;\n if ( ! s -> theora ) skip_bits ( & gb , 1 ) ;\n for ( i = 0 ;\n i < 3 ;\n i ++ ) s -> last_qps [ i ] = s -> qps [ i ] ;\n s -> nqps = 0 ;\n do {\n s -> qps [ s -> nqps ++ ] = get_bits ( & gb , 6 ) ;\n }\n while ( s -> theora >= 0x030200 && s -> nqps < 3 && get_bits1 ( & gb ) ) ;\n for ( i = s -> nqps ;\n i < 3 ;\n i ++ ) s -> qps [ i ] = - 1 ;\n if ( s -> avctx -> debug & FF_DEBUG_PICT_INFO ) av_log ( s -> avctx , AV_LOG_INFO , \" VP3 %sframe #%d: Q index = %d\\n\" , s -> keyframe ? \"key\" : \"\" , avctx -> frame_number + 1 , s -> qps [ 0 ] ) ;\n s -> skip_loop_filter = ! s -> filter_limit_values [ s -> qps [ 0 ] ] || avctx -> skip_loop_filter >= ( s -> keyframe ? AVDISCARD_ALL : AVDISCARD_NONKEY ) ;\n if ( s -> qps [ 0 ] != s -> last_qps [ 0 ] ) init_loop_filter ( s ) ;\n for ( i = 0 ;\n i < s -> nqps ;\n i ++ ) if ( s -> qps [ i ] != s -> last_qps [ i ] || s -> qps [ 0 ] != s -> last_qps [ 0 ] ) init_dequantizer ( s , i ) ;\n if ( avctx -> skip_frame >= AVDISCARD_NONKEY && ! s -> keyframe ) return buf_size ;\n s -> current_frame . reference = 3 ;\n s -> current_frame . pict_type = s -> keyframe ? AV_PICTURE_TYPE_I : AV_PICTURE_TYPE_P ;\n if ( ff_thread_get_buffer ( avctx , & s -> current_frame ) < 0 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n goto error ;\n }\n if ( ! s -> edge_emu_buffer ) s -> edge_emu_buffer = av_malloc ( 9 * FFABS ( s -> current_frame . linesize [ 0 ] ) ) ;\n if ( s -> keyframe ) {\n if ( ! s -> theora ) {\n skip_bits ( & gb , 4 ) ;\n skip_bits ( & gb , 4 ) ;\n if ( s -> version ) {\n s -> version = get_bits ( & gb , 5 ) ;\n if ( avctx -> frame_number == 0 ) av_log ( s -> avctx , AV_LOG_DEBUG , \"VP version: %d\\n\" , s -> version ) ;\n }\n }\n if ( s -> version || s -> theora ) {\n if ( get_bits1 ( & gb ) ) av_log ( s -> avctx , AV_LOG_ERROR , \"Warning, unsupported keyframe coding type?!\\n\" ) ;\n skip_bits ( & gb , 2 ) ;\n }\n }\n else {\n if ( ! s -> golden_frame . data [ 0 ] ) {\n av_log ( s -> avctx , AV_LOG_WARNING , \"vp3: first frame not a keyframe\\n\" ) ;\n s -> golden_frame . reference = 3 ;\n s -> golden_frame . pict_type = AV_PICTURE_TYPE_I ;\n if ( ff_thread_get_buffer ( avctx , & s -> golden_frame ) < 0 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n goto error ;\n }\n s -> last_frame = s -> golden_frame ;\n s -> last_frame . type = FF_BUFFER_TYPE_COPY ;\n ff_thread_report_progress ( & s -> last_frame , INT_MAX , 0 ) ;\n }\n }\n memset ( s -> all_fragments , 0 , s -> fragment_count * sizeof ( Vp3Fragment ) ) ;\n ff_thread_finish_setup ( avctx ) ;\n if ( unpack_superblocks ( s , & gb ) ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"error in unpack_superblocks\\n\" ) ;\n goto error ;\n }\n if ( unpack_modes ( s , & gb ) ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"error in unpack_modes\\n\" ) ;\n goto error ;\n }\n if ( unpack_vectors ( s , & gb ) ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"error in unpack_vectors\\n\" ) ;\n goto error ;\n }\n if ( unpack_block_qpis ( s , & gb ) ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"error in unpack_block_qpis\\n\" ) ;\n goto error ;\n }\n if ( unpack_dct_coeffs ( s , & gb ) ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"error in unpack_dct_coeffs\\n\" ) ;\n goto error ;\n }\n for ( i = 0 ;\n i < 3 ;\n i ++ ) {\n int height = s -> height >> ( i && s -> chroma_y_shift ) ;\n if ( s -> flipped_image ) s -> data_offset [ i ] = 0 ;\n else s -> data_offset [ i ] = ( height - 1 ) * s -> current_frame . linesize [ i ] ;\n }\n s -> last_slice_end = 0 ;\n for ( i = 0 ;\n i < s -> c_superblock_height ;\n i ++ ) render_slice ( s , i ) ;\n for ( i = 0 ;\n i < 3 ;\n i ++ ) {\n int row = ( s -> height >> ( 3 + ( i && s -> chroma_y_shift ) ) ) - 1 ;\n apply_loop_filter ( s , i , row , row + 1 ) ;\n }\n vp3_draw_horiz_band ( s , s -> avctx -> height ) ;\n * got_frame = 1 ;\n * ( AVFrame * ) data = s -> current_frame ;\n if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) update_frames ( avctx ) ;\n return buf_size ;\n error : ff_thread_report_progress ( & s -> current_frame , INT_MAX , 0 ) ;\n if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) avctx -> release_buffer ( avctx , & s -> current_frame ) ;\n return - 1 ;\n }", "idx": 1999}
{"hash": -5697857125570093892, "project": "chrome", "size": 11, "label": 0, "functionSource": "static UBool _isNumericString ( const char * s , int32_t len ) {\n int32_t i ;\n for ( i = 0 ;\n i < len ;\n i ++ ) {\n if ( ! ISNUMERIC ( * ( s + i ) ) ) {\n return FALSE ;\n }\n }\n return TRUE ;\n }", "idx": 2000}
{"hash": -7422764464424760982, "project": "chrome", "size": 20, "label": 0, "functionSource": "TEST_F ( ExtensionServiceSyncTest , GetSyncDataTerminated ) {\n InitializeEmptyExtensionService ( ) ;\n InstallCRX ( data_dir ( ) . AppendASCII ( \"good.crx\" ) , INSTALL_NEW ) ;\n TerminateExtension ( good_crx ) ;\n const Extension * extension = service ( ) -> GetInstalledExtension ( good_crx ) ;\n ASSERT_TRUE ( extension ) ;\n extension_sync_service ( ) -> MergeDataAndStartSyncing ( syncer : : EXTENSIONS , syncer : : SyncDataList ( ) , base : : MakeUnique < syncer : : FakeSyncChangeProcessor > ( ) , base : : MakeUnique < syncer : : SyncErrorFactoryMock > ( ) ) ;\n syncer : : SyncDataList list = extension_sync_service ( ) -> GetAllSyncData ( syncer : : EXTENSIONS ) ;\n ASSERT_EQ ( list . size ( ) , 1U ) ;\n std : : unique_ptr < ExtensionSyncData > data = ExtensionSyncData : : CreateFromSyncData ( list [ 0 ] ) ;\n ASSERT_TRUE ( data . get ( ) ) ;\n EXPECT_EQ ( extension -> id ( ) , data -> id ( ) ) ;\n EXPECT_FALSE ( data -> uninstalled ( ) ) ;\n EXPECT_EQ ( service ( ) -> IsExtensionEnabled ( good_crx ) , data -> enabled ( ) ) ;\n EXPECT_EQ ( extensions : : util : : IsIncognitoEnabled ( good_crx , profile ( ) ) , data -> incognito_enabled ( ) ) ;\n EXPECT_EQ ( ExtensionSyncData : : BOOLEAN_UNSET , data -> all_urls_enabled ( ) ) ;\n EXPECT_EQ ( data -> version ( ) , * extension -> version ( ) ) ;\n EXPECT_EQ ( extensions : : ManifestURL : : GetUpdateURL ( extension ) , data -> update_url ( ) ) ;\n EXPECT_EQ ( extension -> name ( ) , data -> name ( ) ) ;\n }", "idx": 2001}
{"hash": 3761858035663259067, "project": "chrome", "size": 16, "label": 0, "functionSource": "static UBool action_shapeArabic ( UBiDiTransform * pTransform , UErrorCode * pErrorCode ) {\n if ( ( pTransform -> letters | pTransform -> digits ) == 0 ) {\n return FALSE ;\n }\n if ( pTransform -> pActiveScheme -> lettersDir == pTransform -> pActiveScheme -> digitsDir ) {\n doShape ( pTransform , pTransform -> letters | pTransform -> digits | pTransform -> pActiveScheme -> lettersDir , pErrorCode ) ;\n }\n else {\n doShape ( pTransform , pTransform -> digits | pTransform -> pActiveScheme -> digitsDir , pErrorCode ) ;\n if ( U_SUCCESS ( * pErrorCode ) ) {\n updateSrc ( pTransform , pTransform -> dest , * pTransform -> pDestLength , * pTransform -> pDestLength , pErrorCode ) ;\n doShape ( pTransform , pTransform -> letters | pTransform -> pActiveScheme -> lettersDir , pErrorCode ) ;\n }\n }\n return TRUE ;\n }", "idx": 2002}
{"hash": 6343276067273564310, "project": "debian", "size": 7, "label": 0, "functionSource": "afs_int32 SPR_ListMax ( struct rx_call * call , afs_int32 * uid , afs_int32 * gid ) {\n afs_int32 code ;\n code = listMax ( call , uid , gid ) ;\n osi_auditU ( call , PTS_LstMaxEvent , code , AUD_END ) ;\n ViceLog ( 125 , ( \"PTS_ListMax: code %d\\n\" , code ) ) ;\n return code ;\n }", "idx": 2003}
{"hash": 6298409723927571872, "project": "chrome", "size": 4, "label": 0, "functionSource": "static inline bool is_one_of ( const hb_glyph_info_t & info , unsigned int flags ) {\n if ( _hb_glyph_info_ligated ( & info ) ) return false ;\n return ! ! ( FLAG_SAFE ( info . myanmar_category ( ) ) & flags ) ;\n }", "idx": 2004}
{"hash": 3887066622454352196, "project": "chrome", "size": 29, "label": 1, "functionSource": "static int64_t rd_pick_intra_sbuv_mode ( VP9_COMP * cpi , MACROBLOCK * x , PICK_MODE_CONTEXT * ctx , int * rate , int * rate_tokenonly , int64_t * distortion , int * skippable , BLOCK_SIZE bsize , TX_SIZE max_tx_size ) {\n MACROBLOCKD * xd = & x -> e_mbd ;\n PREDICTION_MODE mode ;\n PREDICTION_MODE mode_selected = DC_PRED ;\n int64_t best_rd = INT64_MAX , this_rd ;\n int this_rate_tokenonly , this_rate , s ;\n int64_t this_distortion , this_sse ;\n for ( mode = DC_PRED ;\n mode <= TM_PRED ;\n ++ mode ) {\n if ( ! ( cpi -> sf . intra_uv_mode_mask [ max_tx_size ] & ( 1 << mode ) ) ) continue ;\n xd -> mi [ 0 ] -> mbmi . uv_mode = mode ;\n super_block_uvrd ( cpi , x , & this_rate_tokenonly , & this_distortion , & s , & this_sse , bsize , best_rd ) ;\n if ( this_rate_tokenonly == INT_MAX ) continue ;\n this_rate = this_rate_tokenonly + cpi -> intra_uv_mode_cost [ cpi -> common . frame_type ] [ mode ] ;\n this_rd = RDCOST ( x -> rdmult , x -> rddiv , this_rate , this_distortion ) ;\n if ( this_rd < best_rd ) {\n mode_selected = mode ;\n best_rd = this_rd ;\n * rate = this_rate ;\n * rate_tokenonly = this_rate_tokenonly ;\n * distortion = this_distortion ;\n * skippable = s ;\n if ( ! x -> select_tx_size ) swap_block_ptr ( x , ctx , 2 , 0 , 1 , MAX_MB_PLANE ) ;\n }\n }\n xd -> mi [ 0 ] -> mbmi . uv_mode = mode_selected ;\n return best_rd ;\n }", "idx": 2005}
{"hash": -5280794106681745199, "project": "debian", "size": 16, "label": 0, "functionSource": "static gboolean gst_asf_demux_element_send_event ( GstElement * element , GstEvent * event ) {\n GstASFDemux * demux = GST_ASF_DEMUX ( element ) ;\n gint i ;\n GST_DEBUG ( \"handling element event of type %s\" , GST_EVENT_TYPE_NAME ( event ) ) ;\n for ( i = 0 ;\n i < demux -> num_streams ;\n ++ i ) {\n gst_event_ref ( event ) ;\n if ( gst_asf_demux_handle_src_event ( demux -> stream [ i ] . pad , GST_OBJECT_CAST ( element ) , event ) ) {\n gst_event_unref ( event ) ;\n return TRUE ;\n }\n }\n gst_event_unref ( event ) ;\n return FALSE ;\n }", "idx": 2006}
{"hash": -2908211205972632000, "project": "debian", "size": 6, "label": 0, "functionSource": "static void cmd_window_move_dleft ( void ) {\n MAIN_WINDOW_REC * rec ;\n rec = mainwindows_find_left ( active_mainwin , FALSE ) ;\n if ( rec == NULL ) rec = mainwindows_find_left ( active_mainwin , TRUE ) ;\n if ( rec != NULL ) window_reparent ( active_win , rec ) ;\n }", "idx": 2007}
{"hash": -8199454075838226273, "project": "debian", "size": 121, "label": 0, "functionSource": "static gint dissect_amf0_value_type ( tvbuff_t * tvb , gint offset , proto_tree * tree , gboolean * amf3_encoding , proto_item * parent_ti ) {\n guint8 iObjType ;\n proto_item * ti ;\n proto_tree * val_tree ;\n gint iValueOffset = offset ;\n guint32 iIntegerValue ;\n double iDoubleValue ;\n gboolean iBooleanValue ;\n guint iStringLength ;\n gchar * iStringValue ;\n guint iArrayLength ;\n guint i ;\n nstime_t t ;\n gint64 iInteger64Value ;\n guint count ;\n iObjType = tvb_get_guint8 ( tvb , offset ) ;\n if ( parent_ti != NULL ) proto_item_append_text ( parent_ti , \" %s\" , val_to_str_const ( iObjType , amf0_type_vals , \"Unknown\" ) ) ;\n switch ( iObjType ) {\n case AMF0_OBJECT : ti = proto_tree_add_item ( tree , hf_amf_object , tvb , offset , - 1 , ENC_NA ) ;\n val_tree = proto_item_add_subtree ( ti , ett_amf_value ) ;\n break ;\n case AMF0_ECMA_ARRAY : ti = proto_tree_add_item ( tree , hf_amf_ecmaarray , tvb , offset , - 1 , ENC_NA ) ;\n val_tree = proto_item_add_subtree ( ti , ett_amf_value ) ;\n break ;\n case AMF0_STRICT_ARRAY : ti = proto_tree_add_item ( tree , hf_amf_strictarray , tvb , offset , - 1 , ENC_NA ) ;\n val_tree = proto_item_add_subtree ( ti , ett_amf_value ) ;\n break ;\n default : val_tree = proto_tree_add_subtree ( tree , tvb , offset , - 1 , ett_amf_value , & ti , val_to_str_const ( iObjType , amf0_type_vals , \"Unknown\" ) ) ;\n break ;\n }\n proto_tree_add_uint ( val_tree , hf_amf_amf0_type , tvb , iValueOffset , 1 , iObjType ) ;\n iValueOffset ++ ;\n switch ( iObjType ) {\n case AMF0_NUMBER : iDoubleValue = tvb_get_ntohieee_double ( tvb , iValueOffset ) ;\n proto_tree_add_double ( val_tree , hf_amf_number , tvb , iValueOffset , 8 , iDoubleValue ) ;\n iValueOffset += 8 ;\n proto_item_append_text ( ti , \" %.\" G_STRINGIFY ( DBL_DIG ) \"g\" , iDoubleValue ) ;\n if ( parent_ti != NULL ) proto_item_append_text ( parent_ti , \" %.\" G_STRINGIFY ( DBL_DIG ) \"g\" , iDoubleValue ) ;\n break ;\n case AMF0_BOOLEAN : iBooleanValue = tvb_get_guint8 ( tvb , iValueOffset ) ;\n proto_tree_add_boolean ( val_tree , hf_amf_boolean , tvb , iValueOffset , 1 , iBooleanValue ) ;\n iValueOffset += 1 ;\n proto_item_append_text ( ti , iBooleanValue ? \" true\" : \" false\" ) ;\n if ( parent_ti != NULL ) proto_item_append_text ( parent_ti , iBooleanValue ? \" true\" : \" false\" ) ;\n break ;\n case AMF0_STRING : iStringLength = tvb_get_ntohs ( tvb , iValueOffset ) ;\n proto_tree_add_uint ( val_tree , hf_amf_stringlength , tvb , iValueOffset , 2 , iStringLength ) ;\n iValueOffset += 2 ;\n iStringValue = tvb_get_string_enc ( wmem_packet_scope ( ) , tvb , iValueOffset , iStringLength , ENC_UTF_8 | ENC_NA ) ;\n if ( iStringLength != 0 ) proto_tree_add_string ( val_tree , hf_amf_string , tvb , iValueOffset , iStringLength , iStringValue ) ;\n iValueOffset += iStringLength ;\n proto_item_append_text ( ti , \" '%s'\" , iStringValue ) ;\n if ( parent_ti != NULL ) proto_item_append_text ( parent_ti , \" '%s'\" , iStringValue ) ;\n break ;\n case AMF0_OBJECT : iValueOffset = dissect_amf0_property_list ( tvb , iValueOffset , val_tree , & count , amf3_encoding ) ;\n proto_item_append_text ( ti , \" (%u items)\" , count ) ;\n break ;\n case AMF0_NULL : case AMF0_UNDEFINED : break ;\n case AMF0_REFERENCE : iIntegerValue = tvb_get_ntohs ( tvb , iValueOffset ) ;\n proto_tree_add_uint ( val_tree , hf_amf_object_reference , tvb , iValueOffset , 2 , iIntegerValue ) ;\n iValueOffset += 2 ;\n proto_item_append_text ( ti , \" %d\" , iIntegerValue ) ;\n break ;\n case AMF0_ECMA_ARRAY : iArrayLength = tvb_get_ntohl ( tvb , iValueOffset ) ;\n proto_tree_add_uint ( val_tree , hf_amf_arraylength , tvb , iValueOffset , 4 , iArrayLength ) ;\n iValueOffset += 4 ;\n iValueOffset = dissect_amf0_property_list ( tvb , iValueOffset , val_tree , & count , amf3_encoding ) ;\n proto_item_append_text ( ti , \" (%u items)\" , count ) ;\n break ;\n case AMF0_END_OF_OBJECT : proto_tree_add_item ( tree , hf_amf_end_of_object_marker , tvb , iValueOffset , 3 , ENC_NA ) ;\n iValueOffset += 3 ;\n break ;\n case AMF0_STRICT_ARRAY : iArrayLength = tvb_get_ntohl ( tvb , iValueOffset ) ;\n proto_tree_add_uint ( val_tree , hf_amf_arraylength , tvb , iValueOffset , 4 , iArrayLength ) ;\n iValueOffset += 4 ;\n for ( i = 0 ;\n i < iArrayLength ;\n i ++ ) iValueOffset = dissect_amf0_value_type ( tvb , iValueOffset , val_tree , amf3_encoding , NULL ) ;\n proto_item_append_text ( ti , \" (%u items)\" , iArrayLength ) ;\n break ;\n case AMF0_DATE : iDoubleValue = tvb_get_ntohieee_double ( tvb , iValueOffset ) ;\n t . secs = ( time_t ) ( iDoubleValue / 1000 ) ;\n t . nsecs = ( int ) ( ( iDoubleValue - 1000 * ( double ) t . secs ) * 1000000 ) ;\n proto_tree_add_time ( val_tree , hf_amf_date , tvb , iValueOffset , 8 , & t ) ;\n iValueOffset += 8 ;\n proto_item_append_text ( ti , \" %s\" , abs_time_to_str ( wmem_packet_scope ( ) , & t , ABSOLUTE_TIME_LOCAL , TRUE ) ) ;\n if ( parent_ti != NULL ) proto_item_append_text ( parent_ti , \" %s\" , abs_time_to_str ( wmem_packet_scope ( ) , & t , ABSOLUTE_TIME_LOCAL , TRUE ) ) ;\n iValueOffset += 2 ;\n break ;\n case AMF0_LONG_STRING : case AMF0_XML : iStringLength = tvb_get_ntohl ( tvb , iValueOffset ) ;\n proto_tree_add_uint ( val_tree , hf_amf_stringlength , tvb , iValueOffset , 2 , iStringLength ) ;\n iValueOffset += 4 ;\n iStringValue = tvb_get_string_enc ( wmem_packet_scope ( ) , tvb , iValueOffset , iStringLength , ENC_UTF_8 | ENC_NA ) ;\n if ( iStringLength != 0 ) proto_tree_add_string ( val_tree , ( iObjType == AMF0_XML ) ? hf_amf_xml_doc : hf_amf_longstring , tvb , iValueOffset , iStringLength , iStringValue ) ;\n iValueOffset += iStringLength ;\n proto_item_append_text ( ti , \" '%s'\" , iStringValue ) ;\n if ( parent_ti != NULL ) proto_item_append_text ( parent_ti , \" '%s'\" , iStringValue ) ;\n break ;\n case AMF0_UNSUPPORTED : break ;\n case AMF0_TYPED_OBJECT : iStringLength = tvb_get_ntohs ( tvb , iValueOffset ) ;\n proto_tree_add_uint ( val_tree , hf_amf_stringlength , tvb , iValueOffset , 2 , iStringLength ) ;\n iValueOffset += 2 ;\n iStringValue = tvb_get_string_enc ( wmem_packet_scope ( ) , tvb , iValueOffset , iStringLength , ENC_UTF_8 | ENC_NA ) ;\n proto_tree_add_string ( val_tree , hf_amf_string , tvb , iValueOffset , iStringLength , iStringValue ) ;\n iValueOffset += iStringLength ;\n iValueOffset = dissect_amf0_property_list ( tvb , iValueOffset , val_tree , & count , amf3_encoding ) ;\n break ;\n case AMF0_AMF3_MARKER : * amf3_encoding = TRUE ;\n break ;\n case AMF0_INT64 : iInteger64Value = tvb_get_ntoh64 ( tvb , iValueOffset ) ;\n proto_tree_add_int64 ( val_tree , hf_amf_int64 , tvb , iValueOffset , 8 , iInteger64Value ) ;\n iValueOffset += 8 ;\n proto_item_append_text ( ti , \" %\" G_GINT64_MODIFIER \"d\" , iInteger64Value ) ;\n if ( parent_ti != NULL ) proto_item_append_text ( parent_ti , \" %\" G_GINT64_MODIFIER \"d\" , iInteger64Value ) ;\n break ;\n default : iValueOffset = tvb_reported_length ( tvb ) ;\n break ;\n }\n proto_item_set_end ( ti , tvb , iValueOffset ) ;\n return iValueOffset ;\n }", "idx": 2008}
{"hash": -5780611388839125875, "project": "chrome", "size": 4, "label": 0, "functionSource": "int * __xmlSaveNoEmptyTags ( void ) {\n if ( IS_MAIN_THREAD ) return ( & xmlSaveNoEmptyTags ) ;\n else return ( & xmlGetGlobalState ( ) -> xmlSaveNoEmptyTags ) ;\n }", "idx": 2009}
{"hash": 7295169435648525618, "project": "debian", "size": 12, "label": 0, "functionSource": "static int mdb_get_nextid ( MDB_cursor * mci , ID * cursor ) {\n MDB_val key ;\n ID id ;\n int rc ;\n id = * cursor + 1 ;\n key . mv_data = & id ;\n key . mv_size = sizeof ( ID ) ;\n rc = mdb_cursor_get ( mci , & key , NULL , MDB_SET_RANGE ) ;\n if ( rc ) return rc ;\n memcpy ( cursor , key . mv_data , sizeof ( ID ) ) ;\n return 0 ;\n }", "idx": 2010}
{"hash": 2335222688263906532, "project": "debian", "size": 74, "label": 0, "functionSource": "static int rv34_decode_mv ( RV34DecContext * r , int block_type ) {\n MpegEncContext * s = & r -> s ;\n GetBitContext * gb = & s -> gb ;\n int i , j , k , l ;\n int mv_pos = s -> mb_x * 2 + s -> mb_y * 2 * s -> b8_stride ;\n int next_bt ;\n memset ( r -> dmv , 0 , sizeof ( r -> dmv ) ) ;\n for ( i = 0 ;\n i < num_mvs [ block_type ] ;\n i ++ ) {\n r -> dmv [ i ] [ 0 ] = svq3_get_se_golomb ( gb ) ;\n r -> dmv [ i ] [ 1 ] = svq3_get_se_golomb ( gb ) ;\n }\n switch ( block_type ) {\n case RV34_MB_TYPE_INTRA : case RV34_MB_TYPE_INTRA16x16 : ZERO8x2 ( s -> current_picture_ptr -> motion_val [ 0 ] [ s -> mb_x * 2 + s -> mb_y * 2 * s -> b8_stride ] , s -> b8_stride ) ;\n return 0 ;\n case RV34_MB_SKIP : if ( s -> pict_type == AV_PICTURE_TYPE_P ) {\n ZERO8x2 ( s -> current_picture_ptr -> motion_val [ 0 ] [ s -> mb_x * 2 + s -> mb_y * 2 * s -> b8_stride ] , s -> b8_stride ) ;\n rv34_mc_1mv ( r , block_type , 0 , 0 , 0 , 2 , 2 , 0 ) ;\n break ;\n }\n case RV34_MB_B_DIRECT : if ( HAVE_THREADS && ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) ff_thread_await_progress ( & s -> next_picture_ptr -> tf , FFMAX ( 0 , s -> mb_y - 1 ) , 0 ) ;\n next_bt = s -> next_picture_ptr -> mb_type [ s -> mb_x + s -> mb_y * s -> mb_stride ] ;\n if ( IS_INTRA ( next_bt ) || IS_SKIP ( next_bt ) ) {\n ZERO8x2 ( s -> current_picture_ptr -> motion_val [ 0 ] [ s -> mb_x * 2 + s -> mb_y * 2 * s -> b8_stride ] , s -> b8_stride ) ;\n ZERO8x2 ( s -> current_picture_ptr -> motion_val [ 1 ] [ s -> mb_x * 2 + s -> mb_y * 2 * s -> b8_stride ] , s -> b8_stride ) ;\n }\n else for ( j = 0 ;\n j < 2 ;\n j ++ ) for ( i = 0 ;\n i < 2 ;\n i ++ ) for ( k = 0 ;\n k < 2 ;\n k ++ ) for ( l = 0 ;\n l < 2 ;\n l ++ ) s -> current_picture_ptr -> motion_val [ l ] [ mv_pos + i + j * s -> b8_stride ] [ k ] = calc_add_mv ( r , l , s -> next_picture_ptr -> motion_val [ 0 ] [ mv_pos + i + j * s -> b8_stride ] [ k ] ) ;\n if ( ! ( IS_16X8 ( next_bt ) || IS_8X16 ( next_bt ) || IS_8X8 ( next_bt ) ) ) rv34_mc_2mv ( r , block_type ) ;\n else rv34_mc_2mv_skip ( r ) ;\n ZERO8x2 ( s -> current_picture_ptr -> motion_val [ 0 ] [ s -> mb_x * 2 + s -> mb_y * 2 * s -> b8_stride ] , s -> b8_stride ) ;\n break ;\n case RV34_MB_P_16x16 : case RV34_MB_P_MIX16x16 : rv34_pred_mv ( r , block_type , 0 , 0 ) ;\n rv34_mc_1mv ( r , block_type , 0 , 0 , 0 , 2 , 2 , 0 ) ;\n break ;\n case RV34_MB_B_FORWARD : case RV34_MB_B_BACKWARD : r -> dmv [ 1 ] [ 0 ] = r -> dmv [ 0 ] [ 0 ] ;\n r -> dmv [ 1 ] [ 1 ] = r -> dmv [ 0 ] [ 1 ] ;\n if ( r -> rv30 ) rv34_pred_mv_rv3 ( r , block_type , block_type == RV34_MB_B_BACKWARD ) ;\n else rv34_pred_mv_b ( r , block_type , block_type == RV34_MB_B_BACKWARD ) ;\n rv34_mc_1mv ( r , block_type , 0 , 0 , 0 , 2 , 2 , block_type == RV34_MB_B_BACKWARD ) ;\n break ;\n case RV34_MB_P_16x8 : case RV34_MB_P_8x16 : rv34_pred_mv ( r , block_type , 0 , 0 ) ;\n rv34_pred_mv ( r , block_type , 1 + ( block_type == RV34_MB_P_16x8 ) , 1 ) ;\n if ( block_type == RV34_MB_P_16x8 ) {\n rv34_mc_1mv ( r , block_type , 0 , 0 , 0 , 2 , 1 , 0 ) ;\n rv34_mc_1mv ( r , block_type , 0 , 8 , s -> b8_stride , 2 , 1 , 0 ) ;\n }\n if ( block_type == RV34_MB_P_8x16 ) {\n rv34_mc_1mv ( r , block_type , 0 , 0 , 0 , 1 , 2 , 0 ) ;\n rv34_mc_1mv ( r , block_type , 8 , 0 , 1 , 1 , 2 , 0 ) ;\n }\n break ;\n case RV34_MB_B_BIDIR : rv34_pred_mv_b ( r , block_type , 0 ) ;\n rv34_pred_mv_b ( r , block_type , 1 ) ;\n rv34_mc_2mv ( r , block_type ) ;\n break ;\n case RV34_MB_P_8x8 : for ( i = 0 ;\n i < 4 ;\n i ++ ) {\n rv34_pred_mv ( r , block_type , i , i ) ;\n rv34_mc_1mv ( r , block_type , ( i & 1 ) << 3 , ( i & 2 ) << 2 , ( i & 1 ) + ( i >> 1 ) * s -> b8_stride , 1 , 1 , 0 ) ;\n }\n break ;\n }\n return 0 ;\n }", "idx": 2011}
{"hash": 7072059544915633710, "project": "chrome", "size": 404, "label": 1, "functionSource": "static void _LMBCSOpen ## n ( UConverter * _this , UConverterLoadArgs * pArgs , UErrorCode * err ) \\ {\n _LMBCSOpenWorker ( _this , pArgs , err , n ) ;\n }\n static void _LMBCSOpenWorker ( UConverter * _this , UConverterLoadArgs * pArgs , UErrorCode * err , ulmbcs_byte_t OptGroup ) {\n UConverterDataLMBCS * extraInfo = _this -> extraInfo = ( UConverterDataLMBCS * ) uprv_malloc ( sizeof ( UConverterDataLMBCS ) ) ;\n if ( extraInfo != NULL ) {\n UConverterNamePieces stackPieces ;\n UConverterLoadArgs stackArgs = {\n ( int32_t ) sizeof ( UConverterLoadArgs ) }\n ;\n ulmbcs_byte_t i ;\n uprv_memset ( extraInfo , 0 , sizeof ( UConverterDataLMBCS ) ) ;\n stackArgs . onlyTestIsLoadable = pArgs -> onlyTestIsLoadable ;\n for ( i = 0 ;\n i <= ULMBCS_GRP_LAST && U_SUCCESS ( * err ) ;\n i ++ ) {\n if ( OptGroupByteToCPName [ i ] != NULL ) {\n extraInfo -> OptGrpConverter [ i ] = ucnv_loadSharedData ( OptGroupByteToCPName [ i ] , & stackPieces , & stackArgs , err ) ;\n }\n }\n if ( U_FAILURE ( * err ) || pArgs -> onlyTestIsLoadable ) {\n _LMBCSClose ( _this ) ;\n return ;\n }\n extraInfo -> OptGroup = OptGroup ;\n extraInfo -> localeConverterIndex = FindLMBCSLocale ( pArgs -> locale ) ;\n }\n else {\n * err = U_MEMORY_ALLOCATION_ERROR ;\n }\n }\n static void _LMBCSClose ( UConverter * _this ) {\n if ( _this -> extraInfo != NULL ) {\n ulmbcs_byte_t Ix ;\n UConverterDataLMBCS * extraInfo = ( UConverterDataLMBCS * ) _this -> extraInfo ;\n for ( Ix = 0 ;\n Ix <= ULMBCS_GRP_LAST ;\n Ix ++ ) {\n if ( extraInfo -> OptGrpConverter [ Ix ] != NULL ) ucnv_unloadSharedDataIfReady ( extraInfo -> OptGrpConverter [ Ix ] ) ;\n }\n if ( ! _this -> isExtraLocal ) {\n uprv_free ( _this -> extraInfo ) ;\n _this -> extraInfo = NULL ;\n }\n }\n }\n typedef struct LMBCSClone {\n UConverter cnv ;\n UConverterDataLMBCS lmbcs ;\n }\n LMBCSClone ;\n static UConverter * _LMBCSSafeClone ( const UConverter * cnv , void * stackBuffer , int32_t * pBufferSize , UErrorCode * status ) {\n LMBCSClone * newLMBCS ;\n UConverterDataLMBCS * extraInfo ;\n int32_t i ;\n if ( * pBufferSize <= 0 ) {\n * pBufferSize = ( int32_t ) sizeof ( LMBCSClone ) ;\n return NULL ;\n }\n extraInfo = ( UConverterDataLMBCS * ) cnv -> extraInfo ;\n newLMBCS = ( LMBCSClone * ) stackBuffer ;\n uprv_memcpy ( & newLMBCS -> lmbcs , extraInfo , sizeof ( UConverterDataLMBCS ) ) ;\n for ( i = 0 ;\n i <= ULMBCS_GRP_LAST ;\n ++ i ) {\n if ( extraInfo -> OptGrpConverter [ i ] != NULL ) {\n ucnv_incrementRefCount ( extraInfo -> OptGrpConverter [ i ] ) ;\n }\n }\n newLMBCS -> cnv . extraInfo = & newLMBCS -> lmbcs ;\n newLMBCS -> cnv . isExtraLocal = TRUE ;\n return & newLMBCS -> cnv ;\n }\n static size_t LMBCSConversionWorker ( UConverterDataLMBCS * extraInfo , ulmbcs_byte_t group , ulmbcs_byte_t * pStartLMBCS , UChar * pUniChar , ulmbcs_byte_t * lastConverterIndex , UBool * groups_tried ) {\n ulmbcs_byte_t * pLMBCS = pStartLMBCS ;\n UConverterSharedData * xcnv = extraInfo -> OptGrpConverter [ group ] ;\n int bytesConverted ;\n uint32_t value ;\n ulmbcs_byte_t firstByte ;\n U_ASSERT ( xcnv ) ;\n U_ASSERT ( group < ULMBCS_GRP_UNICODE ) ;\n bytesConverted = ucnv_MBCSFromUChar32 ( xcnv , * pUniChar , & value , FALSE ) ;\n if ( bytesConverted > 0 ) {\n firstByte = ( ulmbcs_byte_t ) ( value >> ( ( bytesConverted - 1 ) * 8 ) ) ;\n }\n else {\n groups_tried [ group ] = TRUE ;\n return 0 ;\n }\n * lastConverterIndex = group ;\n U_ASSERT ( ( firstByte <= ULMBCS_C0END ) || ( firstByte >= ULMBCS_C1START ) || ( group == ULMBCS_GRP_EXCEPT ) ) ;\n if ( group != ULMBCS_GRP_EXCEPT && extraInfo -> OptGroup != group ) {\n * pLMBCS ++ = group ;\n if ( bytesConverted == 1 && group >= ULMBCS_DOUBLEOPTGROUP_START ) {\n * pLMBCS ++ = group ;\n }\n }\n if ( bytesConverted == 1 && firstByte < 0x20 ) return 0 ;\n switch ( bytesConverted ) {\n case 4 : * pLMBCS ++ = ( ulmbcs_byte_t ) ( value >> 24 ) ;\n U_FALLTHROUGH ;\n case 3 : * pLMBCS ++ = ( ulmbcs_byte_t ) ( value >> 16 ) ;\n U_FALLTHROUGH ;\n case 2 : * pLMBCS ++ = ( ulmbcs_byte_t ) ( value >> 8 ) ;\n U_FALLTHROUGH ;\n case 1 : * pLMBCS ++ = ( ulmbcs_byte_t ) value ;\n U_FALLTHROUGH ;\n default : break ;\n }\n return ( pLMBCS - pStartLMBCS ) ;\n }\n static size_t LMBCSConvertUni ( ulmbcs_byte_t * pLMBCS , UChar uniChar ) {\n uint8_t LowCh = ( uint8_t ) ( uniChar & 0x00FF ) ;\n uint8_t HighCh = ( uint8_t ) ( uniChar >> 8 ) ;\n * pLMBCS ++ = ULMBCS_GRP_UNICODE ;\n if ( LowCh == 0 ) {\n * pLMBCS ++ = ULMBCS_UNICOMPATZERO ;\n * pLMBCS ++ = HighCh ;\n }\n else {\n * pLMBCS ++ = HighCh ;\n * pLMBCS ++ = LowCh ;\n }\n return ULMBCS_UNICODE_SIZE ;\n }\n static void _LMBCSFromUnicode ( UConverterFromUnicodeArgs * args , UErrorCode * err ) {\n ulmbcs_byte_t lastConverterIndex = 0 ;\n UChar uniChar ;\n ulmbcs_byte_t LMBCS [ ULMBCS_CHARSIZE_MAX ] ;\n ulmbcs_byte_t * pLMBCS ;\n int32_t bytes_written ;\n UBool groups_tried [ ULMBCS_GRP_LAST + 1 ] ;\n UConverterDataLMBCS * extraInfo = ( UConverterDataLMBCS * ) args -> converter -> extraInfo ;\n int sourceIndex = 0 ;\n ulmbcs_byte_t OldConverterIndex = 0 ;\n while ( args -> source < args -> sourceLimit && ! U_FAILURE ( * err ) ) {\n OldConverterIndex = extraInfo -> localeConverterIndex ;\n if ( args -> target >= args -> targetLimit ) {\n * err = U_BUFFER_OVERFLOW_ERROR ;\n break ;\n }\n uniChar = * ( args -> source ) ;\n bytes_written = 0 ;\n pLMBCS = LMBCS ;\n if ( ( uniChar >= 0x80 ) && ( uniChar <= 0xff ) && ( uniChar != 0xB1 ) && ( uniChar != 0xD7 ) && ( uniChar != 0xF7 ) && ( uniChar != 0xB0 ) && ( uniChar != 0xB4 ) && ( uniChar != 0xB6 ) && ( uniChar != 0xA7 ) && ( uniChar != 0xA8 ) ) {\n extraInfo -> localeConverterIndex = ULMBCS_GRP_L1 ;\n }\n if ( ( ( uniChar > ULMBCS_C0END ) && ( uniChar < ULMBCS_C1START ) ) || uniChar == 0 || uniChar == ULMBCS_HT || uniChar == ULMBCS_CR || uniChar == ULMBCS_LF || uniChar == ULMBCS_123SYSTEMRANGE ) {\n * pLMBCS ++ = ( ulmbcs_byte_t ) uniChar ;\n bytes_written = 1 ;\n }\n if ( ! bytes_written ) {\n ulmbcs_byte_t group = FindLMBCSUniRange ( uniChar ) ;\n if ( group == ULMBCS_GRP_UNICODE ) {\n pLMBCS += LMBCSConvertUni ( pLMBCS , uniChar ) ;\n bytes_written = ( int32_t ) ( pLMBCS - LMBCS ) ;\n }\n else if ( group == ULMBCS_GRP_CTRL ) {\n if ( uniChar <= ULMBCS_C0END ) {\n * pLMBCS ++ = ULMBCS_GRP_CTRL ;\n * pLMBCS ++ = ( ulmbcs_byte_t ) ( ULMBCS_CTRLOFFSET + uniChar ) ;\n }\n else if ( uniChar >= ULMBCS_C1START && uniChar <= ULMBCS_C1START + ULMBCS_CTRLOFFSET ) {\n * pLMBCS ++ = ULMBCS_GRP_CTRL ;\n * pLMBCS ++ = ( ulmbcs_byte_t ) ( uniChar & 0x00FF ) ;\n }\n bytes_written = ( int32_t ) ( pLMBCS - LMBCS ) ;\n }\n else if ( group < ULMBCS_GRP_UNICODE ) {\n bytes_written = ( int32_t ) LMBCSConversionWorker ( extraInfo , group , pLMBCS , & uniChar , & lastConverterIndex , groups_tried ) ;\n }\n if ( ! bytes_written ) {\n uprv_memset ( groups_tried , 0 , sizeof ( groups_tried ) ) ;\n if ( ( extraInfo -> OptGroup != 1 ) && ( ULMBCS_AMBIGUOUS_MATCH ( group , extraInfo -> OptGroup ) ) ) {\n if ( extraInfo -> localeConverterIndex < ULMBCS_DOUBLEOPTGROUP_START ) {\n bytes_written = LMBCSConversionWorker ( extraInfo , ULMBCS_GRP_L1 , pLMBCS , & uniChar , & lastConverterIndex , groups_tried ) ;\n if ( ! bytes_written ) {\n bytes_written = LMBCSConversionWorker ( extraInfo , ULMBCS_GRP_EXCEPT , pLMBCS , & uniChar , & lastConverterIndex , groups_tried ) ;\n }\n if ( ! bytes_written ) {\n bytes_written = LMBCSConversionWorker ( extraInfo , extraInfo -> localeConverterIndex , pLMBCS , & uniChar , & lastConverterIndex , groups_tried ) ;\n }\n }\n else {\n bytes_written = LMBCSConversionWorker ( extraInfo , extraInfo -> localeConverterIndex , pLMBCS , & uniChar , & lastConverterIndex , groups_tried ) ;\n }\n }\n if ( ! bytes_written && ( extraInfo -> localeConverterIndex ) && ( ULMBCS_AMBIGUOUS_MATCH ( group , extraInfo -> localeConverterIndex ) ) ) {\n bytes_written = ( int32_t ) LMBCSConversionWorker ( extraInfo , extraInfo -> localeConverterIndex , pLMBCS , & uniChar , & lastConverterIndex , groups_tried ) ;\n }\n if ( ! bytes_written && ( lastConverterIndex ) && ( ULMBCS_AMBIGUOUS_MATCH ( group , lastConverterIndex ) ) ) {\n bytes_written = ( int32_t ) LMBCSConversionWorker ( extraInfo , lastConverterIndex , pLMBCS , & uniChar , & lastConverterIndex , groups_tried ) ;\n }\n if ( ! bytes_written ) {\n ulmbcs_byte_t grp_start ;\n ulmbcs_byte_t grp_end ;\n ulmbcs_byte_t grp_ix ;\n grp_start = ( ulmbcs_byte_t ) ( ( group == ULMBCS_AMBIGUOUS_MBCS ) ? ULMBCS_DOUBLEOPTGROUP_START : ULMBCS_GRP_L1 ) ;\n grp_end = ( ulmbcs_byte_t ) ( ( group == ULMBCS_AMBIGUOUS_MBCS ) ? ULMBCS_GRP_LAST : ULMBCS_GRP_TH ) ;\n if ( group == ULMBCS_AMBIGUOUS_ALL ) {\n grp_start = ULMBCS_GRP_L1 ;\n grp_end = ULMBCS_GRP_LAST ;\n }\n for ( grp_ix = grp_start ;\n grp_ix <= grp_end && ! bytes_written ;\n grp_ix ++ ) {\n if ( extraInfo -> OptGrpConverter [ grp_ix ] && ! groups_tried [ grp_ix ] ) {\n bytes_written = ( int32_t ) LMBCSConversionWorker ( extraInfo , grp_ix , pLMBCS , & uniChar , & lastConverterIndex , groups_tried ) ;\n }\n }\n if ( ! bytes_written && grp_start == ULMBCS_GRP_L1 ) {\n bytes_written = ( int32_t ) LMBCSConversionWorker ( extraInfo , ULMBCS_GRP_EXCEPT , pLMBCS , & uniChar , & lastConverterIndex , groups_tried ) ;\n }\n }\n if ( ! bytes_written ) {\n pLMBCS += LMBCSConvertUni ( pLMBCS , uniChar ) ;\n bytes_written = ( int32_t ) ( pLMBCS - LMBCS ) ;\n }\n }\n }\n args -> source ++ ;\n pLMBCS = LMBCS ;\n while ( args -> target < args -> targetLimit && bytes_written -- ) {\n * ( args -> target ) ++ = * pLMBCS ++ ;\n if ( args -> offsets ) {\n * ( args -> offsets ) ++ = sourceIndex ;\n }\n }\n sourceIndex ++ ;\n if ( bytes_written > 0 ) {\n uint8_t * pErrorBuffer = args -> converter -> charErrorBuffer ;\n * err = U_BUFFER_OVERFLOW_ERROR ;\n args -> converter -> charErrorBufferLength = ( int8_t ) bytes_written ;\n while ( bytes_written -- ) {\n * pErrorBuffer ++ = * pLMBCS ++ ;\n }\n }\n extraInfo -> localeConverterIndex = OldConverterIndex ;\n }\n }\n static UChar GetUniFromLMBCSUni ( char const * * ppLMBCSin ) {\n uint8_t HighCh = * ( * ppLMBCSin ) ++ ;\n uint8_t LowCh = * ( * ppLMBCSin ) ++ ;\n if ( HighCh == ULMBCS_UNICOMPATZERO ) {\n HighCh = LowCh ;\n LowCh = 0 ;\n }\n return ( UChar ) ( ( HighCh << 8 ) | LowCh ) ;\n }\n # define CHECK_SOURCE_LIMIT ( index ) if ( args -> source + index > args -> sourceLimit ) {\n * err = U_TRUNCATED_CHAR_FOUND ;\n args -> source = args -> sourceLimit ;\n return 0xffff ;\n }\n static UChar32 _LMBCSGetNextUCharWorker ( UConverterToUnicodeArgs * args , UErrorCode * err ) {\n UChar32 uniChar = 0 ;\n ulmbcs_byte_t CurByte ;\n if ( args -> source >= args -> sourceLimit ) {\n * err = U_ILLEGAL_ARGUMENT_ERROR ;\n return 0xffff ;\n }\n CurByte = * ( ( ulmbcs_byte_t * ) ( args -> source ++ ) ) ;\n if ( ( ( CurByte > ULMBCS_C0END ) && ( CurByte < ULMBCS_C1START ) ) || ( CurByte == 0 ) || CurByte == ULMBCS_HT || CurByte == ULMBCS_CR || CurByte == ULMBCS_LF || CurByte == ULMBCS_123SYSTEMRANGE ) {\n uniChar = CurByte ;\n }\n else {\n UConverterDataLMBCS * extraInfo ;\n ulmbcs_byte_t group ;\n UConverterSharedData * cnv ;\n if ( CurByte == ULMBCS_GRP_CTRL ) {\n ulmbcs_byte_t C0C1byte ;\n CHECK_SOURCE_LIMIT ( 1 ) ;\n C0C1byte = * ( args -> source ) ++ ;\n uniChar = ( C0C1byte < ULMBCS_C1START ) ? C0C1byte - ULMBCS_CTRLOFFSET : C0C1byte ;\n }\n else if ( CurByte == ULMBCS_GRP_UNICODE ) {\n CHECK_SOURCE_LIMIT ( 2 ) ;\n return GetUniFromLMBCSUni ( & ( args -> source ) ) ;\n }\n else if ( CurByte <= ULMBCS_CTRLOFFSET ) {\n group = CurByte ;\n extraInfo = ( UConverterDataLMBCS * ) args -> converter -> extraInfo ;\n if ( group > ULMBCS_GRP_LAST || ( cnv = extraInfo -> OptGrpConverter [ group ] ) == NULL ) {\n * err = U_INVALID_CHAR_FOUND ;\n }\n else if ( group >= ULMBCS_DOUBLEOPTGROUP_START ) {\n CHECK_SOURCE_LIMIT ( 2 ) ;\n if ( * args -> source == group ) {\n ++ args -> source ;\n uniChar = ucnv_MBCSSimpleGetNextUChar ( cnv , args -> source , 1 , FALSE ) ;\n ++ args -> source ;\n }\n else {\n uniChar = ucnv_MBCSSimpleGetNextUChar ( cnv , args -> source , 2 , FALSE ) ;\n args -> source += 2 ;\n }\n }\n else {\n CHECK_SOURCE_LIMIT ( 1 ) ;\n CurByte = * ( args -> source ) ++ ;\n if ( CurByte >= ULMBCS_C1START ) {\n uniChar = _MBCS_SINGLE_SIMPLE_GET_NEXT_BMP ( cnv , CurByte ) ;\n }\n else {\n char bytes [ 2 ] ;\n extraInfo = ( UConverterDataLMBCS * ) args -> converter -> extraInfo ;\n cnv = extraInfo -> OptGrpConverter [ ULMBCS_GRP_EXCEPT ] ;\n bytes [ 0 ] = group ;\n bytes [ 1 ] = CurByte ;\n uniChar = ucnv_MBCSSimpleGetNextUChar ( cnv , bytes , 2 , FALSE ) ;\n }\n }\n }\n else if ( CurByte >= ULMBCS_C1START ) {\n extraInfo = ( UConverterDataLMBCS * ) args -> converter -> extraInfo ;\n group = extraInfo -> OptGroup ;\n cnv = extraInfo -> OptGrpConverter [ group ] ;\n if ( group >= ULMBCS_DOUBLEOPTGROUP_START ) {\n if ( ! ucnv_MBCSIsLeadByte ( cnv , CurByte ) ) {\n CHECK_SOURCE_LIMIT ( 0 ) ;\n uniChar = ucnv_MBCSSimpleGetNextUChar ( cnv , args -> source - 1 , 1 , FALSE ) ;\n }\n else {\n CHECK_SOURCE_LIMIT ( 1 ) ;\n uniChar = ucnv_MBCSSimpleGetNextUChar ( cnv , args -> source - 1 , 2 , FALSE ) ;\n ++ args -> source ;\n }\n }\n else {\n uniChar = _MBCS_SINGLE_SIMPLE_GET_NEXT_BMP ( cnv , CurByte ) ;\n }\n }\n }\n return uniChar ;\n }\n static void _LMBCSToUnicodeWithOffsets ( UConverterToUnicodeArgs * args , UErrorCode * err ) {\n char LMBCS [ ULMBCS_CHARSIZE_MAX ] ;\n UChar uniChar ;\n const char * saveSource ;\n const char * pStartLMBCS = args -> source ;\n const char * errSource = NULL ;\n int8_t savebytes = 0 ;\n while ( U_SUCCESS ( * err ) && args -> sourceLimit > args -> source && args -> targetLimit > args -> target ) {\n saveSource = args -> source ;\n if ( args -> converter -> toULength ) {\n const char * saveSourceLimit ;\n size_t size_old = args -> converter -> toULength ;\n size_t size_new_maybe_1 = sizeof ( LMBCS ) - size_old ;\n size_t size_new_maybe_2 = args -> sourceLimit - args -> source ;\n size_t size_new = ( size_new_maybe_1 < size_new_maybe_2 ) ? size_new_maybe_1 : size_new_maybe_2 ;\n uprv_memcpy ( LMBCS , args -> converter -> toUBytes , size_old ) ;\n uprv_memcpy ( LMBCS + size_old , args -> source , size_new ) ;\n saveSourceLimit = args -> sourceLimit ;\n args -> source = errSource = LMBCS ;\n args -> sourceLimit = LMBCS + size_old + size_new ;\n savebytes = ( int8_t ) ( size_old + size_new ) ;\n uniChar = ( UChar ) _LMBCSGetNextUCharWorker ( args , err ) ;\n args -> source = saveSource + ( ( args -> source - LMBCS ) - size_old ) ;\n args -> sourceLimit = saveSourceLimit ;\n if ( * err == U_TRUNCATED_CHAR_FOUND ) {\n args -> converter -> toULength = savebytes ;\n uprv_memcpy ( args -> converter -> toUBytes , LMBCS , savebytes ) ;\n args -> source = args -> sourceLimit ;\n * err = U_ZERO_ERROR ;\n return ;\n }\n else {\n args -> converter -> toULength = 0 ;\n }\n }\n else {\n errSource = saveSource ;\n uniChar = ( UChar ) _LMBCSGetNextUCharWorker ( args , err ) ;\n savebytes = ( int8_t ) ( args -> source - saveSource ) ;\n }\n if ( U_SUCCESS ( * err ) ) {\n if ( uniChar < 0xfffe ) {\n * ( args -> target ) ++ = uniChar ;\n if ( args -> offsets ) {\n * ( args -> offsets ) ++ = ( int32_t ) ( saveSource - pStartLMBCS ) ;\n }\n }\n else if ( uniChar == 0xfffe ) {\n * err = U_INVALID_CHAR_FOUND ;\n }\n else {\n * err = U_ILLEGAL_CHAR_FOUND ;\n }\n }\n }\n if ( U_SUCCESS ( * err ) && args -> sourceLimit > args -> source && args -> targetLimit <= args -> target ) {\n * err = U_BUFFER_OVERFLOW_ERROR ;\n }\n else if ( U_FAILURE ( * err ) ) {\n args -> converter -> toULength = savebytes ;\n if ( savebytes > 0 ) {\n uprv_memcpy ( args -> converter -> toUBytes , errSource , savebytes ) ;\n }\n if ( * err == U_TRUNCATED_CHAR_FOUND ) {\n * err = U_ZERO_ERROR ;\n }\n }\n }\n DEFINE_LMBCS_OPEN ( 1 ) DEFINE_LMBCS_OPEN ( 2 ) DEFINE_LMBCS_OPEN ( 3 ) DEFINE_LMBCS_OPEN ( 4 ) DEFINE_LMBCS_OPEN ( 5 ) DEFINE_LMBCS_OPEN ( 6 ) DEFINE_LMBCS_OPEN ( 8 ) DEFINE_LMBCS_OPEN ( 11 ) DEFINE_LMBCS_OPEN ( 16 ) DEFINE_LMBCS_OPEN ( 17 ) DEFINE_LMBCS_OPEN ( 18 )", "idx": 2012}
{"hash": -769658847024738738, "project": "debian", "size": 97, "label": 0, "functionSource": "static gpgme_error_t uiserver_new ( void * * engine , const char * file_name , const char * home_dir ) {\n gpgme_error_t err = 0 ;\n engine_uiserver_t uiserver ;\n char * dft_display = NULL ;\n char dft_ttyname [ 64 ] ;\n char * dft_ttytype = NULL ;\n char * optstr ;\n uiserver = calloc ( 1 , sizeof * uiserver ) ;\n if ( ! uiserver ) return gpg_error_from_syserror ( ) ;\n uiserver -> protocol = GPGME_PROTOCOL_DEFAULT ;\n uiserver -> status_cb . fd = - 1 ;\n uiserver -> status_cb . dir = 1 ;\n uiserver -> status_cb . tag = 0 ;\n uiserver -> status_cb . data = uiserver ;\n uiserver -> input_cb . fd = - 1 ;\n uiserver -> input_cb . dir = 0 ;\n uiserver -> input_cb . tag = 0 ;\n uiserver -> input_cb . server_fd = - 1 ;\n * uiserver -> input_cb . server_fd_str = 0 ;\n uiserver -> output_cb . fd = - 1 ;\n uiserver -> output_cb . dir = 1 ;\n uiserver -> output_cb . tag = 0 ;\n uiserver -> output_cb . server_fd = - 1 ;\n * uiserver -> output_cb . server_fd_str = 0 ;\n uiserver -> message_cb . fd = - 1 ;\n uiserver -> message_cb . dir = 0 ;\n uiserver -> message_cb . tag = 0 ;\n uiserver -> message_cb . server_fd = - 1 ;\n * uiserver -> message_cb . server_fd_str = 0 ;\n uiserver -> status . fnc = 0 ;\n uiserver -> colon . fnc = 0 ;\n uiserver -> colon . attic . line = 0 ;\n uiserver -> colon . attic . linesize = 0 ;\n uiserver -> colon . attic . linelen = 0 ;\n uiserver -> colon . any = 0 ;\n uiserver -> inline_data = NULL ;\n uiserver -> io_cbs . add = NULL ;\n uiserver -> io_cbs . add_priv = NULL ;\n uiserver -> io_cbs . remove = NULL ;\n uiserver -> io_cbs . event = NULL ;\n uiserver -> io_cbs . event_priv = NULL ;\n err = assuan_new_ext ( & uiserver -> assuan_ctx , GPG_ERR_SOURCE_GPGME , & _gpgme_assuan_malloc_hooks , _gpgme_assuan_log_cb , NULL ) ;\n if ( err ) goto leave ;\n assuan_ctx_set_system_hooks ( uiserver -> assuan_ctx , & _gpgme_assuan_system_hooks ) ;\n err = assuan_socket_connect ( uiserver -> assuan_ctx , file_name ? file_name : _gpgme_get_default_uisrv_socket ( ) , 0 , ASSUAN_SOCKET_SERVER_FDPASSING ) ;\n if ( err ) goto leave ;\n err = _gpgme_getenv ( \"DISPLAY\" , & dft_display ) ;\n if ( err ) goto leave ;\n if ( dft_display ) {\n if ( asprintf ( & optstr , \"OPTION display=%s\" , dft_display ) < 0 ) {\n err = gpg_error_from_syserror ( ) ;\n free ( dft_display ) ;\n goto leave ;\n }\n free ( dft_display ) ;\n err = assuan_transact ( uiserver -> assuan_ctx , optstr , NULL , NULL , NULL , NULL , NULL , NULL ) ;\n free ( optstr ) ;\n if ( err ) goto leave ;\n }\n if ( isatty ( 1 ) ) {\n int rc ;\n rc = ttyname_r ( 1 , dft_ttyname , sizeof ( dft_ttyname ) ) ;\n if ( rc ) {\n err = gpg_error_from_errno ( rc ) ;\n goto leave ;\n }\n else {\n if ( asprintf ( & optstr , \"OPTION ttyname=%s\" , dft_ttyname ) < 0 ) {\n err = gpg_error_from_syserror ( ) ;\n goto leave ;\n }\n err = assuan_transact ( uiserver -> assuan_ctx , optstr , NULL , NULL , NULL , NULL , NULL , NULL ) ;\n free ( optstr ) ;\n if ( err ) goto leave ;\n err = _gpgme_getenv ( \"TERM\" , & dft_ttytype ) ;\n if ( err ) goto leave ;\n if ( dft_ttytype ) {\n if ( asprintf ( & optstr , \"OPTION ttytype=%s\" , dft_ttytype ) < 0 ) {\n err = gpg_error_from_syserror ( ) ;\n free ( dft_ttytype ) ;\n goto leave ;\n }\n free ( dft_ttytype ) ;\n err = assuan_transact ( uiserver -> assuan_ctx , optstr , NULL , NULL , NULL , NULL , NULL , NULL ) ;\n free ( optstr ) ;\n if ( err ) goto leave ;\n }\n }\n }\n # ifdef HAVE_W32_SYSTEM if ( ! err ) {\n err = assuan_transact ( uiserver -> assuan_ctx , \"OPTION allow-pinentry-notify\" , NULL , NULL , NULL , NULL , NULL , NULL ) ;\n if ( gpg_err_code ( err ) == GPG_ERR_UNKNOWN_OPTION ) err = 0 ;\n }\n # endif leave : if ( err ) uiserver_release ( uiserver ) ;\n else * engine = uiserver ;\n return err ;\n }", "idx": 2013}
{"hash": -5493081488206619677, "project": "debian", "size": 8, "label": 0, "functionSource": "static const char * cmd_request_body_access ( cmd_parms * cmd , void * _dcfg , const char * p1 ) {\n directory_config * dcfg = ( directory_config * ) _dcfg ;\n if ( dcfg == NULL ) return NULL ;\n if ( strcasecmp ( p1 , \"on\" ) == 0 ) dcfg -> reqbody_access = 1 ;\n else if ( strcasecmp ( p1 , \"off\" ) == 0 ) dcfg -> reqbody_access = 0 ;\n else return apr_psprintf ( cmd -> pool , \"ModSecurity: Invalid value for SecRequestBodyAccess: %s\" , p1 ) ;\n return NULL ;\n }", "idx": 2014}
{"hash": 453207616518947865, "project": "chrome", "size": 3, "label": 0, "functionSource": "static void uprv_start ( UTimer * timer ) {\n gettimeofday ( & timer -> start , 0 ) ;\n }", "idx": 2015}
{"hash": 1182028467273264883, "project": "debian", "size": 27, "label": 0, "functionSource": "int do_sleep ( struct st_command * command , my_bool real_sleep ) {\n int error = 0 ;\n char * sleep_start , * sleep_end ;\n double sleep_val ;\n char * p ;\n static DYNAMIC_STRING ds_sleep ;\n const struct command_arg sleep_args [ ] = {\n {\n \"sleep_delay\" , ARG_STRING , TRUE , & ds_sleep , \"Number of seconds to sleep.\" }\n }\n ;\n check_command_args ( command , command -> first_argument , sleep_args , sizeof ( sleep_args ) / sizeof ( struct command_arg ) , ' ' ) ;\n p = ds_sleep . str ;\n sleep_end = ds_sleep . str + ds_sleep . length ;\n while ( my_isspace ( charset_info , * p ) ) p ++ ;\n if ( ! * p ) die ( \"Missing argument to %.*s\" , command -> first_word_len , command -> query ) ;\n sleep_start = p ;\n if ( ! my_isdigit ( charset_info , * sleep_start ) ) die ( \"Invalid argument to %.*s \\\"%s\\\"\" , command -> first_word_len , command -> query , sleep_start ) ;\n sleep_val = my_strtod ( sleep_start , & sleep_end , & error ) ;\n check_eol_junk_line ( sleep_end ) ;\n if ( error ) die ( \"Invalid argument to %.*s \\\"%s\\\"\" , command -> first_word_len , command -> query , command -> first_argument ) ;\n dynstr_free ( & ds_sleep ) ;\n if ( opt_sleep >= 0 && ! real_sleep ) sleep_val = opt_sleep ;\n DBUG_PRINT ( \"info\" , ( \"sleep_val: %f\" , sleep_val ) ) ;\n if ( sleep_val ) my_sleep ( ( ulong ) ( sleep_val * 1000000L ) ) ;\n return 0 ;\n }", "idx": 2016}
{"hash": -1983921383858884161, "project": "debian", "size": 30, "label": 1, "functionSource": "static int ipvideo_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n IpvideoContext * s = avctx -> priv_data ;\n int ret ;\n s -> decoding_map_size = avctx -> width * avctx -> height / ( 8 * 8 * 2 ) ;\n if ( buf_size < s -> decoding_map_size ) return buf_size ;\n s -> decoding_map = buf ;\n bytestream2_init ( & s -> stream_ptr , buf + s -> decoding_map_size , buf_size - s -> decoding_map_size ) ;\n s -> current_frame . reference = 3 ;\n if ( ( ret = ff_get_buffer ( avctx , & s -> current_frame ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \" Interplay Video: get_buffer() failed\\n\" ) ;\n return ret ;\n }\n if ( ! s -> is_16bpp ) {\n const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;\n if ( pal ) {\n s -> current_frame . palette_has_changed = 1 ;\n memcpy ( s -> pal , pal , AVPALETTE_SIZE ) ;\n }\n }\n ipvideo_decode_opcodes ( s ) ;\n * got_frame = 1 ;\n * ( AVFrame * ) data = s -> current_frame ;\n if ( s -> second_last_frame . data [ 0 ] ) avctx -> release_buffer ( avctx , & s -> second_last_frame ) ;\n s -> second_last_frame = s -> last_frame ;\n s -> last_frame = s -> current_frame ;\n s -> current_frame . data [ 0 ] = NULL ;\n return buf_size ;\n }", "idx": 2017}
{"hash": 4701140738883197535, "project": "chrome", "size": 12, "label": 1, "functionSource": "void vp9_lpf_vertical_8_dual_sse2 ( uint8_t * s , int p , const uint8_t * blimit0 , const uint8_t * limit0 , const uint8_t * thresh0 , const uint8_t * blimit1 , const uint8_t * limit1 , const uint8_t * thresh1 ) {\n DECLARE_ALIGNED_ARRAY ( 16 , unsigned char , t_dst , 16 * 8 ) ;\n unsigned char * src [ 2 ] ;\n unsigned char * dst [ 2 ] ;\n transpose8x16 ( s - 4 , s - 4 + p * 8 , p , t_dst , 16 ) ;\n vp9_lpf_horizontal_8_dual_sse2 ( t_dst + 4 * 16 , 16 , blimit0 , limit0 , thresh0 , blimit1 , limit1 , thresh1 ) ;\n src [ 0 ] = t_dst ;\n src [ 1 ] = t_dst + 8 ;\n dst [ 0 ] = s - 4 ;\n dst [ 1 ] = s - 4 + p * 8 ;\n transpose ( src , 16 , dst , p , 2 ) ;\n }", "idx": 2018}
{"hash": -8704451445127642833, "project": "chrome", "size": 27, "label": 0, "functionSource": "static int32_t u_scanf_integer_handler ( UFILE * input , u_scanf_spec_info * info , ufmt_args * args , const UChar * fmt , int32_t * fmtConsumed , int32_t * argConverted ) {\n ( void ) fmt ;\n ( void ) fmtConsumed ;\n int32_t len ;\n void * num = ( void * ) ( args [ 0 ] . ptrValue ) ;\n UNumberFormat * format ;\n int32_t parsePos = 0 ;\n int32_t skipped ;\n UErrorCode status = U_ZERO_ERROR ;\n int64_t result ;\n skipped = u_scanf_skip_leading_ws ( input , info -> fPadChar ) ;\n ufile_fill_uchar_buffer ( input ) ;\n len = ( int32_t ) ( input -> str . fLimit - input -> str . fPos ) ;\n if ( info -> fWidth != - 1 ) len = ufmt_min ( len , info -> fWidth ) ;\n format = u_locbund_getNumberFormat ( & input -> str . fBundle , UNUM_DECIMAL ) ;\n if ( format == 0 ) return 0 ;\n skipped += u_scanf_skip_leading_positive_sign ( input , format , & status ) ;\n result = unum_parseInt64 ( format , input -> str . fPos , len , & parsePos , & status ) ;\n if ( ! info -> fSkipArg ) {\n if ( info -> fIsShort ) * ( int16_t * ) num = ( int16_t ) ( UINT16_MAX & result ) ;\n else if ( info -> fIsLongLong ) * ( int64_t * ) num = result ;\n else * ( int32_t * ) num = ( int32_t ) ( UINT32_MAX & result ) ;\n }\n input -> str . fPos += parsePos ;\n * argConverted = ! info -> fSkipArg ;\n return parsePos + skipped ;\n }", "idx": 2019}
{"hash": -7990991774694156606, "project": "debian", "size": 5, "label": 0, "functionSource": "static int ref_frame ( Vp3DecodeContext * s , ThreadFrame * dst , ThreadFrame * src ) {\n ff_thread_release_buffer ( s -> avctx , dst ) ;\n if ( src -> f -> data [ 0 ] ) return ff_thread_ref_frame ( dst , src ) ;\n return 0 ;\n }", "idx": 2020}
{"hash": 6080147530626246065, "project": "debian", "size": 99, "label": 0, "functionSource": "static void vc1_decode_i_blocks_adv ( VC1Context * v ) {\n int k ;\n MpegEncContext * s = & v -> s ;\n int cbp , val ;\n uint8_t * coded_val ;\n int mb_pos ;\n int mquant = v -> pq ;\n int mqdiff ;\n GetBitContext * gb = & s -> gb ;\n switch ( v -> y_ac_table_index ) {\n case 0 : v -> codingset = ( v -> pqindex <= 8 ) ? CS_HIGH_RATE_INTRA : CS_LOW_MOT_INTRA ;\n break ;\n case 1 : v -> codingset = CS_HIGH_MOT_INTRA ;\n break ;\n case 2 : v -> codingset = CS_MID_RATE_INTRA ;\n break ;\n }\n switch ( v -> c_ac_table_index ) {\n case 0 : v -> codingset2 = ( v -> pqindex <= 8 ) ? CS_HIGH_RATE_INTER : CS_LOW_MOT_INTER ;\n break ;\n case 1 : v -> codingset2 = CS_HIGH_MOT_INTER ;\n break ;\n case 2 : v -> codingset2 = CS_MID_RATE_INTER ;\n break ;\n }\n s -> mb_x = s -> mb_y = 0 ;\n s -> mb_intra = 1 ;\n s -> first_slice_line = 1 ;\n s -> mb_y = s -> start_mb_y ;\n if ( s -> start_mb_y ) {\n s -> mb_x = 0 ;\n ff_init_block_index ( s ) ;\n memset ( & s -> coded_block [ s -> block_index [ 0 ] - s -> b8_stride ] , 0 , ( 1 + s -> b8_stride ) * sizeof ( * s -> coded_block ) ) ;\n }\n for ( ;\n s -> mb_y < s -> end_mb_y ;\n s -> mb_y ++ ) {\n s -> mb_x = 0 ;\n ff_init_block_index ( s ) ;\n for ( ;\n s -> mb_x < s -> mb_width ;\n s -> mb_x ++ ) {\n int16_t ( * block ) [ 64 ] = v -> block [ v -> cur_blk_idx ] ;\n ff_update_block_index ( s ) ;\n s -> dsp . clear_blocks ( block [ 0 ] ) ;\n mb_pos = s -> mb_x + s -> mb_y * s -> mb_stride ;\n s -> current_picture . mb_type [ mb_pos + v -> mb_off ] = MB_TYPE_INTRA ;\n s -> current_picture . motion_val [ 1 ] [ s -> block_index [ 0 ] + v -> blocks_off ] [ 0 ] = 0 ;\n s -> current_picture . motion_val [ 1 ] [ s -> block_index [ 0 ] + v -> blocks_off ] [ 1 ] = 0 ;\n if ( v -> fieldtx_is_raw ) v -> fieldtx_plane [ mb_pos ] = get_bits1 ( & v -> s . gb ) ;\n cbp = get_vlc2 ( & v -> s . gb , ff_msmp4_mb_i_vlc . table , MB_INTRA_VLC_BITS , 2 ) ;\n if ( v -> acpred_is_raw ) v -> s . ac_pred = get_bits1 ( & v -> s . gb ) ;\n else v -> s . ac_pred = v -> acpred_plane [ mb_pos ] ;\n if ( v -> condover == CONDOVER_SELECT && v -> overflg_is_raw ) v -> over_flags_plane [ mb_pos ] = get_bits1 ( & v -> s . gb ) ;\n GET_MQUANT ( ) ;\n s -> current_picture . qscale_table [ mb_pos ] = mquant ;\n s -> y_dc_scale = s -> y_dc_scale_table [ mquant ] ;\n s -> c_dc_scale = s -> c_dc_scale_table [ mquant ] ;\n for ( k = 0 ;\n k < 6 ;\n k ++ ) {\n val = ( ( cbp >> ( 5 - k ) ) & 1 ) ;\n if ( k < 4 ) {\n int pred = vc1_coded_block_pred ( & v -> s , k , & coded_val ) ;\n val = val ^ pred ;\n * coded_val = val ;\n }\n cbp |= val << ( 5 - k ) ;\n v -> a_avail = ! s -> first_slice_line || ( k == 2 || k == 3 ) ;\n v -> c_avail = ! ! s -> mb_x || ( k == 1 || k == 3 ) ;\n vc1_decode_i_block_adv ( v , block [ k ] , k , val , ( k < 4 ) ? v -> codingset : v -> codingset2 , mquant ) ;\n if ( k > 3 && ( s -> flags & CODEC_FLAG_GRAY ) ) continue ;\n v -> vc1dsp . vc1_inv_trans_8x8 ( block [ k ] ) ;\n }\n vc1_smooth_overlap_filter_iblk ( v ) ;\n vc1_put_signed_blocks_clamped ( v ) ;\n if ( v -> s . loop_filter ) vc1_loop_filter_iblk_delayed ( v , v -> pq ) ;\n if ( get_bits_count ( & s -> gb ) > v -> bits ) {\n ff_er_add_slice ( & s -> er , 0 , s -> start_mb_y , s -> mb_x , s -> mb_y , ER_MB_ERROR ) ;\n av_log ( s -> avctx , AV_LOG_ERROR , \"Bits overconsumption: %i > %i\\n\" , get_bits_count ( & s -> gb ) , v -> bits ) ;\n return ;\n }\n }\n if ( ! v -> s . loop_filter ) ff_mpeg_draw_horiz_band ( s , s -> mb_y * 16 , 16 ) ;\n else if ( s -> mb_y ) ff_mpeg_draw_horiz_band ( s , ( s -> mb_y - 1 ) * 16 , 16 ) ;\n s -> first_slice_line = 0 ;\n }\n s -> mb_x = 0 ;\n ff_init_block_index ( s ) ;\n for ( ;\n s -> mb_x < s -> mb_width ;\n s -> mb_x ++ ) {\n ff_update_block_index ( s ) ;\n vc1_put_signed_blocks_clamped ( v ) ;\n if ( v -> s . loop_filter ) vc1_loop_filter_iblk_delayed ( v , v -> pq ) ;\n }\n if ( v -> s . loop_filter ) ff_mpeg_draw_horiz_band ( s , ( s -> end_mb_y - 1 ) * 16 , 16 ) ;\n ff_er_add_slice ( & s -> er , 0 , s -> start_mb_y << v -> field_mode , s -> mb_width - 1 , ( s -> end_mb_y << v -> field_mode ) - 1 , ER_MB_END ) ;\n }", "idx": 2021}
{"hash": -4456702502726364053, "project": "debian", "size": 3, "label": 0, "functionSource": "static void decode_cabac_residual_dc_internal ( H264Context * h , int16_t * block , int cat , int n , const uint8_t * scantable , int max_coeff ) {\n decode_cabac_residual_internal ( h , block , cat , n , scantable , NULL , max_coeff , 1 , 0 ) ;\n }", "idx": 2022}
{"hash": 3616225660295849566, "project": "debian", "size": 55, "label": 1, "functionSource": "static gint detect_version ( wtap * wth , int * err , gchar * * err_info ) {\n gint bytes_read ;\n guint16 payload_length ;\n guint16 try_header_size ;\n guint8 * buffer ;\n gint64 file_offset ;\n guint32 log_length ;\n guint32 tag_length ;\n guint16 tmp ;\n file_offset = file_tell ( wth -> fh ) ;\n bytes_read = file_read ( & tmp , 2 , wth -> fh ) ;\n if ( bytes_read != 2 ) {\n * err = file_error ( wth -> fh , err_info ) ;\n if ( * err == 0 && bytes_read != 0 ) * err = WTAP_ERR_SHORT_READ ;\n return - 1 ;\n }\n payload_length = pletoh16 ( & tmp ) ;\n bytes_read = file_read ( & tmp , 2 , wth -> fh ) ;\n if ( bytes_read != 2 ) {\n * err = file_error ( wth -> fh , err_info ) ;\n if ( * err == 0 && bytes_read != 0 ) * err = WTAP_ERR_SHORT_READ ;\n return - 1 ;\n }\n try_header_size = pletoh16 ( & tmp ) ;\n buffer = ( guint8 * ) g_malloc ( 5 * 4 + payload_length ) ;\n bytes_read = file_read ( buffer , 5 * 4 + payload_length , wth -> fh ) ;\n if ( bytes_read != 5 * 4 + payload_length ) {\n if ( bytes_read != 4 * 4 + payload_length ) {\n * err = file_error ( wth -> fh , err_info ) ;\n if ( * err == 0 && bytes_read != 0 ) * err = WTAP_ERR_SHORT_READ ;\n g_free ( buffer ) ;\n return - 1 ;\n }\n }\n if ( try_header_size == 24 ) {\n tag_length = ( guint32 ) strlen ( buffer + 5 * 4 + 1 ) + 1 ;\n log_length = ( guint32 ) strlen ( buffer + 5 * 4 + 1 + tag_length ) + 1 ;\n if ( payload_length == 1 + tag_length + log_length ) {\n g_free ( buffer ) ;\n return 2 ;\n }\n }\n tag_length = ( guint32 ) strlen ( buffer + 4 * 4 + 1 ) + 1 ;\n log_length = ( guint32 ) strlen ( buffer + 4 * 4 + 1 + tag_length ) + 1 ;\n if ( payload_length == 1 + tag_length + log_length ) {\n if ( file_seek ( wth -> fh , file_offset + 4 * 4 + 1 + tag_length + log_length , SEEK_SET , err ) == - 1 ) {\n g_free ( buffer ) ;\n return - 1 ;\n }\n g_free ( buffer ) ;\n return 1 ;\n }\n g_free ( buffer ) ;\n return 0 ;\n }", "idx": 2023}
{"hash": -4885528830177756816, "project": "debian", "size": 13, "label": 0, "functionSource": "int write_data_suffix ( SORT_INFO * sort_info , my_bool fix_datafile ) {\n MI_INFO * info = sort_info -> info ;\n if ( info -> s -> options & HA_OPTION_COMPRESS_RECORD && fix_datafile ) {\n uchar buff [ MEMMAP_EXTRA_MARGIN ] ;\n bzero ( buff , sizeof ( buff ) ) ;\n if ( my_b_write ( & info -> rec_cache , buff , sizeof ( buff ) ) ) {\n mi_check_print_error ( sort_info -> param , \"%d when writing to datafile\" , my_errno ) ;\n return 1 ;\n }\n sort_info -> param -> read_cache . end_of_file += sizeof ( buff ) ;\n }\n return 0 ;\n }", "idx": 2024}
{"hash": 7889142355347191490, "project": "debian", "size": 3, "label": 0, "functionSource": "static __inline__ int udpv6_rcv ( struct sk_buff * skb ) {\n return __udp6_lib_rcv ( skb , & udp_table , IPPROTO_UDP ) ;\n }", "idx": 2025}
{"hash": -7136186224744987223, "project": "debian", "size": 11, "label": 0, "functionSource": "char * Curl_checkheaders ( const struct connectdata * conn , const char * thisheader ) {\n struct curl_slist * head ;\n size_t thislen = strlen ( thisheader ) ;\n struct Curl_easy * data = conn -> data ;\n for ( head = data -> set . headers ;\n head ;\n head = head -> next ) {\n if ( Curl_raw_nequal ( head -> data , thisheader , thislen ) ) return head -> data ;\n }\n return NULL ;\n }", "idx": 2026}
{"hash": 7651945086108393719, "project": "debian", "size": 19, "label": 0, "functionSource": "int qemuMonitorJSONAttachDrive ( qemuMonitorPtr mon , const char * drivestr , virDomainDevicePCIAddress * controllerAddr , virDomainDeviceDriveAddress * driveAddr ) {\n int ret ;\n virJSONValuePtr cmd = NULL ;\n virJSONValuePtr reply = NULL ;\n char * dev ;\n if ( virAsprintf ( & dev , \"%.2x:%.2x.%.1x\" , controllerAddr -> bus , controllerAddr -> slot , controllerAddr -> function ) < 0 ) {\n virReportOOMError ( ) ;\n return - 1 ;\n }\n cmd = qemuMonitorJSONMakeCommand ( \"drive_add\" , \"s:pci_addr\" , dev , \"s:opts\" , drivestr , NULL ) ;\n VIR_FREE ( dev ) ;\n if ( ! cmd ) return - 1 ;\n ret = qemuMonitorJSONCommand ( mon , cmd , & reply ) ;\n if ( ret == 0 ) ret = qemuMonitorJSONCheckError ( cmd , reply ) ;\n if ( ret == 0 && qemuMonitorJSONGetGuestDriveAddress ( reply , driveAddr ) < 0 ) ret = - 1 ;\n virJSONValueFree ( cmd ) ;\n virJSONValueFree ( reply ) ;\n return ret ;\n }", "idx": 2027}
{"hash": 1891617106617090004, "project": "chrome", "size": 100, "label": 1, "functionSource": "static void _UTF32ToUnicodeWithOffsets ( UConverterToUnicodeArgs * pArgs , UErrorCode * pErrorCode ) {\n UConverter * cnv = pArgs -> converter ;\n const char * source = pArgs -> source ;\n const char * sourceLimit = pArgs -> sourceLimit ;\n int32_t * offsets = pArgs -> offsets ;\n int32_t state , offsetDelta ;\n char b ;\n state = cnv -> mode ;\n offsetDelta = 0 ;\n while ( source < sourceLimit && U_SUCCESS ( * pErrorCode ) ) {\n switch ( state ) {\n case 0 : b = * source ;\n if ( b == 0 ) {\n state = 1 ;\n }\n else if ( b == ( char ) 0xff ) {\n state = 5 ;\n }\n else {\n state = 8 ;\n continue ;\n }\n ++ source ;\n break ;\n case 1 : case 2 : case 3 : case 5 : case 6 : case 7 : if ( * source == utf32BOM [ state ] ) {\n ++ state ;\n ++ source ;\n if ( state == 4 ) {\n state = 8 ;\n offsetDelta = ( int32_t ) ( source - pArgs -> source ) ;\n }\n else if ( state == 8 ) {\n state = 9 ;\n offsetDelta = ( int32_t ) ( source - pArgs -> source ) ;\n }\n }\n else {\n int32_t count = ( int32_t ) ( source - pArgs -> source ) ;\n source = pArgs -> source ;\n if ( count == ( state & 3 ) ) {\n }\n else {\n UBool oldFlush = pArgs -> flush ;\n pArgs -> source = utf32BOM + ( state & 4 ) ;\n pArgs -> sourceLimit = pArgs -> source + ( ( state & 3 ) - count ) ;\n pArgs -> flush = FALSE ;\n T_UConverter_toUnicode_UTF32_BE ( pArgs , pErrorCode ) ;\n pArgs -> sourceLimit = sourceLimit ;\n pArgs -> flush = oldFlush ;\n }\n state = 8 ;\n continue ;\n }\n break ;\n case 8 : pArgs -> source = source ;\n if ( offsets == NULL ) {\n T_UConverter_toUnicode_UTF32_BE ( pArgs , pErrorCode ) ;\n }\n else {\n T_UConverter_toUnicode_UTF32_BE_OFFSET_LOGIC ( pArgs , pErrorCode ) ;\n }\n source = pArgs -> source ;\n break ;\n case 9 : pArgs -> source = source ;\n if ( offsets == NULL ) {\n T_UConverter_toUnicode_UTF32_LE ( pArgs , pErrorCode ) ;\n }\n else {\n T_UConverter_toUnicode_UTF32_LE_OFFSET_LOGIC ( pArgs , pErrorCode ) ;\n }\n source = pArgs -> source ;\n break ;\n default : break ;\n }\n }\n if ( offsets != NULL && offsetDelta != 0 ) {\n int32_t * offsetsLimit = pArgs -> offsets ;\n while ( offsets < offsetsLimit ) {\n * offsets ++ += offsetDelta ;\n }\n }\n pArgs -> source = source ;\n if ( source == sourceLimit && pArgs -> flush ) {\n switch ( state ) {\n case 0 : break ;\n case 8 : T_UConverter_toUnicode_UTF32_BE ( pArgs , pErrorCode ) ;\n break ;\n case 9 : T_UConverter_toUnicode_UTF32_LE ( pArgs , pErrorCode ) ;\n break ;\n default : pArgs -> source = utf32BOM + ( state & 4 ) ;\n pArgs -> sourceLimit = pArgs -> source + ( state & 3 ) ;\n T_UConverter_toUnicode_UTF32_BE ( pArgs , pErrorCode ) ;\n pArgs -> source = source ;\n pArgs -> sourceLimit = sourceLimit ;\n state = 8 ;\n break ;\n }\n }\n cnv -> mode = state ;\n }", "idx": 2028}
{"hash": 7092216800726729686, "project": "debian", "size": 5, "label": 0, "functionSource": "static int dissect_h245_NonStandardParameter ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 979 \"../../asn1/h245/h245.cnf\" nsp_handle = NULL ;\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_NonStandardParameter , NonStandardParameter_sequence ) ;\n return offset ;\n }", "idx": 2029}
{"hash": 6393050609822897742, "project": "debian", "size": 8, "label": 0, "functionSource": "static TRBCCode xhci_enable_slot ( XHCIState * xhci , unsigned int slotid ) {\n trace_usb_xhci_slot_enable ( slotid ) ;\n assert ( slotid >= 1 && slotid <= xhci -> numslots ) ;\n xhci -> slots [ slotid - 1 ] . enabled = 1 ;\n xhci -> slots [ slotid - 1 ] . uport = NULL ;\n memset ( xhci -> slots [ slotid - 1 ] . eps , 0 , sizeof ( XHCIEPContext * ) * 31 ) ;\n return CC_SUCCESS ;\n }", "idx": 2030}
{"hash": 3668456668028959955, "project": "debian", "size": 3, "label": 0, "functionSource": "static void generate_json_fixnum ( FBuffer * buffer , VALUE Vstate , JSON_Generator_State * state , VALUE obj ) {\n fbuffer_append_long ( buffer , FIX2LONG ( obj ) ) ;\n }", "idx": 2031}
{"hash": -6090091127667448005, "project": "debian", "size": 3, "label": 0, "functionSource": "static inline __u8 ip_reply_arg_flowi_flags ( const struct ip_reply_arg * arg ) {\n return ( arg -> flags & IP_REPLY_ARG_NOSRCCHECK ) ? FLOWI_FLAG_ANYSRC : 0 ;\n }", "idx": 2032}
{"hash": 8461782184979846246, "project": "chrome", "size": 8, "label": 0, "functionSource": "TEST_F ( ProtocolHandlerRegistryTest , TestRemoveHandler ) {\n ProtocolHandler ph1 = CreateProtocolHandler ( \"test\" , \"test1\" ) ;\n registry ( ) -> OnAcceptRegisterProtocolHandler ( ph1 ) ;\n registry ( ) -> OnAcceptRegisterProtocolHandler ( ph1 ) ;\n registry ( ) -> RemoveHandler ( ph1 ) ;\n ASSERT_FALSE ( registry ( ) -> IsRegistered ( ph1 ) ) ;\n ASSERT_FALSE ( registry ( ) -> IsHandledProtocol ( \"test\" ) ) ;\n }", "idx": 2033}
{"hash": 4028820914612007011, "project": "chrome", "size": 28, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( SitePerProcessAutofillTest , PasswordAutofillPopupPositionInsideOOPIF ) {\n SetupMainTab ( ) ;\n ASSERT_TRUE ( base : : FeatureList : : IsEnabled ( security_state : : kHttpFormWarningFeature ) ) ;\n GURL main_url ( embedded_test_server ( ) -> GetURL ( \"a.com\" , \"/iframe.html\" ) ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , main_url ) ;\n content : : WebContents * active_web_contents = browser ( ) -> tab_strip_model ( ) -> GetActiveWebContents ( ) ;\n ASSERT_TRUE ( content : : ExecuteScript ( active_web_contents , base : : StringPrintf ( \"var iframe = document.querySelector('iframe');\n\" \"iframe.style.marginTop = '%dpx';\n\" \"iframe.style.marginLeft = '%dpx';\n\" , kIframeTopDisplacement , kIframeLeftDisplacement ) ) ) ;\n GURL frame_url = embedded_test_server ( ) -> GetURL ( \"b.com\" , \"/title1.html\" ) ;\n EXPECT_TRUE ( NavigateIframeToURL ( active_web_contents , \"test\" , frame_url ) ) ;\n content : : RenderFrameHost * child_frame = content : : FrameMatchingPredicate ( active_web_contents , base : : Bind ( & content : : FrameIsChildOfMainFrame ) ) ;\n FocusedEditableNodeChangedObserver focus_observer ;\n ASSERT_TRUE ( ExecuteScript ( child_frame , \"window.focus();\n\" \"var input = document.createElement('input');\n\" \"input.type = 'password';\n\" \"document.body.appendChild(input);\n\" \"input.focus();\n\" ) ) ;\n focus_observer . WaitForFocusChangeInPage ( ) ;\n content : : SimulateKeyPress ( active_web_contents , ui : : DomKey : : FromCharacter ( 'A' ) , ui : : DomCode : : US_A , ui : : VKEY_A , false , false , false , false ) ;\n autofill_client ( ) . WaitForNextPopup ( ) ;\n gfx : : Point bounds_origin ( static_cast < int > ( autofill_client ( ) . last_element_bounds ( ) . origin ( ) . x ( ) ) , static_cast < int > ( autofill_client ( ) . last_element_bounds ( ) . origin ( ) . y ( ) ) ) ;\n bounds_origin += active_web_contents -> GetRenderWidgetHostView ( ) -> GetViewBounds ( ) . OffsetFromOrigin ( ) ;\n gfx : : Vector2d error = bounds_origin - focus_observer . focused_node_bounds_in_screen ( ) ;\n EXPECT_LT ( error . Length ( ) , 1.4143f ) << \"Origin of bounds from focused node changed event is '\" << focus_observer . focused_node_bounds_in_screen ( ) . ToString ( ) << \"' but AutofillClient is reporting '\" << bounds_origin . ToString ( ) << \"'\" ;\n }", "idx": 2034}
{"hash": 4206838170759624883, "project": "debian", "size": 495, "label": 1, "functionSource": "int main ( int argc , char * * argv ) {\n BlockBackend * blk ;\n BlockDriverState * bs ;\n off_t dev_offset = 0 ;\n uint16_t nbdflags = 0 ;\n bool disconnect = false ;\n const char * bindto = NULL ;\n const char * port = NULL ;\n char * sockpath = NULL ;\n char * device = NULL ;\n off_t fd_size ;\n QemuOpts * sn_opts = NULL ;\n const char * sn_id_or_name = NULL ;\n const char * sopt = \"hVb:o:p:rsnP:c:dvk:e:f:tl:x:T:D:\" ;\n struct option lopt [ ] = {\n {\n \"help\" , no_argument , NULL , 'h' }\n , {\n \"version\" , no_argument , NULL , 'V' }\n , {\n \"bind\" , required_argument , NULL , 'b' }\n , {\n \"port\" , required_argument , NULL , 'p' }\n , {\n \"socket\" , required_argument , NULL , 'k' }\n , {\n \"offset\" , required_argument , NULL , 'o' }\n , {\n \"read-only\" , no_argument , NULL , 'r' }\n , {\n \"partition\" , required_argument , NULL , 'P' }\n , {\n \"connect\" , required_argument , NULL , 'c' }\n , {\n \"disconnect\" , no_argument , NULL , 'd' }\n , {\n \"snapshot\" , no_argument , NULL , 's' }\n , {\n \"load-snapshot\" , required_argument , NULL , 'l' }\n , {\n \"nocache\" , no_argument , NULL , 'n' }\n , {\n \"cache\" , required_argument , NULL , QEMU_NBD_OPT_CACHE }\n , {\n \"aio\" , required_argument , NULL , QEMU_NBD_OPT_AIO }\n , {\n \"discard\" , required_argument , NULL , QEMU_NBD_OPT_DISCARD }\n , {\n \"detect-zeroes\" , required_argument , NULL , QEMU_NBD_OPT_DETECT_ZEROES }\n , {\n \"shared\" , required_argument , NULL , 'e' }\n , {\n \"format\" , required_argument , NULL , 'f' }\n , {\n \"persistent\" , no_argument , NULL , 't' }\n , {\n \"verbose\" , no_argument , NULL , 'v' }\n , {\n \"object\" , required_argument , NULL , QEMU_NBD_OPT_OBJECT }\n , {\n \"export-name\" , required_argument , NULL , 'x' }\n , {\n \"description\" , required_argument , NULL , 'D' }\n , {\n \"tls-creds\" , required_argument , NULL , QEMU_NBD_OPT_TLSCREDS }\n , {\n \"image-opts\" , no_argument , NULL , QEMU_NBD_OPT_IMAGE_OPTS }\n , {\n \"trace\" , required_argument , NULL , 'T' }\n , {\n \"fork\" , no_argument , NULL , QEMU_NBD_OPT_FORK }\n , {\n NULL , 0 , NULL , 0 }\n }\n ;\n int ch ;\n int opt_ind = 0 ;\n char * end ;\n int flags = BDRV_O_RDWR ;\n int partition = - 1 ;\n int ret = 0 ;\n bool seen_cache = false ;\n bool seen_discard = false ;\n bool seen_aio = false ;\n pthread_t client_thread ;\n const char * fmt = NULL ;\n Error * local_err = NULL ;\n BlockdevDetectZeroesOptions detect_zeroes = BLOCKDEV_DETECT_ZEROES_OPTIONS_OFF ;\n QDict * options = NULL ;\n const char * export_name = NULL ;\n const char * export_description = NULL ;\n const char * tlscredsid = NULL ;\n bool imageOpts = false ;\n bool writethrough = true ;\n char * trace_file = NULL ;\n bool fork_process = false ;\n int old_stderr = - 1 ;\n unsigned socket_activation ;\n struct sigaction sa_sigterm ;\n memset ( & sa_sigterm , 0 , sizeof ( sa_sigterm ) ) ;\n sa_sigterm . sa_handler = termsig_handler ;\n sigaction ( SIGTERM , & sa_sigterm , NULL ) ;\n module_call_init ( MODULE_INIT_TRACE ) ;\n qcrypto_init ( & error_fatal ) ;\n module_call_init ( MODULE_INIT_QOM ) ;\n qemu_add_opts ( & qemu_object_opts ) ;\n qemu_add_opts ( & qemu_trace_opts ) ;\n qemu_init_exec_dir ( argv [ 0 ] ) ;\n while ( ( ch = getopt_long ( argc , argv , sopt , lopt , & opt_ind ) ) != - 1 ) {\n switch ( ch ) {\n case 's' : flags |= BDRV_O_SNAPSHOT ;\n break ;\n case 'n' : optarg = ( char * ) \"none\" ;\n case QEMU_NBD_OPT_CACHE : if ( seen_cache ) {\n error_report ( \"-n and --cache can only be specified once\" ) ;\n exit ( EXIT_FAILURE ) ;\n }\n seen_cache = true ;\n if ( bdrv_parse_cache_mode ( optarg , & flags , & writethrough ) == - 1 ) {\n error_report ( \"Invalid cache mode `%s'\" , optarg ) ;\n exit ( EXIT_FAILURE ) ;\n }\n break ;\n case QEMU_NBD_OPT_AIO : if ( seen_aio ) {\n error_report ( \"--aio can only be specified once\" ) ;\n exit ( EXIT_FAILURE ) ;\n }\n seen_aio = true ;\n if ( ! strcmp ( optarg , \"native\" ) ) {\n flags |= BDRV_O_NATIVE_AIO ;\n }\n else if ( ! strcmp ( optarg , \"threads\" ) ) {\n }\n else {\n error_report ( \"invalid aio mode `%s'\" , optarg ) ;\n exit ( EXIT_FAILURE ) ;\n }\n break ;\n case QEMU_NBD_OPT_DISCARD : if ( seen_discard ) {\n error_report ( \"--discard can only be specified once\" ) ;\n exit ( EXIT_FAILURE ) ;\n }\n seen_discard = true ;\n if ( bdrv_parse_discard_flags ( optarg , & flags ) == - 1 ) {\n error_report ( \"Invalid discard mode `%s'\" , optarg ) ;\n exit ( EXIT_FAILURE ) ;\n }\n break ;\n case QEMU_NBD_OPT_DETECT_ZEROES : detect_zeroes = qapi_enum_parse ( BlockdevDetectZeroesOptions_lookup , optarg , BLOCKDEV_DETECT_ZEROES_OPTIONS__MAX , BLOCKDEV_DETECT_ZEROES_OPTIONS_OFF , & local_err ) ;\n if ( local_err ) {\n error_reportf_err ( local_err , \"Failed to parse detect_zeroes mode: \" ) ;\n exit ( EXIT_FAILURE ) ;\n }\n if ( detect_zeroes == BLOCKDEV_DETECT_ZEROES_OPTIONS_UNMAP && ! ( flags & BDRV_O_UNMAP ) ) {\n error_report ( \"setting detect-zeroes to unmap is not allowed \" \"without setting discard operation to unmap\" ) ;\n exit ( EXIT_FAILURE ) ;\n }\n break ;\n case 'b' : bindto = optarg ;\n break ;\n case 'p' : port = optarg ;\n break ;\n case 'o' : dev_offset = strtoll ( optarg , & end , 0 ) ;\n if ( * end ) {\n error_report ( \"Invalid offset `%s'\" , optarg ) ;\n exit ( EXIT_FAILURE ) ;\n }\n if ( dev_offset < 0 ) {\n error_report ( \"Offset must be positive `%s'\" , optarg ) ;\n exit ( EXIT_FAILURE ) ;\n }\n break ;\n case 'l' : if ( strstart ( optarg , SNAPSHOT_OPT_BASE , NULL ) ) {\n sn_opts = qemu_opts_parse_noisily ( & internal_snapshot_opts , optarg , false ) ;\n if ( ! sn_opts ) {\n error_report ( \"Failed in parsing snapshot param `%s'\" , optarg ) ;\n exit ( EXIT_FAILURE ) ;\n }\n }\n else {\n sn_id_or_name = optarg ;\n }\n case 'r' : nbdflags |= NBD_FLAG_READ_ONLY ;\n flags &= ~ BDRV_O_RDWR ;\n break ;\n case 'P' : partition = strtol ( optarg , & end , 0 ) ;\n if ( * end ) {\n error_report ( \"Invalid partition `%s'\" , optarg ) ;\n exit ( EXIT_FAILURE ) ;\n }\n if ( partition < 1 || partition > 8 ) {\n error_report ( \"Invalid partition %d\" , partition ) ;\n exit ( EXIT_FAILURE ) ;\n }\n break ;\n case 'k' : sockpath = optarg ;\n if ( sockpath [ 0 ] != '/' ) {\n error_report ( \"socket path must be absolute\" ) ;\n exit ( EXIT_FAILURE ) ;\n }\n break ;\n case 'd' : disconnect = true ;\n break ;\n case 'c' : device = optarg ;\n break ;\n case 'e' : shared = strtol ( optarg , & end , 0 ) ;\n if ( * end ) {\n error_report ( \"Invalid shared device number '%s'\" , optarg ) ;\n exit ( EXIT_FAILURE ) ;\n }\n if ( shared < 1 ) {\n error_report ( \"Shared device number must be greater than 0\" ) ;\n exit ( EXIT_FAILURE ) ;\n }\n break ;\n case 'f' : fmt = optarg ;\n break ;\n case 't' : persistent = 1 ;\n break ;\n case 'x' : export_name = optarg ;\n break ;\n case 'D' : export_description = optarg ;\n break ;\n case 'v' : verbose = 1 ;\n break ;\n case 'V' : version ( argv [ 0 ] ) ;\n exit ( 0 ) ;\n break ;\n case 'h' : usage ( argv [ 0 ] ) ;\n exit ( 0 ) ;\n break ;\n case '?' : error_report ( \"Try `%s --help' for more information.\" , argv [ 0 ] ) ;\n exit ( EXIT_FAILURE ) ;\n case QEMU_NBD_OPT_OBJECT : {\n QemuOpts * opts ;\n opts = qemu_opts_parse_noisily ( & qemu_object_opts , optarg , true ) ;\n if ( ! opts ) {\n exit ( EXIT_FAILURE ) ;\n }\n }\n break ;\n case QEMU_NBD_OPT_TLSCREDS : tlscredsid = optarg ;\n break ;\n case QEMU_NBD_OPT_IMAGE_OPTS : imageOpts = true ;\n break ;\n case 'T' : g_free ( trace_file ) ;\n trace_file = trace_opt_parse ( optarg ) ;\n break ;\n case QEMU_NBD_OPT_FORK : fork_process = true ;\n break ;\n }\n }\n if ( ( argc - optind ) != 1 ) {\n error_report ( \"Invalid number of arguments\" ) ;\n error_printf ( \"Try `%s --help' for more information.\\n\" , argv [ 0 ] ) ;\n exit ( EXIT_FAILURE ) ;\n }\n if ( qemu_opts_foreach ( & qemu_object_opts , user_creatable_add_opts_foreach , NULL , NULL ) ) {\n exit ( EXIT_FAILURE ) ;\n }\n if ( ! trace_init_backends ( ) ) {\n exit ( 1 ) ;\n }\n trace_init_file ( trace_file ) ;\n qemu_set_log ( LOG_TRACE ) ;\n socket_activation = check_socket_activation ( ) ;\n if ( socket_activation == 0 ) {\n setup_address_and_port ( & bindto , & port ) ;\n }\n else {\n const char * err_msg = socket_activation_validate_opts ( device , sockpath , bindto , port ) ;\n if ( err_msg != NULL ) {\n error_report ( \"%s\" , err_msg ) ;\n exit ( EXIT_FAILURE ) ;\n }\n if ( socket_activation > 1 ) {\n error_report ( \"qemu-nbd does not support socket activation with %s > 1\" , \"LISTEN_FDS\" ) ;\n exit ( EXIT_FAILURE ) ;\n }\n }\n if ( tlscredsid ) {\n if ( sockpath ) {\n error_report ( \"TLS is only supported with IPv4/IPv6\" ) ;\n exit ( EXIT_FAILURE ) ;\n }\n if ( device ) {\n error_report ( \"TLS is not supported with a host device\" ) ;\n exit ( EXIT_FAILURE ) ;\n }\n if ( ! export_name ) {\n export_name = \"\" ;\n }\n tlscreds = nbd_get_tls_creds ( tlscredsid , & local_err ) ;\n if ( local_err ) {\n error_report ( \"Failed to get TLS creds %s\" , error_get_pretty ( local_err ) ) ;\n exit ( EXIT_FAILURE ) ;\n }\n }\n if ( disconnect ) {\n int nbdfd = open ( argv [ optind ] , O_RDWR ) ;\n if ( nbdfd < 0 ) {\n error_report ( \"Cannot open %s: %s\" , argv [ optind ] , strerror ( errno ) ) ;\n exit ( EXIT_FAILURE ) ;\n }\n nbd_disconnect ( nbdfd ) ;\n close ( nbdfd ) ;\n printf ( \"%s disconnected\\n\" , argv [ optind ] ) ;\n return 0 ;\n }\n if ( ( device && ! verbose ) || fork_process ) {\n int stderr_fd [ 2 ] ;\n pid_t pid ;\n int ret ;\n if ( qemu_pipe ( stderr_fd ) < 0 ) {\n error_report ( \"Error setting up communication pipe: %s\" , strerror ( errno ) ) ;\n exit ( EXIT_FAILURE ) ;\n }\n pid = fork ( ) ;\n if ( pid < 0 ) {\n error_report ( \"Failed to fork: %s\" , strerror ( errno ) ) ;\n exit ( EXIT_FAILURE ) ;\n }\n else if ( pid == 0 ) {\n close ( stderr_fd [ 0 ] ) ;\n ret = qemu_daemon ( 1 , 0 ) ;\n old_stderr = dup ( STDERR_FILENO ) ;\n dup2 ( stderr_fd [ 1 ] , STDERR_FILENO ) ;\n if ( ret < 0 ) {\n error_report ( \"Failed to daemonize: %s\" , strerror ( errno ) ) ;\n exit ( EXIT_FAILURE ) ;\n }\n close ( stderr_fd [ 1 ] ) ;\n }\n else {\n bool errors = false ;\n char * buf ;\n close ( stderr_fd [ 1 ] ) ;\n buf = g_malloc ( 1024 ) ;\n while ( ( ret = read ( stderr_fd [ 0 ] , buf , 1024 ) ) > 0 ) {\n errors = true ;\n ret = qemu_write_full ( STDERR_FILENO , buf , ret ) ;\n if ( ret < 0 ) {\n exit ( EXIT_FAILURE ) ;\n }\n }\n if ( ret < 0 ) {\n error_report ( \"Cannot read from daemon: %s\" , strerror ( errno ) ) ;\n exit ( EXIT_FAILURE ) ;\n }\n exit ( errors ) ;\n }\n }\n if ( device != NULL && sockpath == NULL ) {\n sockpath = g_malloc ( 128 ) ;\n snprintf ( sockpath , 128 , SOCKET_PATH , basename ( device ) ) ;\n }\n if ( socket_activation == 0 ) {\n server_ioc = qio_channel_socket_new ( ) ;\n saddr = nbd_build_socket_address ( sockpath , bindto , port ) ;\n if ( qio_channel_socket_listen_sync ( server_ioc , saddr , & local_err ) < 0 ) {\n object_unref ( OBJECT ( server_ioc ) ) ;\n error_report_err ( local_err ) ;\n return 1 ;\n }\n }\n else {\n assert ( socket_activation == 1 ) ;\n server_ioc = qio_channel_socket_new_fd ( FIRST_SOCKET_ACTIVATION_FD , & local_err ) ;\n if ( server_ioc == NULL ) {\n error_report ( \"Failed to use socket activation: %s\" , error_get_pretty ( local_err ) ) ;\n exit ( EXIT_FAILURE ) ;\n }\n }\n if ( qemu_init_main_loop ( & local_err ) ) {\n error_report_err ( local_err ) ;\n exit ( EXIT_FAILURE ) ;\n }\n bdrv_init ( ) ;\n atexit ( bdrv_close_all ) ;\n srcpath = argv [ optind ] ;\n if ( imageOpts ) {\n QemuOpts * opts ;\n if ( fmt ) {\n error_report ( \"--image-opts and -f are mutually exclusive\" ) ;\n exit ( EXIT_FAILURE ) ;\n }\n opts = qemu_opts_parse_noisily ( & file_opts , srcpath , true ) ;\n if ( ! opts ) {\n qemu_opts_reset ( & file_opts ) ;\n exit ( EXIT_FAILURE ) ;\n }\n options = qemu_opts_to_qdict ( opts , NULL ) ;\n qemu_opts_reset ( & file_opts ) ;\n blk = blk_new_open ( NULL , NULL , options , flags , & local_err ) ;\n }\n else {\n if ( fmt ) {\n options = qdict_new ( ) ;\n qdict_put_str ( options , \"driver\" , fmt ) ;\n }\n blk = blk_new_open ( srcpath , NULL , options , flags , & local_err ) ;\n }\n if ( ! blk ) {\n error_reportf_err ( local_err , \"Failed to blk_new_open '%s': \" , argv [ optind ] ) ;\n exit ( EXIT_FAILURE ) ;\n }\n bs = blk_bs ( blk ) ;\n blk_set_enable_write_cache ( blk , ! writethrough ) ;\n if ( sn_opts ) {\n ret = bdrv_snapshot_load_tmp ( bs , qemu_opt_get ( sn_opts , SNAPSHOT_OPT_ID ) , qemu_opt_get ( sn_opts , SNAPSHOT_OPT_NAME ) , & local_err ) ;\n }\n else if ( sn_id_or_name ) {\n ret = bdrv_snapshot_load_tmp_by_id_or_name ( bs , sn_id_or_name , & local_err ) ;\n }\n if ( ret < 0 ) {\n error_reportf_err ( local_err , \"Failed to load snapshot: \" ) ;\n exit ( EXIT_FAILURE ) ;\n }\n bs -> detect_zeroes = detect_zeroes ;\n fd_size = blk_getlength ( blk ) ;\n if ( fd_size < 0 ) {\n error_report ( \"Failed to determine the image length: %s\" , strerror ( - fd_size ) ) ;\n exit ( EXIT_FAILURE ) ;\n }\n if ( dev_offset >= fd_size ) {\n error_report ( \"Offset (%lld) has to be smaller than the image size \" \"(%lld)\" , ( long long int ) dev_offset , ( long long int ) fd_size ) ;\n exit ( EXIT_FAILURE ) ;\n }\n fd_size -= dev_offset ;\n if ( partition != - 1 ) {\n ret = find_partition ( blk , partition , & dev_offset , & fd_size ) ;\n if ( ret < 0 ) {\n error_report ( \"Could not find partition %d: %s\" , partition , strerror ( - ret ) ) ;\n exit ( EXIT_FAILURE ) ;\n }\n }\n exp = nbd_export_new ( bs , dev_offset , fd_size , nbdflags , nbd_export_closed , writethrough , NULL , & local_err ) ;\n if ( ! exp ) {\n error_report_err ( local_err ) ;\n exit ( EXIT_FAILURE ) ;\n }\n if ( export_name ) {\n nbd_export_set_name ( exp , export_name ) ;\n nbd_export_set_description ( exp , export_description ) ;\n newproto = true ;\n }\n else if ( export_description ) {\n error_report ( \"Export description requires an export name\" ) ;\n exit ( EXIT_FAILURE ) ;\n }\n if ( device ) {\n int ret ;\n ret = pthread_create ( & client_thread , NULL , nbd_client_thread , device ) ;\n if ( ret != 0 ) {\n error_report ( \"Failed to create client thread: %s\" , strerror ( ret ) ) ;\n exit ( EXIT_FAILURE ) ;\n }\n }\n else {\n memset ( & client_thread , 0 , sizeof ( client_thread ) ) ;\n }\n nbd_update_server_watch ( ) ;\n if ( chdir ( \"/\" ) < 0 ) {\n error_report ( \"Could not chdir to root directory: %s\" , strerror ( errno ) ) ;\n exit ( EXIT_FAILURE ) ;\n }\n if ( fork_process ) {\n dup2 ( old_stderr , STDERR_FILENO ) ;\n close ( old_stderr ) ;\n }\n state = RUNNING ;\n do {\n main_loop_wait ( false ) ;\n if ( state == TERMINATE ) {\n state = TERMINATING ;\n nbd_export_close ( exp ) ;\n nbd_export_put ( exp ) ;\n exp = NULL ;\n }\n }\n while ( state != TERMINATED ) ;\n blk_unref ( blk ) ;\n if ( sockpath ) {\n unlink ( sockpath ) ;\n }\n qemu_opts_del ( sn_opts ) ;\n if ( device ) {\n void * ret ;\n pthread_join ( client_thread , & ret ) ;\n exit ( ret != NULL ) ;\n }\n else {\n exit ( EXIT_SUCCESS ) ;\n }\n }", "idx": 2035}
{"hash": 5991533509192663951, "project": "debian", "size": 42, "label": 0, "functionSource": "static int collector_encode_hex_htmlnumericentity ( int c , void * data ) {\n struct collector_htmlnumericentity_data * pc = ( struct collector_htmlnumericentity_data * ) data ;\n int f , n , s , r , d , size , * mapelm ;\n size = pc -> mapsize ;\n f = 0 ;\n n = 0 ;\n while ( n < size ) {\n mapelm = & ( pc -> convmap [ n * 4 ] ) ;\n if ( c >= mapelm [ 0 ] && c <= mapelm [ 1 ] ) {\n s = ( c + mapelm [ 2 ] ) & mapelm [ 3 ] ;\n if ( s >= 0 ) {\n ( * pc -> decoder -> filter_function ) ( 0x26 , pc -> decoder ) ;\n ( * pc -> decoder -> filter_function ) ( 0x23 , pc -> decoder ) ;\n ( * pc -> decoder -> filter_function ) ( 0x78 , pc -> decoder ) ;\n r = 0x1000000 ;\n s %= r ;\n while ( r > 0 ) {\n d = s / r ;\n if ( d || f ) {\n f = 1 ;\n s %= r ;\n ( * pc -> decoder -> filter_function ) ( mbfl_hexchar_table [ d ] , pc -> decoder ) ;\n }\n r /= 16 ;\n }\n if ( ! f ) {\n f = 1 ;\n ( * pc -> decoder -> filter_function ) ( mbfl_hexchar_table [ 0 ] , pc -> decoder ) ;\n }\n ( * pc -> decoder -> filter_function ) ( 0x3b , pc -> decoder ) ;\n }\n }\n if ( f ) {\n break ;\n }\n n ++ ;\n }\n if ( ! f ) {\n ( * pc -> decoder -> filter_function ) ( c , pc -> decoder ) ;\n }\n return c ;\n }", "idx": 2036}
{"hash": 6600620671673714486, "project": "debian", "size": 3, "label": 0, "functionSource": "static gs_memory_type_ptr_t i_object_type ( const gs_memory_t * mem , const void * obj ) {\n return ( ( const obj_header_t * ) obj - 1 ) -> o_type ;\n }", "idx": 2037}
{"hash": 5357882892791796049, "project": "debian", "size": 4, "label": 0, "functionSource": "static uint32_t e1000e_mac_ics_read ( E1000ECore * core , int index ) {\n trace_e1000e_irq_read_ics ( core -> mac [ ICS ] ) ;\n return core -> mac [ ICS ] ;\n }", "idx": 2038}
{"hash": -2423144171479606949, "project": "debian", "size": 37, "label": 0, "functionSource": "static void pdf_show_char ( fz_context * ctx , pdf_run_processor * pr , int cid ) {\n pdf_gstate * gstate = pr -> gstate + pr -> gtop ;\n pdf_font_desc * fontdesc = gstate -> text . font ;\n fz_matrix trm ;\n int gid ;\n int ucsbuf [ 8 ] ;\n int ucslen ;\n int i ;\n int render_direct ;\n gid = pdf_tos_make_trm ( ctx , & pr -> tos , & gstate -> text , fontdesc , cid , & trm ) ;\n render_direct = ( ! fz_font_ft_face ( ctx , fontdesc -> font ) && pr -> nested_depth > 0 ) || ! fz_glyph_cacheable ( ctx , fontdesc -> font , gid ) ;\n if ( ! pr -> tos . text || gstate -> text . render != pr -> tos . text_mode || render_direct ) {\n gstate = pdf_flush_text ( ctx , pr ) ;\n pdf_tos_reset ( ctx , & pr -> tos , gstate -> text . render ) ;\n }\n if ( render_direct ) {\n fz_matrix composed ;\n fz_concat ( & composed , & trm , & gstate -> ctm ) ;\n fz_render_t3_glyph_direct ( ctx , pr -> dev , fontdesc -> font , gid , & composed , gstate , pr -> nested_depth , pr -> default_cs ) ;\n pr -> tos . text_mode = 3 ;\n }\n ucslen = 0 ;\n if ( fontdesc -> to_unicode ) ucslen = pdf_lookup_cmap_full ( fontdesc -> to_unicode , cid , ucsbuf ) ;\n if ( ucslen == 0 && ( size_t ) cid < fontdesc -> cid_to_ucs_len ) {\n ucsbuf [ 0 ] = fontdesc -> cid_to_ucs [ cid ] ;\n ucslen = 1 ;\n }\n if ( ucslen == 0 || ( ucslen == 1 && ucsbuf [ 0 ] == 0 ) ) {\n ucsbuf [ 0 ] = FZ_REPLACEMENT_CHARACTER ;\n ucslen = 1 ;\n }\n fz_show_glyph ( ctx , pr -> tos . text , fontdesc -> font , & trm , gid , ucsbuf [ 0 ] , fontdesc -> wmode , 0 , FZ_BIDI_NEUTRAL , FZ_LANG_UNSET ) ;\n for ( i = 1 ;\n i < ucslen ;\n i ++ ) fz_show_glyph ( ctx , pr -> tos . text , fontdesc -> font , & trm , - 1 , ucsbuf [ i ] , fontdesc -> wmode , 0 , FZ_BIDI_NEUTRAL , FZ_LANG_UNSET ) ;\n pdf_tos_move_after_char ( ctx , & pr -> tos ) ;\n }", "idx": 2039}
{"hash": 9118387177353441960, "project": "debian", "size": 11, "label": 0, "functionSource": "void web_server_destroy ( void ) {\n if ( bWebServerState == WEB_SERVER_ENABLED ) {\n membuffer_destroy ( & gDocumentRootDir ) ;\n alias_release ( & gAliasDoc ) ;\n ithread_mutex_lock ( & gWebMutex ) ;\n memset ( & gAliasDoc , 0 , sizeof ( struct xml_alias_t ) ) ;\n ithread_mutex_unlock ( & gWebMutex ) ;\n ithread_mutex_destroy ( & gWebMutex ) ;\n bWebServerState = WEB_SERVER_DISABLED ;\n }\n }", "idx": 2040}
{"hash": -2740750333757361388, "project": "debian", "size": 41, "label": 0, "functionSource": "static int truespeech_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n AVFrame * frame = data ;\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n TSContext * c = avctx -> priv_data ;\n int i , j ;\n int16_t * samples ;\n int iterations , ret ;\n iterations = buf_size / 32 ;\n if ( ! iterations ) {\n av_log ( avctx , AV_LOG_ERROR , \"Too small input buffer (%d bytes), need at least 32 bytes\\n\" , buf_size ) ;\n return - 1 ;\n }\n frame -> nb_samples = iterations * 240 ;\n if ( ( ret = ff_get_buffer ( avctx , frame , 0 ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n samples = ( int16_t * ) frame -> data [ 0 ] ;\n memset ( samples , 0 , iterations * 240 * sizeof ( * samples ) ) ;\n for ( j = 0 ;\n j < iterations ;\n j ++ ) {\n truespeech_read_frame ( c , buf ) ;\n buf += 32 ;\n truespeech_correlate_filter ( c ) ;\n truespeech_filters_merge ( c ) ;\n for ( i = 0 ;\n i < 4 ;\n i ++ ) {\n truespeech_apply_twopoint_filter ( c , i ) ;\n truespeech_place_pulses ( c , samples , i ) ;\n truespeech_update_filters ( c , samples , i ) ;\n truespeech_synth ( c , samples , i ) ;\n samples += 60 ;\n }\n truespeech_save_prevvec ( c ) ;\n }\n * got_frame_ptr = 1 ;\n return buf_size ;\n }", "idx": 2041}
{"hash": -1483849844579170895, "project": "chrome", "size": 21, "label": 0, "functionSource": "static void initialize_encoder ( struct stream_state * stream , struct VpxEncoderConfig * global ) {\n int i ;\n int flags = 0 ;\n flags |= global -> show_psnr ? VPX_CODEC_USE_PSNR : 0 ;\n flags |= global -> out_part ? VPX_CODEC_USE_OUTPUT_PARTITION : 0 ;\n # if CONFIG_VP9 && CONFIG_VP9_HIGHBITDEPTH flags |= stream -> config . use_16bit_internal ? VPX_CODEC_USE_HIGHBITDEPTH : 0 ;\n # endif vpx_codec_enc_init ( & stream -> encoder , global -> codec -> codec_interface ( ) , & stream -> config . cfg , flags ) ;\n ctx_exit_on_error ( & stream -> encoder , \"Failed to initialize encoder\" ) ;\n for ( i = 0 ;\n i < stream -> config . arg_ctrl_cnt ;\n i ++ ) {\n int ctrl = stream -> config . arg_ctrls [ i ] [ 0 ] ;\n int value = stream -> config . arg_ctrls [ i ] [ 1 ] ;\n if ( vpx_codec_control_ ( & stream -> encoder , ctrl , value ) ) fprintf ( stderr , \"Error: Tried to set control %d = %d\\n\" , ctrl , value ) ;\n ctx_exit_on_error ( & stream -> encoder , \"Failed to control codec\" ) ;\n }\n # if CONFIG_DECODERS if ( global -> test_decode != TEST_DECODE_OFF ) {\n const VpxInterface * decoder = get_vpx_decoder_by_name ( global -> codec -> name ) ;\n vpx_codec_dec_init ( & stream -> decoder , decoder -> codec_interface ( ) , NULL , 0 ) ;\n }\n # endif }", "idx": 2042}
{"hash": -1315695702746584250, "project": "debian", "size": 11, "label": 0, "functionSource": "void proto_registrar_dump_protocols ( void ) {\n protocol_t * protocol ;\n int i ;\n void * cookie = NULL ;\n i = proto_get_first_protocol ( & cookie ) ;\n while ( i != - 1 ) {\n protocol = find_protocol_by_id ( i ) ;\n ws_debug_printf ( \"%s\\t%s\\t%s\\n\" , protocol -> name , protocol -> short_name , protocol -> filter_name ) ;\n i = proto_get_next_protocol ( & cookie ) ;\n }\n }", "idx": 2043}
{"hash": 4976989049001279223, "project": "debian", "size": 3, "label": 0, "functionSource": "void _http_parser_init ( HTTPParser * parser ) {\n parser -> m_parsing_http = true ;\n }", "idx": 2044}
{"hash": -5268859819325807498, "project": "debian", "size": 12, "label": 0, "functionSource": "static void mime_list_state_free ( MimeListState * state ) {\n if ( state -> enumerator ) {\n if ( ! g_file_enumerator_is_closed ( state -> enumerator ) ) {\n g_file_enumerator_close_async ( state -> enumerator , 0 , NULL , NULL , NULL ) ;\n }\n g_object_unref ( state -> enumerator ) ;\n }\n g_object_unref ( state -> cancellable ) ;\n istr_set_destroy ( state -> mime_list_hash ) ;\n nautilus_directory_unref ( state -> directory ) ;\n g_free ( state ) ;\n }", "idx": 2045}
{"hash": -8562506069584692324, "project": "chrome", "size": 28, "label": 1, "functionSource": "TEST_F ( MultiBufferTest , ReadAllAdvanceFirst_NeverDefer ) {\n multibuffer_ . SetMaxWriters ( 1 ) ;\n size_t pos = 0 ;\n size_t end = 10000 ;\n multibuffer_ . SetFileSize ( 10000 ) ;\n multibuffer_ . SetMaxBlocksAfterDefer ( - 10000 ) ;\n multibuffer_ . SetRangeSupported ( true ) ;\n media : : MultiBufferReader reader ( & multibuffer_ , pos , end , base : : Callback < void ( int64_t , int64_t ) > ( ) ) ;\n reader . SetMaxBuffer ( 2000 , 5000 ) ;\n reader . SetPreload ( 1000 , 1000 ) ;\n while ( pos < end ) {\n unsigned char buffer [ 27 ] ;\n buffer [ 17 ] = 17 ;\n size_t to_read = std : : min < size_t > ( end - pos , 17 ) ;\n while ( AdvanceAll ( ) ) ;\n int64_t bytes = reader . TryRead ( buffer , to_read ) ;\n EXPECT_GT ( bytes , 0 ) ;\n EXPECT_EQ ( buffer [ 17 ] , 17 ) ;\n for ( int64_t i = 0 ;\n i < bytes ;\n i ++ ) {\n uint8_t expected = static_cast < uint8_t > ( ( pos * 15485863 ) >> 16 ) ;\n EXPECT_EQ ( expected , buffer [ i ] ) << \" pos = \" << pos ;\n pos ++ ;\n }\n }\n EXPECT_GT ( multibuffer_ . writers_created ( ) , 1 ) ;\n }", "idx": 2046}
{"hash": 692314327553049477, "project": "chrome", "size": 61, "label": 0, "functionSource": "unsigned int vp8_variance16x8_neon ( const unsigned char * src_ptr , int source_stride , const unsigned char * ref_ptr , int recon_stride , unsigned int * sse ) {\n int i ;\n int16x4_t d22s16 , d23s16 , d24s16 , d25s16 , d26s16 , d27s16 , d28s16 , d29s16 ;\n uint32x2_t d0u32 , d10u32 ;\n int64x1_t d0s64 , d1s64 ;\n uint8x16_t q0u8 , q1u8 , q2u8 , q3u8 ;\n uint16x8_t q11u16 , q12u16 , q13u16 , q14u16 ;\n int32x4_t q8s32 , q9s32 , q10s32 ;\n int64x2_t q0s64 , q1s64 , q5s64 ;\n q8s32 = vdupq_n_s32 ( 0 ) ;\n q9s32 = vdupq_n_s32 ( 0 ) ;\n q10s32 = vdupq_n_s32 ( 0 ) ;\n for ( i = 0 ;\n i < 4 ;\n i ++ ) {\n q0u8 = vld1q_u8 ( src_ptr ) ;\n src_ptr += source_stride ;\n q1u8 = vld1q_u8 ( src_ptr ) ;\n src_ptr += source_stride ;\n __builtin_prefetch ( src_ptr ) ;\n q2u8 = vld1q_u8 ( ref_ptr ) ;\n ref_ptr += recon_stride ;\n q3u8 = vld1q_u8 ( ref_ptr ) ;\n ref_ptr += recon_stride ;\n __builtin_prefetch ( ref_ptr ) ;\n q11u16 = vsubl_u8 ( vget_low_u8 ( q0u8 ) , vget_low_u8 ( q2u8 ) ) ;\n q12u16 = vsubl_u8 ( vget_high_u8 ( q0u8 ) , vget_high_u8 ( q2u8 ) ) ;\n q13u16 = vsubl_u8 ( vget_low_u8 ( q1u8 ) , vget_low_u8 ( q3u8 ) ) ;\n q14u16 = vsubl_u8 ( vget_high_u8 ( q1u8 ) , vget_high_u8 ( q3u8 ) ) ;\n d22s16 = vreinterpret_s16_u16 ( vget_low_u16 ( q11u16 ) ) ;\n d23s16 = vreinterpret_s16_u16 ( vget_high_u16 ( q11u16 ) ) ;\n q8s32 = vpadalq_s16 ( q8s32 , vreinterpretq_s16_u16 ( q11u16 ) ) ;\n q9s32 = vmlal_s16 ( q9s32 , d22s16 , d22s16 ) ;\n q10s32 = vmlal_s16 ( q10s32 , d23s16 , d23s16 ) ;\n d24s16 = vreinterpret_s16_u16 ( vget_low_u16 ( q12u16 ) ) ;\n d25s16 = vreinterpret_s16_u16 ( vget_high_u16 ( q12u16 ) ) ;\n q8s32 = vpadalq_s16 ( q8s32 , vreinterpretq_s16_u16 ( q12u16 ) ) ;\n q9s32 = vmlal_s16 ( q9s32 , d24s16 , d24s16 ) ;\n q10s32 = vmlal_s16 ( q10s32 , d25s16 , d25s16 ) ;\n d26s16 = vreinterpret_s16_u16 ( vget_low_u16 ( q13u16 ) ) ;\n d27s16 = vreinterpret_s16_u16 ( vget_high_u16 ( q13u16 ) ) ;\n q8s32 = vpadalq_s16 ( q8s32 , vreinterpretq_s16_u16 ( q13u16 ) ) ;\n q9s32 = vmlal_s16 ( q9s32 , d26s16 , d26s16 ) ;\n q10s32 = vmlal_s16 ( q10s32 , d27s16 , d27s16 ) ;\n d28s16 = vreinterpret_s16_u16 ( vget_low_u16 ( q14u16 ) ) ;\n d29s16 = vreinterpret_s16_u16 ( vget_high_u16 ( q14u16 ) ) ;\n q8s32 = vpadalq_s16 ( q8s32 , vreinterpretq_s16_u16 ( q14u16 ) ) ;\n q9s32 = vmlal_s16 ( q9s32 , d28s16 , d28s16 ) ;\n q10s32 = vmlal_s16 ( q10s32 , d29s16 , d29s16 ) ;\n }\n q10s32 = vaddq_s32 ( q10s32 , q9s32 ) ;\n q0s64 = vpaddlq_s32 ( q8s32 ) ;\n q1s64 = vpaddlq_s32 ( q10s32 ) ;\n d0s64 = vadd_s64 ( vget_low_s64 ( q0s64 ) , vget_high_s64 ( q0s64 ) ) ;\n d1s64 = vadd_s64 ( vget_low_s64 ( q1s64 ) , vget_high_s64 ( q1s64 ) ) ;\n q5s64 = vmull_s32 ( vreinterpret_s32_s64 ( d0s64 ) , vreinterpret_s32_s64 ( d0s64 ) ) ;\n vst1_lane_u32 ( ( uint32_t * ) sse , vreinterpret_u32_s64 ( d1s64 ) , 0 ) ;\n d10u32 = vshr_n_u32 ( vreinterpret_u32_s64 ( vget_low_s64 ( q5s64 ) ) , 7 ) ;\n d0u32 = vsub_u32 ( vreinterpret_u32_s64 ( d1s64 ) , d10u32 ) ;\n return vget_lane_u32 ( d0u32 , 0 ) ;\n }", "idx": 2047}
{"hash": -6552851419396579257, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_spoolss_string_parm ( tvbuff_t * tvb , gint offset , packet_info * pinfo , proto_tree * tree , dcerpc_info * di , guint8 * drep , const char * text ) {\n offset = dissect_ndr_pointer ( tvb , offset , pinfo , tree , di , drep , dissect_spoolss_string_parm_data , NDR_POINTER_UNIQUE , text , - 1 ) ;\n return offset ;\n }", "idx": 2048}
{"hash": -2928324134072492299, "project": "debian", "size": 12, "label": 0, "functionSource": "void skinny_calls_init_tap ( void ) {\n GString * error_string ;\n if ( have_skinny_tap_listener == FALSE ) {\n error_string = register_tap_listener ( \"skinny\" , & ( the_tapinfo_struct . skinny_dummy ) , NULL , TL_REQUIRES_PROTO_TREE , voip_calls_dlg_reset , skinny_calls_packet , voip_calls_dlg_draw ) ;\n if ( error_string != NULL ) {\n simple_dialog ( ESD_TYPE_ERROR , ESD_BTN_OK , \"%s\" , error_string -> str ) ;\n g_string_free ( error_string , TRUE ) ;\n exit ( 1 ) ;\n }\n have_skinny_tap_listener = TRUE ;\n }\n }", "idx": 2049}
{"hash": -4555950263653671147, "project": "debian", "size": 43, "label": 0, "functionSource": "PyObject * PyString_FromStringAndSize ( const char * str , Py_ssize_t size ) {\n register PyStringObject * op ;\n if ( size < 0 ) {\n PyErr_SetString ( PyExc_SystemError , \"Negative size passed to PyString_FromStringAndSize\" ) ;\n return NULL ;\n }\n if ( size == 0 && ( op = nullstring ) != NULL ) {\n # ifdef COUNT_ALLOCS null_strings ++ ;\n # endif Py_INCREF ( op ) ;\n return ( PyObject * ) op ;\n }\n if ( size == 1 && str != NULL && ( op = characters [ * str & UCHAR_MAX ] ) != NULL ) {\n # ifdef COUNT_ALLOCS one_strings ++ ;\n # endif Py_INCREF ( op ) ;\n return ( PyObject * ) op ;\n }\n if ( size > PY_SSIZE_T_MAX - PyStringObject_SIZE ) {\n PyErr_SetString ( PyExc_OverflowError , \"string is too large\" ) ;\n return NULL ;\n }\n op = ( PyStringObject * ) PyObject_MALLOC ( PyStringObject_SIZE + size ) ;\n if ( op == NULL ) return PyErr_NoMemory ( ) ;\n ( void ) PyObject_INIT_VAR ( op , & PyString_Type , size ) ;\n op -> ob_shash = - 1 ;\n op -> ob_sstate = SSTATE_NOT_INTERNED ;\n if ( str != NULL ) Py_MEMCPY ( op -> ob_sval , str , size ) ;\n op -> ob_sval [ size ] = '\\0' ;\n if ( size == 0 ) {\n PyObject * t = ( PyObject * ) op ;\n PyString_InternInPlace ( & t ) ;\n op = ( PyStringObject * ) t ;\n nullstring = op ;\n Py_INCREF ( op ) ;\n }\n else if ( size == 1 && str != NULL ) {\n PyObject * t = ( PyObject * ) op ;\n PyString_InternInPlace ( & t ) ;\n op = ( PyStringObject * ) t ;\n characters [ * str & UCHAR_MAX ] = op ;\n Py_INCREF ( op ) ;\n }\n return ( PyObject * ) op ;\n }", "idx": 2050}
{"hash": -1763326842639388875, "project": "debian", "size": 66, "label": 1, "functionSource": "static int chacha20_poly1305_ctrl ( EVP_CIPHER_CTX * ctx , int type , int arg , void * ptr ) {\n EVP_CHACHA_AEAD_CTX * actx = aead_data ( ctx ) ;\n switch ( type ) {\n case EVP_CTRL_INIT : if ( actx == NULL ) actx = ctx -> cipher_data = OPENSSL_zalloc ( sizeof ( * actx ) + Poly1305_ctx_size ( ) ) ;\n if ( actx == NULL ) {\n EVPerr ( EVP_F_CHACHA20_POLY1305_CTRL , EVP_R_INITIALIZATION_ERROR ) ;\n return 0 ;\n }\n actx -> len . aad = 0 ;\n actx -> len . text = 0 ;\n actx -> aad = 0 ;\n actx -> mac_inited = 0 ;\n actx -> tag_len = 0 ;\n actx -> nonce_len = 12 ;\n actx -> tls_payload_length = NO_TLS_PAYLOAD_LENGTH ;\n return 1 ;\n case EVP_CTRL_COPY : if ( actx ) {\n EVP_CIPHER_CTX * dst = ( EVP_CIPHER_CTX * ) ptr ;\n dst -> cipher_data = OPENSSL_memdup ( actx , sizeof ( * actx ) + Poly1305_ctx_size ( ) ) ;\n if ( dst -> cipher_data == NULL ) {\n EVPerr ( EVP_F_CHACHA20_POLY1305_CTRL , EVP_R_COPY_ERROR ) ;\n return 0 ;\n }\n }\n return 1 ;\n case EVP_CTRL_AEAD_SET_IVLEN : if ( arg <= 0 || arg > CHACHA_CTR_SIZE ) return 0 ;\n actx -> nonce_len = arg ;\n return 1 ;\n case EVP_CTRL_AEAD_SET_IV_FIXED : if ( arg != 12 ) return 0 ;\n actx -> nonce [ 0 ] = actx -> key . counter [ 1 ] = CHACHA_U8TOU32 ( ( unsigned char * ) ptr ) ;\n actx -> nonce [ 1 ] = actx -> key . counter [ 2 ] = CHACHA_U8TOU32 ( ( unsigned char * ) ptr + 4 ) ;\n actx -> nonce [ 2 ] = actx -> key . counter [ 3 ] = CHACHA_U8TOU32 ( ( unsigned char * ) ptr + 8 ) ;\n return 1 ;\n case EVP_CTRL_AEAD_SET_TAG : if ( arg <= 0 || arg > POLY1305_BLOCK_SIZE ) return 0 ;\n if ( ptr != NULL ) {\n memcpy ( actx -> tag , ptr , arg ) ;\n actx -> tag_len = arg ;\n }\n return 1 ;\n case EVP_CTRL_AEAD_GET_TAG : if ( arg <= 0 || arg > POLY1305_BLOCK_SIZE || ! ctx -> encrypt ) return 0 ;\n memcpy ( ptr , actx -> tag , arg ) ;\n return 1 ;\n case EVP_CTRL_AEAD_TLS1_AAD : if ( arg != EVP_AEAD_TLS1_AAD_LEN ) return 0 ;\n {\n unsigned int len ;\n unsigned char * aad = ptr , temp [ POLY1305_BLOCK_SIZE ] ;\n len = aad [ EVP_AEAD_TLS1_AAD_LEN - 2 ] << 8 | aad [ EVP_AEAD_TLS1_AAD_LEN - 1 ] ;\n if ( ! ctx -> encrypt ) {\n len -= POLY1305_BLOCK_SIZE ;\n memcpy ( temp , aad , EVP_AEAD_TLS1_AAD_LEN - 2 ) ;\n aad = temp ;\n temp [ EVP_AEAD_TLS1_AAD_LEN - 2 ] = ( unsigned char ) ( len >> 8 ) ;\n temp [ EVP_AEAD_TLS1_AAD_LEN - 1 ] = ( unsigned char ) len ;\n }\n actx -> tls_payload_length = len ;\n actx -> key . counter [ 1 ] = actx -> nonce [ 0 ] ;\n actx -> key . counter [ 2 ] = actx -> nonce [ 1 ] ^ CHACHA_U8TOU32 ( aad ) ;\n actx -> key . counter [ 3 ] = actx -> nonce [ 2 ] ^ CHACHA_U8TOU32 ( aad + 4 ) ;\n actx -> mac_inited = 0 ;\n chacha20_poly1305_cipher ( ctx , NULL , aad , EVP_AEAD_TLS1_AAD_LEN ) ;\n return POLY1305_BLOCK_SIZE ;\n }\n case EVP_CTRL_AEAD_SET_MAC_KEY : return 1 ;\n default : return - 1 ;\n }\n }", "idx": 2051}
{"hash": 7053327172993215211, "project": "chrome", "size": 19, "label": 0, "functionSource": "TEST ( WinUtils , IsPipe ) {\n using sandbox : : IsPipe ;\n base : : string16 pipe_name = L\"\\\\??\\\\pipe\\\\mypipe\" ;\n EXPECT_TRUE ( IsPipe ( pipe_name ) ) ;\n pipe_name = L\"\\\\??\\\\PiPe\\\\mypipe\" ;\n EXPECT_TRUE ( IsPipe ( pipe_name ) ) ;\n pipe_name = L\"\\\\??\\\\pipe\" ;\n EXPECT_FALSE ( IsPipe ( pipe_name ) ) ;\n pipe_name = L\"\\\\??\\\\_pipe_\\\\mypipe\" ;\n EXPECT_FALSE ( IsPipe ( pipe_name ) ) ;\n pipe_name = L\"\\\\??\\\\ABCD\\\\mypipe\" ;\n EXPECT_FALSE ( IsPipe ( pipe_name ) ) ;\n pipe_name = L\"/??/pipe/mypipe\" ;\n EXPECT_FALSE ( IsPipe ( pipe_name ) ) ;\n pipe_name = L\"\\\\XX\\\\pipe\\\\mypipe\" ;\n EXPECT_FALSE ( IsPipe ( pipe_name ) ) ;\n pipe_name = L\"\\\\Device\\\\NamedPipe\\\\mypipe\" ;\n EXPECT_FALSE ( IsPipe ( pipe_name ) ) ;\n }", "idx": 2052}
{"hash": -5615323818347734353, "project": "debian", "size": 7, "label": 0, "functionSource": "static void create_shutdown_thread ( ) {\n # ifdef __WIN__ hEventShutdown = CreateEvent ( 0 , FALSE , FALSE , shutdown_event_name ) ;\n pthread_t hThread ;\n int error ;\n if ( ( error = mysql_thread_create ( key_thread_handle_shutdown , & hThread , & connection_attrib , handle_shutdown , 0 ) ) ) sql_print_warning ( \"Can't create thread to handle shutdown requests\" \" (errno= %d)\" , error ) ;\n Service . SetShutdownEvent ( hEventShutdown ) ;\n # endif }", "idx": 2053}
{"hash": 4537091194729139981, "project": "chrome", "size": 7, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( FullscreenControllerInteractiveTest , DISABLED_BrowserFullscreenExit ) {\n ASSERT_NO_FATAL_FAILURE ( ToggleBrowserFullscreen ( true ) ) ;\n AddTabAtIndex ( 0 , GURL ( url : : kAboutBlankURL ) , PAGE_TRANSITION_TYPED ) ;\n ASSERT_NO_FATAL_FAILURE ( ToggleTabFullscreen ( true ) ) ;\n ASSERT_NO_FATAL_FAILURE ( ToggleBrowserFullscreen ( false ) ) ;\n ASSERT_FALSE ( browser ( ) -> window ( ) -> IsFullscreen ( ) ) ;\n }", "idx": 2054}
{"hash": -3053641395158209010, "project": "debian", "size": 51, "label": 0, "functionSource": "static int x ( struct vcache * avc , int afun , struct vrequest * areq , \\ struct afs_pdata * ain , struct afs_pdata * aout , \\ afs_ucred_t * * acred ) DECL_PIOCTL ( PGetFID ) ;\n DECL_PIOCTL ( PSetAcl ) ;\n DECL_PIOCTL ( PStoreBehind ) ;\n DECL_PIOCTL ( PGCPAGs ) ;\n DECL_PIOCTL ( PGetAcl ) ;\n DECL_PIOCTL ( PNoop ) ;\n DECL_PIOCTL ( PBogus ) ;\n DECL_PIOCTL ( PGetFileCell ) ;\n DECL_PIOCTL ( PGetWSCell ) ;\n DECL_PIOCTL ( PGetUserCell ) ;\n DECL_PIOCTL ( PSetTokens ) ;\n DECL_PIOCTL ( PGetVolumeStatus ) ;\n DECL_PIOCTL ( PSetVolumeStatus ) ;\n DECL_PIOCTL ( PFlush ) ;\n DECL_PIOCTL ( PNewStatMount ) ;\n DECL_PIOCTL ( PGetTokens ) ;\n DECL_PIOCTL ( PUnlog ) ;\n DECL_PIOCTL ( PMariner ) ;\n DECL_PIOCTL ( PCheckServers ) ;\n DECL_PIOCTL ( PCheckVolNames ) ;\n DECL_PIOCTL ( PCheckAuth ) ;\n DECL_PIOCTL ( PFindVolume ) ;\n DECL_PIOCTL ( PViceAccess ) ;\n DECL_PIOCTL ( PSetCacheSize ) ;\n DECL_PIOCTL ( PGetCacheSize ) ;\n DECL_PIOCTL ( PRemoveCallBack ) ;\n DECL_PIOCTL ( PNewCell ) ;\n DECL_PIOCTL ( PNewAlias ) ;\n DECL_PIOCTL ( PListCells ) ;\n DECL_PIOCTL ( PListAliases ) ;\n DECL_PIOCTL ( PRemoveMount ) ;\n DECL_PIOCTL ( PGetCellStatus ) ;\n DECL_PIOCTL ( PSetCellStatus ) ;\n DECL_PIOCTL ( PFlushVolumeData ) ;\n DECL_PIOCTL ( PFlushAllVolumeData ) ;\n DECL_PIOCTL ( PGetVnodeXStatus ) ;\n DECL_PIOCTL ( PGetVnodeXStatus2 ) ;\n DECL_PIOCTL ( PSetSysName ) ;\n DECL_PIOCTL ( PSetSPrefs ) ;\n DECL_PIOCTL ( PSetSPrefs33 ) ;\n DECL_PIOCTL ( PGetSPrefs ) ;\n DECL_PIOCTL ( PExportAfs ) ;\n DECL_PIOCTL ( PGag ) ;\n DECL_PIOCTL ( PTwiddleRx ) ;\n DECL_PIOCTL ( PGetInitParams ) ;\n DECL_PIOCTL ( PGetRxkcrypt ) ;\n DECL_PIOCTL ( PSetRxkcrypt ) ;\n DECL_PIOCTL ( PGetCPrefs ) ;\n DECL_PIOCTL ( PSetCPrefs ) ;\n DECL_PIOCTL ( PFlushMount ) ;\n DECL_PIOCTL ( PRxStatProc )", "idx": 2055}
{"hash": 7549435794356072684, "project": "debian", "size": 4, "label": 0, "functionSource": "static VALUE ossl_asn1_ ## klass ( int argc , VALUE * argv , VALUE self ) \\ {\n return rb_funcall3 ( cASN1 ## klass , rb_intern ( \"new\" ) , argc , argv ) ;\n }\n OSSL_ASN1_IMPL_FACTORY_METHOD ( Boolean ) OSSL_ASN1_IMPL_FACTORY_METHOD ( Integer ) OSSL_ASN1_IMPL_FACTORY_METHOD ( Enumerated ) OSSL_ASN1_IMPL_FACTORY_METHOD ( BitString ) OSSL_ASN1_IMPL_FACTORY_METHOD ( OctetString ) OSSL_ASN1_IMPL_FACTORY_METHOD ( UTF8String ) OSSL_ASN1_IMPL_FACTORY_METHOD ( NumericString ) OSSL_ASN1_IMPL_FACTORY_METHOD ( PrintableString ) OSSL_ASN1_IMPL_FACTORY_METHOD ( T61String ) OSSL_ASN1_IMPL_FACTORY_METHOD ( VideotexString ) OSSL_ASN1_IMPL_FACTORY_METHOD ( IA5String ) OSSL_ASN1_IMPL_FACTORY_METHOD ( GraphicString ) OSSL_ASN1_IMPL_FACTORY_METHOD ( ISO64String ) OSSL_ASN1_IMPL_FACTORY_METHOD ( GeneralString ) OSSL_ASN1_IMPL_FACTORY_METHOD ( UniversalString ) OSSL_ASN1_IMPL_FACTORY_METHOD ( BMPString ) OSSL_ASN1_IMPL_FACTORY_METHOD ( Null ) OSSL_ASN1_IMPL_FACTORY_METHOD ( ObjectId )", "idx": 2056}
{"hash": 3616225660295849566, "project": "debian", "size": 9, "label": 0, "functionSource": "gboolean logcat_text_process_dump_open ( wtap_dumper * wdh , int * err _U_ ) {\n struct dumper_t * dumper ;\n dumper = ( struct dumper_t * ) g_malloc ( sizeof ( struct dumper_t ) ) ;\n dumper -> type = DUMP_PROCESS ;\n wdh -> priv = dumper ;\n wdh -> subtype_write = logcat_dump_text ;\n wdh -> subtype_close = NULL ;\n return TRUE ;\n }", "idx": 2057}
{"hash": 3887066622454352196, "project": "chrome", "size": 233, "label": 0, "functionSource": "static int64_t handle_inter_mode ( VP9_COMP * cpi , MACROBLOCK * x , BLOCK_SIZE bsize , int64_t txfm_cache [ ] , int * rate2 , int64_t * distortion , int * skippable , int * rate_y , int64_t * distortion_y , int * rate_uv , int64_t * distortion_uv , int * disable_skip , int_mv ( * mode_mv ) [ MAX_REF_FRAMES ] , int mi_row , int mi_col , int_mv single_newmv [ MAX_REF_FRAMES ] , INTERP_FILTER ( * single_filter ) [ MAX_REF_FRAMES ] , int ( * single_skippable ) [ MAX_REF_FRAMES ] , int64_t * psse , const int64_t ref_best_rd ) {\n VP9_COMMON * cm = & cpi -> common ;\n RD_OPT * rd_opt = & cpi -> rd ;\n MACROBLOCKD * xd = & x -> e_mbd ;\n MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] . src_mi -> mbmi ;\n const int is_comp_pred = has_second_ref ( mbmi ) ;\n const int this_mode = mbmi -> mode ;\n int_mv * frame_mv = mode_mv [ this_mode ] ;\n int i ;\n int refs [ 2 ] = {\n mbmi -> ref_frame [ 0 ] , ( mbmi -> ref_frame [ 1 ] < 0 ? 0 : mbmi -> ref_frame [ 1 ] ) }\n ;\n int_mv cur_mv [ 2 ] ;\n int64_t this_rd = 0 ;\n DECLARE_ALIGNED_ARRAY ( 16 , uint8_t , tmp_buf , MAX_MB_PLANE * 64 * 64 ) ;\n int pred_exists = 0 ;\n int intpel_mv ;\n int64_t rd , tmp_rd , best_rd = INT64_MAX ;\n int best_needs_copy = 0 ;\n uint8_t * orig_dst [ MAX_MB_PLANE ] ;\n int orig_dst_stride [ MAX_MB_PLANE ] ;\n int rs = 0 ;\n INTERP_FILTER best_filter = SWITCHABLE ;\n uint8_t skip_txfm [ MAX_MB_PLANE << 2 ] = {\n 0 }\n ;\n int64_t bsse [ MAX_MB_PLANE << 2 ] = {\n 0 }\n ;\n int bsl = mi_width_log2_lookup [ bsize ] ;\n int pred_filter_search = cpi -> sf . cb_pred_filter_search ? ( ( ( mi_row + mi_col ) >> bsl ) + get_chessboard_index ( cm -> current_video_frame ) ) & 0x1 : 0 ;\n if ( pred_filter_search ) {\n INTERP_FILTER af = SWITCHABLE , lf = SWITCHABLE ;\n if ( xd -> up_available ) af = xd -> mi [ - xd -> mi_stride ] . src_mi -> mbmi . interp_filter ;\n if ( xd -> left_available ) lf = xd -> mi [ - 1 ] . src_mi -> mbmi . interp_filter ;\n if ( ( this_mode != NEWMV ) || ( af == lf ) ) best_filter = af ;\n }\n if ( is_comp_pred ) {\n if ( frame_mv [ refs [ 0 ] ] . as_int == INVALID_MV || frame_mv [ refs [ 1 ] ] . as_int == INVALID_MV ) return INT64_MAX ;\n if ( cpi -> sf . adaptive_mode_search ) {\n if ( single_filter [ this_mode ] [ refs [ 0 ] ] == single_filter [ this_mode ] [ refs [ 1 ] ] ) best_filter = single_filter [ this_mode ] [ refs [ 0 ] ] ;\n }\n }\n if ( this_mode == NEWMV ) {\n int rate_mv ;\n if ( is_comp_pred ) {\n frame_mv [ refs [ 0 ] ] . as_int = single_newmv [ refs [ 0 ] ] . as_int ;\n frame_mv [ refs [ 1 ] ] . as_int = single_newmv [ refs [ 1 ] ] . as_int ;\n if ( cpi -> sf . comp_inter_joint_search_thresh <= bsize ) {\n joint_motion_search ( cpi , x , bsize , frame_mv , mi_row , mi_col , single_newmv , & rate_mv ) ;\n }\n else {\n rate_mv = vp9_mv_bit_cost ( & frame_mv [ refs [ 0 ] ] . as_mv , & mbmi -> ref_mvs [ refs [ 0 ] ] [ 0 ] . as_mv , x -> nmvjointcost , x -> mvcost , MV_COST_WEIGHT ) ;\n rate_mv += vp9_mv_bit_cost ( & frame_mv [ refs [ 1 ] ] . as_mv , & mbmi -> ref_mvs [ refs [ 1 ] ] [ 0 ] . as_mv , x -> nmvjointcost , x -> mvcost , MV_COST_WEIGHT ) ;\n }\n * rate2 += rate_mv ;\n }\n else {\n int_mv tmp_mv ;\n single_motion_search ( cpi , x , bsize , mi_row , mi_col , & tmp_mv , & rate_mv ) ;\n if ( tmp_mv . as_int == INVALID_MV ) return INT64_MAX ;\n * rate2 += rate_mv ;\n frame_mv [ refs [ 0 ] ] . as_int = xd -> mi [ 0 ] . src_mi -> bmi [ 0 ] . as_mv [ 0 ] . as_int = tmp_mv . as_int ;\n single_newmv [ refs [ 0 ] ] . as_int = tmp_mv . as_int ;\n }\n }\n for ( i = 0 ;\n i < is_comp_pred + 1 ;\n ++ i ) {\n cur_mv [ i ] = frame_mv [ refs [ i ] ] ;\n if ( this_mode != NEWMV ) clamp_mv2 ( & cur_mv [ i ] . as_mv , xd ) ;\n if ( mv_check_bounds ( x , & cur_mv [ i ] . as_mv ) ) return INT64_MAX ;\n mbmi -> mv [ i ] . as_int = cur_mv [ i ] . as_int ;\n }\n for ( i = 0 ;\n i < MAX_MB_PLANE ;\n i ++ ) {\n orig_dst [ i ] = xd -> plane [ i ] . dst . buf ;\n orig_dst_stride [ i ] = xd -> plane [ i ] . dst . stride ;\n }\n * rate2 += cost_mv_ref ( cpi , this_mode , mbmi -> mode_context [ refs [ 0 ] ] ) ;\n if ( RDCOST ( x -> rdmult , x -> rddiv , * rate2 , 0 ) > ref_best_rd && mbmi -> mode != NEARESTMV ) return INT64_MAX ;\n pred_exists = 0 ;\n intpel_mv = ! mv_has_subpel ( & mbmi -> mv [ 0 ] . as_mv ) ;\n if ( is_comp_pred ) intpel_mv &= ! mv_has_subpel ( & mbmi -> mv [ 1 ] . as_mv ) ;\n rd_opt -> mask_filter = 0 ;\n for ( i = 0 ;\n i < SWITCHABLE_FILTER_CONTEXTS ;\n ++ i ) rd_opt -> filter_cache [ i ] = INT64_MAX ;\n if ( cm -> interp_filter != BILINEAR ) {\n if ( x -> source_variance < cpi -> sf . disable_filter_search_var_thresh ) {\n best_filter = EIGHTTAP ;\n }\n else if ( best_filter == SWITCHABLE ) {\n int newbest ;\n int tmp_rate_sum = 0 ;\n int64_t tmp_dist_sum = 0 ;\n for ( i = 0 ;\n i < SWITCHABLE_FILTERS ;\n ++ i ) {\n int j ;\n int64_t rs_rd ;\n mbmi -> interp_filter = i ;\n rs = vp9_get_switchable_rate ( cpi ) ;\n rs_rd = RDCOST ( x -> rdmult , x -> rddiv , rs , 0 ) ;\n if ( i > 0 && intpel_mv ) {\n rd = RDCOST ( x -> rdmult , x -> rddiv , tmp_rate_sum , tmp_dist_sum ) ;\n rd_opt -> filter_cache [ i ] = rd ;\n rd_opt -> filter_cache [ SWITCHABLE_FILTERS ] = MIN ( rd_opt -> filter_cache [ SWITCHABLE_FILTERS ] , rd + rs_rd ) ;\n if ( cm -> interp_filter == SWITCHABLE ) rd += rs_rd ;\n rd_opt -> mask_filter = MAX ( rd_opt -> mask_filter , rd ) ;\n }\n else {\n int rate_sum = 0 ;\n int64_t dist_sum = 0 ;\n if ( i > 0 && cpi -> sf . adaptive_interp_filter_search && ( cpi -> sf . interp_filter_search_mask & ( 1 << i ) ) ) {\n rate_sum = INT_MAX ;\n dist_sum = INT64_MAX ;\n continue ;\n }\n if ( ( cm -> interp_filter == SWITCHABLE && ( ! i || best_needs_copy ) ) || ( cm -> interp_filter != SWITCHABLE && ( cm -> interp_filter == mbmi -> interp_filter || ( i == 0 && intpel_mv ) ) ) ) {\n restore_dst_buf ( xd , orig_dst , orig_dst_stride ) ;\n }\n else {\n for ( j = 0 ;\n j < MAX_MB_PLANE ;\n j ++ ) {\n xd -> plane [ j ] . dst . buf = tmp_buf + j * 64 * 64 ;\n xd -> plane [ j ] . dst . stride = 64 ;\n }\n }\n vp9_build_inter_predictors_sb ( xd , mi_row , mi_col , bsize ) ;\n model_rd_for_sb ( cpi , bsize , x , xd , & rate_sum , & dist_sum ) ;\n rd = RDCOST ( x -> rdmult , x -> rddiv , rate_sum , dist_sum ) ;\n rd_opt -> filter_cache [ i ] = rd ;\n rd_opt -> filter_cache [ SWITCHABLE_FILTERS ] = MIN ( rd_opt -> filter_cache [ SWITCHABLE_FILTERS ] , rd + rs_rd ) ;\n if ( cm -> interp_filter == SWITCHABLE ) rd += rs_rd ;\n rd_opt -> mask_filter = MAX ( rd_opt -> mask_filter , rd ) ;\n if ( i == 0 && intpel_mv ) {\n tmp_rate_sum = rate_sum ;\n tmp_dist_sum = dist_sum ;\n }\n }\n if ( i == 0 && cpi -> sf . use_rd_breakout && ref_best_rd < INT64_MAX ) {\n if ( rd / 2 > ref_best_rd ) {\n restore_dst_buf ( xd , orig_dst , orig_dst_stride ) ;\n return INT64_MAX ;\n }\n }\n newbest = i == 0 || rd < best_rd ;\n if ( newbest ) {\n best_rd = rd ;\n best_filter = mbmi -> interp_filter ;\n if ( cm -> interp_filter == SWITCHABLE && i && ! intpel_mv ) best_needs_copy = ! best_needs_copy ;\n vpx_memcpy ( skip_txfm , x -> skip_txfm , sizeof ( skip_txfm ) ) ;\n vpx_memcpy ( bsse , x -> bsse , sizeof ( bsse ) ) ;\n }\n if ( ( cm -> interp_filter == SWITCHABLE && newbest ) || ( cm -> interp_filter != SWITCHABLE && cm -> interp_filter == mbmi -> interp_filter ) ) {\n pred_exists = 1 ;\n tmp_rd = best_rd ;\n }\n }\n restore_dst_buf ( xd , orig_dst , orig_dst_stride ) ;\n }\n }\n mbmi -> interp_filter = cm -> interp_filter != SWITCHABLE ? cm -> interp_filter : best_filter ;\n rs = cm -> interp_filter == SWITCHABLE ? vp9_get_switchable_rate ( cpi ) : 0 ;\n if ( pred_exists ) {\n if ( best_needs_copy ) {\n for ( i = 0 ;\n i < MAX_MB_PLANE ;\n i ++ ) {\n xd -> plane [ i ] . dst . buf = tmp_buf + i * 64 * 64 ;\n xd -> plane [ i ] . dst . stride = 64 ;\n }\n }\n rd = tmp_rd + RDCOST ( x -> rdmult , x -> rddiv , rs , 0 ) ;\n }\n else {\n int tmp_rate ;\n int64_t tmp_dist ;\n vp9_build_inter_predictors_sb ( xd , mi_row , mi_col , bsize ) ;\n model_rd_for_sb ( cpi , bsize , x , xd , & tmp_rate , & tmp_dist ) ;\n rd = RDCOST ( x -> rdmult , x -> rddiv , rs + tmp_rate , tmp_dist ) ;\n vpx_memcpy ( skip_txfm , x -> skip_txfm , sizeof ( skip_txfm ) ) ;\n vpx_memcpy ( bsse , x -> bsse , sizeof ( bsse ) ) ;\n }\n if ( ! is_comp_pred ) single_filter [ this_mode ] [ refs [ 0 ] ] = mbmi -> interp_filter ;\n if ( cpi -> sf . adaptive_mode_search ) if ( is_comp_pred ) if ( single_skippable [ this_mode ] [ refs [ 0 ] ] && single_skippable [ this_mode ] [ refs [ 1 ] ] ) vpx_memset ( skip_txfm , 1 , sizeof ( skip_txfm ) ) ;\n if ( cpi -> sf . use_rd_breakout && ref_best_rd < INT64_MAX ) {\n if ( rd / 2 > ref_best_rd ) {\n restore_dst_buf ( xd , orig_dst , orig_dst_stride ) ;\n return INT64_MAX ;\n }\n }\n if ( cm -> interp_filter == SWITCHABLE ) * rate2 += rs ;\n if ( ! is_comp_pred ) {\n if ( cpi -> allow_encode_breakout ) rd_encode_breakout_test ( cpi , x , bsize , rate2 , distortion , distortion_uv , disable_skip ) ;\n }\n vpx_memcpy ( x -> skip_txfm , skip_txfm , sizeof ( skip_txfm ) ) ;\n vpx_memcpy ( x -> bsse , bsse , sizeof ( bsse ) ) ;\n if ( ! x -> skip ) {\n int skippable_y , skippable_uv ;\n int64_t sseuv = INT64_MAX ;\n int64_t rdcosty = INT64_MAX ;\n vp9_subtract_plane ( x , bsize , 0 ) ;\n super_block_yrd ( cpi , x , rate_y , distortion_y , & skippable_y , psse , bsize , txfm_cache , ref_best_rd ) ;\n if ( * rate_y == INT_MAX ) {\n * rate2 = INT_MAX ;\n * distortion = INT64_MAX ;\n restore_dst_buf ( xd , orig_dst , orig_dst_stride ) ;\n return INT64_MAX ;\n }\n * rate2 += * rate_y ;\n * distortion += * distortion_y ;\n rdcosty = RDCOST ( x -> rdmult , x -> rddiv , * rate2 , * distortion ) ;\n rdcosty = MIN ( rdcosty , RDCOST ( x -> rdmult , x -> rddiv , 0 , * psse ) ) ;\n super_block_uvrd ( cpi , x , rate_uv , distortion_uv , & skippable_uv , & sseuv , bsize , ref_best_rd - rdcosty ) ;\n if ( * rate_uv == INT_MAX ) {\n * rate2 = INT_MAX ;\n * distortion = INT64_MAX ;\n restore_dst_buf ( xd , orig_dst , orig_dst_stride ) ;\n return INT64_MAX ;\n }\n * psse += sseuv ;\n * rate2 += * rate_uv ;\n * distortion += * distortion_uv ;\n * skippable = skippable_y && skippable_uv ;\n }\n if ( ! is_comp_pred ) single_skippable [ this_mode ] [ refs [ 0 ] ] = * skippable ;\n restore_dst_buf ( xd , orig_dst , orig_dst_stride ) ;\n return this_rd ;\n }", "idx": 2058}
{"hash": -3559021711340554904, "project": "debian", "size": 6, "label": 0, "functionSource": "int NumRelids ( Node * clause ) {\n Relids varnos = pull_varnos ( clause ) ;\n int result = bms_num_members ( varnos ) ;\n bms_free ( varnos ) ;\n return result ;\n }", "idx": 2059}
{"hash": 914926989019402478, "project": "debian", "size": 34, "label": 0, "functionSource": "static void main_get_appheader ( xd3_stream * stream , main_file * ifile , main_file * output , main_file * sfile ) {\n uint8_t * apphead ;\n usize_t appheadsz ;\n int ret ;\n if ( ! option_use_appheader ) {\n return ;\n }\n ret = xd3_get_appheader ( stream , & apphead , & appheadsz ) ;\n if ( ret != 0 ) {\n return ;\n }\n if ( appheadsz > 0 ) {\n const int kMaxArgs = 4 ;\n char * start = ( char * ) apphead ;\n char * slash ;\n int place = 0 ;\n char * parsed [ kMaxArgs ] ;\n memset ( parsed , 0 , sizeof ( parsed ) ) ;\n while ( ( slash = strchr ( start , '/' ) ) != NULL && place < ( kMaxArgs - 1 ) ) {\n * slash = 0 ;\n parsed [ place ++ ] = start ;\n start = slash + 1 ;\n }\n parsed [ place ++ ] = start ;\n if ( place == 2 || place == 4 ) {\n main_get_appheader_params ( output , parsed , 1 , \"output\" , ifile ) ;\n }\n if ( place == 4 ) {\n main_get_appheader_params ( sfile , parsed + 2 , 0 , \"source\" , ifile ) ;\n }\n }\n option_use_appheader = 0 ;\n return ;\n }", "idx": 2060}
{"hash": 1859256631654516868, "project": "chrome", "size": 5, "label": 0, "functionSource": "static void predict_field_decoding_flag ( H264Context * h ) {\n const int mb_xy = h -> mb_x + h -> mb_y * h -> mb_stride ;\n int mb_type = ( h -> slice_table [ mb_xy - 1 ] == h -> slice_num ) ? h -> cur_pic . mb_type [ mb_xy - 1 ] : ( h -> slice_table [ mb_xy - h -> mb_stride ] == h -> slice_num ) ? h -> cur_pic . mb_type [ mb_xy - h -> mb_stride ] : 0 ;\n h -> mb_mbaff = h -> mb_field_decoding_flag = IS_INTERLACED ( mb_type ) ? 1 : 0 ;\n }", "idx": 2061}
{"hash": 7092216800726729686, "project": "debian", "size": 8, "label": 0, "functionSource": "static int dissect_h245_T_rtpPayloadType ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 932 \"../../asn1/h245/h245.cnf\" unsigned int pt ;\n offset = dissect_per_constrained_integer ( tvb , offset , actx , tree , hf_index , 0U , 127U , & pt , FALSE ) ;\n if ( ( rfc_number == 2198 ) && upcoming_channel ) {\n upcoming_channel -> rfc2198 = pt ;\n }\n return offset ;\n }", "idx": 2062}
{"hash": 7039307292471244756, "project": "debian", "size": 6, "label": 0, "functionSource": "static guint16 de_red_party_sub_addr ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo , guint32 offset , guint len , gchar * add_string _U_ , int string_len _U_ ) {\n gchar * extr_addr ;\n de_sub_addr ( tvb , tree , pinfo , offset , len , & extr_addr ) ;\n if ( extr_addr && add_string ) g_snprintf ( add_string , string_len , \" - (%s)\" , extr_addr ) ;\n return ( len ) ;\n }", "idx": 2063}
{"hash": 1223258652239369123, "project": "debian", "size": 9, "label": 0, "functionSource": "static void spl_filesystem_dir_it_move_forward ( zend_object_iterator * iter TSRMLS_DC ) {\n spl_filesystem_object * object = spl_filesystem_iterator_to_object ( ( spl_filesystem_iterator * ) iter ) ;\n object -> u . dir . index ++ ;\n spl_filesystem_dir_read ( object TSRMLS_CC ) ;\n if ( object -> file_name ) {\n efree ( object -> file_name ) ;\n object -> file_name = NULL ;\n }\n }", "idx": 2064}
{"hash": 8484475213808847345, "project": "debian", "size": 9, "label": 0, "functionSource": "static void qbus_print ( Monitor * mon , BusState * bus , int indent ) {\n struct DeviceState * dev ;\n qdev_printf ( \"bus: %s\\n\" , bus -> name ) ;\n indent += 2 ;\n qdev_printf ( \"type %s\\n\" , bus -> info -> name ) ;\n QLIST_FOREACH ( dev , & bus -> children , sibling ) {\n qdev_print ( mon , dev , indent ) ;\n }\n }", "idx": 2065}
{"hash": -5280794106681745199, "project": "debian", "size": 33, "label": 0, "functionSource": "static gboolean gst_asf_demux_seek_index_lookup ( GstASFDemux * demux , guint * packet , GstClockTime seek_time , GstClockTime * p_idx_time , guint * speed , gboolean next , gboolean * eos ) {\n GstClockTime idx_time ;\n guint idx ;\n if ( eos ) * eos = FALSE ;\n if ( G_UNLIKELY ( demux -> sidx_num_entries == 0 || demux -> sidx_interval == 0 ) ) return FALSE ;\n idx = ( guint ) ( ( seek_time + demux -> preroll ) / demux -> sidx_interval ) ;\n if ( next ) {\n guint idx2 ;\n if ( idx >= demux -> sidx_num_entries - 1 ) {\n if ( eos ) * eos = TRUE ;\n return FALSE ;\n }\n for ( idx2 = idx + 1 ;\n idx2 < demux -> sidx_num_entries ;\n ++ idx2 ) {\n if ( demux -> sidx_entries [ idx ] . packet != demux -> sidx_entries [ idx2 ] . packet ) {\n idx = idx2 ;\n break ;\n }\n }\n }\n if ( G_UNLIKELY ( idx >= demux -> sidx_num_entries ) ) {\n if ( eos ) * eos = TRUE ;\n return FALSE ;\n }\n * packet = demux -> sidx_entries [ idx ] . packet ;\n if ( speed ) * speed = demux -> sidx_entries [ idx ] . count ;\n idx_time = demux -> sidx_interval * idx ;\n if ( G_LIKELY ( idx_time >= demux -> preroll ) ) idx_time -= demux -> preroll ;\n GST_DEBUG_OBJECT ( demux , \"%\" GST_TIME_FORMAT \" => packet %u at %\" GST_TIME_FORMAT , GST_TIME_ARGS ( seek_time ) , * packet , GST_TIME_ARGS ( idx_time ) ) ;\n if ( G_LIKELY ( p_idx_time ) ) * p_idx_time = idx_time ;\n return TRUE ;\n }", "idx": 2066}
{"hash": -7777331401175181229, "project": "debian", "size": 21, "label": 0, "functionSource": "void fe_server_init ( void ) {\n command_bind ( \"server\" , NULL , ( SIGNAL_FUNC ) cmd_server ) ;\n command_bind ( \"server connect\" , NULL , ( SIGNAL_FUNC ) cmd_server_connect ) ;\n command_bind ( \"server add\" , NULL , ( SIGNAL_FUNC ) cmd_server_add ) ;\n command_bind ( \"server modify\" , NULL , ( SIGNAL_FUNC ) cmd_server_modify ) ;\n command_bind ( \"server remove\" , NULL , ( SIGNAL_FUNC ) cmd_server_remove ) ;\n command_bind_first ( \"server\" , NULL , ( SIGNAL_FUNC ) server_command ) ;\n command_bind_first ( \"disconnect\" , NULL , ( SIGNAL_FUNC ) server_command ) ;\n command_set_options ( \"server add\" , \"4 6 !! ssl nossl +ssl_cert +ssl_pkey +ssl_pass ssl_verify nossl_verify +ssl_cafile +ssl_capath +ssl_ciphers +ssl_fingerprint tls notls +tls_cert +tls_pkey +tls_pass tls_verify notls_verify +tls_cafile +tls_capath +tls_ciphers +tls_pinned_cert +tls_pinned_pubkey auto noauto proxy noproxy -host -port noautosendcmd\" ) ;\n command_set_options ( \"server modify\" , \"4 6 !! ssl nossl +ssl_cert +ssl_pkey +ssl_pass ssl_verify nossl_verify +ssl_cafile +ssl_capath +ssl_ciphers +ssl_fingerprint tls notls +tls_cert +tls_pkey +tls_pass tls_verify notls_verify +tls_cafile +tls_capath +tls_ciphers +tls_pinned_cert +tls_pinned_pubkey auto noauto proxy noproxy -host -port noautosendcmd\" ) ;\n signal_add ( \"server looking\" , ( SIGNAL_FUNC ) sig_server_looking ) ;\n signal_add ( \"server connecting\" , ( SIGNAL_FUNC ) sig_server_connecting ) ;\n signal_add ( \"server connected\" , ( SIGNAL_FUNC ) sig_server_connected ) ;\n signal_add ( \"server connect failed\" , ( SIGNAL_FUNC ) sig_connect_failed ) ;\n signal_add ( \"server disconnected\" , ( SIGNAL_FUNC ) sig_server_disconnected ) ;\n signal_add ( \"server quit\" , ( SIGNAL_FUNC ) sig_server_quit ) ;\n signal_add ( \"server lag disconnect\" , ( SIGNAL_FUNC ) sig_server_lag_disconnected ) ;\n signal_add ( \"server reconnect remove\" , ( SIGNAL_FUNC ) sig_server_reconnect_removed ) ;\n signal_add ( \"server reconnect not found\" , ( SIGNAL_FUNC ) sig_server_reconnect_not_found ) ;\n signal_add ( \"chat protocol unknown\" , ( SIGNAL_FUNC ) sig_chat_protocol_unknown ) ;\n }", "idx": 2067}
{"hash": 7039307292471244756, "project": "debian", "size": 11, "label": 0, "functionSource": "static void dtap_cc_facility ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len ) {\n guint32 curr_offset ;\n guint32 consumed ;\n guint curr_len ;\n curr_offset = offset ;\n curr_len = len ;\n is_uplink = IS_UPLINK_TRUE ;\n ELEM_MAND_LV ( GSM_A_PDU_TYPE_DTAP , DE_FACILITY , NULL ) ;\n ELEM_OPT_TLV ( 0x7f , GSM_A_PDU_TYPE_DTAP , DE_SS_VER_IND , NULL ) ;\n EXTRANEOUS_DATA_CHECK ( curr_len , 0 , pinfo , & ei_gsm_a_dtap_extraneous_data ) ;\n }", "idx": 2068}
{"hash": 1414661670117003749, "project": "debian", "size": 14, "label": 0, "functionSource": "static int load_pack_bitmap ( void ) {\n assert ( bitmap_git . map && ! bitmap_git . loaded ) ;\n bitmap_git . bitmaps = kh_init_sha1 ( ) ;\n bitmap_git . ext_index . positions = kh_init_sha1_pos ( ) ;\n load_pack_revindex ( bitmap_git . pack ) ;\n if ( ! ( bitmap_git . commits = read_bitmap_1 ( & bitmap_git ) ) || ! ( bitmap_git . trees = read_bitmap_1 ( & bitmap_git ) ) || ! ( bitmap_git . blobs = read_bitmap_1 ( & bitmap_git ) ) || ! ( bitmap_git . tags = read_bitmap_1 ( & bitmap_git ) ) ) goto failed ;\n if ( load_bitmap_entries_v1 ( & bitmap_git ) < 0 ) goto failed ;\n bitmap_git . loaded = 1 ;\n return 0 ;\n failed : munmap ( bitmap_git . map , bitmap_git . map_size ) ;\n bitmap_git . map = NULL ;\n bitmap_git . map_size = 0 ;\n return - 1 ;\n }", "idx": 2069}
{"hash": -1487877838474751244, "project": "debian", "size": 2, "label": 0, "functionSource": "ZEND_EXTERN_MODULE_GLOBALS ( intl ) # define SEPARATOR \"_\" # define SEPARATOR1 \"-\" # define DELIMITER \"-_\" # define EXTLANG_PREFIX \"a\" # define PRIVATE_PREFIX \"x\" # define DISP_NAME \"name\" # define MAX_NO_VARIANT 15 # define MAX_NO_EXTLANG 3 # define MAX_NO_PRIVATE 15 # define MAX_NO_LOOKUP_LANG_TAG 100 # define LOC_NOT_FOUND 1 # define VARIANT_KEYNAME_LEN 11 # define EXTLANG_KEYNAME_LEN 10 # define PRIVATE_KEYNAME_LEN 11 static const char * const LOC_GRANDFATHERED [ ] = {\n \"art-lojban\" , \"i-klingon\" , \"i-lux\" , \"i-navajo\" , \"no-bok\" , \"no-nyn\" , \"cel-gaulish\" , \"en-GB-oed\" , \"i-ami\" , \"i-bnn\" , \"i-default\" , \"i-enochian\" , \"i-mingo\" , \"i-pwn\" , \"i-tao\" , \"i-tay\" , \"i-tsu\" , \"sgn-BE-fr\" , \"sgn-BE-nl\" , \"sgn-CH-de\" , \"zh-cmn\" , \"zh-cmn-Hans\" , \"zh-cmn-Hant\" , \"zh-gan\" , \"zh-guoyu\" , \"zh-hakka\" , \"zh-min\" , \"zh-min-nan\" , \"zh-wuu\" , \"zh-xiang\" , \"zh-yue\" , NULL }", "idx": 2070}
{"hash": 1182028467273264883, "project": "debian", "size": 23, "label": 0, "functionSource": "void do_chmod_file ( struct st_command * command ) {\n long mode = 0 ;\n int err_code ;\n static DYNAMIC_STRING ds_mode ;\n static DYNAMIC_STRING ds_file ;\n const struct command_arg chmod_file_args [ ] = {\n {\n \"mode\" , ARG_STRING , TRUE , & ds_mode , \"Mode of file(octal) ex. 0660\" }\n , {\n \"filename\" , ARG_STRING , TRUE , & ds_file , \"Filename of file to modify\" }\n }\n ;\n DBUG_ENTER ( \"do_chmod_file\" ) ;\n check_command_args ( command , command -> first_argument , chmod_file_args , sizeof ( chmod_file_args ) / sizeof ( struct command_arg ) , ' ' ) ;\n if ( ds_mode . length != 4 || str2int ( ds_mode . str , 8 , 0 , INT_MAX , & mode ) == NullS ) die ( \"You must write a 4 digit octal number for mode\" ) ;\n DBUG_PRINT ( \"info\" , ( \"chmod %o %s\" , ( uint ) mode , ds_file . str ) ) ;\n err_code = chmod ( ds_file . str , mode ) ;\n if ( err_code < 0 ) err_code = 1 ;\n handle_command_error ( command , err_code , errno ) ;\n dynstr_free ( & ds_mode ) ;\n dynstr_free ( & ds_file ) ;\n DBUG_VOID_RETURN ;\n }", "idx": 2071}
{"hash": -2423144171479606949, "project": "debian", "size": 4, "label": 0, "functionSource": "static void pdf_run_S ( fz_context * ctx , pdf_processor * proc ) {\n pdf_run_processor * pr = ( pdf_run_processor * ) proc ;\n pdf_show_path ( ctx , pr , 0 , 0 , 1 , 0 ) ;\n }", "idx": 2072}
{"hash": 6667142528452941476, "project": "debian", "size": 113, "label": 1, "functionSource": "static my_bool get_view_structure ( char * table , char * db ) {\n MYSQL_RES * table_res ;\n MYSQL_ROW row ;\n MYSQL_FIELD * field ;\n char * result_table , * opt_quoted_table ;\n char table_buff [ NAME_LEN * 2 + 3 ] ;\n char table_buff2 [ NAME_LEN * 2 + 3 ] ;\n char query [ QUERY_LENGTH ] ;\n FILE * sql_file = md_result_file ;\n DBUG_ENTER ( \"get_view_structure\" ) ;\n if ( opt_no_create_info ) DBUG_RETURN ( 0 ) ;\n verbose_msg ( \"-- Retrieving view structure for table %s...\\n\" , table ) ;\n # ifdef NOT_REALLY_USED_YET dynstr_append_checked ( & insert_pat , \"SET SQL_QUOTE_SHOW_CREATE=\" ) ;\n dynstr_append_checked ( & insert_pat , ( opt_quoted || opt_keywords ) ? \"1\" : \"0\" ) ;\n # endif result_table = quote_name ( table , table_buff , 1 ) ;\n opt_quoted_table = quote_name ( table , table_buff2 , 0 ) ;\n if ( switch_character_set_results ( mysql , \"binary\" ) ) DBUG_RETURN ( 1 ) ;\n my_snprintf ( query , sizeof ( query ) , \"SHOW CREATE TABLE %s\" , result_table ) ;\n if ( mysql_query_with_error_report ( mysql , & table_res , query ) ) {\n switch_character_set_results ( mysql , default_charset ) ;\n DBUG_RETURN ( 0 ) ;\n }\n field = mysql_fetch_field_direct ( table_res , 0 ) ;\n if ( strcmp ( field -> name , \"View\" ) != 0 ) {\n mysql_free_result ( table_res ) ;\n switch_character_set_results ( mysql , default_charset ) ;\n verbose_msg ( \"-- It's base table, skipped\\n\" ) ;\n DBUG_RETURN ( 0 ) ;\n }\n if ( path ) {\n if ( ! ( sql_file = open_sql_file_for_table ( table , O_WRONLY ) ) ) {\n mysql_free_result ( table_res ) ;\n DBUG_RETURN ( 1 ) ;\n }\n write_header ( sql_file , db ) ;\n }\n print_comment ( sql_file , 0 , \"\\n--\\n-- Final view structure for view %s\\n--\\n\\n\" , result_table ) ;\n fprintf ( sql_file , \"/*!50001 DROP TABLE IF EXISTS %s*/;\n\\n\" , opt_quoted_table ) ;\n if ( opt_drop ) {\n fprintf ( sql_file , \"/*!50001 DROP VIEW IF EXISTS %s*/;\n\\n\" , opt_quoted_table ) ;\n check_io ( sql_file ) ;\n }\n my_snprintf ( query , sizeof ( query ) , \"SELECT CHECK_OPTION, DEFINER, SECURITY_TYPE, \" \" CHARACTER_SET_CLIENT, COLLATION_CONNECTION \" \"FROM information_schema.views \" \"WHERE table_name=\\\"%s\\\" AND table_schema=\\\"%s\\\"\" , table , db ) ;\n if ( mysql_query ( mysql , query ) ) {\n row = mysql_fetch_row ( table_res ) ;\n fprintf ( sql_file , \"/*!50001 %s */;\n\\n\" , row [ 1 ] ) ;\n check_io ( sql_file ) ;\n mysql_free_result ( table_res ) ;\n }\n else {\n char * ptr ;\n ulong * lengths ;\n char search_buf [ 256 ] , replace_buf [ 256 ] ;\n ulong search_len , replace_len ;\n DYNAMIC_STRING ds_view ;\n row = mysql_fetch_row ( table_res ) ;\n lengths = mysql_fetch_lengths ( table_res ) ;\n init_dynamic_string_checked ( & ds_view , row [ 1 ] , lengths [ 1 ] + 1 , 1024 ) ;\n mysql_free_result ( table_res ) ;\n if ( ! ( table_res = mysql_store_result ( mysql ) ) || ! ( row = mysql_fetch_row ( table_res ) ) ) {\n if ( table_res ) mysql_free_result ( table_res ) ;\n dynstr_free ( & ds_view ) ;\n DB_error ( mysql , \"when trying to save the result of SHOW CREATE TABLE in ds_view.\" ) ;\n DBUG_RETURN ( 1 ) ;\n }\n lengths = mysql_fetch_lengths ( table_res ) ;\n if ( strcmp ( row [ 0 ] , \"NONE\" ) ) {\n ptr = search_buf ;\n search_len = ( ulong ) ( strxmov ( ptr , \"WITH \" , row [ 0 ] , \" CHECK OPTION\" , NullS ) - ptr ) ;\n ptr = replace_buf ;\n replace_len = ( ulong ) ( strxmov ( ptr , \"*/\\n/*!50002 WITH \" , row [ 0 ] , \" CHECK OPTION\" , NullS ) - ptr ) ;\n replace ( & ds_view , search_buf , search_len , replace_buf , replace_len ) ;\n }\n {\n size_t user_name_len ;\n char user_name_str [ USERNAME_LENGTH + 1 ] ;\n char quoted_user_name_str [ USERNAME_LENGTH * 2 + 3 ] ;\n size_t host_name_len ;\n char host_name_str [ HOSTNAME_LENGTH + 1 ] ;\n char quoted_host_name_str [ HOSTNAME_LENGTH * 2 + 3 ] ;\n parse_user ( row [ 1 ] , lengths [ 1 ] , user_name_str , & user_name_len , host_name_str , & host_name_len ) ;\n ptr = search_buf ;\n search_len = ( ulong ) ( strxmov ( ptr , \"DEFINER=\" , quote_name ( user_name_str , quoted_user_name_str , FALSE ) , \"@\" , quote_name ( host_name_str , quoted_host_name_str , FALSE ) , \" SQL SECURITY \" , row [ 2 ] , NullS ) - ptr ) ;\n ptr = replace_buf ;\n replace_len = ( ulong ) ( strxmov ( ptr , \"*/\\n/*!50013 DEFINER=\" , quote_name ( user_name_str , quoted_user_name_str , FALSE ) , \"@\" , quote_name ( host_name_str , quoted_host_name_str , FALSE ) , \" SQL SECURITY \" , row [ 2 ] , \" */\\n/*!50001\" , NullS ) - ptr ) ;\n replace ( & ds_view , search_buf , search_len , replace_buf , replace_len ) ;\n }\n fprintf ( sql_file , \"/*!50001 SET @saved_cs_client = @@character_set_client */;\n\\n\" \"/*!50001 SET @saved_cs_results = @@character_set_results */;\n\\n\" \"/*!50001 SET @saved_col_connection = @@collation_connection */;\n\\n\" \"/*!50001 SET character_set_client = %s */;\n\\n\" \"/*!50001 SET character_set_results = %s */;\n\\n\" \"/*!50001 SET collation_connection = %s */;\n\\n\" \"/*!50001 %s */;\n\\n\" \"/*!50001 SET character_set_client = @saved_cs_client */;\n\\n\" \"/*!50001 SET character_set_results = @saved_cs_results */;\n\\n\" \"/*!50001 SET collation_connection = @saved_col_connection */;\n\\n\" , ( const char * ) row [ 3 ] , ( const char * ) row [ 3 ] , ( const char * ) row [ 4 ] , ( const char * ) ds_view . str ) ;\n check_io ( sql_file ) ;\n mysql_free_result ( table_res ) ;\n dynstr_free ( & ds_view ) ;\n }\n if ( switch_character_set_results ( mysql , default_charset ) ) DBUG_RETURN ( 1 ) ;\n if ( sql_file != md_result_file ) {\n fputs ( \"\\n\" , sql_file ) ;\n write_footer ( sql_file ) ;\n my_fclose ( sql_file , MYF ( MY_WME ) ) ;\n }\n DBUG_RETURN ( 0 ) ;\n }", "idx": 2073}
{"hash": 1415862279747793542, "project": "chrome", "size": 30, "label": 0, "functionSource": "static void udev_hotplug_event ( struct udev_device * udev_dev ) {\n const char * udev_action ;\n const char * sys_name = NULL ;\n uint8_t busnum = 0 , devaddr = 0 ;\n int detached ;\n int r ;\n do {\n udev_action = device : : udev_device_get_action ( udev_dev ) ;\n if ( ! udev_action ) {\n break ;\n }\n detached = ! strncmp ( udev_action , \"remove\" , 6 ) ;\n r = udev_device_info ( NULL , detached , udev_dev , & busnum , & devaddr , & sys_name ) ;\n if ( LIBUSB_SUCCESS != r ) {\n break ;\n }\n usbi_dbg ( \"udev hotplug event. action: %s.\" , udev_action ) ;\n if ( strncmp ( udev_action , \"add\" , 3 ) == 0 ) {\n linux_hotplug_enumerate ( busnum , devaddr , sys_name ) ;\n }\n else if ( detached ) {\n linux_device_disconnected ( busnum , devaddr , sys_name ) ;\n }\n else {\n usbi_err ( NULL , \"ignoring udev action %s\" , udev_action ) ;\n }\n }\n while ( 0 ) ;\n device : : udev_device_unref ( udev_dev ) ;\n }", "idx": 2074}
{"hash": -5706788925640467782, "project": "chrome", "size": 6, "label": 0, "functionSource": "static TX_MODE select_tx_mode ( const VP9_COMP * cpi ) {\n if ( cpi -> mb . e_mbd . lossless ) return ONLY_4X4 ;\n if ( cpi -> sf . tx_size_search_method == USE_LARGESTALL ) return ALLOW_32X32 ;\n else if ( cpi -> sf . tx_size_search_method == USE_FULL_RD || cpi -> sf . tx_size_search_method == USE_TX_8X8 ) return TX_MODE_SELECT ;\n else return cpi -> common . tx_mode ;\n }", "idx": 2075}
{"hash": 6632536031698733342, "project": "debian", "size": 13, "label": 0, "functionSource": "static void clear_log ( int need_lock ) {\n int i ;\n if ( need_lock ) pthread_mutex_lock ( & log_mutex ) ;\n for ( i = 0 ;\n i < log_buffer_size ;\n i ++ ) {\n av_freep ( & log_buffer [ i ] . context_name ) ;\n av_freep ( & log_buffer [ i ] . parent_name ) ;\n av_freep ( & log_buffer [ i ] . log_message ) ;\n }\n log_buffer_size = 0 ;\n if ( need_lock ) pthread_mutex_unlock ( & log_mutex ) ;\n }", "idx": 2076}
{"hash": -2607754285145856562, "project": "debian", "size": 21, "label": 0, "functionSource": "static int wb_write_to_temp ( struct archive_write * a , const void * buff , size_t s ) {\n const char * xp = buff ;\n size_t xs = s ;\n if ( wb_remaining ( a ) == wb_buffmax ( ) && s > ( 1024 * 16 ) ) {\n struct iso9660 * iso9660 = ( struct iso9660 * ) a -> format_data ;\n xs = s % LOGICAL_BLOCK_SIZE ;\n iso9660 -> wbuff_offset += s - xs ;\n if ( write_to_temp ( a , buff , s - xs ) != ARCHIVE_OK ) return ( ARCHIVE_FATAL ) ;\n if ( xs == 0 ) return ( ARCHIVE_OK ) ;\n xp += s - xs ;\n }\n while ( xs ) {\n size_t size = xs ;\n if ( size > wb_remaining ( a ) ) size = wb_remaining ( a ) ;\n memcpy ( wb_buffptr ( a ) , xp , size ) ;\n if ( wb_consume ( a , size ) != ARCHIVE_OK ) return ( ARCHIVE_FATAL ) ;\n xs -= size ;\n xp += size ;\n }\n return ( ARCHIVE_OK ) ;\n }", "idx": 2077}
{"hash": 6752827389510428348, "project": "chrome", "size": 26, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( ClientHintsBrowserTest , ClientHintsLifetimeNotAttachedCookiesBlocked ) {\n base : : HistogramTester histogram_tester ;\n ContentSettingsForOneType host_settings ;\n HostContentSettingsMapFactory : : GetForProfile ( browser ( ) -> profile ( ) ) -> GetSettingsForOneType ( CONTENT_SETTINGS_TYPE_CLIENT_HINTS , std : : string ( ) , & host_settings ) ;\n EXPECT_EQ ( 0u , host_settings . size ( ) ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , accept_ch_with_lifetime_url ( ) ) ;\n histogram_tester . ExpectUniqueSample ( \"ClientHints.UpdateEventCount\" , 1 , 1 ) ;\n content : : FetchHistogramsFromChildProcesses ( ) ;\n SubprocessMetricsProvider : : MergeHistogramDeltasForTesting ( ) ;\n histogram_tester . ExpectUniqueSample ( \"ClientHints.UpdateSize\" , 3 , 1 ) ;\n histogram_tester . ExpectUniqueSample ( \"ClientHints.PersistDuration\" , * 1000 , 1 ) ;\n base : : RunLoop ( ) . RunUntilIdle ( ) ;\n HostContentSettingsMapFactory : : GetForProfile ( browser ( ) -> profile ( ) ) -> GetSettingsForOneType ( CONTENT_SETTINGS_TYPE_CLIENT_HINTS , std : : string ( ) , & host_settings ) ;\n EXPECT_EQ ( 1u , host_settings . size ( ) ) ;\n HostContentSettingsMapFactory : : GetForProfile ( browser ( ) -> profile ( ) ) -> SetContentSettingDefaultScope ( accept_ch_without_lifetime_url ( ) , GURL ( ) , CONTENT_SETTINGS_TYPE_COOKIES , std : : string ( ) , CONTENT_SETTING_BLOCK ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , without_accept_ch_without_lifetime_url ( ) ) ;\n EXPECT_EQ ( 0u , count_client_hints_headers_seen ( ) ) ;\n VerifyContentSettingsNotNotified ( ) ;\n HostContentSettingsMapFactory : : GetForProfile ( browser ( ) -> profile ( ) ) -> SetContentSettingDefaultScope ( accept_ch_without_lifetime_url ( ) , GURL ( ) , CONTENT_SETTINGS_TYPE_COOKIES , std : : string ( ) , CONTENT_SETTING_ALLOW ) ;\n SetClientHintExpectationsOnMainFrame ( true ) ;\n SetClientHintExpectationsOnSubresources ( true ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , without_accept_ch_without_lifetime_url ( ) ) ;\n # if defined ( OS_ANDROID ) EXPECT_EQ ( 4u , count_client_hints_headers_seen ( ) ) ;\n # else EXPECT_EQ ( 6u , count_client_hints_headers_seen ( ) ) ;\n # endif HostContentSettingsMapFactory : : GetForProfile ( browser ( ) -> profile ( ) ) -> ClearSettingsForOneType ( CONTENT_SETTINGS_TYPE_COOKIES ) ;\n }", "idx": 2078}
{"hash": 8436997111466619903, "project": "debian", "size": 141, "label": 1, "functionSource": "void ff_h263_encode_mb ( MpegEncContext * s , int16_t block [ 6 ] [ 64 ] , int motion_x , int motion_y ) {\n int cbpc , cbpy , i , cbp , pred_x , pred_y ;\n int16_t pred_dc ;\n int16_t rec_intradc [ 6 ] ;\n int16_t * dc_ptr [ 6 ] ;\n const int interleaved_stats = ( s -> flags & CODEC_FLAG_PASS1 ) ;\n if ( ! s -> mb_intra ) {\n cbp = get_p_cbp ( s , block , motion_x , motion_y ) ;\n if ( ( cbp | motion_x | motion_y | s -> dquant | ( s -> mv_type - MV_TYPE_16X16 ) ) == 0 ) {\n put_bits ( & s -> pb , 1 , 1 ) ;\n if ( interleaved_stats ) {\n s -> misc_bits ++ ;\n s -> last_bits ++ ;\n }\n s -> skip_count ++ ;\n return ;\n }\n put_bits ( & s -> pb , 1 , 0 ) ;\n cbpc = cbp & 3 ;\n cbpy = cbp >> 2 ;\n if ( s -> alt_inter_vlc == 0 || cbpc != 3 ) cbpy ^= 0xF ;\n if ( s -> dquant ) cbpc += 8 ;\n if ( s -> mv_type == MV_TYPE_16X16 ) {\n put_bits ( & s -> pb , ff_h263_inter_MCBPC_bits [ cbpc ] , ff_h263_inter_MCBPC_code [ cbpc ] ) ;\n put_bits ( & s -> pb , ff_h263_cbpy_tab [ cbpy ] [ 1 ] , ff_h263_cbpy_tab [ cbpy ] [ 0 ] ) ;\n if ( s -> dquant ) put_bits ( & s -> pb , 2 , dquant_code [ s -> dquant + 2 ] ) ;\n if ( interleaved_stats ) {\n s -> misc_bits += get_bits_diff ( s ) ;\n }\n ff_h263_pred_motion ( s , 0 , 0 , & pred_x , & pred_y ) ;\n if ( ! s -> umvplus ) {\n ff_h263_encode_motion_vector ( s , motion_x - pred_x , motion_y - pred_y , 1 ) ;\n }\n else {\n h263p_encode_umotion ( s , motion_x - pred_x ) ;\n h263p_encode_umotion ( s , motion_y - pred_y ) ;\n if ( ( ( motion_x - pred_x ) == 1 ) && ( ( motion_y - pred_y ) == 1 ) ) put_bits ( & s -> pb , 1 , 1 ) ;\n }\n }\n else {\n put_bits ( & s -> pb , ff_h263_inter_MCBPC_bits [ cbpc + 16 ] , ff_h263_inter_MCBPC_code [ cbpc + 16 ] ) ;\n put_bits ( & s -> pb , ff_h263_cbpy_tab [ cbpy ] [ 1 ] , ff_h263_cbpy_tab [ cbpy ] [ 0 ] ) ;\n if ( s -> dquant ) put_bits ( & s -> pb , 2 , dquant_code [ s -> dquant + 2 ] ) ;\n if ( interleaved_stats ) {\n s -> misc_bits += get_bits_diff ( s ) ;\n }\n for ( i = 0 ;\n i < 4 ;\n i ++ ) {\n ff_h263_pred_motion ( s , i , 0 , & pred_x , & pred_y ) ;\n motion_x = s -> current_picture . f . motion_val [ 0 ] [ s -> block_index [ i ] ] [ 0 ] ;\n motion_y = s -> current_picture . f . motion_val [ 0 ] [ s -> block_index [ i ] ] [ 1 ] ;\n if ( ! s -> umvplus ) {\n ff_h263_encode_motion_vector ( s , motion_x - pred_x , motion_y - pred_y , 1 ) ;\n }\n else {\n h263p_encode_umotion ( s , motion_x - pred_x ) ;\n h263p_encode_umotion ( s , motion_y - pred_y ) ;\n if ( ( ( motion_x - pred_x ) == 1 ) && ( ( motion_y - pred_y ) == 1 ) ) put_bits ( & s -> pb , 1 , 1 ) ;\n }\n }\n }\n if ( interleaved_stats ) {\n s -> mv_bits += get_bits_diff ( s ) ;\n }\n }\n else {\n assert ( s -> mb_intra ) ;\n cbp = 0 ;\n if ( s -> h263_aic ) {\n for ( i = 0 ;\n i < 6 ;\n i ++ ) {\n int16_t level = block [ i ] [ 0 ] ;\n int scale ;\n if ( i < 4 ) scale = s -> y_dc_scale ;\n else scale = s -> c_dc_scale ;\n pred_dc = ff_h263_pred_dc ( s , i , & dc_ptr [ i ] ) ;\n level -= pred_dc ;\n if ( level >= 0 ) level = ( level + ( scale >> 1 ) ) / scale ;\n else level = ( level - ( scale >> 1 ) ) / scale ;\n if ( level == 0 && s -> block_last_index [ i ] == 0 ) s -> block_last_index [ i ] = - 1 ;\n if ( ! s -> modified_quant ) {\n if ( level < - 127 ) level = - 127 ;\n else if ( level > 127 ) level = 127 ;\n }\n block [ i ] [ 0 ] = level ;\n rec_intradc [ i ] = scale * level + pred_dc ;\n rec_intradc [ i ] |= 1 ;\n if ( rec_intradc [ i ] < 0 ) rec_intradc [ i ] = 0 ;\n else if ( rec_intradc [ i ] > 2047 ) rec_intradc [ i ] = 2047 ;\n * dc_ptr [ i ] = rec_intradc [ i ] ;\n if ( s -> block_last_index [ i ] >= 0 ) cbp |= 1 << ( 5 - i ) ;\n }\n }\n else {\n for ( i = 0 ;\n i < 6 ;\n i ++ ) {\n if ( s -> block_last_index [ i ] >= 1 ) cbp |= 1 << ( 5 - i ) ;\n }\n }\n cbpc = cbp & 3 ;\n if ( s -> pict_type == AV_PICTURE_TYPE_I ) {\n if ( s -> dquant ) cbpc += 4 ;\n put_bits ( & s -> pb , ff_h263_intra_MCBPC_bits [ cbpc ] , ff_h263_intra_MCBPC_code [ cbpc ] ) ;\n }\n else {\n if ( s -> dquant ) cbpc += 8 ;\n put_bits ( & s -> pb , 1 , 0 ) ;\n put_bits ( & s -> pb , ff_h263_inter_MCBPC_bits [ cbpc + 4 ] , ff_h263_inter_MCBPC_code [ cbpc + 4 ] ) ;\n }\n if ( s -> h263_aic ) {\n put_bits ( & s -> pb , 1 , 0 ) ;\n }\n cbpy = cbp >> 2 ;\n put_bits ( & s -> pb , ff_h263_cbpy_tab [ cbpy ] [ 1 ] , ff_h263_cbpy_tab [ cbpy ] [ 0 ] ) ;\n if ( s -> dquant ) put_bits ( & s -> pb , 2 , dquant_code [ s -> dquant + 2 ] ) ;\n if ( interleaved_stats ) {\n s -> misc_bits += get_bits_diff ( s ) ;\n }\n }\n for ( i = 0 ;\n i < 6 ;\n i ++ ) {\n h263_encode_block ( s , block [ i ] , i ) ;\n if ( s -> h263_aic && s -> mb_intra ) {\n block [ i ] [ 0 ] = rec_intradc [ i ] ;\n }\n }\n if ( interleaved_stats ) {\n if ( ! s -> mb_intra ) {\n s -> p_tex_bits += get_bits_diff ( s ) ;\n s -> f_count ++ ;\n }\n else {\n s -> i_tex_bits += get_bits_diff ( s ) ;\n s -> i_count ++ ;\n }\n }\n }", "idx": 2079}
{"hash": -3053641395158209010, "project": "debian", "size": 53, "label": 0, "functionSource": "static int x ( struct vcache * avc , int afun , struct vrequest * areq , \\ struct afs_pdata * ain , struct afs_pdata * aout , \\ afs_ucred_t * * acred ) DECL_PIOCTL ( PGetFID ) ;\n DECL_PIOCTL ( PSetAcl ) ;\n DECL_PIOCTL ( PStoreBehind ) ;\n DECL_PIOCTL ( PGCPAGs ) ;\n DECL_PIOCTL ( PGetAcl ) ;\n DECL_PIOCTL ( PNoop ) ;\n DECL_PIOCTL ( PBogus ) ;\n DECL_PIOCTL ( PGetFileCell ) ;\n DECL_PIOCTL ( PGetWSCell ) ;\n DECL_PIOCTL ( PGetUserCell ) ;\n DECL_PIOCTL ( PSetTokens ) ;\n DECL_PIOCTL ( PGetVolumeStatus ) ;\n DECL_PIOCTL ( PSetVolumeStatus ) ;\n DECL_PIOCTL ( PFlush ) ;\n DECL_PIOCTL ( PNewStatMount ) ;\n DECL_PIOCTL ( PGetTokens ) ;\n DECL_PIOCTL ( PUnlog ) ;\n DECL_PIOCTL ( PMariner ) ;\n DECL_PIOCTL ( PCheckServers ) ;\n DECL_PIOCTL ( PCheckVolNames ) ;\n DECL_PIOCTL ( PCheckAuth ) ;\n DECL_PIOCTL ( PFindVolume ) ;\n DECL_PIOCTL ( PViceAccess ) ;\n DECL_PIOCTL ( PSetCacheSize ) ;\n DECL_PIOCTL ( PGetCacheSize ) ;\n DECL_PIOCTL ( PRemoveCallBack ) ;\n DECL_PIOCTL ( PNewCell ) ;\n DECL_PIOCTL ( PNewAlias ) ;\n DECL_PIOCTL ( PListCells ) ;\n DECL_PIOCTL ( PListAliases ) ;\n DECL_PIOCTL ( PRemoveMount ) ;\n DECL_PIOCTL ( PGetCellStatus ) ;\n DECL_PIOCTL ( PSetCellStatus ) ;\n DECL_PIOCTL ( PFlushVolumeData ) ;\n DECL_PIOCTL ( PFlushAllVolumeData ) ;\n DECL_PIOCTL ( PGetVnodeXStatus ) ;\n DECL_PIOCTL ( PGetVnodeXStatus2 ) ;\n DECL_PIOCTL ( PSetSysName ) ;\n DECL_PIOCTL ( PSetSPrefs ) ;\n DECL_PIOCTL ( PSetSPrefs33 ) ;\n DECL_PIOCTL ( PGetSPrefs ) ;\n DECL_PIOCTL ( PExportAfs ) ;\n DECL_PIOCTL ( PGag ) ;\n DECL_PIOCTL ( PTwiddleRx ) ;\n DECL_PIOCTL ( PGetInitParams ) ;\n DECL_PIOCTL ( PGetRxkcrypt ) ;\n DECL_PIOCTL ( PSetRxkcrypt ) ;\n DECL_PIOCTL ( PGetCPrefs ) ;\n DECL_PIOCTL ( PSetCPrefs ) ;\n DECL_PIOCTL ( PFlushMount ) ;\n DECL_PIOCTL ( PRxStatProc ) ;\n DECL_PIOCTL ( PRxStatPeer ) ;\n DECL_PIOCTL ( PPrefetchFromTape )", "idx": 2080}
{"hash": -7455544248455991006, "project": "debian", "size": 6, "label": 0, "functionSource": "static int kvm_put_mp_state ( X86CPU * cpu ) {\n struct kvm_mp_state mp_state = {\n . mp_state = cpu -> env . mp_state }\n ;\n return kvm_vcpu_ioctl ( CPU ( cpu ) , KVM_SET_MP_STATE , & mp_state ) ;\n }", "idx": 2081}
{"hash": -2723830976796502611, "project": "chrome", "size": 5, "label": 0, "functionSource": "static vpx_codec_err_t ctrl_set_tune_content ( vpx_codec_alg_priv_t * ctx , va_list args ) {\n struct vp9_extracfg extra_cfg = ctx -> extra_cfg ;\n extra_cfg . content = CAST ( VP9E_SET_TUNE_CONTENT , args ) ;\n return update_extra_cfg ( ctx , & extra_cfg ) ;\n }", "idx": 2082}
{"hash": -8531860357798072773, "project": "debian", "size": 3, "label": 0, "functionSource": "bool send_req_key ( node_t * to ) {\n return send_request ( to -> nexthop -> connection , \"%d %s %s\" , REQ_KEY , myself -> name , to -> name ) ;\n }", "idx": 2083}
{"hash": 4839943401171415484, "project": "chrome", "size": 25, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_P ( BrowserCloseManagerBrowserTest , MAYBE_TestBeforeUnloadMultipleSlowWindows ) {\n const int kBrowserCount = 5 ;\n const int kResposiveBrowserIndex = 2 ;\n for ( int i = 0 ;\n i < kBrowserCount ;\n i ++ ) {\n if ( i ) browsers_ . push_back ( CreateBrowser ( browser ( ) -> profile ( ) ) ) ;\n ASSERT_NO_FATAL_FAILURE ( ui_test_utils : : NavigateToURL ( browsers_ [ i ] , embedded_test_server ( ) -> GetURL ( ( i == kResposiveBrowserIndex ) ? \"/beforeunload.html\" : \"/beforeunload_slow.html\" ) ) ) ;\n }\n PrepareForDialog ( browsers_ [ kResposiveBrowserIndex ] ) ;\n RepeatedNotificationObserver cancel_observer ( chrome : : NOTIFICATION_BROWSER_CLOSE_CANCELLED , kResposiveBrowserIndex + 1 ) ;\n chrome : : CloseAllBrowsersAndQuit ( ) ;\n ASSERT_NO_FATAL_FAILURE ( CancelClose ( ) ) ;\n cancel_observer . Wait ( ) ;\n EXPECT_FALSE ( browser_shutdown : : IsTryingToQuit ( ) ) ;\n for ( int i = 0 ;\n i < kBrowserCount ;\n i ++ ) EXPECT_EQ ( 1 , browsers_ [ i ] -> tab_strip_model ( ) -> count ( ) ) ;\n RepeatedNotificationObserver close_observer ( chrome : : NOTIFICATION_BROWSER_CLOSED , kBrowserCount ) ;\n chrome : : CloseAllBrowsersAndQuit ( ) ;\n ASSERT_NO_FATAL_FAILURE ( AcceptClose ( ) ) ;\n close_observer . Wait ( ) ;\n EXPECT_TRUE ( browser_shutdown : : IsTryingToQuit ( ) ) ;\n EXPECT_TRUE ( BrowserList : : GetInstance ( ) -> empty ( ) ) ;\n }", "idx": 2084}
{"hash": -6119142299306266167, "project": "debian", "size": 18, "label": 0, "functionSource": "static int zrunandhide ( i_ctx_t * i_ctx_p ) {\n os_ptr op = osp ;\n es_ptr ep ;\n check_op ( 2 ) ;\n if ( ! r_is_array ( op - 1 ) ) return_op_typecheck ( op ) ;\n if ( ! r_has_attr ( op , a_executable ) ) return 0 ;\n check_estack ( 5 ) ;\n ep = esp += 5 ;\n make_mark_estack ( ep - 4 , es_other , err_end_runandhide ) ;\n make_op_estack ( ep - 1 , end_runandhide ) ;\n ref_assign ( ep , op ) ;\n make_int ( ep - 3 , ( int ) op [ - 1 ] . tas . type_attrs ) ;\n ref_assign ( ep - 2 , op - 1 ) ;\n r_clear_attrs ( ep - 2 , a_all ) ;\n esfile_check_cache ( ) ;\n pop ( 2 ) ;\n return o_push_estack ;\n }", "idx": 2085}
{"hash": 2068472228498230380, "project": "debian", "size": 5, "label": 0, "functionSource": "static void insert_mb_into_sb ( SuperBlock * sb , MacroBlock mb , unsigned index ) {\n uint32_t * dst = sb -> pixels32 + index + ( index & - 4 ) ;\n dst [ 0 ] = mb . pixels32 [ 0 ] ;\n dst [ 4 ] = mb . pixels32 [ 1 ] ;\n }", "idx": 2086}
{"hash": -1102844685921778700, "project": "debian", "size": 14, "label": 0, "functionSource": "static size_t utf16nbytes ( const void * _p , size_t n ) {\n size_t s ;\n const char * p , * pp ;\n if ( _p == NULL ) return ( 0 ) ;\n p = ( const char * ) _p ;\n s = 0 ;\n pp = p ;\n n >>= 1 ;\n while ( s < n && ( pp [ 0 ] || pp [ 1 ] ) ) {\n pp += 2 ;\n s ++ ;\n }\n return ( s << 1 ) ;\n }", "idx": 2087}
{"hash": 7515904800760791905, "project": "chrome", "size": 46, "label": 0, "functionSource": "static FT_Error t1_allocate_blend ( T1_Face face , FT_UInt num_designs , FT_UInt num_axis ) {\n PS_Blend blend ;\n FT_Memory memory = face -> root . memory ;\n FT_Error error = FT_Err_Ok ;\n blend = face -> blend ;\n if ( ! blend ) {\n if ( FT_NEW ( blend ) ) goto Exit ;\n blend -> num_default_design_vector = 0 ;\n face -> blend = blend ;\n }\n if ( num_designs > 0 ) {\n if ( blend -> num_designs == 0 ) {\n FT_UInt nn ;\n if ( FT_NEW_ARRAY ( blend -> font_infos [ 1 ] , num_designs ) || FT_NEW_ARRAY ( blend -> privates [ 1 ] , num_designs ) || FT_NEW_ARRAY ( blend -> bboxes [ 1 ] , num_designs ) || FT_NEW_ARRAY ( blend -> weight_vector , num_designs * 2 ) ) goto Exit ;\n blend -> default_weight_vector = blend -> weight_vector + num_designs ;\n blend -> font_infos [ 0 ] = & face -> type1 . font_info ;\n blend -> privates [ 0 ] = & face -> type1 . private_dict ;\n blend -> bboxes [ 0 ] = & face -> type1 . font_bbox ;\n for ( nn = 2 ;\n nn <= num_designs ;\n nn ++ ) {\n blend -> font_infos [ nn ] = blend -> font_infos [ nn - 1 ] + 1 ;\n blend -> privates [ nn ] = blend -> privates [ nn - 1 ] + 1 ;\n blend -> bboxes [ nn ] = blend -> bboxes [ nn - 1 ] + 1 ;\n }\n blend -> num_designs = num_designs ;\n }\n else if ( blend -> num_designs != num_designs ) goto Fail ;\n }\n if ( num_axis > 0 ) {\n if ( blend -> num_axis != 0 && blend -> num_axis != num_axis ) goto Fail ;\n blend -> num_axis = num_axis ;\n }\n num_designs = blend -> num_designs ;\n num_axis = blend -> num_axis ;\n if ( num_designs && num_axis && blend -> design_pos [ 0 ] == 0 ) {\n FT_UInt n ;\n if ( FT_NEW_ARRAY ( blend -> design_pos [ 0 ] , num_designs * num_axis ) ) goto Exit ;\n for ( n = 1 ;\n n < num_designs ;\n n ++ ) blend -> design_pos [ n ] = blend -> design_pos [ 0 ] + num_axis * n ;\n }\n Exit : return error ;\n Fail : error = FT_THROW ( Invalid_File_Format ) ;\n goto Exit ;\n }", "idx": 2088}
{"hash": -5981110360267990064, "project": "chrome", "size": 27, "label": 0, "functionSource": "TEST ( IdlCompiler , ObjectTypes ) {\n FooType f1 ;\n f1 . x = 3 ;\n std : : unique_ptr < base : : DictionaryValue > serialized_foo = f1 . ToValue ( ) ;\n FooType f2 ;\n EXPECT_TRUE ( FooType : : Populate ( * serialized_foo . get ( ) , & f2 ) ) ;\n EXPECT_EQ ( f1 . x , f2 . x ) ;\n BarType b1 ;\n b1 . x . reset ( new base : : Value ( 7 ) ) ;\n std : : unique_ptr < base : : DictionaryValue > serialized_bar = b1 . ToValue ( ) ;\n BarType b2 ;\n EXPECT_TRUE ( BarType : : Populate ( * serialized_bar . get ( ) , & b2 ) ) ;\n int tmp_int = 0 ;\n EXPECT_TRUE ( b2 . x -> GetAsInteger ( & tmp_int ) ) ;\n EXPECT_EQ ( 7 , tmp_int ) ;\n std : : unique_ptr < base : : DictionaryValue > icon_props ( new base : : DictionaryValue ( ) ) ;\n icon_props -> SetString ( \"hello\" , \"world\" ) ;\n ObjectFunction1 : : Params : : Icon icon ;\n EXPECT_TRUE ( ObjectFunction1 : : Params : : Icon : : Populate ( * ( icon_props . get ( ) ) , & icon ) ) ;\n base : : ListValue list ;\n list . Append ( std : : move ( icon_props ) ) ;\n std : : unique_ptr < ObjectFunction1 : : Params > params = ObjectFunction1 : : Params : : Create ( list ) ;\n ASSERT_TRUE ( params . get ( ) != NULL ) ;\n std : : string tmp ;\n EXPECT_TRUE ( params -> icon . additional_properties . GetString ( \"hello\" , & tmp ) ) ;\n EXPECT_EQ ( \"world\" , tmp ) ;\n }", "idx": 2089}
{"hash": -6119142299306266167, "project": "debian", "size": 6, "label": 0, "functionSource": "static int zquit ( i_ctx_t * i_ctx_p ) {\n os_ptr op = osp ;\n check_op ( 2 ) ;\n check_type ( * op , t_integer ) ;\n return_error ( gs_error_Quit ) ;\n }", "idx": 2090}
{"hash": 1896723564367514490, "project": "debian", "size": 5, "label": 0, "functionSource": "static VALUE ossl_cipher_block_size ( VALUE self ) {\n EVP_CIPHER_CTX * ctx ;\n GetCipher ( self , ctx ) ;\n return INT2NUM ( EVP_CIPHER_CTX_block_size ( ctx ) ) ;\n }", "idx": 2091}
{"hash": 3804373597256531021, "project": "debian", "size": 33, "label": 0, "functionSource": "bool check_grant_routine ( THD * thd , ulong want_access , TABLE_LIST * procs , bool is_proc , bool no_errors ) {\n TABLE_LIST * table ;\n Security_context * sctx = thd -> security_ctx ;\n char * user = sctx -> priv_user ;\n char * host = sctx -> priv_host ;\n DBUG_ENTER ( \"check_grant_routine\" ) ;\n want_access &= ~ sctx -> master_access ;\n if ( ! want_access ) DBUG_RETURN ( 0 ) ;\n rw_rdlock ( & LOCK_grant ) ;\n for ( table = procs ;\n table ;\n table = table -> next_global ) {\n GRANT_NAME * grant_proc ;\n if ( ( grant_proc = routine_hash_search ( host , sctx -> ip , table -> db , user , table -> table_name , is_proc , 0 ) ) ) table -> grant . privilege |= grant_proc -> privs ;\n if ( want_access & ~ table -> grant . privilege ) {\n want_access &= ~ table -> grant . privilege ;\n goto err ;\n }\n }\n rw_unlock ( & LOCK_grant ) ;\n DBUG_RETURN ( 0 ) ;\n err : rw_unlock ( & LOCK_grant ) ;\n if ( ! no_errors ) {\n char buff [ 1024 ] ;\n const char * command = \"\" ;\n if ( table ) strxmov ( buff , table -> db , \".\" , table -> table_name , NullS ) ;\n if ( want_access & EXECUTE_ACL ) command = \"execute\" ;\n else if ( want_access & ALTER_PROC_ACL ) command = \"alter routine\" ;\n else if ( want_access & GRANT_ACL ) command = \"grant\" ;\n my_error ( ER_PROCACCESS_DENIED_ERROR , MYF ( 0 ) , command , user , host , table ? buff : \"unknown\" ) ;\n }\n DBUG_RETURN ( 1 ) ;\n }", "idx": 2092}
{"hash": 1535921111212871029, "project": "debian", "size": 3, "label": 0, "functionSource": "void remoteDispatchAuthError ( remote_error * rerr ) {\n remoteDispatchStringError ( rerr , VIR_ERR_AUTH_FAILED , \"authentication failed\" ) ;\n }", "idx": 2093}
{"hash": 1182028467273264883, "project": "debian", "size": 10, "label": 0, "functionSource": "int find_found ( FOUND_SET * found_set , uint table_offset , int found_offset ) {\n int i ;\n for ( i = 0 ;\n ( uint ) i < found_sets ;\n i ++ ) if ( found_set [ i ] . table_offset == table_offset && found_set [ i ] . found_offset == found_offset ) return - i - 2 ;\n found_set [ i ] . table_offset = table_offset ;\n found_set [ i ] . found_offset = found_offset ;\n found_sets ++ ;\n return - i - 2 ;\n }", "idx": 2094}
{"hash": 3584320764213684062, "project": "debian", "size": 67, "label": 1, "functionSource": "static int parse_CBaseStorageVariant ( tvbuff_t * tvb , int offset , proto_tree * parent_tree , proto_tree * pad_tree _U_ , struct CBaseStorageVariant * value , const char * text ) {\n int i , len ;\n proto_item * ti , * ti_type , * ti_val ;\n proto_tree * tree , * tr ;\n enum vType highType ;\n ZERO_STRUCT ( * value ) ;\n tree = proto_tree_add_subtree ( parent_tree , tvb , offset , 0 , ett_CBaseStorageVariant , & ti , text ) ;\n parse_vType ( tvb , offset , & value -> vType ) ;\n value -> type = vType_get_type ( value -> vType ) ;\n DISSECTOR_ASSERT ( value -> type != NULL ) ;\n ti_type = proto_tree_add_string ( tree , hf_mswsp_cbasestorvariant_vtype , tvb , offset , 2 , value -> type -> str ) ;\n offset += 2 ;\n value -> vData1 = tvb_get_guint8 ( tvb , offset ) ;\n proto_tree_add_uint ( tree , hf_mswsp_cbasestorvariant_vdata1 , tvb , offset , 1 , value -> vData1 ) ;\n offset += 1 ;\n value -> vData2 = tvb_get_guint8 ( tvb , offset ) ;\n proto_tree_add_uint ( tree , hf_mswsp_cbasestorvariant_vdata2 , tvb , offset , 1 , value -> vData2 ) ;\n offset += 1 ;\n highType = ( enum vType ) ( value -> vType & 0xFF00 ) ;\n ti_val = proto_tree_add_string ( tree , hf_mswsp_cbasestorvariant_vvalue , tvb , offset , 0 , \"\" ) ;\n switch ( highType ) {\n case VT_EMPTY : DISSECTOR_ASSERT_HINT ( value -> type -> tvb_get != 0 , \"type that we don't know yet how to handle, please submit a bug with trace\" ) ;\n len = value -> type -> tvb_get ( tvb , offset , & value -> vValue . vt_single ) ;\n offset += len ;\n break ;\n case VT_VECTOR : proto_item_append_text ( ti_type , \"|VT_VECTOR\" ) ;\n tr = proto_item_add_subtree ( ti_val , ett_CBaseStorageVariant_Vector ) ;\n len = vvalue_tvb_vector ( tvb , offset , & value -> vValue . vt_vector , value -> type ) ;\n proto_tree_add_uint ( tr , hf_mswsp_cbasestorvariant_num , tvb , offset , 4 , value -> vValue . vt_vector . len ) ;\n offset += len ;\n break ;\n case VT_ARRAY : {\n guint16 cDims , fFeatures ;\n guint32 cbElements , cElements , lLbound ;\n int num = 1 ;\n proto_item_append_text ( ti_type , \"|VT_ARRAY\" ) ;\n tr = proto_item_add_subtree ( ti_val , ett_CBaseStorageVariant_Array ) ;\n cDims = tvb_get_letohs ( tvb , offset ) ;\n proto_tree_add_uint ( tr , hf_mswsp_cbasestorvariant_cdims , tvb , offset , 2 , cDims ) ;\n offset += 2 ;\n fFeatures = tvb_get_letohs ( tvb , offset ) ;\n proto_tree_add_uint ( tr , hf_mswsp_cbasestorvariant_ffeatures , tvb , offset , 2 , fFeatures ) ;\n offset += 2 ;\n cbElements = tvb_get_letohl ( tvb , offset ) ;\n proto_tree_add_uint ( tr , hf_mswsp_cbasestorvariant_cbelements , tvb , offset , 4 , cbElements ) ;\n offset += 4 ;\n for ( i = 0 ;\n i < cDims ;\n i ++ ) {\n cElements = tvb_get_letohl ( tvb , offset ) ;\n lLbound = tvb_get_letohl ( tvb , offset + 4 ) ;\n proto_tree_add_string_format ( tr , hf_mswsp_cbasestorvariant_rgsabound , tvb , offset , 8 , \"\" , \"Rgsabound[%d]: (%d:%d)\" , i , cElements , lLbound ) ;\n offset += 8 ;\n num *= cElements ;\n }\n len = vvalue_tvb_vector_internal ( tvb , offset , & value -> vValue . vt_array . vData , value -> type , num ) ;\n offset += len ;\n break ;\n }\n default : proto_item_append_text ( ti_type , \"|0x%x\" , highType ) ;\n }\n proto_item_set_end ( ti , tvb , offset ) ;\n proto_item_set_end ( ti_val , tvb , offset ) ;\n proto_item_append_text ( ti_val , \" %s\" , str_CBaseStorageVariant ( value , FALSE ) ) ;\n proto_item_append_text ( ti , \" %s\" , str_CBaseStorageVariant ( value , TRUE ) ) ;\n return offset ;\n }", "idx": 2095}
{"hash": 6415329349331062723, "project": "chrome", "size": 22, "label": 1, "functionSource": "static struct evhttp * http_setup ( short * pport , struct event_base * base ) {\n int i ;\n struct evhttp * myhttp ;\n short port = - 1 ;\n myhttp = evhttp_new ( base ) ;\n for ( i = 0 ;\n i < 50 ;\n ++ i ) {\n if ( evhttp_bind_socket ( myhttp , \"127.0.0.1\" , 8080 + i ) != - 1 ) {\n port = 8080 + i ;\n break ;\n }\n }\n if ( port == - 1 ) event_errx ( 1 , \"Could not start web server\" ) ;\n evhttp_set_cb ( myhttp , \"/test\" , http_basic_cb , NULL ) ;\n evhttp_set_cb ( myhttp , \"/chunked\" , http_chunked_cb , NULL ) ;\n evhttp_set_cb ( myhttp , \"/postit\" , http_post_cb , NULL ) ;\n evhttp_set_cb ( myhttp , \"/largedelay\" , http_large_delay_cb , NULL ) ;\n evhttp_set_cb ( myhttp , \"/\" , http_dispatcher_cb , NULL ) ;\n * pport = port ;\n return ( myhttp ) ;\n }", "idx": 2096}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_T_t84Restricted ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_T_t84Restricted , T_t84Restricted_sequence ) ;\n return offset ;\n }", "idx": 2097}
{"hash": 3309252579593081468, "project": "debian", "size": 138, "label": 0, "functionSource": "static int nntp_fetch_headers ( struct Context * ctx , void * hc , anum_t first , anum_t last , int restore ) {\n struct NntpData * nntp_data = ctx -> data ;\n struct FetchCtx fc ;\n struct Header * hdr = NULL ;\n char buf [ HUGE_STRING ] ;\n int rc = 0 ;\n int oldmsgcount = ctx -> msgcount ;\n anum_t current ;\n anum_t first_over = first ;\n # ifdef USE_HCACHE void * hdata = NULL ;\n # endif if ( ! last || first > last ) return 0 ;\n fc . ctx = ctx ;\n fc . first = first ;\n fc . last = last ;\n fc . restore = restore ;\n fc . messages = mutt_mem_calloc ( last - first + 1 , sizeof ( unsigned char ) ) ;\n if ( fc . messages == NULL ) return - 1 ;\n # ifdef USE_HCACHE fc . hc = hc ;\n # endif if ( NntpListgroup && nntp_data -> nserv -> hasLISTGROUP && ! nntp_data -> deleted ) {\n if ( ! ctx -> quiet ) mutt_message ( _ ( \"Fetching list of articles...\" ) ) ;\n if ( nntp_data -> nserv -> hasLISTGROUPrange ) snprintf ( buf , sizeof ( buf ) , \"LISTGROUP %s %u-%u\\r\\n\" , nntp_data -> group , first , last ) ;\n else snprintf ( buf , sizeof ( buf ) , \"LISTGROUP %s\\r\\n\" , nntp_data -> group ) ;\n rc = nntp_fetch_lines ( nntp_data , buf , sizeof ( buf ) , NULL , fetch_numbers , & fc ) ;\n if ( rc > 0 ) {\n mutt_error ( \"LISTGROUP: %s\" , buf ) ;\n }\n if ( rc == 0 ) {\n for ( current = first ;\n current <= last && rc == 0 ;\n current ++ ) {\n if ( fc . messages [ current - first ] ) continue ;\n snprintf ( buf , sizeof ( buf ) , \"%u\" , current ) ;\n if ( nntp_data -> bcache ) {\n mutt_debug ( 2 , \"#1 mutt_bcache_del %s\\n\" , buf ) ;\n mutt_bcache_del ( nntp_data -> bcache , buf ) ;\n }\n # ifdef USE_HCACHE if ( fc . hc ) {\n mutt_debug ( 2 , \"mutt_hcache_delete %s\\n\" , buf ) ;\n mutt_hcache_delete ( fc . hc , buf , strlen ( buf ) ) ;\n }\n # endif }\n }\n }\n else {\n for ( current = first ;\n current <= last ;\n current ++ ) fc . messages [ current - first ] = 1 ;\n }\n if ( ! ctx -> quiet ) {\n mutt_progress_init ( & fc . progress , _ ( \"Fetching message headers...\" ) , MUTT_PROGRESS_MSG , ReadInc , last - first + 1 ) ;\n }\n for ( current = first ;\n current <= last && rc == 0 ;\n current ++ ) {\n if ( ! ctx -> quiet ) mutt_progress_update ( & fc . progress , current - first + 1 , - 1 ) ;\n # ifdef USE_HCACHE snprintf ( buf , sizeof ( buf ) , \"%u\" , current ) ;\n # endif if ( ! fc . messages [ current - first ] ) continue ;\n if ( ctx -> msgcount >= ctx -> hdrmax ) mx_alloc_memory ( ctx ) ;\n # ifdef USE_HCACHE hdata = mutt_hcache_fetch ( fc . hc , buf , strlen ( buf ) ) ;\n if ( hdata ) {\n mutt_debug ( 2 , \"mutt_hcache_fetch %s\\n\" , buf ) ;\n ctx -> hdrs [ ctx -> msgcount ] = hdr = mutt_hcache_restore ( hdata ) ;\n mutt_hcache_free ( fc . hc , & hdata ) ;\n hdr -> data = 0 ;\n if ( hdr -> deleted && ! restore ) {\n mutt_header_free ( & hdr ) ;\n if ( nntp_data -> bcache ) {\n mutt_debug ( 2 , \"#2 mutt_bcache_del %s\\n\" , buf ) ;\n mutt_bcache_del ( nntp_data -> bcache , buf ) ;\n }\n continue ;\n }\n hdr -> read = false ;\n hdr -> old = false ;\n }\n else # endif if ( nntp_data -> deleted ) continue ;\n else if ( nntp_data -> nserv -> hasOVER || nntp_data -> nserv -> hasXOVER ) {\n if ( NntpListgroup && nntp_data -> nserv -> hasLISTGROUP ) break ;\n else continue ;\n }\n else {\n FILE * fp = mutt_file_mkstemp ( ) ;\n if ( ! fp ) {\n mutt_perror ( \"mutt_file_mkstemp() failed!\" ) ;\n rc = - 1 ;\n break ;\n }\n snprintf ( buf , sizeof ( buf ) , \"HEAD %u\\r\\n\" , current ) ;\n rc = nntp_fetch_lines ( nntp_data , buf , sizeof ( buf ) , NULL , fetch_tempfile , fp ) ;\n if ( rc ) {\n mutt_file_fclose ( & fp ) ;\n if ( rc < 0 ) break ;\n if ( mutt_str_strncmp ( \"423\" , buf , 3 ) != 0 ) {\n mutt_error ( \"HEAD: %s\" , buf ) ;\n break ;\n }\n if ( nntp_data -> bcache ) {\n snprintf ( buf , sizeof ( buf ) , \"%u\" , current ) ;\n mutt_debug ( 2 , \"#3 mutt_bcache_del %s\\n\" , buf ) ;\n mutt_bcache_del ( nntp_data -> bcache , buf ) ;\n }\n rc = 0 ;\n continue ;\n }\n hdr = ctx -> hdrs [ ctx -> msgcount ] = mutt_header_new ( ) ;\n hdr -> env = mutt_rfc822_read_header ( fp , hdr , 0 , 0 ) ;\n hdr -> received = hdr -> date_sent ;\n mutt_file_fclose ( & fp ) ;\n }\n hdr -> index = ctx -> msgcount ++ ;\n hdr -> read = false ;\n hdr -> old = false ;\n hdr -> deleted = false ;\n hdr -> data = mutt_mem_calloc ( 1 , sizeof ( struct NntpHeaderData ) ) ;\n NHDR ( hdr ) -> article_num = current ;\n if ( restore ) hdr -> changed = true ;\n else {\n nntp_article_status ( ctx , hdr , NULL , NHDR ( hdr ) -> article_num ) ;\n if ( ! hdr -> read ) nntp_parse_xref ( ctx , hdr ) ;\n }\n if ( current > nntp_data -> last_loaded ) nntp_data -> last_loaded = current ;\n first_over = current + 1 ;\n }\n if ( ! NntpListgroup || ! nntp_data -> nserv -> hasLISTGROUP ) current = first_over ;\n if ( current <= last && rc == 0 && ! nntp_data -> deleted ) {\n char * cmd = nntp_data -> nserv -> hasOVER ? \"OVER\" : \"XOVER\" ;\n snprintf ( buf , sizeof ( buf ) , \"%s %u-%u\\r\\n\" , cmd , current , last ) ;\n rc = nntp_fetch_lines ( nntp_data , buf , sizeof ( buf ) , NULL , parse_overview_line , & fc ) ;\n if ( rc > 0 ) {\n mutt_error ( \"%s: %s\" , cmd , buf ) ;\n }\n }\n if ( ctx -> msgcount > oldmsgcount ) mx_update_context ( ctx , ctx -> msgcount - oldmsgcount ) ;\n FREE ( & fc . messages ) ;\n if ( rc != 0 ) return - 1 ;\n mutt_clear_error ( ) ;\n return 0 ;\n }", "idx": 2098}
{"hash": 1366214969540455677, "project": "debian", "size": 74, "label": 1, "functionSource": "void name ## _free ( type * a ) ;\n # define DECLARE_ASN1_PRINT_FUNCTION ( stname ) DECLARE_ASN1_PRINT_FUNCTION_fname ( stname , stname ) # define DECLARE_ASN1_PRINT_FUNCTION_fname ( stname , fname ) int fname ## _print_ctx ( BIO * out , stname * x , int indent , const ASN1_PCTX * pctx ) ;\n # define D2I_OF ( type ) type * ( * ) ( type * * , const unsigned char * * , long ) # define I2D_OF ( type ) int ( * ) ( type * , unsigned char * * ) # define I2D_OF_const ( type ) int ( * ) ( const type * , unsigned char * * ) # define CHECKED_D2I_OF ( type , d2i ) ( ( d2i_of_void * ) ( 1 ? d2i : ( ( D2I_OF ( type ) ) 0 ) ) ) # define CHECKED_I2D_OF ( type , i2d ) ( ( i2d_of_void * ) ( 1 ? i2d : ( ( I2D_OF ( type ) ) 0 ) ) ) # define CHECKED_NEW_OF ( type , xnew ) ( ( void * ( * ) ( void ) ) ( 1 ? xnew : ( ( type * ( * ) ( void ) ) 0 ) ) ) # define CHECKED_PTR_OF ( type , p ) ( ( void * ) ( 1 ? p : ( type * ) 0 ) ) # define CHECKED_PPTR_OF ( type , p ) ( ( void * * ) ( 1 ? p : ( type * * ) 0 ) ) # define TYPEDEF_D2I_OF ( type ) typedef type * d2i_of_ ## type ( type * * , const unsigned char * * , long ) # define TYPEDEF_I2D_OF ( type ) typedef int i2d_of_ ## type ( type * , unsigned char * * ) # define TYPEDEF_D2I2D_OF ( type ) TYPEDEF_D2I_OF ( type ) ;\n TYPEDEF_I2D_OF ( type ) TYPEDEF_D2I2D_OF ( void ) ;\n # ifndef OPENSSL_EXPORT_VAR_AS_FUNCTION typedef const ASN1_ITEM ASN1_ITEM_EXP ;\n # define ASN1_ITEM_ptr ( iptr ) ( iptr ) # define ASN1_ITEM_ref ( iptr ) ( & ( iptr ## _it ) ) # define ASN1_ITEM_rptr ( ref ) ( & ( ref ## _it ) ) # define DECLARE_ASN1_ITEM ( name ) OPENSSL_EXTERN const ASN1_ITEM name ## _it ;\n # else typedef const ASN1_ITEM * ASN1_ITEM_EXP ( void ) ;\n # define ASN1_ITEM_ptr ( iptr ) ( iptr ( ) ) # define ASN1_ITEM_ref ( iptr ) ( iptr ## _it ) # define ASN1_ITEM_rptr ( ref ) ( ref ## _it ( ) ) # define DECLARE_ASN1_ITEM ( name ) const ASN1_ITEM * name ## _it ( void ) ;\n # endif # define ASN1_STRFLGS_ESC_2253 1 # define ASN1_STRFLGS_ESC_CTRL 2 # define ASN1_STRFLGS_ESC_MSB 4 # define ASN1_STRFLGS_ESC_QUOTE 8 # define CHARTYPE_PRINTABLESTRING 0x10 # define CHARTYPE_FIRST_ESC_2253 0x20 # define CHARTYPE_LAST_ESC_2253 0x40 # define ASN1_STRFLGS_UTF8_CONVERT 0x10 # define ASN1_STRFLGS_IGNORE_TYPE 0x20 # define ASN1_STRFLGS_SHOW_TYPE 0x40 # define ASN1_STRFLGS_DUMP_ALL 0x80 # define ASN1_STRFLGS_DUMP_UNKNOWN 0x100 # define ASN1_STRFLGS_DUMP_DER 0x200 # define ASN1_STRFLGS_ESC_2254 0x400 # define ASN1_STRFLGS_RFC2253 ( ASN1_STRFLGS_ESC_2253 | ASN1_STRFLGS_ESC_CTRL | ASN1_STRFLGS_ESC_MSB | ASN1_STRFLGS_UTF8_CONVERT | ASN1_STRFLGS_DUMP_UNKNOWN | ASN1_STRFLGS_DUMP_DER ) DEFINE_STACK_OF ( ASN1_INTEGER ) DEFINE_STACK_OF ( ASN1_GENERALSTRING ) DEFINE_STACK_OF ( ASN1_UTF8STRING ) typedef struct asn1_type_st {\n int type ;\n union {\n char * ptr ;\n ASN1_BOOLEAN boolean ;\n ASN1_STRING * asn1_string ;\n ASN1_OBJECT * object ;\n ASN1_INTEGER * integer ;\n ASN1_ENUMERATED * enumerated ;\n ASN1_BIT_STRING * bit_string ;\n ASN1_OCTET_STRING * octet_string ;\n ASN1_PRINTABLESTRING * printablestring ;\n ASN1_T61STRING * t61string ;\n ASN1_IA5STRING * ia5string ;\n ASN1_GENERALSTRING * generalstring ;\n ASN1_BMPSTRING * bmpstring ;\n ASN1_UNIVERSALSTRING * universalstring ;\n ASN1_UTCTIME * utctime ;\n ASN1_GENERALIZEDTIME * generalizedtime ;\n ASN1_VISIBLESTRING * visiblestring ;\n ASN1_UTF8STRING * utf8string ;\n ASN1_STRING * set ;\n ASN1_STRING * sequence ;\n ASN1_VALUE * asn1_value ;\n }\n value ;\n }\n ASN1_TYPE ;\n DEFINE_STACK_OF ( ASN1_TYPE ) typedef STACK_OF ( ASN1_TYPE ) ASN1_SEQUENCE_ANY ;\n DECLARE_ASN1_ENCODE_FUNCTIONS_const ( ASN1_SEQUENCE_ANY , ASN1_SEQUENCE_ANY ) DECLARE_ASN1_ENCODE_FUNCTIONS_const ( ASN1_SEQUENCE_ANY , ASN1_SET_ANY ) typedef struct BIT_STRING_BITNAME_st {\n int bitnum ;\n const char * lname ;\n const char * sname ;\n }\n BIT_STRING_BITNAME ;\n # define B_ASN1_TIME B_ASN1_UTCTIME | B_ASN1_GENERALIZEDTIME # define B_ASN1_PRINTABLE B_ASN1_NUMERICSTRING | B_ASN1_PRINTABLESTRING | B_ASN1_T61STRING | B_ASN1_IA5STRING | B_ASN1_BIT_STRING | B_ASN1_UNIVERSALSTRING | B_ASN1_BMPSTRING | B_ASN1_UTF8STRING | B_ASN1_SEQUENCE | B_ASN1_UNKNOWN # define B_ASN1_DIRECTORYSTRING B_ASN1_PRINTABLESTRING | B_ASN1_TELETEXSTRING | B_ASN1_BMPSTRING | B_ASN1_UNIVERSALSTRING | B_ASN1_UTF8STRING # define B_ASN1_DISPLAYTEXT B_ASN1_IA5STRING | B_ASN1_VISIBLESTRING | B_ASN1_BMPSTRING | B_ASN1_UTF8STRING DECLARE_ASN1_FUNCTIONS_fname ( ASN1_TYPE , ASN1_ANY , ASN1_TYPE ) int ASN1_TYPE_get ( const ASN1_TYPE * a ) ;\n void ASN1_TYPE_set ( ASN1_TYPE * a , int type , void * value ) ;\n int ASN1_TYPE_set1 ( ASN1_TYPE * a , int type , const void * value ) ;\n int ASN1_TYPE_cmp ( const ASN1_TYPE * a , const ASN1_TYPE * b ) ;\n ASN1_TYPE * ASN1_TYPE_pack_sequence ( const ASN1_ITEM * it , void * s , ASN1_TYPE * * t ) ;\n void * ASN1_TYPE_unpack_sequence ( const ASN1_ITEM * it , const ASN1_TYPE * t ) ;\n ASN1_OBJECT * ASN1_OBJECT_new ( void ) ;\n void ASN1_OBJECT_free ( ASN1_OBJECT * a ) ;\n int i2d_ASN1_OBJECT ( const ASN1_OBJECT * a , unsigned char * * pp ) ;\n ASN1_OBJECT * d2i_ASN1_OBJECT ( ASN1_OBJECT * * a , const unsigned char * * pp , long length ) ;\n DECLARE_ASN1_ITEM ( ASN1_OBJECT ) DEFINE_STACK_OF ( ASN1_OBJECT ) ASN1_STRING * ASN1_STRING_new ( void ) ;\n void ASN1_STRING_free ( ASN1_STRING * a ) ;\n void ASN1_STRING_clear_free ( ASN1_STRING * a ) ;\n int ASN1_STRING_copy ( ASN1_STRING * dst , const ASN1_STRING * str ) ;\n ASN1_STRING * ASN1_STRING_dup ( const ASN1_STRING * a ) ;\n ASN1_STRING * ASN1_STRING_type_new ( int type ) ;\n int ASN1_STRING_cmp ( const ASN1_STRING * a , const ASN1_STRING * b ) ;\n int ASN1_STRING_set ( ASN1_STRING * str , const void * data , int len ) ;\n void ASN1_STRING_set0 ( ASN1_STRING * str , void * data , int len ) ;\n int ASN1_STRING_length ( const ASN1_STRING * x ) ;\n void ASN1_STRING_length_set ( ASN1_STRING * x , int n ) ;\n int ASN1_STRING_type ( const ASN1_STRING * x ) ;\n DEPRECATEDIN_1_1_0 ( unsigned char * ASN1_STRING_data ( ASN1_STRING * x ) ) const unsigned char * ASN1_STRING_get0_data ( const ASN1_STRING * x ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_BIT_STRING ) int ASN1_BIT_STRING_set ( ASN1_BIT_STRING * a , unsigned char * d , int length ) ;\n int ASN1_BIT_STRING_set_bit ( ASN1_BIT_STRING * a , int n , int value ) ;\n int ASN1_BIT_STRING_get_bit ( const ASN1_BIT_STRING * a , int n ) ;\n int ASN1_BIT_STRING_check ( const ASN1_BIT_STRING * a , const unsigned char * flags , int flags_len ) ;\n int ASN1_BIT_STRING_name_print ( BIO * out , ASN1_BIT_STRING * bs , BIT_STRING_BITNAME * tbl , int indent ) ;\n int ASN1_BIT_STRING_num_asc ( const char * name , BIT_STRING_BITNAME * tbl ) ;\n int ASN1_BIT_STRING_set_asc ( ASN1_BIT_STRING * bs , const char * name , int value , BIT_STRING_BITNAME * tbl ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_INTEGER )", "idx": 2099}
{"hash": 6709099320123900016, "project": "debian", "size": 56, "label": 0, "functionSource": "IMPLEMENT_ssl23_meth_func ( SSLv23_server_method , ssl23_accept , ssl_undefined_function , ssl23_get_server_method ) int ssl23_accept ( SSL * s ) {\n BUF_MEM * buf ;\n unsigned long Time = ( unsigned long ) time ( NULL ) ;\n void ( * cb ) ( const SSL * ssl , int type , int val ) = NULL ;\n int ret = - 1 ;\n int new_state , state ;\n RAND_add ( & Time , sizeof ( Time ) , 0 ) ;\n ERR_clear_error ( ) ;\n clear_sys_error ( ) ;\n if ( s -> info_callback != NULL ) cb = s -> info_callback ;\n else if ( s -> ctx -> info_callback != NULL ) cb = s -> ctx -> info_callback ;\n s -> in_handshake ++ ;\n if ( ! SSL_in_init ( s ) || SSL_in_before ( s ) ) SSL_clear ( s ) ;\n for ( ;\n ;\n ) {\n state = s -> state ;\n switch ( s -> state ) {\n case SSL_ST_BEFORE : case SSL_ST_ACCEPT : case SSL_ST_BEFORE | SSL_ST_ACCEPT : case SSL_ST_OK | SSL_ST_ACCEPT : s -> server = 1 ;\n if ( cb != NULL ) cb ( s , SSL_CB_HANDSHAKE_START , 1 ) ;\n s -> type = SSL_ST_ACCEPT ;\n if ( s -> init_buf == NULL ) {\n if ( ( buf = BUF_MEM_new ( ) ) == NULL ) {\n ret = - 1 ;\n goto end ;\n }\n if ( ! BUF_MEM_grow ( buf , SSL3_RT_MAX_PLAIN_LENGTH ) ) {\n ret = - 1 ;\n goto end ;\n }\n s -> init_buf = buf ;\n }\n ssl3_init_finished_mac ( s ) ;\n s -> state = SSL23_ST_SR_CLNT_HELLO_A ;\n s -> ctx -> stats . sess_accept ++ ;\n s -> init_num = 0 ;\n break ;\n case SSL23_ST_SR_CLNT_HELLO_A : case SSL23_ST_SR_CLNT_HELLO_B : s -> shutdown = 0 ;\n ret = ssl23_get_client_hello ( s ) ;\n if ( ret >= 0 ) cb = NULL ;\n goto end ;\n default : SSLerr ( SSL_F_SSL23_ACCEPT , SSL_R_UNKNOWN_STATE ) ;\n ret = - 1 ;\n goto end ;\n }\n if ( ( cb != NULL ) && ( s -> state != state ) ) {\n new_state = s -> state ;\n s -> state = state ;\n cb ( s , SSL_CB_ACCEPT_LOOP , 1 ) ;\n s -> state = new_state ;\n }\n }\n end : s -> in_handshake -- ;\n if ( cb != NULL ) cb ( s , SSL_CB_ACCEPT_EXIT , ret ) ;\n return ( ret ) ;\n }", "idx": 2100}
{"hash": 7651945086108393719, "project": "debian", "size": 53, "label": 0, "functionSource": "int qemuMonitorJSONGetBlockInfo ( qemuMonitorPtr mon , const char * devname , struct qemuDomainDiskInfo * info ) {\n int ret = 0 ;\n bool found = false ;\n int i ;\n virJSONValuePtr cmd = qemuMonitorJSONMakeCommand ( \"query-block\" , NULL ) ;\n virJSONValuePtr reply = NULL ;\n virJSONValuePtr devices ;\n if ( ! cmd ) return - 1 ;\n ret = qemuMonitorJSONCommand ( mon , cmd , & reply ) ;\n if ( ret == 0 ) ret = qemuMonitorJSONCheckError ( cmd , reply ) ;\n if ( ret < 0 ) goto cleanup ;\n ret = - 1 ;\n devices = virJSONValueObjectGet ( reply , \"return\" ) ;\n if ( ! devices || devices -> type != VIR_JSON_TYPE_ARRAY ) {\n qemuReportError ( VIR_ERR_INTERNAL_ERROR , \"%s\" , _ ( \"block info reply was missing device list\" ) ) ;\n goto cleanup ;\n }\n for ( i = 0 ;\n i < virJSONValueArraySize ( devices ) ;\n i ++ ) {\n virJSONValuePtr dev = virJSONValueArrayGet ( devices , i ) ;\n const char * thisdev ;\n if ( ! dev || dev -> type != VIR_JSON_TYPE_OBJECT ) {\n qemuReportError ( VIR_ERR_INTERNAL_ERROR , \"%s\" , _ ( \"block info device entry was not in expected format\" ) ) ;\n goto cleanup ;\n }\n if ( ( thisdev = virJSONValueObjectGetString ( dev , \"device\" ) ) == NULL ) {\n qemuReportError ( VIR_ERR_INTERNAL_ERROR , \"%s\" , _ ( \"block info device entry was not in expected format\" ) ) ;\n goto cleanup ;\n }\n if ( STRPREFIX ( thisdev , QEMU_DRIVE_HOST_PREFIX ) ) thisdev += strlen ( QEMU_DRIVE_HOST_PREFIX ) ;\n if ( STRNEQ ( thisdev , devname ) ) continue ;\n found = true ;\n if ( virJSONValueObjectGetBoolean ( dev , \"removable\" , & info -> removable ) < 0 ) {\n qemuReportError ( VIR_ERR_INTERNAL_ERROR , _ ( \"cannot read %s value\" ) , \"removable\" ) ;\n goto cleanup ;\n }\n if ( virJSONValueObjectGetBoolean ( dev , \"locked\" , & info -> locked ) < 0 ) {\n qemuReportError ( VIR_ERR_INTERNAL_ERROR , _ ( \"cannot read %s value\" ) , \"locked\" ) ;\n goto cleanup ;\n }\n ignore_value ( virJSONValueObjectGetBoolean ( dev , \"tray-open\" , & info -> tray_open ) ) ;\n break ;\n }\n if ( ! found ) {\n qemuReportError ( VIR_ERR_INTERNAL_ERROR , _ ( \"cannot find info for device '%s'\" ) , devname ) ;\n goto cleanup ;\n }\n ret = 0 ;\n cleanup : virJSONValueFree ( cmd ) ;\n virJSONValueFree ( reply ) ;\n return ret ;\n }", "idx": 2101}
{"hash": 6595989226414083189, "project": "debian", "size": 3, "label": 0, "functionSource": "static __always_inline __u32 __be32_to_cpup ( const __be32 * p ) {\n return __swab32p ( ( __u32 * ) p ) ;\n }", "idx": 2102}
{"hash": 2772622454795674000, "project": "debian", "size": 11, "label": 0, "functionSource": "static void h263_decode_dquant ( MpegEncContext * s ) {\n static const int8_t quant_tab [ 4 ] = {\n - 1 , - 2 , 1 , 2 }\n ;\n if ( s -> modified_quant ) {\n if ( get_bits1 ( & s -> gb ) ) s -> qscale = ff_modified_quant_tab [ get_bits1 ( & s -> gb ) ] [ s -> qscale ] ;\n else s -> qscale = get_bits ( & s -> gb , 5 ) ;\n }\n else s -> qscale += quant_tab [ get_bits ( & s -> gb , 2 ) ] ;\n ff_set_qscale ( s , s -> qscale ) ;\n }", "idx": 2103}
{"hash": 4976989049001279223, "project": "debian", "size": 10, "label": 0, "functionSource": "void http_hdr_init ( HdrHeap * heap , HTTPHdrImpl * hh , HTTPType polarity ) {\n memset ( & ( hh -> u ) , 0 , sizeof ( hh -> u ) ) ;\n hh -> m_polarity = polarity ;\n hh -> m_version = HTTP_VERSION ( 1 , 0 ) ;\n hh -> m_fields_impl = mime_hdr_create ( heap ) ;\n if ( polarity == HTTP_TYPE_REQUEST ) {\n hh -> u . req . m_url_impl = url_create ( heap ) ;\n hh -> u . req . m_method_wks_idx = - 1 ;\n }\n }", "idx": 2104}
{"hash": 4180964683905830761, "project": "debian", "size": 14, "label": 0, "functionSource": "static int selinux_determine_inode_label ( const struct task_security_struct * tsec , struct inode * dir , const struct qstr * name , u16 tclass , u32 * _new_isid ) {\n const struct superblock_security_struct * sbsec = dir -> i_sb -> s_security ;\n if ( ( sbsec -> flags & SE_SBINITIALIZED ) && ( sbsec -> behavior == SECURITY_FS_USE_MNTPOINT ) ) {\n * _new_isid = sbsec -> mntpoint_sid ;\n }\n else if ( ( sbsec -> flags & SBLABEL_MNT ) && tsec -> create_sid ) {\n * _new_isid = tsec -> create_sid ;\n }\n else {\n const struct inode_security_struct * dsec = inode_security ( dir ) ;\n return security_transition_sid ( tsec -> sid , dsec -> sid , tclass , name , _new_isid ) ;\n }\n return 0 ;\n }", "idx": 2105}
{"hash": 1742637512846796448, "project": "debian", "size": 15, "label": 0, "functionSource": "static void call_rlc ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , proto_item * ti , guint8 lchid , void * data ) {\n switch ( lchId_type_table [ lchid ] ) {\n case MAC_CONTENT_DCCH : proto_item_append_text ( ti , \" (DCCH)\" ) ;\n call_dissector_with_data ( rlc_dcch_handle , tvb , pinfo , tree , data ) ;\n break ;\n case MAC_CONTENT_PS_DTCH : proto_item_append_text ( ti , \" (PS DTCH)\" ) ;\n call_dissector_with_data ( rlc_ps_dtch_handle , tvb , pinfo , tree , data ) ;\n break ;\n case MAC_CONTENT_CS_DTCH : proto_item_append_text ( ti , \" (CS DTCH)\" ) ;\n break ;\n default : proto_item_append_text ( ti , \" (Unknown EDCH Content)\" ) ;\n expert_add_info_format ( pinfo , ti , & ei_mac_unknown_content , \"Unknown EDCH Content\" ) ;\n break ;\n }\n }", "idx": 2106}
{"hash": -5927738579069082820, "project": "debian", "size": 12, "label": 0, "functionSource": "static char * xps_parse_float_array ( char * s , int num , float * x ) {\n int k = 0 ;\n if ( s == NULL || * s == 0 ) return NULL ;\n while ( * s ) {\n while ( * s == 0x0d || * s == '\\t' || * s == ' ' || * s == 0x0a ) s ++ ;\n x [ k ] = ( float ) strtod ( s , & s ) ;\n while ( * s == 0x0d || * s == '\\t' || * s == ' ' || * s == 0x0a ) s ++ ;\n if ( * s == ',' ) s ++ ;\n if ( ++ k == num ) break ;\n }\n return s ;\n }", "idx": 2107}
{"hash": -1055531103257174901, "project": "debian", "size": 19, "label": 0, "functionSource": "static char * auto_complete ( CHANNEL_REC * channel , const char * line ) {\n GList * comp ;\n const char * p ;\n char * nick , * ret ;\n p = strstr ( line , completion_char ) ;\n if ( p == NULL ) return NULL ;\n nick = g_strndup ( line , ( int ) ( p - line ) ) ;\n ret = NULL ;\n if ( nicklist_find ( channel , nick ) == NULL ) {\n comp = completion_channel_nicks ( channel , nick , NULL ) ;\n if ( comp != NULL ) {\n ret = g_strconcat ( comp -> data , p , NULL ) ;\n g_list_foreach ( comp , ( GFunc ) g_free , NULL ) ;\n g_list_free ( comp ) ;\n }\n }\n g_free ( nick ) ;\n return ret ;\n }", "idx": 2108}
{"hash": -8115807672627724050, "project": "debian", "size": 10, "label": 0, "functionSource": "static int ts_lua_http_config_float_get ( lua_State * L ) {\n int conf ;\n float value ;\n ts_lua_http_ctx * http_ctx ;\n GET_HTTP_CONTEXT ( http_ctx , L ) ;\n conf = luaL_checkinteger ( L , 1 ) ;\n TSHttpTxnConfigFloatGet ( http_ctx -> txnp , conf , & value ) ;\n lua_pushnumber ( L , value ) ;\n return 1 ;\n }", "idx": 2109}
{"hash": 3599206110384554647, "project": "debian", "size": 72, "label": 0, "functionSource": "int i2d_ ## name ( type * a , unsigned char * * out ) ;\n DECLARE_ASN1_ITEM ( itname ) # define DECLARE_ASN1_ENCODE_FUNCTIONS_const ( type , name ) type * d2i_ ## name ( type * * a , const unsigned char * * in , long len ) ;\n int i2d_ ## name ( const type * a , unsigned char * * out ) ;\n DECLARE_ASN1_ITEM ( name ) # define DECLARE_ASN1_NDEF_FUNCTION ( name ) int i2d_ ## name ## _NDEF ( name * a , unsigned char * * out ) ;\n # define DECLARE_ASN1_FUNCTIONS_const ( name ) DECLARE_ASN1_ALLOC_FUNCTIONS ( name ) DECLARE_ASN1_ENCODE_FUNCTIONS_const ( name , name ) # define DECLARE_ASN1_ALLOC_FUNCTIONS_name ( type , name ) type * name ## _new ( void ) ;\n void name ## _free ( type * a ) ;\n # define DECLARE_ASN1_PRINT_FUNCTION ( stname ) DECLARE_ASN1_PRINT_FUNCTION_fname ( stname , stname ) # define DECLARE_ASN1_PRINT_FUNCTION_fname ( stname , fname ) int fname ## _print_ctx ( BIO * out , stname * x , int indent , const ASN1_PCTX * pctx ) ;\n # define D2I_OF ( type ) type * ( * ) ( type * * , const unsigned char * * , long ) # define I2D_OF ( type ) int ( * ) ( type * , unsigned char * * ) # define I2D_OF_const ( type ) int ( * ) ( const type * , unsigned char * * ) # define CHECKED_D2I_OF ( type , d2i ) ( ( d2i_of_void * ) ( 1 ? d2i : ( ( D2I_OF ( type ) ) 0 ) ) ) # define CHECKED_I2D_OF ( type , i2d ) ( ( i2d_of_void * ) ( 1 ? i2d : ( ( I2D_OF ( type ) ) 0 ) ) ) # define CHECKED_NEW_OF ( type , xnew ) ( ( void * ( * ) ( void ) ) ( 1 ? xnew : ( ( type * ( * ) ( void ) ) 0 ) ) ) # define CHECKED_PTR_OF ( type , p ) ( ( void * ) ( 1 ? p : ( type * ) 0 ) ) # define CHECKED_PPTR_OF ( type , p ) ( ( void * * ) ( 1 ? p : ( type * * ) 0 ) ) # define TYPEDEF_D2I_OF ( type ) typedef type * d2i_of_ ## type ( type * * , const unsigned char * * , long ) # define TYPEDEF_I2D_OF ( type ) typedef int i2d_of_ ## type ( type * , unsigned char * * ) # define TYPEDEF_D2I2D_OF ( type ) TYPEDEF_D2I_OF ( type ) ;\n TYPEDEF_I2D_OF ( type ) TYPEDEF_D2I2D_OF ( void ) ;\n # ifndef OPENSSL_EXPORT_VAR_AS_FUNCTION typedef const ASN1_ITEM ASN1_ITEM_EXP ;\n # define ASN1_ITEM_ptr ( iptr ) ( iptr ) # define ASN1_ITEM_ref ( iptr ) ( & ( iptr ## _it ) ) # define ASN1_ITEM_rptr ( ref ) ( & ( ref ## _it ) ) # define DECLARE_ASN1_ITEM ( name ) OPENSSL_EXTERN const ASN1_ITEM name ## _it ;\n # else typedef const ASN1_ITEM * ASN1_ITEM_EXP ( void ) ;\n # define ASN1_ITEM_ptr ( iptr ) ( iptr ( ) ) # define ASN1_ITEM_ref ( iptr ) ( iptr ## _it ) # define ASN1_ITEM_rptr ( ref ) ( ref ## _it ( ) ) # define DECLARE_ASN1_ITEM ( name ) const ASN1_ITEM * name ## _it ( void ) ;\n # endif # define ASN1_STRFLGS_ESC_2253 1 # define ASN1_STRFLGS_ESC_CTRL 2 # define ASN1_STRFLGS_ESC_MSB 4 # define ASN1_STRFLGS_ESC_QUOTE 8 # define CHARTYPE_PRINTABLESTRING 0x10 # define CHARTYPE_FIRST_ESC_2253 0x20 # define CHARTYPE_LAST_ESC_2253 0x40 # define ASN1_STRFLGS_UTF8_CONVERT 0x10 # define ASN1_STRFLGS_IGNORE_TYPE 0x20 # define ASN1_STRFLGS_SHOW_TYPE 0x40 # define ASN1_STRFLGS_DUMP_ALL 0x80 # define ASN1_STRFLGS_DUMP_UNKNOWN 0x100 # define ASN1_STRFLGS_DUMP_DER 0x200 # define ASN1_STRFLGS_ESC_2254 0x400 # define ASN1_STRFLGS_RFC2253 ( ASN1_STRFLGS_ESC_2253 | ASN1_STRFLGS_ESC_CTRL | ASN1_STRFLGS_ESC_MSB | ASN1_STRFLGS_UTF8_CONVERT | ASN1_STRFLGS_DUMP_UNKNOWN | ASN1_STRFLGS_DUMP_DER ) DEFINE_STACK_OF ( ASN1_INTEGER ) DEFINE_STACK_OF ( ASN1_GENERALSTRING ) DEFINE_STACK_OF ( ASN1_UTF8STRING ) typedef struct asn1_type_st {\n int type ;\n union {\n char * ptr ;\n ASN1_BOOLEAN boolean ;\n ASN1_STRING * asn1_string ;\n ASN1_OBJECT * object ;\n ASN1_INTEGER * integer ;\n ASN1_ENUMERATED * enumerated ;\n ASN1_BIT_STRING * bit_string ;\n ASN1_OCTET_STRING * octet_string ;\n ASN1_PRINTABLESTRING * printablestring ;\n ASN1_T61STRING * t61string ;\n ASN1_IA5STRING * ia5string ;\n ASN1_GENERALSTRING * generalstring ;\n ASN1_BMPSTRING * bmpstring ;\n ASN1_UNIVERSALSTRING * universalstring ;\n ASN1_UTCTIME * utctime ;\n ASN1_GENERALIZEDTIME * generalizedtime ;\n ASN1_VISIBLESTRING * visiblestring ;\n ASN1_UTF8STRING * utf8string ;\n ASN1_STRING * set ;\n ASN1_STRING * sequence ;\n ASN1_VALUE * asn1_value ;\n }\n value ;\n }\n ASN1_TYPE ;\n DEFINE_STACK_OF ( ASN1_TYPE ) typedef STACK_OF ( ASN1_TYPE ) ASN1_SEQUENCE_ANY ;\n DECLARE_ASN1_ENCODE_FUNCTIONS_const ( ASN1_SEQUENCE_ANY , ASN1_SEQUENCE_ANY ) DECLARE_ASN1_ENCODE_FUNCTIONS_const ( ASN1_SEQUENCE_ANY , ASN1_SET_ANY ) typedef struct BIT_STRING_BITNAME_st {\n int bitnum ;\n const char * lname ;\n const char * sname ;\n }\n BIT_STRING_BITNAME ;\n # define B_ASN1_TIME B_ASN1_UTCTIME | B_ASN1_GENERALIZEDTIME # define B_ASN1_PRINTABLE B_ASN1_NUMERICSTRING | B_ASN1_PRINTABLESTRING | B_ASN1_T61STRING | B_ASN1_IA5STRING | B_ASN1_BIT_STRING | B_ASN1_UNIVERSALSTRING | B_ASN1_BMPSTRING | B_ASN1_UTF8STRING | B_ASN1_SEQUENCE | B_ASN1_UNKNOWN # define B_ASN1_DIRECTORYSTRING B_ASN1_PRINTABLESTRING | B_ASN1_TELETEXSTRING | B_ASN1_BMPSTRING | B_ASN1_UNIVERSALSTRING | B_ASN1_UTF8STRING # define B_ASN1_DISPLAYTEXT B_ASN1_IA5STRING | B_ASN1_VISIBLESTRING | B_ASN1_BMPSTRING | B_ASN1_UTF8STRING DECLARE_ASN1_FUNCTIONS_fname ( ASN1_TYPE , ASN1_ANY , ASN1_TYPE ) int ASN1_TYPE_get ( const ASN1_TYPE * a ) ;\n void ASN1_TYPE_set ( ASN1_TYPE * a , int type , void * value ) ;\n int ASN1_TYPE_set1 ( ASN1_TYPE * a , int type , const void * value ) ;\n int ASN1_TYPE_cmp ( const ASN1_TYPE * a , const ASN1_TYPE * b ) ;\n ASN1_TYPE * ASN1_TYPE_pack_sequence ( const ASN1_ITEM * it , void * s , ASN1_TYPE * * t ) ;\n void * ASN1_TYPE_unpack_sequence ( const ASN1_ITEM * it , const ASN1_TYPE * t ) ;\n ASN1_OBJECT * ASN1_OBJECT_new ( void ) ;\n void ASN1_OBJECT_free ( ASN1_OBJECT * a ) ;\n int i2d_ASN1_OBJECT ( const ASN1_OBJECT * a , unsigned char * * pp ) ;\n ASN1_OBJECT * d2i_ASN1_OBJECT ( ASN1_OBJECT * * a , const unsigned char * * pp , long length ) ;\n DECLARE_ASN1_ITEM ( ASN1_OBJECT ) DEFINE_STACK_OF ( ASN1_OBJECT ) ASN1_STRING * ASN1_STRING_new ( void ) ;\n void ASN1_STRING_free ( ASN1_STRING * a ) ;\n void ASN1_STRING_clear_free ( ASN1_STRING * a ) ;\n int ASN1_STRING_copy ( ASN1_STRING * dst , const ASN1_STRING * str ) ;\n ASN1_STRING * ASN1_STRING_dup ( const ASN1_STRING * a ) ;\n ASN1_STRING * ASN1_STRING_type_new ( int type ) ;\n int ASN1_STRING_cmp ( const ASN1_STRING * a , const ASN1_STRING * b ) ;\n int ASN1_STRING_set ( ASN1_STRING * str , const void * data , int len ) ;\n void ASN1_STRING_set0 ( ASN1_STRING * str , void * data , int len ) ;\n int ASN1_STRING_length ( const ASN1_STRING * x ) ;\n void ASN1_STRING_length_set ( ASN1_STRING * x , int n ) ;\n int ASN1_STRING_type ( const ASN1_STRING * x ) ;\n DEPRECATEDIN_1_1_0 ( unsigned char * ASN1_STRING_data ( ASN1_STRING * x ) ) const unsigned char * ASN1_STRING_get0_data ( const ASN1_STRING * x ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_BIT_STRING )", "idx": 2110}
{"hash": 6453796474132805955, "project": "chrome", "size": 10, "label": 0, "functionSource": "static void U_CALLCONV _UTF7Open ( UConverter * cnv , UConverterLoadArgs * pArgs , UErrorCode * pErrorCode ) {\n ( void ) pArgs ;\n if ( UCNV_GET_VERSION ( cnv ) <= 1 ) {\n cnv -> fromUnicodeStatus = UCNV_GET_VERSION ( cnv ) << 28 ;\n _UTF7Reset ( cnv , UCNV_RESET_BOTH ) ;\n }\n else {\n * pErrorCode = U_ILLEGAL_ARGUMENT_ERROR ;\n }\n }", "idx": 2111}
{"hash": 6667142528452941476, "project": "debian", "size": 18, "label": 1, "functionSource": "static int init_dumping ( char * database , int init_func ( char * ) ) {\n if ( mysql_select_db ( mysql , database ) ) {\n DB_error ( mysql , \"when selecting the database\" ) ;\n return 1 ;\n }\n if ( ! path && ! opt_xml ) {\n if ( opt_databases || opt_alldbs ) {\n char quoted_database_buf [ NAME_LEN * 2 + 3 ] ;\n char * qdatabase = quote_name ( database , quoted_database_buf , opt_quoted ) ;\n print_comment ( md_result_file , 0 , \"\\n--\\n-- Current Database: %s\\n--\\n\" , qdatabase ) ;\n init_func ( qdatabase ) ;\n fprintf ( md_result_file , \"\\nUSE %s;\n\\n\" , qdatabase ) ;\n check_io ( md_result_file ) ;\n }\n }\n return 0 ;\n }", "idx": 2112}
{"hash": -4078760840682683657, "project": "chrome", "size": 10, "label": 0, "functionSource": "static int read_intra_segment_id ( VP9_COMMON * const cm , MACROBLOCKD * const xd , int mi_row , int mi_col , vp9_reader * r ) {\n struct segmentation * const seg = & cm -> seg ;\n const BLOCK_SIZE bsize = xd -> mi [ 0 ] . src_mi -> mbmi . sb_type ;\n int segment_id ;\n if ( ! seg -> enabled ) return 0 ;\n if ( ! seg -> update_map ) return 0 ;\n segment_id = read_segment_id ( r , seg ) ;\n set_segment_id ( cm , bsize , mi_row , mi_col , segment_id ) ;\n return segment_id ;\n }", "idx": 2113}
{"hash": -7670127399145950875, "project": "debian", "size": 21, "label": 0, "functionSource": "int gs_main_init0 ( gs_main_instance * minst , FILE * in , FILE * out , FILE * err , int max_lib_paths ) {\n ref * array ;\n gp_init ( ) ;\n # ifdef PACIFY_VALGRIND VALGRIND_HG_DISABLE_CHECKING ( gs_debug , 128 ) ;\n # endif memset ( gs_debug , 0 , 128 ) ;\n gs_log_errors = 0 ;\n gp_get_realtime ( minst -> base_time ) ;\n array = ( ref * ) gs_alloc_byte_array ( minst -> heap , max_lib_paths , sizeof ( ref ) , \"lib_path array\" ) ;\n if ( array == 0 ) {\n gs_lib_finit ( 1 , gs_error_VMerror , minst -> heap ) ;\n return_error ( gs_error_VMerror ) ;\n }\n make_array ( & minst -> lib_path . container , avm_foreign , max_lib_paths , array ) ;\n make_array ( & minst -> lib_path . list , avm_foreign | a_readonly , 0 , minst -> lib_path . container . value . refs ) ;\n minst -> lib_path . env = 0 ;\n minst -> lib_path . final = 0 ;\n minst -> lib_path . count = 0 ;\n minst -> user_errors = 1 ;\n minst -> init_done = 0 ;\n return 0 ;\n }", "idx": 2114}
{"hash": 3804373597256531021, "project": "debian", "size": 30, "label": 0, "functionSource": "int open_grant_tables ( THD * thd , TABLE_LIST * tables ) {\n DBUG_ENTER ( \"open_grant_tables\" ) ;\n if ( ! initialized ) {\n my_error ( ER_OPTION_PREVENTS_STATEMENT , MYF ( 0 ) , \"--skip-grant-tables\" ) ;\n DBUG_RETURN ( - 1 ) ;\n }\n bzero ( ( char * ) tables , GRANT_TABLES * sizeof ( * tables ) ) ;\n tables -> alias = tables -> table_name = ( char * ) \"user\" ;\n ( tables + 1 ) -> alias = ( tables + 1 ) -> table_name = ( char * ) \"db\" ;\n ( tables + 2 ) -> alias = ( tables + 2 ) -> table_name = ( char * ) \"tables_priv\" ;\n ( tables + 3 ) -> alias = ( tables + 3 ) -> table_name = ( char * ) \"columns_priv\" ;\n ( tables + 4 ) -> alias = ( tables + 4 ) -> table_name = ( char * ) \"procs_priv\" ;\n tables -> next_local = tables -> next_global = tables + 1 ;\n ( tables + 1 ) -> next_local = ( tables + 1 ) -> next_global = tables + 2 ;\n ( tables + 2 ) -> next_local = ( tables + 2 ) -> next_global = tables + 3 ;\n ( tables + 3 ) -> next_local = ( tables + 3 ) -> next_global = tables + 4 ;\n tables -> lock_type = ( tables + 1 ) -> lock_type = ( tables + 2 ) -> lock_type = ( tables + 3 ) -> lock_type = ( tables + 4 ) -> lock_type = TL_WRITE ;\n tables -> db = ( tables + 1 ) -> db = ( tables + 2 ) -> db = ( tables + 3 ) -> db = ( tables + 4 ) -> db = ( char * ) \"mysql\" ;\n # ifdef HAVE_REPLICATION if ( thd -> slave_thread && rpl_filter -> is_on ( ) ) {\n tables [ 0 ] . updating = tables [ 1 ] . updating = tables [ 2 ] . updating = tables [ 3 ] . updating = tables [ 4 ] . updating = 1 ;\n if ( ! ( thd -> spcont || rpl_filter -> tables_ok ( 0 , tables ) ) ) DBUG_RETURN ( 1 ) ;\n tables [ 0 ] . updating = tables [ 1 ] . updating = tables [ 2 ] . updating = tables [ 3 ] . updating = tables [ 4 ] . updating = 0 ;\n ;\n }\n # endif if ( simple_open_n_lock_tables ( thd , tables ) ) {\n close_thread_tables ( thd ) ;\n DBUG_RETURN ( - 1 ) ;\n }\n DBUG_RETURN ( 0 ) ;\n }", "idx": 2115}
{"hash": 4180964683905830761, "project": "debian", "size": 3, "label": 0, "functionSource": "static inline int default_protocol_stream ( int protocol ) {\n return ( protocol == IPPROTO_IP || protocol == IPPROTO_TCP ) ;\n }", "idx": 2116}
{"hash": 4489017523191997023, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h225_SEQUENCE_OF_H248PackagesDescriptor ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence_of ( tvb , offset , actx , tree , hf_index , ett_h225_SEQUENCE_OF_H248PackagesDescriptor , SEQUENCE_OF_H248PackagesDescriptor_sequence_of ) ;\n return offset ;\n }", "idx": 2117}
{"hash": 8801969307247112896, "project": "debian", "size": 496, "label": 1, "functionSource": "const EVP_CIPHER * EVP_aes_ ## keylen ## _ ## mode ( void ) \\ {\n return & aes_ ## keylen ## _ ## mode ;\n }\n # endif # if defined ( OPENSSL_CPUID_OBJ ) && ( defined ( __arm__ ) || defined ( __arm ) || defined ( __aarch64__ ) ) # include \"arm_arch.h\" # if __ARM_MAX_ARCH__ >= 7 # if defined ( BSAES_ASM ) # define BSAES_CAPABLE ( OPENSSL_armcap_P & ARMV7_NEON ) # endif # if defined ( VPAES_ASM ) # define VPAES_CAPABLE ( OPENSSL_armcap_P & ARMV7_NEON ) # endif # define HWAES_CAPABLE ( OPENSSL_armcap_P & ARMV8_AES ) # define HWAES_set_encrypt_key aes_v8_set_encrypt_key # define HWAES_set_decrypt_key aes_v8_set_decrypt_key # define HWAES_encrypt aes_v8_encrypt # define HWAES_decrypt aes_v8_decrypt # define HWAES_cbc_encrypt aes_v8_cbc_encrypt # define HWAES_ctr32_encrypt_blocks aes_v8_ctr32_encrypt_blocks # endif # endif # if defined ( HWAES_CAPABLE ) int HWAES_set_encrypt_key ( const unsigned char * userKey , const int bits , AES_KEY * key ) ;\n int HWAES_set_decrypt_key ( const unsigned char * userKey , const int bits , AES_KEY * key ) ;\n void HWAES_encrypt ( const unsigned char * in , unsigned char * out , const AES_KEY * key ) ;\n void HWAES_decrypt ( const unsigned char * in , unsigned char * out , const AES_KEY * key ) ;\n void HWAES_cbc_encrypt ( const unsigned char * in , unsigned char * out , size_t length , const AES_KEY * key , unsigned char * ivec , const int enc ) ;\n void HWAES_ctr32_encrypt_blocks ( const unsigned char * in , unsigned char * out , size_t len , const AES_KEY * key , const unsigned char ivec [ 16 ] ) ;\n void HWAES_xts_encrypt ( const unsigned char * inp , unsigned char * out , size_t len , const AES_KEY * key1 , const AES_KEY * key2 , const unsigned char iv [ 16 ] ) ;\n void HWAES_xts_decrypt ( const unsigned char * inp , unsigned char * out , size_t len , const AES_KEY * key1 , const AES_KEY * key2 , const unsigned char iv [ 16 ] ) ;\n # endif # define BLOCK_CIPHER_generic_pack ( nid , keylen , flags ) \\ BLOCK_CIPHER_generic ( nid , keylen , 16 , 16 , cbc , cbc , CBC , flags | EVP_CIPH_FLAG_DEFAULT_ASN1 ) \\ BLOCK_CIPHER_generic ( nid , keylen , 16 , 0 , ecb , ecb , ECB , flags | EVP_CIPH_FLAG_DEFAULT_ASN1 ) \\ BLOCK_CIPHER_generic ( nid , keylen , 1 , 16 , ofb128 , ofb , OFB , flags | EVP_CIPH_FLAG_DEFAULT_ASN1 ) \\ BLOCK_CIPHER_generic ( nid , keylen , 1 , 16 , cfb128 , cfb , CFB , flags | EVP_CIPH_FLAG_DEFAULT_ASN1 ) \\ BLOCK_CIPHER_generic ( nid , keylen , 1 , 16 , cfb1 , cfb1 , CFB , flags ) \\ BLOCK_CIPHER_generic ( nid , keylen , 1 , 16 , cfb8 , cfb8 , CFB , flags ) \\ BLOCK_CIPHER_generic ( nid , keylen , 1 , 16 , ctr , ctr , CTR , flags ) static int aes_init_key ( EVP_CIPHER_CTX * ctx , const unsigned char * key , const unsigned char * iv , int enc ) {\n int ret , mode ;\n EVP_AES_KEY * dat = EVP_C_DATA ( EVP_AES_KEY , ctx ) ;\n mode = EVP_CIPHER_CTX_mode ( ctx ) ;\n if ( ( mode == EVP_CIPH_ECB_MODE || mode == EVP_CIPH_CBC_MODE ) && ! enc ) {\n # ifdef HWAES_CAPABLE if ( HWAES_CAPABLE ) {\n ret = HWAES_set_decrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & dat -> ks . ks ) ;\n dat -> block = ( block128_f ) HWAES_decrypt ;\n dat -> stream . cbc = NULL ;\n # ifdef HWAES_cbc_encrypt if ( mode == EVP_CIPH_CBC_MODE ) dat -> stream . cbc = ( cbc128_f ) HWAES_cbc_encrypt ;\n # endif }\n else # endif # ifdef BSAES_CAPABLE if ( BSAES_CAPABLE && mode == EVP_CIPH_CBC_MODE ) {\n ret = AES_set_decrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & dat -> ks . ks ) ;\n dat -> block = ( block128_f ) AES_decrypt ;\n dat -> stream . cbc = ( cbc128_f ) bsaes_cbc_encrypt ;\n }\n else # endif # ifdef VPAES_CAPABLE if ( VPAES_CAPABLE ) {\n ret = vpaes_set_decrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & dat -> ks . ks ) ;\n dat -> block = ( block128_f ) vpaes_decrypt ;\n dat -> stream . cbc = mode == EVP_CIPH_CBC_MODE ? ( cbc128_f ) vpaes_cbc_encrypt : NULL ;\n }\n else # endif {\n ret = AES_set_decrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & dat -> ks . ks ) ;\n dat -> block = ( block128_f ) AES_decrypt ;\n dat -> stream . cbc = mode == EVP_CIPH_CBC_MODE ? ( cbc128_f ) AES_cbc_encrypt : NULL ;\n }\n }\n else # ifdef HWAES_CAPABLE if ( HWAES_CAPABLE ) {\n ret = HWAES_set_encrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & dat -> ks . ks ) ;\n dat -> block = ( block128_f ) HWAES_encrypt ;\n dat -> stream . cbc = NULL ;\n # ifdef HWAES_cbc_encrypt if ( mode == EVP_CIPH_CBC_MODE ) dat -> stream . cbc = ( cbc128_f ) HWAES_cbc_encrypt ;\n else # endif # ifdef HWAES_ctr32_encrypt_blocks if ( mode == EVP_CIPH_CTR_MODE ) dat -> stream . ctr = ( ctr128_f ) HWAES_ctr32_encrypt_blocks ;\n else # endif ( void ) 0 ;\n }\n else # endif # ifdef BSAES_CAPABLE if ( BSAES_CAPABLE && mode == EVP_CIPH_CTR_MODE ) {\n ret = AES_set_encrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & dat -> ks . ks ) ;\n dat -> block = ( block128_f ) AES_encrypt ;\n dat -> stream . ctr = ( ctr128_f ) bsaes_ctr32_encrypt_blocks ;\n }\n else # endif # ifdef VPAES_CAPABLE if ( VPAES_CAPABLE ) {\n ret = vpaes_set_encrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & dat -> ks . ks ) ;\n dat -> block = ( block128_f ) vpaes_encrypt ;\n dat -> stream . cbc = mode == EVP_CIPH_CBC_MODE ? ( cbc128_f ) vpaes_cbc_encrypt : NULL ;\n }\n else # endif {\n ret = AES_set_encrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & dat -> ks . ks ) ;\n dat -> block = ( block128_f ) AES_encrypt ;\n dat -> stream . cbc = mode == EVP_CIPH_CBC_MODE ? ( cbc128_f ) AES_cbc_encrypt : NULL ;\n # ifdef AES_CTR_ASM if ( mode == EVP_CIPH_CTR_MODE ) dat -> stream . ctr = ( ctr128_f ) AES_ctr32_encrypt ;\n # endif }\n if ( ret < 0 ) {\n EVPerr ( EVP_F_AES_INIT_KEY , EVP_R_AES_KEY_SETUP_FAILED ) ;\n return 0 ;\n }\n return 1 ;\n }\n static int aes_cbc_cipher ( EVP_CIPHER_CTX * ctx , unsigned char * out , const unsigned char * in , size_t len ) {\n EVP_AES_KEY * dat = EVP_C_DATA ( EVP_AES_KEY , ctx ) ;\n if ( dat -> stream . cbc ) ( * dat -> stream . cbc ) ( in , out , len , & dat -> ks , EVP_CIPHER_CTX_iv_noconst ( ctx ) , EVP_CIPHER_CTX_encrypting ( ctx ) ) ;\n else if ( EVP_CIPHER_CTX_encrypting ( ctx ) ) CRYPTO_cbc128_encrypt ( in , out , len , & dat -> ks , EVP_CIPHER_CTX_iv_noconst ( ctx ) , dat -> block ) ;\n else CRYPTO_cbc128_decrypt ( in , out , len , & dat -> ks , EVP_CIPHER_CTX_iv_noconst ( ctx ) , dat -> block ) ;\n return 1 ;\n }\n static int aes_ecb_cipher ( EVP_CIPHER_CTX * ctx , unsigned char * out , const unsigned char * in , size_t len ) {\n size_t bl = EVP_CIPHER_CTX_block_size ( ctx ) ;\n size_t i ;\n EVP_AES_KEY * dat = EVP_C_DATA ( EVP_AES_KEY , ctx ) ;\n if ( len < bl ) return 1 ;\n for ( i = 0 , len -= bl ;\n i <= len ;\n i += bl ) ( * dat -> block ) ( in + i , out + i , & dat -> ks ) ;\n return 1 ;\n }\n static int aes_ofb_cipher ( EVP_CIPHER_CTX * ctx , unsigned char * out , const unsigned char * in , size_t len ) {\n EVP_AES_KEY * dat = EVP_C_DATA ( EVP_AES_KEY , ctx ) ;\n int num = EVP_CIPHER_CTX_num ( ctx ) ;\n CRYPTO_ofb128_encrypt ( in , out , len , & dat -> ks , EVP_CIPHER_CTX_iv_noconst ( ctx ) , & num , dat -> block ) ;\n EVP_CIPHER_CTX_set_num ( ctx , num ) ;\n return 1 ;\n }\n static int aes_cfb_cipher ( EVP_CIPHER_CTX * ctx , unsigned char * out , const unsigned char * in , size_t len ) {\n EVP_AES_KEY * dat = EVP_C_DATA ( EVP_AES_KEY , ctx ) ;\n int num = EVP_CIPHER_CTX_num ( ctx ) ;\n CRYPTO_cfb128_encrypt ( in , out , len , & dat -> ks , EVP_CIPHER_CTX_iv_noconst ( ctx ) , & num , EVP_CIPHER_CTX_encrypting ( ctx ) , dat -> block ) ;\n EVP_CIPHER_CTX_set_num ( ctx , num ) ;\n return 1 ;\n }\n static int aes_cfb8_cipher ( EVP_CIPHER_CTX * ctx , unsigned char * out , const unsigned char * in , size_t len ) {\n EVP_AES_KEY * dat = EVP_C_DATA ( EVP_AES_KEY , ctx ) ;\n int num = EVP_CIPHER_CTX_num ( ctx ) ;\n CRYPTO_cfb128_8_encrypt ( in , out , len , & dat -> ks , EVP_CIPHER_CTX_iv_noconst ( ctx ) , & num , EVP_CIPHER_CTX_encrypting ( ctx ) , dat -> block ) ;\n EVP_CIPHER_CTX_set_num ( ctx , num ) ;\n return 1 ;\n }\n static int aes_cfb1_cipher ( EVP_CIPHER_CTX * ctx , unsigned char * out , const unsigned char * in , size_t len ) {\n EVP_AES_KEY * dat = EVP_C_DATA ( EVP_AES_KEY , ctx ) ;\n if ( EVP_CIPHER_CTX_test_flags ( ctx , EVP_CIPH_FLAG_LENGTH_BITS ) ) {\n int num = EVP_CIPHER_CTX_num ( ctx ) ;\n CRYPTO_cfb128_1_encrypt ( in , out , len , & dat -> ks , EVP_CIPHER_CTX_iv_noconst ( ctx ) , & num , EVP_CIPHER_CTX_encrypting ( ctx ) , dat -> block ) ;\n EVP_CIPHER_CTX_set_num ( ctx , num ) ;\n return 1 ;\n }\n while ( len >= MAXBITCHUNK ) {\n int num = EVP_CIPHER_CTX_num ( ctx ) ;\n CRYPTO_cfb128_1_encrypt ( in , out , MAXBITCHUNK * 8 , & dat -> ks , EVP_CIPHER_CTX_iv_noconst ( ctx ) , & num , EVP_CIPHER_CTX_encrypting ( ctx ) , dat -> block ) ;\n EVP_CIPHER_CTX_set_num ( ctx , num ) ;\n len -= MAXBITCHUNK ;\n }\n if ( len ) {\n int num = EVP_CIPHER_CTX_num ( ctx ) ;\n CRYPTO_cfb128_1_encrypt ( in , out , len * 8 , & dat -> ks , EVP_CIPHER_CTX_iv_noconst ( ctx ) , & num , EVP_CIPHER_CTX_encrypting ( ctx ) , dat -> block ) ;\n EVP_CIPHER_CTX_set_num ( ctx , num ) ;\n }\n return 1 ;\n }\n static int aes_ctr_cipher ( EVP_CIPHER_CTX * ctx , unsigned char * out , const unsigned char * in , size_t len ) {\n unsigned int num = EVP_CIPHER_CTX_num ( ctx ) ;\n EVP_AES_KEY * dat = EVP_C_DATA ( EVP_AES_KEY , ctx ) ;\n if ( dat -> stream . ctr ) CRYPTO_ctr128_encrypt_ctr32 ( in , out , len , & dat -> ks , EVP_CIPHER_CTX_iv_noconst ( ctx ) , EVP_CIPHER_CTX_buf_noconst ( ctx ) , & num , dat -> stream . ctr ) ;\n else CRYPTO_ctr128_encrypt ( in , out , len , & dat -> ks , EVP_CIPHER_CTX_iv_noconst ( ctx ) , EVP_CIPHER_CTX_buf_noconst ( ctx ) , & num , dat -> block ) ;\n EVP_CIPHER_CTX_set_num ( ctx , num ) ;\n return 1 ;\n }\n BLOCK_CIPHER_generic_pack ( NID_aes , 128 , 0 ) BLOCK_CIPHER_generic_pack ( NID_aes , 192 , 0 ) BLOCK_CIPHER_generic_pack ( NID_aes , 256 , 0 ) static int aes_gcm_cleanup ( EVP_CIPHER_CTX * c ) {\n EVP_AES_GCM_CTX * gctx = EVP_C_DATA ( EVP_AES_GCM_CTX , c ) ;\n OPENSSL_cleanse ( & gctx -> gcm , sizeof ( gctx -> gcm ) ) ;\n if ( gctx -> iv != EVP_CIPHER_CTX_iv_noconst ( c ) ) OPENSSL_free ( gctx -> iv ) ;\n return 1 ;\n }\n static void ctr64_inc ( unsigned char * counter ) {\n int n = 8 ;\n unsigned char c ;\n do {\n -- n ;\n c = counter [ n ] ;\n ++ c ;\n counter [ n ] = c ;\n if ( c ) return ;\n }\n while ( n ) ;\n }\n static int aes_gcm_ctrl ( EVP_CIPHER_CTX * c , int type , int arg , void * ptr ) {\n EVP_AES_GCM_CTX * gctx = EVP_C_DATA ( EVP_AES_GCM_CTX , c ) ;\n switch ( type ) {\n case EVP_CTRL_INIT : gctx -> key_set = 0 ;\n gctx -> iv_set = 0 ;\n gctx -> ivlen = EVP_CIPHER_CTX_iv_length ( c ) ;\n gctx -> iv = EVP_CIPHER_CTX_iv_noconst ( c ) ;\n gctx -> taglen = - 1 ;\n gctx -> iv_gen = 0 ;\n gctx -> tls_aad_len = - 1 ;\n return 1 ;\n case EVP_CTRL_AEAD_SET_IVLEN : if ( arg <= 0 ) return 0 ;\n if ( ( arg > EVP_MAX_IV_LENGTH ) && ( arg > gctx -> ivlen ) ) {\n if ( gctx -> iv != EVP_CIPHER_CTX_iv_noconst ( c ) ) OPENSSL_free ( gctx -> iv ) ;\n gctx -> iv = OPENSSL_malloc ( arg ) ;\n if ( gctx -> iv == NULL ) return 0 ;\n }\n gctx -> ivlen = arg ;\n return 1 ;\n case EVP_CTRL_AEAD_SET_TAG : if ( arg <= 0 || arg > 16 || EVP_CIPHER_CTX_encrypting ( c ) ) return 0 ;\n memcpy ( EVP_CIPHER_CTX_buf_noconst ( c ) , ptr , arg ) ;\n gctx -> taglen = arg ;\n return 1 ;\n case EVP_CTRL_AEAD_GET_TAG : if ( arg <= 0 || arg > 16 || ! EVP_CIPHER_CTX_encrypting ( c ) || gctx -> taglen < 0 ) return 0 ;\n memcpy ( ptr , EVP_CIPHER_CTX_buf_noconst ( c ) , arg ) ;\n return 1 ;\n case EVP_CTRL_GCM_SET_IV_FIXED : if ( arg == - 1 ) {\n memcpy ( gctx -> iv , ptr , gctx -> ivlen ) ;\n gctx -> iv_gen = 1 ;\n return 1 ;\n }\n if ( ( arg < 4 ) || ( gctx -> ivlen - arg ) < 8 ) return 0 ;\n if ( arg ) memcpy ( gctx -> iv , ptr , arg ) ;\n if ( EVP_CIPHER_CTX_encrypting ( c ) && RAND_bytes ( gctx -> iv + arg , gctx -> ivlen - arg ) <= 0 ) return 0 ;\n gctx -> iv_gen = 1 ;\n return 1 ;\n case EVP_CTRL_GCM_IV_GEN : if ( gctx -> iv_gen == 0 || gctx -> key_set == 0 ) return 0 ;\n CRYPTO_gcm128_setiv ( & gctx -> gcm , gctx -> iv , gctx -> ivlen ) ;\n if ( arg <= 0 || arg > gctx -> ivlen ) arg = gctx -> ivlen ;\n memcpy ( ptr , gctx -> iv + gctx -> ivlen - arg , arg ) ;\n ctr64_inc ( gctx -> iv + gctx -> ivlen - 8 ) ;\n gctx -> iv_set = 1 ;\n return 1 ;\n case EVP_CTRL_GCM_SET_IV_INV : if ( gctx -> iv_gen == 0 || gctx -> key_set == 0 || EVP_CIPHER_CTX_encrypting ( c ) ) return 0 ;\n memcpy ( gctx -> iv + gctx -> ivlen - arg , ptr , arg ) ;\n CRYPTO_gcm128_setiv ( & gctx -> gcm , gctx -> iv , gctx -> ivlen ) ;\n gctx -> iv_set = 1 ;\n return 1 ;\n case EVP_CTRL_AEAD_TLS1_AAD : if ( arg != EVP_AEAD_TLS1_AAD_LEN ) return 0 ;\n memcpy ( EVP_CIPHER_CTX_buf_noconst ( c ) , ptr , arg ) ;\n gctx -> tls_aad_len = arg ;\n {\n unsigned int len = EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 2 ] << 8 | EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 1 ] ;\n len -= EVP_GCM_TLS_EXPLICIT_IV_LEN ;\n if ( ! EVP_CIPHER_CTX_encrypting ( c ) ) len -= EVP_GCM_TLS_TAG_LEN ;\n EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 2 ] = len >> 8 ;\n EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 1 ] = len & 0xff ;\n }\n return EVP_GCM_TLS_TAG_LEN ;\n case EVP_CTRL_COPY : {\n EVP_CIPHER_CTX * out = ptr ;\n EVP_AES_GCM_CTX * gctx_out = EVP_C_DATA ( EVP_AES_GCM_CTX , out ) ;\n if ( gctx -> gcm . key ) {\n if ( gctx -> gcm . key != & gctx -> ks ) return 0 ;\n gctx_out -> gcm . key = & gctx_out -> ks ;\n }\n if ( gctx -> iv == EVP_CIPHER_CTX_iv_noconst ( c ) ) gctx_out -> iv = EVP_CIPHER_CTX_iv_noconst ( out ) ;\n else {\n gctx_out -> iv = OPENSSL_malloc ( gctx -> ivlen ) ;\n if ( gctx_out -> iv == NULL ) return 0 ;\n memcpy ( gctx_out -> iv , gctx -> iv , gctx -> ivlen ) ;\n }\n return 1 ;\n }\n default : return - 1 ;\n }\n }\n static int aes_gcm_init_key ( EVP_CIPHER_CTX * ctx , const unsigned char * key , const unsigned char * iv , int enc ) {\n EVP_AES_GCM_CTX * gctx = EVP_C_DATA ( EVP_AES_GCM_CTX , ctx ) ;\n if ( ! iv && ! key ) return 1 ;\n if ( key ) {\n do {\n # ifdef HWAES_CAPABLE if ( HWAES_CAPABLE ) {\n HWAES_set_encrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & gctx -> ks . ks ) ;\n CRYPTO_gcm128_init ( & gctx -> gcm , & gctx -> ks , ( block128_f ) HWAES_encrypt ) ;\n # ifdef HWAES_ctr32_encrypt_blocks gctx -> ctr = ( ctr128_f ) HWAES_ctr32_encrypt_blocks ;\n # else gctx -> ctr = NULL ;\n # endif break ;\n }\n else # endif # ifdef BSAES_CAPABLE if ( BSAES_CAPABLE ) {\n AES_set_encrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & gctx -> ks . ks ) ;\n CRYPTO_gcm128_init ( & gctx -> gcm , & gctx -> ks , ( block128_f ) AES_encrypt ) ;\n gctx -> ctr = ( ctr128_f ) bsaes_ctr32_encrypt_blocks ;\n break ;\n }\n else # endif # ifdef VPAES_CAPABLE if ( VPAES_CAPABLE ) {\n vpaes_set_encrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & gctx -> ks . ks ) ;\n CRYPTO_gcm128_init ( & gctx -> gcm , & gctx -> ks , ( block128_f ) vpaes_encrypt ) ;\n gctx -> ctr = NULL ;\n break ;\n }\n else # endif ( void ) 0 ;\n AES_set_encrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & gctx -> ks . ks ) ;\n CRYPTO_gcm128_init ( & gctx -> gcm , & gctx -> ks , ( block128_f ) AES_encrypt ) ;\n # ifdef AES_CTR_ASM gctx -> ctr = ( ctr128_f ) AES_ctr32_encrypt ;\n # else gctx -> ctr = NULL ;\n # endif }\n while ( 0 ) ;\n if ( iv == NULL && gctx -> iv_set ) iv = gctx -> iv ;\n if ( iv ) {\n CRYPTO_gcm128_setiv ( & gctx -> gcm , iv , gctx -> ivlen ) ;\n gctx -> iv_set = 1 ;\n }\n gctx -> key_set = 1 ;\n }\n else {\n if ( gctx -> key_set ) CRYPTO_gcm128_setiv ( & gctx -> gcm , iv , gctx -> ivlen ) ;\n else memcpy ( gctx -> iv , iv , gctx -> ivlen ) ;\n gctx -> iv_set = 1 ;\n gctx -> iv_gen = 0 ;\n }\n return 1 ;\n }\n static int aes_gcm_tls_cipher ( EVP_CIPHER_CTX * ctx , unsigned char * out , const unsigned char * in , size_t len ) {\n EVP_AES_GCM_CTX * gctx = EVP_C_DATA ( EVP_AES_GCM_CTX , ctx ) ;\n int rv = - 1 ;\n if ( out != in || len < ( EVP_GCM_TLS_EXPLICIT_IV_LEN + EVP_GCM_TLS_TAG_LEN ) ) return - 1 ;\n if ( EVP_CIPHER_CTX_ctrl ( ctx , EVP_CIPHER_CTX_encrypting ( ctx ) ? EVP_CTRL_GCM_IV_GEN : EVP_CTRL_GCM_SET_IV_INV , EVP_GCM_TLS_EXPLICIT_IV_LEN , out ) <= 0 ) goto err ;\n if ( CRYPTO_gcm128_aad ( & gctx -> gcm , EVP_CIPHER_CTX_buf_noconst ( ctx ) , gctx -> tls_aad_len ) ) goto err ;\n in += EVP_GCM_TLS_EXPLICIT_IV_LEN ;\n out += EVP_GCM_TLS_EXPLICIT_IV_LEN ;\n len -= EVP_GCM_TLS_EXPLICIT_IV_LEN + EVP_GCM_TLS_TAG_LEN ;\n if ( EVP_CIPHER_CTX_encrypting ( ctx ) ) {\n if ( gctx -> ctr ) {\n size_t bulk = 0 ;\n # if defined ( AES_GCM_ASM ) if ( len >= 32 && AES_GCM_ASM ( gctx ) ) {\n if ( CRYPTO_gcm128_encrypt ( & gctx -> gcm , NULL , NULL , 0 ) ) return - 1 ;\n bulk = AES_gcm_encrypt ( in , out , len , gctx -> gcm . key , gctx -> gcm . Yi . c , gctx -> gcm . Xi . u ) ;\n gctx -> gcm . len . u [ 1 ] += bulk ;\n }\n # endif if ( CRYPTO_gcm128_encrypt_ctr32 ( & gctx -> gcm , in + bulk , out + bulk , len - bulk , gctx -> ctr ) ) goto err ;\n }\n else {\n size_t bulk = 0 ;\n # if defined ( AES_GCM_ASM2 ) if ( len >= 32 && AES_GCM_ASM2 ( gctx ) ) {\n if ( CRYPTO_gcm128_encrypt ( & gctx -> gcm , NULL , NULL , 0 ) ) return - 1 ;\n bulk = AES_gcm_encrypt ( in , out , len , gctx -> gcm . key , gctx -> gcm . Yi . c , gctx -> gcm . Xi . u ) ;\n gctx -> gcm . len . u [ 1 ] += bulk ;\n }\n # endif if ( CRYPTO_gcm128_encrypt ( & gctx -> gcm , in + bulk , out + bulk , len - bulk ) ) goto err ;\n }\n out += len ;\n CRYPTO_gcm128_tag ( & gctx -> gcm , out , EVP_GCM_TLS_TAG_LEN ) ;\n rv = len + EVP_GCM_TLS_EXPLICIT_IV_LEN + EVP_GCM_TLS_TAG_LEN ;\n }\n else {\n if ( gctx -> ctr ) {\n size_t bulk = 0 ;\n # if defined ( AES_GCM_ASM ) if ( len >= 16 && AES_GCM_ASM ( gctx ) ) {\n if ( CRYPTO_gcm128_decrypt ( & gctx -> gcm , NULL , NULL , 0 ) ) return - 1 ;\n bulk = AES_gcm_decrypt ( in , out , len , gctx -> gcm . key , gctx -> gcm . Yi . c , gctx -> gcm . Xi . u ) ;\n gctx -> gcm . len . u [ 1 ] += bulk ;\n }\n # endif if ( CRYPTO_gcm128_decrypt_ctr32 ( & gctx -> gcm , in + bulk , out + bulk , len - bulk , gctx -> ctr ) ) goto err ;\n }\n else {\n size_t bulk = 0 ;\n # if defined ( AES_GCM_ASM2 ) if ( len >= 16 && AES_GCM_ASM2 ( gctx ) ) {\n if ( CRYPTO_gcm128_decrypt ( & gctx -> gcm , NULL , NULL , 0 ) ) return - 1 ;\n bulk = AES_gcm_decrypt ( in , out , len , gctx -> gcm . key , gctx -> gcm . Yi . c , gctx -> gcm . Xi . u ) ;\n gctx -> gcm . len . u [ 1 ] += bulk ;\n }\n # endif if ( CRYPTO_gcm128_decrypt ( & gctx -> gcm , in + bulk , out + bulk , len - bulk ) ) goto err ;\n }\n CRYPTO_gcm128_tag ( & gctx -> gcm , EVP_CIPHER_CTX_buf_noconst ( ctx ) , EVP_GCM_TLS_TAG_LEN ) ;\n if ( CRYPTO_memcmp ( EVP_CIPHER_CTX_buf_noconst ( ctx ) , in + len , EVP_GCM_TLS_TAG_LEN ) ) {\n OPENSSL_cleanse ( out , len ) ;\n goto err ;\n }\n rv = len ;\n }\n err : gctx -> iv_set = 0 ;\n gctx -> tls_aad_len = - 1 ;\n return rv ;\n }\n static int aes_gcm_cipher ( EVP_CIPHER_CTX * ctx , unsigned char * out , const unsigned char * in , size_t len ) {\n EVP_AES_GCM_CTX * gctx = EVP_C_DATA ( EVP_AES_GCM_CTX , ctx ) ;\n if ( ! gctx -> key_set ) return - 1 ;\n if ( gctx -> tls_aad_len >= 0 ) return aes_gcm_tls_cipher ( ctx , out , in , len ) ;\n if ( ! gctx -> iv_set ) return - 1 ;\n if ( in ) {\n if ( out == NULL ) {\n if ( CRYPTO_gcm128_aad ( & gctx -> gcm , in , len ) ) return - 1 ;\n }\n else if ( EVP_CIPHER_CTX_encrypting ( ctx ) ) {\n if ( gctx -> ctr ) {\n size_t bulk = 0 ;\n # if defined ( AES_GCM_ASM ) if ( len >= 32 && AES_GCM_ASM ( gctx ) ) {\n size_t res = ( 16 - gctx -> gcm . mres ) % 16 ;\n if ( CRYPTO_gcm128_encrypt ( & gctx -> gcm , in , out , res ) ) return - 1 ;\n bulk = AES_gcm_encrypt ( in + res , out + res , len - res , gctx -> gcm . key , gctx -> gcm . Yi . c , gctx -> gcm . Xi . u ) ;\n gctx -> gcm . len . u [ 1 ] += bulk ;\n bulk += res ;\n }\n # endif if ( CRYPTO_gcm128_encrypt_ctr32 ( & gctx -> gcm , in + bulk , out + bulk , len - bulk , gctx -> ctr ) ) return - 1 ;\n }\n else {\n size_t bulk = 0 ;\n # if defined ( AES_GCM_ASM2 ) if ( len >= 32 && AES_GCM_ASM2 ( gctx ) ) {\n size_t res = ( 16 - gctx -> gcm . mres ) % 16 ;\n if ( CRYPTO_gcm128_encrypt ( & gctx -> gcm , in , out , res ) ) return - 1 ;\n bulk = AES_gcm_encrypt ( in + res , out + res , len - res , gctx -> gcm . key , gctx -> gcm . Yi . c , gctx -> gcm . Xi . u ) ;\n gctx -> gcm . len . u [ 1 ] += bulk ;\n bulk += res ;\n }\n # endif if ( CRYPTO_gcm128_encrypt ( & gctx -> gcm , in + bulk , out + bulk , len - bulk ) ) return - 1 ;\n }\n }\n else {\n if ( gctx -> ctr ) {\n size_t bulk = 0 ;\n # if defined ( AES_GCM_ASM ) if ( len >= 16 && AES_GCM_ASM ( gctx ) ) {\n size_t res = ( 16 - gctx -> gcm . mres ) % 16 ;\n if ( CRYPTO_gcm128_decrypt ( & gctx -> gcm , in , out , res ) ) return - 1 ;\n bulk = AES_gcm_decrypt ( in + res , out + res , len - res , gctx -> gcm . key , gctx -> gcm . Yi . c , gctx -> gcm . Xi . u ) ;\n gctx -> gcm . len . u [ 1 ] += bulk ;\n bulk += res ;\n }\n # endif if ( CRYPTO_gcm128_decrypt_ctr32 ( & gctx -> gcm , in + bulk , out + bulk , len - bulk , gctx -> ctr ) ) return - 1 ;\n }\n else {\n size_t bulk = 0 ;\n # if defined ( AES_GCM_ASM2 ) if ( len >= 16 && AES_GCM_ASM2 ( gctx ) ) {\n size_t res = ( 16 - gctx -> gcm . mres ) % 16 ;\n if ( CRYPTO_gcm128_decrypt ( & gctx -> gcm , in , out , res ) ) return - 1 ;\n bulk = AES_gcm_decrypt ( in + res , out + res , len - res , gctx -> gcm . key , gctx -> gcm . Yi . c , gctx -> gcm . Xi . u ) ;\n gctx -> gcm . len . u [ 1 ] += bulk ;\n bulk += res ;\n }\n # endif if ( CRYPTO_gcm128_decrypt ( & gctx -> gcm , in + bulk , out + bulk , len - bulk ) ) return - 1 ;\n }\n }\n return len ;\n }\n else {\n if ( ! EVP_CIPHER_CTX_encrypting ( ctx ) ) {\n if ( gctx -> taglen < 0 ) return - 1 ;\n if ( CRYPTO_gcm128_finish ( & gctx -> gcm , EVP_CIPHER_CTX_buf_noconst ( ctx ) , gctx -> taglen ) != 0 ) return - 1 ;\n gctx -> iv_set = 0 ;\n return 0 ;\n }\n CRYPTO_gcm128_tag ( & gctx -> gcm , EVP_CIPHER_CTX_buf_noconst ( ctx ) , 16 ) ;\n gctx -> taglen = 16 ;\n gctx -> iv_set = 0 ;\n return 0 ;\n }\n }\n # define CUSTOM_FLAGS ( EVP_CIPH_FLAG_DEFAULT_ASN1 \\ | EVP_CIPH_CUSTOM_IV | EVP_CIPH_FLAG_CUSTOM_CIPHER \\ | EVP_CIPH_ALWAYS_CALL_INIT | EVP_CIPH_CTRL_INIT \\ | EVP_CIPH_CUSTOM_COPY ) BLOCK_CIPHER_custom ( NID_aes , 128 , 1 , 12 , gcm , GCM , EVP_CIPH_FLAG_AEAD_CIPHER | CUSTOM_FLAGS ) BLOCK_CIPHER_custom ( NID_aes , 192 , 1 , 12 , gcm , GCM , EVP_CIPH_FLAG_AEAD_CIPHER | CUSTOM_FLAGS ) BLOCK_CIPHER_custom ( NID_aes , 256 , 1 , 12 , gcm , GCM , EVP_CIPH_FLAG_AEAD_CIPHER | CUSTOM_FLAGS ) static int aes_xts_ctrl ( EVP_CIPHER_CTX * c , int type , int arg , void * ptr ) {\n EVP_AES_XTS_CTX * xctx = EVP_C_DATA ( EVP_AES_XTS_CTX , c ) ;\n if ( type == EVP_CTRL_COPY ) {\n EVP_CIPHER_CTX * out = ptr ;\n EVP_AES_XTS_CTX * xctx_out = EVP_C_DATA ( EVP_AES_XTS_CTX , out ) ;\n if ( xctx -> xts . key1 ) {\n if ( xctx -> xts . key1 != & xctx -> ks1 ) return 0 ;\n xctx_out -> xts . key1 = & xctx_out -> ks1 ;\n }\n if ( xctx -> xts . key2 ) {\n if ( xctx -> xts . key2 != & xctx -> ks2 ) return 0 ;\n xctx_out -> xts . key2 = & xctx_out -> ks2 ;\n }\n return 1 ;\n }\n else if ( type != EVP_CTRL_INIT ) return - 1 ;\n xctx -> xts . key1 = NULL ;\n xctx -> xts . key2 = NULL ;\n return 1 ;\n }\n static int aes_xts_init_key ( EVP_CIPHER_CTX * ctx , const unsigned char * key , const unsigned char * iv , int enc ) {\n EVP_AES_XTS_CTX * xctx = EVP_C_DATA ( EVP_AES_XTS_CTX , ctx ) ;\n if ( ! iv && ! key ) return 1 ;\n if ( key ) do {\n # ifdef AES_XTS_ASM xctx -> stream = enc ? AES_xts_encrypt : AES_xts_decrypt ;\n # else xctx -> stream = NULL ;\n # endif # ifdef HWAES_CAPABLE if ( HWAES_CAPABLE ) {\n if ( enc ) {\n HWAES_set_encrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 4 , & xctx -> ks1 . ks ) ;\n xctx -> xts . block1 = ( block128_f ) HWAES_encrypt ;\n # ifdef HWAES_xts_encrypt xctx -> stream = HWAES_xts_encrypt ;\n # endif }\n else {\n HWAES_set_decrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 4 , & xctx -> ks1 . ks ) ;\n xctx -> xts . block1 = ( block128_f ) HWAES_decrypt ;\n # ifdef HWAES_xts_decrypt xctx -> stream = HWAES_xts_decrypt ;\n # endif }\n HWAES_set_encrypt_key ( key + EVP_CIPHER_CTX_key_length ( ctx ) / 2 , EVP_CIPHER_CTX_key_length ( ctx ) * 4 , & xctx -> ks2 . ks ) ;\n xctx -> xts . block2 = ( block128_f ) HWAES_encrypt ;\n xctx -> xts . key1 = & xctx -> ks1 ;\n break ;\n }\n else # endif # ifdef BSAES_CAPABLE if ( BSAES_CAPABLE ) xctx -> stream = enc ? bsaes_xts_encrypt : bsaes_xts_decrypt ;\n else # endif # ifdef VPAES_CAPABLE if ( VPAES_CAPABLE ) {\n if ( enc ) {\n vpaes_set_encrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 4 , & xctx -> ks1 . ks ) ;\n xctx -> xts . block1 = ( block128_f ) vpaes_encrypt ;\n }\n else {\n vpaes_set_decrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 4 , & xctx -> ks1 . ks ) ;\n xctx -> xts . block1 = ( block128_f ) vpaes_decrypt ;\n }\n vpaes_set_encrypt_key ( key + EVP_CIPHER_CTX_key_length ( ctx ) / 2 , EVP_CIPHER_CTX_key_length ( ctx ) * 4 , & xctx -> ks2 . ks ) ;\n xctx -> xts . block2 = ( block128_f ) vpaes_encrypt ;\n xctx -> xts . key1 = & xctx -> ks1 ;\n break ;\n }\n else # endif ( void ) 0 ;\n if ( enc ) {\n AES_set_encrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 4 , & xctx -> ks1 . ks ) ;\n xctx -> xts . block1 = ( block128_f ) AES_encrypt ;\n }\n else {\n AES_set_decrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 4 , & xctx -> ks1 . ks ) ;\n xctx -> xts . block1 = ( block128_f ) AES_decrypt ;\n }\n AES_set_encrypt_key ( key + EVP_CIPHER_CTX_key_length ( ctx ) / 2 , EVP_CIPHER_CTX_key_length ( ctx ) * 4 , & xctx -> ks2 . ks ) ;\n xctx -> xts . block2 = ( block128_f ) AES_encrypt ;\n xctx -> xts . key1 = & xctx -> ks1 ;\n }\n while ( 0 ) ;\n if ( iv ) {\n xctx -> xts . key2 = & xctx -> ks2 ;\n memcpy ( EVP_CIPHER_CTX_iv_noconst ( ctx ) , iv , 16 ) ;\n }\n return 1 ;\n }\n static int aes_xts_cipher ( EVP_CIPHER_CTX * ctx , unsigned char * out , const unsigned char * in , size_t len ) {\n EVP_AES_XTS_CTX * xctx = EVP_C_DATA ( EVP_AES_XTS_CTX , ctx ) ;\n if ( ! xctx -> xts . key1 || ! xctx -> xts . key2 ) return 0 ;\n if ( ! out || ! in || len < AES_BLOCK_SIZE ) return 0 ;\n if ( xctx -> stream ) ( * xctx -> stream ) ( in , out , len , xctx -> xts . key1 , xctx -> xts . key2 , EVP_CIPHER_CTX_iv_noconst ( ctx ) ) ;\n else if ( CRYPTO_xts128_encrypt ( & xctx -> xts , EVP_CIPHER_CTX_iv_noconst ( ctx ) , in , out , len , EVP_CIPHER_CTX_encrypting ( ctx ) ) ) return 0 ;\n return 1 ;\n }\n # define aes_xts_cleanup NULL # define XTS_FLAGS ( EVP_CIPH_FLAG_DEFAULT_ASN1 | EVP_CIPH_CUSTOM_IV \\ | EVP_CIPH_ALWAYS_CALL_INIT | EVP_CIPH_CTRL_INIT \\ | EVP_CIPH_CUSTOM_COPY ) BLOCK_CIPHER_custom ( NID_aes , 128 , 1 , 16 , xts , XTS , XTS_FLAGS ) BLOCK_CIPHER_custom ( NID_aes , 256 , 1 , 16 , xts , XTS , XTS_FLAGS )", "idx": 2118}
{"hash": -8933711118846965366, "project": "debian", "size": 20, "label": 0, "functionSource": "static void cirrus_mem_writeb_mode4and5_16bpp ( CirrusVGAState * s , unsigned mode , unsigned offset , uint32_t mem_value ) {\n int x ;\n unsigned val = mem_value ;\n uint8_t * dst ;\n for ( x = 0 ;\n x < 8 ;\n x ++ ) {\n dst = s -> vga . vram_ptr + ( ( offset + 2 * x ) & s -> cirrus_addr_mask & ~ 1 ) ;\n if ( val & 0x80 ) {\n * dst = s -> cirrus_shadow_gr1 ;\n * ( dst + 1 ) = s -> vga . gr [ 0x11 ] ;\n }\n else if ( mode == 5 ) {\n * dst = s -> cirrus_shadow_gr0 ;\n * ( dst + 1 ) = s -> vga . gr [ 0x10 ] ;\n }\n val <<= 1 ;\n }\n memory_region_set_dirty ( & s -> vga . vram , offset , 16 ) ;\n }", "idx": 2119}
{"hash": -2607754285145856562, "project": "debian", "size": 14, "label": 0, "functionSource": "static void idr_resolve ( struct idr * idr , void ( * fsetnum ) ( unsigned char * p , int num ) ) {\n struct idrent * n ;\n unsigned char * p ;\n for ( n = idr -> wait_list . first ;\n n != NULL ;\n n = n -> wnext ) {\n idr_extend_identifier ( n , idr -> num_size , idr -> null_size ) ;\n p = ( unsigned char * ) n -> isoent -> identifier + n -> noff ;\n do {\n fsetnum ( p , n -> avail -> rename_num ++ ) ;\n }\n while ( ! __archive_rb_tree_insert_node ( & ( idr -> rbtree ) , & ( n -> rbnode ) ) ) ;\n }\n }", "idx": 2120}
{"hash": 2578089348587614328, "project": "debian", "size": 3, "label": 0, "functionSource": "int i2d_PUBKEY_bio ( BIO * bp , EVP_PKEY * pkey ) {\n return ASN1_i2d_bio_of ( EVP_PKEY , i2d_PUBKEY , bp , pkey ) ;\n }", "idx": 2121}
{"hash": 927123821003322045, "project": "chrome", "size": 10, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( PageLoadMetricsBrowserTest , DocumentWriteSameDomain ) {\n ASSERT_TRUE ( embedded_test_server ( ) -> Start ( ) ) ;\n auto waiter = CreatePageLoadMetricsWaiter ( ) ;\n waiter -> AddPageExpectation ( TimingField : : FIRST_CONTENTFUL_PAINT ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , embedded_test_server ( ) -> GetURL ( \"/page_load_metrics/document_write_external_script.html\" ) ) ;\n waiter -> Wait ( ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHistogramFirstContentfulPaint , 1 ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHistogramDocWriteBlockParseStartToFirstContentfulPaint , 0 ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHistogramDocWriteBlockCount , 0 ) ;\n }", "idx": 2122}
{"hash": -331579171381918893, "project": "debian", "size": 12, "label": 0, "functionSource": "static SRP_gN_cache * SRP_gN_new_init ( const char * ch ) {\n unsigned char tmp [ MAX_LEN ] ;\n int len ;\n SRP_gN_cache * newgN = ( SRP_gN_cache * ) OPENSSL_malloc ( sizeof ( SRP_gN_cache ) ) ;\n if ( newgN == NULL ) return NULL ;\n if ( ( newgN -> b64_bn = BUF_strdup ( ch ) ) == NULL ) goto err ;\n len = t_fromb64 ( tmp , ch ) ;\n if ( ( newgN -> bn = BN_bin2bn ( tmp , len , NULL ) ) ) return newgN ;\n OPENSSL_free ( newgN -> b64_bn ) ;\n err : OPENSSL_free ( newgN ) ;\n return NULL ;\n }", "idx": 2123}
{"hash": 1182028467273264883, "project": "debian", "size": 24, "label": 0, "functionSource": "static int run_command ( char * cmd , DYNAMIC_STRING * ds_res ) {\n char buf [ 512 ] = {\n 0 }\n ;\n FILE * res_file ;\n int error ;\n DBUG_ENTER ( \"run_command\" ) ;\n DBUG_PRINT ( \"enter\" , ( \"cmd: %s\" , cmd ) ) ;\n if ( ! ( res_file = popen ( cmd , \"r\" ) ) ) {\n report_or_die ( \"popen(\\\"%s\\\", \\\"r\\\") failed\" , cmd ) ;\n return - 1 ;\n }\n while ( fgets ( buf , sizeof ( buf ) , res_file ) ) {\n DBUG_PRINT ( \"info\" , ( \"buf: %s\" , buf ) ) ;\n if ( ds_res ) {\n dynstr_append ( ds_res , buf ) ;\n }\n else {\n fprintf ( stdout , \"%s\" , buf ) ;\n }\n }\n error = pclose ( res_file ) ;\n DBUG_RETURN ( WEXITSTATUS ( error ) ) ;\n }", "idx": 2124}
{"hash": -331579171381918893, "project": "debian", "size": 11, "label": 0, "functionSource": "static SRP_user_pwd * SRP_user_pwd_new ( ) {\n SRP_user_pwd * ret = OPENSSL_malloc ( sizeof ( SRP_user_pwd ) ) ;\n if ( ret == NULL ) return NULL ;\n ret -> N = NULL ;\n ret -> g = NULL ;\n ret -> s = NULL ;\n ret -> v = NULL ;\n ret -> id = NULL ;\n ret -> info = NULL ;\n return ret ;\n }", "idx": 2125}
{"hash": -714975729066076397, "project": "chrome", "size": 20, "label": 0, "functionSource": "hb_blob_t * hb_blob_create ( const char * data , unsigned int length , hb_memory_mode_t mode , void * user_data , hb_destroy_func_t destroy ) {\n hb_blob_t * blob ;\n if ( ! length || length >= 1u << 31 || data + length < data || ! ( blob = hb_object_create < hb_blob_t > ( ) ) ) {\n if ( destroy ) destroy ( user_data ) ;\n return hb_blob_get_empty ( ) ;\n }\n blob -> data = data ;\n blob -> length = length ;\n blob -> mode = mode ;\n blob -> user_data = user_data ;\n blob -> destroy = destroy ;\n if ( blob -> mode == HB_MEMORY_MODE_DUPLICATE ) {\n blob -> mode = HB_MEMORY_MODE_READONLY ;\n if ( ! _try_writable ( blob ) ) {\n hb_blob_destroy ( blob ) ;\n return hb_blob_get_empty ( ) ;\n }\n }\n return blob ;\n }", "idx": 2126}
{"hash": -7777644912037188223, "project": "debian", "size": 102, "label": 0, "functionSource": "static int dissect_udvm_multitype_operand ( tvbuff_t * udvm_tvb , proto_tree * sigcomp_udvm_tree , gint offset , gboolean is_addr _U_ , gint * start_offset , guint16 * value , gboolean * is_memory_address ) {\n guint bytecode ;\n guint display_bytecode ;\n guint16 operand ;\n guint32 result ;\n guint test_bits ;\n * is_memory_address = FALSE ;\n bytecode = tvb_get_guint8 ( udvm_tvb , offset ) ;\n test_bits = ( bytecode & 0xc0 ) >> 6 ;\n switch ( test_bits ) {\n case 0 : display_bytecode = bytecode & 0xc0 ;\n if ( display_udvm_bytecode ) proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_multitype_bytecode , udvm_tvb , offset , 1 , display_bytecode ) ;\n operand = ( bytecode & 0x3f ) ;\n * value = operand ;\n * start_offset = offset ;\n offset ++ ;\n break ;\n case 1 : display_bytecode = bytecode & 0xc0 ;\n if ( display_udvm_bytecode ) proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_multitype_bytecode , udvm_tvb , offset , 1 , display_bytecode ) ;\n operand = ( bytecode & 0x3f ) * 2 ;\n * is_memory_address = TRUE ;\n * value = operand ;\n * start_offset = offset ;\n offset ++ ;\n break ;\n case 2 : test_bits = ( bytecode & 0xe0 ) >> 5 ;\n if ( test_bits == 5 ) {\n display_bytecode = bytecode & 0xe0 ;\n if ( display_udvm_bytecode ) proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_multitype_bytecode , udvm_tvb , offset , 1 , display_bytecode ) ;\n operand = tvb_get_ntohs ( udvm_tvb , offset ) & 0x1fff ;\n * value = operand ;\n * start_offset = offset ;\n offset = offset + 2 ;\n }\n else {\n test_bits = ( bytecode & 0xf0 ) >> 4 ;\n if ( test_bits == 9 ) {\n display_bytecode = bytecode & 0xf0 ;\n if ( display_udvm_bytecode ) proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_multitype_bytecode , udvm_tvb , offset , 1 , display_bytecode ) ;\n operand = ( tvb_get_ntohs ( udvm_tvb , offset ) & 0x0fff ) + 61440 ;\n * start_offset = offset ;\n * value = operand ;\n offset = offset + 2 ;\n }\n else {\n test_bits = ( bytecode & 0x08 ) >> 3 ;\n if ( test_bits == 1 ) {\n display_bytecode = bytecode & 0xf8 ;\n if ( display_udvm_bytecode ) proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_multitype_bytecode , udvm_tvb , offset , 1 , display_bytecode ) ;\n result = ( guint32 ) pow ( 2 , ( bytecode & 0x07 ) + 8 ) ;\n operand = result & 0xffff ;\n * start_offset = offset ;\n * value = operand ;\n offset ++ ;\n }\n else {\n test_bits = ( bytecode & 0x0e ) >> 1 ;\n if ( test_bits == 3 ) {\n display_bytecode = bytecode & 0xfe ;\n if ( display_udvm_bytecode ) proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_multitype_bytecode , udvm_tvb , offset , 1 , display_bytecode ) ;\n result = ( guint32 ) pow ( 2 , ( bytecode & 0x01 ) + 6 ) ;\n operand = result & 0xffff ;\n * start_offset = offset ;\n * value = operand ;\n offset ++ ;\n }\n else {\n display_bytecode = bytecode ;\n if ( display_udvm_bytecode ) proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_multitype_bytecode , udvm_tvb , offset , 1 , display_bytecode ) ;\n if ( ( bytecode & 0x01 ) == 1 ) * is_memory_address = TRUE ;\n offset ++ ;\n operand = tvb_get_ntohs ( udvm_tvb , offset ) ;\n * value = operand ;\n * start_offset = offset ;\n offset = offset + 2 ;\n }\n }\n }\n }\n break ;\n case 3 : test_bits = ( bytecode & 0x20 ) >> 5 ;\n if ( test_bits == 1 ) {\n display_bytecode = bytecode & 0xe0 ;\n if ( display_udvm_bytecode ) proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_multitype_bytecode , udvm_tvb , offset , 1 , display_bytecode ) ;\n operand = ( bytecode & 0x1f ) + 65504 ;\n * start_offset = offset ;\n * value = operand ;\n offset ++ ;\n }\n else {\n display_bytecode = bytecode & 0xe0 ;\n if ( display_udvm_bytecode ) proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_multitype_bytecode , udvm_tvb , offset , 1 , display_bytecode ) ;\n operand = ( tvb_get_ntohs ( udvm_tvb , offset ) & 0x1fff ) ;\n * is_memory_address = TRUE ;\n * start_offset = offset ;\n * value = operand ;\n offset = offset + 2 ;\n }\n default : break ;\n }\n return offset ;\n }", "idx": 2127}
{"hash": -3384986069176965684, "project": "chrome", "size": 9, "label": 0, "functionSource": "static void Pass2Encode ( VP8_COMP * cpi , unsigned long * size , unsigned char * dest , unsigned char * dest_end , unsigned int * frame_flags ) {\n if ( ! cpi -> common . refresh_alt_ref_frame ) vp8_second_pass ( cpi ) ;\n encode_frame_to_data_rate ( cpi , size , dest , dest_end , frame_flags ) ;\n cpi -> twopass . bits_left -= 8 * * size ;\n if ( ! cpi -> common . refresh_alt_ref_frame ) {\n double two_pass_min_rate = ( double ) ( cpi -> oxcf . target_bandwidth * cpi -> oxcf . two_pass_vbrmin_section / 100 ) ;\n cpi -> twopass . bits_left += ( int64_t ) ( two_pass_min_rate / cpi -> framerate ) ;\n }\n }", "idx": 2128}
{"hash": 3887066622454352196, "project": "chrome", "size": 243, "label": 1, "functionSource": "static int64_t rd_pick_best_sub8x8_mode ( VP9_COMP * cpi , MACROBLOCK * x , const TileInfo * const tile , int_mv * best_ref_mv , int_mv * second_best_ref_mv , int64_t best_rd , int * returntotrate , int * returnyrate , int64_t * returndistortion , int * skippable , int64_t * psse , int mvthresh , int_mv seg_mvs [ 4 ] [ MAX_REF_FRAMES ] , BEST_SEG_INFO * bsi_buf , int filter_idx , int mi_row , int mi_col ) {\n int i ;\n BEST_SEG_INFO * bsi = bsi_buf + filter_idx ;\n MACROBLOCKD * xd = & x -> e_mbd ;\n MODE_INFO * mi = xd -> mi [ 0 ] ;\n MB_MODE_INFO * mbmi = & mi -> mbmi ;\n int mode_idx ;\n int k , br = 0 , idx , idy ;\n int64_t bd = 0 , block_sse = 0 ;\n PREDICTION_MODE this_mode ;\n VP9_COMMON * cm = & cpi -> common ;\n struct macroblock_plane * const p = & x -> plane [ 0 ] ;\n struct macroblockd_plane * const pd = & xd -> plane [ 0 ] ;\n const int label_count = 4 ;\n int64_t this_segment_rd = 0 ;\n int label_mv_thresh ;\n int segmentyrate = 0 ;\n const BLOCK_SIZE bsize = mbmi -> sb_type ;\n const int num_4x4_blocks_wide = num_4x4_blocks_wide_lookup [ bsize ] ;\n const int num_4x4_blocks_high = num_4x4_blocks_high_lookup [ bsize ] ;\n ENTROPY_CONTEXT t_above [ 2 ] , t_left [ 2 ] ;\n int subpelmv = 1 , have_ref = 0 ;\n const int has_second_rf = has_second_ref ( mbmi ) ;\n const int inter_mode_mask = cpi -> sf . inter_mode_mask [ bsize ] ;\n vp9_zero ( * bsi ) ;\n bsi -> segment_rd = best_rd ;\n bsi -> ref_mv [ 0 ] = best_ref_mv ;\n bsi -> ref_mv [ 1 ] = second_best_ref_mv ;\n bsi -> mvp . as_int = best_ref_mv -> as_int ;\n bsi -> mvthresh = mvthresh ;\n for ( i = 0 ;\n i < 4 ;\n i ++ ) bsi -> modes [ i ] = ZEROMV ;\n vpx_memcpy ( t_above , pd -> above_context , sizeof ( t_above ) ) ;\n vpx_memcpy ( t_left , pd -> left_context , sizeof ( t_left ) ) ;\n label_mv_thresh = 1 * bsi -> mvthresh / label_count ;\n for ( idy = 0 ;\n idy < 2 ;\n idy += num_4x4_blocks_high ) {\n for ( idx = 0 ;\n idx < 2 ;\n idx += num_4x4_blocks_wide ) {\n int_mv mode_mv [ MB_MODE_COUNT ] [ 2 ] ;\n int_mv frame_mv [ MB_MODE_COUNT ] [ MAX_REF_FRAMES ] ;\n PREDICTION_MODE mode_selected = ZEROMV ;\n int64_t best_rd = INT64_MAX ;\n const int i = idy * 2 + idx ;\n int ref ;\n for ( ref = 0 ;\n ref < 1 + has_second_rf ;\n ++ ref ) {\n const MV_REFERENCE_FRAME frame = mbmi -> ref_frame [ ref ] ;\n frame_mv [ ZEROMV ] [ frame ] . as_int = 0 ;\n vp9_append_sub8x8_mvs_for_idx ( cm , xd , tile , i , ref , mi_row , mi_col , & frame_mv [ NEARESTMV ] [ frame ] , & frame_mv [ NEARMV ] [ frame ] ) ;\n }\n for ( this_mode = NEARESTMV ;\n this_mode <= NEWMV ;\n ++ this_mode ) {\n const struct buf_2d orig_src = x -> plane [ 0 ] . src ;\n struct buf_2d orig_pre [ 2 ] ;\n mode_idx = INTER_OFFSET ( this_mode ) ;\n bsi -> rdstat [ i ] [ mode_idx ] . brdcost = INT64_MAX ;\n if ( ! ( inter_mode_mask & ( 1 << this_mode ) ) ) continue ;\n if ( ! check_best_zero_mv ( cpi , mbmi -> mode_context , frame_mv , inter_mode_mask , this_mode , mbmi -> ref_frame ) ) continue ;\n vpx_memcpy ( orig_pre , pd -> pre , sizeof ( orig_pre ) ) ;\n vpx_memcpy ( bsi -> rdstat [ i ] [ mode_idx ] . ta , t_above , sizeof ( bsi -> rdstat [ i ] [ mode_idx ] . ta ) ) ;\n vpx_memcpy ( bsi -> rdstat [ i ] [ mode_idx ] . tl , t_left , sizeof ( bsi -> rdstat [ i ] [ mode_idx ] . tl ) ) ;\n if ( ! has_second_rf && this_mode == NEWMV && seg_mvs [ i ] [ mbmi -> ref_frame [ 0 ] ] . as_int == INVALID_MV ) {\n MV * const new_mv = & mode_mv [ NEWMV ] [ 0 ] . as_mv ;\n int step_param = 0 ;\n int thissme , bestsme = INT_MAX ;\n int sadpb = x -> sadperbit4 ;\n MV mvp_full ;\n int max_mv ;\n int sad_list [ 5 ] ;\n if ( best_rd < label_mv_thresh ) break ;\n if ( cpi -> oxcf . mode != BEST ) {\n if ( i > 0 ) {\n bsi -> mvp . as_int = mi -> bmi [ i - 1 ] . as_mv [ 0 ] . as_int ;\n if ( i == 2 ) bsi -> mvp . as_int = mi -> bmi [ i - 2 ] . as_mv [ 0 ] . as_int ;\n }\n }\n if ( i == 0 ) max_mv = x -> max_mv_context [ mbmi -> ref_frame [ 0 ] ] ;\n else max_mv = MAX ( abs ( bsi -> mvp . as_mv . row ) , abs ( bsi -> mvp . as_mv . col ) ) >> 3 ;\n if ( cpi -> sf . mv . auto_mv_step_size && cm -> show_frame ) {\n step_param = ( vp9_init_search_range ( max_mv ) + cpi -> mv_step_param ) / 2 ;\n }\n else {\n step_param = cpi -> mv_step_param ;\n }\n mvp_full . row = bsi -> mvp . as_mv . row >> 3 ;\n mvp_full . col = bsi -> mvp . as_mv . col >> 3 ;\n if ( cpi -> sf . adaptive_motion_search ) {\n mvp_full . row = x -> pred_mv [ mbmi -> ref_frame [ 0 ] ] . row >> 3 ;\n mvp_full . col = x -> pred_mv [ mbmi -> ref_frame [ 0 ] ] . col >> 3 ;\n step_param = MAX ( step_param , 8 ) ;\n }\n mi_buf_shift ( x , i ) ;\n vp9_set_mv_search_range ( x , & bsi -> ref_mv [ 0 ] -> as_mv ) ;\n bestsme = vp9_full_pixel_search ( cpi , x , bsize , & mvp_full , step_param , sadpb , cpi -> sf . mv . subpel_search_method != SUBPEL_TREE ? sad_list : NULL , & bsi -> ref_mv [ 0 ] -> as_mv , new_mv , INT_MAX , 1 ) ;\n if ( cpi -> oxcf . mode == BEST ) {\n int_mv * const best_mv = & mi -> bmi [ i ] . as_mv [ 0 ] ;\n clamp_mv ( & mvp_full , x -> mv_col_min , x -> mv_col_max , x -> mv_row_min , x -> mv_row_max ) ;\n thissme = cpi -> full_search_sad ( x , & mvp_full , sadpb , 16 , & cpi -> fn_ptr [ bsize ] , & bsi -> ref_mv [ 0 ] -> as_mv , & best_mv -> as_mv ) ;\n sad_list [ 1 ] = sad_list [ 2 ] = sad_list [ 3 ] = sad_list [ 4 ] = INT_MAX ;\n if ( thissme < bestsme ) {\n bestsme = thissme ;\n * new_mv = best_mv -> as_mv ;\n }\n else {\n best_mv -> as_mv = * new_mv ;\n }\n }\n if ( bestsme < INT_MAX ) {\n int distortion ;\n cpi -> find_fractional_mv_step ( x , new_mv , & bsi -> ref_mv [ 0 ] -> as_mv , cm -> allow_high_precision_mv , x -> errorperbit , & cpi -> fn_ptr [ bsize ] , cpi -> sf . mv . subpel_force_stop , cpi -> sf . mv . subpel_iters_per_step , cond_sad_list ( cpi , sad_list ) , x -> nmvjointcost , x -> mvcost , & distortion , & x -> pred_sse [ mbmi -> ref_frame [ 0 ] ] , NULL , 0 , 0 ) ;\n seg_mvs [ i ] [ mbmi -> ref_frame [ 0 ] ] . as_mv = * new_mv ;\n }\n if ( cpi -> sf . adaptive_motion_search ) x -> pred_mv [ mbmi -> ref_frame [ 0 ] ] = * new_mv ;\n mi_buf_restore ( x , orig_src , orig_pre ) ;\n }\n if ( has_second_rf ) {\n if ( seg_mvs [ i ] [ mbmi -> ref_frame [ 1 ] ] . as_int == INVALID_MV || seg_mvs [ i ] [ mbmi -> ref_frame [ 0 ] ] . as_int == INVALID_MV ) continue ;\n }\n if ( has_second_rf && this_mode == NEWMV && mbmi -> interp_filter == EIGHTTAP ) {\n mi_buf_shift ( x , i ) ;\n if ( cpi -> sf . comp_inter_joint_search_thresh <= bsize ) {\n int rate_mv ;\n joint_motion_search ( cpi , x , bsize , frame_mv [ this_mode ] , mi_row , mi_col , seg_mvs [ i ] , & rate_mv ) ;\n seg_mvs [ i ] [ mbmi -> ref_frame [ 0 ] ] . as_int = frame_mv [ this_mode ] [ mbmi -> ref_frame [ 0 ] ] . as_int ;\n seg_mvs [ i ] [ mbmi -> ref_frame [ 1 ] ] . as_int = frame_mv [ this_mode ] [ mbmi -> ref_frame [ 1 ] ] . as_int ;\n }\n mi_buf_restore ( x , orig_src , orig_pre ) ;\n }\n bsi -> rdstat [ i ] [ mode_idx ] . brate = set_and_cost_bmi_mvs ( cpi , xd , i , this_mode , mode_mv [ this_mode ] , frame_mv , seg_mvs [ i ] , bsi -> ref_mv , x -> nmvjointcost , x -> mvcost ) ;\n for ( ref = 0 ;\n ref < 1 + has_second_rf ;\n ++ ref ) {\n bsi -> rdstat [ i ] [ mode_idx ] . mvs [ ref ] . as_int = mode_mv [ this_mode ] [ ref ] . as_int ;\n if ( num_4x4_blocks_wide > 1 ) bsi -> rdstat [ i + 1 ] [ mode_idx ] . mvs [ ref ] . as_int = mode_mv [ this_mode ] [ ref ] . as_int ;\n if ( num_4x4_blocks_high > 1 ) bsi -> rdstat [ i + 2 ] [ mode_idx ] . mvs [ ref ] . as_int = mode_mv [ this_mode ] [ ref ] . as_int ;\n }\n if ( mv_check_bounds ( x , & mode_mv [ this_mode ] [ 0 ] . as_mv ) || ( has_second_rf && mv_check_bounds ( x , & mode_mv [ this_mode ] [ 1 ] . as_mv ) ) ) continue ;\n if ( filter_idx > 0 ) {\n BEST_SEG_INFO * ref_bsi = bsi_buf ;\n subpelmv = 0 ;\n have_ref = 1 ;\n for ( ref = 0 ;\n ref < 1 + has_second_rf ;\n ++ ref ) {\n subpelmv |= mv_has_subpel ( & mode_mv [ this_mode ] [ ref ] . as_mv ) ;\n have_ref &= mode_mv [ this_mode ] [ ref ] . as_int == ref_bsi -> rdstat [ i ] [ mode_idx ] . mvs [ ref ] . as_int ;\n }\n if ( filter_idx > 1 && ! subpelmv && ! have_ref ) {\n ref_bsi = bsi_buf + 1 ;\n have_ref = 1 ;\n for ( ref = 0 ;\n ref < 1 + has_second_rf ;\n ++ ref ) have_ref &= mode_mv [ this_mode ] [ ref ] . as_int == ref_bsi -> rdstat [ i ] [ mode_idx ] . mvs [ ref ] . as_int ;\n }\n if ( ! subpelmv && have_ref && ref_bsi -> rdstat [ i ] [ mode_idx ] . brdcost < INT64_MAX ) {\n vpx_memcpy ( & bsi -> rdstat [ i ] [ mode_idx ] , & ref_bsi -> rdstat [ i ] [ mode_idx ] , sizeof ( SEG_RDSTAT ) ) ;\n if ( num_4x4_blocks_wide > 1 ) bsi -> rdstat [ i + 1 ] [ mode_idx ] . eobs = ref_bsi -> rdstat [ i + 1 ] [ mode_idx ] . eobs ;\n if ( num_4x4_blocks_high > 1 ) bsi -> rdstat [ i + 2 ] [ mode_idx ] . eobs = ref_bsi -> rdstat [ i + 2 ] [ mode_idx ] . eobs ;\n if ( bsi -> rdstat [ i ] [ mode_idx ] . brdcost < best_rd ) {\n mode_selected = this_mode ;\n best_rd = bsi -> rdstat [ i ] [ mode_idx ] . brdcost ;\n }\n continue ;\n }\n }\n bsi -> rdstat [ i ] [ mode_idx ] . brdcost = encode_inter_mb_segment ( cpi , x , bsi -> segment_rd - this_segment_rd , i , & bsi -> rdstat [ i ] [ mode_idx ] . byrate , & bsi -> rdstat [ i ] [ mode_idx ] . bdist , & bsi -> rdstat [ i ] [ mode_idx ] . bsse , bsi -> rdstat [ i ] [ mode_idx ] . ta , bsi -> rdstat [ i ] [ mode_idx ] . tl , mi_row , mi_col ) ;\n if ( bsi -> rdstat [ i ] [ mode_idx ] . brdcost < INT64_MAX ) {\n bsi -> rdstat [ i ] [ mode_idx ] . brdcost += RDCOST ( x -> rdmult , x -> rddiv , bsi -> rdstat [ i ] [ mode_idx ] . brate , 0 ) ;\n bsi -> rdstat [ i ] [ mode_idx ] . brate += bsi -> rdstat [ i ] [ mode_idx ] . byrate ;\n bsi -> rdstat [ i ] [ mode_idx ] . eobs = p -> eobs [ i ] ;\n if ( num_4x4_blocks_wide > 1 ) bsi -> rdstat [ i + 1 ] [ mode_idx ] . eobs = p -> eobs [ i + 1 ] ;\n if ( num_4x4_blocks_high > 1 ) bsi -> rdstat [ i + 2 ] [ mode_idx ] . eobs = p -> eobs [ i + 2 ] ;\n }\n if ( bsi -> rdstat [ i ] [ mode_idx ] . brdcost < best_rd ) {\n mode_selected = this_mode ;\n best_rd = bsi -> rdstat [ i ] [ mode_idx ] . brdcost ;\n }\n }\n if ( best_rd == INT64_MAX ) {\n int iy , midx ;\n for ( iy = i + 1 ;\n iy < 4 ;\n ++ iy ) for ( midx = 0 ;\n midx < INTER_MODES ;\n ++ midx ) bsi -> rdstat [ iy ] [ midx ] . brdcost = INT64_MAX ;\n bsi -> segment_rd = INT64_MAX ;\n return INT64_MAX ;\n ;\n }\n mode_idx = INTER_OFFSET ( mode_selected ) ;\n vpx_memcpy ( t_above , bsi -> rdstat [ i ] [ mode_idx ] . ta , sizeof ( t_above ) ) ;\n vpx_memcpy ( t_left , bsi -> rdstat [ i ] [ mode_idx ] . tl , sizeof ( t_left ) ) ;\n set_and_cost_bmi_mvs ( cpi , xd , i , mode_selected , mode_mv [ mode_selected ] , frame_mv , seg_mvs [ i ] , bsi -> ref_mv , x -> nmvjointcost , x -> mvcost ) ;\n br += bsi -> rdstat [ i ] [ mode_idx ] . brate ;\n bd += bsi -> rdstat [ i ] [ mode_idx ] . bdist ;\n block_sse += bsi -> rdstat [ i ] [ mode_idx ] . bsse ;\n segmentyrate += bsi -> rdstat [ i ] [ mode_idx ] . byrate ;\n this_segment_rd += bsi -> rdstat [ i ] [ mode_idx ] . brdcost ;\n if ( this_segment_rd > bsi -> segment_rd ) {\n int iy , midx ;\n for ( iy = i + 1 ;\n iy < 4 ;\n ++ iy ) for ( midx = 0 ;\n midx < INTER_MODES ;\n ++ midx ) bsi -> rdstat [ iy ] [ midx ] . brdcost = INT64_MAX ;\n bsi -> segment_rd = INT64_MAX ;\n return INT64_MAX ;\n ;\n }\n }\n }\n bsi -> r = br ;\n bsi -> d = bd ;\n bsi -> segment_yrate = segmentyrate ;\n bsi -> segment_rd = this_segment_rd ;\n bsi -> sse = block_sse ;\n for ( k = 0 ;\n k < 4 ;\n ++ k ) bsi -> modes [ k ] = mi -> bmi [ k ] . as_mode ;\n if ( bsi -> segment_rd > best_rd ) return INT64_MAX ;\n for ( i = 0 ;\n i < 4 ;\n i ++ ) {\n mode_idx = INTER_OFFSET ( bsi -> modes [ i ] ) ;\n mi -> bmi [ i ] . as_mv [ 0 ] . as_int = bsi -> rdstat [ i ] [ mode_idx ] . mvs [ 0 ] . as_int ;\n if ( has_second_ref ( mbmi ) ) mi -> bmi [ i ] . as_mv [ 1 ] . as_int = bsi -> rdstat [ i ] [ mode_idx ] . mvs [ 1 ] . as_int ;\n x -> plane [ 0 ] . eobs [ i ] = bsi -> rdstat [ i ] [ mode_idx ] . eobs ;\n mi -> bmi [ i ] . as_mode = bsi -> modes [ i ] ;\n }\n * returntotrate = bsi -> r ;\n * returndistortion = bsi -> d ;\n * returnyrate = bsi -> segment_yrate ;\n * skippable = vp9_is_skippable_in_plane ( x , BLOCK_8X8 , 0 ) ;\n * psse = bsi -> sse ;\n mbmi -> mode = bsi -> modes [ 3 ] ;\n return bsi -> segment_rd ;\n }", "idx": 2129}
{"hash": 7651945086108393719, "project": "debian", "size": 17, "label": 0, "functionSource": "static void qemuMonitorJSONHandleWatchdog ( qemuMonitorPtr mon , virJSONValuePtr data ) {\n const char * action ;\n int actionID ;\n if ( ! ( action = virJSONValueObjectGetString ( data , \"action\" ) ) ) {\n VIR_WARN ( \"missing action in watchdog event\" ) ;\n }\n if ( action ) {\n if ( ( actionID = qemuMonitorWatchdogActionTypeFromString ( action ) ) < 0 ) {\n VIR_WARN ( \"unknown action %s in watchdog event\" , action ) ;\n actionID = VIR_DOMAIN_EVENT_WATCHDOG_NONE ;\n }\n }\n else {\n actionID = VIR_DOMAIN_EVENT_WATCHDOG_NONE ;\n }\n qemuMonitorEmitWatchdog ( mon , actionID ) ;\n }", "idx": 2130}
{"hash": 6667142528452941476, "project": "debian", "size": 6, "label": 0, "functionSource": "static my_bool test_if_special_chars ( const char * str ) {\n # if MYSQL_VERSION_ID >= 32300 for ( ;\n * str ;\n str ++ ) if ( ! my_isvar ( charset_info , * str ) && * str != '$' ) return 1 ;\n # endif return 0 ;\n }", "idx": 2131}
{"hash": -6468986929796051453, "project": "debian", "size": 7, "label": 0, "functionSource": "void TIFFCvtNativeToIEEEDouble ( TIFF * tif , u_int n , double * f ) {\n double_t * fp = ( double_t * ) f ;\n while ( n -- > 0 ) {\n NATIVE2IEEEDOUBLE ( fp ) ;\n fp ++ ;\n }\n }", "idx": 2132}
{"hash": 2895622461494525400, "project": "debian", "size": 52, "label": 0, "functionSource": "static void test_mem_overun ( ) {\n char buffer [ 10000 ] , field [ 10 ] ;\n MYSQL_STMT * stmt ;\n MYSQL_RES * field_res ;\n int rc , i , length ;\n myheader ( \"test_mem_overun\" ) ;\n rc = mysql_query ( mysql , \"drop table if exists t_mem_overun\" ) ;\n myquery ( rc ) ;\n strxmov ( buffer , \"create table t_mem_overun(\" , NullS ) ;\n for ( i = 0 ;\n i < 1000 ;\n i ++ ) {\n sprintf ( field , \"c%d int\" , i ) ;\n strxmov ( buffer , buffer , field , \", \" , NullS ) ;\n }\n length = strlen ( buffer ) ;\n buffer [ length - 2 ] = ')' ;\n buffer [ -- length ] = '\\0' ;\n rc = mysql_real_query ( mysql , buffer , length ) ;\n myquery ( rc ) ;\n strxmov ( buffer , \"insert into t_mem_overun values(\" , NullS ) ;\n for ( i = 0 ;\n i < 1000 ;\n i ++ ) {\n strxmov ( buffer , buffer , \"1, \" , NullS ) ;\n }\n length = strlen ( buffer ) ;\n buffer [ length - 2 ] = ')' ;\n buffer [ -- length ] = '\\0' ;\n rc = mysql_real_query ( mysql , buffer , length ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"select * from t_mem_overun\" ) ;\n myquery ( rc ) ;\n rc = my_process_result ( mysql ) ;\n DIE_UNLESS ( rc == 1 ) ;\n stmt = mysql_simple_prepare ( mysql , \"select * from t_mem_overun\" ) ;\n check_stmt ( stmt ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n field_res = mysql_stmt_result_metadata ( stmt ) ;\n mytest ( field_res ) ;\n if ( ! opt_silent ) fprintf ( stdout , \"\\n total fields : %d\" , mysql_num_fields ( field_res ) ) ;\n DIE_UNLESS ( 1000 == mysql_num_fields ( field_res ) ) ;\n rc = mysql_stmt_store_result ( stmt ) ;\n check_execute ( stmt , rc ) ;\n rc = mysql_stmt_fetch ( stmt ) ;\n check_execute ( stmt , rc ) ;\n rc = mysql_stmt_fetch ( stmt ) ;\n DIE_UNLESS ( rc == MYSQL_NO_DATA ) ;\n mysql_free_result ( field_res ) ;\n mysql_stmt_close ( stmt ) ;\n }", "idx": 2133}
{"hash": -8704283573519790151, "project": "debian", "size": 32, "label": 0, "functionSource": "int ber_realloc ( BerElement * ber , ber_len_t len ) {\n ber_len_t total , offset , sos_offset ;\n char * buf ;\n assert ( ber != NULL ) ;\n assert ( LBER_VALID ( ber ) ) ;\n if ( ++ len == 0 ) {\n return ( - 1 ) ;\n }\n total = ber_pvt_ber_total ( ber ) ;\n # define LBER_EXBUFSIZ 4060 # if defined ( LBER_EXBUFSIZ ) && LBER_EXBUFSIZ > 0 # ifndef notdef total += len < LBER_EXBUFSIZ ? LBER_EXBUFSIZ : len ;\n # else {\n ber_len_t have = ( total + ( LBER_EXBUFSIZE - 1 ) ) / LBER_EXBUFSIZ ;\n ber_len_t need = ( len + ( LBER_EXBUFSIZ - 1 ) ) / LBER_EXBUFSIZ ;\n total = ( have + need ) * LBER_EXBUFSIZ ;\n }\n # endif # else total += len ;\n # endif if ( total < len || total > ( ber_len_t ) - 1 / 2 ) {\n return ( - 1 ) ;\n }\n buf = ber -> ber_buf ;\n offset = ber -> ber_ptr - buf ;\n sos_offset = ber -> ber_sos_ptr ? ber -> ber_sos_ptr - buf : 0 ;\n buf = ( char * ) ber_memrealloc_x ( buf , total , ber -> ber_memctx ) ;\n if ( buf == NULL ) {\n return ( - 1 ) ;\n }\n ber -> ber_buf = buf ;\n ber -> ber_end = buf + total ;\n ber -> ber_ptr = buf + offset ;\n if ( sos_offset ) ber -> ber_sos_ptr = buf + sos_offset ;\n return ( 0 ) ;\n }", "idx": 2134}
{"hash": -1929262071302712016, "project": "debian", "size": 5, "label": 0, "functionSource": "static void Type_ProfileSequenceDesc_Free ( struct _cms_typehandler_struct * self , void * Ptr ) {\n cmsFreeProfileSequenceDescription ( ( cmsSEQ * ) Ptr ) ;\n return ;\n cmsUNUSED_PARAMETER ( self ) ;\n }", "idx": 2135}
{"hash": -7253276028511611170, "project": "debian", "size": 25, "label": 0, "functionSource": "static void encode_color_spec ( VC2EncContext * s ) {\n AVCodecContext * avctx = s -> avctx ;\n put_bits ( & s -> pb , 1 , ! s -> strict_compliance ) ;\n if ( ! s -> strict_compliance ) {\n int val ;\n put_vc2_ue_uint ( & s -> pb , 0 ) ;\n put_bits ( & s -> pb , 1 , 1 ) ;\n if ( avctx -> color_primaries == AVCOL_PRI_BT470BG ) val = 2 ;\n else if ( avctx -> color_primaries == AVCOL_PRI_SMPTE170M ) val = 1 ;\n else if ( avctx -> color_primaries == AVCOL_PRI_SMPTE240M ) val = 1 ;\n else val = 0 ;\n put_vc2_ue_uint ( & s -> pb , val ) ;\n put_bits ( & s -> pb , 1 , 1 ) ;\n if ( avctx -> colorspace == AVCOL_SPC_RGB ) val = 3 ;\n else if ( avctx -> colorspace == AVCOL_SPC_YCOCG ) val = 2 ;\n else if ( avctx -> colorspace == AVCOL_SPC_BT470BG ) val = 1 ;\n else val = 0 ;\n put_vc2_ue_uint ( & s -> pb , val ) ;\n put_bits ( & s -> pb , 1 , 1 ) ;\n if ( avctx -> color_trc == AVCOL_TRC_LINEAR ) val = 2 ;\n else if ( avctx -> color_trc == AVCOL_TRC_BT1361_ECG ) val = 1 ;\n else val = 0 ;\n put_vc2_ue_uint ( & s -> pb , val ) ;\n }\n }", "idx": 2136}
{"hash": 2335222688263906532, "project": "debian", "size": 54, "label": 0, "functionSource": "static int rv34_decode_slice ( RV34DecContext * r , int end , const uint8_t * buf , int buf_size ) {\n MpegEncContext * s = & r -> s ;\n GetBitContext * gb = & s -> gb ;\n int mb_pos , slice_type ;\n int res ;\n init_get_bits ( & r -> s . gb , buf , buf_size * 8 ) ;\n res = r -> parse_slice_header ( r , gb , & r -> si ) ;\n if ( res < 0 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"Incorrect or unknown slice header\\n\" ) ;\n return - 1 ;\n }\n slice_type = r -> si . type ? r -> si . type : AV_PICTURE_TYPE_I ;\n if ( slice_type != s -> pict_type ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"Slice type mismatch\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n r -> si . end = end ;\n s -> qscale = r -> si . quant ;\n s -> mb_num_left = r -> si . end - r -> si . start ;\n r -> s . mb_skip_run = 0 ;\n mb_pos = s -> mb_x + s -> mb_y * s -> mb_width ;\n if ( r -> si . start != mb_pos ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"Slice indicates MB offset %d, got %d\\n\" , r -> si . start , mb_pos ) ;\n s -> mb_x = r -> si . start % s -> mb_width ;\n s -> mb_y = r -> si . start / s -> mb_width ;\n }\n memset ( r -> intra_types_hist , - 1 , r -> intra_types_stride * 4 * 2 * sizeof ( * r -> intra_types_hist ) ) ;\n s -> first_slice_line = 1 ;\n s -> resync_mb_x = s -> mb_x ;\n s -> resync_mb_y = s -> mb_y ;\n ff_init_block_index ( s ) ;\n while ( ! check_slice_end ( r , s ) ) {\n ff_update_block_index ( s ) ;\n if ( r -> si . type ) res = rv34_decode_inter_macroblock ( r , r -> intra_types + s -> mb_x * 4 + 4 ) ;\n else res = rv34_decode_intra_macroblock ( r , r -> intra_types + s -> mb_x * 4 + 4 ) ;\n if ( res < 0 ) {\n ff_er_add_slice ( & s -> er , s -> resync_mb_x , s -> resync_mb_y , s -> mb_x - 1 , s -> mb_y , ER_MB_ERROR ) ;\n return - 1 ;\n }\n if ( ++ s -> mb_x == s -> mb_width ) {\n s -> mb_x = 0 ;\n s -> mb_y ++ ;\n ff_init_block_index ( s ) ;\n memmove ( r -> intra_types_hist , r -> intra_types , r -> intra_types_stride * 4 * sizeof ( * r -> intra_types_hist ) ) ;\n memset ( r -> intra_types , - 1 , r -> intra_types_stride * 4 * sizeof ( * r -> intra_types_hist ) ) ;\n if ( r -> loop_filter && s -> mb_y >= 2 ) r -> loop_filter ( r , s -> mb_y - 2 ) ;\n if ( HAVE_THREADS && ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) ff_thread_report_progress ( & s -> current_picture_ptr -> tf , s -> mb_y - 2 , 0 ) ;\n }\n if ( s -> mb_x == s -> resync_mb_x ) s -> first_slice_line = 0 ;\n s -> mb_num_left -- ;\n }\n ff_er_add_slice ( & s -> er , s -> resync_mb_x , s -> resync_mb_y , s -> mb_x - 1 , s -> mb_y , ER_MB_END ) ;\n return s -> mb_y == s -> mb_height ;\n }", "idx": 2137}
{"hash": 1760449185745615462, "project": "debian", "size": 17, "label": 0, "functionSource": "TSReturnCode TSUrlCopy ( TSMBuffer dest_bufp , TSMLoc dest_obj , TSMBuffer src_bufp , TSMLoc src_obj ) {\n sdk_assert ( sdk_sanity_check_mbuffer ( src_bufp ) == TS_SUCCESS ) ;\n sdk_assert ( sdk_sanity_check_mbuffer ( dest_bufp ) == TS_SUCCESS ) ;\n sdk_assert ( sdk_sanity_check_url_handle ( src_obj ) == TS_SUCCESS ) ;\n sdk_assert ( sdk_sanity_check_url_handle ( dest_obj ) == TS_SUCCESS ) ;\n if ( ! isWriteable ( dest_bufp ) ) {\n return TS_ERROR ;\n }\n HdrHeap * s_heap , * d_heap ;\n URLImpl * s_url , * d_url ;\n s_heap = ( ( HdrHeapSDKHandle * ) src_bufp ) -> m_heap ;\n d_heap = ( ( HdrHeapSDKHandle * ) dest_bufp ) -> m_heap ;\n s_url = ( URLImpl * ) src_obj ;\n d_url = ( URLImpl * ) dest_obj ;\n url_copy_onto ( s_url , s_heap , d_url , d_heap , ( s_heap != d_heap ) ) ;\n return TS_SUCCESS ;\n }", "idx": 2138}
{"hash": 1223258652239369123, "project": "debian", "size": 77, "label": 0, "functionSource": "static spl_filesystem_object * spl_filesystem_object_create_type ( int ht , spl_filesystem_object * source , int type , zend_class_entry * ce , zval * return_value TSRMLS_DC ) {\n spl_filesystem_object * intern ;\n zend_bool use_include_path = 0 ;\n zval * arg1 , * arg2 ;\n zend_error_handling error_handling ;\n zend_replace_error_handling ( EH_THROW , spl_ce_RuntimeException , & error_handling TSRMLS_CC ) ;\n switch ( source -> type ) {\n case SPL_FS_INFO : case SPL_FS_FILE : break ;\n case SPL_FS_DIR : if ( ! source -> u . dir . entry . d_name [ 0 ] ) {\n zend_throw_exception_ex ( spl_ce_RuntimeException , 0 TSRMLS_CC , \"Could not open file\" ) ;\n zend_restore_error_handling ( & error_handling TSRMLS_CC ) ;\n return NULL ;\n }\n }\n switch ( type ) {\n case SPL_FS_INFO : ce = ce ? ce : source -> info_class ;\n zend_update_class_constants ( ce TSRMLS_CC ) ;\n return_value -> value . obj = spl_filesystem_object_new_ex ( ce , & intern TSRMLS_CC ) ;\n Z_TYPE_P ( return_value ) = IS_OBJECT ;\n spl_filesystem_object_get_file_name ( source TSRMLS_CC ) ;\n if ( ce -> constructor -> common . scope != spl_ce_SplFileInfo ) {\n MAKE_STD_ZVAL ( arg1 ) ;\n ZVAL_STRINGL ( arg1 , source -> file_name , source -> file_name_len , 1 ) ;\n zend_call_method_with_1_params ( & return_value , ce , & ce -> constructor , \"__construct\" , NULL , arg1 ) ;\n zval_ptr_dtor ( & arg1 ) ;\n }\n else {\n intern -> file_name = estrndup ( source -> file_name , source -> file_name_len ) ;\n intern -> file_name_len = source -> file_name_len ;\n intern -> _path = spl_filesystem_object_get_path ( source , & intern -> _path_len TSRMLS_CC ) ;\n intern -> _path = estrndup ( intern -> _path , intern -> _path_len ) ;\n }\n break ;\n case SPL_FS_FILE : ce = ce ? ce : source -> file_class ;\n zend_update_class_constants ( ce TSRMLS_CC ) ;\n return_value -> value . obj = spl_filesystem_object_new_ex ( ce , & intern TSRMLS_CC ) ;\n Z_TYPE_P ( return_value ) = IS_OBJECT ;\n spl_filesystem_object_get_file_name ( source TSRMLS_CC ) ;\n if ( ce -> constructor -> common . scope != spl_ce_SplFileObject ) {\n MAKE_STD_ZVAL ( arg1 ) ;\n MAKE_STD_ZVAL ( arg2 ) ;\n ZVAL_STRINGL ( arg1 , source -> file_name , source -> file_name_len , 1 ) ;\n ZVAL_STRINGL ( arg2 , \"r\" , 1 , 1 ) ;\n zend_call_method_with_2_params ( & return_value , ce , & ce -> constructor , \"__construct\" , NULL , arg1 , arg2 ) ;\n zval_ptr_dtor ( & arg1 ) ;\n zval_ptr_dtor ( & arg2 ) ;\n }\n else {\n intern -> file_name = source -> file_name ;\n intern -> file_name_len = source -> file_name_len ;\n intern -> _path = spl_filesystem_object_get_path ( source , & intern -> _path_len TSRMLS_CC ) ;\n intern -> _path = estrndup ( intern -> _path , intern -> _path_len ) ;\n intern -> u . file . open_mode = \"r\" ;\n intern -> u . file . open_mode_len = 1 ;\n if ( ht && zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , \"|sbr\" , & intern -> u . file . open_mode , & intern -> u . file . open_mode_len , & use_include_path , & intern -> u . file . zcontext ) == FAILURE ) {\n zend_restore_error_handling ( & error_handling TSRMLS_CC ) ;\n intern -> u . file . open_mode = NULL ;\n intern -> file_name = NULL ;\n zval_dtor ( return_value ) ;\n Z_TYPE_P ( return_value ) = IS_NULL ;\n return NULL ;\n }\n if ( spl_filesystem_file_open ( intern , use_include_path , 0 TSRMLS_CC ) == FAILURE ) {\n zend_restore_error_handling ( & error_handling TSRMLS_CC ) ;\n zval_dtor ( return_value ) ;\n Z_TYPE_P ( return_value ) = IS_NULL ;\n return NULL ;\n }\n }\n break ;\n case SPL_FS_DIR : zend_restore_error_handling ( & error_handling TSRMLS_CC ) ;\n zend_throw_exception_ex ( spl_ce_RuntimeException , 0 TSRMLS_CC , \"Operation not supported\" ) ;\n return NULL ;\n }\n zend_restore_error_handling ( & error_handling TSRMLS_CC ) ;\n return NULL ;\n }", "idx": 2139}
{"hash": 7886275645410984140, "project": "debian", "size": 10, "label": 0, "functionSource": "int test ( char * URL ) {\n int i ;\n ( void ) URL ;\n for ( i = 0 ;\n dates [ i ] ;\n i ++ ) {\n printf ( \"%d: %s => %ld\\n\" , i , dates [ i ] , ( long ) curl_getdate ( dates [ i ] , NULL ) ) ;\n }\n return 0 ;\n }", "idx": 2140}
{"hash": -2928324134072492299, "project": "debian", "size": 12, "label": 0, "functionSource": "void sdp_calls_init_tap ( void ) {\n GString * error_string ;\n if ( have_sdp_tap_listener == FALSE ) {\n error_string = register_tap_listener ( \"sdp\" , & ( the_tapinfo_struct . sdp_dummy ) , NULL , 0 , voip_calls_dlg_reset , SDPcalls_packet , voip_calls_dlg_draw ) ;\n if ( error_string != NULL ) {\n simple_dialog ( ESD_TYPE_ERROR , ESD_BTN_OK , \"%s\" , error_string -> str ) ;\n g_string_free ( error_string , TRUE ) ;\n exit ( 1 ) ;\n }\n have_sdp_tap_listener = TRUE ;\n }\n }", "idx": 2141}
{"hash": 7319734001219685758, "project": "debian", "size": 4, "label": 0, "functionSource": "static inline int mpc8_get_mod_golomb ( GetBitContext * gb , int m ) {\n if ( mpc8_cnk_len [ 0 ] [ m ] < 1 ) return 0 ;\n return mpc8_dec_base ( gb , 1 , m + 1 ) ;\n }", "idx": 2142}
{"hash": 7191899184788440065, "project": "debian", "size": 41, "label": 0, "functionSource": "static int com_source ( String * buffer __attribute__ ( ( unused ) ) , char * line ) {\n char source_name [ FN_REFLEN ] , * end , * param ;\n LINE_BUFFER * line_buff ;\n int error ;\n STATUS old_status ;\n FILE * sql_file ;\n my_bool save_ignore_errors ;\n while ( my_isspace ( charset_info , * line ) ) line ++ ;\n if ( ! ( param = strchr ( line , ' ' ) ) ) return put_info ( \"Usage: \\\\. <filename> | source <filename>\" , INFO_ERROR , 0 ) ;\n while ( my_isspace ( charset_info , * param ) ) param ++ ;\n end = strmake_buf ( source_name , param ) ;\n while ( end > source_name && ( my_isspace ( charset_info , end [ - 1 ] ) || my_iscntrl ( charset_info , end [ - 1 ] ) ) ) end -- ;\n end [ 0 ] = 0 ;\n unpack_filename ( source_name , source_name ) ;\n if ( ! ( sql_file = my_fopen ( source_name , O_RDONLY | O_BINARY , MYF ( 0 ) ) ) ) {\n char buff [ FN_REFLEN + 60 ] ;\n sprintf ( buff , \"Failed to open file '%s', error: %d\" , source_name , errno ) ;\n return put_info ( buff , INFO_ERROR , 0 ) ;\n }\n if ( ! ( line_buff = batch_readline_init ( MAX_BATCH_BUFFER_SIZE , sql_file ) ) ) {\n my_fclose ( sql_file , MYF ( 0 ) ) ;\n return put_info ( \"Can't initialize batch_readline\" , INFO_ERROR , 0 ) ;\n }\n old_status = status ;\n save_ignore_errors = ignore_errors ;\n bfill ( ( char * ) & status , sizeof ( status ) , ( char ) 0 ) ;\n status . batch = old_status . batch ;\n status . line_buff = line_buff ;\n status . file_name = source_name ;\n glob_buffer . length ( 0 ) ;\n ignore_errors = ! batch_abort_on_error ;\n in_com_source = 1 ;\n error = read_and_execute ( false ) ;\n ignore_errors = save_ignore_errors ;\n status = old_status ;\n in_com_source = aborted = 0 ;\n my_fclose ( sql_file , MYF ( 0 ) ) ;\n batch_readline_end ( line_buff ) ;\n if ( error && ignore_errors ) error = - 1 ;\n return error ;\n }", "idx": 2143}
{"hash": 6323824267898511453, "project": "debian", "size": 15, "label": 0, "functionSource": "static void icc_base_conv_color ( fz_context * ctx , fz_color_converter * cc , float * dstv , const float * srcv ) {\n const fz_colorspace * srcs = cc -> ss ;\n float local_src_map [ FZ_MAX_COLORS ] ;\n float local_src_map2 [ FZ_MAX_COLORS ] ;\n float * src_map = local_src_map ;\n do {\n srcs -> to_ccs ( ctx , srcs , srcv , src_map ) ;\n srcs = srcs -> get_base ( srcs ) ;\n srcs -> clamp ( srcs , src_map , src_map ) ;\n srcv = src_map ;\n src_map = ( src_map == local_src_map ? local_src_map2 : local_src_map ) ;\n }\n while ( ! fz_colorspace_is_icc ( ctx , srcs ) && ! fz_colorspace_is_cal ( ctx , srcs ) ) ;\n icc_conv_color ( ctx , cc , dstv , srcv ) ;\n }", "idx": 2144}
{"hash": 7092216800726729686, "project": "debian", "size": 7, "label": 0, "functionSource": "static int dissect_h245_MultiplexEntryDescriptor ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 53 \"../../asn1/h245/h245.cnf\" h223_me = NULL ;\n h223_mc = 0 ;\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_MultiplexEntryDescriptor , MultiplexEntryDescriptor_sequence ) ;\n if ( h223_set_mc_handle ) ( * h223_set_mc_handle ) ( actx -> pinfo , h223_mc , h223_me ) ;\n return offset ;\n }", "idx": 2145}
{"hash": 4180964683905830761, "project": "debian", "size": 4, "label": 0, "functionSource": "static int selinux_inode_readlink ( struct dentry * dentry ) {\n const struct cred * cred = current_cred ( ) ;\n return dentry_has_perm ( cred , dentry , FILE__READ ) ;\n }", "idx": 2146}
{"hash": -1315695702746584250, "project": "debian", "size": 8, "label": 0, "functionSource": "header_field_info * proto_get_next_protocol_field ( const int proto_id , void * * cookie ) {\n protocol_t * protocol = find_protocol_by_id ( proto_id ) ;\n guint i = GPOINTER_TO_UINT ( * cookie ) - 1 ;\n i ++ ;\n if ( i >= protocol -> fields -> len ) return NULL ;\n * cookie = GUINT_TO_POINTER ( i + 1 ) ;\n return ( header_field_info * ) g_ptr_array_index ( protocol -> fields , i ) ;\n }", "idx": 2147}
{"hash": -1409799581796815039, "project": "debian", "size": 18, "label": 1, "functionSource": "static inline int handle_cpu_signal ( uintptr_t pc , unsigned long address , int is_write , sigset_t * old_set , void * puc ) {\n int ret ;\n # if defined ( DEBUG_SIGNAL ) qemu_printf ( \"qemu: SIGSEGV pc=0x%08lx address=%08lx w=%d oldset=0x%08lx\\n\" , pc , address , is_write , * ( unsigned long * ) old_set ) ;\n # endif if ( is_write && h2g_valid ( address ) && page_unprotect ( h2g ( address ) , pc , puc ) ) {\n return 1 ;\n }\n ret = cpu_handle_mmu_fault ( cpu_single_env , address , is_write , MMU_USER_IDX ) ;\n if ( ret < 0 ) {\n return 0 ;\n }\n if ( ret == 0 ) {\n return 1 ;\n }\n cpu_restore_state ( cpu_single_env , pc ) ;\n sigprocmask ( SIG_SETMASK , old_set , NULL ) ;\n exception_action ( cpu_single_env ) ;\n return 1 ;\n }", "idx": 2148}
{"hash": 8693230691624196914, "project": "chrome", "size": 3, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( ExtensionPreferenceApiTest , DISABLED_IncognitoDisabled ) {\n EXPECT_FALSE ( RunExtensionTest ( \"preference/persistent_incognito\" ) ) ;\n }", "idx": 2149}
{"hash": -5992472514718425579, "project": "debian", "size": 17, "label": 0, "functionSource": "static int cgroup_read_from_file ( const char * fn , char buf [ ] , size_t bufsize ) {\n int ret = lxc_read_from_file ( fn , buf , bufsize ) ;\n if ( ret < 0 ) {\n SYSERROR ( \"failed to read %s\" , fn ) ;\n return ret ;\n }\n if ( ret == bufsize ) {\n if ( bufsize > 0 ) {\n buf [ bufsize - 1 ] = '\\0' ;\n return ret ;\n }\n ERROR ( \"%s: was not expecting 0 bufsize\" , __func__ ) ;\n return - 1 ;\n }\n buf [ ret ] = '\\0' ;\n return ret ;\n }", "idx": 2150}
{"hash": 1743019814289113128, "project": "debian", "size": 219, "label": 1, "functionSource": "static void pred_spatial_direct_motion ( H264Context * const h , int * mb_type ) {\n int b8_stride = 2 ;\n int b4_stride = h -> b_stride ;\n int mb_xy = h -> mb_xy , mb_y = h -> mb_y ;\n int mb_type_col [ 2 ] ;\n const int16_t ( * l1mv0 ) [ 2 ] , ( * l1mv1 ) [ 2 ] ;\n const int8_t * l1ref0 , * l1ref1 ;\n const int is_b8x8 = IS_8X8 ( * mb_type ) ;\n unsigned int sub_mb_type = MB_TYPE_L0L1 ;\n int i8 , i4 ;\n int ref [ 2 ] ;\n int mv [ 2 ] ;\n int list ;\n assert ( h -> ref_list [ 1 ] [ 0 ] . f . reference & 3 ) ;\n await_reference_mb_row ( h , & h -> ref_list [ 1 ] [ 0 ] , h -> mb_y + ! ! IS_INTERLACED ( * mb_type ) ) ;\n # define MB_TYPE_16x16_OR_INTRA ( MB_TYPE_16x16 | MB_TYPE_INTRA4x4 | MB_TYPE_INTRA16x16 | MB_TYPE_INTRA_PCM ) for ( list = 0 ;\n list < 2 ;\n list ++ ) {\n int left_ref = h -> ref_cache [ list ] [ scan8 [ 0 ] - 1 ] ;\n int top_ref = h -> ref_cache [ list ] [ scan8 [ 0 ] - 8 ] ;\n int refc = h -> ref_cache [ list ] [ scan8 [ 0 ] - 8 + 4 ] ;\n const int16_t * C = h -> mv_cache [ list ] [ scan8 [ 0 ] - 8 + 4 ] ;\n if ( refc == PART_NOT_AVAILABLE ) {\n refc = h -> ref_cache [ list ] [ scan8 [ 0 ] - 8 - 1 ] ;\n C = h -> mv_cache [ list ] [ scan8 [ 0 ] - 8 - 1 ] ;\n }\n ref [ list ] = FFMIN3 ( ( unsigned ) left_ref , ( unsigned ) top_ref , ( unsigned ) refc ) ;\n if ( ref [ list ] >= 0 ) {\n const int16_t * const A = h -> mv_cache [ list ] [ scan8 [ 0 ] - 1 ] ;\n const int16_t * const B = h -> mv_cache [ list ] [ scan8 [ 0 ] - 8 ] ;\n int match_count = ( left_ref == ref [ list ] ) + ( top_ref == ref [ list ] ) + ( refc == ref [ list ] ) ;\n if ( match_count > 1 ) {\n mv [ list ] = pack16to32 ( mid_pred ( A [ 0 ] , B [ 0 ] , C [ 0 ] ) , mid_pred ( A [ 1 ] , B [ 1 ] , C [ 1 ] ) ) ;\n }\n else {\n assert ( match_count == 1 ) ;\n if ( left_ref == ref [ list ] ) {\n mv [ list ] = AV_RN32A ( A ) ;\n }\n else if ( top_ref == ref [ list ] ) {\n mv [ list ] = AV_RN32A ( B ) ;\n }\n else {\n mv [ list ] = AV_RN32A ( C ) ;\n }\n }\n }\n else {\n int mask = ~ ( MB_TYPE_L0 << ( 2 * list ) ) ;\n mv [ list ] = 0 ;\n ref [ list ] = - 1 ;\n if ( ! is_b8x8 ) * mb_type &= mask ;\n sub_mb_type &= mask ;\n }\n }\n if ( ref [ 0 ] < 0 && ref [ 1 ] < 0 ) {\n ref [ 0 ] = ref [ 1 ] = 0 ;\n if ( ! is_b8x8 ) * mb_type |= MB_TYPE_L0L1 ;\n sub_mb_type |= MB_TYPE_L0L1 ;\n }\n if ( ! ( is_b8x8 | mv [ 0 ] | mv [ 1 ] ) ) {\n fill_rectangle ( & h -> ref_cache [ 0 ] [ scan8 [ 0 ] ] , 4 , 4 , 8 , ( uint8_t ) ref [ 0 ] , 1 ) ;\n fill_rectangle ( & h -> ref_cache [ 1 ] [ scan8 [ 0 ] ] , 4 , 4 , 8 , ( uint8_t ) ref [ 1 ] , 1 ) ;\n fill_rectangle ( & h -> mv_cache [ 0 ] [ scan8 [ 0 ] ] , 4 , 4 , 8 , 0 , 4 ) ;\n fill_rectangle ( & h -> mv_cache [ 1 ] [ scan8 [ 0 ] ] , 4 , 4 , 8 , 0 , 4 ) ;\n * mb_type = ( * mb_type & ~ ( MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 | MB_TYPE_P1L0 | MB_TYPE_P1L1 ) ) | MB_TYPE_16x16 | MB_TYPE_DIRECT2 ;\n return ;\n }\n if ( IS_INTERLACED ( h -> ref_list [ 1 ] [ 0 ] . f . mb_type [ mb_xy ] ) ) {\n if ( ! IS_INTERLACED ( * mb_type ) ) {\n mb_y = ( h -> mb_y & ~ 1 ) + h -> col_parity ;\n mb_xy = h -> mb_x + ( ( h -> mb_y & ~ 1 ) + h -> col_parity ) * h -> mb_stride ;\n b8_stride = 0 ;\n }\n else {\n mb_y += h -> col_fieldoff ;\n mb_xy += h -> mb_stride * h -> col_fieldoff ;\n }\n goto single_col ;\n }\n else {\n if ( IS_INTERLACED ( * mb_type ) ) {\n mb_y = h -> mb_y & ~ 1 ;\n mb_xy = h -> mb_x + ( h -> mb_y & ~ 1 ) * h -> mb_stride ;\n mb_type_col [ 0 ] = h -> ref_list [ 1 ] [ 0 ] . f . mb_type [ mb_xy ] ;\n mb_type_col [ 1 ] = h -> ref_list [ 1 ] [ 0 ] . f . mb_type [ mb_xy + h -> mb_stride ] ;\n b8_stride = 2 + 4 * h -> mb_stride ;\n b4_stride *= 6 ;\n if ( IS_INTERLACED ( mb_type_col [ 0 ] ) != IS_INTERLACED ( mb_type_col [ 1 ] ) ) {\n mb_type_col [ 0 ] &= ~ MB_TYPE_INTERLACED ;\n mb_type_col [ 1 ] &= ~ MB_TYPE_INTERLACED ;\n }\n sub_mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2 ;\n if ( ( mb_type_col [ 0 ] & MB_TYPE_16x16_OR_INTRA ) && ( mb_type_col [ 1 ] & MB_TYPE_16x16_OR_INTRA ) && ! is_b8x8 ) {\n * mb_type |= MB_TYPE_16x8 | MB_TYPE_DIRECT2 ;\n }\n else {\n * mb_type |= MB_TYPE_8x8 ;\n }\n }\n else {\n single_col : mb_type_col [ 0 ] = mb_type_col [ 1 ] = h -> ref_list [ 1 ] [ 0 ] . f . mb_type [ mb_xy ] ;\n sub_mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2 ;\n if ( ! is_b8x8 && ( mb_type_col [ 0 ] & MB_TYPE_16x16_OR_INTRA ) ) {\n * mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2 ;\n }\n else if ( ! is_b8x8 && ( mb_type_col [ 0 ] & ( MB_TYPE_16x8 | MB_TYPE_8x16 ) ) ) {\n * mb_type |= MB_TYPE_DIRECT2 | ( mb_type_col [ 0 ] & ( MB_TYPE_16x8 | MB_TYPE_8x16 ) ) ;\n }\n else {\n if ( ! h -> sps . direct_8x8_inference_flag ) {\n sub_mb_type += ( MB_TYPE_8x8 - MB_TYPE_16x16 ) ;\n }\n * mb_type |= MB_TYPE_8x8 ;\n }\n }\n }\n await_reference_mb_row ( h , & h -> ref_list [ 1 ] [ 0 ] , mb_y ) ;\n l1mv0 = & h -> ref_list [ 1 ] [ 0 ] . f . motion_val [ 0 ] [ h -> mb2b_xy [ mb_xy ] ] ;\n l1mv1 = & h -> ref_list [ 1 ] [ 0 ] . f . motion_val [ 1 ] [ h -> mb2b_xy [ mb_xy ] ] ;\n l1ref0 = & h -> ref_list [ 1 ] [ 0 ] . f . ref_index [ 0 ] [ 4 * mb_xy ] ;\n l1ref1 = & h -> ref_list [ 1 ] [ 0 ] . f . ref_index [ 1 ] [ 4 * mb_xy ] ;\n if ( ! b8_stride ) {\n if ( h -> mb_y & 1 ) {\n l1ref0 += 2 ;\n l1ref1 += 2 ;\n l1mv0 += 2 * b4_stride ;\n l1mv1 += 2 * b4_stride ;\n }\n }\n if ( IS_INTERLACED ( * mb_type ) != IS_INTERLACED ( mb_type_col [ 0 ] ) ) {\n int n = 0 ;\n for ( i8 = 0 ;\n i8 < 4 ;\n i8 ++ ) {\n int x8 = i8 & 1 ;\n int y8 = i8 >> 1 ;\n int xy8 = x8 + y8 * b8_stride ;\n int xy4 = 3 * x8 + y8 * b4_stride ;\n int a , b ;\n if ( is_b8x8 && ! IS_DIRECT ( h -> sub_mb_type [ i8 ] ) ) continue ;\n h -> sub_mb_type [ i8 ] = sub_mb_type ;\n fill_rectangle ( & h -> ref_cache [ 0 ] [ scan8 [ i8 * 4 ] ] , 2 , 2 , 8 , ( uint8_t ) ref [ 0 ] , 1 ) ;\n fill_rectangle ( & h -> ref_cache [ 1 ] [ scan8 [ i8 * 4 ] ] , 2 , 2 , 8 , ( uint8_t ) ref [ 1 ] , 1 ) ;\n if ( ! IS_INTRA ( mb_type_col [ y8 ] ) && ! h -> ref_list [ 1 ] [ 0 ] . long_ref && ( ( l1ref0 [ xy8 ] == 0 && FFABS ( l1mv0 [ xy4 ] [ 0 ] ) <= 1 && FFABS ( l1mv0 [ xy4 ] [ 1 ] ) <= 1 ) || ( l1ref0 [ xy8 ] < 0 && l1ref1 [ xy8 ] == 0 && FFABS ( l1mv1 [ xy4 ] [ 0 ] ) <= 1 && FFABS ( l1mv1 [ xy4 ] [ 1 ] ) <= 1 ) ) ) {\n a = b = 0 ;\n if ( ref [ 0 ] > 0 ) a = mv [ 0 ] ;\n if ( ref [ 1 ] > 0 ) b = mv [ 1 ] ;\n n ++ ;\n }\n else {\n a = mv [ 0 ] ;\n b = mv [ 1 ] ;\n }\n fill_rectangle ( & h -> mv_cache [ 0 ] [ scan8 [ i8 * 4 ] ] , 2 , 2 , 8 , a , 4 ) ;\n fill_rectangle ( & h -> mv_cache [ 1 ] [ scan8 [ i8 * 4 ] ] , 2 , 2 , 8 , b , 4 ) ;\n }\n if ( ! is_b8x8 && ! ( n & 3 ) ) * mb_type = ( * mb_type & ~ ( MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 | MB_TYPE_P1L0 | MB_TYPE_P1L1 ) ) | MB_TYPE_16x16 | MB_TYPE_DIRECT2 ;\n }\n else if ( IS_16X16 ( * mb_type ) ) {\n int a , b ;\n fill_rectangle ( & h -> ref_cache [ 0 ] [ scan8 [ 0 ] ] , 4 , 4 , 8 , ( uint8_t ) ref [ 0 ] , 1 ) ;\n fill_rectangle ( & h -> ref_cache [ 1 ] [ scan8 [ 0 ] ] , 4 , 4 , 8 , ( uint8_t ) ref [ 1 ] , 1 ) ;\n if ( ! IS_INTRA ( mb_type_col [ 0 ] ) && ! h -> ref_list [ 1 ] [ 0 ] . long_ref && ( ( l1ref0 [ 0 ] == 0 && FFABS ( l1mv0 [ 0 ] [ 0 ] ) <= 1 && FFABS ( l1mv0 [ 0 ] [ 1 ] ) <= 1 ) || ( l1ref0 [ 0 ] < 0 && l1ref1 [ 0 ] == 0 && FFABS ( l1mv1 [ 0 ] [ 0 ] ) <= 1 && FFABS ( l1mv1 [ 0 ] [ 1 ] ) <= 1 && h -> x264_build > 33U ) ) ) {\n a = b = 0 ;\n if ( ref [ 0 ] > 0 ) a = mv [ 0 ] ;\n if ( ref [ 1 ] > 0 ) b = mv [ 1 ] ;\n }\n else {\n a = mv [ 0 ] ;\n b = mv [ 1 ] ;\n }\n fill_rectangle ( & h -> mv_cache [ 0 ] [ scan8 [ 0 ] ] , 4 , 4 , 8 , a , 4 ) ;\n fill_rectangle ( & h -> mv_cache [ 1 ] [ scan8 [ 0 ] ] , 4 , 4 , 8 , b , 4 ) ;\n }\n else {\n int n = 0 ;\n for ( i8 = 0 ;\n i8 < 4 ;\n i8 ++ ) {\n const int x8 = i8 & 1 ;\n const int y8 = i8 >> 1 ;\n if ( is_b8x8 && ! IS_DIRECT ( h -> sub_mb_type [ i8 ] ) ) continue ;\n h -> sub_mb_type [ i8 ] = sub_mb_type ;\n fill_rectangle ( & h -> mv_cache [ 0 ] [ scan8 [ i8 * 4 ] ] , 2 , 2 , 8 , mv [ 0 ] , 4 ) ;\n fill_rectangle ( & h -> mv_cache [ 1 ] [ scan8 [ i8 * 4 ] ] , 2 , 2 , 8 , mv [ 1 ] , 4 ) ;\n fill_rectangle ( & h -> ref_cache [ 0 ] [ scan8 [ i8 * 4 ] ] , 2 , 2 , 8 , ( uint8_t ) ref [ 0 ] , 1 ) ;\n fill_rectangle ( & h -> ref_cache [ 1 ] [ scan8 [ i8 * 4 ] ] , 2 , 2 , 8 , ( uint8_t ) ref [ 1 ] , 1 ) ;\n assert ( b8_stride == 2 ) ;\n if ( ! IS_INTRA ( mb_type_col [ 0 ] ) && ! h -> ref_list [ 1 ] [ 0 ] . long_ref && ( l1ref0 [ i8 ] == 0 || ( l1ref0 [ i8 ] < 0 && l1ref1 [ i8 ] == 0 && h -> x264_build > 33U ) ) ) {\n const int16_t ( * l1mv ) [ 2 ] = l1ref0 [ i8 ] == 0 ? l1mv0 : l1mv1 ;\n if ( IS_SUB_8X8 ( sub_mb_type ) ) {\n const int16_t * mv_col = l1mv [ x8 * 3 + y8 * 3 * b4_stride ] ;\n if ( FFABS ( mv_col [ 0 ] ) <= 1 && FFABS ( mv_col [ 1 ] ) <= 1 ) {\n if ( ref [ 0 ] == 0 ) fill_rectangle ( & h -> mv_cache [ 0 ] [ scan8 [ i8 * 4 ] ] , 2 , 2 , 8 , 0 , 4 ) ;\n if ( ref [ 1 ] == 0 ) fill_rectangle ( & h -> mv_cache [ 1 ] [ scan8 [ i8 * 4 ] ] , 2 , 2 , 8 , 0 , 4 ) ;\n n += 4 ;\n }\n }\n else {\n int m = 0 ;\n for ( i4 = 0 ;\n i4 < 4 ;\n i4 ++ ) {\n const int16_t * mv_col = l1mv [ x8 * 2 + ( i4 & 1 ) + ( y8 * 2 + ( i4 >> 1 ) ) * b4_stride ] ;\n if ( FFABS ( mv_col [ 0 ] ) <= 1 && FFABS ( mv_col [ 1 ] ) <= 1 ) {\n if ( ref [ 0 ] == 0 ) AV_ZERO32 ( h -> mv_cache [ 0 ] [ scan8 [ i8 * 4 + i4 ] ] ) ;\n if ( ref [ 1 ] == 0 ) AV_ZERO32 ( h -> mv_cache [ 1 ] [ scan8 [ i8 * 4 + i4 ] ] ) ;\n m ++ ;\n }\n }\n if ( ! ( m & 3 ) ) h -> sub_mb_type [ i8 ] += MB_TYPE_16x16 - MB_TYPE_8x8 ;\n n += m ;\n }\n }\n }\n if ( ! is_b8x8 && ! ( n & 15 ) ) * mb_type = ( * mb_type & ~ ( MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 | MB_TYPE_P1L0 | MB_TYPE_P1L1 ) ) | MB_TYPE_16x16 | MB_TYPE_DIRECT2 ;\n }\n }", "idx": 2151}
{"hash": 3599206110384554647, "project": "debian", "size": 69, "label": 1, "functionSource": "static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _new ( sk_ ## t1 ## _compfunc compare ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_new ( ( OPENSSL_sk_compfunc ) compare ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _new_null ( void ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_new_null ( ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _new_reserve ( sk_ ## t1 ## _compfunc compare , int n ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_new_reserve ( ( OPENSSL_sk_compfunc ) compare , n ) ;\n }\n static ossl_inline int sk_ ## t1 ## _reserve ( STACK_OF ( t1 ) * sk , int n ) {\n return OPENSSL_sk_reserve ( ( OPENSSL_STACK * ) sk , n ) ;\n }\n static ossl_inline void sk_ ## t1 ## _free ( STACK_OF ( t1 ) * sk ) {\n OPENSSL_sk_free ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline void sk_ ## t1 ## _zero ( STACK_OF ( t1 ) * sk ) {\n OPENSSL_sk_zero ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _delete ( STACK_OF ( t1 ) * sk , int i ) {\n return ( t2 * ) OPENSSL_sk_delete ( ( OPENSSL_STACK * ) sk , i ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _delete_ptr ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return ( t2 * ) OPENSSL_sk_delete_ptr ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _push ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_push ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _unshift ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_unshift ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _pop ( STACK_OF ( t1 ) * sk ) {\n return ( t2 * ) OPENSSL_sk_pop ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _shift ( STACK_OF ( t1 ) * sk ) {\n return ( t2 * ) OPENSSL_sk_shift ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline void sk_ ## t1 ## _pop_free ( STACK_OF ( t1 ) * sk , sk_ ## t1 ## _freefunc freefunc ) {\n OPENSSL_sk_pop_free ( ( OPENSSL_STACK * ) sk , ( OPENSSL_sk_freefunc ) freefunc ) ;\n }\n static ossl_inline int sk_ ## t1 ## _insert ( STACK_OF ( t1 ) * sk , t2 * ptr , int idx ) {\n return OPENSSL_sk_insert ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr , idx ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _set ( STACK_OF ( t1 ) * sk , int idx , t2 * ptr ) {\n return ( t2 * ) OPENSSL_sk_set ( ( OPENSSL_STACK * ) sk , idx , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _find ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_find ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _find_ex ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_find_ex ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline void sk_ ## t1 ## _sort ( STACK_OF ( t1 ) * sk ) {\n OPENSSL_sk_sort ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline int sk_ ## t1 ## _is_sorted ( const STACK_OF ( t1 ) * sk ) {\n return OPENSSL_sk_is_sorted ( ( const OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _dup ( const STACK_OF ( t1 ) * sk ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_dup ( ( const OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _deep_copy ( const STACK_OF ( t1 ) * sk , sk_ ## t1 ## _copyfunc copyfunc , sk_ ## t1 ## _freefunc freefunc ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_deep_copy ( ( const OPENSSL_STACK * ) sk , ( OPENSSL_sk_copyfunc ) copyfunc , ( OPENSSL_sk_freefunc ) freefunc ) ;\n }\n static ossl_inline sk_ ## t1 ## _compfunc sk_ ## t1 ## _set_cmp_func ( STACK_OF ( t1 ) * sk , sk_ ## t1 ## _compfunc compare ) {\n return ( sk_ ## t1 ## _compfunc ) OPENSSL_sk_set_cmp_func ( ( OPENSSL_STACK * ) sk , ( OPENSSL_sk_compfunc ) compare ) ;\n }\n # define DEFINE_SPECIAL_STACK_OF ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , t2 , t2 ) # define DEFINE_STACK_OF ( t ) SKM_DEFINE_STACK_OF ( t , t , t ) # define DEFINE_SPECIAL_STACK_OF_CONST ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , const t2 , t2 ) # define DEFINE_STACK_OF_CONST ( t ) SKM_DEFINE_STACK_OF ( t , const t , t ) typedef char * OPENSSL_STRING ;\n typedef const char * OPENSSL_CSTRING ;\n DEFINE_SPECIAL_STACK_OF ( OPENSSL_STRING , char ) DEFINE_SPECIAL_STACK_OF_CONST ( OPENSSL_CSTRING , char )", "idx": 2152}
{"hash": 5704453449583823009, "project": "chrome", "size": 9, "label": 0, "functionSource": "int evbuffer_write ( struct evbuffer * buffer , int fd ) {\n int n ;\n # ifndef WIN32 n = write ( fd , buffer -> buffer , buffer -> off ) ;\n # else n = send ( fd , buffer -> buffer , buffer -> off , 0 ) ;\n # endif if ( n == - 1 ) return ( - 1 ) ;\n if ( n == 0 ) return ( 0 ) ;\n evbuffer_drain ( buffer , n ) ;\n return ( n ) ;\n }", "idx": 2153}
{"hash": -5241093592682744127, "project": "debian", "size": 33, "label": 0, "functionSource": "static Selectivity mcelem_array_selec ( ArrayType * array , TypeCacheEntry * typentry , Datum * mcelem , int nmcelem , float4 * numbers , int nnumbers , float4 * hist , int nhist , Oid operator , FmgrInfo * cmpfunc ) {\n Selectivity selec ;\n int num_elems ;\n Datum * elem_values ;\n bool * elem_nulls ;\n bool null_present ;\n int nonnull_nitems ;\n int i ;\n deconstruct_array ( array , typentry -> type_id , typentry -> typlen , typentry -> typbyval , typentry -> typalign , & elem_values , & elem_nulls , & num_elems ) ;\n nonnull_nitems = 0 ;\n null_present = false ;\n for ( i = 0 ;\n i < num_elems ;\n i ++ ) {\n if ( elem_nulls [ i ] ) null_present = true ;\n else elem_values [ nonnull_nitems ++ ] = elem_values [ i ] ;\n }\n if ( null_present && operator == OID_ARRAY_CONTAINS_OP ) {\n pfree ( elem_values ) ;\n pfree ( elem_nulls ) ;\n return ( Selectivity ) 0.0 ;\n }\n qsort_arg ( elem_values , nonnull_nitems , sizeof ( Datum ) , element_compare , cmpfunc ) ;\n if ( operator == OID_ARRAY_CONTAINS_OP || operator == OID_ARRAY_OVERLAP_OP ) selec = mcelem_array_contain_overlap_selec ( mcelem , nmcelem , numbers , nnumbers , elem_values , nonnull_nitems , operator , cmpfunc ) ;\n else if ( operator == OID_ARRAY_CONTAINED_OP ) selec = mcelem_array_contained_selec ( mcelem , nmcelem , numbers , nnumbers , elem_values , nonnull_nitems , hist , nhist , operator , cmpfunc ) ;\n else {\n elog ( ERROR , \"arraycontsel called for unrecognized operator %u\" , operator ) ;\n selec = 0.0 ;\n }\n pfree ( elem_values ) ;\n pfree ( elem_nulls ) ;\n return selec ;\n }", "idx": 2154}
{"hash": 7092216800726729686, "project": "debian", "size": 5, "label": 0, "functionSource": "static int dissect_h245_T_h223_al_type_al1Framed ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 294 \"../../asn1/h245/h245.cnf\" if ( h223_lc_params_temp ) h223_lc_params_temp -> al_type = al1Framed ;\n offset = dissect_per_null ( tvb , offset , actx , tree , hf_index ) ;\n return offset ;\n }", "idx": 2155}
{"hash": 355220887711506893, "project": "debian", "size": 3, "label": 0, "functionSource": "Datum scalarltjoinsel ( PG_FUNCTION_ARGS ) {\n PG_RETURN_FLOAT8 ( DEFAULT_INEQ_SEL ) ;\n }", "idx": 2156}
{"hash": 1760449185745615462, "project": "debian", "size": 4, "label": 0, "functionSource": "void TSFetchUserDataSet ( TSFetchSM fetch_sm , void * data ) {\n sdk_assert ( sdk_sanity_check_fetch_sm ( fetch_sm ) == TS_SUCCESS ) ;\n ( ( FetchSM * ) fetch_sm ) -> ext_set_user_data ( data ) ;\n }", "idx": 2157}
{"hash": 355220887711506893, "project": "debian", "size": 14, "label": 0, "functionSource": "static Node * strip_array_coercion ( Node * node ) {\n for ( ;\n ;\n ) {\n if ( node && IsA ( node , ArrayCoerceExpr ) && ( ( ArrayCoerceExpr * ) node ) -> elemfuncid == InvalidOid ) {\n node = ( Node * ) ( ( ArrayCoerceExpr * ) node ) -> arg ;\n }\n else if ( node && IsA ( node , RelabelType ) ) {\n node = ( Node * ) ( ( RelabelType * ) node ) -> arg ;\n }\n else break ;\n }\n return node ;\n }", "idx": 2158}
{"hash": 3584320764213684062, "project": "debian", "size": 21, "label": 1, "functionSource": "static int parse_CInGroupSortAggregSets ( tvbuff_t * tvb , int offset , proto_tree * parent_tree , proto_tree * pad_tree , const char * fmt , ... ) {\n guint32 cCount , i ;\n proto_item * item ;\n proto_tree * tree ;\n const char * txt ;\n va_list ap ;\n va_start ( ap , fmt ) ;\n txt = wmem_strdup_vprintf ( wmem_packet_scope ( ) , fmt , ap ) ;\n va_end ( ap ) ;\n tree = proto_tree_add_subtree ( parent_tree , tvb , offset , 0 , ett_CInGroupSortAggregSets , & item , txt ) ;\n cCount = tvb_get_letohl ( tvb , offset ) ;\n proto_tree_add_uint ( tree , hf_mswsp_cingroupsortaggregsets_count , tvb , offset , 4 , cCount ) ;\n offset += 4 ;\n for ( i = 0 ;\n i < cCount ;\n i ++ ) {\n offset = parse_CInGroupSortAggregSet ( tvb , offset , tree , pad_tree , \"SortSets[%u]\" , i ) ;\n }\n proto_item_set_end ( item , tvb , offset ) ;\n return offset ;\n }", "idx": 2159}
{"hash": -6856626433814917486, "project": "debian", "size": 23, "label": 0, "functionSource": "static const char * get_sep_media_type ( guint32 interface_id , guint32 adapter_id , guint32 chandle , guint32 direction , guint32 seid , guint32 frame_number ) {\n wmem_tree_key_t key [ 6 ] ;\n wmem_tree_t * subtree ;\n sep_entry_t * sep ;\n key [ 0 ] . length = 1 ;\n key [ 0 ] . key = & interface_id ;\n key [ 1 ] . length = 1 ;\n key [ 1 ] . key = & adapter_id ;\n key [ 2 ] . length = 1 ;\n key [ 2 ] . key = & chandle ;\n key [ 3 ] . length = 1 ;\n key [ 3 ] . key = & direction ;\n key [ 4 ] . length = 1 ;\n key [ 4 ] . key = & seid ;\n key [ 5 ] . length = 0 ;\n key [ 5 ] . key = NULL ;\n subtree = ( wmem_tree_t * ) wmem_tree_lookup32_array ( sep_list , key ) ;\n sep = ( subtree ) ? ( sep_entry_t * ) wmem_tree_lookup32_le ( subtree , frame_number ) : NULL ;\n if ( sep ) {\n return val_to_str_const ( sep -> media_type , media_type_vals , \"unknown\" ) ;\n }\n return \"unknown\" ;\n }", "idx": 2160}
{"hash": 6393050609822897742, "project": "debian", "size": 34, "label": 0, "functionSource": "static TRBType xhci_ring_fetch ( XHCIState * xhci , XHCIRing * ring , XHCITRB * trb , dma_addr_t * addr ) {\n PCIDevice * pci_dev = PCI_DEVICE ( xhci ) ;\n uint32_t link_cnt = 0 ;\n while ( 1 ) {\n TRBType type ;\n pci_dma_read ( pci_dev , ring -> dequeue , trb , TRB_SIZE ) ;\n trb -> addr = ring -> dequeue ;\n trb -> ccs = ring -> ccs ;\n le64_to_cpus ( & trb -> parameter ) ;\n le32_to_cpus ( & trb -> status ) ;\n le32_to_cpus ( & trb -> control ) ;\n trace_usb_xhci_fetch_trb ( ring -> dequeue , trb_name ( trb ) , trb -> parameter , trb -> status , trb -> control ) ;\n if ( ( trb -> control & TRB_C ) != ring -> ccs ) {\n return 0 ;\n }\n type = TRB_TYPE ( * trb ) ;\n if ( type != TR_LINK ) {\n if ( addr ) {\n * addr = ring -> dequeue ;\n }\n ring -> dequeue += TRB_SIZE ;\n return type ;\n }\n else {\n if ( ++ link_cnt > TRB_LINK_LIMIT ) {\n return 0 ;\n }\n ring -> dequeue = xhci_mask64 ( trb -> parameter ) ;\n if ( trb -> control & TRB_LK_TC ) {\n ring -> ccs = ! ring -> ccs ;\n }\n }\n }\n }", "idx": 2161}
{"hash": -2386031673786599357, "project": "debian", "size": 13, "label": 0, "functionSource": "static gpgme_error_t gpgsm_cancel ( void * engine ) {\n engine_gpgsm_t gpgsm = engine ;\n if ( ! gpgsm ) return gpg_error ( GPG_ERR_INV_VALUE ) ;\n if ( gpgsm -> status_cb . fd != - 1 ) _gpgme_io_close ( gpgsm -> status_cb . fd ) ;\n if ( gpgsm -> input_cb . fd != - 1 ) _gpgme_io_close ( gpgsm -> input_cb . fd ) ;\n if ( gpgsm -> output_cb . fd != - 1 ) _gpgme_io_close ( gpgsm -> output_cb . fd ) ;\n if ( gpgsm -> message_cb . fd != - 1 ) _gpgme_io_close ( gpgsm -> message_cb . fd ) ;\n if ( gpgsm -> assuan_ctx ) {\n assuan_release ( gpgsm -> assuan_ctx ) ;\n gpgsm -> assuan_ctx = NULL ;\n }\n return 0 ;\n }", "idx": 2162}
{"hash": -7614722514335375899, "project": "chrome", "size": 28, "label": 1, "functionSource": "TEST_F ( ProfileInfoCacheTest , DownloadHighResAvatarTest ) {\n switches : : EnableNewAvatarMenuForTesting ( base : : CommandLine : : ForCurrentProcess ( ) ) ;\n EXPECT_EQ ( 0U , GetCache ( ) -> GetNumberOfProfiles ( ) ) ;\n base : : FilePath path_1 = GetProfilePath ( \"path_1\" ) ;\n GetCache ( ) -> AddProfileToCache ( path_1 , ASCIIToUTF16 ( \"name_1\" ) , base : : string16 ( ) , 0 , std : : string ( ) ) ;\n EXPECT_EQ ( 1U , GetCache ( ) -> GetNumberOfProfiles ( ) ) ;\n base : : RunLoop ( ) . RunUntilIdle ( ) ;\n EXPECT_EQ ( 0U , GetCache ( ) -> cached_avatar_images_ . size ( ) ) ;\n EXPECT_EQ ( 1U , GetCache ( ) -> avatar_images_downloads_in_progress_ . size ( ) ) ;\n EXPECT_FALSE ( GetCache ( ) -> GetHighResAvatarOfProfileAtIndex ( 0 ) ) ;\n const size_t kIconIndex = 0 ;\n ProfileAvatarDownloader avatar_downloader ( kIconIndex , GetCache ( ) -> GetPathOfProfileAtIndex ( 0 ) , GetCache ( ) ) ;\n SkBitmap bitmap ;\n bitmap . allocN32Pixels ( 2 , 2 ) ;\n bitmap . eraseColor ( SK_ColorGREEN ) ;\n avatar_downloader . OnFetchComplete ( GURL ( \"http://www.google.com/avatar.png\" ) , & bitmap ) ;\n EXPECT_EQ ( 0U , GetCache ( ) -> avatar_images_downloads_in_progress_ . size ( ) ) ;\n std : : string file_name = profiles : : GetDefaultAvatarIconFileNameAtIndex ( kIconIndex ) ;\n EXPECT_EQ ( 1U , GetCache ( ) -> cached_avatar_images_ . size ( ) ) ;\n EXPECT_TRUE ( GetCache ( ) -> GetHighResAvatarOfProfileAtIndex ( 0 ) ) ;\n EXPECT_EQ ( GetCache ( ) -> cached_avatar_images_ [ file_name ] , GetCache ( ) -> GetHighResAvatarOfProfileAtIndex ( 0 ) ) ;\n base : : RunLoop ( ) . RunUntilIdle ( ) ;\n base : : FilePath icon_path = profiles : : GetPathOfHighResAvatarAtIndex ( kIconIndex ) ;\n EXPECT_NE ( std : : string : : npos , icon_path . MaybeAsASCII ( ) . find ( file_name ) ) ;\n EXPECT_TRUE ( base : : PathExists ( icon_path ) ) ;\n EXPECT_TRUE ( base : : DeleteFile ( icon_path , true ) ) ;\n EXPECT_FALSE ( base : : PathExists ( icon_path ) ) ;\n }", "idx": 2163}
{"hash": 6250095321513210169, "project": "debian", "size": 445, "label": 0, "functionSource": "static void rfbProcessClientNormalMessage ( rfbClientPtr cl ) {\n int n = 0 ;\n rfbClientToServerMsg msg ;\n char * str ;\n int i ;\n uint32_t enc = 0 ;\n uint32_t lastPreferredEncoding = - 1 ;\n char encBuf [ 64 ] ;\n char encBuf2 [ 64 ] ;\n if ( ( n = rfbReadExact ( cl , ( char * ) & msg , 1 ) ) <= 0 ) {\n if ( n != 0 ) rfbLogPerror ( \"rfbProcessClientNormalMessage: read\" ) ;\n rfbCloseClient ( cl ) ;\n return ;\n }\n switch ( msg . type ) {\n case rfbSetPixelFormat : if ( ( n = rfbReadExact ( cl , ( ( char * ) & msg ) + 1 , sz_rfbSetPixelFormatMsg - 1 ) ) <= 0 ) {\n if ( n != 0 ) rfbLogPerror ( \"rfbProcessClientNormalMessage: read\" ) ;\n rfbCloseClient ( cl ) ;\n return ;\n }\n cl -> format . bitsPerPixel = msg . spf . format . bitsPerPixel ;\n cl -> format . depth = msg . spf . format . depth ;\n cl -> format . bigEndian = ( msg . spf . format . bigEndian ? TRUE : FALSE ) ;\n cl -> format . trueColour = ( msg . spf . format . trueColour ? TRUE : FALSE ) ;\n cl -> format . redMax = Swap16IfLE ( msg . spf . format . redMax ) ;\n cl -> format . greenMax = Swap16IfLE ( msg . spf . format . greenMax ) ;\n cl -> format . blueMax = Swap16IfLE ( msg . spf . format . blueMax ) ;\n cl -> format . redShift = msg . spf . format . redShift ;\n cl -> format . greenShift = msg . spf . format . greenShift ;\n cl -> format . blueShift = msg . spf . format . blueShift ;\n cl -> readyForSetColourMapEntries = TRUE ;\n cl -> screen -> setTranslateFunction ( cl ) ;\n rfbStatRecordMessageRcvd ( cl , msg . type , sz_rfbSetPixelFormatMsg , sz_rfbSetPixelFormatMsg ) ;\n return ;\n case rfbFixColourMapEntries : if ( ( n = rfbReadExact ( cl , ( ( char * ) & msg ) + 1 , sz_rfbFixColourMapEntriesMsg - 1 ) ) <= 0 ) {\n if ( n != 0 ) rfbLogPerror ( \"rfbProcessClientNormalMessage: read\" ) ;\n rfbCloseClient ( cl ) ;\n return ;\n }\n rfbStatRecordMessageRcvd ( cl , msg . type , sz_rfbSetPixelFormatMsg , sz_rfbSetPixelFormatMsg ) ;\n rfbLog ( \"rfbProcessClientNormalMessage: %s\" , \"FixColourMapEntries unsupported\\n\" ) ;\n rfbCloseClient ( cl ) ;\n return ;\n case rfbSetEncodings : {\n if ( ( n = rfbReadExact ( cl , ( ( char * ) & msg ) + 1 , sz_rfbSetEncodingsMsg - 1 ) ) <= 0 ) {\n if ( n != 0 ) rfbLogPerror ( \"rfbProcessClientNormalMessage: read\" ) ;\n rfbCloseClient ( cl ) ;\n return ;\n }\n msg . se . nEncodings = Swap16IfLE ( msg . se . nEncodings ) ;\n rfbStatRecordMessageRcvd ( cl , msg . type , sz_rfbSetEncodingsMsg + ( msg . se . nEncodings * 4 ) , sz_rfbSetEncodingsMsg + ( msg . se . nEncodings * 4 ) ) ;\n if ( cl -> preferredEncoding != - 1 ) lastPreferredEncoding = cl -> preferredEncoding ;\n cl -> preferredEncoding = - 1 ;\n cl -> useCopyRect = FALSE ;\n cl -> useNewFBSize = FALSE ;\n cl -> cursorWasChanged = FALSE ;\n cl -> useRichCursorEncoding = FALSE ;\n cl -> enableCursorPosUpdates = FALSE ;\n cl -> enableCursorShapeUpdates = FALSE ;\n cl -> enableCursorShapeUpdates = FALSE ;\n cl -> enableLastRectEncoding = FALSE ;\n cl -> enableKeyboardLedState = FALSE ;\n cl -> enableSupportedMessages = FALSE ;\n cl -> enableSupportedEncodings = FALSE ;\n cl -> enableServerIdentity = FALSE ;\n # if defined ( LIBVNCSERVER_HAVE_LIBZ ) || defined ( LIBVNCSERVER_HAVE_LIBPNG ) cl -> tightQualityLevel = - 1 ;\n # ifdef LIBVNCSERVER_HAVE_LIBJPEG cl -> tightCompressLevel = TIGHT_DEFAULT_COMPRESSION ;\n cl -> turboSubsampLevel = TURBO_DEFAULT_SUBSAMP ;\n cl -> turboQualityLevel = - 1 ;\n # endif # endif for ( i = 0 ;\n i < msg . se . nEncodings ;\n i ++ ) {\n if ( ( n = rfbReadExact ( cl , ( char * ) & enc , 4 ) ) <= 0 ) {\n if ( n != 0 ) rfbLogPerror ( \"rfbProcessClientNormalMessage: read\" ) ;\n rfbCloseClient ( cl ) ;\n return ;\n }\n enc = Swap32IfLE ( enc ) ;\n switch ( enc ) {\n case rfbEncodingCopyRect : cl -> useCopyRect = TRUE ;\n break ;\n case rfbEncodingRaw : case rfbEncodingRRE : case rfbEncodingCoRRE : case rfbEncodingHextile : case rfbEncodingUltra : # ifdef LIBVNCSERVER_HAVE_LIBZ case rfbEncodingZlib : case rfbEncodingZRLE : case rfbEncodingZYWRLE : # ifdef LIBVNCSERVER_HAVE_LIBJPEG case rfbEncodingTight : # endif # endif # ifdef LIBVNCSERVER_HAVE_LIBPNG case rfbEncodingTightPng : # endif if ( cl -> preferredEncoding == - 1 ) cl -> preferredEncoding = enc ;\n break ;\n case rfbEncodingXCursor : if ( ! cl -> screen -> dontConvertRichCursorToXCursor ) {\n rfbLog ( \"Enabling X-style cursor updates for client %s\\n\" , cl -> host ) ;\n if ( ! cl -> enableCursorShapeUpdates ) rfbRedrawAfterHideCursor ( cl , NULL ) ;\n cl -> enableCursorShapeUpdates = TRUE ;\n cl -> cursorWasChanged = TRUE ;\n }\n break ;\n case rfbEncodingRichCursor : rfbLog ( \"Enabling full-color cursor updates for client %s\\n\" , cl -> host ) ;\n if ( ! cl -> enableCursorShapeUpdates ) rfbRedrawAfterHideCursor ( cl , NULL ) ;\n cl -> enableCursorShapeUpdates = TRUE ;\n cl -> useRichCursorEncoding = TRUE ;\n cl -> cursorWasChanged = TRUE ;\n break ;\n case rfbEncodingPointerPos : if ( ! cl -> enableCursorPosUpdates ) {\n rfbLog ( \"Enabling cursor position updates for client %s\\n\" , cl -> host ) ;\n cl -> enableCursorPosUpdates = TRUE ;\n cl -> cursorWasMoved = TRUE ;\n }\n break ;\n case rfbEncodingLastRect : if ( ! cl -> enableLastRectEncoding ) {\n rfbLog ( \"Enabling LastRect protocol extension for client \" \"%s\\n\" , cl -> host ) ;\n cl -> enableLastRectEncoding = TRUE ;\n }\n break ;\n case rfbEncodingNewFBSize : if ( ! cl -> useNewFBSize ) {\n rfbLog ( \"Enabling NewFBSize protocol extension for client \" \"%s\\n\" , cl -> host ) ;\n cl -> useNewFBSize = TRUE ;\n }\n break ;\n case rfbEncodingKeyboardLedState : if ( ! cl -> enableKeyboardLedState ) {\n rfbLog ( \"Enabling KeyboardLedState protocol extension for client \" \"%s\\n\" , cl -> host ) ;\n cl -> enableKeyboardLedState = TRUE ;\n }\n break ;\n case rfbEncodingSupportedMessages : if ( ! cl -> enableSupportedMessages ) {\n rfbLog ( \"Enabling SupportedMessages protocol extension for client \" \"%s\\n\" , cl -> host ) ;\n cl -> enableSupportedMessages = TRUE ;\n }\n break ;\n case rfbEncodingSupportedEncodings : if ( ! cl -> enableSupportedEncodings ) {\n rfbLog ( \"Enabling SupportedEncodings protocol extension for client \" \"%s\\n\" , cl -> host ) ;\n cl -> enableSupportedEncodings = TRUE ;\n }\n break ;\n case rfbEncodingServerIdentity : if ( ! cl -> enableServerIdentity ) {\n rfbLog ( \"Enabling ServerIdentity protocol extension for client \" \"%s\\n\" , cl -> host ) ;\n cl -> enableServerIdentity = TRUE ;\n }\n break ;\n case rfbEncodingXvp : if ( cl -> screen -> xvpHook ) {\n rfbLog ( \"Enabling Xvp protocol extension for client \" \"%s\\n\" , cl -> host ) ;\n if ( ! rfbSendXvp ( cl , 1 , rfbXvp_Init ) ) {\n rfbCloseClient ( cl ) ;\n return ;\n }\n }\n break ;\n default : # if defined ( LIBVNCSERVER_HAVE_LIBZ ) || defined ( LIBVNCSERVER_HAVE_LIBPNG ) if ( enc >= ( uint32_t ) rfbEncodingCompressLevel0 && enc <= ( uint32_t ) rfbEncodingCompressLevel9 ) {\n cl -> zlibCompressLevel = enc & 0x0F ;\n # ifdef LIBVNCSERVER_HAVE_LIBJPEG cl -> tightCompressLevel = enc & 0x0F ;\n rfbLog ( \"Using compression level %d for client %s\\n\" , cl -> tightCompressLevel , cl -> host ) ;\n # endif }\n else if ( enc >= ( uint32_t ) rfbEncodingQualityLevel0 && enc <= ( uint32_t ) rfbEncodingQualityLevel9 ) {\n cl -> tightQualityLevel = enc & 0x0F ;\n rfbLog ( \"Using image quality level %d for client %s\\n\" , cl -> tightQualityLevel , cl -> host ) ;\n # ifdef LIBVNCSERVER_HAVE_LIBJPEG cl -> turboQualityLevel = tight2turbo_qual [ enc & 0x0F ] ;\n cl -> turboSubsampLevel = tight2turbo_subsamp [ enc & 0x0F ] ;\n rfbLog ( \"Using JPEG subsampling %d, Q%d for client %s\\n\" , cl -> turboSubsampLevel , cl -> turboQualityLevel , cl -> host ) ;\n }\n else if ( enc >= ( uint32_t ) rfbEncodingFineQualityLevel0 + 1 && enc <= ( uint32_t ) rfbEncodingFineQualityLevel100 ) {\n cl -> turboQualityLevel = enc & 0xFF ;\n rfbLog ( \"Using fine quality level %d for client %s\\n\" , cl -> turboQualityLevel , cl -> host ) ;\n }\n else if ( enc >= ( uint32_t ) rfbEncodingSubsamp1X && enc <= ( uint32_t ) rfbEncodingSubsampGray ) {\n cl -> turboSubsampLevel = enc & 0xFF ;\n rfbLog ( \"Using subsampling level %d for client %s\\n\" , cl -> turboSubsampLevel , cl -> host ) ;\n # endif }\n else # endif {\n rfbExtensionData * e ;\n for ( e = cl -> extensions ;\n e ;\n ) {\n rfbExtensionData * next = e -> next ;\n if ( e -> extension -> enablePseudoEncoding && e -> extension -> enablePseudoEncoding ( cl , & e -> data , ( int ) enc ) ) break ;\n e = next ;\n }\n if ( e == NULL ) {\n rfbBool handled = FALSE ;\n rfbProtocolExtension * e ;\n for ( e = rfbGetExtensionIterator ( ) ;\n e ;\n ) {\n int * encs = e -> pseudoEncodings ;\n while ( encs && * encs != 0 ) {\n if ( * encs == ( int ) enc ) {\n void * data = NULL ;\n if ( ! e -> enablePseudoEncoding ( cl , & data , ( int ) enc ) ) {\n rfbLog ( \"Installed extension pretends to handle pseudo encoding 0x%x, but does not!\\n\" , ( int ) enc ) ;\n }\n else {\n rfbEnableExtension ( cl , e , data ) ;\n handled = TRUE ;\n e = NULL ;\n break ;\n }\n }\n encs ++ ;\n }\n if ( e ) e = e -> next ;\n }\n rfbReleaseExtensionIterator ( ) ;\n if ( ! handled ) rfbLog ( \"rfbProcessClientNormalMessage: \" \"ignoring unsupported encoding type %s\\n\" , encodingName ( enc , encBuf , sizeof ( encBuf ) ) ) ;\n }\n }\n }\n }\n if ( cl -> preferredEncoding == - 1 ) {\n if ( lastPreferredEncoding == - 1 ) {\n cl -> preferredEncoding = rfbEncodingRaw ;\n rfbLog ( \"Defaulting to %s encoding for client %s\\n\" , encodingName ( cl -> preferredEncoding , encBuf , sizeof ( encBuf ) ) , cl -> host ) ;\n }\n else {\n cl -> preferredEncoding = lastPreferredEncoding ;\n rfbLog ( \"Sticking with %s encoding for client %s\\n\" , encodingName ( cl -> preferredEncoding , encBuf , sizeof ( encBuf ) ) , cl -> host ) ;\n }\n }\n else {\n if ( lastPreferredEncoding == - 1 ) {\n rfbLog ( \"Using %s encoding for client %s\\n\" , encodingName ( cl -> preferredEncoding , encBuf , sizeof ( encBuf ) ) , cl -> host ) ;\n }\n else {\n rfbLog ( \"Switching from %s to %s Encoding for client %s\\n\" , encodingName ( lastPreferredEncoding , encBuf2 , sizeof ( encBuf2 ) ) , encodingName ( cl -> preferredEncoding , encBuf , sizeof ( encBuf ) ) , cl -> host ) ;\n }\n }\n if ( cl -> enableCursorPosUpdates && ! cl -> enableCursorShapeUpdates ) {\n rfbLog ( \"Disabling cursor position updates for client %s\\n\" , cl -> host ) ;\n cl -> enableCursorPosUpdates = FALSE ;\n }\n return ;\n }\n case rfbFramebufferUpdateRequest : {\n sraRegionPtr tmpRegion ;\n if ( ( n = rfbReadExact ( cl , ( ( char * ) & msg ) + 1 , sz_rfbFramebufferUpdateRequestMsg - 1 ) ) <= 0 ) {\n if ( n != 0 ) rfbLogPerror ( \"rfbProcessClientNormalMessage: read\" ) ;\n rfbCloseClient ( cl ) ;\n return ;\n }\n rfbStatRecordMessageRcvd ( cl , msg . type , sz_rfbFramebufferUpdateRequestMsg , sz_rfbFramebufferUpdateRequestMsg ) ;\n if ( ! rectSwapIfLEAndClip ( & msg . fur . x , & msg . fur . y , & msg . fur . w , & msg . fur . h , cl ) ) {\n rfbLog ( \"Warning, ignoring rfbFramebufferUpdateRequest: %dXx%dY-%dWx%dH\\n\" , msg . fur . x , msg . fur . y , msg . fur . w , msg . fur . h ) ;\n return ;\n }\n tmpRegion = sraRgnCreateRect ( msg . fur . x , msg . fur . y , msg . fur . x + msg . fur . w , msg . fur . y + msg . fur . h ) ;\n LOCK ( cl -> updateMutex ) ;\n sraRgnOr ( cl -> requestedRegion , tmpRegion ) ;\n if ( ! cl -> readyForSetColourMapEntries ) {\n cl -> readyForSetColourMapEntries = TRUE ;\n if ( ! cl -> format . trueColour ) {\n if ( ! rfbSetClientColourMap ( cl , 0 , 0 ) ) {\n sraRgnDestroy ( tmpRegion ) ;\n TSIGNAL ( cl -> updateCond ) ;\n UNLOCK ( cl -> updateMutex ) ;\n return ;\n }\n }\n }\n if ( ! msg . fur . incremental ) {\n sraRgnOr ( cl -> modifiedRegion , tmpRegion ) ;\n sraRgnSubtract ( cl -> copyRegion , tmpRegion ) ;\n }\n TSIGNAL ( cl -> updateCond ) ;\n UNLOCK ( cl -> updateMutex ) ;\n sraRgnDestroy ( tmpRegion ) ;\n return ;\n }\n case rfbKeyEvent : if ( ( n = rfbReadExact ( cl , ( ( char * ) & msg ) + 1 , sz_rfbKeyEventMsg - 1 ) ) <= 0 ) {\n if ( n != 0 ) rfbLogPerror ( \"rfbProcessClientNormalMessage: read\" ) ;\n rfbCloseClient ( cl ) ;\n return ;\n }\n rfbStatRecordMessageRcvd ( cl , msg . type , sz_rfbKeyEventMsg , sz_rfbKeyEventMsg ) ;\n if ( ! cl -> viewOnly ) {\n cl -> screen -> kbdAddEvent ( msg . ke . down , ( rfbKeySym ) Swap32IfLE ( msg . ke . key ) , cl ) ;\n }\n return ;\n case rfbPointerEvent : if ( ( n = rfbReadExact ( cl , ( ( char * ) & msg ) + 1 , sz_rfbPointerEventMsg - 1 ) ) <= 0 ) {\n if ( n != 0 ) rfbLogPerror ( \"rfbProcessClientNormalMessage: read\" ) ;\n rfbCloseClient ( cl ) ;\n return ;\n }\n rfbStatRecordMessageRcvd ( cl , msg . type , sz_rfbPointerEventMsg , sz_rfbPointerEventMsg ) ;\n if ( cl -> screen -> pointerClient && cl -> screen -> pointerClient != cl ) return ;\n if ( msg . pe . buttonMask == 0 ) cl -> screen -> pointerClient = NULL ;\n else cl -> screen -> pointerClient = cl ;\n if ( ! cl -> viewOnly ) {\n if ( msg . pe . buttonMask != cl -> lastPtrButtons || cl -> screen -> deferPtrUpdateTime == 0 ) {\n cl -> screen -> ptrAddEvent ( msg . pe . buttonMask , ScaleX ( cl -> scaledScreen , cl -> screen , Swap16IfLE ( msg . pe . x ) ) , ScaleY ( cl -> scaledScreen , cl -> screen , Swap16IfLE ( msg . pe . y ) ) , cl ) ;\n cl -> lastPtrButtons = msg . pe . buttonMask ;\n }\n else {\n cl -> lastPtrX = ScaleX ( cl -> scaledScreen , cl -> screen , Swap16IfLE ( msg . pe . x ) ) ;\n cl -> lastPtrY = ScaleY ( cl -> scaledScreen , cl -> screen , Swap16IfLE ( msg . pe . y ) ) ;\n cl -> lastPtrButtons = msg . pe . buttonMask ;\n }\n }\n return ;\n case rfbFileTransfer : if ( ( n = rfbReadExact ( cl , ( ( char * ) & msg ) + 1 , sz_rfbFileTransferMsg - 1 ) ) <= 0 ) {\n if ( n != 0 ) rfbLogPerror ( \"rfbProcessClientNormalMessage: read\" ) ;\n rfbCloseClient ( cl ) ;\n return ;\n }\n msg . ft . size = Swap32IfLE ( msg . ft . size ) ;\n msg . ft . length = Swap32IfLE ( msg . ft . length ) ;\n rfbProcessFileTransfer ( cl , msg . ft . contentType , msg . ft . contentParam , msg . ft . size , msg . ft . length ) ;\n return ;\n case rfbSetSW : if ( ( n = rfbReadExact ( cl , ( ( char * ) & msg ) + 1 , sz_rfbSetSWMsg - 1 ) ) <= 0 ) {\n if ( n != 0 ) rfbLogPerror ( \"rfbProcessClientNormalMessage: read\" ) ;\n rfbCloseClient ( cl ) ;\n return ;\n }\n msg . sw . x = Swap16IfLE ( msg . sw . x ) ;\n msg . sw . y = Swap16IfLE ( msg . sw . y ) ;\n rfbStatRecordMessageRcvd ( cl , msg . type , sz_rfbSetSWMsg , sz_rfbSetSWMsg ) ;\n rfbLog ( \"Received a rfbSetSingleWindow(%d x, %d y)\\n\" , msg . sw . x , msg . sw . y ) ;\n if ( cl -> screen -> setSingleWindow != NULL ) cl -> screen -> setSingleWindow ( cl , msg . sw . x , msg . sw . y ) ;\n return ;\n case rfbSetServerInput : if ( ( n = rfbReadExact ( cl , ( ( char * ) & msg ) + 1 , sz_rfbSetServerInputMsg - 1 ) ) <= 0 ) {\n if ( n != 0 ) rfbLogPerror ( \"rfbProcessClientNormalMessage: read\" ) ;\n rfbCloseClient ( cl ) ;\n return ;\n }\n rfbStatRecordMessageRcvd ( cl , msg . type , sz_rfbSetServerInputMsg , sz_rfbSetServerInputMsg ) ;\n rfbLog ( \"Received a rfbSetServerInput(%d status)\\n\" , msg . sim . status ) ;\n if ( cl -> screen -> setServerInput != NULL ) cl -> screen -> setServerInput ( cl , msg . sim . status ) ;\n return ;\n case rfbTextChat : if ( ( n = rfbReadExact ( cl , ( ( char * ) & msg ) + 1 , sz_rfbTextChatMsg - 1 ) ) <= 0 ) {\n if ( n != 0 ) rfbLogPerror ( \"rfbProcessClientNormalMessage: read\" ) ;\n rfbCloseClient ( cl ) ;\n return ;\n }\n msg . tc . pad2 = Swap16IfLE ( msg . tc . pad2 ) ;\n msg . tc . length = Swap32IfLE ( msg . tc . length ) ;\n switch ( msg . tc . length ) {\n case rfbTextChatOpen : case rfbTextChatClose : case rfbTextChatFinished : str = NULL ;\n rfbStatRecordMessageRcvd ( cl , msg . type , sz_rfbTextChatMsg , sz_rfbTextChatMsg ) ;\n break ;\n default : if ( ( msg . tc . length > 0 ) && ( msg . tc . length < rfbTextMaxSize ) ) {\n str = ( char * ) malloc ( msg . tc . length ) ;\n if ( str == NULL ) {\n rfbLog ( \"Unable to malloc %d bytes for a TextChat Message\\n\" , msg . tc . length ) ;\n rfbCloseClient ( cl ) ;\n return ;\n }\n if ( ( n = rfbReadExact ( cl , str , msg . tc . length ) ) <= 0 ) {\n if ( n != 0 ) rfbLogPerror ( \"rfbProcessClientNormalMessage: read\" ) ;\n free ( str ) ;\n rfbCloseClient ( cl ) ;\n return ;\n }\n rfbStatRecordMessageRcvd ( cl , msg . type , sz_rfbTextChatMsg + msg . tc . length , sz_rfbTextChatMsg + msg . tc . length ) ;\n }\n else {\n rfbLog ( \"client sent us a Text Message that is too big %d>%d\\n\" , msg . tc . length , rfbTextMaxSize ) ;\n rfbCloseClient ( cl ) ;\n return ;\n }\n }\n if ( cl -> screen -> setTextChat != NULL ) cl -> screen -> setTextChat ( cl , msg . tc . length , str ) ;\n free ( str ) ;\n return ;\n case rfbClientCutText : if ( ( n = rfbReadExact ( cl , ( ( char * ) & msg ) + 1 , sz_rfbClientCutTextMsg - 1 ) ) <= 0 ) {\n if ( n != 0 ) rfbLogPerror ( \"rfbProcessClientNormalMessage: read\" ) ;\n rfbCloseClient ( cl ) ;\n return ;\n }\n msg . cct . length = Swap32IfLE ( msg . cct . length ) ;\n if ( msg . cct . length > 1 << 20 ) {\n rfbLog ( \"rfbClientCutText: too big cut text length requested: %\" PRIu32 \"\\n\" , msg . cct . length ) ;\n rfbCloseClient ( cl ) ;\n return ;\n }\n str = ( char * ) calloc ( msg . cct . length ? msg . cct . length : 1 , 1 ) ;\n if ( str == NULL ) {\n rfbLogPerror ( \"rfbProcessClientNormalMessage: not enough memory\" ) ;\n rfbCloseClient ( cl ) ;\n return ;\n }\n if ( ( n = rfbReadExact ( cl , str , msg . cct . length ) ) <= 0 ) {\n if ( n != 0 ) rfbLogPerror ( \"rfbProcessClientNormalMessage: read\" ) ;\n free ( str ) ;\n rfbCloseClient ( cl ) ;\n return ;\n }\n rfbStatRecordMessageRcvd ( cl , msg . type , sz_rfbClientCutTextMsg + msg . cct . length , sz_rfbClientCutTextMsg + msg . cct . length ) ;\n if ( ! cl -> viewOnly ) {\n cl -> screen -> setXCutText ( str , msg . cct . length , cl ) ;\n }\n free ( str ) ;\n return ;\n case rfbPalmVNCSetScaleFactor : cl -> PalmVNC = TRUE ;\n if ( ( n = rfbReadExact ( cl , ( ( char * ) & msg ) + 1 , sz_rfbSetScaleMsg - 1 ) ) <= 0 ) {\n if ( n != 0 ) rfbLogPerror ( \"rfbProcessClientNormalMessage: read\" ) ;\n rfbCloseClient ( cl ) ;\n return ;\n }\n if ( msg . ssc . scale == 0 ) {\n rfbLogPerror ( \"rfbProcessClientNormalMessage: will not accept a scale factor of zero\" ) ;\n rfbCloseClient ( cl ) ;\n return ;\n }\n rfbStatRecordMessageRcvd ( cl , msg . type , sz_rfbSetScaleMsg , sz_rfbSetScaleMsg ) ;\n rfbLog ( \"rfbSetScale(%d)\\n\" , msg . ssc . scale ) ;\n rfbScalingSetup ( cl , cl -> screen -> width / msg . ssc . scale , cl -> screen -> height / msg . ssc . scale ) ;\n rfbSendNewScaleSize ( cl ) ;\n return ;\n case rfbSetScale : if ( ( n = rfbReadExact ( cl , ( ( char * ) & msg ) + 1 , sz_rfbSetScaleMsg - 1 ) ) <= 0 ) {\n if ( n != 0 ) rfbLogPerror ( \"rfbProcessClientNormalMessage: read\" ) ;\n rfbCloseClient ( cl ) ;\n return ;\n }\n if ( msg . ssc . scale == 0 ) {\n rfbLogPerror ( \"rfbProcessClientNormalMessage: will not accept a scale factor of zero\" ) ;\n rfbCloseClient ( cl ) ;\n return ;\n }\n rfbStatRecordMessageRcvd ( cl , msg . type , sz_rfbSetScaleMsg , sz_rfbSetScaleMsg ) ;\n rfbLog ( \"rfbSetScale(%d)\\n\" , msg . ssc . scale ) ;\n rfbScalingSetup ( cl , cl -> screen -> width / msg . ssc . scale , cl -> screen -> height / msg . ssc . scale ) ;\n rfbSendNewScaleSize ( cl ) ;\n return ;\n case rfbXvp : if ( ( n = rfbReadExact ( cl , ( ( char * ) & msg ) + 1 , sz_rfbXvpMsg - 1 ) ) <= 0 ) {\n if ( n != 0 ) rfbLogPerror ( \"rfbProcessClientNormalMessage: read\" ) ;\n rfbCloseClient ( cl ) ;\n return ;\n }\n rfbStatRecordMessageRcvd ( cl , msg . type , sz_rfbXvpMsg , sz_rfbXvpMsg ) ;\n if ( msg . xvp . version != 1 ) {\n rfbSendXvp ( cl , msg . xvp . version , rfbXvp_Fail ) ;\n }\n else {\n if ( cl -> screen -> xvpHook && ! cl -> screen -> xvpHook ( cl , msg . xvp . version , msg . xvp . code ) ) rfbSendXvp ( cl , 1 , rfbXvp_Fail ) ;\n }\n return ;\n default : {\n rfbExtensionData * e , * next ;\n for ( e = cl -> extensions ;\n e ;\n ) {\n next = e -> next ;\n if ( e -> extension -> handleMessage && e -> extension -> handleMessage ( cl , e -> data , & msg ) ) {\n rfbStatRecordMessageRcvd ( cl , msg . type , 0 , 0 ) ;\n return ;\n }\n e = next ;\n }\n rfbLog ( \"rfbProcessClientNormalMessage: unknown message type %d\\n\" , msg . type ) ;\n rfbLog ( \" ... closing connection\\n\" ) ;\n rfbCloseClient ( cl ) ;\n return ;\n }\n }\n }", "idx": 2164}
{"hash": -7187272991279783781, "project": "debian", "size": 13, "label": 0, "functionSource": "static void * sparc32_dma_init ( hwaddr daddr , qemu_irq parent_irq , void * iommu , qemu_irq * dev_irq , int is_ledma ) {\n DeviceState * dev ;\n SysBusDevice * s ;\n dev = qdev_create ( NULL , \"sparc32_dma\" ) ;\n qdev_prop_set_ptr ( dev , \"iommu_opaque\" , iommu ) ;\n qdev_prop_set_uint32 ( dev , \"is_ledma\" , is_ledma ) ;\n qdev_init_nofail ( dev ) ;\n s = SYS_BUS_DEVICE ( dev ) ;\n sysbus_connect_irq ( s , 0 , parent_irq ) ;\n * dev_irq = qdev_get_gpio_in ( dev , 0 ) ;\n sysbus_mmio_map ( s , 0 , daddr ) ;\n return s ;\n }", "idx": 2165}
{"hash": 5810614390175384347, "project": "debian", "size": 8, "label": 0, "functionSource": "static int tqi_decode_mb ( MpegEncContext * s , int16_t ( * block ) [ 64 ] ) {\n int n ;\n s -> dsp . clear_blocks ( block [ 0 ] ) ;\n for ( n = 0 ;\n n < 6 ;\n n ++ ) if ( ff_mpeg1_decode_block_intra ( s , block [ n ] , n ) < 0 ) return - 1 ;\n return 0 ;\n }", "idx": 2166}
{"hash": 1182028467273264883, "project": "debian", "size": 27, "label": 0, "functionSource": "int parse_args ( int argc , char * * argv ) {\n if ( load_defaults ( \"my\" , load_default_groups , & argc , & argv ) ) exit ( 1 ) ;\n default_argv = argv ;\n if ( ( handle_options ( & argc , & argv , my_long_options , get_one_option ) ) ) exit ( 1 ) ;\n if ( argc > 1 ) {\n usage ( ) ;\n exit ( 1 ) ;\n }\n if ( argc == 1 ) opt_db = * argv ;\n if ( tty_password ) opt_pass = get_tty_password ( NullS ) ;\n if ( debug_info_flag ) my_end_arg = MY_CHECK_ERROR | MY_GIVE_INFO ;\n if ( debug_check_flag ) my_end_arg |= MY_CHECK_ERROR ;\n if ( global_subst != NULL ) {\n char * comma = strstr ( global_subst , \",\" ) ;\n if ( comma == NULL ) die ( \"wrong --global-subst, must be X,Y\" ) ;\n memcpy ( global_subst_from , global_subst , ( comma - global_subst ) ) ;\n global_subst_from [ comma - global_subst ] = 0 ;\n memcpy ( global_subst_to , comma + 1 , strlen ( comma ) ) ;\n }\n if ( ! opt_suite_dir ) opt_suite_dir = \"./\" ;\n suite_dir_len = strlen ( opt_suite_dir ) ;\n overlay_dir_len = opt_overlay_dir ? strlen ( opt_overlay_dir ) : 0 ;\n if ( ! record ) {\n if ( result_file_name && access ( result_file_name , F_OK ) != 0 ) die ( \"The specified result file '%s' does not exist\" , result_file_name ) ;\n }\n return 0 ;\n }", "idx": 2167}
{"hash": 3919646340804521652, "project": "debian", "size": 46, "label": 0, "functionSource": "static struct pbase_tree_cache * pbase_tree_get ( const unsigned char * sha1 ) {\n struct pbase_tree_cache * ent , * nent ;\n void * data ;\n unsigned long size ;\n enum object_type type ;\n int neigh ;\n int my_ix = pbase_tree_cache_ix ( sha1 ) ;\n int available_ix = - 1 ;\n for ( neigh = 0 ;\n neigh < 8 ;\n neigh ++ ) {\n ent = pbase_tree_cache [ my_ix ] ;\n if ( ent && ! hashcmp ( ent -> sha1 , sha1 ) ) {\n ent -> ref ++ ;\n return ent ;\n }\n else if ( ( ( available_ix < 0 ) && ( ! ent || ! ent -> ref ) ) || ( ( 0 <= available_ix ) && ( ! ent && pbase_tree_cache [ available_ix ] ) ) ) available_ix = my_ix ;\n if ( ! ent ) break ;\n my_ix = pbase_tree_cache_ix_incr ( my_ix ) ;\n }\n data = read_sha1_file ( sha1 , & type , & size ) ;\n if ( ! data ) return NULL ;\n if ( type != OBJ_TREE ) {\n free ( data ) ;\n return NULL ;\n }\n if ( available_ix < 0 ) ent = NULL ;\n else {\n ent = pbase_tree_cache [ available_ix ] ;\n my_ix = available_ix ;\n }\n if ( ! ent ) {\n nent = xmalloc ( sizeof ( * nent ) ) ;\n nent -> temporary = ( available_ix < 0 ) ;\n }\n else {\n free ( ent -> tree_data ) ;\n nent = ent ;\n }\n hashcpy ( nent -> sha1 , sha1 ) ;\n nent -> tree_data = data ;\n nent -> tree_size = size ;\n nent -> ref = 1 ;\n if ( ! nent -> temporary ) pbase_tree_cache [ my_ix ] = nent ;\n return nent ;\n }", "idx": 2168}
{"hash": -992498691684812004, "project": "chrome", "size": 6, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( PrefsFunctionalTest , TestHomepagePrefs ) {\n GURL home_page_url ( \"http://www.google.com\" ) ;\n PrefService * prefs = browser ( ) -> profile ( ) -> GetPrefs ( ) ;\n EXPECT_FALSE ( prefs -> GetBoolean ( prefs : : kHomePageIsNewTabPage ) ) ;\n EXPECT_EQ ( home_page_url . spec ( ) , prefs -> GetString ( prefs : : kHomePage ) ) ;\n }", "idx": 2169}
{"hash": -7553540414561818627, "project": "debian", "size": 47, "label": 0, "functionSource": "int test_mod_exp_mont5 ( BIO * bp , BN_CTX * ctx ) {\n BIGNUM * a , * p , * m , * d , * e ;\n BN_MONT_CTX * mont ;\n a = BN_new ( ) ;\n p = BN_new ( ) ;\n m = BN_new ( ) ;\n d = BN_new ( ) ;\n e = BN_new ( ) ;\n mont = BN_MONT_CTX_new ( ) ;\n BN_bntest_rand ( m , 1024 , 0 , 1 ) ;\n BN_bntest_rand ( a , 1024 , 0 , 0 ) ;\n BN_zero ( p ) ;\n if ( ! BN_mod_exp_mont_consttime ( d , a , p , m , ctx , NULL ) ) return 0 ;\n if ( ! BN_is_one ( d ) ) {\n fprintf ( stderr , \"Modular exponentiation test failed!\\n\" ) ;\n return 0 ;\n }\n BN_bntest_rand ( p , 1024 , 0 , 0 ) ;\n BN_zero ( a ) ;\n if ( ! BN_mod_exp_mont_consttime ( d , a , p , m , ctx , NULL ) ) return 0 ;\n if ( ! BN_is_zero ( d ) ) {\n fprintf ( stderr , \"Modular exponentiation test failed!\\n\" ) ;\n return 0 ;\n }\n BN_one ( a ) ;\n BN_MONT_CTX_set ( mont , m , ctx ) ;\n if ( ! BN_from_montgomery ( e , a , mont , ctx ) ) return 0 ;\n if ( ! BN_mod_exp_mont_consttime ( d , e , p , m , ctx , NULL ) ) return 0 ;\n if ( ! BN_mod_exp_simple ( a , e , p , m , ctx ) ) return 0 ;\n if ( BN_cmp ( a , d ) != 0 ) {\n fprintf ( stderr , \"Modular exponentiation test failed!\\n\" ) ;\n return 0 ;\n }\n BN_bntest_rand ( e , 1024 , 0 , 0 ) ;\n if ( ! BN_mod_exp_mont_consttime ( d , e , p , m , ctx , NULL ) ) return 0 ;\n if ( ! BN_mod_exp_simple ( a , e , p , m , ctx ) ) return 0 ;\n if ( BN_cmp ( a , d ) != 0 ) {\n fprintf ( stderr , \"Modular exponentiation test failed!\\n\" ) ;\n return 0 ;\n }\n BN_free ( a ) ;\n BN_free ( p ) ;\n BN_free ( m ) ;\n BN_free ( d ) ;\n BN_free ( e ) ;\n return ( 1 ) ;\n }", "idx": 2170}
{"hash": -192019917869801237, "project": "debian", "size": 32, "label": 0, "functionSource": "static gint64 steamdiscover_dissect_header ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , gint offset , gint bytes_left ) {\n gint len ;\n gint64 value ;\n gint64 msg_type = - 1 ;\n protobuf_desc_t pb = {\n tvb , offset , bytes_left }\n ;\n protobuf_tag_t tag = {\n 0 , 0 , 0 }\n ;\n while ( protobuf_iter_next ( & pb , & tag ) ) {\n switch ( tag . field_number ) {\n case STEAMDISCOVER_FN_HEADER_CLIENTID : STEAMDISCOVER_ENSURE_WIRETYPE ( PROTOBUF_WIRETYPE_VARINT ) ;\n value = get_varint64 ( pb . tvb , pb . offset , pb . bytes_left , & len ) ;\n proto_tree_add_uint64 ( tree , hf_steam_ihs_discovery_header_clientid , pb . tvb , pb . offset , len , ( guint64 ) value ) ;\n break ;\n case STEAMDISCOVER_FN_HEADER_MSGTYPE : STEAMDISCOVER_ENSURE_WIRETYPE ( PROTOBUF_WIRETYPE_VARINT ) ;\n value = get_varint64 ( pb . tvb , pb . offset , pb . bytes_left , & len ) ;\n msg_type = value ;\n proto_tree_add_uint64 ( tree , hf_steam_ihs_discovery_header_msgtype , pb . tvb , pb . offset , len , ( guint64 ) value ) ;\n break ;\n case STEAMDISCOVER_FN_HEADER_INSTANCEID : STEAMDISCOVER_ENSURE_WIRETYPE ( PROTOBUF_WIRETYPE_VARINT ) ;\n value = get_varint64 ( pb . tvb , pb . offset , pb . bytes_left , & len ) ;\n proto_tree_add_uint64 ( tree , hf_steam_ihs_discovery_header_instanceid , pb . tvb , pb . offset , len , ( guint64 ) value ) ;\n break ;\n default : len = protobuf_dissect_unknown_field ( & pb , & tag , pinfo , tree , NULL ) ;\n break ;\n }\n protobuf_seek_forward ( & pb , len ) ;\n }\n return msg_type ;\n }", "idx": 2171}
{"hash": 2335116444795821310, "project": "debian", "size": 12, "label": 0, "functionSource": "static bool config_filter_match_service ( const struct config_filter * mask , const struct config_filter * filter ) {\n if ( mask -> service != NULL ) {\n if ( filter -> service == NULL ) return FALSE ;\n if ( mask -> service [ 0 ] == '!' ) {\n if ( strcmp ( filter -> service , mask -> service + 1 ) == 0 ) return FALSE ;\n }\n else {\n if ( strcmp ( filter -> service , mask -> service ) != 0 ) return FALSE ;\n }\n }\n return TRUE ;\n }", "idx": 2172}
{"hash": -7795592811940874822, "project": "debian", "size": 75, "label": 0, "functionSource": "static gcry_err_code_t pss_encode ( gcry_mpi_t * r_result , unsigned int nbits , int algo , const unsigned char * value , size_t valuelen , int saltlen , const void * random_override , size_t random_override_len ) {\n gcry_err_code_t rc = 0 ;\n gcry_error_t err ;\n size_t hlen ;\n unsigned char * em = NULL ;\n size_t emlen = ( nbits + 7 ) / 8 ;\n unsigned char * h ;\n unsigned char * buf = NULL ;\n size_t buflen ;\n unsigned char * mhash ;\n unsigned char * salt ;\n unsigned char * dbmask ;\n unsigned char * p ;\n size_t n ;\n hlen = gcry_md_get_algo_dlen ( algo ) ;\n gcry_assert ( hlen ) ;\n buflen = 8 + hlen + saltlen + ( emlen - hlen - 1 ) ;\n buf = gcry_malloc ( buflen ) ;\n if ( ! buf ) {\n rc = gpg_err_code_from_syserror ( ) ;\n goto leave ;\n }\n mhash = buf + 8 ;\n salt = mhash + hlen ;\n dbmask = salt + saltlen ;\n if ( valuelen != hlen ) {\n rc = GPG_ERR_INV_LENGTH ;\n goto leave ;\n }\n memcpy ( mhash , value , hlen ) ;\n if ( emlen < hlen + saltlen + 2 ) {\n rc = GPG_ERR_TOO_SHORT ;\n goto leave ;\n }\n em = gcry_malloc ( emlen ) ;\n if ( ! em ) {\n rc = gpg_err_code_from_syserror ( ) ;\n goto leave ;\n }\n h = em + emlen - 1 - hlen ;\n if ( saltlen ) {\n if ( random_override ) {\n if ( random_override_len != saltlen ) {\n rc = GPG_ERR_INV_ARG ;\n goto leave ;\n }\n memcpy ( salt , random_override , saltlen ) ;\n }\n else gcry_randomize ( salt , saltlen , GCRY_STRONG_RANDOM ) ;\n }\n memset ( buf , 0 , 8 ) ;\n gcry_md_hash_buffer ( algo , h , buf , 8 + hlen + saltlen ) ;\n p = em + emlen - 1 - hlen - saltlen - 1 ;\n memset ( em , 0 , p - em ) ;\n * p ++ = 0x01 ;\n memcpy ( p , salt , saltlen ) ;\n mgf1 ( dbmask , emlen - hlen - 1 , h , hlen , algo ) ;\n for ( n = 0 , p = dbmask ;\n n < emlen - hlen - 1 ;\n n ++ , p ++ ) em [ n ] ^= * p ;\n em [ 0 ] &= 0xFF >> ( 8 * emlen - nbits ) ;\n em [ emlen - 1 ] = 0xbc ;\n err = gcry_mpi_scan ( r_result , GCRYMPI_FMT_USG , em , emlen , NULL ) ;\n if ( err ) rc = gcry_err_code ( err ) ;\n else if ( DBG_CIPHER ) log_mpidump ( \"PSS encoded data\" , * r_result ) ;\n leave : if ( em ) {\n wipememory ( em , emlen ) ;\n gcry_free ( em ) ;\n }\n if ( buf ) {\n wipememory ( buf , buflen ) ;\n gcry_free ( buf ) ;\n }\n return rc ;\n }", "idx": 2173}
{"hash": -7237039260294671485, "project": "debian", "size": 42, "label": 0, "functionSource": "static int dissect_nlm_test_res ( tvbuff_t * tvb , int offset , packet_info * pinfo _U_ , proto_tree * tree , int version , rpc_call_info_value * rpc_call ) {\n proto_item * lock_item = NULL ;\n proto_tree * lock_tree = NULL ;\n if ( nlm_match_msgres ) {\n if ( rpc_call -> proc == 11 ) {\n if ( ( ! pinfo -> fd -> flags . visited ) ) {\n nlm_register_unmatched_res ( pinfo , tvb , offset ) ;\n }\n else {\n nlm_print_msgres_reply ( pinfo , tree , tvb ) ;\n }\n if ( nfs_fhandle_reqrep_matching ) {\n nlm_match_fhandle_reply ( pinfo , tree ) ;\n }\n }\n }\n offset = dissect_rpc_data ( tvb , tree , hf_nlm_cookie , offset ) ;\n if ( tree ) {\n lock_item = proto_tree_add_item ( tree , hf_nlm_test_stat , tvb , offset , - 1 , ENC_NA ) ;\n lock_tree = proto_item_add_subtree ( lock_item , ett_nlm_lock ) ;\n }\n offset = dissect_rpc_uint32 ( tvb , lock_tree , hf_nlm_test_stat_stat , offset ) ;\n if ( tvb_reported_length_remaining ( tvb , offset ) == 0 ) {\n return offset ;\n }\n if ( tree ) {\n lock_item = proto_tree_add_item ( lock_tree , hf_nlm_holder , tvb , offset , - 1 , ENC_NA ) ;\n if ( lock_item ) lock_tree = proto_item_add_subtree ( lock_item , ett_nlm_lock ) ;\n }\n offset = dissect_rpc_bool ( tvb , lock_tree , hf_nlm_exclusive , offset ) ;\n offset = dissect_rpc_uint32 ( tvb , lock_tree , hf_nlm_lock_svid , offset ) ;\n offset = dissect_rpc_data ( tvb , lock_tree , hf_nlm_lock_owner , offset ) ;\n if ( version == 4 ) {\n offset = dissect_rpc_uint64 ( tvb , lock_tree , hf_nlm_lock_l_offset64 , offset ) ;\n offset = dissect_rpc_uint64 ( tvb , lock_tree , hf_nlm_lock_l_len64 , offset ) ;\n }\n else {\n offset = dissect_rpc_uint32 ( tvb , lock_tree , hf_nlm_lock_l_offset , offset ) ;\n offset = dissect_rpc_uint32 ( tvb , lock_tree , hf_nlm_lock_l_len , offset ) ;\n }\n return offset ;\n }", "idx": 2174}
{"hash": -6870389834356302891, "project": "debian", "size": 55, "label": 0, "functionSource": "static int rv10_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n MpegEncContext * s = avctx -> priv_data ;\n int i , ret ;\n AVFrame * pict = data ;\n int slice_count ;\n const uint8_t * slices_hdr = NULL ;\n av_dlog ( avctx , \"*****frame %d size=%d\\n\" , avctx -> frame_number , buf_size ) ;\n if ( buf_size == 0 ) {\n return 0 ;\n }\n if ( ! avctx -> slice_count ) {\n slice_count = ( * buf ++ ) + 1 ;\n buf_size -- ;\n if ( ! slice_count || buf_size <= 8 * slice_count ) {\n av_log ( avctx , AV_LOG_ERROR , \"Invalid slice count: %d.\\n\" , slice_count ) ;\n return AVERROR_INVALIDDATA ;\n }\n slices_hdr = buf + 4 ;\n buf += 8 * slice_count ;\n buf_size -= 8 * slice_count ;\n }\n else slice_count = avctx -> slice_count ;\n for ( i = 0 ;\n i < slice_count ;\n i ++ ) {\n unsigned offset = get_slice_offset ( avctx , slices_hdr , i ) ;\n int size , size2 ;\n if ( offset >= buf_size ) return AVERROR_INVALIDDATA ;\n if ( i + 1 == slice_count ) size = buf_size - offset ;\n else size = get_slice_offset ( avctx , slices_hdr , i + 1 ) - offset ;\n if ( i + 2 >= slice_count ) size2 = buf_size - offset ;\n else size2 = get_slice_offset ( avctx , slices_hdr , i + 2 ) - offset ;\n if ( size <= 0 || size2 <= 0 || offset + FFMAX ( size , size2 ) > buf_size ) return AVERROR_INVALIDDATA ;\n if ( rv10_decode_packet ( avctx , buf + offset , size , size2 ) > 8 * size ) i ++ ;\n }\n if ( s -> current_picture_ptr != NULL && s -> mb_y >= s -> mb_height ) {\n ff_er_frame_end ( & s -> er ) ;\n ff_MPV_frame_end ( s ) ;\n if ( s -> pict_type == AV_PICTURE_TYPE_B || s -> low_delay ) {\n if ( ( ret = av_frame_ref ( pict , & s -> current_picture_ptr -> f ) ) < 0 ) return ret ;\n ff_print_debug_info ( s , s -> current_picture_ptr ) ;\n }\n else if ( s -> last_picture_ptr != NULL ) {\n if ( ( ret = av_frame_ref ( pict , & s -> last_picture_ptr -> f ) ) < 0 ) return ret ;\n ff_print_debug_info ( s , s -> last_picture_ptr ) ;\n }\n if ( s -> last_picture_ptr || s -> low_delay ) {\n * got_frame = 1 ;\n }\n s -> current_picture_ptr = NULL ;\n }\n return avpkt -> size ;\n }", "idx": 2175}
{"hash": 1182028467273264883, "project": "debian", "size": 24, "label": 0, "functionSource": "int cat_file ( DYNAMIC_STRING * ds , const char * filename ) {\n int fd ;\n size_t len ;\n char buff [ 16384 ] ;\n if ( ( fd = my_open ( filename , O_RDONLY , MYF ( 0 ) ) ) < 0 ) return 1 ;\n while ( ( len = my_read ( fd , ( uchar * ) & buff , sizeof ( buff ) - 1 , MYF ( 0 ) ) ) > 0 ) {\n char * p = buff , * start = buff ;\n while ( p < buff + len ) {\n if ( * p == '\\r' && * ( p + 1 ) && * ( p + 1 ) == '\\n' ) {\n * p = '\\n' ;\n p ++ ;\n * p = 0 ;\n replace_dynstr_append_mem ( ds , start , p - start ) ;\n p ++ ;\n start = p ;\n }\n else p ++ ;\n }\n * p = 0 ;\n replace_dynstr_append_mem ( ds , start , p - start ) ;\n }\n my_close ( fd , MYF ( 0 ) ) ;\n return 0 ;\n }", "idx": 2176}
{"hash": -8721757784652752372, "project": "debian", "size": 42, "label": 0, "functionSource": "int jpc_encode ( jas_image_t * image , jas_stream_t * out , const char * optstr ) {\n jpc_enc_t * enc ;\n jpc_enc_cp_t * cp ;\n enc = 0 ;\n cp = 0 ;\n jpc_initluts ( ) ;\n if ( ! ( cp = cp_create ( optstr , image ) ) ) {\n jas_eprintf ( \"invalid JP encoder options\\n\" ) ;\n goto error ;\n }\n if ( ! ( enc = jpc_enc_create ( cp , out , image ) ) ) {\n goto error ;\n }\n cp = 0 ;\n if ( jpc_enc_encodemainhdr ( enc ) ) {\n goto error ;\n }\n if ( jpc_enc_encodemainbody ( enc ) ) {\n goto error ;\n }\n if ( ! ( enc -> mrk = jpc_ms_create ( JPC_MS_EOC ) ) ) {\n goto error ;\n }\n if ( jpc_putms ( enc -> out , enc -> cstate , enc -> mrk ) ) {\n jas_eprintf ( \"cannot write EOI marker\\n\" ) ;\n goto error ;\n }\n jpc_ms_destroy ( enc -> mrk ) ;\n enc -> mrk = 0 ;\n if ( jas_stream_flush ( enc -> out ) ) {\n goto error ;\n }\n jpc_enc_destroy ( enc ) ;\n return 0 ;\n error : if ( cp ) {\n jpc_enc_cp_destroy ( cp ) ;\n }\n if ( enc ) {\n jpc_enc_destroy ( enc ) ;\n }\n return - 1 ;\n }", "idx": 2177}
{"hash": -2607754285145856562, "project": "debian", "size": 22, "label": 0, "functionSource": "static int write_file_contents ( struct archive_write * a , int64_t offset , int64_t size ) {\n struct iso9660 * iso9660 = a -> format_data ;\n int r ;\n lseek ( iso9660 -> temp_fd , offset , SEEK_SET ) ;\n while ( size ) {\n size_t rsize ;\n ssize_t rs ;\n unsigned char * wb ;\n wb = wb_buffptr ( a ) ;\n rsize = wb_remaining ( a ) ;\n if ( rsize > ( size_t ) size ) rsize = ( size_t ) size ;\n rs = read ( iso9660 -> temp_fd , wb , rsize ) ;\n if ( rs <= 0 ) {\n archive_set_error ( & a -> archive , errno , \"Can't read temporary file(%jd)\" , ( intmax_t ) rs ) ;\n return ( ARCHIVE_FATAL ) ;\n }\n size -= rs ;\n r = wb_consume ( a , rs ) ;\n if ( r < 0 ) return ( r ) ;\n }\n return ( ARCHIVE_OK ) ;\n }", "idx": 2178}
{"hash": 1366214969540455677, "project": "debian", "size": 41, "label": 1, "functionSource": "int i2d_ ## name ( const type * a , unsigned char * * out ) ;\n DECLARE_ASN1_ITEM ( name ) # define DECLARE_ASN1_NDEF_FUNCTION ( name ) int i2d_ ## name ## _NDEF ( name * a , unsigned char * * out ) ;\n # define DECLARE_ASN1_FUNCTIONS_const ( name ) DECLARE_ASN1_ALLOC_FUNCTIONS ( name ) DECLARE_ASN1_ENCODE_FUNCTIONS_const ( name , name ) # define DECLARE_ASN1_ALLOC_FUNCTIONS_name ( type , name ) type * name ## _new ( void ) ;\n void name ## _free ( type * a ) ;\n # define DECLARE_ASN1_PRINT_FUNCTION ( stname ) DECLARE_ASN1_PRINT_FUNCTION_fname ( stname , stname ) # define DECLARE_ASN1_PRINT_FUNCTION_fname ( stname , fname ) int fname ## _print_ctx ( BIO * out , stname * x , int indent , const ASN1_PCTX * pctx ) ;\n # define D2I_OF ( type ) type * ( * ) ( type * * , const unsigned char * * , long ) # define I2D_OF ( type ) int ( * ) ( type * , unsigned char * * ) # define I2D_OF_const ( type ) int ( * ) ( const type * , unsigned char * * ) # define CHECKED_D2I_OF ( type , d2i ) ( ( d2i_of_void * ) ( 1 ? d2i : ( ( D2I_OF ( type ) ) 0 ) ) ) # define CHECKED_I2D_OF ( type , i2d ) ( ( i2d_of_void * ) ( 1 ? i2d : ( ( I2D_OF ( type ) ) 0 ) ) ) # define CHECKED_NEW_OF ( type , xnew ) ( ( void * ( * ) ( void ) ) ( 1 ? xnew : ( ( type * ( * ) ( void ) ) 0 ) ) ) # define CHECKED_PTR_OF ( type , p ) ( ( void * ) ( 1 ? p : ( type * ) 0 ) ) # define CHECKED_PPTR_OF ( type , p ) ( ( void * * ) ( 1 ? p : ( type * * ) 0 ) ) # define TYPEDEF_D2I_OF ( type ) typedef type * d2i_of_ ## type ( type * * , const unsigned char * * , long ) # define TYPEDEF_I2D_OF ( type ) typedef int i2d_of_ ## type ( type * , unsigned char * * ) # define TYPEDEF_D2I2D_OF ( type ) TYPEDEF_D2I_OF ( type ) ;\n TYPEDEF_I2D_OF ( type ) TYPEDEF_D2I2D_OF ( void ) ;\n # ifndef OPENSSL_EXPORT_VAR_AS_FUNCTION typedef const ASN1_ITEM ASN1_ITEM_EXP ;\n # define ASN1_ITEM_ptr ( iptr ) ( iptr ) # define ASN1_ITEM_ref ( iptr ) ( & ( iptr ## _it ) ) # define ASN1_ITEM_rptr ( ref ) ( & ( ref ## _it ) ) # define DECLARE_ASN1_ITEM ( name ) OPENSSL_EXTERN const ASN1_ITEM name ## _it ;\n # else typedef const ASN1_ITEM * ASN1_ITEM_EXP ( void ) ;\n # define ASN1_ITEM_ptr ( iptr ) ( iptr ( ) ) # define ASN1_ITEM_ref ( iptr ) ( iptr ## _it ) # define ASN1_ITEM_rptr ( ref ) ( ref ## _it ( ) ) # define DECLARE_ASN1_ITEM ( name ) const ASN1_ITEM * name ## _it ( void ) ;\n # endif # define ASN1_STRFLGS_ESC_2253 1 # define ASN1_STRFLGS_ESC_CTRL 2 # define ASN1_STRFLGS_ESC_MSB 4 # define ASN1_STRFLGS_ESC_QUOTE 8 # define CHARTYPE_PRINTABLESTRING 0x10 # define CHARTYPE_FIRST_ESC_2253 0x20 # define CHARTYPE_LAST_ESC_2253 0x40 # define ASN1_STRFLGS_UTF8_CONVERT 0x10 # define ASN1_STRFLGS_IGNORE_TYPE 0x20 # define ASN1_STRFLGS_SHOW_TYPE 0x40 # define ASN1_STRFLGS_DUMP_ALL 0x80 # define ASN1_STRFLGS_DUMP_UNKNOWN 0x100 # define ASN1_STRFLGS_DUMP_DER 0x200 # define ASN1_STRFLGS_ESC_2254 0x400 # define ASN1_STRFLGS_RFC2253 ( ASN1_STRFLGS_ESC_2253 | ASN1_STRFLGS_ESC_CTRL | ASN1_STRFLGS_ESC_MSB | ASN1_STRFLGS_UTF8_CONVERT | ASN1_STRFLGS_DUMP_UNKNOWN | ASN1_STRFLGS_DUMP_DER ) DEFINE_STACK_OF ( ASN1_INTEGER ) DEFINE_STACK_OF ( ASN1_GENERALSTRING ) DEFINE_STACK_OF ( ASN1_UTF8STRING ) typedef struct asn1_type_st {\n int type ;\n union {\n char * ptr ;\n ASN1_BOOLEAN boolean ;\n ASN1_STRING * asn1_string ;\n ASN1_OBJECT * object ;\n ASN1_INTEGER * integer ;\n ASN1_ENUMERATED * enumerated ;\n ASN1_BIT_STRING * bit_string ;\n ASN1_OCTET_STRING * octet_string ;\n ASN1_PRINTABLESTRING * printablestring ;\n ASN1_T61STRING * t61string ;\n ASN1_IA5STRING * ia5string ;\n ASN1_GENERALSTRING * generalstring ;\n ASN1_BMPSTRING * bmpstring ;\n ASN1_UNIVERSALSTRING * universalstring ;\n ASN1_UTCTIME * utctime ;\n ASN1_GENERALIZEDTIME * generalizedtime ;\n ASN1_VISIBLESTRING * visiblestring ;\n ASN1_UTF8STRING * utf8string ;\n ASN1_STRING * set ;\n ASN1_STRING * sequence ;\n ASN1_VALUE * asn1_value ;\n }\n value ;\n }\n ASN1_TYPE ;\n DEFINE_STACK_OF ( ASN1_TYPE ) typedef STACK_OF ( ASN1_TYPE ) ASN1_SEQUENCE_ANY ;\n DECLARE_ASN1_ENCODE_FUNCTIONS_const ( ASN1_SEQUENCE_ANY , ASN1_SEQUENCE_ANY )", "idx": 2179}
{"hash": 4496746249504396521, "project": "debian", "size": 11, "label": 0, "functionSource": "const char * symbname ( u_short token ) {\n char * name ;\n if ( token < COUNTOF ( symb ) && symb [ token ] != NULL ) {\n name = symb [ token ] ;\n }\n else {\n LIB_GETBUF ( name ) ;\n snprintf ( name , LIB_BUFLENGTH , \"%d\" , token ) ;\n }\n return name ;\n }", "idx": 2180}
{"hash": 1245821301839614810, "project": "debian", "size": 28, "label": 0, "functionSource": "void nautilus_file_operations_duplicate ( GList * files , GArray * relative_item_points , GtkWindow * parent_window , NautilusCopyCallback done_callback , gpointer done_callback_data ) {\n GTask * task ;\n CopyMoveJob * job ;\n GFile * parent ;\n job = op_job_new ( CopyMoveJob , parent_window ) ;\n job -> done_callback = done_callback ;\n job -> done_callback_data = done_callback_data ;\n job -> files = g_list_copy_deep ( files , ( GCopyFunc ) g_object_ref , NULL ) ;\n job -> destination = NULL ;\n parent = g_file_get_parent ( files -> data ) ;\n nautilus_progress_info_set_destination ( ( ( CommonJob * ) job ) -> progress , parent ) ;\n if ( relative_item_points != NULL && relative_item_points -> len > 0 ) {\n job -> icon_positions = g_memdup ( relative_item_points -> data , sizeof ( GdkPoint ) * relative_item_points -> len ) ;\n job -> n_icon_positions = relative_item_points -> len ;\n }\n job -> debuting_files = g_hash_table_new_full ( g_file_hash , ( GEqualFunc ) g_file_equal , g_object_unref , NULL ) ;\n if ( ! nautilus_file_undo_manager_is_operating ( ) ) {\n GFile * src_dir ;\n src_dir = g_file_get_parent ( files -> data ) ;\n job -> common . undo_info = nautilus_file_undo_info_ext_new ( NAUTILUS_FILE_UNDO_OP_DUPLICATE , g_list_length ( files ) , src_dir , src_dir ) ;\n g_object_unref ( src_dir ) ;\n }\n task = g_task_new ( NULL , job -> common . cancellable , copy_task_done , job ) ;\n g_task_set_task_data ( task , job , NULL ) ;\n g_task_run_in_thread ( task , copy_task_thread_func ) ;\n g_object_unref ( task ) ;\n g_object_unref ( parent ) ;\n }", "idx": 2181}
{"hash": 5498422609764865307, "project": "debian", "size": 24, "label": 0, "functionSource": "static ssize_t compress_filter_read ( struct archive_read_filter * self , const void * * pblock ) {\n struct private_data * state ;\n unsigned char * p , * start , * end ;\n int ret ;\n state = ( struct private_data * ) self -> data ;\n if ( state -> end_of_stream ) {\n * pblock = NULL ;\n return ( 0 ) ;\n }\n p = start = ( unsigned char * ) state -> out_block ;\n end = start + state -> out_block_size ;\n while ( p < end && ! state -> end_of_stream ) {\n if ( state -> stackp > state -> stack ) {\n * p ++ = * -- state -> stackp ;\n }\n else {\n ret = next_code ( self ) ;\n if ( ret == - 1 ) state -> end_of_stream = ret ;\n else if ( ret != ARCHIVE_OK ) return ( ret ) ;\n }\n }\n * pblock = start ;\n return ( p - start ) ;\n }", "idx": 2182}
{"hash": 3584320764213684062, "project": "debian", "size": 47, "label": 0, "functionSource": "static int parse_RowsBufferCol ( tvbuff_t * tvb , packet_info * pinfo , int offset , guint32 row , guint32 col , struct CPMSetBindingsIn * bindingsin , struct rows_data * rowsin , gboolean b_is_64bit , proto_tree * parent_tree , const char * fmt , ... ) {\n proto_tree * tree ;\n proto_item * item ;\n guint32 buf_start = offset ;\n guint32 buf_offset = buf_start + ( row * bindingsin -> brow ) ;\n struct CTableColumn * pcol = & bindingsin -> acolumns [ col ] ;\n static const value_string STATUS [ ] = {\n {\n 0 , \"StoreStatusOk\" }\n , {\n 1 , \"StoreStatusDeferred\" }\n , {\n 2 , \"StoreStatusNull\" }\n , {\n 0 , NULL }\n }\n ;\n const char * txt ;\n va_list ap ;\n va_start ( ap , fmt ) ;\n txt = wmem_strdup_vprintf ( wmem_packet_scope ( ) , fmt , ap ) ;\n va_end ( ap ) ;\n tree = proto_tree_add_subtree ( parent_tree , tvb , offset , 0 , ett_GetRowsColumn , & item , txt ) ;\n proto_item_append_text ( item , \" (%s)\" , pcol -> name ) ;\n if ( pcol -> statusused ) {\n int tmp_offset = buf_offset + pcol -> statusoffset ;\n proto_tree_add_string ( tree , hf_mswsp_ctablecolumn_status , tvb , tmp_offset , 1 , val_to_str ( tvb_get_guint8 ( tvb , tmp_offset ) , STATUS , \"(Invalid: 0x%x)\" ) ) ;\n }\n if ( pcol -> lengthused ) {\n int tmp_offset = buf_offset + pcol -> lengthoffset ;\n proto_tree_add_item ( tree , hf_mswsp_ctablecolumn_length , tvb , tmp_offset , 1 , ENC_LITTLE_ENDIAN ) ;\n }\n if ( pcol -> valueused ) {\n int tmp_offset = buf_offset + pcol -> valueoffset ;\n struct CRowVariant variant ;\n guint32 len = pcol -> valuesize ;\n guint64 base_address = rowsin -> ulclientbase ;\n ZERO_STRUCT ( variant ) ;\n if ( pcol -> lengthused ) {\n len = tvb_get_letohs ( tvb , buf_offset + pcol -> lengthoffset ) - pcol -> valuesize ;\n }\n if ( pcol -> vtype == VT_VARIANT ) {\n parse_VariantCol ( tvb , pinfo , tmp_offset , tree , base_address , len , b_is_64bit , & variant , \"CRowVariant\" ) ;\n }\n }\n return offset ;\n }", "idx": 2183}
{"hash": -1672864273235910388, "project": "debian", "size": 59, "label": 0, "functionSource": "static void _slurm_rpc_composite_msg ( slurm_msg_t * msg ) {\n static time_t config_update = 0 ;\n static bool defer_sched = false ;\n static int sched_timeout = 0 ;\n static int active_rpc_cnt = 0 ;\n struct timeval start_tv ;\n bool run_scheduler = false ;\n composite_msg_t * comp_msg , comp_resp_msg ;\n slurmctld_lock_t job_write_lock = {\n READ_LOCK , WRITE_LOCK , WRITE_LOCK , NO_LOCK , READ_LOCK }\n ;\n memset ( & comp_resp_msg , 0 , sizeof ( composite_msg_t ) ) ;\n comp_resp_msg . msg_list = list_create ( _slurmctld_free_comp_msg_list ) ;\n comp_msg = ( composite_msg_t * ) msg -> data ;\n if ( slurmctld_conf . debug_flags & DEBUG_FLAG_ROUTE ) info ( \"Processing RPC: MESSAGE_COMPOSITE msg with %d messages\" , comp_msg -> msg_list ? list_count ( comp_msg -> msg_list ) : 0 ) ;\n if ( config_update != slurmctld_conf . last_update ) {\n char * sched_params = slurm_get_sched_params ( ) ;\n int time_limit ;\n char * tmp_ptr ;\n defer_sched = ( sched_params && strstr ( sched_params , \"defer\" ) ) ;\n time_limit = slurm_get_msg_timeout ( ) / 2 ;\n if ( sched_params && ( tmp_ptr = strstr ( sched_params , \"max_sched_time=\" ) ) ) {\n sched_timeout = atoi ( tmp_ptr + 15 ) ;\n if ( ( sched_timeout <= 0 ) || ( sched_timeout > time_limit ) ) {\n error ( \"Invalid max_sched_time: %d\" , sched_timeout ) ;\n sched_timeout = 0 ;\n }\n }\n if ( sched_timeout == 0 ) {\n sched_timeout = MAX ( time_limit , 1 ) ;\n sched_timeout = MIN ( sched_timeout , 2 ) ;\n sched_timeout *= 1000000 ;\n }\n xfree ( sched_params ) ;\n config_update = slurmctld_conf . last_update ;\n }\n _throttle_start ( & active_rpc_cnt ) ;\n lock_slurmctld ( job_write_lock ) ;\n gettimeofday ( & start_tv , NULL ) ;\n _slurm_rpc_comp_msg_list ( comp_msg , & run_scheduler , comp_resp_msg . msg_list , & start_tv , sched_timeout ) ;\n unlock_slurmctld ( job_write_lock ) ;\n _throttle_fini ( & active_rpc_cnt ) ;\n if ( list_count ( comp_resp_msg . msg_list ) ) {\n slurm_msg_t resp_msg ;\n slurm_msg_t_init ( & resp_msg ) ;\n resp_msg . flags = msg -> flags ;\n resp_msg . protocol_version = msg -> protocol_version ;\n memcpy ( & resp_msg . address , & comp_msg -> sender , sizeof ( slurm_addr_t ) ) ;\n resp_msg . msg_type = RESPONSE_MESSAGE_COMPOSITE ;\n resp_msg . data = & comp_resp_msg ;\n slurm_send_only_node_msg ( & resp_msg ) ;\n }\n FREE_NULL_LIST ( comp_resp_msg . msg_list ) ;\n if ( run_scheduler ) {\n if ( ! LOTS_OF_AGENTS && ! defer_sched ) ( void ) schedule ( 0 ) ;\n schedule_node_save ( ) ;\n schedule_job_save ( ) ;\n }\n }", "idx": 2184}
{"hash": 2388171415474875762, "project": "debian", "size": 5, "label": 0, "functionSource": "static void dissect_rsvp_policy ( proto_item * ti _U_ , proto_tree * rsvp_object_tree , tvbuff_t * tvb , int offset , int obj_length , int rsvp_class _U_ , int type ) {\n int offset2 = offset + 4 ;\n proto_tree_add_uint ( rsvp_object_tree , hf_rsvp_ctype , tvb , offset + 3 , 1 , type ) ;\n proto_tree_add_item ( rsvp_object_tree , hf_rsvp_policy_data , tvb , offset2 , obj_length - 4 , ENC_NA ) ;\n }", "idx": 2185}
{"hash": 378220832151730865, "project": "debian", "size": 3, "label": 0, "functionSource": "int qemuMonitorTextCommandWithFd ( qemuMonitorPtr mon , const char * cmd , int scm_fd , char * * reply ) {\n return qemuMonitorTextCommandWithHandler ( mon , cmd , NULL , NULL , scm_fd , reply ) ;\n }", "idx": 2186}
{"hash": 8672904772426696383, "project": "debian", "size": 74, "label": 0, "functionSource": "int ff_mpeg4_decode_picture_header ( MpegEncContext * s , GetBitContext * gb ) {\n unsigned startcode , v ;\n align_get_bits ( gb ) ;\n if ( s -> codec_tag == AV_RL32 ( \"WV1F\" ) && show_bits ( gb , 24 ) == 0x575630 ) {\n skip_bits ( gb , 24 ) ;\n if ( get_bits ( gb , 8 ) == 0xF0 ) goto end ;\n }\n startcode = 0xff ;\n for ( ;\n ;\n ) {\n if ( get_bits_count ( gb ) >= gb -> size_in_bits ) {\n if ( gb -> size_in_bits == 8 && ( s -> divx_version >= 0 || s -> xvid_build >= 0 ) ) {\n av_log ( s -> avctx , AV_LOG_WARNING , \"frame skip %d\\n\" , gb -> size_in_bits ) ;\n return FRAME_SKIPPED ;\n }\n else return - 1 ;\n }\n v = get_bits ( gb , 8 ) ;\n startcode = ( ( startcode << 8 ) | v ) & 0xffffffff ;\n if ( ( startcode & 0xFFFFFF00 ) != 0x100 ) continue ;\n / o startcode if ( s -> avctx -> debug & FF_DEBUG_STARTCODE ) {\n av_log ( s -> avctx , AV_LOG_DEBUG , \"startcode: %3X \" , startcode ) ;\n if ( startcode <= 0x11F ) av_log ( s -> avctx , AV_LOG_DEBUG , \"Video Object Start\" ) ;\n else if ( startcode <= 0x12F ) av_log ( s -> avctx , AV_LOG_DEBUG , \"Video Object Layer Start\" ) ;\n else if ( startcode <= 0x13F ) av_log ( s -> avctx , AV_LOG_DEBUG , \"Reserved\" ) ;\n else if ( startcode <= 0x15F ) av_log ( s -> avctx , AV_LOG_DEBUG , \"FGS bp start\" ) ;\n else if ( startcode <= 0x1AF ) av_log ( s -> avctx , AV_LOG_DEBUG , \"Reserved\" ) ;\n else if ( startcode == 0x1B0 ) av_log ( s -> avctx , AV_LOG_DEBUG , \"Visual Object Seq Start\" ) ;\n else if ( startcode == 0x1B1 ) av_log ( s -> avctx , AV_LOG_DEBUG , \"Visual Object Seq End\" ) ;\n else if ( startcode == 0x1B2 ) av_log ( s -> avctx , AV_LOG_DEBUG , \"User Data\" ) ;\n else if ( startcode == 0x1B3 ) av_log ( s -> avctx , AV_LOG_DEBUG , \"Group of VOP start\" ) ;\n else if ( startcode == 0x1B4 ) av_log ( s -> avctx , AV_LOG_DEBUG , \"Video Session Error\" ) ;\n else if ( startcode == 0x1B5 ) av_log ( s -> avctx , AV_LOG_DEBUG , \"Visual Object Start\" ) ;\n else if ( startcode == 0x1B6 ) av_log ( s -> avctx , AV_LOG_DEBUG , \"Video Object Plane start\" ) ;\n else if ( startcode == 0x1B7 ) av_log ( s -> avctx , AV_LOG_DEBUG , \"slice start\" ) ;\n else if ( startcode == 0x1B8 ) av_log ( s -> avctx , AV_LOG_DEBUG , \"extension start\" ) ;\n else if ( startcode == 0x1B9 ) av_log ( s -> avctx , AV_LOG_DEBUG , \"fgs start\" ) ;\n else if ( startcode == 0x1BA ) av_log ( s -> avctx , AV_LOG_DEBUG , \"FBA Object start\" ) ;\n else if ( startcode == 0x1BB ) av_log ( s -> avctx , AV_LOG_DEBUG , \"FBA Object Plane start\" ) ;\n else if ( startcode == 0x1BC ) av_log ( s -> avctx , AV_LOG_DEBUG , \"Mesh Object start\" ) ;\n else if ( startcode == 0x1BD ) av_log ( s -> avctx , AV_LOG_DEBUG , \"Mesh Object Plane start\" ) ;\n else if ( startcode == 0x1BE ) av_log ( s -> avctx , AV_LOG_DEBUG , \"Still Texture Object start\" ) ;\n else if ( startcode == 0x1BF ) av_log ( s -> avctx , AV_LOG_DEBUG , \"Texture Spatial Layer start\" ) ;\n else if ( startcode == 0x1C0 ) av_log ( s -> avctx , AV_LOG_DEBUG , \"Texture SNR Layer start\" ) ;\n else if ( startcode == 0x1C1 ) av_log ( s -> avctx , AV_LOG_DEBUG , \"Texture Tile start\" ) ;\n else if ( startcode == 0x1C2 ) av_log ( s -> avctx , AV_LOG_DEBUG , \"Texture Shape Layer start\" ) ;\n else if ( startcode == 0x1C3 ) av_log ( s -> avctx , AV_LOG_DEBUG , \"stuffing start\" ) ;\n else if ( startcode <= 0x1C5 ) av_log ( s -> avctx , AV_LOG_DEBUG , \"reserved\" ) ;\n else if ( startcode <= 0x1FF ) av_log ( s -> avctx , AV_LOG_DEBUG , \"System start\" ) ;\n av_log ( s -> avctx , AV_LOG_DEBUG , \" at %d\\n\" , get_bits_count ( gb ) ) ;\n }\n if ( startcode >= 0x120 && startcode <= 0x12F ) {\n if ( decode_vol_header ( s , gb ) < 0 ) return - 1 ;\n }\n else if ( startcode == USER_DATA_STARTCODE ) {\n decode_user_data ( s , gb ) ;\n }\n else if ( startcode == GOP_STARTCODE ) {\n mpeg4_decode_gop_header ( s , gb ) ;\n }\n else if ( startcode == VOS_STARTCODE ) {\n mpeg4_decode_profile_level ( s , gb ) ;\n }\n else if ( startcode == VOP_STARTCODE ) {\n break ;\n }\n align_get_bits ( gb ) ;\n startcode = 0xff ;\n }\n end : if ( s -> flags & CODEC_FLAG_LOW_DELAY ) s -> low_delay = 1 ;\n s -> avctx -> has_b_frames = ! s -> low_delay ;\n return decode_vop_header ( s , gb ) ;\n }", "idx": 2187}
{"hash": 1760449185745615462, "project": "debian", "size": 5, "label": 0, "functionSource": "int64_t TSHttpTxnClientRespBodyBytesGet ( TSHttpTxn txnp ) {\n sdk_assert ( sdk_sanity_check_txn ( txnp ) == TS_SUCCESS ) ;\n HttpSM * sm = ( HttpSM * ) txnp ;\n return sm -> client_response_body_bytes ;\n }", "idx": 2188}
{"hash": 4489017523191997023, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h225_SEQUENCE_OF_CallsAvailable ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence_of ( tvb , offset , actx , tree , hf_index , ett_h225_SEQUENCE_OF_CallsAvailable , SEQUENCE_OF_CallsAvailable_sequence_of ) ;\n return offset ;\n }", "idx": 2189}
{"hash": -7555034601056330007, "project": "debian", "size": 9, "label": 0, "functionSource": "VIR_ONCE_GLOBAL_INIT ( virLog ) int virLogReset ( void ) {\n if ( virLogInitialize ( ) < 0 ) return - 1 ;\n virLogLock ( ) ;\n virLogResetFilters ( ) ;\n virLogResetOutputs ( ) ;\n virLogDefaultPriority = VIR_LOG_DEFAULT ;\n virLogUnlock ( ) ;\n return 0 ;\n }", "idx": 2190}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_INTEGER_1_1130 ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_constrained_integer ( tvb , offset , actx , tree , hf_index , 1U , 1130U , NULL , FALSE ) ;\n return offset ;\n }", "idx": 2191}
{"hash": -8884965407551053630, "project": "debian", "size": 9, "label": 0, "functionSource": "int input_DecoderGetCcState ( decoder_t * p_dec , bool * pb_decode , int i_channel ) {\n decoder_owner_sys_t * p_owner = p_dec -> p_owner ;\n * pb_decode = false ;\n if ( i_channel < 0 || i_channel >= 4 || ! p_owner -> cc . pb_present [ i_channel ] ) return VLC_EGENERIC ;\n vlc_mutex_lock ( & p_owner -> lock ) ;\n * pb_decode = p_owner -> cc . pp_decoder [ i_channel ] != NULL ;\n vlc_mutex_unlock ( & p_owner -> lock ) ;\n return VLC_EGENERIC ;\n }", "idx": 2192}
{"hash": 313627013719508831, "project": "debian", "size": 4, "label": 0, "functionSource": "static inline Quantum GetPixelBlack ( const Image * restrict image , const Quantum * restrict pixel ) {\n if ( image -> channel_map [ BlackPixelChannel ] . traits == UndefinedPixelTrait ) return ( ( Quantum ) 0 ) ;\n return ( pixel [ image -> channel_map [ BlackPixelChannel ] . offset ] ) ;\n }", "idx": 2193}
{"hash": -8228664527580018723, "project": "debian", "size": 6, "label": 0, "functionSource": "int curl_mvsprintf ( char * buffer , const char * format , va_list ap_save ) {\n int retcode ;\n retcode = dprintf_formatf ( & buffer , storebuffer , format , ap_save ) ;\n * buffer = 0 ;\n return retcode ;\n }", "idx": 2194}
{"hash": -9121264480768156147, "project": "debian", "size": 6, "label": 0, "functionSource": "static inline int get_bits_diff ( MpegEncContext * s ) {\n const int bits = put_bits_count ( & s -> pb ) ;\n const int last = s -> last_bits ;\n s -> last_bits = bits ;\n return bits - last ;\n }", "idx": 2195}
{"hash": 1830000892320875614, "project": "debian", "size": 8, "label": 0, "functionSource": "void fe_ircnet_deinit ( void ) {\n command_unbind ( \"ircnet\" , ( SIGNAL_FUNC ) cmd_network ) ;\n command_unbind ( \"network\" , ( SIGNAL_FUNC ) cmd_network ) ;\n command_unbind ( \"network list\" , ( SIGNAL_FUNC ) cmd_network_list ) ;\n command_unbind ( \"network add\" , ( SIGNAL_FUNC ) cmd_network_add ) ;\n command_unbind ( \"network modify\" , ( SIGNAL_FUNC ) cmd_network_modify ) ;\n command_unbind ( \"network remove\" , ( SIGNAL_FUNC ) cmd_network_remove ) ;\n }", "idx": 2196}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_T_distribution ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_T_distribution , T_distribution_choice , NULL ) ;\n return offset ;\n }", "idx": 2197}
{"hash": 2636502839178711655, "project": "debian", "size": 13, "label": 0, "functionSource": "static void dissect_coap_opt_uri_path ( tvbuff_t * tvb , proto_item * head_item , proto_tree * subtree , gint offset , gint opt_length , coap_info * coinfo , int hf ) {\n const guint8 * str = NULL ;\n wmem_strbuf_append_c ( coinfo -> uri_str_strbuf , '/' ) ;\n if ( opt_length == 0 ) {\n str = nullstr ;\n }\n else {\n str = tvb_get_string_enc ( wmem_packet_scope ( ) , tvb , offset , opt_length , ENC_ASCII ) ;\n wmem_strbuf_append ( coinfo -> uri_str_strbuf , str ) ;\n }\n proto_tree_add_string ( subtree , hf , tvb , offset , opt_length , str ) ;\n proto_item_append_text ( head_item , \": %s\" , str ) ;\n }", "idx": 2198}
{"hash": 1223258652239369123, "project": "debian", "size": 4, "label": 1, "functionSource": "static void spl_filesystem_dir_it_current_data ( zend_object_iterator * iter , zval * * * data TSRMLS_DC ) {\n spl_filesystem_iterator * iterator = ( spl_filesystem_iterator * ) iter ;\n * data = & iterator -> current ;\n }", "idx": 2199}
{"hash": 4976989049001279223, "project": "debian", "size": 3, "label": 0, "functionSource": "void http_hdr_type_set ( HTTPHdrImpl * hh , HTTPType type ) {\n hh -> m_polarity = type ;\n }", "idx": 2200}
{"hash": -3889154245145551951, "project": "debian", "size": 4, "label": 0, "functionSource": "static void option_export_marks ( const char * marks ) {\n export_marks_file = make_fast_import_path ( marks ) ;\n safe_create_leading_directories_const ( export_marks_file ) ;\n }", "idx": 2201}
{"hash": 2559621819476647153, "project": "debian", "size": 6, "label": 0, "functionSource": "static int get_mode ( AVCodecContext * avctx ) {\n if ( avctx -> block_align == 38 ) return 20 ;\n else if ( avctx -> block_align == 50 ) return 30 ;\n else if ( avctx -> bit_rate > 0 ) return avctx -> bit_rate <= 14000 ? 30 : 20 ;\n else return - 1 ;\n }", "idx": 2202}
{"hash": 1760449185745615462, "project": "debian", "size": 6, "label": 0, "functionSource": "TSReturnCode TSUuidInitialize ( TSUuid uuid , TSUuidVersion v ) {\n sdk_assert ( sdk_sanity_check_null_ptr ( ( void * ) uuid ) == TS_SUCCESS ) ;\n ATSUuid * u = ( ATSUuid * ) uuid ;\n u -> initialize ( v ) ;\n return u -> valid ( ) ? TS_SUCCESS : TS_ERROR ;\n }", "idx": 2203}
{"hash": -1315695702746584250, "project": "debian", "size": 9, "label": 0, "functionSource": "static proto_item * proto_tree_add_pi ( proto_tree * tree , header_field_info * hfinfo , tvbuff_t * tvb , gint start , gint * length ) {\n proto_item * pi ;\n field_info * fi ;\n gint item_length ;\n get_hfi_length ( hfinfo , tvb , start , length , & item_length ) ;\n fi = new_field_info ( tree , hfinfo , tvb , start , item_length ) ;\n pi = proto_tree_add_node ( tree , fi ) ;\n return pi ;\n }", "idx": 2204}
{"hash": -2214740494935555658, "project": "chrome", "size": 32, "label": 1, "functionSource": "INDIC_TABLE_ELEMENT_TYPE hb_indic_get_categories ( hb_codepoint_t u ) {\n switch ( u >> 12 ) {\n case 0x0u : if ( hb_in_range ( u , 0x0028u , 0x0040u ) ) return indic_table [ u - 0x0028u + indic_offset_0x0028u ] ;\n if ( hb_in_range ( u , 0x00D0u , 0x00D8u ) ) return indic_table [ u - 0x00D0u + indic_offset_0x00d0u ] ;\n if ( hb_in_range ( u , 0x0900u , 0x0DF8u ) ) return indic_table [ u - 0x0900u + indic_offset_0x0900u ] ;\n if ( unlikely ( u == 0x00A0u ) ) return _ ( CP , x ) ;\n break ;\n case 0x1u : if ( hb_in_range ( u , 0x1000u , 0x10A0u ) ) return indic_table [ u - 0x1000u + indic_offset_0x1000u ] ;\n if ( hb_in_range ( u , 0x1700u , 0x17F0u ) ) return indic_table [ u - 0x1700u + indic_offset_0x1700u ] ;\n if ( hb_in_range ( u , 0x1900u , 0x1AA0u ) ) return indic_table [ u - 0x1900u + indic_offset_0x1900u ] ;\n if ( hb_in_range ( u , 0x1B00u , 0x1C50u ) ) return indic_table [ u - 0x1B00u + indic_offset_0x1b00u ] ;\n if ( hb_in_range ( u , 0x1CD0u , 0x1CF8u ) ) return indic_table [ u - 0x1CD0u + indic_offset_0x1cd0u ] ;\n break ;\n case 0x2u : if ( hb_in_range ( u , 0x2008u , 0x2018u ) ) return indic_table [ u - 0x2008u + indic_offset_0x2008u ] ;\n if ( unlikely ( u == 0x25CCu ) ) return _ ( CP , x ) ;\n break ;\n case 0xAu : if ( hb_in_range ( u , 0xA800u , 0xAAF8u ) ) return indic_table [ u - 0xA800u + indic_offset_0xa800u ] ;\n if ( hb_in_range ( u , 0xABC0u , 0xAC00u ) ) return indic_table [ u - 0xABC0u + indic_offset_0xabc0u ] ;\n break ;\n case 0x10u : if ( hb_in_range ( u , 0x10A00u , 0x10A48u ) ) return indic_table [ u - 0x10A00u + indic_offset_0x10a00u ] ;\n break ;\n case 0x11u : if ( hb_in_range ( u , 0x11000u , 0x110C0u ) ) return indic_table [ u - 0x11000u + indic_offset_0x11000u ] ;\n if ( hb_in_range ( u , 0x11100u , 0x11238u ) ) return indic_table [ u - 0x11100u + indic_offset_0x11100u ] ;\n if ( hb_in_range ( u , 0x112B0u , 0x11378u ) ) return indic_table [ u - 0x112B0u + indic_offset_0x112b0u ] ;\n if ( hb_in_range ( u , 0x11480u , 0x114E0u ) ) return indic_table [ u - 0x11480u + indic_offset_0x11480u ] ;\n if ( hb_in_range ( u , 0x11580u , 0x115C8u ) ) return indic_table [ u - 0x11580u + indic_offset_0x11580u ] ;\n if ( hb_in_range ( u , 0x11600u , 0x116D0u ) ) return indic_table [ u - 0x11600u + indic_offset_0x11600u ] ;\n break ;\n default : break ;\n }\n return _ ( x , x ) ;\n }", "idx": 2205}
{"hash": 3487622904170815119, "project": "debian", "size": 7, "label": 0, "functionSource": "static inline uint64_t replicate64 ( uint64_t a ) {\n # if HAVE_BIGENDIAN a &= 0xFF00FF00FF00FF00ULL ;\n a |= a >> 8 ;\n # else a &= 0x00FF00FF00FF00FFULL ;\n a |= a << 8 ;\n # endif return a ;\n }", "idx": 2206}
{"hash": 8572106347813672436, "project": "debian", "size": 11, "label": 0, "functionSource": "static int unicast_flush_resp ( struct sock * sk , const struct sadb_msg * ihdr ) {\n struct sk_buff * skb ;\n struct sadb_msg * hdr ;\n skb = alloc_skb ( sizeof ( struct sadb_msg ) + 16 , GFP_ATOMIC ) ;\n if ( ! skb ) return - ENOBUFS ;\n hdr = ( struct sadb_msg * ) skb_put ( skb , sizeof ( struct sadb_msg ) ) ;\n memcpy ( hdr , ihdr , sizeof ( struct sadb_msg ) ) ;\n hdr -> sadb_msg_errno = ( uint8_t ) 0 ;\n hdr -> sadb_msg_len = ( sizeof ( struct sadb_msg ) / sizeof ( uint64_t ) ) ;\n return pfkey_broadcast ( skb , GFP_ATOMIC , BROADCAST_ONE , sk , sock_net ( sk ) ) ;\n }", "idx": 2207}
{"hash": 3584320764213684062, "project": "debian", "size": 11, "label": 0, "functionSource": "static int dissect_CPMSendNotifyOut ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * parent_tree , gboolean in _U_ , void * data _U_ ) {\n gint offset = 16 ;\n proto_item * item ;\n proto_tree * tree ;\n col_append_str ( pinfo -> cinfo , COL_INFO , \"SendNotify\" ) ;\n item = proto_tree_add_item ( parent_tree , hf_mswsp_msg , tvb , offset , - 1 , ENC_NA ) ;\n tree = proto_item_add_subtree ( item , ett_mswsp_msg ) ;\n proto_item_set_text ( item , \"GetSendNotifyOut\" ) ;\n proto_tree_add_item ( tree , hf_mswsp_msg_cpmsendnotify_watchnotify , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n return tvb_reported_length ( tvb ) ;\n }", "idx": 2208}
{"hash": 4180964683905830761, "project": "debian", "size": 4, "label": 0, "functionSource": "static int selinux_inode_copy_up_xattr ( const char * name ) {\n if ( strcmp ( name , XATTR_NAME_SELINUX ) == 0 ) return 1 ;\n return - EOPNOTSUPP ;\n }", "idx": 2209}
{"hash": 1458662858915721428, "project": "debian", "size": 19, "label": 0, "functionSource": "static void tcg_handle_interrupt ( CPUState * cpu , int mask ) {\n CPUArchState * env = cpu -> env_ptr ;\n int old_mask ;\n old_mask = cpu -> interrupt_request ;\n cpu -> interrupt_request |= mask ;\n if ( ! qemu_cpu_is_self ( cpu ) ) {\n qemu_cpu_kick ( cpu ) ;\n return ;\n }\n if ( use_icount ) {\n env -> icount_decr . u16 . high = 0xffff ;\n if ( ! can_do_io ( env ) && ( mask & ~ old_mask ) != 0 ) {\n cpu_abort ( env , \"Raised interrupt while not in I/O function\" ) ;\n }\n }\n else {\n cpu -> tcg_exit_req = 1 ;\n }\n }", "idx": 2210}
{"hash": -8487916477825389369, "project": "chrome", "size": 28, "label": 1, "functionSource": "TEST_F ( PrintPreviewUIUnitTest , PrintPreviewData ) {\n WebContents * initiator = browser ( ) -> tab_strip_model ( ) -> GetActiveWebContents ( ) ;\n ASSERT_TRUE ( initiator ) ;\n EXPECT_FALSE ( IsShowingWebContentsModalDialog ( initiator ) ) ;\n printing : : PrintPreviewDialogController * controller = printing : : PrintPreviewDialogController : : GetInstance ( ) ;\n ASSERT_TRUE ( controller ) ;\n printing : : PrintViewManager * print_view_manager = printing : : PrintViewManager : : FromWebContents ( initiator ) ;\n print_view_manager -> PrintPreviewNow ( false ) ;\n WebContents * preview_dialog = controller -> GetOrCreatePreviewDialog ( initiator ) ;\n EXPECT_NE ( initiator , preview_dialog ) ;\n EXPECT_EQ ( 1 , browser ( ) -> tab_strip_model ( ) -> count ( ) ) ;\n EXPECT_TRUE ( IsShowingWebContentsModalDialog ( initiator ) ) ;\n PrintPreviewUI * preview_ui = static_cast < PrintPreviewUI * > ( preview_dialog -> GetWebUI ( ) -> GetController ( ) ) ;\n ASSERT_TRUE ( preview_ui != NULL ) ;\n scoped_refptr < base : : RefCountedBytes > data ;\n preview_ui -> GetPrintPreviewDataForIndex ( printing : : COMPLETE_PREVIEW_DOCUMENT_INDEX , & data ) ;\n EXPECT_EQ ( NULL , data . get ( ) ) ;\n scoped_refptr < base : : RefCountedBytes > dummy_data = CreateTestData ( ) ;\n preview_ui -> SetPrintPreviewDataForIndex ( printing : : COMPLETE_PREVIEW_DOCUMENT_INDEX , dummy_data . get ( ) ) ;\n preview_ui -> GetPrintPreviewDataForIndex ( printing : : COMPLETE_PREVIEW_DOCUMENT_INDEX , & data ) ;\n EXPECT_EQ ( dummy_data -> size ( ) , data -> size ( ) ) ;\n EXPECT_EQ ( dummy_data . get ( ) , data . get ( ) ) ;\n dummy_data = new base : : RefCountedBytes ( ) ;\n preview_ui -> SetPrintPreviewDataForIndex ( printing : : FIRST_PAGE_INDEX , dummy_data . get ( ) ) ;\n preview_ui -> ClearAllPreviewData ( ) ;\n preview_ui -> GetPrintPreviewDataForIndex ( printing : : COMPLETE_PREVIEW_DOCUMENT_INDEX , & data ) ;\n EXPECT_EQ ( NULL , data . get ( ) ) ;\n }", "idx": 2211}
{"hash": -8115807672627724050, "project": "debian", "size": 10, "label": 0, "functionSource": "static int ts_lua_http_config_int_get ( lua_State * L ) {\n int conf ;\n int64_t value ;\n ts_lua_http_ctx * http_ctx ;\n GET_HTTP_CONTEXT ( http_ctx , L ) ;\n conf = luaL_checkinteger ( L , 1 ) ;\n TSHttpTxnConfigIntGet ( http_ctx -> txnp , conf , & value ) ;\n lua_pushnumber ( L , value ) ;\n return 1 ;\n }", "idx": 2212}
{"hash": 3896936900447628930, "project": "debian", "size": 10, "label": 0, "functionSource": "static char * var_read_string ( AVIOContext * pb , int size ) {\n int n ;\n char * str ;\n if ( size < 0 || size == INT_MAX ) return NULL ;\n str = av_malloc ( size + 1 ) ;\n if ( ! str ) return NULL ;\n n = avio_get_str ( pb , size , str , size + 1 ) ;\n if ( n < size ) avio_skip ( pb , size - n ) ;\n return str ;\n }", "idx": 2213}
{"hash": 1760449185745615462, "project": "debian", "size": 12, "label": 0, "functionSource": "TSReturnCode TSVConnTunnel ( TSVConn sslp ) {\n NetVConnection * vc = reinterpret_cast < NetVConnection * > ( sslp ) ;\n SSLNetVConnection * ssl_vc = dynamic_cast < SSLNetVConnection * > ( vc ) ;\n TSReturnCode zret = TS_SUCCESS ;\n if ( nullptr != ssl_vc ) {\n ssl_vc -> hookOpRequested = SSL_HOOK_OP_TUNNEL ;\n }\n else {\n zret = TS_ERROR ;\n }\n return zret ;\n }", "idx": 2214}
{"hash": -5420171864670538459, "project": "debian", "size": 32, "label": 0, "functionSource": "static void * qemu_dummy_cpu_thread_fn ( void * arg ) {\n # ifdef _WIN32 fprintf ( stderr , \"qtest is not supported under Windows\\n\" ) ;\n exit ( 1 ) ;\n # else CPUState * cpu = arg ;\n sigset_t waitset ;\n int r ;\n qemu_mutex_lock_iothread ( ) ;\n qemu_thread_get_self ( cpu -> thread ) ;\n cpu -> thread_id = qemu_get_thread_id ( ) ;\n sigemptyset ( & waitset ) ;\n sigaddset ( & waitset , SIG_IPI ) ;\n cpu -> created = true ;\n qemu_cond_signal ( & qemu_cpu_cond ) ;\n current_cpu = cpu ;\n while ( 1 ) {\n current_cpu = NULL ;\n qemu_mutex_unlock_iothread ( ) ;\n do {\n int sig ;\n r = sigwait ( & waitset , & sig ) ;\n }\n while ( r == - 1 && ( errno == EAGAIN || errno == EINTR ) ) ;\n if ( r == - 1 ) {\n perror ( \"sigwait\" ) ;\n exit ( 1 ) ;\n }\n qemu_mutex_lock_iothread ( ) ;\n current_cpu = cpu ;\n qemu_wait_io_event_common ( cpu ) ;\n }\n return NULL ;\n # endif }", "idx": 2215}
{"hash": -7555034601056330007, "project": "debian", "size": 10, "label": 0, "functionSource": "int virLogFindOutput ( virLogOutputPtr * outputs , size_t noutputs , virLogDestination dest , const void * opaque ) {\n size_t i ;\n const char * name = opaque ;\n for ( i = 0 ;\n i < noutputs ;\n i ++ ) {\n if ( dest == outputs [ i ] -> dest && ( STREQ_NULLABLE ( outputs [ i ] -> name , name ) ) ) return i ;\n }\n return - 1 ;\n }", "idx": 2216}
{"hash": 4537091194729139981, "project": "chrome", "size": 6, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( FullscreenControllerInteractiveTest , DISABLED_TestTabExitsItselfFromFullscreen ) {\n ASSERT_TRUE ( test_server ( ) -> Start ( ) ) ;\n AddTabAtIndex ( 0 , GURL ( url : : kAboutBlankURL ) , PAGE_TRANSITION_TYPED ) ;\n ASSERT_NO_FATAL_FAILURE ( ToggleTabFullscreen ( true ) ) ;\n ASSERT_NO_FATAL_FAILURE ( ToggleTabFullscreen ( false ) ) ;\n }", "idx": 2217}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_EncryptedAlphanumeric ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_EncryptedAlphanumeric , EncryptedAlphanumeric_sequence ) ;\n return offset ;\n }", "idx": 2218}
{"hash": -5861178779585941932, "project": "debian", "size": 29, "label": 0, "functionSource": "u_int fn_printztn ( netdissect_options * ndo , register const u_char * s , register u_int n , register const u_char * ep ) {\n register u_int bytes ;\n register u_char c ;\n bytes = 0 ;\n for ( ;\n ;\n ) {\n if ( n == 0 || ( ep != NULL && s >= ep ) ) {\n bytes = 0 ;\n break ;\n }\n c = * s ++ ;\n bytes ++ ;\n n -- ;\n if ( c == '\\0' ) {\n break ;\n }\n if ( ! ND_ISASCII ( c ) ) {\n c = ND_TOASCII ( c ) ;\n ND_PRINT ( ( ndo , \"M-\" ) ) ;\n }\n if ( ! ND_ISPRINT ( c ) ) {\n c ^= 0x40 ;\n ND_PRINT ( ( ndo , \"^\" ) ) ;\n }\n ND_PRINT ( ( ndo , \"%c\" , c ) ) ;\n }\n return ( bytes ) ;\n }", "idx": 2219}
{"hash": -5615323818347734353, "project": "debian", "size": 18, "label": 0, "functionSource": "static int option_cmp ( my_option * a , my_option * b ) {\n const char * sa = a -> name ;\n const char * sb = b -> name ;\n for ( ;\n * sa || * sb ;\n sa ++ , sb ++ ) {\n if ( * sa < * sb ) {\n if ( * sa == '-' && * sb == '_' ) continue ;\n else return - 1 ;\n }\n if ( * sa > * sb ) {\n if ( * sa == '_' && * sb == '-' ) continue ;\n else return 1 ;\n }\n }\n DBUG_ASSERT ( a -> name == b -> name ) ;\n return 0 ;\n }", "idx": 2220}
{"hash": 1750726979859153417, "project": "debian", "size": 14, "label": 0, "functionSource": "static PyObject * authGSSServerTargetName ( PyObject * self , PyObject * args ) {\n gss_server_state * state ;\n PyObject * pystate ;\n if ( ! PyArg_ParseTuple ( args , \"O\" , & pystate ) ) return NULL ;\n # if PY_MAJOR_VERSION >= 3 if ( ! PyCapsule_CheckExact ( pystate ) ) {\n # else if ( ! PyCObject_Check ( pystate ) ) {\n # endif PyErr_SetString ( PyExc_TypeError , \"Expected a context object\" ) ;\n return NULL ;\n }\n # if PY_MAJOR_VERSION >= 3 state = PyCapsule_GetPointer ( pystate , NULL ) ;\n # else state = ( gss_client_state * ) PyCObject_AsVoidPtr ( pystate ) ;\n # endif if ( state == NULL ) return NULL ;\n return Py_BuildValue ( \"s\" , state -> targetname ) ;\n }", "idx": 2221}
{"hash": -7187272991279783781, "project": "debian", "size": 6, "label": 0, "functionSource": "static void secondary_cpu_reset ( void * opaque ) {\n SPARCCPU * cpu = opaque ;\n CPUState * cs = CPU ( cpu ) ;\n cpu_reset ( cs ) ;\n cs -> halted = 1 ;\n }", "idx": 2222}
{"hash": -5420171864670538459, "project": "debian", "size": 26, "label": 0, "functionSource": "static void * qemu_kvm_cpu_thread_fn ( void * arg ) {\n CPUState * cpu = arg ;\n int r ;\n qemu_mutex_lock ( & qemu_global_mutex ) ;\n qemu_thread_get_self ( cpu -> thread ) ;\n cpu -> thread_id = qemu_get_thread_id ( ) ;\n current_cpu = cpu ;\n r = kvm_init_vcpu ( cpu ) ;\n if ( r < 0 ) {\n fprintf ( stderr , \"kvm_init_vcpu failed: %s\\n\" , strerror ( - r ) ) ;\n exit ( 1 ) ;\n }\n qemu_kvm_init_cpu_signals ( cpu ) ;\n cpu -> created = true ;\n qemu_cond_signal ( & qemu_cpu_cond ) ;\n while ( 1 ) {\n if ( cpu_can_run ( cpu ) ) {\n r = kvm_cpu_exec ( cpu ) ;\n if ( r == EXCP_DEBUG ) {\n cpu_handle_guest_debug ( cpu ) ;\n }\n }\n qemu_kvm_wait_io_event ( cpu ) ;\n }\n return NULL ;\n }", "idx": 2223}
{"hash": 5452557062588481527, "project": "debian", "size": 38, "label": 1, "functionSource": "static void output ( code_int code , GifCtx * ctx ) {\n ctx -> cur_accum &= masks [ ctx -> cur_bits ] ;\n if ( ctx -> cur_bits > 0 ) {\n ctx -> cur_accum |= ( ( long ) code << ctx -> cur_bits ) ;\n }\n else {\n ctx -> cur_accum = code ;\n }\n ctx -> cur_bits += ctx -> n_bits ;\n while ( ctx -> cur_bits >= 8 ) {\n char_out ( ( unsigned int ) ( ctx -> cur_accum & 0xff ) , ctx ) ;\n ctx -> cur_accum >>= 8 ;\n ctx -> cur_bits -= 8 ;\n }\n if ( ctx -> free_ent > ctx -> maxcode || ctx -> clear_flg ) {\n if ( ctx -> clear_flg ) {\n ctx -> maxcode = MAXCODE ( ctx -> n_bits = ctx -> g_init_bits ) ;\n ctx -> clear_flg = 0 ;\n }\n else {\n ++ ( ctx -> n_bits ) ;\n if ( ctx -> n_bits == maxbits ) {\n ctx -> maxcode = maxmaxcode ;\n }\n else {\n ctx -> maxcode = MAXCODE ( ctx -> n_bits ) ;\n }\n }\n }\n if ( code == ctx -> EOFCode ) {\n while ( ctx -> cur_bits > 0 ) {\n char_out ( ( unsigned int ) ( ctx -> cur_accum & 0xff ) , ctx ) ;\n ctx -> cur_accum >>= 8 ;\n ctx -> cur_bits -= 8 ;\n }\n flush_char ( ctx ) ;\n }\n }", "idx": 2224}
{"hash": 1223258652239369123, "project": "debian", "size": 10, "label": 1, "functionSource": "SPL_METHOD ( SplFileObject , ftell ) {\n spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n long ret = php_stream_tell ( intern -> u . file . stream ) ;\n if ( ret == - 1 ) {\n RETURN_FALSE ;\n }\n else {\n RETURN_LONG ( ret ) ;\n }\n }", "idx": 2225}
{"hash": -1270180049246846366, "project": "chrome", "size": 4, "label": 0, "functionSource": "void hb_face_set_upem ( hb_face_t * face , unsigned int upem ) {\n if ( face -> immutable ) return ;\n face -> upem = upem ;\n }", "idx": 2226}
{"hash": 4028820914612007011, "project": "chrome", "size": 32, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( SitePerProcessInteractivePDFTest , ContextMenuPositionForEmbeddedPDFInCrossOriginFrame ) {\n GURL main_url ( embedded_test_server ( ) -> GetURL ( \"a.com\" , \"/iframe.html\" ) ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , main_url ) ;\n EXPECT_EQ ( 0U , test_guest_view_manager ( ) -> num_guests_created ( ) ) ;\n content : : WebContents * active_web_contents = browser ( ) -> tab_strip_model ( ) -> GetActiveWebContents ( ) ;\n EXPECT_TRUE ( ExecuteScript ( active_web_contents , \"document.querySelector('iframe').style =\" \" 'margin-left: 100px;\n margin-top: 100px;\n';\n\" ) ) ;\n GURL frame_url = embedded_test_server ( ) -> GetURL ( \"b.com\" , \"/page_with_embedded_pdf.html\" ) ;\n EXPECT_TRUE ( NavigateIframeToURL ( active_web_contents , \"test\" , frame_url ) ) ;\n content : : WebContents * guest_contents = test_guest_view_manager ( ) -> WaitForSingleGuestCreated ( ) ;\n NavigationToExtensionSchemeObserver navigation_observer ( guest_contents ) ;\n navigation_observer . Wait ( ) ;\n content : : RenderWidgetHostView * child_view = ChildFrameAt ( active_web_contents -> GetMainFrame ( ) , 0 ) -> GetView ( ) ;\n ContextMenuWaiter menu_waiter ( content : : NotificationService : : AllSources ( ) ) ;\n auto send_right_mouse_event = [ ] ( content : : RenderWidgetHost * host , int x , int y , blink : : WebInputEvent : : Type type ) {\n blink : : WebMouseEvent event ;\n event . x = x ;\n event . y = y ;\n event . button = blink : : WebMouseEvent : : Button : : Right ;\n event . setType ( type ) ;\n host -> ForwardMouseEvent ( event ) ;\n }\n ;\n send_right_mouse_event ( child_view -> GetRenderWidgetHost ( ) , 10 , 20 , blink : : WebInputEvent : : MouseDown ) ;\n send_right_mouse_event ( child_view -> GetRenderWidgetHost ( ) , 10 , 20 , blink : : WebInputEvent : : MouseUp ) ;\n menu_waiter . WaitForMenuOpenAndClose ( ) ;\n gfx : : Point point_in_root_window = child_view -> TransformPointToRootCoordSpace ( gfx : : Point ( 10 , 20 ) ) ;\n EXPECT_EQ ( point_in_root_window . x ( ) , menu_waiter . params ( ) . x ) ;\n EXPECT_EQ ( point_in_root_window . y ( ) , menu_waiter . params ( ) . y ) ;\n }", "idx": 2227}
{"hash": 1760449185745615462, "project": "debian", "size": 23, "label": 0, "functionSource": "TSReturnCode TSHttpTxnCachedReqGet ( TSHttpTxn txnp , TSMBuffer * bufp , TSMLoc * obj ) {\n sdk_assert ( sdk_sanity_check_txn ( txnp ) == TS_SUCCESS ) ;\n sdk_assert ( sdk_sanity_check_null_ptr ( ( void * ) bufp ) == TS_SUCCESS ) ;\n sdk_assert ( sdk_sanity_check_null_ptr ( ( void * ) obj ) == TS_SUCCESS ) ;\n HttpSM * sm = ( HttpSM * ) txnp ;\n HTTPInfo * cached_obj = sm -> t_state . cache_info . object_read ;\n if ( ( ! cached_obj ) || ( ! cached_obj -> valid ( ) ) ) {\n return TS_ERROR ;\n }\n HTTPHdr * cached_hdr = sm -> t_state . cache_info . object_read -> request_get ( ) ;\n if ( ! cached_hdr -> valid ( ) ) {\n return TS_ERROR ;\n }\n HdrHeapSDKHandle * * handle = & ( sm -> t_state . cache_req_hdr_heap_handle ) ;\n if ( * handle == nullptr ) {\n * handle = ( HdrHeapSDKHandle * ) sm -> t_state . arena . alloc ( sizeof ( HdrHeapSDKHandle ) ) ;\n ( * handle ) -> m_heap = cached_hdr -> m_heap ;\n }\n * ( reinterpret_cast < HdrHeapSDKHandle * * > ( bufp ) ) = * handle ;\n * obj = reinterpret_cast < TSMLoc > ( cached_hdr -> m_http ) ;\n sdk_assert ( sdk_sanity_check_mbuffer ( * bufp ) == TS_SUCCESS ) ;\n return TS_SUCCESS ;\n }", "idx": 2228}
{"hash": -3975292313894439939, "project": "debian", "size": 4, "label": 0, "functionSource": "int master_service_settings_read ( struct master_service * service ATTR_UNUSED , const struct master_service_settings_input * input ATTR_UNUSED , struct master_service_settings_output * output_r , const char * * error_r ATTR_UNUSED ) {\n * output_r = output ;\n return 0 ;\n }", "idx": 2229}
{"hash": -8028756826159773630, "project": "debian", "size": 24, "label": 0, "functionSource": "static void StrictNamesCheck ( RestoreOptions * ropt ) {\n const char * missing_name ;\n Assert ( ropt -> strict_names ) ;\n if ( ropt -> schemaNames . head != NULL ) {\n missing_name = simple_string_list_not_touched ( & ropt -> schemaNames ) ;\n if ( missing_name != NULL ) exit_horribly ( modulename , \"schema \\\"%s\\\" not found\\n\" , missing_name ) ;\n }\n if ( ropt -> tableNames . head != NULL ) {\n missing_name = simple_string_list_not_touched ( & ropt -> tableNames ) ;\n if ( missing_name != NULL ) exit_horribly ( modulename , \"table \\\"%s\\\" not found\\n\" , missing_name ) ;\n }\n if ( ropt -> indexNames . head != NULL ) {\n missing_name = simple_string_list_not_touched ( & ropt -> indexNames ) ;\n if ( missing_name != NULL ) exit_horribly ( modulename , \"index \\\"%s\\\" not found\\n\" , missing_name ) ;\n }\n if ( ropt -> functionNames . head != NULL ) {\n missing_name = simple_string_list_not_touched ( & ropt -> functionNames ) ;\n if ( missing_name != NULL ) exit_horribly ( modulename , \"function \\\"%s\\\" not found\\n\" , missing_name ) ;\n }\n if ( ropt -> triggerNames . head != NULL ) {\n missing_name = simple_string_list_not_touched ( & ropt -> triggerNames ) ;\n if ( missing_name != NULL ) exit_horribly ( modulename , \"trigger \\\"%s\\\" not found\\n\" , missing_name ) ;\n }\n }", "idx": 2230}
{"hash": 4180964683905830761, "project": "debian", "size": 6, "label": 0, "functionSource": "static int selinux_conn_sid ( u32 sk_sid , u32 skb_sid , u32 * conn_sid ) {\n int err = 0 ;\n if ( skb_sid != SECSID_NULL ) err = security_sid_mls_copy ( sk_sid , skb_sid , conn_sid ) ;\n else * conn_sid = sk_sid ;\n return err ;\n }", "idx": 2231}
{"hash": 3919646340804521652, "project": "debian", "size": 68, "label": 0, "functionSource": "static void check_object ( struct object_entry * entry ) {\n if ( entry -> in_pack ) {\n struct packed_git * p = entry -> in_pack ;\n struct pack_window * w_curs = NULL ;\n const unsigned char * base_ref = NULL ;\n struct object_entry * base_entry ;\n unsigned long used , used_0 ;\n unsigned long avail ;\n off_t ofs ;\n unsigned char * buf , c ;\n buf = use_pack ( p , & w_curs , entry -> in_pack_offset , & avail ) ;\n used = unpack_object_header_buffer ( buf , avail , & entry -> in_pack_type , & entry -> size ) ;\n if ( used == 0 ) goto give_up ;\n switch ( entry -> in_pack_type ) {\n default : entry -> type = entry -> in_pack_type ;\n entry -> in_pack_header_size = used ;\n if ( entry -> type < OBJ_COMMIT || entry -> type > OBJ_BLOB ) goto give_up ;\n unuse_pack ( & w_curs ) ;\n return ;\n case OBJ_REF_DELTA : if ( reuse_delta && ! entry -> preferred_base ) base_ref = use_pack ( p , & w_curs , entry -> in_pack_offset + used , NULL ) ;\n entry -> in_pack_header_size = used + 20 ;\n break ;\n case OBJ_OFS_DELTA : buf = use_pack ( p , & w_curs , entry -> in_pack_offset + used , NULL ) ;\n used_0 = 0 ;\n c = buf [ used_0 ++ ] ;\n ofs = c & 127 ;\n while ( c & 128 ) {\n ofs += 1 ;\n if ( ! ofs || MSB ( ofs , 7 ) ) {\n error ( \"delta base offset overflow in pack for %s\" , sha1_to_hex ( entry -> idx . sha1 ) ) ;\n goto give_up ;\n }\n c = buf [ used_0 ++ ] ;\n ofs = ( ofs << 7 ) + ( c & 127 ) ;\n }\n ofs = entry -> in_pack_offset - ofs ;\n if ( ofs <= 0 || ofs >= entry -> in_pack_offset ) {\n error ( \"delta base offset out of bound for %s\" , sha1_to_hex ( entry -> idx . sha1 ) ) ;\n goto give_up ;\n }\n if ( reuse_delta && ! entry -> preferred_base ) {\n struct revindex_entry * revidx ;\n revidx = find_pack_revindex ( p , ofs ) ;\n if ( ! revidx ) goto give_up ;\n base_ref = nth_packed_object_sha1 ( p , revidx -> nr ) ;\n }\n entry -> in_pack_header_size = used + used_0 ;\n break ;\n }\n if ( base_ref && ( base_entry = packlist_find ( & to_pack , base_ref , NULL ) ) ) {\n entry -> type = entry -> in_pack_type ;\n entry -> delta = base_entry ;\n entry -> delta_size = entry -> size ;\n entry -> delta_sibling = base_entry -> delta_child ;\n base_entry -> delta_child = entry ;\n unuse_pack ( & w_curs ) ;\n return ;\n }\n if ( entry -> type ) {\n entry -> size = get_size_from_delta ( p , & w_curs , entry -> in_pack_offset + entry -> in_pack_header_size ) ;\n if ( entry -> size == 0 ) goto give_up ;\n unuse_pack ( & w_curs ) ;\n return ;\n }\n give_up : unuse_pack ( & w_curs ) ;\n }\n entry -> type = sha1_object_info ( entry -> idx . sha1 , & entry -> size ) ;\n }", "idx": 2232}
{"hash": 330507736709312787, "project": "chrome", "size": 3, "label": 0, "functionSource": "static float hb_graphite2_get_advance ( const void * hb_font , unsigned short gid ) {\n return ( ( hb_font_t * ) hb_font ) -> get_glyph_h_advance ( gid ) ;\n }", "idx": 2233}
{"hash": 8461266595329035000, "project": "chrome", "size": 15, "label": 0, "functionSource": "int event_pending ( struct event * ev , short event , struct timeval * tv ) {\n struct timeval now , res ;\n int flags = 0 ;\n if ( ev -> ev_flags & EVLIST_INSERTED ) flags |= ( ev -> ev_events & ( EV_READ | EV_WRITE | EV_SIGNAL ) ) ;\n if ( ev -> ev_flags & EVLIST_ACTIVE ) flags |= ev -> ev_res ;\n if ( ev -> ev_flags & EVLIST_TIMEOUT ) flags |= EV_TIMEOUT ;\n event &= ( EV_TIMEOUT | EV_READ | EV_WRITE | EV_SIGNAL ) ;\n if ( tv != NULL && ( flags & event & EV_TIMEOUT ) ) {\n gettime ( ev -> ev_base , & now ) ;\n evutil_timersub ( & ev -> ev_timeout , & now , & res ) ;\n evutil_gettimeofday ( & now , NULL ) ;\n evutil_timeradd ( & now , & res , tv ) ;\n }\n return ( flags & event ) ;\n }", "idx": 2234}
{"hash": 6667142528452941476, "project": "debian", "size": 5, "label": 0, "functionSource": "static void short_usage_sub ( FILE * f ) {\n fprintf ( f , \"Usage: %s [OPTIONS] database [tables]\\n\" , my_progname_short ) ;\n fprintf ( f , \"OR %s [OPTIONS] --databases [OPTIONS] DB1 [DB2 DB3...]\\n\" , my_progname_short ) ;\n fprintf ( f , \"OR %s [OPTIONS] --all-databases [OPTIONS]\\n\" , my_progname_short ) ;\n }", "idx": 2235}
{"hash": 369115599810341094, "project": "debian", "size": 27, "label": 0, "functionSource": "static void vga_draw_line2 ( VGACommonState * vga , uint8_t * d , uint32_t addr , int width ) {\n uint32_t plane_mask , * palette , data , v ;\n int x ;\n palette = vga -> last_palette ;\n plane_mask = mask16 [ vga -> ar [ VGA_ATC_PLANE_ENABLE ] & 0xf ] ;\n width >>= 3 ;\n for ( x = 0 ;\n x < width ;\n x ++ ) {\n data = vga_read_dword_le ( vga , addr ) ;\n data &= plane_mask ;\n v = expand2 [ GET_PLANE ( data , 0 ) ] ;\n v |= expand2 [ GET_PLANE ( data , 2 ) ] << 2 ;\n ( ( uint32_t * ) d ) [ 0 ] = palette [ v >> 12 ] ;\n ( ( uint32_t * ) d ) [ 1 ] = palette [ ( v >> 8 ) & 0xf ] ;\n ( ( uint32_t * ) d ) [ 2 ] = palette [ ( v >> 4 ) & 0xf ] ;\n ( ( uint32_t * ) d ) [ 3 ] = palette [ ( v >> 0 ) & 0xf ] ;\n v = expand2 [ GET_PLANE ( data , 1 ) ] ;\n v |= expand2 [ GET_PLANE ( data , 3 ) ] << 2 ;\n ( ( uint32_t * ) d ) [ 4 ] = palette [ v >> 12 ] ;\n ( ( uint32_t * ) d ) [ 5 ] = palette [ ( v >> 8 ) & 0xf ] ;\n ( ( uint32_t * ) d ) [ 6 ] = palette [ ( v >> 4 ) & 0xf ] ;\n ( ( uint32_t * ) d ) [ 7 ] = palette [ ( v >> 0 ) & 0xf ] ;\n d += 32 ;\n addr += 4 ;\n }\n }", "idx": 2236}
{"hash": -769658847024738738, "project": "debian", "size": 45, "label": 0, "functionSource": "static gpgme_error_t uiserver_sign ( void * engine , gpgme_data_t in , gpgme_data_t out , gpgme_sig_mode_t mode , int use_armor , int use_textmode , int include_certs , gpgme_ctx_t ctx ) {\n engine_uiserver_t uiserver = engine ;\n gpgme_error_t err = 0 ;\n const char * protocol ;\n char * cmd ;\n gpgme_key_t key ;\n if ( ! uiserver || ! in || ! out ) return gpg_error ( GPG_ERR_INV_VALUE ) ;\n if ( uiserver -> protocol == GPGME_PROTOCOL_DEFAULT ) protocol = \"\" ;\n else if ( uiserver -> protocol == GPGME_PROTOCOL_OpenPGP ) protocol = \" --protocol=OpenPGP\" ;\n else if ( uiserver -> protocol == GPGME_PROTOCOL_CMS ) protocol = \" --protocol=CMS\" ;\n else return gpgme_error ( GPG_ERR_UNSUPPORTED_PROTOCOL ) ;\n if ( asprintf ( & cmd , \"SIGN%s%s\" , protocol , ( mode == GPGME_SIG_MODE_DETACH ) ? \" --detached\" : \"\" ) < 0 ) return gpg_error_from_syserror ( ) ;\n key = gpgme_signers_enum ( ctx , 0 ) ;\n if ( key ) {\n const char * s = NULL ;\n if ( key && key -> uids ) s = key -> uids -> email ;\n if ( s && strlen ( s ) < 80 ) {\n char buf [ 100 ] ;\n strcpy ( stpcpy ( buf , \"SENDER --info \" ) , s ) ;\n err = uiserver_assuan_simple_command ( uiserver -> assuan_ctx , buf , uiserver -> status . fnc , uiserver -> status . fnc_value ) ;\n }\n else err = gpg_error ( GPG_ERR_INV_VALUE ) ;\n gpgme_key_unref ( key ) ;\n if ( err ) {\n free ( cmd ) ;\n return err ;\n }\n }\n uiserver -> input_cb . data = in ;\n err = uiserver_set_fd ( uiserver , INPUT_FD , map_data_enc ( uiserver -> input_cb . data ) ) ;\n if ( err ) {\n free ( cmd ) ;\n return err ;\n }\n uiserver -> output_cb . data = out ;\n err = uiserver_set_fd ( uiserver , OUTPUT_FD , use_armor ? \"--armor\" : map_data_enc ( uiserver -> output_cb . data ) ) ;\n if ( err ) {\n free ( cmd ) ;\n return err ;\n }\n uiserver -> inline_data = NULL ;\n err = start ( uiserver , cmd ) ;\n free ( cmd ) ;\n return err ;\n }", "idx": 2237}
{"hash": 1182028467273264883, "project": "debian", "size": 6, "label": 0, "functionSource": "uint get_errcode_from_name ( const char * error_name , const char * error_end ) {\n uint tmp ;\n if ( ( tmp = get_errcode_from_name ( error_name , error_end , global_error_names ) ) ) return tmp ;\n if ( ( tmp = get_errcode_from_name ( error_name , error_end , handler_error_names ) ) ) return tmp ;\n die ( \"Unknown SQL error name '%s'\" , error_name ) ;\n }", "idx": 2238}
{"hash": -6552851419396579257, "project": "debian", "size": 14, "label": 0, "functionSource": "static int dissect_FORM_CTR ( tvbuff_t * tvb , int offset , packet_info * pinfo , proto_tree * tree , dcerpc_info * di , guint8 * drep ) {\n proto_tree * subtree ;\n proto_item * item ;\n guint32 level ;\n subtree = proto_tree_add_subtree ( tree , tvb , offset , 0 , ett_FORM_CTR , & item , \"Form container\" ) ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , subtree , di , drep , hf_form_level , & level ) ;\n switch ( level ) {\n case 1 : offset = dissect_FORM_1 ( tvb , offset , pinfo , subtree , di , drep ) ;\n break ;\n default : expert_add_info_format ( pinfo , item , & ei_form_level , \"Unknown form info level %d\" , level ) ;\n break ;\n }\n return offset ;\n }", "idx": 2239}
{"hash": 3966033627990943399, "project": "chrome", "size": 17, "label": 0, "functionSource": "static int32_t getRunFromLogicalIndex ( UBiDi * pBiDi , int32_t logicalIndex , UErrorCode * pErrorCode ) {\n Run * runs = pBiDi -> runs ;\n int32_t runCount = pBiDi -> runCount , visualStart = 0 , i , length , logicalStart ;\n for ( i = 0 ;\n i < runCount ;\n i ++ ) {\n length = runs [ i ] . visualLimit - visualStart ;\n logicalStart = GET_INDEX ( runs [ i ] . logicalStart ) ;\n if ( ( logicalIndex >= logicalStart ) && ( logicalIndex < ( logicalStart + length ) ) ) {\n return i ;\n }\n visualStart += length ;\n }\n U_ASSERT ( FALSE ) ;\n * pErrorCode = U_INVALID_STATE_ERROR ;\n return 0 ;\n }", "idx": 2240}
{"hash": 4208859344475020583, "project": "chrome", "size": 5, "label": 0, "functionSource": "static void get_months ( const UDateFormat * fmt , UChar * months [ ] , UBool useLongNames , UErrorCode * status ) {\n UDateFormatSymbolType monthType = ( useLongNames ? UDAT_MONTHS : UDAT_SHORT_MONTHS ) ;\n if ( U_FAILURE ( * status ) ) return ;\n get_symbols ( fmt , monthType , months , MONTH_COUNT - 1 , 0 , 0 , status ) ;\n }", "idx": 2241}
{"hash": -6333668321124139371, "project": "debian", "size": 5, "label": 1, "functionSource": "void rtp_free_hash_dyn_payload ( GHashTable * rtp_dyn_payload ) {\n if ( rtp_dyn_payload == NULL ) return ;\n g_hash_table_destroy ( rtp_dyn_payload ) ;\n rtp_dyn_payload = NULL ;\n }", "idx": 2242}
{"hash": 6250095321513210169, "project": "debian", "size": 46, "label": 0, "functionSource": "rfbBool rfbSendSetColourMapEntries ( rfbClientPtr cl , int firstColour , int nColours ) {\n char buf [ sz_rfbSetColourMapEntriesMsg + 256 * 3 * 2 ] ;\n char * wbuf = buf ;\n rfbSetColourMapEntriesMsg * scme ;\n uint16_t * rgb ;\n rfbColourMap * cm = & cl -> screen -> colourMap ;\n int i , len ;\n if ( nColours > 256 ) {\n wbuf = ( char * ) malloc ( sz_rfbSetColourMapEntriesMsg + nColours * 3 * 2 ) ;\n }\n scme = ( rfbSetColourMapEntriesMsg * ) wbuf ;\n rgb = ( uint16_t * ) ( & wbuf [ sz_rfbSetColourMapEntriesMsg ] ) ;\n scme -> type = rfbSetColourMapEntries ;\n scme -> firstColour = Swap16IfLE ( firstColour ) ;\n scme -> nColours = Swap16IfLE ( nColours ) ;\n len = sz_rfbSetColourMapEntriesMsg ;\n for ( i = 0 ;\n i < nColours ;\n i ++ ) {\n if ( i < ( int ) cm -> count ) {\n if ( cm -> is16 ) {\n rgb [ i * 3 ] = Swap16IfLE ( cm -> data . shorts [ i * 3 ] ) ;\n rgb [ i * 3 + 1 ] = Swap16IfLE ( cm -> data . shorts [ i * 3 + 1 ] ) ;\n rgb [ i * 3 + 2 ] = Swap16IfLE ( cm -> data . shorts [ i * 3 + 2 ] ) ;\n }\n else {\n rgb [ i * 3 ] = Swap16IfLE ( ( unsigned short ) cm -> data . bytes [ i * 3 ] ) ;\n rgb [ i * 3 + 1 ] = Swap16IfLE ( ( unsigned short ) cm -> data . bytes [ i * 3 + 1 ] ) ;\n rgb [ i * 3 + 2 ] = Swap16IfLE ( ( unsigned short ) cm -> data . bytes [ i * 3 + 2 ] ) ;\n }\n }\n }\n len += nColours * 3 * 2 ;\n LOCK ( cl -> sendMutex ) ;\n if ( rfbWriteExact ( cl , wbuf , len ) < 0 ) {\n rfbLogPerror ( \"rfbSendSetColourMapEntries: write\" ) ;\n rfbCloseClient ( cl ) ;\n if ( wbuf != buf ) free ( wbuf ) ;\n UNLOCK ( cl -> sendMutex ) ;\n return FALSE ;\n }\n UNLOCK ( cl -> sendMutex ) ;\n rfbStatRecordMessageSent ( cl , rfbSetColourMapEntries , len , len ) ;\n if ( wbuf != buf ) free ( wbuf ) ;\n return TRUE ;\n }", "idx": 2243}
{"hash": -4106680724983638989, "project": "chrome", "size": 7, "label": 1, "functionSource": "static void sbr_turnoff ( SpectralBandReplication * sbr ) {\n sbr -> start = 0 ;\n sbr -> kx [ 1 ] = 32 ;\n sbr -> m [ 1 ] = 0 ;\n sbr -> data [ 0 ] . e_a [ 1 ] = sbr -> data [ 1 ] . e_a [ 1 ] = - 1 ;\n memset ( & sbr -> spectrum_params , - 1 , sizeof ( SpectrumParameters ) ) ;\n }", "idx": 2244}
{"hash": 6415329349331062723, "project": "chrome", "size": 29, "label": 0, "functionSource": "static void http_terminate_chunked_test ( void ) {\n struct bufferevent * bev = NULL ;\n struct timeval tv ;\n const char * http_request ;\n short port = - 1 ;\n int fd = - 1 ;\n test_ok = 0 ;\n fprintf ( stdout , \"Testing Terminated Chunked Connection: \" ) ;\n http = http_setup ( & port , NULL ) ;\n evhttp_del_cb ( http , \"/test\" ) ;\n evhttp_set_cb ( http , \"/test\" , terminate_chunked_cb , & terminate_state ) ;\n fd = http_connect ( \"127.0.0.1\" , port ) ;\n bev = bufferevent_new ( fd , terminate_readcb , http_writecb , http_errorcb , NULL ) ;\n terminate_state . fd = fd ;\n terminate_state . bev = bev ;\n http_request = \"GET /test HTTP/1.1\\r\\n\" \"Host: some\\r\\n\\r\\n\" ;\n bufferevent_write ( bev , http_request , strlen ( http_request ) ) ;\n evutil_timerclear ( & tv ) ;\n tv . tv_usec = 10000 ;\n event_once ( - 1 , EV_TIMEOUT , terminate_chunked_client , & terminate_state , & tv ) ;\n event_dispatch ( ) ;\n if ( test_ok != 1 ) {\n fprintf ( stdout , \"FAILED\\n\" ) ;\n exit ( 1 ) ;\n }\n fprintf ( stdout , \"OK\\n\" ) ;\n if ( fd >= 0 ) EVUTIL_CLOSESOCKET ( fd ) ;\n if ( http ) evhttp_free ( http ) ;\n }", "idx": 2245}
{"hash": 7749168290238234888, "project": "debian", "size": 57, "label": 0, "functionSource": "static int xd3_selftest ( void ) {\n # define DO_TEST ( fn , flags , arg ) do {\n xd3_stream stream ;\n xd3_config config ;\n xd3_init_config ( & config , flags ) ;\n XPR ( NT \"testing \" # fn \"%s...\" , flags ? ( \" (\" # flags \")\" ) : \"\" ) ;\n if ( ( ret = xd3_config_stream ( & stream , & config ) == 0 ) && ( ret = test_ ## fn ( & stream , arg ) ) == 0 ) {\n XPR ( NTR \" success\\n\" ) ;\n }\n else {\n XPR ( NTR \" failed: %s: %s\\n\" , xd3_errstring ( & stream ) , xd3_mainerror ( ret ) ) ;\n }\n xd3_free_stream ( & stream ) ;\n if ( ret != 0 ) {\n goto failure ;\n }\n }\n while ( 0 ) int ret ;\n DO_TEST ( random_numbers , 0 , 0 ) ;\n DO_TEST ( decode_integer_end_of_input , 0 , 0 ) ;\n DO_TEST ( decode_integer_overflow , 0 , 0 ) ;\n DO_TEST ( encode_decode_uint32_t , 0 , 0 ) ;\n DO_TEST ( encode_decode_uint64_t , 0 , 0 ) ;\n DO_TEST ( usize_t_overflow , 0 , 0 ) ;\n DO_TEST ( forward_match , 0 , 0 ) ;\n DO_TEST ( address_cache , 0 , 0 ) ;\n IF_GENCODETBL ( DO_TEST ( address_cache , XD3_ALT_CODE_TABLE , 0 ) ) ;\n DO_TEST ( string_matching , 0 , 0 ) ;\n DO_TEST ( choose_instruction , 0 , 0 ) ;\n DO_TEST ( identical_behavior , 0 , 0 ) ;\n DO_TEST ( in_memory , 0 , 0 ) ;\n IF_GENCODETBL ( DO_TEST ( choose_instruction , XD3_ALT_CODE_TABLE , 0 ) ) ;\n IF_GENCODETBL ( DO_TEST ( encode_code_table , 0 , 0 ) ) ;\n DO_TEST ( iopt_flush_instructions , 0 , 0 ) ;\n DO_TEST ( source_cksum_offset , 0 , 0 ) ;\n DO_TEST ( decompress_single_bit_error , 0 , 3 ) ;\n DO_TEST ( decompress_single_bit_error , XD3_ADLER32 , 3 ) ;\n IF_LZMA ( DO_TEST ( decompress_single_bit_error , XD3_SEC_LZMA , 54 ) ) ;\n IF_FGK ( DO_TEST ( decompress_single_bit_error , XD3_SEC_FGK , 3 ) ) ;\n IF_DJW ( DO_TEST ( decompress_single_bit_error , XD3_SEC_DJW , 8 ) ) ;\n IF_GENCODETBL ( DO_TEST ( decompress_single_bit_error , XD3_ALT_CODE_TABLE , 224 ) ) ;\n # if SHELL_TESTS DO_TEST ( force_behavior , 0 , 0 ) ;\n DO_TEST ( stdout_behavior , 0 , 0 ) ;\n DO_TEST ( no_output , 0 , 0 ) ;\n DO_TEST ( appheader , 0 , 0 ) ;\n DO_TEST ( command_line_arguments , 0 , 0 ) ;\n # if EXTERNAL_COMPRESSION DO_TEST ( source_decompression , 0 , 0 ) ;\n DO_TEST ( externally_compressed_io , 0 , 0 ) ;\n # endif DO_TEST ( recode_command , 0 , 0 ) ;\n # endif IF_LZMA ( DO_TEST ( secondary_lzma , 0 , 1 ) ) ;\n IF_DJW ( DO_TEST ( secondary_huff , 0 , DJW_MAX_GROUPS ) ) ;\n IF_FGK ( DO_TEST ( secondary_fgk , 0 , 1 ) ) ;\n DO_TEST ( compressed_stream_overflow , 0 , 0 ) ;\n IF_LZMA ( DO_TEST ( compressed_stream_overflow , XD3_SEC_LZMA , 0 ) ) ;\n failure : test_cleanup ( ) ;\n return ret == 0 ? EXIT_SUCCESS : EXIT_FAILURE ;\n # undef DO_TEST }", "idx": 2246}
{"hash": 6323824267898511453, "project": "debian", "size": 9, "label": 0, "functionSource": "fz_default_colorspaces * fz_clone_default_colorspaces ( fz_context * ctx , fz_default_colorspaces * base ) {\n fz_default_colorspaces * default_cs = fz_malloc_struct ( ctx , fz_default_colorspaces ) ;\n default_cs -> refs = 1 ;\n default_cs -> gray = fz_keep_colorspace ( ctx , base -> gray ) ;\n default_cs -> rgb = fz_keep_colorspace ( ctx , base -> rgb ) ;\n default_cs -> cmyk = fz_keep_colorspace ( ctx , base -> cmyk ) ;\n default_cs -> oi = fz_keep_colorspace ( ctx , base -> oi ) ;\n return default_cs ;\n }", "idx": 2247}
{"hash": 355220887711506893, "project": "debian", "size": 65, "label": 0, "functionSource": "void genericcostestimate ( PlannerInfo * root , IndexPath * path , double loop_count , List * qinfos , GenericCosts * costs ) {\n IndexOptInfo * index = path -> indexinfo ;\n List * indexQuals = path -> indexquals ;\n List * indexOrderBys = path -> indexorderbys ;\n Cost indexStartupCost ;\n Cost indexTotalCost ;\n Selectivity indexSelectivity ;\n double indexCorrelation ;\n double numIndexPages ;\n double numIndexTuples ;\n double spc_random_page_cost ;\n double num_sa_scans ;\n double num_outer_scans ;\n double num_scans ;\n double qual_op_cost ;\n double qual_arg_cost ;\n List * selectivityQuals ;\n ListCell * l ;\n selectivityQuals = add_predicate_to_quals ( index , indexQuals ) ;\n num_sa_scans = 1 ;\n foreach ( l , indexQuals ) {\n RestrictInfo * rinfo = ( RestrictInfo * ) lfirst ( l ) ;\n if ( IsA ( rinfo -> clause , ScalarArrayOpExpr ) ) {\n ScalarArrayOpExpr * saop = ( ScalarArrayOpExpr * ) rinfo -> clause ;\n int alength = estimate_array_length ( lsecond ( saop -> args ) ) ;\n if ( alength > 1 ) num_sa_scans *= alength ;\n }\n }\n indexSelectivity = clauselist_selectivity ( root , selectivityQuals , index -> rel -> relid , JOIN_INNER , NULL ) ;\n numIndexTuples = costs -> numIndexTuples ;\n if ( numIndexTuples <= 0.0 ) {\n numIndexTuples = indexSelectivity * index -> rel -> tuples ;\n numIndexTuples = rint ( numIndexTuples / num_sa_scans ) ;\n }\n if ( numIndexTuples > index -> tuples ) numIndexTuples = index -> tuples ;\n if ( numIndexTuples < 1.0 ) numIndexTuples = 1.0 ;\n if ( index -> pages > 1 && index -> tuples > 1 ) numIndexPages = ceil ( numIndexTuples * index -> pages / index -> tuples ) ;\n else numIndexPages = 1.0 ;\n get_tablespace_page_costs ( index -> reltablespace , & spc_random_page_cost , NULL ) ;\n num_outer_scans = loop_count ;\n num_scans = num_sa_scans * num_outer_scans ;\n if ( num_scans > 1 ) {\n double pages_fetched ;\n pages_fetched = numIndexPages * num_scans ;\n pages_fetched = index_pages_fetched ( pages_fetched , index -> pages , ( double ) index -> pages , root ) ;\n indexTotalCost = ( pages_fetched * spc_random_page_cost ) / num_outer_scans ;\n }\n else {\n indexTotalCost = numIndexPages * spc_random_page_cost ;\n }\n qual_arg_cost = other_operands_eval_cost ( root , qinfos ) + orderby_operands_eval_cost ( root , path ) ;\n qual_op_cost = cpu_operator_cost * ( list_length ( indexQuals ) + list_length ( indexOrderBys ) ) ;\n indexStartupCost = qual_arg_cost ;\n indexTotalCost += qual_arg_cost ;\n indexTotalCost += numIndexTuples * num_sa_scans * ( cpu_index_tuple_cost + qual_op_cost ) ;\n indexCorrelation = 0.0 ;\n costs -> indexStartupCost = indexStartupCost ;\n costs -> indexTotalCost = indexTotalCost ;\n costs -> indexSelectivity = indexSelectivity ;\n costs -> indexCorrelation = indexCorrelation ;\n costs -> numIndexPages = numIndexPages ;\n costs -> numIndexTuples = numIndexTuples ;\n costs -> spc_random_page_cost = spc_random_page_cost ;\n costs -> num_sa_scans = num_sa_scans ;\n }", "idx": 2248}
{"hash": 1353431100313404503, "project": "chrome", "size": 17, "label": 1, "functionSource": "static int tile_worker_hook ( void * arg1 , void * arg2 ) {\n TileWorkerData * const tile_data = ( TileWorkerData * ) arg1 ;\n const TileInfo * const tile = ( TileInfo * ) arg2 ;\n int mi_row , mi_col ;\n for ( mi_row = tile -> mi_row_start ;\n mi_row < tile -> mi_row_end ;\n mi_row += MI_BLOCK_SIZE ) {\n vp9_zero ( tile_data -> xd . left_context ) ;\n vp9_zero ( tile_data -> xd . left_seg_context ) ;\n for ( mi_col = tile -> mi_col_start ;\n mi_col < tile -> mi_col_end ;\n mi_col += MI_BLOCK_SIZE ) {\n decode_partition ( tile_data -> cm , & tile_data -> xd , tile , mi_row , mi_col , & tile_data -> bit_reader , BLOCK_64X64 ) ;\n }\n }\n return ! tile_data -> xd . corrupted ;\n }", "idx": 2249}
{"hash": -7795592811940874822, "project": "debian", "size": 9, "label": 0, "functionSource": "static gcry_err_code_t dummy_decrypt ( int algorithm , gcry_mpi_t * result , gcry_mpi_t * data , gcry_mpi_t * skey , int flags ) {\n ( void ) algorithm ;\n ( void ) result ;\n ( void ) data ;\n ( void ) skey ;\n ( void ) flags ;\n fips_signal_error ( \"using dummy public key function\" ) ;\n return GPG_ERR_NOT_IMPLEMENTED ;\n }", "idx": 2250}
{"hash": 6020240946719726948, "project": "debian", "size": 11, "label": 1, "functionSource": "static void cmv_decode_intra ( CmvContext * s , const uint8_t * buf , const uint8_t * buf_end ) {\n unsigned char * dst = s -> frame . data [ 0 ] ;\n int i ;\n for ( i = 0 ;\n i < s -> avctx -> height && buf_end - buf >= s -> avctx -> width ;\n i ++ ) {\n memcpy ( dst , buf , s -> avctx -> width ) ;\n dst += s -> frame . linesize [ 0 ] ;\n buf += s -> avctx -> width ;\n }\n }", "idx": 2251}
{"hash": -5706788925640467782, "project": "chrome", "size": 11, "label": 0, "functionSource": "static int get_skip_encode_frame ( const VP9_COMMON * cm ) {\n unsigned int intra_count = 0 , inter_count = 0 ;\n int j ;\n for ( j = 0 ;\n j < INTRA_INTER_CONTEXTS ;\n ++ j ) {\n intra_count += cm -> counts . intra_inter [ j ] [ 0 ] ;\n inter_count += cm -> counts . intra_inter [ j ] [ 1 ] ;\n }\n return ( intra_count << 2 ) < inter_count && cm -> frame_type != KEY_FRAME && cm -> show_frame ;\n }", "idx": 2252}
{"hash": 2390790920103114259, "project": "debian", "size": 20, "label": 0, "functionSource": "static void dovec ( struct vars * v , struct cvec * cv , struct state * lp , struct state * rp ) {\n chr ch , from , to ;\n const chr * p ;\n int i ;\n for ( p = cv -> chrs , i = cv -> nchrs ;\n i > 0 ;\n p ++ , i -- ) {\n ch = * p ;\n newarc ( v -> nfa , PLAIN , subcolor ( v -> cm , ch ) , lp , rp ) ;\n NOERR ( ) ;\n }\n for ( p = cv -> ranges , i = cv -> nranges ;\n i > 0 ;\n p += 2 , i -- ) {\n from = * p ;\n to = * ( p + 1 ) ;\n if ( from <= to ) subrange ( v , from , to , lp , rp ) ;\n NOERR ( ) ;\n }\n }", "idx": 2253}
{"hash": -7237039260294671485, "project": "debian", "size": 5, "label": 0, "functionSource": "static void nlm_msg_res_unmatched_value_destroy ( gpointer value ) {\n nlm_msg_res_unmatched_data * umd = ( nlm_msg_res_unmatched_data * ) value ;\n wmem_free ( NULL , ( gpointer ) umd -> cookie ) ;\n g_free ( umd ) ;\n }", "idx": 2254}
{"hash": 1760449185745615462, "project": "debian", "size": 7, "label": 0, "functionSource": "TSReturnCode sdk_sanity_check_mbuffer ( TSMBuffer bufp ) {\n HdrHeapSDKHandle * handle = ( HdrHeapSDKHandle * ) bufp ;\n if ( ( handle == nullptr ) || ( handle -> m_heap == nullptr ) || ( handle -> m_heap -> m_magic != HDR_BUF_MAGIC_ALIVE ) ) {\n return TS_ERROR ;\n }\n return TS_SUCCESS ;\n }", "idx": 2255}
{"hash": 589395864685553737, "project": "debian", "size": 5, "label": 0, "functionSource": "void armv7m_nvic_set_pending ( void * opaque , int irq ) {\n nvic_state * s = ( nvic_state * ) opaque ;\n if ( irq >= 16 ) irq += 16 ;\n gic_set_pending_private ( & s -> gic , 0 , irq ) ;\n }", "idx": 2256}
{"hash": -5697857125570093892, "project": "chrome", "size": 76, "label": 0, "functionSource": "static UBool _addExtensionToList ( ExtensionListEntry * * first , ExtensionListEntry * ext , UBool localeToBCP ) {\n UBool bAdded = TRUE ;\n if ( * first == NULL ) {\n ext -> next = NULL ;\n * first = ext ;\n }\n else {\n ExtensionListEntry * prev , * cur ;\n int32_t cmp ;\n prev = NULL ;\n cur = * first ;\n while ( TRUE ) {\n if ( cur == NULL ) {\n prev -> next = ext ;\n ext -> next = NULL ;\n break ;\n }\n if ( localeToBCP ) {\n int32_t len , curlen ;\n len = ( int32_t ) uprv_strlen ( ext -> key ) ;\n curlen = ( int32_t ) uprv_strlen ( cur -> key ) ;\n if ( len == 1 && curlen == 1 ) {\n if ( * ( ext -> key ) == * ( cur -> key ) ) {\n cmp = 0 ;\n }\n else if ( * ( ext -> key ) == PRIVATEUSE ) {\n cmp = 1 ;\n }\n else if ( * ( cur -> key ) == PRIVATEUSE ) {\n cmp = - 1 ;\n }\n else {\n cmp = * ( ext -> key ) - * ( cur -> key ) ;\n }\n }\n else if ( len == 1 ) {\n cmp = * ( ext -> key ) - LDMLEXT ;\n }\n else if ( curlen == 1 ) {\n cmp = LDMLEXT - * ( cur -> key ) ;\n }\n else {\n cmp = uprv_compareInvCharsAsAscii ( ext -> key , cur -> key ) ;\n if ( cmp != 0 ) {\n if ( uprv_strcmp ( cur -> key , LOCALE_ATTRIBUTE_KEY ) == 0 ) {\n cmp = 1 ;\n }\n else if ( uprv_strcmp ( ext -> key , LOCALE_ATTRIBUTE_KEY ) == 0 ) {\n cmp = - 1 ;\n }\n }\n }\n }\n else {\n cmp = uprv_compareInvCharsAsAscii ( ext -> key , cur -> key ) ;\n }\n if ( cmp < 0 ) {\n if ( prev == NULL ) {\n * first = ext ;\n }\n else {\n prev -> next = ext ;\n }\n ext -> next = cur ;\n break ;\n }\n if ( cmp == 0 ) {\n bAdded = FALSE ;\n break ;\n }\n prev = cur ;\n cur = cur -> next ;\n }\n }\n return bAdded ;\n }", "idx": 2257}
{"hash": -7455544248455991006, "project": "debian", "size": 19, "label": 0, "functionSource": "static int kvm_guest_debug_workarounds ( X86CPU * cpu ) {\n CPUState * cs = CPU ( cpu ) ;\n CPUX86State * env = & cpu -> env ;\n int ret = 0 ;\n unsigned long reinject_trap = 0 ;\n if ( ! kvm_has_vcpu_events ( ) ) {\n if ( env -> exception_injected == 1 ) {\n reinject_trap = KVM_GUESTDBG_INJECT_DB ;\n }\n else if ( env -> exception_injected == 3 ) {\n reinject_trap = KVM_GUESTDBG_INJECT_BP ;\n }\n env -> exception_injected = - 1 ;\n }\n if ( reinject_trap || ( ! kvm_has_robust_singlestep ( ) && cs -> singlestep_enabled ) ) {\n ret = kvm_update_guest_debug ( cs , reinject_trap ) ;\n }\n return ret ;\n }", "idx": 2258}
{"hash": 1760449185745615462, "project": "debian", "size": 5, "label": 0, "functionSource": "void TSContDestroy ( TSCont contp ) {\n sdk_assert ( sdk_sanity_check_iocore_structure ( contp ) == TS_SUCCESS ) ;\n INKContInternal * i = ( INKContInternal * ) contp ;\n i -> destroy ( ) ;\n }", "idx": 2259}
{"hash": 2546373479020365143, "project": "debian", "size": 50, "label": 0, "functionSource": "int mime_hdr_print ( HdrHeap * , MIMEHdrImpl * mh , char * buf_start , int buf_length , int * buf_index_inout , int * buf_chars_to_skip_inout ) {\n MIMEFieldBlockImpl * fblock ;\n MIMEField * field ;\n uint32_t index ;\n # define SIMPLE_MIME_HDR_PRINT # ifdef SIMPLE_MIME_HDR_PRINT for ( fblock = & ( mh -> m_first_fblock ) ;\n fblock != nullptr ;\n fblock = fblock -> m_next ) {\n for ( index = 0 ;\n index < fblock -> m_freetop ;\n index ++ ) {\n field = & ( fblock -> m_field_slots [ index ] ) ;\n if ( field -> is_live ( ) ) {\n if ( ! mime_field_print ( field , buf_start , buf_length , buf_index_inout , buf_chars_to_skip_inout ) ) {\n return 0 ;\n }\n }\n }\n }\n # else for ( fblock = & ( mh -> m_first_fblock ) ;\n fblock != NULL ;\n fblock = fblock -> m_next ) {\n const char * contig_start = NULL ;\n int this_length , contig_length = 0 ;\n for ( index = 0 ;\n index < fblock -> m_freetop ;\n index ++ ) {\n field = & ( fblock -> m_field_slots [ index ] ) ;\n this_length = field -> m_len_name + field -> m_len_value + field -> m_n_v_raw_printable_pad ;\n if ( field -> is_live ( ) ) {\n if ( ( field -> m_ptr_name == contig_start + contig_length ) && field -> m_n_v_raw_printable && ( ( buf_index_inout == NULL ) || ( contig_length + this_length <= buf_length - * buf_index_inout ) ) ) {\n contig_length += this_length ;\n }\n else {\n if ( contig_length > 0 ) {\n if ( ! mime_mem_print ( contig_start , contig_length , buf_start , buf_length , buf_index_inout , buf_chars_to_skip_inout ) ) return 0 ;\n }\n contig_start = field -> m_ptr_name ;\n contig_length = this_length ;\n }\n }\n }\n if ( contig_length > 0 ) {\n if ( ! mime_mem_print ( contig_start , contig_length , buf_start , buf_length , buf_index_inout , buf_chars_to_skip_inout ) ) return 0 ;\n }\n }\n # endif if ( ! mime_mem_print ( \"\\r\\n\" , 2 , buf_start , buf_length , buf_index_inout , buf_chars_to_skip_inout ) ) {\n return 0 ;\n }\n return 1 ;\n }", "idx": 2260}
{"hash": 6216601921913354724, "project": "debian", "size": 105, "label": 1, "functionSource": "static int tscc2_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n TSCC2Context * c = avctx -> priv_data ;\n GetByteContext gb ;\n uint32_t frame_type , size ;\n int i , val , len , pos = 0 ;\n int num_mb = c -> mb_width * c -> mb_height ;\n int ret ;\n bytestream2_init ( & gb , buf , buf_size ) ;\n frame_type = bytestream2_get_byte ( & gb ) ;\n if ( frame_type > 1 ) {\n av_log ( avctx , AV_LOG_ERROR , \"Incorrect frame type %d\\n\" , frame_type ) ;\n return AVERROR_INVALIDDATA ;\n }\n c -> pic . reference = 3 ;\n c -> pic . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE ;\n if ( ( ret = avctx -> reget_buffer ( avctx , & c -> pic ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"reget_buffer() failed\\n\" ) ;\n return ret ;\n }\n if ( frame_type == 0 ) {\n * got_frame = 1 ;\n * ( AVFrame * ) data = c -> pic ;\n return buf_size ;\n }\n if ( bytestream2_get_bytes_left ( & gb ) < 4 ) {\n av_log ( avctx , AV_LOG_ERROR , \"Frame is too short\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n c -> quant [ 0 ] = bytestream2_get_byte ( & gb ) ;\n c -> quant [ 1 ] = bytestream2_get_byte ( & gb ) ;\n if ( c -> quant [ 0 ] < 2 || c -> quant [ 0 ] > NUM_VLC_SETS + 1 || c -> quant [ 1 ] < 2 || c -> quant [ 1 ] > NUM_VLC_SETS + 1 ) {\n av_log ( avctx , AV_LOG_ERROR , \"Invalid quantisers %d / %d\\n\" , c -> quant [ 0 ] , c -> quant [ 1 ] ) ;\n return AVERROR_INVALIDDATA ;\n }\n for ( i = 0 ;\n i < 3 ;\n i ++ ) {\n c -> q [ 0 ] [ i ] = tscc2_quants [ c -> quant [ 0 ] - 2 ] [ i ] ;\n c -> q [ 1 ] [ i ] = tscc2_quants [ c -> quant [ 1 ] - 2 ] [ i ] ;\n }\n bytestream2_skip ( & gb , 1 ) ;\n size = bytestream2_get_le32 ( & gb ) ;\n if ( size > bytestream2_get_bytes_left ( & gb ) ) {\n av_log ( avctx , AV_LOG_ERROR , \"Slice properties chunk is too large\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n for ( i = 0 ;\n i < size ;\n i ++ ) {\n val = bytestream2_get_byte ( & gb ) ;\n len = val & 0x3F ;\n val >>= 6 ;\n if ( pos + len > num_mb ) {\n av_log ( avctx , AV_LOG_ERROR , \"Too many slice properties\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n memset ( c -> slice_quants + pos , val , len ) ;\n pos += len ;\n }\n if ( pos < num_mb ) {\n av_log ( avctx , AV_LOG_ERROR , \"Too few slice properties (%d / %d)\\n\" , pos , num_mb ) ;\n return AVERROR_INVALIDDATA ;\n }\n for ( i = 0 ;\n i < c -> mb_height ;\n i ++ ) {\n size = bytestream2_peek_byte ( & gb ) ;\n if ( size & 1 ) {\n size = bytestream2_get_byte ( & gb ) - 1 ;\n }\n else {\n size = bytestream2_get_le32 ( & gb ) >> 1 ;\n }\n if ( ! size ) {\n int skip_row = 1 , j , off = i * c -> mb_width ;\n for ( j = 0 ;\n j < c -> mb_width ;\n j ++ ) {\n if ( c -> slice_quants [ off + j ] == 1 || c -> slice_quants [ off + j ] == 2 ) {\n skip_row = 0 ;\n break ;\n }\n }\n if ( ! skip_row ) {\n av_log ( avctx , AV_LOG_ERROR , \"Non-skip row with zero size\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n }\n if ( bytestream2_get_bytes_left ( & gb ) < size ) {\n av_log ( avctx , AV_LOG_ERROR , \"Invalid slice size (%d/%d)\\n\" , size , bytestream2_get_bytes_left ( & gb ) ) ;\n return AVERROR_INVALIDDATA ;\n }\n ret = tscc2_decode_slice ( c , i , buf + bytestream2_tell ( & gb ) , size ) ;\n if ( ret ) {\n av_log ( avctx , AV_LOG_ERROR , \"Error decoding slice %d\\n\" , i ) ;\n return ret ;\n }\n bytestream2_skip ( & gb , size ) ;\n }\n * got_frame = 1 ;\n * ( AVFrame * ) data = c -> pic ;\n return buf_size ;\n }", "idx": 2261}
{"hash": -3740862514502467070, "project": "debian", "size": 7, "label": 0, "functionSource": "static struct taboff * findtabindir ( struct tabdir * td , uint32 tag ) {\n int i ;\n for ( i = 0 ;\n i < td -> numtab ;\n ++ i ) if ( td -> tabs [ i ] . tag == tag ) return ( & td -> tabs [ i ] ) ;\n return ( NULL ) ;\n }", "idx": 2262}
{"hash": -2423144171479606949, "project": "debian", "size": 5, "label": 0, "functionSource": "static void pdf_run_gs_CA ( fz_context * ctx , pdf_processor * proc , float alpha ) {\n pdf_run_processor * pr = ( pdf_run_processor * ) proc ;\n pdf_gstate * gstate = pdf_flush_text ( ctx , pr ) ;\n gstate -> stroke . alpha = fz_clamp ( alpha , 0 , 1 ) ;\n }", "idx": 2263}
{"hash": 4489017523191997023, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h225_OCTET_STRING_SIZE_1_4 ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_octet_string ( tvb , offset , actx , tree , hf_index , 1 , 4 , FALSE , NULL ) ;\n return offset ;\n }", "idx": 2264}
{"hash": -2661809302248698892, "project": "debian", "size": 43, "label": 0, "functionSource": "static inline void mcdc ( uint16_t * dst , uint16_t * src , int log2w , int h , int stride , int scale , unsigned dc ) {\n int i ;\n dc *= 0x10001 ;\n switch ( log2w ) {\n case 0 : for ( i = 0 ;\n i < h ;\n i ++ ) {\n dst [ 0 ] = scale * src [ 0 ] + dc ;\n if ( scale ) src += stride ;\n dst += stride ;\n }\n break ;\n case 1 : for ( i = 0 ;\n i < h ;\n i ++ ) {\n LE_CENTRIC_MUL ( dst , src , scale , dc ) ;\n if ( scale ) src += stride ;\n dst += stride ;\n }\n break ;\n case 2 : for ( i = 0 ;\n i < h ;\n i ++ ) {\n LE_CENTRIC_MUL ( dst , src , scale , dc ) ;\n LE_CENTRIC_MUL ( dst + 2 , src + 2 , scale , dc ) ;\n if ( scale ) src += stride ;\n dst += stride ;\n }\n break ;\n case 3 : for ( i = 0 ;\n i < h ;\n i ++ ) {\n LE_CENTRIC_MUL ( dst , src , scale , dc ) ;\n LE_CENTRIC_MUL ( dst + 2 , src + 2 , scale , dc ) ;\n LE_CENTRIC_MUL ( dst + 4 , src + 4 , scale , dc ) ;\n LE_CENTRIC_MUL ( dst + 6 , src + 6 , scale , dc ) ;\n if ( scale ) src += stride ;\n dst += stride ;\n }\n break ;\n default : assert ( 0 ) ;\n }\n }", "idx": 2265}
{"hash": -6704066512670389306, "project": "debian", "size": 13, "label": 0, "functionSource": "static int lookup_gname_helper ( struct cpio * cpio , const char * * name , id_t id ) {\n struct group * grent ;\n ( void ) cpio ;\n errno = 0 ;\n grent = getgrgid ( ( gid_t ) id ) ;\n if ( grent == NULL ) {\n * name = NULL ;\n if ( errno != 0 ) lafe_warnc ( errno , \"getgrgid(%s) failed\" , cpio_i64toa ( ( int64_t ) id ) ) ;\n return ( errno ) ;\n }\n * name = grent -> gr_name ;\n return ( 0 ) ;\n }", "idx": 2266}
{"hash": -7455544248455991006, "project": "debian", "size": 14, "label": 0, "functionSource": "static int kvm_put_xcrs ( X86CPU * cpu ) {\n CPUX86State * env = & cpu -> env ;\n struct kvm_xcrs xcrs = {\n }\n ;\n if ( ! has_xcrs ) {\n return 0 ;\n }\n xcrs . nr_xcrs = 1 ;\n xcrs . flags = 0 ;\n xcrs . xcrs [ 0 ] . xcr = 0 ;\n xcrs . xcrs [ 0 ] . value = env -> xcr0 ;\n return kvm_vcpu_ioctl ( CPU ( cpu ) , KVM_SET_XCRS , & xcrs ) ;\n }", "idx": 2267}
{"hash": 58020529414140129, "project": "chrome", "size": 17, "label": 0, "functionSource": "static void count_segs ( const VP9_COMMON * cm , MACROBLOCKD * xd , const TileInfo * tile , MODE_INFO * mi , int * no_pred_segcounts , int ( * temporal_predictor_count ) [ 2 ] , int * t_unpred_seg_counts , int bw , int bh , int mi_row , int mi_col ) {\n int segment_id ;\n if ( mi_row >= cm -> mi_rows || mi_col >= cm -> mi_cols ) return ;\n xd -> mi = mi ;\n segment_id = xd -> mi [ 0 ] . src_mi -> mbmi . segment_id ;\n set_mi_row_col ( xd , tile , mi_row , bh , mi_col , bw , cm -> mi_rows , cm -> mi_cols ) ;\n no_pred_segcounts [ segment_id ] ++ ;\n if ( cm -> frame_type != KEY_FRAME ) {\n const BLOCK_SIZE bsize = xd -> mi [ 0 ] . src_mi -> mbmi . sb_type ;\n const int pred_segment_id = vp9_get_segment_id ( cm , cm -> last_frame_seg_map , bsize , mi_row , mi_col ) ;\n const int pred_flag = pred_segment_id == segment_id ;\n const int pred_context = vp9_get_pred_context_seg_id ( xd ) ;\n xd -> mi [ 0 ] . src_mi -> mbmi . seg_id_predicted = pred_flag ;\n temporal_predictor_count [ pred_context ] [ pred_flag ] ++ ;\n if ( ! pred_flag ) t_unpred_seg_counts [ segment_id ] ++ ;\n }\n }", "idx": 2268}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_T38FaxTcpOptions ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_T38FaxTcpOptions , T38FaxTcpOptions_sequence ) ;\n return offset ;\n }", "idx": 2269}
{"hash": -4106680724983638989, "project": "chrome", "size": 7, "label": 1, "functionSource": "static int array_min_int16 ( const int16_t * array , int nel ) {\n int i , min = array [ 0 ] ;\n for ( i = 1 ;\n i < nel ;\n i ++ ) min = FFMIN ( array [ i ] , min ) ;\n return min ;\n }", "idx": 2270}
{"hash": 6805657479815417135, "project": "chrome", "size": 3, "label": 0, "functionSource": "static int compareFiles ( const void * file1 , const void * file2 ) {\n return uprv_strcmp ( ( ( File * ) file1 ) -> basename , ( ( File * ) file2 ) -> basename ) ;\n }", "idx": 2271}
{"hash": -769658847024738738, "project": "debian", "size": 5, "label": 0, "functionSource": "static void uiserver_set_status_handler ( void * engine , engine_status_handler_t fnc , void * fnc_value ) {\n engine_uiserver_t uiserver = engine ;\n uiserver -> status . fnc = fnc ;\n uiserver -> status . fnc_value = fnc_value ;\n }", "idx": 2272}
{"hash": -1768728156572022708, "project": "debian", "size": 3, "label": 0, "functionSource": "void jbig2_global_ctx_free ( Jbig2GlobalCtx * global_ctx ) {\n jbig2_ctx_free ( ( Jbig2Ctx * ) global_ctx ) ;\n }", "idx": 2273}
