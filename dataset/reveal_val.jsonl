{"hash": -3819889754140204145, "project": "debian", "size": 27, "label": 0, "functionSource": "static void parse_keyUsage ( chunk_t blob , private_x509_cert_t * this ) {\n enum {\n KU_DIGITAL_SIGNATURE = 0 , KU_NON_REPUDIATION = 1 , KU_KEY_ENCIPHERMENT = 2 , KU_DATA_ENCIPHERMENT = 3 , KU_KEY_AGREEMENT = 4 , KU_KEY_CERT_SIGN = 5 , KU_CRL_SIGN = 6 , KU_ENCIPHER_ONLY = 7 , KU_DECIPHER_ONLY = 8 , }\n ;\n if ( asn1_unwrap ( & blob , & blob ) == ASN1_BIT_STRING && blob . len ) {\n int bit , byte , unused = blob . ptr [ 0 ] ;\n blob = chunk_skip ( blob , 1 ) ;\n for ( byte = 0 ;\n byte < blob . len ;\n byte ++ ) {\n for ( bit = 0 ;\n bit < 8 ;\n bit ++ ) {\n if ( byte == blob . len - 1 && bit > ( 7 - unused ) ) {\n break ;\n }\n if ( blob . ptr [ byte ] & 1 << ( 7 - bit ) ) {\n switch ( byte * 8 + bit ) {\n case KU_CRL_SIGN : this -> flags |= X509_CRL_SIGN ;\n break ;\n case KU_KEY_CERT_SIGN : case KU_DIGITAL_SIGNATURE : case KU_NON_REPUDIATION : case KU_KEY_ENCIPHERMENT : case KU_DATA_ENCIPHERMENT : case KU_KEY_AGREEMENT : case KU_ENCIPHER_ONLY : case KU_DECIPHER_ONLY : break ;\n }\n }\n }\n }\n }\n }", "idx": 20461}
{"hash": -2607754285145856562, "project": "debian", "size": 5, "label": 0, "functionSource": "static struct isoent * isoent_find_child ( struct isoent * isoent , const char * child_name ) {\n struct isoent * np ;\n np = ( struct isoent * ) __archive_rb_tree_find_node ( & ( isoent -> rbtree ) , child_name ) ;\n return ( np ) ;\n }", "idx": 20462}
{"hash": -4552633429382740307, "project": "debian", "size": 3, "label": 0, "functionSource": "unsigned int mpi_nlimb_hint_from_nbits ( unsigned int nbits ) {\n return ( nbits + BITS_PER_MPI_LIMB - 1 ) / BITS_PER_MPI_LIMB ;\n }", "idx": 20463}
{"hash": -2064332158282087279, "project": "debian", "size": 55, "label": 0, "functionSource": "static int astream_try_base64_decode_char ( struct attachment_istream_part * part , size_t pos , char chr ) {\n switch ( part -> base64_state ) {\n case BASE64_STATE_0 : if ( base64_is_valid_char ( chr ) ) part -> base64_state ++ ;\n else if ( chr == '\\r' ) part -> base64_state = BASE64_STATE_CR ;\n else if ( chr == '\\n' ) {\n return astream_base64_decode_lf ( part ) ;\n }\n else {\n return - 1 ;\n }\n break ;\n case BASE64_STATE_1 : if ( ! base64_is_valid_char ( chr ) ) return - 1 ;\n part -> base64_state ++ ;\n break ;\n case BASE64_STATE_2 : if ( base64_is_valid_char ( chr ) ) part -> base64_state ++ ;\n else if ( chr == '=' ) part -> base64_state = BASE64_STATE_EOB ;\n else return - 1 ;\n break ;\n case BASE64_STATE_3 : part -> base64_bytes = part -> temp_output -> offset + pos + 1 ;\n if ( base64_is_valid_char ( chr ) ) {\n part -> base64_state = BASE64_STATE_0 ;\n part -> cur_base64_blocks ++ ;\n }\n else if ( chr == '=' ) {\n part -> base64_state = BASE64_STATE_EOM ;\n part -> cur_base64_blocks ++ ;\n if ( part -> cur_base64_blocks > part -> base64_line_blocks && part -> base64_line_blocks > 0 ) {\n return - 1 ;\n }\n return 0 ;\n }\n else {\n return - 1 ;\n }\n break ;\n case BASE64_STATE_CR : if ( chr != '\\n' ) return - 1 ;\n if ( ! part -> base64_have_crlf ) {\n if ( part -> base64_line_blocks != 0 ) {\n return - 1 ;\n }\n part -> base64_have_crlf = TRUE ;\n }\n return astream_base64_decode_lf ( part ) ;\n case BASE64_STATE_EOB : if ( chr != '=' ) return - 1 ;\n part -> base64_bytes = part -> temp_output -> offset + pos + 1 ;\n part -> base64_state = BASE64_STATE_EOM ;\n part -> cur_base64_blocks ++ ;\n if ( part -> cur_base64_blocks > part -> base64_line_blocks && part -> base64_line_blocks > 0 ) {\n return - 1 ;\n }\n return 0 ;\n case BASE64_STATE_EOM : i_unreached ( ) ;\n }\n return 1 ;\n }", "idx": 20464}
{"hash": 2687336064028423153, "project": "chrome", "size": 5, "label": 0, "functionSource": "int evdns_server_request_drop ( struct evdns_server_request * _req ) {\n struct server_request * req = TO_SERVER_REQUEST ( _req ) ;\n server_request_free ( req ) ;\n return 0 ;\n }", "idx": 20465}
{"hash": -3847447574854829409, "project": "chrome", "size": 19, "label": 0, "functionSource": "static int32_t strcmpAfterPrefix ( const char * s1 , const char * s2 , int32_t * pPrefixLength ) {\n int32_t pl = * pPrefixLength ;\n int32_t cmp = 0 ;\n s1 += pl ;\n s2 += pl ;\n for ( ;\n ;\n ) {\n int32_t c1 = ( uint8_t ) * s1 ++ ;\n int32_t c2 = ( uint8_t ) * s2 ++ ;\n cmp = c1 - c2 ;\n if ( cmp != 0 || c1 == 0 ) {\n break ;\n }\n ++ pl ;\n }\n * pPrefixLength = pl ;\n return cmp ;\n }", "idx": 20466}
{"hash": 6298409723927571872, "project": "chrome", "size": 52, "label": 0, "functionSource": "static inline void set_myanmar_properties ( hb_glyph_info_t & info ) {\n hb_codepoint_t u = info . codepoint ;\n unsigned int type = hb_indic_get_categories ( u ) ;\n indic_category_t cat = ( indic_category_t ) ( type & 0x7Fu ) ;\n indic_position_t pos = ( indic_position_t ) ( type >> 8 ) ;\n if ( unlikely ( hb_in_range ( u , 0xFE00u , 0xFE0Fu ) ) ) cat = ( indic_category_t ) OT_VS ;\n switch ( u ) {\n case 0x104Eu : cat = ( indic_category_t ) OT_C ;\n break ;\n case 0x002Du : case 0x00A0u : case 0x00D7u : case 0x2012u : case 0x2013u : case 0x2014u : case 0x2015u : case 0x2022u : case 0x25CCu : case 0x25FBu : case 0x25FCu : case 0x25FDu : case 0x25FEu : cat = ( indic_category_t ) OT_GB ;\n break ;\n case 0x1004u : case 0x101Bu : case 0x105Au : cat = ( indic_category_t ) OT_Ra ;\n break ;\n case 0x1032u : case 0x1036u : cat = ( indic_category_t ) OT_A ;\n break ;\n case 0x103Au : cat = ( indic_category_t ) OT_As ;\n break ;\n case 0x1041u : case 0x1042u : case 0x1043u : case 0x1044u : case 0x1045u : case 0x1046u : case 0x1047u : case 0x1048u : case 0x1049u : case 0x1090u : case 0x1091u : case 0x1092u : case 0x1093u : case 0x1094u : case 0x1095u : case 0x1096u : case 0x1097u : case 0x1098u : case 0x1099u : cat = ( indic_category_t ) OT_D ;\n break ;\n case 0x1040u : cat = ( indic_category_t ) OT_D ;\n break ;\n case 0x103Eu : case 0x1060u : cat = ( indic_category_t ) OT_MH ;\n break ;\n case 0x103Cu : cat = ( indic_category_t ) OT_MR ;\n break ;\n case 0x103Du : case 0x1082u : cat = ( indic_category_t ) OT_MW ;\n break ;\n case 0x103Bu : case 0x105Eu : case 0x105Fu : cat = ( indic_category_t ) OT_MY ;\n break ;\n case 0x1063u : case 0x1064u : case 0x1069u : case 0x106Au : case 0x106Bu : case 0x106Cu : case 0x106Du : case 0xAA7Bu : cat = ( indic_category_t ) OT_PT ;\n break ;\n case 0x1038u : case 0x1087u : case 0x1088u : case 0x1089u : case 0x108Au : case 0x108Bu : case 0x108Cu : case 0x108Du : case 0x108Fu : case 0x109Au : case 0x109Bu : case 0x109Cu : cat = ( indic_category_t ) OT_SM ;\n break ;\n case 0x104Au : case 0x104Bu : cat = ( indic_category_t ) OT_P ;\n break ;\n }\n if ( cat == OT_M ) {\n switch ( ( int ) pos ) {\n case POS_PRE_C : cat = ( indic_category_t ) OT_VPre ;\n pos = POS_PRE_M ;\n break ;\n case POS_ABOVE_C : cat = ( indic_category_t ) OT_VAbv ;\n break ;\n case POS_BELOW_C : cat = ( indic_category_t ) OT_VBlw ;\n break ;\n case POS_POST_C : cat = ( indic_category_t ) OT_VPst ;\n break ;\n }\n }\n info . myanmar_category ( ) = ( myanmar_category_t ) cat ;\n info . myanmar_position ( ) = pos ;\n }", "idx": 20467}
{"hash": -7777331401175181229, "project": "debian", "size": 89, "label": 0, "functionSource": "static void cmd_server_add_modify ( const char * data , gboolean add ) {\n GHashTable * optlist ;\n SERVER_SETUP_REC * rec ;\n char * addr , * portstr , * password , * value , * chatnet ;\n void * free_arg ;\n int port ;\n if ( ! cmd_get_params ( data , & free_arg , 3 | PARAM_FLAG_OPTIONS , \"server add\" , & optlist , & addr , & portstr , & password ) ) return ;\n if ( * addr == '\\0' ) cmd_param_error ( CMDERR_NOT_ENOUGH_PARAMS ) ;\n value = g_hash_table_lookup ( optlist , \"port\" ) ;\n if ( * portstr != '\\0' ) port = atoi ( portstr ) ;\n else if ( value != NULL && * value != '\\0' ) port = atoi ( value ) ;\n else if ( g_hash_table_lookup ( optlist , \"tls\" ) || g_hash_table_lookup ( optlist , \"ssl\" ) ) port = DEFAULT_SERVER_ADD_TLS_PORT ;\n else port = DEFAULT_SERVER_ADD_PORT ;\n chatnet = g_hash_table_lookup ( optlist , \"network\" ) ;\n rec = server_setup_find ( addr , port , chatnet ) ;\n if ( rec == NULL ) {\n if ( add == FALSE ) {\n printformat ( NULL , NULL , MSGLEVEL_CLIENTNOTICE , TXT_SETUPSERVER_NOT_FOUND , addr , port ) ;\n cmd_params_free ( free_arg ) ;\n return ;\n }\n rec = create_server_setup ( optlist ) ;\n if ( rec == NULL ) {\n cmd_params_free ( free_arg ) ;\n return ;\n }\n rec -> address = g_strdup ( addr ) ;\n rec -> port = port ;\n }\n else {\n if ( * portstr != '\\0' || g_hash_table_lookup ( optlist , \"port\" ) ) rec -> port = port ;\n if ( * password != '\\0' ) g_free_and_null ( rec -> password ) ;\n if ( g_hash_table_lookup ( optlist , \"host\" ) ) {\n g_free_and_null ( rec -> own_host ) ;\n rec -> own_ip4 = rec -> own_ip6 = NULL ;\n }\n }\n if ( g_hash_table_lookup ( optlist , \"6\" ) ) rec -> family = AF_INET6 ;\n else if ( g_hash_table_lookup ( optlist , \"4\" ) ) rec -> family = AF_INET ;\n if ( g_hash_table_lookup ( optlist , \"tls\" ) || g_hash_table_lookup ( optlist , \"ssl\" ) ) {\n rec -> use_tls = TRUE ;\n }\n else if ( g_hash_table_lookup ( optlist , \"notls\" ) || g_hash_table_lookup ( optlist , \"nossl\" ) ) {\n rec -> use_tls = FALSE ;\n rec -> tls_verify = FALSE ;\n }\n value = g_hash_table_lookup ( optlist , \"tls_cert\" ) ;\n if ( value == NULL ) value = g_hash_table_lookup ( optlist , \"ssl_cert\" ) ;\n if ( value != NULL && * value != '\\0' ) rec -> tls_cert = g_strdup ( value ) ;\n value = g_hash_table_lookup ( optlist , \"tls_pkey\" ) ;\n if ( value == NULL ) value = g_hash_table_lookup ( optlist , \"ssl_pkey\" ) ;\n if ( value != NULL && * value != '\\0' ) rec -> tls_pkey = g_strdup ( value ) ;\n value = g_hash_table_lookup ( optlist , \"tls_pass\" ) ;\n if ( value == NULL ) value = g_hash_table_lookup ( optlist , \"ssl_pass\" ) ;\n if ( value != NULL && * value != '\\0' ) rec -> tls_pass = g_strdup ( value ) ;\n if ( g_hash_table_lookup ( optlist , \"tls_verify\" ) || g_hash_table_lookup ( optlist , \"ssl_verify\" ) ) rec -> tls_verify = TRUE ;\n else if ( g_hash_table_lookup ( optlist , \"notls_verify\" ) || g_hash_table_lookup ( optlist , \"nossl_verify\" ) ) rec -> tls_verify = FALSE ;\n value = g_hash_table_lookup ( optlist , \"tls_cafile\" ) ;\n if ( value == NULL ) value = g_hash_table_lookup ( optlist , \"ssl_cafile\" ) ;\n if ( value != NULL && * value != '\\0' ) rec -> tls_cafile = g_strdup ( value ) ;\n value = g_hash_table_lookup ( optlist , \"tls_capath\" ) ;\n if ( value == NULL ) value = g_hash_table_lookup ( optlist , \"ssl_capath\" ) ;\n if ( value != NULL && * value != '\\0' ) rec -> tls_capath = g_strdup ( value ) ;\n value = g_hash_table_lookup ( optlist , \"tls_ciphers\" ) ;\n if ( value == NULL ) value = g_hash_table_lookup ( optlist , \"ssl_ciphers\" ) ;\n if ( value != NULL && * value != '\\0' ) rec -> tls_ciphers = g_strdup ( value ) ;\n value = g_hash_table_lookup ( optlist , \"tls_pinned_cert\" ) ;\n if ( value == NULL ) value = g_hash_table_lookup ( optlist , \"ssl_pinned_cert\" ) ;\n if ( value != NULL && * value != '\\0' ) rec -> tls_pinned_cert = g_strdup ( value ) ;\n value = g_hash_table_lookup ( optlist , \"tls_pinned_pubkey\" ) ;\n if ( value == NULL ) value = g_hash_table_lookup ( optlist , \"ssl_pinned_pubkey\" ) ;\n if ( value != NULL && * value != '\\0' ) rec -> tls_pinned_pubkey = g_strdup ( value ) ;\n if ( ( rec -> tls_cafile != NULL && rec -> tls_cafile [ 0 ] != '\\0' ) || ( rec -> tls_capath != NULL && rec -> tls_capath [ 0 ] != '\\0' ) ) rec -> tls_verify = TRUE ;\n if ( ( rec -> tls_cert != NULL && rec -> tls_cert [ 0 ] != '\\0' ) || rec -> tls_verify == TRUE ) rec -> use_tls = TRUE ;\n if ( g_hash_table_lookup ( optlist , \"auto\" ) ) rec -> autoconnect = TRUE ;\n if ( g_hash_table_lookup ( optlist , \"noauto\" ) ) rec -> autoconnect = FALSE ;\n if ( g_hash_table_lookup ( optlist , \"proxy\" ) ) rec -> no_proxy = FALSE ;\n if ( g_hash_table_lookup ( optlist , \"noproxy\" ) ) rec -> no_proxy = TRUE ;\n if ( * password != '\\0' && g_strcmp0 ( password , \"-\" ) != 0 ) rec -> password = g_strdup ( password ) ;\n value = g_hash_table_lookup ( optlist , \"host\" ) ;\n if ( value != NULL && * value != '\\0' ) {\n rec -> own_host = g_strdup ( value ) ;\n rec -> own_ip4 = rec -> own_ip6 = NULL ;\n }\n signal_emit ( \"server add fill\" , 2 , rec , optlist ) ;\n server_setup_add ( rec ) ;\n printformat ( NULL , NULL , MSGLEVEL_CLIENTNOTICE , TXT_SETUPSERVER_ADDED , addr , port ) ;\n cmd_params_free ( free_arg ) ;\n }", "idx": 20468}
{"hash": -5992472514718425579, "project": "debian", "size": 21, "label": 0, "functionSource": "static char * lxc_cgroup_find_abs_path ( const char * subsystem , const char * group , bool should_be_writable , const char * suffix ) {\n struct cgroup_meta_data * meta_data ;\n struct cgroup_hierarchy * h ;\n struct cgroup_mount_point * mp ;\n char * result ;\n int saved_errno ;\n meta_data = lxc_cgroup_load_meta ( ) ;\n if ( ! meta_data ) return NULL ;\n h = lxc_cgroup_find_hierarchy ( meta_data , subsystem ) ;\n if ( ! h ) goto out_error ;\n mp = lxc_cgroup_find_mount_point ( h , group , should_be_writable ) ;\n if ( ! mp ) goto out_error ;\n result = cgroup_to_absolute_path ( mp , group , suffix ) ;\n if ( ! result ) goto out_error ;\n lxc_cgroup_put_meta ( meta_data ) ;\n return result ;\n out_error : saved_errno = errno ;\n lxc_cgroup_put_meta ( meta_data ) ;\n errno = saved_errno ;\n return NULL ;\n }", "idx": 20469}
{"hash": -6856626433814917486, "project": "debian", "size": 163, "label": 0, "functionSource": "static gint dissect_capabilities ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , gint offset , gint * codec , gint * content_protection_type , guint32 * vendor_id , guint16 * vendor_codec , guint32 * configuration_offset , guint8 * configuration_length ) {\n proto_item * pitem = NULL ;\n proto_item * ptree = NULL ;\n proto_tree * capabilities_tree ;\n proto_item * capabilities_item ;\n proto_tree * service_tree = NULL ;\n proto_item * service_item = NULL ;\n gint service_category = 0 ;\n gint losc = 0 ;\n gint recovery_type = 0 ;\n gint maximum_recovery_window_size = 0 ;\n gint maximum_number_of_media_packet_in_parity_code = 0 ;\n gint media_type = 0 ;\n gint media_codec_type = 0 ;\n capabilities_item = proto_tree_add_item ( tree , hf_btavdtp_capabilities , tvb , offset , tvb_reported_length ( tvb ) - offset , ENC_NA ) ;\n capabilities_tree = proto_item_add_subtree ( capabilities_item , ett_btavdtp_capabilities ) ;\n if ( codec ) * codec = - 1 ;\n if ( vendor_id ) * vendor_id = 0x003F ;\n if ( vendor_codec ) * vendor_codec = 0 ;\n if ( configuration_length ) * configuration_length = 0 ;\n if ( configuration_offset ) * configuration_offset = 0 ;\n while ( tvb_reported_length_remaining ( tvb , offset ) > 0 ) {\n service_category = tvb_get_guint8 ( tvb , offset ) ;\n losc = tvb_get_guint8 ( tvb , offset + 1 ) ;\n service_item = proto_tree_add_none_format ( capabilities_tree , hf_btavdtp_service , tvb , offset , 2 + losc , \"Service: %s\" , val_to_str_const ( service_category , service_category_vals , \"RFD\" ) ) ;\n service_tree = proto_item_add_subtree ( service_item , ett_btavdtp_service ) ;\n proto_tree_add_item ( service_tree , hf_btavdtp_service_category , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( service_tree , hf_btavdtp_length_of_service_category , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n switch ( service_category ) {\n case SERVICE_CATEGORY_MEDIA_TRANSPORT : case SERVICE_CATEGORY_REPORTING : case SERVICE_CATEGORY_DELAY_REPORTING : break ;\n case SERVICE_CATEGORY_RECOVERY : recovery_type = tvb_get_guint8 ( tvb , offset ) ;\n pitem = proto_tree_add_item ( service_tree , hf_btavdtp_recovery_type , tvb , offset , 1 , ENC_NA ) ;\n proto_item_append_text ( pitem , \" (%s)\" , val_to_str_const ( recovery_type , recovery_type_vals , \"RFD\" ) ) ;\n offset += 1 ;\n losc -= 1 ;\n maximum_recovery_window_size = tvb_get_guint8 ( tvb , offset ) ;\n pitem = proto_tree_add_item ( service_tree , hf_btavdtp_maximum_recovery_window_size , tvb , offset , 1 , ENC_NA ) ;\n if ( maximum_recovery_window_size == 0x00 ) {\n proto_item_append_text ( pitem , \" (Forbidden)\" ) ;\n }\n else if ( maximum_recovery_window_size >= 0x18 ) {\n proto_item_append_text ( pitem , \" (Undocumented)\" ) ;\n }\n offset += 1 ;\n losc -= 1 ;\n maximum_number_of_media_packet_in_parity_code = tvb_get_guint8 ( tvb , offset ) ;\n proto_tree_add_item ( service_tree , hf_btavdtp_maximum_number_of_media_packet_in_parity_code , tvb , offset , 1 , ENC_NA ) ;\n pitem = proto_tree_add_item ( service_tree , hf_btavdtp_maximum_recovery_window_size , tvb , offset , 1 , ENC_NA ) ;\n if ( maximum_number_of_media_packet_in_parity_code == 0x00 ) {\n proto_item_append_text ( pitem , \" (Forbidden)\" ) ;\n }\n else if ( maximum_number_of_media_packet_in_parity_code >= 0x18 ) {\n proto_item_append_text ( pitem , \" (Undocumented)\" ) ;\n }\n offset += 1 ;\n losc -= 1 ;\n break ;\n case SERVICE_CATEGORY_MEDIA_CODEC : if ( configuration_length ) * configuration_length = losc ;\n if ( configuration_offset ) * configuration_offset = offset ;\n media_type = tvb_get_guint8 ( tvb , offset ) >> 4 ;\n proto_tree_add_item ( service_tree , hf_btavdtp_media_codec_media_type , tvb , offset , 1 , ENC_NA ) ;\n proto_tree_add_item ( service_tree , hf_btavdtp_media_codec_rfa , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n losc -= 1 ;\n media_codec_type = tvb_get_guint8 ( tvb , offset ) ;\n if ( codec ) {\n * codec = media_codec_type ;\n }\n if ( media_type == MEDIA_TYPE_AUDIO ) {\n proto_tree_add_item ( service_tree , hf_btavdtp_media_codec_audio_type , tvb , offset , 1 , ENC_NA ) ;\n proto_item_append_text ( service_item , \" - Audio %s\" , val_to_str_const ( media_codec_type , media_codec_audio_type_vals , \"unknown codec\" ) ) ;\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \" - Audio %s\" , val_to_str_const ( media_codec_type , media_codec_audio_type_vals , \"unknown codec\" ) ) ;\n }\n else if ( media_type == MEDIA_TYPE_VIDEO ) {\n proto_tree_add_item ( service_tree , hf_btavdtp_media_codec_video_type , tvb , offset , 1 , ENC_NA ) ;\n proto_item_append_text ( service_item , \" - Video %s\" , val_to_str_const ( media_codec_type , media_codec_video_type_vals , \"unknown codec\" ) ) ;\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \" - Video %s\" , val_to_str_const ( media_codec_type , media_codec_video_type_vals , \"unknown codec\" ) ) ;\n }\n else {\n proto_tree_add_item ( service_tree , hf_btavdtp_media_codec_unknown_type , tvb , offset , 1 , ENC_NA ) ;\n proto_item_append_text ( service_item , \" - Unknown 0x%02x\" , media_codec_type ) ;\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \" - Unknown 0x%02x\" , media_codec_type ) ;\n }\n offset += 1 ;\n losc -= 1 ;\n offset = dissect_codec ( tvb , pinfo , service_item , service_tree , offset , losc , media_type , media_codec_type , vendor_id , vendor_codec ) ;\n losc = 0 ;\n break ;\n case SERVICE_CATEGORY_CONTENT_PROTECTION : proto_tree_add_item ( service_tree , hf_btavdtp_content_protection_type , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n if ( content_protection_type ) {\n * content_protection_type = tvb_get_letohs ( tvb , offset ) ;\n }\n proto_item_append_text ( service_item , \" - %s\" , val_to_str_const ( tvb_get_letohs ( tvb , offset ) , content_protection_type_vals , \"unknown\" ) ) ;\n offset += 2 ;\n losc -= 2 ;\n if ( losc > 0 ) {\n proto_tree_add_item ( service_tree , hf_btavdtp_data , tvb , offset , losc , ENC_NA ) ;\n offset += losc ;\n losc = 0 ;\n }\n break ;\n case SERVICE_CATEGORY_HEADER_COMPRESSION : proto_tree_add_item ( service_tree , hf_btavdtp_header_compression_backch , tvb , offset , 1 , ENC_NA ) ;\n proto_tree_add_item ( service_tree , hf_btavdtp_header_compression_media , tvb , offset , 1 , ENC_NA ) ;\n proto_tree_add_item ( service_tree , hf_btavdtp_header_compression_recovery , tvb , offset , 1 , ENC_NA ) ;\n proto_tree_add_item ( service_tree , hf_btavdtp_header_compression_rfa , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n losc -= 1 ;\n break ;\n case SERVICE_CATEGORY_MULTIPLEXING : proto_tree_add_item ( service_tree , hf_btavdtp_multiplexing_fragmentation , tvb , offset , 1 , ENC_NA ) ;\n proto_tree_add_item ( service_tree , hf_btavdtp_multiplexing_rfa , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n losc -= 1 ;\n if ( losc >= 2 ) {\n pitem = proto_tree_add_none_format ( service_tree , hf_btavdtp_service_multiplexing_entry , tvb , offset , 1 + losc , \"Entry: Media Transport Session\" ) ;\n ptree = proto_item_add_subtree ( pitem , ett_btavdtp_service ) ;\n proto_tree_add_item ( ptree , hf_btavdtp_multiplexing_tsid , tvb , offset , 1 , ENC_NA ) ;\n proto_tree_add_item ( ptree , hf_btavdtp_multiplexing_entry_rfa , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n losc -= 1 ;\n proto_tree_add_item ( ptree , hf_btavdtp_multiplexing_tcid , tvb , offset , 1 , ENC_NA ) ;\n proto_tree_add_item ( ptree , hf_btavdtp_multiplexing_entry_rfa , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n losc -= 1 ;\n }\n if ( losc >= 2 ) {\n pitem = proto_tree_add_none_format ( service_tree , hf_btavdtp_service_multiplexing_entry , tvb , offset , 1 + losc , \"Entry: Reporting Transport Session\" ) ;\n ptree = proto_item_add_subtree ( pitem , ett_btavdtp_service ) ;\n proto_tree_add_item ( ptree , hf_btavdtp_multiplexing_tsid , tvb , offset , 1 , ENC_NA ) ;\n proto_tree_add_item ( ptree , hf_btavdtp_multiplexing_entry_rfa , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n losc -= 1 ;\n proto_tree_add_item ( ptree , hf_btavdtp_multiplexing_tcid , tvb , offset , 1 , ENC_NA ) ;\n proto_tree_add_item ( ptree , hf_btavdtp_multiplexing_entry_rfa , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n losc -= 1 ;\n }\n if ( losc >= 2 ) {\n pitem = proto_tree_add_none_format ( service_tree , hf_btavdtp_service_multiplexing_entry , tvb , offset , 1 + losc , \"Entry: Recovery Transport Session\" ) ;\n ptree = proto_item_add_subtree ( pitem , ett_btavdtp_service ) ;\n proto_tree_add_item ( ptree , hf_btavdtp_multiplexing_tsid , tvb , offset , 1 , ENC_NA ) ;\n proto_tree_add_item ( ptree , hf_btavdtp_multiplexing_entry_rfa , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n losc -= 1 ;\n proto_tree_add_item ( ptree , hf_btavdtp_multiplexing_tcid , tvb , offset , 1 , ENC_NA ) ;\n proto_tree_add_item ( ptree , hf_btavdtp_multiplexing_entry_rfa , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n losc -= 1 ;\n }\n break ;\n default : proto_tree_add_item ( service_tree , hf_btavdtp_data , tvb , offset , losc , ENC_NA ) ;\n offset += losc ;\n losc = 0 ;\n }\n if ( losc > 0 ) {\n pitem = proto_tree_add_item ( service_tree , hf_btavdtp_data , tvb , offset , losc , ENC_NA ) ;\n offset += losc ;\n expert_add_info ( pinfo , pitem , & ei_btavdtp_unexpected_losc_data ) ;\n }\n }\n return offset ;\n }", "idx": 20470}
{"hash": 6393050609822897742, "project": "debian", "size": 113, "label": 0, "functionSource": "static void xhci_kick_epctx ( XHCIEPContext * epctx , unsigned int streamid ) {\n XHCIState * xhci = epctx -> xhci ;\n XHCIStreamContext * stctx ;\n XHCITransfer * xfer ;\n XHCIRing * ring ;\n USBEndpoint * ep = NULL ;\n uint64_t mfindex ;\n int length ;\n int i ;\n trace_usb_xhci_ep_kick ( epctx -> slotid , epctx -> epid , streamid ) ;\n assert ( ! epctx -> kick_active ) ;\n if ( ! xhci -> slots [ epctx -> slotid - 1 ] . uport || ! xhci -> slots [ epctx -> slotid - 1 ] . uport -> dev || ! xhci -> slots [ epctx -> slotid - 1 ] . uport -> dev -> attached ) {\n return ;\n }\n if ( epctx -> retry ) {\n XHCITransfer * xfer = epctx -> retry ;\n trace_usb_xhci_xfer_retry ( xfer ) ;\n assert ( xfer -> running_retry ) ;\n if ( xfer -> timed_xfer ) {\n mfindex = xhci_mfindex_get ( xhci ) ;\n xhci_check_intr_iso_kick ( xhci , xfer , epctx , mfindex ) ;\n if ( xfer -> running_retry ) {\n return ;\n }\n xfer -> timed_xfer = 0 ;\n xfer -> running_retry = 1 ;\n }\n if ( xfer -> iso_xfer ) {\n if ( xhci_setup_packet ( xfer ) < 0 ) {\n return ;\n }\n usb_handle_packet ( xfer -> packet . ep -> dev , & xfer -> packet ) ;\n assert ( xfer -> packet . status != USB_RET_NAK ) ;\n xhci_try_complete_packet ( xfer ) ;\n }\n else {\n if ( xhci_setup_packet ( xfer ) < 0 ) {\n return ;\n }\n usb_handle_packet ( xfer -> packet . ep -> dev , & xfer -> packet ) ;\n if ( xfer -> packet . status == USB_RET_NAK ) {\n return ;\n }\n xhci_try_complete_packet ( xfer ) ;\n }\n assert ( ! xfer -> running_retry ) ;\n if ( xfer -> complete ) {\n xhci_ep_free_xfer ( epctx -> retry ) ;\n }\n epctx -> retry = NULL ;\n }\n if ( epctx -> state == EP_HALTED ) {\n DPRINTF ( \"xhci: ep halted, not running schedule\\n\" ) ;\n return ;\n }\n if ( epctx -> nr_pstreams ) {\n uint32_t err ;\n stctx = xhci_find_stream ( epctx , streamid , & err ) ;\n if ( stctx == NULL ) {\n return ;\n }\n ring = & stctx -> ring ;\n xhci_set_ep_state ( xhci , epctx , stctx , EP_RUNNING ) ;\n }\n else {\n ring = & epctx -> ring ;\n streamid = 0 ;\n xhci_set_ep_state ( xhci , epctx , NULL , EP_RUNNING ) ;\n }\n assert ( ring -> dequeue != 0 ) ;\n epctx -> kick_active ++ ;\n while ( 1 ) {\n length = xhci_ring_chain_length ( xhci , ring ) ;\n if ( length <= 0 ) {\n break ;\n }\n xfer = xhci_ep_alloc_xfer ( epctx , length ) ;\n if ( xfer == NULL ) {\n break ;\n }\n for ( i = 0 ;\n i < length ;\n i ++ ) {\n TRBType type ;\n type = xhci_ring_fetch ( xhci , ring , & xfer -> trbs [ i ] , NULL ) ;\n assert ( type ) ;\n }\n xfer -> streamid = streamid ;\n if ( epctx -> epid == 1 ) {\n xhci_fire_ctl_transfer ( xhci , xfer ) ;\n }\n else {\n xhci_fire_transfer ( xhci , xfer , epctx ) ;\n }\n if ( xfer -> complete ) {\n xhci_ep_free_xfer ( xfer ) ;\n xfer = NULL ;\n }\n if ( epctx -> state == EP_HALTED ) {\n break ;\n }\n if ( xfer != NULL && xfer -> running_retry ) {\n DPRINTF ( \"xhci: xfer nacked, stopping schedule\\n\" ) ;\n epctx -> retry = xfer ;\n break ;\n }\n }\n epctx -> kick_active -- ;\n ep = xhci_epid_to_usbep ( epctx ) ;\n if ( ep ) {\n usb_device_flush_ep_queue ( ep -> dev , ep ) ;\n }\n }", "idx": 20471}
{"hash": -5357254031401749470, "project": "debian", "size": 7, "label": 0, "functionSource": "static int resume_error ( lua_State * L , const char * msg ) {\n L -> top = L -> ci -> base ;\n setsvalue2s ( L , L -> top , luaS_new ( L , msg ) ) ;\n incr_top ( L ) ;\n lua_unlock ( L ) ;\n return LUA_ERRRUN ;\n }", "idx": 20472}
{"hash": 1760449185745615462, "project": "debian", "size": 12, "label": 0, "functionSource": "TSReturnCode TSMimeHdrFieldValueIntInsert ( TSMBuffer bufp , TSMLoc hdr , TSMLoc field , int idx , int value ) {\n sdk_assert ( sdk_sanity_check_mbuffer ( bufp ) == TS_SUCCESS ) ;\n sdk_assert ( ( sdk_sanity_check_mime_hdr_handle ( hdr ) == TS_SUCCESS ) || ( sdk_sanity_check_http_hdr_handle ( hdr ) == TS_SUCCESS ) ) ;\n sdk_assert ( sdk_sanity_check_field_handle ( field , hdr ) == TS_SUCCESS ) ;\n if ( ! isWriteable ( bufp ) ) {\n return TS_ERROR ;\n }\n char tmp [ 16 ] ;\n int len = mime_format_int ( tmp , value , sizeof ( tmp ) ) ;\n TSMimeFieldValueInsert ( bufp , field , tmp , len , idx ) ;\n return TS_SUCCESS ;\n }", "idx": 20473}
{"hash": -341028540041678099, "project": "debian", "size": 3, "label": 0, "functionSource": "static void endoutput ( FILE * fp ) {\n if ( out_chars != 0 ) putc ( '\\n' , fp ) ;\n }", "idx": 20474}
{"hash": -2226094829431805196, "project": "debian", "size": 70, "label": 1, "functionSource": "static int jpc_pi_nextcprl ( register jpc_pi_t * pi ) {\n int rlvlno ;\n jpc_pirlvl_t * pirlvl ;\n jpc_pchg_t * pchg ;\n int prchind ;\n int prcvind ;\n int * prclyrno ;\n uint_fast32_t trx0 ;\n uint_fast32_t try0 ;\n uint_fast32_t r ;\n uint_fast32_t rpx ;\n uint_fast32_t rpy ;\n pchg = pi -> pchg ;\n if ( ! pi -> prgvolfirst ) {\n goto skip ;\n }\n else {\n pi -> prgvolfirst = 0 ;\n }\n for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ;\n pi -> compno < JAS_CAST ( int , pchg -> compnoend ) && pi -> compno < pi -> numcomps ;\n ++ pi -> compno , ++ pi -> picomp ) {\n pirlvl = pi -> picomp -> pirlvls ;\n pi -> xstep = pi -> picomp -> hsamp * ( 1 << ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls - 1 ) ) ;\n pi -> ystep = pi -> picomp -> vsamp * ( 1 << ( pirlvl -> prcheightexpn + pi -> picomp -> numrlvls - 1 ) ) ;\n for ( rlvlno = 1 , pirlvl = & pi -> picomp -> pirlvls [ 1 ] ;\n rlvlno < pi -> picomp -> numrlvls ;\n ++ rlvlno , ++ pirlvl ) {\n pi -> xstep = JAS_MIN ( pi -> xstep , pi -> picomp -> hsamp * ( 1 << ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls - rlvlno - 1 ) ) ) ;\n pi -> ystep = JAS_MIN ( pi -> ystep , pi -> picomp -> vsamp * ( 1 << ( pirlvl -> prcheightexpn + pi -> picomp -> numrlvls - rlvlno - 1 ) ) ) ;\n }\n for ( pi -> y = pi -> ystart ;\n pi -> y < pi -> yend ;\n pi -> y += pi -> ystep - ( pi -> y % pi -> ystep ) ) {\n for ( pi -> x = pi -> xstart ;\n pi -> x < pi -> xend ;\n pi -> x += pi -> xstep - ( pi -> x % pi -> xstep ) ) {\n for ( pi -> rlvlno = pchg -> rlvlnostart , pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ;\n pi -> rlvlno < pi -> picomp -> numrlvls && pi -> rlvlno < pchg -> rlvlnoend ;\n ++ pi -> rlvlno , ++ pi -> pirlvl ) {\n if ( pi -> pirlvl -> numprcs == 0 ) {\n continue ;\n }\n r = pi -> picomp -> numrlvls - 1 - pi -> rlvlno ;\n trx0 = JPC_CEILDIV ( pi -> xstart , pi -> picomp -> hsamp << r ) ;\n try0 = JPC_CEILDIV ( pi -> ystart , pi -> picomp -> vsamp << r ) ;\n rpx = r + pi -> pirlvl -> prcwidthexpn ;\n rpy = r + pi -> pirlvl -> prcheightexpn ;\n if ( ( ( pi -> x == pi -> xstart && ( ( trx0 << r ) % ( 1 << rpx ) ) ) || ! ( pi -> x % ( pi -> picomp -> hsamp << rpx ) ) ) && ( ( pi -> y == pi -> ystart && ( ( try0 << r ) % ( 1 << rpy ) ) ) || ! ( pi -> y % ( pi -> picomp -> vsamp << rpy ) ) ) ) {\n prchind = JPC_FLOORDIVPOW2 ( JPC_CEILDIV ( pi -> x , pi -> picomp -> hsamp << r ) , pi -> pirlvl -> prcwidthexpn ) - JPC_FLOORDIVPOW2 ( trx0 , pi -> pirlvl -> prcwidthexpn ) ;\n prcvind = JPC_FLOORDIVPOW2 ( JPC_CEILDIV ( pi -> y , pi -> picomp -> vsamp << r ) , pi -> pirlvl -> prcheightexpn ) - JPC_FLOORDIVPOW2 ( try0 , pi -> pirlvl -> prcheightexpn ) ;\n pi -> prcno = prcvind * pi -> pirlvl -> numhprcs + prchind ;\n assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ;\n for ( pi -> lyrno = 0 ;\n pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ;\n ++ pi -> lyrno ) {\n prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ;\n if ( pi -> lyrno >= * prclyrno ) {\n ++ ( * prclyrno ) ;\n return 0 ;\n }\n skip : ;\n }\n }\n }\n }\n }\n }\n return 1 ;\n }", "idx": 20475}
{"hash": 8460430819945784394, "project": "debian", "size": 2, "label": 0, "functionSource": "static void _PPC_ioB_write ( target_phys_addr_t addr , uint32_t value ) {\n }", "idx": 20476}
{"hash": 4976989049001279223, "project": "debian", "size": 10, "label": 0, "functionSource": "static char * http_str_store ( Arena * arena , const char * str , int length ) {\n const char * wks ;\n int idx = hdrtoken_tokenize ( str , length , & wks ) ;\n if ( idx < 0 ) {\n return arena -> str_store ( str , length ) ;\n }\n else {\n return ( char * ) wks ;\n }\n }", "idx": 20477}
{"hash": -7187272991279783781, "project": "debian", "size": 9, "label": 0, "functionSource": "static void apc_init ( hwaddr power_base , qemu_irq cpu_halt ) {\n DeviceState * dev ;\n SysBusDevice * s ;\n dev = qdev_create ( NULL , \"apc\" ) ;\n qdev_init_nofail ( dev ) ;\n s = SYS_BUS_DEVICE ( dev ) ;\n sysbus_mmio_map ( s , 0 , power_base ) ;\n sysbus_connect_irq ( s , 0 , cpu_halt ) ;\n }", "idx": 20478}
{"hash": -7136186224744987223, "project": "debian", "size": 11, "label": 0, "functionSource": "char * Curl_checkProxyheaders ( const struct connectdata * conn , const char * thisheader ) {\n struct curl_slist * head ;\n size_t thislen = strlen ( thisheader ) ;\n struct Curl_easy * data = conn -> data ;\n for ( head = ( conn -> bits . proxy && data -> set . sep_headers ) ? data -> set . proxyheaders : data -> set . headers ;\n head ;\n head = head -> next ) {\n if ( Curl_raw_nequal ( head -> data , thisheader , thislen ) ) return head -> data ;\n }\n return NULL ;\n }", "idx": 20479}
{"hash": 6709099320123900016, "project": "debian", "size": 224, "label": 1, "functionSource": "int ssl23_get_client_hello ( SSL * s ) {\n char buf_space [ 11 ] ;\n char * buf = & ( buf_space [ 0 ] ) ;\n unsigned char * p , * d , * d_len , * dd ;\n unsigned int i ;\n unsigned int csl , sil , cl ;\n int n = 0 , j ;\n int type = 0 ;\n int v [ 2 ] ;\n if ( s -> state == SSL23_ST_SR_CLNT_HELLO_A ) {\n v [ 0 ] = v [ 1 ] = 0 ;\n if ( ! ssl3_setup_buffers ( s ) ) goto err ;\n n = ssl23_read_bytes ( s , sizeof buf_space ) ;\n if ( n != sizeof buf_space ) return ( n ) ;\n p = s -> packet ;\n memcpy ( buf , p , n ) ;\n if ( ( p [ 0 ] & 0x80 ) && ( p [ 2 ] == SSL2_MT_CLIENT_HELLO ) ) {\n if ( ( p [ 3 ] == 0x00 ) && ( p [ 4 ] == 0x02 ) ) {\n v [ 0 ] = p [ 3 ] ;\n v [ 1 ] = p [ 4 ] ;\n if ( ! ( s -> options & SSL_OP_NO_SSLv2 ) ) type = 1 ;\n }\n else if ( p [ 3 ] == SSL3_VERSION_MAJOR ) {\n v [ 0 ] = p [ 3 ] ;\n v [ 1 ] = p [ 4 ] ;\n if ( p [ 4 ] >= TLS1_VERSION_MINOR ) {\n if ( p [ 4 ] >= TLS1_2_VERSION_MINOR && ! ( s -> options & SSL_OP_NO_TLSv1_2 ) ) {\n s -> version = TLS1_2_VERSION ;\n s -> state = SSL23_ST_SR_CLNT_HELLO_B ;\n }\n else if ( p [ 4 ] >= TLS1_1_VERSION_MINOR && ! ( s -> options & SSL_OP_NO_TLSv1_1 ) ) {\n s -> version = TLS1_1_VERSION ;\n s -> state = SSL23_ST_SR_CLNT_HELLO_B ;\n }\n else if ( ! ( s -> options & SSL_OP_NO_TLSv1 ) ) {\n s -> version = TLS1_VERSION ;\n s -> state = SSL23_ST_SR_CLNT_HELLO_B ;\n }\n else if ( ! ( s -> options & SSL_OP_NO_SSLv3 ) ) {\n s -> version = SSL3_VERSION ;\n s -> state = SSL23_ST_SR_CLNT_HELLO_B ;\n }\n else if ( ! ( s -> options & SSL_OP_NO_SSLv2 ) ) {\n type = 1 ;\n }\n }\n else if ( ! ( s -> options & SSL_OP_NO_SSLv3 ) ) {\n s -> version = SSL3_VERSION ;\n s -> state = SSL23_ST_SR_CLNT_HELLO_B ;\n }\n else if ( ! ( s -> options & SSL_OP_NO_SSLv2 ) ) type = 1 ;\n }\n }\n else if ( ( p [ 0 ] == SSL3_RT_HANDSHAKE ) && ( p [ 1 ] == SSL3_VERSION_MAJOR ) && ( p [ 5 ] == SSL3_MT_CLIENT_HELLO ) && ( ( p [ 3 ] == 0 && p [ 4 ] < 5 ) || ( p [ 9 ] >= p [ 1 ] ) ) ) {\n v [ 0 ] = p [ 1 ] ;\n if ( p [ 3 ] == 0 && p [ 4 ] < 6 ) {\n SSLerr ( SSL_F_SSL23_GET_CLIENT_HELLO , SSL_R_RECORD_TOO_SMALL ) ;\n goto err ;\n }\n if ( p [ 9 ] > SSL3_VERSION_MAJOR ) v [ 1 ] = 0xff ;\n else v [ 1 ] = p [ 10 ] ;\n if ( v [ 1 ] >= TLS1_VERSION_MINOR ) {\n if ( v [ 1 ] >= TLS1_2_VERSION_MINOR && ! ( s -> options & SSL_OP_NO_TLSv1_2 ) ) {\n s -> version = TLS1_2_VERSION ;\n type = 3 ;\n }\n else if ( v [ 1 ] >= TLS1_1_VERSION_MINOR && ! ( s -> options & SSL_OP_NO_TLSv1_1 ) ) {\n s -> version = TLS1_1_VERSION ;\n type = 3 ;\n }\n else if ( ! ( s -> options & SSL_OP_NO_TLSv1 ) ) {\n s -> version = TLS1_VERSION ;\n type = 3 ;\n }\n else if ( ! ( s -> options & SSL_OP_NO_SSLv3 ) ) {\n s -> version = SSL3_VERSION ;\n type = 3 ;\n }\n }\n else {\n if ( ! ( s -> options & SSL_OP_NO_SSLv3 ) ) {\n s -> version = SSL3_VERSION ;\n type = 3 ;\n }\n else if ( ! ( s -> options & SSL_OP_NO_TLSv1 ) ) {\n s -> version = TLS1_VERSION ;\n type = 3 ;\n }\n }\n }\n else if ( ( strncmp ( \"GET \" , ( char * ) p , 4 ) == 0 ) || ( strncmp ( \"POST \" , ( char * ) p , 5 ) == 0 ) || ( strncmp ( \"HEAD \" , ( char * ) p , 5 ) == 0 ) || ( strncmp ( \"PUT \" , ( char * ) p , 4 ) == 0 ) ) {\n SSLerr ( SSL_F_SSL23_GET_CLIENT_HELLO , SSL_R_HTTP_REQUEST ) ;\n goto err ;\n }\n else if ( strncmp ( \"CONNECT\" , ( char * ) p , 7 ) == 0 ) {\n SSLerr ( SSL_F_SSL23_GET_CLIENT_HELLO , SSL_R_HTTPS_PROXY_REQUEST ) ;\n goto err ;\n }\n }\n OPENSSL_assert ( s -> version <= TLS_MAX_VERSION ) ;\n # ifdef OPENSSL_FIPS if ( FIPS_mode ( ) && ( s -> version < TLS1_VERSION ) ) {\n SSLerr ( SSL_F_SSL23_GET_CLIENT_HELLO , SSL_R_ONLY_TLS_ALLOWED_IN_FIPS_MODE ) ;\n goto err ;\n }\n # endif if ( s -> state == SSL23_ST_SR_CLNT_HELLO_B ) {\n type = 2 ;\n p = s -> packet ;\n v [ 0 ] = p [ 3 ] ;\n v [ 1 ] = p [ 4 ] ;\n n = ( ( p [ 0 ] & 0x7f ) << 8 ) | p [ 1 ] ;\n if ( n > ( 1024 * 4 ) ) {\n SSLerr ( SSL_F_SSL23_GET_CLIENT_HELLO , SSL_R_RECORD_TOO_LARGE ) ;\n goto err ;\n }\n if ( n < 9 ) {\n SSLerr ( SSL_F_SSL23_GET_CLIENT_HELLO , SSL_R_RECORD_LENGTH_MISMATCH ) ;\n goto err ;\n }\n j = ssl23_read_bytes ( s , n + 2 ) ;\n if ( j <= 0 ) return ( j ) ;\n ssl3_finish_mac ( s , s -> packet + 2 , s -> packet_length - 2 ) ;\n if ( s -> msg_callback ) s -> msg_callback ( 0 , SSL2_VERSION , 0 , s -> packet + 2 , s -> packet_length - 2 , s , s -> msg_callback_arg ) ;\n p = s -> packet ;\n p += 5 ;\n n2s ( p , csl ) ;\n n2s ( p , sil ) ;\n n2s ( p , cl ) ;\n d = ( unsigned char * ) s -> init_buf -> data ;\n if ( ( csl + sil + cl + 11 ) != s -> packet_length ) {\n SSLerr ( SSL_F_SSL23_GET_CLIENT_HELLO , SSL_R_RECORD_LENGTH_MISMATCH ) ;\n goto err ;\n }\n * ( d ++ ) = SSL3_MT_CLIENT_HELLO ;\n d_len = d ;\n d += 3 ;\n * ( d ++ ) = SSL3_VERSION_MAJOR ;\n * ( d ++ ) = v [ 1 ] ;\n i = ( cl > SSL3_RANDOM_SIZE ) ? SSL3_RANDOM_SIZE : cl ;\n memset ( d , 0 , SSL3_RANDOM_SIZE ) ;\n memcpy ( & ( d [ SSL3_RANDOM_SIZE - i ] ) , & ( p [ csl + sil ] ) , i ) ;\n d += SSL3_RANDOM_SIZE ;\n * ( d ++ ) = 0 ;\n j = 0 ;\n dd = d ;\n d += 2 ;\n for ( i = 0 ;\n i < csl ;\n i += 3 ) {\n if ( p [ i ] != 0 ) continue ;\n * ( d ++ ) = p [ i + 1 ] ;\n * ( d ++ ) = p [ i + 2 ] ;\n j += 2 ;\n }\n s2n ( j , dd ) ;\n * ( d ++ ) = 1 ;\n * ( d ++ ) = 0 ;\n # if 0 p = p + csl + sil + cl ;\n while ( p < s -> packet + s -> packet_length ) {\n * ( d ++ ) = * ( p ++ ) ;\n }\n # endif i = ( d - ( unsigned char * ) s -> init_buf -> data ) - 4 ;\n l2n3 ( ( long ) i , d_len ) ;\n s -> s3 -> tmp . reuse_message = 1 ;\n s -> s3 -> tmp . message_type = SSL3_MT_CLIENT_HELLO ;\n s -> s3 -> tmp . message_size = i ;\n }\n if ( type == 1 ) {\n # ifdef OPENSSL_NO_SSL2 SSLerr ( SSL_F_SSL23_GET_CLIENT_HELLO , SSL_R_UNSUPPORTED_PROTOCOL ) ;\n goto err ;\n # else if ( s -> s2 == NULL ) {\n if ( ! ssl2_new ( s ) ) goto err ;\n }\n else ssl2_clear ( s ) ;\n if ( s -> s3 != NULL ) ssl3_free ( s ) ;\n if ( ! BUF_MEM_grow_clean ( s -> init_buf , SSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER ) ) {\n goto err ;\n }\n s -> state = SSL2_ST_GET_CLIENT_HELLO_A ;\n if ( s -> options & SSL_OP_NO_TLSv1 && s -> options & SSL_OP_NO_SSLv3 ) s -> s2 -> ssl2_rollback = 0 ;\n else s -> s2 -> ssl2_rollback = 1 ;\n s -> rstate = SSL_ST_READ_HEADER ;\n s -> packet_length = n ;\n s -> packet = & ( s -> s2 -> rbuf [ 0 ] ) ;\n memcpy ( s -> packet , buf , n ) ;\n s -> s2 -> rbuf_left = n ;\n s -> s2 -> rbuf_offs = 0 ;\n s -> method = SSLv2_server_method ( ) ;\n s -> handshake_func = s -> method -> ssl_accept ;\n # endif }\n if ( ( type == 2 ) || ( type == 3 ) ) {\n s -> method = ssl23_get_server_method ( s -> version ) ;\n if ( s -> method == NULL ) {\n SSLerr ( SSL_F_SSL23_GET_CLIENT_HELLO , SSL_R_UNSUPPORTED_PROTOCOL ) ;\n goto err ;\n }\n if ( ! ssl_init_wbio_buffer ( s , 1 ) ) goto err ;\n s -> state = SSL3_ST_SR_CLNT_HELLO_A ;\n if ( type == 3 ) {\n s -> rstate = SSL_ST_READ_HEADER ;\n s -> packet_length = n ;\n if ( s -> s3 -> rbuf . buf == NULL ) if ( ! ssl3_setup_read_buffer ( s ) ) goto err ;\n s -> packet = & ( s -> s3 -> rbuf . buf [ 0 ] ) ;\n memcpy ( s -> packet , buf , n ) ;\n s -> s3 -> rbuf . left = n ;\n s -> s3 -> rbuf . offset = 0 ;\n }\n else {\n s -> packet_length = 0 ;\n s -> s3 -> rbuf . left = 0 ;\n s -> s3 -> rbuf . offset = 0 ;\n }\n # if 0 s -> client_version = ( v [ 0 ] << 8 ) | v [ 1 ] ;\n # endif s -> handshake_func = s -> method -> ssl_accept ;\n }\n if ( ( type < 1 ) || ( type > 3 ) ) {\n SSLerr ( SSL_F_SSL23_GET_CLIENT_HELLO , SSL_R_UNKNOWN_PROTOCOL ) ;\n goto err ;\n }\n s -> init_num = 0 ;\n if ( buf != buf_space ) OPENSSL_free ( buf ) ;\n return ( SSL_accept ( s ) ) ;\n err : if ( buf != buf_space ) OPENSSL_free ( buf ) ;\n return ( - 1 ) ;\n }", "idx": 20480}
{"hash": -4558261210024070448, "project": "chrome", "size": 6, "label": 0, "functionSource": "static void xmlLinkDeallocator ( xmlListPtr l , xmlLinkPtr lk ) {\n ( lk -> prev ) -> next = lk -> next ;\n ( lk -> next ) -> prev = lk -> prev ;\n if ( l -> linkDeallocator ) l -> linkDeallocator ( lk ) ;\n xmlFree ( lk ) ;\n }", "idx": 20481}
{"hash": -1111775978048960297, "project": "chrome", "size": 17, "label": 0, "functionSource": "TEST_F ( BrowsingDataRemoverImplTest , RemoveChannelIDLastHour ) {\n RemoveChannelIDTester tester ( GetBrowserContext ( ) ) ;\n base : : Time now = base : : Time : : Now ( ) ;\n tester . AddChannelID ( kTestOrigin1 ) ;\n tester . AddChannelIDWithTimes ( kTestOrigin2 , now - base : : TimeDelta : : FromHours ( 2 ) ) ;\n EXPECT_EQ ( 0 , tester . ssl_config_changed_count ( ) ) ;\n EXPECT_EQ ( 2 , tester . ChannelIDCount ( ) ) ;\n BlockUntilBrowsingDataRemoved ( AnHourAgo ( ) , base : : Time : : Max ( ) , BrowsingDataRemover : : REMOVE_CHANNEL_IDS , false ) ;\n EXPECT_EQ ( BrowsingDataRemover : : REMOVE_CHANNEL_IDS , GetRemovalMask ( ) ) ;\n EXPECT_EQ ( BrowsingDataHelper : : UNPROTECTED_WEB , GetOriginTypeMask ( ) ) ;\n EXPECT_EQ ( 1 , tester . ssl_config_changed_count ( ) ) ;\n ASSERT_EQ ( 1 , tester . ChannelIDCount ( ) ) ;\n net : : ChannelIDStore : : ChannelIDList channel_ids ;\n tester . GetChannelIDList ( & channel_ids ) ;\n ASSERT_EQ ( 1U , channel_ids . size ( ) ) ;\n EXPECT_EQ ( kTestOrigin2 , channel_ids . front ( ) . server_identifier ( ) ) ;\n }", "idx": 20482}
{"hash": 8281630545066492937, "project": "debian", "size": 13, "label": 0, "functionSource": "static _Bool have_gcrypt ( void ) {\n static _Bool result = 0 ;\n static _Bool need_init = 1 ;\n if ( ! need_init ) return ( result ) ;\n need_init = 0 ;\n # if HAVE_LIBGCRYPT # if GCRYPT_VERSION_NUMBER < 0x010600 if ( gcry_control ( GCRYCTL_SET_THREAD_CBS , & gcry_threads_pthread ) ) return ( 0 ) ;\n # endif if ( ! gcry_check_version ( GCRYPT_VERSION ) ) return ( 0 ) ;\n if ( ! gcry_control ( GCRYCTL_INIT_SECMEM , 32768 , 0 ) ) return ( 0 ) ;\n gcry_control ( GCRYCTL_INITIALIZATION_FINISHED , 0 ) ;\n result = 1 ;\n return ( 1 ) ;\n # else return ( 0 ) ;\n # endif }", "idx": 20483}
{"hash": -5861178779585941932, "project": "debian", "size": 22, "label": 0, "functionSource": "int fn_print ( netdissect_options * ndo , register const u_char * s , register const u_char * ep ) {\n register int ret ;\n register u_char c ;\n ret = 1 ;\n while ( ep == NULL || s < ep ) {\n c = * s ++ ;\n if ( c == '\\0' ) {\n ret = 0 ;\n break ;\n }\n if ( ! ND_ISASCII ( c ) ) {\n c = ND_TOASCII ( c ) ;\n ND_PRINT ( ( ndo , \"M-\" ) ) ;\n }\n if ( ! ND_ISPRINT ( c ) ) {\n c ^= 0x40 ;\n ND_PRINT ( ( ndo , \"^\" ) ) ;\n }\n ND_PRINT ( ( ndo , \"%c\" , c ) ) ;\n }\n return ( ret ) ;\n }", "idx": 20484}
{"hash": 2636502839178711655, "project": "debian", "size": 168, "label": 1, "functionSource": "static int dissect_coap ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * parent_tree , void * data _U_ ) {\n gint offset = 0 ;\n proto_item * coap_root ;\n proto_item * pi ;\n proto_tree * coap_tree ;\n guint8 ttype ;\n guint8 token_len ;\n guint8 code ;\n guint8 code_class ;\n guint16 mid ;\n gint coap_length ;\n gchar * coap_token_str ;\n coap_info * coinfo ;\n conversation_t * conversation ;\n coap_conv_info * ccinfo ;\n coap_transaction * coap_trans = NULL ;\n coinfo = ( coap_info * ) p_get_proto_data ( wmem_file_scope ( ) , pinfo , proto_coap , 0 ) ;\n if ( coinfo == NULL ) {\n coinfo = wmem_new0 ( wmem_file_scope ( ) , coap_info ) ;\n p_add_proto_data ( wmem_file_scope ( ) , pinfo , proto_coap , 0 , coinfo ) ;\n }\n coap_length = tvb_reported_length ( tvb ) ;\n coinfo -> ctype_str = \"\" ;\n coinfo -> ctype_value = DEFAULT_COAP_CTYPE_VALUE ;\n col_set_str ( pinfo -> cinfo , COL_PROTOCOL , \"CoAP\" ) ;\n col_clear ( pinfo -> cinfo , COL_INFO ) ;\n coap_root = proto_tree_add_item ( parent_tree , proto_coap , tvb , offset , - 1 , ENC_NA ) ;\n coap_tree = proto_item_add_subtree ( coap_root , ett_coap ) ;\n proto_tree_add_item ( coap_tree , hf_coap_version , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( coap_tree , hf_coap_ttype , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n ttype = ( tvb_get_guint8 ( tvb , offset ) & COAP_TYPE_MASK ) >> 4 ;\n proto_tree_add_item ( coap_tree , hf_coap_token_len , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n token_len = tvb_get_guint8 ( tvb , offset ) & COAP_TOKEN_LEN_MASK ;\n offset += 1 ;\n code = dissect_coap_code ( tvb , coap_tree , & offset , & dissect_coap_hf , & code_class ) ;\n proto_tree_add_item ( coap_tree , hf_coap_mid , tvb , offset , 2 , ENC_BIG_ENDIAN ) ;\n mid = tvb_get_ntohs ( tvb , offset ) ;\n col_add_fstr ( pinfo -> cinfo , COL_INFO , \"%s, MID:%u, %s\" , val_to_str ( ttype , vals_ttype_short , \"Unknown %u\" ) , mid , val_to_str_ext ( code , & coap_vals_code_ext , \"Unknown %u\" ) ) ;\n proto_item_append_text ( coap_root , \", %s, %s, MID:%u\" , val_to_str ( ttype , vals_ttype , \"Unknown %u\" ) , val_to_str_ext ( code , & coap_vals_code_ext , \"Unknown %u\" ) , mid ) ;\n offset += 2 ;\n coinfo -> block_number = DEFAULT_COAP_BLOCK_NUMBER ;\n coinfo -> block_mflag = 0 ;\n coinfo -> uri_str_strbuf = wmem_strbuf_sized_new ( wmem_packet_scope ( ) , 0 , 1024 ) ;\n coinfo -> uri_query_strbuf = wmem_strbuf_sized_new ( wmem_packet_scope ( ) , 0 , 1024 ) ;\n coinfo -> oscore_info = wmem_new0 ( wmem_packet_scope ( ) , oscore_info_t ) ;\n coinfo -> object_security = FALSE ;\n coap_token_str = NULL ;\n if ( token_len > 0 ) {\n coap_token_str = tvb_bytes_to_str_punct ( wmem_file_scope ( ) , tvb , offset , token_len , ' ' ) ;\n proto_tree_add_item ( coap_tree , hf_coap_token , tvb , offset , token_len , ENC_NA ) ;\n offset += token_len ;\n }\n offset = dissect_coap_options ( tvb , pinfo , coap_tree , offset , coap_length , coinfo , & dissect_coap_hf ) ;\n if ( offset == - 1 ) return tvb_captured_length ( tvb ) ;\n conversation = find_or_create_conversation_noaddrb ( pinfo , ( code_class == 0 ) ) ;\n ccinfo = ( coap_conv_info * ) conversation_get_proto_data ( conversation , proto_coap ) ;\n if ( ! ccinfo ) {\n ccinfo = wmem_new ( wmem_file_scope ( ) , coap_conv_info ) ;\n ccinfo -> messages = wmem_map_new ( wmem_file_scope ( ) , g_str_hash , g_str_equal ) ;\n conversation_add_proto_data ( conversation , proto_coap , ccinfo ) ;\n }\n if ( coap_token_str != NULL ) {\n if ( code != 0 ) {\n coap_trans = ( coap_transaction * ) wmem_map_lookup ( ccinfo -> messages , coap_token_str ) ;\n if ( ! coap_trans ) {\n if ( ( ! PINFO_FD_VISITED ( pinfo ) ) && ( code_class == 0 ) ) {\n coap_trans = wmem_new0 ( wmem_file_scope ( ) , coap_transaction ) ;\n coap_trans -> req_frame = pinfo -> num ;\n coap_trans -> rsp_frame = 0 ;\n coap_trans -> req_time = pinfo -> fd -> abs_ts ;\n if ( coinfo -> uri_str_strbuf ) {\n coap_trans -> uri_str_strbuf = wmem_strbuf_new ( wmem_file_scope ( ) , wmem_strbuf_get_str ( coinfo -> uri_str_strbuf ) ) ;\n }\n if ( coinfo -> oscore_info ) {\n coap_trans -> oscore_info = ( oscore_info_t * ) wmem_memdup ( wmem_file_scope ( ) , coinfo -> oscore_info , sizeof ( oscore_info_t ) ) ;\n if ( coinfo -> oscore_info -> kid ) {\n coap_trans -> oscore_info -> kid = ( guint8 * ) wmem_memdup ( wmem_file_scope ( ) , coinfo -> oscore_info -> kid , coinfo -> oscore_info -> kid_len ) ;\n }\n if ( coinfo -> oscore_info -> kid_context ) {\n coap_trans -> oscore_info -> kid_context = ( guint8 * ) wmem_memdup ( wmem_file_scope ( ) , coinfo -> oscore_info -> kid_context , coinfo -> oscore_info -> kid_context_len ) ;\n }\n if ( coinfo -> oscore_info -> piv ) {\n coap_trans -> oscore_info -> piv = ( guint8 * ) wmem_memdup ( wmem_file_scope ( ) , coinfo -> oscore_info -> piv , coinfo -> oscore_info -> piv_len ) ;\n }\n }\n wmem_map_insert ( ccinfo -> messages , coap_token_str , ( void * ) coap_trans ) ;\n }\n }\n else {\n if ( ( code_class >= 2 ) && ( code_class <= 5 ) ) {\n if ( ! PINFO_FD_VISITED ( pinfo ) ) {\n coap_trans -> rsp_frame = pinfo -> num ;\n }\n if ( coap_trans -> uri_str_strbuf ) {\n coinfo -> uri_str_strbuf = wmem_strbuf_new ( wmem_packet_scope ( ) , wmem_strbuf_get_str ( coap_trans -> uri_str_strbuf ) ) ;\n }\n if ( coap_trans -> oscore_info ) {\n if ( coap_trans -> oscore_info -> kid ) {\n coinfo -> oscore_info -> kid = ( guint8 * ) wmem_memdup ( wmem_packet_scope ( ) , coap_trans -> oscore_info -> kid , coap_trans -> oscore_info -> kid_len ) ;\n }\n coinfo -> oscore_info -> kid_len = coap_trans -> oscore_info -> kid_len ;\n if ( coap_trans -> oscore_info -> kid_context ) {\n coinfo -> oscore_info -> kid_context = ( guint8 * ) wmem_memdup ( wmem_packet_scope ( ) , coap_trans -> oscore_info -> kid_context , coap_trans -> oscore_info -> kid_context_len ) ;\n }\n coinfo -> oscore_info -> kid_context_len = coap_trans -> oscore_info -> kid_context_len ;\n if ( coinfo -> oscore_info -> piv_len > 0 ) {\n coinfo -> oscore_info -> piv_in_response = TRUE ;\n coap_trans -> oscore_info -> piv_in_response = TRUE ;\n }\n else {\n if ( coap_trans -> oscore_info -> piv ) {\n coinfo -> oscore_info -> piv = ( guint8 * ) wmem_memdup ( wmem_packet_scope ( ) , coap_trans -> oscore_info -> piv , coap_trans -> oscore_info -> piv_len ) ;\n }\n coinfo -> oscore_info -> piv_len = coap_trans -> oscore_info -> piv_len ;\n }\n coinfo -> oscore_info -> response = TRUE ;\n }\n }\n }\n }\n }\n if ( coap_trans != NULL ) {\n if ( code_class == 0 ) {\n if ( coap_trans -> rsp_frame ) {\n proto_item * it ;\n it = proto_tree_add_uint ( coap_tree , hf_coap_response_in , tvb , 0 , 0 , coap_trans -> rsp_frame ) ;\n PROTO_ITEM_SET_GENERATED ( it ) ;\n }\n }\n else if ( ( code_class >= 2 ) && ( code_class <= 5 ) ) {\n if ( coap_trans -> req_frame ) {\n proto_item * it ;\n nstime_t ns ;\n it = proto_tree_add_uint ( coap_tree , hf_coap_response_to , tvb , 0 , 0 , coap_trans -> req_frame ) ;\n PROTO_ITEM_SET_GENERATED ( it ) ;\n nstime_delta ( & ns , & pinfo -> fd -> abs_ts , & coap_trans -> req_time ) ;\n it = proto_tree_add_time ( coap_tree , hf_coap_response_time , tvb , 0 , 0 , & ns ) ;\n PROTO_ITEM_SET_GENERATED ( it ) ;\n }\n if ( coinfo -> object_security && coap_trans -> oscore_info ) {\n proto_item * it ;\n it = proto_tree_add_bytes ( coap_tree , hf_coap_oscore_kid , tvb , 0 , coap_trans -> oscore_info -> kid_len , coap_trans -> oscore_info -> kid ) ;\n PROTO_ITEM_SET_GENERATED ( it ) ;\n it = proto_tree_add_bytes ( coap_tree , hf_coap_oscore_kid_context , tvb , 0 , coap_trans -> oscore_info -> kid_context_len , coap_trans -> oscore_info -> kid_context ) ;\n PROTO_ITEM_SET_GENERATED ( it ) ;\n if ( coap_trans -> oscore_info -> piv_in_response ) {\n it = proto_tree_add_bytes ( coap_tree , hf_coap_oscore_piv , tvb , 0 , coinfo -> oscore_info -> piv_len , coinfo -> oscore_info -> piv ) ;\n }\n else {\n it = proto_tree_add_bytes ( coap_tree , hf_coap_oscore_piv , tvb , 0 , coap_trans -> oscore_info -> piv_len , coap_trans -> oscore_info -> piv ) ;\n }\n PROTO_ITEM_SET_GENERATED ( it ) ;\n }\n }\n }\n if ( coap_token_str != NULL ) col_append_fstr ( pinfo -> cinfo , COL_INFO , \", TKN:%s\" , coap_token_str ) ;\n if ( coinfo -> block_number != DEFAULT_COAP_BLOCK_NUMBER ) col_append_fstr ( pinfo -> cinfo , COL_INFO , \", %sBlock #%u\" , coinfo -> block_mflag ? \"\" : \"End of \" , coinfo -> block_number ) ;\n if ( wmem_strbuf_get_len ( coinfo -> uri_str_strbuf ) > 0 ) {\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \", %s\" , wmem_strbuf_get_str ( coinfo -> uri_str_strbuf ) ) ;\n pi = proto_tree_add_string ( coap_tree , dissect_coap_hf . hf . opt_uri_path_recon , tvb , 0 , 0 , wmem_strbuf_get_str ( coinfo -> uri_str_strbuf ) ) ;\n PROTO_ITEM_SET_GENERATED ( pi ) ;\n }\n if ( wmem_strbuf_get_len ( coinfo -> uri_query_strbuf ) > 0 ) col_append_str ( pinfo -> cinfo , COL_INFO , wmem_strbuf_get_str ( coinfo -> uri_query_strbuf ) ) ;\n if ( coap_length > offset ) {\n dissect_coap_payload ( tvb , pinfo , coap_tree , parent_tree , offset , coap_length , code_class , coinfo , & dissect_coap_hf , FALSE ) ;\n }\n return tvb_captured_length ( tvb ) ;\n }", "idx": 20485}
{"hash": 5400542917484463750, "project": "chrome", "size": 9, "label": 0, "functionSource": "vpx_codec_err_t vpx_svc_set_options ( SvcContext * svc_ctx , const char * options ) {\n SvcInternal * const si = get_svc_internal ( svc_ctx ) ;\n if ( svc_ctx == NULL || options == NULL || si == NULL ) {\n return VPX_CODEC_INVALID_PARAM ;\n }\n strncpy ( si -> options , options , sizeof ( si -> options ) ) ;\n si -> options [ sizeof ( si -> options ) - 1 ] = '\\0' ;\n return VPX_CODEC_OK ;\n }", "idx": 20486}
{"hash": -2323311514228246061, "project": "chrome", "size": 38, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( DownloadExtensionTest , DownloadExtensionTest_OnDeterminingFilename_ParentDirInvalid ) {\n ASSERT_TRUE ( StartEmbeddedTestServer ( ) ) ;\n GoOnTheRecord ( ) ;\n LoadExtension ( \"downloads_split\" ) ;\n AddFilenameDeterminer ( ) ;\n std : : string download_url = embedded_test_server ( ) -> GetURL ( \"/slow?0\" ) . spec ( ) ;\n std : : unique_ptr < base : : Value > result ( RunFunctionAndReturnResult ( new DownloadsDownloadFunction ( ) , base : : StringPrintf ( \"[{\n\\\"url\\\": \\\"%s\\\"}\n]\" , download_url . c_str ( ) ) ) ) ;\n ASSERT_TRUE ( result . get ( ) ) ;\n int result_id = - 1 ;\n ASSERT_TRUE ( result -> GetAsInteger ( & result_id ) ) ;\n DownloadItem * item = GetCurrentManager ( ) -> GetDownload ( result_id ) ;\n ASSERT_TRUE ( item ) ;\n ScopedCancellingItem canceller ( item ) ;\n ASSERT_EQ ( download_url , item -> GetOriginalUrl ( ) . spec ( ) ) ;\n ASSERT_TRUE ( WaitFor ( downloads : : OnCreated : : kEventName , base : : StringPrintf ( \"[{\n\\\"danger\\\": \\\"safe\\\",\" \" \\\"incognito\\\": false,\" \" \\\"id\\\": %d,\" \" \\\"mime\\\": \\\"text/plain\\\",\" \" \\\"paused\\\": false,\" \" \\\"url\\\": \\\"%s\\\"}\n]\" , result_id , download_url . c_str ( ) ) ) ) ;\n ASSERT_TRUE ( WaitFor ( downloads : : OnDeterminingFilename : : kEventName , base : : StringPrintf ( \"[{\n\\\"id\\\": %d,\" \" \\\"filename\\\":\\\"slow.txt\\\"}\n]\" , result_id ) ) ) ;\n ASSERT_TRUE ( item -> GetTargetFilePath ( ) . empty ( ) ) ;\n ASSERT_EQ ( DownloadItem : : IN_PROGRESS , item -> GetState ( ) ) ;\n std : : string error ;\n ASSERT_FALSE ( ExtensionDownloadsEventRouter : : DetermineFilename ( browser ( ) -> profile ( ) , false , GetExtensionId ( ) , result_id , base : : FilePath ( FILE_PATH_LITERAL ( \"..\" ) ) , downloads : : FILENAME_CONFLICT_ACTION_UNIQUIFY , & error ) ) ;\n EXPECT_STREQ ( errors : : kInvalidFilename , error . c_str ( ) ) ;\n ASSERT_TRUE ( WaitFor ( downloads : : OnChanged : : kEventName , base : : StringPrintf ( \"[{\n\\\"id\\\": %d,\" \" \\\"filename\\\": {\n\" \" \\\"previous\\\": \\\"\\\",\" \" \\\"current\\\": \\\"%s\\\"}\n}\n]\" , result_id , GetFilename ( \"slow.txt\" ) . c_str ( ) ) ) ) ;\n ASSERT_TRUE ( WaitFor ( downloads : : OnChanged : : kEventName , base : : StringPrintf ( \"[{\n\\\"id\\\": %d,\" \" \\\"state\\\": {\n\" \" \\\"previous\\\": \\\"in_progress\\\",\" \" \\\"current\\\": \\\"complete\\\"}\n}\n]\" , result_id ) ) ) ;\n }", "idx": 20487}
{"hash": -704025756752474526, "project": "debian", "size": 6, "label": 0, "functionSource": "void PNGAPI png_set_sBIT ( png_structp png_ptr , png_infop info_ptr , png_color_8p sig_bit ) {\n png_debug1 ( 1 , \"in %s storage function\" , \"sBIT\" ) ;\n if ( png_ptr == NULL || info_ptr == NULL ) return ;\n png_memcpy ( & ( info_ptr -> sig_bit ) , sig_bit , png_sizeof ( png_color_8 ) ) ;\n info_ptr -> valid |= PNG_INFO_sBIT ;\n }", "idx": 20488}
{"hash": -6126432314261451839, "project": "debian", "size": 13, "label": 0, "functionSource": "static void gx_device_set_media_from_hwsize ( gx_device * dev ) {\n int rot = ( dev -> LeadingEdge & 1 ) ;\n double x = dev -> width * 72.0 / dev -> HWResolution [ 0 ] ;\n double y = dev -> height * 72.0 / dev -> HWResolution [ 1 ] ;\n if ( rot ) {\n dev -> MediaSize [ 1 ] = x ;\n dev -> MediaSize [ 0 ] = y ;\n }\n else {\n dev -> MediaSize [ 0 ] = x ;\n dev -> MediaSize [ 1 ] = y ;\n }\n }", "idx": 20489}
{"hash": -1315695702746584250, "project": "debian", "size": 6, "label": 0, "functionSource": "void proto_set_decoding ( const int proto_id , const gboolean enabled ) {\n protocol_t * protocol ;\n protocol = find_protocol_by_id ( proto_id ) ;\n DISSECTOR_ASSERT ( protocol -> can_toggle ) ;\n protocol -> is_enabled = enabled ;\n }", "idx": 20490}
{"hash": 1760449185745615462, "project": "debian", "size": 10, "label": 0, "functionSource": "TSReturnCode TSHttpTxnCachedRespTimeGet ( TSHttpTxn txnp , time_t * resp_time ) {\n sdk_assert ( sdk_sanity_check_txn ( txnp ) == TS_SUCCESS ) ;\n HttpSM * sm = ( HttpSM * ) txnp ;\n HTTPInfo * cached_obj = sm -> t_state . cache_info . object_read ;\n if ( cached_obj == nullptr || ! cached_obj -> valid ( ) ) {\n return TS_ERROR ;\n }\n * resp_time = cached_obj -> response_received_time_get ( ) ;\n return TS_SUCCESS ;\n }", "idx": 20491}
{"hash": -8115807672627724050, "project": "debian", "size": 9, "label": 0, "functionSource": "static int ts_lua_http_client_packet_mark_set ( lua_State * L ) {\n int value ;\n ts_lua_http_ctx * http_ctx ;\n GET_HTTP_CONTEXT ( http_ctx , L ) ;\n value = luaL_checkinteger ( L , 1 ) ;\n TSDebug ( TS_LUA_DEBUG_TAG , \"client packet mark set\" ) ;\n TSHttpTxnClientPacketMarkSet ( http_ctx -> txnp , value ) ;\n return 0 ;\n }", "idx": 20492}
{"hash": -2915908172644760936, "project": "debian", "size": 37, "label": 0, "functionSource": "static void revert_acfilter ( WmallDecodeCtx * s , int tile_size ) {\n int ich , pred , i , j ;\n int64_t * filter_coeffs = s -> acfilter_coeffs ;\n int scaling = s -> acfilter_scaling ;\n int order = s -> acfilter_order ;\n for ( ich = 0 ;\n ich < s -> num_channels ;\n ich ++ ) {\n int * prevvalues = s -> acfilter_prevvalues [ ich ] ;\n for ( i = 0 ;\n i < order ;\n i ++ ) {\n pred = 0 ;\n for ( j = 0 ;\n j < order ;\n j ++ ) {\n if ( i <= j ) pred += filter_coeffs [ j ] * prevvalues [ j - i ] ;\n else pred += s -> channel_residues [ ich ] [ i - j - 1 ] * filter_coeffs [ j ] ;\n }\n pred >>= scaling ;\n s -> channel_residues [ ich ] [ i ] += pred ;\n }\n for ( i = order ;\n i < tile_size ;\n i ++ ) {\n pred = 0 ;\n for ( j = 0 ;\n j < order ;\n j ++ ) pred += s -> channel_residues [ ich ] [ i - j - 1 ] * filter_coeffs [ j ] ;\n pred >>= scaling ;\n s -> channel_residues [ ich ] [ i ] += pred ;\n }\n for ( j = 0 ;\n j < order ;\n j ++ ) prevvalues [ j ] = s -> channel_residues [ ich ] [ tile_size - j - 1 ] ;\n }\n }", "idx": 20493}
{"hash": -2915908172644760936, "project": "debian", "size": 59, "label": 0, "functionSource": "static int decode_frame ( WmallDecodeCtx * s ) {\n GetBitContext * gb = & s -> gb ;\n int more_frames = 0 , len = 0 , i , ret ;\n s -> frame . nb_samples = s -> samples_per_frame ;\n if ( ( ret = ff_get_buffer ( s -> avctx , & s -> frame , 0 ) ) < 0 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"not enough space for the output samples\\n\" ) ;\n s -> packet_loss = 1 ;\n return ret ;\n }\n for ( i = 0 ;\n i < s -> num_channels ;\n i ++ ) {\n s -> samples_16 [ i ] = ( int16_t * ) s -> frame . extended_data [ i ] ;\n s -> samples_32 [ i ] = ( int32_t * ) s -> frame . extended_data [ i ] ;\n }\n if ( s -> len_prefix ) len = get_bits ( gb , s -> log2_frame_size ) ;\n if ( decode_tilehdr ( s ) ) {\n s -> packet_loss = 1 ;\n return 0 ;\n }\n if ( s -> dynamic_range_compression ) s -> drc_gain = get_bits ( gb , 8 ) ;\n if ( get_bits1 ( gb ) ) {\n int av_unused skip ;\n if ( get_bits1 ( gb ) ) {\n skip = get_bits ( gb , av_log2 ( s -> samples_per_frame * 2 ) ) ;\n av_dlog ( s -> avctx , \"start skip: %i\\n\" , skip ) ;\n }\n if ( get_bits1 ( gb ) ) {\n skip = get_bits ( gb , av_log2 ( s -> samples_per_frame * 2 ) ) ;\n av_dlog ( s -> avctx , \"end skip: %i\\n\" , skip ) ;\n }\n }\n s -> parsed_all_subframes = 0 ;\n for ( i = 0 ;\n i < s -> num_channels ;\n i ++ ) {\n s -> channel [ i ] . decoded_samples = 0 ;\n s -> channel [ i ] . cur_subframe = 0 ;\n }\n while ( ! s -> parsed_all_subframes ) {\n if ( decode_subframe ( s ) < 0 ) {\n s -> packet_loss = 1 ;\n return 0 ;\n }\n }\n av_dlog ( s -> avctx , \"Frame done\\n\" ) ;\n if ( s -> skip_frame ) s -> skip_frame = 0 ;\n if ( s -> len_prefix ) {\n if ( len != ( get_bits_count ( gb ) - s -> frame_offset ) + 2 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"frame[%i] would have to skip %i bits\\n\" , s -> frame_num , len - ( get_bits_count ( gb ) - s -> frame_offset ) - 1 ) ;\n s -> packet_loss = 1 ;\n return 0 ;\n }\n skip_bits_long ( gb , len - ( get_bits_count ( gb ) - s -> frame_offset ) - 1 ) ;\n }\n more_frames = get_bits1 ( gb ) ;\n ++ s -> frame_num ;\n return more_frames ;\n }", "idx": 20494}
{"hash": -7131177824150194183, "project": "debian", "size": 200, "label": 0, "functionSource": "static int bink_decode_plane ( BinkContext * c , AVFrame * frame , GetBitContext * gb , int plane_idx , int is_chroma ) {\n int blk , ret ;\n int i , j , bx , by ;\n uint8_t * dst , * prev , * ref , * ref_start , * ref_end ;\n int v , col [ 2 ] ;\n const uint8_t * scan ;\n int xoff , yoff ;\n LOCAL_ALIGNED_16 ( int16_t , block , [ 64 ] ) ;\n LOCAL_ALIGNED_16 ( uint8_t , ublock , [ 64 ] ) ;\n LOCAL_ALIGNED_16 ( int32_t , dctblock , [ 64 ] ) ;\n int coordmap [ 64 ] ;\n const int stride = frame -> linesize [ plane_idx ] ;\n int bw = is_chroma ? ( c -> avctx -> width + 15 ) >> 4 : ( c -> avctx -> width + 7 ) >> 3 ;\n int bh = is_chroma ? ( c -> avctx -> height + 15 ) >> 4 : ( c -> avctx -> height + 7 ) >> 3 ;\n int width = c -> avctx -> width >> is_chroma ;\n init_lengths ( c , FFMAX ( width , 8 ) , bw ) ;\n for ( i = 0 ;\n i < BINK_NB_SRC ;\n i ++ ) read_bundle ( gb , c , i ) ;\n ref_start = c -> last -> data [ plane_idx ] ? c -> last -> data [ plane_idx ] : frame -> data [ plane_idx ] ;\n ref_end = ref_start + ( bw - 1 + c -> last -> linesize [ plane_idx ] * ( bh - 1 ) ) * 8 ;\n for ( i = 0 ;\n i < 64 ;\n i ++ ) coordmap [ i ] = ( i & 7 ) + ( i >> 3 ) * stride ;\n for ( by = 0 ;\n by < bh ;\n by ++ ) {\n if ( ( ret = read_block_types ( c -> avctx , gb , & c -> bundle [ BINK_SRC_BLOCK_TYPES ] ) ) < 0 ) return ret ;\n if ( ( ret = read_block_types ( c -> avctx , gb , & c -> bundle [ BINK_SRC_SUB_BLOCK_TYPES ] ) ) < 0 ) return ret ;\n if ( ( ret = read_colors ( gb , & c -> bundle [ BINK_SRC_COLORS ] , c ) ) < 0 ) return ret ;\n if ( ( ret = read_patterns ( c -> avctx , gb , & c -> bundle [ BINK_SRC_PATTERN ] ) ) < 0 ) return ret ;\n if ( ( ret = read_motion_values ( c -> avctx , gb , & c -> bundle [ BINK_SRC_X_OFF ] ) ) < 0 ) return ret ;\n if ( ( ret = read_motion_values ( c -> avctx , gb , & c -> bundle [ BINK_SRC_Y_OFF ] ) ) < 0 ) return ret ;\n if ( ( ret = read_dcs ( c -> avctx , gb , & c -> bundle [ BINK_SRC_INTRA_DC ] , DC_START_BITS , 0 ) ) < 0 ) return ret ;\n if ( ( ret = read_dcs ( c -> avctx , gb , & c -> bundle [ BINK_SRC_INTER_DC ] , DC_START_BITS , 1 ) ) < 0 ) return ret ;\n if ( ( ret = read_runs ( c -> avctx , gb , & c -> bundle [ BINK_SRC_RUN ] ) ) < 0 ) return ret ;\n if ( by == bh ) break ;\n dst = frame -> data [ plane_idx ] + 8 * by * stride ;\n prev = ( c -> last -> data [ plane_idx ] ? c -> last -> data [ plane_idx ] : frame -> data [ plane_idx ] ) + 8 * by * stride ;\n for ( bx = 0 ;\n bx < bw ;\n bx ++ , dst += 8 , prev += 8 ) {\n blk = get_value ( c , BINK_SRC_BLOCK_TYPES ) ;\n if ( ( by & 1 ) && blk == SCALED_BLOCK ) {\n bx ++ ;\n dst += 8 ;\n prev += 8 ;\n continue ;\n }\n switch ( blk ) {\n case SKIP_BLOCK : c -> dsp . put_pixels_tab [ 1 ] [ 0 ] ( dst , prev , stride , 8 ) ;\n break ;\n case SCALED_BLOCK : blk = get_value ( c , BINK_SRC_SUB_BLOCK_TYPES ) ;\n switch ( blk ) {\n case RUN_BLOCK : scan = bink_patterns [ get_bits ( gb , 4 ) ] ;\n i = 0 ;\n do {\n int run = get_value ( c , BINK_SRC_RUN ) + 1 ;\n i += run ;\n if ( i > 64 ) {\n av_log ( c -> avctx , AV_LOG_ERROR , \"Run went out of bounds\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( get_bits1 ( gb ) ) {\n v = get_value ( c , BINK_SRC_COLORS ) ;\n for ( j = 0 ;\n j < run ;\n j ++ ) ublock [ * scan ++ ] = v ;\n }\n else {\n for ( j = 0 ;\n j < run ;\n j ++ ) ublock [ * scan ++ ] = get_value ( c , BINK_SRC_COLORS ) ;\n }\n }\n while ( i < 63 ) ;\n if ( i == 63 ) ublock [ * scan ++ ] = get_value ( c , BINK_SRC_COLORS ) ;\n break ;\n case INTRA_BLOCK : memset ( dctblock , 0 , sizeof ( * dctblock ) * 64 ) ;\n dctblock [ 0 ] = get_value ( c , BINK_SRC_INTRA_DC ) ;\n read_dct_coeffs ( gb , dctblock , bink_scan , bink_intra_quant , - 1 ) ;\n c -> bdsp . idct_put ( ublock , 8 , dctblock ) ;\n break ;\n case FILL_BLOCK : v = get_value ( c , BINK_SRC_COLORS ) ;\n c -> dsp . fill_block_tab [ 0 ] ( dst , v , stride , 16 ) ;\n break ;\n case PATTERN_BLOCK : for ( i = 0 ;\n i < 2 ;\n i ++ ) col [ i ] = get_value ( c , BINK_SRC_COLORS ) ;\n for ( j = 0 ;\n j < 8 ;\n j ++ ) {\n v = get_value ( c , BINK_SRC_PATTERN ) ;\n for ( i = 0 ;\n i < 8 ;\n i ++ , v >>= 1 ) ublock [ i + j * 8 ] = col [ v & 1 ] ;\n }\n break ;\n case RAW_BLOCK : for ( j = 0 ;\n j < 8 ;\n j ++ ) for ( i = 0 ;\n i < 8 ;\n i ++ ) ublock [ i + j * 8 ] = get_value ( c , BINK_SRC_COLORS ) ;\n break ;\n default : av_log ( c -> avctx , AV_LOG_ERROR , \"Incorrect 16x16 block type %d\\n\" , blk ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( blk != FILL_BLOCK ) c -> bdsp . scale_block ( ublock , dst , stride ) ;\n bx ++ ;\n dst += 8 ;\n prev += 8 ;\n break ;\n case MOTION_BLOCK : xoff = get_value ( c , BINK_SRC_X_OFF ) ;\n yoff = get_value ( c , BINK_SRC_Y_OFF ) ;\n ref = prev + xoff + yoff * stride ;\n if ( ref < ref_start || ref > ref_end ) {\n av_log ( c -> avctx , AV_LOG_ERROR , \"Copy out of bounds @%d, %d\\n\" , bx * 8 + xoff , by * 8 + yoff ) ;\n return AVERROR_INVALIDDATA ;\n }\n c -> dsp . put_pixels_tab [ 1 ] [ 0 ] ( dst , ref , stride , 8 ) ;\n break ;\n case RUN_BLOCK : scan = bink_patterns [ get_bits ( gb , 4 ) ] ;\n i = 0 ;\n do {\n int run = get_value ( c , BINK_SRC_RUN ) + 1 ;\n i += run ;\n if ( i > 64 ) {\n av_log ( c -> avctx , AV_LOG_ERROR , \"Run went out of bounds\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( get_bits1 ( gb ) ) {\n v = get_value ( c , BINK_SRC_COLORS ) ;\n for ( j = 0 ;\n j < run ;\n j ++ ) dst [ coordmap [ * scan ++ ] ] = v ;\n }\n else {\n for ( j = 0 ;\n j < run ;\n j ++ ) dst [ coordmap [ * scan ++ ] ] = get_value ( c , BINK_SRC_COLORS ) ;\n }\n }\n while ( i < 63 ) ;\n if ( i == 63 ) dst [ coordmap [ * scan ++ ] ] = get_value ( c , BINK_SRC_COLORS ) ;\n break ;\n case RESIDUE_BLOCK : xoff = get_value ( c , BINK_SRC_X_OFF ) ;\n yoff = get_value ( c , BINK_SRC_Y_OFF ) ;\n ref = prev + xoff + yoff * stride ;\n if ( ref < ref_start || ref > ref_end ) {\n av_log ( c -> avctx , AV_LOG_ERROR , \"Copy out of bounds @%d, %d\\n\" , bx * 8 + xoff , by * 8 + yoff ) ;\n return AVERROR_INVALIDDATA ;\n }\n c -> dsp . put_pixels_tab [ 1 ] [ 0 ] ( dst , ref , stride , 8 ) ;\n c -> dsp . clear_block ( block ) ;\n v = get_bits ( gb , 7 ) ;\n read_residue ( gb , block , v ) ;\n c -> dsp . add_pixels8 ( dst , block , stride ) ;\n break ;\n case INTRA_BLOCK : memset ( dctblock , 0 , sizeof ( * dctblock ) * 64 ) ;\n dctblock [ 0 ] = get_value ( c , BINK_SRC_INTRA_DC ) ;\n read_dct_coeffs ( gb , dctblock , bink_scan , bink_intra_quant , - 1 ) ;\n c -> bdsp . idct_put ( dst , stride , dctblock ) ;\n break ;\n case FILL_BLOCK : v = get_value ( c , BINK_SRC_COLORS ) ;\n c -> dsp . fill_block_tab [ 1 ] ( dst , v , stride , 8 ) ;\n break ;\n case INTER_BLOCK : xoff = get_value ( c , BINK_SRC_X_OFF ) ;\n yoff = get_value ( c , BINK_SRC_Y_OFF ) ;\n ref = prev + xoff + yoff * stride ;\n c -> dsp . put_pixels_tab [ 1 ] [ 0 ] ( dst , ref , stride , 8 ) ;\n memset ( dctblock , 0 , sizeof ( * dctblock ) * 64 ) ;\n dctblock [ 0 ] = get_value ( c , BINK_SRC_INTER_DC ) ;\n read_dct_coeffs ( gb , dctblock , bink_scan , bink_inter_quant , - 1 ) ;\n c -> bdsp . idct_add ( dst , stride , dctblock ) ;\n break ;\n case PATTERN_BLOCK : for ( i = 0 ;\n i < 2 ;\n i ++ ) col [ i ] = get_value ( c , BINK_SRC_COLORS ) ;\n for ( i = 0 ;\n i < 8 ;\n i ++ ) {\n v = get_value ( c , BINK_SRC_PATTERN ) ;\n for ( j = 0 ;\n j < 8 ;\n j ++ , v >>= 1 ) dst [ i * stride + j ] = col [ v & 1 ] ;\n }\n break ;\n case RAW_BLOCK : for ( i = 0 ;\n i < 8 ;\n i ++ ) memcpy ( dst + i * stride , c -> bundle [ BINK_SRC_COLORS ] . cur_ptr + i * 8 , 8 ) ;\n c -> bundle [ BINK_SRC_COLORS ] . cur_ptr += 64 ;\n break ;\n default : av_log ( c -> avctx , AV_LOG_ERROR , \"Unknown block type %d\\n\" , blk ) ;\n return AVERROR_INVALIDDATA ;\n }\n }\n }\n if ( get_bits_count ( gb ) & 0x1F ) / ext plane data starts at 32 - bit boundary skip_bits_long ( gb , 32 - ( get_bits_count ( gb ) & 0x1F ) ) ;\n return 0 ;\n }", "idx": 20495}
{"hash": -2723830976796502611, "project": "chrome", "size": 87, "label": 0, "functionSource": "static vpx_codec_err_t set_encoder_config ( VP9EncoderConfig * oxcf , const vpx_codec_enc_cfg_t * cfg , const struct vp9_extracfg * extra_cfg ) {\n const int is_vbr = cfg -> rc_end_usage == VPX_VBR ;\n oxcf -> profile = cfg -> g_profile ;\n oxcf -> width = cfg -> g_w ;\n oxcf -> height = cfg -> g_h ;\n oxcf -> bit_depth = extra_cfg -> bit_depth ;\n oxcf -> input_bit_depth = cfg -> g_input_bit_depth ;\n oxcf -> init_framerate = ( double ) cfg -> g_timebase . den / cfg -> g_timebase . num ;\n if ( oxcf -> init_framerate > 180 ) oxcf -> init_framerate = 30 ;\n oxcf -> mode = GOOD ;\n switch ( cfg -> g_pass ) {\n case VPX_RC_ONE_PASS : oxcf -> pass = 0 ;\n break ;\n case VPX_RC_FIRST_PASS : oxcf -> pass = 1 ;\n break ;\n case VPX_RC_LAST_PASS : oxcf -> pass = 2 ;\n break ;\n }\n oxcf -> lag_in_frames = cfg -> g_pass == VPX_RC_FIRST_PASS ? 0 : cfg -> g_lag_in_frames ;\n oxcf -> rc_mode = cfg -> rc_end_usage ;\n oxcf -> target_bandwidth = 1000 * cfg -> rc_target_bitrate ;\n oxcf -> rc_max_intra_bitrate_pct = extra_cfg -> rc_max_intra_bitrate_pct ;\n oxcf -> best_allowed_q = extra_cfg -> lossless ? 0 : vp9_quantizer_to_qindex ( cfg -> rc_min_quantizer ) ;\n oxcf -> worst_allowed_q = extra_cfg -> lossless ? 0 : vp9_quantizer_to_qindex ( cfg -> rc_max_quantizer ) ;\n oxcf -> cq_level = vp9_quantizer_to_qindex ( extra_cfg -> cq_level ) ;\n oxcf -> fixed_q = - 1 ;\n oxcf -> under_shoot_pct = cfg -> rc_undershoot_pct ;\n oxcf -> over_shoot_pct = cfg -> rc_overshoot_pct ;\n oxcf -> allow_spatial_resampling = cfg -> rc_resize_allowed ;\n oxcf -> scaled_frame_width = cfg -> rc_scaled_width ;\n oxcf -> scaled_frame_height = cfg -> rc_scaled_height ;\n oxcf -> maximum_buffer_size_ms = is_vbr ? 240000 : cfg -> rc_buf_sz ;\n oxcf -> starting_buffer_level_ms = is_vbr ? 60000 : cfg -> rc_buf_initial_sz ;\n oxcf -> optimal_buffer_level_ms = is_vbr ? 60000 : cfg -> rc_buf_optimal_sz ;\n oxcf -> drop_frames_water_mark = cfg -> rc_dropframe_thresh ;\n oxcf -> two_pass_vbrbias = cfg -> rc_2pass_vbr_bias_pct ;\n oxcf -> two_pass_vbrmin_section = cfg -> rc_2pass_vbr_minsection_pct ;\n oxcf -> two_pass_vbrmax_section = cfg -> rc_2pass_vbr_maxsection_pct ;\n oxcf -> auto_key = cfg -> kf_mode == VPX_KF_AUTO && cfg -> kf_min_dist != cfg -> kf_max_dist ;\n oxcf -> key_freq = cfg -> kf_max_dist ;\n oxcf -> speed = abs ( extra_cfg -> cpu_used ) ;\n oxcf -> encode_breakout = extra_cfg -> static_thresh ;\n oxcf -> play_alternate = extra_cfg -> enable_auto_alt_ref ;\n oxcf -> noise_sensitivity = extra_cfg -> noise_sensitivity ;\n oxcf -> sharpness = extra_cfg -> sharpness ;\n oxcf -> two_pass_stats_in = cfg -> rc_twopass_stats_in ;\n # if CONFIG_FP_MB_STATS oxcf -> firstpass_mb_stats_in = cfg -> rc_firstpass_mb_stats_in ;\n # endif oxcf -> arnr_max_frames = extra_cfg -> arnr_max_frames ;\n oxcf -> arnr_strength = extra_cfg -> arnr_strength ;\n oxcf -> tuning = extra_cfg -> tuning ;\n oxcf -> content = extra_cfg -> content ;\n oxcf -> tile_columns = extra_cfg -> tile_columns ;\n oxcf -> tile_rows = extra_cfg -> tile_rows ;\n oxcf -> error_resilient_mode = cfg -> g_error_resilient ;\n oxcf -> frame_parallel_decoding_mode = extra_cfg -> frame_parallel_decoding_mode ;\n oxcf -> aq_mode = extra_cfg -> aq_mode ;\n oxcf -> frame_periodic_boost = extra_cfg -> frame_periodic_boost ;\n oxcf -> ss_number_layers = cfg -> ss_number_layers ;\n if ( oxcf -> ss_number_layers > 1 ) {\n int i ;\n for ( i = 0 ;\n i < VPX_SS_MAX_LAYERS ;\n ++ i ) {\n oxcf -> ss_target_bitrate [ i ] = 1000 * cfg -> ss_target_bitrate [ i ] ;\n # if CONFIG_SPATIAL_SVC oxcf -> ss_play_alternate [ i ] = cfg -> ss_enable_auto_alt_ref [ i ] ;\n # endif }\n }\n else if ( oxcf -> ss_number_layers == 1 ) {\n oxcf -> ss_target_bitrate [ 0 ] = ( int ) oxcf -> target_bandwidth ;\n # if CONFIG_SPATIAL_SVC oxcf -> ss_play_alternate [ 0 ] = extra_cfg -> enable_auto_alt_ref ;\n # endif }\n oxcf -> ts_number_layers = cfg -> ts_number_layers ;\n if ( oxcf -> ts_number_layers > 1 ) {\n int i ;\n for ( i = 0 ;\n i < VPX_TS_MAX_LAYERS ;\n ++ i ) {\n oxcf -> ts_target_bitrate [ i ] = 1000 * cfg -> ts_target_bitrate [ i ] ;\n oxcf -> ts_rate_decimator [ i ] = cfg -> ts_rate_decimator [ i ] ;\n }\n }\n else if ( oxcf -> ts_number_layers == 1 ) {\n oxcf -> ts_target_bitrate [ 0 ] = ( int ) oxcf -> target_bandwidth ;\n oxcf -> ts_rate_decimator [ 0 ] = 1 ;\n }\n return VPX_CODEC_OK ;\n }", "idx": 20496}
{"hash": 1760449185745615462, "project": "debian", "size": 3, "label": 0, "functionSource": "void _TSfree ( void * ptr ) {\n ats_free ( ptr ) ;\n }", "idx": 20497}
{"hash": 9176142195250515812, "project": "debian", "size": 17, "label": 0, "functionSource": "static void prplcb_buddy_typing ( PurpleAccount * account , const char * who , gpointer null ) {\n PurpleConversation * conv ;\n PurpleConvIm * im ;\n int state ;\n if ( ( conv = purple_find_conversation_with_account ( PURPLE_CONV_TYPE_IM , who , account ) ) == NULL ) {\n return ;\n }\n im = PURPLE_CONV_IM ( conv ) ;\n switch ( purple_conv_im_get_typing_state ( im ) ) {\n case PURPLE_TYPING : state = OPT_TYPING ;\n break ;\n case PURPLE_TYPED : state = OPT_THINKING ;\n break ;\n default : state = 0 ;\n }\n imcb_buddy_typing ( purple_ic_by_pa ( account ) , who , state ) ;\n }", "idx": 20498}
{"hash": -649112636673899765, "project": "debian", "size": 4, "label": 0, "functionSource": "static int ivr_probe ( AVProbeData * p ) {\n if ( memcmp ( p -> buf , \".R1M\\x0\\x1\\x1\" , 7 ) && memcmp ( p -> buf , \".REC\" , 4 ) ) return 0 ;\n return AVPROBE_SCORE_MAX ;\n }", "idx": 20499}
{"hash": -6024601983167898950, "project": "debian", "size": 8, "label": 0, "functionSource": "static unsigned int mime_application_hash ( GAppInfo * app ) {\n const char * id ;\n id = g_app_info_get_id ( app ) ;\n if ( id == NULL ) {\n return GPOINTER_TO_UINT ( app ) ;\n }\n return g_str_hash ( id ) ;\n }", "idx": 20500}
{"hash": -1929262071302712016, "project": "debian", "size": 6, "label": 0, "functionSource": "static void Type_Curve_Free ( struct _cms_typehandler_struct * self , void * Ptr ) {\n cmsToneCurve * gamma = ( cmsToneCurve * ) Ptr ;\n cmsFreeToneCurve ( gamma ) ;\n return ;\n cmsUNUSED_PARAMETER ( self ) ;\n }", "idx": 20501}
{"hash": 3919646340804521652, "project": "debian", "size": 5, "label": 0, "functionSource": "static int add_ref_tag ( const char * path , const struct object_id * oid , int flag , void * cb_data ) {\n struct object_id peeled ;\n if ( starts_with ( path , \"refs/tags/\" ) && ! peel_ref ( path , peeled . hash ) && packlist_find ( & to_pack , peeled . hash , NULL ) ) add_object_entry ( oid -> hash , OBJ_TAG , NULL , 0 ) ;\n return 0 ;\n }", "idx": 20502}
{"hash": -1315695702746584250, "project": "debian", "size": 11, "label": 0, "functionSource": "void proto_tree_children_foreach ( proto_tree * tree , proto_tree_foreach_func func , gpointer data ) {\n proto_node * node = tree ;\n proto_node * current ;\n if ( ! node ) return ;\n node = node -> first_child ;\n while ( node != NULL ) {\n current = node ;\n node = current -> next ;\n func ( ( proto_tree * ) current , data ) ;\n }\n }", "idx": 20503}
{"hash": 1223258652239369123, "project": "debian", "size": 7, "label": 0, "functionSource": "SPL_METHOD ( FilesystemIterator , getFlags ) {\n spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n if ( zend_parse_parameters_none ( ) == FAILURE ) {\n return ;\n }\n RETURN_LONG ( intern -> flags & ( SPL_FILE_DIR_KEY_MODE_MASK | SPL_FILE_DIR_CURRENT_MODE_MASK | SPL_FILE_DIR_OTHERS_MASK ) ) ;\n }", "idx": 20504}
{"hash": 5357882892791796049, "project": "debian", "size": 5, "label": 0, "functionSource": "int e1000e_core_post_load ( E1000ECore * core ) {\n NetClientState * nc = qemu_get_queue ( core -> owner_nic ) ;\n nc -> link_down = ( core -> mac [ STATUS ] & E1000_STATUS_LU ) == 0 ;\n return 0 ;\n }", "idx": 20505}
{"hash": -4555950263653671147, "project": "debian", "size": 9, "label": 0, "functionSource": "static PyObject * string_index ( PyStringObject * self , PyObject * args ) {\n Py_ssize_t result = string_find_internal ( self , args , + 1 ) ;\n if ( result == - 2 ) return NULL ;\n if ( result == - 1 ) {\n PyErr_SetString ( PyExc_ValueError , \"substring not found\" ) ;\n return NULL ;\n }\n return PyInt_FromSsize_t ( result ) ;\n }", "idx": 20506}
{"hash": -7042392412001533358, "project": "debian", "size": 6, "label": 0, "functionSource": "static void count_node_types ( cmap_splay * node , void * arg ) {\n int * counts = ( int * ) arg ;\n if ( node -> many ) counts [ 2 ] ++ ;\n else if ( node -> low <= 0xffff && node -> high <= 0xFFFF && node -> out <= 0xFFFF ) counts [ 0 ] ++ ;\n else counts [ 1 ] ++ ;\n }", "idx": 20507}
{"hash": 1760449185745615462, "project": "debian", "size": 11, "label": 0, "functionSource": "TSReturnCode TSFetchPageRespGet ( TSHttpTxn txnp , TSMBuffer * bufp , TSMLoc * obj ) {\n sdk_assert ( sdk_sanity_check_null_ptr ( ( void * ) bufp ) == TS_SUCCESS ) ;\n sdk_assert ( sdk_sanity_check_null_ptr ( ( void * ) obj ) == TS_SUCCESS ) ;\n HTTPHdr * hptr = ( HTTPHdr * ) txnp ;\n if ( hptr -> valid ( ) ) {\n * ( reinterpret_cast < HTTPHdr * * > ( bufp ) ) = hptr ;\n * obj = reinterpret_cast < TSMLoc > ( hptr -> m_http ) ;\n return sdk_sanity_check_mbuffer ( * bufp ) ;\n }\n return TS_ERROR ;\n }", "idx": 20508}
{"hash": 2636502839178711655, "project": "debian", "size": 11, "label": 0, "functionSource": "static void dissect_coap_opt_proxy_uri ( tvbuff_t * tvb , proto_item * head_item , proto_tree * subtree , gint offset , gint opt_length , int hf ) {\n const guint8 * str = NULL ;\n if ( opt_length == 0 ) {\n str = nullstr ;\n }\n else {\n str = tvb_get_string_enc ( wmem_packet_scope ( ) , tvb , offset , opt_length , ENC_ASCII ) ;\n }\n proto_tree_add_string ( subtree , hf , tvb , offset , opt_length , str ) ;\n proto_item_append_text ( head_item , \": %s\" , str ) ;\n }", "idx": 20509}
{"hash": -8228664527580018723, "project": "debian", "size": 3, "label": 0, "functionSource": "int curl_mvprintf ( const char * format , va_list ap_save ) {\n return dprintf_formatf ( stdout , fputc , format , ap_save ) ;\n }", "idx": 20510}
{"hash": 4489017523191997023, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h225_UnknownMessageResponse ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_UnknownMessageResponse , UnknownMessageResponse_sequence ) ;\n return offset ;\n }", "idx": 20511}
{"hash": -4527380754569407959, "project": "chrome", "size": 20, "label": 0, "functionSource": "GType hb_gobject_ ## name ## _get_type ( void ) \\ {\n static gsize type_id = 0 ;\n if ( g_once_init_enter ( & type_id ) ) {\n GType id = g_boxed_type_register_static ( g_intern_static_string ( \"hb_\" # name \"_t\" ) , ( GBoxedCopyFunc ) copy_func , ( GBoxedFreeFunc ) free_func ) ;\n g_once_init_leave ( & type_id , id ) ;\n }\n return type_id ;\n \\ }\n # define HB_DEFINE_OBJECT_TYPE ( name ) HB_DEFINE_BOXED_TYPE ( name , hb_ ## name ## _reference , hb_ ## name ## _destroy ) ;\n # define HB_DEFINE_VALUE_TYPE ( name ) static hb_ ## name ## _t * _hb_ ## name ## _reference ( const hb_ ## name ## _t * l ) {\n hb_ ## name ## _t * c = ( hb_ ## name ## _t * ) calloc ( 1 , sizeof ( hb_ ## name ## _t ) ) ;\n if ( unlikely ( ! c ) ) return NULL ;\n * c = * l ;\n return c ;\n }\n static void _hb_ ## name ## _destroy ( hb_ ## name ## _t * l ) {\n free ( l ) ;\n }\n HB_DEFINE_BOXED_TYPE ( name , _hb_ ## name ## _reference , _hb_ ## name ## _destroy ) ;\n HB_DEFINE_OBJECT_TYPE ( buffer ) HB_DEFINE_OBJECT_TYPE ( blob ) HB_DEFINE_OBJECT_TYPE ( face ) HB_DEFINE_OBJECT_TYPE ( font ) HB_DEFINE_OBJECT_TYPE ( font_funcs ) HB_DEFINE_OBJECT_TYPE ( set ) HB_DEFINE_OBJECT_TYPE ( shape_plan ) HB_DEFINE_OBJECT_TYPE ( unicode_funcs )", "idx": 20512}
{"hash": 4489017523191997023, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h225_TBCD_STRING_SIZE_16 ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_size_constrained_type ( tvb , offset , actx , tree , hf_index , dissect_h225_TBCD_STRING , \"TBCD_STRING\" , 16 , 16 , FALSE ) ;\n return offset ;\n }", "idx": 20513}
{"hash": -357657257866300423, "project": "debian", "size": 12, "label": 0, "functionSource": "int ztoken_get_scanner_option ( const ref * psref , int options , const char * * pname ) {\n const named_scanner_option_t * pnso ;\n for ( pnso = named_options + countof ( named_options ) ;\n pnso -- != named_options ;\n ) {\n if ( ! bytes_compare ( ( const byte * ) pnso -> pname , strlen ( pnso -> pname ) , psref -> value . const_bytes , r_size ( psref ) ) ) {\n * pname = pnso -> pname ;\n return ( options & pnso -> option ? 1 : 0 ) ;\n }\n }\n return - 1 ;\n }", "idx": 20514}
{"hash": -5706788925640467782, "project": "chrome", "size": 19, "label": 0, "functionSource": "static int sb_has_motion ( const VP9_COMMON * cm , MODE_INFO * prev_mi_8x8 , const int motion_thresh ) {\n const int mis = cm -> mi_stride ;\n int block_row , block_col ;\n if ( cm -> prev_mi ) {\n for ( block_row = 0 ;\n block_row < 8 ;\n ++ block_row ) {\n for ( block_col = 0 ;\n block_col < 8 ;\n ++ block_col ) {\n const MODE_INFO * prev_mi = prev_mi_8x8 [ block_row * mis + block_col ] . src_mi ;\n if ( prev_mi ) {\n if ( abs ( prev_mi -> mbmi . mv [ 0 ] . as_mv . row ) > motion_thresh || abs ( prev_mi -> mbmi . mv [ 0 ] . as_mv . col ) > motion_thresh ) return 1 ;\n }\n }\n }\n }\n return 0 ;\n }", "idx": 20515}
{"hash": -331579171381918893, "project": "debian", "size": 18, "label": 0, "functionSource": "SRP_VBASE * SRP_VBASE_new ( char * seed_key ) {\n SRP_VBASE * vb = ( SRP_VBASE * ) OPENSSL_malloc ( sizeof ( SRP_VBASE ) ) ;\n if ( vb == NULL ) return NULL ;\n if ( ! ( vb -> users_pwd = sk_SRP_user_pwd_new_null ( ) ) || ! ( vb -> gN_cache = sk_SRP_gN_cache_new_null ( ) ) ) {\n OPENSSL_free ( vb ) ;\n return NULL ;\n }\n vb -> default_g = NULL ;\n vb -> default_N = NULL ;\n vb -> seed_key = NULL ;\n if ( ( seed_key != NULL ) && ( vb -> seed_key = BUF_strdup ( seed_key ) ) == NULL ) {\n sk_SRP_user_pwd_free ( vb -> users_pwd ) ;\n sk_SRP_gN_cache_free ( vb -> gN_cache ) ;\n OPENSSL_free ( vb ) ;\n return NULL ;\n }\n return vb ;\n }", "idx": 20516}
{"hash": -5493081488206619677, "project": "debian", "size": 11, "label": 0, "functionSource": "static const char * cmd_request_body_limit ( cmd_parms * cmd , void * _dcfg , const char * p1 ) {\n directory_config * dcfg = ( directory_config * ) _dcfg ;\n long int limit ;\n if ( dcfg == NULL ) return NULL ;\n limit = strtol ( p1 , NULL , 10 ) ;\n if ( ( limit == LONG_MAX ) || ( limit == LONG_MIN ) || ( limit <= 0 ) ) {\n return apr_psprintf ( cmd -> pool , \"ModSecurity: Invalid value for SecRequestBodyLimit: %s\" , p1 ) ;\n }\n dcfg -> reqbody_limit = limit ;\n return NULL ;\n }", "idx": 20517}
{"hash": 3401745371761513837, "project": "debian", "size": 19, "label": 0, "functionSource": "static void test_2 ( void ) {\n static char * invalid_labels [ ] = {\n \"C=de,FOO=something,O=bar\" , \"Y=foo, C=baz\" , NULL }\n ;\n gpg_error_t err ;\n int i ;\n unsigned char * buf ;\n size_t off , len ;\n for ( i = 0 ;\n invalid_labels [ i ] ;\n i ++ ) {\n err = ksba_dn_str2der ( invalid_labels [ i ] , & buf , & len ) ;\n if ( gpg_err_code ( err ) != GPG_ERR_UNKNOWN_NAME ) fail ( \"invalid label not detected\" ) ;\n err = ksba_dn_teststr ( invalid_labels [ i ] , 0 , & off , & len ) ;\n if ( ! err ) fail ( \"ksba_dn_test_str returned no error\" ) ;\n printf ( \"string ->%s<- error at %lu.%lu (%.*s)\\n\" , invalid_labels [ i ] , ( unsigned long ) off , ( unsigned long ) len , ( int ) len , invalid_labels [ i ] + off ) ;\n xfree ( buf ) ;\n }\n }", "idx": 20518}
{"hash": 4180964683905830761, "project": "debian", "size": 20, "label": 0, "functionSource": "static int selinux_genfs_get_sid ( struct dentry * dentry , u16 tclass , u16 flags , u32 * sid ) {\n int rc ;\n struct super_block * sb = dentry -> d_sb ;\n char * buffer , * path ;\n buffer = ( char * ) __get_free_page ( GFP_KERNEL ) ;\n if ( ! buffer ) return - ENOMEM ;\n path = dentry_path_raw ( dentry , buffer , PAGE_SIZE ) ;\n if ( IS_ERR ( path ) ) rc = PTR_ERR ( path ) ;\n else {\n if ( flags & SE_SBPROC ) {\n while ( path [ 1 ] >= '0' && path [ 1 ] <= '9' ) {\n path [ 1 ] = '/' ;\n path ++ ;\n }\n }\n rc = security_genfs_sid ( sb -> s_type -> name , path , tclass , sid ) ;\n }\n free_page ( ( unsigned long ) buffer ) ;\n return rc ;\n }", "idx": 20519}
{"hash": -341028540041678099, "project": "debian", "size": 61, "label": 0, "functionSource": "static int sendrequest ( int opcode , associd_t associd , int auth , int qsize , const char * qdata ) {\n struct ntp_control qpkt ;\n int pktsize ;\n u_long key_id ;\n char * pass ;\n int maclen ;\n if ( qsize > CTL_MAX_DATA_LEN ) {\n fprintf ( stderr , \"***Internal error! qsize (%d) too large\\n\" , qsize ) ;\n return 1 ;\n }\n qpkt . li_vn_mode = PKT_LI_VN_MODE ( 0 , pktversion , MODE_CONTROL ) ;\n qpkt . r_m_e_op = ( u_char ) ( opcode & CTL_OP_MASK ) ;\n qpkt . sequence = htons ( sequence ) ;\n qpkt . status = 0 ;\n qpkt . associd = htons ( ( u_short ) associd ) ;\n qpkt . offset = 0 ;\n qpkt . count = htons ( ( u_short ) qsize ) ;\n pktsize = CTL_HEADER_LEN ;\n if ( qsize > 0 ) {\n memcpy ( & qpkt . u , qdata , ( size_t ) qsize ) ;\n pktsize += qsize ;\n while ( pktsize & ( sizeof ( u_int32 ) - 1 ) ) {\n qpkt . u . data [ qsize ++ ] = 0 ;\n pktsize ++ ;\n }\n }\n if ( ! auth && ! always_auth ) {\n return sendpkt ( & qpkt , pktsize ) ;\n }\n while ( pktsize & 7 ) {\n qpkt . u . data [ qsize ++ ] = 0 ;\n pktsize ++ ;\n }\n if ( info_auth_keyid == 0 ) {\n key_id = getkeyid ( \"Keyid: \" ) ;\n if ( key_id == 0 || key_id > NTP_MAXKEY ) {\n fprintf ( stderr , \"Invalid key identifier\\n\" ) ;\n return 1 ;\n }\n info_auth_keyid = key_id ;\n }\n if ( ! authistrusted ( info_auth_keyid ) ) {\n pass = getpass_keytype ( info_auth_keytype ) ;\n if ( '\\0' == pass [ 0 ] ) {\n fprintf ( stderr , \"Invalid password\\n\" ) ;\n return 1 ;\n }\n authusekey ( info_auth_keyid , info_auth_keytype , ( u_char * ) pass ) ;\n authtrust ( info_auth_keyid , 1 ) ;\n }\n maclen = authencrypt ( info_auth_keyid , ( void * ) & qpkt , pktsize ) ;\n if ( ! maclen ) {\n fprintf ( stderr , \"Key not found\\n\" ) ;\n return 1 ;\n }\n else if ( ( size_t ) maclen != ( info_auth_hashlen + sizeof ( keyid_t ) ) ) {\n fprintf ( stderr , \"%d octet MAC, %zu expected with %zu octet digest\\n\" , maclen , ( info_auth_hashlen + sizeof ( keyid_t ) ) , info_auth_hashlen ) ;\n return 1 ;\n }\n return sendpkt ( ( char * ) & qpkt , pktsize + maclen ) ;\n }", "idx": 20520}
{"hash": -7117046864335130087, "project": "chrome", "size": 22, "label": 0, "functionSource": "int vp9_rc_regulate_q ( const VP9_COMP * cpi , int target_bits_per_frame , int active_best_quality , int active_worst_quality ) {\n const VP9_COMMON * const cm = & cpi -> common ;\n int q = active_worst_quality ;\n int last_error = INT_MAX ;\n int i , target_bits_per_mb ;\n const double correction_factor = get_rate_correction_factor ( cpi ) ;\n target_bits_per_mb = ( ( uint64_t ) target_bits_per_frame << BPER_MB_NORMBITS ) / cm -> MBs ;\n i = active_best_quality ;\n do {\n const int bits_per_mb_at_this_q = ( int ) vp9_rc_bits_per_mb ( cm -> frame_type , i , correction_factor , cm -> bit_depth ) ;\n if ( bits_per_mb_at_this_q <= target_bits_per_mb ) {\n if ( ( target_bits_per_mb - bits_per_mb_at_this_q ) <= last_error ) q = i ;\n else q = i - 1 ;\n break ;\n }\n else {\n last_error = bits_per_mb_at_this_q - target_bits_per_mb ;\n }\n }\n while ( ++ i <= active_worst_quality ) ;\n return q ;\n }", "idx": 20521}
{"hash": -2899237383573912022, "project": "debian", "size": 137, "label": 0, "functionSource": "static int encode_block ( SVQ1Context * s , uint8_t * src , uint8_t * ref , uint8_t * decoded , int stride , int level , int threshold , int lambda , int intra ) {\n int count , y , x , i , j , split , best_mean , best_score , best_count ;\n int best_vector [ 6 ] ;\n int block_sum [ 7 ] = {\n 0 , 0 , 0 , 0 , 0 , 0 }\n ;\n int w = 2 << ( level + 2 >> 1 ) ;\n int h = 2 << ( level + 1 >> 1 ) ;\n int size = w * h ;\n int16_t block [ 7 ] [ 256 ] ;\n const int8_t * codebook_sum , * codebook ;\n const uint16_t ( * mean_vlc ) [ 2 ] ;\n const uint8_t ( * multistage_vlc ) [ 2 ] ;\n best_score = 0 ;\n if ( intra ) {\n codebook_sum = svq1_intra_codebook_sum [ level ] ;\n codebook = ff_svq1_intra_codebooks [ level ] ;\n mean_vlc = ff_svq1_intra_mean_vlc ;\n multistage_vlc = ff_svq1_intra_multistage_vlc [ level ] ;\n for ( y = 0 ;\n y < h ;\n y ++ ) {\n for ( x = 0 ;\n x < w ;\n x ++ ) {\n int v = src [ x + y * stride ] ;\n block [ 0 ] [ x + w * y ] = v ;\n best_score += v * v ;\n block_sum [ 0 ] += v ;\n }\n }\n }\n else {\n codebook_sum = svq1_inter_codebook_sum [ level ] ;\n codebook = ff_svq1_inter_codebooks [ level ] ;\n mean_vlc = ff_svq1_inter_mean_vlc + 256 ;\n multistage_vlc = ff_svq1_inter_multistage_vlc [ level ] ;\n for ( y = 0 ;\n y < h ;\n y ++ ) {\n for ( x = 0 ;\n x < w ;\n x ++ ) {\n int v = src [ x + y * stride ] - ref [ x + y * stride ] ;\n block [ 0 ] [ x + w * y ] = v ;\n best_score += v * v ;\n block_sum [ 0 ] += v ;\n }\n }\n }\n best_count = 0 ;\n best_score -= ( int ) ( ( unsigned ) block_sum [ 0 ] * block_sum [ 0 ] >> ( level + 3 ) ) ;\n best_mean = block_sum [ 0 ] + ( size >> 1 ) >> ( level + 3 ) ;\n if ( level < 4 ) {\n for ( count = 1 ;\n count < 7 ;\n count ++ ) {\n int best_vector_score = INT_MAX ;\n int best_vector_sum = - 999 , best_vector_mean = - 999 ;\n const int stage = count - 1 ;\n const int8_t * vector ;\n for ( i = 0 ;\n i < 16 ;\n i ++ ) {\n int sum = codebook_sum [ stage * 16 + i ] ;\n int sqr , diff , score ;\n vector = codebook + stage * size * 16 + i * size ;\n sqr = s -> dsp . ssd_int8_vs_int16 ( vector , block [ stage ] , size ) ;\n diff = block_sum [ stage ] - sum ;\n score = sqr - ( diff * ( int64_t ) diff >> ( level + 3 ) ) ;\n if ( score < best_vector_score ) {\n int mean = diff + ( size >> 1 ) >> ( level + 3 ) ;\n assert ( mean > - 300 && mean < 300 ) ;\n mean = av_clip ( mean , intra ? 0 : - 256 , 255 ) ;\n best_vector_score = score ;\n best_vector [ stage ] = i ;\n best_vector_sum = sum ;\n best_vector_mean = mean ;\n }\n }\n assert ( best_vector_mean != - 999 ) ;\n vector = codebook + stage * size * 16 + best_vector [ stage ] * size ;\n for ( j = 0 ;\n j < size ;\n j ++ ) block [ stage + 1 ] [ j ] = block [ stage ] [ j ] - vector [ j ] ;\n block_sum [ stage + 1 ] = block_sum [ stage ] - best_vector_sum ;\n best_vector_score += lambda * ( + 1 + 4 * count + multistage_vlc [ 1 + count ] [ 1 ] + mean_vlc [ best_vector_mean ] [ 1 ] ) ;\n if ( best_vector_score < best_score ) {\n best_score = best_vector_score ;\n best_count = count ;\n best_mean = best_vector_mean ;\n }\n }\n }\n split = 0 ;\n if ( best_score > threshold && level ) {\n int score = 0 ;\n int offset = level & 1 ? stride * h / 2 : w / 2 ;\n PutBitContext backup [ 6 ] ;\n for ( i = level - 1 ;\n i >= 0 ;\n i -- ) backup [ i ] = s -> reorder_pb [ i ] ;\n score += encode_block ( s , src , ref , decoded , stride , level - 1 , threshold >> 1 , lambda , intra ) ;\n score += encode_block ( s , src + offset , ref + offset , decoded + offset , stride , level - 1 , threshold >> 1 , lambda , intra ) ;\n score += lambda ;\n if ( score < best_score ) {\n best_score = score ;\n split = 1 ;\n }\n else {\n for ( i = level - 1 ;\n i >= 0 ;\n i -- ) s -> reorder_pb [ i ] = backup [ i ] ;\n }\n }\n if ( level > 0 ) put_bits ( & s -> reorder_pb [ level ] , 1 , split ) ;\n if ( ! split ) {\n assert ( best_mean >= 0 && best_mean < 256 || ! intra ) ;\n assert ( best_mean >= - 256 && best_mean < 256 ) ;\n assert ( best_count >= 0 && best_count < 7 ) ;\n assert ( level < 4 || best_count == 0 ) ;\n put_bits ( & s -> reorder_pb [ level ] , multistage_vlc [ 1 + best_count ] [ 1 ] , multistage_vlc [ 1 + best_count ] [ 0 ] ) ;\n put_bits ( & s -> reorder_pb [ level ] , mean_vlc [ best_mean ] [ 1 ] , mean_vlc [ best_mean ] [ 0 ] ) ;\n for ( i = 0 ;\n i < best_count ;\n i ++ ) {\n assert ( best_vector [ i ] >= 0 && best_vector [ i ] < 16 ) ;\n put_bits ( & s -> reorder_pb [ level ] , 4 , best_vector [ i ] ) ;\n }\n for ( y = 0 ;\n y < h ;\n y ++ ) for ( x = 0 ;\n x < w ;\n x ++ ) decoded [ x + y * stride ] = src [ x + y * stride ] - block [ best_count ] [ x + w * y ] + best_mean ;\n }\n return best_score ;\n }", "idx": 20522}
{"hash": 1676654288894940649, "project": "debian", "size": 8, "label": 0, "functionSource": "static void prepare_dummy_password ( char * buf , size_t sz ) {\n size_t i ;\n strlcpy ( buf , \"6F a[\" , sz ) ;\n for ( i = strlen ( buf ) ;\n i < sz - 1 ;\n i ++ ) buf [ i ] = 'a' + ( i % 26 ) ;\n buf [ sz - 1 ] = '\\0' ;\n }", "idx": 20523}
{"hash": -8176848763607321091, "project": "chrome", "size": 7, "label": 0, "functionSource": "TEST_F ( HistoryQuickProviderTest , DaysAgoMatches ) {\n std : : vector < std : : string > expected_urls ;\n expected_urls . push_back ( \"http://daysagoest.com/y/a\" ) ;\n expected_urls . push_back ( \"http://daysagoest.com/y/b\" ) ;\n expected_urls . push_back ( \"http://daysagoest.com/x/c\" ) ;\n RunTest ( ASCIIToUTF16 ( \"daysagoest\" ) , false , expected_urls , true , ASCIIToUTF16 ( \"daysagoest.com/y/a\" ) , ASCIIToUTF16 ( \".com/y/a\" ) ) ;\n }", "idx": 20524}
{"hash": -8365810778652022218, "project": "debian", "size": 9, "label": 0, "functionSource": "static void virtio_net_set_config ( VirtIODevice * vdev , const uint8_t * config ) {\n VirtIONet * n = to_virtio_net ( vdev ) ;\n struct virtio_net_config netcfg ;\n memcpy ( & netcfg , config , sizeof ( netcfg ) ) ;\n if ( memcmp ( netcfg . mac , n -> mac , ETH_ALEN ) ) {\n memcpy ( n -> mac , netcfg . mac , ETH_ALEN ) ;\n qemu_format_nic_info_str ( & n -> nic -> nc , n -> mac ) ;\n }\n }", "idx": 20525}
{"hash": 1366214969540455677, "project": "debian", "size": 92, "label": 1, "functionSource": "void name ## _free ( type * a ) ;\n # define DECLARE_ASN1_PRINT_FUNCTION ( stname ) DECLARE_ASN1_PRINT_FUNCTION_fname ( stname , stname ) # define DECLARE_ASN1_PRINT_FUNCTION_fname ( stname , fname ) int fname ## _print_ctx ( BIO * out , stname * x , int indent , const ASN1_PCTX * pctx ) ;\n # define D2I_OF ( type ) type * ( * ) ( type * * , const unsigned char * * , long ) # define I2D_OF ( type ) int ( * ) ( type * , unsigned char * * ) # define I2D_OF_const ( type ) int ( * ) ( const type * , unsigned char * * ) # define CHECKED_D2I_OF ( type , d2i ) ( ( d2i_of_void * ) ( 1 ? d2i : ( ( D2I_OF ( type ) ) 0 ) ) ) # define CHECKED_I2D_OF ( type , i2d ) ( ( i2d_of_void * ) ( 1 ? i2d : ( ( I2D_OF ( type ) ) 0 ) ) ) # define CHECKED_NEW_OF ( type , xnew ) ( ( void * ( * ) ( void ) ) ( 1 ? xnew : ( ( type * ( * ) ( void ) ) 0 ) ) ) # define CHECKED_PTR_OF ( type , p ) ( ( void * ) ( 1 ? p : ( type * ) 0 ) ) # define CHECKED_PPTR_OF ( type , p ) ( ( void * * ) ( 1 ? p : ( type * * ) 0 ) ) # define TYPEDEF_D2I_OF ( type ) typedef type * d2i_of_ ## type ( type * * , const unsigned char * * , long ) # define TYPEDEF_I2D_OF ( type ) typedef int i2d_of_ ## type ( type * , unsigned char * * ) # define TYPEDEF_D2I2D_OF ( type ) TYPEDEF_D2I_OF ( type ) ;\n TYPEDEF_I2D_OF ( type ) TYPEDEF_D2I2D_OF ( void ) ;\n # ifndef OPENSSL_EXPORT_VAR_AS_FUNCTION typedef const ASN1_ITEM ASN1_ITEM_EXP ;\n # define ASN1_ITEM_ptr ( iptr ) ( iptr ) # define ASN1_ITEM_ref ( iptr ) ( & ( iptr ## _it ) ) # define ASN1_ITEM_rptr ( ref ) ( & ( ref ## _it ) ) # define DECLARE_ASN1_ITEM ( name ) OPENSSL_EXTERN const ASN1_ITEM name ## _it ;\n # else typedef const ASN1_ITEM * ASN1_ITEM_EXP ( void ) ;\n # define ASN1_ITEM_ptr ( iptr ) ( iptr ( ) ) # define ASN1_ITEM_ref ( iptr ) ( iptr ## _it ) # define ASN1_ITEM_rptr ( ref ) ( ref ## _it ( ) ) # define DECLARE_ASN1_ITEM ( name ) const ASN1_ITEM * name ## _it ( void ) ;\n # endif # define ASN1_STRFLGS_ESC_2253 1 # define ASN1_STRFLGS_ESC_CTRL 2 # define ASN1_STRFLGS_ESC_MSB 4 # define ASN1_STRFLGS_ESC_QUOTE 8 # define CHARTYPE_PRINTABLESTRING 0x10 # define CHARTYPE_FIRST_ESC_2253 0x20 # define CHARTYPE_LAST_ESC_2253 0x40 # define ASN1_STRFLGS_UTF8_CONVERT 0x10 # define ASN1_STRFLGS_IGNORE_TYPE 0x20 # define ASN1_STRFLGS_SHOW_TYPE 0x40 # define ASN1_STRFLGS_DUMP_ALL 0x80 # define ASN1_STRFLGS_DUMP_UNKNOWN 0x100 # define ASN1_STRFLGS_DUMP_DER 0x200 # define ASN1_STRFLGS_ESC_2254 0x400 # define ASN1_STRFLGS_RFC2253 ( ASN1_STRFLGS_ESC_2253 | ASN1_STRFLGS_ESC_CTRL | ASN1_STRFLGS_ESC_MSB | ASN1_STRFLGS_UTF8_CONVERT | ASN1_STRFLGS_DUMP_UNKNOWN | ASN1_STRFLGS_DUMP_DER ) DEFINE_STACK_OF ( ASN1_INTEGER ) DEFINE_STACK_OF ( ASN1_GENERALSTRING ) DEFINE_STACK_OF ( ASN1_UTF8STRING ) typedef struct asn1_type_st {\n int type ;\n union {\n char * ptr ;\n ASN1_BOOLEAN boolean ;\n ASN1_STRING * asn1_string ;\n ASN1_OBJECT * object ;\n ASN1_INTEGER * integer ;\n ASN1_ENUMERATED * enumerated ;\n ASN1_BIT_STRING * bit_string ;\n ASN1_OCTET_STRING * octet_string ;\n ASN1_PRINTABLESTRING * printablestring ;\n ASN1_T61STRING * t61string ;\n ASN1_IA5STRING * ia5string ;\n ASN1_GENERALSTRING * generalstring ;\n ASN1_BMPSTRING * bmpstring ;\n ASN1_UNIVERSALSTRING * universalstring ;\n ASN1_UTCTIME * utctime ;\n ASN1_GENERALIZEDTIME * generalizedtime ;\n ASN1_VISIBLESTRING * visiblestring ;\n ASN1_UTF8STRING * utf8string ;\n ASN1_STRING * set ;\n ASN1_STRING * sequence ;\n ASN1_VALUE * asn1_value ;\n }\n value ;\n }\n ASN1_TYPE ;\n DEFINE_STACK_OF ( ASN1_TYPE ) typedef STACK_OF ( ASN1_TYPE ) ASN1_SEQUENCE_ANY ;\n DECLARE_ASN1_ENCODE_FUNCTIONS_const ( ASN1_SEQUENCE_ANY , ASN1_SEQUENCE_ANY ) DECLARE_ASN1_ENCODE_FUNCTIONS_const ( ASN1_SEQUENCE_ANY , ASN1_SET_ANY ) typedef struct BIT_STRING_BITNAME_st {\n int bitnum ;\n const char * lname ;\n const char * sname ;\n }\n BIT_STRING_BITNAME ;\n # define B_ASN1_TIME B_ASN1_UTCTIME | B_ASN1_GENERALIZEDTIME # define B_ASN1_PRINTABLE B_ASN1_NUMERICSTRING | B_ASN1_PRINTABLESTRING | B_ASN1_T61STRING | B_ASN1_IA5STRING | B_ASN1_BIT_STRING | B_ASN1_UNIVERSALSTRING | B_ASN1_BMPSTRING | B_ASN1_UTF8STRING | B_ASN1_SEQUENCE | B_ASN1_UNKNOWN # define B_ASN1_DIRECTORYSTRING B_ASN1_PRINTABLESTRING | B_ASN1_TELETEXSTRING | B_ASN1_BMPSTRING | B_ASN1_UNIVERSALSTRING | B_ASN1_UTF8STRING # define B_ASN1_DISPLAYTEXT B_ASN1_IA5STRING | B_ASN1_VISIBLESTRING | B_ASN1_BMPSTRING | B_ASN1_UTF8STRING DECLARE_ASN1_FUNCTIONS_fname ( ASN1_TYPE , ASN1_ANY , ASN1_TYPE ) int ASN1_TYPE_get ( const ASN1_TYPE * a ) ;\n void ASN1_TYPE_set ( ASN1_TYPE * a , int type , void * value ) ;\n int ASN1_TYPE_set1 ( ASN1_TYPE * a , int type , const void * value ) ;\n int ASN1_TYPE_cmp ( const ASN1_TYPE * a , const ASN1_TYPE * b ) ;\n ASN1_TYPE * ASN1_TYPE_pack_sequence ( const ASN1_ITEM * it , void * s , ASN1_TYPE * * t ) ;\n void * ASN1_TYPE_unpack_sequence ( const ASN1_ITEM * it , const ASN1_TYPE * t ) ;\n ASN1_OBJECT * ASN1_OBJECT_new ( void ) ;\n void ASN1_OBJECT_free ( ASN1_OBJECT * a ) ;\n int i2d_ASN1_OBJECT ( const ASN1_OBJECT * a , unsigned char * * pp ) ;\n ASN1_OBJECT * d2i_ASN1_OBJECT ( ASN1_OBJECT * * a , const unsigned char * * pp , long length ) ;\n DECLARE_ASN1_ITEM ( ASN1_OBJECT ) DEFINE_STACK_OF ( ASN1_OBJECT ) ASN1_STRING * ASN1_STRING_new ( void ) ;\n void ASN1_STRING_free ( ASN1_STRING * a ) ;\n void ASN1_STRING_clear_free ( ASN1_STRING * a ) ;\n int ASN1_STRING_copy ( ASN1_STRING * dst , const ASN1_STRING * str ) ;\n ASN1_STRING * ASN1_STRING_dup ( const ASN1_STRING * a ) ;\n ASN1_STRING * ASN1_STRING_type_new ( int type ) ;\n int ASN1_STRING_cmp ( const ASN1_STRING * a , const ASN1_STRING * b ) ;\n int ASN1_STRING_set ( ASN1_STRING * str , const void * data , int len ) ;\n void ASN1_STRING_set0 ( ASN1_STRING * str , void * data , int len ) ;\n int ASN1_STRING_length ( const ASN1_STRING * x ) ;\n void ASN1_STRING_length_set ( ASN1_STRING * x , int n ) ;\n int ASN1_STRING_type ( const ASN1_STRING * x ) ;\n DEPRECATEDIN_1_1_0 ( unsigned char * ASN1_STRING_data ( ASN1_STRING * x ) ) const unsigned char * ASN1_STRING_get0_data ( const ASN1_STRING * x ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_BIT_STRING ) int ASN1_BIT_STRING_set ( ASN1_BIT_STRING * a , unsigned char * d , int length ) ;\n int ASN1_BIT_STRING_set_bit ( ASN1_BIT_STRING * a , int n , int value ) ;\n int ASN1_BIT_STRING_get_bit ( const ASN1_BIT_STRING * a , int n ) ;\n int ASN1_BIT_STRING_check ( const ASN1_BIT_STRING * a , const unsigned char * flags , int flags_len ) ;\n int ASN1_BIT_STRING_name_print ( BIO * out , ASN1_BIT_STRING * bs , BIT_STRING_BITNAME * tbl , int indent ) ;\n int ASN1_BIT_STRING_num_asc ( const char * name , BIT_STRING_BITNAME * tbl ) ;\n int ASN1_BIT_STRING_set_asc ( ASN1_BIT_STRING * bs , const char * name , int value , BIT_STRING_BITNAME * tbl ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_INTEGER ) ASN1_INTEGER * d2i_ASN1_UINTEGER ( ASN1_INTEGER * * a , const unsigned char * * pp , long length ) ;\n ASN1_INTEGER * ASN1_INTEGER_dup ( const ASN1_INTEGER * x ) ;\n int ASN1_INTEGER_cmp ( const ASN1_INTEGER * x , const ASN1_INTEGER * y ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_ENUMERATED ) int ASN1_UTCTIME_check ( const ASN1_UTCTIME * a ) ;\n ASN1_UTCTIME * ASN1_UTCTIME_set ( ASN1_UTCTIME * s , time_t t ) ;\n ASN1_UTCTIME * ASN1_UTCTIME_adj ( ASN1_UTCTIME * s , time_t t , int offset_day , long offset_sec ) ;\n int ASN1_UTCTIME_set_string ( ASN1_UTCTIME * s , const char * str ) ;\n int ASN1_UTCTIME_cmp_time_t ( const ASN1_UTCTIME * s , time_t t ) ;\n int ASN1_GENERALIZEDTIME_check ( const ASN1_GENERALIZEDTIME * a ) ;\n ASN1_GENERALIZEDTIME * ASN1_GENERALIZEDTIME_set ( ASN1_GENERALIZEDTIME * s , time_t t ) ;\n ASN1_GENERALIZEDTIME * ASN1_GENERALIZEDTIME_adj ( ASN1_GENERALIZEDTIME * s , time_t t , int offset_day , long offset_sec ) ;\n int ASN1_GENERALIZEDTIME_set_string ( ASN1_GENERALIZEDTIME * s , const char * str ) ;\n int ASN1_TIME_diff ( int * pday , int * psec , const ASN1_TIME * from , const ASN1_TIME * to ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_OCTET_STRING ) ASN1_OCTET_STRING * ASN1_OCTET_STRING_dup ( const ASN1_OCTET_STRING * a ) ;\n int ASN1_OCTET_STRING_cmp ( const ASN1_OCTET_STRING * a , const ASN1_OCTET_STRING * b ) ;\n int ASN1_OCTET_STRING_set ( ASN1_OCTET_STRING * str , const unsigned char * data , int len ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_VISIBLESTRING ) DECLARE_ASN1_FUNCTIONS ( ASN1_UNIVERSALSTRING ) DECLARE_ASN1_FUNCTIONS ( ASN1_UTF8STRING ) DECLARE_ASN1_FUNCTIONS ( ASN1_NULL ) DECLARE_ASN1_FUNCTIONS ( ASN1_BMPSTRING ) int UTF8_getc ( const unsigned char * str , int len , unsigned long * val ) ;\n int UTF8_putc ( unsigned char * str , int len , unsigned long value ) ;\n DECLARE_ASN1_FUNCTIONS_name ( ASN1_STRING , ASN1_PRINTABLE )", "idx": 20526}
{"hash": -8919449269326401539, "project": "debian", "size": 108, "label": 1, "functionSource": "static void dissect_cip_safety_data ( proto_tree * tree , proto_item * item , tvbuff_t * tvb , int item_length , packet_info * pinfo ) {\n int base_length , io_data_size ;\n gboolean multicast = ( ( ( pntoh32 ( pinfo -> dst . data ) ) & 0xf0000000 ) == 0xe0000000 ) ;\n gboolean server_dir = FALSE ;\n enum enip_connid_type conn_type = ECIDT_UNKNOWN ;\n enum cip_safety_format_type format = CIP_SAFETY_BASE_FORMAT ;\n cip_safety_info_t * safety_info = ( cip_safety_info_t * ) p_get_proto_data ( wmem_file_scope ( ) , pinfo , proto_cipsafety , 0 ) ;\n col_set_str ( pinfo -> cinfo , COL_PROTOCOL , \"CIP Safety\" ) ;\n if ( safety_info != NULL ) {\n conn_type = safety_info -> conn_type ;\n format = safety_info -> format ;\n server_dir = safety_info -> server_dir ;\n }\n base_length = multicast ? 12 : 6 ;\n if ( ( ( conn_type == ECIDT_O2T ) && ( server_dir == FALSE ) ) || ( ( conn_type == ECIDT_T2O ) && ( server_dir == TRUE ) ) ) {\n dissect_ack_byte ( tree , tvb , 0 , pinfo ) ;\n proto_tree_add_item ( tree , hf_cipsafety_consumer_time_value , tvb , 1 , 2 , ENC_LITTLE_ENDIAN ) ;\n switch ( format ) {\n case CIP_SAFETY_BASE_FORMAT : proto_tree_add_item ( tree , hf_cipsafety_ack_byte2 , tvb , 3 , 1 , ENC_LITTLE_ENDIAN ) ;\n proto_tree_add_item ( tree , hf_cipsafety_crc_s3 , tvb , 4 , 2 , ENC_LITTLE_ENDIAN ) ;\n break ;\n case CIP_SAFETY_EXTENDED_FORMAT : proto_tree_add_item ( tree , hf_cipsafety_crc_s5_0 , tvb , 3 , 1 , ENC_LITTLE_ENDIAN ) ;\n proto_tree_add_item ( tree , hf_cipsafety_crc_s5_1 , tvb , 4 , 1 , ENC_LITTLE_ENDIAN ) ;\n proto_tree_add_item ( tree , hf_cipsafety_crc_s5_2 , tvb , 5 , 1 , ENC_LITTLE_ENDIAN ) ;\n break ;\n }\n }\n else if ( ( ( conn_type == ECIDT_O2T ) && ( server_dir == TRUE ) ) || ( ( conn_type == ECIDT_T2O ) && ( server_dir == FALSE ) ) ) {\n switch ( format ) {\n case CIP_SAFETY_BASE_FORMAT : if ( item_length - base_length <= 2 ) {\n proto_tree_add_item ( tree , hf_cipsafety_data , tvb , 0 , item_length - base_length , ENC_NA ) ;\n dissect_mode_byte ( tree , tvb , item_length - base_length , pinfo ) ;\n proto_tree_add_item ( tree , hf_cipsafety_crc_s1 , tvb , item_length - base_length + 1 , 1 , ENC_LITTLE_ENDIAN ) ;\n proto_tree_add_item ( tree , hf_cipsafety_crc_s2 , tvb , item_length - base_length + 2 , 1 , ENC_LITTLE_ENDIAN ) ;\n proto_tree_add_item ( tree , hf_cipsafety_timestamp , tvb , item_length - base_length + 3 , 2 , ENC_LITTLE_ENDIAN ) ;\n proto_tree_add_item ( tree , hf_cipsafety_crc_s1 , tvb , item_length - base_length + 5 , 1 , ENC_LITTLE_ENDIAN ) ;\n if ( multicast ) {\n dissect_mcast_byte ( tree , tvb , item_length - 6 , pinfo ) ;\n proto_tree_add_item ( tree , hf_cipsafety_time_correction , tvb , item_length - 5 , 2 , ENC_LITTLE_ENDIAN ) ;\n proto_tree_add_item ( tree , hf_cipsafety_mcast_byte2 , tvb , item_length - 3 , 1 , ENC_LITTLE_ENDIAN ) ;\n proto_tree_add_item ( tree , hf_cipsafety_crc_s3 , tvb , item_length - 2 , 2 , ENC_LITTLE_ENDIAN ) ;\n }\n }\n else {\n if ( item_length % 2 == 1 ) {\n expert_add_info ( pinfo , item , & ei_mal_io ) ;\n return ;\n }\n io_data_size = multicast ? ( ( item_length - 14 ) / 2 ) : ( ( item_length - 8 ) / 2 ) ;\n proto_tree_add_item ( tree , hf_cipsafety_data , tvb , 0 , io_data_size , ENC_NA ) ;\n dissect_mode_byte ( tree , tvb , io_data_size , pinfo ) ;\n proto_tree_add_item ( tree , hf_cipsafety_crc_s3 , tvb , io_data_size + 1 , 2 , ENC_LITTLE_ENDIAN ) ;\n proto_tree_add_item ( tree , hf_cipsafety_complement_data , tvb , io_data_size + 3 , io_data_size , ENC_NA ) ;\n proto_tree_add_item ( tree , hf_cipsafety_crc_s3 , tvb , ( io_data_size * 2 ) + 3 , 2 , ENC_LITTLE_ENDIAN ) ;\n proto_tree_add_item ( tree , hf_cipsafety_timestamp , tvb , ( io_data_size * 2 ) + 5 , 2 , ENC_LITTLE_ENDIAN ) ;\n proto_tree_add_item ( tree , hf_cipsafety_crc_s1 , tvb , ( io_data_size * 2 ) + 7 , 1 , ENC_LITTLE_ENDIAN ) ;\n if ( multicast ) {\n dissect_mcast_byte ( tree , tvb , ( io_data_size * 2 ) + 5 , pinfo ) ;\n proto_tree_add_item ( tree , hf_cipsafety_time_correction , tvb , ( io_data_size * 2 ) + 6 , 2 , ENC_LITTLE_ENDIAN ) ;\n proto_tree_add_item ( tree , hf_cipsafety_mcast_byte2 , tvb , ( io_data_size * 2 ) + 8 , 1 , ENC_LITTLE_ENDIAN ) ;\n proto_tree_add_item ( tree , hf_cipsafety_crc_s3 , tvb , ( io_data_size * 2 ) + 9 , 2 , ENC_LITTLE_ENDIAN ) ;\n }\n }\n break ;\n case CIP_SAFETY_EXTENDED_FORMAT : if ( item_length - base_length <= 2 ) {\n proto_tree_add_item ( tree , hf_cipsafety_data , tvb , 0 , item_length - base_length , ENC_NA ) ;\n dissect_mode_byte ( tree , tvb , item_length - base_length , pinfo ) ;\n proto_tree_add_item ( tree , hf_cipsafety_crc_s5_0 , tvb , item_length - base_length + 1 , 1 , ENC_LITTLE_ENDIAN ) ;\n proto_tree_add_item ( tree , hf_cipsafety_crc_s5_1 , tvb , item_length - base_length + 2 , 1 , ENC_LITTLE_ENDIAN ) ;\n proto_tree_add_item ( tree , hf_cipsafety_timestamp , tvb , item_length - base_length + 3 , 2 , ENC_LITTLE_ENDIAN ) ;\n proto_tree_add_item ( tree , hf_cipsafety_crc_s5_2 , tvb , item_length - base_length + 5 , 1 , ENC_LITTLE_ENDIAN ) ;\n if ( multicast ) {\n dissect_mcast_byte ( tree , tvb , item_length - 6 , pinfo ) ;\n proto_tree_add_item ( tree , hf_cipsafety_time_correction , tvb , item_length - 5 , 2 , ENC_LITTLE_ENDIAN ) ;\n proto_tree_add_item ( tree , hf_cipsafety_crc_s5_0 , tvb , item_length - 3 , 1 , ENC_LITTLE_ENDIAN ) ;\n proto_tree_add_item ( tree , hf_cipsafety_crc_s5_1 , tvb , item_length - 2 , 1 , ENC_LITTLE_ENDIAN ) ;\n proto_tree_add_item ( tree , hf_cipsafety_crc_s5_2 , tvb , item_length - 1 , 1 , ENC_LITTLE_ENDIAN ) ;\n }\n }\n else {\n if ( item_length % 2 == 1 ) {\n expert_add_info ( pinfo , item , & ei_mal_io ) ;\n return ;\n }\n io_data_size = multicast ? ( ( item_length - 14 ) / 2 ) : ( ( item_length - 8 ) / 2 ) ;\n proto_tree_add_item ( tree , hf_cipsafety_data , tvb , 0 , io_data_size , ENC_NA ) ;\n dissect_mode_byte ( tree , tvb , io_data_size , pinfo ) ;\n proto_tree_add_item ( tree , hf_cipsafety_crc_s3 , tvb , io_data_size + 1 , 2 , ENC_LITTLE_ENDIAN ) ;\n proto_tree_add_item ( tree , hf_cipsafety_complement_data , tvb , io_data_size + 3 , io_data_size , ENC_NA ) ;\n proto_tree_add_item ( tree , hf_cipsafety_crc_s5_0 , tvb , ( io_data_size * 2 ) + 3 , 1 , ENC_LITTLE_ENDIAN ) ;\n proto_tree_add_item ( tree , hf_cipsafety_crc_s5_1 , tvb , ( io_data_size * 2 ) + 4 , 1 , ENC_LITTLE_ENDIAN ) ;\n proto_tree_add_item ( tree , hf_cipsafety_timestamp , tvb , ( io_data_size * 2 ) + 5 , 2 , ENC_LITTLE_ENDIAN ) ;\n proto_tree_add_item ( tree , hf_cipsafety_crc_s5_2 , tvb , ( io_data_size * 2 ) + 7 , 1 , ENC_LITTLE_ENDIAN ) ;\n if ( multicast ) {\n dissect_mcast_byte ( tree , tvb , ( io_data_size * 2 ) + 8 , pinfo ) ;\n proto_tree_add_item ( tree , hf_cipsafety_time_correction , tvb , ( io_data_size * 2 ) + 9 , 2 , ENC_LITTLE_ENDIAN ) ;\n proto_tree_add_item ( tree , hf_cipsafety_crc_s5_0 , tvb , ( io_data_size * 2 ) + 11 , 1 , ENC_LITTLE_ENDIAN ) ;\n proto_tree_add_item ( tree , hf_cipsafety_crc_s5_1 , tvb , ( io_data_size * 2 ) + 12 , 1 , ENC_LITTLE_ENDIAN ) ;\n proto_tree_add_item ( tree , hf_cipsafety_crc_s5_2 , tvb , ( io_data_size * 2 ) + 13 , 1 , ENC_LITTLE_ENDIAN ) ;\n }\n }\n break ;\n }\n }\n else {\n proto_tree_add_item ( tree , hf_cipsafety_data , tvb , 0 , item_length , ENC_NA ) ;\n }\n }", "idx": 20527}
{"hash": -5706788925640467782, "project": "chrome", "size": 180, "label": 0, "functionSource": "static void nonrd_pick_partition ( VP9_COMP * cpi , const TileInfo * const tile , TOKENEXTRA * * tp , int mi_row , int mi_col , BLOCK_SIZE bsize , int * rate , int64_t * dist , int do_recon , int64_t best_rd , PC_TREE * pc_tree ) {\n const SPEED_FEATURES * const sf = & cpi -> sf ;\n const VP9EncoderConfig * const oxcf = & cpi -> oxcf ;\n VP9_COMMON * const cm = & cpi -> common ;\n MACROBLOCK * const x = & cpi -> mb ;\n MACROBLOCKD * const xd = & x -> e_mbd ;\n const int ms = num_8x8_blocks_wide_lookup [ bsize ] / 2 ;\n TOKENEXTRA * tp_orig = * tp ;\n PICK_MODE_CONTEXT * ctx = & pc_tree -> none ;\n int i ;\n BLOCK_SIZE subsize = bsize ;\n int this_rate , sum_rate = 0 , best_rate = INT_MAX ;\n int64_t this_dist , sum_dist = 0 , best_dist = INT64_MAX ;\n int64_t sum_rd = 0 ;\n int do_split = bsize >= BLOCK_8X8 ;\n int do_rect = 1 ;\n const int force_horz_split = ( mi_row + ms >= cm -> mi_rows ) ;\n const int force_vert_split = ( mi_col + ms >= cm -> mi_cols ) ;\n const int xss = x -> e_mbd . plane [ 1 ] . subsampling_x ;\n const int yss = x -> e_mbd . plane [ 1 ] . subsampling_y ;\n int partition_none_allowed = ! force_horz_split && ! force_vert_split ;\n int partition_horz_allowed = ! force_vert_split && yss <= xss && bsize >= BLOCK_8X8 ;\n int partition_vert_allowed = ! force_horz_split && xss <= yss && bsize >= BLOCK_8X8 ;\n ( void ) * tp_orig ;\n assert ( num_8x8_blocks_wide_lookup [ bsize ] == num_8x8_blocks_high_lookup [ bsize ] ) ;\n if ( sf -> auto_min_max_partition_size ) {\n partition_none_allowed &= ( bsize <= sf -> max_partition_size && bsize >= sf -> min_partition_size ) ;\n partition_horz_allowed &= ( ( bsize <= sf -> max_partition_size && bsize > sf -> min_partition_size ) || force_horz_split ) ;\n partition_vert_allowed &= ( ( bsize <= sf -> max_partition_size && bsize > sf -> min_partition_size ) || force_vert_split ) ;\n do_split &= bsize > sf -> min_partition_size ;\n }\n if ( sf -> use_square_partition_only ) {\n partition_horz_allowed &= force_horz_split ;\n partition_vert_allowed &= force_vert_split ;\n }\n if ( partition_none_allowed ) {\n nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col , & this_rate , & this_dist , bsize , ctx ) ;\n ctx -> mic . mbmi = xd -> mi [ 0 ] . src_mi -> mbmi ;\n ctx -> skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ;\n ctx -> skip = x -> skip ;\n if ( this_rate != INT_MAX ) {\n int pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ;\n this_rate += cpi -> partition_cost [ pl ] [ PARTITION_NONE ] ;\n sum_rd = RDCOST ( x -> rdmult , x -> rddiv , this_rate , this_dist ) ;\n if ( sum_rd < best_rd ) {\n int64_t stop_thresh = 4096 ;\n int64_t stop_thresh_rd ;\n best_rate = this_rate ;\n best_dist = this_dist ;\n best_rd = sum_rd ;\n if ( bsize >= BLOCK_8X8 ) pc_tree -> partitioning = PARTITION_NONE ;\n stop_thresh >>= 8 - ( b_width_log2 ( bsize ) + b_height_log2 ( bsize ) ) ;\n stop_thresh_rd = RDCOST ( x -> rdmult , x -> rddiv , 0 , stop_thresh ) ;\n if ( ! x -> e_mbd . lossless && best_rd < stop_thresh_rd ) {\n do_split = 0 ;\n do_rect = 0 ;\n }\n }\n }\n }\n store_pred_mv ( x , ctx ) ;\n sum_rd = 0 ;\n if ( do_split ) {\n int pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ;\n sum_rate += cpi -> partition_cost [ pl ] [ PARTITION_SPLIT ] ;\n subsize = get_subsize ( bsize , PARTITION_SPLIT ) ;\n for ( i = 0 ;\n i < 4 && sum_rd < best_rd ;\n ++ i ) {\n const int x_idx = ( i & 1 ) * ms ;\n const int y_idx = ( i >> 1 ) * ms ;\n if ( mi_row + y_idx >= cm -> mi_rows || mi_col + x_idx >= cm -> mi_cols ) continue ;\n load_pred_mv ( x , ctx ) ;\n nonrd_pick_partition ( cpi , tile , tp , mi_row + y_idx , mi_col + x_idx , subsize , & this_rate , & this_dist , 0 , best_rd - sum_rd , pc_tree -> split [ i ] ) ;\n if ( this_rate == INT_MAX ) {\n sum_rd = INT64_MAX ;\n }\n else {\n sum_rate += this_rate ;\n sum_dist += this_dist ;\n sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ;\n }\n }\n if ( sum_rd < best_rd ) {\n best_rate = sum_rate ;\n best_dist = sum_dist ;\n best_rd = sum_rd ;\n pc_tree -> partitioning = PARTITION_SPLIT ;\n }\n else {\n if ( sf -> less_rectangular_check ) do_rect &= ! partition_none_allowed ;\n }\n }\n if ( partition_horz_allowed && do_rect ) {\n subsize = get_subsize ( bsize , PARTITION_HORZ ) ;\n if ( sf -> adaptive_motion_search ) load_pred_mv ( x , ctx ) ;\n nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col , & this_rate , & this_dist , subsize , & pc_tree -> horizontal [ 0 ] ) ;\n pc_tree -> horizontal [ 0 ] . mic . mbmi = xd -> mi [ 0 ] . src_mi -> mbmi ;\n pc_tree -> horizontal [ 0 ] . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ;\n pc_tree -> horizontal [ 0 ] . skip = x -> skip ;\n sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ;\n if ( sum_rd < best_rd && mi_row + ms < cm -> mi_rows ) {\n load_pred_mv ( x , ctx ) ;\n nonrd_pick_sb_modes ( cpi , tile , mi_row + ms , mi_col , & this_rate , & this_dist , subsize , & pc_tree -> horizontal [ 1 ] ) ;\n pc_tree -> horizontal [ 1 ] . mic . mbmi = xd -> mi [ 0 ] . src_mi -> mbmi ;\n pc_tree -> horizontal [ 1 ] . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ;\n pc_tree -> horizontal [ 1 ] . skip = x -> skip ;\n if ( this_rate == INT_MAX ) {\n sum_rd = INT64_MAX ;\n }\n else {\n int pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ;\n this_rate += cpi -> partition_cost [ pl ] [ PARTITION_HORZ ] ;\n sum_rate += this_rate ;\n sum_dist += this_dist ;\n sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ;\n }\n }\n if ( sum_rd < best_rd ) {\n best_rd = sum_rd ;\n best_rate = sum_rate ;\n best_dist = sum_dist ;\n pc_tree -> partitioning = PARTITION_HORZ ;\n }\n }\n if ( partition_vert_allowed && do_rect ) {\n subsize = get_subsize ( bsize , PARTITION_VERT ) ;\n if ( sf -> adaptive_motion_search ) load_pred_mv ( x , ctx ) ;\n nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col , & this_rate , & this_dist , subsize , & pc_tree -> vertical [ 0 ] ) ;\n pc_tree -> vertical [ 0 ] . mic . mbmi = xd -> mi [ 0 ] . src_mi -> mbmi ;\n pc_tree -> vertical [ 0 ] . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ;\n pc_tree -> vertical [ 0 ] . skip = x -> skip ;\n sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ;\n if ( sum_rd < best_rd && mi_col + ms < cm -> mi_cols ) {\n load_pred_mv ( x , ctx ) ;\n nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col + ms , & this_rate , & this_dist , subsize , & pc_tree -> vertical [ 1 ] ) ;\n pc_tree -> vertical [ 1 ] . mic . mbmi = xd -> mi [ 0 ] . src_mi -> mbmi ;\n pc_tree -> vertical [ 1 ] . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ;\n pc_tree -> vertical [ 1 ] . skip = x -> skip ;\n if ( this_rate == INT_MAX ) {\n sum_rd = INT64_MAX ;\n }\n else {\n int pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ;\n this_rate += cpi -> partition_cost [ pl ] [ PARTITION_VERT ] ;\n sum_rate += this_rate ;\n sum_dist += this_dist ;\n sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ;\n }\n }\n if ( sum_rd < best_rd ) {\n best_rate = sum_rate ;\n best_dist = sum_dist ;\n best_rd = sum_rd ;\n pc_tree -> partitioning = PARTITION_VERT ;\n }\n }\n ( void ) best_rd ;\n * rate = best_rate ;\n * dist = best_dist ;\n if ( best_rate == INT_MAX ) return ;\n subsize = get_subsize ( bsize , pc_tree -> partitioning ) ;\n fill_mode_info_sb ( cm , x , mi_row , mi_col , bsize , subsize , pc_tree ) ;\n if ( best_rate < INT_MAX && best_dist < INT64_MAX && do_recon ) {\n int output_enabled = ( bsize == BLOCK_64X64 ) ;\n if ( ( oxcf -> aq_mode == COMPLEXITY_AQ ) && cm -> seg . update_map ) {\n vp9_select_in_frame_q_segment ( cpi , mi_row , mi_col , output_enabled , best_rate ) ;\n }\n if ( oxcf -> aq_mode == CYCLIC_REFRESH_AQ ) vp9_cyclic_refresh_set_rate_and_dist_sb ( cpi -> cyclic_refresh , best_rate , best_dist ) ;\n encode_sb_rt ( cpi , tile , tp , mi_row , mi_col , output_enabled , bsize , pc_tree ) ;\n }\n if ( bsize == BLOCK_64X64 ) {\n assert ( tp_orig < * tp ) ;\n assert ( best_rate < INT_MAX ) ;\n assert ( best_dist < INT64_MAX ) ;\n }\n else {\n assert ( tp_orig == * tp ) ;\n }\n }", "idx": 20528}
{"hash": -7236893719053583356, "project": "debian", "size": 153, "label": 0, "functionSource": "void dissect_zcl_color_control_attr_data ( proto_tree * tree , tvbuff_t * tvb , guint * offset , guint16 attr_id , guint data_type ) {\n static const int * capabilities_fields [ ] = {\n & hf_zbee_zcl_color_control_attr_color_capabilities_hs , & hf_zbee_zcl_color_control_attr_color_capabilities_ehs , & hf_zbee_zcl_color_control_attr_color_capabilities_loop , & hf_zbee_zcl_color_control_attr_color_capabilities_xy , & hf_zbee_zcl_color_control_attr_color_capabilities_ct , NULL }\n ;\n switch ( attr_id ) {\n case ZBEE_ZCL_ATTR_ID_COLOR_CONTROL_CURRENT_HUE : proto_tree_add_item ( tree , hf_zbee_zcl_color_control_attr_current_hue , tvb , * offset , 1 , ENC_NA ) ;\n * offset += 1 ;\n break ;\n case ZBEE_ZCL_ATTR_ID_COLOR_CONTROL_CURRENT_SATURATION : proto_tree_add_item ( tree , hf_zbee_zcl_color_control_attr_current_saturation , tvb , * offset , 1 , ENC_NA ) ;\n * offset += 1 ;\n break ;\n case ZBEE_ZCL_ATTR_ID_COLOR_CONTROL_REMAINING_TIME : proto_tree_add_item ( tree , hf_zbee_zcl_color_control_attr_remaining_time , tvb , * offset , 2 , ENC_LITTLE_ENDIAN ) ;\n * offset += 2 ;\n break ;\n case ZBEE_ZCL_ATTR_ID_COLOR_CONTROL_CURRENT_X : proto_tree_add_item ( tree , hf_zbee_zcl_color_control_attr_color_x , tvb , * offset , 2 , ENC_LITTLE_ENDIAN ) ;\n * offset += 2 ;\n break ;\n case ZBEE_ZCL_ATTR_ID_COLOR_CONTROL_CURRENT_Y : proto_tree_add_item ( tree , hf_zbee_zcl_color_control_attr_color_y , tvb , * offset , 2 , ENC_LITTLE_ENDIAN ) ;\n * offset += 2 ;\n break ;\n case ZBEE_ZCL_ATTR_ID_COLOR_CONTROL_DRIFT_COMPENSATION : proto_tree_add_item ( tree , hf_zbee_zcl_color_control_attr_drift_compensation , tvb , * offset , 1 , ENC_NA ) ;\n * offset += 1 ;\n break ;\n case ZBEE_ZCL_ATTR_ID_COLOR_CONTROL_COLOR_TEMP : proto_tree_add_item ( tree , hf_zbee_zcl_color_control_attr_color_temperature , tvb , * offset , 2 , ENC_LITTLE_ENDIAN ) ;\n * offset += 2 ;\n break ;\n case ZBEE_ZCL_ATTR_ID_COLOR_CONTROL_COLOR_MODE : proto_tree_add_item ( tree , hf_zbee_zcl_color_control_attr_color_mode , tvb , * offset , 1 , ENC_NA ) ;\n * offset += 1 ;\n break ;\n case ZBEE_ZCL_ATTR_ID_COLOR_CONTROL_NO_OF_PRIMARIES : proto_tree_add_item ( tree , hf_zbee_zcl_color_control_attr_nr_of_primaries , tvb , * offset , 1 , ENC_NA ) ;\n * offset += 1 ;\n break ;\n case ZBEE_ZCL_ATTR_ID_COLOR_CONTROL_PRIMARY_1_X : proto_tree_add_item ( tree , hf_zbee_zcl_color_control_attr_primary_1_x , tvb , * offset , 2 , ENC_LITTLE_ENDIAN ) ;\n * offset += 2 ;\n break ;\n case ZBEE_ZCL_ATTR_ID_COLOR_CONTROL_PRIMARY_1_Y : proto_tree_add_item ( tree , hf_zbee_zcl_color_control_attr_primary_1_y , tvb , * offset , 2 , ENC_LITTLE_ENDIAN ) ;\n * offset += 2 ;\n break ;\n case ZBEE_ZCL_ATTR_ID_COLOR_CONTROL_PRIMARY_1_INTENSITY : proto_tree_add_item ( tree , hf_zbee_zcl_color_control_attr_primary_1_intensity , tvb , * offset , 1 , ENC_NA ) ;\n * offset += 1 ;\n break ;\n case ZBEE_ZCL_ATTR_ID_COLOR_CONTROL_PRIMARY_2_X : proto_tree_add_item ( tree , hf_zbee_zcl_color_control_attr_primary_2_x , tvb , * offset , 2 , ENC_LITTLE_ENDIAN ) ;\n * offset += 2 ;\n break ;\n case ZBEE_ZCL_ATTR_ID_COLOR_CONTROL_PRIMARY_2_Y : proto_tree_add_item ( tree , hf_zbee_zcl_color_control_attr_primary_2_y , tvb , * offset , 2 , ENC_LITTLE_ENDIAN ) ;\n * offset += 2 ;\n break ;\n case ZBEE_ZCL_ATTR_ID_COLOR_CONTROL_PRIMARY_2_INTENSITY : proto_tree_add_item ( tree , hf_zbee_zcl_color_control_attr_primary_2_intensity , tvb , * offset , 1 , ENC_NA ) ;\n * offset += 1 ;\n break ;\n case ZBEE_ZCL_ATTR_ID_COLOR_CONTROL_PRIMARY_3_X : proto_tree_add_item ( tree , hf_zbee_zcl_color_control_attr_primary_3_x , tvb , * offset , 2 , ENC_LITTLE_ENDIAN ) ;\n * offset += 2 ;\n break ;\n case ZBEE_ZCL_ATTR_ID_COLOR_CONTROL_PRIMARY_3_Y : proto_tree_add_item ( tree , hf_zbee_zcl_color_control_attr_primary_3_y , tvb , * offset , 2 , ENC_LITTLE_ENDIAN ) ;\n * offset += 2 ;\n break ;\n case ZBEE_ZCL_ATTR_ID_COLOR_CONTROL_PRIMARY_3_INTENSITY : proto_tree_add_item ( tree , hf_zbee_zcl_color_control_attr_primary_3_intensity , tvb , * offset , 1 , ENC_NA ) ;\n * offset += 1 ;\n break ;\n case ZBEE_ZCL_ATTR_ID_COLOR_CONTROL_PRIMARY_4_X : proto_tree_add_item ( tree , hf_zbee_zcl_color_control_attr_primary_4_x , tvb , * offset , 2 , ENC_LITTLE_ENDIAN ) ;\n * offset += 2 ;\n break ;\n case ZBEE_ZCL_ATTR_ID_COLOR_CONTROL_PRIMARY_4_Y : proto_tree_add_item ( tree , hf_zbee_zcl_color_control_attr_primary_4_y , tvb , * offset , 2 , ENC_LITTLE_ENDIAN ) ;\n * offset += 2 ;\n break ;\n case ZBEE_ZCL_ATTR_ID_COLOR_CONTROL_PRIMARY_4_INTENSITY : proto_tree_add_item ( tree , hf_zbee_zcl_color_control_attr_primary_4_intensity , tvb , * offset , 1 , ENC_NA ) ;\n * offset += 1 ;\n break ;\n case ZBEE_ZCL_ATTR_ID_COLOR_CONTROL_PRIMARY_5_X : proto_tree_add_item ( tree , hf_zbee_zcl_color_control_attr_primary_5_x , tvb , * offset , 2 , ENC_LITTLE_ENDIAN ) ;\n * offset += 2 ;\n break ;\n case ZBEE_ZCL_ATTR_ID_COLOR_CONTROL_PRIMARY_5_Y : proto_tree_add_item ( tree , hf_zbee_zcl_color_control_attr_primary_5_y , tvb , * offset , 2 , ENC_LITTLE_ENDIAN ) ;\n * offset += 2 ;\n break ;\n case ZBEE_ZCL_ATTR_ID_COLOR_CONTROL_PRIMARY_5_INTENSITY : proto_tree_add_item ( tree , hf_zbee_zcl_color_control_attr_primary_5_intensity , tvb , * offset , 1 , ENC_NA ) ;\n * offset += 1 ;\n break ;\n case ZBEE_ZCL_ATTR_ID_COLOR_CONTROL_PRIMARY_6_X : proto_tree_add_item ( tree , hf_zbee_zcl_color_control_attr_primary_6_x , tvb , * offset , 2 , ENC_LITTLE_ENDIAN ) ;\n * offset += 2 ;\n break ;\n case ZBEE_ZCL_ATTR_ID_COLOR_CONTROL_PRIMARY_6_Y : proto_tree_add_item ( tree , hf_zbee_zcl_color_control_attr_primary_6_y , tvb , * offset , 2 , ENC_LITTLE_ENDIAN ) ;\n * offset += 2 ;\n break ;\n case ZBEE_ZCL_ATTR_ID_COLOR_CONTROL_PRIMARY_6_INTENSITY : proto_tree_add_item ( tree , hf_zbee_zcl_color_control_attr_primary_6_intensity , tvb , * offset , 1 , ENC_NA ) ;\n * offset += 1 ;\n break ;\n case ZBEE_ZCL_ATTR_ID_COLOR_CONTROL_WHITE_POINT_X : proto_tree_add_item ( tree , hf_zbee_zcl_color_control_attr_white_point_x , tvb , * offset , 2 , ENC_LITTLE_ENDIAN ) ;\n * offset += 2 ;\n break ;\n case ZBEE_ZCL_ATTR_ID_COLOR_CONTROL_WHITE_POINT_Y : proto_tree_add_item ( tree , hf_zbee_zcl_color_control_attr_white_point_y , tvb , * offset , 2 , ENC_LITTLE_ENDIAN ) ;\n * offset += 2 ;\n break ;\n case ZBEE_ZCL_ATTR_ID_COLOR_CONTROL_COLOR_POINT_R_X : proto_tree_add_item ( tree , hf_zbee_zcl_color_control_attr_red_x , tvb , * offset , 2 , ENC_LITTLE_ENDIAN ) ;\n * offset += 2 ;\n break ;\n case ZBEE_ZCL_ATTR_ID_COLOR_CONTROL_COLOR_POINT_R_Y : proto_tree_add_item ( tree , hf_zbee_zcl_color_control_attr_red_y , tvb , * offset , 2 , ENC_LITTLE_ENDIAN ) ;\n * offset += 2 ;\n break ;\n case ZBEE_ZCL_ATTR_ID_COLOR_CONTROL_COLOR_POINT_R_INTENSITY : proto_tree_add_item ( tree , hf_zbee_zcl_color_control_attr_red_intensity , tvb , * offset , 1 , ENC_NA ) ;\n * offset += 1 ;\n break ;\n case ZBEE_ZCL_ATTR_ID_COLOR_CONTROL_COLOR_POINT_G_X : proto_tree_add_item ( tree , hf_zbee_zcl_color_control_attr_green_x , tvb , * offset , 2 , ENC_LITTLE_ENDIAN ) ;\n * offset += 2 ;\n break ;\n case ZBEE_ZCL_ATTR_ID_COLOR_CONTROL_COLOR_POINT_G_Y : proto_tree_add_item ( tree , hf_zbee_zcl_color_control_attr_green_y , tvb , * offset , 2 , ENC_LITTLE_ENDIAN ) ;\n * offset += 2 ;\n break ;\n case ZBEE_ZCL_ATTR_ID_COLOR_CONTROL_COLOR_POINT_G_INTENSITY : proto_tree_add_item ( tree , hf_zbee_zcl_color_control_attr_green_intensity , tvb , * offset , 1 , ENC_NA ) ;\n * offset += 1 ;\n break ;\n case ZBEE_ZCL_ATTR_ID_COLOR_CONTROL_COLOR_POINT_B_X : proto_tree_add_item ( tree , hf_zbee_zcl_color_control_attr_blue_x , tvb , * offset , 2 , ENC_LITTLE_ENDIAN ) ;\n * offset += 2 ;\n break ;\n case ZBEE_ZCL_ATTR_ID_COLOR_CONTROL_COLOR_POINT_B_Y : proto_tree_add_item ( tree , hf_zbee_zcl_color_control_attr_blue_y , tvb , * offset , 2 , ENC_LITTLE_ENDIAN ) ;\n * offset += 2 ;\n break ;\n case ZBEE_ZCL_ATTR_ID_COLOR_CONTROL_COLOR_POINT_B_INTENSITY : proto_tree_add_item ( tree , hf_zbee_zcl_color_control_attr_blue_intensity , tvb , * offset , 1 , ENC_NA ) ;\n * offset += 1 ;\n break ;\n case ZBEE_ZCL_ATTR_ID_COLOR_CONTROL_ENHANCED_CURRENT_HUE : proto_tree_add_item ( tree , hf_zbee_zcl_color_control_attr_enhanced_current_hue , tvb , * offset , 2 , ENC_LITTLE_ENDIAN ) ;\n * offset += 2 ;\n break ;\n case ZBEE_ZCL_ATTR_ID_COLOR_CONTROL_ENHANCED_COLOR_MODE : proto_tree_add_item ( tree , hf_zbee_zcl_color_control_attr_enhanced_color_mode , tvb , * offset , 1 , ENC_NA ) ;\n * offset += 1 ;\n break ;\n case ZBEE_ZCL_ATTR_ID_COLOR_CONTROL_COLOR_LOOP_ACTIVE : proto_tree_add_item ( tree , hf_zbee_zcl_color_control_attr_color_loop_active , tvb , * offset , 1 , ENC_NA ) ;\n * offset += 1 ;\n break ;\n case ZBEE_ZCL_ATTR_ID_COLOR_CONTROL_COLOR_LOOP_DIRECTION : proto_tree_add_item ( tree , hf_zbee_zcl_color_control_attr_color_loop_direction , tvb , * offset , 1 , ENC_NA ) ;\n * offset += 1 ;\n break ;\n case ZBEE_ZCL_ATTR_ID_COLOR_CONTROL_COLOR_LOOP_TIME : proto_tree_add_item ( tree , hf_zbee_zcl_color_control_attr_color_loop_time , tvb , * offset , 2 , ENC_LITTLE_ENDIAN ) ;\n * offset += 2 ;\n break ;\n case ZBEE_ZCL_ATTR_ID_COLOR_CONTROL_COLOR_LOOP_START_ENH_HUE : proto_tree_add_item ( tree , hf_zbee_zcl_color_control_attr_color_loop_start_enhanced_hue , tvb , * offset , 2 , ENC_LITTLE_ENDIAN ) ;\n * offset += 2 ;\n break ;\n case ZBEE_ZCL_ATTR_ID_COLOR_CONTROL_COLOR_LOOP_STORED_ENH_HUE : proto_tree_add_item ( tree , hf_zbee_zcl_color_control_attr_color_loop_stored_enhanced_hue , tvb , * offset , 2 , ENC_LITTLE_ENDIAN ) ;\n * offset += 2 ;\n break ;\n case ZBEE_ZCL_ATTR_ID_COLOR_CONTROL_COLOR_CAPABILITIES : proto_tree_add_bitmask ( tree , tvb , * offset , hf_zbee_zcl_color_control_attr_color_capabilities , ett_zbee_zcl_color_control_color_capabilities , capabilities_fields , ENC_LITTLE_ENDIAN ) ;\n * offset += 2 ;\n break ;\n case ZBEE_ZCL_ATTR_ID_COLOR_CONTROL_COLOR_TEMPERATURE_PHYS_MIN : proto_tree_add_item ( tree , hf_zbee_zcl_color_control_attr_color_temperature_phys_min , tvb , * offset , 2 , ENC_LITTLE_ENDIAN ) ;\n * offset += 2 ;\n break ;\n case ZBEE_ZCL_ATTR_ID_COLOR_CONTROL_COLOR_TEMPERATURE_PHYS_MAX : proto_tree_add_item ( tree , hf_zbee_zcl_color_control_attr_color_temperature_phys_max , tvb , * offset , 2 , ENC_LITTLE_ENDIAN ) ;\n * offset += 2 ;\n break ;\n case ZBEE_ZCL_ATTR_ID_COLOR_CONTROL_COMPENSATION_TEXT : default : dissect_zcl_attr_data ( tvb , tree , offset , data_type ) ;\n break ;\n }\n }", "idx": 20529}
{"hash": -1929262071302712016, "project": "debian", "size": 7, "label": 0, "functionSource": "static cmsBool ReadSeqID ( struct _cms_typehandler_struct * self , cmsIOHANDLER * io , void * Cargo , cmsUInt32Number n , cmsUInt32Number SizeOfTag ) {\n cmsSEQ * OutSeq = ( cmsSEQ * ) Cargo ;\n cmsPSEQDESC * seq = & OutSeq -> seq [ n ] ;\n if ( io -> Read ( io , seq -> ProfileID . ID8 , 16 , 1 ) != 1 ) return FALSE ;\n if ( ! ReadEmbeddedText ( self , io , & seq -> Description , SizeOfTag ) ) return FALSE ;\n return TRUE ;\n }", "idx": 20530}
{"hash": -398565394354770780, "project": "debian", "size": 3, "label": 0, "functionSource": "static inline int ohci_put_td ( OHCIState * ohci , dma_addr_t addr , struct ohci_td * td ) {\n return put_dwords ( ohci , addr , ( uint32_t * ) td , sizeof ( * td ) >> 2 ) ;\n }", "idx": 20531}
{"hash": -5280794106681745199, "project": "debian", "size": 18, "label": 0, "functionSource": "static gboolean gst_asf_demux_handle_src_event ( GstPad * pad , GstObject * parent , GstEvent * event ) {\n GstASFDemux * demux ;\n gboolean ret ;\n demux = GST_ASF_DEMUX ( parent ) ;\n switch ( GST_EVENT_TYPE ( event ) ) {\n case GST_EVENT_SEEK : GST_LOG_OBJECT ( pad , \"seek event\" ) ;\n ret = gst_asf_demux_handle_seek_event ( demux , event ) ;\n gst_event_unref ( event ) ;\n break ;\n case GST_EVENT_QOS : case GST_EVENT_NAVIGATION : gst_event_unref ( event ) ;\n ret = FALSE ;\n break ;\n default : GST_LOG_OBJECT ( pad , \"%s event\" , GST_EVENT_TYPE_NAME ( event ) ) ;\n ret = gst_pad_event_default ( pad , parent , event ) ;\n break ;\n }\n return ret ;\n }", "idx": 20532}
{"hash": 2578089348587614328, "project": "debian", "size": 4, "label": 0, "functionSource": "int X509_sign ( X509 * x , EVP_PKEY * pkey , const EVP_MD * md ) {\n x -> cert_info -> enc . modified = 1 ;\n return ( ASN1_item_sign ( ASN1_ITEM_rptr ( X509_CINF ) , x -> cert_info -> signature , x -> sig_alg , x -> signature , x -> cert_info , pkey , md ) ) ;\n }", "idx": 20533}
{"hash": -2127895299879503273, "project": "debian", "size": 3, "label": 0, "functionSource": "static int32_t ide_nop_int32 ( IDEDMA * dma , int x ) {\n return 0 ;\n }", "idx": 20534}
{"hash": -1968566663266802355, "project": "chrome", "size": 14, "label": 0, "functionSource": "TEST_F ( OmniboxViewViewsTest , OnBlur ) {\n int kOmniboxWidth = 60 ;\n gfx : : RenderText * render_text = omnibox_view ( ) -> GetRenderText ( ) ;\n render_text -> SetDisplayRect ( gfx : : Rect ( 0 , 0 , kOmniboxWidth , 10 ) ) ;\n render_text -> SetHorizontalAlignment ( gfx : : ALIGN_LEFT ) ;\n omnibox_view ( ) -> OnFocus ( ) ;\n const base : : string16 kContentsRtl = base : : WideToUTF16 ( L\"\\x05e8\\x05e2.\\x05e7\\x05d5\\x05dd/0123/abcd\" ) ;\n static_cast < OmniboxView * > ( omnibox_view ( ) ) -> SetWindowTextAndCaretPos ( kContentsRtl , 0 , false , false ) ;\n EXPECT_EQ ( gfx : : NO_ELIDE , render_text -> elide_behavior ( ) ) ;\n EXPECT_GT ( 0 , render_text -> GetUpdatedDisplayOffset ( ) . x ( ) ) ;\n omnibox_view ( ) -> OnBlur ( ) ;\n EXPECT_EQ ( gfx : : ELIDE_TAIL , render_text -> elide_behavior ( ) ) ;\n EXPECT_EQ ( 0 , render_text -> GetUpdatedDisplayOffset ( ) . x ( ) ) ;\n }", "idx": 20535}
{"hash": 3502077845611765963, "project": "debian", "size": 67, "label": 0, "functionSource": "static struct cvec * cclass ( struct vars * v , const chr * startp , const chr * endp , int cases ) {\n size_t len ;\n struct cvec * cv = NULL ;\n const char * const * namePtr ;\n int i , index ;\n static const char * const classNames [ ] = {\n \"alnum\" , \"alpha\" , \"ascii\" , \"blank\" , \"cntrl\" , \"digit\" , \"graph\" , \"lower\" , \"print\" , \"punct\" , \"space\" , \"upper\" , \"xdigit\" , NULL }\n ;\n enum classes {\n CC_ALNUM , CC_ALPHA , CC_ASCII , CC_BLANK , CC_CNTRL , CC_DIGIT , CC_GRAPH , CC_LOWER , CC_PRINT , CC_PUNCT , CC_SPACE , CC_UPPER , CC_XDIGIT }\n ;\n len = endp - startp ;\n index = - 1 ;\n for ( namePtr = classNames , i = 0 ;\n * namePtr != NULL ;\n namePtr ++ , i ++ ) {\n if ( strlen ( * namePtr ) == len && pg_char_and_wchar_strncmp ( * namePtr , startp , len ) == 0 ) {\n index = i ;\n break ;\n }\n }\n if ( index == - 1 ) {\n ERR ( REG_ECTYPE ) ;\n return NULL ;\n }\n if ( cases && ( ( enum classes ) index == CC_LOWER || ( enum classes ) index == CC_UPPER ) ) index = ( int ) CC_ALPHA ;\n switch ( ( enum classes ) index ) {\n case CC_PRINT : cv = pg_ctype_get_cache ( pg_wc_isprint ) ;\n break ;\n case CC_ALNUM : cv = pg_ctype_get_cache ( pg_wc_isalnum ) ;\n break ;\n case CC_ALPHA : cv = pg_ctype_get_cache ( pg_wc_isalpha ) ;\n break ;\n case CC_ASCII : cv = getcvec ( v , 0 , 1 ) ;\n if ( cv ) addrange ( cv , 0 , 0x7f ) ;\n break ;\n case CC_BLANK : cv = getcvec ( v , 2 , 0 ) ;\n addchr ( cv , '\\t' ) ;\n addchr ( cv , ' ' ) ;\n break ;\n case CC_CNTRL : cv = getcvec ( v , 0 , 2 ) ;\n addrange ( cv , 0x0 , 0x1f ) ;\n addrange ( cv , 0x7f , 0x9f ) ;\n break ;\n case CC_DIGIT : cv = pg_ctype_get_cache ( pg_wc_isdigit ) ;\n break ;\n case CC_PUNCT : cv = pg_ctype_get_cache ( pg_wc_ispunct ) ;\n break ;\n case CC_XDIGIT : cv = getcvec ( v , 0 , 3 ) ;\n if ( cv ) {\n addrange ( cv , '0' , '9' ) ;\n addrange ( cv , 'a' , 'f' ) ;\n addrange ( cv , 'A' , 'F' ) ;\n }\n break ;\n case CC_SPACE : cv = pg_ctype_get_cache ( pg_wc_isspace ) ;\n break ;\n case CC_LOWER : cv = pg_ctype_get_cache ( pg_wc_islower ) ;\n break ;\n case CC_UPPER : cv = pg_ctype_get_cache ( pg_wc_isupper ) ;\n break ;\n case CC_GRAPH : cv = pg_ctype_get_cache ( pg_wc_isgraph ) ;\n break ;\n }\n if ( cv == NULL ) ERR ( REG_ESPACE ) ;\n return cv ;\n }", "idx": 20536}
{"hash": -3135212895432241239, "project": "debian", "size": 16, "label": 0, "functionSource": "static guint32 dissect_netb_name_query ( tvbuff_t * tvb , packet_info * pinfo _U_ , int offset , proto_tree * tree ) {\n guint8 local_session_number = tvb_get_guint8 ( tvb , offset + NB_DATA2 ) ;\n if ( local_session_number == 0 ) {\n proto_tree_add_uint_format_value ( tree , hf_netb_local_session_no , tvb , offset + NB_DATA2 , 1 , local_session_number , \"0 (FIND.NAME request)\" ) ;\n }\n else {\n proto_tree_add_item ( tree , hf_netb_local_session_no , tvb , offset + NB_DATA2 , 1 , ENC_LITTLE_ENDIAN ) ;\n }\n nb_call_name_type ( tvb , offset , tree ) ;\n nb_resp_corrl ( tvb , offset , tree ) ;\n netbios_add_name ( \"Query Name\" , tvb , offset + NB_RECVER_NAME , tree ) ;\n if ( local_session_number != 0 ) {\n netbios_add_name ( \"Sender's Name\" , tvb , offset + NB_SENDER_NAME , tree ) ;\n }\n return 0 ;\n }", "idx": 20537}
{"hash": 5357882892791796049, "project": "debian", "size": 8, "label": 0, "functionSource": "static void e1000e_mac_setmacaddr ( E1000ECore * core , int index , uint32_t val ) {\n uint32_t macaddr [ 2 ] ;\n core -> mac [ index ] = val ;\n macaddr [ 0 ] = cpu_to_le32 ( core -> mac [ RA ] ) ;\n macaddr [ 1 ] = cpu_to_le32 ( core -> mac [ RA + 1 ] ) ;\n qemu_format_nic_info_str ( qemu_get_queue ( core -> owner_nic ) , ( uint8_t * ) macaddr ) ;\n trace_e1000e_mac_set_sw ( MAC_ARG ( macaddr ) ) ;\n }", "idx": 20538}
{"hash": 2777995095263460833, "project": "debian", "size": 14, "label": 0, "functionSource": "static void usb_ehci_pci_init ( Object * obj ) {\n DeviceClass * dc = OBJECT_GET_CLASS ( DeviceClass , obj , TYPE_DEVICE ) ;\n EHCIPCIState * i = PCI_EHCI ( obj ) ;\n EHCIState * s = & i -> ehci ;\n s -> caps [ 0x09 ] = 0x68 ;\n s -> capsbase = 0x00 ;\n s -> opregbase = 0x20 ;\n s -> portscbase = 0x44 ;\n s -> portnr = NB_PORTS ;\n if ( ! dc -> hotpluggable ) {\n s -> companion_enable = true ;\n }\n usb_ehci_init ( s , DEVICE ( obj ) ) ;\n }", "idx": 20539}
{"hash": -5725800580349519214, "project": "chrome", "size": 33, "label": 0, "functionSource": "int vp9_receive_compressed_data ( VP9Decoder * pbi , size_t size , const uint8_t * * psource ) {\n VP9_COMMON * const cm = & pbi -> common ;\n const uint8_t * source = * psource ;\n int retcode = 0 ;\n cm -> error . error_code = VPX_CODEC_OK ;\n if ( size == 0 ) {\n if ( cm -> frame_refs [ 0 ] . idx != INT_MAX ) cm -> frame_refs [ 0 ] . buf -> corrupted = 1 ;\n }\n if ( cm -> new_fb_idx >= 0 && cm -> frame_bufs [ cm -> new_fb_idx ] . ref_count == 0 ) cm -> release_fb_cb ( cm -> cb_priv , & cm -> frame_bufs [ cm -> new_fb_idx ] . raw_frame_buffer ) ;\n cm -> new_fb_idx = get_free_fb ( cm ) ;\n if ( setjmp ( cm -> error . jmp ) ) {\n pbi -> need_resync = 1 ;\n cm -> error . setjmp = 0 ;\n vp9_clear_system_state ( ) ;\n if ( cm -> frame_refs [ 0 ] . idx != INT_MAX && cm -> frame_refs [ 0 ] . buf != NULL ) cm -> frame_refs [ 0 ] . buf -> corrupted = 1 ;\n if ( cm -> new_fb_idx > 0 && cm -> frame_bufs [ cm -> new_fb_idx ] . ref_count > 0 ) cm -> frame_bufs [ cm -> new_fb_idx ] . ref_count -- ;\n return - 1 ;\n }\n cm -> error . setjmp = 1 ;\n vp9_decode_frame ( pbi , source , source + size , psource ) ;\n swap_frame_buffers ( pbi ) ;\n vp9_clear_system_state ( ) ;\n cm -> last_width = cm -> width ;\n cm -> last_height = cm -> height ;\n if ( ! cm -> show_existing_frame ) cm -> last_show_frame = cm -> show_frame ;\n if ( cm -> show_frame ) {\n if ( ! cm -> show_existing_frame ) vp9_swap_mi_and_prev_mi ( cm ) ;\n cm -> current_video_frame ++ ;\n }\n pbi -> ready_for_new_data = 0 ;\n cm -> error . setjmp = 0 ;\n return retcode ;\n }", "idx": 20540}
{"hash": -866921002076081979, "project": "debian", "size": 23, "label": 0, "functionSource": "static int parent_proxy_success ( TSCont contp , TSEvent event , void * edata ) {\n ParentTest * ptest = ( ParentTest * ) TSContDataGet ( contp ) ;\n TSHttpTxn txnp = ( TSHttpTxn ) edata ;\n int expected ;\n int received ;\n int status ;\n switch ( event ) {\n case TS_EVENT_HTTP_SEND_RESPONSE_HDR : expected = get_request_id ( txnp ) ;\n received = get_response_id ( txnp ) ;\n if ( expected != received ) {\n status = REGRESSION_TEST_FAILED ;\n SDK_RPRINT ( ptest -> regtest , \"TSHttpTxnParentProxySet\" , \"TestCase\" , TC_FAIL , \"Expected response ID %d, received %d\" , expected , received ) ;\n }\n else {\n status = REGRESSION_TEST_PASSED ;\n SDK_RPRINT ( ptest -> regtest , \"TSHttpTxnParentProxySet\" , \"TestCase\" , TC_PASS , \"Received expected response ID %d\" , expected ) ;\n }\n TSHttpTxnReenable ( txnp , TS_EVENT_HTTP_CONTINUE ) ;\n return status ;\n default : SDK_RPRINT ( ptest -> regtest , \"TSHttpTxnParentProxySet\" , ptest -> testcase , TC_FAIL , \"Unexpected event %d\" , event ) ;\n return REGRESSION_TEST_FAILED ;\n }\n }", "idx": 20541}
{"hash": -1929262071302712016, "project": "debian", "size": 6, "label": 0, "functionSource": "static void Type_ParametricCurve_Free ( struct _cms_typehandler_struct * self , void * Ptr ) {\n cmsToneCurve * gamma = ( cmsToneCurve * ) Ptr ;\n cmsFreeToneCurve ( gamma ) ;\n return ;\n cmsUNUSED_PARAMETER ( self ) ;\n }", "idx": 20542}
{"hash": 3599206110384554647, "project": "debian", "size": 57, "label": 0, "functionSource": "static ossl_inline void sk_ ## t1 ## _free ( STACK_OF ( t1 ) * sk ) {\n OPENSSL_sk_free ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline void sk_ ## t1 ## _zero ( STACK_OF ( t1 ) * sk ) {\n OPENSSL_sk_zero ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _delete ( STACK_OF ( t1 ) * sk , int i ) {\n return ( t2 * ) OPENSSL_sk_delete ( ( OPENSSL_STACK * ) sk , i ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _delete_ptr ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return ( t2 * ) OPENSSL_sk_delete_ptr ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _push ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_push ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _unshift ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_unshift ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _pop ( STACK_OF ( t1 ) * sk ) {\n return ( t2 * ) OPENSSL_sk_pop ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _shift ( STACK_OF ( t1 ) * sk ) {\n return ( t2 * ) OPENSSL_sk_shift ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline void sk_ ## t1 ## _pop_free ( STACK_OF ( t1 ) * sk , sk_ ## t1 ## _freefunc freefunc ) {\n OPENSSL_sk_pop_free ( ( OPENSSL_STACK * ) sk , ( OPENSSL_sk_freefunc ) freefunc ) ;\n }\n static ossl_inline int sk_ ## t1 ## _insert ( STACK_OF ( t1 ) * sk , t2 * ptr , int idx ) {\n return OPENSSL_sk_insert ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr , idx ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _set ( STACK_OF ( t1 ) * sk , int idx , t2 * ptr ) {\n return ( t2 * ) OPENSSL_sk_set ( ( OPENSSL_STACK * ) sk , idx , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _find ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_find ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _find_ex ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_find_ex ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline void sk_ ## t1 ## _sort ( STACK_OF ( t1 ) * sk ) {\n OPENSSL_sk_sort ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline int sk_ ## t1 ## _is_sorted ( const STACK_OF ( t1 ) * sk ) {\n return OPENSSL_sk_is_sorted ( ( const OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _dup ( const STACK_OF ( t1 ) * sk ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_dup ( ( const OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _deep_copy ( const STACK_OF ( t1 ) * sk , sk_ ## t1 ## _copyfunc copyfunc , sk_ ## t1 ## _freefunc freefunc ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_deep_copy ( ( const OPENSSL_STACK * ) sk , ( OPENSSL_sk_copyfunc ) copyfunc , ( OPENSSL_sk_freefunc ) freefunc ) ;\n }\n static ossl_inline sk_ ## t1 ## _compfunc sk_ ## t1 ## _set_cmp_func ( STACK_OF ( t1 ) * sk , sk_ ## t1 ## _compfunc compare ) {\n return ( sk_ ## t1 ## _compfunc ) OPENSSL_sk_set_cmp_func ( ( OPENSSL_STACK * ) sk , ( OPENSSL_sk_compfunc ) compare ) ;\n }\n # define DEFINE_SPECIAL_STACK_OF ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , t2 , t2 ) # define DEFINE_STACK_OF ( t ) SKM_DEFINE_STACK_OF ( t , t , t ) # define DEFINE_SPECIAL_STACK_OF_CONST ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , const t2 , t2 ) # define DEFINE_STACK_OF_CONST ( t ) SKM_DEFINE_STACK_OF ( t , const t , t ) typedef char * OPENSSL_STRING ;\n typedef const char * OPENSSL_CSTRING ;\n DEFINE_SPECIAL_STACK_OF ( OPENSSL_STRING , char ) DEFINE_SPECIAL_STACK_OF_CONST ( OPENSSL_CSTRING , char )", "idx": 20543}
{"hash": -6068976579504840746, "project": "debian", "size": 8, "label": 0, "functionSource": "static void send_restrict_list ( restrict_u * pres , int ipv6 , u_int * pidx ) {\n for ( ;\n pres != NULL ;\n pres = pres -> link ) {\n send_restrict_entry ( pres , ipv6 , * pidx ) ;\n ( * pidx ) ++ ;\n }\n }", "idx": 20544}
{"hash": 8445816931248660591, "project": "debian", "size": 18, "label": 0, "functionSource": "static void spl_ptr_llist_push ( spl_ptr_llist * llist , void * data TSRMLS_DC ) {\n spl_ptr_llist_element * elem = emalloc ( sizeof ( spl_ptr_llist_element ) ) ;\n elem -> data = data ;\n elem -> rc = 1 ;\n elem -> prev = llist -> tail ;\n elem -> next = NULL ;\n if ( llist -> tail ) {\n llist -> tail -> next = elem ;\n }\n else {\n llist -> head = elem ;\n }\n llist -> tail = elem ;\n llist -> count ++ ;\n if ( llist -> ctor ) {\n llist -> ctor ( elem TSRMLS_CC ) ;\n }\n }", "idx": 20545}
{"hash": 6323824267898511453, "project": "debian", "size": 95, "label": 0, "functionSource": "static void fast_rgb_to_gray ( fz_context * ctx , fz_pixmap * dst , fz_pixmap * src , fz_colorspace * prf , const fz_default_colorspaces * default_cs , const fz_color_params * color_params , int copy_spots ) {\n unsigned char * s = src -> samples ;\n unsigned char * d = dst -> samples ;\n size_t w = src -> w ;\n int h = src -> h ;\n int sn = src -> n ;\n int ss = src -> s ;\n int sa = src -> alpha ;\n int dn = dst -> n ;\n int ds = dst -> s ;\n int da = dst -> alpha ;\n ptrdiff_t d_line_inc = dst -> stride - w * dn ;\n ptrdiff_t s_line_inc = src -> stride - w * sn ;\n if ( ( copy_spots && ss != ds ) || ( ! da && sa ) ) {\n assert ( \"This should never happen\" == NULL ) ;\n fz_throw ( ctx , FZ_ERROR_GENERIC , \"Cannot convert between incompatible pixmaps\" ) ;\n }\n if ( ( int ) w < 0 || h < 0 ) return ;\n if ( d_line_inc == 0 && s_line_inc == 0 ) {\n w *= h ;\n h = 1 ;\n }\n if ( ss == 0 && ds == 0 ) {\n if ( da ) {\n if ( sa ) {\n while ( h -- ) {\n size_t ww = w ;\n while ( ww -- ) {\n d [ 0 ] = ( ( s [ 0 ] + 1 ) * 77 + ( s [ 1 ] + 1 ) * 150 + ( s [ 2 ] + 1 ) * 28 ) >> 8 ;\n d [ 1 ] = s [ 3 ] ;\n s += 4 ;\n d += 2 ;\n }\n d += d_line_inc ;\n s += s_line_inc ;\n }\n }\n else {\n while ( h -- ) {\n size_t ww = w ;\n while ( ww -- ) {\n d [ 0 ] = ( ( s [ 0 ] + 1 ) * 77 + ( s [ 1 ] + 1 ) * 150 + ( s [ 2 ] + 1 ) * 28 ) >> 8 ;\n d [ 1 ] = 255 ;\n s += 3 ;\n d += 2 ;\n }\n d += d_line_inc ;\n s += s_line_inc ;\n }\n }\n }\n else {\n while ( h -- ) {\n size_t ww = w ;\n while ( ww -- ) {\n d [ 0 ] = ( ( s [ 0 ] + 1 ) * 77 + ( s [ 1 ] + 1 ) * 150 + ( s [ 2 ] + 1 ) * 28 ) >> 8 ;\n s += 3 ;\n d ++ ;\n }\n d += d_line_inc ;\n s += s_line_inc ;\n }\n }\n }\n else if ( copy_spots ) {\n int i ;\n while ( h -- ) {\n size_t ww = w ;\n while ( ww -- ) {\n d [ 0 ] = ( ( s [ 0 ] + 1 ) * 77 + ( s [ 1 ] + 1 ) * 150 + ( s [ 2 ] + 1 ) * 28 ) >> 8 ;\n s += 3 ;\n d ++ ;\n for ( i = ss ;\n i > 0 ;\n i -- ) * d ++ = * s ++ ;\n if ( da ) * d ++ = sa ? * s ++ : 255 ;\n }\n d += d_line_inc ;\n s += s_line_inc ;\n }\n }\n else {\n while ( h -- ) {\n size_t ww = w ;\n while ( ww -- ) {\n d [ 0 ] = ( ( s [ 0 ] + 1 ) * 77 + ( s [ 1 ] + 1 ) * 150 + ( s [ 2 ] + 1 ) * 28 ) >> 8 ;\n s += sn ;\n d += dn ;\n if ( da ) d [ - 1 ] = sa ? s [ - 1 ] : 255 ;\n }\n d += d_line_inc ;\n s += s_line_inc ;\n }\n }\n }", "idx": 20546}
{"hash": -7422764464424760982, "project": "chrome", "size": 829, "label": 1, "functionSource": "TEST_F ( ExtensionServiceSyncTest , ProcessSyncDataNewExtension ) {\n InitializeEmptyExtensionService ( ) ;\n extension_sync_service ( ) -> MergeDataAndStartSyncing ( syncer : : EXTENSIONS , syncer : : SyncDataList ( ) , base : : MakeUnique < syncer : : FakeSyncChangeProcessor > ( ) , base : : MakeUnique < syncer : : SyncErrorFactoryMock > ( ) ) ;\n const base : : FilePath path = data_dir ( ) . AppendASCII ( \"good.crx\" ) ;\n const ExtensionPrefs * prefs = ExtensionPrefs : : Get ( profile ( ) ) ;\n struct TestCase {\n const char * name ;\n bool sync_enabled ;\n int sync_disable_reasons ;\n int expect_disable_reasons ;\n bool expect_permissions_granted ;\n }\n test_cases [ ] = {\n {\n \"Standard\" , true , 0 , 0 , true }\n , {\n \"Disabled\" , false , extensions : : disable_reason : : DISABLE_USER_ACTION , extensions : : disable_reason : : DISABLE_USER_ACTION , true }\n , {\n \"Legacy\" , false , - 1 , extensions : : disable_reason : : DISABLE_USER_ACTION , true }\n , {\n \"PermissionsIncrease\" , false , extensions : : disable_reason : : DISABLE_PERMISSIONS_INCREASE , extensions : : disable_reason : : DISABLE_PERMISSIONS_INCREASE , false }\n , }\n ;\n for ( const TestCase & test_case : test_cases ) {\n SCOPED_TRACE ( test_case . name ) ;\n sync_pb : : EntitySpecifics specifics ;\n sync_pb : : ExtensionSpecifics * ext_specifics = specifics . mutable_extension ( ) ;\n ext_specifics -> set_id ( good_crx ) ;\n ext_specifics -> set_version ( base : : Version ( \"1\" ) . GetString ( ) ) ;\n ext_specifics -> set_enabled ( test_case . sync_enabled ) ;\n if ( test_case . sync_disable_reasons != - 1 ) ext_specifics -> set_disable_reasons ( test_case . sync_disable_reasons ) ;\n SyncChangeList list = MakeSyncChangeList ( good_crx , specifics , SyncChange : : ACTION_UPDATE ) ;\n extension_sync_service ( ) -> ProcessSyncChanges ( FROM_HERE , list ) ;\n ASSERT_TRUE ( service ( ) -> pending_extension_manager ( ) -> IsIdPending ( good_crx ) ) ;\n UpdateExtension ( good_crx , path , test_case . sync_enabled ? ENABLED : DISABLED ) ;\n EXPECT_EQ ( test_case . expect_disable_reasons , prefs -> GetDisableReasons ( good_crx ) ) ;\n std : : unique_ptr < const PermissionSet > permissions = prefs -> GetGrantedPermissions ( good_crx ) ;\n EXPECT_EQ ( test_case . expect_permissions_granted , ! permissions -> IsEmpty ( ) ) ;\n ASSERT_FALSE ( service ( ) -> pending_extension_manager ( ) -> IsIdPending ( good_crx ) ) ;\n UninstallExtension ( good_crx , false , test_case . sync_enabled ? Extension : : ENABLED : Extension : : DISABLED ) ;\n }\n }\n TEST_F ( ExtensionServiceSyncTest , ProcessSyncDataTerminatedExtension ) {\n InitializeExtensionServiceWithUpdater ( ) ;\n extension_sync_service ( ) -> MergeDataAndStartSyncing ( syncer : : EXTENSIONS , syncer : : SyncDataList ( ) , base : : MakeUnique < syncer : : FakeSyncChangeProcessor > ( ) , base : : MakeUnique < syncer : : SyncErrorFactoryMock > ( ) ) ;\n InstallCRX ( data_dir ( ) . AppendASCII ( \"good.crx\" ) , INSTALL_NEW ) ;\n TerminateExtension ( good_crx ) ;\n EXPECT_TRUE ( service ( ) -> IsExtensionEnabled ( good_crx ) ) ;\n EXPECT_FALSE ( extensions : : util : : IsIncognitoEnabled ( good_crx , profile ( ) ) ) ;\n sync_pb : : EntitySpecifics specifics ;\n sync_pb : : ExtensionSpecifics * ext_specifics = specifics . mutable_extension ( ) ;\n ext_specifics -> set_id ( good_crx ) ;\n ext_specifics -> set_version ( service ( ) -> GetInstalledExtension ( good_crx ) -> version ( ) -> GetString ( ) ) ;\n ext_specifics -> set_enabled ( false ) ;\n ext_specifics -> set_incognito_enabled ( true ) ;\n SyncChangeList list = MakeSyncChangeList ( good_crx , specifics , SyncChange : : ACTION_UPDATE ) ;\n extension_sync_service ( ) -> ProcessSyncChanges ( FROM_HERE , list ) ;\n EXPECT_FALSE ( service ( ) -> IsExtensionEnabled ( good_crx ) ) ;\n EXPECT_TRUE ( extensions : : util : : IsIncognitoEnabled ( good_crx , profile ( ) ) ) ;\n EXPECT_FALSE ( service ( ) -> pending_extension_manager ( ) -> IsIdPending ( good_crx ) ) ;\n }\n TEST_F ( ExtensionServiceSyncTest , ProcessSyncDataVersionCheck ) {\n InitializeExtensionServiceWithUpdater ( ) ;\n extension_sync_service ( ) -> MergeDataAndStartSyncing ( syncer : : EXTENSIONS , syncer : : SyncDataList ( ) , base : : MakeUnique < syncer : : FakeSyncChangeProcessor > ( ) , base : : MakeUnique < syncer : : SyncErrorFactoryMock > ( ) ) ;\n InstallCRX ( data_dir ( ) . AppendASCII ( \"good.crx\" ) , INSTALL_NEW ) ;\n EXPECT_TRUE ( service ( ) -> IsExtensionEnabled ( good_crx ) ) ;\n EXPECT_FALSE ( extensions : : util : : IsIncognitoEnabled ( good_crx , profile ( ) ) ) ;\n sync_pb : : EntitySpecifics specifics ;\n sync_pb : : ExtensionSpecifics * ext_specifics = specifics . mutable_extension ( ) ;\n ext_specifics -> set_id ( good_crx ) ;\n ext_specifics -> set_enabled ( true ) ;\n const base : : Version installed_version = * service ( ) -> GetInstalledExtension ( good_crx ) -> version ( ) ;\n {\n ext_specifics -> set_version ( installed_version . GetString ( ) ) ;\n SyncChangeList list = MakeSyncChangeList ( good_crx , specifics , SyncChange : : ACTION_UPDATE ) ;\n extension_sync_service ( ) -> ProcessSyncChanges ( FROM_HERE , list ) ;\n EXPECT_FALSE ( service ( ) -> updater ( ) -> WillCheckSoon ( ) ) ;\n syncer : : SyncDataList data = extension_sync_service ( ) -> GetAllSyncData ( syncer : : EXTENSIONS ) ;\n ASSERT_EQ ( 1u , data . size ( ) ) ;\n std : : unique_ptr < ExtensionSyncData > extension_data = ExtensionSyncData : : CreateFromSyncData ( data [ 0 ] ) ;\n ASSERT_TRUE ( extension_data ) ;\n EXPECT_EQ ( installed_version , extension_data -> version ( ) ) ;\n }\n {\n ext_specifics -> set_version ( \"0.0.0.0\" ) ;\n SyncChangeList list = MakeSyncChangeList ( good_crx , specifics , SyncChange : : ACTION_UPDATE ) ;\n extension_sync_service ( ) -> ProcessSyncChanges ( FROM_HERE , list ) ;\n EXPECT_FALSE ( service ( ) -> updater ( ) -> WillCheckSoon ( ) ) ;\n syncer : : SyncDataList data = extension_sync_service ( ) -> GetAllSyncData ( syncer : : EXTENSIONS ) ;\n ASSERT_EQ ( 1u , data . size ( ) ) ;\n std : : unique_ptr < ExtensionSyncData > extension_data = ExtensionSyncData : : CreateFromSyncData ( data [ 0 ] ) ;\n ASSERT_TRUE ( extension_data ) ;\n EXPECT_EQ ( installed_version , extension_data -> version ( ) ) ;\n }\n {\n const base : : Version new_version ( \"9.9.9.9\" ) ;\n ext_specifics -> set_version ( new_version . GetString ( ) ) ;\n SyncChangeList list = MakeSyncChangeList ( good_crx , specifics , SyncChange : : ACTION_UPDATE ) ;\n extension_sync_service ( ) -> ProcessSyncChanges ( FROM_HERE , list ) ;\n EXPECT_TRUE ( service ( ) -> updater ( ) -> WillCheckSoon ( ) ) ;\n syncer : : SyncDataList data = extension_sync_service ( ) -> GetAllSyncData ( syncer : : EXTENSIONS ) ;\n ASSERT_EQ ( 1u , data . size ( ) ) ;\n std : : unique_ptr < ExtensionSyncData > extension_data = ExtensionSyncData : : CreateFromSyncData ( data [ 0 ] ) ;\n ASSERT_TRUE ( extension_data ) ;\n EXPECT_EQ ( new_version , extension_data -> version ( ) ) ;\n }\n EXPECT_FALSE ( service ( ) -> pending_extension_manager ( ) -> IsIdPending ( good_crx ) ) ;\n }\n TEST_F ( ExtensionServiceSyncTest , ProcessSyncDataNotInstalled ) {\n InitializeExtensionServiceWithUpdater ( ) ;\n extension_sync_service ( ) -> MergeDataAndStartSyncing ( syncer : : EXTENSIONS , syncer : : SyncDataList ( ) , base : : MakeUnique < syncer : : FakeSyncChangeProcessor > ( ) , base : : MakeUnique < syncer : : SyncErrorFactoryMock > ( ) ) ;\n sync_pb : : EntitySpecifics specifics ;\n sync_pb : : ExtensionSpecifics * ext_specifics = specifics . mutable_extension ( ) ;\n ext_specifics -> set_id ( good_crx ) ;\n ext_specifics -> set_enabled ( false ) ;\n ext_specifics -> set_incognito_enabled ( true ) ;\n ext_specifics -> set_update_url ( \"http://www.google.com/\" ) ;\n ext_specifics -> set_version ( \"1.2.3.4\" ) ;\n SyncChangeList list = MakeSyncChangeList ( good_crx , specifics , SyncChange : : ACTION_UPDATE ) ;\n EXPECT_TRUE ( service ( ) -> IsExtensionEnabled ( good_crx ) ) ;\n EXPECT_FALSE ( extensions : : util : : IsIncognitoEnabled ( good_crx , profile ( ) ) ) ;\n extension_sync_service ( ) -> ProcessSyncChanges ( FROM_HERE , list ) ;\n EXPECT_TRUE ( service ( ) -> updater ( ) -> WillCheckSoon ( ) ) ;\n EXPECT_FALSE ( service ( ) -> IsExtensionEnabled ( good_crx ) ) ;\n EXPECT_TRUE ( extensions : : util : : IsIncognitoEnabled ( good_crx , profile ( ) ) ) ;\n const extensions : : PendingExtensionInfo * info ;\n EXPECT_TRUE ( ( info = service ( ) -> pending_extension_manager ( ) -> GetById ( good_crx ) ) ) ;\n EXPECT_EQ ( ext_specifics -> update_url ( ) , info -> update_url ( ) . spec ( ) ) ;\n EXPECT_TRUE ( info -> is_from_sync ( ) ) ;\n EXPECT_EQ ( Manifest : : INTERNAL , info -> install_source ( ) ) ;\n }\n TEST_F ( ExtensionServiceSyncTest , ProcessSyncDataEnableDisable ) {\n InitializeEmptyExtensionService ( ) ;\n extension_sync_service ( ) -> MergeDataAndStartSyncing ( syncer : : EXTENSIONS , syncer : : SyncDataList ( ) , base : : MakeUnique < syncer : : FakeSyncChangeProcessor > ( ) , base : : MakeUnique < syncer : : SyncErrorFactoryMock > ( ) ) ;\n const ExtensionPrefs * prefs = ExtensionPrefs : : Get ( profile ( ) ) ;\n struct TestCase {\n const char * name ;\n int previous_disable_reasons ;\n bool sync_enable ;\n int sync_disable_reasons ;\n int expect_disable_reasons ;\n }\n test_cases [ ] = {\n {\n \"NopEnable\" , 0 , true , 0 , 0 }\n , {\n \"NopDisable\" , extensions : : disable_reason : : DISABLE_USER_ACTION , false , extensions : : disable_reason : : DISABLE_USER_ACTION , extensions : : disable_reason : : DISABLE_USER_ACTION }\n , {\n \"Enable\" , extensions : : disable_reason : : DISABLE_USER_ACTION , true , 0 , 0 }\n , {\n \"Disable\" , 0 , false , extensions : : disable_reason : : DISABLE_USER_ACTION , extensions : : disable_reason : : DISABLE_USER_ACTION }\n , {\n \"AddDisableReason\" , extensions : : disable_reason : : DISABLE_REMOTE_INSTALL , false , extensions : : disable_reason : : DISABLE_REMOTE_INSTALL | extensions : : disable_reason : : DISABLE_USER_ACTION , extensions : : disable_reason : : DISABLE_REMOTE_INSTALL | extensions : : disable_reason : : DISABLE_USER_ACTION }\n , {\n \"RemoveDisableReason\" , extensions : : disable_reason : : DISABLE_REMOTE_INSTALL | extensions : : disable_reason : : DISABLE_USER_ACTION , false , extensions : : disable_reason : : DISABLE_USER_ACTION , extensions : : disable_reason : : DISABLE_USER_ACTION }\n , {\n \"PreserveLocalDisableReason\" , extensions : : disable_reason : : DISABLE_RELOAD , true , 0 , extensions : : disable_reason : : DISABLE_RELOAD }\n , {\n \"PreserveOnlyLocalDisableReason\" , extensions : : disable_reason : : DISABLE_USER_ACTION | extensions : : disable_reason : : DISABLE_RELOAD , true , 0 , extensions : : disable_reason : : DISABLE_RELOAD }\n , {\n \"M44Enable\" , extensions : : disable_reason : : DISABLE_USER_ACTION , true , - 1 , 0 }\n , {\n \"M44ReEnable\" , extensions : : disable_reason : : DISABLE_USER_ACTION , true , extensions : : disable_reason : : DISABLE_USER_ACTION , 0 }\n , {\n \"M44Disable\" , 0 , false , - 1 , extensions : : disable_reason : : DISABLE_USER_ACTION }\n , {\n \"M44ReDisable\" , 0 , false , 0 , extensions : : disable_reason : : DISABLE_USER_ACTION }\n , {\n \"M44AlreadyDisabledByUser\" , extensions : : disable_reason : : DISABLE_USER_ACTION , false , - 1 , extensions : : disable_reason : : DISABLE_USER_ACTION }\n , {\n \"M44AlreadyDisabledWithOtherReason\" , extensions : : disable_reason : : DISABLE_REMOTE_INSTALL , false , - 1 , extensions : : disable_reason : : DISABLE_REMOTE_INSTALL | extensions : : disable_reason : : DISABLE_USER_ACTION }\n , }\n ;\n for ( const TestCase & test_case : test_cases ) {\n SCOPED_TRACE ( test_case . name ) ;\n std : : string id ;\n std : : string version ;\n {\n const Extension * extension = InstallCRX ( data_dir ( ) . AppendASCII ( \"good.crx\" ) , INSTALL_NEW ) ;\n ASSERT_TRUE ( extension ) ;\n id = extension -> id ( ) ;\n version = extension -> VersionString ( ) ;\n }\n ASSERT_TRUE ( registry ( ) -> enabled_extensions ( ) . Contains ( id ) ) ;\n if ( test_case . previous_disable_reasons ) {\n service ( ) -> DisableExtension ( id , test_case . previous_disable_reasons ) ;\n ASSERT_TRUE ( registry ( ) -> disabled_extensions ( ) . Contains ( id ) ) ;\n }\n sync_pb : : EntitySpecifics specifics ;\n sync_pb : : ExtensionSpecifics * ext_specifics = specifics . mutable_extension ( ) ;\n ext_specifics -> set_id ( id ) ;\n ext_specifics -> set_enabled ( test_case . sync_enable ) ;\n ext_specifics -> set_version ( version ) ;\n if ( test_case . sync_disable_reasons != - 1 ) ext_specifics -> set_disable_reasons ( test_case . sync_disable_reasons ) ;\n SyncChangeList list = MakeSyncChangeList ( good_crx , specifics , SyncChange : : ACTION_UPDATE ) ;\n extension_sync_service ( ) -> ProcessSyncChanges ( FROM_HERE , list ) ;\n const bool expect_enabled = ! test_case . expect_disable_reasons ;\n EXPECT_EQ ( expect_enabled , service ( ) -> IsExtensionEnabled ( id ) ) ;\n EXPECT_EQ ( test_case . expect_disable_reasons , prefs -> GetDisableReasons ( id ) ) ;\n UninstallExtension ( id , false , expect_enabled ? Extension : : ENABLED : Extension : : DISABLED ) ;\n }\n }\n TEST_F ( ExtensionServiceSyncTest , ProcessSyncDataDeferredEnable ) {\n base : : CommandLine : : ForCurrentProcess ( ) -> AppendSwitchASCII ( switches : : kAppsGalleryUpdateURL , \"http://localhost/autoupdate/updates.xml\" ) ;\n InitializeEmptyExtensionService ( ) ;\n extension_sync_service ( ) -> MergeDataAndStartSyncing ( syncer : : EXTENSIONS , syncer : : SyncDataList ( ) , base : : MakeUnique < syncer : : FakeSyncChangeProcessor > ( ) , base : : MakeUnique < syncer : : SyncErrorFactoryMock > ( ) ) ;\n base : : FilePath base_path = data_dir ( ) . AppendASCII ( \"permissions_increase\" ) ;\n base : : FilePath pem_path = base_path . AppendASCII ( \"permissions.pem\" ) ;\n base : : FilePath path = base_path . AppendASCII ( \"v1\" ) ;\n const Extension * extension = PackAndInstallCRX ( path , pem_path , INSTALL_NEW ) ;\n ASSERT_TRUE ( extension ) ;\n ASSERT_TRUE ( registry ( ) -> enabled_extensions ( ) . Contains ( extension -> id ( ) ) ) ;\n std : : string id = extension -> id ( ) ;\n path = base_path . AppendASCII ( \"v2\" ) ;\n PackCRXAndUpdateExtension ( id , path , pem_path , DISABLED ) ;\n sync_pb : : EntitySpecifics specifics ;\n sync_pb : : ExtensionSpecifics * ext_specifics = specifics . mutable_extension ( ) ;\n ext_specifics -> set_id ( id ) ;\n ext_specifics -> set_version ( \"3\" ) ;\n ext_specifics -> set_enabled ( true ) ;\n ext_specifics -> set_disable_reasons ( extensions : : disable_reason : : DISABLE_NONE ) ;\n SyncChangeList list = MakeSyncChangeList ( good_crx , specifics , SyncChange : : ACTION_UPDATE ) ;\n extension_sync_service ( ) -> ProcessSyncChanges ( FROM_HERE , list ) ;\n EXPECT_TRUE ( registry ( ) -> disabled_extensions ( ) . Contains ( id ) ) ;\n path = base_path . AppendASCII ( \"v3\" ) ;\n PackCRXAndUpdateExtension ( id , path , pem_path , ENABLED ) ;\n }\n class ExtensionServiceSyncCustomGalleryTest : public ExtensionServiceSyncTest {\n public : void SetUp ( ) override {\n ExtensionServiceSyncTest : : SetUp ( ) ;\n base : : CommandLine : : ForCurrentProcess ( ) -> AppendSwitchASCII ( switches : : kAppsGalleryUpdateURL , \"http://localhost/autoupdate/updates.xml\" ) ;\n }\n }\n ;\n TEST_F ( ExtensionServiceSyncCustomGalleryTest , ProcessSyncDataPermissionApproval ) {\n InitializeEmptyExtensionService ( ) ;\n extension_sync_service ( ) -> MergeDataAndStartSyncing ( syncer : : EXTENSIONS , syncer : : SyncDataList ( ) , base : : MakeUnique < syncer : : FakeSyncChangeProcessor > ( ) , base : : MakeUnique < syncer : : SyncErrorFactoryMock > ( ) ) ;\n const base : : FilePath base_path = data_dir ( ) . AppendASCII ( \"permissions_increase\" ) ;\n const base : : FilePath pem_path = base_path . AppendASCII ( \"permissions.pem\" ) ;\n const base : : FilePath path_v1 = base_path . AppendASCII ( \"v1\" ) ;\n const base : : FilePath path_v2 = base_path . AppendASCII ( \"v2\" ) ;\n base : : ScopedTempDir crx_dir ;\n ASSERT_TRUE ( crx_dir . CreateUniqueTempDir ( ) ) ;\n const base : : FilePath crx_path_v1 = crx_dir . GetPath ( ) . AppendASCII ( \"temp1.crx\" ) ;\n PackCRX ( path_v1 , pem_path , crx_path_v1 ) ;\n const base : : FilePath crx_path_v2 = crx_dir . GetPath ( ) . AppendASCII ( \"temp2.crx\" ) ;\n PackCRX ( path_v2 , pem_path , crx_path_v2 ) ;\n const std : : string v1 ( \"1\" ) ;\n const std : : string v2 ( \"2\" ) ;\n const ExtensionPrefs * prefs = ExtensionPrefs : : Get ( profile ( ) ) ;\n struct TestCase {\n const char * name ;\n const std : : string & sync_version ;\n int sync_disable_reasons ;\n int expect_disable_reasons ;\n bool expect_permissions_granted ;\n }\n test_cases [ ] = {\n {\n \"OldVersion\" , v1 , 0 , extensions : : disable_reason : : DISABLE_PERMISSIONS_INCREASE , false }\n , {\n \"Legacy\" , v2 , - 1 , extensions : : disable_reason : : DISABLE_PERMISSIONS_INCREASE , false }\n , {\n \"GrantPermissions\" , v2 , 0 , extensions : : disable_reason : : DISABLE_NONE , true }\n , }\n ;\n for ( const TestCase & test_case : test_cases ) {\n SCOPED_TRACE ( test_case . name ) ;\n std : : string id ;\n {\n const Extension * extension = InstallCRX ( crx_path_v1 , INSTALL_NEW ) ;\n ASSERT_TRUE ( extension ) ;\n ASSERT_EQ ( v1 , extension -> VersionString ( ) ) ;\n id = extension -> id ( ) ;\n }\n ASSERT_TRUE ( registry ( ) -> enabled_extensions ( ) . Contains ( id ) ) ;\n std : : unique_ptr < const PermissionSet > granted_permissions_v1 = prefs -> GetGrantedPermissions ( id ) ;\n UpdateExtension ( id , crx_path_v2 , DISABLED ) ;\n {\n const Extension * extension = registry ( ) -> disabled_extensions ( ) . GetByID ( id ) ;\n ASSERT_TRUE ( extension ) ;\n ASSERT_EQ ( v2 , extension -> VersionString ( ) ) ;\n }\n ASSERT_TRUE ( prefs -> HasDisableReason ( id , extensions : : disable_reason : : DISABLE_PERMISSIONS_INCREASE ) ) ;\n std : : unique_ptr < const PermissionSet > granted_permissions_v2 = prefs -> GetGrantedPermissions ( id ) ;\n ASSERT_EQ ( * granted_permissions_v1 , * granted_permissions_v2 ) ;\n sync_pb : : EntitySpecifics specifics ;\n sync_pb : : ExtensionSpecifics * ext_specifics = specifics . mutable_extension ( ) ;\n ext_specifics -> set_id ( id ) ;\n ext_specifics -> set_enabled ( true ) ;\n ext_specifics -> set_version ( test_case . sync_version ) ;\n if ( test_case . sync_disable_reasons != - 1 ) ext_specifics -> set_disable_reasons ( test_case . sync_disable_reasons ) ;\n SyncChangeList list = MakeSyncChangeList ( good_crx , specifics , SyncChange : : ACTION_UPDATE ) ;\n extension_sync_service ( ) -> ProcessSyncChanges ( FROM_HERE , list ) ;\n const bool expect_enabled = ! test_case . expect_disable_reasons ;\n EXPECT_EQ ( expect_enabled , service ( ) -> IsExtensionEnabled ( id ) ) ;\n EXPECT_EQ ( test_case . expect_disable_reasons , prefs -> GetDisableReasons ( id ) ) ;\n std : : unique_ptr < const PermissionSet > granted_permissions = prefs -> GetGrantedPermissions ( id ) ;\n if ( test_case . expect_permissions_granted ) {\n std : : unique_ptr < const PermissionSet > active_permissions = prefs -> GetActivePermissions ( id ) ;\n EXPECT_EQ ( * granted_permissions , * active_permissions ) ;\n }\n else {\n EXPECT_EQ ( * granted_permissions , * granted_permissions_v1 ) ;\n }\n UninstallExtension ( id , false , expect_enabled ? Extension : : ENABLED : Extension : : DISABLED ) ;\n }\n }\n TEST_F ( ExtensionServiceSyncTest , DontSyncThemes ) {\n InitializeEmptyExtensionService ( ) ;\n ProfileSyncServiceFactory : : GetForProfile ( profile ( ) ) -> SetFirstSetupComplete ( ) ;\n extension_sync_service ( ) ;\n service ( ) -> Init ( ) ;\n ASSERT_TRUE ( service ( ) -> is_ready ( ) ) ;\n syncer : : FakeSyncChangeProcessor * processor = new syncer : : FakeSyncChangeProcessor ;\n extension_sync_service ( ) -> MergeDataAndStartSyncing ( syncer : : EXTENSIONS , syncer : : SyncDataList ( ) , base : : WrapUnique ( processor ) , base : : WrapUnique ( new syncer : : SyncErrorFactoryMock ) ) ;\n processor -> changes ( ) . clear ( ) ;\n InstallCRX ( data_dir ( ) . AppendASCII ( \"good.crx\" ) , INSTALL_NEW ) ;\n EXPECT_EQ ( 1u , processor -> changes ( ) . size ( ) ) ;\n processor -> changes ( ) . clear ( ) ;\n InstallCRX ( data_dir ( ) . AppendASCII ( \"theme.crx\" ) , INSTALL_NEW ) ;\n content : : WindowedNotificationObserver theme_change_observer ( chrome : : NOTIFICATION_BROWSER_THEME_CHANGED , content : : Source < ThemeService > ( ThemeServiceFactory : : GetForProfile ( profile ( ) ) ) ) ;\n theme_change_observer . Wait ( ) ;\n EXPECT_TRUE ( processor -> changes ( ) . empty ( ) ) ;\n }\n # if BUILDFLAG ( ENABLE_SUPERVISED_USERS ) class ExtensionServiceTestSupervised : public ExtensionServiceSyncCustomGalleryTest , public SupervisedUserService : : Delegate {\n public : ExtensionServiceTestSupervised ( ) : field_trial_list_ ( base : : MakeUnique < base : : MockEntropyProvider > ( ) ) {\n }\n void TearDown ( ) override {\n supervised_user_service ( ) -> SetDelegate ( nullptr ) ;\n ExtensionServiceSyncCustomGalleryTest : : TearDown ( ) ;\n }\n protected : void InitSupervisedUserInitiatedExtensionInstallFeature ( bool enabled ) {\n if ( enabled ) {\n scoped_feature_list_ . InitAndEnableFeature ( supervised_users : : kSupervisedUserInitiatedExtensionInstall ) ;\n }\n }\n bool IsPendingCustodianApproval ( const std : : string & extension_id ) {\n auto function = make_scoped_refptr ( new WebstorePrivateIsPendingCustodianApprovalFunction ( ) ) ;\n std : : unique_ptr < base : : Value > result ( RunFunctionAndReturnSingleResult ( function . get ( ) , \"[\\\"\" + extension_id + \"\\\"]\" , browser_context ( ) ) ) ;\n bool copy_bool_result = false ;\n EXPECT_TRUE ( result -> GetAsBoolean ( & copy_bool_result ) ) ;\n return copy_bool_result ;\n }\n void InitServices ( bool profile_is_supervised ) {\n ExtensionServiceInitParams params = CreateDefaultInitParams ( ) ;\n params . profile_is_supervised = profile_is_supervised ;\n if ( profile_is_supervised ) {\n params . pref_file = base : : FilePath ( ) ;\n }\n InitializeExtensionService ( params ) ;\n StartSyncing ( syncer : : EXTENSIONS ) ;\n supervised_user_service ( ) -> SetDelegate ( this ) ;\n supervised_user_service ( ) -> Init ( ) ;\n }\n std : : string InstallPermissionsTestExtension ( bool by_custodian ) {\n return InstallTestExtension ( permissions_increase , dir_path ( \"1\" ) , pem_path ( ) , by_custodian ) ;\n }\n void UpdatePermissionsTestExtension ( const std : : string & id , const std : : string & version , UpdateState expected_state ) {\n UpdateTestExtension ( dir_path ( version ) , pem_path ( ) , id , version , expected_state ) ;\n }\n std : : string InstallNoPermissionsTestExtension ( bool by_custodian ) {\n base : : FilePath base_path = data_dir ( ) . AppendASCII ( \"autoupdate\" ) ;\n base : : FilePath pem_path = base_path . AppendASCII ( \"key.pem\" ) ;\n base : : FilePath dir_path = base_path . AppendASCII ( \"v1\" ) ;\n return InstallTestExtension ( autoupdate , dir_path , pem_path , by_custodian ) ;\n }\n void UpdateNoPermissionsTestExtension ( const std : : string & id , const std : : string & version , UpdateState expected_state ) {\n base : : FilePath base_path = data_dir ( ) . AppendASCII ( \"autoupdate\" ) ;\n base : : FilePath pem_path = base_path . AppendASCII ( \"key.pem\" ) ;\n base : : FilePath dir_path = base_path . AppendASCII ( \"v\" + version ) ;\n UpdateTestExtension ( dir_path , pem_path , id , version , expected_state ) ;\n }\n std : : string InstallTestExtension ( const std : : string & id , const base : : FilePath & dir_path , const base : : FilePath & pem_path , bool by_custodian ) {\n InstallState expected_state = INSTALL_WITHOUT_LOAD ;\n if ( by_custodian ) {\n extensions : : util : : SetWasInstalledByCustodian ( id , profile ( ) , true ) ;\n expected_state = INSTALL_NEW ;\n }\n const Extension * extension = PackAndInstallCRX ( dir_path , pem_path , expected_state ) ;\n EXPECT_TRUE ( extension ) ;\n EXPECT_EQ ( extension -> id ( ) , id ) ;\n if ( by_custodian ) {\n EXPECT_TRUE ( registry ( ) -> enabled_extensions ( ) . Contains ( id ) ) ;\n }\n else {\n CheckDisabledForCustodianApproval ( id ) ;\n }\n EXPECT_EQ ( * extension -> version ( ) , base : : Version ( \"1\" ) ) ;\n return id ;\n }\n void UpdateTestExtension ( const base : : FilePath & dir_path , const base : : FilePath & pem_path , const std : : string & id , const std : : string & version , const UpdateState & expected_state ) {\n PackCRXAndUpdateExtension ( id , dir_path , pem_path , expected_state ) ;\n const Extension * extension = registry ( ) -> GetInstalledExtension ( id ) ;\n ASSERT_TRUE ( extension ) ;\n EXPECT_EQ ( * extension -> version ( ) , base : : Version ( version ) ) ;\n }\n void SimulateCustodianApprovalChangeViaSync ( const std : : string & extension_id , const std : : string & version , SyncChange : : SyncChangeType type ) {\n std : : string key = SupervisedUserSettingsService : : MakeSplitSettingKey ( supervised_users : : kApprovedExtensions , extension_id ) ;\n syncer : : SyncData sync_data = SupervisedUserSettingsService : : CreateSyncDataForSetting ( key , base : : Value ( version ) ) ;\n SyncChangeList list ( 1 , SyncChange ( FROM_HERE , type , sync_data ) ) ;\n SupervisedUserSettingsService * supervised_user_settings_service = SupervisedUserSettingsServiceFactory : : GetForProfile ( profile ( ) ) ;\n supervised_user_settings_service -> ProcessSyncChanges ( FROM_HERE , list ) ;\n }\n void CheckDisabledForCustodianApproval ( const std : : string & extension_id ) {\n EXPECT_TRUE ( registry ( ) -> disabled_extensions ( ) . Contains ( extension_id ) ) ;\n ExtensionPrefs * extension_prefs = ExtensionPrefs : : Get ( profile ( ) ) ;\n EXPECT_TRUE ( extension_prefs -> HasDisableReason ( extension_id , extensions : : disable_reason : : DISABLE_CUSTODIAN_APPROVAL_REQUIRED ) ) ;\n }\n SupervisedUserService * supervised_user_service ( ) {\n return SupervisedUserServiceFactory : : GetForProfile ( profile ( ) ) ;\n }\n static std : : string RequestId ( const std : : string & extension_id , const std : : string & version ) {\n return SupervisedUserService : : GetExtensionRequestId ( extension_id , base : : Version ( version ) ) ;\n }\n private : bool SetActive ( bool active ) override {\n return true ;\n }\n base : : FilePath base_path ( ) const {\n return data_dir ( ) . AppendASCII ( \"permissions_increase\" ) ;\n }\n base : : FilePath dir_path ( const std : : string & version ) const {\n return base_path ( ) . AppendASCII ( \"v\" + version ) ;\n }\n base : : FilePath pem_path ( ) const {\n return base_path ( ) . AppendASCII ( \"permissions.pem\" ) ;\n }\n base : : FieldTrialList field_trial_list_ ;\n base : : test : : ScopedFeatureList scoped_feature_list_ ;\n }\n ;\n class MockPermissionRequestCreator : public PermissionRequestCreator {\n public : MockPermissionRequestCreator ( ) {\n }\n ~ MockPermissionRequestCreator ( ) override {\n }\n bool IsEnabled ( ) const override {\n return true ;\n }\n void CreateURLAccessRequest ( const GURL & url_requested , const SuccessCallback & callback ) override {\n FAIL ( ) ;\n }\n MOCK_METHOD2 ( CreateExtensionInstallRequest , void ( const std : : string & id , const SupervisedUserService : : SuccessCallback & callback ) ) ;\n MOCK_METHOD2 ( CreateExtensionUpdateRequest , void ( const std : : string & id , const SupervisedUserService : : SuccessCallback & callback ) ) ;\n private : DISALLOW_COPY_AND_ASSIGN ( MockPermissionRequestCreator ) ;\n }\n ;\n TEST_F ( ExtensionServiceTestSupervised , InstallOnlyAllowedByCustodian ) {\n InitServices ( true ) ;\n InitSupervisedUserInitiatedExtensionInstallFeature ( false ) ;\n extensions : : util : : SetWasInstalledByCustodian ( good2048 , profile ( ) , true ) ;\n base : : FilePath path1 = data_dir ( ) . AppendASCII ( \"good.crx\" ) ;\n base : : FilePath path2 = data_dir ( ) . AppendASCII ( \"good2048.crx\" ) ;\n const Extension * extensions [ ] = {\n InstallCRX ( path1 , INSTALL_FAILED ) , InstallCRX ( path2 , INSTALL_NEW ) }\n ;\n EXPECT_FALSE ( extensions [ 0 ] ) ;\n ASSERT_TRUE ( extensions [ 1 ] ) ;\n EXPECT_TRUE ( registry ( ) -> enabled_extensions ( ) . Contains ( extensions [ 1 ] -> id ( ) ) ) ;\n EXPECT_FALSE ( IsPendingCustodianApproval ( extensions [ 1 ] -> id ( ) ) ) ;\n }\n TEST_F ( ExtensionServiceTestSupervised , DelegatedAndPreinstalledExtensionIsSUFirst ) {\n InitServices ( false ) ;\n InitSupervisedUserInitiatedExtensionInstallFeature ( false ) ;\n base : : FilePath path = data_dir ( ) . AppendASCII ( \"good.crx\" ) ;\n const Extension * extension = InstallCRX ( path , INSTALL_NEW ) ;\n std : : string id = extension -> id ( ) ;\n const std : : string version ( \"1.0.0.0\" ) ;\n EXPECT_TRUE ( registry ( ) -> enabled_extensions ( ) . Contains ( id ) ) ;\n profile ( ) -> AsTestingProfile ( ) -> SetSupervisedUserId ( supervised_users : : kChildAccountSUID ) ;\n EXPECT_FALSE ( registry ( ) -> enabled_extensions ( ) . Contains ( id ) ) ;\n sync_pb : : EntitySpecifics specifics ;\n sync_pb : : ExtensionSpecifics * ext_specifics = specifics . mutable_extension ( ) ;\n ext_specifics -> set_id ( id ) ;\n ext_specifics -> set_enabled ( true ) ;\n ext_specifics -> set_disable_reasons ( extensions : : disable_reason : : DISABLE_NONE ) ;\n ext_specifics -> set_installed_by_custodian ( true ) ;\n ext_specifics -> set_version ( version ) ;\n SyncChangeList list = MakeSyncChangeList ( id , specifics , SyncChange : : ACTION_UPDATE ) ;\n extension_sync_service ( ) -> ProcessSyncChanges ( FROM_HERE , list ) ;\n EXPECT_TRUE ( registry ( ) -> enabled_extensions ( ) . Contains ( id ) ) ;\n EXPECT_TRUE ( extensions : : util : : WasInstalledByCustodian ( id , profile ( ) ) ) ;\n }\n TEST_F ( ExtensionServiceTestSupervised , DelegatedAndPreinstalledExtensionSyncFirst ) {\n InitServices ( false ) ;\n InitSupervisedUserInitiatedExtensionInstallFeature ( false ) ;\n base : : FilePath path = data_dir ( ) . AppendASCII ( \"good.crx\" ) ;\n const Extension * extension = InstallCRX ( path , INSTALL_NEW ) ;\n std : : string id = extension -> id ( ) ;\n const std : : string version ( \"1.0.0.0\" ) ;\n EXPECT_TRUE ( registry ( ) -> enabled_extensions ( ) . Contains ( id ) ) ;\n sync_pb : : EntitySpecifics specifics ;\n sync_pb : : ExtensionSpecifics * ext_specifics = specifics . mutable_extension ( ) ;\n ext_specifics -> set_id ( id ) ;\n ext_specifics -> set_enabled ( true ) ;\n ext_specifics -> set_disable_reasons ( extensions : : disable_reason : : DISABLE_NONE ) ;\n ext_specifics -> set_installed_by_custodian ( true ) ;\n ext_specifics -> set_version ( version ) ;\n SyncChangeList list = MakeSyncChangeList ( id , specifics , SyncChange : : ACTION_UPDATE ) ;\n extension_sync_service ( ) -> ProcessSyncChanges ( FROM_HERE , list ) ;\n EXPECT_TRUE ( registry ( ) -> enabled_extensions ( ) . Contains ( id ) ) ;\n EXPECT_TRUE ( extensions : : util : : WasInstalledByCustodian ( id , profile ( ) ) ) ;\n }\n TEST_F ( ExtensionServiceTestSupervised , InstallAllowedByCustodianAndSupervisedUser ) {\n InitServices ( true ) ;\n InitSupervisedUserInitiatedExtensionInstallFeature ( true ) ;\n extensions : : util : : SetWasInstalledByCustodian ( good2048 , profile ( ) , true ) ;\n base : : FilePath path1 = data_dir ( ) . AppendASCII ( \"good.crx\" ) ;\n base : : FilePath path2 = data_dir ( ) . AppendASCII ( \"good2048.crx\" ) ;\n const Extension * extensions [ ] = {\n InstallCRX ( path1 , INSTALL_WITHOUT_LOAD ) , InstallCRX ( path2 , INSTALL_NEW ) }\n ;\n ASSERT_TRUE ( extensions [ 0 ] ) ;\n ASSERT_TRUE ( extensions [ 1 ] ) ;\n EXPECT_TRUE ( registry ( ) -> disabled_extensions ( ) . Contains ( extensions [ 0 ] -> id ( ) ) ) ;\n EXPECT_TRUE ( IsPendingCustodianApproval ( extensions [ 0 ] -> id ( ) ) ) ;\n EXPECT_TRUE ( registry ( ) -> enabled_extensions ( ) . Contains ( extensions [ 1 ] -> id ( ) ) ) ;\n EXPECT_FALSE ( IsPendingCustodianApproval ( extensions [ 1 ] -> id ( ) ) ) ;\n }\n TEST_F ( ExtensionServiceTestSupervised , PreinstalledExtensionWithSUInitiatedInstalls ) {\n InitServices ( false ) ;\n InitSupervisedUserInitiatedExtensionInstallFeature ( true ) ;\n base : : FilePath path = data_dir ( ) . AppendASCII ( \"good.crx\" ) ;\n const Extension * extension = InstallCRX ( path , INSTALL_NEW ) ;\n std : : string id = extension -> id ( ) ;\n EXPECT_TRUE ( registry ( ) -> enabled_extensions ( ) . Contains ( id ) ) ;\n MockPermissionRequestCreator * creator = new MockPermissionRequestCreator ;\n supervised_user_service ( ) -> AddPermissionRequestCreator ( base : : WrapUnique ( creator ) ) ;\n const std : : string version ( \"1.0.0.0\" ) ;\n EXPECT_CALL ( * creator , CreateExtensionInstallRequest ( RequestId ( good_crx , version ) , testing : : _ ) ) ;\n profile ( ) -> AsTestingProfile ( ) -> SetSupervisedUserId ( supervised_users : : kChildAccountSUID ) ;\n Mock : : VerifyAndClearExpectations ( creator ) ;\n CheckDisabledForCustodianApproval ( id ) ;\n EXPECT_TRUE ( IsPendingCustodianApproval ( id ) ) ;\n }\n TEST_F ( ExtensionServiceTestSupervised , PreinstalledExtensionWithoutSUInitiatedInstalls ) {\n InitServices ( false ) ;\n InitSupervisedUserInitiatedExtensionInstallFeature ( false ) ;\n base : : FilePath path = data_dir ( ) . AppendASCII ( \"good.crx\" ) ;\n const Extension * extension = InstallCRX ( path , INSTALL_NEW ) ;\n std : : string id = extension -> id ( ) ;\n EXPECT_TRUE ( registry ( ) -> enabled_extensions ( ) . Contains ( id ) ) ;\n MockPermissionRequestCreator * creator = new MockPermissionRequestCreator ;\n supervised_user_service ( ) -> AddPermissionRequestCreator ( base : : WrapUnique ( creator ) ) ;\n const std : : string version ( \"1.0.0.0\" ) ;\n EXPECT_CALL ( * creator , CreateExtensionInstallRequest ( testing : : _ , testing : : _ ) ) . Times ( 0 ) ;\n profile ( ) -> AsTestingProfile ( ) -> SetSupervisedUserId ( supervised_users : : kChildAccountSUID ) ;\n EXPECT_FALSE ( registry ( ) -> GetInstalledExtension ( id ) ) ;\n }\n TEST_F ( ExtensionServiceTestSupervised , ExtensionApprovalBeforeInstallation ) {\n InitServices ( true ) ;\n InitSupervisedUserInitiatedExtensionInstallFeature ( true ) ;\n MockPermissionRequestCreator * creator = new MockPermissionRequestCreator ;\n supervised_user_service ( ) -> AddPermissionRequestCreator ( base : : WrapUnique ( creator ) ) ;\n std : : string id = good_crx ;\n std : : string version ( \"1.0.0.0\" ) ;\n SimulateCustodianApprovalChangeViaSync ( id , version , SyncChange : : ACTION_ADD ) ;\n base : : FilePath path = data_dir ( ) . AppendASCII ( \"good.crx\" ) ;\n InstallCRX ( path , INSTALL_NEW ) ;\n EXPECT_CALL ( * creator , CreateExtensionInstallRequest ( testing : : _ , testing : : _ ) ) . Times ( 0 ) ;\n EXPECT_TRUE ( registry ( ) -> enabled_extensions ( ) . Contains ( id ) ) ;\n EXPECT_FALSE ( IsPendingCustodianApproval ( id ) ) ;\n }\n TEST_F ( ExtensionServiceTestSupervised , UpdateWithoutPermissionIncrease ) {\n InitServices ( true ) ;\n std : : string id = InstallNoPermissionsTestExtension ( true ) ;\n std : : string version2 ( \"2\" ) ;\n UpdateNoPermissionsTestExtension ( id , version2 , ENABLED ) ;\n const Extension * extension = registry ( ) -> enabled_extensions ( ) . GetByID ( id ) ;\n ASSERT_TRUE ( extension ) ;\n EXPECT_EQ ( * extension -> version ( ) , base : : Version ( version2 ) ) ;\n EXPECT_FALSE ( IsPendingCustodianApproval ( id ) ) ;\n }\n TEST_F ( ExtensionServiceTestSupervised , UpdateWithPermissionIncreaseApprovalOldVersion ) {\n InitServices ( true ) ;\n MockPermissionRequestCreator * creator = new MockPermissionRequestCreator ;\n supervised_user_service ( ) -> AddPermissionRequestCreator ( base : : WrapUnique ( creator ) ) ;\n const std : : string version1 ( \"1\" ) ;\n const std : : string version2 ( \"2\" ) ;\n std : : string id = InstallPermissionsTestExtension ( true ) ;\n EXPECT_CALL ( * creator , CreateExtensionUpdateRequest ( RequestId ( id , version2 ) , testing : : _ ) ) ;\n UpdatePermissionsTestExtension ( id , version2 , DISABLED ) ;\n Mock : : VerifyAndClearExpectations ( creator ) ;\n EXPECT_TRUE ( IsPendingCustodianApproval ( id ) ) ;\n sync_pb : : EntitySpecifics specifics ;\n sync_pb : : ExtensionSpecifics * ext_specifics = specifics . mutable_extension ( ) ;\n ext_specifics -> set_id ( id ) ;\n ext_specifics -> set_enabled ( true ) ;\n ext_specifics -> set_disable_reasons ( extensions : : disable_reason : : DISABLE_NONE ) ;\n ext_specifics -> set_installed_by_custodian ( true ) ;\n ext_specifics -> set_version ( version1 ) ;\n EXPECT_CALL ( * creator , CreateExtensionUpdateRequest ( RequestId ( id , version2 ) , testing : : _ ) ) ;\n SyncChangeList list = MakeSyncChangeList ( id , specifics , SyncChange : : ACTION_UPDATE ) ;\n extension_sync_service ( ) -> ProcessSyncChanges ( FROM_HERE , list ) ;\n EXPECT_FALSE ( registry ( ) -> enabled_extensions ( ) . Contains ( id ) ) ;\n EXPECT_FALSE ( extension_sync_service ( ) -> HasPendingReenable ( id , base : : Version ( version1 ) ) ) ;\n EXPECT_FALSE ( extension_sync_service ( ) -> HasPendingReenable ( id , base : : Version ( version2 ) ) ) ;\n Mock : : VerifyAndClearExpectations ( creator ) ;\n EXPECT_TRUE ( IsPendingCustodianApproval ( id ) ) ;\n }\n TEST_F ( ExtensionServiceTestSupervised , UpdateWithPermissionIncreaseApprovalMatchingVersion ) {\n InitServices ( true ) ;\n MockPermissionRequestCreator * creator = new MockPermissionRequestCreator ;\n supervised_user_service ( ) -> AddPermissionRequestCreator ( base : : WrapUnique ( creator ) ) ;\n std : : string id = InstallPermissionsTestExtension ( true ) ;\n const std : : string version2 ( \"2\" ) ;\n EXPECT_CALL ( * creator , CreateExtensionUpdateRequest ( RequestId ( id , version2 ) , testing : : _ ) ) ;\n UpdatePermissionsTestExtension ( id , version2 , DISABLED ) ;\n Mock : : VerifyAndClearExpectations ( creator ) ;\n EXPECT_TRUE ( IsPendingCustodianApproval ( id ) ) ;\n sync_pb : : EntitySpecifics specifics ;\n sync_pb : : ExtensionSpecifics * ext_specifics = specifics . mutable_extension ( ) ;\n ext_specifics -> set_id ( id ) ;\n ext_specifics -> set_enabled ( true ) ;\n ext_specifics -> set_disable_reasons ( extensions : : disable_reason : : DISABLE_NONE ) ;\n ext_specifics -> set_installed_by_custodian ( true ) ;\n ext_specifics -> set_version ( version2 ) ;\n SyncChangeList list = MakeSyncChangeList ( id , specifics , SyncChange : : ACTION_UPDATE ) ;\n extension_sync_service ( ) -> ProcessSyncChanges ( FROM_HERE , list ) ;\n EXPECT_TRUE ( registry ( ) -> enabled_extensions ( ) . Contains ( id ) ) ;\n EXPECT_FALSE ( IsPendingCustodianApproval ( id ) ) ;\n }\n TEST_F ( ExtensionServiceTestSupervised , UpdateWithPermissionIncreaseApprovalNewVersion ) {\n InitServices ( true ) ;\n MockPermissionRequestCreator * creator = new MockPermissionRequestCreator ;\n supervised_user_service ( ) -> AddPermissionRequestCreator ( base : : WrapUnique ( creator ) ) ;\n std : : string id = InstallPermissionsTestExtension ( true ) ;\n const std : : string version2 ( \"2\" ) ;\n EXPECT_CALL ( * creator , CreateExtensionUpdateRequest ( RequestId ( id , version2 ) , testing : : _ ) ) ;\n UpdatePermissionsTestExtension ( id , version2 , DISABLED ) ;\n Mock : : VerifyAndClearExpectations ( creator ) ;\n const std : : string version3 ( \"3\" ) ;\n sync_pb : : EntitySpecifics specifics ;\n sync_pb : : ExtensionSpecifics * ext_specifics = specifics . mutable_extension ( ) ;\n ext_specifics -> set_id ( id ) ;\n ext_specifics -> set_enabled ( true ) ;\n ext_specifics -> set_disable_reasons ( extensions : : disable_reason : : DISABLE_NONE ) ;\n ext_specifics -> set_installed_by_custodian ( true ) ;\n ext_specifics -> set_version ( version3 ) ;\n EXPECT_CALL ( * creator , CreateExtensionUpdateRequest ( RequestId ( id , version3 ) , testing : : _ ) ) . Times ( 0 ) ;\n SyncChangeList list = MakeSyncChangeList ( id , specifics , SyncChange : : ACTION_UPDATE ) ;\n extension_sync_service ( ) -> ProcessSyncChanges ( FROM_HERE , list ) ;\n EXPECT_FALSE ( registry ( ) -> enabled_extensions ( ) . Contains ( id ) ) ;\n EXPECT_TRUE ( extension_sync_service ( ) -> HasPendingReenable ( id , base : : Version ( version3 ) ) ) ;\n UpdatePermissionsTestExtension ( id , version3 , ENABLED ) ;\n }\n TEST_F ( ExtensionServiceTestSupervised , SupervisedUserInitiatedInstalls ) {\n InitSupervisedUserInitiatedExtensionInstallFeature ( true ) ;\n InitServices ( true ) ;\n MockPermissionRequestCreator * creator = new MockPermissionRequestCreator ;\n supervised_user_service ( ) -> AddPermissionRequestCreator ( base : : WrapUnique ( creator ) ) ;\n base : : FilePath path = data_dir ( ) . AppendASCII ( \"good.crx\" ) ;\n std : : string version ( \"1.0.0.0\" ) ;\n EXPECT_CALL ( * creator , CreateExtensionInstallRequest ( RequestId ( good_crx , version ) , testing : : _ ) ) ;\n const Extension * extension = InstallCRX ( path , INSTALL_WITHOUT_LOAD ) ;\n ASSERT_TRUE ( extension ) ;\n ASSERT_EQ ( extension -> id ( ) , good_crx ) ;\n EXPECT_TRUE ( registry ( ) -> disabled_extensions ( ) . Contains ( good_crx ) ) ;\n Mock : : VerifyAndClearExpectations ( creator ) ;\n EXPECT_TRUE ( IsPendingCustodianApproval ( extension -> id ( ) ) ) ;\n SimulateCustodianApprovalChangeViaSync ( good_crx , version , SyncChange : : ACTION_ADD ) ;\n EXPECT_TRUE ( registry ( ) -> enabled_extensions ( ) . Contains ( good_crx ) ) ;\n EXPECT_FALSE ( IsPendingCustodianApproval ( extension -> id ( ) ) ) ;\n SimulateCustodianApprovalChangeViaSync ( good_crx , version , SyncChange : : ACTION_DELETE ) ;\n EXPECT_TRUE ( registry ( ) -> disabled_extensions ( ) . Contains ( good_crx ) ) ;\n EXPECT_TRUE ( IsPendingCustodianApproval ( extension -> id ( ) ) ) ;\n }\n TEST_F ( ExtensionServiceTestSupervised , UpdateSUInitiatedInstallWithoutPermissionIncrease ) {\n InitSupervisedUserInitiatedExtensionInstallFeature ( true ) ;\n InitServices ( true ) ;\n std : : string id = InstallNoPermissionsTestExtension ( false ) ;\n std : : string version1 ( \"1\" ) ;\n SimulateCustodianApprovalChangeViaSync ( id , version1 , SyncChange : : ACTION_ADD ) ;\n EXPECT_TRUE ( registry ( ) -> enabled_extensions ( ) . Contains ( id ) ) ;\n std : : string version2 ( \"2\" ) ;\n UpdateNoPermissionsTestExtension ( id , version2 , ENABLED ) ;\n const Extension * extension = registry ( ) -> enabled_extensions ( ) . GetByID ( id ) ;\n ASSERT_TRUE ( extension ) ;\n EXPECT_EQ ( 1 , extension -> version ( ) -> CompareTo ( base : : Version ( version1 ) ) ) ;\n std : : string approved_version ;\n PrefService * pref_service = profile ( ) -> GetPrefs ( ) ;\n const base : : DictionaryValue * approved_extensions = pref_service -> GetDictionary ( prefs : : kSupervisedUserApprovedExtensions ) ;\n approved_extensions -> GetStringWithoutPathExpansion ( id , & approved_version ) ;\n EXPECT_EQ ( base : : Version ( approved_version ) , * extension -> version ( ) ) ;\n EXPECT_FALSE ( IsPendingCustodianApproval ( id ) ) ;\n }\n TEST_F ( ExtensionServiceTestSupervised , UpdateSUInitiatedInstallWithPermissionIncrease ) {\n InitSupervisedUserInitiatedExtensionInstallFeature ( true ) ;\n InitServices ( true ) ;\n std : : string id = InstallPermissionsTestExtension ( false ) ;\n std : : string version1 ( \"1\" ) ;\n SimulateCustodianApprovalChangeViaSync ( id , version1 , SyncChange : : ACTION_ADD ) ;\n EXPECT_TRUE ( registry ( ) -> enabled_extensions ( ) . Contains ( id ) ) ;\n std : : string version3 ( \"3\" ) ;\n UpdatePermissionsTestExtension ( id , version3 , DISABLED ) ;\n EXPECT_FALSE ( registry ( ) -> enabled_extensions ( ) . Contains ( id ) ) ;\n EXPECT_TRUE ( ExtensionPrefs : : Get ( profile ( ) ) -> HasDisableReason ( id , extensions : : disable_reason : : DISABLE_PERMISSIONS_INCREASE ) ) ;\n std : : string version2 ( \"2\" ) ;\n SimulateCustodianApprovalChangeViaSync ( id , version2 , SyncChange : : ACTION_UPDATE ) ;\n EXPECT_FALSE ( registry ( ) -> enabled_extensions ( ) . Contains ( id ) ) ;\n EXPECT_TRUE ( ExtensionPrefs : : Get ( profile ( ) ) -> HasDisableReason ( id , extensions : : disable_reason : : DISABLE_PERMISSIONS_INCREASE ) ) ;\n EXPECT_TRUE ( ExtensionPrefs : : Get ( profile ( ) ) -> HasDisableReason ( id , extensions : : disable_reason : : DISABLE_CUSTODIAN_APPROVAL_REQUIRED ) ) ;\n EXPECT_TRUE ( IsPendingCustodianApproval ( id ) ) ;\n SimulateCustodianApprovalChangeViaSync ( id , version3 , SyncChange : : ACTION_UPDATE ) ;\n EXPECT_TRUE ( registry ( ) -> enabled_extensions ( ) . Contains ( id ) ) ;\n EXPECT_FALSE ( IsPendingCustodianApproval ( id ) ) ;\n }\n TEST_F ( ExtensionServiceTestSupervised , UpdateSUInitiatedInstallWithPermissionIncreaseApprovalArrivesFirst ) {\n InitSupervisedUserInitiatedExtensionInstallFeature ( true ) ;\n InitServices ( true ) ;\n std : : string id = InstallPermissionsTestExtension ( false ) ;\n std : : string version1 ( \"1\" ) ;\n SimulateCustodianApprovalChangeViaSync ( id , version1 , SyncChange : : ACTION_ADD ) ;\n EXPECT_TRUE ( registry ( ) -> enabled_extensions ( ) . Contains ( id ) ) ;\n std : : string version2 ( \"2\" ) ;\n SimulateCustodianApprovalChangeViaSync ( id , version2 , SyncChange : : ACTION_UPDATE ) ;\n CheckDisabledForCustodianApproval ( id ) ;\n UpdatePermissionsTestExtension ( id , version2 , ENABLED ) ;\n EXPECT_TRUE ( registry ( ) -> enabled_extensions ( ) . Contains ( id ) ) ;\n EXPECT_FALSE ( IsPendingCustodianApproval ( id ) ) ;\n }\n TEST_F ( ExtensionServiceSyncTest , SyncUninstallByCustodianSkipsPolicy ) {\n InitializeEmptyExtensionService ( ) ;\n extension_sync_service ( ) -> MergeDataAndStartSyncing ( syncer : : EXTENSIONS , syncer : : SyncDataList ( ) , base : : MakeUnique < syncer : : FakeSyncChangeProcessor > ( ) , base : : MakeUnique < syncer : : SyncErrorFactoryMock > ( ) ) ;\n extensions : : util : : SetWasInstalledByCustodian ( good2048 , profile ( ) , true ) ;\n base : : FilePath path1 = data_dir ( ) . AppendASCII ( \"good.crx\" ) ;\n base : : FilePath path2 = data_dir ( ) . AppendASCII ( \"good2048.crx\" ) ;\n const Extension * extensions [ ] = {\n InstallCRX ( path1 , INSTALL_NEW ) , InstallCRX ( path2 , INSTALL_NEW ) }\n ;\n extensions : : TestManagementPolicyProvider provider ( extensions : : TestManagementPolicyProvider : : PROHIBIT_MODIFY_STATUS ) ;\n ExtensionSystem : : Get ( browser_context ( ) ) -> management_policy ( ) -> RegisterProvider ( & provider ) ;\n SyncChangeList list ;\n for ( size_t i = 0 ;\n i < arraysize ( extensions ) ;\n i ++ ) {\n const std : : string & id = extensions [ i ] -> id ( ) ;\n sync_pb : : EntitySpecifics specifics ;\n sync_pb : : ExtensionSpecifics * ext_specifics = specifics . mutable_extension ( ) ;\n ext_specifics -> set_id ( id ) ;\n ext_specifics -> set_version ( \"1.0\" ) ;\n ext_specifics -> set_installed_by_custodian ( extensions : : util : : WasInstalledByCustodian ( id , profile ( ) ) ) ;\n syncer : : SyncData sync_data = syncer : : SyncData : : CreateLocalData ( id , \"Name\" , specifics ) ;\n list . push_back ( SyncChange ( FROM_HERE , SyncChange : : ACTION_DELETE , sync_data ) ) ;\n }\n std : : string extension_ids [ ] = {\n extensions [ 0 ] -> id ( ) , extensions [ 1 ] -> id ( ) }\n ;\n extension_sync_service ( ) -> ProcessSyncChanges ( FROM_HERE , list ) ;\n EXPECT_TRUE ( registry ( ) -> enabled_extensions ( ) . Contains ( extension_ids [ 0 ] ) ) ;\n EXPECT_FALSE ( registry ( ) -> GenerateInstalledExtensionsSet ( ) -> Contains ( extension_ids [ 1 ] ) ) ;\n }\n TEST_F ( ExtensionServiceSyncTest , SyncExtensionHasAllhostsWithheld ) {\n InitializeEmptyExtensionService ( ) ;\n StartSyncing ( syncer : : EXTENSIONS ) ;\n const std : : string kName ( \"extension\" ) ;\n scoped_refptr < const Extension > extension = extensions : : ExtensionBuilder ( kName ) . SetLocation ( Manifest : : INTERNAL ) . AddPermission ( \"*://*/*\" ) . Build ( ) ;\n service ( ) -> AddExtension ( extension . get ( ) ) ;\n service ( ) -> GrantPermissionsAndEnableExtension ( extension . get ( ) ) ;\n const std : : string id = extension -> id ( ) ;\n EXPECT_TRUE ( registry ( ) -> enabled_extensions ( ) . GetByID ( id ) ) ;\n sync_pb : : EntitySpecifics specifics ;\n sync_pb : : ExtensionSpecifics * ext_specifics = specifics . mutable_extension ( ) ;\n ext_specifics -> set_id ( id ) ;\n ext_specifics -> set_name ( kName ) ;\n ext_specifics -> set_version ( \"1.0\" ) ;\n ext_specifics -> set_all_urls_enabled ( false ) ;\n ext_specifics -> set_enabled ( true ) ;\n SyncChangeList list = MakeSyncChangeList ( id , specifics , SyncChange : : ACTION_UPDATE ) ;\n extension_sync_service ( ) -> ProcessSyncChanges ( FROM_HERE , list ) ;\n const Extension * enabled_extension = registry ( ) -> enabled_extensions ( ) . GetByID ( id ) ;\n ASSERT_TRUE ( enabled_extension ) ;\n ScriptingPermissionsModifier modifier ( profile ( ) , enabled_extension ) ;\n EXPECT_FALSE ( modifier . IsAllowedOnAllUrls ( ) ) ;\n EXPECT_TRUE ( modifier . HasSetAllowedOnAllUrls ( ) ) ;\n }\n # endif TEST_F ( ExtensionServiceSyncTest , AppToExtension ) {\n InitializeEmptyExtensionService ( ) ;\n service ( ) -> Init ( ) ;\n ASSERT_TRUE ( service ( ) -> is_ready ( ) ) ;\n const Extension * v1 = InstallCRX ( data_dir ( ) . AppendASCII ( \"sync_datatypes\" ) . AppendASCII ( \"v1.crx\" ) , INSTALL_NEW ) ;\n EXPECT_TRUE ( v1 -> is_app ( ) ) ;\n EXPECT_FALSE ( v1 -> is_extension ( ) ) ;\n std : : string id = v1 -> id ( ) ;\n StatefulChangeProcessor extensions_processor ( syncer : : ModelType : : EXTENSIONS ) ;\n StatefulChangeProcessor apps_processor ( syncer : : ModelType : : APPS ) ;\n extension_sync_service ( ) -> MergeDataAndStartSyncing ( syncer : : EXTENSIONS , syncer : : SyncDataList ( ) , extensions_processor . GetWrapped ( ) , base : : WrapUnique ( new syncer : : SyncErrorFactoryMock ( ) ) ) ;\n extension_sync_service ( ) -> MergeDataAndStartSyncing ( syncer : : APPS , syncer : : SyncDataList ( ) , apps_processor . GetWrapped ( ) , base : : WrapUnique ( new syncer : : SyncErrorFactoryMock ( ) ) ) ;\n EXPECT_TRUE ( extensions_processor . changes ( ) . empty ( ) ) ;\n EXPECT_TRUE ( extensions_processor . data ( ) . empty ( ) ) ;\n EXPECT_EQ ( 1u , apps_processor . data ( ) . size ( ) ) ;\n ASSERT_EQ ( 1u , apps_processor . changes ( ) . size ( ) ) ;\n const SyncChange & app_change = apps_processor . changes ( ) [ 0 ] ;\n EXPECT_EQ ( SyncChange : : ACTION_ADD , app_change . change_type ( ) ) ;\n std : : unique_ptr < ExtensionSyncData > app_data = ExtensionSyncData : : CreateFromSyncData ( app_change . sync_data ( ) ) ;\n EXPECT_TRUE ( app_data -> is_app ( ) ) ;\n EXPECT_EQ ( id , app_data -> id ( ) ) ;\n EXPECT_EQ ( * v1 -> version ( ) , app_data -> version ( ) ) ;\n const Extension * v2 = InstallCRX ( data_dir ( ) . AppendASCII ( \"sync_datatypes\" ) . AppendASCII ( \"v2.crx\" ) , INSTALL_UPDATED ) ;\n EXPECT_FALSE ( v2 -> is_app ( ) ) ;\n EXPECT_TRUE ( v2 -> is_extension ( ) ) ;\n EXPECT_EQ ( id , v2 -> id ( ) ) ;\n ASSERT_EQ ( 1u , extensions_processor . changes ( ) . size ( ) ) ;\n const SyncChange & extension_change = extensions_processor . changes ( ) [ 0 ] ;\n EXPECT_EQ ( SyncChange : : ACTION_ADD , extension_change . change_type ( ) ) ;\n std : : unique_ptr < ExtensionSyncData > extension_data = ExtensionSyncData : : CreateFromSyncData ( extension_change . sync_data ( ) ) ;\n EXPECT_FALSE ( extension_data -> is_app ( ) ) ;\n EXPECT_EQ ( id , extension_data -> id ( ) ) ;\n EXPECT_EQ ( * v2 -> version ( ) , extension_data -> version ( ) ) ;\n syncer : : SyncDataList extensions_data = extensions_processor . GetAllSyncData ( syncer : : EXTENSIONS ) ;\n syncer : : SyncDataList apps_data = apps_processor . GetAllSyncData ( syncer : : APPS ) ;\n extension_sync_service ( ) -> StopSyncing ( syncer : : EXTENSIONS ) ;\n extension_sync_service ( ) -> StopSyncing ( syncer : : APPS ) ;\n extension_sync_service ( ) -> MergeDataAndStartSyncing ( syncer : : EXTENSIONS , extensions_data , extensions_processor . GetWrapped ( ) , base : : WrapUnique ( new syncer : : SyncErrorFactoryMock ( ) ) ) ;\n extension_sync_service ( ) -> MergeDataAndStartSyncing ( syncer : : APPS , apps_data , apps_processor . GetWrapped ( ) , base : : WrapUnique ( new syncer : : SyncErrorFactoryMock ( ) ) ) ;\n bool found_delete = false ;\n for ( const auto & change : apps_processor . changes ( ) ) {\n if ( change . change_type ( ) == SyncChange : : ACTION_DELETE ) {\n std : : unique_ptr < ExtensionSyncData > data = ExtensionSyncData : : CreateFromSyncChange ( change ) ;\n if ( data -> id ( ) == id ) {\n found_delete = true ;\n break ;\n }\n }\n }\n EXPECT_TRUE ( found_delete ) ;\n EXPECT_EQ ( 1u , extensions_processor . data ( ) . size ( ) ) ;\n EXPECT_TRUE ( apps_processor . data ( ) . empty ( ) ) ;\n }", "idx": 20547}
{"hash": -1929262071302712016, "project": "debian", "size": 6, "label": 0, "functionSource": "static void Type_Text_Description_Free ( struct _cms_typehandler_struct * self , void * Ptr ) {\n cmsMLU * mlu = ( cmsMLU * ) Ptr ;\n cmsMLUfree ( mlu ) ;\n return ;\n cmsUNUSED_PARAMETER ( self ) ;\n }", "idx": 20548}
{"hash": 1760449185745615462, "project": "debian", "size": 5, "label": 0, "functionSource": "TSReturnCode TSBase64Encode ( const char * str , size_t str_len , char * dst , size_t dst_size , size_t * length ) {\n sdk_assert ( sdk_sanity_check_null_ptr ( ( void * ) str ) == TS_SUCCESS ) ;\n sdk_assert ( sdk_sanity_check_null_ptr ( ( void * ) dst ) == TS_SUCCESS ) ;\n return ats_base64_encode ( str , str_len , dst , dst_size , length ) ? TS_SUCCESS : TS_ERROR ;\n }", "idx": 20549}
{"hash": -649112636673899765, "project": "debian", "size": 99, "label": 0, "functionSource": "static int rm_read_header ( AVFormatContext * s ) {\n RMDemuxContext * rm = s -> priv_data ;\n AVStream * st ;\n AVIOContext * pb = s -> pb ;\n unsigned int tag ;\n int tag_size ;\n unsigned int start_time , duration ;\n unsigned int data_off = 0 , indx_off = 0 ;\n char buf [ 128 ] , mime [ 128 ] ;\n int flags = 0 ;\n int ret = - 1 ;\n unsigned size , v ;\n int64_t codec_pos ;\n tag = avio_rl32 ( pb ) ;\n if ( tag == MKTAG ( '.' , 'r' , 'a' , 0xfd ) ) {\n return rm_read_header_old ( s ) ;\n }\n else if ( tag != MKTAG ( '.' , 'R' , 'M' , 'F' ) ) {\n return AVERROR ( EIO ) ;\n }\n tag_size = avio_rb32 ( pb ) ;\n avio_skip ( pb , tag_size - 8 ) ;\n for ( ;\n ;\n ) {\n if ( avio_feof ( pb ) ) goto fail ;\n tag = avio_rl32 ( pb ) ;\n tag_size = avio_rb32 ( pb ) ;\n avio_rb16 ( pb ) ;\n av_log ( s , AV_LOG_TRACE , \"tag=%s size=%d\\n\" , av_fourcc2str ( tag ) , tag_size ) ;\n if ( tag_size < 10 && tag != MKTAG ( 'D' , 'A' , 'T' , 'A' ) ) goto fail ;\n switch ( tag ) {\n case MKTAG ( 'P' , 'R' , 'O' , 'P' ) : avio_rb32 ( pb ) ;\n avio_rb32 ( pb ) ;\n avio_rb32 ( pb ) ;\n avio_rb32 ( pb ) ;\n avio_rb32 ( pb ) ;\n duration = avio_rb32 ( pb ) ;\n s -> duration = av_rescale ( duration , AV_TIME_BASE , 1000 ) ;\n avio_rb32 ( pb ) ;\n indx_off = avio_rb32 ( pb ) ;\n data_off = avio_rb32 ( pb ) ;\n avio_rb16 ( pb ) ;\n flags = avio_rb16 ( pb ) ;\n break ;\n case MKTAG ( 'C' , 'O' , 'N' , 'T' ) : rm_read_metadata ( s , pb , 1 ) ;\n break ;\n case MKTAG ( 'M' , 'D' , 'P' , 'R' ) : st = avformat_new_stream ( s , NULL ) ;\n if ( ! st ) {\n ret = AVERROR ( ENOMEM ) ;\n goto fail ;\n }\n st -> id = avio_rb16 ( pb ) ;\n avio_rb32 ( pb ) ;\n st -> codecpar -> bit_rate = avio_rb32 ( pb ) ;\n avio_rb32 ( pb ) ;\n avio_rb32 ( pb ) ;\n start_time = avio_rb32 ( pb ) ;\n avio_rb32 ( pb ) ;\n duration = avio_rb32 ( pb ) ;\n st -> start_time = start_time ;\n st -> duration = duration ;\n if ( duration > 0 ) s -> duration = AV_NOPTS_VALUE ;\n get_str8 ( pb , buf , sizeof ( buf ) ) ;\n get_str8 ( pb , mime , sizeof ( mime ) ) ;\n st -> codecpar -> codec_type = AVMEDIA_TYPE_DATA ;\n st -> priv_data = ff_rm_alloc_rmstream ( ) ;\n if ( ! st -> priv_data ) return AVERROR ( ENOMEM ) ;\n size = avio_rb32 ( pb ) ;\n codec_pos = avio_tell ( pb ) ;\n ffio_ensure_seekback ( pb , 4 ) ;\n v = avio_rb32 ( pb ) ;\n if ( v == MKBETAG ( 'M' , 'L' , 'T' , 'I' ) ) {\n ret = rm_read_multi ( s , s -> pb , st , mime ) ;\n if ( ret < 0 ) goto fail ;\n avio_seek ( pb , codec_pos + size , SEEK_SET ) ;\n }\n else {\n avio_skip ( pb , - 4 ) ;\n if ( ff_rm_read_mdpr_codecdata ( s , s -> pb , st , st -> priv_data , size , mime ) < 0 ) goto fail ;\n }\n break ;\n case MKTAG ( 'D' , 'A' , 'T' , 'A' ) : goto header_end ;\n default : avio_skip ( pb , tag_size - 10 ) ;\n break ;\n }\n }\n header_end : rm -> nb_packets = avio_rb32 ( pb ) ;\n if ( ! rm -> nb_packets && ( flags & 4 ) ) rm -> nb_packets = 3600 * 25 ;\n avio_rb32 ( pb ) ;\n if ( ! data_off ) data_off = avio_tell ( pb ) - 18 ;\n if ( indx_off && ( pb -> seekable & AVIO_SEEKABLE_NORMAL ) && ! ( s -> flags & AVFMT_FLAG_IGNIDX ) && avio_seek ( pb , indx_off , SEEK_SET ) >= 0 ) {\n rm_read_index ( s ) ;\n avio_seek ( pb , data_off + 18 , SEEK_SET ) ;\n }\n return 0 ;\n fail : rm_read_close ( s ) ;\n return ret ;\n }", "idx": 20550}
{"hash": 4952739496652083313, "project": "chrome", "size": 9, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( MediaStreamPermissionTest , TestDenyingThenClearingStickyException ) {\n content : : WebContents * tab_contents = LoadTestPageInTab ( ) ;\n GetUserMediaAndDeny ( tab_contents ) ;\n GetUserMediaAndExpectAutoDenyWithoutPrompt ( tab_contents ) ;\n HostContentSettingsMap * settings_map = HostContentSettingsMapFactory : : GetForProfile ( browser ( ) -> profile ( ) ) ;\n settings_map -> ClearSettingsForOneType ( CONTENT_SETTINGS_TYPE_MEDIASTREAM_MIC ) ;\n settings_map -> ClearSettingsForOneType ( CONTENT_SETTINGS_TYPE_MEDIASTREAM_CAMERA ) ;\n GetUserMediaAndDeny ( tab_contents ) ;\n }", "idx": 20551}
{"hash": -1055531103257174901, "project": "debian", "size": 6, "label": 0, "functionSource": "static void sig_complete_channel ( GList * * list , WINDOW_REC * window , const char * word , const char * line , int * want_space ) {\n g_return_if_fail ( list != NULL ) ;\n g_return_if_fail ( word != NULL ) ;\n * list = completion_get_channels ( NULL , word ) ;\n if ( * list != NULL ) signal_stop ( ) ;\n }", "idx": 20552}
{"hash": 3804373597256531021, "project": "debian", "size": 237, "label": 0, "functionSource": "bool mysql_show_grants ( THD * thd , LEX_USER * lex_user ) {\n ulong want_access ;\n uint counter , index ;\n int error = 0 ;\n ACL_USER * acl_user ;\n ACL_DB * acl_db ;\n char buff [ 1024 ] ;\n Protocol * protocol = thd -> protocol ;\n DBUG_ENTER ( \"mysql_show_grants\" ) ;\n LINT_INIT ( acl_user ) ;\n if ( ! initialized ) {\n my_error ( ER_OPTION_PREVENTS_STATEMENT , MYF ( 0 ) , \"--skip-grant-tables\" ) ;\n DBUG_RETURN ( TRUE ) ;\n }\n rw_rdlock ( & LOCK_grant ) ;\n VOID ( pthread_mutex_lock ( & acl_cache -> lock ) ) ;\n acl_user = find_acl_user ( lex_user -> host . str , lex_user -> user . str , TRUE ) ;\n if ( ! acl_user ) {\n VOID ( pthread_mutex_unlock ( & acl_cache -> lock ) ) ;\n rw_unlock ( & LOCK_grant ) ;\n my_error ( ER_NONEXISTING_GRANT , MYF ( 0 ) , lex_user -> user . str , lex_user -> host . str ) ;\n DBUG_RETURN ( TRUE ) ;\n }\n Item_string * field = new Item_string ( \"\" , 0 , & my_charset_latin1 ) ;\n List < Item > field_list ;\n field -> name = buff ;\n field -> max_length = 1024 ;\n strxmov ( buff , \"Grants for \" , lex_user -> user . str , \"@\" , lex_user -> host . str , NullS ) ;\n field_list . push_back ( field ) ;\n if ( protocol -> send_fields ( & field_list , Protocol : : SEND_NUM_ROWS | Protocol : : SEND_EOF ) ) {\n VOID ( pthread_mutex_unlock ( & acl_cache -> lock ) ) ;\n rw_unlock ( & LOCK_grant ) ;\n DBUG_RETURN ( TRUE ) ;\n }\n {\n String global ( buff , sizeof ( buff ) , system_charset_info ) ;\n global . length ( 0 ) ;\n global . append ( STRING_WITH_LEN ( \"GRANT \" ) ) ;\n want_access = acl_user -> access ;\n if ( test_all_bits ( want_access , ( GLOBAL_ACLS & ~ GRANT_ACL ) ) ) global . append ( STRING_WITH_LEN ( \"ALL PRIVILEGES\" ) ) ;\n else if ( ! ( want_access & ~ GRANT_ACL ) ) global . append ( STRING_WITH_LEN ( \"USAGE\" ) ) ;\n else {\n bool found = 0 ;\n ulong j , test_access = want_access & ~ GRANT_ACL ;\n for ( counter = 0 , j = SELECT_ACL ;\n j <= GLOBAL_ACLS ;\n counter ++ , j <<= 1 ) {\n if ( test_access & j ) {\n if ( found ) global . append ( STRING_WITH_LEN ( \", \" ) ) ;\n found = 1 ;\n global . append ( command_array [ counter ] , command_lengths [ counter ] ) ;\n }\n }\n }\n global . append ( STRING_WITH_LEN ( \" ON *.* TO '\" ) ) ;\n global . append ( lex_user -> user . str , lex_user -> user . length , system_charset_info ) ;\n global . append ( STRING_WITH_LEN ( \"'@'\" ) ) ;\n global . append ( lex_user -> host . str , lex_user -> host . length , system_charset_info ) ;\n global . append ( '\\'' ) ;\n if ( acl_user -> salt_len ) {\n global . append ( STRING_WITH_LEN ( \" IDENTIFIED BY PASSWORD\" ) ) ;\n if ( ( thd -> security_ctx -> master_access & SUPER_ACL ) == SUPER_ACL ) {\n char passwd_buff [ SCRAMBLED_PASSWORD_CHAR_LENGTH + 1 ] ;\n if ( acl_user -> salt_len == SCRAMBLE_LENGTH ) make_password_from_salt ( passwd_buff , acl_user -> salt ) ;\n else make_password_from_salt_323 ( passwd_buff , ( ulong * ) acl_user -> salt ) ;\n global . append ( \" \\'\" ) ;\n global . append ( passwd_buff ) ;\n global . append ( '\\'' ) ;\n }\n else global . append ( \" <secret>\" ) ;\n }\n if ( acl_user -> ssl_type == SSL_TYPE_ANY ) global . append ( STRING_WITH_LEN ( \" REQUIRE SSL\" ) ) ;\n else if ( acl_user -> ssl_type == SSL_TYPE_X509 ) global . append ( STRING_WITH_LEN ( \" REQUIRE X509\" ) ) ;\n else if ( acl_user -> ssl_type == SSL_TYPE_SPECIFIED ) {\n int ssl_options = 0 ;\n global . append ( STRING_WITH_LEN ( \" REQUIRE \" ) ) ;\n if ( acl_user -> x509_issuer ) {\n ssl_options ++ ;\n global . append ( STRING_WITH_LEN ( \"ISSUER \\'\" ) ) ;\n global . append ( acl_user -> x509_issuer , strlen ( acl_user -> x509_issuer ) ) ;\n global . append ( '\\'' ) ;\n }\n if ( acl_user -> x509_subject ) {\n if ( ssl_options ++ ) global . append ( ' ' ) ;\n global . append ( STRING_WITH_LEN ( \"SUBJECT \\'\" ) ) ;\n global . append ( acl_user -> x509_subject , strlen ( acl_user -> x509_subject ) , system_charset_info ) ;\n global . append ( '\\'' ) ;\n }\n if ( acl_user -> ssl_cipher ) {\n if ( ssl_options ++ ) global . append ( ' ' ) ;\n global . append ( STRING_WITH_LEN ( \"CIPHER '\" ) ) ;\n global . append ( acl_user -> ssl_cipher , strlen ( acl_user -> ssl_cipher ) , system_charset_info ) ;\n global . append ( '\\'' ) ;\n }\n }\n if ( ( want_access & GRANT_ACL ) || ( acl_user -> user_resource . questions || acl_user -> user_resource . updates || acl_user -> user_resource . conn_per_hour || acl_user -> user_resource . user_conn ) ) {\n global . append ( STRING_WITH_LEN ( \" WITH\" ) ) ;\n if ( want_access & GRANT_ACL ) global . append ( STRING_WITH_LEN ( \" GRANT OPTION\" ) ) ;\n add_user_option ( & global , acl_user -> user_resource . questions , \"MAX_QUERIES_PER_HOUR\" ) ;\n add_user_option ( & global , acl_user -> user_resource . updates , \"MAX_UPDATES_PER_HOUR\" ) ;\n add_user_option ( & global , acl_user -> user_resource . conn_per_hour , \"MAX_CONNECTIONS_PER_HOUR\" ) ;\n add_user_option ( & global , acl_user -> user_resource . user_conn , \"MAX_USER_CONNECTIONS\" ) ;\n }\n protocol -> prepare_for_resend ( ) ;\n protocol -> store ( global . ptr ( ) , global . length ( ) , global . charset ( ) ) ;\n if ( protocol -> write ( ) ) {\n error = - 1 ;\n goto end ;\n }\n }\n for ( counter = 0 ;\n counter < acl_dbs . elements ;\n counter ++ ) {\n const char * user , * host ;\n acl_db = dynamic_element ( & acl_dbs , counter , ACL_DB * ) ;\n if ( ! ( user = acl_db -> user ) ) user = \"\" ;\n if ( ! ( host = acl_db -> host . hostname ) ) host = \"\" ;\n if ( ! strcmp ( lex_user -> user . str , user ) && ! my_strcasecmp ( system_charset_info , lex_user -> host . str , host ) ) {\n want_access = acl_db -> access ;\n if ( want_access ) {\n String db ( buff , sizeof ( buff ) , system_charset_info ) ;\n db . length ( 0 ) ;\n db . append ( STRING_WITH_LEN ( \"GRANT \" ) ) ;\n if ( test_all_bits ( want_access , ( DB_ACLS & ~ GRANT_ACL ) ) ) db . append ( STRING_WITH_LEN ( \"ALL PRIVILEGES\" ) ) ;\n else if ( ! ( want_access & ~ GRANT_ACL ) ) db . append ( STRING_WITH_LEN ( \"USAGE\" ) ) ;\n else {\n int found = 0 , cnt ;\n ulong j , test_access = want_access & ~ GRANT_ACL ;\n for ( cnt = 0 , j = SELECT_ACL ;\n j <= DB_ACLS ;\n cnt ++ , j <<= 1 ) {\n if ( test_access & j ) {\n if ( found ) db . append ( STRING_WITH_LEN ( \", \" ) ) ;\n found = 1 ;\n db . append ( command_array [ cnt ] , command_lengths [ cnt ] ) ;\n }\n }\n }\n db . append ( STRING_WITH_LEN ( \" ON \" ) ) ;\n append_identifier ( thd , & db , acl_db -> db , strlen ( acl_db -> db ) ) ;\n db . append ( STRING_WITH_LEN ( \".* TO '\" ) ) ;\n db . append ( lex_user -> user . str , lex_user -> user . length , system_charset_info ) ;\n db . append ( STRING_WITH_LEN ( \"'@'\" ) ) ;\n db . append ( host , strlen ( host ) , system_charset_info ) ;\n db . append ( '\\'' ) ;\n if ( want_access & GRANT_ACL ) db . append ( STRING_WITH_LEN ( \" WITH GRANT OPTION\" ) ) ;\n protocol -> prepare_for_resend ( ) ;\n protocol -> store ( db . ptr ( ) , db . length ( ) , db . charset ( ) ) ;\n if ( protocol -> write ( ) ) {\n error = - 1 ;\n goto end ;\n }\n }\n }\n }\n for ( index = 0 ;\n index < column_priv_hash . records ;\n index ++ ) {\n const char * user , * host ;\n GRANT_TABLE * grant_table = ( GRANT_TABLE * ) hash_element ( & column_priv_hash , index ) ;\n if ( ! ( user = grant_table -> user ) ) user = \"\" ;\n if ( ! ( host = grant_table -> host . hostname ) ) host = \"\" ;\n if ( ! strcmp ( lex_user -> user . str , user ) && ! my_strcasecmp ( system_charset_info , lex_user -> host . str , host ) ) {\n ulong table_access = grant_table -> privs ;\n if ( ( table_access | grant_table -> cols ) != 0 ) {\n String global ( buff , sizeof ( buff ) , system_charset_info ) ;\n ulong test_access = ( table_access | grant_table -> cols ) & ~ GRANT_ACL ;\n global . length ( 0 ) ;\n global . append ( STRING_WITH_LEN ( \"GRANT \" ) ) ;\n if ( test_all_bits ( table_access , ( TABLE_ACLS & ~ GRANT_ACL ) ) ) global . append ( STRING_WITH_LEN ( \"ALL PRIVILEGES\" ) ) ;\n else if ( ! test_access ) global . append ( STRING_WITH_LEN ( \"USAGE\" ) ) ;\n else {\n int found = 0 ;\n ulong j ;\n for ( counter = 0 , j = SELECT_ACL ;\n j <= TABLE_ACLS ;\n counter ++ , j <<= 1 ) {\n if ( test_access & j ) {\n if ( found ) global . append ( STRING_WITH_LEN ( \", \" ) ) ;\n found = 1 ;\n global . append ( command_array [ counter ] , command_lengths [ counter ] ) ;\n if ( grant_table -> cols ) {\n uint found_col = 0 ;\n for ( uint col_index = 0 ;\n col_index < grant_table -> hash_columns . records ;\n col_index ++ ) {\n GRANT_COLUMN * grant_column = ( GRANT_COLUMN * ) hash_element ( & grant_table -> hash_columns , col_index ) ;\n if ( grant_column -> rights & j ) {\n if ( ! found_col ) {\n found_col = 1 ;\n if ( table_access & j ) {\n global . append ( STRING_WITH_LEN ( \", \" ) ) ;\n global . append ( command_array [ counter ] , command_lengths [ counter ] ) ;\n }\n global . append ( STRING_WITH_LEN ( \" (\" ) ) ;\n }\n else global . append ( STRING_WITH_LEN ( \", \" ) ) ;\n global . append ( grant_column -> column , grant_column -> key_length , system_charset_info ) ;\n }\n }\n if ( found_col ) global . append ( ')' ) ;\n }\n }\n }\n }\n global . append ( STRING_WITH_LEN ( \" ON \" ) ) ;\n append_identifier ( thd , & global , grant_table -> db , strlen ( grant_table -> db ) ) ;\n global . append ( '.' ) ;\n append_identifier ( thd , & global , grant_table -> tname , strlen ( grant_table -> tname ) ) ;\n global . append ( STRING_WITH_LEN ( \" TO '\" ) ) ;\n global . append ( lex_user -> user . str , lex_user -> user . length , system_charset_info ) ;\n global . append ( STRING_WITH_LEN ( \"'@'\" ) ) ;\n global . append ( host , strlen ( host ) , system_charset_info ) ;\n global . append ( '\\'' ) ;\n if ( table_access & GRANT_ACL ) global . append ( STRING_WITH_LEN ( \" WITH GRANT OPTION\" ) ) ;\n protocol -> prepare_for_resend ( ) ;\n protocol -> store ( global . ptr ( ) , global . length ( ) , global . charset ( ) ) ;\n if ( protocol -> write ( ) ) {\n error = - 1 ;\n break ;\n }\n }\n }\n }\n if ( show_routine_grants ( thd , lex_user , & proc_priv_hash , STRING_WITH_LEN ( \"PROCEDURE\" ) , buff , sizeof ( buff ) ) ) {\n error = - 1 ;\n goto end ;\n }\n if ( show_routine_grants ( thd , lex_user , & func_priv_hash , STRING_WITH_LEN ( \"FUNCTION\" ) , buff , sizeof ( buff ) ) ) {\n error = - 1 ;\n goto end ;\n }\n end : VOID ( pthread_mutex_unlock ( & acl_cache -> lock ) ) ;\n rw_unlock ( & LOCK_grant ) ;\n my_eof ( thd ) ;\n DBUG_RETURN ( error ) ;\n }", "idx": 20553}
{"hash": 355220887711506893, "project": "debian", "size": 10, "label": 1, "functionSource": "extern int name ( int ) __THROW __exctype ( isalnum ) ;\n __exctype ( isalpha ) ;\n __exctype ( iscntrl ) ;\n __exctype ( isdigit ) ;\n __exctype ( islower ) ;\n __exctype ( isgraph ) ;\n __exctype ( isprint ) ;\n __exctype ( ispunct ) ;\n __exctype ( isspace ) ;\n __exctype ( isupper )", "idx": 20554}
{"hash": 6600620671673714486, "project": "debian", "size": 39, "label": 0, "functionSource": "clump_t * clump_splay_app ( clump_t * root , gs_ref_memory_t * imem , splay_app_result_t ( * fn ) ( clump_t * , void * ) , void * arg ) {\n clump_t * step_to ;\n clump_t * cp = root ;\n int from = SPLAY_FROM_ABOVE ;\n splay_app_result_t res ;\n SANITY_CHECK ( cp ) ;\n while ( cp ) {\n if ( from == SPLAY_FROM_ABOVE ) {\n step_to = cp -> left ;\n if ( step_to ) {\n from = SPLAY_FROM_ABOVE ;\n cp = step_to ;\n }\n else {\n from = SPLAY_FROM_LEFT ;\n }\n }\n if ( from == SPLAY_FROM_LEFT ) {\n step_to = cp -> right ;\n if ( step_to ) {\n from = SPLAY_FROM_ABOVE ;\n cp = step_to ;\n }\n else {\n from = SPLAY_FROM_RIGHT ;\n }\n }\n if ( from == SPLAY_FROM_RIGHT ) {\n step_to = cp -> parent ;\n if ( step_to ) {\n from = ( step_to -> left == cp ? SPLAY_FROM_LEFT : SPLAY_FROM_RIGHT ) ;\n }\n res = fn ( cp , arg ) ;\n if ( res & SPLAY_APP_STOP ) return cp ;\n cp = step_to ;\n }\n }\n return cp ;\n }", "idx": 20555}
{"hash": -8721757784652752372, "project": "debian", "size": 7, "label": 0, "functionSource": "int jpc_enc_encodetiledata ( jpc_enc_t * enc ) {\n assert ( enc -> tmpstream ) ;\n if ( jpc_enc_encpkts ( enc , enc -> tmpstream ) ) {\n return - 1 ;\n }\n return 0 ;\n }", "idx": 20556}
{"hash": -2242211406757466627, "project": "debian", "size": 19, "label": 0, "functionSource": "void proto_reg_handoff_AllJoyn ( void ) {\n static gboolean initialized = FALSE ;\n static dissector_handle_t alljoyn_handle_ns ;\n static dissector_handle_t alljoyn_handle_ardp ;\n if ( ! initialized ) {\n alljoyn_handle_ns = new_create_dissector_handle ( dissect_AllJoyn_name_server , proto_AllJoyn_ns ) ;\n alljoyn_handle_ardp = new_create_dissector_handle ( dissect_AllJoyn_ardp , proto_AllJoyn_ardp ) ;\n }\n else {\n dissector_delete_uint ( \"udp.port\" , name_server_port , alljoyn_handle_ns ) ;\n dissector_delete_uint ( \"tcp.port\" , name_server_port , alljoyn_handle_ns ) ;\n dissector_delete_uint ( \"udp.port\" , message_port , alljoyn_handle_ardp ) ;\n dissector_delete_uint ( \"tcp.port\" , message_port , alljoyn_handle_ardp ) ;\n }\n dissector_add_uint ( \"udp.port\" , name_server_port , alljoyn_handle_ns ) ;\n dissector_add_uint ( \"tcp.port\" , name_server_port , alljoyn_handle_ns ) ;\n dissector_add_uint ( \"udp.port\" , message_port , alljoyn_handle_ardp ) ;\n dissector_add_uint ( \"tcp.port\" , message_port , alljoyn_handle_ardp ) ;\n }", "idx": 20557}
{"hash": -4239386405881995323, "project": "chrome", "size": 21, "label": 1, "functionSource": "void * xmlHashLookup3 ( xmlHashTablePtr table , const xmlChar * name , const xmlChar * name2 , const xmlChar * name3 ) {\n unsigned long key ;\n xmlHashEntryPtr entry ;\n if ( table == NULL ) return ( NULL ) ;\n if ( name == NULL ) return ( NULL ) ;\n key = xmlHashComputeKey ( table , name , name2 , name3 ) ;\n if ( table -> table [ key ] . valid == 0 ) return ( NULL ) ;\n if ( table -> dict ) {\n for ( entry = & ( table -> table [ key ] ) ;\n entry != NULL ;\n entry = entry -> next ) {\n if ( ( entry -> name == name ) && ( entry -> name2 == name2 ) && ( entry -> name3 == name3 ) ) return ( entry -> payload ) ;\n }\n }\n for ( entry = & ( table -> table [ key ] ) ;\n entry != NULL ;\n entry = entry -> next ) {\n if ( ( xmlStrEqual ( entry -> name , name ) ) && ( xmlStrEqual ( entry -> name2 , name2 ) ) && ( xmlStrEqual ( entry -> name3 , name3 ) ) ) return ( entry -> payload ) ;\n }\n return ( NULL ) ;\n }", "idx": 20558}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_RequestChannelCloseRelease ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_RequestChannelCloseRelease , RequestChannelCloseRelease_sequence ) ;\n return offset ;\n }", "idx": 20559}
{"hash": 7039307292471244756, "project": "debian", "size": 164, "label": 0, "functionSource": "static guint16 de_cause ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len , gchar * add_string , int string_len ) {\n guint8 oct ;\n guint8 cause ;\n guint32 curr_offset ;\n guint32 diag_length ;\n proto_tree * subtree ;\n const gchar * str ;\n curr_offset = offset ;\n proto_tree_add_item ( tree , hf_gsm_a_extension , tvb , curr_offset , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( tree , hf_gsm_a_dtap_de_cause_coding_standard , tvb , curr_offset , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_bits_item ( tree , hf_gsm_a_spare_bits , tvb , ( curr_offset << 3 ) + 3 , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( tree , hf_gsm_a_dtap_location , tvb , curr_offset , 1 , ENC_BIG_ENDIAN ) ;\n curr_offset ++ ;\n oct = tvb_get_guint8 ( tvb , curr_offset ) ;\n if ( ! ( oct & 0x80 ) ) {\n proto_tree_add_item ( tree , hf_gsm_a_extension , tvb , curr_offset , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( tree , hf_gsm_a_dtap_recommendation , tvb , curr_offset , 1 , ENC_BIG_ENDIAN ) ;\n curr_offset ++ ;\n oct = tvb_get_guint8 ( tvb , curr_offset ) ;\n }\n proto_tree_add_item ( tree , hf_gsm_a_extension , tvb , curr_offset , 1 , ENC_BIG_ENDIAN ) ;\n cause = oct & 0x7f ;\n switch ( cause ) {\n case 1 : str = \"Unassigned (unallocated) number\" ;\n break ;\n case 3 : str = \"No route to destination\" ;\n break ;\n case 6 : str = \"Channel unacceptable\" ;\n break ;\n case 8 : str = \"Operator determined barring\" ;\n break ;\n case 16 : str = \"Normal call clearing\" ;\n break ;\n case 17 : str = \"User busy\" ;\n break ;\n case 18 : str = \"No user responding\" ;\n break ;\n case 19 : str = \"User alerting, no answer\" ;\n break ;\n case 21 : str = \"Call rejected\" ;\n break ;\n case 22 : str = \"Call rejected due to feature at the destination\" ;\n break ;\n case 24 : str = \"Number changed\" ;\n break ;\n case 25 : str = \"Pre-emption\" ;\n break ;\n case 26 : str = \"Non selected user clearing\" ;\n break ;\n case 27 : str = \"Destination out of order\" ;\n break ;\n case 28 : str = \"Invalid number format (incomplete number)\" ;\n break ;\n case 29 : str = \"Facility rejected\" ;\n break ;\n case 30 : str = \"Response to STATUS ENQUIRY\" ;\n break ;\n case 31 : str = \"Normal, unspecified\" ;\n break ;\n case 34 : str = \"No circuit/channel available\" ;\n break ;\n case 38 : str = \"Network out of order\" ;\n break ;\n case 41 : str = \"Temporary failure\" ;\n break ;\n case 42 : str = \"Switching equipment congestion\" ;\n break ;\n case 43 : str = \"Access information discarded\" ;\n break ;\n case 44 : str = \"requested circuit/channel not available\" ;\n break ;\n case 47 : str = \"Resources unavailable, unspecified\" ;\n break ;\n case 49 : str = \"Quality of service unavailable\" ;\n break ;\n case 50 : str = \"Requested facility not subscribed\" ;\n break ;\n case 55 : str = \"Incoming calls barred within the CUG\" ;\n break ;\n case 57 : str = \"Bearer capability not authorized\" ;\n break ;\n case 58 : str = \"Bearer capability not presently available\" ;\n break ;\n case 63 : str = \"Service or option not available, unspecified\" ;\n break ;\n case 65 : str = \"Bearer service not implemented\" ;\n break ;\n case 68 : str = \"ACM equal to or greater than ACMmax\" ;\n break ;\n case 69 : str = \"Requested facility not implemented\" ;\n break ;\n case 70 : str = \"Only restricted digital information bearer capability is available\" ;\n break ;\n case 79 : str = \"Service or option not implemented, unspecified\" ;\n break ;\n case 81 : str = \"Invalid transaction identifier value\" ;\n break ;\n case 87 : str = \"User not member of CUG\" ;\n break ;\n case 88 : str = \"Incompatible destination\" ;\n break ;\n case 91 : str = \"Invalid transit network selection\" ;\n break ;\n case 95 : str = \"Semantically incorrect message\" ;\n break ;\n case 96 : str = \"Invalid mandatory information\" ;\n break ;\n case 97 : str = \"Message type non-existent or not implemented\" ;\n break ;\n case 98 : str = \"Message type not compatible with protocol state\" ;\n break ;\n case 99 : str = \"Information element non-existent or not implemented\" ;\n break ;\n case 100 : str = \"Conditional IE error\" ;\n break ;\n case 101 : str = \"Message not compatible with protocol state\" ;\n break ;\n case 102 : str = \"Recovery on timer expiry\" ;\n break ;\n case 111 : str = \"Protocol error, unspecified\" ;\n break ;\n case 127 : str = \"Interworking, unspecified\" ;\n break ;\n default : if ( cause <= 31 ) {\n str = \"Treat as Normal, unspecified\" ;\n }\n else if ( ( cause >= 32 ) && ( cause <= 47 ) ) {\n str = \"Treat as Resources unavailable, unspecified\" ;\n }\n else if ( ( cause >= 48 ) && ( cause <= 63 ) ) {\n str = \"Treat as Service or option not available, unspecified\" ;\n }\n else if ( ( cause >= 64 ) && ( cause <= 79 ) ) {\n str = \"Treat as Service or option not implemented, unspecified\" ;\n }\n else if ( ( cause >= 80 ) && ( cause <= 95 ) ) {\n str = \"Treat as Semantically incorrect message\" ;\n }\n else if ( ( cause >= 96 ) && ( cause <= 111 ) ) {\n str = \"Treat as Protocol error, unspecified\" ;\n }\n else {\n str = \"Treat as Interworking, unspecified\" ;\n }\n break ;\n }\n proto_tree_add_uint_format_value ( tree , hf_gsm_a_dtap_cause , tvb , curr_offset , 1 , cause , \"Cause: (%u) %s\" , cause , str ) ;\n curr_offset ++ ;\n if ( add_string ) g_snprintf ( add_string , string_len , \" - (%u) %s\" , cause , str ) ;\n NO_MORE_DATA_CHECK ( len ) ;\n subtree = proto_tree_add_subtree ( tree , tvb , curr_offset , len - ( curr_offset - offset ) , ett_gsm_dtap_elem [ DE_CAUSE ] , NULL , \"Diagnostics\" ) ;\n if ( ( cause == 17 ) || ( cause == 29 ) || ( cause == 34 ) || ( cause == 50 ) || ( cause == 55 ) || ( cause == 69 ) || ( cause == 87 ) ) {\n proto_tree_add_item ( subtree , hf_gsm_a_extension , tvb , curr_offset , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( subtree , hf_gsm_a_dtap_cause_ss_diagnostics , tvb , curr_offset , 1 , ENC_BIG_ENDIAN ) ;\n curr_offset ++ ;\n }\n else {\n diag_length = len - ( curr_offset - offset ) ;\n proto_tree_add_item ( subtree , hf_gsm_a_dtap_data , tvb , curr_offset , diag_length , ENC_NA ) ;\n curr_offset += diag_length ;\n }\n EXTRANEOUS_DATA_CHECK ( len , curr_offset - offset , pinfo , & ei_gsm_a_dtap_extraneous_data ) ;\n return ( curr_offset - offset ) ;\n }", "idx": 20560}
{"hash": -341028540041678099, "project": "debian", "size": 30, "label": 0, "functionSource": "static void dump_hex_printable ( const void * data , size_t len ) {\n const char * cdata ;\n const char * rowstart ;\n size_t idx ;\n size_t rowlen ;\n u_char uch ;\n cdata = data ;\n while ( len > 0 ) {\n rowstart = cdata ;\n rowlen = min ( 16 , len ) ;\n for ( idx = 0 ;\n idx < rowlen ;\n idx ++ ) {\n uch = * ( cdata ++ ) ;\n printf ( \"%02x \" , uch ) ;\n }\n for ( ;\n idx < 16 ;\n idx ++ ) printf ( \" \" ) ;\n cdata = rowstart ;\n for ( idx = 0 ;\n idx < rowlen ;\n idx ++ ) {\n uch = * ( cdata ++ ) ;\n printf ( \"%c\" , ( isprint ( uch ) ) ? uch : '.' ) ;\n }\n printf ( \"\\n\" ) ;\n len -= rowlen ;\n }\n }", "idx": 20561}
{"hash": -3053641395158209010, "project": "debian", "size": 38, "label": 0, "functionSource": "int HandleIoctl ( struct vcache * avc , afs_int32 acom , struct afs_ioctl * adata ) {\n afs_int32 code ;\n code = 0 ;\n AFS_STATCNT ( HandleIoctl ) ;\n switch ( acom & 0xff ) {\n case 1 : avc -> f . states |= CSafeStore ;\n avc -> asynchrony = 0 ;\n break ;\n case 3 : {\n struct cell * tcell ;\n afs_int32 i ;\n tcell = afs_GetCell ( avc -> f . fid . Cell , READ_LOCK ) ;\n if ( tcell ) {\n i = strlen ( tcell -> cellName ) + 1 ;\n if ( i > adata -> out_size ) {\n if ( adata -> out_size != 0 ) code = EFAULT ;\n }\n else {\n AFS_COPYOUT ( tcell -> cellName , adata -> out , i , code ) ;\n }\n afs_PutCell ( tcell , READ_LOCK ) ;\n }\n else code = ENOTTY ;\n }\n break ;\n case 49 : if ( adata -> out_size < sizeof ( struct cm_initparams ) ) {\n code = EFAULT ;\n }\n else {\n AFS_COPYOUT ( & cm_initParams , adata -> out , sizeof ( struct cm_initparams ) , code ) ;\n }\n break ;\n default : code = EINVAL ;\n # ifdef AFS_AIX51_ENV code = ENOSYS ;\n # endif break ;\n }\n return code ;\n }", "idx": 20562}
{"hash": 7072059544915633710, "project": "chrome", "size": 404, "label": 1, "functionSource": "static void _LMBCSOpen ## n ( UConverter * _this , UConverterLoadArgs * pArgs , UErrorCode * err ) \\ {\n _LMBCSOpenWorker ( _this , pArgs , err , n ) ;\n }\n static void _LMBCSOpenWorker ( UConverter * _this , UConverterLoadArgs * pArgs , UErrorCode * err , ulmbcs_byte_t OptGroup ) {\n UConverterDataLMBCS * extraInfo = _this -> extraInfo = ( UConverterDataLMBCS * ) uprv_malloc ( sizeof ( UConverterDataLMBCS ) ) ;\n if ( extraInfo != NULL ) {\n UConverterNamePieces stackPieces ;\n UConverterLoadArgs stackArgs = {\n ( int32_t ) sizeof ( UConverterLoadArgs ) }\n ;\n ulmbcs_byte_t i ;\n uprv_memset ( extraInfo , 0 , sizeof ( UConverterDataLMBCS ) ) ;\n stackArgs . onlyTestIsLoadable = pArgs -> onlyTestIsLoadable ;\n for ( i = 0 ;\n i <= ULMBCS_GRP_LAST && U_SUCCESS ( * err ) ;\n i ++ ) {\n if ( OptGroupByteToCPName [ i ] != NULL ) {\n extraInfo -> OptGrpConverter [ i ] = ucnv_loadSharedData ( OptGroupByteToCPName [ i ] , & stackPieces , & stackArgs , err ) ;\n }\n }\n if ( U_FAILURE ( * err ) || pArgs -> onlyTestIsLoadable ) {\n _LMBCSClose ( _this ) ;\n return ;\n }\n extraInfo -> OptGroup = OptGroup ;\n extraInfo -> localeConverterIndex = FindLMBCSLocale ( pArgs -> locale ) ;\n }\n else {\n * err = U_MEMORY_ALLOCATION_ERROR ;\n }\n }\n static void _LMBCSClose ( UConverter * _this ) {\n if ( _this -> extraInfo != NULL ) {\n ulmbcs_byte_t Ix ;\n UConverterDataLMBCS * extraInfo = ( UConverterDataLMBCS * ) _this -> extraInfo ;\n for ( Ix = 0 ;\n Ix <= ULMBCS_GRP_LAST ;\n Ix ++ ) {\n if ( extraInfo -> OptGrpConverter [ Ix ] != NULL ) ucnv_unloadSharedDataIfReady ( extraInfo -> OptGrpConverter [ Ix ] ) ;\n }\n if ( ! _this -> isExtraLocal ) {\n uprv_free ( _this -> extraInfo ) ;\n _this -> extraInfo = NULL ;\n }\n }\n }\n typedef struct LMBCSClone {\n UConverter cnv ;\n UConverterDataLMBCS lmbcs ;\n }\n LMBCSClone ;\n static UConverter * _LMBCSSafeClone ( const UConverter * cnv , void * stackBuffer , int32_t * pBufferSize , UErrorCode * status ) {\n LMBCSClone * newLMBCS ;\n UConverterDataLMBCS * extraInfo ;\n int32_t i ;\n if ( * pBufferSize <= 0 ) {\n * pBufferSize = ( int32_t ) sizeof ( LMBCSClone ) ;\n return NULL ;\n }\n extraInfo = ( UConverterDataLMBCS * ) cnv -> extraInfo ;\n newLMBCS = ( LMBCSClone * ) stackBuffer ;\n uprv_memcpy ( & newLMBCS -> lmbcs , extraInfo , sizeof ( UConverterDataLMBCS ) ) ;\n for ( i = 0 ;\n i <= ULMBCS_GRP_LAST ;\n ++ i ) {\n if ( extraInfo -> OptGrpConverter [ i ] != NULL ) {\n ucnv_incrementRefCount ( extraInfo -> OptGrpConverter [ i ] ) ;\n }\n }\n newLMBCS -> cnv . extraInfo = & newLMBCS -> lmbcs ;\n newLMBCS -> cnv . isExtraLocal = TRUE ;\n return & newLMBCS -> cnv ;\n }\n static size_t LMBCSConversionWorker ( UConverterDataLMBCS * extraInfo , ulmbcs_byte_t group , ulmbcs_byte_t * pStartLMBCS , UChar * pUniChar , ulmbcs_byte_t * lastConverterIndex , UBool * groups_tried ) {\n ulmbcs_byte_t * pLMBCS = pStartLMBCS ;\n UConverterSharedData * xcnv = extraInfo -> OptGrpConverter [ group ] ;\n int bytesConverted ;\n uint32_t value ;\n ulmbcs_byte_t firstByte ;\n U_ASSERT ( xcnv ) ;\n U_ASSERT ( group < ULMBCS_GRP_UNICODE ) ;\n bytesConverted = ucnv_MBCSFromUChar32 ( xcnv , * pUniChar , & value , FALSE ) ;\n if ( bytesConverted > 0 ) {\n firstByte = ( ulmbcs_byte_t ) ( value >> ( ( bytesConverted - 1 ) * 8 ) ) ;\n }\n else {\n groups_tried [ group ] = TRUE ;\n return 0 ;\n }\n * lastConverterIndex = group ;\n U_ASSERT ( ( firstByte <= ULMBCS_C0END ) || ( firstByte >= ULMBCS_C1START ) || ( group == ULMBCS_GRP_EXCEPT ) ) ;\n if ( group != ULMBCS_GRP_EXCEPT && extraInfo -> OptGroup != group ) {\n * pLMBCS ++ = group ;\n if ( bytesConverted == 1 && group >= ULMBCS_DOUBLEOPTGROUP_START ) {\n * pLMBCS ++ = group ;\n }\n }\n if ( bytesConverted == 1 && firstByte < 0x20 ) return 0 ;\n switch ( bytesConverted ) {\n case 4 : * pLMBCS ++ = ( ulmbcs_byte_t ) ( value >> 24 ) ;\n U_FALLTHROUGH ;\n case 3 : * pLMBCS ++ = ( ulmbcs_byte_t ) ( value >> 16 ) ;\n U_FALLTHROUGH ;\n case 2 : * pLMBCS ++ = ( ulmbcs_byte_t ) ( value >> 8 ) ;\n U_FALLTHROUGH ;\n case 1 : * pLMBCS ++ = ( ulmbcs_byte_t ) value ;\n U_FALLTHROUGH ;\n default : break ;\n }\n return ( pLMBCS - pStartLMBCS ) ;\n }\n static size_t LMBCSConvertUni ( ulmbcs_byte_t * pLMBCS , UChar uniChar ) {\n uint8_t LowCh = ( uint8_t ) ( uniChar & 0x00FF ) ;\n uint8_t HighCh = ( uint8_t ) ( uniChar >> 8 ) ;\n * pLMBCS ++ = ULMBCS_GRP_UNICODE ;\n if ( LowCh == 0 ) {\n * pLMBCS ++ = ULMBCS_UNICOMPATZERO ;\n * pLMBCS ++ = HighCh ;\n }\n else {\n * pLMBCS ++ = HighCh ;\n * pLMBCS ++ = LowCh ;\n }\n return ULMBCS_UNICODE_SIZE ;\n }\n static void _LMBCSFromUnicode ( UConverterFromUnicodeArgs * args , UErrorCode * err ) {\n ulmbcs_byte_t lastConverterIndex = 0 ;\n UChar uniChar ;\n ulmbcs_byte_t LMBCS [ ULMBCS_CHARSIZE_MAX ] ;\n ulmbcs_byte_t * pLMBCS ;\n int32_t bytes_written ;\n UBool groups_tried [ ULMBCS_GRP_LAST + 1 ] ;\n UConverterDataLMBCS * extraInfo = ( UConverterDataLMBCS * ) args -> converter -> extraInfo ;\n int sourceIndex = 0 ;\n ulmbcs_byte_t OldConverterIndex = 0 ;\n while ( args -> source < args -> sourceLimit && ! U_FAILURE ( * err ) ) {\n OldConverterIndex = extraInfo -> localeConverterIndex ;\n if ( args -> target >= args -> targetLimit ) {\n * err = U_BUFFER_OVERFLOW_ERROR ;\n break ;\n }\n uniChar = * ( args -> source ) ;\n bytes_written = 0 ;\n pLMBCS = LMBCS ;\n if ( ( uniChar >= 0x80 ) && ( uniChar <= 0xff ) && ( uniChar != 0xB1 ) && ( uniChar != 0xD7 ) && ( uniChar != 0xF7 ) && ( uniChar != 0xB0 ) && ( uniChar != 0xB4 ) && ( uniChar != 0xB6 ) && ( uniChar != 0xA7 ) && ( uniChar != 0xA8 ) ) {\n extraInfo -> localeConverterIndex = ULMBCS_GRP_L1 ;\n }\n if ( ( ( uniChar > ULMBCS_C0END ) && ( uniChar < ULMBCS_C1START ) ) || uniChar == 0 || uniChar == ULMBCS_HT || uniChar == ULMBCS_CR || uniChar == ULMBCS_LF || uniChar == ULMBCS_123SYSTEMRANGE ) {\n * pLMBCS ++ = ( ulmbcs_byte_t ) uniChar ;\n bytes_written = 1 ;\n }\n if ( ! bytes_written ) {\n ulmbcs_byte_t group = FindLMBCSUniRange ( uniChar ) ;\n if ( group == ULMBCS_GRP_UNICODE ) {\n pLMBCS += LMBCSConvertUni ( pLMBCS , uniChar ) ;\n bytes_written = ( int32_t ) ( pLMBCS - LMBCS ) ;\n }\n else if ( group == ULMBCS_GRP_CTRL ) {\n if ( uniChar <= ULMBCS_C0END ) {\n * pLMBCS ++ = ULMBCS_GRP_CTRL ;\n * pLMBCS ++ = ( ulmbcs_byte_t ) ( ULMBCS_CTRLOFFSET + uniChar ) ;\n }\n else if ( uniChar >= ULMBCS_C1START && uniChar <= ULMBCS_C1START + ULMBCS_CTRLOFFSET ) {\n * pLMBCS ++ = ULMBCS_GRP_CTRL ;\n * pLMBCS ++ = ( ulmbcs_byte_t ) ( uniChar & 0x00FF ) ;\n }\n bytes_written = ( int32_t ) ( pLMBCS - LMBCS ) ;\n }\n else if ( group < ULMBCS_GRP_UNICODE ) {\n bytes_written = ( int32_t ) LMBCSConversionWorker ( extraInfo , group , pLMBCS , & uniChar , & lastConverterIndex , groups_tried ) ;\n }\n if ( ! bytes_written ) {\n uprv_memset ( groups_tried , 0 , sizeof ( groups_tried ) ) ;\n if ( ( extraInfo -> OptGroup != 1 ) && ( ULMBCS_AMBIGUOUS_MATCH ( group , extraInfo -> OptGroup ) ) ) {\n if ( extraInfo -> localeConverterIndex < ULMBCS_DOUBLEOPTGROUP_START ) {\n bytes_written = LMBCSConversionWorker ( extraInfo , ULMBCS_GRP_L1 , pLMBCS , & uniChar , & lastConverterIndex , groups_tried ) ;\n if ( ! bytes_written ) {\n bytes_written = LMBCSConversionWorker ( extraInfo , ULMBCS_GRP_EXCEPT , pLMBCS , & uniChar , & lastConverterIndex , groups_tried ) ;\n }\n if ( ! bytes_written ) {\n bytes_written = LMBCSConversionWorker ( extraInfo , extraInfo -> localeConverterIndex , pLMBCS , & uniChar , & lastConverterIndex , groups_tried ) ;\n }\n }\n else {\n bytes_written = LMBCSConversionWorker ( extraInfo , extraInfo -> localeConverterIndex , pLMBCS , & uniChar , & lastConverterIndex , groups_tried ) ;\n }\n }\n if ( ! bytes_written && ( extraInfo -> localeConverterIndex ) && ( ULMBCS_AMBIGUOUS_MATCH ( group , extraInfo -> localeConverterIndex ) ) ) {\n bytes_written = ( int32_t ) LMBCSConversionWorker ( extraInfo , extraInfo -> localeConverterIndex , pLMBCS , & uniChar , & lastConverterIndex , groups_tried ) ;\n }\n if ( ! bytes_written && ( lastConverterIndex ) && ( ULMBCS_AMBIGUOUS_MATCH ( group , lastConverterIndex ) ) ) {\n bytes_written = ( int32_t ) LMBCSConversionWorker ( extraInfo , lastConverterIndex , pLMBCS , & uniChar , & lastConverterIndex , groups_tried ) ;\n }\n if ( ! bytes_written ) {\n ulmbcs_byte_t grp_start ;\n ulmbcs_byte_t grp_end ;\n ulmbcs_byte_t grp_ix ;\n grp_start = ( ulmbcs_byte_t ) ( ( group == ULMBCS_AMBIGUOUS_MBCS ) ? ULMBCS_DOUBLEOPTGROUP_START : ULMBCS_GRP_L1 ) ;\n grp_end = ( ulmbcs_byte_t ) ( ( group == ULMBCS_AMBIGUOUS_MBCS ) ? ULMBCS_GRP_LAST : ULMBCS_GRP_TH ) ;\n if ( group == ULMBCS_AMBIGUOUS_ALL ) {\n grp_start = ULMBCS_GRP_L1 ;\n grp_end = ULMBCS_GRP_LAST ;\n }\n for ( grp_ix = grp_start ;\n grp_ix <= grp_end && ! bytes_written ;\n grp_ix ++ ) {\n if ( extraInfo -> OptGrpConverter [ grp_ix ] && ! groups_tried [ grp_ix ] ) {\n bytes_written = ( int32_t ) LMBCSConversionWorker ( extraInfo , grp_ix , pLMBCS , & uniChar , & lastConverterIndex , groups_tried ) ;\n }\n }\n if ( ! bytes_written && grp_start == ULMBCS_GRP_L1 ) {\n bytes_written = ( int32_t ) LMBCSConversionWorker ( extraInfo , ULMBCS_GRP_EXCEPT , pLMBCS , & uniChar , & lastConverterIndex , groups_tried ) ;\n }\n }\n if ( ! bytes_written ) {\n pLMBCS += LMBCSConvertUni ( pLMBCS , uniChar ) ;\n bytes_written = ( int32_t ) ( pLMBCS - LMBCS ) ;\n }\n }\n }\n args -> source ++ ;\n pLMBCS = LMBCS ;\n while ( args -> target < args -> targetLimit && bytes_written -- ) {\n * ( args -> target ) ++ = * pLMBCS ++ ;\n if ( args -> offsets ) {\n * ( args -> offsets ) ++ = sourceIndex ;\n }\n }\n sourceIndex ++ ;\n if ( bytes_written > 0 ) {\n uint8_t * pErrorBuffer = args -> converter -> charErrorBuffer ;\n * err = U_BUFFER_OVERFLOW_ERROR ;\n args -> converter -> charErrorBufferLength = ( int8_t ) bytes_written ;\n while ( bytes_written -- ) {\n * pErrorBuffer ++ = * pLMBCS ++ ;\n }\n }\n extraInfo -> localeConverterIndex = OldConverterIndex ;\n }\n }\n static UChar GetUniFromLMBCSUni ( char const * * ppLMBCSin ) {\n uint8_t HighCh = * ( * ppLMBCSin ) ++ ;\n uint8_t LowCh = * ( * ppLMBCSin ) ++ ;\n if ( HighCh == ULMBCS_UNICOMPATZERO ) {\n HighCh = LowCh ;\n LowCh = 0 ;\n }\n return ( UChar ) ( ( HighCh << 8 ) | LowCh ) ;\n }\n # define CHECK_SOURCE_LIMIT ( index ) if ( args -> source + index > args -> sourceLimit ) {\n * err = U_TRUNCATED_CHAR_FOUND ;\n args -> source = args -> sourceLimit ;\n return 0xffff ;\n }\n static UChar32 _LMBCSGetNextUCharWorker ( UConverterToUnicodeArgs * args , UErrorCode * err ) {\n UChar32 uniChar = 0 ;\n ulmbcs_byte_t CurByte ;\n if ( args -> source >= args -> sourceLimit ) {\n * err = U_ILLEGAL_ARGUMENT_ERROR ;\n return 0xffff ;\n }\n CurByte = * ( ( ulmbcs_byte_t * ) ( args -> source ++ ) ) ;\n if ( ( ( CurByte > ULMBCS_C0END ) && ( CurByte < ULMBCS_C1START ) ) || ( CurByte == 0 ) || CurByte == ULMBCS_HT || CurByte == ULMBCS_CR || CurByte == ULMBCS_LF || CurByte == ULMBCS_123SYSTEMRANGE ) {\n uniChar = CurByte ;\n }\n else {\n UConverterDataLMBCS * extraInfo ;\n ulmbcs_byte_t group ;\n UConverterSharedData * cnv ;\n if ( CurByte == ULMBCS_GRP_CTRL ) {\n ulmbcs_byte_t C0C1byte ;\n CHECK_SOURCE_LIMIT ( 1 ) ;\n C0C1byte = * ( args -> source ) ++ ;\n uniChar = ( C0C1byte < ULMBCS_C1START ) ? C0C1byte - ULMBCS_CTRLOFFSET : C0C1byte ;\n }\n else if ( CurByte == ULMBCS_GRP_UNICODE ) {\n CHECK_SOURCE_LIMIT ( 2 ) ;\n return GetUniFromLMBCSUni ( & ( args -> source ) ) ;\n }\n else if ( CurByte <= ULMBCS_CTRLOFFSET ) {\n group = CurByte ;\n extraInfo = ( UConverterDataLMBCS * ) args -> converter -> extraInfo ;\n if ( group > ULMBCS_GRP_LAST || ( cnv = extraInfo -> OptGrpConverter [ group ] ) == NULL ) {\n * err = U_INVALID_CHAR_FOUND ;\n }\n else if ( group >= ULMBCS_DOUBLEOPTGROUP_START ) {\n CHECK_SOURCE_LIMIT ( 2 ) ;\n if ( * args -> source == group ) {\n ++ args -> source ;\n uniChar = ucnv_MBCSSimpleGetNextUChar ( cnv , args -> source , 1 , FALSE ) ;\n ++ args -> source ;\n }\n else {\n uniChar = ucnv_MBCSSimpleGetNextUChar ( cnv , args -> source , 2 , FALSE ) ;\n args -> source += 2 ;\n }\n }\n else {\n CHECK_SOURCE_LIMIT ( 1 ) ;\n CurByte = * ( args -> source ) ++ ;\n if ( CurByte >= ULMBCS_C1START ) {\n uniChar = _MBCS_SINGLE_SIMPLE_GET_NEXT_BMP ( cnv , CurByte ) ;\n }\n else {\n char bytes [ 2 ] ;\n extraInfo = ( UConverterDataLMBCS * ) args -> converter -> extraInfo ;\n cnv = extraInfo -> OptGrpConverter [ ULMBCS_GRP_EXCEPT ] ;\n bytes [ 0 ] = group ;\n bytes [ 1 ] = CurByte ;\n uniChar = ucnv_MBCSSimpleGetNextUChar ( cnv , bytes , 2 , FALSE ) ;\n }\n }\n }\n else if ( CurByte >= ULMBCS_C1START ) {\n extraInfo = ( UConverterDataLMBCS * ) args -> converter -> extraInfo ;\n group = extraInfo -> OptGroup ;\n cnv = extraInfo -> OptGrpConverter [ group ] ;\n if ( group >= ULMBCS_DOUBLEOPTGROUP_START ) {\n if ( ! ucnv_MBCSIsLeadByte ( cnv , CurByte ) ) {\n CHECK_SOURCE_LIMIT ( 0 ) ;\n uniChar = ucnv_MBCSSimpleGetNextUChar ( cnv , args -> source - 1 , 1 , FALSE ) ;\n }\n else {\n CHECK_SOURCE_LIMIT ( 1 ) ;\n uniChar = ucnv_MBCSSimpleGetNextUChar ( cnv , args -> source - 1 , 2 , FALSE ) ;\n ++ args -> source ;\n }\n }\n else {\n uniChar = _MBCS_SINGLE_SIMPLE_GET_NEXT_BMP ( cnv , CurByte ) ;\n }\n }\n }\n return uniChar ;\n }\n static void _LMBCSToUnicodeWithOffsets ( UConverterToUnicodeArgs * args , UErrorCode * err ) {\n char LMBCS [ ULMBCS_CHARSIZE_MAX ] ;\n UChar uniChar ;\n const char * saveSource ;\n const char * pStartLMBCS = args -> source ;\n const char * errSource = NULL ;\n int8_t savebytes = 0 ;\n while ( U_SUCCESS ( * err ) && args -> sourceLimit > args -> source && args -> targetLimit > args -> target ) {\n saveSource = args -> source ;\n if ( args -> converter -> toULength ) {\n const char * saveSourceLimit ;\n size_t size_old = args -> converter -> toULength ;\n size_t size_new_maybe_1 = sizeof ( LMBCS ) - size_old ;\n size_t size_new_maybe_2 = args -> sourceLimit - args -> source ;\n size_t size_new = ( size_new_maybe_1 < size_new_maybe_2 ) ? size_new_maybe_1 : size_new_maybe_2 ;\n uprv_memcpy ( LMBCS , args -> converter -> toUBytes , size_old ) ;\n uprv_memcpy ( LMBCS + size_old , args -> source , size_new ) ;\n saveSourceLimit = args -> sourceLimit ;\n args -> source = errSource = LMBCS ;\n args -> sourceLimit = LMBCS + size_old + size_new ;\n savebytes = ( int8_t ) ( size_old + size_new ) ;\n uniChar = ( UChar ) _LMBCSGetNextUCharWorker ( args , err ) ;\n args -> source = saveSource + ( ( args -> source - LMBCS ) - size_old ) ;\n args -> sourceLimit = saveSourceLimit ;\n if ( * err == U_TRUNCATED_CHAR_FOUND ) {\n args -> converter -> toULength = savebytes ;\n uprv_memcpy ( args -> converter -> toUBytes , LMBCS , savebytes ) ;\n args -> source = args -> sourceLimit ;\n * err = U_ZERO_ERROR ;\n return ;\n }\n else {\n args -> converter -> toULength = 0 ;\n }\n }\n else {\n errSource = saveSource ;\n uniChar = ( UChar ) _LMBCSGetNextUCharWorker ( args , err ) ;\n savebytes = ( int8_t ) ( args -> source - saveSource ) ;\n }\n if ( U_SUCCESS ( * err ) ) {\n if ( uniChar < 0xfffe ) {\n * ( args -> target ) ++ = uniChar ;\n if ( args -> offsets ) {\n * ( args -> offsets ) ++ = ( int32_t ) ( saveSource - pStartLMBCS ) ;\n }\n }\n else if ( uniChar == 0xfffe ) {\n * err = U_INVALID_CHAR_FOUND ;\n }\n else {\n * err = U_ILLEGAL_CHAR_FOUND ;\n }\n }\n }\n if ( U_SUCCESS ( * err ) && args -> sourceLimit > args -> source && args -> targetLimit <= args -> target ) {\n * err = U_BUFFER_OVERFLOW_ERROR ;\n }\n else if ( U_FAILURE ( * err ) ) {\n args -> converter -> toULength = savebytes ;\n if ( savebytes > 0 ) {\n uprv_memcpy ( args -> converter -> toUBytes , errSource , savebytes ) ;\n }\n if ( * err == U_TRUNCATED_CHAR_FOUND ) {\n * err = U_ZERO_ERROR ;\n }\n }\n }\n DEFINE_LMBCS_OPEN ( 1 ) DEFINE_LMBCS_OPEN ( 2 ) DEFINE_LMBCS_OPEN ( 3 ) DEFINE_LMBCS_OPEN ( 4 ) DEFINE_LMBCS_OPEN ( 5 ) DEFINE_LMBCS_OPEN ( 6 ) DEFINE_LMBCS_OPEN ( 8 ) DEFINE_LMBCS_OPEN ( 11 ) DEFINE_LMBCS_OPEN ( 16 )", "idx": 20563}
{"hash": 6336384260629386331, "project": "debian", "size": 3, "label": 0, "functionSource": "static void decode_zcl_ota_size_in_bytes ( gchar * s , guint32 value ) {\n g_snprintf ( s , ITEM_LABEL_LENGTH , \"%d [Bytes]\" , value ) ;\n }", "idx": 20564}
{"hash": -6126432314261451839, "project": "debian", "size": 3, "label": 0, "functionSource": "int gs_copydevice ( gx_device * * pnew_dev , const gx_device * dev , gs_memory_t * mem ) {\n return gs_copydevice2 ( pnew_dev , dev , false , mem ) ;\n }", "idx": 20565}
{"hash": 4489017523191997023, "project": "debian", "size": 10, "label": 0, "functionSource": "static int dissect_h225_Status_UUIE ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 388 \"./asn1/h225/h225.cnf\" h225_packet_info * h225_pi ;\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_Status_UUIE , Status_UUIE_sequence ) ;\n # line 392 \"./asn1/h225/h225.cnf\" h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;\n if ( h225_pi != NULL ) {\n h225_pi -> cs_type = H225_STATUS ;\n g_snprintf ( h225_pi -> frame_label , 50 , \"%s\" , val_to_str ( h225_pi -> cs_type , T_h323_message_body_vals , \"<unknown>\" ) ) ;\n }\n return offset ;\n }", "idx": 20566}
{"hash": 4489017523191997023, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h225_DestinationInfo ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence_of ( tvb , offset , actx , tree , hf_index , ett_h225_DestinationInfo , DestinationInfo_sequence_of ) ;\n return offset ;\n }", "idx": 20567}
{"hash": 2390790920103114259, "project": "debian", "size": 34, "label": 0, "functionSource": "static void processlacon ( struct vars * v , struct state * begin , struct state * end , int latype , struct state * lp , struct state * rp ) {\n struct state * s1 ;\n int n ;\n s1 = single_color_transition ( begin , end ) ;\n switch ( latype ) {\n case LATYPE_AHEAD_POS : if ( s1 != NULL ) {\n cloneouts ( v -> nfa , s1 , lp , rp , AHEAD ) ;\n return ;\n }\n break ;\n case LATYPE_AHEAD_NEG : if ( s1 != NULL ) {\n colorcomplement ( v -> nfa , v -> cm , AHEAD , s1 , lp , rp ) ;\n newarc ( v -> nfa , '$' , 1 , lp , rp ) ;\n newarc ( v -> nfa , '$' , 0 , lp , rp ) ;\n return ;\n }\n break ;\n case LATYPE_BEHIND_POS : if ( s1 != NULL ) {\n cloneouts ( v -> nfa , s1 , lp , rp , BEHIND ) ;\n return ;\n }\n break ;\n case LATYPE_BEHIND_NEG : if ( s1 != NULL ) {\n colorcomplement ( v -> nfa , v -> cm , BEHIND , s1 , lp , rp ) ;\n newarc ( v -> nfa , '^' , 1 , lp , rp ) ;\n newarc ( v -> nfa , '^' , 0 , lp , rp ) ;\n return ;\n }\n break ;\n default : assert ( NOTREACHED ) ;\n }\n n = newlacon ( v , begin , end , latype ) ;\n newarc ( v -> nfa , LACON , n , lp , rp ) ;\n }", "idx": 20568}
{"hash": -7455544248455991006, "project": "debian", "size": 6, "label": 0, "functionSource": "int kvm_device_intx_set_mask ( KVMState * s , uint32_t dev_id , bool masked ) {\n struct kvm_assigned_pci_dev dev_data = {\n . assigned_dev_id = dev_id , . flags = masked ? KVM_DEV_ASSIGN_MASK_INTX : 0 , }\n ;\n return kvm_vm_ioctl ( s , KVM_ASSIGN_SET_INTX_MASK , & dev_data ) ;\n }", "idx": 20569}
{"hash": -1983921383858884161, "project": "debian", "size": 32, "label": 1, "functionSource": "static int ipvideo_decode_block_opcode_0x7 ( IpvideoContext * s ) {\n int x , y ;\n unsigned char P [ 2 ] ;\n unsigned int flags ;\n P [ 0 ] = bytestream2_get_byte ( & s -> stream_ptr ) ;\n P [ 1 ] = bytestream2_get_byte ( & s -> stream_ptr ) ;\n if ( P [ 0 ] <= P [ 1 ] ) {\n for ( y = 0 ;\n y < 8 ;\n y ++ ) {\n flags = bytestream2_get_byte ( & s -> stream_ptr ) | 0x100 ;\n for ( ;\n flags != 1 ;\n flags >>= 1 ) * s -> pixel_ptr ++ = P [ flags & 1 ] ;\n s -> pixel_ptr += s -> line_inc ;\n }\n }\n else {\n flags = bytestream2_get_le16 ( & s -> stream_ptr ) ;\n for ( y = 0 ;\n y < 8 ;\n y += 2 ) {\n for ( x = 0 ;\n x < 8 ;\n x += 2 , flags >>= 1 ) {\n s -> pixel_ptr [ x ] = s -> pixel_ptr [ x + 1 ] = s -> pixel_ptr [ x + s -> stride ] = s -> pixel_ptr [ x + 1 + s -> stride ] = P [ flags & 1 ] ;\n }\n s -> pixel_ptr += s -> stride * 2 ;\n }\n }\n return 0 ;\n }", "idx": 20570}
{"hash": -3559021711340554904, "project": "debian", "size": 20, "label": 0, "functionSource": "static Node * substitute_actual_srf_parameters_mutator ( Node * node , substitute_actual_srf_parameters_context * context ) {\n Node * result ;\n if ( node == NULL ) return NULL ;\n if ( IsA ( node , Query ) ) {\n context -> sublevels_up ++ ;\n result = ( Node * ) query_tree_mutator ( ( Query * ) node , substitute_actual_srf_parameters_mutator , ( void * ) context , 0 ) ;\n context -> sublevels_up -- ;\n return result ;\n }\n if ( IsA ( node , Param ) ) {\n Param * param = ( Param * ) node ;\n if ( param -> paramkind == PARAM_EXTERN ) {\n if ( param -> paramid <= 0 || param -> paramid > context -> nargs ) elog ( ERROR , \"invalid paramid: %d\" , param -> paramid ) ;\n result = copyObject ( list_nth ( context -> args , param -> paramid - 1 ) ) ;\n IncrementVarSublevelsUp ( result , context -> sublevels_up , 0 ) ;\n return result ;\n }\n }\n return expression_tree_mutator ( node , substitute_actual_srf_parameters_mutator , ( void * ) context ) ;\n }", "idx": 20571}
{"hash": 4489017523191997023, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h225_SEQUENCE_OF_IntegrityMechanism ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence_of ( tvb , offset , actx , tree , hf_index , ett_h225_SEQUENCE_OF_IntegrityMechanism , SEQUENCE_OF_IntegrityMechanism_sequence_of ) ;\n return offset ;\n }", "idx": 20572}
{"hash": -4558261210024070448, "project": "chrome", "size": 7, "label": 1, "functionSource": "void * xmlListReverseSearch ( xmlListPtr l , void * data ) {\n xmlLinkPtr lk ;\n if ( l == NULL ) return ( NULL ) ;\n lk = xmlListLinkReverseSearch ( l , data ) ;\n if ( lk ) return ( lk -> data ) ;\n return NULL ;\n }", "idx": 20573}
{"hash": 8320716512483418415, "project": "chrome", "size": 16, "label": 0, "functionSource": "void vp9_idct4x4_1_add_c ( const tran_low_t * input , uint8_t * dest , int dest_stride ) {\n int i ;\n tran_high_t a1 ;\n tran_low_t out = dct_const_round_shift ( input [ 0 ] * cospi_16_64 ) ;\n out = dct_const_round_shift ( out * cospi_16_64 ) ;\n a1 = ROUND_POWER_OF_TWO ( out , 4 ) ;\n for ( i = 0 ;\n i < 4 ;\n i ++ ) {\n dest [ 0 ] = clip_pixel ( dest [ 0 ] + a1 ) ;\n dest [ 1 ] = clip_pixel ( dest [ 1 ] + a1 ) ;\n dest [ 2 ] = clip_pixel ( dest [ 2 ] + a1 ) ;\n dest [ 3 ] = clip_pixel ( dest [ 3 ] + a1 ) ;\n dest += dest_stride ;\n }\n }", "idx": 20574}
{"hash": 6790518433053241091, "project": "debian", "size": 24, "label": 0, "functionSource": "static void gtkui_connection_list_row ( int top , struct row_pairs * pair ) {\n GtkTreeIter iter ;\n GtkTreePath * path = NULL ;\n GtkTreeModel * model = NULL ;\n GdkRectangle rect ;\n int wx = 0 , wy = 0 ;\n void * row = NULL ;\n if ( ! ls_conns || ! pair ) return ;\n pair -> conn = NULL ;\n model = GTK_TREE_MODEL ( ls_conns ) ;\n if ( gtk_tree_model_get_iter_first ( model , & iter ) ) {\n gtk_tree_view_get_visible_rect ( GTK_TREE_VIEW ( treeview ) , & rect ) ;\n gtk_tree_view_convert_bin_window_to_widget_coords ( GTK_TREE_VIEW ( treeview ) , rect . x , ( top ) ? rect . y : rect . height , & wx , & wy ) ;\n path = gtk_tree_path_new ( ) ;\n if ( gtk_tree_view_get_path_at_pos ( GTK_TREE_VIEW ( treeview ) , wx + 2 , ( top ) ? wy + 2 : wy - 2 , & path , NULL , NULL , NULL ) ) {\n gtk_tree_model_get_iter ( model , & iter , path ) ;\n gtk_tree_model_get ( model , & iter , 11 , & row , - 1 ) ;\n pair -> iter = iter ;\n pair -> conn = row ;\n }\n if ( path ) gtk_tree_path_free ( path ) ;\n }\n return ;\n }", "idx": 20575}
{"hash": -8199454075838226273, "project": "debian", "size": 127, "label": 0, "functionSource": "static void dissect_rtmpt ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , rtmpt_conv_t * rconv , int cdir , rtmpt_packet_t * tp ) {\n gint offset = 0 ;\n gchar * sDesc = NULL ;\n gint deschasopcode = FALSE ;\n gboolean haveETS = FALSE ;\n guint32 iBodyOffset = 0 ;\n guint32 iBodyRemain = 0 ;\n col_set_str ( pinfo -> cinfo , COL_PROTOCOL , \"RTMP\" ) ;\n RTMPT_DEBUG ( \"Dissect: frame=%u visited=%d len=%d tree=%p\\n\" , pinfo -> num , pinfo -> fd -> flags . visited , tvb_reported_length_remaining ( tvb , offset ) , tree ) ;\n col_clear ( pinfo -> cinfo , COL_INFO ) ;\n if ( tvb_reported_length_remaining ( tvb , offset ) < 1 ) return ;\n if ( tp -> id <= RTMPT_ID_MAX ) {\n if ( tp -> fmt < 3 && tvb_reported_length_remaining ( tvb , offset ) >= tp -> bhlen + 3 && tvb_get_ntoh24 ( tvb , offset + tp -> bhlen ) == 0xffffff ) {\n haveETS = TRUE ;\n }\n iBodyOffset = offset + tp -> bhlen + tp -> mhlen ;\n iBodyRemain = tvb_reported_length_remaining ( tvb , iBodyOffset ) ;\n if ( tp -> cmd == RTMPT_TYPE_CHUNK_SIZE && tp -> len >= 4 && iBodyRemain >= 4 ) {\n guint32 newchunksize = tvb_get_ntohl ( tvb , iBodyOffset ) ;\n if ( newchunksize < rtmpt_max_packet_size ) {\n wmem_tree_insert32 ( rconv -> chunksize [ cdir ] , tp -> lastseq , GINT_TO_POINTER ( newchunksize ) ) ;\n }\n }\n if ( ! PINFO_FD_VISITED ( pinfo ) ) {\n if ( tp -> cmd == RTMPT_TYPE_COMMAND_AMF0 || tp -> cmd == RTMPT_TYPE_COMMAND_AMF3 || tp -> cmd == RTMPT_TYPE_DATA_AMF0 || tp -> cmd == RTMPT_TYPE_DATA_AMF3 ) {\n guint32 soff = 0 ;\n if ( tp -> cmd == RTMPT_TYPE_COMMAND_AMF3 || tp -> cmd == RTMPT_TYPE_DATA_AMF3 ) {\n soff = 1 ;\n }\n tp -> txid = rtmpt_get_amf_txid ( tvb , iBodyOffset + soff ) ;\n if ( tp -> txid != 0 ) {\n RTMPT_DEBUG ( \"got txid=%d\\n\" , tp -> txid ) ;\n wmem_tree_insert32 ( rconv -> txids [ cdir ] , tp -> txid , GINT_TO_POINTER ( pinfo -> num ) ) ;\n }\n }\n }\n }\n if ( tp -> id <= RTMPT_ID_MAX ) {\n sDesc = rtmpt_get_packet_desc ( tvb , iBodyOffset , iBodyRemain , rconv , cdir , tp , & deschasopcode ) ;\n }\n if ( tp -> id > RTMPT_ID_MAX ) {\n col_append_sep_fstr ( pinfo -> cinfo , COL_INFO , \"|\" , \"%s\" , val_to_str ( tp -> id , rtmpt_handshake_vals , \"Unknown (0x%01x)\" ) ) ;\n col_set_fence ( pinfo -> cinfo , COL_INFO ) ;\n }\n else if ( sDesc ) {\n col_append_sep_fstr ( pinfo -> cinfo , COL_INFO , \"|\" , \"%s\" , sDesc ) ;\n col_set_fence ( pinfo -> cinfo , COL_INFO ) ;\n }\n else {\n col_append_sep_fstr ( pinfo -> cinfo , COL_INFO , \"|\" , \"%s\" , val_to_str ( tp -> cmd , rtmpt_opcode_vals , \"Unknown (0x%01x)\" ) ) ;\n col_set_fence ( pinfo -> cinfo , COL_INFO ) ;\n }\n if ( tree ) {\n proto_tree * rtmpt_tree = NULL ;\n proto_tree * rtmptroot_tree = NULL ;\n proto_item * ti ;\n ti = proto_tree_add_item ( tree , proto_rtmpt , tvb , offset , - 1 , ENC_NA ) ;\n if ( tp -> id > RTMPT_ID_MAX ) {\n proto_item_append_text ( ti , \" (%s)\" , val_to_str ( tp -> id , rtmpt_handshake_vals , \"Unknown (0x%01x)\" ) ) ;\n rtmptroot_tree = proto_item_add_subtree ( ti , ett_rtmpt ) ;\n rtmpt_tree = proto_tree_add_subtree ( rtmptroot_tree , tvb , offset , - 1 , ett_rtmpt_handshake , NULL , val_to_str ( tp -> id , rtmpt_handshake_vals , \"Unknown (0x%01x)\" ) ) ;\n if ( tp -> id == RTMPT_TYPE_HANDSHAKE_1 ) {\n proto_tree_add_item ( rtmpt_tree , hf_rtmpt_handshake_c0 , tvb , 0 , 1 , ENC_NA ) ;\n proto_tree_add_item ( rtmpt_tree , hf_rtmpt_handshake_c1 , tvb , 1 , 1536 , ENC_NA ) ;\n }\n else if ( tp -> id == RTMPT_TYPE_HANDSHAKE_2 ) {\n proto_tree_add_item ( rtmpt_tree , hf_rtmpt_handshake_s0 , tvb , 0 , 1 , ENC_NA ) ;\n proto_tree_add_item ( rtmpt_tree , hf_rtmpt_handshake_s1 , tvb , 1 , 1536 , ENC_NA ) ;\n proto_tree_add_item ( rtmpt_tree , hf_rtmpt_handshake_s2 , tvb , 1537 , 1536 , ENC_NA ) ;\n }\n else if ( tp -> id == RTMPT_TYPE_HANDSHAKE_3 ) {\n proto_tree_add_item ( rtmpt_tree , hf_rtmpt_handshake_c2 , tvb , 0 , 1536 , ENC_NA ) ;\n }\n return ;\n }\n if ( sDesc && deschasopcode ) {\n proto_item_append_text ( ti , \" (%s)\" , sDesc ) ;\n }\n else if ( sDesc ) {\n proto_item_append_text ( ti , \" (%s %s)\" , val_to_str ( tp -> cmd , rtmpt_opcode_vals , \"Unknown (0x%01x)\" ) , sDesc ) ;\n }\n else {\n proto_item_append_text ( ti , \" (%s)\" , val_to_str ( tp -> cmd , rtmpt_opcode_vals , \"Unknown (0x%01x)\" ) ) ;\n }\n rtmptroot_tree = proto_item_add_subtree ( ti , ett_rtmpt ) ;\n if ( tp -> otherframe != 0 ) {\n proto_tree_add_uint ( rtmptroot_tree , tp -> isresponse ? hf_rtmpt_function_response : hf_rtmpt_function_call , tvb , offset , tp -> bhlen + tp -> mhlen + tp -> len , tp -> otherframe ) ;\n }\n rtmpt_tree = proto_tree_add_subtree ( rtmptroot_tree , tvb , offset , tp -> bhlen + tp -> mhlen , ett_rtmpt_header , NULL , RTMPT_TEXT_RTMP_HEADER ) ;\n if ( tp -> fmt <= 3 ) proto_tree_add_item ( rtmpt_tree , hf_rtmpt_header_format , tvb , offset + 0 , 1 , ENC_BIG_ENDIAN ) ;\n if ( tp -> fmt <= 3 ) proto_tree_add_item ( rtmpt_tree , hf_rtmpt_header_csid , tvb , offset + 0 , tp -> bhlen , ENC_BIG_ENDIAN ) ;\n if ( tp -> fmt <= 2 ) {\n if ( tp -> fmt > 0 ) {\n proto_tree_add_item ( rtmpt_tree , hf_rtmpt_header_timestamp_delta , tvb , offset + tp -> bhlen , 3 , ENC_BIG_ENDIAN ) ;\n }\n else {\n proto_tree_add_item ( rtmpt_tree , hf_rtmpt_header_timestamp , tvb , offset + tp -> bhlen , 3 , ENC_BIG_ENDIAN ) ;\n }\n if ( haveETS ) {\n proto_tree_add_item ( rtmpt_tree , hf_rtmpt_header_ets , tvb , offset + tp -> bhlen + tp -> mhlen - 4 , 4 , ENC_BIG_ENDIAN ) ;\n }\n }\n if ( ( tp -> fmt > 0 && ! haveETS ) || tp -> fmt == 3 ) {\n proto_tree_add_uint_format_value ( rtmpt_tree , hf_rtmpt_header_timestamp , tvb , offset + tp -> bhlen , 0 , tp -> ts , \"%d (calculated)\" , tp -> ts ) ;\n }\n if ( tp -> fmt <= 1 ) proto_tree_add_item ( rtmpt_tree , hf_rtmpt_header_body_size , tvb , offset + tp -> bhlen + 3 , 3 , ENC_BIG_ENDIAN ) ;\n if ( tp -> fmt <= 1 ) proto_tree_add_item ( rtmpt_tree , hf_rtmpt_header_typeid , tvb , offset + tp -> bhlen + 6 , 1 , ENC_BIG_ENDIAN ) ;\n if ( tp -> fmt <= 0 ) proto_tree_add_item ( rtmpt_tree , hf_rtmpt_header_streamid , tvb , offset + tp -> bhlen + 7 , 4 , ENC_LITTLE_ENDIAN ) ;\n if ( tp -> len == 0 ) return ;\n offset = iBodyOffset ;\n rtmpt_tree = proto_tree_add_subtree ( rtmptroot_tree , tvb , offset , - 1 , ett_rtmpt_body , NULL , RTMPT_TEXT_RTMP_BODY ) ;\n switch ( tp -> cmd ) {\n case RTMPT_TYPE_CHUNK_SIZE : case RTMPT_TYPE_ABORT_MESSAGE : case RTMPT_TYPE_ACKNOWLEDGEMENT : case RTMPT_TYPE_UCM : case RTMPT_TYPE_WINDOW : case RTMPT_TYPE_PEER_BANDWIDTH : dissect_rtmpt_body_scm ( tvb , offset , rtmpt_tree , tp -> cmd ) ;\n break ;\n case RTMPT_TYPE_COMMAND_AMF0 : case RTMPT_TYPE_DATA_AMF0 : dissect_rtmpt_body_command ( tvb , offset , rtmpt_tree , FALSE ) ;\n break ;\n case RTMPT_TYPE_COMMAND_AMF3 : case RTMPT_TYPE_DATA_AMF3 : dissect_rtmpt_body_command ( tvb , offset , rtmpt_tree , TRUE ) ;\n break ;\n case RTMPT_TYPE_AUDIO_DATA : dissect_rtmpt_body_audio ( tvb , offset , rtmpt_tree ) ;\n break ;\n case RTMPT_TYPE_VIDEO_DATA : dissect_rtmpt_body_video ( tvb , offset , rtmpt_tree ) ;\n break ;\n case RTMPT_TYPE_AGGREGATE : dissect_rtmpt_body_aggregate ( tvb , offset , rtmpt_tree ) ;\n break ;\n }\n }\n }", "idx": 20576}
{"hash": -1315695702746584250, "project": "debian", "size": 5, "label": 0, "functionSource": "static int protoo_strlcpy ( gchar * dest , const gchar * src , gsize dest_size ) {\n gsize res = g_strlcpy ( dest , src , dest_size ) ;\n if ( res > dest_size ) res = dest_size ;\n return ( int ) res ;\n }", "idx": 20577}
{"hash": 4839943401171415484, "project": "chrome", "size": 33, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_P ( BrowserCloseManagerBrowserTest , TestMultipleWindows ) {\n browsers_ . push_back ( CreateBrowser ( browser ( ) -> profile ( ) ) ) ;\n ASSERT_NO_FATAL_FAILURE ( ui_test_utils : : NavigateToURL ( browsers_ [ 0 ] , embedded_test_server ( ) -> GetURL ( \"/beforeunload.html\" ) ) ) ;\n ASSERT_NO_FATAL_FAILURE ( ui_test_utils : : NavigateToURL ( browsers_ [ 1 ] , embedded_test_server ( ) -> GetURL ( \"/beforeunload.html\" ) ) ) ;\n PrepareForDialog ( browsers_ [ 0 ] ) ;\n PrepareForDialog ( browsers_ [ 1 ] ) ;\n {\n RepeatedNotificationObserver cancel_observer ( chrome : : NOTIFICATION_BROWSER_CLOSE_CANCELLED , 1 ) ;\n chrome : : CloseAllBrowsersAndQuit ( ) ;\n ASSERT_NO_FATAL_FAILURE ( CancelClose ( ) ) ;\n cancel_observer . Wait ( ) ;\n }\n EXPECT_FALSE ( browser_shutdown : : IsTryingToQuit ( ) ) ;\n EXPECT_EQ ( 1 , browsers_ [ 0 ] -> tab_strip_model ( ) -> count ( ) ) ;\n EXPECT_EQ ( 1 , browsers_ [ 1 ] -> tab_strip_model ( ) -> count ( ) ) ;\n {\n RepeatedNotificationObserver cancel_observer ( chrome : : NOTIFICATION_BROWSER_CLOSE_CANCELLED , 2 ) ;\n chrome : : CloseAllBrowsersAndQuit ( ) ;\n ASSERT_NO_FATAL_FAILURE ( AcceptClose ( ) ) ;\n ASSERT_NO_FATAL_FAILURE ( CancelClose ( ) ) ;\n cancel_observer . Wait ( ) ;\n }\n EXPECT_FALSE ( browser_shutdown : : IsTryingToQuit ( ) ) ;\n EXPECT_EQ ( 1 , browsers_ [ 0 ] -> tab_strip_model ( ) -> count ( ) ) ;\n EXPECT_EQ ( 1 , browsers_ [ 1 ] -> tab_strip_model ( ) -> count ( ) ) ;\n RepeatedNotificationObserver close_observer ( chrome : : NOTIFICATION_BROWSER_CLOSED , 2 ) ;\n chrome : : CloseAllBrowsersAndQuit ( ) ;\n ASSERT_NO_FATAL_FAILURE ( AcceptClose ( ) ) ;\n ASSERT_NO_FATAL_FAILURE ( AcceptClose ( ) ) ;\n close_observer . Wait ( ) ;\n EXPECT_TRUE ( browser_shutdown : : IsTryingToQuit ( ) ) ;\n EXPECT_TRUE ( BrowserList : : GetInstance ( ) -> empty ( ) ) ;\n }", "idx": 20578}
{"hash": 7039307292471244756, "project": "debian", "size": 4, "label": 0, "functionSource": "static guint16 de_signal ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len _U_ , gchar * add_string _U_ , int string_len _U_ ) {\n proto_tree_add_item ( tree , hf_gsm_a_dtap_signal_value , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n return 1 ;\n }", "idx": 20579}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_RequestChannelCloseRejectCause ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_RequestChannelCloseRejectCause , RequestChannelCloseRejectCause_choice , NULL ) ;\n return offset ;\n }", "idx": 20580}
{"hash": 355220887711506893, "project": "debian", "size": 3, "label": 0, "functionSource": "Datum icregexeqsel ( PG_FUNCTION_ARGS ) {\n PG_RETURN_FLOAT8 ( patternsel ( fcinfo , Pattern_Type_Regex_IC , false ) ) ;\n }", "idx": 20581}
{"hash": 378220832151730865, "project": "debian", "size": 55, "label": 0, "functionSource": "int qemuMonitorTextGetBlockInfo ( qemuMonitorPtr mon , const char * devname , struct qemuDomainDiskInfo * info ) {\n char * reply = NULL ;\n int ret = - 1 ;\n char * dummy ;\n const char * p , * eol ;\n int devnamelen = strlen ( devname ) ;\n int tmp ;\n if ( qemuMonitorHMPCommand ( mon , \"info block\" , & reply ) < 0 ) {\n qemuReportError ( VIR_ERR_OPERATION_FAILED , \"%s\" , _ ( \"info block command failed\" ) ) ;\n goto cleanup ;\n }\n if ( strstr ( reply , \"\\ninfo \" ) ) {\n qemuReportError ( VIR_ERR_OPERATION_INVALID , \"%s\" , _ ( \"info block not supported by this qemu\" ) ) ;\n goto cleanup ;\n }\n p = reply ;\n while ( * p ) {\n if ( STRPREFIX ( p , QEMU_DRIVE_HOST_PREFIX ) ) p += strlen ( QEMU_DRIVE_HOST_PREFIX ) ;\n if ( STREQLEN ( p , devname , devnamelen ) && p [ devnamelen ] == ':' && p [ devnamelen + 1 ] == ' ' ) {\n eol = strchr ( p , '\\n' ) ;\n if ( ! eol ) eol = p + strlen ( p ) ;\n p += devnamelen + 2 ;\n while ( * p ) {\n if ( STRPREFIX ( p , \"removable=\" ) ) {\n p += strlen ( \"removable=\" ) ;\n if ( virStrToLong_i ( p , & dummy , 10 , & tmp ) == - 1 ) VIR_DEBUG ( \"error reading removable: %s\" , p ) ;\n else info -> removable = ( tmp != 0 ) ;\n }\n else if ( STRPREFIX ( p , \"locked=\" ) ) {\n p += strlen ( \"locked=\" ) ;\n if ( virStrToLong_i ( p , & dummy , 10 , & tmp ) == - 1 ) VIR_DEBUG ( \"error reading locked: %s\" , p ) ;\n else info -> locked = ( tmp != 0 ) ;\n }\n else if ( STRPREFIX ( p , \"tray_open=\" ) ) {\n p += strlen ( \"tray_open=\" ) ;\n if ( virStrToLong_i ( p , & dummy , 10 , & tmp ) == - 1 ) VIR_DEBUG ( \"error reading tray_open: %s\" , p ) ;\n else info -> tray_open = ( tmp != 0 ) ;\n }\n else {\n }\n p = strchr ( p , ' ' ) ;\n if ( ! p || p >= eol ) break ;\n p ++ ;\n }\n ret = 0 ;\n goto cleanup ;\n }\n p = strchr ( p , '\\n' ) ;\n if ( ! p ) break ;\n p ++ ;\n }\n qemuReportError ( VIR_ERR_INVALID_ARG , _ ( \"no info for device '%s'\" ) , devname ) ;\n cleanup : VIR_FREE ( reply ) ;\n return ret ;\n }", "idx": 20582}
{"hash": -5082285935423529157, "project": "debian", "size": 500, "label": 0, "functionSource": "void proto_register_rsl ( void ) {\n static hf_register_info hf [ ] = {\n {\n & hf_rsl_msg_dsc , {\n \"Message discriminator\" , \"gsm_abis_rsl.msg_dsc\" , FT_UINT8 , BASE_DEC , VALS ( rsl_msg_disc_vals ) , 0xfe , NULL , HFILL }\n }\n , {\n & hf_rsl_T_bit , {\n \"T bit\" , \"gsm_abis_rsl.T_bit\" , FT_BOOLEAN , 8 , TFS ( & rsl_t_bit_vals ) , 0x01 , NULL , HFILL }\n }\n , {\n & hf_rsl_msg_type , {\n \"Message type\" , \"gsm_abis_rsl.msg_type\" , FT_UINT8 , BASE_HEX_DEC | BASE_EXT_STRING , & rsl_msg_type_vals_ext , 0x7f , NULL , HFILL }\n }\n , {\n & hf_rsl_ie_id , {\n \"Element identifier\" , \"gsm_abis_rsl.ie_id\" , FT_UINT8 , BASE_HEX_DEC | BASE_EXT_STRING , & rsl_ie_type_vals_ext , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_ie_length , {\n \"Length\" , \"gsm_abis_rsl.ie_length\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_ch_no_Cbits , {\n \"C-bits\" , \"gsm_abis_rsl.ch_no_Cbits\" , FT_UINT8 , BASE_DEC | BASE_EXT_STRING , & rsl_ch_no_Cbits_vals_ext , 0xf8 , NULL , HFILL }\n }\n , {\n & hf_rsl_ch_no_TN , {\n \"Time slot number (TN)\" , \"gsm_abis_rsl.ch_no_TN\" , FT_UINT8 , BASE_DEC , NULL , 0x07 , NULL , HFILL }\n }\n , {\n & hf_rsl_rtd , {\n \"Round Trip Delay (RTD)\" , \"gsm_abis_rsl.rtd\" , FT_UINT8 , BASE_DEC , NULL , 0xfe , NULL , HFILL }\n }\n , {\n & hf_rsl_delay_ind , {\n \"Delay IND\" , \"gsm_abis_rsl.delay_ind\" , FT_UINT8 , BASE_DEC , VALS ( rsl_delay_ind_vals ) , 0x01 , NULL , HFILL }\n }\n , {\n & hf_rsl_tfo , {\n \"TFO\" , \"gsm_abis_rsl.tfo\" , FT_BOOLEAN , 8 , TFS ( & rsl_tfo_vals ) , 0x01 , NULL , HFILL }\n }\n , {\n & hf_rsl_req_ref_ra , {\n \"Random Access Information (RA)\" , \"gsm_abis_rsl.req_ref_ra\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_req_ref_T1prim , {\n \"T1'\" , \"gsm_abis_rsl.req_ref_T1prim\" , FT_UINT8 , BASE_DEC , NULL , 0xf8 , NULL , HFILL }\n }\n , {\n & hf_rsl_req_ref_T3 , {\n \"T3\" , \"gsm_abis_rsl.req_ref_T3\" , FT_UINT16 , BASE_DEC , NULL , 0x07e0 , NULL , HFILL }\n }\n , {\n & hf_rsl_req_ref_T2 , {\n \"T2\" , \"gsm_abis_rsl.req_ref_T2\" , FT_UINT8 , BASE_DEC , NULL , 0x1f , NULL , HFILL }\n }\n , {\n & hf_rsl_timing_adv , {\n \"Timing Advance\" , \"gsm_abis_rsl.timing_adv\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_ho_ref , {\n \"Hand-over reference\" , \"gsm_abis_rsl.ho_ref\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_l1inf_power_lev , {\n \"MS power level\" , \"gsm_abis_rsl.ms_power_lev\" , FT_UINT8 , BASE_DEC , NULL , 0xf8 , NULL , HFILL }\n }\n , {\n & hf_rsl_l1inf_fpc , {\n \"FPC/EPC\" , \"gsm_abis_rsl.ms_fpc\" , FT_BOOLEAN , 8 , TFS ( & rsl_ms_fpc_epc_mode_vals ) , 0x04 , NULL , HFILL }\n }\n , {\n & hf_rsl_ms_power_lev , {\n \"MS power level\" , \"gsm_abis_rsl.ms_power_lev\" , FT_UINT8 , BASE_DEC , NULL , 0x1f , NULL , HFILL }\n }\n , {\n & hf_rsl_ms_fpc , {\n \"FPC/EPC\" , \"gsm_abis_rsl.ms_fpc\" , FT_BOOLEAN , 8 , TFS ( & rsl_ms_fpc_epc_mode_vals ) , 0x20 , NULL , HFILL }\n }\n , {\n & hf_rsl_act_timing_adv , {\n \"Actual Timing Advance\" , \"gsm_abis_rsl.act_timing_adv\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_dtxd , {\n \"DTXd\" , \"gsm_abis_rsl.dtxd\" , FT_BOOLEAN , 8 , TFS ( & rsl_dtxd_vals ) , 0x40 , NULL , HFILL }\n }\n , {\n & hf_rsl_rxlev_full_up , {\n \"RXLEV.FULL.up\" , \"gsm_abis_rsl.rxlev_full_up\" , FT_UINT8 , BASE_DEC , NULL , 0x3f , NULL , HFILL }\n }\n , {\n & hf_rsl_rxlev_sub_up , {\n \"RXLEV.SUB.up\" , \"gsm_abis_rsl.rxlev_sub_up\" , FT_UINT8 , BASE_DEC , NULL , 0x3f , NULL , HFILL }\n }\n , {\n & hf_rsl_rxqual_full_up , {\n \"RXQUAL.FULL.up\" , \"gsm_abis_rsl.rxqual_full_up\" , FT_UINT8 , BASE_DEC , NULL , 0x38 , NULL , HFILL }\n }\n , {\n & hf_rsl_rxqual_sub_up , {\n \"RXQUAL.SUB.up\" , \"gsm_abis_rsl.rxqual_sub_up\" , FT_UINT8 , BASE_DEC , NULL , 0x07 , NULL , HFILL }\n }\n , {\n & hf_rsl_acc_delay , {\n \"Access Delay\" , \"gsm_abis_rsl.acc_del\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_rach_slot_cnt , {\n \"RACH Slot Count\" , \"gsm_abis_rsl.rach_slot_cnt\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_rach_busy_cnt , {\n \"RACH Busy Count\" , \"gsm_abis_rsl.rach_busy_cnt\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_rach_acc_cnt , {\n \"RACH Access Count\" , \"gsm_abis_rsl.rach_acc_cnt\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_phy_ctx , {\n \"Physical Context\" , \"gsm_abis_rsl.phy_ctx\" , FT_BYTES , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_na , {\n \"Not applicable (NA)\" , \"gsm_abis_rsl.na\" , FT_BOOLEAN , 8 , TFS ( & rsl_na_vals ) , 0x20 , NULL , HFILL }\n }\n , {\n & hf_rsl_ch_type , {\n \"channel type\" , \"gsm_abis_rsl.ch_type\" , FT_UINT8 , BASE_DEC , VALS ( rsl_ch_type_vals ) , 0xc0 , NULL , HFILL }\n }\n , {\n & hf_rsl_prio , {\n \"Priority\" , \"gsm_abis_rsl.prio\" , FT_UINT8 , BASE_DEC , VALS ( rsl_prio_vals ) , 0x18 , NULL , HFILL }\n }\n , {\n & hf_rsl_sapi , {\n \"SAPI\" , \"gsm_abis_rsl.sapi\" , FT_UINT8 , BASE_DEC , NULL , 0x07 , NULL , HFILL }\n }\n , {\n & hf_rsl_rbit , {\n \"R\" , \"gsm_abis_rsl.rbit\" , FT_BOOLEAN , 8 , TFS ( & rsl_rbit_vals ) , 0x80 , NULL , HFILL }\n }\n , {\n & hf_rsl_a3a2 , {\n \"A3A2\" , \"gsm_abis_rsl.a3a2\" , FT_UINT8 , BASE_DEC , VALS ( rsl_a3a2_vals ) , 0x06 , NULL , HFILL }\n }\n , {\n & hf_rsl_a1_0 , {\n \"A1\" , \"gsm_abis_rsl.a1_0\" , FT_BOOLEAN , 8 , TFS ( & rsl_a1_0_vals ) , 0x01 , NULL , HFILL }\n }\n , {\n & hf_rsl_a1_1 , {\n \"A1\" , \"gsm_abis_rsl.a1_1\" , FT_BOOLEAN , 8 , TFS ( & rsl_a1_1_vals ) , 0x01 , NULL , HFILL }\n }\n , {\n & hf_rsl_a1_2 , {\n \"A1\" , \"gsm_abis_rsl.a2_0\" , FT_BOOLEAN , 8 , TFS ( & rsl_a1_2_vals ) , 0x01 , NULL , HFILL }\n }\n , {\n & hf_rsl_epc_mode , {\n \"EPC mode\" , \"gsm_abis_rsl.epc_mode\" , FT_BOOLEAN , 8 , TFS ( & rsl_epc_mode_vals ) , 0x20 , NULL , HFILL }\n }\n , {\n & hf_rsl_bs_fpc_epc_mode , {\n \"FPC-EPC mode\" , \"gsm_abis_rsl.fpc_epc_mode\" , FT_BOOLEAN , 8 , TFS ( & rsl_fpc_epc_mode_vals ) , 0x10 , NULL , HFILL }\n }\n , {\n & hf_rsl_bs_power , {\n \"Power Level\" , \"gsm_abis_rsl.bs_power\" , FT_UINT8 , BASE_DEC | BASE_EXT_STRING , & rsl_rlm_bs_power_vals_ext , 0x0f , NULL , HFILL }\n }\n , {\n & hf_rsl_cm_dtxd , {\n \"DTXd\" , \"gsm_abis_rsl.cm_dtxd\" , FT_BOOLEAN , 8 , TFS ( & rsl_dtx_vals ) , 0x02 , NULL , HFILL }\n }\n , {\n & hf_rsl_cm_dtxu , {\n \"DTXu\" , \"gsm_abis_rsl.cm_dtxu\" , FT_BOOLEAN , 8 , TFS ( & rsl_dtx_vals ) , 0x01 , NULL , HFILL }\n }\n , {\n & hf_rsl_speech_or_data , {\n \"Speech or data indicator\" , \"gsm_abis_rsl.speech_or_data\" , FT_UINT8 , BASE_DEC , VALS ( rsl_speech_or_data_vals ) , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_ch_rate_and_type , {\n \"Channel rate and type\" , \"gsm_abis_rsl.ch_rate_and_type\" , FT_UINT8 , BASE_DEC | BASE_EXT_STRING , & rsl_ch_rate_and_type_vals_ext , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_speech_coding_alg , {\n \"Speech coding algorithm\" , \"gsm_abis_rsl.speech_coding_alg\" , FT_UINT8 , BASE_DEC , VALS ( rsl_speech_coding_alg_vals ) , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_t_nt_bit , {\n \"Transparent indication\" , \"gsm_abis_rsl.t_nt_bit\" , FT_BOOLEAN , 8 , TFS ( & t_nt_bit_vals ) , 0x40 , NULL , HFILL }\n }\n , {\n & hf_rsl_ra_if_data_rte , {\n \"Radio interface data rate\" , \"gsm_abis_rsl.ra_if_data_rte\" , FT_UINT8 , BASE_DEC , VALS ( rsl_ra_if_data_rte_vals ) , 0x3f , NULL , HFILL }\n }\n , {\n & hf_rsl_data_rte , {\n \"Data rate\" , \"gsm_abis_rsl.data_rte\" , FT_UINT8 , BASE_DEC , VALS ( rsl_ra_if_data_rte_vals ) , 0x3f , NULL , HFILL }\n }\n , {\n & hf_rsl_alg_id , {\n \"Algorithm Identifier\" , \"gsm_abis_rsl.alg_id\" , FT_UINT8 , BASE_DEC , VALS ( rsl_algorithm_id_vals ) , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_key , {\n \"KEY\" , \"gsm_abis_rsl.key\" , FT_BYTES , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_cause , {\n \"Cause\" , \"gsm_abis_rsl.cause\" , FT_UINT8 , BASE_DEC | BASE_EXT_STRING , & rsl_rlm_cause_vals_ext , 0x7f , NULL , HFILL }\n }\n , {\n & hf_rsl_rel_mode , {\n \"Release Mode\" , \"gsm_abis_rsl.rel_mode\" , FT_UINT8 , BASE_DEC , VALS ( rel_mode_vals ) , 0x01 , NULL , HFILL }\n }\n , {\n & hf_rsl_interf_band , {\n \"Interf Band\" , \"gsm_abis_rsl.interf_band\" , FT_UINT8 , BASE_DEC , NULL , 0xe0 , NULL , HFILL }\n }\n , {\n & hf_rsl_interf_band_reserved , {\n \"Interf Band reserved bits\" , \"gsm_abis_rsl.interf_band_reserved\" , FT_UINT8 , BASE_DEC , NULL , 0x1f , NULL , HFILL }\n }\n , {\n & hf_rsl_meas_res_no , {\n \"Measurement result number\" , \"gsm_abis_rsl.meas_res_no\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_extension_bit , {\n \"Extension\" , \"gsm_abis_rsl.extension_bit\" , FT_BOOLEAN , 8 , TFS ( & rsl_extension_bit_value ) , 0x80 , NULL , HFILL }\n }\n , {\n & hf_rsl_class , {\n \"Class\" , \"gsm_abis_rsl.class\" , FT_UINT8 , BASE_DEC , VALS ( rsl_class_vals ) , 0x70 , NULL , HFILL }\n }\n , {\n & hf_rsl_paging_grp , {\n \"Paging Group\" , \"gsm_abis_rsl.paging_grp\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_paging_load , {\n \"Paging Buffer Space\" , \"gsm_abis_rsl.paging_load\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_sys_info_type , {\n \"System Info Type\" , \"gsm_abis_rsl.sys_info_type\" , FT_UINT8 , BASE_DEC | BASE_EXT_STRING , & rsl_sys_info_type_vals_ext , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_timing_offset , {\n \"Timing Offset\" , \"gsm_abis_rsl.timing_offset\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_ch_needed , {\n \"Channel Needed\" , \"gsm_abis_rsl.ch_needed\" , FT_UINT8 , BASE_DEC , VALS ( rsl_ch_needed_vals ) , 0x03 , NULL , HFILL }\n }\n , {\n & hf_rsl_cbch_load_type , {\n \"CBCH Load Type\" , \"gsm_abis_rsl.cbch_load_type\" , FT_BOOLEAN , 8 , TFS ( & rsl_cbch_load_type_vals ) , 0x80 , NULL , HFILL }\n }\n , {\n & hf_rsl_msg_slt_cnt , {\n \"Message Slot Count\" , \"gsm_abis_rsl.sg_slt_cnt\" , FT_UINT8 , BASE_DEC , NULL , 0x0f , NULL , HFILL }\n }\n , {\n & hf_rsl_ch_ind , {\n \"Channel Ind\" , \"gsm_abis_rsl.ch_ind\" , FT_UINT8 , BASE_DEC , VALS ( rsl_ch_ind_vals ) , 0x0f , NULL , HFILL }\n }\n , {\n & hf_rsl_command , {\n \"Command\" , \"gsm_abis_rsl.cmd\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_emlpp_prio , {\n \"eMLPP Priority\" , \"gsm_abis_rsl.emlpp_prio\" , FT_UINT8 , BASE_DEC , VALS ( rsl_emlpp_prio_vals ) , 0x03 , NULL , HFILL }\n }\n , {\n & hf_rsl_speech_mode_s , {\n \"ip.access Speech Mode S\" , \"gsm_abis_rsl.ipacc.speech_mode_s\" , FT_UINT8 , BASE_HEX , VALS ( rsl_ipacc_spm_s_vals ) , 0xf , NULL , HFILL }\n }\n , {\n & hf_rsl_speech_mode_m , {\n \"ip.access Speech Mode M\" , \"gsm_abis_rsl.ipacc.speech_mode_m\" , FT_UINT8 , BASE_HEX , VALS ( rsl_ipacc_spm_m_vals ) , 0xf0 , NULL , HFILL }\n }\n , {\n & hf_rsl_conn_id , {\n \"ip.access Connection ID\" , \"gsm_abis_rsl.ipacc.conn_id\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_rtp_payload , {\n \"ip.access RTP Payload Type\" , \"gsm_abis_rsl.ipacc.rtp_payload\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_rtp_csd_fmt_d , {\n \"ip.access RTP CSD Format D\" , \"gsm_abis_rsl.ipacc.rtp_csd_fmt_d\" , FT_UINT8 , BASE_HEX , VALS ( rsl_ipacc_rtp_csd_fmt_d_vals ) , 0x0f , NULL , HFILL }\n , }\n , {\n & hf_rsl_rtp_csd_fmt_ir , {\n \"ip.access RTP CSD Format IR\" , \"gsm_abis_rsl.ipacc.rtp_csd_fmt_ir\" , FT_UINT8 , BASE_HEX , VALS ( rsl_ipacc_rtp_csd_fmt_ir_vals ) , 0xf0 , NULL , HFILL }\n , }\n , {\n & hf_rsl_local_port , {\n \"ip.access Local RTP Port\" , \"gsm_abis_rsl.ipacc.local_port\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n , }\n , {\n & hf_rsl_remote_port , {\n \"ip.access Remote RTP Port\" , \"gsm_abis_rsl.ipacc.remote_port\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n , }\n , {\n & hf_rsl_local_ip , {\n \"ip.access Local IP Address\" , \"gsm_abis_rsl.ipacc.local_ip\" , FT_IPv4 , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n , }\n , {\n & hf_rsl_remote_ip , {\n \"ip.access Remote IP Address\" , \"gsm_abis_rsl.ipacc.remote_ip\" , FT_IPv4 , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n , }\n , {\n & hf_rsl_cstat_tx_pkts , {\n \"Packets Sent\" , \"gsm_abis_rsl.ipacc.cstat.tx_pkts\" , FT_UINT32 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_rsl_cstat_tx_octs , {\n \"Octets Sent\" , \"gsm_abis_rsl.ipacc.cstat.tx_octets\" , FT_UINT32 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_rsl_cstat_rx_pkts , {\n \"Packets Received\" , \"gsm_abis_rsl.ipacc.cstat.rx_pkts\" , FT_UINT32 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_rsl_cstat_rx_octs , {\n \"Octets Received\" , \"gsm_abis_rsl.ipacc.cstat.rx_octets\" , FT_UINT32 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_rsl_cstat_lost_pkts , {\n \"Packets Lost\" , \"gsm_abis_rsl.ipacc.cstat.lost_pkts\" , FT_UINT32 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_rsl_cstat_ia_jitter , {\n \"Inter-arrival Jitter\" , \"gsm_abis_rsl.ipacc.cstat.ia_jitter\" , FT_UINT32 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_rsl_cstat_avg_tx_dly , {\n \"Average Tx Delay\" , \"gsm_abis_rsl.ipacc.cstat.avg_tx_delay\" , FT_UINT32 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_rsl_channel_description_tag , {\n \"Channel Description Tag\" , \"gsm_abis_rsl.channel_description_tag\" , FT_NONE , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_mobile_allocation_tag , {\n \"Mobile Allocation Tag+Length(0)\" , \"gsm_abis_rsl.mobile_allocation_tag\" , FT_NONE , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_no_resources_required , {\n \"0 No resources required(All other values are reserved)\" , \"gsm_abis_rsl.no_resources_required\" , FT_NONE , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_llsdu_ccch , {\n \"Link Layer Service Data Unit (L3 Message)(CCCH)\" , \"gsm_abis_rsl.llsdu.ccch\" , FT_NONE , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_llsdu_sacch , {\n \"Link Layer Service Data Unit (L3 Message)(SACCH)\" , \"gsm_abis_rsl.llsdu.sacch\" , FT_NONE , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_llsdu , {\n \"Link Layer Service Data Unit (L3 Message)\" , \"gsm_abis_rsl.llsdu\" , FT_NONE , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_rach_supplementary_information , {\n \"Supplementary Information\" , \"gsm_abis_rsl.supplementary_information\" , FT_NONE , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_full_immediate_assign_info_field , {\n \"Full Immediate Assign Info field\" , \"gsm_abis_rsl.full_immediate_assign_info_field\" , FT_NONE , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_layer_3_message , {\n \"Layer 3 message\" , \"gsm_abis_rsl.layer_3_message\" , FT_NONE , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_descriptive_group_or_broadcast_call_reference , {\n \"Descriptive group or broadcast call reference\" , \"gsm_abis_rsl.descriptive_group_or_broadcast_call_reference\" , FT_NONE , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_group_channel_description , {\n \"Group Channel Description\" , \"gsm_abis_rsl.group_channel_description\" , FT_NONE , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_uic , {\n \"UIC\" , \"gsm_abis_rsl.uic\" , FT_NONE , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_codec_list , {\n \"Codec List\" , \"gsm_abis_rsl.codec_list\" , FT_NONE , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , }\n ;\n static gint * ett [ ] = {\n & ett_rsl , & ett_ie_link_id , & ett_ie_act_type , & ett_ie_bs_power , & ett_ie_ch_id , & ett_ie_ch_mode , & ett_ie_enc_inf , & ett_ie_ch_no , & ett_ie_frame_no , & ett_ie_ho_ref , & ett_ie_l1_inf , & ett_ie_L3_inf , & ett_ie_ms_id , & ett_ie_ms_pow , & ett_ie_phy_ctx , & ett_ie_paging_grp , & ett_ie_paging_load , & ett_ie_access_delay , & ett_ie_rach_load , & ett_ie_req_ref , & ett_ie_rel_mode , & ett_ie_resource_inf , & ett_ie_rlm_cause , & ett_ie_staring_time , & ett_ie_timing_adv , & ett_ie_uplink_meas , & ett_ie_full_imm_ass_inf , & ett_ie_smscb_inf , & ett_ie_ms_timing_offset , & ett_ie_err_msg , & ett_ie_full_bcch_inf , & ett_ie_ch_needed , & ett_ie_cb_cmd_type , & ett_ie_smscb_mess , & ett_ie_cbch_load_inf , & ett_ie_smscb_ch_ind , & ett_ie_grp_call_ref , & ett_ie_ch_desc , & ett_ie_nch_drx , & ett_ie_cmd_ind , & ett_ie_emlpp_prio , & ett_ie_uic , & ett_ie_main_ch_ref , & ett_ie_multirate_conf , & ett_ie_multirate_cntrl , & ett_ie_sup_codec_types , & ett_ie_codec_conf , & ett_ie_rtd , & ett_ie_tfo_status , & ett_ie_llp_apdu , & ett_ie_tfo_transp_cont , & ett_ie_cause , & ett_ie_meas_res_no , & ett_ie_message_id , & ett_ie_sys_info_type , & ett_ie_speech_mode , & ett_ie_conn_id , & ett_ie_remote_ip , & ett_ie_remote_port , & ett_ie_local_port , & ett_ie_local_ip , & ett_ie_rtp_payload , }\n ;\n static ei_register_info ei [ ] = {\n {\n & ei_rsl_speech_or_data_indicator , {\n \"gsm_abis_rsl.speech_or_data_indicator.bad\" , PI_PROTOCOL , PI_WARN , \"Speech or data indicator != 1,2 or 3\" , EXPFILL }\n }\n , {\n & ei_rsl_facility_information_element_3gpp_ts_44071 , {\n \"gsm_abis_rsl.facility_information_element_3gpp_ts_44071\" , PI_PROTOCOL , PI_NOTE , \"Facility Information Element as defined in 3GPP TS 44.071\" , EXPFILL }\n }\n , {\n & ei_rsl_embedded_message_tfo_configuration , {\n \"gsm_abis_rsl.embedded_message_tfo_configuration\" , PI_PROTOCOL , PI_NOTE , \"Embedded message that contains the TFO configuration\" , EXPFILL }\n }\n , }\n ;\n module_t * rsl_module ;\n expert_module_t * expert_rsl ;\n # define RSL_ATT_TLVDEF ( _attr , _type , _fixed_len ) \\ rsl_att_tlvdef . def [ _attr ] . type = _type ;\n \\ rsl_att_tlvdef . def [ _attr ] . fixed_len = _fixed_len ;\n RSL_ATT_TLVDEF ( RSL_IE_CH_NO , TLV_TYPE_TV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_LINK_ID , TLV_TYPE_TV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_ACT_TYPE , TLV_TYPE_TV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_BS_POW , TLV_TYPE_TV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_CH_ID , TLV_TYPE_TLV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_CH_MODE , TLV_TYPE_TLV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_ENC_INF , TLV_TYPE_TLV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_FRAME_NO , TLV_TYPE_FIXED , 2 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_HO_REF , TLV_TYPE_TV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_L1_INF , TLV_TYPE_FIXED , 2 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_L3_INF , TLV_TYPE_TL16V , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_MS_ID , TLV_TYPE_TLV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_MS_POW , TLV_TYPE_TV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_PAGING_GRP , TLV_TYPE_TV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_PAGING_LOAD , TLV_TYPE_FIXED , 2 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_PHY_CTX , TLV_TYPE_TLV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_ACCESS_DELAY , TLV_TYPE_TV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_RACH_LOAD , TLV_TYPE_TLV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_REQ_REF , TLV_TYPE_FIXED , 3 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_REL_MODE , TLV_TYPE_TV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_RESOURCE_INF , TLV_TYPE_TLV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_RLM_CAUSE , TLV_TYPE_TLV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_STARTING_TIME , TLV_TYPE_FIXED , 2 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_TIMING_ADV , TLV_TYPE_TV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_UPLINK_MEAS , TLV_TYPE_TLV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_CAUSE , TLV_TYPE_TLV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_MEAS_RES_NO , TLV_TYPE_TV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_MESSAGE_ID , TLV_TYPE_TV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_SYS_INFO_TYPE , TLV_TYPE_TV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_MS_POWER_PARAM , TLV_TYPE_TLV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_BS_POWER_PARAM , TLV_TYPE_TLV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_PREPROC_PARAM , TLV_TYPE_TLV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_PREPROC_MEAS , TLV_TYPE_TLV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_ERR_MSG , TLV_TYPE_TLV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_FULL_BCCH_INF , TLV_TYPE_TLV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_CH_NEEDED , TLV_TYPE_TV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_CB_CMD_TYPE , TLV_TYPE_TV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_SMSCB_MESS , TLV_TYPE_TLV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_FULL_IMM_ASS_INF , TLV_TYPE_TLV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_CBCH_LOAD_INF , TLV_TYPE_TV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_SMSCB_CH_IND , TLV_TYPE_TV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_GRP_CALL_REF , TLV_TYPE_TLV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_CH_DESC , TLV_TYPE_TLV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_NCH_DRX_INF , TLV_TYPE_TLV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_CMD_IND , TLV_TYPE_TLV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_EMLPP_PRIO , TLV_TYPE_TV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_UIC , TLV_TYPE_TLV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_MAIN_CH_REF , TLV_TYPE_TV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_MULTIRATE_CONF , TLV_TYPE_TLV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_MULTIRATE_CNTRL , TLV_TYPE_TV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_SUP_CODEC_TYPES , TLV_TYPE_TLV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_CODEC_CONF , TLV_TYPE_TLV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_RTD , TLV_TYPE_TV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_TFO_STATUS , TLV_TYPE_TV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_LLP_APDU , TLV_TYPE_TLV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_IPAC_REMOTE_IP , TLV_TYPE_FIXED , 4 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_IPAC_REMOTE_PORT , TLV_TYPE_FIXED , 2 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_IPAC_LOCAL_IP , TLV_TYPE_FIXED , 4 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_IPAC_CONN_STAT , TLV_TYPE_TLV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_IPAC_LOCAL_PORT , TLV_TYPE_FIXED , 2 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_IPAC_SPEECH_MODE , TLV_TYPE_TV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_IPAC_CONN_ID , TLV_TYPE_FIXED , 2 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_IPAC_RTP_PAYLOAD2 , TLV_TYPE_TV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_IPAC_RTP_PAYLOAD , TLV_TYPE_TV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_IPAC_RTP_CSD_FMT , TLV_TYPE_TV , 0 ) ;\n proto_rsl = proto_register_protocol ( \"Radio Signalling Link (RSL)\" , \"RSL\" , \"gsm_abis_rsl\" ) ;\n proto_register_field_array ( proto_rsl , hf , array_length ( hf ) ) ;\n proto_register_subtree_array ( ett , array_length ( ett ) ) ;\n expert_rsl = expert_register_protocol ( proto_rsl ) ;\n expert_register_field_array ( expert_rsl , ei , array_length ( ei ) ) ;\n register_dissector ( \"gsm_abis_rsl\" , dissect_rsl , proto_rsl ) ;\n rsl_module = prefs_register_protocol ( proto_rsl , proto_reg_handoff_rsl ) ;\n prefs_register_bool_preference ( rsl_module , \"use_ipaccess_rsl\" , \"Use nanoBTS definitions\" , \"Use ipaccess nanoBTS specific definitions for RSL\" , & global_rsl_use_nano_bts ) ;\n }", "idx": 20583}
{"hash": -187662502455871220, "project": "debian", "size": 7, "label": 0, "functionSource": "static const gchar * get_control_selector_name ( guint8 entity_id , guint8 control_sel , usb_conv_info_t * usb_conv_info ) {\n const gchar * control_name = NULL ;\n value_string_ext * selectors = NULL ;\n selectors = get_control_selector_values ( entity_id , usb_conv_info ) ;\n if ( selectors ) control_name = try_val_to_str_ext ( control_sel , selectors ) ;\n return control_name ;\n }", "idx": 20584}
{"hash": 378220832151730865, "project": "debian", "size": 28, "label": 0, "functionSource": "int qemuMonitorTextAttachPCIDiskController ( qemuMonitorPtr mon , const char * bus , virDomainDevicePCIAddress * guestAddr ) {\n char * cmd = NULL ;\n char * reply = NULL ;\n int tryOldSyntax = 0 ;\n int ret = - 1 ;\n try_command : if ( virAsprintf ( & cmd , \"pci_add %s storage if=%s\" , ( tryOldSyntax ? \"0\" : \"pci_addr=auto\" ) , bus ) < 0 ) {\n virReportOOMError ( ) ;\n goto cleanup ;\n }\n if ( qemuMonitorHMPCommand ( mon , cmd , & reply ) < 0 ) {\n qemuReportError ( VIR_ERR_OPERATION_FAILED , _ ( \"cannot attach %s disk controller\" ) , bus ) ;\n goto cleanup ;\n }\n if ( qemuMonitorTextParsePciAddReply ( mon , reply , guestAddr ) < 0 ) {\n if ( ! tryOldSyntax && strstr ( reply , \"invalid char in expression\" ) ) {\n VIR_FREE ( reply ) ;\n VIR_FREE ( cmd ) ;\n tryOldSyntax = 1 ;\n goto try_command ;\n }\n qemuReportError ( VIR_ERR_OPERATION_FAILED , _ ( \"adding %s disk controller failed: %s\" ) , bus , reply ) ;\n goto cleanup ;\n }\n ret = 0 ;\n cleanup : VIR_FREE ( cmd ) ;\n VIR_FREE ( reply ) ;\n return ret ;\n }", "idx": 20585}
{"hash": 5991533509192663951, "project": "debian", "size": 12, "label": 0, "functionSource": "void mbfl_buffer_converter_delete ( mbfl_buffer_converter * convd ) {\n if ( convd != NULL ) {\n if ( convd -> filter1 ) {\n mbfl_convert_filter_delete ( convd -> filter1 ) ;\n }\n if ( convd -> filter2 ) {\n mbfl_convert_filter_delete ( convd -> filter2 ) ;\n }\n mbfl_memory_device_clear ( & convd -> device ) ;\n mbfl_free ( ( void * ) convd ) ;\n }\n }", "idx": 20586}
{"hash": -714975729066076397, "project": "chrome", "size": 20, "label": 1, "functionSource": "hb_blob_t * hb_blob_create ( const char * data , unsigned int length , hb_memory_mode_t mode , void * user_data , hb_destroy_func_t destroy ) {\n hb_blob_t * blob ;\n if ( ! length || ! ( blob = hb_object_create < hb_blob_t > ( ) ) ) {\n if ( destroy ) destroy ( user_data ) ;\n return hb_blob_get_empty ( ) ;\n }\n blob -> data = data ;\n blob -> length = length ;\n blob -> mode = mode ;\n blob -> user_data = user_data ;\n blob -> destroy = destroy ;\n if ( blob -> mode == HB_MEMORY_MODE_DUPLICATE ) {\n blob -> mode = HB_MEMORY_MODE_READONLY ;\n if ( ! _try_writable ( blob ) ) {\n hb_blob_destroy ( blob ) ;\n return hb_blob_get_empty ( ) ;\n }\n }\n return blob ;\n }", "idx": 20587}
{"hash": -2242211406757466627, "project": "debian", "size": 4, "label": 0, "functionSource": "static gint round_to_8byte ( gint current_offset , gint starting_offset ) {\n gint length = current_offset - starting_offset ;\n return starting_offset + ROUND_TO_8BYTE ( length ) ;\n }", "idx": 20588}
{"hash": 8320716512483418415, "project": "chrome", "size": 26, "label": 1, "functionSource": "void vp9_idct16x16_10_add_c ( const int16_t * input , uint8_t * dest , int stride ) {\n int16_t out [ 16 * 16 ] = {\n 0 }\n ;\n int16_t * outptr = out ;\n int i , j ;\n int16_t temp_in [ 16 ] , temp_out [ 16 ] ;\n for ( i = 0 ;\n i < 4 ;\n ++ i ) {\n idct16 ( input , outptr ) ;\n input += 16 ;\n outptr += 16 ;\n }\n for ( i = 0 ;\n i < 16 ;\n ++ i ) {\n for ( j = 0 ;\n j < 16 ;\n ++ j ) temp_in [ j ] = out [ j * 16 + i ] ;\n idct16 ( temp_in , temp_out ) ;\n for ( j = 0 ;\n j < 16 ;\n ++ j ) dest [ j * stride + i ] = clip_pixel ( ROUND_POWER_OF_TWO ( temp_out [ j ] , 6 ) + dest [ j * stride + i ] ) ;\n }\n }", "idx": 20589}
{"hash": -7468702064548611268, "project": "debian", "size": 9, "label": 0, "functionSource": "void ff_vdpau_add_data_chunk ( uint8_t * data , const uint8_t * buf , int buf_size ) {\n struct vdpau_render_state * render = ( struct vdpau_render_state * ) data ;\n assert ( render ) ;\n render -> bitstream_buffers = av_fast_realloc ( render -> bitstream_buffers , & render -> bitstream_buffers_allocated , sizeof ( * render -> bitstream_buffers ) * ( render -> bitstream_buffers_used + 1 ) ) ;\n render -> bitstream_buffers [ render -> bitstream_buffers_used ] . struct_version = VDP_BITSTREAM_BUFFER_VERSION ;\n render -> bitstream_buffers [ render -> bitstream_buffers_used ] . bitstream = buf ;\n render -> bitstream_buffers [ render -> bitstream_buffers_used ] . bitstream_bytes = buf_size ;\n render -> bitstream_buffers_used ++ ;\n }", "idx": 20590}
{"hash": -1929262071302712016, "project": "debian", "size": 5, "label": 0, "functionSource": "static cmsBool SaveOneChromaticity ( cmsFloat64Number x , cmsFloat64Number y , cmsIOHANDLER * io ) {\n if ( ! _cmsWriteUInt32Number ( io , _cmsDoubleTo15Fixed16 ( x ) ) ) return FALSE ;\n if ( ! _cmsWriteUInt32Number ( io , _cmsDoubleTo15Fixed16 ( y ) ) ) return FALSE ;\n return TRUE ;\n }", "idx": 20591}
{"hash": -3135212895432241239, "project": "debian", "size": 10, "label": 0, "functionSource": "static guint32 dissect_netb_datagram ( tvbuff_t * tvb , packet_info * pinfo _U_ , int offset , proto_tree * tree ) {\n netbios_add_name ( \"Receiver's Name\" , tvb , offset + NB_RECVER_NAME , tree ) ;\n if ( tvb_memeql ( tvb , offset + NB_SENDER_NAME , zeroes , 10 ) == 0 ) {\n proto_tree_add_item ( tree , hf_netb_datagram_mac , tvb , offset + NB_SENDER_NAME + 10 , 6 , ENC_NA ) ;\n }\n else {\n netbios_add_name ( \"Sender's Name\" , tvb , offset + NB_SENDER_NAME , tree ) ;\n }\n return 0 ;\n }", "idx": 20592}
{"hash": 1981604082870872490, "project": "chrome", "size": 16, "label": 0, "functionSource": "static int32_t u_printf_hex_handler ( const u_printf_stream_handler * handler , void * context , ULocaleBundle * formatBundle , const u_printf_spec_info * info , const ufmt_args * args ) {\n ( void ) formatBundle ;\n int64_t num = args [ 0 ] . int64Value ;\n UChar result [ UPRINTF_BUFFER_SIZE ] ;\n int32_t len = UPRINTF_BUFFER_SIZE ;\n if ( info -> fIsShort ) num &= UINT16_MAX ;\n else if ( ! info -> fIsLongLong ) num &= UINT32_MAX ;\n ufmt_64tou ( result , & len , num , 16 , ( UBool ) ( info -> fSpec == 0x0078 ) , ( info -> fPrecision == - 1 && info -> fZero ) ? info -> fWidth : info -> fPrecision ) ;\n if ( num != 0 && info -> fAlt && len < UPRINTF_BUFFER_SIZE - 2 ) {\n memmove ( result + 2 , result , len * sizeof ( UChar ) ) ;\n result [ 0 ] = 0x0030 ;\n result [ 1 ] = info -> fSpec ;\n len += 2 ;\n }\n return handler -> pad_and_justify ( context , info , result , len ) ;\n }", "idx": 20593}
{"hash": 4489017523191997023, "project": "debian", "size": 5, "label": 0, "functionSource": "h225ras_call_t * find_h225ras_call ( h225ras_call_info_key * h225ras_call_key , int category ) {\n h225ras_call_t * h225ras_call = NULL ;\n h225ras_call = ( h225ras_call_t * ) g_hash_table_lookup ( ras_calls [ category ] , h225ras_call_key ) ;\n return h225ras_call ;\n }", "idx": 20594}
{"hash": 2546373479020365143, "project": "debian", "size": 6, "label": 0, "functionSource": "void mime_hdr_presence_unset ( MIMEHdrImpl * h , const char * well_known_str ) {\n uint64_t mask = mime_field_presence_mask ( well_known_str ) ;\n if ( mask != 0 ) {\n h -> m_presence_bits &= ( ~ mask ) ;\n }\n }", "idx": 20595}
{"hash": -2242211406757466627, "project": "debian", "size": 4, "label": 0, "functionSource": "static gint round_to_2byte ( gint current_offset , gint starting_offset ) {\n gint length = current_offset - starting_offset ;\n return starting_offset + ROUND_TO_2BYTE ( length ) ;\n }", "idx": 20596}
{"hash": 6323824267898511453, "project": "debian", "size": 4, "label": 0, "functionSource": "static fz_colorspace * base_indexed ( const fz_colorspace * cs ) {\n struct indexed * idx = cs -> data ;\n return idx -> base ;\n }", "idx": 20597}
{"hash": 4839943401171415484, "project": "chrome", "size": 18, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_P ( BrowserCloseManagerBrowserTest , TestShutdownMoreThanOnce ) {\n ASSERT_NO_FATAL_FAILURE ( ui_test_utils : : NavigateToURL ( browser ( ) , embedded_test_server ( ) -> GetURL ( \"/beforeunload.html\" ) ) ) ;\n PrepareForDialog ( browser ( ) ) ;\n RepeatedNotificationObserver cancel_observer ( chrome : : NOTIFICATION_BROWSER_CLOSE_CANCELLED , 1 ) ;\n chrome : : CloseAllBrowsersAndQuit ( ) ;\n chrome : : CloseAllBrowsersAndQuit ( ) ;\n ASSERT_NO_FATAL_FAILURE ( CancelClose ( ) ) ;\n cancel_observer . Wait ( ) ;\n EXPECT_FALSE ( browser_shutdown : : IsTryingToQuit ( ) ) ;\n EXPECT_EQ ( 1 , browser ( ) -> tab_strip_model ( ) -> count ( ) ) ;\n RepeatedNotificationObserver close_observer ( chrome : : NOTIFICATION_BROWSER_CLOSED , 1 ) ;\n chrome : : CloseAllBrowsersAndQuit ( ) ;\n chrome : : CloseAllBrowsersAndQuit ( ) ;\n ASSERT_NO_FATAL_FAILURE ( AcceptClose ( ) ) ;\n close_observer . Wait ( ) ;\n EXPECT_TRUE ( browser_shutdown : : IsTryingToQuit ( ) ) ;\n EXPECT_TRUE ( BrowserList : : GetInstance ( ) -> empty ( ) ) ;\n }", "idx": 20598}
{"hash": 4180964683905830761, "project": "debian", "size": 30, "label": 0, "functionSource": "static void selinux_bprm_committed_creds ( struct linux_binprm * bprm ) {\n const struct task_security_struct * tsec = current_security ( ) ;\n struct itimerval itimer ;\n u32 osid , sid ;\n int rc , i ;\n osid = tsec -> osid ;\n sid = tsec -> sid ;\n if ( sid == osid ) return ;\n rc = avc_has_perm ( osid , sid , SECCLASS_PROCESS , PROCESS__SIGINH , NULL ) ;\n if ( rc ) {\n if ( IS_ENABLED ( CONFIG_POSIX_TIMERS ) ) {\n memset ( & itimer , 0 , sizeof itimer ) ;\n for ( i = 0 ;\n i < 3 ;\n i ++ ) do_setitimer ( i , & itimer , NULL ) ;\n }\n spin_lock_irq ( & current -> sighand -> siglock ) ;\n if ( ! fatal_signal_pending ( current ) ) {\n flush_sigqueue ( & current -> pending ) ;\n flush_sigqueue ( & current -> signal -> shared_pending ) ;\n flush_signal_handlers ( current , 1 ) ;\n sigemptyset ( & current -> blocked ) ;\n recalc_sigpending ( ) ;\n }\n spin_unlock_irq ( & current -> sighand -> siglock ) ;\n }\n read_lock ( & tasklist_lock ) ;\n __wake_up_parent ( current , current -> real_parent ) ;\n read_unlock ( & tasklist_lock ) ;\n }", "idx": 20599}
{"hash": -7455544248455991006, "project": "debian", "size": 3, "label": 0, "functionSource": "static void kvm_msr_buf_reset ( X86CPU * cpu ) {\n memset ( cpu -> kvm_msr_buf , 0 , MSR_BUF_SIZE ) ;\n }", "idx": 20600}
{"hash": 3599206110384554647, "project": "debian", "size": 10, "label": 0, "functionSource": "static ossl_inline void lh_ ## type ## _set_down_load ( LHASH_OF ( type ) * lh , unsigned long dl ) {\n OPENSSL_LH_set_down_load ( ( OPENSSL_LHASH * ) lh , dl ) ;\n }\n static ossl_inline void lh_ ## type ## _doall ( LHASH_OF ( type ) * lh , void ( * doall ) ( type * ) ) {\n OPENSSL_LH_doall ( ( OPENSSL_LHASH * ) lh , ( OPENSSL_LH_DOALL_FUNC ) doall ) ;\n }\n LHASH_OF ( type ) # define IMPLEMENT_LHASH_DOALL_ARG_CONST ( type , argtype ) int_implement_lhash_doall ( type , argtype , const type ) # define IMPLEMENT_LHASH_DOALL_ARG ( type , argtype ) int_implement_lhash_doall ( type , argtype , type ) # define int_implement_lhash_doall ( type , argtype , cbargtype ) static ossl_inline void lh_ ## type ## _doall_ ## argtype ( LHASH_OF ( type ) * lh , void ( * fn ) ( cbargtype * , argtype * ) , argtype * arg ) {\n OPENSSL_LH_doall_arg ( ( OPENSSL_LHASH * ) lh , ( OPENSSL_LH_DOALL_FUNCARG ) fn , ( void * ) arg ) ;\n }\n LHASH_OF ( type ) DEFINE_LHASH_OF ( OPENSSL_STRING )", "idx": 20601}
{"hash": 583170025160259883, "project": "debian", "size": 18, "label": 0, "functionSource": "void hmp_hostfwd_add ( Monitor * mon , const QDict * qdict ) {\n const char * redir_str ;\n SlirpState * s ;\n const char * arg1 = qdict_get_str ( qdict , \"arg1\" ) ;\n const char * arg2 = qdict_get_try_str ( qdict , \"arg2\" ) ;\n const char * arg3 = qdict_get_try_str ( qdict , \"arg3\" ) ;\n if ( arg2 ) {\n s = slirp_lookup ( mon , arg1 , arg2 ) ;\n redir_str = arg3 ;\n }\n else {\n s = slirp_lookup ( mon , NULL , NULL ) ;\n redir_str = arg1 ;\n }\n if ( s ) {\n slirp_hostfwd ( s , redir_str , 0 ) ;\n }\n }", "idx": 20602}
{"hash": 6968788423709606113, "project": "debian", "size": 273, "label": 0, "functionSource": "static Image * ReadGIFImage ( const ImageInfo * image_info , ExceptionInfo * exception ) {\n # define BitSet ( byte , bit ) ( ( ( byte ) & ( bit ) ) == ( bit ) ) # define LSBFirstOrder ( x , y ) ( ( ( y ) << 8 ) | ( x ) ) Image * image , * meta_image ;\n int number_extensionss = 0 ;\n MagickBooleanType status ;\n RectangleInfo page ;\n register ssize_t i ;\n register unsigned char * p ;\n size_t delay , dispose , duration , global_colors , image_count , iterations , one ;\n ssize_t count , opacity ;\n unsigned char background , c , flag , * global_colormap , header [ MaxTextExtent ] , magick [ 12 ] ;\n assert ( image_info != ( const ImageInfo * ) NULL ) ;\n assert ( image_info -> signature == MagickSignature ) ;\n if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ;\n assert ( exception != ( ExceptionInfo * ) NULL ) ;\n assert ( exception -> signature == MagickSignature ) ;\n image = AcquireImage ( image_info ) ;\n status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ;\n if ( status == MagickFalse ) {\n image = DestroyImageList ( image ) ;\n return ( ( Image * ) NULL ) ;\n }\n count = ReadBlob ( image , 6 , magick ) ;\n if ( ( count != 6 ) || ( ( LocaleNCompare ( ( char * ) magick , \"GIF87\" , 5 ) != 0 ) && ( LocaleNCompare ( ( char * ) magick , \"GIF89\" , 5 ) != 0 ) ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ;\n page . width = ReadBlobLSBShort ( image ) ;\n page . height = ReadBlobLSBShort ( image ) ;\n flag = ( unsigned char ) ReadBlobByte ( image ) ;\n background = ( unsigned char ) ReadBlobByte ( image ) ;\n c = ( unsigned char ) ReadBlobByte ( image ) ;\n one = 1 ;\n global_colors = one << ( ( ( size_t ) flag & 0x07 ) + 1 ) ;\n global_colormap = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) MagickMax ( global_colors , 256 ) , 3UL * sizeof ( * global_colormap ) ) ;\n if ( global_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ;\n ( void ) ResetMagickMemory ( global_colormap , 0 , 3 * MagickMax ( global_colors , 256 ) * sizeof ( * global_colormap ) ) ;\n if ( BitSet ( ( int ) flag , 0x80 ) != 0 ) {\n count = ReadBlob ( image , ( size_t ) ( 3 * global_colors ) , global_colormap ) ;\n if ( count != ( ssize_t ) ( 3 * global_colors ) ) {\n global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ;\n ThrowReaderException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ;\n }\n }\n delay = 0 ;\n dispose = 0 ;\n duration = 0 ;\n iterations = 1 ;\n opacity = ( - 1 ) ;\n image_count = 0 ;\n meta_image = AcquireImage ( image_info ) ;\n for ( ;\n ;\n ) {\n count = ReadBlob ( image , 1 , & c ) ;\n if ( count != 1 ) break ;\n if ( c == ( unsigned char ) ';\n' ) break ;\n if ( c == ( unsigned char ) '!' ) {\n count = ReadBlob ( image , 1 , & c ) ;\n if ( count != 1 ) {\n global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ;\n meta_image = DestroyImage ( meta_image ) ;\n ThrowReaderException ( CorruptImageError , \"UnableToReadExtensionBlock\" ) ;\n }\n switch ( c ) {\n case 0xf9 : {\n while ( ReadBlobBlock ( image , header ) != 0 ) ;\n dispose = ( size_t ) ( header [ 0 ] >> 2 ) ;\n delay = ( size_t ) ( ( header [ 2 ] << 8 ) | header [ 1 ] ) ;\n if ( ( ssize_t ) ( header [ 0 ] & 0x01 ) == 0x01 ) opacity = ( ssize_t ) header [ 3 ] ;\n break ;\n }\n case 0xfe : {\n char * comments ;\n size_t length ;\n comments = AcquireString ( ( char * ) NULL ) ;\n for ( length = 0 ;\n ;\n length += count ) {\n count = ReadBlobBlock ( image , header ) ;\n if ( count == 0 ) break ;\n header [ count ] = '\\0' ;\n ( void ) ConcatenateString ( & comments , ( const char * ) header ) ;\n }\n ( void ) SetImageProperty ( meta_image , \"comment\" , comments ) ;\n comments = DestroyString ( comments ) ;\n break ;\n }\n case 0xff : {\n MagickBooleanType loop ;\n loop = MagickFalse ;\n if ( ReadBlobBlock ( image , header ) != 0 ) loop = LocaleNCompare ( ( char * ) header , \"NETSCAPE2.0\" , 11 ) == 0 ? MagickTrue : MagickFalse ;\n if ( loop != MagickFalse ) {\n while ( ReadBlobBlock ( image , header ) != 0 ) iterations = ( size_t ) ( ( header [ 2 ] << 8 ) | header [ 1 ] ) ;\n break ;\n }\n else {\n char name [ MaxTextExtent ] ;\n int block_length , info_length , reserved_length ;\n MagickBooleanType i8bim , icc , iptc , magick ;\n StringInfo * profile ;\n unsigned char * info ;\n icc = LocaleNCompare ( ( char * ) header , \"ICCRGBG1012\" , 11 ) == 0 ? MagickTrue : MagickFalse ;\n magick = LocaleNCompare ( ( char * ) header , \"ImageMagick\" , 11 ) == 0 ? MagickTrue : MagickFalse ;\n i8bim = LocaleNCompare ( ( char * ) header , \"MGK8BIM0000\" , 11 ) == 0 ? MagickTrue : MagickFalse ;\n iptc = LocaleNCompare ( ( char * ) header , \"MGKIPTC0000\" , 11 ) == 0 ? MagickTrue : MagickFalse ;\n number_extensionss ++ ;\n ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \" Reading GIF application extension\" ) ;\n info = ( unsigned char * ) AcquireQuantumMemory ( 255UL , sizeof ( * info ) ) ;\n if ( info == ( unsigned char * ) NULL ) {\n meta_image = DestroyImage ( meta_image ) ;\n ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ;\n }\n reserved_length = 255 ;\n for ( info_length = 0 ;\n ;\n ) {\n block_length = ( int ) ReadBlobBlock ( image , & info [ info_length ] ) ;\n if ( block_length == 0 ) break ;\n info_length += block_length ;\n if ( info_length > ( reserved_length - 255 ) ) {\n reserved_length += 4096 ;\n info = ( unsigned char * ) ResizeQuantumMemory ( info , ( size_t ) reserved_length , sizeof ( * info ) ) ;\n if ( info == ( unsigned char * ) NULL ) {\n meta_image = DestroyImage ( meta_image ) ;\n ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ;\n }\n }\n }\n profile = BlobToStringInfo ( info , ( size_t ) info_length ) ;\n if ( profile == ( StringInfo * ) NULL ) {\n meta_image = DestroyImage ( meta_image ) ;\n ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ;\n }\n if ( i8bim != MagickFalse ) ( void ) CopyMagickString ( name , \"8bim\" , sizeof ( name ) ) ;\n else if ( icc != MagickFalse ) ( void ) CopyMagickString ( name , \"icc\" , sizeof ( name ) ) ;\n else if ( iptc != MagickFalse ) ( void ) CopyMagickString ( name , \"iptc\" , sizeof ( name ) ) ;\n else if ( magick != MagickFalse ) {\n ( void ) CopyMagickString ( name , \"magick\" , sizeof ( name ) ) ;\n meta_image -> gamma = StringToDouble ( ( char * ) info + 6 , ( char * * ) NULL ) ;\n }\n else ( void ) FormatLocaleString ( name , sizeof ( name ) , \"gif:%.11s\" , header ) ;\n info = ( unsigned char * ) RelinquishMagickMemory ( info ) ;\n if ( magick == MagickFalse ) ( void ) SetImageProfile ( meta_image , name , profile ) ;\n profile = DestroyStringInfo ( profile ) ;\n ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \" profile name=%s\" , name ) ;\n }\n break ;\n }\n default : {\n while ( ReadBlobBlock ( image , header ) != 0 ) ;\n break ;\n }\n }\n }\n if ( c != ( unsigned char ) ',' ) continue ;\n if ( image_count != 0 ) {\n AcquireNextImage ( image_info , image ) ;\n if ( GetNextImageInList ( image ) == ( Image * ) NULL ) {\n image = DestroyImageList ( image ) ;\n global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ;\n return ( ( Image * ) NULL ) ;\n }\n image = SyncNextImageInList ( image ) ;\n }\n image_count ++ ;\n meta_image -> scene = image -> scene ;\n ( void ) CloneImageProperties ( image , meta_image ) ;\n DestroyImageProperties ( meta_image ) ;\n ( void ) CloneImageProfiles ( image , meta_image ) ;\n DestroyImageProfiles ( meta_image ) ;\n image -> storage_class = PseudoClass ;\n image -> compression = LZWCompression ;\n page . x = ( ssize_t ) ReadBlobLSBShort ( image ) ;\n page . y = ( ssize_t ) ReadBlobLSBShort ( image ) ;\n image -> columns = ReadBlobLSBShort ( image ) ;\n image -> rows = ReadBlobLSBShort ( image ) ;\n image -> depth = 8 ;\n flag = ( unsigned char ) ReadBlobByte ( image ) ;\n image -> interlace = BitSet ( ( int ) flag , 0x40 ) != 0 ? GIFInterlace : NoInterlace ;\n image -> colors = BitSet ( ( int ) flag , 0x80 ) == 0 ? global_colors : one << ( ( size_t ) ( flag & 0x07 ) + 1 ) ;\n if ( opacity >= ( ssize_t ) image -> colors ) opacity = ( - 1 ) ;\n image -> page . width = page . width ;\n image -> page . height = page . height ;\n image -> page . y = page . y ;\n image -> page . x = page . x ;\n image -> delay = delay ;\n image -> iterations = iterations ;\n image -> ticks_per_second = 100 ;\n image -> dispose = ( DisposeType ) dispose ;\n image -> matte = opacity >= 0 ? MagickTrue : MagickFalse ;\n delay = 0 ;\n dispose = 0 ;\n if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) {\n global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ;\n meta_image = DestroyImage ( meta_image ) ;\n ThrowReaderException ( CorruptImageError , \"NegativeOrZeroImageSize\" ) ;\n }\n if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) {\n global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ;\n meta_image = DestroyImage ( meta_image ) ;\n ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ;\n }\n if ( BitSet ( ( int ) flag , 0x80 ) == 0 ) {\n p = global_colormap ;\n for ( i = 0 ;\n i < ( ssize_t ) image -> colors ;\n i ++ ) {\n image -> colormap [ i ] . red = ScaleCharToQuantum ( * p ++ ) ;\n image -> colormap [ i ] . green = ScaleCharToQuantum ( * p ++ ) ;\n image -> colormap [ i ] . blue = ScaleCharToQuantum ( * p ++ ) ;\n if ( i == opacity ) {\n image -> colormap [ i ] . opacity = ( Quantum ) TransparentOpacity ;\n image -> transparent_color = image -> colormap [ opacity ] ;\n }\n }\n image -> background_color = image -> colormap [ MagickMin ( ( ssize_t ) background , ( ssize_t ) image -> colors - 1 ) ] ;\n }\n else {\n unsigned char * colormap ;\n colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , 3 * sizeof ( * colormap ) ) ;\n if ( colormap == ( unsigned char * ) NULL ) {\n global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ;\n meta_image = DestroyImage ( meta_image ) ;\n ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ;\n }\n count = ReadBlob ( image , ( 3 * image -> colors ) * sizeof ( * colormap ) , colormap ) ;\n if ( count != ( ssize_t ) ( 3 * image -> colors ) ) {\n global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ;\n colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ;\n meta_image = DestroyImage ( meta_image ) ;\n ThrowReaderException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ;\n }\n p = colormap ;\n for ( i = 0 ;\n i < ( ssize_t ) image -> colors ;\n i ++ ) {\n image -> colormap [ i ] . red = ScaleCharToQuantum ( * p ++ ) ;\n image -> colormap [ i ] . green = ScaleCharToQuantum ( * p ++ ) ;\n image -> colormap [ i ] . blue = ScaleCharToQuantum ( * p ++ ) ;\n if ( i == opacity ) image -> colormap [ i ] . opacity = ( Quantum ) TransparentOpacity ;\n }\n colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ;\n }\n if ( image -> gamma == 1.0 ) {\n for ( i = 0 ;\n i < ( ssize_t ) image -> colors ;\n i ++ ) if ( IsGrayPixel ( image -> colormap + i ) == MagickFalse ) break ;\n ( void ) SetImageColorspace ( image , i == ( ssize_t ) image -> colors ? GRAYColorspace : RGBColorspace ) ;\n }\n if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;\n status = SetImageExtent ( image , image -> columns , image -> rows ) ;\n if ( status == MagickFalse ) {\n InheritException ( exception , & image -> exception ) ;\n return ( DestroyImageList ( image ) ) ;\n }\n if ( image_info -> ping != MagickFalse ) status = PingGIFImage ( image ) ;\n else status = DecodeImage ( image , opacity ) ;\n if ( ( image_info -> ping == MagickFalse ) && ( status == MagickFalse ) ) {\n global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ;\n meta_image = DestroyImage ( meta_image ) ;\n ThrowReaderException ( CorruptImageError , \"CorruptImage\" ) ;\n }\n duration += image -> delay * image -> iterations ;\n if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;\n opacity = ( - 1 ) ;\n status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) image -> scene - 1 , image -> scene ) ;\n if ( status == MagickFalse ) break ;\n }\n image -> duration = duration ;\n meta_image = DestroyImage ( meta_image ) ;\n global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ;\n if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) ThrowReaderException ( CorruptImageError , \"NegativeOrZeroImageSize\" ) ;\n ( void ) CloseBlob ( image ) ;\n return ( GetFirstImageInList ( image ) ) ;\n }", "idx": 20603}
{"hash": -8199454075838226273, "project": "debian", "size": 167, "label": 0, "functionSource": "void proto_register_rtmpt ( void ) {\n static hf_register_info hf [ ] = {\n {\n & hf_rtmpt_handshake_c0 , {\n \"Protocol version\" , \"rtmpt.handshake.c0\" , FT_BYTES , BASE_NONE , NULL , 0x0 , \"RTMPT Handshake C0\" , HFILL }\n }\n , {\n & hf_rtmpt_handshake_s0 , {\n \"Protocol version\" , \"rtmpt.handshake.s0\" , FT_BYTES , BASE_NONE , NULL , 0x0 , \"RTMPT Handshake S0\" , HFILL }\n }\n , {\n & hf_rtmpt_handshake_c1 , {\n \"Handshake data\" , \"rtmpt.handshake.c1\" , FT_BYTES , BASE_NONE , NULL , 0x0 , \"RTMPT Handshake C1\" , HFILL }\n }\n , {\n & hf_rtmpt_handshake_s1 , {\n \"Handshake data\" , \"rtmpt.handshake.s1\" , FT_BYTES , BASE_NONE , NULL , 0x0 , \"RTMPT Handshake S1\" , HFILL }\n }\n , {\n & hf_rtmpt_handshake_c2 , {\n \"Handshake data\" , \"rtmpt.handshake.c2\" , FT_BYTES , BASE_NONE , NULL , 0x0 , \"RTMPT Handshake C2\" , HFILL }\n }\n , {\n & hf_rtmpt_handshake_s2 , {\n \"Handshake data\" , \"rtmpt.handshake.s2\" , FT_BYTES , BASE_NONE , NULL , 0x0 , \"RTMPT Handshake S2\" , HFILL }\n }\n , {\n & hf_rtmpt_header_format , {\n \"Format\" , \"rtmpt.header.format\" , FT_UINT8 , BASE_DEC , NULL , 0xC0 , \"RTMPT Basic Header format\" , HFILL }\n }\n , {\n & hf_rtmpt_header_csid , {\n \"Chunk Stream ID\" , \"rtmpt.header.csid\" , FT_UINT8 , BASE_DEC , NULL , 0x3F , \"RTMPT Basic Header chunk stream ID\" , HFILL }\n }\n , {\n & hf_rtmpt_header_timestamp , {\n \"Timestamp\" , \"rtmpt.header.timestamp\" , FT_UINT24 , BASE_DEC , NULL , 0x0 , \"RTMPT Message Header timestamp\" , HFILL }\n }\n , {\n & hf_rtmpt_header_timestamp_delta , {\n \"Timestamp delta\" , \"rtmpt.header.timestampdelta\" , FT_UINT24 , BASE_DEC , NULL , 0x0 , \"RTMPT Message Header timestamp delta\" , HFILL }\n }\n , {\n & hf_rtmpt_header_body_size , {\n \"Body size\" , \"rtmpt.header.bodysize\" , FT_UINT24 , BASE_DEC , NULL , 0x0 , \"RTMPT Message Header body size\" , HFILL }\n }\n , {\n & hf_rtmpt_header_typeid , {\n \"Type ID\" , \"rtmpt.header.typeid\" , FT_UINT8 , BASE_HEX , VALS ( rtmpt_opcode_vals ) , 0x0 , \"RTMPT Message Header type ID\" , HFILL }\n }\n , {\n & hf_rtmpt_header_streamid , {\n \"Stream ID\" , \"rtmpt.header.streamid\" , FT_UINT32 , BASE_DEC , NULL , 0x0 , \"RTMPT Header stream ID\" , HFILL }\n }\n , {\n & hf_rtmpt_header_ets , {\n \"Extended timestamp\" , \"rtmpt.header.ets\" , FT_UINT24 , BASE_DEC , NULL , 0x0 , \"RTMPT Message Header extended timestamp\" , HFILL }\n }\n , {\n & hf_rtmpt_scm_chunksize , {\n \"Chunk size\" , \"rtmpt.scm.chunksize\" , FT_UINT32 , BASE_DEC , NULL , 0x0 , \"RTMPT SCM chunk size\" , HFILL }\n }\n , {\n & hf_rtmpt_scm_csid , {\n \"Chunk stream ID\" , \"rtmpt.scm.csid\" , FT_UINT32 , BASE_DEC , NULL , 0x0 , \"RTMPT SCM chunk stream ID\" , HFILL }\n }\n , {\n & hf_rtmpt_scm_seq , {\n \"Sequence number\" , \"rtmpt.scm.seq\" , FT_UINT32 , BASE_DEC , NULL , 0x0 , \"RTMPT SCM acknowledgement sequence number\" , HFILL }\n }\n , {\n & hf_rtmpt_scm_was , {\n \"Window acknowledgement size\" , \"rtmpt.scm.was\" , FT_UINT32 , BASE_DEC , NULL , 0x0 , \"RTMPT SCM window acknowledgement size\" , HFILL }\n }\n , {\n & hf_rtmpt_scm_limittype , {\n \"Limit type\" , \"rtmpt.scm.limittype\" , FT_UINT8 , BASE_DEC , VALS ( rtmpt_limit_vals ) , 0x0 , \"RTMPT SCM window acknowledgement size\" , HFILL }\n }\n , {\n & hf_rtmpt_ucm_eventtype , {\n \"Event type\" , \"rtmpt.ucm.eventtype\" , FT_UINT16 , BASE_DEC , VALS ( rtmpt_ucm_vals ) , 0x0 , \"RTMPT UCM event type\" , HFILL }\n }\n , {\n & hf_rtmpt_function_call , {\n \"Response to this call in frame\" , \"rtmpt.function.call\" , FT_FRAMENUM , BASE_NONE , NULL , 0x0 , \"RTMPT function call\" , HFILL }\n }\n , {\n & hf_rtmpt_function_response , {\n \"Call for this response in frame\" , \"rtmpt.function.response\" , FT_FRAMENUM , BASE_NONE , NULL , 0x0 , \"RTMPT function response\" , HFILL }\n }\n , {\n & hf_rtmpt_audio_control , {\n \"Audio control\" , \"rtmpt.audio.control\" , FT_UINT8 , BASE_HEX , NULL , 0x0 , \"RTMPT Audio control\" , HFILL }\n }\n , {\n & hf_rtmpt_audio_format , {\n \"Format\" , \"rtmpt.audio.format\" , FT_UINT8 , BASE_DEC , VALS ( rtmpt_audio_codecs ) , 0xf0 , \"RTMPT Audio format\" , HFILL }\n }\n , {\n & hf_rtmpt_audio_rate , {\n \"Sample rate\" , \"rtmpt.audio.rate\" , FT_UINT8 , BASE_DEC , VALS ( rtmpt_audio_rates ) , 0x0c , \"RTMPT Audio sample rate\" , HFILL }\n }\n , {\n & hf_rtmpt_audio_size , {\n \"Sample size\" , \"rtmpt.audio.size\" , FT_UINT8 , BASE_DEC , VALS ( rtmpt_audio_sizes ) , 0x02 , \"RTMPT Audio sample size\" , HFILL }\n }\n , {\n & hf_rtmpt_audio_type , {\n \"Channels\" , \"rtmpt.audio.type\" , FT_UINT8 , BASE_DEC , VALS ( rtmpt_audio_types ) , 0x01 , \"RTMPT Audio channel count\" , HFILL }\n }\n , {\n & hf_rtmpt_audio_data , {\n \"Audio data\" , \"rtmpt.audio.data\" , FT_BYTES , BASE_NONE , NULL , 0x0 , \"RTMPT Audio data\" , HFILL }\n }\n , {\n & hf_rtmpt_video_control , {\n \"Video control\" , \"rtmpt.video.control\" , FT_UINT8 , BASE_HEX , NULL , 0x0 , \"RTMPT Video control\" , HFILL }\n }\n , {\n & hf_rtmpt_video_type , {\n \"Type\" , \"rtmpt.video.type\" , FT_UINT8 , BASE_DEC , VALS ( rtmpt_video_types ) , 0xf0 , \"RTMPT Video type\" , HFILL }\n }\n , {\n & hf_rtmpt_video_format , {\n \"Format\" , \"rtmpt.video.format\" , FT_UINT8 , BASE_DEC , VALS ( rtmpt_video_codecs ) , 0x0f , \"RTMPT Video format\" , HFILL }\n }\n , {\n & hf_rtmpt_video_data , {\n \"Video data\" , \"rtmpt.video.data\" , FT_BYTES , BASE_NONE , NULL , 0x0 , \"RTMPT Video data\" , HFILL }\n }\n , {\n & hf_rtmpt_tag_type , {\n \"Type\" , \"rtmpt.tag.type\" , FT_UINT8 , BASE_DEC , VALS ( rtmpt_tag_vals ) , 0x0 , \"RTMPT Aggregate tag type\" , HFILL }\n }\n , {\n & hf_rtmpt_tag_datasize , {\n \"Data size\" , \"rtmpt.tag.datasize\" , FT_UINT24 , BASE_DEC , NULL , 0x0 , \"RTMPT Aggregate tag data size\" , HFILL }\n }\n , {\n & hf_rtmpt_tag_timestamp , {\n \"Timestamp\" , \"rtmpt.tag.timestamp\" , FT_UINT24 , BASE_DEC , NULL , 0x0 , \"RTMPT Aggregate tag timestamp\" , HFILL }\n }\n , {\n & hf_rtmpt_tag_ets , {\n \"Timestamp Extended\" , \"rtmpt.tag.ets\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , \"RTMPT Aggregate tag timestamp extended\" , HFILL }\n }\n , {\n & hf_rtmpt_tag_streamid , {\n \"Stream ID\" , \"rtmpt.tag.streamid\" , FT_UINT24 , BASE_DEC , NULL , 0x0 , \"RTMPT Aggregate tag stream ID\" , HFILL }\n }\n , {\n & hf_rtmpt_tag_tagsize , {\n \"Previous tag size\" , \"rtmpt.tag.tagsize\" , FT_UINT32 , BASE_DEC , NULL , 0x0 , \"RTMPT Aggregate previous tag size\" , HFILL }\n }\n }\n ;\n static gint * ett [ ] = {\n & ett_rtmpt , & ett_rtmpt_handshake , & ett_rtmpt_header , & ett_rtmpt_body , & ett_rtmpt_ucm , & ett_rtmpt_audio_control , & ett_rtmpt_video_control , & ett_rtmpt_tag , & ett_rtmpt_tag_data }\n ;\n module_t * rtmpt_module ;\n proto_rtmpt = proto_register_protocol ( \"Real Time Messaging Protocol\" , \"RTMPT\" , \"rtmpt\" ) ;\n proto_register_field_array ( proto_rtmpt , hf , array_length ( hf ) ) ;\n proto_register_subtree_array ( ett , array_length ( ett ) ) ;\n rtmpt_module = prefs_register_protocol ( proto_rtmpt , NULL ) ;\n prefs_register_bool_preference ( rtmpt_module , \"desegment\" , \"Reassemble RTMPT messages spanning multiple TCP segments\" , \"Whether the RTMPT dissector should reassemble messages spanning multiple TCP segments.\" \" To use this option, you must also enable \\\"Allow subdissectors to reassemble TCP streams\\\"\" \" in the TCP protocol settings.\" , & rtmpt_desegment ) ;\n prefs_register_uint_preference ( rtmpt_module , \"max_packet_size\" , \"Maximum packet size\" , \"The largest acceptable packet size for reassembly\" , 10 , & rtmpt_max_packet_size ) ;\n }", "idx": 20604}
{"hash": 7191899184788440065, "project": "debian", "size": 23, "label": 0, "functionSource": "static int com_help ( String * buffer __attribute__ ( ( unused ) ) , char * line __attribute__ ( ( unused ) ) ) {\n reg1 int i , j ;\n char * help_arg = strchr ( line , ' ' ) , buff [ 32 ] , * end ;\n if ( help_arg ) {\n while ( my_isspace ( charset_info , * help_arg ) ) help_arg ++ ;\n if ( * help_arg ) return com_server_help ( buffer , line , help_arg ) ;\n }\n put_info ( \"\\nGeneral information about MariaDB can be found at\\n\" \"http://mariadb.org\\n\" , INFO_INFO ) ;\n put_info ( \"List of all MySQL commands:\" , INFO_INFO ) ;\n if ( ! named_cmds ) put_info ( \"Note that all text commands must be first on line and end with ';\n'\" , INFO_INFO ) ;\n for ( i = 0 ;\n commands [ i ] . name ;\n i ++ ) {\n end = strmov ( buff , commands [ i ] . name ) ;\n for ( j = ( int ) strlen ( commands [ i ] . name ) ;\n j < 10 ;\n j ++ ) end = strmov ( end , \" \" ) ;\n if ( commands [ i ] . func ) tee_fprintf ( stdout , \"%s(\\\\%c) %s\\n\" , buff , commands [ i ] . cmd_char , commands [ i ] . doc ) ;\n }\n if ( connected && mysql_get_server_version ( & mysql ) >= 40100 ) put_info ( \"\\nFor server side help, type 'help contents'\\n\" , INFO_INFO ) ;\n return 0 ;\n }", "idx": 20605}
{"hash": 7549435794356072684, "project": "debian", "size": 4, "label": 0, "functionSource": "static VALUE ossl_asn1_ ## klass ( int argc , VALUE * argv , VALUE self ) \\ {\n return rb_funcall3 ( cASN1 ## klass , rb_intern ( \"new\" ) , argc , argv ) ;\n }\n OSSL_ASN1_IMPL_FACTORY_METHOD ( Boolean ) OSSL_ASN1_IMPL_FACTORY_METHOD ( Integer ) OSSL_ASN1_IMPL_FACTORY_METHOD ( Enumerated ) OSSL_ASN1_IMPL_FACTORY_METHOD ( BitString ) OSSL_ASN1_IMPL_FACTORY_METHOD ( OctetString ) OSSL_ASN1_IMPL_FACTORY_METHOD ( UTF8String ) OSSL_ASN1_IMPL_FACTORY_METHOD ( NumericString ) OSSL_ASN1_IMPL_FACTORY_METHOD ( PrintableString ) OSSL_ASN1_IMPL_FACTORY_METHOD ( T61String )", "idx": 20606}
{"hash": 229962612204196999, "project": "debian", "size": 58, "label": 0, "functionSource": "static int delete_remote_branch ( const char * pattern , int force ) {\n struct ref * refs = remote_refs ;\n struct ref * remote_ref = NULL ;\n unsigned char head_sha1 [ 20 ] ;\n char * symref = NULL ;\n int match ;\n int patlen = strlen ( pattern ) ;\n int i ;\n struct active_request_slot * slot ;\n struct slot_results results ;\n char * url ;\n for ( match = 0 ;\n refs ;\n refs = refs -> next ) {\n char * name = refs -> name ;\n int namelen = strlen ( name ) ;\n if ( namelen < patlen || memcmp ( name + namelen - patlen , pattern , patlen ) ) continue ;\n if ( namelen != patlen && name [ namelen - patlen - 1 ] != '/' ) continue ;\n match ++ ;\n remote_ref = refs ;\n }\n if ( match == 0 ) return error ( \"No remote branch matches %s\" , pattern ) ;\n if ( match != 1 ) return error ( \"More than one remote branch matches %s\" , pattern ) ;\n fetch_symref ( \"HEAD\" , & symref , head_sha1 ) ;\n if ( ! symref ) return error ( \"Remote HEAD is not a symref\" ) ;\n for ( i = 0 ;\n symref && i < MAXDEPTH ;\n i ++ ) {\n if ( ! strcmp ( remote_ref -> name , symref ) ) return error ( \"Remote branch %s is the current HEAD\" , remote_ref -> name ) ;\n fetch_symref ( symref , & symref , head_sha1 ) ;\n }\n if ( ! force ) {\n if ( symref ) return error ( \"Remote HEAD symrefs too deep\" ) ;\n if ( is_null_sha1 ( head_sha1 ) ) return error ( \"Unable to resolve remote HEAD\" ) ;\n if ( ! has_sha1_file ( head_sha1 ) ) return error ( \"Remote HEAD resolves to object %s\\nwhich does not exist locally, perhaps you need to fetch?\" , sha1_to_hex ( head_sha1 ) ) ;\n if ( is_null_oid ( & remote_ref -> old_oid ) ) return error ( \"Unable to resolve remote branch %s\" , remote_ref -> name ) ;\n if ( ! has_object_file ( & remote_ref -> old_oid ) ) return error ( \"Remote branch %s resolves to object %s\\nwhich does not exist locally, perhaps you need to fetch?\" , remote_ref -> name , oid_to_hex ( & remote_ref -> old_oid ) ) ;\n if ( ! verify_merge_base ( head_sha1 , remote_ref ) ) {\n return error ( \"The branch '%s' is not an ancestor \" \"of your current HEAD.\\n\" \"If you are sure you want to delete it,\" \" run:\\n\\t'git http-push -D %s %s'\" , remote_ref -> name , repo -> url , pattern ) ;\n }\n }\n fprintf ( stderr , \"Removing remote branch '%s'\\n\" , remote_ref -> name ) ;\n if ( dry_run ) return 0 ;\n url = xstrfmt ( \"%s%s\" , repo -> url , remote_ref -> name ) ;\n slot = get_active_slot ( ) ;\n slot -> results = & results ;\n curl_setup_http_get ( slot -> curl , url , DAV_DELETE ) ;\n if ( start_active_slot ( slot ) ) {\n run_active_slot ( slot ) ;\n free ( url ) ;\n if ( results . curl_result != CURLE_OK ) return error ( \"DELETE request failed (%d/%ld)\" , results . curl_result , results . http_code ) ;\n }\n else {\n free ( url ) ;\n return error ( \"Unable to start DELETE request\" ) ;\n }\n return 0 ;\n }", "idx": 20607}
{"hash": 1223258652239369123, "project": "debian", "size": 17, "label": 0, "functionSource": "SPL_METHOD ( SplFileObject , seek ) {\n spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n long line_pos ;\n if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , \"l\" , & line_pos ) == FAILURE ) {\n return ;\n }\n if ( line_pos < 0 ) {\n zend_throw_exception_ex ( spl_ce_LogicException , 0 TSRMLS_CC , \"Can't seek file %s to negative line %ld\" , intern -> file_name , line_pos ) ;\n RETURN_FALSE ;\n }\n spl_filesystem_file_rewind ( getThis ( ) , intern TSRMLS_CC ) ;\n while ( intern -> u . file . current_line_num < line_pos ) {\n if ( spl_filesystem_file_read_line ( getThis ( ) , intern , 1 TSRMLS_CC ) == FAILURE ) {\n break ;\n }\n }\n }", "idx": 20608}
{"hash": -6552851419396579257, "project": "debian", "size": 12, "label": 0, "functionSource": "static int dissect_USER_LEVEL_1 ( tvbuff_t * tvb , int offset , packet_info * pinfo , proto_tree * tree , dcerpc_info * di , guint8 * drep ) {\n guint32 level ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , tree , di , drep , hf_level , & level ) ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , tree , di , drep , hf_userlevel_size , NULL ) ;\n offset = dissect_ndr_str_pointer_item ( tvb , offset , pinfo , tree , di , drep , NDR_POINTER_UNIQUE , \"Client\" , hf_userlevel_client , 0 ) ;\n offset = dissect_ndr_str_pointer_item ( tvb , offset , pinfo , tree , di , drep , NDR_POINTER_UNIQUE , \"User\" , hf_userlevel_user , 0 ) ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , tree , di , drep , hf_userlevel_build , NULL ) ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , tree , di , drep , hf_userlevel_major , NULL ) ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , tree , di , drep , hf_userlevel_minor , NULL ) ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , tree , di , drep , hf_userlevel_processor , NULL ) ;\n return offset ;\n }", "idx": 20609}
{"hash": 237530479040685467, "project": "chrome", "size": 18, "label": 1, "functionSource": "static UConverter * _HZ_SafeClone ( const UConverter * cnv , void * stackBuffer , int32_t * pBufferSize , UErrorCode * status ) {\n struct cloneHZStruct * localClone ;\n int32_t size , bufferSizeNeeded = sizeof ( struct cloneHZStruct ) ;\n if ( U_FAILURE ( * status ) ) {\n return 0 ;\n }\n if ( * pBufferSize == 0 ) {\n * pBufferSize = bufferSizeNeeded ;\n return 0 ;\n }\n localClone = ( struct cloneHZStruct * ) stackBuffer ;\n uprv_memcpy ( & localClone -> mydata , cnv -> extraInfo , sizeof ( UConverterDataHZ ) ) ;\n localClone -> cnv . extraInfo = & localClone -> mydata ;\n localClone -> cnv . isExtraLocal = TRUE ;\n size = ( int32_t ) ( sizeof ( UConverter ) + sizeof ( UAlignedMemory ) ) ;\n ( ( UConverterDataHZ * ) localClone -> cnv . extraInfo ) -> gbConverter = ucnv_safeClone ( ( ( UConverterDataHZ * ) cnv -> extraInfo ) -> gbConverter , & localClone -> subCnv , & size , status ) ;\n return & localClone -> cnv ;\n }", "idx": 20610}
{"hash": 1760449185745615462, "project": "debian", "size": 5, "label": 0, "functionSource": "void * TSContDataGet ( TSCont contp ) {\n sdk_assert ( sdk_sanity_check_iocore_structure ( contp ) == TS_SUCCESS ) ;\n INKContInternal * i = ( INKContInternal * ) contp ;\n return i -> mdata ;\n }", "idx": 20611}
{"hash": -5420171864670538459, "project": "debian", "size": 10, "label": 0, "functionSource": "int64_t cpu_get_clock ( void ) {\n int64_t ti ;\n if ( ! timers_state . cpu_ticks_enabled ) {\n return timers_state . cpu_clock_offset ;\n }\n else {\n ti = get_clock ( ) ;\n return ti + timers_state . cpu_clock_offset ;\n }\n }", "idx": 20612}
{"hash": 4991783214228010911, "project": "debian", "size": 337, "label": 0, "functionSource": "int jbig2_decode_text_region ( Jbig2Ctx * ctx , Jbig2Segment * segment , const Jbig2TextRegionParams * params , const Jbig2SymbolDict * const * dicts , const uint32_t n_dicts , Jbig2Image * image , const byte * data , const size_t size , Jbig2ArithCx * GR_stats , Jbig2ArithState * as , Jbig2WordStream * ws ) {\n uint32_t NINSTANCES ;\n uint32_t ID ;\n int32_t STRIPT ;\n int32_t FIRSTS ;\n int32_t DT ;\n int32_t DFS ;\n int32_t IDS ;\n int32_t CURS ;\n int32_t CURT ;\n int S , T ;\n int x , y ;\n bool first_symbol ;\n uint32_t index , SBNUMSYMS ;\n Jbig2Image * IB = NULL ;\n Jbig2HuffmanState * hs = NULL ;\n Jbig2HuffmanTable * SBSYMCODES = NULL ;\n int code = 0 ;\n int RI ;\n SBNUMSYMS = 0 ;\n for ( index = 0 ;\n index < n_dicts ;\n index ++ ) {\n SBNUMSYMS += dicts [ index ] -> n_symbols ;\n }\n jbig2_error ( ctx , JBIG2_SEVERITY_DEBUG , segment -> number , \"symbol list contains %d glyphs in %d dictionaries\" , SBNUMSYMS , n_dicts ) ;\n if ( params -> SBHUFF ) {\n Jbig2HuffmanTable * runcodes = NULL ;\n Jbig2HuffmanParams runcodeparams ;\n Jbig2HuffmanLine runcodelengths [ 35 ] ;\n Jbig2HuffmanLine * symcodelengths = NULL ;\n Jbig2HuffmanParams symcodeparams ;\n int err , len , range , r ;\n jbig2_error ( ctx , JBIG2_SEVERITY_DEBUG , segment -> number , \"huffman coded text region\" ) ;\n hs = jbig2_huffman_new ( ctx , ws ) ;\n if ( hs == NULL ) {\n jbig2_error ( ctx , JBIG2_SEVERITY_WARNING , segment -> number , \"failed to allocate storage for text region\" ) ;\n return - 1 ;\n }\n for ( index = 0 ;\n index < 35 ;\n index ++ ) {\n runcodelengths [ index ] . PREFLEN = jbig2_huffman_get_bits ( hs , 4 , & code ) ;\n if ( code < 0 ) goto cleanup1 ;\n runcodelengths [ index ] . RANGELEN = 0 ;\n runcodelengths [ index ] . RANGELOW = index ;\n jbig2_error ( ctx , JBIG2_SEVERITY_DEBUG , segment -> number , \" read runcode%d length %d\" , index , runcodelengths [ index ] . PREFLEN ) ;\n }\n runcodeparams . HTOOB = 0 ;\n runcodeparams . lines = runcodelengths ;\n runcodeparams . n_lines = 35 ;\n runcodes = jbig2_build_huffman_table ( ctx , & runcodeparams ) ;\n if ( runcodes == NULL ) {\n jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"error constructing symbol id runcode table!\" ) ;\n code = - 1 ;\n goto cleanup1 ;\n }\n symcodelengths = jbig2_new ( ctx , Jbig2HuffmanLine , SBNUMSYMS ) ;\n if ( symcodelengths == NULL ) {\n jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"memory allocation failure reading symbol ID huffman table!\" ) ;\n code = - 1 ;\n goto cleanup1 ;\n }\n index = 0 ;\n while ( index < SBNUMSYMS ) {\n code = jbig2_huffman_get ( hs , runcodes , & err ) ;\n if ( err != 0 || code < 0 || code >= 35 ) {\n jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"error reading symbol ID huffman table!\" ) ;\n code = err ? err : - 1 ;\n goto cleanup1 ;\n }\n if ( code < 32 ) {\n len = code ;\n range = 1 ;\n }\n else {\n if ( code == 32 ) {\n if ( index < 1 ) {\n jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"error decoding symbol id table: run length with no antecedent!\" ) ;\n code = - 1 ;\n goto cleanup1 ;\n }\n len = symcodelengths [ index - 1 ] . PREFLEN ;\n }\n else {\n len = 0 ;\n }\n err = 0 ;\n if ( code == 32 ) range = jbig2_huffman_get_bits ( hs , 2 , & err ) + 3 ;\n else if ( code == 33 ) range = jbig2_huffman_get_bits ( hs , 3 , & err ) + 3 ;\n else if ( code == 34 ) range = jbig2_huffman_get_bits ( hs , 7 , & err ) + 11 ;\n if ( err < 0 ) goto cleanup1 ;\n }\n jbig2_error ( ctx , JBIG2_SEVERITY_DEBUG , segment -> number , \" read runcode%d at index %d (length %d range %d)\" , code , index , len , range ) ;\n if ( index + range > SBNUMSYMS ) {\n jbig2_error ( ctx , JBIG2_SEVERITY_WARNING , segment -> number , \"runlength extends %d entries beyond the end of symbol id table!\" , index + range - SBNUMSYMS ) ;\n range = SBNUMSYMS - index ;\n }\n for ( r = 0 ;\n r < range ;\n r ++ ) {\n symcodelengths [ index + r ] . PREFLEN = len ;\n symcodelengths [ index + r ] . RANGELEN = 0 ;\n symcodelengths [ index + r ] . RANGELOW = index + r ;\n }\n index += r ;\n }\n if ( index < SBNUMSYMS ) {\n jbig2_error ( ctx , JBIG2_SEVERITY_WARNING , segment -> number , \"runlength codes do not cover the available symbol set\" ) ;\n }\n symcodeparams . HTOOB = 0 ;\n symcodeparams . lines = symcodelengths ;\n symcodeparams . n_lines = SBNUMSYMS ;\n jbig2_huffman_skip ( hs ) ;\n SBSYMCODES = jbig2_build_huffman_table ( ctx , & symcodeparams ) ;\n cleanup1 : jbig2_free ( ctx -> allocator , symcodelengths ) ;\n jbig2_release_huffman_table ( ctx , runcodes ) ;\n if ( SBSYMCODES == NULL ) {\n jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"could not construct Symbol ID huffman table!\" ) ;\n jbig2_huffman_free ( ctx , hs ) ;\n return ( ( code != 0 ) ? code : - 1 ) ;\n }\n }\n jbig2_image_clear ( ctx , image , params -> SBDEFPIXEL ) ;\n if ( params -> SBHUFF ) {\n STRIPT = jbig2_huffman_get ( hs , params -> SBHUFFDT , & code ) ;\n }\n else {\n code = jbig2_arith_int_decode ( params -> IADT , as , & STRIPT ) ;\n }\n if ( code < 0 ) goto cleanup2 ;\n STRIPT *= - ( params -> SBSTRIPS ) ;\n FIRSTS = 0 ;\n NINSTANCES = 0 ;\n while ( NINSTANCES < params -> SBNUMINSTANCES ) {\n if ( params -> SBHUFF ) {\n DT = jbig2_huffman_get ( hs , params -> SBHUFFDT , & code ) ;\n }\n else {\n code = jbig2_arith_int_decode ( params -> IADT , as , & DT ) ;\n }\n if ( code < 0 ) goto cleanup2 ;\n DT *= params -> SBSTRIPS ;\n STRIPT += DT ;\n first_symbol = TRUE ;\n for ( ;\n ;\n ) {\n if ( first_symbol ) {\n if ( params -> SBHUFF ) {\n DFS = jbig2_huffman_get ( hs , params -> SBHUFFFS , & code ) ;\n }\n else {\n code = jbig2_arith_int_decode ( params -> IAFS , as , & DFS ) ;\n }\n if ( code < 0 ) goto cleanup2 ;\n FIRSTS += DFS ;\n CURS = FIRSTS ;\n first_symbol = FALSE ;\n }\n else {\n if ( NINSTANCES > params -> SBNUMINSTANCES ) {\n code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"too many NINSTANCES (%d) decoded\" , NINSTANCES ) ;\n break ;\n }\n if ( params -> SBHUFF ) {\n IDS = jbig2_huffman_get ( hs , params -> SBHUFFDS , & code ) ;\n }\n else {\n code = jbig2_arith_int_decode ( params -> IADS , as , & IDS ) ;\n }\n if ( code ) {\n break ;\n }\n CURS += IDS + params -> SBDSOFFSET ;\n }\n if ( params -> SBSTRIPS == 1 ) {\n CURT = 0 ;\n }\n else if ( params -> SBHUFF ) {\n CURT = jbig2_huffman_get_bits ( hs , params -> LOGSBSTRIPS , & code ) ;\n }\n else {\n code = jbig2_arith_int_decode ( params -> IAIT , as , & CURT ) ;\n }\n if ( code < 0 ) goto cleanup2 ;\n T = STRIPT + CURT ;\n if ( params -> SBHUFF ) {\n ID = jbig2_huffman_get ( hs , SBSYMCODES , & code ) ;\n }\n else {\n code = jbig2_arith_iaid_decode ( params -> IAID , as , ( int * ) & ID ) ;\n }\n if ( code < 0 ) goto cleanup2 ;\n if ( ID >= SBNUMSYMS ) {\n code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"symbol id out of range! (%d/%d)\" , ID , SBNUMSYMS ) ;\n goto cleanup2 ;\n }\n {\n uint32_t id = ID ;\n index = 0 ;\n while ( id >= dicts [ index ] -> n_symbols ) id -= dicts [ index ++ ] -> n_symbols ;\n IB = jbig2_image_clone ( ctx , dicts [ index ] -> glyphs [ id ] ) ;\n if ( ! IB ) {\n code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"missing glyph %d/%d!\" , index , id ) ;\n goto cleanup2 ;\n }\n }\n if ( params -> SBREFINE ) {\n if ( params -> SBHUFF ) {\n RI = jbig2_huffman_get_bits ( hs , 1 , & code ) ;\n }\n else {\n code = jbig2_arith_int_decode ( params -> IARI , as , & RI ) ;\n }\n if ( code < 0 ) goto cleanup2 ;\n }\n else {\n RI = 0 ;\n }\n if ( RI ) {\n Jbig2RefinementRegionParams rparams ;\n Jbig2Image * IBO ;\n int32_t RDW , RDH , RDX , RDY ;\n Jbig2Image * refimage ;\n int BMSIZE = 0 ;\n int code1 = 0 ;\n int code2 = 0 ;\n int code3 = 0 ;\n int code4 = 0 ;\n int code5 = 0 ;\n if ( ! params -> SBHUFF ) {\n code1 = jbig2_arith_int_decode ( params -> IARDW , as , & RDW ) ;\n code2 = jbig2_arith_int_decode ( params -> IARDH , as , & RDH ) ;\n code3 = jbig2_arith_int_decode ( params -> IARDX , as , & RDX ) ;\n code4 = jbig2_arith_int_decode ( params -> IARDY , as , & RDY ) ;\n }\n else {\n RDW = jbig2_huffman_get ( hs , params -> SBHUFFRDW , & code1 ) ;\n RDH = jbig2_huffman_get ( hs , params -> SBHUFFRDH , & code2 ) ;\n RDX = jbig2_huffman_get ( hs , params -> SBHUFFRDX , & code3 ) ;\n RDY = jbig2_huffman_get ( hs , params -> SBHUFFRDY , & code4 ) ;\n BMSIZE = jbig2_huffman_get ( hs , params -> SBHUFFRSIZE , & code5 ) ;\n jbig2_huffman_skip ( hs ) ;\n }\n if ( ( code1 < 0 ) || ( code2 < 0 ) || ( code3 < 0 ) || ( code4 < 0 ) || ( code5 < 0 ) ) {\n code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"failed to decode data\" ) ;\n goto cleanup2 ;\n }\n IBO = IB ;\n refimage = jbig2_image_new ( ctx , IBO -> width + RDW , IBO -> height + RDH ) ;\n if ( refimage == NULL ) {\n jbig2_image_release ( ctx , IBO ) ;\n if ( params -> SBHUFF ) {\n jbig2_release_huffman_table ( ctx , SBSYMCODES ) ;\n }\n return jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"couldn't allocate reference image\" ) ;\n }\n jbig2_image_clear ( ctx , refimage , 0x00 ) ;\n rparams . GRTEMPLATE = params -> SBRTEMPLATE ;\n rparams . reference = IBO ;\n rparams . DX = ( RDW >> 1 ) + RDX ;\n rparams . DY = ( RDH >> 1 ) + RDY ;\n rparams . TPGRON = 0 ;\n memcpy ( rparams . grat , params -> sbrat , 4 ) ;\n code = jbig2_decode_refinement_region ( ctx , segment , & rparams , as , refimage , GR_stats ) ;\n if ( code < 0 ) {\n jbig2_image_release ( ctx , refimage ) ;\n goto cleanup2 ;\n }\n IB = refimage ;\n jbig2_image_release ( ctx , IBO ) ;\n if ( params -> SBHUFF ) {\n jbig2_huffman_advance ( hs , BMSIZE ) ;\n }\n }\n if ( ( ! params -> TRANSPOSED ) && ( params -> REFCORNER > 1 ) ) {\n CURS += IB -> width - 1 ;\n }\n else if ( ( params -> TRANSPOSED ) && ! ( params -> REFCORNER & 1 ) ) {\n CURS += IB -> height - 1 ;\n }\n S = CURS ;\n if ( ! params -> TRANSPOSED ) {\n switch ( params -> REFCORNER ) {\n case JBIG2_CORNER_TOPLEFT : x = S ;\n y = T ;\n break ;\n case JBIG2_CORNER_TOPRIGHT : x = S - IB -> width + 1 ;\n y = T ;\n break ;\n case JBIG2_CORNER_BOTTOMLEFT : x = S ;\n y = T - IB -> height + 1 ;\n break ;\n default : case JBIG2_CORNER_BOTTOMRIGHT : x = S - IB -> width + 1 ;\n y = T - IB -> height + 1 ;\n break ;\n }\n }\n else {\n switch ( params -> REFCORNER ) {\n case JBIG2_CORNER_TOPLEFT : x = T ;\n y = S ;\n break ;\n case JBIG2_CORNER_TOPRIGHT : x = T - IB -> width + 1 ;\n y = S ;\n break ;\n case JBIG2_CORNER_BOTTOMLEFT : x = T ;\n y = S - IB -> height + 1 ;\n break ;\n default : case JBIG2_CORNER_BOTTOMRIGHT : x = T - IB -> width + 1 ;\n y = S - IB -> height + 1 ;\n break ;\n }\n }\n # ifdef JBIG2_DEBUG jbig2_error ( ctx , JBIG2_SEVERITY_DEBUG , segment -> number , \"composing glyph id %d: %dx%d @ (%d,%d) symbol %d/%d\" , ID , IB -> width , IB -> height , x , y , NINSTANCES + 1 , params -> SBNUMINSTANCES ) ;\n # endif code = jbig2_image_compose ( ctx , image , IB , x , y , params -> SBCOMBOP ) ;\n if ( code < 0 ) {\n jbig2_image_release ( ctx , IB ) ;\n goto cleanup2 ;\n }\n if ( ( ! params -> TRANSPOSED ) && ( params -> REFCORNER < 2 ) ) {\n CURS += IB -> width - 1 ;\n }\n else if ( ( params -> TRANSPOSED ) && ( params -> REFCORNER & 1 ) ) {\n CURS += IB -> height - 1 ;\n }\n NINSTANCES ++ ;\n jbig2_image_release ( ctx , IB ) ;\n }\n }\n cleanup2 : if ( params -> SBHUFF ) {\n jbig2_release_huffman_table ( ctx , SBSYMCODES ) ;\n }\n jbig2_huffman_free ( ctx , hs ) ;\n return code ;\n }", "idx": 20613}
{"hash": 7545838748510052337, "project": "debian", "size": 11, "label": 0, "functionSource": "void feTimestampDifference ( int64 start_time , int64 stop_time , long * secs , int * microsecs ) {\n int64 diff = stop_time - start_time ;\n if ( diff <= 0 ) {\n * secs = 0 ;\n * microsecs = 0 ;\n }\n else {\n * secs = ( long ) ( diff / USECS_PER_SEC ) ;\n * microsecs = ( int ) ( diff % USECS_PER_SEC ) ;\n }\n }", "idx": 20614}
{"hash": 2820551931453396101, "project": "debian", "size": 40, "label": 0, "functionSource": "jas_image_t * jas_image_create ( int numcmpts , jas_image_cmptparm_t * cmptparms , int clrspc ) {\n jas_image_t * image ;\n uint_fast32_t rawsize ;\n uint_fast32_t inmem ;\n int cmptno ;\n jas_image_cmptparm_t * cmptparm ;\n if ( ! ( image = jas_image_create0 ( ) ) ) {\n return 0 ;\n }\n image -> clrspc_ = clrspc ;\n image -> maxcmpts_ = numcmpts ;\n image -> inmem_ = true ;\n if ( ! ( image -> cmpts_ = jas_malloc ( image -> maxcmpts_ * sizeof ( jas_image_cmpt_t * ) ) ) ) {\n jas_image_destroy ( image ) ;\n return 0 ;\n }\n for ( cmptno = 0 ;\n cmptno < image -> maxcmpts_ ;\n ++ cmptno ) {\n image -> cmpts_ [ cmptno ] = 0 ;\n }\n rawsize = 0 ;\n for ( cmptno = 0 , cmptparm = cmptparms ;\n cmptno < numcmpts ;\n ++ cmptno , ++ cmptparm ) {\n rawsize += cmptparm -> width * cmptparm -> height * ( cmptparm -> prec + 7 ) / 8 ;\n }\n inmem = ( rawsize < JAS_IMAGE_INMEMTHRESH ) ;\n for ( cmptno = 0 , cmptparm = cmptparms ;\n cmptno < numcmpts ;\n ++ cmptno , ++ cmptparm ) {\n if ( ! ( image -> cmpts_ [ cmptno ] = jas_image_cmpt_create ( cmptparm -> tlx , cmptparm -> tly , cmptparm -> hstep , cmptparm -> vstep , cmptparm -> width , cmptparm -> height , cmptparm -> prec , cmptparm -> sgnd , inmem ) ) ) {\n jas_image_destroy ( image ) ;\n return 0 ;\n }\n ++ image -> numcmpts_ ;\n }\n jas_image_setbbox ( image ) ;\n return image ;\n }", "idx": 20615}
{"hash": -2943582541244387919, "project": "chrome", "size": 5, "label": 0, "functionSource": "unsigned int vp9_mse8x8_c ( const uint8_t * src , int src_stride , const uint8_t * ref , int ref_stride , unsigned int * sse ) {\n int sum ;\n variance ( src , src_stride , ref , ref_stride , 8 , 8 , sse , & sum ) ;\n return * sse ;\n }", "idx": 20616}
{"hash": -7187272991279783781, "project": "debian", "size": 14, "label": 0, "functionSource": "static void cpu_set_irq ( void * opaque , int irq , int level ) {\n SPARCCPU * cpu = opaque ;\n CPUSPARCState * env = & cpu -> env ;\n if ( level ) {\n trace_sun4m_cpu_set_irq_raise ( irq ) ;\n env -> pil_in |= 1 << irq ;\n cpu_kick_irq ( cpu ) ;\n }\n else {\n trace_sun4m_cpu_set_irq_lower ( irq ) ;\n env -> pil_in &= ~ ( 1 << irq ) ;\n cpu_check_irqs ( env ) ;\n }\n }", "idx": 20617}
{"hash": 8572106347813672436, "project": "debian", "size": 3, "label": 0, "functionSource": "static uint8_t pfkey_proto_from_xfrm ( uint8_t proto ) {\n return proto ? proto : IPSEC_PROTO_ANY ;\n }", "idx": 20618}
{"hash": -5082285935423529157, "project": "debian", "size": 24, "label": 0, "functionSource": "static int dissect_rsl_ie_cbch_load_inf ( tvbuff_t * tvb , packet_info * pinfo _U_ , proto_tree * tree , int offset , gboolean is_mandatory ) {\n proto_item * item ;\n proto_tree * ie_tree ;\n guint8 ie_id ;\n guint8 octet ;\n if ( is_mandatory == FALSE ) {\n ie_id = tvb_get_guint8 ( tvb , offset ) ;\n if ( ie_id != RSL_IE_CBCH_LOAD_INF ) return offset ;\n }\n ie_tree = proto_tree_add_subtree ( tree , tvb , offset , 0 , ett_ie_cbch_load_inf , NULL , \"CBCH Load Information IE\" ) ;\n proto_tree_add_item ( ie_tree , hf_rsl_ie_id , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n offset ++ ;\n octet = tvb_get_guint8 ( tvb , offset ) ;\n proto_tree_add_item ( ie_tree , hf_rsl_cbch_load_type , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n item = proto_tree_add_item ( ie_tree , hf_rsl_msg_slt_cnt , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n if ( ( octet & 0x80 ) == 0x80 ) {\n proto_item_append_text ( item , \"The amount of SMSCB messages (1 to 15) that are needed immediately by BTS\" ) ;\n }\n else {\n proto_item_append_text ( item , \"The amount of delay in message slots (1 to 15) that is needed immediately by BTS\" ) ;\n }\n offset ++ ;\n return offset ;\n }", "idx": 20619}
{"hash": 6302861533225984845, "project": "debian", "size": 6, "label": 0, "functionSource": "static void pxa2xx_rtc_hzupdate ( PXA2xxRTCState * s ) {\n int64_t rt = qemu_get_clock_ms ( rtc_clock ) ;\n s -> last_rcnr += ( ( rt - s -> last_hz ) << 15 ) / ( 1000 * ( ( s -> rttr & 0xffff ) + 1 ) ) ;\n s -> last_rdcr += ( ( rt - s -> last_hz ) << 15 ) / ( 1000 * ( ( s -> rttr & 0xffff ) + 1 ) ) ;\n s -> last_hz = rt ;\n }", "idx": 20620}
{"hash": 2687336064028423153, "project": "chrome", "size": 14, "label": 0, "functionSource": "static void search_state_decref ( struct search_state * const state ) {\n if ( ! state ) return ;\n state -> refcount -- ;\n if ( ! state -> refcount ) {\n struct search_domain * next , * dom ;\n for ( dom = state -> head ;\n dom ;\n dom = next ) {\n next = dom -> next ;\n free ( dom ) ;\n }\n free ( state ) ;\n }\n }", "idx": 20621}
{"hash": 3599206110384554647, "project": "debian", "size": 40, "label": 0, "functionSource": "static ossl_inline void lh_ ## type ## _free ( LHASH_OF ( type ) * lh ) {\n OPENSSL_LH_free ( ( OPENSSL_LHASH * ) lh ) ;\n }\n static ossl_inline type * lh_ ## type ## _insert ( LHASH_OF ( type ) * lh , type * d ) {\n return ( type * ) OPENSSL_LH_insert ( ( OPENSSL_LHASH * ) lh , d ) ;\n }\n static ossl_inline type * lh_ ## type ## _delete ( LHASH_OF ( type ) * lh , const type * d ) {\n return ( type * ) OPENSSL_LH_delete ( ( OPENSSL_LHASH * ) lh , d ) ;\n }\n static ossl_inline type * lh_ ## type ## _retrieve ( LHASH_OF ( type ) * lh , const type * d ) {\n return ( type * ) OPENSSL_LH_retrieve ( ( OPENSSL_LHASH * ) lh , d ) ;\n }\n static ossl_inline int lh_ ## type ## _error ( LHASH_OF ( type ) * lh ) {\n return OPENSSL_LH_error ( ( OPENSSL_LHASH * ) lh ) ;\n }\n static ossl_inline unsigned long lh_ ## type ## _num_items ( LHASH_OF ( type ) * lh ) {\n return OPENSSL_LH_num_items ( ( OPENSSL_LHASH * ) lh ) ;\n }\n static ossl_inline void lh_ ## type ## _node_stats_bio ( const LHASH_OF ( type ) * lh , BIO * out ) {\n OPENSSL_LH_node_stats_bio ( ( const OPENSSL_LHASH * ) lh , out ) ;\n }\n static ossl_inline void lh_ ## type ## _node_usage_stats_bio ( const LHASH_OF ( type ) * lh , BIO * out ) {\n OPENSSL_LH_node_usage_stats_bio ( ( const OPENSSL_LHASH * ) lh , out ) ;\n }\n static ossl_inline void lh_ ## type ## _stats_bio ( const LHASH_OF ( type ) * lh , BIO * out ) {\n OPENSSL_LH_stats_bio ( ( const OPENSSL_LHASH * ) lh , out ) ;\n }\n static ossl_inline unsigned long lh_ ## type ## _get_down_load ( LHASH_OF ( type ) * lh ) {\n return OPENSSL_LH_get_down_load ( ( OPENSSL_LHASH * ) lh ) ;\n }\n static ossl_inline void lh_ ## type ## _set_down_load ( LHASH_OF ( type ) * lh , unsigned long dl ) {\n OPENSSL_LH_set_down_load ( ( OPENSSL_LHASH * ) lh , dl ) ;\n }\n static ossl_inline void lh_ ## type ## _doall ( LHASH_OF ( type ) * lh , void ( * doall ) ( type * ) ) {\n OPENSSL_LH_doall ( ( OPENSSL_LHASH * ) lh , ( OPENSSL_LH_DOALL_FUNC ) doall ) ;\n }\n LHASH_OF ( type ) # define IMPLEMENT_LHASH_DOALL_ARG_CONST ( type , argtype ) int_implement_lhash_doall ( type , argtype , const type ) # define IMPLEMENT_LHASH_DOALL_ARG ( type , argtype ) int_implement_lhash_doall ( type , argtype , type ) # define int_implement_lhash_doall ( type , argtype , cbargtype ) static ossl_inline void lh_ ## type ## _doall_ ## argtype ( LHASH_OF ( type ) * lh , void ( * fn ) ( cbargtype * , argtype * ) , argtype * arg ) {\n OPENSSL_LH_doall_arg ( ( OPENSSL_LHASH * ) lh , ( OPENSSL_LH_DOALL_FUNCARG ) fn , ( void * ) arg ) ;\n }\n LHASH_OF ( type ) DEFINE_LHASH_OF ( OPENSSL_STRING )", "idx": 20622}
{"hash": 4537091194729139981, "project": "chrome", "size": 7, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( FullscreenControllerInteractiveTest , DISABLED_BrowserFullscreenAfterTabFSExit ) {\n ASSERT_NO_FATAL_FAILURE ( ToggleBrowserFullscreen ( true ) ) ;\n AddTabAtIndex ( 0 , GURL ( url : : kAboutBlankURL ) , PAGE_TRANSITION_TYPED ) ;\n ASSERT_NO_FATAL_FAILURE ( ToggleTabFullscreen ( true ) ) ;\n ASSERT_NO_FATAL_FAILURE ( ToggleTabFullscreen ( false ) ) ;\n ASSERT_TRUE ( IsFullscreenForBrowser ( ) ) ;\n }", "idx": 20623}
{"hash": 7039307292471244756, "project": "debian", "size": 24, "label": 0, "functionSource": "static void dtap_bcc_imm_setup ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len ) {\n guint32 curr_offset ;\n guint32 consumed ;\n guint curr_len ;\n guint8 oct ;\n proto_tree * subtree ;\n curr_offset = offset ;\n curr_len = len ;\n oct = tvb_get_guint8 ( tvb , curr_offset ) ;\n proto_tree_add_bits_item ( tree , hf_gsm_a_spare_bits , tvb , curr_offset << 3 , 4 , ENC_BIG_ENDIAN ) ;\n subtree = proto_tree_add_subtree ( tree , tvb , curr_offset , 1 , ett_gsm_common_elem [ DE_CIPH_KEY_SEQ_NUM ] , NULL , val_to_str_ext_const ( DE_CIPH_KEY_SEQ_NUM , & gsm_common_elem_strings_ext , \"\" ) ) ;\n proto_tree_add_bits_item ( subtree , hf_gsm_a_spare_bits , tvb , ( curr_offset << 3 ) + 4 , 1 , ENC_BIG_ENDIAN ) ;\n switch ( oct & 0x07 ) {\n case 0x07 : proto_tree_add_uint_format_value ( subtree , hf_gsm_a_dtap_ciphering_key_sequence_number , tvb , curr_offset , 1 , oct , \"No key is available\" ) ;\n break ;\n default : proto_tree_add_item ( subtree , hf_gsm_a_dtap_ciphering_key_sequence_number , tvb , curr_offset , 1 , ENC_BIG_ENDIAN ) ;\n break ;\n }\n curr_offset ++ ;\n curr_len -- ;\n ELEM_MAND_LV ( GSM_A_PDU_TYPE_COMMON , DE_MS_CM_2 , NULL ) ;\n ELEM_MAND_LV ( GSM_A_PDU_TYPE_COMMON , DE_MID , NULL ) ;\n ELEM_MAND_V ( GSM_A_PDU_TYPE_DTAP , DE_BCC_CALL_REF , \"(Broadcast identity)\" ) ;\n }", "idx": 20624}
{"hash": -2386031673786599357, "project": "debian", "size": 8, "label": 0, "functionSource": "static gpgme_error_t add_io_cb ( engine_gpgsm_t gpgsm , iocb_data_t * iocbd , gpgme_io_cb_t handler ) {\n gpgme_error_t err ;\n TRACE_BEG2 ( DEBUG_ENGINE , \"engine-gpgsm:add_io_cb\" , gpgsm , \"fd %d, dir %d\" , iocbd -> fd , iocbd -> dir ) ;\n err = ( * gpgsm -> io_cbs . add ) ( gpgsm -> io_cbs . add_priv , iocbd -> fd , iocbd -> dir , handler , iocbd -> data , & iocbd -> tag ) ;\n if ( err ) return TRACE_ERR ( err ) ;\n if ( ! iocbd -> dir ) err = _gpgme_io_set_nonblocking ( iocbd -> fd ) ;\n return TRACE_ERR ( err ) ;\n }", "idx": 20625}
{"hash": 1245821301839614810, "project": "debian", "size": 8, "label": 0, "functionSource": "static void mark_desktop_file_executable_task_done ( GObject * source_object , GAsyncResult * res , gpointer user_data ) {\n MarkTrustedJob * job = user_data ;\n g_object_unref ( job -> file ) ;\n if ( job -> done_callback ) {\n job -> done_callback ( ! job_aborted ( ( CommonJob * ) job ) , job -> done_callback_data ) ;\n }\n finalize_common ( ( CommonJob * ) job ) ;\n }", "idx": 20626}
{"hash": 7039307292471244756, "project": "debian", "size": 18, "label": 0, "functionSource": "static guint16 de_call_state ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len _U_ , gchar * add_string _U_ , int string_len _U_ ) {\n guint8 oct , coding_standard , call_state ;\n proto_tree * subtree ;\n subtree = proto_tree_add_subtree ( tree , tvb , offset , 1 , ett_gsm_dtap_elem [ DE_CALL_STATE ] , NULL , val_to_str_ext_const ( DE_CALL_STATE , & gsm_dtap_elem_strings_ext , \"\" ) ) ;\n proto_tree_add_item ( subtree , hf_gsm_a_dtap_coding_standard , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n oct = tvb_get_guint8 ( tvb , offset ) ;\n coding_standard = ( oct & 0xc0 ) >> 6 ;\n call_state = oct & 0x3f ;\n switch ( coding_standard ) {\n case 0 : proto_tree_add_uint_format_value ( subtree , hf_gsm_a_dtap_call_state , tvb , offset , 1 , call_state , \"%s (%u)\" , val_to_str_ext_const ( call_state , & q931_call_state_vals_ext , \"Reserved\" ) , call_state ) ;\n break ;\n case 1 : case 2 : proto_tree_add_item ( subtree , hf_gsm_a_dtap_call_state , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n break ;\n default : proto_tree_add_uint_format_value ( subtree , hf_gsm_a_dtap_call_state , tvb , offset , 1 , call_state , \"%s (%u)\" , val_to_str_const ( call_state , gsm_a_dtap_call_state_vals , \"Reserved\" ) , call_state ) ;\n break ;\n }\n return ( 1 ) ;\n }", "idx": 20627}
{"hash": -8199454075838226273, "project": "debian", "size": 294, "label": 0, "functionSource": "static void dissect_rtmpt_common ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , rtmpt_conv_t * rconv , int cdir , guint32 seq , guint32 lastackseq ) {\n int offset = 0 ;\n int remain ;\n int want ;\n guint8 header_type ;\n int basic_hlen ;\n int message_hlen ;\n guint32 id ;\n guint32 ts = 0 ;\n guint32 tsd = 0 ;\n int body_len ;\n guint8 cmd ;\n guint32 src ;\n int chunk_size ;\n guint32 save_seq = 0 ;\n rtmpt_frag_t * tf ;\n rtmpt_id_t * ti ;\n rtmpt_packet_t * tp ;\n tvbuff_t * pktbuf ;\n remain = tvb_reported_length ( tvb ) ;\n if ( ! remain ) return ;\n RTMPT_DEBUG ( \"Segment: cdir=%d seq=%d-%d\\n\" , cdir , seq , seq + remain - 1 ) ;\n if ( pinfo -> fd -> flags . visited ) {\n wmem_stack_t * packets ;\n packets = wmem_stack_new ( wmem_packet_scope ( ) ) ;\n wmem_stack_push ( packets , 0 ) ;\n tp = ( rtmpt_packet_t * ) wmem_tree_lookup32_le ( rconv -> packets [ cdir ] , seq + remain - 1 ) ;\n while ( tp && tp -> lastseq >= seq && tp -> lastseq >= save_seq ) {\n wmem_stack_push ( packets , tp ) ;\n save_seq = tp -> lastseq + 1 ;\n tp = ( rtmpt_packet_t * ) wmem_tree_lookup32_le ( rconv -> packets [ cdir ] , tp -> lastseq - 1 ) ;\n }\n while ( ( tp = ( rtmpt_packet_t * ) wmem_stack_pop ( packets ) ) != NULL ) {\n if ( tp -> resident ) {\n pktbuf = tvb_new_child_real_data ( tvb , tp -> data . p , tp -> have , tp -> have ) ;\n add_new_data_source ( pinfo , pktbuf , \"Unchunked RTMP\" ) ;\n }\n else {\n pktbuf = tvb_new_subset_length ( tvb , tp -> data . offset , tp -> have ) ;\n }\n dissect_rtmpt ( pktbuf , pinfo , tree , rconv , cdir , tp ) ;\n }\n return ;\n }\n while ( remain > 0 ) {\n tf = NULL ;\n ti = NULL ;\n tp = NULL ;\n if ( offset == 0 ) {\n tf = ( rtmpt_frag_t * ) wmem_tree_lookup32_le ( rconv -> frags [ cdir ] , seq + offset - 1 ) ;\n if ( tf ) {\n RTMPT_DEBUG ( \" tf seq=%d lseq=%d h=%d l=%d\\n\" , tf -> seq , tf -> lastseq , tf -> have , tf -> len ) ;\n if ( tf -> have >= tf -> len || seq + offset < tf -> seq || seq + offset > tf -> lastseq + tf -> len - tf -> have ) {\n tf = NULL ;\n }\n else if ( ! tf -> ishdr ) {\n ti = ( rtmpt_id_t * ) wmem_tree_lookup32 ( rconv -> ids [ cdir ] , tf -> saved . id ) ;\n if ( ti ) {\n tp = ( rtmpt_packet_t * ) wmem_tree_lookup32_le ( ti -> packets , seq + offset - 1 ) ;\n }\n if ( tp && tp -> chunkwant ) {\n goto unchunk ;\n }\n tf = NULL ;\n ti = NULL ;\n tp = NULL ;\n }\n if ( tf ) {\n want = tf -> len - tf -> have ;\n if ( remain < want ) want = remain ;\n tvb_memcpy ( tvb , tf -> saved . d + tf -> have , offset , want ) ;\n id = tf -> saved . d [ 0 ] ;\n header_type = ( id >> 6 ) & 3 ;\n basic_hlen = rtmpt_basic_header_length ( id ) ;\n if ( ( header_type < 3 ) && ( tf -> have < ( basic_hlen + 3 ) ) && ( tf -> have + want >= ( basic_hlen + 3 ) ) ) {\n if ( pntoh24 ( tf -> saved . d + basic_hlen ) == 0xffffff ) {\n tf -> len += 4 ;\n }\n }\n tf -> have += want ;\n tf -> lastseq = seq + want - 1 ;\n remain -= want ;\n offset += want ;\n if ( tf -> have < tf -> len ) {\n return ;\n }\n }\n }\n }\n if ( ! tf ) {\n id = tvb_get_guint8 ( tvb , offset ) ;\n if ( id == RTMPT_MAGIC && seq + offset == RTMPT_HANDSHAKE_OFFSET_1 ) {\n header_type = 4 ;\n basic_hlen = 1 ;\n message_hlen = 0 ;\n id = lastackseq == 1 ? RTMPT_TYPE_HANDSHAKE_1 : RTMPT_TYPE_HANDSHAKE_2 ;\n }\n else if ( seq + offset == RTMPT_HANDSHAKE_OFFSET_2 ) {\n header_type = 4 ;\n basic_hlen = 0 ;\n message_hlen = 0 ;\n id = RTMPT_TYPE_HANDSHAKE_3 ;\n }\n else {\n header_type = ( id >> 6 ) & 3 ;\n basic_hlen = rtmpt_basic_header_length ( id ) ;\n message_hlen = rtmpt_message_header_length ( id ) ;\n if ( ( header_type < 3 ) && ( remain >= ( basic_hlen + 3 ) ) ) {\n if ( tvb_get_ntoh24 ( tvb , offset + basic_hlen ) == 0xffffff ) {\n message_hlen += 4 ;\n }\n }\n if ( remain < ( basic_hlen + message_hlen ) ) {\n tf = wmem_new ( wmem_file_scope ( ) , rtmpt_frag_t ) ;\n tf -> ishdr = 1 ;\n tf -> seq = seq + offset ;\n tf -> lastseq = tf -> seq + remain - 1 ;\n tf -> len = basic_hlen + message_hlen ;\n tvb_memcpy ( tvb , tf -> saved . d , offset , remain ) ;\n tf -> have = remain ;\n wmem_tree_insert32 ( rconv -> frags [ cdir ] , seq + offset , tf ) ;\n return ;\n }\n id = id & 0x3f ;\n if ( id == 0 ) id = tvb_get_guint8 ( tvb , offset + 1 ) + 64 ;\n else if ( id == 1 ) id = tvb_get_letohs ( tvb , offset + 1 ) + 64 ;\n }\n }\n else {\n id = tf -> saved . d [ 0 ] ;\n header_type = ( id >> 6 ) & 3 ;\n basic_hlen = rtmpt_basic_header_length ( id ) ;\n message_hlen = tf -> len - basic_hlen ;\n id = id & 0x3f ;\n if ( id == 0 ) id = tf -> saved . d [ 1 ] + 64 ;\n else if ( id == 1 ) id = pletoh16 ( tf -> saved . d + 1 ) + 64 ;\n }\n if ( id <= RTMPT_ID_MAX ) ti = ( rtmpt_id_t * ) wmem_tree_lookup32 ( rconv -> ids [ cdir ] , id ) ;\n if ( ti ) tp = ( rtmpt_packet_t * ) wmem_tree_lookup32_le ( ti -> packets , seq + offset - 1 ) ;\n if ( header_type == 0 ) src = tf ? pntoh32 ( tf -> saved . d + basic_hlen + 7 ) : tvb_get_ntohl ( tvb , offset + basic_hlen + 7 ) ;\n else if ( ti ) src = ti -> src ;\n else src = 0 ;\n if ( header_type < 2 ) cmd = tf ? tf -> saved . d [ basic_hlen + 6 ] : tvb_get_guint8 ( tvb , offset + basic_hlen + 6 ) ;\n else if ( ti ) cmd = ti -> cmd ;\n else cmd = 0 ;\n if ( id > RTMPT_ID_MAX ) {\n if ( id == RTMPT_TYPE_HANDSHAKE_1 ) chunk_size = body_len = 1536 ;\n else if ( id == RTMPT_TYPE_HANDSHAKE_2 ) chunk_size = body_len = 3072 ;\n else chunk_size = body_len = 1536 ;\n }\n else {\n chunk_size = GPOINTER_TO_INT ( wmem_tree_lookup32_le ( rconv -> chunksize [ cdir ] , seq + offset - 1 ) ) ;\n if ( ! chunk_size ) chunk_size = RTMPT_DEFAULT_CHUNK_SIZE ;\n if ( header_type < 2 ) body_len = tf ? pntoh24 ( tf -> saved . d + basic_hlen + 3 ) : tvb_get_ntoh24 ( tvb , offset + basic_hlen + 3 ) ;\n else if ( ti ) body_len = ti -> len ;\n else body_len = chunk_size ;\n if ( body_len > ( gint ) rtmpt_max_packet_size ) {\n return ;\n }\n }\n if ( ! ti || ! tp || header_type < 3 || tp -> have == tp -> want || tp -> chunkhave != tp -> chunkwant ) {\n RTMPT_DEBUG ( \"New packet cdir=%d seq=%d ti=%p tp=%p header_type=%d header_len=%d id=%d tph=%d tpw=%d len=%d cs=%d\\n\" , cdir , seq + offset , ti , tp , header_type , basic_hlen + message_hlen , id , tp ? tp -> have : 0 , tp ? tp -> want : 0 , body_len , chunk_size ) ;\n if ( ! ti ) {\n ti = wmem_new ( wmem_file_scope ( ) , rtmpt_id_t ) ;\n ti -> packets = wmem_tree_new ( wmem_file_scope ( ) ) ;\n ti -> ts = 0 ;\n ti -> tsd = 0 ;\n wmem_tree_insert32 ( rconv -> ids [ cdir ] , id , ti ) ;\n }\n if ( header_type == 0 ) {\n ts = tf ? pntoh24 ( tf -> saved . d + basic_hlen ) : tvb_get_ntoh24 ( tvb , offset + basic_hlen ) ;\n if ( ts == 0xffffff ) {\n ts = tf ? pntoh32 ( tf -> saved . d + basic_hlen + 11 ) : tvb_get_ntohl ( tvb , offset + basic_hlen + 11 ) ;\n }\n tsd = ts - ti -> ts ;\n }\n else if ( header_type < 3 ) {\n tsd = tf ? pntoh24 ( tf -> saved . d + basic_hlen ) : tvb_get_ntoh24 ( tvb , offset + basic_hlen ) ;\n if ( tsd == 0xffffff ) {\n ts = tf ? pntoh32 ( tf -> saved . d + basic_hlen + message_hlen - 4 ) : tvb_get_ntohl ( tvb , offset + basic_hlen + message_hlen - 4 ) ;\n tsd = ti -> tsd ;\n }\n else {\n ts = ti -> ts + tsd ;\n }\n }\n else {\n ts = ti -> ts + ti -> tsd ;\n tsd = ti -> tsd ;\n }\n tp = wmem_new ( wmem_file_scope ( ) , rtmpt_packet_t ) ;\n tp -> seq = tp -> lastseq = tf ? tf -> seq : seq + offset ;\n tp -> have = 0 ;\n tp -> want = basic_hlen + message_hlen + body_len ;\n tp -> chunkwant = 0 ;\n tp -> chunkhave = 0 ;\n tp -> bhlen = basic_hlen ;\n tp -> mhlen = message_hlen ;\n tp -> fmt = header_type ;\n tp -> id = id ;\n tp -> ts = ts ;\n tp -> len = body_len ;\n if ( id > RTMPT_ID_MAX ) tp -> cmd = id ;\n else tp -> cmd = cmd & 0x7f ;\n tp -> src = src ;\n tp -> txid = 0 ;\n tp -> isresponse = FALSE ;\n tp -> otherframe = 0 ;\n ti -> ts = ts ;\n ti -> tsd = tsd ;\n ti -> len = body_len ;\n ti -> cmd = cmd ;\n ti -> src = src ;\n wmem_tree_insert32 ( ti -> packets , tp -> seq , tp ) ;\n if ( ! tf && body_len <= chunk_size && tp -> want <= remain ) {\n tp -> resident = FALSE ;\n tp -> data . offset = offset ;\n tp -> lastseq = seq + offset + tp -> want - 1 ;\n tp -> have = tp -> want ;\n wmem_tree_insert32 ( rconv -> packets [ cdir ] , tp -> lastseq , tp ) ;\n pktbuf = tvb_new_subset_length ( tvb , tp -> data . offset , tp -> have ) ;\n dissect_rtmpt ( pktbuf , pinfo , tree , rconv , cdir , tp ) ;\n offset += tp -> want ;\n remain -= tp -> want ;\n continue ;\n }\n else {\n tp -> resident = TRUE ;\n tp -> data . p = ( guint8 * ) wmem_alloc ( wmem_file_scope ( ) , tp -> bhlen + tp -> mhlen + tp -> len ) ;\n if ( tf && tf -> ishdr ) {\n memcpy ( tp -> data . p , tf -> saved . d , tf -> len ) ;\n }\n else {\n tvb_memcpy ( tvb , tp -> data . p , offset , basic_hlen + message_hlen ) ;\n offset += basic_hlen + message_hlen ;\n remain -= basic_hlen + message_hlen ;\n }\n tp -> lastseq = seq + offset - 1 ;\n tp -> have = basic_hlen + message_hlen ;\n if ( tp -> have == tp -> want ) {\n wmem_tree_insert32 ( rconv -> packets [ cdir ] , tp -> lastseq , tp ) ;\n pktbuf = tvb_new_child_real_data ( tvb , tp -> data . p , tp -> have , tp -> have ) ;\n add_new_data_source ( pinfo , pktbuf , \"Unchunked RTMP\" ) ;\n dissect_rtmpt ( pktbuf , pinfo , tree , rconv , cdir , tp ) ;\n continue ;\n }\n tp -> chunkwant = chunk_size ;\n if ( tp -> chunkwant > tp -> want - tp -> have ) tp -> chunkwant = tp -> want - tp -> have ;\n }\n }\n else {\n RTMPT_DEBUG ( \"Old packet cdir=%d seq=%d ti=%p tp=%p header_len=%d id=%d tph=%d tpw=%d len=%d cs=%d\\n\" , cdir , seq + offset , ti , tp , basic_hlen + message_hlen , id , tp ? tp -> have : 0 , tp ? tp -> want : 0 , body_len , chunk_size ) ;\n tp -> chunkwant = chunk_size ;\n if ( tp -> chunkwant > tp -> want - tp -> have ) tp -> chunkwant = tp -> want - tp -> have ;\n offset += basic_hlen + message_hlen ;\n remain -= basic_hlen + message_hlen ;\n }\n tf = NULL ;\n unchunk : want = tp -> chunkwant - tp -> chunkhave ;\n if ( want > remain ) want = remain ;\n RTMPT_DEBUG ( \" cw=%d ch=%d r=%d w=%d\\n\" , tp -> chunkwant , tp -> chunkhave , remain , want ) ;\n tvb_memcpy ( tvb , tp -> data . p + tp -> have , offset , want ) ;\n if ( tf ) {\n tf -> have += want ;\n tf -> lastseq = seq + offset + want - 1 ;\n }\n tp -> lastseq = seq + offset + want - 1 ;\n tp -> have += want ;\n tp -> chunkhave += want ;\n offset += want ;\n remain -= want ;\n if ( tp -> chunkhave == tp -> chunkwant ) {\n tp -> chunkhave = 0 ;\n tp -> chunkwant = 0 ;\n }\n if ( tp -> have == tp -> want ) {\n wmem_tree_insert32 ( rconv -> packets [ cdir ] , tp -> lastseq , tp ) ;\n pktbuf = tvb_new_child_real_data ( tvb , tp -> data . p , tp -> have , tp -> have ) ;\n add_new_data_source ( pinfo , pktbuf , \"Unchunked RTMP\" ) ;\n dissect_rtmpt ( pktbuf , pinfo , tree , rconv , cdir , tp ) ;\n }\n else if ( tp -> chunkhave < tp -> chunkwant ) {\n rtmpt_frag_t * tf2 = wmem_new ( wmem_file_scope ( ) , rtmpt_frag_t ) ;\n tf2 -> ishdr = 0 ;\n tf2 -> seq = seq + offset - want ;\n tf2 -> lastseq = tf2 -> seq + remain - 1 + want ;\n tf2 -> have = tp -> chunkhave ;\n tf2 -> len = tp -> chunkwant ;\n tf2 -> saved . id = tp -> id ;\n RTMPT_DEBUG ( \" inserting tf @ %d\\n\" , seq + offset - want - 1 ) ;\n wmem_tree_insert32 ( rconv -> frags [ cdir ] , seq + offset - want - 1 , tf2 ) ;\n }\n }\n }", "idx": 20628}
{"hash": 8085056330506804135, "project": "chrome", "size": 22, "label": 0, "functionSource": "int vp9_denoiser_alloc ( VP9_DENOISER * denoiser , int width , int height , int ssx , int ssy , # if CONFIG_VP9_HIGHBITDEPTH int use_highbitdepth , # endif int border ) {\n int i , fail ;\n assert ( denoiser != NULL ) ;\n for ( i = 0 ;\n i < MAX_REF_FRAMES ;\n ++ i ) {\n fail = vp9_alloc_frame_buffer ( & denoiser -> running_avg_y [ i ] , width , height , ssx , ssy , # if CONFIG_VP9_HIGHBITDEPTH use_highbitdepth , # endif border ) ;\n if ( fail ) {\n vp9_denoiser_free ( denoiser ) ;\n return 1 ;\n }\n # ifdef OUTPUT_YUV_DENOISED make_grayscale ( & denoiser -> running_avg_y [ i ] ) ;\n # endif }\n fail = vp9_alloc_frame_buffer ( & denoiser -> mc_running_avg_y , width , height , ssx , ssy , # if CONFIG_VP9_HIGHBITDEPTH use_highbitdepth , # endif border ) ;\n if ( fail ) {\n vp9_denoiser_free ( denoiser ) ;\n return 1 ;\n }\n # ifdef OUTPUT_YUV_DENOISED make_grayscale ( & denoiser -> running_avg_y [ i ] ) ;\n # endif denoiser -> increase_denoising = 0 ;\n return 0 ;\n }", "idx": 20629}
{"hash": 378220832151730865, "project": "debian", "size": 28, "label": 0, "functionSource": "int qemuMonitorTextGetBalloonInfo ( qemuMonitorPtr mon , unsigned long * currmem ) {\n char * reply = NULL ;\n int ret = - 1 ;\n char * offset ;\n if ( qemuMonitorHMPCommand ( mon , \"info balloon\" , & reply ) < 0 ) {\n qemuReportError ( VIR_ERR_OPERATION_FAILED , \"%s\" , _ ( \"could not query memory balloon allocation\" ) ) ;\n return - 1 ;\n }\n if ( ( offset = strstr ( reply , BALLOON_PREFIX ) ) != NULL ) {\n offset += strlen ( BALLOON_PREFIX ) ;\n struct _virDomainMemoryStat stats [ 1 ] ;\n if ( qemuMonitorParseBalloonInfo ( offset , stats , 1 ) == 0 ) {\n qemuReportError ( VIR_ERR_INTERNAL_ERROR , _ ( \"unexpected balloon information '%s'\" ) , reply ) ;\n goto cleanup ;\n }\n if ( stats [ 0 ] . tag != VIR_DOMAIN_MEMORY_STAT_ACTUAL_BALLOON ) {\n qemuReportError ( VIR_ERR_INTERNAL_ERROR , _ ( \"unexpected balloon information '%s'\" ) , reply ) ;\n goto cleanup ;\n }\n * currmem = stats [ 0 ] . val ;\n ret = 1 ;\n }\n else {\n ret = 0 ;\n }\n cleanup : VIR_FREE ( reply ) ;\n return ret ;\n }", "idx": 20630}
{"hash": -3819889754140204145, "project": "debian", "size": 39, "label": 0, "functionSource": "static bool parse_authorityInfoAccess ( chunk_t blob , int level0 , private_x509_cert_t * this ) {\n asn1_parser_t * parser ;\n chunk_t object ;\n int objectID ;\n int accessMethod = OID_UNKNOWN ;\n bool success = FALSE ;\n parser = asn1_parser_create ( authInfoAccessObjects , blob ) ;\n parser -> set_top_level ( parser , level0 ) ;\n while ( parser -> iterate ( parser , & objectID , & object ) ) {\n switch ( objectID ) {\n case AUTH_INFO_ACCESS_METHOD : accessMethod = asn1_known_oid ( object ) ;\n break ;\n case AUTH_INFO_ACCESS_LOCATION : {\n switch ( accessMethod ) {\n case OID_OCSP : case OID_CA_ISSUERS : {\n identification_t * id ;\n char * uri ;\n id = parse_generalName ( object , parser -> get_level ( parser ) + 1 ) ;\n if ( id == NULL ) {\n goto end ;\n }\n DBG2 ( DBG_ASN , \" '%Y'\" , id ) ;\n if ( accessMethod == OID_OCSP && gn_to_string ( id , & uri ) ) {\n this -> ocsp_uris -> insert_last ( this -> ocsp_uris , uri ) ;\n }\n id -> destroy ( id ) ;\n }\n break ;\n default : break ;\n }\n break ;\n }\n default : break ;\n }\n }\n success = parser -> success ( parser ) ;\n end : parser -> destroy ( parser ) ;\n return success ;\n }", "idx": 20631}
{"hash": -3889154245145551951, "project": "debian", "size": 18, "label": 0, "functionSource": "static const char * create_index ( void ) {\n const char * tmpfile ;\n struct pack_idx_entry * * idx , * * c , * * last ;\n struct object_entry * e ;\n struct object_entry_pool * o ;\n idx = xmalloc ( object_count * sizeof ( * idx ) ) ;\n c = idx ;\n for ( o = blocks ;\n o ;\n o = o -> next_pool ) for ( e = o -> next_free ;\n e -- != o -> entries ;\n ) if ( pack_id == e -> pack_id ) * c ++ = & e -> idx ;\n last = idx + object_count ;\n if ( c != last ) die ( \"internal consistency error creating the index\" ) ;\n tmpfile = write_idx_file ( NULL , idx , object_count , & pack_idx_opts , pack_data -> sha1 ) ;\n free ( idx ) ;\n return tmpfile ;\n }", "idx": 20632}
{"hash": -6119142299306266167, "project": "debian", "size": 6, "label": 0, "functionSource": "static int loop_continue ( i_ctx_t * i_ctx_p ) {\n register es_ptr ep = esp ;\n ref_assign ( ep + 2 , ep ) ;\n esp = ep + 2 ;\n return o_push_estack ;\n }", "idx": 20633}
{"hash": 7039307292471244756, "project": "debian", "size": 33, "label": 0, "functionSource": "static guint16 de_time_zone_time ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len _U_ , gchar * add_string _U_ , int string_len _U_ ) {\n guint8 oct ;\n guint32 curr_offset ;\n char sign ;\n nstime_t tv ;\n struct tm tm ;\n curr_offset = offset ;\n tm . tm_wday = 0 ;\n tm . tm_yday = 0 ;\n tm . tm_isdst = - 1 ;\n oct = tvb_get_guint8 ( tvb , curr_offset ) ;\n tm . tm_year = ( oct & 0x0f ) * 10 + ( ( oct & 0xf0 ) >> 4 ) + 100 ;\n oct = tvb_get_guint8 ( tvb , curr_offset + 1 ) ;\n tm . tm_mon = ( oct & 0x0f ) * 10 + ( ( oct & 0xf0 ) >> 4 ) - 1 ;\n oct = tvb_get_guint8 ( tvb , curr_offset + 2 ) ;\n tm . tm_mday = ( oct & 0x0f ) * 10 + ( ( oct & 0xf0 ) >> 4 ) ;\n oct = tvb_get_guint8 ( tvb , curr_offset + 3 ) ;\n tm . tm_hour = ( oct & 0x0f ) * 10 + ( ( oct & 0xf0 ) >> 4 ) ;\n oct = tvb_get_guint8 ( tvb , curr_offset + 4 ) ;\n tm . tm_min = ( oct & 0x0f ) * 10 + ( ( oct & 0xf0 ) >> 4 ) ;\n oct = tvb_get_guint8 ( tvb , curr_offset + 5 ) ;\n tm . tm_sec = ( oct & 0x0f ) * 10 + ( ( oct & 0xf0 ) >> 4 ) ;\n tv . secs = mktime ( & tm ) ;\n tv . nsecs = 0 ;\n proto_tree_add_time_format_value ( tree , hf_gsm_a_dtap_time_zone_time , tvb , curr_offset , 6 , & tv , \"%s\" , abs_time_to_str ( wmem_packet_scope ( ) , & tv , ABSOLUTE_TIME_LOCAL , FALSE ) ) ;\n curr_offset += 6 ;\n oct = tvb_get_guint8 ( tvb , curr_offset ) ;\n sign = ( oct & 0x08 ) ? '-' : '+' ;\n oct = ( oct >> 4 ) + ( oct & 0x07 ) * 10 ;\n proto_tree_add_uint_format_value ( tree , hf_gsm_a_dtap_timezone , tvb , curr_offset , 1 , oct , \"GMT %c %d hours %d minutes\" , sign , oct / 4 , oct % 4 * 15 ) ;\n curr_offset ++ ;\n return ( curr_offset - offset ) ;\n }", "idx": 20634}
{"hash": -1102844685921778700, "project": "debian", "size": 4, "label": 0, "functionSource": "static void add_converter ( struct archive_string_conv * sc , int ( * converter ) ( struct archive_string * , const void * , size_t , struct archive_string_conv * ) ) {\n if ( sc == NULL || sc -> nconverter >= 2 ) __archive_errx ( 1 , \"Programing error\" ) ;\n sc -> converter [ sc -> nconverter ++ ] = converter ;\n }", "idx": 20635}
{"hash": -7434014980763120366, "project": "debian", "size": 3, "label": 0, "functionSource": "int get_ber_length ( tvbuff_t * tvb , int offset , guint32 * length , gboolean * ind ) {\n return try_get_ber_length ( tvb , offset , length , ind , 1 ) ;\n }", "idx": 20636}
{"hash": 8672904772426696383, "project": "debian", "size": 136, "label": 1, "functionSource": "static int mpeg4_decode_partition_a ( MpegEncContext * s ) {\n int mb_num ;\n static const int8_t quant_tab [ 4 ] = {\n - 1 , - 2 , 1 , 2 }\n ;\n mb_num = 0 ;\n s -> first_slice_line = 1 ;\n for ( ;\n s -> mb_y < s -> mb_height ;\n s -> mb_y ++ ) {\n ff_init_block_index ( s ) ;\n for ( ;\n s -> mb_x < s -> mb_width ;\n s -> mb_x ++ ) {\n const int xy = s -> mb_x + s -> mb_y * s -> mb_stride ;\n int cbpc ;\n int dir = 0 ;\n mb_num ++ ;\n ff_update_block_index ( s ) ;\n if ( s -> mb_x == s -> resync_mb_x && s -> mb_y == s -> resync_mb_y + 1 ) s -> first_slice_line = 0 ;\n if ( s -> pict_type == AV_PICTURE_TYPE_I ) {\n int i ;\n do {\n if ( show_bits_long ( & s -> gb , 19 ) == DC_MARKER ) {\n return mb_num - 1 ;\n }\n cbpc = get_vlc2 ( & s -> gb , ff_h263_intra_MCBPC_vlc . table , INTRA_MCBPC_VLC_BITS , 2 ) ;\n if ( cbpc < 0 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"cbpc corrupted at %d %d\\n\" , s -> mb_x , s -> mb_y ) ;\n return - 1 ;\n }\n }\n while ( cbpc == 8 ) ;\n s -> cbp_table [ xy ] = cbpc & 3 ;\n s -> current_picture . f . mb_type [ xy ] = MB_TYPE_INTRA ;\n s -> mb_intra = 1 ;\n if ( cbpc & 4 ) {\n ff_set_qscale ( s , s -> qscale + quant_tab [ get_bits ( & s -> gb , 2 ) ] ) ;\n }\n s -> current_picture . f . qscale_table [ xy ] = s -> qscale ;\n s -> mbintra_table [ xy ] = 1 ;\n for ( i = 0 ;\n i < 6 ;\n i ++ ) {\n int dc_pred_dir ;\n int dc = mpeg4_decode_dc ( s , i , & dc_pred_dir ) ;\n if ( dc < 0 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"DC corrupted at %d %d\\n\" , s -> mb_x , s -> mb_y ) ;\n return - 1 ;\n }\n dir <<= 1 ;\n if ( dc_pred_dir ) dir |= 1 ;\n }\n s -> pred_dir_table [ xy ] = dir ;\n }\n else {\n int mx , my , pred_x , pred_y , bits ;\n int16_t * const mot_val = s -> current_picture . f . motion_val [ 0 ] [ s -> block_index [ 0 ] ] ;\n const int stride = s -> b8_stride * 2 ;\n try_again : bits = show_bits ( & s -> gb , 17 ) ;\n if ( bits == MOTION_MARKER ) {\n return mb_num - 1 ;\n }\n skip_bits1 ( & s -> gb ) ;\n if ( bits & 0x10000 ) {\n if ( s -> pict_type == AV_PICTURE_TYPE_S && s -> vol_sprite_usage == GMC_SPRITE ) {\n s -> current_picture . f . mb_type [ xy ] = MB_TYPE_SKIP | MB_TYPE_16x16 | MB_TYPE_GMC | MB_TYPE_L0 ;\n mx = get_amv ( s , 0 ) ;\n my = get_amv ( s , 1 ) ;\n }\n else {\n s -> current_picture . f . mb_type [ xy ] = MB_TYPE_SKIP | MB_TYPE_16x16 | MB_TYPE_L0 ;\n mx = my = 0 ;\n }\n mot_val [ 0 ] = mot_val [ 2 ] = mot_val [ 0 + stride ] = mot_val [ 2 + stride ] = mx ;\n mot_val [ 1 ] = mot_val [ 3 ] = mot_val [ 1 + stride ] = mot_val [ 3 + stride ] = my ;\n if ( s -> mbintra_table [ xy ] ) ff_clean_intra_table_entries ( s ) ;\n continue ;\n }\n cbpc = get_vlc2 ( & s -> gb , ff_h263_inter_MCBPC_vlc . table , INTER_MCBPC_VLC_BITS , 2 ) ;\n if ( cbpc < 0 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"cbpc corrupted at %d %d\\n\" , s -> mb_x , s -> mb_y ) ;\n return - 1 ;\n }\n if ( cbpc == 20 ) goto try_again ;\n s -> cbp_table [ xy ] = cbpc & ( 8 + 3 ) ;\n s -> mb_intra = ( ( cbpc & 4 ) != 0 ) ;\n if ( s -> mb_intra ) {\n s -> current_picture . f . mb_type [ xy ] = MB_TYPE_INTRA ;\n s -> mbintra_table [ xy ] = 1 ;\n mot_val [ 0 ] = mot_val [ 2 ] = mot_val [ 0 + stride ] = mot_val [ 2 + stride ] = 0 ;\n mot_val [ 1 ] = mot_val [ 3 ] = mot_val [ 1 + stride ] = mot_val [ 3 + stride ] = 0 ;\n }\n else {\n if ( s -> mbintra_table [ xy ] ) ff_clean_intra_table_entries ( s ) ;\n if ( s -> pict_type == AV_PICTURE_TYPE_S && s -> vol_sprite_usage == GMC_SPRITE && ( cbpc & 16 ) == 0 ) s -> mcsel = get_bits1 ( & s -> gb ) ;\n else s -> mcsel = 0 ;\n if ( ( cbpc & 16 ) == 0 ) {\n ff_h263_pred_motion ( s , 0 , 0 , & pred_x , & pred_y ) ;\n if ( ! s -> mcsel ) {\n mx = ff_h263_decode_motion ( s , pred_x , s -> f_code ) ;\n if ( mx >= 0xffff ) return - 1 ;\n my = ff_h263_decode_motion ( s , pred_y , s -> f_code ) ;\n if ( my >= 0xffff ) return - 1 ;\n s -> current_picture . f . mb_type [ xy ] = MB_TYPE_16x16 | MB_TYPE_L0 ;\n }\n else {\n mx = get_amv ( s , 0 ) ;\n my = get_amv ( s , 1 ) ;\n s -> current_picture . f . mb_type [ xy ] = MB_TYPE_16x16 | MB_TYPE_GMC | MB_TYPE_L0 ;\n }\n mot_val [ 0 ] = mot_val [ 2 ] = mot_val [ 0 + stride ] = mot_val [ 2 + stride ] = mx ;\n mot_val [ 1 ] = mot_val [ 3 ] = mot_val [ 1 + stride ] = mot_val [ 3 + stride ] = my ;\n }\n else {\n int i ;\n s -> current_picture . f . mb_type [ xy ] = MB_TYPE_8x8 | MB_TYPE_L0 ;\n for ( i = 0 ;\n i < 4 ;\n i ++ ) {\n int16_t * mot_val = ff_h263_pred_motion ( s , i , 0 , & pred_x , & pred_y ) ;\n mx = ff_h263_decode_motion ( s , pred_x , s -> f_code ) ;\n if ( mx >= 0xffff ) return - 1 ;\n my = ff_h263_decode_motion ( s , pred_y , s -> f_code ) ;\n if ( my >= 0xffff ) return - 1 ;\n mot_val [ 0 ] = mx ;\n mot_val [ 1 ] = my ;\n }\n }\n }\n }\n }\n s -> mb_x = 0 ;\n }\n return mb_num ;\n }", "idx": 20637}
{"hash": -8028756826159773630, "project": "debian", "size": 8, "label": 0, "functionSource": "static void _moveBefore ( ArchiveHandle * AH , TocEntry * pos , TocEntry * te ) {\n te -> prev -> next = te -> next ;\n te -> next -> prev = te -> prev ;\n te -> prev = pos -> prev ;\n te -> next = pos ;\n pos -> prev -> next = te ;\n pos -> prev = te ;\n }", "idx": 20638}
{"hash": 8572106347813672436, "project": "debian", "size": 62, "label": 0, "functionSource": "static int pfkey_send_new_mapping ( struct xfrm_state * x , xfrm_address_t * ipaddr , __be16 sport ) {\n struct sk_buff * skb ;\n struct sadb_msg * hdr ;\n struct sadb_sa * sa ;\n struct sadb_address * addr ;\n struct sadb_x_nat_t_port * n_port ;\n int sockaddr_size ;\n int size ;\n __u8 satype = ( x -> id . proto == IPPROTO_ESP ? SADB_SATYPE_ESP : 0 ) ;\n struct xfrm_encap_tmpl * natt = NULL ;\n sockaddr_size = pfkey_sockaddr_size ( x -> props . family ) ;\n if ( ! sockaddr_size ) return - EINVAL ;\n if ( ! satype ) return - EINVAL ;\n if ( ! x -> encap ) return - EINVAL ;\n natt = x -> encap ;\n size = sizeof ( struct sadb_msg ) + sizeof ( struct sadb_sa ) + ( sizeof ( struct sadb_address ) * 2 ) + ( sockaddr_size * 2 ) + ( sizeof ( struct sadb_x_nat_t_port ) * 2 ) ;\n skb = alloc_skb ( size + 16 , GFP_ATOMIC ) ;\n if ( skb == NULL ) return - ENOMEM ;\n hdr = ( struct sadb_msg * ) skb_put ( skb , sizeof ( struct sadb_msg ) ) ;\n hdr -> sadb_msg_version = PF_KEY_V2 ;\n hdr -> sadb_msg_type = SADB_X_NAT_T_NEW_MAPPING ;\n hdr -> sadb_msg_satype = satype ;\n hdr -> sadb_msg_len = size / sizeof ( uint64_t ) ;\n hdr -> sadb_msg_errno = 0 ;\n hdr -> sadb_msg_reserved = 0 ;\n hdr -> sadb_msg_seq = x -> km . seq = get_acqseq ( ) ;\n hdr -> sadb_msg_pid = 0 ;\n sa = ( struct sadb_sa * ) skb_put ( skb , sizeof ( struct sadb_sa ) ) ;\n sa -> sadb_sa_len = sizeof ( struct sadb_sa ) / sizeof ( uint64_t ) ;\n sa -> sadb_sa_exttype = SADB_EXT_SA ;\n sa -> sadb_sa_spi = x -> id . spi ;\n sa -> sadb_sa_replay = 0 ;\n sa -> sadb_sa_state = 0 ;\n sa -> sadb_sa_auth = 0 ;\n sa -> sadb_sa_encrypt = 0 ;\n sa -> sadb_sa_flags = 0 ;\n addr = ( struct sadb_address * ) skb_put ( skb , sizeof ( struct sadb_address ) + sockaddr_size ) ;\n addr -> sadb_address_len = ( sizeof ( struct sadb_address ) + sockaddr_size ) / sizeof ( uint64_t ) ;\n addr -> sadb_address_exttype = SADB_EXT_ADDRESS_SRC ;\n addr -> sadb_address_proto = 0 ;\n addr -> sadb_address_reserved = 0 ;\n addr -> sadb_address_prefixlen = pfkey_sockaddr_fill ( & x -> props . saddr , 0 , ( struct sockaddr * ) ( addr + 1 ) , x -> props . family ) ;\n if ( ! addr -> sadb_address_prefixlen ) BUG ( ) ;\n n_port = ( struct sadb_x_nat_t_port * ) skb_put ( skb , sizeof ( * n_port ) ) ;\n n_port -> sadb_x_nat_t_port_len = sizeof ( * n_port ) / sizeof ( uint64_t ) ;\n n_port -> sadb_x_nat_t_port_exttype = SADB_X_EXT_NAT_T_SPORT ;\n n_port -> sadb_x_nat_t_port_port = natt -> encap_sport ;\n n_port -> sadb_x_nat_t_port_reserved = 0 ;\n addr = ( struct sadb_address * ) skb_put ( skb , sizeof ( struct sadb_address ) + sockaddr_size ) ;\n addr -> sadb_address_len = ( sizeof ( struct sadb_address ) + sockaddr_size ) / sizeof ( uint64_t ) ;\n addr -> sadb_address_exttype = SADB_EXT_ADDRESS_DST ;\n addr -> sadb_address_proto = 0 ;\n addr -> sadb_address_reserved = 0 ;\n addr -> sadb_address_prefixlen = pfkey_sockaddr_fill ( ipaddr , 0 , ( struct sockaddr * ) ( addr + 1 ) , x -> props . family ) ;\n if ( ! addr -> sadb_address_prefixlen ) BUG ( ) ;\n n_port = ( struct sadb_x_nat_t_port * ) skb_put ( skb , sizeof ( * n_port ) ) ;\n n_port -> sadb_x_nat_t_port_len = sizeof ( * n_port ) / sizeof ( uint64_t ) ;\n n_port -> sadb_x_nat_t_port_exttype = SADB_X_EXT_NAT_T_DPORT ;\n n_port -> sadb_x_nat_t_port_port = sport ;\n n_port -> sadb_x_nat_t_port_reserved = 0 ;\n return pfkey_broadcast ( skb , GFP_ATOMIC , BROADCAST_REGISTERED , NULL , xs_net ( x ) ) ;\n }", "idx": 20639}
{"hash": -1111775978048960297, "project": "chrome", "size": 13, "label": 0, "functionSource": "TEST_F ( BrowsingDataRemoverImplTest , RemoveQuotaManagedProtectedOrigins ) {\n # if BUILDFLAG ( ENABLE_EXTENSIONS ) MockExtensionSpecialStoragePolicy * policy = CreateMockPolicy ( ) ;\n policy -> AddProtected ( kOrigin1 . GetOrigin ( ) ) ;\n # endif BlockUntilBrowsingDataRemoved ( base : : Time ( ) , base : : Time : : Max ( ) , BrowsingDataRemover : : REMOVE_APPCACHE | BrowsingDataRemover : : REMOVE_SERVICE_WORKERS | BrowsingDataRemover : : REMOVE_CACHE_STORAGE | BrowsingDataRemover : : REMOVE_FILE_SYSTEMS | BrowsingDataRemover : : REMOVE_INDEXEDDB | BrowsingDataRemover : : REMOVE_WEBSQL , true ) ;\n EXPECT_EQ ( BrowsingDataRemover : : REMOVE_APPCACHE | BrowsingDataRemover : : REMOVE_SERVICE_WORKERS | BrowsingDataRemover : : REMOVE_CACHE_STORAGE | BrowsingDataRemover : : REMOVE_FILE_SYSTEMS | BrowsingDataRemover : : REMOVE_INDEXEDDB | BrowsingDataRemover : : REMOVE_WEBSQL , GetRemovalMask ( ) ) ;\n EXPECT_EQ ( BrowsingDataHelper : : PROTECTED_WEB | BrowsingDataHelper : : UNPROTECTED_WEB , GetOriginTypeMask ( ) ) ;\n StoragePartitionRemovalData removal_data = GetStoragePartitionRemovalData ( ) ;\n EXPECT_EQ ( removal_data . remove_mask , StoragePartition : : REMOVE_DATA_MASK_FILE_SYSTEMS | StoragePartition : : REMOVE_DATA_MASK_WEBSQL | StoragePartition : : REMOVE_DATA_MASK_APPCACHE | StoragePartition : : REMOVE_DATA_MASK_SERVICE_WORKERS | StoragePartition : : REMOVE_DATA_MASK_CACHE_STORAGE | StoragePartition : : REMOVE_DATA_MASK_INDEXEDDB ) ;\n EXPECT_EQ ( removal_data . quota_storage_remove_mask , StoragePartition : : QUOTA_MANAGED_STORAGE_MASK_ALL ) ;\n EXPECT_TRUE ( removal_data . origin_matcher . Run ( kOrigin1 , mock_policy ( ) ) ) ;\n EXPECT_TRUE ( removal_data . origin_matcher . Run ( kOrigin2 , mock_policy ( ) ) ) ;\n EXPECT_TRUE ( removal_data . origin_matcher . Run ( kOrigin3 , mock_policy ( ) ) ) ;\n }", "idx": 20640}
{"hash": -7455544248455991006, "project": "debian", "size": 11, "label": 0, "functionSource": "static int find_hw_breakpoint ( target_ulong addr , int len , int type ) {\n int n ;\n for ( n = 0 ;\n n < nb_hw_breakpoint ;\n n ++ ) {\n if ( hw_breakpoint [ n ] . addr == addr && hw_breakpoint [ n ] . type == type && ( hw_breakpoint [ n ] . len == len || len == - 1 ) ) {\n return n ;\n }\n }\n return - 1 ;\n }", "idx": 20641}
{"hash": -8589152252830017940, "project": "debian", "size": 7, "label": 0, "functionSource": "void mspack_destroy_kwaj_decompressor ( struct mskwaj_decompressor * base ) {\n struct mskwaj_decompressor_p * self = ( struct mskwaj_decompressor_p * ) base ;\n if ( self ) {\n struct mspack_system * sys = self -> system ;\n sys -> free ( self ) ;\n }\n }", "idx": 20642}
{"hash": 7651945086108393719, "project": "debian", "size": 28, "label": 0, "functionSource": "int qemuMonitorJSONDriveDel ( qemuMonitorPtr mon , const char * drivestr ) {\n int ret ;\n virJSONValuePtr cmd ;\n virJSONValuePtr reply = NULL ;\n VIR_DEBUG ( \"JSONDriveDel drivestr=%s\" , drivestr ) ;\n cmd = qemuMonitorJSONMakeCommand ( \"drive_del\" , \"s:id\" , drivestr , NULL ) ;\n if ( ! cmd ) return - 1 ;\n if ( ( ret = qemuMonitorJSONCommand ( mon , cmd , & reply ) ) < 0 ) goto cleanup ;\n if ( qemuMonitorJSONHasError ( reply , \"CommandNotFound\" ) ) {\n if ( qemuMonitorCheckHMP ( mon , \"drive_del\" ) ) {\n VIR_DEBUG ( \"drive_del command not found, trying HMP\" ) ;\n ret = qemuMonitorTextDriveDel ( mon , drivestr ) ;\n }\n else {\n VIR_ERROR ( _ ( \"deleting disk is not supported. \" \"This may leak data if disk is reassigned\" ) ) ;\n ret = 1 ;\n }\n }\n else if ( qemuMonitorJSONHasError ( reply , \"DeviceNotFound\" ) ) {\n ret = 0 ;\n }\n else {\n ret = qemuMonitorJSONCheckError ( cmd , reply ) ;\n }\n cleanup : virJSONValueFree ( cmd ) ;\n virJSONValueFree ( reply ) ;\n return ret ;\n }", "idx": 20643}
{"hash": -3740862514502467070, "project": "debian", "size": 54, "label": 0, "functionSource": "static void dumpcffcidhmtx ( struct alltabs * at , SplineFont * _sf ) {\n DBounds b ;\n SplineChar * sc ;\n int cid , i , cnt = 0 , max ;\n SplineFont * sf ;\n int dovmetrics = _sf -> hasvmetrics ;\n at -> gi . hmtx = tmpfile ( ) ;\n if ( dovmetrics ) at -> gi . vmtx = tmpfile ( ) ;\n FigureFullMetricsEnd ( _sf , & at -> gi , false ) ;\n max = 0 ;\n for ( i = 0 ;\n i < _sf -> subfontcnt ;\n ++ i ) if ( max < _sf -> subfonts [ i ] -> glyphcnt ) max = _sf -> subfonts [ i ] -> glyphcnt ;\n for ( cid = 0 ;\n cid < max ;\n ++ cid ) {\n for ( i = 0 ;\n i < _sf -> subfontcnt ;\n ++ i ) {\n sf = _sf -> subfonts [ i ] ;\n if ( cid < sf -> glyphcnt && SCWorthOutputting ( sf -> glyphs [ cid ] ) ) break ;\n }\n if ( i != _sf -> subfontcnt ) {\n sc = sf -> glyphs [ cid ] ;\n if ( sc -> ttf_glyph <= at -> gi . lasthwidth ) putshort ( at -> gi . hmtx , sc -> width ) ;\n SplineCharLayerFindBounds ( sc , at -> gi . layer , & b ) ;\n putshort ( at -> gi . hmtx , b . minx ) ;\n if ( dovmetrics ) {\n if ( sc -> ttf_glyph <= at -> gi . lastvwidth ) putshort ( at -> gi . vmtx , sc -> vwidth ) ;\n putshort ( at -> gi . vmtx , b . maxy ) ;\n }\n ++ cnt ;\n if ( sc -> ttf_glyph == at -> gi . lasthwidth ) at -> gi . hfullcnt = cnt ;\n if ( sc -> ttf_glyph == at -> gi . lastvwidth ) at -> gi . vfullcnt = cnt ;\n }\n else if ( cid == 0 ) {\n sf = _sf -> subfonts [ 0 ] ;\n putshort ( at -> gi . hmtx , sf -> ascent + sf -> descent ) ;\n putshort ( at -> gi . hmtx , 0 ) ;\n ++ cnt ;\n if ( dovmetrics ) {\n putshort ( at -> gi . vmtx , sf -> ascent + sf -> descent ) ;\n putshort ( at -> gi . vmtx , 0 ) ;\n }\n }\n }\n at -> gi . hmtxlen = ftell ( at -> gi . hmtx ) ;\n if ( at -> gi . hmtxlen & 2 ) putshort ( at -> gi . hmtx , 0 ) ;\n if ( dovmetrics ) {\n at -> gi . vmtxlen = ftell ( at -> gi . vmtx ) ;\n if ( at -> gi . vmtxlen & 2 ) putshort ( at -> gi . vmtx , 0 ) ;\n }\n at -> gi . maxp -> numGlyphs = cnt ;\n }", "idx": 20644}
{"hash": -7434014980763120366, "project": "debian", "size": 3, "label": 0, "functionSource": "int dissect_ber_relative_oid ( gboolean implicit_tag , asn1_ctx_t * actx , proto_tree * tree , tvbuff_t * tvb , int offset , gint hf_id , tvbuff_t * * value_tvb ) {\n return dissect_ber_any_oid ( implicit_tag , actx , tree , tvb , offset , hf_id , value_tvb , FALSE ) ;\n }", "idx": 20645}
{"hash": 2390790920103114259, "project": "debian", "size": 19, "label": 0, "functionSource": "static void wordchrs ( struct vars * v ) {\n struct state * left ;\n struct state * right ;\n if ( v -> wordchrs != NULL ) {\n NEXT ( ) ;\n return ;\n }\n left = newstate ( v -> nfa ) ;\n right = newstate ( v -> nfa ) ;\n NOERR ( ) ;\n lexword ( v ) ;\n NEXT ( ) ;\n assert ( v -> savenow != NULL && SEE ( '[' ) ) ;\n bracket ( v , left , right ) ;\n assert ( ( v -> savenow != NULL && SEE ( ']' ) ) || ISERR ( ) ) ;\n NEXT ( ) ;\n NOERR ( ) ;\n v -> wordchrs = left ;\n }", "idx": 20646}
{"hash": -7434014980763120366, "project": "debian", "size": 8, "label": 0, "functionSource": "static void ber_check_length ( guint32 length , gint32 min_len , gint32 max_len , asn1_ctx_t * actx , proto_item * item , gboolean bit ) {\n if ( ( min_len != - 1 ) && ( length < ( guint32 ) min_len ) ) {\n expert_add_info_format ( actx -> pinfo , item , & ei_ber_size_constraint_string , \"Size constraint: %sstring too short: %d (%d .. %d)\" , bit ? \"bit \" : \"\" , length , min_len , max_len ) ;\n }\n else if ( ( max_len != - 1 ) && ( length > ( guint32 ) max_len ) ) {\n expert_add_info_format ( actx -> pinfo , item , & ei_ber_size_constraint_string , \"Size constraint: %sstring too long: %d (%d .. %d)\" , bit ? \"bit \" : \"\" , length , min_len , max_len ) ;\n }\n }", "idx": 20647}
{"hash": -5550748970150309774, "project": "debian", "size": 32, "label": 0, "functionSource": "static void ExecuteSimpleCommands ( ArchiveHandle * AH , const char * buf , size_t bufLen ) {\n const char * qry = buf ;\n const char * eos = buf + bufLen ;\n if ( AH -> sqlparse . curCmd == NULL ) AH -> sqlparse . curCmd = createPQExpBuffer ( ) ;\n for ( ;\n qry < eos ;\n qry ++ ) {\n char ch = * qry ;\n if ( ! ( ch == '\\n' && AH -> sqlparse . curCmd -> len == 0 ) ) appendPQExpBufferChar ( AH -> sqlparse . curCmd , ch ) ;\n switch ( AH -> sqlparse . state ) {\n case SQL_SCAN : if ( ch == ';\n' ) {\n ExecuteSqlCommand ( AH , AH -> sqlparse . curCmd -> data , \"could not execute query\" ) ;\n resetPQExpBuffer ( AH -> sqlparse . curCmd ) ;\n }\n else if ( ch == '\\'' ) {\n AH -> sqlparse . state = SQL_IN_SINGLE_QUOTE ;\n AH -> sqlparse . backSlash = false ;\n }\n else if ( ch == '\"' ) {\n AH -> sqlparse . state = SQL_IN_DOUBLE_QUOTE ;\n }\n break ;\n case SQL_IN_SINGLE_QUOTE : if ( ch == '\\'' && ! AH -> sqlparse . backSlash ) AH -> sqlparse . state = SQL_SCAN ;\n else if ( ch == '\\\\' && ! AH -> public . std_strings ) AH -> sqlparse . backSlash = ! AH -> sqlparse . backSlash ;\n else AH -> sqlparse . backSlash = false ;\n break ;\n case SQL_IN_DOUBLE_QUOTE : if ( ch == '\"' ) AH -> sqlparse . state = SQL_SCAN ;\n break ;\n }\n }\n }", "idx": 20648}
{"hash": -5493081488206619677, "project": "debian", "size": 6, "label": 0, "functionSource": "static const char * cmd_collection_timeout ( cmd_parms * cmd , void * _dcfg , const char * p1 ) {\n directory_config * dcfg = ( directory_config * ) _dcfg ;\n dcfg -> col_timeout = atoi ( p1 ) ;\n if ( ( dcfg -> col_timeout >= 0 ) && ( dcfg -> col_timeout <= 2592000 ) ) return NULL ;\n return apr_psprintf ( cmd -> pool , \"ModSecurity: Invalid value for SecCollectionTimeout: %s\" , p1 ) ;\n }", "idx": 20649}
{"hash": 5524055408114021500, "project": "debian", "size": 7, "label": 0, "functionSource": "int ssl3_release_read_buffer ( SSL * s ) {\n if ( s -> s3 -> rbuf . buf != NULL ) {\n freelist_insert ( s -> ctx , 1 , s -> s3 -> rbuf . len , s -> s3 -> rbuf . buf ) ;\n s -> s3 -> rbuf . buf = NULL ;\n }\n return 1 ;\n }", "idx": 20650}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_T_videoBackChannelSend ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_T_videoBackChannelSend , T_videoBackChannelSend_choice , NULL ) ;\n return offset ;\n }", "idx": 20651}
{"hash": -1102844685921778700, "project": "debian", "size": 24, "label": 0, "functionSource": "void archive_string_conversion_set_opt ( struct archive_string_conv * sc , int opt ) {\n switch ( opt ) {\n case SCONV_SET_OPT_UTF8_LIBARCHIVE2X : # if ( defined ( _WIN32 ) && ! defined ( __CYGWIN__ ) ) || defined ( __STDC_ISO_10646__ ) || defined ( __APPLE__ ) ( void ) sc ;\n # else if ( ( sc -> flag & SCONV_UTF8_LIBARCHIVE_2 ) == 0 ) {\n sc -> flag |= SCONV_UTF8_LIBARCHIVE_2 ;\n setup_converter ( sc ) ;\n }\n # endif break ;\n case SCONV_SET_OPT_NORMALIZATION_C : if ( ( sc -> flag & SCONV_NORMALIZATION_C ) == 0 ) {\n sc -> flag |= SCONV_NORMALIZATION_C ;\n sc -> flag &= ~ SCONV_NORMALIZATION_D ;\n setup_converter ( sc ) ;\n }\n break ;\n case SCONV_SET_OPT_NORMALIZATION_D : # if defined ( HAVE_ICONV ) if ( ! ( sc -> flag & SCONV_WIN_CP ) && ( sc -> flag & ( SCONV_FROM_UTF16 | SCONV_FROM_UTF8 ) ) && ! ( sc -> flag & ( SCONV_TO_UTF16 | SCONV_TO_UTF8 ) ) ) break ;\n # endif if ( ( sc -> flag & SCONV_NORMALIZATION_D ) == 0 ) {\n sc -> flag |= SCONV_NORMALIZATION_D ;\n sc -> flag &= ~ SCONV_NORMALIZATION_C ;\n setup_converter ( sc ) ;\n }\n break ;\n default : break ;\n }\n }", "idx": 20652}
{"hash": -5268859819325807498, "project": "debian", "size": 8, "label": 0, "functionSource": "static void filesystem_info_cancel ( NautilusDirectory * directory ) {\n if ( directory -> details -> filesystem_info_state != NULL ) {\n g_cancellable_cancel ( directory -> details -> filesystem_info_state -> cancellable ) ;\n directory -> details -> filesystem_info_state -> directory = NULL ;\n directory -> details -> filesystem_info_state = NULL ;\n async_job_end ( directory , \"filesystem info\" ) ;\n }\n }", "idx": 20653}
{"hash": 2895622461494525400, "project": "debian", "size": 92, "label": 0, "functionSource": "static void test_fetch_date ( ) {\n MYSQL_STMT * stmt ;\n uint i ;\n int rc , year ;\n char date [ 25 ] , my_time [ 25 ] , ts [ 25 ] , ts_4 [ 25 ] , ts_6 [ 20 ] , dt [ 20 ] ;\n ulong d_length , t_length , ts_length , ts4_length , ts6_length , dt_length , y_length ;\n MYSQL_BIND my_bind [ 8 ] ;\n my_bool is_null [ 8 ] ;\n ulong length [ 8 ] ;\n myheader ( \"test_fetch_date\" ) ;\n rc = mysql_query ( mysql , \"SET SQL_MODE=''\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"DROP TABLE IF EXISTS test_bind_result\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"CREATE TABLE test_bind_result(c1 date, c2 time, \\ c3 timestamp, \\ c4 year, \\ c5 datetime, \\ c6 timestamp, \\ c7 timestamp)\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"SET SQL_MODE=''\" ) ;\n rc = mysql_query ( mysql , \"INSERT INTO test_bind_result VALUES('2002-01-02', \\ '12:49:00', \\ '2002-01-02 17:46:59', \\ 2010, \\ '2010-07-10', \\ '2020', '1999-12-29')\" ) ;\n myquery ( rc ) ;\n rc = mysql_commit ( mysql ) ;\n myquery ( rc ) ;\n memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n for ( i = 0 ;\n i < array_elements ( my_bind ) ;\n i ++ ) {\n my_bind [ i ] . is_null = & is_null [ i ] ;\n my_bind [ i ] . length = & length [ i ] ;\n }\n my_bind [ 0 ] . buffer_type = MYSQL_TYPE_STRING ;\n my_bind [ 1 ] = my_bind [ 2 ] = my_bind [ 0 ] ;\n my_bind [ 0 ] . buffer = ( void * ) & date ;\n my_bind [ 0 ] . buffer_length = sizeof ( date ) ;\n my_bind [ 0 ] . length = & d_length ;\n my_bind [ 1 ] . buffer = ( void * ) & my_time ;\n my_bind [ 1 ] . buffer_length = sizeof ( my_time ) ;\n my_bind [ 1 ] . length = & t_length ;\n my_bind [ 2 ] . buffer = ( void * ) & ts ;\n my_bind [ 2 ] . buffer_length = sizeof ( ts ) ;\n my_bind [ 2 ] . length = & ts_length ;\n my_bind [ 3 ] . buffer_type = MYSQL_TYPE_LONG ;\n my_bind [ 3 ] . buffer = ( void * ) & year ;\n my_bind [ 3 ] . length = & y_length ;\n my_bind [ 4 ] . buffer_type = MYSQL_TYPE_STRING ;\n my_bind [ 4 ] . buffer = ( void * ) & dt ;\n my_bind [ 4 ] . buffer_length = sizeof ( dt ) ;\n my_bind [ 4 ] . length = & dt_length ;\n my_bind [ 5 ] . buffer_type = MYSQL_TYPE_STRING ;\n my_bind [ 5 ] . buffer = ( void * ) & ts_4 ;\n my_bind [ 5 ] . buffer_length = sizeof ( ts_4 ) ;\n my_bind [ 5 ] . length = & ts4_length ;\n my_bind [ 6 ] . buffer_type = MYSQL_TYPE_STRING ;\n my_bind [ 6 ] . buffer = ( void * ) & ts_6 ;\n my_bind [ 6 ] . buffer_length = sizeof ( ts_6 ) ;\n my_bind [ 6 ] . length = & ts6_length ;\n rc = my_stmt_result ( \"SELECT * FROM test_bind_result\" ) ;\n DIE_UNLESS ( rc == 1 ) ;\n stmt = mysql_simple_prepare ( mysql , \"SELECT * FROM test_bind_result\" ) ;\n check_stmt ( stmt ) ;\n rc = mysql_stmt_bind_result ( stmt , my_bind ) ;\n check_execute ( stmt , rc ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n ts_4 [ 0 ] = '\\0' ;\n rc = mysql_stmt_fetch ( stmt ) ;\n check_execute ( stmt , rc ) ;\n if ( ! opt_silent ) {\n fprintf ( stdout , \"\\n date : %s(%lu)\" , date , d_length ) ;\n fprintf ( stdout , \"\\n time : %s(%lu)\" , my_time , t_length ) ;\n fprintf ( stdout , \"\\n ts : %s(%lu)\" , ts , ts_length ) ;\n fprintf ( stdout , \"\\n year : %d(%lu)\" , year , y_length ) ;\n fprintf ( stdout , \"\\n dt : %s(%lu)\" , dt , dt_length ) ;\n fprintf ( stdout , \"\\n ts(4) : %s(%lu)\" , ts_4 , ts4_length ) ;\n fprintf ( stdout , \"\\n ts(6) : %s(%lu)\" , ts_6 , ts6_length ) ;\n }\n DIE_UNLESS ( strcmp ( date , \"2002-01-02\" ) == 0 ) ;\n DIE_UNLESS ( d_length == 10 ) ;\n DIE_UNLESS ( strcmp ( my_time , \"12:49:00\" ) == 0 ) ;\n DIE_UNLESS ( t_length == 8 ) ;\n DIE_UNLESS ( strcmp ( ts , \"2002-01-02 17:46:59\" ) == 0 ) ;\n DIE_UNLESS ( ts_length == 19 ) ;\n DIE_UNLESS ( year == 2010 ) ;\n DIE_UNLESS ( y_length == 4 ) ;\n DIE_UNLESS ( strcmp ( dt , \"2010-07-10 00:00:00\" ) == 0 ) ;\n DIE_UNLESS ( dt_length == 19 ) ;\n DIE_UNLESS ( strcmp ( ts_4 , \"0000-00-00 00:00:00\" ) == 0 ) ;\n DIE_UNLESS ( ts4_length == strlen ( \"0000-00-00 00:00:00\" ) ) ;\n DIE_UNLESS ( strcmp ( ts_6 , \"1999-12-29 00:00:00\" ) == 0 ) ;\n DIE_UNLESS ( ts6_length == 19 ) ;\n rc = mysql_stmt_fetch ( stmt ) ;\n DIE_UNLESS ( rc == MYSQL_NO_DATA ) ;\n mysql_stmt_close ( stmt ) ;\n }", "idx": 20654}
{"hash": 1749848421437618984, "project": "chrome", "size": 6, "label": 0, "functionSource": "static hb_script_t hb_ot_old_tag_to_script ( hb_tag_t tag ) {\n if ( unlikely ( tag == HB_OT_TAG_DEFAULT_SCRIPT ) ) return HB_SCRIPT_INVALID ;\n if ( unlikely ( ( tag & 0x0000FF00u ) == 0x00002000u ) ) tag |= ( tag >> 8 ) & 0x0000FF00u ;\n if ( unlikely ( ( tag & 0x000000FFu ) == 0x00000020u ) ) tag |= ( tag >> 8 ) & 0x000000FFu ;\n return ( hb_script_t ) ( tag & ~ 0x20000000u ) ;\n }", "idx": 20655}
{"hash": 3599206110384554647, "project": "debian", "size": 77, "label": 0, "functionSource": "void name ## _free ( type * a ) ;\n # define DECLARE_ASN1_PRINT_FUNCTION ( stname ) DECLARE_ASN1_PRINT_FUNCTION_fname ( stname , stname ) # define DECLARE_ASN1_PRINT_FUNCTION_fname ( stname , fname ) int fname ## _print_ctx ( BIO * out , stname * x , int indent , const ASN1_PCTX * pctx ) ;\n # define D2I_OF ( type ) type * ( * ) ( type * * , const unsigned char * * , long ) # define I2D_OF ( type ) int ( * ) ( type * , unsigned char * * ) # define I2D_OF_const ( type ) int ( * ) ( const type * , unsigned char * * ) # define CHECKED_D2I_OF ( type , d2i ) ( ( d2i_of_void * ) ( 1 ? d2i : ( ( D2I_OF ( type ) ) 0 ) ) ) # define CHECKED_I2D_OF ( type , i2d ) ( ( i2d_of_void * ) ( 1 ? i2d : ( ( I2D_OF ( type ) ) 0 ) ) ) # define CHECKED_NEW_OF ( type , xnew ) ( ( void * ( * ) ( void ) ) ( 1 ? xnew : ( ( type * ( * ) ( void ) ) 0 ) ) ) # define CHECKED_PTR_OF ( type , p ) ( ( void * ) ( 1 ? p : ( type * ) 0 ) ) # define CHECKED_PPTR_OF ( type , p ) ( ( void * * ) ( 1 ? p : ( type * * ) 0 ) ) # define TYPEDEF_D2I_OF ( type ) typedef type * d2i_of_ ## type ( type * * , const unsigned char * * , long ) # define TYPEDEF_I2D_OF ( type ) typedef int i2d_of_ ## type ( type * , unsigned char * * ) # define TYPEDEF_D2I2D_OF ( type ) TYPEDEF_D2I_OF ( type ) ;\n TYPEDEF_I2D_OF ( type ) TYPEDEF_D2I2D_OF ( void ) ;\n # ifndef OPENSSL_EXPORT_VAR_AS_FUNCTION typedef const ASN1_ITEM ASN1_ITEM_EXP ;\n # define ASN1_ITEM_ptr ( iptr ) ( iptr ) # define ASN1_ITEM_ref ( iptr ) ( & ( iptr ## _it ) ) # define ASN1_ITEM_rptr ( ref ) ( & ( ref ## _it ) ) # define DECLARE_ASN1_ITEM ( name ) OPENSSL_EXTERN const ASN1_ITEM name ## _it ;\n # else typedef const ASN1_ITEM * ASN1_ITEM_EXP ( void ) ;\n # define ASN1_ITEM_ptr ( iptr ) ( iptr ( ) ) # define ASN1_ITEM_ref ( iptr ) ( iptr ## _it ) # define ASN1_ITEM_rptr ( ref ) ( ref ## _it ( ) ) # define DECLARE_ASN1_ITEM ( name ) const ASN1_ITEM * name ## _it ( void ) ;\n # endif # define ASN1_STRFLGS_ESC_2253 1 # define ASN1_STRFLGS_ESC_CTRL 2 # define ASN1_STRFLGS_ESC_MSB 4 # define ASN1_STRFLGS_ESC_QUOTE 8 # define CHARTYPE_PRINTABLESTRING 0x10 # define CHARTYPE_FIRST_ESC_2253 0x20 # define CHARTYPE_LAST_ESC_2253 0x40 # define ASN1_STRFLGS_UTF8_CONVERT 0x10 # define ASN1_STRFLGS_IGNORE_TYPE 0x20 # define ASN1_STRFLGS_SHOW_TYPE 0x40 # define ASN1_STRFLGS_DUMP_ALL 0x80 # define ASN1_STRFLGS_DUMP_UNKNOWN 0x100 # define ASN1_STRFLGS_DUMP_DER 0x200 # define ASN1_STRFLGS_ESC_2254 0x400 # define ASN1_STRFLGS_RFC2253 ( ASN1_STRFLGS_ESC_2253 | ASN1_STRFLGS_ESC_CTRL | ASN1_STRFLGS_ESC_MSB | ASN1_STRFLGS_UTF8_CONVERT | ASN1_STRFLGS_DUMP_UNKNOWN | ASN1_STRFLGS_DUMP_DER ) DEFINE_STACK_OF ( ASN1_INTEGER ) DEFINE_STACK_OF ( ASN1_GENERALSTRING ) DEFINE_STACK_OF ( ASN1_UTF8STRING ) typedef struct asn1_type_st {\n int type ;\n union {\n char * ptr ;\n ASN1_BOOLEAN boolean ;\n ASN1_STRING * asn1_string ;\n ASN1_OBJECT * object ;\n ASN1_INTEGER * integer ;\n ASN1_ENUMERATED * enumerated ;\n ASN1_BIT_STRING * bit_string ;\n ASN1_OCTET_STRING * octet_string ;\n ASN1_PRINTABLESTRING * printablestring ;\n ASN1_T61STRING * t61string ;\n ASN1_IA5STRING * ia5string ;\n ASN1_GENERALSTRING * generalstring ;\n ASN1_BMPSTRING * bmpstring ;\n ASN1_UNIVERSALSTRING * universalstring ;\n ASN1_UTCTIME * utctime ;\n ASN1_GENERALIZEDTIME * generalizedtime ;\n ASN1_VISIBLESTRING * visiblestring ;\n ASN1_UTF8STRING * utf8string ;\n ASN1_STRING * set ;\n ASN1_STRING * sequence ;\n ASN1_VALUE * asn1_value ;\n }\n value ;\n }\n ASN1_TYPE ;\n DEFINE_STACK_OF ( ASN1_TYPE ) typedef STACK_OF ( ASN1_TYPE ) ASN1_SEQUENCE_ANY ;\n DECLARE_ASN1_ENCODE_FUNCTIONS_const ( ASN1_SEQUENCE_ANY , ASN1_SEQUENCE_ANY ) DECLARE_ASN1_ENCODE_FUNCTIONS_const ( ASN1_SEQUENCE_ANY , ASN1_SET_ANY ) typedef struct BIT_STRING_BITNAME_st {\n int bitnum ;\n const char * lname ;\n const char * sname ;\n }\n BIT_STRING_BITNAME ;\n # define B_ASN1_TIME B_ASN1_UTCTIME | B_ASN1_GENERALIZEDTIME # define B_ASN1_PRINTABLE B_ASN1_NUMERICSTRING | B_ASN1_PRINTABLESTRING | B_ASN1_T61STRING | B_ASN1_IA5STRING | B_ASN1_BIT_STRING | B_ASN1_UNIVERSALSTRING | B_ASN1_BMPSTRING | B_ASN1_UTF8STRING | B_ASN1_SEQUENCE | B_ASN1_UNKNOWN # define B_ASN1_DIRECTORYSTRING B_ASN1_PRINTABLESTRING | B_ASN1_TELETEXSTRING | B_ASN1_BMPSTRING | B_ASN1_UNIVERSALSTRING | B_ASN1_UTF8STRING # define B_ASN1_DISPLAYTEXT B_ASN1_IA5STRING | B_ASN1_VISIBLESTRING | B_ASN1_BMPSTRING | B_ASN1_UTF8STRING DECLARE_ASN1_FUNCTIONS_fname ( ASN1_TYPE , ASN1_ANY , ASN1_TYPE ) int ASN1_TYPE_get ( const ASN1_TYPE * a ) ;\n void ASN1_TYPE_set ( ASN1_TYPE * a , int type , void * value ) ;\n int ASN1_TYPE_set1 ( ASN1_TYPE * a , int type , const void * value ) ;\n int ASN1_TYPE_cmp ( const ASN1_TYPE * a , const ASN1_TYPE * b ) ;\n ASN1_TYPE * ASN1_TYPE_pack_sequence ( const ASN1_ITEM * it , void * s , ASN1_TYPE * * t ) ;\n void * ASN1_TYPE_unpack_sequence ( const ASN1_ITEM * it , const ASN1_TYPE * t ) ;\n ASN1_OBJECT * ASN1_OBJECT_new ( void ) ;\n void ASN1_OBJECT_free ( ASN1_OBJECT * a ) ;\n int i2d_ASN1_OBJECT ( const ASN1_OBJECT * a , unsigned char * * pp ) ;\n ASN1_OBJECT * d2i_ASN1_OBJECT ( ASN1_OBJECT * * a , const unsigned char * * pp , long length ) ;\n DECLARE_ASN1_ITEM ( ASN1_OBJECT ) DEFINE_STACK_OF ( ASN1_OBJECT ) ASN1_STRING * ASN1_STRING_new ( void ) ;\n void ASN1_STRING_free ( ASN1_STRING * a ) ;\n void ASN1_STRING_clear_free ( ASN1_STRING * a ) ;\n int ASN1_STRING_copy ( ASN1_STRING * dst , const ASN1_STRING * str ) ;\n ASN1_STRING * ASN1_STRING_dup ( const ASN1_STRING * a ) ;\n ASN1_STRING * ASN1_STRING_type_new ( int type ) ;\n int ASN1_STRING_cmp ( const ASN1_STRING * a , const ASN1_STRING * b ) ;\n int ASN1_STRING_set ( ASN1_STRING * str , const void * data , int len ) ;\n void ASN1_STRING_set0 ( ASN1_STRING * str , void * data , int len ) ;\n int ASN1_STRING_length ( const ASN1_STRING * x ) ;\n void ASN1_STRING_length_set ( ASN1_STRING * x , int n ) ;\n int ASN1_STRING_type ( const ASN1_STRING * x ) ;\n DEPRECATEDIN_1_1_0 ( unsigned char * ASN1_STRING_data ( ASN1_STRING * x ) ) const unsigned char * ASN1_STRING_get0_data ( const ASN1_STRING * x ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_BIT_STRING ) int ASN1_BIT_STRING_set ( ASN1_BIT_STRING * a , unsigned char * d , int length ) ;\n int ASN1_BIT_STRING_set_bit ( ASN1_BIT_STRING * a , int n , int value ) ;\n int ASN1_BIT_STRING_get_bit ( const ASN1_BIT_STRING * a , int n ) ;\n int ASN1_BIT_STRING_check ( const ASN1_BIT_STRING * a , const unsigned char * flags , int flags_len ) ;\n int ASN1_BIT_STRING_name_print ( BIO * out , ASN1_BIT_STRING * bs , BIT_STRING_BITNAME * tbl , int indent ) ;\n int ASN1_BIT_STRING_num_asc ( const char * name , BIT_STRING_BITNAME * tbl ) ;\n int ASN1_BIT_STRING_set_asc ( ASN1_BIT_STRING * bs , const char * name , int value , BIT_STRING_BITNAME * tbl ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_INTEGER ) ASN1_INTEGER * d2i_ASN1_UINTEGER ( ASN1_INTEGER * * a , const unsigned char * * pp , long length ) ;\n ASN1_INTEGER * ASN1_INTEGER_dup ( const ASN1_INTEGER * x ) ;\n int ASN1_INTEGER_cmp ( const ASN1_INTEGER * x , const ASN1_INTEGER * y ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_ENUMERATED )", "idx": 20656}
{"hash": 3599206110384554647, "project": "debian", "size": 48, "label": 1, "functionSource": "static ossl_inline t2 * sk_ ## t1 ## _delete_ptr ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return ( t2 * ) OPENSSL_sk_delete_ptr ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _push ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_push ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _unshift ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_unshift ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _pop ( STACK_OF ( t1 ) * sk ) {\n return ( t2 * ) OPENSSL_sk_pop ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _shift ( STACK_OF ( t1 ) * sk ) {\n return ( t2 * ) OPENSSL_sk_shift ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline void sk_ ## t1 ## _pop_free ( STACK_OF ( t1 ) * sk , sk_ ## t1 ## _freefunc freefunc ) {\n OPENSSL_sk_pop_free ( ( OPENSSL_STACK * ) sk , ( OPENSSL_sk_freefunc ) freefunc ) ;\n }\n static ossl_inline int sk_ ## t1 ## _insert ( STACK_OF ( t1 ) * sk , t2 * ptr , int idx ) {\n return OPENSSL_sk_insert ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr , idx ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _set ( STACK_OF ( t1 ) * sk , int idx , t2 * ptr ) {\n return ( t2 * ) OPENSSL_sk_set ( ( OPENSSL_STACK * ) sk , idx , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _find ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_find ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _find_ex ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_find_ex ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline void sk_ ## t1 ## _sort ( STACK_OF ( t1 ) * sk ) {\n OPENSSL_sk_sort ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline int sk_ ## t1 ## _is_sorted ( const STACK_OF ( t1 ) * sk ) {\n return OPENSSL_sk_is_sorted ( ( const OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _dup ( const STACK_OF ( t1 ) * sk ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_dup ( ( const OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _deep_copy ( const STACK_OF ( t1 ) * sk , sk_ ## t1 ## _copyfunc copyfunc , sk_ ## t1 ## _freefunc freefunc ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_deep_copy ( ( const OPENSSL_STACK * ) sk , ( OPENSSL_sk_copyfunc ) copyfunc , ( OPENSSL_sk_freefunc ) freefunc ) ;\n }\n static ossl_inline sk_ ## t1 ## _compfunc sk_ ## t1 ## _set_cmp_func ( STACK_OF ( t1 ) * sk , sk_ ## t1 ## _compfunc compare ) {\n return ( sk_ ## t1 ## _compfunc ) OPENSSL_sk_set_cmp_func ( ( OPENSSL_STACK * ) sk , ( OPENSSL_sk_compfunc ) compare ) ;\n }\n # define DEFINE_SPECIAL_STACK_OF ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , t2 , t2 ) # define DEFINE_STACK_OF ( t ) SKM_DEFINE_STACK_OF ( t , t , t ) # define DEFINE_SPECIAL_STACK_OF_CONST ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , const t2 , t2 ) # define DEFINE_STACK_OF_CONST ( t ) SKM_DEFINE_STACK_OF ( t , const t , t ) typedef char * OPENSSL_STRING ;\n typedef const char * OPENSSL_CSTRING ;\n DEFINE_SPECIAL_STACK_OF ( OPENSSL_STRING , char )", "idx": 20657}
{"hash": -3135212895432241239, "project": "debian", "size": 19, "label": 0, "functionSource": "static guint32 dissect_netb_name_resp ( tvbuff_t * tvb , packet_info * pinfo _U_ , int offset , proto_tree * tree ) {\n guint8 local_session_number = tvb_get_guint8 ( tvb , offset + NB_DATA2 ) ;\n switch ( local_session_number ) {\n case 0x00 : proto_tree_add_uint_format_value ( tree , hf_netb_state_of_name , tvb , offset + NB_DATA2 , 1 , local_session_number , \"No LISTEN pending, or FIND.NAME response\" ) ;\n break ;\n case 0xFF : proto_tree_add_uint_format_value ( tree , hf_netb_state_of_name , tvb , offset + NB_DATA2 , 1 , local_session_number , \"LISTEN pending, but insufficient resources to establish session\" ) ;\n break ;\n default : proto_tree_add_item ( tree , hf_netb_local_session_no , tvb , offset + NB_DATA2 , 1 , ENC_LITTLE_ENDIAN ) ;\n break ;\n }\n nb_call_name_type ( tvb , offset , tree ) ;\n nb_xmit_corrl ( tvb , offset , tree ) ;\n if ( local_session_number != 0x00 && local_session_number != 0xFF ) nb_resp_corrl ( tvb , offset , tree ) ;\n netbios_add_name ( \"Receiver's Name\" , tvb , offset + NB_RECVER_NAME , tree ) ;\n if ( local_session_number != 0x00 && local_session_number != 0xFF ) {\n netbios_add_name ( \"Sender's Name\" , tvb , offset + NB_SENDER_NAME , tree ) ;\n }\n return 0 ;\n }", "idx": 20658}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_EnhancementOptions ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_EnhancementOptions , EnhancementOptions_sequence ) ;\n return offset ;\n }", "idx": 20659}
{"hash": 5825340398912191389, "project": "debian", "size": 18, "label": 0, "functionSource": "extern int name ( int ) __THROW __exctype ( isalnum ) ;\n __exctype ( isalpha ) ;\n __exctype ( iscntrl ) ;\n __exctype ( isdigit ) ;\n __exctype ( islower ) ;\n __exctype ( isgraph ) ;\n __exctype ( isprint ) ;\n __exctype ( ispunct ) ;\n __exctype ( isspace ) ;\n __exctype ( isupper ) ;\n __exctype ( isxdigit ) ;\n extern int tolower ( int __c ) __THROW ;\n extern int toupper ( int __c ) __THROW ;\n # ifdef __USE_ISOC99 __exctype ( isblank ) ;\n # endif # ifdef __USE_GNU extern int isctype ( int __c , int __mask ) __THROW ;\n # endif # if defined __USE_MISC || defined __USE_XOPEN extern int isascii ( int __c ) __THROW ;\n extern int toascii ( int __c ) __THROW ;\n __exctype ( _toupper )", "idx": 20660}
{"hash": -1270180049246846366, "project": "chrome", "size": 4, "label": 0, "functionSource": "void hb_face_set_index ( hb_face_t * face , unsigned int index ) {\n if ( face -> immutable ) return ;\n face -> index = index ;\n }", "idx": 20661}
{"hash": -2661809302248698892, "project": "debian", "size": 6, "label": 0, "functionSource": "static int mix ( int c0 , int c1 ) {\n int blue = 2 * ( c0 & 0x001F ) + ( c1 & 0x001F ) ;\n int green = ( 2 * ( c0 & 0x03E0 ) + ( c1 & 0x03E0 ) ) >> 5 ;\n int red = 2 * ( c0 >> 10 ) + ( c1 >> 10 ) ;\n return red / 3 * 1024 + green / 3 * 32 + blue / 3 ;\n }", "idx": 20662}
{"hash": -3044261571134154368, "project": "debian", "size": 39, "label": 0, "functionSource": "static void test_rfc822_parse_quoted_string ( void ) {\n const struct {\n const char * input , * output ;\n int ret ;\n }\n tests [ ] = {\n {\n \"\\\"\" , \"\" , - 1 }\n , {\n \"\\\"\\\"\" , \"\" , 0 }\n , {\n \"\\\"foo\\\"\" , \"foo\" , 0 }\n , {\n \"\\\"\\\"foo\" , \"\" , 1 }\n , {\n \"\\\"\\\"\\\"\" , \"\" , 1 }\n , {\n \"\\\"\\\\\\\"\\\"\" , \"\\\"\" , 0 }\n , {\n \"\\\"\\\\\\\\\\\"\" , \"\\\\\" , 0 }\n , {\n \"\\\"\\\\\\\\foo\\\\\\\\foo\\\\\\\\\\\"\" , \"\\\\foo\\\\foo\\\\\" , 0 }\n }\n ;\n struct rfc822_parser_context parser ;\n string_t * str = t_str_new ( 64 ) ;\n unsigned int i = 0 ;\n test_begin ( \"rfc822 parse quoted string\" ) ;\n for ( i = 0 ;\n i < N_ELEMENTS ( tests ) ;\n i ++ ) {\n rfc822_parser_init ( & parser , ( const void * ) tests [ i ] . input , strlen ( tests [ i ] . input ) , NULL ) ;\n test_assert_idx ( rfc822_parse_quoted_string ( & parser , str ) == tests [ i ] . ret , i ) ;\n test_assert_idx ( tests [ i ] . ret < 0 || strcmp ( tests [ i ] . output , str_c ( str ) ) == 0 , i ) ;\n rfc822_parser_deinit ( & parser ) ;\n str_truncate ( str , 0 ) ;\n }\n test_end ( ) ;\n }", "idx": 20663}
{"hash": -2222463888415249941, "project": "chrome", "size": 12, "label": 0, "functionSource": "void vp9_set_high_precision_mv ( VP9_COMP * cpi , int allow_high_precision_mv ) {\n MACROBLOCK * const mb = & cpi -> mb ;\n cpi -> common . allow_high_precision_mv = allow_high_precision_mv ;\n if ( cpi -> common . allow_high_precision_mv ) {\n mb -> mvcost = mb -> nmvcost_hp ;\n mb -> mvsadcost = mb -> nmvsadcost_hp ;\n }\n else {\n mb -> mvcost = mb -> nmvcost ;\n mb -> mvsadcost = mb -> nmvsadcost ;\n }\n }", "idx": 20664}
{"hash": -5268859819325807498, "project": "debian", "size": 3, "label": 0, "functionSource": "static gboolean lacks_info ( NautilusFile * file ) {\n return ! file -> details -> file_info_is_up_to_date && ! file -> details -> is_gone ;\n }", "idx": 20665}
{"hash": -5968890769755017734, "project": "debian", "size": 8, "label": 0, "functionSource": "static bool iswheel ( const char * username ) {\n struct group * grp ;\n grp = getgrnam ( \"wheel\" ) ;\n if ( ( NULL == grp ) || ( NULL == grp -> gr_mem ) ) {\n return false ;\n }\n return is_on_list ( grp -> gr_mem , username ) ;\n }", "idx": 20666}
{"hash": 9176142195250515812, "project": "debian", "size": 6, "label": 0, "functionSource": "static void prplcb_conn_report_disconnect_reason ( PurpleConnection * gc , PurpleConnectionError reason , const char * text ) {\n struct im_connection * ic = purple_ic_by_gc ( gc ) ;\n if ( ic != NULL ) {\n imcb_error ( ic , \"%s\" , text ) ;\n }\n }", "idx": 20667}
{"hash": 1223258652239369123, "project": "debian", "size": 29, "label": 0, "functionSource": "SPL_METHOD ( SplFileObject , setCsvControl ) {\n spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n char delimiter = ',' , enclosure = '\"' , escape = '\\\\' ;\n char * delim = NULL , * enclo = NULL , * esc = NULL ;\n int d_len = 0 , e_len = 0 , esc_len = 0 ;\n if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , \"|sss\" , & delim , & d_len , & enclo , & e_len , & esc , & esc_len ) == SUCCESS ) {\n switch ( ZEND_NUM_ARGS ( ) ) {\n case 3 : if ( esc_len != 1 ) {\n php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"escape must be a character\" ) ;\n RETURN_FALSE ;\n }\n escape = esc [ 0 ] ;\n case 2 : if ( e_len != 1 ) {\n php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"enclosure must be a character\" ) ;\n RETURN_FALSE ;\n }\n enclosure = enclo [ 0 ] ;\n case 1 : if ( d_len != 1 ) {\n php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"delimiter must be a character\" ) ;\n RETURN_FALSE ;\n }\n delimiter = delim [ 0 ] ;\n case 0 : break ;\n }\n intern -> u . file . delimiter = delimiter ;\n intern -> u . file . enclosure = enclosure ;\n intern -> u . file . escape = escape ;\n }\n }", "idx": 20668}
{"hash": 6302861533225984845, "project": "debian", "size": 16, "label": 0, "functionSource": "static PXA2xxFIrState * pxa2xx_fir_init ( MemoryRegion * sysmem , hwaddr base , qemu_irq irq , qemu_irq rx_dma , qemu_irq tx_dma , CharDriverState * chr ) {\n PXA2xxFIrState * s = ( PXA2xxFIrState * ) g_malloc0 ( sizeof ( PXA2xxFIrState ) ) ;\n s -> irq = irq ;\n s -> rx_dma = rx_dma ;\n s -> tx_dma = tx_dma ;\n s -> chr = chr ;\n pxa2xx_fir_reset ( s ) ;\n memory_region_init_io ( & s -> iomem , NULL , & pxa2xx_fir_ops , s , \"pxa2xx-fir\" , 0x1000 ) ;\n memory_region_add_subregion ( sysmem , base , & s -> iomem ) ;\n if ( chr ) {\n qemu_chr_fe_claim_no_fail ( chr ) ;\n qemu_chr_add_handlers ( chr , pxa2xx_fir_is_empty , pxa2xx_fir_rx , pxa2xx_fir_event , s ) ;\n }\n register_savevm ( NULL , \"pxa2xx_fir\" , 0 , 0 , pxa2xx_fir_save , pxa2xx_fir_load , s ) ;\n return s ;\n }", "idx": 20669}
{"hash": 1223258652239369123, "project": "debian", "size": 7, "label": 0, "functionSource": "static void spl_filesystem_dir_it_dtor ( zend_object_iterator * iter TSRMLS_DC ) {\n spl_filesystem_iterator * iterator = ( spl_filesystem_iterator * ) iter ;\n if ( iterator -> intern . data ) {\n zval * object = iterator -> intern . data ;\n zval_ptr_dtor ( & object ) ;\n }\n }", "idx": 20670}
{"hash": -7884836206149374350, "project": "chrome", "size": 3, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( UsbChooserBrowserTest , InvokeDialog_NoDevicesBubble ) {\n RunDialog ( ) ;\n }", "idx": 20671}
{"hash": 9160937366035817353, "project": "chrome", "size": 32, "label": 0, "functionSource": "int vp9_full_search_sad_c ( const MACROBLOCK * x , const MV * ref_mv , int sad_per_bit , int distance , const vp9_variance_fn_ptr_t * fn_ptr , const MV * center_mv , MV * best_mv ) {\n int r , c ;\n const MACROBLOCKD * const xd = & x -> e_mbd ;\n const struct buf_2d * const what = & x -> plane [ 0 ] . src ;\n const struct buf_2d * const in_what = & xd -> plane [ 0 ] . pre [ 0 ] ;\n const int row_min = MAX ( ref_mv -> row - distance , x -> mv_row_min ) ;\n const int row_max = MIN ( ref_mv -> row + distance , x -> mv_row_max ) ;\n const int col_min = MAX ( ref_mv -> col - distance , x -> mv_col_min ) ;\n const int col_max = MIN ( ref_mv -> col + distance , x -> mv_col_max ) ;\n const MV fcenter_mv = {\n center_mv -> row >> 3 , center_mv -> col >> 3 }\n ;\n int best_sad = fn_ptr -> sdf ( what -> buf , what -> stride , get_buf_from_mv ( in_what , ref_mv ) , in_what -> stride ) + mvsad_err_cost ( x , ref_mv , & fcenter_mv , sad_per_bit ) ;\n * best_mv = * ref_mv ;\n for ( r = row_min ;\n r < row_max ;\n ++ r ) {\n for ( c = col_min ;\n c < col_max ;\n ++ c ) {\n const MV mv = {\n r , c }\n ;\n const int sad = fn_ptr -> sdf ( what -> buf , what -> stride , get_buf_from_mv ( in_what , & mv ) , in_what -> stride ) + mvsad_err_cost ( x , & mv , & fcenter_mv , sad_per_bit ) ;\n if ( sad < best_sad ) {\n best_sad = sad ;\n * best_mv = mv ;\n }\n }\n }\n return best_sad ;\n }", "idx": 20672}
{"hash": 847431771831526026, "project": "debian", "size": 17, "label": 0, "functionSource": "static size_t encode_block ( char * str , char * buf , size_t buflen , const char * fromcode , const char * tocode , encoder_t encoder ) {\n if ( ! fromcode ) {\n return ( * encoder ) ( str , buf , buflen , tocode ) ;\n }\n const iconv_t cd = mutt_ch_iconv_open ( tocode , fromcode , 0 ) ;\n assert ( cd != ( iconv_t ) ( - 1 ) ) ;\n const char * ib = buf ;\n size_t ibl = buflen ;\n char tmp [ ENCWORD_LEN_MAX - ENCWORD_LEN_MIN + 1 ] ;\n char * ob = tmp ;\n size_t obl = sizeof ( tmp ) - strlen ( tocode ) ;\n const size_t n1 = iconv ( cd , ( ICONV_CONST char * * ) & ib , & ibl , & ob , & obl ) ;\n const size_t n2 = iconv ( cd , NULL , NULL , & ob , & obl ) ;\n assert ( n1 != ( size_t ) ( - 1 ) && n2 != ( size_t ) ( - 1 ) ) ;\n iconv_close ( cd ) ;\n return ( * encoder ) ( str , tmp , ob - tmp , tocode ) ;\n }", "idx": 20673}
{"hash": -1672864273235910388, "project": "debian", "size": 12, "label": 0, "functionSource": "inline static void _slurm_rpc_trigger_set ( slurm_msg_t * msg ) {\n int rc ;\n uid_t uid = g_slurm_auth_get_uid ( msg -> auth_cred , slurmctld_config . auth_info ) ;\n gid_t gid = g_slurm_auth_get_gid ( msg -> auth_cred , slurmctld_config . auth_info ) ;\n trigger_info_msg_t * trigger_ptr = ( trigger_info_msg_t * ) msg -> data ;\n DEF_TIMERS ;\n START_TIMER ;\n debug ( \"Processing RPC: REQUEST_TRIGGER_SET from uid=%d\" , uid ) ;\n rc = trigger_set ( uid , gid , trigger_ptr ) ;\n END_TIMER2 ( \"_slurm_rpc_trigger_set\" ) ;\n slurm_send_rc_msg ( msg , rc ) ;\n }", "idx": 20674}
{"hash": -1102844685921778700, "project": "debian", "size": 4, "label": 0, "functionSource": "const char * archive_string_conversion_charset_name ( struct archive_string_conv * sc ) {\n if ( sc -> flag & SCONV_TO_CHARSET ) return ( sc -> to_charset ) ;\n else return ( sc -> from_charset ) ;\n }", "idx": 20675}
{"hash": -7117046864335130087, "project": "chrome", "size": 6, "label": 0, "functionSource": "static void update_alt_ref_frame_stats ( VP9_COMP * cpi ) {\n RATE_CONTROL * const rc = & cpi -> rc ;\n rc -> frames_since_golden = 0 ;\n rc -> source_alt_ref_pending = 0 ;\n rc -> source_alt_ref_active = 1 ;\n }", "idx": 20676}
{"hash": -7855974557509681261, "project": "debian", "size": 9, "label": 0, "functionSource": "bool get_func_retset ( Oid funcid ) {\n HeapTuple tp ;\n bool result ;\n tp = SearchSysCache1 ( PROCOID , ObjectIdGetDatum ( funcid ) ) ;\n if ( ! HeapTupleIsValid ( tp ) ) elog ( ERROR , \"cache lookup failed for function %u\" , funcid ) ;\n result = ( ( Form_pg_proc ) GETSTRUCT ( tp ) ) -> proretset ;\n ReleaseSysCache ( tp ) ;\n return result ;\n }", "idx": 20677}
{"hash": -1950979830238945732, "project": "debian", "size": 2, "label": 0, "functionSource": "static void DebugRepaint ( ttfFont * ttf ) {\n }", "idx": 20678}
{"hash": -1315695702746584250, "project": "debian", "size": 9, "label": 0, "functionSource": "proto_tree * ptvcursor_push_subtree ( ptvcursor_t * ptvc , proto_item * it , gint ett_subtree ) {\n subtree_lvl * subtree ;\n if ( ptvc -> pushed_tree_index >= ptvc -> pushed_tree_max ) ptvcursor_new_subtree_levels ( ptvc ) ;\n subtree = ptvc -> pushed_tree + ptvc -> pushed_tree_index ;\n subtree -> tree = ptvc -> tree ;\n subtree -> it = NULL ;\n ptvc -> pushed_tree_index ++ ;\n return ptvcursor_set_subtree ( ptvc , it , ett_subtree ) ;\n }", "idx": 20679}
{"hash": 3487452046891662469, "project": "debian", "size": 3, "label": 0, "functionSource": "static inline void dpy_resize ( DisplayState * s , int w , int h ) {\n s -> dpy_resize ( s , w , h ) ;\n }", "idx": 20680}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_FunctionNotSupported ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_FunctionNotSupported , FunctionNotSupported_sequence ) ;\n return offset ;\n }", "idx": 20681}
{"hash": 2820551931453396101, "project": "debian", "size": 4, "label": 0, "functionSource": "static long uptomult ( long x , long y ) {\n assert ( x >= 0 ) ;\n return ( ( x + y - 1 ) / y ) * y ;\n }", "idx": 20682}
{"hash": -560820000732125076, "project": "chrome", "size": 15, "label": 0, "functionSource": "static double exsltMathMin ( xmlNodeSetPtr ns ) {\n double ret , cur ;\n int i ;\n if ( ( ns == NULL ) || ( ns -> nodeNr == 0 ) ) return ( xmlXPathNAN ) ;\n ret = xmlXPathCastNodeToNumber ( ns -> nodeTab [ 0 ] ) ;\n if ( xmlXPathIsNaN ( ret ) ) return ( xmlXPathNAN ) ;\n for ( i = 1 ;\n i < ns -> nodeNr ;\n i ++ ) {\n cur = xmlXPathCastNodeToNumber ( ns -> nodeTab [ i ] ) ;\n if ( xmlXPathIsNaN ( cur ) ) return ( xmlXPathNAN ) ;\n if ( cur < ret ) ret = cur ;\n }\n return ( ret ) ;\n }", "idx": 20683}
{"hash": 1208165234047591297, "project": "debian", "size": 21, "label": 0, "functionSource": "void parseArrayComplex ( proto_tree * tree , tvbuff_t * tvb , packet_info * pinfo , gint * pOffset , const char * szFieldName , const char * szTypeName , fctComplexTypeParser pParserFunction , const gint idx ) {\n proto_item * ti ;\n proto_tree * subtree = proto_tree_add_subtree_format ( tree , tvb , * pOffset , - 1 , idx , & ti , \"%s: Array of %s\" , szFieldName , szTypeName ) ;\n int i ;\n gint32 iLen ;\n iLen = tvb_get_letohl ( tvb , * pOffset ) ;\n proto_tree_add_item ( subtree , hf_opcua_ArraySize , tvb , * pOffset , 4 , ENC_LITTLE_ENDIAN ) ;\n if ( iLen > MAX_ARRAY_LEN ) {\n proto_tree_add_expert_format ( subtree , pinfo , & ei_array_length , tvb , * pOffset , 4 , \"Array length %d too large to process\" , iLen ) ;\n return ;\n }\n * pOffset += 4 ;\n for ( i = 0 ;\n i < iLen ;\n i ++ ) {\n char szNum [ 20 ] ;\n g_snprintf ( szNum , 20 , \"[%i]\" , i ) ;\n ( * pParserFunction ) ( subtree , tvb , pinfo , pOffset , szNum ) ;\n }\n proto_item_set_end ( ti , tvb , * pOffset ) ;\n }", "idx": 20684}
{"hash": -866921002076081979, "project": "debian", "size": 37, "label": 0, "functionSource": "EXCLUSIVE_REGRESSION_TEST ( SDK_API_HttpHookAdd ) ( RegressionTest * test , int , int * pstatus ) {\n * pstatus = REGRESSION_TEST_INPROGRESS ;\n TSCont cont = TSContCreate ( mytest_handler , TSMutexCreate ( ) ) ;\n SocketTest * socktest = ( SocketTest * ) TSmalloc ( sizeof ( SocketTest ) ) ;\n socktest -> regtest = test ;\n socktest -> pstatus = pstatus ;\n socktest -> hook_mask = 0 ;\n socktest -> reenable_mask = 0 ;\n socktest -> test_client_ip_get = false ;\n socktest -> test_client_incoming_port_get = false ;\n socktest -> test_client_req_get = false ;\n socktest -> test_client_resp_get = false ;\n socktest -> test_server_ip_get = false ;\n socktest -> test_server_req_get = false ;\n socktest -> test_server_resp_get = false ;\n socktest -> test_next_hop_ip_get = false ;\n socktest -> magic = MAGIC_ALIVE ;\n TSContDataSet ( cont , socktest ) ;\n TSHttpHookAdd ( TS_HTTP_TXN_START_HOOK , cont ) ;\n TSHttpHookAdd ( TS_HTTP_READ_REQUEST_HDR_HOOK , cont ) ;\n TSHttpHookAdd ( TS_HTTP_OS_DNS_HOOK , cont ) ;\n TSHttpHookAdd ( TS_HTTP_CACHE_LOOKUP_COMPLETE_HOOK , cont ) ;\n TSHttpHookAdd ( TS_HTTP_SEND_REQUEST_HDR_HOOK , cont ) ;\n TSHttpHookAdd ( TS_HTTP_READ_RESPONSE_HDR_HOOK , cont ) ;\n TSHttpHookAdd ( TS_HTTP_SEND_RESPONSE_HDR_HOOK , cont ) ;\n TSHttpHookAdd ( TS_HTTP_TXN_CLOSE_HOOK , cont ) ;\n socktest -> os = synserver_create ( SYNSERVER_LISTEN_PORT ) ;\n synserver_start ( socktest -> os ) ;\n socktest -> browser = synclient_txn_create ( ) ;\n char * request = generate_request ( HTTP_HOOK_TEST_REQUEST_ID ) ;\n synclient_txn_send_request ( socktest -> browser , request ) ;\n TSfree ( request ) ;\n if ( socktest -> browser -> status == REQUEST_INPROGRESS ) {\n TSContSchedule ( cont , 25 , TS_THREAD_POOL_DEFAULT ) ;\n }\n return ;\n }", "idx": 20685}
{"hash": -2226094829431805196, "project": "debian", "size": 83, "label": 0, "functionSource": "static int jpc_pi_nextrpcl ( register jpc_pi_t * pi ) {\n int rlvlno ;\n jpc_pirlvl_t * pirlvl ;\n jpc_pchg_t * pchg ;\n int prchind ;\n int prcvind ;\n int * prclyrno ;\n int compno ;\n jpc_picomp_t * picomp ;\n int xstep ;\n int ystep ;\n uint_fast32_t r ;\n uint_fast32_t rpx ;\n uint_fast32_t rpy ;\n uint_fast32_t trx0 ;\n uint_fast32_t try0 ;\n pchg = pi -> pchg ;\n if ( ! pi -> prgvolfirst ) {\n goto skip ;\n }\n else {\n pi -> xstep = 0 ;\n pi -> ystep = 0 ;\n for ( compno = 0 , picomp = pi -> picomps ;\n compno < pi -> numcomps ;\n ++ compno , ++ picomp ) {\n for ( rlvlno = 0 , pirlvl = picomp -> pirlvls ;\n rlvlno < picomp -> numrlvls ;\n ++ rlvlno , ++ pirlvl ) {\n xstep = picomp -> hsamp * ( 1 << ( pirlvl -> prcwidthexpn + picomp -> numrlvls - rlvlno - 1 ) ) ;\n ystep = picomp -> vsamp * ( 1 << ( pirlvl -> prcheightexpn + picomp -> numrlvls - rlvlno - 1 ) ) ;\n pi -> xstep = ( ! pi -> xstep ) ? xstep : JAS_MIN ( pi -> xstep , xstep ) ;\n pi -> ystep = ( ! pi -> ystep ) ? ystep : JAS_MIN ( pi -> ystep , ystep ) ;\n }\n }\n pi -> prgvolfirst = 0 ;\n }\n for ( pi -> rlvlno = pchg -> rlvlnostart ;\n pi -> rlvlno < pchg -> rlvlnoend && pi -> rlvlno < pi -> maxrlvls ;\n ++ pi -> rlvlno ) {\n for ( pi -> y = pi -> ystart ;\n pi -> y < pi -> yend ;\n pi -> y += pi -> ystep - ( pi -> y % pi -> ystep ) ) {\n for ( pi -> x = pi -> xstart ;\n pi -> x < pi -> xend ;\n pi -> x += pi -> xstep - ( pi -> x % pi -> xstep ) ) {\n for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ;\n pi -> compno < JAS_CAST ( int , pchg -> compnoend ) && pi -> compno < pi -> numcomps ;\n ++ pi -> compno , ++ pi -> picomp ) {\n if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) {\n continue ;\n }\n pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ;\n if ( pi -> pirlvl -> numprcs == 0 ) {\n continue ;\n }\n r = pi -> picomp -> numrlvls - 1 - pi -> rlvlno ;\n rpx = r + pi -> pirlvl -> prcwidthexpn ;\n rpy = r + pi -> pirlvl -> prcheightexpn ;\n trx0 = JPC_CEILDIV ( pi -> xstart , pi -> picomp -> hsamp << r ) ;\n try0 = JPC_CEILDIV ( pi -> ystart , pi -> picomp -> vsamp << r ) ;\n if ( ( ( pi -> x == pi -> xstart && ( ( trx0 << r ) % ( 1 << rpx ) ) ) || ! ( pi -> x % ( 1 << rpx ) ) ) && ( ( pi -> y == pi -> ystart && ( ( try0 << r ) % ( 1 << rpy ) ) ) || ! ( pi -> y % ( 1 << rpy ) ) ) ) {\n prchind = JPC_FLOORDIVPOW2 ( JPC_CEILDIV ( pi -> x , pi -> picomp -> hsamp << r ) , pi -> pirlvl -> prcwidthexpn ) - JPC_FLOORDIVPOW2 ( trx0 , pi -> pirlvl -> prcwidthexpn ) ;\n prcvind = JPC_FLOORDIVPOW2 ( JPC_CEILDIV ( pi -> y , pi -> picomp -> vsamp << r ) , pi -> pirlvl -> prcheightexpn ) - JPC_FLOORDIVPOW2 ( try0 , pi -> pirlvl -> prcheightexpn ) ;\n pi -> prcno = prcvind * pi -> pirlvl -> numhprcs + prchind ;\n assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ;\n for ( pi -> lyrno = 0 ;\n pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ;\n ++ pi -> lyrno ) {\n prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ;\n if ( pi -> lyrno >= * prclyrno ) {\n ++ ( * prclyrno ) ;\n return 0 ;\n }\n skip : ;\n }\n }\n }\n }\n }\n }\n return 1 ;\n }", "idx": 20686}
{"hash": 355220887711506893, "project": "debian", "size": 21, "label": 0, "functionSource": "double mcv_selectivity ( VariableStatData * vardata , FmgrInfo * opproc , Datum constval , bool varonleft , double * sumcommonp ) {\n double mcv_selec , sumcommon ;\n Datum * values ;\n int nvalues ;\n float4 * numbers ;\n int nnumbers ;\n int i ;\n mcv_selec = 0.0 ;\n sumcommon = 0.0 ;\n if ( HeapTupleIsValid ( vardata -> statsTuple ) && statistic_proc_security_check ( vardata , opproc -> fn_oid ) && get_attstatsslot ( vardata -> statsTuple , vardata -> atttype , vardata -> atttypmod , STATISTIC_KIND_MCV , InvalidOid , NULL , & values , & nvalues , & numbers , & nnumbers ) ) {\n for ( i = 0 ;\n i < nvalues ;\n i ++ ) {\n if ( varonleft ? DatumGetBool ( FunctionCall2Coll ( opproc , DEFAULT_COLLATION_OID , values [ i ] , constval ) ) : DatumGetBool ( FunctionCall2Coll ( opproc , DEFAULT_COLLATION_OID , constval , values [ i ] ) ) ) mcv_selec += numbers [ i ] ;\n sumcommon += numbers [ i ] ;\n }\n free_attstatsslot ( vardata -> atttype , values , nvalues , numbers , nnumbers ) ;\n }\n * sumcommonp = sumcommon ;\n return mcv_selec ;\n }", "idx": 20687}
{"hash": 1182028467273264883, "project": "debian", "size": 26, "label": 0, "functionSource": "void do_diff_files ( struct st_command * command ) {\n int error = 0 ;\n static DYNAMIC_STRING ds_filename ;\n static DYNAMIC_STRING ds_filename2 ;\n const struct command_arg diff_file_args [ ] = {\n {\n \"file1\" , ARG_STRING , TRUE , & ds_filename , \"First file to diff\" }\n , {\n \"file2\" , ARG_STRING , TRUE , & ds_filename2 , \"Second file to diff\" }\n }\n ;\n DBUG_ENTER ( \"do_diff_files\" ) ;\n check_command_args ( command , command -> first_argument , diff_file_args , sizeof ( diff_file_args ) / sizeof ( struct command_arg ) , ' ' ) ;\n if ( access ( ds_filename . str , F_OK ) != 0 ) die ( \"command \\\"diff_files\\\" failed, file '%s' does not exist\" , ds_filename . str ) ;\n if ( access ( ds_filename2 . str , F_OK ) != 0 ) die ( \"command \\\"diff_files\\\" failed, file '%s' does not exist\" , ds_filename2 . str ) ;\n if ( ( error = compare_files ( ds_filename . str , ds_filename2 . str ) ) && match_expected_error ( command , error , NULL ) < 0 ) {\n show_diff ( & ds_res , ds_filename . str , ds_filename2 . str ) ;\n log_file . write ( & ds_res ) ;\n log_file . flush ( ) ;\n dynstr_set ( & ds_res , 0 ) ;\n }\n dynstr_free ( & ds_filename ) ;\n dynstr_free ( & ds_filename2 ) ;\n handle_command_error ( command , error , - 1 ) ;\n DBUG_VOID_RETURN ;\n }", "idx": 20688}
{"hash": 7039307292471244756, "project": "debian", "size": 10, "label": 0, "functionSource": "static void dtap_bcc_connect ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len ) {\n guint32 curr_offset ;\n guint32 consumed ;\n guint curr_len ;\n curr_offset = offset ;\n curr_len = len ;\n ELEM_MAND_V ( GSM_A_PDU_TYPE_DTAP , DE_BCC_CALL_REF , NULL ) ;\n proto_tree_add_bits_item ( tree , hf_gsm_a_spare_bits , tvb , curr_offset << 3 , 4 , ENC_NA ) ;\n ELEM_MAND_V ( GSM_A_PDU_TYPE_DTAP , DE_BCC_ORIG_IND , \"(Broadcast call reference)\" ) ;\n }", "idx": 20689}
{"hash": 5653549006541675258, "project": "debian", "size": 76, "label": 0, "functionSource": "int EVP_DecodeUpdate ( EVP_ENCODE_CTX * ctx , unsigned char * out , int * outl , const unsigned char * in , int inl ) {\n int seof = 0 , eof = 0 , rv = - 1 , ret = 0 , i , v , tmp , n , decoded_len ;\n unsigned char * d ;\n n = ctx -> num ;\n d = ctx -> enc_data ;\n if ( n > 0 && d [ n - 1 ] == '=' ) {\n eof ++ ;\n if ( n > 1 && d [ n - 2 ] == '=' ) eof ++ ;\n }\n if ( inl == 0 ) {\n rv = 0 ;\n goto end ;\n }\n for ( i = 0 ;\n i < inl ;\n i ++ ) {\n tmp = * ( in ++ ) ;\n v = conv_ascii2bin ( tmp ) ;\n if ( v == B64_ERROR ) {\n rv = - 1 ;\n goto end ;\n }\n if ( tmp == '=' ) {\n eof ++ ;\n }\n else if ( eof > 0 && B64_BASE64 ( v ) ) {\n rv = - 1 ;\n goto end ;\n }\n if ( eof > 2 ) {\n rv = - 1 ;\n goto end ;\n }\n if ( v == B64_EOF ) {\n seof = 1 ;\n goto tail ;\n }\n if ( B64_BASE64 ( v ) ) {\n if ( n >= 64 ) {\n rv = - 1 ;\n goto end ;\n }\n OPENSSL_assert ( n < ( int ) sizeof ( ctx -> enc_data ) ) ;\n d [ n ++ ] = tmp ;\n }\n if ( n == 64 ) {\n decoded_len = EVP_DecodeBlock ( out , d , n ) ;\n n = 0 ;\n if ( decoded_len < 0 || eof > decoded_len ) {\n rv = - 1 ;\n goto end ;\n }\n ret += decoded_len - eof ;\n out += decoded_len - eof ;\n }\n }\n tail : if ( n > 0 ) {\n if ( ( n & 3 ) == 0 ) {\n decoded_len = EVP_DecodeBlock ( out , d , n ) ;\n n = 0 ;\n if ( decoded_len < 0 || eof > decoded_len ) {\n rv = - 1 ;\n goto end ;\n }\n ret += ( decoded_len - eof ) ;\n }\n else if ( seof ) {\n rv = - 1 ;\n goto end ;\n }\n }\n rv = seof || ( n == 0 && eof ) ? 0 : 1 ;\n end : * outl = ret ;\n ctx -> num = n ;\n return ( rv ) ;\n }", "idx": 20690}
{"hash": 5347874611477979643, "project": "chrome", "size": 64, "label": 0, "functionSource": "static void rpc_test ( void ) {\n struct msg * msg , * msg2 ;\n struct kill * attack ;\n struct run * run ;\n struct evbuffer * tmp = evbuffer_new ( ) ;\n struct timeval tv_start , tv_end ;\n uint32_t tag ;\n int i ;\n fprintf ( stdout , \"Testing RPC: \" ) ;\n msg = msg_new ( ) ;\n EVTAG_ASSIGN ( msg , from_name , \"niels\" ) ;\n EVTAG_ASSIGN ( msg , to_name , \"phoenix\" ) ;\n if ( EVTAG_GET ( msg , attack , & attack ) == - 1 ) {\n fprintf ( stderr , \"Failed to set kill message.\\n\" ) ;\n exit ( 1 ) ;\n }\n EVTAG_ASSIGN ( attack , weapon , \"feather\" ) ;\n EVTAG_ASSIGN ( attack , action , \"tickle\" ) ;\n evutil_gettimeofday ( & tv_start , NULL ) ;\n for ( i = 0 ;\n i < 1000 ;\n ++ i ) {\n run = EVTAG_ADD ( msg , run ) ;\n if ( run == NULL ) {\n fprintf ( stderr , \"Failed to add run message.\\n\" ) ;\n exit ( 1 ) ;\n }\n EVTAG_ASSIGN ( run , how , \"very fast but with some data in it\" ) ;\n EVTAG_ASSIGN ( run , fixed_bytes , ( unsigned char * ) \"012345678901234567890123\" ) ;\n }\n if ( msg_complete ( msg ) == - 1 ) {\n fprintf ( stderr , \"Failed to make complete message.\\n\" ) ;\n exit ( 1 ) ;\n }\n evtag_marshal_msg ( tmp , 0xdeaf , msg ) ;\n if ( evtag_peek ( tmp , & tag ) == - 1 ) {\n fprintf ( stderr , \"Failed to peak tag.\\n\" ) ;\n exit ( 1 ) ;\n }\n if ( tag != 0xdeaf ) {\n fprintf ( stderr , \"Got incorrect tag: %0x.\\n\" , tag ) ;\n exit ( 1 ) ;\n }\n msg2 = msg_new ( ) ;\n if ( evtag_unmarshal_msg ( tmp , 0xdeaf , msg2 ) == - 1 ) {\n fprintf ( stderr , \"Failed to unmarshal message.\\n\" ) ;\n exit ( 1 ) ;\n }\n evutil_gettimeofday ( & tv_end , NULL ) ;\n evutil_timersub ( & tv_end , & tv_start , & tv_end ) ;\n fprintf ( stderr , \"(%.1f us/add) \" , ( float ) tv_end . tv_sec / ( float ) i * 1000000.0 + tv_end . tv_usec / ( float ) i ) ;\n if ( ! EVTAG_HAS ( msg2 , from_name ) || ! EVTAG_HAS ( msg2 , to_name ) || ! EVTAG_HAS ( msg2 , attack ) ) {\n fprintf ( stderr , \"Missing data structures.\\n\" ) ;\n exit ( 1 ) ;\n }\n if ( EVTAG_LEN ( msg2 , run ) != i ) {\n fprintf ( stderr , \"Wrong number of run messages.\\n\" ) ;\n exit ( 1 ) ;\n }\n msg_free ( msg ) ;\n msg_free ( msg2 ) ;\n evbuffer_free ( tmp ) ;\n fprintf ( stdout , \"OK\\n\" ) ;\n }", "idx": 20691}
{"hash": 4511225370772574632, "project": "debian", "size": 4, "label": 0, "functionSource": "PHP_FUNCTION ( uwsgi_version ) {\n # ifdef UWSGI_PHP7 RETURN_STRING ( UWSGI_VERSION ) ;\n # else RETURN_STRING ( UWSGI_VERSION , 1 ) ;\n # endif }", "idx": 20692}
{"hash": 3804373597256531021, "project": "debian", "size": 5, "label": 0, "functionSource": "void rebuild_check_host ( void ) {\n delete_dynamic ( & acl_wild_hosts ) ;\n hash_free ( & acl_check_hosts ) ;\n init_check_host ( ) ;\n }", "idx": 20693}
{"hash": -8884965407551053630, "project": "debian", "size": 8, "label": 0, "functionSource": "static bool DecoderIsFlushing ( decoder_t * p_dec ) {\n decoder_owner_sys_t * p_owner = p_dec -> p_owner ;\n bool b_flushing ;\n vlc_mutex_lock ( & p_owner -> lock ) ;\n b_flushing = p_owner -> b_flushing ;\n vlc_mutex_unlock ( & p_owner -> lock ) ;\n return b_flushing ;\n }", "idx": 20694}
{"hash": 1366214969540455677, "project": "debian", "size": 19, "label": 0, "functionSource": "int ossl_statem_server_construct_message ( SSL * s ) {\n OSSL_STATEM * st = & s -> statem ;\n switch ( st -> hand_state ) {\n case DTLS_ST_SW_HELLO_VERIFY_REQUEST : return dtls_construct_hello_verify_request ( s ) ;\n case TLS_ST_SW_HELLO_REQ : return tls_construct_hello_request ( s ) ;\n case TLS_ST_SW_SRVR_HELLO : return tls_construct_server_hello ( s ) ;\n case TLS_ST_SW_CERT : return tls_construct_server_certificate ( s ) ;\n case TLS_ST_SW_KEY_EXCH : return tls_construct_server_key_exchange ( s ) ;\n case TLS_ST_SW_CERT_REQ : return tls_construct_certificate_request ( s ) ;\n case TLS_ST_SW_SRVR_DONE : return tls_construct_server_done ( s ) ;\n case TLS_ST_SW_SESSION_TICKET : return tls_construct_new_session_ticket ( s ) ;\n case TLS_ST_SW_CERT_STATUS : return tls_construct_cert_status ( s ) ;\n case TLS_ST_SW_CHANGE : if ( SSL_IS_DTLS ( s ) ) return dtls_construct_change_cipher_spec ( s ) ;\n else return tls_construct_change_cipher_spec ( s ) ;\n case TLS_ST_SW_FINISHED : return tls_construct_finished ( s , s -> method -> ssl3_enc -> server_finished_label , s -> method -> ssl3_enc -> server_finished_label_len ) ;\n default : break ;\n }\n return 0 ;\n }", "idx": 20695}
{"hash": -5260094338219889901, "project": "debian", "size": 9, "label": 0, "functionSource": "static void stroke_counters ( private_stroke_socket_t * this , stroke_msg_t * msg , FILE * out ) {\n pop_string ( msg , & msg -> counters . name ) ;\n if ( msg -> counters . reset ) {\n this -> counter -> reset ( this -> counter , msg -> counters . name ) ;\n }\n else {\n this -> counter -> print ( this -> counter , out , msg -> counters . name ) ;\n }\n }", "idx": 20696}
{"hash": 2895622461494525400, "project": "debian", "size": 20, "label": 0, "functionSource": "static void test_bug6081 ( ) {\n int rc ;\n myheader ( \"test_bug6081\" ) ;\n rc = simple_command ( mysql , COM_DROP_DB , ( uchar * ) current_db , ( ulong ) strlen ( current_db ) , 0 ) ;\n if ( rc == 0 && mysql_errno ( mysql ) != ER_UNKNOWN_COM_ERROR ) {\n myerror ( NULL ) ;\n die ( __FILE__ , __LINE__ , \"COM_DROP_DB failed\" ) ;\n }\n rc = simple_command ( mysql , COM_DROP_DB , ( uchar * ) current_db , ( ulong ) strlen ( current_db ) , 0 ) ;\n myquery_r ( rc ) ;\n rc = simple_command ( mysql , COM_CREATE_DB , ( uchar * ) current_db , ( ulong ) strlen ( current_db ) , 0 ) ;\n if ( rc == 0 && mysql_errno ( mysql ) != ER_UNKNOWN_COM_ERROR ) {\n myerror ( NULL ) ;\n die ( __FILE__ , __LINE__ , \"COM_CREATE_DB failed\" ) ;\n }\n rc = simple_command ( mysql , COM_CREATE_DB , ( uchar * ) current_db , ( ulong ) strlen ( current_db ) , 0 ) ;\n myquery_r ( rc ) ;\n rc = mysql_select_db ( mysql , current_db ) ;\n myquery ( rc ) ;\n }", "idx": 20697}
{"hash": -6126432314261451839, "project": "debian", "size": 41, "label": 0, "functionSource": "int gs_copydevice2 ( gx_device * * pnew_dev , const gx_device * dev , bool keep_open , gs_memory_t * mem ) {\n gx_device * new_dev ;\n const gs_memory_struct_type_t * std = dev -> stype ;\n const gs_memory_struct_type_t * new_std ;\n gs_memory_struct_type_t * a_std = 0 ;\n int code ;\n if ( dev -> stype_is_dynamic ) {\n a_std = ( gs_memory_struct_type_t * ) gs_alloc_bytes_immovable ( mem -> non_gc_memory , sizeof ( * std ) , \"gs_copydevice(stype)\" ) ;\n if ( ! a_std ) return_error ( gs_error_VMerror ) ;\n * a_std = * std ;\n new_std = a_std ;\n }\n else if ( std != 0 && std -> ssize == dev -> params_size ) {\n new_std = std ;\n }\n else {\n a_std = ( gs_memory_struct_type_t * ) gs_alloc_bytes_immovable ( mem -> non_gc_memory , sizeof ( * std ) , \"gs_copydevice(stype)\" ) ;\n if ( ! a_std ) return_error ( gs_error_VMerror ) ;\n gx_device_make_struct_type ( a_std , dev ) ;\n new_std = a_std ;\n }\n new_dev = gs_alloc_struct_immovable ( mem , gx_device , new_std , \"gs_copydevice(device)\" ) ;\n if ( new_dev == 0 ) {\n gs_free_object ( mem -> non_gc_memory , a_std , \"gs_copydevice(stype)\" ) ;\n return_error ( gs_error_VMerror ) ;\n }\n gx_device_init ( new_dev , dev , mem , false ) ;\n gx_device_set_procs ( new_dev ) ;\n new_dev -> stype = new_std ;\n new_dev -> stype_is_dynamic = new_std != std ;\n new_dev -> is_open = dev -> is_open && keep_open ;\n fill_dev_proc ( new_dev , finish_copydevice , gx_default_finish_copydevice ) ;\n code = dev_proc ( new_dev , finish_copydevice ) ( new_dev , dev ) ;\n if ( code < 0 ) {\n gs_free_object ( mem , new_dev , \"gs_copydevice(device)\" ) ;\n # if 0 if ( a_std ) gs_free_object ( dev -> memory -> non_gc_memory , a_std , \"gs_copydevice(stype)\" ) ;\n # endif return code ;\n }\n * pnew_dev = new_dev ;\n return 0 ;\n }", "idx": 20698}
{"hash": -5927738579069082820, "project": "debian", "size": 32, "label": 0, "functionSource": "static void xps_parse_arc_segment ( fz_context * doc , fz_path * path , fz_xml * root , int stroking , int * skipped_stroke ) {\n float rotation_angle ;\n int is_large_arc , is_clockwise ;\n float point_x , point_y ;\n float size_x , size_y ;\n int is_stroked ;\n char * point_att = fz_xml_att ( root , \"Point\" ) ;\n char * size_att = fz_xml_att ( root , \"Size\" ) ;\n char * rotation_angle_att = fz_xml_att ( root , \"RotationAngle\" ) ;\n char * is_large_arc_att = fz_xml_att ( root , \"IsLargeArc\" ) ;\n char * sweep_direction_att = fz_xml_att ( root , \"SweepDirection\" ) ;\n char * is_stroked_att = fz_xml_att ( root , \"IsStroked\" ) ;\n if ( ! point_att || ! size_att || ! rotation_angle_att || ! is_large_arc_att || ! sweep_direction_att ) {\n fz_warn ( doc , \"ArcSegment element is missing attributes\" ) ;\n return ;\n }\n is_stroked = 1 ;\n if ( is_stroked_att && ! strcmp ( is_stroked_att , \"false\" ) ) is_stroked = 0 ;\n if ( ! is_stroked ) * skipped_stroke = 1 ;\n point_x = point_y = 0 ;\n size_x = size_y = 0 ;\n xps_parse_point ( point_att , & point_x , & point_y ) ;\n xps_parse_point ( size_att , & size_x , & size_y ) ;\n rotation_angle = fz_atof ( rotation_angle_att ) ;\n is_large_arc = ! strcmp ( is_large_arc_att , \"true\" ) ;\n is_clockwise = ! strcmp ( sweep_direction_att , \"Clockwise\" ) ;\n if ( stroking && ! is_stroked ) {\n fz_moveto ( doc , path , point_x , point_y ) ;\n return ;\n }\n xps_draw_arc ( doc , path , size_x , size_y , rotation_angle , is_large_arc , is_clockwise , point_x , point_y ) ;\n }", "idx": 20699}
{"hash": -273984976102410662, "project": "chrome", "size": 3, "label": 0, "functionSource": "static inline void uprv_arrayCopy ( const int8_t * src , int8_t * dst , int32_t count ) {\n uprv_memcpy ( dst , src , ( size_t ) count * sizeof ( * src ) ) ;\n }", "idx": 20700}
{"hash": -1658505547857059267, "project": "debian", "size": 21, "label": 0, "functionSource": "static int add_sorted ( Picture * * sorted , Picture * * src , int len , int limit , int dir ) {\n int i , best_poc ;\n int out_i = 0 ;\n for ( ;\n ;\n ) {\n best_poc = dir ? INT_MIN : INT_MAX ;\n for ( i = 0 ;\n i < len ;\n i ++ ) {\n const int poc = src [ i ] -> poc ;\n if ( ( ( poc > limit ) ^ dir ) && ( ( poc < best_poc ) ^ dir ) ) {\n best_poc = poc ;\n sorted [ out_i ] = src [ i ] ;\n }\n }\n if ( best_poc == ( dir ? INT_MIN : INT_MAX ) ) break ;\n limit = sorted [ out_i ++ ] -> poc - dir ;\n }\n return out_i ;\n }", "idx": 20701}
{"hash": 3887066622454352196, "project": "chrome", "size": 13, "label": 1, "functionSource": "int64_t vp9_block_error_c ( const int16_t * coeff , const int16_t * dqcoeff , intptr_t block_size , int64_t * ssz ) {\n int i ;\n int64_t error = 0 , sqcoeff = 0 ;\n for ( i = 0 ;\n i < block_size ;\n i ++ ) {\n const int diff = coeff [ i ] - dqcoeff [ i ] ;\n error += diff * diff ;\n sqcoeff += coeff [ i ] * coeff [ i ] ;\n }\n * ssz = sqcoeff ;\n return error ;\n }", "idx": 20702}
{"hash": -7614722514335375899, "project": "chrome", "size": 38, "label": 0, "functionSource": "TEST_F ( ProfileInfoCacheTest , GAIAPicture ) {\n const int kDefaultAvatarIndex = 0 ;\n const int kOtherAvatarIndex = 1 ;\n const int kGaiaPictureSize = 256 ;\n GetCache ( ) -> AddProfileToCache ( GetProfilePath ( \"path_1\" ) , ASCIIToUTF16 ( \"name_1\" ) , base : : string16 ( ) , kDefaultAvatarIndex , std : : string ( ) ) ;\n GetCache ( ) -> AddProfileToCache ( GetProfilePath ( \"path_2\" ) , ASCIIToUTF16 ( \"name_2\" ) , base : : string16 ( ) , kDefaultAvatarIndex , std : : string ( ) ) ;\n EXPECT_EQ ( NULL , GetCache ( ) -> GetGAIAPictureOfProfileAtIndex ( 0 ) ) ;\n EXPECT_EQ ( NULL , GetCache ( ) -> GetGAIAPictureOfProfileAtIndex ( 1 ) ) ;\n EXPECT_FALSE ( GetCache ( ) -> IsUsingGAIAPictureOfProfileAtIndex ( 0 ) ) ;\n EXPECT_FALSE ( GetCache ( ) -> IsUsingGAIAPictureOfProfileAtIndex ( 1 ) ) ;\n EXPECT_TRUE ( GetCache ( ) -> ProfileIsUsingDefaultAvatarAtIndex ( 0 ) ) ;\n EXPECT_TRUE ( GetCache ( ) -> ProfileIsUsingDefaultAvatarAtIndex ( 1 ) ) ;\n int default_avatar_id = profiles : : GetDefaultAvatarIconResourceIDAtIndex ( kDefaultAvatarIndex ) ;\n const gfx : : Image & default_avatar_image ( ResourceBundle : : GetSharedInstance ( ) . GetImageNamed ( default_avatar_id ) ) ;\n EXPECT_TRUE ( gfx : : test : : IsEqual ( default_avatar_image , GetCache ( ) -> GetAvatarIconOfProfileAtIndex ( 1 ) ) ) ;\n gfx : : Image gaia_image ( gfx : : test : : CreateImage ( kGaiaPictureSize , kGaiaPictureSize ) ) ;\n GetCache ( ) -> SetGAIAPictureOfProfileAtIndex ( 1 , & gaia_image ) ;\n EXPECT_EQ ( NULL , GetCache ( ) -> GetGAIAPictureOfProfileAtIndex ( 0 ) ) ;\n EXPECT_TRUE ( gfx : : test : : IsEqual ( gaia_image , * GetCache ( ) -> GetGAIAPictureOfProfileAtIndex ( 1 ) ) ) ;\n EXPECT_TRUE ( GetCache ( ) -> ProfileIsUsingDefaultAvatarAtIndex ( 1 ) ) ;\n EXPECT_TRUE ( GetCache ( ) -> IsUsingGAIAPictureOfProfileAtIndex ( 1 ) ) ;\n EXPECT_TRUE ( gfx : : test : : IsEqual ( gaia_image , GetCache ( ) -> GetAvatarIconOfProfileAtIndex ( 1 ) ) ) ;\n GetCache ( ) -> SetAvatarIconOfProfileAtIndex ( 1 , kOtherAvatarIndex ) ;\n GetCache ( ) -> SetProfileIsUsingDefaultAvatarAtIndex ( 1 , false ) ;\n EXPECT_FALSE ( GetCache ( ) -> ProfileIsUsingDefaultAvatarAtIndex ( 1 ) ) ;\n EXPECT_FALSE ( GetCache ( ) -> IsUsingGAIAPictureOfProfileAtIndex ( 1 ) ) ;\n int other_avatar_id = profiles : : GetDefaultAvatarIconResourceIDAtIndex ( kOtherAvatarIndex ) ;\n const gfx : : Image & other_avatar_image ( ResourceBundle : : GetSharedInstance ( ) . GetImageNamed ( other_avatar_id ) ) ;\n EXPECT_TRUE ( gfx : : test : : IsEqual ( other_avatar_image , GetCache ( ) -> GetAvatarIconOfProfileAtIndex ( 1 ) ) ) ;\n GetCache ( ) -> SetIsUsingGAIAPictureOfProfileAtIndex ( 1 , true ) ;\n EXPECT_TRUE ( GetCache ( ) -> IsUsingGAIAPictureOfProfileAtIndex ( 1 ) ) ;\n EXPECT_TRUE ( gfx : : test : : IsEqual ( gaia_image , * GetCache ( ) -> GetGAIAPictureOfProfileAtIndex ( 1 ) ) ) ;\n EXPECT_TRUE ( gfx : : test : : IsEqual ( gaia_image , GetCache ( ) -> GetAvatarIconOfProfileAtIndex ( 1 ) ) ) ;\n GetCache ( ) -> SetIsUsingGAIAPictureOfProfileAtIndex ( 1 , false ) ;\n EXPECT_FALSE ( GetCache ( ) -> IsUsingGAIAPictureOfProfileAtIndex ( 1 ) ) ;\n EXPECT_TRUE ( gfx : : test : : IsEqual ( gaia_image , * GetCache ( ) -> GetGAIAPictureOfProfileAtIndex ( 1 ) ) ) ;\n EXPECT_TRUE ( gfx : : test : : IsEqual ( other_avatar_image , GetCache ( ) -> GetAvatarIconOfProfileAtIndex ( 1 ) ) ) ;\n }", "idx": 20703}
{"hash": 5045872831385413038, "project": "debian", "size": 6, "label": 0, "functionSource": "static int dissect_btgatt_nordic_dfu_packet ( tvbuff_t * tvb , packet_info * pinfo _U_ , proto_tree * tree , void * data ) {\n btatt_data_t * att_data = ( btatt_data_t * ) data ;\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) return - 1 ;\n proto_tree_add_item ( tree , hf_gatt_nordic_dfu_packet , tvb , 0 , tvb_captured_length ( tvb ) , ENC_NA ) ;\n return tvb_captured_length ( tvb ) ;\n }", "idx": 20704}
{"hash": 3919646340804521652, "project": "debian", "size": 26, "label": 0, "functionSource": "static unsigned long write_object ( struct sha1file * f , struct object_entry * entry , off_t write_offset ) {\n unsigned long limit , len ;\n int usable_delta , to_reuse ;\n if ( ! pack_to_stdout ) crc32_begin ( f ) ;\n if ( ! pack_size_limit || ! nr_written ) limit = 0 ;\n else if ( pack_size_limit <= write_offset ) limit = 1 ;\n else limit = pack_size_limit - write_offset ;\n if ( ! entry -> delta ) usable_delta = 0 ;\n else if ( ! pack_size_limit ) usable_delta = 1 ;\n else if ( entry -> delta -> idx . offset == ( off_t ) - 1 ) usable_delta = 0 ;\n else if ( entry -> delta -> idx . offset ) usable_delta = 1 ;\n else usable_delta = 0 ;\n if ( ! reuse_object ) to_reuse = 0 ;\n else if ( ! entry -> in_pack ) to_reuse = 0 ;\n else if ( entry -> type == OBJ_REF_DELTA || entry -> type == OBJ_OFS_DELTA ) to_reuse = usable_delta ;\n else if ( entry -> type != entry -> in_pack_type ) to_reuse = 0 ;\n else if ( entry -> delta ) to_reuse = 0 ;\n else to_reuse = 1 ;\n if ( ! to_reuse ) len = write_no_reuse_object ( f , entry , limit , usable_delta ) ;\n else len = write_reuse_object ( f , entry , limit , usable_delta ) ;\n if ( ! len ) return 0 ;\n if ( usable_delta ) written_delta ++ ;\n written ++ ;\n if ( ! pack_to_stdout ) entry -> idx . crc32 = crc32_end ( f ) ;\n return len ;\n }", "idx": 20705}
{"hash": 6755873269946787742, "project": "debian", "size": 42, "label": 0, "functionSource": "static void pk_transaction_update_packages ( PkTransaction * transaction , GVariant * params , GDBusMethodInvocation * context ) {\n gboolean ret ;\n guint length ;\n PkBitfield transaction_flags ;\n g_autoptr ( GError ) error = NULL ;\n g_autofree gchar * * package_ids = NULL ;\n g_autofree gchar * package_ids_temp = NULL ;\n g_autofree gchar * transaction_flags_temp = NULL ;\n g_return_if_fail ( PK_IS_TRANSACTION ( transaction ) ) ;\n g_return_if_fail ( transaction -> priv -> tid != NULL ) ;\n g_variant_get ( params , \"(t^a&s)\" , & transaction_flags , & package_ids ) ;\n package_ids_temp = pk_package_ids_to_string ( package_ids ) ;\n transaction_flags_temp = pk_transaction_flag_bitfield_to_string ( transaction_flags ) ;\n g_debug ( \"UpdatePackages method called: %s (transaction_flags: %s)\" , package_ids_temp , transaction_flags_temp ) ;\n if ( ! pk_backend_is_implemented ( transaction -> priv -> backend , PK_ROLE_ENUM_UPDATE_PACKAGES ) ) {\n g_set_error ( & error , PK_TRANSACTION_ERROR , PK_TRANSACTION_ERROR_NOT_SUPPORTED , \"UpdatePackages not supported by backend\" ) ;\n pk_transaction_set_state ( transaction , PK_TRANSACTION_STATE_ERROR ) ;\n goto out ;\n }\n length = g_strv_length ( package_ids ) ;\n if ( length > PK_TRANSACTION_MAX_PACKAGES_TO_PROCESS ) {\n g_set_error ( & error , PK_TRANSACTION_ERROR , PK_TRANSACTION_ERROR_NUMBER_OF_PACKAGES_INVALID , \"Too many packages to process (%i/%i)\" , length , PK_TRANSACTION_MAX_PACKAGES_TO_PROCESS ) ;\n pk_transaction_set_state ( transaction , PK_TRANSACTION_STATE_ERROR ) ;\n goto out ;\n }\n ret = pk_package_ids_check ( package_ids ) ;\n if ( ! ret ) {\n g_set_error ( & error , PK_TRANSACTION_ERROR , PK_TRANSACTION_ERROR_PACKAGE_ID_INVALID , \"The package id's '%s' are not valid\" , package_ids_temp ) ;\n pk_transaction_set_state ( transaction , PK_TRANSACTION_STATE_ERROR ) ;\n goto out ;\n }\n transaction -> priv -> cached_transaction_flags = transaction_flags ;\n transaction -> priv -> cached_package_ids = g_strdupv ( package_ids ) ;\n pk_transaction_set_role ( transaction , PK_ROLE_ENUM_UPDATE_PACKAGES ) ;\n pk_transaction_emit_property_changed ( transaction , \"TransactionFlags\" , g_variant_new_uint64 ( transaction_flags ) ) ;\n ret = pk_transaction_obtain_authorization ( transaction , PK_ROLE_ENUM_UPDATE_PACKAGES , & error ) ;\n if ( ! ret ) {\n pk_transaction_set_state ( transaction , PK_TRANSACTION_STATE_ERROR ) ;\n goto out ;\n }\n out : pk_transaction_dbus_return ( context , error ) ;\n }", "idx": 20706}
{"hash": -5300415683778646743, "project": "chrome", "size": 3, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( ExtensionMessageBubbleViewBrowserTest , TestUninstallDangerousExtension ) {\n TestUninstallDangerousExtension ( ) ;\n }", "idx": 20707}
{"hash": -954364585377557207, "project": "debian", "size": 69, "label": 1, "functionSource": "static int amrnb_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n AMRContext * p = avctx -> priv_data ;\n AVFrame * frame = data ;\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n float * buf_out ;\n int i , subframe , ret ;\n float fixed_gain_factor ;\n AMRFixed fixed_sparse = {\n 0 }\n ;\n float spare_vector [ AMR_SUBFRAME_SIZE ] ;\n float synth_fixed_gain ;\n const float * synth_fixed_vector ;\n frame -> nb_samples = AMR_BLOCK_SIZE ;\n if ( ( ret = ff_get_buffer ( avctx , frame ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n buf_out = ( float * ) frame -> data [ 0 ] ;\n p -> cur_frame_mode = unpack_bitstream ( p , buf , buf_size ) ;\n if ( p -> cur_frame_mode == NO_DATA ) {\n av_log ( avctx , AV_LOG_ERROR , \"Corrupt bitstream\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( p -> cur_frame_mode == MODE_DTX ) {\n av_log_missing_feature ( avctx , \"dtx mode\" , 1 ) ;\n return AVERROR_PATCHWELCOME ;\n }\n if ( p -> cur_frame_mode == MODE_12k2 ) {\n lsf2lsp_5 ( p ) ;\n }\n else lsf2lsp_3 ( p ) ;\n for ( i = 0 ;\n i < 4 ;\n i ++ ) ff_acelp_lspd2lpc ( p -> lsp [ i ] , p -> lpc [ i ] , 5 ) ;\n for ( subframe = 0 ;\n subframe < 4 ;\n subframe ++ ) {\n const AMRNBSubframe * amr_subframe = & p -> frame . subframe [ subframe ] ;\n decode_pitch_vector ( p , amr_subframe , subframe ) ;\n decode_fixed_sparse ( & fixed_sparse , amr_subframe -> pulses , p -> cur_frame_mode , subframe ) ;\n decode_gains ( p , amr_subframe , p -> cur_frame_mode , subframe , & fixed_gain_factor ) ;\n pitch_sharpening ( p , subframe , p -> cur_frame_mode , & fixed_sparse ) ;\n if ( fixed_sparse . pitch_lag == 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"The file is corrupted, pitch_lag = 0 is not allowed\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n ff_set_fixed_vector ( p -> fixed_vector , & fixed_sparse , 1.0 , AMR_SUBFRAME_SIZE ) ;\n p -> fixed_gain [ 4 ] = ff_amr_set_fixed_gain ( fixed_gain_factor , avpriv_scalarproduct_float_c ( p -> fixed_vector , p -> fixed_vector , AMR_SUBFRAME_SIZE ) / AMR_SUBFRAME_SIZE , p -> prediction_error , energy_mean [ p -> cur_frame_mode ] , energy_pred_fac ) ;\n for ( i = 0 ;\n i < AMR_SUBFRAME_SIZE ;\n i ++ ) p -> excitation [ i ] *= p -> pitch_gain [ 4 ] ;\n ff_set_fixed_vector ( p -> excitation , & fixed_sparse , p -> fixed_gain [ 4 ] , AMR_SUBFRAME_SIZE ) ;\n for ( i = 0 ;\n i < AMR_SUBFRAME_SIZE ;\n i ++ ) p -> excitation [ i ] = truncf ( p -> excitation [ i ] ) ;\n synth_fixed_gain = fixed_gain_smooth ( p , p -> lsf_q [ subframe ] , p -> lsf_avg , p -> cur_frame_mode ) ;\n synth_fixed_vector = anti_sparseness ( p , & fixed_sparse , p -> fixed_vector , synth_fixed_gain , spare_vector ) ;\n if ( synthesis ( p , p -> lpc [ subframe ] , synth_fixed_gain , synth_fixed_vector , & p -> samples_in [ LP_FILTER_ORDER ] , 0 ) ) synthesis ( p , p -> lpc [ subframe ] , synth_fixed_gain , synth_fixed_vector , & p -> samples_in [ LP_FILTER_ORDER ] , 1 ) ;\n postfilter ( p , p -> lpc [ subframe ] , buf_out + subframe * AMR_SUBFRAME_SIZE ) ;\n ff_clear_fixed_vector ( p -> fixed_vector , & fixed_sparse , AMR_SUBFRAME_SIZE ) ;\n update_state ( p ) ;\n }\n ff_acelp_apply_order_2_transfer_function ( buf_out , buf_out , highpass_zeros , highpass_poles , highpass_gain * AMR_SAMPLE_SCALE , p -> high_pass_mem , AMR_BLOCK_SIZE ) ;\n ff_weighted_vector_sumf ( p -> lsf_avg , p -> lsf_avg , p -> lsf_q [ 3 ] , 0.84 , 0.16 , LP_FILTER_ORDER ) ;\n * got_frame_ptr = 1 ;\n return frame_sizes_nb [ p -> cur_frame_mode ] + 1 ;\n }", "idx": 20708}
{"hash": 8193534372312945122, "project": "debian", "size": 29, "label": 0, "functionSource": "static inline void pcnet_tmd_load ( PCNetState * s , struct pcnet_TMD * tmd , hwaddr addr ) {\n if ( ! BCR_SSIZE32 ( s ) ) {\n struct {\n uint32_t tbadr ;\n int16_t length ;\n int16_t status ;\n }\n xda ;\n s -> phys_mem_read ( s -> dma_opaque , addr , ( void * ) & xda , sizeof ( xda ) , 0 ) ;\n tmd -> tbadr = le32_to_cpu ( xda . tbadr ) & 0xffffff ;\n tmd -> length = le16_to_cpu ( xda . length ) ;\n tmd -> status = ( le32_to_cpu ( xda . tbadr ) >> 16 ) & 0xff00 ;\n tmd -> misc = le16_to_cpu ( xda . status ) << 16 ;\n tmd -> res = 0 ;\n }\n else {\n s -> phys_mem_read ( s -> dma_opaque , addr , ( void * ) tmd , sizeof ( * tmd ) , 0 ) ;\n le32_to_cpus ( & tmd -> tbadr ) ;\n le16_to_cpus ( ( uint16_t * ) & tmd -> length ) ;\n le16_to_cpus ( ( uint16_t * ) & tmd -> status ) ;\n le32_to_cpus ( & tmd -> misc ) ;\n le32_to_cpus ( & tmd -> res ) ;\n if ( BCR_SWSTYLE ( s ) == 3 ) {\n uint32_t tmp = tmd -> tbadr ;\n tmd -> tbadr = tmd -> misc ;\n tmd -> misc = tmp ;\n }\n }\n }", "idx": 20709}
{"hash": 8637588907624249958, "project": "debian", "size": 21, "label": 0, "functionSource": "static int dissect_pcp_message_pmns_ids ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , int offset ) {\n proto_item * pcp_pmns_ids_item ;\n proto_tree * pcp_pmns_ids_tree ;\n guint32 num_ids ;\n guint32 i ;\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \"[%s]\" , val_to_str ( PCP_PDU_PMNS_IDS , packettypenames , \"Unknown Type:0x%02x\" ) ) ;\n pcp_pmns_ids_item = proto_tree_add_item ( tree , hf_pcp_pmns_ids , tvb , offset , - 1 , ENC_NA ) ;\n pcp_pmns_ids_tree = proto_item_add_subtree ( pcp_pmns_ids_item , ett_pcp ) ;\n proto_tree_add_item ( pcp_pmns_ids_tree , hf_pcp_pmns_ids_status , tvb , offset , 4 , ENC_BIG_ENDIAN ) ;\n offset += 4 ;\n proto_tree_add_item ( pcp_pmns_ids_tree , hf_pcp_pmns_ids_numids , tvb , offset , 4 , ENC_BIG_ENDIAN ) ;\n num_ids = tvb_get_ntohl ( tvb , offset ) ;\n offset += 4 ;\n populate_pmids_to_names ( pinfo , tvb , offset , num_ids ) ;\n for ( i = 0 ;\n i < num_ids ;\n i ++ ) {\n offset = dissect_pcp_partial_pmid ( tvb , pinfo , pcp_pmns_ids_tree , offset ) ;\n }\n return offset ;\n }", "idx": 20710}
{"hash": 5347874611477979643, "project": "chrome", "size": 3, "label": 0, "functionSource": "static void fail_cb ( int fd , short events , void * arg ) {\n test_ok = 0 ;\n }", "idx": 20711}
{"hash": 7039307292471244756, "project": "debian", "size": 23, "label": 0, "functionSource": "static guint16 de_cc_cap ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len , gchar * add_string _U_ , int string_len _U_ ) {\n guint8 oct ;\n guint32 curr_offset ;\n curr_offset = offset ;\n oct = tvb_get_guint8 ( tvb , curr_offset ) ;\n if ( ( ( oct & 0xf0 ) >> 4 ) == 0 ) {\n proto_tree_add_uint_format_value ( tree , hf_gsm_a_dtap_maximum_number_of_supported_bearers , tvb , curr_offset , 1 , 0 , \"1\" ) ;\n }\n else {\n proto_tree_add_item ( tree , hf_gsm_a_dtap_maximum_number_of_supported_bearers , tvb , curr_offset , 1 , ENC_BIG_ENDIAN ) ;\n }\n proto_tree_add_item ( tree , hf_gsm_a_dtap_mcat , tvb , curr_offset , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( tree , hf_gsm_a_dtap_enicm , tvb , curr_offset , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( tree , hf_gsm_a_dtap_pcp , tvb , curr_offset , 1 , ENC_NA ) ;\n proto_tree_add_item ( tree , hf_gsm_a_dtap_dtmf , tvb , curr_offset , 1 , ENC_NA ) ;\n curr_offset ++ ;\n NO_MORE_DATA_CHECK ( len ) ;\n proto_tree_add_bits_item ( tree , hf_gsm_a_spare_bits , tvb , curr_offset << 3 , 4 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( tree , hf_gsm_a_dtap_max_num_of_speech_bearers , tvb , curr_offset , 1 , ENC_BIG_ENDIAN ) ;\n curr_offset ++ ;\n EXTRANEOUS_DATA_CHECK ( len , curr_offset - offset , pinfo , & ei_gsm_a_dtap_extraneous_data ) ;\n return ( curr_offset - offset ) ;\n }", "idx": 20712}
{"hash": 355220887711506893, "project": "debian", "size": 36, "label": 1, "functionSource": "static void examine_simple_variable ( PlannerInfo * root , Var * var , VariableStatData * vardata ) {\n RangeTblEntry * rte = root -> simple_rte_array [ var -> varno ] ;\n Assert ( IsA ( rte , RangeTblEntry ) ) ;\n if ( get_relation_stats_hook && ( * get_relation_stats_hook ) ( root , rte , var -> varattno , vardata ) ) {\n if ( HeapTupleIsValid ( vardata -> statsTuple ) && ! vardata -> freefunc ) elog ( ERROR , \"no function provided to release variable stats with\" ) ;\n }\n else if ( rte -> rtekind == RTE_RELATION ) {\n vardata -> statsTuple = SearchSysCache3 ( STATRELATTINH , ObjectIdGetDatum ( rte -> relid ) , Int16GetDatum ( var -> varattno ) , BoolGetDatum ( rte -> inh ) ) ;\n vardata -> freefunc = ReleaseSysCache ;\n }\n else if ( rte -> rtekind == RTE_SUBQUERY && ! rte -> inh ) {\n Query * subquery = rte -> subquery ;\n RelOptInfo * rel ;\n TargetEntry * ste ;\n if ( var -> varattno == InvalidAttrNumber ) return ;\n if ( subquery -> setOperations || subquery -> groupClause ) return ;\n rel = find_base_rel ( root , var -> varno ) ;\n if ( rel -> subroot == NULL ) return ;\n Assert ( IsA ( rel -> subroot , PlannerInfo ) ) ;\n subquery = rel -> subroot -> parse ;\n Assert ( IsA ( subquery , Query ) ) ;\n ste = get_tle_by_resno ( subquery -> targetList , var -> varattno ) ;\n if ( ste == NULL || ste -> resjunk ) elog ( ERROR , \"subquery %s does not have attribute %d\" , rte -> eref -> aliasname , var -> varattno ) ;\n var = ( Var * ) ste -> expr ;\n if ( subquery -> distinctClause ) {\n if ( list_length ( subquery -> distinctClause ) == 1 && targetIsInSortList ( ste , InvalidOid , subquery -> distinctClause ) ) vardata -> isunique = true ;\n return ;\n }\n if ( rte -> security_barrier ) return ;\n if ( var && IsA ( var , Var ) && var -> varlevelsup == 0 ) {\n examine_simple_variable ( rel -> subroot , var , vardata ) ;\n }\n }\n else {\n }\n }", "idx": 20713}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_T_videoBadMBs ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_T_videoBadMBs , T_videoBadMBs_sequence ) ;\n return offset ;\n }", "idx": 20714}
{"hash": 2578089348587614328, "project": "debian", "size": 3, "label": 0, "functionSource": "DSA * d2i_DSA_PUBKEY_fp ( FILE * fp , DSA * * dsa ) {\n return ASN1_d2i_fp_of ( DSA , DSA_new , d2i_DSA_PUBKEY , fp , dsa ) ;\n }", "idx": 20715}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_T_frameSequence ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_constrained_sequence_of ( tvb , offset , actx , tree , hf_index , ett_h245_T_frameSequence , T_frameSequence_sequence_of , 1 , 256 , FALSE ) ;\n return offset ;\n }", "idx": 20716}
{"hash": 2895622461494525400, "project": "debian", "size": 30, "label": 0, "functionSource": "static void test_wl4435_2 ( ) {\n MYSQL_STMT * stmt ;\n int i ;\n int rc ;\n char query [ MAX_TEST_QUERY_LENGTH ] ;\n myheader ( \"test_wl4435_2\" ) ;\n mct_start_logging ( \"test_wl4435_2\" ) ;\n for ( i = 0 ;\n i < 10 ;\n ++ i ) {\n rc = mysql_query ( mysql , \"DROP PROCEDURE IF EXISTS p1\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"CREATE PROCEDURE p1()\" \"BEGIN \" \" SELECT 1;\n \" \" SELECT 2, 3 UNION SELECT 4, 5;\n \" \" SELECT 6, 7, 8;\n \" \"END\" ) ;\n myquery ( rc ) ;\n strmov ( query , \"CALL p1()\" ) ;\n stmt = mysql_simple_prepare ( mysql , query ) ;\n check_stmt ( stmt ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n mysql_stmt_close ( stmt ) ;\n rc = mysql_commit ( mysql ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"DROP PROCEDURE p1\" ) ;\n myquery ( rc ) ;\n }\n mct_close_log ( ) ;\n }", "idx": 20717}
{"hash": -2504372172279754762, "project": "debian", "size": 9, "label": 0, "functionSource": "static void prepare_avpic ( MimicContext * ctx , AVPicture * dst , AVFrame * src ) {\n int i ;\n dst -> data [ 0 ] = src -> data [ 0 ] + ( ctx -> avctx -> height - 1 ) * src -> linesize [ 0 ] ;\n dst -> data [ 1 ] = src -> data [ 2 ] + ( ( ctx -> avctx -> height >> 1 ) - 1 ) * src -> linesize [ 2 ] ;\n dst -> data [ 2 ] = src -> data [ 1 ] + ( ( ctx -> avctx -> height >> 1 ) - 1 ) * src -> linesize [ 1 ] ;\n for ( i = 0 ;\n i < 3 ;\n i ++ ) dst -> linesize [ i ] = - src -> linesize [ i ] ;\n }", "idx": 20718}
{"hash": -7559567117301601597, "project": "debian", "size": 32, "label": 0, "functionSource": "int main ( int argc , char * argv [ ] ) {\n int ret_value = 0 ;\n libettercap_init ( ) ;\n ef_globals_alloc ( ) ;\n select_text_interface ( ) ;\n libettercap_ui_init ( ) ;\n fprintf ( stdout , \"\\n\" EC_COLOR_BOLD \"%s %s\" EC_COLOR_END \" copyright %s %s\\n\\n\" , PROGRAM , EC_VERSION , EC_COPYRIGHT , EC_AUTHORS ) ;\n EF_GBL -> lineno = 1 ;\n parse_options ( argc , argv ) ;\n if ( EF_GBL_OPTIONS -> source_file ) {\n yyin = fopen ( EF_GBL_OPTIONS -> source_file , \"r\" ) ;\n if ( yyin == NULL ) FATAL_ERROR ( \"Input file not found !\" ) ;\n }\n else {\n FATAL_ERROR ( \"No source file.\" ) ;\n }\n setbuf ( yyin , NULL ) ;\n setbuf ( stdout , NULL ) ;\n setbuf ( stderr , NULL ) ;\n load_tables ( ) ;\n load_constants ( ) ;\n fprintf ( stdout , \"\\n Parsing source file \\'%s\\' \" , EF_GBL_OPTIONS -> source_file ) ;\n fflush ( stdout ) ;\n ef_debug ( 1 , \"\\n\" ) ;\n if ( yyparse ( ) == 0 ) fprintf ( stdout , \" done.\\n\\n\" ) ;\n else fprintf ( stdout , \"\\n\\nThe script contains errors...\\n\\n\" ) ;\n ret_value = write_output ( ) ;\n if ( ret_value == - E_NOTHANDLED ) FATAL_ERROR ( \"Cannot write output file (%s): the filter is not correctly handled.\" , EF_GBL_OPTIONS -> output_file ) ;\n else if ( ret_value == - E_INVALID ) FATAL_ERROR ( \"Cannot write output file (%s): the filter format is not correct. \" , EF_GBL_OPTIONS -> output_file ) ;\n ef_globals_free ( ) ;\n return 0 ;\n }", "idx": 20719}
{"hash": 2917602761308156638, "project": "debian", "size": 17, "label": 0, "functionSource": "static Asn1Generic * DecodeAsn1DerBoolean ( const unsigned char * buffer , uint32_t size , uint8_t depth , uint32_t * errcode ) {\n const unsigned char * d_ptr = buffer ;\n uint8_t numbytes ;\n uint32_t value ;\n Asn1Generic * a ;\n numbytes = d_ptr [ 1 ] ;\n d_ptr += 2 ;\n if ( DecodeAsn1BuildValue ( & d_ptr , & value , numbytes , errcode ) == - 1 ) {\n return NULL ;\n }\n a = Asn1GenericNew ( ) ;\n if ( a == NULL ) return NULL ;\n a -> type = ASN1_BOOLEAN ;\n a -> length = ( d_ptr - buffer ) ;\n a -> value = value ;\n return a ;\n }", "idx": 20720}
{"hash": 1245821301839614810, "project": "debian", "size": 14, "label": 0, "functionSource": "static void report_extract_final_progress ( ExtractJob * extract_job , gint total_files ) {\n char * status ;\n nautilus_progress_info_set_destination ( extract_job -> common . progress , extract_job -> destination_directory ) ;\n if ( total_files == 1 ) {\n GFile * source_file ;\n source_file = G_FILE ( extract_job -> source_files -> data ) ;\n status = f ( _ ( \"Extracted \u201c%B\u201d to \u201c%B\u201d\" ) , source_file , extract_job -> destination_directory ) ;\n }\n else {\n status = f ( ngettext ( \"Extracted %'d file to \u201c%B\u201d\" , \"Extracted %'d files to \u201c%B\u201d\" , total_files ) , total_files , extract_job -> destination_directory ) ;\n }\n nautilus_progress_info_take_status ( extract_job -> common . progress , status ) ;\n nautilus_progress_info_take_details ( extract_job -> common . progress , f ( _ ( \"%S / %S\" ) , extract_job -> total_compressed_size , extract_job -> total_compressed_size ) ) ;\n }", "idx": 20721}
{"hash": 1667027354487746122, "project": "chrome", "size": 3, "label": 0, "functionSource": "const char * hb_shape_plan_get_shaper ( hb_shape_plan_t * shape_plan ) {\n return shape_plan -> shaper_name ;\n }", "idx": 20722}
{"hash": -5550748970150309774, "project": "debian", "size": 22, "label": 0, "functionSource": "static void _check_database_version ( ArchiveHandle * AH ) {\n const char * remoteversion_str ;\n int remoteversion ;\n PGresult * res ;\n remoteversion_str = PQparameterStatus ( AH -> connection , \"server_version\" ) ;\n remoteversion = PQserverVersion ( AH -> connection ) ;\n if ( remoteversion == 0 || ! remoteversion_str ) exit_horribly ( modulename , \"could not get server_version from libpq\\n\" ) ;\n AH -> public . remoteVersionStr = pg_strdup ( remoteversion_str ) ;\n AH -> public . remoteVersion = remoteversion ;\n if ( ! AH -> archiveRemoteVersion ) AH -> archiveRemoteVersion = AH -> public . remoteVersionStr ;\n if ( remoteversion != PG_VERSION_NUM && ( remoteversion < AH -> public . minRemoteVersion || remoteversion > AH -> public . maxRemoteVersion ) ) {\n write_msg ( NULL , \"server version: %s;\n %s version: %s\\n\" , remoteversion_str , progname , PG_VERSION ) ;\n exit_horribly ( NULL , \"aborting because of server version mismatch\\n\" ) ;\n }\n if ( remoteversion >= 90000 ) {\n res = ExecuteSqlQueryForSingleRow ( ( Archive * ) AH , \"SELECT pg_catalog.pg_is_in_recovery()\" ) ;\n AH -> public . isStandby = ( strcmp ( PQgetvalue ( res , 0 , 0 ) , \"t\" ) == 0 ) ;\n PQclear ( res ) ;\n }\n else AH -> public . isStandby = false ;\n }", "idx": 20723}
{"hash": 5597027026426443709, "project": "debian", "size": 3, "label": 0, "functionSource": "static uint64_t rtc_read ( void * opaque , hwaddr addr , unsigned size ) {\n return cpu_inw ( 0x71 ) ;\n }", "idx": 20724}
{"hash": -6872005221209485070, "project": "chrome", "size": 38, "label": 0, "functionSource": "static void decSetSubnormal ( decNumber * dn , decContext * set , Int * residue , uInt * status ) {\n decContext workset ;\n Int etiny , adjust ;\n # if DECSUBSET if ( ! set -> extended ) {\n uprv_decNumberZero ( dn ) ;\n * status |= DEC_Underflow | DEC_Subnormal | DEC_Inexact | DEC_Rounded ;\n return ;\n }\n # endif etiny = set -> emin - ( set -> digits - 1 ) ;\n if ISZERO ( dn ) {\n # if DECCHECK if ( * residue != 0 ) {\n printf ( \"++ Subnormal 0 residue %ld\\n\" , ( LI ) * residue ) ;\n * status |= DEC_Invalid_operation ;\n }\n # endif if ( dn -> exponent < etiny ) {\n dn -> exponent = etiny ;\n * status |= DEC_Clamped ;\n }\n return ;\n }\n * status |= DEC_Subnormal ;\n adjust = etiny - dn -> exponent ;\n if ( adjust <= 0 ) {\n if ( * status & DEC_Inexact ) * status |= DEC_Underflow ;\n return ;\n }\n workset = * set ;\n workset . digits = dn -> digits - adjust ;\n workset . emin -= adjust ;\n decSetCoeff ( dn , & workset , dn -> lsu , dn -> digits , residue , status ) ;\n decApplyRound ( dn , & workset , * residue , status ) ;\n if ( * status & DEC_Inexact ) * status |= DEC_Underflow ;\n if ( dn -> exponent > etiny ) {\n dn -> digits = decShiftToMost ( dn -> lsu , dn -> digits , 1 ) ;\n dn -> exponent -- ;\n }\n if ( ISZERO ( dn ) ) * status |= DEC_Clamped ;\n }", "idx": 20725}
{"hash": -6872005221209485070, "project": "chrome", "size": 40, "label": 0, "functionSource": "static Int decShiftToLeast ( Unit * uar , Int units , Int shift ) {\n Unit * target , * up ;\n Int cut , count ;\n Int quot , rem ;\n if ( shift == 0 ) return units ;\n if ( shift == units * DECDPUN ) {\n * uar = 0 ;\n return 1 ;\n }\n target = uar ;\n cut = MSUDIGITS ( shift ) ;\n if ( cut == DECDPUN ) {\n up = uar + D2U ( shift ) ;\n for ( ;\n up < uar + units ;\n target ++ , up ++ ) * target = * up ;\n return target - uar ;\n }\n up = uar + D2U ( shift - cut ) ;\n count = units * DECDPUN - shift ;\n # if DECDPUN <= 4 quot = QUOT10 ( * up , cut ) ;\n # else quot = * up / powers [ cut ] ;\n # endif for ( ;\n ;\n target ++ ) {\n * target = ( Unit ) quot ;\n count -= ( DECDPUN - cut ) ;\n if ( count <= 0 ) break ;\n up ++ ;\n quot = * up ;\n # if DECDPUN <= 4 quot = QUOT10 ( quot , cut ) ;\n rem = * up - quot * powers [ cut ] ;\n # else rem = quot % powers [ cut ] ;\n quot = quot / powers [ cut ] ;\n # endif * target = ( Unit ) ( * target + rem * powers [ DECDPUN - cut ] ) ;\n count -= cut ;\n if ( count <= 0 ) break ;\n }\n return target - uar + 1 ;\n }", "idx": 20726}
{"hash": 8801969307247112896, "project": "debian", "size": 33, "label": 0, "functionSource": "static int aes_ocb_ctrl ( EVP_CIPHER_CTX * c , int type , int arg , void * ptr ) {\n EVP_AES_OCB_CTX * octx = EVP_C_DATA ( EVP_AES_OCB_CTX , c ) ;\n EVP_CIPHER_CTX * newc ;\n EVP_AES_OCB_CTX * new_octx ;\n switch ( type ) {\n case EVP_CTRL_INIT : octx -> key_set = 0 ;\n octx -> iv_set = 0 ;\n octx -> ivlen = EVP_CIPHER_CTX_iv_length ( c ) ;\n octx -> iv = EVP_CIPHER_CTX_iv_noconst ( c ) ;\n octx -> taglen = 16 ;\n octx -> data_buf_len = 0 ;\n octx -> aad_buf_len = 0 ;\n return 1 ;\n case EVP_CTRL_AEAD_SET_IVLEN : if ( arg <= 0 || arg > 15 ) return 0 ;\n octx -> ivlen = arg ;\n return 1 ;\n case EVP_CTRL_AEAD_SET_TAG : if ( ! ptr ) {\n if ( arg < 0 || arg > 16 ) return 0 ;\n octx -> taglen = arg ;\n return 1 ;\n }\n if ( arg != octx -> taglen || EVP_CIPHER_CTX_encrypting ( c ) ) return 0 ;\n memcpy ( octx -> tag , ptr , arg ) ;\n return 1 ;\n case EVP_CTRL_AEAD_GET_TAG : if ( arg != octx -> taglen || ! EVP_CIPHER_CTX_encrypting ( c ) ) return 0 ;\n memcpy ( ptr , octx -> tag , arg ) ;\n return 1 ;\n case EVP_CTRL_COPY : newc = ( EVP_CIPHER_CTX * ) ptr ;\n new_octx = EVP_C_DATA ( EVP_AES_OCB_CTX , newc ) ;\n return CRYPTO_ocb128_copy_ctx ( & new_octx -> ocb , & octx -> ocb , & new_octx -> ksenc . ks , & new_octx -> ksdec . ks ) ;\n default : return - 1 ;\n }\n }", "idx": 20727}
{"hash": 847431771831526026, "project": "debian", "size": 23, "label": 0, "functionSource": "static size_t q_encoder ( char * str , const char * buf , size_t buflen , const char * tocode ) {\n static const char hex [ ] = \"0123456789ABCDEF\" ;\n char * s0 = str ;\n memcpy ( str , \"=?\" , 2 ) ;\n str += 2 ;\n memcpy ( str , tocode , strlen ( tocode ) ) ;\n str += strlen ( tocode ) ;\n memcpy ( str , \"?Q?\" , 3 ) ;\n str += 3 ;\n while ( buflen -- ) {\n unsigned char c = * buf ++ ;\n if ( c == ' ' ) * str ++ = '_' ;\n else if ( ( c >= 0x7f ) || ( c < 0x20 ) || ( c == '_' ) || strchr ( MimeSpecials , c ) ) {\n * str ++ = '=' ;\n * str ++ = hex [ ( c & 0xf0 ) >> 4 ] ;\n * str ++ = hex [ c & 0x0f ] ;\n }\n else * str ++ = c ;\n }\n memcpy ( str , \"?=\" , 2 ) ;\n str += 2 ;\n return ( str - s0 ) ;\n }", "idx": 20728}
{"hash": -8933711118846965366, "project": "debian", "size": 71, "label": 0, "functionSource": "static uint8_t cirrus_mmio_blt_read ( CirrusVGAState * s , unsigned address ) {\n int value = 0xff ;\n switch ( address ) {\n case ( CIRRUS_MMIO_BLTBGCOLOR + 0 ) : value = cirrus_vga_read_gr ( s , 0x00 ) ;\n break ;\n case ( CIRRUS_MMIO_BLTBGCOLOR + 1 ) : value = cirrus_vga_read_gr ( s , 0x10 ) ;\n break ;\n case ( CIRRUS_MMIO_BLTBGCOLOR + 2 ) : value = cirrus_vga_read_gr ( s , 0x12 ) ;\n break ;\n case ( CIRRUS_MMIO_BLTBGCOLOR + 3 ) : value = cirrus_vga_read_gr ( s , 0x14 ) ;\n break ;\n case ( CIRRUS_MMIO_BLTFGCOLOR + 0 ) : value = cirrus_vga_read_gr ( s , 0x01 ) ;\n break ;\n case ( CIRRUS_MMIO_BLTFGCOLOR + 1 ) : value = cirrus_vga_read_gr ( s , 0x11 ) ;\n break ;\n case ( CIRRUS_MMIO_BLTFGCOLOR + 2 ) : value = cirrus_vga_read_gr ( s , 0x13 ) ;\n break ;\n case ( CIRRUS_MMIO_BLTFGCOLOR + 3 ) : value = cirrus_vga_read_gr ( s , 0x15 ) ;\n break ;\n case ( CIRRUS_MMIO_BLTWIDTH + 0 ) : value = cirrus_vga_read_gr ( s , 0x20 ) ;\n break ;\n case ( CIRRUS_MMIO_BLTWIDTH + 1 ) : value = cirrus_vga_read_gr ( s , 0x21 ) ;\n break ;\n case ( CIRRUS_MMIO_BLTHEIGHT + 0 ) : value = cirrus_vga_read_gr ( s , 0x22 ) ;\n break ;\n case ( CIRRUS_MMIO_BLTHEIGHT + 1 ) : value = cirrus_vga_read_gr ( s , 0x23 ) ;\n break ;\n case ( CIRRUS_MMIO_BLTDESTPITCH + 0 ) : value = cirrus_vga_read_gr ( s , 0x24 ) ;\n break ;\n case ( CIRRUS_MMIO_BLTDESTPITCH + 1 ) : value = cirrus_vga_read_gr ( s , 0x25 ) ;\n break ;\n case ( CIRRUS_MMIO_BLTSRCPITCH + 0 ) : value = cirrus_vga_read_gr ( s , 0x26 ) ;\n break ;\n case ( CIRRUS_MMIO_BLTSRCPITCH + 1 ) : value = cirrus_vga_read_gr ( s , 0x27 ) ;\n break ;\n case ( CIRRUS_MMIO_BLTDESTADDR + 0 ) : value = cirrus_vga_read_gr ( s , 0x28 ) ;\n break ;\n case ( CIRRUS_MMIO_BLTDESTADDR + 1 ) : value = cirrus_vga_read_gr ( s , 0x29 ) ;\n break ;\n case ( CIRRUS_MMIO_BLTDESTADDR + 2 ) : value = cirrus_vga_read_gr ( s , 0x2a ) ;\n break ;\n case ( CIRRUS_MMIO_BLTSRCADDR + 0 ) : value = cirrus_vga_read_gr ( s , 0x2c ) ;\n break ;\n case ( CIRRUS_MMIO_BLTSRCADDR + 1 ) : value = cirrus_vga_read_gr ( s , 0x2d ) ;\n break ;\n case ( CIRRUS_MMIO_BLTSRCADDR + 2 ) : value = cirrus_vga_read_gr ( s , 0x2e ) ;\n break ;\n case CIRRUS_MMIO_BLTWRITEMASK : value = cirrus_vga_read_gr ( s , 0x2f ) ;\n break ;\n case CIRRUS_MMIO_BLTMODE : value = cirrus_vga_read_gr ( s , 0x30 ) ;\n break ;\n case CIRRUS_MMIO_BLTROP : value = cirrus_vga_read_gr ( s , 0x32 ) ;\n break ;\n case CIRRUS_MMIO_BLTMODEEXT : value = cirrus_vga_read_gr ( s , 0x33 ) ;\n break ;\n case ( CIRRUS_MMIO_BLTTRANSPARENTCOLOR + 0 ) : value = cirrus_vga_read_gr ( s , 0x34 ) ;\n break ;\n case ( CIRRUS_MMIO_BLTTRANSPARENTCOLOR + 1 ) : value = cirrus_vga_read_gr ( s , 0x35 ) ;\n break ;\n case ( CIRRUS_MMIO_BLTTRANSPARENTCOLORMASK + 0 ) : value = cirrus_vga_read_gr ( s , 0x38 ) ;\n break ;\n case ( CIRRUS_MMIO_BLTTRANSPARENTCOLORMASK + 1 ) : value = cirrus_vga_read_gr ( s , 0x39 ) ;\n break ;\n case CIRRUS_MMIO_BLTSTATUS : value = cirrus_vga_read_gr ( s , 0x31 ) ;\n break ;\n default : # ifdef DEBUG_CIRRUS printf ( \"cirrus: mmio read - address 0x%04x\\n\" , address ) ;\n # endif break ;\n }\n trace_vga_cirrus_write_blt ( address , value ) ;\n return ( uint8_t ) value ;\n }", "idx": 20729}
{"hash": -6119142299306266167, "project": "debian", "size": 15, "label": 0, "functionSource": "static int for_pos_int_continue ( i_ctx_t * i_ctx_p ) {\n os_ptr op = osp ;\n register es_ptr ep = esp ;\n int var = ep [ - 3 ] . value . intval ;\n if ( var > ep [ - 1 ] . value . intval ) {\n esp -= 5 ;\n return o_pop_estack ;\n }\n push ( 1 ) ;\n make_int ( op , var ) ;\n ep [ - 3 ] . value . intval = var + ep [ - 2 ] . value . intval ;\n ref_assign_inline ( ep + 2 , ep ) ;\n esp = ep + 2 ;\n return o_push_estack ;\n }", "idx": 20730}
{"hash": 5357882892791796049, "project": "debian", "size": 6, "label": 0, "functionSource": "static void e1000e_set_itr ( E1000ECore * core , int index , uint32_t val ) {\n uint32_t interval = val & 0xffff ;\n trace_e1000e_irq_itr_set ( val ) ;\n core -> itr_guest_value = interval ;\n core -> mac [ index ] = MAX ( interval , E1000E_MIN_XITR ) ;\n }", "idx": 20731}
{"hash": -3740862514502467070, "project": "debian", "size": 20, "label": 0, "functionSource": "int _WriteType42SFNTS ( FILE * type42 , SplineFont * sf , enum fontformat format , int flags , EncMap * map , int layer ) {\n struct alltabs at ;\n int i ;\n locale_t tmplocale ;\n locale_t oldlocale ;\n switch_to_c_locale ( & tmplocale , & oldlocale ) ;\n if ( sf -> subfontcnt != 0 ) sf = sf -> subfonts [ 0 ] ;\n for ( i = 0 ;\n i < sf -> glyphcnt ;\n ++ i ) if ( sf -> glyphs [ i ] != NULL ) sf -> glyphs [ i ] -> ttf_glyph = - 1 ;\n memset ( & at , '\\0' , sizeof ( struct alltabs ) ) ;\n ATinit ( & at , sf , map , flags , layer , format , bf_none , NULL ) ;\n at . applemode = false ;\n at . opentypemode = false ;\n if ( initTables ( & at , sf , format , NULL , bf_none ) ) dumptype42 ( type42 , & at , format ) ;\n free ( at . gi . loca ) ;\n switch_to_old_locale ( & tmplocale , & oldlocale ) ;\n if ( at . error || ferror ( type42 ) ) return ( 0 ) ;\n return ( 1 ) ;\n }", "idx": 20732}
{"hash": -5493081488206619677, "project": "debian", "size": 10, "label": 0, "functionSource": "static const char * cmd_rule_remove_by_id ( cmd_parms * cmd , void * _dcfg , const char * p1 ) {\n directory_config * dcfg = ( directory_config * ) _dcfg ;\n rule_exception * re = apr_pcalloc ( cmd -> pool , sizeof ( rule_exception ) ) ;\n if ( dcfg == NULL ) return NULL ;\n re -> type = RULE_EXCEPTION_REMOVE_ID ;\n re -> param = p1 ;\n * ( rule_exception * * ) apr_array_push ( dcfg -> rule_exceptions ) = re ;\n msre_ruleset_rule_remove_with_exception ( dcfg -> ruleset , re ) ;\n return NULL ;\n }", "idx": 20733}
{"hash": 7847057953677889923, "project": "debian", "size": 7, "label": 0, "functionSource": "static void skip_space ( char * * cpp ) {\n char * cp ;\n for ( cp = * cpp ;\n * cp == ' ' || * cp == '\\t' ;\n cp ++ ) ;\n * cpp = cp ;\n }", "idx": 20734}
{"hash": 4489017523191997023, "project": "debian", "size": 4, "label": 0, "functionSource": "int dissect_h225_CallReferenceValue ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_constrained_integer ( tvb , offset , actx , tree , hf_index , 0U , 65535U , NULL , FALSE ) ;\n return offset ;\n }", "idx": 20735}
{"hash": 4489017523191997023, "project": "debian", "size": 8, "label": 0, "functionSource": "static int dissect_h225_T_oid ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 883 \"./asn1/h225/h225.cnf\" const gchar * oid_str = NULL ;\n gef_ctx_t * gefx ;\n offset = dissect_per_object_identifier_str ( tvb , offset , actx , tree , hf_index , & oid_str ) ;\n gefx = gef_ctx_get ( actx -> private_data ) ;\n if ( gefx ) gefx -> id = oid_str ;\n return offset ;\n }", "idx": 20736}
{"hash": 4313735399044135249, "project": "debian", "size": 17, "label": 0, "functionSource": "sf_count_t psf_fgets ( char * buffer , sf_count_t bufsize , SF_PRIVATE * psf ) {\n sf_count_t k = 0 ;\n sf_count_t count ;\n while ( k < bufsize - 1 ) {\n count = read ( psf -> file . filedes , & ( buffer [ k ] ) , 1 ) ;\n if ( count == - 1 ) {\n if ( errno == EINTR ) continue ;\n psf_log_syserr ( psf , errno ) ;\n break ;\n }\n ;\n if ( count == 0 || buffer [ k ++ ] == '\\n' ) break ;\n }\n ;\n buffer [ k ] = 0 ;\n return k ;\n }", "idx": 20737}
{"hash": -2614908340588220483, "project": "chrome", "size": 11, "label": 1, "functionSource": "TEST_P ( GLES2DecoderTestWithCHROMIUMPathRendering , MatrixLoadfCHROMIUMImmediateValidArgs ) {\n cmds : : MatrixLoadfCHROMIUMImmediate & cmd = * GetImmediateAs < cmds : : MatrixLoadfCHROMIUMImmediate > ( ) ;\n SpecializedSetup < cmds : : MatrixLoadfCHROMIUMImmediate , 0 > ( true ) ;\n GLfloat temp [ 16 ] = {\n 0 , }\n ;\n cmd . Init ( GL_PATH_PROJECTION_CHROMIUM , & temp [ 0 ] ) ;\n EXPECT_CALL ( * gl_ , MatrixLoadfEXT ( GL_PATH_PROJECTION_CHROMIUM , reinterpret_cast < GLfloat * > ( ImmediateDataAddress ( & cmd ) ) ) ) ;\n EXPECT_EQ ( error : : kNoError , ExecuteImmediateCmd ( cmd , sizeof ( temp ) ) ) ;\n EXPECT_EQ ( GL_NO_ERROR , GetGLError ( ) ) ;\n }", "idx": 20738}
{"hash": 6080147530626246065, "project": "debian", "size": 42, "label": 0, "functionSource": "static void vc1_smooth_overlap_filter_iblk ( VC1Context * v ) {\n MpegEncContext * s = & v -> s ;\n int mb_pos ;\n if ( v -> condover == CONDOVER_NONE ) return ;\n mb_pos = s -> mb_x + s -> mb_y * s -> mb_stride ;\n if ( v -> condover == CONDOVER_ALL || v -> pq >= 9 || v -> over_flags_plane [ mb_pos ] ) {\n if ( s -> mb_x && ( v -> condover == CONDOVER_ALL || v -> pq >= 9 || v -> over_flags_plane [ mb_pos - 1 ] ) ) {\n v -> vc1dsp . vc1_h_s_overlap ( v -> block [ v -> left_blk_idx ] [ 1 ] , v -> block [ v -> cur_blk_idx ] [ 0 ] ) ;\n v -> vc1dsp . vc1_h_s_overlap ( v -> block [ v -> left_blk_idx ] [ 3 ] , v -> block [ v -> cur_blk_idx ] [ 2 ] ) ;\n if ( ! ( s -> flags & CODEC_FLAG_GRAY ) ) {\n v -> vc1dsp . vc1_h_s_overlap ( v -> block [ v -> left_blk_idx ] [ 4 ] , v -> block [ v -> cur_blk_idx ] [ 4 ] ) ;\n v -> vc1dsp . vc1_h_s_overlap ( v -> block [ v -> left_blk_idx ] [ 5 ] , v -> block [ v -> cur_blk_idx ] [ 5 ] ) ;\n }\n }\n v -> vc1dsp . vc1_h_s_overlap ( v -> block [ v -> cur_blk_idx ] [ 0 ] , v -> block [ v -> cur_blk_idx ] [ 1 ] ) ;\n v -> vc1dsp . vc1_h_s_overlap ( v -> block [ v -> cur_blk_idx ] [ 2 ] , v -> block [ v -> cur_blk_idx ] [ 3 ] ) ;\n if ( s -> mb_x == s -> mb_width - 1 ) {\n if ( ! s -> first_slice_line && ( v -> condover == CONDOVER_ALL || v -> pq >= 9 || v -> over_flags_plane [ mb_pos - s -> mb_stride ] ) ) {\n v -> vc1dsp . vc1_v_s_overlap ( v -> block [ v -> top_blk_idx ] [ 2 ] , v -> block [ v -> cur_blk_idx ] [ 0 ] ) ;\n v -> vc1dsp . vc1_v_s_overlap ( v -> block [ v -> top_blk_idx ] [ 3 ] , v -> block [ v -> cur_blk_idx ] [ 1 ] ) ;\n if ( ! ( s -> flags & CODEC_FLAG_GRAY ) ) {\n v -> vc1dsp . vc1_v_s_overlap ( v -> block [ v -> top_blk_idx ] [ 4 ] , v -> block [ v -> cur_blk_idx ] [ 4 ] ) ;\n v -> vc1dsp . vc1_v_s_overlap ( v -> block [ v -> top_blk_idx ] [ 5 ] , v -> block [ v -> cur_blk_idx ] [ 5 ] ) ;\n }\n }\n v -> vc1dsp . vc1_v_s_overlap ( v -> block [ v -> cur_blk_idx ] [ 0 ] , v -> block [ v -> cur_blk_idx ] [ 2 ] ) ;\n v -> vc1dsp . vc1_v_s_overlap ( v -> block [ v -> cur_blk_idx ] [ 1 ] , v -> block [ v -> cur_blk_idx ] [ 3 ] ) ;\n }\n }\n if ( s -> mb_x && ( v -> condover == CONDOVER_ALL || v -> over_flags_plane [ mb_pos - 1 ] ) ) {\n if ( ! s -> first_slice_line && ( v -> condover == CONDOVER_ALL || v -> pq >= 9 || v -> over_flags_plane [ mb_pos - s -> mb_stride - 1 ] ) ) {\n v -> vc1dsp . vc1_v_s_overlap ( v -> block [ v -> topleft_blk_idx ] [ 2 ] , v -> block [ v -> left_blk_idx ] [ 0 ] ) ;\n v -> vc1dsp . vc1_v_s_overlap ( v -> block [ v -> topleft_blk_idx ] [ 3 ] , v -> block [ v -> left_blk_idx ] [ 1 ] ) ;\n if ( ! ( s -> flags & CODEC_FLAG_GRAY ) ) {\n v -> vc1dsp . vc1_v_s_overlap ( v -> block [ v -> topleft_blk_idx ] [ 4 ] , v -> block [ v -> left_blk_idx ] [ 4 ] ) ;\n v -> vc1dsp . vc1_v_s_overlap ( v -> block [ v -> topleft_blk_idx ] [ 5 ] , v -> block [ v -> left_blk_idx ] [ 5 ] ) ;\n }\n }\n v -> vc1dsp . vc1_v_s_overlap ( v -> block [ v -> left_blk_idx ] [ 0 ] , v -> block [ v -> left_blk_idx ] [ 2 ] ) ;\n v -> vc1dsp . vc1_v_s_overlap ( v -> block [ v -> left_blk_idx ] [ 1 ] , v -> block [ v -> left_blk_idx ] [ 3 ] ) ;\n }\n }", "idx": 20739}
{"hash": -5780611388839125875, "project": "chrome", "size": 4, "label": 0, "functionSource": "xmlBufferAllocationScheme * __xmlBufferAllocScheme ( void ) {\n if ( IS_MAIN_THREAD ) return ( & xmlBufferAllocScheme ) ;\n else return ( & xmlGetGlobalState ( ) -> xmlBufferAllocScheme ) ;\n }", "idx": 20740}
{"hash": -7076754245473579218, "project": "chrome", "size": 4, "label": 0, "functionSource": "void evhttp_connection_set_local_port ( struct evhttp_connection * evcon , unsigned short port ) {\n assert ( evcon -> state == EVCON_DISCONNECTED ) ;\n evcon -> bind_port = port ;\n }", "idx": 20741}
{"hash": 355220887711506893, "project": "debian", "size": 7, "label": 0, "functionSource": "bool statistic_proc_security_check ( VariableStatData * vardata , Oid func_oid ) {\n if ( vardata -> acl_ok ) return true ;\n if ( ! OidIsValid ( func_oid ) ) return false ;\n if ( get_func_leakproof ( func_oid ) ) return true ;\n ereport ( DEBUG2 , ( errmsg_internal ( \"not using statistics because function \\\"%s\\\" is not leak-proof\" , get_func_name ( func_oid ) ) ) ) ;\n return false ;\n }", "idx": 20742}
{"hash": 1182028467273264883, "project": "debian", "size": 37, "label": 0, "functionSource": "VAR * var_get ( const char * var_name , const char * * var_name_end , my_bool raw , my_bool ignore_not_existing ) {\n int digit ;\n VAR * v ;\n DBUG_ENTER ( \"var_get\" ) ;\n DBUG_PRINT ( \"enter\" , ( \"var_name: %s\" , var_name ) ) ;\n if ( * var_name != '$' ) goto err ;\n digit = * ++ var_name - '0' ;\n if ( digit < 0 || digit >= 10 ) {\n const char * save_var_name = var_name , * end ;\n uint length ;\n end = ( var_name_end ) ? * var_name_end : 0 ;\n while ( my_isvar ( charset_info , * var_name ) && var_name != end ) var_name ++ ;\n if ( var_name == save_var_name ) {\n if ( ignore_not_existing ) DBUG_RETURN ( 0 ) ;\n die ( \"Empty variable\" ) ;\n }\n length = ( uint ) ( var_name - save_var_name ) ;\n if ( length >= MAX_VAR_NAME_LENGTH ) die ( \"Too long variable name: %s\" , save_var_name ) ;\n if ( ! ( v = ( VAR * ) my_hash_search ( & var_hash , ( const uchar * ) save_var_name , length ) ) ) {\n char buff [ MAX_VAR_NAME_LENGTH + 1 ] ;\n strmake ( buff , save_var_name , length ) ;\n v = var_from_env ( buff , \"\" ) ;\n }\n var_name -- ;\n }\n else v = var_reg + digit ;\n if ( ! raw && v -> int_dirty ) {\n sprintf ( v -> str_val , \"%d\" , v -> int_val ) ;\n v -> int_dirty = false ;\n v -> str_val_len = strlen ( v -> str_val ) ;\n }\n if ( var_name_end ) * var_name_end = var_name ;\n DBUG_RETURN ( v ) ;\n err : if ( var_name_end ) * var_name_end = 0 ;\n die ( \"Unsupported variable name: %s\" , var_name ) ;\n DBUG_RETURN ( 0 ) ;\n }", "idx": 20743}
{"hash": 1891617106617090004, "project": "chrome", "size": 58, "label": 1, "functionSource": "static void T_UConverter_toUnicode_UTF32_BE ( UConverterToUnicodeArgs * args , UErrorCode * err ) {\n const unsigned char * mySource = ( unsigned char * ) args -> source ;\n UChar * myTarget = args -> target ;\n const unsigned char * sourceLimit = ( unsigned char * ) args -> sourceLimit ;\n const UChar * targetLimit = args -> targetLimit ;\n unsigned char * toUBytes = args -> converter -> toUBytes ;\n uint32_t ch , i ;\n if ( args -> converter -> toUnicodeStatus && myTarget < targetLimit ) {\n i = args -> converter -> toULength ;\n args -> converter -> toULength = 0 ;\n ch = args -> converter -> toUnicodeStatus - 1 ;\n args -> converter -> toUnicodeStatus = 0 ;\n goto morebytes ;\n }\n while ( mySource < sourceLimit && myTarget < targetLimit ) {\n i = 0 ;\n ch = 0 ;\n morebytes : while ( i < sizeof ( uint32_t ) ) {\n if ( mySource < sourceLimit ) {\n ch = ( ch << 8 ) | ( uint8_t ) ( * mySource ) ;\n toUBytes [ i ++ ] = ( char ) * ( mySource ++ ) ;\n }\n else {\n args -> converter -> toUnicodeStatus = ch + 1 ;\n args -> converter -> toULength = ( int8_t ) i ;\n goto donefornow ;\n }\n }\n if ( ch <= MAXIMUM_UTF && ! U_IS_SURROGATE ( ch ) ) {\n if ( ch <= MAXIMUM_UCS2 ) {\n * ( myTarget ++ ) = ( UChar ) ch ;\n }\n else {\n * ( myTarget ++ ) = U16_LEAD ( ch ) ;\n ch = U16_TRAIL ( ch ) ;\n if ( myTarget < targetLimit ) {\n * ( myTarget ++ ) = ( UChar ) ch ;\n }\n else {\n args -> converter -> UCharErrorBuffer [ 0 ] = ( UChar ) ch ;\n args -> converter -> UCharErrorBufferLength = 1 ;\n * err = U_BUFFER_OVERFLOW_ERROR ;\n break ;\n }\n }\n }\n else {\n args -> converter -> toULength = ( int8_t ) i ;\n * err = U_ILLEGAL_CHAR_FOUND ;\n break ;\n }\n }\n donefornow : if ( mySource < sourceLimit && myTarget >= targetLimit && U_SUCCESS ( * err ) ) {\n * err = U_BUFFER_OVERFLOW_ERROR ;\n }\n args -> target = myTarget ;\n args -> source = ( const char * ) mySource ;\n }", "idx": 20744}
{"hash": -3777025485787920715, "project": "debian", "size": 32, "label": 0, "functionSource": "static int read_code_table ( CLLCContext * ctx , GetBitContext * gb , VLC * vlc ) {\n uint8_t symbols [ 256 ] ;\n uint8_t bits [ 256 ] ;\n uint16_t codes [ 256 ] ;\n int num_lens , num_codes , num_codes_sum , prefix ;\n int i , j , count ;\n prefix = 0 ;\n count = 0 ;\n num_codes_sum = 0 ;\n num_lens = get_bits ( gb , 5 ) ;\n for ( i = 0 ;\n i < num_lens ;\n i ++ ) {\n num_codes = get_bits ( gb , 9 ) ;\n num_codes_sum += num_codes ;\n if ( num_codes_sum > 256 ) {\n vlc -> table = NULL ;\n av_log ( ctx -> avctx , AV_LOG_ERROR , \"Too many VLCs (%d) to be read.\\n\" , num_codes_sum ) ;\n return AVERROR_INVALIDDATA ;\n }\n for ( j = 0 ;\n j < num_codes ;\n j ++ ) {\n symbols [ count ] = get_bits ( gb , 8 ) ;\n bits [ count ] = i + 1 ;\n codes [ count ] = prefix ++ ;\n count ++ ;\n }\n prefix <<= 1 ;\n }\n return ff_init_vlc_sparse ( vlc , 7 , count , bits , 1 , 1 , codes , 2 , 2 , symbols , 1 , 1 , 0 ) ;\n }", "idx": 20745}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_SEQUENCE_SIZE_1_256_OF_RTPPayloadType ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_constrained_sequence_of ( tvb , offset , actx , tree , hf_index , ett_h245_SEQUENCE_SIZE_1_256_OF_RTPPayloadType , SEQUENCE_SIZE_1_256_OF_RTPPayloadType_sequence_of , 1 , 256 , FALSE ) ;\n return offset ;\n }", "idx": 20746}
{"hash": -5300415683778646743, "project": "chrome", "size": 3, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( ExtensionMessageBubbleViewBrowserTest , TestDevModeBubbleIsntShownTwice ) {\n TestDevModeBubbleIsntShownTwice ( ) ;\n }", "idx": 20747}
{"hash": 1676654288894940649, "project": "debian", "size": 18, "label": 0, "functionSource": "int quit ( ) {\n kadm5_ret_t retval ;\n if ( locked ) {\n retval = kadm5_unlock ( handle ) ;\n if ( retval ) {\n com_err ( \"quit\" , retval , _ ( \"while unlocking locked database\" ) ) ;\n return 1 ;\n }\n locked = 0 ;\n }\n kadm5_destroy ( handle ) ;\n if ( ccache_name != NULL ) {\n fprintf ( stderr , \"\\n\\a\\a\\a%s\" , _ ( \"Administration credentials NOT DESTROYED.\\n\" ) ) ;\n }\n krb5_klog_close ( context ) ;\n krb5_free_context ( context ) ;\n return 0 ;\n }", "idx": 20748}
{"hash": -2607754285145856562, "project": "debian", "size": 3, "label": 0, "functionSource": "static inline void set_num_722 ( unsigned char * p , uint16_t value ) {\n archive_be16enc ( p , value ) ;\n }", "idx": 20749}
{"hash": -1929262071302712016, "project": "debian", "size": 3, "label": 0, "functionSource": "static void Type_ViewingConditions_Free ( struct _cms_typehandler_struct * self , void * Ptr ) {\n _cmsFree ( self -> ContextID , Ptr ) ;\n }", "idx": 20750}
{"hash": -5357254031401749470, "project": "debian", "size": 18, "label": 0, "functionSource": "static void resume ( lua_State * L , void * ud ) {\n StkId firstArg = cast ( StkId , ud ) ;\n CallInfo * ci = L -> ci ;\n if ( L -> status == 0 ) {\n lua_assert ( ci == L -> base_ci && firstArg > L -> base ) ;\n if ( luaD_precall ( L , firstArg - 1 , LUA_MULTRET ) != PCRLUA ) return ;\n }\n else {\n lua_assert ( L -> status == LUA_YIELD ) ;\n L -> status = 0 ;\n if ( ! f_isLua ( ci ) ) {\n lua_assert ( GET_OPCODE ( * ( ( ci - 1 ) -> savedpc - 1 ) ) == OP_CALL || GET_OPCODE ( * ( ( ci - 1 ) -> savedpc - 1 ) ) == OP_TAILCALL ) ;\n if ( luaD_poscall ( L , firstArg ) ) L -> top = L -> ci -> top ;\n }\n else L -> base = L -> ci -> base ;\n }\n luaV_execute ( L , cast_int ( L -> ci - L -> base_ci ) ) ;\n }", "idx": 20751}
{"hash": -8028756826159773630, "project": "debian", "size": 6, "label": 0, "functionSource": "static void mark_create_done ( ArchiveHandle * AH , TocEntry * te ) {\n if ( AH -> tableDataId [ te -> dumpId ] != 0 ) {\n TocEntry * ted = AH -> tocsByDumpId [ AH -> tableDataId [ te -> dumpId ] ] ;\n ted -> created = true ;\n }\n }", "idx": 20752}
{"hash": -6357438421920978642, "project": "debian", "size": 295, "label": 0, "functionSource": "int libevt_record_values_read_event ( libevt_record_values_t * record_values , uint8_t * record_data , size_t record_data_size , uint8_t strict_mode , libcerror_error_t * * error ) {\n static char * function = \"libevt_record_values_read_event\" ;\n size_t record_data_offset = 0 ;\n size_t strings_data_offset = 0 ;\n ssize_t value_data_size = 0 ;\n uint32_t data_offset = 0 ;\n uint32_t data_size = 0 ;\n uint32_t members_data_size = 0 ;\n uint32_t size = 0 ;\n uint32_t size_copy = 0 ;\n uint32_t strings_offset = 0 ;\n uint32_t strings_size = 0 ;\n uint32_t user_sid_offset = 0 ;\n uint32_t user_sid_size = 0 ;\n # if defined ( HAVE_DEBUG_OUTPUT ) uint32_t value_32bit = 0 ;\n uint16_t value_16bit = 0 ;\n # endif if ( record_values == NULL ) {\n libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_ARGUMENTS , LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE , \"%s: invalid record values.\" , function ) ;\n return ( - 1 ) ;\n }\n if ( record_data == NULL ) {\n libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_ARGUMENTS , LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE , \"%s: invalid record data.\" , function ) ;\n return ( - 1 ) ;\n }\n if ( record_data_size > ( size_t ) SSIZE_MAX ) {\n libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_ARGUMENTS , LIBCERROR_ARGUMENT_ERROR_VALUE_EXCEEDS_MAXIMUM , \"%s: invalid record data size value exceeds maximum.\" , function ) ;\n return ( - 1 ) ;\n }\n if ( record_data_size < ( sizeof ( evt_record_event_header_t ) + 4 ) ) {\n libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , \"%s: record data size value out of bounds.\" , function ) ;\n return ( - 1 ) ;\n }\n byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> size , size ) ;\n byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> record_number , record_values -> number ) ;\n byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> creation_time , record_values -> creation_time ) ;\n byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> written_time , record_values -> written_time ) ;\n byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> event_identifier , record_values -> event_identifier ) ;\n byte_stream_copy_to_uint16_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> event_type , record_values -> event_type ) ;\n byte_stream_copy_to_uint16_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> event_category , record_values -> event_category ) ;\n byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> strings_offset , strings_offset ) ;\n byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> user_sid_size , user_sid_size ) ;\n byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> user_sid_offset , user_sid_offset ) ;\n byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> data_size , data_size ) ;\n byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> data_offset , data_offset ) ;\n byte_stream_copy_to_uint32_little_endian ( & ( record_data [ record_data_size - 4 ] ) , size_copy ) ;\n # if defined ( HAVE_DEBUG_OUTPUT ) if ( libcnotify_verbose != 0 ) {\n libcnotify_printf ( \"%s: size\\t\\t\\t\\t\\t: %\" PRIu32 \"\\n\" , function , size ) ;\n libcnotify_printf ( \"%s: signature\\t\\t\\t\\t: %c%c%c%c\\n\" , function , ( ( evt_record_event_header_t * ) record_data ) -> signature [ 0 ] , ( ( evt_record_event_header_t * ) record_data ) -> signature [ 1 ] , ( ( evt_record_event_header_t * ) record_data ) -> signature [ 2 ] , ( ( evt_record_event_header_t * ) record_data ) -> signature [ 3 ] ) ;\n libcnotify_printf ( \"%s: record number\\t\\t\\t\\t: %\" PRIu32 \"\\n\" , function , record_values -> number ) ;\n if ( libevt_debug_print_posix_time_value ( function , \"creation time\\t\\t\\t\\t\" , ( ( evt_record_event_header_t * ) record_data ) -> creation_time , 4 , LIBFDATETIME_ENDIAN_LITTLE , LIBFDATETIME_POSIX_TIME_VALUE_TYPE_SECONDS_32BIT_SIGNED , LIBFDATETIME_STRING_FORMAT_TYPE_CTIME | LIBFDATETIME_STRING_FORMAT_FLAG_DATE_TIME , error ) != 1 ) {\n libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_PRINT_FAILED , \"%s: unable to print POSIX time value.\" , function ) ;\n goto on_error ;\n }\n if ( libevt_debug_print_posix_time_value ( function , \"written time\\t\\t\\t\\t\" , ( ( evt_record_event_header_t * ) record_data ) -> written_time , 4 , LIBFDATETIME_ENDIAN_LITTLE , LIBFDATETIME_POSIX_TIME_VALUE_TYPE_SECONDS_32BIT_SIGNED , LIBFDATETIME_STRING_FORMAT_TYPE_CTIME | LIBFDATETIME_STRING_FORMAT_FLAG_DATE_TIME , error ) != 1 ) {\n libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_PRINT_FAILED , \"%s: unable to print POSIX time value.\" , function ) ;\n goto on_error ;\n }\n libcnotify_printf ( \"%s: event identifier\\t\\t\\t: 0x%08\" PRIx32 \"\\n\" , function , record_values -> event_identifier ) ;\n libcnotify_printf ( \"%s: event identifier: code\\t\\t\\t: %\" PRIu32 \"\\n\" , function , record_values -> event_identifier & 0x0000ffffUL ) ;\n libcnotify_printf ( \"%s: event identifier: facility\\t\\t: %\" PRIu32 \"\\n\" , function , ( record_values -> event_identifier & 0x0fff0000UL ) >> 16 ) ;\n libcnotify_printf ( \"%s: event identifier: reserved\\t\\t: %\" PRIu32 \"\\n\" , function , ( record_values -> event_identifier & 0x10000000UL ) >> 28 ) ;\n libcnotify_printf ( \"%s: event identifier: customer flags\\t: %\" PRIu32 \"\\n\" , function , ( record_values -> event_identifier & 0x20000000UL ) >> 29 ) ;\n libcnotify_printf ( \"%s: event identifier: severity\\t\\t: %\" PRIu32 \" (\" , function , ( record_values -> event_identifier & 0xc0000000UL ) >> 30 ) ;\n libevt_debug_print_event_identifier_severity ( record_values -> event_identifier ) ;\n libcnotify_printf ( \")\\n\" ) ;\n libcnotify_printf ( \"%s: event type\\t\\t\\t\\t: %\" PRIu16 \" (\" , function , record_values -> event_type ) ;\n libevt_debug_print_event_type ( record_values -> event_type ) ;\n libcnotify_printf ( \")\\n\" ) ;\n byte_stream_copy_to_uint16_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> number_of_strings , value_16bit ) ;\n libcnotify_printf ( \"%s: number of strings\\t\\t\\t: %\" PRIu16 \"\\n\" , function , value_16bit ) ;\n libcnotify_printf ( \"%s: event category\\t\\t\\t\\t: %\" PRIu16 \"\\n\" , function , record_values -> event_category ) ;\n byte_stream_copy_to_uint16_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> event_flags , value_16bit ) ;\n libcnotify_printf ( \"%s: event flags\\t\\t\\t\\t: 0x%04\" PRIx16 \"\\n\" , function , value_16bit ) ;\n byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> closing_record_number , value_32bit ) ;\n libcnotify_printf ( \"%s: closing record values number\\t\\t: %\" PRIu32 \"\\n\" , function , value_32bit ) ;\n libcnotify_printf ( \"%s: strings offset\\t\\t\\t\\t: %\" PRIu32 \"\\n\" , function , strings_offset ) ;\n libcnotify_printf ( \"%s: user security identifier (SID) size\\t: %\" PRIu32 \"\\n\" , function , user_sid_size ) ;\n libcnotify_printf ( \"%s: user security identifier (SID) offset\\t: %\" PRIu32 \"\\n\" , function , user_sid_offset ) ;\n libcnotify_printf ( \"%s: data size\\t\\t\\t\\t: %\" PRIu32 \"\\n\" , function , data_size ) ;\n libcnotify_printf ( \"%s: data offset\\t\\t\\t\\t: %\" PRIu32 \"\\n\" , function , data_offset ) ;\n }\n # endif record_data_offset = sizeof ( evt_record_event_header_t ) ;\n if ( ( user_sid_offset == 0 ) && ( user_sid_size != 0 ) ) {\n libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , \"%s: user SID offset or size value out of bounds.\" , function ) ;\n goto on_error ;\n }\n if ( user_sid_offset != 0 ) {\n if ( ( ( size_t ) user_sid_offset < record_data_offset ) || ( ( size_t ) user_sid_offset >= ( record_data_size - 4 ) ) ) {\n libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , \"%s: user SID offset value out of bounds.\" , function ) ;\n goto on_error ;\n }\n if ( user_sid_size != 0 ) {\n if ( ( size_t ) ( user_sid_offset + user_sid_size ) > ( record_data_size - 4 ) ) {\n libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , \"%s: user SID size value out of bounds.\" , function ) ;\n goto on_error ;\n }\n }\n }\n if ( ( ( size_t ) strings_offset < user_sid_offset ) || ( ( size_t ) strings_offset >= ( record_data_size - 4 ) ) ) {\n libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , \"%s: strings offset value out of bounds.\" , function ) ;\n goto on_error ;\n }\n if ( ( ( size_t ) data_offset < strings_offset ) || ( ( size_t ) data_offset >= ( record_data_size - 4 ) ) ) {\n if ( data_size != 0 ) {\n libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , \"%s: data offset value out of bounds.\" , function ) ;\n goto on_error ;\n }\n data_offset = ( uint32_t ) record_data_size - 4 ;\n }\n if ( ( ( size_t ) strings_offset >= ( record_data_size - 4 ) ) && ( strings_offset != data_offset ) ) {\n libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , \"%s: strings offset value out of bounds.\" , function ) ;\n goto on_error ;\n }\n if ( strings_offset != 0 ) {\n if ( strings_offset < record_data_offset ) {\n libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , \"%s: strings offset value out of bounds.\" , function ) ;\n goto on_error ;\n }\n }\n if ( user_sid_offset != 0 ) {\n members_data_size = user_sid_offset - ( uint32_t ) record_data_offset ;\n }\n else if ( strings_offset != 0 ) {\n members_data_size = strings_offset - ( uint32_t ) record_data_offset ;\n }\n if ( strings_offset != 0 ) {\n strings_size = data_offset - strings_offset ;\n }\n if ( data_size != 0 ) {\n if ( ( size_t ) ( data_offset + data_size ) > ( record_data_size - 4 ) ) {\n libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , \"%s: data size value out of bounds.\" , function ) ;\n goto on_error ;\n }\n }\n if ( members_data_size != 0 ) {\n # if defined ( HAVE_DEBUG_OUTPUT ) if ( libcnotify_verbose != 0 ) {\n libcnotify_printf ( \"%s: members data:\\n\" , function ) ;\n libcnotify_print_data ( & ( record_data [ record_data_offset ] ) , members_data_size , LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA ) ;\n }\n # endif if ( libfvalue_value_type_initialize ( & ( record_values -> source_name ) , LIBFVALUE_VALUE_TYPE_STRING_UTF16 , error ) != 1 ) {\n libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED , \"%s: unable to create source name value.\" , function ) ;\n goto on_error ;\n }\n value_data_size = libfvalue_value_type_set_data_string ( record_values -> source_name , & ( record_data [ record_data_offset ] ) , members_data_size , LIBFVALUE_CODEPAGE_UTF16_LITTLE_ENDIAN , LIBFVALUE_VALUE_DATA_FLAG_MANAGED , error ) ;\n if ( value_data_size == - 1 ) {\n libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_SET_FAILED , \"%s: unable to set data of source name value.\" , function ) ;\n goto on_error ;\n }\n # if defined ( HAVE_DEBUG_OUTPUT ) if ( libcnotify_verbose != 0 ) {\n libcnotify_printf ( \"%s: source name\\t\\t\\t\\t: \" , function ) ;\n if ( libfvalue_value_print ( record_values -> source_name , 0 , 0 , error ) != 1 ) {\n libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_PRINT_FAILED , \"%s: unable to print source name value.\" , function ) ;\n goto on_error ;\n }\n libcnotify_printf ( \"\\n\" ) ;\n }\n # endif record_data_offset += value_data_size ;\n members_data_size -= ( uint32_t ) value_data_size ;\n if ( libfvalue_value_type_initialize ( & ( record_values -> computer_name ) , LIBFVALUE_VALUE_TYPE_STRING_UTF16 , error ) != 1 ) {\n libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED , \"%s: unable to create computer name value.\" , function ) ;\n goto on_error ;\n }\n value_data_size = libfvalue_value_type_set_data_string ( record_values -> computer_name , & ( record_data [ record_data_offset ] ) , members_data_size , LIBFVALUE_CODEPAGE_UTF16_LITTLE_ENDIAN , LIBFVALUE_VALUE_DATA_FLAG_MANAGED , error ) ;\n if ( value_data_size == - 1 ) {\n libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_SET_FAILED , \"%s: unable to set data of computer name value.\" , function ) ;\n goto on_error ;\n }\n # if defined ( HAVE_DEBUG_OUTPUT ) if ( libcnotify_verbose != 0 ) {\n libcnotify_printf ( \"%s: computer name\\t\\t\\t\\t: \" , function ) ;\n if ( libfvalue_value_print ( record_values -> computer_name , 0 , 0 , error ) != 1 ) {\n libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_PRINT_FAILED , \"%s: unable to print computer name value.\" , function ) ;\n goto on_error ;\n }\n libcnotify_printf ( \"\\n\" ) ;\n }\n # endif record_data_offset += value_data_size ;\n members_data_size -= ( uint32_t ) value_data_size ;\n if ( members_data_size > 0 ) {\n # if defined ( HAVE_DEBUG_OUTPUT ) if ( libcnotify_verbose != 0 ) {\n libcnotify_printf ( \"%s: members trailing data:\\n\" , function ) ;\n libcnotify_print_data ( & ( record_data [ record_data_offset ] ) , members_data_size , LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA ) ;\n }\n # endif record_data_offset += members_data_size ;\n }\n }\n if ( user_sid_size != 0 ) {\n if ( user_sid_size > ( ( record_data_size - 4 ) - user_sid_offset ) ) {\n libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , \"%s: user SID data size value out of bounds.\" , function ) ;\n goto on_error ;\n }\n if ( libfvalue_value_type_initialize ( & ( record_values -> user_security_identifier ) , LIBFVALUE_VALUE_TYPE_NT_SECURITY_IDENTIFIER , error ) != 1 ) {\n libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED , \"%s: unable to create user security identifier (SID) value.\" , function ) ;\n goto on_error ;\n }\n if ( libfvalue_value_set_data ( record_values -> user_security_identifier , & ( record_data [ user_sid_offset ] ) , ( size_t ) user_sid_size , LIBFVALUE_ENDIAN_LITTLE , LIBFVALUE_VALUE_DATA_FLAG_MANAGED , error ) != 1 ) {\n libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_SET_FAILED , \"%s: unable to set data of user security identifier (SID) value.\" , function ) ;\n goto on_error ;\n }\n # if defined ( HAVE_DEBUG_OUTPUT ) if ( libcnotify_verbose != 0 ) {\n libcnotify_printf ( \"%s: user security identifier (SID)\\t\\t: \" , function ) ;\n if ( libfvalue_value_print ( record_values -> user_security_identifier , 0 , 0 , error ) != 1 ) {\n libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_PRINT_FAILED , \"%s: unable to print user security identifier (SID) value.\" , function ) ;\n goto on_error ;\n }\n libcnotify_printf ( \"\\n\" ) ;\n }\n # endif record_data_offset += user_sid_size ;\n }\n if ( strings_size != 0 ) {\n if ( strings_size > ( ( record_data_size - 4 ) - strings_offset ) ) {\n libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , \"%s: strings size value out of bounds.\" , function ) ;\n goto on_error ;\n }\n # if defined ( HAVE_DEBUG_OUTPUT ) if ( libcnotify_verbose != 0 ) {\n libcnotify_printf ( \"%s: strings data:\\n\" , function ) ;\n libcnotify_print_data ( & ( record_data [ strings_offset ] ) , strings_size , LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA ) ;\n }\n # endif if ( size_copy == 0 ) {\n strings_data_offset = strings_offset + strings_size - 2 ;\n while ( strings_data_offset > strings_offset ) {\n if ( ( record_data [ strings_data_offset ] != 0 ) || ( record_data [ strings_data_offset + 1 ] != 0 ) ) {\n strings_size += 2 ;\n break ;\n }\n strings_data_offset -= 2 ;\n strings_size -= 2 ;\n }\n }\n if ( libfvalue_value_type_initialize ( & ( record_values -> strings ) , LIBFVALUE_VALUE_TYPE_STRING_UTF16 , error ) != 1 ) {\n libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED , \"%s: unable to create strings value.\" , function ) ;\n goto on_error ;\n }\n value_data_size = libfvalue_value_type_set_data_strings_array ( record_values -> strings , & ( record_data [ strings_offset ] ) , strings_size , LIBFVALUE_CODEPAGE_UTF16_LITTLE_ENDIAN , error ) ;\n if ( value_data_size == - 1 ) {\n libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_SET_FAILED , \"%s: unable to set data of strings value.\" , function ) ;\n goto on_error ;\n }\n record_data_offset += strings_size ;\n }\n if ( data_size != 0 ) {\n if ( data_size > ( ( record_data_size - 4 ) - data_offset ) ) {\n libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , \"%s: data size value out of bounds.\" , function ) ;\n goto on_error ;\n }\n # if defined ( HAVE_DEBUG_OUTPUT ) if ( libcnotify_verbose != 0 ) {\n libcnotify_printf ( \"%s: data:\\n\" , function ) ;\n libcnotify_print_data ( & ( record_data [ record_data_offset ] ) , ( size_t ) data_size , LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA ) ;\n }\n # endif if ( libfvalue_value_type_initialize ( & ( record_values -> data ) , LIBFVALUE_VALUE_TYPE_BINARY_DATA , error ) != 1 ) {\n libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED , \"%s: unable to create data value.\" , function ) ;\n goto on_error ;\n }\n if ( libfvalue_value_set_data ( record_values -> data , & ( record_data [ record_data_offset ] ) , ( size_t ) data_size , LIBFVALUE_ENDIAN_LITTLE , LIBFVALUE_VALUE_DATA_FLAG_MANAGED , error ) != 1 ) {\n libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_SET_FAILED , \"%s: unable to set data of data value.\" , function ) ;\n goto on_error ;\n }\n # if defined ( HAVE_DEBUG_OUTPUT ) record_data_offset += data_size ;\n # endif }\n # if defined ( HAVE_DEBUG_OUTPUT ) if ( libcnotify_verbose != 0 ) {\n if ( record_data_offset < ( record_data_size - 4 ) ) {\n libcnotify_printf ( \"%s: padding:\\n\" , function ) ;\n libcnotify_print_data ( & ( record_data [ record_data_offset ] ) , ( size_t ) record_data_size - record_data_offset - 4 , LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA ) ;\n }\n libcnotify_printf ( \"%s: size copy\\t\\t\\t\\t: %\" PRIu32 \"\\n\" , function , size_copy ) ;\n libcnotify_printf ( \"\\n\" ) ;\n }\n # endif if ( ( strict_mode == 0 ) && ( size_copy == 0 ) ) {\n size_copy = size ;\n }\n if ( size != size_copy ) {\n libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_INPUT , LIBCERROR_INPUT_ERROR_VALUE_MISMATCH , \"%s: value mismatch for size and size copy.\" , function ) ;\n goto on_error ;\n }\n if ( record_data_size != ( size_t ) size ) {\n libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_INPUT , LIBCERROR_INPUT_ERROR_VALUE_MISMATCH , \"%s: value mismatch for record_values data size and size.\" , function ) ;\n goto on_error ;\n }\n return ( 1 ) ;\n on_error : if ( record_values -> data != NULL ) {\n libfvalue_value_free ( & ( record_values -> data ) , NULL ) ;\n }\n if ( record_values -> strings != NULL ) {\n libfvalue_value_free ( & ( record_values -> strings ) , NULL ) ;\n }\n if ( record_values -> user_security_identifier != NULL ) {\n libfvalue_value_free ( & ( record_values -> user_security_identifier ) , NULL ) ;\n }\n if ( record_values -> computer_name != NULL ) {\n libfvalue_value_free ( & ( record_values -> computer_name ) , NULL ) ;\n }\n if ( record_values -> source_name != NULL ) {\n libfvalue_value_free ( & ( record_values -> source_name ) , NULL ) ;\n }\n return ( - 1 ) ;\n }", "idx": 20753}
{"hash": -8487916477825389369, "project": "chrome", "size": 28, "label": 0, "functionSource": "TEST_F ( PrintPreviewUIUnitTest , PrintPreviewData ) {\n WebContents * initiator = browser ( ) -> tab_strip_model ( ) -> GetActiveWebContents ( ) ;\n ASSERT_TRUE ( initiator ) ;\n EXPECT_FALSE ( IsShowingWebContentsModalDialog ( initiator ) ) ;\n printing : : PrintPreviewDialogController * controller = printing : : PrintPreviewDialogController : : GetInstance ( ) ;\n ASSERT_TRUE ( controller ) ;\n printing : : PrintViewManager * print_view_manager = printing : : PrintViewManager : : FromWebContents ( initiator ) ;\n print_view_manager -> PrintPreviewNow ( initiator -> GetMainFrame ( ) , false ) ;\n WebContents * preview_dialog = controller -> GetOrCreatePreviewDialog ( initiator ) ;\n EXPECT_NE ( initiator , preview_dialog ) ;\n EXPECT_EQ ( 1 , browser ( ) -> tab_strip_model ( ) -> count ( ) ) ;\n EXPECT_TRUE ( IsShowingWebContentsModalDialog ( initiator ) ) ;\n PrintPreviewUI * preview_ui = static_cast < PrintPreviewUI * > ( preview_dialog -> GetWebUI ( ) -> GetController ( ) ) ;\n ASSERT_TRUE ( preview_ui != NULL ) ;\n scoped_refptr < base : : RefCountedBytes > data ;\n preview_ui -> GetPrintPreviewDataForIndex ( printing : : COMPLETE_PREVIEW_DOCUMENT_INDEX , & data ) ;\n EXPECT_EQ ( NULL , data . get ( ) ) ;\n scoped_refptr < base : : RefCountedBytes > dummy_data = CreateTestData ( ) ;\n preview_ui -> SetPrintPreviewDataForIndex ( printing : : COMPLETE_PREVIEW_DOCUMENT_INDEX , dummy_data . get ( ) ) ;\n preview_ui -> GetPrintPreviewDataForIndex ( printing : : COMPLETE_PREVIEW_DOCUMENT_INDEX , & data ) ;\n EXPECT_EQ ( dummy_data -> size ( ) , data -> size ( ) ) ;\n EXPECT_EQ ( dummy_data . get ( ) , data . get ( ) ) ;\n dummy_data = new base : : RefCountedBytes ( ) ;\n preview_ui -> SetPrintPreviewDataForIndex ( printing : : FIRST_PAGE_INDEX , dummy_data . get ( ) ) ;\n preview_ui -> ClearAllPreviewData ( ) ;\n preview_ui -> GetPrintPreviewDataForIndex ( printing : : COMPLETE_PREVIEW_DOCUMENT_INDEX , & data ) ;\n EXPECT_EQ ( NULL , data . get ( ) ) ;\n }", "idx": 20754}
{"hash": -5927738579069082820, "project": "debian", "size": 9, "label": 0, "functionSource": "static int xps_parse_line_cap ( char * attr ) {\n if ( attr ) {\n if ( ! strcmp ( attr , \"Flat\" ) ) return 0 ;\n if ( ! strcmp ( attr , \"Round\" ) ) return 1 ;\n if ( ! strcmp ( attr , \"Square\" ) ) return 2 ;\n if ( ! strcmp ( attr , \"Triangle\" ) ) return 3 ;\n }\n return 0 ;\n }", "idx": 20755}
{"hash": 8193534372312945122, "project": "debian", "size": 35, "label": 0, "functionSource": "static inline void pcnet_rmd_store ( PCNetState * s , struct pcnet_RMD * rmd , hwaddr addr ) {\n if ( ! BCR_SSIZE32 ( s ) ) {\n struct {\n uint32_t rbadr ;\n int16_t buf_length ;\n int16_t msg_length ;\n }\n rda ;\n rda . rbadr = cpu_to_le32 ( ( rmd -> rbadr & 0xffffff ) | ( ( rmd -> status & 0xff00 ) << 16 ) ) ;\n rda . buf_length = cpu_to_le16 ( rmd -> buf_length ) ;\n rda . msg_length = cpu_to_le16 ( rmd -> msg_length ) ;\n s -> phys_mem_write ( s -> dma_opaque , addr , ( void * ) & rda , sizeof ( rda ) , 0 ) ;\n }\n else {\n struct {\n uint32_t rbadr ;\n int16_t buf_length ;\n int16_t status ;\n uint32_t msg_length ;\n uint32_t res ;\n }\n rda ;\n rda . rbadr = cpu_to_le32 ( rmd -> rbadr ) ;\n rda . buf_length = cpu_to_le16 ( rmd -> buf_length ) ;\n rda . status = cpu_to_le16 ( rmd -> status ) ;\n rda . msg_length = cpu_to_le32 ( rmd -> msg_length ) ;\n rda . res = cpu_to_le32 ( rmd -> res ) ;\n if ( BCR_SWSTYLE ( s ) == 3 ) {\n uint32_t tmp = rda . rbadr ;\n rda . rbadr = rda . msg_length ;\n rda . msg_length = tmp ;\n }\n s -> phys_mem_write ( s -> dma_opaque , addr , ( void * ) & rda , sizeof ( rda ) , 0 ) ;\n }\n }", "idx": 20756}
{"hash": 1415862279747793542, "project": "chrome", "size": 13, "label": 1, "functionSource": "void linux_udev_hotplug_poll ( void ) {\n struct udev_device * udev_dev ;\n usbi_mutex_static_lock ( & linux_hotplug_lock ) ;\n do {\n udev_dev = udev_monitor_receive_device ( udev_monitor ) ;\n if ( udev_dev ) {\n usbi_dbg ( \"Handling hotplug event from hotplug_poll\" ) ;\n udev_hotplug_event ( udev_dev ) ;\n }\n }\n while ( udev_dev ) ;\n usbi_mutex_static_unlock ( & linux_hotplug_lock ) ;\n }", "idx": 20757}
{"hash": 4620577553943347649, "project": "debian", "size": 12, "label": 1, "functionSource": "static int yop_paint_block ( YopDecContext * s , int tag ) {\n if ( s -> src_end - s -> srcptr < paint_lut [ tag ] [ 3 ] ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"Packet too small.\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n s -> dstptr [ 0 ] = s -> srcptr [ 0 ] ;\n s -> dstptr [ 1 ] = s -> srcptr [ paint_lut [ tag ] [ 0 ] ] ;\n s -> dstptr [ s -> frame . linesize [ 0 ] ] = s -> srcptr [ paint_lut [ tag ] [ 1 ] ] ;\n s -> dstptr [ s -> frame . linesize [ 0 ] + 1 ] = s -> srcptr [ paint_lut [ tag ] [ 2 ] ] ;\n s -> srcptr += paint_lut [ tag ] [ 3 ] ;\n return 0 ;\n }", "idx": 20758}
{"hash": 825216912438754622, "project": "debian", "size": 8, "label": 0, "functionSource": "static int dissect_t38_T30_data ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_enumerated ( tvb , offset , actx , tree , hf_index , 9 , & Data_value , TRUE , 6 , NULL ) ;\n # line 41 \"../../asn1/t38/t38.cnf\" if ( primary_part ) {\n col_append_fstr ( actx -> pinfo -> cinfo , COL_INFO , \" data:%s:\" , val_to_str ( Data_value , t38_T30_data_vals , \"<unknown>\" ) ) ;\n }\n if ( primary_part ) t38_info -> data_value = Data_value ;\n return offset ;\n }", "idx": 20759}
{"hash": 4704178797381506498, "project": "debian", "size": 40, "label": 0, "functionSource": "static krb5_error_code kadm5_copy_principal ( krb5_context context , krb5_const_principal inprinc , krb5_principal * outprinc ) {\n register krb5_principal tempprinc ;\n register int i , nelems ;\n tempprinc = ( krb5_principal ) krb5_db_alloc ( context , NULL , sizeof ( krb5_principal_data ) ) ;\n if ( tempprinc == 0 ) return ENOMEM ;\n VALGRIND_CHECK_DEFINED ( * inprinc ) ;\n * tempprinc = * inprinc ;\n nelems = ( int ) krb5_princ_size ( context , inprinc ) ;\n tempprinc -> data = krb5_db_alloc ( context , NULL , nelems * sizeof ( krb5_data ) ) ;\n if ( tempprinc -> data == 0 ) {\n krb5_db_free ( context , ( char * ) tempprinc ) ;\n return ENOMEM ;\n }\n for ( i = 0 ;\n i < nelems ;\n i ++ ) {\n unsigned int len = krb5_princ_component ( context , inprinc , i ) -> length ;\n krb5_princ_component ( context , tempprinc , i ) -> length = len ;\n if ( ( ( krb5_princ_component ( context , tempprinc , i ) -> data = krb5_db_alloc ( context , NULL , len ) ) == 0 ) && len ) {\n while ( -- i >= 0 ) krb5_db_free ( context , krb5_princ_component ( context , tempprinc , i ) -> data ) ;\n krb5_db_free ( context , tempprinc -> data ) ;\n krb5_db_free ( context , tempprinc ) ;\n return ENOMEM ;\n }\n if ( len ) memcpy ( krb5_princ_component ( context , tempprinc , i ) -> data , krb5_princ_component ( context , inprinc , i ) -> data , len ) ;\n krb5_princ_component ( context , tempprinc , i ) -> magic = KV5M_DATA ;\n }\n tempprinc -> realm . data = krb5_db_alloc ( context , NULL , tempprinc -> realm . length = inprinc -> realm . length ) ;\n if ( ! tempprinc -> realm . data && tempprinc -> realm . length ) {\n for ( i = 0 ;\n i < nelems ;\n i ++ ) krb5_db_free ( context , krb5_princ_component ( context , tempprinc , i ) -> data ) ;\n krb5_db_free ( context , tempprinc -> data ) ;\n krb5_db_free ( context , tempprinc ) ;\n return ENOMEM ;\n }\n if ( tempprinc -> realm . length ) memcpy ( tempprinc -> realm . data , inprinc -> realm . data , inprinc -> realm . length ) ;\n * outprinc = tempprinc ;\n return 0 ;\n }", "idx": 20760}
{"hash": -838046450101744221, "project": "chrome", "size": 27, "label": 0, "functionSource": "CharList * pkg_appendUniqueDirToList ( CharList * l , CharList * * end , const char * strAlias ) {\n char aBuf [ 1024 ] ;\n char * rPtr ;\n rPtr = uprv_strrchr ( strAlias , U_FILE_SEP_CHAR ) ;\n # if ( U_FILE_SEP_CHAR != U_FILE_ALT_SEP_CHAR ) {\n char * aPtr = uprv_strrchr ( strAlias , U_FILE_ALT_SEP_CHAR ) ;\n if ( ! rPtr || ( aPtr && ( aPtr > rPtr ) ) ) {\n rPtr = aPtr ;\n }\n }\n # endif if ( ! rPtr ) {\n return l ;\n }\n if ( ( rPtr - strAlias ) >= UPRV_LENGTHOF ( aBuf ) ) {\n fprintf ( stderr , \"## ERR: Path too long [%d chars]: %s\\n\" , ( int ) sizeof ( aBuf ) , strAlias ) ;\n return l ;\n }\n strncpy ( aBuf , strAlias , ( rPtr - strAlias ) ) ;\n aBuf [ rPtr - strAlias ] = 0 ;\n convertToNativePathSeparators ( aBuf ) ;\n if ( ! pkg_listContains ( l , aBuf ) ) {\n return pkg_appendToList ( l , end , uprv_strdup ( aBuf ) ) ;\n }\n else {\n return l ;\n }\n }", "idx": 20761}
{"hash": 6323824267898511453, "project": "debian", "size": 120, "label": 0, "functionSource": "static void fast_cmyk_to_bgr ( fz_context * ctx , fz_pixmap * dst , fz_pixmap * src , fz_colorspace * prf , const fz_default_colorspaces * default_cs , const fz_color_params * color_params , int copy_spots ) {\n unsigned char * s = src -> samples ;\n unsigned char * d = dst -> samples ;\n size_t w = src -> w ;\n int h = src -> h ;\n int sn = src -> n ;\n int ss = src -> s ;\n int sa = src -> alpha ;\n int dn = dst -> n ;\n int ds = dst -> s ;\n int da = dst -> alpha ;\n ptrdiff_t d_line_inc = dst -> stride - w * dn ;\n ptrdiff_t s_line_inc = src -> stride - w * sn ;\n unsigned int C , M , Y , K ;\n unsigned char r , g , b ;\n if ( ( copy_spots && ss != ds ) || ( ! da && sa ) ) {\n assert ( \"This should never happen\" == NULL ) ;\n fz_throw ( ctx , FZ_ERROR_GENERIC , \"Cannot convert between incompatible pixmaps\" ) ;\n }\n if ( ( int ) w < 0 || h < 0 ) return ;\n C = 0 ;\n M = 0 ;\n Y = 0 ;\n K = 0 ;\n r = 255 ;\n g = 255 ;\n b = 255 ;\n if ( d_line_inc == 0 && s_line_inc == 0 ) {\n w *= h ;\n h = 1 ;\n }\n if ( ss == 0 && ds == 0 ) {\n if ( da ) {\n if ( sa ) {\n while ( h -- ) {\n size_t ww = w ;\n while ( ww -- ) {\n cached_cmyk_conv ( & r , & g , & b , & C , & M , & Y , & K , s [ 0 ] , s [ 1 ] , s [ 2 ] , s [ 3 ] ) ;\n d [ 0 ] = b ;\n d [ 1 ] = g ;\n d [ 2 ] = r ;\n d [ 3 ] = s [ 4 ] ;\n s += 5 ;\n d += 4 ;\n }\n d += d_line_inc ;\n s += s_line_inc ;\n }\n }\n else {\n while ( h -- ) {\n size_t ww = w ;\n while ( ww -- ) {\n cached_cmyk_conv ( & r , & g , & b , & C , & M , & Y , & K , s [ 0 ] , s [ 1 ] , s [ 2 ] , s [ 3 ] ) ;\n d [ 0 ] = b ;\n d [ 1 ] = g ;\n d [ 2 ] = r ;\n d [ 3 ] = 255 ;\n s += 4 ;\n d += 4 ;\n }\n d += d_line_inc ;\n s += s_line_inc ;\n }\n }\n }\n else {\n assert ( src -> alpha == 0 ) ;\n while ( h -- ) {\n size_t ww = w ;\n while ( ww -- ) {\n cached_cmyk_conv ( & r , & g , & b , & C , & M , & Y , & K , s [ 0 ] , s [ 1 ] , s [ 2 ] , s [ 3 ] ) ;\n d [ 0 ] = b ;\n d [ 1 ] = g ;\n d [ 2 ] = r ;\n s += 4 ;\n d += 3 ;\n }\n d += d_line_inc ;\n s += s_line_inc ;\n }\n }\n }\n else if ( copy_spots ) {\n while ( h -- ) {\n int i ;\n size_t ww = w ;\n while ( ww -- ) {\n cached_cmyk_conv ( & r , & g , & b , & C , & M , & Y , & K , s [ 0 ] , s [ 1 ] , s [ 2 ] , s [ 3 ] ) ;\n d [ 0 ] = b ;\n d [ 1 ] = g ;\n d [ 2 ] = r ;\n s += 4 ;\n d += 3 ;\n for ( i = ss ;\n i > 0 ;\n i -- ) * d ++ = * s ++ ;\n if ( da ) * d ++ = sa ? * s ++ : 255 ;\n }\n d += d_line_inc ;\n s += s_line_inc ;\n }\n }\n else {\n while ( h -- ) {\n size_t ww = w ;\n while ( ww -- ) {\n cached_cmyk_conv ( & r , & g , & b , & C , & M , & Y , & K , s [ 0 ] , s [ 1 ] , s [ 2 ] , s [ 3 ] ) ;\n d [ 0 ] = b ;\n d [ 1 ] = g ;\n d [ 2 ] = r ;\n s += sn ;\n d += dn ;\n if ( da ) d [ - 1 ] = sa ? s [ - 1 ] : 255 ;\n }\n d += d_line_inc ;\n s += s_line_inc ;\n }\n }\n }", "idx": 20762}
{"hash": -3819889754140204145, "project": "debian", "size": 22, "label": 0, "functionSource": "bool x509_parse_generalNames ( chunk_t blob , int level0 , bool implicit , linked_list_t * list ) {\n asn1_parser_t * parser ;\n chunk_t object ;\n identification_t * gn ;\n int objectID ;\n bool success = FALSE ;\n parser = asn1_parser_create ( generalNamesObjects , blob ) ;\n parser -> set_top_level ( parser , level0 ) ;\n parser -> set_flags ( parser , implicit , FALSE ) ;\n while ( parser -> iterate ( parser , & objectID , & object ) ) {\n if ( objectID == GENERAL_NAMES_GN ) {\n gn = parse_generalName ( object , parser -> get_level ( parser ) + 1 ) ;\n if ( ! gn ) {\n goto end ;\n }\n list -> insert_last ( list , ( void * ) gn ) ;\n }\n }\n success = parser -> success ( parser ) ;\n end : parser -> destroy ( parser ) ;\n return success ;\n }", "idx": 20763}
{"hash": -1315695702746584250, "project": "debian", "size": 7, "label": 0, "functionSource": "int proto_get_id_by_filter_name ( const gchar * filter_name ) {\n const protocol_t * protocol = NULL ;\n DISSECTOR_ASSERT_HINT ( filter_name , \"No filter name present\" ) ;\n protocol = ( const protocol_t * ) g_hash_table_lookup ( proto_filter_names , filter_name ) ;\n if ( protocol == NULL ) return - 1 ;\n return protocol -> proto_id ;\n }", "idx": 20764}
{"hash": 6249489553242542670, "project": "debian", "size": 11, "label": 0, "functionSource": "void * concat_gen_fifos ( void * first , void * second ) {\n gen_fifo * pf1 ;\n gen_fifo * pf2 ;\n pf1 = first ;\n pf2 = second ;\n if ( NULL == pf1 ) return pf2 ;\n else if ( NULL == pf2 ) return pf1 ;\n CONCAT_FIFO ( * pf1 , * pf2 , link ) ;\n free ( pf2 ) ;\n return pf1 ;\n }", "idx": 20765}
{"hash": 5829728328403223446, "project": "chrome", "size": 108, "label": 1, "functionSource": "static void temporal_filter_iterate_c ( VP9_COMP * cpi , YV12_BUFFER_CONFIG * * frames , int frame_count , int alt_ref_index , int strength , struct scale_factors * scale ) {\n int byte ;\n int frame ;\n int mb_col , mb_row ;\n unsigned int filter_weight ;\n int mb_cols = cpi -> common . mb_cols ;\n int mb_rows = cpi -> common . mb_rows ;\n int mb_y_offset = 0 ;\n int mb_uv_offset = 0 ;\n DECLARE_ALIGNED_ARRAY ( 16 , unsigned int , accumulator , 16 * 16 * 3 ) ;\n DECLARE_ALIGNED_ARRAY ( 16 , uint16_t , count , 16 * 16 * 3 ) ;\n MACROBLOCKD * mbd = & cpi -> mb . e_mbd ;\n YV12_BUFFER_CONFIG * f = frames [ alt_ref_index ] ;\n uint8_t * dst1 , * dst2 ;\n DECLARE_ALIGNED_ARRAY ( 16 , uint8_t , predictor , 16 * 16 * 3 ) ;\n const int mb_uv_height = 16 >> mbd -> plane [ 1 ] . subsampling_y ;\n const int mb_uv_width = 16 >> mbd -> plane [ 1 ] . subsampling_x ;\n uint8_t * input_buffer [ MAX_MB_PLANE ] ;\n int i ;\n for ( i = 0 ;\n i < MAX_MB_PLANE ;\n i ++ ) input_buffer [ i ] = mbd -> plane [ i ] . pre [ 0 ] . buf ;\n for ( mb_row = 0 ;\n mb_row < mb_rows ;\n mb_row ++ ) {\n cpi -> mb . mv_row_min = - ( ( mb_row * 16 ) + ( 17 - 2 * VP9_INTERP_EXTEND ) ) ;\n cpi -> mb . mv_row_max = ( ( cpi -> common . mb_rows - 1 - mb_row ) * 16 ) + ( 17 - 2 * VP9_INTERP_EXTEND ) ;\n for ( mb_col = 0 ;\n mb_col < mb_cols ;\n mb_col ++ ) {\n int i , j , k ;\n int stride ;\n vpx_memset ( accumulator , 0 , 16 * 16 * 3 * sizeof ( accumulator [ 0 ] ) ) ;\n vpx_memset ( count , 0 , 16 * 16 * 3 * sizeof ( count [ 0 ] ) ) ;\n cpi -> mb . mv_col_min = - ( ( mb_col * 16 ) + ( 17 - 2 * VP9_INTERP_EXTEND ) ) ;\n cpi -> mb . mv_col_max = ( ( cpi -> common . mb_cols - 1 - mb_col ) * 16 ) + ( 17 - 2 * VP9_INTERP_EXTEND ) ;\n for ( frame = 0 ;\n frame < frame_count ;\n frame ++ ) {\n const int thresh_low = 10000 ;\n const int thresh_high = 20000 ;\n if ( frames [ frame ] == NULL ) continue ;\n mbd -> mi [ 0 ] -> bmi [ 0 ] . as_mv [ 0 ] . as_mv . row = 0 ;\n mbd -> mi [ 0 ] -> bmi [ 0 ] . as_mv [ 0 ] . as_mv . col = 0 ;\n if ( frame == alt_ref_index ) {\n filter_weight = 2 ;\n }\n else {\n int err = temporal_filter_find_matching_mb_c ( cpi , frames [ alt_ref_index ] -> y_buffer + mb_y_offset , frames [ frame ] -> y_buffer + mb_y_offset , frames [ frame ] -> y_stride ) ;\n filter_weight = err < thresh_low ? 2 : err < thresh_high ? 1 : 0 ;\n }\n if ( filter_weight != 0 ) {\n temporal_filter_predictors_mb_c ( mbd , frames [ frame ] -> y_buffer + mb_y_offset , frames [ frame ] -> u_buffer + mb_uv_offset , frames [ frame ] -> v_buffer + mb_uv_offset , frames [ frame ] -> y_stride , mb_uv_width , mb_uv_height , mbd -> mi [ 0 ] -> bmi [ 0 ] . as_mv [ 0 ] . as_mv . row , mbd -> mi [ 0 ] -> bmi [ 0 ] . as_mv [ 0 ] . as_mv . col , predictor , scale , mb_col * 16 , mb_row * 16 ) ;\n vp9_temporal_filter_apply ( f -> y_buffer + mb_y_offset , f -> y_stride , predictor , 16 , 16 , strength , filter_weight , accumulator , count ) ;\n vp9_temporal_filter_apply ( f -> u_buffer + mb_uv_offset , f -> uv_stride , predictor + 256 , mb_uv_width , mb_uv_height , strength , filter_weight , accumulator + 256 , count + 256 ) ;\n vp9_temporal_filter_apply ( f -> v_buffer + mb_uv_offset , f -> uv_stride , predictor + 512 , mb_uv_width , mb_uv_height , strength , filter_weight , accumulator + 512 , count + 512 ) ;\n }\n }\n dst1 = cpi -> alt_ref_buffer . y_buffer ;\n stride = cpi -> alt_ref_buffer . y_stride ;\n byte = mb_y_offset ;\n for ( i = 0 , k = 0 ;\n i < 16 ;\n i ++ ) {\n for ( j = 0 ;\n j < 16 ;\n j ++ , k ++ ) {\n unsigned int pval = accumulator [ k ] + ( count [ k ] >> 1 ) ;\n pval *= fixed_divide [ count [ k ] ] ;\n pval >>= 19 ;\n dst1 [ byte ] = ( uint8_t ) pval ;\n byte ++ ;\n }\n byte += stride - 16 ;\n }\n dst1 = cpi -> alt_ref_buffer . u_buffer ;\n dst2 = cpi -> alt_ref_buffer . v_buffer ;\n stride = cpi -> alt_ref_buffer . uv_stride ;\n byte = mb_uv_offset ;\n for ( i = 0 , k = 256 ;\n i < mb_uv_height ;\n i ++ ) {\n for ( j = 0 ;\n j < mb_uv_width ;\n j ++ , k ++ ) {\n int m = k + 256 ;\n unsigned int pval = accumulator [ k ] + ( count [ k ] >> 1 ) ;\n pval *= fixed_divide [ count [ k ] ] ;\n pval >>= 19 ;\n dst1 [ byte ] = ( uint8_t ) pval ;\n pval = accumulator [ m ] + ( count [ m ] >> 1 ) ;\n pval *= fixed_divide [ count [ m ] ] ;\n pval >>= 19 ;\n dst2 [ byte ] = ( uint8_t ) pval ;\n byte ++ ;\n }\n byte += stride - mb_uv_width ;\n }\n mb_y_offset += 16 ;\n mb_uv_offset += mb_uv_width ;\n }\n mb_y_offset += 16 * ( f -> y_stride - mb_cols ) ;\n mb_uv_offset += mb_uv_height * f -> uv_stride - mb_uv_width * mb_cols ;\n }\n for ( i = 0 ;\n i < MAX_MB_PLANE ;\n i ++ ) mbd -> plane [ i ] . pre [ 0 ] . buf = input_buffer [ i ] ;\n }", "idx": 20766}
{"hash": -5706788925640467782, "project": "chrome", "size": 12, "label": 0, "functionSource": "static void duplicate_mode_info_in_sb ( VP9_COMMON * cm , MACROBLOCKD * xd , int mi_row , int mi_col , BLOCK_SIZE bsize ) {\n const int block_width = num_8x8_blocks_wide_lookup [ bsize ] ;\n const int block_height = num_8x8_blocks_high_lookup [ bsize ] ;\n int i , j ;\n for ( j = 0 ;\n j < block_height ;\n ++ j ) for ( i = 0 ;\n i < block_width ;\n ++ i ) {\n if ( mi_row + j < cm -> mi_rows && mi_col + i < cm -> mi_cols ) xd -> mi [ j * xd -> mi_stride + i ] . src_mi = & xd -> mi [ 0 ] ;\n }\n }", "idx": 20767}
{"hash": -2423144171479606949, "project": "debian", "size": 7, "label": 0, "functionSource": "static void pdf_run_w ( fz_context * ctx , pdf_processor * proc , float linewidth ) {\n pdf_run_processor * pr = ( pdf_run_processor * ) proc ;\n pdf_gstate * gstate = pdf_flush_text ( ctx , pr ) ;\n pr -> dev -> flags &= ~ FZ_DEVFLAG_LINEWIDTH_UNDEFINED ;\n gstate -> stroke_state = fz_unshare_stroke_state ( ctx , gstate -> stroke_state ) ;\n gstate -> stroke_state -> linewidth = linewidth ;\n }", "idx": 20768}
{"hash": -7131177824150194183, "project": "debian", "size": 36, "label": 0, "functionSource": "static int binkb_read_bundle ( BinkContext * c , GetBitContext * gb , int bundle_num ) {\n const int bits = binkb_bundle_sizes [ bundle_num ] ;\n const int mask = 1 << ( bits - 1 ) ;\n const int issigned = binkb_bundle_signed [ bundle_num ] ;\n Bundle * b = & c -> bundle [ bundle_num ] ;\n int i , len ;\n CHECK_READ_VAL ( gb , b , len ) ;\n if ( b -> data_end - b -> cur_dec < len * ( 1 + ( bits > 8 ) ) ) return AVERROR_INVALIDDATA ;\n if ( bits <= 8 ) {\n if ( ! issigned ) {\n for ( i = 0 ;\n i < len ;\n i ++ ) * b -> cur_dec ++ = get_bits ( gb , bits ) ;\n }\n else {\n for ( i = 0 ;\n i < len ;\n i ++ ) * b -> cur_dec ++ = get_bits ( gb , bits ) - mask ;\n }\n }\n else {\n int16_t * dst = ( int16_t * ) b -> cur_dec ;\n if ( ! issigned ) {\n for ( i = 0 ;\n i < len ;\n i ++ ) * dst ++ = get_bits ( gb , bits ) ;\n }\n else {\n for ( i = 0 ;\n i < len ;\n i ++ ) * dst ++ = get_bits ( gb , bits ) - mask ;\n }\n b -> cur_dec = ( uint8_t * ) dst ;\n }\n return 0 ;\n }", "idx": 20769}
{"hash": 5976900907644301719, "project": "debian", "size": 71, "label": 0, "functionSource": "void proto_register_applemidi ( void ) {\n static hf_register_info hf [ ] = {\n {\n & hf_applemidi_signature , {\n \"Signature\" , \"applemidi.signature\" , FT_UINT16 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_applemidi_command , {\n \"Command\" , \"applemidi.command\" , FT_UINT16 , BASE_HEX , VALS ( applemidi_commands ) , 0x0 , NULL , HFILL }\n }\n , {\n & hf_applemidi_protocol_version , {\n \"Protocol Version\" , \"applemidi.protocol_version\" , FT_UINT32 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_applemidi_token , {\n \"Initiator Token\" , \"applemidi.initiator_token\" , FT_UINT32 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_applemidi_ssrc , {\n \"Sender SSRC\" , \"applemidi.sender_ssrc\" , FT_UINT32 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_applemidi_name , {\n \"Name\" , \"applemidi.name\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_applemidi_count , {\n \"Count\" , \"applemidi.count\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_applemidi_padding , {\n \"Padding\" , \"applemidi.padding\" , FT_UINT24 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_applemidi_timestamp1 , {\n \"Timestamp 1\" , \"applemidi.timestamp1\" , FT_UINT64 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_applemidi_timestamp2 , {\n \"Timestamp 2\" , \"applemidi.timestamp2\" , FT_UINT64 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_applemidi_timestamp3 , {\n \"Timestamp 3\" , \"applemidi.timestamp3\" , FT_UINT64 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_applemidi_sequence_num , {\n \"Sequence Number\" , \"applemidi.sequence_number\" , FT_UINT32 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_applemidi_rtp_sequence_num , {\n \"RTP Sequence Number\" , \"applemidi.rtp_sequence_number\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_applemidi_rtp_bitrate_limit , {\n \"Bitrate limit\" , \"applemidi.bitrate_limit\" , FT_UINT32 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_applemidi_unknown_data , {\n \"Unknown Data\" , \"applemidi.unknown_data\" , FT_BYTES , BASE_NONE , NULL , 0x00 , NULL , HFILL }\n }\n , }\n ;\n static gint * ett [ ] = {\n & ett_applemidi , & ett_applemidi_seq_num }\n ;\n proto_applemidi = proto_register_protocol ( APPLEMIDI_DISSECTOR_NAME , APPLEMIDI_DISSECTOR_SHORTNAME , APPLEMIDI_DISSECTOR_ABBREVIATION ) ;\n proto_register_field_array ( proto_applemidi , hf , array_length ( hf ) ) ;\n proto_register_subtree_array ( ett , array_length ( ett ) ) ;\n }", "idx": 20770}
{"hash": 9046191708840218774, "project": "debian", "size": 37, "label": 0, "functionSource": "static int tipc_nl_compat_link_stat_dump ( struct tipc_nl_compat_msg * msg , struct nlattr * * attrs ) {\n char * name ;\n struct nlattr * link [ TIPC_NLA_LINK_MAX + 1 ] ;\n struct nlattr * prop [ TIPC_NLA_PROP_MAX + 1 ] ;\n struct nlattr * stats [ TIPC_NLA_STATS_MAX + 1 ] ;\n int err ;\n if ( ! attrs [ TIPC_NLA_LINK ] ) return - EINVAL ;\n err = nla_parse_nested ( link , TIPC_NLA_LINK_MAX , attrs [ TIPC_NLA_LINK ] , NULL ) ;\n if ( err ) return err ;\n if ( ! link [ TIPC_NLA_LINK_PROP ] ) return - EINVAL ;\n err = nla_parse_nested ( prop , TIPC_NLA_PROP_MAX , link [ TIPC_NLA_LINK_PROP ] , NULL ) ;\n if ( err ) return err ;\n if ( ! link [ TIPC_NLA_LINK_STATS ] ) return - EINVAL ;\n err = nla_parse_nested ( stats , TIPC_NLA_STATS_MAX , link [ TIPC_NLA_LINK_STATS ] , NULL ) ;\n if ( err ) return err ;\n name = ( char * ) TLV_DATA ( msg -> req ) ;\n if ( strcmp ( name , nla_data ( link [ TIPC_NLA_LINK_NAME ] ) ) != 0 ) return 0 ;\n tipc_tlv_sprintf ( msg -> rep , \"\\nLink <%s>\\n\" , nla_data ( link [ TIPC_NLA_LINK_NAME ] ) ) ;\n if ( link [ TIPC_NLA_LINK_BROADCAST ] ) {\n __fill_bc_link_stat ( msg , prop , stats ) ;\n return 0 ;\n }\n if ( link [ TIPC_NLA_LINK_ACTIVE ] ) tipc_tlv_sprintf ( msg -> rep , \" ACTIVE\" ) ;\n else if ( link [ TIPC_NLA_LINK_UP ] ) tipc_tlv_sprintf ( msg -> rep , \" STANDBY\" ) ;\n else tipc_tlv_sprintf ( msg -> rep , \" DEFUNCT\" ) ;\n tipc_tlv_sprintf ( msg -> rep , \" MTU:%u Priority:%u\" , nla_get_u32 ( link [ TIPC_NLA_LINK_MTU ] ) , nla_get_u32 ( prop [ TIPC_NLA_PROP_PRIO ] ) ) ;\n tipc_tlv_sprintf ( msg -> rep , \" Tolerance:%u ms Window:%u packets\\n\" , nla_get_u32 ( prop [ TIPC_NLA_PROP_TOL ] ) , nla_get_u32 ( prop [ TIPC_NLA_PROP_WIN ] ) ) ;\n tipc_tlv_sprintf ( msg -> rep , \" RX packets:%u fragments:%u/%u bundles:%u/%u\\n\" , nla_get_u32 ( link [ TIPC_NLA_LINK_RX ] ) - nla_get_u32 ( stats [ TIPC_NLA_STATS_RX_INFO ] ) , nla_get_u32 ( stats [ TIPC_NLA_STATS_RX_FRAGMENTS ] ) , nla_get_u32 ( stats [ TIPC_NLA_STATS_RX_FRAGMENTED ] ) , nla_get_u32 ( stats [ TIPC_NLA_STATS_RX_BUNDLES ] ) , nla_get_u32 ( stats [ TIPC_NLA_STATS_RX_BUNDLED ] ) ) ;\n tipc_tlv_sprintf ( msg -> rep , \" TX packets:%u fragments:%u/%u bundles:%u/%u\\n\" , nla_get_u32 ( link [ TIPC_NLA_LINK_TX ] ) - nla_get_u32 ( stats [ TIPC_NLA_STATS_TX_INFO ] ) , nla_get_u32 ( stats [ TIPC_NLA_STATS_TX_FRAGMENTS ] ) , nla_get_u32 ( stats [ TIPC_NLA_STATS_TX_FRAGMENTED ] ) , nla_get_u32 ( stats [ TIPC_NLA_STATS_TX_BUNDLES ] ) , nla_get_u32 ( stats [ TIPC_NLA_STATS_TX_BUNDLED ] ) ) ;\n tipc_tlv_sprintf ( msg -> rep , \" TX profile sample:%u packets average:%u octets\\n\" , nla_get_u32 ( stats [ TIPC_NLA_STATS_MSG_LEN_CNT ] ) , nla_get_u32 ( stats [ TIPC_NLA_STATS_MSG_LEN_TOT ] ) / nla_get_u32 ( stats [ TIPC_NLA_STATS_MSG_PROF_TOT ] ) ) ;\n tipc_tlv_sprintf ( msg -> rep , \" 0-64:%u%% -256:%u%% -1024:%u%% -4096:%u%% \" , perc ( nla_get_u32 ( stats [ TIPC_NLA_STATS_MSG_LEN_P0 ] ) , nla_get_u32 ( stats [ TIPC_NLA_STATS_MSG_PROF_TOT ] ) ) , perc ( nla_get_u32 ( stats [ TIPC_NLA_STATS_MSG_LEN_P1 ] ) , nla_get_u32 ( stats [ TIPC_NLA_STATS_MSG_PROF_TOT ] ) ) , perc ( nla_get_u32 ( stats [ TIPC_NLA_STATS_MSG_LEN_P2 ] ) , nla_get_u32 ( stats [ TIPC_NLA_STATS_MSG_PROF_TOT ] ) ) , perc ( nla_get_u32 ( stats [ TIPC_NLA_STATS_MSG_LEN_P3 ] ) , nla_get_u32 ( stats [ TIPC_NLA_STATS_MSG_PROF_TOT ] ) ) ) ;\n tipc_tlv_sprintf ( msg -> rep , \"-16384:%u%% -32768:%u%% -66000:%u%%\\n\" , perc ( nla_get_u32 ( stats [ TIPC_NLA_STATS_MSG_LEN_P4 ] ) , nla_get_u32 ( stats [ TIPC_NLA_STATS_MSG_PROF_TOT ] ) ) , perc ( nla_get_u32 ( stats [ TIPC_NLA_STATS_MSG_LEN_P5 ] ) , nla_get_u32 ( stats [ TIPC_NLA_STATS_MSG_PROF_TOT ] ) ) , perc ( nla_get_u32 ( stats [ TIPC_NLA_STATS_MSG_LEN_P6 ] ) , nla_get_u32 ( stats [ TIPC_NLA_STATS_MSG_PROF_TOT ] ) ) ) ;\n tipc_tlv_sprintf ( msg -> rep , \" RX states:%u probes:%u naks:%u defs:%u dups:%u\\n\" , nla_get_u32 ( stats [ TIPC_NLA_STATS_RX_STATES ] ) , nla_get_u32 ( stats [ TIPC_NLA_STATS_RX_PROBES ] ) , nla_get_u32 ( stats [ TIPC_NLA_STATS_RX_NACKS ] ) , nla_get_u32 ( stats [ TIPC_NLA_STATS_RX_DEFERRED ] ) , nla_get_u32 ( stats [ TIPC_NLA_STATS_DUPLICATES ] ) ) ;\n tipc_tlv_sprintf ( msg -> rep , \" TX states:%u probes:%u naks:%u acks:%u dups:%u\\n\" , nla_get_u32 ( stats [ TIPC_NLA_STATS_TX_STATES ] ) , nla_get_u32 ( stats [ TIPC_NLA_STATS_TX_PROBES ] ) , nla_get_u32 ( stats [ TIPC_NLA_STATS_TX_NACKS ] ) , nla_get_u32 ( stats [ TIPC_NLA_STATS_TX_ACKS ] ) , nla_get_u32 ( stats [ TIPC_NLA_STATS_RETRANSMITTED ] ) ) ;\n tipc_tlv_sprintf ( msg -> rep , \" Congestion link:%u Send queue max:%u avg:%u\" , nla_get_u32 ( stats [ TIPC_NLA_STATS_LINK_CONGS ] ) , nla_get_u32 ( stats [ TIPC_NLA_STATS_MAX_QUEUE ] ) , nla_get_u32 ( stats [ TIPC_NLA_STATS_AVG_QUEUE ] ) ) ;\n return 0 ;\n }", "idx": 20771}
{"hash": 6667142528452941476, "project": "debian", "size": 86, "label": 1, "functionSource": "static uint dump_events_for_db ( char * db ) {\n char query_buff [ QUERY_LENGTH ] ;\n char db_name_buff [ NAME_LEN * 2 + 3 ] , name_buff [ NAME_LEN * 2 + 3 ] ;\n char * event_name ;\n char delimiter [ QUERY_LENGTH ] ;\n FILE * sql_file = md_result_file ;\n MYSQL_RES * event_res , * event_list_res ;\n MYSQL_ROW row , event_list_row ;\n char db_cl_name [ MY_CS_NAME_SIZE ] ;\n int db_cl_altered = FALSE ;\n DBUG_ENTER ( \"dump_events_for_db\" ) ;\n DBUG_PRINT ( \"enter\" , ( \"db: '%s'\" , db ) ) ;\n mysql_real_escape_string ( mysql , db_name_buff , db , ( ulong ) strlen ( db ) ) ;\n print_comment ( sql_file , 0 , \"\\n--\\n-- Dumping events for database '%s'\\n--\\n\" , db ) ;\n if ( lock_tables ) mysql_query ( mysql , \"LOCK TABLES mysql.event READ\" ) ;\n if ( mysql_query_with_error_report ( mysql , & event_list_res , \"show events\" ) ) DBUG_RETURN ( 0 ) ;\n strcpy ( delimiter , \";\n\" ) ;\n if ( mysql_num_rows ( event_list_res ) > 0 ) {\n if ( opt_xml ) fputs ( \"\\t<events>\\n\" , sql_file ) ;\n else {\n fprintf ( sql_file , \"/*!50106 SET @save_time_zone= @@TIME_ZONE */ ;\n\\n\" ) ;\n if ( fetch_db_collation ( db_name_buff , db_cl_name , sizeof ( db_cl_name ) ) ) DBUG_RETURN ( 1 ) ;\n }\n if ( switch_character_set_results ( mysql , \"binary\" ) ) DBUG_RETURN ( 1 ) ;\n while ( ( event_list_row = mysql_fetch_row ( event_list_res ) ) != NULL ) {\n event_name = quote_name ( event_list_row [ 1 ] , name_buff , 0 ) ;\n DBUG_PRINT ( \"info\" , ( \"retrieving CREATE EVENT for %s\" , name_buff ) ) ;\n my_snprintf ( query_buff , sizeof ( query_buff ) , \"SHOW CREATE EVENT %s\" , event_name ) ;\n if ( mysql_query_with_error_report ( mysql , & event_res , query_buff ) ) DBUG_RETURN ( 1 ) ;\n while ( ( row = mysql_fetch_row ( event_res ) ) != NULL ) {\n if ( opt_xml ) {\n print_xml_row ( sql_file , \"event\" , event_res , & row , \"Create Event\" ) ;\n continue ;\n }\n if ( strlen ( row [ 3 ] ) != 0 ) {\n char * query_str ;\n if ( opt_drop ) fprintf ( sql_file , \"/*!50106 DROP EVENT IF EXISTS %s */%s\\n\" , event_name , delimiter ) ;\n if ( create_delimiter ( row [ 3 ] , delimiter , sizeof ( delimiter ) ) == NULL ) {\n fprintf ( stderr , \"%s: Warning: Can't create delimiter for event '%s'\\n\" , my_progname_short , event_name ) ;\n DBUG_RETURN ( 1 ) ;\n }\n fprintf ( sql_file , \"DELIMITER %s\\n\" , delimiter ) ;\n if ( mysql_num_fields ( event_res ) >= 7 ) {\n if ( switch_db_collation ( sql_file , db_name_buff , delimiter , db_cl_name , row [ 6 ] , & db_cl_altered ) ) {\n DBUG_RETURN ( 1 ) ;\n }\n switch_cs_variables ( sql_file , delimiter , row [ 4 ] , row [ 4 ] , row [ 5 ] ) ;\n }\n else {\n fprintf ( sql_file , \"--\\n\" \"-- WARNING: old server version. \" \"The following dump may be incomplete.\\n\" \"--\\n\" ) ;\n }\n switch_sql_mode ( sql_file , delimiter , row [ 1 ] ) ;\n switch_time_zone ( sql_file , delimiter , row [ 2 ] ) ;\n query_str = cover_definer_clause ( row [ 3 ] , strlen ( row [ 3 ] ) , C_STRING_WITH_LEN ( \"50117\" ) , C_STRING_WITH_LEN ( \"50106\" ) , C_STRING_WITH_LEN ( \" EVENT\" ) ) ;\n fprintf ( sql_file , \"/*!50106 %s */ %s\\n\" , ( const char * ) ( query_str != NULL ? query_str : row [ 3 ] ) , ( const char * ) delimiter ) ;\n my_free ( query_str ) ;\n restore_time_zone ( sql_file , delimiter ) ;\n restore_sql_mode ( sql_file , delimiter ) ;\n if ( mysql_num_fields ( event_res ) >= 7 ) {\n restore_cs_variables ( sql_file , delimiter ) ;\n if ( db_cl_altered ) {\n if ( restore_db_collation ( sql_file , db_name_buff , delimiter , db_cl_name ) ) DBUG_RETURN ( 1 ) ;\n }\n }\n }\n }\n mysql_free_result ( event_res ) ;\n }\n if ( opt_xml ) {\n fputs ( \"\\t</events>\\n\" , sql_file ) ;\n check_io ( sql_file ) ;\n }\n else {\n fprintf ( sql_file , \"DELIMITER ;\n\\n\" ) ;\n fprintf ( sql_file , \"/*!50106 SET TIME_ZONE= @save_time_zone */ ;\n\\n\" ) ;\n }\n if ( switch_character_set_results ( mysql , default_charset ) ) DBUG_RETURN ( 1 ) ;\n }\n mysql_free_result ( event_list_res ) ;\n if ( lock_tables ) ( void ) mysql_query_with_error_report ( mysql , 0 , \"UNLOCK TABLES\" ) ;\n DBUG_RETURN ( 0 ) ;\n }", "idx": 20772}
{"hash": -8028756826159773630, "project": "debian", "size": 8, "label": 0, "functionSource": "void CloseArchive ( Archive * AHX ) {\n int res = 0 ;\n ArchiveHandle * AH = ( ArchiveHandle * ) AHX ;\n ( * AH -> ClosePtr ) ( AH ) ;\n if ( AH -> gzOut ) res = GZCLOSE ( AH -> OF ) ;\n else if ( AH -> OF != stdout ) res = fclose ( AH -> OF ) ;\n if ( res != 0 ) exit_horribly ( modulename , \"could not close output file: %s\\n\" , strerror ( errno ) ) ;\n }", "idx": 20773}
{"hash": -1983921383858884161, "project": "debian", "size": 3, "label": 0, "functionSource": "static int ipvideo_decode_block_opcode_0x1 ( IpvideoContext * s , AVFrame * frame ) {\n return copy_from ( s , s -> second_last_frame , frame , 0 , 0 ) ;\n }", "idx": 20774}
{"hash": 7749168290238234888, "project": "debian", "size": 10, "label": 0, "functionSource": "static int do_fail ( xd3_stream * stream , const char * buf ) {\n int ret ;\n ret = system ( buf ) ;\n if ( ! WIFEXITED ( ret ) || WEXITSTATUS ( ret ) != 1 ) {\n stream -> msg = \"command should have not succeeded\" ;\n XPR ( NT \"command was %s\\n\" , buf ) ;\n return XD3_INTERNAL ;\n }\n return 0 ;\n }", "idx": 20775}
{"hash": 8461782184979846246, "project": "chrome", "size": 7, "label": 1, "functionSource": "TEST_F ( ProtocolHandlerRegistryTest , TestIsEquivalentRegistered ) {\n ProtocolHandler ph1 = CreateProtocolHandler ( \"test\" , GURL ( \"http://test/%s\" ) , \"test1\" ) ;\n ProtocolHandler ph2 = CreateProtocolHandler ( \"test\" , GURL ( \"http://test/%s\" ) , \"test2\" ) ;\n registry ( ) -> OnAcceptRegisterProtocolHandler ( ph1 ) ;\n ASSERT_TRUE ( registry ( ) -> IsRegistered ( ph1 ) ) ;\n ASSERT_TRUE ( registry ( ) -> HasRegisteredEquivalent ( ph2 ) ) ;\n }", "idx": 20776}
{"hash": -6580451576689962916, "project": "debian", "size": 17, "label": 0, "functionSource": "static const wbxml_decoding * wv_csp_discriminator ( tvbuff_t * tvb , guint32 offset ) {\n guint32 magic_1 = tvb_get_ntohl ( tvb , offset + 0 ) ;\n guint16 magic_2 = tvb_get_ntohs ( tvb , offset + 4 ) ;\n if ( magic_1 == 0xFE050331 && magic_2 == 0x2e30 ) {\n return & decode_wv_cspc_10 ;\n }\n else if ( magic_1 == 0xC9050331 && magic_2 == 0x2e31 ) {\n return & decode_wv_cspc_11 ;\n }\n else if ( magic_1 == 0xC9080331 && magic_2 == 0x2e32 ) {\n return & decode_wv_cspc_12 ;\n }\n else if ( magic_1 == 0xC90B0331 && magic_2 == 0x2E33 ) {\n return & decode_wv_cspc_13 ;\n }\n return & decode_wv_cspc_12 ;\n }", "idx": 20777}
{"hash": -6359684484462176044, "project": "debian", "size": 66, "label": 1, "functionSource": "EC_KEY * d2i_ECPrivateKey ( EC_KEY * * a , const unsigned char * * in , long len ) {\n int ok = 0 ;\n EC_KEY * ret = NULL ;\n EC_PRIVATEKEY * priv_key = NULL ;\n if ( ( priv_key = EC_PRIVATEKEY_new ( ) ) == NULL ) {\n ECerr ( EC_F_D2I_ECPRIVATEKEY , ERR_R_MALLOC_FAILURE ) ;\n return NULL ;\n }\n if ( ( priv_key = d2i_EC_PRIVATEKEY ( & priv_key , in , len ) ) == NULL ) {\n ECerr ( EC_F_D2I_ECPRIVATEKEY , ERR_R_EC_LIB ) ;\n EC_PRIVATEKEY_free ( priv_key ) ;\n return NULL ;\n }\n if ( a == NULL || * a == NULL ) {\n if ( ( ret = EC_KEY_new ( ) ) == NULL ) {\n ECerr ( EC_F_D2I_ECPRIVATEKEY , ERR_R_MALLOC_FAILURE ) ;\n goto err ;\n }\n if ( a ) * a = ret ;\n }\n else ret = * a ;\n if ( priv_key -> parameters ) {\n if ( ret -> group ) EC_GROUP_clear_free ( ret -> group ) ;\n ret -> group = ec_asn1_pkparameters2group ( priv_key -> parameters ) ;\n }\n if ( ret -> group == NULL ) {\n ECerr ( EC_F_D2I_ECPRIVATEKEY , ERR_R_EC_LIB ) ;\n goto err ;\n }\n ret -> version = priv_key -> version ;\n if ( priv_key -> privateKey ) {\n ret -> priv_key = BN_bin2bn ( M_ASN1_STRING_data ( priv_key -> privateKey ) , M_ASN1_STRING_length ( priv_key -> privateKey ) , ret -> priv_key ) ;\n if ( ret -> priv_key == NULL ) {\n ECerr ( EC_F_D2I_ECPRIVATEKEY , ERR_R_BN_LIB ) ;\n goto err ;\n }\n }\n else {\n ECerr ( EC_F_D2I_ECPRIVATEKEY , EC_R_MISSING_PRIVATE_KEY ) ;\n goto err ;\n }\n if ( priv_key -> publicKey ) {\n const unsigned char * pub_oct ;\n size_t pub_oct_len ;\n if ( ret -> pub_key ) EC_POINT_clear_free ( ret -> pub_key ) ;\n ret -> pub_key = EC_POINT_new ( ret -> group ) ;\n if ( ret -> pub_key == NULL ) {\n ECerr ( EC_F_D2I_ECPRIVATEKEY , ERR_R_EC_LIB ) ;\n goto err ;\n }\n pub_oct = M_ASN1_STRING_data ( priv_key -> publicKey ) ;\n pub_oct_len = M_ASN1_STRING_length ( priv_key -> publicKey ) ;\n ret -> conv_form = ( point_conversion_form_t ) ( pub_oct [ 0 ] & ~ 0x01 ) ;\n if ( ! EC_POINT_oct2point ( ret -> group , ret -> pub_key , pub_oct , pub_oct_len , NULL ) ) {\n ECerr ( EC_F_D2I_ECPRIVATEKEY , ERR_R_EC_LIB ) ;\n goto err ;\n }\n }\n ok = 1 ;\n err : if ( ! ok ) {\n if ( ret ) EC_KEY_free ( ret ) ;\n ret = NULL ;\n }\n if ( priv_key ) EC_PRIVATEKEY_free ( priv_key ) ;\n return ( ret ) ;\n }", "idx": 20778}
{"hash": 1760449185745615462, "project": "debian", "size": 8, "label": 0, "functionSource": "int TSHttpHdrLengthGet ( TSMBuffer bufp , TSMLoc obj ) {\n sdk_assert ( sdk_sanity_check_mbuffer ( bufp ) == TS_SUCCESS ) ;\n sdk_assert ( sdk_sanity_check_http_hdr_handle ( obj ) == TS_SUCCESS ) ;\n HTTPHdr h ;\n SET_HTTP_HDR ( h , bufp , obj ) ;\n ink_assert ( h . m_http -> m_type == HDR_HEAP_OBJ_HTTP_HEADER ) ;\n return h . length_get ( ) ;\n }", "idx": 20779}
{"hash": -6333668321124139371, "project": "debian", "size": 8, "label": 0, "functionSource": "void rtp_dyn_payload_insert ( rtp_dyn_payload_t * rtp_dyn_payload , const guint8 pt , const gchar * encoding_name , const int sample_rate ) {\n if ( rtp_dyn_payload && rtp_dyn_payload -> table ) {\n encoding_name_and_rate_t * encoding_name_and_rate_pt = wmem_new ( wmem_file_scope ( ) , encoding_name_and_rate_t ) ;\n encoding_name_and_rate_pt -> encoding_name = wmem_strdup ( wmem_file_scope ( ) , encoding_name ) ;\n encoding_name_and_rate_pt -> sample_rate = sample_rate ;\n g_hash_table_insert ( rtp_dyn_payload -> table , GUINT_TO_POINTER ( pt ) , encoding_name_and_rate_pt ) ;\n }\n }", "idx": 20780}
{"hash": -2443338381883395438, "project": "debian", "size": 53, "label": 0, "functionSource": "int change_logfile ( const char * fname , int leave_crumbs ) {\n FILE * new_file ;\n const char * log_fname ;\n char * abs_fname ;\n # if ! defined ( SYS_WINNT ) && ! defined ( SYS_VXWORKS ) && ! defined ( VMS ) char curdir [ 512 ] ;\n size_t cd_octets ;\n size_t octets ;\n # endif REQUIRE ( fname != NULL ) ;\n log_fname = fname ;\n if ( syslog_file != NULL && syslog_fname != NULL && == strcmp ( syslog_fname , log_fname ) ) return 0 ;\n if ( 0 == strcmp ( log_fname , \"stderr\" ) ) {\n new_file = stderr ;\n abs_fname = estrdup ( log_fname ) ;\n }\n else if ( 0 == strcmp ( log_fname , \"stdout\" ) ) {\n new_file = stdout ;\n abs_fname = estrdup ( log_fname ) ;\n }\n else {\n if ( syslog_fname != NULL && == strcmp ( log_fname , syslog_fname ) ) log_fname = syslog_abs_fname ;\n # if ! defined ( SYS_WINNT ) && ! defined ( SYS_VXWORKS ) && ! defined ( VMS ) if ( log_fname != syslog_abs_fname && DIR_SEP != log_fname [ 0 ] && != strcmp ( log_fname , \"stderr\" ) && != strcmp ( log_fname , \"stdout\" ) && NULL != getcwd ( curdir , sizeof ( curdir ) ) ) {\n cd_octets = strlen ( curdir ) ;\n if ( cd_octets > 1 && DIR_SEP == curdir [ cd_octets - 1 ] ) cd_octets -- ;\n octets = cd_octets ;\n octets += 1 ;\n octets += strlen ( log_fname ) ;\n octets += 1 ;\n abs_fname = emalloc ( octets ) ;\n snprintf ( abs_fname , octets , \"%.*s%c%s\" , ( int ) cd_octets , curdir , DIR_SEP , log_fname ) ;\n }\n else # endif abs_fname = estrdup ( log_fname ) ;\n TRACE ( 1 , ( \"attempting to open log %s\\n\" , abs_fname ) ) ;\n new_file = fopen ( abs_fname , \"a\" ) ;\n }\n if ( NULL == new_file ) {\n free ( abs_fname ) ;\n return - 1 ;\n }\n if ( leave_crumbs && ( syslogit || log_fname != syslog_abs_fname ) ) msyslog ( LOG_NOTICE , \"switching logging to file %s\" , abs_fname ) ;\n if ( syslog_file != NULL && syslog_file != stderr && syslog_file != stdout && fileno ( syslog_file ) != fileno ( new_file ) ) fclose ( syslog_file ) ;\n syslog_file = new_file ;\n if ( log_fname == syslog_abs_fname ) {\n free ( abs_fname ) ;\n }\n else {\n if ( syslog_abs_fname != NULL && syslog_abs_fname != syslog_fname ) free ( syslog_abs_fname ) ;\n if ( syslog_fname != NULL ) free ( syslog_fname ) ;\n syslog_fname = estrdup ( log_fname ) ;\n syslog_abs_fname = abs_fname ;\n }\n syslogit = FALSE ;\n return 0 ;\n }", "idx": 20781}
{"hash": 4180964683905830761, "project": "debian", "size": 9, "label": 0, "functionSource": "static int selinux_msg_queue_associate ( struct msg_queue * msq , int msqflg ) {\n struct ipc_security_struct * isec ;\n struct common_audit_data ad ;\n u32 sid = current_sid ( ) ;\n isec = msq -> q_perm . security ;\n ad . type = LSM_AUDIT_DATA_IPC ;\n ad . u . ipc_id = msq -> q_perm . key ;\n return avc_has_perm ( sid , isec -> sid , SECCLASS_MSGQ , MSGQ__ASSOCIATE , & ad ) ;\n }", "idx": 20782}
{"hash": 825216912438754622, "project": "debian", "size": 5, "label": 0, "functionSource": "static int dissect_t38_UDPTLPacket ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 232 \"../../asn1/t38/t38.cnf\" Data_Field_field_type_value = 1 ;\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_t38_UDPTLPacket , UDPTLPacket_sequence ) ;\n return offset ;\n }", "idx": 20783}
{"hash": -8815658870890288443, "project": "chrome", "size": 3, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( CrossOriginXHR , FileAccessNoHosts ) {\n ASSERT_TRUE ( RunExtensionTest ( \"cross_origin_xhr/file_access_no_hosts\" ) ) << message_ ;\n }", "idx": 20784}
{"hash": -6442559759273439153, "project": "debian", "size": 11, "label": 0, "functionSource": "static int decode_pal_v2 ( MSS12Context * ctx , const uint8_t * buf , int buf_size ) {\n int i , ncol ;\n uint32_t * pal = ctx -> pal + 256 - ctx -> free_colours ;\n if ( ! ctx -> free_colours ) return 0 ;\n ncol = * buf ++ ;\n if ( ncol > ctx -> free_colours || buf_size < 2 + ncol * 3 ) return AVERROR_INVALIDDATA ;\n for ( i = 0 ;\n i < ncol ;\n i ++ ) * pal ++ = AV_RB24 ( buf + 3 * i ) ;\n return 1 + ncol * 3 ;\n }", "idx": 20785}
{"hash": 7424930167238097621, "project": "debian", "size": 3, "label": 0, "functionSource": "static void usbfs_decrease_memory_usage ( unsigned amount ) {\n atomic_sub ( amount , & usbfs_memory_usage ) ;\n }", "idx": 20786}
{"hash": 4180964683905830761, "project": "debian", "size": 3, "label": 0, "functionSource": "static void selinux_d_instantiate ( struct dentry * dentry , struct inode * inode ) {\n if ( inode ) inode_doinit_with_dentry ( inode , dentry ) ;\n }", "idx": 20787}
{"hash": 4489017523191997023, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h225_SEQUENCE_SIZE_1_512_OF_EnumeratedParameter ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_constrained_sequence_of ( tvb , offset , actx , tree , hf_index , ett_h225_SEQUENCE_SIZE_1_512_OF_EnumeratedParameter , SEQUENCE_SIZE_1_512_OF_EnumeratedParameter_sequence_of , 1 , 512 , FALSE ) ;\n return offset ;\n }", "idx": 20788}
{"hash": -1111775978048960297, "project": "chrome", "size": 40, "label": 0, "functionSource": "TEST_F ( BrowsingDataRemoverImplTest , MultipleTasks ) {\n BrowsingDataRemoverImpl * remover = static_cast < BrowsingDataRemoverImpl * > ( BrowsingDataRemoverFactory : : GetForBrowserContext ( GetBrowserContext ( ) ) ) ;\n EXPECT_FALSE ( remover -> is_removing ( ) ) ;\n std : : unique_ptr < BrowsingDataFilterBuilder > filter_builder_1 ( BrowsingDataFilterBuilder : : Create ( BrowsingDataFilterBuilder : : WHITELIST ) ) ;\n std : : unique_ptr < BrowsingDataFilterBuilder > filter_builder_2 ( BrowsingDataFilterBuilder : : Create ( BrowsingDataFilterBuilder : : BLACKLIST ) ) ;\n filter_builder_2 -> AddRegisterableDomain ( \"example.com\" ) ;\n MultipleTasksObserver observer ( remover ) ;\n BrowsingDataRemoverCompletionInhibitor completion_inhibitor ;\n std : : list < BrowsingDataRemoverImpl : : RemovalTask > tasks ;\n tasks . emplace_back ( base : : Time ( ) , base : : Time : : Max ( ) , BrowsingDataRemover : : REMOVE_HISTORY , BrowsingDataHelper : : UNPROTECTED_WEB , BrowsingDataFilterBuilder : : Create ( BrowsingDataFilterBuilder : : BLACKLIST ) , observer . target_a ( ) ) ;\n tasks . emplace_back ( base : : Time ( ) , base : : Time : : Max ( ) , BrowsingDataRemover : : REMOVE_COOKIES , BrowsingDataHelper : : PROTECTED_WEB , BrowsingDataFilterBuilder : : Create ( BrowsingDataFilterBuilder : : BLACKLIST ) , nullptr ) ;\n tasks . emplace_back ( base : : Time : : Now ( ) , base : : Time : : Max ( ) , BrowsingDataRemover : : REMOVE_PASSWORDS , BrowsingDataHelper : : ALL , BrowsingDataFilterBuilder : : Create ( BrowsingDataFilterBuilder : : BLACKLIST ) , observer . target_b ( ) ) ;\n tasks . emplace_back ( base : : Time ( ) , base : : Time : : UnixEpoch ( ) , BrowsingDataRemover : : REMOVE_WEBSQL , BrowsingDataHelper : : UNPROTECTED_WEB , std : : move ( filter_builder_1 ) , observer . target_b ( ) ) ;\n tasks . emplace_back ( base : : Time : : UnixEpoch ( ) , base : : Time : : Now ( ) , BrowsingDataRemover : : REMOVE_CHANNEL_IDS , BrowsingDataHelper : : ALL , std : : move ( filter_builder_2 ) , nullptr ) ;\n for ( BrowsingDataRemoverImpl : : RemovalTask & task : tasks ) {\n if ( ! task . observer && task . filter_builder -> IsEmptyBlacklist ( ) ) {\n remover -> Remove ( task . delete_begin , task . delete_end , task . remove_mask , task . origin_type_mask ) ;\n }\n else if ( task . filter_builder -> IsEmptyBlacklist ( ) ) {\n remover -> RemoveAndReply ( task . delete_begin , task . delete_end , task . remove_mask , task . origin_type_mask , task . observer ) ;\n }\n else if ( ! task . observer ) {\n remover -> RemoveWithFilter ( task . delete_begin , task . delete_end , task . remove_mask , task . origin_type_mask , std : : move ( task . filter_builder ) ) ;\n }\n else {\n remover -> RemoveWithFilterAndReply ( task . delete_begin , task . delete_end , task . remove_mask , task . origin_type_mask , std : : move ( task . filter_builder ) , task . observer ) ;\n }\n }\n for ( BrowsingDataRemoverImpl : : RemovalTask & task : tasks ) {\n EXPECT_TRUE ( remover -> is_removing ( ) ) ;\n observer . ClearLastCalledTarget ( ) ;\n completion_inhibitor . BlockUntilNearCompletion ( ) ;\n completion_inhibitor . ContinueToCompletion ( ) ;\n EXPECT_EQ ( task . observer , observer . GetLastCalledTarget ( ) ) ;\n EXPECT_EQ ( task . remove_mask , GetRemovalMask ( ) ) ;\n EXPECT_EQ ( task . origin_type_mask , GetOriginTypeMask ( ) ) ;\n EXPECT_EQ ( task . delete_begin , GetBeginTime ( ) ) ;\n }\n EXPECT_FALSE ( remover -> is_removing ( ) ) ;\n }", "idx": 20789}
{"hash": 6249489553242542670, "project": "debian", "size": 20, "label": 0, "functionSource": "static char * normal_dtoa ( double d ) {\n char * buf ;\n char * pch_e ;\n char * pch_nz ;\n LIB_GETBUF ( buf ) ;\n snprintf ( buf , LIB_BUFLENGTH , \"%g\" , d ) ;\n pch_e = strchr ( buf , 'e' ) ;\n if ( NULL == pch_e ) {\n pch_e = strchr ( buf , 'E' ) ;\n if ( NULL == pch_e ) return buf ;\n * pch_e = 'e' ;\n }\n pch_e ++ ;\n if ( '-' == * pch_e ) pch_e ++ ;\n pch_nz = pch_e ;\n while ( '0' == * pch_nz ) pch_nz ++ ;\n if ( pch_nz == pch_e ) return buf ;\n strncpy ( pch_e , pch_nz , LIB_BUFLENGTH - ( pch_e - buf ) ) ;\n return buf ;\n }", "idx": 20790}
{"hash": -4106680724983638989, "project": "chrome", "size": 35, "label": 1, "functionSource": "static unsigned int read_sbr_data ( AACContext * ac , SpectralBandReplication * sbr , GetBitContext * gb , int id_aac ) {\n unsigned int cnt = get_bits_count ( gb ) ;\n sbr -> id_aac = id_aac ;\n if ( id_aac == TYPE_SCE || id_aac == TYPE_CCE ) {\n if ( read_sbr_single_channel_element ( ac , sbr , gb ) ) {\n sbr_turnoff ( sbr ) ;\n return get_bits_count ( gb ) - cnt ;\n }\n }\n else if ( id_aac == TYPE_CPE ) {\n if ( read_sbr_channel_pair_element ( ac , sbr , gb ) ) {\n sbr_turnoff ( sbr ) ;\n return get_bits_count ( gb ) - cnt ;\n }\n }\n else {\n av_log ( ac -> avctx , AV_LOG_ERROR , \"Invalid bitstream - cannot apply SBR to element type %d\\n\" , id_aac ) ;\n sbr_turnoff ( sbr ) ;\n return get_bits_count ( gb ) - cnt ;\n }\n if ( get_bits1 ( gb ) ) {\n int num_bits_left = get_bits ( gb , 4 ) ;\n if ( num_bits_left == 15 ) num_bits_left += get_bits ( gb , 8 ) ;\n num_bits_left <<= 3 ;\n while ( num_bits_left > 7 ) {\n num_bits_left -= 2 ;\n read_sbr_extension ( ac , sbr , gb , get_bits ( gb , 2 ) , & num_bits_left ) ;\n }\n if ( num_bits_left < 0 ) {\n av_log ( ac -> avctx , AV_LOG_ERROR , \"SBR Extension over read.\\n\" ) ;\n }\n if ( num_bits_left > 0 ) skip_bits ( gb , num_bits_left ) ;\n }\n return get_bits_count ( gb ) - cnt ;\n }", "idx": 20791}
{"hash": -2607754285145856562, "project": "debian", "size": 111, "label": 0, "functionSource": "static int isoent_tree ( struct archive_write * a , struct isoent * * isoentpp ) {\n # if defined ( _WIN32 ) && ! defined ( __CYGWIN__ ) char name [ _MAX_FNAME ] ;\n # elif defined ( NAME_MAX ) && NAME_MAX >= 255 char name [ NAME_MAX + 1 ] ;\n # else char name [ 256 ] ;\n # endif struct iso9660 * iso9660 = a -> format_data ;\n struct isoent * dent , * isoent , * np ;\n struct isofile * f1 , * f2 ;\n const char * fn , * p ;\n int l ;\n isoent = * isoentpp ;\n dent = iso9660 -> primary . rootent ;\n if ( isoent -> file -> parentdir . length > 0 ) fn = p = isoent -> file -> parentdir . s ;\n else fn = p = \"\" ;\n if ( archive_strlen ( & ( iso9660 -> cur_dirstr ) ) == archive_strlen ( & ( isoent -> file -> parentdir ) ) && strcmp ( iso9660 -> cur_dirstr . s , fn ) == 0 ) {\n if ( ! isoent_add_child_tail ( iso9660 -> cur_dirent , isoent ) ) {\n np = ( struct isoent * ) __archive_rb_tree_find_node ( & ( iso9660 -> cur_dirent -> rbtree ) , isoent -> file -> basename . s ) ;\n goto same_entry ;\n }\n return ( ARCHIVE_OK ) ;\n }\n for ( ;\n ;\n ) {\n l = get_path_component ( name , sizeof ( name ) , fn ) ;\n if ( l == 0 ) {\n np = NULL ;\n break ;\n }\n if ( l < 0 ) {\n archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , \"A name buffer is too small\" ) ;\n _isoent_free ( isoent ) ;\n return ( ARCHIVE_FATAL ) ;\n }\n np = isoent_find_child ( dent , name ) ;\n if ( np == NULL || fn [ 0 ] == '\\0' ) break ;\n if ( ! np -> dir ) {\n archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , \"`%s' is not directory, we cannot insert `%s' \" , archive_entry_pathname ( np -> file -> entry ) , archive_entry_pathname ( isoent -> file -> entry ) ) ;\n _isoent_free ( isoent ) ;\n * isoentpp = NULL ;\n return ( ARCHIVE_FAILED ) ;\n }\n fn += l ;\n if ( fn [ 0 ] == '/' ) fn ++ ;\n dent = np ;\n }\n if ( np == NULL ) {\n while ( fn [ 0 ] != '\\0' ) {\n struct isoent * vp ;\n struct archive_string as ;\n archive_string_init ( & as ) ;\n archive_strncat ( & as , p , fn - p + l ) ;\n if ( as . s [ as . length - 1 ] == '/' ) {\n as . s [ as . length - 1 ] = '\\0' ;\n as . length -- ;\n }\n vp = isoent_create_virtual_dir ( a , iso9660 , as . s ) ;\n if ( vp == NULL ) {\n archive_string_free ( & as ) ;\n archive_set_error ( & a -> archive , ENOMEM , \"Can't allocate memory\" ) ;\n _isoent_free ( isoent ) ;\n * isoentpp = NULL ;\n return ( ARCHIVE_FATAL ) ;\n }\n archive_string_free ( & as ) ;\n if ( vp -> file -> dircnt > iso9660 -> dircnt_max ) iso9660 -> dircnt_max = vp -> file -> dircnt ;\n isoent_add_child_tail ( dent , vp ) ;\n np = vp ;\n fn += l ;\n if ( fn [ 0 ] == '/' ) fn ++ ;\n l = get_path_component ( name , sizeof ( name ) , fn ) ;\n if ( l < 0 ) {\n archive_string_free ( & as ) ;\n archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , \"A name buffer is too small\" ) ;\n _isoent_free ( isoent ) ;\n * isoentpp = NULL ;\n return ( ARCHIVE_FATAL ) ;\n }\n dent = np ;\n }\n iso9660 -> cur_dirent = dent ;\n archive_string_empty ( & ( iso9660 -> cur_dirstr ) ) ;\n archive_string_ensure ( & ( iso9660 -> cur_dirstr ) , archive_strlen ( & ( dent -> file -> parentdir ) ) + archive_strlen ( & ( dent -> file -> basename ) ) + 2 ) ;\n if ( archive_strlen ( & ( dent -> file -> parentdir ) ) + archive_strlen ( & ( dent -> file -> basename ) ) == 0 ) iso9660 -> cur_dirstr . s [ 0 ] = 0 ;\n else {\n if ( archive_strlen ( & ( dent -> file -> parentdir ) ) > 0 ) {\n archive_string_copy ( & ( iso9660 -> cur_dirstr ) , & ( dent -> file -> parentdir ) ) ;\n archive_strappend_char ( & ( iso9660 -> cur_dirstr ) , '/' ) ;\n }\n archive_string_concat ( & ( iso9660 -> cur_dirstr ) , & ( dent -> file -> basename ) ) ;\n }\n if ( ! isoent_add_child_tail ( dent , isoent ) ) {\n np = ( struct isoent * ) __archive_rb_tree_find_node ( & ( dent -> rbtree ) , isoent -> file -> basename . s ) ;\n goto same_entry ;\n }\n return ( ARCHIVE_OK ) ;\n }\n same_entry : f1 = np -> file ;\n f2 = isoent -> file ;\n if ( archive_entry_filetype ( f1 -> entry ) != archive_entry_filetype ( f2 -> entry ) ) {\n archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , \"Found duplicate entries `%s' and its file type is \" \"different\" , archive_entry_pathname ( f1 -> entry ) ) ;\n _isoent_free ( isoent ) ;\n * isoentpp = NULL ;\n return ( ARCHIVE_FAILED ) ;\n }\n np -> file = f2 ;\n isoent -> file = f1 ;\n np -> virtual = 0 ;\n _isoent_free ( isoent ) ;\n * isoentpp = np ;\n return ( ARCHIVE_OK ) ;\n }", "idx": 20792}
{"hash": -5315423743066773158, "project": "debian", "size": 64, "label": 0, "functionSource": "static bool message_decode_body ( struct message_decoder_context * ctx , struct message_block * input , struct message_block * output ) {\n const unsigned char * data = NULL ;\n size_t pos = 0 , size = 0 ;\n const char * error ;\n int ret ;\n if ( ctx -> encoding_buf -> used != 0 ) buffer_append ( ctx -> encoding_buf , input -> data , input -> size ) ;\n switch ( ctx -> message_cte ) {\n case MESSAGE_CTE_UNKNOWN : return FALSE ;\n case MESSAGE_CTE_78BIT : case MESSAGE_CTE_BINARY : i_assert ( ctx -> encoding_buf -> used == 0 ) ;\n data = input -> data ;\n size = pos = input -> size ;\n break ;\n case MESSAGE_CTE_QP : {\n i_assert ( ctx -> encoding_buf -> used == 0 ) ;\n buffer_set_used_size ( ctx -> buf , 0 ) ;\n if ( ctx -> qp == NULL ) ctx -> qp = qp_decoder_init ( ctx -> buf ) ;\n ( void ) qp_decoder_more ( ctx -> qp , input -> data , input -> size , & pos , & error ) ;\n data = ctx -> buf -> data ;\n size = ctx -> buf -> used ;\n pos = input -> size ;\n break ;\n }\n case MESSAGE_CTE_BASE64 : buffer_set_used_size ( ctx -> buf , 0 ) ;\n if ( ctx -> encoding_buf -> used != 0 ) {\n ret = base64_decode ( ctx -> encoding_buf -> data , ctx -> encoding_buf -> used , & pos , ctx -> buf ) ;\n }\n else {\n ret = base64_decode ( input -> data , input -> size , & pos , ctx -> buf ) ;\n }\n if ( ret < 0 ) {\n return FALSE ;\n }\n if ( ret == 0 ) {\n pos = input -> size ;\n buffer_set_used_size ( ctx -> encoding_buf , 0 ) ;\n }\n data = ctx -> buf -> data ;\n size = ctx -> buf -> used ;\n break ;\n }\n if ( ctx -> encoding_buf -> used != 0 ) buffer_delete ( ctx -> encoding_buf , 0 , pos ) ;\n else if ( pos != input -> size ) {\n buffer_append ( ctx -> encoding_buf , input -> data + pos , input -> size - pos ) ;\n }\n if ( ctx -> binary_input ) {\n output -> data = data ;\n output -> size = size ;\n }\n else {\n buffer_set_used_size ( ctx -> buf2 , 0 ) ;\n if ( ctx -> translation_size != 0 ) translation_buf_decode ( ctx , & data , & size ) ;\n pos = size ;\n ( void ) charset_to_utf8 ( ctx -> charset_trans , data , & pos , ctx -> buf2 ) ;\n if ( pos != size ) {\n ctx -> translation_size = size - pos ;\n i_assert ( ctx -> translation_size <= sizeof ( ctx -> translation_buf ) ) ;\n memcpy ( ctx -> translation_buf , data + pos , ctx -> translation_size ) ;\n }\n output -> data = ctx -> buf2 -> data ;\n output -> size = ctx -> buf2 -> used ;\n }\n output -> hdr = NULL ;\n return TRUE ;\n }", "idx": 20793}
{"hash": -4055702019813176658, "project": "debian", "size": 112, "label": 0, "functionSource": "static void desegment_iax ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * iax2_tree , proto_tree * tree , gboolean video , iax_packet_data * iax_packet ) {\n iax_call_data * iax_call = iax_packet -> call_data ;\n iax_call_dirdata * dirdata ;\n gpointer value = NULL ;\n guint32 frag_offset = 0 ;\n fragment_head * fd_head ;\n gboolean must_desegment = FALSE ;\n DISSECTOR_ASSERT ( iax_call ) ;\n pinfo -> can_desegment = 2 ;\n pinfo -> desegment_offset = 0 ;\n pinfo -> desegment_len = 0 ;\n # ifdef DEBUG_DESEGMENT g_debug ( \"dissecting packet %u\" , pinfo -> fd -> num ) ;\n # endif dirdata = & ( iax_call -> dirdata [ ! ! ( iax_packet -> reversed ) ] ) ;\n if ( ( ! pinfo -> fd -> flags . visited && ( dirdata -> current_frag_bytes > 0 ) ) || ( ( value = g_hash_table_lookup ( iax_fid_table , GUINT_TO_POINTER ( pinfo -> fd -> num ) ) ) != NULL ) ) {\n guint32 fid ;\n guint32 frag_len = tvb_reported_length ( tvb ) ;\n gboolean complete ;\n # ifdef DEBUG_DESEGMENT g_debug ( \"visited: %i;\n c_f_b: %u;\n hash: %u->%u\" , pinfo -> fd -> flags . visited ? 1 : 0 , dirdata -> current_frag_bytes , pinfo -> fd -> num , dirdata -> current_frag_id ) ;\n # endif if ( ! pinfo -> fd -> flags . visited ) {\n guint32 tot_len ;\n fid = dirdata -> current_frag_id ;\n tot_len = dirdata -> current_frag_minlen ;\n DISSECTOR_ASSERT ( g_hash_table_lookup ( iax_fid_table , GUINT_TO_POINTER ( pinfo -> fd -> num ) ) == NULL ) ;\n g_hash_table_insert ( iax_fid_table , GUINT_TO_POINTER ( pinfo -> fd -> num ) , GUINT_TO_POINTER ( fid ) ) ;\n frag_offset = dirdata -> current_frag_bytes ;\n dirdata -> current_frag_bytes += frag_len ;\n complete = dirdata -> current_frag_bytes > tot_len ;\n # ifdef DEBUG_DESEGMENT g_debug ( \"hash: %u->%u;\n frag_offset: %u;\n c_f_b: %u;\n totlen: %u\" , pinfo -> fd -> num , fid , frag_offset , dirdata -> current_frag_bytes , tot_len ) ;\n # endif }\n else {\n fid = GPOINTER_TO_UINT ( value ) ;\n dirdata -> current_frag_bytes = 0 ;\n complete = FALSE ;\n }\n fd_head = fragment_add ( & iax_reassembly_table , tvb , 0 , pinfo , fid , NULL , frag_offset , frag_len , ! complete ) ;\n if ( fd_head && ( pinfo -> fd -> num == fd_head -> reassembled_in ) ) {\n gint32 old_len ;\n tvbuff_t * next_tvb = tvb_new_chain ( tvb , fd_head -> tvb_data ) ;\n add_new_data_source ( pinfo , next_tvb , \"Reassembled IAX2\" ) ;\n process_iax_pdu ( next_tvb , pinfo , tree , video , iax_packet ) ;\n old_len = ( gint32 ) ( tvb_reported_length ( next_tvb ) - frag_len ) ;\n if ( pinfo -> desegment_len && ( pinfo -> desegment_offset < old_len ) ) {\n fragment_set_partial_reassembly ( & iax_reassembly_table , pinfo , fid , NULL ) ;\n if ( pinfo -> desegment_len == DESEGMENT_ONE_MORE_SEGMENT ) {\n dirdata -> current_frag_minlen = fd_head -> datalen + 1 ;\n }\n else {\n dirdata -> current_frag_minlen = fd_head -> datalen + pinfo -> desegment_len ;\n }\n }\n else {\n proto_item * iax_tree_item , * frag_tree_item ;\n show_fragment_tree ( fd_head , & iax2_fragment_items , tree , pinfo , next_tvb , & frag_tree_item ) ;\n iax_tree_item = proto_item_get_parent ( proto_tree_get_parent ( iax2_tree ) ) ;\n if ( frag_tree_item && iax_tree_item ) proto_tree_move_item ( tree , iax_tree_item , frag_tree_item ) ;\n dirdata -> current_frag_minlen = dirdata -> current_frag_id = dirdata -> current_frag_bytes = 0 ;\n if ( pinfo -> desegment_len ) {\n must_desegment = TRUE ;\n pinfo -> desegment_offset -= old_len ;\n }\n fd_head = NULL ;\n }\n }\n }\n else {\n process_iax_pdu ( tvb , pinfo , tree , video , iax_packet ) ;\n if ( pinfo -> desegment_len ) {\n must_desegment = TRUE ;\n }\n fd_head = NULL ;\n }\n if ( must_desegment ) {\n guint32 fid = pinfo -> fd -> num ;\n guint32 deseg_offset = pinfo -> desegment_offset ;\n guint32 frag_len = tvb_reported_length_remaining ( tvb , deseg_offset ) ;\n dirdata -> current_frag_id = fid ;\n dirdata -> current_frag_bytes = frag_len ;\n if ( pinfo -> desegment_len == DESEGMENT_ONE_MORE_SEGMENT ) {\n dirdata -> current_frag_minlen = frag_len + 1 ;\n }\n else {\n dirdata -> current_frag_minlen = frag_len + pinfo -> desegment_len ;\n }\n fd_head = fragment_add ( & iax_reassembly_table , tvb , deseg_offset , pinfo , fid , NULL , 0 , frag_len , TRUE ) ;\n # ifdef DEBUG_DESEGMENT g_debug ( \"Start offset of undissected bytes: %u;\n \" \"Bytes remaining in this segment: %u;\n min required bytes: %u\\n\" , deseg_offset , frag_len , frag_len + pinfo -> desegment_len ) ;\n # endif }\n if ( fd_head != NULL ) {\n guint32 deseg_offset = pinfo -> desegment_offset ;\n if ( fd_head -> reassembled_in != 0 && ! ( fd_head -> flags & FD_PARTIAL_REASSEMBLY ) ) {\n proto_item * iax_tree_item ;\n iax_tree_item = proto_tree_add_uint ( tree , hf_iax2_reassembled_in , tvb , deseg_offset , tvb_reported_length_remaining ( tvb , deseg_offset ) , fd_head -> reassembled_in ) ;\n PROTO_ITEM_SET_GENERATED ( iax_tree_item ) ;\n }\n else {\n proto_tree_add_item ( tree , hf_iax2_fragment_unfinished , tvb , deseg_offset , - 1 , ENC_NA ) ;\n }\n if ( pinfo -> desegment_offset == 0 ) {\n col_set_str ( pinfo -> cinfo , COL_PROTOCOL , \"IAX2\" ) ;\n col_set_str ( pinfo -> cinfo , COL_INFO , \"[IAX2 segment of a reassembled PDU]\" ) ;\n }\n }\n pinfo -> can_desegment = 0 ;\n pinfo -> desegment_offset = 0 ;\n pinfo -> desegment_len = 0 ;\n }", "idx": 20794}
{"hash": -8228664527580018723, "project": "debian", "size": 3, "label": 0, "functionSource": "static __inline __uint64_t __uint64_identity ( __uint64_t __x ) {\n return __x ;\n }", "idx": 20795}
{"hash": 8461266595329035000, "project": "chrome", "size": 19, "label": 0, "functionSource": "static int timeout_next ( struct event_base * base , struct timeval * * tv_p ) {\n struct timeval now ;\n struct event * ev ;\n struct timeval * tv = * tv_p ;\n if ( ( ev = min_heap_top ( & base -> timeheap ) ) == NULL ) {\n * tv_p = NULL ;\n return ( 0 ) ;\n }\n if ( gettime ( base , & now ) == - 1 ) return ( - 1 ) ;\n if ( evutil_timercmp ( & ev -> ev_timeout , & now , <= ) ) {\n evutil_timerclear ( tv ) ;\n return ( 0 ) ;\n }\n evutil_timersub ( & ev -> ev_timeout , & now , tv ) ;\n assert ( tv -> tv_sec >= 0 ) ;\n assert ( tv -> tv_usec >= 0 ) ;\n event_debug ( ( \"timeout_next: in %ld seconds\" , tv -> tv_sec ) ) ;\n return ( 0 ) ;\n }", "idx": 20796}
{"hash": 252275190935145023, "project": "debian", "size": 4, "label": 0, "functionSource": "static int decode_unsigned_max ( struct vp9_read_bit_buffer * rb , int max ) {\n const int data = vp9_rb_read_literal ( rb , get_unsigned_bits ( max ) ) ;\n return data > max ? max : data ;\n }", "idx": 20797}
{"hash": 3035587999006680483, "project": "debian", "size": 8, "label": 0, "functionSource": "void dtls1_get_message_header ( unsigned char * data , struct hm_header_st * msg_hdr ) {\n memset ( msg_hdr , 0x00 , sizeof ( struct hm_header_st ) ) ;\n msg_hdr -> type = * ( data ++ ) ;\n n2l3 ( data , msg_hdr -> msg_len ) ;\n n2s ( data , msg_hdr -> seq ) ;\n n2l3 ( data , msg_hdr -> frag_off ) ;\n n2l3 ( data , msg_hdr -> frag_len ) ;\n }", "idx": 20798}
{"hash": 6415329349331062723, "project": "chrome", "size": 6, "label": 0, "functionSource": "static void http_chunked_writecb ( struct bufferevent * bev , void * arg ) {\n if ( EVBUFFER_LENGTH ( EVBUFFER_OUTPUT ( bev ) ) == 0 ) {\n bufferevent_enable ( bev , EV_READ ) ;\n test_ok ++ ;\n }\n }", "idx": 20799}
{"hash": 6581530453642608175, "project": "chrome", "size": 13, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( ProfileBrowserTest , DISABLED_CreateNewProfileAsynchronous ) {\n base : : ScopedTempDir temp_dir ;\n ASSERT_TRUE ( temp_dir . CreateUniqueTempDir ( ) ) ;\n MockProfileDelegate delegate ;\n EXPECT_CALL ( delegate , OnProfileCreated ( testing : : NotNull ( ) , true , true ) ) ;\n {\n content : : WindowedNotificationObserver observer ( chrome : : NOTIFICATION_PROFILE_CREATED , content : : NotificationService : : AllSources ( ) ) ;\n std : : unique_ptr < Profile > profile ( CreateProfile ( temp_dir . path ( ) , & delegate , Profile : : CREATE_MODE_ASYNCHRONOUS ) ) ;\n observer . Wait ( ) ;\n CheckChromeVersion ( profile . get ( ) , true ) ;\n }\n FlushIoTaskRunnerAndSpinThreads ( ) ;\n }", "idx": 20800}
{"hash": 58020529414140129, "project": "chrome", "size": 20, "label": 0, "functionSource": "static int cost_segmap ( int * segcounts , vp9_prob * probs ) {\n const int c01 = segcounts [ 0 ] + segcounts [ 1 ] ;\n const int c23 = segcounts [ 2 ] + segcounts [ 3 ] ;\n const int c45 = segcounts [ 4 ] + segcounts [ 5 ] ;\n const int c67 = segcounts [ 6 ] + segcounts [ 7 ] ;\n const int c0123 = c01 + c23 ;\n const int c4567 = c45 + c67 ;\n int cost = c0123 * vp9_cost_zero ( probs [ 0 ] ) + c4567 * vp9_cost_one ( probs [ 0 ] ) ;\n if ( c0123 > 0 ) {\n cost += c01 * vp9_cost_zero ( probs [ 1 ] ) + c23 * vp9_cost_one ( probs [ 1 ] ) ;\n if ( c01 > 0 ) cost += segcounts [ 0 ] * vp9_cost_zero ( probs [ 3 ] ) + segcounts [ 1 ] * vp9_cost_one ( probs [ 3 ] ) ;\n if ( c23 > 0 ) cost += segcounts [ 2 ] * vp9_cost_zero ( probs [ 4 ] ) + segcounts [ 3 ] * vp9_cost_one ( probs [ 4 ] ) ;\n }\n if ( c4567 > 0 ) {\n cost += c45 * vp9_cost_zero ( probs [ 2 ] ) + c67 * vp9_cost_one ( probs [ 2 ] ) ;\n if ( c45 > 0 ) cost += segcounts [ 4 ] * vp9_cost_zero ( probs [ 5 ] ) + segcounts [ 5 ] * vp9_cost_one ( probs [ 5 ] ) ;\n if ( c67 > 0 ) cost += segcounts [ 6 ] * vp9_cost_zero ( probs [ 6 ] ) + segcounts [ 7 ] * vp9_cost_one ( probs [ 6 ] ) ;\n }\n return cost ;\n }", "idx": 20801}
{"hash": 1144893748552025496, "project": "debian", "size": 22, "label": 0, "functionSource": "static void libopenjpeg_copyto8 ( AVFrame * picture , opj_image_t * image ) {\n int * comp_data ;\n uint8_t * img_ptr ;\n int index , x , y ;\n for ( index = 0 ;\n index < image -> numcomps ;\n index ++ ) {\n comp_data = image -> comps [ index ] . data ;\n for ( y = 0 ;\n y < image -> comps [ index ] . h ;\n y ++ ) {\n img_ptr = picture -> data [ index ] + y * picture -> linesize [ index ] ;\n for ( x = 0 ;\n x < image -> comps [ index ] . w ;\n x ++ ) {\n * img_ptr = ( uint8_t ) * comp_data ;\n img_ptr ++ ;\n comp_data ++ ;\n }\n }\n }\n }", "idx": 20802}
{"hash": -2001852372520287494, "project": "chrome", "size": 9, "label": 0, "functionSource": "void printEachBackward ( UBreakIterator * boundary , UChar * str ) {\n int32_t start ;\n int32_t end = ubrk_last ( boundary ) ;\n for ( start = ubrk_previous ( boundary ) ;\n start != UBRK_DONE ;\n end = start , start = ubrk_previous ( boundary ) ) {\n printTextRange ( str , start , end ) ;\n }\n }", "idx": 20803}
{"hash": 3919646340804521652, "project": "debian", "size": 11, "label": 0, "functionSource": "static void copy_pack_data ( struct sha1file * f , struct packed_git * p , struct pack_window * * w_curs , off_t offset , off_t len ) {\n unsigned char * in ;\n unsigned long avail ;\n while ( len ) {\n in = use_pack ( p , w_curs , offset , & avail ) ;\n if ( avail > len ) avail = ( unsigned long ) len ;\n sha1write ( f , in , avail ) ;\n offset += avail ;\n len -= avail ;\n }\n }", "idx": 20804}
{"hash": -7434014980763120366, "project": "debian", "size": 6, "label": 0, "functionSource": "static void ber_update_oids ( void ) {\n guint i ;\n for ( i = 0 ;\n i < num_oid_users ;\n i ++ ) register_ber_oid_syntax ( oid_users [ i ] . oid , oid_users [ i ] . name , oid_users [ i ] . syntax ) ;\n }", "idx": 20805}
{"hash": 1208165234047591297, "project": "debian", "size": 5, "label": 0, "functionSource": "proto_item * parseInt16 ( proto_tree * tree , tvbuff_t * tvb , packet_info * pinfo _U_ , gint * pOffset , int hfIndex ) {\n proto_item * item = proto_tree_add_item ( tree , hfIndex , tvb , * pOffset , 2 , ENC_LITTLE_ENDIAN ) ;\n * pOffset += 2 ;\n return item ;\n }", "idx": 20806}
{"hash": -1315695702746584250, "project": "debian", "size": 5, "label": 0, "functionSource": "gboolean proto_registrar_is_protocol ( const int n ) {\n header_field_info * hfinfo ;\n PROTO_REGISTRAR_GET_NTH ( n , hfinfo ) ;\n return ( ( ( hfinfo -> id != hf_text_only ) && ( hfinfo -> parent == - 1 ) ) ? TRUE : FALSE ) ;\n }", "idx": 20807}
{"hash": -5018047422955641881, "project": "debian", "size": 37, "label": 0, "functionSource": "int s390_virtio_hypercall ( CPUState * env ) {\n int r = 0 , i ;\n target_ulong mem = env -> regs [ 2 ] ;\n dprintf ( \"KVM hypercall: %ld\\n\" , env -> regs [ 1 ] ) ;\n switch ( env -> regs [ 1 ] ) {\n case KVM_S390_VIRTIO_NOTIFY : if ( mem > ram_size ) {\n VirtIOS390Device * dev = s390_virtio_bus_find_vring ( s390_bus , mem , & i ) ;\n if ( dev ) {\n virtio_queue_notify ( dev -> vdev , i ) ;\n }\n else {\n r = - EINVAL ;\n }\n }\n else {\n }\n break ;\n case KVM_S390_VIRTIO_RESET : {\n break ;\n }\n case KVM_S390_VIRTIO_SET_STATUS : {\n VirtIOS390Device * dev ;\n dev = s390_virtio_bus_find_mem ( s390_bus , mem ) ;\n if ( dev ) {\n s390_virtio_device_update_status ( dev ) ;\n }\n else {\n r = - EINVAL ;\n }\n break ;\n }\n default : r = - EINVAL ;\n break ;\n }\n env -> regs [ 2 ] = r ;\n return 0 ;\n }", "idx": 20808}
{"hash": -1658505547857059267, "project": "debian", "size": 12, "label": 1, "functionSource": "static int split_field_copy ( Picture * dest , Picture * src , int parity , int id_add ) {\n int match = ! ! ( src -> f . reference & parity ) ;\n if ( match ) {\n * dest = * src ;\n if ( parity != PICT_FRAME ) {\n pic_as_field ( dest , parity ) ;\n dest -> pic_id *= 2 ;\n dest -> pic_id += id_add ;\n }\n }\n return match ;\n }", "idx": 20809}
{"hash": 3804373597256531021, "project": "debian", "size": 46, "label": 0, "functionSource": "bool change_password ( THD * thd , const char * host , const char * user , char * new_password ) {\n TABLE_LIST tables ;\n TABLE * table ;\n char buff [ 512 ] ;\n ulong query_length ;\n bool save_binlog_row_based ;\n uint new_password_len = ( uint ) strlen ( new_password ) ;\n bool result = 1 ;\n DBUG_ENTER ( \"change_password\" ) ;\n DBUG_PRINT ( \"enter\" , ( \"host: '%s' user: '%s' new_password: '%s'\" , host , user , new_password ) ) ;\n DBUG_ASSERT ( host != 0 ) ;\n if ( check_change_password ( thd , host , user , new_password , new_password_len ) ) DBUG_RETURN ( 1 ) ;\n bzero ( ( char * ) & tables , sizeof ( tables ) ) ;\n tables . alias = tables . table_name = ( char * ) \"user\" ;\n tables . db = ( char * ) \"mysql\" ;\n # ifdef HAVE_REPLICATION if ( thd -> slave_thread && rpl_filter -> is_on ( ) ) {\n tables . updating = 1 ;\n if ( ! ( thd -> spcont || rpl_filter -> tables_ok ( 0 , & tables ) ) ) DBUG_RETURN ( 0 ) ;\n }\n # endif if ( ! ( table = open_ltable ( thd , & tables , TL_WRITE , 0 ) ) ) DBUG_RETURN ( 1 ) ;\n if ( ( save_binlog_row_based = thd -> current_stmt_binlog_row_based ) ) thd -> clear_current_stmt_binlog_row_based ( ) ;\n VOID ( pthread_mutex_lock ( & acl_cache -> lock ) ) ;\n ACL_USER * acl_user ;\n if ( ! ( acl_user = find_acl_user ( host , user , TRUE ) ) ) {\n VOID ( pthread_mutex_unlock ( & acl_cache -> lock ) ) ;\n my_message ( ER_PASSWORD_NO_MATCH , ER ( ER_PASSWORD_NO_MATCH ) , MYF ( 0 ) ) ;\n goto end ;\n }\n set_user_salt ( acl_user , new_password , new_password_len ) ;\n if ( update_user_table ( thd , table , acl_user -> host . hostname ? acl_user -> host . hostname : \"\" , acl_user -> user ? acl_user -> user : \"\" , new_password , new_password_len ) ) {\n VOID ( pthread_mutex_unlock ( & acl_cache -> lock ) ) ;\n goto end ;\n }\n acl_cache -> clear ( 1 ) ;\n VOID ( pthread_mutex_unlock ( & acl_cache -> lock ) ) ;\n result = 0 ;\n if ( mysql_bin_log . is_open ( ) ) {\n query_length = sprintf ( buff , \"SET PASSWORD FOR '%-.120s'@'%-.120s'='%-.120s'\" , acl_user -> user ? acl_user -> user : \"\" , acl_user -> host . hostname ? acl_user -> host . hostname : \"\" , new_password ) ;\n thd -> clear_error ( ) ;\n result = thd -> binlog_query ( THD : : MYSQL_QUERY_TYPE , buff , query_length , FALSE , FALSE , 0 ) ;\n }\n end : close_thread_tables ( thd ) ;\n DBUG_ASSERT ( ! thd -> current_stmt_binlog_row_based ) ;\n if ( save_binlog_row_based ) thd -> set_current_stmt_binlog_row_based ( ) ;\n DBUG_RETURN ( result ) ;\n }", "idx": 20810}
{"hash": 136942900289772931, "project": "debian", "size": 8, "label": 0, "functionSource": "static int set_metadata_float ( AVDictionary * * dict , const char * key , float value , int allow_zero ) {\n if ( value != 0 || allow_zero ) {\n char tmp [ 64 ] ;\n snprintf ( tmp , sizeof ( tmp ) , \"%f\" , value ) ;\n return av_dict_set ( dict , key , tmp , 0 ) ;\n }\n return 0 ;\n }", "idx": 20811}
{"hash": 4839943401171415484, "project": "chrome", "size": 24, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_P ( BrowserCloseManagerBrowserTest , TestCloseTabDuringShutdown ) {\n ASSERT_NO_FATAL_FAILURE ( ui_test_utils : : NavigateToURL ( browsers_ [ 0 ] , embedded_test_server ( ) -> GetURL ( \"/beforeunload.html\" ) ) ) ;\n PrepareForDialog ( browsers_ [ 0 ] ) ;\n RepeatedNotificationObserver cancel_observer ( chrome : : NOTIFICATION_BROWSER_CLOSE_CANCELLED , 1 ) ;\n chrome : : CloseAllBrowsersAndQuit ( ) ;\n browsers_ . push_back ( CreateBrowser ( browser ( ) -> profile ( ) ) ) ;\n ASSERT_NO_FATAL_FAILURE ( ui_test_utils : : NavigateToURL ( browsers_ [ 1 ] , embedded_test_server ( ) -> GetURL ( \"/beforeunload.html\" ) ) ) ;\n PrepareForDialog ( browsers_ [ 1 ] ) ;\n browsers_ [ 1 ] -> tab_strip_model ( ) -> CloseAllTabs ( ) ;\n ASSERT_NO_FATAL_FAILURE ( CancelClose ( ) ) ;\n ASSERT_NO_FATAL_FAILURE ( CancelClose ( ) ) ;\n cancel_observer . Wait ( ) ;\n EXPECT_FALSE ( browser_shutdown : : IsTryingToQuit ( ) ) ;\n EXPECT_EQ ( 1 , browsers_ [ 0 ] -> tab_strip_model ( ) -> count ( ) ) ;\n EXPECT_EQ ( 1 , browsers_ [ 1 ] -> tab_strip_model ( ) -> count ( ) ) ;\n RepeatedNotificationObserver close_observer ( chrome : : NOTIFICATION_BROWSER_CLOSED , 2 ) ;\n chrome : : CloseAllBrowsersAndQuit ( ) ;\n browsers_ [ 1 ] -> tab_strip_model ( ) -> CloseAllTabs ( ) ;\n ASSERT_NO_FATAL_FAILURE ( AcceptClose ( ) ) ;\n ASSERT_NO_FATAL_FAILURE ( AcceptClose ( ) ) ;\n close_observer . Wait ( ) ;\n EXPECT_TRUE ( browser_shutdown : : IsTryingToQuit ( ) ) ;\n EXPECT_TRUE ( BrowserList : : GetInstance ( ) -> empty ( ) ) ;\n }", "idx": 20812}
{"hash": -3740862514502467070, "project": "debian", "size": 12, "label": 0, "functionSource": "static void DumpDblArray ( real * arr , int n , FILE * cfff , int oper ) {\n int mi , i ;\n for ( mi = n - 1 ;\n mi >= 0 && arr [ mi ] == 0 ;\n -- mi ) ;\n if ( mi < 0 ) return ;\n dumpdbl ( cfff , arr [ 0 ] ) ;\n for ( i = 1 ;\n i <= mi ;\n ++ i ) dumpdbl ( cfff , arr [ i ] - arr [ i - 1 ] ) ;\n dumpoper ( cfff , oper ) ;\n }", "idx": 20813}
{"hash": -2222463888415249941, "project": "chrome", "size": 7, "label": 0, "functionSource": "static void release_scaled_references ( VP9_COMP * cpi ) {\n VP9_COMMON * cm = & cpi -> common ;\n int i ;\n for ( i = 0 ;\n i < 3 ;\n i ++ ) cm -> frame_bufs [ cpi -> scaled_ref_idx [ i ] ] . ref_count -- ;\n }", "idx": 20814}
{"hash": 3668456668028959955, "project": "debian", "size": 86, "label": 0, "functionSource": "static VALUE cState_configure ( VALUE self , VALUE opts ) {\n VALUE tmp ;\n GET_STATE ( self ) ;\n tmp = rb_check_convert_type ( opts , T_HASH , \"Hash\" , \"to_hash\" ) ;\n if ( NIL_P ( tmp ) ) tmp = rb_convert_type ( opts , T_HASH , \"Hash\" , \"to_h\" ) ;\n opts = tmp ;\n tmp = rb_hash_aref ( opts , ID2SYM ( i_indent ) ) ;\n if ( RTEST ( tmp ) ) {\n unsigned long len ;\n Check_Type ( tmp , T_STRING ) ;\n len = RSTRING_LEN ( tmp ) ;\n state -> indent = fstrndup ( RSTRING_PTR ( tmp ) , len + 1 ) ;\n state -> indent_len = len ;\n }\n tmp = rb_hash_aref ( opts , ID2SYM ( i_space ) ) ;\n if ( RTEST ( tmp ) ) {\n unsigned long len ;\n Check_Type ( tmp , T_STRING ) ;\n len = RSTRING_LEN ( tmp ) ;\n state -> space = fstrndup ( RSTRING_PTR ( tmp ) , len + 1 ) ;\n state -> space_len = len ;\n }\n tmp = rb_hash_aref ( opts , ID2SYM ( i_space_before ) ) ;\n if ( RTEST ( tmp ) ) {\n unsigned long len ;\n Check_Type ( tmp , T_STRING ) ;\n len = RSTRING_LEN ( tmp ) ;\n state -> space_before = fstrndup ( RSTRING_PTR ( tmp ) , len + 1 ) ;\n state -> space_before_len = len ;\n }\n tmp = rb_hash_aref ( opts , ID2SYM ( i_array_nl ) ) ;\n if ( RTEST ( tmp ) ) {\n unsigned long len ;\n Check_Type ( tmp , T_STRING ) ;\n len = RSTRING_LEN ( tmp ) ;\n state -> array_nl = fstrndup ( RSTRING_PTR ( tmp ) , len + 1 ) ;\n state -> array_nl_len = len ;\n }\n tmp = rb_hash_aref ( opts , ID2SYM ( i_object_nl ) ) ;\n if ( RTEST ( tmp ) ) {\n unsigned long len ;\n Check_Type ( tmp , T_STRING ) ;\n len = RSTRING_LEN ( tmp ) ;\n state -> object_nl = fstrndup ( RSTRING_PTR ( tmp ) , len + 1 ) ;\n state -> object_nl_len = len ;\n }\n tmp = ID2SYM ( i_max_nesting ) ;\n state -> max_nesting = 100 ;\n if ( option_given_p ( opts , tmp ) ) {\n VALUE max_nesting = rb_hash_aref ( opts , tmp ) ;\n if ( RTEST ( max_nesting ) ) {\n Check_Type ( max_nesting , T_FIXNUM ) ;\n state -> max_nesting = FIX2LONG ( max_nesting ) ;\n }\n else {\n state -> max_nesting = 0 ;\n }\n }\n tmp = ID2SYM ( i_depth ) ;\n state -> depth = 0 ;\n if ( option_given_p ( opts , tmp ) ) {\n VALUE depth = rb_hash_aref ( opts , tmp ) ;\n if ( RTEST ( depth ) ) {\n Check_Type ( depth , T_FIXNUM ) ;\n state -> depth = FIX2LONG ( depth ) ;\n }\n else {\n state -> depth = 0 ;\n }\n }\n tmp = ID2SYM ( i_buffer_initial_length ) ;\n if ( option_given_p ( opts , tmp ) ) {\n VALUE buffer_initial_length = rb_hash_aref ( opts , tmp ) ;\n if ( RTEST ( buffer_initial_length ) ) {\n long initial_length ;\n Check_Type ( buffer_initial_length , T_FIXNUM ) ;\n initial_length = FIX2LONG ( buffer_initial_length ) ;\n if ( initial_length > 0 ) state -> buffer_initial_length = initial_length ;\n }\n }\n tmp = rb_hash_aref ( opts , ID2SYM ( i_allow_nan ) ) ;\n state -> allow_nan = RTEST ( tmp ) ;\n tmp = rb_hash_aref ( opts , ID2SYM ( i_ascii_only ) ) ;\n state -> ascii_only = RTEST ( tmp ) ;\n return self ;\n }", "idx": 20815}
{"hash": 1517008854954196408, "project": "debian", "size": 4, "label": 0, "functionSource": "static void mc_part ( H264Context * h , int n , int square , int height , int delta , uint8_t * dest_y , uint8_t * dest_cb , uint8_t * dest_cr , int x_offset , int y_offset , qpel_mc_func * qpix_put , h264_chroma_mc_func chroma_put , qpel_mc_func * qpix_avg , h264_chroma_mc_func chroma_avg , h264_weight_func * weight_op , h264_biweight_func * weight_avg , int list0 , int list1 ) {\n if ( ( h -> use_weight == 2 && list0 && list1 && ( h -> implicit_weight [ h -> ref_cache [ 0 ] [ scan8 [ n ] ] ] [ h -> ref_cache [ 1 ] [ scan8 [ n ] ] ] [ h -> mb_y & 1 ] != 32 ) ) || h -> use_weight == 1 ) mc_part_weighted ( h , n , square , height , delta , dest_y , dest_cb , dest_cr , x_offset , y_offset , qpix_put , chroma_put , weight_op [ 0 ] , weight_op [ 1 ] , weight_avg [ 0 ] , weight_avg [ 1 ] , list0 , list1 , PIXEL_SHIFT , CHROMA_IDC ) ;\n else mc_part_std ( h , n , square , height , delta , dest_y , dest_cb , dest_cr , x_offset , y_offset , qpix_put , chroma_put , qpix_avg , chroma_avg , list0 , list1 , PIXEL_SHIFT , CHROMA_IDC ) ;\n }", "idx": 20816}
{"hash": 4489017523191997023, "project": "debian", "size": 32, "label": 0, "functionSource": "static int dissect_h225_H245TransportAddress ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 556 \"./asn1/h225/h225.cnf\" h225_packet_info * h225_pi ;\n ipv4_address = 0 ;\n ipv6_address = ipv6_address_zeros ;\n ip_port = 0 ;\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_H245TransportAddress , H245TransportAddress_choice , NULL ) ;\n # line 564 \"./asn1/h225/h225.cnf\" h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;\n if ( h225_pi ) {\n h225_pi -> is_h245 = TRUE ;\n h225_pi -> h245_address = ipv4_address ;\n h225_pi -> h245_port = ip_port ;\n }\n if ( ! actx -> pinfo -> fd -> flags . visited && h245_handle && ip_port != 0 ) {\n address src_addr ;\n conversation_t * conv = NULL ;\n if ( ipv4_address != 0 ) {\n set_address ( & src_addr , AT_IPv4 , 4 , & ipv4_address ) ;\n }\n else if ( memcmp ( ipv6_address . bytes , ipv6_address_zeros . bytes , sizeof ( ipv6_address . bytes ) ) != 0 ) {\n set_address ( & src_addr , AT_IPv6 , 16 , ipv6_address . bytes ) ;\n }\n else {\n return offset ;\n }\n conv = find_conversation ( actx -> pinfo -> num , & src_addr , & src_addr , PT_TCP , ip_port , ip_port , NO_ADDR_B | NO_PORT_B ) ;\n if ( ! conv ) {\n conv = conversation_new ( actx -> pinfo -> num , & src_addr , & src_addr , PT_TCP , ip_port , ip_port , NO_ADDR2 | NO_PORT2 ) ;\n conversation_set_dissector ( conv , h245_handle ) ;\n }\n }\n return offset ;\n }", "idx": 20817}
{"hash": -6126432314261451839, "project": "debian", "size": 4, "label": 0, "functionSource": "int gx_finish_output_page ( gx_device * dev , int num_copies , int flush ) {\n dev -> PageCount += num_copies ;\n return 0 ;\n }", "idx": 20818}
{"hash": -3384986069176965684, "project": "chrome", "size": 7, "label": 0, "functionSource": "int vp8_reverse_trans ( int x ) {\n int i ;\n for ( i = 0 ;\n i < 64 ;\n i ++ ) if ( q_trans [ i ] >= x ) return i ;\n return 63 ;\n }", "idx": 20819}
{"hash": 8484475213808847345, "project": "debian", "size": 8, "label": 0, "functionSource": "void qdev_set_nic_properties ( DeviceState * dev , NICInfo * nd ) {\n qdev_prop_set_macaddr ( dev , \"mac\" , nd -> macaddr ) ;\n if ( nd -> vlan ) qdev_prop_set_vlan ( dev , \"vlan\" , nd -> vlan ) ;\n if ( nd -> netdev ) qdev_prop_set_netdev ( dev , \"netdev\" , nd -> netdev ) ;\n if ( nd -> nvectors != NIC_NVECTORS_UNSPECIFIED && qdev_prop_exists ( dev , \"vectors\" ) ) {\n qdev_prop_set_uint32 ( dev , \"vectors\" , nd -> nvectors ) ;\n }\n }", "idx": 20820}
{"hash": -5493081488206619677, "project": "debian", "size": 81, "label": 0, "functionSource": "void init_directory_config ( directory_config * dcfg ) {\n if ( dcfg == NULL ) return ;\n if ( dcfg -> is_enabled == NOT_SET ) dcfg -> is_enabled = 0 ;\n if ( dcfg -> reqbody_access == NOT_SET ) dcfg -> reqbody_access = 0 ;\n if ( dcfg -> reqintercept_oe == NOT_SET ) dcfg -> reqintercept_oe = 0 ;\n if ( dcfg -> reqbody_buffering == NOT_SET ) dcfg -> reqbody_buffering = REQUEST_BODY_FORCEBUF_OFF ;\n if ( dcfg -> reqbody_inmemory_limit == NOT_SET ) dcfg -> reqbody_inmemory_limit = REQUEST_BODY_DEFAULT_INMEMORY_LIMIT ;\n if ( dcfg -> reqbody_limit == NOT_SET ) dcfg -> reqbody_limit = REQUEST_BODY_DEFAULT_LIMIT ;\n if ( dcfg -> reqbody_no_files_limit == NOT_SET ) dcfg -> reqbody_no_files_limit = REQUEST_BODY_NO_FILES_DEFAULT_LIMIT ;\n if ( dcfg -> resbody_access == NOT_SET ) dcfg -> resbody_access = 0 ;\n if ( dcfg -> of_limit == NOT_SET ) dcfg -> of_limit = RESPONSE_BODY_DEFAULT_LIMIT ;\n if ( dcfg -> if_limit_action == NOT_SET ) dcfg -> if_limit_action = REQUEST_BODY_LIMIT_ACTION_REJECT ;\n if ( dcfg -> of_limit_action == NOT_SET ) dcfg -> of_limit_action = RESPONSE_BODY_LIMIT_ACTION_REJECT ;\n if ( dcfg -> of_mime_types == NOT_SET_P ) {\n dcfg -> of_mime_types = apr_table_make ( dcfg -> mp , 3 ) ;\n if ( dcfg -> of_mime_types_cleared != 1 ) {\n apr_table_setn ( dcfg -> of_mime_types , \"text/plain\" , \"1\" ) ;\n apr_table_setn ( dcfg -> of_mime_types , \"text/html\" , \"1\" ) ;\n }\n }\n if ( dcfg -> debuglog_fd == NOT_SET_P ) dcfg -> debuglog_fd = NULL ;\n if ( dcfg -> debuglog_name == NOT_SET_P ) dcfg -> debuglog_name = NULL ;\n if ( dcfg -> debuglog_level == NOT_SET ) dcfg -> debuglog_level = 0 ;\n if ( dcfg -> cookie_format == NOT_SET ) dcfg -> cookie_format = 0 ;\n if ( dcfg -> argument_separator == NOT_SET ) dcfg -> argument_separator = '&' ;\n if ( dcfg -> cookiev0_separator == NOT_SET_P ) dcfg -> cookiev0_separator = NULL ;\n if ( dcfg -> rule_inheritance == NOT_SET ) dcfg -> rule_inheritance = 1 ;\n if ( dcfg -> auditlog_flag == NOT_SET ) dcfg -> auditlog_flag = 0 ;\n if ( dcfg -> auditlog_type == NOT_SET ) dcfg -> auditlog_type = AUDITLOG_SERIAL ;\n if ( dcfg -> max_rule_time == NOT_SET ) dcfg -> max_rule_time = 0 ;\n if ( dcfg -> auditlog_dirperms == NOT_SET ) dcfg -> auditlog_dirperms = CREATEMODE_DIR ;\n if ( dcfg -> auditlog_fileperms == NOT_SET ) dcfg -> auditlog_fileperms = CREATEMODE ;\n if ( dcfg -> auditlog_fd == NOT_SET_P ) dcfg -> auditlog_fd = NULL ;\n if ( dcfg -> auditlog2_fd == NOT_SET_P ) dcfg -> auditlog2_fd = NULL ;\n if ( dcfg -> auditlog_name == NOT_SET_P ) dcfg -> auditlog_name = NULL ;\n if ( dcfg -> auditlog2_name == NOT_SET_P ) dcfg -> auditlog2_name = NULL ;\n if ( dcfg -> auditlog_storage_dir == NOT_SET_P ) dcfg -> auditlog_storage_dir = NULL ;\n if ( dcfg -> auditlog_parts == NOT_SET_P ) dcfg -> auditlog_parts = \"ABCFHZ\" ;\n if ( dcfg -> auditlog_relevant_regex == NOT_SET_P ) dcfg -> auditlog_relevant_regex = NULL ;\n if ( dcfg -> tmp_dir == NOT_SET_P ) dcfg -> tmp_dir = guess_tmp_dir ( dcfg -> mp ) ;\n if ( dcfg -> upload_dir == NOT_SET_P ) dcfg -> upload_dir = NULL ;\n if ( dcfg -> upload_keep_files == NOT_SET ) dcfg -> upload_keep_files = KEEP_FILES_OFF ;\n if ( dcfg -> upload_validates_files == NOT_SET ) dcfg -> upload_validates_files = 0 ;\n if ( dcfg -> upload_filemode == NOT_SET ) dcfg -> upload_filemode = 0600 ;\n if ( dcfg -> upload_file_limit == NOT_SET ) dcfg -> upload_file_limit = 100 ;\n if ( dcfg -> data_dir == NOT_SET_P ) dcfg -> data_dir = NULL ;\n if ( dcfg -> webappid == NOT_SET_P ) dcfg -> webappid = \"default\" ;\n if ( dcfg -> sensor_id == NOT_SET_P ) dcfg -> sensor_id = \"default\" ;\n if ( dcfg -> httpBlkey == NOT_SET_P ) dcfg -> httpBlkey = NULL ;\n if ( dcfg -> content_injection_enabled == NOT_SET ) dcfg -> content_injection_enabled = 0 ;\n if ( dcfg -> stream_inbody_inspection == NOT_SET ) dcfg -> stream_inbody_inspection = 0 ;\n if ( dcfg -> stream_outbody_inspection == NOT_SET ) dcfg -> stream_outbody_inspection = 0 ;\n if ( dcfg -> geo == NOT_SET_P ) dcfg -> geo = NULL ;\n if ( dcfg -> gsb == NOT_SET_P ) dcfg -> gsb = NULL ;\n if ( dcfg -> u_map == NOT_SET_P ) dcfg -> u_map = NULL ;\n if ( dcfg -> cache_trans == NOT_SET ) dcfg -> cache_trans = MODSEC_CACHE_DISABLED ;\n if ( dcfg -> cache_trans_incremental == NOT_SET ) dcfg -> cache_trans_incremental = 0 ;\n if ( dcfg -> cache_trans_min == ( apr_size_t ) NOT_SET ) dcfg -> cache_trans_min = 32 ;\n if ( dcfg -> cache_trans_max == ( apr_size_t ) NOT_SET ) dcfg -> cache_trans_max = 1024 ;\n if ( dcfg -> cache_trans_maxitems == ( apr_size_t ) NOT_SET ) dcfg -> cache_trans_maxitems = 512 ;\n if ( dcfg -> request_encoding == NOT_SET_P ) dcfg -> request_encoding = NULL ;\n if ( dcfg -> disable_backend_compression == NOT_SET ) dcfg -> disable_backend_compression = 0 ;\n if ( dcfg -> col_timeout == NOT_SET ) dcfg -> col_timeout = 3600 ;\n if ( dcfg -> crypto_key == NOT_SET_P ) dcfg -> crypto_key = getkey ( dcfg -> mp ) ;\n if ( dcfg -> crypto_key_len == NOT_SET ) dcfg -> crypto_key_len = strlen ( dcfg -> crypto_key ) ;\n if ( dcfg -> crypto_key_add == NOT_SET ) dcfg -> crypto_key_add = HASH_KEYONLY ;\n if ( dcfg -> crypto_param_name == NOT_SET_P ) dcfg -> crypto_param_name = \"crypt\" ;\n if ( dcfg -> hash_is_enabled == NOT_SET ) dcfg -> hash_is_enabled = HASH_DISABLED ;\n if ( dcfg -> hash_enforcement == NOT_SET ) dcfg -> hash_enforcement = HASH_DISABLED ;\n if ( dcfg -> crypto_hash_href_rx == NOT_SET ) dcfg -> crypto_hash_href_rx = 0 ;\n if ( dcfg -> crypto_hash_faction_rx == NOT_SET ) dcfg -> crypto_hash_faction_rx = 0 ;\n if ( dcfg -> crypto_hash_location_rx == NOT_SET ) dcfg -> crypto_hash_location_rx = 0 ;\n if ( dcfg -> crypto_hash_iframesrc_rx == NOT_SET ) dcfg -> crypto_hash_iframesrc_rx = 0 ;\n if ( dcfg -> crypto_hash_framesrc_rx == NOT_SET ) dcfg -> crypto_hash_framesrc_rx = 0 ;\n if ( dcfg -> crypto_hash_href_pm == NOT_SET ) dcfg -> crypto_hash_href_pm = 0 ;\n if ( dcfg -> crypto_hash_faction_pm == NOT_SET ) dcfg -> crypto_hash_faction_pm = 0 ;\n if ( dcfg -> crypto_hash_location_pm == NOT_SET ) dcfg -> crypto_hash_location_pm = 0 ;\n if ( dcfg -> crypto_hash_iframesrc_pm == NOT_SET ) dcfg -> crypto_hash_iframesrc_pm = 0 ;\n if ( dcfg -> crypto_hash_framesrc_pm == NOT_SET ) dcfg -> crypto_hash_framesrc_pm = 0 ;\n if ( dcfg -> xml_external_entity == NOT_SET ) dcfg -> xml_external_entity = 0 ;\n }", "idx": 20821}
{"hash": 7719745392319831548, "project": "chrome", "size": 8, "label": 0, "functionSource": "void vp9_save_layer_context ( VP9_COMP * const cpi ) {\n const VP9EncoderConfig * const oxcf = & cpi -> oxcf ;\n LAYER_CONTEXT * const lc = get_layer_context ( cpi ) ;\n lc -> rc = cpi -> rc ;\n lc -> twopass = cpi -> twopass ;\n lc -> target_bandwidth = ( int ) oxcf -> target_bandwidth ;\n lc -> alt_ref_source = cpi -> alt_ref_source ;\n }", "idx": 20822}
{"hash": 4489017523191997023, "project": "debian", "size": 9, "label": 1, "functionSource": "static int dissect_h225_T_empty_flg ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 375 \"./asn1/h225/h225.cnf\" h225_packet_info * h225_pi ;\n offset = dissect_per_null ( tvb , offset , actx , tree , hf_index ) ;\n # line 379 \"./asn1/h225/h225.cnf\" h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;\n if ( h225_pi != NULL ) {\n h225_pi -> cs_type = H225_EMPTY ;\n }\n return offset ;\n }", "idx": 20823}
{"hash": -3292234626779322843, "project": "chrome", "size": 72, "label": 1, "functionSource": "TEST ( AutocompleteMatchTest , Duplicates ) {\n struct DuplicateCases {\n const wchar_t * input ;\n const std : : string url1 ;\n const std : : string url2 ;\n const bool expected_duplicate ;\n }\n cases [ ] = {\n {\n L\"g\" , \"http://www.google.com/\" , \"https://www.google.com/\" , true }\n , {\n L\"g\" , \"http://www.google.com/\" , \"http://www.google.com\" , true }\n , {\n L\"g\" , \"http://google.com/\" , \"http://www.google.com/\" , true }\n , {\n L\"g\" , \"http://www.google.com/\" , \"HTTP://www.GOOGLE.com/\" , true }\n , {\n L\"g\" , \"http://www.google.com/\" , \"http://www.google.com\" , true }\n , {\n L\"g\" , \"https://www.google.com/\" , \"http://google.com\" , true }\n , {\n L\"g\" , \"http://www.google.com/\" , \"wss://www.google.com/\" , false }\n , {\n L\"g\" , \"http://www.google.com/1\" , \"http://www.google.com/1/\" , false }\n , {\n L\"g\" , \"http://www.google.com/\" , \"http://www.google.com/1\" , false }\n , {\n L\"g\" , \"http://www.google.com/\" , \"http://www.goo.com/\" , false }\n , {\n L\"g\" , \"http://www.google.com/\" , \"http://w2.google.com/\" , false }\n , {\n L\"g\" , \"http://www.google.com/\" , \"http://m.google.com/\" , false }\n , {\n L\"g\" , \"http://www.google.com/\" , \"http://www.google.com/?foo\" , false }\n , {\n L\"http://g\" , \"http://google.com/\" , \"https://google.com/\" , false }\n , {\n L\"http://g\" , \"http://blah.com/\" , \"https://blah.com/\" , true }\n , {\n L\"http://g\" , \"http://google.com/1\" , \"https://google.com/1\" , false }\n , {\n L\"http://g hello\" , \"http://google.com/\" , \"https://google.com/\" , false }\n , {\n L\"hello http://g\" , \"http://google.com/\" , \"https://google.com/\" , false }\n , {\n L\"hello http://g\" , \"http://blah.com/\" , \"https://blah.com/\" , true }\n , {\n L\"http://b http://g\" , \"http://google.com/\" , \"https://google.com/\" , false }\n , {\n L\"http://b http://g\" , \"http://blah.com/\" , \"https://blah.com/\" , false }\n , {\n L\"x\" , \"http://xn--1lq90ic7f1rc.cn/\" , \"https://xn--1lq90ic7f1rc.cn/\" , true }\n , {\n L\"http://\\x5317 x\" , \"http://xn--1lq90ic7f1rc.cn/\" , \"https://xn--1lq90ic7f1rc.cn/\" , false }\n , {\n L\"http://\\x89c6 x\" , \"http://xn--1lq90ic7f1rc.cn/\" , \"https://xn--1lq90ic7f1rc.cn/\" , true }\n , }\n ;\n for ( size_t i = 0 ;\n i < arraysize ( cases ) ;\n ++ i ) {\n SCOPED_TRACE ( \"input=\" + base : : WideToUTF8 ( cases [ i ] . input ) + \" url1=\" + cases [ i ] . url1 + \" url2=\" + cases [ i ] . url2 ) ;\n AutocompleteInput input ( base : : WideToUTF16 ( cases [ i ] . input ) , base : : string16 : : npos , std : : string ( ) , GURL ( ) , metrics : : OmniboxEventProto : : INVALID_SPEC , false , false , true , true , false , TestSchemeClassifier ( ) ) ;\n AutocompleteMatch m1 ( NULL , 100 , false , AutocompleteMatchType : : URL_WHAT_YOU_TYPED ) ;\n m1 . destination_url = GURL ( cases [ i ] . url1 ) ;\n m1 . ComputeStrippedDestinationURL ( input , \"zh-CN\" , NULL ) ;\n AutocompleteMatch m2 ( NULL , 100 , false , AutocompleteMatchType : : URL_WHAT_YOU_TYPED ) ;\n m2 . destination_url = GURL ( cases [ i ] . url2 ) ;\n m2 . ComputeStrippedDestinationURL ( input , \"zh-CN\" , NULL ) ;\n EXPECT_EQ ( cases [ i ] . expected_duplicate , AutocompleteMatch : : DestinationsEqual ( m1 , m2 ) ) ;\n }\n }", "idx": 20824}
{"hash": 8947170728280515149, "project": "debian", "size": 14, "label": 0, "functionSource": "static void copyarray ( struct pskeydict * to , struct pskeydict * from , struct garbage * tofrees ) {\n int i ;\n struct pskeyval * oldent = from -> entries ;\n * to = * from ;\n to -> entries = calloc ( to -> cnt , sizeof ( struct pskeyval ) ) ;\n for ( i = 0 ;\n i < to -> cnt ;\n ++ i ) {\n to -> entries [ i ] = oldent [ i ] ;\n if ( to -> entries [ i ] . type == ps_string || to -> entries [ i ] . type == ps_instr || to -> entries [ i ] . type == ps_lit ) to -> entries [ i ] . u . str = copy ( to -> entries [ i ] . u . str ) ;\n else if ( to -> entries [ i ] . type == ps_array || to -> entries [ i ] . type == ps_dict ) copyarray ( & to -> entries [ i ] . u . dict , & oldent [ i ] . u . dict , tofrees ) ;\n }\n collectgarbage ( tofrees , to ) ;\n }", "idx": 20825}
{"hash": 2542574915000171973, "project": "chrome", "size": 3, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( VirtualKeyboardBrowserTest , ControlKeysTest ) {\n RunTest ( base : : FilePath ( FILE_PATH_LITERAL ( \"control_keys_test.js\" ) ) ) ;\n }", "idx": 20826}
{"hash": 2930500905204315787, "project": "debian", "size": 3, "label": 1, "functionSource": "static __always_inline __le32 __cpu_to_le32p ( const __u32 * p ) {\n return ( __le32 ) * p ;\n }", "idx": 20827}
{"hash": 7279312193592248512, "project": "debian", "size": 20, "label": 0, "functionSource": "static void intra_pred_plane ( uint8_t * d , uint8_t * top , uint8_t * left , int stride ) {\n int x , y , ia ;\n int ih = 0 ;\n int iv = 0 ;\n uint8_t * cm = ff_cropTbl + MAX_NEG_CROP ;\n for ( x = 0 ;\n x < 4 ;\n x ++ ) {\n ih += ( x + 1 ) * ( top [ 5 + x ] - top [ 3 - x ] ) ;\n iv += ( x + 1 ) * ( left [ 5 + x ] - left [ 3 - x ] ) ;\n }\n ia = ( top [ 8 ] + left [ 8 ] ) << 4 ;\n ih = ( 17 * ih + 16 ) >> 5 ;\n iv = ( 17 * iv + 16 ) >> 5 ;\n for ( y = 0 ;\n y < 8 ;\n y ++ ) for ( x = 0 ;\n x < 8 ;\n x ++ ) d [ y * stride + x ] = cm [ ( ia + ( x - 3 ) * ih + ( y - 3 ) * iv + 16 ) >> 5 ] ;\n }", "idx": 20828}
{"hash": 7651945086108393719, "project": "debian", "size": 11, "label": 0, "functionSource": "int qemuMonitorJSONEjectMedia ( qemuMonitorPtr mon , const char * dev_name , bool force ) {\n int ret ;\n virJSONValuePtr cmd = qemuMonitorJSONMakeCommand ( \"eject\" , \"s:device\" , dev_name , \"b:force\" , force ? 1 : 0 , NULL ) ;\n virJSONValuePtr reply = NULL ;\n if ( ! cmd ) return - 1 ;\n ret = qemuMonitorJSONCommand ( mon , cmd , & reply ) ;\n if ( ret == 0 ) ret = qemuMonitorJSONCheckError ( cmd , reply ) ;\n virJSONValueFree ( cmd ) ;\n virJSONValueFree ( reply ) ;\n return ret ;\n }", "idx": 20829}
{"hash": -2226094829431805196, "project": "debian", "size": 70, "label": 0, "functionSource": "static int jpc_pi_nextcprl ( register jpc_pi_t * pi ) {\n int rlvlno ;\n jpc_pirlvl_t * pirlvl ;\n jpc_pchg_t * pchg ;\n int prchind ;\n int prcvind ;\n int * prclyrno ;\n uint_fast32_t trx0 ;\n uint_fast32_t try0 ;\n uint_fast32_t r ;\n uint_fast32_t rpx ;\n uint_fast32_t rpy ;\n pchg = pi -> pchg ;\n if ( ! pi -> prgvolfirst ) {\n goto skip ;\n }\n else {\n pi -> prgvolfirst = 0 ;\n }\n for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ;\n pi -> compno < JAS_CAST ( int , pchg -> compnoend ) && pi -> compno < pi -> numcomps ;\n ++ pi -> compno , ++ pi -> picomp ) {\n pirlvl = pi -> picomp -> pirlvls ;\n pi -> xstep = pi -> picomp -> hsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls - 1 ) ) ;\n pi -> ystep = pi -> picomp -> vsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcheightexpn + pi -> picomp -> numrlvls - 1 ) ) ;\n for ( rlvlno = 1 , pirlvl = & pi -> picomp -> pirlvls [ 1 ] ;\n rlvlno < pi -> picomp -> numrlvls ;\n ++ rlvlno , ++ pirlvl ) {\n pi -> xstep = JAS_MIN ( pi -> xstep , pi -> picomp -> hsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls - rlvlno - 1 ) ) ) ;\n pi -> ystep = JAS_MIN ( pi -> ystep , pi -> picomp -> vsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcheightexpn + pi -> picomp -> numrlvls - rlvlno - 1 ) ) ) ;\n }\n for ( pi -> y = pi -> ystart ;\n pi -> y < pi -> yend ;\n pi -> y += pi -> ystep - ( pi -> y % pi -> ystep ) ) {\n for ( pi -> x = pi -> xstart ;\n pi -> x < pi -> xend ;\n pi -> x += pi -> xstep - ( pi -> x % pi -> xstep ) ) {\n for ( pi -> rlvlno = pchg -> rlvlnostart , pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ;\n pi -> rlvlno < pi -> picomp -> numrlvls && pi -> rlvlno < pchg -> rlvlnoend ;\n ++ pi -> rlvlno , ++ pi -> pirlvl ) {\n if ( pi -> pirlvl -> numprcs == 0 ) {\n continue ;\n }\n r = pi -> picomp -> numrlvls - 1 - pi -> rlvlno ;\n trx0 = JPC_CEILDIV ( pi -> xstart , pi -> picomp -> hsamp << r ) ;\n try0 = JPC_CEILDIV ( pi -> ystart , pi -> picomp -> vsamp << r ) ;\n rpx = r + pi -> pirlvl -> prcwidthexpn ;\n rpy = r + pi -> pirlvl -> prcheightexpn ;\n if ( ( ( pi -> x == pi -> xstart && ( ( trx0 << r ) % ( 1 << rpx ) ) ) || ! ( pi -> x % ( pi -> picomp -> hsamp << rpx ) ) ) && ( ( pi -> y == pi -> ystart && ( ( try0 << r ) % ( 1 << rpy ) ) ) || ! ( pi -> y % ( pi -> picomp -> vsamp << rpy ) ) ) ) {\n prchind = JPC_FLOORDIVPOW2 ( JPC_CEILDIV ( pi -> x , pi -> picomp -> hsamp << r ) , pi -> pirlvl -> prcwidthexpn ) - JPC_FLOORDIVPOW2 ( trx0 , pi -> pirlvl -> prcwidthexpn ) ;\n prcvind = JPC_FLOORDIVPOW2 ( JPC_CEILDIV ( pi -> y , pi -> picomp -> vsamp << r ) , pi -> pirlvl -> prcheightexpn ) - JPC_FLOORDIVPOW2 ( try0 , pi -> pirlvl -> prcheightexpn ) ;\n pi -> prcno = prcvind * pi -> pirlvl -> numhprcs + prchind ;\n assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ;\n for ( pi -> lyrno = 0 ;\n pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ;\n ++ pi -> lyrno ) {\n prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ;\n if ( pi -> lyrno >= * prclyrno ) {\n ++ ( * prclyrno ) ;\n return 0 ;\n }\n skip : ;\n }\n }\n }\n }\n }\n }\n return 1 ;\n }", "idx": 20830}
{"hash": -3889154245145551951, "project": "debian", "size": 13, "label": 0, "functionSource": "static struct object_entry * insert_object ( unsigned char * sha1 ) {\n unsigned int h = sha1 [ 0 ] << 8 | sha1 [ 1 ] ;\n struct object_entry * e = object_table [ h ] ;\n while ( e ) {\n if ( ! hashcmp ( sha1 , e -> idx . sha1 ) ) return e ;\n e = e -> next ;\n }\n e = new_object ( sha1 ) ;\n e -> next = object_table [ h ] ;\n e -> idx . offset = 0 ;\n object_table [ h ] = e ;\n return e ;\n }", "idx": 20831}
{"hash": -2908211205972632000, "project": "debian", "size": 14, "label": 0, "functionSource": "static int try_rshrink_left ( MAIN_WINDOW_REC * window , int count ) {\n MAIN_WINDOW_REC * shrink_win ;\n shrink_win = mainwindows_find_left ( window , FALSE ) ;\n if ( shrink_win != NULL ) {\n if ( MAIN_WINDOW_TEXT_WIDTH ( shrink_win ) - count < NEW_WINDOW_WIDTH ) {\n return FALSE ;\n }\n window -> first_column -= count ;\n shrink_win -> last_column -= count ;\n mainwindows_rresize_two ( window , shrink_win , count ) ;\n return TRUE ;\n }\n return FALSE ;\n }", "idx": 20832}
{"hash": 3599206110384554647, "project": "debian", "size": 39, "label": 1, "functionSource": "static ossl_inline t2 * sk_ ## t1 ## _pop ( STACK_OF ( t1 ) * sk ) {\n return ( t2 * ) OPENSSL_sk_pop ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _shift ( STACK_OF ( t1 ) * sk ) {\n return ( t2 * ) OPENSSL_sk_shift ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline void sk_ ## t1 ## _pop_free ( STACK_OF ( t1 ) * sk , sk_ ## t1 ## _freefunc freefunc ) {\n OPENSSL_sk_pop_free ( ( OPENSSL_STACK * ) sk , ( OPENSSL_sk_freefunc ) freefunc ) ;\n }\n static ossl_inline int sk_ ## t1 ## _insert ( STACK_OF ( t1 ) * sk , t2 * ptr , int idx ) {\n return OPENSSL_sk_insert ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr , idx ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _set ( STACK_OF ( t1 ) * sk , int idx , t2 * ptr ) {\n return ( t2 * ) OPENSSL_sk_set ( ( OPENSSL_STACK * ) sk , idx , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _find ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_find ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _find_ex ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_find_ex ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline void sk_ ## t1 ## _sort ( STACK_OF ( t1 ) * sk ) {\n OPENSSL_sk_sort ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline int sk_ ## t1 ## _is_sorted ( const STACK_OF ( t1 ) * sk ) {\n return OPENSSL_sk_is_sorted ( ( const OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _dup ( const STACK_OF ( t1 ) * sk ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_dup ( ( const OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _deep_copy ( const STACK_OF ( t1 ) * sk , sk_ ## t1 ## _copyfunc copyfunc , sk_ ## t1 ## _freefunc freefunc ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_deep_copy ( ( const OPENSSL_STACK * ) sk , ( OPENSSL_sk_copyfunc ) copyfunc , ( OPENSSL_sk_freefunc ) freefunc ) ;\n }\n static ossl_inline sk_ ## t1 ## _compfunc sk_ ## t1 ## _set_cmp_func ( STACK_OF ( t1 ) * sk , sk_ ## t1 ## _compfunc compare ) {\n return ( sk_ ## t1 ## _compfunc ) OPENSSL_sk_set_cmp_func ( ( OPENSSL_STACK * ) sk , ( OPENSSL_sk_compfunc ) compare ) ;\n }\n # define DEFINE_SPECIAL_STACK_OF ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , t2 , t2 ) # define DEFINE_STACK_OF ( t ) SKM_DEFINE_STACK_OF ( t , t , t ) # define DEFINE_SPECIAL_STACK_OF_CONST ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , const t2 , t2 ) # define DEFINE_STACK_OF_CONST ( t ) SKM_DEFINE_STACK_OF ( t , const t , t ) typedef char * OPENSSL_STRING ;\n typedef const char * OPENSSL_CSTRING ;\n DEFINE_SPECIAL_STACK_OF ( OPENSSL_STRING , char )", "idx": 20833}
{"hash": 5991533509192663951, "project": "debian", "size": 73, "label": 0, "functionSource": "const mbfl_encoding * mbfl_identify_encoding ( mbfl_string * string , enum mbfl_no_encoding * elist , int elistsz , int strict ) {\n int i , n , num , bad ;\n unsigned char * p ;\n mbfl_identify_filter * flist , * filter ;\n const mbfl_encoding * encoding ;\n flist = ( mbfl_identify_filter * ) mbfl_calloc ( elistsz , sizeof ( mbfl_identify_filter ) ) ;\n if ( flist == NULL ) {\n return NULL ;\n }\n num = 0 ;\n if ( elist != NULL ) {\n for ( i = 0 ;\n i < elistsz ;\n i ++ ) {\n if ( ! mbfl_identify_filter_init ( & flist [ num ] , elist [ i ] ) ) {\n num ++ ;\n }\n }\n }\n n = string -> len ;\n p = string -> val ;\n if ( p != NULL ) {\n bad = 0 ;\n while ( n > 0 ) {\n for ( i = 0 ;\n i < num ;\n i ++ ) {\n filter = & flist [ i ] ;\n if ( ! filter -> flag ) {\n ( * filter -> filter_function ) ( * p , filter ) ;\n if ( filter -> flag ) {\n bad ++ ;\n }\n }\n }\n if ( ( num - 1 ) <= bad && ! strict ) {\n break ;\n }\n p ++ ;\n n -- ;\n }\n }\n encoding = NULL ;\n for ( i = 0 ;\n i < num ;\n i ++ ) {\n filter = & flist [ i ] ;\n if ( ! filter -> flag ) {\n if ( strict && filter -> status ) {\n continue ;\n }\n encoding = filter -> encoding ;\n break ;\n }\n }\n if ( ! encoding ) {\n for ( i = 0 ;\n i < num ;\n i ++ ) {\n filter = & flist [ i ] ;\n if ( ! filter -> flag && ( ! strict || ! filter -> status ) ) {\n encoding = filter -> encoding ;\n break ;\n }\n }\n }\n i = num ;\n while ( -- i >= 0 ) {\n mbfl_identify_filter_cleanup ( & flist [ i ] ) ;\n }\n mbfl_free ( ( void * ) flist ) ;\n return encoding ;\n }", "idx": 20834}
{"hash": -2625033791912996344, "project": "debian", "size": 28, "label": 0, "functionSource": "static int rv30_decode_intra_types ( RV34DecContext * r , GetBitContext * gb , int8_t * dst ) {\n int i , j , k ;\n for ( i = 0 ;\n i < 4 ;\n i ++ , dst += r -> intra_types_stride - 4 ) {\n for ( j = 0 ;\n j < 4 ;\n j += 2 ) {\n unsigned code = svq3_get_ue_golomb ( gb ) << 1 ;\n if ( code >= 81 * 2 ) {\n av_log ( r -> s . avctx , AV_LOG_ERROR , \"Incorrect intra prediction code\\n\" ) ;\n return - 1 ;\n }\n for ( k = 0 ;\n k < 2 ;\n k ++ ) {\n int A = dst [ - r -> intra_types_stride ] + 1 ;\n int B = dst [ - 1 ] + 1 ;\n * dst ++ = rv30_itype_from_context [ A * 90 + B * 9 + rv30_itype_code [ code + k ] ] ;\n if ( dst [ - 1 ] == 9 ) {\n av_log ( r -> s . avctx , AV_LOG_ERROR , \"Incorrect intra prediction mode\\n\" ) ;\n return - 1 ;\n }\n }\n }\n }\n return 0 ;\n }", "idx": 20835}
{"hash": 5360072031850965731, "project": "debian", "size": 5, "label": 0, "functionSource": "static void ppc_prep_reset ( void * opaque ) {\n PowerPCCPU * cpu = opaque ;\n cpu_reset ( CPU ( cpu ) ) ;\n cpu -> env . nip = 0xfffffffc ;\n }", "idx": 20836}
{"hash": -1919011628477388936, "project": "debian", "size": 55, "label": 0, "functionSource": "static void IRQ_local_pipe ( OpenPICState * opp , int n_CPU , int n_IRQ , bool active , bool was_active ) {\n IRQDest * dst ;\n IRQSource * src ;\n int priority ;\n dst = & opp -> dst [ n_CPU ] ;\n src = & opp -> src [ n_IRQ ] ;\n DPRINTF ( \"%s: IRQ %d active %d was %d\\n\" , __func__ , n_IRQ , active , was_active ) ;\n if ( src -> output != OPENPIC_OUTPUT_INT ) {\n DPRINTF ( \"%s: output %d irq %d active %d was %d count %d\\n\" , __func__ , src -> output , n_IRQ , active , was_active , dst -> outputs_active [ src -> output ] ) ;\n if ( active ) {\n if ( ! was_active && dst -> outputs_active [ src -> output ] ++ == 0 ) {\n DPRINTF ( \"%s: Raise OpenPIC output %d cpu %d irq %d\\n\" , __func__ , src -> output , n_CPU , n_IRQ ) ;\n qemu_irq_raise ( dst -> irqs [ src -> output ] ) ;\n }\n }\n else {\n if ( was_active && -- dst -> outputs_active [ src -> output ] == 0 ) {\n DPRINTF ( \"%s: Lower OpenPIC output %d cpu %d irq %d\\n\" , __func__ , src -> output , n_CPU , n_IRQ ) ;\n qemu_irq_lower ( dst -> irqs [ src -> output ] ) ;\n }\n }\n return ;\n }\n priority = IVPR_PRIORITY ( src -> ivpr ) ;\n if ( active ) {\n IRQ_setbit ( & dst -> raised , n_IRQ ) ;\n }\n else {\n IRQ_resetbit ( & dst -> raised , n_IRQ ) ;\n }\n IRQ_check ( opp , & dst -> raised ) ;\n if ( active && priority <= dst -> ctpr ) {\n DPRINTF ( \"%s: IRQ %d priority %d too low for ctpr %d on CPU %d\\n\" , __func__ , n_IRQ , priority , dst -> ctpr , n_CPU ) ;\n active = 0 ;\n }\n if ( active ) {\n if ( IRQ_get_next ( opp , & dst -> servicing ) >= 0 && priority <= dst -> servicing . priority ) {\n DPRINTF ( \"%s: IRQ %d is hidden by servicing IRQ %d on CPU %d\\n\" , __func__ , n_IRQ , dst -> servicing . next , n_CPU ) ;\n }\n else {\n DPRINTF ( \"%s: Raise OpenPIC INT output cpu %d irq %d/%d\\n\" , __func__ , n_CPU , n_IRQ , dst -> raised . next ) ;\n qemu_irq_raise ( opp -> dst [ n_CPU ] . irqs [ OPENPIC_OUTPUT_INT ] ) ;\n }\n }\n else {\n IRQ_get_next ( opp , & dst -> servicing ) ;\n if ( dst -> raised . priority > dst -> ctpr && dst -> raised . priority > dst -> servicing . priority ) {\n DPRINTF ( \"%s: IRQ %d inactive, IRQ %d prio %d above %d/%d, CPU %d\\n\" , __func__ , n_IRQ , dst -> raised . next , dst -> raised . priority , dst -> ctpr , dst -> servicing . priority , n_CPU ) ;\n }\n else {\n DPRINTF ( \"%s: IRQ %d inactive, current prio %d/%d, CPU %d\\n\" , __func__ , n_IRQ , dst -> ctpr , dst -> servicing . priority , n_CPU ) ;\n qemu_irq_lower ( opp -> dst [ n_CPU ] . irqs [ OPENPIC_OUTPUT_INT ] ) ;\n }\n }\n }", "idx": 20837}
{"hash": -1983921383858884161, "project": "debian", "size": 15, "label": 1, "functionSource": "static int ipvideo_decode_block_opcode_0xC_16 ( IpvideoContext * s ) {\n int x , y ;\n uint16_t * pixel_ptr = ( uint16_t * ) s -> pixel_ptr ;\n for ( y = 0 ;\n y < 8 ;\n y += 2 ) {\n for ( x = 0 ;\n x < 8 ;\n x += 2 ) {\n pixel_ptr [ x ] = pixel_ptr [ x + 1 ] = pixel_ptr [ x + s -> stride ] = pixel_ptr [ x + 1 + s -> stride ] = bytestream2_get_le16 ( & s -> stream_ptr ) ;\n }\n pixel_ptr += s -> stride * 2 ;\n }\n return 0 ;\n }", "idx": 20838}
{"hash": -7510820116196812813, "project": "chrome", "size": 7, "label": 0, "functionSource": "static void fixup ( UScriptRun * scriptRun , UScriptCode scriptCode ) {\n int32_t fixupSP = DEC ( scriptRun -> parenSP , scriptRun -> fixupCount ) ;\n while ( scriptRun -> fixupCount -- > 0 ) {\n fixupSP = INC1 ( fixupSP ) ;\n scriptRun -> parenStack [ fixupSP ] . scriptCode = scriptCode ;\n }\n }", "idx": 20839}
{"hash": 4180964683905830761, "project": "debian", "size": 5, "label": 0, "functionSource": "static void msg_msg_free_security ( struct msg_msg * msg ) {\n struct msg_security_struct * msec = msg -> security ;\n msg -> security = NULL ;\n kfree ( msec ) ;\n }", "idx": 20840}
{"hash": -1111775978048960297, "project": "chrome", "size": 8, "label": 0, "functionSource": "TEST_F ( BrowsingDataRemoverImplTest , RemoveDownloadsByOrigin ) {\n RemoveDownloadsTester tester ( GetBrowserContext ( ) ) ;\n std : : unique_ptr < BrowsingDataFilterBuilder > builder ( BrowsingDataFilterBuilder : : Create ( BrowsingDataFilterBuilder : : WHITELIST ) ) ;\n builder -> AddRegisterableDomain ( kTestRegisterableDomain1 ) ;\n base : : Callback < bool ( const GURL & ) > filter = builder -> BuildGeneralFilter ( ) ;\n EXPECT_CALL ( * tester . download_manager ( ) , RemoveDownloadsByURLAndTime ( ProbablySameFilter ( filter ) , _ , _ ) ) ;\n BlockUntilOriginDataRemoved ( base : : Time ( ) , base : : Time : : Max ( ) , BrowsingDataRemover : : REMOVE_DOWNLOADS , std : : move ( builder ) ) ;\n }", "idx": 20841}
{"hash": -8884965407551053630, "project": "debian", "size": 40, "label": 0, "functionSource": "static void DecoderProcess ( decoder_t * p_dec , block_t * p_block ) {\n decoder_owner_sys_t * p_owner = ( decoder_owner_sys_t * ) p_dec -> p_owner ;\n const bool b_flush_request = p_block && ( p_block -> i_flags & BLOCK_FLAG_CORE_FLUSH ) ;\n if ( p_dec -> b_error ) {\n if ( p_block ) block_Release ( p_block ) ;\n goto flush ;\n }\n if ( p_block && p_block -> i_buffer <= 0 ) {\n assert ( ! b_flush_request ) ;\n block_Release ( p_block ) ;\n return ;\n }\n # ifdef ENABLE_SOUT if ( p_owner -> b_packetizer ) {\n if ( p_block ) p_block -> i_flags &= ~ BLOCK_FLAG_CORE_PRIVATE_MASK ;\n DecoderProcessSout ( p_dec , p_block ) ;\n }\n else # endif {\n bool b_flush = false ;\n if ( p_block ) {\n const bool b_flushing = p_owner -> i_preroll_end == INT64_MAX ;\n DecoderUpdatePreroll ( & p_owner -> i_preroll_end , p_block ) ;\n b_flush = ! b_flushing && b_flush_request ;\n p_block -> i_flags &= ~ BLOCK_FLAG_CORE_PRIVATE_MASK ;\n }\n if ( p_dec -> fmt_out . i_cat == AUDIO_ES ) {\n DecoderProcessAudio ( p_dec , p_block , b_flush ) ;\n }\n else if ( p_dec -> fmt_out . i_cat == VIDEO_ES ) {\n DecoderProcessVideo ( p_dec , p_block , b_flush ) ;\n }\n else if ( p_dec -> fmt_out . i_cat == SPU_ES ) {\n DecoderProcessSpu ( p_dec , p_block , b_flush ) ;\n }\n else {\n msg_Err ( p_dec , \"unknown ES format\" ) ;\n p_dec -> b_error = true ;\n }\n }\n flush : if ( b_flush_request ) DecoderProcessOnFlush ( p_dec ) ;\n }", "idx": 20842}
{"hash": -3165961362620712443, "project": "chrome", "size": 22, "label": 0, "functionSource": "static void * data_create_indic ( const hb_ot_shape_plan_t * plan ) {\n indic_shape_plan_t * indic_plan = ( indic_shape_plan_t * ) calloc ( 1 , sizeof ( indic_shape_plan_t ) ) ;\n if ( unlikely ( ! indic_plan ) ) return NULL ;\n indic_plan -> config = & indic_configs [ 0 ] ;\n for ( unsigned int i = 1 ;\n i < ARRAY_LENGTH ( indic_configs ) ;\n i ++ ) if ( plan -> props . script == indic_configs [ i ] . script ) {\n indic_plan -> config = & indic_configs [ i ] ;\n break ;\n }\n indic_plan -> is_old_spec = indic_plan -> config -> has_old_spec && ( ( plan -> map . chosen_script [ 0 ] & 0x000000FFu ) != '2' ) ;\n indic_plan -> virama_glyph = ( hb_codepoint_t ) - 1 ;\n bool zero_context = ! indic_plan -> is_old_spec ;\n indic_plan -> rphf . init ( & plan -> map , HB_TAG ( 'r' , 'p' , 'h' , 'f' ) , zero_context ) ;\n indic_plan -> pref . init ( & plan -> map , HB_TAG ( 'p' , 'r' , 'e' , 'f' ) , zero_context ) ;\n indic_plan -> blwf . init ( & plan -> map , HB_TAG ( 'b' , 'l' , 'w' , 'f' ) , zero_context ) ;\n indic_plan -> pstf . init ( & plan -> map , HB_TAG ( 'p' , 's' , 't' , 'f' ) , zero_context ) ;\n for ( unsigned int i = 0 ;\n i < ARRAY_LENGTH ( indic_plan -> mask_array ) ;\n i ++ ) indic_plan -> mask_array [ i ] = ( indic_features [ i ] . flags & F_GLOBAL ) ? : plan -> map . get_1_mask ( indic_features [ i ] . tag ) ;\n return indic_plan ;\n }", "idx": 20843}
{"hash": -6215323349888018447, "project": "debian", "size": 30, "label": 1, "functionSource": "static void dumpDatabases ( PGconn * conn ) {\n PGresult * res ;\n int i ;\n if ( server_version >= 70100 ) res = executeQuery ( conn , \"SELECT datname FROM pg_database WHERE datallowconn ORDER BY 1\" ) ;\n else res = executeQuery ( conn , \"SELECT datname FROM pg_database ORDER BY 1\" ) ;\n for ( i = 0 ;\n i < PQntuples ( res ) ;\n i ++ ) {\n int ret ;\n char * dbname = PQgetvalue ( res , i , 0 ) ;\n if ( verbose ) fprintf ( stderr , _ ( \"%s: dumping database \\\"%s\\\"...\\n\" ) , progname , dbname ) ;\n fprintf ( OPF , \"\\\\connect %s\\n\\n\" , fmtId ( dbname ) ) ;\n fprintf ( OPF , \"SET default_transaction_read_only = off;\n\\n\\n\" ) ;\n if ( filename ) fclose ( OPF ) ;\n ret = runPgDump ( dbname ) ;\n if ( ret != 0 ) {\n fprintf ( stderr , _ ( \"%s: pg_dump failed on database \\\"%s\\\", exiting\\n\" ) , progname , dbname ) ;\n exit_nicely ( 1 ) ;\n }\n if ( filename ) {\n OPF = fopen ( filename , PG_BINARY_A ) ;\n if ( ! OPF ) {\n fprintf ( stderr , _ ( \"%s: could not re-open the output file \\\"%s\\\": %s\\n\" ) , progname , filename , strerror ( errno ) ) ;\n exit_nicely ( 1 ) ;\n }\n }\n }\n PQclear ( res ) ;\n }", "idx": 20844}
{"hash": -8199454075838226273, "project": "debian", "size": 11, "label": 0, "functionSource": "static gint dissect_rtmpt_body_command ( tvbuff_t * tvb , gint offset , proto_tree * rtmpt_tree , gboolean amf3 ) {\n gboolean amf3_encoding = FALSE ;\n if ( amf3 ) {\n offset ++ ;\n }\n while ( tvb_reported_length_remaining ( tvb , offset ) > 0 ) {\n if ( amf3_encoding ) offset = dissect_amf3_value_type ( tvb , offset , rtmpt_tree , NULL ) ;\n else offset = dissect_amf0_value_type ( tvb , offset , rtmpt_tree , & amf3_encoding , NULL ) ;\n }\n return offset ;\n }", "idx": 20845}
{"hash": -8029592471297395650, "project": "debian", "size": 4, "label": 1, "functionSource": "static void decode_flush ( AVCodecContext * avctx ) {\n KgvContext * const c = avctx -> priv_data ;\n if ( c -> prev . data [ 0 ] ) avctx -> release_buffer ( avctx , & c -> prev ) ;\n }", "idx": 20846}
{"hash": 1223258652239369123, "project": "debian", "size": 33, "label": 0, "functionSource": "static spl_filesystem_object * spl_filesystem_object_create_info ( spl_filesystem_object * source , char * file_path , int file_path_len , int use_copy , zend_class_entry * ce , zval * return_value TSRMLS_DC ) {\n spl_filesystem_object * intern ;\n zval * arg1 ;\n zend_error_handling error_handling ;\n if ( ! file_path || ! file_path_len ) {\n # if defined ( PHP_WIN32 ) zend_throw_exception_ex ( spl_ce_RuntimeException , 0 TSRMLS_CC , \"Cannot create SplFileInfo for empty path\" ) ;\n if ( file_path && ! use_copy ) {\n efree ( file_path ) ;\n }\n # else if ( file_path && ! use_copy ) {\n efree ( file_path ) ;\n }\n file_path_len = 1 ;\n file_path = \"/\" ;\n # endif return NULL ;\n }\n zend_replace_error_handling ( EH_THROW , spl_ce_RuntimeException , & error_handling TSRMLS_CC ) ;\n ce = ce ? ce : source -> info_class ;\n zend_update_class_constants ( ce TSRMLS_CC ) ;\n return_value -> value . obj = spl_filesystem_object_new_ex ( ce , & intern TSRMLS_CC ) ;\n Z_TYPE_P ( return_value ) = IS_OBJECT ;\n if ( ce -> constructor -> common . scope != spl_ce_SplFileInfo ) {\n MAKE_STD_ZVAL ( arg1 ) ;\n ZVAL_STRINGL ( arg1 , file_path , file_path_len , use_copy ) ;\n zend_call_method_with_1_params ( & return_value , ce , & ce -> constructor , \"__construct\" , NULL , arg1 ) ;\n zval_ptr_dtor ( & arg1 ) ;\n }\n else {\n spl_filesystem_info_set_filename ( intern , file_path , file_path_len , use_copy TSRMLS_CC ) ;\n }\n zend_restore_error_handling ( & error_handling TSRMLS_CC ) ;\n return intern ;\n }", "idx": 20847}
{"hash": -6215323349888018447, "project": "debian", "size": 20, "label": 0, "functionSource": "static void dropRoles ( PGconn * conn ) {\n PGresult * res ;\n int i_rolname ;\n int i ;\n if ( server_version >= 90600 ) res = executeQuery ( conn , \"SELECT rolname \" \"FROM pg_authid \" \"WHERE rolname !~ '^pg_' \" \"ORDER BY 1\" ) ;\n else if ( server_version >= 80100 ) res = executeQuery ( conn , \"SELECT rolname \" \"FROM pg_authid \" \"ORDER BY 1\" ) ;\n else res = executeQuery ( conn , \"SELECT usename as rolname \" \"FROM pg_shadow \" \"UNION \" \"SELECT groname as rolname \" \"FROM pg_group \" \"ORDER BY 1\" ) ;\n i_rolname = PQfnumber ( res , \"rolname\" ) ;\n if ( PQntuples ( res ) > 0 ) fprintf ( OPF , \"--\\n-- Drop roles\\n--\\n\\n\" ) ;\n for ( i = 0 ;\n i < PQntuples ( res ) ;\n i ++ ) {\n const char * rolename ;\n rolename = PQgetvalue ( res , i , i_rolname ) ;\n fprintf ( OPF , \"DROP ROLE %s%s;\n\\n\" , if_exists ? \"IF EXISTS \" : \"\" , fmtId ( rolename ) ) ;\n }\n PQclear ( res ) ;\n fprintf ( OPF , \"\\n\\n\" ) ;\n }", "idx": 20848}
{"hash": -3299391226809811274, "project": "debian", "size": 7, "label": 0, "functionSource": "void qemuAgentNotifyClose ( qemuAgentPtr mon ) {\n if ( ! mon ) return ;\n VIR_DEBUG ( \"mon=%p\" , mon ) ;\n virObjectLock ( mon ) ;\n qemuAgentNotifyCloseLocked ( mon ) ;\n virObjectUnlock ( mon ) ;\n }", "idx": 20849}
{"hash": 7549435794356072684, "project": "debian", "size": 4, "label": 0, "functionSource": "static VALUE ossl_asn1_ ## klass ( int argc , VALUE * argv , VALUE self ) \\ {\n return rb_funcall3 ( cASN1 ## klass , rb_intern ( \"new\" ) , argc , argv ) ;\n }\n OSSL_ASN1_IMPL_FACTORY_METHOD ( Boolean ) OSSL_ASN1_IMPL_FACTORY_METHOD ( Integer ) OSSL_ASN1_IMPL_FACTORY_METHOD ( Enumerated ) OSSL_ASN1_IMPL_FACTORY_METHOD ( BitString ) OSSL_ASN1_IMPL_FACTORY_METHOD ( OctetString ) OSSL_ASN1_IMPL_FACTORY_METHOD ( UTF8String ) OSSL_ASN1_IMPL_FACTORY_METHOD ( NumericString ) OSSL_ASN1_IMPL_FACTORY_METHOD ( PrintableString ) OSSL_ASN1_IMPL_FACTORY_METHOD ( T61String ) OSSL_ASN1_IMPL_FACTORY_METHOD ( VideotexString ) OSSL_ASN1_IMPL_FACTORY_METHOD ( IA5String ) OSSL_ASN1_IMPL_FACTORY_METHOD ( GraphicString ) OSSL_ASN1_IMPL_FACTORY_METHOD ( ISO64String ) OSSL_ASN1_IMPL_FACTORY_METHOD ( GeneralString ) OSSL_ASN1_IMPL_FACTORY_METHOD ( UniversalString )", "idx": 20850}
{"hash": -2323311514228246061, "project": "chrome", "size": 38, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( DownloadExtensionTest , DownloadExtensionTest_OnDeterminingFilename_IllegalFilename ) {\n GoOnTheRecord ( ) ;\n LoadExtension ( \"downloads_split\" ) ;\n AddFilenameDeterminer ( ) ;\n ASSERT_TRUE ( StartEmbeddedTestServer ( ) ) ;\n std : : string download_url = embedded_test_server ( ) -> GetURL ( \"/slow?0\" ) . spec ( ) ;\n std : : unique_ptr < base : : Value > result ( RunFunctionAndReturnResult ( new DownloadsDownloadFunction ( ) , base : : StringPrintf ( \"[{\n\\\"url\\\": \\\"%s\\\"}\n]\" , download_url . c_str ( ) ) ) ) ;\n ASSERT_TRUE ( result . get ( ) ) ;\n int result_id = - 1 ;\n ASSERT_TRUE ( result -> GetAsInteger ( & result_id ) ) ;\n DownloadItem * item = GetCurrentManager ( ) -> GetDownload ( result_id ) ;\n ASSERT_TRUE ( item ) ;\n ScopedCancellingItem canceller ( item ) ;\n ASSERT_EQ ( download_url , item -> GetOriginalUrl ( ) . spec ( ) ) ;\n ASSERT_TRUE ( WaitFor ( downloads : : OnCreated : : kEventName , base : : StringPrintf ( \"[{\n\\\"danger\\\": \\\"safe\\\",\" \" \\\"incognito\\\": false,\" \" \\\"id\\\": %d,\" \" \\\"mime\\\": \\\"text/plain\\\",\" \" \\\"paused\\\": false,\" \" \\\"url\\\": \\\"%s\\\"}\n]\" , result_id , download_url . c_str ( ) ) ) ) ;\n ASSERT_TRUE ( WaitFor ( downloads : : OnDeterminingFilename : : kEventName , base : : StringPrintf ( \"[{\n\\\"id\\\": %d,\" \" \\\"filename\\\":\\\"slow.txt\\\"}\n]\" , result_id ) ) ) ;\n ASSERT_TRUE ( item -> GetTargetFilePath ( ) . empty ( ) ) ;\n ASSERT_EQ ( DownloadItem : : IN_PROGRESS , item -> GetState ( ) ) ;\n std : : string error ;\n ASSERT_FALSE ( ExtensionDownloadsEventRouter : : DetermineFilename ( browser ( ) -> profile ( ) , false , GetExtensionId ( ) , result_id , base : : FilePath ( FILE_PATH_LITERAL ( \"<\" ) ) , downloads : : FILENAME_CONFLICT_ACTION_UNIQUIFY , & error ) ) ;\n EXPECT_STREQ ( errors : : kInvalidFilename , error . c_str ( ) ) ;\n ASSERT_TRUE ( WaitFor ( downloads : : OnChanged : : kEventName , base : : StringPrintf ( \"[{\n\\\"id\\\": %d,\" \" \\\"filename\\\": {\n\" \" \\\"previous\\\": \\\"\\\",\" \" \\\"current\\\": \\\"%s\\\"}\n}\n]\" , result_id , GetFilename ( \"slow.txt\" ) . c_str ( ) ) ) ) ;\n ASSERT_TRUE ( WaitFor ( downloads : : OnChanged : : kEventName , base : : StringPrintf ( \"[{\n\\\"id\\\": %d,\" \" \\\"state\\\": {\n\" \" \\\"previous\\\": \\\"in_progress\\\",\" \" \\\"current\\\": \\\"complete\\\"}\n}\n]\" , result_id ) ) ) ;\n }", "idx": 20851}
{"hash": 1981604082870872490, "project": "chrome", "size": 9, "label": 0, "functionSource": "static int32_t u_printf_simple_percent_handler ( const u_printf_stream_handler * handler , void * context , ULocaleBundle * formatBundle , const u_printf_spec_info * info , const ufmt_args * args ) {\n ( void ) formatBundle ;\n ( void ) info ;\n ( void ) args ;\n static const UChar PERCENT [ ] = {\n UP_PERCENT }\n ;\n return handler -> write ( context , PERCENT , 1 ) ;\n }", "idx": 20852}
{"hash": -8721757784652752372, "project": "debian", "size": 14, "label": 0, "functionSource": "static int jpc_calcssmant ( jpc_fix_t stepsize ) {\n int n ;\n int e ;\n int m ;\n n = jpc_firstone ( stepsize ) ;\n e = n - JPC_FIX_FRACBITS ;\n if ( n >= 11 ) {\n m = ( stepsize >> ( n - 11 ) ) & 0x7ff ;\n }\n else {\n m = ( stepsize & ( ( 1 << n ) - 1 ) ) << ( 11 - n ) ;\n }\n return m ;\n }", "idx": 20853}
{"hash": -7434014980763120366, "project": "debian", "size": 6, "label": 0, "functionSource": "static void ber_populate_list ( const gchar * table_name _U_ , decode_as_add_to_list_func add_to_list , gpointer ui_element ) {\n struct ber_decode_as_populate populate ;\n populate . add_to_list = add_to_list ;\n populate . ui_element = ui_element ;\n ber_decode_as_foreach ( decode_ber_add_to_list , & populate ) ;\n }", "idx": 20854}
{"hash": 3071315158823512715, "project": "debian", "size": 15, "label": 0, "functionSource": "static void ac3_upmix_delay ( AC3DecodeContext * s ) {\n int channel_data_size = sizeof ( s -> delay [ 0 ] ) ;\n switch ( s -> channel_mode ) {\n case AC3_CHMODE_DUALMONO : case AC3_CHMODE_STEREO : memcpy ( s -> delay [ 1 ] , s -> delay [ 0 ] , channel_data_size ) ;\n break ;\n case AC3_CHMODE_2F2R : memset ( s -> delay [ 3 ] , 0 , channel_data_size ) ;\n case AC3_CHMODE_2F1R : memset ( s -> delay [ 2 ] , 0 , channel_data_size ) ;\n break ;\n case AC3_CHMODE_3F2R : memset ( s -> delay [ 4 ] , 0 , channel_data_size ) ;\n case AC3_CHMODE_3F1R : memset ( s -> delay [ 3 ] , 0 , channel_data_size ) ;\n case AC3_CHMODE_3F : memcpy ( s -> delay [ 2 ] , s -> delay [ 1 ] , channel_data_size ) ;\n memset ( s -> delay [ 1 ] , 0 , channel_data_size ) ;\n break ;\n }\n }", "idx": 20855}
{"hash": -2740750333757361388, "project": "debian", "size": 42, "label": 0, "functionSource": "static void truespeech_place_pulses ( TSContext * dec , int16_t * out , int quart ) {\n int16_t tmp [ 7 ] ;\n int i , j , t ;\n const int16_t * ptr1 ;\n int16_t * ptr2 ;\n int coef ;\n memset ( out , 0 , 60 * sizeof ( * out ) ) ;\n for ( i = 0 ;\n i < 7 ;\n i ++ ) {\n t = dec -> pulseval [ quart ] & 3 ;\n dec -> pulseval [ quart ] >>= 2 ;\n tmp [ 6 - i ] = ts_pulse_scales [ dec -> pulseoff [ quart ] * 4 + t ] ;\n }\n coef = dec -> pulsepos [ quart ] >> 15 ;\n ptr1 = ts_pulse_values + 30 ;\n ptr2 = tmp ;\n for ( i = 0 , j = 3 ;\n ( i < 30 ) && ( j > 0 ) ;\n i ++ ) {\n t = * ptr1 ++ ;\n if ( coef >= t ) coef -= t ;\n else {\n out [ i ] = * ptr2 ++ ;\n ptr1 += 30 ;\n j -- ;\n }\n }\n coef = dec -> pulsepos [ quart ] & 0x7FFF ;\n ptr1 = ts_pulse_values ;\n for ( i = 30 , j = 4 ;\n ( i < 60 ) && ( j > 0 ) ;\n i ++ ) {\n t = * ptr1 ++ ;\n if ( coef >= t ) coef -= t ;\n else {\n out [ i ] = * ptr2 ++ ;\n ptr1 += 30 ;\n j -- ;\n }\n }\n }", "idx": 20856}
{"hash": 4489017523191997023, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h225_NumberDigits ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_restricted_character_string ( tvb , offset , actx , tree , hf_index , 1 , 128 , FALSE , \"0123456789#*,\" , 13 , NULL ) ;\n return offset ;\n }", "idx": 20857}
{"hash": 3728341105073176576, "project": "debian", "size": 28, "label": 1, "functionSource": "static ossl_inline int lh_ ## type ## _error ( LHASH_OF ( type ) * lh ) {\n return OPENSSL_LH_error ( ( OPENSSL_LHASH * ) lh ) ;\n }\n static ossl_inline unsigned long lh_ ## type ## _num_items ( LHASH_OF ( type ) * lh ) {\n return OPENSSL_LH_num_items ( ( OPENSSL_LHASH * ) lh ) ;\n }\n static ossl_inline void lh_ ## type ## _node_stats_bio ( const LHASH_OF ( type ) * lh , BIO * out ) {\n OPENSSL_LH_node_stats_bio ( ( const OPENSSL_LHASH * ) lh , out ) ;\n }\n static ossl_inline void lh_ ## type ## _node_usage_stats_bio ( const LHASH_OF ( type ) * lh , BIO * out ) {\n OPENSSL_LH_node_usage_stats_bio ( ( const OPENSSL_LHASH * ) lh , out ) ;\n }\n static ossl_inline void lh_ ## type ## _stats_bio ( const LHASH_OF ( type ) * lh , BIO * out ) {\n OPENSSL_LH_stats_bio ( ( const OPENSSL_LHASH * ) lh , out ) ;\n }\n static ossl_inline unsigned long lh_ ## type ## _get_down_load ( LHASH_OF ( type ) * lh ) {\n return OPENSSL_LH_get_down_load ( ( OPENSSL_LHASH * ) lh ) ;\n }\n static ossl_inline void lh_ ## type ## _set_down_load ( LHASH_OF ( type ) * lh , unsigned long dl ) {\n OPENSSL_LH_set_down_load ( ( OPENSSL_LHASH * ) lh , dl ) ;\n }\n static ossl_inline void lh_ ## type ## _doall ( LHASH_OF ( type ) * lh , void ( * doall ) ( type * ) ) {\n OPENSSL_LH_doall ( ( OPENSSL_LHASH * ) lh , ( OPENSSL_LH_DOALL_FUNC ) doall ) ;\n }\n LHASH_OF ( type ) # define IMPLEMENT_LHASH_DOALL_ARG_CONST ( type , argtype ) int_implement_lhash_doall ( type , argtype , const type ) # define IMPLEMENT_LHASH_DOALL_ARG ( type , argtype ) int_implement_lhash_doall ( type , argtype , type ) # define int_implement_lhash_doall ( type , argtype , cbargtype ) static ossl_inline void lh_ ## type ## _doall_ ## argtype ( LHASH_OF ( type ) * lh , void ( * fn ) ( cbargtype * , argtype * ) , argtype * arg ) {\n OPENSSL_LH_doall_arg ( ( OPENSSL_LHASH * ) lh , ( OPENSSL_LH_DOALL_FUNCARG ) fn , ( void * ) arg ) ;\n }\n LHASH_OF ( type ) DEFINE_LHASH_OF ( OPENSSL_STRING )", "idx": 20858}
{"hash": 2064081176034684128, "project": "debian", "size": 19, "label": 0, "functionSource": "static int ebml_parse_nest ( MatroskaDemuxContext * matroska , EbmlSyntax * syntax , void * data ) {\n int i , res = 0 ;\n for ( i = 0 ;\n syntax [ i ] . id ;\n i ++ ) switch ( syntax [ i ] . type ) {\n case EBML_UINT : * ( uint64_t * ) ( ( char * ) data + syntax [ i ] . data_offset ) = syntax [ i ] . def . u ;\n break ;\n case EBML_FLOAT : * ( double * ) ( ( char * ) data + syntax [ i ] . data_offset ) = syntax [ i ] . def . f ;\n break ;\n case EBML_STR : case EBML_UTF8 : if ( syntax [ i ] . def . s ) {\n uint8_t * * dst = ( uint8_t * * ) ( ( uint8_t * ) data + syntax [ i ] . data_offset ) ;\n * dst = av_strdup ( syntax [ i ] . def . s ) ;\n if ( ! * dst ) return AVERROR ( ENOMEM ) ;\n }\n break ;\n }\n while ( ! res && ! ebml_level_end ( matroska ) ) res = ebml_parse ( matroska , syntax , data ) ;\n return res ;\n }", "idx": 20859}
{"hash": 6393050609822897742, "project": "debian", "size": 13, "label": 0, "functionSource": "static USBEndpoint * xhci_epid_to_usbep ( XHCIEPContext * epctx ) {\n USBPort * uport ;\n uint32_t token ;\n if ( ! epctx ) {\n return NULL ;\n }\n uport = epctx -> xhci -> slots [ epctx -> slotid - 1 ] . uport ;\n token = ( epctx -> epid & 1 ) ? USB_TOKEN_IN : USB_TOKEN_OUT ;\n if ( ! uport ) {\n return NULL ;\n }\n return usb_ep_get ( uport -> dev , token , epctx -> epid >> 1 ) ;\n }", "idx": 20860}
{"hash": -7990991774694156606, "project": "debian", "size": 29, "label": 0, "functionSource": "static int read_huffman_tree ( AVCodecContext * avctx , GetBitContext * gb ) {\n Vp3DecodeContext * s = avctx -> priv_data ;\n if ( get_bits1 ( gb ) ) {\n int token ;\n if ( s -> entries >= 32 ) {\n av_log ( avctx , AV_LOG_ERROR , \"huffman tree overflow\\n\" ) ;\n return - 1 ;\n }\n token = get_bits ( gb , 5 ) ;\n av_dlog ( avctx , \"hti %d hbits %x token %d entry : %d size %d\\n\" , s -> hti , s -> hbits , token , s -> entries , s -> huff_code_size ) ;\n s -> huffman_table [ s -> hti ] [ token ] [ 0 ] = s -> hbits ;\n s -> huffman_table [ s -> hti ] [ token ] [ 1 ] = s -> huff_code_size ;\n s -> entries ++ ;\n }\n else {\n if ( s -> huff_code_size >= 32 ) {\n av_log ( avctx , AV_LOG_ERROR , \"huffman tree overflow\\n\" ) ;\n return - 1 ;\n }\n s -> huff_code_size ++ ;\n s -> hbits <<= 1 ;\n if ( read_huffman_tree ( avctx , gb ) ) return - 1 ;\n s -> hbits |= 1 ;\n if ( read_huffman_tree ( avctx , gb ) ) return - 1 ;\n s -> hbits >>= 1 ;\n s -> huff_code_size -- ;\n }\n return 0 ;\n }", "idx": 20861}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_MediaEncryptionAlgorithm ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_MediaEncryptionAlgorithm , MediaEncryptionAlgorithm_choice , NULL ) ;\n return offset ;\n }", "idx": 20862}
{"hash": -5082285935423529157, "project": "debian", "size": 14, "label": 0, "functionSource": "static int dissect_rsl_ie_timing_adv ( tvbuff_t * tvb , packet_info * pinfo _U_ , proto_tree * tree , int offset , gboolean is_mandatory ) {\n proto_tree * ie_tree ;\n guint8 ie_id ;\n if ( is_mandatory == FALSE ) {\n ie_id = tvb_get_guint8 ( tvb , offset ) ;\n if ( ie_id != RSL_IE_TIMING_ADV ) return offset ;\n }\n ie_tree = proto_tree_add_subtree ( tree , tvb , offset , 2 , ett_ie_timing_adv , NULL , \"Timing Advance IE\" ) ;\n proto_tree_add_item ( ie_tree , hf_rsl_ie_id , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n offset ++ ;\n proto_tree_add_item ( ie_tree , hf_rsl_timing_adv , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n offset ++ ;\n return offset ;\n }", "idx": 20863}
{"hash": 6632536031698733342, "project": "debian", "size": 174, "label": 1, "functionSource": "static int show_stream ( WriterContext * w , AVFormatContext * fmt_ctx , int stream_idx , InputStream * ist , int in_program ) {\n AVStream * stream = ist -> st ;\n AVCodecParameters * par ;\n AVCodecContext * dec_ctx ;\n char val_str [ 128 ] ;\n const char * s ;\n AVRational sar , dar ;\n AVBPrint pbuf ;\n const AVCodecDescriptor * cd ;\n int ret = 0 ;\n const char * profile = NULL ;\n av_bprint_init ( & pbuf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ;\n writer_print_section_header ( w , in_program ? SECTION_ID_PROGRAM_STREAM : SECTION_ID_STREAM ) ;\n print_int ( \"index\" , stream -> index ) ;\n par = stream -> codecpar ;\n dec_ctx = ist -> dec_ctx ;\n if ( cd = avcodec_descriptor_get ( par -> codec_id ) ) {\n print_str ( \"codec_name\" , cd -> name ) ;\n if ( ! do_bitexact ) {\n print_str ( \"codec_long_name\" , cd -> long_name ? cd -> long_name : \"unknown\" ) ;\n }\n }\n else {\n print_str_opt ( \"codec_name\" , \"unknown\" ) ;\n if ( ! do_bitexact ) {\n print_str_opt ( \"codec_long_name\" , \"unknown\" ) ;\n }\n }\n if ( ! do_bitexact && ( profile = avcodec_profile_name ( par -> codec_id , par -> profile ) ) ) print_str ( \"profile\" , profile ) ;\n else {\n if ( par -> profile != FF_PROFILE_UNKNOWN ) {\n char profile_num [ 12 ] ;\n snprintf ( profile_num , sizeof ( profile_num ) , \"%d\" , par -> profile ) ;\n print_str ( \"profile\" , profile_num ) ;\n }\n else print_str_opt ( \"profile\" , \"unknown\" ) ;\n }\n s = av_get_media_type_string ( par -> codec_type ) ;\n if ( s ) print_str ( \"codec_type\" , s ) ;\n else print_str_opt ( \"codec_type\" , \"unknown\" ) ;\n # if FF_API_LAVF_AVCTX if ( dec_ctx ) print_q ( \"codec_time_base\" , dec_ctx -> time_base , '/' ) ;\n # endif print_str ( \"codec_tag_string\" , av_fourcc2str ( par -> codec_tag ) ) ;\n print_fmt ( \"codec_tag\" , \"0x%04\" PRIx32 , par -> codec_tag ) ;\n switch ( par -> codec_type ) {\n case AVMEDIA_TYPE_VIDEO : print_int ( \"width\" , par -> width ) ;\n print_int ( \"height\" , par -> height ) ;\n if ( dec_ctx ) {\n print_int ( \"coded_width\" , dec_ctx -> coded_width ) ;\n print_int ( \"coded_height\" , dec_ctx -> coded_height ) ;\n }\n print_int ( \"has_b_frames\" , par -> video_delay ) ;\n sar = av_guess_sample_aspect_ratio ( fmt_ctx , stream , NULL ) ;\n if ( sar . den ) {\n print_q ( \"sample_aspect_ratio\" , sar , ':' ) ;\n av_reduce ( & dar . num , & dar . den , par -> width * sar . num , par -> height * sar . den , 1024 * 1024 ) ;\n print_q ( \"display_aspect_ratio\" , dar , ':' ) ;\n }\n else {\n print_str_opt ( \"sample_aspect_ratio\" , \"N/A\" ) ;\n print_str_opt ( \"display_aspect_ratio\" , \"N/A\" ) ;\n }\n s = av_get_pix_fmt_name ( par -> format ) ;\n if ( s ) print_str ( \"pix_fmt\" , s ) ;\n else print_str_opt ( \"pix_fmt\" , \"unknown\" ) ;\n print_int ( \"level\" , par -> level ) ;\n if ( par -> color_range != AVCOL_RANGE_UNSPECIFIED ) print_str ( \"color_range\" , av_color_range_name ( par -> color_range ) ) ;\n else print_str_opt ( \"color_range\" , \"N/A\" ) ;\n if ( par -> color_space != AVCOL_SPC_UNSPECIFIED ) print_str ( \"color_space\" , av_color_space_name ( par -> color_space ) ) ;\n else print_str_opt ( \"color_space\" , av_color_space_name ( par -> color_space ) ) ;\n if ( par -> color_trc != AVCOL_TRC_UNSPECIFIED ) print_str ( \"color_transfer\" , av_color_transfer_name ( par -> color_trc ) ) ;\n else print_str_opt ( \"color_transfer\" , av_color_transfer_name ( par -> color_trc ) ) ;\n if ( par -> color_primaries != AVCOL_PRI_UNSPECIFIED ) print_str ( \"color_primaries\" , av_color_primaries_name ( par -> color_primaries ) ) ;\n else print_str_opt ( \"color_primaries\" , av_color_primaries_name ( par -> color_primaries ) ) ;\n if ( par -> chroma_location != AVCHROMA_LOC_UNSPECIFIED ) print_str ( \"chroma_location\" , av_chroma_location_name ( par -> chroma_location ) ) ;\n else print_str_opt ( \"chroma_location\" , av_chroma_location_name ( par -> chroma_location ) ) ;\n if ( par -> field_order == AV_FIELD_PROGRESSIVE ) print_str ( \"field_order\" , \"progressive\" ) ;\n else if ( par -> field_order == AV_FIELD_TT ) print_str ( \"field_order\" , \"tt\" ) ;\n else if ( par -> field_order == AV_FIELD_BB ) print_str ( \"field_order\" , \"bb\" ) ;\n else if ( par -> field_order == AV_FIELD_TB ) print_str ( \"field_order\" , \"tb\" ) ;\n else if ( par -> field_order == AV_FIELD_BT ) print_str ( \"field_order\" , \"bt\" ) ;\n else print_str_opt ( \"field_order\" , \"unknown\" ) ;\n # if FF_API_PRIVATE_OPT if ( dec_ctx && dec_ctx -> timecode_frame_start >= 0 ) {\n char tcbuf [ AV_TIMECODE_STR_SIZE ] ;\n av_timecode_make_mpeg_tc_string ( tcbuf , dec_ctx -> timecode_frame_start ) ;\n print_str ( \"timecode\" , tcbuf ) ;\n }\n else {\n print_str_opt ( \"timecode\" , \"N/A\" ) ;\n }\n # endif if ( dec_ctx ) print_int ( \"refs\" , dec_ctx -> refs ) ;\n break ;\n case AVMEDIA_TYPE_AUDIO : s = av_get_sample_fmt_name ( par -> format ) ;\n if ( s ) print_str ( \"sample_fmt\" , s ) ;\n else print_str_opt ( \"sample_fmt\" , \"unknown\" ) ;\n print_val ( \"sample_rate\" , par -> sample_rate , unit_hertz_str ) ;\n print_int ( \"channels\" , par -> channels ) ;\n if ( par -> channel_layout ) {\n av_bprint_clear ( & pbuf ) ;\n av_bprint_channel_layout ( & pbuf , par -> channels , par -> channel_layout ) ;\n print_str ( \"channel_layout\" , pbuf . str ) ;\n }\n else {\n print_str_opt ( \"channel_layout\" , \"unknown\" ) ;\n }\n print_int ( \"bits_per_sample\" , av_get_bits_per_sample ( par -> codec_id ) ) ;\n break ;\n case AVMEDIA_TYPE_SUBTITLE : if ( par -> width ) print_int ( \"width\" , par -> width ) ;\n else print_str_opt ( \"width\" , \"N/A\" ) ;\n if ( par -> height ) print_int ( \"height\" , par -> height ) ;\n else print_str_opt ( \"height\" , \"N/A\" ) ;\n break ;\n }\n if ( dec_ctx && dec_ctx -> codec && dec_ctx -> codec -> priv_class && show_private_data ) {\n const AVOption * opt = NULL ;\n while ( opt = av_opt_next ( dec_ctx -> priv_data , opt ) ) {\n uint8_t * str ;\n if ( opt -> flags ) continue ;\n if ( av_opt_get ( dec_ctx -> priv_data , opt -> name , 0 , & str ) >= 0 ) {\n print_str ( opt -> name , str ) ;\n av_free ( str ) ;\n }\n }\n }\n if ( fmt_ctx -> iformat -> flags & AVFMT_SHOW_IDS ) print_fmt ( \"id\" , \"0x%x\" , stream -> id ) ;\n else print_str_opt ( \"id\" , \"N/A\" ) ;\n print_q ( \"r_frame_rate\" , stream -> r_frame_rate , '/' ) ;\n print_q ( \"avg_frame_rate\" , stream -> avg_frame_rate , '/' ) ;\n print_q ( \"time_base\" , stream -> time_base , '/' ) ;\n print_ts ( \"start_pts\" , stream -> start_time ) ;\n print_time ( \"start_time\" , stream -> start_time , & stream -> time_base ) ;\n print_ts ( \"duration_ts\" , stream -> duration ) ;\n print_time ( \"duration\" , stream -> duration , & stream -> time_base ) ;\n if ( par -> bit_rate > 0 ) print_val ( \"bit_rate\" , par -> bit_rate , unit_bit_per_second_str ) ;\n else print_str_opt ( \"bit_rate\" , \"N/A\" ) ;\n # if FF_API_LAVF_AVCTX if ( stream -> codec -> rc_max_rate > 0 ) print_val ( \"max_bit_rate\" , stream -> codec -> rc_max_rate , unit_bit_per_second_str ) ;\n else print_str_opt ( \"max_bit_rate\" , \"N/A\" ) ;\n # endif if ( dec_ctx && dec_ctx -> bits_per_raw_sample > 0 ) print_fmt ( \"bits_per_raw_sample\" , \"%d\" , dec_ctx -> bits_per_raw_sample ) ;\n else print_str_opt ( \"bits_per_raw_sample\" , \"N/A\" ) ;\n if ( stream -> nb_frames ) print_fmt ( \"nb_frames\" , \"%\" PRId64 , stream -> nb_frames ) ;\n else print_str_opt ( \"nb_frames\" , \"N/A\" ) ;\n if ( nb_streams_frames [ stream_idx ] ) print_fmt ( \"nb_read_frames\" , \"%\" PRIu64 , nb_streams_frames [ stream_idx ] ) ;\n else print_str_opt ( \"nb_read_frames\" , \"N/A\" ) ;\n if ( nb_streams_packets [ stream_idx ] ) print_fmt ( \"nb_read_packets\" , \"%\" PRIu64 , nb_streams_packets [ stream_idx ] ) ;\n else print_str_opt ( \"nb_read_packets\" , \"N/A\" ) ;\n if ( do_show_data ) writer_print_data ( w , \"extradata\" , par -> extradata , par -> extradata_size ) ;\n writer_print_data_hash ( w , \"extradata_hash\" , par -> extradata , par -> extradata_size ) ;\n # define PRINT_DISPOSITION ( flagname , name ) do {\n print_int ( name , ! ! ( stream -> disposition & AV_DISPOSITION_ ## flagname ) ) ;\n }\n while ( 0 ) if ( do_show_stream_disposition ) {\n writer_print_section_header ( w , in_program ? SECTION_ID_PROGRAM_STREAM_DISPOSITION : SECTION_ID_STREAM_DISPOSITION ) ;\n PRINT_DISPOSITION ( DEFAULT , \"default\" ) ;\n PRINT_DISPOSITION ( DUB , \"dub\" ) ;\n PRINT_DISPOSITION ( ORIGINAL , \"original\" ) ;\n PRINT_DISPOSITION ( COMMENT , \"comment\" ) ;\n PRINT_DISPOSITION ( LYRICS , \"lyrics\" ) ;\n PRINT_DISPOSITION ( KARAOKE , \"karaoke\" ) ;\n PRINT_DISPOSITION ( FORCED , \"forced\" ) ;\n PRINT_DISPOSITION ( HEARING_IMPAIRED , \"hearing_impaired\" ) ;\n PRINT_DISPOSITION ( VISUAL_IMPAIRED , \"visual_impaired\" ) ;\n PRINT_DISPOSITION ( CLEAN_EFFECTS , \"clean_effects\" ) ;\n PRINT_DISPOSITION ( ATTACHED_PIC , \"attached_pic\" ) ;\n PRINT_DISPOSITION ( TIMED_THUMBNAILS , \"timed_thumbnails\" ) ;\n writer_print_section_footer ( w ) ;\n }\n if ( do_show_stream_tags ) ret = show_tags ( w , stream -> metadata , in_program ? SECTION_ID_PROGRAM_STREAM_TAGS : SECTION_ID_STREAM_TAGS ) ;\n if ( stream -> nb_side_data ) {\n print_pkt_side_data ( w , stream -> codecpar , stream -> side_data , stream -> nb_side_data , SECTION_ID_STREAM_SIDE_DATA_LIST , SECTION_ID_STREAM_SIDE_DATA ) ;\n }\n writer_print_section_footer ( w ) ;\n av_bprint_finalize ( & pbuf , NULL ) ;\n fflush ( stdout ) ;\n return ret ;\n }", "idx": 20864}
{"hash": -5268859819325807498, "project": "debian", "size": 30, "label": 0, "functionSource": "static void count_more_files_callback ( GObject * source_object , GAsyncResult * res , gpointer user_data ) {\n DirectoryCountState * state ;\n NautilusDirectory * directory ;\n GError * error ;\n GList * files ;\n state = user_data ;\n directory = state -> directory ;\n if ( g_cancellable_is_cancelled ( state -> cancellable ) ) {\n async_job_end ( directory , \"directory count\" ) ;\n nautilus_directory_async_state_changed ( directory ) ;\n directory_count_state_free ( state ) ;\n return ;\n }\n g_assert ( directory -> details -> count_in_progress != NULL ) ;\n g_assert ( directory -> details -> count_in_progress == state ) ;\n error = NULL ;\n files = g_file_enumerator_next_files_finish ( state -> enumerator , res , & error ) ;\n state -> file_count += count_non_skipped_files ( files ) ;\n if ( files == NULL ) {\n count_children_done ( directory , state -> count_file , TRUE , state -> file_count ) ;\n directory_count_state_free ( state ) ;\n }\n else {\n g_file_enumerator_next_files_async ( state -> enumerator , DIRECTORY_LOAD_ITEMS_PER_CALLBACK , G_PRIORITY_DEFAULT , state -> cancellable , count_more_files_callback , state ) ;\n }\n g_list_free_full ( files , g_object_unref ) ;\n if ( error ) {\n g_error_free ( error ) ;\n }\n }", "idx": 20865}
{"hash": 2895622461494525400, "project": "debian", "size": 37, "label": 0, "functionSource": "static void test_derived ( ) {\n MYSQL_STMT * stmt ;\n int rc , i ;\n MYSQL_BIND my_bind [ 1 ] ;\n int32 my_val = 0 ;\n ulong my_length = 0L ;\n my_bool my_null = FALSE ;\n const char * query = \"select count(1) from (select f.id from t1 f where f.id=?) as x\" ;\n myheader ( \"test_derived\" ) ;\n rc = mysql_query ( mysql , \"DROP TABLE IF EXISTS t1\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"create table t1 (id int(8), primary key (id)) \\ ENGINE=InnoDB DEFAULT CHARSET=utf8\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"insert into t1 values (1)\" ) ;\n myquery ( rc ) ;\n stmt = mysql_simple_prepare ( mysql , query ) ;\n check_stmt ( stmt ) ;\n memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n my_bind [ 0 ] . buffer_type = MYSQL_TYPE_LONG ;\n my_bind [ 0 ] . buffer = ( void * ) & my_val ;\n my_bind [ 0 ] . length = & my_length ;\n my_bind [ 0 ] . is_null = ( char * ) & my_null ;\n my_val = 1 ;\n rc = mysql_stmt_bind_param ( stmt , my_bind ) ;\n check_execute ( stmt , rc ) ;\n for ( i = 0 ;\n i < 3 ;\n i ++ ) {\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n rc = my_process_stmt_result ( stmt ) ;\n DIE_UNLESS ( rc == 1 ) ;\n }\n mysql_stmt_close ( stmt ) ;\n rc = mysql_query ( mysql , \"DROP TABLE t1\" ) ;\n myquery ( rc ) ;\n }", "idx": 20866}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_T_routing ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_T_routing , T_routing_choice , NULL ) ;\n return offset ;\n }", "idx": 20867}
{"hash": 3804373597256531021, "project": "debian", "size": 30, "label": 0, "functionSource": "bool check_column_grant_in_table_ref ( THD * thd , TABLE_LIST * table_ref , const char * name , uint length ) {\n GRANT_INFO * grant ;\n const char * db_name ;\n const char * table_name ;\n Security_context * sctx = test ( table_ref -> security_ctx ) ? table_ref -> security_ctx : thd -> security_ctx ;\n if ( table_ref -> view || table_ref -> field_translation ) {\n ulong view_privs ;\n grant = & ( table_ref -> grant ) ;\n db_name = table_ref -> view_db . str ;\n table_name = table_ref -> view_name . str ;\n if ( table_ref -> belong_to_view && thd -> lex -> sql_command == SQLCOM_SHOW_FIELDS ) {\n view_privs = get_column_grant ( thd , grant , db_name , table_name , name ) ;\n if ( view_privs & VIEW_ANY_ACL ) {\n table_ref -> belong_to_view -> allowed_show = TRUE ;\n return FALSE ;\n }\n table_ref -> belong_to_view -> allowed_show = FALSE ;\n my_message ( ER_VIEW_NO_EXPLAIN , ER ( ER_VIEW_NO_EXPLAIN ) , MYF ( 0 ) ) ;\n return TRUE ;\n }\n }\n else {\n TABLE * table = table_ref -> table ;\n grant = & ( table -> grant ) ;\n db_name = table -> s -> db . str ;\n table_name = table -> s -> table_name . str ;\n }\n if ( grant -> want_privilege ) return check_grant_column ( thd , grant , db_name , table_name , name , length , sctx ) ;\n else return FALSE ;\n }", "idx": 20868}
{"hash": 58020529414140129, "project": "chrome", "size": 61, "label": 0, "functionSource": "void vp9_choose_segmap_coding_method ( VP9_COMMON * cm , MACROBLOCKD * xd ) {\n struct segmentation * seg = & cm -> seg ;\n int no_pred_cost ;\n int t_pred_cost = INT_MAX ;\n int i , tile_col , mi_row , mi_col ;\n int temporal_predictor_count [ PREDICTION_PROBS ] [ 2 ] = {\n {\n 0 }\n }\n ;\n int no_pred_segcounts [ MAX_SEGMENTS ] = {\n 0 }\n ;\n int t_unpred_seg_counts [ MAX_SEGMENTS ] = {\n 0 }\n ;\n vp9_prob no_pred_tree [ SEG_TREE_PROBS ] ;\n vp9_prob t_pred_tree [ SEG_TREE_PROBS ] ;\n vp9_prob t_nopred_prob [ PREDICTION_PROBS ] ;\n vpx_memset ( seg -> tree_probs , 255 , sizeof ( seg -> tree_probs ) ) ;\n vpx_memset ( seg -> pred_probs , 255 , sizeof ( seg -> pred_probs ) ) ;\n for ( tile_col = 0 ;\n tile_col < 1 << cm -> log2_tile_cols ;\n tile_col ++ ) {\n TileInfo tile ;\n MODE_INFO * mi_ptr ;\n vp9_tile_init ( & tile , cm , 0 , tile_col ) ;\n mi_ptr = cm -> mi + tile . mi_col_start ;\n for ( mi_row = 0 ;\n mi_row < cm -> mi_rows ;\n mi_row += 8 , mi_ptr += 8 * cm -> mi_stride ) {\n MODE_INFO * mi = mi_ptr ;\n for ( mi_col = tile . mi_col_start ;\n mi_col < tile . mi_col_end ;\n mi_col += 8 , mi += 8 ) count_segs_sb ( cm , xd , & tile , mi , no_pred_segcounts , temporal_predictor_count , t_unpred_seg_counts , mi_row , mi_col , BLOCK_64X64 ) ;\n }\n }\n calc_segtree_probs ( no_pred_segcounts , no_pred_tree ) ;\n no_pred_cost = cost_segmap ( no_pred_segcounts , no_pred_tree ) ;\n if ( ! frame_is_intra_only ( cm ) ) {\n calc_segtree_probs ( t_unpred_seg_counts , t_pred_tree ) ;\n t_pred_cost = cost_segmap ( t_unpred_seg_counts , t_pred_tree ) ;\n for ( i = 0 ;\n i < PREDICTION_PROBS ;\n i ++ ) {\n const int count0 = temporal_predictor_count [ i ] [ 0 ] ;\n const int count1 = temporal_predictor_count [ i ] [ 1 ] ;\n t_nopred_prob [ i ] = get_binary_prob ( count0 , count1 ) ;\n t_pred_cost += count0 * vp9_cost_zero ( t_nopred_prob [ i ] ) + count1 * vp9_cost_one ( t_nopred_prob [ i ] ) ;\n }\n }\n if ( t_pred_cost < no_pred_cost ) {\n seg -> temporal_update = 1 ;\n vpx_memcpy ( seg -> tree_probs , t_pred_tree , sizeof ( t_pred_tree ) ) ;\n vpx_memcpy ( seg -> pred_probs , t_nopred_prob , sizeof ( t_nopred_prob ) ) ;\n }\n else {\n seg -> temporal_update = 0 ;\n vpx_memcpy ( seg -> tree_probs , no_pred_tree , sizeof ( no_pred_tree ) ) ;\n }\n }", "idx": 20869}
{"hash": 355220887711506893, "project": "debian", "size": 14, "label": 1, "functionSource": "extern int name ( int ) __THROW __exctype ( isalnum ) ;\n __exctype ( isalpha ) ;\n __exctype ( iscntrl ) ;\n __exctype ( isdigit ) ;\n __exctype ( islower ) ;\n __exctype ( isgraph ) ;\n __exctype ( isprint ) ;\n __exctype ( ispunct ) ;\n __exctype ( isspace ) ;\n __exctype ( isupper ) ;\n __exctype ( isxdigit ) ;\n extern int tolower ( int __c ) __THROW ;\n extern int toupper ( int __c ) __THROW ;\n # ifdef __USE_ISOC99 __exctype ( isblank )", "idx": 20870}
{"hash": 4511225370772574632, "project": "debian", "size": 19, "label": 0, "functionSource": "PHP_FUNCTION ( uwsgi_cache_get ) {\n char * key = NULL ;\n int keylen = 0 ;\n char * cache = NULL ;\n int cachelen = 0 ;\n uint64_t valsize ;\n if ( ! uwsgi . caches ) RETURN_NULL ( ) ;\n if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , \"s|s\" , & key , & keylen , & cache , & cachelen ) == FAILURE ) {\n RETURN_NULL ( ) ;\n }\n char * value = uwsgi_cache_magic_get ( key , keylen , & valsize , NULL , cache ) ;\n if ( value ) {\n char * ret = estrndup ( value , valsize ) ;\n free ( value ) ;\n # ifdef UWSGI_PHP7 RETURN_STRING ( ret ) ;\n # else RETURN_STRING ( ret , 0 ) ;\n # endif }\n RETURN_NULL ( ) ;\n }", "idx": 20871}
{"hash": 2820551931453396101, "project": "debian", "size": 18, "label": 0, "functionSource": "int jas_image_ishomosamp ( jas_image_t * image ) {\n jas_image_coord_t hstep ;\n jas_image_coord_t vstep ;\n int result ;\n int i ;\n hstep = jas_image_cmpthstep ( image , 0 ) ;\n vstep = jas_image_cmptvstep ( image , 0 ) ;\n result = 1 ;\n for ( i = 0 ;\n i < image -> numcmpts_ ;\n ++ i ) {\n if ( jas_image_cmpthstep ( image , i ) != hstep || jas_image_cmptvstep ( image , i ) != vstep ) {\n result = 0 ;\n break ;\n }\n }\n return result ;\n }", "idx": 20872}
{"hash": 229962612204196999, "project": "debian", "size": 24, "label": 0, "functionSource": "static int add_send_request ( struct object * obj , struct remote_lock * lock ) {\n struct transfer_request * request ;\n struct packed_git * target ;\n check_locks ( ) ;\n if ( remote_dir_exists [ obj -> oid . hash [ 0 ] ] == - 1 ) get_remote_object_list ( obj -> oid . hash [ 0 ] ) ;\n if ( obj -> flags & ( REMOTE | PUSHING ) ) return 0 ;\n target = find_sha1_pack ( obj -> oid . hash , repo -> packs ) ;\n if ( target ) {\n obj -> flags |= REMOTE ;\n return 0 ;\n }\n obj -> flags |= PUSHING ;\n request = xmalloc ( sizeof ( * request ) ) ;\n request -> obj = obj ;\n request -> url = NULL ;\n request -> lock = lock ;\n request -> headers = NULL ;\n request -> state = NEED_PUSH ;\n request -> next = request_queue_head ;\n request_queue_head = request ;\n # ifdef USE_CURL_MULTI fill_active_slots ( ) ;\n step_active_slots ( ) ;\n # endif return 1 ;\n }", "idx": 20873}
{"hash": 9173144338563772419, "project": "debian", "size": 327, "label": 0, "functionSource": "void commit_command_data ( int cmd ) {\n char error_string [ MAX_INPUT_BUFFER ] ;\n service * temp_service ;\n host * temp_host ;\n hostgroup * temp_hostgroup ;\n comment * temp_comment ;\n scheduled_downtime * temp_downtime ;\n servicegroup * temp_servicegroup = NULL ;\n contact * temp_contact = NULL ;\n int x = 0 ;\n int e = 0 ;\n short error_found = FALSE ;\n short cmd_has_objects = FALSE ;\n short row_color = 0 ;\n get_authentication_information ( & current_authdata ) ;\n is_authorized [ x ] = FALSE ;\n if ( lock_author_names == TRUE ) {\n temp_contact = find_contact ( current_authdata . username ) ;\n if ( temp_contact != NULL && temp_contact -> alias != NULL ) comment_author = temp_contact -> alias ;\n else comment_author = current_authdata . username ;\n }\n switch ( cmd ) {\n case CMD_ADD_HOST_COMMENT : case CMD_ADD_SVC_COMMENT : case CMD_ACKNOWLEDGE_HOST_PROBLEM : case CMD_ACKNOWLEDGE_SVC_PROBLEM : case CMD_SEND_CUSTOM_HOST_NOTIFICATION : case CMD_SEND_CUSTOM_SVC_NOTIFICATION : check_comment_sanity ( & e ) ;\n clean_comment_data ( comment_author ) ;\n clean_comment_data ( comment_data ) ;\n if ( use_ack_end_time == TRUE && ( cmd == CMD_ACKNOWLEDGE_HOST_PROBLEM || cmd == CMD_ACKNOWLEDGE_SVC_PROBLEM ) ) {\n time ( & start_time ) ;\n check_time_sanity ( & e ) ;\n }\n else end_time = 0L ;\n for ( x = 0 ;\n x < NUMBER_OF_STRUCTS ;\n x ++ ) {\n cmd_has_objects = TRUE ;\n if ( commands [ x ] . host_name == NULL ) continue ;\n is_authorized [ x ] = FALSE ;\n if ( cmd == CMD_ADD_HOST_COMMENT || cmd == CMD_ACKNOWLEDGE_HOST_PROBLEM || cmd == CMD_SEND_CUSTOM_HOST_NOTIFICATION ) {\n temp_host = find_host ( commands [ x ] . host_name ) ;\n if ( is_authorized_for_host_commands ( temp_host , & current_authdata ) == TRUE ) is_authorized [ x ] = TRUE ;\n }\n else {\n temp_service = find_service ( commands [ x ] . host_name , commands [ x ] . description ) ;\n if ( is_authorized_for_service_commands ( temp_service , & current_authdata ) == TRUE ) is_authorized [ x ] = TRUE ;\n }\n }\n break ;\n case CMD_DEL_HOST_COMMENT : case CMD_DEL_SVC_COMMENT : if ( enforce_comments_on_actions == TRUE ) {\n check_comment_sanity ( & e ) ;\n clean_comment_data ( comment_author ) ;\n clean_comment_data ( comment_data ) ;\n }\n for ( x = 0 ;\n x < NUMBER_OF_STRUCTS ;\n x ++ ) {\n cmd_has_objects = TRUE ;\n if ( multi_ids [ x ] == FALSE ) continue ;\n if ( multi_ids [ x ] == 0 ) {\n error [ e ++ ] . message = strdup ( \"Comment id cannot be 0\" ) ;\n continue ;\n }\n if ( cmd == CMD_DEL_HOST_COMMENT ) temp_comment = find_host_comment ( multi_ids [ x ] ) ;\n else temp_comment = find_service_comment ( multi_ids [ x ] ) ;\n is_authorized [ x ] = FALSE ;\n if ( cmd == CMD_DEL_HOST_COMMENT && temp_comment != NULL ) {\n temp_host = find_host ( temp_comment -> host_name ) ;\n if ( is_authorized_for_host_commands ( temp_host , & current_authdata ) == TRUE ) is_authorized [ x ] = TRUE ;\n }\n if ( cmd == CMD_DEL_SVC_COMMENT && temp_comment != NULL ) {\n temp_service = find_service ( temp_comment -> host_name , temp_comment -> service_description ) ;\n if ( is_authorized_for_service_commands ( temp_service , & current_authdata ) == TRUE ) is_authorized [ x ] = TRUE ;\n }\n }\n free_comment_data ( ) ;\n break ;\n case CMD_DEL_HOST_DOWNTIME : case CMD_DEL_SVC_DOWNTIME : if ( enforce_comments_on_actions == TRUE ) {\n check_comment_sanity ( & e ) ;\n clean_comment_data ( comment_author ) ;\n clean_comment_data ( comment_data ) ;\n }\n for ( x = 0 ;\n x < NUMBER_OF_STRUCTS ;\n x ++ ) {\n cmd_has_objects = TRUE ;\n if ( multi_ids [ x ] == FALSE ) continue ;\n if ( multi_ids [ x ] == 0 ) {\n error [ e ++ ] . message = strdup ( \"Downtime id cannot be 0\" ) ;\n continue ;\n }\n if ( cmd == CMD_DEL_HOST_DOWNTIME ) temp_downtime = find_host_downtime ( multi_ids [ x ] ) ;\n else temp_downtime = find_service_downtime ( multi_ids [ x ] ) ;\n is_authorized [ x ] = FALSE ;\n if ( cmd == CMD_DEL_HOST_DOWNTIME && temp_downtime != NULL ) {\n temp_host = find_host ( temp_downtime -> host_name ) ;\n if ( is_authorized_for_host_commands ( temp_host , & current_authdata ) == TRUE ) is_authorized [ x ] = TRUE ;\n }\n if ( cmd == CMD_DEL_SVC_DOWNTIME && temp_downtime != NULL ) {\n temp_service = find_service ( temp_downtime -> host_name , temp_downtime -> service_description ) ;\n if ( is_authorized_for_service_commands ( temp_service , & current_authdata ) == TRUE ) is_authorized [ x ] = TRUE ;\n }\n }\n free_downtime_data ( ) ;\n break ;\n case CMD_SCHEDULE_SVC_CHECK : case CMD_ENABLE_SVC_CHECK : case CMD_DISABLE_SVC_CHECK : case CMD_DEL_ALL_SVC_COMMENTS : case CMD_ENABLE_SVC_NOTIFICATIONS : case CMD_DISABLE_SVC_NOTIFICATIONS : case CMD_ENABLE_PASSIVE_SVC_CHECKS : case CMD_DISABLE_PASSIVE_SVC_CHECKS : case CMD_ENABLE_SVC_EVENT_HANDLER : case CMD_DISABLE_SVC_EVENT_HANDLER : case CMD_REMOVE_SVC_ACKNOWLEDGEMENT : case CMD_PROCESS_SERVICE_CHECK_RESULT : case CMD_SCHEDULE_SVC_DOWNTIME : case CMD_DELAY_SVC_NOTIFICATION : case CMD_ENABLE_SVC_FLAP_DETECTION : case CMD_DISABLE_SVC_FLAP_DETECTION : case CMD_START_OBSESSING_OVER_SVC : case CMD_STOP_OBSESSING_OVER_SVC : if ( cmd == CMD_SCHEDULE_SVC_DOWNTIME || enforce_comments_on_actions == TRUE ) {\n check_comment_sanity ( & e ) ;\n if ( cmd == CMD_SCHEDULE_SVC_DOWNTIME ) check_time_sanity ( & e ) ;\n clean_comment_data ( comment_author ) ;\n clean_comment_data ( comment_data ) ;\n }\n for ( x = 0 ;\n x < NUMBER_OF_STRUCTS ;\n x ++ ) {\n cmd_has_objects = TRUE ;\n if ( commands [ x ] . host_name == NULL || commands [ x ] . description == NULL ) continue ;\n is_authorized [ x ] = FALSE ;\n temp_service = find_service ( commands [ x ] . host_name , commands [ x ] . description ) ;\n if ( is_authorized_for_service_commands ( temp_service , & current_authdata ) == TRUE ) is_authorized [ x ] = TRUE ;\n }\n if ( cmd == CMD_PROCESS_SERVICE_CHECK_RESULT && ! strcmp ( plugin_output , \"\" ) ) error [ e ++ ] . message = strdup ( \"Check output cannot be blank\" ) ;\n if ( cmd == CMD_DELAY_SVC_NOTIFICATION && notification_delay <= 0 ) error [ e ++ ] . message = strdup ( \"Notification delay must be greater than 0\" ) ;\n if ( cmd == CMD_SCHEDULE_SVC_CHECK && start_time == ( time_t ) 0 ) error [ e ++ ] . message = strdup ( \"Start time must be non-zero or bad format has been submitted\" ) ;\n break ;\n case CMD_ENABLE_NOTIFICATIONS : case CMD_DISABLE_NOTIFICATIONS : case CMD_SHUTDOWN_PROCESS : case CMD_RESTART_PROCESS : case CMD_START_EXECUTING_SVC_CHECKS : case CMD_STOP_EXECUTING_SVC_CHECKS : case CMD_START_ACCEPTING_PASSIVE_SVC_CHECKS : case CMD_STOP_ACCEPTING_PASSIVE_SVC_CHECKS : case CMD_ENABLE_EVENT_HANDLERS : case CMD_DISABLE_EVENT_HANDLERS : case CMD_START_OBSESSING_OVER_SVC_CHECKS : case CMD_STOP_OBSESSING_OVER_SVC_CHECKS : case CMD_ENABLE_FLAP_DETECTION : case CMD_DISABLE_FLAP_DETECTION : case CMD_ENABLE_FAILURE_PREDICTION : case CMD_DISABLE_FAILURE_PREDICTION : case CMD_ENABLE_PERFORMANCE_DATA : case CMD_DISABLE_PERFORMANCE_DATA : case CMD_START_EXECUTING_HOST_CHECKS : case CMD_STOP_EXECUTING_HOST_CHECKS : case CMD_START_ACCEPTING_PASSIVE_HOST_CHECKS : case CMD_STOP_ACCEPTING_PASSIVE_HOST_CHECKS : case CMD_START_OBSESSING_OVER_HOST_CHECKS : case CMD_STOP_OBSESSING_OVER_HOST_CHECKS : if ( use_disabled_notif_end_time == TRUE && cmd == CMD_DISABLE_NOTIFICATIONS ) {\n time ( & start_time ) ;\n check_time_sanity ( & e ) ;\n }\n else end_time = 0L ;\n if ( enforce_comments_on_actions == TRUE ) {\n check_comment_sanity ( & e ) ;\n clean_comment_data ( comment_author ) ;\n clean_comment_data ( comment_data ) ;\n }\n is_authorized [ x ] = FALSE ;\n if ( is_authorized_for_system_commands ( & current_authdata ) == TRUE ) is_authorized [ x ] = TRUE ;\n break ;\n case CMD_ENABLE_HOST_SVC_CHECKS : case CMD_DISABLE_HOST_SVC_CHECKS : case CMD_DEL_ALL_HOST_COMMENTS : case CMD_SCHEDULE_HOST_SVC_CHECKS : case CMD_ENABLE_HOST_NOTIFICATIONS : case CMD_DISABLE_HOST_NOTIFICATIONS : case CMD_ENABLE_ALL_NOTIFICATIONS_BEYOND_HOST : case CMD_DISABLE_ALL_NOTIFICATIONS_BEYOND_HOST : case CMD_ENABLE_HOST_SVC_NOTIFICATIONS : case CMD_DISABLE_HOST_SVC_NOTIFICATIONS : case CMD_ENABLE_HOST_EVENT_HANDLER : case CMD_DISABLE_HOST_EVENT_HANDLER : case CMD_ENABLE_HOST_CHECK : case CMD_DISABLE_HOST_CHECK : case CMD_REMOVE_HOST_ACKNOWLEDGEMENT : case CMD_SCHEDULE_HOST_DOWNTIME : case CMD_SCHEDULE_HOST_SVC_DOWNTIME : case CMD_DELAY_HOST_NOTIFICATION : case CMD_ENABLE_HOST_FLAP_DETECTION : case CMD_DISABLE_HOST_FLAP_DETECTION : case CMD_PROCESS_HOST_CHECK_RESULT : case CMD_ENABLE_PASSIVE_HOST_CHECKS : case CMD_DISABLE_PASSIVE_HOST_CHECKS : case CMD_SCHEDULE_HOST_CHECK : case CMD_START_OBSESSING_OVER_HOST : case CMD_STOP_OBSESSING_OVER_HOST : case CMD_DEL_DOWNTIME_BY_HOST_NAME : if ( cmd == CMD_SCHEDULE_HOST_DOWNTIME || cmd == CMD_SCHEDULE_HOST_SVC_DOWNTIME || enforce_comments_on_actions == TRUE ) {\n check_comment_sanity ( & e ) ;\n if ( cmd == CMD_SCHEDULE_HOST_DOWNTIME || cmd == CMD_SCHEDULE_HOST_SVC_DOWNTIME ) check_time_sanity ( & e ) ;\n clean_comment_data ( comment_author ) ;\n clean_comment_data ( comment_data ) ;\n }\n for ( x = 0 ;\n x < NUMBER_OF_STRUCTS ;\n x ++ ) {\n cmd_has_objects = TRUE ;\n if ( commands [ x ] . host_name == NULL ) continue ;\n is_authorized [ x ] = FALSE ;\n temp_host = find_host ( commands [ x ] . host_name ) ;\n if ( is_authorized_for_host_commands ( temp_host , & current_authdata ) == TRUE ) is_authorized [ x ] = TRUE ;\n }\n if ( cmd == CMD_DELAY_HOST_NOTIFICATION && notification_delay <= 0 ) error [ e ++ ] . message = strdup ( \"Notification delay must be greater than 0\" ) ;\n if ( ( cmd == CMD_SCHEDULE_HOST_CHECK || cmd == CMD_SCHEDULE_HOST_SVC_CHECKS ) && start_time == ( time_t ) 0 ) error [ e ++ ] . message = strdup ( \"Start time must be non-zero or bad format has been submitted\" ) ;\n if ( cmd == CMD_PROCESS_HOST_CHECK_RESULT && ! strcmp ( plugin_output , \"\" ) ) error [ e ++ ] . message = strdup ( \"Check output cannot be blank\" ) ;\n break ;\n case CMD_ENABLE_HOSTGROUP_SVC_NOTIFICATIONS : case CMD_DISABLE_HOSTGROUP_SVC_NOTIFICATIONS : case CMD_ENABLE_HOSTGROUP_HOST_NOTIFICATIONS : case CMD_DISABLE_HOSTGROUP_HOST_NOTIFICATIONS : case CMD_ENABLE_HOSTGROUP_SVC_CHECKS : case CMD_DISABLE_HOSTGROUP_SVC_CHECKS : case CMD_SCHEDULE_HOSTGROUP_HOST_DOWNTIME : case CMD_SCHEDULE_HOSTGROUP_SVC_DOWNTIME : case CMD_ENABLE_SERVICEGROUP_SVC_NOTIFICATIONS : case CMD_DISABLE_SERVICEGROUP_SVC_NOTIFICATIONS : case CMD_ENABLE_SERVICEGROUP_HOST_NOTIFICATIONS : case CMD_DISABLE_SERVICEGROUP_HOST_NOTIFICATIONS : case CMD_ENABLE_SERVICEGROUP_SVC_CHECKS : case CMD_DISABLE_SERVICEGROUP_SVC_CHECKS : case CMD_SCHEDULE_SERVICEGROUP_HOST_DOWNTIME : case CMD_SCHEDULE_SERVICEGROUP_SVC_DOWNTIME : if ( cmd == CMD_SCHEDULE_SERVICEGROUP_HOST_DOWNTIME || cmd == CMD_SCHEDULE_SERVICEGROUP_SVC_DOWNTIME || cmd == CMD_SCHEDULE_HOSTGROUP_HOST_DOWNTIME || cmd == CMD_SCHEDULE_HOSTGROUP_SVC_DOWNTIME ) {\n check_comment_sanity ( & e ) ;\n check_time_sanity ( & e ) ;\n clean_comment_data ( comment_author ) ;\n clean_comment_data ( comment_data ) ;\n }\n else if ( enforce_comments_on_actions == TRUE ) {\n check_comment_sanity ( & e ) ;\n clean_comment_data ( comment_author ) ;\n clean_comment_data ( comment_data ) ;\n }\n is_authorized [ x ] = FALSE ;\n if ( cmd == CMD_ENABLE_HOSTGROUP_SVC_NOTIFICATIONS || cmd == CMD_DISABLE_HOSTGROUP_SVC_NOTIFICATIONS || cmd == CMD_ENABLE_HOSTGROUP_HOST_NOTIFICATIONS || cmd == CMD_DISABLE_HOSTGROUP_HOST_NOTIFICATIONS || cmd == CMD_ENABLE_HOSTGROUP_SVC_CHECKS || cmd == CMD_DISABLE_HOSTGROUP_SVC_CHECKS || cmd == CMD_SCHEDULE_HOSTGROUP_HOST_DOWNTIME || cmd == CMD_SCHEDULE_HOSTGROUP_SVC_DOWNTIME ) {\n temp_hostgroup = find_hostgroup ( hostgroup_name ) ;\n if ( is_authorized_for_hostgroup_commands ( temp_hostgroup , & current_authdata ) == TRUE ) is_authorized [ x ] = TRUE ;\n }\n else {\n temp_servicegroup = find_servicegroup ( servicegroup_name ) ;\n if ( is_authorized_for_servicegroup_commands ( temp_servicegroup , & current_authdata ) == TRUE ) is_authorized [ x ] = TRUE ;\n }\n break ;\n case CMD_CHANGE_HOST_MODATTR : case CMD_CHANGE_SVC_MODATTR : for ( x = 0 ;\n x < NUMBER_OF_STRUCTS ;\n x ++ ) {\n cmd_has_objects = TRUE ;\n if ( commands [ x ] . host_name == NULL ) continue ;\n is_authorized [ x ] = FALSE ;\n if ( cmd == CMD_CHANGE_HOST_MODATTR ) {\n temp_host = find_host ( commands [ x ] . host_name ) ;\n if ( is_authorized_for_host_commands ( temp_host , & current_authdata ) == TRUE ) is_authorized [ x ] = TRUE ;\n }\n else {\n temp_service = find_service ( commands [ x ] . host_name , commands [ x ] . description ) ;\n if ( is_authorized_for_service_commands ( temp_service , & current_authdata ) == TRUE ) is_authorized [ x ] = TRUE ;\n }\n if ( attr != MODATTR_NONE ) {\n error [ e ++ ] . message = strdup ( \"You cannot change modified attributes other than reset them!\" ) ;\n }\n }\n break ;\n default : print_generic_error_message ( \"Sorry Dave, I can't let you do that...\" , \"Executing an unknown command? Shame on you!\" , 2 ) ;\n return ;\n }\n for ( x = 0 ;\n x < NUMBER_OF_STRUCTS ;\n x ++ ) {\n if ( commands [ x ] . host_name == NULL ) continue ;\n if ( strchr ( commands [ x ] . host_name , ';\n' ) ) {\n snprintf ( error_string , sizeof ( error_string ) , \"The hostname \\\"%s\\\" contains a semicolon\" , commands [ x ] . host_name ) ;\n error_string [ sizeof ( error_string ) - 1 ] = '\\x0' ;\n error [ e ++ ] . message = ( char * ) strdup ( error_string ) ;\n }\n if ( commands [ x ] . description != NULL && strchr ( commands [ x ] . description , ';\n' ) ) {\n snprintf ( error_string , sizeof ( error_string ) , \"The service description \\\"%s\\\" on host \\\"%s\\\" contains a semicolon\" , commands [ x ] . description , commands [ x ] . host_name ) ;\n error_string [ sizeof ( error_string ) - 1 ] = '\\x0' ;\n error [ e ++ ] . message = strdup ( error_string ) ;\n }\n }\n if ( hostgroup_name && strchr ( hostgroup_name , ';\n' ) ) error [ e ++ ] . message = strdup ( \"The hostgroup name contains a semicolon\" ) ;\n if ( servicegroup_name && strchr ( servicegroup_name , ';\n' ) ) error [ e ++ ] . message = strdup ( \"The servicegroup name contains a semicolon\" ) ;\n printf ( \"<BR><DIV align='center'>\\n\" ) ;\n if ( check_external_commands == FALSE ) {\n print_generic_error_message ( \"Sorry, but Icinga is currently not checking for external commands, so your command will not be committed!\" , \"Read the documentation for information on how to enable external commands...\" , 2 ) ;\n return ;\n }\n if ( use_authentication == FALSE ) {\n print_generic_error_message ( \"Sorry Dave, I can't let you do that...\" , \"It seems that you have chosen to not use the authentication functionality of the CGIs. I don't want to be personally responsible for what may happen as a result of allowing unauthorized users to issue commands to Icinga, so you'll have to disable this safeguard if you are really stubborn and want to invite trouble. Read the section on CGI authentication in the HTML documentation to learn how you can enable authentication and why you should want to.\" , 2 ) ;\n return ;\n }\n if ( e > 0 ) {\n printf ( \"<DIV CLASS='errorBox'>\\n\" ) ;\n printf ( \"<DIV CLASS='errorMessage'><table cellspacing=0 cellpadding=0 border=0><tr><td width=55><img src=\\\"%s%s\\\" border=0></td>\" , url_images_path , CMD_STOP_ICON ) ;\n printf ( \"<td CLASS='errorMessage'>Following errors occured.</td></tr></table></DIV>\\n\" ) ;\n printf ( \"<table cellspacing=0 cellpadding=0 border=0 class='errorTable'>\\n\" ) ;\n for ( e = 0 ;\n e < NUMBER_OF_STRUCTS ;\n e ++ ) {\n if ( error [ e ] . message == NULL ) continue ;\n printf ( \"<tr><td class='errorString'>ERROR:</td><td class='errorContent'>%s</td></tr>\\n\" , error [ e ] . message ) ;\n }\n printf ( \"</table>\\n</DIV>\\n\" ) ;\n printf ( \"<BR>\\n\" ) ;\n printf ( \"<table cellspacing=0 cellpadding=0 border=0 class='BoxWidth'><tr>\\n\" ) ;\n printf ( \"<td align='left' width='50%%'><input type='submit' value='< Go back and fix it' onClick='window.history.go(-1);\n' class='submitButton'></td>\\n\" ) ;\n printf ( \"<td align='right' width='50%%'><input type='submit' value='Get me out of here' onClick='window.history.go(-2);\n' class='submitButton'></td>\\n\" ) ;\n printf ( \"</tr></table></DIV>\" ) ;\n return ;\n }\n if ( cmd_has_objects == FALSE && is_authorized [ 0 ] == FALSE ) {\n print_generic_error_message ( \"Sorry, but you are not authorized to commit the specified command.\" , \"Read the section of the documentation that deals with authentication and authorization in the CGIs for more information.\" , 2 ) ;\n return ;\n }\n commit_command ( cmd ) ;\n if ( cmd_has_objects == FALSE ) {\n if ( submit_result [ 0 ] == OK ) {\n printf ( \"<DIV CLASS='successBox'>\\n\" ) ;\n printf ( \"<DIV CLASS='successMessage'>Your command request was successfully submitted to %s for processing.<BR><BR>\\n\" , PROGRAM_NAME ) ;\n printf ( \"Note: It may take a while before the command is actually processed.</DIV>\\n\" ) ;\n printf ( \"</DIV>\\n\" ) ;\n printf ( \"<BR><input type='submit' value='Done' onClick='window.history.go(-2);\n' class='submitButton'></DIV>\\n\" ) ;\n }\n else {\n print_generic_error_message ( \"An error occurred while attempting to commit your command for processing.\" , \"Unfortunately I can't determine the root cause of this problem.\" , 2 ) ;\n }\n }\n else {\n for ( x = 0 ;\n x < NUMBER_OF_STRUCTS ;\n x ++ ) {\n if ( cmd == CMD_DEL_HOST_COMMENT || cmd == CMD_DEL_SVC_COMMENT || cmd == CMD_DEL_HOST_DOWNTIME || cmd == CMD_DEL_SVC_DOWNTIME ) {\n if ( multi_ids [ x ] == FALSE ) continue ;\n }\n else {\n if ( commands [ x ] . host_name == NULL ) continue ;\n }\n if ( is_authorized [ x ] == FALSE || submit_result [ x ] == ERROR ) {\n error_found = TRUE ;\n break ;\n }\n }\n if ( error_found ) {\n print_generic_error_message ( \"An error occurred while attempting to commit your command for processing.\" , \"Not all commands could be send off successfully...\" , 0 ) ;\n }\n else {\n printf ( \"<DIV CLASS='successBox'>\\n\" ) ;\n printf ( \"<DIV CLASS='successMessage'>Your command requests were successfully submitted to %s for processing.<BR><BR>\\n\" , PROGRAM_NAME ) ;\n printf ( \"Note: It may take a while before the commands are actually processed.</DIV>\\n\" ) ;\n printf ( \"</DIV>\\n\" ) ;\n }\n printf ( \"<BR>\\n\" ) ;\n printf ( \"<TABLE CELLSPACING='0' CELLPADDING=0 BORDER=0 CLASS='BoxWidth'>\\n\" ) ;\n printf ( \"<tr class='BoxWidth'><td width='33%%'></td><td width='33%%' align='center'><input type='submit' value='Done' onClick='window.history.go(-2);\n' class='submitButton'></td><td width='33%%' align='right'>\\n\" ) ;\n if ( ! error_found ) printf ( \"<input type='submit' value='Let me see what has been done' onClick=\\\"document.getElementById('sumCommit').style.display = '';\n\\\" class='submitButton'>\\n\" ) ;\n printf ( \"</td></TR></TABLE>\\n\" ) ;\n printf ( \"<BR><BR>\\n\" ) ;\n printf ( \"<TABLE CELLSPACING='0' CELLPADDING='0' ID='sumCommit' %s><TR><TD CLASS='boxFrame BoxWidth'>\\n\" , ( error_found ) ? \"\" : \"style='display:none;\n'\" ) ;\n printf ( \"<table cellspacing=2 cellpadding=0 border=0 class='contentTable'>\\n\" ) ;\n if ( cmd == CMD_DEL_HOST_COMMENT || cmd == CMD_DEL_SVC_COMMENT ) printf ( \"<tr class='sumHeader'><td width='80%%'>Comment ID</td><td width='20%%'>Status</td></tr>\\n\" ) ;\n else if ( cmd == CMD_DEL_HOST_DOWNTIME || cmd == CMD_DEL_SVC_DOWNTIME ) printf ( \"<tr class='sumHeader'><td width='80%%'>Downtime ID</td><td width='20%%'>Status</td></tr>\\n\" ) ;\n else printf ( \"<tr class='sumHeader'><td width='40%%'>Host</td><td width='40%%'>Service</td><td width='20%%'>Status</td></tr>\\n\" ) ;\n for ( x = 0 ;\n x < NUMBER_OF_STRUCTS ;\n x ++ ) {\n if ( cmd == CMD_DEL_HOST_COMMENT || cmd == CMD_DEL_SVC_COMMENT || cmd == CMD_DEL_HOST_DOWNTIME || cmd == CMD_DEL_SVC_DOWNTIME ) {\n if ( multi_ids [ x ] == FALSE ) continue ;\n row_color = ( row_color == 0 ) ? 1 : 0 ;\n printf ( \"<tr class='status%s'><td>%lu</td><td>\" , ( row_color == 0 ) ? \"Even\" : \"Odd \" , multi_ids [ x ] ) ;\n }\n else {\n if ( commands [ x ] . host_name == NULL ) continue ;\n row_color = ( row_color == 0 ) ? 1 : 0 ;\n printf ( \"<tr class='status%s'><td>%s</td><td>%s</td><td>\" , ( row_color == 0 ) ? \"Even\" : \"Odd \" , commands [ x ] . host_name , ( commands [ x ] . description != NULL ) ? commands [ x ] . description : \"N/A\" ) ;\n }\n if ( is_authorized [ x ] == FALSE ) printf ( \"<DIV class='commitFailed'>Not Authorized</DIV>\" ) ;\n else if ( submit_result [ x ] == ERROR ) printf ( \"<DIV class='commitFailed'>FAILED</DIV>\" ) ;\n else if ( submit_result [ x ] == OK ) printf ( \"<DIV class='commitSuccess'>Successful</DIV>\" ) ;\n else printf ( \"<DIV class='commitUnknown'>Unknown</DIV>\" ) ;\n printf ( \"</TD><TR>\\n\" ) ;\n }\n printf ( \"</TABLE>\\n\" ) ;\n printf ( \"</TD></TR></TABLE></DIV>\\n\" ) ;\n }\n return ;\n }", "idx": 20874}
{"hash": 583170025160259883, "project": "debian", "size": 4, "label": 0, "functionSource": "static void guestfwd_read ( void * opaque , const uint8_t * buf , int size ) {\n struct GuestFwd * fwd = opaque ;\n slirp_socket_recv ( fwd -> slirp , fwd -> server , fwd -> port , buf , size ) ;\n }", "idx": 20875}
{"hash": -6252714751027237823, "project": "debian", "size": 3, "label": 0, "functionSource": "static void gs_heap_free_string ( gs_memory_t * mem , byte * data , uint nbytes , client_name_t cname ) {\n gs_heap_free_object ( mem , data , cname ) ;\n }", "idx": 20876}
{"hash": 5825340398912191389, "project": "debian", "size": 8, "label": 0, "functionSource": "extern int name ( int ) __THROW __exctype ( isalnum ) ;\n __exctype ( isalpha ) ;\n __exctype ( iscntrl ) ;\n __exctype ( isdigit ) ;\n __exctype ( islower ) ;\n __exctype ( isgraph ) ;\n __exctype ( isprint ) ;\n __exctype ( ispunct )", "idx": 20877}
{"hash": -6554160531728146583, "project": "debian", "size": 253, "label": 0, "functionSource": "unsigned long # define BN_LONG long # define BN_BITS 128 # define BN_BYTES 8 # define BN_BITS2 64 # define BN_BITS4 32 # define BN_MASK ( 0xffffffffffffffffffffffffffffffffLL ) # define BN_MASK2 ( 0xffffffffffffffffL ) # define BN_MASK2l ( 0xffffffffL ) # define BN_MASK2h ( 0xffffffff00000000L ) # define BN_MASK2h1 ( 0xffffffff80000000L ) # define BN_TBIT ( 0x8000000000000000L ) # define BN_DEC_CONV ( 10000000000000000000UL ) # define BN_DEC_FMT1 \"%lu\" # define BN_DEC_FMT2 \"%019lu\" # define BN_DEC_NUM 19 # define BN_HEX_FMT1 \"%lX\" # define BN_HEX_FMT2 \"%016lX\" # endif # ifdef SIXTY_FOUR_BIT # undef BN_LLONG # undef BN_ULLONG # define BN_ULONG unsigned long long # define BN_LONG long long # define BN_BITS 128 # define BN_BYTES 8 # define BN_BITS2 64 # define BN_BITS4 32 # define BN_MASK2 ( 0xffffffffffffffffLL ) # define BN_MASK2l ( 0xffffffffL ) # define BN_MASK2h ( 0xffffffff00000000LL ) # define BN_MASK2h1 ( 0xffffffff80000000LL ) # define BN_TBIT ( 0x8000000000000000LL ) # define BN_DEC_CONV ( 10000000000000000000ULL ) # define BN_DEC_FMT1 \"%llu\" # define BN_DEC_FMT2 \"%019llu\" # define BN_DEC_NUM 19 # define BN_HEX_FMT1 \"%llX\" # define BN_HEX_FMT2 \"%016llX\" # endif # ifdef THIRTY_TWO_BIT # ifdef BN_LLONG # if defined ( _WIN32 ) && ! defined ( __GNUC__ ) # define BN_ULLONG unsigned __int64 # define BN_MASK ( 0xffffffffffffffffI64 ) # else # define BN_ULLONG unsigned long long # define BN_MASK ( 0xffffffffffffffffLL ) # endif # endif # define BN_ULONG unsigned int # define BN_LONG int # define BN_BITS 64 # define BN_BYTES 4 # define BN_BITS2 32 # define BN_BITS4 16 # define BN_MASK2 ( 0xffffffffL ) # define BN_MASK2l ( 0xffff ) # define BN_MASK2h1 ( 0xffff8000L ) # define BN_MASK2h ( 0xffff0000L ) # define BN_TBIT ( 0x80000000L ) # define BN_DEC_CONV ( 1000000000L ) # define BN_DEC_FMT1 \"%u\" # define BN_DEC_FMT2 \"%09u\" # define BN_DEC_NUM 9 # define BN_HEX_FMT1 \"%X\" # define BN_HEX_FMT2 \"%08X\" # endif # define BN_DEFAULT_BITS 1280 # define BN_FLG_MALLOCED 0x01 # define BN_FLG_STATIC_DATA 0x02 # define BN_FLG_CONSTTIME 0x04 # ifndef OPENSSL_NO_DEPRECATED # define BN_FLG_EXP_CONSTTIME BN_FLG_CONSTTIME # endif # ifndef OPENSSL_NO_DEPRECATED # define BN_FLG_FREE 0x8000 # endif # define BN_set_flags ( b , n ) ( ( b ) -> flags |= ( n ) ) # define BN_get_flags ( b , n ) ( ( b ) -> flags & ( n ) ) # define BN_with_flags ( dest , b , n ) ( ( dest ) -> d = ( b ) -> d , \\ ( dest ) -> top = ( b ) -> top , \\ ( dest ) -> dmax = ( b ) -> dmax , \\ ( dest ) -> neg = ( b ) -> neg , \\ ( dest ) -> flags = ( ( ( dest ) -> flags & BN_FLG_MALLOCED ) \\ | ( ( b ) -> flags & ~ BN_FLG_MALLOCED ) \\ | BN_FLG_STATIC_DATA \\ | ( n ) ) ) # if 0 typedef struct bignum_st BIGNUM ;\n typedef struct bignum_ctx BN_CTX ;\n typedef struct bn_blinding_st BN_BLINDING ;\n typedef struct bn_mont_ctx_st BN_MONT_CTX ;\n typedef struct bn_recp_ctx_st BN_RECP_CTX ;\n typedef struct bn_gencb_st BN_GENCB ;\n # endif struct bignum_st {\n BN_ULONG * d ;\n int top ;\n int dmax ;\n int neg ;\n int flags ;\n }\n ;\n struct bn_mont_ctx_st {\n int ri ;\n BIGNUM RR ;\n BIGNUM N ;\n BIGNUM Ni ;\n BN_ULONG n0 [ 2 ] ;\n int flags ;\n }\n ;\n struct bn_recp_ctx_st {\n BIGNUM N ;\n BIGNUM Nr ;\n int num_bits ;\n int shift ;\n int flags ;\n }\n ;\n struct bn_gencb_st {\n unsigned int ver ;\n void * arg ;\n union {\n void ( * cb_1 ) ( int , int , void * ) ;\n int ( * cb_2 ) ( int , int , BN_GENCB * ) ;\n }\n cb ;\n }\n ;\n int BN_GENCB_call ( BN_GENCB * cb , int a , int b ) ;\n # define BN_GENCB_set_old ( gencb , callback , cb_arg ) {\n \\ BN_GENCB * tmp_gencb = ( gencb ) ;\n \\ tmp_gencb -> ver = 1 ;\n \\ tmp_gencb -> arg = ( cb_arg ) ;\n \\ tmp_gencb -> cb . cb_1 = ( callback ) ;\n }\n # define BN_GENCB_set ( gencb , callback , cb_arg ) {\n \\ BN_GENCB * tmp_gencb = ( gencb ) ;\n \\ tmp_gencb -> ver = 2 ;\n \\ tmp_gencb -> arg = ( cb_arg ) ;\n \\ tmp_gencb -> cb . cb_2 = ( callback ) ;\n }\n # define BN_prime_checks 0 # define BN_prime_checks_for_size ( b ) ( ( b ) >= 1300 ? 2 : \\ ( b ) >= 850 ? 3 : \\ ( b ) >= 650 ? 4 : \\ ( b ) >= 550 ? 5 : \\ ( b ) >= 450 ? 6 : \\ ( b ) >= 400 ? 7 : \\ ( b ) >= 350 ? 8 : \\ ( b ) >= 300 ? 9 : \\ ( b ) >= 250 ? 12 : \\ ( b ) >= 200 ? 15 : \\ ( b ) >= 150 ? 18 : \\ 27 ) # define BN_num_bytes ( a ) ( ( BN_num_bits ( a ) + 7 ) / 8 ) # define BN_abs_is_word ( a , w ) ( ( ( ( a ) -> top == 1 ) && ( ( a ) -> d [ 0 ] == ( BN_ULONG ) ( w ) ) ) || \\ ( ( ( w ) == 0 ) && ( ( a ) -> top == 0 ) ) ) # define BN_is_zero ( a ) ( ( a ) -> top == 0 ) # define BN_is_one ( a ) ( BN_abs_is_word ( ( a ) , 1 ) && ! ( a ) -> neg ) # define BN_is_word ( a , w ) ( BN_abs_is_word ( ( a ) , ( w ) ) && ( ! ( w ) || ! ( a ) -> neg ) ) # define BN_is_odd ( a ) ( ( ( a ) -> top > 0 ) && ( ( a ) -> d [ 0 ] & 1 ) ) # define BN_one ( a ) ( BN_set_word ( ( a ) , 1 ) ) # define BN_zero_ex ( a ) \\ do {\n \\ BIGNUM * _tmp_bn = ( a ) ;\n \\ _tmp_bn -> top = 0 ;\n \\ _tmp_bn -> neg = 0 ;\n \\ }\n while ( 0 ) # ifdef OPENSSL_NO_DEPRECATED # define BN_zero ( a ) BN_zero_ex ( a ) # else # define BN_zero ( a ) ( BN_set_word ( ( a ) , 0 ) ) # endif const BIGNUM * BN_value_one ( void ) ;\n char * BN_options ( void ) ;\n BN_CTX * BN_CTX_new ( void ) ;\n # ifndef OPENSSL_NO_DEPRECATED void BN_CTX_init ( BN_CTX * c ) ;\n # endif void BN_CTX_free ( BN_CTX * c ) ;\n void BN_CTX_start ( BN_CTX * ctx ) ;\n BIGNUM * BN_CTX_get ( BN_CTX * ctx ) ;\n void BN_CTX_end ( BN_CTX * ctx ) ;\n int BN_rand ( BIGNUM * rnd , int bits , int top , int bottom ) ;\n int BN_pseudo_rand ( BIGNUM * rnd , int bits , int top , int bottom ) ;\n int BN_rand_range ( BIGNUM * rnd , const BIGNUM * range ) ;\n int BN_pseudo_rand_range ( BIGNUM * rnd , const BIGNUM * range ) ;\n int BN_num_bits ( const BIGNUM * a ) ;\n int BN_num_bits_word ( BN_ULONG l ) ;\n BIGNUM * BN_new ( void ) ;\n void BN_init ( BIGNUM * ) ;\n void BN_clear_free ( BIGNUM * a ) ;\n BIGNUM * BN_copy ( BIGNUM * a , const BIGNUM * b ) ;\n void BN_swap ( BIGNUM * a , BIGNUM * b ) ;\n BIGNUM * BN_bin2bn ( const unsigned char * s , int len , BIGNUM * ret ) ;\n int BN_bn2bin ( const BIGNUM * a , unsigned char * to ) ;\n BIGNUM * BN_mpi2bn ( const unsigned char * s , int len , BIGNUM * ret ) ;\n int BN_bn2mpi ( const BIGNUM * a , unsigned char * to ) ;\n int BN_sub ( BIGNUM * r , const BIGNUM * a , const BIGNUM * b ) ;\n int BN_usub ( BIGNUM * r , const BIGNUM * a , const BIGNUM * b ) ;\n int BN_uadd ( BIGNUM * r , const BIGNUM * a , const BIGNUM * b ) ;\n int BN_add ( BIGNUM * r , const BIGNUM * a , const BIGNUM * b ) ;\n int BN_mul ( BIGNUM * r , const BIGNUM * a , const BIGNUM * b , BN_CTX * ctx ) ;\n int BN_sqr ( BIGNUM * r , const BIGNUM * a , BN_CTX * ctx ) ;\n void BN_set_negative ( BIGNUM * b , int n ) ;\n # define BN_is_negative ( a ) ( ( a ) -> neg != 0 ) int BN_div ( BIGNUM * dv , BIGNUM * rem , const BIGNUM * m , const BIGNUM * d , BN_CTX * ctx ) ;\n # define BN_mod ( rem , m , d , ctx ) BN_div ( NULL , ( rem ) , ( m ) , ( d ) , ( ctx ) ) int BN_nnmod ( BIGNUM * r , const BIGNUM * m , const BIGNUM * d , BN_CTX * ctx ) ;\n int BN_mod_add ( BIGNUM * r , const BIGNUM * a , const BIGNUM * b , const BIGNUM * m , BN_CTX * ctx ) ;\n int BN_mod_add_quick ( BIGNUM * r , const BIGNUM * a , const BIGNUM * b , const BIGNUM * m ) ;\n int BN_mod_sub ( BIGNUM * r , const BIGNUM * a , const BIGNUM * b , const BIGNUM * m , BN_CTX * ctx ) ;\n int BN_mod_sub_quick ( BIGNUM * r , const BIGNUM * a , const BIGNUM * b , const BIGNUM * m ) ;\n int BN_mod_mul ( BIGNUM * r , const BIGNUM * a , const BIGNUM * b , const BIGNUM * m , BN_CTX * ctx ) ;\n int BN_mod_sqr ( BIGNUM * r , const BIGNUM * a , const BIGNUM * m , BN_CTX * ctx ) ;\n int BN_mod_lshift1 ( BIGNUM * r , const BIGNUM * a , const BIGNUM * m , BN_CTX * ctx ) ;\n int BN_mod_lshift1_quick ( BIGNUM * r , const BIGNUM * a , const BIGNUM * m ) ;\n int BN_mod_lshift ( BIGNUM * r , const BIGNUM * a , int n , const BIGNUM * m , BN_CTX * ctx ) ;\n int BN_mod_lshift_quick ( BIGNUM * r , const BIGNUM * a , int n , const BIGNUM * m ) ;\n BN_ULONG BN_mod_word ( const BIGNUM * a , BN_ULONG w ) ;\n BN_ULONG BN_div_word ( BIGNUM * a , BN_ULONG w ) ;\n int BN_mul_word ( BIGNUM * a , BN_ULONG w ) ;\n int BN_add_word ( BIGNUM * a , BN_ULONG w ) ;\n int BN_sub_word ( BIGNUM * a , BN_ULONG w ) ;\n int BN_set_word ( BIGNUM * a , BN_ULONG w ) ;\n BN_ULONG BN_get_word ( const BIGNUM * a ) ;\n int BN_cmp ( const BIGNUM * a , const BIGNUM * b ) ;\n void BN_free ( BIGNUM * a ) ;\n int BN_is_bit_set ( const BIGNUM * a , int n ) ;\n int BN_lshift ( BIGNUM * r , const BIGNUM * a , int n ) ;\n int BN_lshift1 ( BIGNUM * r , const BIGNUM * a ) ;\n int BN_exp ( BIGNUM * r , const BIGNUM * a , const BIGNUM * p , BN_CTX * ctx ) ;\n int BN_mod_exp ( BIGNUM * r , const BIGNUM * a , const BIGNUM * p , const BIGNUM * m , BN_CTX * ctx ) ;\n int BN_mod_exp_mont ( BIGNUM * r , const BIGNUM * a , const BIGNUM * p , const BIGNUM * m , BN_CTX * ctx , BN_MONT_CTX * m_ctx ) ;\n int BN_mod_exp_mont_consttime ( BIGNUM * rr , const BIGNUM * a , const BIGNUM * p , const BIGNUM * m , BN_CTX * ctx , BN_MONT_CTX * in_mont ) ;\n int BN_mod_exp_mont_word ( BIGNUM * r , BN_ULONG a , const BIGNUM * p , const BIGNUM * m , BN_CTX * ctx , BN_MONT_CTX * m_ctx ) ;\n int BN_mod_exp2_mont ( BIGNUM * r , const BIGNUM * a1 , const BIGNUM * p1 , const BIGNUM * a2 , const BIGNUM * p2 , const BIGNUM * m , BN_CTX * ctx , BN_MONT_CTX * m_ctx ) ;\n int BN_mod_exp_simple ( BIGNUM * r , const BIGNUM * a , const BIGNUM * p , const BIGNUM * m , BN_CTX * ctx ) ;\n int BN_mask_bits ( BIGNUM * a , int n ) ;\n # ifndef OPENSSL_NO_FP_API int BN_print_fp ( FILE * fp , const BIGNUM * a ) ;\n # endif # ifdef HEADER_BIO_H int BN_print ( BIO * fp , const BIGNUM * a ) ;\n # else int BN_print ( void * fp , const BIGNUM * a ) ;\n # endif int BN_reciprocal ( BIGNUM * r , const BIGNUM * m , int len , BN_CTX * ctx ) ;\n int BN_rshift ( BIGNUM * r , const BIGNUM * a , int n ) ;\n int BN_rshift1 ( BIGNUM * r , const BIGNUM * a ) ;\n void BN_clear ( BIGNUM * a ) ;\n BIGNUM * BN_dup ( const BIGNUM * a ) ;\n int BN_ucmp ( const BIGNUM * a , const BIGNUM * b ) ;\n int BN_set_bit ( BIGNUM * a , int n ) ;\n int BN_clear_bit ( BIGNUM * a , int n ) ;\n char * BN_bn2hex ( const BIGNUM * a ) ;\n char * BN_bn2dec ( const BIGNUM * a ) ;\n int BN_hex2bn ( BIGNUM * * a , const char * str ) ;\n int BN_dec2bn ( BIGNUM * * a , const char * str ) ;\n int BN_asc2bn ( BIGNUM * * a , const char * str ) ;\n int BN_gcd ( BIGNUM * r , const BIGNUM * a , const BIGNUM * b , BN_CTX * ctx ) ;\n int BN_kronecker ( const BIGNUM * a , const BIGNUM * b , BN_CTX * ctx ) ;\n BIGNUM * BN_mod_inverse ( BIGNUM * ret , const BIGNUM * a , const BIGNUM * n , BN_CTX * ctx ) ;\n BIGNUM * BN_mod_sqrt ( BIGNUM * ret , const BIGNUM * a , const BIGNUM * n , BN_CTX * ctx ) ;\n void BN_consttime_swap ( BN_ULONG swap , BIGNUM * a , BIGNUM * b , int nwords ) ;\n # ifndef OPENSSL_NO_DEPRECATED BIGNUM * BN_generate_prime ( BIGNUM * ret , int bits , int safe , const BIGNUM * add , const BIGNUM * rem , void ( * callback ) ( int , int , void * ) , void * cb_arg ) ;\n int BN_is_prime ( const BIGNUM * p , int nchecks , void ( * callback ) ( int , int , void * ) , BN_CTX * ctx , void * cb_arg ) ;\n int BN_is_prime_fasttest ( const BIGNUM * p , int nchecks , void ( * callback ) ( int , int , void * ) , BN_CTX * ctx , void * cb_arg , int do_trial_division ) ;\n # endif int BN_generate_prime_ex ( BIGNUM * ret , int bits , int safe , const BIGNUM * add , const BIGNUM * rem , BN_GENCB * cb ) ;\n int BN_is_prime_ex ( const BIGNUM * p , int nchecks , BN_CTX * ctx , BN_GENCB * cb ) ;\n int BN_is_prime_fasttest_ex ( const BIGNUM * p , int nchecks , BN_CTX * ctx , int do_trial_division , BN_GENCB * cb ) ;\n int BN_X931_generate_Xpq ( BIGNUM * Xp , BIGNUM * Xq , int nbits , BN_CTX * ctx ) ;\n int BN_X931_derive_prime_ex ( BIGNUM * p , BIGNUM * p1 , BIGNUM * p2 , const BIGNUM * Xp , const BIGNUM * Xp1 , const BIGNUM * Xp2 , const BIGNUM * e , BN_CTX * ctx , BN_GENCB * cb ) ;\n int BN_X931_generate_prime_ex ( BIGNUM * p , BIGNUM * p1 , BIGNUM * p2 , BIGNUM * Xp1 , BIGNUM * Xp2 , const BIGNUM * Xp , const BIGNUM * e , BN_CTX * ctx , BN_GENCB * cb ) ;\n BN_MONT_CTX * BN_MONT_CTX_new ( void ) ;\n void BN_MONT_CTX_init ( BN_MONT_CTX * ctx ) ;\n int BN_mod_mul_montgomery ( BIGNUM * r , const BIGNUM * a , const BIGNUM * b , BN_MONT_CTX * mont , BN_CTX * ctx ) ;\n # define BN_to_montgomery ( r , a , mont , ctx ) BN_mod_mul_montgomery ( \\ ( r ) , ( a ) , & ( ( mont ) -> RR ) , ( mont ) , ( ctx ) ) int BN_from_montgomery ( BIGNUM * r , const BIGNUM * a , BN_MONT_CTX * mont , BN_CTX * ctx ) ;\n void BN_MONT_CTX_free ( BN_MONT_CTX * mont ) ;\n int BN_MONT_CTX_set ( BN_MONT_CTX * mont , const BIGNUM * mod , BN_CTX * ctx ) ;\n BN_MONT_CTX * BN_MONT_CTX_copy ( BN_MONT_CTX * to , BN_MONT_CTX * from ) ;\n BN_MONT_CTX * BN_MONT_CTX_set_locked ( BN_MONT_CTX * * pmont , int lock , const BIGNUM * mod , BN_CTX * ctx ) ;\n # define BN_BLINDING_NO_UPDATE 0x00000001 # define BN_BLINDING_NO_RECREATE 0x00000002 BN_BLINDING * BN_BLINDING_new ( const BIGNUM * A , const BIGNUM * Ai , BIGNUM * mod ) ;\n void BN_BLINDING_free ( BN_BLINDING * b ) ;\n int BN_BLINDING_update ( BN_BLINDING * b , BN_CTX * ctx ) ;\n int BN_BLINDING_convert ( BIGNUM * n , BN_BLINDING * b , BN_CTX * ctx ) ;\n int BN_BLINDING_invert ( BIGNUM * n , BN_BLINDING * b , BN_CTX * ctx ) ;\n int BN_BLINDING_convert_ex ( BIGNUM * n , BIGNUM * r , BN_BLINDING * b , BN_CTX * ) ;\n int BN_BLINDING_invert_ex ( BIGNUM * n , const BIGNUM * r , BN_BLINDING * b , BN_CTX * ) ;\n # ifndef OPENSSL_NO_DEPRECATED unsigned long BN_BLINDING_get_thread_id ( const BN_BLINDING * ) ;\n void BN_BLINDING_set_thread_id ( BN_BLINDING * , unsigned long ) ;\n # endif CRYPTO_THREADID * BN_BLINDING_thread_id ( BN_BLINDING * ) ;\n unsigned long BN_BLINDING_get_flags ( const BN_BLINDING * ) ;\n void BN_BLINDING_set_flags ( BN_BLINDING * , unsigned long ) ;\n BN_BLINDING * BN_BLINDING_create_param ( BN_BLINDING * b , const BIGNUM * e , BIGNUM * m , BN_CTX * ctx , int ( * bn_mod_exp ) ( BIGNUM * r , const BIGNUM * a , const BIGNUM * p , const BIGNUM * m , BN_CTX * ctx , BN_MONT_CTX * m_ctx ) , BN_MONT_CTX * m_ctx ) ;\n # ifndef OPENSSL_NO_DEPRECATED void BN_set_params ( int mul , int high , int low , int mont ) ;\n int BN_get_params ( int which ) ;\n # endif void BN_RECP_CTX_init ( BN_RECP_CTX * recp ) ;\n BN_RECP_CTX * BN_RECP_CTX_new ( void ) ;\n void BN_RECP_CTX_free ( BN_RECP_CTX * recp ) ;\n int BN_RECP_CTX_set ( BN_RECP_CTX * recp , const BIGNUM * rdiv , BN_CTX * ctx ) ;\n int BN_mod_mul_reciprocal ( BIGNUM * r , const BIGNUM * x , const BIGNUM * y , BN_RECP_CTX * recp , BN_CTX * ctx ) ;\n int BN_mod_exp_recp ( BIGNUM * r , const BIGNUM * a , const BIGNUM * p , const BIGNUM * m , BN_CTX * ctx ) ;\n int BN_div_recp ( BIGNUM * dv , BIGNUM * rem , const BIGNUM * m , BN_RECP_CTX * recp , BN_CTX * ctx ) ;\n # ifndef OPENSSL_NO_EC2M int BN_GF2m_add ( BIGNUM * r , const BIGNUM * a , const BIGNUM * b ) ;\n # define BN_GF2m_sub ( r , a , b ) BN_GF2m_add ( r , a , b ) int BN_GF2m_mod ( BIGNUM * r , const BIGNUM * a , const BIGNUM * p ) ;\n int BN_GF2m_mod_mul ( BIGNUM * r , const BIGNUM * a , const BIGNUM * b , const BIGNUM * p , BN_CTX * ctx ) ;\n int BN_GF2m_mod_sqr ( BIGNUM * r , const BIGNUM * a , const BIGNUM * p , BN_CTX * ctx ) ;\n int BN_GF2m_mod_inv ( BIGNUM * r , const BIGNUM * b , const BIGNUM * p , BN_CTX * ctx ) ;\n int BN_GF2m_mod_div ( BIGNUM * r , const BIGNUM * a , const BIGNUM * b , const BIGNUM * p , BN_CTX * ctx ) ;\n int BN_GF2m_mod_exp ( BIGNUM * r , const BIGNUM * a , const BIGNUM * b , const BIGNUM * p , BN_CTX * ctx ) ;\n int BN_GF2m_mod_sqrt ( BIGNUM * r , const BIGNUM * a , const BIGNUM * p , BN_CTX * ctx ) ;\n int BN_GF2m_mod_solve_quad ( BIGNUM * r , const BIGNUM * a , const BIGNUM * p , BN_CTX * ctx ) ;\n # define BN_GF2m_cmp ( a , b ) BN_ucmp ( ( a ) , ( b ) ) int BN_GF2m_mod_arr ( BIGNUM * r , const BIGNUM * a , const int p [ ] ) ;\n int BN_GF2m_mod_mul_arr ( BIGNUM * r , const BIGNUM * a , const BIGNUM * b , const int p [ ] , BN_CTX * ctx ) ;\n int BN_GF2m_mod_sqr_arr ( BIGNUM * r , const BIGNUM * a , const int p [ ] , BN_CTX * ctx ) ;\n int BN_GF2m_mod_inv_arr ( BIGNUM * r , const BIGNUM * b , const int p [ ] , BN_CTX * ctx ) ;\n int BN_GF2m_mod_div_arr ( BIGNUM * r , const BIGNUM * a , const BIGNUM * b , const int p [ ] , BN_CTX * ctx ) ;\n int BN_GF2m_mod_exp_arr ( BIGNUM * r , const BIGNUM * a , const BIGNUM * b , const int p [ ] , BN_CTX * ctx ) ;\n int BN_GF2m_mod_sqrt_arr ( BIGNUM * r , const BIGNUM * a , const int p [ ] , BN_CTX * ctx ) ;\n int BN_GF2m_mod_solve_quad_arr ( BIGNUM * r , const BIGNUM * a , const int p [ ] , BN_CTX * ctx ) ;\n int BN_GF2m_poly2arr ( const BIGNUM * a , int p [ ] , int max ) ;\n int BN_GF2m_arr2poly ( const int p [ ] , BIGNUM * a ) ;\n # endif int BN_nist_mod_192 ( BIGNUM * r , const BIGNUM * a , const BIGNUM * p , BN_CTX * ctx ) ;\n int BN_nist_mod_224 ( BIGNUM * r , const BIGNUM * a , const BIGNUM * p , BN_CTX * ctx ) ;\n int BN_nist_mod_256 ( BIGNUM * r , const BIGNUM * a , const BIGNUM * p , BN_CTX * ctx ) ;\n int BN_nist_mod_384 ( BIGNUM * r , const BIGNUM * a , const BIGNUM * p , BN_CTX * ctx ) ;\n int BN_nist_mod_521 ( BIGNUM * r , const BIGNUM * a , const BIGNUM * p , BN_CTX * ctx ) ;\n const BIGNUM * BN_get0_nist_prime_192 ( void ) ;\n const BIGNUM * BN_get0_nist_prime_224 ( void ) ;\n const BIGNUM * BN_get0_nist_prime_256 ( void ) ;\n const BIGNUM * BN_get0_nist_prime_384 ( void ) ;\n const BIGNUM * BN_get0_nist_prime_521 ( void ) ;\n int ( * BN_nist_mod_func ( const BIGNUM * p ) ) ( BIGNUM * r , const BIGNUM * a , const BIGNUM * field , BN_CTX * ctx ) ;\n int BN_generate_dsa_nonce ( BIGNUM * out , const BIGNUM * range , const BIGNUM * priv , const unsigned char * message , size_t message_len , BN_CTX * ctx ) ;\n # define bn_expand ( a , bits ) ( ( ( ( ( ( bits + BN_BITS2 - 1 ) ) / BN_BITS2 ) ) <= ( a ) -> dmax ) ? \\ ( a ) : bn_expand2 ( ( a ) , ( bits + BN_BITS2 - 1 ) / BN_BITS2 ) ) # define bn_wexpand ( a , words ) ( ( ( words ) <= ( a ) -> dmax ) ? ( a ) : bn_expand2 ( ( a ) , ( words ) ) ) BIGNUM * bn_expand2 ( BIGNUM * a , int words ) ;\n # ifndef OPENSSL_NO_DEPRECATED BIGNUM * bn_dup_expand ( const BIGNUM * a , int words ) ;\n # endif # ifdef BN_DEBUG # include < assert . h > # ifdef BN_DEBUG_RAND # ifndef RAND_pseudo_bytes int RAND_pseudo_bytes ( unsigned char * buf , int num ) ;\n # define BN_DEBUG_TRIX # endif # define bn_pollute ( a ) \\ do {\n \\ const BIGNUM * _bnum1 = ( a ) ;\n \\ if ( _bnum1 -> top < _bnum1 -> dmax ) {\n \\ unsigned char _tmp_char ;\n \\ \\ BN_ULONG * _not_const ;\n \\ memcpy ( & _not_const , & _bnum1 -> d , sizeof ( BN_ULONG * ) ) ;\n \\ RAND_pseudo_bytes ( & _tmp_char , 1 ) ;\n \\ memset ( ( unsigned char * ) ( _not_const + _bnum1 -> top ) , _tmp_char , \\ ( _bnum1 -> dmax - _bnum1 -> top ) * sizeof ( BN_ULONG ) ) ;\n \\ }\n \\ }\n while ( 0 ) # ifdef BN_DEBUG_TRIX # undef RAND_pseudo_bytes # endif # else # define bn_pollute ( a ) # endif # define bn_check_top ( a ) \\ do {\n \\ const BIGNUM * _bnum2 = ( a ) ;\n \\ if ( _bnum2 != NULL ) {\n \\ assert ( ( _bnum2 -> top == 0 ) || \\ ( _bnum2 -> d [ _bnum2 -> top - 1 ] != 0 ) ) ;\n \\ bn_pollute ( _bnum2 ) ;\n \\ }\n \\ }\n while ( 0 ) # define bn_fix_top ( a ) bn_check_top ( a ) # define bn_check_size ( bn , bits ) bn_wcheck_size ( bn , ( ( bits + BN_BITS2 - 1 ) ) / BN_BITS2 ) # define bn_wcheck_size ( bn , words ) \\ do {\n \\ const BIGNUM * _bnum2 = ( bn ) ;\n \\ assert ( words <= ( _bnum2 ) -> dmax && words >= ( _bnum2 ) -> top ) ;\n \\ }\n while ( 0 ) # else # define bn_pollute ( a ) # define bn_check_top ( a ) # define bn_fix_top ( a ) bn_correct_top ( a ) # define bn_check_size ( bn , bits ) # define bn_wcheck_size ( bn , words ) # endif # define bn_correct_top ( a ) \\ {\n \\ BN_ULONG * ftl ;\n \\ int tmp_top = ( a ) -> top ;\n \\ if ( tmp_top > 0 ) \\ {\n \\ for ( ftl = & ( ( a ) -> d [ tmp_top - 1 ] ) ;\n tmp_top > 0 ;\n tmp_top -- ) \\ if ( * ( ftl -- ) ) break ;\n \\ ( a ) -> top = tmp_top ;\n \\ }\n \\ bn_pollute ( a ) ;\n \\ }\n BN_ULONG bn_mul_add_words ( BN_ULONG * rp , const BN_ULONG * ap , int num , BN_ULONG w ) ;\n BN_ULONG bn_mul_words ( BN_ULONG * rp , const BN_ULONG * ap , int num , BN_ULONG w ) ;\n void bn_sqr_words ( BN_ULONG * rp , const BN_ULONG * ap , int num ) ;\n BN_ULONG bn_div_words ( BN_ULONG h , BN_ULONG l , BN_ULONG d ) ;\n BN_ULONG bn_add_words ( BN_ULONG * rp , const BN_ULONG * ap , const BN_ULONG * bp , int num ) ;\n BN_ULONG bn_sub_words ( BN_ULONG * rp , const BN_ULONG * ap , const BN_ULONG * bp , int num )", "idx": 20878}
{"hash": -2127895299879503273, "project": "debian", "size": 3, "label": 0, "functionSource": "static int ide_nop_int ( IDEDMA * dma , int x ) {\n return 0 ;\n }", "idx": 20879}
{"hash": 6393050609822897742, "project": "debian", "size": 8, "label": 0, "functionSource": "static inline dma_addr_t xhci_mask64 ( uint64_t addr ) {\n if ( sizeof ( dma_addr_t ) == 4 ) {\n return addr & 0xffffffff ;\n }\n else {\n return addr ;\n }\n }", "idx": 20880}
{"hash": -7468702064548611268, "project": "debian", "size": 5, "label": 0, "functionSource": "int ff_vdpau_common_start_frame ( AVCodecContext * avctx , av_unused const uint8_t * buffer , av_unused uint32_t size ) {\n AVVDPAUContext * hwctx = avctx -> hwaccel_context ;\n hwctx -> bitstream_buffers_used = 0 ;\n return 0 ;\n }", "idx": 20881}
{"hash": 6667142528452941476, "project": "debian", "size": 3, "label": 0, "functionSource": "static void dynstr_append_checked ( DYNAMIC_STRING * dest , const char * src ) {\n if ( dynstr_append ( dest , src ) ) die ( EX_MYSQLERR , DYNAMIC_STR_ERROR_MSG ) ;\n }", "idx": 20882}
{"hash": 914926989019402478, "project": "debian", "size": 18, "label": 0, "functionSource": "static int main_file_seek ( main_file * xfile , xoff_t pos ) {\n int ret = 0 ;\n # if XD3_STDIO if ( fseek ( xfile -> file , pos , SEEK_SET ) != 0 ) {\n ret = get_errno ( ) ;\n }\n # elif XD3_POSIX if ( ( xoff_t ) lseek ( xfile -> file , pos , SEEK_SET ) != pos ) {\n ret = get_errno ( ) ;\n }\n # elif XD3_WIN32 # if ( _WIN32_WINNT >= 0x0500 ) LARGE_INTEGER move , out ;\n move . QuadPart = pos ;\n if ( SetFilePointerEx ( xfile -> file , move , & out , FILE_BEGIN ) == 0 ) {\n ret = get_errno ( ) ;\n }\n # else if ( SetFilePointer ( xfile -> file , ( LONG ) pos , NULL , FILE_BEGIN ) == INVALID_SET_FILE_POINTER ) {\n ret = get_errno ( ) ;\n }\n # endif # endif return ret ;\n }", "idx": 20883}
{"hash": -4032982860280343776, "project": "chrome", "size": 8, "label": 0, "functionSource": "static void U_CALLCONV _SCSUClose ( UConverter * cnv ) {\n if ( cnv -> extraInfo != NULL ) {\n if ( ! cnv -> isExtraLocal ) {\n uprv_free ( cnv -> extraInfo ) ;\n }\n cnv -> extraInfo = NULL ;\n }\n }", "idx": 20884}
{"hash": 1182028467273264883, "project": "debian", "size": 30, "label": 0, "functionSource": "void dynstr_append_sorted ( DYNAMIC_STRING * ds , DYNAMIC_STRING * ds_input , bool keep_header ) {\n unsigned i ;\n char * start = ds_input -> str ;\n DYNAMIC_ARRAY lines ;\n DBUG_ENTER ( \"dynstr_append_sorted\" ) ;\n if ( ! * start ) DBUG_VOID_RETURN ;\n my_init_dynamic_array ( & lines , sizeof ( const char * ) , 32 , 32 ) ;\n if ( keep_header ) {\n while ( * start && * start != '\\n' ) start ++ ;\n start ++ ;\n dynstr_append_mem ( ds , ds_input -> str , start - ds_input -> str ) ;\n }\n while ( * start ) {\n char * line_end = ( char * ) start ;\n while ( * line_end && * line_end != '\\n' ) line_end ++ ;\n * line_end = 0 ;\n if ( insert_dynamic ( & lines , ( uchar * ) & start ) ) die ( \"Out of memory inserting lines to sort\" ) ;\n start = line_end + 1 ;\n }\n qsort ( lines . buffer , lines . elements , sizeof ( char * * ) , ( qsort_cmp ) comp_lines ) ;\n for ( i = 0 ;\n i < lines . elements ;\n i ++ ) {\n const char * * line = dynamic_element ( & lines , i , const char * * ) ;\n dynstr_append ( ds , * line ) ;\n dynstr_append ( ds , \"\\n\" ) ;\n }\n delete_dynamic ( & lines ) ;\n DBUG_VOID_RETURN ;\n }", "idx": 20885}
{"hash": 6323824267898511453, "project": "debian", "size": 3, "label": 0, "functionSource": "int fz_colorspace_n ( fz_context * ctx , const fz_colorspace * cs ) {\n return cs ? cs -> n : 0 ;\n }", "idx": 20886}
{"hash": 1760449185745615462, "project": "debian", "size": 5, "label": 0, "functionSource": "void TSHttpTxnUntransformedRespCache ( TSHttpTxn txnp , int on ) {\n sdk_assert ( sdk_sanity_check_txn ( txnp ) == TS_SUCCESS ) ;\n HttpSM * sm = ( HttpSM * ) txnp ;\n sm -> t_state . api_info . cache_untransformed = ( on ? true : false ) ;\n }", "idx": 20887}
{"hash": -6552851419396579257, "project": "debian", "size": 20, "label": 0, "functionSource": "static int SpoolssGetPrinterDriver2_q ( tvbuff_t * tvb , int offset , packet_info * pinfo , proto_tree * tree , dcerpc_info * di , guint8 * drep ) {\n dcerpc_call_value * dcv = ( dcerpc_call_value * ) di -> call_data ;\n e_ctx_hnd policy_hnd ;\n char * pol_name ;\n guint32 level ;\n offset = dissect_nt_policy_hnd ( tvb , offset , pinfo , tree , di , drep , hf_hnd , & policy_hnd , NULL , FALSE , FALSE ) ;\n dcerpc_fetch_polhnd_data ( & policy_hnd , & pol_name , NULL , NULL , NULL , pinfo -> num ) ;\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \", %s\" , pol_name ) ;\n offset = dissect_ndr_str_pointer_item ( tvb , offset , pinfo , tree , di , drep , NDR_POINTER_UNIQUE , \"Environment\" , hf_environment , 0 ) ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , tree , di , drep , hf_level , & level ) ;\n if ( ! pinfo -> fd -> flags . visited ) {\n dcv -> se_data = GUINT_TO_POINTER ( ( int ) level ) ;\n }\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \", level %d\" , level ) ;\n offset = dissect_spoolss_buffer ( tvb , offset , pinfo , tree , di , drep , NULL ) ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , tree , di , drep , hf_offered , NULL ) ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , tree , di , drep , hf_clientmajorversion , NULL ) ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , tree , di , drep , hf_clientminorversion , NULL ) ;\n return offset ;\n }", "idx": 20888}
{"hash": 8801969307247112896, "project": "debian", "size": 3, "label": 0, "functionSource": "const EVP_CIPHER * EVP_aes_128_wrap_pad ( void ) {\n return & aes_128_wrap_pad ;\n }", "idx": 20889}
{"hash": 4537091194729139981, "project": "chrome", "size": 11, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( FullscreenControllerInteractiveTest , DISABLED_TestNewTabExitsFullscreen ) {\n ASSERT_TRUE ( test_server ( ) -> Start ( ) ) ;\n AddTabAtIndex ( 0 , GURL ( url : : kAboutBlankURL ) , PAGE_TRANSITION_TYPED ) ;\n ASSERT_NO_FATAL_FAILURE ( ToggleTabFullscreen ( true ) ) ;\n {\n FullscreenNotificationObserver fullscreen_observer ;\n AddTabAtIndex ( 1 , GURL ( url : : kAboutBlankURL ) , PAGE_TRANSITION_TYPED ) ;\n fullscreen_observer . Wait ( ) ;\n ASSERT_FALSE ( browser ( ) -> window ( ) -> IsFullscreen ( ) ) ;\n }\n }", "idx": 20890}
{"hash": 6120640898537304364, "project": "debian", "size": 9, "label": 0, "functionSource": "void pdf_tos_set_matrix ( pdf_text_object_state * tos , float a , float b , float c , float d , float e , float f ) {\n tos -> tm . a = a ;\n tos -> tm . b = b ;\n tos -> tm . c = c ;\n tos -> tm . d = d ;\n tos -> tm . e = e ;\n tos -> tm . f = f ;\n tos -> tlm = tos -> tm ;\n }", "idx": 20891}
{"hash": 3935234056444097745, "project": "debian", "size": 23, "label": 0, "functionSource": "static int rtp_packetize_swab ( sout_stream_id_sys_t * id , block_t * in ) {\n unsigned max = rtp_mtu ( id ) ;\n while ( in -> i_buffer > 0 ) {\n unsigned payload = ( max < in -> i_buffer ) ? max : in -> i_buffer ;\n unsigned duration = ( in -> i_length * payload ) / in -> i_buffer ;\n bool marker = ( in -> i_flags & BLOCK_FLAG_DISCONTINUITY ) != 0 ;\n block_t * out = block_Alloc ( 12 + payload ) ;\n if ( unlikely ( out == NULL ) ) {\n block_Release ( in ) ;\n return VLC_ENOMEM ;\n }\n rtp_packetize_common ( id , out , marker , in -> i_pts ) ;\n swab ( in -> p_buffer , out -> p_buffer + 12 , payload ) ;\n rtp_packetize_send ( id , out ) ;\n in -> p_buffer += payload ;\n in -> i_buffer -= payload ;\n in -> i_pts += duration ;\n in -> i_length -= duration ;\n in -> i_flags &= ~ BLOCK_FLAG_DISCONTINUITY ;\n }\n block_Release ( in ) ;\n return VLC_SUCCESS ;\n }", "idx": 20892}
{"hash": -4078760840682683657, "project": "chrome", "size": 28, "label": 1, "functionSource": "static void read_intra_frame_mode_info ( VP9_COMMON * const cm , MACROBLOCKD * const xd , int mi_row , int mi_col , vp9_reader * r ) {\n MODE_INFO * const mi = xd -> mi [ 0 ] ;\n MB_MODE_INFO * const mbmi = & mi -> mbmi ;\n const MODE_INFO * above_mi = xd -> mi [ - cm -> mi_stride ] ;\n const MODE_INFO * left_mi = xd -> left_available ? xd -> mi [ - 1 ] : NULL ;\n const BLOCK_SIZE bsize = mbmi -> sb_type ;\n int i ;\n mbmi -> segment_id = read_intra_segment_id ( cm , xd , mi_row , mi_col , r ) ;\n mbmi -> skip = read_skip ( cm , xd , mbmi -> segment_id , r ) ;\n mbmi -> tx_size = read_tx_size ( cm , xd , cm -> tx_mode , bsize , 1 , r ) ;\n mbmi -> ref_frame [ 0 ] = INTRA_FRAME ;\n mbmi -> ref_frame [ 1 ] = NONE ;\n switch ( bsize ) {\n case BLOCK_4X4 : for ( i = 0 ;\n i < 4 ;\n ++ i ) mi -> bmi [ i ] . as_mode = read_intra_mode ( r , get_y_mode_probs ( mi , above_mi , left_mi , i ) ) ;\n mbmi -> mode = mi -> bmi [ 3 ] . as_mode ;\n break ;\n case BLOCK_4X8 : mi -> bmi [ 0 ] . as_mode = mi -> bmi [ 2 ] . as_mode = read_intra_mode ( r , get_y_mode_probs ( mi , above_mi , left_mi , 0 ) ) ;\n mi -> bmi [ 1 ] . as_mode = mi -> bmi [ 3 ] . as_mode = mbmi -> mode = read_intra_mode ( r , get_y_mode_probs ( mi , above_mi , left_mi , 1 ) ) ;\n break ;\n case BLOCK_8X4 : mi -> bmi [ 0 ] . as_mode = mi -> bmi [ 1 ] . as_mode = read_intra_mode ( r , get_y_mode_probs ( mi , above_mi , left_mi , 0 ) ) ;\n mi -> bmi [ 2 ] . as_mode = mi -> bmi [ 3 ] . as_mode = mbmi -> mode = read_intra_mode ( r , get_y_mode_probs ( mi , above_mi , left_mi , 2 ) ) ;\n break ;\n default : mbmi -> mode = read_intra_mode ( r , get_y_mode_probs ( mi , above_mi , left_mi , 0 ) ) ;\n }\n mbmi -> uv_mode = read_intra_mode ( r , vp9_kf_uv_mode_prob [ mbmi -> mode ] ) ;\n }", "idx": 20893}
{"hash": -1102844685921778700, "project": "debian", "size": 11, "label": 0, "functionSource": "int archive_mstring_copy_mbs_len ( struct archive_mstring * aes , const char * mbs , size_t len ) {\n if ( mbs == NULL ) {\n aes -> aes_set = 0 ;\n return ( 0 ) ;\n }\n aes -> aes_set = AES_SET_MBS ;\n archive_strncpy ( & ( aes -> aes_mbs ) , mbs , len ) ;\n archive_string_empty ( & ( aes -> aes_utf8 ) ) ;\n archive_wstring_empty ( & ( aes -> aes_wcs ) ) ;\n return ( 0 ) ;\n }", "idx": 20894}
{"hash": 4180964683905830761, "project": "debian", "size": 3, "label": 0, "functionSource": "static int selinux_inode_getattr ( const struct path * path ) {\n return path_has_perm ( current_cred ( ) , path , FILE__GETATTR ) ;\n }", "idx": 20895}
{"hash": 1760449185745615462, "project": "debian", "size": 4, "label": 0, "functionSource": "void TSHttpParserClear ( TSHttpParser parser ) {\n sdk_assert ( sdk_sanity_check_http_parser ( parser ) == TS_SUCCESS ) ;\n http_parser_clear ( ( HTTPParser * ) parser ) ;\n }", "idx": 20896}
{"hash": -1338403456839869183, "project": "debian", "size": 39, "label": 0, "functionSource": "void dissect_q931_high_layer_compat_ie ( tvbuff_t * tvb , int offset , int len , proto_tree * tree ) {\n guint8 octet ;\n guint8 coding_standard ;\n guint8 pres_method ;\n guint8 characteristics ;\n if ( len == 0 ) return ;\n octet = tvb_get_guint8 ( tvb , offset ) ;\n coding_standard = octet & 0x60 ;\n pres_method = octet & 0x03 ;\n proto_tree_add_item ( tree , hf_q931_extension_ind , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_uint ( tree , hf_q931_coding_standard , tvb , offset , 1 , octet ) ;\n proto_tree_add_uint ( tree , hf_q931_interpretation , tvb , offset , 1 , octet ) ;\n proto_tree_add_uint ( tree , hf_q931_pres_meth_prot_prof , tvb , offset , 1 , octet ) ;\n offset += 1 ;\n len -= 1 ;\n if ( ( coding_standard != Q931_ITU_STANDARDIZED_CODING ) || ( pres_method != Q931_HIGH_LAYER_PROTOCOL_PROFILE ) ) {\n proto_tree_add_item ( tree , hf_q931_high_layer_compat_data , tvb , offset , len , ENC_NA ) ;\n return ;\n }\n if ( len == 0 ) return ;\n octet = tvb_get_guint8 ( tvb , offset ) ;\n characteristics = octet & 0x7F ;\n proto_tree_add_item ( tree , hf_q931_extension_ind , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_uint ( tree , hf_q931_high_layer_characteristics , tvb , offset , 1 , octet ) ;\n offset += 1 ;\n len -= 1 ;\n if ( ! ( octet & Q931_IE_VL_EXTENSION ) ) {\n if ( len == 0 ) return ;\n octet = tvb_get_guint8 ( tvb , offset ) ;\n if ( ( characteristics == Q931_AUDIOVISUAL ) || ( characteristics == 0x61 ) || ( characteristics == 0x62 ) || ( characteristics == 0x68 ) ) {\n proto_tree_add_item ( tree , hf_q931_extension_ind , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_uint ( tree , hf_q931_extended_audiovisual_characteristics , tvb , offset , 1 , octet ) ;\n }\n else if ( ( characteristics == Q931_MANAGEMENT ) || ( characteristics == Q931_MAINTENANCE ) ) {\n proto_tree_add_item ( tree , hf_q931_extension_ind , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_uint ( tree , hf_q931_extended_high_layer_characteristics , tvb , offset , 1 , octet ) ;\n }\n }\n }", "idx": 20897}
{"hash": -6126432314261451839, "project": "debian", "size": 6, "label": 0, "functionSource": "void gx_device_set_procs ( gx_device * dev ) {\n if ( dev -> static_procs != 0 ) {\n dev -> procs = * dev -> static_procs ;\n dev -> static_procs = 0 ;\n }\n }", "idx": 20898}
{"hash": 3668456668028959955, "project": "debian", "size": 17, "label": 0, "functionSource": "static VALUE cState_init_copy ( VALUE obj , VALUE orig ) {\n JSON_Generator_State * objState , * origState ;\n if ( obj == orig ) return obj ;\n GET_STATE_TO ( obj , objState ) ;\n GET_STATE_TO ( orig , origState ) ;\n if ( ! objState ) rb_raise ( rb_eArgError , \"unallocated JSON::State\" ) ;\n MEMCPY ( objState , origState , JSON_Generator_State , 1 ) ;\n objState -> indent = fstrndup ( origState -> indent , origState -> indent_len ) ;\n objState -> space = fstrndup ( origState -> space , origState -> space_len ) ;\n objState -> space_before = fstrndup ( origState -> space_before , origState -> space_before_len ) ;\n objState -> object_nl = fstrndup ( origState -> object_nl , origState -> object_nl_len ) ;\n objState -> array_nl = fstrndup ( origState -> array_nl , origState -> array_nl_len ) ;\n if ( origState -> array_delim ) objState -> array_delim = fbuffer_dup ( origState -> array_delim ) ;\n if ( origState -> object_delim ) objState -> object_delim = fbuffer_dup ( origState -> object_delim ) ;\n if ( origState -> object_delim2 ) objState -> object_delim2 = fbuffer_dup ( origState -> object_delim2 ) ;\n return obj ;\n }", "idx": 20899}
{"hash": -1672864273235910388, "project": "debian", "size": 48, "label": 0, "functionSource": "static void _slurm_rpc_job_step_get_info ( slurm_msg_t * msg ) {\n DEF_TIMERS ;\n void * resp_buffer = NULL ;\n int resp_buffer_size = 0 ;\n int error_code = SLURM_SUCCESS ;\n job_step_info_request_msg_t * request = ( job_step_info_request_msg_t * ) msg -> data ;\n slurmctld_lock_t job_read_lock = {\n READ_LOCK , READ_LOCK , NO_LOCK , READ_LOCK , NO_LOCK }\n ;\n uid_t uid = g_slurm_auth_get_uid ( msg -> auth_cred , slurmctld_config . auth_info ) ;\n START_TIMER ;\n if ( slurmctld_conf . debug_flags & DEBUG_FLAG_STEPS ) debug ( \"Processing RPC: REQUEST_JOB_STEP_INFO from uid=%d\" , uid ) ;\n lock_slurmctld ( job_read_lock ) ;\n if ( ( request -> last_update - 1 ) >= last_job_update ) {\n unlock_slurmctld ( job_read_lock ) ;\n if ( slurmctld_conf . debug_flags & DEBUG_FLAG_STEPS ) debug ( \"%s, no change\" , __func__ ) ;\n error_code = SLURM_NO_CHANGE_IN_DATA ;\n }\n else {\n Buf buffer = init_buf ( BUF_SIZE ) ;\n error_code = pack_ctld_job_step_info_response_msg ( request -> job_id , request -> step_id , uid , request -> show_flags , buffer , msg -> protocol_version ) ;\n unlock_slurmctld ( job_read_lock ) ;\n END_TIMER2 ( \"_slurm_rpc_job_step_get_info\" ) ;\n if ( error_code ) {\n if ( slurmctld_conf . debug_flags & DEBUG_FLAG_STEPS ) debug ( \"%s: %s\" , __func__ , slurm_strerror ( error_code ) ) ;\n free_buf ( buffer ) ;\n }\n else {\n resp_buffer_size = get_buf_offset ( buffer ) ;\n resp_buffer = xfer_buf_data ( buffer ) ;\n if ( slurmctld_conf . debug_flags & DEBUG_FLAG_STEPS ) debug ( \"%s size=%d %s\" , __func__ , resp_buffer_size , TIME_STR ) ;\n }\n }\n if ( error_code ) slurm_send_rc_msg ( msg , error_code ) ;\n else {\n slurm_msg_t response_msg ;\n slurm_msg_t_init ( & response_msg ) ;\n response_msg . flags = msg -> flags ;\n response_msg . protocol_version = msg -> protocol_version ;\n response_msg . address = msg -> address ;\n response_msg . conn = msg -> conn ;\n response_msg . msg_type = RESPONSE_JOB_STEP_INFO ;\n response_msg . data = resp_buffer ;\n response_msg . data_size = resp_buffer_size ;\n slurm_send_node_msg ( msg -> conn_fd , & response_msg ) ;\n xfree ( resp_buffer ) ;\n }\n }", "idx": 20900}
{"hash": 6573793021826676268, "project": "debian", "size": 7, "label": 0, "functionSource": "void xps_end_opacity ( xps_document * doc , char * base_uri , xps_resource * dict , char * opacity_att , fz_xml * opacity_mask_tag ) {\n if ( ! opacity_att && ! opacity_mask_tag ) return ;\n if ( doc -> opacity_top > 0 ) doc -> opacity_top -- ;\n if ( opacity_mask_tag ) {\n if ( strcmp ( fz_xml_tag ( opacity_mask_tag ) , \"SolidColorBrush\" ) ) fz_pop_clip ( doc -> dev ) ;\n }\n }", "idx": 20901}
{"hash": -4960438251319819237, "project": "chrome", "size": 120, "label": 0, "functionSource": "static void define_gf_group ( VP9_COMP * cpi , FIRSTPASS_STATS * this_frame ) {\n RATE_CONTROL * const rc = & cpi -> rc ;\n const VP9EncoderConfig * const oxcf = & cpi -> oxcf ;\n TWO_PASS * const twopass = & cpi -> twopass ;\n FIRSTPASS_STATS next_frame ;\n const FIRSTPASS_STATS * const start_pos = twopass -> stats_in ;\n int i ;\n double boost_score = 0.0 ;\n double old_boost_score = 0.0 ;\n double gf_group_err = 0.0 ;\n double gf_first_frame_err = 0.0 ;\n double mod_frame_err = 0.0 ;\n double mv_ratio_accumulator = 0.0 ;\n double decay_accumulator = 1.0 ;\n double zero_motion_accumulator = 1.0 ;\n double loop_decay_rate = 1.00 ;\n double last_loop_decay_rate = 1.00 ;\n double this_frame_mv_in_out = 0.0 ;\n double mv_in_out_accumulator = 0.0 ;\n double abs_mv_in_out_accumulator = 0.0 ;\n double mv_ratio_accumulator_thresh ;\n unsigned int allow_alt_ref = is_altref_enabled ( cpi ) ;\n int f_boost = 0 ;\n int b_boost = 0 ;\n int flash_detected ;\n int active_max_gf_interval ;\n int64_t gf_group_bits ;\n double gf_group_error_left ;\n int gf_arf_bits ;\n if ( cpi -> common . frame_type != KEY_FRAME ) {\n vp9_zero ( twopass -> gf_group ) ;\n }\n vp9_clear_system_state ( ) ;\n vp9_zero ( next_frame ) ;\n mod_frame_err = calculate_modified_err ( twopass , oxcf , this_frame ) ;\n gf_first_frame_err = mod_frame_err ;\n if ( cpi -> common . frame_type == KEY_FRAME || rc -> source_alt_ref_active ) gf_group_err -= gf_first_frame_err ;\n mv_ratio_accumulator_thresh = ( cpi -> common . width + cpi -> common . height ) / 4.0 ;\n if ( cpi -> multi_arf_allowed ) {\n active_max_gf_interval = rc -> max_gf_interval ;\n }\n else {\n active_max_gf_interval = + ( ( int ) vp9_convert_qindex_to_q ( rc -> last_q [ INTER_FRAME ] , cpi -> common . bit_depth ) >> 5 ) ;\n if ( active_max_gf_interval > rc -> max_gf_interval ) active_max_gf_interval = rc -> max_gf_interval ;\n }\n i = 0 ;\n while ( i < rc -> static_scene_max_gf_interval && i < rc -> frames_to_key ) {\n ++ i ;\n mod_frame_err = calculate_modified_err ( twopass , oxcf , this_frame ) ;\n gf_group_err += mod_frame_err ;\n if ( EOF == input_stats ( twopass , & next_frame ) ) break ;\n flash_detected = detect_flash ( twopass , 0 ) ;\n accumulate_frame_motion_stats ( & next_frame , & this_frame_mv_in_out , & mv_in_out_accumulator , & abs_mv_in_out_accumulator , & mv_ratio_accumulator ) ;\n if ( ! flash_detected ) {\n last_loop_decay_rate = loop_decay_rate ;\n loop_decay_rate = get_prediction_decay_rate ( & cpi -> common , & next_frame ) ;\n decay_accumulator = decay_accumulator * loop_decay_rate ;\n zero_motion_accumulator = MIN ( zero_motion_accumulator , get_zero_motion_factor ( & cpi -> common , & next_frame ) ) ;\n if ( detect_transition_to_still ( twopass , i , 5 , loop_decay_rate , last_loop_decay_rate ) ) {\n allow_alt_ref = 0 ;\n break ;\n }\n }\n boost_score += decay_accumulator * calc_frame_boost ( cpi , & next_frame , this_frame_mv_in_out , GF_MAX_BOOST ) ;\n if ( ( i >= active_max_gf_interval && ( zero_motion_accumulator < 0.995 ) ) || ( ( i > MIN_GF_INTERVAL ) && ( ! flash_detected ) && ( ( mv_ratio_accumulator > mv_ratio_accumulator_thresh ) || ( abs_mv_in_out_accumulator > 3.0 ) || ( mv_in_out_accumulator < - 2.0 ) || ( ( boost_score - old_boost_score ) < BOOST_FACTOR ) ) ) ) {\n boost_score = old_boost_score ;\n break ;\n }\n * this_frame = next_frame ;\n old_boost_score = boost_score ;\n }\n twopass -> gf_zeromotion_pct = ( int ) ( zero_motion_accumulator * 1000.0 ) ;\n if ( cpi -> common . frame_type == KEY_FRAME || rc -> source_alt_ref_active ) rc -> baseline_gf_interval = i - 1 ;\n else rc -> baseline_gf_interval = i ;\n if ( is_two_pass_svc ( cpi ) && cpi -> svc . number_temporal_layers > 1 ) {\n int count = ( 1 << ( cpi -> svc . number_temporal_layers - 1 ) ) - 1 ;\n int new_gf_interval = ( rc -> baseline_gf_interval + count ) & ( ~ count ) ;\n int j ;\n for ( j = 0 ;\n j < new_gf_interval - rc -> baseline_gf_interval ;\n ++ j ) {\n if ( EOF == input_stats ( twopass , this_frame ) ) break ;\n gf_group_err += calculate_modified_err ( twopass , oxcf , this_frame ) ;\n }\n rc -> baseline_gf_interval = new_gf_interval ;\n }\n rc -> frames_till_gf_update_due = rc -> baseline_gf_interval ;\n if ( allow_alt_ref && ( i < cpi -> oxcf . lag_in_frames ) && ( i >= MIN_GF_INTERVAL ) ) {\n rc -> gfu_boost = calc_arf_boost ( cpi , 0 , ( i - 1 ) , ( i - 1 ) , & f_boost , & b_boost ) ;\n rc -> source_alt_ref_pending = 1 ;\n cpi -> multi_arf_enabled = ( cpi -> multi_arf_allowed && ( rc -> baseline_gf_interval >= 6 ) && ( zero_motion_accumulator < 0.995 ) ) ? 1 : 0 ;\n }\n else {\n rc -> gfu_boost = MAX ( ( int ) boost_score , 125 ) ;\n rc -> source_alt_ref_pending = 0 ;\n }\n reset_fpf_position ( twopass , start_pos ) ;\n gf_group_bits = calculate_total_gf_group_bits ( cpi , gf_group_err ) ;\n {\n int q = rc -> last_q [ INTER_FRAME ] ;\n int boost = ( rc -> gfu_boost * gfboost_qadjust ( q , cpi -> common . bit_depth ) ) / 100 ;\n boost = clamp ( boost , 125 , ( rc -> baseline_gf_interval + 1 ) * 200 ) ;\n gf_arf_bits = calculate_boost_bits ( rc -> baseline_gf_interval , boost , gf_group_bits ) ;\n }\n twopass -> kf_group_error_left -= ( int64_t ) gf_group_err ;\n if ( rc -> source_alt_ref_pending ) {\n gf_group_error_left = gf_group_err - mod_frame_err ;\n }\n else if ( cpi -> common . frame_type != KEY_FRAME ) {\n gf_group_error_left = gf_group_err - gf_first_frame_err ;\n }\n else {\n gf_group_error_left = gf_group_err ;\n }\n allocate_gf_group_bits ( cpi , gf_group_bits , gf_group_error_left , gf_arf_bits ) ;\n reset_fpf_position ( twopass , start_pos ) ;\n if ( cpi -> common . frame_type != KEY_FRAME ) {\n twopass -> section_intra_rating = calculate_section_intra_ratio ( start_pos , twopass -> stats_in_end , rc -> baseline_gf_interval ) ;\n }\n }", "idx": 20902}
{"hash": -866921002076081979, "project": "debian", "size": 21, "label": 0, "functionSource": "REGRESSION_TEST ( SDK_API_TSIOBufferProduce ) ( RegressionTest * test , int , int * pstatus ) {\n bool test_passed = false ;\n * pstatus = REGRESSION_TEST_INPROGRESS ;\n TSIOBuffer bufp = TSIOBufferSizedCreate ( TS_IOBUFFER_SIZE_INDEX_4K ) ;\n TSIOBufferReader readerp = TSIOBufferReaderAlloc ( bufp ) ;\n TSIOBufferProduce ( bufp , 10 ) ;\n int64_t reader_avail = TSIOBufferReaderAvail ( readerp ) ;\n if ( reader_avail == 10 ) {\n SDK_RPRINT ( test , \"TSIOBufferProduce\" , \"TestCase1\" , TC_PASS , \"ok\" ) ;\n SDK_RPRINT ( test , \"TSIOBufferReaderAlloc\" , \"TestCase1\" , TC_PASS , \"ok\" ) ;\n SDK_RPRINT ( test , \"TSIOBufferReaderAvail\" , \"TestCase1\" , TC_PASS , \"ok\" ) ;\n test_passed = true ;\n }\n else {\n SDK_RPRINT ( test , \"TSIOBufferProduce\" , \"TestCase1\" , TC_FAIL , \"failed\" ) ;\n SDK_RPRINT ( test , \"TSIOBufferReaderAlloc\" , \"TestCase1\" , TC_FAIL , \"failed\" ) ;\n SDK_RPRINT ( test , \"TSIOBufferReaderAvail\" , \"TestCase1\" , TC_FAIL , \"failed\" ) ;\n }\n * pstatus = ( ( test_passed == true ) ? REGRESSION_TEST_PASSED : REGRESSION_TEST_FAILED ) ;\n return ;\n }", "idx": 20903}
{"hash": -2222758297961835509, "project": "debian", "size": 17, "label": 0, "functionSource": "void ff_ivi_init_static_vlc ( void ) {\n int i ;\n static VLC_TYPE table_data [ 8192 * 16 ] [ 2 ] ;\n static int initialized_vlcs = 0 ;\n if ( initialized_vlcs ) return ;\n for ( i = 0 ;\n i < 8 ;\n i ++ ) {\n ivi_mb_vlc_tabs [ i ] . table = table_data + i * 2 * 8192 ;\n ivi_mb_vlc_tabs [ i ] . table_allocated = 8192 ;\n ivi_create_huff_from_desc ( & ff_ivi_mb_huff_desc [ i ] , & ivi_mb_vlc_tabs [ i ] , 1 ) ;\n ivi_blk_vlc_tabs [ i ] . table = table_data + ( i * 2 + 1 ) * 8192 ;\n ivi_blk_vlc_tabs [ i ] . table_allocated = 8192 ;\n ivi_create_huff_from_desc ( & ff_ivi_blk_huff_desc [ i ] , & ivi_blk_vlc_tabs [ i ] , 1 ) ;\n }\n initialized_vlcs = 1 ;\n }", "idx": 20904}
{"hash": -5268859819325807498, "project": "debian", "size": 13, "label": 0, "functionSource": "static void deep_count_got_info ( GObject * source_object , GAsyncResult * res , gpointer user_data ) {\n GFileInfo * info ;\n const char * id ;\n GFile * file = ( GFile * ) source_object ;\n DeepCountState * state = ( DeepCountState * ) user_data ;\n info = g_file_query_info_finish ( file , res , NULL ) ;\n if ( info != NULL ) {\n id = g_file_info_get_attribute_string ( info , G_FILE_ATTRIBUTE_ID_FILESYSTEM ) ;\n state -> fs_id = g_strdup ( id ) ;\n g_object_unref ( info ) ;\n }\n deep_count_load ( state , file ) ;\n }", "idx": 20905}
{"hash": -5385892304146930196, "project": "debian", "size": 17, "label": 0, "functionSource": "static int asf_write_index ( AVFormatContext * s , const ASFIndex * index , uint16_t max , uint32_t count ) {\n AVIOContext * pb = s -> pb ;\n int i ;\n ff_put_guid ( pb , & ff_asf_simple_index_header ) ;\n avio_wl64 ( pb , 24 + 16 + 8 + 4 + 4 + ( 4 + 2 ) * count ) ;\n ff_put_guid ( pb , & ff_asf_my_guid ) ;\n avio_wl64 ( pb , ASF_INDEXED_INTERVAL ) ;\n avio_wl32 ( pb , max ) ;\n avio_wl32 ( pb , count ) ;\n for ( i = 0 ;\n i < count ;\n i ++ ) {\n avio_wl32 ( pb , index [ i ] . packet_number ) ;\n avio_wl16 ( pb , index [ i ] . packet_count ) ;\n }\n return 0 ;\n }", "idx": 20906}
{"hash": 2895622461494525400, "project": "debian", "size": 72, "label": 0, "functionSource": "static void test_bug1500 ( ) {\n MYSQL_STMT * stmt ;\n MYSQL_BIND my_bind [ 3 ] ;\n int rc ;\n int32 int_data [ 3 ] = {\n 2 , 3 , 4 }\n ;\n const char * data ;\n myheader ( \"test_bug1500\" ) ;\n rc = mysql_query ( mysql , \"DROP TABLE IF EXISTS test_bg1500\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"CREATE TABLE test_bg1500 (i INT)\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"INSERT INTO test_bg1500 VALUES (1), (2)\" ) ;\n myquery ( rc ) ;\n rc = mysql_commit ( mysql ) ;\n myquery ( rc ) ;\n stmt = mysql_simple_prepare ( mysql , \"SELECT i FROM test_bg1500 WHERE i IN (?, ?, ?)\" ) ;\n check_stmt ( stmt ) ;\n verify_param_count ( stmt , 3 ) ;\n memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n my_bind [ 0 ] . buffer = ( void * ) int_data ;\n my_bind [ 0 ] . buffer_type = MYSQL_TYPE_LONG ;\n my_bind [ 2 ] = my_bind [ 1 ] = my_bind [ 0 ] ;\n my_bind [ 1 ] . buffer = ( void * ) ( int_data + 1 ) ;\n my_bind [ 2 ] . buffer = ( void * ) ( int_data + 2 ) ;\n rc = mysql_stmt_bind_param ( stmt , my_bind ) ;\n check_execute ( stmt , rc ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n rc = my_process_stmt_result ( stmt ) ;\n DIE_UNLESS ( rc == 1 ) ;\n mysql_stmt_close ( stmt ) ;\n rc = mysql_query ( mysql , \"DROP TABLE test_bg1500\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"CREATE TABLE test_bg1500 (s VARCHAR(25), FULLTEXT(s)) engine=MyISAM\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"INSERT INTO test_bg1500 VALUES ('Gravedigger'), ('Greed'), ('Hollow Dogs')\" ) ;\n myquery ( rc ) ;\n rc = mysql_commit ( mysql ) ;\n myquery ( rc ) ;\n stmt = mysql_simple_prepare ( mysql , \"SELECT s FROM test_bg1500 WHERE MATCH (s) AGAINST (?)\" ) ;\n check_stmt ( stmt ) ;\n verify_param_count ( stmt , 1 ) ;\n data = \"Dogs\" ;\n my_bind [ 0 ] . buffer_type = MYSQL_TYPE_STRING ;\n my_bind [ 0 ] . buffer = ( void * ) data ;\n my_bind [ 0 ] . buffer_length = strlen ( data ) ;\n my_bind [ 0 ] . is_null = 0 ;\n my_bind [ 0 ] . length = 0 ;\n rc = mysql_stmt_bind_param ( stmt , my_bind ) ;\n check_execute ( stmt , rc ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n rc = my_process_stmt_result ( stmt ) ;\n DIE_UNLESS ( rc == 1 ) ;\n mysql_stmt_close ( stmt ) ;\n stmt = mysql_simple_prepare ( mysql , \"SELECT s FROM test_bg1500 WHERE MATCH (s) AGAINST (CONCAT(?, 'digger'))\" ) ;\n check_stmt ( stmt ) ;\n verify_param_count ( stmt , 1 ) ;\n data = \"Grave\" ;\n my_bind [ 0 ] . buffer_type = MYSQL_TYPE_STRING ;\n my_bind [ 0 ] . buffer = ( void * ) data ;\n my_bind [ 0 ] . buffer_length = strlen ( data ) ;\n rc = mysql_stmt_bind_param ( stmt , my_bind ) ;\n check_execute ( stmt , rc ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n rc = my_process_stmt_result ( stmt ) ;\n DIE_UNLESS ( rc == 1 ) ;\n mysql_stmt_close ( stmt ) ;\n }", "idx": 20907}
{"hash": -4555950263653671147, "project": "debian", "size": 18, "label": 0, "functionSource": "static PyObject * string_encode ( PyStringObject * self , PyObject * args , PyObject * kwargs ) {\n static char * kwlist [ ] = {\n \"encoding\" , \"errors\" , 0 }\n ;\n char * encoding = NULL ;\n char * errors = NULL ;\n PyObject * v ;\n if ( ! PyArg_ParseTupleAndKeywords ( args , kwargs , \"|ss:encode\" , kwlist , & encoding , & errors ) ) return NULL ;\n v = PyString_AsEncodedObject ( ( PyObject * ) self , encoding , errors ) ;\n if ( v == NULL ) goto onError ;\n if ( ! PyString_Check ( v ) && ! PyUnicode_Check ( v ) ) {\n PyErr_Format ( PyExc_TypeError , \"encoder did not return a string/unicode object \" \"(type=%.400s)\" , Py_TYPE ( v ) -> tp_name ) ;\n Py_DECREF ( v ) ;\n return NULL ;\n }\n return v ;\n onError : return NULL ;\n }", "idx": 20908}
{"hash": -5115519918147424659, "project": "chrome", "size": 4, "label": 0, "functionSource": "extern int main ( int argc , const char * argv [ ] ) {\n TestLenient8Iterator ( ) ;\n return 0 ;\n }", "idx": 20909}
{"hash": 5357882892791796049, "project": "debian", "size": 6, "label": 0, "functionSource": "static uint32_t e1000e_mac_read_clr8 ( E1000ECore * core , int index ) {\n uint32_t ret = core -> mac [ index ] ;\n core -> mac [ index ] = 0 ;\n core -> mac [ index - 1 ] = 0 ;\n return ret ;\n }", "idx": 20910}
{"hash": -1315695702746584250, "project": "debian", "size": 11, "label": 0, "functionSource": "static void proto_tree_set_uint ( field_info * fi , guint32 value ) {\n header_field_info * hfinfo ;\n guint32 integer ;\n hfinfo = fi -> hfinfo ;\n integer = value ;\n if ( hfinfo -> bitmask ) {\n integer &= ( guint32 ) ( hfinfo -> bitmask ) ;\n integer >>= hfinfo_bitshift ( hfinfo ) ;\n }\n fvalue_set_uinteger ( & fi -> value , integer ) ;\n }", "idx": 20911}
{"hash": 1458662858915721428, "project": "debian", "size": 27, "label": 0, "functionSource": "static void tb_link_page ( TranslationBlock * tb , tb_page_addr_t phys_pc , tb_page_addr_t phys_page2 ) {\n unsigned int h ;\n TranslationBlock * * ptb ;\n mmap_lock ( ) ;\n h = tb_phys_hash_func ( phys_pc ) ;\n ptb = & tcg_ctx . tb_ctx . tb_phys_hash [ h ] ;\n tb -> phys_hash_next = * ptb ;\n * ptb = tb ;\n tb_alloc_page ( tb , 0 , phys_pc & TARGET_PAGE_MASK ) ;\n if ( phys_page2 != - 1 ) {\n tb_alloc_page ( tb , 1 , phys_page2 ) ;\n }\n else {\n tb -> page_addr [ 1 ] = - 1 ;\n }\n tb -> jmp_first = ( TranslationBlock * ) ( ( uintptr_t ) tb | 2 ) ;\n tb -> jmp_next [ 0 ] = NULL ;\n tb -> jmp_next [ 1 ] = NULL ;\n if ( tb -> tb_next_offset [ 0 ] != 0xffff ) {\n tb_reset_jump ( tb , 0 ) ;\n }\n if ( tb -> tb_next_offset [ 1 ] != 0xffff ) {\n tb_reset_jump ( tb , 1 ) ;\n }\n # ifdef DEBUG_TB_CHECK tb_page_check ( ) ;\n # endif mmap_unlock ( ) ;\n }", "idx": 20912}
{"hash": 8206514580434225668, "project": "chrome", "size": 10, "label": 1, "functionSource": "IN_PROC_BROWSER_TEST_F ( HttpsEngagementPageLoadMetricsBrowserTest , UncommittedLoadWithError ) {\n StartHttpsServer ( true ) ;\n TabStripModel * tab_strip_model = browser ( ) -> tab_strip_model ( ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , https_test_server_ -> GetURL ( \"/simple.html\" ) ) ;\n content : : WebContentsDestroyedWatcher destroyed_watcher ( tab_strip_model -> GetActiveWebContents ( ) ) ;\n EXPECT_TRUE ( tab_strip_model -> CloseWebContentsAt ( tab_strip_model -> active_index ( ) , 0 ) ) ;\n destroyed_watcher . Wait ( ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHttpEngagementHistogram , 0 ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHttpsEngagementHistogram , 0 ) ;\n }", "idx": 20913}
{"hash": 5825340398912191389, "project": "debian", "size": 7, "label": 0, "functionSource": "extern int name ( int ) __THROW __exctype ( isalnum ) ;\n __exctype ( isalpha ) ;\n __exctype ( iscntrl ) ;\n __exctype ( isdigit ) ;\n __exctype ( islower ) ;\n __exctype ( isgraph ) ;\n __exctype ( isprint )", "idx": 20914}
{"hash": 2546373479020365143, "project": "debian", "size": 20, "label": 0, "functionSource": "int mime_hdr_fields_count ( MIMEHdrImpl * mh ) {\n unsigned int index ;\n MIMEFieldBlockImpl * fblock ;\n MIMEField * field ;\n int count ;\n count = 0 ;\n for ( fblock = & ( mh -> m_first_fblock ) ;\n fblock != nullptr ;\n fblock = fblock -> m_next ) {\n for ( index = 0 ;\n index < fblock -> m_freetop ;\n index ++ ) {\n field = & ( fblock -> m_field_slots [ index ] ) ;\n if ( field -> is_live ( ) ) {\n ++ count ;\n }\n }\n }\n return count ;\n }", "idx": 20915}
{"hash": -2222463888415249941, "project": "chrome", "size": 39, "label": 0, "functionSource": "static void calc_psnr ( const YV12_BUFFER_CONFIG * a , const YV12_BUFFER_CONFIG * b , PSNR_STATS * psnr ) {\n const int widths [ 3 ] = {\n a -> y_width , a -> uv_width , a -> uv_width }\n ;\n const int heights [ 3 ] = {\n a -> y_height , a -> uv_height , a -> uv_height }\n ;\n const uint8_t * a_planes [ 3 ] = {\n a -> y_buffer , a -> u_buffer , a -> v_buffer }\n ;\n const int a_strides [ 3 ] = {\n a -> y_stride , a -> uv_stride , a -> uv_stride }\n ;\n const uint8_t * b_planes [ 3 ] = {\n b -> y_buffer , b -> u_buffer , b -> v_buffer }\n ;\n const int b_strides [ 3 ] = {\n b -> y_stride , b -> uv_stride , b -> uv_stride }\n ;\n int i ;\n uint64_t total_sse = 0 ;\n uint32_t total_samples = 0 ;\n for ( i = 0 ;\n i < 3 ;\n ++ i ) {\n const int w = widths [ i ] ;\n const int h = heights [ i ] ;\n const uint32_t samples = w * h ;\n const uint64_t sse = get_sse ( a_planes [ i ] , a_strides [ i ] , b_planes [ i ] , b_strides [ i ] , w , h ) ;\n psnr -> sse [ 1 + i ] = sse ;\n psnr -> samples [ 1 + i ] = samples ;\n psnr -> psnr [ 1 + i ] = vpx_sse_to_psnr ( samples , 255.0 , ( double ) sse ) ;\n total_sse += sse ;\n total_samples += samples ;\n }\n psnr -> sse [ 0 ] = total_sse ;\n psnr -> samples [ 0 ] = total_samples ;\n psnr -> psnr [ 0 ] = vpx_sse_to_psnr ( ( double ) total_samples , 255.0 , ( double ) total_sse ) ;\n }", "idx": 20916}
{"hash": 2335222688263906532, "project": "debian", "size": 8, "label": 0, "functionSource": "static int is_mv_diff_gt_3 ( int16_t ( * motion_val ) [ 2 ] , int step ) {\n int d ;\n d = motion_val [ 0 ] [ 0 ] - motion_val [ - step ] [ 0 ] ;\n if ( d < - 3 || d > 3 ) return 1 ;\n d = motion_val [ 0 ] [ 1 ] - motion_val [ - step ] [ 1 ] ;\n if ( d < - 3 || d > 3 ) return 1 ;\n return 0 ;\n }", "idx": 20917}
{"hash": -2222758297961835509, "project": "debian", "size": 3, "label": 0, "functionSource": "static int ivi_huff_desc_cmp ( const IVIHuffDesc * desc1 , const IVIHuffDesc * desc2 ) {\n return desc1 -> num_rows != desc2 -> num_rows || memcmp ( desc1 -> xbits , desc2 -> xbits , desc1 -> num_rows ) ;\n }", "idx": 20918}
{"hash": 7424930167238097621, "project": "debian", "size": 229, "label": 0, "functionSource": "static int proc_do_submiturb ( struct usb_dev_state * ps , struct usbdevfs_urb * uurb , struct usbdevfs_iso_packet_desc __user * iso_frame_desc , void __user * arg ) {\n struct usbdevfs_iso_packet_desc * isopkt = NULL ;\n struct usb_host_endpoint * ep ;\n struct async * as = NULL ;\n struct usb_ctrlrequest * dr = NULL ;\n unsigned int u , totlen , isofrmlen ;\n int i , ret , is_in , num_sgs = 0 , ifnum = - 1 ;\n int number_of_packets = 0 ;\n unsigned int stream_id = 0 ;\n void * buf ;\n if ( uurb -> flags & ~ ( USBDEVFS_URB_ISO_ASAP | USBDEVFS_URB_SHORT_NOT_OK | USBDEVFS_URB_BULK_CONTINUATION | USBDEVFS_URB_NO_FSBR | USBDEVFS_URB_ZERO_PACKET | USBDEVFS_URB_NO_INTERRUPT ) ) return - EINVAL ;\n if ( uurb -> buffer_length > 0 && ! uurb -> buffer ) return - EINVAL ;\n if ( ! ( uurb -> type == USBDEVFS_URB_TYPE_CONTROL && ( uurb -> endpoint & ~ USB_ENDPOINT_DIR_MASK ) == 0 ) ) {\n ifnum = findintfep ( ps -> dev , uurb -> endpoint ) ;\n if ( ifnum < 0 ) return ifnum ;\n ret = checkintf ( ps , ifnum ) ;\n if ( ret ) return ret ;\n }\n ep = ep_to_host_endpoint ( ps -> dev , uurb -> endpoint ) ;\n if ( ! ep ) return - ENOENT ;\n is_in = ( uurb -> endpoint & USB_ENDPOINT_DIR_MASK ) != 0 ;\n u = 0 ;\n switch ( uurb -> type ) {\n case USBDEVFS_URB_TYPE_CONTROL : if ( ! usb_endpoint_xfer_control ( & ep -> desc ) ) return - EINVAL ;\n if ( uurb -> buffer_length < 8 ) return - EINVAL ;\n dr = kmalloc ( sizeof ( struct usb_ctrlrequest ) , GFP_KERNEL ) ;\n if ( ! dr ) return - ENOMEM ;\n if ( copy_from_user ( dr , uurb -> buffer , 8 ) ) {\n ret = - EFAULT ;\n goto error ;\n }\n if ( uurb -> buffer_length < ( le16_to_cpup ( & dr -> wLength ) + 8 ) ) {\n ret = - EINVAL ;\n goto error ;\n }\n ret = check_ctrlrecip ( ps , dr -> bRequestType , dr -> bRequest , le16_to_cpup ( & dr -> wIndex ) ) ;\n if ( ret ) goto error ;\n uurb -> buffer_length = le16_to_cpup ( & dr -> wLength ) ;\n uurb -> buffer += 8 ;\n if ( ( dr -> bRequestType & USB_DIR_IN ) && uurb -> buffer_length ) {\n is_in = 1 ;\n uurb -> endpoint |= USB_DIR_IN ;\n }\n else {\n is_in = 0 ;\n uurb -> endpoint &= ~ USB_DIR_IN ;\n }\n snoop ( & ps -> dev -> dev , \"control urb: bRequestType=%02x \" \"bRequest=%02x wValue=%04x \" \"wIndex=%04x wLength=%04x\\n\" , dr -> bRequestType , dr -> bRequest , __le16_to_cpup ( & dr -> wValue ) , __le16_to_cpup ( & dr -> wIndex ) , __le16_to_cpup ( & dr -> wLength ) ) ;\n u = sizeof ( struct usb_ctrlrequest ) ;\n break ;\n case USBDEVFS_URB_TYPE_BULK : switch ( usb_endpoint_type ( & ep -> desc ) ) {\n case USB_ENDPOINT_XFER_CONTROL : case USB_ENDPOINT_XFER_ISOC : return - EINVAL ;\n case USB_ENDPOINT_XFER_INT : uurb -> type = USBDEVFS_URB_TYPE_INTERRUPT ;\n goto interrupt_urb ;\n }\n num_sgs = DIV_ROUND_UP ( uurb -> buffer_length , USB_SG_SIZE ) ;\n if ( num_sgs == 1 || num_sgs > ps -> dev -> bus -> sg_tablesize ) num_sgs = 0 ;\n if ( ep -> streams ) stream_id = uurb -> stream_id ;\n break ;\n case USBDEVFS_URB_TYPE_INTERRUPT : if ( ! usb_endpoint_xfer_int ( & ep -> desc ) ) return - EINVAL ;\n interrupt_urb : break ;\n case USBDEVFS_URB_TYPE_ISO : if ( uurb -> number_of_packets < 1 || uurb -> number_of_packets > 128 ) return - EINVAL ;\n if ( ! usb_endpoint_xfer_isoc ( & ep -> desc ) ) return - EINVAL ;\n number_of_packets = uurb -> number_of_packets ;\n isofrmlen = sizeof ( struct usbdevfs_iso_packet_desc ) * number_of_packets ;\n isopkt = memdup_user ( iso_frame_desc , isofrmlen ) ;\n if ( IS_ERR ( isopkt ) ) {\n ret = PTR_ERR ( isopkt ) ;\n isopkt = NULL ;\n goto error ;\n }\n for ( totlen = u = 0 ;\n u < number_of_packets ;\n u ++ ) {\n if ( isopkt [ u ] . length > 49152 ) {\n ret = - EINVAL ;\n goto error ;\n }\n totlen += isopkt [ u ] . length ;\n }\n u *= sizeof ( struct usb_iso_packet_descriptor ) ;\n uurb -> buffer_length = totlen ;\n break ;\n default : return - EINVAL ;\n }\n if ( uurb -> buffer_length >= USBFS_XFER_MAX ) {\n ret = - EINVAL ;\n goto error ;\n }\n if ( uurb -> buffer_length > 0 && ! access_ok ( is_in ? VERIFY_WRITE : VERIFY_READ , uurb -> buffer , uurb -> buffer_length ) ) {\n ret = - EFAULT ;\n goto error ;\n }\n as = alloc_async ( number_of_packets ) ;\n if ( ! as ) {\n ret = - ENOMEM ;\n goto error ;\n }\n as -> usbm = find_memory_area ( ps , uurb ) ;\n if ( IS_ERR ( as -> usbm ) ) {\n ret = PTR_ERR ( as -> usbm ) ;\n as -> usbm = NULL ;\n goto error ;\n }\n if ( as -> usbm ) num_sgs = 0 ;\n u += sizeof ( struct async ) + sizeof ( struct urb ) + uurb -> buffer_length + num_sgs * sizeof ( struct scatterlist ) ;\n ret = usbfs_increase_memory_usage ( u ) ;\n if ( ret ) goto error ;\n as -> mem_usage = u ;\n if ( num_sgs ) {\n as -> urb -> sg = kmalloc ( num_sgs * sizeof ( struct scatterlist ) , GFP_KERNEL ) ;\n if ( ! as -> urb -> sg ) {\n ret = - ENOMEM ;\n goto error ;\n }\n as -> urb -> num_sgs = num_sgs ;\n sg_init_table ( as -> urb -> sg , as -> urb -> num_sgs ) ;\n totlen = uurb -> buffer_length ;\n for ( i = 0 ;\n i < as -> urb -> num_sgs ;\n i ++ ) {\n u = ( totlen > USB_SG_SIZE ) ? USB_SG_SIZE : totlen ;\n buf = kmalloc ( u , GFP_KERNEL ) ;\n if ( ! buf ) {\n ret = - ENOMEM ;\n goto error ;\n }\n sg_set_buf ( & as -> urb -> sg [ i ] , buf , u ) ;\n if ( ! is_in ) {\n if ( copy_from_user ( buf , uurb -> buffer , u ) ) {\n ret = - EFAULT ;\n goto error ;\n }\n uurb -> buffer += u ;\n }\n totlen -= u ;\n }\n }\n else if ( uurb -> buffer_length > 0 ) {\n if ( as -> usbm ) {\n unsigned long uurb_start = ( unsigned long ) uurb -> buffer ;\n as -> urb -> transfer_buffer = as -> usbm -> mem + ( uurb_start - as -> usbm -> vm_start ) ;\n }\n else {\n as -> urb -> transfer_buffer = kmalloc ( uurb -> buffer_length , GFP_KERNEL ) ;\n if ( ! as -> urb -> transfer_buffer ) {\n ret = - ENOMEM ;\n goto error ;\n }\n if ( ! is_in ) {\n if ( copy_from_user ( as -> urb -> transfer_buffer , uurb -> buffer , uurb -> buffer_length ) ) {\n ret = - EFAULT ;\n goto error ;\n }\n }\n else if ( uurb -> type == USBDEVFS_URB_TYPE_ISO ) {\n memset ( as -> urb -> transfer_buffer , 0 , uurb -> buffer_length ) ;\n }\n }\n }\n as -> urb -> dev = ps -> dev ;\n as -> urb -> pipe = ( uurb -> type << 30 ) | __create_pipe ( ps -> dev , uurb -> endpoint & 0xf ) | ( uurb -> endpoint & USB_DIR_IN ) ;\n u = ( is_in ? URB_DIR_IN : URB_DIR_OUT ) ;\n if ( uurb -> flags & USBDEVFS_URB_ISO_ASAP ) u |= URB_ISO_ASAP ;\n if ( uurb -> flags & USBDEVFS_URB_SHORT_NOT_OK && is_in ) u |= URB_SHORT_NOT_OK ;\n if ( uurb -> flags & USBDEVFS_URB_NO_FSBR ) u |= URB_NO_FSBR ;\n if ( uurb -> flags & USBDEVFS_URB_ZERO_PACKET ) u |= URB_ZERO_PACKET ;\n if ( uurb -> flags & USBDEVFS_URB_NO_INTERRUPT ) u |= URB_NO_INTERRUPT ;\n as -> urb -> transfer_flags = u ;\n as -> urb -> transfer_buffer_length = uurb -> buffer_length ;\n as -> urb -> setup_packet = ( unsigned char * ) dr ;\n dr = NULL ;\n as -> urb -> start_frame = uurb -> start_frame ;\n as -> urb -> number_of_packets = number_of_packets ;\n as -> urb -> stream_id = stream_id ;\n if ( uurb -> type == USBDEVFS_URB_TYPE_ISO || ps -> dev -> speed == USB_SPEED_HIGH ) as -> urb -> interval = 1 << min ( 15 , ep -> desc . bInterval - 1 ) ;\n else as -> urb -> interval = ep -> desc . bInterval ;\n as -> urb -> context = as ;\n as -> urb -> complete = async_completed ;\n for ( totlen = u = 0 ;\n u < number_of_packets ;\n u ++ ) {\n as -> urb -> iso_frame_desc [ u ] . offset = totlen ;\n as -> urb -> iso_frame_desc [ u ] . length = isopkt [ u ] . length ;\n totlen += isopkt [ u ] . length ;\n }\n kfree ( isopkt ) ;\n isopkt = NULL ;\n as -> ps = ps ;\n as -> userurb = arg ;\n if ( as -> usbm ) {\n unsigned long uurb_start = ( unsigned long ) uurb -> buffer ;\n as -> urb -> transfer_flags |= URB_NO_TRANSFER_DMA_MAP ;\n as -> urb -> transfer_dma = as -> usbm -> dma_handle + ( uurb_start - as -> usbm -> vm_start ) ;\n }\n else if ( is_in && uurb -> buffer_length > 0 ) as -> userbuffer = uurb -> buffer ;\n as -> signr = uurb -> signr ;\n as -> ifnum = ifnum ;\n as -> pid = get_pid ( task_pid ( current ) ) ;\n as -> cred = get_current_cred ( ) ;\n security_task_getsecid ( current , & as -> secid ) ;\n snoop_urb ( ps -> dev , as -> userurb , as -> urb -> pipe , as -> urb -> transfer_buffer_length , 0 , SUBMIT , NULL , 0 ) ;\n if ( ! is_in ) snoop_urb_data ( as -> urb , as -> urb -> transfer_buffer_length ) ;\n async_newpending ( as ) ;\n if ( usb_endpoint_xfer_bulk ( & ep -> desc ) ) {\n spin_lock_irq ( & ps -> lock ) ;\n as -> bulk_addr = usb_endpoint_num ( & ep -> desc ) | ( ( ep -> desc . bEndpointAddress & USB_ENDPOINT_DIR_MASK ) >> 3 ) ;\n if ( uurb -> flags & USBDEVFS_URB_BULK_CONTINUATION ) as -> bulk_status = AS_CONTINUATION ;\n else ps -> disabled_bulk_eps &= ~ ( 1 << as -> bulk_addr ) ;\n if ( ps -> disabled_bulk_eps & ( 1 << as -> bulk_addr ) ) ret = - EREMOTEIO ;\n else ret = usb_submit_urb ( as -> urb , GFP_ATOMIC ) ;\n spin_unlock_irq ( & ps -> lock ) ;\n }\n else {\n ret = usb_submit_urb ( as -> urb , GFP_KERNEL ) ;\n }\n if ( ret ) {\n dev_printk ( KERN_DEBUG , & ps -> dev -> dev , \"usbfs: usb_submit_urb returned %d\\n\" , ret ) ;\n snoop_urb ( ps -> dev , as -> userurb , as -> urb -> pipe , 0 , ret , COMPLETE , NULL , 0 ) ;\n async_removepending ( as ) ;\n goto error ;\n }\n return 0 ;\n error : if ( as && as -> usbm ) dec_usb_memory_use_count ( as -> usbm , & as -> usbm -> urb_use_count ) ;\n kfree ( isopkt ) ;\n kfree ( dr ) ;\n if ( as ) free_async ( as ) ;\n return ret ;\n }", "idx": 20919}
{"hash": -7777331401175181229, "project": "debian", "size": 17, "label": 0, "functionSource": "static SERVER_SETUP_REC * create_server_setup ( GHashTable * optlist ) {\n CHAT_PROTOCOL_REC * rec ;\n SERVER_SETUP_REC * server ;\n char * chatnet ;\n rec = chat_protocol_find_net ( optlist ) ;\n if ( rec == NULL ) rec = chat_protocol_get_default ( ) ;\n else {\n chatnet = g_hash_table_lookup ( optlist , rec -> chatnet ) ;\n if ( chatnet_find ( chatnet ) == NULL ) {\n printformat ( NULL , NULL , MSGLEVEL_CLIENTNOTICE , TXT_UNKNOWN_CHATNET , chatnet ) ;\n return NULL ;\n }\n }\n server = rec -> create_server_setup ( ) ;\n server -> chat_type = rec -> id ;\n return server ;\n }", "idx": 20920}
{"hash": -714975729066076397, "project": "chrome", "size": 18, "label": 0, "functionSource": "static bool _try_writable ( hb_blob_t * blob ) {\n if ( blob -> immutable ) return false ;\n if ( blob -> mode == HB_MEMORY_MODE_WRITABLE ) return true ;\n if ( blob -> mode == HB_MEMORY_MODE_READONLY_MAY_MAKE_WRITABLE && _try_writable_inplace ( blob ) ) return true ;\n if ( blob -> mode == HB_MEMORY_MODE_WRITABLE ) return true ;\n DEBUG_MSG_FUNC ( BLOB , blob , \"current data is -> %p\\n\" , blob -> data ) ;\n char * new_data ;\n new_data = ( char * ) malloc ( blob -> length ) ;\n if ( unlikely ( ! new_data ) ) return false ;\n DEBUG_MSG_FUNC ( BLOB , blob , \"dupped successfully -> %p\\n\" , blob -> data ) ;\n memcpy ( new_data , blob -> data , blob -> length ) ;\n _hb_blob_destroy_user_data ( blob ) ;\n blob -> mode = HB_MEMORY_MODE_WRITABLE ;\n blob -> data = new_data ;\n blob -> user_data = new_data ;\n blob -> destroy = free ;\n return true ;\n }", "idx": 20921}
{"hash": -6561679584559270089, "project": "chrome", "size": 65, "label": 0, "functionSource": "int ff_get_qtpalette ( int codec_id , AVIOContext * pb , uint32_t * palette ) {\n int tmp , bit_depth , color_table_id , greyscale , i ;\n avio_seek ( pb , 82 , SEEK_CUR ) ;\n tmp = avio_rb16 ( pb ) ;\n bit_depth = tmp & 0x1F ;\n greyscale = tmp & 0x20 ;\n color_table_id = avio_rb16 ( pb ) ;\n if ( greyscale && codec_id == AV_CODEC_ID_CINEPAK ) return 0 ;\n if ( ( bit_depth == 1 || bit_depth == 2 || bit_depth == 4 || bit_depth == 8 ) ) {\n uint32_t color_count , color_start , color_end ;\n uint32_t a , r , g , b ;\n if ( greyscale && bit_depth > 1 && color_table_id ) {\n int color_index , color_dec ;\n color_count = 1 << bit_depth ;\n color_index = 255 ;\n color_dec = 256 / ( color_count - 1 ) ;\n for ( i = 0 ;\n i < color_count ;\n i ++ ) {\n r = g = b = color_index ;\n palette [ i ] = ( 0xFFU << 24 ) | ( r << 16 ) | ( g << 8 ) | ( b ) ;\n color_index -= color_dec ;\n if ( color_index < 0 ) color_index = 0 ;\n }\n }\n else if ( color_table_id ) {\n const uint8_t * color_table ;\n color_count = 1 << bit_depth ;\n if ( bit_depth == 1 ) color_table = ff_qt_default_palette_2 ;\n else if ( bit_depth == 2 ) color_table = ff_qt_default_palette_4 ;\n else if ( bit_depth == 4 ) color_table = ff_qt_default_palette_16 ;\n else color_table = ff_qt_default_palette_256 ;\n for ( i = 0 ;\n i < color_count ;\n i ++ ) {\n r = color_table [ i * 3 + 0 ] ;\n g = color_table [ i * 3 + 1 ] ;\n b = color_table [ i * 3 + 2 ] ;\n palette [ i ] = ( 0xFFU << 24 ) | ( r << 16 ) | ( g << 8 ) | ( b ) ;\n }\n }\n else {\n color_start = avio_rb32 ( pb ) ;\n avio_rb16 ( pb ) ;\n color_end = avio_rb16 ( pb ) ;\n if ( ( color_start <= 255 ) && ( color_end <= 255 ) ) {\n for ( i = color_start ;\n i <= color_end ;\n i ++ ) {\n a = avio_r8 ( pb ) ;\n avio_r8 ( pb ) ;\n r = avio_r8 ( pb ) ;\n avio_r8 ( pb ) ;\n g = avio_r8 ( pb ) ;\n avio_r8 ( pb ) ;\n b = avio_r8 ( pb ) ;\n avio_r8 ( pb ) ;\n palette [ i ] = ( a << 24 ) | ( r << 16 ) | ( g << 8 ) | ( b ) ;\n }\n }\n }\n return 1 ;\n }\n return 0 ;\n }", "idx": 20922}
{"hash": -866921002076081979, "project": "debian", "size": 27, "label": 0, "functionSource": "static int checkHttpTxnIncomingAddrGet ( SocketTest * test , void * data ) {\n uint16_t port ;\n HttpProxyPort * proxy_port = HttpProxyPort : : findHttp ( AF_INET ) ;\n TSHttpTxn txnp = ( TSHttpTxn ) data ;\n sockaddr const * ptr = TSHttpTxnIncomingAddrGet ( txnp ) ;\n if ( nullptr == proxy_port ) {\n SDK_RPRINT ( test -> regtest , \"TSHttpTxnIncomingPortGet\" , \"TestCase1\" , TC_FAIL , \"TSHttpTxnIncomingAddrGet failed to find configured HTTP port.\" ) ;\n test -> test_client_incoming_port_get = false ;\n return TS_EVENT_CONTINUE ;\n }\n if ( nullptr == ptr ) {\n SDK_RPRINT ( test -> regtest , \"TSHttpTxnIncomingPortGet\" , \"TestCase1\" , TC_FAIL , \"TSHttpTxnIncomingAddrGet returns 0 pointer\" ) ;\n test -> test_client_incoming_port_get = false ;\n return TS_EVENT_CONTINUE ;\n }\n port = ats_ip_port_host_order ( ptr ) ;\n TSDebug ( UTDBG_TAG , \"TS HTTP port = %x, Txn incoming client port %x\" , proxy_port -> m_port , port ) ;\n if ( port == proxy_port -> m_port ) {\n SDK_RPRINT ( test -> regtest , \"TSHttpTxnIncomingAddrGet\" , \"TestCase1\" , TC_PASS , \"ok\" ) ;\n test -> test_client_incoming_port_get = true ;\n }\n else {\n SDK_RPRINT ( test -> regtest , \"TSHttpTxnIncomingAddrGet\" , \"TestCase1\" , TC_FAIL , \"Value's Mismatch. From Function: %d Expected value: %d\" , port , proxy_port -> m_port ) ;\n test -> test_client_incoming_port_get = false ;\n }\n return TS_EVENT_CONTINUE ;\n }", "idx": 20923}
{"hash": -273984976102410662, "project": "chrome", "size": 3, "label": 0, "functionSource": "static inline void uprv_arrayCopy ( const int32_t * src , int32_t srcStart , int32_t * dst , int32_t dstStart , int32_t count ) {\n uprv_memcpy ( dst + dstStart , src + srcStart , ( size_t ) count * sizeof ( * src ) ) ;\n }", "idx": 20924}
{"hash": -4596135714614925483, "project": "debian", "size": 27, "label": 0, "functionSource": "static long timelib_parse_tz_cor ( char * * ptr ) {\n char * begin = * ptr , * end ;\n long tmp ;\n while ( isdigit ( * * ptr ) || * * ptr == ':' ) {\n ++ * ptr ;\n }\n end = * ptr ;\n switch ( end - begin ) {\n case 1 : case 2 : return HOUR ( strtol ( begin , NULL , 10 ) ) ;\n break ;\n case 3 : case 4 : if ( begin [ 1 ] == ':' ) {\n tmp = HOUR ( strtol ( begin , NULL , 10 ) ) + strtol ( begin + 2 , NULL , 10 ) ;\n return tmp ;\n }\n else if ( begin [ 2 ] == ':' ) {\n tmp = HOUR ( strtol ( begin , NULL , 10 ) ) + strtol ( begin + 3 , NULL , 10 ) ;\n return tmp ;\n }\n else {\n tmp = strtol ( begin , NULL , 10 ) ;\n return HOUR ( tmp / 100 ) + tmp % 100 ;\n }\n case 5 : tmp = HOUR ( strtol ( begin , NULL , 10 ) ) + strtol ( begin + 3 , NULL , 10 ) ;\n return tmp ;\n }\n return 0 ;\n }", "idx": 20925}
{"hash": -3559021711340554904, "project": "debian", "size": 3, "label": 0, "functionSource": "bool contain_leaked_vars ( Node * clause ) {\n return contain_leaked_vars_walker ( clause , NULL ) ;\n }", "idx": 20926}
{"hash": -8925552398357902286, "project": "chrome", "size": 8, "label": 1, "functionSource": "static void init_bit_trees ( ) {\n init_bit_tree ( cat1 , 1 ) ;\n init_bit_tree ( cat2 , 2 ) ;\n init_bit_tree ( cat3 , 3 ) ;\n init_bit_tree ( cat4 , 4 ) ;\n init_bit_tree ( cat5 , 5 ) ;\n init_bit_tree ( cat6 , 14 ) ;\n }", "idx": 20927}
{"hash": 6250095321513210169, "project": "debian", "size": 9, "label": 0, "functionSource": "rfbBool rfbFilenameTranslate2DOS ( rfbClientPtr cl , char * unixPath , char * path ) {\n int x ;\n FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN ( \"\" , cl , FALSE ) ;\n sprintf ( path , \"C:%s\" , unixPath ) ;\n for ( x = 2 ;\n x < strlen ( path ) ;\n x ++ ) if ( path [ x ] == '/' ) path [ x ] = '\\\\' ;\n return TRUE ;\n }", "idx": 20928}
{"hash": -2607754285145856562, "project": "debian", "size": 101, "label": 0, "functionSource": "int archive_write_set_format_iso9660 ( struct archive * _a ) {\n struct archive_write * a = ( struct archive_write * ) _a ;\n struct iso9660 * iso9660 ;\n archive_check_magic ( _a , ARCHIVE_WRITE_MAGIC , ARCHIVE_STATE_NEW , \"archive_write_set_format_iso9660\" ) ;\n if ( a -> format_free != NULL ) ( a -> format_free ) ( a ) ;\n iso9660 = calloc ( 1 , sizeof ( * iso9660 ) ) ;\n if ( iso9660 == NULL ) {\n archive_set_error ( & a -> archive , ENOMEM , \"Can't allocate iso9660 data\" ) ;\n return ( ARCHIVE_FATAL ) ;\n }\n iso9660 -> birth_time = 0 ;\n iso9660 -> temp_fd = - 1 ;\n iso9660 -> cur_file = NULL ;\n iso9660 -> primary . max_depth = 0 ;\n iso9660 -> primary . vdd_type = VDD_PRIMARY ;\n iso9660 -> primary . pathtbl = NULL ;\n iso9660 -> joliet . rootent = NULL ;\n iso9660 -> joliet . max_depth = 0 ;\n iso9660 -> joliet . vdd_type = VDD_JOLIET ;\n iso9660 -> joliet . pathtbl = NULL ;\n isofile_init_entry_list ( iso9660 ) ;\n isofile_init_entry_data_file_list ( iso9660 ) ;\n isofile_init_hardlinks ( iso9660 ) ;\n iso9660 -> directories_too_deep = NULL ;\n iso9660 -> dircnt_max = 1 ;\n iso9660 -> wbuff_remaining = wb_buffmax ( ) ;\n iso9660 -> wbuff_type = WB_TO_TEMP ;\n iso9660 -> wbuff_offset = 0 ;\n iso9660 -> wbuff_written = 0 ;\n iso9660 -> wbuff_tail = 0 ;\n archive_string_init ( & ( iso9660 -> utf16be ) ) ;\n archive_string_init ( & ( iso9660 -> mbs ) ) ;\n archive_string_init ( & ( iso9660 -> volume_identifier ) ) ;\n archive_strcpy ( & ( iso9660 -> volume_identifier ) , \"CDROM\" ) ;\n archive_string_init ( & ( iso9660 -> publisher_identifier ) ) ;\n archive_string_init ( & ( iso9660 -> data_preparer_identifier ) ) ;\n archive_string_init ( & ( iso9660 -> application_identifier ) ) ;\n archive_strcpy ( & ( iso9660 -> application_identifier ) , archive_version_string ( ) ) ;\n archive_string_init ( & ( iso9660 -> copyright_file_identifier ) ) ;\n archive_string_init ( & ( iso9660 -> abstract_file_identifier ) ) ;\n archive_string_init ( & ( iso9660 -> bibliographic_file_identifier ) ) ;\n archive_string_init ( & ( iso9660 -> el_torito . catalog_filename ) ) ;\n iso9660 -> el_torito . catalog = NULL ;\n archive_strcpy ( & ( iso9660 -> el_torito . catalog_filename ) , \"boot.catalog\" ) ;\n archive_string_init ( & ( iso9660 -> el_torito . boot_filename ) ) ;\n iso9660 -> el_torito . boot = NULL ;\n iso9660 -> el_torito . platform_id = BOOT_PLATFORM_X86 ;\n archive_string_init ( & ( iso9660 -> el_torito . id ) ) ;\n iso9660 -> el_torito . boot_load_seg = 0 ;\n iso9660 -> el_torito . boot_load_size = BOOT_LOAD_SIZE ;\n # ifdef HAVE_ZLIB_H iso9660 -> zisofs . block_pointers = NULL ;\n iso9660 -> zisofs . block_pointers_allocated = 0 ;\n iso9660 -> zisofs . stream_valid = 0 ;\n iso9660 -> zisofs . compression_level = 9 ;\n memset ( & ( iso9660 -> zisofs . stream ) , 0 , sizeof ( iso9660 -> zisofs . stream ) ) ;\n # endif iso9660 -> opt . abstract_file = OPT_ABSTRACT_FILE_DEFAULT ;\n iso9660 -> opt . application_id = OPT_APPLICATION_ID_DEFAULT ;\n iso9660 -> opt . allow_vernum = OPT_ALLOW_VERNUM_DEFAULT ;\n iso9660 -> opt . biblio_file = OPT_BIBLIO_FILE_DEFAULT ;\n iso9660 -> opt . boot = OPT_BOOT_DEFAULT ;\n iso9660 -> opt . boot_catalog = OPT_BOOT_CATALOG_DEFAULT ;\n iso9660 -> opt . boot_info_table = OPT_BOOT_INFO_TABLE_DEFAULT ;\n iso9660 -> opt . boot_load_seg = OPT_BOOT_LOAD_SEG_DEFAULT ;\n iso9660 -> opt . boot_load_size = OPT_BOOT_LOAD_SIZE_DEFAULT ;\n iso9660 -> opt . boot_type = OPT_BOOT_TYPE_DEFAULT ;\n iso9660 -> opt . compression_level = OPT_COMPRESSION_LEVEL_DEFAULT ;\n iso9660 -> opt . copyright_file = OPT_COPYRIGHT_FILE_DEFAULT ;\n iso9660 -> opt . iso_level = OPT_ISO_LEVEL_DEFAULT ;\n iso9660 -> opt . joliet = OPT_JOLIET_DEFAULT ;\n iso9660 -> opt . limit_depth = OPT_LIMIT_DEPTH_DEFAULT ;\n iso9660 -> opt . limit_dirs = OPT_LIMIT_DIRS_DEFAULT ;\n iso9660 -> opt . pad = OPT_PAD_DEFAULT ;\n iso9660 -> opt . publisher = OPT_PUBLISHER_DEFAULT ;\n iso9660 -> opt . rr = OPT_RR_DEFAULT ;\n iso9660 -> opt . volume_id = OPT_VOLUME_ID_DEFAULT ;\n iso9660 -> opt . zisofs = OPT_ZISOFS_DEFAULT ;\n iso9660 -> primary . rootent = isoent_create_virtual_dir ( a , iso9660 , \"\" ) ;\n if ( iso9660 -> primary . rootent == NULL ) {\n free ( iso9660 ) ;\n archive_set_error ( & a -> archive , ENOMEM , \"Can't allocate memory\" ) ;\n return ( ARCHIVE_FATAL ) ;\n }\n iso9660 -> primary . rootent -> parent = iso9660 -> primary . rootent ;\n iso9660 -> cur_dirent = iso9660 -> primary . rootent ;\n archive_string_init ( & ( iso9660 -> cur_dirstr ) ) ;\n archive_string_ensure ( & ( iso9660 -> cur_dirstr ) , 1 ) ;\n iso9660 -> cur_dirstr . s [ 0 ] = 0 ;\n iso9660 -> sconv_to_utf16be = NULL ;\n iso9660 -> sconv_from_utf16be = NULL ;\n a -> format_data = iso9660 ;\n a -> format_name = \"iso9660\" ;\n a -> format_options = iso9660_options ;\n a -> format_write_header = iso9660_write_header ;\n a -> format_write_data = iso9660_write_data ;\n a -> format_finish_entry = iso9660_finish_entry ;\n a -> format_close = iso9660_close ;\n a -> format_free = iso9660_free ;\n a -> archive . archive_format = ARCHIVE_FORMAT_ISO9660 ;\n a -> archive . archive_format_name = \"ISO9660\" ;\n return ( ARCHIVE_OK ) ;\n }", "idx": 20929}
{"hash": 4839943401171415484, "project": "chrome", "size": 27, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_P ( BrowserCloseManagerBrowserTest , TestWithOffTheRecordWindowAndRegularDownload ) {\n Profile * otr_profile = browser ( ) -> profile ( ) -> GetOffTheRecordProfile ( ) ;\n Browser * otr_browser = CreateBrowser ( otr_profile ) ;\n ASSERT_NO_FATAL_FAILURE ( CreateStalledDownload ( browser ( ) ) ) ;\n content : : TestNavigationObserver navigation_observer ( otr_browser -> tab_strip_model ( ) -> GetActiveWebContents ( ) , 1 ) ;\n ui_test_utils : : NavigateToURL ( otr_browser , GURL ( \"about:blank\" ) ) ;\n navigation_observer . Wait ( ) ;\n int num_downloads_blocking = 0 ;\n ASSERT_EQ ( Browser : : DOWNLOAD_CLOSE_OK , otr_browser -> OkToCloseWithInProgressDownloads ( & num_downloads_blocking ) ) ;\n ASSERT_EQ ( 0 , num_downloads_blocking ) ;\n {\n RepeatedNotificationObserver close_observer ( chrome : : NOTIFICATION_BROWSER_CLOSED , 1 ) ;\n otr_browser -> window ( ) -> Close ( ) ;\n close_observer . Wait ( ) ;\n }\n ASSERT_EQ ( Browser : : DOWNLOAD_CLOSE_BROWSER_SHUTDOWN , browser ( ) -> OkToCloseWithInProgressDownloads ( & num_downloads_blocking ) ) ;\n ASSERT_EQ ( 1 , num_downloads_blocking ) ;\n {\n RepeatedNotificationObserver close_observer ( chrome : : NOTIFICATION_BROWSER_CLOSED , 2 ) ;\n TestBrowserCloseManager : : AttemptClose ( TestBrowserCloseManager : : USER_CHOICE_USER_ALLOWS_CLOSE ) ;\n close_observer . Wait ( ) ;\n }\n EXPECT_TRUE ( browser_shutdown : : IsTryingToQuit ( ) ) ;\n EXPECT_TRUE ( BrowserList : : GetInstance ( ) -> empty ( ) ) ;\n if ( browser_defaults : : kBrowserAliveWithNoWindows ) EXPECT_EQ ( 1 , DownloadCoreService : : NonMaliciousDownloadCountAllProfiles ( ) ) ;\n else EXPECT_EQ ( 0 , DownloadCoreService : : NonMaliciousDownloadCountAllProfiles ( ) ) ;\n }", "idx": 20930}
{"hash": 4722923622195275414, "project": "debian", "size": 3, "label": 0, "functionSource": "static uint8_t lag_calc_zero_run ( int8_t x ) {\n return ( x << 1 ) ^ ( x >> 7 ) ;\n }", "idx": 20931}
{"hash": -1283648210945038844, "project": "chrome", "size": 11, "label": 1, "functionSource": "void vp9_fdct8x8_1_c ( const int16_t * input , int16_t * output , int stride ) {\n int r , c ;\n int16_t sum = 0 ;\n for ( r = 0 ;\n r < 8 ;\n ++ r ) for ( c = 0 ;\n c < 8 ;\n ++ c ) sum += input [ r * stride + c ] ;\n output [ 0 ] = sum ;\n output [ 1 ] = 0 ;\n }", "idx": 20932}
{"hash": 2895622461494525400, "project": "debian", "size": 57, "label": 0, "functionSource": "static void test_field_misc ( ) {\n MYSQL_STMT * stmt ;\n MYSQL_RES * result ;\n int rc ;\n myheader ( \"test_field_misc\" ) ;\n rc = mysql_query ( mysql , \"SELECT @@autocommit\" ) ;\n myquery ( rc ) ;\n result = mysql_store_result ( mysql ) ;\n mytest ( result ) ;\n rc = my_process_result_set ( result ) ;\n DIE_UNLESS ( rc == 1 ) ;\n verify_prepare_field ( result , 0 , \"@@autocommit\" , \"\" , MYSQL_TYPE_LONGLONG , \"\" , \"\" , \"\" , 1 , 0 ) ;\n mysql_free_result ( result ) ;\n stmt = mysql_simple_prepare ( mysql , \"SELECT @@autocommit\" ) ;\n check_stmt ( stmt ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n result = mysql_stmt_result_metadata ( stmt ) ;\n mytest ( result ) ;\n rc = my_process_stmt_result ( stmt ) ;\n DIE_UNLESS ( rc == 1 ) ;\n verify_prepare_field ( result , 0 , \"@@autocommit\" , \"\" , MYSQL_TYPE_LONGLONG , \"\" , \"\" , \"\" , 1 , 0 ) ;\n mysql_free_result ( result ) ;\n mysql_stmt_close ( stmt ) ;\n stmt = mysql_simple_prepare ( mysql , \"SELECT @@max_error_count\" ) ;\n check_stmt ( stmt ) ;\n result = mysql_stmt_result_metadata ( stmt ) ;\n mytest ( result ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n rc = my_process_stmt_result ( stmt ) ;\n DIE_UNLESS ( rc == 1 ) ;\n verify_prepare_field ( result , 0 , \"@@max_error_count\" , \"\" , MYSQL_TYPE_LONGLONG , \"\" , \"\" , \"\" , MY_INT64_NUM_DECIMAL_DIGITS , 0 ) ;\n mysql_free_result ( result ) ;\n mysql_stmt_close ( stmt ) ;\n stmt = mysql_simple_prepare ( mysql , \"SELECT @@max_allowed_packet\" ) ;\n check_stmt ( stmt ) ;\n result = mysql_stmt_result_metadata ( stmt ) ;\n mytest ( result ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n DIE_UNLESS ( 1 == my_process_stmt_result ( stmt ) ) ;\n verify_prepare_field ( result , 0 , \"@@max_allowed_packet\" , \"\" , MYSQL_TYPE_LONGLONG , \"\" , \"\" , \"\" , MY_INT64_NUM_DECIMAL_DIGITS , 0 ) ;\n mysql_free_result ( result ) ;\n mysql_stmt_close ( stmt ) ;\n stmt = mysql_simple_prepare ( mysql , \"SELECT @@sql_warnings\" ) ;\n check_stmt ( stmt ) ;\n result = mysql_stmt_result_metadata ( stmt ) ;\n mytest ( result ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n rc = my_process_stmt_result ( stmt ) ;\n DIE_UNLESS ( rc == 1 ) ;\n verify_prepare_field ( result , 0 , \"@@sql_warnings\" , \"\" , MYSQL_TYPE_LONGLONG , \"\" , \"\" , \"\" , 1 , 0 ) ;\n mysql_free_result ( result ) ;\n mysql_stmt_close ( stmt ) ;\n }", "idx": 20933}
{"hash": 415966375198131126, "project": "debian", "size": 14, "label": 0, "functionSource": "void record_sys_stats ( void ) {\n l_fp now ;\n u_long day ;\n if ( ! stats_control ) return ;\n get_systime ( & now ) ;\n filegen_setup ( & sysstats , now . l_ui ) ;\n day = now . l_ui / 86400 + MJD_1900 ;\n now . l_ui %= 86400 ;\n if ( sysstats . fp != NULL ) {\n fprintf ( sysstats . fp , \"%lu %s %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu\\n\" , day , ulfptoa ( & now , 3 ) , current_time - sys_stattime , sys_received , sys_processed , sys_newversion , sys_oldversion , sys_restricted , sys_badlength , sys_badauth , sys_declined , sys_limitrejected , sys_kodsent ) ;\n fflush ( sysstats . fp ) ;\n proto_clr_stats ( ) ;\n }\n }", "idx": 20934}
{"hash": -5280794106681745199, "project": "debian", "size": 37, "label": 0, "functionSource": "static GstFlowReturn gst_asf_demux_chain_headers ( GstASFDemux * demux ) {\n AsfObject obj ;\n guint8 * header_data , * data = NULL ;\n const guint8 * cdata = NULL ;\n guint64 header_size ;\n GstFlowReturn flow = GST_FLOW_OK ;\n cdata = ( guint8 * ) gst_adapter_map ( demux -> adapter , ASF_OBJECT_HEADER_SIZE ) ;\n if ( cdata == NULL ) goto need_more_data ;\n if ( ! asf_demux_peek_object ( demux , cdata , ASF_OBJECT_HEADER_SIZE , & obj , TRUE ) ) goto parse_failed ;\n if ( obj . id != ASF_OBJ_HEADER ) goto wrong_type ;\n GST_LOG_OBJECT ( demux , \"header size = %u\" , ( guint ) obj . size ) ;\n if ( gst_adapter_available ( demux -> adapter ) < obj . size + 50 ) goto need_more_data ;\n data = gst_adapter_take ( demux -> adapter , obj . size + 50 ) ;\n header_data = data ;\n header_size = obj . size ;\n flow = gst_asf_demux_process_object ( demux , & header_data , & header_size ) ;\n if ( flow != GST_FLOW_OK ) goto parse_failed ;\n demux -> data_offset = obj . size + 50 ;\n if ( ! gst_asf_demux_parse_data_object_start ( demux , data + obj . size ) ) goto wrong_type ;\n if ( demux -> num_streams == 0 ) goto no_streams ;\n g_free ( data ) ;\n return GST_FLOW_OK ;\n need_more_data : {\n GST_LOG_OBJECT ( demux , \"not enough data in adapter yet\" ) ;\n return GST_FLOW_OK ;\n }\n wrong_type : {\n GST_ELEMENT_ERROR ( demux , STREAM , WRONG_TYPE , ( NULL ) , ( \"This doesn't seem to be an ASF file\" ) ) ;\n g_free ( data ) ;\n return GST_FLOW_ERROR ;\n }\n no_streams : parse_failed : {\n GST_ELEMENT_ERROR ( demux , STREAM , DEMUX , ( NULL ) , ( \"header parsing failed, or no streams found, flow = %s\" , gst_flow_get_name ( flow ) ) ) ;\n g_free ( data ) ;\n return GST_FLOW_ERROR ;\n }\n }", "idx": 20935}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_LogicalChannelRateRelease ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_LogicalChannelRateRelease , LogicalChannelRateRelease_sequence ) ;\n return offset ;\n }", "idx": 20936}
{"hash": 5524055408114021500, "project": "debian", "size": 53, "label": 0, "functionSource": "unsigned long ssl3_output_cert_chain ( SSL * s , X509 * x ) {\n unsigned char * p ;\n int i ;\n unsigned long l = 7 ;\n BUF_MEM * buf ;\n int no_chain ;\n if ( ( s -> mode & SSL_MODE_NO_AUTO_CHAIN ) || s -> ctx -> extra_certs ) no_chain = 1 ;\n else no_chain = 0 ;\n buf = s -> init_buf ;\n if ( ! BUF_MEM_grow_clean ( buf , 10 ) ) {\n SSLerr ( SSL_F_SSL3_OUTPUT_CERT_CHAIN , ERR_R_BUF_LIB ) ;\n return ( 0 ) ;\n }\n if ( x != NULL ) {\n if ( no_chain ) {\n if ( ssl3_add_cert_to_buf ( buf , & l , x ) ) return ( 0 ) ;\n }\n else {\n X509_STORE_CTX xs_ctx ;\n if ( ! X509_STORE_CTX_init ( & xs_ctx , s -> ctx -> cert_store , x , NULL ) ) {\n SSLerr ( SSL_F_SSL3_OUTPUT_CERT_CHAIN , ERR_R_X509_LIB ) ;\n return ( 0 ) ;\n }\n X509_verify_cert ( & xs_ctx ) ;\n ERR_clear_error ( ) ;\n for ( i = 0 ;\n i < sk_X509_num ( xs_ctx . chain ) ;\n i ++ ) {\n x = sk_X509_value ( xs_ctx . chain , i ) ;\n if ( ssl3_add_cert_to_buf ( buf , & l , x ) ) {\n X509_STORE_CTX_cleanup ( & xs_ctx ) ;\n return 0 ;\n }\n }\n X509_STORE_CTX_cleanup ( & xs_ctx ) ;\n }\n }\n for ( i = 0 ;\n i < sk_X509_num ( s -> ctx -> extra_certs ) ;\n i ++ ) {\n x = sk_X509_value ( s -> ctx -> extra_certs , i ) ;\n if ( ssl3_add_cert_to_buf ( buf , & l , x ) ) return ( 0 ) ;\n }\n l -= 7 ;\n p = ( unsigned char * ) & ( buf -> data [ 4 ] ) ;\n l2n3 ( l , p ) ;\n l += 3 ;\n p = ( unsigned char * ) & ( buf -> data [ 0 ] ) ;\n * ( p ++ ) = SSL3_MT_CERTIFICATE ;\n l2n3 ( l , p ) ;\n l += 4 ;\n return ( l ) ;\n }", "idx": 20937}
{"hash": 4180964683905830761, "project": "debian", "size": 8, "label": 0, "functionSource": "static int selinux_kernel_module_request ( char * kmod_name ) {\n u32 sid ;\n struct common_audit_data ad ;\n sid = task_sid ( current ) ;\n ad . type = LSM_AUDIT_DATA_KMOD ;\n ad . u . kmod_name = kmod_name ;\n return avc_has_perm ( sid , SECINITSID_KERNEL , SECCLASS_SYSTEM , SYSTEM__MODULE_REQUEST , & ad ) ;\n }", "idx": 20938}
{"hash": 6879275573700337956, "project": "debian", "size": 59, "label": 0, "functionSource": "static inline int decode_subframe ( FLACContext * s , int channel ) {\n int32_t * decoded = s -> decoded [ channel ] ;\n int type , wasted = 0 ;\n int bps = s -> bps ;\n int i , tmp ;\n if ( channel == 0 ) {\n if ( s -> ch_mode == FLAC_CHMODE_RIGHT_SIDE ) bps ++ ;\n }\n else {\n if ( s -> ch_mode == FLAC_CHMODE_LEFT_SIDE || s -> ch_mode == FLAC_CHMODE_MID_SIDE ) bps ++ ;\n }\n if ( get_bits1 ( & s -> gb ) ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"invalid subframe padding\\n\" ) ;\n return - 1 ;\n }\n type = get_bits ( & s -> gb , 6 ) ;\n if ( get_bits1 ( & s -> gb ) ) {\n int left = get_bits_left ( & s -> gb ) ;\n wasted = 1 ;\n if ( left < 0 || ( left < bps && ! show_bits_long ( & s -> gb , left ) ) || ! show_bits_long ( & s -> gb , bps ) ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"Invalid number of wasted bits > available bits (%d) - left=%d\\n\" , bps , left ) ;\n return AVERROR_INVALIDDATA ;\n }\n while ( ! get_bits1 ( & s -> gb ) ) wasted ++ ;\n bps -= wasted ;\n }\n if ( bps > 32 ) {\n av_log_missing_feature ( s -> avctx , \"Decorrelated bit depth > 32\" , 0 ) ;\n return AVERROR_PATCHWELCOME ;\n }\n if ( type == 0 ) {\n tmp = get_sbits_long ( & s -> gb , bps ) ;\n for ( i = 0 ;\n i < s -> blocksize ;\n i ++ ) decoded [ i ] = tmp ;\n }\n else if ( type == 1 ) {\n for ( i = 0 ;\n i < s -> blocksize ;\n i ++ ) decoded [ i ] = get_sbits_long ( & s -> gb , bps ) ;\n }\n else if ( ( type >= 8 ) && ( type <= 12 ) ) {\n if ( decode_subframe_fixed ( s , decoded , type & ~ 0x8 , bps ) < 0 ) return - 1 ;\n }\n else if ( type >= 32 ) {\n if ( decode_subframe_lpc ( s , decoded , ( type & ~ 0x20 ) + 1 , bps ) < 0 ) return - 1 ;\n }\n else {\n av_log ( s -> avctx , AV_LOG_ERROR , \"invalid coding type\\n\" ) ;\n return - 1 ;\n }\n if ( wasted ) {\n int i ;\n for ( i = 0 ;\n i < s -> blocksize ;\n i ++ ) decoded [ i ] <<= wasted ;\n }\n return 0 ;\n }", "idx": 20939}
{"hash": 6249489553242542670, "project": "debian", "size": 37, "label": 0, "functionSource": "static void config_tos ( config_tree * ptree ) {\n attr_val * tos ;\n int item ;\n item = - 1 ;\n tos = HEAD_PFIFO ( ptree -> orphan_cmds ) ;\n for ( ;\n tos != NULL ;\n tos = tos -> link ) {\n switch ( tos -> attr ) {\n default : NTP_INSIST ( 0 ) ;\n break ;\n case T_Ceiling : item = PROTO_CEILING ;\n break ;\n case T_Floor : item = PROTO_FLOOR ;\n break ;\n case T_Cohort : item = PROTO_COHORT ;\n break ;\n case T_Orphan : item = PROTO_ORPHAN ;\n break ;\n case T_Orphanwait : item = PROTO_ORPHWAIT ;\n break ;\n case T_Mindist : item = PROTO_MINDISP ;\n break ;\n case T_Maxdist : item = PROTO_MAXDIST ;\n break ;\n case T_Minclock : item = PROTO_MINCLOCK ;\n break ;\n case T_Maxclock : item = PROTO_MAXCLOCK ;\n break ;\n case T_Minsane : item = PROTO_MINSANE ;\n break ;\n case T_Beacon : item = PROTO_BEACON ;\n break ;\n }\n proto_config ( item , 0 , tos -> value . d , NULL ) ;\n }\n }", "idx": 20940}
{"hash": 5704453449583823009, "project": "chrome", "size": 4, "label": 0, "functionSource": "void evbuffer_free ( struct evbuffer * buffer ) {\n if ( buffer -> orig_buffer != NULL ) free ( buffer -> orig_buffer ) ;\n free ( buffer ) ;\n }", "idx": 20941}
{"hash": -3616725510139109047, "project": "chrome", "size": 58, "label": 0, "functionSource": "static void separate_arf_mbs ( VP9_COMP * cpi ) {\n VP9_COMMON * const cm = & cpi -> common ;\n int mb_col , mb_row , offset , i ;\n int mi_row , mi_col ;\n int ncnt [ 4 ] = {\n 0 }\n ;\n int n_frames = cpi -> mbgraph_n_frames ;\n int * arf_not_zz ;\n CHECK_MEM_ERROR ( cm , arf_not_zz , vpx_calloc ( cm -> mb_rows * cm -> mb_cols * sizeof ( * arf_not_zz ) , 1 ) ) ;\n if ( n_frames > cpi -> rc . frames_till_gf_update_due ) n_frames = cpi -> rc . frames_till_gf_update_due ;\n for ( i = n_frames - 1 ;\n i >= 0 ;\n i -- ) {\n MBGRAPH_FRAME_STATS * frame_stats = & cpi -> mbgraph_stats [ i ] ;\n for ( offset = 0 , mb_row = 0 ;\n mb_row < cm -> mb_rows ;\n offset += cm -> mb_cols , mb_row ++ ) {\n for ( mb_col = 0 ;\n mb_col < cm -> mb_cols ;\n mb_col ++ ) {\n MBGRAPH_MB_STATS * mb_stats = & frame_stats -> mb_stats [ offset + mb_col ] ;\n int altref_err = mb_stats -> ref [ ALTREF_FRAME ] . err ;\n int intra_err = mb_stats -> ref [ INTRA_FRAME ] . err ;\n int golden_err = mb_stats -> ref [ GOLDEN_FRAME ] . err ;\n if ( altref_err > 1000 || altref_err > intra_err || altref_err > golden_err ) {\n arf_not_zz [ offset + mb_col ] ++ ;\n }\n }\n }\n }\n for ( mi_row = 0 ;\n mi_row < cm -> mi_rows ;\n mi_row ++ ) {\n for ( mi_col = 0 ;\n mi_col < cm -> mi_cols ;\n mi_col ++ ) {\n if ( arf_not_zz [ mi_row / 2 * cm -> mb_cols + mi_col / 2 ] ) {\n ncnt [ 0 ] ++ ;\n cpi -> segmentation_map [ mi_row * cm -> mi_cols + mi_col ] = 0 ;\n }\n else {\n cpi -> segmentation_map [ mi_row * cm -> mi_cols + mi_col ] = 1 ;\n ncnt [ 1 ] ++ ;\n }\n }\n }\n if ( 1 ) {\n if ( cm -> MBs ) cpi -> static_mb_pct = ( ncnt [ 1 ] * 100 ) / ( cm -> mi_rows * cm -> mi_cols ) ;\n else cpi -> static_mb_pct = 0 ;\n vp9_enable_segmentation ( & cm -> seg ) ;\n }\n else {\n cpi -> static_mb_pct = 0 ;\n vp9_disable_segmentation ( & cm -> seg ) ;\n }\n vpx_free ( arf_not_zz ) ;\n }", "idx": 20942}
{"hash": 4489017523191997023, "project": "debian", "size": 10, "label": 0, "functionSource": "static int dissect_h225_DisengageReason ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 648 \"./asn1/h225/h225.cnf\" gint32 value ;\n h225_packet_info * h225_pi ;\n h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_DisengageReason , DisengageReason_choice , & value ) ;\n if ( h225_pi != NULL ) {\n h225_pi -> reason = value ;\n }\n return offset ;\n }", "idx": 20943}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_T38faxApp ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_T38faxApp , T38faxApp_sequence ) ;\n return offset ;\n }", "idx": 20944}
{"hash": -3559021711340554904, "project": "debian", "size": 103, "label": 0, "functionSource": "static Expr * inline_function ( Oid funcid , Oid result_type , Oid result_collid , Oid input_collid , List * args , bool funcvariadic , HeapTuple func_tuple , eval_const_expressions_context * context ) {\n Form_pg_proc funcform = ( Form_pg_proc ) GETSTRUCT ( func_tuple ) ;\n char * src ;\n Datum tmp ;\n bool isNull ;\n bool modifyTargetList ;\n MemoryContext oldcxt ;\n MemoryContext mycxt ;\n inline_error_callback_arg callback_arg ;\n ErrorContextCallback sqlerrcontext ;\n FuncExpr * fexpr ;\n SQLFunctionParseInfoPtr pinfo ;\n ParseState * pstate ;\n List * raw_parsetree_list ;\n Query * querytree ;\n Node * newexpr ;\n int * usecounts ;\n ListCell * arg ;\n int i ;\n if ( funcform -> prolang != SQLlanguageId || funcform -> prosecdef || funcform -> proretset || funcform -> prorettype == RECORDOID || ! heap_attisnull ( func_tuple , Anum_pg_proc_proconfig ) || funcform -> pronargs != list_length ( args ) ) return NULL ;\n if ( list_member_oid ( context -> active_fns , funcid ) ) return NULL ;\n if ( pg_proc_aclcheck ( funcid , GetUserId ( ) , ACL_EXECUTE ) != ACLCHECK_OK ) return NULL ;\n if ( FmgrHookIsNeeded ( funcid ) ) return NULL ;\n mycxt = AllocSetContextCreate ( CurrentMemoryContext , \"inline_function\" , ALLOCSET_DEFAULT_MINSIZE , ALLOCSET_DEFAULT_INITSIZE , ALLOCSET_DEFAULT_MAXSIZE ) ;\n oldcxt = MemoryContextSwitchTo ( mycxt ) ;\n tmp = SysCacheGetAttr ( PROCOID , func_tuple , Anum_pg_proc_prosrc , & isNull ) ;\n if ( isNull ) elog ( ERROR , \"null prosrc for function %u\" , funcid ) ;\n src = TextDatumGetCString ( tmp ) ;\n callback_arg . proname = NameStr ( funcform -> proname ) ;\n callback_arg . prosrc = src ;\n sqlerrcontext . callback = sql_inline_error_callback ;\n sqlerrcontext . arg = ( void * ) & callback_arg ;\n sqlerrcontext . previous = error_context_stack ;\n error_context_stack = & sqlerrcontext ;\n fexpr = makeNode ( FuncExpr ) ;\n fexpr -> funcid = funcid ;\n fexpr -> funcresulttype = result_type ;\n fexpr -> funcretset = false ;\n fexpr -> funcvariadic = funcvariadic ;\n fexpr -> funcformat = COERCE_EXPLICIT_CALL ;\n fexpr -> funccollid = result_collid ;\n fexpr -> inputcollid = input_collid ;\n fexpr -> args = args ;\n fexpr -> location = - 1 ;\n pinfo = prepare_sql_fn_parse_info ( func_tuple , ( Node * ) fexpr , input_collid ) ;\n raw_parsetree_list = pg_parse_query ( src ) ;\n if ( list_length ( raw_parsetree_list ) != 1 ) goto fail ;\n pstate = make_parsestate ( NULL ) ;\n pstate -> p_sourcetext = src ;\n sql_fn_parser_setup ( pstate , pinfo ) ;\n querytree = transformTopLevelStmt ( pstate , linitial ( raw_parsetree_list ) ) ;\n free_parsestate ( pstate ) ;\n if ( ! IsA ( querytree , Query ) || querytree -> commandType != CMD_SELECT || querytree -> utilityStmt || querytree -> hasAggs || querytree -> hasWindowFuncs || querytree -> hasSubLinks || querytree -> cteList || querytree -> rtable || querytree -> jointree -> fromlist || querytree -> jointree -> quals || querytree -> groupClause || querytree -> groupingSets || querytree -> havingQual || querytree -> windowClause || querytree -> distinctClause || querytree -> sortClause || querytree -> limitOffset || querytree -> limitCount || querytree -> setOperations || list_length ( querytree -> targetList ) != 1 ) goto fail ;\n if ( check_sql_fn_retval ( funcid , result_type , list_make1 ( querytree ) , & modifyTargetList , NULL ) ) goto fail ;\n newexpr = ( Node * ) ( ( TargetEntry * ) linitial ( querytree -> targetList ) ) -> expr ;\n Assert ( exprType ( newexpr ) == result_type ) ;\n Assert ( ! modifyTargetList ) ;\n if ( expression_returns_set ( newexpr ) ) goto fail ;\n if ( funcform -> provolatile == PROVOLATILE_IMMUTABLE && contain_mutable_functions ( newexpr ) ) goto fail ;\n else if ( funcform -> provolatile == PROVOLATILE_STABLE && contain_volatile_functions ( newexpr ) ) goto fail ;\n if ( funcform -> proisstrict && contain_nonstrict_functions ( newexpr ) ) goto fail ;\n if ( contain_context_dependent_node ( ( Node * ) args ) ) goto fail ;\n usecounts = ( int * ) palloc0 ( funcform -> pronargs * sizeof ( int ) ) ;\n newexpr = substitute_actual_parameters ( newexpr , funcform -> pronargs , args , usecounts ) ;\n i = 0 ;\n foreach ( arg , args ) {\n Node * param = lfirst ( arg ) ;\n if ( usecounts [ i ] == 0 ) {\n if ( funcform -> proisstrict ) goto fail ;\n }\n else if ( usecounts [ i ] != 1 ) {\n QualCost eval_cost ;\n if ( contain_subplans ( param ) ) goto fail ;\n cost_qual_eval ( & eval_cost , list_make1 ( param ) , NULL ) ;\n if ( eval_cost . startup + eval_cost . per_tuple > 10 * cpu_operator_cost ) goto fail ;\n if ( contain_volatile_functions ( param ) ) goto fail ;\n }\n i ++ ;\n }\n MemoryContextSwitchTo ( oldcxt ) ;\n newexpr = copyObject ( newexpr ) ;\n MemoryContextDelete ( mycxt ) ;\n if ( OidIsValid ( result_collid ) ) {\n Oid exprcoll = exprCollation ( newexpr ) ;\n if ( OidIsValid ( exprcoll ) && exprcoll != result_collid ) {\n CollateExpr * newnode = makeNode ( CollateExpr ) ;\n newnode -> arg = ( Expr * ) newexpr ;\n newnode -> collOid = result_collid ;\n newnode -> location = - 1 ;\n newexpr = ( Node * ) newnode ;\n }\n }\n if ( context -> root ) record_plan_function_dependency ( context -> root , funcid ) ;\n context -> active_fns = lcons_oid ( funcid , context -> active_fns ) ;\n newexpr = eval_const_expressions_mutator ( newexpr , context ) ;\n context -> active_fns = list_delete_first ( context -> active_fns ) ;\n error_context_stack = sqlerrcontext . previous ;\n return ( Expr * ) newexpr ;\n fail : MemoryContextSwitchTo ( oldcxt ) ;\n MemoryContextDelete ( mycxt ) ;\n error_context_stack = sqlerrcontext . previous ;\n return NULL ;\n }", "idx": 20945}
{"hash": -2971164434690241379, "project": "debian", "size": 51, "label": 1, "functionSource": "static int stp_print_mstp_bpdu ( netdissect_options * ndo , const struct stp_bpdu_ * stp_bpdu , u_int length ) {\n const u_char * ptr ;\n uint16_t v3len ;\n uint16_t len ;\n uint16_t msti ;\n u_int offset ;\n ptr = ( const u_char * ) stp_bpdu ;\n ND_PRINT ( ( ndo , \", CIST Flags [%s], length %u\" , bittok2str ( stp_bpdu_flag_values , \"none\" , stp_bpdu -> flags ) , length ) ) ;\n if ( ! ndo -> ndo_vflag ) {\n return 1 ;\n }\n ND_PRINT ( ( ndo , \"\\n\\tport-role %s, \" , tok2str ( rstp_obj_port_role_values , \"Unknown\" , RSTP_EXTRACT_PORT_ROLE ( stp_bpdu -> flags ) ) ) ) ;\n ND_TCHECK ( stp_bpdu -> root_path_cost ) ;\n ND_PRINT ( ( ndo , \"CIST root-id %s, CIST ext-pathcost %u\" , stp_print_bridge_id ( ( const u_char * ) & stp_bpdu -> root_id ) , EXTRACT_32BITS ( & stp_bpdu -> root_path_cost ) ) ) ;\n ND_TCHECK ( stp_bpdu -> bridge_id ) ;\n ND_PRINT ( ( ndo , \"\\n\\tCIST regional-root-id %s, \" , stp_print_bridge_id ( ( const u_char * ) & stp_bpdu -> bridge_id ) ) ) ;\n ND_TCHECK ( stp_bpdu -> port_id ) ;\n ND_PRINT ( ( ndo , \"CIST port-id %04x,\" , EXTRACT_16BITS ( & stp_bpdu -> port_id ) ) ) ;\n ND_TCHECK ( stp_bpdu -> forward_delay ) ;\n ND_PRINT ( ( ndo , \"\\n\\tmessage-age %.2fs, max-age %.2fs\" \", hello-time %.2fs, forwarding-delay %.2fs\" , ( float ) EXTRACT_16BITS ( & stp_bpdu -> message_age ) / STP_TIME_BASE , ( float ) EXTRACT_16BITS ( & stp_bpdu -> max_age ) / STP_TIME_BASE , ( float ) EXTRACT_16BITS ( & stp_bpdu -> hello_time ) / STP_TIME_BASE , ( float ) EXTRACT_16BITS ( & stp_bpdu -> forward_delay ) / STP_TIME_BASE ) ) ;\n ND_TCHECK_16BITS ( ptr + MST_BPDU_VER3_LEN_OFFSET ) ;\n ND_PRINT ( ( ndo , \"\\n\\tv3len %d, \" , EXTRACT_16BITS ( ptr + MST_BPDU_VER3_LEN_OFFSET ) ) ) ;\n ND_TCHECK_32BITS ( ptr + MST_BPDU_CONFIG_DIGEST_OFFSET + 12 ) ;\n ND_PRINT ( ( ndo , \"MCID Name \" ) ) ;\n if ( fn_printzp ( ndo , ptr + MST_BPDU_CONFIG_NAME_OFFSET , 32 , ndo -> ndo_snapend ) ) goto trunc ;\n ND_PRINT ( ( ndo , \", rev %u,\" \"\\n\\t\\tdigest %08x%08x%08x%08x, \" , EXTRACT_16BITS ( ptr + MST_BPDU_CONFIG_NAME_OFFSET + 32 ) , EXTRACT_32BITS ( ptr + MST_BPDU_CONFIG_DIGEST_OFFSET ) , EXTRACT_32BITS ( ptr + MST_BPDU_CONFIG_DIGEST_OFFSET + 4 ) , EXTRACT_32BITS ( ptr + MST_BPDU_CONFIG_DIGEST_OFFSET + 8 ) , EXTRACT_32BITS ( ptr + MST_BPDU_CONFIG_DIGEST_OFFSET + 12 ) ) ) ;\n ND_TCHECK_32BITS ( ptr + MST_BPDU_CIST_INT_PATH_COST_OFFSET ) ;\n ND_PRINT ( ( ndo , \"CIST int-root-pathcost %u,\" , EXTRACT_32BITS ( ptr + MST_BPDU_CIST_INT_PATH_COST_OFFSET ) ) ) ;\n ND_TCHECK_BRIDGE_ID ( ptr + MST_BPDU_CIST_BRIDGE_ID_OFFSET ) ;\n ND_PRINT ( ( ndo , \"\\n\\tCIST bridge-id %s, \" , stp_print_bridge_id ( ptr + MST_BPDU_CIST_BRIDGE_ID_OFFSET ) ) ) ;\n ND_TCHECK ( ptr [ MST_BPDU_CIST_REMAIN_HOPS_OFFSET ] ) ;\n ND_PRINT ( ( ndo , \"CIST remaining-hops %d\" , ptr [ MST_BPDU_CIST_REMAIN_HOPS_OFFSET ] ) ) ;\n ND_TCHECK_16BITS ( ptr + MST_BPDU_VER3_LEN_OFFSET ) ;\n v3len = EXTRACT_16BITS ( ptr + MST_BPDU_VER3_LEN_OFFSET ) ;\n if ( v3len > MST_BPDU_CONFIG_INFO_LENGTH ) {\n len = v3len - MST_BPDU_CONFIG_INFO_LENGTH ;\n offset = MST_BPDU_MSTI_OFFSET ;\n while ( len >= MST_BPDU_MSTI_LENGTH ) {\n ND_TCHECK2 ( * ( ptr + offset ) , MST_BPDU_MSTI_LENGTH ) ;\n msti = EXTRACT_16BITS ( ptr + offset + MST_BPDU_MSTI_ROOT_PRIO_OFFSET ) ;\n msti = msti & 0x0FFF ;\n ND_PRINT ( ( ndo , \"\\n\\tMSTI %d, Flags [%s], port-role %s\" , msti , bittok2str ( stp_bpdu_flag_values , \"none\" , ptr [ offset ] ) , tok2str ( rstp_obj_port_role_values , \"Unknown\" , RSTP_EXTRACT_PORT_ROLE ( ptr [ offset ] ) ) ) ) ;\n ND_PRINT ( ( ndo , \"\\n\\t\\tMSTI regional-root-id %s, pathcost %u\" , stp_print_bridge_id ( ptr + offset + MST_BPDU_MSTI_ROOT_PRIO_OFFSET ) , EXTRACT_32BITS ( ptr + offset + MST_BPDU_MSTI_ROOT_PATH_COST_OFFSET ) ) ) ;\n ND_PRINT ( ( ndo , \"\\n\\t\\tMSTI bridge-prio %d, port-prio %d, hops %d\" , ptr [ offset + MST_BPDU_MSTI_BRIDGE_PRIO_OFFSET ] >> 4 , ptr [ offset + MST_BPDU_MSTI_PORT_PRIO_OFFSET ] >> 4 , ptr [ offset + MST_BPDU_MSTI_REMAIN_HOPS_OFFSET ] ) ) ;\n len -= MST_BPDU_MSTI_LENGTH ;\n offset += MST_BPDU_MSTI_LENGTH ;\n }\n }\n return 1 ;\n trunc : return 0 ;\n }", "idx": 20946}
{"hash": -8638406710431929037, "project": "debian", "size": 8, "label": 0, "functionSource": "static int srec_get_byte ( bfd * abfd , bfd_boolean * errorptr ) {\n bfd_byte c ;\n if ( bfd_bread ( & c , ( bfd_size_type ) 1 , abfd ) != 1 ) {\n if ( bfd_get_error ( ) != bfd_error_file_truncated ) * errorptr = TRUE ;\n return EOF ;\n }\n return ( int ) ( c & 0xff ) ;\n }", "idx": 20947}
{"hash": 1312888211311686952, "project": "debian", "size": 15, "label": 0, "functionSource": "static int dissect_segment_unknown ( tvbuff_t * tvb , int offset , packet_info * pinfo _U_ , proto_tree * tree , int encoding ) {\n proto_item * subtree_item = NULL ;\n proto_tree * subtree = NULL ;\n int datalen = 0 ;\n int seglen = 0 ;\n seglen = lbmpdm_get_segment_length ( tvb , offset , encoding , & datalen ) ;\n subtree_item = proto_tree_add_none_format ( tree , hf_lbmpdm_segment , tvb , offset , seglen , \"Unknown Segment\" ) ;\n subtree = proto_item_add_subtree ( subtree_item , ett_lbmpdm_segment ) ;\n proto_tree_add_item ( subtree , hf_lbmpdm_segment_next_hdr , tvb , offset + O_LBMPDM_SEG_HDR_T_NEXT_HDR , L_LBMPDM_SEG_HDR_T_NEXT_HDR , encoding ) ;\n proto_tree_add_item ( subtree , hf_lbmpdm_segment_flags , tvb , offset + O_LBMPDM_SEG_HDR_T_FLAGS , L_LBMPDM_SEG_HDR_T_FLAGS , encoding ) ;\n proto_tree_add_item ( subtree , hf_lbmpdm_segment_res , tvb , offset + O_LBMPDM_SEG_HDR_T_RES , L_LBMPDM_SEG_HDR_T_RES , encoding ) ;\n proto_tree_add_item ( subtree , hf_lbmpdm_segment_len , tvb , offset + O_LBMPDM_SEG_HDR_T_LEN , L_LBMPDM_SEG_HDR_T_LEN , encoding ) ;\n proto_tree_add_item ( subtree , hf_lbmpdm_segment_data , tvb , offset + L_LBMPDM_SEG_HDR_T , datalen , ENC_NA ) ;\n return ( seglen ) ;\n }", "idx": 20948}
{"hash": -2908211205972632000, "project": "debian", "size": 36, "label": 0, "functionSource": "int mainwindows_reserve_lines ( int top , int bottom ) {\n MAIN_WINDOW_REC * window ;\n int ret ;\n ret = - 1 ;\n if ( top != 0 ) {\n GSList * list , * tmp ;\n g_return_val_if_fail ( top > 0 || screen_reserved_top > top , - 1 ) ;\n ret = screen_reserved_top ;\n screen_reserved_top += top ;\n list = mainwindows_get_line ( mainwindows_find_lower ( NULL ) ) ;\n for ( tmp = list ;\n tmp != NULL ;\n tmp = tmp -> next ) {\n window = tmp -> data ;\n window -> first_line += top ;\n mainwindow_resize ( window , 0 , - top ) ;\n }\n g_slist_free ( list ) ;\n }\n if ( bottom != 0 ) {\n GSList * list , * tmp ;\n g_return_val_if_fail ( bottom > 0 || screen_reserved_bottom > bottom , - 1 ) ;\n ret = screen_reserved_bottom ;\n screen_reserved_bottom += bottom ;\n list = mainwindows_get_line ( mainwindows_find_upper ( NULL ) ) ;\n for ( tmp = list ;\n tmp != NULL ;\n tmp = tmp -> next ) {\n window = tmp -> data ;\n window -> last_line -= bottom ;\n mainwindow_resize ( window , 0 , - bottom ) ;\n }\n g_slist_free ( list ) ;\n }\n return ret ;\n }", "idx": 20949}
{"hash": -7777644912037188223, "project": "debian", "size": 490, "label": 0, "functionSource": "void proto_register_sigcomp ( void ) {\n static hf_register_info hf [ ] = {\n {\n & hf_sigcomp_t_bit , {\n \"T bit\" , \"sigcomp.t.bit\" , FT_UINT8 , BASE_DEC , NULL , 0x04 , \"Sigcomp T bit\" , HFILL }\n }\n , {\n & hf_sigcomp_len , {\n \"Partial state id length\" , \"sigcomp.length\" , FT_UINT8 , BASE_HEX , VALS ( length_encoding_vals ) , 0x03 , \"Sigcomp length\" , HFILL }\n }\n , {\n & hf_sigcomp_returned_feedback_item , {\n \"Returned_feedback item\" , \"sigcomp.returned.feedback.item\" , FT_BYTES , BASE_NONE , NULL , 0x0 , \"Returned feedback item\" , HFILL }\n }\n , {\n & hf_sigcomp_partial_state , {\n \"Partial state identifier\" , \"sigcomp.partial.state.identifier\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_sigcomp_remaining_message_bytes , {\n \"Remaining SigComp message bytes\" , \"sigcomp.remaining-bytes\" , FT_UINT32 , BASE_DEC , NULL , 0x0 , \"Number of bytes remaining in message\" , HFILL }\n }\n , {\n & hf_sigcomp_compression_ratio , {\n \"Compression ratio (%)\" , \"sigcomp.compression-ratio\" , FT_UINT32 , BASE_DEC , NULL , 0x0 , \"Compression ratio (decompressed / compressed) %\" , HFILL }\n }\n , {\n & hf_sigcomp_returned_feedback_item_len , {\n \"Returned feedback item length\" , \"sigcomp.returned.feedback.item.len\" , FT_UINT8 , BASE_DEC , NULL , 0x7f , NULL , HFILL }\n }\n , {\n & hf_sigcomp_code_len , {\n \"Code length\" , \"sigcomp.code.len\" , FT_UINT16 , BASE_HEX , NULL , 0xfff0 , NULL , HFILL }\n }\n , {\n & hf_sigcomp_destination , {\n \"Destination\" , \"sigcomp.destination\" , FT_UINT8 , BASE_HEX | BASE_EXT_STRING , & destination_address_encoding_vals_ext , 0xf , NULL , HFILL }\n }\n , {\n & hf_sigcomp_udvm_bytecode , {\n \"Uploaded UDVM bytecode\" , \"sigcomp.udvm.byte-code\" , FT_NONE , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_sigcomp_udvm_instr , {\n \"UDVM instruction code\" , \"sigcomp.udvm.instr\" , FT_UINT8 , BASE_DEC | BASE_EXT_STRING , & udvm_instruction_code_vals_ext , 0x0 , NULL , HFILL }\n }\n , {\n & hf_udvm_execution_trace , {\n \"UDVM execution trace\" , \"sigcomp.udvm.execution-trace\" , FT_NONE , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_udvm_multitype_bytecode , {\n \"UDVM bytecode\" , \"sigcomp.udvm.multyt.bytecode\" , FT_UINT8 , BASE_HEX , VALS ( display_bytecode_vals ) , 0x0 , NULL , HFILL }\n }\n , {\n & hf_udvm_reference_bytecode , {\n \"UDVM bytecode\" , \"sigcomp.udvm.ref.bytecode\" , FT_UINT8 , BASE_HEX , VALS ( display_ref_bytecode_vals ) , 0x0 , NULL , HFILL }\n }\n , {\n & hf_udvm_literal_bytecode , {\n \"UDVM bytecode\" , \"sigcomp.udvm.lit.bytecode\" , FT_UINT8 , BASE_HEX , VALS ( display_lit_bytecode_vals ) , 0x0 , NULL , HFILL }\n }\n , # if 0 {\n & hf_udvm_operand , {\n \"UDVM operand\" , \"sigcomp.udvm.operand\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , # endif {\n & hf_udvm_length , {\n \"%Length\" , \"sigcomp.udvm.length\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , \"Length\" , HFILL }\n }\n , {\n & hf_udvm_addr_length , {\n \"%Length[memory address]\" , \"sigcomp.udvm.addr.length\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , \"Length\" , HFILL }\n }\n , {\n & hf_udvm_destination , {\n \"%Destination\" , \"sigcomp.udvm.destination\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , \"Destination\" , HFILL }\n }\n , {\n & hf_udvm_addr_destination , {\n \"%Destination[memory address]\" , \"sigcomp.udvm.addr.destination\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , \"Destination\" , HFILL }\n }\n , {\n & hf_udvm_at_address , {\n \"@Address(mem_add_of_inst + D) mod 2^16)\" , \"sigcomp.udvm.at.address\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , \"Address\" , HFILL }\n }\n , {\n & hf_udvm_address , {\n \"%Address\" , \"sigcomp.udvm.length\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , \"Address\" , HFILL }\n }\n , {\n & hf_udvm_literal_num , {\n \"#n\" , \"sigcomp.udvm.literal-num\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , \"Literal number\" , HFILL }\n }\n , {\n & hf_udvm_value , {\n \"%Value\" , \"sigcomp.udvm.value\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , \"Value\" , HFILL }\n }\n , {\n & hf_udvm_addr_value , {\n \"%Value[memory address]\" , \"sigcomp.udvm.value\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , \"Value\" , HFILL }\n }\n , {\n & hf_partial_identifier_start , {\n \"%Partial identifier start\" , \"sigcomp.udvm.partial.identifier.start\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , \"Partial identifier start\" , HFILL }\n }\n , {\n & hf_partial_identifier_length , {\n \"%Partial identifier length\" , \"sigcomp.udvm.partial.identifier.length\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , \"Partial identifier length\" , HFILL }\n }\n , {\n & hf_state_begin , {\n \"%State begin\" , \"sigcomp.udvm.state.begin\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , \"State begin\" , HFILL }\n }\n , {\n & hf_udvm_state_length , {\n \"%State length\" , \"sigcomp.udvm.state.length\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , \"State length\" , HFILL }\n }\n , {\n & hf_udvm_state_length_addr , {\n \"%State length[memory address]\" , \"sigcomp.udvm.state.length.addr\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , \"State length\" , HFILL }\n }\n , {\n & hf_udvm_state_address , {\n \"%State address\" , \"sigcomp.udvm.start.address\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , \"State address\" , HFILL }\n }\n , {\n & hf_udvm_state_address_addr , {\n \"%State address[memory address]\" , \"sigcomp.udvm.start.address.addr\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , \"State address\" , HFILL }\n }\n , {\n & hf_udvm_state_instr , {\n \"%State instruction\" , \"sigcomp.udvm.start.instr\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , \"State instruction\" , HFILL }\n }\n , {\n & hf_udvm_operand_1 , {\n \"$Operand 1[memory address]\" , \"sigcomp.udvm.operand.1\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , \"Reference $ Operand 1\" , HFILL }\n }\n , {\n & hf_udvm_operand_2 , {\n \"%Operand 2\" , \"sigcomp.udvm.operand.2\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , \"Operand 2\" , HFILL }\n }\n , {\n & hf_udvm_operand_2_addr , {\n \"%Operand 2[memory address]\" , \"sigcomp.udvm.operand.2.addr\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , \"Operand 2\" , HFILL }\n }\n , {\n & hf_udvm_j , {\n \"%j\" , \"sigcomp.udvm.j\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , \"j\" , HFILL }\n }\n , {\n & hf_udvm_addr_j , {\n \"%j[memory address]\" , \"sigcomp.udvm.addr.j\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , \"j\" , HFILL }\n }\n , {\n & hf_udvm_output_start , {\n \"%Output_start\" , \"sigcomp.output.start\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , \"Output start\" , HFILL }\n }\n , {\n & hf_udvm_addr_output_start , {\n \"%Output_start[memory address]\" , \"sigcomp.addr.output.start\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , \"Output start\" , HFILL }\n }\n , {\n & hf_udvm_output_length , {\n \"%Output_length\" , \"sigcomp.output.length\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , \"Output length\" , HFILL }\n }\n , {\n & hf_udvm_output_length_addr , {\n \"%Output_length[memory address]\" , \"sigcomp.output.length.addr\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , \"Output length\" , HFILL }\n }\n , {\n & hf_udvm_req_feedback_loc , {\n \"%Requested feedback location\" , \"sigcomp.req.feedback.loc\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , \"Requested feedback location\" , HFILL }\n }\n , {\n & hf_udvm_min_acc_len , {\n \"%Minimum access length\" , \"sigcomp.min.acc.len\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , \"Minimum access length\" , HFILL }\n }\n , {\n & hf_udvm_state_ret_pri , {\n \"%State retention priority\" , \"sigcomp.udvm.state.ret.pri\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , \"State retention priority\" , HFILL }\n }\n , {\n & hf_udvm_ret_param_loc , {\n \"%Returned parameters location\" , \"sigcomp.ret.param.loc\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , \"Returned parameters location\" , HFILL }\n }\n , {\n & hf_udvm_position , {\n \"%Position\" , \"sigcomp.udvm.position\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , \"Position\" , HFILL }\n }\n , {\n & hf_udvm_ref_dest , {\n \"$Destination[memory address]\" , \"sigcomp.udvm.ref.destination\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , \"(reference)Destination\" , HFILL }\n }\n , {\n & hf_udvm_bits , {\n \"%Bits\" , \"sigcomp.udvm.bits\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , \"Bits\" , HFILL }\n }\n , {\n & hf_udvm_lower_bound , {\n \"%Lower bound\" , \"sigcomp.udvm.lower.bound\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , \"Lower_bound\" , HFILL }\n }\n , {\n & hf_udvm_upper_bound , {\n \"%Upper bound\" , \"sigcomp.udvm.upper.bound\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , \"Upper bound\" , HFILL }\n }\n , {\n & hf_udvm_uncompressed , {\n \"%Uncompressed\" , \"sigcomp.udvm.uncompressed\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , \"Uncompressed\" , HFILL }\n }\n , {\n & hf_udvm_start_value , {\n \"%Start value\" , \"sigcomp.udvm.start.value\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , \"Start value\" , HFILL }\n }\n , {\n & hf_udvm_offset , {\n \"%Offset\" , \"sigcomp.udvm.offset\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , \"Offset\" , HFILL }\n }\n , {\n & hf_udvm_addr_offset , {\n \"%Offset[memory address]\" , \"sigcomp.udvm.addr.offset\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , \"Offset\" , HFILL }\n }\n , {\n & hf_sigcomp_nack_ver , {\n \"NACK Version\" , \"sigcomp.nack.ver\" , FT_UINT8 , BASE_DEC , NULL , 0x0f , NULL , HFILL }\n }\n , {\n & hf_sigcomp_nack_reason_code , {\n \"Reason Code\" , \"sigcomp.nack.reason\" , FT_UINT8 , BASE_DEC | BASE_EXT_STRING , & sigcomp_nack_reason_code_vals_ext , 0x0 , \"NACK Reason Code\" , HFILL }\n }\n , {\n & hf_sigcomp_nack_failed_op_code , {\n \"OPCODE of failed instruction\" , \"sigcomp.nack.failed_op_code\" , FT_UINT8 , BASE_DEC | BASE_EXT_STRING , & udvm_instruction_code_vals_ext , 0x0 , \"NACK OPCODE of failed instruction\" , HFILL }\n }\n , {\n & hf_sigcomp_nack_pc , {\n \"PC of failed instruction\" , \"sigcomp.nack.pc\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , \"NACK PC of failed instruction\" , HFILL }\n }\n , {\n & hf_sigcomp_nack_sha1 , {\n \"SHA-1 Hash of failed message\" , \"sigcomp.nack.sha1\" , FT_BYTES , BASE_NONE , NULL , 0x0 , \"NACK SHA-1 Hash of failed message\" , HFILL }\n }\n , {\n & hf_sigcomp_nack_state_id , {\n \"State ID (6 - 20 bytes)\" , \"sigcomp.nack.state_id\" , FT_BYTES , BASE_NONE , NULL , 0x0 , \"NACK State ID (6 - 20 bytes)\" , HFILL }\n }\n , {\n & hf_sigcomp_nack_cycles_per_bit , {\n \"Cycles Per Bit\" , \"sigcomp.nack.cycles_per_bit\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , \"NACK Cycles Per Bit\" , HFILL }\n }\n , {\n & hf_sigcomp_nack_memory_size , {\n \"Memory size\" , \"sigcomp.memory_size\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_sigcomp_decompress_instruction , {\n \"Instruction\" , \"sigcomp.decompress_instruction\" , FT_NONE , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_sigcomp_loading_result , {\n \"Loading result\" , \"sigcomp.loading_result\" , FT_NONE , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_sigcomp_byte_copy , {\n \"byte copy\" , \"sigcomp.byte_copy\" , FT_BYTES , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_sigcomp_accessing_state , {\n \"### Accessing state ###\" , \"sigcomp.accessing_state\" , FT_BYTES , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_sigcomp_getting_value , {\n \"Getting value\" , \"sigcomp.getting_value\" , FT_UINT8 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_sigcomp_load_bytecode_into_udvm_start , {\n \"Load bytecode into UDVM starting at\" , \"sigcomp.load_bytecode_into_udvm_start\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_sigcomp_instruction_code , {\n \"Instruction code\" , \"sigcomp.instruction_code\" , FT_UINT8 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_sigcomp_current_instruction , {\n \"Addr\" , \"sigcomp.current_instruction\" , FT_UINT8 , BASE_DEC | BASE_EXT_STRING , & udvm_instruction_code_vals_ext , 0x0 , NULL , HFILL }\n }\n , {\n & hf_sigcomp_decompression_failure , {\n \"DECOMPRESSION-FAILURE\" , \"sigcomp.decompression_failure\" , FT_UINT32 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_sigcomp_wireshark_udvm_diagnostic , {\n \"Wireshark UDVM diagnostic\" , \"sigcomp.wireshark_udvm_diagnostic\" , FT_UINT32 , BASE_DEC , VALS ( result_code_vals ) , 0x0 , NULL , HFILL }\n }\n , {\n & hf_sigcomp_calculated_sha_1 , {\n \"Calculated SHA-1\" , \"sigcomp.calculated_sha_1\" , FT_BYTES , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_sigcomp_copying_value , {\n \"Copying value\" , \"sigcomp.copying_value\" , FT_UINT8 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_sigcomp_storing_value , {\n \"Storing value\" , \"sigcomp.storing_value\" , FT_UINT8 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_sigcomp_loading_value , {\n \"Loading value\" , \"sigcomp.loading_value\" , FT_UINT8 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_sigcomp_set_hu , {\n \"Set Hu\" , \"sigcomp.set_hu\" , FT_BYTES , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_sigcomp_loading_h , {\n \"Loading H\" , \"sigcomp.loading_h\" , FT_UINT8 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_sigcomp_state_value , {\n \"Addr\" , \"sigcomp.state_value\" , FT_UINT8 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_sigcomp_output_value , {\n \"Output value\" , \"sigcomp.output_value\" , FT_UINT8 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_sigcomp_num_state_create , {\n \"no_of_state_create\" , \"sigcomp.num_state_create\" , FT_UINT32 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_sigcomp_sha1_digest , {\n \"SHA1 digest\" , \"sigcomp.sha1_digest\" , FT_BYTES , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_sigcomp_creating_state , {\n \"### Creating state ###\" , \"sigcomp.creating_state\" , FT_BYTES , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_sigcomp_sigcomp_message_decompressed , {\n \"SigComp message Decompressed\" , \"sigcomp.message_decompressed\" , FT_BYTES , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_sigcomp_starting_to_remove_escape_digits , {\n \"Starting to remove escape digits\" , \"sigcomp.starting_to_remove_escape_digits\" , FT_NONE , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_sigcomp_escape_digit_found , {\n \"Escape digit found\" , \"sigcomp.escape_digit_found\" , FT_NONE , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_sigcomp_illegal_escape_code , {\n \"Illegal escape code\" , \"sigcomp.illegal_escape_code\" , FT_NONE , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_sigcomp_end_of_sigcomp_message_indication_found , {\n \"End of SigComp message indication found\" , \"sigcomp.end_of_sigcomp_message_indication_found\" , FT_NONE , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_sigcomp_addr_value , {\n \"Addr\" , \"sigcomp.addr\" , FT_UINT8 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_sigcomp_copying_bytes_literally , {\n \"Copying bytes literally\" , \"sigcomp.copying_bytes_literally\" , FT_BYTES , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_sigcomp_data_for_sigcomp_dissector , {\n \"Data handed to the Sigcomp dissector\" , \"sigcomp.data_for_sigcomp_dissector\" , FT_BYTES , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_sigcomp_remaining_sigcomp_message , {\n \"Remaining SigComp message\" , \"sigcomp.remaining_sigcomp_message\" , FT_BYTES , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_sigcomp_sha1buff , {\n \"sha1buff\" , \"sigcomp.sha1buff\" , FT_BYTES , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_sigcomp_udvm_instruction , {\n \"UDVM instruction\" , \"sigcomp.udvm_instruction\" , FT_UINT8 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_sigcomp_remaining_bytes , {\n \"Remaining bytes\" , \"sigcomp.remaining_bytes\" , FT_BYTES , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_sigcomp_max_udvm_cycles , {\n \"maximum_UDVM_cycles\" , \"sigcomp.max_udvm_cycles\" , FT_UINT32 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_sigcomp_used_udvm_cycles , {\n \"used_udvm_cycles\" , \"sigcomp.used_udvm_cycles\" , FT_UINT32 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_sigcomp_udvm_execution_stated , {\n \"UDVM EXECUTION STARTED\" , \"sigcomp.udvm_execution_stated\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_sigcomp_message_length , {\n \"Message Length\" , \"sigcomp.message_length\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_sigcomp_byte_code_length , {\n \"Byte code length\" , \"sigcomp.byte_code_length\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , }\n ;\n static gint * ett [ ] = {\n & ett_sigcomp , & ett_sigcomp_udvm , & ett_sigcomp_udvm_exe , }\n ;\n static gint * ett_raw [ ] = {\n & ett_raw_text , }\n ;\n static ei_register_info ei [ ] = {\n {\n & ei_sigcomp_nack_failed_op_code , {\n \"sigcomp.nack.failed_op_code.expert\" , PI_SEQUENCE , PI_WARN , \"SigComp NACK\" , EXPFILL }\n }\n , {\n & ei_sigcomp_invalid_instruction , {\n \"sigcomp.invalid_instruction\" , PI_PROTOCOL , PI_WARN , \"Invalid instruction\" , EXPFILL }\n }\n , {\n & ei_sigcomp_invalid_shift_value , {\n \"sigcomp.invalid_shift_value\" , PI_PROTOCOL , PI_WARN , \"Invalid shift value\" , EXPFILL }\n }\n , {\n & ei_sigcomp_sigcomp_message_decompression_failure , {\n \"sigcomp.message_decompression_failure\" , PI_PROTOCOL , PI_WARN , \"SigComp message Decompression failure\" , EXPFILL }\n }\n , {\n & ei_sigcomp_execution_of_this_instruction_is_not_implemented , {\n \"sigcomp.execution_of_this_instruction_is_not_implemented\" , PI_UNDECODED , PI_WARN , \"Execution of this instruction is NOT implemented\" , EXPFILL }\n }\n , {\n & ei_sigcomp_decompression_failure , {\n \"sigcomp.decompression_failure_expert\" , PI_PROTOCOL , PI_WARN , \"DECOMPRESSION FAILURE\" , EXPFILL }\n }\n , {\n & ei_sigcomp_tcp_fragment , {\n \"sigcomp.tcp_fragment\" , PI_MALFORMED , PI_ERROR , \"TCP Fragment\" , EXPFILL }\n }\n , {\n & ei_sigcomp_failed_to_access_state_wireshark_udvm_diagnostic , {\n \"sigcomp.failed_to_access_state_wireshark_udvm_diagnostic\" , PI_PROTOCOL , PI_WARN , \"Failed to Access state Wireshark UDVM diagnostic\" , EXPFILL }\n }\n , {\n & ei_sigcomp_all_remaining_parameters_zero , {\n \"sigcomp.all_remaining_parameters\" , PI_PROTOCOL , PI_NOTE , \"All remaining parameters = 0(Not in the uploaded code as UDVM buffer initialized to Zero\" , EXPFILL }\n }\n , }\n ;\n module_t * sigcomp_module ;\n expert_module_t * expert_sigcomp ;\n static const enum_val_t udvm_detail_vals [ ] = {\n {\n \"no-printout\" , \"No-Printout\" , 0 }\n , {\n \"low-detail\" , \"Low-detail\" , 1 }\n , {\n \"medium-detail\" , \"Medium-detail\" , 2 }\n , {\n \"high-detail\" , \"High-detail\" , 3 }\n , {\n NULL , NULL , - 1 }\n }\n ;\n proto_sigcomp = proto_register_protocol ( \"Signaling Compression\" , \"SIGCOMP\" , \"sigcomp\" ) ;\n proto_raw_sigcomp = proto_register_protocol ( \"Decompressed SigComp message as raw text\" , \"Raw_SigComp\" , \"raw_sigcomp\" ) ;\n register_dissector ( \"sigcomp\" , dissect_sigcomp , proto_sigcomp ) ;\n proto_register_field_array ( proto_sigcomp , hf , array_length ( hf ) ) ;\n proto_register_subtree_array ( ett , array_length ( ett ) ) ;\n proto_register_subtree_array ( ett_raw , array_length ( ett_raw ) ) ;\n expert_sigcomp = expert_register_protocol ( proto_sigcomp ) ;\n expert_register_field_array ( expert_sigcomp , ei , array_length ( ei ) ) ;\n sigcomp_module = prefs_register_protocol ( proto_sigcomp , proto_reg_handoff_sigcomp ) ;\n prefs_register_uint_preference ( sigcomp_module , \"udp.port\" , \"Sigcomp UDP Port 1\" , \"Set UDP port 1 for SigComp messages\" , 10 , & SigCompUDPPort1 ) ;\n prefs_register_uint_preference ( sigcomp_module , \"udp.port2\" , \"Sigcomp UDP Port 2\" , \"Set UDP port 2 for SigComp messages\" , 10 , & SigCompUDPPort2 ) ;\n prefs_register_uint_preference ( sigcomp_module , \"tcp.port\" , \"Sigcomp TCP Port 1\" , \"Set TCP port 1 for SigComp messages\" , 10 , & SigCompTCPPort1 ) ;\n prefs_register_uint_preference ( sigcomp_module , \"tcp.port2\" , \"Sigcomp TCP Port 2\" , \"Set TCP port 2 for SigComp messages\" , 10 , & SigCompTCPPort2 ) ;\n prefs_register_bool_preference ( sigcomp_module , \"display.udvm.code\" , \"Dissect the UDVM code\" , \"Preference whether to Dissect the UDVM code or not\" , & dissect_udvm_code ) ;\n prefs_register_bool_preference ( sigcomp_module , \"display.bytecode\" , \"Display the bytecode of operands\" , \"preference whether to display the bytecode in \" \"UDVM operands or not\" , & display_udvm_bytecode ) ;\n prefs_register_bool_preference ( sigcomp_module , \"decomp.msg\" , \"Decompress message\" , \"preference whether to decompress message or not\" , & decompress ) ;\n prefs_register_bool_preference ( sigcomp_module , \"display.decomp.msg.as.txt\" , \"Displays the decompressed message as text\" , \"preference whether to display the decompressed message \" \"as raw text or not\" , & display_raw_txt ) ;\n prefs_register_enum_preference ( sigcomp_module , \"show.udvm.execution\" , \"Level of detail of UDVM execution:\" , \"'No-Printout' = UDVM executes silently, then increasing detail \" \"about execution of UDVM instructions;\n \" \"Warning! CPU intense at high detail\" , & udvm_print_detail_level , udvm_detail_vals , FALSE ) ;\n register_init_routine ( & sigcomp_init_udvm ) ;\n register_cleanup_routine ( & sigcomp_cleanup_udvm ) ;\n }", "idx": 20950}
{"hash": 8084418997489372457, "project": "chrome", "size": 35, "label": 0, "functionSource": "static hb_unicode_general_category_t hb_icu_unicode_general_category ( hb_unicode_funcs_t * ufuncs HB_UNUSED , hb_codepoint_t unicode , void * user_data HB_UNUSED ) {\n switch ( u_getIntPropertyValue ( unicode , UCHAR_GENERAL_CATEGORY ) ) {\n case U_UNASSIGNED : return HB_UNICODE_GENERAL_CATEGORY_UNASSIGNED ;\n case U_UPPERCASE_LETTER : return HB_UNICODE_GENERAL_CATEGORY_UPPERCASE_LETTER ;\n case U_LOWERCASE_LETTER : return HB_UNICODE_GENERAL_CATEGORY_LOWERCASE_LETTER ;\n case U_TITLECASE_LETTER : return HB_UNICODE_GENERAL_CATEGORY_TITLECASE_LETTER ;\n case U_MODIFIER_LETTER : return HB_UNICODE_GENERAL_CATEGORY_MODIFIER_LETTER ;\n case U_OTHER_LETTER : return HB_UNICODE_GENERAL_CATEGORY_OTHER_LETTER ;\n case U_NON_SPACING_MARK : return HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK ;\n case U_ENCLOSING_MARK : return HB_UNICODE_GENERAL_CATEGORY_ENCLOSING_MARK ;\n case U_COMBINING_SPACING_MARK : return HB_UNICODE_GENERAL_CATEGORY_SPACING_MARK ;\n case U_DECIMAL_DIGIT_NUMBER : return HB_UNICODE_GENERAL_CATEGORY_DECIMAL_NUMBER ;\n case U_LETTER_NUMBER : return HB_UNICODE_GENERAL_CATEGORY_LETTER_NUMBER ;\n case U_OTHER_NUMBER : return HB_UNICODE_GENERAL_CATEGORY_OTHER_NUMBER ;\n case U_SPACE_SEPARATOR : return HB_UNICODE_GENERAL_CATEGORY_SPACE_SEPARATOR ;\n case U_LINE_SEPARATOR : return HB_UNICODE_GENERAL_CATEGORY_LINE_SEPARATOR ;\n case U_PARAGRAPH_SEPARATOR : return HB_UNICODE_GENERAL_CATEGORY_PARAGRAPH_SEPARATOR ;\n case U_CONTROL_CHAR : return HB_UNICODE_GENERAL_CATEGORY_CONTROL ;\n case U_FORMAT_CHAR : return HB_UNICODE_GENERAL_CATEGORY_FORMAT ;\n case U_PRIVATE_USE_CHAR : return HB_UNICODE_GENERAL_CATEGORY_PRIVATE_USE ;\n case U_SURROGATE : return HB_UNICODE_GENERAL_CATEGORY_SURROGATE ;\n case U_DASH_PUNCTUATION : return HB_UNICODE_GENERAL_CATEGORY_DASH_PUNCTUATION ;\n case U_START_PUNCTUATION : return HB_UNICODE_GENERAL_CATEGORY_OPEN_PUNCTUATION ;\n case U_END_PUNCTUATION : return HB_UNICODE_GENERAL_CATEGORY_CLOSE_PUNCTUATION ;\n case U_CONNECTOR_PUNCTUATION : return HB_UNICODE_GENERAL_CATEGORY_CONNECT_PUNCTUATION ;\n case U_OTHER_PUNCTUATION : return HB_UNICODE_GENERAL_CATEGORY_OTHER_PUNCTUATION ;\n case U_MATH_SYMBOL : return HB_UNICODE_GENERAL_CATEGORY_MATH_SYMBOL ;\n case U_CURRENCY_SYMBOL : return HB_UNICODE_GENERAL_CATEGORY_CURRENCY_SYMBOL ;\n case U_MODIFIER_SYMBOL : return HB_UNICODE_GENERAL_CATEGORY_MODIFIER_SYMBOL ;\n case U_OTHER_SYMBOL : return HB_UNICODE_GENERAL_CATEGORY_OTHER_SYMBOL ;\n case U_INITIAL_PUNCTUATION : return HB_UNICODE_GENERAL_CATEGORY_INITIAL_PUNCTUATION ;\n case U_FINAL_PUNCTUATION : return HB_UNICODE_GENERAL_CATEGORY_FINAL_PUNCTUATION ;\n }\n return HB_UNICODE_GENERAL_CATEGORY_UNASSIGNED ;\n }", "idx": 20951}
{"hash": -1315695702746584250, "project": "debian", "size": 8, "label": 0, "functionSource": "char * proto_construct_match_selected_string ( field_info * finfo , epan_dissect_t * edt ) {\n char * filter = NULL ;\n if ( ! construct_match_selected_string ( finfo , edt , & filter ) ) {\n wmem_free ( NULL , filter ) ;\n return NULL ;\n }\n return filter ;\n }", "idx": 20952}
{"hash": 2546373479020365143, "project": "debian", "size": 23, "label": 0, "functionSource": "uint32_t mime_parse_uint ( const char * buf , const char * end ) {\n uint32_t num ;\n if ( ! buf || ( buf == end ) ) {\n return 0 ;\n }\n if ( is_digit ( * buf ) ) {\n num = * buf ++ - '0' ;\n while ( ( buf != end ) && is_digit ( * buf ) ) {\n num = ( num * 10 ) + ( * buf ++ - '0' ) ;\n }\n return num ;\n }\n else {\n num = 0 ;\n while ( ( buf != end ) && ParseRules : : is_space ( * buf ) ) {\n buf += 1 ;\n }\n while ( ( buf != end ) && is_digit ( * buf ) ) {\n num = ( num * 10 ) + ( * buf ++ - '0' ) ;\n }\n return num ;\n }\n }", "idx": 20953}
{"hash": -8665368283409781704, "project": "debian", "size": 5, "label": 0, "functionSource": "void bitmap_writer_reuse_bitmaps ( struct packing_data * to_pack ) {\n if ( prepare_bitmap_git ( ) < 0 ) return ;\n writer . reused = kh_init_sha1 ( ) ;\n rebuild_existing_bitmaps ( to_pack , writer . reused , writer . show_progress ) ;\n }", "idx": 20954}
{"hash": 1760449185745615462, "project": "debian", "size": 6, "label": 0, "functionSource": "TSReturnCode sdk_sanity_check_ssl_hook_id ( TSHttpHookID id ) {\n if ( id < TS_SSL_FIRST_HOOK || id > TS_SSL_LAST_HOOK ) {\n return TS_ERROR ;\n }\n return TS_SUCCESS ;\n }", "idx": 20955}
{"hash": 6393050609822897742, "project": "debian", "size": 18, "label": 0, "functionSource": "static void xhci_kick_ep ( XHCIState * xhci , unsigned int slotid , unsigned int epid , unsigned int streamid ) {\n XHCIEPContext * epctx ;\n assert ( slotid >= 1 && slotid <= xhci -> numslots ) ;\n assert ( epid >= 1 && epid <= 31 ) ;\n if ( ! xhci -> slots [ slotid - 1 ] . enabled ) {\n DPRINTF ( \"xhci: xhci_kick_ep for disabled slot %d\\n\" , slotid ) ;\n return ;\n }\n epctx = xhci -> slots [ slotid - 1 ] . eps [ epid - 1 ] ;\n if ( ! epctx ) {\n DPRINTF ( \"xhci: xhci_kick_ep for disabled endpoint %d,%d\\n\" , epid , slotid ) ;\n return ;\n }\n if ( epctx -> kick_active ) {\n return ;\n }\n xhci_kick_epctx ( epctx , streamid ) ;\n }", "idx": 20956}
{"hash": -5268859819325807498, "project": "debian", "size": 4, "label": 0, "functionSource": "static void mount_state_free ( MountState * state ) {\n g_object_unref ( state -> cancellable ) ;\n g_free ( state ) ;\n }", "idx": 20957}
{"hash": 5506079590431503777, "project": "debian", "size": 4, "label": 0, "functionSource": "static void dissect_mdns_udp ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree ) {\n col_set_str ( pinfo -> cinfo , COL_PROTOCOL , \"MDNS\" ) ;\n dissect_dns_common ( tvb , pinfo , tree , FALSE , TRUE , FALSE ) ;\n }", "idx": 20958}
{"hash": -8919449269326401539, "project": "debian", "size": 6, "label": 0, "functionSource": "static int dissect_s_validator_app_data_path ( packet_info * pinfo , proto_tree * tree , proto_item * item _U_ , tvbuff_t * tvb , int offset , int total_len ) {\n proto_item * pi ;\n proto_tree * epath_tree = proto_tree_add_subtree ( tree , NULL , 0 , 0 , ett_path , & pi , \"Application Data Path: \" ) ;\n dissect_epath ( tvb , pinfo , epath_tree , pi , offset , total_len , FALSE , FALSE , NULL , NULL , NO_DISPLAY , NULL , FALSE ) ;\n return total_len ;\n }", "idx": 20959}
{"hash": 2487534775710400322, "project": "chrome", "size": 22, "label": 0, "functionSource": "TEST_F ( ExtensionWelcomeNotificationTest , DelayedPreferenceSyncNeverShown ) {\n EXPECT_FALSE ( GetBooleanPref ( prefs : : kWelcomeNotificationDismissed ) ) ;\n EXPECT_FALSE ( GetBooleanPref ( prefs : : kWelcomeNotificationDismissedLocal ) ) ;\n EXPECT_FALSE ( GetBooleanPref ( prefs : : kWelcomeNotificationPreviouslyPoppedUp ) ) ;\n ShowChromeNowNotification ( ) ;\n EXPECT_EQ ( message_center ( ) -> add_notification_calls ( ) , 0 ) ;\n EXPECT_EQ ( message_center ( ) -> remove_notification_calls ( ) , 0 ) ;\n EXPECT_EQ ( message_center ( ) -> notifications_with_shown_as_popup ( ) , 0 ) ;\n EXPECT_FALSE ( GetBooleanPref ( prefs : : kWelcomeNotificationDismissed ) ) ;\n EXPECT_FALSE ( GetBooleanPref ( prefs : : kWelcomeNotificationDismissedLocal ) ) ;\n EXPECT_FALSE ( GetBooleanPref ( prefs : : kWelcomeNotificationPreviouslyPoppedUp ) ) ;\n EXPECT_FALSE ( GetBooleanPref ( prefs : : kWelcomeNotificationDismissed ) ) ;\n EXPECT_FALSE ( GetBooleanPref ( prefs : : kWelcomeNotificationDismissedLocal ) ) ;\n EXPECT_FALSE ( GetBooleanPref ( prefs : : kWelcomeNotificationPreviouslyPoppedUp ) ) ;\n StartPreferenceSyncing ( ) ;\n EXPECT_EQ ( message_center ( ) -> add_notification_calls ( ) , 1 ) ;\n EXPECT_EQ ( message_center ( ) -> remove_notification_calls ( ) , 0 ) ;\n EXPECT_EQ ( message_center ( ) -> notifications_with_shown_as_popup ( ) , 0 ) ;\n EXPECT_FALSE ( GetBooleanPref ( prefs : : kWelcomeNotificationDismissed ) ) ;\n EXPECT_FALSE ( GetBooleanPref ( prefs : : kWelcomeNotificationDismissedLocal ) ) ;\n EXPECT_TRUE ( GetBooleanPref ( prefs : : kWelcomeNotificationPreviouslyPoppedUp ) ) ;\n }", "idx": 20960}
{"hash": 5357882892791796049, "project": "debian", "size": 5, "label": 0, "functionSource": "static bool e1000e_has_rxbufs ( E1000ECore * core , const E1000E_RingInfo * r , size_t total_size ) {\n uint32_t bufs = e1000e_ring_free_descr_num ( core , r ) ;\n trace_e1000e_rx_has_buffers ( r -> idx , bufs , total_size , core -> rx_desc_buf_size ) ;\n return total_size <= bufs / ( core -> rx_desc_len / E1000_MIN_RX_DESC_LEN ) * core -> rx_desc_buf_size ;\n }", "idx": 20961}
{"hash": -7422764464424760982, "project": "chrome", "size": 49, "label": 0, "functionSource": "TEST_F ( ExtensionServiceSyncTest , GetSyncExtensionDataUserSettings ) {\n InitializeEmptyExtensionService ( ) ;\n InstallCRX ( data_dir ( ) . AppendASCII ( \"good.crx\" ) , INSTALL_NEW ) ;\n const Extension * extension = service ( ) -> GetInstalledExtension ( good_crx ) ;\n ASSERT_TRUE ( extension ) ;\n extension_sync_service ( ) -> MergeDataAndStartSyncing ( syncer : : EXTENSIONS , syncer : : SyncDataList ( ) , base : : MakeUnique < syncer : : FakeSyncChangeProcessor > ( ) , base : : MakeUnique < syncer : : SyncErrorFactoryMock > ( ) ) ;\n {\n syncer : : SyncDataList list = extension_sync_service ( ) -> GetAllSyncData ( syncer : : EXTENSIONS ) ;\n ASSERT_EQ ( list . size ( ) , 1U ) ;\n std : : unique_ptr < ExtensionSyncData > data = ExtensionSyncData : : CreateFromSyncData ( list [ 0 ] ) ;\n ASSERT_TRUE ( data . get ( ) ) ;\n EXPECT_TRUE ( data -> enabled ( ) ) ;\n EXPECT_FALSE ( data -> incognito_enabled ( ) ) ;\n EXPECT_EQ ( ExtensionSyncData : : BOOLEAN_UNSET , data -> all_urls_enabled ( ) ) ;\n }\n service ( ) -> DisableExtension ( good_crx , extensions : : disable_reason : : DISABLE_USER_ACTION ) ;\n {\n syncer : : SyncDataList list = extension_sync_service ( ) -> GetAllSyncData ( syncer : : EXTENSIONS ) ;\n ASSERT_EQ ( list . size ( ) , 1U ) ;\n std : : unique_ptr < ExtensionSyncData > data = ExtensionSyncData : : CreateFromSyncData ( list [ 0 ] ) ;\n ASSERT_TRUE ( data . get ( ) ) ;\n EXPECT_FALSE ( data -> enabled ( ) ) ;\n EXPECT_FALSE ( data -> incognito_enabled ( ) ) ;\n EXPECT_EQ ( ExtensionSyncData : : BOOLEAN_UNSET , data -> all_urls_enabled ( ) ) ;\n }\n extensions : : util : : SetIsIncognitoEnabled ( good_crx , profile ( ) , true ) ;\n ScriptingPermissionsModifier permissions_modifier ( profile ( ) , registry ( ) -> GetExtensionById ( good_crx , extensions : : ExtensionRegistry : : EVERYTHING ) ) ;\n permissions_modifier . SetAllowedOnAllUrls ( false ) ;\n {\n syncer : : SyncDataList list = extension_sync_service ( ) -> GetAllSyncData ( syncer : : EXTENSIONS ) ;\n ASSERT_EQ ( list . size ( ) , 1U ) ;\n std : : unique_ptr < ExtensionSyncData > data = ExtensionSyncData : : CreateFromSyncData ( list [ 0 ] ) ;\n ASSERT_TRUE ( data . get ( ) ) ;\n EXPECT_FALSE ( data -> enabled ( ) ) ;\n EXPECT_TRUE ( data -> incognito_enabled ( ) ) ;\n EXPECT_EQ ( ExtensionSyncData : : BOOLEAN_FALSE , data -> all_urls_enabled ( ) ) ;\n }\n service ( ) -> EnableExtension ( good_crx ) ;\n permissions_modifier . SetAllowedOnAllUrls ( true ) ;\n {\n syncer : : SyncDataList list = extension_sync_service ( ) -> GetAllSyncData ( syncer : : EXTENSIONS ) ;\n ASSERT_EQ ( list . size ( ) , 1U ) ;\n std : : unique_ptr < ExtensionSyncData > data = ExtensionSyncData : : CreateFromSyncData ( list [ 0 ] ) ;\n ASSERT_TRUE ( data . get ( ) ) ;\n EXPECT_TRUE ( data -> enabled ( ) ) ;\n EXPECT_TRUE ( data -> incognito_enabled ( ) ) ;\n EXPECT_EQ ( ExtensionSyncData : : BOOLEAN_TRUE , data -> all_urls_enabled ( ) ) ;\n }\n }", "idx": 20962}
{"hash": 2125998987781803371, "project": "debian", "size": 7, "label": 0, "functionSource": "static void SchroFrameFree ( SchroFrame * frame , void * priv ) {\n struct picture_free_t * p_free = priv ;\n if ( ! p_free ) return ;\n picture_Release ( p_free -> p_pic ) ;\n free ( p_free ) ;\n ( void ) frame ;\n }", "idx": 20963}
{"hash": -8884965407551053630, "project": "debian", "size": 5, "label": 0, "functionSource": "static int DecoderGetInputAttachments ( decoder_t * p_dec , input_attachment_t * * * ppp_attachment , int * pi_attachment ) {\n input_thread_t * p_input = p_dec -> p_owner -> p_input ;\n if ( unlikely ( p_input == NULL ) ) return VLC_ENOOBJ ;\n return input_Control ( p_input , INPUT_GET_ATTACHMENTS , ppp_attachment , pi_attachment ) ;\n }", "idx": 20964}
{"hash": 367231654042118631, "project": "debian", "size": 22, "label": 0, "functionSource": "static int me_sasl ( struct Client * client_p , struct Client * source_p , int parc , const char * parv [ ] ) {\n struct Client * target_p , * agent_p ;\n if ( strncmp ( parv [ 2 ] , me . id , 3 ) ) return 0 ;\n if ( ( target_p = find_id ( parv [ 2 ] ) ) == NULL ) return 0 ;\n if ( ( agent_p = find_id ( parv [ 1 ] ) ) == NULL ) return 0 ;\n if ( source_p != agent_p -> servptr ) return 0 ;\n if ( ! IsService ( agent_p ) ) return 0 ;\n if ( * target_p -> localClient -> sasl_agent && strncmp ( parv [ 1 ] , target_p -> localClient -> sasl_agent , IDLEN ) ) return 0 ;\n else if ( ! * target_p -> localClient -> sasl_agent ) rb_strlcpy ( target_p -> localClient -> sasl_agent , parv [ 1 ] , IDLEN ) ;\n if ( * parv [ 3 ] == 'C' ) sendto_one ( target_p , \"AUTHENTICATE %s\" , parv [ 4 ] ) ;\n else if ( * parv [ 3 ] == 'D' ) {\n if ( * parv [ 4 ] == 'F' ) sendto_one ( target_p , form_str ( ERR_SASLFAIL ) , me . name , EmptyString ( target_p -> name ) ? \"*\" : target_p -> name ) ;\n else if ( * parv [ 4 ] == 'S' ) {\n sendto_one ( target_p , form_str ( RPL_SASLSUCCESS ) , me . name , EmptyString ( target_p -> name ) ? \"*\" : target_p -> name ) ;\n target_p -> localClient -> sasl_complete = 1 ;\n ServerStats . is_ssuc ++ ;\n }\n * target_p -> localClient -> sasl_agent = '\\0' ;\n }\n else if ( * parv [ 3 ] == 'M' ) sendto_one ( target_p , form_str ( RPL_SASLMECHS ) , me . name , EmptyString ( target_p -> name ) ? \"*\" : target_p -> name , parv [ 4 ] ) ;\n return 0 ;\n }", "idx": 20965}
{"hash": -7237039260294671485, "project": "debian", "size": 3, "label": 0, "functionSource": "static int dissect_nlm1_test ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , void * data ) {\n return dissect_nlm_test ( tvb , 0 , pinfo , tree , 1 , ( rpc_call_info_value * ) data ) ;\n }", "idx": 20966}
{"hash": -7415191846425595149, "project": "chrome", "size": 10, "label": 0, "functionSource": "void vp9_set_mb_mi ( VP9_COMMON * cm , int width , int height ) {\n const int aligned_width = ALIGN_POWER_OF_TWO ( width , MI_SIZE_LOG2 ) ;\n const int aligned_height = ALIGN_POWER_OF_TWO ( height , MI_SIZE_LOG2 ) ;\n cm -> mi_cols = aligned_width >> MI_SIZE_LOG2 ;\n cm -> mi_rows = aligned_height >> MI_SIZE_LOG2 ;\n cm -> mi_stride = calc_mi_size ( cm -> mi_cols ) ;\n cm -> mb_cols = ( cm -> mi_cols + 1 ) >> 1 ;\n cm -> mb_rows = ( cm -> mi_rows + 1 ) >> 1 ;\n cm -> MBs = cm -> mb_rows * cm -> mb_cols ;\n }", "idx": 20967}
{"hash": -4299048894522449432, "project": "debian", "size": 30, "label": 0, "functionSource": "static int inverse_quant_coeff ( IMCContext * q , IMCChannel * chctx , int stream_format_code ) {\n int i , j ;\n int middle_value , cw_len , max_size ;\n const float * quantizer ;\n for ( i = 0 ;\n i < BANDS ;\n i ++ ) {\n for ( j = band_tab [ i ] ;\n j < band_tab [ i + 1 ] ;\n j ++ ) {\n chctx -> CWdecoded [ j ] = 0 ;\n cw_len = chctx -> CWlengthT [ j ] ;\n if ( cw_len <= 0 || chctx -> skipFlags [ j ] ) continue ;\n max_size = 1 << cw_len ;\n middle_value = max_size >> 1 ;\n if ( chctx -> codewords [ j ] >= max_size || chctx -> codewords [ j ] < 0 ) return AVERROR_INVALIDDATA ;\n if ( cw_len >= 4 ) {\n quantizer = imc_quantizer2 [ ( stream_format_code & 2 ) >> 1 ] ;\n if ( chctx -> codewords [ j ] >= middle_value ) chctx -> CWdecoded [ j ] = quantizer [ chctx -> codewords [ j ] - 8 ] * chctx -> flcoeffs6 [ i ] ;\n else chctx -> CWdecoded [ j ] = - quantizer [ max_size - chctx -> codewords [ j ] - 8 - 1 ] * chctx -> flcoeffs6 [ i ] ;\n }\n else {\n quantizer = imc_quantizer1 [ ( ( stream_format_code & 2 ) >> 1 ) | ( chctx -> bandFlagsBuf [ i ] << 1 ) ] ;\n if ( chctx -> codewords [ j ] >= middle_value ) chctx -> CWdecoded [ j ] = quantizer [ chctx -> codewords [ j ] - 1 ] * chctx -> flcoeffs6 [ i ] ;\n else chctx -> CWdecoded [ j ] = - quantizer [ max_size - 2 - chctx -> codewords [ j ] ] * chctx -> flcoeffs6 [ i ] ;\n }\n }\n }\n return 0 ;\n }", "idx": 20968}
{"hash": -9032389459913766398, "project": "debian", "size": 5, "label": 0, "functionSource": "static inline bool ipv6_addr_any ( const struct in6_addr * a ) {\n # if defined ( CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS ) && BITS_PER_LONG == 64 const unsigned long * ul = ( const unsigned long * ) a ;\n return ( ul [ 0 ] | ul [ 1 ] ) == 0UL ;\n # else return ( a -> s6_addr32 [ 0 ] | a -> s6_addr32 [ 1 ] | a -> s6_addr32 [ 2 ] | a -> s6_addr32 [ 3 ] ) == 0 ;\n # endif }", "idx": 20969}
{"hash": -7076754245473579218, "project": "chrome", "size": 4, "label": 0, "functionSource": "void evhttp_set_gencb ( struct evhttp * http , void ( * cb ) ( struct evhttp_request * , void * ) , void * cbarg ) {\n http -> gencb = cb ;\n http -> gencbarg = cbarg ;\n }", "idx": 20970}
{"hash": 6249489553242542670, "project": "debian", "size": 61, "label": 0, "functionSource": "static void config_auth ( config_tree * ptree ) {\n attr_val * my_val ;\n int first ;\n int last ;\n int i ;\n # ifdef AUTOKEY int item ;\n # endif # ifdef AUTOKEY item = - 1 ;\n my_val = HEAD_PFIFO ( ptree -> auth . crypto_cmd_list ) ;\n for ( ;\n my_val != NULL ;\n my_val = my_val -> link ) {\n switch ( my_val -> attr ) {\n default : NTP_INSIST ( 0 ) ;\n break ;\n case T_Host : item = CRYPTO_CONF_PRIV ;\n break ;\n case T_Ident : item = CRYPTO_CONF_IDENT ;\n break ;\n case T_Pw : item = CRYPTO_CONF_PW ;\n break ;\n case T_Randfile : item = CRYPTO_CONF_RAND ;\n break ;\n case T_Digest : item = CRYPTO_CONF_NID ;\n break ;\n }\n crypto_config ( item , my_val -> value . s ) ;\n }\n # endif if ( ptree -> auth . keysdir ) {\n if ( keysdir != default_keysdir ) free ( keysdir ) ;\n keysdir = estrdup ( ptree -> auth . keysdir ) ;\n }\n if ( ptree -> auth . ntp_signd_socket ) {\n if ( ntp_signd_socket != default_ntp_signd_socket ) free ( ntp_signd_socket ) ;\n ntp_signd_socket = estrdup ( ptree -> auth . ntp_signd_socket ) ;\n }\n # ifdef AUTOKEY if ( ptree -> auth . cryptosw && ! cryptosw ) {\n crypto_setup ( ) ;\n cryptosw = 1 ;\n }\n # endif if ( ptree -> auth . keys ) getauthkeys ( ptree -> auth . keys ) ;\n if ( ptree -> auth . control_key ) ctl_auth_keyid = ( keyid_t ) ptree -> auth . control_key ;\n if ( ptree -> auth . request_key ) {\n DPRINTF ( 4 , ( \"set info_auth_keyid to %08lx\\n\" , ( u_long ) ptree -> auth . request_key ) ) ;\n info_auth_keyid = ( keyid_t ) ptree -> auth . request_key ;\n }\n my_val = HEAD_PFIFO ( ptree -> auth . trusted_key_list ) ;\n for ( ;\n my_val != NULL ;\n my_val = my_val -> link ) {\n if ( T_Integer == my_val -> type ) authtrust ( my_val -> value . i , 1 ) ;\n else if ( T_Intrange == my_val -> type ) {\n first = my_val -> value . r . first ;\n last = my_val -> value . r . last ;\n if ( first > last || first < 1 || last > 65534 ) msyslog ( LOG_NOTICE , \"Ignoring invalid trustedkey range %d ... %d, min 1 max 65534.\" , first , last ) ;\n else for ( i = first ;\n i <= last ;\n i ++ ) authtrust ( ( keyid_t ) i , 1 ) ;\n }\n }\n # ifdef AUTOKEY if ( ptree -> auth . revoke ) sys_revoke = 1 << ptree -> auth . revoke ;\n # endif }", "idx": 20971}
{"hash": 5347874611477979643, "project": "chrome", "size": 10, "label": 0, "functionSource": "static void combined_read_cb ( int fd , short event , void * arg ) {\n struct both * both = arg ;\n char buf [ 128 ] ;\n int len ;\n len = read ( fd , buf , sizeof ( buf ) ) ;\n if ( len == - 1 ) fprintf ( stderr , \"%s: read\\n\" , __func__ ) ;\n if ( len <= 0 ) return ;\n both -> nread += len ;\n if ( event_add ( & both -> ev , NULL ) == - 1 ) exit ( 1 ) ;\n }", "idx": 20972}
{"hash": -7415191846425595149, "project": "chrome", "size": 7, "label": 0, "functionSource": "static void clear_mi_border ( const VP9_COMMON * cm , MODE_INFO * mi ) {\n int i ;\n vpx_memset ( mi , 0 , sizeof ( * mi ) * cm -> mi_stride ) ;\n for ( i = 1 ;\n i < cm -> mi_rows + 1 ;\n ++ i ) vpx_memset ( & mi [ i * cm -> mi_stride ] , 0 , sizeof ( * mi ) ) ;\n }", "idx": 20973}
{"hash": -550840957453737733, "project": "chrome", "size": 29, "label": 0, "functionSource": "TEST_F ( NotificationConversionHelperTest , NotificationToNotificationOptions ) {\n scoped_ptr < Notification > notification1 = CreateNotification ( message_center : : NOTIFICATION_TYPE_IMAGE ) ;\n scoped_ptr < extensions : : api : : notifications : : NotificationOptions > options1 ( new extensions : : api : : notifications : : NotificationOptions ( ) ) ;\n NotificationConversionHelper : : NotificationToNotificationOptions ( * ( notification1 ) , options1 . get ( ) ) ;\n EXPECT_EQ ( options1 -> type , extensions : : api : : notifications : : TEMPLATE_TYPE_IMAGE ) ;\n EXPECT_EQ ( * ( options1 -> title ) , \"Title\" ) ;\n EXPECT_EQ ( * ( options1 -> message ) , \"This is a message.\" ) ;\n EXPECT_EQ ( * ( options1 -> priority ) , 1 ) ;\n EXPECT_EQ ( * ( options1 -> context_message ) , \"I am a context message.\" ) ;\n EXPECT_FALSE ( * ( options1 -> is_clickable ) ) ;\n EXPECT_EQ ( * ( options1 -> event_time ) , 12345678.9 ) ;\n EXPECT_EQ ( options1 -> buttons -> at ( 0 ) -> title , \"Button 1\" ) ;\n EXPECT_EQ ( options1 -> buttons -> at ( 1 ) -> title , \"Button 2\" ) ;\n EXPECT_EQ ( options1 -> icon_bitmap -> width , 1 ) ;\n EXPECT_EQ ( options1 -> icon_bitmap -> height , 1 ) ;\n scoped_ptr < Notification > notification2 = CreateNotification ( message_center : : NOTIFICATION_TYPE_PROGRESS ) ;\n scoped_ptr < extensions : : api : : notifications : : NotificationOptions > options2 ( new extensions : : api : : notifications : : NotificationOptions ( ) ) ;\n NotificationConversionHelper : : NotificationToNotificationOptions ( * ( notification2 ) , options2 . get ( ) ) ;\n EXPECT_EQ ( options2 -> type , extensions : : api : : notifications : : TEMPLATE_TYPE_PROGRESS ) ;\n EXPECT_EQ ( * ( options2 -> progress ) , 50 ) ;\n scoped_ptr < Notification > notification3 = CreateNotification ( message_center : : NOTIFICATION_TYPE_MULTIPLE ) ;\n scoped_ptr < extensions : : api : : notifications : : NotificationOptions > options3 ( new extensions : : api : : notifications : : NotificationOptions ( ) ) ;\n NotificationConversionHelper : : NotificationToNotificationOptions ( * ( notification3 ) , options3 . get ( ) ) ;\n EXPECT_EQ ( options3 -> type , extensions : : api : : notifications : : TEMPLATE_TYPE_LIST ) ;\n EXPECT_EQ ( options3 -> items -> at ( 0 ) -> title , \"Item 1 Title\" ) ;\n EXPECT_EQ ( options3 -> items -> at ( 0 ) -> message , \"Item 1 Message\" ) ;\n EXPECT_EQ ( options3 -> items -> at ( 1 ) -> title , \"Item 2 Title\" ) ;\n EXPECT_EQ ( options3 -> items -> at ( 1 ) -> message , \"Item 2 Message\" ) ;\n }", "idx": 20974}
{"hash": 2895622461494525400, "project": "debian", "size": 33, "label": 0, "functionSource": "static void test_bug56976 ( ) {\n MYSQL_STMT * stmt ;\n MYSQL_BIND bind [ 1 ] ;\n int rc ;\n const char * query = \"SELECT LENGTH(?)\" ;\n char * long_buffer ;\n unsigned long i , packet_len = 256 * 1024L ;\n unsigned long dos_len = 8 * 1024 * 1024L ;\n DBUG_ENTER ( \"test_bug56976\" ) ;\n myheader ( \"test_bug56976\" ) ;\n stmt = mysql_stmt_init ( mysql ) ;\n check_stmt ( stmt ) ;\n rc = mysql_stmt_prepare ( stmt , query , strlen ( query ) ) ;\n check_execute ( stmt , rc ) ;\n memset ( bind , 0 , sizeof ( bind ) ) ;\n bind [ 0 ] . buffer_type = MYSQL_TYPE_TINY_BLOB ;\n rc = mysql_stmt_bind_param ( stmt , bind ) ;\n check_execute ( stmt , rc ) ;\n long_buffer = ( char * ) my_malloc ( packet_len , MYF ( 0 ) ) ;\n DIE_UNLESS ( long_buffer ) ;\n memset ( long_buffer , 'a' , packet_len ) ;\n for ( i = 0 ;\n i < dos_len / packet_len ;\n i ++ ) {\n rc = mysql_stmt_send_long_data ( stmt , 0 , long_buffer , packet_len ) ;\n check_execute ( stmt , rc ) ;\n }\n my_free ( long_buffer ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n DIE_UNLESS ( rc && mysql_stmt_errno ( stmt ) == ER_UNKNOWN_ERROR ) ;\n mysql_stmt_close ( stmt ) ;\n DBUG_VOID_RETURN ;\n }", "idx": 20975}
{"hash": -4635544075321012404, "project": "debian", "size": 285, "label": 0, "functionSource": "static CURLFORMcode FormAdd ( struct curl_httppost * * httppost , struct curl_httppost * * last_post , va_list params ) {\n FormInfo * first_form , * current_form , * form = NULL ;\n CURLFORMcode return_value = CURL_FORMADD_OK ;\n const char * prevtype = NULL ;\n struct curl_httppost * post = NULL ;\n CURLformoption option ;\n struct curl_forms * forms = NULL ;\n char * array_value = NULL ;\n bool array_state = FALSE ;\n first_form = calloc ( 1 , sizeof ( struct FormInfo ) ) ;\n if ( ! first_form ) return CURL_FORMADD_MEMORY ;\n current_form = first_form ;\n while ( return_value == CURL_FORMADD_OK ) {\n if ( array_state && forms ) {\n option = forms -> option ;\n array_value = ( char * ) forms -> value ;\n forms ++ ;\n if ( CURLFORM_END == option ) {\n array_state = FALSE ;\n continue ;\n }\n }\n else {\n option = va_arg ( params , CURLformoption ) ;\n if ( CURLFORM_END == option ) break ;\n }\n switch ( option ) {\n case CURLFORM_ARRAY : if ( array_state ) return_value = CURL_FORMADD_ILLEGAL_ARRAY ;\n else {\n forms = va_arg ( params , struct curl_forms * ) ;\n if ( forms ) array_state = TRUE ;\n else return_value = CURL_FORMADD_NULL ;\n }\n break ;\n case CURLFORM_PTRNAME : # ifdef CURL_DOES_CONVERSIONS # else current_form -> flags |= HTTPPOST_PTRNAME ;\n # endif case CURLFORM_COPYNAME : if ( current_form -> name ) return_value = CURL_FORMADD_OPTION_TWICE ;\n else {\n char * name = array_state ? array_value : va_arg ( params , char * ) ;\n if ( name ) current_form -> name = name ;\n else return_value = CURL_FORMADD_NULL ;\n }\n break ;\n case CURLFORM_NAMELENGTH : if ( current_form -> namelength ) return_value = CURL_FORMADD_OPTION_TWICE ;\n else current_form -> namelength = array_state ? ( size_t ) array_value : ( size_t ) va_arg ( params , long ) ;\n break ;\n case CURLFORM_PTRCONTENTS : current_form -> flags |= HTTPPOST_PTRCONTENTS ;\n case CURLFORM_COPYCONTENTS : if ( current_form -> value ) return_value = CURL_FORMADD_OPTION_TWICE ;\n else {\n char * value = array_state ? array_value : va_arg ( params , char * ) ;\n if ( value ) current_form -> value = value ;\n else return_value = CURL_FORMADD_NULL ;\n }\n break ;\n case CURLFORM_CONTENTSLENGTH : if ( current_form -> contentslength ) return_value = CURL_FORMADD_OPTION_TWICE ;\n else current_form -> contentslength = array_state ? ( size_t ) array_value : ( size_t ) va_arg ( params , long ) ;\n break ;\n case CURLFORM_FILECONTENT : if ( current_form -> flags & ( HTTPPOST_PTRCONTENTS | HTTPPOST_READFILE ) ) return_value = CURL_FORMADD_OPTION_TWICE ;\n else {\n const char * filename = array_state ? array_value : va_arg ( params , char * ) ;\n if ( filename ) {\n current_form -> value = strdup ( filename ) ;\n if ( ! current_form -> value ) return_value = CURL_FORMADD_MEMORY ;\n else {\n current_form -> flags |= HTTPPOST_READFILE ;\n current_form -> value_alloc = TRUE ;\n }\n }\n else return_value = CURL_FORMADD_NULL ;\n }\n break ;\n case CURLFORM_FILE : {\n const char * filename = array_state ? array_value : va_arg ( params , char * ) ;\n if ( current_form -> value ) {\n if ( current_form -> flags & HTTPPOST_FILENAME ) {\n if ( filename ) {\n char * fname = strdup ( filename ) ;\n if ( ! fname ) return_value = CURL_FORMADD_MEMORY ;\n else {\n form = AddFormInfo ( fname , NULL , current_form ) ;\n if ( ! form ) {\n Curl_safefree ( fname ) ;\n return_value = CURL_FORMADD_MEMORY ;\n }\n else {\n form -> value_alloc = TRUE ;\n current_form = form ;\n form = NULL ;\n }\n }\n }\n else return_value = CURL_FORMADD_NULL ;\n }\n else return_value = CURL_FORMADD_OPTION_TWICE ;\n }\n else {\n if ( filename ) {\n current_form -> value = strdup ( filename ) ;\n if ( ! current_form -> value ) return_value = CURL_FORMADD_MEMORY ;\n else {\n current_form -> flags |= HTTPPOST_FILENAME ;\n current_form -> value_alloc = TRUE ;\n }\n }\n else return_value = CURL_FORMADD_NULL ;\n }\n break ;\n }\n case CURLFORM_BUFFERPTR : current_form -> flags |= HTTPPOST_PTRBUFFER | HTTPPOST_BUFFER ;\n if ( current_form -> buffer ) return_value = CURL_FORMADD_OPTION_TWICE ;\n else {\n char * buffer = array_state ? array_value : va_arg ( params , char * ) ;\n if ( buffer ) {\n current_form -> buffer = buffer ;\n current_form -> value = buffer ;\n }\n else return_value = CURL_FORMADD_NULL ;\n }\n break ;\n case CURLFORM_BUFFERLENGTH : if ( current_form -> bufferlength ) return_value = CURL_FORMADD_OPTION_TWICE ;\n else current_form -> bufferlength = array_state ? ( size_t ) array_value : ( size_t ) va_arg ( params , long ) ;\n break ;\n case CURLFORM_STREAM : current_form -> flags |= HTTPPOST_CALLBACK ;\n if ( current_form -> userp ) return_value = CURL_FORMADD_OPTION_TWICE ;\n else {\n char * userp = array_state ? array_value : va_arg ( params , char * ) ;\n if ( userp ) {\n current_form -> userp = userp ;\n current_form -> value = userp ;\n }\n else return_value = CURL_FORMADD_NULL ;\n }\n break ;\n case CURLFORM_CONTENTTYPE : {\n const char * contenttype = array_state ? array_value : va_arg ( params , char * ) ;\n if ( current_form -> contenttype ) {\n if ( current_form -> flags & HTTPPOST_FILENAME ) {\n if ( contenttype ) {\n char * type = strdup ( contenttype ) ;\n if ( ! type ) return_value = CURL_FORMADD_MEMORY ;\n else {\n form = AddFormInfo ( NULL , type , current_form ) ;\n if ( ! form ) {\n Curl_safefree ( type ) ;\n return_value = CURL_FORMADD_MEMORY ;\n }\n else {\n form -> contenttype_alloc = TRUE ;\n current_form = form ;\n form = NULL ;\n }\n }\n }\n else return_value = CURL_FORMADD_NULL ;\n }\n else return_value = CURL_FORMADD_OPTION_TWICE ;\n }\n else {\n if ( contenttype ) {\n current_form -> contenttype = strdup ( contenttype ) ;\n if ( ! current_form -> contenttype ) return_value = CURL_FORMADD_MEMORY ;\n else current_form -> contenttype_alloc = TRUE ;\n }\n else return_value = CURL_FORMADD_NULL ;\n }\n break ;\n }\n case CURLFORM_CONTENTHEADER : {\n struct curl_slist * list = array_state ? ( struct curl_slist * ) array_value : va_arg ( params , struct curl_slist * ) ;\n if ( current_form -> contentheader ) return_value = CURL_FORMADD_OPTION_TWICE ;\n else current_form -> contentheader = list ;\n break ;\n }\n case CURLFORM_FILENAME : case CURLFORM_BUFFER : {\n const char * filename = array_state ? array_value : va_arg ( params , char * ) ;\n if ( current_form -> showfilename ) return_value = CURL_FORMADD_OPTION_TWICE ;\n else {\n current_form -> showfilename = strdup ( filename ) ;\n if ( ! current_form -> showfilename ) return_value = CURL_FORMADD_MEMORY ;\n else current_form -> showfilename_alloc = TRUE ;\n }\n break ;\n }\n default : return_value = CURL_FORMADD_UNKNOWN_OPTION ;\n break ;\n }\n }\n if ( CURL_FORMADD_OK != return_value ) {\n FormInfo * ptr ;\n for ( ptr = first_form ;\n ptr != NULL ;\n ptr = ptr -> more ) {\n if ( ptr -> name_alloc ) {\n Curl_safefree ( ptr -> name ) ;\n ptr -> name_alloc = FALSE ;\n }\n if ( ptr -> value_alloc ) {\n Curl_safefree ( ptr -> value ) ;\n ptr -> value_alloc = FALSE ;\n }\n if ( ptr -> contenttype_alloc ) {\n Curl_safefree ( ptr -> contenttype ) ;\n ptr -> contenttype_alloc = FALSE ;\n }\n if ( ptr -> showfilename_alloc ) {\n Curl_safefree ( ptr -> showfilename ) ;\n ptr -> showfilename_alloc = FALSE ;\n }\n }\n }\n if ( CURL_FORMADD_OK == return_value ) {\n post = NULL ;\n for ( form = first_form ;\n form != NULL ;\n form = form -> more ) {\n if ( ( ( ! form -> name || ! form -> value ) && ! post ) || ( ( form -> contentslength ) && ( form -> flags & HTTPPOST_FILENAME ) ) || ( ( form -> flags & HTTPPOST_FILENAME ) && ( form -> flags & HTTPPOST_PTRCONTENTS ) ) || ( ( ! form -> buffer ) && ( form -> flags & HTTPPOST_BUFFER ) && ( form -> flags & HTTPPOST_PTRBUFFER ) ) || ( ( form -> flags & HTTPPOST_READFILE ) && ( form -> flags & HTTPPOST_PTRCONTENTS ) ) ) {\n return_value = CURL_FORMADD_INCOMPLETE ;\n break ;\n }\n else {\n if ( ( ( form -> flags & HTTPPOST_FILENAME ) || ( form -> flags & HTTPPOST_BUFFER ) ) && ! form -> contenttype ) {\n char * f = form -> flags & HTTPPOST_BUFFER ? form -> showfilename : form -> value ;\n form -> contenttype = strdup ( ContentTypeForFilename ( f , prevtype ) ) ;\n if ( ! form -> contenttype ) {\n return_value = CURL_FORMADD_MEMORY ;\n break ;\n }\n form -> contenttype_alloc = TRUE ;\n }\n if ( ! ( form -> flags & HTTPPOST_PTRNAME ) && ( form == first_form ) ) {\n if ( form -> name ) {\n form -> name = Curl_memdup ( form -> name , form -> namelength ? form -> namelength : strlen ( form -> name ) + 1 ) ;\n }\n if ( ! form -> name ) {\n return_value = CURL_FORMADD_MEMORY ;\n break ;\n }\n form -> name_alloc = TRUE ;\n }\n if ( ! ( form -> flags & ( HTTPPOST_FILENAME | HTTPPOST_READFILE | HTTPPOST_PTRCONTENTS | HTTPPOST_PTRBUFFER | HTTPPOST_CALLBACK ) ) && form -> value ) {\n form -> value = Curl_memdup ( form -> value , form -> contentslength ? form -> contentslength : strlen ( form -> value ) + 1 ) ;\n if ( ! form -> value ) {\n return_value = CURL_FORMADD_MEMORY ;\n break ;\n }\n form -> value_alloc = TRUE ;\n }\n post = AddHttpPost ( form -> name , form -> namelength , form -> value , form -> contentslength , form -> buffer , form -> bufferlength , form -> contenttype , form -> flags , form -> contentheader , form -> showfilename , form -> userp , post , httppost , last_post ) ;\n if ( ! post ) {\n return_value = CURL_FORMADD_MEMORY ;\n break ;\n }\n if ( form -> contenttype ) prevtype = form -> contenttype ;\n }\n }\n if ( CURL_FORMADD_OK != return_value ) {\n FormInfo * ptr ;\n for ( ptr = form ;\n ptr != NULL ;\n ptr = ptr -> more ) {\n if ( ptr -> name_alloc ) {\n Curl_safefree ( ptr -> name ) ;\n ptr -> name_alloc = FALSE ;\n }\n if ( ptr -> value_alloc ) {\n Curl_safefree ( ptr -> value ) ;\n ptr -> value_alloc = FALSE ;\n }\n if ( ptr -> contenttype_alloc ) {\n Curl_safefree ( ptr -> contenttype ) ;\n ptr -> contenttype_alloc = FALSE ;\n }\n if ( ptr -> showfilename_alloc ) {\n Curl_safefree ( ptr -> showfilename ) ;\n ptr -> showfilename_alloc = FALSE ;\n }\n }\n }\n }\n while ( first_form ) {\n FormInfo * ptr = first_form -> more ;\n Curl_safefree ( first_form ) ;\n first_form = ptr ;\n }\n return return_value ;\n }", "idx": 20976}
{"hash": -942846491258578486, "project": "debian", "size": 29, "label": 0, "functionSource": "static enum nss_status internal_setent ( int stayopen ) {\n enum nss_status status = NSS_STATUS_SUCCESS ;\n if ( stream == NULL ) {\n stream = fopen ( DATAFILE , \"rce\" ) ;\n if ( stream == NULL ) status = errno == EAGAIN ? NSS_STATUS_TRYAGAIN : NSS_STATUS_UNAVAIL ;\n else {\n # if ! defined O_CLOEXEC || ! defined __ASSUME_O_CLOEXEC # ifdef O_CLOEXEC if ( __have_o_cloexec <= 0 ) # endif {\n int result ;\n int flags ;\n result = flags = fcntl ( fileno ( stream ) , F_GETFD , 0 ) ;\n if ( result >= 0 ) {\n # ifdef O_CLOEXEC if ( __have_o_cloexec == 0 ) __have_o_cloexec = ( flags & FD_CLOEXEC ) == 0 ? - 1 : 1 ;\n if ( __have_o_cloexec < 0 ) # endif {\n flags |= FD_CLOEXEC ;\n result = fcntl ( fileno ( stream ) , F_SETFD , flags ) ;\n }\n }\n if ( result < 0 ) {\n fclose ( stream ) ;\n stream = NULL ;\n status = NSS_STATUS_UNAVAIL ;\n }\n }\n # endif }\n }\n else rewind ( stream ) ;\n if ( stream != NULL ) keep_stream |= stayopen ;\n return status ;\n }", "idx": 20977}
{"hash": 1760449185745615462, "project": "debian", "size": 9, "label": 0, "functionSource": "TSVIO TSVConnRead ( TSVConn connp , TSCont contp , TSIOBuffer bufp , int64_t nbytes ) {\n sdk_assert ( sdk_sanity_check_iocore_structure ( connp ) == TS_SUCCESS ) ;\n sdk_assert ( sdk_sanity_check_iocore_structure ( contp ) == TS_SUCCESS ) ;\n sdk_assert ( sdk_sanity_check_iocore_structure ( bufp ) == TS_SUCCESS ) ;\n sdk_assert ( nbytes >= 0 ) ;\n FORCE_PLUGIN_SCOPED_MUTEX ( contp ) ;\n VConnection * vc = ( VConnection * ) connp ;\n return reinterpret_cast < TSVIO > ( vc -> do_io ( VIO : : READ , ( INKContInternal * ) contp , nbytes , ( MIOBuffer * ) bufp ) ) ;\n }", "idx": 20978}
{"hash": -2222463888415249941, "project": "chrome", "size": 27, "label": 0, "functionSource": "void adjust_frame_rate ( VP9_COMP * cpi , const struct lookahead_entry * source ) {\n int64_t this_duration ;\n int step = 0 ;\n if ( source -> ts_start == cpi -> first_time_stamp_ever ) {\n this_duration = source -> ts_end - source -> ts_start ;\n step = 1 ;\n }\n else {\n int64_t last_duration = cpi -> last_end_time_stamp_seen - cpi -> last_time_stamp_seen ;\n this_duration = source -> ts_end - cpi -> last_end_time_stamp_seen ;\n if ( last_duration ) step = ( int ) ( ( this_duration - last_duration ) * 10 / last_duration ) ;\n }\n if ( this_duration ) {\n if ( step ) {\n vp9_new_framerate ( cpi , 10000000.0 / this_duration ) ;\n }\n else {\n const double interval = MIN ( ( double ) ( source -> ts_end - cpi -> first_time_stamp_ever ) , 10000000.0 ) ;\n double avg_duration = 10000000.0 / cpi -> framerate ;\n avg_duration *= ( interval - avg_duration + this_duration ) ;\n avg_duration /= interval ;\n vp9_new_framerate ( cpi , 10000000.0 / avg_duration ) ;\n }\n }\n cpi -> last_time_stamp_seen = source -> ts_start ;\n cpi -> last_end_time_stamp_seen = source -> ts_end ;\n }", "idx": 20979}
{"hash": -6580451576689962916, "project": "debian", "size": 4, "label": 0, "functionSource": "static char * ext_t_0_wv_cspc_11 ( tvbuff_t * tvb _U_ , guint32 value , guint32 str_tbl _U_ ) {\n char * str = wmem_strdup_printf ( wmem_packet_scope ( ) , \"Common Value: '%s'\" , val_to_str_ext ( value , & vals_wv_csp_11_element_value_tokens_ext , \"<Unknown WV-CSP 1.1 Common Value token 0x%X>\" ) ) ;\n return str ;\n }", "idx": 20980}
{"hash": -1929262071302712016, "project": "debian", "size": 26, "label": 0, "functionSource": "static void * Type_ColorantTable_Read ( struct _cms_typehandler_struct * self , cmsIOHANDLER * io , cmsUInt32Number * nItems , cmsUInt32Number SizeOfTag ) {\n cmsUInt32Number i , Count ;\n cmsNAMEDCOLORLIST * List ;\n char Name [ 34 ] ;\n cmsUInt16Number PCS [ 3 ] ;\n if ( ! _cmsReadUInt32Number ( io , & Count ) ) return NULL ;\n if ( Count > cmsMAXCHANNELS ) {\n cmsSignalError ( self -> ContextID , cmsERROR_RANGE , \"Too many colorants '%d'\" , Count ) ;\n return NULL ;\n }\n List = cmsAllocNamedColorList ( self -> ContextID , Count , 0 , \"\" , \"\" ) ;\n for ( i = 0 ;\n i < Count ;\n i ++ ) {\n if ( io -> Read ( io , Name , 32 , 1 ) != 1 ) goto Error ;\n Name [ 33 ] = 0 ;\n if ( ! _cmsReadUInt16Array ( io , 3 , PCS ) ) goto Error ;\n if ( ! cmsAppendNamedColor ( List , Name , PCS , NULL ) ) goto Error ;\n }\n * nItems = 1 ;\n return List ;\n Error : * nItems = 0 ;\n cmsFreeNamedColorList ( List ) ;\n return NULL ;\n cmsUNUSED_PARAMETER ( SizeOfTag ) ;\n }", "idx": 20981}
{"hash": 7039307292471244756, "project": "debian", "size": 12, "label": 0, "functionSource": "guint16 de_rej_cause ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len _U_ , gchar * add_string _U_ , int string_len _U_ ) {\n guint8 oct ;\n const gchar * str ;\n oct = tvb_get_guint8 ( tvb , offset ) ;\n str = try_rval_to_str ( oct , gsm_a_dtap_rej_cause_vals ) ;\n if ( ! str ) {\n if ( is_uplink == IS_UPLINK_TRUE ) str = \"Protocol error, unspecified\" ;\n else str = \"Service option temporarily out of order\" ;\n }\n proto_tree_add_uint_format_value ( tree , hf_gsm_a_dtap_rej_cause , tvb , offset , 1 , oct , \"%s (%u)\" , str , oct ) ;\n return ( 1 ) ;\n }", "idx": 20982}
{"hash": -2723830976796502611, "project": "chrome", "size": 12, "label": 0, "functionSource": "static vpx_codec_err_t encoder_set_config ( vpx_codec_alg_priv_t * ctx , const vpx_codec_enc_cfg_t * cfg ) {\n vpx_codec_err_t res ;\n if ( cfg -> g_w != ctx -> cfg . g_w || cfg -> g_h != ctx -> cfg . g_h ) ERROR ( \"Cannot change width or height after initialization\" ) ;\n if ( cfg -> g_lag_in_frames > ctx -> cfg . g_lag_in_frames ) ERROR ( \"Cannot increase lag_in_frames\" ) ;\n res = validate_config ( ctx , cfg , & ctx -> extra_cfg ) ;\n if ( res == VPX_CODEC_OK ) {\n ctx -> cfg = * cfg ;\n set_encoder_config ( & ctx -> oxcf , & ctx -> cfg , & ctx -> extra_cfg ) ;\n vp9_change_config ( ctx -> cpi , & ctx -> oxcf ) ;\n }\n return res ;\n }", "idx": 20983}
{"hash": -2648356651055439484, "project": "debian", "size": 32, "label": 0, "functionSource": "guint16 elem_v_short ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo , gint pdu_type , int idx , guint32 offset , guint32 nibble ) {\n guint16 consumed = 1 ;\n guint32 curr_offset ;\n proto_tree * subtree ;\n proto_item * item ;\n value_string_ext elem_names_ext ;\n gint * elem_ett ;\n elem_fcn * elem_funcs ;\n gchar * a_add_string ;\n const gchar * elem_name ;\n curr_offset = offset ;\n SET_ELEM_VARS ( pdu_type , elem_names_ext , elem_ett , elem_funcs , & ei_gsm_a_unknown_pdu_type ) ;\n elem_name = try_val_to_str_ext ( idx , & elem_names_ext ) ;\n if ( elem_name == NULL ) {\n proto_tree_add_expert ( tree , pinfo , & ei_gsm_a_unknown_element , tvb , curr_offset , 0 ) ;\n return consumed ;\n }\n subtree = proto_tree_add_subtree ( tree , tvb , curr_offset , 0 , elem_ett [ idx ] , & item , elem_name ) ;\n a_add_string = ( gchar * ) wmem_alloc ( wmem_packet_scope ( ) , 1024 ) ;\n a_add_string [ 0 ] = '\\0' ;\n if ( elem_funcs [ idx ] == NULL ) {\n ( void ) de_spare_nibble ( tvb , subtree , pinfo , curr_offset , nibble , a_add_string , 1024 ) ;\n }\n else {\n ( void ) ( * elem_funcs [ idx ] ) ( tvb , subtree , pinfo , curr_offset , nibble , a_add_string , 1024 ) ;\n }\n if ( a_add_string [ 0 ] != '\\0' ) {\n proto_item_append_text ( item , \"%s\" , a_add_string ) ;\n }\n proto_item_set_len ( item , consumed ) ;\n return consumed ;\n }", "idx": 20984}
{"hash": 8849962823026424130, "project": "debian", "size": 74, "label": 0, "functionSource": "static int qio_channel_websock_decode_header ( QIOChannelWebsock * ioc , Error * * errp ) {\n unsigned char opcode , fin , has_mask ;\n size_t header_size ;\n size_t payload_len ;\n QIOChannelWebsockHeader * header = ( QIOChannelWebsockHeader * ) ioc -> encinput . buffer ;\n if ( ioc -> payload_remain ) {\n error_setg ( errp , \"Decoding header but %zu bytes of payload remain\" , ioc -> payload_remain ) ;\n qio_channel_websock_write_close ( ioc , QIO_CHANNEL_WEBSOCK_STATUS_SERVER_ERR , \"internal server error\" ) ;\n return - 1 ;\n }\n if ( ioc -> encinput . offset < QIO_CHANNEL_WEBSOCK_HEADER_LEN_7_BIT ) {\n return QIO_CHANNEL_ERR_BLOCK ;\n }\n fin = header -> b0 & QIO_CHANNEL_WEBSOCK_HEADER_FIELD_FIN ;\n opcode = header -> b0 & QIO_CHANNEL_WEBSOCK_HEADER_FIELD_OPCODE ;\n has_mask = header -> b1 & QIO_CHANNEL_WEBSOCK_HEADER_FIELD_HAS_MASK ;\n payload_len = header -> b1 & QIO_CHANNEL_WEBSOCK_HEADER_FIELD_PAYLOAD_LEN ;\n if ( opcode ) {\n ioc -> opcode = opcode ;\n }\n else {\n opcode = ioc -> opcode ;\n }\n trace_qio_channel_websock_header_partial_decode ( ioc , payload_len , fin , opcode , ( int ) has_mask ) ;\n if ( opcode == QIO_CHANNEL_WEBSOCK_OPCODE_CLOSE ) {\n return 0 ;\n }\n if ( ! fin ) {\n if ( opcode != QIO_CHANNEL_WEBSOCK_OPCODE_BINARY_FRAME ) {\n error_setg ( errp , \"only binary websocket frames may be fragmented\" ) ;\n qio_channel_websock_write_close ( ioc , QIO_CHANNEL_WEBSOCK_STATUS_POLICY , \"only binary frames may be fragmented\" ) ;\n return - 1 ;\n }\n }\n else {\n if ( opcode != QIO_CHANNEL_WEBSOCK_OPCODE_BINARY_FRAME && opcode != QIO_CHANNEL_WEBSOCK_OPCODE_CLOSE && opcode != QIO_CHANNEL_WEBSOCK_OPCODE_PING && opcode != QIO_CHANNEL_WEBSOCK_OPCODE_PONG ) {\n error_setg ( errp , \"unsupported opcode: %#04x;\n only binary, close, \" \"ping, and pong websocket frames are supported\" , opcode ) ;\n qio_channel_websock_write_close ( ioc , QIO_CHANNEL_WEBSOCK_STATUS_INVALID_DATA , \"only binary, close, ping, and pong frames are supported\" ) ;\n return - 1 ;\n }\n }\n if ( ! has_mask ) {\n error_setg ( errp , \"client websocket frames must be masked\" ) ;\n qio_channel_websock_write_close ( ioc , QIO_CHANNEL_WEBSOCK_STATUS_PROTOCOL_ERR , \"client frames must be masked\" ) ;\n return - 1 ;\n }\n if ( payload_len < QIO_CHANNEL_WEBSOCK_PAYLOAD_LEN_MAGIC_16_BIT ) {\n ioc -> payload_remain = payload_len ;\n header_size = QIO_CHANNEL_WEBSOCK_HEADER_LEN_7_BIT ;\n ioc -> mask = header -> u . m ;\n }\n else if ( opcode & QIO_CHANNEL_WEBSOCK_CONTROL_OPCODE_MASK ) {\n error_setg ( errp , \"websocket control frame is too large\" ) ;\n qio_channel_websock_write_close ( ioc , QIO_CHANNEL_WEBSOCK_STATUS_PROTOCOL_ERR , \"control frame is too large\" ) ;\n return - 1 ;\n }\n else if ( payload_len == QIO_CHANNEL_WEBSOCK_PAYLOAD_LEN_MAGIC_16_BIT && ioc -> encinput . offset >= QIO_CHANNEL_WEBSOCK_HEADER_LEN_16_BIT ) {\n ioc -> payload_remain = be16_to_cpu ( header -> u . s16 . l16 ) ;\n header_size = QIO_CHANNEL_WEBSOCK_HEADER_LEN_16_BIT ;\n ioc -> mask = header -> u . s16 . m16 ;\n }\n else if ( payload_len == QIO_CHANNEL_WEBSOCK_PAYLOAD_LEN_MAGIC_64_BIT && ioc -> encinput . offset >= QIO_CHANNEL_WEBSOCK_HEADER_LEN_64_BIT ) {\n ioc -> payload_remain = be64_to_cpu ( header -> u . s64 . l64 ) ;\n header_size = QIO_CHANNEL_WEBSOCK_HEADER_LEN_64_BIT ;\n ioc -> mask = header -> u . s64 . m64 ;\n }\n else {\n return QIO_CHANNEL_ERR_BLOCK ;\n }\n trace_qio_channel_websock_header_full_decode ( ioc , header_size , ioc -> payload_remain , ioc -> mask . u ) ;\n buffer_advance ( & ioc -> encinput , header_size ) ;\n return 0 ;\n }", "idx": 20985}
{"hash": -3133987110086012192, "project": "chrome", "size": 7, "label": 0, "functionSource": "TEST_F ( SoundContentSettingObserverTest , MutingAudioWhileSoundIsPlayingBlocksSound ) {\n SimulateAudioPlaying ( ) ;\n EXPECT_FALSE ( RecordedSiteMuted ( ) ) ;\n ChangeSoundContentSettingTo ( CONTENT_SETTING_BLOCK ) ;\n EXPECT_TRUE ( RecordedSiteMuted ( ) ) ;\n ExpectRecordedForReason ( SoundContentSettingObserver : : MuteReason : : kSiteException ) ;\n }", "idx": 20986}
{"hash": 355220887711506893, "project": "debian", "size": 53, "label": 1, "functionSource": "static double var_eq_const ( VariableStatData * vardata , Oid operator , Datum constval , bool constisnull , bool varonleft ) {\n double selec ;\n bool isdefault ;\n if ( constisnull ) return 0.0 ;\n if ( vardata -> isunique && vardata -> rel && vardata -> rel -> tuples >= 1.0 ) return 1.0 / vardata -> rel -> tuples ;\n if ( HeapTupleIsValid ( vardata -> statsTuple ) ) {\n Form_pg_statistic stats ;\n Datum * values ;\n int nvalues ;\n float4 * numbers ;\n int nnumbers ;\n bool match = false ;\n int i ;\n stats = ( Form_pg_statistic ) GETSTRUCT ( vardata -> statsTuple ) ;\n if ( get_attstatsslot ( vardata -> statsTuple , vardata -> atttype , vardata -> atttypmod , STATISTIC_KIND_MCV , InvalidOid , NULL , & values , & nvalues , & numbers , & nnumbers ) ) {\n FmgrInfo eqproc ;\n fmgr_info ( get_opcode ( operator ) , & eqproc ) ;\n for ( i = 0 ;\n i < nvalues ;\n i ++ ) {\n if ( varonleft ) match = DatumGetBool ( FunctionCall2Coll ( & eqproc , DEFAULT_COLLATION_OID , values [ i ] , constval ) ) ;\n else match = DatumGetBool ( FunctionCall2Coll ( & eqproc , DEFAULT_COLLATION_OID , constval , values [ i ] ) ) ;\n if ( match ) break ;\n }\n }\n else {\n values = NULL ;\n numbers = NULL ;\n i = nvalues = nnumbers = 0 ;\n }\n if ( match ) {\n selec = numbers [ i ] ;\n }\n else {\n double sumcommon = 0.0 ;\n double otherdistinct ;\n for ( i = 0 ;\n i < nnumbers ;\n i ++ ) sumcommon += numbers [ i ] ;\n selec = 1.0 - sumcommon - stats -> stanullfrac ;\n CLAMP_PROBABILITY ( selec ) ;\n otherdistinct = get_variable_numdistinct ( vardata , & isdefault ) - nnumbers ;\n if ( otherdistinct > 1 ) selec /= otherdistinct ;\n if ( nnumbers > 0 && selec > numbers [ nnumbers - 1 ] ) selec = numbers [ nnumbers - 1 ] ;\n }\n free_attstatsslot ( vardata -> atttype , values , nvalues , numbers , nnumbers ) ;\n }\n else {\n selec = 1.0 / get_variable_numdistinct ( vardata , & isdefault ) ;\n }\n CLAMP_PROBABILITY ( selec ) ;\n return selec ;\n }", "idx": 20987}
{"hash": 1223258652239369123, "project": "debian", "size": 7, "label": 0, "functionSource": "SPL_METHOD ( DirectoryIterator , isDot ) {\n spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n if ( zend_parse_parameters_none ( ) == FAILURE ) {\n return ;\n }\n RETURN_BOOL ( spl_filesystem_is_dot ( intern -> u . dir . entry . d_name ) ) ;\n }", "idx": 20988}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_T_decision ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_T_decision , T_decision_choice , NULL ) ;\n return offset ;\n }", "idx": 20989}
{"hash": 2546373479020365143, "project": "debian", "size": 19, "label": 0, "functionSource": "int mime_hdr_length_get ( MIMEHdrImpl * mh ) {\n unsigned int length , index ;\n MIMEFieldBlockImpl * fblock ;\n MIMEField * field ;\n length = 2 ;\n for ( fblock = & ( mh -> m_first_fblock ) ;\n fblock != nullptr ;\n fblock = fblock -> m_next ) {\n for ( index = 0 ;\n index < fblock -> m_freetop ;\n index ++ ) {\n field = & ( fblock -> m_field_slots [ index ] ) ;\n if ( field -> is_live ( ) ) {\n length += mime_field_length_get ( field ) ;\n }\n }\n }\n return length ;\n }", "idx": 20990}
{"hash": 2830888773500127914, "project": "debian", "size": 7, "label": 0, "functionSource": "void issue_warnings ( void ) {\n if ( GET_MAJOR_VERSION ( old_cluster . major_version ) <= 804 ) {\n start_postmaster ( & new_cluster , true ) ;\n new_9_0_populate_pg_largeobject_metadata ( & new_cluster , false ) ;\n stop_postmaster ( false ) ;\n }\n }", "idx": 20991}
{"hash": 6336384260629386331, "project": "debian", "size": 31, "label": 0, "functionSource": "void proto_register_zbee_zcl_identify ( void ) {\n static hf_register_info hf [ ] = {\n {\n & hf_zbee_zcl_identify_attr_id , {\n \"Attribute\" , \"zbee_zcl_general.identify.attr_id\" , FT_UINT16 , BASE_HEX , VALS ( zbee_zcl_identify_attr_names ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_zbee_zcl_identify_identify_time , {\n \"Identify Time\" , \"zbee_zcl_general.identify.attr.identify_time\" , FT_UINT16 , BASE_CUSTOM , CF_FUNC ( decode_zcl_time_in_seconds ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_zbee_zcl_identify_identify_timeout , {\n \"Identify Timeout\" , \"zbee_zcl_general.identify.identify_timeout\" , FT_UINT16 , BASE_CUSTOM , CF_FUNC ( decode_zcl_time_in_seconds ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_zbee_zcl_identify_srv_rx_cmd_id , {\n \"Command\" , \"zbee_zcl_general.identify.cmd.srv_rx.id\" , FT_UINT8 , BASE_HEX , VALS ( zbee_zcl_identify_srv_rx_cmd_names ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_zbee_zcl_identify_srv_tx_cmd_id , {\n \"Command\" , \"zbee_zcl_general.identify.cmd.srv_tx.id\" , FT_UINT8 , BASE_HEX , VALS ( zbee_zcl_identify_srv_tx_cmd_names ) , 0x00 , NULL , HFILL }\n }\n }\n ;\n static gint * ett [ ZBEE_ZCL_IDENTIFY_NUM_ETT ] ;\n ett [ 0 ] = & ett_zbee_zcl_identify ;\n proto_zbee_zcl_identify = proto_register_protocol ( \"ZigBee ZCL Identify\" , \"ZCL Identify\" , ZBEE_PROTOABBREV_ZCL_IDENTIFY ) ;\n proto_register_field_array ( proto_zbee_zcl_identify , hf , array_length ( hf ) ) ;\n proto_register_subtree_array ( ett , array_length ( ett ) ) ;\n register_dissector ( ZBEE_PROTOABBREV_ZCL_IDENTIFY , dissect_zbee_zcl_identify , proto_zbee_zcl_identify ) ;\n }", "idx": 20992}
{"hash": -7683902591435073306, "project": "debian", "size": 21, "label": 0, "functionSource": "static apr_status_t modsecurity_process_phase_response_body ( modsec_rec * msr ) {\n apr_time_t time_before ;\n apr_status_t rc = 0 ;\n if ( msr -> allow_scope == ACTION_ALLOW ) {\n if ( msr -> txcfg -> debuglog_level >= 4 ) {\n msr_log ( msr , 4 , \"Skipping phase RESPONSE_BODY (allow used).\" ) ;\n }\n return 0 ;\n }\n else {\n if ( msr -> txcfg -> debuglog_level >= 4 ) {\n msr_log ( msr , 4 , \"Starting phase RESPONSE_BODY.\" ) ;\n }\n }\n time_before = apr_time_now ( ) ;\n if ( msr -> txcfg -> ruleset != NULL ) {\n rc = msre_ruleset_process_phase ( msr -> txcfg -> ruleset , msr ) ;\n }\n msr -> time_phase4 = apr_time_now ( ) - time_before ;\n return rc ;\n }", "idx": 20993}
{"hash": -4960438251319819237, "project": "chrome", "size": 5, "label": 1, "functionSource": "static double get_zero_motion_factor ( const FIRSTPASS_STATS * frame ) {\n const double sr_ratio = frame -> coded_error / DOUBLE_DIVIDE_CHECK ( frame -> sr_coded_error ) ;\n const double zero_motion_pct = frame -> pcnt_inter - frame -> pcnt_motion ;\n return MIN ( sr_ratio , zero_motion_pct ) ;\n }", "idx": 20994}
{"hash": -6093401289602790055, "project": "debian", "size": 6, "label": 0, "functionSource": "char * Curl_memdup ( const char * src , size_t length ) {\n char * buffer = malloc ( length ) ;\n if ( ! buffer ) return NULL ;\n memcpy ( buffer , src , length ) ;\n return buffer ;\n }", "idx": 20995}
{"hash": -4432585791636767127, "project": "debian", "size": 30, "label": 0, "functionSource": "krb5_error_code krb5_read_tkt_policy ( krb5_context context , krb5_ldap_context * ldap_context , krb5_db_entry * entries , char * policy ) {\n krb5_error_code st = 0 ;\n int mask = 0 , omask = 0 ;\n int tkt_mask = ( KDB_MAX_LIFE_ATTR | KDB_MAX_RLIFE_ATTR | KDB_TKT_FLAGS_ATTR ) ;\n krb5_ldap_policy_params * tktpoldnparam = NULL ;\n if ( ( st = krb5_get_attributes_mask ( context , entries , & mask ) ) != 0 ) goto cleanup ;\n if ( ( mask & tkt_mask ) == tkt_mask ) goto cleanup ;\n if ( policy != NULL ) {\n st = krb5_ldap_read_policy ( context , policy , & tktpoldnparam , & omask ) ;\n if ( st && st != KRB5_KDB_NOENTRY ) {\n prepend_err_str ( context , _ ( \"Error reading ticket policy. \" ) , st , st ) ;\n goto cleanup ;\n }\n st = 0 ;\n }\n if ( ( mask & KDB_MAX_LIFE_ATTR ) == 0 ) {\n if ( ( omask & KDB_MAX_LIFE_ATTR ) == KDB_MAX_LIFE_ATTR ) entries -> max_life = tktpoldnparam -> maxtktlife ;\n else if ( ldap_context -> lrparams -> max_life ) entries -> max_life = ldap_context -> lrparams -> max_life ;\n }\n if ( ( mask & KDB_MAX_RLIFE_ATTR ) == 0 ) {\n if ( ( omask & KDB_MAX_RLIFE_ATTR ) == KDB_MAX_RLIFE_ATTR ) entries -> max_renewable_life = tktpoldnparam -> maxrenewlife ;\n else if ( ldap_context -> lrparams -> max_renewable_life ) entries -> max_renewable_life = ldap_context -> lrparams -> max_renewable_life ;\n }\n if ( ( mask & KDB_TKT_FLAGS_ATTR ) == 0 ) {\n if ( ( omask & KDB_TKT_FLAGS_ATTR ) == KDB_TKT_FLAGS_ATTR ) entries -> attributes = tktpoldnparam -> tktflags ;\n else if ( ldap_context -> lrparams -> tktflags ) entries -> attributes |= ldap_context -> lrparams -> tktflags ;\n }\n krb5_ldap_free_policy ( context , tktpoldnparam ) ;\n cleanup : return st ;\n }", "idx": 20996}
{"hash": 914926989019402478, "project": "debian", "size": 46, "label": 0, "functionSource": "static void setup_environment ( int argc , char * * argv , int * argc_out , char * * * argv_out , char * * * argv_free , char * * env_free ) {\n int n , i , i0 ;\n char * p , * v = getenv ( \"XDELTA\" ) ;\n if ( v == NULL ) {\n ( * argc_out ) = argc ;\n ( * argv_out ) = argv ;\n ( * argv_free ) = NULL ;\n ( * env_free ) = NULL ;\n return ;\n }\n ( * env_free ) = ( char * ) main_malloc ( ( usize_t ) strlen ( v ) + 1 ) ;\n strcpy ( * env_free , v ) ;\n n = argc + 1 ;\n for ( p = * env_free ;\n * p != 0 ;\n ) {\n if ( * p ++ == ' ' ) {\n n ++ ;\n }\n }\n ( * argv_free ) = ( char * * ) main_malloc ( sizeof ( char * ) * ( n + 1 ) ) ;\n ( * argv_out ) = ( * argv_free ) ;\n ( * argv_out ) [ 0 ] = argv [ 0 ] ;\n ( * argv_out ) [ n ] = NULL ;\n i = 1 ;\n for ( p = * env_free ;\n * p != 0 ;\n ) {\n ( * argv_out ) [ i ++ ] = p ;\n while ( * p != ' ' && * p != 0 ) {\n p ++ ;\n }\n while ( * p == ' ' ) {\n * p ++ = 0 ;\n }\n }\n for ( i0 = 1 ;\n i0 < argc ;\n i0 ++ ) {\n ( * argv_out ) [ i ++ ] = argv [ i0 ] ;\n }\n ( * argc_out ) = i ;\n while ( i <= n ) {\n ( * argv_out ) [ i ++ ] = NULL ;\n }\n }", "idx": 20997}
{"hash": -4421762461659142174, "project": "debian", "size": 7, "label": 0, "functionSource": "static void xps_insert_font ( xps_document * doc , char * name , fz_font * font ) {\n xps_font_cache * cache = fz_malloc_struct ( doc -> ctx , xps_font_cache ) ;\n cache -> name = fz_strdup ( doc -> ctx , name ) ;\n cache -> font = fz_keep_font ( doc -> ctx , font ) ;\n cache -> next = doc -> font_table ;\n doc -> font_table = cache ;\n }", "idx": 20998}
{"hash": 4489017523191997023, "project": "debian", "size": 10, "label": 1, "functionSource": "static int dissect_h225_Information_UUIE ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 399 \"./asn1/h225/h225.cnf\" h225_packet_info * h225_pi ;\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_Information_UUIE , Information_UUIE_sequence ) ;\n # line 403 \"./asn1/h225/h225.cnf\" h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;\n if ( h225_pi != NULL ) {\n h225_pi -> cs_type = H225_INFORMATION ;\n g_snprintf ( h225_pi -> frame_label , 50 , \"%s\" , val_to_str ( h225_pi -> cs_type , T_h323_message_body_vals , \"<unknown>\" ) ) ;\n }\n return offset ;\n }", "idx": 20999}
{"hash": -2807496476613334427, "project": "debian", "size": 43, "label": 0, "functionSource": "bool cephx_build_service_ticket_reply ( CephContext * cct , CryptoKey & principal_secret , vector < CephXSessionAuthInfo > ticket_info_vec , bool should_encrypt_ticket , CryptoKey & ticket_enc_key , bufferlist & reply ) {\n __u8 service_ticket_reply_v = 1 ;\n : : encode ( service_ticket_reply_v , reply ) ;\n uint32_t num = ticket_info_vec . size ( ) ;\n : : encode ( num , reply ) ;\n ldout ( cct , 10 ) << \"build_service_ticket_reply encoding \" << num << \" tickets with secret \" << principal_secret << dendl ;\n for ( vector < CephXSessionAuthInfo > : : iterator ticket_iter = ticket_info_vec . begin ( ) ;\n ticket_iter != ticket_info_vec . end ( ) ;\n ++ ticket_iter ) {\n CephXSessionAuthInfo & info = * ticket_iter ;\n : : encode ( info . service_id , reply ) ;\n __u8 service_ticket_v = 1 ;\n : : encode ( service_ticket_v , reply ) ;\n CephXServiceTicket msg_a ;\n msg_a . session_key = info . session_key ;\n msg_a . validity = info . validity ;\n std : : string error ;\n if ( encode_encrypt ( cct , msg_a , principal_secret , reply , error ) ) {\n ldout ( cct , - 1 ) << \"error encoding encrypted: \" << error << dendl ;\n return false ;\n }\n bufferlist service_ticket_bl ;\n CephXTicketBlob blob ;\n if ( ! cephx_build_service_ticket_blob ( cct , info , blob ) ) {\n return false ;\n }\n : : encode ( blob , service_ticket_bl ) ;\n ldout ( cct , 30 ) << \"service_ticket_blob is \" ;\n service_ticket_bl . hexdump ( * _dout ) ;\n * _dout << dendl ;\n : : encode ( ( __u8 ) should_encrypt_ticket , reply ) ;\n if ( should_encrypt_ticket ) {\n if ( encode_encrypt ( cct , service_ticket_bl , ticket_enc_key , reply , error ) ) {\n ldout ( cct , - 1 ) << \"error encoding encrypted ticket: \" << error << dendl ;\n return false ;\n }\n }\n else {\n : : encode ( service_ticket_bl , reply ) ;\n }\n }\n return true ;\n }", "idx": 21000}
{"hash": -454486177854888036, "project": "debian", "size": 8, "label": 0, "functionSource": "static int rac_get_bits ( RangeCoder * c , int nbits ) {\n int val ;\n c -> range >>= nbits ;\n val = c -> low / c -> range ;\n c -> low -= c -> range * val ;\n if ( c -> range < RAC_BOTTOM ) rac_normalise ( c ) ;\n return val ;\n }", "idx": 21001}
{"hash": 1760449185745615462, "project": "debian", "size": 5, "label": 0, "functionSource": "TSReturnCode TSBase64Decode ( const char * str , size_t str_len , unsigned char * dst , size_t dst_size , size_t * length ) {\n sdk_assert ( sdk_sanity_check_null_ptr ( ( void * ) str ) == TS_SUCCESS ) ;\n sdk_assert ( sdk_sanity_check_null_ptr ( ( void * ) dst ) == TS_SUCCESS ) ;\n return ats_base64_decode ( str , str_len , dst , dst_size , length ) ? TS_SUCCESS : TS_ERROR ;\n }", "idx": 21002}
{"hash": 6632536031698733342, "project": "debian", "size": 9, "label": 0, "functionSource": "static inline int check_section_show_entries ( int section_id ) {\n int * id ;\n struct section * section = & sections [ section_id ] ;\n if ( sections [ section_id ] . show_all_entries || sections [ section_id ] . entries_to_show ) return 1 ;\n for ( id = section -> children_ids ;\n * id != - 1 ;\n id ++ ) if ( check_section_show_entries ( * id ) ) return 1 ;\n return 0 ;\n }", "idx": 21003}
{"hash": 3309252579593081468, "project": "debian", "size": 47, "label": 0, "functionSource": "static int nntp_fetch_lines ( struct NntpData * nntp_data , char * query , size_t qlen , const char * msg , int ( * funct ) ( char * , void * ) , void * data ) {\n int done = false ;\n int rc ;\n while ( ! done ) {\n char buf [ LONG_STRING ] ;\n char * line = NULL ;\n unsigned int lines = 0 ;\n size_t off = 0 ;\n struct Progress progress ;\n if ( msg ) mutt_progress_init ( & progress , msg , MUTT_PROGRESS_MSG , ReadInc , 0 ) ;\n mutt_str_strfcpy ( buf , query , sizeof ( buf ) ) ;\n if ( nntp_query ( nntp_data , buf , sizeof ( buf ) ) < 0 ) return - 1 ;\n if ( buf [ 0 ] != '2' ) {\n mutt_str_strfcpy ( query , buf , qlen ) ;\n return 1 ;\n }\n line = mutt_mem_malloc ( sizeof ( buf ) ) ;\n rc = 0 ;\n while ( true ) {\n char * p = NULL ;\n int chunk = mutt_socket_readln_d ( buf , sizeof ( buf ) , nntp_data -> nserv -> conn , MUTT_SOCK_LOG_HDR ) ;\n if ( chunk < 0 ) {\n nntp_data -> nserv -> status = NNTP_NONE ;\n break ;\n }\n p = buf ;\n if ( ! off && buf [ 0 ] == '.' ) {\n if ( buf [ 1 ] == '\\0' ) {\n done = true ;\n break ;\n }\n if ( buf [ 1 ] == '.' ) p ++ ;\n }\n mutt_str_strfcpy ( line + off , p , sizeof ( buf ) ) ;\n if ( chunk >= sizeof ( buf ) ) off += strlen ( p ) ;\n else {\n if ( msg ) mutt_progress_update ( & progress , ++ lines , - 1 ) ;\n if ( rc == 0 && funct ( line , data ) < 0 ) rc = - 2 ;\n off = 0 ;\n }\n mutt_mem_realloc ( & line , off + sizeof ( buf ) ) ;\n }\n FREE ( & line ) ;\n funct ( NULL , data ) ;\n }\n return rc ;\n }", "idx": 21004}
{"hash": -8933711118846965366, "project": "debian", "size": 10, "label": 0, "functionSource": "static int cirrus_post_load ( void * opaque , int version_id ) {\n CirrusVGAState * s = opaque ;\n s -> vga . gr [ 0x00 ] = s -> cirrus_shadow_gr0 & 0x0f ;\n s -> vga . gr [ 0x01 ] = s -> cirrus_shadow_gr1 & 0x0f ;\n cirrus_update_memory_access ( s ) ;\n s -> vga . graphic_mode = - 1 ;\n cirrus_update_bank_ptr ( s , 0 ) ;\n cirrus_update_bank_ptr ( s , 1 ) ;\n return 0 ;\n }", "idx": 21005}
{"hash": 6323824267898511453, "project": "debian", "size": 3, "label": 0, "functionSource": "void fz_clamp_color ( fz_context * ctx , const fz_colorspace * cs , const float * in , float * out ) {\n cs -> clamp ( cs , in , out ) ;\n }", "idx": 21006}
{"hash": 6667142528452941476, "project": "debian", "size": 4, "label": 0, "functionSource": "static void short_usage ( FILE * f ) {\n short_usage_sub ( f ) ;\n fprintf ( f , \"For more options, use %s --help\\n\" , my_progname_short ) ;\n }", "idx": 21007}
{"hash": -5456913190944844754, "project": "chrome", "size": 20, "label": 0, "functionSource": "TEST_F ( TemplateURLTest , ExtractSearchTermsFromURLPath ) {\n TemplateURLData data ;\n data . SetURL ( \"http://term-in-path.com/begin/{\nsearchTerms}\n/end\" ) ;\n TemplateURL url ( data ) ;\n base : : string16 result ;\n EXPECT_TRUE ( url . ExtractSearchTermsFromURL ( GURL ( \"http://term-in-path.com/begin/something/end\" ) , search_terms_data_ , & result ) ) ;\n EXPECT_EQ ( ASCIIToUTF16 ( \"something\" ) , result ) ;\n EXPECT_TRUE ( url . ExtractSearchTermsFromURL ( GURL ( \"http://term-in-path.com/begin/a%20b%20c/end\" ) , search_terms_data_ , & result ) ) ;\n EXPECT_EQ ( ASCIIToUTF16 ( \"a b c\" ) , result ) ;\n EXPECT_TRUE ( url . ExtractSearchTermsFromURL ( GURL ( \"http://term-in-path.com/begin/1+2+3/end\" ) , search_terms_data_ , & result ) ) ;\n EXPECT_EQ ( ASCIIToUTF16 ( \"1+2+3\" ) , result ) ;\n EXPECT_FALSE ( url . ExtractSearchTermsFromURL ( GURL ( \"http://term-in-path.com/about\" ) , search_terms_data_ , & result ) ) ;\n EXPECT_EQ ( base : : string16 ( ) , result ) ;\n EXPECT_FALSE ( url . ExtractSearchTermsFromURL ( GURL ( \"http://term-in-path.com/begin\" ) , search_terms_data_ , & result ) ) ;\n EXPECT_EQ ( base : : string16 ( ) , result ) ;\n EXPECT_FALSE ( url . ExtractSearchTermsFromURL ( GURL ( \"http://term-in-path.com/end\" ) , search_terms_data_ , & result ) ) ;\n EXPECT_EQ ( base : : string16 ( ) , result ) ;\n }", "idx": 21008}
{"hash": -4555950263653671147, "project": "debian", "size": 4, "label": 0, "functionSource": "static Py_ssize_t string_buffer_getwritebuf ( PyStringObject * self , Py_ssize_t index , const void * * ptr ) {\n PyErr_SetString ( PyExc_TypeError , \"Cannot use string as modifiable buffer\" ) ;\n return - 1 ;\n }", "idx": 21009}
{"hash": -2928324134072492299, "project": "debian", "size": 4, "label": 0, "functionSource": "void remove_tap_listener_sdp_calls ( void ) {\n remove_tap_listener ( & ( the_tapinfo_struct . sdp_dummy ) ) ;\n have_sdp_tap_listener = FALSE ;\n }", "idx": 21010}
{"hash": -6126432314261451839, "project": "debian", "size": 3, "label": 0, "functionSource": "int gs_copypage ( gs_gstate * pgs ) {\n return gs_output_page ( pgs , 1 , 0 ) ;\n }", "idx": 21011}
{"hash": 6675626110148442062, "project": "debian", "size": 17, "label": 0, "functionSource": "long jas_stream_tell ( jas_stream_t * stream ) {\n int adjust ;\n int offset ;\n if ( stream -> bufmode_ & JAS_STREAM_RDBUF ) {\n adjust = - stream -> cnt_ ;\n }\n else if ( stream -> bufmode_ & JAS_STREAM_WRBUF ) {\n adjust = stream -> ptr_ - stream -> bufstart_ ;\n }\n else {\n adjust = 0 ;\n }\n if ( ( offset = ( * stream -> ops_ -> seek_ ) ( stream -> obj_ , 0 , SEEK_CUR ) ) < 0 ) {\n return - 1 ;\n }\n return offset + adjust ;\n }", "idx": 21012}
{"hash": 7092216800726729686, "project": "debian", "size": 25, "label": 0, "functionSource": "static int dissect_h245_RequestMessage ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 367 \"../../asn1/h245/h245.cnf\" gint32 value ;\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_RequestMessage , RequestMessage_choice , & value ) ;\n if ( h245_shorttypes == TRUE ) {\n col_prepend_fstr ( actx -> pinfo -> cinfo , COL_INFO , \"%s \" , val_to_str ( value , h245_RequestMessage_short_vals , \"<unknown>\" ) ) ;\n }\n else {\n col_prepend_fstr ( actx -> pinfo -> cinfo , COL_INFO , \"%s \" , val_to_str ( value , h245_RequestMessage_vals , \"<unknown>\" ) ) ;\n }\n if ( ( codec_type != NULL ) && ( value == RequestMessage_openLogicalChannel ) ) {\n col_append_fstr ( actx -> pinfo -> cinfo , COL_INFO , \"(%s) \" , codec_type ) ;\n }\n col_set_fence ( actx -> pinfo -> cinfo , COL_INFO ) ;\n if ( h245_pi == NULL ) return offset ;\n if ( strlen ( h245_pi -> frame_label ) == 0 ) {\n g_snprintf ( h245_pi -> frame_label , 50 , \"%s\" , val_to_str ( value , h245_RequestMessage_short_vals , \"UKN\" ) ) ;\n if ( ( codec_type != NULL ) && ( ( value == RequestMessage_openLogicalChannel ) || ( value == RequestMessage_requestMode ) ) ) {\n g_strlcat ( h245_pi -> frame_label , \" (\" , 50 ) ;\n g_strlcat ( h245_pi -> frame_label , codec_type , 50 ) ;\n g_strlcat ( h245_pi -> frame_label , \")\" , 50 ) ;\n }\n }\n g_strlcat ( h245_pi -> comment , val_to_str ( value , h245_RequestMessage_vals , \"<unknown>\" ) , 50 ) ;\n return offset ;\n }", "idx": 21013}
{"hash": 4876100961671882393, "project": "debian", "size": 3, "label": 0, "functionSource": "static int dissect_pvfs2_create_response ( tvbuff_t * tvb , proto_tree * tree , int offset , packet_info * pinfo ) {\n return dissect_pvfs_fh ( tvb , offset , pinfo , tree , \"handle\" , NULL ) ;\n }", "idx": 21014}
{"hash": -4979531020783644238, "project": "debian", "size": 3, "label": 0, "functionSource": "static void stop_postmaster_atexit ( void ) {\n stop_postmaster ( true ) ;\n }", "idx": 21015}
{"hash": -7888349587538303571, "project": "debian", "size": 34, "label": 0, "functionSource": "static int rawv6_send_hdrinc ( struct sock * sk , void * from , int length , struct flowi * fl , struct rt6_info * rt , unsigned int flags ) {\n struct ipv6_pinfo * np = inet6_sk ( sk ) ;\n struct ipv6hdr * iph ;\n struct sk_buff * skb ;\n int err ;\n if ( length > rt -> u . dst . dev -> mtu ) {\n ipv6_local_error ( sk , EMSGSIZE , fl , rt -> u . dst . dev -> mtu ) ;\n return - EMSGSIZE ;\n }\n if ( flags & MSG_PROBE ) goto out ;\n skb = sock_alloc_send_skb ( sk , length + LL_ALLOCATED_SPACE ( rt -> u . dst . dev ) + 15 , flags & MSG_DONTWAIT , & err ) ;\n if ( skb == NULL ) goto error ;\n skb_reserve ( skb , LL_RESERVED_SPACE ( rt -> u . dst . dev ) ) ;\n skb -> priority = sk -> sk_priority ;\n skb -> mark = sk -> sk_mark ;\n skb_dst_set ( skb , dst_clone ( & rt -> u . dst ) ) ;\n skb_put ( skb , length ) ;\n skb_reset_network_header ( skb ) ;\n iph = ipv6_hdr ( skb ) ;\n skb -> ip_summed = CHECKSUM_NONE ;\n skb -> transport_header = skb -> network_header ;\n err = memcpy_fromiovecend ( ( void * ) iph , from , 0 , length ) ;\n if ( err ) goto error_fault ;\n IP6_UPD_PO_STATS ( sock_net ( sk ) , rt -> rt6i_idev , IPSTATS_MIB_OUT , skb -> len ) ;\n err = NF_HOOK ( PF_INET6 , NF_INET_LOCAL_OUT , skb , NULL , rt -> u . dst . dev , dst_output ) ;\n if ( err > 0 ) err = net_xmit_errno ( err ) ;\n if ( err ) goto error ;\n out : return 0 ;\n error_fault : err = - EFAULT ;\n kfree_skb ( skb ) ;\n error : IP6_INC_STATS ( sock_net ( sk ) , rt -> rt6i_idev , IPSTATS_MIB_OUTDISCARDS ) ;\n if ( err == - ENOBUFS && ! np -> recverr ) err = 0 ;\n return err ;\n }", "idx": 21016}
{"hash": 1470723493451072803, "project": "debian", "size": 66, "label": 1, "functionSource": "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n VideoXLContext * const a = avctx -> priv_data ;\n AVFrame * const p = & a -> pic ;\n uint8_t * Y , * U , * V ;\n int i , j , ret ;\n int stride ;\n uint32_t val ;\n int y0 , y1 , y2 , y3 = 0 , c0 = 0 , c1 = 0 ;\n if ( p -> data [ 0 ] ) avctx -> release_buffer ( avctx , p ) ;\n p -> reference = 0 ;\n if ( ( ret = ff_get_buffer ( avctx , p ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n p -> pict_type = AV_PICTURE_TYPE_I ;\n p -> key_frame = 1 ;\n Y = a -> pic . data [ 0 ] ;\n U = a -> pic . data [ 1 ] ;\n V = a -> pic . data [ 2 ] ;\n stride = avctx -> width - 4 ;\n if ( buf_size < avctx -> width * avctx -> height ) {\n av_log ( avctx , AV_LOG_ERROR , \"Packet is too small\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n for ( i = 0 ;\n i < avctx -> height ;\n i ++ ) {\n buf += stride ;\n for ( j = 0 ;\n j < avctx -> width ;\n j += 4 ) {\n val = AV_RL32 ( buf ) ;\n buf -= 4 ;\n val = ( ( val >> 16 ) & 0xFFFF ) | ( ( val & 0xFFFF ) << 16 ) ;\n if ( ! j ) y0 = ( val & 0x1F ) << 2 ;\n else y0 = y3 + xl_table [ val & 0x1F ] ;\n val >>= 5 ;\n y1 = y0 + xl_table [ val & 0x1F ] ;\n val >>= 5 ;\n y2 = y1 + xl_table [ val & 0x1F ] ;\n val >>= 6 ;\n y3 = y2 + xl_table [ val & 0x1F ] ;\n val >>= 5 ;\n if ( ! j ) c0 = ( val & 0x1F ) << 2 ;\n else c0 += xl_table [ val & 0x1F ] ;\n val >>= 5 ;\n if ( ! j ) c1 = ( val & 0x1F ) << 2 ;\n else c1 += xl_table [ val & 0x1F ] ;\n Y [ j + 0 ] = y0 << 1 ;\n Y [ j + 1 ] = y1 << 1 ;\n Y [ j + 2 ] = y2 << 1 ;\n Y [ j + 3 ] = y3 << 1 ;\n U [ j >> 2 ] = c0 << 1 ;\n V [ j >> 2 ] = c1 << 1 ;\n }\n buf += avctx -> width + 4 ;\n Y += a -> pic . linesize [ 0 ] ;\n U += a -> pic . linesize [ 1 ] ;\n V += a -> pic . linesize [ 2 ] ;\n }\n * got_frame = 1 ;\n * ( AVFrame * ) data = a -> pic ;\n return buf_size ;\n }", "idx": 21017}
{"hash": 6336384260629386331, "project": "debian", "size": 6, "label": 0, "functionSource": "void proto_reg_handoff_zbee_zcl_appl_ctrl ( void ) {\n dissector_handle_t appl_ctrl_handle ;\n appl_ctrl_handle = find_dissector ( ZBEE_PROTOABBREV_ZCL_APPLCTRL ) ;\n dissector_add_uint ( \"zbee.zcl.cluster\" , ZBEE_ZCL_CID_APPLIANCE_CONTROL , appl_ctrl_handle ) ;\n zbee_zcl_init_cluster ( proto_zbee_zcl_appl_ctrl , ett_zbee_zcl_appl_ctrl , ZBEE_ZCL_CID_APPLIANCE_CONTROL , hf_zbee_zcl_appl_ctrl_attr_id , hf_zbee_zcl_appl_ctrl_srv_rx_cmd_id , hf_zbee_zcl_appl_ctrl_srv_tx_cmd_id , ( zbee_zcl_fn_attr_data ) dissect_zcl_appl_ctrl_attr_data ) ;\n }", "idx": 21018}
{"hash": 914926989019402478, "project": "debian", "size": 5, "label": 0, "functionSource": "void main_file_init ( main_file * xfile ) {\n memset ( xfile , 0 , sizeof ( * xfile ) ) ;\n # if XD3_POSIX xfile -> file = - 1 ;\n # endif # if XD3_WIN32 xfile -> file = INVALID_HANDLE_VALUE ;\n # endif }", "idx": 21019}
{"hash": -9197960073880365676, "project": "debian", "size": 8, "label": 0, "functionSource": "static uint8_t file_byte_getter ( Gif_Reader * grr ) {\n int i = getc ( grr -> f ) ;\n if ( i != EOF ) {\n ++ grr -> pos ;\n return i ;\n }\n else return 0 ;\n }", "idx": 21020}
{"hash": 3599206110384554647, "project": "debian", "size": 73, "label": 1, "functionSource": "static ossl_inline t2 * sk_ ## t1 ## _value ( const STACK_OF ( t1 ) * sk , int idx ) {\n return ( t2 * ) OPENSSL_sk_value ( ( const OPENSSL_STACK * ) sk , idx ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _new ( sk_ ## t1 ## _compfunc compare ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_new ( ( OPENSSL_sk_compfunc ) compare ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _new_null ( void ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_new_null ( ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _new_reserve ( sk_ ## t1 ## _compfunc compare , int n ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_new_reserve ( ( OPENSSL_sk_compfunc ) compare , n ) ;\n }\n static ossl_inline int sk_ ## t1 ## _reserve ( STACK_OF ( t1 ) * sk , int n ) {\n return OPENSSL_sk_reserve ( ( OPENSSL_STACK * ) sk , n ) ;\n }\n static ossl_inline void sk_ ## t1 ## _free ( STACK_OF ( t1 ) * sk ) {\n OPENSSL_sk_free ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline void sk_ ## t1 ## _zero ( STACK_OF ( t1 ) * sk ) {\n OPENSSL_sk_zero ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _delete ( STACK_OF ( t1 ) * sk , int i ) {\n return ( t2 * ) OPENSSL_sk_delete ( ( OPENSSL_STACK * ) sk , i ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _delete_ptr ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return ( t2 * ) OPENSSL_sk_delete_ptr ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _push ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_push ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _unshift ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_unshift ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _pop ( STACK_OF ( t1 ) * sk ) {\n return ( t2 * ) OPENSSL_sk_pop ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _shift ( STACK_OF ( t1 ) * sk ) {\n return ( t2 * ) OPENSSL_sk_shift ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline void sk_ ## t1 ## _pop_free ( STACK_OF ( t1 ) * sk , sk_ ## t1 ## _freefunc freefunc ) {\n OPENSSL_sk_pop_free ( ( OPENSSL_STACK * ) sk , ( OPENSSL_sk_freefunc ) freefunc ) ;\n }\n static ossl_inline int sk_ ## t1 ## _insert ( STACK_OF ( t1 ) * sk , t2 * ptr , int idx ) {\n return OPENSSL_sk_insert ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr , idx ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _set ( STACK_OF ( t1 ) * sk , int idx , t2 * ptr ) {\n return ( t2 * ) OPENSSL_sk_set ( ( OPENSSL_STACK * ) sk , idx , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _find ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_find ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _find_ex ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_find_ex ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline void sk_ ## t1 ## _sort ( STACK_OF ( t1 ) * sk ) {\n OPENSSL_sk_sort ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline int sk_ ## t1 ## _is_sorted ( const STACK_OF ( t1 ) * sk ) {\n return OPENSSL_sk_is_sorted ( ( const OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _dup ( const STACK_OF ( t1 ) * sk ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_dup ( ( const OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _deep_copy ( const STACK_OF ( t1 ) * sk , sk_ ## t1 ## _copyfunc copyfunc , sk_ ## t1 ## _freefunc freefunc ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_deep_copy ( ( const OPENSSL_STACK * ) sk , ( OPENSSL_sk_copyfunc ) copyfunc , ( OPENSSL_sk_freefunc ) freefunc ) ;\n }\n static ossl_inline sk_ ## t1 ## _compfunc sk_ ## t1 ## _set_cmp_func ( STACK_OF ( t1 ) * sk , sk_ ## t1 ## _compfunc compare ) {\n return ( sk_ ## t1 ## _compfunc ) OPENSSL_sk_set_cmp_func ( ( OPENSSL_STACK * ) sk , ( OPENSSL_sk_compfunc ) compare ) ;\n }\n # define DEFINE_SPECIAL_STACK_OF ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , t2 , t2 ) # define DEFINE_STACK_OF ( t ) SKM_DEFINE_STACK_OF ( t , t , t ) # define DEFINE_SPECIAL_STACK_OF_CONST ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , const t2 , t2 ) # define DEFINE_STACK_OF_CONST ( t ) SKM_DEFINE_STACK_OF ( t , const t , t ) typedef char * OPENSSL_STRING ;\n typedef const char * OPENSSL_CSTRING ;\n DEFINE_SPECIAL_STACK_OF ( OPENSSL_STRING , char ) DEFINE_SPECIAL_STACK_OF_CONST ( OPENSSL_CSTRING , char ) typedef void * OPENSSL_BLOCK ;\n DEFINE_SPECIAL_STACK_OF ( OPENSSL_BLOCK , void )", "idx": 21021}
{"hash": 5829728328403223446, "project": "chrome", "size": 31, "label": 0, "functionSource": "static int temporal_filter_find_matching_mb_c ( VP9_COMP * cpi , uint8_t * arf_frame_buf , uint8_t * frame_ptr_buf , int stride ) {\n MACROBLOCK * const x = & cpi -> mb ;\n MACROBLOCKD * const xd = & x -> e_mbd ;\n const MV_SPEED_FEATURES * const mv_sf = & cpi -> sf . mv ;\n int step_param ;\n int sadpb = x -> sadperbit16 ;\n int bestsme = INT_MAX ;\n int distortion ;\n unsigned int sse ;\n int sad_list [ 5 ] ;\n MV best_ref_mv1 = {\n 0 , 0 }\n ;\n MV best_ref_mv1_full ;\n MV * ref_mv = & x -> e_mbd . mi [ 0 ] . src_mi -> bmi [ 0 ] . as_mv [ 0 ] . as_mv ;\n struct buf_2d src = x -> plane [ 0 ] . src ;\n struct buf_2d pre = xd -> plane [ 0 ] . pre [ 0 ] ;\n best_ref_mv1_full . col = best_ref_mv1 . col >> 3 ;\n best_ref_mv1_full . row = best_ref_mv1 . row >> 3 ;\n x -> plane [ 0 ] . src . buf = arf_frame_buf ;\n x -> plane [ 0 ] . src . stride = stride ;\n xd -> plane [ 0 ] . pre [ 0 ] . buf = frame_ptr_buf ;\n xd -> plane [ 0 ] . pre [ 0 ] . stride = stride ;\n step_param = mv_sf -> reduce_first_step_size ;\n step_param = MIN ( step_param , MAX_MVSEARCH_STEPS - 2 ) ;\n vp9_hex_search ( x , & best_ref_mv1_full , step_param , sadpb , 1 , cond_sad_list ( cpi , sad_list ) , & cpi -> fn_ptr [ BLOCK_16X16 ] , 0 , & best_ref_mv1 , ref_mv ) ;\n bestsme = cpi -> find_fractional_mv_step ( x , ref_mv , & best_ref_mv1 , cpi -> common . allow_high_precision_mv , x -> errorperbit , & cpi -> fn_ptr [ BLOCK_16X16 ] , 0 , mv_sf -> subpel_iters_per_step , cond_sad_list ( cpi , sad_list ) , NULL , NULL , & distortion , & sse , NULL , 0 , 0 ) ;\n x -> plane [ 0 ] . src = src ;\n xd -> plane [ 0 ] . pre [ 0 ] = pre ;\n return bestsme ;\n }", "idx": 21022}
{"hash": -8028756826159773630, "project": "debian", "size": 64, "label": 0, "functionSource": "void PrintTOCSummary ( Archive * AHX ) {\n ArchiveHandle * AH = ( ArchiveHandle * ) AHX ;\n RestoreOptions * ropt = AH -> public . ropt ;\n TocEntry * te ;\n teSection curSection ;\n OutputContext sav ;\n const char * fmtName ;\n char stamp_str [ 64 ] ;\n sav = SaveOutput ( AH ) ;\n if ( ropt -> filename ) SetOutput ( AH , ropt -> filename , 0 ) ;\n if ( strftime ( stamp_str , sizeof ( stamp_str ) , PGDUMP_STRFTIME_FMT , localtime ( & AH -> createDate ) ) == 0 ) strcpy ( stamp_str , \"[unknown]\" ) ;\n ahprintf ( AH , \";\n\\n;\n Archive created at %s\\n\" , stamp_str ) ;\n ahprintf ( AH , \";\n dbname: %s\\n;\n TOC Entries: %d\\n;\n Compression: %d\\n\" , AH -> archdbname , AH -> tocCount , AH -> compression ) ;\n switch ( AH -> format ) {\n case archCustom : fmtName = \"CUSTOM\" ;\n break ;\n case archDirectory : fmtName = \"DIRECTORY\" ;\n break ;\n case archTar : fmtName = \"TAR\" ;\n break ;\n default : fmtName = \"UNKNOWN\" ;\n }\n ahprintf ( AH , \";\n Dump Version: %d.%d-%d\\n\" , AH -> vmaj , AH -> vmin , AH -> vrev ) ;\n ahprintf ( AH , \";\n Format: %s\\n\" , fmtName ) ;\n ahprintf ( AH , \";\n Integer: %d bytes\\n\" , ( int ) AH -> intSize ) ;\n ahprintf ( AH , \";\n Offset: %d bytes\\n\" , ( int ) AH -> offSize ) ;\n if ( AH -> archiveRemoteVersion ) ahprintf ( AH , \";\n Dumped from database version: %s\\n\" , AH -> archiveRemoteVersion ) ;\n if ( AH -> archiveDumpVersion ) ahprintf ( AH , \";\n Dumped by pg_dump version: %s\\n\" , AH -> archiveDumpVersion ) ;\n ahprintf ( AH , \";\n\\n;\n\\n;\n Selected TOC Entries:\\n;\n\\n\" ) ;\n curSection = SECTION_PRE_DATA ;\n for ( te = AH -> toc -> next ;\n te != AH -> toc ;\n te = te -> next ) {\n if ( te -> section != SECTION_NONE ) curSection = te -> section ;\n if ( ropt -> verbose || ( _tocEntryRequired ( te , curSection , ropt ) & ( REQ_SCHEMA | REQ_DATA ) ) != 0 ) ahprintf ( AH , \"%d;\n %u %u %s %s %s %s\\n\" , te -> dumpId , te -> catalogId . tableoid , te -> catalogId . oid , te -> desc , te -> namespace ? te -> namespace : \"-\" , te -> tag , te -> owner ) ;\n if ( ropt -> verbose && te -> nDeps > 0 ) {\n int i ;\n ahprintf ( AH , \";\n\\tdepends on:\" ) ;\n for ( i = 0 ;\n i < te -> nDeps ;\n i ++ ) ahprintf ( AH , \" %d\" , te -> dependencies [ i ] ) ;\n ahprintf ( AH , \"\\n\" ) ;\n }\n }\n if ( ropt -> strict_names ) StrictNamesCheck ( ropt ) ;\n if ( ropt -> filename ) RestoreOutput ( AH , sav ) ;\n }", "idx": 21023}
{"hash": 8952659721822029396, "project": "debian", "size": 37, "label": 1, "functionSource": "static int dvvideo_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n DVVideoContext * s = avctx -> priv_data ;\n const uint8_t * vsc_pack ;\n int apt , is16_9 ;\n s -> sys = avpriv_dv_frame_profile ( s -> sys , buf , buf_size ) ;\n if ( ! s -> sys || buf_size < s -> sys -> frame_size || ff_dv_init_dynamic_tables ( s -> sys ) ) {\n av_log ( avctx , AV_LOG_ERROR , \"could not find dv frame profile\\n\" ) ;\n return - 1 ;\n }\n if ( s -> picture . data [ 0 ] ) avctx -> release_buffer ( avctx , & s -> picture ) ;\n s -> picture . reference = 0 ;\n s -> picture . key_frame = 1 ;\n s -> picture . pict_type = AV_PICTURE_TYPE_I ;\n avctx -> pix_fmt = s -> sys -> pix_fmt ;\n avctx -> time_base = s -> sys -> time_base ;\n avcodec_set_dimensions ( avctx , s -> sys -> width , s -> sys -> height ) ;\n if ( ff_get_buffer ( avctx , & s -> picture ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return - 1 ;\n }\n s -> picture . interlaced_frame = 1 ;\n s -> picture . top_field_first = 0 ;\n s -> buf = buf ;\n avctx -> execute ( avctx , dv_decode_video_segment , s -> sys -> work_chunks , NULL , dv_work_pool_size ( s -> sys ) , sizeof ( DVwork_chunk ) ) ;\n emms_c ( ) ;\n * got_frame = 1 ;\n * ( AVFrame * ) data = s -> picture ;\n vsc_pack = buf + 80 * 5 + 48 + 5 ;\n if ( * vsc_pack == dv_video_control ) {\n apt = buf [ 4 ] & 0x07 ;\n is16_9 = ( vsc_pack && ( ( vsc_pack [ 2 ] & 0x07 ) == 0x02 || ( ! apt && ( vsc_pack [ 2 ] & 0x07 ) == 0x07 ) ) ) ;\n avctx -> sample_aspect_ratio = s -> sys -> sar [ is16_9 ] ;\n }\n return s -> sys -> frame_size ;\n }", "idx": 21024}
{"hash": 3668456668028959955, "project": "debian", "size": 3, "label": 0, "functionSource": "static void generate_json_true ( FBuffer * buffer , VALUE Vstate , JSON_Generator_State * state , VALUE obj ) {\n fbuffer_append ( buffer , \"true\" , 4 ) ;\n }", "idx": 21025}
{"hash": 6675626110148442062, "project": "debian", "size": 4, "label": 0, "functionSource": "static int file_read ( jas_stream_obj_t * obj , char * buf , int cnt ) {\n jas_stream_fileobj_t * fileobj = JAS_CAST ( jas_stream_fileobj_t * , obj ) ;\n return read ( fileobj -> fd , buf , cnt ) ;\n }", "idx": 21026}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_G7231AnnexCCapability ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_G7231AnnexCCapability , G7231AnnexCCapability_sequence ) ;\n return offset ;\n }", "idx": 21027}
{"hash": 7651945086108393719, "project": "debian", "size": 11, "label": 0, "functionSource": "int qemuMonitorJSONSetCapabilities ( qemuMonitorPtr mon ) {\n int ret ;\n virJSONValuePtr cmd = qemuMonitorJSONMakeCommand ( \"qmp_capabilities\" , NULL ) ;\n virJSONValuePtr reply = NULL ;\n if ( ! cmd ) return - 1 ;\n ret = qemuMonitorJSONCommand ( mon , cmd , & reply ) ;\n if ( ret == 0 ) ret = qemuMonitorJSONCheckError ( cmd , reply ) ;\n virJSONValueFree ( cmd ) ;\n virJSONValueFree ( reply ) ;\n return ret ;\n }", "idx": 21028}
{"hash": -3502382902740740634, "project": "debian", "size": 197, "label": 0, "functionSource": "static int dictionary_load ( void ) {\n ddict_t * d ;\n ddict_application_t * p ;\n ddict_vendor_t * v ;\n ddict_cmd_t * c ;\n ddict_typedefn_t * t ;\n ddict_avp_t * a ;\n gboolean do_debug_parser = getenv ( \"WIRESHARK_DEBUG_DIAM_DICT_PARSER\" ) ? TRUE : FALSE ;\n gboolean do_dump_dict = getenv ( \"WIRESHARK_DUMP_DIAM_DICT\" ) ? TRUE : FALSE ;\n char * dir ;\n const avp_type_t * type ;\n const avp_type_t * octetstring = & basic_types [ 0 ] ;\n diam_avp_t * avp ;\n GHashTable * vendors = g_hash_table_new ( strcase_hash , strcase_equal ) ;\n diam_vnd_t * vnd ;\n GArray * vnd_shrt_arr = g_array_new ( TRUE , TRUE , sizeof ( value_string ) ) ;\n build_dict . hf = wmem_array_new ( wmem_epan_scope ( ) , sizeof ( hf_register_info ) ) ;\n build_dict . ett = g_ptr_array_new ( ) ;\n build_dict . types = g_hash_table_new ( strcase_hash , strcase_equal ) ;\n build_dict . avps = g_hash_table_new ( strcase_hash , strcase_equal ) ;\n dictionary . vnds = wmem_tree_new ( wmem_epan_scope ( ) ) ;\n dictionary . avps = wmem_tree_new ( wmem_epan_scope ( ) ) ;\n unknown_vendor . vs_cmds = g_array_new ( TRUE , TRUE , sizeof ( value_string ) ) ;\n unknown_vendor . vs_avps = g_array_new ( TRUE , TRUE , sizeof ( value_string ) ) ;\n no_vnd . vs_cmds = g_array_new ( TRUE , TRUE , sizeof ( value_string ) ) ;\n no_vnd . vs_avps = g_array_new ( TRUE , TRUE , sizeof ( value_string ) ) ;\n all_cmds = g_array_new ( TRUE , TRUE , sizeof ( value_string ) ) ;\n wmem_tree_insert32 ( dictionary . vnds , 0 , & no_vnd ) ;\n g_hash_table_insert ( vendors , ( gchar * ) \"None\" , & no_vnd ) ;\n for ( type = basic_types ;\n type -> name ;\n type ++ ) {\n g_hash_table_insert ( build_dict . types , ( gchar * ) type -> name , ( void * ) type ) ;\n }\n dir = g_strdup_printf ( \"%s\" G_DIR_SEPARATOR_S \"diameter\" G_DIR_SEPARATOR_S , get_datafile_dir ( ) ) ;\n d = ddict_scan ( dir , \"dictionary.xml\" , do_debug_parser ) ;\n g_free ( dir ) ;\n if ( d == NULL ) {\n g_hash_table_destroy ( vendors ) ;\n g_array_free ( vnd_shrt_arr , TRUE ) ;\n return 0 ;\n }\n if ( do_dump_dict ) ddict_print ( stdout , d ) ;\n for ( t = d -> typedefns ;\n t ;\n t = t -> next ) {\n const avp_type_t * parent = NULL ;\n if ( t -> name == NULL ) {\n report_failure ( \"Diameter Dictionary: Invalid Type (empty name): parent==%s\\n\" , t -> parent ? t -> parent : \"(null)\" ) ;\n continue ;\n }\n if ( g_hash_table_lookup ( build_dict . types , t -> name ) ) continue ;\n if ( t -> parent ) {\n parent = ( avp_type_t * ) g_hash_table_lookup ( build_dict . types , t -> parent ) ;\n }\n if ( ! parent ) parent = octetstring ;\n g_hash_table_insert ( build_dict . types , t -> name , ( void * ) parent ) ;\n }\n if ( ( p = d -> applications ) ) {\n wmem_array_t * arr = wmem_array_new ( wmem_epan_scope ( ) , sizeof ( value_string ) ) ;\n value_string term [ 1 ] ;\n term [ 0 ] . value = 0 ;\n term [ 0 ] . strptr = NULL ;\n for ( ;\n p ;\n p = p -> next ) {\n value_string item [ 1 ] ;\n item [ 0 ] . value = p -> code ;\n item [ 0 ] . strptr = p -> name ;\n if ( ! p -> name ) {\n report_failure ( \"Diameter Dictionary: Invalid Application (empty name): id=%d\\n\" , p -> code ) ;\n continue ;\n }\n wmem_array_append_one ( arr , item ) ;\n }\n wmem_array_sort ( arr , compare_avps ) ;\n wmem_array_append_one ( arr , term ) ;\n dictionary . applications = value_string_ext_new ( ( value_string * ) wmem_array_get_raw ( arr ) , wmem_array_get_count ( arr ) , wmem_strdup_printf ( wmem_epan_scope ( ) , \"applications_vals_ext\" ) ) ;\n }\n if ( ( v = d -> vendors ) ) {\n for ( ;\n v ;\n v = v -> next ) {\n value_string item [ 1 ] ;\n item [ 0 ] . value = v -> code ;\n item [ 0 ] . strptr = v -> name ;\n if ( v -> name == NULL ) {\n report_failure ( \"Diameter Dictionary: Invalid Vendor (empty name): code==%d\\n\" , v -> code ) ;\n continue ;\n }\n if ( g_hash_table_lookup ( vendors , v -> name ) ) continue ;\n g_array_append_val ( vnd_shrt_arr , item ) ;\n vnd = wmem_new ( wmem_epan_scope ( ) , diam_vnd_t ) ;\n vnd -> code = v -> code ;\n vnd -> vs_cmds = g_array_new ( TRUE , TRUE , sizeof ( value_string ) ) ;\n vnd -> vs_avps = g_array_new ( TRUE , TRUE , sizeof ( value_string ) ) ;\n vnd -> vs_avps_ext = NULL ;\n wmem_tree_insert32 ( dictionary . vnds , vnd -> code , vnd ) ;\n g_hash_table_insert ( vendors , v -> name , vnd ) ;\n }\n }\n vnd_short_vs = ( value_string * ) vnd_shrt_arr -> data ;\n g_array_free ( vnd_shrt_arr , FALSE ) ;\n if ( ( c = d -> cmds ) ) {\n for ( ;\n c ;\n c = c -> next ) {\n if ( c -> vendor == NULL ) {\n report_failure ( \"Diameter Dictionary: Invalid Vendor (empty name) for command %s\\n\" , c -> name ? c -> name : \"(null)\" ) ;\n continue ;\n }\n if ( ( vnd = ( diam_vnd_t * ) g_hash_table_lookup ( vendors , c -> vendor ) ) ) {\n value_string item [ 1 ] ;\n item [ 0 ] . value = c -> code ;\n item [ 0 ] . strptr = c -> name ;\n g_array_append_val ( vnd -> vs_cmds , item ) ;\n g_array_append_val ( all_cmds , item ) ;\n }\n else {\n report_failure ( \"Diameter Dictionary: No Vendor: %s\\n\" , c -> vendor ) ;\n }\n }\n }\n for ( a = d -> avps ;\n a ;\n a = a -> next ) {\n ddict_enum_t * e ;\n value_string * vs = NULL ;\n const char * vend = a -> vendor ? a -> vendor : \"None\" ;\n ddict_xmlpi_t * x ;\n void * avp_data = NULL ;\n if ( a -> name == NULL ) {\n report_failure ( \"Diameter Dictionary: Invalid AVP (empty name)\\n\" ) ;\n continue ;\n }\n if ( ( vnd = ( diam_vnd_t * ) g_hash_table_lookup ( vendors , vend ) ) ) {\n value_string vndvs [ 1 ] ;\n vndvs [ 0 ] . value = a -> code ;\n vndvs [ 0 ] . strptr = a -> name ;\n g_array_append_val ( vnd -> vs_avps , vndvs ) ;\n }\n else {\n report_failure ( \"Diameter Dictionary: No Vendor: %s\\n\" , vend ) ;\n vnd = & unknown_vendor ;\n }\n if ( ( e = a -> enums ) ) {\n wmem_array_t * arr = wmem_array_new ( wmem_epan_scope ( ) , sizeof ( value_string ) ) ;\n value_string term [ 1 ] ;\n term [ 0 ] . value = 0 ;\n term [ 0 ] . strptr = NULL ;\n for ( ;\n e ;\n e = e -> next ) {\n value_string item [ 1 ] ;\n item [ 0 ] . value = e -> code ;\n item [ 0 ] . strptr = e -> name ;\n wmem_array_append_one ( arr , item ) ;\n }\n wmem_array_sort ( arr , compare_avps ) ;\n wmem_array_append_one ( arr , term ) ;\n vs = ( value_string * ) wmem_array_get_raw ( arr ) ;\n }\n type = NULL ;\n for ( x = d -> xmlpis ;\n x ;\n x = x -> next ) {\n if ( ( strcase_equal ( x -> name , \"avp-proto\" ) && strcase_equal ( x -> key , a -> name ) ) || ( a -> type && strcase_equal ( x -> name , \"type-proto\" ) && strcase_equal ( x -> key , a -> type ) ) ) {\n static avp_type_t proto_type = {\n \"proto\" , proto_avp , proto_avp , FT_UINT32 , BASE_HEX , build_proto_avp }\n ;\n type = & proto_type ;\n avp_data = x -> value ;\n break ;\n }\n }\n if ( ( ! type ) && a -> type ) type = ( avp_type_t * ) g_hash_table_lookup ( build_dict . types , a -> type ) ;\n if ( ! type ) type = octetstring ;\n avp = type -> build ( type , a -> code , vnd , a -> name , vs , avp_data ) ;\n if ( avp != NULL ) {\n g_hash_table_insert ( build_dict . avps , a -> name , avp ) ;\n {\n wmem_tree_key_t k [ 3 ] ;\n k [ 0 ] . length = 1 ;\n k [ 0 ] . key = & ( a -> code ) ;\n k [ 1 ] . length = 1 ;\n k [ 1 ] . key = & ( vnd -> code ) ;\n k [ 2 ] . length = 0 ;\n k [ 2 ] . key = NULL ;\n wmem_tree_insert32_array ( dictionary . avps , k , avp ) ;\n }\n }\n }\n g_hash_table_destroy ( build_dict . types ) ;\n g_hash_table_destroy ( build_dict . avps ) ;\n g_hash_table_destroy ( vendors ) ;\n return 1 ;\n }", "idx": 21029}
{"hash": 5575425611513297119, "project": "debian", "size": 41, "label": 0, "functionSource": "static int dtls1_process_out_of_seq_message ( SSL * s , const struct hm_header_st * msg_hdr , int * ok ) {\n int i = - 1 ;\n hm_fragment * frag = NULL ;\n pitem * item = NULL ;\n unsigned char seq64be [ 8 ] ;\n unsigned long frag_len = msg_hdr -> frag_len ;\n if ( ( msg_hdr -> frag_off + frag_len ) > msg_hdr -> msg_len ) goto err ;\n memset ( seq64be , 0 , sizeof ( seq64be ) ) ;\n seq64be [ 6 ] = ( unsigned char ) ( msg_hdr -> seq >> 8 ) ;\n seq64be [ 7 ] = ( unsigned char ) msg_hdr -> seq ;\n item = pqueue_find ( s -> d1 -> buffered_messages , seq64be ) ;\n if ( item != NULL && frag_len != msg_hdr -> msg_len ) item = NULL ;\n if ( msg_hdr -> seq <= s -> d1 -> handshake_read_seq || msg_hdr -> seq > s -> d1 -> handshake_read_seq + 10 || item != NULL || ( s -> d1 -> handshake_read_seq == 0 && msg_hdr -> type == SSL3_MT_FINISHED ) ) {\n unsigned char devnull [ 256 ] ;\n while ( frag_len ) {\n i = s -> method -> ssl_read_bytes ( s , SSL3_RT_HANDSHAKE , NULL , devnull , frag_len > sizeof ( devnull ) ? sizeof ( devnull ) : frag_len , 0 ) ;\n if ( i <= 0 ) goto err ;\n frag_len -= i ;\n }\n }\n else {\n if ( frag_len != msg_hdr -> msg_len ) return dtls1_reassemble_fragment ( s , msg_hdr , ok ) ;\n if ( frag_len > dtls1_max_handshake_message_len ( s ) ) goto err ;\n frag = dtls1_hm_fragment_new ( frag_len , 0 ) ;\n if ( frag == NULL ) goto err ;\n memcpy ( & ( frag -> msg_header ) , msg_hdr , sizeof ( * msg_hdr ) ) ;\n if ( frag_len ) {\n i = s -> method -> ssl_read_bytes ( s , SSL3_RT_HANDSHAKE , NULL , frag -> fragment , frag_len , 0 ) ;\n if ( ( unsigned long ) i != frag_len ) i = - 1 ;\n if ( i <= 0 ) goto err ;\n }\n item = pitem_new ( seq64be , frag ) ;\n if ( item == NULL ) goto err ;\n item = pqueue_insert ( s -> d1 -> buffered_messages , item ) ;\n OPENSSL_assert ( item != NULL ) ;\n }\n return DTLS1_HM_FRAGMENT_RETRY ;\n err : if ( item == NULL ) dtls1_hm_fragment_free ( frag ) ;\n * ok = 0 ;\n return i ;\n }", "idx": 21030}
{"hash": 1286774465219423144, "project": "debian", "size": 124, "label": 1, "functionSource": "static int jbig2_decode_mmr_line ( Jbig2MmrCtx * mmr , const byte * ref , byte * dst ) {\n int a0 = - 1 ;\n int a1 , a2 , b1 , b2 ;\n int c = 0 ;\n while ( 1 ) {\n uint32_t word = mmr -> word ;\n if ( a0 >= mmr -> width ) break ;\n if ( ( word >> ( 32 - 3 ) ) == 1 ) {\n int white_run , black_run ;\n jbig2_decode_mmr_consume ( mmr , 3 ) ;\n if ( a0 == - 1 ) a0 = 0 ;\n if ( c == 0 ) {\n white_run = jbig2_decode_get_run ( mmr , jbig2_mmr_white_decode , 8 ) ;\n black_run = jbig2_decode_get_run ( mmr , jbig2_mmr_black_decode , 7 ) ;\n a1 = a0 + white_run ;\n a2 = a1 + black_run ;\n if ( a1 > mmr -> width ) a1 = mmr -> width ;\n if ( a2 > mmr -> width ) a2 = mmr -> width ;\n if ( a2 < a1 || a1 < 0 ) return - 1 ;\n jbig2_set_bits ( dst , a1 , a2 ) ;\n a0 = a2 ;\n }\n else {\n black_run = jbig2_decode_get_run ( mmr , jbig2_mmr_black_decode , 7 ) ;\n white_run = jbig2_decode_get_run ( mmr , jbig2_mmr_white_decode , 8 ) ;\n a1 = a0 + black_run ;\n a2 = a1 + white_run ;\n if ( a1 > mmr -> width ) a1 = mmr -> width ;\n if ( a2 > mmr -> width ) a2 = mmr -> width ;\n if ( a1 < a0 || a0 < 0 ) return - 1 ;\n jbig2_set_bits ( dst , a0 , a1 ) ;\n a0 = a2 ;\n }\n }\n else if ( ( word >> ( 32 - 4 ) ) == 1 ) {\n jbig2_decode_mmr_consume ( mmr , 4 ) ;\n b1 = jbig2_find_changing_element_of_color ( ref , a0 , mmr -> width , ! c ) ;\n b2 = jbig2_find_changing_element ( ref , b1 , mmr -> width ) ;\n if ( c ) {\n if ( b2 < a0 || a0 < 0 ) return - 1 ;\n jbig2_set_bits ( dst , a0 , b2 ) ;\n }\n a0 = b2 ;\n }\n else if ( ( word >> ( 32 - 1 ) ) == 1 ) {\n jbig2_decode_mmr_consume ( mmr , 1 ) ;\n b1 = jbig2_find_changing_element_of_color ( ref , a0 , mmr -> width , ! c ) ;\n if ( c ) {\n if ( b1 < a0 || a0 < 0 ) return - 1 ;\n jbig2_set_bits ( dst , a0 , b1 ) ;\n }\n a0 = b1 ;\n c = ! c ;\n }\n else if ( ( word >> ( 32 - 3 ) ) == 3 ) {\n jbig2_decode_mmr_consume ( mmr , 3 ) ;\n b1 = jbig2_find_changing_element_of_color ( ref , a0 , mmr -> width , ! c ) ;\n if ( b1 + 1 > mmr -> width ) break ;\n if ( c ) {\n if ( b1 + 1 < a0 || a0 < 0 ) return - 1 ;\n jbig2_set_bits ( dst , a0 , b1 + 1 ) ;\n }\n a0 = b1 + 1 ;\n c = ! c ;\n }\n else if ( ( word >> ( 32 - 6 ) ) == 3 ) {\n jbig2_decode_mmr_consume ( mmr , 6 ) ;\n b1 = jbig2_find_changing_element_of_color ( ref , a0 , mmr -> width , ! c ) ;\n if ( b1 + 2 > mmr -> width ) break ;\n if ( c ) {\n if ( b1 + 2 < a0 || a0 < 0 ) return - 1 ;\n jbig2_set_bits ( dst , a0 , b1 + 2 ) ;\n }\n a0 = b1 + 2 ;\n c = ! c ;\n }\n else if ( ( word >> ( 32 - 7 ) ) == 3 ) {\n jbig2_decode_mmr_consume ( mmr , 7 ) ;\n b1 = jbig2_find_changing_element_of_color ( ref , a0 , mmr -> width , ! c ) ;\n if ( b1 + 3 > mmr -> width ) break ;\n if ( c ) {\n if ( b1 + 3 < a0 || a0 < 0 ) return - 1 ;\n jbig2_set_bits ( dst , a0 , b1 + 3 ) ;\n }\n a0 = b1 + 3 ;\n c = ! c ;\n }\n else if ( ( word >> ( 32 - 3 ) ) == 2 ) {\n jbig2_decode_mmr_consume ( mmr , 3 ) ;\n b1 = jbig2_find_changing_element_of_color ( ref , a0 , mmr -> width , ! c ) ;\n if ( b1 - 1 < 0 ) break ;\n if ( c ) {\n if ( b1 - 1 < a0 || a0 < 0 ) return - 1 ;\n jbig2_set_bits ( dst , a0 , b1 - 1 ) ;\n }\n a0 = b1 - 1 ;\n c = ! c ;\n }\n else if ( ( word >> ( 32 - 6 ) ) == 2 ) {\n jbig2_decode_mmr_consume ( mmr , 6 ) ;\n b1 = jbig2_find_changing_element_of_color ( ref , a0 , mmr -> width , ! c ) ;\n if ( b1 - 2 < 0 ) break ;\n if ( c ) {\n if ( b1 - 2 < a0 || a0 < 0 ) return - 1 ;\n jbig2_set_bits ( dst , a0 , b1 - 2 ) ;\n }\n a0 = b1 - 2 ;\n c = ! c ;\n }\n else if ( ( word >> ( 32 - 7 ) ) == 2 ) {\n jbig2_decode_mmr_consume ( mmr , 7 ) ;\n b1 = jbig2_find_changing_element_of_color ( ref , a0 , mmr -> width , ! c ) ;\n if ( b1 - 3 < 0 ) break ;\n if ( c ) {\n if ( b1 - 3 < a0 || a0 < 0 ) return - 1 ;\n jbig2_set_bits ( dst , a0 , b1 - 3 ) ;\n }\n a0 = b1 - 3 ;\n c = ! c ;\n }\n else break ;\n }\n return 0 ;\n }", "idx": 21031}
{"hash": 6458694302493204858, "project": "debian", "size": 25, "label": 0, "functionSource": "static Datum ExecEvalNullIf ( FuncExprState * nullIfExpr , ExprContext * econtext , bool * isNull , ExprDoneCond * isDone ) {\n Datum result ;\n FunctionCallInfo fcinfo ;\n ExprDoneCond argDone ;\n if ( isDone ) * isDone = ExprSingleResult ;\n if ( nullIfExpr -> func . fn_oid == InvalidOid ) {\n NullIfExpr * op = ( NullIfExpr * ) nullIfExpr -> xprstate . expr ;\n init_fcache ( op -> opfuncid , op -> inputcollid , nullIfExpr , econtext -> ecxt_per_query_memory , true ) ;\n Assert ( ! nullIfExpr -> func . fn_retset ) ;\n }\n fcinfo = & nullIfExpr -> fcinfo_data ;\n argDone = ExecEvalFuncArgs ( fcinfo , nullIfExpr -> args , econtext ) ;\n if ( argDone != ExprSingleResult ) ereport ( ERROR , ( errcode ( ERRCODE_DATATYPE_MISMATCH ) , errmsg ( \"NULLIF does not support set arguments\" ) ) ) ;\n Assert ( fcinfo -> nargs == 2 ) ;\n if ( ! fcinfo -> argnull [ 0 ] && ! fcinfo -> argnull [ 1 ] ) {\n fcinfo -> isnull = false ;\n result = FunctionCallInvoke ( fcinfo ) ;\n if ( ! fcinfo -> isnull && DatumGetBool ( result ) ) {\n * isNull = true ;\n return ( Datum ) 0 ;\n }\n }\n * isNull = fcinfo -> argnull [ 0 ] ;\n return fcinfo -> arg [ 0 ] ;\n }", "idx": 21032}
{"hash": -16551315108292821, "project": "debian", "size": 10, "label": 1, "functionSource": "gcry_mpi_t gcry_sexp_nth_mpi ( gcry_sexp_t list , int number , int mpifmt ) {\n const char * s ;\n size_t n ;\n gcry_mpi_t a ;\n if ( ! mpifmt ) mpifmt = GCRYMPI_FMT_STD ;\n s = sexp_nth_data ( list , number , & n ) ;\n if ( ! s ) return NULL ;\n if ( gcry_mpi_scan ( & a , mpifmt , s , n , NULL ) ) return NULL ;\n return a ;\n }", "idx": 21033}
{"hash": -1055531103257174901, "project": "debian", "size": 11, "label": 0, "functionSource": "static GList * convert_msglist ( GSList * msglist ) {\n GList * list ;\n list = NULL ;\n while ( msglist != NULL ) {\n LAST_MSG_REC * rec = msglist -> data ;\n list = g_list_append ( list , rec -> nick ) ;\n msglist = g_slist_remove ( msglist , rec ) ;\n g_free ( rec ) ;\n }\n return list ;\n }", "idx": 21034}
{"hash": 3599206110384554647, "project": "debian", "size": 30, "label": 0, "functionSource": "int PEM_write_ ## name ( FILE * fp , const type * x ) ;\n # define DECLARE_PEM_write_cb_fp ( name , type ) int PEM_write_ ## name ( FILE * fp , type * x , const EVP_CIPHER * enc , unsigned char * kstr , int klen , pem_password_cb * cb , void * u ) ;\n # endif # define DECLARE_PEM_read_bio ( name , type ) type * PEM_read_bio_ ## name ( BIO * bp , type * * x , pem_password_cb * cb , void * u ) ;\n # define DECLARE_PEM_write_bio ( name , type ) int PEM_write_bio_ ## name ( BIO * bp , type * x ) ;\n # define DECLARE_PEM_write_bio_const ( name , type ) int PEM_write_bio_ ## name ( BIO * bp , const type * x ) ;\n # define DECLARE_PEM_write_cb_bio ( name , type ) int PEM_write_bio_ ## name ( BIO * bp , type * x , const EVP_CIPHER * enc , unsigned char * kstr , int klen , pem_password_cb * cb , void * u ) ;\n # define DECLARE_PEM_write ( name , type ) DECLARE_PEM_write_bio ( name , type ) DECLARE_PEM_write_fp ( name , type ) # define DECLARE_PEM_write_const ( name , type ) DECLARE_PEM_write_bio_const ( name , type ) DECLARE_PEM_write_fp_const ( name , type ) # define DECLARE_PEM_write_cb ( name , type ) DECLARE_PEM_write_cb_bio ( name , type ) DECLARE_PEM_write_cb_fp ( name , type ) # define DECLARE_PEM_read ( name , type ) DECLARE_PEM_read_bio ( name , type ) DECLARE_PEM_read_fp ( name , type ) # define DECLARE_PEM_rw ( name , type ) DECLARE_PEM_read ( name , type ) DECLARE_PEM_write ( name , type ) # define DECLARE_PEM_rw_const ( name , type ) DECLARE_PEM_read ( name , type ) DECLARE_PEM_write_const ( name , type ) # define DECLARE_PEM_rw_cb ( name , type ) DECLARE_PEM_read ( name , type ) DECLARE_PEM_write_cb ( name , type ) typedef int pem_password_cb ( char * buf , int size , int rwflag , void * userdata ) ;\n int PEM_get_EVP_CIPHER_INFO ( char * header , EVP_CIPHER_INFO * cipher ) ;\n int PEM_do_header ( EVP_CIPHER_INFO * cipher , unsigned char * data , long * len , pem_password_cb * callback , void * u ) ;\n int PEM_read_bio ( BIO * bp , char * * name , char * * header , unsigned char * * data , long * len ) ;\n # define PEM_FLAG_SECURE 0x1 # define PEM_FLAG_EAY_COMPATIBLE 0x2 # define PEM_FLAG_ONLY_B64 0x4 int PEM_read_bio_ex ( BIO * bp , char * * name , char * * header , unsigned char * * data , long * len , unsigned int flags ) ;\n int PEM_bytes_read_bio_secmem ( unsigned char * * pdata , long * plen , char * * pnm , const char * name , BIO * bp , pem_password_cb * cb , void * u ) ;\n int PEM_write_bio ( BIO * bp , const char * name , const char * hdr , const unsigned char * data , long len ) ;\n int PEM_bytes_read_bio ( unsigned char * * pdata , long * plen , char * * pnm , const char * name , BIO * bp , pem_password_cb * cb , void * u ) ;\n void * PEM_ASN1_read_bio ( d2i_of_void * d2i , const char * name , BIO * bp , void * * x , pem_password_cb * cb , void * u ) ;\n int PEM_ASN1_write_bio ( i2d_of_void * i2d , const char * name , BIO * bp , void * x , const EVP_CIPHER * enc , unsigned char * kstr , int klen , pem_password_cb * cb , void * u ) ;\n STACK_OF ( X509_INFO ) * PEM_X509_INFO_read_bio ( BIO * bp , STACK_OF ( X509_INFO ) * sk , pem_password_cb * cb , void * u ) ;\n int PEM_X509_INFO_write_bio ( BIO * bp , X509_INFO * xi , EVP_CIPHER * enc , unsigned char * kstr , int klen , pem_password_cb * cd , void * u ) ;\n # ifndef OPENSSL_NO_STDIO int PEM_read ( FILE * fp , char * * name , char * * header , unsigned char * * data , long * len ) ;\n int PEM_write ( FILE * fp , const char * name , const char * hdr , const unsigned char * data , long len ) ;\n void * PEM_ASN1_read ( d2i_of_void * d2i , const char * name , FILE * fp , void * * x , pem_password_cb * cb , void * u ) ;\n int PEM_ASN1_write ( i2d_of_void * i2d , const char * name , FILE * fp , void * x , const EVP_CIPHER * enc , unsigned char * kstr , int klen , pem_password_cb * callback , void * u ) ;\n STACK_OF ( X509_INFO ) * PEM_X509_INFO_read ( FILE * fp , STACK_OF ( X509_INFO ) * sk , pem_password_cb * cb , void * u ) ;\n # endif int PEM_SignInit ( EVP_MD_CTX * ctx , EVP_MD * type ) ;\n int PEM_SignUpdate ( EVP_MD_CTX * ctx , unsigned char * d , unsigned int cnt ) ;\n int PEM_SignFinal ( EVP_MD_CTX * ctx , unsigned char * sigret , unsigned int * siglen , EVP_PKEY * pkey ) ;\n int PEM_def_callback ( char * buf , int num , int rwflag , void * userdata ) ;\n void PEM_proc_type ( char * buf , int type ) ;\n void PEM_dek_info ( char * buf , const char * type , int len , char * str ) ;\n # include < openssl / symhacks . h > DECLARE_PEM_rw ( X509 , X509 ) DECLARE_PEM_rw ( X509_AUX , X509 ) DECLARE_PEM_rw ( X509_REQ , X509_REQ ) DECLARE_PEM_write ( X509_REQ_NEW , X509_REQ ) DECLARE_PEM_rw ( X509_CRL , X509_CRL ) DECLARE_PEM_rw ( PKCS7 , PKCS7 ) DECLARE_PEM_rw ( NETSCAPE_CERT_SEQUENCE , NETSCAPE_CERT_SEQUENCE ) DECLARE_PEM_rw ( PKCS8 , X509_SIG ) DECLARE_PEM_rw ( PKCS8_PRIV_KEY_INFO , PKCS8_PRIV_KEY_INFO ) # ifndef OPENSSL_NO_RSA DECLARE_PEM_rw_cb ( RSAPrivateKey , RSA ) DECLARE_PEM_rw_const ( RSAPublicKey , RSA ) DECLARE_PEM_rw ( RSA_PUBKEY , RSA ) # endif # ifndef OPENSSL_NO_DSA DECLARE_PEM_rw_cb ( DSAPrivateKey , DSA ) DECLARE_PEM_rw ( DSA_PUBKEY , DSA ) DECLARE_PEM_rw_const ( DSAparams , DSA ) # endif # ifndef OPENSSL_NO_EC DECLARE_PEM_rw_const ( ECPKParameters , EC_GROUP ) DECLARE_PEM_rw_cb ( ECPrivateKey , EC_KEY ) DECLARE_PEM_rw ( EC_PUBKEY , EC_KEY ) # endif # ifndef OPENSSL_NO_DH DECLARE_PEM_rw_const ( DHparams , DH ) DECLARE_PEM_write_const ( DHxparams , DH )", "idx": 21035}
{"hash": 3401745371761513837, "project": "debian", "size": 24, "label": 0, "functionSource": "static void test_0 ( void ) {\n static char * good_strings [ ] = {\n \"C=de,O=g10 Code,OU=qa,CN=P\u00e9p\u00e9 le Moko\" , \"C= de, O=g10 Code , OU=qa ,CN=P\u00e9p\u00e9 le Moko\" , \"CN=www.gnupg.org\" , \" CN=www.gnupg.org \" , \"C=fr,L=Paris,CN=Julien Duvivier,EMAIL=julien@example.org\" , NULL }\n ;\n gpg_error_t err ;\n int i ;\n unsigned char * buf ;\n size_t off , len ;\n for ( i = 0 ;\n good_strings [ i ] ;\n i ++ ) {\n err = ksba_dn_str2der ( good_strings [ i ] , & buf , & len ) ;\n if ( err ) {\n fprintf ( stderr , \"%s:%d: ksba_dn_str2der failed for `%s': %s\\n\" , __FILE__ , __LINE__ , good_strings [ i ] , gpg_strerror ( err ) ) ;\n exit ( 1 ) ;\n }\n err = ksba_dn_teststr ( good_strings [ i ] , 0 , & off , & len ) ;\n if ( err ) {\n fprintf ( stderr , \"%s:%d: ksba_dn_teststr failed for `%s': %s\\n\" , __FILE__ , __LINE__ , good_strings [ i ] , gpg_strerror ( err ) ) ;\n exit ( 1 ) ;\n }\n xfree ( buf ) ;\n }\n }", "idx": 21036}
{"hash": -6449977545791282800, "project": "debian", "size": 5, "label": 0, "functionSource": "static inline void * ruby_zalloc ( size_t n ) {\n void * p = ruby_xmalloc ( n ) ;\n memset ( p , 0 , n ) ;\n return p ;\n }", "idx": 21037}
{"hash": 3599206110384554647, "project": "debian", "size": 46, "label": 1, "functionSource": "static ossl_inline int sk_ ## t1 ## _push ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_push ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _unshift ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_unshift ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _pop ( STACK_OF ( t1 ) * sk ) {\n return ( t2 * ) OPENSSL_sk_pop ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _shift ( STACK_OF ( t1 ) * sk ) {\n return ( t2 * ) OPENSSL_sk_shift ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline void sk_ ## t1 ## _pop_free ( STACK_OF ( t1 ) * sk , sk_ ## t1 ## _freefunc freefunc ) {\n OPENSSL_sk_pop_free ( ( OPENSSL_STACK * ) sk , ( OPENSSL_sk_freefunc ) freefunc ) ;\n }\n static ossl_inline int sk_ ## t1 ## _insert ( STACK_OF ( t1 ) * sk , t2 * ptr , int idx ) {\n return OPENSSL_sk_insert ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr , idx ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _set ( STACK_OF ( t1 ) * sk , int idx , t2 * ptr ) {\n return ( t2 * ) OPENSSL_sk_set ( ( OPENSSL_STACK * ) sk , idx , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _find ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_find ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _find_ex ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_find_ex ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline void sk_ ## t1 ## _sort ( STACK_OF ( t1 ) * sk ) {\n OPENSSL_sk_sort ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline int sk_ ## t1 ## _is_sorted ( const STACK_OF ( t1 ) * sk ) {\n return OPENSSL_sk_is_sorted ( ( const OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _dup ( const STACK_OF ( t1 ) * sk ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_dup ( ( const OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _deep_copy ( const STACK_OF ( t1 ) * sk , sk_ ## t1 ## _copyfunc copyfunc , sk_ ## t1 ## _freefunc freefunc ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_deep_copy ( ( const OPENSSL_STACK * ) sk , ( OPENSSL_sk_copyfunc ) copyfunc , ( OPENSSL_sk_freefunc ) freefunc ) ;\n }\n static ossl_inline sk_ ## t1 ## _compfunc sk_ ## t1 ## _set_cmp_func ( STACK_OF ( t1 ) * sk , sk_ ## t1 ## _compfunc compare ) {\n return ( sk_ ## t1 ## _compfunc ) OPENSSL_sk_set_cmp_func ( ( OPENSSL_STACK * ) sk , ( OPENSSL_sk_compfunc ) compare ) ;\n }\n # define DEFINE_SPECIAL_STACK_OF ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , t2 , t2 ) # define DEFINE_STACK_OF ( t ) SKM_DEFINE_STACK_OF ( t , t , t ) # define DEFINE_SPECIAL_STACK_OF_CONST ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , const t2 , t2 ) # define DEFINE_STACK_OF_CONST ( t ) SKM_DEFINE_STACK_OF ( t , const t , t ) typedef char * OPENSSL_STRING ;\n typedef const char * OPENSSL_CSTRING ;\n DEFINE_SPECIAL_STACK_OF ( OPENSSL_STRING , char ) DEFINE_SPECIAL_STACK_OF_CONST ( OPENSSL_CSTRING , char ) typedef void * OPENSSL_BLOCK ;\n DEFINE_SPECIAL_STACK_OF ( OPENSSL_BLOCK , void )", "idx": 21038}
{"hash": -7034148853749334444, "project": "debian", "size": 15, "label": 0, "functionSource": "static void yy_reduce_print ( YYSTYPE * yyvsp , int yyrule ) # else static void yy_reduce_print ( yyvsp , yyrule ) YYSTYPE * yyvsp ;\n int yyrule ;\n # endif {\n int yynrhs = yyr2 [ yyrule ] ;\n int yyi ;\n unsigned long int yylno = yyrline [ yyrule ] ;\n YYFPRINTF ( stderr , \"Reducing stack by rule %d (line %lu):\\n\" , yyrule - 1 , yylno ) ;\n for ( yyi = 0 ;\n yyi < yynrhs ;\n yyi ++ ) {\n YYFPRINTF ( stderr , \" $%d = \" , yyi + 1 ) ;\n yy_symbol_print ( stderr , yyrhs [ yyprhs [ yyrule ] + yyi ] , & ( yyvsp [ ( yyi + 1 ) - ( yynrhs ) ] ) ) ;\n YYFPRINTF ( stderr , \"\\n\" ) ;\n }\n }", "idx": 21039}
{"hash": -4810636875286199147, "project": "debian", "size": 76, "label": 0, "functionSource": "static enum fetch_step vbf_stp_fetch ( struct worker * wrk , struct busyobj * bo ) {\n const char * p ;\n CHECK_OBJ_NOTNULL ( wrk , WORKER_MAGIC ) ;\n CHECK_OBJ_NOTNULL ( bo , BUSYOBJ_MAGIC ) ;\n CHECK_OBJ_NOTNULL ( bo -> fetch_objcore , OBJCORE_MAGIC ) ;\n assert ( wrk -> handling == VCL_RET_DELIVER ) ;\n if ( ! cache_param -> http_gzip_support ) bo -> do_gzip = bo -> do_gunzip = 0 ;\n if ( bo -> htc -> content_length == 0 ) http_Unset ( bo -> beresp , H_Content_Encoding ) ;\n if ( bo -> htc -> body_status != BS_NONE ) {\n bo -> is_gzip = http_HdrIs ( bo -> beresp , H_Content_Encoding , \"gzip\" ) ;\n bo -> is_gunzip = ! http_GetHdr ( bo -> beresp , H_Content_Encoding , NULL ) ;\n assert ( bo -> is_gzip == 0 || bo -> is_gunzip == 0 ) ;\n }\n if ( bo -> htc -> body_status == BS_NONE || bo -> htc -> content_length == 0 || ( bo -> do_gunzip && ! bo -> is_gzip ) ) bo -> do_gunzip = 0 ;\n if ( bo -> htc -> body_status == BS_NONE || bo -> htc -> content_length == 0 || ( bo -> do_gzip && ! bo -> is_gunzip ) ) bo -> do_gzip = 0 ;\n assert ( bo -> do_gzip == 0 || bo -> do_gunzip == 0 ) ;\n if ( bo -> do_gunzip || ( bo -> is_gzip && bo -> do_esi ) ) vbf_vfp_push ( bo , & vfp_gunzip , 1 ) ;\n if ( bo -> htc -> content_length != 0 ) {\n if ( bo -> do_esi && bo -> do_gzip ) {\n vbf_vfp_push ( bo , & vfp_esi_gzip , 1 ) ;\n }\n else if ( bo -> do_esi && bo -> is_gzip && ! bo -> do_gunzip ) {\n vbf_vfp_push ( bo , & vfp_esi_gzip , 1 ) ;\n }\n else if ( bo -> do_esi ) {\n vbf_vfp_push ( bo , & vfp_esi , 1 ) ;\n }\n else if ( bo -> do_gzip ) {\n vbf_vfp_push ( bo , & vfp_gzip , 1 ) ;\n }\n else if ( bo -> is_gzip && ! bo -> do_gunzip ) {\n vbf_vfp_push ( bo , & vfp_testgunzip , 1 ) ;\n }\n }\n if ( bo -> fetch_objcore -> flags & OC_F_PRIVATE ) AN ( bo -> uncacheable ) ;\n if ( bo -> htc -> body_status == BS_NONE ) bo -> do_stream = 0 ;\n bo -> fetch_objcore -> boc -> len_so_far = 0 ;\n if ( VFP_Open ( bo -> vfc ) ) {\n ( void ) VFP_Error ( bo -> vfc , \"Fetch pipeline failed to open\" ) ;\n bo -> htc -> doclose = SC_RX_BODY ;\n VDI_Finish ( bo -> wrk , bo ) ;\n return ( F_STP_ERROR ) ;\n }\n if ( vbf_beresp2obj ( bo ) ) {\n ( void ) VFP_Error ( bo -> vfc , \"Could not get storage\" ) ;\n bo -> htc -> doclose = SC_RX_BODY ;\n VFP_Close ( bo -> vfc ) ;\n VDI_Finish ( bo -> wrk , bo ) ;\n return ( F_STP_ERROR ) ;\n }\n if ( bo -> do_esi ) ObjSetFlag ( bo -> wrk , bo -> fetch_objcore , OF_ESIPROC , 1 ) ;\n if ( bo -> do_gzip || ( bo -> is_gzip && ! bo -> do_gunzip ) ) ObjSetFlag ( bo -> wrk , bo -> fetch_objcore , OF_GZIPED , 1 ) ;\n if ( bo -> do_gzip || bo -> do_gunzip ) ObjSetFlag ( bo -> wrk , bo -> fetch_objcore , OF_CHGGZIP , 1 ) ;\n if ( ! ( bo -> fetch_objcore -> flags & OC_F_PASS ) && http_IsStatus ( bo -> beresp , 200 ) && ( http_GetHdr ( bo -> beresp , H_Last_Modified , & p ) || http_GetHdr ( bo -> beresp , H_ETag , & p ) ) ) ObjSetFlag ( bo -> wrk , bo -> fetch_objcore , OF_IMSCAND , 1 ) ;\n if ( bo -> htc -> body_status != BS_NONE && VDI_GetBody ( bo -> wrk , bo ) != 0 ) {\n ( void ) VFP_Error ( bo -> vfc , \"GetBody failed - workspace_backend overflow?\" ) ;\n VFP_Close ( bo -> vfc ) ;\n bo -> htc -> doclose = SC_OVERLOAD ;\n VDI_Finish ( bo -> wrk , bo ) ;\n return ( F_STP_ERROR ) ;\n }\n assert ( bo -> fetch_objcore -> boc -> refcount >= 1 ) ;\n assert ( bo -> fetch_objcore -> boc -> state == BOS_REQ_DONE ) ;\n if ( bo -> do_stream ) {\n ObjSetState ( wrk , bo -> fetch_objcore , BOS_PREP_STREAM ) ;\n HSH_Unbusy ( wrk , bo -> fetch_objcore ) ;\n ObjSetState ( wrk , bo -> fetch_objcore , BOS_STREAM ) ;\n }\n VSLb ( bo -> vsl , SLT_Fetch_Body , \"%u %s %s\" , bo -> htc -> body_status , body_status_2str ( bo -> htc -> body_status ) , bo -> do_stream ? \"stream\" : \"-\" ) ;\n if ( bo -> htc -> body_status != BS_NONE ) {\n assert ( bo -> htc -> body_status != BS_ERROR ) ;\n return ( F_STP_FETCHBODY ) ;\n }\n AZ ( bo -> vfc -> failed ) ;\n return ( F_STP_FETCHEND ) ;\n }", "idx": 21040}
{"hash": -4960438251319819237, "project": "chrome", "size": 43, "label": 1, "functionSource": "static void first_pass_motion_search ( VP9_COMP * cpi , MACROBLOCK * x , const MV * ref_mv , MV * best_mv , int * best_motion_err ) {\n MACROBLOCKD * const xd = & x -> e_mbd ;\n MV tmp_mv = {\n 0 , 0 }\n ;\n MV ref_mv_full = {\n ref_mv -> row >> 3 , ref_mv -> col >> 3 }\n ;\n int num00 , tmp_err , n ;\n const BLOCK_SIZE bsize = xd -> mi [ 0 ] -> mbmi . sb_type ;\n vp9_variance_fn_ptr_t v_fn_ptr = cpi -> fn_ptr [ bsize ] ;\n const int new_mv_mode_penalty = 256 ;\n int step_param = 3 ;\n int further_steps = ( MAX_MVSEARCH_STEPS - 1 ) - step_param ;\n const int sr = get_search_range ( & cpi -> common ) ;\n step_param += sr ;\n further_steps -= sr ;\n v_fn_ptr . vf = get_block_variance_fn ( bsize ) ;\n tmp_err = cpi -> diamond_search_sad ( x , & cpi -> ss_cfg , & ref_mv_full , & tmp_mv , step_param , x -> sadperbit16 , & num00 , & v_fn_ptr , ref_mv ) ;\n if ( tmp_err < INT_MAX ) tmp_err = vp9_get_mvpred_var ( x , & tmp_mv , ref_mv , & v_fn_ptr , 1 ) ;\n if ( tmp_err < INT_MAX - new_mv_mode_penalty ) tmp_err += new_mv_mode_penalty ;\n if ( tmp_err < * best_motion_err ) {\n * best_motion_err = tmp_err ;\n * best_mv = tmp_mv ;\n }\n n = num00 ;\n num00 = 0 ;\n while ( n < further_steps ) {\n ++ n ;\n if ( num00 ) {\n -- num00 ;\n }\n else {\n tmp_err = cpi -> diamond_search_sad ( x , & cpi -> ss_cfg , & ref_mv_full , & tmp_mv , step_param + n , x -> sadperbit16 , & num00 , & v_fn_ptr , ref_mv ) ;\n if ( tmp_err < INT_MAX ) tmp_err = vp9_get_mvpred_var ( x , & tmp_mv , ref_mv , & v_fn_ptr , 1 ) ;\n if ( tmp_err < INT_MAX - new_mv_mode_penalty ) tmp_err += new_mv_mode_penalty ;\n if ( tmp_err < * best_motion_err ) {\n * best_motion_err = tmp_err ;\n * best_mv = tmp_mv ;\n }\n }\n }\n }", "idx": 21041}
{"hash": -6468986929796051453, "project": "debian", "size": 3, "label": 0, "functionSource": "tdata_t _TIFFrealloc ( tdata_t p , tsize_t s ) {\n return ( realloc ( p , ( size_t ) s ) ) ;\n }", "idx": 21042}
{"hash": -6024601983167898950, "project": "debian", "size": 30, "label": 0, "functionSource": "static void activation_mountable_started ( NautilusFile * file , GFile * gfile_of_file , GError * error , gpointer callback_data ) {\n ActivateParameters * parameters = callback_data ;\n LaunchLocation * location ;\n parameters -> start_mountables = g_list_remove ( parameters -> start_mountables , file ) ;\n nautilus_file_unref ( file ) ;\n if ( error == NULL ) {\n location = find_launch_location_for_file ( parameters -> locations , file ) ;\n if ( location != NULL ) {\n parameters -> locations = g_list_remove ( parameters -> locations , location ) ;\n launch_location_free ( location ) ;\n }\n }\n else {\n if ( error -> domain != G_IO_ERROR || ( error -> code != G_IO_ERROR_FAILED_HANDLED ) ) {\n location = find_launch_location_for_file ( parameters -> locations , file ) ;\n if ( location ) {\n parameters -> locations = g_list_remove ( parameters -> locations , location ) ;\n launch_location_free ( location ) ;\n }\n }\n if ( error -> domain != G_IO_ERROR || ( error -> code != G_IO_ERROR_CANCELLED && error -> code != G_IO_ERROR_FAILED_HANDLED ) ) {\n eel_show_error_dialog ( _ ( \"Unable to start location\" ) , error -> message , NULL ) ;\n }\n if ( error -> code == G_IO_ERROR_CANCELLED ) {\n activation_parameters_free ( parameters ) ;\n return ;\n }\n }\n activation_start_mountables ( parameters ) ;\n }", "idx": 21043}
{"hash": -5511323081862746166, "project": "debian", "size": 42, "label": 0, "functionSource": "static gboolean k12_read ( wtap * wth , int * err , gchar * * err_info , gint64 * data_offset ) {\n k12_t * k12 = ( k12_t * ) wth -> priv ;\n k12_src_desc_t * src_desc ;\n guint8 * buffer ;\n gint64 offset ;\n gint len ;\n guint32 type ;\n guint32 src_id ;\n offset = file_tell ( wth -> fh ) ;\n do {\n if ( k12 -> num_of_records == 0 ) {\n * err = 0 ;\n return FALSE ;\n }\n K12_DBG ( 5 , ( \"k12_read: offset=%i\" , offset ) ) ;\n * data_offset = offset ;\n len = get_record ( k12 , wth -> fh , offset , FALSE , err , err_info ) ;\n if ( len < 0 ) {\n return FALSE ;\n }\n else if ( len == 0 ) {\n * err = WTAP_ERR_SHORT_READ ;\n return FALSE ;\n }\n else if ( len < K12_RECORD_SRC_ID + 4 ) {\n * err = WTAP_ERR_BAD_FILE ;\n * err_info = g_strdup_printf ( \"k12: Data record length %d too short\" , len ) ;\n return FALSE ;\n }\n k12 -> num_of_records -- ;\n buffer = k12 -> seq_read_buff ;\n type = pntoh32 ( buffer + K12_RECORD_TYPE ) ;\n src_id = pntoh32 ( buffer + K12_RECORD_SRC_ID ) ;\n if ( ! ( src_desc = ( k12_src_desc_t * ) g_hash_table_lookup ( k12 -> src_by_id , GUINT_TO_POINTER ( src_id ) ) ) ) {\n src_desc = ( k12_src_desc_t * ) g_hash_table_lookup ( k12 -> src_by_id , GUINT_TO_POINTER ( src_id & K12_RECORD_SRC_ID_MASK ) ) ;\n }\n K12_DBG ( 5 , ( \"k12_read: record type=%x src_id=%x\" , type , src_id ) ) ;\n offset += len ;\n }\n while ( ( ( type & K12_MASK_PACKET ) != K12_REC_PACKET && ( type & K12_MASK_PACKET ) != K12_REC_D0020 ) || ! src_id || ! src_desc ) ;\n return process_packet_data ( & wth -> phdr , wth -> frame_buffer , buffer , ( guint ) len , k12 , err , err_info ) ;\n }", "idx": 21044}
{"hash": 415966375198131126, "project": "debian", "size": 4, "label": 1, "functionSource": "extern int name ( int ) __THROW __exctype ( isalnum ) ;\n __exctype ( isalpha ) ;\n __exctype ( iscntrl ) ;\n __exctype ( isdigit )", "idx": 21045}
{"hash": -4555950263653671147, "project": "debian", "size": 11, "label": 0, "functionSource": "static void string_dealloc ( PyObject * op ) {\n switch ( PyString_CHECK_INTERNED ( op ) ) {\n case SSTATE_NOT_INTERNED : break ;\n case SSTATE_INTERNED_MORTAL : Py_REFCNT ( op ) = 3 ;\n if ( PyDict_DelItem ( interned , op ) != 0 ) Py_FatalError ( \"deletion of interned string failed\" ) ;\n break ;\n case SSTATE_INTERNED_IMMORTAL : Py_FatalError ( \"Immortal interned string died.\" ) ;\n default : Py_FatalError ( \"Inconsistent interned string state.\" ) ;\n }\n Py_TYPE ( op ) -> tp_free ( op ) ;\n }", "idx": 21046}
{"hash": -5249292504513104172, "project": "debian", "size": 37, "label": 0, "functionSource": "static void xmlrpc_append_char_encode ( mowgli_string_t * s , const char * s1 ) {\n long unsigned int i ;\n unsigned char c ;\n char buf2 [ 15 ] ;\n if ( ( ! ( s1 ) || ( * ( s1 ) == '\\0' ) ) ) {\n return ;\n }\n for ( i = 0 ;\n s1 [ i ] != '\\0' ;\n i ++ ) {\n c = s1 [ i ] ;\n if ( c > 127 ) {\n snprintf ( buf2 , sizeof buf2 , \"&#%d;\n\" , c ) ;\n s -> append ( s , buf2 , strlen ( buf2 ) ) ;\n }\n else if ( c == '&' ) {\n s -> append ( s , \"&amp;\n\" , 5 ) ;\n }\n else if ( c == '<' ) {\n s -> append ( s , \"&lt;\n\" , 4 ) ;\n }\n else if ( c == '>' ) {\n s -> append ( s , \"&gt;\n\" , 4 ) ;\n }\n else if ( c == '\"' ) {\n s -> append ( s , \"&quot;\n\" , 6 ) ;\n }\n else {\n s -> append_char ( s , c ) ;\n }\n }\n }", "idx": 21047}
{"hash": 3804373597256531021, "project": "debian", "size": 7, "label": 0, "functionSource": "void get_mqh ( const char * user , const char * host , USER_CONN * uc ) {\n ACL_USER * acl_user ;\n pthread_mutex_lock ( & acl_cache -> lock ) ;\n if ( initialized && ( acl_user = find_acl_user ( host , user , FALSE ) ) ) uc -> user_resources = acl_user -> user_resource ;\n else bzero ( ( char * ) & uc -> user_resources , sizeof ( uc -> user_resources ) ) ;\n pthread_mutex_unlock ( & acl_cache -> lock ) ;\n }", "idx": 21048}
{"hash": -3559021711340554904, "project": "debian", "size": 4, "label": 0, "functionSource": "bool is_pseudo_constant_clause_relids ( Node * clause , Relids relids ) {\n if ( bms_is_empty ( relids ) && ! contain_volatile_functions ( clause ) ) return true ;\n return false ;\n }", "idx": 21049}
{"hash": 6250095321513210169, "project": "debian", "size": 31, "label": 0, "functionSource": "rfbBool rfbSendCopyRegion ( rfbClientPtr cl , sraRegionPtr reg , int dx , int dy ) {\n int x , y , w , h ;\n rfbFramebufferUpdateRectHeader rect ;\n rfbCopyRect cr ;\n sraRectangleIterator * i ;\n sraRect rect1 ;\n i = sraRgnGetReverseIterator ( reg , dx > 0 , dy > 0 ) ;\n dx = ScaleX ( cl -> screen , cl -> scaledScreen , dx ) ;\n dy = ScaleX ( cl -> screen , cl -> scaledScreen , dy ) ;\n while ( sraRgnIteratorNext ( i , & rect1 ) ) {\n x = rect1 . x1 ;\n y = rect1 . y1 ;\n w = rect1 . x2 - x ;\n h = rect1 . y2 - y ;\n rfbScaledCorrection ( cl -> screen , cl -> scaledScreen , & x , & y , & w , & h , \"copyrect\" ) ;\n rect . r . x = Swap16IfLE ( x ) ;\n rect . r . y = Swap16IfLE ( y ) ;\n rect . r . w = Swap16IfLE ( w ) ;\n rect . r . h = Swap16IfLE ( h ) ;\n rect . encoding = Swap32IfLE ( rfbEncodingCopyRect ) ;\n memcpy ( & cl -> updateBuf [ cl -> ublen ] , ( char * ) & rect , sz_rfbFramebufferUpdateRectHeader ) ;\n cl -> ublen += sz_rfbFramebufferUpdateRectHeader ;\n cr . srcX = Swap16IfLE ( x - dx ) ;\n cr . srcY = Swap16IfLE ( y - dy ) ;\n memcpy ( & cl -> updateBuf [ cl -> ublen ] , ( char * ) & cr , sz_rfbCopyRect ) ;\n cl -> ublen += sz_rfbCopyRect ;\n rfbStatRecordEncodingSent ( cl , rfbEncodingCopyRect , sz_rfbFramebufferUpdateRectHeader + sz_rfbCopyRect , w * h * ( cl -> scaledScreen -> bitsPerPixel / 8 ) ) ;\n }\n sraRgnReleaseIterator ( i ) ;\n return TRUE ;\n }", "idx": 21050}
{"hash": -4979531020783644238, "project": "debian", "size": 13, "label": 0, "functionSource": "char * cluster_conn_opts ( ClusterInfo * cluster ) {\n static PQExpBuffer buf ;\n if ( buf == NULL ) buf = createPQExpBuffer ( ) ;\n else resetPQExpBuffer ( buf ) ;\n if ( cluster -> sockdir ) {\n appendPQExpBufferStr ( buf , \"--host \" ) ;\n appendShellString ( buf , cluster -> sockdir ) ;\n appendPQExpBufferChar ( buf , ' ' ) ;\n }\n appendPQExpBuffer ( buf , \"--port %d --username \" , cluster -> port ) ;\n appendShellString ( buf , os_info . user ) ;\n return buf -> data ;\n }", "idx": 21051}
{"hash": -320658364442495927, "project": "chrome", "size": 20, "label": 1, "functionSource": "void vp8_de_noise ( VP8_COMMON * cm , YV12_BUFFER_CONFIG * source , YV12_BUFFER_CONFIG * post , int q , int low_var_thresh , int flag ) {\n int mbr ;\n double level = 6.0e-05 * q * q * q - .0067 * q * q + .306 * q + .0065 ;\n int ppl = ( int ) ( level + .5 ) ;\n int mb_rows = cm -> mb_rows ;\n int mb_cols = cm -> mb_cols ;\n unsigned char * limits = cm -> pp_limits_buffer ;\n ;\n ( void ) post ;\n ( void ) low_var_thresh ;\n ( void ) flag ;\n vpx_memset ( limits , ( unsigned char ) ppl , 16 * mb_cols ) ;\n for ( mbr = 0 ;\n mbr < mb_rows ;\n mbr ++ ) {\n vp8_post_proc_down_and_across_mb_row ( source -> y_buffer + 16 * mbr * source -> y_stride , source -> y_buffer + 16 * mbr * source -> y_stride , source -> y_stride , source -> y_stride , source -> y_width , limits , 16 ) ;\n vp8_post_proc_down_and_across_mb_row ( source -> u_buffer + 8 * mbr * source -> uv_stride , source -> u_buffer + 8 * mbr * source -> uv_stride , source -> uv_stride , source -> uv_stride , source -> uv_width , limits , 8 ) ;\n vp8_post_proc_down_and_across_mb_row ( source -> v_buffer + 8 * mbr * source -> uv_stride , source -> v_buffer + 8 * mbr * source -> uv_stride , source -> uv_stride , source -> uv_stride , source -> uv_width , limits , 8 ) ;\n }\n }", "idx": 21052}
{"hash": 8460430819945784394, "project": "debian", "size": 7, "label": 0, "functionSource": "static void put_long ( void * addr , uint32_t l ) {\n char * pos = addr ;\n pos [ 0 ] = ( l >> 24 ) & 0xFF ;\n pos [ 1 ] = ( l >> 16 ) & 0xFF ;\n pos [ 2 ] = ( l >> 8 ) & 0xFF ;\n pos [ 3 ] = l & 0xFF ;\n }", "idx": 21053}
{"hash": -1710554222303887484, "project": "chrome", "size": 442, "label": 0, "functionSource": "static void iadst16_8col ( __m128i * in ) {\n __m128i s [ 16 ] , x [ 16 ] , u [ 32 ] , v [ 32 ] ;\n const __m128i k__cospi_p01_p31 = pair_set_epi16 ( cospi_1_64 , cospi_31_64 ) ;\n const __m128i k__cospi_p31_m01 = pair_set_epi16 ( cospi_31_64 , - cospi_1_64 ) ;\n const __m128i k__cospi_p05_p27 = pair_set_epi16 ( cospi_5_64 , cospi_27_64 ) ;\n const __m128i k__cospi_p27_m05 = pair_set_epi16 ( cospi_27_64 , - cospi_5_64 ) ;\n const __m128i k__cospi_p09_p23 = pair_set_epi16 ( cospi_9_64 , cospi_23_64 ) ;\n const __m128i k__cospi_p23_m09 = pair_set_epi16 ( cospi_23_64 , - cospi_9_64 ) ;\n const __m128i k__cospi_p13_p19 = pair_set_epi16 ( cospi_13_64 , cospi_19_64 ) ;\n const __m128i k__cospi_p19_m13 = pair_set_epi16 ( cospi_19_64 , - cospi_13_64 ) ;\n const __m128i k__cospi_p17_p15 = pair_set_epi16 ( cospi_17_64 , cospi_15_64 ) ;\n const __m128i k__cospi_p15_m17 = pair_set_epi16 ( cospi_15_64 , - cospi_17_64 ) ;\n const __m128i k__cospi_p21_p11 = pair_set_epi16 ( cospi_21_64 , cospi_11_64 ) ;\n const __m128i k__cospi_p11_m21 = pair_set_epi16 ( cospi_11_64 , - cospi_21_64 ) ;\n const __m128i k__cospi_p25_p07 = pair_set_epi16 ( cospi_25_64 , cospi_7_64 ) ;\n const __m128i k__cospi_p07_m25 = pair_set_epi16 ( cospi_7_64 , - cospi_25_64 ) ;\n const __m128i k__cospi_p29_p03 = pair_set_epi16 ( cospi_29_64 , cospi_3_64 ) ;\n const __m128i k__cospi_p03_m29 = pair_set_epi16 ( cospi_3_64 , - cospi_29_64 ) ;\n const __m128i k__cospi_p04_p28 = pair_set_epi16 ( cospi_4_64 , cospi_28_64 ) ;\n const __m128i k__cospi_p28_m04 = pair_set_epi16 ( cospi_28_64 , - cospi_4_64 ) ;\n const __m128i k__cospi_p20_p12 = pair_set_epi16 ( cospi_20_64 , cospi_12_64 ) ;\n const __m128i k__cospi_p12_m20 = pair_set_epi16 ( cospi_12_64 , - cospi_20_64 ) ;\n const __m128i k__cospi_m28_p04 = pair_set_epi16 ( - cospi_28_64 , cospi_4_64 ) ;\n const __m128i k__cospi_m12_p20 = pair_set_epi16 ( - cospi_12_64 , cospi_20_64 ) ;\n const __m128i k__cospi_p08_p24 = pair_set_epi16 ( cospi_8_64 , cospi_24_64 ) ;\n const __m128i k__cospi_p24_m08 = pair_set_epi16 ( cospi_24_64 , - cospi_8_64 ) ;\n const __m128i k__cospi_m24_p08 = pair_set_epi16 ( - cospi_24_64 , cospi_8_64 ) ;\n const __m128i k__cospi_m16_m16 = _mm_set1_epi16 ( - cospi_16_64 ) ;\n const __m128i k__cospi_p16_p16 = _mm_set1_epi16 ( cospi_16_64 ) ;\n const __m128i k__cospi_p16_m16 = pair_set_epi16 ( cospi_16_64 , - cospi_16_64 ) ;\n const __m128i k__cospi_m16_p16 = pair_set_epi16 ( - cospi_16_64 , cospi_16_64 ) ;\n const __m128i k__DCT_CONST_ROUNDING = _mm_set1_epi32 ( DCT_CONST_ROUNDING ) ;\n const __m128i kZero = _mm_set1_epi16 ( 0 ) ;\n u [ 0 ] = _mm_unpacklo_epi16 ( in [ 15 ] , in [ 0 ] ) ;\n u [ 1 ] = _mm_unpackhi_epi16 ( in [ 15 ] , in [ 0 ] ) ;\n u [ 2 ] = _mm_unpacklo_epi16 ( in [ 13 ] , in [ 2 ] ) ;\n u [ 3 ] = _mm_unpackhi_epi16 ( in [ 13 ] , in [ 2 ] ) ;\n u [ 4 ] = _mm_unpacklo_epi16 ( in [ 11 ] , in [ 4 ] ) ;\n u [ 5 ] = _mm_unpackhi_epi16 ( in [ 11 ] , in [ 4 ] ) ;\n u [ 6 ] = _mm_unpacklo_epi16 ( in [ 9 ] , in [ 6 ] ) ;\n u [ 7 ] = _mm_unpackhi_epi16 ( in [ 9 ] , in [ 6 ] ) ;\n u [ 8 ] = _mm_unpacklo_epi16 ( in [ 7 ] , in [ 8 ] ) ;\n u [ 9 ] = _mm_unpackhi_epi16 ( in [ 7 ] , in [ 8 ] ) ;\n u [ 10 ] = _mm_unpacklo_epi16 ( in [ 5 ] , in [ 10 ] ) ;\n u [ 11 ] = _mm_unpackhi_epi16 ( in [ 5 ] , in [ 10 ] ) ;\n u [ 12 ] = _mm_unpacklo_epi16 ( in [ 3 ] , in [ 12 ] ) ;\n u [ 13 ] = _mm_unpackhi_epi16 ( in [ 3 ] , in [ 12 ] ) ;\n u [ 14 ] = _mm_unpacklo_epi16 ( in [ 1 ] , in [ 14 ] ) ;\n u [ 15 ] = _mm_unpackhi_epi16 ( in [ 1 ] , in [ 14 ] ) ;\n v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p01_p31 ) ;\n v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p01_p31 ) ;\n v [ 2 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p31_m01 ) ;\n v [ 3 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p31_m01 ) ;\n v [ 4 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p05_p27 ) ;\n v [ 5 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p05_p27 ) ;\n v [ 6 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p27_m05 ) ;\n v [ 7 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p27_m05 ) ;\n v [ 8 ] = _mm_madd_epi16 ( u [ 4 ] , k__cospi_p09_p23 ) ;\n v [ 9 ] = _mm_madd_epi16 ( u [ 5 ] , k__cospi_p09_p23 ) ;\n v [ 10 ] = _mm_madd_epi16 ( u [ 4 ] , k__cospi_p23_m09 ) ;\n v [ 11 ] = _mm_madd_epi16 ( u [ 5 ] , k__cospi_p23_m09 ) ;\n v [ 12 ] = _mm_madd_epi16 ( u [ 6 ] , k__cospi_p13_p19 ) ;\n v [ 13 ] = _mm_madd_epi16 ( u [ 7 ] , k__cospi_p13_p19 ) ;\n v [ 14 ] = _mm_madd_epi16 ( u [ 6 ] , k__cospi_p19_m13 ) ;\n v [ 15 ] = _mm_madd_epi16 ( u [ 7 ] , k__cospi_p19_m13 ) ;\n v [ 16 ] = _mm_madd_epi16 ( u [ 8 ] , k__cospi_p17_p15 ) ;\n v [ 17 ] = _mm_madd_epi16 ( u [ 9 ] , k__cospi_p17_p15 ) ;\n v [ 18 ] = _mm_madd_epi16 ( u [ 8 ] , k__cospi_p15_m17 ) ;\n v [ 19 ] = _mm_madd_epi16 ( u [ 9 ] , k__cospi_p15_m17 ) ;\n v [ 20 ] = _mm_madd_epi16 ( u [ 10 ] , k__cospi_p21_p11 ) ;\n v [ 21 ] = _mm_madd_epi16 ( u [ 11 ] , k__cospi_p21_p11 ) ;\n v [ 22 ] = _mm_madd_epi16 ( u [ 10 ] , k__cospi_p11_m21 ) ;\n v [ 23 ] = _mm_madd_epi16 ( u [ 11 ] , k__cospi_p11_m21 ) ;\n v [ 24 ] = _mm_madd_epi16 ( u [ 12 ] , k__cospi_p25_p07 ) ;\n v [ 25 ] = _mm_madd_epi16 ( u [ 13 ] , k__cospi_p25_p07 ) ;\n v [ 26 ] = _mm_madd_epi16 ( u [ 12 ] , k__cospi_p07_m25 ) ;\n v [ 27 ] = _mm_madd_epi16 ( u [ 13 ] , k__cospi_p07_m25 ) ;\n v [ 28 ] = _mm_madd_epi16 ( u [ 14 ] , k__cospi_p29_p03 ) ;\n v [ 29 ] = _mm_madd_epi16 ( u [ 15 ] , k__cospi_p29_p03 ) ;\n v [ 30 ] = _mm_madd_epi16 ( u [ 14 ] , k__cospi_p03_m29 ) ;\n v [ 31 ] = _mm_madd_epi16 ( u [ 15 ] , k__cospi_p03_m29 ) ;\n u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , v [ 16 ] ) ;\n u [ 1 ] = _mm_add_epi32 ( v [ 1 ] , v [ 17 ] ) ;\n u [ 2 ] = _mm_add_epi32 ( v [ 2 ] , v [ 18 ] ) ;\n u [ 3 ] = _mm_add_epi32 ( v [ 3 ] , v [ 19 ] ) ;\n u [ 4 ] = _mm_add_epi32 ( v [ 4 ] , v [ 20 ] ) ;\n u [ 5 ] = _mm_add_epi32 ( v [ 5 ] , v [ 21 ] ) ;\n u [ 6 ] = _mm_add_epi32 ( v [ 6 ] , v [ 22 ] ) ;\n u [ 7 ] = _mm_add_epi32 ( v [ 7 ] , v [ 23 ] ) ;\n u [ 8 ] = _mm_add_epi32 ( v [ 8 ] , v [ 24 ] ) ;\n u [ 9 ] = _mm_add_epi32 ( v [ 9 ] , v [ 25 ] ) ;\n u [ 10 ] = _mm_add_epi32 ( v [ 10 ] , v [ 26 ] ) ;\n u [ 11 ] = _mm_add_epi32 ( v [ 11 ] , v [ 27 ] ) ;\n u [ 12 ] = _mm_add_epi32 ( v [ 12 ] , v [ 28 ] ) ;\n u [ 13 ] = _mm_add_epi32 ( v [ 13 ] , v [ 29 ] ) ;\n u [ 14 ] = _mm_add_epi32 ( v [ 14 ] , v [ 30 ] ) ;\n u [ 15 ] = _mm_add_epi32 ( v [ 15 ] , v [ 31 ] ) ;\n u [ 16 ] = _mm_sub_epi32 ( v [ 0 ] , v [ 16 ] ) ;\n u [ 17 ] = _mm_sub_epi32 ( v [ 1 ] , v [ 17 ] ) ;\n u [ 18 ] = _mm_sub_epi32 ( v [ 2 ] , v [ 18 ] ) ;\n u [ 19 ] = _mm_sub_epi32 ( v [ 3 ] , v [ 19 ] ) ;\n u [ 20 ] = _mm_sub_epi32 ( v [ 4 ] , v [ 20 ] ) ;\n u [ 21 ] = _mm_sub_epi32 ( v [ 5 ] , v [ 21 ] ) ;\n u [ 22 ] = _mm_sub_epi32 ( v [ 6 ] , v [ 22 ] ) ;\n u [ 23 ] = _mm_sub_epi32 ( v [ 7 ] , v [ 23 ] ) ;\n u [ 24 ] = _mm_sub_epi32 ( v [ 8 ] , v [ 24 ] ) ;\n u [ 25 ] = _mm_sub_epi32 ( v [ 9 ] , v [ 25 ] ) ;\n u [ 26 ] = _mm_sub_epi32 ( v [ 10 ] , v [ 26 ] ) ;\n u [ 27 ] = _mm_sub_epi32 ( v [ 11 ] , v [ 27 ] ) ;\n u [ 28 ] = _mm_sub_epi32 ( v [ 12 ] , v [ 28 ] ) ;\n u [ 29 ] = _mm_sub_epi32 ( v [ 13 ] , v [ 29 ] ) ;\n u [ 30 ] = _mm_sub_epi32 ( v [ 14 ] , v [ 30 ] ) ;\n u [ 31 ] = _mm_sub_epi32 ( v [ 15 ] , v [ 31 ] ) ;\n v [ 0 ] = _mm_add_epi32 ( u [ 0 ] , k__DCT_CONST_ROUNDING ) ;\n v [ 1 ] = _mm_add_epi32 ( u [ 1 ] , k__DCT_CONST_ROUNDING ) ;\n v [ 2 ] = _mm_add_epi32 ( u [ 2 ] , k__DCT_CONST_ROUNDING ) ;\n v [ 3 ] = _mm_add_epi32 ( u [ 3 ] , k__DCT_CONST_ROUNDING ) ;\n v [ 4 ] = _mm_add_epi32 ( u [ 4 ] , k__DCT_CONST_ROUNDING ) ;\n v [ 5 ] = _mm_add_epi32 ( u [ 5 ] , k__DCT_CONST_ROUNDING ) ;\n v [ 6 ] = _mm_add_epi32 ( u [ 6 ] , k__DCT_CONST_ROUNDING ) ;\n v [ 7 ] = _mm_add_epi32 ( u [ 7 ] , k__DCT_CONST_ROUNDING ) ;\n v [ 8 ] = _mm_add_epi32 ( u [ 8 ] , k__DCT_CONST_ROUNDING ) ;\n v [ 9 ] = _mm_add_epi32 ( u [ 9 ] , k__DCT_CONST_ROUNDING ) ;\n v [ 10 ] = _mm_add_epi32 ( u [ 10 ] , k__DCT_CONST_ROUNDING ) ;\n v [ 11 ] = _mm_add_epi32 ( u [ 11 ] , k__DCT_CONST_ROUNDING ) ;\n v [ 12 ] = _mm_add_epi32 ( u [ 12 ] , k__DCT_CONST_ROUNDING ) ;\n v [ 13 ] = _mm_add_epi32 ( u [ 13 ] , k__DCT_CONST_ROUNDING ) ;\n v [ 14 ] = _mm_add_epi32 ( u [ 14 ] , k__DCT_CONST_ROUNDING ) ;\n v [ 15 ] = _mm_add_epi32 ( u [ 15 ] , k__DCT_CONST_ROUNDING ) ;\n v [ 16 ] = _mm_add_epi32 ( u [ 16 ] , k__DCT_CONST_ROUNDING ) ;\n v [ 17 ] = _mm_add_epi32 ( u [ 17 ] , k__DCT_CONST_ROUNDING ) ;\n v [ 18 ] = _mm_add_epi32 ( u [ 18 ] , k__DCT_CONST_ROUNDING ) ;\n v [ 19 ] = _mm_add_epi32 ( u [ 19 ] , k__DCT_CONST_ROUNDING ) ;\n v [ 20 ] = _mm_add_epi32 ( u [ 20 ] , k__DCT_CONST_ROUNDING ) ;\n v [ 21 ] = _mm_add_epi32 ( u [ 21 ] , k__DCT_CONST_ROUNDING ) ;\n v [ 22 ] = _mm_add_epi32 ( u [ 22 ] , k__DCT_CONST_ROUNDING ) ;\n v [ 23 ] = _mm_add_epi32 ( u [ 23 ] , k__DCT_CONST_ROUNDING ) ;\n v [ 24 ] = _mm_add_epi32 ( u [ 24 ] , k__DCT_CONST_ROUNDING ) ;\n v [ 25 ] = _mm_add_epi32 ( u [ 25 ] , k__DCT_CONST_ROUNDING ) ;\n v [ 26 ] = _mm_add_epi32 ( u [ 26 ] , k__DCT_CONST_ROUNDING ) ;\n v [ 27 ] = _mm_add_epi32 ( u [ 27 ] , k__DCT_CONST_ROUNDING ) ;\n v [ 28 ] = _mm_add_epi32 ( u [ 28 ] , k__DCT_CONST_ROUNDING ) ;\n v [ 29 ] = _mm_add_epi32 ( u [ 29 ] , k__DCT_CONST_ROUNDING ) ;\n v [ 30 ] = _mm_add_epi32 ( u [ 30 ] , k__DCT_CONST_ROUNDING ) ;\n v [ 31 ] = _mm_add_epi32 ( u [ 31 ] , k__DCT_CONST_ROUNDING ) ;\n u [ 0 ] = _mm_srai_epi32 ( v [ 0 ] , DCT_CONST_BITS ) ;\n u [ 1 ] = _mm_srai_epi32 ( v [ 1 ] , DCT_CONST_BITS ) ;\n u [ 2 ] = _mm_srai_epi32 ( v [ 2 ] , DCT_CONST_BITS ) ;\n u [ 3 ] = _mm_srai_epi32 ( v [ 3 ] , DCT_CONST_BITS ) ;\n u [ 4 ] = _mm_srai_epi32 ( v [ 4 ] , DCT_CONST_BITS ) ;\n u [ 5 ] = _mm_srai_epi32 ( v [ 5 ] , DCT_CONST_BITS ) ;\n u [ 6 ] = _mm_srai_epi32 ( v [ 6 ] , DCT_CONST_BITS ) ;\n u [ 7 ] = _mm_srai_epi32 ( v [ 7 ] , DCT_CONST_BITS ) ;\n u [ 8 ] = _mm_srai_epi32 ( v [ 8 ] , DCT_CONST_BITS ) ;\n u [ 9 ] = _mm_srai_epi32 ( v [ 9 ] , DCT_CONST_BITS ) ;\n u [ 10 ] = _mm_srai_epi32 ( v [ 10 ] , DCT_CONST_BITS ) ;\n u [ 11 ] = _mm_srai_epi32 ( v [ 11 ] , DCT_CONST_BITS ) ;\n u [ 12 ] = _mm_srai_epi32 ( v [ 12 ] , DCT_CONST_BITS ) ;\n u [ 13 ] = _mm_srai_epi32 ( v [ 13 ] , DCT_CONST_BITS ) ;\n u [ 14 ] = _mm_srai_epi32 ( v [ 14 ] , DCT_CONST_BITS ) ;\n u [ 15 ] = _mm_srai_epi32 ( v [ 15 ] , DCT_CONST_BITS ) ;\n u [ 16 ] = _mm_srai_epi32 ( v [ 16 ] , DCT_CONST_BITS ) ;\n u [ 17 ] = _mm_srai_epi32 ( v [ 17 ] , DCT_CONST_BITS ) ;\n u [ 18 ] = _mm_srai_epi32 ( v [ 18 ] , DCT_CONST_BITS ) ;\n u [ 19 ] = _mm_srai_epi32 ( v [ 19 ] , DCT_CONST_BITS ) ;\n u [ 20 ] = _mm_srai_epi32 ( v [ 20 ] , DCT_CONST_BITS ) ;\n u [ 21 ] = _mm_srai_epi32 ( v [ 21 ] , DCT_CONST_BITS ) ;\n u [ 22 ] = _mm_srai_epi32 ( v [ 22 ] , DCT_CONST_BITS ) ;\n u [ 23 ] = _mm_srai_epi32 ( v [ 23 ] , DCT_CONST_BITS ) ;\n u [ 24 ] = _mm_srai_epi32 ( v [ 24 ] , DCT_CONST_BITS ) ;\n u [ 25 ] = _mm_srai_epi32 ( v [ 25 ] , DCT_CONST_BITS ) ;\n u [ 26 ] = _mm_srai_epi32 ( v [ 26 ] , DCT_CONST_BITS ) ;\n u [ 27 ] = _mm_srai_epi32 ( v [ 27 ] , DCT_CONST_BITS ) ;\n u [ 28 ] = _mm_srai_epi32 ( v [ 28 ] , DCT_CONST_BITS ) ;\n u [ 29 ] = _mm_srai_epi32 ( v [ 29 ] , DCT_CONST_BITS ) ;\n u [ 30 ] = _mm_srai_epi32 ( v [ 30 ] , DCT_CONST_BITS ) ;\n u [ 31 ] = _mm_srai_epi32 ( v [ 31 ] , DCT_CONST_BITS ) ;\n s [ 0 ] = _mm_packs_epi32 ( u [ 0 ] , u [ 1 ] ) ;\n s [ 1 ] = _mm_packs_epi32 ( u [ 2 ] , u [ 3 ] ) ;\n s [ 2 ] = _mm_packs_epi32 ( u [ 4 ] , u [ 5 ] ) ;\n s [ 3 ] = _mm_packs_epi32 ( u [ 6 ] , u [ 7 ] ) ;\n s [ 4 ] = _mm_packs_epi32 ( u [ 8 ] , u [ 9 ] ) ;\n s [ 5 ] = _mm_packs_epi32 ( u [ 10 ] , u [ 11 ] ) ;\n s [ 6 ] = _mm_packs_epi32 ( u [ 12 ] , u [ 13 ] ) ;\n s [ 7 ] = _mm_packs_epi32 ( u [ 14 ] , u [ 15 ] ) ;\n s [ 8 ] = _mm_packs_epi32 ( u [ 16 ] , u [ 17 ] ) ;\n s [ 9 ] = _mm_packs_epi32 ( u [ 18 ] , u [ 19 ] ) ;\n s [ 10 ] = _mm_packs_epi32 ( u [ 20 ] , u [ 21 ] ) ;\n s [ 11 ] = _mm_packs_epi32 ( u [ 22 ] , u [ 23 ] ) ;\n s [ 12 ] = _mm_packs_epi32 ( u [ 24 ] , u [ 25 ] ) ;\n s [ 13 ] = _mm_packs_epi32 ( u [ 26 ] , u [ 27 ] ) ;\n s [ 14 ] = _mm_packs_epi32 ( u [ 28 ] , u [ 29 ] ) ;\n s [ 15 ] = _mm_packs_epi32 ( u [ 30 ] , u [ 31 ] ) ;\n u [ 0 ] = _mm_unpacklo_epi16 ( s [ 8 ] , s [ 9 ] ) ;\n u [ 1 ] = _mm_unpackhi_epi16 ( s [ 8 ] , s [ 9 ] ) ;\n u [ 2 ] = _mm_unpacklo_epi16 ( s [ 10 ] , s [ 11 ] ) ;\n u [ 3 ] = _mm_unpackhi_epi16 ( s [ 10 ] , s [ 11 ] ) ;\n u [ 4 ] = _mm_unpacklo_epi16 ( s [ 12 ] , s [ 13 ] ) ;\n u [ 5 ] = _mm_unpackhi_epi16 ( s [ 12 ] , s [ 13 ] ) ;\n u [ 6 ] = _mm_unpacklo_epi16 ( s [ 14 ] , s [ 15 ] ) ;\n u [ 7 ] = _mm_unpackhi_epi16 ( s [ 14 ] , s [ 15 ] ) ;\n v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p04_p28 ) ;\n v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p04_p28 ) ;\n v [ 2 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p28_m04 ) ;\n v [ 3 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p28_m04 ) ;\n v [ 4 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p20_p12 ) ;\n v [ 5 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p20_p12 ) ;\n v [ 6 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p12_m20 ) ;\n v [ 7 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p12_m20 ) ;\n v [ 8 ] = _mm_madd_epi16 ( u [ 4 ] , k__cospi_m28_p04 ) ;\n v [ 9 ] = _mm_madd_epi16 ( u [ 5 ] , k__cospi_m28_p04 ) ;\n v [ 10 ] = _mm_madd_epi16 ( u [ 4 ] , k__cospi_p04_p28 ) ;\n v [ 11 ] = _mm_madd_epi16 ( u [ 5 ] , k__cospi_p04_p28 ) ;\n v [ 12 ] = _mm_madd_epi16 ( u [ 6 ] , k__cospi_m12_p20 ) ;\n v [ 13 ] = _mm_madd_epi16 ( u [ 7 ] , k__cospi_m12_p20 ) ;\n v [ 14 ] = _mm_madd_epi16 ( u [ 6 ] , k__cospi_p20_p12 ) ;\n v [ 15 ] = _mm_madd_epi16 ( u [ 7 ] , k__cospi_p20_p12 ) ;\n u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , v [ 8 ] ) ;\n u [ 1 ] = _mm_add_epi32 ( v [ 1 ] , v [ 9 ] ) ;\n u [ 2 ] = _mm_add_epi32 ( v [ 2 ] , v [ 10 ] ) ;\n u [ 3 ] = _mm_add_epi32 ( v [ 3 ] , v [ 11 ] ) ;\n u [ 4 ] = _mm_add_epi32 ( v [ 4 ] , v [ 12 ] ) ;\n u [ 5 ] = _mm_add_epi32 ( v [ 5 ] , v [ 13 ] ) ;\n u [ 6 ] = _mm_add_epi32 ( v [ 6 ] , v [ 14 ] ) ;\n u [ 7 ] = _mm_add_epi32 ( v [ 7 ] , v [ 15 ] ) ;\n u [ 8 ] = _mm_sub_epi32 ( v [ 0 ] , v [ 8 ] ) ;\n u [ 9 ] = _mm_sub_epi32 ( v [ 1 ] , v [ 9 ] ) ;\n u [ 10 ] = _mm_sub_epi32 ( v [ 2 ] , v [ 10 ] ) ;\n u [ 11 ] = _mm_sub_epi32 ( v [ 3 ] , v [ 11 ] ) ;\n u [ 12 ] = _mm_sub_epi32 ( v [ 4 ] , v [ 12 ] ) ;\n u [ 13 ] = _mm_sub_epi32 ( v [ 5 ] , v [ 13 ] ) ;\n u [ 14 ] = _mm_sub_epi32 ( v [ 6 ] , v [ 14 ] ) ;\n u [ 15 ] = _mm_sub_epi32 ( v [ 7 ] , v [ 15 ] ) ;\n v [ 0 ] = _mm_add_epi32 ( u [ 0 ] , k__DCT_CONST_ROUNDING ) ;\n v [ 1 ] = _mm_add_epi32 ( u [ 1 ] , k__DCT_CONST_ROUNDING ) ;\n v [ 2 ] = _mm_add_epi32 ( u [ 2 ] , k__DCT_CONST_ROUNDING ) ;\n v [ 3 ] = _mm_add_epi32 ( u [ 3 ] , k__DCT_CONST_ROUNDING ) ;\n v [ 4 ] = _mm_add_epi32 ( u [ 4 ] , k__DCT_CONST_ROUNDING ) ;\n v [ 5 ] = _mm_add_epi32 ( u [ 5 ] , k__DCT_CONST_ROUNDING ) ;\n v [ 6 ] = _mm_add_epi32 ( u [ 6 ] , k__DCT_CONST_ROUNDING ) ;\n v [ 7 ] = _mm_add_epi32 ( u [ 7 ] , k__DCT_CONST_ROUNDING ) ;\n v [ 8 ] = _mm_add_epi32 ( u [ 8 ] , k__DCT_CONST_ROUNDING ) ;\n v [ 9 ] = _mm_add_epi32 ( u [ 9 ] , k__DCT_CONST_ROUNDING ) ;\n v [ 10 ] = _mm_add_epi32 ( u [ 10 ] , k__DCT_CONST_ROUNDING ) ;\n v [ 11 ] = _mm_add_epi32 ( u [ 11 ] , k__DCT_CONST_ROUNDING ) ;\n v [ 12 ] = _mm_add_epi32 ( u [ 12 ] , k__DCT_CONST_ROUNDING ) ;\n v [ 13 ] = _mm_add_epi32 ( u [ 13 ] , k__DCT_CONST_ROUNDING ) ;\n v [ 14 ] = _mm_add_epi32 ( u [ 14 ] , k__DCT_CONST_ROUNDING ) ;\n v [ 15 ] = _mm_add_epi32 ( u [ 15 ] , k__DCT_CONST_ROUNDING ) ;\n u [ 0 ] = _mm_srai_epi32 ( v [ 0 ] , DCT_CONST_BITS ) ;\n u [ 1 ] = _mm_srai_epi32 ( v [ 1 ] , DCT_CONST_BITS ) ;\n u [ 2 ] = _mm_srai_epi32 ( v [ 2 ] , DCT_CONST_BITS ) ;\n u [ 3 ] = _mm_srai_epi32 ( v [ 3 ] , DCT_CONST_BITS ) ;\n u [ 4 ] = _mm_srai_epi32 ( v [ 4 ] , DCT_CONST_BITS ) ;\n u [ 5 ] = _mm_srai_epi32 ( v [ 5 ] , DCT_CONST_BITS ) ;\n u [ 6 ] = _mm_srai_epi32 ( v [ 6 ] , DCT_CONST_BITS ) ;\n u [ 7 ] = _mm_srai_epi32 ( v [ 7 ] , DCT_CONST_BITS ) ;\n u [ 8 ] = _mm_srai_epi32 ( v [ 8 ] , DCT_CONST_BITS ) ;\n u [ 9 ] = _mm_srai_epi32 ( v [ 9 ] , DCT_CONST_BITS ) ;\n u [ 10 ] = _mm_srai_epi32 ( v [ 10 ] , DCT_CONST_BITS ) ;\n u [ 11 ] = _mm_srai_epi32 ( v [ 11 ] , DCT_CONST_BITS ) ;\n u [ 12 ] = _mm_srai_epi32 ( v [ 12 ] , DCT_CONST_BITS ) ;\n u [ 13 ] = _mm_srai_epi32 ( v [ 13 ] , DCT_CONST_BITS ) ;\n u [ 14 ] = _mm_srai_epi32 ( v [ 14 ] , DCT_CONST_BITS ) ;\n u [ 15 ] = _mm_srai_epi32 ( v [ 15 ] , DCT_CONST_BITS ) ;\n x [ 0 ] = _mm_add_epi16 ( s [ 0 ] , s [ 4 ] ) ;\n x [ 1 ] = _mm_add_epi16 ( s [ 1 ] , s [ 5 ] ) ;\n x [ 2 ] = _mm_add_epi16 ( s [ 2 ] , s [ 6 ] ) ;\n x [ 3 ] = _mm_add_epi16 ( s [ 3 ] , s [ 7 ] ) ;\n x [ 4 ] = _mm_sub_epi16 ( s [ 0 ] , s [ 4 ] ) ;\n x [ 5 ] = _mm_sub_epi16 ( s [ 1 ] , s [ 5 ] ) ;\n x [ 6 ] = _mm_sub_epi16 ( s [ 2 ] , s [ 6 ] ) ;\n x [ 7 ] = _mm_sub_epi16 ( s [ 3 ] , s [ 7 ] ) ;\n x [ 8 ] = _mm_packs_epi32 ( u [ 0 ] , u [ 1 ] ) ;\n x [ 9 ] = _mm_packs_epi32 ( u [ 2 ] , u [ 3 ] ) ;\n x [ 10 ] = _mm_packs_epi32 ( u [ 4 ] , u [ 5 ] ) ;\n x [ 11 ] = _mm_packs_epi32 ( u [ 6 ] , u [ 7 ] ) ;\n x [ 12 ] = _mm_packs_epi32 ( u [ 8 ] , u [ 9 ] ) ;\n x [ 13 ] = _mm_packs_epi32 ( u [ 10 ] , u [ 11 ] ) ;\n x [ 14 ] = _mm_packs_epi32 ( u [ 12 ] , u [ 13 ] ) ;\n x [ 15 ] = _mm_packs_epi32 ( u [ 14 ] , u [ 15 ] ) ;\n u [ 0 ] = _mm_unpacklo_epi16 ( x [ 4 ] , x [ 5 ] ) ;\n u [ 1 ] = _mm_unpackhi_epi16 ( x [ 4 ] , x [ 5 ] ) ;\n u [ 2 ] = _mm_unpacklo_epi16 ( x [ 6 ] , x [ 7 ] ) ;\n u [ 3 ] = _mm_unpackhi_epi16 ( x [ 6 ] , x [ 7 ] ) ;\n u [ 4 ] = _mm_unpacklo_epi16 ( x [ 12 ] , x [ 13 ] ) ;\n u [ 5 ] = _mm_unpackhi_epi16 ( x [ 12 ] , x [ 13 ] ) ;\n u [ 6 ] = _mm_unpacklo_epi16 ( x [ 14 ] , x [ 15 ] ) ;\n u [ 7 ] = _mm_unpackhi_epi16 ( x [ 14 ] , x [ 15 ] ) ;\n v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p08_p24 ) ;\n v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p08_p24 ) ;\n v [ 2 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p24_m08 ) ;\n v [ 3 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p24_m08 ) ;\n v [ 4 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_m24_p08 ) ;\n v [ 5 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_m24_p08 ) ;\n v [ 6 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p08_p24 ) ;\n v [ 7 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p08_p24 ) ;\n v [ 8 ] = _mm_madd_epi16 ( u [ 4 ] , k__cospi_p08_p24 ) ;\n v [ 9 ] = _mm_madd_epi16 ( u [ 5 ] , k__cospi_p08_p24 ) ;\n v [ 10 ] = _mm_madd_epi16 ( u [ 4 ] , k__cospi_p24_m08 ) ;\n v [ 11 ] = _mm_madd_epi16 ( u [ 5 ] , k__cospi_p24_m08 ) ;\n v [ 12 ] = _mm_madd_epi16 ( u [ 6 ] , k__cospi_m24_p08 ) ;\n v [ 13 ] = _mm_madd_epi16 ( u [ 7 ] , k__cospi_m24_p08 ) ;\n v [ 14 ] = _mm_madd_epi16 ( u [ 6 ] , k__cospi_p08_p24 ) ;\n v [ 15 ] = _mm_madd_epi16 ( u [ 7 ] , k__cospi_p08_p24 ) ;\n u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , v [ 4 ] ) ;\n u [ 1 ] = _mm_add_epi32 ( v [ 1 ] , v [ 5 ] ) ;\n u [ 2 ] = _mm_add_epi32 ( v [ 2 ] , v [ 6 ] ) ;\n u [ 3 ] = _mm_add_epi32 ( v [ 3 ] , v [ 7 ] ) ;\n u [ 4 ] = _mm_sub_epi32 ( v [ 0 ] , v [ 4 ] ) ;\n u [ 5 ] = _mm_sub_epi32 ( v [ 1 ] , v [ 5 ] ) ;\n u [ 6 ] = _mm_sub_epi32 ( v [ 2 ] , v [ 6 ] ) ;\n u [ 7 ] = _mm_sub_epi32 ( v [ 3 ] , v [ 7 ] ) ;\n u [ 8 ] = _mm_add_epi32 ( v [ 8 ] , v [ 12 ] ) ;\n u [ 9 ] = _mm_add_epi32 ( v [ 9 ] , v [ 13 ] ) ;\n u [ 10 ] = _mm_add_epi32 ( v [ 10 ] , v [ 14 ] ) ;\n u [ 11 ] = _mm_add_epi32 ( v [ 11 ] , v [ 15 ] ) ;\n u [ 12 ] = _mm_sub_epi32 ( v [ 8 ] , v [ 12 ] ) ;\n u [ 13 ] = _mm_sub_epi32 ( v [ 9 ] , v [ 13 ] ) ;\n u [ 14 ] = _mm_sub_epi32 ( v [ 10 ] , v [ 14 ] ) ;\n u [ 15 ] = _mm_sub_epi32 ( v [ 11 ] , v [ 15 ] ) ;\n u [ 0 ] = _mm_add_epi32 ( u [ 0 ] , k__DCT_CONST_ROUNDING ) ;\n u [ 1 ] = _mm_add_epi32 ( u [ 1 ] , k__DCT_CONST_ROUNDING ) ;\n u [ 2 ] = _mm_add_epi32 ( u [ 2 ] , k__DCT_CONST_ROUNDING ) ;\n u [ 3 ] = _mm_add_epi32 ( u [ 3 ] , k__DCT_CONST_ROUNDING ) ;\n u [ 4 ] = _mm_add_epi32 ( u [ 4 ] , k__DCT_CONST_ROUNDING ) ;\n u [ 5 ] = _mm_add_epi32 ( u [ 5 ] , k__DCT_CONST_ROUNDING ) ;\n u [ 6 ] = _mm_add_epi32 ( u [ 6 ] , k__DCT_CONST_ROUNDING ) ;\n u [ 7 ] = _mm_add_epi32 ( u [ 7 ] , k__DCT_CONST_ROUNDING ) ;\n u [ 8 ] = _mm_add_epi32 ( u [ 8 ] , k__DCT_CONST_ROUNDING ) ;\n u [ 9 ] = _mm_add_epi32 ( u [ 9 ] , k__DCT_CONST_ROUNDING ) ;\n u [ 10 ] = _mm_add_epi32 ( u [ 10 ] , k__DCT_CONST_ROUNDING ) ;\n u [ 11 ] = _mm_add_epi32 ( u [ 11 ] , k__DCT_CONST_ROUNDING ) ;\n u [ 12 ] = _mm_add_epi32 ( u [ 12 ] , k__DCT_CONST_ROUNDING ) ;\n u [ 13 ] = _mm_add_epi32 ( u [ 13 ] , k__DCT_CONST_ROUNDING ) ;\n u [ 14 ] = _mm_add_epi32 ( u [ 14 ] , k__DCT_CONST_ROUNDING ) ;\n u [ 15 ] = _mm_add_epi32 ( u [ 15 ] , k__DCT_CONST_ROUNDING ) ;\n v [ 0 ] = _mm_srai_epi32 ( u [ 0 ] , DCT_CONST_BITS ) ;\n v [ 1 ] = _mm_srai_epi32 ( u [ 1 ] , DCT_CONST_BITS ) ;\n v [ 2 ] = _mm_srai_epi32 ( u [ 2 ] , DCT_CONST_BITS ) ;\n v [ 3 ] = _mm_srai_epi32 ( u [ 3 ] , DCT_CONST_BITS ) ;\n v [ 4 ] = _mm_srai_epi32 ( u [ 4 ] , DCT_CONST_BITS ) ;\n v [ 5 ] = _mm_srai_epi32 ( u [ 5 ] , DCT_CONST_BITS ) ;\n v [ 6 ] = _mm_srai_epi32 ( u [ 6 ] , DCT_CONST_BITS ) ;\n v [ 7 ] = _mm_srai_epi32 ( u [ 7 ] , DCT_CONST_BITS ) ;\n v [ 8 ] = _mm_srai_epi32 ( u [ 8 ] , DCT_CONST_BITS ) ;\n v [ 9 ] = _mm_srai_epi32 ( u [ 9 ] , DCT_CONST_BITS ) ;\n v [ 10 ] = _mm_srai_epi32 ( u [ 10 ] , DCT_CONST_BITS ) ;\n v [ 11 ] = _mm_srai_epi32 ( u [ 11 ] , DCT_CONST_BITS ) ;\n v [ 12 ] = _mm_srai_epi32 ( u [ 12 ] , DCT_CONST_BITS ) ;\n v [ 13 ] = _mm_srai_epi32 ( u [ 13 ] , DCT_CONST_BITS ) ;\n v [ 14 ] = _mm_srai_epi32 ( u [ 14 ] , DCT_CONST_BITS ) ;\n v [ 15 ] = _mm_srai_epi32 ( u [ 15 ] , DCT_CONST_BITS ) ;\n s [ 0 ] = _mm_add_epi16 ( x [ 0 ] , x [ 2 ] ) ;\n s [ 1 ] = _mm_add_epi16 ( x [ 1 ] , x [ 3 ] ) ;\n s [ 2 ] = _mm_sub_epi16 ( x [ 0 ] , x [ 2 ] ) ;\n s [ 3 ] = _mm_sub_epi16 ( x [ 1 ] , x [ 3 ] ) ;\n s [ 4 ] = _mm_packs_epi32 ( v [ 0 ] , v [ 1 ] ) ;\n s [ 5 ] = _mm_packs_epi32 ( v [ 2 ] , v [ 3 ] ) ;\n s [ 6 ] = _mm_packs_epi32 ( v [ 4 ] , v [ 5 ] ) ;\n s [ 7 ] = _mm_packs_epi32 ( v [ 6 ] , v [ 7 ] ) ;\n s [ 8 ] = _mm_add_epi16 ( x [ 8 ] , x [ 10 ] ) ;\n s [ 9 ] = _mm_add_epi16 ( x [ 9 ] , x [ 11 ] ) ;\n s [ 10 ] = _mm_sub_epi16 ( x [ 8 ] , x [ 10 ] ) ;\n s [ 11 ] = _mm_sub_epi16 ( x [ 9 ] , x [ 11 ] ) ;\n s [ 12 ] = _mm_packs_epi32 ( v [ 8 ] , v [ 9 ] ) ;\n s [ 13 ] = _mm_packs_epi32 ( v [ 10 ] , v [ 11 ] ) ;\n s [ 14 ] = _mm_packs_epi32 ( v [ 12 ] , v [ 13 ] ) ;\n s [ 15 ] = _mm_packs_epi32 ( v [ 14 ] , v [ 15 ] ) ;\n u [ 0 ] = _mm_unpacklo_epi16 ( s [ 2 ] , s [ 3 ] ) ;\n u [ 1 ] = _mm_unpackhi_epi16 ( s [ 2 ] , s [ 3 ] ) ;\n u [ 2 ] = _mm_unpacklo_epi16 ( s [ 6 ] , s [ 7 ] ) ;\n u [ 3 ] = _mm_unpackhi_epi16 ( s [ 6 ] , s [ 7 ] ) ;\n u [ 4 ] = _mm_unpacklo_epi16 ( s [ 10 ] , s [ 11 ] ) ;\n u [ 5 ] = _mm_unpackhi_epi16 ( s [ 10 ] , s [ 11 ] ) ;\n u [ 6 ] = _mm_unpacklo_epi16 ( s [ 14 ] , s [ 15 ] ) ;\n u [ 7 ] = _mm_unpackhi_epi16 ( s [ 14 ] , s [ 15 ] ) ;\n v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_m16_m16 ) ;\n v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_m16_m16 ) ;\n v [ 2 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p16_m16 ) ;\n v [ 3 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p16_m16 ) ;\n v [ 4 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p16_p16 ) ;\n v [ 5 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p16_p16 ) ;\n v [ 6 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_m16_p16 ) ;\n v [ 7 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_m16_p16 ) ;\n v [ 8 ] = _mm_madd_epi16 ( u [ 4 ] , k__cospi_p16_p16 ) ;\n v [ 9 ] = _mm_madd_epi16 ( u [ 5 ] , k__cospi_p16_p16 ) ;\n v [ 10 ] = _mm_madd_epi16 ( u [ 4 ] , k__cospi_m16_p16 ) ;\n v [ 11 ] = _mm_madd_epi16 ( u [ 5 ] , k__cospi_m16_p16 ) ;\n v [ 12 ] = _mm_madd_epi16 ( u [ 6 ] , k__cospi_m16_m16 ) ;\n v [ 13 ] = _mm_madd_epi16 ( u [ 7 ] , k__cospi_m16_m16 ) ;\n v [ 14 ] = _mm_madd_epi16 ( u [ 6 ] , k__cospi_p16_m16 ) ;\n v [ 15 ] = _mm_madd_epi16 ( u [ 7 ] , k__cospi_p16_m16 ) ;\n u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , k__DCT_CONST_ROUNDING ) ;\n u [ 1 ] = _mm_add_epi32 ( v [ 1 ] , k__DCT_CONST_ROUNDING ) ;\n u [ 2 ] = _mm_add_epi32 ( v [ 2 ] , k__DCT_CONST_ROUNDING ) ;\n u [ 3 ] = _mm_add_epi32 ( v [ 3 ] , k__DCT_CONST_ROUNDING ) ;\n u [ 4 ] = _mm_add_epi32 ( v [ 4 ] , k__DCT_CONST_ROUNDING ) ;\n u [ 5 ] = _mm_add_epi32 ( v [ 5 ] , k__DCT_CONST_ROUNDING ) ;\n u [ 6 ] = _mm_add_epi32 ( v [ 6 ] , k__DCT_CONST_ROUNDING ) ;\n u [ 7 ] = _mm_add_epi32 ( v [ 7 ] , k__DCT_CONST_ROUNDING ) ;\n u [ 8 ] = _mm_add_epi32 ( v [ 8 ] , k__DCT_CONST_ROUNDING ) ;\n u [ 9 ] = _mm_add_epi32 ( v [ 9 ] , k__DCT_CONST_ROUNDING ) ;\n u [ 10 ] = _mm_add_epi32 ( v [ 10 ] , k__DCT_CONST_ROUNDING ) ;\n u [ 11 ] = _mm_add_epi32 ( v [ 11 ] , k__DCT_CONST_ROUNDING ) ;\n u [ 12 ] = _mm_add_epi32 ( v [ 12 ] , k__DCT_CONST_ROUNDING ) ;\n u [ 13 ] = _mm_add_epi32 ( v [ 13 ] , k__DCT_CONST_ROUNDING ) ;\n u [ 14 ] = _mm_add_epi32 ( v [ 14 ] , k__DCT_CONST_ROUNDING ) ;\n u [ 15 ] = _mm_add_epi32 ( v [ 15 ] , k__DCT_CONST_ROUNDING ) ;\n v [ 0 ] = _mm_srai_epi32 ( u [ 0 ] , DCT_CONST_BITS ) ;\n v [ 1 ] = _mm_srai_epi32 ( u [ 1 ] , DCT_CONST_BITS ) ;\n v [ 2 ] = _mm_srai_epi32 ( u [ 2 ] , DCT_CONST_BITS ) ;\n v [ 3 ] = _mm_srai_epi32 ( u [ 3 ] , DCT_CONST_BITS ) ;\n v [ 4 ] = _mm_srai_epi32 ( u [ 4 ] , DCT_CONST_BITS ) ;\n v [ 5 ] = _mm_srai_epi32 ( u [ 5 ] , DCT_CONST_BITS ) ;\n v [ 6 ] = _mm_srai_epi32 ( u [ 6 ] , DCT_CONST_BITS ) ;\n v [ 7 ] = _mm_srai_epi32 ( u [ 7 ] , DCT_CONST_BITS ) ;\n v [ 8 ] = _mm_srai_epi32 ( u [ 8 ] , DCT_CONST_BITS ) ;\n v [ 9 ] = _mm_srai_epi32 ( u [ 9 ] , DCT_CONST_BITS ) ;\n v [ 10 ] = _mm_srai_epi32 ( u [ 10 ] , DCT_CONST_BITS ) ;\n v [ 11 ] = _mm_srai_epi32 ( u [ 11 ] , DCT_CONST_BITS ) ;\n v [ 12 ] = _mm_srai_epi32 ( u [ 12 ] , DCT_CONST_BITS ) ;\n v [ 13 ] = _mm_srai_epi32 ( u [ 13 ] , DCT_CONST_BITS ) ;\n v [ 14 ] = _mm_srai_epi32 ( u [ 14 ] , DCT_CONST_BITS ) ;\n v [ 15 ] = _mm_srai_epi32 ( u [ 15 ] , DCT_CONST_BITS ) ;\n in [ 0 ] = s [ 0 ] ;\n in [ 1 ] = _mm_sub_epi16 ( kZero , s [ 8 ] ) ;\n in [ 2 ] = s [ 12 ] ;\n in [ 3 ] = _mm_sub_epi16 ( kZero , s [ 4 ] ) ;\n in [ 4 ] = _mm_packs_epi32 ( v [ 4 ] , v [ 5 ] ) ;\n in [ 5 ] = _mm_packs_epi32 ( v [ 12 ] , v [ 13 ] ) ;\n in [ 6 ] = _mm_packs_epi32 ( v [ 8 ] , v [ 9 ] ) ;\n in [ 7 ] = _mm_packs_epi32 ( v [ 0 ] , v [ 1 ] ) ;\n in [ 8 ] = _mm_packs_epi32 ( v [ 2 ] , v [ 3 ] ) ;\n in [ 9 ] = _mm_packs_epi32 ( v [ 10 ] , v [ 11 ] ) ;\n in [ 10 ] = _mm_packs_epi32 ( v [ 14 ] , v [ 15 ] ) ;\n in [ 11 ] = _mm_packs_epi32 ( v [ 6 ] , v [ 7 ] ) ;\n in [ 12 ] = s [ 5 ] ;\n in [ 13 ] = _mm_sub_epi16 ( kZero , s [ 13 ] ) ;\n in [ 14 ] = s [ 9 ] ;\n in [ 15 ] = _mm_sub_epi16 ( kZero , s [ 1 ] ) ;\n }", "idx": 21054}
{"hash": 2755982813601944893, "project": "debian", "size": 24, "label": 0, "functionSource": "static void dec_gain ( TwinContext * tctx , GetBitContext * gb , enum FrameType ftype , float * out ) {\n const ModeTab * mtab = tctx -> mtab ;\n int i , j ;\n int sub = mtab -> fmode [ ftype ] . sub ;\n float step = AMP_MAX / ( ( 1 << GAIN_BITS ) - 1 ) ;\n float sub_step = SUB_AMP_MAX / ( ( 1 << SUB_GAIN_BITS ) - 1 ) ;\n if ( ftype == FT_LONG ) {\n for ( i = 0 ;\n i < tctx -> avctx -> channels ;\n i ++ ) out [ i ] = ( 1. / ( 1 << 13 ) ) * mulawinv ( step * 0.5 + step * get_bits ( gb , GAIN_BITS ) , AMP_MAX , MULAW_MU ) ;\n }\n else {\n for ( i = 0 ;\n i < tctx -> avctx -> channels ;\n i ++ ) {\n float val = ( 1. / ( 1 << 23 ) ) * mulawinv ( step * 0.5 + step * get_bits ( gb , GAIN_BITS ) , AMP_MAX , MULAW_MU ) ;\n for ( j = 0 ;\n j < sub ;\n j ++ ) {\n out [ i * sub + j ] = val * mulawinv ( sub_step * 0.5 + sub_step * get_bits ( gb , SUB_GAIN_BITS ) , SUB_AMP_MAX , MULAW_MU ) ;\n }\n }\n }\n }", "idx": 21055}
{"hash": 1223258652239369123, "project": "debian", "size": 12, "label": 0, "functionSource": "static void spl_filesystem_file_rewind ( zval * this_ptr , spl_filesystem_object * intern TSRMLS_DC ) {\n if ( - 1 == php_stream_rewind ( intern -> u . file . stream ) ) {\n zend_throw_exception_ex ( spl_ce_RuntimeException , 0 TSRMLS_CC , \"Cannot rewind file %s\" , intern -> file_name ) ;\n }\n else {\n spl_filesystem_file_free_line ( intern TSRMLS_CC ) ;\n intern -> u . file . current_line_num = 0 ;\n }\n if ( SPL_HAS_FLAG ( intern -> flags , SPL_FILE_OBJECT_READ_AHEAD ) ) {\n spl_filesystem_file_read_line ( this_ptr , intern , 1 TSRMLS_CC ) ;\n }\n }", "idx": 21056}
{"hash": -5268859819325807498, "project": "debian", "size": 20, "label": 0, "functionSource": "void nautilus_directory_get_info_for_new_files ( NautilusDirectory * directory , GList * location_list ) {\n NewFilesState * state ;\n GFile * location ;\n GList * l ;\n if ( location_list == NULL ) {\n return ;\n }\n state = g_new ( NewFilesState , 1 ) ;\n state -> directory = directory ;\n state -> cancellable = g_cancellable_new ( ) ;\n state -> count = 0 ;\n for ( l = location_list ;\n l != NULL ;\n l = l -> next ) {\n location = l -> data ;\n state -> count ++ ;\n g_file_query_info_async ( location , NAUTILUS_FILE_DEFAULT_ATTRIBUTES , 0 , G_PRIORITY_DEFAULT , state -> cancellable , new_files_callback , state ) ;\n }\n directory -> details -> new_files_in_progress = g_list_prepend ( directory -> details -> new_files_in_progress , state ) ;\n }", "idx": 21057}
{"hash": -5697857125570093892, "project": "chrome", "size": 9, "label": 0, "functionSource": "static UBool _isScriptSubtag ( const char * s , int32_t len ) {\n if ( len < 0 ) {\n len = ( int32_t ) uprv_strlen ( s ) ;\n }\n if ( len == 4 && _isAlphaString ( s , len ) ) {\n return TRUE ;\n }\n return FALSE ;\n }", "idx": 21058}
{"hash": -454486177854888036, "project": "debian", "size": 27, "label": 0, "functionSource": "static void model_update ( Model * m , int val ) {\n int i , sum = 0 ;\n unsigned scale ;\n m -> weights [ val ] ++ ;\n m -> till_rescale -- ;\n if ( m -> till_rescale ) return ;\n m -> tot_weight += m -> upd_val ;\n if ( m -> tot_weight > 0x8000 ) {\n m -> tot_weight = 0 ;\n for ( i = 0 ;\n i < m -> num_syms ;\n i ++ ) {\n m -> weights [ i ] = ( m -> weights [ i ] + 1 ) >> 1 ;\n m -> tot_weight += m -> weights [ i ] ;\n }\n }\n scale = 0x80000000u / m -> tot_weight ;\n for ( i = 0 ;\n i < m -> num_syms ;\n i ++ ) {\n m -> freqs [ i ] = sum * scale >> 16 ;\n sum += m -> weights [ i ] ;\n }\n m -> upd_val = m -> upd_val * 5 >> 2 ;\n if ( m -> upd_val > m -> max_upd_val ) m -> upd_val = m -> max_upd_val ;\n m -> till_rescale = m -> upd_val ;\n }", "idx": 21059}
{"hash": 7279312193592248512, "project": "debian", "size": 40, "label": 0, "functionSource": "void ff_cavs_load_intra_pred_luma ( AVSContext * h , uint8_t * top , uint8_t * * left , int block ) {\n int i ;\n switch ( block ) {\n case 0 : * left = h -> left_border_y ;\n h -> left_border_y [ 0 ] = h -> left_border_y [ 1 ] ;\n memset ( & h -> left_border_y [ 17 ] , h -> left_border_y [ 16 ] , 9 ) ;\n memcpy ( & top [ 1 ] , & h -> top_border_y [ h -> mbx * 16 ] , 16 ) ;\n top [ 17 ] = top [ 16 ] ;\n top [ 0 ] = top [ 1 ] ;\n if ( ( h -> flags & A_AVAIL ) && ( h -> flags & B_AVAIL ) ) h -> left_border_y [ 0 ] = top [ 0 ] = h -> topleft_border_y ;\n break ;\n case 1 : * left = h -> intern_border_y ;\n for ( i = 0 ;\n i < 8 ;\n i ++ ) h -> intern_border_y [ i + 1 ] = * ( h -> cy + 7 + i * h -> l_stride ) ;\n memset ( & h -> intern_border_y [ 9 ] , h -> intern_border_y [ 8 ] , 9 ) ;\n h -> intern_border_y [ 0 ] = h -> intern_border_y [ 1 ] ;\n memcpy ( & top [ 1 ] , & h -> top_border_y [ h -> mbx * 16 + 8 ] , 8 ) ;\n if ( h -> flags & C_AVAIL ) memcpy ( & top [ 9 ] , & h -> top_border_y [ ( h -> mbx + 1 ) * 16 ] , 8 ) ;\n else memset ( & top [ 9 ] , top [ 8 ] , 9 ) ;\n top [ 17 ] = top [ 16 ] ;\n top [ 0 ] = top [ 1 ] ;\n if ( h -> flags & B_AVAIL ) h -> intern_border_y [ 0 ] = top [ 0 ] = h -> top_border_y [ h -> mbx * 16 + 7 ] ;\n break ;\n case 2 : * left = & h -> left_border_y [ 8 ] ;\n memcpy ( & top [ 1 ] , h -> cy + 7 * h -> l_stride , 16 ) ;\n top [ 17 ] = top [ 16 ] ;\n top [ 0 ] = top [ 1 ] ;\n if ( h -> flags & A_AVAIL ) top [ 0 ] = h -> left_border_y [ 8 ] ;\n break ;\n case 3 : * left = & h -> intern_border_y [ 8 ] ;\n for ( i = 0 ;\n i < 8 ;\n i ++ ) h -> intern_border_y [ i + 9 ] = * ( h -> cy + 7 + ( i + 8 ) * h -> l_stride ) ;\n memset ( & h -> intern_border_y [ 17 ] , h -> intern_border_y [ 16 ] , 9 ) ;\n memcpy ( & top [ 0 ] , h -> cy + 7 + 7 * h -> l_stride , 9 ) ;\n memset ( & top [ 9 ] , top [ 8 ] , 9 ) ;\n break ;\n }\n }", "idx": 21060}
{"hash": -5018047422955641881, "project": "debian", "size": 3, "label": 0, "functionSource": "static void s390_machine_init ( void ) {\n qemu_register_machine ( & s390_machine ) ;\n }", "idx": 21061}
{"hash": 2713698759296604855, "project": "debian", "size": 6, "label": 0, "functionSource": "static inline void add_dequant_dct ( MpegEncContext * s , int16_t * block , int i , uint8_t * dest , int line_size , int qscale ) {\n if ( s -> block_last_index [ i ] >= 0 ) {\n s -> dct_unquantize_inter ( s , block , i , qscale ) ;\n s -> dsp . idct_add ( dest , line_size , block ) ;\n }\n }", "idx": 21062}
{"hash": -7553540414561818627, "project": "debian", "size": 136, "label": 0, "functionSource": "int main ( int argc , char * argv [ ] ) {\n BN_CTX * ctx ;\n BIO * out ;\n char * outfile = NULL ;\n results = 0 ;\n RAND_seed ( rnd_seed , sizeof rnd_seed ) ;\n argc -- ;\n argv ++ ;\n while ( argc >= 1 ) {\n if ( strcmp ( * argv , \"-results\" ) == 0 ) results = 1 ;\n else if ( strcmp ( * argv , \"-out\" ) == 0 ) {\n if ( -- argc < 1 ) break ;\n outfile = * ( ++ argv ) ;\n }\n argc -- ;\n argv ++ ;\n }\n ctx = BN_CTX_new ( ) ;\n if ( ctx == NULL ) EXIT ( 1 ) ;\n out = BIO_new ( BIO_s_file ( ) ) ;\n if ( out == NULL ) EXIT ( 1 ) ;\n if ( outfile == NULL ) {\n BIO_set_fp ( out , stdout , BIO_NOCLOSE ) ;\n }\n else {\n if ( ! BIO_write_filename ( out , outfile ) ) {\n perror ( outfile ) ;\n EXIT ( 1 ) ;\n }\n }\n if ( ! results ) BIO_puts ( out , \"obase=16\\nibase=16\\n\" ) ;\n message ( out , \"BN_add\" ) ;\n if ( ! test_add ( out ) ) goto err ;\n ( void ) BIO_flush ( out ) ;\n message ( out , \"BN_sub\" ) ;\n if ( ! test_sub ( out ) ) goto err ;\n ( void ) BIO_flush ( out ) ;\n message ( out , \"BN_lshift1\" ) ;\n if ( ! test_lshift1 ( out ) ) goto err ;\n ( void ) BIO_flush ( out ) ;\n message ( out , \"BN_lshift (fixed)\" ) ;\n if ( ! test_lshift ( out , ctx , BN_bin2bn ( lst , sizeof ( lst ) - 1 , NULL ) ) ) goto err ;\n ( void ) BIO_flush ( out ) ;\n message ( out , \"BN_lshift\" ) ;\n if ( ! test_lshift ( out , ctx , NULL ) ) goto err ;\n ( void ) BIO_flush ( out ) ;\n message ( out , \"BN_rshift1\" ) ;\n if ( ! test_rshift1 ( out ) ) goto err ;\n ( void ) BIO_flush ( out ) ;\n message ( out , \"BN_rshift\" ) ;\n if ( ! test_rshift ( out , ctx ) ) goto err ;\n ( void ) BIO_flush ( out ) ;\n message ( out , \"BN_sqr\" ) ;\n if ( ! test_sqr ( out , ctx ) ) goto err ;\n ( void ) BIO_flush ( out ) ;\n message ( out , \"BN_mul\" ) ;\n if ( ! test_mul ( out ) ) goto err ;\n ( void ) BIO_flush ( out ) ;\n message ( out , \"BN_div\" ) ;\n if ( ! test_div ( out , ctx ) ) goto err ;\n ( void ) BIO_flush ( out ) ;\n message ( out , \"BN_div_word\" ) ;\n if ( ! test_div_word ( out ) ) goto err ;\n ( void ) BIO_flush ( out ) ;\n message ( out , \"BN_div_recp\" ) ;\n if ( ! test_div_recp ( out , ctx ) ) goto err ;\n ( void ) BIO_flush ( out ) ;\n message ( out , \"BN_mod\" ) ;\n if ( ! test_mod ( out , ctx ) ) goto err ;\n ( void ) BIO_flush ( out ) ;\n message ( out , \"BN_mod_mul\" ) ;\n if ( ! test_mod_mul ( out , ctx ) ) goto err ;\n ( void ) BIO_flush ( out ) ;\n message ( out , \"BN_mont\" ) ;\n if ( ! test_mont ( out , ctx ) ) goto err ;\n ( void ) BIO_flush ( out ) ;\n message ( out , \"BN_mod_exp\" ) ;\n if ( ! test_mod_exp ( out , ctx ) ) goto err ;\n ( void ) BIO_flush ( out ) ;\n message ( out , \"BN_mod_exp_mont_consttime\" ) ;\n if ( ! test_mod_exp_mont_consttime ( out , ctx ) ) goto err ;\n if ( ! test_mod_exp_mont5 ( out , ctx ) ) goto err ;\n ( void ) BIO_flush ( out ) ;\n message ( out , \"BN_exp\" ) ;\n if ( ! test_exp ( out , ctx ) ) goto err ;\n ( void ) BIO_flush ( out ) ;\n message ( out , \"BN_kronecker\" ) ;\n if ( ! test_kron ( out , ctx ) ) goto err ;\n ( void ) BIO_flush ( out ) ;\n message ( out , \"BN_mod_sqrt\" ) ;\n if ( ! test_sqrt ( out , ctx ) ) goto err ;\n ( void ) BIO_flush ( out ) ;\n message ( out , \"Small prime generation\" ) ;\n if ( ! test_small_prime ( out , ctx ) ) goto err ;\n ( void ) BIO_flush ( out ) ;\n # ifdef OPENSSL_SYS_WIN32 message ( out , \"Probable prime generation with coprimes disabled\" ) ;\n # else message ( out , \"Probable prime generation with coprimes\" ) ;\n if ( ! test_probable_prime_coprime ( out , ctx ) ) goto err ;\n # endif ( void ) BIO_flush ( out ) ;\n # ifndef OPENSSL_NO_EC2M message ( out , \"BN_GF2m_add\" ) ;\n if ( ! test_gf2m_add ( out ) ) goto err ;\n ( void ) BIO_flush ( out ) ;\n message ( out , \"BN_GF2m_mod\" ) ;\n if ( ! test_gf2m_mod ( out ) ) goto err ;\n ( void ) BIO_flush ( out ) ;\n message ( out , \"BN_GF2m_mod_mul\" ) ;\n if ( ! test_gf2m_mod_mul ( out , ctx ) ) goto err ;\n ( void ) BIO_flush ( out ) ;\n message ( out , \"BN_GF2m_mod_sqr\" ) ;\n if ( ! test_gf2m_mod_sqr ( out , ctx ) ) goto err ;\n ( void ) BIO_flush ( out ) ;\n message ( out , \"BN_GF2m_mod_inv\" ) ;\n if ( ! test_gf2m_mod_inv ( out , ctx ) ) goto err ;\n ( void ) BIO_flush ( out ) ;\n message ( out , \"BN_GF2m_mod_div\" ) ;\n if ( ! test_gf2m_mod_div ( out , ctx ) ) goto err ;\n ( void ) BIO_flush ( out ) ;\n message ( out , \"BN_GF2m_mod_exp\" ) ;\n if ( ! test_gf2m_mod_exp ( out , ctx ) ) goto err ;\n ( void ) BIO_flush ( out ) ;\n message ( out , \"BN_GF2m_mod_sqrt\" ) ;\n if ( ! test_gf2m_mod_sqrt ( out , ctx ) ) goto err ;\n ( void ) BIO_flush ( out ) ;\n message ( out , \"BN_GF2m_mod_solve_quad\" ) ;\n if ( ! test_gf2m_mod_solve_quad ( out , ctx ) ) goto err ;\n ( void ) BIO_flush ( out ) ;\n # endif BN_CTX_free ( ctx ) ;\n BIO_free ( out ) ;\n EXIT ( 0 ) ;\n err : BIO_puts ( out , \"1\\n\" ) ;\n ( void ) BIO_flush ( out ) ;\n ERR_load_crypto_strings ( ) ;\n ERR_print_errors_fp ( stderr ) ;\n EXIT ( 1 ) ;\n return ( 1 ) ;\n }", "idx": 21063}
{"hash": -8830528631587258848, "project": "debian", "size": 9, "label": 0, "functionSource": "static void init_uncompress ( compress_filter_context_t * zfx , z_stream * zs ) {\n int rc ;\n if ( ( rc = zfx -> algo == 1 ? inflateInit2 ( zs , - 15 ) : inflateInit ( zs ) ) != Z_OK ) {\n log_fatal ( \"zlib problem: %s\\n\" , zs -> msg ? zs -> msg : rc == Z_MEM_ERROR ? \"out of core\" : rc == Z_VERSION_ERROR ? \"invalid lib version\" : \"unknown error\" ) ;\n }\n zfx -> inbufsize = 2048 ;\n zfx -> inbuf = xmalloc ( zfx -> inbufsize ) ;\n zs -> avail_in = 0 ;\n }", "idx": 21064}
{"hash": 378220832151730865, "project": "debian", "size": 32, "label": 0, "functionSource": "int qemuMonitorTextSetDrivePassphrase ( qemuMonitorPtr mon , const char * alias , const char * passphrase ) {\n char * cmd = NULL ;\n char * reply = NULL ;\n int ret = - 1 ;\n char * safe_str ;\n safe_str = qemuMonitorEscapeArg ( passphrase ) ;\n if ( ! safe_str ) {\n virReportOOMError ( ) ;\n return - 1 ;\n }\n if ( virAsprintf ( & cmd , \"block_passwd %s%s \\\"%s\\\"\" , QEMU_DRIVE_HOST_PREFIX , alias , safe_str ) < 0 ) {\n virReportOOMError ( ) ;\n goto cleanup ;\n }\n if ( qemuMonitorHMPCommand ( mon , cmd , & reply ) < 0 ) {\n qemuReportError ( VIR_ERR_OPERATION_FAILED , \"%s\" , _ ( \"failed to set disk password\" ) ) ;\n goto cleanup ;\n }\n if ( strstr ( reply , \"unknown command:\" ) ) {\n qemuReportError ( VIR_ERR_OPERATION_FAILED , \"%s\" , _ ( \"setting disk password is not supported\" ) ) ;\n goto cleanup ;\n }\n else if ( strstr ( reply , \"The entered password is invalid\" ) ) {\n qemuReportError ( VIR_ERR_OPERATION_FAILED , \"%s\" , _ ( \"the disk password is incorrect\" ) ) ;\n goto cleanup ;\n }\n ret = 0 ;\n cleanup : VIR_FREE ( cmd ) ;\n VIR_FREE ( reply ) ;\n VIR_FREE ( safe_str ) ;\n return ret ;\n }", "idx": 21065}
{"hash": 7039307292471244756, "project": "debian", "size": 15, "label": 0, "functionSource": "static void dtap_cc_disconnect ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len ) {\n guint32 curr_offset ;\n guint32 consumed ;\n guint curr_len ;\n curr_offset = offset ;\n curr_len = len ;\n is_uplink = IS_UPLINK_TRUE ;\n ELEM_MAND_LV ( GSM_A_PDU_TYPE_DTAP , DE_CAUSE , NULL ) ;\n ELEM_OPT_TLV ( 0x1c , GSM_A_PDU_TYPE_DTAP , DE_FACILITY , NULL ) ;\n ELEM_OPT_TLV ( 0x1e , GSM_A_PDU_TYPE_DTAP , DE_PROG_IND , NULL ) ;\n ELEM_OPT_TLV ( 0x7e , GSM_A_PDU_TYPE_DTAP , DE_USER_USER , NULL ) ;\n ELEM_OPT_TLV ( 0x7b , GSM_A_PDU_TYPE_DTAP , DE_ALLOWED_ACTIONS , NULL ) ;\n ELEM_OPT_TLV ( 0x7f , GSM_A_PDU_TYPE_DTAP , DE_SS_VER_IND , NULL ) ;\n EXTRANEOUS_DATA_CHECK ( curr_len , 0 , pinfo , & ei_gsm_a_dtap_extraneous_data ) ;\n }", "idx": 21066}
{"hash": -1672864273235910388, "project": "debian", "size": 11, "label": 0, "functionSource": "static void _slurm_rpc_sib_job_unlock ( uint32_t uid , slurm_msg_t * msg ) {\n int rc ;\n sib_msg_t * sib_msg = msg -> data ;\n if ( ! msg -> conn ) {\n error ( \"Security violation, SIB_JOB_UNLOCK RPC from uid=%d\" , uid ) ;\n slurm_send_rc_msg ( msg , ESLURM_ACCESS_DENIED ) ;\n return ;\n }\n rc = fed_mgr_job_lock_unset ( sib_msg -> job_id , sib_msg -> cluster_id ) ;\n slurm_send_rc_msg ( msg , rc ) ;\n }", "idx": 21067}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_T_pixelAspectCode ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_constrained_set_of ( tvb , offset , actx , tree , hf_index , ett_h245_T_pixelAspectCode , T_pixelAspectCode_set_of , 1 , 14 , FALSE ) ;\n return offset ;\n }", "idx": 21068}
{"hash": -8176848763607321091, "project": "chrome", "size": 5, "label": 0, "functionSource": "TEST_F ( HistoryQuickProviderTest , SimpleSingleMatch ) {\n std : : vector < std : : string > expected_urls ;\n expected_urls . push_back ( \"http://slashdot.org/favorite_page.html\" ) ;\n RunTest ( ASCIIToUTF16 ( \"slashdot\" ) , false , expected_urls , true , ASCIIToUTF16 ( \"slashdot.org/favorite_page.html\" ) , ASCIIToUTF16 ( \".org/favorite_page.html\" ) ) ;\n }", "idx": 21069}
{"hash": -6552851419396579257, "project": "debian", "size": 31, "label": 0, "functionSource": "static int SpoolssEnumPrinters_r ( tvbuff_t * tvb , int offset , packet_info * pinfo , proto_tree * tree , dcerpc_info * di , guint8 * drep _U_ ) {\n guint32 num_drivers ;\n dcerpc_call_value * dcv = ( dcerpc_call_value * ) di -> call_data ;\n gint16 level = GPOINTER_TO_INT ( dcv -> se_data ) ;\n BUFFER buffer ;\n proto_item * item ;\n proto_tree * subtree = NULL ;\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \", level %d\" , level ) ;\n offset = dissect_spoolss_buffer ( tvb , offset , pinfo , tree , di , drep , & buffer ) ;\n if ( buffer . tvb ) {\n subtree = proto_tree_add_subtree_format ( buffer . tree , buffer . tvb , 0 , - 1 , ett_PRINTER_INFO , & item , \"Print info level %d\" , level ) ;\n switch ( level ) {\n case 0 : dissect_PRINTER_INFO_0 ( buffer . tvb , 0 , pinfo , subtree , di , drep ) ;\n break ;\n case 1 : dissect_PRINTER_INFO_1 ( buffer . tvb , 0 , pinfo , subtree , di , drep ) ;\n break ;\n case 2 : dissect_PRINTER_INFO_2 ( buffer . tvb , 0 , pinfo , subtree , di , drep ) ;\n break ;\n case 3 : dissect_PRINTER_INFO_3 ( buffer . tvb , 0 , pinfo , subtree , di , drep ) ;\n break ;\n case 7 : dissect_PRINTER_INFO_7 ( buffer . tvb , 0 , pinfo , subtree , di , drep ) ;\n break ;\n default : expert_add_info ( pinfo , item , & ei_printer_info_level ) ;\n break ;\n }\n }\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , tree , di , drep , hf_needed , NULL ) ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , tree , di , drep , hf_returned , & num_drivers ) ;\n offset = dissect_doserror ( tvb , offset , pinfo , tree , di , drep , hf_rc , NULL ) ;\n return offset ;\n }", "idx": 21070}
{"hash": 2687336064028423153, "project": "chrome", "size": 46, "label": 0, "functionSource": "static void reply_handle ( struct request * const req , u16 flags , u32 ttl , struct reply * reply ) {\n int error ;\n static const int error_codes [ ] = {\n DNS_ERR_FORMAT , DNS_ERR_SERVERFAILED , DNS_ERR_NOTEXIST , DNS_ERR_NOTIMPL , DNS_ERR_REFUSED }\n ;\n if ( flags & 0x020f || ! reply || ! reply -> have_answer ) {\n if ( flags & 0x0200 ) {\n error = DNS_ERR_TRUNCATED ;\n }\n else {\n u16 error_code = ( flags & 0x000f ) - 1 ;\n if ( error_code > 4 ) {\n error = DNS_ERR_UNKNOWN ;\n }\n else {\n error = error_codes [ error_code ] ;\n }\n }\n switch ( error ) {\n case DNS_ERR_NOTIMPL : case DNS_ERR_REFUSED : if ( req -> reissue_count < global_max_reissues ) {\n char msg [ 64 ] ;\n evutil_snprintf ( msg , sizeof ( msg ) , \"Bad response %d (%s)\" , error , evdns_err_to_string ( error ) ) ;\n nameserver_failed ( req -> ns , msg ) ;\n if ( ! request_reissue ( req ) ) return ;\n }\n break ;\n case DNS_ERR_SERVERFAILED : log ( EVDNS_LOG_DEBUG , \"Got a SERVERFAILED from nameserver %s;\n \" \"will allow the request to time out.\" , debug_ntoa ( req -> ns -> address ) ) ;\n break ;\n default : nameserver_up ( req -> ns ) ;\n }\n if ( req -> search_state && req -> request_type != TYPE_PTR ) {\n if ( ! search_try_next ( req ) ) {\n request_finished ( req , & req_head ) ;\n return ;\n }\n }\n reply_callback ( req , 0 , error , NULL ) ;\n request_finished ( req , & req_head ) ;\n }\n else {\n reply_callback ( req , ttl , 0 , reply ) ;\n nameserver_up ( req -> ns ) ;\n request_finished ( req , & req_head ) ;\n }\n }", "idx": 21071}
{"hash": 8484475213808847345, "project": "debian", "size": 27, "label": 0, "functionSource": "DeviceState * qdev_create ( BusState * bus , const char * name ) {\n DeviceInfo * info ;\n DeviceState * dev ;\n if ( ! bus ) {\n if ( ! main_system_bus ) {\n main_system_bus = qbus_create ( & system_bus_info , NULL , \"main-system-bus\" ) ;\n }\n bus = main_system_bus ;\n }\n info = qdev_find_info ( bus -> info , name ) ;\n if ( ! info ) {\n hw_error ( \"Unknown device '%s' for bus '%s'\\n\" , name , bus -> info -> name ) ;\n }\n dev = qemu_mallocz ( info -> size ) ;\n dev -> info = info ;\n dev -> parent_bus = bus ;\n qdev_prop_set_defaults ( dev , dev -> info -> props ) ;\n qdev_prop_set_defaults ( dev , dev -> parent_bus -> info -> props ) ;\n qdev_prop_set_globals ( dev ) ;\n QLIST_INSERT_HEAD ( & bus -> children , dev , sibling ) ;\n if ( qdev_hotplug ) {\n assert ( bus -> allow_hotplug ) ;\n dev -> hotplugged = 1 ;\n }\n dev -> state = DEV_STATE_CREATED ;\n return dev ;\n }", "idx": 21072}
{"hash": 7037573792123850742, "project": "debian", "size": 71, "label": 1, "functionSource": "static PHP_MINIT_FUNCTION ( zip ) {\n # ifdef PHP_ZIP_USE_OO zend_class_entry ce ;\n memcpy ( & zip_object_handlers , zend_get_std_object_handlers ( ) , sizeof ( zend_object_handlers ) ) ;\n zip_object_handlers . clone_obj = NULL ;\n zip_object_handlers . get_property_ptr_ptr = php_zip_get_property_ptr_ptr ;\n zip_object_handlers . get_properties = php_zip_get_properties ;\n zip_object_handlers . read_property = php_zip_read_property ;\n zip_object_handlers . has_property = php_zip_has_property ;\n INIT_CLASS_ENTRY ( ce , \"ZipArchive\" , zip_class_functions ) ;\n ce . create_object = php_zip_object_new ;\n zip_class_entry = zend_register_internal_class ( & ce TSRMLS_CC ) ;\n zend_hash_init ( & zip_prop_handlers , 0 , NULL , NULL , 1 ) ;\n php_zip_register_prop_handler ( & zip_prop_handlers , \"status\" , php_zip_status , NULL , NULL , IS_LONG TSRMLS_CC ) ;\n php_zip_register_prop_handler ( & zip_prop_handlers , \"statusSys\" , php_zip_status_sys , NULL , NULL , IS_LONG TSRMLS_CC ) ;\n php_zip_register_prop_handler ( & zip_prop_handlers , \"numFiles\" , php_zip_get_num_files , NULL , NULL , IS_LONG TSRMLS_CC ) ;\n php_zip_register_prop_handler ( & zip_prop_handlers , \"filename\" , NULL , NULL , php_zipobj_get_filename , IS_STRING TSRMLS_CC ) ;\n php_zip_register_prop_handler ( & zip_prop_handlers , \"comment\" , NULL , php_zipobj_get_zip_comment , NULL , IS_STRING TSRMLS_CC ) ;\n REGISTER_ZIP_CLASS_CONST_LONG ( \"CREATE\" , ZIP_CREATE ) ;\n REGISTER_ZIP_CLASS_CONST_LONG ( \"EXCL\" , ZIP_EXCL ) ;\n REGISTER_ZIP_CLASS_CONST_LONG ( \"CHECKCONS\" , ZIP_CHECKCONS ) ;\n REGISTER_ZIP_CLASS_CONST_LONG ( \"OVERWRITE\" , ZIP_OVERWRITE ) ;\n REGISTER_ZIP_CLASS_CONST_LONG ( \"FL_NOCASE\" , ZIP_FL_NOCASE ) ;\n REGISTER_ZIP_CLASS_CONST_LONG ( \"FL_NODIR\" , ZIP_FL_NODIR ) ;\n REGISTER_ZIP_CLASS_CONST_LONG ( \"FL_COMPRESSED\" , ZIP_FL_COMPRESSED ) ;\n REGISTER_ZIP_CLASS_CONST_LONG ( \"FL_UNCHANGED\" , ZIP_FL_UNCHANGED ) ;\n REGISTER_ZIP_CLASS_CONST_LONG ( \"CM_DEFAULT\" , ZIP_CM_DEFAULT ) ;\n REGISTER_ZIP_CLASS_CONST_LONG ( \"CM_STORE\" , ZIP_CM_STORE ) ;\n REGISTER_ZIP_CLASS_CONST_LONG ( \"CM_SHRINK\" , ZIP_CM_SHRINK ) ;\n REGISTER_ZIP_CLASS_CONST_LONG ( \"CM_REDUCE_1\" , ZIP_CM_REDUCE_1 ) ;\n REGISTER_ZIP_CLASS_CONST_LONG ( \"CM_REDUCE_2\" , ZIP_CM_REDUCE_2 ) ;\n REGISTER_ZIP_CLASS_CONST_LONG ( \"CM_REDUCE_3\" , ZIP_CM_REDUCE_3 ) ;\n REGISTER_ZIP_CLASS_CONST_LONG ( \"CM_REDUCE_4\" , ZIP_CM_REDUCE_4 ) ;\n REGISTER_ZIP_CLASS_CONST_LONG ( \"CM_IMPLODE\" , ZIP_CM_IMPLODE ) ;\n REGISTER_ZIP_CLASS_CONST_LONG ( \"CM_DEFLATE\" , ZIP_CM_DEFLATE ) ;\n REGISTER_ZIP_CLASS_CONST_LONG ( \"CM_DEFLATE64\" , ZIP_CM_DEFLATE64 ) ;\n REGISTER_ZIP_CLASS_CONST_LONG ( \"CM_PKWARE_IMPLODE\" , ZIP_CM_PKWARE_IMPLODE ) ;\n REGISTER_ZIP_CLASS_CONST_LONG ( \"CM_BZIP2\" , ZIP_CM_BZIP2 ) ;\n REGISTER_ZIP_CLASS_CONST_LONG ( \"CM_LZMA\" , ZIP_CM_LZMA ) ;\n REGISTER_ZIP_CLASS_CONST_LONG ( \"CM_TERSE\" , ZIP_CM_TERSE ) ;\n REGISTER_ZIP_CLASS_CONST_LONG ( \"CM_LZ77\" , ZIP_CM_LZ77 ) ;\n REGISTER_ZIP_CLASS_CONST_LONG ( \"CM_WAVPACK\" , ZIP_CM_WAVPACK ) ;\n REGISTER_ZIP_CLASS_CONST_LONG ( \"CM_PPMD\" , ZIP_CM_PPMD ) ;\n REGISTER_ZIP_CLASS_CONST_LONG ( \"ER_OK\" , ZIP_ER_OK ) ;\n REGISTER_ZIP_CLASS_CONST_LONG ( \"ER_MULTIDISK\" , ZIP_ER_MULTIDISK ) ;\n REGISTER_ZIP_CLASS_CONST_LONG ( \"ER_RENAME\" , ZIP_ER_RENAME ) ;\n REGISTER_ZIP_CLASS_CONST_LONG ( \"ER_CLOSE\" , ZIP_ER_CLOSE ) ;\n REGISTER_ZIP_CLASS_CONST_LONG ( \"ER_SEEK\" , ZIP_ER_SEEK ) ;\n REGISTER_ZIP_CLASS_CONST_LONG ( \"ER_READ\" , ZIP_ER_READ ) ;\n REGISTER_ZIP_CLASS_CONST_LONG ( \"ER_WRITE\" , ZIP_ER_WRITE ) ;\n REGISTER_ZIP_CLASS_CONST_LONG ( \"ER_CRC\" , ZIP_ER_CRC ) ;\n REGISTER_ZIP_CLASS_CONST_LONG ( \"ER_ZIPCLOSED\" , ZIP_ER_ZIPCLOSED ) ;\n REGISTER_ZIP_CLASS_CONST_LONG ( \"ER_NOENT\" , ZIP_ER_NOENT ) ;\n REGISTER_ZIP_CLASS_CONST_LONG ( \"ER_EXISTS\" , ZIP_ER_EXISTS ) ;\n REGISTER_ZIP_CLASS_CONST_LONG ( \"ER_OPEN\" , ZIP_ER_OPEN ) ;\n REGISTER_ZIP_CLASS_CONST_LONG ( \"ER_TMPOPEN\" , ZIP_ER_TMPOPEN ) ;\n REGISTER_ZIP_CLASS_CONST_LONG ( \"ER_ZLIB\" , ZIP_ER_ZLIB ) ;\n REGISTER_ZIP_CLASS_CONST_LONG ( \"ER_MEMORY\" , ZIP_ER_MEMORY ) ;\n REGISTER_ZIP_CLASS_CONST_LONG ( \"ER_CHANGED\" , ZIP_ER_CHANGED ) ;\n REGISTER_ZIP_CLASS_CONST_LONG ( \"ER_COMPNOTSUPP\" , ZIP_ER_COMPNOTSUPP ) ;\n REGISTER_ZIP_CLASS_CONST_LONG ( \"ER_EOF\" , ZIP_ER_EOF ) ;\n REGISTER_ZIP_CLASS_CONST_LONG ( \"ER_INVAL\" , ZIP_ER_INVAL ) ;\n REGISTER_ZIP_CLASS_CONST_LONG ( \"ER_NOZIP\" , ZIP_ER_NOZIP ) ;\n REGISTER_ZIP_CLASS_CONST_LONG ( \"ER_INTERNAL\" , ZIP_ER_INTERNAL ) ;\n REGISTER_ZIP_CLASS_CONST_LONG ( \"ER_INCONS\" , ZIP_ER_INCONS ) ;\n REGISTER_ZIP_CLASS_CONST_LONG ( \"ER_REMOVE\" , ZIP_ER_REMOVE ) ;\n REGISTER_ZIP_CLASS_CONST_LONG ( \"ER_DELETED\" , ZIP_ER_DELETED ) ;\n php_register_url_stream_wrapper ( \"zip\" , & php_stream_zip_wrapper TSRMLS_CC ) ;\n # endif le_zip_dir = zend_register_list_destructors_ex ( php_zip_free_dir , NULL , le_zip_dir_name , module_number ) ;\n le_zip_entry = zend_register_list_destructors_ex ( php_zip_free_entry , NULL , le_zip_entry_name , module_number ) ;\n return SUCCESS ;\n }", "idx": 21073}
{"hash": 1182028467273264883, "project": "debian", "size": 11, "label": 0, "functionSource": "int do_echo ( struct st_command * command ) {\n DYNAMIC_STRING ds_echo ;\n DBUG_ENTER ( \"do_echo\" ) ;\n init_dynamic_string ( & ds_echo , \"\" , command -> query_len , 256 ) ;\n do_eval ( & ds_echo , command -> first_argument , command -> end , FALSE ) ;\n dynstr_append_mem ( & ds_res , ds_echo . str , ds_echo . length ) ;\n dynstr_append_mem ( & ds_res , \"\\n\" , 1 ) ;\n dynstr_free ( & ds_echo ) ;\n command -> last_argument = command -> end ;\n DBUG_RETURN ( 0 ) ;\n }", "idx": 21074}
{"hash": 1760449185745615462, "project": "debian", "size": 4, "label": 0, "functionSource": "void TSUuidDestroy ( TSUuid uuid ) {\n sdk_assert ( sdk_sanity_check_null_ptr ( ( void * ) uuid ) == TS_SUCCESS ) ;\n delete ( ATSUuid * ) uuid ;\n }", "idx": 21075}
{"hash": 2546373479020365143, "project": "debian", "size": 4, "label": 0, "functionSource": "void mime_scanner_clear ( MIMEScanner * scanner ) {\n ats_free ( scanner -> m_line ) ;\n _mime_scanner_init ( scanner ) ;\n }", "idx": 21076}
{"hash": 3246343243711264189, "project": "debian", "size": 20, "label": 0, "functionSource": "static inline void save_to_qmem_pingordata ( int userid , struct query * q ) {\n char cmc [ 8 ] ;\n int i ;\n if ( q -> name [ 0 ] == 'P' || q -> name [ 0 ] == 'p' ) {\n size_t cmcsize = sizeof ( cmc ) ;\n char * cp = strchr ( q -> name , '.' ) ;\n if ( cp == NULL ) return ;\n i = b32 -> decode ( cmc , & cmcsize , q -> name + 1 , ( cp - q -> name ) - 1 ) ;\n if ( i < 4 ) return ;\n save_to_qmem ( users [ userid ] . qmemping_cmc , users [ userid ] . qmemping_type , QMEMPING_LEN , & users [ userid ] . qmemping_lastfilled , ( void * ) cmc , q -> type ) ;\n }\n else {\n if ( strlen ( q -> name ) < 5 ) return ;\n for ( i = 0 ;\n i < 4 ;\n i ++ ) if ( q -> name [ i + 1 ] >= 'A' && q -> name [ i + 1 ] <= 'Z' ) cmc [ i ] = q -> name [ i + 1 ] + ( 'a' - 'A' ) ;\n else cmc [ i ] = q -> name [ i + 1 ] ;\n save_to_qmem ( users [ userid ] . qmemdata_cmc , users [ userid ] . qmemdata_type , QMEMDATA_LEN , & users [ userid ] . qmemdata_lastfilled , ( void * ) cmc , q -> type ) ;\n }\n }", "idx": 21077}
{"hash": -2222463888415249941, "project": "chrome", "size": 24, "label": 0, "functionSource": "int vp9_get_preview_raw_frame ( VP9_COMP * cpi , YV12_BUFFER_CONFIG * dest , vp9_ppflags_t * flags ) {\n VP9_COMMON * cm = & cpi -> common ;\n # if ! CONFIG_VP9_POSTPROC ( void ) flags ;\n # endif if ( ! cm -> show_frame ) {\n return - 1 ;\n }\n else {\n int ret ;\n # if CONFIG_VP9_POSTPROC ret = vp9_post_proc_frame ( cm , dest , flags ) ;\n # else if ( cm -> frame_to_show ) {\n * dest = * cm -> frame_to_show ;\n dest -> y_width = cm -> width ;\n dest -> y_height = cm -> height ;\n dest -> uv_width = cm -> width >> cm -> subsampling_x ;\n dest -> uv_height = cm -> height >> cm -> subsampling_y ;\n ret = 0 ;\n }\n else {\n ret = - 1 ;\n }\n # endif vp9_clear_system_state ( ) ;\n return ret ;\n }\n }", "idx": 21078}
{"hash": 2064081176034684128, "project": "debian", "size": 12, "label": 0, "functionSource": "static int ebml_read_ascii ( AVIOContext * pb , int size , char * * str ) {\n char * res ;\n if ( ! ( res = av_malloc ( size + 1 ) ) ) return AVERROR ( ENOMEM ) ;\n if ( avio_read ( pb , ( uint8_t * ) res , size ) != size ) {\n av_free ( res ) ;\n return AVERROR ( EIO ) ;\n }\n ( res ) [ size ] = '\\0' ;\n av_free ( * str ) ;\n * str = res ;\n return 0 ;\n }", "idx": 21079}
{"hash": -1929262071302712016, "project": "debian", "size": 7, "label": 0, "functionSource": "static void Type_UcrBg_Free ( struct _cms_typehandler_struct * self , void * Ptr ) {\n cmsUcrBg * Src = ( cmsUcrBg * ) Ptr ;\n if ( Src -> Ucr ) cmsFreeToneCurve ( Src -> Ucr ) ;\n if ( Src -> Bg ) cmsFreeToneCurve ( Src -> Bg ) ;\n if ( Src -> Desc ) cmsMLUfree ( Src -> Desc ) ;\n _cmsFree ( self -> ContextID , Ptr ) ;\n }", "idx": 21080}
{"hash": 8895005875911486570, "project": "debian", "size": 4, "label": 0, "functionSource": "static void curses_connection_data_help ( void ) {\n char help [ ] = \"HELP: shortcut list:\\n\\n\" \" ARROWS - switch between panels\\n\" \" j - switch from split to joined view\\n\" \" y - inject characters interactively\\n\" \" Y - inject characters from a file\\n\" \" k - kill the connection\" ;\n curses_message ( help ) ;\n }", "idx": 21081}
{"hash": -1055531103257174901, "project": "debian", "size": 22, "label": 0, "functionSource": "static void complete_from_nicklist ( GList * * outlist , CHANNEL_REC * channel , const char * nick , const char * suffix , const int match_case ) {\n MODULE_CHANNEL_REC * mchannel ;\n GSList * tmp ;\n GList * ownlist ;\n char * str ;\n int len ;\n ownlist = NULL ;\n len = strlen ( nick ) ;\n mchannel = MODULE_DATA ( channel ) ;\n for ( tmp = mchannel -> lastmsgs ;\n tmp != NULL ;\n tmp = tmp -> next ) {\n LAST_MSG_REC * rec = tmp -> data ;\n if ( ( match_case ? strncmp ( rec -> nick , nick , len ) : g_ascii_strncasecmp ( rec -> nick , nick , len ) ) == 0 && ( match_case ? glist_find_string ( * outlist , rec -> nick ) : glist_find_icase_string ( * outlist , rec -> nick ) ) == NULL ) {\n str = g_strconcat ( rec -> nick , suffix , NULL ) ;\n if ( completion_lowercase ) ascii_strdown ( str ) ;\n if ( rec -> own ) ownlist = g_list_append ( ownlist , str ) ;\n else * outlist = g_list_append ( * outlist , str ) ;\n }\n }\n * outlist = g_list_concat ( ownlist , * outlist ) ;\n }", "idx": 21082}
{"hash": -5268859819325807498, "project": "debian", "size": 5, "label": 0, "functionSource": "static void schedule_call_ready_callbacks ( NautilusDirectory * directory ) {\n if ( directory -> details -> call_ready_idle_id == 0 ) {\n directory -> details -> call_ready_idle_id = g_idle_add ( call_ready_callbacks_at_idle , directory ) ;\n }\n }", "idx": 21083}
{"hash": -2723830976796502611, "project": "chrome", "size": 5, "label": 0, "functionSource": "static vpx_codec_err_t ctrl_set_sharpness ( vpx_codec_alg_priv_t * ctx , va_list args ) {\n struct vp9_extracfg extra_cfg = ctx -> extra_cfg ;\n extra_cfg . sharpness = CAST ( VP8E_SET_SHARPNESS , args ) ;\n return update_extra_cfg ( ctx , & extra_cfg ) ;\n }", "idx": 21084}
{"hash": 1245821301839614810, "project": "debian", "size": 3, "label": 0, "functionSource": "static gboolean job_aborted ( CommonJob * job ) {\n return g_cancellable_is_cancelled ( job -> cancellable ) ;\n }", "idx": 21085}
{"hash": -454486177854888036, "project": "debian", "size": 11, "label": 0, "functionSource": "static void rac_init ( RangeCoder * c , const uint8_t * src , int size ) {\n int i ;\n c -> src = src ;\n c -> src_end = src + size ;\n c -> low = 0 ;\n for ( i = 0 ;\n i < FFMIN ( size , 4 ) ;\n i ++ ) c -> low = ( c -> low << 8 ) | * c -> src ++ ;\n c -> range = 0xFFFFFFFF ;\n c -> got_error = 0 ;\n }", "idx": 21086}
{"hash": -3384986069176965684, "project": "chrome", "size": 5, "label": 0, "functionSource": "int vp8_update_entropy ( VP8_COMP * cpi , int update ) {\n VP8_COMMON * cm = & cpi -> common ;\n cm -> refresh_entropy_probs = update ;\n return 0 ;\n }", "idx": 21087}
{"hash": 2895622461494525400, "project": "debian", "size": 56, "label": 0, "functionSource": "static void test_stiny_bug ( ) {\n MYSQL_STMT * stmt ;\n MYSQL_BIND my_bind [ 4 ] ;\n short short_value ;\n int32 long_value ;\n ulong s_length , l_length , ll_length , t_length ;\n ulonglong longlong_value ;\n int rc ;\n uchar tiny_value ;\n char llbuf [ 22 ] ;\n myheader ( \"test_stiny_bug\" ) ;\n rc = mysql_query ( mysql , \"DROP TABLE IF EXISTS test_stiny\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"CREATE TABLE test_stiny(a tinyint signed, \\ b tinyint signed, \\ c tinyint unsigned, \\ d tinyint unsigned)\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"INSERT INTO test_stiny VALUES(-128, -127, 255, 0)\" ) ;\n myquery ( rc ) ;\n stmt = mysql_simple_prepare ( mysql , \"SELECT * FROM test_stiny\" ) ;\n check_stmt ( stmt ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n my_bind [ 0 ] . buffer_type = MYSQL_TYPE_SHORT ;\n my_bind [ 0 ] . buffer = ( void * ) & short_value ;\n my_bind [ 0 ] . length = & s_length ;\n my_bind [ 1 ] . buffer_type = MYSQL_TYPE_LONG ;\n my_bind [ 1 ] . buffer = ( void * ) & long_value ;\n my_bind [ 1 ] . length = & l_length ;\n my_bind [ 2 ] . buffer_type = MYSQL_TYPE_LONGLONG ;\n my_bind [ 2 ] . buffer = ( void * ) & longlong_value ;\n my_bind [ 2 ] . length = & ll_length ;\n my_bind [ 3 ] . buffer_type = MYSQL_TYPE_TINY ;\n my_bind [ 3 ] . buffer = ( void * ) & tiny_value ;\n my_bind [ 3 ] . length = & t_length ;\n rc = mysql_stmt_bind_result ( stmt , my_bind ) ;\n check_execute ( stmt , rc ) ;\n rc = mysql_stmt_fetch ( stmt ) ;\n check_execute ( stmt , rc ) ;\n if ( ! opt_silent ) {\n fprintf ( stdout , \"\\n sshort : %d (%ld)\" , short_value , s_length ) ;\n fprintf ( stdout , \"\\n slong : %ld (%ld)\" , ( long ) long_value , l_length ) ;\n fprintf ( stdout , \"\\n longlong : %s (%ld)\" , llstr ( longlong_value , llbuf ) , ll_length ) ;\n fprintf ( stdout , \"\\n tinyint : %d (%ld)\" , tiny_value , t_length ) ;\n }\n DIE_UNLESS ( short_value == - 128 ) ;\n DIE_UNLESS ( s_length == 2 ) ;\n DIE_UNLESS ( long_value == - 127 ) ;\n DIE_UNLESS ( l_length == 4 ) ;\n DIE_UNLESS ( longlong_value == 255 ) ;\n DIE_UNLESS ( ll_length == 8 ) ;\n DIE_UNLESS ( tiny_value == 0 ) ;\n DIE_UNLESS ( t_length == 1 ) ;\n rc = mysql_stmt_fetch ( stmt ) ;\n DIE_UNLESS ( rc == MYSQL_NO_DATA ) ;\n mysql_stmt_close ( stmt ) ;\n }", "idx": 21088}
{"hash": 7399683071036018868, "project": "debian", "size": 10, "label": 0, "functionSource": "static void dbstmt_prop_delete ( zval * object , zval * member , const zend_literal * key TSRMLS_DC ) {\n pdo_stmt_t * stmt = ( pdo_stmt_t * ) zend_object_store_get_object ( object TSRMLS_CC ) ;\n convert_to_string ( member ) ;\n if ( strcmp ( Z_STRVAL_P ( member ) , \"queryString\" ) == 0 ) {\n pdo_raise_impl_error ( stmt -> dbh , stmt , \"HY000\" , \"property queryString is read only\" TSRMLS_CC ) ;\n }\n else {\n std_object_handlers . unset_property ( object , member , key TSRMLS_CC ) ;\n }\n }", "idx": 21089}
{"hash": -2443338381883395438, "project": "debian", "size": 28, "label": 0, "functionSource": "void format_errmsg ( char * nfmt , size_t lennfmt , const char * fmt , int errval ) {\n char errmsg [ 256 ] ;\n char c ;\n char * n ;\n const char * f ;\n size_t len ;\n n = nfmt ;\n f = fmt ;\n while ( ( c = * f ++ ) != '\\0' && n < ( nfmt + lennfmt - 1 ) ) {\n if ( c != '%' ) {\n * n ++ = c ;\n continue ;\n }\n if ( ( c = * f ++ ) != 'm' ) {\n * n ++ = '%' ;\n if ( '\\0' == c ) break ;\n * n ++ = c ;\n continue ;\n }\n errno_to_str ( errval , errmsg , sizeof ( errmsg ) ) ;\n len = strlen ( errmsg ) ;\n if ( ( n + len ) < ( nfmt + lennfmt - 1 ) ) {\n memcpy ( n , errmsg , len ) ;\n n += len ;\n }\n }\n * n = '\\0' ;\n }", "idx": 21090}
{"hash": 6336384260629386331, "project": "debian", "size": 14, "label": 1, "functionSource": "static void dissect_zcl_pwr_prof_pwrprofstatersp ( tvbuff_t * tvb , proto_tree * tree , guint * offset ) {\n proto_tree * sub_tree = NULL ;\n guint i ;\n guint8 power_profile_count ;\n power_profile_count = tvb_get_guint8 ( tvb , * offset ) ;\n proto_tree_add_item ( tree , hf_zbee_zcl_pwr_prof_pwr_prof_count , tvb , * offset , 1 , ENC_NA ) ;\n * offset += 1 ;\n for ( i = 0 ;\n i < power_profile_count ;\n i ++ ) {\n sub_tree = proto_tree_add_subtree_format ( tree , tvb , * offset , 1 , ett_zbee_zcl_pwr_prof_pwrprofiles [ i ] , NULL , \"Power Profile #%u\" , i ) ;\n dissect_zcl_power_profile ( tvb , sub_tree , offset ) ;\n }\n }", "idx": 21091}
{"hash": -2222463888415249941, "project": "chrome", "size": 9, "label": 0, "functionSource": "static void Pass0Encode ( VP9_COMP * cpi , size_t * size , uint8_t * dest , unsigned int * frame_flags ) {\n if ( cpi -> oxcf . rc_mode == VPX_CBR ) {\n vp9_rc_get_one_pass_cbr_params ( cpi ) ;\n }\n else {\n vp9_rc_get_one_pass_vbr_params ( cpi ) ;\n }\n encode_frame_to_data_rate ( cpi , size , dest , frame_flags ) ;\n }", "idx": 21092}
{"hash": 8425497811998776592, "project": "debian", "size": 329, "label": 1, "functionSource": "int petite_inflate2x_1to9 ( char * buf , uint32_t minrva , uint32_t bufsz , struct cli_exe_section * sections , unsigned int sectcount , uint32_t Imagebase , uint32_t pep , int desc , int version , uint32_t ResRva , uint32_t ResSize ) {\n char * adjbuf = buf - minrva ;\n char * packed = NULL ;\n uint32_t thisrva = 0 , bottom = 0 , enc_ep = 0 , irva = 0 , workdone = 0 , grown = 0x355 , skew = 0x35 ;\n int j = 0 , oob , mangled = 0 , check4resources = 0 ;\n struct cli_exe_section * usects = NULL ;\n void * tmpsct = NULL ;\n if ( version == 2 ) packed = adjbuf + sections [ sectcount - 1 ] . rva + 0x1b8 ;\n if ( version == 1 ) {\n packed = adjbuf + sections [ sectcount - 1 ] . rva + 0x178 ;\n grown = 0x323 ;\n skew = 0x34 ;\n }\n while ( 1 ) {\n char * ssrc , * ddst ;\n uint32_t size , srva ;\n int backbytes , oldback , backsize , addsize ;\n if ( ! CLI_ISCONTAINED ( buf , bufsz , packed , 4 ) ) {\n if ( usects ) free ( usects ) ;\n return 1 ;\n }\n srva = cli_readint32 ( packed ) ;\n if ( ! srva ) {\n int t , upd = 1 ;\n if ( j <= 0 ) return 1 ;\n while ( upd ) {\n upd = 0 ;\n for ( t = 0 ;\n t < j - 1 ;\n t ++ ) {\n uint32_t trva , trsz , tvsz ;\n if ( usects [ t ] . rva <= usects [ t + 1 ] . rva ) continue ;\n trva = usects [ t ] . rva ;\n trsz = usects [ t ] . rsz ;\n tvsz = usects [ t ] . vsz ;\n usects [ t ] . rva = usects [ t + 1 ] . rva ;\n usects [ t ] . rsz = usects [ t + 1 ] . rsz ;\n usects [ t ] . vsz = usects [ t + 1 ] . vsz ;\n usects [ t + 1 ] . rva = trva ;\n usects [ t + 1 ] . rsz = trsz ;\n usects [ t + 1 ] . vsz = tvsz ;\n upd = 1 ;\n }\n }\n for ( t = 0 ;\n t < j - 1 ;\n t ++ ) {\n if ( usects [ t ] . vsz != usects [ t + 1 ] . rva - usects [ t ] . rva ) usects [ t ] . vsz = usects [ t + 1 ] . rva - usects [ t ] . rva ;\n }\n if ( enc_ep ) {\n uint32_t virtaddr = pep + 5 + Imagebase , tmpep ;\n int rndm = 0 , dummy = 1 ;\n char * thunk = adjbuf + irva ;\n char * imports ;\n if ( version == 2 ) {\n while ( dummy && CLI_ISCONTAINED ( buf , bufsz , thunk , 4 ) ) {\n uint32_t api ;\n if ( ! cli_readint32 ( thunk ) ) {\n workdone = 1 ;\n break ;\n }\n imports = adjbuf + cli_readint32 ( thunk ) ;\n thunk += 4 ;\n dummy = 0 ;\n while ( CLI_ISCONTAINED ( buf , bufsz , imports , 4 ) ) {\n dummy = 0 ;\n imports += 4 ;\n if ( ! ( api = cli_readint32 ( imports - 4 ) ) ) {\n dummy = 1 ;\n break ;\n }\n if ( ( api != ( api | 0x80000000 ) ) && mangled && -- rndm < 0 ) {\n api = virtaddr ;\n virtaddr += 5 ;\n rndm = virtaddr & 7 ;\n }\n else {\n api = 0xbff01337 ;\n }\n if ( sections [ sectcount - 1 ] . rva + Imagebase < api ) enc_ep -- ;\n if ( api < virtaddr ) enc_ep -- ;\n tmpep = ( enc_ep & 0xfffffff8 ) >> 3 & 0x1fffffff ;\n enc_ep = ( enc_ep & 7 ) << 29 | tmpep ;\n }\n }\n }\n else workdone = 1 ;\n enc_ep = pep + 5 + enc_ep ;\n if ( workdone == 1 ) {\n cli_dbgmsg ( \"Petite: Old EP: %x\\n\" , enc_ep ) ;\n }\n else {\n enc_ep = usects [ 0 ] . rva ;\n cli_dbgmsg ( \"Petite: In troubles while attempting to decrypt old EP, using bogus %x\\n\" , enc_ep ) ;\n }\n }\n for ( t = 0 ;\n t < j ;\n t ++ ) {\n usects [ t ] . raw = ( t > 0 ) ? ( usects [ t - 1 ] . raw + usects [ t - 1 ] . rsz ) : 0 ;\n if ( usects [ t ] . rsz != 0 ) {\n if ( CLI_ISCONTAINED ( buf , bufsz , buf + usects [ t ] . raw , usects [ t ] . rsz ) ) {\n memmove ( buf + usects [ t ] . raw , adjbuf + usects [ t ] . rva , usects [ t ] . rsz ) ;\n }\n else {\n cli_dbgmsg ( \"Petite: Skipping section %d, Raw: %x, RSize:%x\\n\" , t , usects [ t ] . raw , usects [ t ] . rsz ) ;\n usects [ t ] . raw = t > 0 ? usects [ t - 1 ] . raw : 0 ;\n usects [ t ] . rsz = 0 ;\n }\n }\n }\n cli_dbgmsg ( \"Petite: Sections dump:\\n\" ) ;\n for ( t = 0 ;\n t < j ;\n t ++ ) cli_dbgmsg ( \"Petite: .SECT%d RVA:%x VSize:%x ROffset: %x, RSize:%x\\n\" , t , usects [ t ] . rva , usects [ t ] . vsz , usects [ t ] . raw , usects [ t ] . rsz ) ;\n if ( ! cli_rebuildpe ( buf , usects , j , Imagebase , enc_ep , ResRva , ResSize , desc ) ) {\n cli_dbgmsg ( \"Petite: Rebuilding failed\\n\" ) ;\n free ( usects ) ;\n return 1 ;\n }\n free ( usects ) ;\n return 0 ;\n }\n size = srva & 0x7fffffff ;\n if ( srva != size ) {\n check4resources = 0 ;\n if ( ! CLI_ISCONTAINED ( buf , bufsz , packed + 4 , 8 ) ) {\n if ( usects ) free ( usects ) ;\n return 1 ;\n }\n bottom = cli_readint32 ( packed + 8 ) + 4 ;\n ssrc = adjbuf + cli_readint32 ( packed + 4 ) - ( size - 1 ) * 4 ;\n ddst = adjbuf + cli_readint32 ( packed + 8 ) - ( size - 1 ) * 4 ;\n if ( ! CLI_ISCONTAINED ( buf , bufsz , ssrc , size * 4 ) || ! CLI_ISCONTAINED ( buf , bufsz , ddst , size * 4 ) ) {\n if ( usects ) free ( usects ) ;\n return 1 ;\n }\n memmove ( ddst , ssrc , size * 4 ) ;\n packed += 0x0c ;\n }\n else {\n uint32_t check1 , check2 ;\n uint8_t mydl = 0 ;\n uint8_t goback ;\n unsigned int q ;\n if ( ! CLI_ISCONTAINED ( buf , bufsz , packed + 4 , 8 ) ) {\n if ( usects ) free ( usects ) ;\n return 1 ;\n }\n size = cli_readint32 ( packed + 4 ) ;\n thisrva = cli_readint32 ( packed + 8 ) ;\n packed += 0x10 ;\n if ( j >= 96 ) {\n cli_dbgmsg ( \"Petite: maximum number of sections exceeded, giving up.\\n\" ) ;\n free ( usects ) ;\n return 1 ;\n }\n if ( ! ( tmpsct = cli_realloc ( usects , sizeof ( struct cli_exe_section ) * ( j + 1 ) ) ) ) {\n if ( usects ) free ( usects ) ;\n return 1 ;\n }\n usects = ( struct cli_exe_section * ) tmpsct ;\n usects [ j ] . rva = thisrva ;\n usects [ j ] . rsz = size ;\n if ( ( int ) ( bottom - thisrva ) > 0 ) usects [ j ] . vsz = bottom - thisrva ;\n else usects [ j ] . vsz = size ;\n usects [ j ] . raw = 0 ;\n if ( ! size ) {\n j ++ ;\n continue ;\n }\n ssrc = adjbuf + srva ;\n ddst = adjbuf + thisrva ;\n for ( q = 0 ;\n q < sectcount ;\n q ++ ) {\n if ( ! CLI_ISCONTAINED ( sections [ q ] . rva , sections [ q ] . vsz , usects [ j ] . rva , usects [ j ] . vsz ) ) continue ;\n if ( ! check4resources ) {\n usects [ j ] . rva = sections [ q ] . rva ;\n usects [ j ] . rsz = thisrva - sections [ q ] . rva + size ;\n }\n break ;\n }\n if ( q == sectcount ) {\n free ( usects ) ;\n return 1 ;\n }\n j ++ ;\n if ( size < 0x10000 ) {\n check1 = 0x0FFFFC060 ;\n check2 = 0x0FFFFFC60 ;\n goback = 5 ;\n }\n else if ( size < 0x40000 ) {\n check1 = 0x0FFFF8180 ;\n check2 = 0x0FFFFF980 ;\n goback = 7 ;\n }\n else {\n check1 = 0x0FFFF8300 ;\n check2 = 0x0FFFFFB00 ;\n goback = 8 ;\n }\n if ( ! CLI_ISCONTAINED ( buf , bufsz , ssrc , 1 ) || ! CLI_ISCONTAINED ( buf , bufsz , ddst , 1 ) ) {\n free ( usects ) ;\n return 1 ;\n }\n size -- ;\n * ddst ++ = * ssrc ++ ;\n backbytes = 0 ;\n oldback = 0 ;\n while ( size > 0 ) {\n oob = doubledl ( & ssrc , & mydl , buf , bufsz ) ;\n if ( oob == - 1 ) {\n free ( usects ) ;\n return 1 ;\n }\n if ( ! oob ) {\n if ( ! CLI_ISCONTAINED ( buf , bufsz , ssrc , 1 ) || ! CLI_ISCONTAINED ( buf , bufsz , ddst , 1 ) ) {\n free ( usects ) ;\n return 1 ;\n }\n * ddst ++ = ( char ) ( ( * ssrc ++ ) ^ ( size & 0xff ) ) ;\n size -- ;\n }\n else {\n addsize = 0 ;\n backbytes ++ ;\n while ( 1 ) {\n if ( ( oob = doubledl ( & ssrc , & mydl , buf , bufsz ) ) == - 1 ) {\n free ( usects ) ;\n return 1 ;\n }\n backbytes = backbytes * 2 + oob ;\n if ( ( oob = doubledl ( & ssrc , & mydl , buf , bufsz ) ) == - 1 ) {\n free ( usects ) ;\n return 1 ;\n }\n if ( ! oob ) break ;\n }\n backbytes -= 3 ;\n if ( backbytes >= 0 ) {\n backsize = goback ;\n do {\n if ( ( oob = doubledl ( & ssrc , & mydl , buf , bufsz ) ) == - 1 ) {\n free ( usects ) ;\n return 1 ;\n }\n backbytes = backbytes * 2 + oob ;\n backsize -- ;\n }\n while ( backsize ) ;\n backbytes ^= 0xffffffff ;\n addsize += 1 + ( backbytes < ( int ) check2 ) + ( backbytes < ( int ) check1 ) ;\n oldback = backbytes ;\n }\n else {\n backsize = backbytes + 1 ;\n backbytes = oldback ;\n }\n if ( ( oob = doubledl ( & ssrc , & mydl , buf , bufsz ) ) == - 1 ) {\n free ( usects ) ;\n return 1 ;\n }\n backsize = backsize * 2 + oob ;\n if ( ( oob = doubledl ( & ssrc , & mydl , buf , bufsz ) ) == - 1 ) {\n free ( usects ) ;\n return 1 ;\n }\n backsize = backsize * 2 + oob ;\n if ( ! backsize ) {\n backsize ++ ;\n while ( 1 ) {\n if ( ( oob = doubledl ( & ssrc , & mydl , buf , bufsz ) ) == - 1 ) {\n free ( usects ) ;\n return 1 ;\n }\n backsize = backsize * 2 + oob ;\n if ( ( oob = doubledl ( & ssrc , & mydl , buf , bufsz ) ) == - 1 ) {\n free ( usects ) ;\n return 1 ;\n }\n if ( ! oob ) break ;\n }\n backsize += 2 ;\n }\n backsize += addsize ;\n size -= backsize ;\n if ( ! CLI_ISCONTAINED ( buf , bufsz , ddst , backsize ) || ! CLI_ISCONTAINED ( buf , bufsz , ddst + backbytes , backsize ) ) {\n free ( usects ) ;\n return 1 ;\n }\n while ( backsize -- ) {\n * ddst = * ( ddst + backbytes ) ;\n ddst ++ ;\n }\n backbytes = 0 ;\n backsize = 0 ;\n }\n }\n if ( j ) {\n int strippetite = 0 ;\n uint32_t reloc ;\n if ( usects [ j - 1 ] . rsz > grown && CLI_ISCONTAINED ( buf , bufsz , ddst - grown + 5 + 0x4f , 8 ) && cli_readint32 ( ddst - grown + 5 + 0x4f ) == 0x645ec033 && cli_readint32 ( ddst - grown + 5 + 0x4f + 4 ) == 0x1b8b188b ) {\n reloc = 0 ;\n strippetite = 1 ;\n }\n if ( ! strippetite && usects [ j - 1 ] . rsz > grown + skew && CLI_ISCONTAINED ( buf , bufsz , ddst - grown + 5 + 0x4f - skew , 8 ) && cli_readint32 ( ddst - grown + 5 + 0x4f - skew ) == 0x645ec033 && cli_readint32 ( ddst - grown + 5 + 0x4f + 4 - skew ) == 0x1b8b188b ) {\n reloc = skew ;\n strippetite = 1 ;\n }\n if ( strippetite && CLI_ISCONTAINED ( buf , bufsz , ddst - grown + 0x0f - 8 - reloc , 8 ) ) {\n uint32_t test1 , test2 ;\n test1 = cli_readint32 ( ddst - grown + 0x0f - 8 - reloc ) ^ 0x9d6661aa ;\n test2 = cli_readint32 ( ddst - grown + 0x0f - 4 - reloc ) ^ 0xe908c483 ;\n cli_dbgmsg ( \"Petite: Found petite code in sect%d(%x). Let's strip it.\\n\" , j - 1 , usects [ j - 1 ] . rva ) ;\n if ( test1 == test2 && CLI_ISCONTAINED ( buf , bufsz , ddst - grown + 0x0f - reloc , 0x1c0 - 0x0f + 4 ) ) {\n irva = cli_readint32 ( ddst - grown + 0x121 - reloc ) ;\n enc_ep = cli_readint32 ( ddst - grown + 0x0f - reloc ) ^ test1 ;\n mangled = ( ( uint32_t ) cli_readint32 ( ddst - grown + 0x1c0 - reloc ) != 0x90909090 ) ;\n cli_dbgmsg ( \"Petite: Encrypted EP: %x | Array of imports: %x\\n\" , enc_ep , irva ) ;\n }\n usects [ j - 1 ] . rsz -= grown + reloc ;\n }\n }\n check4resources ++ ;\n }\n }\n }", "idx": 21093}
{"hash": -7646792761994281873, "project": "debian", "size": 6, "label": 0, "functionSource": "static int http_config_cb ( const char * , RecDataT , RecData , void * ) {\n ink_atomic_increment ( ( int * ) & http_config_changes , 1 ) ;\n INK_MEMORY_BARRIER ;\n eventProcessor . schedule_in ( http_config_cont , HRTIME_SECONDS ( 1 ) , ET_CALL ) ;\n return 0 ;\n }", "idx": 21094}
{"hash": -3502382902740740634, "project": "debian", "size": 17, "label": 0, "functionSource": "static diam_avp_t * build_proto_avp ( const avp_type_t * type _U_ , guint32 code , diam_vnd_t * vendor , const char * name _U_ , const value_string * vs _U_ , void * data ) {\n diam_avp_t * a = ( diam_avp_t * ) g_malloc0 ( sizeof ( diam_avp_t ) ) ;\n proto_avp_t * t = ( proto_avp_t * ) g_malloc0 ( sizeof ( proto_avp_t ) ) ;\n gint * ettp = & ( a -> ett ) ;\n a -> code = code ;\n a -> vendor = vendor ;\n a -> dissector_v16 = proto_avp ;\n a -> dissector_rfc = proto_avp ;\n a -> ett = - 1 ;\n a -> hf_value = - 2 ;\n a -> type_data = t ;\n t -> name = ( char * ) data ;\n t -> handle = NULL ;\n t -> reassemble_mode = REASEMBLE_NEVER ;\n g_ptr_array_add ( build_dict . ett , ettp ) ;\n return a ;\n }", "idx": 21095}
{"hash": 6249489553242542670, "project": "debian", "size": 28, "label": 0, "functionSource": "static void config_other_modes ( config_tree * ptree ) {\n sockaddr_u addr_sock ;\n address_node * addr_node ;\n if ( ptree -> broadcastclient ) proto_config ( PROTO_BROADCLIENT , ptree -> broadcastclient , 0. , NULL ) ;\n addr_node = HEAD_PFIFO ( ptree -> manycastserver ) ;\n while ( addr_node != NULL ) {\n ZERO_SOCK ( & addr_sock ) ;\n AF ( & addr_sock ) = addr_node -> type ;\n if ( 1 == getnetnum ( addr_node -> address , & addr_sock , 1 , t_UNK ) ) {\n proto_config ( PROTO_MULTICAST_ADD , 0 , 0. , & addr_sock ) ;\n sys_manycastserver = 1 ;\n }\n addr_node = addr_node -> link ;\n }\n addr_node = HEAD_PFIFO ( ptree -> multicastclient ) ;\n if ( addr_node != NULL ) {\n do {\n ZERO_SOCK ( & addr_sock ) ;\n AF ( & addr_sock ) = addr_node -> type ;\n if ( 1 == getnetnum ( addr_node -> address , & addr_sock , 1 , t_UNK ) ) {\n proto_config ( PROTO_MULTICAST_ADD , 0 , 0. , & addr_sock ) ;\n }\n addr_node = addr_node -> link ;\n }\n while ( addr_node != NULL ) ;\n proto_config ( PROTO_MULTICAST_ADD , 1 , 0. , NULL ) ;\n }\n }", "idx": 21096}
{"hash": 6632536031698733342, "project": "debian", "size": 3, "label": 0, "functionSource": "static void flat_print_int ( WriterContext * wctx , const char * key , long long int value ) {\n printf ( \"%s%s=%lld\\n\" , wctx -> section_pbuf [ wctx -> level ] . str , key , value ) ;\n }", "idx": 21097}
{"hash": 927123821003322045, "project": "chrome", "size": 15, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( SessionRestorePageLoadMetricsBrowserTest , LoadingAfterSessionRestore ) {\n ui_test_utils : : NavigateToURL ( browser ( ) , GetTestURL ( ) ) ;\n Browser * new_browser = nullptr ;\n {\n SessionRestorePaintWaiter session_restore_paint_waiter ;\n new_browser = QuitBrowserAndRestore ( browser ( ) ) ;\n session_restore_paint_waiter . WaitForForegroundTabs ( 1 ) ;\n ExpectFirstPaintMetricsTotalCount ( 1 ) ;\n }\n auto waiter = std : : make_unique < PageLoadMetricsWaiter > ( new_browser -> tab_strip_model ( ) -> GetActiveWebContents ( ) ) ;\n waiter -> AddPageExpectation ( TimingField : : FIRST_MEANINGFUL_PAINT ) ;\n ui_test_utils : : NavigateToURL ( new_browser , GetTestURL ( ) ) ;\n waiter -> Wait ( ) ;\n ExpectFirstPaintMetricsTotalCount ( 1 ) ;\n }", "idx": 21098}
{"hash": -1315695702746584250, "project": "debian", "size": 10, "label": 0, "functionSource": "proto_item * proto_tree_add_float ( proto_tree * tree , int hfindex , tvbuff_t * tvb , gint start , gint length , float value ) {\n proto_item * pi ;\n header_field_info * hfinfo ;\n CHECK_FOR_NULL_TREE ( tree ) ;\n TRY_TO_FAKE_THIS_ITEM ( tree , hfindex , hfinfo ) ;\n DISSECTOR_ASSERT_FIELD_TYPE ( hfinfo , FT_FLOAT ) ;\n pi = proto_tree_add_pi ( tree , hfinfo , tvb , start , & length ) ;\n proto_tree_set_float ( PNODE_FINFO ( pi ) , value ) ;\n return pi ;\n }", "idx": 21099}
{"hash": 7673224878519445199, "project": "debian", "size": 11, "label": 0, "functionSource": "static void vdpau_h264_set_rf ( VdpReferenceFrameH264 * rf , Picture * pic , int pic_structure ) {\n VdpVideoSurface surface = ff_vdpau_get_surface_id ( pic ) ;\n if ( pic_structure == 0 ) pic_structure = pic -> reference ;\n rf -> surface = surface ;\n rf -> is_long_term = pic -> reference && pic -> long_ref ;\n rf -> top_is_reference = ( pic_structure & PICT_TOP_FIELD ) != 0 ;\n rf -> bottom_is_reference = ( pic_structure & PICT_BOTTOM_FIELD ) != 0 ;\n rf -> field_order_cnt [ 0 ] = h264_foc ( pic -> field_poc [ 0 ] ) ;\n rf -> field_order_cnt [ 1 ] = h264_foc ( pic -> field_poc [ 1 ] ) ;\n rf -> frame_idx = pic -> long_ref ? pic -> pic_id : pic -> frame_num ;\n }", "idx": 21100}
{"hash": -1111775978048960297, "project": "chrome", "size": 13, "label": 0, "functionSource": "TEST_F ( BrowsingDataRemoverImplTest , MultipleTasksInQuickSuccession ) {\n BrowsingDataRemoverImpl * remover = static_cast < BrowsingDataRemoverImpl * > ( BrowsingDataRemoverFactory : : GetForBrowserContext ( GetBrowserContext ( ) ) ) ;\n EXPECT_FALSE ( remover -> is_removing ( ) ) ;\n int test_removal_masks [ ] = {\n BrowsingDataRemover : : REMOVE_COOKIES , BrowsingDataRemover : : REMOVE_PASSWORDS , BrowsingDataRemover : : REMOVE_COOKIES , BrowsingDataRemover : : REMOVE_COOKIES , BrowsingDataRemover : : REMOVE_COOKIES , BrowsingDataRemover : : REMOVE_HISTORY , BrowsingDataRemover : : REMOVE_HISTORY , BrowsingDataRemover : : REMOVE_HISTORY , BrowsingDataRemover : : REMOVE_COOKIES | BrowsingDataRemover : : REMOVE_HISTORY , BrowsingDataRemover : : REMOVE_COOKIES | BrowsingDataRemover : : REMOVE_HISTORY , BrowsingDataRemover : : REMOVE_COOKIES | BrowsingDataRemover : : REMOVE_HISTORY | BrowsingDataRemover : : REMOVE_PASSWORDS , BrowsingDataRemover : : REMOVE_PASSWORDS , BrowsingDataRemover : : REMOVE_PASSWORDS , }\n ;\n for ( int removal_mask : test_removal_masks ) {\n remover -> Remove ( base : : Time ( ) , base : : Time : : Max ( ) , removal_mask , BrowsingDataHelper : : UNPROTECTED_WEB ) ;\n }\n EXPECT_TRUE ( remover -> is_removing ( ) ) ;\n BlockUntilBrowsingDataRemoved ( base : : Time ( ) , base : : Time : : Max ( ) , BrowsingDataRemover : : REMOVE_COOKIES , BrowsingDataHelper : : UNPROTECTED_WEB ) ;\n EXPECT_FALSE ( remover -> is_removing ( ) ) ;\n }", "idx": 21101}
{"hash": 4876100961671882393, "project": "debian", "size": 20, "label": 0, "functionSource": "static int dissect_pvfs2_readdir_response ( tvbuff_t * tvb , proto_tree * tree , int offset , packet_info * pinfo ) {\n guint32 dirent_count = 0 ;\n guint32 nCount = 0 ;\n proto_tree_add_item ( tree , hf_pvfs_ds_position , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n offset += 4 ;\n proto_tree_add_item ( tree , hf_pvfs_directory_version , tvb , offset , 8 , ENC_LITTLE_ENDIAN ) ;\n offset += 8 ;\n offset += 4 ;\n dirent_count = tvb_get_letohl ( tvb , offset ) ;\n proto_tree_add_item ( tree , hf_pvfs_dirent_count , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n for ( nCount = 0 ;\n nCount < dirent_count ;\n nCount ++ ) {\n offset = dissect_pvfs_string ( tvb , tree , hf_pvfs_path , offset , NULL ) ;\n offset = dissect_pvfs_fh ( tvb , offset , pinfo , tree , \"handle\" , NULL ) ;\n }\n return offset ;\n }", "idx": 21102}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_T_rfc2733 ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_T_rfc2733 , T_rfc2733_sequence ) ;\n return offset ;\n }", "idx": 21103}
{"hash": -5706788925640467782, "project": "chrome", "size": 9, "label": 0, "functionSource": "static int check_dual_ref_flags ( VP9_COMP * cpi ) {\n const int ref_flags = cpi -> ref_frame_flags ;\n if ( vp9_segfeature_active ( & cpi -> common . seg , 1 , SEG_LVL_REF_FRAME ) ) {\n return 0 ;\n }\n else {\n return ( ! ! ( ref_flags & VP9_GOLD_FLAG ) + ! ! ( ref_flags & VP9_LAST_FLAG ) + ! ! ( ref_flags & VP9_ALT_FLAG ) ) >= 2 ;\n }\n }", "idx": 21104}
{"hash": -4885528830177756816, "project": "debian", "size": 21, "label": 0, "functionSource": "int filecopy ( MI_CHECK * param , File to , File from , my_off_t start , my_off_t length , const char * type ) {\n char tmp_buff [ IO_SIZE ] , * buff ;\n ulong buff_length ;\n DBUG_ENTER ( \"filecopy\" ) ;\n buff_length = ( ulong ) min ( param -> write_buffer_length , length ) ;\n if ( ! ( buff = my_malloc ( buff_length , MYF ( 0 ) ) ) ) {\n buff = tmp_buff ;\n buff_length = IO_SIZE ;\n }\n mysql_file_seek ( from , start , MY_SEEK_SET , MYF ( 0 ) ) ;\n while ( length > buff_length ) {\n if ( mysql_file_read ( from , ( uchar * ) buff , buff_length , MYF ( MY_NABP ) ) || mysql_file_write ( to , ( uchar * ) buff , buff_length , param -> myf_rw ) ) goto err ;\n length -= buff_length ;\n }\n if ( mysql_file_read ( from , ( uchar * ) buff , ( uint ) length , MYF ( MY_NABP ) ) || mysql_file_write ( to , ( uchar * ) buff , ( uint ) length , param -> myf_rw ) ) goto err ;\n if ( buff != tmp_buff ) my_free ( buff ) ;\n DBUG_RETURN ( 0 ) ;\n err : if ( buff != tmp_buff ) my_free ( buff ) ;\n mi_check_print_error ( param , \"Can't copy %s to tempfile, error %d\" , type , my_errno ) ;\n DBUG_RETURN ( 1 ) ;\n }", "idx": 21105}
{"hash": -398565394354770780, "project": "debian", "size": 6, "label": 0, "functionSource": "static void usb_ohci_reset_pci ( DeviceState * d ) {\n PCIDevice * dev = PCI_DEVICE ( d ) ;\n OHCIPCIState * ohci = PCI_OHCI ( dev ) ;\n OHCIState * s = & ohci -> state ;\n ohci_hard_reset ( s ) ;\n }", "idx": 21106}
{"hash": -1768728156572022708, "project": "debian", "size": 3, "label": 0, "functionSource": "uint16_t jbig2_get_uint16 ( const byte * bptr ) {\n return get_uint16 ( bptr ) ;\n }", "idx": 21107}
{"hash": -7076754245473579218, "project": "chrome", "size": 33, "label": 0, "functionSource": "struct evhttp_request * evhttp_request_new ( void ( * cb ) ( struct evhttp_request * , void * ) , void * arg ) {\n struct evhttp_request * req = NULL ;\n if ( ( req = calloc ( 1 , sizeof ( struct evhttp_request ) ) ) == NULL ) {\n event_warn ( \"%s: calloc\" , __func__ ) ;\n goto error ;\n }\n req -> kind = EVHTTP_RESPONSE ;\n req -> input_headers = calloc ( 1 , sizeof ( struct evkeyvalq ) ) ;\n if ( req -> input_headers == NULL ) {\n event_warn ( \"%s: calloc\" , __func__ ) ;\n goto error ;\n }\n TAILQ_INIT ( req -> input_headers ) ;\n req -> output_headers = calloc ( 1 , sizeof ( struct evkeyvalq ) ) ;\n if ( req -> output_headers == NULL ) {\n event_warn ( \"%s: calloc\" , __func__ ) ;\n goto error ;\n }\n TAILQ_INIT ( req -> output_headers ) ;\n if ( ( req -> input_buffer = evbuffer_new ( ) ) == NULL ) {\n event_warn ( \"%s: evbuffer_new\" , __func__ ) ;\n goto error ;\n }\n if ( ( req -> output_buffer = evbuffer_new ( ) ) == NULL ) {\n event_warn ( \"%s: evbuffer_new\" , __func__ ) ;\n goto error ;\n }\n req -> cb = cb ;\n req -> cb_arg = arg ;\n return ( req ) ;\n error : if ( req != NULL ) evhttp_request_free ( req ) ;\n return ( NULL ) ;\n }", "idx": 21108}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_H263Options ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_H263Options , H263Options_sequence ) ;\n return offset ;\n }", "idx": 21109}
{"hash": 8320716512483418415, "project": "chrome", "size": 25, "label": 1, "functionSource": "void vp9_iht16x16_256_add_c ( const int16_t * input , uint8_t * dest , int stride , int tx_type ) {\n int i , j ;\n int16_t out [ 16 * 16 ] ;\n int16_t * outptr = out ;\n int16_t temp_in [ 16 ] , temp_out [ 16 ] ;\n const transform_2d ht = IHT_16 [ tx_type ] ;\n for ( i = 0 ;\n i < 16 ;\n ++ i ) {\n ht . rows ( input , outptr ) ;\n input += 16 ;\n outptr += 16 ;\n }\n for ( i = 0 ;\n i < 16 ;\n ++ i ) {\n for ( j = 0 ;\n j < 16 ;\n ++ j ) temp_in [ j ] = out [ j * 16 + i ] ;\n ht . cols ( temp_in , temp_out ) ;\n for ( j = 0 ;\n j < 16 ;\n ++ j ) dest [ j * stride + i ] = clip_pixel ( ROUND_POWER_OF_TWO ( temp_out [ j ] , 6 ) + dest [ j * stride + i ] ) ;\n }\n }", "idx": 21110}
{"hash": -6068976579504840746, "project": "debian", "size": 15, "label": 0, "functionSource": "static void ctl_putunqstr ( const char * tag , const char * data , size_t len ) {\n char buffer [ 512 ] ;\n char * cp ;\n size_t tl ;\n tl = strlen ( tag ) ;\n memcpy ( buffer , tag , tl ) ;\n cp = buffer + tl ;\n if ( len > 0 ) {\n INSIST ( tl + 1 + len <= sizeof ( buffer ) ) ;\n * cp ++ = '=' ;\n memcpy ( cp , data , len ) ;\n cp += len ;\n }\n ctl_putdata ( buffer , ( u_int ) ( cp - buffer ) , 0 ) ;\n }", "idx": 21111}
{"hash": 3919646340804521652, "project": "debian", "size": 18, "label": 0, "functionSource": "static int check_pack_inflate ( struct packed_git * p , struct pack_window * * w_curs , off_t offset , off_t len , unsigned long expect ) {\n git_zstream stream ;\n unsigned char fakebuf [ 4096 ] , * in ;\n int st ;\n memset ( & stream , 0 , sizeof ( stream ) ) ;\n git_inflate_init ( & stream ) ;\n do {\n in = use_pack ( p , w_curs , offset , & stream . avail_in ) ;\n stream . next_in = in ;\n stream . next_out = fakebuf ;\n stream . avail_out = sizeof ( fakebuf ) ;\n st = git_inflate ( & stream , Z_FINISH ) ;\n offset += stream . next_in - in ;\n }\n while ( st == Z_OK || st == Z_BUF_ERROR ) ;\n git_inflate_end ( & stream ) ;\n return ( st == Z_STREAM_END && stream . total_out == expect && stream . total_in == len ) ? 0 : - 1 ;\n }", "idx": 21112}
{"hash": 927123821003322045, "project": "chrome", "size": 15, "label": 1, "functionSource": "IN_PROC_BROWSER_TEST_F ( PageLoadMetricsBrowserTest , PayloadSizeIgnoresDownloads ) {\n ASSERT_TRUE ( embedded_test_server ( ) -> Start ( ) ) ;\n bool prev_io_allowed = base : : ThreadRestrictions : : SetIOAllowed ( true ) ;\n {\n base : : ScopedTempDir downloads_directory ;\n ASSERT_TRUE ( downloads_directory . CreateUniqueTempDir ( ) ) ;\n browser ( ) -> profile ( ) -> GetPrefs ( ) -> SetFilePath ( prefs : : kDownloadDefaultDirectory , downloads_directory . GetPath ( ) ) ;\n content : : DownloadTestObserverTerminal downloads_observer ( content : : BrowserContext : : GetDownloadManager ( browser ( ) -> profile ( ) ) , 1 , content : : DownloadTestObserver : : ON_DANGEROUS_DOWNLOAD_FAIL ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , embedded_test_server ( ) -> GetURL ( \"/page_load_metrics/download_anchor_click.html\" ) ) ;\n downloads_observer . WaitForFinished ( ) ;\n }\n base : : ThreadRestrictions : : SetIOAllowed ( prev_io_allowed ) ;\n NavigateToUntrackedUrl ( ) ;\n histogram_tester_ . ExpectUniqueSample ( internal : : kHistogramPageLoadTotalBytes , 0 , 1 ) ;\n }", "idx": 21113}
{"hash": -1929262071302712016, "project": "debian", "size": 23, "label": 0, "functionSource": "static cmsBool Type_MPEclut_Write ( struct _cms_typehandler_struct * self , cmsIOHANDLER * io , void * Ptr , cmsUInt32Number nItems ) {\n cmsUInt8Number Dimensions8 [ 16 ] ;\n cmsUInt32Number i ;\n cmsStage * mpe = ( cmsStage * ) Ptr ;\n _cmsStageCLutData * clut = ( _cmsStageCLutData * ) mpe -> Data ;\n if ( mpe -> InputChannels > MAX_INPUT_DIMENSIONS ) return FALSE ;\n if ( clut -> HasFloatValues == FALSE ) return FALSE ;\n if ( ! _cmsWriteUInt16Number ( io , ( cmsUInt16Number ) mpe -> InputChannels ) ) return FALSE ;\n if ( ! _cmsWriteUInt16Number ( io , ( cmsUInt16Number ) mpe -> OutputChannels ) ) return FALSE ;\n memset ( Dimensions8 , 0 , sizeof ( Dimensions8 ) ) ;\n for ( i = 0 ;\n i < mpe -> InputChannels ;\n i ++ ) Dimensions8 [ i ] = ( cmsUInt8Number ) clut -> Params -> nSamples [ i ] ;\n if ( ! io -> Write ( io , 16 , Dimensions8 ) ) return FALSE ;\n for ( i = 0 ;\n i < clut -> nEntries ;\n i ++ ) {\n if ( ! _cmsWriteFloat32Number ( io , clut -> Tab . TFloat [ i ] ) ) return FALSE ;\n }\n return TRUE ;\n cmsUNUSED_PARAMETER ( nItems ) ;\n cmsUNUSED_PARAMETER ( self ) ;\n }", "idx": 21114}
{"hash": 2895622461494525400, "project": "debian", "size": 125, "label": 0, "functionSource": "static void test_prepare ( ) {\n MYSQL_STMT * stmt ;\n int rc , i ;\n int int_data , o_int_data ;\n char str_data [ 50 ] , data [ 50 ] ;\n char tiny_data , o_tiny_data ;\n short small_data , o_small_data ;\n longlong big_data , o_big_data ;\n float real_data , o_real_data ;\n double double_data , o_double_data ;\n ulong length [ 7 ] , len ;\n my_bool is_null [ 7 ] ;\n char llbuf [ 22 ] ;\n MYSQL_BIND my_bind [ 7 ] ;\n char query [ MAX_TEST_QUERY_LENGTH ] ;\n myheader ( \"test_prepare\" ) ;\n rc = mysql_autocommit ( mysql , TRUE ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"DROP TABLE IF EXISTS my_prepare\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"CREATE TABLE my_prepare(col1 tinyint, \" \"col2 varchar(15), col3 int, \" \"col4 smallint, col5 bigint, \" \"col6 float, col7 double )\" ) ;\n myquery ( rc ) ;\n strxmov ( query , \"INSERT INTO my_prepare VALUES(?, ?, ?, ?, ?, ?, ?)\" , NullS ) ;\n stmt = mysql_simple_prepare ( mysql , query ) ;\n check_stmt ( stmt ) ;\n verify_param_count ( stmt , 7 ) ;\n memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n my_bind [ 0 ] . buffer_type = MYSQL_TYPE_TINY ;\n my_bind [ 0 ] . buffer = ( void * ) & tiny_data ;\n my_bind [ 1 ] . buffer_type = MYSQL_TYPE_STRING ;\n my_bind [ 1 ] . buffer = ( void * ) str_data ;\n my_bind [ 1 ] . buffer_length = 1000 ;\n my_bind [ 2 ] . buffer_type = MYSQL_TYPE_LONG ;\n my_bind [ 2 ] . buffer = ( void * ) & int_data ;\n my_bind [ 3 ] . buffer_type = MYSQL_TYPE_SHORT ;\n my_bind [ 3 ] . buffer = ( void * ) & small_data ;\n my_bind [ 4 ] . buffer_type = MYSQL_TYPE_LONGLONG ;\n my_bind [ 4 ] . buffer = ( void * ) & big_data ;\n my_bind [ 5 ] . buffer_type = MYSQL_TYPE_FLOAT ;\n my_bind [ 5 ] . buffer = ( void * ) & real_data ;\n my_bind [ 6 ] . buffer_type = MYSQL_TYPE_DOUBLE ;\n my_bind [ 6 ] . buffer = ( void * ) & double_data ;\n for ( i = 0 ;\n i < ( int ) array_elements ( my_bind ) ;\n i ++ ) {\n my_bind [ i ] . length = & length [ i ] ;\n my_bind [ i ] . is_null = & is_null [ i ] ;\n is_null [ i ] = 0 ;\n }\n rc = mysql_stmt_bind_param ( stmt , my_bind ) ;\n check_execute ( stmt , rc ) ;\n int_data = 320 ;\n small_data = 1867 ;\n big_data = 1000 ;\n real_data = 2 ;\n double_data = 6578.001 ;\n for ( tiny_data = 0 ;\n tiny_data < 100 ;\n tiny_data ++ ) {\n length [ 1 ] = sprintf ( str_data , \"MySQL%d\" , int_data ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n int_data += 25 ;\n small_data += 10 ;\n big_data += 100 ;\n real_data += 1 ;\n double_data += 10.09 ;\n }\n mysql_stmt_close ( stmt ) ;\n rc = mysql_commit ( mysql ) ;\n myquery ( rc ) ;\n rc = my_stmt_result ( \"SELECT * FROM my_prepare\" ) ;\n DIE_UNLESS ( tiny_data == ( char ) rc ) ;\n stmt = mysql_simple_prepare ( mysql , \"SELECT * FROM my_prepare\" ) ;\n check_stmt ( stmt ) ;\n rc = mysql_stmt_bind_result ( stmt , my_bind ) ;\n check_execute ( stmt , rc ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n o_int_data = 320 ;\n o_small_data = 1867 ;\n o_big_data = 1000 ;\n o_real_data = 2 ;\n o_double_data = 6578.001 ;\n for ( o_tiny_data = 0 ;\n o_tiny_data < 100 ;\n o_tiny_data ++ ) {\n len = sprintf ( data , \"MySQL%d\" , o_int_data ) ;\n rc = mysql_stmt_fetch ( stmt ) ;\n check_execute ( stmt , rc ) ;\n if ( ! opt_silent ) {\n fprintf ( stdout , \"\\n\" ) ;\n fprintf ( stdout , \"\\n\\t tiny : %d (%lu)\" , tiny_data , length [ 0 ] ) ;\n fprintf ( stdout , \"\\n\\t short : %d (%lu)\" , small_data , length [ 3 ] ) ;\n fprintf ( stdout , \"\\n\\t int : %d (%lu)\" , int_data , length [ 2 ] ) ;\n fprintf ( stdout , \"\\n\\t big : %s (%lu)\" , llstr ( big_data , llbuf ) , length [ 4 ] ) ;\n fprintf ( stdout , \"\\n\\t float : %f (%lu)\" , real_data , length [ 5 ] ) ;\n fprintf ( stdout , \"\\n\\t double : %f (%lu)\" , double_data , length [ 6 ] ) ;\n fprintf ( stdout , \"\\n\\t str : %s (%lu)\" , str_data , length [ 1 ] ) ;\n }\n DIE_UNLESS ( tiny_data == o_tiny_data ) ;\n DIE_UNLESS ( is_null [ 0 ] == 0 ) ;\n DIE_UNLESS ( length [ 0 ] == 1 ) ;\n DIE_UNLESS ( int_data == o_int_data ) ;\n DIE_UNLESS ( length [ 2 ] == 4 ) ;\n DIE_UNLESS ( small_data == o_small_data ) ;\n DIE_UNLESS ( length [ 3 ] == 2 ) ;\n DIE_UNLESS ( big_data == o_big_data ) ;\n DIE_UNLESS ( length [ 4 ] == 8 ) ;\n DIE_UNLESS ( real_data == o_real_data ) ;\n DIE_UNLESS ( length [ 5 ] == 4 ) ;\n DIE_UNLESS ( cmp_double ( & double_data , & o_double_data ) ) ;\n DIE_UNLESS ( length [ 6 ] == 8 ) ;\n DIE_UNLESS ( strcmp ( data , str_data ) == 0 ) ;\n DIE_UNLESS ( length [ 1 ] == len ) ;\n o_int_data += 25 ;\n o_small_data += 10 ;\n o_big_data += 100 ;\n o_real_data += 1 ;\n o_double_data += 10.09 ;\n }\n rc = mysql_stmt_fetch ( stmt ) ;\n DIE_UNLESS ( rc == MYSQL_NO_DATA ) ;\n mysql_stmt_close ( stmt ) ;\n }", "idx": 21115}
{"hash": 6595989226414083189, "project": "debian", "size": 12, "label": 0, "functionSource": "void rds_clear_recv_queue ( struct rds_sock * rs ) {\n struct sock * sk = rds_rs_to_sk ( rs ) ;\n struct rds_incoming * inc , * tmp ;\n unsigned long flags ;\n write_lock_irqsave ( & rs -> rs_recv_lock , flags ) ;\n list_for_each_entry_safe ( inc , tmp , & rs -> rs_recv_queue , i_item ) {\n rds_recv_rcvbuf_delta ( rs , sk , inc -> i_conn -> c_lcong , - be32_to_cpu ( inc -> i_hdr . h_len ) , inc -> i_hdr . h_dport ) ;\n list_del_init ( & inc -> i_item ) ;\n rds_inc_put ( inc ) ;\n }\n write_unlock_irqrestore ( & rs -> rs_recv_lock , flags ) ;\n }", "idx": 21116}
{"hash": -992498691684812004, "project": "chrome", "size": 11, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( PrefsFunctionalTest , TestDownloadDirPref ) {\n ASSERT_TRUE ( embedded_test_server ( ) -> Start ( ) ) ;\n base : : FilePath new_download_dir = DownloadPrefs ( browser ( ) -> profile ( ) ) . DownloadPath ( ) . AppendASCII ( \"subdir\" ) ;\n base : : FilePath downloaded_pkg = new_download_dir . AppendASCII ( \"a_zip_file.zip\" ) ;\n browser ( ) -> profile ( ) -> GetPrefs ( ) -> SetFilePath ( prefs : : kDownloadDefaultDirectory , new_download_dir ) ;\n std : : unique_ptr < content : : DownloadTestObserver > downloads_observer ( CreateWaiter ( browser ( ) , 1 ) ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , embedded_test_server ( ) -> GetURL ( \"/downloads/a_zip_file.zip\" ) ) ;\n downloads_observer -> WaitForFinished ( ) ;\n base : : ScopedAllowBlockingForTesting allow_blocking ;\n EXPECT_TRUE ( base : : PathExists ( downloaded_pkg ) ) ;\n }", "idx": 21117}
{"hash": -3053641395158209010, "project": "debian", "size": 27, "label": 0, "functionSource": "static int x ( struct vcache * avc , int afun , struct vrequest * areq , \\ struct afs_pdata * ain , struct afs_pdata * aout , \\ afs_ucred_t * * acred ) DECL_PIOCTL ( PGetFID ) ;\n DECL_PIOCTL ( PSetAcl ) ;\n DECL_PIOCTL ( PStoreBehind ) ;\n DECL_PIOCTL ( PGCPAGs ) ;\n DECL_PIOCTL ( PGetAcl ) ;\n DECL_PIOCTL ( PNoop ) ;\n DECL_PIOCTL ( PBogus ) ;\n DECL_PIOCTL ( PGetFileCell ) ;\n DECL_PIOCTL ( PGetWSCell ) ;\n DECL_PIOCTL ( PGetUserCell ) ;\n DECL_PIOCTL ( PSetTokens ) ;\n DECL_PIOCTL ( PGetVolumeStatus ) ;\n DECL_PIOCTL ( PSetVolumeStatus ) ;\n DECL_PIOCTL ( PFlush ) ;\n DECL_PIOCTL ( PNewStatMount ) ;\n DECL_PIOCTL ( PGetTokens ) ;\n DECL_PIOCTL ( PUnlog ) ;\n DECL_PIOCTL ( PMariner ) ;\n DECL_PIOCTL ( PCheckServers ) ;\n DECL_PIOCTL ( PCheckVolNames ) ;\n DECL_PIOCTL ( PCheckAuth ) ;\n DECL_PIOCTL ( PFindVolume ) ;\n DECL_PIOCTL ( PViceAccess ) ;\n DECL_PIOCTL ( PSetCacheSize ) ;\n DECL_PIOCTL ( PGetCacheSize ) ;\n DECL_PIOCTL ( PRemoveCallBack ) ;\n DECL_PIOCTL ( PNewCell )", "idx": 21118}
{"hash": 8572106347813672436, "project": "debian", "size": 11, "label": 0, "functionSource": "static int pfkey_release ( struct socket * sock ) {\n struct sock * sk = sock -> sk ;\n if ( ! sk ) return 0 ;\n pfkey_remove ( sk ) ;\n sock_orphan ( sk ) ;\n sock -> sk = NULL ;\n skb_queue_purge ( & sk -> sk_write_queue ) ;\n synchronize_rcu ( ) ;\n sock_put ( sk ) ;\n return 0 ;\n }", "idx": 21119}
{"hash": 2687336064028423153, "project": "chrome", "size": 67, "label": 0, "functionSource": "int evdns_resolv_conf_parse ( int flags , const char * const filename ) {\n struct stat st ;\n int fd , n , r ;\n u8 * resolv ;\n char * start ;\n int err = 0 ;\n log ( EVDNS_LOG_DEBUG , \"Parsing resolv.conf file %s\" , filename ) ;\n fd = open ( filename , O_RDONLY ) ;\n if ( fd < 0 ) {\n evdns_resolv_set_defaults ( flags ) ;\n return 1 ;\n }\n if ( fstat ( fd , & st ) ) {\n err = 2 ;\n goto out1 ;\n }\n if ( ! st . st_size ) {\n evdns_resolv_set_defaults ( flags ) ;\n err = ( flags & DNS_OPTION_NAMESERVERS ) ? 6 : 0 ;\n goto out1 ;\n }\n if ( st . st_size > 65535 ) {\n err = 3 ;\n goto out1 ;\n }\n resolv = ( u8 * ) malloc ( ( size_t ) st . st_size + 1 ) ;\n if ( ! resolv ) {\n err = 4 ;\n goto out1 ;\n }\n n = 0 ;\n while ( ( r = read ( fd , resolv + n , ( size_t ) st . st_size - n ) ) > 0 ) {\n n += r ;\n if ( n == st . st_size ) break ;\n assert ( n < st . st_size ) ;\n }\n if ( r < 0 ) {\n err = 5 ;\n goto out2 ;\n }\n resolv [ n ] = 0 ;\n start = ( char * ) resolv ;\n for ( ;\n ;\n ) {\n char * const newline = strchr ( start , '\\n' ) ;\n if ( ! newline ) {\n resolv_conf_parse_line ( start , flags ) ;\n break ;\n }\n else {\n * newline = 0 ;\n resolv_conf_parse_line ( start , flags ) ;\n start = newline + 1 ;\n }\n }\n if ( ! server_head && ( flags & DNS_OPTION_NAMESERVERS ) ) {\n evdns_nameserver_ip_add ( \"127.0.0.1\" ) ;\n err = 6 ;\n }\n if ( flags & DNS_OPTION_SEARCH && ( ! global_search_state || global_search_state -> num_domains == 0 ) ) {\n search_set_from_hostname ( ) ;\n }\n out2 : free ( resolv ) ;\n out1 : close ( fd ) ;\n return err ;\n }", "idx": 21120}
{"hash": 2578089348587614328, "project": "debian", "size": 3, "label": 0, "functionSource": "int i2d_RSAPrivateKey_fp ( FILE * fp , RSA * rsa ) {\n return ASN1_item_i2d_fp ( ASN1_ITEM_rptr ( RSAPrivateKey ) , fp , rsa ) ;\n }", "idx": 21121}
{"hash": -755883256379441954, "project": "chrome", "size": 121, "label": 1, "functionSource": "void vp9_ ## type ## _predictor_ ## size ## x ## size ## _c ( uint8_t * dst , ptrdiff_t stride , const uint8_t * above , const uint8_t * left ) {\n type ## _predictor ( dst , stride , size , above , left ) ;\n }\n # define intra_pred_allsizes ( type ) intra_pred_sized ( type , 4 ) intra_pred_sized ( type , 8 ) intra_pred_sized ( type , 16 ) intra_pred_sized ( type , 32 ) static INLINE void d207_predictor ( uint8_t * dst , ptrdiff_t stride , int bs , const uint8_t * above , const uint8_t * left ) {\n int r , c ;\n ( void ) above ;\n for ( r = 0 ;\n r < bs - 1 ;\n ++ r ) dst [ r * stride ] = ROUND_POWER_OF_TWO ( left [ r ] + left [ r + 1 ] , 1 ) ;\n dst [ ( bs - 1 ) * stride ] = left [ bs - 1 ] ;\n dst ++ ;\n for ( r = 0 ;\n r < bs - 2 ;\n ++ r ) dst [ r * stride ] = ROUND_POWER_OF_TWO ( left [ r ] + left [ r + 1 ] * 2 + left [ r + 2 ] , 2 ) ;\n dst [ ( bs - 2 ) * stride ] = ROUND_POWER_OF_TWO ( left [ bs - 2 ] + left [ bs - 1 ] * 3 , 2 ) ;\n dst [ ( bs - 1 ) * stride ] = left [ bs - 1 ] ;\n dst ++ ;\n for ( c = 0 ;\n c < bs - 2 ;\n ++ c ) dst [ ( bs - 1 ) * stride + c ] = left [ bs - 1 ] ;\n for ( r = bs - 2 ;\n r >= 0 ;\n -- r ) for ( c = 0 ;\n c < bs - 2 ;\n ++ c ) dst [ r * stride + c ] = dst [ ( r + 1 ) * stride + c - 2 ] ;\n }\n intra_pred_allsizes ( d207 ) static INLINE void d63_predictor ( uint8_t * dst , ptrdiff_t stride , int bs , const uint8_t * above , const uint8_t * left ) {\n int r , c ;\n ( void ) left ;\n for ( r = 0 ;\n r < bs ;\n ++ r ) {\n for ( c = 0 ;\n c < bs ;\n ++ c ) dst [ c ] = r & 1 ? ROUND_POWER_OF_TWO ( above [ r / 2 + c ] + above [ r / 2 + c + 1 ] * 2 + above [ r / 2 + c + 2 ] , 2 ) : ROUND_POWER_OF_TWO ( above [ r / 2 + c ] + above [ r / 2 + c + 1 ] , 1 ) ;\n dst += stride ;\n }\n }\n intra_pred_allsizes ( d63 ) static INLINE void d45_predictor ( uint8_t * dst , ptrdiff_t stride , int bs , const uint8_t * above , const uint8_t * left ) {\n int r , c ;\n ( void ) left ;\n for ( r = 0 ;\n r < bs ;\n ++ r ) {\n for ( c = 0 ;\n c < bs ;\n ++ c ) dst [ c ] = r + c + 2 < bs * 2 ? ROUND_POWER_OF_TWO ( above [ r + c ] + above [ r + c + 1 ] * 2 + above [ r + c + 2 ] , 2 ) : above [ bs * 2 - 1 ] ;\n dst += stride ;\n }\n }\n intra_pred_allsizes ( d45 ) static INLINE void d117_predictor ( uint8_t * dst , ptrdiff_t stride , int bs , const uint8_t * above , const uint8_t * left ) {\n int r , c ;\n for ( c = 0 ;\n c < bs ;\n c ++ ) dst [ c ] = ROUND_POWER_OF_TWO ( above [ c - 1 ] + above [ c ] , 1 ) ;\n dst += stride ;\n dst [ 0 ] = ROUND_POWER_OF_TWO ( left [ 0 ] + above [ - 1 ] * 2 + above [ 0 ] , 2 ) ;\n for ( c = 1 ;\n c < bs ;\n c ++ ) dst [ c ] = ROUND_POWER_OF_TWO ( above [ c - 2 ] + above [ c - 1 ] * 2 + above [ c ] , 2 ) ;\n dst += stride ;\n dst [ 0 ] = ROUND_POWER_OF_TWO ( above [ - 1 ] + left [ 0 ] * 2 + left [ 1 ] , 2 ) ;\n for ( r = 3 ;\n r < bs ;\n ++ r ) dst [ ( r - 2 ) * stride ] = ROUND_POWER_OF_TWO ( left [ r - 3 ] + left [ r - 2 ] * 2 + left [ r - 1 ] , 2 ) ;\n for ( r = 2 ;\n r < bs ;\n ++ r ) {\n for ( c = 1 ;\n c < bs ;\n c ++ ) dst [ c ] = dst [ - 2 * stride + c - 1 ] ;\n dst += stride ;\n }\n }\n intra_pred_allsizes ( d117 ) static INLINE void d135_predictor ( uint8_t * dst , ptrdiff_t stride , int bs , const uint8_t * above , const uint8_t * left ) {\n int r , c ;\n dst [ 0 ] = ROUND_POWER_OF_TWO ( left [ 0 ] + above [ - 1 ] * 2 + above [ 0 ] , 2 ) ;\n for ( c = 1 ;\n c < bs ;\n c ++ ) dst [ c ] = ROUND_POWER_OF_TWO ( above [ c - 2 ] + above [ c - 1 ] * 2 + above [ c ] , 2 ) ;\n dst [ stride ] = ROUND_POWER_OF_TWO ( above [ - 1 ] + left [ 0 ] * 2 + left [ 1 ] , 2 ) ;\n for ( r = 2 ;\n r < bs ;\n ++ r ) dst [ r * stride ] = ROUND_POWER_OF_TWO ( left [ r - 2 ] + left [ r - 1 ] * 2 + left [ r ] , 2 ) ;\n dst += stride ;\n for ( r = 1 ;\n r < bs ;\n ++ r ) {\n for ( c = 1 ;\n c < bs ;\n c ++ ) dst [ c ] = dst [ - stride + c - 1 ] ;\n dst += stride ;\n }\n }\n intra_pred_allsizes ( d135 ) static INLINE void d153_predictor ( uint8_t * dst , ptrdiff_t stride , int bs , const uint8_t * above , const uint8_t * left ) {\n int r , c ;\n dst [ 0 ] = ROUND_POWER_OF_TWO ( above [ - 1 ] + left [ 0 ] , 1 ) ;\n for ( r = 1 ;\n r < bs ;\n r ++ ) dst [ r * stride ] = ROUND_POWER_OF_TWO ( left [ r - 1 ] + left [ r ] , 1 ) ;\n dst ++ ;\n dst [ 0 ] = ROUND_POWER_OF_TWO ( left [ 0 ] + above [ - 1 ] * 2 + above [ 0 ] , 2 ) ;\n dst [ stride ] = ROUND_POWER_OF_TWO ( above [ - 1 ] + left [ 0 ] * 2 + left [ 1 ] , 2 ) ;\n for ( r = 2 ;\n r < bs ;\n r ++ ) dst [ r * stride ] = ROUND_POWER_OF_TWO ( left [ r - 2 ] + left [ r - 1 ] * 2 + left [ r ] , 2 ) ;\n dst ++ ;\n for ( c = 0 ;\n c < bs - 2 ;\n c ++ ) dst [ c ] = ROUND_POWER_OF_TWO ( above [ c - 1 ] + above [ c ] * 2 + above [ c + 1 ] , 2 ) ;\n dst += stride ;\n for ( r = 1 ;\n r < bs ;\n ++ r ) {\n for ( c = 0 ;\n c < bs - 2 ;\n c ++ ) dst [ c ] = dst [ - stride + c - 2 ] ;\n dst += stride ;\n }\n }\n intra_pred_allsizes ( d153 )", "idx": 21122}
{"hash": -5725800580349519214, "project": "chrome", "size": 37, "label": 0, "functionSource": "vpx_codec_err_t vp9_parse_superframe_index ( const uint8_t * data , size_t data_sz , uint32_t sizes [ 8 ] , int * count , vpx_decrypt_cb decrypt_cb , void * decrypt_state ) {\n uint8_t marker ;\n assert ( data_sz ) ;\n marker = read_marker ( decrypt_cb , decrypt_state , data + data_sz - 1 ) ;\n * count = 0 ;\n if ( ( marker & 0xe0 ) == 0xc0 ) {\n const uint32_t frames = ( marker & 0x7 ) + 1 ;\n const uint32_t mag = ( ( marker >> 3 ) & 0x3 ) + 1 ;\n const size_t index_sz = 2 + mag * frames ;\n if ( data_sz < index_sz ) return VPX_CODEC_CORRUPT_FRAME ;\n {\n const uint8_t marker2 = read_marker ( decrypt_cb , decrypt_state , data + data_sz - index_sz ) ;\n if ( marker != marker2 ) return VPX_CODEC_CORRUPT_FRAME ;\n }\n {\n uint32_t i , j ;\n const uint8_t * x = & data [ data_sz - index_sz + 1 ] ;\n uint8_t clear_buffer [ 32 ] ;\n assert ( sizeof ( clear_buffer ) >= frames * mag ) ;\n if ( decrypt_cb ) {\n decrypt_cb ( decrypt_state , x , clear_buffer , frames * mag ) ;\n x = clear_buffer ;\n }\n for ( i = 0 ;\n i < frames ;\n ++ i ) {\n uint32_t this_sz = 0 ;\n for ( j = 0 ;\n j < mag ;\n ++ j ) this_sz |= ( * x ++ ) << ( j * 8 ) ;\n sizes [ i ] = this_sz ;\n }\n * count = frames ;\n }\n }\n return VPX_CODEC_OK ;\n }", "idx": 21123}
{"hash": -5640788001150418304, "project": "debian", "size": 86, "label": 0, "functionSource": "void proto_register_t38 ( void ) {\n static hf_register_info hf [ ] = {\n # include \"packet-t38-hfarr.c\" {\n & hf_t38_setup , {\n \"Stream setup\" , \"t38.setup\" , FT_STRING , BASE_NONE , NULL , 0x0 , \"Stream setup, method and frame number\" , HFILL }\n }\n , {\n & hf_t38_setup_frame , {\n \"Stream frame\" , \"t38.setup-frame\" , FT_FRAMENUM , BASE_NONE , NULL , 0x0 , \"Frame that set up this stream\" , HFILL }\n }\n , {\n & hf_t38_setup_method , {\n \"Stream Method\" , \"t38.setup-method\" , FT_STRING , BASE_NONE , NULL , 0x0 , \"Method used to set up this stream\" , HFILL }\n }\n , {\n & hf_t38_fragments , {\n \"Message fragments\" , \"t38.fragments\" , FT_NONE , BASE_NONE , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_t38_fragment , {\n \"Message fragment\" , \"t38.fragment\" , FT_FRAMENUM , BASE_NONE , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_t38_fragment_overlap , {\n \"Message fragment overlap\" , \"t38.fragment.overlap\" , FT_BOOLEAN , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_t38_fragment_overlap_conflicts , {\n \"Message fragment overlapping with conflicting data\" , \"t38.fragment.overlap.conflicts\" , FT_BOOLEAN , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_t38_fragment_multiple_tails , {\n \"Message has multiple tail fragments\" , \"t38.fragment.multiple_tails\" , FT_BOOLEAN , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_t38_fragment_too_long_fragment , {\n \"Message fragment too long\" , \"t38.fragment.too_long_fragment\" , FT_BOOLEAN , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_t38_fragment_error , {\n \"Message defragmentation error\" , \"t38.fragment.error\" , FT_FRAMENUM , BASE_NONE , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_t38_fragment_count , {\n \"Message fragment count\" , \"t38.fragment.count\" , FT_UINT32 , BASE_DEC , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_t38_reassembled_in , {\n \"Reassembled in\" , \"t38.reassembled.in\" , FT_FRAMENUM , BASE_NONE , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_t38_reassembled_length , {\n \"Reassembled T38 length\" , \"t38.reassembled.length\" , FT_UINT32 , BASE_DEC , NULL , 0x00 , NULL , HFILL }\n }\n , }\n ;\n static gint * ett [ ] = {\n & ett_t38 , # include \"packet-t38-ettarr.c\" & ett_t38_setup , & ett_data_fragment , & ett_data_fragments }\n ;\n static ei_register_info ei [ ] = {\n {\n & ei_t38_malformed , {\n \"t38.malformed\" , PI_MALFORMED , PI_ERROR , \"Malformed packet\" , EXPFILL }\n }\n , }\n ;\n module_t * t38_module ;\n expert_module_t * expert_t38 ;\n proto_t38 = proto_register_protocol ( \"T.38\" , \"T.38\" , \"t38\" ) ;\n proto_register_field_array ( proto_t38 , hf , array_length ( hf ) ) ;\n proto_register_subtree_array ( ett , array_length ( ett ) ) ;\n expert_t38 = expert_register_protocol ( proto_t38 ) ;\n expert_register_field_array ( expert_t38 , ei , array_length ( ei ) ) ;\n register_dissector ( \"t38_udp\" , dissect_t38_udp , proto_t38 ) ;\n register_init_routine ( t38_defragment_init ) ;\n register_cleanup_routine ( t38_defragment_cleanup ) ;\n t38_tap = register_tap ( \"t38\" ) ;\n t38_module = prefs_register_protocol ( proto_t38 , proto_reg_handoff_t38 ) ;\n prefs_register_bool_preference ( t38_module , \"use_pre_corrigendum_asn1_specification\" , \"Use the Pre-Corrigendum ASN.1 specification\" , \"Whether the T.38 dissector should decode using the Pre-Corrigendum T.38 \" \"ASN.1 specification (1998).\" , & use_pre_corrigendum_asn1_specification ) ;\n prefs_register_bool_preference ( t38_module , \"dissect_possible_rtpv2_packets_as_rtp\" , \"Dissect possible RTP version 2 packets with RTP dissector\" , \"Whether a UDP packet that looks like RTP version 2 packet will \" \"be dissected as RTP packet or T.38 packet. If enabled there is a risk that T.38 UDPTL \" \"packets with sequence number higher than 32767 may be dissected as RTP.\" , & dissect_possible_rtpv2_packets_as_rtp ) ;\n prefs_register_uint_preference ( t38_module , \"tcp.port\" , \"T.38 TCP Port\" , \"Set the TCP port for T.38 messages\" , 10 , & global_t38_tcp_port ) ;\n prefs_register_uint_preference ( t38_module , \"udp.port\" , \"T.38 UDP Port\" , \"Set the UDP port for T.38 messages\" , 10 , & global_t38_udp_port ) ;\n prefs_register_bool_preference ( t38_module , \"reassembly\" , \"Reassemble T.38 PDUs over TPKT over TCP\" , \"Whether the dissector should reassemble T.38 PDUs spanning multiple TCP segments \" \"when TPKT is used over TCP. \" \"To use this option, you must also enable \\\"Allow subdissectors to reassemble \" \"TCP streams\\\" in the TCP protocol settings.\" , & t38_tpkt_reassembly ) ;\n prefs_register_enum_preference ( t38_module , \"tpkt_usage\" , \"TPKT used over TCP\" , \"Whether T.38 is used with TPKT for TCP\" , ( gint * ) & t38_tpkt_usage , t38_tpkt_options , FALSE ) ;\n prefs_register_bool_preference ( t38_module , \"show_setup_info\" , \"Show stream setup information\" , \"Where available, show which protocol and frame caused \" \"this T.38 stream to be created\" , & global_t38_show_setup_info ) ;\n }", "idx": 21124}
{"hash": -1315695702746584250, "project": "debian", "size": 3, "label": 0, "functionSource": "static void proto_tree_set_eui64 ( field_info * fi , const guint64 value ) {\n fvalue_set_uinteger64 ( & fi -> value , value ) ;\n }", "idx": 21125}
{"hash": 8127806390163862344, "project": "debian", "size": 3, "label": 0, "functionSource": "static void patch_byte ( CPUX86State * env , target_ulong addr , uint8_t byte ) {\n cpu_memory_rw_debug ( env , addr , & byte , 1 , 1 ) ;\n }", "idx": 21126}
{"hash": 2895622461494525400, "project": "debian", "size": 59, "label": 0, "functionSource": "static void test_bug43560 ( void ) {\n MYSQL * conn ;\n uint rc ;\n MYSQL_STMT * stmt = 0 ;\n MYSQL_BIND bind ;\n my_bool is_null = 0 ;\n char buffer [ 256 ] ;\n const uint BUFSIZE = sizeof ( buffer ) ;\n const char * values [ ] = {\n \"eins\" , \"zwei\" , \"drei\" , \"viele\" , NULL }\n ;\n const char insert_str [ ] = \"INSERT INTO t1 (c2) VALUES (?)\" ;\n unsigned long length ;\n const unsigned int drop_db = opt_drop_db ;\n DBUG_ENTER ( \"test_bug43560\" ) ;\n myheader ( \"test_bug43560\" ) ;\n if ( ! strstr ( mysql -> server_version , \"debug\" ) ) {\n fprintf ( stdout , \"Skipping test_bug43560: server not DEBUG version\\n\" ) ;\n DBUG_VOID_RETURN ;\n }\n conn = client_connect ( 0 , MYSQL_PROTOCOL_TCP , 0 ) ;\n rc = mysql_query ( conn , \"DROP TABLE IF EXISTS t1\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( conn , \"CREATE TABLE t1 (c1 INT PRIMARY KEY AUTO_INCREMENT, c2 CHAR(10))\" ) ;\n myquery ( rc ) ;\n stmt = mysql_stmt_init ( conn ) ;\n check_stmt ( stmt ) ;\n rc = mysql_stmt_prepare ( stmt , insert_str , strlen ( insert_str ) ) ;\n check_execute ( stmt , rc ) ;\n memset ( & bind , 0 , sizeof ( bind ) ) ;\n bind . buffer_type = MYSQL_TYPE_STRING ;\n bind . buffer_length = BUFSIZE ;\n bind . buffer = buffer ;\n bind . is_null = & is_null ;\n bind . length = & length ;\n rc = mysql_stmt_bind_param ( stmt , & bind ) ;\n check_execute ( stmt , rc ) ;\n strncpy ( buffer , values [ 0 ] , BUFSIZE ) ;\n length = strlen ( buffer ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n rc = mysql_query ( conn , \"SET SESSION debug='+d,close_conn_after_stmt_execute'\" ) ;\n myquery ( rc ) ;\n strncpy ( buffer , values [ 1 ] , BUFSIZE ) ;\n length = strlen ( buffer ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n DIE_UNLESS ( rc && mysql_stmt_errno ( stmt ) == CR_SERVER_LOST ) ;\n strncpy ( buffer , values [ 2 ] , BUFSIZE ) ;\n length = strlen ( buffer ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n DIE_UNLESS ( rc && mysql_stmt_errno ( stmt ) == CR_SERVER_LOST ) ;\n mysql_stmt_close ( stmt ) ;\n opt_drop_db = 0 ;\n client_disconnect ( conn ) ;\n rc = mysql_query ( mysql , \"DROP TABLE t1\" ) ;\n myquery ( rc ) ;\n opt_drop_db = drop_db ;\n DBUG_VOID_RETURN ;\n }", "idx": 21127}
{"hash": -305162769887579921, "project": "debian", "size": 12, "label": 0, "functionSource": "static int encode_frame ( AVCodecContext * c , AVFrame * frame ) {\n AVPacket pkt = {\n 0 }\n ;\n int ret , got_output ;\n av_init_packet ( & pkt ) ;\n ret = avcodec_encode_video2 ( c , & pkt , frame , & got_output ) ;\n if ( ret < 0 ) return ret ;\n ret = pkt . size ;\n av_free_packet ( & pkt ) ;\n return ret ;\n }", "idx": 21128}
{"hash": 2895622461494525400, "project": "debian", "size": 26, "label": 0, "functionSource": "static void test_bug8722 ( ) {\n MYSQL_STMT * stmt ;\n int rc ;\n const char * stmt_text ;\n myheader ( \"test_bug8722\" ) ;\n stmt_text = \"drop table if exists t1, v1\" ;\n rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n myquery ( rc ) ;\n stmt_text = \"CREATE TABLE t1 (c1 varchar(10), c2 varchar(10), c3 varchar(10),\" \" c4 varchar(10), c5 varchar(10), c6 varchar(10),\" \" c7 varchar(10), c8 varchar(10), c9 varchar(10),\" \"c10 varchar(10))\" ;\n rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n myquery ( rc ) ;\n stmt_text = \"INSERT INTO t1 VALUES (1,2,3,4,5,6,7,8,9,10)\" ;\n rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n myquery ( rc ) ;\n stmt_text = \"CREATE VIEW v1 AS SELECT * FROM t1\" ;\n rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n myquery ( rc ) ;\n stmt = mysql_stmt_init ( mysql ) ;\n stmt_text = \"select * from v1\" ;\n rc = mysql_stmt_prepare ( stmt , stmt_text , strlen ( stmt_text ) ) ;\n check_execute ( stmt , rc ) ;\n mysql_stmt_close ( stmt ) ;\n stmt_text = \"drop table if exists t1, v1\" ;\n rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n myquery ( rc ) ;\n }", "idx": 21129}
{"hash": -1381237731082039179, "project": "debian", "size": 34, "label": 0, "functionSource": "static int process_rec_header2_v145 ( wtap * wth , unsigned char * buffer , guint16 length , gint16 maj_vers , int * err , gchar * * err_info ) {\n if ( length < 5 ) {\n * err = WTAP_ERR_UNSUPPORTED ;\n * err_info = g_strdup ( \"ngsniffer: WAN capture has no network subtype\" ) ;\n return - 1 ;\n }\n switch ( buffer [ 4 ] ) {\n case NET_SDLC : wth -> file_encap = WTAP_ENCAP_SDLC ;\n break ;\n case NET_HDLC : wth -> file_encap = WTAP_ENCAP_PER_PACKET ;\n break ;\n case NET_FRAME_RELAY : wth -> file_encap = WTAP_ENCAP_FRELAY_WITH_PHDR ;\n break ;\n case NET_ROUTER : wth -> file_encap = WTAP_ENCAP_PER_PACKET ;\n switch ( maj_vers ) {\n case 4 : if ( buffer [ 1 ] == 0xfa ) wth -> file_encap = WTAP_ENCAP_ISDN ;\n break ;\n case 5 : if ( length < 7 ) {\n * err = WTAP_ERR_UNSUPPORTED ;\n * err_info = g_strdup ( \"ngsniffer: WAN bridge/router capture has no ISDN flag\" ) ;\n return - 1 ;\n }\n if ( buffer [ 6 ] == 0x01 ) wth -> file_encap = WTAP_ENCAP_ISDN ;\n break ;\n }\n break ;\n case NET_PPP : wth -> file_encap = WTAP_ENCAP_PPP_WITH_PHDR ;\n break ;\n default : * err = WTAP_ERR_UNSUPPORTED ;\n * err_info = g_strdup_printf ( \"ngsniffer: WAN network subtype %u unknown or unsupported\" , buffer [ 4 ] ) ;\n return - 1 ;\n }\n return 0 ;\n }", "idx": 21130}
{"hash": 6600620671673714486, "project": "debian", "size": 15, "label": 0, "functionSource": "static void * i_alloc_struct_array ( gs_memory_t * mem , uint num_elements , gs_memory_type_ptr_t pstype , client_name_t cname ) {\n gs_ref_memory_t * const imem = ( gs_ref_memory_t * ) mem ;\n obj_header_t * obj ;\n ulong lsize ;\n # ifdef MEMENTO if ( Memento_failThisEvent ( ) ) return NULL ;\n # endif ALLOC_CHECK_SIZE ( mem , pstype ) ;\n # ifdef DEBUG if ( pstype -> enum_ptrs == basic_enum_ptrs ) {\n dmprintf2 ( mem , \" i_alloc_struct_array: called with incorrect structure type (not element), struct='%s', client='%s'\\n\" , pstype -> sname , cname ) ;\n return NULL ;\n }\n # endif if ( alloc_array_check_size ( num_elements , pstype -> ssize , & lsize ) == false ) return NULL ;\n obj = alloc_obj ( imem , lsize , pstype , ALLOC_DIRECT , cname ) ;\n if_debug7m ( 'A' , mem , \"[a%d:+<.]%s %s*(%lu=%u*%u) = 0x%lx\\n\" , alloc_trace_space ( imem ) , client_name_string ( cname ) , struct_type_name_string ( pstype ) , ( ulong ) num_elements * pstype -> ssize , num_elements , pstype -> ssize , ( ulong ) obj ) ;\n return ( char * ) obj ;\n }", "idx": 21131}
{"hash": -6872005221209485070, "project": "chrome", "size": 144, "label": 0, "functionSource": "decNumber * decLnOp ( decNumber * res , const decNumber * rhs , decContext * set , uInt * status ) {\n uInt ignore = 0 ;\n uInt needbytes ;\n Int residue ;\n Int r ;\n Int p ;\n Int pp ;\n Int t ;\n decNumber bufa [ D2N ( DECBUFFER + 12 ) ] ;\n decNumber * allocbufa = NULL ;\n decNumber * a = bufa ;\n decNumber bufb [ D2N ( DECBUFFER * 2 + 2 ) ] ;\n decNumber * allocbufb = NULL ;\n decNumber * b = bufb ;\n decNumber numone ;\n decNumber cmp ;\n decContext aset , bset ;\n # if DECCHECK Int iterations = 0 ;\n if ( decCheckOperands ( res , DECUNUSED , rhs , set ) ) return res ;\n # endif do {\n if ( SPECIALARG ) {\n if ( decNumberIsInfinite ( rhs ) ) {\n if ( decNumberIsNegative ( rhs ) ) * status |= DEC_Invalid_operation ;\n else uprv_decNumberCopy ( res , rhs ) ;\n }\n else decNaNs ( res , rhs , NULL , set , status ) ;\n break ;\n }\n if ( ISZERO ( rhs ) ) {\n uprv_decNumberZero ( res ) ;\n res -> bits = DECINF | DECNEG ;\n break ;\n }\n if ( decNumberIsNegative ( rhs ) ) {\n * status |= DEC_Invalid_operation ;\n break ;\n }\n if ( rhs -> exponent == 0 && set -> digits <= 40 ) {\n # if DECDPUN == 1 if ( rhs -> lsu [ 0 ] == 0 && rhs -> lsu [ 1 ] == 1 && rhs -> digits == 2 ) {\n # else if ( rhs -> lsu [ 0 ] == 10 && rhs -> digits == 2 ) {\n # endif aset = * set ;\n aset . round = DEC_ROUND_HALF_EVEN ;\n # define LN10 \"2.302585092994045684017991454684364207601\" uprv_decNumberFromString ( res , LN10 , & aset ) ;\n * status |= ( DEC_Inexact | DEC_Rounded ) ;\n break ;\n }\n if ( rhs -> lsu [ 0 ] == 2 && rhs -> digits == 1 ) {\n aset = * set ;\n aset . round = DEC_ROUND_HALF_EVEN ;\n # define LN2 \"0.6931471805599453094172321214581765680755\" uprv_decNumberFromString ( res , LN2 , & aset ) ;\n * status |= ( DEC_Inexact | DEC_Rounded ) ;\n break ;\n }\n }\n p = MAXI ( rhs -> digits , MAXI ( set -> digits , 7 ) ) + 2 ;\n needbytes = sizeof ( decNumber ) + ( D2U ( MAXI ( p , 16 ) ) - 1 ) * sizeof ( Unit ) ;\n if ( needbytes > sizeof ( bufa ) ) {\n allocbufa = ( decNumber * ) malloc ( needbytes ) ;\n if ( allocbufa == NULL ) {\n * status |= DEC_Insufficient_storage ;\n break ;\n }\n a = allocbufa ;\n }\n pp = p + rhs -> digits ;\n needbytes = sizeof ( decNumber ) + ( D2U ( MAXI ( pp , 16 ) ) - 1 ) * sizeof ( Unit ) ;\n if ( needbytes > sizeof ( bufb ) ) {\n allocbufb = ( decNumber * ) malloc ( needbytes ) ;\n if ( allocbufb == NULL ) {\n * status |= DEC_Insufficient_storage ;\n break ;\n }\n b = allocbufb ;\n }\n uprv_decContextDefault ( & aset , DEC_INIT_DECIMAL64 ) ;\n r = rhs -> exponent + rhs -> digits ;\n uprv_decNumberFromInt32 ( a , r ) ;\n uprv_decNumberFromInt32 ( b , 2302585 ) ;\n b -> exponent = - 6 ;\n decMultiplyOp ( a , a , b , & aset , & ignore ) ;\n residue = 0 ;\n aset . digits = 2 ;\n aset . round = DEC_ROUND_DOWN ;\n decCopyFit ( b , rhs , & aset , & residue , & ignore ) ;\n b -> exponent = 0 ;\n t = decGetInt ( b ) ;\n if ( t < 10 ) t = X10 ( t ) ;\n t = LNnn [ t - 10 ] ;\n uprv_decNumberFromInt32 ( b , t >> 2 ) ;\n b -> exponent = - ( t & 3 ) - 3 ;\n b -> bits = DECNEG ;\n aset . digits = 16 ;\n aset . round = DEC_ROUND_HALF_EVEN ;\n decAddOp ( a , a , b , & aset , 0 , & ignore ) ;\n uprv_decNumberZero ( & numone ) ;\n * numone . lsu = 1 ;\n aset . emax = set -> emax ;\n aset . emin = set -> emin ;\n aset . clamp = 0 ;\n bset = aset ;\n bset . emax = DEC_MAX_MATH * 2 ;\n bset . emin = - DEC_MAX_MATH * 2 ;\n pp = 9 ;\n aset . digits = pp ;\n bset . digits = pp + rhs -> digits ;\n for ( ;\n ;\n ) {\n # if DECCHECK iterations ++ ;\n if ( iterations > 24 ) break ;\n # endif a -> bits ^= DECNEG ;\n decExpOp ( b , a , & bset , & ignore ) ;\n a -> bits ^= DECNEG ;\n decMultiplyOp ( b , b , rhs , & bset , & ignore ) ;\n decAddOp ( b , b , & numone , & bset , DECNEG , & ignore ) ;\n if ( decNumberIsZero ( b ) || ( a -> digits + a -> exponent ) >= ( b -> digits + b -> exponent + set -> digits + 1 ) ) {\n if ( a -> digits == p ) break ;\n if ( decNumberIsZero ( a ) ) {\n decCompareOp ( & cmp , rhs , & numone , & aset , COMPARE , & ignore ) ;\n if ( cmp . lsu [ 0 ] == 0 ) a -> exponent = 0 ;\n else * status |= ( DEC_Inexact | DEC_Rounded ) ;\n break ;\n }\n if ( decNumberIsZero ( b ) ) b -> exponent = a -> exponent - p ;\n }\n decAddOp ( a , a , b , & aset , 0 , & ignore ) ;\n if ( pp == p ) continue ;\n pp = pp * 2 ;\n if ( pp > p ) pp = p ;\n aset . digits = pp ;\n bset . digits = pp + rhs -> digits ;\n }\n # if DECCHECK if ( iterations > 24 ) printf ( \"Ln iterations=%ld, status=%08lx, p=%ld, d=%ld\\n\" , ( LI ) iterations , ( LI ) * status , ( LI ) p , ( LI ) rhs -> digits ) ;\n # endif residue = 1 ;\n if ( ISZERO ( a ) ) residue = 0 ;\n aset . digits = set -> digits ;\n decCopyFit ( res , a , & aset , & residue , status ) ;\n decFinish ( res , set , & residue , status ) ;\n }\n while ( 0 ) ;\n if ( allocbufa != NULL ) free ( allocbufa ) ;\n if ( allocbufb != NULL ) free ( allocbufb ) ;\n return res ;\n }", "idx": 21132}
{"hash": -6105298668491046960, "project": "debian", "size": 74, "label": 0, "functionSource": "static int msmpeg4v12_decode_mb ( MpegEncContext * s , int16_t block [ 6 ] [ 64 ] ) {\n int cbp , code , i ;\n if ( s -> pict_type == AV_PICTURE_TYPE_P ) {\n if ( s -> use_skip_mb_code ) {\n if ( get_bits1 ( & s -> gb ) ) {\n s -> mb_intra = 0 ;\n for ( i = 0 ;\n i < 6 ;\n i ++ ) s -> block_last_index [ i ] = - 1 ;\n s -> mv_dir = MV_DIR_FORWARD ;\n s -> mv_type = MV_TYPE_16X16 ;\n s -> mv [ 0 ] [ 0 ] [ 0 ] = 0 ;\n s -> mv [ 0 ] [ 0 ] [ 1 ] = 0 ;\n s -> mb_skipped = 1 ;\n return 0 ;\n }\n }\n if ( s -> msmpeg4_version == 2 ) code = get_vlc2 ( & s -> gb , v2_mb_type_vlc . table , V2_MB_TYPE_VLC_BITS , 1 ) ;\n else code = get_vlc2 ( & s -> gb , ff_h263_inter_MCBPC_vlc . table , INTER_MCBPC_VLC_BITS , 2 ) ;\n if ( code < 0 || code > 7 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"cbpc %d invalid at %d %d\\n\" , code , s -> mb_x , s -> mb_y ) ;\n return - 1 ;\n }\n s -> mb_intra = code >> 2 ;\n cbp = code & 0x3 ;\n }\n else {\n s -> mb_intra = 1 ;\n if ( s -> msmpeg4_version == 2 ) cbp = get_vlc2 ( & s -> gb , v2_intra_cbpc_vlc . table , V2_INTRA_CBPC_VLC_BITS , 1 ) ;\n else cbp = get_vlc2 ( & s -> gb , ff_h263_intra_MCBPC_vlc . table , INTRA_MCBPC_VLC_BITS , 1 ) ;\n if ( cbp < 0 || cbp > 3 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"cbpc %d invalid at %d %d\\n\" , cbp , s -> mb_x , s -> mb_y ) ;\n return - 1 ;\n }\n }\n if ( ! s -> mb_intra ) {\n int mx , my , cbpy ;\n cbpy = get_vlc2 ( & s -> gb , ff_h263_cbpy_vlc . table , CBPY_VLC_BITS , 1 ) ;\n if ( cbpy < 0 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"cbpy %d invalid at %d %d\\n\" , cbp , s -> mb_x , s -> mb_y ) ;\n return - 1 ;\n }\n cbp |= cbpy << 2 ;\n if ( s -> msmpeg4_version == 1 || ( cbp & 3 ) != 3 ) cbp ^= 0x3C ;\n ff_h263_pred_motion ( s , 0 , 0 , & mx , & my ) ;\n mx = msmpeg4v2_decode_motion ( s , mx , 1 ) ;\n my = msmpeg4v2_decode_motion ( s , my , 1 ) ;\n s -> mv_dir = MV_DIR_FORWARD ;\n s -> mv_type = MV_TYPE_16X16 ;\n s -> mv [ 0 ] [ 0 ] [ 0 ] = mx ;\n s -> mv [ 0 ] [ 0 ] [ 1 ] = my ;\n }\n else {\n if ( s -> msmpeg4_version == 2 ) {\n s -> ac_pred = get_bits1 ( & s -> gb ) ;\n cbp |= get_vlc2 ( & s -> gb , ff_h263_cbpy_vlc . table , CBPY_VLC_BITS , 1 ) << 2 ;\n }\n else {\n s -> ac_pred = 0 ;\n cbp |= get_vlc2 ( & s -> gb , ff_h263_cbpy_vlc . table , CBPY_VLC_BITS , 1 ) << 2 ;\n if ( s -> pict_type == AV_PICTURE_TYPE_P ) cbp ^= 0x3C ;\n }\n }\n s -> dsp . clear_blocks ( s -> block [ 0 ] ) ;\n for ( i = 0 ;\n i < 6 ;\n i ++ ) {\n if ( ff_msmpeg4_decode_block ( s , block [ i ] , i , ( cbp >> ( 5 - i ) ) & 1 , NULL ) < 0 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"\\nerror while decoding block: %d x %d (%d)\\n\" , s -> mb_x , s -> mb_y , i ) ;\n return - 1 ;\n }\n }\n return 0 ;\n }", "idx": 21133}
{"hash": 3761858035663259067, "project": "chrome", "size": 5, "label": 0, "functionSource": "static UBool action_reverse ( UBiDiTransform * pTransform , UErrorCode * pErrorCode ) {\n ubidi_writeReverse ( pTransform -> src , pTransform -> srcLength , pTransform -> dest , pTransform -> destSize , UBIDI_REORDER_DEFAULT , pErrorCode ) ;\n * pTransform -> pDestLength = pTransform -> srcLength ;\n return TRUE ;\n }", "idx": 21134}
{"hash": 5357882892791796049, "project": "debian", "size": 6, "label": 0, "functionSource": "static void e1000e_intrmgr_on_timer ( void * opaque ) {\n E1000IntrDelayTimer * timer = opaque ;\n trace_e1000e_irq_throttling_timer ( timer -> delay_reg << 2 ) ;\n timer -> running = false ;\n e1000e_intrmgr_fire_delayed_interrupts ( timer -> core ) ;\n }", "idx": 21135}
{"hash": 5366785327268799421, "project": "chrome", "size": 3, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( MimeHandlerViewTest , Iframe ) {\n RunTest ( \"test_iframe.html\" ) ;\n }", "idx": 21136}
{"hash": 2895622461494525400, "project": "debian", "size": 44, "label": 0, "functionSource": "static void test_bug12243 ( ) {\n MYSQL_STMT * stmt1 , * stmt2 ;\n int rc ;\n const char * stmt_text ;\n ulong type ;\n myheader ( \"test_bug12243\" ) ;\n if ( ! have_innodb ) {\n if ( ! opt_silent ) printf ( \"This test requires InnoDB.\\n\" ) ;\n return ;\n }\n mysql_query ( mysql , \"drop table if exists t1\" ) ;\n mysql_query ( mysql , \"create table t1 (a int) engine=InnoDB\" ) ;\n rc = mysql_query ( mysql , \"insert into t1 (a) values (1), (2)\" ) ;\n myquery ( rc ) ;\n mysql_autocommit ( mysql , FALSE ) ;\n stmt1 = mysql_stmt_init ( mysql ) ;\n stmt2 = mysql_stmt_init ( mysql ) ;\n type = ( ulong ) CURSOR_TYPE_READ_ONLY ;\n mysql_stmt_attr_set ( stmt1 , STMT_ATTR_CURSOR_TYPE , ( const void * ) & type ) ;\n mysql_stmt_attr_set ( stmt2 , STMT_ATTR_CURSOR_TYPE , ( const void * ) & type ) ;\n stmt_text = \"select a from t1\" ;\n rc = mysql_stmt_prepare ( stmt1 , stmt_text , strlen ( stmt_text ) ) ;\n check_execute ( stmt1 , rc ) ;\n rc = mysql_stmt_execute ( stmt1 ) ;\n check_execute ( stmt1 , rc ) ;\n rc = mysql_stmt_fetch ( stmt1 ) ;\n check_execute ( stmt1 , rc ) ;\n rc = mysql_stmt_prepare ( stmt2 , stmt_text , strlen ( stmt_text ) ) ;\n check_execute ( stmt2 , rc ) ;\n rc = mysql_stmt_execute ( stmt2 ) ;\n check_execute ( stmt2 , rc ) ;\n rc = mysql_stmt_fetch ( stmt2 ) ;\n check_execute ( stmt2 , rc ) ;\n rc = mysql_stmt_close ( stmt1 ) ;\n check_execute ( stmt1 , rc ) ;\n rc = mysql_commit ( mysql ) ;\n myquery ( rc ) ;\n rc = mysql_stmt_fetch ( stmt2 ) ;\n check_execute ( stmt2 , rc ) ;\n mysql_stmt_close ( stmt2 ) ;\n rc = mysql_query ( mysql , \"drop table t1\" ) ;\n myquery ( rc ) ;\n mysql_autocommit ( mysql , TRUE ) ;\n }", "idx": 21137}
{"hash": -2338718868165006846, "project": "chrome", "size": 22, "label": 0, "functionSource": "int get_vp9_frame_buffer ( void * cb_priv , size_t min_size , vpx_codec_frame_buffer_t * fb ) {\n int i ;\n struct ExternalFrameBufferList * const ext_fb_list = ( struct ExternalFrameBufferList * ) cb_priv ;\n if ( ext_fb_list == NULL ) return - 1 ;\n for ( i = 0 ;\n i < ext_fb_list -> num_external_frame_buffers ;\n ++ i ) {\n if ( ! ext_fb_list -> ext_fb [ i ] . in_use ) break ;\n }\n if ( i == ext_fb_list -> num_external_frame_buffers ) return - 1 ;\n if ( ext_fb_list -> ext_fb [ i ] . size < min_size ) {\n free ( ext_fb_list -> ext_fb [ i ] . data ) ;\n ext_fb_list -> ext_fb [ i ] . data = ( uint8_t * ) calloc ( min_size , sizeof ( uint8_t ) ) ;\n if ( ! ext_fb_list -> ext_fb [ i ] . data ) return - 1 ;\n ext_fb_list -> ext_fb [ i ] . size = min_size ;\n }\n fb -> data = ext_fb_list -> ext_fb [ i ] . data ;\n fb -> size = ext_fb_list -> ext_fb [ i ] . size ;\n ext_fb_list -> ext_fb [ i ] . in_use = 1 ;\n fb -> priv = & ext_fb_list -> ext_fb [ i ] ;\n return 0 ;\n }", "idx": 21138}
{"hash": 4180964683905830761, "project": "debian", "size": 3, "label": 0, "functionSource": "static int selinux_netlink_send ( struct sock * sk , struct sk_buff * skb ) {\n return selinux_nlmsg_perm ( sk , skb ) ;\n }", "idx": 21139}
{"hash": -1487877838474751244, "project": "debian", "size": 9, "label": 0, "functionSource": "static int handleAppendResult ( int result , smart_str * loc_name TSRMLS_DC ) {\n intl_error_reset ( NULL TSRMLS_CC ) ;\n if ( result == FAILURE ) {\n intl_error_set ( NULL , U_ILLEGAL_ARGUMENT_ERROR , \"locale_compose: parameter array element is not a string\" , 0 TSRMLS_CC ) ;\n smart_str_free ( loc_name ) ;\n return 0 ;\n }\n return 1 ;\n }", "idx": 21140}
{"hash": 4976989049001279223, "project": "debian", "size": 5, "label": 0, "functionSource": "void http_hdr_method_set ( HdrHeap * heap , HTTPHdrImpl * hh , const char * method , int16_t method_wks_idx , int method_length , bool must_copy ) {\n ink_assert ( hh -> m_polarity == HTTP_TYPE_REQUEST ) ;\n hh -> u . req . m_method_wks_idx = method_wks_idx ;\n mime_str_u16_set ( heap , method , method_length , & ( hh -> u . req . m_ptr_method ) , & ( hh -> u . req . m_len_method ) , must_copy ) ;\n }", "idx": 21141}
{"hash": 2820551931453396101, "project": "debian", "size": 14, "label": 0, "functionSource": "void jas_image_destroy ( jas_image_t * image ) {\n int i ;\n if ( image -> cmpts_ ) {\n for ( i = 0 ;\n i < image -> numcmpts_ ;\n ++ i ) {\n jas_image_cmpt_destroy ( image -> cmpts_ [ i ] ) ;\n image -> cmpts_ [ i ] = 0 ;\n }\n jas_free ( image -> cmpts_ ) ;\n }\n if ( image -> cmprof_ ) jas_cmprof_destroy ( image -> cmprof_ ) ;\n jas_free ( image ) ;\n }", "idx": 21142}
{"hash": 6675626110148442062, "project": "debian", "size": 29, "label": 0, "functionSource": "static void jas_stream_initbuf ( jas_stream_t * stream , int bufmode , char * buf , int bufsize ) {\n assert ( ! stream -> bufbase_ ) ;\n if ( bufmode != JAS_STREAM_UNBUF ) {\n if ( ! buf ) {\n if ( ( stream -> bufbase_ = jas_malloc ( JAS_STREAM_BUFSIZE + JAS_STREAM_MAXPUTBACK ) ) ) {\n stream -> bufmode_ |= JAS_STREAM_FREEBUF ;\n stream -> bufsize_ = JAS_STREAM_BUFSIZE ;\n }\n else {\n stream -> bufbase_ = stream -> tinybuf_ ;\n stream -> bufsize_ = 1 ;\n }\n }\n else {\n assert ( bufsize > JAS_STREAM_MAXPUTBACK ) ;\n stream -> bufbase_ = JAS_CAST ( uchar * , buf ) ;\n stream -> bufsize_ = bufsize - JAS_STREAM_MAXPUTBACK ;\n }\n }\n else {\n assert ( ! buf ) ;\n stream -> bufbase_ = stream -> tinybuf_ ;\n stream -> bufsize_ = 1 ;\n }\n stream -> bufstart_ = & stream -> bufbase_ [ JAS_STREAM_MAXPUTBACK ] ;\n stream -> ptr_ = stream -> bufstart_ ;\n stream -> cnt_ = 0 ;\n stream -> bufmode_ |= bufmode & JAS_STREAM_BUFMODEMASK ;\n }", "idx": 21143}
{"hash": 1760449185745615462, "project": "debian", "size": 4, "label": 0, "functionSource": "void * TSFetchUserDataGet ( TSFetchSM fetch_sm ) {\n sdk_assert ( sdk_sanity_check_fetch_sm ( fetch_sm ) == TS_SUCCESS ) ;\n return ( ( FetchSM * ) fetch_sm ) -> ext_get_user_data ( ) ;\n }", "idx": 21144}
{"hash": -7855974557509681261, "project": "debian", "size": 21, "label": 0, "functionSource": "Oid get_base_element_type ( Oid typid ) {\n for ( ;\n ;\n ) {\n HeapTuple tup ;\n Form_pg_type typTup ;\n tup = SearchSysCache1 ( TYPEOID , ObjectIdGetDatum ( typid ) ) ;\n if ( ! HeapTupleIsValid ( tup ) ) break ;\n typTup = ( Form_pg_type ) GETSTRUCT ( tup ) ;\n if ( typTup -> typtype != TYPTYPE_DOMAIN ) {\n Oid result ;\n if ( typTup -> typlen == - 1 ) result = typTup -> typelem ;\n else result = InvalidOid ;\n ReleaseSysCache ( tup ) ;\n return result ;\n }\n typid = typTup -> typbasetype ;\n ReleaseSysCache ( tup ) ;\n }\n return InvalidOid ;\n }", "idx": 21145}
{"hash": -6024601983167898950, "project": "debian", "size": 217, "label": 0, "functionSource": "static void activate_files ( ActivateParameters * parameters ) {\n NautilusFile * file ;\n NautilusWindow * window ;\n NautilusWindowOpenFlags flags ;\n g_autoptr ( GList ) open_in_app_parameters = NULL ;\n g_autoptr ( GList ) unhandled_open_in_app_uris = NULL ;\n ApplicationLaunchParameters * one_parameters ;\n int count ;\n g_autofree char * old_working_dir = NULL ;\n GdkScreen * screen ;\n gint num_apps ;\n gint num_unhandled ;\n gint num_files ;\n gboolean open_files ;\n gboolean closed_window ;\n g_autoptr ( GQueue ) launch_desktop_files = NULL ;\n g_autoptr ( GQueue ) launch_files = NULL ;\n g_autoptr ( GQueue ) launch_in_terminal_files = NULL ;\n g_autoptr ( GQueue ) open_in_app_uris = NULL ;\n g_autoptr ( GQueue ) open_in_view_files = NULL ;\n GList * l ;\n ActivationAction action ;\n LaunchLocation * location ;\n launch_desktop_files = g_queue_new ( ) ;\n launch_files = g_queue_new ( ) ;\n launch_in_terminal_files = g_queue_new ( ) ;\n open_in_view_files = g_queue_new ( ) ;\n open_in_app_uris = g_queue_new ( ) ;\n for ( l = parameters -> locations ;\n l != NULL ;\n l = l -> next ) {\n location = l -> data ;\n file = location -> file ;\n if ( file_was_cancelled ( file ) ) {\n continue ;\n }\n action = get_activation_action ( file ) ;\n if ( action == ACTIVATION_ACTION_ASK ) {\n pause_activation_timed_cancel ( parameters ) ;\n action = get_executable_text_file_action ( parameters -> parent_window , file ) ;\n unpause_activation_timed_cancel ( parameters ) ;\n }\n switch ( action ) {\n case ACTIVATION_ACTION_LAUNCH_DESKTOP_FILE : {\n g_queue_push_tail ( launch_desktop_files , file ) ;\n }\n break ;\n case ACTIVATION_ACTION_LAUNCH : {\n g_queue_push_tail ( launch_files , file ) ;\n }\n break ;\n case ACTIVATION_ACTION_LAUNCH_IN_TERMINAL : {\n g_queue_push_tail ( launch_in_terminal_files , file ) ;\n }\n break ;\n case ACTIVATION_ACTION_OPEN_IN_VIEW : {\n g_queue_push_tail ( open_in_view_files , file ) ;\n }\n break ;\n case ACTIVATION_ACTION_OPEN_IN_APPLICATION : {\n g_queue_push_tail ( open_in_app_uris , location -> uri ) ;\n }\n break ;\n case ACTIVATION_ACTION_DO_NOTHING : {\n }\n break ;\n case ACTIVATION_ACTION_EXTRACT : {\n g_assert_not_reached ( ) ;\n }\n break ;\n case ACTIVATION_ACTION_ASK : {\n g_assert_not_reached ( ) ;\n }\n break ;\n }\n }\n for ( l = g_queue_peek_head_link ( launch_desktop_files ) ;\n l != NULL ;\n l = l -> next ) {\n file = NAUTILUS_FILE ( l -> data ) ;\n activate_desktop_file ( parameters , file ) ;\n }\n if ( parameters -> activation_directory && ( ! g_queue_is_empty ( launch_files ) || ! g_queue_is_empty ( launch_in_terminal_files ) ) ) {\n old_working_dir = g_get_current_dir ( ) ;\n g_chdir ( parameters -> activation_directory ) ;\n }\n screen = gtk_widget_get_screen ( GTK_WIDGET ( parameters -> parent_window ) ) ;\n for ( l = g_queue_peek_head_link ( launch_files ) ;\n l != NULL ;\n l = l -> next ) {\n g_autofree char * uri = NULL ;\n g_autofree char * executable_path = NULL ;\n g_autofree char * quoted_path = NULL ;\n file = NAUTILUS_FILE ( l -> data ) ;\n uri = nautilus_file_get_activation_uri ( file ) ;\n executable_path = g_filename_from_uri ( uri , NULL , NULL ) ;\n quoted_path = g_shell_quote ( executable_path ) ;\n DEBUG ( \"Launching file path %s\" , quoted_path ) ;\n nautilus_launch_application_from_command ( screen , quoted_path , FALSE , NULL ) ;\n }\n for ( l = g_queue_peek_head_link ( launch_in_terminal_files ) ;\n l != NULL ;\n l = l -> next ) {\n g_autofree char * uri = NULL ;\n g_autofree char * executable_path = NULL ;\n g_autofree char * quoted_path = NULL ;\n file = NAUTILUS_FILE ( l -> data ) ;\n uri = nautilus_file_get_activation_uri ( file ) ;\n executable_path = g_filename_from_uri ( uri , NULL , NULL ) ;\n quoted_path = g_shell_quote ( executable_path ) ;\n DEBUG ( \"Launching in terminal file quoted path %s\" , quoted_path ) ;\n nautilus_launch_application_from_command ( screen , quoted_path , TRUE , NULL ) ;\n }\n if ( old_working_dir != NULL ) {\n g_chdir ( old_working_dir ) ;\n }\n count = g_queue_get_length ( open_in_view_files ) ;\n flags = parameters -> flags ;\n if ( count > 1 ) {\n if ( ( parameters -> flags & NAUTILUS_WINDOW_OPEN_FLAG_NEW_WINDOW ) == 0 ) {\n if ( ( parameters -> flags & NAUTILUS_WINDOW_OPEN_FLAG_CLOSE_BEHIND ) != 0 ) {\n flags |= NAUTILUS_WINDOW_OPEN_FLAG_NEW_WINDOW ;\n }\n else {\n flags |= NAUTILUS_WINDOW_OPEN_FLAG_NEW_TAB ;\n }\n }\n else {\n flags |= NAUTILUS_WINDOW_OPEN_FLAG_NEW_WINDOW ;\n }\n }\n else {\n if ( ( parameters -> flags & NAUTILUS_WINDOW_OPEN_FLAG_CLOSE_BEHIND ) != 0 ) {\n flags |= NAUTILUS_WINDOW_OPEN_FLAG_NEW_WINDOW ;\n }\n }\n if ( parameters -> slot != NULL && ( ! parameters -> user_confirmation || confirm_multiple_windows ( parameters -> parent_window , count , ( flags & NAUTILUS_WINDOW_OPEN_FLAG_NEW_TAB ) != 0 ) ) ) {\n if ( ( flags & NAUTILUS_WINDOW_OPEN_FLAG_NEW_TAB ) != 0 && g_settings_get_enum ( nautilus_preferences , NAUTILUS_PREFERENCES_NEW_TAB_POSITION ) == NAUTILUS_NEW_TAB_POSITION_AFTER_CURRENT_TAB ) {\n g_queue_reverse ( open_in_view_files ) ;\n }\n closed_window = FALSE ;\n for ( l = g_queue_peek_head_link ( open_in_view_files ) ;\n l != NULL ;\n l = l -> next ) {\n g_autofree char * uri = NULL ;\n g_autoptr ( GFile ) location = NULL ;\n g_autoptr ( GFile ) location_with_permissions = NULL ;\n file = NAUTILUS_FILE ( l -> data ) ;\n uri = nautilus_file_get_activation_uri ( file ) ;\n location = g_file_new_for_uri ( uri ) ;\n if ( g_file_is_native ( location ) && ( nautilus_file_is_in_admin ( file ) || ! nautilus_file_can_read ( file ) || ! nautilus_file_can_execute ( file ) ) ) {\n g_autofree gchar * file_path = NULL ;\n g_free ( uri ) ;\n file_path = g_file_get_path ( location ) ;\n uri = g_strconcat ( \"admin://\" , file_path , NULL ) ;\n }\n location_with_permissions = g_file_new_for_uri ( uri ) ;\n nautilus_application_open_location_full ( NAUTILUS_APPLICATION ( g_application_get_default ( ) ) , location_with_permissions , flags , NULL , NULL , parameters -> slot ) ;\n if ( ! closed_window && ( flags & NAUTILUS_WINDOW_OPEN_FLAG_CLOSE_BEHIND ) != 0 ) {\n flags &= ( ~ NAUTILUS_WINDOW_OPEN_FLAG_CLOSE_BEHIND ) ;\n if ( ( parameters -> flags & NAUTILUS_WINDOW_OPEN_FLAG_NEW_WINDOW ) == 0 ) {\n flags &= ( ~ NAUTILUS_WINDOW_OPEN_FLAG_NEW_WINDOW ) ;\n flags |= NAUTILUS_WINDOW_OPEN_FLAG_NEW_TAB ;\n }\n closed_window = TRUE ;\n }\n }\n }\n if ( open_in_app_uris != NULL ) {\n open_in_app_parameters = make_activation_parameters ( g_queue_peek_head_link ( open_in_app_uris ) , & unhandled_open_in_app_uris ) ;\n }\n num_apps = g_list_length ( open_in_app_parameters ) ;\n num_unhandled = g_list_length ( unhandled_open_in_app_uris ) ;\n num_files = g_queue_get_length ( open_in_app_uris ) ;\n open_files = TRUE ;\n if ( g_queue_is_empty ( open_in_app_uris ) && ( ! parameters -> user_confirmation || num_files + num_unhandled > SILENT_OPEN_LIMIT ) && num_apps > 1 ) {\n GtkDialog * dialog ;\n char * prompt ;\n g_autofree char * detail = NULL ;\n int response ;\n pause_activation_timed_cancel ( parameters ) ;\n prompt = _ ( \"Are you sure you want to open all files?\" ) ;\n detail = g_strdup_printf ( ngettext ( \"This will open %d separate application.\" , \"This will open %d separate applications.\" , num_apps ) , num_apps ) ;\n dialog = eel_show_yes_no_dialog ( prompt , detail , _ ( \"_OK\" ) , _ ( \"_Cancel\" ) , parameters -> parent_window ) ;\n response = gtk_dialog_run ( dialog ) ;\n gtk_widget_destroy ( GTK_WIDGET ( dialog ) ) ;\n unpause_activation_timed_cancel ( parameters ) ;\n if ( response != GTK_RESPONSE_YES ) {\n open_files = FALSE ;\n }\n }\n if ( open_files ) {\n for ( l = open_in_app_parameters ;\n l != NULL ;\n l = l -> next ) {\n one_parameters = l -> data ;\n nautilus_launch_application_by_uri ( one_parameters -> application , one_parameters -> uris , parameters -> parent_window ) ;\n application_launch_parameters_free ( one_parameters ) ;\n }\n for ( l = unhandled_open_in_app_uris ;\n l != NULL ;\n l = l -> next ) {\n char * uri = l -> data ;\n application_unhandled_uri ( parameters , uri ) ;\n }\n }\n window = NULL ;\n if ( parameters -> slot != NULL ) {\n window = nautilus_window_slot_get_window ( parameters -> slot ) ;\n }\n if ( open_in_app_parameters != NULL || unhandled_open_in_app_uris != NULL ) {\n if ( ( parameters -> flags & NAUTILUS_WINDOW_OPEN_FLAG_CLOSE_BEHIND ) != 0 && window != NULL ) {\n nautilus_window_close ( window ) ;\n }\n }\n activation_parameters_free ( parameters ) ;\n }", "idx": 21146}
{"hash": -7283224897680777091, "project": "chrome", "size": 14, "label": 0, "functionSource": "void vp9_loop_filter_frame ( YV12_BUFFER_CONFIG * frame , VP9_COMMON * cm , MACROBLOCKD * xd , int frame_filter_level , int y_only , int partial_frame ) {\n int start_mi_row , end_mi_row , mi_rows_to_filter ;\n if ( ! frame_filter_level ) return ;\n start_mi_row = 0 ;\n mi_rows_to_filter = cm -> mi_rows ;\n if ( partial_frame && cm -> mi_rows > 8 ) {\n start_mi_row = cm -> mi_rows >> 1 ;\n start_mi_row &= 0xfffffff8 ;\n mi_rows_to_filter = MAX ( cm -> mi_rows / 8 , 8 ) ;\n }\n end_mi_row = start_mi_row + mi_rows_to_filter ;\n vp9_loop_filter_frame_init ( cm , frame_filter_level ) ;\n vp9_loop_filter_rows ( frame , cm , xd -> plane , start_mi_row , end_mi_row , y_only ) ;\n }", "idx": 21147}
{"hash": 6323824267898511453, "project": "debian", "size": 6, "label": 0, "functionSource": "static void clamp_default ( const fz_colorspace * cs , const float * src , float * dst ) {\n int i ;\n for ( i = 0 ;\n i < cs -> n ;\n i ++ ) dst [ i ] = fz_clamp ( src [ i ] , 0 , 1 ) ;\n }", "idx": 21148}
{"hash": 5357882892791796049, "project": "debian", "size": 15, "label": 0, "functionSource": "static void e1000e_set_ims ( E1000ECore * core , int index , uint32_t val ) {\n static const uint32_t ims_ext_mask = E1000_IMS_RXQ0 | E1000_IMS_RXQ1 | E1000_IMS_TXQ0 | E1000_IMS_TXQ1 | E1000_IMS_OTHER ;\n static const uint32_t ims_valid_mask = E1000_IMS_TXDW | E1000_IMS_TXQE | E1000_IMS_LSC | E1000_IMS_RXDMT0 | E1000_IMS_RXO | E1000_IMS_RXT0 | E1000_IMS_MDAC | E1000_IMS_TXD_LOW | E1000_IMS_SRPD | E1000_IMS_ACK | E1000_IMS_MNG | E1000_IMS_RXQ0 | E1000_IMS_RXQ1 | E1000_IMS_TXQ0 | E1000_IMS_TXQ1 | E1000_IMS_OTHER ;\n uint32_t valid_val = val & ims_valid_mask ;\n trace_e1000e_irq_set_ims ( val , core -> mac [ IMS ] , core -> mac [ IMS ] | valid_val ) ;\n core -> mac [ IMS ] |= valid_val ;\n if ( ( valid_val & ims_ext_mask ) && ( core -> mac [ CTRL_EXT ] & E1000_CTRL_EXT_PBA_CLR ) && msix_enabled ( core -> owner ) ) {\n e1000e_msix_clear ( core , valid_val ) ;\n }\n if ( ( valid_val == ims_valid_mask ) && ( core -> mac [ CTRL_EXT ] & E1000_CTRL_EXT_INT_TIMERS_CLEAR_ENA ) ) {\n trace_e1000e_irq_fire_all_timers ( val ) ;\n e1000e_intrmgr_fire_all_timers ( core ) ;\n }\n e1000e_update_interrupt_state ( core ) ;\n }", "idx": 21149}
{"hash": 3192165150896245305, "project": "debian", "size": 73, "label": 1, "functionSource": "void bn_sqr_comba8 ( BN_ULONG * r , const BN_ULONG * a ) {\n BN_ULONG t1 , t2 ;\n BN_ULONG c1 , c2 , c3 ;\n c1 = 0 ;\n c2 = 0 ;\n c3 = 0 ;\n sqr_add_c ( a , 0 , c1 , c2 , c3 ) ;\n r [ 0 ] = c1 ;\n c1 = 0 ;\n sqr_add_c2 ( a , 1 , 0 , c2 , c3 , c1 ) ;\n r [ 1 ] = c2 ;\n c2 = 0 ;\n sqr_add_c ( a , 1 , c3 , c1 , c2 ) ;\n sqr_add_c2 ( a , 2 , 0 , c3 , c1 , c2 ) ;\n r [ 2 ] = c3 ;\n c3 = 0 ;\n sqr_add_c2 ( a , 3 , 0 , c1 , c2 , c3 ) ;\n sqr_add_c2 ( a , 2 , 1 , c1 , c2 , c3 ) ;\n r [ 3 ] = c1 ;\n c1 = 0 ;\n sqr_add_c ( a , 2 , c2 , c3 , c1 ) ;\n sqr_add_c2 ( a , 3 , 1 , c2 , c3 , c1 ) ;\n sqr_add_c2 ( a , 4 , 0 , c2 , c3 , c1 ) ;\n r [ 4 ] = c2 ;\n c2 = 0 ;\n sqr_add_c2 ( a , 5 , 0 , c3 , c1 , c2 ) ;\n sqr_add_c2 ( a , 4 , 1 , c3 , c1 , c2 ) ;\n sqr_add_c2 ( a , 3 , 2 , c3 , c1 , c2 ) ;\n r [ 5 ] = c3 ;\n c3 = 0 ;\n sqr_add_c ( a , 3 , c1 , c2 , c3 ) ;\n sqr_add_c2 ( a , 4 , 2 , c1 , c2 , c3 ) ;\n sqr_add_c2 ( a , 5 , 1 , c1 , c2 , c3 ) ;\n sqr_add_c2 ( a , 6 , 0 , c1 , c2 , c3 ) ;\n r [ 6 ] = c1 ;\n c1 = 0 ;\n sqr_add_c2 ( a , 7 , 0 , c2 , c3 , c1 ) ;\n sqr_add_c2 ( a , 6 , 1 , c2 , c3 , c1 ) ;\n sqr_add_c2 ( a , 5 , 2 , c2 , c3 , c1 ) ;\n sqr_add_c2 ( a , 4 , 3 , c2 , c3 , c1 ) ;\n r [ 7 ] = c2 ;\n c2 = 0 ;\n sqr_add_c ( a , 4 , c3 , c1 , c2 ) ;\n sqr_add_c2 ( a , 5 , 3 , c3 , c1 , c2 ) ;\n sqr_add_c2 ( a , 6 , 2 , c3 , c1 , c2 ) ;\n sqr_add_c2 ( a , 7 , 1 , c3 , c1 , c2 ) ;\n r [ 8 ] = c3 ;\n c3 = 0 ;\n sqr_add_c2 ( a , 7 , 2 , c1 , c2 , c3 ) ;\n sqr_add_c2 ( a , 6 , 3 , c1 , c2 , c3 ) ;\n sqr_add_c2 ( a , 5 , 4 , c1 , c2 , c3 ) ;\n r [ 9 ] = c1 ;\n c1 = 0 ;\n sqr_add_c ( a , 5 , c2 , c3 , c1 ) ;\n sqr_add_c2 ( a , 6 , 4 , c2 , c3 , c1 ) ;\n sqr_add_c2 ( a , 7 , 3 , c2 , c3 , c1 ) ;\n r [ 10 ] = c2 ;\n c2 = 0 ;\n sqr_add_c2 ( a , 7 , 4 , c3 , c1 , c2 ) ;\n sqr_add_c2 ( a , 6 , 5 , c3 , c1 , c2 ) ;\n r [ 11 ] = c3 ;\n c3 = 0 ;\n sqr_add_c ( a , 6 , c1 , c2 , c3 ) ;\n sqr_add_c2 ( a , 7 , 5 , c1 , c2 , c3 ) ;\n r [ 12 ] = c1 ;\n c1 = 0 ;\n sqr_add_c2 ( a , 7 , 6 , c2 , c3 , c1 ) ;\n r [ 13 ] = c2 ;\n c2 = 0 ;\n sqr_add_c ( a , 7 , c3 , c1 , c2 ) ;\n r [ 14 ] = c3 ;\n r [ 15 ] = c1 ;\n }", "idx": 21150}
{"hash": -2325305888478261876, "project": "debian", "size": 20, "label": 0, "functionSource": "int tm_rescinfo ( tm_node_id node , char * resource , int len , tm_event_t * event ) {\n struct reschold * rhold ;\n struct tcp_chan * chan = NULL ;\n if ( ! init_done ) return TM_BADINIT ;\n if ( resource == NULL || len == 0 ) return TM_EBADENVIRONMENT ;\n * event = new_event ( ) ;\n if ( startcom ( TM_RESOURCES , * event , & chan ) != DIS_SUCCESS ) return TM_ESYSTEM ;\n if ( diswsi ( chan , node ) != DIS_SUCCESS ) {\n DIS_tcp_cleanup ( chan ) ;\n return TM_ESYSTEM ;\n }\n DIS_tcp_wflush ( chan ) ;\n DIS_tcp_cleanup ( chan ) ;\n rhold = ( struct reschold * ) calloc ( 1 , sizeof ( struct reschold ) ) ;\n assert ( rhold != NULL ) ;\n rhold -> resc = resource ;\n rhold -> len = len ;\n add_event ( * event , node , TM_RESOURCES , ( void * ) rhold ) ;\n return TM_SUCCESS ;\n }", "idx": 21151}
{"hash": 6415329349331062723, "project": "chrome", "size": 3, "label": 0, "functionSource": "static void terminate_readcb ( struct bufferevent * bev , void * arg ) {\n evbuffer_drain ( bev -> output , - 1 ) ;\n }", "idx": 21152}
{"hash": 6664609110189077049, "project": "debian", "size": 75, "label": 0, "functionSource": "static int decode_coeffs ( WMAProDecodeCtx * s , int c ) {\n static const uint32_t fval_tab [ 16 ] = {\n 0x00000000 , 0x3f800000 , 0x40000000 , 0x40400000 , 0x40800000 , 0x40a00000 , 0x40c00000 , 0x40e00000 , 0x41000000 , 0x41100000 , 0x41200000 , 0x41300000 , 0x41400000 , 0x41500000 , 0x41600000 , 0x41700000 , }\n ;\n int vlctable ;\n VLC * vlc ;\n WMAProChannelCtx * ci = & s -> channel [ c ] ;\n int rl_mode = 0 ;\n int cur_coeff = 0 ;\n int num_zeros = 0 ;\n const uint16_t * run ;\n const float * level ;\n av_dlog ( s -> avctx , \"decode coefficients for channel %i\\n\" , c ) ;\n vlctable = get_bits1 ( & s -> gb ) ;\n vlc = & coef_vlc [ vlctable ] ;\n if ( vlctable ) {\n run = coef1_run ;\n level = coef1_level ;\n }\n else {\n run = coef0_run ;\n level = coef0_level ;\n }\n while ( ( s -> transmit_num_vec_coeffs || ! rl_mode ) && ( cur_coeff + 3 < ci -> num_vec_coeffs ) ) {\n uint32_t vals [ 4 ] ;\n int i ;\n unsigned int idx ;\n idx = get_vlc2 ( & s -> gb , vec4_vlc . table , VLCBITS , VEC4MAXDEPTH ) ;\n if ( idx == HUFF_VEC4_SIZE - 1 ) {\n for ( i = 0 ;\n i < 4 ;\n i += 2 ) {\n idx = get_vlc2 ( & s -> gb , vec2_vlc . table , VLCBITS , VEC2MAXDEPTH ) ;\n if ( idx == HUFF_VEC2_SIZE - 1 ) {\n uint32_t v0 , v1 ;\n v0 = get_vlc2 ( & s -> gb , vec1_vlc . table , VLCBITS , VEC1MAXDEPTH ) ;\n if ( v0 == HUFF_VEC1_SIZE - 1 ) v0 += ff_wma_get_large_val ( & s -> gb ) ;\n v1 = get_vlc2 ( & s -> gb , vec1_vlc . table , VLCBITS , VEC1MAXDEPTH ) ;\n if ( v1 == HUFF_VEC1_SIZE - 1 ) v1 += ff_wma_get_large_val ( & s -> gb ) ;\n vals [ i ] = av_float2int ( v0 ) ;\n vals [ i + 1 ] = av_float2int ( v1 ) ;\n }\n else {\n vals [ i ] = fval_tab [ symbol_to_vec2 [ idx ] >> 4 ] ;\n vals [ i + 1 ] = fval_tab [ symbol_to_vec2 [ idx ] & 0xF ] ;\n }\n }\n }\n else {\n vals [ 0 ] = fval_tab [ symbol_to_vec4 [ idx ] >> 12 ] ;\n vals [ 1 ] = fval_tab [ ( symbol_to_vec4 [ idx ] >> 8 ) & 0xF ] ;\n vals [ 2 ] = fval_tab [ ( symbol_to_vec4 [ idx ] >> 4 ) & 0xF ] ;\n vals [ 3 ] = fval_tab [ symbol_to_vec4 [ idx ] & 0xF ] ;\n }\n for ( i = 0 ;\n i < 4 ;\n i ++ ) {\n if ( vals [ i ] ) {\n uint32_t sign = get_bits1 ( & s -> gb ) - 1 ;\n AV_WN32A ( & ci -> coeffs [ cur_coeff ] , vals [ i ] ^ sign << 31 ) ;\n num_zeros = 0 ;\n }\n else {\n ci -> coeffs [ cur_coeff ] = 0 ;\n rl_mode |= ( ++ num_zeros > s -> subframe_len >> 8 ) ;\n }\n ++ cur_coeff ;\n }\n }\n if ( cur_coeff < s -> subframe_len ) {\n memset ( & ci -> coeffs [ cur_coeff ] , 0 , sizeof ( * ci -> coeffs ) * ( s -> subframe_len - cur_coeff ) ) ;\n if ( ff_wma_run_level_decode ( s -> avctx , & s -> gb , vlc , level , run , 1 , ci -> coeffs , cur_coeff , s -> subframe_len , s -> subframe_len , s -> esc_len , 0 ) ) return AVERROR_INVALIDDATA ;\n }\n return 0 ;\n }", "idx": 21153}
{"hash": -9197960073880365676, "project": "debian", "size": 6, "label": 0, "functionSource": "static uint32_t file_block_getter ( uint8_t * p , uint32_t s , Gif_Reader * grr ) {\n size_t nread = fread ( p , 1 , s , grr -> f ) ;\n if ( nread < s ) memset ( p + nread , 0 , s - nread ) ;\n grr -> pos += nread ;\n return nread ;\n }", "idx": 21154}
{"hash": -5459605226342014540, "project": "debian", "size": 49, "label": 0, "functionSource": "static inline void tm2_motion_block ( TM2Context * ctx , AVFrame * pic , int bx , int by ) {\n int i , j ;\n int mx , my ;\n TM2_INIT_POINTERS_2 ( ) ;\n mx = GET_TOK ( ctx , TM2_MOT ) ;\n my = GET_TOK ( ctx , TM2_MOT ) ;\n mx = av_clip ( mx , - ( bx * 4 + 4 ) , ctx -> avctx -> width - bx * 4 ) ;\n my = av_clip ( my , - ( by * 4 + 4 ) , ctx -> avctx -> height - by * 4 ) ;\n Yo += my * oYstride + mx ;\n Uo += ( my >> 1 ) * oUstride + ( mx >> 1 ) ;\n Vo += ( my >> 1 ) * oVstride + ( mx >> 1 ) ;\n for ( j = 0 ;\n j < 2 ;\n j ++ ) {\n for ( i = 0 ;\n i < 2 ;\n i ++ ) {\n U [ i ] = Uo [ i ] ;\n V [ i ] = Vo [ i ] ;\n }\n U += Ustride ;\n V += Vstride ;\n Uo += oUstride ;\n Vo += oVstride ;\n }\n U -= Ustride * 2 ;\n V -= Vstride * 2 ;\n TM2_RECALC_BLOCK ( U , Ustride , clast , ctx -> CD ) ;\n TM2_RECALC_BLOCK ( V , Vstride , ( clast + 2 ) , ( ctx -> CD + 2 ) ) ;\n for ( j = 0 ;\n j < 4 ;\n j ++ ) {\n for ( i = 0 ;\n i < 4 ;\n i ++ ) {\n Y [ i ] = Yo [ i ] ;\n }\n Y += Ystride ;\n Yo += oYstride ;\n }\n Y -= Ystride * 4 ;\n ctx -> D [ 0 ] = Y [ 3 ] - last [ 3 ] ;\n ctx -> D [ 1 ] = Y [ 3 + Ystride ] - Y [ 3 ] ;\n ctx -> D [ 2 ] = Y [ 3 + Ystride * 2 ] - Y [ 3 + Ystride ] ;\n ctx -> D [ 3 ] = Y [ 3 + Ystride * 3 ] - Y [ 3 + Ystride * 2 ] ;\n for ( i = 0 ;\n i < 4 ;\n i ++ ) last [ i ] = Y [ i + Ystride * 3 ] ;\n }", "idx": 21155}
{"hash": 1458662858915721428, "project": "debian", "size": 67, "label": 0, "functionSource": "static void page_init ( void ) {\n # ifdef _WIN32 {\n SYSTEM_INFO system_info ;\n GetSystemInfo ( & system_info ) ;\n qemu_real_host_page_size = system_info . dwPageSize ;\n }\n # else qemu_real_host_page_size = getpagesize ( ) ;\n # endif if ( qemu_host_page_size == 0 ) {\n qemu_host_page_size = qemu_real_host_page_size ;\n }\n if ( qemu_host_page_size < TARGET_PAGE_SIZE ) {\n qemu_host_page_size = TARGET_PAGE_SIZE ;\n }\n qemu_host_page_mask = ~ ( qemu_host_page_size - 1 ) ;\n # if defined ( CONFIG_BSD ) && defined ( CONFIG_USER_ONLY ) {\n # ifdef HAVE_KINFO_GETVMMAP struct kinfo_vmentry * freep ;\n int i , cnt ;\n freep = kinfo_getvmmap ( getpid ( ) , & cnt ) ;\n if ( freep ) {\n mmap_lock ( ) ;\n for ( i = 0 ;\n i < cnt ;\n i ++ ) {\n unsigned long startaddr , endaddr ;\n startaddr = freep [ i ] . kve_start ;\n endaddr = freep [ i ] . kve_end ;\n if ( h2g_valid ( startaddr ) ) {\n startaddr = h2g ( startaddr ) & TARGET_PAGE_MASK ;\n if ( h2g_valid ( endaddr ) ) {\n endaddr = h2g ( endaddr ) ;\n page_set_flags ( startaddr , endaddr , PAGE_RESERVED ) ;\n }\n else {\n # if TARGET_ABI_BITS <= L1_MAP_ADDR_SPACE_BITS endaddr = ~ 0ul ;\n page_set_flags ( startaddr , endaddr , PAGE_RESERVED ) ;\n # endif }\n }\n }\n free ( freep ) ;\n mmap_unlock ( ) ;\n }\n # else FILE * f ;\n last_brk = ( unsigned long ) sbrk ( 0 ) ;\n f = fopen ( \"/compat/linux/proc/self/maps\" , \"r\" ) ;\n if ( f ) {\n mmap_lock ( ) ;\n do {\n unsigned long startaddr , endaddr ;\n int n ;\n n = fscanf ( f , \"%lx-%lx %*[^\\n]\\n\" , & startaddr , & endaddr ) ;\n if ( n == 2 && h2g_valid ( startaddr ) ) {\n startaddr = h2g ( startaddr ) & TARGET_PAGE_MASK ;\n if ( h2g_valid ( endaddr ) ) {\n endaddr = h2g ( endaddr ) ;\n }\n else {\n endaddr = ~ 0ul ;\n }\n page_set_flags ( startaddr , endaddr , PAGE_RESERVED ) ;\n }\n }\n while ( ! feof ( f ) ) ;\n fclose ( f ) ;\n mmap_unlock ( ) ;\n }\n # endif }\n # endif }", "idx": 21156}
{"hash": 1245821301839614810, "project": "debian", "size": 39, "label": 0, "functionSource": "static void move_task_thread_func ( GTask * task , gpointer source_object , gpointer task_data , GCancellable * cancellable ) {\n CopyMoveJob * job ;\n CommonJob * common ;\n GList * fallbacks ;\n SourceInfo source_info ;\n TransferInfo transfer_info ;\n char * dest_fs_id ;\n char * dest_fs_type ;\n GList * fallback_files ;\n job = task_data ;\n common = & job -> common ;\n dest_fs_id = NULL ;\n dest_fs_type = NULL ;\n fallbacks = NULL ;\n nautilus_progress_info_start ( job -> common . progress ) ;\n verify_destination ( & job -> common , job -> destination , & dest_fs_id , - 1 ) ;\n if ( job_aborted ( common ) ) {\n goto aborted ;\n }\n move_files_prepare ( job , dest_fs_id , & dest_fs_type , & fallbacks ) ;\n if ( job_aborted ( common ) ) {\n goto aborted ;\n }\n fallback_files = get_files_from_fallbacks ( fallbacks ) ;\n scan_sources ( fallback_files , & source_info , common , OP_KIND_MOVE ) ;\n g_list_free ( fallback_files ) ;\n if ( job_aborted ( common ) ) {\n goto aborted ;\n }\n verify_destination ( & job -> common , job -> destination , NULL , source_info . num_bytes ) ;\n if ( job_aborted ( common ) ) {\n goto aborted ;\n }\n memset ( & transfer_info , 0 , sizeof ( transfer_info ) ) ;\n move_files ( job , fallbacks , dest_fs_id , & dest_fs_type , & source_info , & transfer_info ) ;\n aborted : g_list_free_full ( fallbacks , g_free ) ;\n g_free ( dest_fs_id ) ;\n g_free ( dest_fs_type ) ;\n }", "idx": 21157}
{"hash": 1760449185745615462, "project": "debian", "size": 295, "label": 0, "functionSource": "static void * _conf_to_memberp ( TSOverridableConfigKey conf , OverridableHttpConfigParams * overridableHttpConfig , OverridableDataType * typep ) {\n OverridableDataType typ = OVERRIDABLE_TYPE_BYTE ;\n void * ret = nullptr ;\n switch ( conf ) {\n case TS_CONFIG_URL_REMAP_PRISTINE_HOST_HDR : ret = & overridableHttpConfig -> maintain_pristine_host_hdr ;\n break ;\n case TS_CONFIG_HTTP_CHUNKING_ENABLED : ret = & overridableHttpConfig -> chunking_enabled ;\n break ;\n case TS_CONFIG_HTTP_NEGATIVE_CACHING_ENABLED : ret = & overridableHttpConfig -> negative_caching_enabled ;\n break ;\n case TS_CONFIG_HTTP_NEGATIVE_CACHING_LIFETIME : typ = OVERRIDABLE_TYPE_INT ;\n ret = & overridableHttpConfig -> negative_caching_lifetime ;\n break ;\n case TS_CONFIG_HTTP_CACHE_WHEN_TO_REVALIDATE : ret = & overridableHttpConfig -> cache_when_to_revalidate ;\n break ;\n case TS_CONFIG_HTTP_KEEP_ALIVE_ENABLED_IN : ret = & overridableHttpConfig -> keep_alive_enabled_in ;\n break ;\n case TS_CONFIG_HTTP_KEEP_ALIVE_ENABLED_OUT : ret = & overridableHttpConfig -> keep_alive_enabled_out ;\n break ;\n case TS_CONFIG_HTTP_KEEP_ALIVE_POST_OUT : ret = & overridableHttpConfig -> keep_alive_post_out ;\n break ;\n case TS_CONFIG_HTTP_SERVER_SESSION_SHARING_MATCH : ret = & overridableHttpConfig -> server_session_sharing_match ;\n break ;\n case TS_CONFIG_NET_SOCK_RECV_BUFFER_SIZE_OUT : typ = OVERRIDABLE_TYPE_INT ;\n ret = & overridableHttpConfig -> sock_recv_buffer_size_out ;\n break ;\n case TS_CONFIG_NET_SOCK_SEND_BUFFER_SIZE_OUT : typ = OVERRIDABLE_TYPE_INT ;\n ret = & overridableHttpConfig -> sock_send_buffer_size_out ;\n break ;\n case TS_CONFIG_NET_SOCK_OPTION_FLAG_OUT : typ = OVERRIDABLE_TYPE_INT ;\n ret = & overridableHttpConfig -> sock_option_flag_out ;\n break ;\n case TS_CONFIG_HTTP_FORWARD_PROXY_AUTH_TO_PARENT : ret = & overridableHttpConfig -> fwd_proxy_auth_to_parent ;\n break ;\n case TS_CONFIG_HTTP_ANONYMIZE_REMOVE_FROM : ret = & overridableHttpConfig -> anonymize_remove_from ;\n break ;\n case TS_CONFIG_HTTP_ANONYMIZE_REMOVE_REFERER : ret = & overridableHttpConfig -> anonymize_remove_referer ;\n break ;\n case TS_CONFIG_HTTP_ANONYMIZE_REMOVE_USER_AGENT : ret = & overridableHttpConfig -> anonymize_remove_user_agent ;\n break ;\n case TS_CONFIG_HTTP_ANONYMIZE_REMOVE_COOKIE : ret = & overridableHttpConfig -> anonymize_remove_cookie ;\n break ;\n case TS_CONFIG_HTTP_ANONYMIZE_REMOVE_CLIENT_IP : ret = & overridableHttpConfig -> anonymize_remove_client_ip ;\n break ;\n case TS_CONFIG_HTTP_ANONYMIZE_INSERT_CLIENT_IP : ret = & overridableHttpConfig -> anonymize_insert_client_ip ;\n break ;\n case TS_CONFIG_HTTP_RESPONSE_SERVER_ENABLED : ret = & overridableHttpConfig -> proxy_response_server_enabled ;\n break ;\n case TS_CONFIG_HTTP_INSERT_SQUID_X_FORWARDED_FOR : ret = & overridableHttpConfig -> insert_squid_x_forwarded_for ;\n break ;\n case TS_CONFIG_HTTP_SERVER_TCP_INIT_CWND : typ = OVERRIDABLE_TYPE_INT ;\n ret = & overridableHttpConfig -> server_tcp_init_cwnd ;\n break ;\n case TS_CONFIG_HTTP_SEND_HTTP11_REQUESTS : ret = & overridableHttpConfig -> send_http11_requests ;\n break ;\n case TS_CONFIG_HTTP_CACHE_HTTP : ret = & overridableHttpConfig -> cache_http ;\n break ;\n case TS_CONFIG_HTTP_CACHE_CLUSTER_CACHE_LOCAL : ret = & overridableHttpConfig -> cache_cluster_cache_local ;\n break ;\n case TS_CONFIG_HTTP_CACHE_IGNORE_CLIENT_NO_CACHE : ret = & overridableHttpConfig -> cache_ignore_client_no_cache ;\n break ;\n case TS_CONFIG_HTTP_CACHE_IGNORE_CLIENT_CC_MAX_AGE : ret = & overridableHttpConfig -> cache_ignore_client_cc_max_age ;\n break ;\n case TS_CONFIG_HTTP_CACHE_IMS_ON_CLIENT_NO_CACHE : ret = & overridableHttpConfig -> cache_ims_on_client_no_cache ;\n break ;\n case TS_CONFIG_HTTP_CACHE_IGNORE_SERVER_NO_CACHE : ret = & overridableHttpConfig -> cache_ignore_server_no_cache ;\n break ;\n case TS_CONFIG_HTTP_CACHE_CACHE_RESPONSES_TO_COOKIES : ret = & overridableHttpConfig -> cache_responses_to_cookies ;\n break ;\n case TS_CONFIG_HTTP_CACHE_IGNORE_AUTHENTICATION : ret = & overridableHttpConfig -> cache_ignore_auth ;\n break ;\n case TS_CONFIG_HTTP_CACHE_CACHE_URLS_THAT_LOOK_DYNAMIC : ret = & overridableHttpConfig -> cache_urls_that_look_dynamic ;\n break ;\n case TS_CONFIG_HTTP_CACHE_REQUIRED_HEADERS : ret = & overridableHttpConfig -> cache_required_headers ;\n break ;\n case TS_CONFIG_HTTP_INSERT_REQUEST_VIA_STR : ret = & overridableHttpConfig -> insert_request_via_string ;\n break ;\n case TS_CONFIG_HTTP_INSERT_RESPONSE_VIA_STR : ret = & overridableHttpConfig -> insert_response_via_string ;\n break ;\n case TS_CONFIG_HTTP_CACHE_HEURISTIC_MIN_LIFETIME : typ = OVERRIDABLE_TYPE_INT ;\n ret = & overridableHttpConfig -> cache_heuristic_min_lifetime ;\n break ;\n case TS_CONFIG_HTTP_CACHE_HEURISTIC_MAX_LIFETIME : typ = OVERRIDABLE_TYPE_INT ;\n ret = & overridableHttpConfig -> cache_heuristic_max_lifetime ;\n break ;\n case TS_CONFIG_HTTP_CACHE_GUARANTEED_MIN_LIFETIME : typ = OVERRIDABLE_TYPE_INT ;\n ret = & overridableHttpConfig -> cache_guaranteed_min_lifetime ;\n break ;\n case TS_CONFIG_HTTP_CACHE_GUARANTEED_MAX_LIFETIME : typ = OVERRIDABLE_TYPE_INT ;\n ret = & overridableHttpConfig -> cache_guaranteed_max_lifetime ;\n break ;\n case TS_CONFIG_HTTP_CACHE_MAX_STALE_AGE : typ = OVERRIDABLE_TYPE_INT ;\n ret = & overridableHttpConfig -> cache_max_stale_age ;\n break ;\n case TS_CONFIG_HTTP_KEEP_ALIVE_NO_ACTIVITY_TIMEOUT_IN : typ = OVERRIDABLE_TYPE_INT ;\n ret = & overridableHttpConfig -> keep_alive_no_activity_timeout_in ;\n break ;\n case TS_CONFIG_HTTP_KEEP_ALIVE_NO_ACTIVITY_TIMEOUT_OUT : typ = OVERRIDABLE_TYPE_INT ;\n ret = & overridableHttpConfig -> keep_alive_no_activity_timeout_out ;\n break ;\n case TS_CONFIG_HTTP_TRANSACTION_NO_ACTIVITY_TIMEOUT_IN : typ = OVERRIDABLE_TYPE_INT ;\n ret = & overridableHttpConfig -> transaction_no_activity_timeout_in ;\n break ;\n case TS_CONFIG_HTTP_TRANSACTION_NO_ACTIVITY_TIMEOUT_OUT : typ = OVERRIDABLE_TYPE_INT ;\n ret = & overridableHttpConfig -> transaction_no_activity_timeout_out ;\n break ;\n case TS_CONFIG_HTTP_TRANSACTION_ACTIVE_TIMEOUT_OUT : typ = OVERRIDABLE_TYPE_INT ;\n ret = & overridableHttpConfig -> transaction_active_timeout_out ;\n break ;\n case TS_CONFIG_HTTP_ORIGIN_MAX_CONNECTIONS : typ = OVERRIDABLE_TYPE_INT ;\n ret = & overridableHttpConfig -> origin_max_connections ;\n break ;\n case TS_CONFIG_HTTP_CONNECT_ATTEMPTS_MAX_RETRIES : typ = OVERRIDABLE_TYPE_INT ;\n ret = & overridableHttpConfig -> connect_attempts_max_retries ;\n break ;\n case TS_CONFIG_HTTP_CONNECT_ATTEMPTS_MAX_RETRIES_DEAD_SERVER : typ = OVERRIDABLE_TYPE_INT ;\n ret = & overridableHttpConfig -> connect_attempts_max_retries_dead_server ;\n break ;\n case TS_CONFIG_HTTP_CONNECT_ATTEMPTS_RR_RETRIES : typ = OVERRIDABLE_TYPE_INT ;\n ret = & overridableHttpConfig -> connect_attempts_rr_retries ;\n break ;\n case TS_CONFIG_HTTP_CONNECT_ATTEMPTS_TIMEOUT : typ = OVERRIDABLE_TYPE_INT ;\n ret = & overridableHttpConfig -> connect_attempts_timeout ;\n break ;\n case TS_CONFIG_HTTP_POST_CONNECT_ATTEMPTS_TIMEOUT : typ = OVERRIDABLE_TYPE_INT ;\n ret = & overridableHttpConfig -> post_connect_attempts_timeout ;\n break ;\n case TS_CONFIG_HTTP_DOWN_SERVER_CACHE_TIME : typ = OVERRIDABLE_TYPE_INT ;\n ret = & overridableHttpConfig -> down_server_timeout ;\n break ;\n case TS_CONFIG_HTTP_DOWN_SERVER_ABORT_THRESHOLD : typ = OVERRIDABLE_TYPE_INT ;\n ret = & overridableHttpConfig -> client_abort_threshold ;\n break ;\n case TS_CONFIG_HTTP_CACHE_FUZZ_TIME : typ = OVERRIDABLE_TYPE_INT ;\n ret = & overridableHttpConfig -> freshness_fuzz_time ;\n break ;\n case TS_CONFIG_HTTP_CACHE_FUZZ_MIN_TIME : typ = OVERRIDABLE_TYPE_INT ;\n ret = & overridableHttpConfig -> freshness_fuzz_min_time ;\n break ;\n case TS_CONFIG_HTTP_DOC_IN_CACHE_SKIP_DNS : ret = & overridableHttpConfig -> doc_in_cache_skip_dns ;\n break ;\n case TS_CONFIG_HTTP_BACKGROUND_FILL_ACTIVE_TIMEOUT : typ = OVERRIDABLE_TYPE_INT ;\n ret = & overridableHttpConfig -> background_fill_active_timeout ;\n break ;\n case TS_CONFIG_HTTP_RESPONSE_SERVER_STR : typ = OVERRIDABLE_TYPE_STRING ;\n ret = & overridableHttpConfig -> proxy_response_server_string ;\n break ;\n case TS_CONFIG_HTTP_CACHE_HEURISTIC_LM_FACTOR : typ = OVERRIDABLE_TYPE_FLOAT ;\n ret = & overridableHttpConfig -> cache_heuristic_lm_factor ;\n break ;\n case TS_CONFIG_HTTP_CACHE_FUZZ_PROBABILITY : typ = OVERRIDABLE_TYPE_FLOAT ;\n ret = & overridableHttpConfig -> freshness_fuzz_prob ;\n break ;\n case TS_CONFIG_HTTP_BACKGROUND_FILL_COMPLETED_THRESHOLD : typ = OVERRIDABLE_TYPE_FLOAT ;\n ret = & overridableHttpConfig -> background_fill_threshold ;\n break ;\n case TS_CONFIG_NET_SOCK_PACKET_MARK_OUT : typ = OVERRIDABLE_TYPE_INT ;\n ret = & overridableHttpConfig -> sock_packet_mark_out ;\n break ;\n case TS_CONFIG_NET_SOCK_PACKET_TOS_OUT : typ = OVERRIDABLE_TYPE_INT ;\n ret = & overridableHttpConfig -> sock_packet_tos_out ;\n break ;\n case TS_CONFIG_HTTP_INSERT_AGE_IN_RESPONSE : ret = & overridableHttpConfig -> insert_age_in_response ;\n break ;\n case TS_CONFIG_HTTP_CHUNKING_SIZE : typ = OVERRIDABLE_TYPE_INT ;\n ret = & overridableHttpConfig -> http_chunking_size ;\n break ;\n case TS_CONFIG_HTTP_FLOW_CONTROL_ENABLED : ret = & overridableHttpConfig -> flow_control_enabled ;\n break ;\n case TS_CONFIG_HTTP_FLOW_CONTROL_LOW_WATER_MARK : typ = OVERRIDABLE_TYPE_INT ;\n ret = & overridableHttpConfig -> flow_low_water_mark ;\n break ;\n case TS_CONFIG_HTTP_FLOW_CONTROL_HIGH_WATER_MARK : typ = OVERRIDABLE_TYPE_INT ;\n ret = & overridableHttpConfig -> flow_high_water_mark ;\n break ;\n case TS_CONFIG_HTTP_CACHE_RANGE_LOOKUP : ret = & overridableHttpConfig -> cache_range_lookup ;\n break ;\n case TS_CONFIG_HTTP_NORMALIZE_AE_GZIP : ret = & overridableHttpConfig -> normalize_ae_gzip ;\n break ;\n case TS_CONFIG_HTTP_DEFAULT_BUFFER_SIZE : typ = OVERRIDABLE_TYPE_INT ;\n ret = & overridableHttpConfig -> default_buffer_size_index ;\n break ;\n case TS_CONFIG_HTTP_DEFAULT_BUFFER_WATER_MARK : typ = OVERRIDABLE_TYPE_INT ;\n ret = & overridableHttpConfig -> default_buffer_water_mark ;\n break ;\n case TS_CONFIG_HTTP_REQUEST_HEADER_MAX_SIZE : typ = OVERRIDABLE_TYPE_INT ;\n ret = & overridableHttpConfig -> request_hdr_max_size ;\n break ;\n case TS_CONFIG_HTTP_RESPONSE_HEADER_MAX_SIZE : typ = OVERRIDABLE_TYPE_INT ;\n ret = & overridableHttpConfig -> response_hdr_max_size ;\n break ;\n case TS_CONFIG_HTTP_NEGATIVE_REVALIDATING_ENABLED : ret = & overridableHttpConfig -> negative_revalidating_enabled ;\n break ;\n case TS_CONFIG_HTTP_NEGATIVE_REVALIDATING_LIFETIME : typ = OVERRIDABLE_TYPE_INT ;\n ret = & overridableHttpConfig -> negative_revalidating_lifetime ;\n break ;\n case TS_CONFIG_SSL_HSTS_MAX_AGE : typ = OVERRIDABLE_TYPE_INT ;\n ret = & overridableHttpConfig -> proxy_response_hsts_max_age ;\n break ;\n case TS_CONFIG_SSL_HSTS_INCLUDE_SUBDOMAINS : ret = & overridableHttpConfig -> proxy_response_hsts_include_subdomains ;\n break ;\n case TS_CONFIG_HTTP_CACHE_OPEN_READ_RETRY_TIME : typ = OVERRIDABLE_TYPE_INT ;\n ret = & overridableHttpConfig -> cache_open_read_retry_time ;\n break ;\n case TS_CONFIG_HTTP_CACHE_MAX_OPEN_READ_RETRIES : typ = OVERRIDABLE_TYPE_INT ;\n ret = & overridableHttpConfig -> max_cache_open_read_retries ;\n break ;\n case TS_CONFIG_HTTP_CACHE_RANGE_WRITE : ret = & overridableHttpConfig -> cache_range_write ;\n break ;\n case TS_CONFIG_HTTP_POST_CHECK_CONTENT_LENGTH_ENABLED : ret = & overridableHttpConfig -> post_check_content_length_enabled ;\n break ;\n case TS_CONFIG_HTTP_GLOBAL_USER_AGENT_HEADER : typ = OVERRIDABLE_TYPE_STRING ;\n ret = & overridableHttpConfig -> global_user_agent_header ;\n break ;\n case TS_CONFIG_HTTP_AUTH_SERVER_SESSION_PRIVATE : ret = & overridableHttpConfig -> auth_server_session_private ;\n break ;\n case TS_CONFIG_HTTP_SLOW_LOG_THRESHOLD : typ = OVERRIDABLE_TYPE_INT ;\n ret = & overridableHttpConfig -> slow_log_threshold ;\n break ;\n case TS_CONFIG_HTTP_CACHE_GENERATION : typ = OVERRIDABLE_TYPE_INT ;\n ret = & overridableHttpConfig -> cache_generation_number ;\n break ;\n case TS_CONFIG_BODY_FACTORY_TEMPLATE_BASE : typ = OVERRIDABLE_TYPE_STRING ;\n ret = & overridableHttpConfig -> body_factory_template_base ;\n break ;\n case TS_CONFIG_HTTP_CACHE_OPEN_WRITE_FAIL_ACTION : ret = & overridableHttpConfig -> cache_open_write_fail_action ;\n break ;\n case TS_CONFIG_HTTP_ENABLE_REDIRECTION : ret = & overridableHttpConfig -> redirection_enabled ;\n break ;\n case TS_CONFIG_HTTP_NUMBER_OF_REDIRECTIONS : typ = OVERRIDABLE_TYPE_INT ;\n ret = & overridableHttpConfig -> number_of_redirections ;\n break ;\n case TS_CONFIG_HTTP_CACHE_MAX_OPEN_WRITE_RETRIES : typ = OVERRIDABLE_TYPE_INT ;\n ret = & overridableHttpConfig -> max_cache_open_write_retries ;\n break ;\n case TS_CONFIG_HTTP_REDIRECT_USE_ORIG_CACHE_KEY : ret = & overridableHttpConfig -> redirect_use_orig_cache_key ;\n break ;\n case TS_CONFIG_HTTP_ATTACH_SERVER_SESSION_TO_CLIENT : typ = OVERRIDABLE_TYPE_INT ;\n ret = & overridableHttpConfig -> attach_server_session_to_client ;\n break ;\n case TS_CONFIG_HTTP_SAFE_REQUESTS_RETRYABLE : typ = OVERRIDABLE_TYPE_INT ;\n ret = & overridableHttpConfig -> safe_requests_retryable ;\n break ;\n case TS_CONFIG_HTTP_ORIGIN_MAX_CONNECTIONS_QUEUE : typ = OVERRIDABLE_TYPE_INT ;\n ret = & overridableHttpConfig -> origin_max_connections_queue ;\n break ;\n case TS_CONFIG_WEBSOCKET_NO_ACTIVITY_TIMEOUT : typ = OVERRIDABLE_TYPE_INT ;\n ret = & overridableHttpConfig -> websocket_inactive_timeout ;\n break ;\n case TS_CONFIG_WEBSOCKET_ACTIVE_TIMEOUT : typ = OVERRIDABLE_TYPE_INT ;\n ret = & overridableHttpConfig -> websocket_active_timeout ;\n break ;\n case TS_CONFIG_HTTP_UNCACHEABLE_REQUESTS_BYPASS_PARENT : ret = & overridableHttpConfig -> uncacheable_requests_bypass_parent ;\n break ;\n case TS_CONFIG_HTTP_PARENT_PROXY_TOTAL_CONNECT_ATTEMPTS : typ = OVERRIDABLE_TYPE_INT ;\n ret = & overridableHttpConfig -> parent_connect_attempts ;\n break ;\n case TS_CONFIG_HTTP_TRANSACTION_ACTIVE_TIMEOUT_IN : typ = OVERRIDABLE_TYPE_INT ;\n ret = & overridableHttpConfig -> transaction_active_timeout_in ;\n break ;\n case TS_CONFIG_SRV_ENABLED : ret = & overridableHttpConfig -> srv_enabled ;\n break ;\n case TS_CONFIG_HTTP_FORWARD_CONNECT_METHOD : ret = & overridableHttpConfig -> forward_connect_method ;\n break ;\n case TS_CONFIG_SSL_CERT_FILENAME : typ = OVERRIDABLE_TYPE_STRING ;\n ret = & overridableHttpConfig -> client_cert_filename ;\n break ;\n case TS_CONFIG_SSL_CERT_FILEPATH : typ = OVERRIDABLE_TYPE_STRING ;\n ret = & overridableHttpConfig -> client_cert_filepath ;\n break ;\n case TS_CONFIG_PARENT_FAILURES_UPDATE_HOSTDB : ret = & overridableHttpConfig -> parent_failures_update_hostdb ;\n break ;\n case TS_CONFIG_SSL_CLIENT_VERIFY_SERVER : ret = & overridableHttpConfig -> ssl_client_verify_server ;\n break ;\n case TS_CONFIG_HTTP_PARENT_PROXY_FAIL_THRESHOLD : typ = OVERRIDABLE_TYPE_INT ;\n ret = & overridableHttpConfig -> parent_fail_threshold ;\n break ;\n case TS_CONFIG_HTTP_PARENT_PROXY_RETRY_TIME : typ = OVERRIDABLE_TYPE_INT ;\n ret = & overridableHttpConfig -> parent_retry_time ;\n break ;\n case TS_CONFIG_HTTP_PER_PARENT_CONNECT_ATTEMPTS : typ = OVERRIDABLE_TYPE_INT ;\n ret = & overridableHttpConfig -> per_parent_connect_attempts ;\n break ;\n case TS_CONFIG_HTTP_PARENT_CONNECT_ATTEMPT_TIMEOUT : typ = OVERRIDABLE_TYPE_INT ;\n ret = & overridableHttpConfig -> parent_connect_timeout ;\n break ;\n case TS_CONFIG_HTTP_ALLOW_MULTI_RANGE : ret = & overridableHttpConfig -> allow_multi_range ;\n break ;\n case TS_CONFIG_NULL : case TS_CONFIG_LAST_ENTRY : typ = OVERRIDABLE_TYPE_NULL ;\n ret = nullptr ;\n break ;\n }\n * typep = typ ;\n return ret ;\n }", "idx": 21158}
{"hash": -755883256379441954, "project": "chrome", "size": 209, "label": 1, "functionSource": "void vp9_ ## type ## _predictor_ ## size ## x ## size ## _c ( uint8_t * dst , ptrdiff_t stride , const uint8_t * above , const uint8_t * left ) {\n type ## _predictor ( dst , stride , size , above , left ) ;\n }\n # define intra_pred_allsizes ( type ) intra_pred_sized ( type , 4 ) intra_pred_sized ( type , 8 ) intra_pred_sized ( type , 16 ) intra_pred_sized ( type , 32 ) static INLINE void d207_predictor ( uint8_t * dst , ptrdiff_t stride , int bs , const uint8_t * above , const uint8_t * left ) {\n int r , c ;\n ( void ) above ;\n for ( r = 0 ;\n r < bs - 1 ;\n ++ r ) dst [ r * stride ] = ROUND_POWER_OF_TWO ( left [ r ] + left [ r + 1 ] , 1 ) ;\n dst [ ( bs - 1 ) * stride ] = left [ bs - 1 ] ;\n dst ++ ;\n for ( r = 0 ;\n r < bs - 2 ;\n ++ r ) dst [ r * stride ] = ROUND_POWER_OF_TWO ( left [ r ] + left [ r + 1 ] * 2 + left [ r + 2 ] , 2 ) ;\n dst [ ( bs - 2 ) * stride ] = ROUND_POWER_OF_TWO ( left [ bs - 2 ] + left [ bs - 1 ] * 3 , 2 ) ;\n dst [ ( bs - 1 ) * stride ] = left [ bs - 1 ] ;\n dst ++ ;\n for ( c = 0 ;\n c < bs - 2 ;\n ++ c ) dst [ ( bs - 1 ) * stride + c ] = left [ bs - 1 ] ;\n for ( r = bs - 2 ;\n r >= 0 ;\n -- r ) for ( c = 0 ;\n c < bs - 2 ;\n ++ c ) dst [ r * stride + c ] = dst [ ( r + 1 ) * stride + c - 2 ] ;\n }\n intra_pred_allsizes ( d207 ) static INLINE void d63_predictor ( uint8_t * dst , ptrdiff_t stride , int bs , const uint8_t * above , const uint8_t * left ) {\n int r , c ;\n ( void ) left ;\n for ( r = 0 ;\n r < bs ;\n ++ r ) {\n for ( c = 0 ;\n c < bs ;\n ++ c ) dst [ c ] = r & 1 ? ROUND_POWER_OF_TWO ( above [ r / 2 + c ] + above [ r / 2 + c + 1 ] * 2 + above [ r / 2 + c + 2 ] , 2 ) : ROUND_POWER_OF_TWO ( above [ r / 2 + c ] + above [ r / 2 + c + 1 ] , 1 ) ;\n dst += stride ;\n }\n }\n intra_pred_allsizes ( d63 ) static INLINE void d45_predictor ( uint8_t * dst , ptrdiff_t stride , int bs , const uint8_t * above , const uint8_t * left ) {\n int r , c ;\n ( void ) left ;\n for ( r = 0 ;\n r < bs ;\n ++ r ) {\n for ( c = 0 ;\n c < bs ;\n ++ c ) dst [ c ] = r + c + 2 < bs * 2 ? ROUND_POWER_OF_TWO ( above [ r + c ] + above [ r + c + 1 ] * 2 + above [ r + c + 2 ] , 2 ) : above [ bs * 2 - 1 ] ;\n dst += stride ;\n }\n }\n intra_pred_allsizes ( d45 ) static INLINE void d117_predictor ( uint8_t * dst , ptrdiff_t stride , int bs , const uint8_t * above , const uint8_t * left ) {\n int r , c ;\n for ( c = 0 ;\n c < bs ;\n c ++ ) dst [ c ] = ROUND_POWER_OF_TWO ( above [ c - 1 ] + above [ c ] , 1 ) ;\n dst += stride ;\n dst [ 0 ] = ROUND_POWER_OF_TWO ( left [ 0 ] + above [ - 1 ] * 2 + above [ 0 ] , 2 ) ;\n for ( c = 1 ;\n c < bs ;\n c ++ ) dst [ c ] = ROUND_POWER_OF_TWO ( above [ c - 2 ] + above [ c - 1 ] * 2 + above [ c ] , 2 ) ;\n dst += stride ;\n dst [ 0 ] = ROUND_POWER_OF_TWO ( above [ - 1 ] + left [ 0 ] * 2 + left [ 1 ] , 2 ) ;\n for ( r = 3 ;\n r < bs ;\n ++ r ) dst [ ( r - 2 ) * stride ] = ROUND_POWER_OF_TWO ( left [ r - 3 ] + left [ r - 2 ] * 2 + left [ r - 1 ] , 2 ) ;\n for ( r = 2 ;\n r < bs ;\n ++ r ) {\n for ( c = 1 ;\n c < bs ;\n c ++ ) dst [ c ] = dst [ - 2 * stride + c - 1 ] ;\n dst += stride ;\n }\n }\n intra_pred_allsizes ( d117 ) static INLINE void d135_predictor ( uint8_t * dst , ptrdiff_t stride , int bs , const uint8_t * above , const uint8_t * left ) {\n int r , c ;\n dst [ 0 ] = ROUND_POWER_OF_TWO ( left [ 0 ] + above [ - 1 ] * 2 + above [ 0 ] , 2 ) ;\n for ( c = 1 ;\n c < bs ;\n c ++ ) dst [ c ] = ROUND_POWER_OF_TWO ( above [ c - 2 ] + above [ c - 1 ] * 2 + above [ c ] , 2 ) ;\n dst [ stride ] = ROUND_POWER_OF_TWO ( above [ - 1 ] + left [ 0 ] * 2 + left [ 1 ] , 2 ) ;\n for ( r = 2 ;\n r < bs ;\n ++ r ) dst [ r * stride ] = ROUND_POWER_OF_TWO ( left [ r - 2 ] + left [ r - 1 ] * 2 + left [ r ] , 2 ) ;\n dst += stride ;\n for ( r = 1 ;\n r < bs ;\n ++ r ) {\n for ( c = 1 ;\n c < bs ;\n c ++ ) dst [ c ] = dst [ - stride + c - 1 ] ;\n dst += stride ;\n }\n }\n intra_pred_allsizes ( d135 ) static INLINE void d153_predictor ( uint8_t * dst , ptrdiff_t stride , int bs , const uint8_t * above , const uint8_t * left ) {\n int r , c ;\n dst [ 0 ] = ROUND_POWER_OF_TWO ( above [ - 1 ] + left [ 0 ] , 1 ) ;\n for ( r = 1 ;\n r < bs ;\n r ++ ) dst [ r * stride ] = ROUND_POWER_OF_TWO ( left [ r - 1 ] + left [ r ] , 1 ) ;\n dst ++ ;\n dst [ 0 ] = ROUND_POWER_OF_TWO ( left [ 0 ] + above [ - 1 ] * 2 + above [ 0 ] , 2 ) ;\n dst [ stride ] = ROUND_POWER_OF_TWO ( above [ - 1 ] + left [ 0 ] * 2 + left [ 1 ] , 2 ) ;\n for ( r = 2 ;\n r < bs ;\n r ++ ) dst [ r * stride ] = ROUND_POWER_OF_TWO ( left [ r - 2 ] + left [ r - 1 ] * 2 + left [ r ] , 2 ) ;\n dst ++ ;\n for ( c = 0 ;\n c < bs - 2 ;\n c ++ ) dst [ c ] = ROUND_POWER_OF_TWO ( above [ c - 1 ] + above [ c ] * 2 + above [ c + 1 ] , 2 ) ;\n dst += stride ;\n for ( r = 1 ;\n r < bs ;\n ++ r ) {\n for ( c = 0 ;\n c < bs - 2 ;\n c ++ ) dst [ c ] = dst [ - stride + c - 2 ] ;\n dst += stride ;\n }\n }\n intra_pred_allsizes ( d153 ) static INLINE void v_predictor ( uint8_t * dst , ptrdiff_t stride , int bs , const uint8_t * above , const uint8_t * left ) {\n int r ;\n ( void ) left ;\n for ( r = 0 ;\n r < bs ;\n r ++ ) {\n vpx_memcpy ( dst , above , bs ) ;\n dst += stride ;\n }\n }\n intra_pred_allsizes ( v ) static INLINE void h_predictor ( uint8_t * dst , ptrdiff_t stride , int bs , const uint8_t * above , const uint8_t * left ) {\n int r ;\n ( void ) above ;\n for ( r = 0 ;\n r < bs ;\n r ++ ) {\n vpx_memset ( dst , left [ r ] , bs ) ;\n dst += stride ;\n }\n }\n intra_pred_allsizes ( h ) static INLINE void tm_predictor ( uint8_t * dst , ptrdiff_t stride , int bs , const uint8_t * above , const uint8_t * left ) {\n int r , c ;\n int ytop_left = above [ - 1 ] ;\n for ( r = 0 ;\n r < bs ;\n r ++ ) {\n for ( c = 0 ;\n c < bs ;\n c ++ ) dst [ c ] = clip_pixel ( left [ r ] + above [ c ] - ytop_left ) ;\n dst += stride ;\n }\n }\n intra_pred_allsizes ( tm ) static INLINE void dc_128_predictor ( uint8_t * dst , ptrdiff_t stride , int bs , const uint8_t * above , const uint8_t * left ) {\n int r ;\n ( void ) above ;\n ( void ) left ;\n for ( r = 0 ;\n r < bs ;\n r ++ ) {\n vpx_memset ( dst , 128 , bs ) ;\n dst += stride ;\n }\n }\n intra_pred_allsizes ( dc_128 ) static INLINE void dc_left_predictor ( uint8_t * dst , ptrdiff_t stride , int bs , const uint8_t * above , const uint8_t * left ) {\n int i , r , expected_dc , sum = 0 ;\n ( void ) above ;\n for ( i = 0 ;\n i < bs ;\n i ++ ) sum += left [ i ] ;\n expected_dc = ( sum + ( bs >> 1 ) ) / bs ;\n for ( r = 0 ;\n r < bs ;\n r ++ ) {\n vpx_memset ( dst , expected_dc , bs ) ;\n dst += stride ;\n }\n }\n intra_pred_allsizes ( dc_left ) static INLINE void dc_top_predictor ( uint8_t * dst , ptrdiff_t stride , int bs , const uint8_t * above , const uint8_t * left ) {\n int i , r , expected_dc , sum = 0 ;\n ( void ) left ;\n for ( i = 0 ;\n i < bs ;\n i ++ ) sum += above [ i ] ;\n expected_dc = ( sum + ( bs >> 1 ) ) / bs ;\n for ( r = 0 ;\n r < bs ;\n r ++ ) {\n vpx_memset ( dst , expected_dc , bs ) ;\n dst += stride ;\n }\n }\n intra_pred_allsizes ( dc_top ) static INLINE void dc_predictor ( uint8_t * dst , ptrdiff_t stride , int bs , const uint8_t * above , const uint8_t * left ) {\n int i , r , expected_dc , sum = 0 ;\n const int count = 2 * bs ;\n for ( i = 0 ;\n i < bs ;\n i ++ ) {\n sum += above [ i ] ;\n sum += left [ i ] ;\n }\n expected_dc = ( sum + ( count >> 1 ) ) / count ;\n for ( r = 0 ;\n r < bs ;\n r ++ ) {\n vpx_memset ( dst , expected_dc , bs ) ;\n dst += stride ;\n }\n }\n intra_pred_allsizes ( dc )", "idx": 21159}
{"hash": 8953904005695962093, "project": "debian", "size": 42, "label": 0, "functionSource": "static void xan_unpack ( unsigned char * dest , int dest_len , const unsigned char * src , int src_len ) {\n unsigned char opcode ;\n int size ;\n unsigned char * dest_org = dest ;\n unsigned char * dest_end = dest + dest_len ;\n GetByteContext ctx ;\n bytestream2_init ( & ctx , src , src_len ) ;\n while ( dest < dest_end && bytestream2_get_bytes_left ( & ctx ) ) {\n opcode = bytestream2_get_byte ( & ctx ) ;\n if ( opcode < 0xe0 ) {\n int size2 , back ;\n if ( ( opcode & 0x80 ) == 0 ) {\n size = opcode & 3 ;\n back = ( ( opcode & 0x60 ) << 3 ) + bytestream2_get_byte ( & ctx ) + 1 ;\n size2 = ( ( opcode & 0x1c ) >> 2 ) + 3 ;\n }\n else if ( ( opcode & 0x40 ) == 0 ) {\n size = bytestream2_peek_byte ( & ctx ) >> 6 ;\n back = ( bytestream2_get_be16 ( & ctx ) & 0x3fff ) + 1 ;\n size2 = ( opcode & 0x3f ) + 4 ;\n }\n else {\n size = opcode & 3 ;\n back = ( ( opcode & 0x10 ) << 12 ) + bytestream2_get_be16 ( & ctx ) + 1 ;\n size2 = ( ( opcode & 0x0c ) << 6 ) + bytestream2_get_byte ( & ctx ) + 5 ;\n }\n if ( dest_end - dest < size + size2 || dest + size - dest_org < back || bytestream2_get_bytes_left ( & ctx ) < size ) return ;\n bytestream2_get_buffer ( & ctx , dest , size ) ;\n dest += size ;\n av_memcpy_backptr ( dest , back , size2 ) ;\n dest += size2 ;\n }\n else {\n int finish = opcode >= 0xfc ;\n size = finish ? opcode & 3 : ( ( opcode & 0x1f ) << 2 ) + 4 ;\n if ( dest_end - dest < size || bytestream2_get_bytes_left ( & ctx ) < size ) return ;\n bytestream2_get_buffer ( & ctx , dest , size ) ;\n dest += size ;\n if ( finish ) return ;\n }\n }\n }", "idx": 21160}
{"hash": 5653549006541675258, "project": "debian", "size": 4, "label": 0, "functionSource": "static unsigned char conv_ascii2bin ( unsigned char a ) {\n if ( a & 0x80 ) return B64_ERROR ;\n return data_ascii2bin [ a ] ;\n }", "idx": 21161}
{"hash": 3935234056444097745, "project": "debian", "size": 20, "label": 0, "functionSource": "static int rtp_packetize_g726 ( sout_stream_id_sys_t * id , block_t * in , int i_pad ) {\n int i_max = ( rtp_mtu ( id ) - 12 + i_pad - 1 ) & ~ i_pad ;\n int i_count = ( in -> i_buffer + i_max - 1 ) / i_max ;\n uint8_t * p_data = in -> p_buffer ;\n int i_data = in -> i_buffer ;\n int i_packet = 0 ;\n while ( i_data > 0 ) {\n int i_payload = __MIN ( i_max , i_data ) ;\n block_t * out = block_Alloc ( 12 + i_payload ) ;\n rtp_packetize_common ( id , out , 0 , ( in -> i_pts > VLC_TS_INVALID ? in -> i_pts : in -> i_dts ) ) ;\n memcpy ( & out -> p_buffer [ 12 ] , p_data , i_payload ) ;\n out -> i_dts = in -> i_dts + i_packet ++ * in -> i_length / i_count ;\n out -> i_length = in -> i_length / i_count ;\n rtp_packetize_send ( id , out ) ;\n p_data += i_payload ;\n i_data -= i_payload ;\n }\n block_Release ( in ) ;\n return VLC_SUCCESS ;\n }", "idx": 21162}
{"hash": -2423144171479606949, "project": "debian", "size": 7, "label": 0, "functionSource": "static void pdf_run_M ( fz_context * ctx , pdf_processor * proc , float miterlimit ) {\n pdf_run_processor * pr = ( pdf_run_processor * ) proc ;\n pdf_gstate * gstate = pdf_flush_text ( ctx , pr ) ;\n pr -> dev -> flags &= ~ FZ_DEVFLAG_MITERLIMIT_UNDEFINED ;\n gstate -> stroke_state = fz_unshare_stroke_state ( ctx , gstate -> stroke_state ) ;\n gstate -> stroke_state -> miterlimit = miterlimit ;\n }", "idx": 21163}
{"hash": 7092216800726729686, "project": "debian", "size": 9, "label": 0, "functionSource": "static int dissect_h245_OLC_reverseLogicalChannelParameters ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 194 \"../../asn1/h245/h245.cnf\" upcoming_channel = ( upcoming_olc ) ? & upcoming_olc -> rev_lc : NULL ;\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_OLC_reverseLogicalChannelParameters , OLC_reverseLogicalChannelParameters_sequence ) ;\n if ( upcoming_channel && codec_type ) {\n g_strlcpy ( upcoming_channel -> data_type_str , codec_type , sizeof ( upcoming_channel -> data_type_str ) ) ;\n }\n upcoming_channel = NULL ;\n return offset ;\n }", "idx": 21164}
{"hash": 355220887711506893, "project": "debian", "size": 11, "label": 1, "functionSource": "extern int name ( int ) __THROW __exctype ( isalnum ) ;\n __exctype ( isalpha ) ;\n __exctype ( iscntrl ) ;\n __exctype ( isdigit ) ;\n __exctype ( islower ) ;\n __exctype ( isgraph ) ;\n __exctype ( isprint ) ;\n __exctype ( ispunct ) ;\n __exctype ( isspace ) ;\n __exctype ( isupper ) ;\n __exctype ( isxdigit )", "idx": 21165}
{"hash": 7399683071036018868, "project": "debian", "size": 10, "label": 0, "functionSource": "static int row_get_classname ( const zval * object , const char * * class_name , zend_uint * class_name_len , int parent TSRMLS_DC ) {\n if ( parent ) {\n return FAILURE ;\n }\n else {\n * class_name = estrndup ( \"PDORow\" , sizeof ( \"PDORow\" ) - 1 ) ;\n * class_name_len = sizeof ( \"PDORow\" ) - 1 ;\n return SUCCESS ;\n }\n }", "idx": 21166}
{"hash": 1245821301839614810, "project": "debian", "size": 21, "label": 0, "functionSource": "static gboolean make_file_name_valid_for_dest_fs ( char * filename , const char * dest_fs_type ) {\n if ( dest_fs_type != NULL && filename != NULL ) {\n if ( ! strcmp ( dest_fs_type , \"fat\" ) || ! strcmp ( dest_fs_type , \"vfat\" ) || ! strcmp ( dest_fs_type , \"msdos\" ) || ! strcmp ( dest_fs_type , \"msdosfs\" ) ) {\n gboolean ret ;\n int i , old_len ;\n ret = fat_str_replace ( filename , '_' ) ;\n old_len = strlen ( filename ) ;\n for ( i = 0 ;\n i < old_len ;\n i ++ ) {\n if ( filename [ i ] != ' ' ) {\n g_strchomp ( filename ) ;\n ret |= ( old_len != strlen ( filename ) ) ;\n break ;\n }\n }\n return ret ;\n }\n }\n return FALSE ;\n }", "idx": 21167}
{"hash": -6024601983167898950, "project": "debian", "size": 5, "label": 0, "functionSource": "static void unpause_activation_timed_cancel ( ActivateParameters * parameters ) {\n if ( ! parameters -> timed_wait_active ) {\n activation_start_timed_cancel ( parameters ) ;\n }\n }", "idx": 21168}
{"hash": 4489017523191997023, "project": "debian", "size": 10, "label": 0, "functionSource": "static int dissect_h225_Facility_UUIE ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 445 \"./asn1/h225/h225.cnf\" h225_packet_info * h225_pi ;\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_Facility_UUIE , Facility_UUIE_sequence ) ;\n # line 449 \"./asn1/h225/h225.cnf\" h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;\n if ( h225_pi != NULL ) {\n h225_pi -> cs_type = H225_FACILITY ;\n g_snprintf ( h225_pi -> frame_label , 50 , \"%s\" , val_to_str ( h225_pi -> cs_type , T_h323_message_body_vals , \"<unknown>\" ) ) ;\n }\n return offset ;\n }", "idx": 21169}
{"hash": 6336384260629386331, "project": "debian", "size": 53, "label": 0, "functionSource": "static int dissect_zbee_zcl_ota ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , void * data ) {\n proto_tree * payload_tree ;\n zbee_zcl_packet * zcl ;\n guint offset = 0 ;\n guint8 cmd_id ;\n gint rem_len ;\n if ( data == NULL ) return 0 ;\n zcl = ( zbee_zcl_packet * ) data ;\n cmd_id = zcl -> cmd_id ;\n if ( zcl -> direction == ZBEE_ZCL_FCF_TO_SERVER ) {\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \"%s, Seq: %u\" , val_to_str_const ( cmd_id , zbee_zcl_ota_srv_rx_cmd_names , \"Unknown Command\" ) , zcl -> tran_seqno ) ;\n proto_tree_add_item ( tree , hf_zbee_zcl_ota_srv_rx_cmd_id , tvb , offset , 1 , cmd_id ) ;\n rem_len = tvb_reported_length_remaining ( tvb , ++ offset ) ;\n if ( rem_len > 0 ) {\n payload_tree = proto_tree_add_subtree ( tree , tvb , offset , rem_len , ett_zbee_zcl_ota , NULL , \"Payload\" ) ;\n switch ( cmd_id ) {\n case ZBEE_ZCL_CMD_ID_OTA_QUERY_NEXT_IMAGE_REQ : dissect_zcl_ota_querynextimagereq ( tvb , payload_tree , & offset ) ;\n break ;\n case ZBEE_ZCL_CMD_ID_OTA_IMAGE_BLOCK_REQ : dissect_zcl_ota_imageblockreq ( tvb , payload_tree , & offset ) ;\n break ;\n case ZBEE_ZCL_CMD_ID_OTA_IMAGE_PAGE_REQ : dissect_zcl_ota_imagepagereq ( tvb , payload_tree , & offset ) ;\n break ;\n case ZBEE_ZCL_CMD_ID_OTA_UPGRADE_END_REQ : dissect_zcl_ota_upgradeendreq ( tvb , payload_tree , & offset ) ;\n break ;\n case ZBEE_ZCL_CMD_ID_OTA_QUERY_SPEC_FILE_REQ : dissect_zcl_ota_queryspecfilereq ( tvb , payload_tree , & offset ) ;\n break ;\n default : break ;\n }\n }\n }\n else {\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \"%s, Seq: %u\" , val_to_str_const ( cmd_id , zbee_zcl_ota_srv_tx_cmd_names , \"Unknown Command\" ) , zcl -> tran_seqno ) ;\n proto_tree_add_item ( tree , hf_zbee_zcl_ota_srv_tx_cmd_id , tvb , offset , 1 , cmd_id ) ;\n rem_len = tvb_reported_length_remaining ( tvb , ++ offset ) ;\n if ( rem_len > 0 ) {\n payload_tree = proto_tree_add_subtree ( tree , tvb , offset , rem_len , ett_zbee_zcl_ota , NULL , \"Payload\" ) ;\n switch ( cmd_id ) {\n case ZBEE_ZCL_CMD_ID_OTA_IMAGE_NOTIFY : dissect_zcl_ota_imagenotify ( tvb , payload_tree , & offset ) ;\n break ;\n case ZBEE_ZCL_CMD_ID_OTA_QUERY_NEXT_IMAGE_RSP : dissect_zcl_ota_querynextimagersp ( tvb , payload_tree , & offset ) ;\n break ;\n case ZBEE_ZCL_CMD_ID_OTA_IMAGE_BLOCK_RSP : dissect_zcl_ota_imageblockrsp ( tvb , payload_tree , & offset ) ;\n break ;\n case ZBEE_ZCL_CMD_ID_OTA_UPGRADE_END_RSP : dissect_zcl_ota_upgradeendrsp ( tvb , payload_tree , & offset ) ;\n break ;\n case ZBEE_ZCL_CMD_ID_OTA_QUERY_SPEC_FILE_RSP : dissect_zcl_ota_queryspecfilersp ( tvb , payload_tree , & offset ) ;\n break ;\n default : break ;\n }\n }\n }\n return tvb_captured_length ( tvb ) ;\n }", "idx": 21170}
{"hash": 8193534372312945122, "project": "debian", "size": 140, "label": 0, "functionSource": "ssize_t pcnet_receive ( NetClientState * nc , const uint8_t * buf , size_t size_ ) {\n PCNetState * s = qemu_get_nic_opaque ( nc ) ;\n int is_padr = 0 , is_bcast = 0 , is_ladr = 0 ;\n uint8_t buf1 [ 60 ] ;\n int remaining ;\n int crc_err = 0 ;\n size_t size = size_ ;\n if ( CSR_DRX ( s ) || CSR_STOP ( s ) || CSR_SPND ( s ) || ! size || ( CSR_LOOP ( s ) && ! s -> looptest ) ) {\n return - 1 ;\n }\n # ifdef PCNET_DEBUG printf ( \"pcnet_receive size=%zu\\n\" , size ) ;\n # endif if ( size < MIN_BUF_SIZE ) {\n memcpy ( buf1 , buf , size ) ;\n memset ( buf1 + size , 0 , MIN_BUF_SIZE - size ) ;\n buf = buf1 ;\n size = MIN_BUF_SIZE ;\n }\n if ( CSR_PROM ( s ) || ( is_padr = padr_match ( s , buf , size ) ) || ( is_bcast = padr_bcast ( s , buf , size ) ) || ( is_ladr = ladr_match ( s , buf , size ) ) ) {\n pcnet_rdte_poll ( s ) ;\n if ( ! ( CSR_CRST ( s ) & 0x8000 ) && s -> rdra ) {\n struct pcnet_RMD rmd ;\n int rcvrc = CSR_RCVRC ( s ) - 1 , i ;\n hwaddr nrda ;\n for ( i = CSR_RCVRL ( s ) - 1 ;\n i > 0 ;\n i -- , rcvrc -- ) {\n if ( rcvrc <= 1 ) rcvrc = CSR_RCVRL ( s ) ;\n nrda = s -> rdra + ( CSR_RCVRL ( s ) - rcvrc ) * ( BCR_SWSTYLE ( s ) ? 16 : 8 ) ;\n RMDLOAD ( & rmd , nrda ) ;\n if ( GET_FIELD ( rmd . status , RMDS , OWN ) ) {\n # ifdef PCNET_DEBUG_RMD printf ( \"pcnet - scan buffer: RCVRC=%d PREV_RCVRC=%d\\n\" , rcvrc , CSR_RCVRC ( s ) ) ;\n # endif CSR_RCVRC ( s ) = rcvrc ;\n pcnet_rdte_poll ( s ) ;\n break ;\n }\n }\n }\n if ( ! ( CSR_CRST ( s ) & 0x8000 ) ) {\n # ifdef PCNET_DEBUG_RMD printf ( \"pcnet - no buffer: RCVRC=%d\\n\" , CSR_RCVRC ( s ) ) ;\n # endif s -> csr [ 0 ] |= 0x1000 ;\n CSR_MISSC ( s ) ++ ;\n }\n else {\n uint8_t * src = s -> buffer ;\n hwaddr crda = CSR_CRDA ( s ) ;\n struct pcnet_RMD rmd ;\n int pktcount = 0 ;\n if ( ! s -> looptest ) {\n if ( size > 4092 ) {\n # ifdef PCNET_DEBUG_RMD fprintf ( stderr , \"pcnet: truncates rx packet.\\n\" ) ;\n # endif size = 4092 ;\n }\n memcpy ( src , buf , size ) ;\n src [ size ] = 0 ;\n src [ size + 1 ] = 0 ;\n src [ size + 2 ] = 0 ;\n src [ size + 3 ] = 0 ;\n size += 4 ;\n }\n else if ( s -> looptest == PCNET_LOOPTEST_CRC || ! CSR_DXMTFCS ( s ) || size < MIN_BUF_SIZE + 4 ) {\n uint32_t fcs = ~ 0 ;\n uint8_t * p = src ;\n while ( p != & src [ size ] ) CRC ( fcs , * p ++ ) ;\n * ( uint32_t * ) p = htonl ( fcs ) ;\n size += 4 ;\n }\n else {\n uint32_t fcs = ~ 0 ;\n uint8_t * p = src ;\n while ( p != & src [ size ] ) CRC ( fcs , * p ++ ) ;\n crc_err = ( * ( uint32_t * ) p != htonl ( fcs ) ) ;\n }\n # ifdef PCNET_DEBUG_MATCH PRINT_PKTHDR ( buf ) ;\n # endif RMDLOAD ( & rmd , PHYSADDR ( s , crda ) ) ;\n SET_FIELD ( & rmd . status , RMDS , STP , 1 ) ;\n # define PCNET_RECV_STORE ( ) do {\n int count = MIN ( 4096 - GET_FIELD ( rmd . buf_length , RMDL , BCNT ) , remaining ) ;\n hwaddr rbadr = PHYSADDR ( s , rmd . rbadr ) ;\n s -> phys_mem_write ( s -> dma_opaque , rbadr , src , count , CSR_BSWP ( s ) ) ;\n src += count ;\n remaining -= count ;\n SET_FIELD ( & rmd . status , RMDS , OWN , 0 ) ;\n RMDSTORE ( & rmd , PHYSADDR ( s , crda ) ) ;\n pktcount ++ ;\n \\ }\n while ( 0 ) remaining = size ;\n PCNET_RECV_STORE ( ) ;\n if ( ( remaining > 0 ) && CSR_NRDA ( s ) ) {\n hwaddr nrda = CSR_NRDA ( s ) ;\n # ifdef PCNET_DEBUG_RMD PRINT_RMD ( & rmd ) ;\n # endif RMDLOAD ( & rmd , PHYSADDR ( s , nrda ) ) ;\n if ( GET_FIELD ( rmd . status , RMDS , OWN ) ) {\n crda = nrda ;\n PCNET_RECV_STORE ( ) ;\n # ifdef PCNET_DEBUG_RMD PRINT_RMD ( & rmd ) ;\n # endif if ( ( remaining > 0 ) && ( nrda = CSR_NNRD ( s ) ) ) {\n RMDLOAD ( & rmd , PHYSADDR ( s , nrda ) ) ;\n if ( GET_FIELD ( rmd . status , RMDS , OWN ) ) {\n crda = nrda ;\n PCNET_RECV_STORE ( ) ;\n }\n }\n }\n }\n # undef PCNET_RECV_STORE RMDLOAD ( & rmd , PHYSADDR ( s , crda ) ) ;\n if ( remaining == 0 ) {\n SET_FIELD ( & rmd . msg_length , RMDM , MCNT , size ) ;\n SET_FIELD ( & rmd . status , RMDS , ENP , 1 ) ;\n SET_FIELD ( & rmd . status , RMDS , PAM , ! CSR_PROM ( s ) && is_padr ) ;\n SET_FIELD ( & rmd . status , RMDS , LFAM , ! CSR_PROM ( s ) && is_ladr ) ;\n SET_FIELD ( & rmd . status , RMDS , BAM , ! CSR_PROM ( s ) && is_bcast ) ;\n if ( crc_err ) {\n SET_FIELD ( & rmd . status , RMDS , CRC , 1 ) ;\n SET_FIELD ( & rmd . status , RMDS , ERR , 1 ) ;\n }\n }\n else {\n SET_FIELD ( & rmd . status , RMDS , OFLO , 1 ) ;\n SET_FIELD ( & rmd . status , RMDS , BUFF , 1 ) ;\n SET_FIELD ( & rmd . status , RMDS , ERR , 1 ) ;\n }\n RMDSTORE ( & rmd , PHYSADDR ( s , crda ) ) ;\n s -> csr [ 0 ] |= 0x0400 ;\n # ifdef PCNET_DEBUG printf ( \"RCVRC=%d CRDA=0x%08x BLKS=%d\\n\" , CSR_RCVRC ( s ) , PHYSADDR ( s , CSR_CRDA ( s ) ) , pktcount ) ;\n # endif # ifdef PCNET_DEBUG_RMD PRINT_RMD ( & rmd ) ;\n # endif while ( pktcount -- ) {\n if ( CSR_RCVRC ( s ) <= 1 ) {\n CSR_RCVRC ( s ) = CSR_RCVRL ( s ) ;\n }\n else {\n CSR_RCVRC ( s ) -- ;\n }\n }\n pcnet_rdte_poll ( s ) ;\n }\n }\n pcnet_poll ( s ) ;\n pcnet_update_irq ( s ) ;\n return size_ ;\n }", "idx": 21171}
{"hash": -5018199117312371093, "project": "chrome", "size": 262, "label": 0, "functionSource": "int y4m_input_open ( y4m_input * _y4m , FILE * _fin , char * _skip , int _nskip , int only_420 ) {\n char buffer [ 80 ] = {\n 0 }\n ;\n int ret ;\n int i ;\n for ( i = 0 ;\n i < 79 ;\n i ++ ) {\n if ( _nskip > 0 ) {\n buffer [ i ] = * _skip ++ ;\n _nskip -- ;\n }\n else {\n if ( ! file_read ( buffer + i , 1 , _fin ) ) return - 1 ;\n }\n if ( buffer [ i ] == '\\n' ) break ;\n }\n if ( _nskip > 0 ) return - 1 ;\n if ( i == 79 ) {\n fprintf ( stderr , \"Error parsing header;\n not a YUV2MPEG2 file?\\n\" ) ;\n return - 1 ;\n }\n buffer [ i ] = '\\0' ;\n if ( memcmp ( buffer , \"YUV4MPEG\" , 8 ) ) {\n fprintf ( stderr , \"Incomplete magic for YUV4MPEG file.\\n\" ) ;\n return - 1 ;\n }\n if ( buffer [ 8 ] != '2' ) {\n fprintf ( stderr , \"Incorrect YUV input file version;\n YUV4MPEG2 required.\\n\" ) ;\n }\n ret = y4m_parse_tags ( _y4m , buffer + 5 ) ;\n if ( ret < 0 ) {\n fprintf ( stderr , \"Error parsing YUV4MPEG2 header.\\n\" ) ;\n return ret ;\n }\n if ( _y4m -> interlace == '?' ) {\n fprintf ( stderr , \"Warning: Input video interlacing format unknown;\n \" \"assuming progressive scan.\\n\" ) ;\n }\n else if ( _y4m -> interlace != 'p' ) {\n fprintf ( stderr , \"Input video is interlaced;\n \" \"Only progressive scan handled.\\n\" ) ;\n return - 1 ;\n }\n _y4m -> vpx_fmt = VPX_IMG_FMT_I420 ;\n _y4m -> bps = 12 ;\n _y4m -> bit_depth = 8 ;\n if ( strcmp ( _y4m -> chroma_type , \"420\" ) == 0 || strcmp ( _y4m -> chroma_type , \"420jpeg\" ) == 0 ) {\n _y4m -> src_c_dec_h = _y4m -> dst_c_dec_h = _y4m -> src_c_dec_v = _y4m -> dst_c_dec_v = 2 ;\n _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h + 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * ( ( _y4m -> pic_h + 1 ) / 2 ) ;\n _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ;\n _y4m -> convert = y4m_convert_null ;\n }\n else if ( strcmp ( _y4m -> chroma_type , \"420p10\" ) == 0 ) {\n _y4m -> src_c_dec_h = 2 ;\n _y4m -> dst_c_dec_h = 2 ;\n _y4m -> src_c_dec_v = 2 ;\n _y4m -> dst_c_dec_v = 2 ;\n _y4m -> dst_buf_read_sz = 2 * ( _y4m -> pic_w * _y4m -> pic_h + * ( ( _y4m -> pic_w + 1 ) / 2 ) * ( ( _y4m -> pic_h + 1 ) / 2 ) ) ;\n _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ;\n _y4m -> convert = y4m_convert_null ;\n _y4m -> bit_depth = 10 ;\n _y4m -> bps = 15 ;\n _y4m -> vpx_fmt = VPX_IMG_FMT_I42016 ;\n if ( only_420 ) {\n fprintf ( stderr , \"Unsupported conversion from 420p10 to 420jpeg\\n\" ) ;\n return - 1 ;\n }\n }\n else if ( strcmp ( _y4m -> chroma_type , \"420p12\" ) == 0 ) {\n _y4m -> src_c_dec_h = 2 ;\n _y4m -> dst_c_dec_h = 2 ;\n _y4m -> src_c_dec_v = 2 ;\n _y4m -> dst_c_dec_v = 2 ;\n _y4m -> dst_buf_read_sz = 2 * ( _y4m -> pic_w * _y4m -> pic_h + * ( ( _y4m -> pic_w + 1 ) / 2 ) * ( ( _y4m -> pic_h + 1 ) / 2 ) ) ;\n _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ;\n _y4m -> convert = y4m_convert_null ;\n _y4m -> bit_depth = 12 ;\n _y4m -> bps = 18 ;\n _y4m -> vpx_fmt = VPX_IMG_FMT_I42016 ;\n if ( only_420 ) {\n fprintf ( stderr , \"Unsupported conversion from 420p12 to 420jpeg\\n\" ) ;\n return - 1 ;\n }\n }\n else if ( strcmp ( _y4m -> chroma_type , \"420mpeg2\" ) == 0 ) {\n _y4m -> src_c_dec_h = _y4m -> dst_c_dec_h = _y4m -> src_c_dec_v = _y4m -> dst_c_dec_v = 2 ;\n _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ;\n _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = * ( ( _y4m -> pic_w + 1 ) / 2 ) * ( ( _y4m -> pic_h + 1 ) / 2 ) ;\n _y4m -> convert = y4m_convert_42xmpeg2_42xjpeg ;\n }\n else if ( strcmp ( _y4m -> chroma_type , \"420paldv\" ) == 0 ) {\n _y4m -> src_c_dec_h = _y4m -> dst_c_dec_h = _y4m -> src_c_dec_v = _y4m -> dst_c_dec_v = 2 ;\n _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ;\n _y4m -> aux_buf_sz = 3 * ( ( _y4m -> pic_w + 1 ) / 2 ) * ( ( _y4m -> pic_h + 1 ) / 2 ) ;\n _y4m -> aux_buf_read_sz = 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * ( ( _y4m -> pic_h + 1 ) / 2 ) ;\n _y4m -> convert = y4m_convert_42xpaldv_42xjpeg ;\n }\n else if ( strcmp ( _y4m -> chroma_type , \"422jpeg\" ) == 0 ) {\n _y4m -> src_c_dec_h = _y4m -> dst_c_dec_h = 2 ;\n _y4m -> src_c_dec_v = 1 ;\n _y4m -> dst_c_dec_v = 2 ;\n _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ;\n _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ;\n _y4m -> convert = y4m_convert_422jpeg_420jpeg ;\n }\n else if ( strcmp ( _y4m -> chroma_type , \"422\" ) == 0 ) {\n _y4m -> src_c_dec_h = 2 ;\n _y4m -> src_c_dec_v = 1 ;\n if ( only_420 ) {\n _y4m -> dst_c_dec_h = 2 ;\n _y4m -> dst_c_dec_v = 2 ;\n _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ;\n _y4m -> aux_buf_read_sz = 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ;\n _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz + ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ;\n _y4m -> convert = y4m_convert_422_420jpeg ;\n }\n else {\n _y4m -> vpx_fmt = VPX_IMG_FMT_I422 ;\n _y4m -> bps = 16 ;\n _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ;\n _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ;\n _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h + 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ;\n _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ;\n _y4m -> convert = y4m_convert_null ;\n }\n }\n else if ( strcmp ( _y4m -> chroma_type , \"422p10\" ) == 0 ) {\n _y4m -> src_c_dec_h = 2 ;\n _y4m -> src_c_dec_v = 1 ;\n _y4m -> vpx_fmt = VPX_IMG_FMT_I42216 ;\n _y4m -> bps = 20 ;\n _y4m -> bit_depth = 10 ;\n _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ;\n _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ;\n _y4m -> dst_buf_read_sz = 2 * ( _y4m -> pic_w * _y4m -> pic_h + * ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ) ;\n _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ;\n _y4m -> convert = y4m_convert_null ;\n if ( only_420 ) {\n fprintf ( stderr , \"Unsupported conversion from 422p10 to 420jpeg\\n\" ) ;\n return - 1 ;\n }\n }\n else if ( strcmp ( _y4m -> chroma_type , \"422p12\" ) == 0 ) {\n _y4m -> src_c_dec_h = 2 ;\n _y4m -> src_c_dec_v = 1 ;\n _y4m -> vpx_fmt = VPX_IMG_FMT_I42216 ;\n _y4m -> bps = 24 ;\n _y4m -> bit_depth = 12 ;\n _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ;\n _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ;\n _y4m -> dst_buf_read_sz = 2 * ( _y4m -> pic_w * _y4m -> pic_h + * ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ) ;\n _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ;\n _y4m -> convert = y4m_convert_null ;\n if ( only_420 ) {\n fprintf ( stderr , \"Unsupported conversion from 422p12 to 420jpeg\\n\" ) ;\n return - 1 ;\n }\n }\n else if ( strcmp ( _y4m -> chroma_type , \"411\" ) == 0 ) {\n _y4m -> src_c_dec_h = 4 ;\n _y4m -> dst_c_dec_h = 2 ;\n _y4m -> src_c_dec_v = 1 ;\n _y4m -> dst_c_dec_v = 2 ;\n _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ;\n _y4m -> aux_buf_read_sz = 2 * ( ( _y4m -> pic_w + 3 ) / 4 ) * _y4m -> pic_h ;\n _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz + ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ;\n _y4m -> convert = y4m_convert_411_420jpeg ;\n }\n else if ( strcmp ( _y4m -> chroma_type , \"444\" ) == 0 ) {\n _y4m -> src_c_dec_h = 1 ;\n _y4m -> src_c_dec_v = 1 ;\n if ( only_420 ) {\n _y4m -> dst_c_dec_h = 2 ;\n _y4m -> dst_c_dec_v = 2 ;\n _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ;\n _y4m -> aux_buf_read_sz = 2 * _y4m -> pic_w * _y4m -> pic_h ;\n _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz + ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ;\n _y4m -> convert = y4m_convert_444_420jpeg ;\n }\n else {\n _y4m -> vpx_fmt = VPX_IMG_FMT_I444 ;\n _y4m -> bps = 24 ;\n _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ;\n _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ;\n _y4m -> dst_buf_read_sz = 3 * _y4m -> pic_w * _y4m -> pic_h ;\n _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ;\n _y4m -> convert = y4m_convert_null ;\n }\n }\n else if ( strcmp ( _y4m -> chroma_type , \"444p10\" ) == 0 ) {\n _y4m -> src_c_dec_h = 1 ;\n _y4m -> src_c_dec_v = 1 ;\n _y4m -> vpx_fmt = VPX_IMG_FMT_I44416 ;\n _y4m -> bps = 30 ;\n _y4m -> bit_depth = 10 ;\n _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ;\n _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ;\n _y4m -> dst_buf_read_sz = 2 * 3 * _y4m -> pic_w * _y4m -> pic_h ;\n _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ;\n _y4m -> convert = y4m_convert_null ;\n if ( only_420 ) {\n fprintf ( stderr , \"Unsupported conversion from 444p10 to 420jpeg\\n\" ) ;\n return - 1 ;\n }\n }\n else if ( strcmp ( _y4m -> chroma_type , \"444p12\" ) == 0 ) {\n _y4m -> src_c_dec_h = 1 ;\n _y4m -> src_c_dec_v = 1 ;\n _y4m -> vpx_fmt = VPX_IMG_FMT_I44416 ;\n _y4m -> bps = 36 ;\n _y4m -> bit_depth = 12 ;\n _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ;\n _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ;\n _y4m -> dst_buf_read_sz = 2 * 3 * _y4m -> pic_w * _y4m -> pic_h ;\n _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ;\n _y4m -> convert = y4m_convert_null ;\n if ( only_420 ) {\n fprintf ( stderr , \"Unsupported conversion from 444p12 to 420jpeg\\n\" ) ;\n return - 1 ;\n }\n }\n else if ( strcmp ( _y4m -> chroma_type , \"444alpha\" ) == 0 ) {\n _y4m -> src_c_dec_h = 1 ;\n _y4m -> src_c_dec_v = 1 ;\n if ( only_420 ) {\n _y4m -> dst_c_dec_h = 2 ;\n _y4m -> dst_c_dec_v = 2 ;\n _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ;\n _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 3 * _y4m -> pic_w * _y4m -> pic_h ;\n _y4m -> convert = y4m_convert_444_420jpeg ;\n }\n else {\n _y4m -> vpx_fmt = VPX_IMG_FMT_444A ;\n _y4m -> bps = 32 ;\n _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ;\n _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ;\n _y4m -> dst_buf_read_sz = 4 * _y4m -> pic_w * _y4m -> pic_h ;\n _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ;\n _y4m -> convert = y4m_convert_null ;\n }\n }\n else if ( strcmp ( _y4m -> chroma_type , \"mono\" ) == 0 ) {\n _y4m -> src_c_dec_h = _y4m -> src_c_dec_v = 0 ;\n _y4m -> dst_c_dec_h = _y4m -> dst_c_dec_v = 2 ;\n _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ;\n _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ;\n _y4m -> convert = y4m_convert_mono_420jpeg ;\n }\n else {\n fprintf ( stderr , \"Unknown chroma sampling type: %s\\n\" , _y4m -> chroma_type ) ;\n return - 1 ;\n }\n _y4m -> dst_buf_sz = _y4m -> pic_w * _y4m -> pic_h + 2 * ( ( _y4m -> pic_w + _y4m -> dst_c_dec_h - 1 ) / _y4m -> dst_c_dec_h ) * ( ( _y4m -> pic_h + _y4m -> dst_c_dec_v - 1 ) / _y4m -> dst_c_dec_v ) ;\n if ( _y4m -> bit_depth == 8 ) _y4m -> dst_buf = ( unsigned char * ) malloc ( _y4m -> dst_buf_sz ) ;\n else _y4m -> dst_buf = ( unsigned char * ) malloc ( 2 * _y4m -> dst_buf_sz ) ;\n if ( _y4m -> aux_buf_sz > 0 ) _y4m -> aux_buf = ( unsigned char * ) malloc ( _y4m -> aux_buf_sz ) ;\n return 0 ;\n }", "idx": 21172}
{"hash": -4765077557530511796, "project": "chrome", "size": 34, "label": 1, "functionSource": "static int ogg_read_header ( AVFormatContext * s ) {\n struct ogg * ogg = s -> priv_data ;\n int ret , i ;\n ogg -> curidx = - 1 ;\n do {\n ret = ogg_packet ( s , NULL , NULL , NULL , NULL ) ;\n if ( ret < 0 ) {\n ogg_read_close ( s ) ;\n return ret ;\n }\n }\n while ( ! ogg -> headers ) ;\n av_log ( s , AV_LOG_TRACE , \"found headers\\n\" ) ;\n for ( i = 0 ;\n i < ogg -> nstreams ;\n i ++ ) {\n struct ogg_stream * os = ogg -> streams + i ;\n if ( ogg -> streams [ i ] . header < 0 ) {\n av_log ( s , AV_LOG_ERROR , \"Header parsing failed for stream %d\\n\" , i ) ;\n ogg -> streams [ i ] . codec = NULL ;\n }\n else if ( os -> codec && os -> nb_header < os -> codec -> nb_header ) {\n av_log ( s , AV_LOG_WARNING , \"Headers mismatch for stream %d: \" \"expected %d received %d.\\n\" , i , os -> codec -> nb_header , os -> nb_header ) ;\n if ( s -> error_recognition & AV_EF_EXPLODE ) return AVERROR_INVALIDDATA ;\n }\n if ( os -> start_granule != OGG_NOGRANULE_VALUE ) os -> lastpts = s -> streams [ i ] -> start_time = ogg_gptopts ( s , i , os -> start_granule , NULL ) ;\n }\n ret = ogg_get_length ( s ) ;\n if ( ret < 0 ) {\n ogg_read_close ( s ) ;\n return ret ;\n }\n return 0 ;\n }", "idx": 21173}
{"hash": -3502382902740740634, "project": "debian", "size": 19, "label": 0, "functionSource": "static const char * unsigned64_avp ( diam_ctx_t * c , diam_avp_t * a , tvbuff_t * tvb , diam_sub_dis_t * diam_sub_dis_inf _U_ ) {\n char * label = NULL ;\n proto_item * pi ;\n gint length = tvb_reported_length ( tvb ) ;\n if ( length == 8 ) {\n if ( c -> tree ) {\n pi = proto_tree_add_item ( c -> tree , a -> hf_value , tvb , 0 , length , ENC_BIG_ENDIAN ) ;\n label = ( char * ) wmem_alloc ( wmem_packet_scope ( ) , ITEM_LABEL_LENGTH + 1 ) ;\n proto_item_fill_label ( PITEM_FINFO ( pi ) , label ) ;\n label = strstr ( label , \": \" ) + 2 ;\n }\n }\n else {\n pi = proto_tree_add_bytes_format ( c -> tree , hf_diameter_avp_data_wrong_length , tvb , 0 , length , NULL , \"Error! Bad Unsigned64 Length\" ) ;\n expert_add_info_format ( c -> pinfo , pi , & ei_diameter_avp_len , \"Bad Unsigned64 Length (%u)\" , length ) ;\n PROTO_ITEM_SET_GENERATED ( pi ) ;\n }\n return label ;\n }", "idx": 21174}
{"hash": 7651945086108393719, "project": "debian", "size": 20, "label": 0, "functionSource": "int qemuMonitorJSONGetBlockIoThrottle ( qemuMonitorPtr mon , const char * device , virDomainBlockIoTuneInfoPtr reply ) {\n int ret = - 1 ;\n virJSONValuePtr cmd = NULL ;\n virJSONValuePtr result = NULL ;\n cmd = qemuMonitorJSONMakeCommand ( \"query-block\" , NULL ) ;\n if ( ! cmd ) {\n return - 1 ;\n }\n ret = qemuMonitorJSONCommand ( mon , cmd , & result ) ;\n if ( ret == 0 && virJSONValueObjectHasKey ( result , \"error\" ) ) {\n if ( qemuMonitorJSONHasError ( result , \"DeviceNotActive\" ) ) qemuReportError ( VIR_ERR_OPERATION_INVALID , _ ( \"No active operation on device: %s\" ) , device ) ;\n else if ( qemuMonitorJSONHasError ( result , \"NotSupported\" ) ) qemuReportError ( VIR_ERR_OPERATION_INVALID , _ ( \"Operation is not supported for device: %s\" ) , device ) ;\n else qemuReportError ( VIR_ERR_INTERNAL_ERROR , \"%s\" , _ ( \"Unexpected error\" ) ) ;\n ret = - 1 ;\n }\n if ( ret == 0 ) ret = qemuMonitorJSONBlockIoThrottleInfo ( result , device , reply ) ;\n virJSONValueFree ( cmd ) ;\n virJSONValueFree ( result ) ;\n return ret ;\n }", "idx": 21175}
{"hash": -1315695702746584250, "project": "debian", "size": 7, "label": 0, "functionSource": "GPtrArray * proto_find_finfo ( proto_tree * tree , const int id ) {\n ffdata_t ffdata ;\n ffdata . array = g_ptr_array_new ( ) ;\n ffdata . id = id ;\n proto_tree_traverse_pre_order ( tree , find_finfo , & ffdata ) ;\n return ffdata . array ;\n }", "idx": 21176}
{"hash": 927123821003322045, "project": "chrome", "size": 14, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( PageLoadMetricsBrowserTest , PaintInMultipleChildFrames ) {\n ASSERT_TRUE ( embedded_test_server ( ) -> Start ( ) ) ;\n GURL a_url ( embedded_test_server ( ) -> GetURL ( \"/page_load_metrics/iframes.html\" ) ) ;\n auto waiter = CreatePageLoadMetricsWaiter ( ) ;\n waiter -> AddPageExpectation ( TimingField : : FIRST_LAYOUT ) ;\n waiter -> AddPageExpectation ( TimingField : : LOAD_EVENT ) ;\n waiter -> AddSubFrameExpectation ( TimingField : : FIRST_PAINT ) ;\n waiter -> AddSubFrameExpectation ( TimingField : : FIRST_CONTENTFUL_PAINT ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , a_url ) ;\n waiter -> Wait ( ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHistogramFirstLayout , 1 ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHistogramLoad , 1 ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHistogramFirstPaint , 1 ) ;\n }", "idx": 21177}
{"hash": -4960438251319819237, "project": "chrome", "size": 11, "label": 0, "functionSource": "static double get_sr_decay_rate ( const VP9_COMMON * cm , const FIRSTPASS_STATS * frame ) {\n double sr_diff = ( frame -> sr_coded_error - frame -> coded_error ) / cm -> MBs ;\n double sr_decay = 1.0 ;\n const double motion_amplitude_factor = frame -> pcnt_motion * ( ( frame -> mvc_abs + frame -> mvr_abs ) / 2 ) ;\n const double pcnt_intra = 100 * ( 1.0 - frame -> pcnt_inter ) ;\n if ( ( sr_diff > LOW_SR_DIFF_TRHESH ) ) {\n sr_diff = MIN ( sr_diff , SR_DIFF_MAX ) ;\n sr_decay = 1.0 - ( SR_DIFF_PART * sr_diff ) - ( MOTION_AMP_PART * motion_amplitude_factor ) - ( INTRA_PART * pcnt_intra ) ;\n }\n return MAX ( sr_decay , MIN ( DEFAULT_DECAY_LIMIT , frame -> pcnt_inter ) ) ;\n }", "idx": 21178}
{"hash": -8562387810778703674, "project": "chrome", "size": 4, "label": 0, "functionSource": "void hb_font_funcs_make_immutable ( hb_font_funcs_t * ffuncs ) {\n if ( unlikely ( hb_object_is_inert ( ffuncs ) ) ) return ;\n ffuncs -> immutable = true ;\n }", "idx": 21179}
{"hash": 7399683071036018868, "project": "debian", "size": 21, "label": 0, "functionSource": "void pdo_stmt_init ( TSRMLS_D ) {\n zend_class_entry ce ;\n INIT_CLASS_ENTRY ( ce , \"PDOStatement\" , pdo_dbstmt_functions ) ;\n pdo_dbstmt_ce = zend_register_internal_class ( & ce TSRMLS_CC ) ;\n pdo_dbstmt_ce -> get_iterator = pdo_stmt_iter_get ;\n pdo_dbstmt_ce -> create_object = pdo_dbstmt_new ;\n zend_class_implements ( pdo_dbstmt_ce TSRMLS_CC , 1 , zend_ce_traversable ) ;\n zend_declare_property_null ( pdo_dbstmt_ce , \"queryString\" , sizeof ( \"queryString\" ) - 1 , ZEND_ACC_PUBLIC TSRMLS_CC ) ;\n memcpy ( & pdo_dbstmt_object_handlers , & std_object_handlers , sizeof ( zend_object_handlers ) ) ;\n pdo_dbstmt_object_handlers . write_property = dbstmt_prop_write ;\n pdo_dbstmt_object_handlers . unset_property = dbstmt_prop_delete ;\n pdo_dbstmt_object_handlers . get_method = dbstmt_method_get ;\n pdo_dbstmt_object_handlers . compare_objects = dbstmt_compare ;\n pdo_dbstmt_object_handlers . clone_obj = dbstmt_clone_obj ;\n INIT_CLASS_ENTRY ( ce , \"PDORow\" , pdo_row_functions ) ;\n pdo_row_ce = zend_register_internal_class ( & ce TSRMLS_CC ) ;\n pdo_row_ce -> ce_flags |= ZEND_ACC_FINAL_CLASS ;\n pdo_row_ce -> create_object = pdo_row_new ;\n pdo_row_ce -> serialize = pdo_row_serialize ;\n pdo_row_ce -> unserialize = zend_class_unserialize_deny ;\n }", "idx": 21180}
{"hash": -3299391226809811274, "project": "debian", "size": 14, "label": 0, "functionSource": "int qemuAgentFSThaw ( qemuAgentPtr mon ) {\n int ret = - 1 ;\n virJSONValuePtr cmd ;\n virJSONValuePtr reply = NULL ;\n cmd = qemuAgentMakeCommand ( \"guest-fsfreeze-thaw\" , NULL ) ;\n if ( ! cmd ) return - 1 ;\n if ( qemuAgentCommand ( mon , cmd , & reply , true , VIR_DOMAIN_QEMU_AGENT_COMMAND_BLOCK ) < 0 ) goto cleanup ;\n if ( virJSONValueObjectGetNumberInt ( reply , \"return\" , & ret ) < 0 ) {\n virReportError ( VIR_ERR_INTERNAL_ERROR , \"%s\" , _ ( \"malformed return value\" ) ) ;\n }\n cleanup : virJSONValueFree ( cmd ) ;\n virJSONValueFree ( reply ) ;\n return ret ;\n }", "idx": 21181}
{"hash": -1929262071302712016, "project": "debian", "size": 39, "label": 0, "functionSource": "static cmsBool Type_Text_Description_Write ( struct _cms_typehandler_struct * self , cmsIOHANDLER * io , void * Ptr , cmsUInt32Number nItems ) {\n cmsMLU * mlu = ( cmsMLU * ) Ptr ;\n char * Text = NULL ;\n wchar_t * Wide = NULL ;\n cmsUInt32Number len , len_text , len_tag_requirement , len_aligned ;\n cmsBool rc = FALSE ;\n char Filler [ 68 ] ;\n memset ( Filler , 0 , sizeof ( Filler ) ) ;\n len = cmsMLUgetASCII ( mlu , cmsNoLanguage , cmsNoCountry , NULL , 0 ) ;\n if ( len <= 0 ) {\n Text = ( char * ) _cmsDupMem ( self -> ContextID , \"\" , sizeof ( char ) ) ;\n Wide = ( wchar_t * ) _cmsDupMem ( self -> ContextID , L\"\" , sizeof ( wchar_t ) ) ;\n }\n else {\n Text = ( char * ) _cmsCalloc ( self -> ContextID , len , sizeof ( char ) ) ;\n if ( Text == NULL ) goto Error ;\n Wide = ( wchar_t * ) _cmsCalloc ( self -> ContextID , len , sizeof ( wchar_t ) ) ;\n if ( Wide == NULL ) goto Error ;\n cmsMLUgetASCII ( mlu , cmsNoLanguage , cmsNoCountry , Text , len * sizeof ( char ) ) ;\n cmsMLUgetWide ( mlu , cmsNoLanguage , cmsNoCountry , Wide , len * sizeof ( wchar_t ) ) ;\n }\n len_text = ( cmsUInt32Number ) strlen ( Text ) + 1 ;\n len_tag_requirement = ( 8 + 4 + len_text + 4 + 4 + 2 * len_text + 2 + 1 + 67 ) ;\n len_aligned = _cmsALIGNLONG ( len_tag_requirement ) ;\n if ( ! _cmsWriteUInt32Number ( io , len_text ) ) goto Error ;\n if ( ! io -> Write ( io , len_text , Text ) ) goto Error ;\n if ( ! _cmsWriteUInt32Number ( io , 0 ) ) goto Error ;\n if ( ! _cmsWriteUInt32Number ( io , len_text ) ) goto Error ;\n if ( ! _cmsWriteWCharArray ( io , len_text , Wide ) ) goto Error ;\n if ( ! _cmsWriteUInt16Number ( io , 0 ) ) goto Error ;\n if ( ! _cmsWriteUInt8Number ( io , 0 ) ) goto Error ;\n if ( ! io -> Write ( io , 67 , Filler ) ) goto Error ;\n if ( len_aligned - len_tag_requirement > 0 ) if ( ! io -> Write ( io , len_aligned - len_tag_requirement , Filler ) ) goto Error ;\n rc = TRUE ;\n Error : if ( Text ) _cmsFree ( self -> ContextID , Text ) ;\n if ( Wide ) _cmsFree ( self -> ContextID , Wide ) ;\n return rc ;\n cmsUNUSED_PARAMETER ( nItems ) ;\n }", "idx": 21182}
{"hash": 7424930167238097621, "project": "debian", "size": 8, "label": 0, "functionSource": "static struct async * async_getpending ( struct usb_dev_state * ps , void __user * userurb ) {\n struct async * as ;\n list_for_each_entry ( as , & ps -> async_pending , asynclist ) if ( as -> userurb == userurb ) {\n list_del_init ( & as -> asynclist ) ;\n return as ;\n }\n return NULL ;\n }", "idx": 21183}
{"hash": -4719501675862910941, "project": "debian", "size": 3, "label": 0, "functionSource": "static void reset_h245_pi ( void * dummy _U_ ) {\n h245_pi = NULL ;\n }", "idx": 21184}
{"hash": -2931981263594364686, "project": "debian", "size": 11, "label": 0, "functionSource": "static void update_offset_hash_table_from_kb ( OffsetHashTable tbl , KBNODE node , off_t off ) {\n for ( ;\n node ;\n node = node -> next ) {\n if ( node -> pkt -> pkttype == PKT_PUBLIC_KEY || node -> pkt -> pkttype == PKT_PUBLIC_SUBKEY ) {\n u32 aki [ 2 ] ;\n keyid_from_pk ( node -> pkt -> pkt . public_key , aki ) ;\n update_offset_hash_table ( tbl , aki , off ) ;\n }\n }\n }", "idx": 21185}
{"hash": 8572106347813672436, "project": "debian", "size": 8, "label": 0, "functionSource": "static inline int pfkey_mode_from_xfrm ( int mode ) {\n switch ( mode ) {\n case XFRM_MODE_TRANSPORT : return IPSEC_MODE_TRANSPORT ;\n case XFRM_MODE_TUNNEL : return IPSEC_MODE_TUNNEL ;\n case XFRM_MODE_BEET : return IPSEC_MODE_BEET ;\n default : return - 1 ;\n }\n }", "idx": 21186}
{"hash": -1102844685921778700, "project": "debian", "size": 25, "label": 0, "functionSource": "static int best_effort_strncat_to_utf16 ( struct archive_string * as16 , const void * _p , size_t length , struct archive_string_conv * sc , int bigendian ) {\n const char * s = ( const char * ) _p ;\n char * utf16 ;\n size_t remaining ;\n int ret ;\n ( void ) sc ;\n ret = 0 ;\n remaining = length ;\n if ( archive_string_ensure ( as16 , as16 -> length + ( length + 1 ) * 2 ) == NULL ) return ( - 1 ) ;\n utf16 = as16 -> s + as16 -> length ;\n while ( remaining -- ) {\n unsigned c = * s ++ ;\n if ( c > 127 ) {\n c = UNICODE_R_CHAR ;\n ret = - 1 ;\n }\n if ( bigendian ) archive_be16enc ( utf16 , c ) ;\n else archive_le16enc ( utf16 , c ) ;\n utf16 += 2 ;\n }\n as16 -> length = utf16 - as16 -> s ;\n as16 -> s [ as16 -> length ] = 0 ;\n as16 -> s [ as16 -> length + 1 ] = 0 ;\n return ( ret ) ;\n }", "idx": 21187}
{"hash": -5315423743066773158, "project": "debian", "size": 13, "label": 0, "functionSource": "void message_decoder_deinit ( struct message_decoder_context * * _ctx ) {\n struct message_decoder_context * ctx = * _ctx ;\n * _ctx = NULL ;\n if ( ctx -> charset_trans != NULL ) charset_to_utf8_end ( & ctx -> charset_trans ) ;\n if ( ctx -> qp != NULL ) qp_decoder_deinit ( & ctx -> qp ) ;\n buffer_free ( & ctx -> encoding_buf ) ;\n buffer_free ( & ctx -> buf ) ;\n buffer_free ( & ctx -> buf2 ) ;\n i_free ( ctx -> charset_trans_charset ) ;\n i_free ( ctx -> content_type ) ;\n i_free ( ctx -> content_charset ) ;\n i_free ( ctx ) ;\n }", "idx": 21188}
{"hash": 373200843854506734, "project": "chrome", "size": 76, "label": 0, "functionSource": "static UBool generateFromUTable ( CnvExtData * extData , UCMTable * table , int32_t start , int32_t limit , int32_t unitIndex , uint32_t defaultValue ) {\n UCMapping * mappings , * m ;\n int32_t * map ;\n int32_t i , j , uniqueCount , count , subStart , subLimit ;\n UChar * uchars ;\n UChar32 low , high , prev ;\n UChar * sectionUChars ;\n uint32_t * sectionValues ;\n mappings = table -> mappings ;\n map = table -> reverseMap ;\n m = mappings + map [ start ] ;\n uchars = ( UChar * ) UCM_GET_CODE_POINTS ( table , m ) ;\n low = uchars [ unitIndex ] ;\n uniqueCount = 1 ;\n prev = high = low ;\n for ( i = start + 1 ;\n i < limit ;\n ++ i ) {\n m = mappings + map [ i ] ;\n uchars = ( UChar * ) UCM_GET_CODE_POINTS ( table , m ) ;\n high = uchars [ unitIndex ] ;\n if ( high != prev ) {\n prev = high ;\n ++ uniqueCount ;\n }\n }\n count = uniqueCount ;\n sectionUChars = ( UChar * ) utm_allocN ( extData -> fromUTableUChars , 1 + count ) ;\n sectionValues = ( uint32_t * ) utm_allocN ( extData -> fromUTableValues , 1 + count ) ;\n * sectionUChars ++ = ( UChar ) count ;\n * sectionValues ++ = defaultValue ;\n prev = low - 1 ;\n j = 0 ;\n for ( i = start ;\n i < limit ;\n ++ i ) {\n m = mappings + map [ i ] ;\n uchars = ( UChar * ) UCM_GET_CODE_POINTS ( table , m ) ;\n high = uchars [ unitIndex ] ;\n if ( high != prev ) {\n prev = high ;\n sectionUChars [ j ] = ( UChar ) high ;\n sectionValues [ j ] = ( uint32_t ) i ;\n ++ j ;\n }\n }\n subLimit = ( int32_t ) ( sectionValues [ 0 ] ) ;\n for ( j = 0 ;\n j < count ;\n ++ j ) {\n subStart = subLimit ;\n subLimit = ( j + 1 ) < count ? ( int32_t ) ( sectionValues [ j + 1 ] ) : limit ;\n defaultValue = 0 ;\n m = mappings + map [ subStart ] ;\n if ( m -> uLen == unitIndex + 1 ) {\n ++ subStart ;\n if ( subStart < subLimit && mappings [ map [ subStart ] ] . uLen == unitIndex + 1 ) {\n fprintf ( stderr , \"error: multiple mappings from same Unicode code points\\n\" ) ;\n ucm_printMapping ( table , m , stderr ) ;\n ucm_printMapping ( table , mappings + map [ subStart ] , stderr ) ;\n return FALSE ;\n }\n defaultValue = getFromUBytesValue ( extData , table , m ) ;\n }\n if ( subStart == subLimit ) {\n sectionValues [ j ] = defaultValue ;\n }\n else {\n sectionValues [ j ] = ( uint32_t ) utm_countItems ( extData -> fromUTableValues ) ;\n if ( ! generateFromUTable ( extData , table , subStart , subLimit , unitIndex + 1 , defaultValue ) ) {\n return FALSE ;\n }\n }\n }\n return TRUE ;\n }", "idx": 21189}
{"hash": 1274314752608585941, "project": "chrome", "size": 27, "label": 1, "functionSource": "IN_PROC_BROWSER_TEST_F ( SingleClientSessionsSyncTest , TimestampMatchesHistory ) {\n ASSERT_TRUE ( SetupSync ( ) ) << \"SetupSync() failed.\" ;\n ASSERT_TRUE ( CheckInitialState ( 0 ) ) ;\n const GURL url ( \"about:version\" ) ;\n ScopedWindowMap windows ;\n ASSERT_TRUE ( OpenTabAndGetLocalWindows ( 0 , url , windows . GetMutable ( ) ) ) ;\n int found_navigations = 0 ;\n for ( SessionWindowMap : : const_iterator it = windows . Get ( ) -> begin ( ) ;\n it != windows . Get ( ) -> end ( ) ;\n ++ it ) {\n for ( std : : vector < sessions : : SessionTab * > : : const_iterator it2 = it -> second -> tabs . begin ( ) ;\n it2 != it -> second -> tabs . end ( ) ;\n ++ it2 ) {\n for ( std : : vector < sessions : : SerializedNavigationEntry > : : const_iterator it3 = ( * it2 ) -> navigations . begin ( ) ;\n it3 != ( * it2 ) -> navigations . end ( ) ;\n ++ it3 ) {\n const base : : Time timestamp = it3 -> timestamp ( ) ;\n history : : URLRow virtual_row ;\n ASSERT_TRUE ( GetUrlFromClient ( 0 , it3 -> virtual_url ( ) , & virtual_row ) ) ;\n const base : : Time history_timestamp = virtual_row . last_visit ( ) ;\n ASSERT_EQ ( timestamp , history_timestamp ) ;\n ++ found_navigations ;\n }\n }\n }\n ASSERT_EQ ( 1 , found_navigations ) ;\n }", "idx": 21190}
{"hash": -7237039260294671485, "project": "debian", "size": 3, "label": 0, "functionSource": "static int dissect_nlm3_shareres ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , void * data _U_ ) {\n return dissect_nlm_shareres ( tvb , 0 , pinfo , tree , 3 ) ;\n }", "idx": 21191}
{"hash": -7076754245473579218, "project": "chrome", "size": 42, "label": 1, "functionSource": "static int evhttp_parse_request_line ( struct evhttp_request * req , char * line ) {\n char * method ;\n char * uri ;\n char * version ;\n method = strsep ( & line , \" \" ) ;\n if ( line == NULL ) return ( - 1 ) ;\n uri = strsep ( & line , \" \" ) ;\n if ( line == NULL ) return ( - 1 ) ;\n version = strsep ( & line , \" \" ) ;\n if ( line != NULL ) return ( - 1 ) ;\n if ( strcmp ( method , \"GET\" ) == 0 ) {\n req -> type = EVHTTP_REQ_GET ;\n }\n else if ( strcmp ( method , \"POST\" ) == 0 ) {\n req -> type = EVHTTP_REQ_POST ;\n }\n else if ( strcmp ( method , \"HEAD\" ) == 0 ) {\n req -> type = EVHTTP_REQ_HEAD ;\n }\n else {\n event_debug ( ( \"%s: bad method %s on request %p from %s\" , __func__ , method , req , req -> remote_host ) ) ;\n return ( - 1 ) ;\n }\n if ( strcmp ( version , \"HTTP/1.0\" ) == 0 ) {\n req -> major = 1 ;\n req -> minor = 0 ;\n }\n else if ( strcmp ( version , \"HTTP/1.1\" ) == 0 ) {\n req -> major = 1 ;\n req -> minor = 1 ;\n }\n else {\n event_debug ( ( \"%s: bad version %s on request %p from %s\" , __func__ , version , req , req -> remote_host ) ) ;\n return ( - 1 ) ;\n }\n if ( ( req -> uri = strdup ( uri ) ) == NULL ) {\n event_debug ( ( \"%s: evhttp_decode_uri\" , __func__ ) ) ;\n return ( - 1 ) ;\n }\n if ( strlen ( req -> uri ) > 0 && req -> uri [ 0 ] != '/' ) req -> flags |= EVHTTP_PROXY_REQUEST ;\n return ( 0 ) ;\n }", "idx": 21192}
{"hash": -1658505547857059267, "project": "debian", "size": 13, "label": 0, "functionSource": "static Picture * remove_long ( H264Context * h , int i , int ref_mask ) {\n Picture * pic ;\n pic = h -> long_ref [ i ] ;\n if ( pic ) {\n if ( unreference_pic ( h , pic , ref_mask ) ) {\n assert ( h -> long_ref [ i ] -> long_ref == 1 ) ;\n h -> long_ref [ i ] -> long_ref = 0 ;\n h -> long_ref [ i ] = NULL ;\n h -> long_ref_count -- ;\n }\n }\n return pic ;\n }", "idx": 21193}
{"hash": 6632536031698733342, "project": "debian", "size": 47, "label": 0, "functionSource": "static void ffprobe_show_pixel_formats ( WriterContext * w ) {\n const AVPixFmtDescriptor * pixdesc = NULL ;\n int i , n ;\n writer_print_section_header ( w , SECTION_ID_PIXEL_FORMATS ) ;\n while ( pixdesc = av_pix_fmt_desc_next ( pixdesc ) ) {\n writer_print_section_header ( w , SECTION_ID_PIXEL_FORMAT ) ;\n print_str ( \"name\" , pixdesc -> name ) ;\n print_int ( \"nb_components\" , pixdesc -> nb_components ) ;\n if ( ( pixdesc -> nb_components >= 3 ) && ! ( pixdesc -> flags & AV_PIX_FMT_FLAG_RGB ) ) {\n print_int ( \"log2_chroma_w\" , pixdesc -> log2_chroma_w ) ;\n print_int ( \"log2_chroma_h\" , pixdesc -> log2_chroma_h ) ;\n }\n else {\n print_str_opt ( \"log2_chroma_w\" , \"N/A\" ) ;\n print_str_opt ( \"log2_chroma_h\" , \"N/A\" ) ;\n }\n n = av_get_bits_per_pixel ( pixdesc ) ;\n if ( n ) print_int ( \"bits_per_pixel\" , n ) ;\n else print_str_opt ( \"bits_per_pixel\" , \"N/A\" ) ;\n if ( do_show_pixel_format_flags ) {\n writer_print_section_header ( w , SECTION_ID_PIXEL_FORMAT_FLAGS ) ;\n PRINT_PIX_FMT_FLAG ( BE , \"big_endian\" ) ;\n PRINT_PIX_FMT_FLAG ( PAL , \"palette\" ) ;\n PRINT_PIX_FMT_FLAG ( BITSTREAM , \"bitstream\" ) ;\n PRINT_PIX_FMT_FLAG ( HWACCEL , \"hwaccel\" ) ;\n PRINT_PIX_FMT_FLAG ( PLANAR , \"planar\" ) ;\n PRINT_PIX_FMT_FLAG ( RGB , \"rgb\" ) ;\n PRINT_PIX_FMT_FLAG ( PSEUDOPAL , \"pseudopal\" ) ;\n PRINT_PIX_FMT_FLAG ( ALPHA , \"alpha\" ) ;\n writer_print_section_footer ( w ) ;\n }\n if ( do_show_pixel_format_components && ( pixdesc -> nb_components > 0 ) ) {\n writer_print_section_header ( w , SECTION_ID_PIXEL_FORMAT_COMPONENTS ) ;\n for ( i = 0 ;\n i < pixdesc -> nb_components ;\n i ++ ) {\n writer_print_section_header ( w , SECTION_ID_PIXEL_FORMAT_COMPONENT ) ;\n print_int ( \"index\" , i + 1 ) ;\n print_int ( \"bit_depth\" , pixdesc -> comp [ i ] . depth ) ;\n writer_print_section_footer ( w ) ;\n }\n writer_print_section_footer ( w ) ;\n }\n writer_print_section_footer ( w ) ;\n }\n writer_print_section_footer ( w ) ;\n }", "idx": 21194}
{"hash": 4423867112908498696, "project": "chrome", "size": 15, "label": 1, "functionSource": "void vp9_quantize_dc_32x32 ( const int16_t * coeff_ptr , int skip_block , const int16_t * round_ptr , const int16_t quant , int16_t * qcoeff_ptr , int16_t * dqcoeff_ptr , const int16_t dequant_ptr , uint16_t * eob_ptr ) {\n const int rc = 0 ;\n const int coeff = coeff_ptr [ rc ] ;\n const int coeff_sign = ( coeff >> 31 ) ;\n const int abs_coeff = ( coeff ^ coeff_sign ) - coeff_sign ;\n int tmp , eob = - 1 ;\n if ( ! skip_block ) {\n tmp = clamp ( abs_coeff + round_ptr [ rc != 0 ] , INT16_MIN , INT16_MAX ) ;\n tmp = ( tmp * quant ) >> 15 ;\n qcoeff_ptr [ rc ] = ( tmp ^ coeff_sign ) - coeff_sign ;\n dqcoeff_ptr [ rc ] = qcoeff_ptr [ rc ] * dequant_ptr / 2 ;\n if ( tmp ) eob = 0 ;\n }\n * eob_ptr = eob + 1 ;\n }", "idx": 21195}
{"hash": -7422764464424760982, "project": "chrome", "size": 39, "label": 0, "functionSource": "TEST_F ( ExtensionServiceSyncTest , GetSyncAppDataUserSettingsOnExtensionMoved ) {\n InitializeEmptyExtensionService ( ) ;\n const size_t kAppCount = 3 ;\n const Extension * apps [ kAppCount ] ;\n apps [ 0 ] = PackAndInstallCRX ( data_dir ( ) . AppendASCII ( \"app1\" ) , INSTALL_NEW ) ;\n apps [ 1 ] = PackAndInstallCRX ( data_dir ( ) . AppendASCII ( \"app2\" ) , INSTALL_NEW ) ;\n apps [ 2 ] = PackAndInstallCRX ( data_dir ( ) . AppendASCII ( \"app4\" ) , INSTALL_NEW ) ;\n for ( size_t i = 0 ;\n i < kAppCount ;\n ++ i ) {\n ASSERT_TRUE ( apps [ i ] ) ;\n ASSERT_TRUE ( apps [ i ] -> is_app ( ) ) ;\n }\n extension_sync_service ( ) -> MergeDataAndStartSyncing ( syncer : : APPS , syncer : : SyncDataList ( ) , base : : WrapUnique ( new syncer : : FakeSyncChangeProcessor ( ) ) , base : : WrapUnique ( new syncer : : SyncErrorFactoryMock ( ) ) ) ;\n ExtensionSystem : : Get ( service ( ) -> GetBrowserContext ( ) ) -> app_sorting ( ) -> OnExtensionMoved ( apps [ 0 ] -> id ( ) , apps [ 1 ] -> id ( ) , apps [ 2 ] -> id ( ) ) ;\n {\n syncer : : SyncDataList list = extension_sync_service ( ) -> GetAllSyncData ( syncer : : APPS ) ;\n ASSERT_EQ ( list . size ( ) , 3U ) ;\n std : : unique_ptr < ExtensionSyncData > data [ kAppCount ] ;\n for ( size_t i = 0 ;\n i < kAppCount ;\n ++ i ) {\n data [ i ] = ExtensionSyncData : : CreateFromSyncData ( list [ i ] ) ;\n ASSERT_TRUE ( data [ i ] . get ( ) ) ;\n }\n syncer : : StringOrdinal app_launch_ordinals [ kAppCount ] ;\n for ( size_t i = 0 ;\n i < kAppCount ;\n ++ i ) {\n for ( size_t j = 0 ;\n j < kAppCount ;\n ++ j ) {\n if ( apps [ i ] -> id ( ) == data [ j ] -> id ( ) ) app_launch_ordinals [ i ] = data [ j ] -> app_launch_ordinal ( ) ;\n }\n }\n EXPECT_TRUE ( app_launch_ordinals [ 1 ] . LessThan ( app_launch_ordinals [ 0 ] ) ) ;\n EXPECT_TRUE ( app_launch_ordinals [ 0 ] . LessThan ( app_launch_ordinals [ 2 ] ) ) ;\n }\n }", "idx": 21196}
{"hash": -2915908172644760936, "project": "debian", "size": 20, "label": 0, "functionSource": "static void use_high_update_speed ( WmallDecodeCtx * s , int ich ) {\n int ilms , recent , icoef ;\n for ( ilms = s -> cdlms_ttl [ ich ] - 1 ;\n ilms >= 0 ;\n ilms -- ) {\n recent = s -> cdlms [ ich ] [ ilms ] . recent ;\n if ( s -> update_speed [ ich ] == 16 ) continue ;\n if ( s -> bV3RTM ) {\n for ( icoef = 0 ;\n icoef < s -> cdlms [ ich ] [ ilms ] . order ;\n icoef ++ ) s -> cdlms [ ich ] [ ilms ] . lms_updates [ icoef + recent ] *= 2 ;\n }\n else {\n for ( icoef = 0 ;\n icoef < s -> cdlms [ ich ] [ ilms ] . order ;\n icoef ++ ) s -> cdlms [ ich ] [ ilms ] . lms_updates [ icoef ] *= 2 ;\n }\n }\n s -> update_speed [ ich ] = 16 ;\n }", "idx": 21197}
{"hash": -2908211205972632000, "project": "debian", "size": 11, "label": 0, "functionSource": "static void cmd_window_size ( const char * data ) {\n char sizestr [ MAX_INT_STRLEN ] ;\n int size ;\n if ( ! is_numeric ( data , 0 ) ) return ;\n size = atoi ( data ) ;\n size -= WINDOW_MAIN ( active_win ) -> height - WINDOW_MAIN ( active_win ) -> statusbar_lines ;\n if ( size == 0 ) return ;\n ltoa ( sizestr , size < 0 ? - size : size ) ;\n if ( size < 0 ) cmd_window_shrink ( sizestr ) ;\n else cmd_window_grow ( sizestr ) ;\n }", "idx": 21198}
{"hash": -1102844685921778700, "project": "debian", "size": 36, "label": 0, "functionSource": "int archive_mstring_get_mbs_l ( struct archive_mstring * aes , const char * * p , size_t * length , struct archive_string_conv * sc ) {\n int r , ret = 0 ;\n # if defined ( _WIN32 ) && ! defined ( __CYGWIN__ ) if ( sc != NULL && ( aes -> aes_set & AES_SET_WCS ) != 0 ) {\n archive_string_empty ( & ( aes -> aes_mbs_in_locale ) ) ;\n r = archive_string_append_from_wcs_in_codepage ( & ( aes -> aes_mbs_in_locale ) , aes -> aes_wcs . s , aes -> aes_wcs . length , sc ) ;\n if ( r == 0 ) {\n * p = aes -> aes_mbs_in_locale . s ;\n if ( length != NULL ) * length = aes -> aes_mbs_in_locale . length ;\n return ( 0 ) ;\n }\n else if ( errno == ENOMEM ) return ( - 1 ) ;\n else ret = - 1 ;\n }\n # endif if ( ( aes -> aes_set & AES_SET_MBS ) == 0 && ( aes -> aes_set & AES_SET_WCS ) != 0 ) {\n archive_string_empty ( & ( aes -> aes_mbs ) ) ;\n r = archive_string_append_from_wcs ( & ( aes -> aes_mbs ) , aes -> aes_wcs . s , aes -> aes_wcs . length ) ;\n if ( r == 0 ) aes -> aes_set |= AES_SET_MBS ;\n else if ( errno == ENOMEM ) return ( - 1 ) ;\n else ret = - 1 ;\n }\n if ( aes -> aes_set & AES_SET_MBS ) {\n if ( sc == NULL ) {\n * p = aes -> aes_mbs . s ;\n if ( length != NULL ) * length = aes -> aes_mbs . length ;\n return ( 0 ) ;\n }\n ret = archive_strncpy_l ( & ( aes -> aes_mbs_in_locale ) , aes -> aes_mbs . s , aes -> aes_mbs . length , sc ) ;\n * p = aes -> aes_mbs_in_locale . s ;\n if ( length != NULL ) * length = aes -> aes_mbs_in_locale . length ;\n }\n else {\n * p = NULL ;\n if ( length != NULL ) * length = 0 ;\n }\n return ( ret ) ;\n }", "idx": 21199}
{"hash": 3755875528583281641, "project": "debian", "size": 85, "label": 0, "functionSource": "static PK11SymKey * import_symmetric_key ( struct crypto_instance * instance , enum sym_key_type key_type ) {\n SECItem key_item ;\n PK11SlotInfo * slot ;\n PK11SymKey * res_key ;\n CK_MECHANISM_TYPE cipher ;\n CK_ATTRIBUTE_TYPE operation ;\n CK_MECHANISM_TYPE wrap_mechanism ;\n int wrap_key_len ;\n PK11SymKey * wrap_key ;\n PK11Context * wrap_key_crypt_context ;\n SECItem tmp_sec_item ;\n SECItem wrapped_key ;\n int wrapped_key_len ;\n unsigned char wrapped_key_data [ MAX_WRAPPED_KEY_LEN ] ;\n int case_processed ;\n memset ( & key_item , 0 , sizeof ( key_item ) ) ;\n slot = NULL ;\n wrap_key = NULL ;\n res_key = NULL ;\n wrap_key_crypt_context = NULL ;\n key_item . type = siBuffer ;\n key_item . data = instance -> private_key ;\n case_processed = 0 ;\n switch ( key_type ) {\n case SYM_KEY_TYPE_CRYPT : key_item . len = cipher_key_len [ instance -> crypto_cipher_type ] ;\n cipher = cipher_to_nss [ instance -> crypto_cipher_type ] ;\n operation = CKA_ENCRYPT | CKA_DECRYPT ;\n case_processed = 1 ;\n break ;\n case SYM_KEY_TYPE_HASH : key_item . len = instance -> private_key_len ;\n cipher = hash_to_nss [ instance -> crypto_hash_type ] ;\n operation = CKA_SIGN ;\n case_processed = 1 ;\n break ;\n }\n if ( ! case_processed ) {\n log_printf ( instance -> log_level_error , \"Unknown key_type\" ) ;\n goto exit_res_key ;\n }\n slot = PK11_GetBestSlot ( cipher , NULL ) ;\n if ( slot == NULL ) {\n log_printf ( instance -> log_level_security , \"Unable to find security slot (%d): %s\" , PR_GetError ( ) , PR_ErrorToString ( PR_GetError ( ) , PR_LANGUAGE_I_DEFAULT ) ) ;\n goto exit_res_key ;\n }\n wrap_mechanism = PK11_GetBestWrapMechanism ( slot ) ;\n wrap_key_len = PK11_GetBestKeyLength ( slot , wrap_mechanism ) ;\n wrap_key = PK11_KeyGen ( slot , wrap_mechanism , NULL , wrap_key_len , NULL ) ;\n if ( wrap_key == NULL ) {\n log_printf ( instance -> log_level_security , \"Unable to generate wrapping key (%d): %s\" , PR_GetError ( ) , PR_ErrorToString ( PR_GetError ( ) , PR_LANGUAGE_I_DEFAULT ) ) ;\n goto exit_res_key ;\n }\n memset ( & tmp_sec_item , 0 , sizeof ( tmp_sec_item ) ) ;\n wrap_key_crypt_context = PK11_CreateContextBySymKey ( wrap_mechanism , CKA_ENCRYPT , wrap_key , & tmp_sec_item ) ;\n if ( wrap_key_crypt_context == NULL ) {\n log_printf ( instance -> log_level_security , \"Unable to create encrypt context (%d): %s\" , PR_GetError ( ) , PR_ErrorToString ( PR_GetError ( ) , PR_LANGUAGE_I_DEFAULT ) ) ;\n goto exit_res_key ;\n }\n wrapped_key_len = ( int ) sizeof ( wrapped_key_data ) ;\n if ( PK11_CipherOp ( wrap_key_crypt_context , wrapped_key_data , & wrapped_key_len , sizeof ( wrapped_key_data ) , key_item . data , key_item . len ) != SECSuccess ) {\n log_printf ( instance -> log_level_security , \"Unable to encrypt authkey (%d): %s\" , PR_GetError ( ) , PR_ErrorToString ( PR_GetError ( ) , PR_LANGUAGE_I_DEFAULT ) ) ;\n goto exit_res_key ;\n }\n if ( PK11_Finalize ( wrap_key_crypt_context ) != SECSuccess ) {\n log_printf ( instance -> log_level_security , \"Unable to finalize encryption of authkey (%d): %s\" , PR_GetError ( ) , PR_ErrorToString ( PR_GetError ( ) , PR_LANGUAGE_I_DEFAULT ) ) ;\n goto exit_res_key ;\n }\n memset ( & tmp_sec_item , 0 , sizeof ( tmp_sec_item ) ) ;\n wrapped_key . data = wrapped_key_data ;\n wrapped_key . len = wrapped_key_len ;\n res_key = PK11_UnwrapSymKey ( wrap_key , wrap_mechanism , & tmp_sec_item , & wrapped_key , cipher , operation , key_item . len ) ;\n if ( res_key == NULL ) {\n log_printf ( instance -> log_level_security , \"Failure to import key into NSS (%d): %s\" , PR_GetError ( ) , PR_ErrorToString ( PR_GetError ( ) , PR_LANGUAGE_I_DEFAULT ) ) ;\n goto exit_res_key ;\n }\n exit_res_key : if ( wrap_key_crypt_context != NULL ) {\n PK11_DestroyContext ( wrap_key_crypt_context , PR_TRUE ) ;\n }\n if ( wrap_key != NULL ) {\n PK11_FreeSymKey ( wrap_key ) ;\n }\n if ( slot != NULL ) {\n PK11_FreeSlot ( slot ) ;\n }\n return ( res_key ) ;\n }", "idx": 21200}
{"hash": 1760449185745615462, "project": "debian", "size": 4, "label": 0, "functionSource": "void TSTextLogObjectRollingSizeMbSet ( TSTextLogObject the_object , int rolling_size_mb ) {\n sdk_assert ( sdk_sanity_check_iocore_structure ( the_object ) == TS_SUCCESS ) ;\n ( ( TextLogObject * ) the_object ) -> set_rolling_size_mb ( rolling_size_mb ) ;\n }", "idx": 21201}
{"hash": -2877872629837651351, "project": "chrome", "size": 7, "label": 0, "functionSource": "static UBool isNewline ( UChar32 c ) {\n switch ( c ) {\n case 0x000A : case 0x2029 : lineCount ++ ;\n case 0x000D : return TRUE ;\n default : return FALSE ;\n }\n }", "idx": 21202}
{"hash": 7153080989267739132, "project": "debian", "size": 7, "label": 0, "functionSource": "static int mxpeg_decode_app ( MXpegDecodeContext * s , const uint8_t * buf_ptr , int buf_size ) {\n int len ;\n if ( buf_size < 2 ) return 0 ;\n len = AV_RB16 ( buf_ptr ) ;\n skip_bits ( & s -> jpg . gb , 8 * FFMIN ( len , buf_size ) ) ;\n return 0 ;\n }", "idx": 21203}
{"hash": 3487452046891662469, "project": "debian", "size": 3, "label": 0, "functionSource": "static inline void qemu_get_8s ( QEMUFile * f , uint8_t * pv ) {\n * pv = qemu_get_byte ( f ) ;\n }", "idx": 21204}
{"hash": -7253276028511611170, "project": "debian", "size": 50, "label": 0, "functionSource": "static void init_quant_matrix ( VC2EncContext * s ) {\n int level , orientation ;\n if ( s -> wavelet_depth <= 4 && s -> quant_matrix == VC2_QM_DEF ) {\n s -> custom_quant_matrix = 0 ;\n for ( level = 0 ;\n level < s -> wavelet_depth ;\n level ++ ) {\n s -> quant [ level ] [ 0 ] = ff_dirac_default_qmat [ s -> wavelet_idx ] [ level ] [ 0 ] ;\n s -> quant [ level ] [ 1 ] = ff_dirac_default_qmat [ s -> wavelet_idx ] [ level ] [ 1 ] ;\n s -> quant [ level ] [ 2 ] = ff_dirac_default_qmat [ s -> wavelet_idx ] [ level ] [ 2 ] ;\n s -> quant [ level ] [ 3 ] = ff_dirac_default_qmat [ s -> wavelet_idx ] [ level ] [ 3 ] ;\n }\n return ;\n }\n s -> custom_quant_matrix = 1 ;\n if ( s -> quant_matrix == VC2_QM_DEF ) {\n for ( level = 0 ;\n level < s -> wavelet_depth ;\n level ++ ) {\n for ( orientation = 0 ;\n orientation < 4 ;\n orientation ++ ) {\n if ( level <= 3 ) s -> quant [ level ] [ orientation ] = ff_dirac_default_qmat [ s -> wavelet_idx ] [ level ] [ orientation ] ;\n else s -> quant [ level ] [ orientation ] = vc2_qm_col_tab [ level ] [ orientation ] ;\n }\n }\n }\n else if ( s -> quant_matrix == VC2_QM_COL ) {\n for ( level = 0 ;\n level < s -> wavelet_depth ;\n level ++ ) {\n for ( orientation = 0 ;\n orientation < 4 ;\n orientation ++ ) {\n s -> quant [ level ] [ orientation ] = vc2_qm_col_tab [ level ] [ orientation ] ;\n }\n }\n }\n else {\n for ( level = 0 ;\n level < s -> wavelet_depth ;\n level ++ ) {\n for ( orientation = 0 ;\n orientation < 4 ;\n orientation ++ ) {\n s -> quant [ level ] [ orientation ] = vc2_qm_flat_tab [ level ] [ orientation ] ;\n }\n }\n }\n }", "idx": 21205}
{"hash": -4555950263653671147, "project": "debian", "size": 4, "label": 0, "functionSource": "static PyObject * basestring_new ( PyTypeObject * type , PyObject * args , PyObject * kwds ) {\n PyErr_SetString ( PyExc_TypeError , \"The basestring type cannot be instantiated\" ) ;\n return NULL ;\n }", "idx": 21206}
{"hash": -1315695702746584250, "project": "debian", "size": 43, "label": 0, "functionSource": "static int proto_register_field_init ( header_field_info * hfinfo , const int parent ) {\n tmp_fld_check_assert ( hfinfo ) ;\n hfinfo -> parent = parent ;\n hfinfo -> same_name_next = NULL ;\n hfinfo -> same_name_prev_id = - 1 ;\n if ( gpa_hfinfo . len >= gpa_hfinfo . allocated_len ) {\n if ( ! gpa_hfinfo . hfi ) {\n gpa_hfinfo . allocated_len = PROTO_PRE_ALLOC_HF_FIELDS_MEM ;\n gpa_hfinfo . hfi = ( header_field_info * * ) g_malloc ( sizeof ( header_field_info * ) * PROTO_PRE_ALLOC_HF_FIELDS_MEM ) ;\n }\n else {\n gpa_hfinfo . allocated_len += 1000 ;\n gpa_hfinfo . hfi = ( header_field_info * * ) g_realloc ( gpa_hfinfo . hfi , sizeof ( header_field_info * ) * gpa_hfinfo . allocated_len ) ;\n }\n }\n gpa_hfinfo . hfi [ gpa_hfinfo . len ] = hfinfo ;\n gpa_hfinfo . len ++ ;\n hfinfo -> id = gpa_hfinfo . len - 1 ;\n if ( ( hfinfo -> name [ 0 ] != 0 ) && ( hfinfo -> abbrev [ 0 ] != 0 ) ) {\n header_field_info * same_name_next_hfinfo ;\n guchar c ;\n c = wrs_check_charset ( fld_abbrev_chars , hfinfo -> abbrev ) ;\n if ( c ) {\n if ( g_ascii_isprint ( c ) ) fprintf ( stderr , \"Invalid character '%c' in filter name '%s'\\n\" , c , hfinfo -> abbrev ) ;\n else fprintf ( stderr , \"Invalid byte \\\\%03o in filter name '%s'\\n\" , c , hfinfo -> abbrev ) ;\n DISSECTOR_ASSERT_NOT_REACHED ( ) ;\n }\n same_name_hfinfo = NULL ;\n g_hash_table_insert ( gpa_name_map , ( gpointer ) ( hfinfo -> abbrev ) , hfinfo ) ;\n if ( same_name_hfinfo ) {\n same_name_next_hfinfo = same_name_hfinfo -> same_name_next ;\n hfinfo -> same_name_next = same_name_next_hfinfo ;\n if ( same_name_next_hfinfo ) same_name_next_hfinfo -> same_name_prev_id = hfinfo -> id ;\n same_name_hfinfo -> same_name_next = hfinfo ;\n hfinfo -> same_name_prev_id = same_name_hfinfo -> id ;\n # ifdef ENABLE_CHECK_FILTER while ( same_name_hfinfo ) {\n if ( _ftype_common ( hfinfo -> type ) != _ftype_common ( same_name_hfinfo -> type ) ) fprintf ( stderr , \"'%s' exists multiple times with NOT compatible types: %s and %s\\n\" , hfinfo -> abbrev , ftype_name ( hfinfo -> type ) , ftype_name ( same_name_hfinfo -> type ) ) ;\n same_name_hfinfo = same_name_hfinfo -> same_name_next ;\n }\n # endif }\n }\n return hfinfo -> id ;\n }", "idx": 21207}
{"hash": 8206514580434225668, "project": "chrome", "size": 13, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( HttpsEngagementPageLoadMetricsBrowserTest , BackgroundThenForeground_Http ) {\n StartHttpServer ( ) ;\n base : : TimeDelta upper_bound = NavigateInBackgroundAndCloseInForegroundWithTiming ( http_test_server_ -> GetURL ( \"/simple.html\" ) ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHttpEngagementHistogram , 1 ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHttpsEngagementHistogram , 0 ) ;\n int32_t bucket_min = histogram_tester_ . GetAllSamples ( internal : : kHttpEngagementHistogram ) [ 0 ] . min ;\n EXPECT_GE ( upper_bound . InMilliseconds ( ) , bucket_min ) ;\n EXPECT_LT ( 0 , bucket_min ) ;\n FakeUserMetricsUpload ( ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHttpsEngagementSessionPercentage , 1 ) ;\n int32_t ratio_bucket = histogram_tester_ . GetAllSamples ( internal : : kHttpsEngagementSessionPercentage ) [ 0 ] . min ;\n EXPECT_EQ ( 0 , ratio_bucket ) ;\n }", "idx": 21208}
{"hash": -7855974557509681261, "project": "debian", "size": 12, "label": 0, "functionSource": "char * get_opname ( Oid opno ) {\n HeapTuple tp ;\n tp = SearchSysCache1 ( OPEROID , ObjectIdGetDatum ( opno ) ) ;\n if ( HeapTupleIsValid ( tp ) ) {\n Form_pg_operator optup = ( Form_pg_operator ) GETSTRUCT ( tp ) ;\n char * result ;\n result = pstrdup ( NameStr ( optup -> oprname ) ) ;\n ReleaseSysCache ( tp ) ;\n return result ;\n }\n else return NULL ;\n }", "idx": 21209}
{"hash": -4055702019813176658, "project": "debian", "size": 25, "label": 0, "functionSource": "static guint iax_circuit_lookup ( const address * address_p , port_type ptype , guint32 port , guint32 callno ) {\n iax_circuit_key key ;\n guint32 * circuit_id_p ;\n key . addr = * address_p ;\n key . ptype = ptype ;\n key . port = port ;\n key . callno = callno ;\n circuit_id_p = ( guint32 * ) g_hash_table_lookup ( iax_circuit_hashtab , & key ) ;\n if ( ! circuit_id_p ) {\n iax_circuit_key * new_key ;\n new_key = wmem_new ( wmem_file_scope ( ) , iax_circuit_key ) ;\n new_key -> addr . type = address_p -> type ;\n new_key -> addr . len = MIN ( address_p -> len , MAX_ADDRESS ) ;\n new_key -> addr . data = new_key -> address_data ;\n memcpy ( new_key -> address_data , address_p -> data , new_key -> addr . len ) ;\n new_key -> ptype = ptype ;\n new_key -> port = port ;\n new_key -> callno = callno ;\n circuit_id_p = ( guint32 * ) wmem_new ( wmem_file_scope ( ) , iax_circuit_key ) ;\n * circuit_id_p = ++ circuitcount ;\n g_hash_table_insert ( iax_circuit_hashtab , new_key , circuit_id_p ) ;\n # ifdef DEBUG_HASHING g_debug ( \"Created new circuit id %u for node %s\" , * circuit_id_p , key_to_str ( new_key ) ) ;\n # endif }\n return * circuit_id_p ;\n }", "idx": 21210}
{"hash": -6615083443578004976, "project": "debian", "size": 9, "label": 0, "functionSource": "void proto_reg_handoff_usb_ms ( void ) {\n dissector_handle_t usb_ms_bulk_handle ;\n dissector_handle_t usb_ms_control_handle ;\n usb_ms_bulk_handle = find_dissector ( \"usbms\" ) ;\n dissector_add_uint ( \"usb.bulk\" , IF_CLASS_MASS_STORAGE , usb_ms_bulk_handle ) ;\n usb_ms_control_handle = create_dissector_handle ( dissect_usb_ms_control , proto_usb_ms ) ;\n dissector_add_uint ( \"usb.control\" , IF_CLASS_MASS_STORAGE , usb_ms_control_handle ) ;\n heur_dissector_add ( \"usb.bulk\" , dissect_usb_ms_bulk_heur , \"Mass Storage USB bulk endpoint\" , \"ms_usb_bulk\" , proto_usb_ms , HEURISTIC_ENABLE ) ;\n }", "idx": 21211}
{"hash": -5550748970150309774, "project": "debian", "size": 11, "label": 0, "functionSource": "void DisconnectDatabase ( Archive * AHX ) {\n ArchiveHandle * AH = ( ArchiveHandle * ) AHX ;\n char errbuf [ 1 ] ;\n if ( ! AH -> connection ) return ;\n if ( AH -> connCancel ) {\n if ( PQtransactionStatus ( AH -> connection ) == PQTRANS_ACTIVE ) PQcancel ( AH -> connCancel , errbuf , sizeof ( errbuf ) ) ;\n set_archive_cancel_info ( AH , NULL ) ;\n }\n PQfinish ( AH -> connection ) ;\n AH -> connection = NULL ;\n }", "idx": 21212}
{"hash": 369115599810341094, "project": "debian", "size": 15, "label": 0, "functionSource": "static void vga_draw_line15_be ( VGACommonState * vga , uint8_t * d , uint32_t addr , int width ) {\n int w ;\n uint32_t v , r , g , b ;\n w = width ;\n do {\n v = vga_read_word_be ( vga , addr ) ;\n r = ( v >> 7 ) & 0xf8 ;\n g = ( v >> 2 ) & 0xf8 ;\n b = ( v << 3 ) & 0xf8 ;\n ( ( uint32_t * ) d ) [ 0 ] = rgb_to_pixel32 ( r , g , b ) ;\n addr += 2 ;\n d += 4 ;\n }\n while ( -- w != 0 ) ;\n }", "idx": 21213}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_QOSClass ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_QOSClass , QOSClass_choice , NULL ) ;\n return offset ;\n }", "idx": 21214}
{"hash": 3584320764213684062, "project": "debian", "size": 51, "label": 1, "functionSource": "static int dissect_CPMConnect ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * parent_tree , gboolean in , void * private_data ) {\n proto_item * ti ;\n proto_tree * tree ;\n gint offset = 16 ;\n guint len ;\n guint32 version ;\n struct message_data * data = NULL ;\n struct mswsp_ct * ct = NULL ;\n ti = proto_tree_add_item ( parent_tree , hf_mswsp_msg , tvb , offset , - 1 , ENC_NA ) ;\n tree = proto_item_add_subtree ( ti , ett_mswsp_msg ) ;\n proto_item_set_text ( ti , \"CPMConnect%s\" , in ? \"In\" : \"Out\" ) ;\n col_append_str ( pinfo -> cinfo , COL_INFO , \"Connect\" ) ;\n ti = proto_tree_add_item_ret_uint ( tree , hf_mswsp_msg_Connect_Version , tvb , offset , 4 , ENC_LITTLE_ENDIAN , & version ) ;\n ct = get_create_converstation_data ( pinfo ) ;\n if ( ct ) {\n data = find_or_create_message_data ( ct , pinfo , 0xC8 , in , private_data ) ;\n if ( data ) {\n data -> content . version = version ;\n }\n }\n offset += 4 ;\n if ( in ) {\n guint32 blob_size1_off , blob_size2_off ;\n proto_tree * pad_tree ;\n pad_tree = proto_tree_add_subtree ( tree , tvb , offset , 0 , ett_mswsp_pad , & ti , \"Padding\" ) ;\n proto_tree_add_item ( tree , hf_mswsp_msg_ConnectIn_ClientIsRemote , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n blob_size1_off = offset ;\n offset += 4 ;\n offset = parse_padding ( tvb , offset , 8 , pad_tree , \"_paddingcbBlob2\" ) ;\n blob_size2_off = offset ;\n offset += 4 ;\n offset = parse_padding ( tvb , offset , 16 , pad_tree , \"_padding\" ) ;\n len = tvb_unicode_strsize ( tvb , offset ) ;\n proto_tree_add_item ( tree , hf_mswsp_msg_ConnectIn_MachineName , tvb , offset , len , ENC_LITTLE_ENDIAN | ENC_UCS_2 ) ;\n offset += len ;\n len = tvb_unicode_strsize ( tvb , offset ) ;\n ti = proto_tree_add_item ( tree , hf_mswsp_msg_ConnectIn_UserName , tvb , offset , len , ENC_LITTLE_ENDIAN | ENC_UCS_2 ) ;\n offset += len ;\n offset = parse_padding ( tvb , offset , 8 , pad_tree , \"_paddingcPropSets\" ) ;\n offset = parse_PropertySetArray ( tvb , offset , blob_size1_off , tree , pad_tree , \"PropSets\" ) ;\n offset = parse_padding ( tvb , offset , 8 , pad_tree , \"paddingExtPropset\" ) ;\n offset = parse_PropertySetArray ( tvb , offset , blob_size2_off , tree , pad_tree , \"ExtPropset\" ) ;\n offset = parse_padding ( tvb , offset , 8 , pad_tree , \"???\" ) ;\n DISSECTOR_ASSERT ( offset == ( int ) tvb_reported_length ( tvb ) ) ;\n proto_tree_move_item ( tree , ti , proto_tree_get_parent ( pad_tree ) ) ;\n }\n else {\n }\n return tvb_reported_length ( tvb ) ;\n }", "idx": 21215}
{"hash": 7039307292471244756, "project": "debian", "size": 13, "label": 0, "functionSource": "static void dtap_cc_modify_complete ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len ) {\n guint32 curr_offset ;\n guint32 consumed ;\n guint curr_len ;\n curr_offset = offset ;\n curr_len = len ;\n is_uplink = IS_UPLINK_TRUE ;\n ELEM_MAND_LV ( GSM_A_PDU_TYPE_DTAP , DE_BEARER_CAP , NULL ) ;\n ELEM_OPT_TLV ( 0x7c , GSM_A_PDU_TYPE_DTAP , DE_LLC , NULL ) ;\n ELEM_OPT_TLV ( 0x7d , GSM_A_PDU_TYPE_DTAP , DE_HLC , NULL ) ;\n ELEM_OPT_T ( 0xa3 , GSM_A_PDU_TYPE_DTAP , DE_REV_CALL_SETUP_DIR , NULL ) ;\n EXTRANEOUS_DATA_CHECK ( curr_len , 0 , pinfo , & ei_gsm_a_dtap_extraneous_data ) ;\n }", "idx": 21216}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_H223AnnexCCapability ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_H223AnnexCCapability , H223AnnexCCapability_sequence ) ;\n return offset ;\n }", "idx": 21217}
{"hash": 1339575514457462426, "project": "chrome", "size": 12, "label": 0, "functionSource": "TEST_F ( IconLabelBubbleViewTest , GestureInkDropState ) {\n AttachInkDrop ( ) ;\n generator ( ) -> GestureTapAt ( gfx : : Point ( ) ) ;\n EXPECT_EQ ( views : : InkDropState : : ACTIVATED , ink_drop ( ) -> GetTargetInkDropState ( ) ) ;\n view ( ) -> HideBubble ( ) ;\n EXPECT_EQ ( views : : InkDropState : : HIDDEN , ink_drop ( ) -> GetTargetInkDropState ( ) ) ;\n generator ( ) -> GestureTapAt ( gfx : : Point ( ) ) ;\n EXPECT_EQ ( views : : InkDropState : : ACTIVATED , ink_drop ( ) -> GetTargetInkDropState ( ) ) ;\n generator ( ) -> GestureTapAt ( gfx : : Point ( ) ) ;\n view ( ) -> HideBubble ( ) ;\n EXPECT_EQ ( views : : InkDropState : : HIDDEN , ink_drop ( ) -> GetTargetInkDropState ( ) ) ;\n }", "idx": 21218}
{"hash": -1283648210945038844, "project": "chrome", "size": 11, "label": 0, "functionSource": "void vp9_fdct16x16_1_c ( const int16_t * input , tran_low_t * output , int stride ) {\n int r , c ;\n tran_low_t sum = 0 ;\n for ( r = 0 ;\n r < 16 ;\n ++ r ) for ( c = 0 ;\n c < 16 ;\n ++ c ) sum += input [ r * stride + c ] ;\n output [ 0 ] = sum >> 1 ;\n output [ 1 ] = 0 ;\n }", "idx": 21219}
{"hash": -2423144171479606949, "project": "debian", "size": 5, "label": 0, "functionSource": "static void pdf_run_TL ( fz_context * ctx , pdf_processor * proc , float leading ) {\n pdf_run_processor * pr = ( pdf_run_processor * ) proc ;\n pdf_gstate * gstate = pr -> gstate + pr -> gtop ;\n gstate -> text . leading = leading ;\n }", "idx": 21220}
{"hash": -9028269206303312561, "project": "debian", "size": 8, "label": 0, "functionSource": "static int cmp_stop ( const void * a , const void * b ) {\n const struct stop * astop = a ;\n const struct stop * bstop = b ;\n float diff = astop -> offset - bstop -> offset ;\n if ( diff < 0 ) return - 1 ;\n if ( diff > 0 ) return 1 ;\n return astop -> index - bstop -> index ;\n }", "idx": 21221}
{"hash": -4558261210024070448, "project": "chrome", "size": 6, "label": 0, "functionSource": "int xmlListRemoveAll ( xmlListPtr l , void * data ) {\n int count = 0 ;\n if ( l == NULL ) return ( 0 ) ;\n while ( xmlListRemoveFirst ( l , data ) ) count ++ ;\n return count ;\n }", "idx": 21222}
{"hash": -5706788925640467782, "project": "chrome", "size": 66, "label": 1, "functionSource": "static void rd_auto_partition_range ( VP9_COMP * cpi , const TileInfo * const tile , int mi_row , int mi_col , BLOCK_SIZE * min_block_size , BLOCK_SIZE * max_block_size ) {\n VP9_COMMON * const cm = & cpi -> common ;\n MACROBLOCKD * const xd = & cpi -> mb . e_mbd ;\n MODE_INFO * * mi = xd -> mi ;\n const int left_in_image = xd -> left_available && mi [ - 1 ] ;\n const int above_in_image = xd -> up_available && mi [ - xd -> mi_stride ] ;\n const int row8x8_remaining = tile -> mi_row_end - mi_row ;\n const int col8x8_remaining = tile -> mi_col_end - mi_col ;\n int bh , bw ;\n BLOCK_SIZE min_size = BLOCK_4X4 ;\n BLOCK_SIZE max_size = BLOCK_64X64 ;\n int i = 0 ;\n int bs_hist [ BLOCK_SIZES ] = {\n 0 }\n ;\n if ( left_in_image || above_in_image || cm -> frame_type != KEY_FRAME ) {\n min_size = BLOCK_64X64 ;\n max_size = BLOCK_4X4 ;\n if ( cm -> frame_type != KEY_FRAME ) {\n MODE_INFO * * const prev_mi = & cm -> prev_mi_grid_visible [ mi_row * xd -> mi_stride + mi_col ] ;\n get_sb_partition_size_range ( xd , prev_mi , & min_size , & max_size , bs_hist ) ;\n }\n if ( left_in_image ) {\n MODE_INFO * * left_sb64_mi = & mi [ - MI_BLOCK_SIZE ] ;\n get_sb_partition_size_range ( xd , left_sb64_mi , & min_size , & max_size , bs_hist ) ;\n }\n if ( above_in_image ) {\n MODE_INFO * * above_sb64_mi = & mi [ - xd -> mi_stride * MI_BLOCK_SIZE ] ;\n get_sb_partition_size_range ( xd , above_sb64_mi , & min_size , & max_size , bs_hist ) ;\n }\n if ( cpi -> sf . auto_min_max_partition_size == RELAXED_NEIGHBORING_MIN_MAX ) {\n min_size = min_partition_size [ min_size ] ;\n max_size = max_partition_size [ max_size ] ;\n }\n else if ( cpi -> sf . auto_min_max_partition_size == CONSTRAIN_NEIGHBORING_MIN_MAX ) {\n int sum = 0 ;\n int first_moment = 0 ;\n int second_moment = 0 ;\n int var_unnormalized = 0 ;\n for ( i = 0 ;\n i < BLOCK_SIZES ;\n i ++ ) {\n sum += bs_hist [ i ] ;\n first_moment += bs_hist [ i ] * i ;\n second_moment += bs_hist [ i ] * i * i ;\n }\n var_unnormalized = second_moment - first_moment * first_moment / sum ;\n if ( var_unnormalized <= 4 * sum ) {\n int mean = first_moment / sum ;\n min_size = min_partition_size [ mean ] ;\n max_size = max_partition_size [ mean ] ;\n }\n else {\n min_size = min_partition_size [ min_size ] ;\n max_size = max_partition_size [ max_size ] ;\n }\n }\n }\n max_size = find_partition_size ( max_size , row8x8_remaining , col8x8_remaining , & bh , & bw ) ;\n min_size = MIN ( min_size , max_size ) ;\n if ( cpi -> sf . use_square_partition_only && next_square_size [ max_size ] < min_size ) {\n min_size = next_square_size [ max_size ] ;\n }\n * min_block_size = min_size ;\n * max_block_size = max_size ;\n }", "idx": 21223}
{"hash": 2388171415474875762, "project": "debian", "size": 11, "label": 0, "functionSource": "static void dissect_rsvp_link_cap ( proto_item * ti , packet_info * pinfo , proto_tree * rsvp_object_tree , tvbuff_t * tvb , int offset , int obj_length , int rsvp_class , int type ) {\n proto_item_set_text ( ti , \"LINK CAPABILITY: \" ) ;\n switch ( type ) {\n case 1 : proto_tree_add_uint ( rsvp_object_tree , hf_rsvp_ctype , tvb , offset + 3 , 1 , type ) ;\n dissect_rsvp_ero_rro_subobjects ( ti , pinfo , rsvp_object_tree , tvb , offset + 4 , obj_length , rsvp_class ) ;\n break ;\n default : proto_tree_add_uint_format_value ( rsvp_object_tree , hf_rsvp_ctype , tvb , offset + 3 , 1 , type , \"Unknown (%u)\" , type ) ;\n proto_tree_add_item ( rsvp_object_tree , hf_rsvp_record_route_data , tvb , offset + 4 , obj_length - 4 , ENC_NA ) ;\n break ;\n }\n }", "idx": 21224}
{"hash": 5991533509192663951, "project": "debian", "size": 12, "label": 0, "functionSource": "int mbfl_buffer_converter_flush ( mbfl_buffer_converter * convd ) {\n if ( convd == NULL ) {\n return - 1 ;\n }\n if ( convd -> filter1 != NULL ) {\n mbfl_convert_filter_flush ( convd -> filter1 ) ;\n }\n if ( convd -> filter2 != NULL ) {\n mbfl_convert_filter_flush ( convd -> filter2 ) ;\n }\n return 0 ;\n }", "idx": 21225}
{"hash": -8365810778652022218, "project": "debian", "size": 14, "label": 0, "functionSource": "static void virtio_net_set_features ( VirtIODevice * vdev , uint32_t features ) {\n VirtIONet * n = to_virtio_net ( vdev ) ;\n n -> mergeable_rx_bufs = ! ! ( features & ( 1 << VIRTIO_NET_F_MRG_RXBUF ) ) ;\n if ( n -> has_vnet_hdr ) {\n tap_set_offload ( n -> nic -> nc . peer , ( features >> VIRTIO_NET_F_GUEST_CSUM ) & 1 , ( features >> VIRTIO_NET_F_GUEST_TSO4 ) & 1 , ( features >> VIRTIO_NET_F_GUEST_TSO6 ) & 1 , ( features >> VIRTIO_NET_F_GUEST_ECN ) & 1 , ( features >> VIRTIO_NET_F_GUEST_UFO ) & 1 ) ;\n }\n if ( ! n -> nic -> nc . peer || n -> nic -> nc . peer -> info -> type != NET_CLIENT_TYPE_TAP ) {\n return ;\n }\n if ( ! tap_get_vhost_net ( n -> nic -> nc . peer ) ) {\n return ;\n }\n vhost_net_ack_features ( tap_get_vhost_net ( n -> nic -> nc . peer ) , features ) ;\n }", "idx": 21226}
{"hash": 1760449185745615462, "project": "debian", "size": 25, "label": 0, "functionSource": "void TSMimeHdrPrint ( TSMBuffer bufp , TSMLoc obj , TSIOBuffer iobufp ) {\n sdk_assert ( sdk_sanity_check_mbuffer ( bufp ) == TS_SUCCESS ) ;\n sdk_assert ( ( sdk_sanity_check_mime_hdr_handle ( obj ) == TS_SUCCESS ) || ( sdk_sanity_check_http_hdr_handle ( obj ) == TS_SUCCESS ) ) ;\n sdk_assert ( sdk_sanity_check_iocore_structure ( iobufp ) == TS_SUCCESS ) ;\n HdrHeap * heap = ( ( HdrHeapSDKHandle * ) bufp ) -> m_heap ;\n MIMEHdrImpl * mh = _hdr_mloc_to_mime_hdr_impl ( obj ) ;\n MIOBuffer * b = ( MIOBuffer * ) iobufp ;\n IOBufferBlock * blk ;\n int bufindex ;\n int tmp , dumpoffset = 0 ;\n int done ;\n do {\n blk = b -> get_current_block ( ) ;\n if ( ! blk || blk -> write_avail ( ) == 0 ) {\n b -> add_block ( ) ;\n blk = b -> get_current_block ( ) ;\n }\n bufindex = 0 ;\n tmp = dumpoffset ;\n done = mime_hdr_print ( heap , mh , blk -> end ( ) , blk -> write_avail ( ) , & bufindex , & tmp ) ;\n dumpoffset += bufindex ;\n b -> fill ( bufindex ) ;\n }\n while ( ! done ) ;\n }", "idx": 21227}
{"hash": -4558261210024070448, "project": "chrome", "size": 16, "label": 0, "functionSource": "int xmlListPushFront ( xmlListPtr l , void * data ) {\n xmlLinkPtr lkPlace , lkNew ;\n if ( l == NULL ) return ( 0 ) ;\n lkPlace = l -> sentinel ;\n lkNew = ( xmlLinkPtr ) xmlMalloc ( sizeof ( xmlLink ) ) ;\n if ( lkNew == NULL ) {\n xmlGenericError ( xmlGenericErrorContext , \"Cannot initialize memory for new link\" ) ;\n return ( 0 ) ;\n }\n lkNew -> data = data ;\n lkNew -> next = lkPlace -> next ;\n ( lkPlace -> next ) -> prev = lkNew ;\n lkPlace -> next = lkNew ;\n lkNew -> prev = lkPlace ;\n return 1 ;\n }", "idx": 21228}
{"hash": -649112636673899765, "project": "debian", "size": 37, "label": 0, "functionSource": "static int rm_read_multi ( AVFormatContext * s , AVIOContext * pb , AVStream * st , char * mime ) {\n int number_of_streams = avio_rb16 ( pb ) ;\n int number_of_mdpr ;\n int i , ret ;\n unsigned size2 ;\n for ( i = 0 ;\n i < number_of_streams ;\n i ++ ) avio_rb16 ( pb ) ;\n number_of_mdpr = avio_rb16 ( pb ) ;\n if ( number_of_mdpr != 1 ) {\n avpriv_request_sample ( s , \"MLTI with multiple (%d) MDPR\" , number_of_mdpr ) ;\n }\n for ( i = 0 ;\n i < number_of_mdpr ;\n i ++ ) {\n AVStream * st2 ;\n if ( i > 0 ) {\n st2 = avformat_new_stream ( s , NULL ) ;\n if ( ! st2 ) {\n ret = AVERROR ( ENOMEM ) ;\n return ret ;\n }\n st2 -> id = st -> id + ( i << 16 ) ;\n st2 -> codecpar -> bit_rate = st -> codecpar -> bit_rate ;\n st2 -> start_time = st -> start_time ;\n st2 -> duration = st -> duration ;\n st2 -> codecpar -> codec_type = AVMEDIA_TYPE_DATA ;\n st2 -> priv_data = ff_rm_alloc_rmstream ( ) ;\n if ( ! st2 -> priv_data ) return AVERROR ( ENOMEM ) ;\n }\n else st2 = st ;\n size2 = avio_rb32 ( pb ) ;\n ret = ff_rm_read_mdpr_codecdata ( s , s -> pb , st2 , st2 -> priv_data , size2 , mime ) ;\n if ( ret < 0 ) return ret ;\n }\n return 0 ;\n }", "idx": 21229}
{"hash": -1929262071302712016, "project": "debian", "size": 14, "label": 0, "functionSource": "static void * Type_ViewingConditions_Read ( struct _cms_typehandler_struct * self , cmsIOHANDLER * io , cmsUInt32Number * nItems , cmsUInt32Number SizeOfTag ) {\n cmsICCViewingConditions * vc = NULL ;\n vc = ( cmsICCViewingConditions * ) _cmsMallocZero ( self -> ContextID , sizeof ( cmsICCViewingConditions ) ) ;\n if ( vc == NULL ) return NULL ;\n * nItems = 0 ;\n if ( ! _cmsReadXYZNumber ( io , & vc -> IlluminantXYZ ) ) goto Error ;\n if ( ! _cmsReadXYZNumber ( io , & vc -> SurroundXYZ ) ) goto Error ;\n if ( ! _cmsReadUInt32Number ( io , & vc -> IlluminantType ) ) goto Error ;\n * nItems = 1 ;\n return ( void * ) vc ;\n Error : if ( vc != NULL ) _cmsFree ( self -> ContextID , vc ) ;\n return NULL ;\n cmsUNUSED_PARAMETER ( SizeOfTag ) ;\n }", "idx": 21230}
{"hash": -3889154245145551951, "project": "debian", "size": 8, "label": 0, "functionSource": "static uintmax_t parse_mark_ref ( const char * p , char * * endptr ) {\n uintmax_t mark ;\n assert ( * p == ':' ) ;\n p ++ ;\n mark = strtoumax ( p , endptr , 10 ) ;\n if ( * endptr == p ) die ( \"No value after ':' in mark: %s\" , command_buf . buf ) ;\n return mark ;\n }", "idx": 21231}
{"hash": 2895622461494525400, "project": "debian", "size": 29, "label": 0, "functionSource": "static void test_bug8378 ( ) {\n # if defined ( HAVE_CHARSET_gbk ) && ! defined ( EMBEDDED_LIBRARY ) MYSQL * lmysql ;\n char out [ 9 ] ;\n char buf [ 256 ] ;\n int len , rc ;\n myheader ( \"test_bug8378\" ) ;\n if ( ! opt_silent ) fprintf ( stdout , \"\\n Establishing a test connection ...\" ) ;\n if ( ! ( lmysql = mysql_client_init ( NULL ) ) ) {\n myerror ( \"mysql_client_init() failed\" ) ;\n exit ( 1 ) ;\n }\n if ( mysql_options ( lmysql , MYSQL_SET_CHARSET_NAME , \"gbk\" ) ) {\n myerror ( \"mysql_options() failed\" ) ;\n exit ( 1 ) ;\n }\n if ( ! ( mysql_real_connect ( lmysql , opt_host , opt_user , opt_password , current_db , opt_port , opt_unix_socket , 0 ) ) ) {\n myerror ( \"connection failed\" ) ;\n exit ( 1 ) ;\n }\n if ( ! opt_silent ) fprintf ( stdout , \"OK\" ) ;\n rc = mysql_query ( lmysql , \"SET SQL_MODE=''\" ) ;\n myquery ( rc ) ;\n len = mysql_real_escape_string ( lmysql , out , TEST_BUG8378_IN , 4 ) ;\n DIE_UNLESS ( memcmp ( out , TEST_BUG8378_OUT , len ) == 0 ) ;\n sprintf ( buf , \"SELECT '%s'\" , out ) ;\n rc = mysql_real_query ( lmysql , buf , strlen ( buf ) ) ;\n myquery ( rc ) ;\n mysql_close ( lmysql ) ;\n # endif }", "idx": 21232}
{"hash": -7019074708255236794, "project": "debian", "size": 7, "label": 0, "functionSource": "static inline void decode_2p_track ( int * out , int code , int m , int off ) {\n int pos0 = BIT_STR ( code , m , m ) + off ;\n int pos1 = BIT_STR ( code , 0 , m ) + off ;\n out [ 0 ] = BIT_POS ( code , 2 * m ) ? - pos0 : pos0 ;\n out [ 1 ] = BIT_POS ( code , 2 * m ) ? - pos1 : pos1 ;\n out [ 1 ] = pos0 > pos1 ? - out [ 1 ] : out [ 1 ] ;\n }", "idx": 21233}
{"hash": -1102844685921778700, "project": "debian", "size": 68, "label": 0, "functionSource": "static struct archive_string_conv * create_sconv_object ( const char * fc , const char * tc , unsigned current_codepage , int flag ) {\n struct archive_string_conv * sc ;\n sc = calloc ( 1 , sizeof ( * sc ) ) ;\n if ( sc == NULL ) return ( NULL ) ;\n sc -> next = NULL ;\n sc -> from_charset = strdup ( fc ) ;\n if ( sc -> from_charset == NULL ) {\n free ( sc ) ;\n return ( NULL ) ;\n }\n sc -> to_charset = strdup ( tc ) ;\n if ( sc -> to_charset == NULL ) {\n free ( sc -> from_charset ) ;\n free ( sc ) ;\n return ( NULL ) ;\n }\n archive_string_init ( & sc -> utftmp ) ;\n if ( flag & SCONV_TO_CHARSET ) {\n sc -> from_cp = current_codepage ;\n sc -> to_cp = make_codepage_from_charset ( tc ) ;\n # if defined ( _WIN32 ) && ! defined ( __CYGWIN__ ) if ( IsValidCodePage ( sc -> to_cp ) ) flag |= SCONV_WIN_CP ;\n # endif }\n else if ( flag & SCONV_FROM_CHARSET ) {\n sc -> to_cp = current_codepage ;\n sc -> from_cp = make_codepage_from_charset ( fc ) ;\n # if defined ( _WIN32 ) && ! defined ( __CYGWIN__ ) if ( IsValidCodePage ( sc -> from_cp ) ) flag |= SCONV_WIN_CP ;\n # endif }\n if ( strcmp ( fc , tc ) == 0 || ( sc -> from_cp != ( unsigned ) - 1 && sc -> from_cp == sc -> to_cp ) ) sc -> same = 1 ;\n else sc -> same = 0 ;\n if ( strcmp ( tc , \"UTF-8\" ) == 0 ) flag |= SCONV_TO_UTF8 ;\n else if ( strcmp ( tc , \"UTF-16BE\" ) == 0 ) flag |= SCONV_TO_UTF16BE ;\n else if ( strcmp ( tc , \"UTF-16LE\" ) == 0 ) flag |= SCONV_TO_UTF16LE ;\n if ( strcmp ( fc , \"UTF-8\" ) == 0 ) flag |= SCONV_FROM_UTF8 ;\n else if ( strcmp ( fc , \"UTF-16BE\" ) == 0 ) flag |= SCONV_FROM_UTF16BE ;\n else if ( strcmp ( fc , \"UTF-16LE\" ) == 0 ) flag |= SCONV_FROM_UTF16LE ;\n # if defined ( _WIN32 ) && ! defined ( __CYGWIN__ ) if ( sc -> to_cp == CP_UTF8 ) flag |= SCONV_TO_UTF8 ;\n else if ( sc -> to_cp == CP_UTF16BE ) flag |= SCONV_TO_UTF16BE | SCONV_WIN_CP ;\n else if ( sc -> to_cp == CP_UTF16LE ) flag |= SCONV_TO_UTF16LE | SCONV_WIN_CP ;\n if ( sc -> from_cp == CP_UTF8 ) flag |= SCONV_FROM_UTF8 ;\n else if ( sc -> from_cp == CP_UTF16BE ) flag |= SCONV_FROM_UTF16BE | SCONV_WIN_CP ;\n else if ( sc -> from_cp == CP_UTF16LE ) flag |= SCONV_FROM_UTF16LE | SCONV_WIN_CP ;\n # endif if ( ( flag & SCONV_FROM_CHARSET ) && ( flag & ( SCONV_FROM_UTF16 | SCONV_FROM_UTF8 ) ) ) {\n # if defined ( __APPLE__ ) if ( flag & SCONV_TO_UTF8 ) flag |= SCONV_NORMALIZATION_D ;\n else # endif flag |= SCONV_NORMALIZATION_C ;\n }\n # if defined ( __APPLE__ ) if ( ( flag & SCONV_TO_CHARSET ) && ( flag & ( SCONV_FROM_UTF16 | SCONV_FROM_UTF8 ) ) && ! ( flag & ( SCONV_TO_UTF16 | SCONV_TO_UTF8 ) ) ) flag |= SCONV_NORMALIZATION_C ;\n if ( ( flag & SCONV_FROM_CHARSET ) && ! ( flag & ( SCONV_FROM_UTF16 | SCONV_FROM_UTF8 ) ) && ( flag & SCONV_TO_UTF8 ) ) flag |= SCONV_NORMALIZATION_D ;\n # endif # if defined ( HAVE_ICONV ) sc -> cd_w = ( iconv_t ) - 1 ;\n if ( ( ( flag & ( SCONV_TO_UTF8 | SCONV_TO_UTF16 ) ) && ( flag & ( SCONV_FROM_UTF8 | SCONV_FROM_UTF16 ) ) ) || ( flag & SCONV_WIN_CP ) ) {\n sc -> cd = ( iconv_t ) - 1 ;\n }\n else {\n sc -> cd = iconv_open ( tc , fc ) ;\n if ( sc -> cd == ( iconv_t ) - 1 && ( sc -> flag & SCONV_BEST_EFFORT ) ) {\n if ( strcmp ( tc , \"CP932\" ) == 0 ) sc -> cd = iconv_open ( \"SJIS\" , fc ) ;\n else if ( strcmp ( fc , \"CP932\" ) == 0 ) sc -> cd = iconv_open ( tc , \"SJIS\" ) ;\n }\n # if defined ( _WIN32 ) && ! defined ( __CYGWIN__ ) if ( flag & SCONV_FROM_CHARSET ) {\n sc -> cd_w = iconv_open ( \"UTF-8\" , fc ) ;\n if ( sc -> cd_w == ( iconv_t ) - 1 && ( sc -> flag & SCONV_BEST_EFFORT ) ) {\n if ( strcmp ( fc , \"CP932\" ) == 0 ) sc -> cd_w = iconv_open ( \"UTF-8\" , \"SJIS\" ) ;\n }\n }\n # endif }\n # endif sc -> flag = flag ;\n setup_converter ( sc ) ;\n return ( sc ) ;\n }", "idx": 21234}
{"hash": 1859256631654516868, "project": "chrome", "size": 64, "label": 0, "functionSource": "static enum AVPixelFormat get_pixel_format ( H264Context * h , int force_callback ) {\n switch ( h -> sps . bit_depth_luma ) {\n case 9 : if ( CHROMA444 ( h ) ) {\n if ( h -> avctx -> colorspace == AVCOL_SPC_RGB ) {\n return AV_PIX_FMT_GBRP9 ;\n }\n else return AV_PIX_FMT_YUV444P9 ;\n }\n else if ( CHROMA422 ( h ) ) return AV_PIX_FMT_YUV422P9 ;\n else return AV_PIX_FMT_YUV420P9 ;\n break ;\n case 10 : if ( CHROMA444 ( h ) ) {\n if ( h -> avctx -> colorspace == AVCOL_SPC_RGB ) {\n return AV_PIX_FMT_GBRP10 ;\n }\n else return AV_PIX_FMT_YUV444P10 ;\n }\n else if ( CHROMA422 ( h ) ) return AV_PIX_FMT_YUV422P10 ;\n else return AV_PIX_FMT_YUV420P10 ;\n break ;\n case 12 : if ( CHROMA444 ( h ) ) {\n if ( h -> avctx -> colorspace == AVCOL_SPC_RGB ) {\n return AV_PIX_FMT_GBRP12 ;\n }\n else return AV_PIX_FMT_YUV444P12 ;\n }\n else if ( CHROMA422 ( h ) ) return AV_PIX_FMT_YUV422P12 ;\n else return AV_PIX_FMT_YUV420P12 ;\n break ;\n case 14 : if ( CHROMA444 ( h ) ) {\n if ( h -> avctx -> colorspace == AVCOL_SPC_RGB ) {\n return AV_PIX_FMT_GBRP14 ;\n }\n else return AV_PIX_FMT_YUV444P14 ;\n }\n else if ( CHROMA422 ( h ) ) return AV_PIX_FMT_YUV422P14 ;\n else return AV_PIX_FMT_YUV420P14 ;\n break ;\n case 8 : if ( CHROMA444 ( h ) ) {\n if ( h -> avctx -> colorspace == AVCOL_SPC_RGB ) {\n av_log ( h -> avctx , AV_LOG_DEBUG , \"Detected GBR colorspace.\\n\" ) ;\n return AV_PIX_FMT_GBR24P ;\n }\n else if ( h -> avctx -> colorspace == AVCOL_SPC_YCGCO ) {\n av_log ( h -> avctx , AV_LOG_WARNING , \"Detected unsupported YCgCo colorspace.\\n\" ) ;\n }\n return h -> avctx -> color_range == AVCOL_RANGE_JPEG ? AV_PIX_FMT_YUVJ444P : AV_PIX_FMT_YUV444P ;\n }\n else if ( CHROMA422 ( h ) ) {\n return h -> avctx -> color_range == AVCOL_RANGE_JPEG ? AV_PIX_FMT_YUVJ422P : AV_PIX_FMT_YUV422P ;\n }\n else {\n int i ;\n const enum AVPixelFormat * fmt = h -> avctx -> codec -> pix_fmts ? h -> avctx -> codec -> pix_fmts : h -> avctx -> color_range == AVCOL_RANGE_JPEG ? h264_hwaccel_pixfmt_list_jpeg_420 : h264_hwaccel_pixfmt_list_420 ;\n for ( i = 0 ;\n fmt [ i ] != AV_PIX_FMT_NONE ;\n i ++ ) if ( fmt [ i ] == h -> avctx -> pix_fmt && ! force_callback ) return fmt [ i ] ;\n return ff_thread_get_format ( h -> avctx , fmt ) ;\n }\n break ;\n default : av_log ( h -> avctx , AV_LOG_ERROR , \"Unsupported bit depth: %d\\n\" , h -> sps . bit_depth_luma ) ;\n return AVERROR_INVALIDDATA ;\n }\n }", "idx": 21235}
{"hash": 8693230691624196914, "project": "chrome", "size": 3, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( ExtensionPreferenceApiTest , DataReductionProxy ) {\n EXPECT_TRUE ( RunExtensionTest ( \"preference/data_reduction_proxy\" ) ) << message_ ;\n }", "idx": 21236}
{"hash": 7651945086108393719, "project": "debian", "size": 11, "label": 0, "functionSource": "int qemuMonitorJSONGraphicsRelocate ( qemuMonitorPtr mon , int type , const char * hostname , int port , int tlsPort , const char * tlsSubject ) {\n int ret = - 1 ;\n virJSONValuePtr cmd = qemuMonitorJSONMakeCommand ( \"client_migrate_info\" , \"s:protocol\" , ( type == VIR_DOMAIN_GRAPHICS_TYPE_SPICE ? \"spice\" : \"vnc\" ) , \"s:hostname\" , hostname , \"i:port\" , port , \"i:tls-port\" , tlsPort , ( tlsSubject ? \"s:cert-subject\" : NULL ) , ( tlsSubject ? tlsSubject : NULL ) , NULL ) ;\n virJSONValuePtr reply = NULL ;\n if ( ! cmd ) return - 1 ;\n ret = qemuMonitorJSONCommand ( mon , cmd , & reply ) ;\n if ( ret == 0 ) ret = qemuMonitorJSONCheckError ( cmd , reply ) ;\n virJSONValueFree ( cmd ) ;\n virJSONValueFree ( reply ) ;\n return ret ;\n }", "idx": 21237}
{"hash": 8572106347813672436, "project": "debian", "size": 16, "label": 0, "functionSource": "static int pfkey_do_dump ( struct pfkey_sock * pfk ) {\n struct sadb_msg * hdr ;\n int rc ;\n rc = pfk -> dump . dump ( pfk ) ;\n if ( rc == - ENOBUFS ) return 0 ;\n if ( pfk -> dump . skb ) {\n if ( ! pfkey_can_dump ( & pfk -> sk ) ) return 0 ;\n hdr = ( struct sadb_msg * ) pfk -> dump . skb -> data ;\n hdr -> sadb_msg_seq = 0 ;\n hdr -> sadb_msg_errno = rc ;\n pfkey_broadcast ( pfk -> dump . skb , GFP_ATOMIC , BROADCAST_ONE , & pfk -> sk , sock_net ( & pfk -> sk ) ) ;\n pfk -> dump . skb = NULL ;\n }\n pfkey_terminate_dump ( pfk ) ;\n return rc ;\n }", "idx": 21238}
{"hash": -2423144171479606949, "project": "debian", "size": 5, "label": 0, "functionSource": "static void pdf_run_gs_op ( fz_context * ctx , pdf_processor * proc , int b ) {\n pdf_run_processor * pr = ( pdf_run_processor * ) proc ;\n pdf_gstate * gstate = pdf_flush_text ( ctx , pr ) ;\n gstate -> fill . color_params . op = b ;\n }", "idx": 21239}
{"hash": -3569070884878445567, "project": "debian", "size": 123, "label": 1, "functionSource": "static int svq3_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n SVQ3Context * s = avctx -> priv_data ;\n H264Context * h = & s -> h ;\n int buf_size = avpkt -> size ;\n int ret , m , i ;\n if ( buf_size == 0 ) {\n if ( s -> next_pic -> f . data [ 0 ] && ! h -> low_delay && ! s -> last_frame_output ) {\n * ( AVFrame * ) data = s -> next_pic -> f ;\n s -> last_frame_output = 1 ;\n * got_frame = 1 ;\n }\n return 0 ;\n }\n init_get_bits ( & h -> gb , buf , 8 * buf_size ) ;\n h -> mb_x = h -> mb_y = h -> mb_xy = 0 ;\n if ( svq3_decode_slice_header ( avctx ) ) return - 1 ;\n h -> pict_type = h -> slice_type ;\n if ( h -> pict_type != AV_PICTURE_TYPE_B ) FFSWAP ( Picture * , s -> next_pic , s -> last_pic ) ;\n if ( s -> cur_pic -> f . data [ 0 ] ) avctx -> release_buffer ( avctx , & s -> cur_pic -> f ) ;\n s -> cur_pic -> f . pict_type = h -> pict_type ;\n s -> cur_pic -> f . key_frame = ( h -> pict_type == AV_PICTURE_TYPE_I ) ;\n ret = get_buffer ( avctx , s -> cur_pic ) ;\n if ( ret < 0 ) return ret ;\n h -> cur_pic_ptr = s -> cur_pic ;\n h -> cur_pic = * s -> cur_pic ;\n for ( i = 0 ;\n i < 16 ;\n i ++ ) {\n h -> block_offset [ i ] = ( 4 * ( ( scan8 [ i ] - scan8 [ 0 ] ) & 7 ) ) + 4 * h -> linesize * ( ( scan8 [ i ] - scan8 [ 0 ] ) >> 3 ) ;\n h -> block_offset [ 48 + i ] = ( 4 * ( ( scan8 [ i ] - scan8 [ 0 ] ) & 7 ) ) + 8 * h -> linesize * ( ( scan8 [ i ] - scan8 [ 0 ] ) >> 3 ) ;\n }\n for ( i = 0 ;\n i < 16 ;\n i ++ ) {\n h -> block_offset [ 16 + i ] = h -> block_offset [ 32 + i ] = ( 4 * ( ( scan8 [ i ] - scan8 [ 0 ] ) & 7 ) ) + 4 * h -> uvlinesize * ( ( scan8 [ i ] - scan8 [ 0 ] ) >> 3 ) ;\n h -> block_offset [ 48 + 16 + i ] = h -> block_offset [ 48 + 32 + i ] = ( 4 * ( ( scan8 [ i ] - scan8 [ 0 ] ) & 7 ) ) + 8 * h -> uvlinesize * ( ( scan8 [ i ] - scan8 [ 0 ] ) >> 3 ) ;\n }\n if ( h -> pict_type != AV_PICTURE_TYPE_I ) {\n if ( ! s -> last_pic -> f . data [ 0 ] ) {\n av_log ( avctx , AV_LOG_ERROR , \"Missing reference frame.\\n\" ) ;\n ret = get_buffer ( avctx , s -> last_pic ) ;\n if ( ret < 0 ) return ret ;\n memset ( s -> last_pic -> f . data [ 0 ] , 0 , avctx -> height * s -> last_pic -> f . linesize [ 0 ] ) ;\n memset ( s -> last_pic -> f . data [ 1 ] , 0x80 , ( avctx -> height / 2 ) * s -> last_pic -> f . linesize [ 1 ] ) ;\n memset ( s -> last_pic -> f . data [ 2 ] , 0x80 , ( avctx -> height / 2 ) * s -> last_pic -> f . linesize [ 2 ] ) ;\n }\n if ( h -> pict_type == AV_PICTURE_TYPE_B && ! s -> next_pic -> f . data [ 0 ] ) {\n av_log ( avctx , AV_LOG_ERROR , \"Missing reference frame.\\n\" ) ;\n ret = get_buffer ( avctx , s -> next_pic ) ;\n if ( ret < 0 ) return ret ;\n memset ( s -> next_pic -> f . data [ 0 ] , 0 , avctx -> height * s -> next_pic -> f . linesize [ 0 ] ) ;\n memset ( s -> next_pic -> f . data [ 1 ] , 0x80 , ( avctx -> height / 2 ) * s -> next_pic -> f . linesize [ 1 ] ) ;\n memset ( s -> next_pic -> f . data [ 2 ] , 0x80 , ( avctx -> height / 2 ) * s -> next_pic -> f . linesize [ 2 ] ) ;\n }\n }\n if ( avctx -> debug & FF_DEBUG_PICT_INFO ) av_log ( h -> avctx , AV_LOG_DEBUG , \"%c hpel:%d, tpel:%d aqp:%d qp:%d, slice_num:%02X\\n\" , av_get_picture_type_char ( h -> pict_type ) , s -> halfpel_flag , s -> thirdpel_flag , s -> adaptive_quant , h -> qscale , h -> slice_num ) ;\n if ( avctx -> skip_frame >= AVDISCARD_NONREF && h -> pict_type == AV_PICTURE_TYPE_B || avctx -> skip_frame >= AVDISCARD_NONKEY && h -> pict_type != AV_PICTURE_TYPE_I || avctx -> skip_frame >= AVDISCARD_ALL ) return 0 ;\n if ( s -> next_p_frame_damaged ) {\n if ( h -> pict_type == AV_PICTURE_TYPE_B ) return 0 ;\n else s -> next_p_frame_damaged = 0 ;\n }\n if ( h -> pict_type == AV_PICTURE_TYPE_B ) {\n h -> frame_num_offset = h -> slice_num - h -> prev_frame_num ;\n if ( h -> frame_num_offset < 0 ) h -> frame_num_offset += 256 ;\n if ( h -> frame_num_offset == 0 || h -> frame_num_offset >= h -> prev_frame_num_offset ) {\n av_log ( h -> avctx , AV_LOG_ERROR , \"error in B-frame picture id\\n\" ) ;\n return - 1 ;\n }\n }\n else {\n h -> prev_frame_num = h -> frame_num ;\n h -> frame_num = h -> slice_num ;\n h -> prev_frame_num_offset = h -> frame_num - h -> prev_frame_num ;\n if ( h -> prev_frame_num_offset < 0 ) h -> prev_frame_num_offset += 256 ;\n }\n for ( m = 0 ;\n m < 2 ;\n m ++ ) {\n int i ;\n for ( i = 0 ;\n i < 4 ;\n i ++ ) {\n int j ;\n for ( j = - 1 ;\n j < 4 ;\n j ++ ) h -> ref_cache [ m ] [ scan8 [ 0 ] + 8 * i + j ] = 1 ;\n if ( i < 3 ) h -> ref_cache [ m ] [ scan8 [ 0 ] + 8 * i + j ] = PART_NOT_AVAILABLE ;\n }\n }\n for ( h -> mb_y = 0 ;\n h -> mb_y < h -> mb_height ;\n h -> mb_y ++ ) {\n for ( h -> mb_x = 0 ;\n h -> mb_x < h -> mb_width ;\n h -> mb_x ++ ) {\n unsigned mb_type ;\n h -> mb_xy = h -> mb_x + h -> mb_y * h -> mb_stride ;\n if ( ( get_bits_count ( & h -> gb ) + 7 ) >= h -> gb . size_in_bits && ( ( get_bits_count ( & h -> gb ) & 7 ) == 0 || show_bits ( & h -> gb , - get_bits_count ( & h -> gb ) & 7 ) == 0 ) ) {\n skip_bits ( & h -> gb , s -> next_slice_index - get_bits_count ( & h -> gb ) ) ;\n h -> gb . size_in_bits = 8 * buf_size ;\n if ( svq3_decode_slice_header ( avctx ) ) return - 1 ;\n }\n mb_type = svq3_get_ue_golomb ( & h -> gb ) ;\n if ( h -> pict_type == AV_PICTURE_TYPE_I ) mb_type += 8 ;\n else if ( h -> pict_type == AV_PICTURE_TYPE_B && mb_type >= 4 ) mb_type += 4 ;\n if ( mb_type > 33 || svq3_decode_mb ( s , mb_type ) ) {\n av_log ( h -> avctx , AV_LOG_ERROR , \"error while decoding MB %d %d\\n\" , h -> mb_x , h -> mb_y ) ;\n return - 1 ;\n }\n if ( mb_type != 0 ) ff_h264_hl_decode_mb ( h ) ;\n if ( h -> pict_type != AV_PICTURE_TYPE_B && ! h -> low_delay ) h -> cur_pic . f . mb_type [ h -> mb_x + h -> mb_y * h -> mb_stride ] = ( h -> pict_type == AV_PICTURE_TYPE_P && mb_type < 8 ) ? ( mb_type - 1 ) : - 1 ;\n }\n ff_draw_horiz_band ( avctx , NULL , s -> cur_pic , s -> last_pic -> f . data [ 0 ] ? s -> last_pic : NULL , 16 * h -> mb_y , 16 , h -> picture_structure , 0 , 0 , h -> low_delay , h -> mb_height * 16 , h -> mb_width * 16 ) ;\n }\n if ( h -> pict_type == AV_PICTURE_TYPE_B || h -> low_delay ) * ( AVFrame * ) data = s -> cur_pic -> f ;\n else * ( AVFrame * ) data = s -> last_pic -> f ;\n if ( s -> last_pic -> f . data [ 0 ] || h -> low_delay ) * got_frame = 1 ;\n if ( h -> pict_type != AV_PICTURE_TYPE_B ) {\n FFSWAP ( Picture * , s -> cur_pic , s -> next_pic ) ;\n }\n return buf_size ;\n }", "idx": 21240}
{"hash": -1055531103257174901, "project": "debian", "size": 18, "label": 0, "functionSource": "static void sig_complete_window ( GList * * list , WINDOW_REC * window , const char * word , const char * linestart , int * want_space ) {\n WINDOW_REC * win ;\n WI_ITEM_REC * item ;\n GSList * tmp ;\n int len ;\n g_return_if_fail ( list != NULL ) ;\n g_return_if_fail ( word != NULL ) ;\n len = strlen ( word ) ;\n for ( tmp = windows ;\n tmp != NULL ;\n tmp = tmp -> next ) {\n win = tmp -> data ;\n item = win -> active ;\n if ( win -> name != NULL && g_ascii_strncasecmp ( win -> name , word , len ) == 0 ) * list = g_list_append ( * list , g_strdup ( win -> name ) ) ;\n if ( item != NULL && g_ascii_strncasecmp ( item -> visible_name , word , len ) == 0 ) * list = g_list_append ( * list , g_strdup ( item -> visible_name ) ) ;\n }\n if ( * list != NULL ) signal_stop ( ) ;\n }", "idx": 21241}
{"hash": 6336384260629386331, "project": "debian", "size": 6, "label": 0, "functionSource": "void proto_reg_handoff_zbee_zcl_ota ( void ) {\n dissector_handle_t ota_handle ;\n ota_handle = find_dissector ( ZBEE_PROTOABBREV_ZCL_OTA ) ;\n dissector_add_uint ( \"zbee.zcl.cluster\" , ZBEE_ZCL_CID_OTA_UPGRADE , ota_handle ) ;\n zbee_zcl_init_cluster ( proto_zbee_zcl_ota , ett_zbee_zcl_ota , ZBEE_ZCL_CID_OTA_UPGRADE , hf_zbee_zcl_ota_attr_id , hf_zbee_zcl_ota_srv_rx_cmd_id , hf_zbee_zcl_ota_srv_tx_cmd_id , ( zbee_zcl_fn_attr_data ) dissect_zcl_ota_attr_data ) ;\n }", "idx": 21242}
{"hash": 2518148041181868265, "project": "debian", "size": 8, "label": 1, "functionSource": "char * irc_ctcp_dcc_filename_without_quotes ( const char * filename ) {\n int length ;\n length = strlen ( filename ) ;\n if ( length > 0 ) {\n if ( ( filename [ 0 ] == '\\\"' ) && ( filename [ length - 1 ] == '\\\"' ) ) return weechat_strndup ( filename + 1 , length - 2 ) ;\n }\n return strdup ( filename ) ;\n }", "idx": 21243}
{"hash": 8672904772426696383, "project": "debian", "size": 33, "label": 0, "functionSource": "static inline int mpeg4_decode_dc ( MpegEncContext * s , int n , int * dir_ptr ) {\n int level , code ;\n if ( n < 4 ) code = get_vlc2 ( & s -> gb , dc_lum . table , DC_VLC_BITS , 1 ) ;\n else code = get_vlc2 ( & s -> gb , dc_chrom . table , DC_VLC_BITS , 1 ) ;\n if ( code < 0 || code > 9 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"illegal dc vlc\\n\" ) ;\n return - 1 ;\n }\n if ( code == 0 ) {\n level = 0 ;\n }\n else {\n if ( IS_3IV1 ) {\n if ( code == 1 ) level = 2 * get_bits1 ( & s -> gb ) - 1 ;\n else {\n if ( get_bits1 ( & s -> gb ) ) level = get_bits ( & s -> gb , code - 1 ) + ( 1 << ( code - 1 ) ) ;\n else level = - get_bits ( & s -> gb , code - 1 ) - ( 1 << ( code - 1 ) ) ;\n }\n }\n else {\n level = get_xbits ( & s -> gb , code ) ;\n }\n if ( code > 8 ) {\n if ( get_bits1 ( & s -> gb ) == 0 ) {\n if ( s -> err_recognition & AV_EF_BITSTREAM ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"dc marker bit missing\\n\" ) ;\n return - 1 ;\n }\n }\n }\n }\n return ff_mpeg4_pred_dc ( s , n , level , dir_ptr , 0 ) ;\n }", "idx": 21244}
{"hash": 515706766097680840, "project": "chrome", "size": 61, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( SiteDetailsBrowserTest , IsolateExtensionsHostedApps ) {\n GURL app_with_web_iframe_url = embedded_test_server ( ) -> GetURL ( \"app.org\" , \"/cross_site_iframe_factory.html?app.org(b.com)\" ) ;\n GURL app_in_web_iframe_url = embedded_test_server ( ) -> GetURL ( \"b.com\" , \"/cross_site_iframe_factory.html?b.com(app.org)\" ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , app_with_web_iframe_url ) ;\n scoped_refptr < TestMemoryDetails > details = new TestMemoryDetails ( ) ;\n details -> StartFetchAndWait ( ) ;\n EXPECT_THAT ( details -> uma ( ) -> GetAllSamples ( \"SiteIsolation.CurrentRendererProcessCount\" ) , HasOneSample ( GetRenderProcessCount ( ) ) ) ;\n EXPECT_THAT ( details -> uma ( ) -> GetAllSamples ( \"SiteIsolation.IsolateNothingProcessCountEstimate\" ) , HasOneSample ( 1 ) ) ;\n EXPECT_THAT ( details -> uma ( ) -> GetAllSamples ( \"SiteIsolation.IsolateExtensionsProcessCountEstimate\" ) , HasOneSample ( 1 ) ) ;\n EXPECT_THAT ( details -> uma ( ) -> GetAllSamples ( \"SiteIsolation.IsolateExtensionsProcessCountLowerBound\" ) , HasOneSample ( 1 ) ) ;\n EXPECT_THAT ( details -> uma ( ) -> GetAllSamples ( \"SiteIsolation.IsolateExtensionsProcessCountNoLimit\" ) , HasOneSample ( 1 ) ) ;\n EXPECT_THAT ( GetRenderProcessCount ( ) , DependingOnPolicy ( 1 , 1 , 2 ) ) ;\n EXPECT_THAT ( details -> uma ( ) -> GetAllSamples ( \"SiteIsolation.IsolateAllSitesProcessCountEstimate\" ) , HasOneSample ( 2 ) ) ;\n EXPECT_THAT ( details -> uma ( ) -> GetAllSamples ( \"SiteIsolation.IsolateAllSitesProcessCountLowerBound\" ) , HasOneSample ( 2 ) ) ;\n EXPECT_THAT ( details -> uma ( ) -> GetAllSamples ( \"SiteIsolation.IsolateAllSitesProcessCountNoLimit\" ) , HasOneSample ( 2 ) ) ;\n EXPECT_THAT ( GetRenderProcessCount ( ) , DependingOnPolicy ( 1 , 1 , 2 ) ) ;\n EXPECT_THAT ( details -> GetOutOfProcessIframeCount ( ) , DependingOnPolicy ( 0 , 0 , 1 ) ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , app_in_web_iframe_url ) ;\n details = new TestMemoryDetails ( ) ;\n details -> StartFetchAndWait ( ) ;\n EXPECT_THAT ( details -> uma ( ) -> GetAllSamples ( \"SiteIsolation.CurrentRendererProcessCount\" ) , HasOneSample ( GetRenderProcessCount ( ) ) ) ;\n EXPECT_THAT ( details -> uma ( ) -> GetAllSamples ( \"SiteIsolation.IsolateNothingProcessCountEstimate\" ) , HasOneSample ( 1 ) ) ;\n EXPECT_THAT ( details -> uma ( ) -> GetAllSamples ( \"SiteIsolation.IsolateExtensionsProcessCountEstimate\" ) , HasOneSample ( 1 ) ) ;\n EXPECT_THAT ( details -> uma ( ) -> GetAllSamples ( \"SiteIsolation.IsolateExtensionsProcessCountLowerBound\" ) , HasOneSample ( 1 ) ) ;\n EXPECT_THAT ( details -> uma ( ) -> GetAllSamples ( \"SiteIsolation.IsolateExtensionsProcessCountNoLimit\" ) , HasOneSample ( 1 ) ) ;\n EXPECT_THAT ( GetRenderProcessCount ( ) , DependingOnPolicy ( 1 , 1 , 2 ) ) ;\n EXPECT_THAT ( details -> uma ( ) -> GetAllSamples ( \"SiteIsolation.IsolateAllSitesProcessCountEstimate\" ) , HasOneSample ( 2 ) ) ;\n EXPECT_THAT ( details -> uma ( ) -> GetAllSamples ( \"SiteIsolation.IsolateAllSitesProcessCountLowerBound\" ) , HasOneSample ( 2 ) ) ;\n EXPECT_THAT ( details -> uma ( ) -> GetAllSamples ( \"SiteIsolation.IsolateAllSitesProcessCountNoLimit\" ) , HasOneSample ( 2 ) ) ;\n EXPECT_THAT ( GetRenderProcessCount ( ) , DependingOnPolicy ( 1 , 1 , 2 ) ) ;\n EXPECT_THAT ( details -> GetOutOfProcessIframeCount ( ) , DependingOnPolicy ( 0 , 0 , 1 ) ) ;\n CreateHostedApp ( \"App\" , GURL ( \"http://app.org\" ) ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , app_with_web_iframe_url ) ;\n details = new TestMemoryDetails ( ) ;\n details -> StartFetchAndWait ( ) ;\n EXPECT_THAT ( details -> uma ( ) -> GetAllSamples ( \"SiteIsolation.CurrentRendererProcessCount\" ) , HasOneSample ( GetRenderProcessCount ( ) ) ) ;\n EXPECT_THAT ( details -> uma ( ) -> GetAllSamples ( \"SiteIsolation.IsolateNothingProcessCountEstimate\" ) , HasOneSample ( 1 ) ) ;\n EXPECT_THAT ( details -> uma ( ) -> GetAllSamples ( \"SiteIsolation.IsolateExtensionsProcessCountEstimate\" ) , HasOneSample ( 1 ) ) ;\n EXPECT_THAT ( details -> uma ( ) -> GetAllSamples ( \"SiteIsolation.IsolateExtensionsProcessCountLowerBound\" ) , HasOneSample ( 1 ) ) ;\n EXPECT_THAT ( details -> uma ( ) -> GetAllSamples ( \"SiteIsolation.IsolateExtensionsProcessCountNoLimit\" ) , HasOneSample ( 1 ) ) ;\n EXPECT_THAT ( GetRenderProcessCount ( ) , DependingOnPolicy ( 1 , 1 , 2 ) ) ;\n EXPECT_THAT ( details -> uma ( ) -> GetAllSamples ( \"SiteIsolation.IsolateAllSitesProcessCountEstimate\" ) , HasOneSample ( 2 ) ) ;\n EXPECT_THAT ( details -> uma ( ) -> GetAllSamples ( \"SiteIsolation.IsolateAllSitesProcessCountLowerBound\" ) , HasOneSample ( 2 ) ) ;\n EXPECT_THAT ( details -> uma ( ) -> GetAllSamples ( \"SiteIsolation.IsolateAllSitesProcessCountNoLimit\" ) , HasOneSample ( 2 ) ) ;\n EXPECT_THAT ( GetRenderProcessCount ( ) , DependingOnPolicy ( 1 , 1 , 2 ) ) ;\n EXPECT_THAT ( details -> GetOutOfProcessIframeCount ( ) , DependingOnPolicy ( 0 , 0 , 1 ) ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , app_in_web_iframe_url ) ;\n details = new TestMemoryDetails ( ) ;\n details -> StartFetchAndWait ( ) ;\n EXPECT_THAT ( details -> uma ( ) -> GetAllSamples ( \"SiteIsolation.CurrentRendererProcessCount\" ) , HasOneSample ( GetRenderProcessCount ( ) ) ) ;\n EXPECT_THAT ( details -> uma ( ) -> GetAllSamples ( \"SiteIsolation.IsolateNothingProcessCountEstimate\" ) , HasOneSample ( 1 ) ) ;\n EXPECT_THAT ( details -> uma ( ) -> GetAllSamples ( \"SiteIsolation.IsolateExtensionsProcessCountEstimate\" ) , HasOneSample ( 1 ) ) ;\n EXPECT_THAT ( details -> uma ( ) -> GetAllSamples ( \"SiteIsolation.IsolateExtensionsProcessCountLowerBound\" ) , HasOneSample ( 1 ) ) ;\n EXPECT_THAT ( details -> uma ( ) -> GetAllSamples ( \"SiteIsolation.IsolateExtensionsProcessCountNoLimit\" ) , HasOneSample ( 1 ) ) ;\n EXPECT_THAT ( GetRenderProcessCount ( ) , DependingOnPolicy ( 1 , 1 , 2 ) ) ;\n EXPECT_THAT ( details -> uma ( ) -> GetAllSamples ( \"SiteIsolation.IsolateAllSitesProcessCountEstimate\" ) , HasOneSample ( 2 ) ) ;\n EXPECT_THAT ( details -> uma ( ) -> GetAllSamples ( \"SiteIsolation.IsolateAllSitesProcessCountLowerBound\" ) , HasOneSample ( 2 ) ) ;\n EXPECT_THAT ( details -> uma ( ) -> GetAllSamples ( \"SiteIsolation.IsolateAllSitesProcessCountNoLimit\" ) , HasOneSample ( 2 ) ) ;\n EXPECT_THAT ( GetRenderProcessCount ( ) , DependingOnPolicy ( 1 , 1 , 2 ) ) ;\n EXPECT_THAT ( details -> GetOutOfProcessIframeCount ( ) , DependingOnPolicy ( 0 , 0 , 1 ) ) ;\n }", "idx": 21245}
{"hash": -3299391226809811274, "project": "debian", "size": 12, "label": 0, "functionSource": "static int qemuAgentIOWrite ( qemuAgentPtr mon ) {\n int done ;\n if ( ! mon -> msg || mon -> msg -> txOffset == mon -> msg -> txLength ) return 0 ;\n done = safewrite ( mon -> fd , mon -> msg -> txBuffer + mon -> msg -> txOffset , mon -> msg -> txLength - mon -> msg -> txOffset ) ;\n if ( done < 0 ) {\n if ( errno == EAGAIN ) return 0 ;\n virReportSystemError ( errno , \"%s\" , _ ( \"Unable to write to monitor\" ) ) ;\n return - 1 ;\n }\n mon -> msg -> txOffset += done ;\n return done ;\n }", "idx": 21246}
{"hash": -1983921383858884161, "project": "debian", "size": 15, "label": 0, "functionSource": "static int ipvideo_decode_block_opcode_0xC_16 ( IpvideoContext * s , AVFrame * frame ) {\n int x , y ;\n uint16_t * pixel_ptr = ( uint16_t * ) s -> pixel_ptr ;\n for ( y = 0 ;\n y < 8 ;\n y += 2 ) {\n for ( x = 0 ;\n x < 8 ;\n x += 2 ) {\n pixel_ptr [ x ] = pixel_ptr [ x + 1 ] = pixel_ptr [ x + s -> stride ] = pixel_ptr [ x + 1 + s -> stride ] = bytestream2_get_le16 ( & s -> stream_ptr ) ;\n }\n pixel_ptr += s -> stride * 2 ;\n }\n return 0 ;\n }", "idx": 21247}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_CallInformationReq ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_CallInformationReq , CallInformationReq_sequence ) ;\n return offset ;\n }", "idx": 21248}
{"hash": 8461266595329035000, "project": "chrome", "size": 3, "label": 0, "functionSource": "int event_once ( int fd , short events , void ( * callback ) ( int , short , void * ) , void * arg , const struct timeval * tv ) {\n return event_base_once ( current_base , fd , events , callback , arg , tv ) ;\n }", "idx": 21249}
{"hash": 8073241806104522127, "project": "chrome", "size": 24, "label": 0, "functionSource": "TEST_F ( AutocompleteResultTest , Swap ) {\n AutocompleteResult r1 ;\n AutocompleteResult r2 ;\n r1 . Swap ( & r2 ) ;\n EXPECT_EQ ( r1 . end ( ) , r1 . default_match ( ) ) ;\n EXPECT_EQ ( r2 . end ( ) , r2 . default_match ( ) ) ;\n ACMatches matches ;\n AutocompleteMatch match ;\n match . relevance = 1 ;\n match . allowed_to_be_default_match = true ;\n AutocompleteInput input ( base : : ASCIIToUTF16 ( \"a\" ) , base : : string16 : : npos , std : : string ( ) , GURL ( ) , OmniboxEventProto : : INVALID_SPEC , false , false , false , true , false , TestSchemeClassifier ( ) ) ;\n matches . push_back ( match ) ;\n r1 . AppendMatches ( input , matches ) ;\n r1 . SortAndCull ( input , template_url_service_ . get ( ) ) ;\n EXPECT_EQ ( r1 . begin ( ) , r1 . default_match ( ) ) ;\n EXPECT_EQ ( \"http://a/\" , r1 . alternate_nav_url ( ) . spec ( ) ) ;\n r1 . Swap ( & r2 ) ;\n EXPECT_TRUE ( r1 . empty ( ) ) ;\n EXPECT_EQ ( r1 . end ( ) , r1 . default_match ( ) ) ;\n EXPECT_TRUE ( r1 . alternate_nav_url ( ) . is_empty ( ) ) ;\n ASSERT_FALSE ( r2 . empty ( ) ) ;\n EXPECT_EQ ( r2 . begin ( ) , r2 . default_match ( ) ) ;\n EXPECT_EQ ( \"http://a/\" , r2 . alternate_nav_url ( ) . spec ( ) ) ;\n }", "idx": 21250}
{"hash": -8199454075838226273, "project": "debian", "size": 50, "label": 0, "functionSource": "static gint rtmpt_get_amf_length ( tvbuff_t * tvb , gint offset ) {\n guint8 iObjType ;\n gint remain = tvb_reported_length_remaining ( tvb , offset ) ;\n guint32 depth = 0 ;\n gint itemlen = 0 ;\n gint rv = 0 ;\n while ( rv == 0 || depth > 0 ) {\n if ( depth > 0 ) {\n if ( remain - rv < 2 ) return remain ;\n itemlen = tvb_get_ntohs ( tvb , offset + rv ) + 2 ;\n if ( remain - rv < itemlen + 1 ) return remain ;\n rv += itemlen ;\n }\n if ( remain - rv < 1 ) return remain ;\n iObjType = tvb_get_guint8 ( tvb , offset + rv ) ;\n if ( depth > 0 && itemlen == 2 && iObjType == AMF0_END_OF_OBJECT ) {\n rv ++ ;\n depth -- ;\n continue ;\n }\n switch ( iObjType ) {\n case AMF0_NUMBER : itemlen = 9 ;\n break ;\n case AMF0_BOOLEAN : itemlen = 2 ;\n break ;\n case AMF0_STRING : if ( remain - rv < 3 ) return remain ;\n itemlen = tvb_get_ntohs ( tvb , offset + rv + 1 ) + 3 ;\n break ;\n case AMF0_NULL : case AMF0_UNDEFINED : case AMF0_UNSUPPORTED : itemlen = 1 ;\n break ;\n case AMF0_DATE : itemlen = 11 ;\n break ;\n case AMF0_LONG_STRING : case AMF0_XML : if ( remain - rv < 5 ) return remain ;\n itemlen = tvb_get_ntohl ( tvb , offset + rv + 1 ) + 5 ;\n break ;\n case AMF0_INT64 : itemlen = 9 ;\n break ;\n case AMF0_OBJECT : itemlen = 1 ;\n depth ++ ;\n break ;\n case AMF0_ECMA_ARRAY : itemlen = 5 ;\n depth ++ ;\n break ;\n default : return remain ;\n }\n if ( remain - rv < itemlen ) return remain ;\n rv += itemlen ;\n }\n return rv ;\n }", "idx": 21251}
{"hash": -8815658870890288443, "project": "chrome", "size": 3, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( CrossOriginXHR , NoFileAccessAllURLs ) {\n ASSERT_TRUE ( RunExtensionTestNoFileAccess ( \"cross_origin_xhro_file_access_all_urls\" ) ) << message_ ;\n }", "idx": 21252}
{"hash": -5511323081862746166, "project": "debian", "size": 66, "label": 0, "functionSource": "static gboolean process_packet_data ( struct wtap_pkthdr * phdr , Buffer * target , guint8 * buffer , guint record_len , k12_t * k12 , int * err , gchar * * err_info ) {\n guint32 type ;\n guint buffer_offset ;\n guint64 ts ;\n guint32 length ;\n guint32 extra_len ;\n guint32 src_id ;\n k12_src_desc_t * src_desc ;\n type = pntoh32 ( buffer + K12_RECORD_TYPE ) ;\n buffer_offset = ( type == K12_REC_D0020 ) ? K12_PACKET_FRAME_D0020 : K12_PACKET_FRAME ;\n if ( buffer_offset > record_len ) {\n * err = WTAP_ERR_BAD_FILE ;\n * err_info = g_strdup_printf ( \"k12: Frame data offset %u > record length %u\" , buffer_offset , record_len ) ;\n return FALSE ;\n }\n length = pntoh32 ( buffer + K12_RECORD_FRAME_LEN ) & 0x00001FFF ;\n if ( length > record_len - buffer_offset ) {\n * err = WTAP_ERR_BAD_FILE ;\n * err_info = g_strdup_printf ( \"k12: Frame length %u > record frame data %u\" , length , record_len - buffer_offset ) ;\n return FALSE ;\n }\n phdr -> rec_type = REC_TYPE_PACKET ;\n phdr -> presence_flags = WTAP_HAS_TS ;\n ts = pntoh64 ( buffer + K12_PACKET_TIMESTAMP ) ;\n phdr -> ts . secs = ( guint32 ) ( ( ts / 2000000 ) + 631152000 ) ;\n phdr -> ts . nsecs = ( guint32 ) ( ( ts % 2000000 ) * 500 ) ;\n phdr -> len = phdr -> caplen = length ;\n ws_buffer_assure_space ( target , length ) ;\n memcpy ( ws_buffer_start_ptr ( target ) , buffer + buffer_offset , length ) ;\n extra_len = record_len - buffer_offset - length ;\n ws_buffer_assure_space ( & ( k12 -> extra_info ) , extra_len ) ;\n memcpy ( ws_buffer_start_ptr ( & ( k12 -> extra_info ) ) , buffer + buffer_offset + length , extra_len ) ;\n phdr -> pseudo_header . k12 . extra_info = ( guint8 * ) ws_buffer_start_ptr ( & ( k12 -> extra_info ) ) ;\n phdr -> pseudo_header . k12 . extra_length = extra_len ;\n src_id = pntoh32 ( buffer + K12_RECORD_SRC_ID ) ;\n K12_DBG ( 5 , ( \"process_packet_data: src_id=%.8x\" , src_id ) ) ;\n phdr -> pseudo_header . k12 . input = src_id ;\n if ( ! ( src_desc = ( k12_src_desc_t * ) g_hash_table_lookup ( k12 -> src_by_id , GUINT_TO_POINTER ( src_id ) ) ) ) {\n src_desc = ( k12_src_desc_t * ) g_hash_table_lookup ( k12 -> src_by_id , GUINT_TO_POINTER ( src_id & K12_RECORD_SRC_ID_MASK ) ) ;\n }\n if ( src_desc ) {\n K12_DBG ( 5 , ( \"process_packet_data: input_name='%s' stack_file='%s' type=%x\" , src_desc -> input_name , src_desc -> stack_file , src_desc -> input_type ) ) ;\n phdr -> pseudo_header . k12 . input_name = src_desc -> input_name ;\n phdr -> pseudo_header . k12 . stack_file = src_desc -> stack_file ;\n phdr -> pseudo_header . k12 . input_type = src_desc -> input_type ;\n switch ( src_desc -> input_type ) {\n case K12_PORT_ATMPVC : if ( ( long ) ( buffer_offset + length + K12_PACKET_OFFSET_CID ) < record_len ) {\n phdr -> pseudo_header . k12 . input_info . atm . vp = pntoh16 ( buffer + buffer_offset + length + K12_PACKET_OFFSET_VP ) ;\n phdr -> pseudo_header . k12 . input_info . atm . vc = pntoh16 ( buffer + buffer_offset + length + K12_PACKET_OFFSET_VC ) ;\n phdr -> pseudo_header . k12 . input_info . atm . cid = * ( ( unsigned char * ) ( buffer + buffer_offset + length + K12_PACKET_OFFSET_CID ) ) ;\n break ;\n }\n default : memcpy ( & ( phdr -> pseudo_header . k12 . input_info ) , & ( src_desc -> input_info ) , sizeof ( src_desc -> input_info ) ) ;\n break ;\n }\n }\n else {\n K12_DBG ( 5 , ( \"process_packet_data: NO SRC_RECORD FOUND\" ) ) ;\n memset ( & ( phdr -> pseudo_header . k12 ) , 0 , sizeof ( phdr -> pseudo_header . k12 ) ) ;\n phdr -> pseudo_header . k12 . input_name = \"unknown port\" ;\n phdr -> pseudo_header . k12 . stack_file = \"unknown stack file\" ;\n }\n phdr -> pseudo_header . k12 . input = src_id ;\n phdr -> pseudo_header . k12 . stuff = k12 ;\n return TRUE ;\n }", "idx": 21253}
{"hash": 2120840145598099861, "project": "chrome", "size": 3, "label": 0, "functionSource": "static xmlHashTablePtr exsltSaxonInit ( xsltTransformContextPtr ctxt ATTRIBUTE_UNUSED , const xmlChar * URI ATTRIBUTE_UNUSED ) {\n return xmlHashCreate ( 1 ) ;\n }", "idx": 21254}
{"hash": -970074718378997844, "project": "debian", "size": 14, "label": 0, "functionSource": "void ff_mpeg4_clean_buffers ( MpegEncContext * s ) {\n int c_wrap , c_xy , l_wrap , l_xy ;\n l_wrap = s -> b8_stride ;\n l_xy = ( 2 * s -> mb_y - 1 ) * l_wrap + s -> mb_x * 2 - 1 ;\n c_wrap = s -> mb_stride ;\n c_xy = ( s -> mb_y - 1 ) * c_wrap + s -> mb_x - 1 ;\n # if 0 memsetw ( s -> dc_val [ 0 ] + l_xy , 1024 , l_wrap * 2 + 1 ) ;\n memsetw ( s -> dc_val [ 1 ] + c_xy , 1024 , c_wrap + 1 ) ;\n memsetw ( s -> dc_val [ 2 ] + c_xy , 1024 , c_wrap + 1 ) ;\n # endif memset ( s -> ac_val [ 0 ] + l_xy , 0 , ( l_wrap * 2 + 1 ) * 16 * sizeof ( int16_t ) ) ;\n memset ( s -> ac_val [ 1 ] + c_xy , 0 , ( c_wrap + 1 ) * 16 * sizeof ( int16_t ) ) ;\n memset ( s -> ac_val [ 2 ] + c_xy , 0 , ( c_wrap + 1 ) * 16 * sizeof ( int16_t ) ) ;\n s -> last_mv [ 0 ] [ 0 ] [ 0 ] = s -> last_mv [ 0 ] [ 0 ] [ 1 ] = s -> last_mv [ 1 ] [ 0 ] [ 0 ] = s -> last_mv [ 1 ] [ 0 ] [ 1 ] = 0 ;\n }", "idx": 21255}
{"hash": 5825340398912191389, "project": "debian", "size": 4, "label": 0, "functionSource": "extern int name ( int , locale_t ) __THROW __exctype_l ( isalnum_l ) ;\n __exctype_l ( isalpha_l ) ;\n __exctype_l ( iscntrl_l ) ;\n __exctype_l ( isdigit_l )", "idx": 21256}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_T_entryDataType ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_T_entryDataType , T_entryDataType_choice , NULL ) ;\n return offset ;\n }", "idx": 21257}
{"hash": 6250095321513210169, "project": "debian", "size": 10, "label": 0, "functionSource": "rfbBool rfbSendUpdateBuf ( rfbClientPtr cl ) {\n if ( cl -> sock < 0 ) return FALSE ;\n if ( rfbWriteExact ( cl , cl -> updateBuf , cl -> ublen ) < 0 ) {\n rfbLogPerror ( \"rfbSendUpdateBuf: write\" ) ;\n rfbCloseClient ( cl ) ;\n return FALSE ;\n }\n cl -> ublen = 0 ;\n return TRUE ;\n }", "idx": 21258}
{"hash": 2713698759296604855, "project": "debian", "size": 12, "label": 0, "functionSource": "int ff_find_unused_picture ( MpegEncContext * s , int shared ) {\n int ret = find_unused_picture ( s , shared ) ;\n if ( ret >= 0 && ret < MAX_PICTURE_COUNT ) {\n if ( s -> picture [ ret ] . needs_realloc ) {\n s -> picture [ ret ] . needs_realloc = 0 ;\n free_picture_tables ( & s -> picture [ ret ] ) ;\n ff_mpeg_unref_picture ( s , & s -> picture [ ret ] ) ;\n avcodec_get_frame_defaults ( & s -> picture [ ret ] . f ) ;\n }\n }\n return ret ;\n }", "idx": 21259}
{"hash": -3819889754140204145, "project": "debian", "size": 3, "label": 0, "functionSource": "METHOD ( x509_t , get_authKeyIdentifier , chunk_t , private_x509_cert_t * this ) {\n return this -> authKeyIdentifier ;\n }", "idx": 21260}
{"hash": 583170025160259883, "project": "debian", "size": 41, "label": 0, "functionSource": "static int slirp_smb ( SlirpState * s , const char * exported_dir , struct in_addr vserver_addr ) {\n char smb_conf [ 128 ] ;\n char smb_cmdline [ 128 ] ;\n struct passwd * passwd ;\n FILE * f ;\n passwd = getpwuid ( geteuid ( ) ) ;\n if ( ! passwd ) {\n error_report ( \"failed to retrieve user name\" ) ;\n return - 1 ;\n }\n if ( access ( CONFIG_SMBD_COMMAND , F_OK ) ) {\n error_report ( \"could not find '%s', please install it\" , CONFIG_SMBD_COMMAND ) ;\n return - 1 ;\n }\n if ( access ( exported_dir , R_OK | X_OK ) ) {\n error_report ( \"error accessing shared directory '%s': %s\" , exported_dir , strerror ( errno ) ) ;\n return - 1 ;\n }\n snprintf ( s -> smb_dir , sizeof ( s -> smb_dir ) , \"/tmp/qemu-smb.XXXXXX\" ) ;\n if ( ! mkdtemp ( s -> smb_dir ) ) {\n error_report ( \"could not create samba server dir '%s'\" , s -> smb_dir ) ;\n s -> smb_dir [ 0 ] = 0 ;\n return - 1 ;\n }\n snprintf ( smb_conf , sizeof ( smb_conf ) , \"%s/%s\" , s -> smb_dir , \"smb.conf\" ) ;\n f = fopen ( smb_conf , \"w\" ) ;\n if ( ! f ) {\n slirp_smb_cleanup ( s ) ;\n error_report ( \"could not create samba server configuration file '%s'\" , smb_conf ) ;\n return - 1 ;\n }\n fprintf ( f , \"[global]\\n\" \"private dir=%s\\n\" \"interfaces=127.0.0.1\\n\" \"bind interfaces only=yes\\n\" \"pid directory=%s\\n\" \"lock directory=%s\\n\" \"state directory=%s\\n\" \"cache directory=%s\\n\" \"ncalrpc dir=%scalrpc\\n\" \"log file=%s/log.smbd\\n\" \"smb passwd file=%s/smbpasswd\\n\" \"security = user\\n\" \"map to guest = Bad User\\n\" \"load printers = no\\n\" \"printing = bsd\\n\" \"disable spoolss = yes\\n\" \"usershare max shares = 0\\n\" \"[qemu]\\n\" \"path=%s\\n\" \"read only=no\\n\" \"guest ok=yes\\n\" \"force user=%s\\n\" , s -> smb_dir , s -> smb_dir , s -> smb_dir , s -> smb_dir , s -> smb_dir , s -> smb_dir , s -> smb_dir , s -> smb_dir , exported_dir , passwd -> pw_name ) ;\n fclose ( f ) ;\n snprintf ( smb_cmdline , sizeof ( smb_cmdline ) , \"%s -l %s -s %s\" , CONFIG_SMBD_COMMAND , s -> smb_dir , smb_conf ) ;\n if ( slirp_add_exec ( s -> slirp , 0 , smb_cmdline , & vserver_addr , 139 ) < 0 || slirp_add_exec ( s -> slirp , 0 , smb_cmdline , & vserver_addr , 445 ) < 0 ) {\n slirp_smb_cleanup ( s ) ;\n error_report ( \"conflicting/invalid smbserver address\" ) ;\n return - 1 ;\n }\n return 0 ;\n }", "idx": 21261}
{"hash": -3146697469509848825, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dsa_pub_cmp ( const EVP_PKEY * a , const EVP_PKEY * b ) {\n if ( BN_cmp ( b -> pkey . dsa -> pub_key , a -> pkey . dsa -> pub_key ) != 0 ) return 0 ;\n else return 1 ;\n }", "idx": 21262}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_H235Media ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_H235Media , H235Media_sequence ) ;\n return offset ;\n }", "idx": 21263}
{"hash": -3062453801436404700, "project": "debian", "size": 7, "label": 1, "functionSource": "static ossl_inline sk_ ## t1 ## _compfunc sk_ ## t1 ## _set_cmp_func ( STACK_OF ( t1 ) * sk , sk_ ## t1 ## _compfunc compare ) {\n return ( sk_ ## t1 ## _compfunc ) OPENSSL_sk_set_cmp_func ( ( OPENSSL_STACK * ) sk , ( OPENSSL_sk_compfunc ) compare ) ;\n }\n # define DEFINE_SPECIAL_STACK_OF ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , t2 , t2 ) # define DEFINE_STACK_OF ( t ) SKM_DEFINE_STACK_OF ( t , t , t ) # define DEFINE_SPECIAL_STACK_OF_CONST ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , const t2 , t2 ) # define DEFINE_STACK_OF_CONST ( t ) SKM_DEFINE_STACK_OF ( t , const t , t ) typedef char * OPENSSL_STRING ;\n typedef const char * OPENSSL_CSTRING ;\n DEFINE_SPECIAL_STACK_OF ( OPENSSL_STRING , char ) DEFINE_SPECIAL_STACK_OF_CONST ( OPENSSL_CSTRING , char ) typedef void * OPENSSL_BLOCK ;\n DEFINE_SPECIAL_STACK_OF ( OPENSSL_BLOCK , void )", "idx": 21264}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_QOSType ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_QOSType , QOSType_choice , NULL ) ;\n return offset ;\n }", "idx": 21265}
{"hash": 4489017523191997023, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h225_SEQUENCE_OF_ConferenceIdentifier ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence_of ( tvb , offset , actx , tree , hf_index , ett_h225_SEQUENCE_OF_ConferenceIdentifier , SEQUENCE_OF_ConferenceIdentifier_sequence_of ) ;\n return offset ;\n }", "idx": 21266}
{"hash": 2388171415474875762, "project": "debian", "size": 179, "label": 0, "functionSource": "static void dissect_rsvp_ero_rro_subobjects ( proto_tree * ti , packet_info * pinfo , proto_tree * rsvp_object_tree , tvbuff_t * tvb , int offset , int obj_length , int rsvp_class ) {\n int i , j , k , l , flags ;\n proto_tree * ti2 = NULL , * rsvp_ro_subtree , * rsvp_rro_flags_subtree ;\n int tree_type ;\n switch ( rsvp_class ) {\n case RSVP_CLASS_EXPLICIT_ROUTE : tree_type = TREE ( TT_EXPLICIT_ROUTE_SUBOBJ ) ;\n break ;\n case RSVP_CLASS_RECORD_ROUTE : tree_type = TREE ( TT_RECORD_ROUTE_SUBOBJ ) ;\n break ;\n default : return ;\n }\n for ( i = 1 , l = 0 ;\n l < obj_length - 4 ;\n i ++ ) {\n j = tvb_get_guint8 ( tvb , offset + l ) & 0x7f ;\n switch ( j ) {\n case 1 : k = tvb_get_guint8 ( tvb , offset + l ) & 0x80 ;\n rsvp_ro_subtree = proto_tree_add_subtree_format ( rsvp_object_tree , tvb , offset + l , 8 , tree_type , & ti2 , \"IPv4 Subobject - %s%s\" , tvb_ip_to_str ( tvb , offset + l + 2 ) , rsvp_class == RSVP_CLASS_EXPLICIT_ROUTE ? ( k ? \", Loose\" : \", Strict\" ) : \"\" ) ;\n if ( rsvp_class == RSVP_CLASS_EXPLICIT_ROUTE ) proto_tree_add_item ( rsvp_ro_subtree , hf_rsvp_loose_hop , tvb , offset + l , 1 , ENC_NA ) ;\n proto_tree_add_uint_format_value ( rsvp_ro_subtree , hf_rsvp_type , tvb , offset + l , 1 , j , \"1 (IPv4)\" ) ;\n proto_tree_add_item ( rsvp_ro_subtree , hf_rsvp_ero_rro_subobjects_length , tvb , offset + l + 1 , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rsvp_ro_subtree , hf_rsvp_ero_rro_subobjects_ipv4_hop , tvb , offset + l + 2 , 4 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rsvp_ro_subtree , hf_rsvp_ero_rro_subobjects_prefix_length , tvb , offset + l + 6 , 1 , ENC_BIG_ENDIAN ) ;\n if ( i < 4 ) {\n proto_item_append_text ( ti , \"IPv4 %s%s\" , tvb_ip_to_str ( tvb , offset + l + 2 ) , k ? \" [L]\" : \"\" ) ;\n }\n if ( rsvp_class == RSVP_CLASS_RECORD_ROUTE ) {\n flags = tvb_get_guint8 ( tvb , offset + l + 7 ) ;\n if ( flags & 0x20 ) {\n proto_item_append_text ( ti , \" (Node-id)\" ) ;\n proto_item_append_text ( ti2 , \" (Node-id)\" ) ;\n }\n if ( flags & 0x01 ) proto_item_append_text ( ti2 , \", Local Protection Available\" ) ;\n if ( flags & 0x02 ) proto_item_append_text ( ti2 , \", Local Protection In Use\" ) ;\n if ( flags & 0x04 ) proto_item_append_text ( ti2 , \", Backup BW Avail\" ) ;\n if ( flags & 0x08 ) proto_item_append_text ( ti2 , \", Backup is Next-Next-Hop\" ) ;\n ti2 = proto_tree_add_item ( rsvp_ro_subtree , hf_rsvp_ero_rro_subobjects_flags , tvb , offset + l + 7 , 1 , ENC_BIG_ENDIAN ) ;\n rsvp_rro_flags_subtree = proto_item_add_subtree ( ti2 , TREE ( TT_RECORD_ROUTE_SUBOBJ_FLAGS ) ) ;\n proto_tree_add_item ( rsvp_rro_flags_subtree , hf_rsvp_rro_flags_local_avail , tvb , offset + l + 7 , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rsvp_rro_flags_subtree , hf_rsvp_rro_flags_local_in_use , tvb , offset + l + 7 , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rsvp_rro_flags_subtree , hf_rsvp_rro_flags_bandwidth , tvb , offset + l + 7 , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rsvp_rro_flags_subtree , hf_rsvp_rro_flags_node , tvb , offset + l + 7 , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rsvp_rro_flags_subtree , hf_rsvp_rro_flags_node_address , tvb , offset + l + 7 , 1 , ENC_BIG_ENDIAN ) ;\n }\n break ;\n case 2 : rsvp_ro_subtree = proto_tree_add_subtree ( rsvp_object_tree , tvb , offset + l , 20 , tree_type , & ti2 , \"IPv6 Subobject\" ) ;\n k = tvb_get_guint8 ( tvb , offset + l ) & 0x80 ;\n if ( rsvp_class == RSVP_CLASS_EXPLICIT_ROUTE ) proto_tree_add_item ( rsvp_ro_subtree , hf_rsvp_loose_hop , tvb , offset + l , 1 , ENC_NA ) ;\n proto_tree_add_uint_format_value ( rsvp_ro_subtree , hf_rsvp_type , tvb , offset + l , 1 , j , \"2 (IPv6)\" ) ;\n proto_tree_add_item ( rsvp_ro_subtree , hf_rsvp_ero_rro_subobjects_length , tvb , offset + l + 1 , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rsvp_ro_subtree , hf_rsvp_ero_rro_subobjects_ipv6_hop , tvb , offset + l + 2 , 16 , ENC_NA ) ;\n proto_tree_add_item ( rsvp_ro_subtree , hf_rsvp_ero_rro_subobjects_prefix_length , tvb , offset + l + 18 , 1 , ENC_BIG_ENDIAN ) ;\n if ( i < 4 ) {\n proto_item_append_text ( ti , \"IPv6 [...]%s\" , k ? \" [L]\" : \"\" ) ;\n }\n if ( rsvp_class == RSVP_CLASS_RECORD_ROUTE ) {\n flags = tvb_get_guint8 ( tvb , offset + l + 19 ) ;\n if ( flags & 0x20 ) {\n proto_item_append_text ( ti , \" (Node-id)\" ) ;\n proto_item_append_text ( ti2 , \" (Node-id)\" ) ;\n }\n if ( flags & 0x01 ) proto_item_append_text ( ti2 , \", Local Protection Available\" ) ;\n if ( flags & 0x02 ) proto_item_append_text ( ti2 , \", Local Protection In Use\" ) ;\n if ( flags & 0x04 ) proto_item_append_text ( ti2 , \", Backup BW Avail\" ) ;\n if ( flags & 0x08 ) proto_item_append_text ( ti2 , \", Backup is Next-Next-Hop\" ) ;\n ti2 = proto_tree_add_item ( rsvp_ro_subtree , hf_rsvp_ero_rro_subobjects_flags , tvb , offset + l + 19 , 1 , ENC_BIG_ENDIAN ) ;\n rsvp_rro_flags_subtree = proto_item_add_subtree ( ti2 , TREE ( TT_RECORD_ROUTE_SUBOBJ_FLAGS ) ) ;\n proto_tree_add_item ( rsvp_rro_flags_subtree , hf_rsvp_rro_flags_local_avail , tvb , offset + l + 19 , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rsvp_rro_flags_subtree , hf_rsvp_rro_flags_local_in_use , tvb , offset + l + 19 , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rsvp_rro_flags_subtree , hf_rsvp_rro_flags_backup_tunnel_bandwidth , tvb , offset + l + 19 , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rsvp_rro_flags_subtree , hf_rsvp_rro_flags_backup_tunnel_hop , tvb , offset + l + 19 , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rsvp_rro_flags_subtree , hf_rsvp_rro_flags_node_address , tvb , offset + l + 19 , 1 , ENC_BIG_ENDIAN ) ;\n }\n break ;\n case 3 : k = tvb_get_guint8 ( tvb , offset + l ) & 0x80 ;\n rsvp_ro_subtree = proto_tree_add_subtree_format ( rsvp_object_tree , tvb , offset + l , 8 , tree_type , & ti2 , \"Label Subobject - %d, %s\" , tvb_get_ntohl ( tvb , offset + l + 4 ) , rsvp_class == RSVP_CLASS_EXPLICIT_ROUTE ? ( k ? \"Loose\" : \"Strict\" ) : \"\" ) ;\n if ( rsvp_class == RSVP_CLASS_EXPLICIT_ROUTE ) proto_tree_add_item ( rsvp_ro_subtree , hf_rsvp_loose_hop , tvb , offset + l , 1 , ENC_NA ) ;\n proto_tree_add_uint_format_value ( rsvp_ro_subtree , hf_rsvp_type , tvb , offset + l , 1 , j , \"3 (Label)\" ) ;\n proto_tree_add_item ( rsvp_ro_subtree , hf_rsvp_ero_rro_subobjects_length , tvb , offset + l + 1 , 1 , ENC_BIG_ENDIAN ) ;\n if ( rsvp_class == RSVP_CLASS_RECORD_ROUTE ) {\n flags = tvb_get_guint8 ( tvb , offset + l + 2 ) ;\n if ( flags & 0x01 ) proto_item_append_text ( ti2 , \"The label will be understood if received on any interface\" ) ;\n ti2 = proto_tree_add_item ( rsvp_ro_subtree , hf_rsvp_ero_rro_subobjects_flags , tvb , offset + l + 2 , 1 , ENC_BIG_ENDIAN ) ;\n rsvp_rro_flags_subtree = proto_item_add_subtree ( ti2 , TREE ( TT_RECORD_ROUTE_SUBOBJ_FLAGS ) ) ;\n proto_tree_add_item ( rsvp_rro_flags_subtree , hf_rsvp_rro_flags_global_label , tvb , offset + l + 2 , 1 , ENC_BIG_ENDIAN ) ;\n }\n proto_tree_add_item ( rsvp_ro_subtree , hf_rsvp_ctype , tvb , offset + l + 3 , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rsvp_ro_subtree , hf_rsvp_ero_rro_subobjects_label , tvb , offset + l + 4 , 4 , ENC_BIG_ENDIAN ) ;\n if ( i < 4 ) {\n proto_item_append_text ( ti , \"Label %d%s\" , tvb_get_ntohl ( tvb , offset + l + 4 ) , k ? \" [L]\" : \"\" ) ;\n }\n break ;\n case 4 : k = tvb_get_guint8 ( tvb , offset + l ) & 0x80 ;\n rsvp_ro_subtree = proto_tree_add_subtree_format ( rsvp_object_tree , tvb , offset + l , 8 , tree_type , & ti2 , \"Unnumbered Interface-ID - %s, %d, %s\" , tvb_ip_to_str ( tvb , offset + l + 4 ) , tvb_get_ntohl ( tvb , offset + l + 8 ) , rsvp_class == RSVP_CLASS_EXPLICIT_ROUTE ? ( k ? \"Loose\" : \"Strict\" ) : \"\" ) ;\n if ( rsvp_class == RSVP_CLASS_EXPLICIT_ROUTE ) proto_tree_add_item ( rsvp_ro_subtree , hf_rsvp_loose_hop , tvb , offset + l , 1 , ENC_NA ) ;\n proto_tree_add_uint_format_value ( rsvp_ro_subtree , hf_rsvp_type , tvb , offset + l , 1 , j , \"4 (Unnumbered Interface-ID)\" ) ;\n proto_tree_add_item ( rsvp_ro_subtree , hf_rsvp_ero_rro_subobjects_length , tvb , offset + l + 1 , 1 , ENC_BIG_ENDIAN ) ;\n if ( rsvp_class == RSVP_CLASS_RECORD_ROUTE ) {\n flags = tvb_get_guint8 ( tvb , offset + l + 2 ) ;\n if ( flags & 0x01 ) proto_item_append_text ( ti2 , \", Local Protection Available\" ) ;\n if ( flags & 0x02 ) proto_item_append_text ( ti2 , \", Local Protection In Use\" ) ;\n ti2 = proto_tree_add_item ( rsvp_ro_subtree , hf_rsvp_ero_rro_subobjects_flags , tvb , offset + l + 2 , 1 , ENC_BIG_ENDIAN ) ;\n rsvp_rro_flags_subtree = proto_item_add_subtree ( ti2 , TREE ( TT_RECORD_ROUTE_SUBOBJ_FLAGS ) ) ;\n proto_tree_add_item ( rsvp_rro_flags_subtree , hf_rsvp_rro_flags_local_avail , tvb , offset + l + 2 , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rsvp_rro_flags_subtree , hf_rsvp_rro_flags_local_in_use , tvb , offset + l + 2 , 1 , ENC_BIG_ENDIAN ) ;\n }\n proto_tree_add_item ( rsvp_ro_subtree , hf_rsvp_ero_rro_subobjects_router_id , tvb , offset + l + 4 , 4 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rsvp_ro_subtree , hf_rsvp_ero_rro_subobjects_interface_id , tvb , offset + l + 8 , 4 , ENC_BIG_ENDIAN ) ;\n if ( i < 4 ) {\n proto_item_append_text ( ti , \"Unnum %s/%d%s\" , tvb_ip_to_str ( tvb , offset + l + 4 ) , tvb_get_ntohl ( tvb , offset + l + 8 ) , k ? \" [L]\" : \"\" ) ;\n }\n break ;\n case 32 : if ( rsvp_class == RSVP_CLASS_RECORD_ROUTE ) goto defaultsub ;\n k = tvb_get_ntohs ( tvb , offset + l + 2 ) ;\n rsvp_ro_subtree = proto_tree_add_subtree_format ( rsvp_object_tree , tvb , offset + l , 4 , tree_type , & ti2 , \"Autonomous System %u\" , k ) ;\n proto_tree_add_uint_format_value ( rsvp_ro_subtree , hf_rsvp_type , tvb , offset + l , 1 , j , \"32 (Autonomous System Number)\" ) ;\n proto_tree_add_item ( rsvp_ro_subtree , hf_rsvp_ero_rro_subobjects_length , tvb , offset + l + 1 , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rsvp_ro_subtree , hf_rsvp_ero_rro_autonomous_system , tvb , offset + l + 2 , 2 , ENC_BIG_ENDIAN ) ;\n if ( i < 4 ) {\n proto_item_append_text ( ti , \"AS %d\" , tvb_get_ntohs ( tvb , offset + l + 2 ) ) ;\n }\n break ;\n case 64 : if ( rsvp_class == RSVP_CLASS_RECORD_ROUTE ) goto defaultsub ;\n k = tvb_get_ntohs ( tvb , offset + l + 2 ) ;\n rsvp_ro_subtree = proto_tree_add_subtree_format ( rsvp_object_tree , tvb , offset + l , 8 , tree_type , & ti2 , \"Path Key subobject - %s, %u\" , tvb_ip_to_str ( tvb , offset + l + 4 ) , k ) ;\n proto_tree_add_uint_format_value ( rsvp_ro_subtree , hf_rsvp_type , tvb , offset + l , 1 , j , \"64 (Path Key with IPv4 PCE-ID)\" ) ;\n proto_tree_add_item ( rsvp_ro_subtree , hf_rsvp_ero_rro_subobjects_length , tvb , offset + l + 1 , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rsvp_ro_subtree , hf_rsvp_ero_rro_subobjects_path_key , tvb , offset + l + 2 , 2 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rsvp_ro_subtree , hf_rsvp_ero_rro_subobjects_pce_id_ipv4 , tvb , offset + l + 4 , 4 , ENC_BIG_ENDIAN ) ;\n if ( i < 4 ) {\n proto_item_append_text ( ti , \"Path Key %d\" , k ) ;\n }\n break ;\n case 65 : if ( rsvp_class == RSVP_CLASS_RECORD_ROUTE ) goto defaultsub ;\n k = tvb_get_ntohs ( tvb , offset + l + 2 ) ;\n rsvp_ro_subtree = proto_tree_add_subtree_format ( rsvp_object_tree , tvb , offset + l , 8 , tree_type , & ti2 , \"Path Key subobject - %s, %u\" , tvb_ip6_to_str ( tvb , offset + l + 4 ) , k ) ;\n proto_tree_add_uint_format_value ( rsvp_ro_subtree , hf_rsvp_type , tvb , offset + l , 1 , j , \"65 (Path Key with IPv6 PCE-ID)\" ) ;\n proto_tree_add_item ( rsvp_ro_subtree , hf_rsvp_ero_rro_subobjects_length , tvb , offset + l + 1 , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rsvp_ro_subtree , hf_rsvp_ero_rro_subobjects_path_key , tvb , offset + l + 2 , 2 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rsvp_ro_subtree , hf_rsvp_ero_rro_subobjects_pce_id_ipv6 , tvb , offset + l + 4 , 16 , ENC_NA ) ;\n if ( i < 4 ) {\n proto_item_append_text ( ti , \"Path Key %d\" , k ) ;\n }\n break ;\n case 124 : case 125 : case 126 : case 127 : if ( rsvp_class == RSVP_CLASS_RECORD_ROUTE ) goto defaultsub ;\n else goto privatesub ;\n break ;\n case 252 : case 253 : case 254 : case 255 : if ( rsvp_class == RSVP_CLASS_EXPLICIT_ROUTE ) goto defaultsub ;\n else goto privatesub ;\n break ;\n privatesub : {\n guint8 private_so_len = tvb_get_guint8 ( tvb , offset + l + 1 ) ;\n rsvp_ro_subtree = proto_tree_add_subtree_format ( rsvp_object_tree , tvb , offset + l , tvb_get_guint8 ( tvb , offset + l + 1 ) , tree_type , & ti2 , \"Private Subobject: %d\" , j ) ;\n proto_tree_add_item ( rsvp_ro_subtree , hf_rsvp_loose_hop , tvb , offset + l , 1 , ENC_NA ) ;\n proto_tree_add_uint_format_value ( rsvp_ro_subtree , hf_rsvp_type , tvb , offset + l , 1 , j , \"%u (Private)\" , j ) ;\n proto_tree_add_item ( rsvp_ro_subtree , hf_rsvp_ero_rro_subobjects_private_length , tvb , offset + l + 1 , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rsvp_ro_subtree , hf_rsvp_filter [ RSVPF_ENT_CODE ] , tvb , offset + l + 4 , 4 , ENC_BIG_ENDIAN ) ;\n if ( private_so_len > 8 ) {\n proto_tree_add_item ( rsvp_ro_subtree , hf_rsvp_ero_rro_subobjects_private_data , tvb , offset + l + 8 , private_so_len - 8 , ENC_NA ) ;\n }\n }\n break ;\n default : defaultsub : rsvp_ro_subtree = proto_tree_add_subtree_format ( rsvp_object_tree , tvb , offset + l , tvb_get_guint8 ( tvb , offset + l + 1 ) , tree_type , & ti2 , \"Unknown subobject: %d\" , j ) ;\n proto_tree_add_item ( rsvp_ro_subtree , hf_rsvp_loose_hop , tvb , offset + l , 1 , ENC_NA ) ;\n proto_tree_add_uint_format_value ( rsvp_ro_subtree , hf_rsvp_type , tvb , offset + l , 1 , j , \"%u (Unknown)\" , j ) ;\n proto_tree_add_item ( rsvp_ro_subtree , hf_rsvp_ero_rro_subobjects_length , tvb , offset + l + 1 , 1 , ENC_BIG_ENDIAN ) ;\n break ;\n }\n if ( tvb_get_guint8 ( tvb , offset + l + 1 ) < 1 ) {\n proto_tree_add_expert_format ( rsvp_ro_subtree , pinfo , & ei_rsvp_invalid_length , tvb , offset + l + 1 , 1 , \"Invalid length: %u\" , tvb_get_guint8 ( tvb , offset + l + 1 ) ) ;\n return ;\n }\n l += tvb_get_guint8 ( tvb , offset + l + 1 ) ;\n if ( l < obj_length - 4 ) {\n if ( i < 4 ) proto_item_append_text ( ti , \", \" ) ;\n else if ( i == 4 ) proto_item_append_text ( ti , \"...\" ) ;\n }\n }\n }", "idx": 21267}
{"hash": -4558261210024070448, "project": "chrome", "size": 17, "label": 1, "functionSource": "int xmlListInsert ( xmlListPtr l , void * data ) {\n xmlLinkPtr lkPlace , lkNew ;\n if ( l == NULL ) return ( 1 ) ;\n lkPlace = xmlListLowerSearch ( l , data ) ;\n lkNew = ( xmlLinkPtr ) xmlMalloc ( sizeof ( xmlLink ) ) ;\n if ( lkNew == NULL ) {\n xmlGenericError ( xmlGenericErrorContext , \"Cannot initialize memory for new link\" ) ;\n return ( 1 ) ;\n }\n lkNew -> data = data ;\n lkPlace = lkPlace -> prev ;\n lkNew -> next = lkPlace -> next ;\n ( lkPlace -> next ) -> prev = lkNew ;\n lkPlace -> next = lkNew ;\n lkNew -> prev = lkPlace ;\n return 0 ;\n }", "idx": 21268}
{"hash": -6552851419396579257, "project": "debian", "size": 27, "label": 0, "functionSource": "static int SpoolssGetPrinterDriver2_r ( tvbuff_t * tvb , int offset , packet_info * pinfo , proto_tree * tree , dcerpc_info * di , guint8 * drep ) {\n dcerpc_call_value * dcv = ( dcerpc_call_value * ) di -> call_data ;\n guint32 level = GPOINTER_TO_UINT ( dcv -> se_data ) ;\n BUFFER buffer ;\n offset = dissect_spoolss_buffer ( tvb , offset , pinfo , tree , di , drep , & buffer ) ;\n if ( buffer . tvb ) {\n switch ( level ) {\n case 1 : dissect_DRIVER_INFO_1 ( buffer . tvb , 0 , pinfo , buffer . tree , di , drep ) ;\n break ;\n case 2 : dissect_DRIVER_INFO_2 ( buffer . tvb , 0 , pinfo , buffer . tree , di , drep ) ;\n break ;\n case 3 : dissect_DRIVER_INFO_3 ( buffer . tvb , 0 , pinfo , buffer . tree , di , drep ) ;\n break ;\n case 6 : dissect_DRIVER_INFO_6 ( buffer . tvb , 0 , pinfo , buffer . tree , di , drep ) ;\n break ;\n case 101 : dissect_DRIVER_INFO_101 ( buffer . tvb , 0 , pinfo , buffer . tree , di , drep ) ;\n break ;\n default : proto_tree_add_expert_format ( buffer . tree , pinfo , & ei_driver_info_level , buffer . tvb , 0 , - 1 , \"Unknown driver info level %d\" , level ) ;\n break ;\n }\n }\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , tree , di , drep , hf_needed , NULL ) ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , tree , di , drep , hf_servermajorversion , NULL ) ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , tree , di , drep , hf_serverminorversion , NULL ) ;\n offset = dissect_doserror ( tvb , offset , pinfo , tree , di , drep , hf_rc , NULL ) ;\n return offset ;\n }", "idx": 21269}
{"hash": 1760449185745615462, "project": "debian", "size": 17, "label": 0, "functionSource": "TSReturnCode TSPluginRegister ( const TSPluginRegistrationInfo * plugin_info ) {\n sdk_assert ( sdk_sanity_check_null_ptr ( ( void * ) plugin_info ) == TS_SUCCESS ) ;\n if ( ! plugin_reg_current ) {\n return TS_ERROR ;\n }\n plugin_reg_current -> plugin_registered = true ;\n if ( plugin_info -> plugin_name ) {\n plugin_reg_current -> plugin_name = ats_strdup ( plugin_info -> plugin_name ) ;\n }\n if ( plugin_info -> vendor_name ) {\n plugin_reg_current -> vendor_name = ats_strdup ( plugin_info -> vendor_name ) ;\n }\n if ( plugin_info -> support_email ) {\n plugin_reg_current -> support_email = ats_strdup ( plugin_info -> support_email ) ;\n }\n return TS_SUCCESS ;\n }", "idx": 21270}
{"hash": 6028689830752105670, "project": "debian", "size": 7, "label": 0, "functionSource": "static void mspack_fmap_free ( void * mem ) {\n if ( mem ) {\n free ( mem ) ;\n mem = NULL ;\n }\n return ;\n }", "idx": 21271}
{"hash": 355220887711506893, "project": "debian", "size": 3, "label": 0, "functionSource": "Datum iclikejoinsel ( PG_FUNCTION_ARGS ) {\n PG_RETURN_FLOAT8 ( patternjoinsel ( fcinfo , Pattern_Type_Like_IC , false ) ) ;\n }", "idx": 21272}
{"hash": 2315393806700093389, "project": "chrome", "size": 23, "label": 0, "functionSource": "static void convolve_avg_vert ( const uint8_t * src , ptrdiff_t src_stride , uint8_t * dst , ptrdiff_t dst_stride , const InterpKernel * y_filters , int y0_q4 , int y_step_q4 , int w , int h ) {\n int x , y ;\n src -= src_stride * ( SUBPEL_TAPS / 2 - 1 ) ;\n for ( x = 0 ;\n x < w ;\n ++ x ) {\n int y_q4 = y0_q4 ;\n for ( y = 0 ;\n y < h ;\n ++ y ) {\n const unsigned char * src_y = & src [ ( y_q4 >> SUBPEL_BITS ) * src_stride ] ;\n const int16_t * const y_filter = y_filters [ y_q4 & SUBPEL_MASK ] ;\n int k , sum = 0 ;\n for ( k = 0 ;\n k < SUBPEL_TAPS ;\n ++ k ) sum += src_y [ k * src_stride ] * y_filter [ k ] ;\n dst [ y * dst_stride ] = ROUND_POWER_OF_TWO ( dst [ y * dst_stride ] + clip_pixel ( ROUND_POWER_OF_TWO ( sum , FILTER_BITS ) ) , 1 ) ;\n y_q4 += y_step_q4 ;\n }\n ++ src ;\n ++ dst ;\n }\n }", "idx": 21273}
{"hash": -5992472514718425579, "project": "debian", "size": 5, "label": 0, "functionSource": "static const char * cgfs_get_cgroup ( void * hdata , const char * subsystem ) {\n struct cgfs_data * d = hdata ;\n if ( ! d ) return NULL ;\n return lxc_cgroup_get_hierarchy_path_data ( subsystem , d ) ;\n }", "idx": 21274}
{"hash": 2895622461494525400, "project": "debian", "size": 73, "label": 0, "functionSource": "static void test_null ( ) {\n MYSQL_STMT * stmt ;\n int rc ;\n uint nData ;\n MYSQL_BIND my_bind [ 2 ] ;\n my_bool is_null [ 2 ] ;\n char query [ MAX_TEST_QUERY_LENGTH ] ;\n myheader ( \"test_null\" ) ;\n rc = mysql_query ( mysql , \"DROP TABLE IF EXISTS test_null\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"CREATE TABLE test_null(col1 int, col2 varchar(50))\" ) ;\n myquery ( rc ) ;\n strmov ( query , \"INSERT INTO test_null(col3, col2) VALUES(?, ?)\" ) ;\n stmt = mysql_simple_prepare ( mysql , query ) ;\n check_stmt_r ( stmt ) ;\n strmov ( query , \"INSERT INTO test_null(col1, col2) VALUES(?, ?)\" ) ;\n stmt = mysql_simple_prepare ( mysql , query ) ;\n check_stmt ( stmt ) ;\n verify_param_count ( stmt , 2 ) ;\n memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n my_bind [ 0 ] . buffer_type = MYSQL_TYPE_LONG ;\n my_bind [ 0 ] . is_null = & is_null [ 0 ] ;\n is_null [ 0 ] = 1 ;\n my_bind [ 1 ] = my_bind [ 0 ] ;\n rc = mysql_stmt_bind_param ( stmt , my_bind ) ;\n check_execute ( stmt , rc ) ;\n for ( nData = 0 ;\n nData < 10 ;\n nData ++ ) {\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n }\n my_bind [ 0 ] . buffer_type = MYSQL_TYPE_NULL ;\n is_null [ 0 ] = 0 ;\n my_bind [ 1 ] = my_bind [ 0 ] ;\n rc = mysql_stmt_bind_param ( stmt , my_bind ) ;\n check_execute ( stmt , rc ) ;\n for ( nData = 0 ;\n nData < 10 ;\n nData ++ ) {\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n }\n mysql_stmt_close ( stmt ) ;\n rc = mysql_commit ( mysql ) ;\n myquery ( rc ) ;\n nData *= 2 ;\n rc = my_stmt_result ( \"SELECT * FROM test_null\" ) ;\n ;\n DIE_UNLESS ( ( int ) nData == rc ) ;\n my_bind [ 0 ] . buffer_type = MYSQL_TYPE_LONG ;\n my_bind [ 0 ] . buffer = ( void * ) & nData ;\n my_bind [ 0 ] . length = 0 ;\n my_bind [ 1 ] = my_bind [ 0 ] ;\n my_bind [ 0 ] . is_null = & is_null [ 0 ] ;\n my_bind [ 1 ] . is_null = & is_null [ 1 ] ;\n stmt = mysql_simple_prepare ( mysql , \"SELECT * FROM test_null\" ) ;\n check_stmt ( stmt ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n rc = mysql_stmt_bind_result ( stmt , my_bind ) ;\n check_execute ( stmt , rc ) ;\n rc = 0 ;\n is_null [ 0 ] = is_null [ 1 ] = 0 ;\n while ( mysql_stmt_fetch ( stmt ) != MYSQL_NO_DATA ) {\n DIE_UNLESS ( is_null [ 0 ] ) ;\n DIE_UNLESS ( is_null [ 1 ] ) ;\n rc ++ ;\n is_null [ 0 ] = is_null [ 1 ] = 0 ;\n }\n DIE_UNLESS ( rc == ( int ) nData ) ;\n mysql_stmt_close ( stmt ) ;\n }", "idx": 21275}
{"hash": -5602110576334023565, "project": "debian", "size": 16, "label": 0, "functionSource": "static int allocate_buffers ( ALACContext * alac ) {\n int ch ;\n int buf_size = alac -> max_samples_per_frame * sizeof ( int32_t ) ;\n for ( ch = 0 ;\n ch < FFMIN ( alac -> channels , 2 ) ;\n ch ++ ) {\n FF_ALLOC_OR_GOTO ( alac -> avctx , alac -> predict_error_buffer [ ch ] , buf_size , buf_alloc_fail ) ;\n if ( alac -> sample_size == 16 ) {\n FF_ALLOC_OR_GOTO ( alac -> avctx , alac -> output_samples_buffer [ ch ] , buf_size , buf_alloc_fail ) ;\n }\n FF_ALLOC_OR_GOTO ( alac -> avctx , alac -> extra_bits_buffer [ ch ] , buf_size , buf_alloc_fail ) ;\n }\n return 0 ;\n buf_alloc_fail : alac_decode_close ( alac -> avctx ) ;\n return AVERROR ( ENOMEM ) ;\n }", "idx": 21276}
{"hash": 3487622904170815119, "project": "debian", "size": 84, "label": 0, "functionSource": "static int decode_cell ( Indeo3DecodeContext * ctx , AVCodecContext * avctx , Plane * plane , Cell * cell , const uint8_t * data_ptr , const uint8_t * last_ptr ) {\n int x , mv_x , mv_y , mode , vq_index , prim_indx , second_indx ;\n int zoom_fac ;\n int offset , error = 0 , swap_quads [ 2 ] ;\n uint8_t code , * block , * ref_block = 0 ;\n const vqEntry * delta [ 2 ] ;\n const uint8_t * data_start = data_ptr ;\n code = * data_ptr ++ ;\n mode = code >> 4 ;\n vq_index = code & 0xF ;\n offset = ( cell -> ypos << 2 ) * plane -> pitch + ( cell -> xpos << 2 ) ;\n block = plane -> pixels [ ctx -> buf_sel ] + offset ;\n if ( ! cell -> mv_ptr ) {\n ref_block = block - plane -> pitch ;\n }\n else if ( mode >= 10 ) {\n copy_cell ( ctx , plane , cell ) ;\n }\n else {\n mv_y = cell -> mv_ptr [ 0 ] ;\n mv_x = cell -> mv_ptr [ 1 ] ;\n offset += mv_y * plane -> pitch + mv_x ;\n ref_block = plane -> pixels [ ctx -> buf_sel ^ 1 ] + offset ;\n }\n if ( mode == 1 || mode == 4 ) {\n code = ctx -> alt_quant [ vq_index ] ;\n prim_indx = ( code >> 4 ) + ctx -> cb_offset ;\n second_indx = ( code & 0xF ) + ctx -> cb_offset ;\n }\n else {\n vq_index += ctx -> cb_offset ;\n prim_indx = second_indx = vq_index ;\n }\n if ( prim_indx >= 24 || second_indx >= 24 ) {\n av_log ( avctx , AV_LOG_ERROR , \"Invalid VQ table indexes! Primary: %d, secondary: %d!\\n\" , prim_indx , second_indx ) ;\n return AVERROR_INVALIDDATA ;\n }\n delta [ 0 ] = & vq_tab [ second_indx ] ;\n delta [ 1 ] = & vq_tab [ prim_indx ] ;\n swap_quads [ 0 ] = second_indx >= 16 ;\n swap_quads [ 1 ] = prim_indx >= 16 ;\n if ( vq_index >= 8 && ref_block ) {\n for ( x = 0 ;\n x < cell -> width << 2 ;\n x ++ ) ref_block [ x ] = requant_tab [ vq_index & 7 ] [ ref_block [ x ] ] ;\n }\n error = IV3_NOERR ;\n switch ( mode ) {\n case 0 : case 1 : case 3 : case 4 : if ( mode >= 3 && cell -> mv_ptr ) {\n av_log ( avctx , AV_LOG_ERROR , \"Attempt to apply Mode 3/4 to an INTER cell!\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n zoom_fac = mode >= 3 ;\n error = decode_cell_data ( ctx , cell , block , ref_block , plane -> pitch , 0 , zoom_fac , mode , delta , swap_quads , & data_ptr , last_ptr ) ;\n break ;\n case 10 : case 11 : if ( mode == 10 && ! cell -> mv_ptr ) {\n error = decode_cell_data ( ctx , cell , block , ref_block , plane -> pitch , 1 , 1 , mode , delta , swap_quads , & data_ptr , last_ptr ) ;\n }\n else {\n if ( mode == 11 && ! cell -> mv_ptr ) {\n av_log ( avctx , AV_LOG_ERROR , \"Attempt to use Mode 11 for an INTRA cell!\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n zoom_fac = mode == 10 ;\n error = decode_cell_data ( ctx , cell , block , ref_block , plane -> pitch , zoom_fac , 1 , mode , delta , swap_quads , & data_ptr , last_ptr ) ;\n }\n break ;\n default : av_log ( avctx , AV_LOG_ERROR , \"Unsupported coding mode: %d\\n\" , mode ) ;\n return AVERROR_INVALIDDATA ;\n }\n switch ( error ) {\n case IV3_BAD_RLE : av_log ( avctx , AV_LOG_ERROR , \"Mode %d: RLE code %X is not allowed at the current line\\n\" , mode , data_ptr [ - 1 ] ) ;\n return AVERROR_INVALIDDATA ;\n case IV3_BAD_DATA : av_log ( avctx , AV_LOG_ERROR , \"Mode %d: invalid VQ data\\n\" , mode ) ;\n return AVERROR_INVALIDDATA ;\n case IV3_BAD_COUNTER : av_log ( avctx , AV_LOG_ERROR , \"Mode %d: RLE-FB invalid counter: %d\\n\" , mode , code ) ;\n return AVERROR_INVALIDDATA ;\n case IV3_UNSUPPORTED : av_log ( avctx , AV_LOG_ERROR , \"Mode %d: unsupported RLE code: %X\\n\" , mode , data_ptr [ - 1 ] ) ;\n return AVERROR_INVALIDDATA ;\n case IV3_OUT_OF_DATA : av_log ( avctx , AV_LOG_ERROR , \"Mode %d: attempt to read past end of buffer\\n\" , mode ) ;\n return AVERROR_INVALIDDATA ;\n }\n return data_ptr - data_start ;\n }", "idx": 21277}
{"hash": -3146697469509848825, "project": "debian", "size": 9, "label": 0, "functionSource": "static int dsa_param_decode ( EVP_PKEY * pkey , const unsigned char * * pder , int derlen ) {\n DSA * dsa ;\n if ( ( dsa = d2i_DSAparams ( NULL , pder , derlen ) ) == NULL ) {\n DSAerr ( DSA_F_DSA_PARAM_DECODE , ERR_R_DSA_LIB ) ;\n return 0 ;\n }\n EVP_PKEY_assign_DSA ( pkey , dsa ) ;\n return 1 ;\n }", "idx": 21278}
{"hash": 1208165234047591297, "project": "debian", "size": 22, "label": 0, "functionSource": "void parseArraySimple ( proto_tree * tree , tvbuff_t * tvb , packet_info * pinfo , gint * pOffset , const char * szFieldName , const char * szTypeName , int hfIndex , fctSimpleTypeParser pParserFunction , const gint idx ) {\n proto_item * ti ;\n proto_tree * subtree = proto_tree_add_subtree_format ( tree , tvb , * pOffset , - 1 , idx , & ti , \"%s: Array of %s\" , szFieldName , szTypeName ) ;\n int i ;\n gint32 iLen ;\n iLen = tvb_get_letohl ( tvb , * pOffset ) ;\n proto_tree_add_item ( subtree , hf_opcua_ArraySize , tvb , * pOffset , 4 , ENC_LITTLE_ENDIAN ) ;\n if ( iLen > MAX_ARRAY_LEN ) {\n proto_tree_add_expert_format ( subtree , pinfo , & ei_array_length , tvb , * pOffset , 4 , \"Array length %d too large to process\" , iLen ) ;\n return ;\n }\n * pOffset += 4 ;\n for ( i = 0 ;\n i < iLen ;\n i ++ ) {\n proto_item * arrayItem = ( * pParserFunction ) ( subtree , tvb , pinfo , pOffset , hfIndex ) ;\n if ( arrayItem != NULL ) {\n proto_item_prepend_text ( arrayItem , \"[%i]: \" , i ) ;\n }\n }\n proto_item_set_end ( ti , tvb , * pOffset ) ;\n }", "idx": 21279}
{"hash": -1487877838474751244, "project": "debian", "size": 32, "label": 0, "functionSource": "PHP_FUNCTION ( locale_lookup ) {\n char * fallback_loc = NULL ;\n int fallback_loc_len = 0 ;\n const char * loc_range = NULL ;\n int loc_range_len = 0 ;\n zval * arr = NULL ;\n HashTable * hash_arr = NULL ;\n zend_bool boolCanonical = 0 ;\n char * result = NULL ;\n intl_error_reset ( NULL TSRMLS_CC ) ;\n if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , \"as|bs\" , & arr , & loc_range , & loc_range_len , & boolCanonical , & fallback_loc , & fallback_loc_len ) == FAILURE ) {\n intl_error_set ( NULL , U_ILLEGAL_ARGUMENT_ERROR , \"locale_lookup: unable to parse input params\" , 0 TSRMLS_CC ) ;\n RETURN_FALSE ;\n }\n if ( loc_range_len == 0 ) {\n loc_range = intl_locale_get_default ( TSRMLS_C ) ;\n }\n hash_arr = HASH_OF ( arr ) ;\n if ( ! hash_arr || zend_hash_num_elements ( hash_arr ) == 0 ) {\n RETURN_EMPTY_STRING ( ) ;\n }\n result = lookup_loc_range ( loc_range , hash_arr , boolCanonical TSRMLS_CC ) ;\n if ( result == NULL || result [ 0 ] == '\\0' ) {\n if ( fallback_loc ) {\n result = estrndup ( fallback_loc , fallback_loc_len ) ;\n }\n else {\n RETURN_EMPTY_STRING ( ) ;\n }\n }\n RETVAL_STRINGL ( result , strlen ( result ) , 0 ) ;\n }", "idx": 21280}
{"hash": 3502077845611765963, "project": "debian", "size": 45, "label": 0, "functionSource": "static struct cvec * range ( struct vars * v , celt a , celt b , int cases ) {\n int nchrs ;\n struct cvec * cv ;\n celt c , cc ;\n if ( a != b && ! before ( a , b ) ) {\n ERR ( REG_ERANGE ) ;\n return NULL ;\n }\n if ( ! cases ) {\n cv = getcvec ( v , 0 , 1 ) ;\n NOERRN ( ) ;\n addrange ( cv , a , b ) ;\n return cv ;\n }\n nchrs = b - a + 1 ;\n if ( nchrs <= 0 || nchrs > 100000 ) nchrs = 100000 ;\n cv = getcvec ( v , nchrs , 1 ) ;\n NOERRN ( ) ;\n addrange ( cv , a , b ) ;\n for ( c = a ;\n c <= b ;\n c ++ ) {\n cc = pg_wc_tolower ( ( chr ) c ) ;\n if ( cc != c && ( before ( cc , a ) || before ( b , cc ) ) ) {\n if ( cv -> nchrs >= cv -> chrspace ) {\n ERR ( REG_ETOOBIG ) ;\n return NULL ;\n }\n addchr ( cv , cc ) ;\n }\n cc = pg_wc_toupper ( ( chr ) c ) ;\n if ( cc != c && ( before ( cc , a ) || before ( b , cc ) ) ) {\n if ( cv -> nchrs >= cv -> chrspace ) {\n ERR ( REG_ETOOBIG ) ;\n return NULL ;\n }\n addchr ( cv , cc ) ;\n }\n if ( CANCEL_REQUESTED ( v -> re ) ) {\n ERR ( REG_CANCEL ) ;\n return NULL ;\n }\n }\n return cv ;\n }", "idx": 21281}
{"hash": -4960438251319819237, "project": "chrome", "size": 4, "label": 1, "functionSource": "static int gfboost_qadjust ( int qindex ) {\n const double q = vp9_convert_qindex_to_q ( qindex ) ;\n return ( int ) ( ( 0.00000828 * q * q * q ) + ( - 0.0055 * q * q ) + ( 1.32 * q ) + 79.3 ) ;\n }", "idx": 21282}
{"hash": 1742637512846796448, "project": "debian", "size": 9, "label": 0, "functionSource": "static guint find_head ( body_parts * * body_parts_array , guint16 * tsn ) {\n guint length = 0 ;\n * tsn = ( * tsn == 0 ) ? ( guint16 ) ( MAX_TSN - 1 ) : ( * tsn ) - 1 ;\n for ( ;\n body_parts_array [ * tsn ] -> middle != NULL ;\n * tsn = ( * tsn == 0 ) ? ( guint16 ) ( MAX_TSN - 1 ) : ( * tsn ) - 1 ) length += body_parts_array [ * tsn ] -> middle -> length ;\n if ( body_parts_array [ * tsn ] -> head != NULL ) return length + body_parts_array [ * tsn ] -> head -> length ;\n return 0 ;\n }", "idx": 21283}
{"hash": 1891617106617090004, "project": "chrome", "size": 76, "label": 1, "functionSource": "static void T_UConverter_fromUnicode_UTF32_BE ( UConverterFromUnicodeArgs * args , UErrorCode * err ) {\n const UChar * mySource = args -> source ;\n unsigned char * myTarget ;\n const UChar * sourceLimit = args -> sourceLimit ;\n const unsigned char * targetLimit = ( unsigned char * ) args -> targetLimit ;\n UChar32 ch , ch2 ;\n unsigned int indexToWrite ;\n unsigned char temp [ sizeof ( uint32_t ) ] ;\n if ( mySource >= sourceLimit ) {\n return ;\n }\n if ( args -> converter -> fromUnicodeStatus == UCNV_NEED_TO_WRITE_BOM ) {\n static const char bom [ ] = {\n 0 , 0 , ( char ) 0xfe , ( char ) 0xff }\n ;\n ucnv_fromUWriteBytes ( args -> converter , bom , 4 , & args -> target , args -> targetLimit , & args -> offsets , - 1 , err ) ;\n args -> converter -> fromUnicodeStatus = 0 ;\n }\n myTarget = ( unsigned char * ) args -> target ;\n temp [ 0 ] = 0 ;\n if ( args -> converter -> fromUChar32 ) {\n ch = args -> converter -> fromUChar32 ;\n args -> converter -> fromUChar32 = 0 ;\n goto lowsurogate ;\n }\n while ( mySource < sourceLimit && myTarget < targetLimit ) {\n ch = * ( mySource ++ ) ;\n if ( U_IS_SURROGATE ( ch ) ) {\n if ( U_IS_LEAD ( ch ) ) {\n lowsurogate : if ( mySource < sourceLimit ) {\n ch2 = * mySource ;\n if ( U_IS_TRAIL ( ch2 ) ) {\n ch = ( ( ch - SURROGATE_HIGH_START ) << HALF_SHIFT ) + ch2 + SURROGATE_LOW_BASE ;\n mySource ++ ;\n }\n else {\n args -> converter -> fromUChar32 = ch ;\n * err = U_ILLEGAL_CHAR_FOUND ;\n break ;\n }\n }\n else {\n args -> converter -> fromUChar32 = ch ;\n if ( args -> flush ) {\n * err = U_ILLEGAL_CHAR_FOUND ;\n }\n break ;\n }\n }\n else {\n args -> converter -> fromUChar32 = ch ;\n * err = U_ILLEGAL_CHAR_FOUND ;\n break ;\n }\n }\n temp [ 1 ] = ( uint8_t ) ( ch >> 16 & 0x1F ) ;\n temp [ 2 ] = ( uint8_t ) ( ch >> 8 ) ;\n temp [ 3 ] = ( uint8_t ) ( ch ) ;\n for ( indexToWrite = 0 ;\n indexToWrite <= sizeof ( uint32_t ) - 1 ;\n indexToWrite ++ ) {\n if ( myTarget < targetLimit ) {\n * ( myTarget ++ ) = temp [ indexToWrite ] ;\n }\n else {\n args -> converter -> charErrorBuffer [ args -> converter -> charErrorBufferLength ++ ] = temp [ indexToWrite ] ;\n * err = U_BUFFER_OVERFLOW_ERROR ;\n }\n }\n }\n if ( mySource < sourceLimit && myTarget >= targetLimit && U_SUCCESS ( * err ) ) {\n * err = U_BUFFER_OVERFLOW_ERROR ;\n }\n args -> target = ( char * ) myTarget ;\n args -> source = mySource ;\n }", "idx": 21284}
{"hash": 7319734001219685758, "project": "debian", "size": 6, "label": 0, "functionSource": "static inline int mpc8_dec_base ( GetBitContext * gb , int k , int n ) {\n int len = mpc8_cnk_len [ k - 1 ] [ n - 1 ] - 1 ;\n int code = len ? get_bits_long ( gb , len ) : 0 ;\n if ( code >= mpc8_cnk_lost [ k - 1 ] [ n - 1 ] ) code = ( ( code << 1 ) | get_bits1 ( gb ) ) - mpc8_cnk_lost [ k - 1 ] [ n - 1 ] ;\n return code ;\n }", "idx": 21285}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_CRCLength ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_CRCLength , CRCLength_choice , NULL ) ;\n return offset ;\n }", "idx": 21286}
{"hash": 7039307292471244756, "project": "debian", "size": 9, "label": 0, "functionSource": "static guint16 de_tp_ue_positioning_technology ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len _U_ , gchar * add_string _U_ , int string_len _U_ ) {\n guint32 curr_offset ;\n guchar oct ;\n curr_offset = offset ;\n oct = tvb_get_guint8 ( tvb , curr_offset ) ;\n proto_tree_add_uint_format_value ( tree , hf_gsm_a_dtap_ue_positioning_technology , tvb , curr_offset , 1 , oct , \"%s\" , val_to_str ( oct , gsm_positioning_technology_vals , \"Reserved (%d)\" ) ) ;\n curr_offset += 1 ;\n return ( curr_offset - offset ) ;\n }", "idx": 21287}
{"hash": 3599206110384554647, "project": "debian", "size": 14, "label": 0, "functionSource": "static ossl_inline unsigned long lh_ ## type ## _get_down_load ( LHASH_OF ( type ) * lh ) {\n return OPENSSL_LH_get_down_load ( ( OPENSSL_LHASH * ) lh ) ;\n }\n static ossl_inline void lh_ ## type ## _set_down_load ( LHASH_OF ( type ) * lh , unsigned long dl ) {\n OPENSSL_LH_set_down_load ( ( OPENSSL_LHASH * ) lh , dl ) ;\n }\n static ossl_inline void lh_ ## type ## _doall ( LHASH_OF ( type ) * lh , void ( * doall ) ( type * ) ) {\n OPENSSL_LH_doall ( ( OPENSSL_LHASH * ) lh , ( OPENSSL_LH_DOALL_FUNC ) doall ) ;\n }\n LHASH_OF ( type ) # define IMPLEMENT_LHASH_DOALL_ARG_CONST ( type , argtype ) int_implement_lhash_doall ( type , argtype , const type ) # define IMPLEMENT_LHASH_DOALL_ARG ( type , argtype ) int_implement_lhash_doall ( type , argtype , type ) # define int_implement_lhash_doall ( type , argtype , cbargtype ) static ossl_inline void lh_ ## type ## _doall_ ## argtype ( LHASH_OF ( type ) * lh , void ( * fn ) ( cbargtype * , argtype * ) , argtype * arg ) {\n OPENSSL_LH_doall_arg ( ( OPENSSL_LHASH * ) lh , ( OPENSSL_LH_DOALL_FUNCARG ) fn , ( void * ) arg ) ;\n }\n LHASH_OF ( type ) DEFINE_LHASH_OF ( OPENSSL_STRING ) ;\n # ifdef _MSC_VER # pragma warning ( push ) # pragma warning ( disable : 4090 ) # endif DEFINE_LHASH_OF ( OPENSSL_CSTRING )", "idx": 21288}
{"hash": -5420171864670538459, "project": "debian", "size": 5, "label": 0, "functionSource": "static void cpu_handle_guest_debug ( CPUState * cpu ) {\n gdb_set_stop_cpu ( cpu ) ;\n qemu_system_debug_request ( ) ;\n cpu -> stopped = true ;\n }", "idx": 21289}
{"hash": 6632536031698733342, "project": "debian", "size": 12, "label": 0, "functionSource": "static void writer_print_data_hash ( WriterContext * wctx , const char * name , uint8_t * data , int size ) {\n char * p , buf [ AV_HASH_MAX_SIZE * 2 + 64 ] = {\n 0 }\n ;\n if ( ! hash ) return ;\n av_hash_init ( hash ) ;\n av_hash_update ( hash , data , size ) ;\n snprintf ( buf , sizeof ( buf ) , \"%s:\" , av_hash_get_name ( hash ) ) ;\n p = buf + strlen ( buf ) ;\n av_hash_final_hex ( hash , p , buf + sizeof ( buf ) - p ) ;\n writer_print_string ( wctx , name , buf , 0 ) ;\n }", "idx": 21290}
{"hash": 2713698759296604855, "project": "debian", "size": 32, "label": 1, "functionSource": "static void free_picture ( MpegEncContext * s , Picture * pic ) {\n int i ;\n if ( pic -> f . data [ 0 ] && pic -> f . type != FF_BUFFER_TYPE_SHARED ) {\n free_frame_buffer ( s , pic ) ;\n }\n av_freep ( & pic -> mb_var ) ;\n av_freep ( & pic -> mc_mb_var ) ;\n av_freep ( & pic -> mb_mean ) ;\n av_freep ( & pic -> f . mbskip_table ) ;\n av_freep ( & pic -> qscale_table_base ) ;\n pic -> f . qscale_table = NULL ;\n av_freep ( & pic -> mb_type_base ) ;\n pic -> f . mb_type = NULL ;\n av_freep ( & pic -> f . dct_coeff ) ;\n av_freep ( & pic -> f . pan_scan ) ;\n pic -> f . mb_type = NULL ;\n for ( i = 0 ;\n i < 2 ;\n i ++ ) {\n av_freep ( & pic -> motion_val_base [ i ] ) ;\n av_freep ( & pic -> f . ref_index [ i ] ) ;\n pic -> f . motion_val [ i ] = NULL ;\n }\n if ( pic -> f . type == FF_BUFFER_TYPE_SHARED ) {\n for ( i = 0 ;\n i < 4 ;\n i ++ ) {\n pic -> f . base [ i ] = pic -> f . data [ i ] = NULL ;\n }\n pic -> f . type = 0 ;\n }\n }", "idx": 21291}
{"hash": 1182028467273264883, "project": "debian", "size": 10, "label": 0, "functionSource": "static int setenv ( const char * name , const char * value , int overwrite ) {\n size_t buflen = strlen ( name ) + strlen ( value ) + 2 ;\n char * envvar = ( char * ) malloc ( buflen ) ;\n if ( ! envvar ) return ENOMEM ;\n strcpy ( envvar , name ) ;\n strcat ( envvar , \"=\" ) ;\n strcat ( envvar , value ) ;\n putenv ( envvar ) ;\n return 0 ;\n }", "idx": 21292}
{"hash": -2943582541244387919, "project": "chrome", "size": 43, "label": 0, "functionSource": "unsigned int vp9_sub_pixel_variance ## W ## x ## H ## _c ( const uint8_t * src , int src_stride , int xoffset , int yoffset , const uint8_t * dst , int dst_stride , unsigned int * sse ) {\n uint16_t fdata3 [ ( H + 1 ) * W ] ;\n uint8_t temp2 [ H * W ] ;\n var_filter_block2d_bil_first_pass ( src , fdata3 , src_stride , 1 , H + 1 , W , BILINEAR_FILTERS_2TAP ( xoffset ) ) ;\n var_filter_block2d_bil_second_pass ( fdata3 , temp2 , W , W , H , W , BILINEAR_FILTERS_2TAP ( yoffset ) ) ;\n return vp9_variance ## W ## x ## H ## _c ( temp2 , W , dst , dst_stride , sse ) ;\n \\ }\n # define SUBPIX_AVG_VAR ( W , H ) unsigned int vp9_sub_pixel_avg_variance ## W ## x ## H ## _c ( const uint8_t * src , int src_stride , int xoffset , int yoffset , const uint8_t * dst , int dst_stride , unsigned int * sse , const uint8_t * second_pred ) {\n uint16_t fdata3 [ ( H + 1 ) * W ] ;\n uint8_t temp2 [ H * W ] ;\n DECLARE_ALIGNED_ARRAY ( 16 , uint8_t , temp3 , H * W ) ;\n var_filter_block2d_bil_first_pass ( src , fdata3 , src_stride , 1 , H + 1 , W , BILINEAR_FILTERS_2TAP ( xoffset ) ) ;\n var_filter_block2d_bil_second_pass ( fdata3 , temp2 , W , W , H , W , BILINEAR_FILTERS_2TAP ( yoffset ) ) ;\n vp9_comp_avg_pred ( temp3 , second_pred , W , H , temp2 , W ) ;\n return vp9_variance ## W ## x ## H ## _c ( temp3 , W , dst , dst_stride , sse ) ;\n \\ }\n void vp9_get16x16var_c ( const uint8_t * src_ptr , int source_stride , const uint8_t * ref_ptr , int ref_stride , unsigned int * sse , int * sum ) {\n variance ( src_ptr , source_stride , ref_ptr , ref_stride , 16 , 16 , sse , sum ) ;\n }\n void vp9_get8x8var_c ( const uint8_t * src_ptr , int source_stride , const uint8_t * ref_ptr , int ref_stride , unsigned int * sse , int * sum ) {\n variance ( src_ptr , source_stride , ref_ptr , ref_stride , 8 , 8 , sse , sum ) ;\n }\n unsigned int vp9_mse16x16_c ( const uint8_t * src , int src_stride , const uint8_t * ref , int ref_stride , unsigned int * sse ) {\n int sum ;\n variance ( src , src_stride , ref , ref_stride , 16 , 16 , sse , & sum ) ;\n return * sse ;\n }\n unsigned int vp9_mse16x8_c ( const uint8_t * src , int src_stride , const uint8_t * ref , int ref_stride , unsigned int * sse ) {\n int sum ;\n variance ( src , src_stride , ref , ref_stride , 16 , 8 , sse , & sum ) ;\n return * sse ;\n }\n unsigned int vp9_mse8x16_c ( const uint8_t * src , int src_stride , const uint8_t * ref , int ref_stride , unsigned int * sse ) {\n int sum ;\n variance ( src , src_stride , ref , ref_stride , 8 , 16 , sse , & sum ) ;\n return * sse ;\n }\n unsigned int vp9_mse8x8_c ( const uint8_t * src , int src_stride , const uint8_t * ref , int ref_stride , unsigned int * sse ) {\n int sum ;\n variance ( src , src_stride , ref , ref_stride , 8 , 8 , sse , & sum ) ;\n return * sse ;\n }\n VAR ( 4 , 4 ) SUBPIX_VAR ( 4 , 4 ) SUBPIX_AVG_VAR ( 4 , 4 ) VAR ( 4 , 8 ) SUBPIX_VAR ( 4 , 8 ) SUBPIX_AVG_VAR ( 4 , 8 ) VAR ( 8 , 4 ) SUBPIX_VAR ( 8 , 4 ) SUBPIX_AVG_VAR ( 8 , 4 ) VAR ( 8 , 8 ) SUBPIX_VAR ( 8 , 8 ) SUBPIX_AVG_VAR ( 8 , 8 ) VAR ( 8 , 16 ) SUBPIX_VAR ( 8 , 16 ) SUBPIX_AVG_VAR ( 8 , 16 ) VAR ( 16 , 8 ) SUBPIX_VAR ( 16 , 8 ) SUBPIX_AVG_VAR ( 16 , 8 ) VAR ( 16 , 16 ) SUBPIX_VAR ( 16 , 16 ) SUBPIX_AVG_VAR ( 16 , 16 ) VAR ( 16 , 32 ) SUBPIX_VAR ( 16 , 32 )", "idx": 21293}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_IS13818MultichannelType ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_IS13818MultichannelType , IS13818MultichannelType_choice , NULL ) ;\n return offset ;\n }", "idx": 21294}
{"hash": -1483849844579170895, "project": "chrome", "size": 6, "label": 0, "functionSource": "static void ctx_exit_on_error ( vpx_codec_ctx_t * ctx , const char * s , ... ) {\n va_list ap ;\n va_start ( ap , s ) ;\n warn_or_exit_on_errorv ( ctx , 1 , s , ap ) ;\n va_end ( ap ) ;\n }", "idx": 21295}
{"hash": 5704453449583823009, "project": "chrome", "size": 61, "label": 0, "functionSource": "char * evbuffer_readln ( struct evbuffer * buffer , size_t * n_read_out , enum evbuffer_eol_style eol_style ) {\n u_char * data = EVBUFFER_DATA ( buffer ) ;\n u_char * start_of_eol , * end_of_eol ;\n size_t len = EVBUFFER_LENGTH ( buffer ) ;\n char * line ;\n unsigned int i , n_to_copy , n_to_drain ;\n if ( n_read_out ) * n_read_out = 0 ;\n switch ( eol_style ) {\n case EVBUFFER_EOL_ANY : for ( i = 0 ;\n i < len ;\n i ++ ) {\n if ( data [ i ] == '\\r' || data [ i ] == '\\n' ) break ;\n }\n if ( i == len ) return ( NULL ) ;\n start_of_eol = data + i ;\n ++ i ;\n for ( ;\n i < len ;\n i ++ ) {\n if ( data [ i ] != '\\r' && data [ i ] != '\\n' ) break ;\n }\n end_of_eol = data + i ;\n break ;\n case EVBUFFER_EOL_CRLF : end_of_eol = memchr ( data , '\\n' , len ) ;\n if ( ! end_of_eol ) return ( NULL ) ;\n if ( end_of_eol > data && * ( end_of_eol - 1 ) == '\\r' ) start_of_eol = end_of_eol - 1 ;\n else start_of_eol = end_of_eol ;\n end_of_eol ++ ;\n break ;\n case EVBUFFER_EOL_CRLF_STRICT : {\n u_char * cp = data ;\n while ( ( cp = memchr ( cp , '\\r' , len - ( cp - data ) ) ) ) {\n if ( cp < data + len - 1 && * ( cp + 1 ) == '\\n' ) break ;\n if ( ++ cp >= data + len ) {\n cp = NULL ;\n break ;\n }\n }\n if ( ! cp ) return ( NULL ) ;\n start_of_eol = cp ;\n end_of_eol = cp + 2 ;\n break ;\n }\n case EVBUFFER_EOL_LF : start_of_eol = memchr ( data , '\\n' , len ) ;\n if ( ! start_of_eol ) return ( NULL ) ;\n end_of_eol = start_of_eol + 1 ;\n break ;\n default : return ( NULL ) ;\n }\n n_to_copy = start_of_eol - data ;\n n_to_drain = end_of_eol - data ;\n if ( ( line = malloc ( n_to_copy + 1 ) ) == NULL ) {\n event_warn ( \"%s: out of memory\\n\" , __func__ ) ;\n return ( NULL ) ;\n }\n memcpy ( line , data , n_to_copy ) ;\n line [ n_to_copy ] = '\\0' ;\n evbuffer_drain ( buffer , n_to_drain ) ;\n if ( n_read_out ) * n_read_out = ( size_t ) n_to_copy ;\n return ( line ) ;\n }", "idx": 21296}
{"hash": 4180964683905830761, "project": "debian", "size": 20, "label": 0, "functionSource": "static int may_create ( struct inode * dir , struct dentry * dentry , u16 tclass ) {\n const struct task_security_struct * tsec = current_security ( ) ;\n struct inode_security_struct * dsec ;\n struct superblock_security_struct * sbsec ;\n u32 sid , newsid ;\n struct common_audit_data ad ;\n int rc ;\n dsec = inode_security ( dir ) ;\n sbsec = dir -> i_sb -> s_security ;\n sid = tsec -> sid ;\n ad . type = LSM_AUDIT_DATA_DENTRY ;\n ad . u . dentry = dentry ;\n rc = avc_has_perm ( sid , dsec -> sid , SECCLASS_DIR , DIR__ADD_NAME | DIR__SEARCH , & ad ) ;\n if ( rc ) return rc ;\n rc = selinux_determine_inode_label ( current_security ( ) , dir , & dentry -> d_name , tclass , & newsid ) ;\n if ( rc ) return rc ;\n rc = avc_has_perm ( sid , newsid , tclass , FILE__CREATE , & ad ) ;\n if ( rc ) return rc ;\n return avc_has_perm ( newsid , sbsec -> sid , SECCLASS_FILESYSTEM , FILESYSTEM__ASSOCIATE , & ad ) ;\n }", "idx": 21297}
{"hash": -4055702019813176658, "project": "debian", "size": 572, "label": 1, "functionSource": "void proto_register_iax2 ( void ) {\n static hf_register_info hf [ ] = {\n {\n & hf_iax2_packet_type , {\n \"Packet type\" , \"iax2.packet_type\" , FT_UINT8 , BASE_DEC , VALS ( iax_packet_types ) , 0 , \"Full/minivoice/minivideo/trunk packet\" , HFILL }\n }\n , {\n & hf_iax2_callno , {\n \"Call identifier\" , \"iax2.call\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"This is the identifier Wireshark assigns to identify this call.\" \" It does not correspond to any real field in the protocol\" , HFILL }\n }\n , {\n & hf_iax2_scallno , {\n \"Source call\" , \"iax2.src_call\" , FT_UINT16 , BASE_DEC , NULL , 0x7FFF , \"src_call holds the number of this call at the packet source pbx\" , HFILL }\n }\n , {\n & hf_iax2_dcallno , {\n \"Destination call\" , \"iax2.dst_call\" , FT_UINT16 , BASE_DEC , NULL , 0x7FFF , \"dst_call holds the number of this call at the packet destination\" , HFILL }\n }\n , {\n & hf_iax2_retransmission , {\n \"Retransmission\" , \"iax2.retransmission\" , FT_BOOLEAN , 16 , NULL , 0x8000 , \"retransmission is set if this packet is a retransmission of an earlier failed packet\" , HFILL }\n }\n , {\n & hf_iax2_ts , {\n \"Timestamp\" , \"iax2.timestamp\" , FT_UINT32 , BASE_DEC , NULL , 0x0 , \"timestamp is the time, in ms after the start of this call, at which this packet was transmitted\" , HFILL }\n }\n , {\n & hf_iax2_minits , {\n \"Timestamp\" , \"iax2.timestamp\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , \"timestamp is the time, in ms after the start of this call, at which this packet was transmitted\" , HFILL }\n }\n , {\n & hf_iax2_minividts , {\n \"Timestamp\" , \"iax2.timestamp\" , FT_UINT16 , BASE_DEC , NULL , 0x7FFF , \"timestamp is the time, in ms after the start of this call, at which this packet was transmitted\" , HFILL }\n }\n , {\n & hf_iax2_absts , {\n \"Absolute Time\" , \"iax2.abstime\" , FT_ABSOLUTE_TIME , ABSOLUTE_TIME_LOCAL , NULL , 0x0 , \"The absolute time of this packet (calculated by adding the IAX timestamp to the start time of this call)\" , HFILL }\n }\n , {\n & hf_iax2_lateness , {\n \"Lateness\" , \"iax2.lateness\" , FT_RELATIVE_TIME , BASE_NONE , NULL , 0x0 , \"The lateness of this packet compared to its timestamp\" , HFILL }\n }\n , {\n & hf_iax2_minividmarker , {\n \"Marker\" , \"iax2.video.marker\" , FT_UINT16 , BASE_DEC , NULL , 0x8000 , \"RTP end-of-frame marker\" , HFILL }\n }\n , {\n & hf_iax2_oseqno , {\n \"Outbound seq.no.\" , \"iax2.oseqno\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , \"oseqno is the sequence no of this packet. The first packet has oseqno==0,\" \" and subsequent packets increment the oseqno by 1\" , HFILL }\n }\n , {\n & hf_iax2_iseqno , {\n \"Inbound seq.no.\" , \"iax2.iseqno\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , \"iseqno is the sequence no of the last successfully received packet\" , HFILL }\n }\n , {\n & hf_iax2_type , {\n \"Type\" , \"iax2.type\" , FT_UINT8 , BASE_DEC | BASE_EXT_STRING , & iax_frame_types_ext , 0x0 , \"For full IAX2 frames, type is the type of frame\" , HFILL }\n }\n , {\n & hf_iax2_csub , {\n \"Unknown subclass\" , \"iax2.subclass\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , \"Subclass of unknown type of full IAX2 frame\" , HFILL }\n }\n , {\n & hf_iax2_dtmf_csub , {\n \"DTMF subclass (digit)\" , \"iax2.dtmf.subclass\" , FT_STRINGZ , BASE_NONE , NULL , 0x0 , \"DTMF subclass gives the DTMF digit\" , HFILL }\n }\n , {\n & hf_iax2_cmd_csub , {\n \"Control subclass\" , \"iax2.control.subclass\" , FT_UINT8 , BASE_DEC | BASE_EXT_STRING , & iax_cmd_subclasses_ext , 0x0 , \"This gives the command number for a Control packet.\" , HFILL }\n }\n , {\n & hf_iax2_iax_csub , {\n \"IAX subclass\" , \"iax2.iax.subclass\" , FT_UINT8 , BASE_DEC | BASE_EXT_STRING , & iax_iax_subclasses_ext , 0x0 , \"IAX subclass gives the command number for IAX signaling packets\" , HFILL }\n }\n , {\n & hf_iax2_voice_csub , {\n \"Voice Subclass (compressed codec no)\" , \"iax2.voice.subclass\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_voice_codec , {\n \"CODEC\" , \"iax2.voice.codec\" , FT_UINT32 , BASE_HEX | BASE_EXT_STRING , & codec_types_ext , 0x0 , \"CODEC gives the codec used to encode audio data\" , HFILL }\n }\n , {\n & hf_iax2_video_csub , {\n \"Video Subclass (compressed codec no)\" , \"iax2.video.subclass\" , FT_UINT8 , BASE_DEC , NULL , 0xBF , NULL , HFILL }\n }\n , {\n & hf_iax2_marker , {\n \"Marker\" , \"iax2.video.marker\" , FT_BOOLEAN , 8 , NULL , 0x40 , \"RTP end-of-frame marker\" , HFILL }\n }\n , {\n & hf_iax2_video_codec , {\n \"CODEC\" , \"iax2.video.codec\" , FT_UINT32 , BASE_HEX | BASE_EXT_STRING , & codec_types_ext , 0 , \"The codec used to encode video data\" , HFILL }\n }\n , {\n & hf_iax2_modem_csub , {\n \"Modem subclass\" , \"iax2.modem.subclass\" , FT_UINT8 , BASE_DEC , VALS ( iax_modem_subclasses ) , 0x0 , \"Modem subclass gives the type of modem\" , HFILL }\n }\n , {\n & hf_iax2_text_csub , {\n \"Text subclass\" , \"iax2.text.subclass\" , FT_UINT8 , BASE_DEC , VALS ( iax_text_subclasses ) , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_text_text , {\n \"Text\" , \"iax2.text.text\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_html_csub , {\n \"HTML subclass\" , \"iax2.html.subclass\" , FT_UINT8 , BASE_DEC , VALS ( iax_html_subclasses ) , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_html_url , {\n \"HTML URL\" , \"iax2.html.url\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_trunk_ts , {\n \"Timestamp\" , \"iax2.timestamp\" , FT_UINT32 , BASE_DEC , NULL , 0x0 , \"timestamp is the time, in ms after the start of Command data this call,\" \" at which this trunk packet was transmitted\" , HFILL }\n }\n , {\n & hf_iax2_trunk_metacmd , {\n \"Meta command\" , \"iax2.trunk.metacmd\" , FT_UINT8 , BASE_DEC , NULL , 0x7F , \"Meta command indicates whether or not the Meta Frame is a trunk.\" , HFILL }\n }\n , {\n & hf_iax2_trunk_cmddata , {\n \"Command data\" , \"iax2.trunk.cmddata\" , FT_UINT8 , BASE_HEX , NULL , 0x0 , \"Flags for options that apply to a trunked call\" , HFILL }\n }\n , {\n & hf_iax2_trunk_cmddata_ts , {\n \"Trunk timestamps\" , \"iax2.trunk.cmddata.ts\" , FT_BOOLEAN , 8 , NULL , IAX2_TRUNK_TS , \"True: calls do each include their own timestamp\" , HFILL }\n }\n , {\n & hf_iax2_trunk_call_len , {\n \"Data length\" , \"iax2.trunk.call.len\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , \"Trunk call data length in octets\" , HFILL }\n }\n , {\n & hf_iax2_trunk_call_scallno , {\n \"Source call number\" , \"iax2.trunk.call.scallno\" , FT_UINT16 , BASE_DEC , NULL , 0x7FFF , \"Trunk call source call number\" , HFILL }\n }\n , {\n & hf_iax2_trunk_call_ts , {\n \"Timestamp\" , \"iax2.trunk.call.ts\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , \"timestamp is the time, in ms after the start of this call, at which this packet was transmitted\" , HFILL }\n }\n , {\n & hf_iax2_trunk_call_data , {\n \"Data\" , \"iax2.trunk.call.payload\" , FT_BYTES , BASE_NONE , NULL , 0x0 , \"Payload carried by this trunked packet.\" , HFILL }\n }\n , {\n & hf_iax2_trunk_ncalls , {\n \"Number of calls\" , \"iax2.trunk.ncalls\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , \"Number of calls in this trunk packet\" , HFILL }\n }\n , {\n & hf_IAX_IE_APPARENTADDR_SINFAMILY , {\n \"Family\" , \"iax2.iax.app_addr.sinfamily\" , FT_UINT16 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_IAX_IE_APPARENTADDR_SINPORT , {\n \"Port\" , \"iax2.iax.app_addr.sinport\" , FT_UINT16 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_IAX_IE_APPARENTADDR_SINADDR , {\n \"Address\" , \"iax2.iax.app_addr.sinaddr\" , FT_IPv4 , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_CALLED_NUMBER ] , {\n \"Number/extension being called\" , \"iax2.iax.called_number\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_CALLING_NUMBER ] , {\n \"Calling number\" , \"iax2.iax.calling_number\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_CALLING_ANI ] , {\n \"Calling number ANI for billing\" , \"iax2.iax.calling_ani\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_CALLING_NAME ] , {\n \"Name of caller\" , \"iax2.iax.calling_name\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_CALLED_CONTEXT ] , {\n \"Context for number\" , \"iax2.iax.called_context\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_USERNAME ] , {\n \"Username (peer or user) for authentication\" , \"iax2.iax.username\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_PASSWORD ] , {\n \"Password for authentication\" , \"iax2.iax.password\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_CAPABILITY ] , {\n \"Actual codec capability\" , \"iax2.iax.capability\" , FT_UINT32 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_FORMAT ] , {\n \"Desired codec format\" , \"iax2.iax.format\" , FT_UINT32 , BASE_HEX | BASE_EXT_STRING , & codec_types_ext , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_LANGUAGE ] , {\n \"Desired language\" , \"iax2.iax.language\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_VERSION ] , {\n \"Protocol version\" , \"iax2.iax.version\" , FT_UINT16 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_ADSICPE ] , {\n \"CPE ADSI capability\" , \"iax2.iax.cpe_adsi\" , FT_UINT16 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_DNID ] , {\n \"Originally dialed DNID\" , \"iax2.iax.dnid\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_AUTHMETHODS ] , {\n \"Authentication method(s)\" , \"iax2.iax.auth.methods\" , FT_UINT16 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_CHALLENGE ] , {\n \"Challenge data for MD5/RSA\" , \"iax2.iax.auth.challenge\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_MD5_RESULT ] , {\n \"MD5 challenge result\" , \"iax2.iax.auth.md5\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_RSA_RESULT ] , {\n \"RSA challenge result\" , \"iax2.iax.auth.rsa\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_REFRESH ] , {\n \"When to refresh registration\" , \"iax2.iax.refresh\" , FT_INT16 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_DPSTATUS ] , {\n \"Dialplan status\" , \"iax2.iax.dialplan_status\" , FT_UINT16 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_CALLNO ] , {\n \"Call number of peer\" , \"iax2.iax.call_no\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_CAUSE ] , {\n \"Cause\" , \"iax2.iax.cause\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_IAX_UNKNOWN ] , {\n \"Unknown IAX command\" , \"iax2.iax.iax_unknown\" , FT_BYTES , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_MSGCOUNT ] , {\n \"How many messages waiting\" , \"iax2.iax.msg_count\" , FT_INT16 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_AUTOANSWER ] , {\n \"Request auto-answering\" , \"iax2.iax.autoanswer\" , FT_NONE , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_MUSICONHOLD ] , {\n \"Request musiconhold with QUELCH\" , \"iax2.iax.moh\" , FT_NONE , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_TRANSFERID ] , {\n \"Transfer Request Identifier\" , \"iax2.iax.transferid\" , FT_UINT32 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_RDNIS ] , {\n \"Referring DNIS\" , \"iax2.iax.rdnis\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_PROVISIONING ] , {\n \"Provisioning info\" , \"iax2.iax.provisioning\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_AESPROVISIONING ] , {\n \"AES Provisioning info\" , \"iax2.iax.aesprovisioning\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_DATETIME ] , {\n \"Date/Time\" , \"iax2.iax.datetime.raw\" , FT_UINT32 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ie_datetime , {\n \"Date/Time\" , \"iax2.iax.datetime\" , FT_ABSOLUTE_TIME , ABSOLUTE_TIME_LOCAL , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_DEVICETYPE ] , {\n \"Device type\" , \"iax2.iax.devicetype\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_SERVICEIDENT ] , {\n \"Service identifier\" , \"iax2.iax.serviceident\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_FIRMWAREVER ] , {\n \"Firmware version\" , \"iax2.iax.firmwarever\" , FT_UINT16 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_FWBLOCKDESC ] , {\n \"Firmware block description\" , \"iax2.iax.fwblockdesc\" , FT_UINT32 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_FWBLOCKDATA ] , {\n \"Firmware block of data\" , \"iax2.iax.fwblockdata\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_PROVVER ] , {\n \"Provisioning version\" , \"iax2.iax.provver\" , FT_UINT32 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_CALLINGPRES ] , {\n \"Calling presentation\" , \"iax2.iax.callingpres\" , FT_UINT8 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_CALLINGTON ] , {\n \"Calling type of number\" , \"iax2.iax.callington\" , FT_UINT8 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_CALLINGTNS ] , {\n \"Calling transit network select\" , \"iax2.iax.callingtns\" , FT_UINT16 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_SAMPLINGRATE ] , {\n \"Supported sampling rates\" , \"iax2.iax.samplingrate\" , FT_UINT16 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_CAUSECODE ] , {\n \"Hangup cause\" , \"iax2.iax.causecode\" , FT_UINT8 , BASE_HEX | BASE_EXT_STRING , & iax_causecodes_ext , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_ENCRYPTION ] , {\n \"Encryption format\" , \"iax2.iax.encryption\" , FT_UINT16 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_ENCKEY ] , {\n \"Encryption key\" , \"iax2.iax.enckey\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_CODEC_PREFS ] , {\n \"Codec negotiation\" , \"iax2.iax.codecprefs\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_RR_JITTER ] , {\n \"Received jitter (as in RFC1889)\" , \"iax2.iax.rrjitter\" , FT_UINT32 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_RR_LOSS ] , {\n \"Received loss (high byte loss pct, low 24 bits loss count, as in rfc1889)\" , \"iax2.iax.rrloss\" , FT_UINT32 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_RR_PKTS ] , {\n \"Total frames received\" , \"iax2.iax.rrpkts\" , FT_UINT32 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_RR_DELAY ] , {\n \"Max playout delay in ms for received frames\" , \"iax2.iax.rrdelay\" , FT_UINT16 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_RR_DROPPED ] , {\n \"Dropped frames (presumably by jitterbuffer)\" , \"iax2.iax.rrdropped\" , FT_UINT32 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_RR_OOO ] , {\n \"Frame received out of order\" , \"iax2.iax.rrooo\" , FT_UINT32 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_DATAFORMAT ] , {\n \"Data call format\" , \"iax2.iax.dataformat\" , FT_UINT32 , BASE_HEX , VALS ( iax_dataformats ) , 0x0 , NULL , HFILL }\n }\n , {\n & hf_IAX_IE_UNKNOWN_BYTE , {\n \"Unknown\" , \"iax2.iax.unknownbyte\" , FT_UINT8 , BASE_HEX , NULL , 0x0 , \"Raw data for unknown IEs\" , HFILL }\n }\n , {\n & hf_IAX_IE_UNKNOWN_I16 , {\n \"Unknown\" , \"iax2.iax.unknownshort\" , FT_UINT16 , BASE_HEX , NULL , 0x0 , \"Raw data for unknown IEs\" , HFILL }\n }\n , {\n & hf_IAX_IE_UNKNOWN_I32 , {\n \"Unknown\" , \"iax2.iax.unknownlong\" , FT_UINT32 , BASE_HEX , NULL , 0x0 , \"Raw data for unknown IEs\" , HFILL }\n }\n , {\n & hf_IAX_IE_UNKNOWN_BYTES , {\n \"Unknown\" , \"iax2.iax.unknownstring\" , FT_STRING , BASE_NONE , NULL , 0x0 , \"Raw data for unknown IEs\" , HFILL }\n }\n , {\n & hf_iax2_ie_id , {\n \"IE id\" , \"iax2.ie_id\" , FT_UINT8 , BASE_DEC | BASE_EXT_STRING , & iax_ies_type_ext , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_length , {\n \"Length\" , \"iax2.length\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_g723_1 , {\n \"G.723.1 compression\" , \"iax2.cap.g723_1\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_G723_1 , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_gsm , {\n \"GSM compression\" , \"iax2.cap.gsm\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_GSM , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_ulaw , {\n \"Raw mu-law data (G.711)\" , \"iax2.cap.ulaw\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_ULAW , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_alaw , {\n \"Raw A-law data (G.711)\" , \"iax2.cap.alaw\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_ALAW , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_g726_aal2 , {\n \"G.726 compression (AAL2 packing)\" , \"iax2.cap.g726_aal2\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_G726_AAL2 , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_adpcm , {\n \"ADPCM\" , \"iax2.cap.adpcm\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_ADPCM , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_slinear , {\n \"Raw 16-bit Signed Linear (8000 Hz) PCM\" , \"iax2.cap.slinear\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_SLINEAR , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_lpc10 , {\n \"LPC10, 180 samples/frame\" , \"iax2.cap.lpc10\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_LPC10 , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_g729a , {\n \"G.729a Audio\" , \"iax2.cap.g729a\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_G729A , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_speex , {\n \"SPEEX Audio\" , \"iax2.cap.speex\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_SPEEX , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_ilbc , {\n \"iLBC Free compressed Audio\" , \"iax2.cap.ilbc\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_ILBC , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_g726 , {\n \"ADPCM (G.726, 32kbps, RFC3551 codeword packing)\" , \"iax2.cap.g726\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_G726 , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_g722 , {\n \"G.722 wideband audio\" , \"iax2.cap.g722\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_G722 , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_siren7 , {\n \"G.722.1 (also known as Siren7, 32kbps assumed)\" , \"iax2.cap.siren7\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_SIREN7 , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_siren14 , {\n \"G.722.1 Annex C (also known as Siren14, 48kbps assumed)\" , \"iax2.cap.siren14\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_SIREN14 , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_slinear16 , {\n \"Raw 16-bit Signed Linear (16000 Hz) PCM\" , \"iax2.cap.slinear16\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_SLINEAR16 , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_jpeg , {\n \"JPEG images\" , \"iax2.cap.jpeg\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_JPEG , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_png , {\n \"PNG images\" , \"iax2.cap.png\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_PNG , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_h261 , {\n \"H.261 video\" , \"iax2.cap.h261\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_H261 , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_h263 , {\n \"H.263 video\" , \"iax2.cap.h263\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_H263 , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_h263_plus , {\n \"H.263+ video\" , \"iax2.cap.h263_plus\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_H263_PLUS , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_h264 , {\n \"H.264 video\" , \"iax2.cap.h264\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_H264 , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_mpeg4 , {\n \"MPEG4 video\" , \"iax2.cap.mpeg4\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_MP4_VIDEO , NULL , HFILL }\n }\n , {\n & hf_iax2_fragment_unfinished , {\n \"IAX2 fragment, unfinished\" , \"iax2.fragment_unfinished\" , FT_BYTES , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_payload_data , {\n \"IAX2 payload\" , \"iax2.payload_data\" , FT_BYTES , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_fragments , {\n \"IAX2 Fragments\" , \"iax2.fragments\" , FT_NONE , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_fragment , {\n \"IAX2 Fragment data\" , \"iax2.fragment\" , FT_FRAMENUM , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_fragment_overlap , {\n \"Fragment overlap\" , \"iax2.fragment.overlap\" , FT_BOOLEAN , BASE_NONE , NULL , 0x0 , \"Fragment overlaps with other fragments\" , HFILL }\n }\n , {\n & hf_iax2_fragment_overlap_conflict , {\n \"Conflicting data in fragment overlap\" , \"iax2.fragment.overlap.conflict\" , FT_BOOLEAN , BASE_NONE , NULL , 0x0 , \"Overlapping fragments contained conflicting data\" , HFILL }\n }\n , {\n & hf_iax2_fragment_multiple_tails , {\n \"Multiple tail fragments found\" , \"iax2.fragment.multipletails\" , FT_BOOLEAN , BASE_NONE , NULL , 0x0 , \"Several tails were found when defragmenting the packet\" , HFILL }\n }\n , {\n & hf_iax2_fragment_too_long_fragment , {\n \"Fragment too long\" , \"iax2.fragment.toolongfragment\" , FT_BOOLEAN , BASE_NONE , NULL , 0x0 , \"Fragment contained data past end of packet\" , HFILL }\n }\n , {\n & hf_iax2_fragment_error , {\n \"Defragmentation error\" , \"iax2.fragment.error\" , FT_FRAMENUM , BASE_NONE , NULL , 0x0 , \"Defragmentation error due to illegal fragments\" , HFILL }\n }\n , {\n & hf_iax2_fragment_count , {\n \"Fragment count\" , \"iax2.fragment.count\" , FT_UINT32 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_reassembled_in , {\n \"IAX2 fragment, reassembled in frame\" , \"iax2.reassembled_in\" , FT_FRAMENUM , BASE_NONE , NULL , 0x0 , \"This IAX2 packet is reassembled in this frame\" , HFILL }\n }\n , {\n & hf_iax2_reassembled_length , {\n \"Reassembled IAX2 length\" , \"iax2.reassembled.length\" , FT_UINT32 , BASE_DEC , NULL , 0x0 , \"The total length of the reassembled payload\" , HFILL }\n }\n }\n ;\n static gint * ett [ ] = {\n & ett_iax2 , & ett_iax2_full_mini_subtree , & ett_iax2_type , & ett_iax2_ie , & ett_iax2_codecs , & ett_iax2_ies_apparent_addr , & ett_iax2_fragment , & ett_iax2_fragments , & ett_iax2_trunk_cmddata , & ett_iax2_trunk_call }\n ;\n static ei_register_info ei [ ] = {\n {\n & ei_iax_too_many_transfers , {\n \"iax2.too_many_transfers\" , PI_PROTOCOL , PI_WARN , \"Too many transfers for iax_call\" , EXPFILL }\n }\n , {\n & ei_iax_circuit_id_conflict , {\n \"iax2.circuit_id_conflict\" , PI_PROTOCOL , PI_WARN , \"Circuit ID conflict\" , EXPFILL }\n }\n , {\n & ei_iax_peer_address_unsupported , {\n \"iax2.peer_address_unsupported\" , PI_PROTOCOL , PI_WARN , \"Peer address unsupported\" , EXPFILL }\n }\n , {\n & ei_iax_invalid_len , {\n \"iax2.invalid_len\" , PI_PROTOCOL , PI_WARN , \"Invalid length\" , EXPFILL }\n }\n }\n ;\n expert_module_t * expert_iax ;\n memset ( hf_iax2_ies , 0xff , sizeof ( hf_iax2_ies ) ) ;\n proto_iax2 = proto_register_protocol ( \"Inter-Asterisk eXchange v2\" , \"IAX2\" , \"iax2\" ) ;\n proto_register_field_array ( proto_iax2 , hf , array_length ( hf ) ) ;\n proto_register_subtree_array ( ett , array_length ( ett ) ) ;\n expert_iax = expert_register_protocol ( proto_iax2 ) ;\n expert_register_field_array ( expert_iax , ei , array_length ( ei ) ) ;\n register_dissector ( \"iax2\" , dissect_iax2 , proto_iax2 ) ;\n iax2_codec_dissector_table = register_dissector_table ( \"iax2.codec\" , \"IAX codec number\" , FT_UINT32 , BASE_HEX ) ;\n iax2_dataformat_dissector_table = register_dissector_table ( \"iax2.dataformat\" , \"IAX dataformat number\" , FT_UINT32 , BASE_HEX ) ;\n register_init_routine ( & iax_init_protocol ) ;\n register_cleanup_routine ( & iax_cleanup_protocol ) ;\n iax2_tap = register_tap ( \"IAX2\" ) ;\n }", "idx": 21298}
{"hash": 6080147530626246065, "project": "debian", "size": 121, "label": 0, "functionSource": "static int vc1_decode_p_block ( VC1Context * v , int16_t block [ 64 ] , int n , int mquant , int ttmb , int first_block , uint8_t * dst , int linesize , int skip_block , int * ttmb_out ) {\n MpegEncContext * s = & v -> s ;\n GetBitContext * gb = & s -> gb ;\n int i , j ;\n int subblkpat = 0 ;\n int scale , off , idx , last , skip , value ;\n int ttblk = ttmb & 7 ;\n int pat = 0 ;\n s -> dsp . clear_block ( block ) ;\n if ( ttmb == - 1 ) {\n ttblk = ff_vc1_ttblk_to_tt [ v -> tt_index ] [ get_vlc2 ( gb , ff_vc1_ttblk_vlc [ v -> tt_index ] . table , VC1_TTBLK_VLC_BITS , 1 ) ] ;\n }\n if ( ttblk == TT_4X4 ) {\n subblkpat = ~ ( get_vlc2 ( gb , ff_vc1_subblkpat_vlc [ v -> tt_index ] . table , VC1_SUBBLKPAT_VLC_BITS , 1 ) + 1 ) ;\n }\n if ( ( ttblk != TT_8X8 && ttblk != TT_4X4 ) && ( ( v -> ttmbf || ( ttmb != - 1 && ( ttmb & 8 ) && ! first_block ) ) || ( ! v -> res_rtm_flag && ! first_block ) ) ) {\n subblkpat = decode012 ( gb ) ;\n if ( subblkpat ) subblkpat ^= 3 ;\n if ( ttblk == TT_8X4_TOP || ttblk == TT_8X4_BOTTOM ) ttblk = TT_8X4 ;\n if ( ttblk == TT_4X8_RIGHT || ttblk == TT_4X8_LEFT ) ttblk = TT_4X8 ;\n }\n scale = 2 * mquant + ( ( v -> pq == mquant ) ? v -> halfpq : 0 ) ;\n if ( ttblk == TT_8X4_TOP || ttblk == TT_8X4_BOTTOM ) {\n subblkpat = 2 - ( ttblk == TT_8X4_TOP ) ;\n ttblk = TT_8X4 ;\n }\n if ( ttblk == TT_4X8_RIGHT || ttblk == TT_4X8_LEFT ) {\n subblkpat = 2 - ( ttblk == TT_4X8_LEFT ) ;\n ttblk = TT_4X8 ;\n }\n switch ( ttblk ) {\n case TT_8X8 : pat = 0xF ;\n i = 0 ;\n last = 0 ;\n while ( ! last ) {\n vc1_decode_ac_coeff ( v , & last , & skip , & value , v -> codingset2 ) ;\n i += skip ;\n if ( i > 63 ) break ;\n if ( ! v -> fcm ) idx = v -> zz_8x8 [ 0 ] [ i ++ ] ;\n else idx = v -> zzi_8x8 [ i ++ ] ;\n block [ idx ] = value * scale ;\n if ( ! v -> pquantizer ) block [ idx ] += ( block [ idx ] < 0 ) ? - mquant : mquant ;\n }\n if ( ! skip_block ) {\n if ( i == 1 ) v -> vc1dsp . vc1_inv_trans_8x8_dc ( dst , linesize , block ) ;\n else {\n v -> vc1dsp . vc1_inv_trans_8x8 ( block ) ;\n s -> dsp . add_pixels_clamped ( block , dst , linesize ) ;\n }\n }\n break ;\n case TT_4X4 : pat = ~ subblkpat & 0xF ;\n for ( j = 0 ;\n j < 4 ;\n j ++ ) {\n last = subblkpat & ( 1 << ( 3 - j ) ) ;\n i = 0 ;\n off = ( j & 1 ) * 4 + ( j & 2 ) * 16 ;\n while ( ! last ) {\n vc1_decode_ac_coeff ( v , & last , & skip , & value , v -> codingset2 ) ;\n i += skip ;\n if ( i > 15 ) break ;\n if ( ! v -> fcm ) idx = ff_vc1_simple_progressive_4x4_zz [ i ++ ] ;\n else idx = ff_vc1_adv_interlaced_4x4_zz [ i ++ ] ;\n block [ idx + off ] = value * scale ;\n if ( ! v -> pquantizer ) block [ idx + off ] += ( block [ idx + off ] < 0 ) ? - mquant : mquant ;\n }\n if ( ! ( subblkpat & ( 1 << ( 3 - j ) ) ) && ! skip_block ) {\n if ( i == 1 ) v -> vc1dsp . vc1_inv_trans_4x4_dc ( dst + ( j & 1 ) * 4 + ( j & 2 ) * 2 * linesize , linesize , block + off ) ;\n else v -> vc1dsp . vc1_inv_trans_4x4 ( dst + ( j & 1 ) * 4 + ( j & 2 ) * 2 * linesize , linesize , block + off ) ;\n }\n }\n break ;\n case TT_8X4 : pat = ~ ( ( subblkpat & 2 ) * 6 + ( subblkpat & 1 ) * 3 ) & 0xF ;\n for ( j = 0 ;\n j < 2 ;\n j ++ ) {\n last = subblkpat & ( 1 << ( 1 - j ) ) ;\n i = 0 ;\n off = j * 32 ;\n while ( ! last ) {\n vc1_decode_ac_coeff ( v , & last , & skip , & value , v -> codingset2 ) ;\n i += skip ;\n if ( i > 31 ) break ;\n if ( ! v -> fcm ) idx = v -> zz_8x4 [ i ++ ] + off ;\n else idx = ff_vc1_adv_interlaced_8x4_zz [ i ++ ] + off ;\n block [ idx ] = value * scale ;\n if ( ! v -> pquantizer ) block [ idx ] += ( block [ idx ] < 0 ) ? - mquant : mquant ;\n }\n if ( ! ( subblkpat & ( 1 << ( 1 - j ) ) ) && ! skip_block ) {\n if ( i == 1 ) v -> vc1dsp . vc1_inv_trans_8x4_dc ( dst + j * 4 * linesize , linesize , block + off ) ;\n else v -> vc1dsp . vc1_inv_trans_8x4 ( dst + j * 4 * linesize , linesize , block + off ) ;\n }\n }\n break ;\n case TT_4X8 : pat = ~ ( subblkpat * 5 ) & 0xF ;\n for ( j = 0 ;\n j < 2 ;\n j ++ ) {\n last = subblkpat & ( 1 << ( 1 - j ) ) ;\n i = 0 ;\n off = j * 4 ;\n while ( ! last ) {\n vc1_decode_ac_coeff ( v , & last , & skip , & value , v -> codingset2 ) ;\n i += skip ;\n if ( i > 31 ) break ;\n if ( ! v -> fcm ) idx = v -> zz_4x8 [ i ++ ] + off ;\n else idx = ff_vc1_adv_interlaced_4x8_zz [ i ++ ] + off ;\n block [ idx ] = value * scale ;\n if ( ! v -> pquantizer ) block [ idx ] += ( block [ idx ] < 0 ) ? - mquant : mquant ;\n }\n if ( ! ( subblkpat & ( 1 << ( 1 - j ) ) ) && ! skip_block ) {\n if ( i == 1 ) v -> vc1dsp . vc1_inv_trans_4x8_dc ( dst + j * 4 , linesize , block + off ) ;\n else v -> vc1dsp . vc1_inv_trans_4x8 ( dst + j * 4 , linesize , block + off ) ;\n }\n }\n break ;\n }\n if ( ttmb_out ) * ttmb_out |= ttblk << ( n * 4 ) ;\n return pat ;\n }", "idx": 21299}
{"hash": 1353431100313404503, "project": "chrome", "size": 55, "label": 0, "functionSource": "void vp9_decode_frame ( VP9Decoder * pbi , const uint8_t * data , const uint8_t * data_end , const uint8_t * * p_data_end ) {\n VP9_COMMON * const cm = & pbi -> common ;\n MACROBLOCKD * const xd = & pbi -> mb ;\n struct vp9_read_bit_buffer rb = {\n NULL , NULL , 0 , NULL , 0 }\n ;\n uint8_t clear_data [ MAX_VP9_HEADER_SIZE ] ;\n const size_t first_partition_size = read_uncompressed_header ( pbi , init_read_bit_buffer ( pbi , & rb , data , data_end , clear_data ) ) ;\n const int tile_rows = 1 << cm -> log2_tile_rows ;\n const int tile_cols = 1 << cm -> log2_tile_cols ;\n YV12_BUFFER_CONFIG * const new_fb = get_frame_new_buffer ( cm ) ;\n xd -> cur_buf = new_fb ;\n if ( ! first_partition_size ) {\n * p_data_end = data + ( cm -> profile <= PROFILE_2 ? 1 : 2 ) ;\n return ;\n }\n data += vp9_rb_bytes_read ( & rb ) ;\n if ( ! read_is_valid ( data , first_partition_size , data_end ) ) vpx_internal_error ( & cm -> error , VPX_CODEC_CORRUPT_FRAME , \"Truncated packet or corrupt header length\" ) ;\n init_macroblockd ( cm , & pbi -> mb ) ;\n if ( ! cm -> error_resilient_mode ) set_prev_mi ( cm ) ;\n else cm -> prev_mi = NULL ;\n setup_plane_dequants ( cm , xd , cm -> base_qindex ) ;\n vp9_setup_block_planes ( xd , cm -> subsampling_x , cm -> subsampling_y ) ;\n cm -> fc = cm -> frame_contexts [ cm -> frame_context_idx ] ;\n vp9_zero ( cm -> counts ) ;\n vp9_zero ( xd -> dqcoeff ) ;\n xd -> corrupted = 0 ;\n new_fb -> corrupted = read_compressed_header ( pbi , data , first_partition_size ) ;\n if ( pbi -> max_threads > 1 && tile_rows == 1 && tile_cols > 1 && cm -> frame_parallel_decoding_mode ) {\n * p_data_end = decode_tiles_mt ( pbi , data + first_partition_size , data_end ) ;\n if ( ! xd -> corrupted ) {\n vp9_loop_filter_frame_mt ( new_fb , pbi , cm , cm -> lf . filter_level , 0 ) ;\n }\n }\n else {\n * p_data_end = decode_tiles ( pbi , data + first_partition_size , data_end ) ;\n }\n new_fb -> corrupted |= xd -> corrupted ;\n if ( ! new_fb -> corrupted ) {\n if ( ! cm -> error_resilient_mode && ! cm -> frame_parallel_decoding_mode ) {\n vp9_adapt_coef_probs ( cm ) ;\n if ( ! frame_is_intra_only ( cm ) ) {\n vp9_adapt_mode_probs ( cm ) ;\n vp9_adapt_mv_probs ( cm , cm -> allow_high_precision_mv ) ;\n }\n }\n else {\n debug_check_frame_counts ( cm ) ;\n }\n }\n else {\n vpx_internal_error ( & cm -> error , VPX_CODEC_CORRUPT_FRAME , \"Decode failed. Frame data is corrupted.\" ) ;\n }\n if ( cm -> refresh_frame_context ) cm -> frame_contexts [ cm -> frame_context_idx ] = cm -> fc ;\n }", "idx": 21300}
{"hash": -5300415683778646743, "project": "chrome", "size": 3, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( ExtensionMessageBubbleViewBrowserTest , ExtensionBubbleAnchoredToExtensionAction ) {\n TestBubbleAnchoredToExtensionAction ( ) ;\n }", "idx": 21301}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_OCTET_STRING ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_octet_string ( tvb , offset , actx , tree , hf_index , NO_BOUND , NO_BOUND , FALSE , NULL ) ;\n return offset ;\n }", "idx": 21302}
{"hash": -1381237731082039179, "project": "debian", "size": 15, "label": 0, "functionSource": "gboolean ngsniffer_dump_open ( wtap_dumper * wdh , int * err ) {\n ngsniffer_dump_t * ngsniffer ;\n char buf [ 6 ] = {\n REC_VERS , 0x00 , 0x12 , 0x00 , 0x00 , 0x00 }\n ;\n wdh -> subtype_write = ngsniffer_dump ;\n wdh -> subtype_finish = ngsniffer_dump_finish ;\n ngsniffer = ( ngsniffer_dump_t * ) g_malloc ( sizeof ( ngsniffer_dump_t ) ) ;\n wdh -> priv = ( void * ) ngsniffer ;\n ngsniffer -> first_frame = TRUE ;\n ngsniffer -> start = 0 ;\n if ( ! wtap_dump_file_write ( wdh , ngsniffer_magic , sizeof ngsniffer_magic , err ) ) return FALSE ;\n if ( ! wtap_dump_file_write ( wdh , buf , 6 , err ) ) return FALSE ;\n return TRUE ;\n }", "idx": 21303}
{"hash": 1749848421437618984, "project": "chrome", "size": 25, "label": 0, "functionSource": "hb_language_t hb_ot_tag_to_language ( hb_tag_t tag ) {\n unsigned int i ;\n if ( tag == HB_OT_TAG_DEFAULT_LANGUAGE ) return NULL ;\n for ( i = 0 ;\n i < ARRAY_LENGTH ( ot_languages ) ;\n i ++ ) if ( ot_languages [ i ] . tag == tag ) return hb_language_from_string ( ot_languages [ i ] . language , - 1 ) ;\n if ( ( tag & 0xFFFF0000u ) == 0x5A480000u ) {\n switch ( tag ) {\n case HB_TAG ( 'Z' , 'H' , 'H' , ' ' ) : return hb_language_from_string ( \"zh-hk\" , - 1 ) ;\n case HB_TAG ( 'Z' , 'H' , 'S' , ' ' ) : return hb_language_from_string ( \"zh-Hans\" , - 1 ) ;\n case HB_TAG ( 'Z' , 'H' , 'T' , ' ' ) : return hb_language_from_string ( \"zh-Hant\" , - 1 ) ;\n default : break ;\n }\n }\n {\n unsigned char buf [ 11 ] = \"x-hbot\" ;\n buf [ 6 ] = tag >> 24 ;\n buf [ 7 ] = ( tag >> 16 ) & 0xFF ;\n buf [ 8 ] = ( tag >> 8 ) & 0xFF ;\n buf [ 9 ] = tag & 0xFF ;\n if ( buf [ 9 ] == 0x20 ) buf [ 9 ] = '\\0' ;\n buf [ 10 ] = '\\0' ;\n return hb_language_from_string ( ( char * ) buf , - 1 ) ;\n }\n }", "idx": 21304}
{"hash": -2242211406757466627, "project": "debian", "size": 8, "label": 0, "functionSource": "static void add_padding_item ( gint padding_start , gint padding_end , tvbuff_t * tvb , proto_tree * tree ) {\n if ( padding_end > padding_start && padding_end < ( gint ) tvb_reported_length ( tvb ) ) {\n gint padding_length = padding_end - padding_start ;\n if ( padding_length <= MAX_ROUND_TO_BYTES ) {\n proto_tree_add_item ( tree , hf_padding , tvb , padding_start , padding_length , ENC_NA ) ;\n }\n }\n }", "idx": 21305}
{"hash": -4558261210024070448, "project": "chrome", "size": 4, "label": 1, "functionSource": "xmlLinkPtr xmlListEnd ( xmlListPtr l ) {\n if ( l == NULL ) return ( NULL ) ;\n return ( l -> sentinel -> prev ) ;\n }", "idx": 21306}
{"hash": -4239386405881995323, "project": "chrome", "size": 3, "label": 0, "functionSource": "int xmlHashRemoveEntry2 ( xmlHashTablePtr table , const xmlChar * name , const xmlChar * name2 , xmlHashDeallocator f ) {\n return ( xmlHashRemoveEntry3 ( table , name , name2 , NULL , f ) ) ;\n }", "idx": 21307}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_EndSessionCommand ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_EndSessionCommand , EndSessionCommand_choice , NULL ) ;\n return offset ;\n }", "idx": 21308}
{"hash": 7493853980473701704, "project": "debian", "size": 31, "label": 0, "functionSource": "static void gic_set_irq ( void * opaque , int irq , int level ) {\n GICState * s = ( GICState * ) opaque ;\n int cm , target ;\n if ( irq < ( s -> num_irq - GIC_INTERNAL ) ) {\n cm = ALL_CPU_MASK ;\n irq += GIC_INTERNAL ;\n target = GIC_TARGET ( irq ) ;\n }\n else {\n int cpu ;\n irq -= ( s -> num_irq - GIC_INTERNAL ) ;\n cpu = irq / GIC_INTERNAL ;\n irq %= GIC_INTERNAL ;\n cm = 1 << cpu ;\n target = cm ;\n }\n if ( level == GIC_TEST_LEVEL ( irq , cm ) ) {\n return ;\n }\n if ( level ) {\n GIC_SET_LEVEL ( irq , cm ) ;\n if ( GIC_TEST_TRIGGER ( irq ) || GIC_TEST_ENABLED ( irq , cm ) ) {\n DPRINTF ( \"Set %d pending mask %x\\n\" , irq , target ) ;\n GIC_SET_PENDING ( irq , target ) ;\n }\n }\n else {\n GIC_CLEAR_LEVEL ( irq , cm ) ;\n }\n gic_update ( s ) ;\n }", "idx": 21309}
{"hash": 9155638497612715289, "project": "debian", "size": 11, "label": 0, "functionSource": "static void cpu_irq_change ( AlphaCPU * cpu , uint64_t req ) {\n if ( cpu != NULL ) {\n CPUState * cs = CPU ( cpu ) ;\n if ( req ) {\n cpu_interrupt ( cs , CPU_INTERRUPT_HARD ) ;\n }\n else {\n cpu_reset_interrupt ( cs , CPU_INTERRUPT_HARD ) ;\n }\n }\n }", "idx": 21310}
{"hash": 6755873269946787742, "project": "debian", "size": 33, "label": 0, "functionSource": "static void pk_transaction_repo_remove ( PkTransaction * transaction , GVariant * params , GDBusMethodInvocation * context ) {\n PkBitfield transaction_flags ;\n const gchar * repo_id ;\n gboolean autoremove ;\n gboolean ret ;\n g_autoptr ( GError ) error = NULL ;\n g_autofree gchar * tmp = NULL ;\n g_return_if_fail ( PK_IS_TRANSACTION ( transaction ) ) ;\n g_return_if_fail ( transaction -> priv -> tid != NULL ) ;\n g_variant_get ( params , \"(t&sb)\" , & transaction_flags , & repo_id , & autoremove ) ;\n tmp = pk_transaction_flag_bitfield_to_string ( transaction_flags ) ;\n g_debug ( \"RepoRemove method called: %s, %s, %i\" , tmp , repo_id , autoremove ) ;\n if ( ! pk_backend_is_implemented ( transaction -> priv -> backend , PK_ROLE_ENUM_REPO_REMOVE ) ) {\n g_set_error_literal ( & error , PK_TRANSACTION_ERROR , PK_TRANSACTION_ERROR_NOT_SUPPORTED , \"RepoSetData not supported by backend\" ) ;\n pk_transaction_set_state ( transaction , PK_TRANSACTION_STATE_ERROR ) ;\n goto out ;\n }\n ret = pk_transaction_strvalidate ( repo_id , & error ) ;\n if ( ! ret ) {\n pk_transaction_set_state ( transaction , PK_TRANSACTION_STATE_ERROR ) ;\n goto out ;\n }\n transaction -> priv -> cached_repo_id = g_strdup ( repo_id ) ;\n transaction -> priv -> cached_transaction_flags = transaction_flags ;\n transaction -> priv -> cached_autoremove = autoremove ;\n pk_transaction_set_role ( transaction , PK_ROLE_ENUM_REPO_REMOVE ) ;\n ret = pk_transaction_obtain_authorization ( transaction , PK_ROLE_ENUM_REPO_REMOVE , & error ) ;\n if ( ! ret ) {\n pk_transaction_set_state ( transaction , PK_TRANSACTION_STATE_ERROR ) ;\n goto out ;\n }\n out : pk_transaction_dbus_return ( context , error ) ;\n }", "idx": 21311}
{"hash": -3146697469509848825, "project": "debian", "size": 30, "label": 0, "functionSource": "static int dsa_sig_print ( BIO * bp , const X509_ALGOR * sigalg , const ASN1_STRING * sig , int indent , ASN1_PCTX * pctx ) {\n DSA_SIG * dsa_sig ;\n const unsigned char * p ;\n if ( ! sig ) {\n if ( BIO_puts ( bp , \"\\n\" ) <= 0 ) return 0 ;\n else return 1 ;\n }\n p = sig -> data ;\n dsa_sig = d2i_DSA_SIG ( NULL , & p , sig -> length ) ;\n if ( dsa_sig ) {\n int rv = 0 ;\n size_t buf_len = 0 ;\n unsigned char * m = NULL ;\n update_buflen ( dsa_sig -> r , & buf_len ) ;\n update_buflen ( dsa_sig -> s , & buf_len ) ;\n m = OPENSSL_malloc ( buf_len + 10 ) ;\n if ( m == NULL ) {\n DSAerr ( DSA_F_DSA_SIG_PRINT , ERR_R_MALLOC_FAILURE ) ;\n goto err ;\n }\n if ( BIO_write ( bp , \"\\n\" , 1 ) != 1 ) goto err ;\n if ( ! ASN1_bn_print ( bp , \"r: \" , dsa_sig -> r , m , indent ) ) goto err ;\n if ( ! ASN1_bn_print ( bp , \"s: \" , dsa_sig -> s , m , indent ) ) goto err ;\n rv = 1 ;\n err : OPENSSL_free ( m ) ;\n DSA_SIG_free ( dsa_sig ) ;\n return rv ;\n }\n return X509_signature_dump ( bp , sig , indent ) ;\n }", "idx": 21312}
{"hash": -2922528420890432122, "project": "debian", "size": 290, "label": 0, "functionSource": "static int wma_decode_block ( WMACodecContext * s ) {\n int n , v , a , ch , bsize ;\n int coef_nb_bits , total_gain ;\n int nb_coefs [ MAX_CHANNELS ] ;\n float mdct_norm ;\n FFTContext * mdct ;\n # ifdef TRACE tprintf ( s -> avctx , \"***decode_block: %d:%d\\n\" , s -> frame_count - 1 , s -> block_num ) ;\n # endif if ( s -> use_variable_block_len ) {\n n = av_log2 ( s -> nb_block_sizes - 1 ) + 1 ;\n if ( s -> reset_block_lengths ) {\n s -> reset_block_lengths = 0 ;\n v = get_bits ( & s -> gb , n ) ;\n if ( v >= s -> nb_block_sizes ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"prev_block_len_bits %d out of range\\n\" , s -> frame_len_bits - v ) ;\n return - 1 ;\n }\n s -> prev_block_len_bits = s -> frame_len_bits - v ;\n v = get_bits ( & s -> gb , n ) ;\n if ( v >= s -> nb_block_sizes ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"block_len_bits %d out of range\\n\" , s -> frame_len_bits - v ) ;\n return - 1 ;\n }\n s -> block_len_bits = s -> frame_len_bits - v ;\n }\n else {\n s -> prev_block_len_bits = s -> block_len_bits ;\n s -> block_len_bits = s -> next_block_len_bits ;\n }\n v = get_bits ( & s -> gb , n ) ;\n if ( v >= s -> nb_block_sizes ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"next_block_len_bits %d out of range\\n\" , s -> frame_len_bits - v ) ;\n return - 1 ;\n }\n s -> next_block_len_bits = s -> frame_len_bits - v ;\n }\n else {\n s -> next_block_len_bits = s -> frame_len_bits ;\n s -> prev_block_len_bits = s -> frame_len_bits ;\n s -> block_len_bits = s -> frame_len_bits ;\n }\n s -> block_len = 1 << s -> block_len_bits ;\n if ( ( s -> block_pos + s -> block_len ) > s -> frame_len ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"frame_len overflow\\n\" ) ;\n return - 1 ;\n }\n if ( s -> avctx -> channels == 2 ) {\n s -> ms_stereo = get_bits1 ( & s -> gb ) ;\n }\n v = 0 ;\n for ( ch = 0 ;\n ch < s -> avctx -> channels ;\n ch ++ ) {\n a = get_bits1 ( & s -> gb ) ;\n s -> channel_coded [ ch ] = a ;\n v |= a ;\n }\n bsize = s -> frame_len_bits - s -> block_len_bits ;\n if ( ! v ) goto next ;\n total_gain = 1 ;\n for ( ;\n ;\n ) {\n a = get_bits ( & s -> gb , 7 ) ;\n total_gain += a ;\n if ( a != 127 ) break ;\n }\n coef_nb_bits = ff_wma_total_gain_to_bits ( total_gain ) ;\n n = s -> coefs_end [ bsize ] - s -> coefs_start ;\n for ( ch = 0 ;\n ch < s -> avctx -> channels ;\n ch ++ ) nb_coefs [ ch ] = n ;\n if ( s -> use_noise_coding ) {\n for ( ch = 0 ;\n ch < s -> avctx -> channels ;\n ch ++ ) {\n if ( s -> channel_coded [ ch ] ) {\n int i , n , a ;\n n = s -> exponent_high_sizes [ bsize ] ;\n for ( i = 0 ;\n i < n ;\n i ++ ) {\n a = get_bits1 ( & s -> gb ) ;\n s -> high_band_coded [ ch ] [ i ] = a ;\n if ( a ) nb_coefs [ ch ] -= s -> exponent_high_bands [ bsize ] [ i ] ;\n }\n }\n }\n for ( ch = 0 ;\n ch < s -> avctx -> channels ;\n ch ++ ) {\n if ( s -> channel_coded [ ch ] ) {\n int i , n , val , code ;\n n = s -> exponent_high_sizes [ bsize ] ;\n val = ( int ) 0x80000000 ;\n for ( i = 0 ;\n i < n ;\n i ++ ) {\n if ( s -> high_band_coded [ ch ] [ i ] ) {\n if ( val == ( int ) 0x80000000 ) {\n val = get_bits ( & s -> gb , 7 ) - 19 ;\n }\n else {\n code = get_vlc2 ( & s -> gb , s -> hgain_vlc . table , HGAINVLCBITS , HGAINMAX ) ;\n if ( code < 0 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"hgain vlc invalid\\n\" ) ;\n return - 1 ;\n }\n val += code - 18 ;\n }\n s -> high_band_values [ ch ] [ i ] = val ;\n }\n }\n }\n }\n }\n if ( ( s -> block_len_bits == s -> frame_len_bits ) || get_bits1 ( & s -> gb ) ) {\n for ( ch = 0 ;\n ch < s -> avctx -> channels ;\n ch ++ ) {\n if ( s -> channel_coded [ ch ] ) {\n if ( s -> use_exp_vlc ) {\n if ( decode_exp_vlc ( s , ch ) < 0 ) return - 1 ;\n }\n else {\n decode_exp_lsp ( s , ch ) ;\n }\n s -> exponents_bsize [ ch ] = bsize ;\n }\n }\n }\n for ( ch = 0 ;\n ch < s -> avctx -> channels ;\n ch ++ ) {\n if ( s -> channel_coded [ ch ] ) {\n int tindex ;\n WMACoef * ptr = & s -> coefs1 [ ch ] [ 0 ] ;\n tindex = ( ch == 1 && s -> ms_stereo ) ;\n memset ( ptr , 0 , s -> block_len * sizeof ( WMACoef ) ) ;\n ff_wma_run_level_decode ( s -> avctx , & s -> gb , & s -> coef_vlc [ tindex ] , s -> level_table [ tindex ] , s -> run_table [ tindex ] , 0 , ptr , 0 , nb_coefs [ ch ] , s -> block_len , s -> frame_len_bits , coef_nb_bits ) ;\n }\n if ( s -> version == 1 && s -> avctx -> channels >= 2 ) {\n align_get_bits ( & s -> gb ) ;\n }\n }\n {\n int n4 = s -> block_len / 2 ;\n mdct_norm = 1.0 / ( float ) n4 ;\n if ( s -> version == 1 ) {\n mdct_norm *= sqrt ( n4 ) ;\n }\n }\n for ( ch = 0 ;\n ch < s -> avctx -> channels ;\n ch ++ ) {\n if ( s -> channel_coded [ ch ] ) {\n WMACoef * coefs1 ;\n float * coefs , * exponents , mult , mult1 , noise ;\n int i , j , n , n1 , last_high_band , esize ;\n float exp_power [ HIGH_BAND_MAX_SIZE ] ;\n coefs1 = s -> coefs1 [ ch ] ;\n exponents = s -> exponents [ ch ] ;\n esize = s -> exponents_bsize [ ch ] ;\n mult = pow ( 10 , total_gain * 0.05 ) / s -> max_exponent [ ch ] ;\n mult *= mdct_norm ;\n coefs = s -> coefs [ ch ] ;\n if ( s -> use_noise_coding ) {\n mult1 = mult ;\n for ( i = 0 ;\n i < s -> coefs_start ;\n i ++ ) {\n * coefs ++ = s -> noise_table [ s -> noise_index ] * exponents [ i << bsize >> esize ] * mult1 ;\n s -> noise_index = ( s -> noise_index + 1 ) & ( NOISE_TAB_SIZE - 1 ) ;\n }\n n1 = s -> exponent_high_sizes [ bsize ] ;\n exponents = s -> exponents [ ch ] + ( s -> high_band_start [ bsize ] << bsize >> esize ) ;\n last_high_band = 0 ;\n for ( j = 0 ;\n j < n1 ;\n j ++ ) {\n n = s -> exponent_high_bands [ s -> frame_len_bits - s -> block_len_bits ] [ j ] ;\n if ( s -> high_band_coded [ ch ] [ j ] ) {\n float e2 , v ;\n e2 = 0 ;\n for ( i = 0 ;\n i < n ;\n i ++ ) {\n v = exponents [ i << bsize >> esize ] ;\n e2 += v * v ;\n }\n exp_power [ j ] = e2 / n ;\n last_high_band = j ;\n tprintf ( s -> avctx , \"%d: power=%f (%d)\\n\" , j , exp_power [ j ] , n ) ;\n }\n exponents += n << bsize >> esize ;\n }\n exponents = s -> exponents [ ch ] + ( s -> coefs_start << bsize >> esize ) ;\n for ( j = - 1 ;\n j < n1 ;\n j ++ ) {\n if ( j < 0 ) {\n n = s -> high_band_start [ bsize ] - s -> coefs_start ;\n }\n else {\n n = s -> exponent_high_bands [ s -> frame_len_bits - s -> block_len_bits ] [ j ] ;\n }\n if ( j >= 0 && s -> high_band_coded [ ch ] [ j ] ) {\n mult1 = sqrt ( exp_power [ j ] / exp_power [ last_high_band ] ) ;\n mult1 = mult1 * pow ( 10 , s -> high_band_values [ ch ] [ j ] * 0.05 ) ;\n mult1 = mult1 / ( s -> max_exponent [ ch ] * s -> noise_mult ) ;\n mult1 *= mdct_norm ;\n for ( i = 0 ;\n i < n ;\n i ++ ) {\n noise = s -> noise_table [ s -> noise_index ] ;\n s -> noise_index = ( s -> noise_index + 1 ) & ( NOISE_TAB_SIZE - 1 ) ;\n * coefs ++ = noise * exponents [ i << bsize >> esize ] * mult1 ;\n }\n exponents += n << bsize >> esize ;\n }\n else {\n for ( i = 0 ;\n i < n ;\n i ++ ) {\n noise = s -> noise_table [ s -> noise_index ] ;\n s -> noise_index = ( s -> noise_index + 1 ) & ( NOISE_TAB_SIZE - 1 ) ;\n * coefs ++ = ( ( * coefs1 ++ ) + noise ) * exponents [ i << bsize >> esize ] * mult ;\n }\n exponents += n << bsize >> esize ;\n }\n }\n n = s -> block_len - s -> coefs_end [ bsize ] ;\n mult1 = mult * exponents [ ( ( - 1 << bsize ) ) >> esize ] ;\n for ( i = 0 ;\n i < n ;\n i ++ ) {\n * coefs ++ = s -> noise_table [ s -> noise_index ] * mult1 ;\n s -> noise_index = ( s -> noise_index + 1 ) & ( NOISE_TAB_SIZE - 1 ) ;\n }\n }\n else {\n for ( i = 0 ;\n i < s -> coefs_start ;\n i ++ ) * coefs ++ = 0.0 ;\n n = nb_coefs [ ch ] ;\n for ( i = 0 ;\n i < n ;\n i ++ ) {\n * coefs ++ = coefs1 [ i ] * exponents [ i << bsize >> esize ] * mult ;\n }\n n = s -> block_len - s -> coefs_end [ bsize ] ;\n for ( i = 0 ;\n i < n ;\n i ++ ) * coefs ++ = 0.0 ;\n }\n }\n }\n # ifdef TRACE for ( ch = 0 ;\n ch < s -> avctx -> channels ;\n ch ++ ) {\n if ( s -> channel_coded [ ch ] ) {\n dump_floats ( s , \"exponents\" , 3 , s -> exponents [ ch ] , s -> block_len ) ;\n dump_floats ( s , \"coefs\" , 1 , s -> coefs [ ch ] , s -> block_len ) ;\n }\n }\n # endif if ( s -> ms_stereo && s -> channel_coded [ 1 ] ) {\n if ( ! s -> channel_coded [ 0 ] ) {\n tprintf ( s -> avctx , \"rare ms-stereo case happened\\n\" ) ;\n memset ( s -> coefs [ 0 ] , 0 , sizeof ( float ) * s -> block_len ) ;\n s -> channel_coded [ 0 ] = 1 ;\n }\n s -> fdsp . butterflies_float ( s -> coefs [ 0 ] , s -> coefs [ 1 ] , s -> block_len ) ;\n }\n next : mdct = & s -> mdct_ctx [ bsize ] ;\n for ( ch = 0 ;\n ch < s -> avctx -> channels ;\n ch ++ ) {\n int n4 , index ;\n n4 = s -> block_len / 2 ;\n if ( s -> channel_coded [ ch ] ) {\n mdct -> imdct_calc ( mdct , s -> output , s -> coefs [ ch ] ) ;\n }\n else if ( ! ( s -> ms_stereo && ch == 1 ) ) memset ( s -> output , 0 , sizeof ( s -> output ) ) ;\n index = ( s -> frame_len / 2 ) + s -> block_pos - n4 ;\n wma_window ( s , & s -> frame_out [ ch ] [ index ] ) ;\n }\n s -> block_num ++ ;\n s -> block_pos += s -> block_len ;\n if ( s -> block_pos >= s -> frame_len ) return 1 ;\n else return 0 ;\n }", "idx": 21313}
{"hash": -8962831256613787672, "project": "debian", "size": 3, "label": 0, "functionSource": "static void midi_data_reassemble_init ( void ) {\n reassembly_table_init ( & midi_data_reassembly_table , & addresses_reassembly_table_functions ) ;\n }", "idx": 21314}
{"hash": -3559021711340554904, "project": "debian", "size": 13, "label": 0, "functionSource": "static bool contain_agg_clause_walker ( Node * node , void * context ) {\n if ( node == NULL ) return false ;\n if ( IsA ( node , Aggref ) ) {\n Assert ( ( ( Aggref * ) node ) -> agglevelsup == 0 ) ;\n return true ;\n }\n if ( IsA ( node , GroupingFunc ) ) {\n Assert ( ( ( GroupingFunc * ) node ) -> agglevelsup == 0 ) ;\n return true ;\n }\n Assert ( ! IsA ( node , SubLink ) ) ;\n return expression_tree_walker ( node , contain_agg_clause_walker , context ) ;\n }", "idx": 21315}
{"hash": 6632536031698733342, "project": "debian", "size": 8, "label": 0, "functionSource": "static void writer_print_ts ( WriterContext * wctx , const char * key , int64_t ts , int is_duration ) {\n if ( ( ! is_duration && ts == AV_NOPTS_VALUE ) || ( is_duration && ts == 0 ) ) {\n writer_print_string ( wctx , key , \"N/A\" , PRINT_STRING_OPT ) ;\n }\n else {\n writer_print_integer ( wctx , key , ts ) ;\n }\n }", "idx": 21316}
{"hash": 4537091194729139981, "project": "chrome", "size": 37, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( FullscreenControllerInteractiveTest , DISABLED_MouseLockAndFullscreen ) {\n ASSERT_TRUE ( test_server ( ) -> Start ( ) ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , test_server ( ) -> GetURL ( kFullscreenMouseLockHTML ) ) ;\n ASSERT_FALSE ( IsFullscreenBubbleDisplayed ( ) ) ;\n {\n FullscreenNotificationObserver fullscreen_observer ;\n ASSERT_TRUE ( ui_test_utils : : SendKeyPressAndWait ( browser ( ) , ui : : VKEY_B , false , true , false , false , chrome : : NOTIFICATION_MOUSE_LOCK_CHANGED , content : : NotificationService : : AllSources ( ) ) ) ;\n fullscreen_observer . Wait ( ) ;\n }\n ASSERT_TRUE ( IsFullscreenBubbleDisplayed ( ) ) ;\n ASSERT_TRUE ( IsFullscreenPermissionRequested ( ) ) ;\n ASSERT_TRUE ( IsMouseLockPermissionRequested ( ) ) ;\n ASSERT_FALSE ( IsMouseLocked ( ) ) ;\n ASSERT_TRUE ( IsWindowFullscreenForTabOrPending ( ) ) ;\n {\n FullscreenNotificationObserver fullscreen_observer ;\n DenyCurrentFullscreenOrMouseLockRequest ( ) ;\n fullscreen_observer . Wait ( ) ;\n }\n ASSERT_FALSE ( IsMouseLocked ( ) ) ;\n ASSERT_FALSE ( IsWindowFullscreenForTabOrPending ( ) ) ;\n ASSERT_FALSE ( IsFullscreenPermissionRequested ( ) ) ;\n {\n FullscreenNotificationObserver fullscreen_observer ;\n ASSERT_TRUE ( ui_test_utils : : SendKeyPressAndWait ( browser ( ) , ui : : VKEY_B , false , true , false , false , chrome : : NOTIFICATION_MOUSE_LOCK_CHANGED , content : : NotificationService : : AllSources ( ) ) ) ;\n fullscreen_observer . Wait ( ) ;\n }\n ASSERT_TRUE ( IsFullscreenBubbleDisplayed ( ) ) ;\n ASSERT_TRUE ( IsFullscreenPermissionRequested ( ) ) ;\n ASSERT_TRUE ( IsMouseLockPermissionRequested ( ) ) ;\n ASSERT_FALSE ( IsMouseLocked ( ) ) ;\n ASSERT_TRUE ( IsWindowFullscreenForTabOrPending ( ) ) ;\n AcceptCurrentFullscreenOrMouseLockRequest ( ) ;\n ASSERT_TRUE ( IsMouseLocked ( ) ) ;\n ASSERT_TRUE ( IsWindowFullscreenForTabOrPending ( ) ) ;\n ASSERT_FALSE ( IsFullscreenPermissionRequested ( ) ) ;\n }", "idx": 21317}
{"hash": 1760449185745615462, "project": "debian", "size": 3, "label": 0, "functionSource": "TSReturnCode sdk_sanity_check_lifecycle_hook_id ( TSLifecycleHookID id ) {\n return LifecycleAPIHooks : : is_valid ( id ) ? TS_SUCCESS : TS_ERROR ;\n }", "idx": 21318}
{"hash": -5268859819325807498, "project": "debian", "size": 12, "label": 0, "functionSource": "static gboolean should_skip_file ( NautilusDirectory * directory , GFileInfo * info ) {\n static gboolean show_hidden_files_changed_callback_installed = FALSE ;\n if ( ! show_hidden_files_changed_callback_installed ) {\n g_signal_connect_swapped ( gtk_filechooser_preferences , \"changed::\" NAUTILUS_PREFERENCES_SHOW_HIDDEN_FILES , G_CALLBACK ( show_hidden_files_changed_callback ) , NULL ) ;\n show_hidden_files_changed_callback_installed = TRUE ;\n show_hidden_files_changed_callback ( NULL ) ;\n }\n if ( ! show_hidden_files && ( g_file_info_get_is_hidden ( info ) || g_file_info_get_is_backup ( info ) ) ) {\n return TRUE ;\n }\n return FALSE ;\n }", "idx": 21319}
{"hash": 8849962823026424130, "project": "debian", "size": 58, "label": 0, "functionSource": "static int qio_channel_websock_decode_payload ( QIOChannelWebsock * ioc , Error * * errp ) {\n size_t i ;\n size_t payload_len = 0 ;\n uint32_t * payload32 ;\n if ( ioc -> payload_remain ) {\n if ( ioc -> encinput . offset < ioc -> payload_remain ) {\n if ( ioc -> opcode & QIO_CHANNEL_WEBSOCK_CONTROL_OPCODE_MASK ) {\n return QIO_CHANNEL_ERR_BLOCK ;\n }\n payload_len = ioc -> encinput . offset - ( ioc -> encinput . offset % 4 ) ;\n }\n else {\n payload_len = ioc -> payload_remain ;\n }\n if ( payload_len == 0 ) {\n return QIO_CHANNEL_ERR_BLOCK ;\n }\n ioc -> payload_remain -= payload_len ;\n payload32 = ( uint32_t * ) ioc -> encinput . buffer ;\n for ( i = 0 ;\n i < payload_len / 4 ;\n i ++ ) {\n payload32 [ i ] ^= ioc -> mask . u ;\n }\n for ( i *= 4 ;\n i < payload_len ;\n i ++ ) {\n ioc -> encinput . buffer [ i ] ^= ioc -> mask . c [ i % 4 ] ;\n }\n }\n trace_qio_channel_websock_payload_decode ( ioc , ioc -> opcode , ioc -> payload_remain ) ;\n if ( ioc -> opcode == QIO_CHANNEL_WEBSOCK_OPCODE_BINARY_FRAME ) {\n if ( payload_len ) {\n buffer_reserve ( & ioc -> rawinput , payload_len ) ;\n buffer_append ( & ioc -> rawinput , ioc -> encinput . buffer , payload_len ) ;\n }\n }\n else if ( ioc -> opcode == QIO_CHANNEL_WEBSOCK_OPCODE_CLOSE ) {\n error_setg ( errp , \"websocket closed by peer\" ) ;\n if ( payload_len ) {\n qio_channel_websock_encode_buffer ( ioc , & ioc -> encoutput , QIO_CHANNEL_WEBSOCK_OPCODE_CLOSE , & ioc -> encinput ) ;\n qio_channel_websock_write_wire ( ioc , NULL ) ;\n qio_channel_shutdown ( ioc -> master , QIO_CHANNEL_SHUTDOWN_BOTH , NULL ) ;\n }\n else {\n qio_channel_websock_write_close ( ioc , QIO_CHANNEL_WEBSOCK_STATUS_NORMAL , \"peer requested close\" ) ;\n }\n return - 1 ;\n }\n else if ( ioc -> opcode == QIO_CHANNEL_WEBSOCK_OPCODE_PING ) {\n buffer_reset ( & ioc -> ping_reply ) ;\n qio_channel_websock_encode_buffer ( ioc , & ioc -> ping_reply , QIO_CHANNEL_WEBSOCK_OPCODE_PONG , & ioc -> encinput ) ;\n }\n if ( payload_len ) {\n buffer_advance ( & ioc -> encinput , payload_len ) ;\n }\n return 0 ;\n }", "idx": 21320}
{"hash": -6333668321124139371, "project": "debian", "size": 55, "label": 0, "functionSource": "static void dissect_rtp_hdr_ext_ed137a ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree ) {\n unsigned int offset = 0 ;\n unsigned int hdr_extension_len = 0 ;\n proto_item * ti = NULL ;\n proto_item * ti2 = NULL ;\n proto_tree * rtp_hext_tree = NULL ;\n proto_tree * rtp_hext_tree2 = NULL ;\n unsigned int i ;\n guint32 ext_value ;\n unsigned int ft_type = 0 ;\n hdr_extension_len = tvb_reported_length ( tvb ) / 4 ;\n if ( hdr_extension_len > 0 ) {\n unsigned int hdrext_offset = 0 ;\n if ( tree ) {\n ti = proto_tree_add_item ( tree , hf_rtp_hdr_ed137s , tvb , offset , hdr_extension_len * 4 , ENC_NA ) ;\n rtp_hext_tree = proto_item_add_subtree ( ti , ett_hdr_ext_ed137s ) ;\n }\n for ( i = 0 ;\n i < hdr_extension_len ;\n i ++ ) {\n if ( tree ) {\n ti2 = proto_tree_add_item ( rtp_hext_tree , hf_rtp_hdr_ed137a , tvb , hdrext_offset , 4 , ENC_NA ) ;\n rtp_hext_tree2 = proto_item_add_subtree ( ti2 , ett_hdr_ext_ed137a ) ;\n ext_value = tvb_get_ntohl ( tvb , hdrext_offset ) ;\n if ( RTP_ED137A_ptt_mask ( ext_value ) ) {\n col_append_str ( pinfo -> cinfo , COL_INFO , \", PTT\" ) ;\n }\n if ( RTP_ED137A_squ_mask ( ext_value ) ) {\n col_append_str ( pinfo -> cinfo , COL_INFO , \", SQU\" ) ;\n }\n proto_tree_add_item ( rtp_hext_tree2 , hf_rtp_hdr_ed137a_ptt_type , tvb , hdrext_offset , 4 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rtp_hext_tree2 , hf_rtp_hdr_ed137a_squ , tvb , hdrext_offset , 4 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rtp_hext_tree2 , hf_rtp_hdr_ed137a_ptt_id , tvb , hdrext_offset , 4 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rtp_hext_tree2 , hf_rtp_hdr_ed137a_pm , tvb , hdrext_offset , 4 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rtp_hext_tree2 , hf_rtp_hdr_ed137a_ptts , tvb , hdrext_offset , 4 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rtp_hext_tree2 , hf_rtp_hdr_ed137a_sct , tvb , hdrext_offset , 4 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rtp_hext_tree2 , hf_rtp_hdr_ed137a_reserved , tvb , hdrext_offset , 4 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rtp_hext_tree2 , hf_rtp_hdr_ed137a_x , tvb , hdrext_offset , 4 , ENC_BIG_ENDIAN ) ;\n if ( RTP_ED137A_extended_information ( ext_value ) ) {\n proto_tree_add_item ( rtp_hext_tree2 , hf_rtp_hdr_ed137a_ft_type , tvb , hdrext_offset , 4 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rtp_hext_tree2 , hf_rtp_hdr_ed137a_ft_len , tvb , hdrext_offset , 4 , ENC_BIG_ENDIAN ) ;\n ft_type = RTP_ED137A_feature_type ( ext_value ) ;\n switch ( ft_type ) {\n default : proto_tree_add_item ( rtp_hext_tree2 , hf_rtp_hdr_ed137a_ft_value , tvb , hdrext_offset , 4 , ENC_BIG_ENDIAN ) ;\n break ;\n }\n }\n else {\n proto_tree_add_item ( rtp_hext_tree2 , hf_rtp_hdr_ed137a_x_nu , tvb , hdrext_offset , 4 , ENC_BIG_ENDIAN ) ;\n }\n }\n hdrext_offset += 4 ;\n }\n }\n }", "idx": 21321}
{"hash": 1859256631654516868, "project": "chrome", "size": 78, "label": 0, "functionSource": "const uint8_t * ff_h264_decode_nal ( H264Context * h , const uint8_t * src , int * dst_length , int * consumed , int length ) {\n int i , si , di ;\n uint8_t * dst ;\n int bufidx ;\n h -> nal_ref_idc = src [ 0 ] >> 5 ;\n h -> nal_unit_type = src [ 0 ] & 0x1F ;\n src ++ ;\n length -- ;\n # define STARTCODE_TEST if ( i + 2 < length && src [ i + 1 ] == 0 && src [ i + 2 ] <= 3 ) {\n if ( src [ i + 2 ] != 3 ) {\n length = i ;\n }\n break ;\n }\n # if HAVE_FAST_UNALIGNED # define FIND_FIRST_ZERO if ( i > 0 && ! src [ i ] ) i -- ;\n while ( src [ i ] ) i ++ # if HAVE_FAST_64BIT for ( i = 0 ;\n i + 1 < length ;\n i += 9 ) {\n if ( ! ( ( ~ AV_RN64A ( src + i ) & ( AV_RN64A ( src + i ) - 0x0100010001000101ULL ) ) & 0x8000800080008080ULL ) ) continue ;\n FIND_FIRST_ZERO ;\n STARTCODE_TEST ;\n i -= 7 ;\n }\n # else for ( i = 0 ;\n i + 1 < length ;\n i += 5 ) {\n if ( ! ( ( ~ AV_RN32A ( src + i ) & ( AV_RN32A ( src + i ) - 0x01000101U ) ) & 0x80008080U ) ) continue ;\n FIND_FIRST_ZERO ;\n STARTCODE_TEST ;\n i -= 3 ;\n }\n # endif # else for ( i = 0 ;\n i + 1 < length ;\n i += 2 ) {\n if ( src [ i ] ) continue ;\n if ( i > 0 && src [ i - 1 ] == 0 ) i -- ;\n STARTCODE_TEST ;\n }\n # endif bufidx = h -> nal_unit_type == NAL_DPC ? 1 : 0 ;\n si = h -> rbsp_buffer_size [ bufidx ] ;\n av_fast_padded_malloc ( & h -> rbsp_buffer [ bufidx ] , & h -> rbsp_buffer_size [ bufidx ] , length + MAX_MBPAIR_SIZE ) ;\n dst = h -> rbsp_buffer [ bufidx ] ;\n if ( dst == NULL ) return NULL ;\n if ( i >= length - 1 ) {\n / o escaped 0 * dst_length = length ;\n * consumed = length + 1 ;\n if ( h -> avctx -> flags2 & CODEC_FLAG2_FAST ) {\n return src ;\n }\n else {\n memcpy ( dst , src , length ) ;\n return dst ;\n }\n }\n memcpy ( dst , src , i ) ;\n si = di = i ;\n while ( si + 2 < length ) {\n if ( src [ si + 2 ] > 3 ) {\n dst [ di ++ ] = src [ si ++ ] ;\n dst [ di ++ ] = src [ si ++ ] ;\n }\n else if ( src [ si ] == 0 && src [ si + 1 ] == 0 ) {\n if ( src [ si + 2 ] == 3 ) {\n dst [ di ++ ] = 0 ;\n dst [ di ++ ] = 0 ;\n si += 3 ;\n continue ;\n }\n else goto nsc ;\n }\n dst [ di ++ ] = src [ si ++ ] ;\n }\n while ( si < length ) dst [ di ++ ] = src [ si ++ ] ;\n nsc : memset ( dst + di , 0 , FF_INPUT_BUFFER_PADDING_SIZE ) ;\n * dst_length = di ;\n * consumed = si + 1 ;\n return dst ;\n }", "idx": 21322}
{"hash": -2607754285145856562, "project": "debian", "size": 26, "label": 0, "functionSource": "static int _compare_path_table ( const void * v1 , const void * v2 ) {\n const struct isoent * p1 , * p2 ;\n const char * s1 , * s2 ;\n int cmp , l ;\n p1 = * ( ( const struct isoent * * ) ( uintptr_t ) v1 ) ;\n p2 = * ( ( const struct isoent * * ) ( uintptr_t ) v2 ) ;\n cmp = p1 -> parent -> dir_number - p2 -> parent -> dir_number ;\n if ( cmp != 0 ) return ( cmp ) ;\n s1 = p1 -> identifier ;\n s2 = p2 -> identifier ;\n l = p1 -> ext_off ;\n if ( l > p2 -> ext_off ) l = p2 -> ext_off ;\n cmp = strncmp ( s1 , s2 , l ) ;\n if ( cmp != 0 ) return ( cmp ) ;\n if ( p1 -> ext_off < p2 -> ext_off ) {\n s2 += l ;\n l = p2 -> ext_off - p1 -> ext_off ;\n while ( l -- ) if ( 0x20 != * s2 ++ ) return ( 0x20 - * ( const unsigned char * ) ( s2 - 1 ) ) ;\n }\n else if ( p1 -> ext_off > p2 -> ext_off ) {\n s1 += l ;\n l = p1 -> ext_off - p2 -> ext_off ;\n while ( l -- ) if ( 0x20 != * s1 ++ ) return ( * ( const unsigned char * ) ( s1 - 1 ) - 0x20 ) ;\n }\n return ( 0 ) ;\n }", "idx": 21323}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_H262VideoMode ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_H262VideoMode , H262VideoMode_sequence ) ;\n return offset ;\n }", "idx": 21324}
{"hash": 1700977331036764538, "project": "debian", "size": 47, "label": 0, "functionSource": "int EVP_DecryptFinal_ex ( EVP_CIPHER_CTX * ctx , unsigned char * out , int * outl ) {\n int i , n ;\n unsigned int b ;\n * outl = 0 ;\n if ( ctx -> cipher -> flags & EVP_CIPH_FLAG_CUSTOM_CIPHER ) {\n i = ctx -> cipher -> do_cipher ( ctx , out , NULL , 0 ) ;\n if ( i < 0 ) return 0 ;\n else * outl = i ;\n return 1 ;\n }\n b = ctx -> cipher -> block_size ;\n if ( ctx -> flags & EVP_CIPH_NO_PADDING ) {\n if ( ctx -> buf_len ) {\n EVPerr ( EVP_F_EVP_DECRYPTFINAL_EX , EVP_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH ) ;\n return 0 ;\n }\n * outl = 0 ;\n return 1 ;\n }\n if ( b > 1 ) {\n if ( ctx -> buf_len || ! ctx -> final_used ) {\n EVPerr ( EVP_F_EVP_DECRYPTFINAL_EX , EVP_R_WRONG_FINAL_BLOCK_LENGTH ) ;\n return ( 0 ) ;\n }\n OPENSSL_assert ( b <= sizeof ctx -> final ) ;\n n = ctx -> final [ b - 1 ] ;\n if ( n == 0 || n > ( int ) b ) {\n EVPerr ( EVP_F_EVP_DECRYPTFINAL_EX , EVP_R_BAD_DECRYPT ) ;\n return ( 0 ) ;\n }\n for ( i = 0 ;\n i < n ;\n i ++ ) {\n if ( ctx -> final [ -- b ] != n ) {\n EVPerr ( EVP_F_EVP_DECRYPTFINAL_EX , EVP_R_BAD_DECRYPT ) ;\n return ( 0 ) ;\n }\n }\n n = ctx -> cipher -> block_size - n ;\n for ( i = 0 ;\n i < n ;\n i ++ ) out [ i ] = ctx -> final [ i ] ;\n * outl = n ;\n }\n else * outl = 0 ;\n return ( 1 ) ;\n }", "idx": 21325}
{"hash": 378220832151730865, "project": "debian", "size": 31, "label": 0, "functionSource": "int qemuMonitorTextGetBlockStatsParamsNumber ( qemuMonitorPtr mon , int * nparams ) {\n char * info = NULL ;\n int ret = - 1 ;\n int num = 0 ;\n const char * p , * eol ;\n if ( qemuMonitorHMPCommand ( mon , \"info blockstats\" , & info ) < 0 ) {\n qemuReportError ( VIR_ERR_OPERATION_FAILED , \"%s\" , _ ( \"'info blockstats' command failed\" ) ) ;\n goto cleanup ;\n }\n if ( strstr ( info , \"\\ninfo \" ) ) {\n qemuReportError ( VIR_ERR_OPERATION_INVALID , \"%s\" , _ ( \"'info blockstats' not supported by this qemu\" ) ) ;\n goto cleanup ;\n }\n p = info ;\n eol = strchr ( p , '\\n' ) ;\n if ( ! eol ) eol = p + strlen ( p ) ;\n p = strchr ( p , ' ' ) ;\n while ( p && p < eol ) {\n if ( STRPREFIX ( p , \" rd_bytes=\" ) || STRPREFIX ( p , \" wr_bytes=\" ) || STRPREFIX ( p , \" rd_operations=\" ) || STRPREFIX ( p , \" wr_operations=\" ) || STRPREFIX ( p , \" rd_total_times_ns=\" ) || STRPREFIX ( p , \" wr_total_times_ns=\" ) || STRPREFIX ( p , \" flush_operations=\" ) || STRPREFIX ( p , \" flush_total_times_ns=\" ) ) {\n num ++ ;\n }\n else {\n VIR_DEBUG ( \"unknown block stat near %s\" , p ) ;\n }\n p = strchr ( p + 1 , ' ' ) ;\n }\n * nparams = num ;\n ret = 0 ;\n cleanup : VIR_FREE ( info ) ;\n return ret ;\n }", "idx": 21326}
{"hash": -4552633429382740307, "project": "debian", "size": 14, "label": 0, "functionSource": "MPI # ifdef M_DEBUG mpi_debug_alloc ( unsigned nlimbs , const char * info ) # else mpi_alloc ( unsigned nlimbs ) # endif {\n MPI a ;\n if ( DBG_MEMORY ) log_debug ( \"mpi_alloc(%u)\\n\" , nlimbs * BITS_PER_MPI_LIMB ) ;\n # ifdef M_DEBUG a = m_debug_alloc ( sizeof * a , info ) ;\n a -> d = nlimbs ? mpi_debug_alloc_limb_space ( nlimbs , 0 , info ) : NULL ;\n # else a = xmalloc ( sizeof * a ) ;\n a -> d = nlimbs ? mpi_alloc_limb_space ( nlimbs , 0 ) : NULL ;\n # endif a -> alloced = nlimbs ;\n a -> nlimbs = 0 ;\n a -> sign = 0 ;\n a -> flags = 0 ;\n a -> nbits = 0 ;\n return a ;\n }", "idx": 21327}
{"hash": -4872400287267974771, "project": "debian", "size": 24, "label": 0, "functionSource": "static void reindex_one_database ( const char * name , const char * dbname , const char * type , const char * host , const char * port , const char * username , enum trivalue prompt_password , const char * progname , bool echo , bool verbose ) {\n PQExpBufferData sql ;\n PGconn * conn ;\n conn = connectDatabase ( dbname , host , port , username , prompt_password , progname , false , false ) ;\n initPQExpBuffer ( & sql ) ;\n appendPQExpBufferStr ( & sql , \"REINDEX\" ) ;\n if ( verbose ) appendPQExpBufferStr ( & sql , \" (VERBOSE)\" ) ;\n if ( strcmp ( type , \"TABLE\" ) == 0 ) appendPQExpBuffer ( & sql , \" TABLE %s\" , name ) ;\n else if ( strcmp ( type , \"INDEX\" ) == 0 ) appendPQExpBuffer ( & sql , \" INDEX %s\" , name ) ;\n else if ( strcmp ( type , \"SCHEMA\" ) == 0 ) appendPQExpBuffer ( & sql , \" SCHEMA %s\" , name ) ;\n else if ( strcmp ( type , \"DATABASE\" ) == 0 ) appendPQExpBuffer ( & sql , \" DATABASE %s\" , fmtId ( PQdb ( conn ) ) ) ;\n appendPQExpBufferChar ( & sql , ';\n' ) ;\n if ( ! executeMaintenanceCommand ( conn , sql . data , echo ) ) {\n if ( strcmp ( type , \"TABLE\" ) == 0 ) fprintf ( stderr , _ ( \"%s: reindexing of table \\\"%s\\\" in database \\\"%s\\\" failed: %s\" ) , progname , name , PQdb ( conn ) , PQerrorMessage ( conn ) ) ;\n if ( strcmp ( type , \"INDEX\" ) == 0 ) fprintf ( stderr , _ ( \"%s: reindexing of index \\\"%s\\\" in database \\\"%s\\\" failed: %s\" ) , progname , name , PQdb ( conn ) , PQerrorMessage ( conn ) ) ;\n if ( strcmp ( type , \"SCHEMA\" ) == 0 ) fprintf ( stderr , _ ( \"%s: reindexing of schema \\\"%s\\\" in database \\\"%s\\\" failed: %s\" ) , progname , name , PQdb ( conn ) , PQerrorMessage ( conn ) ) ;\n else fprintf ( stderr , _ ( \"%s: reindexing of database \\\"%s\\\" failed: %s\" ) , progname , PQdb ( conn ) , PQerrorMessage ( conn ) ) ;\n PQfinish ( conn ) ;\n exit ( 1 ) ;\n }\n PQfinish ( conn ) ;\n termPQExpBuffer ( & sql ) ;\n }", "idx": 21328}
{"hash": -7434014980763120366, "project": "debian", "size": 16, "label": 0, "functionSource": "static int dissect_ber ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , void * data _U_ ) {\n const char * name ;\n int offset ;\n col_set_str ( pinfo -> cinfo , COL_PROTOCOL , \"BER\" ) ;\n col_set_str ( pinfo -> cinfo , COL_DEF_SRC , \"BER encoded file\" ) ;\n if ( ! decode_as_syntax ) {\n col_set_str ( pinfo -> cinfo , COL_INFO , \"Unknown BER\" ) ;\n offset = dissect_unknown_ber ( pinfo , tvb , 0 , tree ) ;\n }\n else {\n offset = call_ber_syntax_callback ( decode_as_syntax , tvb , 0 , pinfo , tree ) ;\n name = get_ber_oid_syntax ( decode_as_syntax ) ;\n col_add_fstr ( pinfo -> cinfo , COL_INFO , \"Decoded as %s\" , name ? name : decode_as_syntax ) ;\n }\n return offset ;\n }", "idx": 21329}
{"hash": 1182028467273264883, "project": "debian", "size": 11, "label": 0, "functionSource": "void check_eol_junk_line ( const char * line ) {\n const char * p = line ;\n DBUG_ENTER ( \"check_eol_junk_line\" ) ;\n DBUG_PRINT ( \"enter\" , ( \"line: %s\" , line ) ) ;\n if ( * p && ! strncmp ( p , delimiter , delimiter_length ) ) die ( \"Extra delimiter \\\"%s\\\" found\" , delimiter ) ;\n if ( * p && * p != '#' ) {\n if ( * p == '\\n' ) die ( \"Missing delimiter\" ) ;\n die ( \"End of line junk detected: \\\"%s\\\"\" , p ) ;\n }\n DBUG_VOID_RETURN ;\n }", "idx": 21330}
{"hash": -560820000732125076, "project": "chrome", "size": 19, "label": 0, "functionSource": "static void exsltMathHighestFunction ( xmlXPathParserContextPtr ctxt , int nargs ) {\n xmlNodeSetPtr ns , ret ;\n void * user = NULL ;\n if ( nargs != 1 ) {\n xmlXPathSetArityError ( ctxt ) ;\n return ;\n }\n if ( ( ctxt -> value != NULL ) && ctxt -> value -> boolval != 0 ) {\n user = ctxt -> value -> user ;\n ctxt -> value -> boolval = 0 ;\n ctxt -> value -> user = NULL ;\n }\n ns = xmlXPathPopNodeSet ( ctxt ) ;\n if ( xmlXPathCheckError ( ctxt ) ) return ;\n ret = exsltMathHighest ( ns ) ;\n xmlXPathFreeNodeSet ( ns ) ;\n if ( user != NULL ) xmlFreeNodeList ( ( xmlNodePtr ) user ) ;\n xmlXPathReturnNodeSet ( ctxt , ret ) ;\n }", "idx": 21331}
{"hash": -7855974557509681261, "project": "debian", "size": 5, "label": 0, "functionSource": "Oid getTypeIOParam ( HeapTuple typeTuple ) {\n Form_pg_type typeStruct = ( Form_pg_type ) GETSTRUCT ( typeTuple ) ;\n if ( OidIsValid ( typeStruct -> typelem ) ) return typeStruct -> typelem ;\n else return HeapTupleGetOid ( typeTuple ) ;\n }", "idx": 21332}
{"hash": 7493853980473701704, "project": "debian", "size": 10, "label": 0, "functionSource": "static void gic_set_running_irq ( GICState * s , int cpu , int irq ) {\n s -> running_irq [ cpu ] = irq ;\n if ( irq == 1023 ) {\n s -> running_priority [ cpu ] = 0x100 ;\n }\n else {\n s -> running_priority [ cpu ] = GIC_GET_PRIORITY ( irq , cpu ) ;\n }\n gic_update ( s ) ;\n }", "idx": 21333}
{"hash": 2578089348587614328, "project": "debian", "size": 3, "label": 0, "functionSource": "EVP_PKEY * d2i_PrivateKey_bio ( BIO * bp , EVP_PKEY * * a ) {\n return ASN1_d2i_bio_of ( EVP_PKEY , EVP_PKEY_new , d2i_AutoPrivateKey , bp , a ) ;\n }", "idx": 21334}
{"hash": 643387607984457432, "project": "debian", "size": 17, "label": 0, "functionSource": "static void postfilter ( WMAVoiceContext * s , const float * synth , float * samples , int size , const float * lpcs , float * zero_exc_pf , int fcb_type , int pitch ) {\n float synth_filter_in_buf [ MAX_FRAMESIZE / 2 ] , * synth_pf = & s -> synth_filter_out_buf [ MAX_LSPS_ALIGN16 ] , * synth_filter_in = zero_exc_pf ;\n assert ( size <= MAX_FRAMESIZE / 2 ) ;\n ff_celp_lp_zero_synthesis_filterf ( zero_exc_pf , lpcs , synth , size , s -> lsps ) ;\n if ( fcb_type >= FCB_TYPE_AW_PULSES && ! kalman_smoothen ( s , pitch , zero_exc_pf , synth_filter_in_buf , size ) ) synth_filter_in = synth_filter_in_buf ;\n ff_celp_lp_synthesis_filterf ( synth_pf , lpcs , synth_filter_in , size , s -> lsps ) ;\n memcpy ( & synth_pf [ - s -> lsps ] , & synth_pf [ size - s -> lsps ] , sizeof ( synth_pf [ 0 ] ) * s -> lsps ) ;\n wiener_denoise ( s , fcb_type , synth_pf , size , lpcs ) ;\n adaptive_gain_control ( samples , synth_pf , synth , size , 0.99 , & s -> postfilter_agc ) ;\n if ( s -> dc_level > 8 ) {\n ff_acelp_apply_order_2_transfer_function ( samples , samples , ( const float [ 2 ] ) {\n - 1.99997 , 1.0 }\n , ( const float [ 2 ] ) {\n - 1.9330735188 , 0.93589198496 }\n , 0.93980580475 , s -> dcf_mem , size ) ;\n }\n }", "idx": 21335}
{"hash": 2820551931453396101, "project": "debian", "size": 18, "label": 0, "functionSource": "int jas_image_copycmpt ( jas_image_t * dstimage , int dstcmptno , jas_image_t * srcimage , int srccmptno ) {\n jas_image_cmpt_t * newcmpt ;\n if ( dstimage -> numcmpts_ >= dstimage -> maxcmpts_ ) {\n if ( jas_image_growcmpts ( dstimage , dstimage -> maxcmpts_ + 128 ) ) {\n return - 1 ;\n }\n }\n if ( ! ( newcmpt = jas_image_cmpt_copy ( srcimage -> cmpts_ [ srccmptno ] ) ) ) {\n return - 1 ;\n }\n if ( dstcmptno < dstimage -> numcmpts_ ) {\n memmove ( & dstimage -> cmpts_ [ dstcmptno + 1 ] , & dstimage -> cmpts_ [ dstcmptno ] , ( dstimage -> numcmpts_ - dstcmptno ) * sizeof ( jas_image_cmpt_t * ) ) ;\n }\n dstimage -> cmpts_ [ dstcmptno ] = newcmpt ;\n ++ dstimage -> numcmpts_ ;\n jas_image_setbbox ( dstimage ) ;\n return 0 ;\n }", "idx": 21336}
{"hash": -1445906809722253218, "project": "chrome", "size": 9, "label": 0, "functionSource": "TEST_F ( FullscreenControllerStateUnitTest , ExitFullscreenViaBrowserWindow ) {\n AddTab ( browser ( ) , GURL ( url : : kAboutBlankURL ) ) ;\n ASSERT_TRUE ( InvokeEvent ( TOGGLE_FULLSCREEN ) ) ;\n ASSERT_TRUE ( InvokeEvent ( WINDOW_CHANGE ) ) ;\n ASSERT_TRUE ( browser ( ) -> window ( ) -> IsFullscreen ( ) ) ;\n browser ( ) -> window ( ) -> ExitFullscreen ( ) ;\n ChangeWindowFullscreenState ( ) ;\n EXPECT_EQ ( EXCLUSIVE_ACCESS_BUBBLE_TYPE_NONE , browser ( ) -> fullscreen_controller ( ) -> GetExclusiveAccessBubbleType ( ) ) ;\n }", "idx": 21337}
{"hash": -5241093592682744127, "project": "debian", "size": 55, "label": 0, "functionSource": "static Selectivity mcelem_array_contain_overlap_selec ( Datum * mcelem , int nmcelem , float4 * numbers , int nnumbers , Datum * array_data , int nitems , Oid operator , FmgrInfo * cmpfunc ) {\n Selectivity selec , elem_selec ;\n int mcelem_index , i ;\n bool use_bsearch ;\n float4 minfreq ;\n if ( nnumbers != nmcelem + 3 ) {\n numbers = NULL ;\n nnumbers = 0 ;\n }\n if ( numbers ) {\n minfreq = numbers [ nmcelem ] ;\n }\n else {\n minfreq = 2 * ( float4 ) DEFAULT_CONTAIN_SEL ;\n }\n if ( nitems * floor_log2 ( ( uint32 ) nmcelem ) < nmcelem + nitems ) use_bsearch = true ;\n else use_bsearch = false ;\n if ( operator == OID_ARRAY_CONTAINS_OP ) {\n selec = 1.0 ;\n }\n else {\n selec = 0.0 ;\n }\n mcelem_index = 0 ;\n for ( i = 0 ;\n i < nitems ;\n i ++ ) {\n bool match = false ;\n if ( i > 0 && element_compare ( & array_data [ i - 1 ] , & array_data [ i ] , cmpfunc ) == 0 ) continue ;\n if ( use_bsearch ) {\n match = find_next_mcelem ( mcelem , nmcelem , array_data [ i ] , & mcelem_index , cmpfunc ) ;\n }\n else {\n while ( mcelem_index < nmcelem ) {\n int cmp = element_compare ( & mcelem [ mcelem_index ] , & array_data [ i ] , cmpfunc ) ;\n if ( cmp < 0 ) mcelem_index ++ ;\n else {\n if ( cmp == 0 ) match = true ;\n break ;\n }\n }\n }\n if ( match && numbers ) {\n elem_selec = numbers [ mcelem_index ] ;\n mcelem_index ++ ;\n }\n else {\n elem_selec = Min ( DEFAULT_CONTAIN_SEL , minfreq / 2 ) ;\n }\n if ( operator == OID_ARRAY_CONTAINS_OP ) selec *= elem_selec ;\n else selec = selec + elem_selec - selec * elem_selec ;\n CLAMP_PROBABILITY ( selec ) ;\n }\n return selec ;\n }", "idx": 21338}
{"hash": -4370220620850259177, "project": "debian", "size": 9, "label": 0, "functionSource": "static void convolute_with_sparse ( float * out , const AMRFixed * pulses , const float * shape , int length ) {\n int i , j ;\n memset ( out , 0 , length * sizeof ( float ) ) ;\n for ( i = 0 ;\n i < pulses -> n ;\n i ++ ) for ( j = pulses -> x [ i ] ;\n j < length ;\n j ++ ) out [ j ] += pulses -> y [ i ] * shape [ j - pulses -> x [ i ] ] ;\n }", "idx": 21339}
{"hash": -5249292504513104172, "project": "debian", "size": 5, "label": 0, "functionSource": "int xmlrpc_unregister_method ( const char * method ) {\n return_val_if_fail ( method != NULL , XMLRPC_ERR_PARAMS ) ;\n mowgli_patricia_delete ( XMLRPCCMD , method ) ;\n return XMLRPC_ERR_OK ;\n }", "idx": 21340}
{"hash": 4489017523191997023, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h225_OBJECT_IDENTIFIER ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_object_identifier ( tvb , offset , actx , tree , hf_index , NULL ) ;\n return offset ;\n }", "idx": 21341}
{"hash": 9046191708840218774, "project": "debian", "size": 13, "label": 0, "functionSource": "static __inline__ int TLV_SET ( void * tlv , __u16 type , void * data , __u16 len ) {\n struct tlv_desc * tlv_ptr ;\n int tlv_len ;\n tlv_len = TLV_LENGTH ( len ) ;\n tlv_ptr = ( struct tlv_desc * ) tlv ;\n tlv_ptr -> tlv_type = htons ( type ) ;\n tlv_ptr -> tlv_len = htons ( tlv_len ) ;\n if ( len && data ) {\n memcpy ( TLV_DATA ( tlv_ptr ) , data , len ) ;\n memset ( TLV_DATA ( tlv_ptr ) + len , 0 , TLV_SPACE ( len ) - tlv_len ) ;\n }\n return TLV_SPACE ( len ) ;\n }", "idx": 21342}
{"hash": 4180964683905830761, "project": "debian", "size": 9, "label": 0, "functionSource": "static u32 ptrace_parent_sid ( struct task_struct * task ) {\n u32 sid = 0 ;\n struct task_struct * tracer ;\n rcu_read_lock ( ) ;\n tracer = ptrace_parent ( task ) ;\n if ( tracer ) sid = task_sid ( tracer ) ;\n rcu_read_unlock ( ) ;\n return sid ;\n }", "idx": 21343}
{"hash": 1208165234047591297, "project": "debian", "size": 5, "label": 0, "functionSource": "proto_item * parseUInt16 ( proto_tree * tree , tvbuff_t * tvb , packet_info * pinfo _U_ , gint * pOffset , int hfIndex ) {\n proto_item * item = proto_tree_add_item ( tree , hfIndex , tvb , * pOffset , 2 , ENC_LITTLE_ENDIAN ) ;\n * pOffset += 2 ;\n return item ;\n }", "idx": 21344}
{"hash": 6632536031698733342, "project": "debian", "size": 5, "label": 0, "functionSource": "static int opt_show_ ## section ( const char * opt , const char * arg ) {\n mark_section_show_entries ( SECTION_ID_ ## target_section_id , 1 , NULL ) ;\n return 0 ;\n }\n DEFINE_OPT_SHOW_SECTION ( chapters , CHAPTERS ) DEFINE_OPT_SHOW_SECTION ( error , ERROR ) DEFINE_OPT_SHOW_SECTION ( format , FORMAT ) DEFINE_OPT_SHOW_SECTION ( frames , FRAMES )", "idx": 21345}
{"hash": -7855974557509681261, "project": "debian", "size": 3, "label": 0, "functionSource": "bool type_is_collatable ( Oid typid ) {\n return OidIsValid ( get_typcollation ( typid ) ) ;\n }", "idx": 21346}
{"hash": 1366214969540455677, "project": "debian", "size": 97, "label": 1, "functionSource": "int i2d_ ## name ( type * a , unsigned char * * out ) ;\n DECLARE_ASN1_ITEM ( itname ) # define DECLARE_ASN1_ENCODE_FUNCTIONS_const ( type , name ) type * d2i_ ## name ( type * * a , const unsigned char * * in , long len ) ;\n int i2d_ ## name ( const type * a , unsigned char * * out ) ;\n DECLARE_ASN1_ITEM ( name ) # define DECLARE_ASN1_NDEF_FUNCTION ( name ) int i2d_ ## name ## _NDEF ( name * a , unsigned char * * out ) ;\n # define DECLARE_ASN1_FUNCTIONS_const ( name ) DECLARE_ASN1_ALLOC_FUNCTIONS ( name ) DECLARE_ASN1_ENCODE_FUNCTIONS_const ( name , name ) # define DECLARE_ASN1_ALLOC_FUNCTIONS_name ( type , name ) type * name ## _new ( void ) ;\n void name ## _free ( type * a ) ;\n # define DECLARE_ASN1_PRINT_FUNCTION ( stname ) DECLARE_ASN1_PRINT_FUNCTION_fname ( stname , stname ) # define DECLARE_ASN1_PRINT_FUNCTION_fname ( stname , fname ) int fname ## _print_ctx ( BIO * out , stname * x , int indent , const ASN1_PCTX * pctx ) ;\n # define D2I_OF ( type ) type * ( * ) ( type * * , const unsigned char * * , long ) # define I2D_OF ( type ) int ( * ) ( type * , unsigned char * * ) # define I2D_OF_const ( type ) int ( * ) ( const type * , unsigned char * * ) # define CHECKED_D2I_OF ( type , d2i ) ( ( d2i_of_void * ) ( 1 ? d2i : ( ( D2I_OF ( type ) ) 0 ) ) ) # define CHECKED_I2D_OF ( type , i2d ) ( ( i2d_of_void * ) ( 1 ? i2d : ( ( I2D_OF ( type ) ) 0 ) ) ) # define CHECKED_NEW_OF ( type , xnew ) ( ( void * ( * ) ( void ) ) ( 1 ? xnew : ( ( type * ( * ) ( void ) ) 0 ) ) ) # define CHECKED_PTR_OF ( type , p ) ( ( void * ) ( 1 ? p : ( type * ) 0 ) ) # define CHECKED_PPTR_OF ( type , p ) ( ( void * * ) ( 1 ? p : ( type * * ) 0 ) ) # define TYPEDEF_D2I_OF ( type ) typedef type * d2i_of_ ## type ( type * * , const unsigned char * * , long ) # define TYPEDEF_I2D_OF ( type ) typedef int i2d_of_ ## type ( type * , unsigned char * * ) # define TYPEDEF_D2I2D_OF ( type ) TYPEDEF_D2I_OF ( type ) ;\n TYPEDEF_I2D_OF ( type ) TYPEDEF_D2I2D_OF ( void ) ;\n # ifndef OPENSSL_EXPORT_VAR_AS_FUNCTION typedef const ASN1_ITEM ASN1_ITEM_EXP ;\n # define ASN1_ITEM_ptr ( iptr ) ( iptr ) # define ASN1_ITEM_ref ( iptr ) ( & ( iptr ## _it ) ) # define ASN1_ITEM_rptr ( ref ) ( & ( ref ## _it ) ) # define DECLARE_ASN1_ITEM ( name ) OPENSSL_EXTERN const ASN1_ITEM name ## _it ;\n # else typedef const ASN1_ITEM * ASN1_ITEM_EXP ( void ) ;\n # define ASN1_ITEM_ptr ( iptr ) ( iptr ( ) ) # define ASN1_ITEM_ref ( iptr ) ( iptr ## _it ) # define ASN1_ITEM_rptr ( ref ) ( ref ## _it ( ) ) # define DECLARE_ASN1_ITEM ( name ) const ASN1_ITEM * name ## _it ( void ) ;\n # endif # define ASN1_STRFLGS_ESC_2253 1 # define ASN1_STRFLGS_ESC_CTRL 2 # define ASN1_STRFLGS_ESC_MSB 4 # define ASN1_STRFLGS_ESC_QUOTE 8 # define CHARTYPE_PRINTABLESTRING 0x10 # define CHARTYPE_FIRST_ESC_2253 0x20 # define CHARTYPE_LAST_ESC_2253 0x40 # define ASN1_STRFLGS_UTF8_CONVERT 0x10 # define ASN1_STRFLGS_IGNORE_TYPE 0x20 # define ASN1_STRFLGS_SHOW_TYPE 0x40 # define ASN1_STRFLGS_DUMP_ALL 0x80 # define ASN1_STRFLGS_DUMP_UNKNOWN 0x100 # define ASN1_STRFLGS_DUMP_DER 0x200 # define ASN1_STRFLGS_ESC_2254 0x400 # define ASN1_STRFLGS_RFC2253 ( ASN1_STRFLGS_ESC_2253 | ASN1_STRFLGS_ESC_CTRL | ASN1_STRFLGS_ESC_MSB | ASN1_STRFLGS_UTF8_CONVERT | ASN1_STRFLGS_DUMP_UNKNOWN | ASN1_STRFLGS_DUMP_DER ) DEFINE_STACK_OF ( ASN1_INTEGER ) DEFINE_STACK_OF ( ASN1_GENERALSTRING ) DEFINE_STACK_OF ( ASN1_UTF8STRING ) typedef struct asn1_type_st {\n int type ;\n union {\n char * ptr ;\n ASN1_BOOLEAN boolean ;\n ASN1_STRING * asn1_string ;\n ASN1_OBJECT * object ;\n ASN1_INTEGER * integer ;\n ASN1_ENUMERATED * enumerated ;\n ASN1_BIT_STRING * bit_string ;\n ASN1_OCTET_STRING * octet_string ;\n ASN1_PRINTABLESTRING * printablestring ;\n ASN1_T61STRING * t61string ;\n ASN1_IA5STRING * ia5string ;\n ASN1_GENERALSTRING * generalstring ;\n ASN1_BMPSTRING * bmpstring ;\n ASN1_UNIVERSALSTRING * universalstring ;\n ASN1_UTCTIME * utctime ;\n ASN1_GENERALIZEDTIME * generalizedtime ;\n ASN1_VISIBLESTRING * visiblestring ;\n ASN1_UTF8STRING * utf8string ;\n ASN1_STRING * set ;\n ASN1_STRING * sequence ;\n ASN1_VALUE * asn1_value ;\n }\n value ;\n }\n ASN1_TYPE ;\n DEFINE_STACK_OF ( ASN1_TYPE ) typedef STACK_OF ( ASN1_TYPE ) ASN1_SEQUENCE_ANY ;\n DECLARE_ASN1_ENCODE_FUNCTIONS_const ( ASN1_SEQUENCE_ANY , ASN1_SEQUENCE_ANY ) DECLARE_ASN1_ENCODE_FUNCTIONS_const ( ASN1_SEQUENCE_ANY , ASN1_SET_ANY ) typedef struct BIT_STRING_BITNAME_st {\n int bitnum ;\n const char * lname ;\n const char * sname ;\n }\n BIT_STRING_BITNAME ;\n # define B_ASN1_TIME B_ASN1_UTCTIME | B_ASN1_GENERALIZEDTIME # define B_ASN1_PRINTABLE B_ASN1_NUMERICSTRING | B_ASN1_PRINTABLESTRING | B_ASN1_T61STRING | B_ASN1_IA5STRING | B_ASN1_BIT_STRING | B_ASN1_UNIVERSALSTRING | B_ASN1_BMPSTRING | B_ASN1_UTF8STRING | B_ASN1_SEQUENCE | B_ASN1_UNKNOWN # define B_ASN1_DIRECTORYSTRING B_ASN1_PRINTABLESTRING | B_ASN1_TELETEXSTRING | B_ASN1_BMPSTRING | B_ASN1_UNIVERSALSTRING | B_ASN1_UTF8STRING # define B_ASN1_DISPLAYTEXT B_ASN1_IA5STRING | B_ASN1_VISIBLESTRING | B_ASN1_BMPSTRING | B_ASN1_UTF8STRING DECLARE_ASN1_FUNCTIONS_fname ( ASN1_TYPE , ASN1_ANY , ASN1_TYPE ) int ASN1_TYPE_get ( const ASN1_TYPE * a ) ;\n void ASN1_TYPE_set ( ASN1_TYPE * a , int type , void * value ) ;\n int ASN1_TYPE_set1 ( ASN1_TYPE * a , int type , const void * value ) ;\n int ASN1_TYPE_cmp ( const ASN1_TYPE * a , const ASN1_TYPE * b ) ;\n ASN1_TYPE * ASN1_TYPE_pack_sequence ( const ASN1_ITEM * it , void * s , ASN1_TYPE * * t ) ;\n void * ASN1_TYPE_unpack_sequence ( const ASN1_ITEM * it , const ASN1_TYPE * t ) ;\n ASN1_OBJECT * ASN1_OBJECT_new ( void ) ;\n void ASN1_OBJECT_free ( ASN1_OBJECT * a ) ;\n int i2d_ASN1_OBJECT ( const ASN1_OBJECT * a , unsigned char * * pp ) ;\n ASN1_OBJECT * d2i_ASN1_OBJECT ( ASN1_OBJECT * * a , const unsigned char * * pp , long length ) ;\n DECLARE_ASN1_ITEM ( ASN1_OBJECT ) DEFINE_STACK_OF ( ASN1_OBJECT ) ASN1_STRING * ASN1_STRING_new ( void ) ;\n void ASN1_STRING_free ( ASN1_STRING * a ) ;\n void ASN1_STRING_clear_free ( ASN1_STRING * a ) ;\n int ASN1_STRING_copy ( ASN1_STRING * dst , const ASN1_STRING * str ) ;\n ASN1_STRING * ASN1_STRING_dup ( const ASN1_STRING * a ) ;\n ASN1_STRING * ASN1_STRING_type_new ( int type ) ;\n int ASN1_STRING_cmp ( const ASN1_STRING * a , const ASN1_STRING * b ) ;\n int ASN1_STRING_set ( ASN1_STRING * str , const void * data , int len ) ;\n void ASN1_STRING_set0 ( ASN1_STRING * str , void * data , int len ) ;\n int ASN1_STRING_length ( const ASN1_STRING * x ) ;\n void ASN1_STRING_length_set ( ASN1_STRING * x , int n ) ;\n int ASN1_STRING_type ( const ASN1_STRING * x ) ;\n DEPRECATEDIN_1_1_0 ( unsigned char * ASN1_STRING_data ( ASN1_STRING * x ) ) const unsigned char * ASN1_STRING_get0_data ( const ASN1_STRING * x ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_BIT_STRING ) int ASN1_BIT_STRING_set ( ASN1_BIT_STRING * a , unsigned char * d , int length ) ;\n int ASN1_BIT_STRING_set_bit ( ASN1_BIT_STRING * a , int n , int value ) ;\n int ASN1_BIT_STRING_get_bit ( const ASN1_BIT_STRING * a , int n ) ;\n int ASN1_BIT_STRING_check ( const ASN1_BIT_STRING * a , const unsigned char * flags , int flags_len ) ;\n int ASN1_BIT_STRING_name_print ( BIO * out , ASN1_BIT_STRING * bs , BIT_STRING_BITNAME * tbl , int indent ) ;\n int ASN1_BIT_STRING_num_asc ( const char * name , BIT_STRING_BITNAME * tbl ) ;\n int ASN1_BIT_STRING_set_asc ( ASN1_BIT_STRING * bs , const char * name , int value , BIT_STRING_BITNAME * tbl ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_INTEGER ) ASN1_INTEGER * d2i_ASN1_UINTEGER ( ASN1_INTEGER * * a , const unsigned char * * pp , long length ) ;\n ASN1_INTEGER * ASN1_INTEGER_dup ( const ASN1_INTEGER * x ) ;\n int ASN1_INTEGER_cmp ( const ASN1_INTEGER * x , const ASN1_INTEGER * y ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_ENUMERATED ) int ASN1_UTCTIME_check ( const ASN1_UTCTIME * a ) ;\n ASN1_UTCTIME * ASN1_UTCTIME_set ( ASN1_UTCTIME * s , time_t t ) ;\n ASN1_UTCTIME * ASN1_UTCTIME_adj ( ASN1_UTCTIME * s , time_t t , int offset_day , long offset_sec ) ;\n int ASN1_UTCTIME_set_string ( ASN1_UTCTIME * s , const char * str ) ;\n int ASN1_UTCTIME_cmp_time_t ( const ASN1_UTCTIME * s , time_t t ) ;\n int ASN1_GENERALIZEDTIME_check ( const ASN1_GENERALIZEDTIME * a ) ;\n ASN1_GENERALIZEDTIME * ASN1_GENERALIZEDTIME_set ( ASN1_GENERALIZEDTIME * s , time_t t ) ;\n ASN1_GENERALIZEDTIME * ASN1_GENERALIZEDTIME_adj ( ASN1_GENERALIZEDTIME * s , time_t t , int offset_day , long offset_sec ) ;\n int ASN1_GENERALIZEDTIME_set_string ( ASN1_GENERALIZEDTIME * s , const char * str ) ;\n int ASN1_TIME_diff ( int * pday , int * psec , const ASN1_TIME * from , const ASN1_TIME * to ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_OCTET_STRING ) ASN1_OCTET_STRING * ASN1_OCTET_STRING_dup ( const ASN1_OCTET_STRING * a ) ;\n int ASN1_OCTET_STRING_cmp ( const ASN1_OCTET_STRING * a , const ASN1_OCTET_STRING * b ) ;\n int ASN1_OCTET_STRING_set ( ASN1_OCTET_STRING * str , const unsigned char * data , int len ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_VISIBLESTRING ) DECLARE_ASN1_FUNCTIONS ( ASN1_UNIVERSALSTRING ) DECLARE_ASN1_FUNCTIONS ( ASN1_UTF8STRING ) DECLARE_ASN1_FUNCTIONS ( ASN1_NULL ) DECLARE_ASN1_FUNCTIONS ( ASN1_BMPSTRING ) int UTF8_getc ( const unsigned char * str , int len , unsigned long * val ) ;\n int UTF8_putc ( unsigned char * str , int len , unsigned long value ) ;\n DECLARE_ASN1_FUNCTIONS_name ( ASN1_STRING , ASN1_PRINTABLE ) DECLARE_ASN1_FUNCTIONS_name ( ASN1_STRING , DIRECTORYSTRING ) DECLARE_ASN1_FUNCTIONS_name ( ASN1_STRING , DISPLAYTEXT ) DECLARE_ASN1_FUNCTIONS ( ASN1_PRINTABLESTRING ) DECLARE_ASN1_FUNCTIONS ( ASN1_T61STRING )", "idx": 21347}
{"hash": -6527276140940489090, "project": "chrome", "size": 43, "label": 0, "functionSource": "TEST_F ( TransportSecurityPersisterTest , SerializeData3 ) {\n net : : HashValue fp1 ( net : : HASH_VALUE_SHA1 ) ;\n memset ( fp1 . data ( ) , 0 , fp1 . size ( ) ) ;\n net : : HashValue fp2 ( net : : HASH_VALUE_SHA1 ) ;\n memset ( fp2 . data ( ) , 1 , fp2 . size ( ) ) ;\n base : : Time expiry = base : : Time : : Now ( ) + base : : TimeDelta : : FromSeconds ( 1000 ) ;\n net : : HashValueVector dynamic_spki_hashes ;\n dynamic_spki_hashes . push_back ( fp1 ) ;\n dynamic_spki_hashes . push_back ( fp2 ) ;\n bool include_subdomains = false ;\n state_ . AddHSTS ( \"www.example.com\" , expiry , include_subdomains ) ;\n state_ . AddHPKP ( \"www.example.com\" , expiry , include_subdomains , dynamic_spki_hashes ) ;\n memset ( fp1 . data ( ) , 2 , fp1 . size ( ) ) ;\n memset ( fp2 . data ( ) , 3 , fp2 . size ( ) ) ;\n expiry = base : : Time : : Now ( ) + base : : TimeDelta : : FromSeconds ( 3000 ) ;\n dynamic_spki_hashes . push_back ( fp1 ) ;\n dynamic_spki_hashes . push_back ( fp2 ) ;\n state_ . AddHSTS ( \"www.example.net\" , expiry , include_subdomains ) ;\n state_ . AddHPKP ( \"www.example.net\" , expiry , include_subdomains , dynamic_spki_hashes ) ;\n std : : map < std : : string , TransportSecurityState : : DomainState > saved ;\n TransportSecurityState : : Iterator i ( state_ ) ;\n while ( i . HasNext ( ) ) {\n saved [ i . hostname ( ) ] = i . domain_state ( ) ;\n i . Advance ( ) ;\n }\n std : : string serialized ;\n EXPECT_TRUE ( persister_ -> SerializeData ( & serialized ) ) ;\n base : : FilePath path = temp_dir_ . path ( ) . AppendASCII ( \"TransportSecurityPersisterTest\" ) ;\n EXPECT_TRUE ( base : : WriteFile ( path , serialized . c_str ( ) , serialized . size ( ) ) ) ;\n std : : string persisted ;\n EXPECT_TRUE ( base : : ReadFileToString ( path , & persisted ) ) ;\n EXPECT_EQ ( persisted , serialized ) ;\n bool dirty ;\n EXPECT_TRUE ( persister_ -> LoadEntries ( persisted , & dirty ) ) ;\n EXPECT_FALSE ( dirty ) ;\n size_t count = 0 ;\n TransportSecurityState : : Iterator j ( state_ ) ;\n while ( j . HasNext ( ) ) {\n count ++ ;\n j . Advance ( ) ;\n }\n EXPECT_EQ ( count , saved . size ( ) ) ;\n }", "idx": 21348}
{"hash": 7749168290238234888, "project": "debian", "size": 14, "label": 0, "functionSource": "static int do_cmd ( xd3_stream * stream , const char * buf ) {\n int ret ;\n if ( ( ret = system ( buf ) ) != 0 ) {\n if ( WIFEXITED ( ret ) ) {\n stream -> msg = \"command exited non-zero\" ;\n IF_DEBUG1 ( XPR ( NT \"command was: %s\\n\" , buf ) ) ;\n }\n else {\n stream -> msg = \"abnormal command termination\" ;\n }\n return ret ;\n }\n return 0 ;\n }", "idx": 21349}
{"hash": -6468986929796051453, "project": "debian", "size": 3, "label": 0, "functionSource": "void _TIFFfree ( tdata_t p ) {\n free ( p ) ;\n }", "idx": 21350}
{"hash": 8193534372312945122, "project": "debian", "size": 10, "label": 0, "functionSource": "static inline int padr_match ( PCNetState * s , const uint8_t * buf , int size ) {\n struct qemu_ether_header * hdr = ( void * ) buf ;\n uint8_t padr [ 6 ] = {\n s -> csr [ 12 ] & 0xff , s -> csr [ 12 ] >> 8 , s -> csr [ 13 ] & 0xff , s -> csr [ 13 ] >> 8 , s -> csr [ 14 ] & 0xff , s -> csr [ 14 ] >> 8 }\n ;\n int result = ( ! CSR_DRCVPA ( s ) ) && ! memcmp ( hdr -> ether_dhost , padr , 6 ) ;\n # ifdef PCNET_DEBUG_MATCH printf ( \"packet dhost=%02x:%02x:%02x:%02x:%02x:%02x, \" \"padr=%02x:%02x:%02x:%02x:%02x:%02x\\n\" , hdr -> ether_dhost [ 0 ] , hdr -> ether_dhost [ 1 ] , hdr -> ether_dhost [ 2 ] , hdr -> ether_dhost [ 3 ] , hdr -> ether_dhost [ 4 ] , hdr -> ether_dhost [ 5 ] , padr [ 0 ] , padr [ 1 ] , padr [ 2 ] , padr [ 3 ] , padr [ 4 ] , padr [ 5 ] ) ;\n printf ( \"padr_match result=%d\\n\" , result ) ;\n # endif return result ;\n }", "idx": 21351}
{"hash": 2713698759296604855, "project": "debian", "size": 3, "label": 0, "functionSource": "void ff_MPV_report_decode_progress ( MpegEncContext * s ) {\n if ( s -> pict_type != AV_PICTURE_TYPE_B && ! s -> partitioned_frame && ! s -> er . error_occurred ) ff_thread_report_progress ( & s -> current_picture_ptr -> tf , s -> mb_y , 0 ) ;\n }", "idx": 21352}
{"hash": -8933711118846965366, "project": "debian", "size": 7, "label": 0, "functionSource": "static uint64_t cirrus_linear_bitblt_read ( void * opaque , hwaddr addr , unsigned size ) {\n CirrusVGAState * s = opaque ;\n uint32_t ret ;\n ( void ) s ;\n ret = 0xff ;\n return ret ;\n }", "idx": 21353}
{"hash": -1929262071302712016, "project": "debian", "size": 13, "label": 0, "functionSource": "static void * Type_CrdInfo_Read ( struct _cms_typehandler_struct * self , cmsIOHANDLER * io , cmsUInt32Number * nItems , cmsUInt32Number SizeOfTag ) {\n cmsMLU * mlu = cmsMLUalloc ( self -> ContextID , 5 ) ;\n * nItems = 0 ;\n if ( ! ReadCountAndSting ( self , io , mlu , & SizeOfTag , \"nm\" ) ) goto Error ;\n if ( ! ReadCountAndSting ( self , io , mlu , & SizeOfTag , \"#0\" ) ) goto Error ;\n if ( ! ReadCountAndSting ( self , io , mlu , & SizeOfTag , \"#1\" ) ) goto Error ;\n if ( ! ReadCountAndSting ( self , io , mlu , & SizeOfTag , \"#2\" ) ) goto Error ;\n if ( ! ReadCountAndSting ( self , io , mlu , & SizeOfTag , \"#3\" ) ) goto Error ;\n * nItems = 1 ;\n return ( void * ) mlu ;\n Error : cmsMLUfree ( mlu ) ;\n return NULL ;\n }", "idx": 21354}
{"hash": -8933711118846965366, "project": "debian", "size": 8, "label": 0, "functionSource": "static void unmap_linear_vram ( CirrusVGAState * s ) {\n if ( s -> bustype == CIRRUS_BUSTYPE_PCI && s -> linear_vram ) {\n s -> linear_vram = false ;\n memory_region_del_subregion ( & s -> pci_bar , & s -> vga . vram ) ;\n }\n memory_region_set_enabled ( & s -> cirrus_bank [ 0 ] , false ) ;\n memory_region_set_enabled ( & s -> cirrus_bank [ 1 ] , false ) ;\n }", "idx": 21355}
{"hash": 4715922168896528064, "project": "debian", "size": 101, "label": 0, "functionSource": "void jpc_ft_fwdlift_colgrp ( jpc_fix_t * a , int numrows , int stride , int parity ) {\n jpc_fix_t * lptr ;\n jpc_fix_t * hptr ;\n register jpc_fix_t * lptr2 ;\n register jpc_fix_t * hptr2 ;\n register int n ;\n register int i ;\n int llen ;\n llen = ( numrows + 1 - parity ) >> 1 ;\n if ( numrows > 1 ) {\n lptr = & a [ 0 ] ;\n hptr = & a [ llen * stride ] ;\n if ( parity ) {\n lptr2 = lptr ;\n hptr2 = hptr ;\n for ( i = 0 ;\n i < JPC_QMFB_COLGRPSIZE ;\n ++ i ) {\n hptr2 [ 0 ] -= lptr2 [ 0 ] ;\n ++ hptr2 ;\n ++ lptr2 ;\n }\n hptr += stride ;\n }\n n = numrows - llen - parity - ( parity == ( numrows & 1 ) ) ;\n while ( n -- > 0 ) {\n lptr2 = lptr ;\n hptr2 = hptr ;\n for ( i = 0 ;\n i < JPC_QMFB_COLGRPSIZE ;\n ++ i ) {\n hptr2 [ 0 ] -= jpc_fix_asr ( lptr2 [ 0 ] + lptr2 [ stride ] , 1 ) ;\n ++ lptr2 ;\n ++ hptr2 ;\n }\n hptr += stride ;\n lptr += stride ;\n }\n if ( parity == ( numrows & 1 ) ) {\n lptr2 = lptr ;\n hptr2 = hptr ;\n for ( i = 0 ;\n i < JPC_QMFB_COLGRPSIZE ;\n ++ i ) {\n hptr2 [ 0 ] -= lptr2 [ 0 ] ;\n ++ lptr2 ;\n ++ hptr2 ;\n }\n }\n lptr = & a [ 0 ] ;\n hptr = & a [ llen * stride ] ;\n if ( ! parity ) {\n lptr2 = lptr ;\n hptr2 = hptr ;\n for ( i = 0 ;\n i < JPC_QMFB_COLGRPSIZE ;\n ++ i ) {\n lptr2 [ 0 ] += jpc_fix_asr ( hptr2 [ 0 ] + 1 , 1 ) ;\n ++ lptr2 ;\n ++ hptr2 ;\n }\n lptr += stride ;\n }\n n = llen - ( ! parity ) - ( parity != ( numrows & 1 ) ) ;\n while ( n -- > 0 ) {\n lptr2 = lptr ;\n hptr2 = hptr ;\n for ( i = 0 ;\n i < JPC_QMFB_COLGRPSIZE ;\n ++ i ) {\n lptr2 [ 0 ] += jpc_fix_asr ( hptr2 [ 0 ] + hptr2 [ stride ] + 2 , 2 ) ;\n ++ lptr2 ;\n ++ hptr2 ;\n }\n lptr += stride ;\n hptr += stride ;\n }\n if ( parity != ( numrows & 1 ) ) {\n lptr2 = lptr ;\n hptr2 = hptr ;\n for ( i = 0 ;\n i < JPC_QMFB_COLGRPSIZE ;\n ++ i ) {\n lptr2 [ 0 ] += jpc_fix_asr ( hptr2 [ 0 ] + 1 , 1 ) ;\n ++ lptr2 ;\n ++ hptr2 ;\n }\n }\n }\n else {\n if ( parity ) {\n lptr2 = & a [ 0 ] ;\n for ( i = 0 ;\n i < JPC_QMFB_COLGRPSIZE ;\n ++ i ) {\n lptr2 [ 0 ] = jpc_fix_asl ( lptr2 [ 0 ] , 1 ) ;\n ++ lptr2 ;\n }\n }\n }\n }", "idx": 21356}
{"hash": 1859256631654516868, "project": "chrome", "size": 10, "label": 0, "functionSource": "int ff_h264_get_slice_type ( const H264Context * h ) {\n switch ( h -> slice_type ) {\n case AV_PICTURE_TYPE_P : return 0 ;\n case AV_PICTURE_TYPE_B : return 1 ;\n case AV_PICTURE_TYPE_I : return 2 ;\n case AV_PICTURE_TYPE_SP : return 3 ;\n case AV_PICTURE_TYPE_SI : return 4 ;\n default : return AVERROR_INVALIDDATA ;\n }\n }", "idx": 21357}
{"hash": -341028540041678099, "project": "debian", "size": 19, "label": 0, "functionSource": "static int decodearr ( char * str , int * narr , l_fp * lfparr ) {\n register char * cp , * bp ;\n register l_fp * lfp ;\n char buf [ 60 ] ;\n lfp = lfparr ;\n cp = str ;\n * narr = 0 ;\n while ( * narr < 8 ) {\n while ( isspace ( ( int ) * cp ) ) cp ++ ;\n if ( * cp == '\\0' ) break ;\n bp = buf ;\n while ( ! isspace ( ( int ) * cp ) && * cp != '\\0' ) * bp ++ = * cp ++ ;\n * bp ++ = '\\0' ;\n if ( ! decodetime ( buf , lfp ) ) return 0 ;\n ( * narr ) ++ ;\n lfp ++ ;\n }\n return 1 ;\n }", "idx": 21358}
{"hash": -4886619136962902359, "project": "chrome", "size": 12, "label": 1, "functionSource": "TEST_F ( NativeBackendLibsecretTest , SomeKeyringAttributesAreMissing ) {\n NativeBackendLibsecret backend ( 42 ) ;\n VerifiedAdd ( & backend , form_google_ ) ;\n EXPECT_EQ ( 1u , global_mock_libsecret_items -> size ( ) ) ;\n ( * global_mock_libsecret_items ) [ 0 ] -> RemoveAttribute ( \"avatar_url\" ) ;\n ( * global_mock_libsecret_items ) [ 0 ] -> RemoveAttribute ( \"ssl_valid\" ) ;\n ScopedVector < autofill : : PasswordForm > form_list ;\n EXPECT_TRUE ( backend . GetAutofillableLogins ( & form_list ) ) ;\n EXPECT_EQ ( 1u , form_list . size ( ) ) ;\n EXPECT_EQ ( GURL ( \"\" ) , form_list [ 0 ] -> icon_url ) ;\n EXPECT_FALSE ( form_list [ 0 ] -> ssl_valid ) ;\n }", "idx": 21359}
{"hash": 7039307292471244756, "project": "debian", "size": 11, "label": 0, "functionSource": "static void dtap_mm_tmsi_realloc_cmd ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len ) {\n guint32 curr_offset ;\n guint32 consumed ;\n guint curr_len ;\n curr_offset = offset ;\n curr_len = len ;\n is_uplink = IS_UPLINK_FALSE ;\n ELEM_MAND_V ( GSM_A_PDU_TYPE_COMMON , DE_LAI , NULL ) ;\n ELEM_MAND_LV ( GSM_A_PDU_TYPE_COMMON , DE_MID , NULL ) ;\n EXTRANEOUS_DATA_CHECK ( curr_len , 0 , pinfo , & ei_gsm_a_dtap_extraneous_data ) ;\n }", "idx": 21360}
{"hash": 8572106347813672436, "project": "debian", "size": 151, "label": 0, "functionSource": "static struct xfrm_state * pfkey_msg2xfrm_state ( struct net * net , const struct sadb_msg * hdr , void * const * ext_hdrs ) {\n struct xfrm_state * x ;\n const struct sadb_lifetime * lifetime ;\n const struct sadb_sa * sa ;\n const struct sadb_key * key ;\n const struct sadb_x_sec_ctx * sec_ctx ;\n uint16_t proto ;\n int err ;\n sa = ext_hdrs [ SADB_EXT_SA - 1 ] ;\n if ( ! sa || ! present_and_same_family ( ext_hdrs [ SADB_EXT_ADDRESS_SRC - 1 ] , ext_hdrs [ SADB_EXT_ADDRESS_DST - 1 ] ) ) return ERR_PTR ( - EINVAL ) ;\n if ( hdr -> sadb_msg_satype == SADB_SATYPE_ESP && ! ext_hdrs [ SADB_EXT_KEY_ENCRYPT - 1 ] ) return ERR_PTR ( - EINVAL ) ;\n if ( hdr -> sadb_msg_satype == SADB_SATYPE_AH && ! ext_hdrs [ SADB_EXT_KEY_AUTH - 1 ] ) return ERR_PTR ( - EINVAL ) ;\n if ( ! ! ext_hdrs [ SADB_EXT_LIFETIME_HARD - 1 ] != ! ! ext_hdrs [ SADB_EXT_LIFETIME_SOFT - 1 ] ) return ERR_PTR ( - EINVAL ) ;\n proto = pfkey_satype2proto ( hdr -> sadb_msg_satype ) ;\n if ( proto == 0 ) return ERR_PTR ( - EINVAL ) ;\n err = - ENOBUFS ;\n if ( sa -> sadb_sa_auth > SADB_AALG_MAX || ( hdr -> sadb_msg_satype == SADB_X_SATYPE_IPCOMP && sa -> sadb_sa_encrypt > SADB_X_CALG_MAX ) || sa -> sadb_sa_encrypt > SADB_EALG_MAX ) return ERR_PTR ( - EINVAL ) ;\n key = ext_hdrs [ SADB_EXT_KEY_AUTH - 1 ] ;\n if ( key != NULL && sa -> sadb_sa_auth != SADB_X_AALG_NULL && ( ( key -> sadb_key_bits + 7 ) / 8 == 0 || ( key -> sadb_key_bits + 7 ) / 8 > key -> sadb_key_len * sizeof ( uint64_t ) ) ) return ERR_PTR ( - EINVAL ) ;\n key = ext_hdrs [ SADB_EXT_KEY_ENCRYPT - 1 ] ;\n if ( key != NULL && sa -> sadb_sa_encrypt != SADB_EALG_NULL && ( ( key -> sadb_key_bits + 7 ) / 8 == 0 || ( key -> sadb_key_bits + 7 ) / 8 > key -> sadb_key_len * sizeof ( uint64_t ) ) ) return ERR_PTR ( - EINVAL ) ;\n x = xfrm_state_alloc ( net ) ;\n if ( x == NULL ) return ERR_PTR ( - ENOBUFS ) ;\n x -> id . proto = proto ;\n x -> id . spi = sa -> sadb_sa_spi ;\n x -> props . replay_window = sa -> sadb_sa_replay ;\n if ( sa -> sadb_sa_flags & SADB_SAFLAGS_NOECN ) x -> props . flags |= XFRM_STATE_NOECN ;\n if ( sa -> sadb_sa_flags & SADB_SAFLAGS_DECAP_DSCP ) x -> props . flags |= XFRM_STATE_DECAP_DSCP ;\n if ( sa -> sadb_sa_flags & SADB_SAFLAGS_NOPMTUDISC ) x -> props . flags |= XFRM_STATE_NOPMTUDISC ;\n lifetime = ext_hdrs [ SADB_EXT_LIFETIME_HARD - 1 ] ;\n if ( lifetime != NULL ) {\n x -> lft . hard_packet_limit = _KEY2X ( lifetime -> sadb_lifetime_allocations ) ;\n x -> lft . hard_byte_limit = _KEY2X ( lifetime -> sadb_lifetime_bytes ) ;\n x -> lft . hard_add_expires_seconds = lifetime -> sadb_lifetime_addtime ;\n x -> lft . hard_use_expires_seconds = lifetime -> sadb_lifetime_usetime ;\n }\n lifetime = ext_hdrs [ SADB_EXT_LIFETIME_SOFT - 1 ] ;\n if ( lifetime != NULL ) {\n x -> lft . soft_packet_limit = _KEY2X ( lifetime -> sadb_lifetime_allocations ) ;\n x -> lft . soft_byte_limit = _KEY2X ( lifetime -> sadb_lifetime_bytes ) ;\n x -> lft . soft_add_expires_seconds = lifetime -> sadb_lifetime_addtime ;\n x -> lft . soft_use_expires_seconds = lifetime -> sadb_lifetime_usetime ;\n }\n sec_ctx = ext_hdrs [ SADB_X_EXT_SEC_CTX - 1 ] ;\n if ( sec_ctx != NULL ) {\n struct xfrm_user_sec_ctx * uctx = pfkey_sadb2xfrm_user_sec_ctx ( sec_ctx ) ;\n if ( ! uctx ) goto out ;\n err = security_xfrm_state_alloc ( x , uctx ) ;\n kfree ( uctx ) ;\n if ( err ) goto out ;\n }\n key = ext_hdrs [ SADB_EXT_KEY_AUTH - 1 ] ;\n if ( sa -> sadb_sa_auth ) {\n int keysize = 0 ;\n struct xfrm_algo_desc * a = xfrm_aalg_get_byid ( sa -> sadb_sa_auth ) ;\n if ( ! a || ! a -> pfkey_supported ) {\n err = - ENOSYS ;\n goto out ;\n }\n if ( key ) keysize = ( key -> sadb_key_bits + 7 ) / 8 ;\n x -> aalg = kmalloc ( sizeof ( * x -> aalg ) + keysize , GFP_KERNEL ) ;\n if ( ! x -> aalg ) goto out ;\n strcpy ( x -> aalg -> alg_name , a -> name ) ;\n x -> aalg -> alg_key_len = 0 ;\n if ( key ) {\n x -> aalg -> alg_key_len = key -> sadb_key_bits ;\n memcpy ( x -> aalg -> alg_key , key + 1 , keysize ) ;\n }\n x -> aalg -> alg_trunc_len = a -> uinfo . auth . icv_truncbits ;\n x -> props . aalgo = sa -> sadb_sa_auth ;\n }\n if ( sa -> sadb_sa_encrypt ) {\n if ( hdr -> sadb_msg_satype == SADB_X_SATYPE_IPCOMP ) {\n struct xfrm_algo_desc * a = xfrm_calg_get_byid ( sa -> sadb_sa_encrypt ) ;\n if ( ! a || ! a -> pfkey_supported ) {\n err = - ENOSYS ;\n goto out ;\n }\n x -> calg = kmalloc ( sizeof ( * x -> calg ) , GFP_KERNEL ) ;\n if ( ! x -> calg ) goto out ;\n strcpy ( x -> calg -> alg_name , a -> name ) ;\n x -> props . calgo = sa -> sadb_sa_encrypt ;\n }\n else {\n int keysize = 0 ;\n struct xfrm_algo_desc * a = xfrm_ealg_get_byid ( sa -> sadb_sa_encrypt ) ;\n if ( ! a || ! a -> pfkey_supported ) {\n err = - ENOSYS ;\n goto out ;\n }\n key = ( struct sadb_key * ) ext_hdrs [ SADB_EXT_KEY_ENCRYPT - 1 ] ;\n if ( key ) keysize = ( key -> sadb_key_bits + 7 ) / 8 ;\n x -> ealg = kmalloc ( sizeof ( * x -> ealg ) + keysize , GFP_KERNEL ) ;\n if ( ! x -> ealg ) goto out ;\n strcpy ( x -> ealg -> alg_name , a -> name ) ;\n x -> ealg -> alg_key_len = 0 ;\n if ( key ) {\n x -> ealg -> alg_key_len = key -> sadb_key_bits ;\n memcpy ( x -> ealg -> alg_key , key + 1 , keysize ) ;\n }\n x -> props . ealgo = sa -> sadb_sa_encrypt ;\n }\n }\n x -> props . family = pfkey_sadb_addr2xfrm_addr ( ( struct sadb_address * ) ext_hdrs [ SADB_EXT_ADDRESS_SRC - 1 ] , & x -> props . saddr ) ;\n if ( ! x -> props . family ) {\n err = - EAFNOSUPPORT ;\n goto out ;\n }\n pfkey_sadb_addr2xfrm_addr ( ( struct sadb_address * ) ext_hdrs [ SADB_EXT_ADDRESS_DST - 1 ] , & x -> id . daddr ) ;\n if ( ext_hdrs [ SADB_X_EXT_SA2 - 1 ] ) {\n const struct sadb_x_sa2 * sa2 = ext_hdrs [ SADB_X_EXT_SA2 - 1 ] ;\n int mode = pfkey_mode_to_xfrm ( sa2 -> sadb_x_sa2_mode ) ;\n if ( mode < 0 ) {\n err = - EINVAL ;\n goto out ;\n }\n x -> props . mode = mode ;\n x -> props . reqid = sa2 -> sadb_x_sa2_reqid ;\n }\n if ( ext_hdrs [ SADB_EXT_ADDRESS_PROXY - 1 ] ) {\n const struct sadb_address * addr = ext_hdrs [ SADB_EXT_ADDRESS_PROXY - 1 ] ;\n x -> sel . family = pfkey_sadb_addr2xfrm_addr ( addr , & x -> sel . saddr ) ;\n x -> sel . prefixlen_s = addr -> sadb_address_prefixlen ;\n }\n if ( ! x -> sel . family ) x -> sel . family = x -> props . family ;\n if ( ext_hdrs [ SADB_X_EXT_NAT_T_TYPE - 1 ] ) {\n const struct sadb_x_nat_t_type * n_type ;\n struct xfrm_encap_tmpl * natt ;\n x -> encap = kmalloc ( sizeof ( * x -> encap ) , GFP_KERNEL ) ;\n if ( ! x -> encap ) goto out ;\n natt = x -> encap ;\n n_type = ext_hdrs [ SADB_X_EXT_NAT_T_TYPE - 1 ] ;\n natt -> encap_type = n_type -> sadb_x_nat_t_type_type ;\n if ( ext_hdrs [ SADB_X_EXT_NAT_T_SPORT - 1 ] ) {\n const struct sadb_x_nat_t_port * n_port = ext_hdrs [ SADB_X_EXT_NAT_T_SPORT - 1 ] ;\n natt -> encap_sport = n_port -> sadb_x_nat_t_port_port ;\n }\n if ( ext_hdrs [ SADB_X_EXT_NAT_T_DPORT - 1 ] ) {\n const struct sadb_x_nat_t_port * n_port = ext_hdrs [ SADB_X_EXT_NAT_T_DPORT - 1 ] ;\n natt -> encap_dport = n_port -> sadb_x_nat_t_port_port ;\n }\n memset ( & natt -> encap_oa , 0 , sizeof ( natt -> encap_oa ) ) ;\n }\n err = xfrm_init_state ( x ) ;\n if ( err ) goto out ;\n x -> km . seq = hdr -> sadb_msg_seq ;\n return x ;\n out : x -> km . state = XFRM_STATE_DEAD ;\n xfrm_state_put ( x ) ;\n return ERR_PTR ( err ) ;\n }", "idx": 21361}
{"hash": 9083170310480750768, "project": "debian", "size": 37, "label": 1, "functionSource": "int set_wep_key ( char * string ) {\n int bit = 0 ;\n char * p , type ;\n char * tok ;\n char s [ strlen ( string ) + 1 ] ;\n u_char tmp_wkey [ 512 ] ;\n size_t tmp_wkey_len ;\n char tmp [ 128 ] ;\n memset ( GBL_WIFI -> wkey , 0 , sizeof ( GBL_WIFI -> wkey ) ) ;\n GBL_WIFI -> wkey_len = 0 ;\n strcpy ( s , string ) ;\n p = ec_strtok ( s , \":\" , & tok ) ;\n if ( p == NULL ) SEMIFATAL_ERROR ( \"Invalid parsing of the WEP key\" ) ;\n bit = atoi ( p ) ;\n if ( bit <= 0 ) SEMIFATAL_ERROR ( \"Unsupported WEP key length\" ) ;\n tmp_wkey_len = bit / 8 - WEP_IV_LEN ;\n if ( bit != 64 && bit != 128 ) SEMIFATAL_ERROR ( \"Unsupported WEP key length\" ) ;\n p = ec_strtok ( NULL , \":\" , & tok ) ;\n if ( p == NULL ) SEMIFATAL_ERROR ( \"Invalid parsing of the WEP key\" ) ;\n type = * p ;\n p = ec_strtok ( NULL , \":\" , & tok ) ;\n if ( p == NULL ) SEMIFATAL_ERROR ( \"Invalid parsing of the WEP key\" ) ;\n if ( type == 's' ) {\n if ( strescape ( ( char * ) tmp_wkey , p ) != ( int ) tmp_wkey_len ) SEMIFATAL_ERROR ( \"Specified WEP key length does not match the given string\" ) ;\n }\n else if ( type == 'p' ) {\n if ( bit == 64 ) make_key_64 ( ( u_char * ) p , tmp_wkey ) ;\n else if ( bit == 128 ) make_key_128 ( ( u_char * ) p , tmp_wkey ) ;\n }\n else {\n SEMIFATAL_ERROR ( \"Invalid parsing of the WEP key\" ) ;\n }\n USER_MSG ( \"Using WEP key: %s\\n\" , str_tohex ( tmp_wkey , tmp_wkey_len , tmp , sizeof ( tmp ) ) ) ;\n memcpy ( GBL_WIFI -> wkey , tmp_wkey , sizeof ( GBL_WIFI -> wkey ) ) ;\n GBL_WIFI -> wkey_len = tmp_wkey_len ;\n return E_SUCCESS ;\n }", "idx": 21362}
{"hash": -3383030848920666759, "project": "debian", "size": 10, "label": 0, "functionSource": "static void * login_setting_dup ( pool_t pool , const struct setting_parser_info * info , const void * src_set ) {\n const char * error ;\n void * dest ;\n dest = settings_dup ( info , src_set , pool ) ;\n if ( ! settings_check ( info , pool , dest , & error ) ) {\n const char * name = info -> module_name ;\n i_fatal ( \"settings_check(%s) failed: %s\" , name != NULL ? name : \"unknown\" , error ) ;\n }\n return dest ;\n }", "idx": 21363}
{"hash": 1245821301839614810, "project": "debian", "size": 52, "label": 0, "functionSource": "static void set_permissions_file ( SetPermissionsJob * job , GFile * file , GFileInfo * info ) {\n CommonJob * common ;\n GFileInfo * child_info ;\n gboolean free_info ;\n guint32 current ;\n guint32 value ;\n guint32 mask ;\n GFileEnumerator * enumerator ;\n GFile * child ;\n common = ( CommonJob * ) job ;\n nautilus_progress_info_pulse_progress ( common -> progress ) ;\n free_info = FALSE ;\n if ( info == NULL ) {\n free_info = TRUE ;\n info = g_file_query_info ( file , G_FILE_ATTRIBUTE_STANDARD_TYPE \",\" G_FILE_ATTRIBUTE_UNIX_MODE , G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS , common -> cancellable , NULL ) ;\n if ( info == NULL ) {\n return ;\n }\n }\n if ( g_file_info_get_file_type ( info ) == G_FILE_TYPE_DIRECTORY ) {\n value = job -> dir_permissions ;\n mask = job -> dir_mask ;\n }\n else {\n value = job -> file_permissions ;\n mask = job -> file_mask ;\n }\n if ( ! job_aborted ( common ) && g_file_info_has_attribute ( info , G_FILE_ATTRIBUTE_UNIX_MODE ) ) {\n current = g_file_info_get_attribute_uint32 ( info , G_FILE_ATTRIBUTE_UNIX_MODE ) ;\n if ( common -> undo_info != NULL ) {\n nautilus_file_undo_info_rec_permissions_add_file ( NAUTILUS_FILE_UNDO_INFO_REC_PERMISSIONS ( common -> undo_info ) , file , current ) ;\n }\n current = ( current & ~ mask ) | value ;\n g_file_set_attribute_uint32 ( file , G_FILE_ATTRIBUTE_UNIX_MODE , current , G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS , common -> cancellable , NULL ) ;\n }\n if ( ! job_aborted ( common ) && g_file_info_get_file_type ( info ) == G_FILE_TYPE_DIRECTORY ) {\n enumerator = g_file_enumerate_children ( file , G_FILE_ATTRIBUTE_STANDARD_NAME \",\" G_FILE_ATTRIBUTE_STANDARD_TYPE \",\" G_FILE_ATTRIBUTE_UNIX_MODE , G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS , common -> cancellable , NULL ) ;\n if ( enumerator ) {\n while ( ! job_aborted ( common ) && ( child_info = g_file_enumerator_next_file ( enumerator , common -> cancellable , NULL ) ) != NULL ) {\n child = g_file_get_child ( file , g_file_info_get_name ( child_info ) ) ;\n set_permissions_file ( job , child , child_info ) ;\n g_object_unref ( child ) ;\n g_object_unref ( child_info ) ;\n }\n g_file_enumerator_close ( enumerator , common -> cancellable , NULL ) ;\n g_object_unref ( enumerator ) ;\n }\n }\n if ( free_info ) {\n g_object_unref ( info ) ;\n }\n }", "idx": 21364}
{"hash": -4055702019813176658, "project": "debian", "size": 143, "label": 1, "functionSource": "static guint32 dissect_fullpacket ( tvbuff_t * tvb , guint32 offset , guint16 scallno , packet_info * pinfo , proto_tree * iax2_tree , proto_tree * main_tree ) {\n guint16 dcallno ;\n guint32 ts ;\n guint8 type ;\n guint8 csub ;\n guint32 codec ;\n proto_tree * packet_type_tree = NULL ;\n iax_call_data * iax_call ;\n iax_packet_data * iax_packet ;\n gboolean reversed ;\n gboolean rtp_marker ;\n dcallno = tvb_get_ntohs ( tvb , offset ) & 0x7FFF ;\n ts = tvb_get_ntohl ( tvb , offset + 2 ) ;\n type = tvb_get_guint8 ( tvb , offset + 8 ) ;\n csub = tvb_get_guint8 ( tvb , offset + 9 ) ;\n iax2_info -> ftype = type ;\n iax2_info -> csub = csub ;\n iax2_info -> scallno = scallno ;\n iax2_info -> dcallno = dcallno ;\n iax_packet = ( iax_packet_data * ) p_get_proto_data ( wmem_file_scope ( ) , pinfo , proto_iax2 , 0 ) ;\n if ( ! iax_packet ) {\n if ( type == AST_FRAME_IAX && csub == IAX_COMMAND_NEW ) {\n iax_call = iax_new_call ( pinfo , scallno ) ;\n reversed = FALSE ;\n }\n else {\n iax_call = iax_lookup_call ( pinfo , scallno , dcallno , & reversed ) ;\n }\n iax_packet = iax_new_packet_data ( iax_call , reversed ) ;\n p_add_proto_data ( wmem_file_scope ( ) , pinfo , proto_iax2 , 0 , iax_packet ) ;\n }\n else {\n iax_call = iax_packet -> call_data ;\n reversed = iax_packet -> reversed ;\n }\n iax2_populate_pinfo_from_packet_data ( pinfo , iax_packet ) ;\n if ( iax2_tree ) {\n proto_item * packet_type_base ;\n proto_tree_add_item ( iax2_tree , hf_iax2_dcallno , tvb , offset , 2 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( iax2_tree , hf_iax2_retransmission , tvb , offset , 2 , ENC_BIG_ENDIAN ) ;\n if ( iax_call ) {\n proto_item * item = proto_tree_add_uint ( iax2_tree , hf_iax2_callno , tvb , 0 , 4 , iax_call -> forward_circuit_ids [ 0 ] ) ;\n PROTO_ITEM_SET_GENERATED ( item ) ;\n }\n proto_tree_add_uint ( iax2_tree , hf_iax2_ts , tvb , offset + 2 , 4 , ts ) ;\n iax2_add_ts_fields ( pinfo , iax2_tree , iax_packet , ( guint16 ) ts ) ;\n proto_tree_add_item ( iax2_tree , hf_iax2_oseqno , tvb , offset + 6 , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( iax2_tree , hf_iax2_iseqno , tvb , offset + 7 , 1 , ENC_BIG_ENDIAN ) ;\n packet_type_base = proto_tree_add_uint ( iax2_tree , hf_iax2_type , tvb , offset + 8 , 1 , type ) ;\n packet_type_tree = proto_item_add_subtree ( packet_type_base , ett_iax2_type ) ;\n }\n else {\n iax2_add_ts_fields ( pinfo , iax2_tree , iax_packet , ( guint16 ) ts ) ;\n }\n col_add_fstr ( pinfo -> cinfo , COL_INFO , \"%s, source call# %d, timestamp %ums\" , val_to_str_ext ( type , & iax_frame_types_ext , \"Unknown (0x%02x)\" ) , scallno , ts ) ;\n iax2_info -> messageName = val_to_str_ext ( type , & iax_frame_types_ext , \"Unknown (0x%02x)\" ) ;\n switch ( type ) {\n case AST_FRAME_IAX : offset = dissect_iax2_command ( tvb , offset + 9 , pinfo , packet_type_tree , iax_packet ) ;\n iax2_info -> messageName = val_to_str_ext ( csub , & iax_iax_subclasses_ext , \"unknown (0x%02x)\" ) ;\n if ( csub < NUM_TAP_IAX_VOIP_STATES ) iax2_info -> callState = tap_iax_voip_state [ csub ] ;\n break ;\n case AST_FRAME_DTMF_BEGIN : case AST_FRAME_DTMF_END : proto_tree_add_item ( packet_type_tree , hf_iax2_dtmf_csub , tvb , offset + 9 , 1 , ENC_ASCII | ENC_NA ) ;\n offset += 10 ;\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \" digit %c\" , csub ) ;\n break ;\n case AST_FRAME_CONTROL : proto_tree_add_uint ( packet_type_tree , hf_iax2_cmd_csub , tvb , offset + 9 , 1 , csub ) ;\n offset += 10 ;\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \" %s\" , val_to_str_ext ( csub , & iax_cmd_subclasses_ext , \"unknown (0x%02x)\" ) ) ;\n iax2_info -> messageName = val_to_str_ext ( csub , & iax_cmd_subclasses_ext , \"unknown (0x%02x)\" ) ;\n if ( csub < NUM_TAP_CMD_VOIP_STATES ) iax2_info -> callState = tap_cmd_voip_state [ csub ] ;\n break ;\n case AST_FRAME_VOICE : iax_packet -> codec = codec = uncompress_subclass ( csub ) ;\n if ( packet_type_tree ) {\n proto_item * item ;\n proto_tree_add_item ( packet_type_tree , hf_iax2_voice_csub , tvb , offset + 9 , 1 , ENC_BIG_ENDIAN ) ;\n item = proto_tree_add_uint ( packet_type_tree , hf_iax2_voice_codec , tvb , offset + 9 , 1 , codec ) ;\n PROTO_ITEM_SET_GENERATED ( item ) ;\n }\n offset += 10 ;\n if ( iax_call ) {\n if ( reversed ) {\n iax_call -> dst_codec = codec ;\n }\n else {\n iax_call -> src_codec = codec ;\n }\n }\n dissect_payload ( tvb , offset , pinfo , iax2_tree , main_tree , ts , FALSE , iax_packet ) ;\n break ;\n case AST_FRAME_VIDEO : rtp_marker = csub & 0x40 ? TRUE : FALSE ;\n iax_packet -> codec = codec = uncompress_subclass ( ( guint8 ) ( csub & ~ 40 ) ) ;\n if ( packet_type_tree ) {\n proto_item * item ;\n proto_tree_add_item ( packet_type_tree , hf_iax2_video_csub , tvb , offset + 9 , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( packet_type_tree , hf_iax2_marker , tvb , offset + 9 , 1 , ENC_BIG_ENDIAN ) ;\n item = proto_tree_add_uint ( packet_type_tree , hf_iax2_video_codec , tvb , offset + 9 , 1 , codec ) ;\n PROTO_ITEM_SET_GENERATED ( item ) ;\n }\n offset += 10 ;\n if ( iax_call && iax_packet -> first_time ) {\n if ( reversed ) {\n iax_call -> dst_vformat = codec ;\n }\n else {\n iax_call -> src_vformat = codec ;\n }\n }\n if ( rtp_marker ) col_append_str ( pinfo -> cinfo , COL_INFO , \", Mark\" ) ;\n dissect_payload ( tvb , offset , pinfo , iax2_tree , main_tree , ts , TRUE , iax_packet ) ;\n break ;\n case AST_FRAME_MODEM : proto_tree_add_item ( packet_type_tree , hf_iax2_modem_csub , tvb , offset + 9 , 1 , ENC_BIG_ENDIAN ) ;\n offset += 10 ;\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \" %s\" , val_to_str ( csub , iax_modem_subclasses , \"unknown (0x%02x)\" ) ) ;\n break ;\n case AST_FRAME_TEXT : proto_tree_add_item ( packet_type_tree , hf_iax2_text_csub , tvb , offset + 9 , 1 , ENC_BIG_ENDIAN ) ;\n offset += 10 ;\n {\n int textlen = tvb_captured_length_remaining ( tvb , offset ) ;\n if ( textlen > 0 ) {\n proto_tree_add_item ( packet_type_tree , hf_iax2_text_text , tvb , offset , textlen , ENC_UTF_8 | ENC_NA ) ;\n offset += textlen ;\n }\n }\n break ;\n case AST_FRAME_HTML : proto_tree_add_item ( packet_type_tree , hf_iax2_html_csub , tvb , offset + 9 , 1 , ENC_BIG_ENDIAN ) ;\n offset += 10 ;\n if ( csub == 0x01 ) {\n int urllen = tvb_captured_length_remaining ( tvb , offset ) ;\n if ( urllen > 0 ) {\n proto_item * pi = proto_tree_add_item ( packet_type_tree , hf_iax2_html_url , tvb , offset , urllen , ENC_UTF_8 | ENC_NA ) ;\n PROTO_ITEM_SET_URL ( pi ) ;\n offset += urllen ;\n }\n }\n break ;\n case AST_FRAME_CNG : default : proto_tree_add_uint ( packet_type_tree , hf_iax2_csub , tvb , offset + 9 , 1 , csub ) ;\n offset += 10 ;\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \" subclass %d\" , csub ) ;\n break ;\n }\n iax_packet -> first_time = FALSE ;\n return offset ;\n }", "idx": 21365}
{"hash": -7117046864335130087, "project": "chrome", "size": 18, "label": 0, "functionSource": "int vp9_compute_qdelta ( const RATE_CONTROL * rc , double qstart , double qtarget , vpx_bit_depth_t bit_depth ) {\n int start_index = rc -> worst_quality ;\n int target_index = rc -> worst_quality ;\n int i ;\n for ( i = rc -> best_quality ;\n i < rc -> worst_quality ;\n ++ i ) {\n start_index = i ;\n if ( vp9_convert_qindex_to_q ( i , bit_depth ) >= qstart ) break ;\n }\n for ( i = rc -> best_quality ;\n i < rc -> worst_quality ;\n ++ i ) {\n target_index = i ;\n if ( vp9_convert_qindex_to_q ( i , bit_depth ) >= qtarget ) break ;\n }\n return target_index - start_index ;\n }", "idx": 21366}
{"hash": 9196999303933889181, "project": "debian", "size": 54, "label": 0, "functionSource": "static int zerocodec_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n ZeroCodecContext * zc = avctx -> priv_data ;\n AVFrame * pic = data ;\n AVFrame * prev_pic = & zc -> previous_frame ;\n z_stream * zstream = & zc -> zstream ;\n uint8_t * prev = prev_pic -> data [ 0 ] ;\n uint8_t * dst ;\n int i , j , zret , ret ;\n if ( avpkt -> flags & AV_PKT_FLAG_KEY ) {\n pic -> key_frame = 1 ;\n pic -> pict_type = AV_PICTURE_TYPE_I ;\n }\n else {\n if ( ! prev ) {\n av_log ( avctx , AV_LOG_ERROR , \"Missing reference frame.\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n prev += ( avctx -> height - 1 ) * prev_pic -> linesize [ 0 ] ;\n pic -> key_frame = 0 ;\n pic -> pict_type = AV_PICTURE_TYPE_P ;\n }\n zret = inflateReset ( zstream ) ;\n if ( zret != Z_OK ) {\n av_log ( avctx , AV_LOG_ERROR , \"Could not reset inflate: %d.\\n\" , zret ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( ff_get_buffer ( avctx , pic , AV_GET_BUFFER_FLAG_REF ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"Could not allocate buffer.\\n\" ) ;\n return AVERROR ( ENOMEM ) ;\n }\n zstream -> next_in = avpkt -> data ;\n zstream -> avail_in = avpkt -> size ;\n dst = pic -> data [ 0 ] + ( avctx -> height - 1 ) * pic -> linesize [ 0 ] ;\n for ( i = 0 ;\n i < avctx -> height ;\n i ++ ) {\n zstream -> next_out = dst ;\n zstream -> avail_out = avctx -> width << 1 ;\n zret = inflate ( zstream , Z_SYNC_FLUSH ) ;\n if ( zret != Z_OK && zret != Z_STREAM_END ) {\n av_log ( avctx , AV_LOG_ERROR , \"Inflate failed with return code: %d.\\n\" , zret ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( ! ( avpkt -> flags & AV_PKT_FLAG_KEY ) ) for ( j = 0 ;\n j < avctx -> width << 1 ;\n j ++ ) dst [ j ] += prev [ j ] & - ! dst [ j ] ;\n prev -= prev_pic -> linesize [ 0 ] ;\n dst -= pic -> linesize [ 0 ] ;\n }\n av_frame_unref ( & zc -> previous_frame ) ;\n if ( ( ret = av_frame_ref ( & zc -> previous_frame , pic ) ) < 0 ) return ret ;\n * got_frame = 1 ;\n return avpkt -> size ;\n }", "idx": 21367}
{"hash": -5968890769755017734, "project": "debian", "size": 64, "label": 0, "functionSource": "static void process_flags ( int argc , char * * argv ) {\n int c ;\n static struct option long_options [ ] = {\n {\n \"command\" , required_argument , NULL , 'c' }\n , {\n \"help\" , no_argument , NULL , 'h' }\n , {\n \"login\" , no_argument , NULL , 'l' }\n , {\n \"preserve-environment\" , no_argument , NULL , 'p' }\n , {\n \"shell\" , required_argument , NULL , 's' }\n , {\n NULL , 0 , NULL , '\\0' }\n }\n ;\n while ( ( c = getopt_long ( argc , argv , \"c:hlmps:\" , long_options , NULL ) ) != - 1 ) {\n switch ( c ) {\n case 'c' : command = optarg ;\n break ;\n case 'h' : usage ( E_SUCCESS ) ;\n break ;\n case 'l' : fakelogin = true ;\n break ;\n case 'm' : case 'p' : change_environment = false ;\n break ;\n case 's' : shellstr = optarg ;\n break ;\n default : usage ( E_USAGE ) ;\n }\n }\n if ( ( optind < argc ) && ( strcmp ( argv [ optind ] , \"-\" ) == 0 ) ) {\n fakelogin = true ;\n optind ++ ;\n if ( ( optind < argc ) && ( strcmp ( argv [ optind ] , \"--\" ) == 0 ) ) {\n optind ++ ;\n }\n }\n if ( ( optind < argc ) && ( '-' != argv [ optind ] [ 0 ] ) ) {\n STRFCPY ( name , argv [ optind ++ ] ) ;\n if ( ( optind < argc ) && ( strcmp ( argv [ optind ] , \"--\" ) == 0 ) ) {\n optind ++ ;\n }\n }\n if ( '\\0' == name [ 0 ] ) {\n struct passwd * root_pw = getpwnam ( \"root\" ) ;\n if ( ( NULL != root_pw ) && ( 0 == root_pw -> pw_uid ) ) {\n ( void ) strcpy ( name , \"root\" ) ;\n }\n else {\n root_pw = getpwuid ( 0 ) ;\n if ( NULL == root_pw ) {\n SYSLOG ( ( LOG_CRIT , \"There is no UID 0 user.\" ) ) ;\n su_failure ( caller_tty , true ) ;\n }\n ( void ) strcpy ( name , root_pw -> pw_name ) ;\n }\n }\n doshell = ( argc == optind ) ;\n if ( NULL != command ) {\n doshell = false ;\n }\n }", "idx": 21368}
{"hash": 3584320764213684062, "project": "debian", "size": 26, "label": 1, "functionSource": "static int parse_PropertySetArray ( tvbuff_t * tvb , int offset , int size_offset , proto_tree * parent_tree , proto_tree * pad_tree , const char * fmt , ... ) {\n const int offset_in = offset ;\n guint32 size , num ;\n int i ;\n proto_tree * tree ;\n proto_item * item ;\n const char * txt ;\n va_list ap ;\n va_start ( ap , fmt ) ;\n txt = wmem_strdup_vprintf ( wmem_packet_scope ( ) , fmt , ap ) ;\n va_end ( ap ) ;\n tree = proto_tree_add_subtree ( parent_tree , tvb , offset , 0 , ett_CDbPropSet_Array , & item , txt ) ;\n size = tvb_get_letohl ( tvb , size_offset ) ;\n proto_tree_add_item ( tree , hf_mswsp_msg_ConnectIn_Blob1 , tvb , size_offset , 4 , ENC_LITTLE_ENDIAN ) ;\n num = tvb_get_letohl ( tvb , offset ) ;\n proto_tree_add_item ( tree , hf_mswsp_msg_ConnectIn_PropSets_num , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n for ( i = 0 ;\n i < ( int ) num ;\n i ++ ) {\n offset = parse_CDbPropSet ( tvb , offset , tree , pad_tree , \"PropertySet[%d]\" , i ) ;\n }\n proto_item_set_end ( item , tvb , offset ) ;\n DISSECTOR_ASSERT ( offset - offset_in == ( int ) size ) ;\n return offset ;\n }", "idx": 21369}
{"hash": 1760449185745615462, "project": "debian", "size": 484, "label": 0, "functionSource": "TSReturnCode TSHttpTxnConfigFind ( const char * name , int length , TSOverridableConfigKey * conf , TSRecordDataType * type ) {\n sdk_assert ( sdk_sanity_check_null_ptr ( ( void * ) name ) == TS_SUCCESS ) ;\n sdk_assert ( sdk_sanity_check_null_ptr ( ( void * ) conf ) == TS_SUCCESS ) ;\n TSOverridableConfigKey cnf = TS_CONFIG_NULL ;\n TSRecordDataType typ = TS_RECORDDATATYPE_INT ;\n if ( length == - 1 ) {\n length = strlen ( name ) ;\n }\n switch ( length ) {\n case 24 : if ( ! strncmp ( name , \"proxy.config.srv_enabled\" , length ) ) {\n cnf = TS_CONFIG_SRV_ENABLED ;\n }\n break ;\n case 28 : if ( ! strncmp ( name , \"proxy.config.http.cache.http\" , length ) ) {\n cnf = TS_CONFIG_HTTP_CACHE_HTTP ;\n }\n break ;\n case 29 : if ( ! strncmp ( name , \"proxy.config.ssl.hsts_max_age\" , length ) ) {\n cnf = TS_CONFIG_SSL_HSTS_MAX_AGE ;\n }\n break ;\n case 31 : if ( ! strncmp ( name , \"proxy.config.http.chunking.size\" , length ) ) {\n cnf = TS_CONFIG_HTTP_CHUNKING_SIZE ;\n }\n break ;\n case 33 : if ( ! strncmp ( name , \"proxy.config.http.cache.fuzz.time\" , length ) ) {\n cnf = TS_CONFIG_HTTP_CACHE_FUZZ_TIME ;\n }\n else if ( ! strncmp ( name , \"proxy.config.ssl.client.cert.path\" , length ) ) {\n cnf = TS_CONFIG_SSL_CERT_FILEPATH ;\n typ = TS_RECORDDATATYPE_STRING ;\n }\n break ;\n case 34 : if ( ! strncmp ( name , \"proxy.config.http.chunking_enabled\" , length ) ) {\n cnf = TS_CONFIG_HTTP_CHUNKING_ENABLED ;\n }\n else if ( ! strncmp ( name , \"proxy.config.http.cache.generation\" , length ) ) {\n cnf = TS_CONFIG_HTTP_CACHE_GENERATION ;\n }\n else if ( ! strncmp ( name , \"proxy.config.http.insert_client_ip\" , length ) ) {\n cnf = TS_CONFIG_HTTP_ANONYMIZE_INSERT_CLIENT_IP ;\n }\n break ;\n case 35 : switch ( name [ length - 1 ] ) {\n case 'e' : if ( ! strncmp ( name , \"proxy.config.http.cache.range.write\" , length ) ) {\n cnf = TS_CONFIG_HTTP_CACHE_RANGE_WRITE ;\n }\n else if ( ! strncmp ( name , \"proxy.config.http.allow_multi_range\" , length ) ) {\n cnf = TS_CONFIG_HTTP_ALLOW_MULTI_RANGE ;\n }\n break ;\n case 'p' : if ( ! strncmp ( name , \"proxy.config.http.normalize_ae_gzip\" , length ) ) {\n cnf = TS_CONFIG_HTTP_NORMALIZE_AE_GZIP ;\n }\n break ;\n }\n break ;\n case 36 : switch ( name [ length - 1 ] ) {\n case 'p' : if ( ! strncmp ( name , \"proxy.config.http.cache.range.lookup\" , length ) ) {\n cnf = TS_CONFIG_HTTP_CACHE_RANGE_LOOKUP ;\n }\n break ;\n case 't' : if ( ! strncmp ( name , \"proxy.config.net.sock_packet_tos_out\" , length ) ) {\n cnf = TS_CONFIG_NET_SOCK_PACKET_TOS_OUT ;\n }\n break ;\n case 'd' : if ( ! strncmp ( name , \"proxy.config.http.slow.log.threshold\" , length ) ) {\n cnf = TS_CONFIG_HTTP_SLOW_LOG_THRESHOLD ;\n }\n break ;\n }\n break ;\n case 37 : switch ( name [ length - 1 ] ) {\n case 'd' : if ( ! strncmp ( name , \"proxy.config.http.redirection_enabled\" , length ) ) {\n cnf = TS_CONFIG_HTTP_ENABLE_REDIRECTION ;\n }\n break ;\n case 'e' : if ( ! strncmp ( name , \"proxy.config.http.cache.max_stale_age\" , length ) ) {\n cnf = TS_CONFIG_HTTP_CACHE_MAX_STALE_AGE ;\n }\n else if ( ! strncmp ( name , \"proxy.config.http.cache.fuzz.min_time\" , length ) ) {\n cnf = TS_CONFIG_HTTP_CACHE_FUZZ_MIN_TIME ;\n }\n else if ( ! strncmp ( name , \"proxy.config.http.default_buffer_size\" , length ) ) {\n cnf = TS_CONFIG_HTTP_DEFAULT_BUFFER_SIZE ;\n }\n else if ( ! strncmp ( name , \"proxy.config.ssl.client.cert.filename\" , length ) ) {\n cnf = TS_CONFIG_SSL_CERT_FILENAME ;\n typ = TS_RECORDDATATYPE_STRING ;\n }\n break ;\n case 'r' : if ( ! strncmp ( name , \"proxy.config.http.response_server_str\" , length ) ) {\n cnf = TS_CONFIG_HTTP_RESPONSE_SERVER_STR ;\n typ = TS_RECORDDATATYPE_STRING ;\n }\n else if ( ! strncmp ( name , \"proxy.config.ssl.client.verify.server\" , length ) ) {\n cnf = TS_CONFIG_SSL_CLIENT_VERIFY_SERVER ;\n }\n break ;\n case 't' : if ( ! strncmp ( name , \"proxy.config.http.keep_alive_post_out\" , length ) ) {\n cnf = TS_CONFIG_HTTP_KEEP_ALIVE_POST_OUT ;\n }\n else if ( ! strncmp ( name , \"proxy.config.net.sock_option_flag_out\" , length ) ) {\n cnf = TS_CONFIG_NET_SOCK_OPTION_FLAG_OUT ;\n }\n else if ( ! strncmp ( name , \"proxy.config.net.sock_packet_mark_out\" , length ) ) {\n cnf = TS_CONFIG_NET_SOCK_PACKET_MARK_OUT ;\n }\n else if ( ! strncmp ( name , \"proxy.config.websocket.active_timeout\" , length ) ) {\n cnf = TS_CONFIG_WEBSOCKET_ACTIVE_TIMEOUT ;\n }\n break ;\n }\n break ;\n case 38 : switch ( name [ length - 1 ] ) {\n case 'd' : if ( ! strncmp ( name , \"proxy.config.http.server_tcp_init_cwnd\" , length ) ) {\n cnf = TS_CONFIG_HTTP_SERVER_TCP_INIT_CWND ;\n }\n else if ( ! strncmp ( name , \"proxy.config.http.flow_control.enabled\" , length ) ) {\n cnf = TS_CONFIG_HTTP_FLOW_CONTROL_ENABLED ;\n }\n break ;\n break ;\n case 's' : if ( ! strncmp ( name , \"proxy.config.http.send_http11_requests\" , length ) ) {\n cnf = TS_CONFIG_HTTP_SEND_HTTP11_REQUESTS ;\n }\n break ;\n }\n break ;\n case 39 : switch ( name [ length - 1 ] ) {\n case 'e' : if ( ! strncmp ( name , \"proxy.config.body_factory.template_base\" , length ) ) {\n cnf = TS_CONFIG_BODY_FACTORY_TEMPLATE_BASE ;\n typ = TS_RECORDDATATYPE_STRING ;\n }\n break ;\n case 'm' : if ( ! strncmp ( name , \"proxy.config.http.anonymize_remove_from\" , length ) ) {\n cnf = TS_CONFIG_HTTP_ANONYMIZE_REMOVE_FROM ;\n }\n break ;\n case 'n' : if ( ! strncmp ( name , \"proxy.config.http.keep_alive_enabled_in\" , length ) ) {\n cnf = TS_CONFIG_HTTP_KEEP_ALIVE_ENABLED_IN ;\n }\n break ;\n case 's' : if ( ! strncmp ( name , \"proxy.config.http.doc_in_cache_skip_dns\" , length ) ) {\n cnf = TS_CONFIG_HTTP_DOC_IN_CACHE_SKIP_DNS ;\n }\n break ;\n }\n break ;\n case 40 : switch ( name [ length - 1 ] ) {\n case 'd' : if ( ! strncmp ( name , \"proxy.config.http.forward_connect_method\" , length ) ) {\n cnf = TS_CONFIG_HTTP_FORWARD_CONNECT_METHOD ;\n }\n break ;\n case 'e' : if ( ! strncmp ( name , \"proxy.config.http.down_server.cache_time\" , length ) ) {\n cnf = TS_CONFIG_HTTP_DOWN_SERVER_CACHE_TIME ;\n }\n else if ( ! strncmp ( name , \"proxy.config.http.insert_age_in_response\" , length ) ) {\n cnf = TS_CONFIG_HTTP_INSERT_AGE_IN_RESPONSE ;\n }\n break ;\n case 'r' : if ( ! strncmp ( name , \"proxy.config.url_remap.pristine_host_hdr\" , length ) ) {\n cnf = TS_CONFIG_URL_REMAP_PRISTINE_HOST_HDR ;\n }\n else if ( ! strncmp ( name , \"proxy.config.http.insert_request_via_str\" , length ) ) {\n cnf = TS_CONFIG_HTTP_INSERT_REQUEST_VIA_STR ;\n }\n else if ( ! strncmp ( name , \"proxy.config.http.flow_control.low_water\" , length ) ) {\n cnf = TS_CONFIG_HTTP_FLOW_CONTROL_LOW_WATER_MARK ;\n }\n break ;\n case 's' : if ( ! strncmp ( name , \"proxy.config.http.origin_max_connections\" , length ) ) {\n cnf = TS_CONFIG_HTTP_ORIGIN_MAX_CONNECTIONS ;\n }\n else if ( ! strncmp ( name , \"proxy.config.http.cache.required_headers\" , length ) ) {\n cnf = TS_CONFIG_HTTP_CACHE_REQUIRED_HEADERS ;\n }\n else if ( ! strncmp ( name , \"proxy.config.ssl.hsts_include_subdomains\" , length ) ) {\n cnf = TS_CONFIG_SSL_HSTS_INCLUDE_SUBDOMAINS ;\n }\n else if ( ! strncmp ( name , \"proxy.config.http.number_of_redirections\" , length ) ) {\n cnf = TS_CONFIG_HTTP_NUMBER_OF_REDIRECTIONS ;\n }\n break ;\n case 't' : if ( ! strncmp ( name , \"proxy.config.http.keep_alive_enabled_out\" , length ) ) {\n cnf = TS_CONFIG_HTTP_KEEP_ALIVE_ENABLED_OUT ;\n }\n break ;\n case 'y' : if ( ! strncmp ( name , \"proxy.config.http.cache.fuzz.probability\" , length ) ) {\n typ = TS_RECORDDATATYPE_FLOAT ;\n cnf = TS_CONFIG_HTTP_CACHE_FUZZ_PROBABILITY ;\n }\n break ;\n }\n break ;\n case 41 : switch ( name [ length - 1 ] ) {\n case 'd' : if ( ! strncmp ( name , \"proxy.config.http.response_server_enabled\" , length ) ) {\n cnf = TS_CONFIG_HTTP_RESPONSE_SERVER_ENABLED ;\n }\n break ;\n case 'e' : if ( ! strncmp ( name , \"proxy.config.http.anonymize_remove_cookie\" , length ) ) {\n cnf = TS_CONFIG_HTTP_ANONYMIZE_REMOVE_COOKIE ;\n }\n else if ( ! strncmp ( name , \"proxy.config.http.request_header_max_size\" , length ) ) {\n cnf = TS_CONFIG_HTTP_REQUEST_HEADER_MAX_SIZE ;\n }\n else if ( ! strncmp ( name , \"proxy.config.http.safe_requests_retryable\" , length ) ) {\n cnf = TS_CONFIG_HTTP_SAFE_REQUESTS_RETRYABLE ;\n }\n else if ( ! strncmp ( name , \"proxy.config.http.parent_proxy.retry_time\" , length ) ) {\n cnf = TS_CONFIG_HTTP_PARENT_PROXY_RETRY_TIME ;\n }\n break ;\n case 'r' : if ( ! strncmp ( name , \"proxy.config.http.insert_response_via_str\" , length ) ) {\n cnf = TS_CONFIG_HTTP_INSERT_RESPONSE_VIA_STR ;\n }\n else if ( ! strncmp ( name , \"proxy.config.http.flow_control.high_water\" , length ) ) {\n cnf = TS_CONFIG_HTTP_FLOW_CONTROL_HIGH_WATER_MARK ;\n }\n break ;\n }\n break ;\n case 42 : switch ( name [ length - 1 ] ) {\n case 'd' : if ( ! strncmp ( name , \"proxy.config.http.negative_caching_enabled\" , length ) ) {\n cnf = TS_CONFIG_HTTP_NEGATIVE_CACHING_ENABLED ;\n }\n break ;\n case 'e' : if ( ! strncmp ( name , \"proxy.config.http.cache.when_to_revalidate\" , length ) ) {\n cnf = TS_CONFIG_HTTP_CACHE_WHEN_TO_REVALIDATE ;\n }\n else if ( ! strncmp ( name , \"proxy.config.http.response_header_max_size\" , length ) ) {\n cnf = TS_CONFIG_HTTP_RESPONSE_HEADER_MAX_SIZE ;\n }\n break ;\n case 'r' : if ( ! strncmp ( name , \"proxy.config.http.anonymize_remove_referer\" , length ) ) {\n cnf = TS_CONFIG_HTTP_ANONYMIZE_REMOVE_REFERER ;\n }\n else if ( ! strncmp ( name , \"proxy.config.http.global_user_agent_header\" , length ) ) {\n cnf = TS_CONFIG_HTTP_GLOBAL_USER_AGENT_HEADER ;\n typ = TS_RECORDDATATYPE_STRING ;\n }\n break ;\n case 't' : if ( ! strncmp ( name , \"proxy.config.net.sock_recv_buffer_size_out\" , length ) ) {\n cnf = TS_CONFIG_NET_SOCK_RECV_BUFFER_SIZE_OUT ;\n }\n else if ( ! strncmp ( name , \"proxy.config.net.sock_send_buffer_size_out\" , length ) ) {\n cnf = TS_CONFIG_NET_SOCK_SEND_BUFFER_SIZE_OUT ;\n }\n else if ( ! strncmp ( name , \"proxy.config.http.connect_attempts_timeout\" , length ) ) {\n cnf = TS_CONFIG_HTTP_CONNECT_ATTEMPTS_TIMEOUT ;\n }\n else if ( ! strncmp ( name , \"proxy.config.websocket.no_activity_timeout\" , length ) ) {\n cnf = TS_CONFIG_WEBSOCKET_NO_ACTIVITY_TIMEOUT ;\n }\n break ;\n }\n break ;\n case 43 : switch ( name [ length - 1 ] ) {\n case 'e' : if ( ! strncmp ( name , \"proxy.config.http.negative_caching_lifetime\" , length ) ) {\n cnf = TS_CONFIG_HTTP_NEGATIVE_CACHING_LIFETIME ;\n }\n break ;\n case 'k' : if ( ! strncmp ( name , \"proxy.config.http.default_buffer_water_mark\" , length ) ) {\n cnf = TS_CONFIG_HTTP_DEFAULT_BUFFER_WATER_MARK ;\n }\n break ;\n case 'l' : if ( ! strncmp ( name , \"proxy.config.http.cache.cluster_cache_local\" , length ) ) {\n cnf = TS_CONFIG_HTTP_CACHE_CLUSTER_CACHE_LOCAL ;\n }\n break ;\n case 'r' : if ( ! strncmp ( name , \"proxy.config.http.cache.heuristic_lm_factor\" , length ) ) {\n typ = TS_RECORDDATATYPE_FLOAT ;\n cnf = TS_CONFIG_HTTP_CACHE_HEURISTIC_LM_FACTOR ;\n }\n break ;\n }\n break ;\n case 44 : switch ( name [ length - 1 ] ) {\n case 'p' : if ( ! strncmp ( name , \"proxy.config.http.anonymize_remove_client_ip\" , length ) ) {\n cnf = TS_CONFIG_HTTP_ANONYMIZE_REMOVE_CLIENT_IP ;\n }\n break ;\n case 'e' : if ( ! strncmp ( name , \"proxy.config.http.cache.open_read_retry_time\" , length ) ) {\n cnf = TS_CONFIG_HTTP_CACHE_OPEN_READ_RETRY_TIME ;\n }\n break ;\n }\n break ;\n case 45 : switch ( name [ length - 1 ] ) {\n case 'd' : if ( ! strncmp ( name , \"proxy.config.http.down_server.abort_threshold\" , length ) ) {\n cnf = TS_CONFIG_HTTP_DOWN_SERVER_ABORT_THRESHOLD ;\n }\n else if ( ! strncmp ( name , \"proxy.config.http.parent_proxy.fail_threshold\" , length ) ) {\n cnf = TS_CONFIG_HTTP_PARENT_PROXY_FAIL_THRESHOLD ;\n }\n break ;\n case 'n' : if ( ! strncmp ( name , \"proxy.config.http.cache.ignore_authentication\" , length ) ) {\n cnf = TS_CONFIG_HTTP_CACHE_IGNORE_AUTHENTICATION ;\n }\n break ;\n case 't' : if ( ! strncmp ( name , \"proxy.config.http.anonymize_remove_user_agent\" , length ) ) {\n cnf = TS_CONFIG_HTTP_ANONYMIZE_REMOVE_USER_AGENT ;\n }\n break ;\n case 's' : if ( ! strncmp ( name , \"proxy.config.http.connect_attempts_rr_retries\" , length ) ) {\n cnf = TS_CONFIG_HTTP_CONNECT_ATTEMPTS_RR_RETRIES ;\n }\n else if ( ! strncmp ( name , \"proxy.config.http.cache.max_open_read_retries\" , length ) ) {\n cnf = TS_CONFIG_HTTP_CACHE_MAX_OPEN_READ_RETRIES ;\n }\n break ;\n case 'e' : if ( 0 == strncmp ( name , \"proxy.config.http.auth_server_session_private\" , length ) ) {\n cnf = TS_CONFIG_HTTP_AUTH_SERVER_SESSION_PRIVATE ;\n }\n break ;\n case 'y' : if ( ! strncmp ( name , \"proxy.config.http.redirect_use_orig_cache_key\" , length ) ) {\n cnf = TS_CONFIG_HTTP_REDIRECT_USE_ORIG_CACHE_KEY ;\n }\n break ;\n }\n break ;\n case 46 : switch ( name [ length - 1 ] ) {\n case 'e' : if ( ! strncmp ( name , \"proxy.config.http.cache.ignore_client_no_cache\" , length ) ) {\n cnf = TS_CONFIG_HTTP_CACHE_IGNORE_CLIENT_NO_CACHE ;\n }\n else if ( ! strncmp ( name , \"proxy.config.http.cache.ims_on_client_no_cache\" , length ) ) {\n cnf = TS_CONFIG_HTTP_CACHE_IMS_ON_CLIENT_NO_CACHE ;\n }\n else if ( ! strncmp ( name , \"proxy.config.http.cache.ignore_server_no_cache\" , length ) ) {\n cnf = TS_CONFIG_HTTP_CACHE_IGNORE_SERVER_NO_CACHE ;\n }\n else if ( ! strncmp ( name , \"proxy.config.http.cache.heuristic_min_lifetime\" , length ) ) {\n cnf = TS_CONFIG_HTTP_CACHE_HEURISTIC_MIN_LIFETIME ;\n }\n else if ( ! strncmp ( name , \"proxy.config.http.cache.heuristic_max_lifetime\" , length ) ) {\n cnf = TS_CONFIG_HTTP_CACHE_HEURISTIC_MAX_LIFETIME ;\n }\n else if ( ! strncmp ( name , \"proxy.config.http.origin_max_connections_queue\" , length ) ) {\n cnf = TS_CONFIG_HTTP_ORIGIN_MAX_CONNECTIONS_QUEUE ;\n }\n break ;\n case 'r' : if ( ! strncmp ( name , \"proxy.config.http.insert_squid_x_forwarded_for\" , length ) ) {\n cnf = TS_CONFIG_HTTP_INSERT_SQUID_X_FORWARDED_FOR ;\n }\n break ;\n case 's' : if ( ! strncmp ( name , \"proxy.config.http.connect_attempts_max_retries\" , length ) ) {\n cnf = TS_CONFIG_HTTP_CONNECT_ATTEMPTS_MAX_RETRIES ;\n }\n else if ( ! strncmp ( name , \"proxy.config.http.cache.max_open_write_retries\" , length ) ) {\n cnf = TS_CONFIG_HTTP_CACHE_MAX_OPEN_WRITE_RETRIES ;\n }\n break ;\n case 't' : if ( ! strncmp ( name , \"proxy.config.http.forward.proxy_auth_to_parent\" , length ) ) {\n cnf = TS_CONFIG_HTTP_FORWARD_PROXY_AUTH_TO_PARENT ;\n }\n break ;\n case 'h' : if ( 0 == strncmp ( name , \"proxy.config.http.server_session_sharing.match\" , length ) ) {\n cnf = TS_CONFIG_HTTP_SERVER_SESSION_SHARING_MATCH ;\n }\n break ;\n case 'n' : if ( ! strncmp ( name , \"proxy.config.http.cache.open_write_fail_action\" , length ) ) {\n cnf = TS_CONFIG_HTTP_CACHE_OPEN_WRITE_FAIL_ACTION ;\n }\n break ;\n }\n break ;\n case 47 : switch ( name [ length - 1 ] ) {\n case 'b' : if ( ! strncmp ( name , \"proxy.config.http.parent_proxy.mark_down_hostdb\" , length ) ) {\n cnf = TS_CONFIG_PARENT_FAILURES_UPDATE_HOSTDB ;\n }\n break ;\n case 'd' : if ( ! strncmp ( name , \"proxy.config.http.negative_revalidating_enabled\" , length ) ) {\n cnf = TS_CONFIG_HTTP_NEGATIVE_REVALIDATING_ENABLED ;\n }\n break ;\n case 'e' : if ( ! strncmp ( name , \"proxy.config.http.cache.guaranteed_min_lifetime\" , length ) ) {\n cnf = TS_CONFIG_HTTP_CACHE_GUARANTEED_MIN_LIFETIME ;\n }\n else if ( ! strncmp ( name , \"proxy.config.http.cache.guaranteed_max_lifetime\" , length ) ) {\n cnf = TS_CONFIG_HTTP_CACHE_GUARANTEED_MAX_LIFETIME ;\n }\n break ;\n case 'n' : if ( ! strncmp ( name , \"proxy.config.http.transaction_active_timeout_in\" , length ) ) {\n cnf = TS_CONFIG_HTTP_TRANSACTION_ACTIVE_TIMEOUT_IN ;\n }\n break ;\n case 't' : if ( ! strncmp ( name , \"proxy.config.http.post_connect_attempts_timeout\" , length ) ) {\n cnf = TS_CONFIG_HTTP_POST_CONNECT_ATTEMPTS_TIMEOUT ;\n }\n break ;\n }\n break ;\n case 48 : switch ( name [ length - 1 ] ) {\n case 'e' : if ( ! strncmp ( name , \"proxy.config.http.cache.ignore_client_cc_max_age\" , length ) ) {\n cnf = TS_CONFIG_HTTP_CACHE_IGNORE_CLIENT_CC_MAX_AGE ;\n }\n else if ( ! strncmp ( name , \"proxy.config.http.negative_revalidating_lifetime\" , length ) ) {\n cnf = TS_CONFIG_HTTP_NEGATIVE_REVALIDATING_LIFETIME ;\n }\n break ;\n case 't' : switch ( name [ length - 4 ] ) {\n case '_' : if ( ! strncmp ( name , \"proxy.config.http.transaction_active_timeout_out\" , length ) ) {\n cnf = TS_CONFIG_HTTP_TRANSACTION_ACTIVE_TIMEOUT_OUT ;\n }\n break ;\n case 'e' : if ( ! strncmp ( name , \"proxy.config.http.background_fill_active_timeout\" , length ) ) {\n cnf = TS_CONFIG_HTTP_BACKGROUND_FILL_ACTIVE_TIMEOUT ;\n }\n break ;\n }\n break ;\n }\n break ;\n case 49 : if ( ! strncmp ( name , \"proxy.config.http.attach_server_session_to_client\" , length ) ) {\n cnf = TS_CONFIG_HTTP_ATTACH_SERVER_SESSION_TO_CLIENT ;\n }\n break ;\n case 50 : if ( ! strncmp ( name , \"proxy.config.http.cache.cache_responses_to_cookies\" , length ) ) {\n cnf = TS_CONFIG_HTTP_CACHE_CACHE_RESPONSES_TO_COOKIES ;\n }\n break ;\n case 51 : switch ( name [ length - 1 ] ) {\n case 'n' : if ( ! strncmp ( name , \"proxy.config.http.keep_alive_no_activity_timeout_in\" , length ) ) {\n cnf = TS_CONFIG_HTTP_KEEP_ALIVE_NO_ACTIVITY_TIMEOUT_IN ;\n }\n break ;\n case 'd' : if ( ! strncmp ( name , \"proxy.config.http.post.check.content_length.enabled\" , length ) ) {\n cnf = TS_CONFIG_HTTP_POST_CHECK_CONTENT_LENGTH_ENABLED ;\n }\n break ;\n }\n break ;\n case 52 : switch ( name [ length - 1 ] ) {\n case 'c' : if ( ! strncmp ( name , \"proxy.config.http.cache.cache_urls_that_look_dynamic\" , length ) ) {\n cnf = TS_CONFIG_HTTP_CACHE_CACHE_URLS_THAT_LOOK_DYNAMIC ;\n }\n break ;\n case 'n' : if ( ! strncmp ( name , \"proxy.config.http.transaction_no_activity_timeout_in\" , length ) ) {\n cnf = TS_CONFIG_HTTP_TRANSACTION_NO_ACTIVITY_TIMEOUT_IN ;\n }\n break ;\n case 't' : if ( ! strncmp ( name , \"proxy.config.http.keep_alive_no_activity_timeout_out\" , length ) ) {\n cnf = TS_CONFIG_HTTP_KEEP_ALIVE_NO_ACTIVITY_TIMEOUT_OUT ;\n }\n else if ( ! strncmp ( name , \"proxy.config.http.uncacheable_requests_bypass_parent\" , length ) ) {\n cnf = TS_CONFIG_HTTP_UNCACHEABLE_REQUESTS_BYPASS_PARENT ;\n }\n break ;\n }\n break ;\n case 53 : switch ( name [ length - 1 ] ) {\n case 't' : if ( ! strncmp ( name , \"proxy.config.http.transaction_no_activity_timeout_out\" , length ) ) {\n cnf = TS_CONFIG_HTTP_TRANSACTION_NO_ACTIVITY_TIMEOUT_OUT ;\n }\n break ;\n case 'd' : if ( ! strncmp ( name , \"proxy.config.http.background_fill_completed_threshold\" , length ) ) {\n typ = TS_RECORDDATATYPE_FLOAT ;\n cnf = TS_CONFIG_HTTP_BACKGROUND_FILL_COMPLETED_THRESHOLD ;\n }\n break ;\n case 's' : if ( ! strncmp ( name , \"proxy.config.http.parent_proxy.total_connect_attempts\" , length ) ) {\n cnf = TS_CONFIG_HTTP_PARENT_PROXY_TOTAL_CONNECT_ATTEMPTS ;\n }\n break ;\n }\n break ;\n case 55 : if ( ! strncmp ( name , \"proxy.config.http.parent_proxy.connect_attempts_timeout\" , length ) ) {\n cnf = TS_CONFIG_HTTP_PARENT_CONNECT_ATTEMPT_TIMEOUT ;\n }\n break ;\n case 58 : if ( ! strncmp ( name , \"proxy.config.http.connect_attempts_max_retries_dead_server\" , length ) ) {\n cnf = TS_CONFIG_HTTP_CONNECT_ATTEMPTS_MAX_RETRIES_DEAD_SERVER ;\n }\n else if ( ! strncmp ( name , \"proxy.config.http.parent_proxy.per_parent_connect_attempts\" , length ) ) {\n cnf = TS_CONFIG_HTTP_PER_PARENT_CONNECT_ATTEMPTS ;\n }\n break ;\n }\n * conf = cnf ;\n if ( type ) {\n * type = typ ;\n }\n return ( ( cnf != TS_CONFIG_NULL ) ? TS_SUCCESS : TS_ERROR ) ;\n }", "idx": 21370}
{"hash": 4180964683905830761, "project": "debian", "size": 5, "label": 0, "functionSource": "static int selinux_binder_set_context_mgr ( struct task_struct * mgr ) {\n u32 mysid = current_sid ( ) ;\n u32 mgrsid = task_sid ( mgr ) ;\n return avc_has_perm ( mysid , mgrsid , SECCLASS_BINDER , BINDER__SET_CONTEXT_MGR , NULL ) ;\n }", "idx": 21371}
{"hash": -4032982860280343776, "project": "chrome", "size": 25, "label": 0, "functionSource": "static int getDynamicOffset ( uint32_t c , uint32_t * pOffset ) {\n int i ;\n for ( i = 0 ;\n i < 7 ;\n ++ i ) {\n if ( ( uint32_t ) ( c - fixedOffsets [ i ] ) <= 0x7f ) {\n * pOffset = fixedOffsets [ i ] ;\n return 0xf9 + i ;\n }\n }\n if ( c < 0x80 ) {\n return - 1 ;\n }\n else if ( c < 0x3400 || ( uint32_t ) ( c - 0x10000 ) < ( 0x14000 - 0x10000 ) || ( uint32_t ) ( c - 0x1d000 ) <= ( 0x1ffff - 0x1d000 ) ) {\n * pOffset = c & 0x7fffff80 ;\n return ( int ) ( c >> 7 ) ;\n }\n else if ( 0xe000 <= c && c != 0xfeff && c < 0xfff0 ) {\n * pOffset = c & 0x7fffff80 ;\n return ( int ) ( ( c - gapOffset ) >> 7 ) ;\n }\n else {\n return - 1 ;\n }\n }", "idx": 21372}
{"hash": 1414661670117003749, "project": "debian", "size": 20, "label": 0, "functionSource": "static int rebuild_bitmap ( uint32_t * reposition , struct ewah_bitmap * source , struct bitmap * dest ) {\n uint32_t pos = 0 ;\n struct ewah_iterator it ;\n eword_t word ;\n ewah_iterator_init ( & it , source ) ;\n while ( ewah_iterator_next ( & word , & it ) ) {\n uint32_t offset , bit_pos ;\n for ( offset = 0 ;\n offset < BITS_IN_EWORD ;\n ++ offset ) {\n if ( ( word >> offset ) == 0 ) break ;\n offset += ewah_bit_ctz64 ( word >> offset ) ;\n bit_pos = reposition [ pos + offset ] ;\n if ( bit_pos > 0 ) bitmap_set ( dest , bit_pos - 1 ) ;\n else return - 1 ;\n }\n pos += BITS_IN_EWORD ;\n }\n return 0 ;\n }", "idx": 21373}
{"hash": -8704283573519790151, "project": "debian", "size": 11, "label": 0, "functionSource": "ber_slen_t ber_read ( BerElement * ber , char * buf , ber_len_t len ) {\n ber_len_t actuallen , nleft ;\n assert ( ber != NULL ) ;\n assert ( buf != NULL ) ;\n assert ( LBER_VALID ( ber ) ) ;\n nleft = ber_pvt_ber_remaining ( ber ) ;\n actuallen = nleft < len ? nleft : len ;\n AC_MEMCPY ( buf , ber -> ber_ptr , actuallen ) ;\n ber -> ber_ptr += actuallen ;\n return ( ( ber_slen_t ) actuallen ) ;\n }", "idx": 21374}
{"hash": -7237039260294671485, "project": "debian", "size": 5, "label": 0, "functionSource": "static gint nlm_msg_res_matched_equal ( gconstpointer k1 , gconstpointer k2 ) {\n guint mk1 = GPOINTER_TO_UINT ( k1 ) ;\n guint mk2 = GPOINTER_TO_UINT ( k2 ) ;\n return ( mk1 == mk2 ) ;\n }", "idx": 21375}
{"hash": 8572106347813672436, "project": "debian", "size": 23, "label": 0, "functionSource": "static int pfkey_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) {\n struct sock * sk = sock -> sk ;\n struct sk_buff * skb = NULL ;\n struct sadb_msg * hdr = NULL ;\n int err ;\n err = - EOPNOTSUPP ;\n if ( msg -> msg_flags & MSG_OOB ) goto out ;\n err = - EMSGSIZE ;\n if ( ( unsigned int ) len > sk -> sk_sndbuf - 32 ) goto out ;\n err = - ENOBUFS ;\n skb = alloc_skb ( len , GFP_KERNEL ) ;\n if ( skb == NULL ) goto out ;\n err = - EFAULT ;\n if ( memcpy_fromiovec ( skb_put ( skb , len ) , msg -> msg_iov , len ) ) goto out ;\n hdr = pfkey_get_base_msg ( skb , & err ) ;\n if ( ! hdr ) goto out ;\n mutex_lock ( & xfrm_cfg_mutex ) ;\n err = pfkey_process ( sk , skb , hdr ) ;\n mutex_unlock ( & xfrm_cfg_mutex ) ;\n out : if ( err && hdr && pfkey_error ( hdr , err , sk ) == 0 ) err = 0 ;\n kfree_skb ( skb ) ;\n return err ? : len ;\n }", "idx": 21376}
{"hash": 6323824267898511453, "project": "debian", "size": 3, "label": 0, "functionSource": "int fz_colorspace_is_rgb ( fz_context * ctx , const fz_colorspace * cs ) {\n return cs && cs -> type == FZ_COLORSPACE_RGB ;\n }", "idx": 21377}
{"hash": 6323824267898511453, "project": "debian", "size": 8, "label": 0, "functionSource": "fz_colorspace * fz_new_icc_colorspace_from_file ( fz_context * ctx , const char * name , const char * path ) {\n fz_colorspace * cs = NULL ;\n fz_buffer * buffer = fz_read_file ( ctx , path ) ;\n fz_try ( ctx ) cs = fz_new_icc_colorspace ( ctx , name , 0 , buffer ) ;\n fz_always ( ctx ) fz_drop_buffer ( ctx , buffer ) ;\n fz_catch ( ctx ) fz_rethrow ( ctx ) ;\n return cs ;\n }", "idx": 21378}
{"hash": 7320640583188908680, "project": "debian", "size": 27, "label": 0, "functionSource": "static int remoteStreamFilter ( struct qemud_client * client , struct qemud_client_message * msg , void * opaque ) {\n struct qemud_client_stream * stream = opaque ;\n if ( msg -> hdr . serial == stream -> serial && msg -> hdr . proc == stream -> procedure && msg -> hdr . type == REMOTE_STREAM ) {\n VIR_DEBUG ( \"Incoming rx=%p serial=%d proc=%d status=%d\" , stream -> rx , msg -> hdr . proc , msg -> hdr . serial , msg -> hdr . status ) ;\n if ( stream -> rx ) {\n qemudClientMessageQueuePush ( & stream -> rx , msg ) ;\n remoteStreamUpdateEvents ( stream ) ;\n }\n else {\n int ret = 0 ;\n switch ( msg -> hdr . status ) {\n case REMOTE_OK : ret = remoteStreamHandleFinish ( client , stream , msg ) ;\n if ( ret == 0 ) qemudClientMessageRelease ( client , msg ) ;\n break ;\n case REMOTE_CONTINUE : qemudClientMessageQueuePush ( & stream -> rx , msg ) ;\n remoteStreamUpdateEvents ( stream ) ;\n break ;\n case REMOTE_ERROR : default : ret = remoteStreamHandleAbort ( client , stream , msg ) ;\n if ( ret == 0 ) qemudClientMessageRelease ( client , msg ) ;\n break ;\n }\n if ( ret < 0 ) return - 1 ;\n }\n return 1 ;\n }\n return 0 ;\n }", "idx": 21379}
{"hash": -2423144171479606949, "project": "debian", "size": 4, "label": 0, "functionSource": "static void pdf_run_sh ( fz_context * ctx , pdf_processor * proc , const char * name , fz_shade * shade ) {\n pdf_run_processor * pr = ( pdf_run_processor * ) proc ;\n pdf_show_shade ( ctx , pr , shade ) ;\n }", "idx": 21380}
{"hash": 3584320764213684062, "project": "debian", "size": 20, "label": 0, "functionSource": "static int parse_CInGroupSortAggregSet ( tvbuff_t * tvb , packet_info * pinfo , int offset , proto_tree * parent_tree , proto_tree * pad_tree , const char * fmt , ... ) {\n proto_item * item ;\n proto_tree * tree ;\n va_list ap ;\n enum CInGroupSortAggregSet_type type ;\n const char * txt ;\n va_start ( ap , fmt ) ;\n txt = wmem_strdup_vprintf ( wmem_packet_scope ( ) , fmt , ap ) ;\n va_end ( ap ) ;\n tree = proto_tree_add_subtree ( parent_tree , tvb , offset , 0 , ett_CInGroupSortAggregSet , & item , txt ) ;\n offset = parse_CInGroupSortAggregSet_type ( tvb , offset , tree , & type ) ;\n offset = parse_padding ( tvb , offset , 4 , pad_tree , \"CInGroupSortAggregSet\" ) ;\n if ( type == GroupIdValue ) {\n struct CBaseStorageVariant id ;\n offset = parse_CBaseStorageVariant ( tvb , pinfo , offset , tree , pad_tree , & id , \"inGroupId\" ) ;\n }\n offset = parse_CSortSet ( tvb , offset , tree , pad_tree , \"SortSet\" ) ;\n proto_item_set_end ( item , tvb , offset ) ;\n return offset ;\n }", "idx": 21381}
{"hash": 5838244232542871853, "project": "chrome", "size": 15, "label": 0, "functionSource": "TEST_F ( ScoredHistoryMatchTest , ScoringTLD ) {\n base : : Time now = base : : Time : : NowFromSystemTime ( ) ;\n std : : string url_string ( \"http://fedcba.com/\" ) ;\n const GURL url ( url_string ) ;\n history : : URLRow row ( MakeURLRow ( url_string . c_str ( ) , \"\" , 8 , 3 , 1 ) ) ;\n RowWordStarts word_starts ;\n PopulateWordStarts ( row , & word_starts ) ;\n WordStarts two_words_no_offsets ( 2 , 0u ) ;\n VisitInfoVector visits = CreateVisitInfoVector ( 8 , 3 , now ) ;\n ScoredHistoryMatch scored ( row , visits , ASCIIToUTF16 ( \"fed com\" ) , Make2Terms ( \"fed\" , \"com\" ) , two_words_no_offsets , word_starts , false , nullptr , now ) ;\n EXPECT_EQ ( 0 , scored . raw_score ) ;\n base : : AutoReset < bool > reset ( & ScoredHistoryMatch : : allow_tld_matches_ , true ) ;\n ScoredHistoryMatch scored_with_tld ( row , visits , ASCIIToUTF16 ( \"fed com\" ) , Make2Terms ( \"fed\" , \"com\" ) , two_words_no_offsets , word_starts , false , nullptr , now ) ;\n EXPECT_GT ( scored_with_tld . raw_score , 0 ) ;\n }", "idx": 21382}
{"hash": 6250095321513210169, "project": "debian", "size": 52, "label": 0, "functionSource": "void rfbClientConnectionGone ( rfbClientPtr cl ) {\n # if defined ( LIBVNCSERVER_HAVE_LIBZ ) && defined ( LIBVNCSERVER_HAVE_LIBJPEG ) int i ;\n # endif LOCK ( rfbClientListMutex ) ;\n if ( cl -> prev ) cl -> prev -> next = cl -> next ;\n else cl -> screen -> clientHead = cl -> next ;\n if ( cl -> next ) cl -> next -> prev = cl -> prev ;\n UNLOCK ( rfbClientListMutex ) ;\n # ifdef LIBVNCSERVER_HAVE_LIBPTHREAD if ( cl -> screen -> backgroundLoop != FALSE ) {\n int i ;\n do {\n LOCK ( cl -> refCountMutex ) ;\n i = cl -> refCount ;\n if ( i > 0 ) WAIT ( cl -> deleteCond , cl -> refCountMutex ) ;\n UNLOCK ( cl -> refCountMutex ) ;\n }\n while ( i > 0 ) ;\n }\n # endif if ( cl -> sock >= 0 ) close ( cl -> sock ) ;\n if ( cl -> scaledScreen != NULL ) cl -> scaledScreen -> scaledScreenRefCount -- ;\n # ifdef LIBVNCSERVER_HAVE_LIBZ rfbFreeZrleData ( cl ) ;\n # endif rfbFreeUltraData ( cl ) ;\n free ( cl -> beforeEncBuf ) ;\n free ( cl -> afterEncBuf ) ;\n if ( cl -> sock >= 0 ) FD_CLR ( cl -> sock , & ( cl -> screen -> allFds ) ) ;\n cl -> clientGoneHook ( cl ) ;\n rfbLog ( \"Client %s gone\\n\" , cl -> host ) ;\n free ( cl -> host ) ;\n # ifdef LIBVNCSERVER_HAVE_LIBZ if ( cl -> compStreamInited ) {\n deflateEnd ( & ( cl -> compStream ) ) ;\n }\n # ifdef LIBVNCSERVER_HAVE_LIBJPEG for ( i = 0 ;\n i < 4 ;\n i ++ ) {\n if ( cl -> zsActive [ i ] ) deflateEnd ( & cl -> zsStruct [ i ] ) ;\n }\n # endif # endif if ( cl -> screen -> pointerClient == cl ) cl -> screen -> pointerClient = NULL ;\n sraRgnDestroy ( cl -> modifiedRegion ) ;\n sraRgnDestroy ( cl -> requestedRegion ) ;\n sraRgnDestroy ( cl -> copyRegion ) ;\n if ( cl -> translateLookupTable ) free ( cl -> translateLookupTable ) ;\n TINI_COND ( cl -> updateCond ) ;\n TINI_MUTEX ( cl -> updateMutex ) ;\n LOCK ( cl -> outputMutex ) ;\n UNLOCK ( cl -> outputMutex ) ;\n TINI_MUTEX ( cl -> outputMutex ) ;\n LOCK ( cl -> sendMutex ) ;\n UNLOCK ( cl -> sendMutex ) ;\n TINI_MUTEX ( cl -> sendMutex ) ;\n rfbPrintStats ( cl ) ;\n rfbResetStats ( cl ) ;\n free ( cl ) ;\n }", "idx": 21383}
{"hash": -5697857125570093892, "project": "chrome", "size": 12, "label": 0, "functionSource": "static int32_t ultag_getExtensionsSize ( const ULanguageTag * langtag ) {\n int32_t size = 0 ;\n ExtensionListEntry * cur = langtag -> extensions ;\n while ( TRUE ) {\n if ( cur == NULL ) {\n break ;\n }\n size ++ ;\n cur = cur -> next ;\n }\n return size ;\n }", "idx": 21384}
{"hash": -4552633429382740307, "project": "debian", "size": 24, "label": 0, "functionSource": "void # ifdef M_DEBUG mpi_debug_free_limb_space ( mpi_ptr_t a , const char * info ) # else mpi_free_limb_space ( mpi_ptr_t a ) # endif {\n if ( ! a ) return ;\n if ( DBG_MEMORY ) log_debug ( \"mpi_free_limb_space of size %lu\\n\" , ( ulong ) m_size ( a ) * 8 ) ;\n # if 0 if ( ! m_is_secure ( a ) ) {\n size_t nlimbs = m_size ( a ) / 4 ;\n void * p = a ;\n if ( nlimbs == 5 ) {\n * a = unused_limbs_5 ;\n unused_limbs_5 = a ;\n return ;\n }\n else if ( nlimbs == 32 ) {\n * a = unused_limbs_32 ;\n unused_limbs_32 = a ;\n return ;\n }\n else if ( nlimbs == 64 ) {\n * a = unused_limbs_64 ;\n unused_limbs_64 = a ;\n return ;\n }\n }\n # endif xfree ( a ) ;\n }", "idx": 21385}
{"hash": -1315695702746584250, "project": "debian", "size": 3, "label": 0, "functionSource": "static void proto_tree_set_ax25_tvb ( field_info * fi , tvbuff_t * tvb , gint start ) {\n proto_tree_set_ax25 ( fi , tvb_get_ptr ( tvb , start , 7 ) ) ;\n }", "idx": 21386}
{"hash": -1055531103257174901, "project": "debian", "size": 13, "label": 0, "functionSource": "static void sig_complete_away ( GList * * list , WINDOW_REC * window , const char * word , const char * line , int * want_space ) {\n const char * reason ;\n g_return_if_fail ( list != NULL ) ;\n g_return_if_fail ( word != NULL ) ;\n * want_space = FALSE ;\n if ( * word == '\\0' && window -> active_server != NULL ) {\n reason = SERVER ( window -> active_server ) -> away_reason ;\n if ( reason != NULL ) {\n * list = g_list_append ( NULL , g_strdup ( reason ) ) ;\n signal_stop ( ) ;\n }\n }\n }", "idx": 21387}
{"hash": -3502382902740740634, "project": "debian", "size": 19, "label": 0, "functionSource": "static const char * integer64_avp ( diam_ctx_t * c , diam_avp_t * a , tvbuff_t * tvb , diam_sub_dis_t * diam_sub_dis_inf _U_ ) {\n char * label = NULL ;\n proto_item * pi ;\n gint length = tvb_reported_length ( tvb ) ;\n if ( length == 8 ) {\n if ( c -> tree ) {\n pi = proto_tree_add_item ( c -> tree , a -> hf_value , tvb , 0 , length , ENC_BIG_ENDIAN ) ;\n label = ( char * ) wmem_alloc ( wmem_packet_scope ( ) , ITEM_LABEL_LENGTH + 1 ) ;\n proto_item_fill_label ( PITEM_FINFO ( pi ) , label ) ;\n label = strstr ( label , \": \" ) + 2 ;\n }\n }\n else {\n pi = proto_tree_add_bytes_format ( c -> tree , hf_diameter_avp_data_wrong_length , tvb , 0 , length , NULL , \"Error! Bad Integer64 Length\" ) ;\n expert_add_info_format ( c -> pinfo , pi , & ei_diameter_avp_len , \"Bad Integer64 Length (%u)\" , length ) ;\n PROTO_ITEM_SET_GENERATED ( pi ) ;\n }\n return label ;\n }", "idx": 21388}
{"hash": -7555034601056330007, "project": "debian", "size": 3, "label": 0, "functionSource": "static int virLogSetDefaultOutputToStderr ( void ) {\n return virAsprintf ( & virLogDefaultOutput , \"%d:stderr\" , virLogDefaultPriority ) ;\n }", "idx": 21389}
{"hash": 378220832151730865, "project": "debian", "size": 9, "label": 0, "functionSource": "int qemuMonitorTextSystemPowerdown ( qemuMonitorPtr mon ) {\n char * info ;\n if ( qemuMonitorHMPCommand ( mon , \"system_powerdown\" , & info ) < 0 ) {\n qemuReportError ( VIR_ERR_OPERATION_FAILED , \"%s\" , _ ( \"system shutdown operation failed\" ) ) ;\n return - 1 ;\n }\n VIR_FREE ( info ) ;\n return 0 ;\n }", "idx": 21390}
{"hash": 4715922168896528064, "project": "debian", "size": 203, "label": 0, "functionSource": "void jpc_ns_invlift_colres ( jpc_fix_t * a , int numrows , int numcols , int stride , int parity ) {\n jpc_fix_t * lptr ;\n jpc_fix_t * hptr ;\n register jpc_fix_t * lptr2 ;\n register jpc_fix_t * hptr2 ;\n register int n ;\n register int i ;\n int llen ;\n llen = ( numrows + 1 - parity ) >> 1 ;\n if ( numrows > 1 ) {\n # if defined ( WT_DOSCALE ) lptr = & a [ 0 ] ;\n n = llen ;\n while ( n -- > 0 ) {\n lptr2 = lptr ;\n for ( i = 0 ;\n i < numcols ;\n ++ i ) {\n lptr2 [ 0 ] = jpc_fix_mul ( lptr2 [ 0 ] , jpc_dbltofix ( 1.0 / LGAIN ) ) ;\n ++ lptr2 ;\n }\n lptr += stride ;\n }\n hptr = & a [ llen * stride ] ;\n n = numrows - llen ;\n while ( n -- > 0 ) {\n hptr2 = hptr ;\n for ( i = 0 ;\n i < numcols ;\n ++ i ) {\n hptr2 [ 0 ] = jpc_fix_mul ( hptr2 [ 0 ] , jpc_dbltofix ( 1.0 / HGAIN ) ) ;\n ++ hptr2 ;\n }\n hptr += stride ;\n }\n # endif lptr = & a [ 0 ] ;\n hptr = & a [ llen * stride ] ;\n if ( ! parity ) {\n lptr2 = lptr ;\n hptr2 = hptr ;\n for ( i = 0 ;\n i < numcols ;\n ++ i ) {\n jpc_fix_minuseq ( lptr2 [ 0 ] , jpc_fix_mul ( jpc_dbltofix ( 2.0 * DELTA ) , hptr2 [ 0 ] ) ) ;\n ++ lptr2 ;\n ++ hptr2 ;\n }\n lptr += stride ;\n }\n n = llen - ( ! parity ) - ( parity != ( numrows & 1 ) ) ;\n while ( n -- > 0 ) {\n lptr2 = lptr ;\n hptr2 = hptr ;\n for ( i = 0 ;\n i < numcols ;\n ++ i ) {\n jpc_fix_minuseq ( lptr2 [ 0 ] , jpc_fix_mul ( jpc_dbltofix ( DELTA ) , jpc_fix_add ( hptr2 [ 0 ] , hptr2 [ stride ] ) ) ) ;\n ++ lptr2 ;\n ++ hptr2 ;\n }\n lptr += stride ;\n hptr += stride ;\n }\n if ( parity != ( numrows & 1 ) ) {\n lptr2 = lptr ;\n hptr2 = hptr ;\n for ( i = 0 ;\n i < numcols ;\n ++ i ) {\n jpc_fix_minuseq ( lptr2 [ 0 ] , jpc_fix_mul ( jpc_dbltofix ( 2.0 * DELTA ) , hptr2 [ 0 ] ) ) ;\n ++ lptr2 ;\n ++ hptr2 ;\n }\n }\n lptr = & a [ 0 ] ;\n hptr = & a [ llen * stride ] ;\n if ( parity ) {\n lptr2 = lptr ;\n hptr2 = hptr ;\n for ( i = 0 ;\n i < numcols ;\n ++ i ) {\n jpc_fix_minuseq ( hptr2 [ 0 ] , jpc_fix_mul ( jpc_dbltofix ( 2.0 * GAMMA ) , lptr2 [ 0 ] ) ) ;\n ++ hptr2 ;\n ++ lptr2 ;\n }\n hptr += stride ;\n }\n n = numrows - llen - parity - ( parity == ( numrows & 1 ) ) ;\n while ( n -- > 0 ) {\n lptr2 = lptr ;\n hptr2 = hptr ;\n for ( i = 0 ;\n i < numcols ;\n ++ i ) {\n jpc_fix_minuseq ( hptr2 [ 0 ] , jpc_fix_mul ( jpc_dbltofix ( GAMMA ) , jpc_fix_add ( lptr2 [ 0 ] , lptr2 [ stride ] ) ) ) ;\n ++ lptr2 ;\n ++ hptr2 ;\n }\n hptr += stride ;\n lptr += stride ;\n }\n if ( parity == ( numrows & 1 ) ) {\n lptr2 = lptr ;\n hptr2 = hptr ;\n for ( i = 0 ;\n i < numcols ;\n ++ i ) {\n jpc_fix_minuseq ( hptr2 [ 0 ] , jpc_fix_mul ( jpc_dbltofix ( 2.0 * GAMMA ) , lptr2 [ 0 ] ) ) ;\n ++ lptr2 ;\n ++ hptr2 ;\n }\n }\n lptr = & a [ 0 ] ;\n hptr = & a [ llen * stride ] ;\n if ( ! parity ) {\n lptr2 = lptr ;\n hptr2 = hptr ;\n for ( i = 0 ;\n i < numcols ;\n ++ i ) {\n jpc_fix_minuseq ( lptr2 [ 0 ] , jpc_fix_mul ( jpc_dbltofix ( 2.0 * BETA ) , hptr2 [ 0 ] ) ) ;\n ++ lptr2 ;\n ++ hptr2 ;\n }\n lptr += stride ;\n }\n n = llen - ( ! parity ) - ( parity != ( numrows & 1 ) ) ;\n while ( n -- > 0 ) {\n lptr2 = lptr ;\n hptr2 = hptr ;\n for ( i = 0 ;\n i < numcols ;\n ++ i ) {\n jpc_fix_minuseq ( lptr2 [ 0 ] , jpc_fix_mul ( jpc_dbltofix ( BETA ) , jpc_fix_add ( hptr2 [ 0 ] , hptr2 [ stride ] ) ) ) ;\n ++ lptr2 ;\n ++ hptr2 ;\n }\n lptr += stride ;\n hptr += stride ;\n }\n if ( parity != ( numrows & 1 ) ) {\n lptr2 = lptr ;\n hptr2 = hptr ;\n for ( i = 0 ;\n i < numcols ;\n ++ i ) {\n jpc_fix_minuseq ( lptr2 [ 0 ] , jpc_fix_mul ( jpc_dbltofix ( 2.0 * BETA ) , hptr2 [ 0 ] ) ) ;\n ++ lptr2 ;\n ++ hptr2 ;\n }\n }\n lptr = & a [ 0 ] ;\n hptr = & a [ llen * stride ] ;\n if ( parity ) {\n lptr2 = lptr ;\n hptr2 = hptr ;\n for ( i = 0 ;\n i < numcols ;\n ++ i ) {\n jpc_fix_minuseq ( hptr2 [ 0 ] , jpc_fix_mul ( jpc_dbltofix ( 2.0 * ALPHA ) , lptr2 [ 0 ] ) ) ;\n ++ hptr2 ;\n ++ lptr2 ;\n }\n hptr += stride ;\n }\n n = numrows - llen - parity - ( parity == ( numrows & 1 ) ) ;\n while ( n -- > 0 ) {\n lptr2 = lptr ;\n hptr2 = hptr ;\n for ( i = 0 ;\n i < numcols ;\n ++ i ) {\n jpc_fix_minuseq ( hptr2 [ 0 ] , jpc_fix_mul ( jpc_dbltofix ( ALPHA ) , jpc_fix_add ( lptr2 [ 0 ] , lptr2 [ stride ] ) ) ) ;\n ++ lptr2 ;\n ++ hptr2 ;\n }\n hptr += stride ;\n lptr += stride ;\n }\n if ( parity == ( numrows & 1 ) ) {\n lptr2 = lptr ;\n hptr2 = hptr ;\n for ( i = 0 ;\n i < numcols ;\n ++ i ) {\n jpc_fix_minuseq ( hptr2 [ 0 ] , jpc_fix_mul ( jpc_dbltofix ( 2.0 * ALPHA ) , lptr2 [ 0 ] ) ) ;\n ++ lptr2 ;\n ++ hptr2 ;\n }\n }\n }\n else {\n # if defined ( WT_LENONE ) if ( parity ) {\n lptr2 = & a [ 0 ] ;\n for ( i = 0 ;\n i < numcols ;\n ++ i ) {\n lptr2 [ 0 ] = jpc_fix_asr ( lptr2 [ 0 ] , 1 ) ;\n ++ lptr2 ;\n }\n }\n # endif }\n }", "idx": 21391}
{"hash": -3053641395158209010, "project": "debian", "size": 14, "label": 0, "functionSource": "static int x ( struct vcache * avc , int afun , struct vrequest * areq , \\ struct afs_pdata * ain , struct afs_pdata * aout , \\ afs_ucred_t * * acred ) DECL_PIOCTL ( PGetFID ) ;\n DECL_PIOCTL ( PSetAcl ) ;\n DECL_PIOCTL ( PStoreBehind ) ;\n DECL_PIOCTL ( PGCPAGs ) ;\n DECL_PIOCTL ( PGetAcl ) ;\n DECL_PIOCTL ( PNoop ) ;\n DECL_PIOCTL ( PBogus ) ;\n DECL_PIOCTL ( PGetFileCell ) ;\n DECL_PIOCTL ( PGetWSCell ) ;\n DECL_PIOCTL ( PGetUserCell ) ;\n DECL_PIOCTL ( PSetTokens ) ;\n DECL_PIOCTL ( PGetVolumeStatus ) ;\n DECL_PIOCTL ( PSetVolumeStatus ) ;\n DECL_PIOCTL ( PFlush )", "idx": 21392}
{"hash": 3192165150896245305, "project": "debian", "size": 101, "label": 1, "functionSource": "void bn_mul_comba8 ( BN_ULONG * r , BN_ULONG * a , BN_ULONG * b ) {\n BN_ULONG t1 , t2 ;\n BN_ULONG c1 , c2 , c3 ;\n c1 = 0 ;\n c2 = 0 ;\n c3 = 0 ;\n mul_add_c ( a [ 0 ] , b [ 0 ] , c1 , c2 , c3 ) ;\n r [ 0 ] = c1 ;\n c1 = 0 ;\n mul_add_c ( a [ 0 ] , b [ 1 ] , c2 , c3 , c1 ) ;\n mul_add_c ( a [ 1 ] , b [ 0 ] , c2 , c3 , c1 ) ;\n r [ 1 ] = c2 ;\n c2 = 0 ;\n mul_add_c ( a [ 2 ] , b [ 0 ] , c3 , c1 , c2 ) ;\n mul_add_c ( a [ 1 ] , b [ 1 ] , c3 , c1 , c2 ) ;\n mul_add_c ( a [ 0 ] , b [ 2 ] , c3 , c1 , c2 ) ;\n r [ 2 ] = c3 ;\n c3 = 0 ;\n mul_add_c ( a [ 0 ] , b [ 3 ] , c1 , c2 , c3 ) ;\n mul_add_c ( a [ 1 ] , b [ 2 ] , c1 , c2 , c3 ) ;\n mul_add_c ( a [ 2 ] , b [ 1 ] , c1 , c2 , c3 ) ;\n mul_add_c ( a [ 3 ] , b [ 0 ] , c1 , c2 , c3 ) ;\n r [ 3 ] = c1 ;\n c1 = 0 ;\n mul_add_c ( a [ 4 ] , b [ 0 ] , c2 , c3 , c1 ) ;\n mul_add_c ( a [ 3 ] , b [ 1 ] , c2 , c3 , c1 ) ;\n mul_add_c ( a [ 2 ] , b [ 2 ] , c2 , c3 , c1 ) ;\n mul_add_c ( a [ 1 ] , b [ 3 ] , c2 , c3 , c1 ) ;\n mul_add_c ( a [ 0 ] , b [ 4 ] , c2 , c3 , c1 ) ;\n r [ 4 ] = c2 ;\n c2 = 0 ;\n mul_add_c ( a [ 0 ] , b [ 5 ] , c3 , c1 , c2 ) ;\n mul_add_c ( a [ 1 ] , b [ 4 ] , c3 , c1 , c2 ) ;\n mul_add_c ( a [ 2 ] , b [ 3 ] , c3 , c1 , c2 ) ;\n mul_add_c ( a [ 3 ] , b [ 2 ] , c3 , c1 , c2 ) ;\n mul_add_c ( a [ 4 ] , b [ 1 ] , c3 , c1 , c2 ) ;\n mul_add_c ( a [ 5 ] , b [ 0 ] , c3 , c1 , c2 ) ;\n r [ 5 ] = c3 ;\n c3 = 0 ;\n mul_add_c ( a [ 6 ] , b [ 0 ] , c1 , c2 , c3 ) ;\n mul_add_c ( a [ 5 ] , b [ 1 ] , c1 , c2 , c3 ) ;\n mul_add_c ( a [ 4 ] , b [ 2 ] , c1 , c2 , c3 ) ;\n mul_add_c ( a [ 3 ] , b [ 3 ] , c1 , c2 , c3 ) ;\n mul_add_c ( a [ 2 ] , b [ 4 ] , c1 , c2 , c3 ) ;\n mul_add_c ( a [ 1 ] , b [ 5 ] , c1 , c2 , c3 ) ;\n mul_add_c ( a [ 0 ] , b [ 6 ] , c1 , c2 , c3 ) ;\n r [ 6 ] = c1 ;\n c1 = 0 ;\n mul_add_c ( a [ 0 ] , b [ 7 ] , c2 , c3 , c1 ) ;\n mul_add_c ( a [ 1 ] , b [ 6 ] , c2 , c3 , c1 ) ;\n mul_add_c ( a [ 2 ] , b [ 5 ] , c2 , c3 , c1 ) ;\n mul_add_c ( a [ 3 ] , b [ 4 ] , c2 , c3 , c1 ) ;\n mul_add_c ( a [ 4 ] , b [ 3 ] , c2 , c3 , c1 ) ;\n mul_add_c ( a [ 5 ] , b [ 2 ] , c2 , c3 , c1 ) ;\n mul_add_c ( a [ 6 ] , b [ 1 ] , c2 , c3 , c1 ) ;\n mul_add_c ( a [ 7 ] , b [ 0 ] , c2 , c3 , c1 ) ;\n r [ 7 ] = c2 ;\n c2 = 0 ;\n mul_add_c ( a [ 7 ] , b [ 1 ] , c3 , c1 , c2 ) ;\n mul_add_c ( a [ 6 ] , b [ 2 ] , c3 , c1 , c2 ) ;\n mul_add_c ( a [ 5 ] , b [ 3 ] , c3 , c1 , c2 ) ;\n mul_add_c ( a [ 4 ] , b [ 4 ] , c3 , c1 , c2 ) ;\n mul_add_c ( a [ 3 ] , b [ 5 ] , c3 , c1 , c2 ) ;\n mul_add_c ( a [ 2 ] , b [ 6 ] , c3 , c1 , c2 ) ;\n mul_add_c ( a [ 1 ] , b [ 7 ] , c3 , c1 , c2 ) ;\n r [ 8 ] = c3 ;\n c3 = 0 ;\n mul_add_c ( a [ 2 ] , b [ 7 ] , c1 , c2 , c3 ) ;\n mul_add_c ( a [ 3 ] , b [ 6 ] , c1 , c2 , c3 ) ;\n mul_add_c ( a [ 4 ] , b [ 5 ] , c1 , c2 , c3 ) ;\n mul_add_c ( a [ 5 ] , b [ 4 ] , c1 , c2 , c3 ) ;\n mul_add_c ( a [ 6 ] , b [ 3 ] , c1 , c2 , c3 ) ;\n mul_add_c ( a [ 7 ] , b [ 2 ] , c1 , c2 , c3 ) ;\n r [ 9 ] = c1 ;\n c1 = 0 ;\n mul_add_c ( a [ 7 ] , b [ 3 ] , c2 , c3 , c1 ) ;\n mul_add_c ( a [ 6 ] , b [ 4 ] , c2 , c3 , c1 ) ;\n mul_add_c ( a [ 5 ] , b [ 5 ] , c2 , c3 , c1 ) ;\n mul_add_c ( a [ 4 ] , b [ 6 ] , c2 , c3 , c1 ) ;\n mul_add_c ( a [ 3 ] , b [ 7 ] , c2 , c3 , c1 ) ;\n r [ 10 ] = c2 ;\n c2 = 0 ;\n mul_add_c ( a [ 4 ] , b [ 7 ] , c3 , c1 , c2 ) ;\n mul_add_c ( a [ 5 ] , b [ 6 ] , c3 , c1 , c2 ) ;\n mul_add_c ( a [ 6 ] , b [ 5 ] , c3 , c1 , c2 ) ;\n mul_add_c ( a [ 7 ] , b [ 4 ] , c3 , c1 , c2 ) ;\n r [ 11 ] = c3 ;\n c3 = 0 ;\n mul_add_c ( a [ 7 ] , b [ 5 ] , c1 , c2 , c3 ) ;\n mul_add_c ( a [ 6 ] , b [ 6 ] , c1 , c2 , c3 ) ;\n mul_add_c ( a [ 5 ] , b [ 7 ] , c1 , c2 , c3 ) ;\n r [ 12 ] = c1 ;\n c1 = 0 ;\n mul_add_c ( a [ 6 ] , b [ 7 ] , c2 , c3 , c1 ) ;\n mul_add_c ( a [ 7 ] , b [ 6 ] , c2 , c3 , c1 ) ;\n r [ 13 ] = c2 ;\n c2 = 0 ;\n mul_add_c ( a [ 7 ] , b [ 7 ] , c3 , c1 , c2 ) ;\n r [ 14 ] = c3 ;\n r [ 15 ] = c1 ;\n }", "idx": 21393}
{"hash": 2578089348587614328, "project": "debian", "size": 3, "label": 0, "functionSource": "int X509_NAME_digest ( const X509_NAME * data , const EVP_MD * type , unsigned char * md , unsigned int * len ) {\n return ( ASN1_item_digest ( ASN1_ITEM_rptr ( X509_NAME ) , type , ( char * ) data , md , len ) ) ;\n }", "idx": 21394}
{"hash": 594127775011357110, "project": "debian", "size": 94, "label": 0, "functionSource": "static void ImportBlueQuantum ( const Image * image , QuantumInfo * quantum_info , const MagickSizeType number_pixels , const unsigned char * magick_restrict p , Quantum * magick_restrict q , ExceptionInfo * exception ) {\n QuantumAny range ;\n register ssize_t x ;\n unsigned int pixel ;\n assert ( image != ( Image * ) NULL ) ;\n assert ( image -> signature == MagickCoreSignature ) ;\n switch ( quantum_info -> depth ) {\n case 8 : {\n unsigned char pixel ;\n for ( x = 0 ;\n x < ( ssize_t ) number_pixels ;\n x ++ ) {\n p = PushCharPixel ( p , & pixel ) ;\n SetPixelBlue ( image , ScaleCharToQuantum ( pixel ) , q ) ;\n p += quantum_info -> pad ;\n q += GetPixelChannels ( image ) ;\n }\n break ;\n }\n case 16 : {\n unsigned short pixel ;\n if ( quantum_info -> format == FloatingPointQuantumFormat ) {\n for ( x = 0 ;\n x < ( ssize_t ) number_pixels ;\n x ++ ) {\n p = PushShortPixel ( quantum_info -> endian , p , & pixel ) ;\n SetPixelBlue ( image , ClampToQuantum ( QuantumRange * HalfToSinglePrecision ( pixel ) ) , q ) ;\n p += quantum_info -> pad ;\n q += GetPixelChannels ( image ) ;\n }\n break ;\n }\n for ( x = 0 ;\n x < ( ssize_t ) number_pixels ;\n x ++ ) {\n p = PushShortPixel ( quantum_info -> endian , p , & pixel ) ;\n SetPixelBlue ( image , ScaleShortToQuantum ( pixel ) , q ) ;\n p += quantum_info -> pad ;\n q += GetPixelChannels ( image ) ;\n }\n break ;\n }\n case 32 : {\n unsigned int pixel ;\n if ( quantum_info -> format == FloatingPointQuantumFormat ) {\n float pixel ;\n for ( x = 0 ;\n x < ( ssize_t ) number_pixels ;\n x ++ ) {\n p = PushFloatPixel ( quantum_info , p , & pixel ) ;\n SetPixelBlue ( image , ClampToQuantum ( pixel ) , q ) ;\n p += quantum_info -> pad ;\n q += GetPixelChannels ( image ) ;\n }\n break ;\n }\n for ( x = 0 ;\n x < ( ssize_t ) number_pixels ;\n x ++ ) {\n p = PushLongPixel ( quantum_info -> endian , p , & pixel ) ;\n SetPixelBlue ( image , ScaleLongToQuantum ( pixel ) , q ) ;\n p += quantum_info -> pad ;\n q += GetPixelChannels ( image ) ;\n }\n break ;\n }\n case 64 : {\n if ( quantum_info -> format == FloatingPointQuantumFormat ) {\n double pixel ;\n for ( x = 0 ;\n x < ( ssize_t ) number_pixels ;\n x ++ ) {\n p = PushDoublePixel ( quantum_info , p , & pixel ) ;\n SetPixelBlue ( image , ClampToQuantum ( pixel ) , q ) ;\n p += quantum_info -> pad ;\n q += GetPixelChannels ( image ) ;\n }\n break ;\n }\n }\n default : {\n range = GetQuantumRange ( quantum_info -> depth ) ;\n for ( x = 0 ;\n x < ( ssize_t ) number_pixels ;\n x ++ ) {\n p = PushQuantumPixel ( quantum_info , p , & pixel ) ;\n SetPixelBlue ( image , ScaleAnyToQuantum ( pixel , range ) , q ) ;\n p += quantum_info -> pad ;\n q += GetPixelChannels ( image ) ;\n }\n break ;\n }\n }\n }", "idx": 21395}
{"hash": 214341372476109918, "project": "debian", "size": 24, "label": 0, "functionSource": "static void copy_clog_xlog_xid ( void ) {\n copy_subdir_files ( \"pg_clog\" ) ;\n prep_status ( \"Setting next transaction ID and epoch for new cluster\" ) ;\n exec_prog ( UTILITY_LOG_FILE , NULL , true , \"\\\"%s/pg_resetxlog\\\" -f -x %u \\\"%s\\\"\" , new_cluster . bindir , old_cluster . controldata . chkpnt_nxtxid , new_cluster . pgdata ) ;\n exec_prog ( UTILITY_LOG_FILE , NULL , true , \"\\\"%s/pg_resetxlog\\\" -f -e %u \\\"%s\\\"\" , new_cluster . bindir , old_cluster . controldata . chkpnt_nxtepoch , new_cluster . pgdata ) ;\n exec_prog ( UTILITY_LOG_FILE , NULL , true , \"\\\"%s/pg_resetxlog\\\" -f -c %u,%u \\\"%s\\\"\" , new_cluster . bindir , old_cluster . controldata . chkpnt_nxtxid , old_cluster . controldata . chkpnt_nxtxid , new_cluster . pgdata ) ;\n check_ok ( ) ;\n if ( old_cluster . controldata . cat_ver >= MULTIXACT_FORMATCHANGE_CAT_VER && new_cluster . controldata . cat_ver >= MULTIXACT_FORMATCHANGE_CAT_VER ) {\n copy_subdir_files ( \"pg_multixact/offsets\" ) ;\n copy_subdir_files ( \"pg_multixact/members\" ) ;\n prep_status ( \"Setting next multixact ID and offset for new cluster\" ) ;\n exec_prog ( UTILITY_LOG_FILE , NULL , true , \"\\\"%s/pg_resetxlog\\\" -O %u -m %u,%u \\\"%s\\\"\" , new_cluster . bindir , old_cluster . controldata . chkpnt_nxtmxoff , old_cluster . controldata . chkpnt_nxtmulti , old_cluster . controldata . chkpnt_oldstMulti , new_cluster . pgdata ) ;\n check_ok ( ) ;\n }\n else if ( new_cluster . controldata . cat_ver >= MULTIXACT_FORMATCHANGE_CAT_VER ) {\n remove_new_subdir ( \"pg_multixact/offsets\" , false ) ;\n prep_status ( \"Setting oldest multixact ID on new cluster\" ) ;\n exec_prog ( UTILITY_LOG_FILE , NULL , true , \"\\\"%s/pg_resetxlog\\\" -m %u,%u \\\"%s\\\"\" , new_cluster . bindir , old_cluster . controldata . chkpnt_nxtmulti + 1 , old_cluster . controldata . chkpnt_nxtmulti , new_cluster . pgdata ) ;\n check_ok ( ) ;\n }\n prep_status ( \"Resetting WAL archives\" ) ;\n exec_prog ( UTILITY_LOG_FILE , NULL , true , \"\\\"%s/pg_resetxlog\\\" -l 00000001%s \\\"%s\\\"\" , new_cluster . bindir , old_cluster . controldata . nextxlogfile + 8 , new_cluster . pgdata ) ;\n check_ok ( ) ;\n }", "idx": 21396}
{"hash": 4206838170759624883, "project": "debian", "size": 53, "label": 0, "functionSource": "static int find_partition ( BlockBackend * blk , int partition , off_t * offset , off_t * size ) {\n struct partition_record mbr [ 4 ] ;\n uint8_t data [ MBR_SIZE ] ;\n int i ;\n int ext_partnum = 4 ;\n int ret ;\n ret = blk_pread ( blk , 0 , data , sizeof ( data ) ) ;\n if ( ret < 0 ) {\n error_report ( \"error while reading: %s\" , strerror ( - ret ) ) ;\n exit ( EXIT_FAILURE ) ;\n }\n if ( data [ 510 ] != 0x55 || data [ 511 ] != 0xaa ) {\n return - EINVAL ;\n }\n for ( i = 0 ;\n i < 4 ;\n i ++ ) {\n read_partition ( & data [ 446 + 16 * i ] , & mbr [ i ] ) ;\n if ( ! mbr [ i ] . system || ! mbr [ i ] . nb_sectors_abs ) {\n continue ;\n }\n if ( mbr [ i ] . system == 0xF || mbr [ i ] . system == 0x5 ) {\n struct partition_record ext [ 4 ] ;\n uint8_t data1 [ MBR_SIZE ] ;\n int j ;\n ret = blk_pread ( blk , mbr [ i ] . start_sector_abs * MBR_SIZE , data1 , sizeof ( data1 ) ) ;\n if ( ret < 0 ) {\n error_report ( \"error while reading: %s\" , strerror ( - ret ) ) ;\n exit ( EXIT_FAILURE ) ;\n }\n for ( j = 0 ;\n j < 4 ;\n j ++ ) {\n read_partition ( & data1 [ 446 + 16 * j ] , & ext [ j ] ) ;\n if ( ! ext [ j ] . system || ! ext [ j ] . nb_sectors_abs ) {\n continue ;\n }\n if ( ( ext_partnum + j + 1 ) == partition ) {\n * offset = ( uint64_t ) ext [ j ] . start_sector_abs << 9 ;\n * size = ( uint64_t ) ext [ j ] . nb_sectors_abs << 9 ;\n return 0 ;\n }\n }\n ext_partnum += 4 ;\n }\n else if ( ( i + 1 ) == partition ) {\n * offset = ( uint64_t ) mbr [ i ] . start_sector_abs << 9 ;\n * size = ( uint64_t ) mbr [ i ] . nb_sectors_abs << 9 ;\n return 0 ;\n }\n }\n return - ENOENT ;\n }", "idx": 21397}
{"hash": 6500423400461365723, "project": "debian", "size": 32, "label": 0, "functionSource": "static Dwarf_Bool is_32bit_abs_reloc ( unsigned int type , Dwarf_Half machine ) {\n Dwarf_Bool r = 0 ;\n switch ( machine ) {\n # if defined ( EM_MIPS ) && defined ( R_MIPS_32 ) case EM_MIPS : r = ( 0 # if defined ( R_MIPS_32 ) | ( type == R_MIPS_32 ) # endif # if defined ( R_MIPS_TLS_DTPREL32 ) | ( type == R_MIPS_TLS_DTPREL32 ) # endif ) ;\n break ;\n # endif # if defined ( EM_SPARC32PLUS ) && defined ( R_SPARC_UA32 ) case EM_SPARC32PLUS : r = ( type == R_SPARC_UA32 ) ;\n break ;\n # endif # if defined ( EM_SPARCV9 ) && defined ( R_SPARC_UA32 ) case EM_SPARCV9 : r = ( type == R_SPARC_UA32 ) ;\n break ;\n # endif # if defined ( EM_SPARC ) && defined ( R_SPARC_UA32 ) case EM_SPARC : r = ( 0 # if defined ( R_SPARC_UA32 ) | ( type == R_SPARC_UA32 ) # endif # if ( R_SPARC_TLS_DTPOFF32 ) | ( type == R_SPARC_TLS_DTPOFF32 ) # endif ) ;\n break ;\n # endif # if defined ( EM_386 ) && defined ( R_386_32 ) case EM_386 : r = ( 0 # if defined ( R_386_32 ) | ( type == R_386_32 ) # endif # if defined ( R_386_TLS_LDO_32 ) | ( type == R_386_TLS_LDO_32 ) # endif # if defined ( R_386_TLS_DTPOFF32 ) | ( type == R_386_TLS_DTPOFF32 ) # endif ) ;\n break ;\n # endif # if defined ( EM_SH ) && defined ( R_SH_DIR32 ) case EM_SH : r = ( 0 # if defined ( R_SH_DIR32 ) | ( type == R_SH_DIR32 ) # endif # if defined ( R_SH_DTPOFF32 ) | ( type == R_SH_TLS_DTPOFF32 ) # endif ) ;\n break ;\n # endif # if defined ( EM_IA_64 ) && defined ( R_IA64_SECREL32LSB ) case EM_IA_64 : r = ( 0 # if defined ( R_IA64_SECREL32LSB ) | ( type == R_IA64_SECREL32LSB ) # endif # if defined ( R_IA64_DIR32LSB ) | ( type == R_IA64_DIR32LSB ) # endif # if defined ( R_IA64_DTPREL32LSB ) | ( type == R_IA64_DTPREL32LSB ) # endif ) ;\n break ;\n # endif # if defined ( EM_ARM ) && defined ( R_ARM_ABS32 ) case EM_ARM : case EM_AARCH64 : r = ( 0 # if defined ( R_ARM_ABS32 ) | ( type == R_ARM_ABS32 ) # endif # if defined ( R_AARCH64_ABS32 ) | ( type == R_AARCH64_ABS32 ) # endif # if defined ( R_ARM_TLS_LDO32 ) | ( type == R_ARM_TLS_LDO32 ) # endif ) ;\n break ;\n # endif # if defined ( EM_PPC64 ) && defined ( R_PPC_ADDR32 ) case EM_PPC64 : r = ( 0 # if defined ( R_PPC_ADDR32 ) | ( type == R_PPC_ADDR32 ) # endif # if defined ( R_PPC64_DTPREL32 ) | ( type == R_PPC64_DTPREL32 ) # endif ) ;\n break ;\n # endif # if defined ( EM_PPC ) && defined ( R_PPC_ADDR32 ) case EM_PPC : r = ( 0 # if defined ( R_PPC_ADDR32 ) | ( type == R_PPC_ADDR32 ) # endif # if defined ( R_PPC_DTPREL32 ) | ( type == R_PPC_DTPREL32 ) # endif ) ;\n break ;\n # endif # if defined ( EM_S390 ) && defined ( R_390_32 ) case EM_S390 : r = ( 0 # if defined ( R_390_32 ) | ( type == R_390_32 ) # endif # if defined ( R_390_TLS_LDO32 ) | ( type == R_390_TLS_LDO32 ) # endif ) ;\n break ;\n # endif # if defined ( EM_X86_64 ) && defined ( R_X86_64_32 ) # if defined ( EM_K10M ) case EM_K10M : # endif # if defined ( EM_L10M ) case EM_L10M : # endif case EM_X86_64 : r = ( 0 # if defined ( R_X86_64_32 ) | ( type == R_X86_64_32 ) # endif # if defined ( R_X86_64_DTPOFF32 ) | ( type == R_X86_64_DTPOFF32 ) # endif ) ;\n break ;\n # endif case EM_QUALCOMM_DSP6 : r = ( type == QUALCOMM_REL32 ) ;\n break ;\n }\n return r ;\n }", "idx": 21398}
{"hash": 1891617106617090004, "project": "chrome", "size": 82, "label": 1, "functionSource": "static void T_UConverter_fromUnicode_UTF32_BE_OFFSET_LOGIC ( UConverterFromUnicodeArgs * args , UErrorCode * err ) {\n const UChar * mySource = args -> source ;\n unsigned char * myTarget ;\n int32_t * myOffsets ;\n const UChar * sourceLimit = args -> sourceLimit ;\n const unsigned char * targetLimit = ( unsigned char * ) args -> targetLimit ;\n UChar32 ch , ch2 ;\n int32_t offsetNum = 0 ;\n unsigned int indexToWrite ;\n unsigned char temp [ sizeof ( uint32_t ) ] ;\n if ( mySource >= sourceLimit ) {\n return ;\n }\n if ( args -> converter -> fromUnicodeStatus == UCNV_NEED_TO_WRITE_BOM ) {\n static const char bom [ ] = {\n 0 , 0 , ( char ) 0xfe , ( char ) 0xff }\n ;\n ucnv_fromUWriteBytes ( args -> converter , bom , 4 , & args -> target , args -> targetLimit , & args -> offsets , - 1 , err ) ;\n args -> converter -> fromUnicodeStatus = 0 ;\n }\n myTarget = ( unsigned char * ) args -> target ;\n myOffsets = args -> offsets ;\n temp [ 0 ] = 0 ;\n if ( args -> converter -> fromUChar32 ) {\n ch = args -> converter -> fromUChar32 ;\n args -> converter -> fromUChar32 = 0 ;\n goto lowsurogate ;\n }\n while ( mySource < sourceLimit && myTarget < targetLimit ) {\n ch = * ( mySource ++ ) ;\n if ( U_IS_SURROGATE ( ch ) ) {\n if ( U_IS_LEAD ( ch ) ) {\n lowsurogate : if ( mySource < sourceLimit ) {\n ch2 = * mySource ;\n if ( U_IS_TRAIL ( ch2 ) ) {\n ch = ( ( ch - SURROGATE_HIGH_START ) << HALF_SHIFT ) + ch2 + SURROGATE_LOW_BASE ;\n mySource ++ ;\n }\n else {\n args -> converter -> fromUChar32 = ch ;\n * err = U_ILLEGAL_CHAR_FOUND ;\n break ;\n }\n }\n else {\n args -> converter -> fromUChar32 = ch ;\n if ( args -> flush ) {\n * err = U_ILLEGAL_CHAR_FOUND ;\n }\n break ;\n }\n }\n else {\n args -> converter -> fromUChar32 = ch ;\n * err = U_ILLEGAL_CHAR_FOUND ;\n break ;\n }\n }\n temp [ 1 ] = ( uint8_t ) ( ch >> 16 & 0x1F ) ;\n temp [ 2 ] = ( uint8_t ) ( ch >> 8 ) ;\n temp [ 3 ] = ( uint8_t ) ( ch ) ;\n for ( indexToWrite = 0 ;\n indexToWrite <= sizeof ( uint32_t ) - 1 ;\n indexToWrite ++ ) {\n if ( myTarget < targetLimit ) {\n * ( myTarget ++ ) = temp [ indexToWrite ] ;\n * ( myOffsets ++ ) = offsetNum ;\n }\n else {\n args -> converter -> charErrorBuffer [ args -> converter -> charErrorBufferLength ++ ] = temp [ indexToWrite ] ;\n * err = U_BUFFER_OVERFLOW_ERROR ;\n }\n }\n offsetNum = offsetNum + 1 + ( temp [ 1 ] != 0 ) ;\n }\n if ( mySource < sourceLimit && myTarget >= targetLimit && U_SUCCESS ( * err ) ) {\n * err = U_BUFFER_OVERFLOW_ERROR ;\n }\n args -> target = ( char * ) myTarget ;\n args -> source = mySource ;\n args -> offsets = myOffsets ;\n }", "idx": 21399}
{"hash": 3599206110384554647, "project": "debian", "size": 28, "label": 0, "functionSource": "static ossl_inline t2 * sk_ ## t1 ## _set ( STACK_OF ( t1 ) * sk , int idx , t2 * ptr ) {\n return ( t2 * ) OPENSSL_sk_set ( ( OPENSSL_STACK * ) sk , idx , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _find ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_find ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _find_ex ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_find_ex ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline void sk_ ## t1 ## _sort ( STACK_OF ( t1 ) * sk ) {\n OPENSSL_sk_sort ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline int sk_ ## t1 ## _is_sorted ( const STACK_OF ( t1 ) * sk ) {\n return OPENSSL_sk_is_sorted ( ( const OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _dup ( const STACK_OF ( t1 ) * sk ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_dup ( ( const OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _deep_copy ( const STACK_OF ( t1 ) * sk , sk_ ## t1 ## _copyfunc copyfunc , sk_ ## t1 ## _freefunc freefunc ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_deep_copy ( ( const OPENSSL_STACK * ) sk , ( OPENSSL_sk_copyfunc ) copyfunc , ( OPENSSL_sk_freefunc ) freefunc ) ;\n }\n static ossl_inline sk_ ## t1 ## _compfunc sk_ ## t1 ## _set_cmp_func ( STACK_OF ( t1 ) * sk , sk_ ## t1 ## _compfunc compare ) {\n return ( sk_ ## t1 ## _compfunc ) OPENSSL_sk_set_cmp_func ( ( OPENSSL_STACK * ) sk , ( OPENSSL_sk_compfunc ) compare ) ;\n }\n # define DEFINE_SPECIAL_STACK_OF ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , t2 , t2 ) # define DEFINE_STACK_OF ( t ) SKM_DEFINE_STACK_OF ( t , t , t ) # define DEFINE_SPECIAL_STACK_OF_CONST ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , const t2 , t2 ) # define DEFINE_STACK_OF_CONST ( t ) SKM_DEFINE_STACK_OF ( t , const t , t ) typedef char * OPENSSL_STRING ;\n typedef const char * OPENSSL_CSTRING ;\n DEFINE_SPECIAL_STACK_OF ( OPENSSL_STRING , char ) DEFINE_SPECIAL_STACK_OF_CONST ( OPENSSL_CSTRING , char ) typedef void * OPENSSL_BLOCK ;\n DEFINE_SPECIAL_STACK_OF ( OPENSSL_BLOCK , void )", "idx": 21400}
{"hash": -3502382902740740634, "project": "debian", "size": 16, "label": 0, "functionSource": "static guint strcase_hash ( gconstpointer key ) {\n const char * p = ( const char * ) key ;\n guint h = * p ;\n char c ;\n if ( h ) {\n if ( h >= 'A' && h <= 'Z' ) h = h - 'A' + 'a' ;\n for ( p += 1 ;\n * p != '\\0' ;\n p ++ ) {\n c = * p ;\n if ( c >= 'A' && c <= 'Z' ) c = c - 'A' + 'a' ;\n h = ( h << 5 ) - h + c ;\n }\n }\n return h ;\n }", "idx": 21401}
{"hash": 7092216800726729686, "project": "debian", "size": 6, "label": 0, "functionSource": "static int dissect_h245_Ack_mediaControlChannel ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 905 \"../../asn1/h245/h245.cnf\" if ( upcoming_channel ) upcoming_channel -> upcoming_addr = & upcoming_channel -> media_control_addr ;\n offset = dissect_h245_TransportAddress ( tvb , offset , actx , tree , hf_index ) ;\n # line 909 \"../../asn1/h245/h245.cnf\" if ( upcoming_channel ) upcoming_channel -> upcoming_addr = NULL ;\n return offset ;\n }", "idx": 21402}
{"hash": 774948452618964156, "project": "chrome", "size": 16, "label": 0, "functionSource": "static int32_t setCodes ( const UScriptCode * src , int32_t length , UScriptCode * dest , int32_t capacity , UErrorCode * err ) {\n int32_t i ;\n if ( U_FAILURE ( * err ) ) {\n return 0 ;\n }\n if ( length > capacity ) {\n * err = U_BUFFER_OVERFLOW_ERROR ;\n return length ;\n }\n for ( i = 0 ;\n i < length ;\n ++ i ) {\n dest [ i ] = src [ i ] ;\n }\n return length ;\n }", "idx": 21403}
{"hash": -1768728156572022708, "project": "debian", "size": 3, "label": 0, "functionSource": "int16_t jbig2_get_int16 ( const byte * bptr ) {\n return get_int16 ( bptr ) ;\n }", "idx": 21404}
{"hash": -8365810778652022218, "project": "debian", "size": 16, "label": 0, "functionSource": "static int virtio_net_handle_rx_mode ( VirtIONet * n , uint8_t cmd , VirtQueueElement * elem ) {\n uint8_t on ;\n if ( elem -> out_num != 2 || elem -> out_sg [ 1 ] . iov_len != sizeof ( on ) ) {\n error_report ( \"virtio-net ctrl invalid rx mode command\" ) ;\n exit ( 1 ) ;\n }\n on = ldub_p ( elem -> out_sg [ 1 ] . iov_base ) ;\n if ( cmd == VIRTIO_NET_CTRL_RX_MODE_PROMISC ) n -> promisc = on ;\n else if ( cmd == VIRTIO_NET_CTRL_RX_MODE_ALLMULTI ) n -> allmulti = on ;\n else if ( cmd == VIRTIO_NET_CTRL_RX_MODE_ALLUNI ) n -> alluni = on ;\n else if ( cmd == VIRTIO_NET_CTRL_RX_MODE_NOMULTI ) n -> nomulti = on ;\n else if ( cmd == VIRTIO_NET_CTRL_RX_MODE_NOUNI ) n -> nouni = on ;\n else if ( cmd == VIRTIO_NET_CTRL_RX_MODE_NOBCAST ) n -> nobcast = on ;\n else return VIRTIO_NET_ERR ;\n return VIRTIO_NET_OK ;\n }", "idx": 21405}
{"hash": -7559567117301601597, "project": "debian", "size": 8, "label": 0, "functionSource": "void ef_debug ( u_char level , const char * message , ... ) {\n va_list ap ;\n if ( EF_GBL_OPTIONS -> debug < level ) return ;\n va_start ( ap , message ) ;\n vfprintf ( stderr , message , ap ) ;\n fflush ( stderr ) ;\n va_end ( ap ) ;\n }", "idx": 21406}
{"hash": 4489017523191997023, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h225_PublicPartyNumber ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_PublicPartyNumber , PublicPartyNumber_sequence ) ;\n return offset ;\n }", "idx": 21407}
{"hash": 6393050609822897742, "project": "debian", "size": 15, "label": 0, "functionSource": "static void xhci_class_init ( ObjectClass * klass , void * data ) {\n PCIDeviceClass * k = PCI_DEVICE_CLASS ( klass ) ;\n DeviceClass * dc = DEVICE_CLASS ( klass ) ;\n dc -> vmsd = & vmstate_xhci ;\n dc -> props = xhci_properties ;\n dc -> reset = xhci_reset ;\n set_bit ( DEVICE_CATEGORY_USB , dc -> categories ) ;\n k -> realize = usb_xhci_realize ;\n k -> exit = usb_xhci_exit ;\n k -> vendor_id = PCI_VENDOR_ID_NEC ;\n k -> device_id = PCI_DEVICE_ID_NEC_UPD720200 ;\n k -> class_id = PCI_CLASS_SERIAL_USB ;\n k -> revision = 0x03 ;\n k -> is_express = 1 ;\n }", "idx": 21408}
{"hash": -5689214734378699681, "project": "debian", "size": 21, "label": 0, "functionSource": "static int write_string ( buffer_t buffer , PyObject * py_string ) {\n Py_ssize_t string_length ;\n const char * string ;\n # if PY_MAJOR_VERSION >= 3 if ( PyUnicode_Check ( py_string ) ) {\n return write_unicode ( buffer , py_string ) ;\n }\n string = PyBytes_AsString ( py_string ) ;\n # else string = PyString_AsString ( py_string ) ;\n # endif if ( ! string ) {\n return 0 ;\n }\n # if PY_MAJOR_VERSION >= 3 string_length = PyBytes_Size ( py_string ) + 1 ;\n # else string_length = PyString_Size ( py_string ) + 1 ;\n # endif if ( ! buffer_write_bytes ( buffer , ( const char * ) & string_length , 4 ) ) {\n return 0 ;\n }\n if ( ! buffer_write_bytes ( buffer , string , string_length ) ) {\n return 0 ;\n }\n return 1 ;\n }", "idx": 21409}
{"hash": -2908211205972632000, "project": "debian", "size": 29, "label": 0, "functionSource": "void mainwindow_change_active ( MAIN_WINDOW_REC * mainwin , WINDOW_REC * skip_window ) {\n WINDOW_REC * window , * other ;\n GSList * tmp ;\n mainwin -> active = NULL ;\n if ( mainwin -> sticky_windows ) {\n tmp = get_sticky_windows_sorted ( mainwin ) ;\n window = tmp -> data ;\n if ( window == skip_window ) {\n window = tmp -> next == NULL ? NULL : tmp -> next -> data ;\n }\n g_slist_free ( tmp ) ;\n if ( window != NULL ) {\n window_set_active ( window ) ;\n return ;\n }\n }\n other = NULL ;\n for ( tmp = windows ;\n tmp != NULL ;\n tmp = tmp -> next ) {\n WINDOW_REC * rec = tmp -> data ;\n if ( rec != skip_window ) {\n other = rec ;\n break ;\n }\n }\n window_set_active ( other ) ;\n if ( mainwindows -> next != NULL ) mainwindow_destroy ( mainwin ) ;\n }", "idx": 21410}
{"hash": -3135212895432241239, "project": "debian", "size": 16, "label": 0, "functionSource": "static guint32 dissect_netb_status_query ( tvbuff_t * tvb , packet_info * pinfo _U_ , int offset , proto_tree * tree ) {\n guint8 status_request = tvb_get_guint8 ( tvb , offset + NB_DATA1 ) ;\n switch ( status_request ) {\n case 0 : proto_tree_add_uint_format_value ( tree , hf_netb_status_request , tvb , offset + NB_DATA1 , 1 , status_request , \"NetBIOS 1.x or 2.0\" ) ;\n break ;\n case 1 : proto_tree_add_uint_format_value ( tree , hf_netb_status_request , tvb , offset + NB_DATA1 , 1 , status_request , \"NetBIOS 2.1, initial status request\" ) ;\n break ;\n default : proto_tree_add_uint_format_value ( tree , hf_netb_status_request , tvb , offset + NB_DATA1 , 1 , status_request , \"NetBIOS 2.1, %u names received so far\" , status_request ) ;\n break ;\n }\n nb_data2 ( hf_netb_status_buffer_len , tvb , offset , tree ) ;\n nb_resp_corrl ( tvb , offset , tree ) ;\n netbios_add_name ( \"Receiver's Name\" , tvb , offset + NB_RECVER_NAME , tree ) ;\n netbios_add_name ( \"Sender's Name\" , tvb , offset + NB_SENDER_NAME , tree ) ;\n return 0 ;\n }", "idx": 21411}
{"hash": 7479670341626732011, "project": "chrome", "size": 4, "label": 0, "functionSource": "int main ( int argc ATTRIBUTE_UNUSED , char * * argv ATTRIBUTE_UNUSED ) {\n printf ( \"%s : Regexp support not compiled in\\n\" , argv [ 0 ] ) ;\n return ( 0 ) ;\n }", "idx": 21412}
{"hash": 6393050609822897742, "project": "debian", "size": 4, "label": 0, "functionSource": "static uint32_t rotl ( uint32_t v , unsigned count ) {\n count &= 31 ;\n return ( v << count ) | ( v >> ( 32 - count ) ) ;\n }", "idx": 21413}
{"hash": 5653549006541675258, "project": "debian", "size": 36, "label": 1, "functionSource": "void EVP_EncodeUpdate ( EVP_ENCODE_CTX * ctx , unsigned char * out , int * outl , const unsigned char * in , int inl ) {\n int i , j ;\n unsigned int total = 0 ;\n * outl = 0 ;\n if ( inl <= 0 ) return ;\n OPENSSL_assert ( ctx -> length <= ( int ) sizeof ( ctx -> enc_data ) ) ;\n if ( ( ctx -> num + inl ) < ctx -> length ) {\n memcpy ( & ( ctx -> enc_data [ ctx -> num ] ) , in , inl ) ;\n ctx -> num += inl ;\n return ;\n }\n if ( ctx -> num != 0 ) {\n i = ctx -> length - ctx -> num ;\n memcpy ( & ( ctx -> enc_data [ ctx -> num ] ) , in , i ) ;\n in += i ;\n inl -= i ;\n j = EVP_EncodeBlock ( out , ctx -> enc_data , ctx -> length ) ;\n ctx -> num = 0 ;\n out += j ;\n * ( out ++ ) = '\\n' ;\n * out = '\\0' ;\n total = j + 1 ;\n }\n while ( inl >= ctx -> length ) {\n j = EVP_EncodeBlock ( out , in , ctx -> length ) ;\n in += ctx -> length ;\n inl -= ctx -> length ;\n out += j ;\n * ( out ++ ) = '\\n' ;\n * out = '\\0' ;\n total += j + 1 ;\n }\n if ( inl != 0 ) memcpy ( & ( ctx -> enc_data [ 0 ] ) , in , inl ) ;\n ctx -> num = inl ;\n * outl = total ;\n }", "idx": 21414}
{"hash": -1388412050128601796, "project": "debian", "size": 41, "label": 0, "functionSource": "static int g722_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n G722Context * c = avctx -> priv_data ;\n AVFrame * frame = data ;\n int16_t * out_buf ;\n int j , ret ;\n const int skip = 8 - c -> bits_per_codeword ;\n const int16_t * quantizer_table = low_inv_quants [ skip ] ;\n GetBitContext gb ;\n frame -> nb_samples = avpkt -> size * 2 ;\n if ( ( ret = ff_get_buffer ( avctx , frame , 0 ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n out_buf = ( int16_t * ) frame -> data [ 0 ] ;\n init_get_bits ( & gb , avpkt -> data , avpkt -> size * 8 ) ;\n for ( j = 0 ;\n j < avpkt -> size ;\n j ++ ) {\n int ilow , ihigh , rlow , rhigh , dhigh ;\n int xout1 , xout2 ;\n ihigh = get_bits ( & gb , 2 ) ;\n ilow = get_bits ( & gb , 6 - skip ) ;\n skip_bits ( & gb , skip ) ;\n rlow = av_clip ( ( c -> band [ 0 ] . scale_factor * quantizer_table [ ilow ] >> 10 ) + c -> band [ 0 ] . s_predictor , - 16384 , 16383 ) ;\n ff_g722_update_low_predictor ( & c -> band [ 0 ] , ilow >> ( 2 - skip ) ) ;\n dhigh = c -> band [ 1 ] . scale_factor * ff_g722_high_inv_quant [ ihigh ] >> 10 ;\n rhigh = av_clip ( dhigh + c -> band [ 1 ] . s_predictor , - 16384 , 16383 ) ;\n ff_g722_update_high_predictor ( & c -> band [ 1 ] , dhigh , ihigh ) ;\n c -> prev_samples [ c -> prev_samples_pos ++ ] = rlow + rhigh ;\n c -> prev_samples [ c -> prev_samples_pos ++ ] = rlow - rhigh ;\n ff_g722_apply_qmf ( c -> prev_samples + c -> prev_samples_pos - 24 , & xout1 , & xout2 ) ;\n * out_buf ++ = av_clip_int16 ( xout1 >> 11 ) ;\n * out_buf ++ = av_clip_int16 ( xout2 >> 11 ) ;\n if ( c -> prev_samples_pos >= PREV_SAMPLES_BUF_SIZE ) {\n memmove ( c -> prev_samples , c -> prev_samples + c -> prev_samples_pos - 22 , 22 * sizeof ( c -> prev_samples [ 0 ] ) ) ;\n c -> prev_samples_pos = 22 ;\n }\n }\n * got_frame_ptr = 1 ;\n return avpkt -> size ;\n }", "idx": 21415}
{"hash": -5332743636142828697, "project": "debian", "size": 88, "label": 0, "functionSource": "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n const uint8_t * buf_end = avpkt -> data + avpkt -> size ;\n int buf_size = avpkt -> size ;\n AVFrame * const p = data ;\n uint8_t * outdata ;\n int colors ;\n int i , ret ;\n uint32_t * pal ;\n int r , g , b ;\n if ( ( ret = ff_get_buffer ( avctx , p , 0 ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n p -> pict_type = AV_PICTURE_TYPE_I ;\n p -> key_frame = 1 ;\n outdata = p -> data [ 0 ] ;\n if ( buf_end - buf < 0x68 + 4 ) return AVERROR_INVALIDDATA ;\n buf += 0x68 ;\n colors = AV_RB32 ( buf ) ;\n buf += 4 ;\n if ( colors < 0 || colors > 256 ) {\n av_log ( avctx , AV_LOG_ERROR , \"Error color count - %i(0x%X)\\n\" , colors , colors ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( buf_end - buf < ( colors + 1 ) * 8 ) return AVERROR_INVALIDDATA ;\n pal = ( uint32_t * ) p -> data [ 1 ] ;\n for ( i = 0 ;\n i <= colors ;\n i ++ ) {\n unsigned int idx ;\n idx = AV_RB16 ( buf ) ;\n buf += 2 ;\n if ( idx > 255 ) {\n av_log ( avctx , AV_LOG_ERROR , \"Palette index out of range: %u\\n\" , idx ) ;\n buf += 6 ;\n continue ;\n }\n r = * buf ++ ;\n buf ++ ;\n g = * buf ++ ;\n buf ++ ;\n b = * buf ++ ;\n buf ++ ;\n pal [ idx ] = ( r << 16 ) | ( g << 8 ) | b ;\n }\n p -> palette_has_changed = 1 ;\n if ( buf_end - buf < 18 ) return AVERROR_INVALIDDATA ;\n buf += 18 ;\n for ( i = 0 ;\n i < avctx -> height ;\n i ++ ) {\n int size , left , code , pix ;\n const uint8_t * next ;\n uint8_t * out ;\n int tsize = 0 ;\n out = outdata ;\n size = AV_RB16 ( buf ) ;\n buf += 2 ;\n if ( buf_end - buf < size ) return AVERROR_INVALIDDATA ;\n left = size ;\n next = buf + size ;\n while ( left > 0 ) {\n code = * buf ++ ;\n if ( code & 0x80 ) {\n pix = * buf ++ ;\n if ( ( out + ( 257 - code ) ) > ( outdata + p -> linesize [ 0 ] ) ) break ;\n memset ( out , pix , 257 - code ) ;\n out += 257 - code ;\n tsize += 257 - code ;\n left -= 2 ;\n }\n else {\n if ( ( out + code ) > ( outdata + p -> linesize [ 0 ] ) ) break ;\n if ( buf_end - buf < code + 1 ) return AVERROR_INVALIDDATA ;\n memcpy ( out , buf , code + 1 ) ;\n out += code + 1 ;\n buf += code + 1 ;\n left -= 2 + code ;\n tsize += code + 1 ;\n }\n }\n buf = next ;\n outdata += p -> linesize [ 0 ] ;\n }\n * got_frame = 1 ;\n return buf_size ;\n }", "idx": 21416}
{"hash": 8170016074494868282, "project": "debian", "size": 10, "label": 0, "functionSource": "static int auth_server_input_cont ( struct auth_server_connection * conn , const char * const * args ) {\n struct auth_client_request * request ;\n if ( str_array_length ( args ) < 2 ) {\n i_error ( \"BUG: Authentication server sent broken CONT line\" ) ;\n return - 1 ;\n }\n if ( auth_server_lookup_request ( conn , args [ 0 ] , FALSE , & request ) < 0 ) return - 1 ;\n auth_client_request_server_input ( request , AUTH_REQUEST_STATUS_CONTINUE , args + 1 ) ;\n return 0 ;\n }", "idx": 21417}
{"hash": -4558261210024070448, "project": "chrome", "size": 10, "label": 0, "functionSource": "static xmlLinkPtr xmlListLinkSearch ( xmlListPtr l , void * data ) {\n xmlLinkPtr lk ;\n if ( l == NULL ) return ( NULL ) ;\n lk = xmlListLowerSearch ( l , data ) ;\n if ( lk == l -> sentinel ) return NULL ;\n else {\n if ( l -> linkCompare ( lk -> data , data ) == 0 ) return lk ;\n return NULL ;\n }\n }", "idx": 21418}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_RequestAllTerminalIDsResponse ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_RequestAllTerminalIDsResponse , RequestAllTerminalIDsResponse_sequence ) ;\n return offset ;\n }", "idx": 21419}
{"hash": 4876100961671882393, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_pvfs2_rmdirent_response ( tvbuff_t * tvb , proto_tree * tree , int offset , packet_info * pinfo ) {\n offset = dissect_pvfs_fh ( tvb , offset , pinfo , tree , \"handle\" , NULL ) ;\n return offset ;\n }", "idx": 21420}
{"hash": 3584320764213684062, "project": "debian", "size": 26, "label": 0, "functionSource": "static int parse_CContentRestriction ( tvbuff_t * tvb , int offset , proto_tree * parent_tree , proto_tree * pad_tree , struct CContentRestriction * v , const char * fmt , ... ) {\n proto_tree * tree ;\n proto_item * item ;\n va_list ap ;\n guint32 cc ;\n const char * txt ;\n va_start ( ap , fmt ) ;\n txt = wmem_strdup_vprintf ( wmem_packet_scope ( ) , fmt , ap ) ;\n va_end ( ap ) ;\n tree = proto_tree_add_subtree ( parent_tree , tvb , offset , 0 , ett_CContentRestriction , & item , txt ) ;\n offset = parse_CFullPropSpec ( tvb , offset , tree , pad_tree , & v -> property , \"Property\" ) ;\n offset = parse_padding ( tvb , offset , 4 , pad_tree , \"Padding1\" ) ;\n cc = tvb_get_letohl ( tvb , offset ) ;\n proto_tree_add_uint ( tree , hf_mswsp_ccontentrestrict_cc , tvb , offset , 4 , cc ) ;\n offset += 4 ;\n proto_tree_add_item_ret_string ( tree , hf_mswsp_ccontentrestrict_phrase , tvb , offset , 2 * cc , ENC_LITTLE_ENDIAN | ENC_UCS_2 , wmem_packet_scope ( ) , & v -> phrase ) ;\n offset += 2 * cc ;\n offset = parse_padding ( tvb , offset , 4 , pad_tree , \"Padding2\" ) ;\n v -> lcid = tvb_get_letohl ( tvb , offset ) ;\n offset = parse_lcid ( tvb , offset , tree , \"lcid\" ) ;\n v -> method = tvb_get_letohl ( tvb , offset ) ;\n proto_tree_add_uint ( tree , hf_mswsp_ccontentrestrict_method , tvb , offset , 4 , v -> method ) ;\n offset += 4 ;\n proto_item_set_end ( item , tvb , offset ) ;\n return offset ;\n }", "idx": 21421}
{"hash": 1676654288894940649, "project": "debian", "size": 85, "label": 1, "functionSource": "void kadmin_getprinc ( int argc , char * argv [ ] ) {\n kadm5_principal_ent_rec dprinc ;\n krb5_principal princ = NULL ;\n krb5_error_code retval ;\n char * canon = NULL , * princstr = NULL , * modprincstr = NULL ;\n int i ;\n size_t j ;\n if ( ! ( argc == 2 || ( argc == 3 && ! strcmp ( \"-terse\" , argv [ 1 ] ) ) ) ) {\n fprintf ( stderr , _ ( \"usage: get_principal [-terse] principal\\n\" ) ) ;\n return ;\n }\n memset ( & dprinc , 0 , sizeof ( dprinc ) ) ;\n retval = kadmin_parse_name ( argv [ argc - 1 ] , & princ ) ;\n if ( retval ) {\n com_err ( \"get_principal\" , retval , _ ( \"while parsing principal\" ) ) ;\n return ;\n }\n retval = krb5_unparse_name ( context , princ , & canon ) ;\n if ( retval ) {\n com_err ( \"get_principal\" , retval , _ ( \"while canonicalizing principal\" ) ) ;\n goto cleanup ;\n }\n retval = kadm5_get_principal ( handle , princ , & dprinc , KADM5_PRINCIPAL_NORMAL_MASK | KADM5_KEY_DATA ) ;\n if ( retval ) {\n com_err ( \"get_principal\" , retval , _ ( \"while retrieving \\\"%s\\\".\" ) , canon ) ;\n goto cleanup ;\n }\n retval = krb5_unparse_name ( context , dprinc . principal , & princstr ) ;\n if ( retval ) {\n com_err ( \"get_principal\" , retval , _ ( \"while unparsing principal\" ) ) ;\n goto cleanup ;\n }\n retval = krb5_unparse_name ( context , dprinc . mod_name , & modprincstr ) ;\n if ( retval ) {\n com_err ( \"get_principal\" , retval , _ ( \"while unparsing principal\" ) ) ;\n goto cleanup ;\n }\n if ( argc == 2 ) {\n printf ( _ ( \"Principal: %s\\n\" ) , princstr ) ;\n printf ( _ ( \"Expiration date: %s\\n\" ) , dprinc . princ_expire_time ? strdate ( dprinc . princ_expire_time ) : _ ( \"[never]\" ) ) ;\n printf ( _ ( \"Last password change: %s\\n\" ) , dprinc . last_pwd_change ? strdate ( dprinc . last_pwd_change ) : _ ( \"[never]\" ) ) ;\n printf ( _ ( \"Password expiration date: %s\\n\" ) , dprinc . pw_expiration ? strdate ( dprinc . pw_expiration ) : _ ( \"[none]\" ) ) ;\n printf ( _ ( \"Maximum ticket life: %s\\n\" ) , strdur ( dprinc . max_life ) ) ;\n printf ( _ ( \"Maximum renewable life: %s\\n\" ) , strdur ( dprinc . max_renewable_life ) ) ;\n printf ( _ ( \"Last modified: %s (%s)\\n\" ) , strdate ( dprinc . mod_date ) , modprincstr ) ;\n printf ( _ ( \"Last successful authentication: %s\\n\" ) , dprinc . last_success ? strdate ( dprinc . last_success ) : _ ( \"[never]\" ) ) ;\n printf ( \"Last failed authentication: %s\\n\" , dprinc . last_failed ? strdate ( dprinc . last_failed ) : \"[never]\" ) ;\n printf ( _ ( \"Failed password attempts: %d\\n\" ) , dprinc . fail_auth_count ) ;\n printf ( _ ( \"Number of keys: %d\\n\" ) , dprinc . n_key_data ) ;\n for ( i = 0 ;\n i < dprinc . n_key_data ;\n i ++ ) {\n krb5_key_data * key_data = & dprinc . key_data [ i ] ;\n char enctype [ BUFSIZ ] , salttype [ BUFSIZ ] ;\n if ( krb5_enctype_to_name ( key_data -> key_data_type [ 0 ] , FALSE , enctype , sizeof ( enctype ) ) ) snprintf ( enctype , sizeof ( enctype ) , _ ( \"<Encryption type 0x%x>\" ) , key_data -> key_data_type [ 0 ] ) ;\n printf ( \"Key: vno %d, %s, \" , key_data -> key_data_kvno , enctype ) ;\n if ( key_data -> key_data_ver > 1 ) {\n if ( krb5_salttype_to_string ( key_data -> key_data_type [ 1 ] , salttype , sizeof ( salttype ) ) ) snprintf ( salttype , sizeof ( salttype ) , _ ( \"<Salt type 0x%x>\" ) , key_data -> key_data_type [ 1 ] ) ;\n printf ( \"%s\\n\" , salttype ) ;\n }\n else printf ( _ ( \"no salt\\n\" ) ) ;\n }\n printf ( _ ( \"MKey: vno %d\\n\" ) , dprinc . mkvno ) ;\n printf ( _ ( \"Attributes:\" ) ) ;\n for ( j = 0 ;\n j < sizeof ( prflags ) / sizeof ( char * ) ;\n j ++ ) {\n if ( dprinc . attributes & ( krb5_flags ) 1 << j ) printf ( \" %s\" , prflags [ j ] ) ;\n }\n printf ( \"\\n\" ) ;\n printf ( _ ( \"Policy: %s\\n\" ) , dprinc . policy ? dprinc . policy : _ ( \"[none]\" ) ) ;\n }\n else {\n printf ( \"\\\"%s\\\"\\t%d\\t%d\\t%d\\t%d\\t\\\"%s\\\"\\t%d\\t%d\\t%d\\t%d\\t\\\"%s\\\"\" \"\\t%d\\t%d\\t%d\\t%d\\t%d\" , princstr , dprinc . princ_expire_time , dprinc . last_pwd_change , dprinc . pw_expiration , dprinc . max_life , modprincstr , dprinc . mod_date , dprinc . attributes , dprinc . kvno , dprinc . mkvno , dprinc . policy ? dprinc . policy : \"[none]\" , dprinc . max_renewable_life , dprinc . last_success , dprinc . last_failed , dprinc . fail_auth_count , dprinc . n_key_data ) ;\n for ( i = 0 ;\n i < dprinc . n_key_data ;\n i ++ ) printf ( \"\\t%d\\t%d\\t%d\\t%d\" , dprinc . key_data [ i ] . key_data_ver , dprinc . key_data [ i ] . key_data_kvno , dprinc . key_data [ i ] . key_data_type [ 0 ] , dprinc . key_data [ i ] . key_data_type [ 1 ] ) ;\n printf ( \"\\n\" ) ;\n }\n cleanup : krb5_free_principal ( context , princ ) ;\n kadm5_free_principal_ent ( handle , & dprinc ) ;\n free ( canon ) ;\n free ( princstr ) ;\n free ( modprincstr ) ;\n }", "idx": 21422}
{"hash": -7434014980763120366, "project": "debian", "size": 3, "label": 0, "functionSource": "int dissect_ber_object_identifier ( gboolean implicit_tag , asn1_ctx_t * actx , proto_tree * tree , tvbuff_t * tvb , int offset , gint hf_id , tvbuff_t * * value_tvb ) {\n return dissect_ber_any_oid ( implicit_tag , actx , tree , tvb , offset , hf_id , value_tvb , TRUE ) ;\n }", "idx": 21423}
{"hash": 468458465404335175, "project": "debian", "size": 38, "label": 0, "functionSource": "static void vacuum_all_databases ( vacuumingOptions * vacopts , bool analyze_in_stages , const char * maintenance_db , const char * host , const char * port , const char * username , enum trivalue prompt_password , int concurrentCons , const char * progname , bool echo , bool quiet ) {\n PGconn * conn ;\n PGresult * result ;\n PQExpBufferData connstr ;\n int stage ;\n int i ;\n conn = connectMaintenanceDatabase ( maintenance_db , host , port , username , prompt_password , progname ) ;\n result = executeQuery ( conn , \"SELECT datname FROM pg_database WHERE datallowconn ORDER BY 1;\n\" , progname , echo ) ;\n PQfinish ( conn ) ;\n initPQExpBuffer ( & connstr ) ;\n if ( analyze_in_stages ) {\n for ( stage = 0 ;\n stage < ANALYZE_NUM_STAGES ;\n stage ++ ) {\n for ( i = 0 ;\n i < PQntuples ( result ) ;\n i ++ ) {\n resetPQExpBuffer ( & connstr ) ;\n appendPQExpBuffer ( & connstr , \"dbname=\" ) ;\n appendConnStrVal ( & connstr , PQgetvalue ( result , i , 0 ) ) ;\n vacuum_one_database ( connstr . data , vacopts , stage , NULL , host , port , username , prompt_password , concurrentCons , progname , echo , quiet ) ;\n }\n }\n }\n else {\n for ( i = 0 ;\n i < PQntuples ( result ) ;\n i ++ ) {\n resetPQExpBuffer ( & connstr ) ;\n appendPQExpBuffer ( & connstr , \"dbname=\" ) ;\n appendConnStrVal ( & connstr , PQgetvalue ( result , i , 0 ) ) ;\n vacuum_one_database ( connstr . data , vacopts , ANALYZE_NO_STAGE , NULL , host , port , username , prompt_password , concurrentCons , progname , echo , quiet ) ;\n }\n }\n termPQExpBuffer ( & connstr ) ;\n PQclear ( result ) ;\n }", "idx": 21424}
{"hash": 4489017523191997023, "project": "debian", "size": 4, "label": 0, "functionSource": "int dissect_h225_PresentationIndicator ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_PresentationIndicator , PresentationIndicator_choice , NULL ) ;\n return offset ;\n }", "idx": 21425}
{"hash": 1760449185745615462, "project": "debian", "size": 3, "label": 0, "functionSource": "double TSdrandom ( ) {\n return this_ethread ( ) -> generator . drandom ( ) ;\n }", "idx": 21426}
{"hash": 1760449185745615462, "project": "debian", "size": 6, "label": 0, "functionSource": "TSReturnCode sdk_sanity_check_null_ptr ( void * ptr ) {\n if ( ptr == nullptr ) {\n return TS_ERROR ;\n }\n return TS_SUCCESS ;\n }", "idx": 21427}
{"hash": 2895622461494525400, "project": "debian", "size": 9, "label": 0, "functionSource": "static void test_date_frac ( ) {\n int rc ;\n myheader ( \"test_date\" ) ;\n rc = mysql_query ( mysql , \"DROP TABLE IF EXISTS test_date\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"CREATE TABLE test_date(c1 TIMESTAMP(6), \\ c2 TIME(6), \\ c3 DATETIME(6), \\ c4 DATE)\" ) ;\n myquery ( rc ) ;\n bind_date_conv ( 5 , TRUE ) ;\n }", "idx": 21428}
{"hash": 7749168290238234888, "project": "debian", "size": 3, "label": 0, "functionSource": "static int test_decode_integer_end_of_input ( xd3_stream * stream , int unused ) {\n return test_read_integer_error ( stream , 1 , \"end-of-input in read_integer\" ) ;\n }", "idx": 21429}
{"hash": -6552851419396579257, "project": "debian", "size": 14, "label": 0, "functionSource": "static int SpoolssRFFPCNEX_q ( tvbuff_t * tvb , int offset , packet_info * pinfo , proto_tree * tree , dcerpc_info * di , guint8 * drep _U_ ) {\n guint32 flags ;\n static const int * hf_flags [ ] = {\n & hf_rffpcnex_flags_timeout , & hf_rffpcnex_flags_delete_driver , & hf_rffpcnex_flags_set_driver , & hf_rffpcnex_flags_add_driver , & hf_rffpcnex_flags_delete_print_processor , & hf_rffpcnex_flags_add_print_processor , & hf_rffpcnex_flags_delete_port , & hf_rffpcnex_flags_configure_port , & hf_rffpcnex_flags_add_port , & hf_rffpcnex_flags_delete_form , & hf_rffpcnex_flags_set_form , & hf_rffpcnex_flags_add_form , & hf_rffpcnex_flags_write_job , & hf_rffpcnex_flags_delete_job , & hf_rffpcnex_flags_set_job , & hf_rffpcnex_flags_add_job , & hf_rffpcnex_flags_failed_printer_connection , & hf_rffpcnex_flags_delete_printer , & hf_rffpcnex_flags_set_printer , & hf_rffpcnex_flags_add_printer , NULL }\n ;\n offset = dissect_nt_policy_hnd ( tvb , offset , pinfo , tree , di , drep , hf_hnd , NULL , NULL , FALSE , FALSE ) ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , NULL , di , drep , - 1 , & flags ) ;\n proto_tree_add_bitmask_value ( tree , tvb , offset - 4 , hf_rffpcnex_flags , ett_rffpcnex_flags , hf_flags , flags ) ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , tree , di , drep , hf_rffpcnex_options , NULL ) ;\n offset = dissect_ndr_str_pointer_item ( tvb , offset , pinfo , tree , di , drep , NDR_POINTER_UNIQUE , \"Server\" , hf_servername , 0 ) ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , tree , di , drep , hf_printerlocal , NULL ) ;\n offset = dissect_ndr_pointer ( tvb , offset , pinfo , tree , di , drep , dissect_NOTIFY_OPTIONS_ARRAY_CTR , NDR_POINTER_UNIQUE , \"Notify Options Container\" , - 1 ) ;\n return offset ;\n }", "idx": 21430}
{"hash": 8415334249344417068, "project": "debian", "size": 30, "label": 0, "functionSource": "static void dissect_u3v_stream_trailer ( proto_tree * u3v_telegram_tree , tvbuff_t * tvb , packet_info * pinfo , usb_conv_info_t * usb_conv_info _U_ ) {\n gint offset = 0 ;\n guint64 block_id ;\n proto_item * item = NULL ;\n item = proto_tree_add_item ( u3v_telegram_tree , hf_u3v_stream_trailer , tvb , 0 , - 1 , ENC_NA ) ;\n u3v_telegram_tree = proto_item_add_subtree ( item , ett_u3v_stream_trailer ) ;\n proto_tree_add_item ( u3v_telegram_tree , hf_u3v_stream_prefix , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n proto_tree_add_item ( u3v_telegram_tree , hf_u3v_stream_reserved , tvb , offset , 2 , ENC_NA ) ;\n offset += 2 ;\n proto_tree_add_item ( u3v_telegram_tree , hf_u3v_stream_trailer_size , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n block_id = tvb_get_letoh64 ( tvb , offset ) ;\n proto_tree_add_item ( u3v_telegram_tree , hf_u3v_stream_block_id , tvb , offset , 8 , ENC_LITTLE_ENDIAN ) ;\n offset += 8 ;\n proto_tree_add_item ( u3v_telegram_tree , hf_u3v_stream_status , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( u3v_telegram_tree , hf_u3v_stream_reserved , tvb , offset , 2 , ENC_NA ) ;\n offset += 2 ;\n proto_tree_add_item ( u3v_telegram_tree , hf_u3v_stream_valid_payload_size , tvb , offset , 8 , ENC_LITTLE_ENDIAN ) ;\n offset += 8 ;\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \"Stream Trailer [ Block ID: %\" G_GINT64_MODIFIER \"u]\" , block_id ) ;\n if ( tvb_captured_length_remaining ( tvb , offset ) >= 4 ) {\n proto_tree_add_item ( u3v_telegram_tree , hf_u3v_stream_size_y , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n }\n if ( tvb_captured_length_remaining ( tvb , offset ) >= 4 ) {\n proto_tree_add_item ( u3v_telegram_tree , hf_u3v_stream_chunk_layout_id , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n }\n }", "idx": 21431}
{"hash": -1487877838474751244, "project": "debian", "size": 32, "label": 0, "functionSource": "static char * get_private_subtags ( const char * loc_name ) {\n char * result = NULL ;\n int singletonPos = 0 ;\n int len = 0 ;\n const char * mod_loc_name = NULL ;\n if ( loc_name && ( len = strlen ( loc_name ) > 0 ) ) {\n mod_loc_name = loc_name ;\n len = strlen ( mod_loc_name ) ;\n while ( ( singletonPos = getSingletonPos ( mod_loc_name ) ) != - 1 ) {\n if ( singletonPos != - 1 ) {\n if ( ( * ( mod_loc_name + singletonPos ) == 'x' ) || ( * ( mod_loc_name + singletonPos ) == 'X' ) ) {\n if ( singletonPos + 2 == len ) {\n }\n else {\n result = estrndup ( mod_loc_name + singletonPos + 2 , ( len - ( singletonPos + 2 ) ) ) ;\n }\n break ;\n }\n else {\n if ( singletonPos + 1 >= len ) {\n break ;\n }\n else {\n mod_loc_name = mod_loc_name + singletonPos + 1 ;\n len = strlen ( mod_loc_name ) ;\n }\n }\n }\n }\n }\n return result ;\n }", "idx": 21432}
{"hash": 5991533509192663951, "project": "debian", "size": 13, "label": 0, "functionSource": "mbfl_string * mime_header_decoder_result ( struct mime_header_decoder_data * pd , mbfl_string * result ) {\n switch ( pd -> status ) {\n case 1 : case 2 : case 3 : case 4 : case 7 : case 8 : case 9 : mbfl_convert_filter_devcat ( pd -> conv1_filter , & pd -> tmpdev ) ;\n break ;\n case 5 : case 6 : ( * pd -> deco_filter -> filter_flush ) ( pd -> deco_filter ) ;\n ( * pd -> conv1_filter -> filter_flush ) ( pd -> conv1_filter ) ;\n break ;\n }\n ( * pd -> conv2_filter -> filter_flush ) ( pd -> conv2_filter ) ;\n mbfl_memory_device_reset ( & pd -> tmpdev ) ;\n pd -> status = 0 ;\n return mbfl_memory_device_result ( & pd -> outdev , result ) ;\n }", "idx": 21433}
{"hash": -6119142299306266167, "project": "debian", "size": 28, "label": 0, "functionSource": "static int zexecn ( i_ctx_t * i_ctx_p ) {\n os_ptr op = osp ;\n uint n , i ;\n es_ptr esp_orig ;\n check_int_leu ( * op , max_uint - 1 ) ;\n n = ( uint ) op -> value . intval ;\n check_op ( n + 1 ) ;\n check_estack ( n ) ;\n esp_orig = esp ;\n for ( i = 0 ;\n i < n ;\n ++ i ) {\n const ref * rp = ref_stack_index ( & o_stack , ( long ) ( i + 1 ) ) ;\n if ( ref_type_uses_access ( r_type ( rp ) ) ) {\n if ( ! r_has_attr ( rp , a_execute ) && r_has_attr ( rp , a_executable ) ) {\n esp = esp_orig ;\n return_error ( gs_error_invalidaccess ) ;\n }\n }\n if ( ! r_has_type_attrs ( rp , t_null , a_executable ) ) {\n ++ esp ;\n ref_assign ( esp , rp ) ;\n }\n }\n esfile_check_cache ( ) ;\n pop ( n + 1 ) ;\n return o_push_estack ;\n }", "idx": 21434}
{"hash": 5357882892791796049, "project": "debian", "size": 4, "label": 0, "functionSource": "static inline void e1000e_read_ext_rx_descr ( E1000ECore * core , uint8_t * desc , hwaddr * buff_addr ) {\n union e1000_rx_desc_extended * d = ( union e1000_rx_desc_extended * ) desc ;\n * buff_addr = le64_to_cpu ( d -> read . buffer_addr ) ;\n }", "idx": 21435}
{"hash": -2751047985690578371, "project": "debian", "size": 55, "label": 0, "functionSource": "static unsigned int wiener_map ( unsigned int n ) {\n static struct {\n unsigned int p_n , q_n ;\n }\n t [ ] = {\n {\n 512 , 119 }\n , {\n 768 , 145 }\n , {\n 1024 , 165 }\n , {\n 1280 , 183 }\n , {\n 1536 , 198 }\n , {\n 1792 , 212 }\n , {\n 2048 , 225 }\n , {\n 2304 , 237 }\n , {\n 2560 , 249 }\n , {\n 2816 , 259 }\n , {\n 3072 , 269 }\n , {\n 3328 , 279 }\n , {\n 3584 , 288 }\n , {\n 3840 , 296 }\n , {\n 4096 , 305 }\n , {\n 4352 , 313 }\n , {\n 4608 , 320 }\n , {\n 4864 , 328 }\n , {\n 5120 , 335 }\n , {\n 0 , 0 }\n }\n ;\n int i ;\n for ( i = 0 ;\n t [ i ] . p_n ;\n i ++ ) {\n if ( n <= t [ i ] . p_n ) return t [ i ] . q_n ;\n }\n return n / 8 + 200 ;\n }", "idx": 21436}
{"hash": -3384986069176965684, "project": "chrome", "size": 28, "label": 0, "functionSource": "static int resize_key_frame ( VP8_COMP * cpi ) {\n # if CONFIG_SPATIAL_RESAMPLING VP8_COMMON * cm = & cpi -> common ;\n if ( cpi -> oxcf . allow_spatial_resampling && ( cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) ) {\n int UNINITIALIZED_IS_SAFE ( hr ) , UNINITIALIZED_IS_SAFE ( hs ) ;\n int UNINITIALIZED_IS_SAFE ( vr ) , UNINITIALIZED_IS_SAFE ( vs ) ;\n int new_width , new_height ;\n if ( cpi -> buffer_level < ( cpi -> oxcf . resample_down_water_mark * cpi -> oxcf . optimal_buffer_level / 100 ) ) {\n cm -> horiz_scale = ( cm -> horiz_scale < ONETWO ) ? cm -> horiz_scale + 1 : ONETWO ;\n cm -> vert_scale = ( cm -> vert_scale < ONETWO ) ? cm -> vert_scale + 1 : ONETWO ;\n }\n else if ( cpi -> buffer_level > ( cpi -> oxcf . resample_up_water_mark * cpi -> oxcf . optimal_buffer_level / 100 ) ) {\n cm -> horiz_scale = ( cm -> horiz_scale > NORMAL ) ? cm -> horiz_scale - 1 : NORMAL ;\n cm -> vert_scale = ( cm -> vert_scale > NORMAL ) ? cm -> vert_scale - 1 : NORMAL ;\n }\n Scale2Ratio ( cm -> horiz_scale , & hr , & hs ) ;\n Scale2Ratio ( cm -> vert_scale , & vr , & vs ) ;\n new_width = ( ( hs - 1 ) + ( cpi -> oxcf . Width * hr ) ) / hs ;\n new_height = ( ( vs - 1 ) + ( cpi -> oxcf . Height * vr ) ) / vs ;\n if ( ( cm -> Width != new_width ) || ( cm -> Height != new_height ) ) {\n cm -> Width = new_width ;\n cm -> Height = new_height ;\n vp8_alloc_compressor_data ( cpi ) ;\n scale_and_extend_source ( cpi -> un_scaled_source , cpi ) ;\n return 1 ;\n }\n }\n # endif return 0 ;\n }", "idx": 21437}
{"hash": -3889154245145551951, "project": "debian", "size": 6, "label": 0, "functionSource": "static void * pool_calloc ( size_t count , size_t size ) {\n size_t len = count * size ;\n void * r = pool_alloc ( len ) ;\n memset ( r , 0 , len ) ;\n return r ;\n }", "idx": 21438}
{"hash": 9176142195250515812, "project": "debian", "size": 5, "label": 0, "functionSource": "static void prplcb_roomlist_create ( PurpleRoomlist * list ) {\n struct purple_roomlist_data * rld ;\n list -> ui_data = rld = g_new0 ( struct purple_roomlist_data , 1 ) ;\n rld -> topic = - 1 ;\n }", "idx": 21439}
{"hash": -5249292504513104172, "project": "debian", "size": 5, "label": 0, "functionSource": "char * xmlrpc_double ( char * buf , double value ) {\n * buf = '\\0' ;\n snprintf ( buf , XMLRPC_BUFSIZE , \"<double>%g</double>\" , value ) ;\n return buf ;\n }", "idx": 21440}
{"hash": -141110337504935425, "project": "debian", "size": 22, "label": 0, "functionSource": "static int get_logical_cpus ( AVCodecContext * avctx ) {\n int ret , nb_cpus = 1 ;\n # if HAVE_SCHED_GETAFFINITY && defined ( CPU_COUNT ) cpu_set_t cpuset ;\n CPU_ZERO ( & cpuset ) ;\n ret = sched_getaffinity ( 0 , sizeof ( cpuset ) , & cpuset ) ;\n if ( ! ret ) {\n nb_cpus = CPU_COUNT ( & cpuset ) ;\n }\n # elif HAVE_GETPROCESSAFFINITYMASK DWORD_PTR proc_aff , sys_aff ;\n ret = GetProcessAffinityMask ( GetCurrentProcess ( ) , & proc_aff , & sys_aff ) ;\n if ( ret ) nb_cpus = av_popcount64 ( proc_aff ) ;\n # elif HAVE_SYSCTL && defined ( HW_NCPU ) int mib [ 2 ] = {\n CTL_HW , HW_NCPU }\n ;\n size_t len = sizeof ( nb_cpus ) ;\n ret = sysctl ( mib , 2 , & nb_cpus , & len , NULL , 0 ) ;\n if ( ret == - 1 ) nb_cpus = 0 ;\n # elif HAVE_SYSCONF && defined ( _SC_NPROC_ONLN ) nb_cpus = sysconf ( _SC_NPROC_ONLN ) ;\n # elif HAVE_SYSCONF && defined ( _SC_NPROCESSORS_ONLN ) nb_cpus = sysconf ( _SC_NPROCESSORS_ONLN ) ;\n # endif av_log ( avctx , AV_LOG_DEBUG , \"detected %d logical cores\\n\" , nb_cpus ) ;\n return nb_cpus ;\n }", "idx": 21441}
{"hash": -6552851419396579257, "project": "debian", "size": 8, "label": 0, "functionSource": "static int SpoolssEndPagePrinter_q ( tvbuff_t * tvb , int offset , packet_info * pinfo , proto_tree * tree , dcerpc_info * di , guint8 * drep ) {\n e_ctx_hnd policy_hnd ;\n char * pol_name ;\n offset = dissect_nt_policy_hnd ( tvb , offset , pinfo , tree , di , drep , hf_hnd , & policy_hnd , NULL , FALSE , FALSE ) ;\n dcerpc_fetch_polhnd_data ( & policy_hnd , & pol_name , NULL , NULL , NULL , pinfo -> num ) ;\n if ( pol_name ) col_append_fstr ( pinfo -> cinfo , COL_INFO , \", %s\" , pol_name ) ;\n return offset ;\n }", "idx": 21442}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_VendorIdentification ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_VendorIdentification , VendorIdentification_sequence ) ;\n return offset ;\n }", "idx": 21443}
{"hash": -4527380754569407959, "project": "chrome", "size": 20, "label": 0, "functionSource": "GType hb_gobject_ ## name ## _get_type ( void ) \\ {\n static gsize type_id = 0 ;\n if ( g_once_init_enter ( & type_id ) ) {\n GType id = g_boxed_type_register_static ( g_intern_static_string ( \"hb_\" # name \"_t\" ) , ( GBoxedCopyFunc ) copy_func , ( GBoxedFreeFunc ) free_func ) ;\n g_once_init_leave ( & type_id , id ) ;\n }\n return type_id ;\n \\ }\n # define HB_DEFINE_OBJECT_TYPE ( name ) HB_DEFINE_BOXED_TYPE ( name , hb_ ## name ## _reference , hb_ ## name ## _destroy ) ;\n # define HB_DEFINE_VALUE_TYPE ( name ) static hb_ ## name ## _t * _hb_ ## name ## _reference ( const hb_ ## name ## _t * l ) {\n hb_ ## name ## _t * c = ( hb_ ## name ## _t * ) calloc ( 1 , sizeof ( hb_ ## name ## _t ) ) ;\n if ( unlikely ( ! c ) ) return NULL ;\n * c = * l ;\n return c ;\n }\n static void _hb_ ## name ## _destroy ( hb_ ## name ## _t * l ) {\n free ( l ) ;\n }\n HB_DEFINE_BOXED_TYPE ( name , _hb_ ## name ## _reference , _hb_ ## name ## _destroy ) ;\n HB_DEFINE_OBJECT_TYPE ( buffer ) HB_DEFINE_OBJECT_TYPE ( blob ) HB_DEFINE_OBJECT_TYPE ( face ) HB_DEFINE_OBJECT_TYPE ( font )", "idx": 21444}
{"hash": 2626033973808493247, "project": "chrome", "size": 3, "label": 0, "functionSource": "static struct qcms_modular_transform * qcms_modular_transform_alloc ( ) {\n return calloc ( 1 , sizeof ( struct qcms_modular_transform ) ) ;\n }", "idx": 21445}
{"hash": 4704178797381506498, "project": "debian", "size": 19, "label": 0, "functionSource": "kadm5_ret_t kadm5_delete_principal ( void * server_handle , krb5_principal principal ) {\n unsigned int ret ;\n krb5_db_entry * kdb ;\n osa_princ_ent_rec adb ;\n kadm5_server_handle_t handle = server_handle ;\n CHECK_HANDLE ( server_handle ) ;\n krb5_clear_error_message ( handle -> context ) ;\n if ( principal == NULL ) return EINVAL ;\n if ( ( ret = kdb_get_entry ( handle , principal , & kdb , & adb ) ) ) return ( ret ) ;\n ret = k5_kadm5_hook_remove ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_PRECOMMIT , principal ) ;\n if ( ret ) {\n kdb_free_entry ( handle , kdb , & adb ) ;\n return ret ;\n }\n ret = kdb_delete_entry ( handle , principal ) ;\n kdb_free_entry ( handle , kdb , & adb ) ;\n if ( ret == 0 ) ( void ) k5_kadm5_hook_remove ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_POSTCOMMIT , principal ) ;\n return ret ;\n }", "idx": 21446}
{"hash": -7434014980763120366, "project": "debian", "size": 4, "label": 0, "functionSource": "int dissect_ber_EmbeddedPDV_Type ( gboolean implicit_tag , proto_tree * tree , tvbuff_t * tvb , int offset , asn1_ctx_t * actx , gint hf_id , ber_callback func _U_ ) {\n offset = dissect_ber_tagged_type ( implicit_tag , actx , tree , tvb , offset , hf_id , BER_CLASS_UNI , BER_UNI_TAG_EMBEDDED_PDV , TRUE , dissect_ber_external_U ) ;\n return offset ;\n }", "idx": 21447}
{"hash": -4527380754569407959, "project": "chrome", "size": 5, "label": 0, "functionSource": "static void _hb_ ## name ## _destroy ( hb_ ## name ## _t * l ) {\n free ( l ) ;\n }\n HB_DEFINE_BOXED_TYPE ( name , _hb_ ## name ## _reference , _hb_ ## name ## _destroy ) ;\n HB_DEFINE_OBJECT_TYPE ( buffer ) HB_DEFINE_OBJECT_TYPE ( blob ) HB_DEFINE_OBJECT_TYPE ( face ) HB_DEFINE_OBJECT_TYPE ( font ) HB_DEFINE_OBJECT_TYPE ( font_funcs ) HB_DEFINE_OBJECT_TYPE ( set ) HB_DEFINE_OBJECT_TYPE ( shape_plan ) HB_DEFINE_OBJECT_TYPE ( unicode_funcs ) HB_DEFINE_VALUE_TYPE ( feature ) HB_DEFINE_VALUE_TYPE ( glyph_info ) HB_DEFINE_VALUE_TYPE ( glyph_position ) HB_DEFINE_VALUE_TYPE ( segment_properties )", "idx": 21448}
{"hash": -502031617050384761, "project": "chrome", "size": 12, "label": 0, "functionSource": "int arm_cpu_caps ( void ) {\n int flags ;\n int mask ;\n if ( ! arm_cpu_env_flags ( & flags ) ) {\n return flags ;\n }\n mask = arm_cpu_env_mask ( ) ;\n # if HAVE_EDSP flags |= HAS_EDSP ;\n # endif # if HAVE_MEDIA flags |= HAS_MEDIA ;\n # endif # if HAVE_NEON || HAVE_NEON_ASM flags |= HAS_NEON ;\n # endif return flags & mask ;\n }", "idx": 21449}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_INTEGER_1_8192 ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_constrained_integer ( tvb , offset , actx , tree , hf_index , 1U , 8192U , NULL , FALSE ) ;\n return offset ;\n }", "idx": 21450}
{"hash": -7049333455584635197, "project": "chrome", "size": 12, "label": 1, "functionSource": "static void _UTF16Open ( UConverter * cnv , UConverterLoadArgs * pArgs , UErrorCode * pErrorCode ) {\n if ( UCNV_GET_VERSION ( cnv ) <= 2 ) {\n if ( UCNV_GET_VERSION ( cnv ) == 2 && ! pArgs -> onlyTestIsLoadable ) {\n cnv -> sharedData = ( UConverterSharedData * ) & _UTF16v2Data ;\n uprv_memcpy ( cnv -> subChars , _UTF16v2Data . staticData -> subChar , UCNV_MAX_SUBCHAR_LEN ) ;\n }\n _UTF16Reset ( cnv , UCNV_RESET_BOTH ) ;\n }\n else {\n * pErrorCode = U_ILLEGAL_ARGUMENT_ERROR ;\n }\n }", "idx": 21451}
{"hash": -7237039260294671485, "project": "debian", "size": 3, "label": 0, "functionSource": "static int dissect_nlm1_lock ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , void * data ) {\n return dissect_nlm_lock ( tvb , 0 , pinfo , tree , 1 , ( rpc_call_info_value * ) data ) ;\n }", "idx": 21452}
{"hash": -398565394354770780, "project": "debian", "size": 18, "label": 0, "functionSource": "static int ohci_copy_iso_td ( OHCIState * ohci , uint32_t start_addr , uint32_t end_addr , uint8_t * buf , int len , DMADirection dir ) {\n dma_addr_t ptr , n ;\n ptr = start_addr ;\n n = 0x1000 - ( ptr & 0xfff ) ;\n if ( n > len ) n = len ;\n if ( dma_memory_rw ( ohci -> as , ptr + ohci -> localmem_base , buf , n , dir ) ) {\n return - 1 ;\n }\n if ( n == len ) {\n return 0 ;\n }\n ptr = end_addr & ~ 0xfffu ;\n buf += n ;\n if ( dma_memory_rw ( ohci -> as , ptr + ohci -> localmem_base , buf , len - n , dir ) ) {\n return - 1 ;\n }\n return 0 ;\n }", "idx": 21453}
{"hash": 3672688962041927109, "project": "chrome", "size": 22, "label": 0, "functionSource": "vpx_codec_err_t vpx_codec_enc_init_ver ( vpx_codec_ctx_t * ctx , vpx_codec_iface_t * iface , const vpx_codec_enc_cfg_t * cfg , vpx_codec_flags_t flags , int ver ) {\n vpx_codec_err_t res ;\n if ( ver != VPX_ENCODER_ABI_VERSION ) res = VPX_CODEC_ABI_MISMATCH ;\n else if ( ! ctx || ! iface || ! cfg ) res = VPX_CODEC_INVALID_PARAM ;\n else if ( iface -> abi_version != VPX_CODEC_INTERNAL_ABI_VERSION ) res = VPX_CODEC_ABI_MISMATCH ;\n else if ( ! ( iface -> caps & VPX_CODEC_CAP_ENCODER ) ) res = VPX_CODEC_INCAPABLE ;\n else if ( ( flags & VPX_CODEC_USE_PSNR ) && ! ( iface -> caps & VPX_CODEC_CAP_PSNR ) ) res = VPX_CODEC_INCAPABLE ;\n else if ( ( flags & VPX_CODEC_USE_OUTPUT_PARTITION ) && ! ( iface -> caps & VPX_CODEC_CAP_OUTPUT_PARTITION ) ) res = VPX_CODEC_INCAPABLE ;\n else {\n ctx -> iface = iface ;\n ctx -> name = iface -> name ;\n ctx -> priv = NULL ;\n ctx -> init_flags = flags ;\n ctx -> config . enc = cfg ;\n res = ctx -> iface -> init ( ctx , NULL ) ;\n if ( res ) {\n ctx -> err_detail = ctx -> priv ? ctx -> priv -> err_detail : NULL ;\n vpx_codec_destroy ( ctx ) ;\n }\n }\n return SAVE_STATUS ( ctx , res ) ;\n }", "idx": 21454}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_CommunicationModeCommand ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_CommunicationModeCommand , CommunicationModeCommand_sequence ) ;\n return offset ;\n }", "idx": 21455}
{"hash": 6323824267898511453, "project": "debian", "size": 3, "label": 0, "functionSource": "void fz_cmm_init_link ( fz_context * ctx , fz_icclink * link , const fz_iccprofile * dst , int dst_extras , const fz_iccprofile * src , int src_extras , const fz_iccprofile * prf , const fz_color_params * rend , int cmm_flags , int num_bytes , int copy_spots ) {\n if ( ctx && ctx -> colorspace && ctx -> colorspace -> cmm && ctx -> cmm_instance ) ctx -> colorspace -> cmm -> init_link ( ctx -> cmm_instance , link , dst , dst_extras , src , src_extras , prf , rend , cmm_flags , num_bytes , copy_spots ) ;\n }", "idx": 21456}
{"hash": 8445816931248660591, "project": "debian", "size": 3, "label": 0, "functionSource": "static void spl_ptr_llist_zval_ctor ( spl_ptr_llist_element * elem TSRMLS_DC ) {\n Z_ADDREF_P ( ( zval * ) elem -> data ) ;\n }", "idx": 21457}
{"hash": -3384986069176965684, "project": "chrome", "size": 36, "label": 0, "functionSource": "static void update_rd_ref_frame_probs ( VP8_COMP * cpi ) {\n VP8_COMMON * cm = & cpi -> common ;\n const int * const rfct = cpi -> mb . count_mb_ref_frame_usage ;\n const int rf_intra = rfct [ INTRA_FRAME ] ;\n const int rf_inter = rfct [ LAST_FRAME ] + rfct [ GOLDEN_FRAME ] + rfct [ ALTREF_FRAME ] ;\n if ( cm -> frame_type == KEY_FRAME ) {\n cpi -> prob_intra_coded = 255 ;\n cpi -> prob_last_coded = 128 ;\n cpi -> prob_gf_coded = 128 ;\n }\n else if ( ! ( rf_intra + rf_inter ) ) {\n cpi -> prob_intra_coded = 63 ;\n cpi -> prob_last_coded = 128 ;\n cpi -> prob_gf_coded = 128 ;\n }\n if ( cpi -> oxcf . number_of_layers == 1 ) {\n if ( cpi -> common . refresh_alt_ref_frame ) {\n cpi -> prob_intra_coded += 40 ;\n if ( cpi -> prob_intra_coded > 255 ) cpi -> prob_intra_coded = 255 ;\n cpi -> prob_last_coded = 200 ;\n cpi -> prob_gf_coded = 1 ;\n }\n else if ( cpi -> frames_since_golden == 0 ) {\n cpi -> prob_last_coded = 214 ;\n }\n else if ( cpi -> frames_since_golden == 1 ) {\n cpi -> prob_last_coded = 192 ;\n cpi -> prob_gf_coded = 220 ;\n }\n else if ( cpi -> source_alt_ref_active ) {\n cpi -> prob_gf_coded -= 20 ;\n if ( cpi -> prob_gf_coded < 10 ) cpi -> prob_gf_coded = 10 ;\n }\n if ( ! cpi -> source_alt_ref_active ) cpi -> prob_gf_coded = 255 ;\n }\n }", "idx": 21458}
{"hash": 1760449185745615462, "project": "debian", "size": 20, "label": 0, "functionSource": "TSAction TSHttpSchedule ( TSCont contp , TSHttpTxn txnp , ink_hrtime timeout ) {\n sdk_assert ( sdk_sanity_check_iocore_structure ( contp ) == TS_SUCCESS ) ;\n FORCE_PLUGIN_SCOPED_MUTEX ( contp ) ;\n INKContInternal * i = ( INKContInternal * ) contp ;\n if ( ink_atomic_increment ( ( int * ) & i -> m_event_count , 1 ) < 0 ) {\n ink_assert ( ! \"not reached\" ) ;\n }\n TSAction action ;\n Continuation * cont = ( Continuation * ) contp ;\n HttpSM * sm = ( HttpSM * ) txnp ;\n sm -> set_http_schedule ( cont ) ;\n if ( timeout == 0 ) {\n action = reinterpret_cast < TSAction > ( eventProcessor . schedule_imm ( sm , ET_NET ) ) ;\n }\n else {\n action = reinterpret_cast < TSAction > ( eventProcessor . schedule_in ( sm , HRTIME_MSECONDS ( timeout ) , ET_NET ) ) ;\n }\n action = ( TSAction ) ( ( uintptr_t ) action | 0x1 ) ;\n return action ;\n }", "idx": 21459}
{"hash": -673406620978847526, "project": "chrome", "size": 17, "label": 0, "functionSource": "TEST_F ( WebFrameSimTest , DisplayNoneIFrameHasNoLayoutObjects ) {\n SimRequest main_resource ( \"https://example.com/test.html\" , \"text/html\" ) ;\n SimRequest frame_resource ( \"https://example.com/frame.html\" , \"text/html\" ) ;\n LoadURL ( \"https://example.com/test.html\" ) ;\n main_resource . Complete ( \"<!DOCTYPE html>\" \"<iframe src=frame.html style='display: none'></iframe>\" ) ;\n frame_resource . Complete ( \"<!DOCTYPE html>\" \"<html><body>This is a visible iframe.</body></html>\" ) ;\n Element * element = GetDocument ( ) . QuerySelector ( \"iframe\" ) ;\n HTMLFrameOwnerElement * frame_owner_element = ToHTMLFrameOwnerElement ( element ) ;\n Document * iframe_doc = frame_owner_element -> contentDocument ( ) ;\n EXPECT_FALSE ( iframe_doc -> documentElement ( ) -> GetLayoutObject ( ) ) ;\n element -> SetInlineStyleProperty ( CSSPropertyDisplay , CSSValueBlock ) ;\n Compositor ( ) . BeginFrame ( ) ;\n EXPECT_TRUE ( iframe_doc -> documentElement ( ) -> GetLayoutObject ( ) ) ;\n element -> SetInlineStyleProperty ( CSSPropertyDisplay , CSSValueNone ) ;\n Compositor ( ) . BeginFrame ( ) ;\n EXPECT_FALSE ( iframe_doc -> documentElement ( ) -> GetLayoutObject ( ) ) ;\n }", "idx": 21460}
{"hash": -3889154245145551951, "project": "debian", "size": 14, "label": 0, "functionSource": "static int validate_raw_date ( const char * src , struct strbuf * result ) {\n const char * orig_src = src ;\n char * endp ;\n unsigned long num ;\n errno = 0 ;\n num = strtoul ( src , & endp , 10 ) ;\n if ( errno || endp == src || * endp != ' ' ) return - 1 ;\n src = endp + 1 ;\n if ( * src != '-' && * src != '+' ) return - 1 ;\n num = strtoul ( src + 1 , & endp , 10 ) ;\n if ( errno || endp == src + 1 || * endp || 1400 < num ) return - 1 ;\n strbuf_addstr ( result , orig_src ) ;\n return 0 ;\n }", "idx": 21461}
{"hash": 4704178797381506498, "project": "debian", "size": 149, "label": 0, "functionSource": "kadm5_ret_t kadm5_setkey_principal_3 ( void * server_handle , krb5_principal principal , krb5_boolean keepold , int n_ks_tuple , krb5_key_salt_tuple * ks_tuple , krb5_keyblock * keyblocks , int n_keys ) {\n krb5_db_entry * kdb ;\n osa_princ_ent_rec adb ;\n krb5_int32 now ;\n kadm5_policy_ent_rec pol ;\n krb5_key_data * old_key_data ;\n int n_old_keys ;\n int i , j , k , kvno , ret ;\n krb5_boolean have_pol = FALSE ;\n # if 0 int last_pwd ;\n # endif kadm5_server_handle_t handle = server_handle ;\n krb5_boolean similar ;\n krb5_keysalt keysalt ;\n krb5_key_data tmp_key_data ;\n krb5_key_data * tptr ;\n krb5_keyblock * act_mkey ;\n krb5_key_salt_tuple * ks_from_keys = NULL ;\n CHECK_HANDLE ( server_handle ) ;\n krb5_clear_error_message ( handle -> context ) ;\n if ( principal == NULL || keyblocks == NULL ) return EINVAL ;\n if ( hist_princ && ( ( krb5_principal_compare ( handle -> context , principal , hist_princ ) ) == TRUE ) ) return KADM5_PROTECT_PRINCIPAL ;\n if ( ( ret = kdb_get_entry ( handle , principal , & kdb , & adb ) ) ) return ( ret ) ;\n if ( ! n_ks_tuple ) {\n ret = make_ks_from_keys ( handle -> context , n_keys , keyblocks , & ks_from_keys ) ;\n if ( ret ) goto done ;\n ret = apply_keysalt_policy ( handle , adb . policy , n_keys , ks_from_keys , NULL , NULL ) ;\n free ( ks_from_keys ) ;\n }\n else {\n ret = apply_keysalt_policy ( handle , adb . policy , n_ks_tuple , ks_tuple , NULL , NULL ) ;\n }\n if ( ret ) goto done ;\n for ( i = 0 ;\n i < n_keys ;\n i ++ ) {\n for ( j = i + 1 ;\n j < n_keys ;\n j ++ ) {\n if ( ( ret = krb5_c_enctype_compare ( handle -> context , keyblocks [ i ] . enctype , keyblocks [ j ] . enctype , & similar ) ) ) return ( ret ) ;\n if ( similar ) {\n if ( n_ks_tuple ) {\n if ( ks_tuple [ i ] . ks_salttype == ks_tuple [ j ] . ks_salttype ) return KADM5_SETKEY_DUP_ENCTYPES ;\n }\n else return KADM5_SETKEY_DUP_ENCTYPES ;\n }\n }\n }\n if ( n_ks_tuple && n_ks_tuple != n_keys ) return KADM5_SETKEY3_ETYPE_MISMATCH ;\n for ( kvno = 0 , i = 0 ;\n i < kdb -> n_key_data ;\n i ++ ) if ( kdb -> key_data [ i ] . key_data_kvno > kvno ) kvno = kdb -> key_data [ i ] . key_data_kvno ;\n if ( keepold ) {\n old_key_data = kdb -> key_data ;\n n_old_keys = kdb -> n_key_data ;\n }\n else {\n if ( kdb -> key_data != NULL ) cleanup_key_data ( handle -> context , kdb -> n_key_data , kdb -> key_data ) ;\n n_old_keys = 0 ;\n old_key_data = NULL ;\n }\n kdb -> key_data = krb5_db_alloc ( handle -> context , NULL , ( n_keys + n_old_keys + 1 ) * sizeof ( krb5_key_data ) ) ;\n if ( kdb -> key_data == NULL ) {\n ret = ENOMEM ;\n goto done ;\n }\n memset ( kdb -> key_data , 0 , ( n_keys + n_old_keys ) * sizeof ( krb5_key_data ) ) ;\n kdb -> n_key_data = 0 ;\n for ( i = 0 ;\n i < n_keys ;\n i ++ ) {\n if ( n_ks_tuple ) {\n keysalt . type = ks_tuple [ i ] . ks_salttype ;\n keysalt . data . length = 0 ;\n keysalt . data . data = NULL ;\n if ( ks_tuple [ i ] . ks_enctype != keyblocks [ i ] . enctype ) {\n ret = KADM5_SETKEY3_ETYPE_MISMATCH ;\n goto done ;\n }\n }\n memset ( & tmp_key_data , 0 , sizeof ( tmp_key_data ) ) ;\n ret = kdb_get_active_mkey ( handle , NULL , & act_mkey ) ;\n if ( ret ) goto done ;\n ret = krb5_dbe_encrypt_key_data ( handle -> context , act_mkey , & keyblocks [ i ] , n_ks_tuple ? & keysalt : NULL , kvno + 1 , & tmp_key_data ) ;\n if ( ret ) goto done ;\n tptr = & kdb -> key_data [ i ] ;\n tptr -> key_data_ver = tmp_key_data . key_data_ver ;\n tptr -> key_data_kvno = tmp_key_data . key_data_kvno ;\n for ( k = 0 ;\n k < tmp_key_data . key_data_ver ;\n k ++ ) {\n tptr -> key_data_type [ k ] = tmp_key_data . key_data_type [ k ] ;\n tptr -> key_data_length [ k ] = tmp_key_data . key_data_length [ k ] ;\n if ( tmp_key_data . key_data_contents [ k ] ) {\n tptr -> key_data_contents [ k ] = krb5_db_alloc ( handle -> context , NULL , tmp_key_data . key_data_length [ k ] ) ;\n if ( tptr -> key_data_contents [ k ] == NULL ) {\n int i1 ;\n for ( i1 = k ;\n i1 < tmp_key_data . key_data_ver ;\n i1 ++ ) {\n if ( tmp_key_data . key_data_contents [ i1 ] ) {\n memset ( tmp_key_data . key_data_contents [ i1 ] , 0 , tmp_key_data . key_data_length [ i1 ] ) ;\n free ( tmp_key_data . key_data_contents [ i1 ] ) ;\n }\n }\n ret = ENOMEM ;\n goto done ;\n }\n memcpy ( tptr -> key_data_contents [ k ] , tmp_key_data . key_data_contents [ k ] , tmp_key_data . key_data_length [ k ] ) ;\n memset ( tmp_key_data . key_data_contents [ k ] , 0 , tmp_key_data . key_data_length [ k ] ) ;\n free ( tmp_key_data . key_data_contents [ k ] ) ;\n tmp_key_data . key_data_contents [ k ] = NULL ;\n }\n }\n kdb -> n_key_data ++ ;\n }\n for ( i = 0 ;\n i < n_old_keys ;\n i ++ ) {\n kdb -> key_data [ i + n_keys ] = old_key_data [ i ] ;\n memset ( & old_key_data [ i ] , 0 , sizeof ( krb5_key_data ) ) ;\n kdb -> n_key_data ++ ;\n }\n if ( old_key_data ) krb5_db_free ( handle -> context , old_key_data ) ;\n kdb -> attributes &= ~ KRB5_KDB_REQUIRES_PWCHANGE ;\n if ( ( ret = krb5_timeofday ( handle -> context , & now ) ) ) goto done ;\n if ( ( adb . aux_attributes & KADM5_POLICY ) ) {\n ret = get_policy ( handle , adb . policy , & pol , & have_pol ) ;\n if ( ret ) goto done ;\n }\n if ( have_pol ) {\n # if 0 if ( ret = krb5_dbe_lookup_last_pwd_change ( handle -> context , kdb , & last_pwd ) ) goto done ;\n if ( ( now - last_pwd ) < pol . pw_min_life && ! ( kdb -> attributes & KRB5_KDB_REQUIRES_PWCHANGE ) ) {\n ret = KADM5_PASS_TOOSOON ;\n goto done ;\n }\n # endif if ( pol . pw_max_life ) kdb -> pw_expiration = now + pol . pw_max_life ;\n else kdb -> pw_expiration = 0 ;\n }\n else {\n kdb -> pw_expiration = 0 ;\n }\n if ( ( ret = krb5_dbe_update_last_pwd_change ( handle -> context , kdb , now ) ) ) goto done ;\n kdb -> fail_auth_count = 0 ;\n if ( ( ret = kdb_put_entry ( handle , kdb , & adb ) ) ) goto done ;\n ret = KADM5_OK ;\n done : kdb_free_entry ( handle , kdb , & adb ) ;\n if ( have_pol ) kadm5_free_policy_ent ( handle -> lhandle , & pol ) ;\n return ret ;\n }", "idx": 21462}
{"hash": 1750726979859153417, "project": "debian", "size": 20, "label": 0, "functionSource": "static PyObject * authGSSClientClean ( PyObject * self , PyObject * args ) {\n gss_client_state * state ;\n PyObject * pystate ;\n int result = 0 ;\n if ( ! PyArg_ParseTuple ( args , \"O\" , & pystate ) ) return NULL ;\n # if PY_MAJOR_VERSION >= 3 if ( ! PyCapsule_CheckExact ( pystate ) ) {\n # else if ( ! PyCObject_Check ( pystate ) ) {\n # endif PyErr_SetString ( PyExc_TypeError , \"Expected a context object\" ) ;\n return NULL ;\n }\n # if PY_MAJOR_VERSION >= 3 state = PyCapsule_GetPointer ( pystate , NULL ) ;\n # else state = ( gss_client_state * ) PyCObject_AsVoidPtr ( pystate ) ;\n # endif if ( state != NULL ) {\n result = authenticate_gss_client_clean ( state ) ;\n free ( state ) ;\n # if PY_MAJOR_VERSION >= 3 PyCapsule_SetPointer ( pystate , NULL ) ;\n # else PyCObject_SetVoidPtr ( pystate , NULL ) ;\n # endif }\n return Py_BuildValue ( \"i\" , result ) ;\n }", "idx": 21463}
{"hash": -942846491258578486, "project": "debian", "size": 31, "label": 0, "functionSource": "static enum nss_status internal_getent ( struct STRUCTURE * result , char * buffer , size_t buflen , int * errnop H_ERRNO_PROTO EXTRA_ARGS_DECL ) {\n char * p ;\n struct parser_data * data = ( void * ) buffer ;\n size_t linebuflen = buffer + buflen - data -> linebuffer ;\n int parse_result ;\n if ( buflen < sizeof * data + 2 ) {\n * errnop = ERANGE ;\n H_ERRNO_SET ( NETDB_INTERNAL ) ;\n return NSS_STATUS_TRYAGAIN ;\n }\n do {\n get_contents_ret r = get_contents ( data -> linebuffer , linebuflen , stream ) ;\n if ( r == gcr_error ) {\n H_ERRNO_SET ( HOST_NOT_FOUND ) ;\n return NSS_STATUS_NOTFOUND ;\n }\n if ( r == gcr_overflow ) {\n * errnop = ERANGE ;\n H_ERRNO_SET ( NETDB_INTERNAL ) ;\n return NSS_STATUS_TRYAGAIN ;\n }\n p = data -> linebuffer ;\n while ( isspace ( * p ) ) ++ p ;\n }\n while ( * p == '\\0' || * p == '#' || ! ( parse_result = parse_line ( p , result , data , buflen , errnop EXTRA_ARGS ) ) ) ;\n if ( __glibc_unlikely ( parse_result == - 1 ) ) {\n H_ERRNO_SET ( NETDB_INTERNAL ) ;\n return NSS_STATUS_TRYAGAIN ;\n }\n return NSS_STATUS_SUCCESS ;\n }", "idx": 21464}
{"hash": 4489017523191997023, "project": "debian", "size": 9, "label": 0, "functionSource": "static int dissect_H323_UserInformation_PDU ( tvbuff_t * tvb _U_ , packet_info * pinfo _U_ , proto_tree * tree _U_ , void * data _U_ ) {\n int offset = 0 ;\n asn1_ctx_t asn1_ctx ;\n asn1_ctx_init ( & asn1_ctx , ASN1_ENC_PER , TRUE , pinfo ) ;\n offset = dissect_h225_H323_UserInformation ( tvb , offset , & asn1_ctx , tree , hf_h225_H323_UserInformation_PDU ) ;\n offset += 7 ;\n offset >>= 3 ;\n return offset ;\n }", "idx": 21465}
{"hash": 6017095990848568360, "project": "chrome", "size": 4, "label": 0, "functionSource": "void usage_exit ( ) {\n fprintf ( stderr , \"Usage: %s <codec> <width> <height> <infile> <outfile>\\n\" , exec_name ) ;\n exit ( EXIT_FAILURE ) ;\n }", "idx": 21466}
{"hash": -1929262071302712016, "project": "debian", "size": 5, "label": 0, "functionSource": "static void * Type_LUTB2A_Dup ( struct _cms_typehandler_struct * self , const void * Ptr , cmsUInt32Number n ) {\n return ( void * ) cmsPipelineDup ( ( cmsPipeline * ) Ptr ) ;\n cmsUNUSED_PARAMETER ( n ) ;\n cmsUNUSED_PARAMETER ( self ) ;\n }", "idx": 21467}
{"hash": -8919449269326401539, "project": "debian", "size": 13, "label": 0, "functionSource": "static void dissect_mcast_byte ( proto_tree * tree , tvbuff_t * tvb , int offset , packet_info * pinfo _U_ ) {\n proto_item * mcast_item ;\n proto_tree * mcast_tree ;\n # if 0 guint8 mcast_byte ;\n mcast_byte = tvb_get_guint8 ( tvb , offset ) ;\n # endif mcast_item = proto_tree_add_item ( tree , hf_cipsafety_mcast_byte , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ;\n mcast_tree = proto_item_add_subtree ( mcast_item , ett_cipsafety_mcast_byte ) ;\n proto_tree_add_item ( mcast_tree , hf_cipsafety_mcast_byte_consumer_num , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ;\n proto_tree_add_item ( mcast_tree , hf_cipsafety_mcast_byte_reserved1 , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ;\n proto_tree_add_item ( mcast_tree , hf_cipsafety_mcast_byte_mai , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ;\n proto_tree_add_item ( mcast_tree , hf_cipsafety_mcast_byte_reserved2 , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ;\n proto_tree_add_item ( mcast_tree , hf_cipsafety_mcast_byte_parity_even , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ;\n }", "idx": 21468}
{"hash": 2895622461494525400, "project": "debian", "size": 44, "label": 0, "functionSource": "static void test_bug3117 ( ) {\n MYSQL_STMT * stmt ;\n MYSQL_BIND buffer ;\n longlong lii ;\n ulong length ;\n my_bool is_null ;\n int rc ;\n myheader ( \"test_bug3117\" ) ;\n rc = mysql_query ( mysql , \"DROP TABLE IF EXISTS t1\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"CREATE TABLE t1 (id int auto_increment primary key)\" ) ;\n myquery ( rc ) ;\n stmt = mysql_simple_prepare ( mysql , \"SELECT LAST_INSERT_ID()\" ) ;\n check_stmt ( stmt ) ;\n rc = mysql_query ( mysql , \"INSERT INTO t1 VALUES (NULL)\" ) ;\n myquery ( rc ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n memset ( & buffer , 0 , sizeof ( buffer ) ) ;\n buffer . buffer_type = MYSQL_TYPE_LONGLONG ;\n buffer . buffer_length = sizeof ( lii ) ;\n buffer . buffer = ( void * ) & lii ;\n buffer . length = & length ;\n buffer . is_null = & is_null ;\n rc = mysql_stmt_bind_result ( stmt , & buffer ) ;\n check_execute ( stmt , rc ) ;\n rc = mysql_stmt_store_result ( stmt ) ;\n check_execute ( stmt , rc ) ;\n rc = mysql_stmt_fetch ( stmt ) ;\n check_execute ( stmt , rc ) ;\n DIE_UNLESS ( is_null == 0 && lii == 1 ) ;\n if ( ! opt_silent ) fprintf ( stdout , \"\\n\\tLAST_INSERT_ID()= 1 ok\\n\" ) ;\n rc = mysql_query ( mysql , \"INSERT INTO t1 VALUES (NULL)\" ) ;\n myquery ( rc ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n rc = mysql_stmt_fetch ( stmt ) ;\n check_execute ( stmt , rc ) ;\n DIE_UNLESS ( is_null == 0 && lii == 2 ) ;\n if ( ! opt_silent ) fprintf ( stdout , \"\\tLAST_INSERT_ID()= 2 ok\\n\" ) ;\n mysql_stmt_close ( stmt ) ;\n rc = mysql_query ( mysql , \"DROP TABLE t1\" ) ;\n myquery ( rc ) ;\n }", "idx": 21469}
{"hash": -5697857125570093892, "project": "chrome", "size": 14, "label": 0, "functionSource": "static const char * ultag_getExtensionValue ( const ULanguageTag * langtag , int32_t idx ) {\n const char * val = NULL ;\n ExtensionListEntry * cur = langtag -> extensions ;\n int32_t i = 0 ;\n while ( cur ) {\n if ( i == idx ) {\n val = cur -> value ;\n break ;\n }\n cur = cur -> next ;\n i ++ ;\n }\n return val ;\n }", "idx": 21470}
{"hash": 4313735399044135249, "project": "debian", "size": 12, "label": 0, "functionSource": "int psf_fopen ( SF_PRIVATE * psf ) {\n psf -> error = 0 ;\n psf -> file . filedes = psf_open_fd ( & psf -> file ) ;\n if ( psf -> file . filedes == - SFE_BAD_OPEN_MODE ) {\n psf -> error = SFE_BAD_OPEN_MODE ;\n psf -> file . filedes = - 1 ;\n return psf -> error ;\n }\n ;\n if ( psf -> file . filedes == - 1 ) psf_log_syserr ( psf , errno ) ;\n return psf -> error ;\n }", "idx": 21471}
{"hash": 5400542917484463750, "project": "chrome", "size": 35, "label": 0, "functionSource": "void assign_layer_bitrates ( const SvcContext * svc_ctx , vpx_codec_enc_cfg_t * const enc_cfg ) {\n int i ;\n const SvcInternal * const si = get_const_svc_internal ( svc_ctx ) ;\n if ( si -> bitrates [ 0 ] != 0 ) {\n enc_cfg -> rc_target_bitrate = 0 ;\n for ( i = 0 ;\n i < svc_ctx -> spatial_layers ;\n ++ i ) {\n enc_cfg -> ss_target_bitrate [ i ] = ( unsigned int ) si -> bitrates [ i ] ;\n enc_cfg -> rc_target_bitrate += si -> bitrates [ i ] ;\n }\n }\n else {\n float total = 0 ;\n float alloc_ratio [ VPX_SS_MAX_LAYERS ] = {\n 0 }\n ;\n for ( i = 0 ;\n i < svc_ctx -> spatial_layers ;\n ++ i ) {\n if ( si -> svc_params . scaling_factor_den [ i ] > 0 ) {\n alloc_ratio [ i ] = ( float ) ( si -> svc_params . scaling_factor_num [ i ] * 1.0 / si -> svc_params . scaling_factor_den [ i ] ) ;\n alloc_ratio [ i ] *= alloc_ratio [ i ] ;\n total += alloc_ratio [ i ] ;\n }\n }\n for ( i = 0 ;\n i < svc_ctx -> spatial_layers ;\n ++ i ) {\n if ( total > 0 ) {\n enc_cfg -> ss_target_bitrate [ i ] = ( unsigned int ) ( enc_cfg -> rc_target_bitrate * alloc_ratio [ i ] / total ) ;\n }\n }\n }\n }", "idx": 21472}
{"hash": -6442559759273439153, "project": "debian", "size": 202, "label": 1, "functionSource": "static int mss2_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n MSS2Context * ctx = avctx -> priv_data ;\n MSS12Context * c = & ctx -> c ;\n GetBitContext gb ;\n GetByteContext gB ;\n ArithCoder acoder ;\n int keyframe , has_wmv9 , has_mv , is_rle , is_555 , ret ;\n Rectangle wmv9rects [ MAX_WMV9_RECTANGLES ] , * r ;\n int used_rects = 0 , i , implicit_rect = 0 , av_uninit ( wmv9_mask ) ;\n av_assert0 ( FF_INPUT_BUFFER_PADDING_SIZE >= ARITH2_PADDING + ( MIN_CACHE_BITS + 7 ) / 8 ) ;\n init_get_bits ( & gb , buf , buf_size * 8 ) ;\n if ( keyframe = get_bits1 ( & gb ) ) skip_bits ( & gb , 7 ) ;\n has_wmv9 = get_bits1 ( & gb ) ;\n has_mv = keyframe ? 0 : get_bits1 ( & gb ) ;\n is_rle = get_bits1 ( & gb ) ;\n is_555 = is_rle && get_bits1 ( & gb ) ;\n if ( c -> slice_split > 0 ) ctx -> split_position = c -> slice_split ;\n else if ( c -> slice_split < 0 ) {\n if ( get_bits1 ( & gb ) ) {\n if ( get_bits1 ( & gb ) ) {\n if ( get_bits1 ( & gb ) ) ctx -> split_position = get_bits ( & gb , 16 ) ;\n else ctx -> split_position = get_bits ( & gb , 12 ) ;\n }\n else ctx -> split_position = get_bits ( & gb , 8 ) << 4 ;\n }\n else {\n if ( keyframe ) ctx -> split_position = avctx -> height / 2 ;\n }\n }\n else ctx -> split_position = avctx -> height ;\n if ( c -> slice_split && ( ctx -> split_position < 1 - is_555 || ctx -> split_position > avctx -> height - 1 ) ) return AVERROR_INVALIDDATA ;\n align_get_bits ( & gb ) ;\n buf += get_bits_count ( & gb ) >> 3 ;\n buf_size -= get_bits_count ( & gb ) >> 3 ;\n if ( buf_size < 1 ) return AVERROR_INVALIDDATA ;\n if ( is_555 && ( has_wmv9 || has_mv || c -> slice_split && ctx -> split_position ) ) return AVERROR_INVALIDDATA ;\n avctx -> pix_fmt = is_555 ? AV_PIX_FMT_RGB555 : AV_PIX_FMT_RGB24 ;\n if ( ctx -> pic . data [ 0 ] && ctx -> pic . format != avctx -> pix_fmt ) avctx -> release_buffer ( avctx , & ctx -> pic ) ;\n if ( has_wmv9 ) {\n bytestream2_init ( & gB , buf , buf_size + ARITH2_PADDING ) ;\n arith2_init ( & acoder , & gB ) ;\n implicit_rect = ! arith2_get_bit ( & acoder ) ;\n while ( arith2_get_bit ( & acoder ) ) {\n if ( used_rects == MAX_WMV9_RECTANGLES ) return AVERROR_INVALIDDATA ;\n r = & wmv9rects [ used_rects ] ;\n if ( ! used_rects ) r -> x = arith2_get_number ( & acoder , avctx -> width ) ;\n else r -> x = arith2_get_number ( & acoder , avctx -> width - wmv9rects [ used_rects - 1 ] . x ) + wmv9rects [ used_rects - 1 ] . x ;\n r -> y = arith2_get_number ( & acoder , avctx -> height ) ;\n r -> w = arith2_get_number ( & acoder , avctx -> width - r -> x ) + 1 ;\n r -> h = arith2_get_number ( & acoder , avctx -> height - r -> y ) + 1 ;\n used_rects ++ ;\n }\n if ( implicit_rect && used_rects ) {\n av_log ( avctx , AV_LOG_ERROR , \"implicit_rect && used_rects > 0\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( implicit_rect ) {\n wmv9rects [ 0 ] . x = 0 ;\n wmv9rects [ 0 ] . y = 0 ;\n wmv9rects [ 0 ] . w = avctx -> width ;\n wmv9rects [ 0 ] . h = avctx -> height ;\n used_rects = 1 ;\n }\n for ( i = 0 ;\n i < used_rects ;\n i ++ ) {\n if ( ! implicit_rect && arith2_get_bit ( & acoder ) ) {\n av_log ( avctx , AV_LOG_ERROR , \"Unexpected grandchildren\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( ! i ) {\n wmv9_mask = arith2_get_bit ( & acoder ) - 1 ;\n if ( ! wmv9_mask ) wmv9_mask = arith2_get_number ( & acoder , 256 ) ;\n }\n wmv9rects [ i ] . coded = arith2_get_number ( & acoder , 2 ) ;\n }\n buf += arith2_get_consumed_bytes ( & acoder ) ;\n buf_size -= arith2_get_consumed_bytes ( & acoder ) ;\n if ( buf_size < 1 ) return AVERROR_INVALIDDATA ;\n }\n c -> mvX = c -> mvY = 0 ;\n if ( keyframe && ! is_555 ) {\n if ( ( i = decode_pal_v2 ( c , buf , buf_size ) ) < 0 ) return AVERROR_INVALIDDATA ;\n buf += i ;\n buf_size -= i ;\n }\n else if ( has_mv ) {\n buf += 4 ;\n buf_size -= 4 ;\n if ( buf_size < 1 ) return AVERROR_INVALIDDATA ;\n c -> mvX = AV_RB16 ( buf - 4 ) - avctx -> width ;\n c -> mvY = AV_RB16 ( buf - 2 ) - avctx -> height ;\n }\n if ( c -> mvX < 0 || c -> mvY < 0 ) {\n FFSWAP ( AVFrame , ctx -> pic , ctx -> last_pic ) ;\n FFSWAP ( uint8_t * , c -> pal_pic , c -> last_pal_pic ) ;\n if ( ctx -> pic . data [ 0 ] ) avctx -> release_buffer ( avctx , & ctx -> pic ) ;\n ctx -> pic . reference = 3 ;\n ctx -> pic . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_READABLE | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE ;\n if ( ( ret = ff_get_buffer ( avctx , & ctx -> pic ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n if ( ctx -> last_pic . data [ 0 ] ) {\n av_assert0 ( ctx -> pic . linesize [ 0 ] == ctx -> last_pic . linesize [ 0 ] ) ;\n c -> last_rgb_pic = ctx -> last_pic . data [ 0 ] + ctx -> last_pic . linesize [ 0 ] * ( avctx -> height - 1 ) ;\n }\n else {\n av_log ( avctx , AV_LOG_ERROR , \"Missing keyframe\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n }\n else {\n if ( ctx -> last_pic . data [ 0 ] ) avctx -> release_buffer ( avctx , & ctx -> last_pic ) ;\n ctx -> pic . reference = 3 ;\n ctx -> pic . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_READABLE | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE ;\n if ( ( ret = avctx -> reget_buffer ( avctx , & ctx -> pic ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"reget_buffer() failed\\n\" ) ;\n return ret ;\n }\n c -> last_rgb_pic = NULL ;\n }\n c -> rgb_pic = ctx -> pic . data [ 0 ] + ctx -> pic . linesize [ 0 ] * ( avctx -> height - 1 ) ;\n c -> rgb_stride = - ctx -> pic . linesize [ 0 ] ;\n ctx -> pic . key_frame = keyframe ;\n ctx -> pic . pict_type = keyframe ? AV_PICTURE_TYPE_I : AV_PICTURE_TYPE_P ;\n if ( is_555 ) {\n bytestream2_init ( & gB , buf , buf_size ) ;\n if ( decode_555 ( & gB , ( uint16_t * ) c -> rgb_pic , c -> rgb_stride >> 1 , keyframe , avctx -> width , avctx -> height ) ) return AVERROR_INVALIDDATA ;\n buf_size -= bytestream2_tell ( & gB ) ;\n }\n else {\n if ( keyframe ) {\n c -> corrupted = 0 ;\n ff_mss12_slicecontext_reset ( & ctx -> sc [ 0 ] ) ;\n if ( c -> slice_split ) ff_mss12_slicecontext_reset ( & ctx -> sc [ 1 ] ) ;\n }\n if ( is_rle ) {\n init_get_bits ( & gb , buf , buf_size * 8 ) ;\n if ( ret = decode_rle ( & gb , c -> pal_pic , c -> pal_stride , c -> rgb_pic , c -> rgb_stride , c -> pal , keyframe , ctx -> split_position , 0 , avctx -> width , avctx -> height ) ) return ret ;\n align_get_bits ( & gb ) ;\n if ( c -> slice_split ) if ( ret = decode_rle ( & gb , c -> pal_pic , c -> pal_stride , c -> rgb_pic , c -> rgb_stride , c -> pal , keyframe , ctx -> split_position , 1 , avctx -> width , avctx -> height ) ) return ret ;\n align_get_bits ( & gb ) ;\n buf += get_bits_count ( & gb ) >> 3 ;\n buf_size -= get_bits_count ( & gb ) >> 3 ;\n }\n else if ( ! implicit_rect || wmv9_mask != - 1 ) {\n if ( c -> corrupted ) return AVERROR_INVALIDDATA ;\n bytestream2_init ( & gB , buf , buf_size + ARITH2_PADDING ) ;\n arith2_init ( & acoder , & gB ) ;\n c -> keyframe = keyframe ;\n if ( c -> corrupted = ff_mss12_decode_rect ( & ctx -> sc [ 0 ] , & acoder , 0 , 0 , avctx -> width , ctx -> split_position ) ) return AVERROR_INVALIDDATA ;\n buf += arith2_get_consumed_bytes ( & acoder ) ;\n buf_size -= arith2_get_consumed_bytes ( & acoder ) ;\n if ( c -> slice_split ) {\n if ( buf_size < 1 ) return AVERROR_INVALIDDATA ;\n bytestream2_init ( & gB , buf , buf_size + ARITH2_PADDING ) ;\n arith2_init ( & acoder , & gB ) ;\n if ( c -> corrupted = ff_mss12_decode_rect ( & ctx -> sc [ 1 ] , & acoder , 0 , ctx -> split_position , avctx -> width , avctx -> height - ctx -> split_position ) ) return AVERROR_INVALIDDATA ;\n buf += arith2_get_consumed_bytes ( & acoder ) ;\n buf_size -= arith2_get_consumed_bytes ( & acoder ) ;\n }\n }\n else memset ( c -> pal_pic , 0 , c -> pal_stride * avctx -> height ) ;\n }\n if ( has_wmv9 ) {\n for ( i = 0 ;\n i < used_rects ;\n i ++ ) {\n int x = wmv9rects [ i ] . x ;\n int y = wmv9rects [ i ] . y ;\n int w = wmv9rects [ i ] . w ;\n int h = wmv9rects [ i ] . h ;\n if ( wmv9rects [ i ] . coded ) {\n int WMV9codedFrameSize ;\n if ( buf_size < 4 || ! ( WMV9codedFrameSize = AV_RL24 ( buf ) ) ) return AVERROR_INVALIDDATA ;\n if ( ret = decode_wmv9 ( avctx , buf + 3 , buf_size - 3 , x , y , w , h , wmv9_mask ) ) return ret ;\n buf += WMV9codedFrameSize + 3 ;\n buf_size -= WMV9codedFrameSize + 3 ;\n }\n else {\n uint8_t * dst = c -> rgb_pic + y * c -> rgb_stride + x * 3 ;\n if ( wmv9_mask != - 1 ) {\n ctx -> dsp . mss2_gray_fill_masked ( dst , c -> rgb_stride , wmv9_mask , c -> pal_pic + y * c -> pal_stride + x , c -> pal_stride , w , h ) ;\n }\n else {\n do {\n memset ( dst , 0x80 , w * 3 ) ;\n dst += c -> rgb_stride ;\n }\n while ( -- h ) ;\n }\n }\n }\n }\n if ( buf_size ) av_log ( avctx , AV_LOG_WARNING , \"buffer not fully consumed\\n\" ) ;\n * got_frame = 1 ;\n * ( AVFrame * ) data = ctx -> pic ;\n return avpkt -> size ;\n }", "idx": 21473}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_T84Profile ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_T84Profile , T84Profile_choice , NULL ) ;\n return offset ;\n }", "idx": 21474}
{"hash": -866921002076081979, "project": "debian", "size": 17, "label": 0, "functionSource": "REGRESSION_TEST ( SDK_API_TSIOBufferStart ) ( RegressionTest * test , int , int * pstatus ) {\n bool test_passed = false ;\n * pstatus = REGRESSION_TEST_INPROGRESS ;\n TSIOBuffer bufp = TSIOBufferSizedCreate ( TS_IOBUFFER_SIZE_INDEX_4K ) ;\n TSIOBufferReader readerp = TSIOBufferReaderAlloc ( bufp ) ;\n if ( TSIOBufferStart ( bufp ) == TSIOBufferReaderStart ( readerp ) ) {\n SDK_RPRINT ( test , \"TSIOBufferStart\" , \"TestCase1\" , TC_PASS , \"ok\" ) ;\n SDK_RPRINT ( test , \"TSIOBufferReaderStart\" , \"TestCase1\" , TC_PASS , \"ok\" ) ;\n test_passed = true ;\n }\n else {\n SDK_RPRINT ( test , \"TSIOBufferStart\" , \"TestCase1\" , TC_FAIL , \"failed\" ) ;\n SDK_RPRINT ( test , \"TSIOBufferReaderStart\" , \"TestCase1\" , TC_FAIL , \"failed\" ) ;\n }\n * pstatus = ( ( test_passed == true ) ? REGRESSION_TEST_PASSED : REGRESSION_TEST_FAILED ) ;\n return ;\n }", "idx": 21475}
{"hash": 8320716512483418415, "project": "chrome", "size": 38, "label": 1, "functionSource": "void vp9_idct32x32_1024_add_c ( const int16_t * input , uint8_t * dest , int stride ) {\n int16_t out [ 32 * 32 ] ;\n int16_t * outptr = out ;\n int i , j ;\n int16_t temp_in [ 32 ] , temp_out [ 32 ] ;\n for ( i = 0 ;\n i < 32 ;\n ++ i ) {\n int16_t zero_coeff [ 16 ] ;\n for ( j = 0 ;\n j < 16 ;\n ++ j ) zero_coeff [ j ] = input [ 2 * j ] | input [ 2 * j + 1 ] ;\n for ( j = 0 ;\n j < 8 ;\n ++ j ) zero_coeff [ j ] = zero_coeff [ 2 * j ] | zero_coeff [ 2 * j + 1 ] ;\n for ( j = 0 ;\n j < 4 ;\n ++ j ) zero_coeff [ j ] = zero_coeff [ 2 * j ] | zero_coeff [ 2 * j + 1 ] ;\n for ( j = 0 ;\n j < 2 ;\n ++ j ) zero_coeff [ j ] = zero_coeff [ 2 * j ] | zero_coeff [ 2 * j + 1 ] ;\n if ( zero_coeff [ 0 ] | zero_coeff [ 1 ] ) idct32 ( input , outptr ) ;\n else vpx_memset ( outptr , 0 , sizeof ( int16_t ) * 32 ) ;\n input += 32 ;\n outptr += 32 ;\n }\n for ( i = 0 ;\n i < 32 ;\n ++ i ) {\n for ( j = 0 ;\n j < 32 ;\n ++ j ) temp_in [ j ] = out [ j * 32 + i ] ;\n idct32 ( temp_in , temp_out ) ;\n for ( j = 0 ;\n j < 32 ;\n ++ j ) dest [ j * stride + i ] = clip_pixel ( ROUND_POWER_OF_TWO ( temp_out [ j ] , 6 ) + dest [ j * stride + i ] ) ;\n }\n }", "idx": 21476}
{"hash": -1483849844579170895, "project": "chrome", "size": 6, "label": 0, "functionSource": "static void warn_or_exit_on_error ( vpx_codec_ctx_t * ctx , int fatal , const char * s , ... ) {\n va_list ap ;\n va_start ( ap , s ) ;\n warn_or_exit_on_errorv ( ctx , fatal , s , ap ) ;\n va_end ( ap ) ;\n }", "idx": 21477}
{"hash": -4136373206107992781, "project": "chrome", "size": 269, "label": 0, "functionSource": "static void U_CALLCONV UConverter_toUnicode_ISCII_OFFSETS_LOGIC ( UConverterToUnicodeArgs * args , UErrorCode * err ) {\n const char * source = ( char * ) args -> source ;\n UChar * target = args -> target ;\n const char * sourceLimit = args -> sourceLimit ;\n const UChar * targetLimit = args -> targetLimit ;\n uint32_t targetUniChar = 0x0000 ;\n uint8_t sourceChar = 0x0000 ;\n UConverterDataISCII * data ;\n UChar32 * toUnicodeStatus = NULL ;\n UChar32 tempTargetUniChar = 0x0000 ;\n UChar * contextCharToUnicode = NULL ;\n UBool found ;\n int i ;\n int offset = 0 ;\n if ( ( args -> converter == NULL ) || ( target < args -> target ) || ( source < args -> source ) ) {\n * err = U_ILLEGAL_ARGUMENT_ERROR ;\n return ;\n }\n data = ( UConverterDataISCII * ) ( args -> converter -> extraInfo ) ;\n contextCharToUnicode = & data -> contextCharToUnicode ;\n toUnicodeStatus = ( UChar32 * ) & args -> converter -> toUnicodeStatus ;\n while ( U_SUCCESS ( * err ) && source < sourceLimit ) {\n targetUniChar = missingCharMarker ;\n if ( target < targetLimit ) {\n sourceChar = ( unsigned char ) * ( source ) ++ ;\n if ( * contextCharToUnicode == ATR ) {\n if ( ( uint8_t ) ( PNJ - sourceChar ) <= PNJ - DEV ) {\n data -> currentDeltaToUnicode = ( uint16_t ) ( lookupTable [ sourceChar & 0x0F ] [ 0 ] * DELTA ) ;\n data -> currentMaskToUnicode = ( MaskEnum ) lookupTable [ sourceChar & 0x0F ] [ 1 ] ;\n }\n else if ( sourceChar == DEF ) {\n data -> currentDeltaToUnicode = data -> defDeltaToUnicode ;\n data -> currentMaskToUnicode = data -> defMaskToUnicode ;\n }\n else {\n if ( ( sourceChar >= 0x21 && sourceChar <= 0x3F ) ) {\n }\n else {\n * err = U_ILLEGAL_CHAR_FOUND ;\n * contextCharToUnicode = NO_CHAR_MARKER ;\n goto CALLBACK ;\n }\n }\n * contextCharToUnicode = NO_CHAR_MARKER ;\n continue ;\n }\n else if ( * contextCharToUnicode == EXT ) {\n if ( ( uint8_t ) ( EXT_RANGE_END - sourceChar ) <= ( EXT_RANGE_END - EXT_RANGE_BEGIN ) ) {\n if ( sourceChar == 0xBF || sourceChar == 0xB8 ) {\n targetUniChar = ( sourceChar == 0xBF ) ? DEV_ABBR_SIGN : DEV_ANUDATTA ;\n if ( validityTable [ ( uint8_t ) targetUniChar ] & data -> currentMaskToUnicode ) {\n * contextCharToUnicode = NO_CHAR_MARKER ;\n if ( data -> prevToUnicodeStatus ) {\n WRITE_TO_TARGET_TO_U ( args , source , target , args -> offsets , ( source - args -> source - 1 ) , data -> prevToUnicodeStatus , 0 , err ) ;\n data -> prevToUnicodeStatus = 0x0000 ;\n }\n WRITE_TO_TARGET_TO_U ( args , source , target , args -> offsets , ( source - args -> source - 2 ) , targetUniChar , data -> currentDeltaToUnicode , err ) ;\n continue ;\n }\n }\n targetUniChar = missingCharMarker ;\n * err = U_INVALID_CHAR_FOUND ;\n }\n else {\n * contextCharToUnicode = NO_CHAR_MARKER ;\n * err = U_ILLEGAL_CHAR_FOUND ;\n }\n goto CALLBACK ;\n }\n else if ( * contextCharToUnicode == ISCII_INV ) {\n if ( sourceChar == ISCII_HALANT ) {\n targetUniChar = 0x0020 ;\n }\n else {\n targetUniChar = ZWJ ;\n }\n if ( data -> prevToUnicodeStatus ) {\n WRITE_TO_TARGET_TO_U ( args , source , target , args -> offsets , ( source - args -> source - 1 ) , data -> prevToUnicodeStatus , 0 , err ) ;\n data -> prevToUnicodeStatus = 0x0000 ;\n }\n WRITE_TO_TARGET_TO_U ( args , source , target , args -> offsets , ( source - args -> source - 2 ) , targetUniChar , data -> currentDeltaToUnicode , err ) ;\n * contextCharToUnicode = NO_CHAR_MARKER ;\n }\n switch ( sourceChar ) {\n case ISCII_INV : case EXT : case ATR : * contextCharToUnicode = ( UChar ) sourceChar ;\n if ( * toUnicodeStatus != missingCharMarker ) {\n if ( data -> prevToUnicodeStatus ) {\n WRITE_TO_TARGET_TO_U ( args , source , target , args -> offsets , ( source - args -> source - 1 ) , data -> prevToUnicodeStatus , 0 , err ) ;\n data -> prevToUnicodeStatus = 0x0000 ;\n }\n WRITE_TO_TARGET_TO_U ( args , source , target , args -> offsets , ( source - args -> source - 2 ) , * toUnicodeStatus , data -> currentDeltaToUnicode , err ) ;\n * toUnicodeStatus = missingCharMarker ;\n }\n continue ;\n case ISCII_DANDA : if ( * contextCharToUnicode == ISCII_DANDA ) {\n targetUniChar = DOUBLE_DANDA ;\n * contextCharToUnicode = NO_CHAR_MARKER ;\n * toUnicodeStatus = missingCharMarker ;\n }\n else {\n GET_MAPPING ( sourceChar , targetUniChar , data ) ;\n * contextCharToUnicode = sourceChar ;\n }\n break ;\n case ISCII_HALANT : if ( * contextCharToUnicode == ISCII_HALANT ) {\n targetUniChar = ZWNJ ;\n * contextCharToUnicode = NO_CHAR_MARKER ;\n }\n else {\n GET_MAPPING ( sourceChar , targetUniChar , data ) ;\n * contextCharToUnicode = sourceChar ;\n }\n break ;\n case 0x0A : case 0x0D : data -> resetToDefaultToUnicode = TRUE ;\n GET_MAPPING ( sourceChar , targetUniChar , data ) ;\n * contextCharToUnicode = sourceChar ;\n break ;\n case ISCII_VOWEL_SIGN_E : i = 1 ;\n found = FALSE ;\n for ( ;\n i < vowelSignESpecialCases [ 0 ] [ 0 ] ;\n i ++ ) {\n U_ASSERT ( i < UPRV_LENGTHOF ( vowelSignESpecialCases ) ) ;\n if ( vowelSignESpecialCases [ i ] [ 0 ] == ( uint8_t ) * contextCharToUnicode ) {\n targetUniChar = vowelSignESpecialCases [ i ] [ 1 ] ;\n found = TRUE ;\n break ;\n }\n }\n if ( found ) {\n if ( validityTable [ ( uint8_t ) targetUniChar ] & data -> currentMaskToUnicode ) {\n * contextCharToUnicode = NO_CHAR_MARKER ;\n * toUnicodeStatus = missingCharMarker ;\n break ;\n }\n }\n GET_MAPPING ( sourceChar , targetUniChar , data ) ;\n * contextCharToUnicode = sourceChar ;\n break ;\n case ISCII_NUKTA : if ( * contextCharToUnicode == ISCII_HALANT ) {\n targetUniChar = ZWJ ;\n * contextCharToUnicode = NO_CHAR_MARKER ;\n break ;\n }\n else if ( data -> currentDeltaToUnicode == PNJ_DELTA && data -> contextCharToUnicode == 0xc0 ) {\n if ( data -> prevToUnicodeStatus ) {\n WRITE_TO_TARGET_TO_U ( args , source , target , args -> offsets , ( source - args -> source - 1 ) , data -> prevToUnicodeStatus , 0 , err ) ;\n data -> prevToUnicodeStatus = 0x0000 ;\n }\n targetUniChar = PNJ_RRA ;\n WRITE_TO_TARGET_TO_U ( args , source , target , args -> offsets , ( source - args -> source ) - 2 , targetUniChar , 0 , err ) ;\n if ( U_SUCCESS ( * err ) ) {\n targetUniChar = PNJ_SIGN_VIRAMA ;\n WRITE_TO_TARGET_TO_U ( args , source , target , args -> offsets , ( source - args -> source ) - 2 , targetUniChar , 0 , err ) ;\n if ( U_SUCCESS ( * err ) ) {\n targetUniChar = PNJ_HA ;\n WRITE_TO_TARGET_TO_U ( args , source , target , args -> offsets , ( source - args -> source ) - 2 , targetUniChar , 0 , err ) ;\n }\n else {\n args -> converter -> UCharErrorBuffer [ args -> converter -> UCharErrorBufferLength ++ ] = PNJ_HA ;\n }\n }\n else {\n args -> converter -> UCharErrorBuffer [ args -> converter -> UCharErrorBufferLength ++ ] = PNJ_SIGN_VIRAMA ;\n args -> converter -> UCharErrorBuffer [ args -> converter -> UCharErrorBufferLength ++ ] = PNJ_HA ;\n }\n * toUnicodeStatus = missingCharMarker ;\n data -> contextCharToUnicode = NO_CHAR_MARKER ;\n continue ;\n }\n else {\n i = 1 ;\n found = FALSE ;\n for ( ;\n i < nuktaSpecialCases [ 0 ] [ 0 ] ;\n i ++ ) {\n if ( nuktaSpecialCases [ i ] [ 0 ] == ( uint8_t ) * contextCharToUnicode ) {\n targetUniChar = nuktaSpecialCases [ i ] [ 1 ] ;\n found = TRUE ;\n break ;\n }\n }\n if ( found ) {\n if ( validityTable [ ( uint8_t ) targetUniChar ] & data -> currentMaskToUnicode ) {\n * contextCharToUnicode = NO_CHAR_MARKER ;\n * toUnicodeStatus = missingCharMarker ;\n if ( data -> currentDeltaToUnicode == PNJ_DELTA ) {\n if ( data -> prevToUnicodeStatus ) {\n WRITE_TO_TARGET_TO_U ( args , source , target , args -> offsets , ( source - args -> source - 1 ) , data -> prevToUnicodeStatus , 0 , err ) ;\n data -> prevToUnicodeStatus = 0x0000 ;\n }\n WRITE_TO_TARGET_TO_U ( args , source , target , args -> offsets , ( source - args -> source - 2 ) , targetUniChar , data -> currentDeltaToUnicode , err ) ;\n continue ;\n }\n break ;\n }\n }\n U_FALLTHROUGH ;\n }\n default : GET_MAPPING ( sourceChar , targetUniChar , data ) ;\n * contextCharToUnicode = sourceChar ;\n break ;\n }\n if ( * toUnicodeStatus != missingCharMarker ) {\n if ( data -> currentDeltaToUnicode == PNJ_DELTA && data -> prevToUnicodeStatus != 0 && isPNJConsonant ( data -> prevToUnicodeStatus ) && ( * toUnicodeStatus + PNJ_DELTA ) == PNJ_SIGN_VIRAMA && ( ( UChar32 ) ( targetUniChar + PNJ_DELTA ) == data -> prevToUnicodeStatus ) ) {\n offset = ( int ) ( source - args -> source - 3 ) ;\n tempTargetUniChar = PNJ_ADHAK ;\n WRITE_TO_TARGET_TO_U ( args , source , target , args -> offsets , offset , tempTargetUniChar , 0 , err ) ;\n WRITE_TO_TARGET_TO_U ( args , source , target , args -> offsets , offset , data -> prevToUnicodeStatus , 0 , err ) ;\n data -> prevToUnicodeStatus = 0x0000 ;\n * toUnicodeStatus = missingCharMarker ;\n continue ;\n }\n else {\n if ( data -> prevToUnicodeStatus ) {\n WRITE_TO_TARGET_TO_U ( args , source , target , args -> offsets , ( source - args -> source - 1 ) , data -> prevToUnicodeStatus , 0 , err ) ;\n data -> prevToUnicodeStatus = 0x0000 ;\n }\n if ( data -> currentDeltaToUnicode == PNJ_DELTA && ( targetUniChar + PNJ_DELTA ) == PNJ_BINDI && isPNJBindiTippi ( ( * toUnicodeStatus + PNJ_DELTA ) ) ) {\n targetUniChar = PNJ_TIPPI - PNJ_DELTA ;\n WRITE_TO_TARGET_TO_U ( args , source , target , args -> offsets , ( source - args -> source - 2 ) , * toUnicodeStatus , PNJ_DELTA , err ) ;\n }\n else if ( data -> currentDeltaToUnicode == PNJ_DELTA && ( targetUniChar + PNJ_DELTA ) == PNJ_SIGN_VIRAMA && isPNJConsonant ( ( * toUnicodeStatus + PNJ_DELTA ) ) ) {\n data -> prevToUnicodeStatus = * toUnicodeStatus + PNJ_DELTA ;\n }\n else {\n WRITE_TO_TARGET_TO_U ( args , source , target , args -> offsets , ( source - args -> source - 2 ) , * toUnicodeStatus , data -> currentDeltaToUnicode , err ) ;\n }\n }\n * toUnicodeStatus = missingCharMarker ;\n }\n if ( targetUniChar != missingCharMarker ) {\n * toUnicodeStatus = ( UChar ) targetUniChar ;\n if ( data -> resetToDefaultToUnicode == TRUE ) {\n data -> currentDeltaToUnicode = data -> defDeltaToUnicode ;\n data -> currentMaskToUnicode = data -> defMaskToUnicode ;\n data -> resetToDefaultToUnicode = FALSE ;\n }\n }\n else {\n * err = U_INVALID_CHAR_FOUND ;\n CALLBACK : args -> converter -> toUBytes [ 0 ] = ( uint8_t ) sourceChar ;\n args -> converter -> toULength = 1 ;\n break ;\n }\n }\n else {\n * err = U_BUFFER_OVERFLOW_ERROR ;\n break ;\n }\n }\n if ( U_SUCCESS ( * err ) && args -> flush && source == sourceLimit ) {\n UConverter * cnv = args -> converter ;\n if ( * contextCharToUnicode == ATR || * contextCharToUnicode == EXT || * contextCharToUnicode == ISCII_INV ) {\n cnv -> toUBytes [ 0 ] = ( uint8_t ) * contextCharToUnicode ;\n cnv -> toULength = 1 ;\n * contextCharToUnicode = NO_CHAR_MARKER ;\n }\n else {\n cnv -> toULength = 0 ;\n }\n if ( * toUnicodeStatus != missingCharMarker ) {\n WRITE_TO_TARGET_TO_U ( args , source , target , args -> offsets , ( source - args -> source - 1 ) , * toUnicodeStatus , data -> currentDeltaToUnicode , err ) ;\n * toUnicodeStatus = missingCharMarker ;\n }\n }\n args -> target = target ;\n args -> source = source ;\n }", "idx": 21478}
{"hash": 2578089348587614328, "project": "debian", "size": 3, "label": 0, "functionSource": "int i2d_X509_fp ( FILE * fp , X509 * x509 ) {\n return ASN1_item_i2d_fp ( ASN1_ITEM_rptr ( X509 ) , fp , x509 ) ;\n }", "idx": 21479}
{"hash": 7406835591406200950, "project": "chrome", "size": 7, "label": 0, "functionSource": "static UBool U_CALLCONV _enumPropertyStartsRange ( const void * context , UChar32 start , UChar32 end , uint32_t value ) {\n ( void ) end ;\n ( void ) value ;\n const USetAdder * sa = ( const USetAdder * ) context ;\n sa -> add ( sa -> set , start ) ;\n return TRUE ;\n }", "idx": 21480}
{"hash": -5706788925640467782, "project": "chrome", "size": 49, "label": 0, "functionSource": "static void constrain_copy_partitioning ( VP9_COMP * const cpi , const TileInfo * const tile , MODE_INFO * mi_8x8 , MODE_INFO * prev_mi_8x8 , int mi_row , int mi_col , BLOCK_SIZE bsize ) {\n VP9_COMMON * const cm = & cpi -> common ;\n const int mis = cm -> mi_stride ;\n const int row8x8_remaining = tile -> mi_row_end - mi_row ;\n const int col8x8_remaining = tile -> mi_col_end - mi_col ;\n MODE_INFO * const mi_upper_left = cm -> mi + mi_row * mis + mi_col ;\n const int bh = num_8x8_blocks_high_lookup [ bsize ] ;\n const int bw = num_8x8_blocks_wide_lookup [ bsize ] ;\n int block_row , block_col ;\n assert ( ( row8x8_remaining > 0 ) && ( col8x8_remaining > 0 ) ) ;\n if ( ( col8x8_remaining >= MI_BLOCK_SIZE ) && ( row8x8_remaining >= MI_BLOCK_SIZE ) ) {\n for ( block_row = 0 ;\n block_row < MI_BLOCK_SIZE ;\n block_row += bh ) {\n for ( block_col = 0 ;\n block_col < MI_BLOCK_SIZE ;\n block_col += bw ) {\n const int index = block_row * mis + block_col ;\n MODE_INFO * prev_mi = prev_mi_8x8 [ index ] . src_mi ;\n const BLOCK_SIZE sb_type = prev_mi ? prev_mi -> mbmi . sb_type : 0 ;\n if ( prev_mi && sb_type <= bsize ) {\n int block_row2 , block_col2 ;\n for ( block_row2 = 0 ;\n block_row2 < bh ;\n ++ block_row2 ) {\n for ( block_col2 = 0 ;\n block_col2 < bw ;\n ++ block_col2 ) {\n const int index2 = ( block_row + block_row2 ) * mis + block_col + block_col2 ;\n prev_mi = prev_mi_8x8 [ index2 ] . src_mi ;\n if ( prev_mi ) {\n const ptrdiff_t offset = prev_mi - cm -> prev_mi ;\n mi_8x8 [ index2 ] . src_mi = cm -> mi + offset ;\n mi_8x8 [ index2 ] . src_mi -> mbmi . sb_type = prev_mi -> mbmi . sb_type ;\n }\n }\n }\n }\n else {\n mi_8x8 [ index ] . src_mi = mi_upper_left + index ;\n mi_8x8 [ index ] . src_mi -> mbmi . sb_type = bsize ;\n }\n }\n }\n }\n else {\n copy_partitioning ( cm , mi_8x8 , prev_mi_8x8 ) ;\n }\n }", "idx": 21481}
{"hash": 4489017523191997023, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h225_H323_UU_PDU ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_H323_UU_PDU , H323_UU_PDU_sequence ) ;\n return offset ;\n }", "idx": 21482}
{"hash": 453207616518947865, "project": "chrome", "size": 3, "label": 0, "functionSource": "static UBool uprv_compareFrequency ( UTimer * , UTimer * ) {\n return TRUE ;\n }", "idx": 21483}
{"hash": -3805791263064294216, "project": "debian", "size": 345, "label": 0, "functionSource": "int phar_tar_flush ( phar_archive_data * phar , char * user_stub , long len , int defaultstub , char * * error TSRMLS_DC ) {\n phar_entry_info entry = {\n 0 }\n ;\n static const char newstub [ ] = \"<?php // tar-based phar archive stub file\\n__HALT_COMPILER();\n\" ;\n php_stream * oldfile , * newfile , * stubfile ;\n int closeoldfile , free_user_stub , signature_length ;\n struct _phar_pass_tar_info pass ;\n char * buf , * signature , * tmp , sigbuf [ 8 ] ;\n char halt_stub [ ] = \"__HALT_COMPILER();\n\" ;\n entry . flags = PHAR_ENT_PERM_DEF_FILE ;\n entry . timestamp = time ( NULL ) ;\n entry . is_modified = 1 ;\n entry . is_crc_checked = 1 ;\n entry . is_tar = 1 ;\n entry . tar_type = '0' ;\n entry . phar = phar ;\n entry . fp_type = PHAR_MOD ;\n if ( phar -> is_persistent ) {\n if ( error ) {\n spprintf ( error , 0 , \"internal error: attempt to flush cached tar-based phar \\\"%s\\\"\" , phar -> fname ) ;\n }\n return EOF ;\n }\n if ( phar -> is_data ) {\n goto nostub ;\n }\n if ( ! phar -> is_temporary_alias && phar -> alias_len ) {\n entry . filename = estrndup ( \".phar/alias.txt\" , sizeof ( \".phar/alias.txt\" ) - 1 ) ;\n entry . filename_len = sizeof ( \".phar/alias.txt\" ) - 1 ;\n entry . fp = php_stream_fopen_tmpfile ( ) ;\n if ( entry . fp == NULL ) {\n spprintf ( error , 0 , \"phar error: unable to create temporary file\" ) ;\n return - 1 ;\n }\n if ( phar -> alias_len != ( int ) php_stream_write ( entry . fp , phar -> alias , phar -> alias_len ) ) {\n if ( error ) {\n spprintf ( error , 0 , \"unable to set alias in tar-based phar \\\"%s\\\"\" , phar -> fname ) ;\n }\n return EOF ;\n }\n entry . uncompressed_filesize = phar -> alias_len ;\n if ( SUCCESS != zend_hash_update ( & phar -> manifest , entry . filename , entry . filename_len , ( void * ) & entry , sizeof ( phar_entry_info ) , NULL ) ) {\n if ( error ) {\n spprintf ( error , 0 , \"unable to set alias in tar-based phar \\\"%s\\\"\" , phar -> fname ) ;\n }\n return EOF ;\n }\n }\n else {\n zend_hash_del ( & phar -> manifest , \".phar/alias.txt\" , sizeof ( \".phar/alias.txt\" ) - 1 ) ;\n }\n if ( user_stub && ! defaultstub ) {\n char * pos ;\n if ( len < 0 ) {\n if ( ! ( php_stream_from_zval_no_verify ( stubfile , ( zval * * ) user_stub ) ) ) {\n if ( error ) {\n spprintf ( error , 0 , \"unable to access resource to copy stub to new tar-based phar \\\"%s\\\"\" , phar -> fname ) ;\n }\n return EOF ;\n }\n if ( len == - 1 ) {\n len = PHP_STREAM_COPY_ALL ;\n }\n else {\n len = - len ;\n }\n user_stub = 0 ;\n if ( ! ( len = php_stream_copy_to_mem ( stubfile , & user_stub , len , 0 ) ) || ! user_stub ) {\n if ( error ) {\n spprintf ( error , 0 , \"unable to read resource to copy stub to new tar-based phar \\\"%s\\\"\" , phar -> fname ) ;\n }\n return EOF ;\n }\n free_user_stub = 1 ;\n }\n else {\n free_user_stub = 0 ;\n }\n tmp = estrndup ( user_stub , len ) ;\n if ( ( pos = php_stristr ( tmp , halt_stub , len , sizeof ( halt_stub ) - 1 ) ) == NULL ) {\n efree ( tmp ) ;\n if ( error ) {\n spprintf ( error , 0 , \"illegal stub for tar-based phar \\\"%s\\\"\" , phar -> fname ) ;\n }\n if ( free_user_stub ) {\n efree ( user_stub ) ;\n }\n return EOF ;\n }\n pos = user_stub + ( pos - tmp ) ;\n efree ( tmp ) ;\n len = pos - user_stub + 18 ;\n entry . fp = php_stream_fopen_tmpfile ( ) ;\n if ( entry . fp == NULL ) {\n spprintf ( error , 0 , \"phar error: unable to create temporary file\" ) ;\n return EOF ;\n }\n entry . uncompressed_filesize = len + 5 ;\n if ( ( size_t ) len != php_stream_write ( entry . fp , user_stub , len ) || 5 != php_stream_write ( entry . fp , \" ?>\\r\\n\" , 5 ) ) {\n if ( error ) {\n spprintf ( error , 0 , \"unable to create stub from string in new tar-based phar \\\"%s\\\"\" , phar -> fname ) ;\n }\n if ( free_user_stub ) {\n efree ( user_stub ) ;\n }\n php_stream_close ( entry . fp ) ;\n return EOF ;\n }\n entry . filename = estrndup ( \".phar/stub.php\" , sizeof ( \".phar/stub.php\" ) - 1 ) ;\n entry . filename_len = sizeof ( \".phar/stub.php\" ) - 1 ;\n zend_hash_update ( & phar -> manifest , entry . filename , entry . filename_len , ( void * ) & entry , sizeof ( phar_entry_info ) , NULL ) ;\n if ( free_user_stub ) {\n efree ( user_stub ) ;\n }\n }\n else {\n entry . fp = php_stream_fopen_tmpfile ( ) ;\n if ( entry . fp == NULL ) {\n spprintf ( error , 0 , \"phar error: unable to create temporary file\" ) ;\n return EOF ;\n }\n if ( sizeof ( newstub ) - 1 != php_stream_write ( entry . fp , newstub , sizeof ( newstub ) - 1 ) ) {\n php_stream_close ( entry . fp ) ;\n if ( error ) {\n spprintf ( error , 0 , \"unable to %s stub in%star-based phar \\\"%s\\\", failed\" , user_stub ? \"overwrite\" : \"create\" , user_stub ? \" \" : \" new \" , phar -> fname ) ;\n }\n return EOF ;\n }\n entry . uncompressed_filesize = entry . compressed_filesize = sizeof ( newstub ) - 1 ;\n entry . filename = estrndup ( \".phar/stub.php\" , sizeof ( \".phar/stub.php\" ) - 1 ) ;\n entry . filename_len = sizeof ( \".phar/stub.php\" ) - 1 ;\n if ( ! defaultstub ) {\n if ( ! zend_hash_exists ( & phar -> manifest , \".phar/stub.php\" , sizeof ( \".phar/stub.php\" ) - 1 ) ) {\n if ( SUCCESS != zend_hash_add ( & phar -> manifest , entry . filename , entry . filename_len , ( void * ) & entry , sizeof ( phar_entry_info ) , NULL ) ) {\n php_stream_close ( entry . fp ) ;\n efree ( entry . filename ) ;\n if ( error ) {\n spprintf ( error , 0 , \"unable to create stub in tar-based phar \\\"%s\\\"\" , phar -> fname ) ;\n }\n return EOF ;\n }\n }\n else {\n php_stream_close ( entry . fp ) ;\n efree ( entry . filename ) ;\n }\n }\n else {\n if ( SUCCESS != zend_hash_update ( & phar -> manifest , entry . filename , entry . filename_len , ( void * ) & entry , sizeof ( phar_entry_info ) , NULL ) ) {\n php_stream_close ( entry . fp ) ;\n efree ( entry . filename ) ;\n if ( error ) {\n spprintf ( error , 0 , \"unable to overwrite stub in tar-based phar \\\"%s\\\"\" , phar -> fname ) ;\n }\n return EOF ;\n }\n }\n }\n nostub : if ( phar -> fp && ! phar -> is_brandnew ) {\n oldfile = phar -> fp ;\n closeoldfile = 0 ;\n php_stream_rewind ( oldfile ) ;\n }\n else {\n oldfile = php_stream_open_wrapper ( phar -> fname , \"rb\" , 0 , NULL ) ;\n closeoldfile = oldfile != NULL ;\n }\n newfile = php_stream_fopen_tmpfile ( ) ;\n if ( ! newfile ) {\n if ( error ) {\n spprintf ( error , 0 , \"unable to create temporary file\" ) ;\n }\n if ( closeoldfile ) {\n php_stream_close ( oldfile ) ;\n }\n return EOF ;\n }\n pass . old = oldfile ;\n pass . new = newfile ;\n pass . error = error ;\n pass . free_fp = 1 ;\n pass . free_ufp = 1 ;\n if ( phar -> metadata ) {\n phar_entry_info * mentry ;\n if ( SUCCESS == zend_hash_find ( & ( phar -> manifest ) , \".phar/.metadata.bin\" , sizeof ( \".phar/.metadata.bin\" ) - 1 , ( void * * ) & mentry ) ) {\n if ( ZEND_HASH_APPLY_KEEP != phar_tar_setmetadata ( phar -> metadata , mentry , error TSRMLS_CC ) ) {\n if ( closeoldfile ) {\n php_stream_close ( oldfile ) ;\n }\n return EOF ;\n }\n }\n else {\n phar_entry_info newentry = {\n 0 }\n ;\n newentry . filename = estrndup ( \".phar/.metadata.bin\" , sizeof ( \".phar/.metadata.bin\" ) - 1 ) ;\n newentry . filename_len = sizeof ( \".phar/.metadata.bin\" ) - 1 ;\n newentry . phar = phar ;\n newentry . tar_type = TAR_FILE ;\n newentry . is_tar = 1 ;\n if ( SUCCESS != zend_hash_add ( & ( phar -> manifest ) , \".phar/.metadata.bin\" , sizeof ( \".phar/.metadata.bin\" ) - 1 , ( void * ) & newentry , sizeof ( phar_entry_info ) , ( void * * ) & mentry ) ) {\n spprintf ( error , 0 , \"phar tar error: unable to add magic metadata file to manifest for phar archive \\\"%s\\\"\" , phar -> fname ) ;\n if ( closeoldfile ) {\n php_stream_close ( oldfile ) ;\n }\n return EOF ;\n }\n if ( ZEND_HASH_APPLY_KEEP != phar_tar_setmetadata ( phar -> metadata , mentry , error TSRMLS_CC ) ) {\n zend_hash_del ( & ( phar -> manifest ) , \".phar/.metadata.bin\" , sizeof ( \".phar/.metadata.bin\" ) - 1 ) ;\n if ( closeoldfile ) {\n php_stream_close ( oldfile ) ;\n }\n return EOF ;\n }\n }\n }\n zend_hash_apply_with_argument ( & phar -> manifest , ( apply_func_arg_t ) phar_tar_setupmetadata , ( void * ) & pass TSRMLS_CC ) ;\n if ( error && * error ) {\n if ( closeoldfile ) {\n php_stream_close ( oldfile ) ;\n }\n php_stream_close ( newfile ) ;\n return EOF ;\n }\n zend_hash_apply_with_argument ( & phar -> manifest , ( apply_func_arg_t ) phar_tar_writeheaders , ( void * ) & pass TSRMLS_CC ) ;\n if ( ! phar -> is_data || phar -> sig_flags ) {\n if ( FAILURE == phar_create_signature ( phar , newfile , & signature , & signature_length , error TSRMLS_CC ) ) {\n if ( error ) {\n char * save = * error ;\n spprintf ( error , 0 , \"phar error: unable to write signature to tar-based phar: %s\" , save ) ;\n efree ( save ) ;\n }\n if ( closeoldfile ) {\n php_stream_close ( oldfile ) ;\n }\n php_stream_close ( newfile ) ;\n return EOF ;\n }\n entry . filename = \".phar/signature.bin\" ;\n entry . filename_len = sizeof ( \".phar/signature.bin\" ) - 1 ;\n entry . fp = php_stream_fopen_tmpfile ( ) ;\n if ( entry . fp == NULL ) {\n spprintf ( error , 0 , \"phar error: unable to create temporary file\" ) ;\n return EOF ;\n }\n # ifdef WORDS_BIGENDIAN # define PHAR_SET_32 ( var , buffer ) \\ * ( php_uint32 * ) ( var ) = ( ( ( ( ( unsigned char * ) & ( buffer ) ) [ 3 ] ) << 24 ) \\ | ( ( ( ( unsigned char * ) & ( buffer ) ) [ 2 ] ) << 16 ) \\ | ( ( ( ( unsigned char * ) & ( buffer ) ) [ 1 ] ) << 8 ) \\ | ( ( ( unsigned char * ) & ( buffer ) ) [ 0 ] ) ) # else # define PHAR_SET_32 ( var , buffer ) * ( php_uint32 * ) ( var ) = ( php_uint32 ) ( buffer ) # endif PHAR_SET_32 ( sigbuf , phar -> sig_flags ) ;\n PHAR_SET_32 ( sigbuf + 4 , signature_length ) ;\n if ( 8 != ( int ) php_stream_write ( entry . fp , sigbuf , 8 ) || signature_length != ( int ) php_stream_write ( entry . fp , signature , signature_length ) ) {\n efree ( signature ) ;\n if ( error ) {\n spprintf ( error , 0 , \"phar error: unable to write signature to tar-based phar %s\" , phar -> fname ) ;\n }\n if ( closeoldfile ) {\n php_stream_close ( oldfile ) ;\n }\n php_stream_close ( newfile ) ;\n return EOF ;\n }\n efree ( signature ) ;\n entry . uncompressed_filesize = entry . compressed_filesize = signature_length + 8 ;\n entry . filename_len = phar_tar_writeheaders ( ( void * ) & entry , ( void * ) & pass TSRMLS_CC ) ;\n if ( error && * error ) {\n if ( closeoldfile ) {\n php_stream_close ( oldfile ) ;\n }\n php_stream_close ( newfile ) ;\n return EOF ;\n }\n }\n buf = ( char * ) ecalloc ( 1024 , 1 ) ;\n php_stream_write ( newfile , buf , 1024 ) ;\n efree ( buf ) ;\n if ( closeoldfile ) {\n php_stream_close ( oldfile ) ;\n }\n if ( error && * error ) {\n php_stream_close ( newfile ) ;\n return EOF ;\n }\n if ( phar -> fp && pass . free_fp ) {\n php_stream_close ( phar -> fp ) ;\n }\n if ( phar -> ufp ) {\n if ( pass . free_ufp ) {\n php_stream_close ( phar -> ufp ) ;\n }\n phar -> ufp = NULL ;\n }\n phar -> is_brandnew = 0 ;\n php_stream_rewind ( newfile ) ;\n if ( phar -> donotflush ) {\n phar -> fp = newfile ;\n }\n else {\n phar -> fp = php_stream_open_wrapper ( phar -> fname , \"w+b\" , IGNORE_URL | STREAM_MUST_SEEK | REPORT_ERRORS , NULL ) ;\n if ( ! phar -> fp ) {\n phar -> fp = newfile ;\n if ( error ) {\n spprintf ( error , 0 , \"unable to open new phar \\\"%s\\\" for writing\" , phar -> fname ) ;\n }\n return EOF ;\n }\n if ( phar -> flags & PHAR_FILE_COMPRESSED_GZ ) {\n php_stream_filter * filter ;\n zval filterparams ;\n array_init ( & filterparams ) ;\n # ifndef MAX_WBITS # define MAX_WBITS 15 # endif add_assoc_long ( & filterparams , \"window\" , MAX_WBITS + 16 ) ;\n filter = php_stream_filter_create ( \"zlib.deflate\" , & filterparams , php_stream_is_persistent ( phar -> fp ) TSRMLS_CC ) ;\n zval_dtor ( & filterparams ) ;\n if ( ! filter ) {\n phar_stream_copy_to_stream ( newfile , phar -> fp , PHP_STREAM_COPY_ALL , NULL ) ;\n php_stream_close ( newfile ) ;\n if ( error ) {\n spprintf ( error , 4096 , \"unable to compress all contents of phar \\\"%s\\\" using zlib, PHP versions older than 5.2.6 have a buggy zlib\" , phar -> fname ) ;\n }\n return EOF ;\n }\n php_stream_filter_append ( & phar -> fp -> writefilters , filter ) ;\n phar_stream_copy_to_stream ( newfile , phar -> fp , PHP_STREAM_COPY_ALL , NULL ) ;\n php_stream_filter_flush ( filter , 1 ) ;\n php_stream_filter_remove ( filter , 1 TSRMLS_CC ) ;\n php_stream_close ( phar -> fp ) ;\n phar -> fp = newfile ;\n }\n else if ( phar -> flags & PHAR_FILE_COMPRESSED_BZ2 ) {\n php_stream_filter * filter ;\n filter = php_stream_filter_create ( \"bzip2.compress\" , NULL , php_stream_is_persistent ( phar -> fp ) TSRMLS_CC ) ;\n php_stream_filter_append ( & phar -> fp -> writefilters , filter ) ;\n phar_stream_copy_to_stream ( newfile , phar -> fp , PHP_STREAM_COPY_ALL , NULL ) ;\n php_stream_filter_flush ( filter , 1 ) ;\n php_stream_filter_remove ( filter , 1 TSRMLS_CC ) ;\n php_stream_close ( phar -> fp ) ;\n phar -> fp = newfile ;\n }\n else {\n phar_stream_copy_to_stream ( newfile , phar -> fp , PHP_STREAM_COPY_ALL , NULL ) ;\n php_stream_close ( newfile ) ;\n }\n }\n return EOF ;\n }", "idx": 21484}
{"hash": -755883256379441954, "project": "chrome", "size": 192, "label": 1, "functionSource": "void vp9_ ## type ## _predictor_ ## size ## x ## size ## _c ( uint8_t * dst , ptrdiff_t stride , const uint8_t * above , const uint8_t * left ) {\n type ## _predictor ( dst , stride , size , above , left ) ;\n }\n # define intra_pred_allsizes ( type ) intra_pred_sized ( type , 4 ) intra_pred_sized ( type , 8 ) intra_pred_sized ( type , 16 ) intra_pred_sized ( type , 32 ) static INLINE void d207_predictor ( uint8_t * dst , ptrdiff_t stride , int bs , const uint8_t * above , const uint8_t * left ) {\n int r , c ;\n ( void ) above ;\n for ( r = 0 ;\n r < bs - 1 ;\n ++ r ) dst [ r * stride ] = ROUND_POWER_OF_TWO ( left [ r ] + left [ r + 1 ] , 1 ) ;\n dst [ ( bs - 1 ) * stride ] = left [ bs - 1 ] ;\n dst ++ ;\n for ( r = 0 ;\n r < bs - 2 ;\n ++ r ) dst [ r * stride ] = ROUND_POWER_OF_TWO ( left [ r ] + left [ r + 1 ] * 2 + left [ r + 2 ] , 2 ) ;\n dst [ ( bs - 2 ) * stride ] = ROUND_POWER_OF_TWO ( left [ bs - 2 ] + left [ bs - 1 ] * 3 , 2 ) ;\n dst [ ( bs - 1 ) * stride ] = left [ bs - 1 ] ;\n dst ++ ;\n for ( c = 0 ;\n c < bs - 2 ;\n ++ c ) dst [ ( bs - 1 ) * stride + c ] = left [ bs - 1 ] ;\n for ( r = bs - 2 ;\n r >= 0 ;\n -- r ) for ( c = 0 ;\n c < bs - 2 ;\n ++ c ) dst [ r * stride + c ] = dst [ ( r + 1 ) * stride + c - 2 ] ;\n }\n intra_pred_allsizes ( d207 ) static INLINE void d63_predictor ( uint8_t * dst , ptrdiff_t stride , int bs , const uint8_t * above , const uint8_t * left ) {\n int r , c ;\n ( void ) left ;\n for ( r = 0 ;\n r < bs ;\n ++ r ) {\n for ( c = 0 ;\n c < bs ;\n ++ c ) dst [ c ] = r & 1 ? ROUND_POWER_OF_TWO ( above [ r / 2 + c ] + above [ r / 2 + c + 1 ] * 2 + above [ r / 2 + c + 2 ] , 2 ) : ROUND_POWER_OF_TWO ( above [ r / 2 + c ] + above [ r / 2 + c + 1 ] , 1 ) ;\n dst += stride ;\n }\n }\n intra_pred_allsizes ( d63 ) static INLINE void d45_predictor ( uint8_t * dst , ptrdiff_t stride , int bs , const uint8_t * above , const uint8_t * left ) {\n int r , c ;\n ( void ) left ;\n for ( r = 0 ;\n r < bs ;\n ++ r ) {\n for ( c = 0 ;\n c < bs ;\n ++ c ) dst [ c ] = r + c + 2 < bs * 2 ? ROUND_POWER_OF_TWO ( above [ r + c ] + above [ r + c + 1 ] * 2 + above [ r + c + 2 ] , 2 ) : above [ bs * 2 - 1 ] ;\n dst += stride ;\n }\n }\n intra_pred_allsizes ( d45 ) static INLINE void d117_predictor ( uint8_t * dst , ptrdiff_t stride , int bs , const uint8_t * above , const uint8_t * left ) {\n int r , c ;\n for ( c = 0 ;\n c < bs ;\n c ++ ) dst [ c ] = ROUND_POWER_OF_TWO ( above [ c - 1 ] + above [ c ] , 1 ) ;\n dst += stride ;\n dst [ 0 ] = ROUND_POWER_OF_TWO ( left [ 0 ] + above [ - 1 ] * 2 + above [ 0 ] , 2 ) ;\n for ( c = 1 ;\n c < bs ;\n c ++ ) dst [ c ] = ROUND_POWER_OF_TWO ( above [ c - 2 ] + above [ c - 1 ] * 2 + above [ c ] , 2 ) ;\n dst += stride ;\n dst [ 0 ] = ROUND_POWER_OF_TWO ( above [ - 1 ] + left [ 0 ] * 2 + left [ 1 ] , 2 ) ;\n for ( r = 3 ;\n r < bs ;\n ++ r ) dst [ ( r - 2 ) * stride ] = ROUND_POWER_OF_TWO ( left [ r - 3 ] + left [ r - 2 ] * 2 + left [ r - 1 ] , 2 ) ;\n for ( r = 2 ;\n r < bs ;\n ++ r ) {\n for ( c = 1 ;\n c < bs ;\n c ++ ) dst [ c ] = dst [ - 2 * stride + c - 1 ] ;\n dst += stride ;\n }\n }\n intra_pred_allsizes ( d117 ) static INLINE void d135_predictor ( uint8_t * dst , ptrdiff_t stride , int bs , const uint8_t * above , const uint8_t * left ) {\n int r , c ;\n dst [ 0 ] = ROUND_POWER_OF_TWO ( left [ 0 ] + above [ - 1 ] * 2 + above [ 0 ] , 2 ) ;\n for ( c = 1 ;\n c < bs ;\n c ++ ) dst [ c ] = ROUND_POWER_OF_TWO ( above [ c - 2 ] + above [ c - 1 ] * 2 + above [ c ] , 2 ) ;\n dst [ stride ] = ROUND_POWER_OF_TWO ( above [ - 1 ] + left [ 0 ] * 2 + left [ 1 ] , 2 ) ;\n for ( r = 2 ;\n r < bs ;\n ++ r ) dst [ r * stride ] = ROUND_POWER_OF_TWO ( left [ r - 2 ] + left [ r - 1 ] * 2 + left [ r ] , 2 ) ;\n dst += stride ;\n for ( r = 1 ;\n r < bs ;\n ++ r ) {\n for ( c = 1 ;\n c < bs ;\n c ++ ) dst [ c ] = dst [ - stride + c - 1 ] ;\n dst += stride ;\n }\n }\n intra_pred_allsizes ( d135 ) static INLINE void d153_predictor ( uint8_t * dst , ptrdiff_t stride , int bs , const uint8_t * above , const uint8_t * left ) {\n int r , c ;\n dst [ 0 ] = ROUND_POWER_OF_TWO ( above [ - 1 ] + left [ 0 ] , 1 ) ;\n for ( r = 1 ;\n r < bs ;\n r ++ ) dst [ r * stride ] = ROUND_POWER_OF_TWO ( left [ r - 1 ] + left [ r ] , 1 ) ;\n dst ++ ;\n dst [ 0 ] = ROUND_POWER_OF_TWO ( left [ 0 ] + above [ - 1 ] * 2 + above [ 0 ] , 2 ) ;\n dst [ stride ] = ROUND_POWER_OF_TWO ( above [ - 1 ] + left [ 0 ] * 2 + left [ 1 ] , 2 ) ;\n for ( r = 2 ;\n r < bs ;\n r ++ ) dst [ r * stride ] = ROUND_POWER_OF_TWO ( left [ r - 2 ] + left [ r - 1 ] * 2 + left [ r ] , 2 ) ;\n dst ++ ;\n for ( c = 0 ;\n c < bs - 2 ;\n c ++ ) dst [ c ] = ROUND_POWER_OF_TWO ( above [ c - 1 ] + above [ c ] * 2 + above [ c + 1 ] , 2 ) ;\n dst += stride ;\n for ( r = 1 ;\n r < bs ;\n ++ r ) {\n for ( c = 0 ;\n c < bs - 2 ;\n c ++ ) dst [ c ] = dst [ - stride + c - 2 ] ;\n dst += stride ;\n }\n }\n intra_pred_allsizes ( d153 ) static INLINE void v_predictor ( uint8_t * dst , ptrdiff_t stride , int bs , const uint8_t * above , const uint8_t * left ) {\n int r ;\n ( void ) left ;\n for ( r = 0 ;\n r < bs ;\n r ++ ) {\n vpx_memcpy ( dst , above , bs ) ;\n dst += stride ;\n }\n }\n intra_pred_allsizes ( v ) static INLINE void h_predictor ( uint8_t * dst , ptrdiff_t stride , int bs , const uint8_t * above , const uint8_t * left ) {\n int r ;\n ( void ) above ;\n for ( r = 0 ;\n r < bs ;\n r ++ ) {\n vpx_memset ( dst , left [ r ] , bs ) ;\n dst += stride ;\n }\n }\n intra_pred_allsizes ( h ) static INLINE void tm_predictor ( uint8_t * dst , ptrdiff_t stride , int bs , const uint8_t * above , const uint8_t * left ) {\n int r , c ;\n int ytop_left = above [ - 1 ] ;\n for ( r = 0 ;\n r < bs ;\n r ++ ) {\n for ( c = 0 ;\n c < bs ;\n c ++ ) dst [ c ] = clip_pixel ( left [ r ] + above [ c ] - ytop_left ) ;\n dst += stride ;\n }\n }\n intra_pred_allsizes ( tm ) static INLINE void dc_128_predictor ( uint8_t * dst , ptrdiff_t stride , int bs , const uint8_t * above , const uint8_t * left ) {\n int r ;\n ( void ) above ;\n ( void ) left ;\n for ( r = 0 ;\n r < bs ;\n r ++ ) {\n vpx_memset ( dst , 128 , bs ) ;\n dst += stride ;\n }\n }\n intra_pred_allsizes ( dc_128 ) static INLINE void dc_left_predictor ( uint8_t * dst , ptrdiff_t stride , int bs , const uint8_t * above , const uint8_t * left ) {\n int i , r , expected_dc , sum = 0 ;\n ( void ) above ;\n for ( i = 0 ;\n i < bs ;\n i ++ ) sum += left [ i ] ;\n expected_dc = ( sum + ( bs >> 1 ) ) / bs ;\n for ( r = 0 ;\n r < bs ;\n r ++ ) {\n vpx_memset ( dst , expected_dc , bs ) ;\n dst += stride ;\n }\n }\n intra_pred_allsizes ( dc_left ) static INLINE void dc_top_predictor ( uint8_t * dst , ptrdiff_t stride , int bs , const uint8_t * above , const uint8_t * left ) {\n int i , r , expected_dc , sum = 0 ;\n ( void ) left ;\n for ( i = 0 ;\n i < bs ;\n i ++ ) sum += above [ i ] ;\n expected_dc = ( sum + ( bs >> 1 ) ) / bs ;\n for ( r = 0 ;\n r < bs ;\n r ++ ) {\n vpx_memset ( dst , expected_dc , bs ) ;\n dst += stride ;\n }\n }\n intra_pred_allsizes ( dc_top )", "idx": 21485}
{"hash": 6500423400461365723, "project": "debian", "size": 24, "label": 0, "functionSource": "static Dwarf_Bool is_64bit_abs_reloc ( unsigned int type , Dwarf_Half machine ) {\n Dwarf_Bool r = 0 ;\n switch ( machine ) {\n # if defined ( EM_MIPS ) && defined ( R_MIPS_64 ) case EM_MIPS : r = ( 0 # if defined ( R_MIPS_64 ) | ( type == R_MIPS_64 ) # endif # if defined ( R_MIPS_32 ) | ( type == R_MIPS_32 ) # endif # if defined ( R_MIPS_TLS_DTPREL64 ) | ( type == R_MIPS_TLS_DTPREL64 ) # endif ) ;\n break ;\n # endif # if defined ( EM_SPARC32PLUS ) && defined ( R_SPARC_UA64 ) case EM_SPARC32PLUS : r = ( type == R_SPARC_UA64 ) ;\n break ;\n # endif # if defined ( EM_SPARCV9 ) && defined ( R_SPARC_UA64 ) case EM_SPARCV9 : r = ( 0 # if defined ( R_SPARC_UA64 ) | ( type == R_SPARC_UA64 ) # endif # if defined ( R_SPARC_TLS_DTPOFF64 ) | ( type == R_SPARC_TLS_DTPOFF64 ) # endif ) ;\n break ;\n # endif # if defined ( EM_SPARC ) && defined ( R_SPARC_UA64 ) case EM_SPARC : r = ( 0 # if defined ( R_SPARC_UA64 ) | ( type == R_SPARC_UA64 ) # endif # if defined ( R_SPARC_TLS_DTPOFF64 ) | ( type == R_SPARC_TLS_DTPOFF64 ) # endif ) ;\n break ;\n # endif # if defined ( EM_IA_64 ) && defined ( R_IA64_SECREL64LSB ) case EM_IA_64 : r = ( 0 # if defined ( R_IA64_SECREL64LSB ) | ( type == R_IA64_SECREL64LSB ) # endif # if defined ( R_IA64_SECREL32LSB ) | ( type == R_IA64_SECREL32LSB ) # endif # if defined ( R_IA64_DIR64LSB ) | ( type == R_IA64_DIR64LSB ) # endif # if defined ( R_IA64_DTPREL64LSB ) | ( type == R_IA64_DTPREL64LSB ) # endif # if defined ( R_IA64_REL32LSB ) | ( type == R_IA64_REL32LSB ) # endif ) ;\n break ;\n # endif # if defined ( EM_PPC64 ) && defined ( R_PPC64_ADDR64 ) case EM_PPC64 : r = ( 0 # if defined ( R_PPC64_ADDR64 ) | ( type == R_PPC64_ADDR64 ) # endif # if defined ( R_PPC64_DTPREL64 ) | ( type == R_PPC64_DTPREL64 ) # endif ) ;\n break ;\n # endif # if defined ( EM_S390 ) && defined ( R_390_64 ) case EM_S390 : r = ( 0 # if defined ( R_390_64 ) | ( type == R_390_64 ) # endif # if defined ( R_390_TLS_LDO64 ) | ( type == R_390_TLS_LDO64 ) # endif ) ;\n break ;\n # endif # if defined ( EM_X86_64 ) && defined ( R_X86_64_64 ) # if defined ( EM_K10M ) case EM_K10M : # endif # if defined ( EM_L10M ) case EM_L10M : # endif case EM_X86_64 : r = ( 0 # if defined ( R_X86_64_64 ) | ( type == R_X86_64_64 ) # endif # if defined ( R_X86_64_DTPOFF32 ) | ( type == R_X86_64_DTPOFF64 ) # endif ) ;\n break ;\n # endif # if defined ( EM_AARCH64 ) && defined ( R_AARCH64_ABS64 ) case EM_AARCH64 : r = ( 0 # if defined ( R_AARCH64_ABS64 ) | ( type == R_AARCH64_ABS64 ) # endif ) ;\n break ;\n # endif }\n return r ;\n }", "idx": 21486}
{"hash": -2423144171479606949, "project": "debian", "size": 6, "label": 0, "functionSource": "static void pdf_show_space ( fz_context * ctx , pdf_run_processor * pr , float tadj ) {\n pdf_gstate * gstate = pr -> gstate + pr -> gtop ;\n pdf_font_desc * fontdesc = gstate -> text . font ;\n if ( fontdesc -> wmode == 0 ) fz_pre_translate ( & pr -> tos . tm , tadj * gstate -> text . scale , 0 ) ;\n else fz_pre_translate ( & pr -> tos . tm , 0 , tadj ) ;\n }", "idx": 21487}
{"hash": 1760449185745615462, "project": "debian", "size": 8, "label": 0, "functionSource": "TSAction TSCacheRead ( TSCont contp , TSCacheKey key ) {\n sdk_assert ( sdk_sanity_check_iocore_structure ( contp ) == TS_SUCCESS ) ;\n sdk_assert ( sdk_sanity_check_cachekey ( key ) == TS_SUCCESS ) ;\n FORCE_PLUGIN_SCOPED_MUTEX ( contp ) ;\n CacheInfo * info = ( CacheInfo * ) key ;\n Continuation * i = ( INKContInternal * ) contp ;\n return ( TSAction ) cacheProcessor . open_read ( i , & info -> cache_key , true , info -> frag_type , info -> hostname , info -> len ) ;\n }", "idx": 21488}
{"hash": -3062453801436404700, "project": "debian", "size": 4, "label": 0, "functionSource": "static void dtls1_clear_queues ( SSL * s ) {\n dtls1_clear_received_buffer ( s ) ;\n dtls1_clear_sent_buffer ( s ) ;\n }", "idx": 21489}
{"hash": 1773163316021227217, "project": "debian", "size": 44, "label": 1, "functionSource": "static void cmd_channel_add_modify ( const char * data , gboolean add ) {\n GHashTable * optlist ;\n CHATNET_REC * chatnetrec ;\n CHANNEL_SETUP_REC * rec ;\n char * botarg , * botcmdarg , * chatnet , * channel , * password ;\n void * free_arg ;\n if ( ! cmd_get_params ( data , & free_arg , 3 | PARAM_FLAG_OPTIONS , \"channel add\" , & optlist , & channel , & chatnet , & password ) ) return ;\n if ( * chatnet == '\\0' || * channel == '\\0' ) {\n cmd_param_error ( CMDERR_NOT_ENOUGH_PARAMS ) ;\n }\n chatnetrec = chatnet_find ( chatnet ) ;\n if ( chatnetrec == NULL ) {\n printformat ( NULL , NULL , MSGLEVEL_CLIENTNOTICE , TXT_UNKNOWN_CHATNET , chatnet ) ;\n cmd_params_free ( free_arg ) ;\n return ;\n }\n botarg = g_hash_table_lookup ( optlist , \"bots\" ) ;\n botcmdarg = g_hash_table_lookup ( optlist , \"botcmd\" ) ;\n rec = channel_setup_find ( channel , chatnet ) ;\n if ( rec == NULL ) {\n if ( add == FALSE ) {\n cmd_params_free ( free_arg ) ;\n printformat ( NULL , NULL , MSGLEVEL_CLIENTNOTICE , TXT_CHANSETUP_NOT_FOUND , channel , chatnet ) ;\n return ;\n }\n rec = CHAT_PROTOCOL ( chatnetrec ) -> create_channel_setup ( ) ;\n rec -> name = g_strdup ( channel ) ;\n rec -> chatnet = g_strdup ( chatnet ) ;\n }\n else {\n if ( g_hash_table_lookup ( optlist , \"bots\" ) ) g_free_and_null ( rec -> botmasks ) ;\n if ( g_hash_table_lookup ( optlist , \"botcmd\" ) ) g_free_and_null ( rec -> autosendcmd ) ;\n if ( * password != '\\0' ) g_free_and_null ( rec -> password ) ;\n }\n if ( g_hash_table_lookup ( optlist , \"auto\" ) ) rec -> autojoin = TRUE ;\n if ( g_hash_table_lookup ( optlist , \"noauto\" ) ) rec -> autojoin = FALSE ;\n if ( botarg != NULL && * botarg != '\\0' ) rec -> botmasks = g_strdup ( botarg ) ;\n if ( botcmdarg != NULL && * botcmdarg != '\\0' ) rec -> autosendcmd = g_strdup ( botcmdarg ) ;\n if ( * password != '\\0' && g_strcmp0 ( password , \"-\" ) != 0 ) rec -> password = g_strdup ( password ) ;\n signal_emit ( \"channel add fill\" , 2 , rec , optlist ) ;\n channel_setup_create ( rec ) ;\n printformat ( NULL , NULL , MSGLEVEL_CLIENTNOTICE , TXT_CHANSETUP_ADDED , channel , chatnet ) ;\n cmd_params_free ( free_arg ) ;\n }", "idx": 21490}
{"hash": -5697857125570093892, "project": "chrome", "size": 9, "label": 0, "functionSource": "static UBool _isExtensionSubtag ( const char * s , int32_t len ) {\n if ( len < 0 ) {\n len = ( int32_t ) uprv_strlen ( s ) ;\n }\n if ( len >= 2 && len <= 8 && _isAlphaNumericString ( s , len ) ) {\n return TRUE ;\n }\n return FALSE ;\n }", "idx": 21491}
{"hash": -1929262071302712016, "project": "debian", "size": 3, "label": 0, "functionSource": "static void Type_Chromaticity_Free ( struct _cms_typehandler_struct * self , void * Ptr ) {\n _cmsFree ( self -> ContextID , Ptr ) ;\n }", "idx": 21492}
{"hash": -2492312952058578720, "project": "debian", "size": 67, "label": 0, "functionSource": "Jbig2Segment * jbig2_parse_segment_header ( Jbig2Ctx * ctx , uint8_t * buf , size_t buf_size , size_t * p_header_size ) {\n Jbig2Segment * result ;\n uint8_t rtscarf ;\n uint32_t rtscarf_long ;\n uint32_t * referred_to_segments ;\n uint32_t referred_to_segment_count ;\n uint32_t referred_to_segment_size ;\n uint32_t pa_size ;\n uint32_t offset ;\n if ( buf_size < 11 ) return NULL ;\n result = jbig2_new ( ctx , Jbig2Segment , 1 ) ;\n if ( result == NULL ) {\n jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , - 1 , \"failed to allocate segment in jbig2_parse_segment_header\" ) ;\n return result ;\n }\n result -> number = jbig2_get_uint32 ( buf ) ;\n result -> flags = buf [ 4 ] ;\n rtscarf = buf [ 5 ] ;\n if ( ( rtscarf & 0xe0 ) == 0xe0 ) {\n rtscarf_long = jbig2_get_uint32 ( buf + 5 ) ;\n referred_to_segment_count = rtscarf_long & 0x1fffffff ;\n offset = 5 + 4 + ( referred_to_segment_count + 1 ) / 8 ;\n }\n else {\n referred_to_segment_count = ( rtscarf >> 5 ) ;\n offset = 5 + 1 ;\n }\n result -> referred_to_segment_count = referred_to_segment_count ;\n referred_to_segment_size = result -> number <= 256 ? 1 : result -> number <= 65536 ? 2 : 4 ;\n pa_size = result -> flags & 0x40 ? 4 : 1 ;\n if ( offset + referred_to_segment_count * referred_to_segment_size + pa_size + 4 > buf_size ) {\n jbig2_error ( ctx , JBIG2_SEVERITY_DEBUG , result -> number , \"jbig2_parse_segment_header() called with insufficient data\" , - 1 ) ;\n jbig2_free ( ctx -> allocator , result ) ;\n return NULL ;\n }\n if ( referred_to_segment_count ) {\n uint32_t i ;\n referred_to_segments = jbig2_new ( ctx , uint32_t , referred_to_segment_count * referred_to_segment_size ) ;\n if ( referred_to_segments == NULL ) {\n jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , - 1 , \"could not allocate referred_to_segments \" \"in jbig2_parse_segment_header\" ) ;\n return NULL ;\n }\n for ( i = 0 ;\n i < referred_to_segment_count ;\n i ++ ) {\n referred_to_segments [ i ] = ( referred_to_segment_size == 1 ) ? buf [ offset ] : ( referred_to_segment_size == 2 ) ? jbig2_get_uint16 ( buf + offset ) : jbig2_get_uint32 ( buf + offset ) ;\n offset += referred_to_segment_size ;\n jbig2_error ( ctx , JBIG2_SEVERITY_DEBUG , result -> number , \"segment %d refers to segment %d\" , result -> number , referred_to_segments [ i ] ) ;\n }\n result -> referred_to_segments = referred_to_segments ;\n }\n else {\n result -> referred_to_segments = NULL ;\n }\n if ( result -> flags & 0x40 ) {\n result -> page_association = jbig2_get_uint32 ( buf + offset ) ;\n offset += 4 ;\n }\n else {\n result -> page_association = buf [ offset ++ ] ;\n }\n jbig2_error ( ctx , JBIG2_SEVERITY_DEBUG , result -> number , \"segment %d is associated with page %d\" , result -> number , result -> page_association ) ;\n result -> data_length = jbig2_get_uint32 ( buf + offset ) ;\n * p_header_size = offset + 4 ;\n result -> result = NULL ;\n return result ;\n }", "idx": 21493}
{"hash": -650231346353974279, "project": "debian", "size": 24, "label": 0, "functionSource": "void appendConnStrVal ( PQExpBuffer buf , const char * str ) {\n const char * s ;\n bool needquotes ;\n needquotes = true ;\n for ( s = str ;\n * s ;\n s ++ ) {\n if ( ! ( ( * s >= 'a' && * s <= 'z' ) || ( * s >= 'A' && * s <= 'Z' ) || ( * s >= '0' && * s <= '9' ) || * s == '_' || * s == '.' ) ) {\n needquotes = true ;\n break ;\n }\n needquotes = false ;\n }\n if ( needquotes ) {\n appendPQExpBufferChar ( buf , '\\'' ) ;\n while ( * str ) {\n if ( * str == '\\'' || * str == '\\\\' ) appendPQExpBufferChar ( buf , '\\\\' ) ;\n appendPQExpBufferChar ( buf , * str ) ;\n str ++ ;\n }\n appendPQExpBufferChar ( buf , '\\'' ) ;\n }\n else appendPQExpBufferStr ( buf , str ) ;\n }", "idx": 21494}
{"hash": 2546373479020365143, "project": "debian", "size": 3, "label": 0, "functionSource": "int mime_format_int ( char * buf , int32_t val , size_t buf_len ) {\n return ink_fast_itoa ( val , buf , buf_len ) ;\n }", "idx": 21495}
{"hash": -3740862514502467070, "project": "debian", "size": 12, "label": 0, "functionSource": "static void MaxpFromTable ( struct alltabs * at , SplineFont * sf ) {\n struct ttf_table * maxp ;\n maxp = SFFindTable ( sf , CHR ( 'm' , 'a' , 'x' , 'p' ) ) ;\n if ( maxp == NULL && sf -> mm != NULL && sf -> mm -> apple ) maxp = SFFindTable ( sf -> mm -> normal , CHR ( 'm' , 'a' , 'x' , 'p' ) ) ;\n if ( maxp == NULL || maxp -> len < 13 * sizeof ( uint16 ) ) return ;\n at -> maxp . maxZones = memushort ( maxp -> data , maxp -> len , 7 * sizeof ( uint16 ) ) ;\n at -> maxp . maxTwilightPts = memushort ( maxp -> data , maxp -> len , 8 * sizeof ( uint16 ) ) ;\n at -> maxp . maxStorage = memushort ( maxp -> data , maxp -> len , 9 * sizeof ( uint16 ) ) ;\n at -> maxp . maxFDEFs = memushort ( maxp -> data , maxp -> len , 10 * sizeof ( uint16 ) ) ;\n at -> maxp . maxIDEFs = memushort ( maxp -> data , maxp -> len , 11 * sizeof ( uint16 ) ) ;\n at -> maxp . maxStack = memushort ( maxp -> data , maxp -> len , 12 * sizeof ( uint16 ) ) ;\n }", "idx": 21496}
{"hash": -3146697469509848825, "project": "debian", "size": 3, "label": 0, "functionSource": "static int dsa_bits ( const EVP_PKEY * pkey ) {\n return BN_num_bits ( pkey -> pkey . dsa -> p ) ;\n }", "idx": 21497}
{"hash": -3819889754140204145, "project": "debian", "size": 27, "label": 0, "functionSource": "static void add_cdps ( linked_list_t * list , linked_list_t * uris , linked_list_t * issuers ) {\n identification_t * issuer , * id ;\n enumerator_t * enumerator ;\n x509_cdp_t * cdp ;\n char * uri ;\n while ( uris -> remove_last ( uris , ( void * * ) & id ) == SUCCESS ) {\n if ( gn_to_string ( id , & uri ) ) {\n if ( issuers -> get_count ( issuers ) ) {\n enumerator = issuers -> create_enumerator ( issuers ) ;\n while ( enumerator -> enumerate ( enumerator , & issuer ) ) {\n INIT ( cdp , . uri = strdup ( uri ) , . issuer = issuer -> clone ( issuer ) , ) ;\n list -> insert_last ( list , cdp ) ;\n }\n enumerator -> destroy ( enumerator ) ;\n free ( uri ) ;\n }\n else {\n INIT ( cdp , . uri = uri , ) ;\n list -> insert_last ( list , cdp ) ;\n }\n }\n id -> destroy ( id ) ;\n }\n while ( issuers -> remove_last ( issuers , ( void * * ) & id ) == SUCCESS ) {\n id -> destroy ( id ) ;\n }\n }", "idx": 21498}
{"hash": -5260094338219889901, "project": "debian", "size": 5, "label": 0, "functionSource": "static void stroke_memusage ( private_stroke_socket_t * this , stroke_msg_t * msg , FILE * out ) {\n if ( lib -> leak_detective ) {\n lib -> leak_detective -> usage ( lib -> leak_detective , ( leak_detective_report_cb_t ) report_usage , ( leak_detective_summary_cb_t ) sum_usage , out ) ;\n }\n }", "idx": 21499}
{"hash": -6552851419396579257, "project": "debian", "size": 17, "label": 0, "functionSource": "static int SpoolssWritePrinter_q ( tvbuff_t * tvb , int offset , packet_info * pinfo , proto_tree * tree , dcerpc_info * di , guint8 * drep ) {\n e_ctx_hnd policy_hnd ;\n char * pol_name ;\n guint32 size ;\n proto_item * item ;\n proto_tree * subtree ;\n offset = dissect_nt_policy_hnd ( tvb , offset , pinfo , tree , di , drep , hf_hnd , & policy_hnd , NULL , FALSE , FALSE ) ;\n dcerpc_fetch_polhnd_data ( & policy_hnd , & pol_name , NULL , NULL , NULL , pinfo -> num ) ;\n if ( pol_name ) col_append_fstr ( pinfo -> cinfo , COL_INFO , \", %s\" , pol_name ) ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , tree , di , drep , hf_buffer_size , & size ) ;\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \", %d bytes\" , size ) ;\n subtree = proto_tree_add_subtree ( tree , tvb , offset , 0 , ett_writeprinter_buffer , & item , \"Buffer\" ) ;\n offset = dissect_ndr_uint8s ( tvb , offset , pinfo , subtree , di , drep , hf_buffer_data , size , NULL ) ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , subtree , di , drep , hf_buffer_size , NULL ) ;\n proto_item_set_len ( item , size + 4 ) ;\n return offset ;\n }", "idx": 21500}
{"hash": 6595989226414083189, "project": "debian", "size": 3, "label": 0, "functionSource": "static __always_inline __u64 __be64_to_cpup ( const __be64 * p ) {\n return __swab64p ( ( __u64 * ) p ) ;\n }", "idx": 21501}
{"hash": 4704178797381506498, "project": "debian", "size": 19, "label": 0, "functionSource": "static int create_history_entry ( krb5_context context , krb5_keyblock * hist_key , int n_key_data , krb5_key_data * key_data , osa_pw_hist_ent * hist ) {\n krb5_error_code ret ;\n krb5_keyblock key ;\n krb5_keysalt salt ;\n int i ;\n hist -> key_data = k5calloc ( n_key_data , sizeof ( krb5_key_data ) , & ret ) ;\n if ( hist -> key_data == NULL ) return ret ;\n for ( i = 0 ;\n i < n_key_data ;\n i ++ ) {\n ret = krb5_dbe_decrypt_key_data ( context , NULL , & key_data [ i ] , & key , & salt ) ;\n if ( ret ) return ret ;\n ret = krb5_dbe_encrypt_key_data ( context , hist_key , & key , & salt , key_data [ i ] . key_data_kvno , & hist -> key_data [ i ] ) ;\n if ( ret ) return ret ;\n krb5_free_keyblock_contents ( context , & key ) ;\n }\n hist -> n_key_data = n_key_data ;\n return 0 ;\n }", "idx": 21502}
{"hash": 2917602761308156638, "project": "debian", "size": 47, "label": 1, "functionSource": "static Asn1Generic * DecodeAsn1DerSequence ( const unsigned char * buffer , uint32_t max_size , uint8_t depth , uint32_t * errcode ) {\n const unsigned char * d_ptr = buffer ;\n uint32_t d_length , parsed_bytes , numbytes , el_max_size ;\n uint8_t c ;\n uint32_t seq_index ;\n Asn1Generic * node ;\n d_ptr ++ ;\n node = Asn1GenericNew ( ) ;\n if ( node == NULL ) return NULL ;\n node -> type = ASN1_SEQUENCE ;\n c = d_ptr [ 0 ] ;\n if ( ( c & ( 1 << 7 ) ) >> 7 == 0 ) {\n d_length = c ;\n d_ptr ++ ;\n }\n else {\n numbytes = c & 0x7f ;\n d_ptr ++ ;\n if ( DecodeAsn1BuildValue ( & d_ptr , & d_length , numbytes , errcode ) == - 1 ) {\n SCFree ( node ) ;\n return NULL ;\n }\n }\n node -> length = d_length + ( d_ptr - buffer ) ;\n if ( node -> length > max_size ) {\n SCFree ( node ) ;\n return NULL ;\n }\n parsed_bytes = 0 ;\n seq_index = 0 ;\n while ( parsed_bytes < d_length ) {\n el_max_size = max_size - ( d_ptr - buffer ) ;\n Asn1Generic * child = DecodeAsn1DerGeneric ( d_ptr , el_max_size , depth , seq_index , errcode ) ;\n if ( child == NULL ) {\n break ;\n }\n int ret = Asn1SequenceAppend ( node , child ) ;\n if ( ret == - 1 ) {\n DerFree ( child ) ;\n break ;\n }\n parsed_bytes += child -> length ;\n d_ptr += child -> length ;\n seq_index ++ ;\n }\n return ( Asn1Generic * ) node ;\n }", "idx": 21503}
{"hash": 4180964683905830761, "project": "debian", "size": 11, "label": 0, "functionSource": "static int selinux_bprm_secureexec ( struct linux_binprm * bprm ) {\n const struct task_security_struct * tsec = current_security ( ) ;\n u32 sid , osid ;\n int atsecure = 0 ;\n sid = tsec -> sid ;\n osid = tsec -> osid ;\n if ( osid != sid ) {\n atsecure = avc_has_perm ( osid , sid , SECCLASS_PROCESS , PROCESS__NOATSECURE , NULL ) ;\n }\n return ! ! atsecure ;\n }", "idx": 21504}
{"hash": -7599707968689691014, "project": "debian", "size": 662, "label": 1, "functionSource": "php_stream * php_stream_url_wrap_http_ex ( php_stream_wrapper * wrapper , const char * path , const char * mode , int options , char * * opened_path , php_stream_context * context , int redirect_max , int flags STREAMS_DC TSRMLS_DC ) {\n php_stream * stream = NULL ;\n php_url * resource = NULL ;\n int use_ssl ;\n int use_proxy = 0 ;\n char * scratch = NULL ;\n char * tmp = NULL ;\n char * ua_str = NULL ;\n zval * * ua_zval = NULL , * * tmpzval = NULL , * ssl_proxy_peer_name = NULL ;\n int scratch_len = 0 ;\n int body = 0 ;\n char location [ HTTP_HEADER_BLOCK_SIZE ] ;\n zval * response_header = NULL ;\n int reqok = 0 ;\n char * http_header_line = NULL ;\n char tmp_line [ 128 ] ;\n size_t chunk_size = 0 , file_size = 0 ;\n int eol_detect = 0 ;\n char * transport_string , * errstr = NULL ;\n int transport_len , have_header = 0 , request_fulluri = 0 , ignore_errors = 0 ;\n char * protocol_version = NULL ;\n int protocol_version_len = 3 ;\n struct timeval timeout ;\n char * user_headers = NULL ;\n int header_init = ( ( flags & HTTP_WRAPPER_HEADER_INIT ) != 0 ) ;\n int redirected = ( ( flags & HTTP_WRAPPER_REDIRECTED ) != 0 ) ;\n int follow_location = 1 ;\n php_stream_filter * transfer_encoding = NULL ;\n int response_code ;\n tmp_line [ 0 ] = '\\0' ;\n if ( redirect_max < 1 ) {\n php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , \"Redirection limit reached, aborting\" ) ;\n return NULL ;\n }\n resource = php_url_parse ( path ) ;\n if ( resource == NULL ) {\n return NULL ;\n }\n if ( strncasecmp ( resource -> scheme , \"http\" , sizeof ( \"http\" ) ) && strncasecmp ( resource -> scheme , \"https\" , sizeof ( \"https\" ) ) ) {\n if ( ! context || php_stream_context_get_option ( context , wrapper -> wops -> label , \"proxy\" , & tmpzval ) == FAILURE || Z_TYPE_PP ( tmpzval ) != IS_STRING || Z_STRLEN_PP ( tmpzval ) <= 0 ) {\n php_url_free ( resource ) ;\n return php_stream_open_wrapper_ex ( path , mode , REPORT_ERRORS , NULL , context ) ;\n }\n request_fulluri = 1 ;\n use_ssl = 0 ;\n use_proxy = 1 ;\n transport_len = Z_STRLEN_PP ( tmpzval ) ;\n transport_string = estrndup ( Z_STRVAL_PP ( tmpzval ) , Z_STRLEN_PP ( tmpzval ) ) ;\n }\n else {\n if ( strpbrk ( mode , \"awx+\" ) ) {\n php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , \"HTTP wrapper does not support writeable connections\" ) ;\n php_url_free ( resource ) ;\n return NULL ;\n }\n use_ssl = resource -> scheme && ( strlen ( resource -> scheme ) > 4 ) && resource -> scheme [ 4 ] == 's' ;\n if ( use_ssl && resource -> port == 0 ) resource -> port = 443 ;\n else if ( resource -> port == 0 ) resource -> port = 80 ;\n if ( context && php_stream_context_get_option ( context , wrapper -> wops -> label , \"proxy\" , & tmpzval ) == SUCCESS && Z_TYPE_PP ( tmpzval ) == IS_STRING && Z_STRLEN_PP ( tmpzval ) > 0 ) {\n use_proxy = 1 ;\n transport_len = Z_STRLEN_PP ( tmpzval ) ;\n transport_string = estrndup ( Z_STRVAL_PP ( tmpzval ) , Z_STRLEN_PP ( tmpzval ) ) ;\n }\n else {\n transport_len = spprintf ( & transport_string , 0 , \"%s://%s:%d\" , use_ssl ? \"ssl\" : \"tcp\" , resource -> host , resource -> port ) ;\n }\n }\n if ( context && php_stream_context_get_option ( context , wrapper -> wops -> label , \"timeout\" , & tmpzval ) == SUCCESS ) {\n SEPARATE_ZVAL ( tmpzval ) ;\n convert_to_double_ex ( tmpzval ) ;\n timeout . tv_sec = ( time_t ) Z_DVAL_PP ( tmpzval ) ;\n timeout . tv_usec = ( size_t ) ( ( Z_DVAL_PP ( tmpzval ) - timeout . tv_sec ) * 1000000 ) ;\n }\n else {\n timeout . tv_sec = FG ( default_socket_timeout ) ;\n timeout . tv_usec = 0 ;\n }\n stream = php_stream_xport_create ( transport_string , transport_len , options , STREAM_XPORT_CLIENT | STREAM_XPORT_CONNECT , NULL , & timeout , context , & errstr , NULL ) ;\n if ( stream ) {\n php_stream_set_option ( stream , PHP_STREAM_OPTION_READ_TIMEOUT , 0 , & timeout ) ;\n }\n if ( errstr ) {\n php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , \"%s\" , errstr ) ;\n efree ( errstr ) ;\n errstr = NULL ;\n }\n efree ( transport_string ) ;\n if ( stream && use_proxy && use_ssl ) {\n smart_str header = {\n 0 }\n ;\n if ( ! context || php_stream_context_get_option ( context , \"ssl\" , \"peer_name\" , & tmpzval ) == FAILURE ) {\n MAKE_STD_ZVAL ( ssl_proxy_peer_name ) ;\n ZVAL_STRING ( ssl_proxy_peer_name , resource -> host , 1 ) ;\n php_stream_context_set_option ( stream -> context , \"ssl\" , \"peer_name\" , ssl_proxy_peer_name ) ;\n }\n smart_str_appendl ( & header , \"CONNECT \" , sizeof ( \"CONNECT \" ) - 1 ) ;\n smart_str_appends ( & header , resource -> host ) ;\n smart_str_appendc ( & header , ':' ) ;\n smart_str_append_unsigned ( & header , resource -> port ) ;\n smart_str_appendl ( & header , \" HTTP/1.0\\r\\n\" , sizeof ( \" HTTP/1.0\\r\\n\" ) - 1 ) ;\n if ( context && php_stream_context_get_option ( context , \"http\" , \"header\" , & tmpzval ) == SUCCESS ) {\n char * s , * p ;\n if ( Z_TYPE_PP ( tmpzval ) == IS_ARRAY ) {\n HashPosition pos ;\n zval * * tmpheader = NULL ;\n for ( zend_hash_internal_pointer_reset_ex ( Z_ARRVAL_PP ( tmpzval ) , & pos ) ;\n SUCCESS == zend_hash_get_current_data_ex ( Z_ARRVAL_PP ( tmpzval ) , ( void * ) & tmpheader , & pos ) ;\n zend_hash_move_forward_ex ( Z_ARRVAL_PP ( tmpzval ) , & pos ) ) {\n if ( Z_TYPE_PP ( tmpheader ) == IS_STRING ) {\n s = Z_STRVAL_PP ( tmpheader ) ;\n do {\n while ( * s == ' ' || * s == '\\t' ) s ++ ;\n p = s ;\n while ( * p != 0 && * p != ':' && * p != '\\r' && * p != '\\n' ) p ++ ;\n if ( * p == ':' ) {\n p ++ ;\n if ( p - s == sizeof ( \"Proxy-Authorization:\" ) - 1 && zend_binary_strcasecmp ( s , sizeof ( \"Proxy-Authorization:\" ) - 1 , \"Proxy-Authorization:\" , sizeof ( \"Proxy-Authorization:\" ) - 1 ) == 0 ) {\n while ( * p != 0 && * p != '\\r' && * p != '\\n' ) p ++ ;\n smart_str_appendl ( & header , s , p - s ) ;\n smart_str_appendl ( & header , \"\\r\\n\" , sizeof ( \"\\r\\n\" ) - 1 ) ;\n goto finish ;\n }\n else {\n while ( * p != 0 && * p != '\\r' && * p != '\\n' ) p ++ ;\n }\n }\n s = p ;\n while ( * s == '\\r' || * s == '\\n' ) s ++ ;\n }\n while ( * s != 0 ) ;\n }\n }\n }\n else if ( Z_TYPE_PP ( tmpzval ) == IS_STRING && Z_STRLEN_PP ( tmpzval ) ) {\n s = Z_STRVAL_PP ( tmpzval ) ;\n do {\n while ( * s == ' ' || * s == '\\t' ) s ++ ;\n p = s ;\n while ( * p != 0 && * p != ':' && * p != '\\r' && * p != '\\n' ) p ++ ;\n if ( * p == ':' ) {\n p ++ ;\n if ( p - s == sizeof ( \"Proxy-Authorization:\" ) - 1 && zend_binary_strcasecmp ( s , sizeof ( \"Proxy-Authorization:\" ) - 1 , \"Proxy-Authorization:\" , sizeof ( \"Proxy-Authorization:\" ) - 1 ) == 0 ) {\n while ( * p != 0 && * p != '\\r' && * p != '\\n' ) p ++ ;\n smart_str_appendl ( & header , s , p - s ) ;\n smart_str_appendl ( & header , \"\\r\\n\" , sizeof ( \"\\r\\n\" ) - 1 ) ;\n goto finish ;\n }\n else {\n while ( * p != 0 && * p != '\\r' && * p != '\\n' ) p ++ ;\n }\n }\n s = p ;\n while ( * s == '\\r' || * s == '\\n' ) s ++ ;\n }\n while ( * s != 0 ) ;\n }\n }\n finish : smart_str_appendl ( & header , \"\\r\\n\" , sizeof ( \"\\r\\n\" ) - 1 ) ;\n if ( php_stream_write ( stream , header . c , header . len ) != header . len ) {\n php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , \"Cannot connect to HTTPS server through proxy\" ) ;\n php_stream_close ( stream ) ;\n stream = NULL ;\n }\n smart_str_free ( & header ) ;\n if ( stream ) {\n char header_line [ HTTP_HEADER_BLOCK_SIZE ] ;\n while ( php_stream_gets ( stream , header_line , HTTP_HEADER_BLOCK_SIZE - 1 ) != NULL ) {\n if ( header_line [ 0 ] == '\\n' || header_line [ 0 ] == '\\r' || header_line [ 0 ] == '\\0' ) {\n break ;\n }\n }\n }\n if ( stream ) {\n if ( php_stream_xport_crypto_setup ( stream , STREAM_CRYPTO_METHOD_SSLv23_CLIENT , NULL TSRMLS_CC ) < 0 || php_stream_xport_crypto_enable ( stream , 1 TSRMLS_CC ) < 0 ) {\n php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , \"Cannot connect to HTTPS server through proxy\" ) ;\n php_stream_close ( stream ) ;\n stream = NULL ;\n }\n }\n }\n if ( stream == NULL ) goto out ;\n if ( options & STREAM_WILL_CAST ) chunk_size = php_stream_set_chunk_size ( stream , 1 ) ;\n eol_detect = stream -> flags & ( PHP_STREAM_FLAG_DETECT_EOL | PHP_STREAM_FLAG_EOL_MAC ) ;\n stream -> flags &= ~ ( PHP_STREAM_FLAG_DETECT_EOL | PHP_STREAM_FLAG_EOL_MAC ) ;\n php_stream_context_set ( stream , context ) ;\n php_stream_notify_info ( context , PHP_STREAM_NOTIFY_CONNECT , NULL , 0 ) ;\n if ( header_init && context && php_stream_context_get_option ( context , \"http\" , \"max_redirects\" , & tmpzval ) == SUCCESS ) {\n SEPARATE_ZVAL ( tmpzval ) ;\n convert_to_long_ex ( tmpzval ) ;\n redirect_max = Z_LVAL_PP ( tmpzval ) ;\n }\n if ( context && php_stream_context_get_option ( context , \"http\" , \"method\" , & tmpzval ) == SUCCESS ) {\n if ( Z_TYPE_PP ( tmpzval ) == IS_STRING && Z_STRLEN_PP ( tmpzval ) > 0 ) {\n if ( ! redirected || ( Z_STRLEN_PP ( tmpzval ) == 3 && memcmp ( \"GET\" , Z_STRVAL_PP ( tmpzval ) , 3 ) == 0 ) || ( Z_STRLEN_PP ( tmpzval ) == 4 && memcmp ( \"HEAD\" , Z_STRVAL_PP ( tmpzval ) , 4 ) == 0 ) ) {\n scratch_len = strlen ( path ) + 29 + Z_STRLEN_PP ( tmpzval ) ;\n scratch = emalloc ( scratch_len ) ;\n strlcpy ( scratch , Z_STRVAL_PP ( tmpzval ) , Z_STRLEN_PP ( tmpzval ) + 1 ) ;\n strncat ( scratch , \" \" , 1 ) ;\n }\n }\n }\n if ( context && php_stream_context_get_option ( context , \"http\" , \"protocol_version\" , & tmpzval ) == SUCCESS ) {\n SEPARATE_ZVAL ( tmpzval ) ;\n convert_to_double_ex ( tmpzval ) ;\n protocol_version_len = spprintf ( & protocol_version , 0 , \"%.1F\" , Z_DVAL_PP ( tmpzval ) ) ;\n }\n if ( ! scratch ) {\n scratch_len = strlen ( path ) + 29 + protocol_version_len ;\n scratch = emalloc ( scratch_len ) ;\n strncpy ( scratch , \"GET \" , scratch_len ) ;\n }\n if ( ! request_fulluri && context && php_stream_context_get_option ( context , \"http\" , \"request_fulluri\" , & tmpzval ) == SUCCESS ) {\n zval ztmp = * * tmpzval ;\n zval_copy_ctor ( & ztmp ) ;\n convert_to_boolean ( & ztmp ) ;\n request_fulluri = Z_BVAL ( ztmp ) ? 1 : 0 ;\n zval_dtor ( & ztmp ) ;\n }\n if ( request_fulluri ) {\n strcat ( scratch , path ) ;\n }\n else {\n if ( resource -> path && * resource -> path ) {\n strlcat ( scratch , resource -> path , scratch_len ) ;\n }\n else {\n strlcat ( scratch , \"/\" , scratch_len ) ;\n }\n if ( resource -> query ) {\n strlcat ( scratch , \"?\" , scratch_len ) ;\n strlcat ( scratch , resource -> query , scratch_len ) ;\n }\n }\n if ( protocol_version ) {\n strlcat ( scratch , \" HTTP/\" , scratch_len ) ;\n strlcat ( scratch , protocol_version , scratch_len ) ;\n strlcat ( scratch , \"\\r\\n\" , scratch_len ) ;\n }\n else {\n strlcat ( scratch , \" HTTP/1.0\\r\\n\" , scratch_len ) ;\n }\n php_stream_write ( stream , scratch , strlen ( scratch ) ) ;\n if ( context && php_stream_context_get_option ( context , \"http\" , \"header\" , & tmpzval ) == SUCCESS ) {\n tmp = NULL ;\n if ( Z_TYPE_PP ( tmpzval ) == IS_ARRAY ) {\n HashPosition pos ;\n zval * * tmpheader = NULL ;\n smart_str tmpstr = {\n 0 }\n ;\n for ( zend_hash_internal_pointer_reset_ex ( Z_ARRVAL_PP ( tmpzval ) , & pos ) ;\n SUCCESS == zend_hash_get_current_data_ex ( Z_ARRVAL_PP ( tmpzval ) , ( void * ) & tmpheader , & pos ) ;\n zend_hash_move_forward_ex ( Z_ARRVAL_PP ( tmpzval ) , & pos ) ) {\n if ( Z_TYPE_PP ( tmpheader ) == IS_STRING ) {\n smart_str_appendl ( & tmpstr , Z_STRVAL_PP ( tmpheader ) , Z_STRLEN_PP ( tmpheader ) ) ;\n smart_str_appendl ( & tmpstr , \"\\r\\n\" , sizeof ( \"\\r\\n\" ) - 1 ) ;\n }\n }\n smart_str_0 ( & tmpstr ) ;\n if ( tmpstr . c ) {\n tmp = php_trim ( tmpstr . c , strlen ( tmpstr . c ) , NULL , 0 , NULL , 3 TSRMLS_CC ) ;\n smart_str_free ( & tmpstr ) ;\n }\n }\n if ( Z_TYPE_PP ( tmpzval ) == IS_STRING && Z_STRLEN_PP ( tmpzval ) ) {\n tmp = php_trim ( Z_STRVAL_PP ( tmpzval ) , Z_STRLEN_PP ( tmpzval ) , NULL , 0 , NULL , 3 TSRMLS_CC ) ;\n }\n if ( tmp && strlen ( tmp ) > 0 ) {\n char * s ;\n user_headers = estrdup ( tmp ) ;\n php_strtolower ( tmp , strlen ( tmp ) ) ;\n if ( ! header_init ) {\n strip_header ( user_headers , tmp , \"content-length:\" ) ;\n strip_header ( user_headers , tmp , \"content-type:\" ) ;\n }\n if ( ( s = strstr ( tmp , \"user-agent:\" ) ) && ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || * ( s - 1 ) == '\\t' || * ( s - 1 ) == ' ' ) ) {\n have_header |= HTTP_HEADER_USER_AGENT ;\n }\n if ( ( s = strstr ( tmp , \"host:\" ) ) && ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || * ( s - 1 ) == '\\t' || * ( s - 1 ) == ' ' ) ) {\n have_header |= HTTP_HEADER_HOST ;\n }\n if ( ( s = strstr ( tmp , \"from:\" ) ) && ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || * ( s - 1 ) == '\\t' || * ( s - 1 ) == ' ' ) ) {\n have_header |= HTTP_HEADER_FROM ;\n }\n if ( ( s = strstr ( tmp , \"authorization:\" ) ) && ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || * ( s - 1 ) == '\\t' || * ( s - 1 ) == ' ' ) ) {\n have_header |= HTTP_HEADER_AUTH ;\n }\n if ( ( s = strstr ( tmp , \"content-length:\" ) ) && ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || * ( s - 1 ) == '\\t' || * ( s - 1 ) == ' ' ) ) {\n have_header |= HTTP_HEADER_CONTENT_LENGTH ;\n }\n if ( ( s = strstr ( tmp , \"content-type:\" ) ) && ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || * ( s - 1 ) == '\\t' || * ( s - 1 ) == ' ' ) ) {\n have_header |= HTTP_HEADER_TYPE ;\n }\n if ( ( s = strstr ( tmp , \"connection:\" ) ) && ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || * ( s - 1 ) == '\\t' || * ( s - 1 ) == ' ' ) ) {\n have_header |= HTTP_HEADER_CONNECTION ;\n }\n if ( use_proxy && use_ssl && ( s = strstr ( tmp , \"proxy-authorization:\" ) ) && ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || * ( s - 1 ) == '\\t' || * ( s - 1 ) == ' ' ) ) {\n char * p = s + sizeof ( \"proxy-authorization:\" ) - 1 ;\n while ( s > tmp && ( * ( s - 1 ) == ' ' || * ( s - 1 ) == '\\t' ) ) s -- ;\n while ( * p != 0 && * p != '\\r' && * p != '\\n' ) p ++ ;\n while ( * p == '\\r' || * p == '\\n' ) p ++ ;\n if ( * p == 0 ) {\n if ( s == tmp ) {\n efree ( user_headers ) ;\n user_headers = NULL ;\n }\n else {\n while ( s > tmp && ( * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' ) ) s -- ;\n user_headers [ s - tmp ] = 0 ;\n }\n }\n else {\n memmove ( user_headers + ( s - tmp ) , user_headers + ( p - tmp ) , strlen ( p ) + 1 ) ;\n }\n }\n }\n if ( tmp ) {\n efree ( tmp ) ;\n }\n }\n if ( ( ( have_header & HTTP_HEADER_AUTH ) == 0 ) && resource -> user ) {\n php_url_decode ( resource -> user , strlen ( resource -> user ) ) ;\n strcpy ( scratch , resource -> user ) ;\n strcat ( scratch , \":\" ) ;\n if ( resource -> pass ) {\n php_url_decode ( resource -> pass , strlen ( resource -> pass ) ) ;\n strcat ( scratch , resource -> pass ) ;\n }\n tmp = ( char * ) php_base64_encode ( ( unsigned char * ) scratch , strlen ( scratch ) , NULL ) ;\n if ( snprintf ( scratch , scratch_len , \"Authorization: Basic %s\\r\\n\" , tmp ) > 0 ) {\n php_stream_write ( stream , scratch , strlen ( scratch ) ) ;\n php_stream_notify_info ( context , PHP_STREAM_NOTIFY_AUTH_REQUIRED , NULL , 0 ) ;\n }\n efree ( tmp ) ;\n tmp = NULL ;\n }\n if ( ( ( have_header & HTTP_HEADER_FROM ) == 0 ) && FG ( from_address ) ) {\n if ( snprintf ( scratch , scratch_len , \"From: %s\\r\\n\" , FG ( from_address ) ) > 0 ) php_stream_write ( stream , scratch , strlen ( scratch ) ) ;\n }\n if ( ( have_header & HTTP_HEADER_HOST ) == 0 ) {\n if ( ( use_ssl && resource -> port != 443 && resource -> port != 0 ) || ( ! use_ssl && resource -> port != 80 && resource -> port != 0 ) ) {\n if ( snprintf ( scratch , scratch_len , \"Host: %s:%i\\r\\n\" , resource -> host , resource -> port ) > 0 ) php_stream_write ( stream , scratch , strlen ( scratch ) ) ;\n }\n else {\n if ( snprintf ( scratch , scratch_len , \"Host: %s\\r\\n\" , resource -> host ) > 0 ) {\n php_stream_write ( stream , scratch , strlen ( scratch ) ) ;\n }\n }\n }\n if ( ( have_header & HTTP_HEADER_CONNECTION ) == 0 ) {\n php_stream_write_string ( stream , \"Connection: close\\r\\n\" ) ;\n }\n if ( context && php_stream_context_get_option ( context , \"http\" , \"user_agent\" , & ua_zval ) == SUCCESS && Z_TYPE_PP ( ua_zval ) == IS_STRING ) {\n ua_str = Z_STRVAL_PP ( ua_zval ) ;\n }\n else if ( FG ( user_agent ) ) {\n ua_str = FG ( user_agent ) ;\n }\n if ( ( ( have_header & HTTP_HEADER_USER_AGENT ) == 0 ) && ua_str ) {\n # define _UA_HEADER \"User-Agent: %s\\r\\n\" char * ua ;\n size_t ua_len ;\n ua_len = sizeof ( _UA_HEADER ) + strlen ( ua_str ) ;\n if ( ua_len > sizeof ( _UA_HEADER ) ) {\n ua = emalloc ( ua_len + 1 ) ;\n if ( ( ua_len = slprintf ( ua , ua_len , _UA_HEADER , ua_str ) ) > 0 ) {\n ua [ ua_len ] = 0 ;\n php_stream_write ( stream , ua , ua_len ) ;\n }\n else {\n php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Cannot construct User-agent header\" ) ;\n }\n if ( ua ) {\n efree ( ua ) ;\n }\n }\n }\n if ( user_headers ) {\n if ( header_init && context && ! ( have_header & HTTP_HEADER_CONTENT_LENGTH ) && php_stream_context_get_option ( context , \"http\" , \"content\" , & tmpzval ) == SUCCESS && Z_TYPE_PP ( tmpzval ) == IS_STRING && Z_STRLEN_PP ( tmpzval ) > 0 ) {\n scratch_len = slprintf ( scratch , scratch_len , \"Content-Length: %d\\r\\n\" , Z_STRLEN_PP ( tmpzval ) ) ;\n php_stream_write ( stream , scratch , scratch_len ) ;\n have_header |= HTTP_HEADER_CONTENT_LENGTH ;\n }\n php_stream_write ( stream , user_headers , strlen ( user_headers ) ) ;\n php_stream_write ( stream , \"\\r\\n\" , sizeof ( \"\\r\\n\" ) - 1 ) ;\n efree ( user_headers ) ;\n }\n if ( header_init && context && php_stream_context_get_option ( context , \"http\" , \"content\" , & tmpzval ) == SUCCESS && Z_TYPE_PP ( tmpzval ) == IS_STRING && Z_STRLEN_PP ( tmpzval ) > 0 ) {\n if ( ! ( have_header & HTTP_HEADER_CONTENT_LENGTH ) ) {\n scratch_len = slprintf ( scratch , scratch_len , \"Content-Length: %d\\r\\n\" , Z_STRLEN_PP ( tmpzval ) ) ;\n php_stream_write ( stream , scratch , scratch_len ) ;\n }\n if ( ! ( have_header & HTTP_HEADER_TYPE ) ) {\n php_stream_write ( stream , \"Content-Type: application/x-www-form-urlencoded\\r\\n\" , sizeof ( \"Content-Type: application/x-www-form-urlencoded\\r\\n\" ) - 1 ) ;\n php_error_docref ( NULL TSRMLS_CC , E_NOTICE , \"Content-type not specified assuming application/x-www-form-urlencoded\" ) ;\n }\n php_stream_write ( stream , \"\\r\\n\" , sizeof ( \"\\r\\n\" ) - 1 ) ;\n php_stream_write ( stream , Z_STRVAL_PP ( tmpzval ) , Z_STRLEN_PP ( tmpzval ) ) ;\n }\n else {\n php_stream_write ( stream , \"\\r\\n\" , sizeof ( \"\\r\\n\" ) - 1 ) ;\n }\n location [ 0 ] = '\\0' ;\n if ( ! EG ( active_symbol_table ) ) {\n zend_rebuild_symbol_table ( TSRMLS_C ) ;\n }\n if ( header_init ) {\n zval * ztmp ;\n MAKE_STD_ZVAL ( ztmp ) ;\n array_init ( ztmp ) ;\n ZEND_SET_SYMBOL ( EG ( active_symbol_table ) , \"http_response_header\" , ztmp ) ;\n }\n {\n zval * * rh ;\n if ( zend_hash_find ( EG ( active_symbol_table ) , \"http_response_header\" , sizeof ( \"http_response_header\" ) , ( void * * ) & rh ) != SUCCESS || Z_TYPE_PP ( rh ) != IS_ARRAY ) {\n php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , \"HTTP request failed, http_response_header overwritten\" ) ;\n goto out ;\n }\n response_header = * rh ;\n Z_ADDREF_P ( response_header ) ;\n }\n if ( ! php_stream_eof ( stream ) ) {\n size_t tmp_line_len ;\n if ( php_stream_get_line ( stream , tmp_line , sizeof ( tmp_line ) - 1 , & tmp_line_len ) != NULL ) {\n zval * http_response ;\n if ( tmp_line_len > 9 ) {\n response_code = atoi ( tmp_line + 9 ) ;\n }\n else {\n response_code = 0 ;\n }\n if ( context && SUCCESS == php_stream_context_get_option ( context , \"http\" , \"ignore_errors\" , & tmpzval ) ) {\n ignore_errors = zend_is_true ( * tmpzval ) ;\n }\n if ( ( options & STREAM_ONLY_GET_HEADERS ) || ignore_errors ) {\n reqok = 1 ;\n }\n if ( response_code >= 100 && response_code < 200 ) {\n while ( ! php_stream_eof ( stream ) && php_stream_get_line ( stream , tmp_line , sizeof ( tmp_line ) - 1 , & tmp_line_len ) != NULL && ( tmp_line_len < sizeof ( \"HTTP/1\" ) - 1 || strncasecmp ( tmp_line , \"HTTP/1\" , sizeof ( \"HTTP/1\" ) - 1 ) ) ) ;\n if ( tmp_line_len > 9 ) {\n response_code = atoi ( tmp_line + 9 ) ;\n }\n else {\n response_code = 0 ;\n }\n }\n if ( response_code >= 200 && response_code < 400 ) {\n reqok = 1 ;\n }\n else {\n switch ( response_code ) {\n case 403 : php_stream_notify_error ( context , PHP_STREAM_NOTIFY_AUTH_RESULT , tmp_line , response_code ) ;\n break ;\n default : if ( ! tmp_line_len ) {\n tmp_line [ 0 ] = '\\0' ;\n }\n php_stream_notify_error ( context , PHP_STREAM_NOTIFY_FAILURE , tmp_line , response_code ) ;\n }\n }\n if ( tmp_line [ tmp_line_len - 1 ] == '\\n' ) {\n -- tmp_line_len ;\n if ( tmp_line [ tmp_line_len - 1 ] == '\\r' ) {\n -- tmp_line_len ;\n }\n }\n MAKE_STD_ZVAL ( http_response ) ;\n ZVAL_STRINGL ( http_response , tmp_line , tmp_line_len , 1 ) ;\n zend_hash_next_index_insert ( Z_ARRVAL_P ( response_header ) , & http_response , sizeof ( zval * ) , NULL ) ;\n }\n }\n else {\n php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , \"HTTP request failed, unexpected end of socket!\" ) ;\n goto out ;\n }\n http_header_line = emalloc ( HTTP_HEADER_BLOCK_SIZE ) ;\n while ( ! body && ! php_stream_eof ( stream ) ) {\n size_t http_header_line_length ;\n if ( php_stream_get_line ( stream , http_header_line , HTTP_HEADER_BLOCK_SIZE , & http_header_line_length ) && * http_header_line != '\\n' && * http_header_line != '\\r' ) {\n char * e = http_header_line + http_header_line_length - 1 ;\n if ( * e != '\\n' ) {\n do {\n if ( php_stream_get_line ( stream , http_header_line , HTTP_HEADER_BLOCK_SIZE , & http_header_line_length ) == NULL ) {\n php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , \"Failed to read HTTP headers\" ) ;\n goto out ;\n }\n e = http_header_line + http_header_line_length - 1 ;\n }\n while ( * e != '\\n' ) ;\n continue ;\n }\n while ( * e == '\\n' || * e == '\\r' ) {\n e -- ;\n }\n http_header_line_length = e - http_header_line + 1 ;\n http_header_line [ http_header_line_length ] = '\\0' ;\n if ( ! strncasecmp ( http_header_line , \"Location: \" , 10 ) ) {\n if ( context && php_stream_context_get_option ( context , \"http\" , \"follow_location\" , & tmpzval ) == SUCCESS ) {\n SEPARATE_ZVAL ( tmpzval ) ;\n convert_to_long_ex ( tmpzval ) ;\n follow_location = Z_LVAL_PP ( tmpzval ) ;\n }\n else if ( ! ( response_code >= 300 && response_code < 304 || 307 == response_code || 308 == response_code ) ) {\n follow_location = 0 ;\n }\n strlcpy ( location , http_header_line + 10 , sizeof ( location ) ) ;\n }\n else if ( ! strncasecmp ( http_header_line , \"Content-Type: \" , 14 ) ) {\n php_stream_notify_info ( context , PHP_STREAM_NOTIFY_MIME_TYPE_IS , http_header_line + 14 , 0 ) ;\n }\n else if ( ! strncasecmp ( http_header_line , \"Content-Length: \" , 16 ) ) {\n file_size = atoi ( http_header_line + 16 ) ;\n php_stream_notify_file_size ( context , file_size , http_header_line , 0 ) ;\n }\n else if ( ! strncasecmp ( http_header_line , \"Transfer-Encoding: chunked\" , sizeof ( \"Transfer-Encoding: chunked\" ) ) ) {\n if ( ! ( options & STREAM_ONLY_GET_HEADERS ) ) {\n long decode = 1 ;\n if ( context && php_stream_context_get_option ( context , \"http\" , \"auto_decode\" , & tmpzval ) == SUCCESS ) {\n SEPARATE_ZVAL ( tmpzval ) ;\n convert_to_boolean ( * tmpzval ) ;\n decode = Z_LVAL_PP ( tmpzval ) ;\n }\n if ( decode ) {\n transfer_encoding = php_stream_filter_create ( \"dechunk\" , NULL , php_stream_is_persistent ( stream ) TSRMLS_CC ) ;\n if ( transfer_encoding ) {\n continue ;\n }\n }\n }\n }\n if ( http_header_line [ 0 ] == '\\0' ) {\n body = 1 ;\n }\n else {\n zval * http_header ;\n MAKE_STD_ZVAL ( http_header ) ;\n ZVAL_STRINGL ( http_header , http_header_line , http_header_line_length , 1 ) ;\n zend_hash_next_index_insert ( Z_ARRVAL_P ( response_header ) , & http_header , sizeof ( zval * ) , NULL ) ;\n }\n }\n else {\n break ;\n }\n }\n if ( ! reqok || ( location [ 0 ] != '\\0' && follow_location ) ) {\n if ( ! follow_location || ( ( ( options & STREAM_ONLY_GET_HEADERS ) || ignore_errors ) && redirect_max <= 1 ) ) {\n goto out ;\n }\n if ( location [ 0 ] != '\\0' ) php_stream_notify_info ( context , PHP_STREAM_NOTIFY_REDIRECTED , location , 0 ) ;\n php_stream_close ( stream ) ;\n stream = NULL ;\n if ( location [ 0 ] != '\\0' ) {\n char new_path [ HTTP_HEADER_BLOCK_SIZE ] ;\n char loc_path [ HTTP_HEADER_BLOCK_SIZE ] ;\n * new_path = '\\0' ;\n if ( strlen ( location ) < 8 || ( strncasecmp ( location , \"http://\" , sizeof ( \"http://\" ) - 1 ) && strncasecmp ( location , \"https://\" , sizeof ( \"https://\" ) - 1 ) && strncasecmp ( location , \"ftp://\" , sizeof ( \"ftp://\" ) - 1 ) && strncasecmp ( location , \"ftps://\" , sizeof ( \"ftps://\" ) - 1 ) ) ) {\n if ( * location != '/' ) {\n if ( * ( location + 1 ) != '\\0' && resource -> path ) {\n char * s = strrchr ( resource -> path , '/' ) ;\n if ( ! s ) {\n s = resource -> path ;\n if ( ! s [ 0 ] ) {\n efree ( s ) ;\n s = resource -> path = estrdup ( \"/\" ) ;\n }\n else {\n * s = '/' ;\n }\n }\n s [ 1 ] = '\\0' ;\n if ( resource -> path && * ( resource -> path ) == '/' && * ( resource -> path + 1 ) == '\\0' ) {\n snprintf ( loc_path , sizeof ( loc_path ) - 1 , \"%s%s\" , resource -> path , location ) ;\n }\n else {\n snprintf ( loc_path , sizeof ( loc_path ) - 1 , \"%s/%s\" , resource -> path , location ) ;\n }\n }\n else {\n snprintf ( loc_path , sizeof ( loc_path ) - 1 , \"/%s\" , location ) ;\n }\n }\n else {\n strlcpy ( loc_path , location , sizeof ( loc_path ) ) ;\n }\n if ( ( use_ssl && resource -> port != 443 ) || ( ! use_ssl && resource -> port != 80 ) ) {\n snprintf ( new_path , sizeof ( new_path ) - 1 , \"%s://%s:%d%s\" , resource -> scheme , resource -> host , resource -> port , loc_path ) ;\n }\n else {\n snprintf ( new_path , sizeof ( new_path ) - 1 , \"%s://%s%s\" , resource -> scheme , resource -> host , loc_path ) ;\n }\n }\n else {\n strlcpy ( new_path , location , sizeof ( new_path ) ) ;\n }\n php_url_free ( resource ) ;\n if ( ( resource = php_url_parse ( new_path ) ) == NULL ) {\n php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , \"Invalid redirect URL! %s\" , new_path ) ;\n goto out ;\n }\n # define CHECK_FOR_CNTRL_CHARS ( val ) {\n if ( val ) {\n unsigned char * s , * e ;\n int l ;\n l = php_url_decode ( val , strlen ( val ) ) ;\n s = ( unsigned char * ) val ;\n e = s + l ;\n while ( s < e ) {\n if ( iscntrl ( * s ) ) {\n php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , \"Invalid redirect URL! %s\" , new_path ) ;\n goto out ;\n }\n s ++ ;\n }\n }\n \\ }\n if ( strncasecmp ( new_path , \"http://\" , sizeof ( \"http://\" ) - 1 ) || strncasecmp ( new_path , \"https://\" , sizeof ( \"https://\" ) - 1 ) ) {\n CHECK_FOR_CNTRL_CHARS ( resource -> user ) CHECK_FOR_CNTRL_CHARS ( resource -> pass ) CHECK_FOR_CNTRL_CHARS ( resource -> path ) }\n stream = php_stream_url_wrap_http_ex ( wrapper , new_path , mode , options , opened_path , context , -- redirect_max , HTTP_WRAPPER_REDIRECTED STREAMS_CC TSRMLS_CC ) ;\n }\n else {\n php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , \"HTTP request failed! %s\" , tmp_line ) ;\n }\n }\n out : if ( protocol_version ) {\n efree ( protocol_version ) ;\n }\n if ( http_header_line ) {\n efree ( http_header_line ) ;\n }\n if ( scratch ) {\n efree ( scratch ) ;\n }\n if ( resource ) {\n php_url_free ( resource ) ;\n }\n if ( stream ) {\n if ( header_init ) {\n stream -> wrapperdata = response_header ;\n }\n else {\n if ( response_header ) {\n Z_DELREF_P ( response_header ) ;\n }\n }\n php_stream_notify_progress_init ( context , 0 , file_size ) ;\n if ( options & STREAM_WILL_CAST ) php_stream_set_chunk_size ( stream , chunk_size ) ;\n stream -> flags |= eol_detect ;\n stream -> position = 0 ;\n strlcpy ( stream -> mode , mode , sizeof ( stream -> mode ) ) ;\n if ( transfer_encoding ) {\n php_stream_filter_append ( & stream -> readfilters , transfer_encoding ) ;\n }\n }\n else {\n if ( response_header ) {\n Z_DELREF_P ( response_header ) ;\n }\n if ( transfer_encoding ) {\n php_stream_filter_free ( transfer_encoding TSRMLS_CC ) ;\n }\n }\n return stream ;\n }", "idx": 21505}
{"hash": -5260094338219889901, "project": "debian", "size": 49, "label": 0, "functionSource": "static void stroke_export ( private_stroke_socket_t * this , stroke_msg_t * msg , FILE * out ) {\n pop_string ( msg , & msg -> export . selector ) ;\n if ( msg -> export . flags & EXPORT_X509 ) {\n enumerator_t * enumerator ;\n identification_t * id ;\n certificate_t * cert ;\n id = identification_create_from_string ( msg -> export . selector ) ;\n enumerator = lib -> credmgr -> create_cert_enumerator ( lib -> credmgr , CERT_X509 , KEY_ANY , id , FALSE ) ;\n while ( enumerator -> enumerate ( enumerator , & cert ) ) {\n print_pem_cert ( out , cert ) ;\n }\n enumerator -> destroy ( enumerator ) ;\n id -> destroy ( id ) ;\n }\n if ( msg -> export . flags & ( EXPORT_CONN_CERT | EXPORT_CONN_CHAIN ) ) {\n enumerator_t * sas , * auths , * certs ;\n ike_sa_t * ike_sa ;\n auth_cfg_t * auth ;\n certificate_t * cert ;\n auth_rule_t rule ;\n sas = charon -> ike_sa_manager -> create_enumerator ( charon -> ike_sa_manager , TRUE ) ;\n while ( sas -> enumerate ( sas , & ike_sa ) ) {\n if ( streq ( msg -> export . selector , ike_sa -> get_name ( ike_sa ) ) ) {\n auths = ike_sa -> create_auth_cfg_enumerator ( ike_sa , FALSE ) ;\n while ( auths -> enumerate ( auths , & auth ) ) {\n bool got_subject = FALSE ;\n certs = auth -> create_enumerator ( auth ) ;\n while ( certs -> enumerate ( certs , & rule , & cert ) ) {\n switch ( rule ) {\n case AUTH_RULE_CA_CERT : case AUTH_RULE_IM_CERT : if ( msg -> export . flags & EXPORT_CONN_CHAIN ) {\n print_pem_cert ( out , cert ) ;\n }\n break ;\n case AUTH_RULE_SUBJECT_CERT : if ( ! got_subject ) {\n print_pem_cert ( out , cert ) ;\n got_subject = TRUE ;\n }\n break ;\n default : break ;\n }\n }\n certs -> destroy ( certs ) ;\n }\n auths -> destroy ( auths ) ;\n }\n }\n sas -> destroy ( sas ) ;\n }\n }", "idx": 21506}
{"hash": 1245821301839614810, "project": "debian", "size": 19, "label": 0, "functionSource": "static gpointer init_common ( gsize job_size , GtkWindow * parent_window ) {\n CommonJob * common ;\n GdkScreen * screen ;\n common = g_malloc0 ( job_size ) ;\n if ( parent_window ) {\n common -> parent_window = parent_window ;\n g_object_add_weak_pointer ( G_OBJECT ( common -> parent_window ) , ( gpointer * ) & common -> parent_window ) ;\n }\n common -> progress = nautilus_progress_info_new ( ) ;\n common -> cancellable = nautilus_progress_info_get_cancellable ( common -> progress ) ;\n common -> time = g_timer_new ( ) ;\n common -> inhibit_cookie = 0 ;\n common -> screen_num = 0 ;\n if ( parent_window ) {\n screen = gtk_widget_get_screen ( GTK_WIDGET ( parent_window ) ) ;\n common -> screen_num = gdk_screen_get_number ( screen ) ;\n }\n return common ;\n }", "idx": 21507}
{"hash": 3584320764213684062, "project": "debian", "size": 23, "label": 0, "functionSource": "int parse_CRangeCategSpec ( tvbuff_t * tvb , packet_info * pinfo , int offset , proto_tree * parent_tree , proto_tree * pad_tree , const char * fmt , ... ) {\n proto_item * item ;\n proto_tree * tree ;\n va_list ap ;\n unsigned i ;\n const char * txt ;\n guint32 cRange ;\n va_start ( ap , fmt ) ;\n txt = wmem_strdup_vprintf ( wmem_packet_scope ( ) , fmt , ap ) ;\n va_end ( ap ) ;\n tree = proto_tree_add_subtree ( parent_tree , tvb , offset , 0 , ett_CRangeCategSpec , & item , txt ) ;\n offset = parse_lcid ( tvb , offset , tree , \"lcid\" ) ;\n cRange = tvb_get_letohl ( tvb , offset ) ;\n proto_tree_add_uint ( tree , hf_mswsp_crangecategspec_crange , tvb , offset , 4 , cRange ) ;\n offset += 4 ;\n for ( i = 0 ;\n i < cRange ;\n i ++ ) {\n offset = parse_RANGEBOUNDARY ( tvb , pinfo , offset , tree , pad_tree , \"aRangeBegin[%u]\" , i ) ;\n }\n proto_item_set_end ( item , tvb , offset ) ;\n return offset ;\n }", "idx": 21508}
{"hash": -7415191846425595149, "project": "chrome", "size": 9, "label": 1, "functionSource": "static void setup_mi ( VP9_COMMON * cm ) {\n cm -> mi = cm -> mip + cm -> mi_stride + 1 ;\n cm -> prev_mi = cm -> prev_mip + cm -> mi_stride + 1 ;\n cm -> mi_grid_visible = cm -> mi_grid_base + cm -> mi_stride + 1 ;\n cm -> prev_mi_grid_visible = cm -> prev_mi_grid_base + cm -> mi_stride + 1 ;\n vpx_memset ( cm -> mip , 0 , cm -> mi_stride * ( cm -> mi_rows + 1 ) * sizeof ( * cm -> mip ) ) ;\n vpx_memset ( cm -> mi_grid_base , 0 , cm -> mi_stride * ( cm -> mi_rows + 1 ) * sizeof ( * cm -> mi_grid_base ) ) ;\n clear_mi_border ( cm , cm -> prev_mip ) ;\n }", "idx": 21509}
{"hash": 6667142528452941476, "project": "debian", "size": 4, "label": 0, "functionSource": "uchar * get_table_key ( const char * entry , size_t * length , my_bool not_used __attribute__ ( ( unused ) ) ) {\n * length = strlen ( entry ) ;\n return ( uchar * ) entry ;\n }", "idx": 21510}
{"hash": 7442680289895575823, "project": "debian", "size": 11, "label": 0, "functionSource": "static void delta_decode ( uint8_t * dst , const uint8_t * src , int src_size , uint8_t * state , const int8_t * table ) {\n uint8_t val = * state ;\n while ( src_size -- ) {\n uint8_t d = * src ++ ;\n val = av_clip_uint8 ( val + table [ d & 0xF ] ) ;\n * dst ++ = val ;\n val = av_clip_uint8 ( val + table [ d >> 4 ] ) ;\n * dst ++ = val ;\n }\n * state = val ;\n }", "idx": 21511}
{"hash": 8206514580434225668, "project": "chrome", "size": 8, "label": 1, "functionSource": "IN_PROC_BROWSER_TEST_F ( HttpsEngagementPageLoadMetricsBrowserTest , AlwaysInBackground ) {\n StartHttpsServer ( false ) ;\n StartHttpServer ( ) ;\n NavigateInBackgroundAndClose ( https_test_server_ -> GetURL ( \"/simple.html\" ) ) ;\n NavigateInBackgroundAndClose ( http_test_server_ -> GetURL ( \"/simple.html\" ) ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHttpEngagementHistogram , 0 ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHttpsEngagementHistogram , 0 ) ;\n }", "idx": 21512}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_INTEGER_1_9216 ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_constrained_integer ( tvb , offset , actx , tree , hf_index , 1U , 9216U , NULL , FALSE ) ;\n return offset ;\n }", "idx": 21513}
{"hash": -1929262071302712016, "project": "debian", "size": 14, "label": 0, "functionSource": "static cmsBool AllocArray ( cmsContext ContextID , _cmsDICarray * a , cmsUInt32Number Count , cmsUInt32Number Length ) {\n memset ( a , 0 , sizeof ( _cmsDICarray ) ) ;\n if ( ! AllocElem ( ContextID , & a -> Name , Count ) ) goto Error ;\n if ( ! AllocElem ( ContextID , & a -> Value , Count ) ) goto Error ;\n if ( Length > 16 ) {\n if ( ! AllocElem ( ContextID , & a -> DisplayName , Count ) ) goto Error ;\n }\n if ( Length > 24 ) {\n if ( ! AllocElem ( ContextID , & a -> DisplayValue , Count ) ) goto Error ;\n }\n return TRUE ;\n Error : FreeArray ( a ) ;\n return FALSE ;\n }", "idx": 21514}
{"hash": 6393050609822897742, "project": "debian", "size": 29, "label": 0, "functionSource": "static void usb_xhci_exit ( PCIDevice * dev ) {\n int i ;\n XHCIState * xhci = XHCI ( dev ) ;\n trace_usb_xhci_exit ( ) ;\n for ( i = 0 ;\n i < xhci -> numslots ;\n i ++ ) {\n xhci_disable_slot ( xhci , i + 1 ) ;\n }\n if ( xhci -> mfwrap_timer ) {\n timer_del ( xhci -> mfwrap_timer ) ;\n timer_free ( xhci -> mfwrap_timer ) ;\n xhci -> mfwrap_timer = NULL ;\n }\n memory_region_del_subregion ( & xhci -> mem , & xhci -> mem_cap ) ;\n memory_region_del_subregion ( & xhci -> mem , & xhci -> mem_oper ) ;\n memory_region_del_subregion ( & xhci -> mem , & xhci -> mem_runtime ) ;\n memory_region_del_subregion ( & xhci -> mem , & xhci -> mem_doorbell ) ;\n for ( i = 0 ;\n i < xhci -> numports ;\n i ++ ) {\n XHCIPort * port = & xhci -> ports [ i ] ;\n memory_region_del_subregion ( & xhci -> mem , & port -> mem ) ;\n }\n if ( dev -> msix_table && dev -> msix_pba && dev -> msix_entry_used ) {\n msix_uninit ( dev , & xhci -> mem , & xhci -> mem ) ;\n }\n usb_bus_release ( & xhci -> bus ) ;\n }", "idx": 21515}
{"hash": -4555950263653671147, "project": "debian", "size": 4, "label": 0, "functionSource": "static PyObject * string_strip ( PyStringObject * self , PyObject * args ) {\n if ( PyTuple_GET_SIZE ( args ) == 0 ) return do_strip ( self , BOTHSTRIP ) ;\n else return do_argstrip ( self , BOTHSTRIP , args ) ;\n }", "idx": 21516}
{"hash": -8028756826159773630, "project": "debian", "size": 13, "label": 0, "functionSource": "static void restore_toc_entries_postfork ( ArchiveHandle * AH , TocEntry * pending_list ) {\n RestoreOptions * ropt = AH -> public . ropt ;\n TocEntry * te ;\n ahlog ( AH , 2 , \"entering restore_toc_entries_postfork\\n\" ) ;\n ConnectDatabase ( ( Archive * ) AH , ropt -> dbname , ropt -> pghost , ropt -> pgport , ropt -> username , ropt -> promptPassword ) ;\n _doSetFixedOutputState ( AH ) ;\n for ( te = pending_list -> par_next ;\n te != pending_list ;\n te = te -> par_next ) {\n ahlog ( AH , 1 , \"processing missed item %d %s %s\\n\" , te -> dumpId , te -> desc , te -> tag ) ;\n ( void ) restore_toc_entry ( AH , te , false ) ;\n }\n }", "idx": 21517}
{"hash": -2723830976796502611, "project": "chrome", "size": 5, "label": 0, "functionSource": "static vpx_codec_err_t ctrl_set_arnr_max_frames ( vpx_codec_alg_priv_t * ctx , va_list args ) {\n struct vp9_extracfg extra_cfg = ctx -> extra_cfg ;\n extra_cfg . arnr_max_frames = CAST ( VP8E_SET_ARNR_MAXFRAMES , args ) ;\n return update_extra_cfg ( ctx , & extra_cfg ) ;\n }", "idx": 21518}
{"hash": 3728341105073176576, "project": "debian", "size": 37, "label": 1, "functionSource": "static ossl_inline type * lh_ ## type ## _insert ( LHASH_OF ( type ) * lh , type * d ) {\n return ( type * ) OPENSSL_LH_insert ( ( OPENSSL_LHASH * ) lh , d ) ;\n }\n static ossl_inline type * lh_ ## type ## _delete ( LHASH_OF ( type ) * lh , const type * d ) {\n return ( type * ) OPENSSL_LH_delete ( ( OPENSSL_LHASH * ) lh , d ) ;\n }\n static ossl_inline type * lh_ ## type ## _retrieve ( LHASH_OF ( type ) * lh , const type * d ) {\n return ( type * ) OPENSSL_LH_retrieve ( ( OPENSSL_LHASH * ) lh , d ) ;\n }\n static ossl_inline int lh_ ## type ## _error ( LHASH_OF ( type ) * lh ) {\n return OPENSSL_LH_error ( ( OPENSSL_LHASH * ) lh ) ;\n }\n static ossl_inline unsigned long lh_ ## type ## _num_items ( LHASH_OF ( type ) * lh ) {\n return OPENSSL_LH_num_items ( ( OPENSSL_LHASH * ) lh ) ;\n }\n static ossl_inline void lh_ ## type ## _node_stats_bio ( const LHASH_OF ( type ) * lh , BIO * out ) {\n OPENSSL_LH_node_stats_bio ( ( const OPENSSL_LHASH * ) lh , out ) ;\n }\n static ossl_inline void lh_ ## type ## _node_usage_stats_bio ( const LHASH_OF ( type ) * lh , BIO * out ) {\n OPENSSL_LH_node_usage_stats_bio ( ( const OPENSSL_LHASH * ) lh , out ) ;\n }\n static ossl_inline void lh_ ## type ## _stats_bio ( const LHASH_OF ( type ) * lh , BIO * out ) {\n OPENSSL_LH_stats_bio ( ( const OPENSSL_LHASH * ) lh , out ) ;\n }\n static ossl_inline unsigned long lh_ ## type ## _get_down_load ( LHASH_OF ( type ) * lh ) {\n return OPENSSL_LH_get_down_load ( ( OPENSSL_LHASH * ) lh ) ;\n }\n static ossl_inline void lh_ ## type ## _set_down_load ( LHASH_OF ( type ) * lh , unsigned long dl ) {\n OPENSSL_LH_set_down_load ( ( OPENSSL_LHASH * ) lh , dl ) ;\n }\n static ossl_inline void lh_ ## type ## _doall ( LHASH_OF ( type ) * lh , void ( * doall ) ( type * ) ) {\n OPENSSL_LH_doall ( ( OPENSSL_LHASH * ) lh , ( OPENSSL_LH_DOALL_FUNC ) doall ) ;\n }\n LHASH_OF ( type ) # define IMPLEMENT_LHASH_DOALL_ARG_CONST ( type , argtype ) int_implement_lhash_doall ( type , argtype , const type ) # define IMPLEMENT_LHASH_DOALL_ARG ( type , argtype ) int_implement_lhash_doall ( type , argtype , type ) # define int_implement_lhash_doall ( type , argtype , cbargtype ) static ossl_inline void lh_ ## type ## _doall_ ## argtype ( LHASH_OF ( type ) * lh , void ( * fn ) ( cbargtype * , argtype * ) , argtype * arg ) {\n OPENSSL_LH_doall_arg ( ( OPENSSL_LHASH * ) lh , ( OPENSSL_LH_DOALL_FUNCARG ) fn , ( void * ) arg ) ;\n }\n LHASH_OF ( type ) DEFINE_LHASH_OF ( OPENSSL_STRING )", "idx": 21519}
{"hash": -6359684484462176044, "project": "debian", "size": 82, "label": 0, "functionSource": "static int ec_asn1_group2fieldid ( const EC_GROUP * group , X9_62_FIELDID * field ) {\n int ok = 0 , nid ;\n BIGNUM * tmp = NULL ;\n if ( group == NULL || field == NULL ) return 0 ;\n if ( field -> fieldType != NULL ) ASN1_OBJECT_free ( field -> fieldType ) ;\n if ( field -> p . other != NULL ) ASN1_TYPE_free ( field -> p . other ) ;\n nid = EC_METHOD_get_field_type ( EC_GROUP_method_of ( group ) ) ;\n if ( ( field -> fieldType = OBJ_nid2obj ( nid ) ) == NULL ) {\n ECerr ( EC_F_EC_ASN1_GROUP2FIELDID , ERR_R_OBJ_LIB ) ;\n goto err ;\n }\n if ( nid == NID_X9_62_prime_field ) {\n if ( ( tmp = BN_new ( ) ) == NULL ) {\n ECerr ( EC_F_EC_ASN1_GROUP2FIELDID , ERR_R_MALLOC_FAILURE ) ;\n goto err ;\n }\n if ( ! EC_GROUP_get_curve_GFp ( group , tmp , NULL , NULL , NULL ) ) {\n ECerr ( EC_F_EC_ASN1_GROUP2FIELDID , ERR_R_EC_LIB ) ;\n goto err ;\n }\n field -> p . prime = BN_to_ASN1_INTEGER ( tmp , NULL ) ;\n if ( field -> p . prime == NULL ) {\n ECerr ( EC_F_EC_ASN1_GROUP2FIELDID , ERR_R_ASN1_LIB ) ;\n goto err ;\n }\n }\n else {\n int field_type ;\n X9_62_CHARACTERISTIC_TWO * char_two ;\n field -> p . char_two = X9_62_CHARACTERISTIC_TWO_new ( ) ;\n char_two = field -> p . char_two ;\n if ( char_two == NULL ) {\n ECerr ( EC_F_EC_ASN1_GROUP2FIELDID , ERR_R_MALLOC_FAILURE ) ;\n goto err ;\n }\n char_two -> m = ( long ) EC_GROUP_get_degree ( group ) ;\n field_type = EC_GROUP_get_basis_type ( group ) ;\n if ( field_type == 0 ) {\n ECerr ( EC_F_EC_ASN1_GROUP2FIELDID , ERR_R_EC_LIB ) ;\n goto err ;\n }\n if ( ( char_two -> type = OBJ_nid2obj ( field_type ) ) == NULL ) {\n ECerr ( EC_F_EC_ASN1_GROUP2FIELDID , ERR_R_OBJ_LIB ) ;\n goto err ;\n }\n if ( field_type == NID_X9_62_tpBasis ) {\n unsigned int k ;\n if ( ! EC_GROUP_get_trinomial_basis ( group , & k ) ) goto err ;\n char_two -> p . tpBasis = ASN1_INTEGER_new ( ) ;\n if ( ! char_two -> p . tpBasis ) {\n ECerr ( EC_F_EC_ASN1_GROUP2FIELDID , ERR_R_MALLOC_FAILURE ) ;\n goto err ;\n }\n if ( ! ASN1_INTEGER_set ( char_two -> p . tpBasis , ( long ) k ) ) {\n ECerr ( EC_F_EC_ASN1_GROUP2FIELDID , ERR_R_ASN1_LIB ) ;\n goto err ;\n }\n }\n else if ( field_type == NID_X9_62_ppBasis ) {\n unsigned int k1 , k2 , k3 ;\n if ( ! EC_GROUP_get_pentanomial_basis ( group , & k1 , & k2 , & k3 ) ) goto err ;\n char_two -> p . ppBasis = X9_62_PENTANOMIAL_new ( ) ;\n if ( ! char_two -> p . ppBasis ) {\n ECerr ( EC_F_EC_ASN1_GROUP2FIELDID , ERR_R_MALLOC_FAILURE ) ;\n goto err ;\n }\n char_two -> p . ppBasis -> k1 = ( long ) k1 ;\n char_two -> p . ppBasis -> k2 = ( long ) k2 ;\n char_two -> p . ppBasis -> k3 = ( long ) k3 ;\n }\n else {\n char_two -> p . onBasis = ASN1_NULL_new ( ) ;\n if ( ! char_two -> p . onBasis ) {\n ECerr ( EC_F_EC_ASN1_GROUP2FIELDID , ERR_R_MALLOC_FAILURE ) ;\n goto err ;\n }\n }\n }\n ok = 1 ;\n err : if ( tmp ) BN_free ( tmp ) ;\n return ( ok ) ;\n }", "idx": 21520}
{"hash": 8073241806104522127, "project": "chrome", "size": 48, "label": 1, "functionSource": "TEST_F ( AutocompleteResultTest , SortAndCullWithMatchDups ) {\n TemplateURLData url_data ;\n url_data . SetShortName ( base : : ASCIIToUTF16 ( \"unittest\" ) ) ;\n url_data . SetKeyword ( base : : ASCIIToUTF16 ( \"foo\" ) ) ;\n url_data . SetURL ( \"http://www.foo.com/s?q={\nsearchTerms}\n\" ) ;\n template_url_service_ . get ( ) -> Add ( new TemplateURL ( url_data ) ) ;\n AutocompleteMatch dup_match ;\n dup_match . destination_url = GURL ( \"http://www.foo.com/s?q=foo&oq=dup\" ) ;\n std : : vector < AutocompleteMatch > dups ;\n dups . push_back ( dup_match ) ;\n TestData data [ ] = {\n {\n 0 , 1 , 1300 , true , dups }\n , {\n 1 , 1 , 1200 , true }\n , {\n 2 , 1 , 1100 , true }\n , {\n 3 , 1 , 1000 , true , dups }\n , {\n 4 , 2 , 900 , true }\n , {\n 5 , 1 , 800 , true }\n , }\n ;\n ACMatches matches ;\n PopulateAutocompleteMatches ( data , arraysize ( data ) , & matches ) ;\n matches [ 0 ] . destination_url = GURL ( \"http://www.foo.com/s?q=foo\" ) ;\n matches [ 1 ] . destination_url = GURL ( \"http://www.foo.com/s?q=foo2\" ) ;\n matches [ 2 ] . destination_url = GURL ( \"http://www.foo.com/s?q=foo&oq=f\" ) ;\n matches [ 3 ] . destination_url = GURL ( \"http://www.foo.com/s?q=foo&aqs=0\" ) ;\n matches [ 4 ] . destination_url = GURL ( \"http://www.foo.com/\" ) ;\n matches [ 5 ] . destination_url = GURL ( \"http://www.foo.com/s?q=foo2&oq=f\" ) ;\n AutocompleteInput input ( base : : string16 ( ) , base : : string16 : : npos , std : : string ( ) , GURL ( ) , OmniboxEventProto : : INVALID_SPEC , false , false , false , true , false , TestSchemeClassifier ( ) ) ;\n AutocompleteResult result ;\n result . AppendMatches ( input , matches ) ;\n result . SortAndCull ( input , std : : string ( ) , template_url_service_ . get ( ) ) ;\n ASSERT_EQ ( 3U , result . size ( ) ) ;\n ASSERT_EQ ( 4U , result . match_at ( 0 ) -> duplicate_matches . size ( ) ) ;\n const AutocompleteMatch * first_match = result . match_at ( 0 ) ;\n EXPECT_EQ ( matches [ 2 ] . destination_url , first_match -> duplicate_matches . at ( 1 ) . destination_url ) ;\n EXPECT_EQ ( dup_match . destination_url , first_match -> duplicate_matches . at ( 2 ) . destination_url ) ;\n EXPECT_EQ ( matches [ 3 ] . destination_url , first_match -> duplicate_matches . at ( 3 ) . destination_url ) ;\n ASSERT_EQ ( 1U , result . match_at ( 1 ) -> duplicate_matches . size ( ) ) ;\n EXPECT_EQ ( matches [ 5 ] . destination_url , result . match_at ( 1 ) -> duplicate_matches . at ( 0 ) . destination_url ) ;\n }", "idx": 21521}
{"hash": -4525941100783779911, "project": "debian", "size": 4, "label": 0, "functionSource": "static const char * NoMeta ( const char * str ) {\n if ( strchr ( str , '%' ) != NULL ) return \"**** CORRUPTED FORMAT STRING ***\" ;\n return str ;\n }", "idx": 21522}
{"hash": -4979531020783644238, "project": "debian", "size": 10, "label": 0, "functionSource": "PGconn * connectToServer ( ClusterInfo * cluster , const char * db_name ) {\n PGconn * conn = get_db_conn ( cluster , db_name ) ;\n if ( conn == NULL || PQstatus ( conn ) != CONNECTION_OK ) {\n pg_log ( PG_REPORT , \"connection to database failed: %s\\n\" , PQerrorMessage ( conn ) ) ;\n if ( conn ) PQfinish ( conn ) ;\n printf ( \"Failure, exiting\\n\" ) ;\n exit ( 1 ) ;\n }\n return conn ;\n }", "idx": 21523}
{"hash": 5704453449583823009, "project": "chrome", "size": 24, "label": 0, "functionSource": "int evbuffer_read ( struct evbuffer * buf , int fd , int howmuch ) {\n u_char * p ;\n size_t oldoff = buf -> off ;\n int n = EVBUFFER_MAX_READ ;\n # if defined ( FIONREAD ) # ifdef WIN32 long lng = n ;\n if ( ioctlsocket ( fd , FIONREAD , & lng ) == - 1 || ( n = lng ) <= 0 ) {\n # else if ( ioctl ( fd , FIONREAD , & n ) == - 1 || n <= 0 ) {\n # endif n = EVBUFFER_MAX_READ ;\n }\n else if ( n > EVBUFFER_MAX_READ && n > howmuch ) {\n if ( ( size_t ) n > buf -> totallen << 2 ) n = buf -> totallen << 2 ;\n if ( n < EVBUFFER_MAX_READ ) n = EVBUFFER_MAX_READ ;\n }\n # endif if ( howmuch < 0 || howmuch > n ) howmuch = n ;\n if ( evbuffer_expand ( buf , howmuch ) == - 1 ) return ( - 1 ) ;\n p = buf -> buffer + buf -> off ;\n # ifndef WIN32 n = read ( fd , p , howmuch ) ;\n # else n = recv ( fd , p , howmuch , 0 ) ;\n # endif if ( n == - 1 ) return ( - 1 ) ;\n if ( n == 0 ) return ( 0 ) ;\n buf -> off += n ;\n if ( buf -> off != oldoff && buf -> cb != NULL ) ( * buf -> cb ) ( buf , oldoff , buf -> off , buf -> cbarg ) ;\n return ( n ) ;\n }", "idx": 21524}
{"hash": 643387607984457432, "project": "debian", "size": 24, "label": 0, "functionSource": "static void aw_parse_coords ( WMAVoiceContext * s , GetBitContext * gb , const int * pitch ) {\n static const int16_t start_offset [ 94 ] = {\n - 11 , - 9 , - 7 , - 5 , - 3 , - 1 , 1 , 3 , 5 , 7 , 9 , 11 , 13 , 15 , 18 , 17 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 35 , 37 , 39 , 41 , 43 , 45 , 47 , 49 , 51 , 53 , 55 , 57 , 59 , 61 , 63 , 65 , 67 , 69 , 71 , 73 , 75 , 77 , 79 , 81 , 83 , 85 , 87 , 89 , 91 , 93 , 95 , 97 , 99 , 101 , 103 , 105 , 107 , 109 , 111 , 113 , 115 , 117 , 119 , 121 , 123 , 125 , 127 , 129 , 131 , 133 , 135 , 137 , 139 , 141 , 143 , 145 , 147 , 149 , 151 , 153 , 155 , 157 , 159 }\n ;\n int bits , offset ;\n s -> aw_idx_is_ext = 0 ;\n if ( ( bits = get_bits ( gb , 6 ) ) >= 54 ) {\n s -> aw_idx_is_ext = 1 ;\n bits += ( bits - 54 ) * 3 + get_bits ( gb , 2 ) ;\n }\n s -> aw_pulse_range = FFMIN ( pitch [ 0 ] , pitch [ 1 ] ) > 32 ? 24 : 16 ;\n for ( offset = start_offset [ bits ] ;\n offset < 0 ;\n offset += pitch [ 0 ] ) ;\n s -> aw_n_pulses [ 0 ] = ( pitch [ 0 ] - 1 + MAX_FRAMESIZE / 2 - offset ) / pitch [ 0 ] ;\n s -> aw_first_pulse_off [ 0 ] = offset - s -> aw_pulse_range / 2 ;\n offset += s -> aw_n_pulses [ 0 ] * pitch [ 0 ] ;\n s -> aw_n_pulses [ 1 ] = ( pitch [ 1 ] - 1 + MAX_FRAMESIZE - offset ) / pitch [ 1 ] ;\n s -> aw_first_pulse_off [ 1 ] = offset - ( MAX_FRAMESIZE + s -> aw_pulse_range ) / 2 ;\n if ( start_offset [ bits ] < MAX_FRAMESIZE / 2 ) {\n while ( s -> aw_first_pulse_off [ 1 ] - pitch [ 1 ] + s -> aw_pulse_range > 0 ) s -> aw_first_pulse_off [ 1 ] -= pitch [ 1 ] ;\n if ( start_offset [ bits ] < 0 ) while ( s -> aw_first_pulse_off [ 0 ] - pitch [ 0 ] + s -> aw_pulse_range > 0 ) s -> aw_first_pulse_off [ 0 ] -= pitch [ 0 ] ;\n }\n }", "idx": 21525}
{"hash": -1315695702746584250, "project": "debian", "size": 11, "label": 0, "functionSource": "proto_item * proto_tree_add_ipv4_format_value ( proto_tree * tree , int hfindex , tvbuff_t * tvb , gint start , gint length , guint32 value , const char * format , ... ) {\n proto_item * pi ;\n va_list ap ;\n pi = proto_tree_add_ipv4 ( tree , hfindex , tvb , start , length , value ) ;\n if ( pi != tree ) {\n va_start ( ap , format ) ;\n proto_tree_set_representation_value ( pi , format , ap ) ;\n va_end ( ap ) ;\n }\n return pi ;\n }", "idx": 21526}
{"hash": 8320716512483418415, "project": "chrome", "size": 8, "label": 1, "functionSource": "void vp9_iht8x8_add ( TX_TYPE tx_type , const int16_t * input , uint8_t * dest , int stride , int eob ) {\n if ( tx_type == DCT_DCT ) {\n vp9_idct8x8_add ( input , dest , stride , eob ) ;\n }\n else {\n vp9_iht8x8_64_add ( input , dest , stride , tx_type ) ;\n }\n }", "idx": 21527}
{"hash": 7191899184788440065, "project": "debian", "size": 73, "label": 0, "functionSource": "static int com_server_help ( String * buffer __attribute__ ( ( unused ) ) , char * line __attribute__ ( ( unused ) ) , char * help_arg ) {\n MYSQL_ROW cur ;\n const char * server_cmd ;\n char cmd_buf [ 100 + 1 ] ;\n MYSQL_RES * result ;\n int error ;\n if ( help_arg [ 0 ] != '\\'' ) {\n char * end_arg = strend ( help_arg ) ;\n if ( -- end_arg ) {\n while ( my_isspace ( charset_info , * end_arg ) ) end_arg -- ;\n * ++ end_arg = '\\0' ;\n }\n ( void ) strxnmov ( cmd_buf , sizeof ( cmd_buf ) , \"help '\" , help_arg , \"'\" , NullS ) ;\n }\n else ( void ) strxnmov ( cmd_buf , sizeof ( cmd_buf ) , \"help \" , help_arg , NullS ) ;\n server_cmd = cmd_buf ;\n if ( ! status . batch ) {\n old_buffer = * buffer ;\n old_buffer . copy ( ) ;\n }\n if ( ! connected && reconnect ( ) ) return 1 ;\n if ( ( error = mysql_real_query_for_lazy ( server_cmd , ( int ) strlen ( server_cmd ) ) ) || ( error = mysql_store_result_for_lazy ( & result ) ) ) return error ;\n if ( result ) {\n unsigned int num_fields = mysql_num_fields ( result ) ;\n my_ulonglong num_rows = mysql_num_rows ( result ) ;\n mysql_fetch_fields ( result ) ;\n if ( num_fields == 3 && num_rows == 1 ) {\n if ( ! ( cur = mysql_fetch_row ( result ) ) ) {\n error = - 1 ;\n goto err ;\n }\n init_pager ( ) ;\n tee_fprintf ( PAGER , \"Name: \\'%s\\'\\n\" , cur [ 0 ] ) ;\n tee_fprintf ( PAGER , \"Description:\\n%s\" , cur [ 1 ] ) ;\n if ( cur [ 2 ] && * ( ( char * ) cur [ 2 ] ) ) tee_fprintf ( PAGER , \"Examples:\\n%s\" , cur [ 2 ] ) ;\n tee_fprintf ( PAGER , \"\\n\" ) ;\n end_pager ( ) ;\n }\n else if ( num_fields >= 2 && num_rows ) {\n init_pager ( ) ;\n char last_char = 0 ;\n int num_name = 0 , num_cat = 0 ;\n LINT_INIT ( num_name ) ;\n LINT_INIT ( num_cat ) ;\n if ( num_fields == 2 ) {\n put_info ( \"Many help items for your request exist.\" , INFO_INFO ) ;\n put_info ( \"To make a more specific request, please type 'help <item>',\\nwhere <item> is one of the following\" , INFO_INFO ) ;\n num_name = 0 ;\n num_cat = 1 ;\n }\n else if ( ( cur = mysql_fetch_row ( result ) ) ) {\n tee_fprintf ( PAGER , \"You asked for help about help category: \\\"%s\\\"\\n\" , cur [ 0 ] ) ;\n put_info ( \"For more information, type 'help <item>', where <item> is one of the following\" , INFO_INFO ) ;\n num_name = 1 ;\n num_cat = 2 ;\n print_help_item ( & cur , 1 , 2 , & last_char ) ;\n }\n while ( ( cur = mysql_fetch_row ( result ) ) ) print_help_item ( & cur , num_name , num_cat , & last_char ) ;\n tee_fprintf ( PAGER , \"\\n\" ) ;\n end_pager ( ) ;\n }\n else {\n put_info ( \"\\nNothing found\" , INFO_INFO ) ;\n if ( strncasecmp ( server_cmd , \"help 'contents'\" , 15 ) == 0 ) {\n put_info ( \"\\nPlease check if 'help tables' are loaded.\\n\" , INFO_INFO ) ;\n goto err ;\n }\n put_info ( \"Please try to run 'help contents' for a list of all accessible topics\\n\" , INFO_INFO ) ;\n }\n }\n err : mysql_free_result ( result ) ;\n return error ;\n }", "idx": 21528}
{"hash": -1315695702746584250, "project": "debian", "size": 3, "label": 0, "functionSource": "void ptvcursor_free ( ptvcursor_t * ptvc ) {\n ptvcursor_free_subtree_levels ( ptvc ) ;\n }", "idx": 21529}
{"hash": -1929262071302712016, "project": "debian", "size": 30, "label": 0, "functionSource": "static void * Type_MPEclut_Read ( struct _cms_typehandler_struct * self , cmsIOHANDLER * io , cmsUInt32Number * nItems , cmsUInt32Number SizeOfTag ) {\n cmsStage * mpe = NULL ;\n cmsUInt16Number InputChans , OutputChans ;\n cmsUInt8Number Dimensions8 [ 16 ] ;\n cmsUInt32Number i , nMaxGrids , GridPoints [ MAX_INPUT_DIMENSIONS ] ;\n _cmsStageCLutData * clut ;\n if ( ! _cmsReadUInt16Number ( io , & InputChans ) ) return NULL ;\n if ( ! _cmsReadUInt16Number ( io , & OutputChans ) ) return NULL ;\n if ( InputChans == 0 ) goto Error ;\n if ( OutputChans == 0 ) goto Error ;\n if ( io -> Read ( io , Dimensions8 , sizeof ( cmsUInt8Number ) , 16 ) != 16 ) goto Error ;\n nMaxGrids = InputChans > MAX_INPUT_DIMENSIONS ? MAX_INPUT_DIMENSIONS : InputChans ;\n for ( i = 0 ;\n i < nMaxGrids ;\n i ++ ) GridPoints [ i ] = ( cmsUInt32Number ) Dimensions8 [ i ] ;\n mpe = cmsStageAllocCLutFloatGranular ( self -> ContextID , GridPoints , InputChans , OutputChans , NULL ) ;\n if ( mpe == NULL ) goto Error ;\n clut = ( _cmsStageCLutData * ) mpe -> Data ;\n for ( i = 0 ;\n i < clut -> nEntries ;\n i ++ ) {\n if ( ! _cmsReadFloat32Number ( io , & clut -> Tab . TFloat [ i ] ) ) goto Error ;\n }\n * nItems = 1 ;\n return mpe ;\n Error : * nItems = 0 ;\n if ( mpe != NULL ) cmsStageFree ( mpe ) ;\n return NULL ;\n cmsUNUSED_PARAMETER ( SizeOfTag ) ;\n }", "idx": 21530}
{"hash": 8218188955508624394, "project": "debian", "size": 42, "label": 0, "functionSource": "static int read_matrix_params ( MLPDecodeContext * m , unsigned int substr , GetBitContext * gbp ) {\n SubStream * s = & m -> substream [ substr ] ;\n unsigned int mat , ch ;\n const int max_primitive_matrices = m -> avctx -> codec_id == AV_CODEC_ID_MLP ? MAX_MATRICES_MLP : MAX_MATRICES_TRUEHD ;\n if ( m -> matrix_changed ++ > 1 ) {\n av_log ( m -> avctx , AV_LOG_ERROR , \"Matrices may change only once per access unit.\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n s -> num_primitive_matrices = get_bits ( gbp , 4 ) ;\n if ( s -> num_primitive_matrices > max_primitive_matrices ) {\n av_log ( m -> avctx , AV_LOG_ERROR , \"Number of primitive matrices cannot be greater than %d.\\n\" , max_primitive_matrices ) ;\n return AVERROR_INVALIDDATA ;\n }\n for ( mat = 0 ;\n mat < s -> num_primitive_matrices ;\n mat ++ ) {\n int frac_bits , max_chan ;\n s -> matrix_out_ch [ mat ] = get_bits ( gbp , 4 ) ;\n frac_bits = get_bits ( gbp , 4 ) ;\n s -> lsb_bypass [ mat ] = get_bits1 ( gbp ) ;\n if ( s -> matrix_out_ch [ mat ] > s -> max_matrix_channel ) {\n av_log ( m -> avctx , AV_LOG_ERROR , \"Invalid channel %d specified as output from matrix.\\n\" , s -> matrix_out_ch [ mat ] ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( frac_bits > 14 ) {\n av_log ( m -> avctx , AV_LOG_ERROR , \"Too many fractional bits specified.\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n max_chan = s -> max_matrix_channel ;\n if ( ! s -> noise_type ) max_chan += 2 ;\n for ( ch = 0 ;\n ch <= max_chan ;\n ch ++ ) {\n int coeff_val = 0 ;\n if ( get_bits1 ( gbp ) ) coeff_val = get_sbits ( gbp , frac_bits + 2 ) ;\n s -> matrix_coeff [ mat ] [ ch ] = coeff_val << ( 14 - frac_bits ) ;\n }\n if ( s -> noise_type ) s -> matrix_noise_shift [ mat ] = get_bits ( gbp , 4 ) ;\n else s -> matrix_noise_shift [ mat ] = 0 ;\n }\n return 0 ;\n }", "idx": 21531}
{"hash": 5524055408114021500, "project": "debian", "size": 26, "label": 0, "functionSource": "int ssl_verify_alarm_type ( long type ) {\n int al ;\n switch ( type ) {\n case X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT : case X509_V_ERR_UNABLE_TO_GET_CRL : case X509_V_ERR_UNABLE_TO_GET_CRL_ISSUER : al = SSL_AD_UNKNOWN_CA ;\n break ;\n case X509_V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE : case X509_V_ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE : case X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY : case X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD : case X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD : case X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD : case X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD : case X509_V_ERR_CERT_NOT_YET_VALID : case X509_V_ERR_CRL_NOT_YET_VALID : case X509_V_ERR_CERT_UNTRUSTED : case X509_V_ERR_CERT_REJECTED : al = SSL_AD_BAD_CERTIFICATE ;\n break ;\n case X509_V_ERR_CERT_SIGNATURE_FAILURE : case X509_V_ERR_CRL_SIGNATURE_FAILURE : al = SSL_AD_DECRYPT_ERROR ;\n break ;\n case X509_V_ERR_CERT_HAS_EXPIRED : case X509_V_ERR_CRL_HAS_EXPIRED : al = SSL_AD_CERTIFICATE_EXPIRED ;\n break ;\n case X509_V_ERR_CERT_REVOKED : al = SSL_AD_CERTIFICATE_REVOKED ;\n break ;\n case X509_V_ERR_OUT_OF_MEM : al = SSL_AD_INTERNAL_ERROR ;\n break ;\n case X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT : case X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN : case X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY : case X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE : case X509_V_ERR_CERT_CHAIN_TOO_LONG : case X509_V_ERR_PATH_LENGTH_EXCEEDED : case X509_V_ERR_INVALID_CA : al = SSL_AD_UNKNOWN_CA ;\n break ;\n case X509_V_ERR_APPLICATION_VERIFICATION : al = SSL_AD_HANDSHAKE_FAILURE ;\n break ;\n case X509_V_ERR_INVALID_PURPOSE : al = SSL_AD_UNSUPPORTED_CERTIFICATE ;\n break ;\n default : al = SSL_AD_CERTIFICATE_UNKNOWN ;\n break ;\n }\n return ( al ) ;\n }", "idx": 21532}
{"hash": -3133987110086012192, "project": "chrome", "size": 5, "label": 0, "functionSource": "TEST_F ( SoundContentSettingObserverTest , UnmutedAudioPlayingDoesNotRecordSiteMuted ) {\n ChangeSoundContentSettingTo ( CONTENT_SETTING_ALLOW ) ;\n SimulateAudioStarting ( ) ;\n EXPECT_FALSE ( RecordedSiteMuted ( ) ) ;\n }", "idx": 21533}
{"hash": -2222463888415249941, "project": "chrome", "size": 17, "label": 1, "functionSource": "static void update_reference_segmentation_map ( VP9_COMP * cpi ) {\n VP9_COMMON * const cm = & cpi -> common ;\n MODE_INFO * * mi_8x8_ptr = cm -> mi_grid_visible ;\n uint8_t * cache_ptr = cm -> last_frame_seg_map ;\n int row , col ;\n for ( row = 0 ;\n row < cm -> mi_rows ;\n row ++ ) {\n MODE_INFO * * mi_8x8 = mi_8x8_ptr ;\n uint8_t * cache = cache_ptr ;\n for ( col = 0 ;\n col < cm -> mi_cols ;\n col ++ , mi_8x8 ++ , cache ++ ) cache [ 0 ] = mi_8x8 [ 0 ] -> mbmi . segment_id ;\n mi_8x8_ptr += cm -> mi_stride ;\n cache_ptr += cm -> mi_cols ;\n }\n }", "idx": 21534}
{"hash": -5361762812461354840, "project": "chrome", "size": 14, "label": 0, "functionSource": "static void U_CALLCONV _CompoundText_GetUnicodeSet ( const UConverter * cnv , const USetAdder * sa , UConverterUnicodeSet which , UErrorCode * pErrorCode ) {\n UConverterDataCompoundText * myConverterData = ( UConverterDataCompoundText * ) cnv -> extraInfo ;\n int32_t i ;\n for ( i = 1 ;\n i < NUM_OF_CONVERTERS ;\n i ++ ) {\n ucnv_MBCSGetUnicodeSetForUnicode ( myConverterData -> myConverterArray [ i ] , sa , which , pErrorCode ) ;\n }\n sa -> add ( sa -> set , 0x0000 ) ;\n sa -> add ( sa -> set , 0x0009 ) ;\n sa -> add ( sa -> set , 0x000A ) ;\n sa -> addRange ( sa -> set , 0x0020 , 0x007F ) ;\n sa -> addRange ( sa -> set , 0x00A0 , 0x00FF ) ;\n }", "idx": 21535}
{"hash": 3238650362391448613, "project": "chrome", "size": 12, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( PrintPreviewDialogControllerBrowserTest , NavigateFromInitiatorTab ) {\n PrintPreview ( ) ;\n WebContents * preview_dialog = GetPrintPreviewDialog ( ) ;\n ASSERT_TRUE ( preview_dialog ) ;\n ASSERT_NE ( initiator ( ) , preview_dialog ) ;\n PrintPreviewDialogDestroyedObserver dialog_destroyed_observer ( preview_dialog ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , GURL ( chrome : : kChromeUINewTabURL ) ) ;\n ASSERT_TRUE ( dialog_destroyed_observer . dialog_destroyed ( ) ) ;\n PrintPreview ( ) ;\n WebContents * new_preview_dialog = GetPrintPreviewDialog ( ) ;\n EXPECT_TRUE ( new_preview_dialog ) ;\n }", "idx": 21536}
{"hash": -8503439282031333562, "project": "debian", "size": 135, "label": 1, "functionSource": "int tmx_check_pretran ( sip_msg_t * msg ) {\n unsigned int chid ;\n unsigned int slotid ;\n int dsize ;\n struct via_param * vbr ;\n str scallid ;\n str scseqmet ;\n str scseqnum ;\n str sftag ;\n str svbranch = {\n NULL , 0 }\n ;\n pretran_t * it ;\n if ( _tmx_ptran_table == NULL ) {\n LM_ERR ( \"pretran hash table not initialized yet\\n\" ) ;\n return - 1 ;\n }\n if ( get_route_type ( ) != REQUEST_ROUTE ) {\n LM_ERR ( \"invalid usage - not in request route\\n\" ) ;\n return - 1 ;\n }\n if ( msg -> first_line . type != SIP_REQUEST ) {\n LM_ERR ( \"invalid usage - not a sip request\\n\" ) ;\n return - 1 ;\n }\n if ( parse_headers ( msg , HDR_FROM_F | HDR_VIA1_F | HDR_CALLID_F | HDR_CSEQ_F , 0 ) < 0 ) {\n LM_ERR ( \"failed to parse required headers\\n\" ) ;\n return - 1 ;\n }\n if ( msg -> cseq == NULL || msg -> cseq -> parsed == NULL ) {\n LM_ERR ( \"failed to parse cseq headers\\n\" ) ;\n return - 1 ;\n }\n if ( get_cseq ( msg ) -> method_id == METHOD_ACK || get_cseq ( msg ) -> method_id == METHOD_CANCEL ) {\n LM_DBG ( \"no pre-transaction management for ACK or CANCEL\\n\" ) ;\n return - 1 ;\n }\n if ( msg -> via1 == 0 ) {\n LM_ERR ( \"failed to get Via header\\n\" ) ;\n return - 1 ;\n }\n if ( parse_from_header ( msg ) < 0 || get_from ( msg ) -> tag_value . len == 0 ) {\n LM_ERR ( \"failed to get From header\\n\" ) ;\n return - 1 ;\n }\n if ( msg -> callid == NULL || msg -> callid -> body . s == NULL ) {\n LM_ERR ( \"failed to parse callid headers\\n\" ) ;\n return - 1 ;\n }\n vbr = msg -> via1 -> branch ;\n scallid = msg -> callid -> body ;\n trim ( & scallid ) ;\n scseqmet = get_cseq ( msg ) -> method ;\n trim ( & scseqmet ) ;\n scseqnum = get_cseq ( msg ) -> number ;\n trim ( & scseqnum ) ;\n sftag = get_from ( msg ) -> tag_value ;\n trim ( & sftag ) ;\n chid = get_hash1_raw ( msg -> callid -> body . s , msg -> callid -> body . len ) ;\n slotid = chid & ( _tmx_ptran_size - 1 ) ;\n if ( unlikely ( _tmx_proc_ptran == NULL ) ) {\n _tmx_proc_ptran = ( pretran_t * ) shm_malloc ( sizeof ( pretran_t ) ) ;\n if ( _tmx_proc_ptran == NULL ) {\n LM_ERR ( \"not enough memory for pretran structure\\n\" ) ;\n return - 1 ;\n }\n memset ( _tmx_proc_ptran , 0 , sizeof ( pretran_t ) ) ;\n _tmx_proc_ptran -> pid = my_pid ( ) ;\n }\n dsize = scallid . len + scseqnum . len + scseqmet . len + sftag . len + 4 ;\n if ( likely ( vbr != NULL ) ) {\n svbranch = vbr -> value ;\n trim ( & svbranch ) ;\n dsize += svbranch . len ;\n }\n if ( dsize < 256 ) dsize = 256 ;\n tmx_pretran_unlink ( ) ;\n if ( dsize > _tmx_proc_ptran -> dbuf . len ) {\n if ( _tmx_proc_ptran -> dbuf . s ) shm_free ( _tmx_proc_ptran -> dbuf . s ) ;\n _tmx_proc_ptran -> dbuf . s = ( char * ) shm_malloc ( dsize ) ;\n if ( _tmx_proc_ptran -> dbuf . s == NULL ) {\n LM_ERR ( \"not enough memory for pretran data\\n\" ) ;\n return - 1 ;\n }\n _tmx_proc_ptran -> dbuf . len = dsize ;\n }\n _tmx_proc_ptran -> hid = chid ;\n _tmx_proc_ptran -> cseqmetid = ( get_cseq ( msg ) ) -> method_id ;\n _tmx_proc_ptran -> callid . s = _tmx_proc_ptran -> dbuf . s ;\n memcpy ( _tmx_proc_ptran -> callid . s , scallid . s , scallid . len ) ;\n _tmx_proc_ptran -> callid . len = scallid . len ;\n _tmx_proc_ptran -> callid . s [ _tmx_proc_ptran -> callid . len ] = '\\0' ;\n _tmx_proc_ptran -> ftag . s = _tmx_proc_ptran -> callid . s + _tmx_proc_ptran -> callid . len + 1 ;\n memcpy ( _tmx_proc_ptran -> ftag . s , sftag . s , sftag . len ) ;\n _tmx_proc_ptran -> ftag . len = sftag . len ;\n _tmx_proc_ptran -> ftag . s [ _tmx_proc_ptran -> ftag . len ] = '\\0' ;\n _tmx_proc_ptran -> cseqnum . s = _tmx_proc_ptran -> ftag . s + _tmx_proc_ptran -> ftag . len + 1 ;\n memcpy ( _tmx_proc_ptran -> cseqnum . s , scseqnum . s , scseqnum . len ) ;\n _tmx_proc_ptran -> cseqnum . len = scseqnum . len ;\n _tmx_proc_ptran -> cseqnum . s [ _tmx_proc_ptran -> cseqnum . len ] = '\\0' ;\n _tmx_proc_ptran -> cseqmet . s = _tmx_proc_ptran -> cseqnum . s + _tmx_proc_ptran -> cseqnum . len + 1 ;\n memcpy ( _tmx_proc_ptran -> cseqmet . s , scseqmet . s , scseqmet . len ) ;\n _tmx_proc_ptran -> cseqmet . len = scseqmet . len ;\n _tmx_proc_ptran -> cseqmet . s [ _tmx_proc_ptran -> cseqmet . len ] = '\\0' ;\n if ( likely ( vbr != NULL ) ) {\n _tmx_proc_ptran -> vbranch . s = _tmx_proc_ptran -> cseqmet . s + _tmx_proc_ptran -> cseqmet . len + 1 ;\n memcpy ( _tmx_proc_ptran -> vbranch . s , svbranch . s , svbranch . len ) ;\n _tmx_proc_ptran -> vbranch . len = svbranch . len ;\n _tmx_proc_ptran -> vbranch . s [ _tmx_proc_ptran -> vbranch . len ] = '\\0' ;\n }\n else {\n _tmx_proc_ptran -> vbranch . s = NULL ;\n _tmx_proc_ptran -> vbranch . len = 0 ;\n }\n lock_get ( & _tmx_ptran_table [ slotid ] . lock ) ;\n it = _tmx_ptran_table [ slotid ] . plist ;\n tmx_pretran_link_safe ( slotid ) ;\n for ( ;\n it != NULL ;\n it = it -> next ) {\n if ( _tmx_proc_ptran -> hid != it -> hid || _tmx_proc_ptran -> cseqmetid != it -> cseqmetid || _tmx_proc_ptran -> callid . len != it -> callid . len || _tmx_proc_ptran -> ftag . len != it -> ftag . len || _tmx_proc_ptran -> cseqmet . len != it -> cseqmet . len || _tmx_proc_ptran -> cseqnum . len != it -> cseqnum . len ) continue ;\n if ( _tmx_proc_ptran -> vbranch . s != NULL && it -> vbranch . s != NULL ) {\n if ( _tmx_proc_ptran -> vbranch . len != it -> vbranch . len ) continue ;\n if ( _tmx_proc_ptran -> vbranch . s [ it -> vbranch . len - 1 ] != it -> vbranch . s [ it -> vbranch . len - 1 ] ) continue ;\n if ( memcmp ( _tmx_proc_ptran -> vbranch . s , it -> vbranch . s , it -> vbranch . len ) != 0 ) continue ;\n }\n if ( memcmp ( _tmx_proc_ptran -> callid . s , it -> callid . s , it -> callid . len ) != 0 || memcmp ( _tmx_proc_ptran -> ftag . s , it -> ftag . s , it -> ftag . len ) != 0 || memcmp ( _tmx_proc_ptran -> cseqnum . s , it -> cseqnum . s , it -> cseqnum . len ) != 0 ) continue ;\n if ( ( it -> cseqmetid == METHOD_OTHER || it -> cseqmetid == METHOD_UNDEF ) && memcmp ( _tmx_proc_ptran -> cseqmet . s , it -> cseqmet . s , it -> cseqmet . len ) != 0 ) continue ;\n LM_DBG ( \"matched another pre-transaction by pid %d for [%.*s]\\n\" , it -> pid , it -> callid . len , it -> callid . s ) ;\n lock_release ( & _tmx_ptran_table [ slotid ] . lock ) ;\n return 1 ;\n }\n lock_release ( & _tmx_ptran_table [ slotid ] . lock ) ;\n return 0 ;\n }", "idx": 21537}
{"hash": 4180964683905830761, "project": "debian", "size": 6, "label": 0, "functionSource": "static struct inode_security_struct * inode_security_rcu ( struct inode * inode , bool rcu ) {\n int error ;\n error = __inode_security_revalidate ( inode , NULL , ! rcu ) ;\n if ( error ) return ERR_PTR ( error ) ;\n return inode -> i_security ;\n }", "idx": 21538}
{"hash": 5360072031850965731, "project": "debian", "size": 8, "label": 0, "functionSource": "static uint32_t PPC_prep_io_readw ( void * opaque , hwaddr addr ) {\n sysctrl_t * sysctrl = opaque ;\n uint32_t ret ;\n addr = prep_IO_address ( sysctrl , addr ) ;\n ret = cpu_inw ( addr ) ;\n PPC_IO_DPRINTF ( \"0x\" TARGET_FMT_plx \" <= 0x%08\" PRIx32 \"\\n\" , addr , ret ) ;\n return ret ;\n }", "idx": 21539}
{"hash": 3584320764213684062, "project": "debian", "size": 15, "label": 0, "functionSource": "static struct mswsp_ct * get_create_converstation_data ( packet_info * pinfo ) {\n struct mswsp_ct * ct = NULL ;\n conversation_t * conversation ;\n conversation = find_or_create_conversation ( pinfo ) ;\n if ( ! conversation ) {\n return NULL ;\n }\n ct = ( struct mswsp_ct * ) conversation_get_proto_data ( conversation , proto_mswsp ) ;\n if ( ! ct ) {\n ct = wmem_new ( wmem_file_scope ( ) , struct mswsp_ct ) ;\n ct -> GSL_message_data = NULL ;\n conversation_add_proto_data ( conversation , proto_mswsp , ct ) ;\n }\n return ct ;\n }", "idx": 21540}
{"hash": -6220838201187559331, "project": "debian", "size": 102, "label": 0, "functionSource": "static CURLcode dict_do ( struct connectdata * conn , bool * done ) {\n char * word ;\n char * eword ;\n char * ppath ;\n char * database = NULL ;\n char * strategy = NULL ;\n char * nthdef = NULL ;\n CURLcode result = CURLE_OK ;\n struct Curl_easy * data = conn -> data ;\n curl_socket_t sockfd = conn -> sock [ FIRSTSOCKET ] ;\n char * path = data -> state . path ;\n curl_off_t * bytecount = & data -> req . bytecount ;\n * done = TRUE ;\n if ( conn -> bits . user_passwd ) {\n }\n if ( Curl_raw_nequal ( path , DICT_MATCH , sizeof ( DICT_MATCH ) - 1 ) || Curl_raw_nequal ( path , DICT_MATCH2 , sizeof ( DICT_MATCH2 ) - 1 ) || Curl_raw_nequal ( path , DICT_MATCH3 , sizeof ( DICT_MATCH3 ) - 1 ) ) {\n word = strchr ( path , ':' ) ;\n if ( word ) {\n word ++ ;\n database = strchr ( word , ':' ) ;\n if ( database ) {\n * database ++ = ( char ) 0 ;\n strategy = strchr ( database , ':' ) ;\n if ( strategy ) {\n * strategy ++ = ( char ) 0 ;\n nthdef = strchr ( strategy , ':' ) ;\n if ( nthdef ) {\n * nthdef = ( char ) 0 ;\n }\n }\n }\n }\n if ( ( word == NULL ) || ( * word == ( char ) 0 ) ) {\n infof ( data , \"lookup word is missing\\n\" ) ;\n word = ( char * ) \"default\" ;\n }\n if ( ( database == NULL ) || ( * database == ( char ) 0 ) ) {\n database = ( char * ) \"!\" ;\n }\n if ( ( strategy == NULL ) || ( * strategy == ( char ) 0 ) ) {\n strategy = ( char * ) \".\" ;\n }\n eword = unescape_word ( data , word ) ;\n if ( ! eword ) return CURLE_OUT_OF_MEMORY ;\n result = Curl_sendf ( sockfd , conn , \"CLIENT \" LIBCURL_NAME \" \" LIBCURL_VERSION \"\\r\\n\" \"MATCH \" \"%s \" \"%s \" \"%s\\r\\n\" \"QUIT\\r\\n\" , database , strategy , eword ) ;\n free ( eword ) ;\n if ( result ) {\n failf ( data , \"Failed sending DICT request\" ) ;\n return result ;\n }\n Curl_setup_transfer ( conn , FIRSTSOCKET , - 1 , FALSE , bytecount , - 1 , NULL ) ;\n }\n else if ( Curl_raw_nequal ( path , DICT_DEFINE , sizeof ( DICT_DEFINE ) - 1 ) || Curl_raw_nequal ( path , DICT_DEFINE2 , sizeof ( DICT_DEFINE2 ) - 1 ) || Curl_raw_nequal ( path , DICT_DEFINE3 , sizeof ( DICT_DEFINE3 ) - 1 ) ) {\n word = strchr ( path , ':' ) ;\n if ( word ) {\n word ++ ;\n database = strchr ( word , ':' ) ;\n if ( database ) {\n * database ++ = ( char ) 0 ;\n nthdef = strchr ( database , ':' ) ;\n if ( nthdef ) {\n * nthdef = ( char ) 0 ;\n }\n }\n }\n if ( ( word == NULL ) || ( * word == ( char ) 0 ) ) {\n infof ( data , \"lookup word is missing\\n\" ) ;\n word = ( char * ) \"default\" ;\n }\n if ( ( database == NULL ) || ( * database == ( char ) 0 ) ) {\n database = ( char * ) \"!\" ;\n }\n eword = unescape_word ( data , word ) ;\n if ( ! eword ) return CURLE_OUT_OF_MEMORY ;\n result = Curl_sendf ( sockfd , conn , \"CLIENT \" LIBCURL_NAME \" \" LIBCURL_VERSION \"\\r\\n\" \"DEFINE \" \"%s \" \"%s\\r\\n\" \"QUIT\\r\\n\" , database , eword ) ;\n free ( eword ) ;\n if ( result ) {\n failf ( data , \"Failed sending DICT request\" ) ;\n return result ;\n }\n Curl_setup_transfer ( conn , FIRSTSOCKET , - 1 , FALSE , bytecount , - 1 , NULL ) ;\n }\n else {\n ppath = strchr ( path , '/' ) ;\n if ( ppath ) {\n int i ;\n ppath ++ ;\n for ( i = 0 ;\n ppath [ i ] ;\n i ++ ) {\n if ( ppath [ i ] == ':' ) ppath [ i ] = ' ' ;\n }\n result = Curl_sendf ( sockfd , conn , \"CLIENT \" LIBCURL_NAME \" \" LIBCURL_VERSION \"\\r\\n\" \"%s\\r\\n\" \"QUIT\\r\\n\" , ppath ) ;\n if ( result ) {\n failf ( data , \"Failed sending DICT request\" ) ;\n return result ;\n }\n Curl_setup_transfer ( conn , FIRSTSOCKET , - 1 , FALSE , bytecount , - 1 , NULL ) ;\n }\n }\n return CURLE_OK ;\n }", "idx": 21541}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_MaxRedundancy ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_constrained_integer ( tvb , offset , actx , tree , hf_index , 1U , NO_BOUND , NULL , FALSE ) ;\n return offset ;\n }", "idx": 21542}
{"hash": 4704178797381506498, "project": "debian", "size": 12, "label": 0, "functionSource": "static void cleanup_key_data ( context , count , data ) krb5_context context ;\n int count ;\n krb5_key_data * data ;\n {\n int i , j ;\n for ( i = 0 ;\n i < count ;\n i ++ ) for ( j = 0 ;\n j < data [ i ] . key_data_ver ;\n j ++ ) if ( data [ i ] . key_data_length [ j ] ) krb5_db_free ( context , data [ i ] . key_data_contents [ j ] ) ;\n krb5_db_free ( context , data ) ;\n }", "idx": 21543}
{"hash": 8484475213808847345, "project": "debian", "size": 61, "label": 0, "functionSource": "static BusState * qbus_find ( const char * path ) {\n DeviceState * dev ;\n BusState * bus ;\n char elem [ 128 ] , msg [ 256 ] ;\n int pos , len ;\n if ( path [ 0 ] == '/' ) {\n bus = main_system_bus ;\n pos = 0 ;\n }\n else {\n if ( sscanf ( path , \"%127[^/]%n\" , elem , & len ) != 1 ) {\n qemu_error ( \"path parse error (\\\"%s\\\")\\n\" , path ) ;\n return NULL ;\n }\n bus = qbus_find_recursive ( main_system_bus , elem , NULL ) ;\n if ( ! bus ) {\n qemu_error ( \"bus \\\"%s\\\" not found\\n\" , elem ) ;\n return NULL ;\n }\n pos = len ;\n }\n for ( ;\n ;\n ) {\n if ( path [ pos ] == '\\0' ) {\n return bus ;\n }\n if ( sscanf ( path + pos , \"/%127[^/]%n\" , elem , & len ) != 1 ) {\n qemu_error ( \"path parse error (\\\"%s\\\" pos %d)\\n\" , path , pos ) ;\n return NULL ;\n }\n pos += len ;\n dev = qbus_find_dev ( bus , elem ) ;\n if ( ! dev ) {\n qbus_list_dev ( bus , msg , sizeof ( msg ) ) ;\n qemu_error ( \"device \\\"%s\\\" not found\\n%s\\n\" , elem , msg ) ;\n return NULL ;\n }\n if ( path [ pos ] == '\\0' ) {\n switch ( dev -> num_child_bus ) {\n case 0 : qemu_error ( \"device has no child bus (%s)\\n\" , path ) ;\n return NULL ;\n case 1 : return QLIST_FIRST ( & dev -> child_bus ) ;\n default : qbus_list_bus ( dev , msg , sizeof ( msg ) ) ;\n qemu_error ( \"device has multiple child busses (%s)\\n%s\\n\" , path , msg ) ;\n return NULL ;\n }\n }\n if ( sscanf ( path + pos , \"/%127[^/]%n\" , elem , & len ) != 1 ) {\n qemu_error ( \"path parse error (\\\"%s\\\" pos %d)\\n\" , path , pos ) ;\n return NULL ;\n }\n pos += len ;\n bus = qbus_find_bus ( dev , elem ) ;\n if ( ! bus ) {\n qbus_list_bus ( dev , msg , sizeof ( msg ) ) ;\n qemu_error ( \"child bus \\\"%s\\\" not found\\n%s\\n\" , elem , msg ) ;\n return NULL ;\n }\n }\n }", "idx": 21544}
{"hash": 4180964683905830761, "project": "debian", "size": 4, "label": 0, "functionSource": "static int selinux_umount ( struct vfsmount * mnt , int flags ) {\n const struct cred * cred = current_cred ( ) ;\n return superblock_has_perm ( cred , mnt -> mnt_sb , FILESYSTEM__UNMOUNT , NULL ) ;\n }", "idx": 21545}
{"hash": -6552851419396579257, "project": "debian", "size": 16, "label": 0, "functionSource": "static int dissect_FORM_1 ( tvbuff_t * tvb , int offset , packet_info * pinfo , proto_tree * tree , dcerpc_info * di , guint8 * drep ) {\n proto_tree * subtree ;\n guint32 flags ;\n subtree = proto_tree_add_subtree ( tree , tvb , offset , 0 , ett_FORM_1 , NULL , \"Form level 1\" ) ;\n offset = dissect_ndr_str_pointer_item ( tvb , offset , pinfo , subtree , di , drep , NDR_POINTER_UNIQUE , \"Name\" , hf_form_name , 0 ) ;\n if ( tvb_reported_length_remaining ( tvb , offset ) <= 0 ) goto done ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , subtree , di , drep , hf_form_flags , & flags ) ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , subtree , di , drep , hf_form_unknown , NULL ) ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , subtree , di , drep , hf_form_width , NULL ) ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , subtree , di , drep , hf_form_height , NULL ) ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , subtree , di , drep , hf_form_left_margin , NULL ) ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , subtree , di , drep , hf_form_top_margin , NULL ) ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , subtree , di , drep , hf_form_horiz_len , NULL ) ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , subtree , di , drep , hf_form_vert_len , NULL ) ;\n done : return offset ;\n }", "idx": 21546}
{"hash": 1760449185745615462, "project": "debian", "size": 15, "label": 0, "functionSource": "TSReturnCode TSMimeHdrFieldValueDateInsert ( TSMBuffer bufp , TSMLoc hdr , TSMLoc field , time_t value ) {\n sdk_assert ( sdk_sanity_check_mbuffer ( bufp ) == TS_SUCCESS ) ;\n sdk_assert ( ( sdk_sanity_check_mime_hdr_handle ( hdr ) == TS_SUCCESS ) || ( sdk_sanity_check_http_hdr_handle ( hdr ) == TS_SUCCESS ) ) ;\n sdk_assert ( sdk_sanity_check_field_handle ( field , hdr ) == TS_SUCCESS ) ;\n if ( ! isWriteable ( bufp ) ) {\n return TS_ERROR ;\n }\n if ( TSMimeHdrFieldValuesClear ( bufp , hdr , field ) == TS_ERROR ) {\n return TS_ERROR ;\n }\n char tmp [ 33 ] ;\n int len = mime_format_date ( tmp , value ) ;\n ( void ) TSMimeFieldValueSet ( bufp , field , - 1 , tmp , len ) ;\n return TS_SUCCESS ;\n }", "idx": 21547}
{"hash": 7549435794356072684, "project": "debian", "size": 9, "label": 0, "functionSource": "static ASN1_GENERALIZEDTIME * obj_to_asn1gtime ( VALUE time ) {\n time_t sec ;\n ASN1_GENERALIZEDTIME * t ;\n # if defined ( HAVE_ASN1_TIME_ADJ ) int off_days ;\n ossl_time_split ( time , & sec , & off_days ) ;\n if ( ! ( t = ASN1_GENERALIZEDTIME_adj ( NULL , sec , off_days , 0 ) ) ) # else sec = time_to_time_t ( time ) ;\n if ( ! ( t = ASN1_GENERALIZEDTIME_set ( NULL , sec ) ) ) # endif ossl_raise ( eASN1Error , NULL ) ;\n return t ;\n }", "idx": 21548}
{"hash": 3426991998365732450, "project": "debian", "size": 5, "label": 0, "functionSource": "static void ps2_set_ledstate ( PS2KbdState * s , int ledstate ) {\n trace_ps2_set_ledstate ( s , ledstate ) ;\n s -> ledstate = ledstate ;\n kbd_put_ledstate ( ledstate ) ;\n }", "idx": 21549}
{"hash": 1760449185745615462, "project": "debian", "size": 6, "label": 0, "functionSource": "void * TSHttpTxnArgGet ( TSHttpTxn txnp , int arg_idx ) {\n sdk_assert ( sdk_sanity_check_txn ( txnp ) == TS_SUCCESS ) ;\n sdk_assert ( arg_idx >= 0 && arg_idx < HTTP_SSN_TXN_MAX_USER_ARG ) ;\n HttpSM * sm = ( HttpSM * ) txnp ;\n return sm -> t_state . user_args [ arg_idx ] ;\n }", "idx": 21550}
{"hash": -9197960073880365676, "project": "debian", "size": 3, "label": 0, "functionSource": "void Gif_SetErrorHandler ( Gif_ReadErrorHandler handler ) {\n default_error_handler = handler ;\n }", "idx": 21551}
{"hash": -7136186224744987223, "project": "debian", "size": 25, "label": 0, "functionSource": "static size_t readmoredata ( char * buffer , size_t size , size_t nitems , void * userp ) {\n struct connectdata * conn = ( struct connectdata * ) userp ;\n struct HTTP * http = conn -> data -> req . protop ;\n size_t fullsize = size * nitems ;\n if ( ! http -> postsize ) return 0 ;\n conn -> data -> req . forbidchunk = ( http -> sending == HTTPSEND_REQUEST ) ? TRUE : FALSE ;\n if ( http -> postsize <= ( curl_off_t ) fullsize ) {\n memcpy ( buffer , http -> postdata , ( size_t ) http -> postsize ) ;\n fullsize = ( size_t ) http -> postsize ;\n if ( http -> backup . postsize ) {\n http -> postdata = http -> backup . postdata ;\n http -> postsize = http -> backup . postsize ;\n conn -> data -> state . fread_func = http -> backup . fread_func ;\n conn -> data -> state . in = http -> backup . fread_in ;\n http -> sending ++ ;\n http -> backup . postsize = 0 ;\n }\n else http -> postsize = 0 ;\n return fullsize ;\n }\n memcpy ( buffer , http -> postdata , fullsize ) ;\n http -> postdata += fullsize ;\n http -> postsize -= fullsize ;\n return fullsize ;\n }", "idx": 21552}
{"hash": 8672904772426696383, "project": "debian", "size": 82, "label": 1, "functionSource": "static int mpeg4_decode_partition_b ( MpegEncContext * s , int mb_count ) {\n int mb_num = 0 ;\n static const int8_t quant_tab [ 4 ] = {\n - 1 , - 2 , 1 , 2 }\n ;\n s -> mb_x = s -> resync_mb_x ;\n s -> first_slice_line = 1 ;\n for ( s -> mb_y = s -> resync_mb_y ;\n mb_num < mb_count ;\n s -> mb_y ++ ) {\n ff_init_block_index ( s ) ;\n for ( ;\n mb_num < mb_count && s -> mb_x < s -> mb_width ;\n s -> mb_x ++ ) {\n const int xy = s -> mb_x + s -> mb_y * s -> mb_stride ;\n mb_num ++ ;\n ff_update_block_index ( s ) ;\n if ( s -> mb_x == s -> resync_mb_x && s -> mb_y == s -> resync_mb_y + 1 ) s -> first_slice_line = 0 ;\n if ( s -> pict_type == AV_PICTURE_TYPE_I ) {\n int ac_pred = get_bits1 ( & s -> gb ) ;\n int cbpy = get_vlc2 ( & s -> gb , ff_h263_cbpy_vlc . table , CBPY_VLC_BITS , 1 ) ;\n if ( cbpy < 0 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"cbpy corrupted at %d %d\\n\" , s -> mb_x , s -> mb_y ) ;\n return - 1 ;\n }\n s -> cbp_table [ xy ] |= cbpy << 2 ;\n s -> current_picture . f . mb_type [ xy ] |= ac_pred * MB_TYPE_ACPRED ;\n }\n else {\n if ( IS_INTRA ( s -> current_picture . f . mb_type [ xy ] ) ) {\n int dir = 0 , i ;\n int ac_pred = get_bits1 ( & s -> gb ) ;\n int cbpy = get_vlc2 ( & s -> gb , ff_h263_cbpy_vlc . table , CBPY_VLC_BITS , 1 ) ;\n if ( cbpy < 0 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"I cbpy corrupted at %d %d\\n\" , s -> mb_x , s -> mb_y ) ;\n return - 1 ;\n }\n if ( s -> cbp_table [ xy ] & 8 ) {\n ff_set_qscale ( s , s -> qscale + quant_tab [ get_bits ( & s -> gb , 2 ) ] ) ;\n }\n s -> current_picture . f . qscale_table [ xy ] = s -> qscale ;\n for ( i = 0 ;\n i < 6 ;\n i ++ ) {\n int dc_pred_dir ;\n int dc = mpeg4_decode_dc ( s , i , & dc_pred_dir ) ;\n if ( dc < 0 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"DC corrupted at %d %d\\n\" , s -> mb_x , s -> mb_y ) ;\n return - 1 ;\n }\n dir <<= 1 ;\n if ( dc_pred_dir ) dir |= 1 ;\n }\n s -> cbp_table [ xy ] &= 3 ;\n s -> cbp_table [ xy ] |= cbpy << 2 ;\n s -> current_picture . f . mb_type [ xy ] |= ac_pred * MB_TYPE_ACPRED ;\n s -> pred_dir_table [ xy ] = dir ;\n }\n else if ( IS_SKIP ( s -> current_picture . f . mb_type [ xy ] ) ) {\n s -> current_picture . f . qscale_table [ xy ] = s -> qscale ;\n s -> cbp_table [ xy ] = 0 ;\n }\n else {\n int cbpy = get_vlc2 ( & s -> gb , ff_h263_cbpy_vlc . table , CBPY_VLC_BITS , 1 ) ;\n if ( cbpy < 0 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"P cbpy corrupted at %d %d\\n\" , s -> mb_x , s -> mb_y ) ;\n return - 1 ;\n }\n if ( s -> cbp_table [ xy ] & 8 ) {\n ff_set_qscale ( s , s -> qscale + quant_tab [ get_bits ( & s -> gb , 2 ) ] ) ;\n }\n s -> current_picture . f . qscale_table [ xy ] = s -> qscale ;\n s -> cbp_table [ xy ] &= 3 ;\n s -> cbp_table [ xy ] |= ( cbpy ^ 0xf ) << 2 ;\n }\n }\n }\n if ( mb_num >= mb_count ) return 0 ;\n s -> mb_x = 0 ;\n }\n return 0 ;\n }", "idx": 21553}
{"hash": -6474315190511670247, "project": "debian", "size": 51, "label": 0, "functionSource": "static void basic_ec_math ( void ) {\n gpg_error_t err ;\n gcry_ctx_t ctx ;\n gcry_mpi_t P , A ;\n gcry_mpi_point_t G , Q ;\n gcry_mpi_t d ;\n gcry_mpi_t x , y , z ;\n wherestr = \"basic_ec_math\" ;\n show ( \"checking basic math functions for EC\\n\" ) ;\n P = hex2mpi ( \"0xfffffffffffffffffffffffffffffffeffffffffffffffff\" ) ;\n A = hex2mpi ( \"0xfffffffffffffffffffffffffffffffefffffffffffffffc\" ) ;\n G = make_point ( \"188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012\" , \"7192B95FFC8DA78631011ED6B24CDD573F977A11E794811\" , \"1\" ) ;\n d = hex2mpi ( \"D4EF27E32F8AD8E2A1C6DDEBB1D235A69E3CEF9BCE90273D\" ) ;\n Q = gcry_mpi_point_new ( 0 ) ;\n err = ec_p_new ( & ctx , P , A ) ;\n if ( err ) die ( \"ec_p_new failed: %s\\n\" , gpg_strerror ( err ) ) ;\n x = gcry_mpi_new ( 0 ) ;\n y = gcry_mpi_new ( 0 ) ;\n z = gcry_mpi_new ( 0 ) ;\n {\n gcry_mpi_t tmp ;\n tmp = gcry_mpi_new ( 0 ) ;\n gcry_mpi_ec_mul ( Q , tmp , G , ctx ) ;\n gcry_mpi_release ( tmp ) ;\n gcry_mpi_point_get ( x , y , z , Q ) ;\n if ( gcry_mpi_cmp_ui ( x , 0 ) || gcry_mpi_cmp_ui ( y , 0 ) || gcry_mpi_cmp_ui ( z , 0 ) ) fail ( \"multiply a point by zero failed\\n\" ) ;\n }\n gcry_mpi_ec_mul ( Q , d , G , ctx ) ;\n gcry_mpi_point_get ( x , y , z , Q ) ;\n if ( cmp_mpihex ( x , \"222D9EC717C89D047E0898C9185B033CD11C0A981EE6DC66\" ) || cmp_mpihex ( y , \"605DE0A82D70D3E0F84A127D0739ED33D657DF0D054BFDE8\" ) || cmp_mpihex ( z , \"00B06B519071BC536999AC8F2D3934B3C1FC9EACCD0A31F88F\" ) ) fail ( \"computed public key does not match\\n\" ) ;\n if ( debug ) {\n print_mpi ( \"Q.x\" , x ) ;\n print_mpi ( \"Q.y\" , y ) ;\n print_mpi ( \"Q.z\" , z ) ;\n }\n if ( gcry_mpi_ec_get_affine ( x , y , Q , ctx ) ) fail ( \"failed to get affine coordinates\\n\" ) ;\n if ( cmp_mpihex ( x , \"008532093BA023F4D55C0424FA3AF9367E05F309DC34CDC3FE\" ) || cmp_mpihex ( y , \"00C13CA9E617C6C8487BFF6A726E3C4F277913D97117939966\" ) ) fail ( \"computed affine coordinates of public key do not match\\n\" ) ;\n if ( debug ) {\n print_mpi ( \"q.x\" , x ) ;\n print_mpi ( \"q.y\" , y ) ;\n }\n gcry_mpi_release ( z ) ;\n gcry_mpi_release ( y ) ;\n gcry_mpi_release ( x ) ;\n gcry_mpi_point_release ( Q ) ;\n gcry_mpi_release ( d ) ;\n gcry_mpi_point_release ( G ) ;\n gcry_mpi_release ( A ) ;\n gcry_mpi_release ( P ) ;\n gcry_ctx_release ( ctx ) ;\n }", "idx": 21554}
{"hash": 2895622461494525400, "project": "debian", "size": 28, "label": 0, "functionSource": "static void test_field_names ( ) {\n int rc ;\n MYSQL_RES * result ;\n myheader ( \"test_field_names\" ) ;\n if ( ! opt_silent ) fprintf ( stdout , \"\\n %d, %d, %d\" , MYSQL_TYPE_DECIMAL , MYSQL_TYPE_NEWDATE , MYSQL_TYPE_ENUM ) ;\n rc = mysql_query ( mysql , \"DROP TABLE IF EXISTS test_field_names1\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"DROP TABLE IF EXISTS test_field_names2\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"CREATE TABLE test_field_names1(id int, name varchar(50))\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"CREATE TABLE test_field_names2(id int, name varchar(50))\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"SELECT id as 'id-alias' FROM test_field_names1\" ) ;\n myquery ( rc ) ;\n result = mysql_use_result ( mysql ) ;\n mytest ( result ) ;\n rc = my_process_result_set ( result ) ;\n DIE_UNLESS ( rc == 0 ) ;\n mysql_free_result ( result ) ;\n rc = mysql_query ( mysql , \"SELECT t1.id as 'id-alias', test_field_names2.name FROM test_field_names1 t1, test_field_names2\" ) ;\n myquery ( rc ) ;\n result = mysql_use_result ( mysql ) ;\n mytest ( result ) ;\n rc = my_process_result_set ( result ) ;\n DIE_UNLESS ( rc == 0 ) ;\n mysql_free_result ( result ) ;\n }", "idx": 21555}
{"hash": -5315423743066773158, "project": "debian", "size": 10, "label": 0, "functionSource": "struct message_decoder_context * message_decoder_init ( normalizer_func_t * normalizer , enum message_decoder_flags flags ) {\n struct message_decoder_context * ctx ;\n ctx = i_new ( struct message_decoder_context , 1 ) ;\n ctx -> flags = flags ;\n ctx -> normalizer = normalizer ;\n ctx -> buf = buffer_create_dynamic ( default_pool , 8192 ) ;\n ctx -> buf2 = buffer_create_dynamic ( default_pool , 8192 ) ;\n ctx -> encoding_buf = buffer_create_dynamic ( default_pool , 128 ) ;\n return ctx ;\n }", "idx": 21556}
{"hash": 9176142195250515812, "project": "debian", "size": 5, "label": 0, "functionSource": "static void prplcb_request_action_free ( void * data ) {\n struct prplcb_request_action_data * pqad = data ;\n pqad -> bee_data = NULL ;\n purple_request_close ( PURPLE_REQUEST_ACTION , pqad ) ;\n }", "idx": 21557}
{"hash": 6664609110189077049, "project": "debian", "size": 63, "label": 0, "functionSource": "static int decode_packet ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n WMAProDecodeCtx * s = avctx -> priv_data ;\n GetBitContext * gb = & s -> pgb ;\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n int num_bits_prev_frame ;\n int packet_sequence_number ;\n * got_frame_ptr = 0 ;\n if ( s -> packet_done || s -> packet_loss ) {\n s -> packet_done = 0 ;\n if ( buf_size < avctx -> block_align ) return 0 ;\n s -> next_packet_start = buf_size - avctx -> block_align ;\n buf_size = avctx -> block_align ;\n s -> buf_bit_size = buf_size << 3 ;\n init_get_bits ( gb , buf , s -> buf_bit_size ) ;\n packet_sequence_number = get_bits ( gb , 4 ) ;\n skip_bits ( gb , 2 ) ;\n num_bits_prev_frame = get_bits ( gb , s -> log2_frame_size ) ;\n av_dlog ( avctx , \"packet[%d]: nbpf %x\\n\" , avctx -> frame_number , num_bits_prev_frame ) ;\n if ( ! s -> packet_loss && ( ( s -> packet_sequence_number + 1 ) & 0xF ) != packet_sequence_number ) {\n s -> packet_loss = 1 ;\n av_log ( avctx , AV_LOG_ERROR , \"Packet loss detected! seq %x vs %x\\n\" , s -> packet_sequence_number , packet_sequence_number ) ;\n }\n s -> packet_sequence_number = packet_sequence_number ;\n if ( num_bits_prev_frame > 0 ) {\n int remaining_packet_bits = s -> buf_bit_size - get_bits_count ( gb ) ;\n if ( num_bits_prev_frame >= remaining_packet_bits ) {\n num_bits_prev_frame = remaining_packet_bits ;\n s -> packet_done = 1 ;\n }\n save_bits ( s , gb , num_bits_prev_frame , 1 ) ;\n av_dlog ( avctx , \"accumulated %x bits of frame data\\n\" , s -> num_saved_bits - s -> frame_offset ) ;\n if ( ! s -> packet_loss ) decode_frame ( s , data , got_frame_ptr ) ;\n }\n else if ( s -> num_saved_bits - s -> frame_offset ) {\n av_dlog ( avctx , \"ignoring %x previously saved bits\\n\" , s -> num_saved_bits - s -> frame_offset ) ;\n }\n if ( s -> packet_loss ) {\n s -> num_saved_bits = 0 ;\n s -> packet_loss = 0 ;\n }\n }\n else {\n int frame_size ;\n s -> buf_bit_size = ( avpkt -> size - s -> next_packet_start ) << 3 ;\n init_get_bits ( gb , avpkt -> data , s -> buf_bit_size ) ;\n skip_bits ( gb , s -> packet_offset ) ;\n if ( s -> len_prefix && remaining_bits ( s , gb ) > s -> log2_frame_size && ( frame_size = show_bits ( gb , s -> log2_frame_size ) ) && frame_size <= remaining_bits ( s , gb ) ) {\n save_bits ( s , gb , frame_size , 0 ) ;\n s -> packet_done = ! decode_frame ( s , data , got_frame_ptr ) ;\n }\n else if ( ! s -> len_prefix && s -> num_saved_bits > get_bits_count ( & s -> gb ) ) {\n s -> packet_done = ! decode_frame ( s , data , got_frame_ptr ) ;\n }\n else s -> packet_done = 1 ;\n }\n if ( s -> packet_done && ! s -> packet_loss && remaining_bits ( s , gb ) > 0 ) {\n save_bits ( s , gb , remaining_bits ( s , gb ) , 0 ) ;\n }\n s -> packet_offset = get_bits_count ( gb ) & 7 ;\n if ( s -> packet_loss ) return AVERROR_INVALIDDATA ;\n return get_bits_count ( gb ) >> 3 ;\n }", "idx": 21558}
{"hash": 313627013719508831, "project": "debian", "size": 3, "label": 0, "functionSource": "static inline void SetPixelYellow ( const Image * restrict image , const Quantum yellow , Quantum * restrict pixel ) {\n pixel [ image -> channel_map [ YellowPixelChannel ] . offset ] = yellow ;\n }", "idx": 21559}
{"hash": -5260094338219889901, "project": "debian", "size": 15, "label": 0, "functionSource": "static void stroke_loglevel ( private_stroke_socket_t * this , stroke_msg_t * msg , FILE * out ) {\n debug_t group ;\n pop_string ( msg , & ( msg -> loglevel . type ) ) ;\n DBG1 ( DBG_CFG , \"received stroke: loglevel %d for %s\" , msg -> loglevel . level , msg -> loglevel . type ) ;\n if ( this -> prevent_loglevel_changes ) {\n DBG1 ( DBG_CFG , \"prevented log level change\" ) ;\n fprintf ( out , \"command not allowed!\\n\" ) ;\n return ;\n }\n if ( ! enum_from_name ( debug_names , msg -> loglevel . type , & group ) ) {\n fprintf ( out , \"unknown type '%s'!\\n\" , msg -> loglevel . type ) ;\n return ;\n }\n charon -> set_level ( charon , group , msg -> loglevel . level ) ;\n }", "idx": 21560}
{"hash": 3649198920984613385, "project": "debian", "size": 8, "label": 0, "functionSource": "static int vmsvga_post_load ( void * opaque , int version_id ) {\n struct vmsvga_state_s * s = opaque ;\n s -> invalidated = 1 ;\n if ( s -> config ) {\n s -> fifo = ( uint32_t * ) s -> fifo_ptr ;\n }\n return 0 ;\n }", "idx": 21561}
{"hash": -5615323818347734353, "project": "debian", "size": 5, "label": 0, "functionSource": "static int show_net_compression ( THD * thd , SHOW_VAR * var , char * buff ) {\n var -> type = SHOW_MY_BOOL ;\n var -> value = ( char * ) & thd -> net . compress ;\n return 0 ;\n }", "idx": 21562}
{"hash": -6552851419396579257, "project": "debian", "size": 18, "label": 0, "functionSource": "static int SpoolssEnumPrinters_q ( tvbuff_t * tvb , int offset , packet_info * pinfo , proto_tree * tree , dcerpc_info * di , guint8 * drep _U_ ) {\n guint32 level , flags ;\n dcerpc_call_value * dcv = ( dcerpc_call_value * ) di -> call_data ;\n static const int * hf_flags [ ] = {\n & hf_enumprinters_flags_network , & hf_enumprinters_flags_shared , & hf_enumprinters_flags_remote , & hf_enumprinters_flags_name , & hf_enumprinters_flags_connections , & hf_enumprinters_flags_local , & hf_enumprinters_flags_default , NULL }\n ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , NULL , di , drep , - 1 , & flags ) ;\n proto_tree_add_bitmask_value ( tree , tvb , offset - 4 , hf_enumprinters_flags , ett_enumprinters_flags , hf_flags , flags ) ;\n offset = dissect_ndr_str_pointer_item ( tvb , offset , pinfo , tree , di , drep , NDR_POINTER_UNIQUE , \"Server name\" , hf_servername , 0 ) ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , tree , di , drep , hf_level , & level ) ;\n if ( ! pinfo -> fd -> flags . visited ) {\n dcv -> se_data = GINT_TO_POINTER ( ( int ) level ) ;\n }\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \", level %d\" , level ) ;\n offset = dissect_spoolss_buffer ( tvb , offset , pinfo , tree , di , drep , NULL ) ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , tree , di , drep , hf_offered , NULL ) ;\n return offset ;\n }", "idx": 21563}
{"hash": 3728341105073176576, "project": "debian", "size": 40, "label": 1, "functionSource": "static ossl_inline void lh_ ## type ## _free ( LHASH_OF ( type ) * lh ) {\n OPENSSL_LH_free ( ( OPENSSL_LHASH * ) lh ) ;\n }\n static ossl_inline type * lh_ ## type ## _insert ( LHASH_OF ( type ) * lh , type * d ) {\n return ( type * ) OPENSSL_LH_insert ( ( OPENSSL_LHASH * ) lh , d ) ;\n }\n static ossl_inline type * lh_ ## type ## _delete ( LHASH_OF ( type ) * lh , const type * d ) {\n return ( type * ) OPENSSL_LH_delete ( ( OPENSSL_LHASH * ) lh , d ) ;\n }\n static ossl_inline type * lh_ ## type ## _retrieve ( LHASH_OF ( type ) * lh , const type * d ) {\n return ( type * ) OPENSSL_LH_retrieve ( ( OPENSSL_LHASH * ) lh , d ) ;\n }\n static ossl_inline int lh_ ## type ## _error ( LHASH_OF ( type ) * lh ) {\n return OPENSSL_LH_error ( ( OPENSSL_LHASH * ) lh ) ;\n }\n static ossl_inline unsigned long lh_ ## type ## _num_items ( LHASH_OF ( type ) * lh ) {\n return OPENSSL_LH_num_items ( ( OPENSSL_LHASH * ) lh ) ;\n }\n static ossl_inline void lh_ ## type ## _node_stats_bio ( const LHASH_OF ( type ) * lh , BIO * out ) {\n OPENSSL_LH_node_stats_bio ( ( const OPENSSL_LHASH * ) lh , out ) ;\n }\n static ossl_inline void lh_ ## type ## _node_usage_stats_bio ( const LHASH_OF ( type ) * lh , BIO * out ) {\n OPENSSL_LH_node_usage_stats_bio ( ( const OPENSSL_LHASH * ) lh , out ) ;\n }\n static ossl_inline void lh_ ## type ## _stats_bio ( const LHASH_OF ( type ) * lh , BIO * out ) {\n OPENSSL_LH_stats_bio ( ( const OPENSSL_LHASH * ) lh , out ) ;\n }\n static ossl_inline unsigned long lh_ ## type ## _get_down_load ( LHASH_OF ( type ) * lh ) {\n return OPENSSL_LH_get_down_load ( ( OPENSSL_LHASH * ) lh ) ;\n }\n static ossl_inline void lh_ ## type ## _set_down_load ( LHASH_OF ( type ) * lh , unsigned long dl ) {\n OPENSSL_LH_set_down_load ( ( OPENSSL_LHASH * ) lh , dl ) ;\n }\n static ossl_inline void lh_ ## type ## _doall ( LHASH_OF ( type ) * lh , void ( * doall ) ( type * ) ) {\n OPENSSL_LH_doall ( ( OPENSSL_LHASH * ) lh , ( OPENSSL_LH_DOALL_FUNC ) doall ) ;\n }\n LHASH_OF ( type ) # define IMPLEMENT_LHASH_DOALL_ARG_CONST ( type , argtype ) int_implement_lhash_doall ( type , argtype , const type ) # define IMPLEMENT_LHASH_DOALL_ARG ( type , argtype ) int_implement_lhash_doall ( type , argtype , type ) # define int_implement_lhash_doall ( type , argtype , cbargtype ) static ossl_inline void lh_ ## type ## _doall_ ## argtype ( LHASH_OF ( type ) * lh , void ( * fn ) ( cbargtype * , argtype * ) , argtype * arg ) {\n OPENSSL_LH_doall_arg ( ( OPENSSL_LHASH * ) lh , ( OPENSSL_LH_DOALL_FUNCARG ) fn , ( void * ) arg ) ;\n }\n LHASH_OF ( type ) DEFINE_LHASH_OF ( OPENSSL_STRING )", "idx": 21564}
{"hash": 927123821003322045, "project": "chrome", "size": 16, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( PageLoadMetricsBrowserTest , PaintInMainAndChildFrame ) {\n ASSERT_TRUE ( embedded_test_server ( ) -> Start ( ) ) ;\n GURL a_url ( embedded_test_server ( ) -> GetURL ( \"/page_load_metrics/main_frame_with_iframe.html\" ) ) ;\n auto waiter = CreatePageLoadMetricsWaiter ( ) ;\n waiter -> AddPageExpectation ( TimingField : : FIRST_LAYOUT ) ;\n waiter -> AddPageExpectation ( TimingField : : LOAD_EVENT ) ;\n waiter -> AddPageExpectation ( TimingField : : FIRST_PAINT ) ;\n waiter -> AddPageExpectation ( TimingField : : FIRST_CONTENTFUL_PAINT ) ;\n waiter -> AddSubFrameExpectation ( TimingField : : FIRST_PAINT ) ;\n waiter -> AddSubFrameExpectation ( TimingField : : FIRST_CONTENTFUL_PAINT ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , a_url ) ;\n waiter -> Wait ( ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHistogramFirstLayout , 1 ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHistogramLoad , 1 ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHistogramFirstPaint , 1 ) ;\n }", "idx": 21565}
{"hash": 6632536031698733342, "project": "debian", "size": 7, "label": 0, "functionSource": "static int opt_pretty ( void * optctx , const char * opt , const char * arg ) {\n show_value_unit = 1 ;\n use_value_prefix = 1 ;\n use_byte_value_binary_prefix = 1 ;\n use_value_sexagesimal_format = 1 ;\n return 0 ;\n }", "idx": 21566}
{"hash": 8637588907624249958, "project": "debian", "size": 3, "label": 0, "functionSource": "static guint get_pcp_message_len ( packet_info * pinfo _U_ , tvbuff_t * tvb , int offset , void * data _U_ ) {\n return ( guint ) tvb_get_ntohl ( tvb , offset ) ;\n }", "idx": 21567}
{"hash": -8028756826159773630, "project": "debian", "size": 38, "label": 0, "functionSource": "ArchiveHandle * CloneArchive ( ArchiveHandle * AH ) {\n ArchiveHandle * clone ;\n clone = ( ArchiveHandle * ) pg_malloc ( sizeof ( ArchiveHandle ) ) ;\n memcpy ( clone , AH , sizeof ( ArchiveHandle ) ) ;\n memset ( & ( clone -> sqlparse ) , 0 , sizeof ( clone -> sqlparse ) ) ;\n clone -> connection = NULL ;\n clone -> connCancel = NULL ;\n clone -> currUser = NULL ;\n clone -> currSchema = NULL ;\n clone -> currTablespace = NULL ;\n clone -> currWithOids = - 1 ;\n if ( clone -> savedPassword ) clone -> savedPassword = pg_strdup ( clone -> savedPassword ) ;\n clone -> public . n_errors = 0 ;\n if ( AH -> mode == archModeRead ) {\n RestoreOptions * ropt = AH -> public . ropt ;\n Assert ( AH -> connection == NULL ) ;\n ConnectDatabase ( ( Archive * ) clone , ropt -> dbname , ropt -> pghost , ropt -> pgport , ropt -> username , ropt -> promptPassword ) ;\n _doSetFixedOutputState ( clone ) ;\n }\n else {\n PQExpBufferData connstr ;\n char * pghost ;\n char * pgport ;\n char * username ;\n Assert ( AH -> connection != NULL ) ;\n initPQExpBuffer ( & connstr ) ;\n appendPQExpBuffer ( & connstr , \"dbname=\" ) ;\n appendConnStrVal ( & connstr , PQdb ( AH -> connection ) ) ;\n pghost = PQhost ( AH -> connection ) ;\n pgport = PQport ( AH -> connection ) ;\n username = PQuser ( AH -> connection ) ;\n ConnectDatabase ( ( Archive * ) clone , connstr . data , pghost , pgport , username , TRI_NO ) ;\n termPQExpBuffer ( & connstr ) ;\n }\n ( clone -> ClonePtr ) ( clone ) ;\n Assert ( clone -> connection != NULL ) ;\n return clone ;\n }", "idx": 21568}
{"hash": 3584320764213684062, "project": "debian", "size": 8, "label": 0, "functionSource": "static struct rows_data * find_rowsin_msg_data ( struct mswsp_ct * ct , packet_info * pinfo , void * private_data ) {\n struct rows_data * result = NULL ;\n struct message_data * data = find_matching_request_by_fid ( ct , pinfo , 0xCC , TRUE , private_data ) ;\n if ( data ) {\n result = & data -> content . rowsin ;\n }\n return result ;\n }", "idx": 21569}
{"hash": 6323824267898511453, "project": "debian", "size": 6, "label": 0, "functionSource": "static void rgb_to_gray ( fz_context * ctx , const fz_colorspace * cs , const float * rgb , float * gray ) {\n float r = rgb [ 0 ] ;\n float g = rgb [ 1 ] ;\n float b = rgb [ 2 ] ;\n gray [ 0 ] = r * 0.3f + g * 0.59f + b * 0.11f ;\n }", "idx": 21570}
{"hash": -5640788001150418304, "project": "debian", "size": 33, "label": 0, "functionSource": "static void dissect_t38_tcp_pdu ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree ) {\n proto_item * it ;\n proto_tree * tr ;\n guint32 offset = 0 ;\n tvbuff_t * next_tvb ;\n guint16 ifp_packet_number = 1 ;\n col_set_str ( pinfo -> cinfo , COL_PROTOCOL , \"T.38\" ) ;\n col_clear ( pinfo -> cinfo , COL_INFO ) ;\n primary_part = TRUE ;\n Data_Field_item_num = 0 ;\n it = proto_tree_add_protocol_format ( tree , proto_t38 , tvb , 0 , - 1 , \"ITU-T Recommendation T.38\" ) ;\n tr = proto_item_add_subtree ( it , ett_t38 ) ;\n init_t38_info_conv ( pinfo ) ;\n if ( global_t38_show_setup_info ) {\n show_setup_info ( tvb , tr , p_t38_packet_conv ) ;\n }\n col_append_str ( pinfo -> cinfo , COL_INFO , \"TCP: IFPPacket\" ) ;\n while ( tvb_reported_length_remaining ( tvb , offset ) > 0 ) {\n next_tvb = tvb_new_subset_remaining ( tvb , offset ) ;\n offset += dissect_IFPPacket_PDU ( next_tvb , pinfo , tr , NULL ) ;\n ifp_packet_number ++ ;\n if ( tvb_reported_length_remaining ( tvb , offset ) > 0 ) {\n if ( t38_tpkt_usage == T38_TPKT_ALWAYS ) {\n proto_tree_add_expert_format ( tr , pinfo , & ei_t38_malformed , tvb , offset , tvb_reported_length_remaining ( tvb , offset ) , \"[MALFORMED PACKET or wrong preference settings]\" ) ;\n col_append_str ( pinfo -> cinfo , COL_INFO , \" [Malformed?]\" ) ;\n break ;\n }\n else {\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \" IFPPacket#%u\" , ifp_packet_number ) ;\n }\n }\n }\n }", "idx": 21571}
{"hash": -1768728156572022708, "project": "debian", "size": 3, "label": 0, "functionSource": "int32_t jbig2_get_int32 ( const byte * bptr ) {\n return ( ( int32_t ) get_int16 ( bptr ) << 16 ) | get_uint16 ( bptr + 2 ) ;\n }", "idx": 21572}
{"hash": -5697857125570093892, "project": "chrome", "size": 12, "label": 0, "functionSource": "static UBool _isRegionSubtag ( const char * s , int32_t len ) {\n if ( len < 0 ) {\n len = ( int32_t ) uprv_strlen ( s ) ;\n }\n if ( len == 2 && _isAlphaString ( s , len ) ) {\n return TRUE ;\n }\n if ( len == 3 && _isNumericString ( s , len ) ) {\n return TRUE ;\n }\n return FALSE ;\n }", "idx": 21573}
{"hash": -6228844445714759206, "project": "debian", "size": 23, "label": 0, "functionSource": "static void fts_parser_script_more ( struct fts_parser * _parser , struct message_block * block ) {\n struct script_fts_parser * parser = ( struct script_fts_parser * ) _parser ;\n ssize_t ret ;\n if ( block -> size > 0 ) {\n if ( ! parser -> failed && write_full ( parser -> fd , block -> data , block -> size ) < 0 ) {\n i_error ( \"write(%s) failed: %m\" , parser -> path ) ;\n parser -> failed = TRUE ;\n }\n block -> size = 0 ;\n }\n else {\n if ( ! parser -> shutdown ) {\n if ( shutdown ( parser -> fd , SHUT_WR ) < 0 ) i_error ( \"shutdown(%s) failed: %m\" , parser -> path ) ;\n parser -> shutdown = TRUE ;\n }\n ret = read ( parser -> fd , parser -> outbuf , sizeof ( parser -> outbuf ) ) ;\n if ( ret < 0 ) i_error ( \"read(%s) failed: %m\" , parser -> path ) ;\n else {\n block -> data = parser -> outbuf ;\n block -> size = ret ;\n }\n }\n }", "idx": 21574}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_T_extendedPAR_item ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_T_extendedPAR_item , T_extendedPAR_item_sequence ) ;\n return offset ;\n }", "idx": 21575}
{"hash": 3668456668028959955, "project": "debian", "size": 3, "label": 0, "functionSource": "static VALUE mArray_to_json ( int argc , VALUE * argv , VALUE self ) {\n GENERATE_JSON ( array ) ;\n }", "idx": 21576}
{"hash": -341028540041678099, "project": "debian", "size": 72, "label": 0, "functionSource": "static int rtdatetolfp ( char * str , l_fp * lfp ) {\n register char * cp ;\n register int i ;\n struct calendar cal ;\n char buf [ 4 ] ;\n cal . yearday = 0 ;\n cp = str ;\n if ( ! isdigit ( ( int ) * cp ) ) {\n if ( * cp == '-' ) {\n L_CLR ( lfp ) ;\n return 1 ;\n }\n return 0 ;\n }\n cal . monthday = ( u_char ) ( * cp ++ - '0' ) ;\n if ( isdigit ( ( int ) * cp ) ) {\n cal . monthday = ( u_char ) ( ( cal . monthday << 3 ) + ( cal . monthday << 1 ) ) ;\n cal . monthday = ( u_char ) ( cal . monthday + * cp ++ - '0' ) ;\n }\n if ( * cp ++ != '-' ) return 0 ;\n for ( i = 0 ;\n i < 3 ;\n i ++ ) buf [ i ] = * cp ++ ;\n buf [ 3 ] = '\\0' ;\n for ( i = 0 ;\n i < 12 ;\n i ++ ) if ( STREQ ( buf , months [ i ] ) ) break ;\n if ( i == 12 ) return 0 ;\n cal . month = ( u_char ) ( i + 1 ) ;\n if ( * cp ++ != '-' ) return 0 ;\n if ( ! isdigit ( ( int ) * cp ) ) return 0 ;\n cal . year = ( u_short ) ( * cp ++ - '0' ) ;\n if ( isdigit ( ( int ) * cp ) ) {\n cal . year = ( u_short ) ( ( cal . year << 3 ) + ( cal . year << 1 ) ) ;\n cal . year = ( u_short ) ( * cp ++ - '0' ) ;\n }\n if ( isdigit ( ( int ) * cp ) ) {\n cal . year = ( u_short ) ( ( cal . year << 3 ) + ( cal . year << 1 ) ) ;\n cal . year = ( u_short ) ( cal . year + * cp ++ - '0' ) ;\n }\n if ( isdigit ( ( int ) * cp ) ) {\n cal . year = ( u_short ) ( ( cal . year << 3 ) + ( cal . year << 1 ) ) ;\n cal . year = ( u_short ) ( cal . year + * cp ++ - '0' ) ;\n }\n if ( cal . year == 0 ) {\n L_CLR ( lfp ) ;\n return 1 ;\n }\n if ( * cp ++ != ' ' || ! isdigit ( ( int ) * cp ) ) return 0 ;\n cal . hour = ( u_char ) ( * cp ++ - '0' ) ;\n if ( isdigit ( ( int ) * cp ) ) {\n cal . hour = ( u_char ) ( ( cal . hour << 3 ) + ( cal . hour << 1 ) ) ;\n cal . hour = ( u_char ) ( cal . hour + * cp ++ - '0' ) ;\n }\n if ( * cp ++ != ':' || ! isdigit ( ( int ) * cp ) ) return 0 ;\n cal . minute = ( u_char ) ( * cp ++ - '0' ) ;\n if ( isdigit ( ( int ) * cp ) ) {\n cal . minute = ( u_char ) ( ( cal . minute << 3 ) + ( cal . minute << 1 ) ) ;\n cal . minute = ( u_char ) ( cal . minute + * cp ++ - '0' ) ;\n }\n if ( * cp ++ != ':' || ! isdigit ( ( int ) * cp ) ) return 0 ;\n cal . second = ( u_char ) ( * cp ++ - '0' ) ;\n if ( isdigit ( ( int ) * cp ) ) {\n cal . second = ( u_char ) ( ( cal . second << 3 ) + ( cal . second << 1 ) ) ;\n cal . second = ( u_char ) ( cal . second + * cp ++ - '0' ) ;\n }\n if ( cal . year < 72 ) cal . year += 2000 ;\n if ( cal . year < 100 ) cal . year += 1900 ;\n lfp -> l_ui = caltontp ( & cal ) ;\n lfp -> l_uf = 0 ;\n return 1 ;\n }", "idx": 21577}
{"hash": 355220887711506893, "project": "debian", "size": 89, "label": 0, "functionSource": "static double eqjoinsel_semi ( Oid operator , VariableStatData * vardata1 , VariableStatData * vardata2 , RelOptInfo * inner_rel ) {\n double selec ;\n double nd1 ;\n double nd2 ;\n bool isdefault1 ;\n bool isdefault2 ;\n Oid opfuncoid ;\n Form_pg_statistic stats1 = NULL ;\n bool have_mcvs1 = false ;\n Datum * values1 = NULL ;\n int nvalues1 = 0 ;\n float4 * numbers1 = NULL ;\n int nnumbers1 = 0 ;\n bool have_mcvs2 = false ;\n Datum * values2 = NULL ;\n int nvalues2 = 0 ;\n float4 * numbers2 = NULL ;\n int nnumbers2 = 0 ;\n nd1 = get_variable_numdistinct ( vardata1 , & isdefault1 ) ;\n nd2 = get_variable_numdistinct ( vardata2 , & isdefault2 ) ;\n opfuncoid = OidIsValid ( operator ) ? get_opcode ( operator ) : InvalidOid ;\n if ( vardata2 -> rel ) nd2 = Min ( nd2 , vardata2 -> rel -> rows ) ;\n nd2 = Min ( nd2 , inner_rel -> rows ) ;\n if ( HeapTupleIsValid ( vardata1 -> statsTuple ) ) {\n stats1 = ( Form_pg_statistic ) GETSTRUCT ( vardata1 -> statsTuple ) ;\n if ( statistic_proc_security_check ( vardata1 , opfuncoid ) ) have_mcvs1 = get_attstatsslot ( vardata1 -> statsTuple , vardata1 -> atttype , vardata1 -> atttypmod , STATISTIC_KIND_MCV , InvalidOid , NULL , & values1 , & nvalues1 , & numbers1 , & nnumbers1 ) ;\n }\n if ( HeapTupleIsValid ( vardata2 -> statsTuple ) && statistic_proc_security_check ( vardata2 , opfuncoid ) ) {\n have_mcvs2 = get_attstatsslot ( vardata2 -> statsTuple , vardata2 -> atttype , vardata2 -> atttypmod , STATISTIC_KIND_MCV , InvalidOid , NULL , & values2 , & nvalues2 , & numbers2 , & nnumbers2 ) ;\n }\n if ( have_mcvs1 && have_mcvs2 && OidIsValid ( operator ) ) {\n FmgrInfo eqproc ;\n bool * hasmatch1 ;\n bool * hasmatch2 ;\n double nullfrac1 = stats1 -> stanullfrac ;\n double matchfreq1 , uncertainfrac , uncertain ;\n int i , nmatches , clamped_nvalues2 ;\n clamped_nvalues2 = Min ( nvalues2 , nd2 ) ;\n fmgr_info ( opfuncoid , & eqproc ) ;\n hasmatch1 = ( bool * ) palloc0 ( nvalues1 * sizeof ( bool ) ) ;\n hasmatch2 = ( bool * ) palloc0 ( clamped_nvalues2 * sizeof ( bool ) ) ;\n nmatches = 0 ;\n for ( i = 0 ;\n i < nvalues1 ;\n i ++ ) {\n int j ;\n for ( j = 0 ;\n j < clamped_nvalues2 ;\n j ++ ) {\n if ( hasmatch2 [ j ] ) continue ;\n if ( DatumGetBool ( FunctionCall2Coll ( & eqproc , DEFAULT_COLLATION_OID , values1 [ i ] , values2 [ j ] ) ) ) {\n hasmatch1 [ i ] = hasmatch2 [ j ] = true ;\n nmatches ++ ;\n break ;\n }\n }\n }\n matchfreq1 = 0.0 ;\n for ( i = 0 ;\n i < nvalues1 ;\n i ++ ) {\n if ( hasmatch1 [ i ] ) matchfreq1 += numbers1 [ i ] ;\n }\n CLAMP_PROBABILITY ( matchfreq1 ) ;\n pfree ( hasmatch1 ) ;\n pfree ( hasmatch2 ) ;\n if ( ! isdefault1 && ! isdefault2 ) {\n nd1 -= nmatches ;\n nd2 -= nmatches ;\n if ( nd1 <= nd2 || nd2 < 0 ) uncertainfrac = 1.0 ;\n else uncertainfrac = nd2 / nd1 ;\n }\n else uncertainfrac = 0.5 ;\n uncertain = 1.0 - matchfreq1 - nullfrac1 ;\n CLAMP_PROBABILITY ( uncertain ) ;\n selec = matchfreq1 + uncertainfrac * uncertain ;\n }\n else {\n double nullfrac1 = stats1 ? stats1 -> stanullfrac : 0.0 ;\n if ( ! isdefault1 && ! isdefault2 ) {\n if ( nd1 <= nd2 || nd2 < 0 ) selec = 1.0 - nullfrac1 ;\n else selec = ( nd2 / nd1 ) * ( 1.0 - nullfrac1 ) ;\n }\n else selec = 0.5 * ( 1.0 - nullfrac1 ) ;\n }\n if ( have_mcvs1 ) free_attstatsslot ( vardata1 -> atttype , values1 , nvalues1 , numbers1 , nnumbers1 ) ;\n if ( have_mcvs2 ) free_attstatsslot ( vardata2 -> atttype , values2 , nvalues2 , numbers2 , nnumbers2 ) ;\n return selec ;\n }", "idx": 21578}
{"hash": 3584320764213684062, "project": "debian", "size": 27, "label": 0, "functionSource": "static int parse_CAggregSpec ( tvbuff_t * tvb , int offset , proto_tree * parent_tree , proto_tree * pad_tree , const char * fmt , ... ) {\n proto_item * item ;\n proto_tree * tree ;\n va_list ap ;\n guint8 type ;\n guint32 ccAlias , idColumn ;\n const char * txt ;\n va_start ( ap , fmt ) ;\n txt = wmem_strdup_vprintf ( wmem_packet_scope ( ) , fmt , ap ) ;\n va_end ( ap ) ;\n tree = proto_tree_add_subtree ( parent_tree , tvb , offset , 0 , ett_CAggregSpec , & item , txt ) ;\n type = tvb_get_guint8 ( tvb , offset ) ;\n proto_tree_add_uint ( tree , hf_mswsp_caggregspec_type , tvb , offset , 1 , type ) ;\n proto_item_append_text ( item , \"type: %u\" , type ) ;\n offset += 1 ;\n offset = parse_padding ( tvb , offset , 4 , pad_tree , \"padding\" ) ;\n ccAlias = tvb_get_letohl ( tvb , offset ) ;\n proto_tree_add_uint ( tree , hf_mswsp_caggregspec_ccalias , tvb , offset , 1 , ccAlias ) ;\n offset += 4 ;\n proto_tree_add_item ( tree , hf_mswsp_caggregspec_alias , tvb , offset , 2 * ccAlias , ENC_LITTLE_ENDIAN | ENC_UCS_2 ) ;\n offset += 2 * ccAlias ;\n idColumn = tvb_get_letohl ( tvb , offset ) ;\n proto_tree_add_uint ( tree , hf_mswsp_caggregspec_idcolumn , tvb , offset , 1 , idColumn ) ;\n offset += 4 ;\n proto_item_set_end ( item , tvb , offset ) ;\n return offset ;\n }", "idx": 21579}
{"hash": 1535921111212871029, "project": "debian", "size": 33, "label": 0, "functionSource": "int remoteDispatchClientRequest ( struct qemud_server * server , struct qemud_client * client , struct qemud_client_message * msg ) {\n int ret ;\n remote_error rerr ;\n bool qemu_call ;\n VIR_DEBUG ( \"prog=%d ver=%d type=%d status=%d serial=%d proc=%d\" , msg -> hdr . prog , msg -> hdr . vers , msg -> hdr . type , msg -> hdr . status , msg -> hdr . serial , msg -> hdr . proc ) ;\n memset ( & rerr , 0 , sizeof rerr ) ;\n if ( msg -> hdr . prog == REMOTE_PROGRAM ) qemu_call = false ;\n else if ( msg -> hdr . prog == QEMU_PROGRAM ) qemu_call = true ;\n else {\n remoteDispatchFormatError ( & rerr , _ ( \"program mismatch (actual %x, expected %x or %x)\" ) , msg -> hdr . prog , REMOTE_PROGRAM , QEMU_PROGRAM ) ;\n goto error ;\n }\n if ( ! qemu_call && msg -> hdr . vers != REMOTE_PROTOCOL_VERSION ) {\n remoteDispatchFormatError ( & rerr , _ ( \"version mismatch (actual %x, expected %x)\" ) , msg -> hdr . vers , REMOTE_PROTOCOL_VERSION ) ;\n goto error ;\n }\n else if ( qemu_call && msg -> hdr . vers != QEMU_PROTOCOL_VERSION ) {\n remoteDispatchFormatError ( & rerr , _ ( \"version mismatch (actual %x, expected %x)\" ) , msg -> hdr . vers , QEMU_PROTOCOL_VERSION ) ;\n goto error ;\n }\n switch ( msg -> hdr . type ) {\n case REMOTE_CALL : return remoteDispatchClientCall ( server , client , msg , qemu_call ) ;\n case REMOTE_STREAM : VIR_INFO ( \"Ignoring unexpected stream data serial=%d proc=%d status=%d\" , msg -> hdr . serial , msg -> hdr . proc , msg -> hdr . status ) ;\n qemudClientMessageRelease ( client , msg ) ;\n break ;\n default : remoteDispatchFormatError ( & rerr , _ ( \"type (%d) != REMOTE_CALL\" ) , ( int ) msg -> hdr . type ) ;\n goto error ;\n }\n return 0 ;\n error : ret = remoteSerializeReplyError ( client , & rerr , & msg -> hdr ) ;\n if ( ret >= 0 ) VIR_FREE ( msg ) ;\n return ret ;\n }", "idx": 21580}
{"hash": 9176142195250515812, "project": "debian", "size": 5, "label": 0, "functionSource": "static void * prplcb_notify_email ( PurpleConnection * gc , const char * subject , const char * from , const char * to , const char * url ) {\n struct im_connection * ic = purple_ic_by_gc ( gc ) ;\n imcb_notify_email ( ic , \"Received e-mail from %s for %s: %s <%s>\" , from , to , subject , url ) ;\n return NULL ;\n }", "idx": 21581}
{"hash": -4960438251319819237, "project": "chrome", "size": 8, "label": 0, "functionSource": "static int find_fp_qindex ( vpx_bit_depth_t bit_depth ) {\n int i ;\n for ( i = 0 ;\n i < QINDEX_RANGE ;\n ++ i ) if ( vp9_convert_qindex_to_q ( i , bit_depth ) >= FIRST_PASS_Q ) break ;\n if ( i == QINDEX_RANGE ) i -- ;\n return i ;\n }", "idx": 21582}
{"hash": -8704283573519790151, "project": "debian", "size": 20, "label": 0, "functionSource": "int ber_flatten ( BerElement * ber , struct berval * * bvPtr ) {\n struct berval * bv ;\n int rc ;\n assert ( bvPtr != NULL ) ;\n if ( bvPtr == NULL ) {\n return - 1 ;\n }\n bv = ber_memalloc_x ( sizeof ( struct berval ) , ber -> ber_memctx ) ;\n if ( bv == NULL ) {\n return - 1 ;\n }\n rc = ber_flatten2 ( ber , bv , 1 ) ;\n if ( rc == - 1 ) {\n ber_memfree_x ( bv , ber -> ber_memctx ) ;\n }\n else {\n * bvPtr = bv ;\n }\n return rc ;\n }", "idx": 21583}
{"hash": -4433254577494420260, "project": "debian", "size": 4, "label": 0, "functionSource": "static void convert_to_rgb32 ( uint8_t * dst , const uint8_t * src , int width , int loco ) {\n if ( loco ) convert_to_rgb32_loco ( dst , src , width , 1 ) ;\n else convert_to_rgb32_loco ( dst , src , width , 0 ) ;\n }", "idx": 21584}
{"hash": -1283648210945038844, "project": "chrome", "size": 11, "label": 0, "functionSource": "void vp9_fdct8x8_1_c ( const int16_t * input , tran_low_t * output , int stride ) {\n int r , c ;\n tran_low_t sum = 0 ;\n for ( r = 0 ;\n r < 8 ;\n ++ r ) for ( c = 0 ;\n c < 8 ;\n ++ c ) sum += input [ r * stride + c ] ;\n output [ 0 ] = sum ;\n output [ 1 ] = 0 ;\n }", "idx": 21585}
{"hash": -7187272991279783781, "project": "debian", "size": 7, "label": 0, "functionSource": "static void cpu_kick_irq ( SPARCCPU * cpu ) {\n CPUSPARCState * env = & cpu -> env ;\n CPUState * cs = CPU ( cpu ) ;\n cs -> halted = 0 ;\n cpu_check_irqs ( env ) ;\n qemu_cpu_kick ( cs ) ;\n }", "idx": 21586}
{"hash": 6343276067273564310, "project": "debian", "size": 40, "label": 0, "functionSource": "static afs_int32 addToGroup ( struct rx_call * call , afs_int32 aid , afs_int32 gid , afs_int32 * cid ) {\n afs_int32 code ;\n struct ubik_trans * tt ;\n afs_int32 tempu ;\n afs_int32 tempg ;\n struct prentry tentry ;\n struct prentry uentry ;\n code = Initdb ( ) ;\n if ( code != PRSUCCESS ) return code ;\n if ( gid == ANYUSERID || gid == AUTHUSERID ) return PRPERM ;\n if ( aid == ANONYMOUSID ) return PRPERM ;\n code = ubik_BeginTrans ( dbase , UBIK_WRITETRANS , & tt ) ;\n if ( code ) return code ;\n code = ubik_SetLock ( tt , 1 , 1 , LOCKWRITE ) ;\n if ( code ) ABORT_WITH ( tt , code ) ;\n code = read_DbHeader ( tt ) ;\n if ( code ) ABORT_WITH ( tt , code ) ;\n code = WhoIsThis ( call , tt , cid ) ;\n if ( code ) ABORT_WITH ( tt , PRPERM ) ;\n tempu = FindByID ( tt , aid ) ;\n if ( ! tempu ) ABORT_WITH ( tt , PRNOENT ) ;\n memset ( & uentry , 0 , sizeof ( uentry ) ) ;\n code = pr_ReadEntry ( tt , 0 , tempu , & uentry ) ;\n if ( code != 0 ) ABORT_WITH ( tt , code ) ;\n # if ! defined ( SUPERGROUPS ) if ( uentry . flags & PRGRP ) ABORT_WITH ( tt , PRNOTUSER ) ;\n # endif tempg = FindByID ( tt , gid ) ;\n if ( ! tempg ) ABORT_WITH ( tt , PRNOENT ) ;\n code = pr_ReadEntry ( tt , 0 , tempg , & tentry ) ;\n if ( code != 0 ) ABORT_WITH ( tt , code ) ;\n if ( ! ( tentry . flags & PRGRP ) ) ABORT_WITH ( tt , PRNOTGROUP ) ;\n if ( ! AccessOK ( tt , * cid , & tentry , PRP_ADD_MEM , PRP_ADD_ANY ) ) ABORT_WITH ( tt , PRPERM ) ;\n code = AddToEntry ( tt , & tentry , tempg , aid ) ;\n if ( code != PRSUCCESS ) ABORT_WITH ( tt , code ) ;\n # if defined ( SUPERGROUPS ) if ( uentry . flags & PRGRP ) code = AddToSGEntry ( tt , & uentry , tempu , gid ) ;\n else # endif code = AddToEntry ( tt , & uentry , tempu , gid ) ;\n if ( code != PRSUCCESS ) ABORT_WITH ( tt , code ) ;\n code = ubik_EndTrans ( tt ) ;\n if ( code ) return code ;\n return PRSUCCESS ;\n }", "idx": 21587}
{"hash": 8461266595329035000, "project": "chrome", "size": 12, "label": 0, "functionSource": "void timeout_process ( struct event_base * base ) {\n struct timeval now ;\n struct event * ev ;\n if ( min_heap_empty ( & base -> timeheap ) ) return ;\n gettime ( base , & now ) ;\n while ( ( ev = min_heap_top ( & base -> timeheap ) ) ) {\n if ( evutil_timercmp ( & ev -> ev_timeout , & now , > ) ) break ;\n event_del ( ev ) ;\n event_debug ( ( \"timeout_process: call %p\" , ev -> ev_callback ) ) ;\n event_active ( ev , EV_TIMEOUT , 1 ) ;\n }\n }", "idx": 21588}
{"hash": -8884965407551053630, "project": "debian", "size": 10, "label": 0, "functionSource": "static void DecoderOutputChangePause ( decoder_t * p_dec , bool b_paused , mtime_t i_date ) {\n decoder_owner_sys_t * p_owner = p_dec -> p_owner ;\n vlc_assert_locked ( & p_owner -> lock ) ;\n if ( p_dec -> fmt_out . i_cat == AUDIO_ES ) {\n if ( p_owner -> p_aout ) aout_DecChangePause ( p_owner -> p_aout , b_paused , i_date ) ;\n }\n else if ( p_dec -> fmt_out . i_cat == VIDEO_ES ) {\n if ( p_owner -> p_vout ) vout_ChangePause ( p_owner -> p_vout , b_paused , i_date ) ;\n }\n }", "idx": 21589}
{"hash": -5082285935423529157, "project": "debian", "size": 20, "label": 0, "functionSource": "static int dissect_rsl_ie_multirate_conf ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , int offset , gboolean is_mandatory ) {\n proto_item * ti ;\n proto_tree * ie_tree ;\n guint length ;\n guint8 ie_id ;\n if ( is_mandatory == FALSE ) {\n ie_id = tvb_get_guint8 ( tvb , offset ) ;\n if ( ie_id != RSL_IE_MULTIRATE_CONF ) return offset ;\n }\n ie_tree = proto_tree_add_subtree ( tree , tvb , offset , 0 , ett_ie_multirate_conf , & ti , \"MultiRate configuration IE\" ) ;\n proto_tree_add_item ( ie_tree , hf_rsl_ie_id , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n offset ++ ;\n length = tvb_get_guint8 ( tvb , offset ) ;\n proto_item_set_len ( ti , length + 2 ) ;\n proto_tree_add_item ( ie_tree , hf_rsl_ie_length , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n offset ++ ;\n de_rr_multirate_conf ( tvb , ie_tree , pinfo , offset , length , NULL , 0 ) ;\n offset = offset + length ;\n return offset ;\n }", "idx": 21590}
{"hash": 3728341105073176576, "project": "debian", "size": 26, "label": 1, "functionSource": "static ossl_inline unsigned long lh_ ## type ## _num_items ( LHASH_OF ( type ) * lh ) {\n return OPENSSL_LH_num_items ( ( OPENSSL_LHASH * ) lh ) ;\n }\n static ossl_inline void lh_ ## type ## _node_stats_bio ( const LHASH_OF ( type ) * lh , BIO * out ) {\n OPENSSL_LH_node_stats_bio ( ( const OPENSSL_LHASH * ) lh , out ) ;\n }\n static ossl_inline void lh_ ## type ## _node_usage_stats_bio ( const LHASH_OF ( type ) * lh , BIO * out ) {\n OPENSSL_LH_node_usage_stats_bio ( ( const OPENSSL_LHASH * ) lh , out ) ;\n }\n static ossl_inline void lh_ ## type ## _stats_bio ( const LHASH_OF ( type ) * lh , BIO * out ) {\n OPENSSL_LH_stats_bio ( ( const OPENSSL_LHASH * ) lh , out ) ;\n }\n static ossl_inline unsigned long lh_ ## type ## _get_down_load ( LHASH_OF ( type ) * lh ) {\n return OPENSSL_LH_get_down_load ( ( OPENSSL_LHASH * ) lh ) ;\n }\n static ossl_inline void lh_ ## type ## _set_down_load ( LHASH_OF ( type ) * lh , unsigned long dl ) {\n OPENSSL_LH_set_down_load ( ( OPENSSL_LHASH * ) lh , dl ) ;\n }\n static ossl_inline void lh_ ## type ## _doall ( LHASH_OF ( type ) * lh , void ( * doall ) ( type * ) ) {\n OPENSSL_LH_doall ( ( OPENSSL_LHASH * ) lh , ( OPENSSL_LH_DOALL_FUNC ) doall ) ;\n }\n LHASH_OF ( type ) # define IMPLEMENT_LHASH_DOALL_ARG_CONST ( type , argtype ) int_implement_lhash_doall ( type , argtype , const type ) # define IMPLEMENT_LHASH_DOALL_ARG ( type , argtype ) int_implement_lhash_doall ( type , argtype , type ) # define int_implement_lhash_doall ( type , argtype , cbargtype ) static ossl_inline void lh_ ## type ## _doall_ ## argtype ( LHASH_OF ( type ) * lh , void ( * fn ) ( cbargtype * , argtype * ) , argtype * arg ) {\n OPENSSL_LH_doall_arg ( ( OPENSSL_LHASH * ) lh , ( OPENSSL_LH_DOALL_FUNCARG ) fn , ( void * ) arg ) ;\n }\n LHASH_OF ( type ) DEFINE_LHASH_OF ( OPENSSL_STRING ) ;\n # ifdef _MSC_VER # pragma warning ( push ) # pragma warning ( disable : 4090 ) # endif DEFINE_LHASH_OF ( OPENSSL_CSTRING )", "idx": 21591}
{"hash": 7039307292471244756, "project": "debian", "size": 10, "label": 0, "functionSource": "static void dtap_gcc_connect ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len ) {\n guint32 curr_offset ;\n guint32 consumed ;\n guint curr_len ;\n curr_offset = offset ;\n curr_len = len ;\n ELEM_MAND_V ( GSM_A_PDU_TYPE_DTAP , DE_GCC_CALL_REF , NULL ) ;\n proto_tree_add_bits_item ( tree , hf_gsm_a_spare_bits , tvb , curr_offset << 3 , 4 , ENC_NA ) ;\n ELEM_MAND_V ( GSM_A_PDU_TYPE_DTAP , DE_GCC_ORIG_IND , NULL ) ;\n }", "idx": 21592}
{"hash": -7131177824150194183, "project": "debian", "size": 11, "label": 0, "functionSource": "static inline int binkb_get_value ( BinkContext * c , int bundle_num ) {\n int16_t ret ;\n const int bits = binkb_bundle_sizes [ bundle_num ] ;\n if ( bits <= 8 ) {\n int val = * c -> bundle [ bundle_num ] . cur_ptr ++ ;\n return binkb_bundle_signed [ bundle_num ] ? ( int8_t ) val : val ;\n }\n ret = * ( int16_t * ) c -> bundle [ bundle_num ] . cur_ptr ;\n c -> bundle [ bundle_num ] . cur_ptr += 2 ;\n return ret ;\n }", "idx": 21593}
{"hash": -2423144171479606949, "project": "debian", "size": 4, "label": 0, "functionSource": "static void pdf_run_v ( fz_context * ctx , pdf_processor * proc , float x2 , float y2 , float x3 , float y3 ) {\n pdf_run_processor * pr = ( pdf_run_processor * ) proc ;\n fz_curvetov ( ctx , pr -> path , x2 , y2 , x3 , y3 ) ;\n }", "idx": 21594}
{"hash": 1896723564367514490, "project": "debian", "size": 11, "label": 0, "functionSource": "static VALUE ossl_cipher_set_iv ( VALUE self , VALUE iv ) {\n EVP_CIPHER_CTX * ctx ;\n int iv_len = 0 ;\n StringValue ( iv ) ;\n GetCipher ( self , ctx ) ;\n # if defined ( HAVE_AUTHENTICATED_ENCRYPTION ) if ( EVP_CIPHER_CTX_flags ( ctx ) & EVP_CIPH_FLAG_AEAD_CIPHER ) iv_len = ( int ) ( VALUE ) EVP_CIPHER_CTX_get_app_data ( ctx ) ;\n # endif if ( ! iv_len ) iv_len = EVP_CIPHER_CTX_iv_length ( ctx ) ;\n if ( RSTRING_LEN ( iv ) != iv_len ) ossl_raise ( rb_eArgError , \"iv must be %d bytes\" , iv_len ) ;\n if ( EVP_CipherInit_ex ( ctx , NULL , NULL , NULL , ( unsigned char * ) RSTRING_PTR ( iv ) , - 1 ) != 1 ) ossl_raise ( eCipherError , NULL ) ;\n return iv ;\n }", "idx": 21595}
{"hash": -8638406710431929037, "project": "debian", "size": 14, "label": 0, "functionSource": "static bfd_boolean srec_mkobject ( bfd * abfd ) {\n tdata_type * tdata ;\n srec_init ( ) ;\n tdata = ( tdata_type * ) bfd_alloc ( abfd , sizeof ( tdata_type ) ) ;\n if ( tdata == NULL ) return FALSE ;\n abfd -> tdata . srec_data = tdata ;\n tdata -> type = 1 ;\n tdata -> head = NULL ;\n tdata -> tail = NULL ;\n tdata -> symbols = NULL ;\n tdata -> symtail = NULL ;\n tdata -> csymbols = NULL ;\n return TRUE ;\n }", "idx": 21596}
{"hash": -1929262071302712016, "project": "debian", "size": 48, "label": 0, "functionSource": "static cmsBool WriteSegmentedCurve ( cmsIOHANDLER * io , cmsToneCurve * g ) {\n cmsUInt32Number i , j ;\n cmsCurveSegment * Segments = g -> Segments ;\n cmsUInt32Number nSegments = g -> nSegments ;\n if ( ! _cmsWriteUInt32Number ( io , cmsSigSegmentedCurve ) ) goto Error ;\n if ( ! _cmsWriteUInt32Number ( io , 0 ) ) goto Error ;\n if ( ! _cmsWriteUInt16Number ( io , ( cmsUInt16Number ) nSegments ) ) goto Error ;\n if ( ! _cmsWriteUInt16Number ( io , 0 ) ) goto Error ;\n for ( i = 0 ;\n i < nSegments - 1 ;\n i ++ ) {\n if ( ! _cmsWriteFloat32Number ( io , Segments [ i ] . x1 ) ) goto Error ;\n }\n for ( i = 0 ;\n i < g -> nSegments ;\n i ++ ) {\n cmsCurveSegment * ActualSeg = Segments + i ;\n if ( ActualSeg -> Type == 0 ) {\n if ( ! _cmsWriteUInt32Number ( io , ( cmsUInt32Number ) cmsSigSampledCurveSeg ) ) goto Error ;\n if ( ! _cmsWriteUInt32Number ( io , 0 ) ) goto Error ;\n if ( ! _cmsWriteUInt32Number ( io , ActualSeg -> nGridPoints ) ) goto Error ;\n for ( j = 0 ;\n j < g -> Segments [ i ] . nGridPoints ;\n j ++ ) {\n if ( ! _cmsWriteFloat32Number ( io , ActualSeg -> SampledPoints [ j ] ) ) goto Error ;\n }\n }\n else {\n int Type ;\n cmsUInt32Number ParamsByType [ ] = {\n 4 , 5 , 5 }\n ;\n if ( ! _cmsWriteUInt32Number ( io , ( cmsUInt32Number ) cmsSigFormulaCurveSeg ) ) goto Error ;\n if ( ! _cmsWriteUInt32Number ( io , 0 ) ) goto Error ;\n Type = ActualSeg -> Type - 6 ;\n if ( Type > 2 || Type < 0 ) goto Error ;\n if ( ! _cmsWriteUInt16Number ( io , ( cmsUInt16Number ) Type ) ) goto Error ;\n if ( ! _cmsWriteUInt16Number ( io , 0 ) ) goto Error ;\n for ( j = 0 ;\n j < ParamsByType [ Type ] ;\n j ++ ) {\n if ( ! _cmsWriteFloat32Number ( io , ( cmsFloat32Number ) ActualSeg -> Params [ j ] ) ) goto Error ;\n }\n }\n }\n return TRUE ;\n Error : return FALSE ;\n }", "idx": 21597}
{"hash": -3053641395158209010, "project": "debian", "size": 11, "label": 0, "functionSource": "static int x ( struct vcache * avc , int afun , struct vrequest * areq , \\ struct afs_pdata * ain , struct afs_pdata * aout , \\ afs_ucred_t * * acred ) DECL_PIOCTL ( PGetFID ) ;\n DECL_PIOCTL ( PSetAcl ) ;\n DECL_PIOCTL ( PStoreBehind ) ;\n DECL_PIOCTL ( PGCPAGs ) ;\n DECL_PIOCTL ( PGetAcl ) ;\n DECL_PIOCTL ( PNoop ) ;\n DECL_PIOCTL ( PBogus ) ;\n DECL_PIOCTL ( PGetFileCell ) ;\n DECL_PIOCTL ( PGetWSCell ) ;\n DECL_PIOCTL ( PGetUserCell ) ;\n DECL_PIOCTL ( PSetTokens )", "idx": 21598}
{"hash": -866921002076081979, "project": "debian", "size": 59, "label": 0, "functionSource": "REGRESSION_TEST ( SDK_API_TSMgmtGet ) ( RegressionTest * test , int , int * pstatus ) {\n const char * CONFIG_PARAM_COUNTER_NAME = \"proxy.process.ssl.total_tickets_renewed\" ;\n int CONFIG_PARAM_COUNTER_VALUE = 0 ;\n const char * CONFIG_PARAM_FLOAT_NAME = \"proxy.config.http.background_fill_completed_threshold\" ;\n float CONFIG_PARAM_FLOAT_VALUE = 0.0 ;\n const char * CONFIG_PARAM_INT_NAME = \"proxy.config.http.cache.http\" ;\n int CONFIG_PARAM_INT_VALUE = 1 ;\n const char * CONFIG_PARAM_STRING_NAME = \"proxy.config.product_name\" ;\n const char * CONFIG_PARAM_STRING_VALUE = \"Traffic Server\" ;\n * pstatus = REGRESSION_TEST_INPROGRESS ;\n int err = 0 ;\n TSMgmtCounter cvalue = 0 ;\n TSMgmtFloat fvalue = 0.0 ;\n TSMgmtInt ivalue = - 1 ;\n TSMgmtString svalue = nullptr ;\n if ( TS_SUCCESS != TSMgmtCounterGet ( CONFIG_PARAM_COUNTER_NAME , & cvalue ) ) {\n SDK_RPRINT ( test , \"TSMgmtCounterGet\" , \"TestCase1.1\" , TC_FAIL , \"can not get value of param %s\" , CONFIG_PARAM_COUNTER_NAME ) ;\n err = 1 ;\n }\n else if ( cvalue != CONFIG_PARAM_COUNTER_VALUE ) {\n SDK_RPRINT ( test , \"TSMgmtCounterGet\" , \"TestCase1.1\" , TC_FAIL , \"got incorrect value of param %s, should have been %d, found %d\" , CONFIG_PARAM_COUNTER_NAME , CONFIG_PARAM_COUNTER_VALUE , cvalue ) ;\n err = 1 ;\n }\n else {\n SDK_RPRINT ( test , \"TSMgmtCounterGet\" , \"TestCase1.1\" , TC_PASS , \"ok\" ) ;\n }\n if ( ( TS_SUCCESS != TSMgmtFloatGet ( CONFIG_PARAM_FLOAT_NAME , & fvalue ) ) || ( fvalue != CONFIG_PARAM_FLOAT_VALUE ) ) {\n SDK_RPRINT ( test , \"TSMgmtFloatGet\" , \"TestCase2\" , TC_FAIL , \"can not get value of param %s\" , CONFIG_PARAM_FLOAT_NAME ) ;\n err = 1 ;\n }\n else {\n SDK_RPRINT ( test , \"TSMgmtFloatGet\" , \"TestCase1.2\" , TC_PASS , \"ok\" ) ;\n }\n if ( ( TSMgmtIntGet ( CONFIG_PARAM_INT_NAME , & ivalue ) != TS_SUCCESS ) || ( ivalue != CONFIG_PARAM_INT_VALUE ) ) {\n SDK_RPRINT ( test , \"TSMgmtIntGet\" , \"TestCase1.3\" , TC_FAIL , \"can not get value of param %s\" , CONFIG_PARAM_INT_NAME ) ;\n err = 1 ;\n }\n else {\n SDK_RPRINT ( test , \"TSMgmtIntGet\" , \"TestCase1.3\" , TC_PASS , \"ok\" ) ;\n }\n if ( TS_SUCCESS != TSMgmtStringGet ( CONFIG_PARAM_STRING_NAME , & svalue ) ) {\n SDK_RPRINT ( test , \"TSMgmtStringGet\" , \"TestCase1.4\" , TC_FAIL , \"can not get value of param %s\" , CONFIG_PARAM_STRING_NAME ) ;\n err = 1 ;\n }\n else if ( strcmp ( svalue , CONFIG_PARAM_STRING_VALUE ) != 0 ) {\n SDK_RPRINT ( test , \"TSMgmtStringGet\" , \"TestCase1.4\" , TC_FAIL , R \"(got incorrect value of param %s, should have been \" % s \", found \" % s \")\" , CONFIG_PARAM_STRING_NAME , CONFIG_PARAM_STRING_VALUE , svalue ) ;\n err = 1 ;\n }\n else {\n SDK_RPRINT ( test , \"TSMgmtStringGet\" , \"TestCase1.4\" , TC_PASS , \"ok\" ) ;\n }\n if ( err ) {\n * pstatus = REGRESSION_TEST_FAILED ;\n return ;\n }\n * pstatus = REGRESSION_TEST_PASSED ;\n SDK_RPRINT ( test , \"TSMgmtGet\" , \"TestCase1\" , TC_PASS , \"ok\" ) ;\n return ;\n }", "idx": 21599}
{"hash": 3919646340804521652, "project": "debian", "size": 24, "label": 0, "functionSource": "static off_t write_reused_pack ( struct sha1file * f ) {\n unsigned char buffer [ 8192 ] ;\n off_t to_write , total ;\n int fd ;\n if ( ! is_pack_valid ( reuse_packfile ) ) die ( \"packfile is invalid: %s\" , reuse_packfile -> pack_name ) ;\n fd = git_open_noatime ( reuse_packfile -> pack_name ) ;\n if ( fd < 0 ) die_errno ( \"unable to open packfile for reuse: %s\" , reuse_packfile -> pack_name ) ;\n if ( lseek ( fd , sizeof ( struct pack_header ) , SEEK_SET ) == - 1 ) die_errno ( \"unable to seek in reused packfile\" ) ;\n if ( reuse_packfile_offset < 0 ) reuse_packfile_offset = reuse_packfile -> pack_size - 20 ;\n total = to_write = reuse_packfile_offset - sizeof ( struct pack_header ) ;\n while ( to_write ) {\n int read_pack = xread ( fd , buffer , sizeof ( buffer ) ) ;\n if ( read_pack <= 0 ) die_errno ( \"unable to read from reused packfile\" ) ;\n if ( read_pack > to_write ) read_pack = to_write ;\n sha1write ( f , buffer , read_pack ) ;\n to_write -= read_pack ;\n written = reuse_packfile_objects * ( ( ( double ) ( total - to_write ) ) / total ) ;\n display_progress ( progress_state , written ) ;\n }\n close ( fd ) ;\n written = reuse_packfile_objects ;\n display_progress ( progress_state , written ) ;\n return reuse_packfile_offset - sizeof ( struct pack_header ) ;\n }", "idx": 21600}
{"hash": -7553540414561818627, "project": "debian", "size": 7, "label": 0, "functionSource": "int rand_neg ( void ) {\n static unsigned int neg = 0 ;\n static int sign [ 8 ] = {\n 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 }\n ;\n return ( sign [ ( neg ++ ) % 8 ] ) ;\n }", "idx": 21601}
{"hash": 7039307292471244756, "project": "debian", "size": 10, "label": 0, "functionSource": "static void dtap_sms_cp_error ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len ) {\n guint32 curr_offset ;\n guint32 consumed ;\n guint curr_len ;\n curr_offset = offset ;\n curr_len = len ;\n is_uplink = IS_UPLINK_TRUE ;\n ELEM_MAND_V ( GSM_A_PDU_TYPE_DTAP , DE_CP_CAUSE , NULL ) ;\n EXTRANEOUS_DATA_CHECK ( curr_len , 0 , pinfo , & ei_gsm_a_dtap_extraneous_data ) ;\n }", "idx": 21602}
{"hash": -2607754285145856562, "project": "debian", "size": 40, "label": 0, "functionSource": "static int set_file_identifier ( unsigned char * bp , int from , int to , enum vdc vdc , struct archive_write * a , struct vdd * vdd , struct archive_string * id , const char * label , int leading_under , enum char_type char_type ) {\n char identifier [ 256 ] ;\n struct isoent * isoent ;\n const char * ids ;\n size_t len ;\n int r ;\n if ( id -> length > 0 && leading_under && id -> s [ 0 ] != '_' ) {\n if ( char_type == A_CHAR ) r = set_str_a_characters_bp ( a , bp , from , to , id -> s , vdc ) ;\n else r = set_str_d_characters_bp ( a , bp , from , to , id -> s , vdc ) ;\n }\n else if ( id -> length > 0 ) {\n ids = id -> s ;\n if ( leading_under ) ids ++ ;\n isoent = isoent_find_entry ( vdd -> rootent , ids ) ;\n if ( isoent == NULL ) {\n archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , \"Not Found %s `%s'.\" , label , ids ) ;\n return ( ARCHIVE_FATAL ) ;\n }\n len = isoent -> ext_off + isoent -> ext_len ;\n if ( vdd -> vdd_type == VDD_JOLIET ) {\n if ( len > sizeof ( identifier ) - 2 ) len = sizeof ( identifier ) - 2 ;\n }\n else {\n if ( len > sizeof ( identifier ) - 1 ) len = sizeof ( identifier ) - 1 ;\n }\n memcpy ( identifier , isoent -> identifier , len ) ;\n identifier [ len ] = '\\0' ;\n if ( vdd -> vdd_type == VDD_JOLIET ) {\n identifier [ len + 1 ] = 0 ;\n vdc = VDC_UCS2_DIRECT ;\n }\n if ( char_type == A_CHAR ) r = set_str_a_characters_bp ( a , bp , from , to , identifier , vdc ) ;\n else r = set_str_d_characters_bp ( a , bp , from , to , identifier , vdc ) ;\n }\n else {\n if ( char_type == A_CHAR ) r = set_str_a_characters_bp ( a , bp , from , to , NULL , vdc ) ;\n else r = set_str_d_characters_bp ( a , bp , from , to , NULL , vdc ) ;\n }\n return ( r ) ;\n }", "idx": 21603}
{"hash": -6529313662352494663, "project": "debian", "size": 87, "label": 0, "functionSource": "int gdev_x_put_params ( gx_device * dev , gs_param_list * plist ) {\n gx_device_X * xdev = ( gx_device_X * ) dev ;\n gx_device_X values ;\n int orig_MaxBitmap = xdev -> space_params . MaxBitmap ;\n long pwin = ( long ) xdev -> pwin ;\n bool save_is_page = xdev -> IsPageDevice ;\n int ecode = 0 , code ;\n bool clear_window = false ;\n values = * xdev ;\n ecode = param_put_long ( plist , \"WindowID\" , & pwin , ecode ) ;\n ecode = param_put_bool ( plist , \".IsPageDevice\" , & values . IsPageDevice , ecode ) ;\n ecode = param_put_int ( plist , \"MaxTempPixmap\" , & values . MaxTempPixmap , ecode ) ;\n ecode = param_put_int ( plist , \"MaxTempImage\" , & values . MaxTempImage , ecode ) ;\n if ( ecode < 0 ) return ecode ;\n if ( pwin == ( long ) xdev -> pwin ) dev -> is_open = false ;\n xdev -> IsPageDevice = values . IsPageDevice ;\n code = gx_default_put_params ( dev , plist ) ;\n dev -> is_open = values . is_open ;\n if ( code < 0 ) {\n xdev -> IsPageDevice = save_is_page ;\n return code ;\n }\n if ( pwin != ( long ) xdev -> pwin ) {\n if ( xdev -> is_open ) gs_closedevice ( dev ) ;\n xdev -> pwin = ( Window ) pwin ;\n }\n if ( xdev -> is_open && xdev -> ghostview ) {\n dev -> width = values . width ;\n dev -> height = values . height ;\n dev -> x_pixels_per_inch = values . x_pixels_per_inch ;\n dev -> y_pixels_per_inch = values . y_pixels_per_inch ;\n dev -> HWResolution [ 0 ] = values . HWResolution [ 0 ] ;\n dev -> HWResolution [ 1 ] = values . HWResolution [ 1 ] ;\n dev -> MediaSize [ 0 ] = values . MediaSize [ 0 ] ;\n dev -> MediaSize [ 1 ] = values . MediaSize [ 1 ] ;\n }\n if ( xdev -> is_open && ! xdev -> ghostview && ( dev -> width != values . width || dev -> height != values . height || dev -> HWResolution [ 0 ] != values . HWResolution [ 0 ] || dev -> HWResolution [ 1 ] != values . HWResolution [ 1 ] ) ) {\n int area_width = WidthOfScreen ( xdev -> scr ) , area_height = HeightOfScreen ( xdev -> scr ) ;\n int dw , dh ;\n x_get_work_area ( xdev , & area_width , & area_height ) ;\n dev -> x_pixels_per_inch = values . x_pixels_per_inch ;\n dev -> y_pixels_per_inch = values . y_pixels_per_inch ;\n dev -> HWResolution [ 0 ] = values . HWResolution [ 0 ] ;\n dev -> HWResolution [ 1 ] = values . HWResolution [ 1 ] ;\n dev -> width = min ( dev -> width , area_width ) ;\n dev -> height = min ( dev -> height , area_height ) ;\n if ( dev -> width <= 0 || dev -> height <= 0 ) {\n emprintf3 ( dev -> memory , \"Requested pagesize %d x %d not supported by %s device\\n\" , dev -> width , dev -> height , dev -> dname ) ;\n return_error ( gs_error_rangecheck ) ;\n }\n dev -> MediaSize [ 0 ] = ( float ) dev -> width / xdev -> x_pixels_per_inch * 72 ;\n dev -> MediaSize [ 1 ] = ( float ) dev -> height / xdev -> y_pixels_per_inch * 72 ;\n dw = dev -> width - values . width ;\n dh = dev -> height - values . height ;\n if ( dw || dh ) {\n XResizeWindow ( xdev -> dpy , xdev -> win , dev -> width , dev -> height ) ;\n if ( xdev -> bpixmap != ( Pixmap ) 0 ) {\n XFreePixmap ( xdev -> dpy , xdev -> bpixmap ) ;\n xdev -> bpixmap = ( Pixmap ) 0 ;\n }\n xdev -> dest = 0 ;\n clear_window = true ;\n }\n if ( xdev -> initial_matrix . xy == 0 ) {\n if ( xdev -> initial_matrix . xx < 0 ) {\n xdev -> initial_matrix . tx += dw ;\n }\n else {\n xdev -> initial_matrix . ty += dh ;\n }\n }\n else {\n if ( xdev -> initial_matrix . xy < 0 ) {\n xdev -> initial_matrix . tx += dh ;\n xdev -> initial_matrix . ty += dw ;\n }\n else {\n }\n }\n }\n xdev -> MaxTempPixmap = values . MaxTempPixmap ;\n xdev -> MaxTempImage = values . MaxTempImage ;\n if ( clear_window || xdev -> space_params . MaxBitmap != orig_MaxBitmap ) {\n if ( xdev -> is_open ) gdev_x_clear_window ( xdev ) ;\n }\n return 0 ;\n }", "idx": 21604}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_EncryptionAuthenticationAndIntegrity ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_EncryptionAuthenticationAndIntegrity , EncryptionAuthenticationAndIntegrity_sequence ) ;\n return offset ;\n }", "idx": 21605}
{"hash": -1929262071302712016, "project": "debian", "size": 42, "label": 0, "functionSource": "static void * Type_LUTA2B_Read ( struct _cms_typehandler_struct * self , cmsIOHANDLER * io , cmsUInt32Number * nItems , cmsUInt32Number SizeOfTag ) {\n cmsUInt32Number BaseOffset ;\n cmsUInt8Number inputChan ;\n cmsUInt8Number outputChan ;\n cmsUInt32Number offsetB ;\n cmsUInt32Number offsetMat ;\n cmsUInt32Number offsetM ;\n cmsUInt32Number offsetC ;\n cmsUInt32Number offsetA ;\n cmsPipeline * NewLUT = NULL ;\n BaseOffset = io -> Tell ( io ) - sizeof ( _cmsTagBase ) ;\n if ( ! _cmsReadUInt8Number ( io , & inputChan ) ) return NULL ;\n if ( ! _cmsReadUInt8Number ( io , & outputChan ) ) return NULL ;\n if ( ! _cmsReadUInt16Number ( io , NULL ) ) return NULL ;\n if ( ! _cmsReadUInt32Number ( io , & offsetB ) ) return NULL ;\n if ( ! _cmsReadUInt32Number ( io , & offsetMat ) ) return NULL ;\n if ( ! _cmsReadUInt32Number ( io , & offsetM ) ) return NULL ;\n if ( ! _cmsReadUInt32Number ( io , & offsetC ) ) return NULL ;\n if ( ! _cmsReadUInt32Number ( io , & offsetA ) ) return NULL ;\n NewLUT = cmsPipelineAlloc ( self -> ContextID , inputChan , outputChan ) ;\n if ( NewLUT == NULL ) return NULL ;\n if ( offsetA != 0 ) {\n if ( ! cmsPipelineInsertStage ( NewLUT , cmsAT_END , ReadSetOfCurves ( self , io , BaseOffset + offsetA , inputChan ) ) ) goto Error ;\n }\n if ( offsetC != 0 ) {\n if ( ! cmsPipelineInsertStage ( NewLUT , cmsAT_END , ReadCLUT ( self , io , BaseOffset + offsetC , inputChan , outputChan ) ) ) goto Error ;\n }\n if ( offsetM != 0 ) {\n if ( ! cmsPipelineInsertStage ( NewLUT , cmsAT_END , ReadSetOfCurves ( self , io , BaseOffset + offsetM , outputChan ) ) ) goto Error ;\n }\n if ( offsetMat != 0 ) {\n if ( ! cmsPipelineInsertStage ( NewLUT , cmsAT_END , ReadMatrix ( self , io , BaseOffset + offsetMat ) ) ) goto Error ;\n }\n if ( offsetB != 0 ) {\n if ( ! cmsPipelineInsertStage ( NewLUT , cmsAT_END , ReadSetOfCurves ( self , io , BaseOffset + offsetB , outputChan ) ) ) goto Error ;\n }\n * nItems = 1 ;\n return NewLUT ;\n Error : cmsPipelineFree ( NewLUT ) ;\n return NULL ;\n cmsUNUSED_PARAMETER ( SizeOfTag ) ;\n }", "idx": 21606}
{"hash": 7039307292471244756, "project": "debian", "size": 9, "label": 0, "functionSource": "static void dtap_tp_test_interface ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len ) {\n guint32 curr_offset ;\n guint32 consumed ;\n guint curr_len ;\n curr_len = len ;\n curr_offset = offset ;\n ELEM_MAND_V ( GSM_A_PDU_TYPE_DTAP , DE_TP_TESTED_DEVICE , NULL ) ;\n EXTRANEOUS_DATA_CHECK ( curr_len , 0 , pinfo , & ei_gsm_a_dtap_extraneous_data ) ;\n }", "idx": 21607}
{"hash": -398565394354770780, "project": "debian", "size": 8, "label": 0, "functionSource": "static void ohci_port_power ( OHCIState * ohci , int i , int p ) {\n if ( p ) {\n ohci -> rhport [ i ] . ctrl |= OHCI_PORT_PPS ;\n }\n else {\n ohci -> rhport [ i ] . ctrl &= ~ ( OHCI_PORT_PPS | OHCI_PORT_CCS | OHCI_PORT_PSS | OHCI_PORT_PRS ) ;\n }\n }", "idx": 21608}
{"hash": 7909110399479437032, "project": "chrome", "size": 5, "label": 0, "functionSource": "void hb_set_destroy ( hb_set_t * set ) {\n if ( ! hb_object_destroy ( set ) ) return ;\n set -> fini ( ) ;\n free ( set ) ;\n }", "idx": 21609}
{"hash": 1245821301839614810, "project": "debian", "size": 33, "label": 0, "functionSource": "static gboolean do_run_simple_dialog ( gpointer _data ) {\n RunSimpleDialogData * data = _data ;\n const char * button_title ;\n GtkWidget * dialog ;\n int result ;\n int response_id ;\n g_mutex_lock ( & data -> mutex ) ;\n dialog = gtk_message_dialog_new ( * data -> parent_window , 0 , data -> message_type , GTK_BUTTONS_NONE , NULL ) ;\n g_object_set ( dialog , \"text\" , data -> primary_text , \"secondary-text\" , data -> secondary_text , NULL ) ;\n for ( response_id = 0 ;\n data -> button_titles [ response_id ] != NULL ;\n response_id ++ ) {\n button_title = data -> button_titles [ response_id ] ;\n if ( ! data -> show_all && is_all_button_text ( button_title ) ) {\n continue ;\n }\n gtk_dialog_add_button ( GTK_DIALOG ( dialog ) , button_title , response_id ) ;\n gtk_dialog_set_default_response ( GTK_DIALOG ( dialog ) , response_id ) ;\n }\n if ( data -> details_text ) {\n eel_gtk_message_dialog_set_details_label ( GTK_MESSAGE_DIALOG ( dialog ) , data -> details_text ) ;\n }\n result = gtk_dialog_run ( GTK_DIALOG ( dialog ) ) ;\n while ( ( result == GTK_RESPONSE_NONE || result == GTK_RESPONSE_DELETE_EVENT ) && data -> ignore_close_box ) {\n result = gtk_dialog_run ( GTK_DIALOG ( dialog ) ) ;\n }\n gtk_widget_destroy ( dialog ) ;\n data -> result = result ;\n data -> completed = TRUE ;\n g_cond_signal ( & data -> cond ) ;\n g_mutex_unlock ( & data -> mutex ) ;\n return FALSE ;\n }", "idx": 21610}
{"hash": -5268859819325807498, "project": "debian", "size": 22, "label": 0, "functionSource": "static void enumerate_children_callback ( GObject * source_object , GAsyncResult * res , gpointer user_data ) {\n DirectoryLoadState * state ;\n GFileEnumerator * enumerator ;\n GError * error ;\n state = user_data ;\n if ( state -> directory == NULL ) {\n directory_load_state_free ( state ) ;\n return ;\n }\n error = NULL ;\n enumerator = g_file_enumerate_children_finish ( G_FILE ( source_object ) , res , & error ) ;\n if ( enumerator == NULL ) {\n directory_load_done ( state -> directory , error ) ;\n g_error_free ( error ) ;\n directory_load_state_free ( state ) ;\n return ;\n }\n else {\n state -> enumerator = enumerator ;\n g_file_enumerator_next_files_async ( state -> enumerator , DIRECTORY_LOAD_ITEMS_PER_CALLBACK , G_PRIORITY_DEFAULT , state -> cancellable , more_files_callback , state ) ;\n }\n }", "idx": 21611}
{"hash": -1929262071302712016, "project": "debian", "size": 5, "label": 0, "functionSource": "static void Type_MPE_Free ( struct _cms_typehandler_struct * self , void * Ptr ) {\n cmsPipelineFree ( ( cmsPipeline * ) Ptr ) ;\n return ;\n cmsUNUSED_PARAMETER ( self ) ;\n }", "idx": 21612}
{"hash": -2915908172644760936, "project": "debian", "size": 11, "label": 0, "functionSource": "static void flush ( AVCodecContext * avctx ) {\n WmallDecodeCtx * s = avctx -> priv_data ;\n s -> packet_loss = 1 ;\n s -> packet_done = 0 ;\n s -> num_saved_bits = 0 ;\n s -> frame_offset = 0 ;\n s -> next_packet_start = 0 ;\n s -> cdlms [ 0 ] [ 0 ] . order = 0 ;\n s -> frame . nb_samples = 0 ;\n init_put_bits ( & s -> pb , s -> frame_data , MAX_FRAMESIZE ) ;\n }", "idx": 21613}
{"hash": 7039307292471244756, "project": "debian", "size": 19, "label": 0, "functionSource": "static void dtap_cc_congestion_control ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len ) {\n guint32 curr_offset ;\n guint32 consumed ;\n guint curr_len ;\n guint8 oct ;\n proto_tree * subtree ;\n curr_offset = offset ;\n curr_len = len ;\n is_uplink = IS_UPLINK_FALSE ;\n oct = tvb_get_guint8 ( tvb , curr_offset ) ;\n proto_tree_add_bits_item ( tree , hf_gsm_a_spare_bits , tvb , curr_offset << 3 , 4 , ENC_BIG_ENDIAN ) ;\n subtree = proto_tree_add_subtree ( tree , tvb , curr_offset , 1 , ett_gsm_dtap_elem [ DE_CONGESTION ] , NULL , val_to_str_ext_const ( DE_CONGESTION , & gsm_dtap_elem_strings_ext , \"\" ) ) ;\n proto_tree_add_uint_format_value ( subtree , hf_gsm_a_dtap_congestion_level , tvb , curr_offset , 1 , oct , \"%s\" , val_to_str_const ( oct & 0xF , gsm_a_dtap_congestion_level_vals , \"Reserved\" ) ) ;\n curr_offset ++ ;\n curr_len -- ;\n if ( ( signed ) curr_len <= 0 ) return ;\n ELEM_OPT_TLV ( 0x08 , GSM_A_PDU_TYPE_DTAP , DE_CAUSE , NULL ) ;\n EXTRANEOUS_DATA_CHECK ( curr_len , 0 , pinfo , & ei_gsm_a_dtap_extraneous_data ) ;\n }", "idx": 21614}
{"hash": 8461266595329035000, "project": "chrome", "size": 20, "label": 0, "functionSource": "void event_queue_insert ( struct event_base * base , struct event * ev , int queue ) {\n if ( ev -> ev_flags & queue ) {\n if ( queue & EVLIST_ACTIVE ) return ;\n event_errx ( 1 , \"%s: %p(fd %d) already on queue %x\" , __func__ , ev , ev -> ev_fd , queue ) ;\n }\n if ( ~ ev -> ev_flags & EVLIST_INTERNAL ) base -> event_count ++ ;\n ev -> ev_flags |= queue ;\n switch ( queue ) {\n case EVLIST_INSERTED : TAILQ_INSERT_TAIL ( & base -> eventqueue , ev , ev_next ) ;\n break ;\n case EVLIST_ACTIVE : base -> event_count_active ++ ;\n TAILQ_INSERT_TAIL ( base -> activequeues [ ev -> ev_pri ] , ev , ev_active_next ) ;\n break ;\n case EVLIST_TIMEOUT : {\n min_heap_push ( & base -> timeheap , ev ) ;\n break ;\n }\n default : event_errx ( 1 , \"%s: unknown queue %x\" , __func__ , queue ) ;\n }\n }", "idx": 21615}
{"hash": -4558261210024070448, "project": "chrome", "size": 13, "label": 0, "functionSource": "int xmlListCopy ( xmlListPtr cur , const xmlListPtr old ) {\n xmlLinkPtr lk ;\n if ( ( old == NULL ) || ( cur == NULL ) ) return ( 1 ) ;\n for ( lk = old -> sentinel -> next ;\n lk != old -> sentinel ;\n lk = lk -> next ) {\n if ( 0 != xmlListInsert ( cur , lk -> data ) ) {\n xmlListDelete ( cur ) ;\n return ( 1 ) ;\n }\n }\n return ( 0 ) ;\n }", "idx": 21616}
{"hash": -3569070884878445567, "project": "debian", "size": 11, "label": 0, "functionSource": "static void free_picture ( AVCodecContext * avctx , Picture * pic ) {\n int i ;\n for ( i = 0 ;\n i < 2 ;\n i ++ ) {\n av_buffer_unref ( & pic -> motion_val_buf [ i ] ) ;\n av_buffer_unref ( & pic -> ref_index_buf [ i ] ) ;\n }\n av_buffer_unref ( & pic -> mb_type_buf ) ;\n av_frame_unref ( & pic -> f ) ;\n }", "idx": 21617}
{"hash": 5611940141018433728, "project": "chrome", "size": 19, "label": 0, "functionSource": "void vp9_pack_bitstream ( VP9_COMP * cpi , uint8_t * dest , size_t * size ) {\n uint8_t * data = dest ;\n size_t first_part_size , uncompressed_hdr_size ;\n struct vp9_write_bit_buffer wb = {\n data , 0 }\n ;\n struct vp9_write_bit_buffer saved_wb ;\n write_uncompressed_header ( cpi , & wb ) ;\n saved_wb = wb ;\n vp9_wb_write_literal ( & wb , 0 , 16 ) ;\n uncompressed_hdr_size = vp9_wb_bytes_written ( & wb ) ;\n data += uncompressed_hdr_size ;\n vp9_clear_system_state ( ) ;\n first_part_size = write_compressed_header ( cpi , data ) ;\n data += first_part_size ;\n vp9_wb_write_literal ( & saved_wb , ( int ) first_part_size , 16 ) ;\n data += encode_tiles ( cpi , data ) ;\n * size = data - dest ;\n }", "idx": 21618}
{"hash": -3889154245145551951, "project": "debian", "size": 5, "label": 0, "functionSource": "static int tecmp0 ( const void * _a , const void * _b ) {\n struct tree_entry * a = * ( ( struct tree_entry * * ) _a ) ;\n struct tree_entry * b = * ( ( struct tree_entry * * ) _b ) ;\n return base_name_compare ( a -> name -> str_dat , a -> name -> str_len , a -> versions [ 0 ] . mode , b -> name -> str_dat , b -> name -> str_len , b -> versions [ 0 ] . mode ) ;\n }", "idx": 21619}
{"hash": -8721757784652752372, "project": "debian", "size": 15, "label": 0, "functionSource": "void jpc_enc_destroy ( jpc_enc_t * enc ) {\n if ( enc -> curtile ) {\n jpc_enc_tile_destroy ( enc -> curtile ) ;\n }\n if ( enc -> cp ) {\n jpc_enc_cp_destroy ( enc -> cp ) ;\n }\n if ( enc -> cstate ) {\n jpc_cstate_destroy ( enc -> cstate ) ;\n }\n if ( enc -> tmpstream ) {\n jas_stream_close ( enc -> tmpstream ) ;\n }\n jas_free ( enc ) ;\n }", "idx": 21620}
{"hash": -4844249011537705593, "project": "chrome", "size": 13, "label": 0, "functionSource": "static float sbr_sum_square_c ( float ( * x ) [ 2 ] , int n ) {\n float sum0 = 0.0f , sum1 = 0.0f ;\n int i ;\n for ( i = 0 ;\n i < n ;\n i += 2 ) {\n sum0 += x [ i + 0 ] [ 0 ] * x [ i + 0 ] [ 0 ] ;\n sum1 += x [ i + 0 ] [ 1 ] * x [ i + 0 ] [ 1 ] ;\n sum0 += x [ i + 1 ] [ 0 ] * x [ i + 1 ] [ 0 ] ;\n sum1 += x [ i + 1 ] [ 1 ] * x [ i + 1 ] [ 1 ] ;\n }\n return sum0 + sum1 ;\n }", "idx": 21621}
{"hash": -1487877838474751244, "project": "debian", "size": 21, "label": 0, "functionSource": "static int getStrrtokenPos ( char * str , int savedPos ) {\n int result = - 1 ;\n int i ;\n for ( i = savedPos - 1 ;\n i >= 0 ;\n i -- ) {\n if ( isIDSeparator ( * ( str + i ) ) ) {\n if ( i >= 2 && isIDSeparator ( * ( str + i - 2 ) ) ) {\n result = i - 2 ;\n }\n else {\n result = i ;\n }\n break ;\n }\n }\n if ( result < 1 ) {\n result = - 1 ;\n }\n return result ;\n }", "idx": 21622}
{"hash": 1760449185745615462, "project": "debian", "size": 5, "label": 0, "functionSource": "TSHttpSsn TSHttpTxnSsnGet ( TSHttpTxn txnp ) {\n sdk_assert ( sdk_sanity_check_txn ( txnp ) == TS_SUCCESS ) ;\n HttpSM * sm = reinterpret_cast < HttpSM * > ( txnp ) ;\n return reinterpret_cast < TSHttpSsn > ( sm -> ua_session ? ( TSHttpSsn ) sm -> ua_session -> get_parent ( ) : nullptr ) ;\n }", "idx": 21623}
{"hash": -6107005761225945142, "project": "debian", "size": 5, "label": 0, "functionSource": "static int php_is_dir_ok ( const cwd_state * state ) {\n struct stat buf ;\n if ( php_sys_stat ( state -> cwd , & buf ) == 0 && S_ISDIR ( buf . st_mode ) ) return ( 0 ) ;\n return ( 1 ) ;\n }", "idx": 21624}
{"hash": -8884965407551053630, "project": "debian", "size": 16, "label": 0, "functionSource": "void input_DecoderFrameNext ( decoder_t * p_dec , mtime_t * pi_duration ) {\n decoder_owner_sys_t * p_owner = p_dec -> p_owner ;\n * pi_duration = 0 ;\n vlc_mutex_lock ( & p_owner -> lock ) ;\n if ( p_dec -> fmt_out . i_cat == VIDEO_ES ) {\n if ( p_owner -> b_paused && p_owner -> p_vout ) {\n vout_NextPicture ( p_owner -> p_vout , pi_duration ) ;\n p_owner -> pause . i_ignore ++ ;\n vlc_cond_signal ( & p_owner -> wait_request ) ;\n }\n }\n else {\n DecoderFlush ( p_dec ) ;\n }\n vlc_mutex_unlock ( & p_owner -> lock ) ;\n }", "idx": 21625}
{"hash": 355220887711506893, "project": "debian", "size": 25, "label": 0, "functionSource": "void spgcostestimate ( PlannerInfo * root , IndexPath * path , double loop_count , Cost * indexStartupCost , Cost * indexTotalCost , Selectivity * indexSelectivity , double * indexCorrelation ) {\n IndexOptInfo * index = path -> indexinfo ;\n List * qinfos ;\n GenericCosts costs ;\n Cost descentCost ;\n qinfos = deconstruct_indexquals ( path ) ;\n MemSet ( & costs , 0 , sizeof ( costs ) ) ;\n genericcostestimate ( root , path , loop_count , qinfos , & costs ) ;\n if ( index -> tree_height < 0 ) {\n if ( index -> pages > 1 ) index -> tree_height = ( int ) ( log ( index -> pages ) / log ( 100.0 ) ) ;\n else index -> tree_height = 0 ;\n }\n if ( index -> tuples > 1 ) {\n descentCost = ceil ( log ( index -> tuples ) ) * cpu_operator_cost ;\n costs . indexStartupCost += descentCost ;\n costs . indexTotalCost += costs . num_sa_scans * descentCost ;\n }\n descentCost = ( index -> tree_height + 1 ) * 50.0 * cpu_operator_cost ;\n costs . indexStartupCost += descentCost ;\n costs . indexTotalCost += costs . num_sa_scans * descentCost ;\n * indexStartupCost = costs . indexStartupCost ;\n * indexTotalCost = costs . indexTotalCost ;\n * indexSelectivity = costs . indexSelectivity ;\n * indexCorrelation = costs . indexCorrelation ;\n }", "idx": 21626}
{"hash": 9176142195250515812, "project": "debian", "size": 21, "label": 0, "functionSource": "static void purple_login ( account_t * acc ) {\n struct im_connection * ic = imcb_new ( acc ) ;\n struct purple_data * pd ;\n if ( ( local_bee != NULL && local_bee != acc -> bee ) || ( global . conf -> runmode == RUNMODE_DAEMON && ! getenv ( \"BITLBEE_DEBUG\" ) ) ) {\n imcb_error ( ic , \"Daemon mode detected. Do *not* try to use libpurple in daemon mode! \" \"Please use inetd or ForkDaemon mode instead.\" ) ;\n imc_logout ( ic , FALSE ) ;\n return ;\n }\n local_bee = acc -> bee ;\n purple_connections = g_slist_prepend ( purple_connections , ic ) ;\n ic -> proto_data = pd = g_new0 ( struct purple_data , 1 ) ;\n pd -> account = purple_account_new ( acc -> user , purple_get_account_prpl_id ( acc ) ) ;\n pd -> input_requests = g_hash_table_new_full ( g_direct_hash , g_direct_equal , NULL , g_free ) ;\n pd -> next_request_id = 0 ;\n purple_account_set_password ( pd -> account , acc -> pass ) ;\n purple_sync_settings ( acc , pd -> account ) ;\n purple_account_set_enabled ( pd -> account , \"BitlBee\" , TRUE ) ;\n if ( set_getbool ( & acc -> set , \"mail_notifications\" ) && set_getstr ( & acc -> set , \"mail_notifications_handle\" ) ) {\n imcb_add_buddy ( ic , set_getstr ( & acc -> set , \"mail_notifications_handle\" ) , NULL ) ;\n }\n }", "idx": 21627}
{"hash": -4635544075321012404, "project": "debian", "size": 9, "label": 0, "functionSource": "static char * strippath ( const char * fullfile ) {\n char * filename ;\n char * base ;\n filename = strdup ( fullfile ) ;\n if ( ! filename ) return NULL ;\n base = strdup ( basename ( filename ) ) ;\n free ( filename ) ;\n return base ;\n }", "idx": 21628}
{"hash": 5835074581393329621, "project": "debian", "size": 3, "label": 0, "functionSource": "void relpTcpHintBurstBegin ( relpTcp_t * pThis ) {\n setCORKopt ( pThis -> sock , 1 ) ;\n }", "idx": 21629}
{"hash": -1672864273235910388, "project": "debian", "size": 40, "label": 0, "functionSource": "static void _slurm_rpc_dump_jobs ( slurm_msg_t * msg ) {\n DEF_TIMERS ;\n char * dump ;\n int dump_size ;\n slurm_msg_t response_msg ;\n job_info_request_msg_t * job_info_request_msg = ( job_info_request_msg_t * ) msg -> data ;\n slurmctld_lock_t job_read_lock = {\n READ_LOCK , READ_LOCK , NO_LOCK , READ_LOCK , READ_LOCK }\n ;\n uid_t uid = g_slurm_auth_get_uid ( msg -> auth_cred , slurmctld_config . auth_info ) ;\n START_TIMER ;\n debug3 ( \"Processing RPC: REQUEST_JOB_INFO from uid=%d\" , uid ) ;\n lock_slurmctld ( job_read_lock ) ;\n if ( ( job_info_request_msg -> last_update - 1 ) >= last_job_update ) {\n unlock_slurmctld ( job_read_lock ) ;\n debug3 ( \"_slurm_rpc_dump_jobs, no change\" ) ;\n slurm_send_rc_msg ( msg , SLURM_NO_CHANGE_IN_DATA ) ;\n }\n else {\n if ( job_info_request_msg -> job_ids ) {\n pack_spec_jobs ( & dump , & dump_size , job_info_request_msg -> job_ids , job_info_request_msg -> show_flags , uid , NO_VAL , msg -> protocol_version ) ;\n }\n else {\n pack_all_jobs ( & dump , & dump_size , job_info_request_msg -> show_flags , uid , NO_VAL , msg -> protocol_version ) ;\n }\n unlock_slurmctld ( job_read_lock ) ;\n END_TIMER2 ( \"_slurm_rpc_dump_jobs\" ) ;\n # if 0 info ( \"_slurm_rpc_dump_jobs, size=%d %s\" , dump_size , TIME_STR ) ;\n # endif slurm_msg_t_init ( & response_msg ) ;\n response_msg . flags = msg -> flags ;\n response_msg . protocol_version = msg -> protocol_version ;\n response_msg . address = msg -> address ;\n response_msg . conn = msg -> conn ;\n response_msg . msg_type = RESPONSE_JOB_INFO ;\n response_msg . data = dump ;\n response_msg . data_size = dump_size ;\n slurm_send_node_msg ( msg -> conn_fd , & response_msg ) ;\n xfree ( dump ) ;\n }\n }", "idx": 21630}
{"hash": 1208165234047591297, "project": "debian", "size": 5, "label": 0, "functionSource": "proto_item * parseSByte ( proto_tree * tree , tvbuff_t * tvb , packet_info * pinfo _U_ , gint * pOffset , int hfIndex ) {\n proto_item * item = proto_tree_add_item ( tree , hfIndex , tvb , * pOffset , 1 , ENC_LITTLE_ENDIAN ) ;\n * pOffset += 1 ;\n return item ;\n }", "idx": 21631}
{"hash": 1760449185745615462, "project": "debian", "size": 5, "label": 0, "functionSource": "void TSHttpTxnDNSTimeoutSet ( TSHttpTxn txnp , int timeout ) {\n sdk_assert ( sdk_sanity_check_txn ( txnp ) == TS_SUCCESS ) ;\n HttpTransact : : State * s = & ( ( ( HttpSM * ) txnp ) -> t_state ) ;\n s -> api_txn_dns_timeout_value = timeout ;\n }", "idx": 21632}
{"hash": 2713698759296604855, "project": "debian", "size": 36, "label": 1, "functionSource": "static int alloc_frame_buffer ( MpegEncContext * s , Picture * pic ) {\n int r , ret ;\n if ( s -> avctx -> hwaccel ) {\n assert ( ! pic -> hwaccel_picture_private ) ;\n if ( s -> avctx -> hwaccel -> priv_data_size ) {\n pic -> hwaccel_picture_private = av_mallocz ( s -> avctx -> hwaccel -> priv_data_size ) ;\n if ( ! pic -> hwaccel_picture_private ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"alloc_frame_buffer() failed (hwaccel private data allocation)\\n\" ) ;\n return - 1 ;\n }\n }\n }\n if ( s -> codec_id != AV_CODEC_ID_WMV3IMAGE && s -> codec_id != AV_CODEC_ID_VC1IMAGE && s -> codec_id != AV_CODEC_ID_MSS2 ) r = ff_thread_get_buffer ( s -> avctx , & pic -> f ) ;\n else r = avcodec_default_get_buffer ( s -> avctx , & pic -> f ) ;\n if ( r < 0 || ! pic -> f . type || ! pic -> f . data [ 0 ] ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"get_buffer() failed (%d %d %p)\\n\" , r , pic -> f . type , pic -> f . data [ 0 ] ) ;\n av_freep ( & pic -> hwaccel_picture_private ) ;\n return - 1 ;\n }\n if ( s -> linesize && ( s -> linesize != pic -> f . linesize [ 0 ] || s -> uvlinesize != pic -> f . linesize [ 1 ] ) ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"get_buffer() failed (stride changed)\\n\" ) ;\n free_frame_buffer ( s , pic ) ;\n return - 1 ;\n }\n if ( pic -> f . linesize [ 1 ] != pic -> f . linesize [ 2 ] ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"get_buffer() failed (uv stride mismatch)\\n\" ) ;\n free_frame_buffer ( s , pic ) ;\n return - 1 ;\n }\n if ( ! s -> edge_emu_buffer && ( ret = ff_mpv_frame_size_alloc ( s , pic -> f . linesize [ 0 ] ) ) < 0 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"get_buffer() failed to allocate context scratch buffers.\\n\" ) ;\n free_frame_buffer ( s , pic ) ;\n return ret ;\n }\n return 0 ;\n }", "idx": 21633}
{"hash": 927123821003322045, "project": "chrome", "size": 9, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( SessionRestorePageLoadMetricsBrowserTest , NavigationDuringSessionRestore ) {\n NavigateToUntrackedUrl ( ) ;\n Browser * new_browser = QuitBrowserAndRestore ( browser ( ) ) ;\n auto waiter = std : : make_unique < PageLoadMetricsWaiter > ( new_browser -> tab_strip_model ( ) -> GetActiveWebContents ( ) ) ;\n waiter -> AddPageExpectation ( TimingField : : FIRST_MEANINGFUL_PAINT ) ;\n ui_test_utils : : NavigateToURL ( new_browser , GetTestURL ( ) ) ;\n waiter -> Wait ( ) ;\n ExpectFirstPaintMetricsTotalCount ( 0 ) ;\n }", "idx": 21634}
{"hash": 5357882892791796049, "project": "debian", "size": 8, "label": 0, "functionSource": "static inline void e1000e_rx_fix_l4_csum ( E1000ECore * core , struct NetRxPkt * pkt ) {\n if ( net_rx_pkt_has_virt_hdr ( pkt ) ) {\n struct virtio_net_hdr * vhdr = net_rx_pkt_get_vhdr ( pkt ) ;\n if ( vhdr -> flags & VIRTIO_NET_HDR_F_NEEDS_CSUM ) {\n net_rx_pkt_fix_l4_csum ( pkt ) ;\n }\n }\n }", "idx": 21635}
{"hash": -4960438251319819237, "project": "chrome", "size": 13, "label": 0, "functionSource": "static int calculate_section_intra_ratio ( const FIRSTPASS_STATS * begin , const FIRSTPASS_STATS * end , int section_length ) {\n const FIRSTPASS_STATS * s = begin ;\n double intra_error = 0.0 ;\n double coded_error = 0.0 ;\n int i = 0 ;\n while ( s < end && i < section_length ) {\n intra_error += s -> intra_error ;\n coded_error += s -> coded_error ;\n ++ s ;\n ++ i ;\n }\n return ( int ) ( intra_error / DOUBLE_DIVIDE_CHECK ( coded_error ) ) ;\n }", "idx": 21636}
{"hash": -3591633859713840564, "project": "debian", "size": 25, "label": 0, "functionSource": "static void compute_antialias ( MPADecodeContext * s , GranuleDef * g ) {\n INTFLOAT * ptr ;\n int n , i ;\n if ( g -> block_type == 2 ) {\n if ( ! g -> switch_point ) return ;\n n = 1 ;\n }\n else {\n n = SBLIMIT - 1 ;\n }\n ptr = g -> sb_hybrid + 18 ;\n for ( i = n ;\n i > 0 ;\n i -- ) {\n AA ( 0 ) ;\n AA ( 1 ) ;\n AA ( 2 ) ;\n AA ( 3 ) ;\n AA ( 4 ) ;\n AA ( 5 ) ;\n AA ( 6 ) ;\n AA ( 7 ) ;\n ptr += 18 ;\n }\n }", "idx": 21637}
{"hash": 6017095990848568360, "project": "chrome", "size": 25, "label": 0, "functionSource": "static void set_roi_map ( const vpx_codec_enc_cfg_t * cfg , vpx_codec_ctx_t * codec ) {\n unsigned int i ;\n vpx_roi_map_t roi ;\n memset ( & roi , 0 , sizeof ( roi ) ) ;\n roi . rows = ( cfg -> g_h + 15 ) / 16 ;\n roi . cols = ( cfg -> g_w + 15 ) / 16 ;\n roi . delta_q [ 0 ] = 0 ;\n roi . delta_q [ 1 ] = - 2 ;\n roi . delta_q [ 2 ] = - 4 ;\n roi . delta_q [ 3 ] = - 6 ;\n roi . delta_lf [ 0 ] = 0 ;\n roi . delta_lf [ 1 ] = 1 ;\n roi . delta_lf [ 2 ] = 2 ;\n roi . delta_lf [ 3 ] = 3 ;\n roi . static_threshold [ 0 ] = 1500 ;\n roi . static_threshold [ 1 ] = 1000 ;\n roi . static_threshold [ 2 ] = 500 ;\n roi . static_threshold [ 3 ] = 0 ;\n roi . roi_map = ( uint8_t * ) malloc ( roi . rows * roi . cols ) ;\n for ( i = 0 ;\n i < roi . rows * roi . cols ;\n ++ i ) roi . roi_map [ i ] = i % 4 ;\n if ( vpx_codec_control ( codec , VP8E_SET_ROI_MAP , & roi ) ) die_codec ( codec , \"Failed to set ROI map\" ) ;\n free ( roi . roi_map ) ;\n }", "idx": 21638}
{"hash": -6734821889507212232, "project": "debian", "size": 82, "label": 1, "functionSource": "static int tgv_decode_inter ( TgvContext * s , const uint8_t * buf , const uint8_t * buf_end ) {\n int num_mvs ;\n int num_blocks_raw ;\n int num_blocks_packed ;\n int vector_bits ;\n int i , j , x , y ;\n GetBitContext gb ;\n int mvbits ;\n const uint8_t * blocks_raw ;\n if ( buf + 12 > buf_end ) return AVERROR_INVALIDDATA ;\n num_mvs = AV_RL16 ( & buf [ 0 ] ) ;\n num_blocks_raw = AV_RL16 ( & buf [ 2 ] ) ;\n num_blocks_packed = AV_RL16 ( & buf [ 4 ] ) ;\n vector_bits = AV_RL16 ( & buf [ 6 ] ) ;\n buf += 12 ;\n if ( vector_bits > MIN_CACHE_BITS || ! vector_bits ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"Invalid value for motion vector bits: %d\\n\" , vector_bits ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( num_mvs > s -> num_mvs ) {\n s -> mv_codebook = av_realloc ( s -> mv_codebook , num_mvs * 2 * sizeof ( int ) ) ;\n s -> num_mvs = num_mvs ;\n }\n if ( num_blocks_packed > s -> num_blocks_packed ) {\n s -> block_codebook = av_realloc ( s -> block_codebook , num_blocks_packed * 16 ) ;\n s -> num_blocks_packed = num_blocks_packed ;\n }\n mvbits = ( num_mvs * 2 * 10 + 31 ) & ~ 31 ;\n if ( buf + ( mvbits >> 3 ) + 16 * num_blocks_raw + 8 * num_blocks_packed > buf_end ) return AVERROR_INVALIDDATA ;\n init_get_bits ( & gb , buf , mvbits ) ;\n for ( i = 0 ;\n i < num_mvs ;\n i ++ ) {\n s -> mv_codebook [ i ] [ 0 ] = get_sbits ( & gb , 10 ) ;\n s -> mv_codebook [ i ] [ 1 ] = get_sbits ( & gb , 10 ) ;\n }\n buf += mvbits >> 3 ;\n blocks_raw = buf ;\n buf += num_blocks_raw * 16 ;\n init_get_bits ( & gb , buf , ( buf_end - buf ) << 3 ) ;\n for ( i = 0 ;\n i < num_blocks_packed ;\n i ++ ) {\n int tmp [ 4 ] ;\n for ( j = 0 ;\n j < 4 ;\n j ++ ) tmp [ j ] = get_bits ( & gb , 8 ) ;\n for ( j = 0 ;\n j < 16 ;\n j ++ ) s -> block_codebook [ i ] [ 15 - j ] = tmp [ get_bits ( & gb , 2 ) ] ;\n }\n if ( get_bits_left ( & gb ) < vector_bits * ( s -> avctx -> height / 4 ) * ( s -> avctx -> width / 4 ) ) return AVERROR_INVALIDDATA ;\n for ( y = 0 ;\n y < s -> avctx -> height / 4 ;\n y ++ ) for ( x = 0 ;\n x < s -> avctx -> width / 4 ;\n x ++ ) {\n unsigned int vector = get_bits ( & gb , vector_bits ) ;\n const uint8_t * src ;\n int src_stride ;\n if ( vector < num_mvs ) {\n int mx = x * 4 + s -> mv_codebook [ vector ] [ 0 ] ;\n int my = y * 4 + s -> mv_codebook [ vector ] [ 1 ] ;\n if ( mx < 0 || mx + 4 > s -> avctx -> width || my < 0 || my + 4 > s -> avctx -> height ) continue ;\n src = s -> last_frame . data [ 0 ] + mx + my * s -> last_frame . linesize [ 0 ] ;\n src_stride = s -> last_frame . linesize [ 0 ] ;\n }\n else {\n int offset = vector - num_mvs ;\n if ( offset < num_blocks_raw ) src = blocks_raw + 16 * offset ;\n else if ( offset - num_blocks_raw < num_blocks_packed ) src = s -> block_codebook [ offset - num_blocks_raw ] ;\n else continue ;\n src_stride = 4 ;\n }\n for ( j = 0 ;\n j < 4 ;\n j ++ ) for ( i = 0 ;\n i < 4 ;\n i ++ ) s -> frame . data [ 0 ] [ ( y * 4 + j ) * s -> frame . linesize [ 0 ] + ( x * 4 + i ) ] = src [ j * src_stride + i ] ;\n }\n return 0 ;\n }", "idx": 21639}
{"hash": 5045872831385413038, "project": "debian", "size": 6, "label": 0, "functionSource": "static int dissect_btgatt_microbit_client_requirements ( tvbuff_t * tvb , packet_info * pinfo _U_ , proto_tree * tree , void * data ) {\n btatt_data_t * att_data = ( btatt_data_t * ) data ;\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) return - 1 ;\n proto_tree_add_item ( tree , hf_gatt_microbit_client_requirements , tvb , 0 , tvb_captured_length ( tvb ) , ENC_NA ) ;\n return tvb_captured_length ( tvb ) ;\n }", "idx": 21640}
{"hash": -5268859819325807498, "project": "debian", "size": 22, "label": 0, "functionSource": "gboolean nautilus_directory_has_active_request_for_file ( NautilusDirectory * directory , NautilusFile * file ) {\n GList * node ;\n ReadyCallback * callback ;\n Monitor * monitor ;\n for ( node = directory -> details -> call_when_ready_list ;\n node != NULL ;\n node = node -> next ) {\n callback = node -> data ;\n if ( callback -> file == file || callback -> file == NULL ) {\n return TRUE ;\n }\n }\n for ( node = directory -> details -> monitor_list ;\n node != NULL ;\n node = node -> next ) {\n monitor = node -> data ;\n if ( monitor -> file == file || monitor -> file == NULL ) {\n return TRUE ;\n }\n }\n return FALSE ;\n }", "idx": 21641}
{"hash": 4876100961671882393, "project": "debian", "size": 5, "label": 0, "functionSource": "static int dissect_pvfs2_geteattr_response ( tvbuff_t * tvb , proto_tree * tree , int offset , packet_info * pinfo _U_ ) {\n offset += 4 ;\n offset = dissect_ds_keyval_array ( tvb , tree , offset ) ;\n return offset ;\n }", "idx": 21642}
{"hash": 3668456668028959955, "project": "debian", "size": 7, "label": 0, "functionSource": "static char * fstrndup ( const char * ptr , unsigned long len ) {\n char * result ;\n if ( len <= 0 ) return NULL ;\n result = ALLOC_N ( char , len ) ;\n memcpy ( result , ptr , len ) ;\n return result ;\n }", "idx": 21643}
{"hash": 4489017523191997023, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h225_T_ip6Address ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_T_ip6Address , T_ip6Address_sequence ) ;\n return offset ;\n }", "idx": 21644}
{"hash": -6872005221209485070, "project": "chrome", "size": 112, "label": 0, "functionSource": "static void decApplyRound ( decNumber * dn , decContext * set , Int residue , uInt * status ) {\n Int bump ;\n if ( residue == 0 ) return ;\n bump = 0 ;\n switch ( set -> round ) {\n case DEC_ROUND_05UP : {\n Int lsd5 = * dn -> lsu % 5 ;\n if ( residue < 0 && lsd5 != 1 ) bump = - 1 ;\n else if ( residue > 0 && lsd5 == 0 ) bump = 1 ;\n break ;\n }\n case DEC_ROUND_DOWN : {\n if ( residue < 0 ) bump = - 1 ;\n break ;\n }\n case DEC_ROUND_HALF_DOWN : {\n if ( residue > 5 ) bump = 1 ;\n break ;\n }\n case DEC_ROUND_HALF_EVEN : {\n if ( residue > 5 ) bump = 1 ;\n else if ( residue == 5 ) {\n if ( * dn -> lsu & 0x01 ) bump = 1 ;\n }\n break ;\n }\n case DEC_ROUND_HALF_UP : {\n if ( residue >= 5 ) bump = 1 ;\n break ;\n }\n case DEC_ROUND_UP : {\n if ( residue > 0 ) bump = 1 ;\n break ;\n }\n case DEC_ROUND_CEILING : {\n if ( decNumberIsNegative ( dn ) ) {\n if ( residue < 0 ) bump = - 1 ;\n }\n else {\n if ( residue > 0 ) bump = 1 ;\n }\n break ;\n }\n case DEC_ROUND_FLOOR : {\n if ( ! decNumberIsNegative ( dn ) ) {\n if ( residue < 0 ) bump = - 1 ;\n }\n else {\n if ( residue > 0 ) bump = 1 ;\n }\n break ;\n }\n default : {\n * status |= DEC_Invalid_context ;\n # if DECTRACE || ( DECCHECK && DECVERB ) printf ( \"Unknown rounding mode: %d\\n\" , set -> round ) ;\n # endif break ;\n }\n }\n if ( bump == 0 ) return ;\n if ( bump > 0 ) {\n Unit * up ;\n uInt count = dn -> digits ;\n for ( up = dn -> lsu ;\n ;\n up ++ ) {\n if ( count <= DECDPUN ) {\n if ( * up != powers [ count ] - 1 ) break ;\n * up = ( Unit ) powers [ count - 1 ] ;\n for ( up = up - 1 ;\n up >= dn -> lsu ;\n up -- ) * up = 0 ;\n dn -> exponent ++ ;\n if ( ( dn -> exponent + dn -> digits ) > set -> emax + 1 ) {\n decSetOverflow ( dn , set , status ) ;\n }\n return ;\n }\n if ( * up != DECDPUNMAX ) break ;\n count -= DECDPUN ;\n }\n }\n else {\n Unit * up , * sup ;\n uInt count = dn -> digits ;\n for ( up = dn -> lsu ;\n ;\n up ++ ) {\n if ( count <= DECDPUN ) {\n if ( * up != powers [ count - 1 ] ) break ;\n sup = up ;\n * up = ( Unit ) powers [ count ] - 1 ;\n for ( up = up - 1 ;\n up >= dn -> lsu ;\n up -- ) * up = ( Unit ) powers [ DECDPUN ] - 1 ;\n dn -> exponent -- ;\n if ( dn -> exponent + 1 == set -> emin - set -> digits + 1 ) {\n if ( count == 1 && dn -> digits == 1 ) * sup = 0 ;\n else {\n * sup = ( Unit ) powers [ count - 1 ] - 1 ;\n dn -> digits -- ;\n }\n dn -> exponent ++ ;\n * status |= DEC_Underflow | DEC_Subnormal | DEC_Inexact | DEC_Rounded ;\n }\n return ;\n }\n if ( * up != 0 ) break ;\n count -= DECDPUN ;\n }\n }\n decUnitAddSub ( dn -> lsu , D2U ( dn -> digits ) , uarrone , 1 , 0 , dn -> lsu , bump ) ;\n }", "idx": 21645}
{"hash": 6323824267898511453, "project": "debian", "size": 7, "label": 0, "functionSource": "void fz_new_colorspace_context ( fz_context * ctx ) {\n ctx -> colorspace = fz_malloc_struct ( ctx , fz_colorspace_context ) ;\n ctx -> colorspace -> ctx_refs = 1 ;\n set_no_icc ( ctx -> colorspace ) ;\n # ifdef NO_ICC fz_set_cmm_engine ( ctx , NULL ) ;\n # else fz_set_cmm_engine ( ctx , & fz_cmm_engine_lcms ) ;\n # endif }", "idx": 21646}
{"hash": -7049333455584635197, "project": "chrome", "size": 11, "label": 1, "functionSource": "static const char * _UTF16GetName ( const UConverter * cnv ) {\n if ( UCNV_GET_VERSION ( cnv ) == 0 ) {\n return \"UTF-16\" ;\n }\n else if ( UCNV_GET_VERSION ( cnv ) == 1 ) {\n return \"UTF-16,version=1\" ;\n }\n else {\n return \"UTF-16,version=2\" ;\n }\n }", "idx": 21647}
{"hash": -1929262071302712016, "project": "debian", "size": 11, "label": 0, "functionSource": "void _cmsAllocMPETypePluginChunk ( struct _cmsContext_struct * ctx , const struct _cmsContext_struct * src ) {\n if ( src != NULL ) {\n DupTagTypeList ( ctx , src , MPEPlugin ) ;\n }\n else {\n static _cmsTagTypePluginChunkType TagTypePluginChunk = {\n NULL }\n ;\n ctx -> chunks [ MPEPlugin ] = _cmsSubAllocDup ( ctx -> MemPool , & TagTypePluginChunk , sizeof ( _cmsTagTypePluginChunkType ) ) ;\n }\n }", "idx": 21648}
{"hash": 1223258652239369123, "project": "debian", "size": 16, "label": 0, "functionSource": "static void spl_filesystem_tree_it_rewind ( zend_object_iterator * iter TSRMLS_DC ) {\n spl_filesystem_iterator * iterator = ( spl_filesystem_iterator * ) iter ;\n spl_filesystem_object * object = spl_filesystem_iterator_to_object ( iterator ) ;\n object -> u . dir . index = 0 ;\n if ( object -> u . dir . dirp ) {\n php_stream_rewinddir ( object -> u . dir . dirp ) ;\n }\n do {\n spl_filesystem_dir_read ( object TSRMLS_CC ) ;\n }\n while ( spl_filesystem_is_dot ( object -> u . dir . entry . d_name ) ) ;\n if ( iterator -> current ) {\n zval_ptr_dtor ( & iterator -> current ) ;\n iterator -> current = NULL ;\n }\n }", "idx": 21649}
{"hash": -2648356651055439484, "project": "debian", "size": 3, "label": 0, "functionSource": "static void gsm_a_dtap_mm_stat_init ( new_stat_tap_ui * new_stat , new_stat_tap_gui_init_cb gui_callback , void * gui_data ) {\n gsm_a_stat_init ( new_stat , gui_callback , gui_data , \"GSM A-I/F DTAP Mobility Management Statistics\" , gsm_a_dtap_msg_mm_strings ) ;\n }", "idx": 21650}
{"hash": 8445816931248660591, "project": "debian", "size": 12, "label": 0, "functionSource": "static zend_object_value spl_dllist_object_clone ( zval * zobject TSRMLS_DC ) {\n zend_object_value new_obj_val ;\n zend_object * old_object ;\n zend_object * new_object ;\n zend_object_handle handle = Z_OBJ_HANDLE_P ( zobject ) ;\n spl_dllist_object * intern ;\n old_object = zend_objects_get_address ( zobject TSRMLS_CC ) ;\n new_obj_val = spl_dllist_object_new_ex ( old_object -> ce , & intern , zobject , 1 TSRMLS_CC ) ;\n new_object = & intern -> std ;\n zend_objects_clone_members ( new_object , new_obj_val , old_object , handle TSRMLS_CC ) ;\n return new_obj_val ;\n }", "idx": 21651}
{"hash": 3887066622454352196, "project": "chrome", "size": 29, "label": 0, "functionSource": "static int64_t rd_pick_intra_sbuv_mode ( VP9_COMP * cpi , MACROBLOCK * x , PICK_MODE_CONTEXT * ctx , int * rate , int * rate_tokenonly , int64_t * distortion , int * skippable , BLOCK_SIZE bsize , TX_SIZE max_tx_size ) {\n MACROBLOCKD * xd = & x -> e_mbd ;\n PREDICTION_MODE mode ;\n PREDICTION_MODE mode_selected = DC_PRED ;\n int64_t best_rd = INT64_MAX , this_rd ;\n int this_rate_tokenonly , this_rate , s ;\n int64_t this_distortion , this_sse ;\n for ( mode = DC_PRED ;\n mode <= TM_PRED ;\n ++ mode ) {\n if ( ! ( cpi -> sf . intra_uv_mode_mask [ max_tx_size ] & ( 1 << mode ) ) ) continue ;\n xd -> mi [ 0 ] . src_mi -> mbmi . uv_mode = mode ;\n super_block_uvrd ( cpi , x , & this_rate_tokenonly , & this_distortion , & s , & this_sse , bsize , best_rd ) ;\n if ( this_rate_tokenonly == INT_MAX ) continue ;\n this_rate = this_rate_tokenonly + cpi -> intra_uv_mode_cost [ cpi -> common . frame_type ] [ mode ] ;\n this_rd = RDCOST ( x -> rdmult , x -> rddiv , this_rate , this_distortion ) ;\n if ( this_rd < best_rd ) {\n mode_selected = mode ;\n best_rd = this_rd ;\n * rate = this_rate ;\n * rate_tokenonly = this_rate_tokenonly ;\n * distortion = this_distortion ;\n * skippable = s ;\n if ( ! x -> select_tx_size ) swap_block_ptr ( x , ctx , 2 , 0 , 1 , MAX_MB_PLANE ) ;\n }\n }\n xd -> mi [ 0 ] . src_mi -> mbmi . uv_mode = mode_selected ;\n return best_rd ;\n }", "idx": 21652}
{"hash": 6302861533225984845, "project": "debian", "size": 25, "label": 0, "functionSource": "static int pxa2xx_rtc_init ( SysBusDevice * dev ) {\n PXA2xxRTCState * s = FROM_SYSBUS ( PXA2xxRTCState , dev ) ;\n struct tm tm ;\n int wom ;\n s -> rttr = 0x7fff ;\n s -> rtsr = 0 ;\n qemu_get_timedate ( & tm , 0 ) ;\n wom = ( ( tm . tm_mday - 1 ) / 7 ) + 1 ;\n s -> last_rcnr = ( uint32_t ) mktimegm ( & tm ) ;\n s -> last_rdcr = ( wom << 20 ) | ( ( tm . tm_wday + 1 ) << 17 ) | ( tm . tm_hour << 12 ) | ( tm . tm_min << 6 ) | tm . tm_sec ;\n s -> last_rycr = ( ( tm . tm_year + 1900 ) << 9 ) | ( ( tm . tm_mon + 1 ) << 5 ) | tm . tm_mday ;\n s -> last_swcr = ( tm . tm_hour << 19 ) | ( tm . tm_min << 13 ) | ( tm . tm_sec << 7 ) ;\n s -> last_rtcpicr = 0 ;\n s -> last_hz = s -> last_sw = s -> last_pi = qemu_get_clock_ms ( rtc_clock ) ;\n s -> rtc_hz = qemu_new_timer_ms ( rtc_clock , pxa2xx_rtc_hz_tick , s ) ;\n s -> rtc_rdal1 = qemu_new_timer_ms ( rtc_clock , pxa2xx_rtc_rdal1_tick , s ) ;\n s -> rtc_rdal2 = qemu_new_timer_ms ( rtc_clock , pxa2xx_rtc_rdal2_tick , s ) ;\n s -> rtc_swal1 = qemu_new_timer_ms ( rtc_clock , pxa2xx_rtc_swal1_tick , s ) ;\n s -> rtc_swal2 = qemu_new_timer_ms ( rtc_clock , pxa2xx_rtc_swal2_tick , s ) ;\n s -> rtc_pi = qemu_new_timer_ms ( rtc_clock , pxa2xx_rtc_pi_tick , s ) ;\n sysbus_init_irq ( dev , & s -> rtc_irq ) ;\n memory_region_init_io ( & s -> iomem , OBJECT ( s ) , & pxa2xx_rtc_ops , s , \"pxa2xx-rtc\" , 0x10000 ) ;\n sysbus_init_mmio ( dev , & s -> iomem ) ;\n return 0 ;\n }", "idx": 21653}
{"hash": -115674558950115809, "project": "debian", "size": 33, "label": 0, "functionSource": "static int read_uncompressed_sgi ( unsigned char * out_buf , uint8_t * out_end , SgiState * s ) {\n int x , y , z ;\n unsigned int offset = s -> height * s -> width * s -> bytes_per_channel ;\n GetByteContext gp [ 4 ] ;\n if ( offset * s -> depth > bytestream2_get_bytes_left ( & s -> g ) ) return AVERROR_INVALIDDATA ;\n for ( z = 0 ;\n z < s -> depth ;\n z ++ ) {\n gp [ z ] = s -> g ;\n bytestream2_skip ( & gp [ z ] , z * offset ) ;\n }\n for ( y = s -> height - 1 ;\n y >= 0 ;\n y -- ) {\n out_end = out_buf + ( y * s -> linesize ) ;\n if ( s -> bytes_per_channel == 1 ) {\n for ( x = s -> width ;\n x > 0 ;\n x -- ) for ( z = 0 ;\n z < s -> depth ;\n z ++ ) * out_end ++ = bytestream2_get_byteu ( & gp [ z ] ) ;\n }\n else {\n uint16_t * out16 = ( uint16_t * ) out_end ;\n for ( x = s -> width ;\n x > 0 ;\n x -- ) for ( z = 0 ;\n z < s -> depth ;\n z ++ ) * out16 ++ = bytestream2_get_ne16u ( & gp [ z ] ) ;\n }\n }\n return 0 ;\n }", "idx": 21654}
{"hash": 7725608904711859657, "project": "debian", "size": 4, "label": 0, "functionSource": "int TS_X509_ALGOR_print_bio ( BIO * bio , const X509_ALGOR * alg ) {\n int i = OBJ_obj2nid ( alg -> algorithm ) ;\n return BIO_printf ( bio , \"Hash Algorithm: %s\\n\" , ( i == NID_undef ) ? \"UNKNOWN\" : OBJ_nid2ln ( i ) ) ;\n }", "idx": 21655}
{"hash": 1223258652239369123, "project": "debian", "size": 30, "label": 1, "functionSource": "SPL_METHOD ( RecursiveDirectoryIterator , getChildren ) {\n zval * zpath , * zflags ;\n spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n spl_filesystem_object * subdir ;\n char slash = SPL_HAS_FLAG ( intern -> flags , SPL_FILE_DIR_UNIXPATHS ) ? '/' : DEFAULT_SLASH ;\n if ( zend_parse_parameters_none ( ) == FAILURE ) {\n return ;\n }\n spl_filesystem_object_get_file_name ( intern TSRMLS_CC ) ;\n MAKE_STD_ZVAL ( zflags ) ;\n MAKE_STD_ZVAL ( zpath ) ;\n ZVAL_LONG ( zflags , intern -> flags ) ;\n ZVAL_STRINGL ( zpath , intern -> file_name , intern -> file_name_len , 1 ) ;\n spl_instantiate_arg_ex2 ( Z_OBJCE_P ( getThis ( ) ) , & return_value , 0 , zpath , zflags TSRMLS_CC ) ;\n zval_ptr_dtor ( & zpath ) ;\n zval_ptr_dtor ( & zflags ) ;\n subdir = ( spl_filesystem_object * ) zend_object_store_get_object ( return_value TSRMLS_CC ) ;\n if ( subdir ) {\n if ( intern -> u . dir . sub_path && intern -> u . dir . sub_path [ 0 ] ) {\n subdir -> u . dir . sub_path_len = spprintf ( & subdir -> u . dir . sub_path , 0 , \"%s%c%s\" , intern -> u . dir . sub_path , slash , intern -> u . dir . entry . d_name ) ;\n }\n else {\n subdir -> u . dir . sub_path_len = strlen ( intern -> u . dir . entry . d_name ) ;\n subdir -> u . dir . sub_path = estrndup ( intern -> u . dir . entry . d_name , subdir -> u . dir . sub_path_len ) ;\n }\n subdir -> info_class = intern -> info_class ;\n subdir -> file_class = intern -> file_class ;\n subdir -> oth = intern -> oth ;\n }\n }", "idx": 21656}
{"hash": 252275190935145023, "project": "debian", "size": 14, "label": 0, "functionSource": "static void read_coef_probs_common ( vp9_coeff_probs_model * coef_probs , vp9_reader * r ) {\n int i , j , k , l , m ;\n if ( vp9_read_bit ( r ) ) for ( i = 0 ;\n i < PLANE_TYPES ;\n ++ i ) for ( j = 0 ;\n j < REF_TYPES ;\n ++ j ) for ( k = 0 ;\n k < COEF_BANDS ;\n ++ k ) for ( l = 0 ;\n l < BAND_COEFF_CONTEXTS ( k ) ;\n ++ l ) for ( m = 0 ;\n m < UNCONSTRAINED_NODES ;\n ++ m ) vp9_diff_update_prob ( r , & coef_probs [ i ] [ j ] [ k ] [ l ] [ m ] ) ;\n }", "idx": 21657}
{"hash": 5506079590431503777, "project": "debian", "size": 8, "label": 0, "functionSource": "int get_dns_name ( tvbuff_t * tvb , int offset , int max_len , int dns_data_offset , const guchar * * name ) {\n int len ;\n len = expand_dns_name ( tvb , offset , max_len , dns_data_offset , name ) ;\n if ( * * name == '\\0' ) {\n * name = \"<Root>\" ;\n }\n return len ;\n }", "idx": 21658}
{"hash": -5082285935423529157, "project": "debian", "size": 13, "label": 0, "functionSource": "static int dissect_rsl_ie_multirate_cntrl ( tvbuff_t * tvb , packet_info * pinfo _U_ , proto_tree * tree , int offset , gboolean is_mandatory ) {\n proto_tree * ie_tree ;\n guint8 ie_id ;\n if ( is_mandatory == FALSE ) {\n ie_id = tvb_get_guint8 ( tvb , offset ) ;\n if ( ie_id != RSL_IE_MULTIRATE_CNTRL ) return offset ;\n }\n ie_tree = proto_tree_add_subtree ( tree , tvb , offset , 2 , ett_ie_multirate_cntrl , NULL , \"MultiRate Control IE\" ) ;\n proto_tree_add_item ( ie_tree , hf_rsl_ie_id , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n offset ++ ;\n offset ++ ;\n return offset ;\n }", "idx": 21659}
{"hash": 1458662858915721428, "project": "debian", "size": 6, "label": 0, "functionSource": "void tb_free ( TranslationBlock * tb ) {\n if ( tcg_ctx . tb_ctx . nb_tbs > 0 && tb == & tcg_ctx . tb_ctx . tbs [ tcg_ctx . tb_ctx . nb_tbs - 1 ] ) {\n tcg_ctx . code_gen_ptr = tb -> tc_ptr ;\n tcg_ctx . tb_ctx . nb_tbs -- ;\n }\n }", "idx": 21660}
{"hash": -6580451576689962916, "project": "debian", "size": 3, "label": 0, "functionSource": "static const char * Indent ( guint8 level ) {\n return indent_buffer + ( 512 - 2 * ( level ) ) ;\n }", "idx": 21661}
{"hash": -1338403456839869183, "project": "debian", "size": 672, "label": 0, "functionSource": "void proto_register_q931 ( void ) {\n guint i ;\n guint last_offset ;\n static hf_register_info hf [ ] = {\n {\n & hf_q931_discriminator , {\n \"Protocol discriminator\" , \"q931.disc\" , FT_UINT8 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_q931_call_ref_len , {\n \"Call reference value length\" , \"q931.call_ref_len\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_q931_call_ref_flag , {\n \"Call reference flag\" , \"q931.call_ref_flag\" , FT_BOOLEAN , BASE_NONE , TFS ( & tfs_call_ref_flag ) , 0x0 , NULL , HFILL }\n }\n , {\n & hf_q931_call_ref , {\n \"Call reference value\" , \"q931.call_ref\" , FT_BYTES , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_q931_message_type , {\n \"Message type\" , \"q931.message_type\" , FT_UINT8 , BASE_HEX | BASE_EXT_STRING , & q931_message_type_vals_ext , 0x0 , NULL , HFILL }\n }\n , {\n & hf_q931_maintenance_message_type , {\n \"Maintenance message type\" , \"q931.maintenance_message_type\" , FT_UINT8 , BASE_HEX , VALS ( dms_message_type_vals ) , 0x0 , NULL , HFILL }\n }\n , {\n & hf_q931_segment_type , {\n \"Segmented message type\" , \"q931.segment_type\" , FT_UINT8 , BASE_HEX | BASE_EXT_STRING , & q931_message_type_vals_ext , 0x0 , NULL , HFILL }\n }\n , {\n & hf_q931_coding_standard , {\n \"Coding standard\" , \"q931.coding_standard\" , FT_UINT8 , BASE_HEX , VALS ( q931_coding_standard_vals ) , 0x60 , NULL , HFILL }\n }\n , {\n & hf_q931_interpretation , {\n \"Interpretation\" , \"q931.interpretation\" , FT_UINT8 , BASE_HEX , VALS ( q931_interpretation_vals ) , 0x1C , NULL , HFILL }\n }\n , {\n & hf_q931_pres_meth_prot_prof , {\n \"Presentation method of protocol profile\" , \"q931.presentation_method_protocol_profile\" , FT_UINT8 , BASE_HEX , VALS ( q931_pres_meth_prot_prof_vals ) , 0x03 , NULL , HFILL }\n }\n , {\n & hf_q931_high_layer_characteristics , {\n \"High layer characteristics identification\" , \"q931.high_layer_characteristics\" , FT_UINT8 , BASE_HEX | BASE_EXT_STRING , & q931_high_layer_characteristics_vals_ext , 0x7f , NULL , HFILL }\n }\n , {\n & hf_q931_extended_high_layer_characteristics , {\n \"Extended high layer characteristics identification\" , \"q931.extended_high_layer_characteristics\" , FT_UINT8 , BASE_HEX | BASE_EXT_STRING , & q931_extended_high_layer_characteristics_vals_ext , 0x7f , NULL , HFILL }\n }\n , {\n & hf_q931_extended_audiovisual_characteristics , {\n \"Extended audiovisual characteristics identification\" , \"q931.extended_audiovisual_characteristics\" , FT_UINT8 , BASE_HEX , VALS ( q931_audiovisual_characteristics_vals ) , 0x7f , NULL , HFILL }\n }\n , {\n & hf_q931_information_transfer_capability , {\n \"Information transfer capability\" , \"q931.information_transfer_capability\" , FT_UINT8 , BASE_HEX , VALS ( q931_information_transfer_capability_vals ) , 0x1f , NULL , HFILL }\n }\n , {\n & hf_q931_transfer_mode , {\n \"Transfer mode\" , \"q931.transfer_mode\" , FT_UINT8 , BASE_HEX , VALS ( q931_transfer_mode_vals ) , 0x60 , NULL , HFILL }\n }\n , {\n & hf_q931_information_transfer_rate , {\n \"Information transfer rate\" , \"q931.information_transfer_rate\" , FT_UINT8 , BASE_HEX , VALS ( q931_information_transfer_rate_vals ) , 0x1f , NULL , HFILL }\n }\n , {\n & hf_q931_layer_ident , {\n \"Layer identification\" , \"q931.layer_ident\" , FT_UINT8 , BASE_HEX , VALS ( q931_bearer_capability_layer_ident_vals ) , 0x60 , NULL , HFILL }\n }\n , {\n & hf_q931_uil1 , {\n \"User information layer 1 protocol\" , \"q931.uil1\" , FT_UINT8 , BASE_HEX | BASE_EXT_STRING , & q931_uil1_vals_ext , 0x1f , NULL , HFILL }\n }\n , {\n & hf_q931_cause_location , {\n \"Cause location\" , \"q931.cause_location\" , FT_UINT8 , BASE_DEC | BASE_EXT_STRING , & q931_cause_location_vals_ext , 0x0f , NULL , HFILL }\n }\n , {\n & hf_q931_cause_value , {\n \"Cause value\" , \"q931.cause_value\" , FT_UINT8 , BASE_DEC | BASE_EXT_STRING , & q931_cause_code_vals_ext , 0x7f , NULL , HFILL }\n }\n , {\n & hf_q931_number_type , {\n \"Number type\" , \"q931.number_type\" , FT_UINT8 , BASE_HEX , VALS ( q931_number_type_vals ) , 0x70 , NULL , HFILL }\n }\n , {\n & hf_q931_numbering_plan , {\n \"Numbering plan\" , \"q931.numbering_plan\" , FT_UINT8 , BASE_HEX , VALS ( q931_numbering_plan_vals ) , 0x0f , NULL , HFILL }\n }\n , {\n & hf_q931_screening_ind , {\n \"Screening indicator\" , \"q931.screening_ind\" , FT_UINT8 , BASE_HEX , VALS ( q931_screening_indicator_vals ) , 0x03 , NULL , HFILL }\n }\n , {\n & hf_q931_presentation_ind , {\n \"Presentation indicator\" , \"q931.presentation_ind\" , FT_UINT8 , BASE_HEX , VALS ( q931_presentation_indicator_vals ) , 0x60 , NULL , HFILL }\n }\n , {\n & hf_q931_extension_ind , {\n \"Extension indicator\" , \"q931.extension_ind\" , FT_BOOLEAN , 8 , TFS ( & q931_extension_ind_value ) , 0x80 , NULL , HFILL }\n }\n , {\n & hf_q931_extension_ind_preference , {\n \"Preference\" , \"q931.extension_ind_preference\" , FT_UINT8 , BASE_DEC , VALS ( q931_status_preference_vals ) , 0x40 , NULL , HFILL }\n }\n , {\n & hf_q931_extension_ind_new_status , {\n \"New status\" , \"q931.extension_ind_new_status\" , FT_UINT8 , BASE_DEC , VALS ( q931_new_status_vals ) , 0x07 , NULL , HFILL }\n }\n , {\n & hf_q931_calling_party_number , {\n \"Calling party number digits\" , \"q931.calling_party_number.digits\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_q931_called_party_number , {\n \"Called party number digits\" , \"q931.called_party_number.digits\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_q931_connected_number , {\n \"Connected party number digits\" , \"q931.connected_number.digits\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_q931_redirecting_number , {\n \"Redirecting party number digits\" , \"q931.redirecting_number.digits\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_q931_channel_interface_explicit , {\n \"Interface identifier present\" , \"q931.channel.interface_id_present\" , FT_BOOLEAN , 8 , NULL , 0x40 , \"True if the interface identifier is explicit in the following octets\" , HFILL }\n }\n , {\n & hf_q931_channel_interface_type , {\n \"Interface type\" , \"q931.channel.interface_type\" , FT_BOOLEAN , 8 , TFS ( & tfs_interface_type ) , 0x20 , \"Identifies the ISDN interface type\" , HFILL }\n }\n , {\n & hf_q931_channel_exclusive , {\n \"Indicated channel\" , \"q931.channel.exclusive\" , FT_BOOLEAN , 8 , TFS ( & tfs_channel_exclusive ) , 0x08 , \"True if only the indicated channel is acceptable\" , HFILL }\n }\n , {\n & hf_q931_channel_dchan , {\n \"D-channel indicator\" , \"q931.channel.dchan\" , FT_BOOLEAN , 8 , NULL , 0x04 , \"True if the identified channel is the D-Channel\" , HFILL }\n }\n , {\n & hf_q931_channel_selection_bri , {\n \"Information channel selection\" , \"q931.channel.selection\" , FT_UINT8 , BASE_HEX , VALS ( q931_basic_channel_selection_vals ) , 0x03 , \"Identifies the information channel to be used\" , HFILL }\n }\n , {\n & hf_q931_channel_selection_pri , {\n \"Information channel selection\" , \"q931.channel.selection\" , FT_UINT8 , BASE_HEX , VALS ( q931_not_basic_channel_selection_vals ) , 0x03 , \"Identifies the information channel to be used\" , HFILL }\n }\n , {\n & hf_q931_channel_map , {\n \"Number/map\" , \"q931.channel.map\" , FT_BOOLEAN , 8 , TFS ( & tfs_channel_map ) , 0x10 , \"True if channel is indicates by channel map rather than number\" , HFILL }\n }\n , {\n & hf_q931_channel_element_type , {\n \"Element type\" , \"q931.channel.element_type\" , FT_UINT8 , BASE_HEX , VALS ( q931_element_type_vals ) , 0xF , \"Type of element in the channel number/slot map octets\" , HFILL }\n }\n , {\n & hf_q931_channel_number , {\n \"Channel number\" , \"q931.channel.number\" , FT_UINT8 , BASE_DEC , NULL , 0x7F , NULL , HFILL }\n }\n , {\n & hf_q931_segment_overlap , {\n \"Segment overlap\" , \"q931.segment.overlap\" , FT_BOOLEAN , BASE_NONE , NULL , 0x0 , \"Fragment overlaps with other fragments\" , HFILL }\n }\n , {\n & hf_q931_segment_overlap_conflict , {\n \"Conflicting data in fragment overlap\" , \"q931.segment.overlap.conflict\" , FT_BOOLEAN , BASE_NONE , NULL , 0x0 , \"Overlapping fragments contained conflicting data\" , HFILL }\n }\n , {\n & hf_q931_segment_multiple_tails , {\n \"Multiple tail fragments found\" , \"q931.segment.multipletails\" , FT_BOOLEAN , BASE_NONE , NULL , 0x0 , \"Several tails were found when defragmenting the packet\" , HFILL }\n }\n , {\n & hf_q931_segment_too_long_segment , {\n \"Segment too long\" , \"q931.segment.toolongfragment\" , FT_BOOLEAN , BASE_NONE , NULL , 0x0 , \"Segment contained data past end of packet\" , HFILL }\n }\n , {\n & hf_q931_segment_error , {\n \"Defragmentation error\" , \"q931.segment.error\" , FT_FRAMENUM , BASE_NONE , NULL , 0x0 , \"Defragmentation error due to illegal fragments\" , HFILL }\n }\n , {\n & hf_q931_segment_count , {\n \"Segment count\" , \"q931.segment.count\" , FT_UINT32 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_q931_segment , {\n \"Q.931 Segment\" , \"q931.segment\" , FT_FRAMENUM , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_q931_segments , {\n \"Q.931 Segments\" , \"q931.segments\" , FT_NONE , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_q931_reassembled_in , {\n \"Reassembled Q.931 in frame\" , \"q931.reassembled_in\" , FT_FRAMENUM , BASE_NONE , NULL , 0x0 , \"This Q.931 message is reassembled in this frame\" , HFILL }\n }\n , {\n & hf_q931_reassembled_length , {\n \"Reassembled Q.931 length\" , \"q931.reassembled.length\" , FT_UINT32 , BASE_DEC , NULL , 0x0 , \"The total length of the reassembled payload\" , HFILL }\n }\n , {\n & hf_q931_first_segment , {\n \"First segment\" , \"q931.segment.first\" , FT_UINT8 , BASE_DEC , NULL , 0x7F , NULL , HFILL }\n }\n , {\n & hf_q931_not_first_segment , {\n \"Not first segment\" , \"q931.segment.not_first\" , FT_UINT8 , BASE_DEC , NULL , 0x7F , NULL , HFILL }\n }\n , {\n & hf_q931_bearer_capability_data , {\n \"Data\" , \"q931.bearer_capability.data\" , FT_BYTES , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_q931_bearer_capability_rate_multiplier , {\n \"Rate multiplier\" , \"q931.bearer_capability.rate_multiplier\" , FT_UINT8 , BASE_DEC , NULL , 0x7f , NULL , HFILL }\n }\n , {\n & hf_q931_bearer_capability_user_rate , {\n \"User rate\" , \"q931.bearer_capability.user_rate\" , FT_UINT8 , BASE_HEX | BASE_EXT_STRING , & q931_l1_user_rate_vals_ext , 0x1F , NULL , HFILL }\n }\n , {\n & hf_q931_bearer_capability_intermediate_rate , {\n \"Intermediate rate\" , \"q931.bearer_capability.intermediate_rate\" , FT_UINT8 , BASE_HEX , VALS ( q931_l1_intermediate_rate_vals ) , 0x60 , NULL , HFILL }\n }\n , {\n & hf_q931_bearer_capability_stop_bits , {\n \"Stop bits\" , \"q931.bearer_capability.stop_bits\" , FT_UINT8 , BASE_HEX , VALS ( q931_l1_stop_bits_vals ) , 0x60 , NULL , HFILL }\n }\n , {\n & hf_q931_bearer_capability_data_bits , {\n \"Data bits\" , \"q931.bearer_capability.data_bits\" , FT_UINT8 , BASE_HEX , VALS ( q931_l1_data_bits_vals ) , 0x18 , NULL , HFILL }\n }\n , {\n & hf_q931_bearer_capability_parity , {\n \"Parity\" , \"q931.bearer_capability.parity\" , FT_UINT8 , BASE_HEX , VALS ( q931_l1_parity_vals ) , 0x07 , NULL , HFILL }\n }\n , {\n & hf_q931_bearer_capability_modem_type , {\n \"Modem type\" , \"q931.bearer_capability.modem_type\" , FT_UINT8 , BASE_HEX | BASE_RANGE_STRING , RVALS ( q931_l1_modem_type_rvals ) , 0x3F , NULL , HFILL }\n }\n , {\n & hf_q931_uil2 , {\n \"User information layer 2 protocol\" , \"q931.uil2\" , FT_UINT8 , BASE_HEX | BASE_EXT_STRING , & q931_uil2_vals_ext , 0x1F , NULL , HFILL }\n }\n , {\n & hf_q931_uil2_info , {\n \"User-specified layer 2 protocol information\" , \"q931.uil2_info\" , FT_UINT8 , BASE_HEX , NULL , 0x7F , NULL , HFILL }\n }\n , {\n & hf_q931_bearer_capability_mode , {\n \"Mode\" , \"q931.bearer_capability.mode\" , FT_UINT8 , BASE_HEX , VALS ( q931_mode_vals ) , 0x60 , NULL , HFILL }\n }\n , {\n & hf_q931_bearer_capability_window_size , {\n \"Window size\" , \"q931.bearer_capability.window_size\" , FT_UINT8 , BASE_DEC , NULL , 0x7F , NULL , HFILL }\n }\n , {\n & hf_q931_uil3 , {\n \"User information layer 3 protocol\" , \"q931.uil3\" , FT_UINT8 , BASE_HEX , VALS ( q931_uil3_vals ) , 0x1F , NULL , HFILL }\n }\n , {\n & hf_q931_bearer_capability_default_packet_size , {\n \"Default packet size\" , \"q931.bearer_capability.default_packet_size\" , FT_UINT8 , BASE_DEC , NULL , 0x0F , NULL , HFILL }\n }\n , {\n & hf_q931_bearer_capability_packet_window_size , {\n \"Packet window size\" , \"q931.bearer_capability.packet_window_size\" , FT_UINT8 , BASE_DEC , NULL , 0x7F , NULL , HFILL }\n }\n , {\n & hf_q931_uil3_additional , {\n \"Additional layer 3 protocol information\" , \"q931.uil3_additional\" , FT_UINT16 , BASE_HEX , VALS ( nlpid_vals ) , 0x0 , NULL , HFILL }\n }\n , {\n & hf_q931_cause_data , {\n \"Data\" , \"q931.cause.data\" , FT_BYTES , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_q931_cause_recommendation , {\n \"Recommendation\" , \"q931.cause.recommendation\" , FT_UINT8 , BASE_HEX , VALS ( q931_cause_recommendation_vals ) , 0x7F , NULL , HFILL }\n }\n , {\n & hf_q931_cause_call_rejection_reason , {\n \"Rejection reason\" , \"q931.cause_call.rejection_reason\" , FT_UINT8 , BASE_HEX , VALS ( q931_rejection_reason_vals ) , 0x7C , NULL , HFILL }\n }\n , {\n & hf_q931_cause_call_condition , {\n \"Condition\" , \"q931.cause_call.condition\" , FT_UINT8 , BASE_HEX , VALS ( q931_cause_condition_vals ) , 0x03 , NULL , HFILL }\n }\n , {\n & hf_q931_cause_call_user_specific_diagnostic , {\n \"User specific diagnostic\" , \"q931.cause_call.user_specific_diagnostic\" , FT_BYTES , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_q931_cause_call_diagnostic , {\n \"Diagnostic\" , \"q931.cause_call.diagnostic\" , FT_BYTES , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_q931_cause_call_message_type , {\n \"Message type\" , \"q931.cause_call.message_type\" , FT_UINT8 , BASE_HEX | BASE_EXT_STRING , & q931_message_type_vals_ext , 0x0 , NULL , HFILL }\n }\n , {\n & hf_q931_cause_call_rec_timer , {\n \"Timer\" , \"q931.cause_call.rec_timer\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_q931_call_state_data , {\n \"Data\" , \"q931.call_state.data\" , FT_BYTES , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_q931_call_state , {\n \"Call state\" , \"q931.call_state\" , FT_UINT8 , BASE_HEX | BASE_EXT_STRING , & q931_call_state_vals_ext , 0x3F , NULL , HFILL }\n }\n , {\n & hf_q931_channel_interface_id , {\n \"Interface ID\" , \"q931.channel.interface_id\" , FT_UINT32 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_q931_channel_data , {\n \"Data\" , \"q931.channel.data\" , FT_BYTES , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_q931_channel_slot_map , {\n \"Slot map\" , \"q931.channel.slot_map\" , FT_UINT8 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_q931_progress_indicator_data , {\n \"Data\" , \"q931.progress_indicator.data\" , FT_BYTES , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_q931_progress_indicator_location , {\n \"Location\" , \"q931.progress_indicator.location\" , FT_UINT8 , BASE_HEX | BASE_EXT_STRING , & q931_cause_location_vals_ext , 0x0F , NULL , HFILL }\n }\n , {\n & hf_q931_progress_indicator_description , {\n \"Progress description\" , \"q931.progress_indicator.description\" , FT_UINT8 , BASE_HEX | BASE_EXT_STRING , & q931_progress_description_vals_ext , 0x7F , NULL , HFILL }\n }\n , {\n & hf_q931_netid_length , {\n \"Network identification length\" , \"q931.netid.length\" , FT_UINT8 , BASE_DEC , NULL , 0x7F , NULL , HFILL }\n }\n , {\n & hf_q931_netid_type , {\n \"Type of network identification\" , \"q931.netid.type\" , FT_UINT8 , BASE_HEX , VALS ( q931_netid_type_vals ) , 0x70 , NULL , HFILL }\n }\n , {\n & hf_q931_netid_plan , {\n \"Network identification plan\" , \"q931.netid.plan\" , FT_UINT8 , BASE_HEX , VALS ( q931_netid_plan_vals ) , 0x0F , NULL , HFILL }\n }\n , {\n & hf_q931_netid , {\n \"Network identification\" , \"q931.netid\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_q931_netid_facility_specification , {\n \"Network-specific facility specification\" , \"q931.netid.facility_specification\" , FT_BYTES , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_q931_notification_description , {\n \"Notification description\" , \"q931.notification_description\" , FT_UINT8 , BASE_HEX , VALS ( q931_notification_description_vals ) , 0x7F , NULL , HFILL }\n }\n , {\n & hf_q931_signal , {\n \"Signal\" , \"q931.signal\" , FT_UINT8 , BASE_HEX | BASE_EXT_STRING , & q931_signal_vals_ext , 0x0 , NULL , HFILL }\n }\n , {\n & hf_q931_information_rate_incoming , {\n \"Incoming information rate\" , \"q931.information_rate.incoming\" , FT_UINT8 , BASE_HEX | BASE_EXT_STRING , & q931_throughput_class_vals_ext , 0x1F , NULL , HFILL }\n }\n , {\n & hf_q931_information_rate_outgoing , {\n \"Outgoing information rate\" , \"q931.information_rate.outgoing\" , FT_UINT8 , BASE_HEX | BASE_EXT_STRING , & q931_throughput_class_vals_ext , 0x1F , NULL , HFILL }\n }\n , {\n & hf_q931_information_rate_minimum_incoming , {\n \"Minimum incoming information rate\" , \"q931.information_rate.minimum_incoming\" , FT_UINT8 , BASE_HEX | BASE_EXT_STRING , & q931_throughput_class_vals_ext , 0x1F , NULL , HFILL }\n }\n , {\n & hf_q931_information_rate_minimum_outgoing , {\n \"Minimum outgoing information rate\" , \"q931.information_rate.minimum_outgoing\" , FT_UINT8 , BASE_HEX | BASE_EXT_STRING , & q931_throughput_class_vals_ext , 0x1F , NULL , HFILL }\n }\n , {\n & hf_q931_fast_select , {\n \"Fast select\" , \"q931.fast_select\" , FT_UINT8 , BASE_HEX , VALS ( q931_fast_selected_vals ) , 0x18 , NULL , HFILL }\n }\n , {\n & hf_q931_pl_window_size_forward_value , {\n \"Forward value\" , \"q931.pl_window_size.forward_value\" , FT_UINT8 , BASE_DEC , NULL , 0x7F , NULL , HFILL }\n }\n , {\n & hf_q931_pl_window_size_backward_value , {\n \"Backward value\" , \"q931.pl_window_size.backward_value\" , FT_UINT8 , BASE_DEC , NULL , 0x7F , NULL , HFILL }\n }\n , {\n & hf_q931_packet_size_forward_value , {\n \"Forward value\" , \"q931.packet_size.forward_value\" , FT_UINT8 , BASE_DEC , NULL , 0x7F , NULL , HFILL }\n }\n , {\n & hf_q931_packet_size_backward_value , {\n \"Backward value\" , \"q931.packet_size.backward_value\" , FT_UINT8 , BASE_DEC , NULL , 0x7F , NULL , HFILL }\n }\n , {\n & hf_q931_cug_indication , {\n \"CUG indication\" , \"q931.cug_indication\" , FT_UINT8 , BASE_HEX , VALS ( q931_cug_indication_vals ) , 0x07 , NULL , HFILL }\n }\n , {\n & hf_q931_cug_index_code , {\n \"CUG index code\" , \"q931.cug_index_code\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_q931_reverse_charging_ind , {\n \"Reverse charging indication\" , \"q931.reverse_charging_ind\" , FT_UINT8 , BASE_HEX , VALS ( q931_reverse_charging_indication_vals ) , 0x07 , NULL , HFILL }\n }\n , {\n & hf_q931_extension_reason , {\n \"Reason for redirection\" , \"q931.extension.reason\" , FT_UINT8 , BASE_HEX , VALS ( q931_redirection_reason_vals ) , 0x0F , NULL , HFILL }\n }\n , {\n & hf_q931_party_subaddr_type , {\n \"Type of subaddress\" , \"q931.party_subaddr.type\" , FT_UINT8 , BASE_HEX , VALS ( q931_subaddress_type_vals ) , 0x70 , NULL , HFILL }\n }\n , {\n & hf_q931_party_subaddr_odd_even_indicator , {\n \"Odd/even indicator\" , \"q931.party_subaddr.odd_even\" , FT_UINT8 , BASE_HEX , VALS ( q931_odd_even_indicator_vals ) , 0x08 , NULL , HFILL }\n }\n , {\n & hf_q931_party_subaddr , {\n \"Subaddress\" , \"q931.party_subaddr\" , FT_BYTES , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_q931_restart_indicator , {\n \"Restart indicator\" , \"q931.restart_indicator\" , FT_UINT8 , BASE_HEX , VALS ( q931_restart_indicator_class_vals ) , 0x07 , NULL , HFILL }\n }\n , {\n & hf_q931_high_layer_compat_data , {\n \"Data\" , \"q931.high_layer_compat.data\" , FT_BYTES , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_q931_user_protocol_discriminator , {\n \"Protocol discriminator\" , \"q931.user.protocol_discriminator\" , FT_UINT8 , BASE_HEX | BASE_EXT_STRING , & q931_protocol_discriminator_vals_ext , 0x0 , NULL , HFILL }\n }\n , {\n & hf_q931_user_information_len , {\n \"User information\" , \"q931.user.len\" , FT_UINT32 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_q931_user_information_str , {\n \"User information\" , \"q931.user.string\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_q931_user_information_bytes , {\n \"User information\" , \"q931.user.bytes\" , FT_BYTES , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_q931_party_category , {\n \"Party category\" , \"q931.party_category\" , FT_UINT8 , BASE_HEX , VALS ( q931_party_category_vals ) , 0x07 , NULL , HFILL }\n }\n , {\n & hf_q931_congestion_level , {\n \"Congestion level\" , \"q931.congestion_level\" , FT_UINT8 , BASE_HEX , VALS ( q931_congestion_level_vals ) , Q931_IE_SO_IE_MASK , NULL , HFILL }\n }\n , {\n & hf_q931_repeat_indicator , {\n \"Repeat indicator\" , \"q931.repeat_indicator\" , FT_UINT8 , BASE_HEX , VALS ( q931_repeat_indication_vals ) , Q931_IE_SO_IE_MASK , NULL , HFILL }\n }\n , {\n & hf_q931_out_band_negotiation , {\n \"Out-band negotiation\" , \"q931.out_band_negotiation\" , FT_BOOLEAN , 8 , TFS ( & tfs_possible_not_possible ) , 0x40 , NULL , HFILL }\n }\n , {\n & hf_q931_layer_1 , {\n \"Layer 1\" , \"q931.layer_1\" , FT_BOOLEAN , 8 , TFS ( & tfs_asynchronous_synchronous ) , 0x40 , NULL , HFILL }\n }\n , {\n & hf_q931_layer_1_in_band_negotiation , {\n \"Layer 1 in-band negotiation\" , \"q931.layer_1_in_band_negotiation\" , FT_BOOLEAN , 8 , TFS ( & tfs_possible_not_possible ) , 0x20 , NULL , HFILL }\n }\n , {\n & hf_q931_send_data_net_independent_clock , {\n \"Send data with network independent clock\" , \"q931.send_data_net_independent_clock\" , FT_BOOLEAN , 8 , TFS ( & tfs_required_not_required ) , 0x10 , NULL , HFILL }\n }\n , {\n & hf_q931_accept_data_net_independent_clock , {\n \"Accept data with network independent clock\" , \"q931.accept_data_net_independent_clock\" , FT_BOOLEAN , 8 , TFS ( & tfs_accepted_not_accepted ) , 0x08 , NULL , HFILL }\n }\n , {\n & hf_q931_send_data_flow_control , {\n \"Send data with flow control mechanism\" , \"q931.send_data_flow_control\" , FT_BOOLEAN , 8 , TFS ( & tfs_required_not_required ) , 0x04 , NULL , HFILL }\n }\n , {\n & hf_q931_accept_data_flow_control , {\n \"Accept data with flow control mechanism\" , \"q931.accept_data_flow_control\" , FT_BOOLEAN , 8 , TFS ( & tfs_accepted_not_accepted ) , 0x2 , NULL , HFILL }\n }\n , {\n & hf_q931_rate_adaption_header , {\n \"Rate adaption header\" , \"q931.rate_adaption_header\" , FT_BOOLEAN , 8 , TFS ( & tfs_present_not_present ) , 0x40 , NULL , HFILL }\n }\n , {\n & hf_q931_multiple_frame_establishment , {\n \"Multiple frame establishment\" , \"q931.multiple_frame_establishment\" , FT_BOOLEAN , 8 , TFS ( & tfs_supported_not_supported ) , 0x20 , NULL , HFILL }\n }\n , {\n & hf_q931_mode_of_operation , {\n \"mode of operation\" , \"q931.mode_of_operation\" , FT_BOOLEAN , 8 , TFS ( & tfs_protocol_sensative_bit_transparent ) , 0x10 , NULL , HFILL }\n }\n , {\n & hf_q931_message_originator , {\n \"Message originator\" , \"q931.message_originator\" , FT_BOOLEAN , 8 , TFS ( & tfs_assignor_default ) , 0x04 , NULL , HFILL }\n }\n , {\n & hf_q931_negotiation_is_done , {\n \"Negotiation is done\" , \"q931.negotiation_is_done\" , FT_BOOLEAN , 8 , TFS ( & tfs_in_out_band ) , 0x02 , NULL , HFILL }\n }\n , {\n & hf_q931_bearer_capability_duplex , {\n \"Duplex\" , \"q931.bearer_capability.duplex\" , FT_BOOLEAN , 8 , TFS ( & tfs_full_half ) , 0x40 , NULL , HFILL }\n }\n , {\n & hf_q931_network_service , {\n \"Network service\" , \"q931.network_service\" , FT_BOOLEAN , 8 , TFS ( & tfs_user_provider ) , 0x80 , NULL , HFILL }\n }\n , {\n & hf_q931_extension_condition_type , {\n \"Type\" , \"q931.extension_condition_type\" , FT_BOOLEAN , 8 , TFS ( & tfs_abnormal_normal ) , 0x40 , NULL , HFILL }\n }\n , {\n & hf_q931_extension_condition , {\n \"Condition\" , \"q931.extension_condition\" , FT_UINT8 , BASE_HEX , VALS ( q931_cause_condition_vals ) , 0x03 , NULL , HFILL }\n }\n , {\n & hf_q931_pl_request , {\n \"Request\" , \"q931.pl_request\" , FT_BOOLEAN , 8 , TFS ( & tfs_pl_request ) , 0x04 , NULL , HFILL }\n }\n , {\n & hf_q931_pl_binary_confirmation , {\n \"Confirmation\" , \"q931.pl_binary_confirmation\" , FT_BOOLEAN , 8 , TFS ( & tfs_link_end ) , 0x02 , NULL , HFILL }\n }\n , {\n & hf_q931_pl_modulus , {\n \"Modulus\" , \"q931.pl_modulus\" , FT_BOOLEAN , 8 , TFS ( & tfs_pl_modulus ) , 0x01 , NULL , HFILL }\n }\n , {\n & hf_q931_data , {\n \"Data\" , \"q931.data\" , FT_BYTES , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_q931_information_element , {\n \"Information element\" , \"q931.information_element\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_q931_information_element_len , {\n \"Length\" , \"q931.information_element_len\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_q931_date_time , {\n \"Date/time\" , \"q931.date_time\" , FT_BYTES , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_q931_more_data , {\n \"More data\" , \"q931.more_data\" , FT_NONE , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_q931_sending_complete , {\n \"Sending complete\" , \"q931.sending_complete\" , FT_NONE , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_q931_message_segment , {\n \"Message segment\" , \"q931.message_segment\" , FT_BYTES , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_q931_missing_info_element , {\n \"Missing information element\" , \"q931.missing_info_element\" , FT_UINT8 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_q931_insufficient_info_element , {\n \"Insufficient information element\" , \"q931.insufficient_info_element\" , FT_UINT8 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_q931_cumulative_transit_delay , {\n \"Cumulative transit delay\" , \"q931.cumulative_transit_delay\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_q931_requested_end_to_end_transit_delay , {\n \"Requested end-to-end transit delay\" , \"q931.requested_end_to_end_transit_delay\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_q931_maximum_end_to_end_transit_delay , {\n \"Maximum end-to-end transit delay\" , \"q931.maximum_end_to_end_transit_delay\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_q931_transit_delay , {\n \"Transit delay\" , \"q931.transit_delay\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_q931_display_information , {\n \"Display information\" , \"q931.display_information\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_q931_keypad_facility , {\n \"Keypad facility\" , \"q931.keypad_facility\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_q931_avaya_display , {\n \"Avaya Display\" , \"q931.avaya_display\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_q931_locking_codeset , {\n \"Locking codeset\" , \"q931.locking_codeset\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_q931_protocol_negotiation , {\n \"Protocol negotiation\" , \"q931.protocol_negotiation\" , FT_BOOLEAN , 8 , TFS ( & tfs_protocol_negotiation ) , 0x08 , NULL , HFILL }\n }\n , }\n ;\n # define NUM_INDIVIDUAL_ELEMS 3 static gint * ett [ NUM_INDIVIDUAL_ELEMS + NUM_IE ] ;\n static ei_register_info ei [ ] = {\n {\n & ei_q931_invalid_length , {\n \"q931.invalid_length\" , PI_MALFORMED , PI_ERROR , \"Invalid length\" , EXPFILL }\n }\n , {\n & ei_q931_date_time , {\n \"q931.date_time.invalid\" , PI_MALFORMED , PI_ERROR , \"Date/time: Invalid length\" , EXPFILL }\n }\n , {\n & ei_q931_information_element , {\n \"q931.information_element.unknown\" , PI_PROTOCOL , PI_WARN , \"Unknown information element\" , EXPFILL }\n }\n , {\n & ei_q931_incomplete_ie , {\n \"q931.incomplete_ie\" , PI_MALFORMED , PI_ERROR , \"Incomplete IE in the 1st segment\" , EXPFILL }\n }\n , }\n ;\n module_t * q931_module ;\n expert_module_t * expert_q931 ;\n ett [ 0 ] = & ett_q931 ;\n ett [ 1 ] = & ett_q931_segments ;\n ett [ 2 ] = & ett_q931_segment ;\n last_offset = NUM_INDIVIDUAL_ELEMS ;\n for ( i = 0 ;\n i < NUM_IE ;\n i ++ , last_offset ++ ) {\n ett_q931_ie [ i ] = - 1 ;\n ett [ last_offset ] = & ett_q931_ie [ i ] ;\n }\n proto_q931 = proto_register_protocol ( \"Q.931\" , \"Q.931\" , \"q931\" ) ;\n proto_register_field_array ( proto_q931 , hf , array_length ( hf ) ) ;\n proto_register_subtree_array ( ett , array_length ( ett ) ) ;\n expert_q931 = expert_register_protocol ( proto_q931 ) ;\n expert_register_field_array ( expert_q931 , ei , array_length ( ei ) ) ;\n register_init_routine ( q931_init ) ;\n register_cleanup_routine ( q931_cleanup ) ;\n q931_handle = register_dissector ( \"q931\" , dissect_q931 , proto_q931 ) ;\n q931_tpkt_handle = register_dissector ( \"q931.tpkt\" , dissect_q931_tpkt , proto_q931 ) ;\n q931_tpkt_pdu_handle = create_dissector_handle ( dissect_q931_tpkt_pdu , proto_q931 ) ;\n q931_over_ip_handle = register_dissector ( \"q931.over_ip\" , dissect_q931_over_ip , proto_q931 ) ;\n register_dissector ( \"q931.ie\" , dissect_q931_ie_cs0 , proto_q931 ) ;\n register_dissector ( \"q931.ie.cs7\" , dissect_q931_ie_cs7 , proto_q931 ) ;\n codeset_dissector_table = register_dissector_table ( \"q931.codeset\" , \"Q.931 Codeset\" , proto_q931 , FT_UINT8 , BASE_HEX ) ;\n ie_dissector_table = register_dissector_table ( \"q931.ie\" , \"Q.931 IE\" , proto_q931 , FT_UINT16 , BASE_HEX ) ;\n q931_user_heur_subdissector_list = register_heur_dissector_list ( \"q931_user\" , proto_q931 ) ;\n q931_module = prefs_register_protocol ( proto_q931 , NULL ) ;\n prefs_register_bool_preference ( q931_module , \"desegment_h323_messages\" , \"Reassemble Q.931 messages spanning multiple TCP segments\" , \"Whether the Q.931 dissector should reassemble messages spanning multiple TCP segments.\" \" To use this option, you must also enable \\\"Allow subdissectors to reassemble TCP streams\\\" in the TCP protocol settings.\" , & q931_desegment ) ;\n prefs_register_bool_preference ( q931_module , \"reassembly\" , \"Reassemble segmented Q.931 messages\" , \"Reassemble segmented Q.931 messages (Q.931 - Annex H)\" , & q931_reassembly ) ;\n prefs_register_bool_preference ( q931_module , \"iso_iec_cause_coding\" , \"Decode ISO/IEC cause coding standard as ITU-T\" , \"Decode ISO/IEC cause coding standard as ITU-T\" , & g931_iso_iec_cause ) ;\n q931_tap = register_tap ( \"q931\" ) ;\n }", "idx": 21662}
{"hash": -1929262071302712016, "project": "debian", "size": 26, "label": 0, "functionSource": "static cmsBool Type_ParametricCurve_Write ( struct _cms_typehandler_struct * self , cmsIOHANDLER * io , void * Ptr , cmsUInt32Number nItems ) {\n cmsToneCurve * Curve = ( cmsToneCurve * ) Ptr ;\n int i , nParams , typen ;\n static const int ParamsByType [ ] = {\n 0 , 1 , 3 , 4 , 5 , 7 }\n ;\n typen = Curve -> Segments [ 0 ] . Type ;\n if ( Curve -> nSegments > 1 || typen < 1 ) {\n cmsSignalError ( self -> ContextID , cmsERROR_UNKNOWN_EXTENSION , \"Multisegment or Inverted parametric curves cannot be written\" ) ;\n return FALSE ;\n }\n if ( typen > 5 ) {\n cmsSignalError ( self -> ContextID , cmsERROR_UNKNOWN_EXTENSION , \"Unsupported parametric curve\" ) ;\n return FALSE ;\n }\n nParams = ParamsByType [ typen ] ;\n if ( ! _cmsWriteUInt16Number ( io , ( cmsUInt16Number ) ( Curve -> Segments [ 0 ] . Type - 1 ) ) ) return FALSE ;\n if ( ! _cmsWriteUInt16Number ( io , 0 ) ) return FALSE ;\n for ( i = 0 ;\n i < nParams ;\n i ++ ) {\n if ( ! _cmsWrite15Fixed16Number ( io , Curve -> Segments [ 0 ] . Params [ i ] ) ) return FALSE ;\n }\n return TRUE ;\n cmsUNUSED_PARAMETER ( nItems ) ;\n }", "idx": 21663}
{"hash": 5750382823403258531, "project": "debian", "size": 66, "label": 0, "functionSource": "static int cinvideo_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n CinVideoContext * cin = avctx -> priv_data ;\n int i , y , palette_type , palette_colors_count , bitmap_frame_type , bitmap_frame_size , res = 0 ;\n palette_type = buf [ 0 ] ;\n palette_colors_count = AV_RL16 ( buf + 1 ) ;\n bitmap_frame_type = buf [ 3 ] ;\n buf += 4 ;\n bitmap_frame_size = buf_size - 4 ;\n if ( bitmap_frame_size < palette_colors_count * ( 3 + ( palette_type != 0 ) ) ) return AVERROR_INVALIDDATA ;\n if ( palette_type == 0 ) {\n if ( palette_colors_count > 256 ) return AVERROR_INVALIDDATA ;\n for ( i = 0 ;\n i < palette_colors_count ;\n ++ i ) {\n cin -> palette [ i ] = bytestream_get_le24 ( & buf ) ;\n bitmap_frame_size -= 3 ;\n }\n }\n else {\n for ( i = 0 ;\n i < palette_colors_count ;\n ++ i ) {\n cin -> palette [ buf [ 0 ] ] = AV_RL24 ( buf + 1 ) ;\n buf += 4 ;\n bitmap_frame_size -= 4 ;\n }\n }\n switch ( bitmap_frame_type ) {\n case 9 : cin_decode_rle ( buf , bitmap_frame_size , cin -> bitmap_table [ CIN_CUR_BMP ] , cin -> bitmap_size ) ;\n break ;\n case 34 : cin_decode_rle ( buf , bitmap_frame_size , cin -> bitmap_table [ CIN_CUR_BMP ] , cin -> bitmap_size ) ;\n cin_apply_delta_data ( cin -> bitmap_table [ CIN_PRE_BMP ] , cin -> bitmap_table [ CIN_CUR_BMP ] , cin -> bitmap_size ) ;\n break ;\n case 35 : cin_decode_huffman ( buf , bitmap_frame_size , cin -> bitmap_table [ CIN_INT_BMP ] , cin -> bitmap_size ) ;\n cin_decode_rle ( cin -> bitmap_table [ CIN_INT_BMP ] , bitmap_frame_size , cin -> bitmap_table [ CIN_CUR_BMP ] , cin -> bitmap_size ) ;\n break ;\n case 36 : bitmap_frame_size = cin_decode_huffman ( buf , bitmap_frame_size , cin -> bitmap_table [ CIN_INT_BMP ] , cin -> bitmap_size ) ;\n cin_decode_rle ( cin -> bitmap_table [ CIN_INT_BMP ] , bitmap_frame_size , cin -> bitmap_table [ CIN_CUR_BMP ] , cin -> bitmap_size ) ;\n cin_apply_delta_data ( cin -> bitmap_table [ CIN_PRE_BMP ] , cin -> bitmap_table [ CIN_CUR_BMP ] , cin -> bitmap_size ) ;\n break ;\n case 37 : cin_decode_huffman ( buf , bitmap_frame_size , cin -> bitmap_table [ CIN_CUR_BMP ] , cin -> bitmap_size ) ;\n break ;\n case 38 : res = cin_decode_lzss ( buf , bitmap_frame_size , cin -> bitmap_table [ CIN_CUR_BMP ] , cin -> bitmap_size ) ;\n if ( res < 0 ) return res ;\n break ;\n case 39 : res = cin_decode_lzss ( buf , bitmap_frame_size , cin -> bitmap_table [ CIN_CUR_BMP ] , cin -> bitmap_size ) ;\n if ( res < 0 ) return res ;\n cin_apply_delta_data ( cin -> bitmap_table [ CIN_PRE_BMP ] , cin -> bitmap_table [ CIN_CUR_BMP ] , cin -> bitmap_size ) ;\n break ;\n }\n if ( ( res = ff_reget_buffer ( avctx , & cin -> frame ) ) < 0 ) {\n av_log ( cin -> avctx , AV_LOG_ERROR , \"delphinecinvideo: reget_buffer() failed to allocate a frame\\n\" ) ;\n return res ;\n }\n memcpy ( cin -> frame . data [ 1 ] , cin -> palette , sizeof ( cin -> palette ) ) ;\n cin -> frame . palette_has_changed = 1 ;\n for ( y = 0 ;\n y < cin -> avctx -> height ;\n ++ y ) memcpy ( cin -> frame . data [ 0 ] + ( cin -> avctx -> height - 1 - y ) * cin -> frame . linesize [ 0 ] , cin -> bitmap_table [ CIN_CUR_BMP ] + y * cin -> avctx -> width , cin -> avctx -> width ) ;\n FFSWAP ( uint8_t * , cin -> bitmap_table [ CIN_CUR_BMP ] , cin -> bitmap_table [ CIN_PRE_BMP ] ) ;\n if ( ( res = av_frame_ref ( data , & cin -> frame ) ) < 0 ) return res ;\n * got_frame = 1 ;\n return buf_size ;\n }", "idx": 21664}
{"hash": -357657257866300423, "project": "debian", "size": 9, "label": 0, "functionSource": "int ztokenexec ( i_ctx_t * i_ctx_p ) {\n os_ptr op = osp ;\n stream * s ;\n scanner_state state ;\n check_read_file ( i_ctx_p , s , op ) ;\n check_estack ( 1 ) ;\n gs_scanner_init ( & state , op ) ;\n return tokenexec_continue ( i_ctx_p , & state , true ) ;\n }", "idx": 21665}
{"hash": -3591633859713840564, "project": "debian", "size": 11, "label": 0, "functionSource": "static inline int l3_unscale ( int value , int exponent ) {\n unsigned int m ;\n int e ;\n e = table_4_3_exp [ 4 * value + ( exponent & 3 ) ] ;\n m = table_4_3_value [ 4 * value + ( exponent & 3 ) ] ;\n e -= exponent >> 2 ;\n assert ( e >= 1 ) ;\n if ( e > 31 ) return 0 ;\n m = ( m + ( 1 << ( e - 1 ) ) ) >> e ;\n return m ;\n }", "idx": 21666}
{"hash": -7855974557509681261, "project": "debian", "size": 10, "label": 0, "functionSource": "void get_typlenbyval ( Oid typid , int16 * typlen , bool * typbyval ) {\n HeapTuple tp ;\n Form_pg_type typtup ;\n tp = SearchSysCache1 ( TYPEOID , ObjectIdGetDatum ( typid ) ) ;\n if ( ! HeapTupleIsValid ( tp ) ) elog ( ERROR , \"cache lookup failed for type %u\" , typid ) ;\n typtup = ( Form_pg_type ) GETSTRUCT ( tp ) ;\n * typlen = typtup -> typlen ;\n * typbyval = typtup -> typbyval ;\n ReleaseSysCache ( tp ) ;\n }", "idx": 21667}
{"hash": -2386031673786599357, "project": "debian", "size": 121, "label": 0, "functionSource": "static gpgme_error_t status_handler ( void * opaque , int fd ) {\n struct io_cb_data * data = ( struct io_cb_data * ) opaque ;\n engine_gpgsm_t gpgsm = ( engine_gpgsm_t ) data -> handler_value ;\n gpgme_error_t err = 0 ;\n char * line ;\n size_t linelen ;\n do {\n err = assuan_read_line ( gpgsm -> assuan_ctx , & line , & linelen ) ;\n if ( err ) {\n TRACE3 ( DEBUG_CTX , \"gpgme:status_handler\" , gpgsm , \"fd 0x%x: error from assuan (%d) getting status line : %s\" , fd , err , gpg_strerror ( err ) ) ;\n }\n else if ( linelen >= 3 && line [ 0 ] == 'E' && line [ 1 ] == 'R' && line [ 2 ] == 'R' && ( line [ 3 ] == '\\0' || line [ 3 ] == ' ' ) ) {\n if ( line [ 3 ] == ' ' ) err = atoi ( & line [ 4 ] ) ;\n if ( ! err ) err = gpg_error ( GPG_ERR_GENERAL ) ;\n TRACE2 ( DEBUG_CTX , \"gpgme:status_handler\" , gpgsm , \"fd 0x%x: ERR line - mapped to: %s\" , fd , err ? gpg_strerror ( err ) : \"ok\" ) ;\n }\n else if ( linelen >= 2 && line [ 0 ] == 'O' && line [ 1 ] == 'K' && ( line [ 2 ] == '\\0' || line [ 2 ] == ' ' ) ) {\n if ( gpgsm -> status . fnc ) err = gpgsm -> status . fnc ( gpgsm -> status . fnc_value , GPGME_STATUS_EOF , \"\" ) ;\n if ( ! err && gpgsm -> colon . fnc && gpgsm -> colon . any ) {\n gpgsm -> colon . any = 0 ;\n err = gpgsm -> colon . fnc ( gpgsm -> colon . fnc_value , NULL ) ;\n }\n TRACE2 ( DEBUG_CTX , \"gpgme:status_handler\" , gpgsm , \"fd 0x%x: OK line - final status: %s\" , fd , err ? gpg_strerror ( err ) : \"ok\" ) ;\n _gpgme_io_close ( gpgsm -> status_cb . fd ) ;\n return err ;\n }\n else if ( linelen > 2 && line [ 0 ] == 'D' && line [ 1 ] == ' ' && gpgsm -> colon . fnc ) {\n char * src = line + 2 ;\n char * end = line + linelen ;\n char * dst ;\n char * * aline = & gpgsm -> colon . attic . line ;\n int * alinelen = & gpgsm -> colon . attic . linelen ;\n if ( gpgsm -> colon . attic . linesize < * alinelen + linelen + 1 ) {\n char * newline = realloc ( * aline , * alinelen + linelen + 1 ) ;\n if ( ! newline ) err = gpg_error_from_syserror ( ) ;\n else {\n * aline = newline ;\n gpgsm -> colon . attic . linesize = * alinelen + linelen + 1 ;\n }\n }\n if ( ! err ) {\n dst = * aline + * alinelen ;\n while ( ! err && src < end ) {\n if ( * src == '%' && src + 2 < end ) {\n ++ src ;\n * dst = _gpgme_hextobyte ( src ) ;\n ( * alinelen ) ++ ;\n src += 2 ;\n }\n else {\n * dst = * src ++ ;\n ( * alinelen ) ++ ;\n }\n if ( * dst == '\\n' ) {\n gpgsm -> colon . any = 1 ;\n if ( * alinelen > 1 && * ( dst - 1 ) == '\\r' ) dst -- ;\n * dst = '\\0' ;\n err = gpgsm -> colon . fnc ( gpgsm -> colon . fnc_value , * aline ) ;\n if ( ! err ) {\n dst = * aline ;\n * alinelen = 0 ;\n }\n }\n else dst ++ ;\n }\n }\n TRACE2 ( DEBUG_CTX , \"gpgme:status_handler\" , gpgsm , \"fd 0x%x: D line;\n final status: %s\" , fd , err ? gpg_strerror ( err ) : \"ok\" ) ;\n }\n else if ( linelen > 2 && line [ 0 ] == 'D' && line [ 1 ] == ' ' && gpgsm -> inline_data ) {\n char * src = line + 2 ;\n char * end = line + linelen ;\n char * dst = src ;\n gpgme_ssize_t nwritten ;\n linelen = 0 ;\n while ( src < end ) {\n if ( * src == '%' && src + 2 < end ) {\n ++ src ;\n * dst ++ = _gpgme_hextobyte ( src ) ;\n src += 2 ;\n }\n else * dst ++ = * src ++ ;\n linelen ++ ;\n }\n src = line + 2 ;\n while ( linelen > 0 ) {\n nwritten = gpgme_data_write ( gpgsm -> inline_data , src , linelen ) ;\n if ( ! nwritten || ( nwritten < 0 && errno != EINTR ) || nwritten > linelen ) {\n err = gpg_error_from_syserror ( ) ;\n break ;\n }\n src += nwritten ;\n linelen -= nwritten ;\n }\n TRACE2 ( DEBUG_CTX , \"gpgme:status_handler\" , gpgsm , \"fd 0x%x: D inlinedata;\n final status: %s\" , fd , err ? gpg_strerror ( err ) : \"ok\" ) ;\n }\n else if ( linelen > 2 && line [ 0 ] == 'S' && line [ 1 ] == ' ' ) {\n char * rest ;\n gpgme_status_code_t r ;\n rest = strchr ( line + 2 , ' ' ) ;\n if ( ! rest ) rest = line + linelen ;\n else * ( rest ++ ) = 0 ;\n r = _gpgme_parse_status ( line + 2 ) ;\n if ( r >= 0 ) {\n if ( gpgsm -> status . fnc ) err = gpgsm -> status . fnc ( gpgsm -> status . fnc_value , r , rest ) ;\n }\n else fprintf ( stderr , \"[UNKNOWN STATUS]%s %s\" , line + 2 , rest ) ;\n TRACE3 ( DEBUG_CTX , \"gpgme:status_handler\" , gpgsm , \"fd 0x%x: S line (%s) - final status: %s\" , fd , line + 2 , err ? gpg_strerror ( err ) : \"ok\" ) ;\n }\n else if ( linelen >= 7 && line [ 0 ] == 'I' && line [ 1 ] == 'N' && line [ 2 ] == 'Q' && line [ 3 ] == 'U' && line [ 4 ] == 'I' && line [ 5 ] == 'R' && line [ 6 ] == 'E' && ( line [ 7 ] == '\\0' || line [ 7 ] == ' ' ) ) {\n char * keyword = line + 7 ;\n while ( * keyword == ' ' ) keyword ++ ;\n ;\n default_inq_cb ( gpgsm , keyword ) ;\n assuan_write_line ( gpgsm -> assuan_ctx , \"END\" ) ;\n }\n }\n while ( ! err && assuan_pending_line ( gpgsm -> assuan_ctx ) ) ;\n return err ;\n }", "idx": 21668}
{"hash": 701342272801985904, "project": "chrome", "size": 7, "label": 0, "functionSource": "static char * _catkey ( char * buffer , int32_t set_num , int32_t msg_num ) {\n int32_t i = 0 ;\n i = T_CString_integerToString ( buffer , set_num , 10 ) ;\n buffer [ i ++ ] = SEPARATOR ;\n T_CString_integerToString ( buffer + i , msg_num , 10 ) ;\n return buffer ;\n }", "idx": 21669}
{"hash": -1338403456839869183, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_q931_tpkt_pdu ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , void * data _U_ ) {\n dissect_q931_pdu ( tvb , pinfo , tree , TRUE ) ;\n return tvb_captured_length ( tvb ) ;\n }", "idx": 21670}
{"hash": -331579171381918893, "project": "debian", "size": 10, "label": 1, "functionSource": "static ossl_inline void lh_ ## type ## _set_down_load ( LHASH_OF ( type ) * lh , unsigned long dl ) {\n OPENSSL_LH_set_down_load ( ( OPENSSL_LHASH * ) lh , dl ) ;\n }\n static ossl_inline void lh_ ## type ## _doall ( LHASH_OF ( type ) * lh , void ( * doall ) ( type * ) ) {\n OPENSSL_LH_doall ( ( OPENSSL_LHASH * ) lh , ( OPENSSL_LH_DOALL_FUNC ) doall ) ;\n }\n LHASH_OF ( type ) # define IMPLEMENT_LHASH_DOALL_ARG_CONST ( type , argtype ) int_implement_lhash_doall ( type , argtype , const type ) # define IMPLEMENT_LHASH_DOALL_ARG ( type , argtype ) int_implement_lhash_doall ( type , argtype , type ) # define int_implement_lhash_doall ( type , argtype , cbargtype ) static ossl_inline void lh_ ## type ## _doall_ ## argtype ( LHASH_OF ( type ) * lh , void ( * fn ) ( cbargtype * , argtype * ) , argtype * arg ) {\n OPENSSL_LH_doall_arg ( ( OPENSSL_LHASH * ) lh , ( OPENSSL_LH_DOALL_FUNCARG ) fn , ( void * ) arg ) ;\n }\n LHASH_OF ( type ) DEFINE_LHASH_OF ( OPENSSL_STRING )", "idx": 21671}
{"hash": 6500423400461365723, "project": "debian", "size": 33, "label": 0, "functionSource": "static int loop_through_relocations ( Dwarf_Debug dbg , dwarf_elf_object_access_internals_t * obj , struct Dwarf_Section_s * relocatablesec , int * error ) {\n Dwarf_Small * target_section = 0 ;\n Dwarf_Small * symtab_section = obj -> symtab -> dss_data ;\n Dwarf_Unsigned symtab_section_entrysize = obj -> symtab -> dss_entrysize ;\n Dwarf_Unsigned symtab_section_size = obj -> symtab -> dss_size ;\n Dwarf_Small * relocation_section = relocatablesec -> dss_reloc_data ;\n Dwarf_Unsigned relocation_section_size = relocatablesec -> dss_reloc_size ;\n Dwarf_Unsigned relocation_section_entrysize = relocatablesec -> dss_reloc_entrysize ;\n int ret = DW_DLV_ERROR ;\n struct Dwarf_Elf_Rela * relas = 0 ;\n unsigned int nrelas = 0 ;\n Dwarf_Small * mspace = 0 ;\n ret = get_relocation_entries ( obj -> is_64bit , obj -> endianness , obj -> machine , relocation_section , relocation_section_size , relocation_section_entrysize , & relas , & nrelas , error ) ;\n if ( ret != DW_DLV_OK ) {\n free ( relas ) ;\n return ret ;\n }\n if ( ! relocatablesec -> dss_data_was_malloc ) {\n mspace = malloc ( relocatablesec -> dss_size ) ;\n if ( ! mspace ) {\n * error = DW_DLE_RELOC_SECTION_MALLOC_FAIL ;\n return DW_DLV_ERROR ;\n }\n memcpy ( mspace , relocatablesec -> dss_data , relocatablesec -> dss_size ) ;\n relocatablesec -> dss_data = mspace ;\n target_section = relocatablesec -> dss_data ;\n relocatablesec -> dss_data_was_malloc = 1 ;\n }\n target_section = relocatablesec -> dss_data ;\n ret = apply_rela_entries ( dbg , obj -> is_64bit , obj -> endianness , obj -> machine , target_section , symtab_section , symtab_section_size , symtab_section_entrysize , relas , nrelas , error ) ;\n free ( relas ) ;\n return ret ;\n }", "idx": 21672}
{"hash": -3889154245145551951, "project": "debian", "size": 5, "label": 0, "functionSource": "static void parse_new_blob ( void ) {\n read_next_command ( ) ;\n parse_mark ( ) ;\n parse_and_store_blob ( & last_blob , NULL , next_mark ) ;\n }", "idx": 21673}
{"hash": -7455544248455991006, "project": "debian", "size": 67, "label": 0, "functionSource": "static int kvm_get_supported_msrs ( KVMState * s ) {\n static int kvm_supported_msrs ;\n int ret = 0 ;\n if ( kvm_supported_msrs == 0 ) {\n struct kvm_msr_list msr_list , * kvm_msr_list ;\n kvm_supported_msrs = - 1 ;\n msr_list . nmsrs = 0 ;\n ret = kvm_ioctl ( s , KVM_GET_MSR_INDEX_LIST , & msr_list ) ;\n if ( ret < 0 && ret != - E2BIG ) {\n return ret ;\n }\n kvm_msr_list = g_malloc0 ( MAX ( 1024 , sizeof ( msr_list ) + msr_list . nmsrs * sizeof ( msr_list . indices [ 0 ] ) ) ) ;\n kvm_msr_list -> nmsrs = msr_list . nmsrs ;\n ret = kvm_ioctl ( s , KVM_GET_MSR_INDEX_LIST , kvm_msr_list ) ;\n if ( ret >= 0 ) {\n int i ;\n for ( i = 0 ;\n i < kvm_msr_list -> nmsrs ;\n i ++ ) {\n switch ( kvm_msr_list -> indices [ i ] ) {\n case MSR_STAR : has_msr_star = true ;\n break ;\n case MSR_VM_HSAVE_PA : has_msr_hsave_pa = true ;\n break ;\n case MSR_TSC_AUX : has_msr_tsc_aux = true ;\n break ;\n case MSR_TSC_ADJUST : has_msr_tsc_adjust = true ;\n break ;\n case MSR_IA32_TSCDEADLINE : has_msr_tsc_deadline = true ;\n break ;\n case MSR_IA32_SMBASE : has_msr_smbase = true ;\n break ;\n case MSR_SMI_COUNT : has_msr_smi_count = true ;\n break ;\n case MSR_IA32_MISC_ENABLE : has_msr_misc_enable = true ;\n break ;\n case MSR_IA32_BNDCFGS : has_msr_bndcfgs = true ;\n break ;\n case MSR_IA32_XSS : has_msr_xss = true ;\n break ;\n case HV_X64_MSR_CRASH_CTL : has_msr_hv_crash = true ;\n break ;\n case HV_X64_MSR_RESET : has_msr_hv_reset = true ;\n break ;\n case HV_X64_MSR_VP_INDEX : has_msr_hv_vpindex = true ;\n break ;\n case HV_X64_MSR_VP_RUNTIME : has_msr_hv_runtime = true ;\n break ;\n case HV_X64_MSR_SCONTROL : has_msr_hv_synic = true ;\n break ;\n case HV_X64_MSR_STIMER0_CONFIG : has_msr_hv_stimer = true ;\n break ;\n case HV_X64_MSR_TSC_FREQUENCY : has_msr_hv_frequencies = true ;\n break ;\n case HV_X64_MSR_REENLIGHTENMENT_CONTROL : has_msr_hv_reenlightenment = true ;\n break ;\n case MSR_IA32_SPEC_CTRL : has_msr_spec_ctrl = true ;\n break ;\n case MSR_VIRT_SSBD : has_msr_virt_ssbd = true ;\n break ;\n }\n }\n }\n g_free ( kvm_msr_list ) ;\n }\n return ret ;\n }", "idx": 21674}
{"hash": -6552851419396579257, "project": "debian", "size": 4, "label": 0, "functionSource": "static int SpoolssSetJob_r ( tvbuff_t * tvb , int offset , packet_info * pinfo , proto_tree * tree , dcerpc_info * di , guint8 * drep ) {\n offset = dissect_doserror ( tvb , offset , pinfo , tree , di , drep , hf_rc , NULL ) ;\n return offset ;\n }", "idx": 21675}
{"hash": 2542574915000171973, "project": "chrome", "size": 9, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( VirtualKeyboardBrowserTest , IsKeyboardLoaded ) {\n content : : RenderViewHost * keyboard_rvh = GetKeyboardRenderViewHost ( ) ;\n ASSERT_TRUE ( keyboard_rvh ) ;\n bool loaded = false ;\n std : : string script = \"!!chrome.virtualKeyboardPrivate\" ;\n EXPECT_TRUE ( content : : ExecuteScriptAndExtractBool ( keyboard_rvh , \"window.domAutomationController.send(\" + script + \");\n\" , & loaded ) ) ;\n ASSERT_TRUE ( loaded ) ;\n }", "idx": 21676}
{"hash": 4952739496652083313, "project": "chrome", "size": 5, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( MediaStreamPermissionTest , TestDismissIsNotSticky ) {\n content : : WebContents * tab_contents = LoadTestPageInTab ( ) ;\n GetUserMediaAndDismiss ( tab_contents ) ;\n GetUserMediaAndDismiss ( tab_contents ) ;\n }", "idx": 21677}
{"hash": 6393050609822897742, "project": "debian", "size": 46, "label": 0, "functionSource": "static int xhci_try_complete_packet ( XHCITransfer * xfer ) {\n if ( xfer -> packet . status == USB_RET_ASYNC ) {\n trace_usb_xhci_xfer_async ( xfer ) ;\n xfer -> running_async = 1 ;\n xfer -> running_retry = 0 ;\n xfer -> complete = 0 ;\n return 0 ;\n }\n else if ( xfer -> packet . status == USB_RET_NAK ) {\n trace_usb_xhci_xfer_nak ( xfer ) ;\n xfer -> running_async = 0 ;\n xfer -> running_retry = 1 ;\n xfer -> complete = 0 ;\n return 0 ;\n }\n else {\n xfer -> running_async = 0 ;\n xfer -> running_retry = 0 ;\n xfer -> complete = 1 ;\n xhci_xfer_unmap ( xfer ) ;\n }\n if ( xfer -> packet . status == USB_RET_SUCCESS ) {\n trace_usb_xhci_xfer_success ( xfer , xfer -> packet . actual_length ) ;\n xfer -> status = CC_SUCCESS ;\n xhci_xfer_report ( xfer ) ;\n return 0 ;\n }\n trace_usb_xhci_xfer_error ( xfer , xfer -> packet . status ) ;\n switch ( xfer -> packet . status ) {\n case USB_RET_NODEV : case USB_RET_IOERROR : xfer -> status = CC_USB_TRANSACTION_ERROR ;\n xhci_xfer_report ( xfer ) ;\n xhci_stall_ep ( xfer ) ;\n break ;\n case USB_RET_STALL : xfer -> status = CC_STALL_ERROR ;\n xhci_xfer_report ( xfer ) ;\n xhci_stall_ep ( xfer ) ;\n break ;\n case USB_RET_BABBLE : xfer -> status = CC_BABBLE_DETECTED ;\n xhci_xfer_report ( xfer ) ;\n xhci_stall_ep ( xfer ) ;\n break ;\n default : DPRINTF ( \"%s: FIXME: status = %d\\n\" , __func__ , xfer -> packet . status ) ;\n FIXME ( \"unhandled USB_RET_*\" ) ;\n }\n return 0 ;\n }", "idx": 21678}
{"hash": 3616225660295849566, "project": "debian", "size": 11, "label": 0, "functionSource": "gboolean logcat_binary_dump_open ( wtap_dumper * wdh , int * err ) {\n wdh -> subtype_write = logcat_binary_dump ;\n wdh -> subtype_close = NULL ;\n switch ( wdh -> encap ) {\n case WTAP_ENCAP_LOGCAT : wdh -> tsprecision = WTAP_FILE_TSPREC_USEC ;\n break ;\n default : * err = WTAP_ERR_UNSUPPORTED_FILE_TYPE ;\n return FALSE ;\n }\n return TRUE ;\n }", "idx": 21679}
{"hash": -1483849844579170895, "project": "chrome", "size": 9, "label": 0, "functionSource": "static void set_stream_dimensions ( struct stream_state * stream , unsigned int w , unsigned int h ) {\n if ( ! stream -> config . cfg . g_w ) {\n if ( ! stream -> config . cfg . g_h ) stream -> config . cfg . g_w = w ;\n else stream -> config . cfg . g_w = w * stream -> config . cfg . g_h / h ;\n }\n if ( ! stream -> config . cfg . g_h ) {\n stream -> config . cfg . g_h = h * stream -> config . cfg . g_w / w ;\n }\n }", "idx": 21680}
{"hash": 5347874611477979643, "project": "chrome", "size": 8, "label": 0, "functionSource": "static void child_signal_cb ( int fd , short event , void * arg ) {\n struct timeval tv ;\n int * pint = arg ;\n * pint = 1 ;\n tv . tv_usec = 500000 ;\n tv . tv_sec = 0 ;\n event_loopexit ( & tv ) ;\n }", "idx": 21681}
{"hash": 1896723564367514490, "project": "debian", "size": 7, "label": 0, "functionSource": "static VALUE ossl_cipher_set_padding ( VALUE self , VALUE padding ) {\n EVP_CIPHER_CTX * ctx ;\n int pad = NUM2INT ( padding ) ;\n GetCipher ( self , ctx ) ;\n if ( EVP_CIPHER_CTX_set_padding ( ctx , pad ) != 1 ) ossl_raise ( eCipherError , NULL ) ;\n return padding ;\n }", "idx": 21682}
{"hash": -7855974557509681261, "project": "debian", "size": 12, "label": 0, "functionSource": "char * get_collation_name ( Oid colloid ) {\n HeapTuple tp ;\n tp = SearchSysCache1 ( COLLOID , ObjectIdGetDatum ( colloid ) ) ;\n if ( HeapTupleIsValid ( tp ) ) {\n Form_pg_collation colltup = ( Form_pg_collation ) GETSTRUCT ( tp ) ;\n char * result ;\n result = pstrdup ( NameStr ( colltup -> collname ) ) ;\n ReleaseSysCache ( tp ) ;\n return result ;\n }\n else return NULL ;\n }", "idx": 21683}
{"hash": 1749848421437618984, "project": "chrome", "size": 15, "label": 0, "functionSource": "static hb_script_t hb_ot_new_tag_to_script ( hb_tag_t tag ) {\n switch ( tag ) {\n case HB_TAG ( 'b' , 'n' , 'g' , '2' ) : return HB_SCRIPT_BENGALI ;\n case HB_TAG ( 'd' , 'e' , 'v' , '2' ) : return HB_SCRIPT_DEVANAGARI ;\n case HB_TAG ( 'g' , 'j' , 'r' , '2' ) : return HB_SCRIPT_GUJARATI ;\n case HB_TAG ( 'g' , 'u' , 'r' , '2' ) : return HB_SCRIPT_GURMUKHI ;\n case HB_TAG ( 'k' , 'n' , 'd' , '2' ) : return HB_SCRIPT_KANNADA ;\n case HB_TAG ( 'm' , 'l' , 'm' , '2' ) : return HB_SCRIPT_MALAYALAM ;\n case HB_TAG ( 'o' , 'r' , 'y' , '2' ) : return HB_SCRIPT_ORIYA ;\n case HB_TAG ( 't' , 'm' , 'l' , '2' ) : return HB_SCRIPT_TAMIL ;\n case HB_TAG ( 't' , 'e' , 'l' , '2' ) : return HB_SCRIPT_TELUGU ;\n case HB_TAG ( 'm' , 'y' , 'm' , '2' ) : return HB_SCRIPT_MYANMAR ;\n }\n return HB_SCRIPT_UNKNOWN ;\n }", "idx": 21684}
{"hash": 8484475213808847345, "project": "debian", "size": 14, "label": 0, "functionSource": "static DeviceState * qdev_find_recursive ( BusState * bus , const char * id ) {\n DeviceState * dev , * ret ;\n BusState * child ;\n QLIST_FOREACH ( dev , & bus -> children , sibling ) {\n if ( dev -> id && strcmp ( dev -> id , id ) == 0 ) return dev ;\n QLIST_FOREACH ( child , & dev -> child_bus , sibling ) {\n ret = qdev_find_recursive ( child , id ) ;\n if ( ret ) {\n return ret ;\n }\n }\n }\n return NULL ;\n }", "idx": 21685}
{"hash": -4626871451018238412, "project": "chrome", "size": 17, "label": 0, "functionSource": "static UHashtable * _uhash_init ( UHashtable * result , UHashFunction * keyHash , UKeyComparator * keyComp , UValueComparator * valueComp , int32_t primeIndex , UErrorCode * status ) {\n if ( U_FAILURE ( * status ) ) return NULL ;\n U_ASSERT ( keyHash != NULL ) ;\n U_ASSERT ( keyComp != NULL ) ;\n result -> keyHasher = keyHash ;\n result -> keyComparator = keyComp ;\n result -> valueComparator = valueComp ;\n result -> keyDeleter = NULL ;\n result -> valueDeleter = NULL ;\n result -> allocated = FALSE ;\n _uhash_internalSetResizePolicy ( result , U_GROW ) ;\n _uhash_allocate ( result , primeIndex , status ) ;\n if ( U_FAILURE ( * status ) ) {\n return NULL ;\n }\n return result ;\n }", "idx": 21686}
{"hash": -769658847024738738, "project": "debian", "size": 7, "label": 0, "functionSource": "static gpgme_error_t uiserver_set_colon_line_handler ( void * engine , engine_colon_line_handler_t fnc , void * fnc_value ) {\n engine_uiserver_t uiserver = engine ;\n uiserver -> colon . fnc = fnc ;\n uiserver -> colon . fnc_value = fnc_value ;\n uiserver -> colon . any = 0 ;\n return 0 ;\n }", "idx": 21687}
{"hash": -320658364442495927, "project": "chrome", "size": 22, "label": 0, "functionSource": "void vp8_de_noise ( VP8_COMMON * cm , YV12_BUFFER_CONFIG * source , YV12_BUFFER_CONFIG * post , int q , int low_var_thresh , int flag , int uvfilter ) {\n int mbr ;\n double level = 6.0e-05 * q * q * q - .0067 * q * q + .306 * q + .0065 ;\n int ppl = ( int ) ( level + .5 ) ;\n int mb_rows = cm -> mb_rows ;\n int mb_cols = cm -> mb_cols ;\n unsigned char * limits = cm -> pp_limits_buffer ;\n ;\n ( void ) post ;\n ( void ) low_var_thresh ;\n ( void ) flag ;\n vpx_memset ( limits , ( unsigned char ) ppl , 16 * mb_cols ) ;\n for ( mbr = 0 ;\n mbr < mb_rows ;\n mbr ++ ) {\n vp8_post_proc_down_and_across_mb_row ( source -> y_buffer + 16 * mbr * source -> y_stride , source -> y_buffer + 16 * mbr * source -> y_stride , source -> y_stride , source -> y_stride , source -> y_width , limits , 16 ) ;\n if ( uvfilter == 1 ) {\n vp8_post_proc_down_and_across_mb_row ( source -> u_buffer + 8 * mbr * source -> uv_stride , source -> u_buffer + 8 * mbr * source -> uv_stride , source -> uv_stride , source -> uv_stride , source -> uv_width , limits , 8 ) ;\n vp8_post_proc_down_and_across_mb_row ( source -> v_buffer + 8 * mbr * source -> uv_stride , source -> v_buffer + 8 * mbr * source -> uv_stride , source -> uv_stride , source -> uv_stride , source -> uv_width , limits , 8 ) ;\n }\n }\n }", "idx": 21688}
{"hash": -1487877838474751244, "project": "debian", "size": 44, "label": 0, "functionSource": "PHP_FUNCTION ( locale_get_keywords ) {\n UEnumeration * e = NULL ;\n UErrorCode status = U_ZERO_ERROR ;\n const char * kw_key = NULL ;\n int32_t kw_key_len = 0 ;\n const char * loc_name = NULL ;\n int loc_name_len = 0 ;\n char * kw_value = NULL ;\n int32_t kw_value_len = 100 ;\n intl_error_reset ( NULL TSRMLS_CC ) ;\n if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , \"s\" , & loc_name , & loc_name_len ) == FAILURE ) {\n intl_error_set ( NULL , U_ILLEGAL_ARGUMENT_ERROR , \"locale_get_keywords: unable to parse input params\" , 0 TSRMLS_CC ) ;\n RETURN_FALSE ;\n }\n if ( loc_name_len == 0 ) {\n loc_name = intl_locale_get_default ( TSRMLS_C ) ;\n }\n e = uloc_openKeywords ( loc_name , & status ) ;\n if ( e != NULL ) {\n array_init ( return_value ) ;\n while ( ( kw_key = uenum_next ( e , & kw_key_len , & status ) ) != NULL ) {\n kw_value = ecalloc ( 1 , kw_value_len ) ;\n kw_value_len = uloc_getKeywordValue ( loc_name , kw_key , kw_value , kw_value_len , & status ) ;\n if ( status == U_BUFFER_OVERFLOW_ERROR ) {\n status = U_ZERO_ERROR ;\n kw_value = erealloc ( kw_value , kw_value_len + 1 ) ;\n kw_value_len = uloc_getKeywordValue ( loc_name , kw_key , kw_value , kw_value_len + 1 , & status ) ;\n }\n else if ( ! U_FAILURE ( status ) ) {\n kw_value = erealloc ( kw_value , kw_value_len + 1 ) ;\n }\n if ( U_FAILURE ( status ) ) {\n intl_error_set ( NULL , U_ILLEGAL_ARGUMENT_ERROR , \"locale_get_keywords: Error encountered while getting the keyword value for the keyword\" , 0 TSRMLS_CC ) ;\n if ( kw_value ) {\n efree ( kw_value ) ;\n }\n zval_dtor ( return_value ) ;\n RETURN_FALSE ;\n }\n add_assoc_stringl ( return_value , ( char * ) kw_key , kw_value , kw_value_len , 0 ) ;\n }\n }\n uenum_close ( e ) ;\n }", "idx": 21689}
{"hash": 3668456668028959955, "project": "debian", "size": 41, "label": 0, "functionSource": "static void generate_json ( FBuffer * buffer , VALUE Vstate , JSON_Generator_State * state , VALUE obj ) {\n VALUE tmp ;\n VALUE klass = CLASS_OF ( obj ) ;\n if ( klass == rb_cHash ) {\n generate_json_object ( buffer , Vstate , state , obj ) ;\n }\n else if ( klass == rb_cArray ) {\n generate_json_array ( buffer , Vstate , state , obj ) ;\n }\n else if ( klass == rb_cString ) {\n generate_json_string ( buffer , Vstate , state , obj ) ;\n }\n else if ( obj == Qnil ) {\n generate_json_null ( buffer , Vstate , state , obj ) ;\n }\n else if ( obj == Qfalse ) {\n generate_json_false ( buffer , Vstate , state , obj ) ;\n }\n else if ( obj == Qtrue ) {\n generate_json_true ( buffer , Vstate , state , obj ) ;\n }\n else if ( FIXNUM_P ( obj ) ) {\n generate_json_fixnum ( buffer , Vstate , state , obj ) ;\n }\n else if ( RB_TYPE_P ( obj , T_BIGNUM ) ) {\n generate_json_bignum ( buffer , Vstate , state , obj ) ;\n }\n else if ( klass == rb_cFloat ) {\n generate_json_float ( buffer , Vstate , state , obj ) ;\n }\n else if ( rb_respond_to ( obj , i_to_json ) ) {\n tmp = rb_funcall ( obj , i_to_json , 1 , Vstate ) ;\n Check_Type ( tmp , T_STRING ) ;\n fbuffer_append_str ( buffer , tmp ) ;\n }\n else {\n tmp = rb_funcall ( obj , i_to_s , 0 ) ;\n Check_Type ( tmp , T_STRING ) ;\n generate_json_string ( buffer , Vstate , state , tmp ) ;\n }\n }", "idx": 21690}
{"hash": -1983921383858884161, "project": "debian", "size": 64, "label": 0, "functionSource": "static int ipvideo_decode_block_opcode_0x9_16 ( IpvideoContext * s , AVFrame * frame ) {\n int x , y ;\n uint16_t P [ 4 ] ;\n uint16_t * pixel_ptr = ( uint16_t * ) s -> pixel_ptr ;\n for ( x = 0 ;\n x < 4 ;\n x ++ ) P [ x ] = bytestream2_get_le16 ( & s -> stream_ptr ) ;\n if ( ! ( P [ 0 ] & 0x8000 ) ) {\n if ( ! ( P [ 2 ] & 0x8000 ) ) {\n for ( y = 0 ;\n y < 8 ;\n y ++ ) {\n int flags = bytestream2_get_le16 ( & s -> stream_ptr ) ;\n for ( x = 0 ;\n x < 8 ;\n x ++ , flags >>= 2 ) * pixel_ptr ++ = P [ flags & 0x03 ] ;\n pixel_ptr += s -> line_inc ;\n }\n }\n else {\n uint32_t flags ;\n flags = bytestream2_get_le32 ( & s -> stream_ptr ) ;\n for ( y = 0 ;\n y < 8 ;\n y += 2 ) {\n for ( x = 0 ;\n x < 8 ;\n x += 2 , flags >>= 2 ) {\n pixel_ptr [ x ] = pixel_ptr [ x + 1 ] = pixel_ptr [ x + s -> stride ] = pixel_ptr [ x + 1 + s -> stride ] = P [ flags & 0x03 ] ;\n }\n pixel_ptr += s -> stride * 2 ;\n }\n }\n }\n else {\n uint64_t flags ;\n flags = bytestream2_get_le64 ( & s -> stream_ptr ) ;\n if ( ! ( P [ 2 ] & 0x8000 ) ) {\n for ( y = 0 ;\n y < 8 ;\n y ++ ) {\n for ( x = 0 ;\n x < 8 ;\n x += 2 , flags >>= 2 ) {\n pixel_ptr [ x ] = pixel_ptr [ x + 1 ] = P [ flags & 0x03 ] ;\n }\n pixel_ptr += s -> stride ;\n }\n }\n else {\n for ( y = 0 ;\n y < 8 ;\n y += 2 ) {\n for ( x = 0 ;\n x < 8 ;\n x ++ , flags >>= 2 ) {\n pixel_ptr [ x ] = pixel_ptr [ x + s -> stride ] = P [ flags & 0x03 ] ;\n }\n pixel_ptr += s -> stride * 2 ;\n }\n }\n }\n return 0 ;\n }", "idx": 21691}
{"hash": -7049333455584635197, "project": "chrome", "size": 165, "label": 1, "functionSource": "static void _UTF16LEFromUnicodeWithOffsets ( UConverterFromUnicodeArgs * pArgs , UErrorCode * pErrorCode ) {\n UConverter * cnv ;\n const UChar * source ;\n char * target ;\n int32_t * offsets ;\n uint32_t targetCapacity , length , sourceIndex ;\n UChar c , trail ;\n char overflow [ 4 ] ;\n source = pArgs -> source ;\n length = ( int32_t ) ( pArgs -> sourceLimit - source ) ;\n if ( length <= 0 ) {\n return ;\n }\n cnv = pArgs -> converter ;\n if ( cnv -> fromUnicodeStatus == UCNV_NEED_TO_WRITE_BOM ) {\n static const char bom [ ] = {\n ( char ) 0xff , ( char ) 0xfe }\n ;\n ucnv_fromUWriteBytes ( cnv , bom , 2 , & pArgs -> target , pArgs -> targetLimit , & pArgs -> offsets , - 1 , pErrorCode ) ;\n cnv -> fromUnicodeStatus = 0 ;\n }\n target = pArgs -> target ;\n if ( target >= pArgs -> targetLimit ) {\n * pErrorCode = U_BUFFER_OVERFLOW_ERROR ;\n return ;\n }\n targetCapacity = ( uint32_t ) ( pArgs -> targetLimit - pArgs -> target ) ;\n offsets = pArgs -> offsets ;\n sourceIndex = 0 ;\n if ( ( c = ( UChar ) cnv -> fromUChar32 ) != 0 && U16_IS_TRAIL ( trail = * source ) && targetCapacity >= 4 ) {\n ++ source ;\n -- length ;\n target [ 0 ] = ( uint8_t ) c ;\n target [ 1 ] = ( uint8_t ) ( c >> 8 ) ;\n target [ 2 ] = ( uint8_t ) trail ;\n target [ 3 ] = ( uint8_t ) ( trail >> 8 ) ;\n target += 4 ;\n targetCapacity -= 4 ;\n if ( offsets != NULL ) {\n * offsets ++ = - 1 ;\n * offsets ++ = - 1 ;\n * offsets ++ = - 1 ;\n * offsets ++ = - 1 ;\n }\n sourceIndex = 1 ;\n cnv -> fromUChar32 = c = 0 ;\n }\n if ( c == 0 ) {\n uint32_t count = 2 * length ;\n if ( count > targetCapacity ) {\n count = targetCapacity & ~ 1 ;\n }\n targetCapacity -= count ;\n count >>= 1 ;\n length -= count ;\n if ( offsets == NULL ) {\n while ( count > 0 ) {\n c = * source ++ ;\n if ( U16_IS_SINGLE ( c ) ) {\n target [ 0 ] = ( uint8_t ) c ;\n target [ 1 ] = ( uint8_t ) ( c >> 8 ) ;\n target += 2 ;\n }\n else if ( U16_IS_SURROGATE_LEAD ( c ) && count >= 2 && U16_IS_TRAIL ( trail = * source ) ) {\n ++ source ;\n -- count ;\n target [ 0 ] = ( uint8_t ) c ;\n target [ 1 ] = ( uint8_t ) ( c >> 8 ) ;\n target [ 2 ] = ( uint8_t ) trail ;\n target [ 3 ] = ( uint8_t ) ( trail >> 8 ) ;\n target += 4 ;\n }\n else {\n break ;\n }\n -- count ;\n }\n }\n else {\n while ( count > 0 ) {\n c = * source ++ ;\n if ( U16_IS_SINGLE ( c ) ) {\n target [ 0 ] = ( uint8_t ) c ;\n target [ 1 ] = ( uint8_t ) ( c >> 8 ) ;\n target += 2 ;\n * offsets ++ = sourceIndex ;\n * offsets ++ = sourceIndex ++ ;\n }\n else if ( U16_IS_SURROGATE_LEAD ( c ) && count >= 2 && U16_IS_TRAIL ( trail = * source ) ) {\n ++ source ;\n -- count ;\n target [ 0 ] = ( uint8_t ) c ;\n target [ 1 ] = ( uint8_t ) ( c >> 8 ) ;\n target [ 2 ] = ( uint8_t ) trail ;\n target [ 3 ] = ( uint8_t ) ( trail >> 8 ) ;\n target += 4 ;\n * offsets ++ = sourceIndex ;\n * offsets ++ = sourceIndex ;\n * offsets ++ = sourceIndex ;\n * offsets ++ = sourceIndex ;\n sourceIndex += 2 ;\n }\n else {\n break ;\n }\n -- count ;\n }\n }\n if ( count == 0 ) {\n if ( length > 0 && targetCapacity > 0 ) {\n if ( U16_IS_SINGLE ( c = * source ++ ) ) {\n overflow [ 0 ] = ( char ) c ;\n overflow [ 1 ] = ( char ) ( c >> 8 ) ;\n length = 2 ;\n c = 0 ;\n }\n }\n else {\n length = 0 ;\n c = 0 ;\n }\n }\n else {\n targetCapacity += 2 * count ;\n }\n }\n else {\n length = 0 ;\n }\n if ( c != 0 ) {\n length = 0 ;\n if ( U16_IS_SURROGATE_LEAD ( c ) ) {\n if ( source < pArgs -> sourceLimit ) {\n if ( U16_IS_TRAIL ( trail = * source ) ) {\n ++ source ;\n overflow [ 0 ] = ( char ) c ;\n overflow [ 1 ] = ( char ) ( c >> 8 ) ;\n overflow [ 2 ] = ( char ) trail ;\n overflow [ 3 ] = ( char ) ( trail >> 8 ) ;\n length = 4 ;\n c = 0 ;\n }\n else {\n * pErrorCode = U_ILLEGAL_CHAR_FOUND ;\n }\n }\n else {\n }\n }\n else {\n * pErrorCode = U_ILLEGAL_CHAR_FOUND ;\n }\n cnv -> fromUChar32 = c ;\n }\n if ( length > 0 ) {\n ucnv_fromUWriteBytes ( cnv , overflow , length , & target , pArgs -> targetLimit , & offsets , sourceIndex , pErrorCode ) ;\n targetCapacity = ( uint32_t ) ( pArgs -> targetLimit - ( char * ) target ) ;\n }\n if ( U_SUCCESS ( * pErrorCode ) && source < pArgs -> sourceLimit && targetCapacity == 0 ) {\n * pErrorCode = U_BUFFER_OVERFLOW_ERROR ;\n }\n pArgs -> source = source ;\n pArgs -> target = target ;\n pArgs -> offsets = offsets ;\n }", "idx": 21692}
{"hash": -5279853345356125001, "project": "debian", "size": 361, "label": 0, "functionSource": "static void pimv2_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , const u_char * bp2 ) {\n register const u_char * ep ;\n register const struct pim * pim = ( const struct pim * ) bp ;\n int advance ;\n enum checksum_status cksum_status ;\n ep = ( const u_char * ) ndo -> ndo_snapend ;\n if ( bp >= ep ) return ;\n if ( ep > bp + len ) ep = bp + len ;\n ND_TCHECK ( pim -> pim_rsv ) ;\n pimv2_addr_len = pim -> pim_rsv ;\n if ( pimv2_addr_len != 0 ) ND_PRINT ( ( ndo , \", RFC2117-encoding\" ) ) ;\n ND_PRINT ( ( ndo , \", cksum 0x%04x \" , EXTRACT_16BITS ( & pim -> pim_cksum ) ) ) ;\n if ( EXTRACT_16BITS ( & pim -> pim_cksum ) == 0 ) {\n ND_PRINT ( ( ndo , \"(unverified)\" ) ) ;\n }\n else {\n if ( PIM_TYPE ( pim -> pim_typever ) == PIMV2_TYPE_REGISTER ) {\n cksum_status = pimv2_check_checksum ( ndo , bp , bp2 , 8 ) ;\n if ( cksum_status == INCORRECT ) {\n cksum_status = pimv2_check_checksum ( ndo , bp , bp2 , len ) ;\n }\n }\n else {\n cksum_status = pimv2_check_checksum ( ndo , bp , bp2 , len ) ;\n }\n switch ( cksum_status ) {\n case CORRECT : ND_PRINT ( ( ndo , \"(correct)\" ) ) ;\n break ;\n case INCORRECT : ND_PRINT ( ( ndo , \"(incorrect)\" ) ) ;\n break ;\n case UNVERIFIED : ND_PRINT ( ( ndo , \"(unverified)\" ) ) ;\n break ;\n }\n }\n switch ( PIM_TYPE ( pim -> pim_typever ) ) {\n case PIMV2_TYPE_HELLO : {\n uint16_t otype , olen ;\n bp += 4 ;\n while ( bp < ep ) {\n ND_TCHECK2 ( bp [ 0 ] , 4 ) ;\n otype = EXTRACT_16BITS ( & bp [ 0 ] ) ;\n olen = EXTRACT_16BITS ( & bp [ 2 ] ) ;\n ND_TCHECK2 ( bp [ 0 ] , 4 + olen ) ;\n ND_PRINT ( ( ndo , \"\\n\\t %s Option (%u), length %u, Value: \" , tok2str ( pimv2_hello_option_values , \"Unknown\" , otype ) , otype , olen ) ) ;\n bp += 4 ;\n switch ( otype ) {\n case PIMV2_HELLO_OPTION_HOLDTIME : unsigned_relts_print ( ndo , EXTRACT_16BITS ( bp ) ) ;\n break ;\n case PIMV2_HELLO_OPTION_LANPRUNEDELAY : if ( olen != 4 ) {\n ND_PRINT ( ( ndo , \"ERROR: Option Length != 4 Bytes (%u)\" , olen ) ) ;\n }\n else {\n char t_bit ;\n uint16_t lan_delay , override_interval ;\n lan_delay = EXTRACT_16BITS ( bp ) ;\n override_interval = EXTRACT_16BITS ( bp + 2 ) ;\n t_bit = ( lan_delay & 0x8000 ) ? 1 : 0 ;\n lan_delay &= ~ 0x8000 ;\n ND_PRINT ( ( ndo , \"\\n\\t T-bit=%d, LAN delay %dms, Override interval %dms\" , t_bit , lan_delay , override_interval ) ) ;\n }\n break ;\n case PIMV2_HELLO_OPTION_DR_PRIORITY_OLD : case PIMV2_HELLO_OPTION_DR_PRIORITY : switch ( olen ) {\n case 0 : ND_PRINT ( ( ndo , \"Bi-Directional Capability (Old)\" ) ) ;\n break ;\n case 4 : ND_PRINT ( ( ndo , \"%u\" , EXTRACT_32BITS ( bp ) ) ) ;\n break ;\n default : ND_PRINT ( ( ndo , \"ERROR: Option Length != 4 Bytes (%u)\" , olen ) ) ;\n break ;\n }\n break ;\n case PIMV2_HELLO_OPTION_GENID : ND_PRINT ( ( ndo , \"0x%08x\" , EXTRACT_32BITS ( bp ) ) ) ;\n break ;\n case PIMV2_HELLO_OPTION_REFRESH_CAP : ND_PRINT ( ( ndo , \"v%d\" , * bp ) ) ;\n if ( * ( bp + 1 ) != 0 ) {\n ND_PRINT ( ( ndo , \", interval \" ) ) ;\n unsigned_relts_print ( ndo , * ( bp + 1 ) ) ;\n }\n if ( EXTRACT_16BITS ( bp + 2 ) != 0 ) {\n ND_PRINT ( ( ndo , \" ?0x%04x?\" , EXTRACT_16BITS ( bp + 2 ) ) ) ;\n }\n break ;\n case PIMV2_HELLO_OPTION_BIDIR_CAP : break ;\n case PIMV2_HELLO_OPTION_ADDRESS_LIST_OLD : case PIMV2_HELLO_OPTION_ADDRESS_LIST : if ( ndo -> ndo_vflag > 1 ) {\n const u_char * ptr = bp ;\n while ( ptr < ( bp + olen ) ) {\n ND_PRINT ( ( ndo , \"\\n\\t \" ) ) ;\n advance = pimv2_addr_print ( ndo , ptr , pimv2_unicast , 0 ) ;\n if ( advance < 0 ) {\n ND_PRINT ( ( ndo , \"...\" ) ) ;\n break ;\n }\n ptr += advance ;\n }\n }\n break ;\n default : if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , bp , \"\\n\\t \" , olen ) ;\n break ;\n }\n if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , bp , \"\\n\\t \" , olen ) ;\n bp += olen ;\n }\n break ;\n }\n case PIMV2_TYPE_REGISTER : {\n const struct ip * ip ;\n ND_TCHECK2 ( * ( bp + 4 ) , PIMV2_REGISTER_FLAG_LEN ) ;\n ND_PRINT ( ( ndo , \", Flags [ %s ]\\n\\t\" , tok2str ( pimv2_register_flag_values , \"none\" , EXTRACT_32BITS ( bp + 4 ) ) ) ) ;\n bp += 8 ;\n len -= 8 ;\n ip = ( const struct ip * ) bp ;\n switch ( IP_V ( ip ) ) {\n case 0 : ND_PRINT ( ( ndo , \"IP-Null-header %s > %s\" , ipaddr_string ( ndo , & ip -> ip_src ) , ipaddr_string ( ndo , & ip -> ip_dst ) ) ) ;\n break ;\n case 4 : ip_print ( ndo , bp , len ) ;\n break ;\n case 6 : ip6_print ( ndo , bp , len ) ;\n break ;\n default : ND_PRINT ( ( ndo , \"IP ver %d\" , IP_V ( ip ) ) ) ;\n break ;\n }\n break ;\n }\n case PIMV2_TYPE_REGISTER_STOP : bp += 4 ;\n len -= 4 ;\n if ( bp >= ep ) break ;\n ND_PRINT ( ( ndo , \" group=\" ) ) ;\n if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_group , 0 ) ) < 0 ) {\n ND_PRINT ( ( ndo , \"...\" ) ) ;\n break ;\n }\n bp += advance ;\n len -= advance ;\n if ( bp >= ep ) break ;\n ND_PRINT ( ( ndo , \" source=\" ) ) ;\n if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_unicast , 0 ) ) < 0 ) {\n ND_PRINT ( ( ndo , \"...\" ) ) ;\n break ;\n }\n bp += advance ;\n len -= advance ;\n break ;\n case PIMV2_TYPE_JOIN_PRUNE : case PIMV2_TYPE_GRAFT : case PIMV2_TYPE_GRAFT_ACK : {\n uint8_t ngroup ;\n uint16_t holdtime ;\n uint16_t njoin ;\n uint16_t nprune ;\n int i , j ;\n bp += 4 ;\n len -= 4 ;\n if ( PIM_TYPE ( pim -> pim_typever ) != 7 ) {\n if ( bp >= ep ) break ;\n ND_PRINT ( ( ndo , \", upstream-neighbor: \" ) ) ;\n if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_unicast , 0 ) ) < 0 ) {\n ND_PRINT ( ( ndo , \"...\" ) ) ;\n break ;\n }\n bp += advance ;\n len -= advance ;\n }\n if ( bp + 4 > ep ) break ;\n ngroup = bp [ 1 ] ;\n holdtime = EXTRACT_16BITS ( & bp [ 2 ] ) ;\n ND_PRINT ( ( ndo , \"\\n\\t %u group(s)\" , ngroup ) ) ;\n if ( PIM_TYPE ( pim -> pim_typever ) != 7 ) {\n ND_PRINT ( ( ndo , \", holdtime: \" ) ) ;\n if ( holdtime == 0xffff ) ND_PRINT ( ( ndo , \"infinite\" ) ) ;\n else unsigned_relts_print ( ndo , holdtime ) ;\n }\n bp += 4 ;\n len -= 4 ;\n for ( i = 0 ;\n i < ngroup ;\n i ++ ) {\n if ( bp >= ep ) goto jp_done ;\n ND_PRINT ( ( ndo , \"\\n\\t group #%u: \" , i + 1 ) ) ;\n if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_group , 0 ) ) < 0 ) {\n ND_PRINT ( ( ndo , \"...)\" ) ) ;\n goto jp_done ;\n }\n bp += advance ;\n len -= advance ;\n if ( bp + 4 > ep ) {\n ND_PRINT ( ( ndo , \"...)\" ) ) ;\n goto jp_done ;\n }\n njoin = EXTRACT_16BITS ( & bp [ 0 ] ) ;\n nprune = EXTRACT_16BITS ( & bp [ 2 ] ) ;\n ND_PRINT ( ( ndo , \", joined sources: %u, pruned sources: %u\" , njoin , nprune ) ) ;\n bp += 4 ;\n len -= 4 ;\n for ( j = 0 ;\n j < njoin ;\n j ++ ) {\n ND_PRINT ( ( ndo , \"\\n\\t joined source #%u: \" , j + 1 ) ) ;\n if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_source , 0 ) ) < 0 ) {\n ND_PRINT ( ( ndo , \"...)\" ) ) ;\n goto jp_done ;\n }\n bp += advance ;\n len -= advance ;\n }\n for ( j = 0 ;\n j < nprune ;\n j ++ ) {\n ND_PRINT ( ( ndo , \"\\n\\t pruned source #%u: \" , j + 1 ) ) ;\n if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_source , 0 ) ) < 0 ) {\n ND_PRINT ( ( ndo , \"...)\" ) ) ;\n goto jp_done ;\n }\n bp += advance ;\n len -= advance ;\n }\n }\n jp_done : break ;\n }\n case PIMV2_TYPE_BOOTSTRAP : {\n int i , j , frpcnt ;\n bp += 4 ;\n if ( bp + sizeof ( uint16_t ) >= ep ) break ;\n ND_PRINT ( ( ndo , \" tag=%x\" , EXTRACT_16BITS ( bp ) ) ) ;\n bp += sizeof ( uint16_t ) ;\n if ( bp >= ep ) break ;\n ND_PRINT ( ( ndo , \" hashmlen=%d\" , bp [ 0 ] ) ) ;\n if ( bp + 1 >= ep ) break ;\n ND_PRINT ( ( ndo , \" BSRprio=%d\" , bp [ 1 ] ) ) ;\n bp += 2 ;\n if ( bp >= ep ) break ;\n ND_PRINT ( ( ndo , \" BSR=\" ) ) ;\n if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_unicast , 0 ) ) < 0 ) {\n ND_PRINT ( ( ndo , \"...\" ) ) ;\n break ;\n }\n bp += advance ;\n for ( i = 0 ;\n bp < ep ;\n i ++ ) {\n ND_PRINT ( ( ndo , \" (group%d: \" , i ) ) ;\n if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_group , 0 ) ) < 0 ) {\n ND_PRINT ( ( ndo , \"...)\" ) ) ;\n goto bs_done ;\n }\n bp += advance ;\n if ( bp >= ep ) {\n ND_PRINT ( ( ndo , \"...)\" ) ) ;\n goto bs_done ;\n }\n ND_PRINT ( ( ndo , \" RPcnt=%d\" , bp [ 0 ] ) ) ;\n if ( bp + 1 >= ep ) {\n ND_PRINT ( ( ndo , \"...)\" ) ) ;\n goto bs_done ;\n }\n ND_PRINT ( ( ndo , \" FRPcnt=%d\" , frpcnt = bp [ 1 ] ) ) ;\n bp += 4 ;\n for ( j = 0 ;\n j < frpcnt && bp < ep ;\n j ++ ) {\n ND_PRINT ( ( ndo , \" RP%d=\" , j ) ) ;\n if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_unicast , 0 ) ) < 0 ) {\n ND_PRINT ( ( ndo , \"...)\" ) ) ;\n goto bs_done ;\n }\n bp += advance ;\n if ( bp + 1 >= ep ) {\n ND_PRINT ( ( ndo , \"...)\" ) ) ;\n goto bs_done ;\n }\n ND_PRINT ( ( ndo , \",holdtime=\" ) ) ;\n unsigned_relts_print ( ndo , EXTRACT_16BITS ( bp ) ) ;\n if ( bp + 2 >= ep ) {\n ND_PRINT ( ( ndo , \"...)\" ) ) ;\n goto bs_done ;\n }\n ND_PRINT ( ( ndo , \",prio=%d\" , bp [ 2 ] ) ) ;\n bp += 4 ;\n }\n ND_PRINT ( ( ndo , \")\" ) ) ;\n }\n bs_done : break ;\n }\n case PIMV2_TYPE_ASSERT : bp += 4 ;\n len -= 4 ;\n if ( bp >= ep ) break ;\n ND_PRINT ( ( ndo , \" group=\" ) ) ;\n if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_group , 0 ) ) < 0 ) {\n ND_PRINT ( ( ndo , \"...\" ) ) ;\n break ;\n }\n bp += advance ;\n len -= advance ;\n if ( bp >= ep ) break ;\n ND_PRINT ( ( ndo , \" src=\" ) ) ;\n if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_unicast , 0 ) ) < 0 ) {\n ND_PRINT ( ( ndo , \"...\" ) ) ;\n break ;\n }\n bp += advance ;\n len -= advance ;\n if ( bp + 8 > ep ) break ;\n if ( bp [ 0 ] & 0x80 ) ND_PRINT ( ( ndo , \" RPT\" ) ) ;\n ND_PRINT ( ( ndo , \" pref=%u\" , EXTRACT_32BITS ( & bp [ 0 ] ) & 0x7fffffff ) ) ;\n ND_PRINT ( ( ndo , \" metric=%u\" , EXTRACT_32BITS ( & bp [ 4 ] ) ) ) ;\n break ;\n case PIMV2_TYPE_CANDIDATE_RP : {\n int i , pfxcnt ;\n bp += 4 ;\n if ( bp >= ep ) break ;\n ND_PRINT ( ( ndo , \" prefix-cnt=%d\" , bp [ 0 ] ) ) ;\n pfxcnt = bp [ 0 ] ;\n if ( bp + 1 >= ep ) break ;\n ND_PRINT ( ( ndo , \" prio=%d\" , bp [ 1 ] ) ) ;\n if ( bp + 3 >= ep ) break ;\n ND_PRINT ( ( ndo , \" holdtime=\" ) ) ;\n unsigned_relts_print ( ndo , EXTRACT_16BITS ( & bp [ 2 ] ) ) ;\n bp += 4 ;\n if ( bp >= ep ) break ;\n ND_PRINT ( ( ndo , \" RP=\" ) ) ;\n if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_unicast , 0 ) ) < 0 ) {\n ND_PRINT ( ( ndo , \"...\" ) ) ;\n break ;\n }\n bp += advance ;\n for ( i = 0 ;\n i < pfxcnt && bp < ep ;\n i ++ ) {\n ND_PRINT ( ( ndo , \" Group%d=\" , i ) ) ;\n if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_group , 0 ) ) < 0 ) {\n ND_PRINT ( ( ndo , \"...\" ) ) ;\n break ;\n }\n bp += advance ;\n }\n break ;\n }\n case PIMV2_TYPE_PRUNE_REFRESH : ND_PRINT ( ( ndo , \" src=\" ) ) ;\n if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_unicast , 0 ) ) < 0 ) {\n ND_PRINT ( ( ndo , \"...\" ) ) ;\n break ;\n }\n bp += advance ;\n ND_PRINT ( ( ndo , \" grp=\" ) ) ;\n if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_group , 0 ) ) < 0 ) {\n ND_PRINT ( ( ndo , \"...\" ) ) ;\n break ;\n }\n bp += advance ;\n ND_PRINT ( ( ndo , \" forwarder=\" ) ) ;\n if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_unicast , 0 ) ) < 0 ) {\n ND_PRINT ( ( ndo , \"...\" ) ) ;\n break ;\n }\n bp += advance ;\n ND_TCHECK2 ( bp [ 0 ] , 2 ) ;\n ND_PRINT ( ( ndo , \" TUNR \" ) ) ;\n unsigned_relts_print ( ndo , EXTRACT_16BITS ( bp ) ) ;\n break ;\n default : ND_PRINT ( ( ndo , \" [type %d]\" , PIM_TYPE ( pim -> pim_typever ) ) ) ;\n break ;\n }\n return ;\n trunc : ND_PRINT ( ( ndo , \"[|pim]\" ) ) ;\n }", "idx": 21693}
{"hash": 3887066622454352196, "project": "chrome", "size": 48, "label": 0, "functionSource": "void vp9_rd_pick_intra_mode_sb ( VP9_COMP * cpi , MACROBLOCK * x , int * returnrate , int64_t * returndist , BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx , int64_t best_rd ) {\n VP9_COMMON * const cm = & cpi -> common ;\n MACROBLOCKD * const xd = & x -> e_mbd ;\n struct macroblockd_plane * const pd = xd -> plane ;\n int rate_y = 0 , rate_uv = 0 , rate_y_tokenonly = 0 , rate_uv_tokenonly = 0 ;\n int y_skip = 0 , uv_skip = 0 ;\n int64_t dist_y = 0 , dist_uv = 0 , tx_cache [ TX_MODES ] = {\n 0 }\n ;\n TX_SIZE max_uv_tx_size ;\n x -> skip_encode = 0 ;\n ctx -> skip = 0 ;\n xd -> mi [ 0 ] . src_mi -> mbmi . ref_frame [ 0 ] = INTRA_FRAME ;\n if ( bsize >= BLOCK_8X8 ) {\n if ( rd_pick_intra_sby_mode ( cpi , x , & rate_y , & rate_y_tokenonly , & dist_y , & y_skip , bsize , tx_cache , best_rd ) >= best_rd ) {\n * returnrate = INT_MAX ;\n return ;\n }\n max_uv_tx_size = get_uv_tx_size_impl ( xd -> mi [ 0 ] . src_mi -> mbmi . tx_size , bsize , pd [ 1 ] . subsampling_x , pd [ 1 ] . subsampling_y ) ;\n rd_pick_intra_sbuv_mode ( cpi , x , ctx , & rate_uv , & rate_uv_tokenonly , & dist_uv , & uv_skip , bsize , max_uv_tx_size ) ;\n }\n else {\n y_skip = 0 ;\n if ( rd_pick_intra_sub_8x8_y_mode ( cpi , x , & rate_y , & rate_y_tokenonly , & dist_y , best_rd ) >= best_rd ) {\n * returnrate = INT_MAX ;\n return ;\n }\n max_uv_tx_size = get_uv_tx_size_impl ( xd -> mi [ 0 ] . src_mi -> mbmi . tx_size , bsize , pd [ 1 ] . subsampling_x , pd [ 1 ] . subsampling_y ) ;\n rd_pick_intra_sbuv_mode ( cpi , x , ctx , & rate_uv , & rate_uv_tokenonly , & dist_uv , & uv_skip , BLOCK_8X8 , max_uv_tx_size ) ;\n }\n if ( y_skip && uv_skip ) {\n * returnrate = rate_y + rate_uv - rate_y_tokenonly - rate_uv_tokenonly + vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 1 ) ;\n * returndist = dist_y + dist_uv ;\n vp9_zero ( ctx -> tx_rd_diff ) ;\n }\n else {\n int i ;\n * returnrate = rate_y + rate_uv + vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 0 ) ;\n * returndist = dist_y + dist_uv ;\n if ( cpi -> sf . tx_size_search_method == USE_FULL_RD ) for ( i = 0 ;\n i < TX_MODES ;\n i ++ ) {\n if ( tx_cache [ i ] < INT64_MAX && tx_cache [ cm -> tx_mode ] < INT64_MAX ) ctx -> tx_rd_diff [ i ] = tx_cache [ i ] - tx_cache [ cm -> tx_mode ] ;\n else ctx -> tx_rd_diff [ i ] = 0 ;\n }\n }\n ctx -> mic = * xd -> mi [ 0 ] . src_mi ;\n }", "idx": 21694}
{"hash": 561876472800374387, "project": "debian", "size": 5, "label": 0, "functionSource": "void RECORD_LAYER_init ( RECORD_LAYER * rl , SSL * s ) {\n rl -> s = s ;\n RECORD_LAYER_set_first_record ( & s -> rlayer ) ;\n SSL3_RECORD_clear ( rl -> rrec , SSL_MAX_PIPELINES ) ;\n }", "idx": 21695}
{"hash": -7131177824150194183, "project": "debian", "size": 45, "label": 0, "functionSource": "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * pkt ) {\n BinkContext * const c = avctx -> priv_data ;\n AVFrame * frame = data ;\n GetBitContext gb ;\n int plane , plane_idx , ret ;\n int bits_count = pkt -> size << 3 ;\n if ( c -> version > 'b' ) {\n if ( ( ret = ff_get_buffer ( avctx , frame , AV_GET_BUFFER_FLAG_REF ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n }\n else {\n if ( ( ret = ff_reget_buffer ( avctx , c -> last ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"reget_buffer() failed\\n\" ) ;\n return ret ;\n }\n if ( ( ret = av_frame_ref ( frame , c -> last ) ) < 0 ) return ret ;\n }\n init_get_bits ( & gb , pkt -> data , bits_count ) ;\n if ( c -> has_alpha ) {\n if ( c -> version >= 'i' ) skip_bits_long ( & gb , 32 ) ;\n if ( ( ret = bink_decode_plane ( c , frame , & gb , 3 , 0 ) ) < 0 ) return ret ;\n }\n if ( c -> version >= 'i' ) skip_bits_long ( & gb , 32 ) ;\n for ( plane = 0 ;\n plane < 3 ;\n plane ++ ) {\n plane_idx = ( ! plane || ! c -> swap_planes ) ? plane : ( plane ^ 3 ) ;\n if ( c -> version > 'b' ) {\n if ( ( ret = bink_decode_plane ( c , frame , & gb , plane_idx , ! ! plane ) ) < 0 ) return ret ;\n }\n else {\n if ( ( ret = binkb_decode_plane ( c , frame , & gb , plane_idx , ! avctx -> frame_number , ! ! plane ) ) < 0 ) return ret ;\n }\n if ( get_bits_count ( & gb ) >= bits_count ) break ;\n }\n emms_c ( ) ;\n if ( c -> version > 'b' ) {\n av_frame_unref ( c -> last ) ;\n if ( ( ret = av_frame_ref ( c -> last , frame ) ) < 0 ) return ret ;\n }\n * got_frame = 1 ;\n return pkt -> size ;\n }", "idx": 21696}
{"hash": 8415334249344417068, "project": "debian", "size": 9, "label": 0, "functionSource": "void proto_register_u3v ( void ) {\n static gint * ett [ ] = {\n & ett_u3v , & ett_u3v_cmd , & ett_u3v_flags , & ett_u3v_ack , & ett_u3v_payload_cmd , & ett_u3v_payload_ack , & ett_u3v_payload_ack_subtree , & ett_u3v_payload_cmd_subtree , & ett_u3v_bootstrap_fields , & ett_u3v_stream_leader , & ett_u3v_stream_trailer , & ett_u3v_stream_payload , & ett_u3v_device_info_descriptor , & ett_u3v_device_info_descriptor_speed_support , & ett_u3v_device_info_descriptor_gencp_version , & ett_u3v_device_info_descriptor_u3v_version , }\n ;\n proto_u3v = proto_register_protocol ( \"USB 3 Vision\" , \"U3V\" , \"u3v\" ) ;\n proto_register_field_array ( proto_u3v , hf , array_length ( hf ) ) ;\n proto_register_subtree_array ( ett , array_length ( ett ) ) ;\n register_dissector ( \"u3v\" , dissect_u3v , proto_u3v ) ;\n }", "idx": 21697}
{"hash": 6675626110148442062, "project": "debian", "size": 9, "label": 0, "functionSource": "int jas_stream_puts ( jas_stream_t * stream , const char * s ) {\n while ( * s != '\\0' ) {\n if ( jas_stream_putc_macro ( stream , * s ) == EOF ) {\n return - 1 ;\n }\n ++ s ;\n }\n return 0 ;\n }", "idx": 21698}
{"hash": -7777644912037188223, "project": "debian", "size": 94, "label": 1, "functionSource": "static int decode_udvm_multitype_operand ( guint8 * buff , guint operand_address , guint16 * value ) {\n guint test_bits ;\n guint bytecode ;\n guint offset = operand_address ;\n guint16 operand ;\n guint32 result ;\n guint8 temp_data ;\n guint16 temp_data16 ;\n guint16 memmory_addr = 0 ;\n * value = 0 ;\n bytecode = buff [ operand_address ] ;\n test_bits = ( bytecode & 0xc0 ) >> 6 ;\n switch ( test_bits ) {\n case 0 : operand = buff [ operand_address ] ;\n * value = operand ;\n offset ++ ;\n break ;\n case 1 : memmory_addr = ( bytecode & 0x3f ) * 2 ;\n temp_data16 = buff [ memmory_addr ] << 8 ;\n temp_data16 = temp_data16 | buff [ ( memmory_addr + 1 ) & 0xffff ] ;\n * value = temp_data16 ;\n offset ++ ;\n break ;\n case 2 : test_bits = ( bytecode & 0xe0 ) >> 5 ;\n if ( test_bits == 5 ) {\n temp_data = buff [ operand_address ] & 0x1f ;\n operand = temp_data << 8 ;\n temp_data = buff [ ( operand_address + 1 ) & 0xffff ] ;\n operand = operand | temp_data ;\n * value = operand ;\n offset = offset + 2 ;\n }\n else {\n test_bits = ( bytecode & 0xf0 ) >> 4 ;\n if ( test_bits == 9 ) {\n temp_data = buff [ operand_address ] & 0x0f ;\n operand = temp_data << 8 ;\n temp_data = buff [ ( operand_address + 1 ) & 0xffff ] ;\n operand = operand | temp_data ;\n operand = operand + 61440 ;\n * value = operand ;\n offset = offset + 2 ;\n }\n else {\n test_bits = ( bytecode & 0x08 ) >> 3 ;\n if ( test_bits == 1 ) {\n result = 1 << ( ( buff [ operand_address ] & 0x07 ) + 8 ) ;\n operand = result & 0xffff ;\n * value = operand ;\n offset ++ ;\n }\n else {\n test_bits = ( bytecode & 0x0e ) >> 1 ;\n if ( test_bits == 3 ) {\n result = 1 << ( ( buff [ operand_address ] & 0x01 ) + 6 ) ;\n operand = result & 0xffff ;\n * value = operand ;\n offset ++ ;\n }\n else {\n offset ++ ;\n temp_data16 = buff [ ( operand_address + 1 ) & 0xffff ] << 8 ;\n temp_data16 = temp_data16 | buff [ ( operand_address + 2 ) & 0xffff ] ;\n if ( ( bytecode & 0x01 ) == 1 ) {\n memmory_addr = temp_data16 ;\n temp_data16 = buff [ memmory_addr ] << 8 ;\n temp_data16 = temp_data16 | buff [ ( memmory_addr + 1 ) & 0xffff ] ;\n }\n * value = temp_data16 ;\n offset = offset + 2 ;\n }\n }\n }\n }\n break ;\n case 3 : test_bits = ( bytecode & 0x20 ) >> 5 ;\n if ( test_bits == 1 ) {\n operand = ( buff [ operand_address ] & 0x1f ) + 65504 ;\n * value = operand ;\n offset ++ ;\n }\n else {\n memmory_addr = buff [ operand_address ] & 0x1f ;\n memmory_addr = memmory_addr << 8 ;\n memmory_addr = memmory_addr | buff [ ( operand_address + 1 ) & 0xffff ] ;\n temp_data16 = buff [ memmory_addr ] << 8 ;\n temp_data16 = temp_data16 | buff [ ( memmory_addr + 1 ) & 0xffff ] ;\n * value = temp_data16 ;\n offset = offset + 2 ;\n }\n default : break ;\n }\n return offset ;\n }", "idx": 21699}
{"hash": -8919449269326401539, "project": "debian", "size": 11, "label": 0, "functionSource": "void proto_reg_handoff_cipsafety ( void ) {\n dissector_handle_t cip_class_s_supervisor_handle ;\n cip_class_s_supervisor_handle = create_dissector_handle ( dissect_cip_class_s_supervisor , proto_cip_class_s_supervisor ) ;\n dissector_add_uint ( \"cip.class.iface\" , CI_CLS_SAFETY_SUPERVISOR , cip_class_s_supervisor_handle ) ;\n cip_class_s_validator_handle = create_dissector_handle ( dissect_cip_class_s_validator , proto_cip_class_s_validator ) ;\n dissector_add_uint ( \"cip.class.iface\" , CI_CLS_SAFETY_VALIDATOR , cip_class_s_validator_handle ) ;\n heur_dissector_add ( \"cip.sc\" , dissect_class_svalidator_heur , \"CIP Safety Validator\" , \"s_validator_cip\" , proto_cip_class_s_validator , HEURISTIC_ENABLE ) ;\n dissector_add_for_decode_as ( \"enip.io\" , cipsafety_handle ) ;\n proto_cip = proto_get_id_by_filter_name ( \"cip\" ) ;\n subdissector_class_table = find_dissector_table ( \"cip.class.iface\" ) ;\n }", "idx": 21700}
{"hash": 7072059544915633710, "project": "chrome", "size": 404, "label": 0, "functionSource": "static void U_CALLCONV _LMBCSOpen ## n ( UConverter * _this , UConverterLoadArgs * pArgs , UErrorCode * err ) \\ {\n _LMBCSOpenWorker ( _this , pArgs , err , n ) ;\n }\n static void _LMBCSOpenWorker ( UConverter * _this , UConverterLoadArgs * pArgs , UErrorCode * err , ulmbcs_byte_t OptGroup ) {\n UConverterDataLMBCS * extraInfo = ( UConverterDataLMBCS * ) uprv_malloc ( sizeof ( UConverterDataLMBCS ) ) ;\n _this -> extraInfo = extraInfo ;\n if ( extraInfo != NULL ) {\n UConverterNamePieces stackPieces ;\n UConverterLoadArgs stackArgs = UCNV_LOAD_ARGS_INITIALIZER ;\n ulmbcs_byte_t i ;\n uprv_memset ( extraInfo , 0 , sizeof ( UConverterDataLMBCS ) ) ;\n stackArgs . onlyTestIsLoadable = pArgs -> onlyTestIsLoadable ;\n for ( i = 0 ;\n i <= ULMBCS_GRP_LAST && U_SUCCESS ( * err ) ;\n i ++ ) {\n if ( OptGroupByteToCPName [ i ] != NULL ) {\n extraInfo -> OptGrpConverter [ i ] = ucnv_loadSharedData ( OptGroupByteToCPName [ i ] , & stackPieces , & stackArgs , err ) ;\n }\n }\n if ( U_FAILURE ( * err ) || pArgs -> onlyTestIsLoadable ) {\n _LMBCSClose ( _this ) ;\n return ;\n }\n extraInfo -> OptGroup = OptGroup ;\n extraInfo -> localeConverterIndex = FindLMBCSLocale ( pArgs -> locale ) ;\n }\n else {\n * err = U_MEMORY_ALLOCATION_ERROR ;\n }\n }\n U_CDECL_BEGIN static void U_CALLCONV _LMBCSClose ( UConverter * _this ) {\n if ( _this -> extraInfo != NULL ) {\n ulmbcs_byte_t Ix ;\n UConverterDataLMBCS * extraInfo = ( UConverterDataLMBCS * ) _this -> extraInfo ;\n for ( Ix = 0 ;\n Ix <= ULMBCS_GRP_LAST ;\n Ix ++ ) {\n if ( extraInfo -> OptGrpConverter [ Ix ] != NULL ) ucnv_unloadSharedDataIfReady ( extraInfo -> OptGrpConverter [ Ix ] ) ;\n }\n if ( ! _this -> isExtraLocal ) {\n uprv_free ( _this -> extraInfo ) ;\n _this -> extraInfo = NULL ;\n }\n }\n }\n typedef struct LMBCSClone {\n UConverter cnv ;\n UConverterDataLMBCS lmbcs ;\n }\n LMBCSClone ;\n static UConverter * U_CALLCONV _LMBCSSafeClone ( const UConverter * cnv , void * stackBuffer , int32_t * pBufferSize , UErrorCode * status ) {\n ( void ) status ;\n LMBCSClone * newLMBCS ;\n UConverterDataLMBCS * extraInfo ;\n int32_t i ;\n if ( * pBufferSize <= 0 ) {\n * pBufferSize = ( int32_t ) sizeof ( LMBCSClone ) ;\n return NULL ;\n }\n extraInfo = ( UConverterDataLMBCS * ) cnv -> extraInfo ;\n newLMBCS = ( LMBCSClone * ) stackBuffer ;\n uprv_memcpy ( & newLMBCS -> lmbcs , extraInfo , sizeof ( UConverterDataLMBCS ) ) ;\n for ( i = 0 ;\n i <= ULMBCS_GRP_LAST ;\n ++ i ) {\n if ( extraInfo -> OptGrpConverter [ i ] != NULL ) {\n ucnv_incrementRefCount ( extraInfo -> OptGrpConverter [ i ] ) ;\n }\n }\n newLMBCS -> cnv . extraInfo = & newLMBCS -> lmbcs ;\n newLMBCS -> cnv . isExtraLocal = TRUE ;\n return & newLMBCS -> cnv ;\n }\n static size_t LMBCSConversionWorker ( UConverterDataLMBCS * extraInfo , ulmbcs_byte_t group , ulmbcs_byte_t * pStartLMBCS , UChar * pUniChar , ulmbcs_byte_t * lastConverterIndex , UBool * groups_tried ) {\n ulmbcs_byte_t * pLMBCS = pStartLMBCS ;\n UConverterSharedData * xcnv = extraInfo -> OptGrpConverter [ group ] ;\n int bytesConverted ;\n uint32_t value ;\n ulmbcs_byte_t firstByte ;\n U_ASSERT ( xcnv ) ;\n U_ASSERT ( group < ULMBCS_GRP_UNICODE ) ;\n bytesConverted = ucnv_MBCSFromUChar32 ( xcnv , * pUniChar , & value , FALSE ) ;\n if ( bytesConverted > 0 ) {\n firstByte = ( ulmbcs_byte_t ) ( value >> ( ( bytesConverted - 1 ) * 8 ) ) ;\n }\n else {\n groups_tried [ group ] = TRUE ;\n return 0 ;\n }\n * lastConverterIndex = group ;\n U_ASSERT ( ( firstByte <= ULMBCS_C0END ) || ( firstByte >= ULMBCS_C1START ) || ( group == ULMBCS_GRP_EXCEPT ) ) ;\n if ( group != ULMBCS_GRP_EXCEPT && extraInfo -> OptGroup != group ) {\n * pLMBCS ++ = group ;\n if ( bytesConverted == 1 && group >= ULMBCS_DOUBLEOPTGROUP_START ) {\n * pLMBCS ++ = group ;\n }\n }\n if ( bytesConverted == 1 && firstByte < 0x20 ) return 0 ;\n switch ( bytesConverted ) {\n case 4 : * pLMBCS ++ = ( ulmbcs_byte_t ) ( value >> 24 ) ;\n U_FALLTHROUGH ;\n case 3 : * pLMBCS ++ = ( ulmbcs_byte_t ) ( value >> 16 ) ;\n U_FALLTHROUGH ;\n case 2 : * pLMBCS ++ = ( ulmbcs_byte_t ) ( value >> 8 ) ;\n U_FALLTHROUGH ;\n case 1 : * pLMBCS ++ = ( ulmbcs_byte_t ) value ;\n U_FALLTHROUGH ;\n default : break ;\n }\n return ( pLMBCS - pStartLMBCS ) ;\n }\n static size_t LMBCSConvertUni ( ulmbcs_byte_t * pLMBCS , UChar uniChar ) {\n uint8_t LowCh = ( uint8_t ) ( uniChar & 0x00FF ) ;\n uint8_t HighCh = ( uint8_t ) ( uniChar >> 8 ) ;\n * pLMBCS ++ = ULMBCS_GRP_UNICODE ;\n if ( LowCh == 0 ) {\n * pLMBCS ++ = ULMBCS_UNICOMPATZERO ;\n * pLMBCS ++ = HighCh ;\n }\n else {\n * pLMBCS ++ = HighCh ;\n * pLMBCS ++ = LowCh ;\n }\n return ULMBCS_UNICODE_SIZE ;\n }\n static void U_CALLCONV _LMBCSFromUnicode ( UConverterFromUnicodeArgs * args , UErrorCode * err ) {\n ulmbcs_byte_t lastConverterIndex = 0 ;\n UChar uniChar ;\n ulmbcs_byte_t LMBCS [ ULMBCS_CHARSIZE_MAX ] ;\n ulmbcs_byte_t * pLMBCS ;\n int32_t bytes_written ;\n UBool groups_tried [ ULMBCS_GRP_LAST + 1 ] ;\n UConverterDataLMBCS * extraInfo = ( UConverterDataLMBCS * ) args -> converter -> extraInfo ;\n int sourceIndex = 0 ;\n ulmbcs_byte_t OldConverterIndex = 0 ;\n while ( args -> source < args -> sourceLimit && ! U_FAILURE ( * err ) ) {\n OldConverterIndex = extraInfo -> localeConverterIndex ;\n if ( args -> target >= args -> targetLimit ) {\n * err = U_BUFFER_OVERFLOW_ERROR ;\n break ;\n }\n uniChar = * ( args -> source ) ;\n bytes_written = 0 ;\n pLMBCS = LMBCS ;\n if ( ( uniChar >= 0x80 ) && ( uniChar <= 0xff ) && ( uniChar != 0xB1 ) && ( uniChar != 0xD7 ) && ( uniChar != 0xF7 ) && ( uniChar != 0xB0 ) && ( uniChar != 0xB4 ) && ( uniChar != 0xB6 ) && ( uniChar != 0xA7 ) && ( uniChar != 0xA8 ) ) {\n extraInfo -> localeConverterIndex = ULMBCS_GRP_L1 ;\n }\n if ( ( ( uniChar > ULMBCS_C0END ) && ( uniChar < ULMBCS_C1START ) ) || uniChar == 0 || uniChar == ULMBCS_HT || uniChar == ULMBCS_CR || uniChar == ULMBCS_LF || uniChar == ULMBCS_123SYSTEMRANGE ) {\n * pLMBCS ++ = ( ulmbcs_byte_t ) uniChar ;\n bytes_written = 1 ;\n }\n if ( ! bytes_written ) {\n ulmbcs_byte_t group = FindLMBCSUniRange ( uniChar ) ;\n if ( group == ULMBCS_GRP_UNICODE ) {\n pLMBCS += LMBCSConvertUni ( pLMBCS , uniChar ) ;\n bytes_written = ( int32_t ) ( pLMBCS - LMBCS ) ;\n }\n else if ( group == ULMBCS_GRP_CTRL ) {\n if ( uniChar <= ULMBCS_C0END ) {\n * pLMBCS ++ = ULMBCS_GRP_CTRL ;\n * pLMBCS ++ = ( ulmbcs_byte_t ) ( ULMBCS_CTRLOFFSET + uniChar ) ;\n }\n else if ( uniChar >= ULMBCS_C1START && uniChar <= ULMBCS_C1START + ULMBCS_CTRLOFFSET ) {\n * pLMBCS ++ = ULMBCS_GRP_CTRL ;\n * pLMBCS ++ = ( ulmbcs_byte_t ) ( uniChar & 0x00FF ) ;\n }\n bytes_written = ( int32_t ) ( pLMBCS - LMBCS ) ;\n }\n else if ( group < ULMBCS_GRP_UNICODE ) {\n bytes_written = ( int32_t ) LMBCSConversionWorker ( extraInfo , group , pLMBCS , & uniChar , & lastConverterIndex , groups_tried ) ;\n }\n if ( ! bytes_written ) {\n uprv_memset ( groups_tried , 0 , sizeof ( groups_tried ) ) ;\n if ( ( extraInfo -> OptGroup != 1 ) && ( ULMBCS_AMBIGUOUS_MATCH ( group , extraInfo -> OptGroup ) ) ) {\n if ( extraInfo -> localeConverterIndex < ULMBCS_DOUBLEOPTGROUP_START ) {\n bytes_written = LMBCSConversionWorker ( extraInfo , ULMBCS_GRP_L1 , pLMBCS , & uniChar , & lastConverterIndex , groups_tried ) ;\n if ( ! bytes_written ) {\n bytes_written = LMBCSConversionWorker ( extraInfo , ULMBCS_GRP_EXCEPT , pLMBCS , & uniChar , & lastConverterIndex , groups_tried ) ;\n }\n if ( ! bytes_written ) {\n bytes_written = LMBCSConversionWorker ( extraInfo , extraInfo -> localeConverterIndex , pLMBCS , & uniChar , & lastConverterIndex , groups_tried ) ;\n }\n }\n else {\n bytes_written = LMBCSConversionWorker ( extraInfo , extraInfo -> localeConverterIndex , pLMBCS , & uniChar , & lastConverterIndex , groups_tried ) ;\n }\n }\n if ( ! bytes_written && ( extraInfo -> localeConverterIndex ) && ( ULMBCS_AMBIGUOUS_MATCH ( group , extraInfo -> localeConverterIndex ) ) ) {\n bytes_written = ( int32_t ) LMBCSConversionWorker ( extraInfo , extraInfo -> localeConverterIndex , pLMBCS , & uniChar , & lastConverterIndex , groups_tried ) ;\n }\n if ( ! bytes_written && ( lastConverterIndex ) && ( ULMBCS_AMBIGUOUS_MATCH ( group , lastConverterIndex ) ) ) {\n bytes_written = ( int32_t ) LMBCSConversionWorker ( extraInfo , lastConverterIndex , pLMBCS , & uniChar , & lastConverterIndex , groups_tried ) ;\n }\n if ( ! bytes_written ) {\n ulmbcs_byte_t grp_start ;\n ulmbcs_byte_t grp_end ;\n ulmbcs_byte_t grp_ix ;\n grp_start = ( ulmbcs_byte_t ) ( ( group == ULMBCS_AMBIGUOUS_MBCS ) ? ULMBCS_DOUBLEOPTGROUP_START : ULMBCS_GRP_L1 ) ;\n grp_end = ( ulmbcs_byte_t ) ( ( group == ULMBCS_AMBIGUOUS_MBCS ) ? ULMBCS_GRP_LAST : ULMBCS_GRP_TH ) ;\n if ( group == ULMBCS_AMBIGUOUS_ALL ) {\n grp_start = ULMBCS_GRP_L1 ;\n grp_end = ULMBCS_GRP_LAST ;\n }\n for ( grp_ix = grp_start ;\n grp_ix <= grp_end && ! bytes_written ;\n grp_ix ++ ) {\n if ( extraInfo -> OptGrpConverter [ grp_ix ] && ! groups_tried [ grp_ix ] ) {\n bytes_written = ( int32_t ) LMBCSConversionWorker ( extraInfo , grp_ix , pLMBCS , & uniChar , & lastConverterIndex , groups_tried ) ;\n }\n }\n if ( ! bytes_written && grp_start == ULMBCS_GRP_L1 ) {\n bytes_written = ( int32_t ) LMBCSConversionWorker ( extraInfo , ULMBCS_GRP_EXCEPT , pLMBCS , & uniChar , & lastConverterIndex , groups_tried ) ;\n }\n }\n if ( ! bytes_written ) {\n pLMBCS += LMBCSConvertUni ( pLMBCS , uniChar ) ;\n bytes_written = ( int32_t ) ( pLMBCS - LMBCS ) ;\n }\n }\n }\n args -> source ++ ;\n pLMBCS = LMBCS ;\n while ( args -> target < args -> targetLimit && bytes_written -- ) {\n * ( args -> target ) ++ = * pLMBCS ++ ;\n if ( args -> offsets ) {\n * ( args -> offsets ) ++ = sourceIndex ;\n }\n }\n sourceIndex ++ ;\n if ( bytes_written > 0 ) {\n uint8_t * pErrorBuffer = args -> converter -> charErrorBuffer ;\n * err = U_BUFFER_OVERFLOW_ERROR ;\n args -> converter -> charErrorBufferLength = ( int8_t ) bytes_written ;\n while ( bytes_written -- ) {\n * pErrorBuffer ++ = * pLMBCS ++ ;\n }\n }\n extraInfo -> localeConverterIndex = OldConverterIndex ;\n }\n }\n static UChar GetUniFromLMBCSUni ( char const * * ppLMBCSin ) {\n uint8_t HighCh = * ( * ppLMBCSin ) ++ ;\n uint8_t LowCh = * ( * ppLMBCSin ) ++ ;\n if ( HighCh == ULMBCS_UNICOMPATZERO ) {\n HighCh = LowCh ;\n LowCh = 0 ;\n }\n return ( UChar ) ( ( HighCh << 8 ) | LowCh ) ;\n }\n # define CHECK_SOURCE_LIMIT ( index ) if ( args -> source + index > args -> sourceLimit ) {\n * err = U_TRUNCATED_CHAR_FOUND ;\n args -> source = args -> sourceLimit ;\n return 0xffff ;\n }\n static UChar32 U_CALLCONV _LMBCSGetNextUCharWorker ( UConverterToUnicodeArgs * args , UErrorCode * err ) {\n UChar32 uniChar = 0 ;\n ulmbcs_byte_t CurByte ;\n if ( args -> source >= args -> sourceLimit ) {\n * err = U_ILLEGAL_ARGUMENT_ERROR ;\n return 0xffff ;\n }\n CurByte = * ( ( ulmbcs_byte_t * ) ( args -> source ++ ) ) ;\n if ( ( ( CurByte > ULMBCS_C0END ) && ( CurByte < ULMBCS_C1START ) ) || ( CurByte == 0 ) || CurByte == ULMBCS_HT || CurByte == ULMBCS_CR || CurByte == ULMBCS_LF || CurByte == ULMBCS_123SYSTEMRANGE ) {\n uniChar = CurByte ;\n }\n else {\n UConverterDataLMBCS * extraInfo ;\n ulmbcs_byte_t group ;\n UConverterSharedData * cnv ;\n if ( CurByte == ULMBCS_GRP_CTRL ) {\n ulmbcs_byte_t C0C1byte ;\n CHECK_SOURCE_LIMIT ( 1 ) ;\n C0C1byte = * ( args -> source ) ++ ;\n uniChar = ( C0C1byte < ULMBCS_C1START ) ? C0C1byte - ULMBCS_CTRLOFFSET : C0C1byte ;\n }\n else if ( CurByte == ULMBCS_GRP_UNICODE ) {\n CHECK_SOURCE_LIMIT ( 2 ) ;\n return GetUniFromLMBCSUni ( & ( args -> source ) ) ;\n }\n else if ( CurByte <= ULMBCS_CTRLOFFSET ) {\n group = CurByte ;\n extraInfo = ( UConverterDataLMBCS * ) args -> converter -> extraInfo ;\n if ( group > ULMBCS_GRP_LAST || ( cnv = extraInfo -> OptGrpConverter [ group ] ) == NULL ) {\n * err = U_INVALID_CHAR_FOUND ;\n }\n else if ( group >= ULMBCS_DOUBLEOPTGROUP_START ) {\n CHECK_SOURCE_LIMIT ( 2 ) ;\n if ( * args -> source == group ) {\n ++ args -> source ;\n uniChar = ucnv_MBCSSimpleGetNextUChar ( cnv , args -> source , 1 , FALSE ) ;\n ++ args -> source ;\n }\n else {\n uniChar = ucnv_MBCSSimpleGetNextUChar ( cnv , args -> source , 2 , FALSE ) ;\n args -> source += 2 ;\n }\n }\n else {\n CHECK_SOURCE_LIMIT ( 1 ) ;\n CurByte = * ( args -> source ) ++ ;\n if ( CurByte >= ULMBCS_C1START ) {\n uniChar = _MBCS_SINGLE_SIMPLE_GET_NEXT_BMP ( cnv , CurByte ) ;\n }\n else {\n char bytes [ 2 ] ;\n extraInfo = ( UConverterDataLMBCS * ) args -> converter -> extraInfo ;\n cnv = extraInfo -> OptGrpConverter [ ULMBCS_GRP_EXCEPT ] ;\n bytes [ 0 ] = group ;\n bytes [ 1 ] = CurByte ;\n uniChar = ucnv_MBCSSimpleGetNextUChar ( cnv , bytes , 2 , FALSE ) ;\n }\n }\n }\n else if ( CurByte >= ULMBCS_C1START ) {\n extraInfo = ( UConverterDataLMBCS * ) args -> converter -> extraInfo ;\n group = extraInfo -> OptGroup ;\n cnv = extraInfo -> OptGrpConverter [ group ] ;\n if ( group >= ULMBCS_DOUBLEOPTGROUP_START ) {\n if ( ! ucnv_MBCSIsLeadByte ( cnv , CurByte ) ) {\n CHECK_SOURCE_LIMIT ( 0 ) ;\n uniChar = ucnv_MBCSSimpleGetNextUChar ( cnv , args -> source - 1 , 1 , FALSE ) ;\n }\n else {\n CHECK_SOURCE_LIMIT ( 1 ) ;\n uniChar = ucnv_MBCSSimpleGetNextUChar ( cnv , args -> source - 1 , 2 , FALSE ) ;\n ++ args -> source ;\n }\n }\n else {\n uniChar = _MBCS_SINGLE_SIMPLE_GET_NEXT_BMP ( cnv , CurByte ) ;\n }\n }\n }\n return uniChar ;\n }\n static void U_CALLCONV _LMBCSToUnicodeWithOffsets ( UConverterToUnicodeArgs * args , UErrorCode * err ) {\n char LMBCS [ ULMBCS_CHARSIZE_MAX ] ;\n UChar uniChar ;\n const char * saveSource ;\n const char * pStartLMBCS = args -> source ;\n const char * errSource = NULL ;\n int8_t savebytes = 0 ;\n while ( U_SUCCESS ( * err ) && args -> sourceLimit > args -> source && args -> targetLimit > args -> target ) {\n saveSource = args -> source ;\n if ( args -> converter -> toULength ) {\n const char * saveSourceLimit ;\n size_t size_old = args -> converter -> toULength ;\n size_t size_new_maybe_1 = sizeof ( LMBCS ) - size_old ;\n size_t size_new_maybe_2 = args -> sourceLimit - args -> source ;\n size_t size_new = ( size_new_maybe_1 < size_new_maybe_2 ) ? size_new_maybe_1 : size_new_maybe_2 ;\n uprv_memcpy ( LMBCS , args -> converter -> toUBytes , size_old ) ;\n uprv_memcpy ( LMBCS + size_old , args -> source , size_new ) ;\n saveSourceLimit = args -> sourceLimit ;\n args -> source = errSource = LMBCS ;\n args -> sourceLimit = LMBCS + size_old + size_new ;\n savebytes = ( int8_t ) ( size_old + size_new ) ;\n uniChar = ( UChar ) _LMBCSGetNextUCharWorker ( args , err ) ;\n args -> source = saveSource + ( ( args -> source - LMBCS ) - size_old ) ;\n args -> sourceLimit = saveSourceLimit ;\n if ( * err == U_TRUNCATED_CHAR_FOUND ) {\n args -> converter -> toULength = savebytes ;\n uprv_memcpy ( args -> converter -> toUBytes , LMBCS , savebytes ) ;\n args -> source = args -> sourceLimit ;\n * err = U_ZERO_ERROR ;\n return ;\n }\n else {\n args -> converter -> toULength = 0 ;\n }\n }\n else {\n errSource = saveSource ;\n uniChar = ( UChar ) _LMBCSGetNextUCharWorker ( args , err ) ;\n savebytes = ( int8_t ) ( args -> source - saveSource ) ;\n }\n if ( U_SUCCESS ( * err ) ) {\n if ( uniChar < 0xfffe ) {\n * ( args -> target ) ++ = uniChar ;\n if ( args -> offsets ) {\n * ( args -> offsets ) ++ = ( int32_t ) ( saveSource - pStartLMBCS ) ;\n }\n }\n else if ( uniChar == 0xfffe ) {\n * err = U_INVALID_CHAR_FOUND ;\n }\n else {\n * err = U_ILLEGAL_CHAR_FOUND ;\n }\n }\n }\n if ( U_SUCCESS ( * err ) && args -> sourceLimit > args -> source && args -> targetLimit <= args -> target ) {\n * err = U_BUFFER_OVERFLOW_ERROR ;\n }\n else if ( U_FAILURE ( * err ) ) {\n args -> converter -> toULength = savebytes ;\n if ( savebytes > 0 ) {\n uprv_memcpy ( args -> converter -> toUBytes , errSource , savebytes ) ;\n }\n if ( * err == U_TRUNCATED_CHAR_FOUND ) {\n * err = U_ZERO_ERROR ;\n }\n }\n }\n DEFINE_LMBCS_OPEN ( 1 ) DEFINE_LMBCS_OPEN ( 2 ) DEFINE_LMBCS_OPEN ( 3 ) DEFINE_LMBCS_OPEN ( 4 )", "idx": 21701}
{"hash": -3231032419759162058, "project": "debian", "size": 14, "label": 0, "functionSource": "static inline uint8_t quant ( G726Context * c , int d ) {\n int sign , exp , i , dln ;\n sign = i = 0 ;\n if ( d < 0 ) {\n sign = 1 ;\n d = - d ;\n }\n exp = av_log2_16bit ( d ) ;\n dln = ( ( exp << 7 ) + ( ( ( d << 7 ) >> exp ) & 0x7f ) ) - ( c -> y >> 2 ) ;\n while ( c -> tbls . quant [ i ] < INT_MAX && c -> tbls . quant [ i ] < dln ) ++ i ;\n if ( sign ) i = ~ i ;\n if ( c -> code_size != 2 && i == 0 ) i = 0xff ;\n return i ;\n }", "idx": 21702}
{"hash": 1245821301839614810, "project": "debian", "size": 153, "label": 0, "functionSource": "static gboolean copy_move_directory ( CopyMoveJob * copy_job , GFile * src , GFile * * dest , gboolean same_fs , gboolean create_dest , char * * parent_dest_fs_type , SourceInfo * source_info , TransferInfo * transfer_info , GHashTable * debuting_files , gboolean * skipped_file , gboolean readonly_source_fs ) {\n GFileInfo * info ;\n GError * error ;\n GFile * src_file ;\n GFileEnumerator * enumerator ;\n char * primary , * secondary , * details ;\n char * dest_fs_type ;\n int response ;\n gboolean skip_error ;\n gboolean local_skipped_file ;\n CommonJob * job ;\n GFileCopyFlags flags ;\n job = ( CommonJob * ) copy_job ;\n if ( create_dest ) {\n switch ( create_dest_dir ( job , src , dest , same_fs , parent_dest_fs_type ) ) {\n case CREATE_DEST_DIR_RETRY : {\n return FALSE ;\n }\n case CREATE_DEST_DIR_FAILED : {\n * skipped_file = TRUE ;\n return TRUE ;\n }\n case CREATE_DEST_DIR_SUCCESS : default : {\n }\n break ;\n }\n if ( debuting_files ) {\n g_hash_table_replace ( debuting_files , g_object_ref ( * dest ) , GINT_TO_POINTER ( TRUE ) ) ;\n }\n }\n local_skipped_file = FALSE ;\n dest_fs_type = NULL ;\n skip_error = should_skip_readdir_error ( job , src ) ;\n retry : error = NULL ;\n enumerator = g_file_enumerate_children ( src , G_FILE_ATTRIBUTE_STANDARD_NAME , G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS , job -> cancellable , & error ) ;\n if ( enumerator ) {\n error = NULL ;\n while ( ! job_aborted ( job ) && ( info = g_file_enumerator_next_file ( enumerator , job -> cancellable , skip_error ? NULL : & error ) ) != NULL ) {\n src_file = g_file_get_child ( src , g_file_info_get_name ( info ) ) ;\n copy_move_file ( copy_job , src_file , * dest , same_fs , FALSE , & dest_fs_type , source_info , transfer_info , NULL , NULL , FALSE , & local_skipped_file , readonly_source_fs ) ;\n if ( local_skipped_file ) {\n transfer_add_file_to_count ( src_file , job , transfer_info ) ;\n report_copy_progress ( copy_job , source_info , transfer_info ) ;\n }\n g_object_unref ( src_file ) ;\n g_object_unref ( info ) ;\n }\n g_file_enumerator_close ( enumerator , job -> cancellable , NULL ) ;\n g_object_unref ( enumerator ) ;\n if ( error && IS_IO_ERROR ( error , CANCELLED ) ) {\n g_error_free ( error ) ;\n }\n else if ( error ) {\n if ( copy_job -> is_move ) {\n primary = f ( _ ( \"Error while moving.\" ) ) ;\n }\n else {\n primary = f ( _ ( \"Error while copying.\" ) ) ;\n }\n details = NULL ;\n if ( IS_IO_ERROR ( error , PERMISSION_DENIED ) ) {\n secondary = f ( _ ( \"Files in the folder \u201c%B\u201d cannot be copied because you do \" \"not have permissions to see them.\" ) , src ) ;\n }\n else {\n secondary = f ( _ ( \"There was an error getting information about the files in the folder \u201c%B\u201d.\" ) , src ) ;\n details = error -> message ;\n }\n response = run_warning ( job , primary , secondary , details , FALSE , CANCEL , _ ( \"_Skip files\" ) , NULL ) ;\n g_error_free ( error ) ;\n if ( response == 0 || response == GTK_RESPONSE_DELETE_EVENT ) {\n abort_job ( job ) ;\n }\n else if ( response == 1 ) {\n local_skipped_file = TRUE ;\n }\n else {\n g_assert_not_reached ( ) ;\n }\n }\n transfer_info -> num_files ++ ;\n report_copy_progress ( copy_job , source_info , transfer_info ) ;\n if ( debuting_files ) {\n g_hash_table_replace ( debuting_files , g_object_ref ( * dest ) , GINT_TO_POINTER ( create_dest ) ) ;\n }\n }\n else if ( IS_IO_ERROR ( error , CANCELLED ) ) {\n g_error_free ( error ) ;\n }\n else {\n if ( copy_job -> is_move ) {\n primary = f ( _ ( \"Error while moving.\" ) ) ;\n }\n else {\n primary = f ( _ ( \"Error while copying.\" ) ) ;\n }\n details = NULL ;\n if ( IS_IO_ERROR ( error , PERMISSION_DENIED ) ) {\n secondary = f ( _ ( \"The folder \u201c%B\u201d cannot be copied because you do not have \" \"permissions to read it.\" ) , src ) ;\n }\n else {\n secondary = f ( _ ( \"There was an error reading the folder \u201c%B\u201d.\" ) , src ) ;\n details = error -> message ;\n }\n response = run_warning ( job , primary , secondary , details , FALSE , CANCEL , SKIP , RETRY , NULL ) ;\n g_error_free ( error ) ;\n if ( response == 0 || response == GTK_RESPONSE_DELETE_EVENT ) {\n abort_job ( job ) ;\n }\n else if ( response == 1 ) {\n local_skipped_file = TRUE ;\n }\n else if ( response == 2 ) {\n goto retry ;\n }\n else {\n g_assert_not_reached ( ) ;\n }\n }\n if ( create_dest ) {\n flags = ( readonly_source_fs ) ? G_FILE_COPY_NOFOLLOW_SYMLINKS | G_FILE_COPY_TARGET_DEFAULT_PERMS : G_FILE_COPY_NOFOLLOW_SYMLINKS ;\n g_file_copy_attributes ( src , * dest , flags , job -> cancellable , NULL ) ;\n }\n if ( ! job_aborted ( job ) && copy_job -> is_move && ! local_skipped_file ) {\n if ( ! g_file_delete ( src , job -> cancellable , & error ) ) {\n if ( job -> skip_all_error ) {\n goto skip ;\n }\n primary = f ( _ ( \"Error while moving \u201c%B\u201d.\" ) , src ) ;\n secondary = f ( _ ( \"Could not remove the source folder.\" ) ) ;\n details = error -> message ;\n response = run_cancel_or_skip_warning ( job , primary , secondary , details , source_info -> num_files , source_info -> num_files - transfer_info -> num_files ) ;\n if ( response == 0 || response == GTK_RESPONSE_DELETE_EVENT ) {\n abort_job ( job ) ;\n }\n else if ( response == 1 ) {\n job -> skip_all_error = TRUE ;\n local_skipped_file = TRUE ;\n }\n else if ( response == 2 ) {\n local_skipped_file = TRUE ;\n }\n else {\n g_assert_not_reached ( ) ;\n }\n skip : g_error_free ( error ) ;\n }\n }\n if ( local_skipped_file ) {\n * skipped_file = TRUE ;\n }\n g_free ( dest_fs_type ) ;\n return TRUE ;\n }", "idx": 21703}
{"hash": 4313735399044135249, "project": "debian", "size": 5, "label": 0, "functionSource": "int psf_close_rsrc ( SF_PRIVATE * psf ) {\n psf_close_fd ( psf -> rsrc . filedes ) ;\n psf -> rsrc . filedes = - 1 ;\n return 0 ;\n }", "idx": 21704}
{"hash": 1760449185745615462, "project": "debian", "size": 5, "label": 0, "functionSource": "int TSHttpCurrentActiveClientConnectionsGet ( void ) {\n int64_t S ;\n HTTP_READ_DYN_SUM ( http_current_active_client_connections_stat , S ) ;\n return ( int ) S ;\n }", "idx": 21705}
{"hash": 455172021572601154, "project": "debian", "size": 52, "label": 1, "functionSource": "int strescape ( char * dst , char * src ) {\n char * olddst = dst ;\n int c ;\n int val ;\n while ( ( c = * src ++ ) != '\\0' ) {\n if ( c == '\\\\' ) {\n switch ( ( c = * src ++ ) ) {\n case '\\0' : goto strend ;\n default : * dst ++ = ( char ) c ;\n break ;\n case 'n' : * dst ++ = '\\n' ;\n break ;\n case 'r' : * dst ++ = '\\r' ;\n break ;\n case 'b' : * dst ++ = '\\b' ;\n break ;\n case 't' : * dst ++ = '\\t' ;\n break ;\n case 'f' : * dst ++ = '\\f' ;\n break ;\n case 'v' : * dst ++ = '\\v' ;\n break ;\n case '0' : case '1' : case '2' : case '3' : case '4' : case '5' : case '6' : case '7' : val = c - '0' ;\n c = * src ++ ;\n if ( c >= '0' && c <= '7' ) {\n val = ( val << 3 ) | ( c - '0' ) ;\n c = * src ++ ;\n if ( c >= '0' && c <= '7' ) val = ( val << 3 ) | ( c - '0' ) ;\n else -- src ;\n }\n else -- src ;\n * dst ++ = ( char ) val ;\n break ;\n case 'x' : val = 'x' ;\n c = hextoint ( * src ++ ) ;\n if ( c >= 0 ) {\n val = c ;\n c = hextoint ( * src ++ ) ;\n if ( c >= 0 ) val = ( val << 4 ) + c ;\n else -- src ;\n }\n else -- src ;\n * dst ++ = ( char ) val ;\n break ;\n }\n }\n else if ( c == 8 || c == 263 ) dst -- ;\n else * dst ++ = ( char ) c ;\n }\n strend : * dst = '\\0' ;\n return ( dst - olddst ) ;\n }", "idx": 21706}
{"hash": 1245821301839614810, "project": "debian", "size": 3, "label": 0, "functionSource": "static void custom_size_skip ( va_list * va ) {\n ( void ) va_arg ( * va , goffset ) ;\n }", "idx": 21707}
{"hash": -1919011628477388936, "project": "debian", "size": 20, "label": 0, "functionSource": "static void IRQ_check ( OpenPICState * opp , IRQQueue * q ) {\n int irq = - 1 ;\n int next = - 1 ;\n int priority = - 1 ;\n for ( ;\n ;\n ) {\n irq = find_next_bit ( q -> queue , opp -> max_irq , irq + 1 ) ;\n if ( irq == opp -> max_irq ) {\n break ;\n }\n DPRINTF ( \"IRQ_check: irq %d set ivpr_pr=%d pr=%d\\n\" , irq , IVPR_PRIORITY ( opp -> src [ irq ] . ivpr ) , priority ) ;\n if ( IVPR_PRIORITY ( opp -> src [ irq ] . ivpr ) > priority ) {\n next = irq ;\n priority = IVPR_PRIORITY ( opp -> src [ irq ] . ivpr ) ;\n }\n }\n q -> next = next ;\n q -> priority = priority ;\n }", "idx": 21708}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_T_videoFastUpdateGOB ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_T_videoFastUpdateGOB , T_videoFastUpdateGOB_sequence ) ;\n return offset ;\n }", "idx": 21709}
{"hash": 229962612204196999, "project": "debian", "size": 28, "label": 0, "functionSource": "static int update_remote ( unsigned char * sha1 , struct remote_lock * lock ) {\n struct active_request_slot * slot ;\n struct slot_results results ;\n struct buffer out_buffer = {\n STRBUF_INIT , 0 }\n ;\n struct curl_slist * dav_headers ;\n dav_headers = get_dav_token_headers ( lock , DAV_HEADER_IF ) ;\n strbuf_addf ( & out_buffer . buf , \"%s\\n\" , sha1_to_hex ( sha1 ) ) ;\n slot = get_active_slot ( ) ;\n slot -> results = & results ;\n curl_setup_http ( slot -> curl , lock -> url , DAV_PUT , & out_buffer , fwrite_null ) ;\n curl_easy_setopt ( slot -> curl , CURLOPT_HTTPHEADER , dav_headers ) ;\n if ( start_active_slot ( slot ) ) {\n run_active_slot ( slot ) ;\n strbuf_release ( & out_buffer . buf ) ;\n if ( results . curl_result != CURLE_OK ) {\n fprintf ( stderr , \"PUT error: curl result=%d, HTTP code=%ld\\n\" , results . curl_result , results . http_code ) ;\n return 0 ;\n }\n }\n else {\n strbuf_release ( & out_buffer . buf ) ;\n fprintf ( stderr , \"Unable to start PUT request\\n\" ) ;\n return 0 ;\n }\n return 1 ;\n }", "idx": 21710}
{"hash": -5612058238993493687, "project": "debian", "size": 77, "label": 0, "functionSource": "static void handle_pap ( netdissect_options * ndo , const u_char * p , int length ) {\n u_int code , len ;\n int peerid_len , passwd_len , msg_len ;\n const u_char * p0 ;\n int i ;\n p0 = p ;\n if ( length < 1 ) {\n ND_PRINT ( ( ndo , \"[|pap]\" ) ) ;\n return ;\n }\n else if ( length < 4 ) {\n ND_TCHECK ( * p ) ;\n ND_PRINT ( ( ndo , \"[|pap 0x%02x]\" , * p ) ) ;\n return ;\n }\n ND_TCHECK ( * p ) ;\n code = * p ;\n ND_PRINT ( ( ndo , \"PAP, %s (0x%02x)\" , tok2str ( papcode_values , \"unknown\" , code ) , code ) ) ;\n p ++ ;\n ND_TCHECK ( * p ) ;\n ND_PRINT ( ( ndo , \", id %u\" , * p ) ) ;\n p ++ ;\n ND_TCHECK2 ( * p , 2 ) ;\n len = EXTRACT_16BITS ( p ) ;\n p += 2 ;\n if ( ( int ) len > length ) {\n ND_PRINT ( ( ndo , \", length %u > packet size\" , len ) ) ;\n return ;\n }\n length = len ;\n if ( length < ( p - p0 ) ) {\n ND_PRINT ( ( ndo , \", length %u < PAP header length\" , length ) ) ;\n return ;\n }\n switch ( code ) {\n case PAP_AREQ : if ( length - ( p - p0 ) < 1 ) return ;\n ND_TCHECK ( * p ) ;\n peerid_len = * p ;\n p ++ ;\n if ( length - ( p - p0 ) < peerid_len ) return ;\n ND_PRINT ( ( ndo , \", Peer \" ) ) ;\n for ( i = 0 ;\n i < peerid_len ;\n i ++ ) {\n ND_TCHECK ( * p ) ;\n safeputchar ( ndo , * p ++ ) ;\n }\n if ( length - ( p - p0 ) < 1 ) return ;\n ND_TCHECK ( * p ) ;\n passwd_len = * p ;\n p ++ ;\n if ( length - ( p - p0 ) < passwd_len ) return ;\n ND_PRINT ( ( ndo , \", Name \" ) ) ;\n for ( i = 0 ;\n i < passwd_len ;\n i ++ ) {\n ND_TCHECK ( * p ) ;\n safeputchar ( ndo , * p ++ ) ;\n }\n break ;\n case PAP_AACK : case PAP_ANAK : if ( length - ( p - p0 ) < 1 ) return ;\n ND_TCHECK ( * p ) ;\n msg_len = * p ;\n p ++ ;\n if ( length - ( p - p0 ) < msg_len ) return ;\n ND_PRINT ( ( ndo , \", Msg \" ) ) ;\n for ( i = 0 ;\n i < msg_len ;\n i ++ ) {\n ND_TCHECK ( * p ) ;\n safeputchar ( ndo , * p ++ ) ;\n }\n break ;\n }\n return ;\n trunc : ND_PRINT ( ( ndo , \"[|pap]\" ) ) ;\n }", "idx": 21711}
{"hash": 5357882892791796049, "project": "debian", "size": 80, "label": 0, "functionSource": "ssize_t e1000e_receive_iov ( E1000ECore * core , const struct iovec * iov , int iovcnt ) {\n static const int maximum_ethernet_hdr_len = ( 14 + 4 ) ;\n static const int min_buf_size = 60 ;\n uint32_t n = 0 ;\n uint8_t min_buf [ min_buf_size ] ;\n struct iovec min_iov ;\n uint8_t * filter_buf ;\n size_t size , orig_size ;\n size_t iov_ofs = 0 ;\n E1000E_RxRing rxr ;\n E1000E_RSSInfo rss_info ;\n size_t total_size ;\n ssize_t retval ;\n bool rdmts_hit ;\n trace_e1000e_rx_receive_iov ( iovcnt ) ;\n if ( ! e1000x_hw_rx_enabled ( core -> mac ) ) {\n return - 1 ;\n }\n if ( core -> has_vnet ) {\n net_rx_pkt_set_vhdr_iovec ( core -> rx_pkt , iov , iovcnt ) ;\n iov_ofs = sizeof ( struct virtio_net_hdr ) ;\n }\n filter_buf = iov -> iov_base + iov_ofs ;\n orig_size = iov_size ( iov , iovcnt ) ;\n size = orig_size - iov_ofs ;\n if ( size < sizeof ( min_buf ) ) {\n iov_to_buf ( iov , iovcnt , iov_ofs , min_buf , size ) ;\n memset ( & min_buf [ size ] , 0 , sizeof ( min_buf ) - size ) ;\n e1000x_inc_reg_if_not_full ( core -> mac , RUC ) ;\n min_iov . iov_base = filter_buf = min_buf ;\n min_iov . iov_len = size = sizeof ( min_buf ) ;\n iovcnt = 1 ;\n iov = & min_iov ;\n iov_ofs = 0 ;\n }\n else if ( iov -> iov_len < maximum_ethernet_hdr_len ) {\n iov_to_buf ( iov , iovcnt , iov_ofs , min_buf , maximum_ethernet_hdr_len ) ;\n filter_buf = min_buf ;\n }\n if ( e1000x_is_oversized ( core -> mac , size ) ) {\n return orig_size ;\n }\n net_rx_pkt_set_packet_type ( core -> rx_pkt , get_eth_packet_type ( PKT_GET_ETH_HDR ( filter_buf ) ) ) ;\n if ( ! e1000e_receive_filter ( core , filter_buf , size ) ) {\n trace_e1000e_rx_flt_dropped ( ) ;\n return orig_size ;\n }\n net_rx_pkt_attach_iovec_ex ( core -> rx_pkt , iov , iovcnt , iov_ofs , e1000x_vlan_enabled ( core -> mac ) , core -> vet ) ;\n e1000e_rss_parse_packet ( core , core -> rx_pkt , & rss_info ) ;\n e1000e_rx_ring_init ( core , & rxr , rss_info . queue ) ;\n trace_e1000e_rx_rss_dispatched_to_queue ( rxr . i -> idx ) ;\n total_size = net_rx_pkt_get_total_len ( core -> rx_pkt ) + e1000x_fcs_len ( core -> mac ) ;\n if ( e1000e_has_rxbufs ( core , rxr . i , total_size ) ) {\n e1000e_rx_fix_l4_csum ( core , core -> rx_pkt ) ;\n e1000e_write_packet_to_guest ( core , core -> rx_pkt , & rxr , & rss_info ) ;\n retval = orig_size ;\n if ( total_size < core -> mac [ RSRPD ] ) {\n n |= E1000_ICS_SRPD ;\n }\n if ( ! ( core -> mac [ RFCTL ] & E1000_RFCTL_ACK_DIS ) && ( e1000e_is_tcp_ack ( core , core -> rx_pkt ) ) ) {\n n |= E1000_ICS_ACK ;\n }\n rdmts_hit = e1000e_rx_descr_threshold_hit ( core , rxr . i ) ;\n n |= e1000e_rx_wb_interrupt_cause ( core , rxr . i -> idx , rdmts_hit ) ;\n trace_e1000e_rx_written_to_guest ( n ) ;\n }\n else {\n n |= E1000_ICS_RXO ;\n retval = 0 ;\n trace_e1000e_rx_not_written_to_guest ( n ) ;\n }\n if ( ! e1000e_intrmgr_delay_rx_causes ( core , & n ) ) {\n trace_e1000e_rx_interrupt_set ( n ) ;\n e1000e_set_interrupt_cause ( core , n ) ;\n }\n else {\n trace_e1000e_rx_interrupt_delayed ( n ) ;\n }\n return retval ;\n }", "idx": 21712}
{"hash": 2315393806700093389, "project": "chrome", "size": 23, "label": 0, "functionSource": "static void convolve_vert ( const uint8_t * src , ptrdiff_t src_stride , uint8_t * dst , ptrdiff_t dst_stride , const InterpKernel * y_filters , int y0_q4 , int y_step_q4 , int w , int h ) {\n int x , y ;\n src -= src_stride * ( SUBPEL_TAPS / 2 - 1 ) ;\n for ( x = 0 ;\n x < w ;\n ++ x ) {\n int y_q4 = y0_q4 ;\n for ( y = 0 ;\n y < h ;\n ++ y ) {\n const unsigned char * src_y = & src [ ( y_q4 >> SUBPEL_BITS ) * src_stride ] ;\n const int16_t * const y_filter = y_filters [ y_q4 & SUBPEL_MASK ] ;\n int k , sum = 0 ;\n for ( k = 0 ;\n k < SUBPEL_TAPS ;\n ++ k ) sum += src_y [ k * src_stride ] * y_filter [ k ] ;\n dst [ y * dst_stride ] = clip_pixel ( ROUND_POWER_OF_TWO ( sum , FILTER_BITS ) ) ;\n y_q4 += y_step_q4 ;\n }\n ++ src ;\n ++ dst ;\n }\n }", "idx": 21713}
{"hash": 4489017523191997023, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h225_TerminalInfo ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_TerminalInfo , TerminalInfo_sequence ) ;\n return offset ;\n }", "idx": 21714}
{"hash": 3599206110384554647, "project": "debian", "size": 63, "label": 1, "functionSource": "static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _new_reserve ( sk_ ## t1 ## _compfunc compare , int n ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_new_reserve ( ( OPENSSL_sk_compfunc ) compare , n ) ;\n }\n static ossl_inline int sk_ ## t1 ## _reserve ( STACK_OF ( t1 ) * sk , int n ) {\n return OPENSSL_sk_reserve ( ( OPENSSL_STACK * ) sk , n ) ;\n }\n static ossl_inline void sk_ ## t1 ## _free ( STACK_OF ( t1 ) * sk ) {\n OPENSSL_sk_free ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline void sk_ ## t1 ## _zero ( STACK_OF ( t1 ) * sk ) {\n OPENSSL_sk_zero ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _delete ( STACK_OF ( t1 ) * sk , int i ) {\n return ( t2 * ) OPENSSL_sk_delete ( ( OPENSSL_STACK * ) sk , i ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _delete_ptr ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return ( t2 * ) OPENSSL_sk_delete_ptr ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _push ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_push ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _unshift ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_unshift ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _pop ( STACK_OF ( t1 ) * sk ) {\n return ( t2 * ) OPENSSL_sk_pop ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _shift ( STACK_OF ( t1 ) * sk ) {\n return ( t2 * ) OPENSSL_sk_shift ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline void sk_ ## t1 ## _pop_free ( STACK_OF ( t1 ) * sk , sk_ ## t1 ## _freefunc freefunc ) {\n OPENSSL_sk_pop_free ( ( OPENSSL_STACK * ) sk , ( OPENSSL_sk_freefunc ) freefunc ) ;\n }\n static ossl_inline int sk_ ## t1 ## _insert ( STACK_OF ( t1 ) * sk , t2 * ptr , int idx ) {\n return OPENSSL_sk_insert ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr , idx ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _set ( STACK_OF ( t1 ) * sk , int idx , t2 * ptr ) {\n return ( t2 * ) OPENSSL_sk_set ( ( OPENSSL_STACK * ) sk , idx , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _find ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_find ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _find_ex ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_find_ex ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline void sk_ ## t1 ## _sort ( STACK_OF ( t1 ) * sk ) {\n OPENSSL_sk_sort ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline int sk_ ## t1 ## _is_sorted ( const STACK_OF ( t1 ) * sk ) {\n return OPENSSL_sk_is_sorted ( ( const OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _dup ( const STACK_OF ( t1 ) * sk ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_dup ( ( const OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _deep_copy ( const STACK_OF ( t1 ) * sk , sk_ ## t1 ## _copyfunc copyfunc , sk_ ## t1 ## _freefunc freefunc ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_deep_copy ( ( const OPENSSL_STACK * ) sk , ( OPENSSL_sk_copyfunc ) copyfunc , ( OPENSSL_sk_freefunc ) freefunc ) ;\n }\n static ossl_inline sk_ ## t1 ## _compfunc sk_ ## t1 ## _set_cmp_func ( STACK_OF ( t1 ) * sk , sk_ ## t1 ## _compfunc compare ) {\n return ( sk_ ## t1 ## _compfunc ) OPENSSL_sk_set_cmp_func ( ( OPENSSL_STACK * ) sk , ( OPENSSL_sk_compfunc ) compare ) ;\n }\n # define DEFINE_SPECIAL_STACK_OF ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , t2 , t2 ) # define DEFINE_STACK_OF ( t ) SKM_DEFINE_STACK_OF ( t , t , t ) # define DEFINE_SPECIAL_STACK_OF_CONST ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , const t2 , t2 ) # define DEFINE_STACK_OF_CONST ( t ) SKM_DEFINE_STACK_OF ( t , const t , t ) typedef char * OPENSSL_STRING ;\n typedef const char * OPENSSL_CSTRING ;\n DEFINE_SPECIAL_STACK_OF ( OPENSSL_STRING , char ) DEFINE_SPECIAL_STACK_OF_CONST ( OPENSSL_CSTRING , char )", "idx": 21715}
{"hash": -3740862514502467070, "project": "debian", "size": 6, "label": 0, "functionSource": "static void dumpoper ( FILE * cfff , int oper ) {\n if ( oper != - 1 ) {\n if ( oper >= 256 ) putc ( oper >> 8 , cfff ) ;\n putc ( oper & 0xff , cfff ) ;\n }\n }", "idx": 21716}
{"hash": 643387607984457432, "project": "debian", "size": 87, "label": 1, "functionSource": "static int synth_superframe ( AVCodecContext * ctx , AVFrame * frame , int * got_frame_ptr ) {\n WMAVoiceContext * s = ctx -> priv_data ;\n GetBitContext * gb = & s -> gb , s_gb ;\n int n , res , n_samples = 480 ;\n double lsps [ MAX_FRAMES ] [ MAX_LSPS ] ;\n const double * mean_lsf = s -> lsps == 16 ? wmavoice_mean_lsf16 [ s -> lsp_def_mode ] : wmavoice_mean_lsf10 [ s -> lsp_def_mode ] ;\n float excitation [ MAX_SIGNAL_HISTORY + MAX_SFRAMESIZE + 12 ] ;\n float synth [ MAX_LSPS + MAX_SFRAMESIZE ] ;\n float * samples ;\n memcpy ( synth , s -> synth_history , s -> lsps * sizeof ( * synth ) ) ;\n memcpy ( excitation , s -> excitation_history , s -> history_nsamples * sizeof ( * excitation ) ) ;\n if ( s -> sframe_cache_size > 0 ) {\n gb = & s_gb ;\n init_get_bits ( gb , s -> sframe_cache , s -> sframe_cache_size ) ;\n s -> sframe_cache_size = 0 ;\n }\n if ( ( res = check_bits_for_superframe ( gb , s ) ) == 1 ) {\n * got_frame_ptr = 0 ;\n return 1 ;\n }\n if ( ! get_bits1 ( gb ) ) {\n av_log_missing_feature ( ctx , \"WMAPro-in-WMAVoice\" , 1 ) ;\n return AVERROR_PATCHWELCOME ;\n }\n if ( get_bits1 ( gb ) ) {\n if ( ( n_samples = get_bits ( gb , 12 ) ) > 480 ) {\n av_log ( ctx , AV_LOG_ERROR , \"Superframe encodes >480 samples (%d), not allowed\\n\" , n_samples ) ;\n return - 1 ;\n }\n }\n if ( s -> has_residual_lsps ) {\n double prev_lsps [ MAX_LSPS ] , a1 [ MAX_LSPS * 2 ] , a2 [ MAX_LSPS * 2 ] ;\n for ( n = 0 ;\n n < s -> lsps ;\n n ++ ) prev_lsps [ n ] = s -> prev_lsps [ n ] - mean_lsf [ n ] ;\n if ( s -> lsps == 10 ) {\n dequant_lsp10r ( gb , lsps [ 2 ] , prev_lsps , a1 , a2 , s -> lsp_q_mode ) ;\n }\n else dequant_lsp16r ( gb , lsps [ 2 ] , prev_lsps , a1 , a2 , s -> lsp_q_mode ) ;\n for ( n = 0 ;\n n < s -> lsps ;\n n ++ ) {\n lsps [ 0 ] [ n ] = mean_lsf [ n ] + ( a1 [ n ] - a2 [ n * 2 ] ) ;\n lsps [ 1 ] [ n ] = mean_lsf [ n ] + ( a1 [ s -> lsps + n ] - a2 [ n * 2 + 1 ] ) ;\n lsps [ 2 ] [ n ] += mean_lsf [ n ] ;\n }\n for ( n = 0 ;\n n < 3 ;\n n ++ ) stabilize_lsps ( lsps [ n ] , s -> lsps ) ;\n }\n frame -> nb_samples = 480 ;\n if ( ( res = ff_get_buffer ( ctx , frame ) ) < 0 ) {\n av_log ( ctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return res ;\n }\n frame -> nb_samples = n_samples ;\n samples = ( float * ) frame -> data [ 0 ] ;\n for ( n = 0 ;\n n < 3 ;\n n ++ ) {\n if ( ! s -> has_residual_lsps ) {\n int m ;\n if ( s -> lsps == 10 ) {\n dequant_lsp10i ( gb , lsps [ n ] ) ;\n }\n else dequant_lsp16i ( gb , lsps [ n ] ) ;\n for ( m = 0 ;\n m < s -> lsps ;\n m ++ ) lsps [ n ] [ m ] += mean_lsf [ m ] ;\n stabilize_lsps ( lsps [ n ] , s -> lsps ) ;\n }\n if ( ( res = synth_frame ( ctx , gb , n , & samples [ n * MAX_FRAMESIZE ] , lsps [ n ] , n == 0 ? s -> prev_lsps : lsps [ n - 1 ] , & excitation [ s -> history_nsamples + n * MAX_FRAMESIZE ] , & synth [ s -> lsps + n * MAX_FRAMESIZE ] ) ) ) {\n * got_frame_ptr = 0 ;\n return res ;\n }\n }\n if ( get_bits1 ( gb ) ) {\n res = get_bits ( gb , 4 ) ;\n skip_bits ( gb , 10 * ( res + 1 ) ) ;\n }\n * got_frame_ptr = 1 ;\n memcpy ( s -> prev_lsps , lsps [ 2 ] , s -> lsps * sizeof ( * s -> prev_lsps ) ) ;\n memcpy ( s -> synth_history , & synth [ MAX_SFRAMESIZE ] , s -> lsps * sizeof ( * synth ) ) ;\n memcpy ( s -> excitation_history , & excitation [ MAX_SFRAMESIZE ] , s -> history_nsamples * sizeof ( * excitation ) ) ;\n if ( s -> do_apf ) memmove ( s -> zero_exc_pf , & s -> zero_exc_pf [ MAX_SFRAMESIZE ] , s -> history_nsamples * sizeof ( * s -> zero_exc_pf ) ) ;\n return 0 ;\n }", "idx": 21717}
{"hash": 4107780562321324682, "project": "chrome", "size": 11, "label": 0, "functionSource": "static const char * getPosixID ( const ILcidPosixMap * this_0 , uint32_t hostID ) {\n uint32_t i ;\n for ( i = 0 ;\n i <= this_0 -> numRegions ;\n i ++ ) {\n if ( this_0 -> regionMaps [ i ] . hostID == hostID ) {\n return this_0 -> regionMaps [ i ] . posixID ;\n }\n }\n return this_0 -> regionMaps [ 0 ] . posixID ;\n }", "idx": 21718}
{"hash": 6627875687115906550, "project": "chrome", "size": 23, "label": 1, "functionSource": "IN_PROC_BROWSER_TEST_F ( WebRtcApprtcBrowserTest , MANUAL_WorksOnApprtc ) {\n DetectErrorsInJavaScript ( ) ;\n ASSERT_TRUE ( LaunchApprtcInstanceOnLocalhost ( \"9999\" ) ) ;\n ASSERT_TRUE ( LaunchColliderOnLocalHost ( \"http://localhost:9999\" , \"8089\" ) ) ;\n while ( ! LocalApprtcInstanceIsUp ( ) ) DVLOG ( 1 ) << \"Waiting for AppRTC to come up...\" ;\n GURL room_url = GURL ( \"http://localhost:9999/r/some_room\" \"?wshpp=localhost:8089&wstls=false\" ) ;\n chrome : : AddTabAt ( browser ( ) , GURL ( ) , - 1 , true ) ;\n content : : WebContents * left_tab = browser ( ) -> tab_strip_model ( ) -> GetActiveWebContents ( ) ;\n PermissionBubbleManager : : FromWebContents ( left_tab ) -> set_auto_response_for_test ( PermissionBubbleManager : : ACCEPT_ALL ) ;\n InfoBarResponder left_infobar_responder ( InfoBarService : : FromWebContents ( left_tab ) , InfoBarResponder : : ACCEPT ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , room_url ) ;\n chrome : : AddTabAt ( browser ( ) , GURL ( ) , - 1 , true ) ;\n content : : WebContents * right_tab = browser ( ) -> tab_strip_model ( ) -> GetActiveWebContents ( ) ;\n PermissionBubbleManager : : FromWebContents ( right_tab ) -> set_auto_response_for_test ( PermissionBubbleManager : : ACCEPT_ALL ) ;\n InfoBarResponder right_infobar_responder ( InfoBarService : : FromWebContents ( right_tab ) , InfoBarResponder : : ACCEPT ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , room_url ) ;\n ASSERT_TRUE ( WaitForCallToComeUp ( left_tab ) ) ;\n ASSERT_TRUE ( WaitForCallToComeUp ( right_tab ) ) ;\n ASSERT_TRUE ( DetectRemoteVideoPlaying ( left_tab ) ) ;\n ASSERT_TRUE ( DetectRemoteVideoPlaying ( right_tab ) ) ;\n chrome : : CloseWebContents ( browser ( ) , left_tab , false ) ;\n chrome : : CloseWebContents ( browser ( ) , right_tab , false ) ;\n }", "idx": 21719}
{"hash": -4552633429382740307, "project": "debian", "size": 8, "label": 0, "functionSource": "void # ifdef M_DEBUG mpi_debug_resize ( MPI a , unsigned nlimbs , const char * info ) # else mpi_resize ( MPI a , unsigned nlimbs ) # endif {\n if ( nlimbs <= a -> alloced ) return ;\n # ifdef M_DEBUG if ( a -> d ) a -> d = m_debug_realloc ( a -> d , nlimbs * sizeof ( mpi_limb_t ) , info ) ;\n else a -> d = m_debug_alloc_clear ( nlimbs * sizeof ( mpi_limb_t ) , info ) ;\n # else if ( a -> d ) a -> d = xrealloc ( a -> d , nlimbs * sizeof ( mpi_limb_t ) ) ;\n else a -> d = xmalloc_clear ( nlimbs * sizeof ( mpi_limb_t ) ) ;\n # endif a -> alloced = nlimbs ;\n }", "idx": 21720}
{"hash": -4106680724983638989, "project": "chrome", "size": 92, "label": 0, "functionSource": "static void sbr_hf_assemble ( float Y1 [ 38 ] [ 64 ] [ 2 ] , const float X_high [ 64 ] [ 40 ] [ 2 ] , SpectralBandReplication * sbr , SBRData * ch_data , const int e_a [ 2 ] ) {\n int e , i , j , m ;\n const int h_SL = 4 * ! sbr -> bs_smoothing_mode ;\n const int kx = sbr -> kx [ 1 ] ;\n const int m_max = sbr -> m [ 1 ] ;\n static const float h_smooth [ 5 ] = {\n 0.33333333333333 , 0.30150283239582 , 0.21816949906249 , 0.11516383427084 , 0.03183050093751 , }\n ;\n float ( * g_temp ) [ 48 ] = ch_data -> g_temp , ( * q_temp ) [ 48 ] = ch_data -> q_temp ;\n int indexnoise = ch_data -> f_indexnoise ;\n int indexsine = ch_data -> f_indexsine ;\n if ( sbr -> reset ) {\n for ( i = 0 ;\n i < h_SL ;\n i ++ ) {\n memcpy ( g_temp [ i + 2 * ch_data -> t_env [ 0 ] ] , sbr -> gain [ 0 ] , m_max * sizeof ( sbr -> gain [ 0 ] [ 0 ] ) ) ;\n memcpy ( q_temp [ i + 2 * ch_data -> t_env [ 0 ] ] , sbr -> q_m [ 0 ] , m_max * sizeof ( sbr -> q_m [ 0 ] [ 0 ] ) ) ;\n }\n }\n else if ( h_SL ) {\n for ( i = 0 ;\n i < 4 ;\n i ++ ) {\n memcpy ( g_temp [ i + 2 * ch_data -> t_env [ 0 ] ] , g_temp [ i + 2 * ch_data -> t_env_num_env_old ] , sizeof ( g_temp [ 0 ] ) ) ;\n memcpy ( q_temp [ i + 2 * ch_data -> t_env [ 0 ] ] , q_temp [ i + 2 * ch_data -> t_env_num_env_old ] , sizeof ( q_temp [ 0 ] ) ) ;\n }\n }\n for ( e = 0 ;\n e < ch_data -> bs_num_env ;\n e ++ ) {\n for ( i = 2 * ch_data -> t_env [ e ] ;\n i < 2 * ch_data -> t_env [ e + 1 ] ;\n i ++ ) {\n memcpy ( g_temp [ h_SL + i ] , sbr -> gain [ e ] , m_max * sizeof ( sbr -> gain [ 0 ] [ 0 ] ) ) ;\n memcpy ( q_temp [ h_SL + i ] , sbr -> q_m [ e ] , m_max * sizeof ( sbr -> q_m [ 0 ] [ 0 ] ) ) ;\n }\n }\n for ( e = 0 ;\n e < ch_data -> bs_num_env ;\n e ++ ) {\n for ( i = 2 * ch_data -> t_env [ e ] ;\n i < 2 * ch_data -> t_env [ e + 1 ] ;\n i ++ ) {\n LOCAL_ALIGNED_16 ( float , g_filt_tab , [ 48 ] ) ;\n LOCAL_ALIGNED_16 ( float , q_filt_tab , [ 48 ] ) ;\n float * g_filt , * q_filt ;\n if ( h_SL && e != e_a [ 0 ] && e != e_a [ 1 ] ) {\n g_filt = g_filt_tab ;\n q_filt = q_filt_tab ;\n for ( m = 0 ;\n m < m_max ;\n m ++ ) {\n const int idx1 = i + h_SL ;\n g_filt [ m ] = 0.0f ;\n q_filt [ m ] = 0.0f ;\n for ( j = 0 ;\n j <= h_SL ;\n j ++ ) {\n g_filt [ m ] += g_temp [ idx1 - j ] [ m ] * h_smooth [ j ] ;\n q_filt [ m ] += q_temp [ idx1 - j ] [ m ] * h_smooth [ j ] ;\n }\n }\n }\n else {\n g_filt = g_temp [ i + h_SL ] ;\n q_filt = q_temp [ i ] ;\n }\n sbr -> dsp . hf_g_filt ( Y1 [ i ] + kx , X_high + kx , g_filt , m_max , i + ENVELOPE_ADJUSTMENT_OFFSET ) ;\n if ( e != e_a [ 0 ] && e != e_a [ 1 ] ) {\n sbr -> dsp . hf_apply_noise [ indexsine ] ( Y1 [ i ] + kx , sbr -> s_m [ e ] , q_filt , indexnoise , kx , m_max ) ;\n }\n else {\n int idx = indexsine & 1 ;\n int A = ( 1 - ( ( indexsine + ( kx & 1 ) ) & 2 ) ) ;\n int B = ( A ^ ( - idx ) ) + idx ;\n float * out = & Y1 [ i ] [ kx ] [ idx ] ;\n float * in = sbr -> s_m [ e ] ;\n for ( m = 0 ;\n m + 1 < m_max ;\n m += 2 ) {\n out [ 2 * m ] += in [ m ] * A ;\n out [ 2 * m + 2 ] += in [ m + 1 ] * B ;\n }\n if ( m_max & 1 ) out [ 2 * m ] += in [ m ] * A ;\n }\n indexnoise = ( indexnoise + m_max ) & 0x1ff ;\n indexsine = ( indexsine + 1 ) & 3 ;\n }\n }\n ch_data -> f_indexnoise = indexnoise ;\n ch_data -> f_indexsine = indexsine ;\n }", "idx": 21721}
{"hash": -1055531103257174901, "project": "debian", "size": 5, "label": 1, "functionSource": "static void sig_message_join ( SERVER_REC * server , const char * channel , const char * nick , const char * address ) {\n CHANNEL_REC * chanrec ;\n chanrec = channel_find ( server , channel ) ;\n if ( chanrec != NULL ) CHANNEL_LAST_MSG_ADD ( chanrec , nick , FALSE ) ;\n }", "idx": 21722}
{"hash": 2895622461494525400, "project": "debian", "size": 58, "label": 0, "functionSource": "static void test_bind_result ( ) {\n MYSQL_STMT * stmt ;\n int rc ;\n int nData ;\n ulong length1 ;\n char szData [ 100 ] ;\n MYSQL_BIND my_bind [ 2 ] ;\n my_bool is_null [ 2 ] ;\n myheader ( \"test_bind_result\" ) ;\n rc = mysql_query ( mysql , \"DROP TABLE IF EXISTS test_bind_result\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"CREATE TABLE test_bind_result(col1 int , col2 varchar(50))\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"INSERT INTO test_bind_result VALUES(10, 'venu')\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"INSERT INTO test_bind_result VALUES(20, 'MySQL')\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"INSERT INTO test_bind_result(col2) VALUES('monty')\" ) ;\n myquery ( rc ) ;\n rc = mysql_commit ( mysql ) ;\n myquery ( rc ) ;\n memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n my_bind [ 0 ] . buffer_type = MYSQL_TYPE_LONG ;\n my_bind [ 0 ] . buffer = ( void * ) & nData ;\n my_bind [ 0 ] . is_null = & is_null [ 0 ] ;\n my_bind [ 1 ] . buffer_type = MYSQL_TYPE_STRING ;\n my_bind [ 1 ] . buffer = szData ;\n my_bind [ 1 ] . buffer_length = sizeof ( szData ) ;\n my_bind [ 1 ] . length = & length1 ;\n my_bind [ 1 ] . is_null = & is_null [ 1 ] ;\n stmt = mysql_simple_prepare ( mysql , \"SELECT * FROM test_bind_result\" ) ;\n check_stmt ( stmt ) ;\n rc = mysql_stmt_bind_result ( stmt , my_bind ) ;\n check_execute ( stmt , rc ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n rc = mysql_stmt_fetch ( stmt ) ;\n check_execute ( stmt , rc ) ;\n if ( ! opt_silent ) fprintf ( stdout , \"\\n row 1: %d, %s(%lu)\" , nData , szData , length1 ) ;\n DIE_UNLESS ( nData == 10 ) ;\n DIE_UNLESS ( strcmp ( szData , \"venu\" ) == 0 ) ;\n DIE_UNLESS ( length1 == 4 ) ;\n rc = mysql_stmt_fetch ( stmt ) ;\n check_execute ( stmt , rc ) ;\n if ( ! opt_silent ) fprintf ( stdout , \"\\n row 2: %d, %s(%lu)\" , nData , szData , length1 ) ;\n DIE_UNLESS ( nData == 20 ) ;\n DIE_UNLESS ( strcmp ( szData , \"MySQL\" ) == 0 ) ;\n DIE_UNLESS ( length1 == 5 ) ;\n rc = mysql_stmt_fetch ( stmt ) ;\n check_execute ( stmt , rc ) ;\n if ( ! opt_silent && is_null [ 0 ] ) fprintf ( stdout , \"\\n row 3: NULL, %s(%lu)\" , szData , length1 ) ;\n DIE_UNLESS ( is_null [ 0 ] ) ;\n DIE_UNLESS ( strcmp ( szData , \"monty\" ) == 0 ) ;\n DIE_UNLESS ( length1 == 5 ) ;\n rc = mysql_stmt_fetch ( stmt ) ;\n DIE_UNLESS ( rc == MYSQL_NO_DATA ) ;\n mysql_stmt_close ( stmt ) ;\n }", "idx": 21723}
{"hash": -942846491258578486, "project": "debian", "size": 15, "label": 0, "functionSource": "static get_contents_ret get_contents ( char * linebuf , size_t len , FILE * stream ) {\n size_t remaining_len = len ;\n char * curbuf = linebuf ;\n do {\n int curlen = ( ( remaining_len > ( size_t ) INT_MAX ) ? INT_MAX : remaining_len ) ;\n ( ( unsigned char * ) curbuf ) [ curlen - 1 ] = 0xff ;\n char * p = fgets_unlocked ( curbuf , curlen , stream ) ;\n if ( p == NULL ) return gcr_error ;\n if ( ( ( unsigned char * ) curbuf ) [ curlen - 1 ] == 0xff ) return gcr_ok ;\n remaining_len -= curlen - 1 ;\n curbuf += curlen - 1 ;\n }\n while ( remaining_len > 1 ) ;\n return gcr_overflow ;\n }", "idx": 21724}
{"hash": -6119142299306266167, "project": "debian", "size": 30, "label": 0, "functionSource": "static int cond_continue ( i_ctx_t * i_ctx_p ) {\n os_ptr op = osp ;\n es_ptr ep = esp ;\n int code ;\n check_type ( * op , t_boolean ) ;\n if ( op -> value . boolval ) {\n array_get ( imemory , ep , 1L , ep ) ;\n esfile_check_cache ( ) ;\n code = o_pop_estack ;\n }\n else if ( r_size ( ep ) > 2 ) {\n const ref_packed * elts = ep -> value . packed ;\n check_estack ( 2 ) ;\n r_dec_size ( ep , 2 ) ;\n elts = packed_next ( elts ) ;\n elts = packed_next ( elts ) ;\n ep -> value . packed = elts ;\n array_get ( imemory , ep , 0L , ep + 2 ) ;\n make_op_estack ( ep + 1 , cond_continue ) ;\n esp = ep + 2 ;\n esfile_check_cache ( ) ;\n code = o_push_estack ;\n }\n else {\n esp = ep - 1 ;\n code = o_pop_estack ;\n }\n pop ( 1 ) ;\n return code ;\n }", "idx": 21725}
{"hash": 1223258652239369123, "project": "debian", "size": 12, "label": 1, "functionSource": "SPL_METHOD ( SplFileObject , setMaxLineLen ) {\n long max_len ;\n spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , \"l\" , & max_len ) == FAILURE ) {\n return ;\n }\n if ( max_len < 0 ) {\n zend_throw_exception_ex ( spl_ce_DomainException , 0 TSRMLS_CC , \"Maximum line length must be greater than or equal zero\" ) ;\n return ;\n }\n intern -> u . file . max_line_len = max_len ;\n }", "idx": 21726}
{"hash": 1676654288894940649, "project": "debian", "size": 19, "label": 0, "functionSource": "void kadmin_getpols ( int argc , char * argv [ ] ) {\n krb5_error_code retval ;\n char * expr , * * names ;\n int i , count ;\n expr = NULL ;\n if ( ! ( argc == 1 || ( argc == 2 && ( expr = argv [ 1 ] ) ) ) ) {\n fprintf ( stderr , _ ( \"usage: get_policies [expression]\\n\" ) ) ;\n return ;\n }\n retval = kadm5_get_policies ( handle , expr , & names , & count ) ;\n if ( retval ) {\n com_err ( \"get_policies\" , retval , _ ( \"while retrieving list.\" ) ) ;\n return ;\n }\n for ( i = 0 ;\n i < count ;\n i ++ ) printf ( \"%s\\n\" , names [ i ] ) ;\n kadm5_free_name_list ( handle , names , count ) ;\n }", "idx": 21727}
{"hash": 3599206110384554647, "project": "debian", "size": 87, "label": 0, "functionSource": "void name ## _free ( type * a ) ;\n # define DECLARE_ASN1_PRINT_FUNCTION ( stname ) DECLARE_ASN1_PRINT_FUNCTION_fname ( stname , stname ) # define DECLARE_ASN1_PRINT_FUNCTION_fname ( stname , fname ) int fname ## _print_ctx ( BIO * out , stname * x , int indent , const ASN1_PCTX * pctx ) ;\n # define D2I_OF ( type ) type * ( * ) ( type * * , const unsigned char * * , long ) # define I2D_OF ( type ) int ( * ) ( type * , unsigned char * * ) # define I2D_OF_const ( type ) int ( * ) ( const type * , unsigned char * * ) # define CHECKED_D2I_OF ( type , d2i ) ( ( d2i_of_void * ) ( 1 ? d2i : ( ( D2I_OF ( type ) ) 0 ) ) ) # define CHECKED_I2D_OF ( type , i2d ) ( ( i2d_of_void * ) ( 1 ? i2d : ( ( I2D_OF ( type ) ) 0 ) ) ) # define CHECKED_NEW_OF ( type , xnew ) ( ( void * ( * ) ( void ) ) ( 1 ? xnew : ( ( type * ( * ) ( void ) ) 0 ) ) ) # define CHECKED_PTR_OF ( type , p ) ( ( void * ) ( 1 ? p : ( type * ) 0 ) ) # define CHECKED_PPTR_OF ( type , p ) ( ( void * * ) ( 1 ? p : ( type * * ) 0 ) ) # define TYPEDEF_D2I_OF ( type ) typedef type * d2i_of_ ## type ( type * * , const unsigned char * * , long ) # define TYPEDEF_I2D_OF ( type ) typedef int i2d_of_ ## type ( type * , unsigned char * * ) # define TYPEDEF_D2I2D_OF ( type ) TYPEDEF_D2I_OF ( type ) ;\n TYPEDEF_I2D_OF ( type ) TYPEDEF_D2I2D_OF ( void ) ;\n # ifndef OPENSSL_EXPORT_VAR_AS_FUNCTION typedef const ASN1_ITEM ASN1_ITEM_EXP ;\n # define ASN1_ITEM_ptr ( iptr ) ( iptr ) # define ASN1_ITEM_ref ( iptr ) ( & ( iptr ## _it ) ) # define ASN1_ITEM_rptr ( ref ) ( & ( ref ## _it ) ) # define DECLARE_ASN1_ITEM ( name ) OPENSSL_EXTERN const ASN1_ITEM name ## _it ;\n # else typedef const ASN1_ITEM * ASN1_ITEM_EXP ( void ) ;\n # define ASN1_ITEM_ptr ( iptr ) ( iptr ( ) ) # define ASN1_ITEM_ref ( iptr ) ( iptr ## _it ) # define ASN1_ITEM_rptr ( ref ) ( ref ## _it ( ) ) # define DECLARE_ASN1_ITEM ( name ) const ASN1_ITEM * name ## _it ( void ) ;\n # endif # define ASN1_STRFLGS_ESC_2253 1 # define ASN1_STRFLGS_ESC_CTRL 2 # define ASN1_STRFLGS_ESC_MSB 4 # define ASN1_STRFLGS_ESC_QUOTE 8 # define CHARTYPE_PRINTABLESTRING 0x10 # define CHARTYPE_FIRST_ESC_2253 0x20 # define CHARTYPE_LAST_ESC_2253 0x40 # define ASN1_STRFLGS_UTF8_CONVERT 0x10 # define ASN1_STRFLGS_IGNORE_TYPE 0x20 # define ASN1_STRFLGS_SHOW_TYPE 0x40 # define ASN1_STRFLGS_DUMP_ALL 0x80 # define ASN1_STRFLGS_DUMP_UNKNOWN 0x100 # define ASN1_STRFLGS_DUMP_DER 0x200 # define ASN1_STRFLGS_ESC_2254 0x400 # define ASN1_STRFLGS_RFC2253 ( ASN1_STRFLGS_ESC_2253 | ASN1_STRFLGS_ESC_CTRL | ASN1_STRFLGS_ESC_MSB | ASN1_STRFLGS_UTF8_CONVERT | ASN1_STRFLGS_DUMP_UNKNOWN | ASN1_STRFLGS_DUMP_DER ) DEFINE_STACK_OF ( ASN1_INTEGER ) DEFINE_STACK_OF ( ASN1_GENERALSTRING ) DEFINE_STACK_OF ( ASN1_UTF8STRING ) typedef struct asn1_type_st {\n int type ;\n union {\n char * ptr ;\n ASN1_BOOLEAN boolean ;\n ASN1_STRING * asn1_string ;\n ASN1_OBJECT * object ;\n ASN1_INTEGER * integer ;\n ASN1_ENUMERATED * enumerated ;\n ASN1_BIT_STRING * bit_string ;\n ASN1_OCTET_STRING * octet_string ;\n ASN1_PRINTABLESTRING * printablestring ;\n ASN1_T61STRING * t61string ;\n ASN1_IA5STRING * ia5string ;\n ASN1_GENERALSTRING * generalstring ;\n ASN1_BMPSTRING * bmpstring ;\n ASN1_UNIVERSALSTRING * universalstring ;\n ASN1_UTCTIME * utctime ;\n ASN1_GENERALIZEDTIME * generalizedtime ;\n ASN1_VISIBLESTRING * visiblestring ;\n ASN1_UTF8STRING * utf8string ;\n ASN1_STRING * set ;\n ASN1_STRING * sequence ;\n ASN1_VALUE * asn1_value ;\n }\n value ;\n }\n ASN1_TYPE ;\n DEFINE_STACK_OF ( ASN1_TYPE ) typedef STACK_OF ( ASN1_TYPE ) ASN1_SEQUENCE_ANY ;\n DECLARE_ASN1_ENCODE_FUNCTIONS_const ( ASN1_SEQUENCE_ANY , ASN1_SEQUENCE_ANY ) DECLARE_ASN1_ENCODE_FUNCTIONS_const ( ASN1_SEQUENCE_ANY , ASN1_SET_ANY ) typedef struct BIT_STRING_BITNAME_st {\n int bitnum ;\n const char * lname ;\n const char * sname ;\n }\n BIT_STRING_BITNAME ;\n # define B_ASN1_TIME B_ASN1_UTCTIME | B_ASN1_GENERALIZEDTIME # define B_ASN1_PRINTABLE B_ASN1_NUMERICSTRING | B_ASN1_PRINTABLESTRING | B_ASN1_T61STRING | B_ASN1_IA5STRING | B_ASN1_BIT_STRING | B_ASN1_UNIVERSALSTRING | B_ASN1_BMPSTRING | B_ASN1_UTF8STRING | B_ASN1_SEQUENCE | B_ASN1_UNKNOWN # define B_ASN1_DIRECTORYSTRING B_ASN1_PRINTABLESTRING | B_ASN1_TELETEXSTRING | B_ASN1_BMPSTRING | B_ASN1_UNIVERSALSTRING | B_ASN1_UTF8STRING # define B_ASN1_DISPLAYTEXT B_ASN1_IA5STRING | B_ASN1_VISIBLESTRING | B_ASN1_BMPSTRING | B_ASN1_UTF8STRING DECLARE_ASN1_FUNCTIONS_fname ( ASN1_TYPE , ASN1_ANY , ASN1_TYPE ) int ASN1_TYPE_get ( const ASN1_TYPE * a ) ;\n void ASN1_TYPE_set ( ASN1_TYPE * a , int type , void * value ) ;\n int ASN1_TYPE_set1 ( ASN1_TYPE * a , int type , const void * value ) ;\n int ASN1_TYPE_cmp ( const ASN1_TYPE * a , const ASN1_TYPE * b ) ;\n ASN1_TYPE * ASN1_TYPE_pack_sequence ( const ASN1_ITEM * it , void * s , ASN1_TYPE * * t ) ;\n void * ASN1_TYPE_unpack_sequence ( const ASN1_ITEM * it , const ASN1_TYPE * t ) ;\n ASN1_OBJECT * ASN1_OBJECT_new ( void ) ;\n void ASN1_OBJECT_free ( ASN1_OBJECT * a ) ;\n int i2d_ASN1_OBJECT ( const ASN1_OBJECT * a , unsigned char * * pp ) ;\n ASN1_OBJECT * d2i_ASN1_OBJECT ( ASN1_OBJECT * * a , const unsigned char * * pp , long length ) ;\n DECLARE_ASN1_ITEM ( ASN1_OBJECT ) DEFINE_STACK_OF ( ASN1_OBJECT ) ASN1_STRING * ASN1_STRING_new ( void ) ;\n void ASN1_STRING_free ( ASN1_STRING * a ) ;\n void ASN1_STRING_clear_free ( ASN1_STRING * a ) ;\n int ASN1_STRING_copy ( ASN1_STRING * dst , const ASN1_STRING * str ) ;\n ASN1_STRING * ASN1_STRING_dup ( const ASN1_STRING * a ) ;\n ASN1_STRING * ASN1_STRING_type_new ( int type ) ;\n int ASN1_STRING_cmp ( const ASN1_STRING * a , const ASN1_STRING * b ) ;\n int ASN1_STRING_set ( ASN1_STRING * str , const void * data , int len ) ;\n void ASN1_STRING_set0 ( ASN1_STRING * str , void * data , int len ) ;\n int ASN1_STRING_length ( const ASN1_STRING * x ) ;\n void ASN1_STRING_length_set ( ASN1_STRING * x , int n ) ;\n int ASN1_STRING_type ( const ASN1_STRING * x ) ;\n DEPRECATEDIN_1_1_0 ( unsigned char * ASN1_STRING_data ( ASN1_STRING * x ) ) const unsigned char * ASN1_STRING_get0_data ( const ASN1_STRING * x ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_BIT_STRING ) int ASN1_BIT_STRING_set ( ASN1_BIT_STRING * a , unsigned char * d , int length ) ;\n int ASN1_BIT_STRING_set_bit ( ASN1_BIT_STRING * a , int n , int value ) ;\n int ASN1_BIT_STRING_get_bit ( const ASN1_BIT_STRING * a , int n ) ;\n int ASN1_BIT_STRING_check ( const ASN1_BIT_STRING * a , const unsigned char * flags , int flags_len ) ;\n int ASN1_BIT_STRING_name_print ( BIO * out , ASN1_BIT_STRING * bs , BIT_STRING_BITNAME * tbl , int indent ) ;\n int ASN1_BIT_STRING_num_asc ( const char * name , BIT_STRING_BITNAME * tbl ) ;\n int ASN1_BIT_STRING_set_asc ( ASN1_BIT_STRING * bs , const char * name , int value , BIT_STRING_BITNAME * tbl ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_INTEGER ) ASN1_INTEGER * d2i_ASN1_UINTEGER ( ASN1_INTEGER * * a , const unsigned char * * pp , long length ) ;\n ASN1_INTEGER * ASN1_INTEGER_dup ( const ASN1_INTEGER * x ) ;\n int ASN1_INTEGER_cmp ( const ASN1_INTEGER * x , const ASN1_INTEGER * y ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_ENUMERATED ) int ASN1_UTCTIME_check ( const ASN1_UTCTIME * a ) ;\n ASN1_UTCTIME * ASN1_UTCTIME_set ( ASN1_UTCTIME * s , time_t t ) ;\n ASN1_UTCTIME * ASN1_UTCTIME_adj ( ASN1_UTCTIME * s , time_t t , int offset_day , long offset_sec ) ;\n int ASN1_UTCTIME_set_string ( ASN1_UTCTIME * s , const char * str ) ;\n int ASN1_UTCTIME_cmp_time_t ( const ASN1_UTCTIME * s , time_t t ) ;\n int ASN1_GENERALIZEDTIME_check ( const ASN1_GENERALIZEDTIME * a ) ;\n ASN1_GENERALIZEDTIME * ASN1_GENERALIZEDTIME_set ( ASN1_GENERALIZEDTIME * s , time_t t ) ;\n ASN1_GENERALIZEDTIME * ASN1_GENERALIZEDTIME_adj ( ASN1_GENERALIZEDTIME * s , time_t t , int offset_day , long offset_sec ) ;\n int ASN1_GENERALIZEDTIME_set_string ( ASN1_GENERALIZEDTIME * s , const char * str ) ;\n int ASN1_TIME_diff ( int * pday , int * psec , const ASN1_TIME * from , const ASN1_TIME * to ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_OCTET_STRING )", "idx": 21728}
{"hash": 2546373479020365143, "project": "debian", "size": 4, "label": 0, "functionSource": "int mime_field_presence_get ( MIMEHdrImpl * h , const char * well_known_str ) {\n uint64_t mask = mime_field_presence_mask ( well_known_str ) ;\n return ( ( mask == 0 ) ? 1 : ( ( h -> m_presence_bits & mask ) == 0 ? 0 : 1 ) ) ;\n }", "idx": 21729}
{"hash": 1749848421437618984, "project": "chrome", "size": 42, "label": 0, "functionSource": "hb_tag_t hb_ot_tag_from_language ( hb_language_t language ) {\n const char * lang_str , * s ;\n if ( language == HB_LANGUAGE_INVALID ) return HB_OT_TAG_DEFAULT_LANGUAGE ;\n lang_str = hb_language_to_string ( language ) ;\n s = strstr ( lang_str , \"x-hbot\" ) ;\n if ( s ) {\n char tag [ 4 ] ;\n int i ;\n s += 6 ;\n for ( i = 0 ;\n i < 4 && ISALPHA ( s [ i ] ) ;\n i ++ ) tag [ i ] = TOUPPER ( s [ i ] ) ;\n if ( i ) {\n for ( ;\n i < 4 ;\n i ++ ) tag [ i ] = ' ' ;\n return HB_TAG_CHAR4 ( tag ) ;\n }\n }\n {\n const LangTag * lang_tag ;\n lang_tag = ( LangTag * ) bsearch ( lang_str , ot_languages , ARRAY_LENGTH ( ot_languages ) , sizeof ( LangTag ) , ( hb_compare_func_t ) lang_compare_first_component ) ;\n if ( lang_tag ) return lang_tag -> tag ;\n }\n if ( 0 == lang_compare_first_component ( lang_str , \"zh\" ) ) {\n unsigned int i ;\n for ( i = 0 ;\n i < ARRAY_LENGTH ( ot_languages_zh ) ;\n i ++ ) {\n const LangTagLong * lang_tag ;\n lang_tag = & ot_languages_zh [ i ] ;\n if ( lang_matches ( lang_str , lang_tag -> language ) ) return lang_tag -> tag ;\n }\n return HB_TAG ( 'Z' , 'H' , 'S' , ' ' ) ;\n }\n s = strchr ( lang_str , '-' ) ;\n if ( ! s ) s = lang_str + strlen ( lang_str ) ;\n if ( s - lang_str == 3 ) {\n return hb_tag_from_string ( lang_str , s - lang_str ) & ~ 0x20202000u ;\n }\n return HB_OT_TAG_DEFAULT_LANGUAGE ;\n }", "idx": 21730}
{"hash": 7039307292471244756, "project": "debian", "size": 9, "label": 0, "functionSource": "static guint16 de_repeat_ind ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len _U_ , gchar * add_string _U_ , int string_len _U_ ) {\n guint8 oct ;\n guint32 curr_offset ;\n curr_offset = offset ;\n oct = tvb_get_guint8 ( tvb , curr_offset ) ;\n proto_tree_add_uint_format_value ( tree , hf_gsm_a_dtap_repeat_indicator , tvb , curr_offset , 1 , oct , \"%s\" , val_to_str_const ( oct & 0xF , gsm_a_dtap_repeat_indicator_vals , \"Reserved\" ) ) ;\n curr_offset ++ ;\n return ( curr_offset - offset ) ;\n }", "idx": 21731}
{"hash": -4555950263653671147, "project": "debian", "size": 10, "label": 0, "functionSource": "static int string_contains ( PyObject * str_obj , PyObject * sub_obj ) {\n if ( ! PyString_CheckExact ( sub_obj ) ) {\n # ifdef Py_USING_UNICODE if ( PyUnicode_Check ( sub_obj ) ) return PyUnicode_Contains ( str_obj , sub_obj ) ;\n # endif if ( ! PyString_Check ( sub_obj ) ) {\n PyErr_Format ( PyExc_TypeError , \"'in <string>' requires string as left operand, \" \"not %.200s\" , Py_TYPE ( sub_obj ) -> tp_name ) ;\n return - 1 ;\n }\n }\n return stringlib_contains_obj ( str_obj , sub_obj ) ;\n }", "idx": 21732}
{"hash": -789251383577298283, "project": "debian", "size": 79, "label": 0, "functionSource": "static int fmtfp ( char * * sbuffer , char * * buffer , size_t * currlen , size_t * maxlen , LDOUBLE fvalue , int min , int max , int flags ) {\n int signvalue = 0 ;\n LDOUBLE ufvalue ;\n char iconvert [ 20 ] ;\n char fconvert [ 20 ] ;\n int iplace = 0 ;\n int fplace = 0 ;\n int padlen = 0 ;\n int zpadlen = 0 ;\n long intpart ;\n long fracpart ;\n long max10 ;\n if ( max < 0 ) max = 6 ;\n ufvalue = abs_val ( fvalue ) ;\n if ( fvalue < 0 ) signvalue = '-' ;\n else if ( flags & DP_F_PLUS ) signvalue = '+' ;\n else if ( flags & DP_F_SPACE ) signvalue = ' ' ;\n intpart = ( long ) ufvalue ;\n if ( max > 9 ) max = 9 ;\n max10 = roundv ( pow_10 ( max ) ) ;\n fracpart = roundv ( pow_10 ( max ) * ( ufvalue - intpart ) ) ;\n if ( fracpart >= max10 ) {\n intpart ++ ;\n fracpart -= max10 ;\n }\n do {\n iconvert [ iplace ++ ] = \"0123456789\" [ intpart % 10 ] ;\n intpart = ( intpart / 10 ) ;\n }\n while ( intpart && ( iplace < ( int ) sizeof ( iconvert ) ) ) ;\n if ( iplace == sizeof iconvert ) iplace -- ;\n iconvert [ iplace ] = 0 ;\n do {\n fconvert [ fplace ++ ] = \"0123456789\" [ fracpart % 10 ] ;\n fracpart = ( fracpart / 10 ) ;\n }\n while ( fplace < max ) ;\n if ( fplace == sizeof fconvert ) fplace -- ;\n fconvert [ fplace ] = 0 ;\n padlen = min - iplace - max - 1 - ( ( signvalue ) ? 1 : 0 ) ;\n zpadlen = max - fplace ;\n if ( zpadlen < 0 ) zpadlen = 0 ;\n if ( padlen < 0 ) padlen = 0 ;\n if ( flags & DP_F_MINUS ) padlen = - padlen ;\n if ( ( flags & DP_F_ZERO ) && ( padlen > 0 ) ) {\n if ( signvalue ) {\n if ( ! doapr_outch ( sbuffer , buffer , currlen , maxlen , signvalue ) ) return 0 ;\n -- padlen ;\n signvalue = 0 ;\n }\n while ( padlen > 0 ) {\n if ( ! doapr_outch ( sbuffer , buffer , currlen , maxlen , '0' ) ) return 0 ;\n -- padlen ;\n }\n }\n while ( padlen > 0 ) {\n if ( ! doapr_outch ( sbuffer , buffer , currlen , maxlen , ' ' ) ) return 0 ;\n -- padlen ;\n }\n if ( signvalue && ! doapr_outch ( sbuffer , buffer , currlen , maxlen , signvalue ) ) return 0 ;\n while ( iplace > 0 ) {\n if ( ! doapr_outch ( sbuffer , buffer , currlen , maxlen , iconvert [ -- iplace ] ) ) return 0 ;\n }\n if ( max > 0 || ( flags & DP_F_NUM ) ) {\n if ( ! doapr_outch ( sbuffer , buffer , currlen , maxlen , '.' ) ) return 0 ;\n while ( fplace > 0 ) {\n if ( ! doapr_outch ( sbuffer , buffer , currlen , maxlen , fconvert [ -- fplace ] ) ) return 0 ;\n }\n }\n while ( zpadlen > 0 ) {\n if ( ! doapr_outch ( sbuffer , buffer , currlen , maxlen , '0' ) ) return 0 ;\n -- zpadlen ;\n }\n while ( padlen < 0 ) {\n if ( ! doapr_outch ( sbuffer , buffer , currlen , maxlen , ' ' ) ) return 0 ;\n ++ padlen ;\n }\n return 1 ;\n }", "idx": 21733}
{"hash": 6910889735724933479, "project": "debian", "size": 65, "label": 1, "functionSource": "static void bamboo_init ( ram_addr_t ram_size , const char * boot_device , const char * kernel_filename , const char * kernel_cmdline , const char * initrd_filename , const char * cpu_model ) {\n unsigned int pci_irq_nrs [ 4 ] = {\n 28 , 27 , 26 , 25 }\n ;\n PCIBus * pcibus ;\n CPUState * env ;\n uint64_t elf_entry ;\n uint64_t elf_lowaddr ;\n target_phys_addr_t entry = 0 ;\n target_phys_addr_t loadaddr = 0 ;\n target_long kernel_size = 0 ;\n target_ulong initrd_base = 0 ;\n target_long initrd_size = 0 ;\n target_ulong dt_base = 0 ;\n void * fdt ;\n int i ;\n env = ppc440ep_init ( & ram_size , & pcibus , pci_irq_nrs , 1 , cpu_model ) ;\n if ( pcibus ) {\n for ( i = 0 ;\n i < MAX_VIRTIO_CONSOLES ;\n i ++ ) {\n if ( virtcon_hds [ i ] ) {\n pci_create_simple ( pcibus , - 1 , \"virtio-console-pci\" ) ;\n }\n }\n for ( i = 0 ;\n i < nb_nics ;\n i ++ ) {\n pci_nic_init_nofail ( & nd_table [ i ] , \"e1000\" , NULL ) ;\n }\n }\n if ( kernel_filename ) {\n kernel_size = load_uimage ( kernel_filename , & entry , & loadaddr , NULL ) ;\n if ( kernel_size < 0 ) {\n kernel_size = load_elf ( kernel_filename , 0 , & elf_entry , & elf_lowaddr , NULL , 1 , ELF_MACHINE , 0 ) ;\n entry = elf_entry ;\n loadaddr = elf_lowaddr ;\n }\n if ( kernel_size < 0 ) {\n fprintf ( stderr , \"qemu: could not load kernel '%s'\\n\" , kernel_filename ) ;\n exit ( 1 ) ;\n }\n }\n if ( initrd_filename ) {\n initrd_base = kernel_size + loadaddr ;\n initrd_size = load_image_targphys ( initrd_filename , initrd_base , ram_size - initrd_base ) ;\n if ( initrd_size < 0 ) {\n fprintf ( stderr , \"qemu: could not load initial ram disk '%s'\\n\" , initrd_filename ) ;\n exit ( 1 ) ;\n }\n }\n if ( kernel_filename ) {\n if ( initrd_base ) dt_base = initrd_base + initrd_size ;\n else dt_base = kernel_size + loadaddr ;\n fdt = bamboo_load_device_tree ( dt_base , ram_size , initrd_base , initrd_size , kernel_cmdline ) ;\n if ( fdt == NULL ) {\n fprintf ( stderr , \"couldn't load device tree\\n\" ) ;\n exit ( 1 ) ;\n }\n env -> gpr [ 1 ] = ( 16 << 20 ) - 8 ;\n env -> gpr [ 3 ] = dt_base ;\n env -> nip = entry ;\n }\n if ( kvm_enabled ( ) ) kvmppc_init ( ) ;\n }", "idx": 21734}
{"hash": -8562387810778703674, "project": "chrome", "size": 9, "label": 0, "functionSource": "static hb_bool_t hb_font_get_glyph_contour_point_nil ( hb_font_t * font , void * font_data HB_UNUSED , hb_codepoint_t glyph , unsigned int point_index , hb_position_t * x , hb_position_t * y , void * user_data HB_UNUSED ) {\n if ( font -> parent ) {\n hb_bool_t ret = font -> parent -> get_glyph_contour_point ( glyph , point_index , x , y ) ;\n if ( ret ) font -> parent_scale_position ( x , y ) ;\n return ret ;\n }\n * x = * y = 0 ;\n return false ;\n }", "idx": 21735}
{"hash": 5357882892791796049, "project": "debian", "size": 9, "label": 0, "functionSource": "static inline void e1000e_autoneg_timer ( void * opaque ) {\n E1000ECore * core = opaque ;\n if ( ! qemu_get_queue ( core -> owner_nic ) -> link_down ) {\n e1000x_update_regs_on_autoneg_done ( core -> mac , core -> phy [ 0 ] ) ;\n e1000e_start_recv ( core ) ;\n e1000e_update_flowctl_status ( core ) ;\n e1000e_set_interrupt_cause ( core , E1000_ICR_LSC ) ;\n }\n }", "idx": 21736}
{"hash": 8127806390163862344, "project": "debian", "size": 8, "label": 0, "functionSource": "static void vapic_class_init ( ObjectClass * klass , void * data ) {\n SysBusDeviceClass * sc = SYS_BUS_DEVICE_CLASS ( klass ) ;\n DeviceClass * dc = DEVICE_CLASS ( klass ) ;\n dc -> no_user = 1 ;\n dc -> reset = vapic_reset ;\n dc -> vmsd = & vmstate_vapic ;\n sc -> init = vapic_init ;\n }", "idx": 21737}
{"hash": 6458694302493204858, "project": "debian", "size": 12, "label": 0, "functionSource": "static Datum ExecEvalOper ( FuncExprState * fcache , ExprContext * econtext , bool * isNull , ExprDoneCond * isDone ) {\n OpExpr * op = ( OpExpr * ) fcache -> xprstate . expr ;\n init_fcache ( op -> opfuncid , op -> inputcollid , fcache , econtext -> ecxt_per_query_memory , true ) ;\n if ( fcache -> func . fn_retset || expression_returns_set ( ( Node * ) op -> args ) ) {\n fcache -> xprstate . evalfunc = ( ExprStateEvalFunc ) ExecMakeFunctionResult ;\n return ExecMakeFunctionResult ( fcache , econtext , isNull , isDone ) ;\n }\n else {\n fcache -> xprstate . evalfunc = ( ExprStateEvalFunc ) ExecMakeFunctionResultNoSets ;\n return ExecMakeFunctionResultNoSets ( fcache , econtext , isNull , isDone ) ;\n }\n }", "idx": 21738}
{"hash": 3766491362463647945, "project": "debian", "size": 30, "label": 0, "functionSource": "static int map_uri_to_page_cache_file ( ngx_http_request_t * r , ngx_str_t * public_dir , const u_char * filename , size_t filename_len , ngx_str_t * page_cache_file ) {\n u_char * end ;\n if ( ( r -> method != NGX_HTTP_GET && r -> method != NGX_HTTP_HEAD ) || filename_len == 0 ) {\n return 0 ;\n }\n if ( mapped_filename_equals ( filename , filename_len , public_dir ) ) {\n if ( filename_len + sizeof ( \"/index.html\" ) > page_cache_file -> len ) {\n return 0 ;\n }\n end = ngx_copy ( page_cache_file -> data , filename , filename_len ) ;\n if ( filename [ filename_len - 1 ] != '/' ) {\n end = ngx_copy ( end , \"/\" , 1 ) ;\n }\n end = ngx_copy ( end , \"index.html\" , sizeof ( \"index.html\" ) ) ;\n }\n else {\n if ( filename_len + sizeof ( \".html\" ) > page_cache_file -> len ) {\n return 0 ;\n }\n end = ngx_copy ( page_cache_file -> data , filename , filename_len ) ;\n end = ngx_copy ( end , \".html\" , sizeof ( \".html\" ) ) ;\n }\n if ( file_exists ( page_cache_file -> data , 0 ) ) {\n page_cache_file -> len = end - page_cache_file -> data - 1 ;\n return 1 ;\n }\n else {\n return 0 ;\n }\n }", "idx": 21739}
{"hash": -3889154245145551951, "project": "debian", "size": 23, "label": 0, "functionSource": "static void * pool_alloc ( size_t len ) {\n struct mem_pool * p ;\n void * r ;\n if ( len & ( sizeof ( uintmax_t ) - 1 ) ) len += sizeof ( uintmax_t ) - ( len & ( sizeof ( uintmax_t ) - 1 ) ) ;\n for ( p = mem_pool ;\n p ;\n p = p -> next_pool ) if ( ( p -> end - p -> next_free >= len ) ) break ;\n if ( ! p ) {\n if ( len >= ( mem_pool_alloc / 2 ) ) {\n total_allocd += len ;\n return xmalloc ( len ) ;\n }\n total_allocd += sizeof ( struct mem_pool ) + mem_pool_alloc ;\n p = xmalloc ( sizeof ( struct mem_pool ) + mem_pool_alloc ) ;\n p -> next_pool = mem_pool ;\n p -> next_free = ( char * ) p -> space ;\n p -> end = p -> next_free + mem_pool_alloc ;\n mem_pool = p ;\n }\n r = p -> next_free ;\n p -> next_free += len ;\n return r ;\n }", "idx": 21740}
{"hash": -7777331401175181229, "project": "debian", "size": 4, "label": 0, "functionSource": "static void sig_server_reconnect_not_found ( const char * tag ) {\n g_return_if_fail ( tag != NULL ) ;\n printformat ( NULL , NULL , MSGLEVEL_CLIENTNOTICE , TXT_RECONNECT_NOT_FOUND , tag ) ;\n }", "idx": 21741}
{"hash": -5493081488206619677, "project": "debian", "size": 6, "label": 0, "functionSource": "static const char * cmd_request_encoding ( cmd_parms * cmd , void * _dcfg , const char * p1 ) {\n directory_config * dcfg = ( directory_config * ) _dcfg ;\n if ( dcfg == NULL ) return NULL ;\n dcfg -> request_encoding = p1 ;\n return NULL ;\n }", "idx": 21742}
{"hash": -398565394354770780, "project": "debian", "size": 17, "label": 0, "functionSource": "static void ohci_process_lists ( OHCIState * ohci , int completion ) {\n if ( ( ohci -> ctl & OHCI_CTL_CLE ) && ( ohci -> status & OHCI_STATUS_CLF ) ) {\n if ( ohci -> ctrl_cur && ohci -> ctrl_cur != ohci -> ctrl_head ) {\n trace_usb_ohci_process_lists ( ohci -> ctrl_head , ohci -> ctrl_cur ) ;\n }\n if ( ! ohci_service_ed_list ( ohci , ohci -> ctrl_head , completion ) ) {\n ohci -> ctrl_cur = 0 ;\n ohci -> status &= ~ OHCI_STATUS_CLF ;\n }\n }\n if ( ( ohci -> ctl & OHCI_CTL_BLE ) && ( ohci -> status & OHCI_STATUS_BLF ) ) {\n if ( ! ohci_service_ed_list ( ohci , ohci -> bulk_head , completion ) ) {\n ohci -> bulk_cur = 0 ;\n ohci -> status &= ~ OHCI_STATUS_BLF ;\n }\n }\n }", "idx": 21743}
{"hash": 6302861533225984845, "project": "debian", "size": 7, "label": 0, "functionSource": "static void pxa2xx_rtc_sysbus_class_init ( ObjectClass * klass , void * data ) {\n DeviceClass * dc = DEVICE_CLASS ( klass ) ;\n SysBusDeviceClass * k = SYS_BUS_DEVICE_CLASS ( klass ) ;\n k -> init = pxa2xx_rtc_init ;\n dc -> desc = \"PXA2xx RTC Controller\" ;\n dc -> vmsd = & vmstate_pxa2xx_rtc_regs ;\n }", "idx": 21744}
{"hash": -502031617050384761, "project": "chrome", "size": 12, "label": 1, "functionSource": "int arm_cpu_caps ( void ) {\n int flags ;\n int mask ;\n if ( ! arm_cpu_env_flags ( & flags ) ) {\n return flags ;\n }\n mask = arm_cpu_env_mask ( ) ;\n # if HAVE_EDSP flags |= HAS_EDSP ;\n # endif # if HAVE_MEDIA flags |= HAS_MEDIA ;\n # endif # if HAVE_NEON flags |= HAS_NEON ;\n # endif return flags & mask ;\n }", "idx": 21745}
{"hash": -4978896576290502518, "project": "debian", "size": 17, "label": 0, "functionSource": "void mi_check_print_warning ( MI_CHECK * param , const char * fmt , ... ) {\n va_list args ;\n DBUG_ENTER ( \"mi_check_print_warning\" ) ;\n fflush ( stdout ) ;\n if ( ! param -> warning_printed && ! param -> error_printed ) {\n if ( param -> testflag & T_SILENT ) fprintf ( stderr , \"%s: MyISAM file %s\\n\" , my_progname_short , param -> isam_file_name ) ;\n param -> out_flag |= O_DATA_LOST ;\n }\n param -> warning_printed = 1 ;\n va_start ( args , fmt ) ;\n fprintf ( stderr , \"%s: warning: \" , my_progname_short ) ;\n ( void ) vfprintf ( stderr , fmt , args ) ;\n ( void ) fputc ( '\\n' , stderr ) ;\n fflush ( stderr ) ;\n va_end ( args ) ;\n DBUG_VOID_RETURN ;\n }", "idx": 21746}
{"hash": -954364585377557207, "project": "debian", "size": 26, "label": 0, "functionSource": "static void apply_ir_filter ( float * out , const AMRFixed * in , const float * filter ) {\n float filter1 [ AMR_SUBFRAME_SIZE ] , filter2 [ AMR_SUBFRAME_SIZE ] ;\n int lag = in -> pitch_lag ;\n float fac = in -> pitch_fac ;\n int i ;\n if ( lag < AMR_SUBFRAME_SIZE ) {\n ff_celp_circ_addf ( filter1 , filter , filter , lag , fac , AMR_SUBFRAME_SIZE ) ;\n if ( lag < AMR_SUBFRAME_SIZE >> 1 ) ff_celp_circ_addf ( filter2 , filter , filter1 , lag , fac , AMR_SUBFRAME_SIZE ) ;\n }\n memset ( out , 0 , sizeof ( float ) * AMR_SUBFRAME_SIZE ) ;\n for ( i = 0 ;\n i < in -> n ;\n i ++ ) {\n int x = in -> x [ i ] ;\n float y = in -> y [ i ] ;\n const float * filterp ;\n if ( x >= AMR_SUBFRAME_SIZE - lag ) {\n filterp = filter ;\n }\n else if ( x >= AMR_SUBFRAME_SIZE - ( lag << 1 ) ) {\n filterp = filter1 ;\n }\n else filterp = filter2 ;\n ff_celp_circ_addf ( out , out , filterp , x , y , AMR_SUBFRAME_SIZE ) ;\n }\n }", "idx": 21747}
{"hash": 2578089348587614328, "project": "debian", "size": 3, "label": 0, "functionSource": "X509_SIG * d2i_PKCS8_fp ( FILE * fp , X509_SIG * * p8 ) {\n return ASN1_d2i_fp_of ( X509_SIG , X509_SIG_new , d2i_X509_SIG , fp , p8 ) ;\n }", "idx": 21748}
{"hash": -1710554222303887484, "project": "chrome", "size": 85, "label": 0, "functionSource": "void vp9_idct4x4_16_add_sse2 ( const int16_t * input , uint8_t * dest , int stride ) {\n const __m128i zero = _mm_setzero_si128 ( ) ;\n const __m128i eight = _mm_set1_epi16 ( 8 ) ;\n const __m128i cst = _mm_setr_epi16 ( ( int16_t ) cospi_16_64 , ( int16_t ) cospi_16_64 , ( int16_t ) cospi_16_64 , ( int16_t ) - cospi_16_64 , ( int16_t ) cospi_24_64 , ( int16_t ) - cospi_8_64 , ( int16_t ) cospi_8_64 , ( int16_t ) cospi_24_64 ) ;\n const __m128i rounding = _mm_set1_epi32 ( DCT_CONST_ROUNDING ) ;\n __m128i input0 , input1 , input2 , input3 ;\n input0 = _mm_load_si128 ( ( const __m128i * ) input ) ;\n input2 = _mm_load_si128 ( ( const __m128i * ) ( input + 8 ) ) ;\n input0 = _mm_shufflelo_epi16 ( input0 , 0xd8 ) ;\n input0 = _mm_shufflehi_epi16 ( input0 , 0xd8 ) ;\n input2 = _mm_shufflelo_epi16 ( input2 , 0xd8 ) ;\n input2 = _mm_shufflehi_epi16 ( input2 , 0xd8 ) ;\n input1 = _mm_unpackhi_epi32 ( input0 , input0 ) ;\n input0 = _mm_unpacklo_epi32 ( input0 , input0 ) ;\n input3 = _mm_unpackhi_epi32 ( input2 , input2 ) ;\n input2 = _mm_unpacklo_epi32 ( input2 , input2 ) ;\n input0 = _mm_madd_epi16 ( input0 , cst ) ;\n input1 = _mm_madd_epi16 ( input1 , cst ) ;\n input2 = _mm_madd_epi16 ( input2 , cst ) ;\n input3 = _mm_madd_epi16 ( input3 , cst ) ;\n input0 = _mm_add_epi32 ( input0 , rounding ) ;\n input1 = _mm_add_epi32 ( input1 , rounding ) ;\n input2 = _mm_add_epi32 ( input2 , rounding ) ;\n input3 = _mm_add_epi32 ( input3 , rounding ) ;\n input0 = _mm_srai_epi32 ( input0 , DCT_CONST_BITS ) ;\n input1 = _mm_srai_epi32 ( input1 , DCT_CONST_BITS ) ;\n input2 = _mm_srai_epi32 ( input2 , DCT_CONST_BITS ) ;\n input3 = _mm_srai_epi32 ( input3 , DCT_CONST_BITS ) ;\n input0 = _mm_packs_epi32 ( input0 , input1 ) ;\n input1 = _mm_packs_epi32 ( input2 , input3 ) ;\n input2 = _mm_unpacklo_epi16 ( input0 , input1 ) ;\n input3 = _mm_unpackhi_epi16 ( input0 , input1 ) ;\n input0 = _mm_unpacklo_epi32 ( input2 , input3 ) ;\n input1 = _mm_unpackhi_epi32 ( input2 , input3 ) ;\n input1 = _mm_shuffle_epi32 ( input1 , 0x4e ) ;\n input2 = _mm_add_epi16 ( input0 , input1 ) ;\n input3 = _mm_sub_epi16 ( input0 , input1 ) ;\n input0 = _mm_unpacklo_epi32 ( input2 , input2 ) ;\n input1 = _mm_unpackhi_epi32 ( input2 , input2 ) ;\n input2 = _mm_unpackhi_epi32 ( input3 , input3 ) ;\n input3 = _mm_unpacklo_epi32 ( input3 , input3 ) ;\n input0 = _mm_madd_epi16 ( input0 , cst ) ;\n input1 = _mm_madd_epi16 ( input1 , cst ) ;\n input2 = _mm_madd_epi16 ( input2 , cst ) ;\n input3 = _mm_madd_epi16 ( input3 , cst ) ;\n input0 = _mm_add_epi32 ( input0 , rounding ) ;\n input1 = _mm_add_epi32 ( input1 , rounding ) ;\n input2 = _mm_add_epi32 ( input2 , rounding ) ;\n input3 = _mm_add_epi32 ( input3 , rounding ) ;\n input0 = _mm_srai_epi32 ( input0 , DCT_CONST_BITS ) ;\n input1 = _mm_srai_epi32 ( input1 , DCT_CONST_BITS ) ;\n input2 = _mm_srai_epi32 ( input2 , DCT_CONST_BITS ) ;\n input3 = _mm_srai_epi32 ( input3 , DCT_CONST_BITS ) ;\n input0 = _mm_packs_epi32 ( input0 , input2 ) ;\n input1 = _mm_packs_epi32 ( input1 , input3 ) ;\n input2 = _mm_unpacklo_epi16 ( input0 , input1 ) ;\n input3 = _mm_unpackhi_epi16 ( input0 , input1 ) ;\n input0 = _mm_unpacklo_epi32 ( input2 , input3 ) ;\n input1 = _mm_unpackhi_epi32 ( input2 , input3 ) ;\n input1 = _mm_shuffle_epi32 ( input1 , 0x4e ) ;\n input2 = _mm_add_epi16 ( input0 , input1 ) ;\n input3 = _mm_sub_epi16 ( input0 , input1 ) ;\n input2 = _mm_add_epi16 ( input2 , eight ) ;\n input3 = _mm_add_epi16 ( input3 , eight ) ;\n input2 = _mm_srai_epi16 ( input2 , 4 ) ;\n input3 = _mm_srai_epi16 ( input3 , 4 ) ;\n {\n __m128i d0 = _mm_cvtsi32_si128 ( * ( const int * ) ( dest ) ) ;\n __m128i d2 = _mm_cvtsi32_si128 ( * ( const int * ) ( dest + stride * 2 ) ) ;\n d0 = _mm_unpacklo_epi32 ( d0 , _mm_cvtsi32_si128 ( * ( const int * ) ( dest + stride ) ) ) ;\n d2 = _mm_unpacklo_epi32 ( _mm_cvtsi32_si128 ( * ( const int * ) ( dest + stride * 3 ) ) , d2 ) ;\n d0 = _mm_unpacklo_epi8 ( d0 , zero ) ;\n d2 = _mm_unpacklo_epi8 ( d2 , zero ) ;\n d0 = _mm_add_epi16 ( d0 , input2 ) ;\n d2 = _mm_add_epi16 ( d2 , input3 ) ;\n d0 = _mm_packus_epi16 ( d0 , d2 ) ;\n * ( int * ) dest = _mm_cvtsi128_si32 ( d0 ) ;\n d0 = _mm_srli_si128 ( d0 , 4 ) ;\n * ( int * ) ( dest + stride ) = _mm_cvtsi128_si32 ( d0 ) ;\n d0 = _mm_srli_si128 ( d0 , 4 ) ;\n * ( int * ) ( dest + stride * 3 ) = _mm_cvtsi128_si32 ( d0 ) ;\n d0 = _mm_srli_si128 ( d0 , 4 ) ;\n * ( int * ) ( dest + stride * 2 ) = _mm_cvtsi128_si32 ( d0 ) ;\n }\n }", "idx": 21749}
{"hash": -2943582541244387919, "project": "chrome", "size": 36, "label": 0, "functionSource": "unsigned int vp9_sub_pixel_avg_variance ## W ## x ## H ## _c ( const uint8_t * src , int src_stride , int xoffset , int yoffset , const uint8_t * dst , int dst_stride , unsigned int * sse , const uint8_t * second_pred ) {\n uint16_t fdata3 [ ( H + 1 ) * W ] ;\n uint8_t temp2 [ H * W ] ;\n DECLARE_ALIGNED_ARRAY ( 16 , uint8_t , temp3 , H * W ) ;\n var_filter_block2d_bil_first_pass ( src , fdata3 , src_stride , 1 , H + 1 , W , BILINEAR_FILTERS_2TAP ( xoffset ) ) ;\n var_filter_block2d_bil_second_pass ( fdata3 , temp2 , W , W , H , W , BILINEAR_FILTERS_2TAP ( yoffset ) ) ;\n vp9_comp_avg_pred ( temp3 , second_pred , W , H , temp2 , W ) ;\n return vp9_variance ## W ## x ## H ## _c ( temp3 , W , dst , dst_stride , sse ) ;\n \\ }\n void vp9_get16x16var_c ( const uint8_t * src_ptr , int source_stride , const uint8_t * ref_ptr , int ref_stride , unsigned int * sse , int * sum ) {\n variance ( src_ptr , source_stride , ref_ptr , ref_stride , 16 , 16 , sse , sum ) ;\n }\n void vp9_get8x8var_c ( const uint8_t * src_ptr , int source_stride , const uint8_t * ref_ptr , int ref_stride , unsigned int * sse , int * sum ) {\n variance ( src_ptr , source_stride , ref_ptr , ref_stride , 8 , 8 , sse , sum ) ;\n }\n unsigned int vp9_mse16x16_c ( const uint8_t * src , int src_stride , const uint8_t * ref , int ref_stride , unsigned int * sse ) {\n int sum ;\n variance ( src , src_stride , ref , ref_stride , 16 , 16 , sse , & sum ) ;\n return * sse ;\n }\n unsigned int vp9_mse16x8_c ( const uint8_t * src , int src_stride , const uint8_t * ref , int ref_stride , unsigned int * sse ) {\n int sum ;\n variance ( src , src_stride , ref , ref_stride , 16 , 8 , sse , & sum ) ;\n return * sse ;\n }\n unsigned int vp9_mse8x16_c ( const uint8_t * src , int src_stride , const uint8_t * ref , int ref_stride , unsigned int * sse ) {\n int sum ;\n variance ( src , src_stride , ref , ref_stride , 8 , 16 , sse , & sum ) ;\n return * sse ;\n }\n unsigned int vp9_mse8x8_c ( const uint8_t * src , int src_stride , const uint8_t * ref , int ref_stride , unsigned int * sse ) {\n int sum ;\n variance ( src , src_stride , ref , ref_stride , 8 , 8 , sse , & sum ) ;\n return * sse ;\n }\n VAR ( 4 , 4 ) SUBPIX_VAR ( 4 , 4 ) SUBPIX_AVG_VAR ( 4 , 4 ) VAR ( 4 , 8 ) SUBPIX_VAR ( 4 , 8 ) SUBPIX_AVG_VAR ( 4 , 8 ) VAR ( 8 , 4 ) SUBPIX_VAR ( 8 , 4 ) SUBPIX_AVG_VAR ( 8 , 4 ) VAR ( 8 , 8 ) SUBPIX_VAR ( 8 , 8 ) SUBPIX_AVG_VAR ( 8 , 8 ) VAR ( 8 , 16 ) SUBPIX_VAR ( 8 , 16 ) SUBPIX_AVG_VAR ( 8 , 16 ) VAR ( 16 , 8 ) SUBPIX_VAR ( 16 , 8 ) SUBPIX_AVG_VAR ( 16 , 8 ) VAR ( 16 , 16 ) SUBPIX_VAR ( 16 , 16 ) SUBPIX_AVG_VAR ( 16 , 16 ) VAR ( 16 , 32 ) SUBPIX_VAR ( 16 , 32 ) SUBPIX_AVG_VAR ( 16 , 32 ) VAR ( 32 , 16 ) SUBPIX_VAR ( 32 , 16 ) SUBPIX_AVG_VAR ( 32 , 16 ) VAR ( 32 , 32 ) SUBPIX_VAR ( 32 , 32 ) SUBPIX_AVG_VAR ( 32 , 32 ) VAR ( 32 , 64 ) SUBPIX_VAR ( 32 , 64 ) SUBPIX_AVG_VAR ( 32 , 64 ) VAR ( 64 , 32 ) SUBPIX_VAR ( 64 , 32 ) SUBPIX_AVG_VAR ( 64 , 32 )", "idx": 21750}
{"hash": -3559021711340554904, "project": "debian", "size": 8, "label": 0, "functionSource": "static bool contain_mutable_functions_walker ( Node * node , void * context ) {\n if ( node == NULL ) return false ;\n if ( check_functions_in_node ( node , contain_mutable_functions_checker , context ) ) return true ;\n if ( IsA ( node , Query ) ) {\n return query_tree_walker ( ( Query * ) node , contain_mutable_functions_walker , context , 0 ) ;\n }\n return expression_tree_walker ( node , contain_mutable_functions_walker , context ) ;\n }", "idx": 21751}
{"hash": 6393050609822897742, "project": "debian", "size": 68, "label": 0, "functionSource": "static void xhci_xfer_report ( XHCITransfer * xfer ) {\n uint32_t edtla = 0 ;\n unsigned int left ;\n bool reported = 0 ;\n bool shortpkt = 0 ;\n XHCIEvent event = {\n ER_TRANSFER , CC_SUCCESS }\n ;\n XHCIState * xhci = xfer -> epctx -> xhci ;\n int i ;\n left = xfer -> packet . actual_length ;\n for ( i = 0 ;\n i < xfer -> trb_count ;\n i ++ ) {\n XHCITRB * trb = & xfer -> trbs [ i ] ;\n unsigned int chunk = 0 ;\n switch ( TRB_TYPE ( * trb ) ) {\n case TR_SETUP : chunk = trb -> status & 0x1ffff ;\n if ( chunk > 8 ) {\n chunk = 8 ;\n }\n break ;\n case TR_DATA : case TR_NORMAL : case TR_ISOCH : chunk = trb -> status & 0x1ffff ;\n if ( chunk > left ) {\n chunk = left ;\n if ( xfer -> status == CC_SUCCESS ) {\n shortpkt = 1 ;\n }\n }\n left -= chunk ;\n edtla += chunk ;\n break ;\n case TR_STATUS : reported = 0 ;\n shortpkt = 0 ;\n break ;\n }\n if ( ! reported && ( ( trb -> control & TRB_TR_IOC ) || ( shortpkt && ( trb -> control & TRB_TR_ISP ) ) || ( xfer -> status != CC_SUCCESS && left == 0 ) ) ) {\n event . slotid = xfer -> epctx -> slotid ;\n event . epid = xfer -> epctx -> epid ;\n event . length = ( trb -> status & 0x1ffff ) - chunk ;\n event . flags = 0 ;\n event . ptr = trb -> addr ;\n if ( xfer -> status == CC_SUCCESS ) {\n event . ccode = shortpkt ? CC_SHORT_PACKET : CC_SUCCESS ;\n }\n else {\n event . ccode = xfer -> status ;\n }\n if ( TRB_TYPE ( * trb ) == TR_EVDATA ) {\n event . ptr = trb -> parameter ;\n event . flags |= TRB_EV_ED ;\n event . length = edtla & 0xffffff ;\n DPRINTF ( \"xhci_xfer_data: EDTLA=%d\\n\" , event . length ) ;\n edtla = 0 ;\n }\n xhci_event ( xhci , & event , TRB_INTR ( * trb ) ) ;\n reported = 1 ;\n if ( xfer -> status != CC_SUCCESS ) {\n return ;\n }\n }\n switch ( TRB_TYPE ( * trb ) ) {\n case TR_SETUP : reported = 0 ;\n shortpkt = 0 ;\n break ;\n }\n }\n }", "idx": 21752}
{"hash": -3062453801436404700, "project": "debian", "size": 7, "label": 1, "functionSource": "void dtls1_stop_timer ( SSL * s ) {\n memset ( & s -> d1 -> timeout , 0 , sizeof ( s -> d1 -> timeout ) ) ;\n memset ( & s -> d1 -> next_timeout , 0 , sizeof ( s -> d1 -> next_timeout ) ) ;\n s -> d1 -> timeout_duration = 1 ;\n BIO_ctrl ( SSL_get_rbio ( s ) , BIO_CTRL_DGRAM_SET_NEXT_TIMEOUT , 0 , & ( s -> d1 -> next_timeout ) ) ;\n dtls1_clear_record_buffer ( s ) ;\n }", "idx": 21753}
{"hash": -5268859819325807498, "project": "debian", "size": 23, "label": 0, "functionSource": "static void filesystem_info_start ( NautilusDirectory * directory , NautilusFile * file , gboolean * doing_io ) {\n GFile * location ;\n FilesystemInfoState * state ;\n if ( directory -> details -> filesystem_info_state != NULL ) {\n * doing_io = TRUE ;\n return ;\n }\n if ( ! is_needy ( file , lacks_filesystem_info , REQUEST_FILESYSTEM_INFO ) ) {\n return ;\n }\n * doing_io = TRUE ;\n if ( ! async_job_start ( directory , \"filesystem info\" ) ) {\n return ;\n }\n state = g_new0 ( FilesystemInfoState , 1 ) ;\n state -> directory = directory ;\n state -> file = file ;\n state -> cancellable = g_cancellable_new ( ) ;\n location = nautilus_file_get_location ( file ) ;\n directory -> details -> filesystem_info_state = state ;\n g_file_query_filesystem_info_async ( location , G_FILE_ATTRIBUTE_FILESYSTEM_READONLY \",\" G_FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW \",\" G_FILE_ATTRIBUTE_FILESYSTEM_TYPE , G_PRIORITY_DEFAULT , state -> cancellable , query_filesystem_info_callback , state ) ;\n g_object_unref ( location ) ;\n }", "idx": 21754}
{"hash": -7253276028511611170, "project": "debian", "size": 28, "label": 0, "functionSource": "static int rate_control ( AVCodecContext * avctx , void * arg ) {\n SliceArgs * slice_dat = arg ;\n VC2EncContext * s = slice_dat -> ctx ;\n const int top = slice_dat -> bits_ceil ;\n const int bottom = slice_dat -> bits_floor ;\n int quant_buf [ 2 ] = {\n - 1 , - 1 }\n ;\n int quant = slice_dat -> quant_idx , step = 1 ;\n int bits_last , bits = count_hq_slice ( slice_dat , quant ) ;\n while ( ( bits > top ) || ( bits < bottom ) ) {\n const int signed_step = bits > top ? + step : - step ;\n quant = av_clip ( quant + signed_step , 0 , s -> q_ceil - 1 ) ;\n bits = count_hq_slice ( slice_dat , quant ) ;\n if ( quant_buf [ 1 ] == quant ) {\n quant = FFMAX ( quant_buf [ 0 ] , quant ) ;\n bits = quant == quant_buf [ 0 ] ? bits_last : bits ;\n break ;\n }\n step = av_clip ( step / 2 , 1 , ( s -> q_ceil - 1 ) / 2 ) ;\n quant_buf [ 1 ] = quant_buf [ 0 ] ;\n quant_buf [ 0 ] = quant ;\n bits_last = bits ;\n }\n slice_dat -> quant_idx = av_clip ( quant , 0 , s -> q_ceil - 1 ) ;\n slice_dat -> bytes = SSIZE_ROUND ( bits >> 3 ) ;\n return 0 ;\n }", "idx": 21755}
{"hash": -3740862514502467070, "project": "debian", "size": 26, "label": 0, "functionSource": "static int tablefilematch ( struct taboff * tab , FILE * ttc , struct alltabs * all , int pos ) {\n int i , ch1 , ch2 ;\n struct taboff * test ;\n unsigned len ;\n for ( i = 0 ;\n i < pos ;\n ++ i ) {\n test = findtabindir ( & all [ i ] . tabdir , tab -> tag ) ;\n if ( test == NULL || test -> data == ( void * ) ( intpt ) - 1 || test -> length != tab -> length ) continue ;\n rewind ( tab -> data ) ;\n fseek ( ttc , test -> offset , SEEK_SET ) ;\n for ( len = 0 ;\n len < tab -> length && ( ch1 = getc ( tab -> data ) ) != EOF && ( ch2 = getc ( ttc ) ) != EOF ;\n ++ len ) {\n if ( ch1 != ch2 ) break ;\n }\n if ( len == tab -> length ) {\n rewind ( tab -> data ) ;\n fseek ( ttc , 0 , SEEK_END ) ;\n return ( i ) ;\n }\n }\n rewind ( tab -> data ) ;\n fseek ( ttc , 0 , SEEK_END ) ;\n return ( - 1 ) ;\n }", "idx": 21756}
{"hash": 4991783214228010911, "project": "debian", "size": 343, "label": 0, "functionSource": "int jbig2_text_region ( Jbig2Ctx * ctx , Jbig2Segment * segment , const byte * segment_data ) {\n uint32_t offset = 0 ;\n Jbig2RegionSegmentInfo region_info ;\n Jbig2TextRegionParams params ;\n Jbig2Image * image = NULL ;\n Jbig2SymbolDict * * dicts = NULL ;\n uint32_t n_dicts = 0 ;\n uint16_t flags = 0 ;\n uint16_t huffman_flags = 0 ;\n Jbig2ArithCx * GR_stats = NULL ;\n int code = 0 ;\n Jbig2WordStream * ws = NULL ;\n Jbig2ArithState * as = NULL ;\n uint32_t table_index = 0 ;\n const Jbig2HuffmanParams * huffman_params = NULL ;\n if ( segment -> data_length < 17 ) goto too_short ;\n jbig2_get_region_segment_info ( & region_info , segment_data ) ;\n offset += 17 ;\n flags = jbig2_get_uint16 ( segment_data + offset ) ;\n offset += 2 ;\n jbig2_error ( ctx , JBIG2_SEVERITY_DEBUG , segment -> number , \"text region header flags 0x%04x\" , flags ) ;\n memset ( & params , 0 , sizeof ( Jbig2TextRegionParams ) ) ;\n params . SBHUFF = flags & 0x0001 ;\n params . SBREFINE = flags & 0x0002 ;\n params . LOGSBSTRIPS = ( flags & 0x000c ) >> 2 ;\n params . SBSTRIPS = 1 << params . LOGSBSTRIPS ;\n params . REFCORNER = ( Jbig2RefCorner ) ( ( flags & 0x0030 ) >> 4 ) ;\n params . TRANSPOSED = flags & 0x0040 ;\n params . SBCOMBOP = ( Jbig2ComposeOp ) ( ( flags & 0x0180 ) >> 7 ) ;\n params . SBDEFPIXEL = flags & 0x0200 ;\n params . SBDSOFFSET = ( flags & 0x7C00 ) >> 10 ;\n if ( params . SBDSOFFSET > 0x0f ) params . SBDSOFFSET -= 0x20 ;\n params . SBRTEMPLATE = flags & 0x8000 ;\n if ( params . SBDSOFFSET ) {\n jbig2_error ( ctx , JBIG2_SEVERITY_DEBUG , segment -> number , \"text region has SBDSOFFSET %d\" , params . SBDSOFFSET ) ;\n }\n if ( params . SBHUFF ) {\n huffman_flags = jbig2_get_uint16 ( segment_data + offset ) ;\n offset += 2 ;\n if ( huffman_flags & 0x8000 ) jbig2_error ( ctx , JBIG2_SEVERITY_WARNING , segment -> number , \"reserved bit 15 of text region huffman flags is not zero\" ) ;\n }\n else {\n if ( ( params . SBREFINE ) && ! ( params . SBRTEMPLATE ) ) {\n params . sbrat [ 0 ] = segment_data [ offset ] ;\n params . sbrat [ 1 ] = segment_data [ offset + 1 ] ;\n params . sbrat [ 2 ] = segment_data [ offset + 2 ] ;\n params . sbrat [ 3 ] = segment_data [ offset + 3 ] ;\n offset += 4 ;\n }\n }\n params . SBNUMINSTANCES = jbig2_get_uint32 ( segment_data + offset ) ;\n offset += 4 ;\n if ( params . SBHUFF ) {\n switch ( huffman_flags & 0x0003 ) {\n case 0 : params . SBHUFFFS = jbig2_build_huffman_table ( ctx , & jbig2_huffman_params_F ) ;\n break ;\n case 1 : params . SBHUFFFS = jbig2_build_huffman_table ( ctx , & jbig2_huffman_params_G ) ;\n break ;\n case 3 : huffman_params = jbig2_find_table ( ctx , segment , table_index ) ;\n if ( huffman_params == NULL ) {\n code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"Custom FS huffman table not found (%d)\" , table_index ) ;\n goto cleanup1 ;\n }\n params . SBHUFFFS = jbig2_build_huffman_table ( ctx , huffman_params ) ;\n ++ table_index ;\n break ;\n case 2 : default : code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"text region specified invalid FS huffman table\" ) ;\n goto cleanup1 ;\n break ;\n }\n if ( params . SBHUFFFS == NULL ) {\n code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"failed to allocate text region specified FS huffman table\" ) ;\n goto cleanup1 ;\n }\n switch ( ( huffman_flags & 0x000c ) >> 2 ) {\n case 0 : params . SBHUFFDS = jbig2_build_huffman_table ( ctx , & jbig2_huffman_params_H ) ;\n break ;\n case 1 : params . SBHUFFDS = jbig2_build_huffman_table ( ctx , & jbig2_huffman_params_I ) ;\n break ;\n case 2 : params . SBHUFFDS = jbig2_build_huffman_table ( ctx , & jbig2_huffman_params_J ) ;\n break ;\n case 3 : huffman_params = jbig2_find_table ( ctx , segment , table_index ) ;\n if ( huffman_params == NULL ) {\n code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"Custom DS huffman table not found (%d)\" , table_index ) ;\n goto cleanup1 ;\n }\n params . SBHUFFDS = jbig2_build_huffman_table ( ctx , huffman_params ) ;\n ++ table_index ;\n break ;\n }\n if ( params . SBHUFFDS == NULL ) {\n code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"failed to allocate text region specified DS huffman table\" ) ;\n goto cleanup1 ;\n }\n switch ( ( huffman_flags & 0x0030 ) >> 4 ) {\n case 0 : params . SBHUFFDT = jbig2_build_huffman_table ( ctx , & jbig2_huffman_params_K ) ;\n break ;\n case 1 : params . SBHUFFDT = jbig2_build_huffman_table ( ctx , & jbig2_huffman_params_L ) ;\n break ;\n case 2 : params . SBHUFFDT = jbig2_build_huffman_table ( ctx , & jbig2_huffman_params_M ) ;\n break ;\n case 3 : huffman_params = jbig2_find_table ( ctx , segment , table_index ) ;\n if ( huffman_params == NULL ) {\n code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"Custom DT huffman table not found (%d)\" , table_index ) ;\n goto cleanup1 ;\n }\n params . SBHUFFDT = jbig2_build_huffman_table ( ctx , huffman_params ) ;\n ++ table_index ;\n break ;\n }\n if ( params . SBHUFFDT == NULL ) {\n code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"failed to allocate text region specified DT huffman table\" ) ;\n goto cleanup1 ;\n }\n switch ( ( huffman_flags & 0x00c0 ) >> 6 ) {\n case 0 : params . SBHUFFRDW = jbig2_build_huffman_table ( ctx , & jbig2_huffman_params_N ) ;\n break ;\n case 1 : params . SBHUFFRDW = jbig2_build_huffman_table ( ctx , & jbig2_huffman_params_O ) ;\n break ;\n case 3 : huffman_params = jbig2_find_table ( ctx , segment , table_index ) ;\n if ( huffman_params == NULL ) {\n code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"Custom RDW huffman table not found (%d)\" , table_index ) ;\n goto cleanup1 ;\n }\n params . SBHUFFRDW = jbig2_build_huffman_table ( ctx , huffman_params ) ;\n ++ table_index ;\n break ;\n case 2 : default : code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"text region specified invalid RDW huffman table\" ) ;\n goto cleanup1 ;\n break ;\n }\n if ( params . SBHUFFRDW == NULL ) {\n code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"failed to allocate text region specified RDW huffman table\" ) ;\n goto cleanup1 ;\n }\n switch ( ( huffman_flags & 0x0300 ) >> 8 ) {\n case 0 : params . SBHUFFRDH = jbig2_build_huffman_table ( ctx , & jbig2_huffman_params_N ) ;\n break ;\n case 1 : params . SBHUFFRDH = jbig2_build_huffman_table ( ctx , & jbig2_huffman_params_O ) ;\n break ;\n case 3 : huffman_params = jbig2_find_table ( ctx , segment , table_index ) ;\n if ( huffman_params == NULL ) {\n code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"Custom RDH huffman table not found (%d)\" , table_index ) ;\n goto cleanup1 ;\n }\n params . SBHUFFRDH = jbig2_build_huffman_table ( ctx , huffman_params ) ;\n ++ table_index ;\n break ;\n case 2 : default : code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"text region specified invalid RDH huffman table\" ) ;\n goto cleanup1 ;\n break ;\n }\n if ( params . SBHUFFRDH == NULL ) {\n code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"failed to allocate text region specified RDH huffman table\" ) ;\n goto cleanup1 ;\n }\n switch ( ( huffman_flags & 0x0c00 ) >> 10 ) {\n case 0 : params . SBHUFFRDX = jbig2_build_huffman_table ( ctx , & jbig2_huffman_params_N ) ;\n break ;\n case 1 : params . SBHUFFRDX = jbig2_build_huffman_table ( ctx , & jbig2_huffman_params_O ) ;\n break ;\n case 3 : huffman_params = jbig2_find_table ( ctx , segment , table_index ) ;\n if ( huffman_params == NULL ) {\n code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"Custom RDX huffman table not found (%d)\" , table_index ) ;\n goto cleanup1 ;\n }\n params . SBHUFFRDX = jbig2_build_huffman_table ( ctx , huffman_params ) ;\n ++ table_index ;\n break ;\n case 2 : default : code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"text region specified invalid RDX huffman table\" ) ;\n goto cleanup1 ;\n break ;\n }\n if ( params . SBHUFFRDX == NULL ) {\n code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"failed to allocate text region specified RDX huffman table\" ) ;\n goto cleanup1 ;\n }\n switch ( ( huffman_flags & 0x3000 ) >> 12 ) {\n case 0 : params . SBHUFFRDY = jbig2_build_huffman_table ( ctx , & jbig2_huffman_params_N ) ;\n break ;\n case 1 : params . SBHUFFRDY = jbig2_build_huffman_table ( ctx , & jbig2_huffman_params_O ) ;\n break ;\n case 3 : huffman_params = jbig2_find_table ( ctx , segment , table_index ) ;\n if ( huffman_params == NULL ) {\n code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"Custom RDY huffman table not found (%d)\" , table_index ) ;\n goto cleanup1 ;\n }\n params . SBHUFFRDY = jbig2_build_huffman_table ( ctx , huffman_params ) ;\n ++ table_index ;\n break ;\n case 2 : default : code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"text region specified invalid RDY huffman table\" ) ;\n goto cleanup1 ;\n break ;\n }\n if ( params . SBHUFFRDY == NULL ) {\n code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"failed to allocate text region specified RDY huffman table\" ) ;\n goto cleanup1 ;\n }\n switch ( ( huffman_flags & 0x4000 ) >> 14 ) {\n case 0 : params . SBHUFFRSIZE = jbig2_build_huffman_table ( ctx , & jbig2_huffman_params_A ) ;\n break ;\n case 1 : huffman_params = jbig2_find_table ( ctx , segment , table_index ) ;\n if ( huffman_params == NULL ) {\n code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"Custom RSIZE huffman table not found (%d)\" , table_index ) ;\n goto cleanup1 ;\n }\n params . SBHUFFRSIZE = jbig2_build_huffman_table ( ctx , huffman_params ) ;\n ++ table_index ;\n break ;\n }\n if ( params . SBHUFFRSIZE == NULL ) {\n code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"failed to allocate text region specified RSIZE huffman table\" ) ;\n goto cleanup1 ;\n }\n if ( huffman_flags & 0x8000 ) {\n jbig2_error ( ctx , JBIG2_SEVERITY_WARNING , segment -> number , \"text region huffman flags bit 15 is set, contrary to spec\" ) ;\n }\n }\n jbig2_error ( ctx , JBIG2_SEVERITY_INFO , segment -> number , \"text region: %d x %d @ (%d,%d) %d symbols\" , region_info . width , region_info . height , region_info . x , region_info . y , params . SBNUMINSTANCES ) ;\n n_dicts = jbig2_sd_count_referred ( ctx , segment ) ;\n if ( n_dicts != 0 ) {\n dicts = jbig2_sd_list_referred ( ctx , segment ) ;\n }\n else {\n code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"text region refers to no symbol dictionaries!\" ) ;\n goto cleanup1 ;\n }\n if ( dicts == NULL ) {\n code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"unable to retrive symbol dictionaries! previous parsing error?\" ) ;\n goto cleanup1 ;\n }\n else {\n uint32_t index ;\n if ( dicts [ 0 ] == NULL ) {\n code = jbig2_error ( ctx , JBIG2_SEVERITY_WARNING , segment -> number , \"unable to find first referenced symbol dictionary!\" ) ;\n goto cleanup1 ;\n }\n for ( index = 1 ;\n index < n_dicts ;\n index ++ ) if ( dicts [ index ] == NULL ) {\n jbig2_error ( ctx , JBIG2_SEVERITY_WARNING , segment -> number , \"unable to find all referenced symbol dictionaries!\" ) ;\n n_dicts = index ;\n }\n }\n {\n int stats_size = params . SBRTEMPLATE ? 1 << 10 : 1 << 13 ;\n GR_stats = jbig2_new ( ctx , Jbig2ArithCx , stats_size ) ;\n if ( GR_stats == NULL ) {\n code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"could not allocate GR_stats\" ) ;\n goto cleanup1 ;\n }\n memset ( GR_stats , 0 , stats_size ) ;\n }\n image = jbig2_image_new ( ctx , region_info . width , region_info . height ) ;\n if ( image == NULL ) {\n code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"couldn't allocate text region image\" ) ;\n goto cleanup2 ;\n }\n ws = jbig2_word_stream_buf_new ( ctx , segment_data + offset , segment -> data_length - offset ) ;\n if ( ws == NULL ) {\n code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"couldn't allocate ws in text region image\" ) ;\n goto cleanup2 ;\n }\n as = jbig2_arith_new ( ctx , ws ) ;\n if ( as == NULL ) {\n code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"couldn't allocate as in text region image\" ) ;\n goto cleanup2 ;\n }\n if ( ! params . SBHUFF ) {\n uint32_t SBSYMCODELEN , index ;\n uint32_t SBNUMSYMS = 0 ;\n for ( index = 0 ;\n index < n_dicts ;\n index ++ ) {\n SBNUMSYMS += dicts [ index ] -> n_symbols ;\n }\n params . IADT = jbig2_arith_int_ctx_new ( ctx ) ;\n params . IAFS = jbig2_arith_int_ctx_new ( ctx ) ;\n params . IADS = jbig2_arith_int_ctx_new ( ctx ) ;\n params . IAIT = jbig2_arith_int_ctx_new ( ctx ) ;\n if ( ( params . IADT == NULL ) || ( params . IAFS == NULL ) || ( params . IADS == NULL ) || ( params . IAIT == NULL ) ) {\n code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"couldn't allocate text region image data\" ) ;\n goto cleanup3 ;\n }\n for ( SBSYMCODELEN = 0 ;\n ( 1U << SBSYMCODELEN ) < SBNUMSYMS ;\n SBSYMCODELEN ++ ) {\n }\n params . IAID = jbig2_arith_iaid_ctx_new ( ctx , SBSYMCODELEN ) ;\n params . IARI = jbig2_arith_int_ctx_new ( ctx ) ;\n params . IARDW = jbig2_arith_int_ctx_new ( ctx ) ;\n params . IARDH = jbig2_arith_int_ctx_new ( ctx ) ;\n params . IARDX = jbig2_arith_int_ctx_new ( ctx ) ;\n params . IARDY = jbig2_arith_int_ctx_new ( ctx ) ;\n if ( ( params . IAID == NULL ) || ( params . IARI == NULL ) || ( params . IARDW == NULL ) || ( params . IARDH == NULL ) || ( params . IARDX == NULL ) || ( params . IARDY == NULL ) ) {\n code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"couldn't allocate text region image data\" ) ;\n goto cleanup4 ;\n }\n }\n code = jbig2_decode_text_region ( ctx , segment , & params , ( const Jbig2SymbolDict * const * ) dicts , n_dicts , image , segment_data + offset , segment -> data_length - offset , GR_stats , as , ws ) ;\n if ( code < 0 ) {\n jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"failed to decode text region image data\" ) ;\n goto cleanup4 ;\n }\n if ( ( segment -> flags & 63 ) == 4 ) {\n segment -> result = jbig2_image_clone ( ctx , image ) ;\n }\n else {\n jbig2_error ( ctx , JBIG2_SEVERITY_DEBUG , segment -> number , \"composing %dx%d decoded text region onto page at (%d, %d)\" , region_info . width , region_info . height , region_info . x , region_info . y ) ;\n jbig2_page_add_result ( ctx , & ctx -> pages [ ctx -> current_page ] , image , region_info . x , region_info . y , region_info . op ) ;\n }\n cleanup4 : if ( ! params . SBHUFF ) {\n jbig2_arith_iaid_ctx_free ( ctx , params . IAID ) ;\n jbig2_arith_int_ctx_free ( ctx , params . IARI ) ;\n jbig2_arith_int_ctx_free ( ctx , params . IARDW ) ;\n jbig2_arith_int_ctx_free ( ctx , params . IARDH ) ;\n jbig2_arith_int_ctx_free ( ctx , params . IARDX ) ;\n jbig2_arith_int_ctx_free ( ctx , params . IARDY ) ;\n }\n cleanup3 : if ( ! params . SBHUFF ) {\n jbig2_arith_int_ctx_free ( ctx , params . IADT ) ;\n jbig2_arith_int_ctx_free ( ctx , params . IAFS ) ;\n jbig2_arith_int_ctx_free ( ctx , params . IADS ) ;\n jbig2_arith_int_ctx_free ( ctx , params . IAIT ) ;\n }\n jbig2_free ( ctx -> allocator , as ) ;\n jbig2_word_stream_buf_free ( ctx , ws ) ;\n cleanup2 : jbig2_free ( ctx -> allocator , GR_stats ) ;\n jbig2_image_release ( ctx , image ) ;\n cleanup1 : if ( params . SBHUFF ) {\n jbig2_release_huffman_table ( ctx , params . SBHUFFFS ) ;\n jbig2_release_huffman_table ( ctx , params . SBHUFFDS ) ;\n jbig2_release_huffman_table ( ctx , params . SBHUFFDT ) ;\n jbig2_release_huffman_table ( ctx , params . SBHUFFRDX ) ;\n jbig2_release_huffman_table ( ctx , params . SBHUFFRDY ) ;\n jbig2_release_huffman_table ( ctx , params . SBHUFFRDW ) ;\n jbig2_release_huffman_table ( ctx , params . SBHUFFRDH ) ;\n jbig2_release_huffman_table ( ctx , params . SBHUFFRSIZE ) ;\n }\n jbig2_free ( ctx -> allocator , dicts ) ;\n return code ;\n too_short : return jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"Segment too short\" ) ;\n }", "idx": 21757}
{"hash": -7283224897680777091, "project": "chrome", "size": 113, "label": 0, "functionSource": "void vp9_filter_block_plane ( VP9_COMMON * const cm , struct macroblockd_plane * const plane , int mi_row , LOOP_FILTER_MASK * lfm ) {\n struct buf_2d * const dst = & plane -> dst ;\n uint8_t * const dst0 = dst -> buf ;\n int r , c ;\n if ( ! plane -> plane_type ) {\n uint64_t mask_16x16 = lfm -> left_y [ TX_16X16 ] ;\n uint64_t mask_8x8 = lfm -> left_y [ TX_8X8 ] ;\n uint64_t mask_4x4 = lfm -> left_y [ TX_4X4 ] ;\n uint64_t mask_4x4_int = lfm -> int_4x4_y ;\n for ( r = 0 ;\n r < MI_BLOCK_SIZE && mi_row + r < cm -> mi_rows ;\n r += 2 ) {\n unsigned int mask_16x16_l = mask_16x16 & 0xffff ;\n unsigned int mask_8x8_l = mask_8x8 & 0xffff ;\n unsigned int mask_4x4_l = mask_4x4 & 0xffff ;\n unsigned int mask_4x4_int_l = mask_4x4_int & 0xffff ;\n filter_selectively_vert_row2 ( plane -> plane_type , dst -> buf , dst -> stride , mask_16x16_l , mask_8x8_l , mask_4x4_l , mask_4x4_int_l , & cm -> lf_info , & lfm -> lfl_y [ r << 3 ] ) ;\n dst -> buf += 16 * dst -> stride ;\n mask_16x16 >>= 16 ;\n mask_8x8 >>= 16 ;\n mask_4x4 >>= 16 ;\n mask_4x4_int >>= 16 ;\n }\n dst -> buf = dst0 ;\n mask_16x16 = lfm -> above_y [ TX_16X16 ] ;\n mask_8x8 = lfm -> above_y [ TX_8X8 ] ;\n mask_4x4 = lfm -> above_y [ TX_4X4 ] ;\n mask_4x4_int = lfm -> int_4x4_y ;\n for ( r = 0 ;\n r < MI_BLOCK_SIZE && mi_row + r < cm -> mi_rows ;\n r ++ ) {\n unsigned int mask_16x16_r ;\n unsigned int mask_8x8_r ;\n unsigned int mask_4x4_r ;\n if ( mi_row + r == 0 ) {\n mask_16x16_r = 0 ;\n mask_8x8_r = 0 ;\n mask_4x4_r = 0 ;\n }\n else {\n mask_16x16_r = mask_16x16 & 0xff ;\n mask_8x8_r = mask_8x8 & 0xff ;\n mask_4x4_r = mask_4x4 & 0xff ;\n }\n filter_selectively_horiz ( dst -> buf , dst -> stride , mask_16x16_r , mask_8x8_r , mask_4x4_r , mask_4x4_int & 0xff , & cm -> lf_info , & lfm -> lfl_y [ r << 3 ] ) ;\n dst -> buf += 8 * dst -> stride ;\n mask_16x16 >>= 8 ;\n mask_8x8 >>= 8 ;\n mask_4x4 >>= 8 ;\n mask_4x4_int >>= 8 ;\n }\n }\n else {\n uint16_t mask_16x16 = lfm -> left_uv [ TX_16X16 ] ;\n uint16_t mask_8x8 = lfm -> left_uv [ TX_8X8 ] ;\n uint16_t mask_4x4 = lfm -> left_uv [ TX_4X4 ] ;\n uint16_t mask_4x4_int = lfm -> int_4x4_uv ;\n for ( r = 0 ;\n r < MI_BLOCK_SIZE && mi_row + r < cm -> mi_rows ;\n r += 4 ) {\n if ( plane -> plane_type == 1 ) {\n for ( c = 0 ;\n c < ( MI_BLOCK_SIZE >> 1 ) ;\n c ++ ) {\n lfm -> lfl_uv [ ( r << 1 ) + c ] = lfm -> lfl_y [ ( r << 3 ) + ( c << 1 ) ] ;\n lfm -> lfl_uv [ ( ( r + 2 ) << 1 ) + c ] = lfm -> lfl_y [ ( ( r + 2 ) << 3 ) + ( c << 1 ) ] ;\n }\n }\n {\n unsigned int mask_16x16_l = mask_16x16 & 0xff ;\n unsigned int mask_8x8_l = mask_8x8 & 0xff ;\n unsigned int mask_4x4_l = mask_4x4 & 0xff ;\n unsigned int mask_4x4_int_l = mask_4x4_int & 0xff ;\n filter_selectively_vert_row2 ( plane -> plane_type , dst -> buf , dst -> stride , mask_16x16_l , mask_8x8_l , mask_4x4_l , mask_4x4_int_l , & cm -> lf_info , & lfm -> lfl_uv [ r << 1 ] ) ;\n dst -> buf += 16 * dst -> stride ;\n mask_16x16 >>= 8 ;\n mask_8x8 >>= 8 ;\n mask_4x4 >>= 8 ;\n mask_4x4_int >>= 8 ;\n }\n }\n dst -> buf = dst0 ;\n mask_16x16 = lfm -> above_uv [ TX_16X16 ] ;\n mask_8x8 = lfm -> above_uv [ TX_8X8 ] ;\n mask_4x4 = lfm -> above_uv [ TX_4X4 ] ;\n mask_4x4_int = lfm -> int_4x4_uv ;\n for ( r = 0 ;\n r < MI_BLOCK_SIZE && mi_row + r < cm -> mi_rows ;\n r += 2 ) {\n const int skip_border_4x4_r = mi_row + r == cm -> mi_rows - 1 ;\n const unsigned int mask_4x4_int_r = skip_border_4x4_r ? : ( mask_4x4_int & 0xf ) ;\n unsigned int mask_16x16_r ;\n unsigned int mask_8x8_r ;\n unsigned int mask_4x4_r ;\n if ( mi_row + r == 0 ) {\n mask_16x16_r = 0 ;\n mask_8x8_r = 0 ;\n mask_4x4_r = 0 ;\n }\n else {\n mask_16x16_r = mask_16x16 & 0xf ;\n mask_8x8_r = mask_8x8 & 0xf ;\n mask_4x4_r = mask_4x4 & 0xf ;\n }\n filter_selectively_horiz ( dst -> buf , dst -> stride , mask_16x16_r , mask_8x8_r , mask_4x4_r , mask_4x4_int_r , & cm -> lf_info , & lfm -> lfl_uv [ r << 1 ] ) ;\n dst -> buf += 8 * dst -> stride ;\n mask_16x16 >>= 4 ;\n mask_8x8 >>= 4 ;\n mask_4x4 >>= 4 ;\n mask_4x4_int >>= 4 ;\n }\n }\n }", "idx": 21758}
{"hash": -2901388205723537271, "project": "debian", "size": 5, "label": 0, "functionSource": "VALUE rb_dlhandle_to_i ( VALUE self ) {\n struct dl_handle * dlhandle ;\n Data_Get_Struct ( self , struct dl_handle , dlhandle ) ;\n return PTR2NUM ( dlhandle ) ;\n }", "idx": 21759}
{"hash": -1315695702746584250, "project": "debian", "size": 6, "label": 0, "functionSource": "header_field_info * proto_get_first_protocol_field ( const int proto_id , void * * cookie ) {\n protocol_t * protocol = find_protocol_by_id ( proto_id ) ;\n if ( ( protocol == NULL ) || ( protocol -> fields -> len == 0 ) ) return NULL ;\n * cookie = GUINT_TO_POINTER ( 0 + 1 ) ;\n return ( header_field_info * ) g_ptr_array_index ( protocol -> fields , 0 ) ;\n }", "idx": 21760}
{"hash": -7283224897680777091, "project": "chrome", "size": 6, "label": 1, "functionSource": "int vp9_loop_filter_worker ( void * arg1 , void * arg2 ) {\n LFWorkerData * const lf_data = ( LFWorkerData * ) arg1 ;\n ( void ) arg2 ;\n vp9_loop_filter_rows ( lf_data -> frame_buffer , lf_data -> cm , lf_data -> planes , lf_data -> start , lf_data -> stop , lf_data -> y_only ) ;\n return 1 ;\n }", "idx": 21761}
{"hash": -8046645508582876963, "project": "debian", "size": 10, "label": 0, "functionSource": "static int eval_motion_dist ( RoqContext * enc , int x , int y , motion_vect vect , int size ) {\n int mx = vect . d [ 0 ] ;\n int my = vect . d [ 1 ] ;\n if ( mx < - 7 || mx > 7 ) return INT_MAX ;\n if ( my < - 7 || my > 7 ) return INT_MAX ;\n mx += x ;\n my += y ;\n if ( ( unsigned ) mx > enc -> width - size || ( unsigned ) my > enc -> height - size ) return INT_MAX ;\n return block_sse ( enc -> frame_to_enc -> data , enc -> last_frame -> data , x , y , mx , my , enc -> frame_to_enc -> linesize , enc -> last_frame -> linesize , size ) ;\n }", "idx": 21762}
{"hash": -454486177854888036, "project": "debian", "size": 21, "label": 0, "functionSource": "static void decode_dct_block ( RangeCoder * c , DCTBlockCoder * bc , uint8_t * dst , int stride , int block_size , int * block , int mb_x , int mb_y ) {\n int i , j ;\n int bx , by ;\n int nblocks = block_size >> 3 ;\n bx = mb_x * nblocks ;\n by = mb_y * nblocks ;\n for ( j = 0 ;\n j < nblocks ;\n j ++ ) {\n for ( i = 0 ;\n i < nblocks ;\n i ++ ) {\n if ( decode_dct ( c , bc , block , bx + i , by + j ) ) {\n c -> got_error = 1 ;\n return ;\n }\n ff_mss34_dct_put ( dst + i * 8 , stride , block ) ;\n }\n dst += 8 * stride ;\n }\n }", "idx": 21763}
{"hash": 7039307292471244756, "project": "debian", "size": 180, "label": 0, "functionSource": "static int dissect_dtap ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , void * data ) {\n static gsm_a_tap_rec_t tap_rec [ 4 ] ;\n static gsm_a_tap_rec_t * tap_p ;\n static guint tap_current = 0 ;\n void ( * dtap_msg_fcn ) ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo , guint32 offset , guint len ) ;\n guint8 oct ;\n guint8 pd ;\n guint32 offset ;\n guint32 len ;\n guint32 oct_1 ;\n gint idx ;\n proto_item * dtap_item = NULL ;\n proto_tree * dtap_tree = NULL ;\n proto_item * oct_1_item = NULL ;\n proto_tree * pd_tree = NULL ;\n const gchar * msg_str ;\n gint ett_tree ;\n gint ti ;\n int hf_idx ;\n gboolean nsd ;\n sccp_msg_info_t * sccp_msg = ( sccp_msg_info_t * ) data ;\n len = tvb_reported_length ( tvb ) ;\n if ( len < 2 ) {\n call_data_dissector ( tvb , pinfo , tree ) ;\n return len ;\n }\n col_append_str ( pinfo -> cinfo , COL_INFO , \"(DTAP) \" ) ;\n tap_current ++ ;\n if ( tap_current >= 4 ) {\n tap_current = 0 ;\n }\n tap_p = & tap_rec [ tap_current ] ;\n offset = 0 ;\n g_tree = tree ;\n oct_1 = tvb_get_guint8 ( tvb , offset ++ ) ;\n if ( ( ( ( oct_1 & DTAP_TI_MASK ) >> 4 ) & DTAP_TIE_PRES_MASK ) == DTAP_TIE_PRES_MASK ) {\n offset ++ ;\n }\n oct = tvb_get_guint8 ( tvb , offset ) ;\n pd = oct_1 & DTAP_PD_MASK ;\n ti = - 1 ;\n msg_str = NULL ;\n ett_tree = - 1 ;\n hf_idx = - 1 ;\n dtap_msg_fcn = NULL ;\n nsd = FALSE ;\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \"(%s) \" , val_to_str_const ( pd , gsm_a_pd_short_str_vals , \"unknown\" ) ) ;\n switch ( pd ) {\n case 0 : msg_str = try_val_to_str_idx ( ( guint32 ) ( oct & DTAP_GCC_IEI_MASK ) , gsm_a_dtap_msg_gcc_strings , & idx ) ;\n if ( msg_str != NULL ) {\n ett_tree = ett_gsm_dtap_msg_gcc [ idx ] ;\n dtap_msg_fcn = dtap_msg_gcc [ idx ] ;\n }\n hf_idx = hf_gsm_a_dtap_msg_gcc_type ;\n ti = ( oct_1 & DTAP_TI_MASK ) >> 4 ;\n nsd = TRUE ;\n break ;\n case 1 : msg_str = try_val_to_str_idx ( ( guint32 ) ( oct & DTAP_BCC_IEI_MASK ) , gsm_a_dtap_msg_bcc_strings , & idx ) ;\n if ( msg_str != NULL ) {\n ett_tree = ett_gsm_dtap_msg_bcc [ idx ] ;\n dtap_msg_fcn = dtap_msg_bcc [ idx ] ;\n }\n hf_idx = hf_gsm_a_dtap_msg_bcc_type ;\n ti = ( oct_1 & DTAP_TI_MASK ) >> 4 ;\n nsd = TRUE ;\n break ;\n case 3 : msg_str = try_val_to_str_idx ( ( guint32 ) ( oct & DTAP_CC_IEI_MASK ) , gsm_a_dtap_msg_cc_strings , & idx ) ;\n if ( msg_str != NULL ) {\n ett_tree = ett_gsm_dtap_msg_cc [ idx ] ;\n dtap_msg_fcn = dtap_msg_cc_fcn [ idx ] ;\n }\n hf_idx = hf_gsm_a_dtap_msg_cc_type ;\n ti = ( oct_1 & DTAP_TI_MASK ) >> 4 ;\n nsd = TRUE ;\n break ;\n case 5 : msg_str = try_val_to_str_idx ( ( guint32 ) ( oct & DTAP_MM_IEI_MASK ) , gsm_a_dtap_msg_mm_strings , & idx ) ;\n if ( msg_str != NULL ) {\n ett_tree = ett_gsm_dtap_msg_mm [ idx ] ;\n dtap_msg_fcn = dtap_msg_mm_fcn [ idx ] ;\n }\n hf_idx = hf_gsm_a_dtap_msg_mm_type ;\n nsd = TRUE ;\n break ;\n case 6 : get_rr_msg_params ( oct , & msg_str , & ett_tree , & hf_idx , & dtap_msg_fcn ) ;\n break ;\n case 8 : get_gmm_msg_params ( oct , & msg_str , & ett_tree , & hf_idx , & dtap_msg_fcn ) ;\n break ;\n case 9 : msg_str = try_val_to_str_idx ( ( guint32 ) ( oct & DTAP_SMS_IEI_MASK ) , gsm_a_dtap_msg_sms_strings , & idx ) ;\n hf_idx = hf_gsm_a_dtap_msg_sms_type ;\n if ( msg_str != NULL ) {\n ett_tree = ett_gsm_dtap_msg_sms [ idx ] ;\n dtap_msg_fcn = dtap_msg_sms_fcn [ idx ] ;\n }\n ti = ( oct_1 & DTAP_TI_MASK ) >> 4 ;\n break ;\n case 10 : get_sm_msg_params ( oct , & msg_str , & ett_tree , & hf_idx , & dtap_msg_fcn ) ;\n ti = ( oct_1 & DTAP_TI_MASK ) >> 4 ;\n break ;\n case 11 : msg_str = try_val_to_str_idx ( ( guint32 ) ( oct & DTAP_SS_IEI_MASK ) , gsm_a_dtap_msg_ss_strings , & idx ) ;\n hf_idx = hf_gsm_a_dtap_msg_ss_type ;\n if ( msg_str != NULL ) {\n ett_tree = ett_gsm_dtap_msg_ss [ idx ] ;\n dtap_msg_fcn = dtap_msg_ss_fcn [ idx ] ;\n }\n ti = ( oct_1 & DTAP_TI_MASK ) >> 4 ;\n nsd = TRUE ;\n break ;\n case 15 : msg_str = try_val_to_str_idx ( ( guint32 ) ( oct & DTAP_TP_IEI_MASK ) , gsm_a_dtap_msg_tp_strings , & idx ) ;\n hf_idx = hf_gsm_a_dtap_msg_tp_type ;\n if ( msg_str != NULL ) {\n ett_tree = ett_gsm_dtap_msg_tp [ idx ] ;\n dtap_msg_fcn = dtap_msg_tp_fcn [ idx ] ;\n }\n nsd = TRUE ;\n break ;\n default : return len ;\n }\n if ( sccp_msg && sccp_msg -> data . co . assoc ) {\n sccp_assoc = sccp_msg -> data . co . assoc ;\n }\n else {\n sccp_assoc = NULL ;\n sccp_msg = NULL ;\n }\n if ( msg_str == NULL ) {\n dtap_item = proto_tree_add_protocol_format ( tree , proto_a_dtap , tvb , 0 , len , \"GSM A-I/F DTAP - Unknown DTAP Message Type (0x%02x)\" , oct ) ;\n dtap_tree = proto_item_add_subtree ( dtap_item , ett_dtap_msg ) ;\n if ( sccp_msg && ! sccp_msg -> data . co . label ) {\n sccp_msg -> data . co . label = wmem_strdup_printf ( wmem_file_scope ( ) , \"DTAP (0x%02x)\" , oct ) ;\n }\n }\n else {\n dtap_item = proto_tree_add_protocol_format ( tree , proto_a_dtap , tvb , 0 , - 1 , \"GSM A-I/F DTAP - %s\" , msg_str ) ;\n dtap_tree = proto_item_add_subtree ( dtap_item , ett_tree ) ;\n if ( sccp_msg && ! sccp_msg -> data . co . label ) {\n sccp_msg -> data . co . label = wmem_strdup ( wmem_file_scope ( ) , msg_str ) ;\n }\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \"%s \" , msg_str ) ;\n col_set_fence ( pinfo -> cinfo , COL_INFO ) ;\n }\n oct_1_item = proto_tree_add_uint ( dtap_tree , hf_gsm_a_dtap_protocol_discriminator , tvb , 0 , 1 , pd ) ;\n pd_tree = proto_item_add_subtree ( oct_1_item , ett_dtap_oct_1 ) ;\n proto_tree_add_item ( pd_tree , hf_gsm_a_L3_protocol_discriminator , tvb , 0 , 1 , ENC_BIG_ENDIAN ) ;\n if ( ti == - 1 ) {\n proto_tree_add_item ( pd_tree , hf_gsm_a_skip_ind , tvb , 0 , 1 , ENC_BIG_ENDIAN ) ;\n }\n else {\n proto_tree_add_item ( pd_tree , hf_gsm_a_dtap_ti_flag , tvb , 0 , 1 , ENC_NA ) ;\n if ( ( ti & DTAP_TIE_PRES_MASK ) == DTAP_TIE_PRES_MASK ) {\n proto_tree_add_uint_format_value ( pd_tree , hf_gsm_a_dtap_tio , tvb , 0 , 1 , oct_1 , \"The TI value is given by the TIE in octet 2\" ) ;\n }\n else {\n proto_tree_add_item ( pd_tree , hf_gsm_a_dtap_tio , tvb , 0 , 1 , ENC_BIG_ENDIAN ) ;\n }\n }\n if ( ( ti != - 1 ) && ( ti & DTAP_TIE_PRES_MASK ) == DTAP_TIE_PRES_MASK ) {\n proto_tree_add_item ( tree , hf_gsm_a_extension , tvb , 1 , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( pd_tree , hf_gsm_a_dtap_tie , tvb , 1 , 1 , ENC_BIG_ENDIAN ) ;\n }\n if ( ( pinfo -> p2p_dir == P2P_DIR_RECV ) && nsd ) {\n }\n if ( ( pd == 5 ) || ( pd == 3 ) || ( pd == 10 ) || ( pd == 11 ) ) {\n proto_tree_add_item ( dtap_tree , hf_gsm_a_seq_no , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n }\n proto_tree_add_item ( dtap_tree , hf_idx , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n offset ++ ;\n tap_p -> pdu_type = GSM_A_PDU_TYPE_DTAP ;\n tap_p -> message_type = ( nsd ? ( oct & 0x3f ) : oct ) ;\n tap_p -> protocol_disc = ( gsm_a_pd_str_e ) pd ;\n tap_queue_packet ( gsm_a_tap , pinfo , tap_p ) ;\n if ( msg_str == NULL ) return len ;\n if ( offset >= len ) return len ;\n if ( dtap_msg_fcn == NULL ) {\n proto_tree_add_item ( dtap_tree , hf_gsm_a_dtap_message_elements , tvb , offset , len - offset , ENC_NA ) ;\n }\n else {\n ( * dtap_msg_fcn ) ( tvb , dtap_tree , pinfo , offset , len - offset ) ;\n }\n return len ;\n }", "idx": 21764}
{"hash": 1676654288894940649, "project": "debian", "size": 36, "label": 0, "functionSource": "void kadmin_purgekeys ( int argc , char * argv [ ] ) {\n kadm5_ret_t retval ;\n int keepkvno = - 1 ;\n char * pname = NULL , * canon = NULL ;\n krb5_principal princ ;\n if ( argc == 4 && strcmp ( argv [ 1 ] , \"-keepkvno\" ) == 0 ) {\n keepkvno = atoi ( argv [ 2 ] ) ;\n pname = argv [ 3 ] ;\n }\n if ( argc == 2 ) {\n pname = argv [ 1 ] ;\n }\n if ( pname == NULL ) {\n fprintf ( stderr , _ ( \"usage: purgekeys [-keepkvno oldest_kvno_to_keep] \" \"principal\\n\" ) ) ;\n return ;\n }\n retval = kadmin_parse_name ( pname , & princ ) ;\n if ( retval ) {\n com_err ( \"purgekeys\" , retval , _ ( \"while parsing principal\" ) ) ;\n return ;\n }\n retval = krb5_unparse_name ( context , princ , & canon ) ;\n if ( retval ) {\n com_err ( \"purgekeys\" , retval , _ ( \"while canonicalizing principal\" ) ) ;\n goto cleanup ;\n }\n retval = kadm5_purgekeys ( handle , princ , keepkvno ) ;\n if ( retval ) {\n com_err ( \"purgekeys\" , retval , _ ( \"while purging keys for principal \\\"%s\\\"\" ) , canon ) ;\n goto cleanup ;\n }\n printf ( _ ( \"Old keys for principal \\\"%s\\\" purged.\\n\" ) , canon ) ;\n cleanup : krb5_free_principal ( context , princ ) ;\n free ( canon ) ;\n return ;\n }", "idx": 21765}
{"hash": -7014146700012452141, "project": "debian", "size": 5, "label": 0, "functionSource": "static void cdxl_decode_rgb ( CDXLVideoContext * c , AVFrame * frame ) {\n uint32_t * new_palette = ( uint32_t * ) frame -> data [ 1 ] ;\n import_palette ( c , new_palette ) ;\n import_format ( c , frame -> linesize [ 0 ] , frame -> data [ 0 ] ) ;\n }", "idx": 21766}
{"hash": -7777331401175181229, "project": "debian", "size": 3, "label": 0, "functionSource": "static void cmd_server_modify ( const char * data ) {\n cmd_server_add_modify ( data , FALSE ) ;\n }", "idx": 21767}
{"hash": 4489017523191997023, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h225_H323_UserInformation ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_H323_UserInformation , H323_UserInformation_sequence ) ;\n return offset ;\n }", "idx": 21768}
{"hash": -4555950263653671147, "project": "debian", "size": 13, "label": 0, "functionSource": "static PyObject * string_center ( PyStringObject * self , PyObject * args ) {\n Py_ssize_t marg , left ;\n Py_ssize_t width ;\n char fillchar = ' ' ;\n if ( ! PyArg_ParseTuple ( args , \"n|c:center\" , & width , & fillchar ) ) return NULL ;\n if ( PyString_GET_SIZE ( self ) >= width && PyString_CheckExact ( self ) ) {\n Py_INCREF ( self ) ;\n return ( PyObject * ) self ;\n }\n marg = width - PyString_GET_SIZE ( self ) ;\n left = marg / 2 + ( marg & width & 1 ) ;\n return pad ( self , left , marg - left , fillchar ) ;\n }", "idx": 21769}
{"hash": 6458694302493204858, "project": "debian", "size": 48, "label": 0, "functionSource": "static Datum ExecEvalNullTest ( NullTestState * nstate , ExprContext * econtext , bool * isNull , ExprDoneCond * isDone ) {\n NullTest * ntest = ( NullTest * ) nstate -> xprstate . expr ;\n Datum result ;\n result = ExecEvalExpr ( nstate -> arg , econtext , isNull , isDone ) ;\n if ( isDone && * isDone == ExprEndResult ) return result ;\n if ( ntest -> argisrow && ! ( * isNull ) ) {\n HeapTupleHeader tuple ;\n Oid tupType ;\n int32 tupTypmod ;\n TupleDesc tupDesc ;\n HeapTupleData tmptup ;\n int att ;\n tuple = DatumGetHeapTupleHeader ( result ) ;\n tupType = HeapTupleHeaderGetTypeId ( tuple ) ;\n tupTypmod = HeapTupleHeaderGetTypMod ( tuple ) ;\n tupDesc = get_cached_rowtype ( tupType , tupTypmod , & nstate -> argdesc , econtext ) ;\n tmptup . t_len = HeapTupleHeaderGetDatumLength ( tuple ) ;\n tmptup . t_data = tuple ;\n for ( att = 1 ;\n att <= tupDesc -> natts ;\n att ++ ) {\n if ( tupDesc -> attrs [ att - 1 ] -> attisdropped ) continue ;\n if ( heap_attisnull ( & tmptup , att ) ) {\n if ( ntest -> nulltesttype == IS_NOT_NULL ) return BoolGetDatum ( false ) ;\n }\n else {\n if ( ntest -> nulltesttype == IS_NULL ) return BoolGetDatum ( false ) ;\n }\n }\n return BoolGetDatum ( true ) ;\n }\n else {\n switch ( ntest -> nulltesttype ) {\n case IS_NULL : if ( * isNull ) {\n * isNull = false ;\n return BoolGetDatum ( true ) ;\n }\n else return BoolGetDatum ( false ) ;\n case IS_NOT_NULL : if ( * isNull ) {\n * isNull = false ;\n return BoolGetDatum ( false ) ;\n }\n else return BoolGetDatum ( true ) ;\n default : elog ( ERROR , \"unrecognized nulltesttype: %d\" , ( int ) ntest -> nulltesttype ) ;\n return ( Datum ) 0 ;\n }\n }\n }", "idx": 21770}
{"hash": 4600167735237264207, "project": "chrome", "size": 77, "label": 0, "functionSource": "static uint8_t checkBaseExtUnicode ( UCMStates * baseStates , UCMTable * base , UCMTable * ext , UBool moveToExt , UBool intersectBase ) {\n ( void ) baseStates ;\n UCMapping * mb , * me , * mbLimit , * meLimit ;\n int32_t cmp ;\n uint8_t result ;\n mb = base -> mappings ;\n mbLimit = mb + base -> mappingsLength ;\n me = ext -> mappings ;\n meLimit = me + ext -> mappingsLength ;\n result = 0 ;\n for ( ;\n ;\n ) {\n for ( ;\n ;\n ) {\n if ( mb == mbLimit ) {\n return result ;\n }\n if ( ( 0 <= mb -> f && mb -> f <= 2 ) || mb -> f == 4 ) {\n break ;\n }\n ++ mb ;\n }\n for ( ;\n ;\n ) {\n if ( me == meLimit ) {\n return result ;\n }\n if ( ( 0 <= me -> f && me -> f <= 2 ) || me -> f == 4 ) {\n break ;\n }\n ++ me ;\n }\n cmp = compareUnicode ( base , mb , ext , me ) ;\n if ( cmp < 0 ) {\n if ( intersectBase && ( intersectBase != 2 || mb -> bLen > 1 ) ) {\n mb -> moveFlag |= UCM_MOVE_TO_EXT ;\n result |= NEEDS_MOVE ;\n }\n else if ( mb -> uLen < me -> uLen && 0 == uprv_memcmp ( UCM_GET_CODE_POINTS ( base , mb ) , UCM_GET_CODE_POINTS ( ext , me ) , 4 * mb -> uLen ) ) {\n if ( moveToExt ) {\n mb -> moveFlag |= UCM_MOVE_TO_EXT ;\n result |= NEEDS_MOVE ;\n }\n else {\n fprintf ( stderr , \"ucm error: the base table contains a mapping whose input sequence\\n\" \" is a prefix of the input sequence of an extension mapping\\n\" ) ;\n ucm_printMapping ( base , mb , stderr ) ;\n ucm_printMapping ( ext , me , stderr ) ;\n result |= HAS_ERRORS ;\n }\n }\n ++ mb ;\n }\n else if ( cmp == 0 ) {\n if ( mb -> f == me -> f && mb -> bLen == me -> bLen && 0 == uprv_memcmp ( UCM_GET_BYTES ( base , mb ) , UCM_GET_BYTES ( ext , me ) , mb -> bLen ) ) {\n me -> moveFlag |= UCM_REMOVE_MAPPING ;\n result |= NEEDS_MOVE ;\n }\n else if ( intersectBase ) {\n mb -> moveFlag |= UCM_MOVE_TO_EXT ;\n result |= NEEDS_MOVE ;\n }\n else {\n fprintf ( stderr , \"ucm error: the base table contains a mapping whose input sequence\\n\" \" is the same as the input sequence of an extension mapping\\n\" \" but it maps differently\\n\" ) ;\n ucm_printMapping ( base , mb , stderr ) ;\n ucm_printMapping ( ext , me , stderr ) ;\n result |= HAS_ERRORS ;\n }\n ++ mb ;\n }\n else {\n ++ me ;\n }\n }\n }", "idx": 21771}
{"hash": -1315695702746584250, "project": "debian", "size": 27, "label": 0, "functionSource": "static void proto_tree_set_representation_value ( proto_item * pi , const char * format , va_list ap ) {\n g_assert ( pi ) ;\n if ( PTREE_DATA ( pi ) -> visible && ! PROTO_ITEM_IS_HIDDEN ( pi ) ) {\n int ret = 0 ;\n field_info * fi = PITEM_FINFO ( pi ) ;\n header_field_info * hf ;\n DISSECTOR_ASSERT ( fi ) ;\n hf = fi -> hfinfo ;\n ITEM_LABEL_NEW ( PNODE_POOL ( pi ) , fi -> rep ) ;\n if ( hf -> bitmask && ( hf -> type == FT_BOOLEAN || IS_FT_UINT ( hf -> type ) ) ) {\n guint64 val ;\n char * p ;\n if ( IS_FT_UINT ( hf -> type ) ) val = fvalue_get_uinteger ( & fi -> value ) ;\n else val = fvalue_get_uinteger64 ( & fi -> value ) ;\n val <<= hfinfo_bitshift ( hf ) ;\n p = decode_bitfield_value ( fi -> rep -> representation , val , hf -> bitmask , hfinfo_container_bitwidth ( hf ) ) ;\n ret = ( int ) ( p - fi -> rep -> representation ) ;\n }\n ret += g_snprintf ( fi -> rep -> representation + ret , ITEM_LABEL_LENGTH - ret , \"%s: \" , hf -> name ) ;\n if ( ret < ITEM_LABEL_LENGTH ) {\n ret += g_vsnprintf ( fi -> rep -> representation + ret , ITEM_LABEL_LENGTH - ret , format , ap ) ;\n }\n if ( ret >= ITEM_LABEL_LENGTH ) {\n LABEL_MARK_TRUNCATED_START ( fi -> rep -> representation ) ;\n }\n }\n }", "idx": 21772}
{"hash": 1223258652239369123, "project": "debian", "size": 12, "label": 0, "functionSource": "SPL_METHOD ( SplFileInfo , func_name ) \\ {\n \\ spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n \\ zend_error_handling error_handling ;\n \\ if ( zend_parse_parameters_none ( ) == FAILURE ) {\n \\ return ;\n \\ }\n \\ \\ zend_replace_error_handling ( EH_THROW , spl_ce_RuntimeException , & error_handling TSRMLS_CC ) ;\n \\ spl_filesystem_object_get_file_name ( intern TSRMLS_CC ) ;\n \\ php_stat ( intern -> file_name , intern -> file_name_len , func_num , return_value TSRMLS_CC ) ;\n \\ zend_restore_error_handling ( & error_handling TSRMLS_CC ) ;\n \\ }\n FileInfoFunction ( getPerms , FS_PERMS ) FileInfoFunction ( getInode , FS_INODE ) FileInfoFunction ( getSize , FS_SIZE ) FileInfoFunction ( getOwner , FS_OWNER ) FileInfoFunction ( getGroup , FS_GROUP ) FileInfoFunction ( getATime , FS_ATIME ) FileInfoFunction ( getMTime , FS_MTIME ) FileInfoFunction ( getCTime , FS_CTIME ) FileInfoFunction ( getType , FS_TYPE ) FileInfoFunction ( isWritable , FS_IS_W ) FileInfoFunction ( isReadable , FS_IS_R ) FileInfoFunction ( isExecutable , FS_IS_X ) FileInfoFunction ( isFile , FS_IS_FILE )", "idx": 21773}
{"hash": 3919646340804521652, "project": "debian", "size": 5, "label": 0, "functionSource": "static void show_object ( struct object * obj , const char * name , void * data ) {\n add_preferred_base_object ( name ) ;\n add_object_entry ( obj -> oid . hash , obj -> type , name , 0 ) ;\n obj -> flags |= OBJECT_ADDED ;\n }", "idx": 21774}
{"hash": 7651945086108393719, "project": "debian", "size": 34, "label": 0, "functionSource": "static void qemuMonitorJSONHandleVNC ( qemuMonitorPtr mon , virJSONValuePtr data , int phase ) {\n const char * localNode , * localService , * localFamily ;\n const char * remoteNode , * remoteService , * remoteFamily ;\n const char * authScheme , * saslUsername , * x509dname ;\n int localFamilyID , remoteFamilyID ;\n virJSONValuePtr client ;\n virJSONValuePtr server ;\n if ( ! ( client = virJSONValueObjectGet ( data , \"client\" ) ) ) {\n VIR_WARN ( \"missing client info in VNC event\" ) ;\n return ;\n }\n if ( ! ( server = virJSONValueObjectGet ( data , \"server\" ) ) ) {\n VIR_WARN ( \"missing server info in VNC event\" ) ;\n return ;\n }\n authScheme = virJSONValueObjectGetString ( server , \"auth\" ) ;\n localFamily = virJSONValueObjectGetString ( server , \"family\" ) ;\n localNode = virJSONValueObjectGetString ( server , \"host\" ) ;\n localService = virJSONValueObjectGetString ( server , \"service\" ) ;\n remoteFamily = virJSONValueObjectGetString ( client , \"family\" ) ;\n remoteNode = virJSONValueObjectGetString ( client , \"host\" ) ;\n remoteService = virJSONValueObjectGetString ( client , \"service\" ) ;\n saslUsername = virJSONValueObjectGetString ( client , \"sasl_username\" ) ;\n x509dname = virJSONValueObjectGetString ( client , \"x509_dname\" ) ;\n if ( ( localFamilyID = qemuMonitorGraphicsAddressFamilyTypeFromString ( localFamily ) ) < 0 ) {\n VIR_WARN ( \"unknown address family '%s'\" , localFamily ) ;\n localFamilyID = VIR_DOMAIN_EVENT_GRAPHICS_ADDRESS_IPV4 ;\n }\n if ( ( remoteFamilyID = qemuMonitorGraphicsAddressFamilyTypeFromString ( remoteFamily ) ) < 0 ) {\n VIR_WARN ( \"unknown address family '%s'\" , remoteFamily ) ;\n remoteFamilyID = VIR_DOMAIN_EVENT_GRAPHICS_ADDRESS_IPV4 ;\n }\n qemuMonitorEmitGraphics ( mon , phase , localFamilyID , localNode , localService , remoteFamilyID , remoteNode , remoteService , authScheme , x509dname , saslUsername ) ;\n }", "idx": 21775}
{"hash": -7049333455584635197, "project": "chrome", "size": 8, "label": 1, "functionSource": "static void _UTF16Reset ( UConverter * cnv , UConverterResetChoice choice ) {\n if ( choice <= UCNV_RESET_TO_UNICODE ) {\n cnv -> mode = 0 ;\n }\n if ( choice != UCNV_RESET_TO_UNICODE ) {\n cnv -> fromUnicodeStatus = UCNV_NEED_TO_WRITE_BOM ;\n }\n }", "idx": 21776}
{"hash": 2687336064028423153, "project": "chrome", "size": 15, "label": 0, "functionSource": "const char * evdns_err_to_string ( int err ) {\n switch ( err ) {\n case DNS_ERR_NONE : return \"no error\" ;\n case DNS_ERR_FORMAT : return \"misformatted query\" ;\n case DNS_ERR_SERVERFAILED : return \"server failed\" ;\n case DNS_ERR_NOTEXIST : return \"name does not exist\" ;\n case DNS_ERR_NOTIMPL : return \"query not implemented\" ;\n case DNS_ERR_REFUSED : return \"refused\" ;\n case DNS_ERR_TRUNCATED : return \"reply truncated or ill-formed\" ;\n case DNS_ERR_UNKNOWN : return \"unknown\" ;\n case DNS_ERR_TIMEOUT : return \"request timed out\" ;\n case DNS_ERR_SHUTDOWN : return \"dns subsystem shut down\" ;\n default : return \"[Unknown error code]\" ;\n }\n }", "idx": 21777}
{"hash": -2607754285145856562, "project": "debian", "size": 71, "label": 0, "functionSource": "static void isoent_setup_file_location ( struct iso9660 * iso9660 , int location ) {\n struct isoent * isoent ;\n struct isoent * np ;\n struct isofile * file ;\n size_t size ;\n int block ;\n int depth ;\n int joliet ;\n int symlocation ;\n int total_block ;\n iso9660 -> total_file_block = 0 ;\n if ( ( isoent = iso9660 -> el_torito . catalog ) != NULL ) {\n isoent -> file -> content . location = location ;\n block = ( int ) ( ( archive_entry_size ( isoent -> file -> entry ) + LOGICAL_BLOCK_SIZE - 1 ) >> LOGICAL_BLOCK_BITS ) ;\n location += block ;\n iso9660 -> total_file_block += block ;\n }\n if ( ( isoent = iso9660 -> el_torito . boot ) != NULL ) {\n isoent -> file -> content . location = location ;\n size = fd_boot_image_size ( iso9660 -> el_torito . media_type ) ;\n if ( size == 0 ) size = ( size_t ) archive_entry_size ( isoent -> file -> entry ) ;\n block = ( ( int ) size + LOGICAL_BLOCK_SIZE - 1 ) >> LOGICAL_BLOCK_BITS ;\n location += block ;\n iso9660 -> total_file_block += block ;\n isoent -> file -> content . blocks = block ;\n }\n depth = 0 ;\n symlocation = - 16 ;\n if ( ! iso9660 -> opt . rr && iso9660 -> opt . joliet ) {\n joliet = 1 ;\n np = iso9660 -> joliet . rootent ;\n }\n else {\n joliet = 0 ;\n np = iso9660 -> primary . rootent ;\n }\n do {\n _isoent_file_location ( iso9660 , np , & symlocation ) ;\n if ( np -> subdirs . first != NULL && ( joliet || ( ( iso9660 -> opt . rr == OPT_RR_DISABLED && depth + 2 < iso9660 -> primary . max_depth ) || ( iso9660 -> opt . rr && depth + 1 < iso9660 -> primary . max_depth ) ) ) ) {\n np = np -> subdirs . first ;\n depth ++ ;\n continue ;\n }\n while ( np != np -> parent ) {\n if ( np -> drnext == NULL ) {\n np = np -> parent ;\n depth -- ;\n }\n else {\n np = np -> drnext ;\n break ;\n }\n }\n }\n while ( np != np -> parent ) ;\n total_block = 0 ;\n for ( file = iso9660 -> data_file_list . first ;\n file != NULL ;\n file = file -> datanext ) {\n if ( ! file -> write_content ) continue ;\n file -> cur_content = & ( file -> content ) ;\n do {\n file -> cur_content -> location = location ;\n location += file -> cur_content -> blocks ;\n total_block += file -> cur_content -> blocks ;\n file -> cur_content = file -> cur_content -> next ;\n }\n while ( file -> cur_content != NULL ) ;\n }\n iso9660 -> total_file_block += total_block ;\n }", "idx": 21778}
{"hash": -1321749842392027937, "project": "chrome", "size": 24, "label": 0, "functionSource": "static void check_reset_2nd_coeffs ( MACROBLOCKD * x , int type , ENTROPY_CONTEXT * a , ENTROPY_CONTEXT * l ) {\n int sum = 0 ;\n int i ;\n BLOCKD * bd = & x -> block [ 24 ] ;\n if ( bd -> dequant [ 0 ] >= 35 && bd -> dequant [ 1 ] >= 35 ) return ;\n for ( i = 0 ;\n i < ( * bd -> eob ) ;\n i ++ ) {\n int coef = bd -> dqcoeff [ vp8_default_zig_zag1d [ i ] ] ;\n sum += ( coef >= 0 ) ? coef : - coef ;\n if ( sum >= 35 ) return ;\n }\n if ( sum < 35 ) {\n for ( i = 0 ;\n i < ( * bd -> eob ) ;\n i ++ ) {\n int rc = vp8_default_zig_zag1d [ i ] ;\n bd -> qcoeff [ rc ] = 0 ;\n bd -> dqcoeff [ rc ] = 0 ;\n }\n * bd -> eob = 0 ;\n * a = * l = ( * bd -> eob != ! type ) ;\n }\n }", "idx": 21779}
{"hash": -3889154245145551951, "project": "debian", "size": 10, "label": 0, "functionSource": "static void load_branch ( struct branch * b ) {\n load_tree ( & b -> branch_tree ) ;\n if ( ! b -> active ) {\n b -> active = 1 ;\n b -> active_next_branch = active_branches ;\n active_branches = b ;\n cur_active_branches ++ ;\n branch_load_count ++ ;\n }\n }", "idx": 21780}
{"hash": -789251383577298283, "project": "debian", "size": 28, "label": 0, "functionSource": "static int doapr_outch ( char * * sbuffer , char * * buffer , size_t * currlen , size_t * maxlen , int c ) {\n assert ( * sbuffer != NULL || buffer != NULL ) ;\n assert ( * currlen <= * maxlen ) ;\n if ( buffer && * currlen == * maxlen ) {\n if ( * maxlen > INT_MAX - BUFFER_INC ) return 0 ;\n * maxlen += BUFFER_INC ;\n if ( * buffer == NULL ) {\n * buffer = OPENSSL_malloc ( * maxlen ) ;\n if ( * buffer == NULL ) return 0 ;\n if ( * currlen > 0 ) {\n assert ( * sbuffer != NULL ) ;\n memcpy ( * buffer , * sbuffer , * currlen ) ;\n }\n * sbuffer = NULL ;\n }\n else {\n char * tmpbuf ;\n tmpbuf = OPENSSL_realloc ( * buffer , * maxlen ) ;\n if ( tmpbuf == NULL ) return 0 ;\n * buffer = tmpbuf ;\n }\n }\n if ( * currlen < * maxlen ) {\n if ( * sbuffer ) ( * sbuffer ) [ ( * currlen ) ++ ] = ( char ) c ;\n else ( * buffer ) [ ( * currlen ) ++ ] = ( char ) c ;\n }\n return 1 ;\n }", "idx": 21781}
{"hash": 8947170728280515149, "project": "debian", "size": 10, "label": 0, "functionSource": "int EvaluatePS ( char * str , real * stack , int size ) {\n EntityChar ec ;\n RetStack rs ;\n memset ( & ec , '\\0' , sizeof ( ec ) ) ;\n memset ( & rs , '\\0' , sizeof ( rs ) ) ;\n rs . max = size ;\n rs . stack = stack ;\n InterpretPS ( NULL , str , & ec , & rs ) ;\n return ( rs . cnt ) ;\n }", "idx": 21782}
{"hash": -4960438251319819237, "project": "chrome", "size": 4, "label": 0, "functionSource": "static void get_arf_buffer_indices ( unsigned char * arf_buffer_indices ) {\n arf_buffer_indices [ 0 ] = ARF_SLOT1 ;\n arf_buffer_indices [ 1 ] = ARF_SLOT2 ;\n }", "idx": 21783}
{"hash": 2447070537606626244, "project": "debian", "size": 7, "label": 1, "functionSource": "extern int name ( int ) __THROW __exctype ( isalnum ) ;\n __exctype ( isalpha ) ;\n __exctype ( iscntrl ) ;\n __exctype ( isdigit ) ;\n __exctype ( islower ) ;\n __exctype ( isgraph ) ;\n __exctype ( isprint )", "idx": 21784}
{"hash": -7334302271653594926, "project": "debian", "size": 11, "label": 0, "functionSource": "double double_from_string_with_check ( CHARSET_INFO * cs , const char * cptr , const char * end ) {\n int error ;\n char * end_of_num = ( char * ) end ;\n double tmp ;\n tmp = my_strntod ( cs , ( char * ) cptr , end - cptr , & end_of_num , & error ) ;\n if ( error || ( end != end_of_num && ! check_if_only_end_space ( cs , end_of_num , end ) ) ) {\n ErrConvString err ( cptr , end - cptr , cs ) ;\n push_warning_printf ( current_thd , MYSQL_ERROR : : WARN_LEVEL_WARN , ER_TRUNCATED_WRONG_VALUE , ER ( ER_TRUNCATED_WRONG_VALUE ) , \"DOUBLE\" , err . ptr ( ) ) ;\n }\n return tmp ;\n }", "idx": 21785}
{"hash": -3384986069176965684, "project": "chrome", "size": 3, "label": 0, "functionSource": "static void disable_segmentation ( VP8_COMP * cpi ) {\n cpi -> mb . e_mbd . segmentation_enabled = 0 ;\n }", "idx": 21786}
{"hash": -992498691684812004, "project": "chrome", "size": 9, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( PrefsFunctionalTest , TestJavascriptEnableDisable ) {\n ASSERT_TRUE ( embedded_test_server ( ) -> Start ( ) ) ;\n EXPECT_TRUE ( browser ( ) -> profile ( ) -> GetPrefs ( ) -> GetBoolean ( prefs : : kWebKitJavascriptEnabled ) ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , embedded_test_server ( ) -> GetURL ( \"/javaScriptTitle.html\" ) ) ;\n EXPECT_EQ ( base : : ASCIIToUTF16 ( \"Title from script javascript enabled\" ) , browser ( ) -> tab_strip_model ( ) -> GetActiveWebContents ( ) -> GetTitle ( ) ) ;\n browser ( ) -> profile ( ) -> GetPrefs ( ) -> SetBoolean ( prefs : : kWebKitJavascriptEnabled , false ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , embedded_test_server ( ) -> GetURL ( \"/javaScriptTitle.html\" ) ) ;\n EXPECT_EQ ( base : : ASCIIToUTF16 ( \"This is html title\" ) , browser ( ) -> tab_strip_model ( ) -> GetActiveWebContents ( ) -> GetTitle ( ) ) ;\n }", "idx": 21787}
{"hash": -714975729066076397, "project": "chrome", "size": 7, "label": 0, "functionSource": "hb_blob_t * hb_blob_create_sub_blob ( hb_blob_t * parent , unsigned int offset , unsigned int length ) {\n hb_blob_t * blob ;\n if ( ! length || offset >= parent -> length ) return hb_blob_get_empty ( ) ;\n hb_blob_make_immutable ( parent ) ;\n blob = hb_blob_create ( parent -> data + offset , MIN ( length , parent -> length - offset ) , HB_MEMORY_MODE_READONLY , hb_blob_reference ( parent ) , ( hb_destroy_func_t ) hb_blob_destroy ) ;\n return blob ;\n }", "idx": 21788}
{"hash": 4180964683905830761, "project": "debian", "size": 8, "label": 0, "functionSource": "static int msg_msg_alloc_security ( struct msg_msg * msg ) {\n struct msg_security_struct * msec ;\n msec = kzalloc ( sizeof ( struct msg_security_struct ) , GFP_KERNEL ) ;\n if ( ! msec ) return - ENOMEM ;\n msec -> sid = SECINITSID_UNLABELED ;\n msg -> security = msec ;\n return 0 ;\n }", "idx": 21789}
{"hash": -8301849797259977267, "project": "debian", "size": 24, "label": 0, "functionSource": "static void pnm_get ( PNMContext * sc , char * str , int buf_size ) {\n char * s ;\n int c ;\n for ( ;\n ;\n ) {\n c = * sc -> bytestream ++ ;\n if ( c == '#' ) {\n do {\n c = * sc -> bytestream ++ ;\n }\n while ( c != '\\n' && sc -> bytestream < sc -> bytestream_end ) ;\n }\n else if ( ! pnm_space ( c ) ) {\n break ;\n }\n }\n s = str ;\n while ( sc -> bytestream < sc -> bytestream_end && ! pnm_space ( c ) ) {\n if ( ( s - str ) < buf_size - 1 ) * s ++ = c ;\n c = * sc -> bytestream ++ ;\n }\n * s = '\\0' ;\n }", "idx": 21790}
{"hash": -5025430721469043309, "project": "debian", "size": 100, "label": 1, "functionSource": "static void process_envvars ( enum mode * modep ) {\n char * * runp = _environ ;\n char * envline ;\n enum mode mode = normal ;\n char * debug_output = NULL ;\n GLRO ( dl_profile_output ) = & \"/var/tmp\\0/var/profile\" [ __libc_enable_secure ? 9 : 0 ] ;\n while ( ( envline = _dl_next_ld_env_entry ( & runp ) ) != NULL ) {\n size_t len = 0 ;\n while ( envline [ len ] != '\\0' && envline [ len ] != '=' ) ++ len ;\n if ( envline [ len ] != '=' ) continue ;\n switch ( len ) {\n case 4 : if ( memcmp ( envline , \"WARN\" , 4 ) == 0 ) GLRO ( dl_verbose ) = envline [ 5 ] != '\\0' ;\n break ;\n case 5 : if ( memcmp ( envline , \"DEBUG\" , 5 ) == 0 ) {\n process_dl_debug ( & envline [ 6 ] ) ;\n break ;\n }\n if ( memcmp ( envline , \"AUDIT\" , 5 ) == 0 ) process_dl_audit ( & envline [ 6 ] ) ;\n break ;\n case 7 : if ( memcmp ( envline , \"VERBOSE\" , 7 ) == 0 ) {\n version_info = envline [ 8 ] != '\\0' ;\n break ;\n }\n if ( memcmp ( envline , \"PRELOAD\" , 7 ) == 0 ) {\n preloadlist = & envline [ 8 ] ;\n break ;\n }\n if ( memcmp ( envline , \"PROFILE\" , 7 ) == 0 && envline [ 8 ] != '\\0' ) GLRO ( dl_profile ) = & envline [ 8 ] ;\n break ;\n case 8 : if ( memcmp ( envline , \"BIND_NOW\" , 8 ) == 0 ) {\n GLRO ( dl_lazy ) = envline [ 9 ] == '\\0' ;\n break ;\n }\n if ( memcmp ( envline , \"BIND_NOT\" , 8 ) == 0 ) GLRO ( dl_bind_not ) = envline [ 9 ] != '\\0' ;\n break ;\n case 9 : if ( ! __libc_enable_secure && memcmp ( envline , \"SHOW_AUXV\" , 9 ) == 0 ) _dl_show_auxv ( ) ;\n break ;\n case 10 : if ( memcmp ( envline , \"HWCAP_MASK\" , 10 ) == 0 ) GLRO ( dl_hwcap_mask ) = __strtoul_internal ( & envline [ 11 ] , NULL , 0 , 0 ) ;\n break ;\n case 11 : if ( ! __libc_enable_secure && memcmp ( envline , \"ORIGIN_PATH\" , 11 ) == 0 ) GLRO ( dl_origin_path ) = & envline [ 12 ] ;\n break ;\n case 12 : if ( memcmp ( envline , \"LIBRARY_PATH\" , 12 ) == 0 ) {\n library_path = & envline [ 13 ] ;\n break ;\n }\n if ( memcmp ( envline , \"DEBUG_OUTPUT\" , 12 ) == 0 ) {\n debug_output = & envline [ 13 ] ;\n break ;\n }\n if ( ! __libc_enable_secure && memcmp ( envline , \"DYNAMIC_WEAK\" , 12 ) == 0 ) GLRO ( dl_dynamic_weak ) = 1 ;\n break ;\n case 13 : # ifdef EXTRA_LD_ENVVARS_13 EXTRA_LD_ENVVARS_13 # endif if ( ! __libc_enable_secure && memcmp ( envline , \"USE_LOAD_BIAS\" , 13 ) == 0 ) {\n GLRO ( dl_use_load_bias ) = envline [ 14 ] == '1' ? - 1 : 0 ;\n break ;\n }\n if ( memcmp ( envline , \"POINTER_GUARD\" , 13 ) == 0 ) GLRO ( dl_pointer_guard ) = envline [ 14 ] != '0' ;\n break ;\n case 14 : if ( ! __libc_enable_secure && memcmp ( envline , \"PROFILE_OUTPUT\" , 14 ) == 0 && envline [ 15 ] != '\\0' ) GLRO ( dl_profile_output ) = & envline [ 15 ] ;\n break ;\n case 16 : if ( memcmp ( envline , \"TRACE_PRELINKING\" , 16 ) == 0 ) {\n mode = trace ;\n GLRO ( dl_verbose ) = 1 ;\n GLRO ( dl_debug_mask ) |= DL_DEBUG_PRELINK ;\n GLRO ( dl_trace_prelink ) = & envline [ 17 ] ;\n }\n break ;\n case 20 : if ( memcmp ( envline , \"TRACE_LOADED_OBJECTS\" , 20 ) == 0 ) mode = trace ;\n break ;\n # ifdef EXTRA_LD_ENVVARS EXTRA_LD_ENVVARS # endif }\n }\n * modep = mode ;\n if ( __builtin_expect ( __libc_enable_secure , 0 ) ) {\n static const char unsecure_envvars [ ] = # ifdef EXTRA_UNSECURE_ENVVARS EXTRA_UNSECURE_ENVVARS # endif UNSECURE_ENVVARS ;\n const char * nextp ;\n nextp = unsecure_envvars ;\n do {\n unsetenv ( nextp ) ;\n nextp = ( char * ) ( strchr ) ( nextp , '\\0' ) + 1 ;\n }\n while ( * nextp != '\\0' ) ;\n if ( __access ( \"/etc/suid-debug\" , F_OK ) != 0 ) {\n unsetenv ( \"MALLOC_CHECK_\" ) ;\n GLRO ( dl_debug_mask ) = 0 ;\n }\n if ( mode != normal ) _exit ( 5 ) ;\n }\n else if ( any_debug && debug_output != NULL ) {\n # ifdef O_NOFOLLOW const int flags = O_WRONLY | O_APPEND | O_CREAT | O_NOFOLLOW ;\n # else const int flags = O_WRONLY | O_APPEND | O_CREAT ;\n # endif size_t name_len = strlen ( debug_output ) ;\n char buf [ name_len + 12 ] ;\n char * startp ;\n buf [ name_len + 11 ] = '\\0' ;\n startp = _itoa ( __getpid ( ) , & buf [ name_len + 11 ] , 10 , 0 ) ;\n * -- startp = '.' ;\n startp = memcpy ( startp - name_len , debug_output , name_len ) ;\n GLRO ( dl_debug_fd ) = __open ( startp , flags , DEFFILEMODE ) ;\n if ( GLRO ( dl_debug_fd ) == - 1 ) GLRO ( dl_debug_fd ) = STDOUT_FILENO ;\n }\n }", "idx": 21791}
{"hash": 4180964683905830761, "project": "debian", "size": 8, "label": 0, "functionSource": "static int selinux_tun_dev_alloc_security ( void * * security ) {\n struct tun_security_struct * tunsec ;\n tunsec = kzalloc ( sizeof ( * tunsec ) , GFP_KERNEL ) ;\n if ( ! tunsec ) return - ENOMEM ;\n tunsec -> sid = current_sid ( ) ;\n * security = tunsec ;\n return 0 ;\n }", "idx": 21792}
{"hash": 2546373479020365143, "project": "debian", "size": 13, "label": 0, "functionSource": "void mime_hdr_field_block_list_adjust ( int , MIMEFieldBlockImpl * old_list , MIMEFieldBlockImpl * new_list ) {\n for ( MIMEFieldBlockImpl * new_blk = new_list ;\n new_blk ;\n new_blk = new_blk -> m_next ) {\n for ( MIMEField * field = new_blk -> m_field_slots , * end = field + new_blk -> m_freetop ;\n field != end ;\n ++ field ) {\n if ( field -> is_live ( ) && field -> m_next_dup ) {\n relocate ( field , new_list , old_list ) ;\n }\n }\n }\n }", "idx": 21793}
{"hash": 2713698759296604855, "project": "debian", "size": 5, "label": 0, "functionSource": "static inline int pic_is_unused ( MpegEncContext * s , Picture * pic ) {\n if ( pic -> f . data [ 0 ] == NULL ) return 1 ;\n if ( pic -> needs_realloc && ! ( pic -> reference & DELAYED_PIC_REF ) ) return 1 ;\n return 0 ;\n }", "idx": 21794}
{"hash": -8958254313220732728, "project": "debian", "size": 9, "label": 0, "functionSource": "static int virtio_net_init_pci ( PCIDevice * pci_dev ) {\n VirtIOPCIProxy * proxy = DO_UPCAST ( VirtIOPCIProxy , pci_dev , pci_dev ) ;\n VirtIODevice * vdev ;\n vdev = virtio_net_init ( & pci_dev -> qdev , & proxy -> nic ) ;\n vdev -> nvectors = proxy -> nvectors ;\n virtio_init_pci ( proxy , vdev , PCI_VENDOR_ID_REDHAT_QUMRANET , PCI_DEVICE_ID_VIRTIO_NET , PCI_CLASS_NETWORK_ETHERNET , 0x00 ) ;\n proxy -> nvectors = vdev -> nvectors ;\n return 0 ;\n }", "idx": 21795}
{"hash": 4489017523191997023, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h225_T_algorithmOIDs ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence_of ( tvb , offset , actx , tree , hf_index , ett_h225_T_algorithmOIDs , T_algorithmOIDs_sequence_of ) ;\n return offset ;\n }", "idx": 21796}
{"hash": 2100112064176019294, "project": "chrome", "size": 24, "label": 0, "functionSource": "xsltDocumentPtr xsltLoadStyleDocument ( xsltStylesheetPtr style , const xmlChar * URI ) {\n xsltDocumentPtr ret ;\n xmlDocPtr doc ;\n xsltSecurityPrefsPtr sec ;\n if ( ( style == NULL ) || ( URI == NULL ) ) return ( NULL ) ;\n sec = xsltGetDefaultSecurityPrefs ( ) ;\n if ( sec != NULL ) {\n int res ;\n res = xsltCheckRead ( sec , NULL , URI ) ;\n if ( res == 0 ) {\n xsltTransformError ( NULL , NULL , NULL , \"xsltLoadStyleDocument: read rights for %s denied\\n\" , URI ) ;\n return ( NULL ) ;\n }\n }\n ret = style -> docList ;\n while ( ret != NULL ) {\n if ( ( ret -> doc != NULL ) && ( ret -> doc -> URL != NULL ) && ( xmlStrEqual ( ret -> doc -> URL , URI ) ) ) return ( ret ) ;\n ret = ret -> next ;\n }\n doc = xsltDocDefaultLoader ( URI , style -> dict , XSLT_PARSE_OPTIONS , ( void * ) style , XSLT_LOAD_STYLESHEET ) ;\n if ( doc == NULL ) return ( NULL ) ;\n ret = xsltNewStyleDocument ( style , doc ) ;\n return ( ret ) ;\n }", "idx": 21797}
{"hash": 6980637897759012306, "project": "chrome", "size": 23, "label": 0, "functionSource": "int evsignal_init ( struct event_base * base ) {\n int i ;\n if ( evutil_socketpair ( AF_UNIX , SOCK_STREAM , 0 , base -> sig . ev_signal_pair ) == - 1 ) {\n # ifdef WIN32 event_warn ( \"%s: socketpair\" , __func__ ) ;\n # else event_err ( 1 , \"%s: socketpair\" , __func__ ) ;\n # endif return - 1 ;\n }\n FD_CLOSEONEXEC ( base -> sig . ev_signal_pair [ 0 ] ) ;\n FD_CLOSEONEXEC ( base -> sig . ev_signal_pair [ 1 ] ) ;\n base -> sig . sh_old = NULL ;\n base -> sig . sh_old_max = 0 ;\n base -> sig . evsignal_caught = 0 ;\n memset ( & base -> sig . evsigcaught , 0 , sizeof ( sig_atomic_t ) * NSIG ) ;\n for ( i = 0 ;\n i < NSIG ;\n ++ i ) TAILQ_INIT ( & base -> sig . evsigevents [ i ] ) ;\n evutil_make_socket_nonblocking ( base -> sig . ev_signal_pair [ 0 ] ) ;\n evutil_make_socket_nonblocking ( base -> sig . ev_signal_pair [ 1 ] ) ;\n event_set ( & base -> sig . ev_signal , base -> sig . ev_signal_pair [ 1 ] , EV_READ | EV_PERSIST , evsignal_cb , & base -> sig . ev_signal ) ;\n base -> sig . ev_signal . ev_base = base ;\n base -> sig . ev_signal . ev_flags |= EVLIST_INTERNAL ;\n return 0 ;\n }", "idx": 21798}
{"hash": 4180964683905830761, "project": "debian", "size": 51, "label": 0, "functionSource": "static int selinux_sb_remount ( struct super_block * sb , void * data ) {\n int rc , i , * flags ;\n struct security_mnt_opts opts ;\n char * secdata , * * mount_options ;\n struct superblock_security_struct * sbsec = sb -> s_security ;\n if ( ! ( sbsec -> flags & SE_SBINITIALIZED ) ) return 0 ;\n if ( ! data ) return 0 ;\n if ( sb -> s_type -> fs_flags & FS_BINARY_MOUNTDATA ) return 0 ;\n security_init_mnt_opts ( & opts ) ;\n secdata = alloc_secdata ( ) ;\n if ( ! secdata ) return - ENOMEM ;\n rc = selinux_sb_copy_data ( data , secdata ) ;\n if ( rc ) goto out_free_secdata ;\n rc = selinux_parse_opts_str ( secdata , & opts ) ;\n if ( rc ) goto out_free_secdata ;\n mount_options = opts . mnt_opts ;\n flags = opts . mnt_opts_flags ;\n for ( i = 0 ;\n i < opts . num_mnt_opts ;\n i ++ ) {\n u32 sid ;\n if ( flags [ i ] == SBLABEL_MNT ) continue ;\n rc = security_context_str_to_sid ( mount_options [ i ] , & sid , GFP_KERNEL ) ;\n if ( rc ) {\n printk ( KERN_WARNING \"SELinux: security_context_str_to_sid\" \"(%s) failed for (dev %s, type %s) errno=%d\\n\" , mount_options [ i ] , sb -> s_id , sb -> s_type -> name , rc ) ;\n goto out_free_opts ;\n }\n rc = - EINVAL ;\n switch ( flags [ i ] ) {\n case FSCONTEXT_MNT : if ( bad_option ( sbsec , FSCONTEXT_MNT , sbsec -> sid , sid ) ) goto out_bad_option ;\n break ;\n case CONTEXT_MNT : if ( bad_option ( sbsec , CONTEXT_MNT , sbsec -> mntpoint_sid , sid ) ) goto out_bad_option ;\n break ;\n case ROOTCONTEXT_MNT : {\n struct inode_security_struct * root_isec ;\n root_isec = backing_inode_security ( sb -> s_root ) ;\n if ( bad_option ( sbsec , ROOTCONTEXT_MNT , root_isec -> sid , sid ) ) goto out_bad_option ;\n break ;\n }\n case DEFCONTEXT_MNT : if ( bad_option ( sbsec , DEFCONTEXT_MNT , sbsec -> def_sid , sid ) ) goto out_bad_option ;\n break ;\n default : goto out_free_opts ;\n }\n }\n rc = 0 ;\n out_free_opts : security_free_mnt_opts ( & opts ) ;\n out_free_secdata : free_secdata ( secdata ) ;\n return rc ;\n out_bad_option : printk ( KERN_WARNING \"SELinux: unable to change security options \" \"during remount (dev %s, type=%s)\\n\" , sb -> s_id , sb -> s_type -> name ) ;\n goto out_free_opts ;\n }", "idx": 21799}
{"hash": -6435087038712482873, "project": "debian", "size": 3, "label": 0, "functionSource": "void ff_mpeg12_common_init ( MpegEncContext * s ) {\n s -> y_dc_scale_table = s -> c_dc_scale_table = ff_mpeg2_dc_scale_table [ s -> intra_dc_precision ] ;\n }", "idx": 21800}
{"hash": -2423144171479606949, "project": "debian", "size": 6, "label": 0, "functionSource": "static void pdf_run_TD ( fz_context * ctx , pdf_processor * proc , float tx , float ty ) {\n pdf_run_processor * pr = ( pdf_run_processor * ) proc ;\n pdf_gstate * gstate = pr -> gstate + pr -> gtop ;\n gstate -> text . leading = - ty ;\n pdf_tos_translate ( & pr -> tos , tx , ty ) ;\n }", "idx": 21801}
{"hash": -2648356651055439484, "project": "debian", "size": 27, "label": 0, "functionSource": "static void gsm_a_stat_init ( new_stat_tap_ui * new_stat , new_stat_tap_gui_init_cb gui_callback , void * gui_data , const char * table_title , const value_string * msg_strings ) {\n int num_fields = sizeof ( gsm_a_stat_fields ) / sizeof ( stat_tap_table_item ) ;\n new_stat_tap_table * table ;\n guint i ;\n stat_tap_table_item_type items [ sizeof ( gsm_a_stat_fields ) / sizeof ( stat_tap_table_item ) ] ;\n items [ IEI_COLUMN ] . type = TABLE_ITEM_UINT ;\n items [ MSG_NAME_COLUMN ] . type = TABLE_ITEM_STRING ;\n items [ COUNT_COLUMN ] . type = TABLE_ITEM_UINT ;\n items [ COUNT_COLUMN ] . value . uint_value = 0 ;\n table = new_stat_tap_init_table ( table_title , num_fields , 0 , NULL , gui_callback , gui_data ) ;\n new_stat_tap_add_table ( new_stat , table ) ;\n for ( i = 0 ;\n i < 256 ;\n i ++ ) {\n const char * msg_str = try_val_to_str ( i , msg_strings ) ;\n char * col_str ;\n if ( msg_str ) {\n col_str = g_strdup ( msg_str ) ;\n }\n else {\n col_str = g_strdup_printf ( \"Unknown message %d\" , i ) ;\n }\n items [ IEI_COLUMN ] . value . uint_value = i ;\n items [ MSG_NAME_COLUMN ] . value . string_value = col_str ;\n new_stat_tap_init_table_row ( table , i , num_fields , items ) ;\n }\n }", "idx": 21802}
{"hash": -5912543978015782596, "project": "debian", "size": 26, "label": 0, "functionSource": "static int adb_send ( socket_handle_t sock , const char * adb_service ) {\n char buffer [ 4 ] ;\n gssize used_buffer_length ;\n gssize result ;\n size_t adb_service_length ;\n adb_service_length = strlen ( adb_service ) ;\n result = send ( sock , adb_service , ( int ) adb_service_length , 0 ) ;\n if ( result != ( gssize ) adb_service_length ) {\n errmsg_print ( \"ERROR: Error while sending <%s> to ADB\" , adb_service ) ;\n return EXIT_CODE_ERROR_WHILE_SENDING_ADB_PACKET_1 ;\n }\n used_buffer_length = 0 ;\n while ( used_buffer_length < 4 ) {\n result = recv ( sock , buffer + used_buffer_length , ( int ) ( sizeof ( buffer ) - used_buffer_length ) , 0 ) ;\n if ( result <= 0 ) {\n errmsg_print ( \"ERROR: Broken socket connection while fetching reply status for <%s>\" , adb_service ) ;\n return EXIT_CODE_ERROR_WHILE_RECEIVING_ADB_PACKET_STATUS ;\n }\n used_buffer_length += result ;\n }\n if ( memcmp ( buffer , \"OKAY\" , 4 ) ) {\n errmsg_print ( \"ERROR: Error while receiving by ADB for <%s>\" , adb_service ) ;\n return EXIT_CODE_ERROR_WHILE_RECEIVING_ADB_PACKET_DATA ;\n }\n return EXIT_CODE_SUCCESS ;\n }", "idx": 21803}
{"hash": 2895622461494525400, "project": "debian", "size": 43, "label": 0, "functionSource": "static void test_view_2where ( ) {\n MYSQL_STMT * stmt ;\n int rc , i ;\n MYSQL_BIND my_bind [ 8 ] ;\n char parms [ 8 ] [ 100 ] ;\n ulong length [ 8 ] ;\n const char * query = \"select relid, report, handle, log_group, username, variant, type, \" \"version, erfdat, erftime, erfname, aedat, aetime, aename, dependvars, \" \"inactive from V_LTDX where mandt = ? and relid = ? and report = ? and \" \"handle = ? and log_group = ? and username in ( ? , ? ) and type = ?\" ;\n myheader ( \"test_view_2where\" ) ;\n rc = mysql_query ( mysql , \"DROP TABLE IF EXISTS LTDX\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"DROP VIEW IF EXISTS V_LTDX\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"CREATE TABLE LTDX (MANDT char(3) NOT NULL default '000', \" \" RELID char(2) NOT NULL, REPORT varchar(40) NOT NULL,\" \" HANDLE varchar(4) NOT NULL, LOG_GROUP varchar(4) NOT NULL,\" \" USERNAME varchar(12) NOT NULL,\" \" VARIANT varchar(12) NOT NULL,\" \" TYPE char(1) NOT NULL, SRTF2 int(11) NOT NULL,\" \" VERSION varchar(6) NOT NULL default '000000',\" \" ERFDAT varchar(8) NOT NULL default '00000000',\" \" ERFTIME varchar(6) NOT NULL default '000000',\" \" ERFNAME varchar(12) NOT NULL,\" \" AEDAT varchar(8) NOT NULL default '00000000',\" \" AETIME varchar(6) NOT NULL default '000000',\" \" AENAME varchar(12) NOT NULL,\" \" DEPENDVARS varchar(10) NOT NULL,\" \" INACTIVE char(1) NOT NULL, CLUSTR smallint(6) NOT NULL,\" \" CLUSTD blob,\" \" PRIMARY KEY (MANDT, RELID, REPORT, HANDLE, LOG_GROUP, \" \"USERNAME, VARIANT, TYPE, SRTF2))\" \" CHARSET=latin1 COLLATE latin1_bin\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"CREATE VIEW V_LTDX AS select T0001.MANDT AS \" \" MANDT,T0001.RELID AS RELID,T0001.REPORT AS \" \" REPORT,T0001.HANDLE AS HANDLE,T0001.LOG_GROUP AS \" \" LOG_GROUP,T0001.USERNAME AS USERNAME,T0001.VARIANT AS \" \" VARIANT,T0001.TYPE AS TYPE,T0001.VERSION AS \" \" VERSION,T0001.ERFDAT AS ERFDAT,T0001.ERFTIME AS \" \" ERFTIME,T0001.ERFNAME AS ERFNAME,T0001.AEDAT AS \" \" AEDAT,T0001.AETIME AS AETIME,T0001.AENAME AS \" \" AENAME,T0001.DEPENDVARS AS DEPENDVARS,T0001.INACTIVE AS \" \" INACTIVE from LTDX T0001 where (T0001.SRTF2 = 0)\" ) ;\n myquery ( rc ) ;\n memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n for ( i = 0 ;\n i < 8 ;\n i ++ ) {\n strmov ( parms [ i ] , \"1\" ) ;\n my_bind [ i ] . buffer_type = MYSQL_TYPE_VAR_STRING ;\n my_bind [ i ] . buffer = ( char * ) & parms [ i ] ;\n my_bind [ i ] . buffer_length = 100 ;\n my_bind [ i ] . is_null = 0 ;\n my_bind [ i ] . length = & length [ i ] ;\n length [ i ] = 1 ;\n }\n stmt = mysql_stmt_init ( mysql ) ;\n rc = mysql_stmt_prepare ( stmt , query , strlen ( query ) ) ;\n check_execute ( stmt , rc ) ;\n rc = mysql_stmt_bind_param ( stmt , my_bind ) ;\n check_execute ( stmt , rc ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n rc = my_process_stmt_result ( stmt ) ;\n DIE_UNLESS ( 0 == rc ) ;\n mysql_stmt_close ( stmt ) ;\n rc = mysql_query ( mysql , \"DROP VIEW V_LTDX\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"DROP TABLE LTDX\" ) ;\n myquery ( rc ) ;\n }", "idx": 21804}
{"hash": -4719501675862910941, "project": "debian", "size": 30, "label": 1, "functionSource": "static void h245_setup_channels ( packet_info * pinfo , channel_info_t * upcoming_channel_lcl ) {\n gint * key ;\n GHashTable * rtp_dyn_payload = NULL ;\n struct srtp_info * dummy_srtp_info = NULL ;\n if ( ! upcoming_channel_lcl ) return ;\n if ( ! strcmp ( upcoming_channel_lcl -> data_type_str , \"t38fax\" ) ) {\n if ( upcoming_channel_lcl -> media_addr . addr . type != AT_NONE && upcoming_channel_lcl -> media_addr . port != 0 ) {\n t38_add_address ( pinfo , & upcoming_channel_lcl -> media_addr . addr , upcoming_channel_lcl -> media_addr . port , 0 , \"H245\" , pinfo -> fd -> num ) ;\n }\n return ;\n }\n if ( upcoming_channel_lcl -> rfc2198 > 0 ) {\n encoding_name_and_rate_t * encoding_name_and_rate = wmem_new ( wmem_file_scope ( ) , encoding_name_and_rate_t ) ;\n rtp_dyn_payload = g_hash_table_new ( g_int_hash , g_int_equal ) ;\n encoding_name_and_rate -> encoding_name = wmem_strdup ( wmem_file_scope ( ) , \"red\" ) ;\n encoding_name_and_rate -> sample_rate = 8000 ;\n key = wmem_new ( wmem_file_scope ( ) , gint ) ;\n * key = upcoming_channel_lcl -> rfc2198 ;\n g_hash_table_insert ( rtp_dyn_payload , key , encoding_name_and_rate ) ;\n }\n if ( upcoming_channel_lcl -> srtp_flag ) {\n dummy_srtp_info = wmem_new0 ( wmem_file_scope ( ) , struct srtp_info ) ;\n }\n if ( upcoming_channel_lcl -> media_addr . addr . type != AT_NONE && upcoming_channel_lcl -> media_addr . port != 0 ) {\n srtp_add_address ( pinfo , & upcoming_channel_lcl -> media_addr . addr , upcoming_channel_lcl -> media_addr . port , 0 , \"H245\" , pinfo -> fd -> num , upcoming_channel_lcl -> is_video , rtp_dyn_payload , dummy_srtp_info ) ;\n }\n if ( upcoming_channel_lcl -> media_control_addr . addr . type != AT_NONE && upcoming_channel_lcl -> media_control_addr . port != 0 && rtcp_handle ) {\n srtcp_add_address ( pinfo , & upcoming_channel_lcl -> media_control_addr . addr , upcoming_channel_lcl -> media_control_addr . port , 0 , \"H245\" , pinfo -> fd -> num , dummy_srtp_info ) ;\n }\n }", "idx": 21805}
{"hash": -7076754245473579218, "project": "chrome", "size": 21, "label": 0, "functionSource": "static int socket_connect ( int fd , const char * address , unsigned short port ) {\n struct addrinfo * ai = make_addrinfo ( address , port ) ;\n int res = - 1 ;\n if ( ai == NULL ) {\n event_debug ( ( \"%s: make_addrinfo: \\\"%s:%d\\\"\" , __func__ , address , port ) ) ;\n return ( - 1 ) ;\n }\n if ( connect ( fd , ai -> ai_addr , ai -> ai_addrlen ) == - 1 ) {\n # ifdef WIN32 int tmp_error = WSAGetLastError ( ) ;\n if ( tmp_error != WSAEWOULDBLOCK && tmp_error != WSAEINVAL && tmp_error != WSAEINPROGRESS ) {\n goto out ;\n }\n # else if ( errno != EINPROGRESS ) {\n goto out ;\n }\n # endif }\n res = 0 ;\n out : # ifdef HAVE_GETADDRINFO freeaddrinfo ( ai ) ;\n # else fake_freeaddrinfo ( ai ) ;\n # endif return ( res ) ;\n }", "idx": 21806}
{"hash": 5825340398912191389, "project": "debian", "size": 19, "label": 0, "functionSource": "extern int name ( int ) __THROW __exctype ( isalnum ) ;\n __exctype ( isalpha ) ;\n __exctype ( iscntrl ) ;\n __exctype ( isdigit ) ;\n __exctype ( islower ) ;\n __exctype ( isgraph ) ;\n __exctype ( isprint ) ;\n __exctype ( ispunct ) ;\n __exctype ( isspace ) ;\n __exctype ( isupper ) ;\n __exctype ( isxdigit ) ;\n extern int tolower ( int __c ) __THROW ;\n extern int toupper ( int __c ) __THROW ;\n # ifdef __USE_ISOC99 __exctype ( isblank ) ;\n # endif # ifdef __USE_GNU extern int isctype ( int __c , int __mask ) __THROW ;\n # endif # if defined __USE_MISC || defined __USE_XOPEN extern int isascii ( int __c ) __THROW ;\n extern int toascii ( int __c ) __THROW ;\n __exctype ( _toupper ) ;\n __exctype ( _tolower )", "idx": 21807}
{"hash": 2895622461494525400, "project": "debian", "size": 32, "label": 0, "functionSource": "static void test_bug6046 ( ) {\n MYSQL_STMT * stmt ;\n const char * stmt_text ;\n int rc ;\n short b = 1 ;\n MYSQL_BIND my_bind [ 1 ] ;\n myheader ( \"test_bug6046\" ) ;\n stmt_text = \"DROP TABLE IF EXISTS t1\" ;\n rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n myquery ( rc ) ;\n stmt_text = \"CREATE TABLE t1 (a int, b int)\" ;\n rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n myquery ( rc ) ;\n stmt_text = \"INSERT INTO t1 VALUES (1,1),(2,2),(3,1),(4,2)\" ;\n rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n myquery ( rc ) ;\n stmt = mysql_stmt_init ( mysql ) ;\n stmt_text = \"SELECT t1.a FROM t1 NATURAL JOIN t1 as X1 \" \"WHERE t1.b > ? ORDER BY t1.a\" ;\n rc = mysql_stmt_prepare ( stmt , stmt_text , strlen ( stmt_text ) ) ;\n check_execute ( stmt , rc ) ;\n b = 1 ;\n memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n my_bind [ 0 ] . buffer = & b ;\n my_bind [ 0 ] . buffer_type = MYSQL_TYPE_SHORT ;\n mysql_stmt_bind_param ( stmt , my_bind ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n mysql_stmt_store_result ( stmt ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n mysql_stmt_close ( stmt ) ;\n }", "idx": 21808}
{"hash": 5357882892791796049, "project": "debian", "size": 7, "label": 0, "functionSource": "static bool e1000e_phy_reg_check_cap ( E1000ECore * core , uint32_t addr , char cap , uint8_t * page ) {\n * page = ( e1000e_phy_regcap [ 0 ] [ addr ] & PHY_ANYPAGE ) ? 0 : core -> phy [ 0 ] [ PHY_PAGE ] ;\n if ( * page >= E1000E_PHY_PAGES ) {\n return false ;\n }\n return e1000e_phy_regcap [ * page ] [ addr ] & cap ;\n }", "idx": 21809}
{"hash": -4534372572324105488, "project": "debian", "size": 63, "label": 0, "functionSource": "static int avi_read_idx1 ( AVFormatContext * s , int size ) {\n AVIContext * avi = s -> priv_data ;\n AVIOContext * pb = s -> pb ;\n int nb_index_entries , i ;\n AVStream * st ;\n AVIStream * ast ;\n int64_t pos ;\n unsigned int index , tag , flags , len , first_packet = 1 ;\n int64_t last_pos = - 1 ;\n unsigned last_idx = - 1 ;\n int64_t idx1_pos , first_packet_pos = 0 , data_offset = 0 ;\n int anykey = 0 ;\n nb_index_entries = size / 16 ;\n if ( nb_index_entries <= 0 ) return AVERROR_INVALIDDATA ;\n idx1_pos = avio_tell ( pb ) ;\n avio_seek ( pb , avi -> movi_list + 4 , SEEK_SET ) ;\n if ( avi_sync ( s , 1 ) == 0 ) first_packet_pos = avio_tell ( pb ) - 8 ;\n avi -> stream_index = - 1 ;\n avio_seek ( pb , idx1_pos , SEEK_SET ) ;\n if ( s -> nb_streams == 1 && s -> streams [ 0 ] -> codecpar -> codec_tag == AV_RL32 ( \"MMES\" ) ) {\n first_packet_pos = 0 ;\n data_offset = avi -> movi_list ;\n }\n for ( i = 0 ;\n i < nb_index_entries ;\n i ++ ) {\n if ( avio_feof ( pb ) ) return - 1 ;\n tag = avio_rl32 ( pb ) ;\n flags = avio_rl32 ( pb ) ;\n pos = avio_rl32 ( pb ) ;\n len = avio_rl32 ( pb ) ;\n av_log ( s , AV_LOG_TRACE , \"%d: tag=0x%x flags=0x%x pos=0x%\" PRIx64 \" len=%d/\" , i , tag , flags , pos , len ) ;\n index = ( ( tag & 0xff ) - '0' ) * 10 ;\n index += ( tag >> 8 & 0xff ) - '0' ;\n if ( index >= s -> nb_streams ) continue ;\n st = s -> streams [ index ] ;\n ast = st -> priv_data ;\n if ( ( tag >> 16 & 0xff ) == 'p' && ( tag >> 24 & 0xff ) == 'c' ) continue ;\n if ( first_packet && first_packet_pos ) {\n if ( avi -> movi_list + 4 != pos || pos + 500 > first_packet_pos ) data_offset = first_packet_pos - pos ;\n first_packet = 0 ;\n }\n pos += data_offset ;\n av_log ( s , AV_LOG_TRACE , \"%d cum_len=%\" PRId64 \"\\n\" , len , ast -> cum_len ) ;\n if ( last_pos == pos ) avi -> non_interleaved = 1 ;\n if ( last_idx != pos && len ) {\n av_add_index_entry ( st , pos , ast -> cum_len , len , 0 , ( flags & AVIIF_INDEX ) ? AVINDEX_KEYFRAME : 0 ) ;\n last_idx = pos ;\n }\n ast -> cum_len += get_duration ( ast , len ) ;\n last_pos = pos ;\n anykey |= flags & AVIIF_INDEX ;\n }\n if ( ! anykey ) {\n for ( index = 0 ;\n index < s -> nb_streams ;\n index ++ ) {\n st = s -> streams [ index ] ;\n if ( st -> nb_index_entries ) st -> index_entries [ 0 ] . flags |= AVINDEX_KEYFRAME ;\n }\n }\n return 0 ;\n }", "idx": 21810}
{"hash": 6500423400461365723, "project": "debian", "size": 48, "label": 0, "functionSource": "static int dwarf_elf_object_access_get_section_info ( void * obj_in , Dwarf_Half section_index , Dwarf_Obj_Access_Section * ret_scn , int * error ) {\n dwarf_elf_object_access_internals_t * obj = ( dwarf_elf_object_access_internals_t * ) obj_in ;\n Elf32_Shdr * shdr32 = 0 ;\n # ifdef HAVE_ELF64_GETSHDR Elf64_Shdr * shdr64 = 0 ;\n # endif Elf_Scn * scn = 0 ;\n scn = elf_getscn ( obj -> elf , section_index ) ;\n if ( scn == NULL ) {\n * error = DW_DLE_MDE ;\n return DW_DLV_ERROR ;\n }\n if ( obj -> is_64bit ) {\n # ifdef HAVE_ELF64_GETSHDR shdr64 = elf64_getshdr ( scn ) ;\n if ( shdr64 == NULL ) {\n * error = DW_DLE_ELF_GETSHDR_ERROR ;\n return DW_DLV_ERROR ;\n }\n ret_scn -> type = shdr64 -> sh_type ;\n ret_scn -> size = shdr64 -> sh_size ;\n ret_scn -> addr = shdr64 -> sh_addr ;\n ret_scn -> link = shdr64 -> sh_link ;\n ret_scn -> info = shdr64 -> sh_info ;\n ret_scn -> entrysize = shdr64 -> sh_entsize ;\n ret_scn -> name = elf_strptr ( obj -> elf , obj -> ehdr64 -> e_shstrndx , shdr64 -> sh_name ) ;\n if ( ret_scn -> name == NULL ) {\n * error = DW_DLE_ELF_STRPTR_ERROR ;\n return DW_DLV_ERROR ;\n }\n return DW_DLV_OK ;\n # else * error = DW_DLE_MISSING_ELF64_SUPPORT ;\n return DW_DLV_ERROR ;\n # endif }\n if ( ( shdr32 = elf32_getshdr ( scn ) ) == NULL ) {\n * error = DW_DLE_ELF_GETSHDR_ERROR ;\n return DW_DLV_ERROR ;\n }\n ret_scn -> type = shdr32 -> sh_type ;\n ret_scn -> size = shdr32 -> sh_size ;\n ret_scn -> addr = shdr32 -> sh_addr ;\n ret_scn -> link = shdr32 -> sh_link ;\n ret_scn -> info = shdr32 -> sh_info ;\n ret_scn -> entrysize = shdr32 -> sh_entsize ;\n ret_scn -> name = elf_strptr ( obj -> elf , obj -> ehdr32 -> e_shstrndx , shdr32 -> sh_name ) ;\n if ( ret_scn -> name == NULL ) {\n * error = DW_DLE_ELF_STRPTR_ERROR ;\n return DW_DLV_ERROR ;\n }\n return DW_DLV_OK ;\n }", "idx": 21811}
{"hash": 3071315158823512715, "project": "debian", "size": 113, "label": 1, "functionSource": "static int ac3_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n AVFrame * frame = data ;\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n AC3DecodeContext * s = avctx -> priv_data ;\n int blk , ch , err , ret ;\n const uint8_t * channel_map ;\n const float * output [ AC3_MAX_CHANNELS ] ;\n if ( buf_size >= 2 && AV_RB16 ( buf ) == 0x770B ) {\n int cnt = FFMIN ( buf_size , AC3_FRAME_BUFFER_SIZE ) >> 1 ;\n s -> dsp . bswap16_buf ( ( uint16_t * ) s -> input_buffer , ( const uint16_t * ) buf , cnt ) ;\n }\n else memcpy ( s -> input_buffer , buf , FFMIN ( buf_size , AC3_FRAME_BUFFER_SIZE ) ) ;\n buf = s -> input_buffer ;\n init_get_bits ( & s -> gbc , buf , buf_size * 8 ) ;\n err = parse_frame_header ( s ) ;\n if ( err ) {\n switch ( err ) {\n case AAC_AC3_PARSE_ERROR_SYNC : av_log ( avctx , AV_LOG_ERROR , \"frame sync error\\n\" ) ;\n return - 1 ;\n case AAC_AC3_PARSE_ERROR_BSID : av_log ( avctx , AV_LOG_ERROR , \"invalid bitstream id\\n\" ) ;\n break ;\n case AAC_AC3_PARSE_ERROR_SAMPLE_RATE : av_log ( avctx , AV_LOG_ERROR , \"invalid sample rate\\n\" ) ;\n break ;\n case AAC_AC3_PARSE_ERROR_FRAME_SIZE : av_log ( avctx , AV_LOG_ERROR , \"invalid frame size\\n\" ) ;\n break ;\n case AAC_AC3_PARSE_ERROR_FRAME_TYPE : if ( s -> frame_type == EAC3_FRAME_TYPE_DEPENDENT || s -> substreamid ) {\n av_log ( avctx , AV_LOG_ERROR , \"unsupported frame type : \" \"skipping frame\\n\" ) ;\n * got_frame_ptr = 0 ;\n return s -> frame_size ;\n }\n else {\n av_log ( avctx , AV_LOG_ERROR , \"invalid frame type\\n\" ) ;\n }\n break ;\n default : av_log ( avctx , AV_LOG_ERROR , \"invalid header\\n\" ) ;\n break ;\n }\n }\n else {\n if ( s -> frame_size > buf_size ) {\n av_log ( avctx , AV_LOG_ERROR , \"incomplete frame\\n\" ) ;\n err = AAC_AC3_PARSE_ERROR_FRAME_SIZE ;\n }\n else if ( avctx -> err_recognition & AV_EF_CRCCHECK ) {\n if ( av_crc ( av_crc_get_table ( AV_CRC_16_ANSI ) , 0 , & buf [ 2 ] , s -> frame_size - 2 ) ) {\n av_log ( avctx , AV_LOG_ERROR , \"frame CRC mismatch\\n\" ) ;\n err = AAC_AC3_PARSE_ERROR_CRC ;\n }\n }\n }\n if ( ! err ) {\n avctx -> sample_rate = s -> sample_rate ;\n avctx -> bit_rate = s -> bit_rate ;\n }\n if ( ! err || ( s -> channels && s -> out_channels != s -> channels ) ) {\n s -> out_channels = s -> channels ;\n s -> output_mode = s -> channel_mode ;\n if ( s -> lfe_on ) s -> output_mode |= AC3_OUTPUT_LFEON ;\n if ( avctx -> request_channels > 0 && avctx -> request_channels <= 2 && avctx -> request_channels < s -> channels ) {\n s -> out_channels = avctx -> request_channels ;\n s -> output_mode = avctx -> request_channels == 1 ? AC3_CHMODE_MONO : AC3_CHMODE_STEREO ;\n s -> channel_layout = avpriv_ac3_channel_layout_tab [ s -> output_mode ] ;\n }\n avctx -> channels = s -> out_channels ;\n avctx -> channel_layout = s -> channel_layout ;\n if ( s -> channels != s -> out_channels && ! ( ( s -> output_mode & AC3_OUTPUT_LFEON ) && s -> fbw_channels == s -> out_channels ) ) {\n set_downmix_coeffs ( s ) ;\n }\n }\n else if ( ! s -> channels ) {\n av_log ( avctx , AV_LOG_ERROR , \"unable to determine channel mode\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n avctx -> channels = s -> out_channels ;\n avctx -> audio_service_type = s -> bitstream_mode ;\n if ( s -> bitstream_mode == 0x7 && s -> channels > 1 ) avctx -> audio_service_type = AV_AUDIO_SERVICE_TYPE_KARAOKE ;\n frame -> nb_samples = s -> num_blocks * 256 ;\n if ( ( ret = ff_get_buffer ( avctx , frame ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n channel_map = ff_ac3_dec_channel_map [ s -> output_mode & ~ AC3_OUTPUT_LFEON ] [ s -> lfe_on ] ;\n for ( ch = 0 ;\n ch < s -> channels ;\n ch ++ ) {\n if ( ch < s -> out_channels ) s -> outptr [ channel_map [ ch ] ] = ( float * ) frame -> data [ ch ] ;\n else s -> outptr [ ch ] = s -> output [ ch ] ;\n output [ ch ] = s -> output [ ch ] ;\n }\n for ( blk = 0 ;\n blk < s -> num_blocks ;\n blk ++ ) {\n if ( ! err && decode_audio_block ( s , blk ) ) {\n av_log ( avctx , AV_LOG_ERROR , \"error decoding the audio block\\n\" ) ;\n err = 1 ;\n }\n if ( err ) for ( ch = 0 ;\n ch < s -> out_channels ;\n ch ++ ) memcpy ( s -> outptr [ channel_map [ ch ] ] , output [ ch ] , 1024 ) ;\n for ( ch = 0 ;\n ch < s -> out_channels ;\n ch ++ ) {\n output [ ch ] = s -> outptr [ channel_map [ ch ] ] ;\n s -> outptr [ channel_map [ ch ] ] += AC3_BLOCK_SIZE ;\n }\n }\n for ( ch = 0 ;\n ch < s -> out_channels ;\n ch ++ ) memcpy ( s -> output [ ch ] , output [ ch ] , 1024 ) ;\n * got_frame_ptr = 1 ;\n return FFMIN ( buf_size , s -> frame_size ) ;\n }", "idx": 21812}
{"hash": -6068976579504840746, "project": "debian", "size": 14, "label": 0, "functionSource": "static void send_random_tag_value ( int indx ) {\n int noise ;\n char buf [ 32 ] ;\n noise = rand ( ) ^ ( rand ( ) << 16 ) ;\n buf [ 0 ] = 'a' + noise % 26 ;\n noise >>= 5 ;\n buf [ 1 ] = 'a' + noise % 26 ;\n noise >>= 5 ;\n buf [ 2 ] = 'a' + noise % 26 ;\n noise >>= 5 ;\n buf [ 3 ] = '.' ;\n snprintf ( & buf [ 4 ] , sizeof ( buf ) - 4 , \"%d\" , indx ) ;\n ctl_putuint ( buf , noise ) ;\n }", "idx": 21813}
{"hash": 7037573792123850742, "project": "debian", "size": 3, "label": 0, "functionSource": "static PHP_NAMED_FUNCTION ( zif_zip_entry_name ) {\n php_zip_entry_get_info ( INTERNAL_FUNCTION_PARAM_PASSTHRU , 0 ) ;\n }", "idx": 21814}
{"hash": -4635544075321012404, "project": "debian", "size": 27, "label": 0, "functionSource": "static struct curl_httppost * AddHttpPost ( char * name , size_t namelength , char * value , size_t contentslength , char * buffer , size_t bufferlength , char * contenttype , long flags , struct curl_slist * contentHeader , char * showfilename , char * userp , struct curl_httppost * parent_post , struct curl_httppost * * httppost , struct curl_httppost * * last_post ) {\n struct curl_httppost * post ;\n post = calloc ( 1 , sizeof ( struct curl_httppost ) ) ;\n if ( post ) {\n post -> name = name ;\n post -> namelength = ( long ) ( name ? ( namelength ? namelength : strlen ( name ) ) : 0 ) ;\n post -> contents = value ;\n post -> contentslength = ( long ) contentslength ;\n post -> buffer = buffer ;\n post -> bufferlength = ( long ) bufferlength ;\n post -> contenttype = contenttype ;\n post -> contentheader = contentHeader ;\n post -> showfilename = showfilename ;\n post -> userp = userp , post -> flags = flags ;\n }\n else return NULL ;\n if ( parent_post ) {\n post -> more = parent_post -> more ;\n parent_post -> more = post ;\n }\n else {\n if ( * last_post ) ( * last_post ) -> next = post ;\n else ( * httppost ) = post ;\n ( * last_post ) = post ;\n }\n return post ;\n }", "idx": 21815}
{"hash": -7117046864335130087, "project": "chrome", "size": 13, "label": 0, "functionSource": "int vp9_compute_qdelta_by_rate ( const RATE_CONTROL * rc , FRAME_TYPE frame_type , int qindex , double rate_target_ratio , vpx_bit_depth_t bit_depth ) {\n int target_index = rc -> worst_quality ;\n int i ;\n const int base_bits_per_mb = vp9_rc_bits_per_mb ( frame_type , qindex , 1.0 , bit_depth ) ;\n const int target_bits_per_mb = ( int ) ( rate_target_ratio * base_bits_per_mb ) ;\n for ( i = rc -> best_quality ;\n i < rc -> worst_quality ;\n ++ i ) {\n target_index = i ;\n if ( vp9_rc_bits_per_mb ( frame_type , i , 1.0 , bit_depth ) <= target_bits_per_mb ) break ;\n }\n return target_index - qindex ;\n }", "idx": 21816}
{"hash": 2546373479020365143, "project": "debian", "size": 28, "label": 0, "functionSource": "MIMEField * _mime_hdr_field_list_search_by_slotnum ( MIMEHdrImpl * mh , int slotnum ) {\n unsigned int block_num , block_index ;\n MIMEFieldBlockImpl * fblock ;\n if ( slotnum < MIME_FIELD_BLOCK_SLOTS ) {\n fblock = & ( mh -> m_first_fblock ) ;\n block_index = slotnum ;\n if ( block_index >= fblock -> m_freetop ) {\n return nullptr ;\n }\n else {\n return & ( fblock -> m_field_slots [ block_index ] ) ;\n }\n }\n else {\n block_num = slotnum / MIME_FIELD_BLOCK_SLOTS ;\n block_index = slotnum % MIME_FIELD_BLOCK_SLOTS ;\n fblock = & ( mh -> m_first_fblock ) ;\n while ( block_num -- && fblock ) {\n fblock = fblock -> m_next ;\n }\n if ( ( fblock == nullptr ) || ( block_index >= fblock -> m_freetop ) ) {\n return nullptr ;\n }\n else {\n return & ( fblock -> m_field_slots [ block_index ] ) ;\n }\n }\n }", "idx": 21817}
{"hash": 6323824267898511453, "project": "debian", "size": 10, "label": 0, "functionSource": "static void indexed_to_alt ( fz_context * ctx , const fz_colorspace * cs , const float * color , float * alt ) {\n struct indexed * idx = cs -> data ;\n int i , k ;\n int n = idx -> base -> n ;\n i = color [ 0 ] * 255 ;\n i = fz_clampi ( i , 0 , idx -> high ) ;\n for ( k = 0 ;\n k < n ;\n k ++ ) alt [ k ] = idx -> lookup [ i * n + k ] / 255.0f ;\n }", "idx": 21818}
{"hash": -398565394354770780, "project": "debian", "size": 7, "label": 0, "functionSource": "static void ohci_realize_pxa ( DeviceState * dev , Error * * errp ) {\n OHCISysBusState * s = SYSBUS_OHCI ( dev ) ;\n SysBusDevice * sbd = SYS_BUS_DEVICE ( dev ) ;\n usb_ohci_init ( & s -> ohci , dev , s -> num_ports , s -> dma_offset , NULL , 0 , & address_space_memory , & error_abort ) ;\n sysbus_init_irq ( sbd , & s -> ohci . irq ) ;\n sysbus_init_mmio ( sbd , & s -> ohci . mem ) ;\n }", "idx": 21819}
{"hash": 6323824267898511453, "project": "debian", "size": 28, "label": 0, "functionSource": "const unsigned char * fz_lookup_icc ( fz_context * ctx , const char * name , size_t * size ) {\n # ifndef NO_ICC if ( fz_get_cmm_engine ( ctx ) == NULL ) return * size = 0 , NULL ;\n if ( ! strcmp ( name , FZ_ICC_PROFILE_GRAY ) ) {\n extern const int fz_resources_icc_gray_icc_size ;\n extern const unsigned char fz_resources_icc_gray_icc [ ] ;\n * size = fz_resources_icc_gray_icc_size ;\n return fz_resources_icc_gray_icc ;\n }\n if ( ! strcmp ( name , FZ_ICC_PROFILE_RGB ) || ! strcmp ( name , FZ_ICC_PROFILE_BGR ) ) {\n extern const int fz_resources_icc_rgb_icc_size ;\n extern const unsigned char fz_resources_icc_rgb_icc [ ] ;\n * size = fz_resources_icc_rgb_icc_size ;\n return fz_resources_icc_rgb_icc ;\n }\n if ( ! strcmp ( name , FZ_ICC_PROFILE_CMYK ) ) {\n extern const int fz_resources_icc_cmyk_icc_size ;\n extern const unsigned char fz_resources_icc_cmyk_icc [ ] ;\n * size = fz_resources_icc_cmyk_icc_size ;\n return fz_resources_icc_cmyk_icc ;\n }\n if ( ! strcmp ( name , FZ_ICC_PROFILE_LAB ) ) {\n extern const int fz_resources_icc_lab_icc_size ;\n extern const unsigned char fz_resources_icc_lab_icc [ ] ;\n * size = fz_resources_icc_lab_icc_size ;\n return fz_resources_icc_lab_icc ;\n }\n # endif return * size = 0 , NULL ;\n }", "idx": 21820}
{"hash": -2653265013496966602, "project": "debian", "size": 6, "label": 0, "functionSource": "static int dict_spot_results ( i_ctx_t * i_ctx_p , ref * pdict , const gs_spot_halftone * psp ) {\n int code ;\n code = dict_real_result ( i_ctx_p , pdict , \"ActualFrequency\" , psp -> screen . actual_frequency ) ;\n if ( code < 0 ) return code ;\n return dict_real_result ( i_ctx_p , pdict , \"ActualAngle\" , psp -> screen . actual_angle ) ;\n }", "idx": 21821}
{"hash": 2578089348587614328, "project": "debian", "size": 3, "label": 0, "functionSource": "DSA * d2i_DSA_PUBKEY_bio ( BIO * bp , DSA * * dsa ) {\n return ASN1_d2i_bio_of ( DSA , DSA_new , d2i_DSA_PUBKEY , bp , dsa ) ;\n }", "idx": 21822}
{"hash": -5992472514718425579, "project": "debian", "size": 16, "label": 0, "functionSource": "static const char * cgfs_canonical_path ( void * hdata ) {\n struct cgfs_data * d = hdata ;\n struct cgroup_process_info * info_ptr ;\n char * path = NULL ;\n if ( ! d ) return NULL ;\n for ( info_ptr = d -> info ;\n info_ptr ;\n info_ptr = info_ptr -> next ) {\n if ( ! path ) path = info_ptr -> cgroup_path ;\n else if ( strcmp ( path , info_ptr -> cgroup_path ) != 0 ) {\n ERROR ( \"not all paths match %s, %s has path %s\" , path , info_ptr -> hierarchy -> subsystems [ 0 ] , info_ptr -> cgroup_path ) ;\n return NULL ;\n }\n }\n return path ;\n }", "idx": 21823}
{"hash": -6333668321124139371, "project": "debian", "size": 65, "label": 0, "functionSource": "static void process_rtp_payload ( tvbuff_t * newtvb , packet_info * pinfo , proto_tree * tree , proto_tree * rtp_tree , unsigned int payload_type ) {\n struct _rtp_conversation_info * p_conv_data = NULL ;\n gboolean found_match = FALSE ;\n int payload_len ;\n struct srtp_info * srtp_info ;\n int offset = 0 ;\n payload_len = tvb_length_remaining ( newtvb , offset ) ;\n p_conv_data = ( struct _rtp_conversation_info * ) p_get_proto_data ( wmem_file_scope ( ) , pinfo , proto_rtp , 0 ) ;\n if ( p_conv_data && p_conv_data -> srtp_info ) {\n srtp_info = p_conv_data -> srtp_info ;\n payload_len -= srtp_info -> mki_len + srtp_info -> auth_tag_len ;\n # if 0 # error Currently the srtp_info structure contains no cipher data , see packet - sdp . c adding dummy_srtp_info structure if ( p_conv_data -> srtp_info -> encryption_algorithm == SRTP_ENC_ALG_NULL ) {\n if ( rtp_tree ) proto_tree_add_text ( rtp_tree , newtvb , offset , payload_len , \"SRTP Payload with NULL encryption\" ) ;\n }\n else # endif {\n if ( rtp_tree ) proto_tree_add_item ( rtp_tree , hf_srtp_encrypted_payload , newtvb , offset , payload_len , ENC_NA ) ;\n found_match = TRUE ;\n }\n offset += payload_len ;\n if ( srtp_info -> mki_len ) {\n proto_tree_add_item ( rtp_tree , hf_srtp_mki , newtvb , offset , srtp_info -> mki_len , ENC_NA ) ;\n offset += srtp_info -> mki_len ;\n }\n if ( srtp_info -> auth_tag_len ) {\n proto_tree_add_item ( rtp_tree , hf_srtp_auth_tag , newtvb , offset , srtp_info -> auth_tag_len , ENC_NA ) ;\n }\n }\n else if ( p_conv_data && ! p_conv_data -> bta2dp_info && ! p_conv_data -> btvdp_info && payload_type >= PT_UNDF_96 && payload_type <= PT_UNDF_127 ) {\n if ( p_conv_data && p_conv_data -> rtp_dyn_payload ) {\n const gchar * payload_type_str = rtp_dyn_payload_get_name ( p_conv_data -> rtp_dyn_payload , payload_type ) ;\n if ( payload_type_str ) {\n found_match = dissector_try_string ( rtp_dyn_pt_dissector_table , payload_type_str , newtvb , pinfo , tree , NULL ) ;\n if ( found_match == FALSE ) proto_tree_add_item ( rtp_tree , hf_rtp_data , newtvb , 0 , - 1 , ENC_NA ) ;\n return ;\n }\n }\n }\n else if ( p_conv_data && p_conv_data -> bta2dp_info ) {\n tvbuff_t * nexttvb ;\n gint suboffset = 0 ;\n found_match = TRUE ;\n if ( p_conv_data -> bta2dp_info -> content_protection_type == BTAVDTP_CONTENT_PROTECTION_TYPE_SCMS_T ) {\n nexttvb = tvb_new_subset ( newtvb , 0 , 1 , 1 ) ;\n call_dissector ( bta2dp_content_protection_header_scms_t , nexttvb , pinfo , tree ) ;\n suboffset = 1 ;\n }\n nexttvb = tvb_new_subset_remaining ( newtvb , suboffset ) ;\n if ( p_conv_data -> bta2dp_info -> codec_dissector ) call_dissector ( p_conv_data -> bta2dp_info -> codec_dissector , nexttvb , pinfo , tree ) ;\n else call_dissector ( data_handle , nexttvb , pinfo , tree ) ;\n }\n else if ( p_conv_data && p_conv_data -> btvdp_info ) {\n tvbuff_t * nexttvb ;\n gint suboffset = 0 ;\n found_match = TRUE ;\n if ( p_conv_data -> btvdp_info -> content_protection_type == BTAVDTP_CONTENT_PROTECTION_TYPE_SCMS_T ) {\n nexttvb = tvb_new_subset ( newtvb , 0 , 1 , 1 ) ;\n call_dissector ( bta2dp_content_protection_header_scms_t , nexttvb , pinfo , tree ) ;\n suboffset = 1 ;\n }\n nexttvb = tvb_new_subset_remaining ( newtvb , suboffset ) ;\n if ( p_conv_data -> btvdp_info -> codec_dissector ) call_dissector ( p_conv_data -> btvdp_info -> codec_dissector , nexttvb , pinfo , tree ) ;\n else call_dissector ( data_handle , nexttvb , pinfo , tree ) ;\n }\n if ( ! found_match && ! dissector_try_uint ( rtp_pt_dissector_table , payload_type , newtvb , pinfo , tree ) ) proto_tree_add_item ( rtp_tree , hf_rtp_data , newtvb , 0 , - 1 , ENC_NA ) ;\n }", "idx": 21824}
{"hash": -7241004363975794258, "project": "debian", "size": 14, "label": 0, "functionSource": "static void dump_page_info ( Jbig2Ctx * ctx , Jbig2Segment * segment , Jbig2Page * page ) {\n if ( page -> x_resolution == 0 ) {\n jbig2_error ( ctx , JBIG2_SEVERITY_INFO , segment -> number , \"page %d image is %dx%d (unknown res)\" , page -> number , page -> width , page -> height ) ;\n }\n else if ( page -> x_resolution == page -> y_resolution ) {\n jbig2_error ( ctx , JBIG2_SEVERITY_INFO , segment -> number , \"page %d image is %dx%d (%d ppm)\" , page -> number , page -> width , page -> height , page -> x_resolution ) ;\n }\n else {\n jbig2_error ( ctx , JBIG2_SEVERITY_INFO , segment -> number , \"page %d image is %dx%d (%dx%d ppm)\" , page -> number , page -> width , page -> height , page -> x_resolution , page -> y_resolution ) ;\n }\n if ( page -> striped ) {\n jbig2_error ( ctx , JBIG2_SEVERITY_INFO , segment -> number , \"\\tmaximum stripe size: %d\" , page -> stripe_size ) ;\n }\n }", "idx": 21825}
{"hash": -2908211205972632000, "project": "debian", "size": 27, "label": 1, "functionSource": "static void _cmd_window_show_opt ( const char * data , int right ) {\n MAIN_WINDOW_REC * parent ;\n WINDOW_REC * window ;\n if ( * data == '\\0' ) cmd_return_error ( CMDERR_NOT_ENOUGH_PARAMS ) ;\n if ( is_numeric ( data , '\\0' ) ) {\n window = window_find_refnum ( atoi ( data ) ) ;\n if ( window == NULL ) {\n printformat_window ( active_win , MSGLEVEL_CLIENTERROR , TXT_REFNUM_NOT_FOUND , data ) ;\n }\n }\n else {\n window = window_find_item ( active_win -> active_server , data ) ;\n }\n if ( window == NULL || is_window_visible ( window ) ) return ;\n if ( WINDOW_GUI ( window ) -> sticky ) {\n if ( ! settings_get_bool ( \"autounstick_windows\" ) ) {\n printformat_window ( active_win , MSGLEVEL_CLIENTERROR , TXT_CANT_SHOW_STICKY_WINDOWS ) ;\n return ;\n }\n }\n parent = mainwindow_create ( right ) ;\n parent -> active = window ;\n gui_window_reparent ( window , parent ) ;\n if ( settings_get_bool ( \"autostick_split_windows\" ) ) gui_window_set_sticky ( window ) ;\n active_mainwin = NULL ;\n window_set_active ( window ) ;\n }", "idx": 21826}
{"hash": 6323824267898511453, "project": "debian", "size": 105, "label": 0, "functionSource": "static void fast_gray_to_rgb ( fz_context * ctx , fz_pixmap * dst , fz_pixmap * src , fz_colorspace * prf , const fz_default_colorspaces * default_cs , const fz_color_params * color_params , int copy_spots ) {\n unsigned char * s = src -> samples ;\n unsigned char * d = dst -> samples ;\n size_t w = src -> w ;\n int h = src -> h ;\n int sn = src -> n ;\n int ss = src -> s ;\n int sa = src -> alpha ;\n int dn = dst -> n ;\n int ds = dst -> s ;\n int da = dst -> alpha ;\n ptrdiff_t d_line_inc = dst -> stride - w * dn ;\n ptrdiff_t s_line_inc = src -> stride - w * sn ;\n if ( ( copy_spots && ss != ds ) || ( ! da && sa ) ) {\n assert ( \"This should never happen\" == NULL ) ;\n fz_throw ( ctx , FZ_ERROR_GENERIC , \"Cannot convert between incompatible pixmaps\" ) ;\n }\n if ( ( int ) w < 0 || h < 0 ) return ;\n if ( d_line_inc == 0 && s_line_inc == 0 ) {\n w *= h ;\n h = 1 ;\n }\n if ( ss == 0 && ds == 0 ) {\n if ( da ) {\n if ( sa ) {\n while ( h -- ) {\n size_t ww = w ;\n while ( ww -- ) {\n d [ 0 ] = s [ 0 ] ;\n d [ 1 ] = s [ 0 ] ;\n d [ 2 ] = s [ 0 ] ;\n d [ 3 ] = s [ 1 ] ;\n s += 2 ;\n d += 4 ;\n }\n d += d_line_inc ;\n s += s_line_inc ;\n }\n }\n else {\n while ( h -- ) {\n size_t ww = w ;\n while ( ww -- ) {\n d [ 0 ] = s [ 0 ] ;\n d [ 1 ] = s [ 0 ] ;\n d [ 2 ] = s [ 0 ] ;\n d [ 3 ] = 255 ;\n s ++ ;\n d += 4 ;\n }\n d += d_line_inc ;\n s += s_line_inc ;\n }\n }\n }\n else {\n while ( h -- ) {\n size_t ww = w ;\n while ( ww -- ) {\n d [ 0 ] = s [ 0 ] ;\n d [ 1 ] = s [ 0 ] ;\n d [ 2 ] = s [ 0 ] ;\n s ++ ;\n d += 3 ;\n }\n d += d_line_inc ;\n s += s_line_inc ;\n }\n }\n }\n else if ( copy_spots ) {\n int i ;\n while ( h -- ) {\n size_t ww = w ;\n while ( ww -- ) {\n d [ 0 ] = s [ 0 ] ;\n d [ 1 ] = s [ 0 ] ;\n d [ 2 ] = s [ 0 ] ;\n s += 1 ;\n d += 3 ;\n for ( i = ss ;\n i > 0 ;\n i -- ) * d ++ = * s ++ ;\n if ( da ) * d ++ = sa ? * s ++ : 255 ;\n }\n d += d_line_inc ;\n s += s_line_inc ;\n }\n }\n else {\n while ( h -- ) {\n size_t ww = w ;\n while ( ww -- ) {\n d [ 0 ] = s [ 0 ] ;\n d [ 1 ] = s [ 0 ] ;\n d [ 2 ] = s [ 0 ] ;\n s += sn ;\n d += dn ;\n if ( da ) d [ - 1 ] = sa ? s [ - 1 ] : 255 ;\n }\n d += d_line_inc ;\n s += s_line_inc ;\n }\n }\n }", "idx": 21827}
{"hash": 4704178797381506498, "project": "debian", "size": 89, "label": 0, "functionSource": "kadm5_ret_t kadm5_get_principal ( void * server_handle , krb5_principal principal , kadm5_principal_ent_t entry , long in_mask ) {\n krb5_db_entry * kdb ;\n osa_princ_ent_rec adb ;\n krb5_error_code ret = 0 ;\n long mask ;\n int i ;\n kadm5_server_handle_t handle = server_handle ;\n CHECK_HANDLE ( server_handle ) ;\n krb5_clear_error_message ( handle -> context ) ;\n mask = in_mask ;\n memset ( entry , 0 , sizeof ( * entry ) ) ;\n if ( principal == NULL ) return EINVAL ;\n if ( ( ret = kdb_get_entry ( handle , principal , & kdb , & adb ) ) ) return ret ;\n if ( ( mask & KADM5_POLICY ) && adb . policy && ( adb . aux_attributes & KADM5_POLICY ) ) {\n if ( ( entry -> policy = strdup ( adb . policy ) ) == NULL ) {\n ret = ENOMEM ;\n goto done ;\n }\n }\n if ( mask & KADM5_AUX_ATTRIBUTES ) entry -> aux_attributes = adb . aux_attributes ;\n if ( ( mask & KADM5_PRINCIPAL ) && ( ret = krb5_copy_principal ( handle -> context , kdb -> princ , & entry -> principal ) ) ) {\n goto done ;\n }\n if ( mask & KADM5_PRINC_EXPIRE_TIME ) entry -> princ_expire_time = kdb -> expiration ;\n if ( ( mask & KADM5_LAST_PWD_CHANGE ) && ( ret = krb5_dbe_lookup_last_pwd_change ( handle -> context , kdb , & ( entry -> last_pwd_change ) ) ) ) {\n goto done ;\n }\n if ( mask & KADM5_PW_EXPIRATION ) entry -> pw_expiration = kdb -> pw_expiration ;\n if ( mask & KADM5_MAX_LIFE ) entry -> max_life = kdb -> max_life ;\n if ( ( mask & KADM5_MOD_NAME ) || ( mask & KADM5_MOD_TIME ) ) {\n ret = krb5_dbe_lookup_mod_princ_data ( handle -> context , kdb , & ( entry -> mod_date ) , & ( entry -> mod_name ) ) ;\n if ( ret ) {\n goto done ;\n }\n if ( ! ( mask & KADM5_MOD_TIME ) ) entry -> mod_date = 0 ;\n if ( ! ( mask & KADM5_MOD_NAME ) ) {\n krb5_free_principal ( handle -> context , entry -> mod_name ) ;\n entry -> mod_name = NULL ;\n }\n }\n if ( mask & KADM5_ATTRIBUTES ) entry -> attributes = kdb -> attributes ;\n if ( mask & KADM5_KVNO ) for ( entry -> kvno = 0 , i = 0 ;\n i < kdb -> n_key_data ;\n i ++ ) if ( ( krb5_kvno ) kdb -> key_data [ i ] . key_data_kvno > entry -> kvno ) entry -> kvno = kdb -> key_data [ i ] . key_data_kvno ;\n if ( mask & KADM5_MKVNO ) {\n ret = krb5_dbe_get_mkvno ( handle -> context , kdb , & entry -> mkvno ) ;\n if ( ret ) goto done ;\n }\n if ( mask & KADM5_MAX_RLIFE ) entry -> max_renewable_life = kdb -> max_renewable_life ;\n if ( mask & KADM5_LAST_SUCCESS ) entry -> last_success = kdb -> last_success ;\n if ( mask & KADM5_LAST_FAILED ) entry -> last_failed = kdb -> last_failed ;\n if ( mask & KADM5_FAIL_AUTH_COUNT ) entry -> fail_auth_count = kdb -> fail_auth_count ;\n if ( mask & KADM5_TL_DATA ) {\n krb5_tl_data * tl , * tl2 ;\n entry -> tl_data = NULL ;\n tl = kdb -> tl_data ;\n while ( tl ) {\n if ( tl -> tl_data_type > 255 ) {\n if ( ( tl2 = dup_tl_data ( tl ) ) == NULL ) {\n ret = ENOMEM ;\n goto done ;\n }\n tl2 -> tl_data_next = entry -> tl_data ;\n entry -> tl_data = tl2 ;\n entry -> n_tl_data ++ ;\n }\n tl = tl -> tl_data_next ;\n }\n }\n if ( mask & KADM5_KEY_DATA ) {\n entry -> n_key_data = kdb -> n_key_data ;\n if ( entry -> n_key_data ) {\n entry -> key_data = k5calloc ( entry -> n_key_data , sizeof ( krb5_key_data ) , & ret ) ;\n if ( entry -> key_data == NULL ) goto done ;\n }\n else entry -> key_data = NULL ;\n for ( i = 0 ;\n i < entry -> n_key_data ;\n i ++ ) ret = krb5_copy_key_data_contents ( handle -> context , & kdb -> key_data [ i ] , & entry -> key_data [ i ] ) ;\n if ( ret ) goto done ;\n }\n ret = KADM5_OK ;\n done : if ( ret && entry -> principal ) {\n krb5_free_principal ( handle -> context , entry -> principal ) ;\n entry -> principal = NULL ;\n }\n kdb_free_entry ( handle , kdb , & adb ) ;\n return ret ;\n }", "idx": 21828}
{"hash": 3919646340804521652, "project": "debian", "size": 5, "label": 0, "functionSource": "static void setup_delta_attr_check ( struct git_attr_check * check ) {\n static struct git_attr * attr_delta ;\n if ( ! attr_delta ) attr_delta = git_attr ( \"delta\" ) ;\n check [ 0 ] . attr = attr_delta ;\n }", "idx": 21829}
{"hash": 2125998987781803371, "project": "debian", "size": 68, "label": 0, "functionSource": "static picture_t * DecodeBlock ( decoder_t * p_dec , block_t * * pp_block ) {\n decoder_sys_t * p_sys = p_dec -> p_sys ;\n if ( ! pp_block ) return NULL ;\n if ( * pp_block ) {\n block_t * p_block = * pp_block ;\n if ( p_block -> i_flags & BLOCK_FLAG_DISCONTINUITY ) {\n schro_decoder_reset ( p_sys -> p_schro ) ;\n p_sys -> i_lastpts = VLC_TS_INVALID ;\n block_Release ( p_block ) ;\n * pp_block = NULL ;\n return NULL ;\n }\n SchroBuffer * p_schrobuffer ;\n p_schrobuffer = schro_buffer_new_with_data ( p_block -> p_buffer , p_block -> i_buffer ) ;\n p_schrobuffer -> free = SchroBufferFree ;\n p_schrobuffer -> priv = p_block ;\n if ( p_block -> i_pts > VLC_TS_INVALID ) {\n mtime_t * p_pts = malloc ( sizeof ( * p_pts ) ) ;\n if ( p_pts ) {\n * p_pts = p_block -> i_pts ;\n p_schrobuffer -> tag = schro_tag_new ( p_pts , free ) ;\n }\n }\n * pp_block = NULL ;\n schro_decoder_autoparse_push ( p_sys -> p_schro , p_schrobuffer ) ;\n }\n while ( 1 ) {\n SchroFrame * p_schroframe ;\n picture_t * p_pic ;\n int state = schro_decoder_autoparse_wait ( p_sys -> p_schro ) ;\n switch ( state ) {\n case SCHRO_DECODER_FIRST_ACCESS_UNIT : SetVideoFormat ( p_dec ) ;\n break ;\n case SCHRO_DECODER_NEED_BITS : return NULL ;\n case SCHRO_DECODER_NEED_FRAME : p_schroframe = CreateSchroFrameFromPic ( p_dec ) ;\n if ( ! p_schroframe ) {\n msg_Err ( p_dec , \"Could not allocate picture for decoder\" ) ;\n return NULL ;\n }\n schro_decoder_add_output_picture ( p_sys -> p_schro , p_schroframe ) ;\n break ;\n case SCHRO_DECODER_OK : {\n SchroTag * p_tag = schro_decoder_get_picture_tag ( p_sys -> p_schro ) ;\n p_schroframe = schro_decoder_pull ( p_sys -> p_schro ) ;\n if ( ! p_schroframe || ! p_schroframe -> priv ) {\n if ( p_tag ) schro_tag_free ( p_tag ) ;\n if ( p_schroframe ) schro_frame_unref ( p_schroframe ) ;\n break ;\n }\n p_pic = ( ( struct picture_free_t * ) p_schroframe -> priv ) -> p_pic ;\n p_schroframe -> priv = NULL ;\n if ( p_tag ) {\n p_pic -> date = * ( mtime_t * ) p_tag -> value ;\n schro_tag_free ( p_tag ) ;\n }\n else if ( p_sys -> i_lastpts > VLC_TS_INVALID ) {\n p_pic -> date = p_sys -> i_lastpts + p_sys -> i_frame_pts_delta ;\n }\n p_sys -> i_lastpts = p_pic -> date ;\n schro_frame_unref ( p_schroframe ) ;\n return p_pic ;\n }\n case SCHRO_DECODER_EOS : break ;\n case SCHRO_DECODER_ERROR : msg_Err ( p_dec , \"SCHRO_DECODER_ERROR\" ) ;\n return NULL ;\n }\n }\n }", "idx": 21830}
{"hash": -1594970847928262768, "project": "debian", "size": 61, "label": 0, "functionSource": "static int decode_slice ( AVCodecContext * avctx , void * tdata ) {\n ProresThreadData * td = tdata ;\n ProresContext * ctx = avctx -> priv_data ;\n int mb_x_pos = td -> x_pos ;\n int mb_y_pos = td -> y_pos ;\n int pic_num = ctx -> pic_num ;\n int slice_num = td -> slice_num ;\n int mbs_per_slice = td -> slice_width ;\n const uint8_t * buf ;\n uint8_t * y_data , * u_data , * v_data ;\n AVFrame * pic = ctx -> frame ;\n int i , sf , slice_width_factor ;\n int slice_data_size , hdr_size , y_data_size , u_data_size , v_data_size ;\n int y_linesize , u_linesize , v_linesize ;\n buf = ctx -> slice_data [ slice_num ] . index ;\n slice_data_size = ctx -> slice_data [ slice_num + 1 ] . index - buf ;\n slice_width_factor = av_log2 ( mbs_per_slice ) ;\n y_data = pic -> data [ 0 ] ;\n u_data = pic -> data [ 1 ] ;\n v_data = pic -> data [ 2 ] ;\n y_linesize = pic -> linesize [ 0 ] ;\n u_linesize = pic -> linesize [ 1 ] ;\n v_linesize = pic -> linesize [ 2 ] ;\n if ( pic -> interlaced_frame ) {\n if ( ! ( pic_num ^ pic -> top_field_first ) ) {\n y_data += y_linesize ;\n u_data += u_linesize ;\n v_data += v_linesize ;\n }\n y_linesize <<= 1 ;\n u_linesize <<= 1 ;\n v_linesize <<= 1 ;\n }\n if ( slice_data_size < 6 ) {\n av_log ( avctx , AV_LOG_ERROR , \"slice data too small\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n hdr_size = buf [ 0 ] >> 3 ;\n y_data_size = AV_RB16 ( buf + 2 ) ;\n u_data_size = AV_RB16 ( buf + 4 ) ;\n v_data_size = hdr_size > 7 ? AV_RB16 ( buf + 6 ) : slice_data_size - y_data_size - u_data_size - hdr_size ;\n if ( hdr_size + y_data_size + u_data_size + v_data_size > slice_data_size || v_data_size < 0 || hdr_size < 6 ) {\n av_log ( avctx , AV_LOG_ERROR , \"invalid data size\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n sf = av_clip ( buf [ 1 ] , 1 , 224 ) ;\n sf = sf > 128 ? ( sf - 96 ) << 2 : sf ;\n if ( ctx -> qmat_changed || sf != td -> prev_slice_sf ) {\n td -> prev_slice_sf = sf ;\n for ( i = 0 ;\n i < 64 ;\n i ++ ) {\n td -> qmat_luma_scaled [ ctx -> dsp . idct_permutation [ i ] ] = ctx -> qmat_luma [ i ] * sf ;\n td -> qmat_chroma_scaled [ ctx -> dsp . idct_permutation [ i ] ] = ctx -> qmat_chroma [ i ] * sf ;\n }\n }\n decode_slice_plane ( ctx , td , buf + hdr_size , y_data_size , ( uint16_t * ) ( y_data + ( mb_y_pos << 4 ) * y_linesize + ( mb_x_pos << 5 ) ) , y_linesize , mbs_per_slice , 4 , slice_width_factor + 2 , td -> qmat_luma_scaled , 0 ) ;\n decode_slice_plane ( ctx , td , buf + hdr_size + y_data_size , u_data_size , ( uint16_t * ) ( u_data + ( mb_y_pos << 4 ) * u_linesize + ( mb_x_pos << ctx -> mb_chroma_factor ) ) , u_linesize , mbs_per_slice , ctx -> num_chroma_blocks , slice_width_factor + ctx -> chroma_factor - 1 , td -> qmat_chroma_scaled , 1 ) ;\n decode_slice_plane ( ctx , td , buf + hdr_size + y_data_size + u_data_size , v_data_size , ( uint16_t * ) ( v_data + ( mb_y_pos << 4 ) * v_linesize + ( mb_x_pos << ctx -> mb_chroma_factor ) ) , v_linesize , mbs_per_slice , ctx -> num_chroma_blocks , slice_width_factor + ctx -> chroma_factor - 1 , td -> qmat_chroma_scaled , 1 ) ;\n return 0 ;\n }", "idx": 21831}
{"hash": -4106680724983638989, "project": "chrome", "size": 39, "label": 0, "functionSource": "static void sbr_hf_inverse_filter ( SBRDSPContext * dsp , float ( * alpha0 ) [ 2 ] , float ( * alpha1 ) [ 2 ] , const float X_low [ 32 ] [ 40 ] [ 2 ] , int k0 ) {\n int k ;\n for ( k = 0 ;\n k < k0 ;\n k ++ ) {\n LOCAL_ALIGNED_16 ( float , phi , [ 3 ] , [ 2 ] [ 2 ] ) ;\n float dk ;\n dsp -> autocorrelate ( X_low [ k ] , phi ) ;\n dk = phi [ 2 ] [ 1 ] [ 0 ] * phi [ 1 ] [ 0 ] [ 0 ] - ( phi [ 1 ] [ 1 ] [ 0 ] * phi [ 1 ] [ 1 ] [ 0 ] + phi [ 1 ] [ 1 ] [ 1 ] * phi [ 1 ] [ 1 ] [ 1 ] ) / 1.000001f ;\n if ( ! dk ) {\n alpha1 [ k ] [ 0 ] = 0 ;\n alpha1 [ k ] [ 1 ] = 0 ;\n }\n else {\n float temp_real , temp_im ;\n temp_real = phi [ 0 ] [ 0 ] [ 0 ] * phi [ 1 ] [ 1 ] [ 0 ] - phi [ 0 ] [ 0 ] [ 1 ] * phi [ 1 ] [ 1 ] [ 1 ] - phi [ 0 ] [ 1 ] [ 0 ] * phi [ 1 ] [ 0 ] [ 0 ] ;\n temp_im = phi [ 0 ] [ 0 ] [ 0 ] * phi [ 1 ] [ 1 ] [ 1 ] + phi [ 0 ] [ 0 ] [ 1 ] * phi [ 1 ] [ 1 ] [ 0 ] - phi [ 0 ] [ 1 ] [ 1 ] * phi [ 1 ] [ 0 ] [ 0 ] ;\n alpha1 [ k ] [ 0 ] = temp_real / dk ;\n alpha1 [ k ] [ 1 ] = temp_im / dk ;\n }\n if ( ! phi [ 1 ] [ 0 ] [ 0 ] ) {\n alpha0 [ k ] [ 0 ] = 0 ;\n alpha0 [ k ] [ 1 ] = 0 ;\n }\n else {\n float temp_real , temp_im ;\n temp_real = phi [ 0 ] [ 0 ] [ 0 ] + alpha1 [ k ] [ 0 ] * phi [ 1 ] [ 1 ] [ 0 ] + alpha1 [ k ] [ 1 ] * phi [ 1 ] [ 1 ] [ 1 ] ;\n temp_im = phi [ 0 ] [ 0 ] [ 1 ] + alpha1 [ k ] [ 1 ] * phi [ 1 ] [ 1 ] [ 0 ] - alpha1 [ k ] [ 0 ] * phi [ 1 ] [ 1 ] [ 1 ] ;\n alpha0 [ k ] [ 0 ] = - temp_real / phi [ 1 ] [ 0 ] [ 0 ] ;\n alpha0 [ k ] [ 1 ] = - temp_im / phi [ 1 ] [ 0 ] [ 0 ] ;\n }\n if ( alpha1 [ k ] [ 0 ] * alpha1 [ k ] [ 0 ] + alpha1 [ k ] [ 1 ] * alpha1 [ k ] [ 1 ] >= 16.0f || alpha0 [ k ] [ 0 ] * alpha0 [ k ] [ 0 ] + alpha0 [ k ] [ 1 ] * alpha0 [ k ] [ 1 ] >= 16.0f ) {\n alpha1 [ k ] [ 0 ] = 0 ;\n alpha1 [ k ] [ 1 ] = 0 ;\n alpha0 [ k ] [ 0 ] = 0 ;\n alpha0 [ k ] [ 1 ] = 0 ;\n }\n }\n }", "idx": 21832}
{"hash": -7117046864335130087, "project": "chrome", "size": 32, "label": 0, "functionSource": "static int calc_active_worst_quality_one_pass_cbr ( const VP9_COMP * cpi ) {\n const VP9_COMMON * const cm = & cpi -> common ;\n const RATE_CONTROL * rc = & cpi -> rc ;\n int64_t critical_level = rc -> optimal_buffer_level >> 2 ;\n int64_t buff_lvl_step = 0 ;\n int adjustment = 0 ;\n int active_worst_quality ;\n if ( cm -> frame_type == KEY_FRAME ) return rc -> worst_quality ;\n if ( cm -> current_video_frame > 1 ) active_worst_quality = MIN ( rc -> worst_quality , rc -> avg_frame_qindex [ INTER_FRAME ] * 5 / 4 ) ;\n else active_worst_quality = MIN ( rc -> worst_quality , rc -> avg_frame_qindex [ KEY_FRAME ] * 3 / 2 ) ;\n if ( rc -> buffer_level > rc -> optimal_buffer_level ) {\n int max_adjustment_down = active_worst_quality / 3 ;\n if ( max_adjustment_down ) {\n buff_lvl_step = ( ( rc -> maximum_buffer_size - rc -> optimal_buffer_level ) / max_adjustment_down ) ;\n if ( buff_lvl_step ) adjustment = ( int ) ( ( rc -> buffer_level - rc -> optimal_buffer_level ) / buff_lvl_step ) ;\n active_worst_quality -= adjustment ;\n }\n }\n else if ( rc -> buffer_level > critical_level ) {\n if ( critical_level ) {\n buff_lvl_step = ( rc -> optimal_buffer_level - critical_level ) ;\n if ( buff_lvl_step ) {\n adjustment = ( int ) ( ( rc -> worst_quality - rc -> avg_frame_qindex [ INTER_FRAME ] ) * ( rc -> optimal_buffer_level - rc -> buffer_level ) / buff_lvl_step ) ;\n }\n active_worst_quality = rc -> avg_frame_qindex [ INTER_FRAME ] + adjustment ;\n }\n }\n else {\n active_worst_quality = rc -> worst_quality ;\n }\n return active_worst_quality ;\n }", "idx": 21833}
{"hash": -8962831256613787672, "project": "debian", "size": 3, "label": 0, "functionSource": "static inline gboolean is_sysex_code ( guint8 code ) {\n return ( code == 0x04 || code == 0x05 || code == 0x06 || code == 0x07 ) ;\n }", "idx": 21834}
{"hash": 3935234056444097745, "project": "debian", "size": 25, "label": 0, "functionSource": "static int rtp_packetize_amr ( sout_stream_id_sys_t * id , block_t * in ) {\n int i_max = rtp_mtu ( id ) - 2 ;\n int i_count = ( in -> i_buffer + i_max - 1 ) / i_max ;\n uint8_t * p_data = in -> p_buffer ;\n int i_data = in -> i_buffer ;\n int i ;\n for ( i = 0 ;\n i < i_count ;\n i ++ ) {\n int i_payload = __MIN ( i_max , i_data ) ;\n block_t * out = block_Alloc ( 14 + i_payload ) ;\n rtp_packetize_common ( id , out , ( ( i == i_count - 1 ) ? 1 : 0 ) , ( in -> i_pts > VLC_TS_INVALID ? in -> i_pts : in -> i_dts ) ) ;\n out -> p_buffer [ 12 ] = 0xF0 ;\n out -> p_buffer [ 13 ] = p_data [ 0 ] & 0x7C ;\n memcpy ( & out -> p_buffer [ 14 ] , p_data + 1 , i_payload - 1 ) ;\n out -> i_buffer -- ;\n out -> i_dts = in -> i_dts + i * in -> i_length / i_count ;\n out -> i_length = in -> i_length / i_count ;\n rtp_packetize_send ( id , out ) ;\n p_data += i_payload ;\n i_data -= i_payload ;\n }\n block_Release ( in ) ;\n return VLC_SUCCESS ;\n }", "idx": 21835}
{"hash": -8638406710431929037, "project": "debian", "size": 3, "label": 0, "functionSource": "static int srec_sizeof_headers ( bfd * abfd ATTRIBUTE_UNUSED , struct bfd_link_info * info ATTRIBUTE_UNUSED ) {\n return 0 ;\n }", "idx": 21836}
{"hash": -4421762461659142174, "project": "debian", "size": 27, "label": 0, "functionSource": "static void xps_deobfuscate_font_resource ( xps_document * doc , xps_part * part ) {\n unsigned char buf [ 33 ] ;\n unsigned char key [ 16 ] ;\n char * p ;\n int i ;\n p = strrchr ( part -> name , '/' ) ;\n if ( ! p ) p = part -> name ;\n for ( i = 0 ;\n i < 32 && * p ;\n p ++ ) {\n if ( ishex ( * p ) ) buf [ i ++ ] = * p ;\n }\n buf [ i ] = 0 ;\n if ( i != 32 ) {\n fz_warn ( doc -> ctx , \"cannot extract GUID from obfuscated font part name\" ) ;\n return ;\n }\n for ( i = 0 ;\n i < 16 ;\n i ++ ) key [ i ] = unhex ( buf [ i * 2 + 0 ] ) * 16 + unhex ( buf [ i * 2 + 1 ] ) ;\n for ( i = 0 ;\n i < 16 ;\n i ++ ) {\n part -> data [ i ] ^= key [ 15 - i ] ;\n part -> data [ i + 16 ] ^= key [ 15 - i ] ;\n }\n }", "idx": 21837}
{"hash": 6336384260629386331, "project": "debian", "size": 4, "label": 0, "functionSource": "static void dissect_zcl_identify_identifyqueryrsp ( tvbuff_t * tvb , proto_tree * tree , guint * offset ) {\n proto_tree_add_item ( tree , hf_zbee_zcl_identify_identify_timeout , tvb , * offset , 2 , ENC_LITTLE_ENDIAN ) ;\n * offset += 2 ;\n }", "idx": 21838}
{"hash": -3740862514502467070, "project": "debian", "size": 28, "label": 0, "functionSource": "static void _dumpcffstrings ( FILE * file , struct pschars * strs ) {\n int i , len , offsize ;\n len = 1 ;\n for ( i = 0 ;\n i < strs -> next ;\n ++ i ) len += strs -> lens [ i ] ;\n putshort ( file , strs -> next ) ;\n if ( strs -> next != 0 ) {\n offsize = len <= 255 ? 1 : len <= 65535 ? 2 : len <= 0xffffff ? 3 : 4 ;\n putc ( offsize , file ) ;\n len = 1 ;\n for ( i = 0 ;\n i < strs -> next ;\n ++ i ) {\n dumpoffset ( file , offsize , len ) ;\n len += strs -> lens [ i ] ;\n }\n dumpoffset ( file , offsize , len ) ;\n for ( i = 0 ;\n i < strs -> next ;\n ++ i ) {\n uint8 * pt = strs -> values [ i ] , * end = pt + strs -> lens [ i ] ;\n while ( pt < end ) {\n putc ( * pt ++ , file ) ;\n }\n }\n }\n }", "idx": 21839}
{"hash": 4489017523191997023, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h225_GatewayInfo ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_GatewayInfo , GatewayInfo_sequence ) ;\n return offset ;\n }", "idx": 21840}
{"hash": 3035587999006680483, "project": "debian", "size": 19, "label": 0, "functionSource": "int dtls1_send_change_cipher_spec ( SSL * s , int a , int b ) {\n unsigned char * p ;\n if ( s -> state == a ) {\n p = ( unsigned char * ) s -> init_buf -> data ;\n * p ++ = SSL3_MT_CCS ;\n s -> d1 -> handshake_write_seq = s -> d1 -> next_handshake_write_seq ;\n s -> init_num = DTLS1_CCS_HEADER_LENGTH ;\n if ( s -> version == DTLS1_BAD_VER ) {\n s -> d1 -> next_handshake_write_seq ++ ;\n s2n ( s -> d1 -> handshake_write_seq , p ) ;\n s -> init_num += 2 ;\n }\n s -> init_off = 0 ;\n dtls1_set_message_header_int ( s , SSL3_MT_CCS , 0 , s -> d1 -> handshake_write_seq , 0 , 0 ) ;\n dtls1_buffer_message ( s , 1 ) ;\n s -> state = b ;\n }\n return ( dtls1_do_write ( s , SSL3_RT_CHANGE_CIPHER_SPEC ) ) ;\n }", "idx": 21841}
{"hash": -6580451576689962916, "project": "debian", "size": 189, "label": 1, "functionSource": "static guint32 parse_wbxml_tag ( proto_tree * tree , tvbuff_t * tvb , guint32 offset , guint32 str_tbl , guint8 * level , guint8 * codepage_stag , guint8 * codepage_attr ) {\n guint32 tvb_len = tvb_reported_length ( tvb ) ;\n guint32 off = offset ;\n guint32 len ;\n guint str_len ;\n guint32 ent ;\n guint32 idx ;\n guint8 peek ;\n guint32 tag_len ;\n guint8 tag_save_known = 0 ;\n guint8 tag_new_known = 0 ;\n const char * tag_save_literal ;\n const char * tag_new_literal ;\n char * tag_save_buf = NULL ;\n char * tag_new_buf = NULL ;\n guint8 parsing_tag_content = FALSE ;\n tag_save_literal = NULL ;\n DebugLog ( ( \"parse_wbxml_tag (level = %u, offset = %u)\\n\" , * level , offset ) ) ;\n while ( off < tvb_len ) {\n peek = tvb_get_guint8 ( tvb , off ) ;\n DebugLog ( ( \"STAG: (top of while) level = %3u, peek = 0x%02X, off = %u, tvb_len = %u\\n\" , * level , peek , off , tvb_len ) ) ;\n if ( ( peek & 0x3F ) < 4 ) switch ( peek ) {\n case 0x00 : * codepage_stag = tvb_get_guint8 ( tvb , off + 1 ) ;\n proto_tree_add_text ( tree , tvb , off , 2 , \" | Tag | T -->%3d \" \"| SWITCH_PAGE (Tag code page) \" \"|\" , * codepage_stag ) ;\n off += 2 ;\n break ;\n case 0x01 : if ( tag_save_known ) {\n proto_tree_add_text ( tree , tvb , off , 1 , \" %3d | Tag | T %3d \" \"| END (Known Tag 0x%02X) \" \"| %s</%s>\" , * level , * codepage_stag , tag_save_known , Indent ( * level ) , tag_save_literal ) ;\n }\n else {\n proto_tree_add_text ( tree , tvb , off , 1 , \" %3d | Tag | T %3d \" \"| END (Literal Tag) \" \"| %s</%s>\" , * level , * codepage_stag , Indent ( * level ) , tag_save_literal ? tag_save_literal : \"\" ) ;\n }\n ( * level ) -- ;\n off ++ ;\n DebugLog ( ( \"STAG: level = %u, Return: len = %u\\n\" , * level , off - offset ) ) ;\n return ( off - offset ) ;\n case 0x02 : ent = tvb_get_guintvar ( tvb , off + 1 , & len ) ;\n proto_tree_add_text ( tree , tvb , off , 1 + len , \" %3d | Tag | T %3d \" \"| ENTITY \" \"| %s'&#%u;\n'\" , * level , * codepage_stag , Indent ( * level ) , ent ) ;\n off += 1 + len ;\n break ;\n case 0x03 : len = tvb_strsize ( tvb , off + 1 ) ;\n proto_tree_add_text ( tree , tvb , off , 1 + len , \" %3d | Tag | T %3d \" \"| STR_I (Inline string) \" \"| %s\\'%s\\'\" , * level , * codepage_stag , Indent ( * level ) , tvb_format_text ( tvb , off + 1 , len - 1 ) ) ;\n off += 1 + len ;\n break ;\n case 0x40 : case 0x41 : case 0x42 : len = tvb_strsize ( tvb , off + 1 ) ;\n proto_tree_add_text ( tree , tvb , off , 1 + len , \" %3d | Tag | T %3d \" \"| EXT_I_%1x (Extension Token) \" \"| %s(Inline string extension: \\'%s\\')\" , * level , * codepage_stag , peek & 0x0f , Indent ( * level ) , tvb_format_text ( tvb , off + 1 , len - 1 ) ) ;\n off += 1 + len ;\n break ;\n case 0x43 : proto_tree_add_text ( tree , tvb , off , 1 , \" %3d | Tag | T %3d \" \"| PI (XML Processing Instruction) \" \"| %s<?xml\" , * level , * codepage_stag , Indent ( * level ) ) ;\n len = parse_wbxml_attribute_list ( tree , tvb , off , str_tbl , * level , codepage_attr ) ;\n off += len ;\n if ( off >= tvb_len ) {\n DebugLog ( ( \"STAG: level = %u, ThrowException: len = %u (short frame)\\n\" , * level , off - offset ) ) ;\n THROW ( ReportedBoundsError ) ;\n }\n proto_tree_add_text ( tree , tvb , off - 1 , 1 , \" %3d | Tag | T %3d \" \"| END (PI) \" \"| %s?>\" , * level , * codepage_stag , Indent ( * level ) ) ;\n break ;\n case 0x80 : case 0x81 : case 0x82 : idx = tvb_get_guintvar ( tvb , off + 1 , & len ) ;\n proto_tree_add_text ( tree , tvb , off , 1 + len , \" %3d | Tag | T %3d \" \"| EXT_T_%1x (Extension Token) \" \"| %s(Extension Token, integer value: %u)\" , * level , * codepage_stag , peek & 0x0f , Indent ( * level ) , idx ) ;\n off += 1 + len ;\n break ;\n case 0x83 : idx = tvb_get_guintvar ( tvb , off + 1 , & len ) ;\n str_len = tvb_strsize ( tvb , str_tbl + idx ) ;\n proto_tree_add_text ( tree , tvb , off , 1 + len , \" %3d | Tag | T %3d \" \"| STR_T (Tableref string) \" \"| %s\\'%s\\'\" , * level , * codepage_stag , Indent ( * level ) , tvb_format_text ( tvb , str_tbl + idx , str_len - 1 ) ) ;\n off += 1 + len ;\n break ;\n case 0xC0 : case 0xC1 : case 0xC2 : proto_tree_add_text ( tree , tvb , off , 1 , \" %3d | Tag | T %3d \" \"| EXT_%1x (Extension Token) \" \"| %s(Single-byte extension)\" , * level , * codepage_stag , peek & 0x0f , Indent ( * level ) ) ;\n off ++ ;\n break ;\n case 0xC3 : if ( tvb_get_guint8 ( tvb , 0 ) ) {\n idx = tvb_get_guintvar ( tvb , off + 1 , & len ) ;\n proto_tree_add_text ( tree , tvb , off , 1 + len + idx , \" %3d | Tag | T %3d \" \"| OPAQUE (Opaque data) \" \"| %s(%d bytes of opaque data)\" , * level , * codepage_stag , Indent ( * level ) , idx ) ;\n off += 1 + len + idx ;\n }\n else {\n proto_tree_add_text ( tree , tvb , off , 1 , \" %3d | Tag | T %3d \" \"| RESERVED_2 (Invalid Token!) \" \"| WBXML 1.0 parsing stops here.\" , * level , * codepage_stag ) ;\n off = tvb_len ;\n DebugLog ( ( \"STAG: level = %u, Return: len = %u\\n\" , * level , off - offset ) ) ;\n return ( off - offset ) ;\n }\n break ;\n }\n else {\n tag_len = 0 ;\n if ( ( peek & 0x3F ) == 4 ) {\n DebugLog ( ( \"STAG: LITERAL tag (peek = 0x%02X, off = %u)\" \" - TableRef follows!\\n\" , peek , off ) ) ;\n idx = tvb_get_guintvar ( tvb , off + 1 , & tag_len ) ;\n str_len = tvb_strsize ( tvb , str_tbl + idx ) ;\n tag_new_literal = ( const gchar * ) tvb_get_ptr ( tvb , str_tbl + idx , str_len ) ;\n tag_new_known = 0 ;\n }\n else {\n tag_new_known = peek & 0x3F ;\n tag_new_buf = wmem_strdup_printf ( wmem_packet_scope ( ) , \"Tag_0x%02X\" , tag_new_known ) ;\n tag_new_literal = tag_new_buf ;\n }\n if ( peek & 0x40 ) {\n if ( parsing_tag_content ) {\n DebugLog ( ( \"STAG: Tag in Tag - RECURSE! (off = %u)\\n\" , off ) ) ;\n ( * level ) ++ ;\n len = parse_wbxml_tag ( tree , tvb , off , str_tbl , level , codepage_stag , codepage_attr ) ;\n off += len ;\n }\n else {\n if ( ( peek & 0x3F ) == 4 ) {\n tag_save_literal = tag_new_literal ;\n tag_save_known = 0 ;\n }\n else {\n tag_save_known = tag_new_known ;\n tag_save_buf = wmem_strdup_printf ( wmem_packet_scope ( ) , \"Tag_0x%02X\" , tag_new_known ) ;\n tag_save_literal = tag_save_buf ;\n }\n if ( peek & 0x80 ) {\n if ( tag_new_known ) {\n proto_tree_add_text ( tree , tvb , off , 1 , \" %3d | Tag | T %3d \" \"| Known Tag 0x%02X (AC) \" \"| %s<%s\" , * level , * codepage_stag , tag_new_known , Indent ( * level ) , tag_new_literal ) ;\n off ++ ;\n }\n else {\n proto_tree_add_text ( tree , tvb , off , 1 , \" %3d | Tag | T %3d \" \"| LITERAL_AC (Literal tag) (AC) \" \"| %s<%s\" , * level , * codepage_stag , Indent ( * level ) , tag_new_literal ) ;\n off += 1 + tag_len ;\n }\n len = parse_wbxml_attribute_list ( tree , tvb , off , str_tbl , * level , codepage_attr ) ;\n off += len ;\n if ( off >= tvb_len ) {\n DebugLog ( ( \"STAG: level = %u, ThrowException: \" \"len = %u (short frame)\\n\" , * level , off - offset ) ) ;\n THROW ( ReportedBoundsError ) ;\n }\n proto_tree_add_text ( tree , tvb , off - 1 , 1 , \" %3d | Tag | T %3d \" \"| END (attribute list) \" \"| %s>\" , * level , * codepage_stag , Indent ( * level ) ) ;\n }\n else {\n if ( tag_new_known ) {\n proto_tree_add_text ( tree , tvb , off , 1 , \" %3d | Tag | T %3d \" \"| Known Tag 0x%02X (.C) \" \"| %s<%s>\" , * level , * codepage_stag , tag_new_known , Indent ( * level ) , tag_new_literal ) ;\n off ++ ;\n }\n else {\n proto_tree_add_text ( tree , tvb , off , 1 , \" %3d | Tag | T %3d \" \"| LITERAL_C (Literal Tag) (.C) \" \"| %s<%s>\" , * level , * codepage_stag , Indent ( * level ) , tag_new_literal ) ;\n off += 1 + tag_len ;\n }\n }\n parsing_tag_content = TRUE ;\n DebugLog ( ( \"Tag in Tag - No recursion this time! \" \"(off = %u)\\n\" , off ) ) ;\n }\n }\n else {\n DebugLog ( ( \"<Tag/> in Tag - No recursion! (off = %u)\\n\" , off ) ) ;\n ( * level ) ++ ;\n if ( peek & 0x80 ) {\n if ( tag_new_known ) {\n proto_tree_add_text ( tree , tvb , off , 1 , \" %3d | Tag | T %3d \" \"| Known Tag 0x%02X (A.) \" \"| %s<%s\" , * level , * codepage_stag , tag_new_known , Indent ( * level ) , tag_new_literal ) ;\n off ++ ;\n len = parse_wbxml_attribute_list ( tree , tvb , off , str_tbl , * level , codepage_attr ) ;\n off += len ;\n if ( off >= tvb_len ) {\n DebugLog ( ( \"STAG: level = %u, ThrowException: \" \"len = %u (short frame)\\n\" , * level , off - offset ) ) ;\n THROW ( ReportedBoundsError ) ;\n }\n proto_tree_add_text ( tree , tvb , off - 1 , 1 , \" %3d | Tag | T %3d \" \"| END (Known Tag) \" \"| %s/>\" , * level , * codepage_stag , Indent ( * level ) ) ;\n }\n else {\n proto_tree_add_text ( tree , tvb , off , 1 , \" %3d | Tag | T %3d \" \"| LITERAL_A (Literal Tag) (A.) \" \"| %s<%s\" , * level , * codepage_stag , Indent ( * level ) , tag_new_literal ) ;\n off += 1 + tag_len ;\n len = parse_wbxml_attribute_list ( tree , tvb , off , str_tbl , * level , codepage_attr ) ;\n off += len ;\n if ( off >= tvb_len ) {\n DebugLog ( ( \"STAG: level = %u, ThrowException: \" \"len = %u (short frame)\\n\" , * level , off - offset ) ) ;\n THROW ( ReportedBoundsError ) ;\n }\n proto_tree_add_text ( tree , tvb , off - 1 , 1 , \" %3d | Tag | T %3d \" \"| END (Literal Tag) \" \"| %s/>\" , * level , * codepage_stag , Indent ( * level ) ) ;\n }\n }\n else {\n if ( tag_new_known ) {\n proto_tree_add_text ( tree , tvb , off , 1 , \" %3d | Tag | T %3d \" \"| Known Tag 0x%02x (..) \" \"| %s<%s />\" , * level , * codepage_stag , tag_new_known , Indent ( * level ) , tag_new_literal ) ;\n off ++ ;\n }\n else {\n proto_tree_add_text ( tree , tvb , off , 1 , \" %3d | Tag | T %3d \" \"| LITERAL (Literal Tag) (..) \" \"| %s<%s />\" , * level , * codepage_stag , Indent ( * level ) , tag_new_literal ) ;\n off += 1 + tag_len ;\n }\n }\n ( * level ) -- ;\n }\n }\n }\n DebugLog ( ( \"STAG: level = %u, Return: len = %u (end of function body)\\n\" , * level , off - offset ) ) ;\n return ( off - offset ) ;\n }", "idx": 21842}
{"hash": 9176142195250515812, "project": "debian", "size": 13, "label": 0, "functionSource": "struct im_connection * purple_ic_by_pa ( PurpleAccount * pa ) {\n GSList * i ;\n struct purple_data * pd ;\n for ( i = purple_connections ;\n i ;\n i = i -> next ) {\n pd = ( ( struct im_connection * ) i -> data ) -> proto_data ;\n if ( pd -> account == pa ) {\n return i -> data ;\n }\n }\n return NULL ;\n }", "idx": 21843}
{"hash": -398565394354770780, "project": "debian", "size": 18, "label": 0, "functionSource": "static void ohci_detach ( USBPort * port1 ) {\n OHCIState * s = port1 -> opaque ;\n OHCIPort * port = & s -> rhport [ port1 -> index ] ;\n uint32_t old_state = port -> ctrl ;\n ohci_async_cancel_device ( s , port1 -> dev ) ;\n if ( port -> ctrl & OHCI_PORT_CCS ) {\n port -> ctrl &= ~ OHCI_PORT_CCS ;\n port -> ctrl |= OHCI_PORT_CSC ;\n }\n if ( port -> ctrl & OHCI_PORT_PES ) {\n port -> ctrl &= ~ OHCI_PORT_PES ;\n port -> ctrl |= OHCI_PORT_PESC ;\n }\n trace_usb_ohci_port_detach ( port1 -> index ) ;\n if ( old_state != port -> ctrl ) {\n ohci_set_interrupt ( s , OHCI_INTR_RHSC ) ;\n }\n }", "idx": 21844}
{"hash": 4180964683905830761, "project": "debian", "size": 3, "label": 0, "functionSource": "static int selinux_task_create ( unsigned long clone_flags ) {\n return current_has_perm ( current , PROCESS__FORK ) ;\n }", "idx": 21845}
{"hash": 1760449185745615462, "project": "debian", "size": 8, "label": 0, "functionSource": "const char * TSHttpHdrHostGet ( TSMBuffer bufp , TSMLoc obj , int * length ) {\n sdk_assert ( sdk_sanity_check_mbuffer ( bufp ) == TS_SUCCESS ) ;\n sdk_assert ( sdk_sanity_check_http_hdr_handle ( obj ) == TS_SUCCESS ) ;\n sdk_assert ( sdk_sanity_check_null_ptr ( ( void * ) length ) == TS_SUCCESS ) ;\n HTTPHdr h ;\n SET_HTTP_HDR ( h , bufp , obj ) ;\n return h . host_get ( length ) ;\n }", "idx": 21846}
{"hash": 1760449185745615462, "project": "debian", "size": 10, "label": 0, "functionSource": "TSReturnCode sdk_sanity_check_url_handle ( TSMLoc field ) {\n if ( field == TS_NULL_MLOC ) {\n return TS_ERROR ;\n }\n MIMEFieldSDKHandle * field_handle = ( MIMEFieldSDKHandle * ) field ;\n if ( field_handle -> m_type != HDR_HEAP_OBJ_URL ) {\n return TS_ERROR ;\n }\n return TS_SUCCESS ;\n }", "idx": 21847}
{"hash": 5611940141018433728, "project": "chrome", "size": 10, "label": 0, "functionSource": "static void write_delta_q ( struct vp9_write_bit_buffer * wb , int delta_q ) {\n if ( delta_q != 0 ) {\n vp9_wb_write_bit ( wb , 1 ) ;\n vp9_wb_write_literal ( wb , abs ( delta_q ) , 4 ) ;\n vp9_wb_write_bit ( wb , delta_q < 0 ) ;\n }\n else {\n vp9_wb_write_bit ( wb , 0 ) ;\n }\n }", "idx": 21848}
{"hash": -7076754245473579218, "project": "chrome", "size": 12, "label": 0, "functionSource": "static inline void evhttp_send ( struct evhttp_request * req , struct evbuffer * databuf ) {\n struct evhttp_connection * evcon = req -> evcon ;\n if ( evcon == NULL ) {\n evhttp_request_free ( req ) ;\n return ;\n }\n assert ( TAILQ_FIRST ( & evcon -> requests ) == req ) ;\n req -> userdone = 1 ;\n if ( databuf != NULL ) evbuffer_add_buffer ( req -> output_buffer , databuf ) ;\n evhttp_make_header ( evcon , req ) ;\n evhttp_write_buffer ( evcon , evhttp_send_done , NULL ) ;\n }", "idx": 21849}
{"hash": 561876472800374387, "project": "debian", "size": 302, "label": 0, "functionSource": "int ssl3_read_bytes ( SSL * s , int type , int * recvd_type , unsigned char * buf , int len , int peek ) {\n int al , i , j , ret ;\n unsigned int n , curr_rec , num_recs , read_bytes ;\n SSL3_RECORD * rr ;\n SSL3_BUFFER * rbuf ;\n void ( * cb ) ( const SSL * ssl , int type2 , int val ) = NULL ;\n rbuf = & s -> rlayer . rbuf ;\n if ( ! SSL3_BUFFER_is_initialised ( rbuf ) ) {\n if ( ! ssl3_setup_read_buffer ( s ) ) return ( - 1 ) ;\n }\n if ( ( type && ( type != SSL3_RT_APPLICATION_DATA ) && ( type != SSL3_RT_HANDSHAKE ) ) || ( peek && ( type != SSL3_RT_APPLICATION_DATA ) ) ) {\n SSLerr ( SSL_F_SSL3_READ_BYTES , ERR_R_INTERNAL_ERROR ) ;\n return - 1 ;\n }\n if ( ( type == SSL3_RT_HANDSHAKE ) && ( s -> rlayer . handshake_fragment_len > 0 ) ) {\n unsigned char * src = s -> rlayer . handshake_fragment ;\n unsigned char * dst = buf ;\n unsigned int k ;\n n = 0 ;\n while ( ( len > 0 ) && ( s -> rlayer . handshake_fragment_len > 0 ) ) {\n * dst ++ = * src ++ ;\n len -- ;\n s -> rlayer . handshake_fragment_len -- ;\n n ++ ;\n }\n for ( k = 0 ;\n k < s -> rlayer . handshake_fragment_len ;\n k ++ ) s -> rlayer . handshake_fragment [ k ] = * src ++ ;\n if ( recvd_type != NULL ) * recvd_type = SSL3_RT_HANDSHAKE ;\n return n ;\n }\n if ( ! ossl_statem_get_in_handshake ( s ) && SSL_in_init ( s ) ) {\n i = s -> handshake_func ( s ) ;\n if ( i < 0 ) return ( i ) ;\n if ( i == 0 ) {\n SSLerr ( SSL_F_SSL3_READ_BYTES , SSL_R_SSL_HANDSHAKE_FAILURE ) ;\n return ( - 1 ) ;\n }\n }\n start : s -> rwstate = SSL_NOTHING ;\n rr = s -> rlayer . rrec ;\n num_recs = RECORD_LAYER_get_numrpipes ( & s -> rlayer ) ;\n do {\n if ( num_recs == 0 ) {\n ret = ssl3_get_record ( s ) ;\n if ( ret <= 0 ) return ( ret ) ;\n num_recs = RECORD_LAYER_get_numrpipes ( & s -> rlayer ) ;\n if ( num_recs == 0 ) {\n al = SSL_AD_INTERNAL_ERROR ;\n SSLerr ( SSL_F_SSL3_READ_BYTES , ERR_R_INTERNAL_ERROR ) ;\n goto f_err ;\n }\n }\n for ( curr_rec = 0 ;\n curr_rec < num_recs && SSL3_RECORD_is_read ( & rr [ curr_rec ] ) ;\n curr_rec ++ ) ;\n if ( curr_rec == num_recs ) {\n RECORD_LAYER_set_numrpipes ( & s -> rlayer , 0 ) ;\n num_recs = 0 ;\n curr_rec = 0 ;\n }\n }\n while ( num_recs == 0 ) ;\n rr = & rr [ curr_rec ] ;\n if ( SSL3_RECORD_get_type ( rr ) != SSL3_RT_ALERT && SSL3_RECORD_get_length ( rr ) != 0 ) s -> rlayer . alert_count = 0 ;\n if ( s -> s3 -> change_cipher_spec && ( SSL3_RECORD_get_type ( rr ) != SSL3_RT_HANDSHAKE ) ) {\n al = SSL_AD_UNEXPECTED_MESSAGE ;\n SSLerr ( SSL_F_SSL3_READ_BYTES , SSL_R_DATA_BETWEEN_CCS_AND_FINISHED ) ;\n goto f_err ;\n }\n if ( s -> shutdown & SSL_RECEIVED_SHUTDOWN ) {\n SSL3_RECORD_set_length ( rr , 0 ) ;\n s -> rwstate = SSL_NOTHING ;\n return ( 0 ) ;\n }\n if ( type == SSL3_RECORD_get_type ( rr ) || ( SSL3_RECORD_get_type ( rr ) == SSL3_RT_CHANGE_CIPHER_SPEC && type == SSL3_RT_HANDSHAKE && recvd_type != NULL ) ) {\n if ( SSL_in_init ( s ) && ( type == SSL3_RT_APPLICATION_DATA ) && ( s -> enc_read_ctx == NULL ) ) {\n al = SSL_AD_UNEXPECTED_MESSAGE ;\n SSLerr ( SSL_F_SSL3_READ_BYTES , SSL_R_APP_DATA_IN_HANDSHAKE ) ;\n goto f_err ;\n }\n if ( type == SSL3_RT_HANDSHAKE && SSL3_RECORD_get_type ( rr ) == SSL3_RT_CHANGE_CIPHER_SPEC && s -> rlayer . handshake_fragment_len > 0 ) {\n al = SSL_AD_UNEXPECTED_MESSAGE ;\n SSLerr ( SSL_F_SSL3_READ_BYTES , SSL_R_CCS_RECEIVED_EARLY ) ;\n goto f_err ;\n }\n if ( recvd_type != NULL ) * recvd_type = SSL3_RECORD_get_type ( rr ) ;\n if ( len <= 0 ) return ( len ) ;\n read_bytes = 0 ;\n do {\n if ( ( unsigned int ) len - read_bytes > SSL3_RECORD_get_length ( rr ) ) n = SSL3_RECORD_get_length ( rr ) ;\n else n = ( unsigned int ) len - read_bytes ;\n memcpy ( buf , & ( rr -> data [ rr -> off ] ) , n ) ;\n buf += n ;\n if ( ! peek ) {\n SSL3_RECORD_sub_length ( rr , n ) ;\n SSL3_RECORD_add_off ( rr , n ) ;\n if ( SSL3_RECORD_get_length ( rr ) == 0 ) {\n s -> rlayer . rstate = SSL_ST_READ_HEADER ;\n SSL3_RECORD_set_off ( rr , 0 ) ;\n SSL3_RECORD_set_read ( rr ) ;\n }\n }\n if ( SSL3_RECORD_get_length ( rr ) == 0 || ( peek && n == SSL3_RECORD_get_length ( rr ) ) ) {\n curr_rec ++ ;\n rr ++ ;\n }\n read_bytes += n ;\n }\n while ( type == SSL3_RT_APPLICATION_DATA && curr_rec < num_recs && read_bytes < ( unsigned int ) len ) ;\n if ( read_bytes == 0 ) {\n goto start ;\n }\n if ( ! peek && curr_rec == num_recs && ( s -> mode & SSL_MODE_RELEASE_BUFFERS ) && SSL3_BUFFER_get_left ( rbuf ) == 0 ) ssl3_release_read_buffer ( s ) ;\n return read_bytes ;\n }\n if ( rr -> rec_version == SSL2_VERSION ) {\n al = SSL_AD_INTERNAL_ERROR ;\n SSLerr ( SSL_F_SSL3_READ_BYTES , ERR_R_INTERNAL_ERROR ) ;\n goto f_err ;\n }\n if ( s -> method -> version == TLS_ANY_VERSION && ( s -> server || rr -> type != SSL3_RT_ALERT ) ) {\n s -> version = rr -> rec_version ;\n al = SSL_AD_UNEXPECTED_MESSAGE ;\n SSLerr ( SSL_F_SSL3_READ_BYTES , SSL_R_UNEXPECTED_MESSAGE ) ;\n goto f_err ;\n }\n {\n unsigned int dest_maxlen = 0 ;\n unsigned char * dest = NULL ;\n unsigned int * dest_len = NULL ;\n if ( SSL3_RECORD_get_type ( rr ) == SSL3_RT_HANDSHAKE ) {\n dest_maxlen = sizeof s -> rlayer . handshake_fragment ;\n dest = s -> rlayer . handshake_fragment ;\n dest_len = & s -> rlayer . handshake_fragment_len ;\n }\n else if ( SSL3_RECORD_get_type ( rr ) == SSL3_RT_ALERT ) {\n dest_maxlen = sizeof s -> rlayer . alert_fragment ;\n dest = s -> rlayer . alert_fragment ;\n dest_len = & s -> rlayer . alert_fragment_len ;\n }\n if ( dest_maxlen > 0 ) {\n n = dest_maxlen - * dest_len ;\n if ( SSL3_RECORD_get_length ( rr ) < n ) n = SSL3_RECORD_get_length ( rr ) ;\n while ( n -- > 0 ) {\n dest [ ( * dest_len ) ++ ] = SSL3_RECORD_get_data ( rr ) [ SSL3_RECORD_get_off ( rr ) ] ;\n SSL3_RECORD_add_off ( rr , 1 ) ;\n SSL3_RECORD_add_length ( rr , - 1 ) ;\n }\n if ( * dest_len < dest_maxlen ) {\n SSL3_RECORD_set_read ( rr ) ;\n goto start ;\n }\n }\n }\n if ( ( ! s -> server ) && ( s -> rlayer . handshake_fragment_len >= 4 ) && ( s -> rlayer . handshake_fragment [ 0 ] == SSL3_MT_HELLO_REQUEST ) && ( s -> session != NULL ) && ( s -> session -> cipher != NULL ) ) {\n s -> rlayer . handshake_fragment_len = 0 ;\n if ( ( s -> rlayer . handshake_fragment [ 1 ] != 0 ) || ( s -> rlayer . handshake_fragment [ 2 ] != 0 ) || ( s -> rlayer . handshake_fragment [ 3 ] != 0 ) ) {\n al = SSL_AD_DECODE_ERROR ;\n SSLerr ( SSL_F_SSL3_READ_BYTES , SSL_R_BAD_HELLO_REQUEST ) ;\n goto f_err ;\n }\n if ( s -> msg_callback ) s -> msg_callback ( 0 , s -> version , SSL3_RT_HANDSHAKE , s -> rlayer . handshake_fragment , 4 , s , s -> msg_callback_arg ) ;\n if ( SSL_is_init_finished ( s ) && ! ( s -> s3 -> flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS ) && ! s -> s3 -> renegotiate ) {\n ssl3_renegotiate ( s ) ;\n if ( ssl3_renegotiate_check ( s ) ) {\n i = s -> handshake_func ( s ) ;\n if ( i < 0 ) return ( i ) ;\n if ( i == 0 ) {\n SSLerr ( SSL_F_SSL3_READ_BYTES , SSL_R_SSL_HANDSHAKE_FAILURE ) ;\n return ( - 1 ) ;\n }\n if ( ! ( s -> mode & SSL_MODE_AUTO_RETRY ) ) {\n if ( SSL3_BUFFER_get_left ( rbuf ) == 0 ) {\n BIO * bio ;\n s -> rwstate = SSL_READING ;\n bio = SSL_get_rbio ( s ) ;\n BIO_clear_retry_flags ( bio ) ;\n BIO_set_retry_read ( bio ) ;\n return ( - 1 ) ;\n }\n }\n }\n }\n goto start ;\n }\n if ( s -> server && SSL_is_init_finished ( s ) && ! s -> s3 -> send_connection_binding && ( s -> version > SSL3_VERSION ) && ( s -> rlayer . handshake_fragment_len >= 4 ) && ( s -> rlayer . handshake_fragment [ 0 ] == SSL3_MT_CLIENT_HELLO ) && ( s -> session != NULL ) && ( s -> session -> cipher != NULL ) && ! ( s -> ctx -> options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION ) ) {\n SSL3_RECORD_set_length ( rr , 0 ) ;\n SSL3_RECORD_set_read ( rr ) ;\n ssl3_send_alert ( s , SSL3_AL_WARNING , SSL_AD_NO_RENEGOTIATION ) ;\n goto start ;\n }\n if ( s -> rlayer . alert_fragment_len >= 2 ) {\n int alert_level = s -> rlayer . alert_fragment [ 0 ] ;\n int alert_descr = s -> rlayer . alert_fragment [ 1 ] ;\n s -> rlayer . alert_fragment_len = 0 ;\n if ( s -> msg_callback ) s -> msg_callback ( 0 , s -> version , SSL3_RT_ALERT , s -> rlayer . alert_fragment , 2 , s , s -> msg_callback_arg ) ;\n if ( s -> info_callback != NULL ) cb = s -> info_callback ;\n else if ( s -> ctx -> info_callback != NULL ) cb = s -> ctx -> info_callback ;\n if ( cb != NULL ) {\n j = ( alert_level << 8 ) | alert_descr ;\n cb ( s , SSL_CB_READ_ALERT , j ) ;\n }\n if ( alert_level == SSL3_AL_WARNING ) {\n s -> s3 -> warn_alert = alert_descr ;\n SSL3_RECORD_set_read ( rr ) ;\n s -> rlayer . alert_count ++ ;\n if ( s -> rlayer . alert_count == MAX_WARN_ALERT_COUNT ) {\n al = SSL_AD_UNEXPECTED_MESSAGE ;\n SSLerr ( SSL_F_SSL3_READ_BYTES , SSL_R_TOO_MANY_WARN_ALERTS ) ;\n goto f_err ;\n }\n if ( alert_descr == SSL_AD_CLOSE_NOTIFY ) {\n s -> shutdown |= SSL_RECEIVED_SHUTDOWN ;\n return ( 0 ) ;\n }\n else if ( alert_descr == SSL_AD_NO_RENEGOTIATION ) {\n al = SSL_AD_HANDSHAKE_FAILURE ;\n SSLerr ( SSL_F_SSL3_READ_BYTES , SSL_R_NO_RENEGOTIATION ) ;\n goto f_err ;\n }\n # ifdef SSL_AD_MISSING_SRP_USERNAME else if ( alert_descr == SSL_AD_MISSING_SRP_USERNAME ) return ( 0 ) ;\n # endif }\n else if ( alert_level == SSL3_AL_FATAL ) {\n char tmp [ 16 ] ;\n s -> rwstate = SSL_NOTHING ;\n s -> s3 -> fatal_alert = alert_descr ;\n SSLerr ( SSL_F_SSL3_READ_BYTES , SSL_AD_REASON_OFFSET + alert_descr ) ;\n BIO_snprintf ( tmp , sizeof tmp , \"%d\" , alert_descr ) ;\n ERR_add_error_data ( 2 , \"SSL alert number \" , tmp ) ;\n s -> shutdown |= SSL_RECEIVED_SHUTDOWN ;\n SSL3_RECORD_set_read ( rr ) ;\n SSL_CTX_remove_session ( s -> session_ctx , s -> session ) ;\n return ( 0 ) ;\n }\n else {\n al = SSL_AD_ILLEGAL_PARAMETER ;\n SSLerr ( SSL_F_SSL3_READ_BYTES , SSL_R_UNKNOWN_ALERT_TYPE ) ;\n goto f_err ;\n }\n goto start ;\n }\n if ( s -> shutdown & SSL_SENT_SHUTDOWN ) {\n s -> rwstate = SSL_NOTHING ;\n SSL3_RECORD_set_length ( rr , 0 ) ;\n SSL3_RECORD_set_read ( rr ) ;\n return ( 0 ) ;\n }\n if ( SSL3_RECORD_get_type ( rr ) == SSL3_RT_CHANGE_CIPHER_SPEC ) {\n al = SSL_AD_UNEXPECTED_MESSAGE ;\n SSLerr ( SSL_F_SSL3_READ_BYTES , SSL_R_CCS_RECEIVED_EARLY ) ;\n goto f_err ;\n }\n if ( ( s -> rlayer . handshake_fragment_len >= 4 ) && ! ossl_statem_get_in_handshake ( s ) ) {\n if ( SSL_is_init_finished ( s ) && ! ( s -> s3 -> flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS ) ) {\n ossl_statem_set_in_init ( s , 1 ) ;\n s -> renegotiate = 1 ;\n s -> new_session = 1 ;\n }\n i = s -> handshake_func ( s ) ;\n if ( i < 0 ) return ( i ) ;\n if ( i == 0 ) {\n SSLerr ( SSL_F_SSL3_READ_BYTES , SSL_R_SSL_HANDSHAKE_FAILURE ) ;\n return ( - 1 ) ;\n }\n if ( ! ( s -> mode & SSL_MODE_AUTO_RETRY ) ) {\n if ( SSL3_BUFFER_get_left ( rbuf ) == 0 ) {\n BIO * bio ;\n s -> rwstate = SSL_READING ;\n bio = SSL_get_rbio ( s ) ;\n BIO_clear_retry_flags ( bio ) ;\n BIO_set_retry_read ( bio ) ;\n return ( - 1 ) ;\n }\n }\n goto start ;\n }\n switch ( SSL3_RECORD_get_type ( rr ) ) {\n default : if ( s -> version >= TLS1_VERSION && s -> version <= TLS1_1_VERSION ) {\n SSL3_RECORD_set_length ( rr , 0 ) ;\n SSL3_RECORD_set_read ( rr ) ;\n goto start ;\n }\n al = SSL_AD_UNEXPECTED_MESSAGE ;\n SSLerr ( SSL_F_SSL3_READ_BYTES , SSL_R_UNEXPECTED_RECORD ) ;\n goto f_err ;\n case SSL3_RT_CHANGE_CIPHER_SPEC : case SSL3_RT_ALERT : case SSL3_RT_HANDSHAKE : al = SSL_AD_UNEXPECTED_MESSAGE ;\n SSLerr ( SSL_F_SSL3_READ_BYTES , ERR_R_INTERNAL_ERROR ) ;\n goto f_err ;\n case SSL3_RT_APPLICATION_DATA : if ( ossl_statem_app_data_allowed ( s ) ) {\n s -> s3 -> in_read_app_data = 2 ;\n return ( - 1 ) ;\n }\n else {\n al = SSL_AD_UNEXPECTED_MESSAGE ;\n SSLerr ( SSL_F_SSL3_READ_BYTES , SSL_R_UNEXPECTED_RECORD ) ;\n goto f_err ;\n }\n }\n f_err : ssl3_send_alert ( s , SSL3_AL_FATAL , al ) ;\n return ( - 1 ) ;\n }", "idx": 21850}
{"hash": -4239386405881995323, "project": "chrome", "size": 68, "label": 1, "functionSource": "int xmlHashAddEntry3 ( xmlHashTablePtr table , const xmlChar * name , const xmlChar * name2 , const xmlChar * name3 , void * userdata ) {\n unsigned long key , len = 0 ;\n xmlHashEntryPtr entry ;\n xmlHashEntryPtr insert ;\n if ( ( table == NULL ) || ( name == NULL ) ) return ( - 1 ) ;\n if ( table -> dict ) {\n if ( ! xmlDictOwns ( table -> dict , name ) ) {\n name = xmlDictLookup ( table -> dict , name , - 1 ) ;\n if ( name == NULL ) return ( - 1 ) ;\n }\n if ( ( name2 != NULL ) && ( ! xmlDictOwns ( table -> dict , name2 ) ) ) {\n name2 = xmlDictLookup ( table -> dict , name2 , - 1 ) ;\n if ( name2 == NULL ) return ( - 1 ) ;\n }\n if ( ( name3 != NULL ) && ( ! xmlDictOwns ( table -> dict , name3 ) ) ) {\n name3 = xmlDictLookup ( table -> dict , name3 , - 1 ) ;\n if ( name3 == NULL ) return ( - 1 ) ;\n }\n }\n key = xmlHashComputeKey ( table , name , name2 , name3 ) ;\n if ( table -> table [ key ] . valid == 0 ) {\n insert = NULL ;\n }\n else {\n if ( table -> dict ) {\n for ( insert = & ( table -> table [ key ] ) ;\n insert -> next != NULL ;\n insert = insert -> next ) {\n if ( ( insert -> name == name ) && ( insert -> name2 == name2 ) && ( insert -> name3 == name3 ) ) return ( - 1 ) ;\n len ++ ;\n }\n if ( ( insert -> name == name ) && ( insert -> name2 == name2 ) && ( insert -> name3 == name3 ) ) return ( - 1 ) ;\n }\n else {\n for ( insert = & ( table -> table [ key ] ) ;\n insert -> next != NULL ;\n insert = insert -> next ) {\n if ( ( xmlStrEqual ( insert -> name , name ) ) && ( xmlStrEqual ( insert -> name2 , name2 ) ) && ( xmlStrEqual ( insert -> name3 , name3 ) ) ) return ( - 1 ) ;\n len ++ ;\n }\n if ( ( xmlStrEqual ( insert -> name , name ) ) && ( xmlStrEqual ( insert -> name2 , name2 ) ) && ( xmlStrEqual ( insert -> name3 , name3 ) ) ) return ( - 1 ) ;\n }\n }\n if ( insert == NULL ) {\n entry = & ( table -> table [ key ] ) ;\n }\n else {\n entry = xmlMalloc ( sizeof ( xmlHashEntry ) ) ;\n if ( entry == NULL ) return ( - 1 ) ;\n }\n if ( table -> dict != NULL ) {\n entry -> name = ( xmlChar * ) name ;\n entry -> name2 = ( xmlChar * ) name2 ;\n entry -> name3 = ( xmlChar * ) name3 ;\n }\n else {\n entry -> name = xmlStrdup ( name ) ;\n entry -> name2 = xmlStrdup ( name2 ) ;\n entry -> name3 = xmlStrdup ( name3 ) ;\n }\n entry -> payload = userdata ;\n entry -> next = NULL ;\n entry -> valid = 1 ;\n if ( insert != NULL ) insert -> next = entry ;\n table -> nbElems ++ ;\n if ( len > MAX_HASH_LEN ) xmlHashGrow ( table , MAX_HASH_LEN * table -> size ) ;\n return ( 0 ) ;\n }", "idx": 21851}
{"hash": -4844249011537705593, "project": "chrome", "size": 9, "label": 0, "functionSource": "static void sbr_hf_g_filt_c ( float ( * Y ) [ 2 ] , const float ( * X_high ) [ 40 ] [ 2 ] , const float * g_filt , int m_max , intptr_t ixh ) {\n int m ;\n for ( m = 0 ;\n m < m_max ;\n m ++ ) {\n Y [ m ] [ 0 ] = X_high [ m ] [ ixh ] [ 0 ] * g_filt [ m ] ;\n Y [ m ] [ 1 ] = X_high [ m ] [ ixh ] [ 1 ] * g_filt [ m ] ;\n }\n }", "idx": 21852}
{"hash": -2591112946600337077, "project": "debian", "size": 10, "label": 0, "functionSource": "static int dot_product ( const int16_t * a , const int16_t * b , int length ) {\n int i , sum = 0 ;\n for ( i = 0 ;\n i < length ;\n i ++ ) {\n int prod = a [ i ] * b [ i ] ;\n sum = av_sat_dadd32 ( sum , prod ) ;\n }\n return sum ;\n }", "idx": 21853}
{"hash": -3203201540003795971, "project": "debian", "size": 3, "label": 0, "functionSource": "static inline uint64_t tswap64 ( uint64_t s ) {\n return s ;\n }", "idx": 21854}
{"hash": -2222463888415249941, "project": "chrome", "size": 12, "label": 0, "functionSource": "static void full_to_model_counts ( vp9_coeff_count_model * model_count , vp9_coeff_count * full_count ) {\n int i , j , k , l ;\n for ( i = 0 ;\n i < PLANE_TYPES ;\n ++ i ) for ( j = 0 ;\n j < REF_TYPES ;\n ++ j ) for ( k = 0 ;\n k < COEF_BANDS ;\n ++ k ) for ( l = 0 ;\n l < BAND_COEFF_CONTEXTS ( k ) ;\n ++ l ) full_to_model_count ( model_count [ i ] [ j ] [ k ] [ l ] , full_count [ i ] [ j ] [ k ] [ l ] ) ;\n }", "idx": 21855}
{"hash": 3599206110384554647, "project": "debian", "size": 27, "label": 0, "functionSource": "static ossl_inline t2 * sk_ ## t1 ## _set ( STACK_OF ( t1 ) * sk , int idx , t2 * ptr ) {\n return ( t2 * ) OPENSSL_sk_set ( ( OPENSSL_STACK * ) sk , idx , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _find ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_find ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _find_ex ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_find_ex ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline void sk_ ## t1 ## _sort ( STACK_OF ( t1 ) * sk ) {\n OPENSSL_sk_sort ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline int sk_ ## t1 ## _is_sorted ( const STACK_OF ( t1 ) * sk ) {\n return OPENSSL_sk_is_sorted ( ( const OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _dup ( const STACK_OF ( t1 ) * sk ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_dup ( ( const OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _deep_copy ( const STACK_OF ( t1 ) * sk , sk_ ## t1 ## _copyfunc copyfunc , sk_ ## t1 ## _freefunc freefunc ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_deep_copy ( ( const OPENSSL_STACK * ) sk , ( OPENSSL_sk_copyfunc ) copyfunc , ( OPENSSL_sk_freefunc ) freefunc ) ;\n }\n static ossl_inline sk_ ## t1 ## _compfunc sk_ ## t1 ## _set_cmp_func ( STACK_OF ( t1 ) * sk , sk_ ## t1 ## _compfunc compare ) {\n return ( sk_ ## t1 ## _compfunc ) OPENSSL_sk_set_cmp_func ( ( OPENSSL_STACK * ) sk , ( OPENSSL_sk_compfunc ) compare ) ;\n }\n # define DEFINE_SPECIAL_STACK_OF ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , t2 , t2 ) # define DEFINE_STACK_OF ( t ) SKM_DEFINE_STACK_OF ( t , t , t ) # define DEFINE_SPECIAL_STACK_OF_CONST ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , const t2 , t2 ) # define DEFINE_STACK_OF_CONST ( t ) SKM_DEFINE_STACK_OF ( t , const t , t ) typedef char * OPENSSL_STRING ;\n typedef const char * OPENSSL_CSTRING ;\n DEFINE_SPECIAL_STACK_OF ( OPENSSL_STRING , char )", "idx": 21856}
{"hash": 7295169435648525618, "project": "debian", "size": 12, "label": 0, "functionSource": "static void mdb_rtxn_snap ( Operation * op , ww_ctx * ww ) {\n if ( ww -> mcd ) {\n MDB_val key , data ;\n mdb_cursor_get ( ww -> mcd , & key , & data , MDB_GET_CURRENT ) ;\n memcpy ( & ww -> key , key . mv_data , sizeof ( ID ) ) ;\n ww -> data . mv_size = data . mv_size ;\n ww -> data . mv_data = op -> o_tmpalloc ( data . mv_size , op -> o_tmpmemctx ) ;\n memcpy ( ww -> data . mv_data , data . mv_data , data . mv_size ) ;\n }\n mdb_txn_reset ( ww -> txn ) ;\n ww -> flag = 1 ;\n }", "idx": 21857}
{"hash": -7455544248455991006, "project": "debian", "size": 6, "label": 0, "functionSource": "static bool host_tsx_blacklisted ( void ) {\n int family , model , stepping ;\n char vendor [ CPUID_VENDOR_SZ + 1 ] ;\n host_vendor_fms ( vendor , & family , & model , & stepping ) ;\n return ! strcmp ( vendor , CPUID_VENDOR_INTEL ) && ( family == 6 ) && ( ( model == 63 && stepping < 4 ) || model == 60 || model == 69 || model == 70 ) ;\n }", "idx": 21858}
{"hash": -3819889754140204145, "project": "debian", "size": 27, "label": 0, "functionSource": "static bool parse_basicConstraints ( chunk_t blob , int level0 , private_x509_cert_t * this ) {\n asn1_parser_t * parser ;\n chunk_t object ;\n int objectID ;\n bool isCA = FALSE ;\n bool success ;\n parser = asn1_parser_create ( basicConstraintsObjects , blob ) ;\n parser -> set_top_level ( parser , level0 ) ;\n while ( parser -> iterate ( parser , & objectID , & object ) ) {\n switch ( objectID ) {\n case BASIC_CONSTRAINTS_CA : isCA = object . len && * object . ptr ;\n DBG2 ( DBG_ASN , \" %s\" , isCA ? \"TRUE\" : \"FALSE\" ) ;\n if ( isCA ) {\n this -> flags |= X509_CA ;\n }\n break ;\n case BASIC_CONSTRAINTS_PATH_LEN : if ( isCA ) {\n this -> pathLenConstraint = parse_constraint ( object ) ;\n }\n break ;\n default : break ;\n }\n }\n success = parser -> success ( parser ) ;\n parser -> destroy ( parser ) ;\n return success ;\n }", "idx": 21859}
{"hash": 1223258652239369123, "project": "debian", "size": 13, "label": 1, "functionSource": "SPL_METHOD ( FilesystemIterator , key ) {\n spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n if ( zend_parse_parameters_none ( ) == FAILURE ) {\n return ;\n }\n if ( SPL_FILE_DIR_KEY ( intern , SPL_FILE_DIR_KEY_AS_FILENAME ) ) {\n RETURN_STRING ( intern -> u . dir . entry . d_name , 1 ) ;\n }\n else {\n spl_filesystem_object_get_file_name ( intern TSRMLS_CC ) ;\n RETURN_STRINGL ( intern -> file_name , intern -> file_name_len , 1 ) ;\n }\n }", "idx": 21860}
{"hash": -8919449269326401539, "project": "debian", "size": 38, "label": 0, "functionSource": "static gboolean dissect_class_svalidator_heur ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , void * data _U_ ) {\n unsigned char service , service_code , ioilen , segment ;\n cip_req_info_t * preq_info ;\n guint32 classid = 0 ;\n int offset = 0 ;\n service = tvb_get_guint8 ( tvb , offset ) ;\n service_code = service & 0x7F ;\n if ( service_code == SC_GET_ATT_ALL ) {\n if ( service & 0x80 ) {\n preq_info = ( cip_req_info_t * ) p_get_proto_data ( wmem_file_scope ( ) , pinfo , proto_cip , 0 ) ;\n if ( ( preq_info != NULL ) && ( preq_info -> dissector == dissector_get_uint_handle ( subdissector_class_table , CI_CLS_SAFETY_VALIDATOR ) ) ) {\n call_dissector ( preq_info -> dissector , tvb , pinfo , tree ) ;\n return TRUE ;\n }\n }\n else {\n ioilen = tvb_get_guint8 ( tvb , offset + 1 ) ;\n if ( ioilen > 1 ) {\n segment = tvb_get_guint8 ( tvb , offset + 2 ) ;\n if ( ( ( segment & CI_SEGMENT_TYPE_MASK ) == CI_LOGICAL_SEGMENT ) && ( ( segment & CI_LOGICAL_SEG_TYPE_MASK ) == CI_LOGICAL_SEG_CLASS_ID ) ) {\n switch ( segment & CI_LOGICAL_SEG_FORMAT_MASK ) {\n case CI_LOGICAL_SEG_8_BIT : classid = tvb_get_guint8 ( tvb , offset + 3 ) ;\n break ;\n case CI_LOGICAL_SEG_16_BIT : if ( ioilen >= 2 ) classid = tvb_get_letohs ( tvb , offset + 4 ) ;\n break ;\n case CI_LOGICAL_SEG_32_BIT : if ( ioilen >= 3 ) classid = tvb_get_letohl ( tvb , offset + 4 ) ;\n break ;\n }\n }\n }\n if ( classid == CI_CLS_SAFETY_VALIDATOR ) {\n call_dissector ( cip_class_s_validator_handle , tvb , pinfo , tree ) ;\n return TRUE ;\n }\n }\n }\n return FALSE ;\n }", "idx": 21861}
{"hash": -46053003459728034, "project": "chrome", "size": 66, "label": 0, "functionSource": "void compute_curve_gamma_table_type_parametric ( float gamma_table [ 256 ] , float parameter [ 7 ] , int count ) {\n size_t X ;\n float interval ;\n float a , b , c , e , f ;\n float y = parameter [ 0 ] ;\n if ( count == 0 ) {\n a = 1 ;\n b = 0 ;\n c = 0 ;\n e = 0 ;\n f = 0 ;\n interval = - INFINITY ;\n }\n else if ( count == 1 ) {\n a = parameter [ 1 ] ;\n b = parameter [ 2 ] ;\n c = 0 ;\n e = 0 ;\n f = 0 ;\n interval = - 1 * parameter [ 2 ] / parameter [ 1 ] ;\n }\n else if ( count == 2 ) {\n a = parameter [ 1 ] ;\n b = parameter [ 2 ] ;\n c = 0 ;\n e = parameter [ 3 ] ;\n f = parameter [ 3 ] ;\n interval = - 1 * parameter [ 2 ] / parameter [ 1 ] ;\n }\n else if ( count == 3 ) {\n a = parameter [ 1 ] ;\n b = parameter [ 2 ] ;\n c = parameter [ 3 ] ;\n e = - c ;\n f = 0 ;\n interval = parameter [ 4 ] ;\n }\n else if ( count == 4 ) {\n a = parameter [ 1 ] ;\n b = parameter [ 2 ] ;\n c = parameter [ 3 ] ;\n e = parameter [ 5 ] - c ;\n f = parameter [ 6 ] ;\n interval = parameter [ 4 ] ;\n }\n else {\n assert ( 0 && \"invalid parametric function type.\" ) ;\n a = 1 ;\n b = 0 ;\n c = 0 ;\n e = 0 ;\n f = 0 ;\n interval = - INFINITY ;\n }\n for ( X = 0 ;\n X < 256 ;\n X ++ ) {\n float x = X / 255.0 ;\n if ( x >= interval ) {\n gamma_table [ X ] = clamp_float ( powf ( a * x + b , y ) + ( c + e ) ) ;\n }\n else {\n gamma_table [ X ] = clamp_float ( c * x + f ) ;\n }\n }\n }", "idx": 21862}
{"hash": 369115599810341094, "project": "debian", "size": 20, "label": 0, "functionSource": "static void vga_draw_line8 ( VGACommonState * vga , uint8_t * d , uint32_t addr , int width ) {\n uint32_t * palette ;\n int x ;\n palette = vga -> last_palette ;\n width >>= 3 ;\n for ( x = 0 ;\n x < width ;\n x ++ ) {\n ( ( uint32_t * ) d ) [ 0 ] = palette [ vga_read_byte ( vga , addr + 0 ) ] ;\n ( ( uint32_t * ) d ) [ 1 ] = palette [ vga_read_byte ( vga , addr + 1 ) ] ;\n ( ( uint32_t * ) d ) [ 2 ] = palette [ vga_read_byte ( vga , addr + 2 ) ] ;\n ( ( uint32_t * ) d ) [ 3 ] = palette [ vga_read_byte ( vga , addr + 3 ) ] ;\n ( ( uint32_t * ) d ) [ 4 ] = palette [ vga_read_byte ( vga , addr + 4 ) ] ;\n ( ( uint32_t * ) d ) [ 5 ] = palette [ vga_read_byte ( vga , addr + 5 ) ] ;\n ( ( uint32_t * ) d ) [ 6 ] = palette [ vga_read_byte ( vga , addr + 6 ) ] ;\n ( ( uint32_t * ) d ) [ 7 ] = palette [ vga_read_byte ( vga , addr + 7 ) ] ;\n d += 32 ;\n addr += 8 ;\n }\n }", "idx": 21863}
{"hash": 1760449185745615462, "project": "debian", "size": 5, "label": 0, "functionSource": "void TSHttpTxnConnectTimeoutSet ( TSHttpTxn txnp , int timeout ) {\n sdk_assert ( sdk_sanity_check_txn ( txnp ) == TS_SUCCESS ) ;\n HttpTransact : : State * s = & ( ( ( HttpSM * ) txnp ) -> t_state ) ;\n s -> api_txn_connect_timeout_value = timeout ;\n }", "idx": 21864}
{"hash": -8933711118846965366, "project": "debian", "size": 9, "label": 0, "functionSource": "static void cirrus_linear_bitblt_write ( void * opaque , hwaddr addr , uint64_t val , unsigned size ) {\n CirrusVGAState * s = opaque ;\n if ( s -> cirrus_srcptr != s -> cirrus_srcptr_end ) {\n * s -> cirrus_srcptr ++ = ( uint8_t ) val ;\n if ( s -> cirrus_srcptr >= s -> cirrus_srcptr_end ) {\n cirrus_bitblt_cputovideo_next ( s ) ;\n }\n }\n }", "idx": 21865}
{"hash": 7039307292471244756, "project": "debian", "size": 11, "label": 0, "functionSource": "static guint16 de_tp_epc_ue_tl_c_setup ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len _U_ , gchar * add_string _U_ , int string_len _U_ ) {\n guint32 curr_offset ;\n curr_offset = offset ;\n proto_tree_add_bits_item ( tree , hf_gsm_a_dtap_epc_ue_tl_c_mbsfn_area_id , tvb , curr_offset << 3 , 8 , ENC_BIG_ENDIAN ) ;\n curr_offset ++ ;\n proto_tree_add_bits_item ( tree , hf_gsm_a_dtap_epc_ue_tl_c_mch_id , tvb , ( curr_offset << 3 ) + 4 , 4 , ENC_BIG_ENDIAN ) ;\n curr_offset ++ ;\n proto_tree_add_bits_item ( tree , hf_gsm_a_dtap_epc_ue_tl_c_lcid , tvb , ( curr_offset << 3 ) + 3 , 5 , ENC_BIG_ENDIAN ) ;\n curr_offset ++ ;\n return ( curr_offset - offset ) ;\n }", "idx": 21866}
{"hash": 7092216800726729686, "project": "debian", "size": 10, "label": 0, "functionSource": "static int dissect_h245_OLC_fw_h223_params ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 185 \"../../asn1/h245/h245.cnf\" h223_fw_lc_params = wmem_new ( wmem_file_scope ( ) , h223_lc_params ) ;\n h223_fw_lc_params -> al_type = al_nonStandard ;\n h223_fw_lc_params -> al_params = NULL ;\n h223_fw_lc_params -> segmentable = 0 ;\n h223_fw_lc_params -> subdissector = NULL ;\n h223_lc_params_temp = h223_fw_lc_params ;\n offset = dissect_h245_H223LogicalChannelParameters ( tvb , offset , actx , tree , hf_index ) ;\n return offset ;\n }", "idx": 21867}
{"hash": -910422676404244037, "project": "debian", "size": 7, "label": 0, "functionSource": "static inline int loco_predict ( uint8_t * data , int stride , int step ) {\n int a , b , c ;\n a = data [ - stride ] ;\n b = data [ - step ] ;\n c = data [ - stride - step ] ;\n return mid_pred ( a , a + b - c , b ) ;\n }", "idx": 21868}
{"hash": -1111775978048960297, "project": "chrome", "size": 13, "label": 0, "functionSource": "TEST_F ( BrowsingDataRemoverImplTest , RemoveChannelIDsForServerIdentifiers ) {\n RemoveChannelIDTester tester ( GetBrowserContext ( ) ) ;\n tester . AddChannelID ( kTestRegisterableDomain1 ) ;\n tester . AddChannelID ( kTestRegisterableDomain3 ) ;\n EXPECT_EQ ( 2 , tester . ChannelIDCount ( ) ) ;\n std : : unique_ptr < BrowsingDataFilterBuilder > filter_builder ( BrowsingDataFilterBuilder : : Create ( BrowsingDataFilterBuilder : : WHITELIST ) ) ;\n filter_builder -> AddRegisterableDomain ( kTestRegisterableDomain1 ) ;\n BlockUntilOriginDataRemoved ( base : : Time ( ) , base : : Time : : Max ( ) , BrowsingDataRemover : : REMOVE_CHANNEL_IDS , std : : move ( filter_builder ) ) ;\n EXPECT_EQ ( 1 , tester . ChannelIDCount ( ) ) ;\n net : : ChannelIDStore : : ChannelIDList channel_ids ;\n tester . GetChannelIDList ( & channel_ids ) ;\n EXPECT_EQ ( kTestRegisterableDomain3 , channel_ids . front ( ) . server_identifier ( ) ) ;\n }", "idx": 21869}
{"hash": 1208165234047591297, "project": "debian", "size": 13, "label": 0, "functionSource": "void parseNodeClassMask ( proto_tree * tree , tvbuff_t * tvb , packet_info * pinfo _U_ , gint * pOffset ) {\n static const int * nodeclass_mask [ ] = {\n & hf_opcua_nodeClassMask_object , & hf_opcua_nodeClassMask_variable , & hf_opcua_nodeClassMask_method , & hf_opcua_nodeClassMask_objecttype , & hf_opcua_nodeClassMask_variabletype , & hf_opcua_nodeClassMask_referencetype , & hf_opcua_nodeClassMask_datatype , & hf_opcua_nodeClassMask_view , NULL }\n ;\n guint8 NodeClassMask = tvb_get_guint8 ( tvb , * pOffset ) ;\n if ( NodeClassMask == NODECLASSMASK_ALL ) {\n proto_tree_add_item ( tree , hf_opcua_nodeClassMask_all , tvb , * pOffset , 4 , ENC_LITTLE_ENDIAN ) ;\n }\n else {\n proto_tree_add_bitmask ( tree , tvb , * pOffset , hf_opcua_nodeClassMask , ett_opcua_nodeClassMask , nodeclass_mask , ENC_LITTLE_ENDIAN ) ;\n }\n * pOffset += 4 ;\n }", "idx": 21870}
{"hash": -5493081488206619677, "project": "debian", "size": 7, "label": 0, "functionSource": "static const char * cmd_server_signature ( cmd_parms * cmd , void * _dcfg , const char * p1 ) {\n if ( cmd -> server -> is_virtual ) {\n return \"ModSecurity: SecServerSignature not allowed in VirtualHost\" ;\n }\n new_server_signature = ( char * ) p1 ;\n return NULL ;\n }", "idx": 21871}
{"hash": 155037296040076635, "project": "debian", "size": 112, "label": 0, "functionSource": "hidden_proto ( _nss_dns_gethostbyaddr2_r ) enum nss_status _nss_dns_gethostbyaddr2_r ( const void * addr , socklen_t len , int af , struct hostent * result , char * buffer , size_t buflen , int * errnop , int * h_errnop , int32_t * ttlp ) {\n static const u_char mapped [ ] = {\n 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0xff , 0xff }\n ;\n static const u_char tunnelled [ ] = {\n 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 }\n ;\n static const u_char v6local [ ] = {\n 0 , 0 , 0 , 1 }\n ;\n const u_char * uaddr = ( const u_char * ) addr ;\n struct host_data {\n char * aliases [ MAX_NR_ALIASES ] ;\n unsigned char host_addr [ 16 ] ;\n char * h_addr_ptrs [ MAX_NR_ADDRS + 1 ] ;\n char linebuffer [ 0 ] ;\n }\n * host_data = ( struct host_data * ) buffer ;\n union {\n querybuf * buf ;\n u_char * ptr ;\n }\n host_buffer ;\n querybuf * orig_host_buffer ;\n char qbuf [ MAXDNAME + 1 ] , * qp = NULL ;\n size_t size ;\n int n , status ;\n int olderr = errno ;\n uintptr_t pad = - ( uintptr_t ) buffer % __alignof__ ( struct host_data ) ;\n buffer += pad ;\n buflen = buflen > pad ? buflen - pad : 0 ;\n if ( __glibc_unlikely ( buflen < sizeof ( struct host_data ) ) ) {\n * errnop = ERANGE ;\n * h_errnop = NETDB_INTERNAL ;\n return NSS_STATUS_TRYAGAIN ;\n }\n host_data = ( struct host_data * ) buffer ;\n if ( __res_maybe_init ( & _res , 0 ) == - 1 ) return NSS_STATUS_UNAVAIL ;\n if ( af == AF_INET6 && len == IN6ADDRSZ && ( memcmp ( uaddr , mapped , sizeof mapped ) == 0 || ( memcmp ( uaddr , tunnelled , sizeof tunnelled ) == 0 && memcmp ( & uaddr [ sizeof tunnelled ] , v6local , sizeof v6local ) ) ) ) {\n addr += sizeof mapped ;\n uaddr += sizeof mapped ;\n af = AF_INET ;\n len = INADDRSZ ;\n }\n switch ( af ) {\n case AF_INET : size = INADDRSZ ;\n break ;\n case AF_INET6 : size = IN6ADDRSZ ;\n break ;\n default : * errnop = EAFNOSUPPORT ;\n * h_errnop = NETDB_INTERNAL ;\n return NSS_STATUS_UNAVAIL ;\n }\n if ( size > len ) {\n * errnop = EAFNOSUPPORT ;\n * h_errnop = NETDB_INTERNAL ;\n return NSS_STATUS_UNAVAIL ;\n }\n host_buffer . buf = orig_host_buffer = ( querybuf * ) alloca ( 1024 ) ;\n switch ( af ) {\n case AF_INET : sprintf ( qbuf , \"%u.%u.%u.%u.in-addr.arpa\" , ( uaddr [ 3 ] & 0xff ) , ( uaddr [ 2 ] & 0xff ) , ( uaddr [ 1 ] & 0xff ) , ( uaddr [ 0 ] & 0xff ) ) ;\n break ;\n case AF_INET6 : if ( __glibc_unlikely ( _res . options & RES_USEBSTRING ) ) {\n qp = stpcpy ( qbuf , \"\\\\[x\" ) ;\n for ( n = 0 ;\n n < IN6ADDRSZ ;\n ++ n ) qp += sprintf ( qp , \"%02hhx\" , uaddr [ n ] ) ;\n strcpy ( qp , \"].ip6.arpa\" ) ;\n n = __libc_res_nquery ( & _res , qbuf , C_IN , T_PTR , host_buffer . buf -> buf , 1024 , & host_buffer . ptr , NULL , NULL , NULL , NULL ) ;\n if ( n >= 0 ) goto got_it_already ;\n }\n qp = qbuf ;\n for ( n = IN6ADDRSZ - 1 ;\n n >= 0 ;\n n -- ) {\n static const char nibblechar [ 16 ] = \"0123456789abcdef\" ;\n * qp ++ = nibblechar [ uaddr [ n ] & 0xf ] ;\n * qp ++ = '.' ;\n * qp ++ = nibblechar [ ( uaddr [ n ] >> 4 ) & 0xf ] ;\n * qp ++ = '.' ;\n }\n strcpy ( qp , \"ip6.arpa\" ) ;\n break ;\n default : break ;\n }\n n = __libc_res_nquery ( & _res , qbuf , C_IN , T_PTR , host_buffer . buf -> buf , 1024 , & host_buffer . ptr , NULL , NULL , NULL , NULL ) ;\n if ( n < 0 && af == AF_INET6 && ( _res . options & RES_NOIP6DOTINT ) == 0 ) {\n strcpy ( qp , \"ip6.int\" ) ;\n n = __libc_res_nquery ( & _res , qbuf , C_IN , T_PTR , host_buffer . buf -> buf , host_buffer . buf != orig_host_buffer ? MAXPACKET : 1024 , & host_buffer . ptr , NULL , NULL , NULL , NULL ) ;\n }\n if ( n < 0 ) {\n * h_errnop = h_errno ;\n __set_errno ( olderr ) ;\n if ( host_buffer . buf != orig_host_buffer ) free ( host_buffer . buf ) ;\n return errno == ECONNREFUSED ? NSS_STATUS_UNAVAIL : NSS_STATUS_NOTFOUND ;\n }\n got_it_already : status = getanswer_r ( host_buffer . buf , n , qbuf , T_PTR , result , buffer , buflen , errnop , h_errnop , 0 , ttlp , NULL ) ;\n if ( host_buffer . buf != orig_host_buffer ) free ( host_buffer . buf ) ;\n if ( status != NSS_STATUS_SUCCESS ) return status ;\n # ifdef SUNSECURITY This is not implemented because it is not possible to use the current source from bind in a multi - threaded program . # endif result -> h_addrtype = af ;\n result -> h_length = len ;\n memcpy ( host_data -> host_addr , addr , len ) ;\n host_data -> h_addr_ptrs [ 0 ] = ( char * ) host_data -> host_addr ;\n host_data -> h_addr_ptrs [ 1 ] = NULL ;\n # if 0 if ( af == AF_INET && ( _res . options & RES_USE_INET6 ) ) {\n map_v4v6_address ( ( char * ) host_data -> host_addr , ( char * ) host_data -> host_addr ) ;\n result -> h_addrtype = AF_INET6 ;\n result -> h_length = IN6ADDRSZ ;\n }\n # endif * h_errnop = NETDB_SUCCESS ;\n return NSS_STATUS_SUCCESS ;\n }", "idx": 21872}
{"hash": 8415334249344417068, "project": "debian", "size": 151, "label": 0, "functionSource": "static int dissect_u3v ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , void * data ) {\n gint offset = 0 ;\n proto_tree * u3v_tree = NULL , * ccd_tree_flag , * u3v_telegram_tree = NULL , * ccd_tree = NULL ;\n gint data_length = 0 ;\n gint req_id = 0 ;\n gint command_id = - 1 ;\n gint status = 0 ;\n guint prefix = 0 ;\n proto_item * ti = NULL ;\n proto_item * item = NULL ;\n const char * command_string ;\n usb_conv_info_t * usb_conv_info ;\n gint stream_detected = FALSE ;\n gint control_detected = FALSE ;\n u3v_conv_info_t * u3v_conv_info = NULL ;\n gencp_transaction_t * gencp_trans = NULL ;\n usb_conv_info = ( usb_conv_info_t * ) data ;\n u3v_conv_info = ( u3v_conv_info_t * ) usb_conv_info -> class_data ;\n if ( ! u3v_conv_info ) {\n u3v_conv_info = wmem_new0 ( wmem_file_scope ( ) , u3v_conv_info_t ) ;\n usb_conv_info -> class_data = u3v_conv_info ;\n usb_conv_info -> class_data_type = USB_CONV_U3V ;\n }\n else if ( usb_conv_info -> class_data_type != USB_CONV_U3V ) {\n return 0 ;\n }\n prefix = tvb_get_letohl ( tvb , 0 ) ;\n if ( ( tvb_reported_length ( tvb ) >= 4 ) && ( ( U3V_CONTROL_PREFIX == prefix ) || ( U3V_EVENT_PREFIX == prefix ) ) ) {\n control_detected = TRUE ;\n }\n if ( ( ( tvb_reported_length ( tvb ) >= 4 ) && ( ( U3V_STREAM_LEADER_PREFIX == prefix ) || ( U3V_STREAM_TRAILER_PREFIX == prefix ) ) ) || ( usb_conv_info -> endpoint == u3v_conv_info -> ep_stream ) ) {\n stream_detected = TRUE ;\n }\n if ( control_detected || stream_detected ) {\n if ( usb_conv_info -> interfaceClass == IF_CLASS_UNKNOWN && usb_conv_info -> interfaceSubclass == IF_SUBCLASS_UNKNOWN ) {\n usb_conv_info -> interfaceClass = IF_CLASS_MISCELLANEOUS ;\n usb_conv_info -> interfaceSubclass = IF_SUBCLASS_MISC_U3V ;\n }\n }\n if ( control_detected ) {\n col_set_str ( pinfo -> cinfo , COL_PROTOCOL , \"U3V\" ) ;\n col_clear ( pinfo -> cinfo , COL_INFO ) ;\n ti = proto_tree_add_item ( tree , proto_u3v , tvb , offset , - 1 , ENC_NA ) ;\n u3v_tree = proto_item_add_subtree ( ti , ett_u3v ) ;\n prefix = tvb_get_letohl ( tvb , offset ) ;\n command_id = tvb_get_letohs ( tvb , offset + 6 ) ;\n if ( ( prefix == U3V_CONTROL_PREFIX || prefix == U3V_EVENT_PREFIX ) && ( ( command_id % 2 ) == 0 ) ) {\n command_string = val_to_str ( command_id , command_names , \"Unknown Command (0x%x)\" ) ;\n item = proto_tree_add_item ( u3v_tree , hf_u3v_ccd_cmd , tvb , offset , 8 , ENC_NA ) ;\n proto_item_append_text ( item , \": %s\" , command_string ) ;\n ccd_tree = proto_item_add_subtree ( item , ett_u3v_cmd ) ;\n proto_tree_add_item ( ccd_tree , hf_u3v_gencp_prefix , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n item = proto_tree_add_item ( ccd_tree , hf_u3v_flag , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n ccd_tree_flag = proto_item_add_subtree ( item , ett_u3v_flags ) ;\n proto_tree_add_item ( ccd_tree_flag , hf_u3v_acknowledge_required_flag , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \"> %s \" , command_string ) ;\n }\n else if ( prefix == U3V_CONTROL_PREFIX && ( ( command_id % 2 ) == 1 ) ) {\n command_string = val_to_str ( command_id , command_names , \"Unknown Acknowledge (0x%x)\" ) ;\n item = proto_tree_add_item ( u3v_tree , hf_u3v_ccd_ack , tvb , offset , 8 , ENC_NA ) ;\n proto_item_append_text ( item , \": %s\" , command_string ) ;\n ccd_tree = proto_item_add_subtree ( item , ett_u3v_ack ) ;\n proto_tree_add_item ( ccd_tree , hf_u3v_gencp_prefix , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n proto_tree_add_item ( ccd_tree , hf_u3v_status , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n status = tvb_get_letohs ( tvb , offset ) ;\n offset += 2 ;\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \"< %s %s\" , command_string , val_to_str ( status , status_names_short , \"Unknown status (0x%04X)\" ) ) ;\n }\n else {\n return 0 ;\n }\n proto_tree_add_item ( ccd_tree , hf_u3v_command_id , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( ccd_tree , hf_u3v_length , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n data_length = tvb_get_letohs ( tvb , offset ) ;\n offset += 2 ;\n proto_tree_add_item ( ccd_tree , hf_u3v_request_id , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n req_id = tvb_get_letohs ( tvb , offset ) ;\n offset += 2 ;\n u3v_telegram_tree = proto_item_add_subtree ( u3v_tree , ett_u3v ) ;\n if ( ! PINFO_FD_VISITED ( pinfo ) ) {\n if ( ( command_id % 2 ) == 0 ) {\n gencp_trans = wmem_new ( wmem_file_scope ( ) , gencp_transaction_t ) ;\n gencp_trans -> cmd_frame = pinfo -> fd -> num ;\n gencp_trans -> ack_frame = 0 ;\n gencp_trans -> cmd_time = pinfo -> fd -> abs_ts ;\n p_add_proto_data ( wmem_file_scope ( ) , pinfo , proto_u3v , req_id , gencp_trans ) ;\n u3v_conv_info -> trans_info = gencp_trans ;\n }\n else {\n gencp_trans = u3v_conv_info -> trans_info ;\n if ( gencp_trans ) {\n gencp_trans -> ack_frame = pinfo -> fd -> num ;\n p_add_proto_data ( wmem_file_scope ( ) , pinfo , proto_u3v , req_id , gencp_trans ) ;\n }\n }\n }\n else {\n gencp_trans = ( gencp_transaction_t * ) p_get_proto_data ( wmem_file_scope ( ) , pinfo , proto_u3v , req_id ) ;\n }\n if ( ! gencp_trans ) {\n gencp_trans = wmem_new ( wmem_packet_scope ( ) , gencp_transaction_t ) ;\n gencp_trans -> cmd_frame = 0 ;\n gencp_trans -> ack_frame = 0 ;\n gencp_trans -> cmd_time = pinfo -> fd -> abs_ts ;\n }\n switch ( command_id ) {\n case U3V_READMEM_CMD : dissect_u3v_read_mem_cmd ( u3v_telegram_tree , tvb , pinfo , offset , data_length , u3v_conv_info , gencp_trans ) ;\n break ;\n case U3V_WRITEMEM_CMD : dissect_u3v_write_mem_cmd ( u3v_telegram_tree , tvb , pinfo , offset , data_length , u3v_conv_info , gencp_trans ) ;\n break ;\n case U3V_EVENT_CMD : dissect_u3v_event_cmd ( u3v_telegram_tree , tvb , pinfo , offset , data_length ) ;\n break ;\n case U3V_READMEM_ACK : if ( U3V_STATUS_GENCP_SUCCESS == status ) {\n dissect_u3v_read_mem_ack ( u3v_telegram_tree , tvb , pinfo , offset , data_length , u3v_conv_info , gencp_trans ) ;\n }\n break ;\n case U3V_WRITEMEM_ACK : dissect_u3v_write_mem_ack ( u3v_telegram_tree , tvb , pinfo , offset , data_length , u3v_conv_info , gencp_trans ) ;\n break ;\n case U3V_PENDING_ACK : dissect_u3v_pending_ack ( u3v_telegram_tree , tvb , pinfo , offset , data_length , u3v_conv_info , gencp_trans ) ;\n break ;\n default : proto_tree_add_item ( u3v_telegram_tree , hf_u3v_payloaddata , tvb , offset , data_length , ENC_NA ) ;\n break ;\n }\n return data_length + 12 ;\n }\n else if ( stream_detected ) {\n u3v_conv_info = ( u3v_conv_info_t * ) usb_conv_info -> class_data ;\n u3v_conv_info -> ep_stream = usb_conv_info -> endpoint ;\n col_set_str ( pinfo -> cinfo , COL_PROTOCOL , \"U3V\" ) ;\n col_clear ( pinfo -> cinfo , COL_INFO ) ;\n ti = proto_tree_add_item ( tree , proto_u3v , tvb , offset , - 1 , ENC_NA ) ;\n u3v_tree = proto_item_add_subtree ( ti , ett_u3v ) ;\n if ( tvb_captured_length ( tvb ) >= 4 ) {\n prefix = tvb_get_letohl ( tvb , offset ) ;\n switch ( prefix ) {\n case U3V_STREAM_LEADER_PREFIX : dissect_u3v_stream_leader ( u3v_tree , tvb , pinfo , usb_conv_info ) ;\n break ;\n case U3V_STREAM_TRAILER_PREFIX : dissect_u3v_stream_trailer ( u3v_tree , tvb , pinfo , usb_conv_info ) ;\n break ;\n default : dissect_u3v_stream_payload ( u3v_tree , tvb , pinfo , usb_conv_info ) ;\n break ;\n }\n }\n return tvb_captured_length ( tvb ) ;\n }\n return 0 ;\n }", "idx": 21873}
{"hash": -1315695702746584250, "project": "debian", "size": 4, "label": 0, "functionSource": "proto_tree * ptvcursor_set_subtree ( ptvcursor_t * ptvc , proto_item * it , gint ett_subtree ) {\n ptvc -> tree = proto_item_add_subtree ( it , ett_subtree ) ;\n return ptvc -> tree ;\n }", "idx": 21874}
{"hash": 3584320764213684062, "project": "debian", "size": 24, "label": 0, "functionSource": "static int dissect_CPMRatioFinished ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * parent_tree , gboolean in , void * data _U_ ) {\n gint offset = 16 ;\n proto_item * item ;\n proto_tree * tree ;\n col_append_str ( pinfo -> cinfo , COL_INFO , \"RatioFinished\" ) ;\n item = proto_tree_add_item ( parent_tree , hf_mswsp_msg , tvb , offset , - 1 , ENC_NA ) ;\n tree = proto_item_add_subtree ( item , ett_mswsp_msg ) ;\n proto_item_set_text ( item , \"RationFinised%s\" , in ? \"In\" : \"Out\" ) ;\n if ( in ) {\n proto_tree_add_item ( tree , hf_mswsp_msg_cpmratiofinished_hcursor , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n proto_tree_add_item ( tree , hf_mswsp_msg_cpmratiofinished_fquick , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n }\n else {\n proto_tree_add_item ( tree , hf_mswsp_msg_cpmratiofinished_ulnumerator , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n proto_tree_add_item ( tree , hf_mswsp_msg_cpmratiofinished_uldenominator , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n proto_tree_add_item ( tree , hf_mswsp_msg_cpmratiofinished_crows , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n proto_tree_add_item ( tree , hf_mswsp_msg_cpmratiofinished_fnewrows , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n }\n return tvb_reported_length ( tvb ) ;\n }", "idx": 21875}
{"hash": 4489017523191997023, "project": "debian", "size": 10, "label": 1, "functionSource": "static int dissect_h225_DisengageRejectReason ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 646 \"./asn1/h225/h225.cnf\" gint32 value ;\n h225_packet_info * h225_pi ;\n h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_DisengageRejectReason , DisengageRejectReason_choice , & value ) ;\n if ( h225_pi != NULL ) {\n h225_pi -> reason = value ;\n }\n return offset ;\n }", "idx": 21876}
{"hash": -8704451445127642833, "project": "chrome", "size": 44, "label": 1, "functionSource": "static int32_t u_scanf_string_handler ( UFILE * input , u_scanf_spec_info * info , ufmt_args * args , const UChar * fmt , int32_t * fmtConsumed , int32_t * argConverted ) {\n const UChar * source ;\n UConverter * conv ;\n char * arg = ( char * ) ( args [ 0 ] . ptrValue ) ;\n char * alias = arg ;\n char * limit ;\n UErrorCode status = U_ZERO_ERROR ;\n int32_t count ;\n int32_t skipped = 0 ;\n UChar c ;\n UBool isNotEOF = FALSE ;\n if ( info -> fIsString ) {\n skipped = u_scanf_skip_leading_ws ( input , info -> fPadChar ) ;\n }\n count = 0 ;\n conv = u_getDefaultConverter ( & status ) ;\n if ( U_FAILURE ( status ) ) return - 1 ;\n while ( ( info -> fWidth == - 1 || count < info -> fWidth ) && ( isNotEOF = ufile_getch ( input , & c ) ) && ( ! info -> fIsString || ( c != info -> fPadChar && ! u_isWhitespace ( c ) ) ) ) {\n if ( ! info -> fSkipArg ) {\n source = & c ;\n if ( info -> fWidth > 0 ) {\n limit = alias + info -> fWidth - count ;\n }\n else {\n limit = alias + ucnv_getMaxCharSize ( conv ) ;\n }\n ucnv_fromUnicode ( conv , & alias , limit , & source , source + 1 , NULL , TRUE , & status ) ;\n if ( U_FAILURE ( status ) ) {\n u_releaseDefaultConverter ( conv ) ;\n return - 1 ;\n }\n }\n ++ count ;\n }\n if ( ! info -> fSkipArg ) {\n if ( ( info -> fWidth == - 1 || count < info -> fWidth ) && isNotEOF ) u_fungetc ( c , input ) ;\n if ( info -> fIsString ) {\n * alias = 0x00 ;\n }\n }\n u_releaseDefaultConverter ( conv ) ;\n * argConverted = ! info -> fSkipArg ;\n return count + skipped ;\n }", "idx": 21877}
{"hash": -1514879141119470937, "project": "chrome", "size": 3, "label": 1, "functionSource": "void min_heap_dtor ( min_heap_t * s ) {\n free ( s -> p ) ;\n }", "idx": 21878}
{"hash": 9046191708840218774, "project": "debian", "size": 10, "label": 0, "functionSource": "static int tipc_nl_compat_bearer_disable ( struct tipc_nl_compat_cmd_doit * cmd , struct sk_buff * skb , struct tipc_nl_compat_msg * msg ) {\n char * name ;\n struct nlattr * bearer ;\n name = ( char * ) TLV_DATA ( msg -> req ) ;\n bearer = nla_nest_start ( skb , TIPC_NLA_BEARER ) ;\n if ( ! bearer ) return - EMSGSIZE ;\n if ( nla_put_string ( skb , TIPC_NLA_BEARER_NAME , name ) ) return - EMSGSIZE ;\n nla_nest_end ( skb , bearer ) ;\n return 0 ;\n }", "idx": 21879}
{"hash": 7039307292471244756, "project": "debian", "size": 9, "label": 0, "functionSource": "static void dtap_tp_open_loop_cmd ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len ) {\n guint32 curr_offset ;\n guint32 consumed ;\n guint curr_len ;\n curr_len = len ;\n curr_offset = offset ;\n if ( curr_len ) ELEM_MAND_V ( GSM_A_PDU_TYPE_DTAP , DE_TP_ACK , NULL ) ;\n EXTRANEOUS_DATA_CHECK ( curr_len , 0 , pinfo , & ei_gsm_a_dtap_extraneous_data ) ;\n }", "idx": 21880}
{"hash": -1514879141119470937, "project": "chrome", "size": 3, "label": 0, "functionSource": "void min_heap_elem_init ( struct event * e ) {\n e -> min_heap_idx = - 1 ;\n }", "idx": 21881}
{"hash": 4180964683905830761, "project": "debian", "size": 4, "label": 0, "functionSource": "static inline u32 current_sid ( void ) {\n const struct task_security_struct * tsec = current_security ( ) ;\n return tsec -> sid ;\n }", "idx": 21882}
{"hash": 2820551931453396101, "project": "debian", "size": 22, "label": 0, "functionSource": "void jas_image_clearfmts ( ) {\n int i ;\n jas_image_fmtinfo_t * fmtinfo ;\n for ( i = 0 ;\n i < jas_image_numfmts ;\n ++ i ) {\n fmtinfo = & jas_image_fmtinfos [ i ] ;\n if ( fmtinfo -> name ) {\n jas_free ( fmtinfo -> name ) ;\n fmtinfo -> name = 0 ;\n }\n if ( fmtinfo -> ext ) {\n jas_free ( fmtinfo -> ext ) ;\n fmtinfo -> ext = 0 ;\n }\n if ( fmtinfo -> desc ) {\n jas_free ( fmtinfo -> desc ) ;\n fmtinfo -> desc = 0 ;\n }\n }\n jas_image_numfmts = 0 ;\n }", "idx": 21883}
{"hash": -4844249011537705593, "project": "chrome", "size": 9, "label": 1, "functionSource": "static void sbr_qmf_deint_bfly_c ( float * v , const float * src0 , const float * src1 ) {\n int i ;\n for ( i = 0 ;\n i < 64 ;\n i ++ ) {\n v [ i ] = src0 [ i ] - src1 [ 63 - i ] ;\n v [ 127 - i ] = src0 [ i ] + src1 [ 63 - i ] ;\n }\n }", "idx": 21884}
{"hash": 2335222688263906532, "project": "debian", "size": 14, "label": 0, "functionSource": "static int rv34_decoder_alloc ( RV34DecContext * r ) {\n r -> intra_types_stride = r -> s . mb_width * 4 + 4 ;\n r -> cbp_chroma = av_malloc ( r -> s . mb_stride * r -> s . mb_height * sizeof ( * r -> cbp_chroma ) ) ;\n r -> cbp_luma = av_malloc ( r -> s . mb_stride * r -> s . mb_height * sizeof ( * r -> cbp_luma ) ) ;\n r -> deblock_coefs = av_malloc ( r -> s . mb_stride * r -> s . mb_height * sizeof ( * r -> deblock_coefs ) ) ;\n r -> intra_types_hist = av_malloc ( r -> intra_types_stride * 4 * 2 * sizeof ( * r -> intra_types_hist ) ) ;\n r -> mb_type = av_mallocz ( r -> s . mb_stride * r -> s . mb_height * sizeof ( * r -> mb_type ) ) ;\n if ( ! ( r -> cbp_chroma && r -> cbp_luma && r -> deblock_coefs && r -> intra_types_hist && r -> mb_type ) ) {\n rv34_decoder_free ( r ) ;\n return AVERROR ( ENOMEM ) ;\n }\n r -> intra_types = r -> intra_types_hist + r -> intra_types_stride * 4 ;\n return 0 ;\n }", "idx": 21885}
{"hash": 3887066622454352196, "project": "chrome", "size": 10, "label": 1, "functionSource": "static void choose_intra_uv_mode ( VP9_COMP * cpi , PICK_MODE_CONTEXT * ctx , BLOCK_SIZE bsize , TX_SIZE max_tx_size , int * rate_uv , int * rate_uv_tokenonly , int64_t * dist_uv , int * skip_uv , PREDICTION_MODE * mode_uv ) {\n MACROBLOCK * const x = & cpi -> mb ;\n if ( cpi -> sf . use_uv_intra_rd_estimate ) {\n rd_sbuv_dcpred ( cpi , x , rate_uv , rate_uv_tokenonly , dist_uv , skip_uv , bsize < BLOCK_8X8 ? BLOCK_8X8 : bsize ) ;\n }\n else {\n rd_pick_intra_sbuv_mode ( cpi , x , ctx , rate_uv , rate_uv_tokenonly , dist_uv , skip_uv , bsize < BLOCK_8X8 ? BLOCK_8X8 : bsize , max_tx_size ) ;\n }\n * mode_uv = x -> e_mbd . mi [ 0 ] -> mbmi . uv_mode ;\n }", "idx": 21886}
{"hash": -320658364442495927, "project": "chrome", "size": 37, "label": 0, "functionSource": "void vp8_mbpost_proc_down_c ( unsigned char * dst , int pitch , int rows , int cols , int flimit ) {\n int r , c , i ;\n const short * rv3 = & vp8_rv [ 63 & rand ( ) ] ;\n for ( c = 0 ;\n c < cols ;\n c ++ ) {\n unsigned char * s = & dst [ c ] ;\n int sumsq = 0 ;\n int sum = 0 ;\n unsigned char d [ 16 ] ;\n const short * rv2 = rv3 + ( ( c * 17 ) & 127 ) ;\n for ( i = - 8 ;\n i < 0 ;\n i ++ ) s [ i * pitch ] = s [ 0 ] ;\n for ( i = 0 ;\n i < 17 ;\n i ++ ) s [ ( i + rows ) * pitch ] = s [ ( rows - 1 ) * pitch ] ;\n for ( i = - 8 ;\n i <= 6 ;\n i ++ ) {\n sumsq += s [ i * pitch ] * s [ i * pitch ] ;\n sum += s [ i * pitch ] ;\n }\n for ( r = 0 ;\n r < rows + 8 ;\n r ++ ) {\n sumsq += s [ 7 * pitch ] * s [ 7 * pitch ] - s [ - 8 * pitch ] * s [ - 8 * pitch ] ;\n sum += s [ 7 * pitch ] - s [ - 8 * pitch ] ;\n d [ r & 15 ] = s [ 0 ] ;\n if ( sumsq * 15 - sum * sum < flimit ) {\n d [ r & 15 ] = ( rv2 [ r & 127 ] + sum + s [ 0 ] ) >> 4 ;\n }\n if ( r >= 8 ) s [ - 8 * pitch ] = d [ ( r - 8 ) & 15 ] ;\n s += pitch ;\n }\n }\n }", "idx": 21887}
{"hash": -3889154245145551951, "project": "debian", "size": 7, "label": 0, "functionSource": "static void file_change_deleteall ( struct branch * b ) {\n release_tree_content_recursive ( b -> branch_tree . tree ) ;\n hashclr ( b -> branch_tree . versions [ 0 ] . sha1 ) ;\n hashclr ( b -> branch_tree . versions [ 1 ] . sha1 ) ;\n load_tree ( & b -> branch_tree ) ;\n b -> num_notes = 0 ;\n }", "idx": 21888}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_T_rangeOfBitRates ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_T_rangeOfBitRates , T_rangeOfBitRates_sequence ) ;\n return offset ;\n }", "idx": 21889}
{"hash": -4555950263653671147, "project": "debian", "size": 20, "label": 0, "functionSource": "static PyObject * string_count ( PyStringObject * self , PyObject * args ) {\n PyObject * sub_obj ;\n const char * str = PyString_AS_STRING ( self ) , * sub ;\n Py_ssize_t sub_len ;\n Py_ssize_t start = 0 , end = PY_SSIZE_T_MAX ;\n if ( ! stringlib_parse_args_finds ( \"count\" , args , & sub_obj , & start , & end ) ) return NULL ;\n if ( PyString_Check ( sub_obj ) ) {\n sub = PyString_AS_STRING ( sub_obj ) ;\n sub_len = PyString_GET_SIZE ( sub_obj ) ;\n }\n # ifdef Py_USING_UNICODE else if ( PyUnicode_Check ( sub_obj ) ) {\n Py_ssize_t count ;\n count = PyUnicode_Count ( ( PyObject * ) self , sub_obj , start , end ) ;\n if ( count == - 1 ) return NULL ;\n else return PyInt_FromSsize_t ( count ) ;\n }\n # endif else if ( PyObject_AsCharBuffer ( sub_obj , & sub , & sub_len ) ) return NULL ;\n ADJUST_INDICES ( start , end , PyString_GET_SIZE ( self ) ) ;\n return PyInt_FromSsize_t ( stringlib_count ( str + start , end - start , sub , sub_len , PY_SSIZE_T_MAX ) ) ;\n }", "idx": 21890}
{"hash": 3599206110384554647, "project": "debian", "size": 92, "label": 0, "functionSource": "void name ## _free ( type * a ) ;\n # define DECLARE_ASN1_PRINT_FUNCTION ( stname ) DECLARE_ASN1_PRINT_FUNCTION_fname ( stname , stname ) # define DECLARE_ASN1_PRINT_FUNCTION_fname ( stname , fname ) int fname ## _print_ctx ( BIO * out , stname * x , int indent , const ASN1_PCTX * pctx ) ;\n # define D2I_OF ( type ) type * ( * ) ( type * * , const unsigned char * * , long ) # define I2D_OF ( type ) int ( * ) ( type * , unsigned char * * ) # define I2D_OF_const ( type ) int ( * ) ( const type * , unsigned char * * ) # define CHECKED_D2I_OF ( type , d2i ) ( ( d2i_of_void * ) ( 1 ? d2i : ( ( D2I_OF ( type ) ) 0 ) ) ) # define CHECKED_I2D_OF ( type , i2d ) ( ( i2d_of_void * ) ( 1 ? i2d : ( ( I2D_OF ( type ) ) 0 ) ) ) # define CHECKED_NEW_OF ( type , xnew ) ( ( void * ( * ) ( void ) ) ( 1 ? xnew : ( ( type * ( * ) ( void ) ) 0 ) ) ) # define CHECKED_PTR_OF ( type , p ) ( ( void * ) ( 1 ? p : ( type * ) 0 ) ) # define CHECKED_PPTR_OF ( type , p ) ( ( void * * ) ( 1 ? p : ( type * * ) 0 ) ) # define TYPEDEF_D2I_OF ( type ) typedef type * d2i_of_ ## type ( type * * , const unsigned char * * , long ) # define TYPEDEF_I2D_OF ( type ) typedef int i2d_of_ ## type ( type * , unsigned char * * ) # define TYPEDEF_D2I2D_OF ( type ) TYPEDEF_D2I_OF ( type ) ;\n TYPEDEF_I2D_OF ( type ) TYPEDEF_D2I2D_OF ( void ) ;\n # ifndef OPENSSL_EXPORT_VAR_AS_FUNCTION typedef const ASN1_ITEM ASN1_ITEM_EXP ;\n # define ASN1_ITEM_ptr ( iptr ) ( iptr ) # define ASN1_ITEM_ref ( iptr ) ( & ( iptr ## _it ) ) # define ASN1_ITEM_rptr ( ref ) ( & ( ref ## _it ) ) # define DECLARE_ASN1_ITEM ( name ) OPENSSL_EXTERN const ASN1_ITEM name ## _it ;\n # else typedef const ASN1_ITEM * ASN1_ITEM_EXP ( void ) ;\n # define ASN1_ITEM_ptr ( iptr ) ( iptr ( ) ) # define ASN1_ITEM_ref ( iptr ) ( iptr ## _it ) # define ASN1_ITEM_rptr ( ref ) ( ref ## _it ( ) ) # define DECLARE_ASN1_ITEM ( name ) const ASN1_ITEM * name ## _it ( void ) ;\n # endif # define ASN1_STRFLGS_ESC_2253 1 # define ASN1_STRFLGS_ESC_CTRL 2 # define ASN1_STRFLGS_ESC_MSB 4 # define ASN1_STRFLGS_ESC_QUOTE 8 # define CHARTYPE_PRINTABLESTRING 0x10 # define CHARTYPE_FIRST_ESC_2253 0x20 # define CHARTYPE_LAST_ESC_2253 0x40 # define ASN1_STRFLGS_UTF8_CONVERT 0x10 # define ASN1_STRFLGS_IGNORE_TYPE 0x20 # define ASN1_STRFLGS_SHOW_TYPE 0x40 # define ASN1_STRFLGS_DUMP_ALL 0x80 # define ASN1_STRFLGS_DUMP_UNKNOWN 0x100 # define ASN1_STRFLGS_DUMP_DER 0x200 # define ASN1_STRFLGS_ESC_2254 0x400 # define ASN1_STRFLGS_RFC2253 ( ASN1_STRFLGS_ESC_2253 | ASN1_STRFLGS_ESC_CTRL | ASN1_STRFLGS_ESC_MSB | ASN1_STRFLGS_UTF8_CONVERT | ASN1_STRFLGS_DUMP_UNKNOWN | ASN1_STRFLGS_DUMP_DER ) DEFINE_STACK_OF ( ASN1_INTEGER ) DEFINE_STACK_OF ( ASN1_GENERALSTRING ) DEFINE_STACK_OF ( ASN1_UTF8STRING ) typedef struct asn1_type_st {\n int type ;\n union {\n char * ptr ;\n ASN1_BOOLEAN boolean ;\n ASN1_STRING * asn1_string ;\n ASN1_OBJECT * object ;\n ASN1_INTEGER * integer ;\n ASN1_ENUMERATED * enumerated ;\n ASN1_BIT_STRING * bit_string ;\n ASN1_OCTET_STRING * octet_string ;\n ASN1_PRINTABLESTRING * printablestring ;\n ASN1_T61STRING * t61string ;\n ASN1_IA5STRING * ia5string ;\n ASN1_GENERALSTRING * generalstring ;\n ASN1_BMPSTRING * bmpstring ;\n ASN1_UNIVERSALSTRING * universalstring ;\n ASN1_UTCTIME * utctime ;\n ASN1_GENERALIZEDTIME * generalizedtime ;\n ASN1_VISIBLESTRING * visiblestring ;\n ASN1_UTF8STRING * utf8string ;\n ASN1_STRING * set ;\n ASN1_STRING * sequence ;\n ASN1_VALUE * asn1_value ;\n }\n value ;\n }\n ASN1_TYPE ;\n DEFINE_STACK_OF ( ASN1_TYPE ) typedef STACK_OF ( ASN1_TYPE ) ASN1_SEQUENCE_ANY ;\n DECLARE_ASN1_ENCODE_FUNCTIONS_const ( ASN1_SEQUENCE_ANY , ASN1_SEQUENCE_ANY ) DECLARE_ASN1_ENCODE_FUNCTIONS_const ( ASN1_SEQUENCE_ANY , ASN1_SET_ANY ) typedef struct BIT_STRING_BITNAME_st {\n int bitnum ;\n const char * lname ;\n const char * sname ;\n }\n BIT_STRING_BITNAME ;\n # define B_ASN1_TIME B_ASN1_UTCTIME | B_ASN1_GENERALIZEDTIME # define B_ASN1_PRINTABLE B_ASN1_NUMERICSTRING | B_ASN1_PRINTABLESTRING | B_ASN1_T61STRING | B_ASN1_IA5STRING | B_ASN1_BIT_STRING | B_ASN1_UNIVERSALSTRING | B_ASN1_BMPSTRING | B_ASN1_UTF8STRING | B_ASN1_SEQUENCE | B_ASN1_UNKNOWN # define B_ASN1_DIRECTORYSTRING B_ASN1_PRINTABLESTRING | B_ASN1_TELETEXSTRING | B_ASN1_BMPSTRING | B_ASN1_UNIVERSALSTRING | B_ASN1_UTF8STRING # define B_ASN1_DISPLAYTEXT B_ASN1_IA5STRING | B_ASN1_VISIBLESTRING | B_ASN1_BMPSTRING | B_ASN1_UTF8STRING DECLARE_ASN1_FUNCTIONS_fname ( ASN1_TYPE , ASN1_ANY , ASN1_TYPE ) int ASN1_TYPE_get ( const ASN1_TYPE * a ) ;\n void ASN1_TYPE_set ( ASN1_TYPE * a , int type , void * value ) ;\n int ASN1_TYPE_set1 ( ASN1_TYPE * a , int type , const void * value ) ;\n int ASN1_TYPE_cmp ( const ASN1_TYPE * a , const ASN1_TYPE * b ) ;\n ASN1_TYPE * ASN1_TYPE_pack_sequence ( const ASN1_ITEM * it , void * s , ASN1_TYPE * * t ) ;\n void * ASN1_TYPE_unpack_sequence ( const ASN1_ITEM * it , const ASN1_TYPE * t ) ;\n ASN1_OBJECT * ASN1_OBJECT_new ( void ) ;\n void ASN1_OBJECT_free ( ASN1_OBJECT * a ) ;\n int i2d_ASN1_OBJECT ( const ASN1_OBJECT * a , unsigned char * * pp ) ;\n ASN1_OBJECT * d2i_ASN1_OBJECT ( ASN1_OBJECT * * a , const unsigned char * * pp , long length ) ;\n DECLARE_ASN1_ITEM ( ASN1_OBJECT ) DEFINE_STACK_OF ( ASN1_OBJECT ) ASN1_STRING * ASN1_STRING_new ( void ) ;\n void ASN1_STRING_free ( ASN1_STRING * a ) ;\n void ASN1_STRING_clear_free ( ASN1_STRING * a ) ;\n int ASN1_STRING_copy ( ASN1_STRING * dst , const ASN1_STRING * str ) ;\n ASN1_STRING * ASN1_STRING_dup ( const ASN1_STRING * a ) ;\n ASN1_STRING * ASN1_STRING_type_new ( int type ) ;\n int ASN1_STRING_cmp ( const ASN1_STRING * a , const ASN1_STRING * b ) ;\n int ASN1_STRING_set ( ASN1_STRING * str , const void * data , int len ) ;\n void ASN1_STRING_set0 ( ASN1_STRING * str , void * data , int len ) ;\n int ASN1_STRING_length ( const ASN1_STRING * x ) ;\n void ASN1_STRING_length_set ( ASN1_STRING * x , int n ) ;\n int ASN1_STRING_type ( const ASN1_STRING * x ) ;\n DEPRECATEDIN_1_1_0 ( unsigned char * ASN1_STRING_data ( ASN1_STRING * x ) ) const unsigned char * ASN1_STRING_get0_data ( const ASN1_STRING * x ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_BIT_STRING ) int ASN1_BIT_STRING_set ( ASN1_BIT_STRING * a , unsigned char * d , int length ) ;\n int ASN1_BIT_STRING_set_bit ( ASN1_BIT_STRING * a , int n , int value ) ;\n int ASN1_BIT_STRING_get_bit ( const ASN1_BIT_STRING * a , int n ) ;\n int ASN1_BIT_STRING_check ( const ASN1_BIT_STRING * a , const unsigned char * flags , int flags_len ) ;\n int ASN1_BIT_STRING_name_print ( BIO * out , ASN1_BIT_STRING * bs , BIT_STRING_BITNAME * tbl , int indent ) ;\n int ASN1_BIT_STRING_num_asc ( const char * name , BIT_STRING_BITNAME * tbl ) ;\n int ASN1_BIT_STRING_set_asc ( ASN1_BIT_STRING * bs , const char * name , int value , BIT_STRING_BITNAME * tbl ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_INTEGER ) ASN1_INTEGER * d2i_ASN1_UINTEGER ( ASN1_INTEGER * * a , const unsigned char * * pp , long length ) ;\n ASN1_INTEGER * ASN1_INTEGER_dup ( const ASN1_INTEGER * x ) ;\n int ASN1_INTEGER_cmp ( const ASN1_INTEGER * x , const ASN1_INTEGER * y ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_ENUMERATED ) int ASN1_UTCTIME_check ( const ASN1_UTCTIME * a ) ;\n ASN1_UTCTIME * ASN1_UTCTIME_set ( ASN1_UTCTIME * s , time_t t ) ;\n ASN1_UTCTIME * ASN1_UTCTIME_adj ( ASN1_UTCTIME * s , time_t t , int offset_day , long offset_sec ) ;\n int ASN1_UTCTIME_set_string ( ASN1_UTCTIME * s , const char * str ) ;\n int ASN1_UTCTIME_cmp_time_t ( const ASN1_UTCTIME * s , time_t t ) ;\n int ASN1_GENERALIZEDTIME_check ( const ASN1_GENERALIZEDTIME * a ) ;\n ASN1_GENERALIZEDTIME * ASN1_GENERALIZEDTIME_set ( ASN1_GENERALIZEDTIME * s , time_t t ) ;\n ASN1_GENERALIZEDTIME * ASN1_GENERALIZEDTIME_adj ( ASN1_GENERALIZEDTIME * s , time_t t , int offset_day , long offset_sec ) ;\n int ASN1_GENERALIZEDTIME_set_string ( ASN1_GENERALIZEDTIME * s , const char * str ) ;\n int ASN1_TIME_diff ( int * pday , int * psec , const ASN1_TIME * from , const ASN1_TIME * to ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_OCTET_STRING ) ASN1_OCTET_STRING * ASN1_OCTET_STRING_dup ( const ASN1_OCTET_STRING * a ) ;\n int ASN1_OCTET_STRING_cmp ( const ASN1_OCTET_STRING * a , const ASN1_OCTET_STRING * b ) ;\n int ASN1_OCTET_STRING_set ( ASN1_OCTET_STRING * str , const unsigned char * data , int len ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_VISIBLESTRING ) DECLARE_ASN1_FUNCTIONS ( ASN1_UNIVERSALSTRING ) DECLARE_ASN1_FUNCTIONS ( ASN1_UTF8STRING ) DECLARE_ASN1_FUNCTIONS ( ASN1_NULL ) DECLARE_ASN1_FUNCTIONS ( ASN1_BMPSTRING ) int UTF8_getc ( const unsigned char * str , int len , unsigned long * val ) ;\n int UTF8_putc ( unsigned char * str , int len , unsigned long value ) ;\n DECLARE_ASN1_FUNCTIONS_name ( ASN1_STRING , ASN1_PRINTABLE ) DECLARE_ASN1_FUNCTIONS_name ( ASN1_STRING , DIRECTORYSTRING ) DECLARE_ASN1_FUNCTIONS_name ( ASN1_STRING , DISPLAYTEXT ) DECLARE_ASN1_FUNCTIONS ( ASN1_PRINTABLESTRING )", "idx": 21891}
{"hash": 5347874611477979643, "project": "chrome", "size": 16, "label": 0, "functionSource": "static void test_multiplesignal ( void ) {\n struct event ev_one , ev_two ;\n struct itimerval itv ;\n setup_test ( \"Multiple signal: \" ) ;\n signal_set ( & ev_one , SIGALRM , signal_cb , & ev_one ) ;\n signal_add ( & ev_one , NULL ) ;\n signal_set ( & ev_two , SIGALRM , signal_cb , & ev_two ) ;\n signal_add ( & ev_two , NULL ) ;\n memset ( & itv , 0 , sizeof ( itv ) ) ;\n itv . it_value . tv_sec = 1 ;\n if ( setitimer ( ITIMER_REAL , & itv , NULL ) == - 1 ) goto skip_simplesignal ;\n event_dispatch ( ) ;\n skip_simplesignal : if ( signal_del ( & ev_one ) == - 1 ) test_ok = 0 ;\n if ( signal_del ( & ev_two ) == - 1 ) test_ok = 0 ;\n cleanup_test ( ) ;\n }", "idx": 21892}
{"hash": -5550748970150309774, "project": "debian", "size": 15, "label": 0, "functionSource": "int ReconnectToServer ( ArchiveHandle * AH , const char * dbname , const char * username ) {\n PGconn * newConn ;\n const char * newdbname ;\n const char * newusername ;\n if ( ! dbname ) newdbname = PQdb ( AH -> connection ) ;\n else newdbname = dbname ;\n if ( ! username ) newusername = PQuser ( AH -> connection ) ;\n else newusername = username ;\n if ( strcmp ( newdbname , PQdb ( AH -> connection ) ) == 0 && strcmp ( newusername , PQuser ( AH -> connection ) ) == 0 ) return 1 ;\n newConn = _connectDB ( AH , newdbname , newusername ) ;\n set_archive_cancel_info ( AH , newConn ) ;\n PQfinish ( AH -> connection ) ;\n AH -> connection = newConn ;\n return 1 ;\n }", "idx": 21893}
{"hash": -7434014980763120366, "project": "debian", "size": 4, "label": 0, "functionSource": "static gboolean ber_decode_as_change ( const char * name _U_ , const gpointer pattern _U_ , gpointer handle _U_ , gchar * list_name ) {\n ber_decode_as ( list_name ) ;\n return FALSE ;\n }", "idx": 21894}
{"hash": -1514879141119470937, "project": "chrome", "size": 3, "label": 0, "functionSource": "unsigned min_heap_size ( min_heap_t * s ) {\n return s -> n ;\n }", "idx": 21895}
{"hash": -281311800725760049, "project": "debian", "size": 4, "label": 0, "functionSource": "static int get_bits_esc4 ( GetBitContext * gb ) {\n if ( get_bits1 ( gb ) ) return get_bits ( gb , 4 ) + 1 ;\n else return 0 ;\n }", "idx": 21896}
{"hash": 8085056330506804135, "project": "chrome", "size": 4, "label": 0, "functionSource": "static int absdiff_thresh ( BLOCK_SIZE bs , int increase_denoising ) {\n ( void ) bs ;\n return 3 + ( increase_denoising ? 1 : 0 ) ;\n }", "idx": 21897}
{"hash": 313627013719508831, "project": "debian", "size": 3, "label": 0, "functionSource": "static inline void SetPixelRedTraits ( Image * image , const PixelTrait traits ) {\n image -> channel_map [ RedPixelChannel ] . traits = traits ;\n }", "idx": 21898}
{"hash": 3557739556029059195, "project": "chrome", "size": 21, "label": 0, "functionSource": "unsigned int vp9_sad ## m ## x ## n ## _c ( const uint8_t * src , int src_stride , const uint8_t * ref , int ref_stride ) {\n return sad ( src , src_stride , ref , ref_stride , m , n ) ;\n \\ }\n unsigned int vp9_sad ## m ## x ## n ## _avg_c ( const uint8_t * src , int src_stride , const uint8_t * ref , int ref_stride , const uint8_t * second_pred ) {\n uint8_t comp_pred [ m * n ] ;\n vp9_comp_avg_pred ( comp_pred , second_pred , m , n , ref , ref_stride ) ;\n return sad ( src , src_stride , comp_pred , m , m , n ) ;\n \\ }\n # define sadMxNxK ( m , n , k ) void vp9_sad ## m ## x ## n ## x ## k ## _c ( const uint8_t * src , int src_stride , const uint8_t * ref , int ref_stride , unsigned int * sads ) {\n int i ;\n for ( i = 0 ;\n i < k ;\n ++ i ) sads [ i ] = vp9_sad ## m ## x ## n ## _c ( src , src_stride , & ref [ i ] , ref_stride ) ;\n \\ }\n # define sadMxNx4D ( m , n ) void vp9_sad ## m ## x ## n ## x4d_c ( const uint8_t * src , int src_stride , const uint8_t * const refs [ ] , int ref_stride , unsigned int * sads ) {\n int i ;\n for ( i = 0 ;\n i < 4 ;\n ++ i ) sads [ i ] = vp9_sad ## m ## x ## n ## _c ( src , src_stride , refs [ i ] , ref_stride ) ;\n \\ }\n sadMxN ( 64 , 64 ) sadMxNxK ( 64 , 64 , 3 ) sadMxNxK ( 64 , 64 , 8 ) sadMxNx4D ( 64 , 64 ) sadMxN ( 64 , 32 ) sadMxNx4D ( 64 , 32 ) sadMxN ( 32 , 64 ) sadMxNx4D ( 32 , 64 ) sadMxN ( 32 , 32 ) sadMxNxK ( 32 , 32 , 3 ) sadMxNxK ( 32 , 32 , 8 ) sadMxNx4D ( 32 , 32 ) sadMxN ( 32 , 16 ) sadMxNx4D ( 32 , 16 ) sadMxN ( 16 , 32 ) sadMxNx4D ( 16 , 32 ) sadMxN ( 16 , 16 )", "idx": 21899}
{"hash": 2895622461494525400, "project": "debian", "size": 38, "label": 0, "functionSource": "static void test_bug6058 ( ) {\n MYSQL_STMT * stmt ;\n MYSQL_BIND my_bind [ 1 ] ;\n MYSQL_RES * res ;\n MYSQL_ROW row ;\n const char * stmt_text ;\n char buffer [ 30 ] ;\n ulong length ;\n int rc ;\n myheader ( \"test_bug6058\" ) ;\n rc = mysql_query ( mysql , \"SET SQL_MODE=''\" ) ;\n myquery ( rc ) ;\n stmt_text = \"SELECT CAST('0000-00-00' AS DATE)\" ;\n rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n myquery ( rc ) ;\n res = mysql_store_result ( mysql ) ;\n row = mysql_fetch_row ( res ) ;\n stmt = mysql_stmt_init ( mysql ) ;\n rc = mysql_stmt_prepare ( stmt , stmt_text , strlen ( stmt_text ) ) ;\n check_execute ( stmt , rc ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n my_bind [ 0 ] . buffer_type = MYSQL_TYPE_STRING ;\n my_bind [ 0 ] . buffer = & buffer ;\n my_bind [ 0 ] . buffer_length = sizeof ( buffer ) ;\n my_bind [ 0 ] . length = & length ;\n mysql_stmt_bind_result ( stmt , my_bind ) ;\n rc = mysql_stmt_fetch ( stmt ) ;\n DIE_UNLESS ( rc == 0 ) ;\n if ( ! opt_silent ) {\n printf ( \"Result from query: %s\\n\" , row [ 0 ] ) ;\n printf ( \"Result from prepared statement: %s\\n\" , buffer ) ;\n }\n DIE_UNLESS ( strcmp ( row [ 0 ] , buffer ) == 0 ) ;\n mysql_free_result ( res ) ;\n mysql_stmt_close ( stmt ) ;\n }", "idx": 21900}
{"hash": 6451388340908334697, "project": "debian", "size": 4, "label": 0, "functionSource": "static CLEAR_MARKS_PROC ( aos_clear_marks ) {\n aos_state_t * const pptr = vptr ;\n r_clear_attrs ( & pptr -> blocks , l_mark ) ;\n }", "idx": 21901}
{"hash": -7724655445309867912, "project": "debian", "size": 326, "label": 0, "functionSource": "int cpu_exec ( CPUArchState * env ) {\n CPUState * cpu = ENV_GET_CPU ( env ) ;\n # if ! ( defined ( CONFIG_USER_ONLY ) && ( defined ( TARGET_M68K ) || defined ( TARGET_PPC ) || defined ( TARGET_S390X ) ) ) CPUClass * cc = CPU_GET_CLASS ( cpu ) ;\n # endif int ret , interrupt_request ;\n TranslationBlock * tb ;\n uint8_t * tc_ptr ;\n tcg_target_ulong next_tb ;\n if ( cpu -> halted ) {\n if ( ! cpu_has_work ( cpu ) ) {\n return EXCP_HALTED ;\n }\n cpu -> halted = 0 ;\n }\n current_cpu = cpu ;\n smp_mb ( ) ;\n if ( unlikely ( exit_request ) ) {\n cpu -> exit_request = 1 ;\n }\n # if defined ( TARGET_I386 ) CC_SRC = env -> eflags & ( CC_O | CC_S | CC_Z | CC_A | CC_P | CC_C ) ;\n env -> df = 1 - ( 2 * ( ( env -> eflags >> 10 ) & 1 ) ) ;\n CC_OP = CC_OP_EFLAGS ;\n env -> eflags &= ~ ( DF_MASK | CC_O | CC_S | CC_Z | CC_A | CC_P | CC_C ) ;\n # elif defined ( TARGET_SPARC ) # elif defined ( TARGET_M68K ) env -> cc_op = CC_OP_FLAGS ;\n env -> cc_dest = env -> sr & 0xf ;\n env -> cc_x = ( env -> sr >> 4 ) & 1 ;\n # elif defined ( TARGET_ALPHA ) # elif defined ( TARGET_ARM ) # elif defined ( TARGET_UNICORE32 ) # elif defined ( TARGET_PPC ) env -> reserve_addr = - 1 ;\n # elif defined ( TARGET_LM32 ) # elif defined ( TARGET_MICROBLAZE ) # elif defined ( TARGET_MIPS ) # elif defined ( TARGET_MOXIE ) # elif defined ( TARGET_OPENRISC ) # elif defined ( TARGET_SH4 ) # elif defined ( TARGET_CRIS ) # elif defined ( TARGET_S390X ) # elif defined ( TARGET_XTENSA ) # else # error unsupported target CPU # endif env -> exception_index = - 1 ;\n for ( ;\n ;\n ) {\n if ( sigsetjmp ( env -> jmp_env , 0 ) == 0 ) {\n if ( env -> exception_index >= 0 ) {\n if ( env -> exception_index >= EXCP_INTERRUPT ) {\n ret = env -> exception_index ;\n if ( ret == EXCP_DEBUG ) {\n cpu_handle_debug_exception ( env ) ;\n }\n break ;\n }\n else {\n # if defined ( CONFIG_USER_ONLY ) # if defined ( TARGET_I386 ) cc -> do_interrupt ( cpu ) ;\n # endif ret = env -> exception_index ;\n break ;\n # else cc -> do_interrupt ( cpu ) ;\n env -> exception_index = - 1 ;\n # endif }\n }\n next_tb = 0 ;\n for ( ;\n ;\n ) {\n interrupt_request = cpu -> interrupt_request ;\n if ( unlikely ( interrupt_request ) ) {\n if ( unlikely ( env -> singlestep_enabled & SSTEP_NOIRQ ) ) {\n interrupt_request &= ~ CPU_INTERRUPT_SSTEP_MASK ;\n }\n if ( interrupt_request & CPU_INTERRUPT_DEBUG ) {\n cpu -> interrupt_request &= ~ CPU_INTERRUPT_DEBUG ;\n env -> exception_index = EXCP_DEBUG ;\n cpu_loop_exit ( env ) ;\n }\n # if defined ( TARGET_ARM ) || defined ( TARGET_SPARC ) || defined ( TARGET_MIPS ) || defined ( TARGET_PPC ) || defined ( TARGET_ALPHA ) || defined ( TARGET_CRIS ) || defined ( TARGET_MICROBLAZE ) || defined ( TARGET_LM32 ) || defined ( TARGET_UNICORE32 ) if ( interrupt_request & CPU_INTERRUPT_HALT ) {\n cpu -> interrupt_request &= ~ CPU_INTERRUPT_HALT ;\n cpu -> halted = 1 ;\n env -> exception_index = EXCP_HLT ;\n cpu_loop_exit ( env ) ;\n }\n # endif # if defined ( TARGET_I386 ) # if ! defined ( CONFIG_USER_ONLY ) if ( interrupt_request & CPU_INTERRUPT_POLL ) {\n cpu -> interrupt_request &= ~ CPU_INTERRUPT_POLL ;\n apic_poll_irq ( env -> apic_state ) ;\n }\n # endif if ( interrupt_request & CPU_INTERRUPT_INIT ) {\n cpu_svm_check_intercept_param ( env , SVM_EXIT_INIT , 0 ) ;\n do_cpu_init ( x86_env_get_cpu ( env ) ) ;\n env -> exception_index = EXCP_HALTED ;\n cpu_loop_exit ( env ) ;\n }\n else if ( interrupt_request & CPU_INTERRUPT_SIPI ) {\n do_cpu_sipi ( x86_env_get_cpu ( env ) ) ;\n }\n else if ( env -> hflags2 & HF2_GIF_MASK ) {\n if ( ( interrupt_request & CPU_INTERRUPT_SMI ) && ! ( env -> hflags & HF_SMM_MASK ) ) {\n cpu_svm_check_intercept_param ( env , SVM_EXIT_SMI , 0 ) ;\n cpu -> interrupt_request &= ~ CPU_INTERRUPT_SMI ;\n do_smm_enter ( env ) ;\n next_tb = 0 ;\n }\n else if ( ( interrupt_request & CPU_INTERRUPT_NMI ) && ! ( env -> hflags2 & HF2_NMI_MASK ) ) {\n cpu -> interrupt_request &= ~ CPU_INTERRUPT_NMI ;\n env -> hflags2 |= HF2_NMI_MASK ;\n do_interrupt_x86_hardirq ( env , EXCP02_NMI , 1 ) ;\n next_tb = 0 ;\n }\n else if ( interrupt_request & CPU_INTERRUPT_MCE ) {\n cpu -> interrupt_request &= ~ CPU_INTERRUPT_MCE ;\n do_interrupt_x86_hardirq ( env , EXCP12_MCHK , 0 ) ;\n next_tb = 0 ;\n }\n else if ( ( interrupt_request & CPU_INTERRUPT_HARD ) && ( ( ( env -> hflags2 & HF2_VINTR_MASK ) && ( env -> hflags2 & HF2_HIF_MASK ) ) || ( ! ( env -> hflags2 & HF2_VINTR_MASK ) && ( env -> eflags & IF_MASK && ! ( env -> hflags & HF_INHIBIT_IRQ_MASK ) ) ) ) ) {\n int intno ;\n cpu_svm_check_intercept_param ( env , SVM_EXIT_INTR , 0 ) ;\n cpu -> interrupt_request &= ~ ( CPU_INTERRUPT_HARD | CPU_INTERRUPT_VIRQ ) ;\n intno = cpu_get_pic_interrupt ( env ) ;\n qemu_log_mask ( CPU_LOG_TB_IN_ASM , \"Servicing hardware INT=0x%02x\\n\" , intno ) ;\n do_interrupt_x86_hardirq ( env , intno , 1 ) ;\n next_tb = 0 ;\n # if ! defined ( CONFIG_USER_ONLY ) }\n else if ( ( interrupt_request & CPU_INTERRUPT_VIRQ ) && ( env -> eflags & IF_MASK ) && ! ( env -> hflags & HF_INHIBIT_IRQ_MASK ) ) {\n int intno ;\n cpu_svm_check_intercept_param ( env , SVM_EXIT_VINTR , 0 ) ;\n intno = ldl_phys ( env -> vm_vmcb + offsetof ( struct vmcb , control . int_vector ) ) ;\n qemu_log_mask ( CPU_LOG_TB_IN_ASM , \"Servicing virtual hardware INT=0x%02x\\n\" , intno ) ;\n do_interrupt_x86_hardirq ( env , intno , 1 ) ;\n cpu -> interrupt_request &= ~ CPU_INTERRUPT_VIRQ ;\n next_tb = 0 ;\n # endif }\n }\n # elif defined ( TARGET_PPC ) if ( ( interrupt_request & CPU_INTERRUPT_RESET ) ) {\n cpu_reset ( cpu ) ;\n }\n if ( interrupt_request & CPU_INTERRUPT_HARD ) {\n ppc_hw_interrupt ( env ) ;\n if ( env -> pending_interrupts == 0 ) {\n cpu -> interrupt_request &= ~ CPU_INTERRUPT_HARD ;\n }\n next_tb = 0 ;\n }\n # elif defined ( TARGET_LM32 ) if ( ( interrupt_request & CPU_INTERRUPT_HARD ) && ( env -> ie & IE_IE ) ) {\n env -> exception_index = EXCP_IRQ ;\n cc -> do_interrupt ( cpu ) ;\n next_tb = 0 ;\n }\n # elif defined ( TARGET_MICROBLAZE ) if ( ( interrupt_request & CPU_INTERRUPT_HARD ) && ( env -> sregs [ SR_MSR ] & MSR_IE ) && ! ( env -> sregs [ SR_MSR ] & ( MSR_EIP | MSR_BIP ) ) && ! ( env -> iflags & ( D_FLAG | IMM_FLAG ) ) ) {\n env -> exception_index = EXCP_IRQ ;\n cc -> do_interrupt ( cpu ) ;\n next_tb = 0 ;\n }\n # elif defined ( TARGET_MIPS ) if ( ( interrupt_request & CPU_INTERRUPT_HARD ) && cpu_mips_hw_interrupts_pending ( env ) ) {\n env -> exception_index = EXCP_EXT_INTERRUPT ;\n env -> error_code = 0 ;\n cc -> do_interrupt ( cpu ) ;\n next_tb = 0 ;\n }\n # elif defined ( TARGET_OPENRISC ) {\n int idx = - 1 ;\n if ( ( interrupt_request & CPU_INTERRUPT_HARD ) && ( env -> sr & SR_IEE ) ) {\n idx = EXCP_INT ;\n }\n if ( ( interrupt_request & CPU_INTERRUPT_TIMER ) && ( env -> sr & SR_TEE ) ) {\n idx = EXCP_TICK ;\n }\n if ( idx >= 0 ) {\n env -> exception_index = idx ;\n cc -> do_interrupt ( cpu ) ;\n next_tb = 0 ;\n }\n }\n # elif defined ( TARGET_SPARC ) if ( interrupt_request & CPU_INTERRUPT_HARD ) {\n if ( cpu_interrupts_enabled ( env ) && env -> interrupt_index > 0 ) {\n int pil = env -> interrupt_index & 0xf ;\n int type = env -> interrupt_index & 0xf0 ;\n if ( ( ( type == TT_EXTINT ) && cpu_pil_allowed ( env , pil ) ) || type != TT_EXTINT ) {\n env -> exception_index = env -> interrupt_index ;\n cc -> do_interrupt ( cpu ) ;\n next_tb = 0 ;\n }\n }\n }\n # elif defined ( TARGET_ARM ) if ( interrupt_request & CPU_INTERRUPT_FIQ && ! ( env -> uncached_cpsr & CPSR_F ) ) {\n env -> exception_index = EXCP_FIQ ;\n cc -> do_interrupt ( cpu ) ;\n next_tb = 0 ;\n }\n if ( interrupt_request & CPU_INTERRUPT_HARD && ( ( IS_M ( env ) && env -> regs [ 15 ] < 0xfffffff0 ) || ! ( env -> uncached_cpsr & CPSR_I ) ) ) {\n env -> exception_index = EXCP_IRQ ;\n cc -> do_interrupt ( cpu ) ;\n next_tb = 0 ;\n }\n # elif defined ( TARGET_UNICORE32 ) if ( interrupt_request & CPU_INTERRUPT_HARD && ! ( env -> uncached_asr & ASR_I ) ) {\n env -> exception_index = UC32_EXCP_INTR ;\n cc -> do_interrupt ( cpu ) ;\n next_tb = 0 ;\n }\n # elif defined ( TARGET_SH4 ) if ( interrupt_request & CPU_INTERRUPT_HARD ) {\n cc -> do_interrupt ( cpu ) ;\n next_tb = 0 ;\n }\n # elif defined ( TARGET_ALPHA ) {\n int idx = - 1 ;\n switch ( env -> pal_mode ? 7 : env -> ps & PS_INT_MASK ) {\n case 0 ... 3 : if ( interrupt_request & CPU_INTERRUPT_HARD ) {\n idx = EXCP_DEV_INTERRUPT ;\n }\n case 4 : if ( interrupt_request & CPU_INTERRUPT_TIMER ) {\n idx = EXCP_CLK_INTERRUPT ;\n }\n case 5 : if ( interrupt_request & CPU_INTERRUPT_SMP ) {\n idx = EXCP_SMP_INTERRUPT ;\n }\n case 6 : if ( interrupt_request & CPU_INTERRUPT_MCHK ) {\n idx = EXCP_MCHK ;\n }\n }\n if ( idx >= 0 ) {\n env -> exception_index = idx ;\n env -> error_code = 0 ;\n cc -> do_interrupt ( cpu ) ;\n next_tb = 0 ;\n }\n }\n # elif defined ( TARGET_CRIS ) if ( interrupt_request & CPU_INTERRUPT_HARD && ( env -> pregs [ PR_CCS ] & I_FLAG ) && ! env -> locked_irq ) {\n env -> exception_index = EXCP_IRQ ;\n cc -> do_interrupt ( cpu ) ;\n next_tb = 0 ;\n }\n if ( interrupt_request & CPU_INTERRUPT_NMI ) {\n unsigned int m_flag_archval ;\n if ( env -> pregs [ PR_VR ] < 32 ) {\n m_flag_archval = M_FLAG_V10 ;\n }\n else {\n m_flag_archval = M_FLAG_V32 ;\n }\n if ( ( env -> pregs [ PR_CCS ] & m_flag_archval ) ) {\n env -> exception_index = EXCP_NMI ;\n cc -> do_interrupt ( cpu ) ;\n next_tb = 0 ;\n }\n }\n # elif defined ( TARGET_M68K ) if ( interrupt_request & CPU_INTERRUPT_HARD && ( ( env -> sr & SR_I ) >> SR_I_SHIFT ) < env -> pending_level ) {\n env -> exception_index = env -> pending_vector ;\n do_interrupt_m68k_hardirq ( env ) ;\n next_tb = 0 ;\n }\n # elif defined ( TARGET_S390X ) && ! defined ( CONFIG_USER_ONLY ) if ( ( interrupt_request & CPU_INTERRUPT_HARD ) && ( env -> psw . mask & PSW_MASK_EXT ) ) {\n cc -> do_interrupt ( cpu ) ;\n next_tb = 0 ;\n }\n # elif defined ( TARGET_XTENSA ) if ( interrupt_request & CPU_INTERRUPT_HARD ) {\n env -> exception_index = EXC_IRQ ;\n cc -> do_interrupt ( cpu ) ;\n next_tb = 0 ;\n }\n # endif if ( cpu -> interrupt_request & CPU_INTERRUPT_EXITTB ) {\n cpu -> interrupt_request &= ~ CPU_INTERRUPT_EXITTB ;\n next_tb = 0 ;\n }\n }\n if ( unlikely ( cpu -> exit_request ) ) {\n cpu -> exit_request = 0 ;\n env -> exception_index = EXCP_INTERRUPT ;\n cpu_loop_exit ( env ) ;\n }\n # if defined ( DEBUG_DISAS ) if ( qemu_loglevel_mask ( CPU_LOG_TB_CPU ) ) {\n # if defined ( TARGET_I386 ) log_cpu_state ( env , CPU_DUMP_CCOP ) ;\n # elif defined ( TARGET_M68K ) cpu_m68k_flush_flags ( env , env -> cc_op ) ;\n env -> cc_op = CC_OP_FLAGS ;\n env -> sr = ( env -> sr & 0xffe0 ) | env -> cc_dest | ( env -> cc_x << 4 ) ;\n log_cpu_state ( env , 0 ) ;\n # else log_cpu_state ( env , 0 ) ;\n # endif }\n # endif spin_lock ( & tcg_ctx . tb_ctx . tb_lock ) ;\n tb = tb_find_fast ( env ) ;\n if ( tcg_ctx . tb_ctx . tb_invalidated_flag ) {\n next_tb = 0 ;\n tcg_ctx . tb_ctx . tb_invalidated_flag = 0 ;\n }\n if ( qemu_loglevel_mask ( CPU_LOG_EXEC ) ) {\n qemu_log ( \"Trace %p [\" TARGET_FMT_lx \"] %s\\n\" , tb -> tc_ptr , tb -> pc , lookup_symbol ( tb -> pc ) ) ;\n }\n if ( next_tb != 0 && tb -> page_addr [ 1 ] == - 1 ) {\n tb_add_jump ( ( TranslationBlock * ) ( next_tb & ~ TB_EXIT_MASK ) , next_tb & TB_EXIT_MASK , tb ) ;\n }\n spin_unlock ( & tcg_ctx . tb_ctx . tb_lock ) ;\n cpu -> current_tb = tb ;\n barrier ( ) ;\n if ( likely ( ! cpu -> exit_request ) ) {\n tc_ptr = tb -> tc_ptr ;\n next_tb = cpu_tb_exec ( cpu , tc_ptr ) ;\n switch ( next_tb & TB_EXIT_MASK ) {\n case TB_EXIT_REQUESTED : tb = ( TranslationBlock * ) ( next_tb & ~ TB_EXIT_MASK ) ;\n next_tb = 0 ;\n break ;\n case TB_EXIT_ICOUNT_EXPIRED : {\n int insns_left ;\n tb = ( TranslationBlock * ) ( next_tb & ~ TB_EXIT_MASK ) ;\n insns_left = env -> icount_decr . u32 ;\n if ( env -> icount_extra && insns_left >= 0 ) {\n env -> icount_extra += insns_left ;\n if ( env -> icount_extra > 0xffff ) {\n insns_left = 0xffff ;\n }\n else {\n insns_left = env -> icount_extra ;\n }\n env -> icount_extra -= insns_left ;\n env -> icount_decr . u16 . low = insns_left ;\n }\n else {\n if ( insns_left > 0 ) {\n cpu_exec_nocache ( env , insns_left , tb ) ;\n }\n env -> exception_index = EXCP_INTERRUPT ;\n next_tb = 0 ;\n cpu_loop_exit ( env ) ;\n }\n break ;\n }\n default : break ;\n }\n }\n cpu -> current_tb = NULL ;\n }\n }\n else {\n cpu = current_cpu ;\n env = cpu -> env_ptr ;\n }\n }\n # if defined ( TARGET_I386 ) env -> eflags = env -> eflags | cpu_cc_compute_all ( env , CC_OP ) | ( env -> df & DF_MASK ) ;\n # elif defined ( TARGET_ARM ) # elif defined ( TARGET_UNICORE32 ) # elif defined ( TARGET_SPARC ) # elif defined ( TARGET_PPC ) # elif defined ( TARGET_LM32 ) # elif defined ( TARGET_M68K ) cpu_m68k_flush_flags ( env , env -> cc_op ) ;\n env -> cc_op = CC_OP_FLAGS ;\n env -> sr = ( env -> sr & 0xffe0 ) | env -> cc_dest | ( env -> cc_x << 4 ) ;\n # elif defined ( TARGET_MICROBLAZE ) # elif defined ( TARGET_MIPS ) # elif defined ( TARGET_MOXIE ) # elif defined ( TARGET_OPENRISC ) # elif defined ( TARGET_SH4 ) # elif defined ( TARGET_ALPHA ) # elif defined ( TARGET_CRIS ) # elif defined ( TARGET_S390X ) # elif defined ( TARGET_XTENSA ) # else # error unsupported target CPU # endif current_cpu = NULL ;\n return ret ;\n }", "idx": 21902}
{"hash": -3559021711340554904, "project": "debian", "size": 9, "label": 0, "functionSource": "Node * estimate_expression_value ( PlannerInfo * root , Node * node ) {\n eval_const_expressions_context context ;\n context . boundParams = root -> glob -> boundParams ;\n context . root = NULL ;\n context . active_fns = NIL ;\n context . case_val = NULL ;\n context . estimate = true ;\n return eval_const_expressions_mutator ( node , & context ) ;\n }", "idx": 21903}
{"hash": -5780611388839125875, "project": "chrome", "size": 47, "label": 1, "functionSource": "void xmlInitializeGlobalState ( xmlGlobalStatePtr gs ) {\n # ifdef DEBUG_GLOBALS fprintf ( stderr , \"Initializing globals at %lu for thread %d\\n\" , ( unsigned long ) gs , xmlGetThreadId ( ) ) ;\n # endif if ( xmlThrDefMutex == NULL ) xmlInitGlobals ( ) ;\n xmlMutexLock ( xmlThrDefMutex ) ;\n # if defined ( LIBXML_DOCB_ENABLED ) && defined ( LIBXML_LEGACY_ENABLED ) && defined ( LIBXML_SAX1_ENABLED ) initdocbDefaultSAXHandler ( & gs -> docbDefaultSAXHandler ) ;\n # endif # if defined ( LIBXML_HTML_ENABLED ) && defined ( LIBXML_LEGACY_ENABLED ) inithtmlDefaultSAXHandler ( & gs -> htmlDefaultSAXHandler ) ;\n # endif gs -> oldXMLWDcompatibility = 0 ;\n gs -> xmlBufferAllocScheme = xmlBufferAllocSchemeThrDef ;\n gs -> xmlDefaultBufferSize = xmlDefaultBufferSizeThrDef ;\n # if defined ( LIBXML_SAX1_ENABLED ) && defined ( LIBXML_LEGACY_ENABLED ) initxmlDefaultSAXHandler ( & gs -> xmlDefaultSAXHandler , 1 ) ;\n # endif gs -> xmlDefaultSAXLocator . getPublicId = xmlSAX2GetPublicId ;\n gs -> xmlDefaultSAXLocator . getSystemId = xmlSAX2GetSystemId ;\n gs -> xmlDefaultSAXLocator . getLineNumber = xmlSAX2GetLineNumber ;\n gs -> xmlDefaultSAXLocator . getColumnNumber = xmlSAX2GetColumnNumber ;\n gs -> xmlDoValidityCheckingDefaultValue = xmlDoValidityCheckingDefaultValueThrDef ;\n # if defined ( DEBUG_MEMORY_LOCATION ) | defined ( DEBUG_MEMORY ) gs -> xmlFree = ( xmlFreeFunc ) xmlMemFree ;\n gs -> xmlMalloc = ( xmlMallocFunc ) xmlMemMalloc ;\n gs -> xmlMallocAtomic = ( xmlMallocFunc ) xmlMemMalloc ;\n gs -> xmlRealloc = ( xmlReallocFunc ) xmlMemRealloc ;\n gs -> xmlMemStrdup = ( xmlStrdupFunc ) xmlMemoryStrdup ;\n # else gs -> xmlFree = ( xmlFreeFunc ) free ;\n gs -> xmlMalloc = ( xmlMallocFunc ) malloc ;\n gs -> xmlMallocAtomic = ( xmlMallocFunc ) malloc ;\n gs -> xmlRealloc = ( xmlReallocFunc ) realloc ;\n gs -> xmlMemStrdup = ( xmlStrdupFunc ) xmlStrdup ;\n # endif gs -> xmlGetWarningsDefaultValue = xmlGetWarningsDefaultValueThrDef ;\n gs -> xmlIndentTreeOutput = xmlIndentTreeOutputThrDef ;\n gs -> xmlTreeIndentString = xmlTreeIndentStringThrDef ;\n gs -> xmlKeepBlanksDefaultValue = xmlKeepBlanksDefaultValueThrDef ;\n gs -> xmlLineNumbersDefaultValue = xmlLineNumbersDefaultValueThrDef ;\n gs -> xmlLoadExtDtdDefaultValue = xmlLoadExtDtdDefaultValueThrDef ;\n gs -> xmlParserDebugEntities = xmlParserDebugEntitiesThrDef ;\n gs -> xmlParserVersion = LIBXML_VERSION_STRING ;\n gs -> xmlPedanticParserDefaultValue = xmlPedanticParserDefaultValueThrDef ;\n gs -> xmlSaveNoEmptyTags = xmlSaveNoEmptyTagsThrDef ;\n gs -> xmlSubstituteEntitiesDefaultValue = xmlSubstituteEntitiesDefaultValueThrDef ;\n gs -> xmlGenericError = xmlGenericErrorThrDef ;\n gs -> xmlStructuredError = xmlStructuredErrorThrDef ;\n gs -> xmlGenericErrorContext = xmlGenericErrorContextThrDef ;\n gs -> xmlStructuredErrorContext = xmlStructuredErrorContextThrDef ;\n gs -> xmlRegisterNodeDefaultValue = xmlRegisterNodeDefaultValueThrDef ;\n gs -> xmlDeregisterNodeDefaultValue = xmlDeregisterNodeDefaultValueThrDef ;\n gs -> xmlParserInputBufferCreateFilenameValue = xmlParserInputBufferCreateFilenameValueThrDef ;\n gs -> xmlOutputBufferCreateFilenameValue = xmlOutputBufferCreateFilenameValueThrDef ;\n memset ( & gs -> xmlLastError , 0 , sizeof ( xmlError ) ) ;\n xmlMutexUnlock ( xmlThrDefMutex ) ;\n }", "idx": 21904}
{"hash": 2578089348587614328, "project": "debian", "size": 3, "label": 0, "functionSource": "DSA * d2i_DSAPrivateKey_fp ( FILE * fp , DSA * * dsa ) {\n return ASN1_d2i_fp_of ( DSA , DSA_new , d2i_DSAPrivateKey , fp , dsa ) ;\n }", "idx": 21905}
{"hash": -5697857125570093892, "project": "chrome", "size": 288, "label": 0, "functionSource": "static ULanguageTag * ultag_parse ( const char * tag , int32_t tagLen , int32_t * parsedLen , UErrorCode * status ) {\n ULanguageTag * t ;\n char * tagBuf ;\n int16_t next ;\n char * pSubtag , * pNext , * pLastGoodPosition ;\n int32_t subtagLen ;\n int32_t extlangIdx ;\n ExtensionListEntry * pExtension ;\n char * pExtValueSubtag , * pExtValueSubtagEnd ;\n int32_t i ;\n UBool privateuseVar = FALSE ;\n int32_t grandfatheredLen = 0 ;\n if ( parsedLen != NULL ) {\n * parsedLen = 0 ;\n }\n if ( U_FAILURE ( * status ) ) {\n return NULL ;\n }\n if ( tagLen < 0 ) {\n tagLen = ( int32_t ) uprv_strlen ( tag ) ;\n }\n tagBuf = ( char * ) uprv_malloc ( tagLen + 1 ) ;\n if ( tagBuf == NULL ) {\n * status = U_MEMORY_ALLOCATION_ERROR ;\n return NULL ;\n }\n uprv_memcpy ( tagBuf , tag , tagLen ) ;\n * ( tagBuf + tagLen ) = 0 ;\n t = ( ULanguageTag * ) uprv_malloc ( sizeof ( ULanguageTag ) ) ;\n if ( t == NULL ) {\n uprv_free ( tagBuf ) ;\n * status = U_MEMORY_ALLOCATION_ERROR ;\n return NULL ;\n }\n _initializeULanguageTag ( t ) ;\n t -> buf = tagBuf ;\n if ( tagLen < MINLEN ) {\n return t ;\n }\n for ( i = 0 ;\n GRANDFATHERED [ i ] != NULL ;\n i += 2 ) {\n if ( uprv_stricmp ( GRANDFATHERED [ i ] , tagBuf ) == 0 ) {\n int32_t newTagLength ;\n grandfatheredLen = tagLen ;\n newTagLength = uprv_strlen ( GRANDFATHERED [ i + 1 ] ) ;\n if ( tagLen < newTagLength ) {\n uprv_free ( tagBuf ) ;\n tagBuf = ( char * ) uprv_malloc ( newTagLength + 1 ) ;\n if ( tagBuf == NULL ) {\n * status = U_MEMORY_ALLOCATION_ERROR ;\n ultag_close ( t ) ;\n return NULL ;\n }\n t -> buf = tagBuf ;\n tagLen = newTagLength ;\n }\n uprv_strcpy ( t -> buf , GRANDFATHERED [ i + 1 ] ) ;\n break ;\n }\n }\n next = LANG | PRIV ;\n pNext = pLastGoodPosition = tagBuf ;\n extlangIdx = 0 ;\n pExtension = NULL ;\n pExtValueSubtag = NULL ;\n pExtValueSubtagEnd = NULL ;\n while ( pNext ) {\n char * pSep ;\n pSubtag = pNext ;\n pSep = pSubtag ;\n while ( * pSep ) {\n if ( * pSep == SEP ) {\n break ;\n }\n pSep ++ ;\n }\n if ( * pSep == 0 ) {\n pNext = NULL ;\n }\n else {\n pNext = pSep + 1 ;\n }\n subtagLen = ( int32_t ) ( pSep - pSubtag ) ;\n if ( next & LANG ) {\n if ( _isLanguageSubtag ( pSubtag , subtagLen ) ) {\n * pSep = 0 ;\n t -> language = T_CString_toLowerCase ( pSubtag ) ;\n pLastGoodPosition = pSep ;\n next = EXTL | SCRT | REGN | VART | EXTS | PRIV ;\n continue ;\n }\n }\n if ( next & EXTL ) {\n if ( _isExtlangSubtag ( pSubtag , subtagLen ) ) {\n * pSep = 0 ;\n t -> extlang [ extlangIdx ++ ] = T_CString_toLowerCase ( pSubtag ) ;\n pLastGoodPosition = pSep ;\n if ( extlangIdx < 3 ) {\n next = EXTL | SCRT | REGN | VART | EXTS | PRIV ;\n }\n else {\n next = SCRT | REGN | VART | EXTS | PRIV ;\n }\n continue ;\n }\n }\n if ( next & SCRT ) {\n if ( _isScriptSubtag ( pSubtag , subtagLen ) ) {\n char * p = pSubtag ;\n * pSep = 0 ;\n * p = uprv_toupper ( * p ) ;\n p ++ ;\n for ( ;\n * p ;\n p ++ ) {\n * p = uprv_tolower ( * p ) ;\n }\n t -> script = pSubtag ;\n pLastGoodPosition = pSep ;\n next = REGN | VART | EXTS | PRIV ;\n continue ;\n }\n }\n if ( next & REGN ) {\n if ( _isRegionSubtag ( pSubtag , subtagLen ) ) {\n * pSep = 0 ;\n t -> region = T_CString_toUpperCase ( pSubtag ) ;\n pLastGoodPosition = pSep ;\n next = VART | EXTS | PRIV ;\n continue ;\n }\n }\n if ( next & VART ) {\n if ( _isVariantSubtag ( pSubtag , subtagLen ) || ( privateuseVar && _isPrivateuseVariantSubtag ( pSubtag , subtagLen ) ) ) {\n VariantListEntry * var ;\n UBool isAdded ;\n var = ( VariantListEntry * ) uprv_malloc ( sizeof ( VariantListEntry ) ) ;\n if ( var == NULL ) {\n * status = U_MEMORY_ALLOCATION_ERROR ;\n goto error ;\n }\n * pSep = 0 ;\n var -> variant = T_CString_toUpperCase ( pSubtag ) ;\n isAdded = _addVariantToList ( & ( t -> variants ) , var ) ;\n if ( ! isAdded ) {\n uprv_free ( var ) ;\n break ;\n }\n pLastGoodPosition = pSep ;\n next = VART | EXTS | PRIV ;\n continue ;\n }\n }\n if ( next & EXTS ) {\n if ( _isExtensionSingleton ( pSubtag , subtagLen ) ) {\n if ( pExtension != NULL ) {\n if ( pExtValueSubtag == NULL || pExtValueSubtagEnd == NULL ) {\n uprv_free ( pExtension ) ;\n pExtension = NULL ;\n break ;\n }\n * pExtValueSubtagEnd = 0 ;\n pExtension -> value = T_CString_toLowerCase ( pExtValueSubtag ) ;\n if ( _addExtensionToList ( & ( t -> extensions ) , pExtension , FALSE ) ) {\n pLastGoodPosition = pExtValueSubtagEnd ;\n }\n else {\n uprv_free ( pExtension ) ;\n pExtension = NULL ;\n break ;\n }\n }\n pExtension = ( ExtensionListEntry * ) uprv_malloc ( sizeof ( ExtensionListEntry ) ) ;\n if ( pExtension == NULL ) {\n * status = U_MEMORY_ALLOCATION_ERROR ;\n goto error ;\n }\n * pSep = 0 ;\n pExtension -> key = T_CString_toLowerCase ( pSubtag ) ;\n pExtension -> value = NULL ;\n pExtValueSubtag = NULL ;\n pExtValueSubtagEnd = NULL ;\n next = EXTV ;\n continue ;\n }\n }\n if ( next & EXTV ) {\n if ( _isExtensionSubtag ( pSubtag , subtagLen ) ) {\n if ( pExtValueSubtag == NULL ) {\n pExtValueSubtag = pSubtag ;\n }\n pExtValueSubtagEnd = pSep ;\n next = EXTS | EXTV | PRIV ;\n continue ;\n }\n }\n if ( next & PRIV ) {\n if ( uprv_tolower ( * pSubtag ) == PRIVATEUSE ) {\n char * pPrivuseVal ;\n if ( pExtension != NULL ) {\n if ( pExtValueSubtag == NULL || pExtValueSubtagEnd == NULL ) {\n uprv_free ( pExtension ) ;\n pExtension = NULL ;\n break ;\n }\n else {\n * pExtValueSubtagEnd = 0 ;\n pExtension -> value = T_CString_toLowerCase ( pExtValueSubtag ) ;\n if ( _addExtensionToList ( & ( t -> extensions ) , pExtension , FALSE ) ) {\n pLastGoodPosition = pExtValueSubtagEnd ;\n pExtension = NULL ;\n }\n else {\n uprv_free ( pExtension ) ;\n pExtension = NULL ;\n break ;\n }\n }\n }\n if ( pNext == NULL ) {\n break ;\n }\n pPrivuseVal = pNext ;\n while ( pNext ) {\n pSubtag = pNext ;\n pSep = pSubtag ;\n while ( * pSep ) {\n if ( * pSep == SEP ) {\n break ;\n }\n pSep ++ ;\n }\n if ( * pSep == 0 ) {\n pNext = NULL ;\n }\n else {\n pNext = pSep + 1 ;\n }\n subtagLen = ( int32_t ) ( pSep - pSubtag ) ;\n if ( uprv_strncmp ( pSubtag , PRIVUSE_VARIANT_PREFIX , uprv_strlen ( PRIVUSE_VARIANT_PREFIX ) ) == 0 ) {\n * pSep = 0 ;\n next = VART ;\n privateuseVar = TRUE ;\n break ;\n }\n else if ( _isPrivateuseValueSubtag ( pSubtag , subtagLen ) ) {\n pLastGoodPosition = pSep ;\n }\n else {\n break ;\n }\n }\n if ( next == VART ) {\n continue ;\n }\n if ( pLastGoodPosition - pPrivuseVal > 0 ) {\n * pLastGoodPosition = 0 ;\n t -> privateuse = T_CString_toLowerCase ( pPrivuseVal ) ;\n }\n break ;\n }\n break ;\n }\n break ;\n }\n if ( pExtension != NULL ) {\n if ( pExtValueSubtag == NULL || pExtValueSubtagEnd == NULL ) {\n uprv_free ( pExtension ) ;\n }\n else {\n * pExtValueSubtagEnd = 0 ;\n pExtension -> value = T_CString_toLowerCase ( pExtValueSubtag ) ;\n if ( _addExtensionToList ( & ( t -> extensions ) , pExtension , FALSE ) ) {\n pLastGoodPosition = pExtValueSubtagEnd ;\n }\n else {\n uprv_free ( pExtension ) ;\n }\n }\n }\n if ( parsedLen != NULL ) {\n * parsedLen = ( grandfatheredLen > 0 ) ? grandfatheredLen : ( int32_t ) ( pLastGoodPosition - t -> buf ) ;\n }\n return t ;\n error : ultag_close ( t ) ;\n return NULL ;\n }", "idx": 21906}
{"hash": -7076754245473579218, "project": "chrome", "size": 5, "label": 0, "functionSource": "static void evhttp_connection_retry ( int fd , short what , void * arg ) {\n struct evhttp_connection * evcon = arg ;\n evcon -> state = EVCON_DISCONNECTED ;\n evhttp_connection_connect ( evcon ) ;\n }", "idx": 21907}
{"hash": 3584320764213684062, "project": "debian", "size": 4, "label": 0, "functionSource": "static void vvalue_strbuf_append_str ( wmem_strbuf_t * strbuf , void * ptr ) {\n struct data_str * str = ( struct data_str * ) ptr ;\n wmem_strbuf_append_printf ( strbuf , \"\\\"%s\\\"\" , str -> str ) ;\n }", "idx": 21908}
{"hash": 3668456668028959955, "project": "debian", "size": 8, "label": 0, "functionSource": "static VALUE mObject_to_json ( int argc , VALUE * argv , VALUE self ) {\n VALUE state ;\n VALUE string = rb_funcall ( self , i_to_s , 0 ) ;\n rb_scan_args ( argc , argv , \"01\" , & state ) ;\n Check_Type ( string , T_STRING ) ;\n state = cState_from_state_s ( cState , state ) ;\n return cState_partial_generate ( state , string ) ;\n }", "idx": 21909}
{"hash": -2607754285145856562, "project": "debian", "size": 32, "label": 0, "functionSource": "static int get_num_opt ( struct archive_write * a , int * num , int high , int low , const char * key , const char * value ) {\n const char * p = value ;\n int data = 0 ;\n int neg = 0 ;\n if ( p == NULL ) {\n archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , \"Invalid value(empty) for option ``%s''\" , key ) ;\n return ( ARCHIVE_FATAL ) ;\n }\n if ( * p == '-' ) {\n neg = 1 ;\n p ++ ;\n }\n while ( * p ) {\n if ( * p >= '0' && * p <= '9' ) data = data * 10 + * p - '0' ;\n else {\n archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , \"Invalid value for option ``%s''\" , key ) ;\n return ( ARCHIVE_FATAL ) ;\n }\n if ( data > high ) {\n archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , \"Invalid value(over %d) for \" \"option ``%s''\" , high , key ) ;\n return ( ARCHIVE_FATAL ) ;\n }\n if ( data < low ) {\n archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , \"Invalid value(under %d) for \" \"option ``%s''\" , low , key ) ;\n return ( ARCHIVE_FATAL ) ;\n }\n p ++ ;\n }\n if ( neg ) data *= - 1 ;\n * num = data ;\n return ( ARCHIVE_OK ) ;\n }", "idx": 21910}
{"hash": 6584173680685889333, "project": "debian", "size": 40, "label": 1, "functionSource": "int zrestore ( i_ctx_t * i_ctx_p ) {\n os_ptr op = osp ;\n alloc_save_t * asave ;\n bool last ;\n vm_save_t * vmsave ;\n int code = restore_check_operand ( op , & asave , idmemory ) ;\n if ( code < 0 ) return code ;\n if_debug2m ( 'u' , imemory , \"[u]vmrestore 0x%lx, id = %lu\\n\" , ( ulong ) alloc_save_client_data ( asave ) , ( ulong ) op -> value . saveid ) ;\n if ( I_VALIDATE_BEFORE_RESTORE ) ivalidate_clean_spaces ( i_ctx_p ) ;\n osp -- ;\n {\n int code ;\n if ( ( code = restore_check_stack ( i_ctx_p , & o_stack , asave , false ) ) < 0 || ( code = restore_check_stack ( i_ctx_p , & e_stack , asave , true ) ) < 0 || ( code = restore_check_stack ( i_ctx_p , & d_stack , asave , false ) ) < 0 ) {\n osp ++ ;\n return code ;\n }\n }\n restore_fix_stack ( i_ctx_p , & o_stack , asave , false ) ;\n restore_fix_stack ( i_ctx_p , & e_stack , asave , true ) ;\n restore_fix_stack ( i_ctx_p , & d_stack , asave , false ) ;\n do {\n vmsave = alloc_save_client_data ( alloc_save_current ( idmemory ) ) ;\n gs_grestoreall_for_restore ( igs , vmsave -> gsave ) ;\n vmsave -> gsave = 0 ;\n code = alloc_restore_step_in ( idmemory , asave ) ;\n if ( code < 0 ) return code ;\n last = code ;\n }\n while ( ! last ) ;\n {\n uint space = icurrent_space ;\n ialloc_set_space ( idmemory , avm_local ) ;\n ifree_object ( vmsave , \"zrestore\" ) ;\n ialloc_set_space ( idmemory , space ) ;\n }\n dict_set_top ( ) ;\n if ( I_VALIDATE_AFTER_RESTORE ) ivalidate_clean_spaces ( i_ctx_p ) ;\n i_ctx_p -> LockFilePermissions = false ;\n return 0 ;\n }", "idx": 21911}
{"hash": 4180964683905830761, "project": "debian", "size": 18, "label": 0, "functionSource": "static int selinux_shm_shmctl ( struct shmid_kernel * shp , int cmd ) {\n int perms ;\n int err ;\n switch ( cmd ) {\n case IPC_INFO : case SHM_INFO : return task_has_system ( current , SYSTEM__IPC_INFO ) ;\n case IPC_STAT : case SHM_STAT : perms = SHM__GETATTR | SHM__ASSOCIATE ;\n break ;\n case IPC_SET : perms = SHM__SETATTR ;\n break ;\n case SHM_LOCK : case SHM_UNLOCK : perms = SHM__LOCK ;\n break ;\n case IPC_RMID : perms = SHM__DESTROY ;\n break ;\n default : return 0 ;\n }\n err = ipc_has_perm ( & shp -> shm_perm , perms ) ;\n return err ;\n }", "idx": 21912}
{"hash": 229962612204196999, "project": "debian", "size": 19, "label": 0, "functionSource": "static void one_remote_ref ( const char * refname ) {\n struct ref * ref ;\n struct object * obj ;\n ref = alloc_ref ( refname ) ;\n if ( http_fetch_ref ( repo -> url , ref ) != 0 ) {\n fprintf ( stderr , \"Unable to fetch ref %s from %s\\n\" , refname , repo -> url ) ;\n free ( ref ) ;\n return ;\n }\n if ( repo -> can_update_info_refs && ! has_object_file ( & ref -> old_oid ) ) {\n obj = lookup_unknown_object ( ref -> old_oid . hash ) ;\n if ( obj ) {\n fprintf ( stderr , \" fetch %s for %s\\n\" , oid_to_hex ( & ref -> old_oid ) , refname ) ;\n add_fetch_request ( obj ) ;\n }\n }\n ref -> next = remote_refs ;\n remote_refs = ref ;\n }", "idx": 21913}
{"hash": -3740862514502467070, "project": "debian", "size": 70, "label": 0, "functionSource": "static void dumppost ( struct alltabs * at , SplineFont * sf , enum fontformat format ) {\n int pos , i , j , shouldbe ;\n int shorttable = ( format == ff_otf || format == ff_otfcid || ( at -> gi . flags & ttf_flag_shortps ) ) ;\n uint32 here ;\n at -> post = tmpfile ( ) ;\n putlong ( at -> post , shorttable ? 0x00030000 : 0x00020000 ) ;\n putfixed ( at -> post , sf -> italicangle ) ;\n putshort ( at -> post , sf -> upos - sf -> uwidth / 2 ) ;\n putshort ( at -> post , sf -> uwidth ) ;\n putlong ( at -> post , at -> isfixed ) ;\n putlong ( at -> post , 0 ) ;\n putlong ( at -> post , 0 ) ;\n putlong ( at -> post , 0 ) ;\n putlong ( at -> post , 0 ) ;\n if ( ! shorttable ) {\n here = ftell ( at -> post ) ;\n putshort ( at -> post , at -> maxp . numGlyphs ) ;\n shouldbe = 0 ;\n for ( i = 0 , pos = 0 ;\n i < at -> maxp . numGlyphs ;\n ++ i ) {\n if ( at -> gi . bygid [ i ] != - 1 && sf -> glyphs [ at -> gi . bygid [ i ] ] != NULL ) {\n SplineChar * sc = sf -> glyphs [ at -> gi . bygid [ i ] ] ;\n while ( i > shouldbe ) {\n if ( shouldbe == 0 ) putshort ( at -> post , 0 ) ;\n else if ( shouldbe == 1 ) putshort ( at -> post , 1 ) ;\n else if ( shouldbe == 2 ) putshort ( at -> post , 2 ) ;\n else putshort ( at -> post , 0 ) ;\n ++ shouldbe ;\n }\n if ( strcmp ( sc -> name , \".notdef\" ) == 0 ) putshort ( at -> post , 0 ) ;\n else {\n for ( j = 0 ;\n j < 258 ;\n ++ j ) if ( strcmp ( sc -> name , ttfstandardnames [ j ] ) == 0 ) break ;\n if ( j != 258 ) putshort ( at -> post , j ) ;\n else {\n putshort ( at -> post , pos + 258 ) ;\n ++ pos ;\n }\n }\n ++ shouldbe ;\n }\n }\n if ( shouldbe != at -> maxp . numGlyphs ) {\n fseek ( at -> post , here , SEEK_SET ) ;\n putshort ( at -> post , shouldbe ) ;\n fseek ( at -> post , 0 , SEEK_END ) ;\n }\n if ( pos != 0 ) {\n for ( i = 0 ;\n i < at -> maxp . numGlyphs ;\n ++ i ) if ( at -> gi . bygid [ i ] != - 1 ) {\n SplineChar * sc = sf -> glyphs [ at -> gi . bygid [ i ] ] ;\n if ( strcmp ( sc -> name , \".notdef\" ) == 0 ) ;\n else {\n for ( j = 0 ;\n j < 258 ;\n ++ j ) if ( strcmp ( sc -> name , ttfstandardnames [ j ] ) == 0 ) break ;\n if ( j != 258 ) ;\n else dumppstr ( at -> post , sc -> name ) ;\n }\n }\n }\n }\n at -> postlen = ftell ( at -> post ) ;\n if ( ( at -> postlen & 3 ) != 0 ) for ( j = 4 - ( at -> postlen & 3 ) ;\n j > 0 ;\n -- j ) putc ( '\\0' , at -> post ) ;\n }", "idx": 21914}
{"hash": -7724655445309867912, "project": "debian", "size": 3, "label": 0, "functionSource": "void cpu_set_debug_excp_handler ( CPUDebugExcpHandler * handler ) {\n debug_excp_handler = handler ;\n }", "idx": 21915}
{"hash": -6068399010699045437, "project": "debian", "size": 20, "label": 0, "functionSource": "static void lfe_interpolation_fir ( DCAContext * s , int decimation_select , int num_deci_sample , float * samples_in , float * samples_out , float scale ) {\n int decifactor ;\n const float * prCoeff ;\n int deciindex ;\n if ( decimation_select == 1 ) {\n decifactor = 64 ;\n prCoeff = lfe_fir_128 ;\n }\n else {\n decifactor = 32 ;\n prCoeff = lfe_fir_64 ;\n }\n for ( deciindex = 0 ;\n deciindex < num_deci_sample ;\n deciindex ++ ) {\n s -> dcadsp . lfe_fir ( samples_out , samples_in , prCoeff , decifactor , scale ) ;\n samples_in ++ ;\n samples_out += 2 * decifactor ;\n }\n }", "idx": 21916}
{"hash": 9046191708840218774, "project": "debian", "size": 10, "label": 0, "functionSource": "static int tipc_nl_compat_link_reset_stats ( struct tipc_nl_compat_cmd_doit * cmd , struct sk_buff * skb , struct tipc_nl_compat_msg * msg ) {\n char * name ;\n struct nlattr * link ;\n name = ( char * ) TLV_DATA ( msg -> req ) ;\n link = nla_nest_start ( skb , TIPC_NLA_LINK ) ;\n if ( ! link ) return - EMSGSIZE ;\n if ( nla_put_string ( skb , TIPC_NLA_LINK_NAME , name ) ) return - EMSGSIZE ;\n nla_nest_end ( skb , link ) ;\n return 0 ;\n }", "idx": 21917}
{"hash": -2607754285145856562, "project": "debian", "size": 6, "label": 0, "functionSource": "static void set_digit ( unsigned char * p , size_t s , int value ) {\n while ( s -- ) {\n p [ s ] = '0' + ( value % 10 ) ;\n value /= 10 ;\n }\n }", "idx": 21918}
{"hash": 4313735399044135249, "project": "debian", "size": 26, "label": 0, "functionSource": "static int psf_open_fd ( PSF_FILE * pfile ) {\n int fd , oflag , mode ;\n if ( sizeof ( sf_count_t ) != 8 ) {\n puts ( \"\\n\\n*** Fatal error : sizeof (sf_count_t) != 8\" ) ;\n puts ( \"*** This means that libsndfile was not configured correctly.\\n\" ) ;\n exit ( 1 ) ;\n }\n ;\n switch ( pfile -> mode ) {\n case SFM_READ : oflag = O_RDONLY | O_BINARY ;\n mode = 0 ;\n break ;\n case SFM_WRITE : oflag = O_WRONLY | O_CREAT | O_TRUNC | O_BINARY ;\n mode = S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ;\n break ;\n case SFM_RDWR : oflag = O_RDWR | O_CREAT | O_BINARY ;\n mode = S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ;\n break ;\n default : return - SFE_BAD_OPEN_MODE ;\n break ;\n }\n ;\n if ( mode == 0 ) fd = open ( pfile -> path . c , oflag ) ;\n else fd = open ( pfile -> path . c , oflag , mode ) ;\n return fd ;\n }", "idx": 21919}
{"hash": 8572106347813672436, "project": "debian", "size": 72, "label": 0, "functionSource": "static int pfkey_getspi ( struct sock * sk , struct sk_buff * skb , const struct sadb_msg * hdr , void * const * ext_hdrs ) {\n struct net * net = sock_net ( sk ) ;\n struct sk_buff * resp_skb ;\n struct sadb_x_sa2 * sa2 ;\n struct sadb_address * saddr , * daddr ;\n struct sadb_msg * out_hdr ;\n struct sadb_spirange * range ;\n struct xfrm_state * x = NULL ;\n int mode ;\n int err ;\n u32 min_spi , max_spi ;\n u32 reqid ;\n u8 proto ;\n unsigned short family ;\n xfrm_address_t * xsaddr = NULL , * xdaddr = NULL ;\n if ( ! present_and_same_family ( ext_hdrs [ SADB_EXT_ADDRESS_SRC - 1 ] , ext_hdrs [ SADB_EXT_ADDRESS_DST - 1 ] ) ) return - EINVAL ;\n proto = pfkey_satype2proto ( hdr -> sadb_msg_satype ) ;\n if ( proto == 0 ) return - EINVAL ;\n if ( ( sa2 = ext_hdrs [ SADB_X_EXT_SA2 - 1 ] ) != NULL ) {\n mode = pfkey_mode_to_xfrm ( sa2 -> sadb_x_sa2_mode ) ;\n if ( mode < 0 ) return - EINVAL ;\n reqid = sa2 -> sadb_x_sa2_reqid ;\n }\n else {\n mode = 0 ;\n reqid = 0 ;\n }\n saddr = ext_hdrs [ SADB_EXT_ADDRESS_SRC - 1 ] ;\n daddr = ext_hdrs [ SADB_EXT_ADDRESS_DST - 1 ] ;\n family = ( ( struct sockaddr * ) ( saddr + 1 ) ) -> sa_family ;\n switch ( family ) {\n case AF_INET : xdaddr = ( xfrm_address_t * ) & ( ( struct sockaddr_in * ) ( daddr + 1 ) ) -> sin_addr . s_addr ;\n xsaddr = ( xfrm_address_t * ) & ( ( struct sockaddr_in * ) ( saddr + 1 ) ) -> sin_addr . s_addr ;\n break ;\n # if IS_ENABLED ( CONFIG_IPV6 ) case AF_INET6 : xdaddr = ( xfrm_address_t * ) & ( ( struct sockaddr_in6 * ) ( daddr + 1 ) ) -> sin6_addr ;\n xsaddr = ( xfrm_address_t * ) & ( ( struct sockaddr_in6 * ) ( saddr + 1 ) ) -> sin6_addr ;\n break ;\n # endif }\n if ( hdr -> sadb_msg_seq ) {\n x = xfrm_find_acq_byseq ( net , DUMMY_MARK , hdr -> sadb_msg_seq ) ;\n if ( x && ! xfrm_addr_equal ( & x -> id . daddr , xdaddr , family ) ) {\n xfrm_state_put ( x ) ;\n x = NULL ;\n }\n }\n if ( ! x ) x = xfrm_find_acq ( net , & dummy_mark , mode , reqid , proto , xdaddr , xsaddr , 1 , family ) ;\n if ( x == NULL ) return - ENOENT ;\n min_spi = 0x100 ;\n max_spi = 0x0fffffff ;\n range = ext_hdrs [ SADB_EXT_SPIRANGE - 1 ] ;\n if ( range ) {\n min_spi = range -> sadb_spirange_min ;\n max_spi = range -> sadb_spirange_max ;\n }\n err = xfrm_alloc_spi ( x , min_spi , max_spi ) ;\n resp_skb = err ? ERR_PTR ( err ) : pfkey_xfrm_state2msg ( x ) ;\n if ( IS_ERR ( resp_skb ) ) {\n xfrm_state_put ( x ) ;\n return PTR_ERR ( resp_skb ) ;\n }\n out_hdr = ( struct sadb_msg * ) resp_skb -> data ;\n out_hdr -> sadb_msg_version = hdr -> sadb_msg_version ;\n out_hdr -> sadb_msg_type = SADB_GETSPI ;\n out_hdr -> sadb_msg_satype = pfkey_proto2satype ( proto ) ;\n out_hdr -> sadb_msg_errno = 0 ;\n out_hdr -> sadb_msg_reserved = 0 ;\n out_hdr -> sadb_msg_seq = hdr -> sadb_msg_seq ;\n out_hdr -> sadb_msg_pid = hdr -> sadb_msg_pid ;\n xfrm_state_put ( x ) ;\n pfkey_broadcast ( resp_skb , GFP_KERNEL , BROADCAST_ONE , sk , net ) ;\n return 0 ;\n }", "idx": 21920}
{"hash": -341028540041678099, "project": "debian", "size": 6, "label": 0, "functionSource": "static RETSIGTYPE abortcmd ( int sig ) {\n if ( current_output == stdout ) ( void ) fflush ( stdout ) ;\n putc ( '\\n' , stderr ) ;\n ( void ) fflush ( stderr ) ;\n if ( jump ) longjmp ( interrupt_buf , 1 ) ;\n }", "idx": 21921}
{"hash": -3502382902740740634, "project": "debian", "size": 13, "label": 0, "functionSource": "static gint check_diameter ( tvbuff_t * tvb ) {\n guint32 diam_len ;\n guint8 flags ;\n if ( tvb_captured_length ( tvb ) < 5 ) return NOT_ENOUGH_DATA ;\n if ( tvb_get_guint8 ( tvb , 0 ) != 1 ) return NOT_DIAMETER ;\n diam_len = tvb_get_ntoh24 ( tvb , 1 ) ;\n if ( diam_len > 65534 ) return NOT_DIAMETER ;\n if ( diam_len < 36 ) return NOT_DIAMETER ;\n flags = tvb_get_guint8 ( tvb , 4 ) ;\n if ( flags & 0x0f ) return NOT_DIAMETER ;\n if ( ( flags & DIAM_FLAGS_R ) && ( flags & DIAM_FLAGS_E ) ) return NOT_DIAMETER ;\n return IS_DIAMETER ;\n }", "idx": 21922}
{"hash": 2709342705526909410, "project": "debian", "size": 15, "label": 0, "functionSource": "int ssl_set_version_bound ( int method_version , int version , int * bound ) {\n if ( version == 0 ) {\n * bound = version ;\n return 1 ;\n }\n switch ( method_version ) {\n default : return 0 ;\n case TLS_ANY_VERSION : if ( version < SSL3_VERSION || version > TLS_MAX_VERSION ) return 0 ;\n break ;\n case DTLS_ANY_VERSION : if ( DTLS_VERSION_GT ( version , DTLS_MAX_VERSION ) || DTLS_VERSION_LT ( version , DTLS1_BAD_VER ) ) return 0 ;\n break ;\n }\n * bound = version ;\n return 1 ;\n }", "idx": 21923}
{"hash": -4555950263653671147, "project": "debian", "size": 5, "label": 0, "functionSource": "static PyObject * string_splitlines ( PyStringObject * self , PyObject * args ) {\n int keepends = 0 ;\n if ( ! PyArg_ParseTuple ( args , \"|i:splitlines\" , & keepends ) ) return NULL ;\n return stringlib_splitlines ( ( PyObject * ) self , PyString_AS_STRING ( self ) , PyString_GET_SIZE ( self ) , keepends ) ;\n }", "idx": 21924}
{"hash": 1859256631654516868, "project": "chrome", "size": 48, "label": 0, "functionSource": "int ff_init_poc ( H264Context * h , int pic_field_poc [ 2 ] , int * pic_poc ) {\n const int max_frame_num = 1 << h -> sps . log2_max_frame_num ;\n int field_poc [ 2 ] ;\n h -> frame_num_offset = h -> prev_frame_num_offset ;\n if ( h -> frame_num < h -> prev_frame_num ) h -> frame_num_offset += max_frame_num ;\n if ( h -> sps . poc_type == 0 ) {\n const int max_poc_lsb = 1 << h -> sps . log2_max_poc_lsb ;\n if ( h -> poc_lsb < h -> prev_poc_lsb && h -> prev_poc_lsb - h -> poc_lsb >= max_poc_lsb / 2 ) h -> poc_msb = h -> prev_poc_msb + max_poc_lsb ;\n else if ( h -> poc_lsb > h -> prev_poc_lsb && h -> prev_poc_lsb - h -> poc_lsb < - max_poc_lsb / 2 ) h -> poc_msb = h -> prev_poc_msb - max_poc_lsb ;\n else h -> poc_msb = h -> prev_poc_msb ;\n field_poc [ 0 ] = field_poc [ 1 ] = h -> poc_msb + h -> poc_lsb ;\n if ( h -> picture_structure == PICT_FRAME ) field_poc [ 1 ] += h -> delta_poc_bottom ;\n }\n else if ( h -> sps . poc_type == 1 ) {\n int abs_frame_num , expected_delta_per_poc_cycle , expectedpoc ;\n int i ;\n if ( h -> sps . poc_cycle_length != 0 ) abs_frame_num = h -> frame_num_offset + h -> frame_num ;\n else abs_frame_num = 0 ;\n if ( h -> nal_ref_idc == 0 && abs_frame_num > 0 ) abs_frame_num -- ;\n expected_delta_per_poc_cycle = 0 ;\n for ( i = 0 ;\n i < h -> sps . poc_cycle_length ;\n i ++ ) expected_delta_per_poc_cycle += h -> sps . offset_for_ref_frame [ i ] ;\n if ( abs_frame_num > 0 ) {\n int poc_cycle_cnt = ( abs_frame_num - 1 ) / h -> sps . poc_cycle_length ;\n int frame_num_in_poc_cycle = ( abs_frame_num - 1 ) % h -> sps . poc_cycle_length ;\n expectedpoc = poc_cycle_cnt * expected_delta_per_poc_cycle ;\n for ( i = 0 ;\n i <= frame_num_in_poc_cycle ;\n i ++ ) expectedpoc = expectedpoc + h -> sps . offset_for_ref_frame [ i ] ;\n }\n else expectedpoc = 0 ;\n if ( h -> nal_ref_idc == 0 ) expectedpoc = expectedpoc + h -> sps . offset_for_non_ref_pic ;\n field_poc [ 0 ] = expectedpoc + h -> delta_poc [ 0 ] ;\n field_poc [ 1 ] = field_poc [ 0 ] + h -> sps . offset_for_top_to_bottom_field ;\n if ( h -> picture_structure == PICT_FRAME ) field_poc [ 1 ] += h -> delta_poc [ 1 ] ;\n }\n else {\n int poc = 2 * ( h -> frame_num_offset + h -> frame_num ) ;\n if ( ! h -> nal_ref_idc ) poc -- ;\n field_poc [ 0 ] = poc ;\n field_poc [ 1 ] = poc ;\n }\n if ( h -> picture_structure != PICT_BOTTOM_FIELD ) pic_field_poc [ 0 ] = field_poc [ 0 ] ;\n if ( h -> picture_structure != PICT_TOP_FIELD ) pic_field_poc [ 1 ] = field_poc [ 1 ] ;\n * pic_poc = FFMIN ( pic_field_poc [ 0 ] , pic_field_poc [ 1 ] ) ;\n return 0 ;\n }", "idx": 21925}
{"hash": 5651124822185017997, "project": "debian", "size": 7, "label": 0, "functionSource": "static VALUE ossl_x509name_hash ( VALUE self ) {\n X509_NAME * name ;\n unsigned long hash ;\n GetX509Name ( self , name ) ;\n hash = X509_NAME_hash ( name ) ;\n return ULONG2NUM ( hash ) ;\n }", "idx": 21926}
{"hash": 2578089348587614328, "project": "debian", "size": 3, "label": 0, "functionSource": "EC_KEY * d2i_ECPrivateKey_bio ( BIO * bp , EC_KEY * * eckey ) {\n return ASN1_d2i_bio_of ( EC_KEY , EC_KEY_new , d2i_ECPrivateKey , bp , eckey ) ;\n }", "idx": 21927}
{"hash": -9129169564020831625, "project": "debian", "size": 13, "label": 0, "functionSource": "static int dsa_cb ( int operation , ASN1_VALUE * * pval , const ASN1_ITEM * it , void * exarg ) {\n if ( operation == ASN1_OP_NEW_PRE ) {\n * pval = ( ASN1_VALUE * ) DSA_new ( ) ;\n if ( * pval ) return 2 ;\n return 0 ;\n }\n else if ( operation == ASN1_OP_FREE_PRE ) {\n DSA_free ( ( DSA * ) * pval ) ;\n * pval = NULL ;\n return 2 ;\n }\n return 1 ;\n }", "idx": 21928}
{"hash": 2058562589071273546, "project": "chrome", "size": 8, "label": 1, "functionSource": "int main ( int argc , char * * argv ) {\n struct event signal_int ;\n event_init ( ) ;\n event_set ( & signal_int , SIGINT , EV_SIGNAL | EV_PERSIST , signal_cb , & signal_int ) ;\n event_add ( & signal_int , NULL ) ;\n event_dispatch ( ) ;\n return ( 0 ) ;\n }", "idx": 21929}
{"hash": 5045872831385413038, "project": "debian", "size": 6, "label": 0, "functionSource": "static int dissect_btgatt_nordic_uart_rx ( tvbuff_t * tvb , packet_info * pinfo _U_ , proto_tree * tree , void * data ) {\n btatt_data_t * att_data = ( btatt_data_t * ) data ;\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) return - 1 ;\n proto_tree_add_item ( tree , hf_gatt_nordic_uart_rx , tvb , 0 , tvb_captured_length ( tvb ) , ENC_ASCII | ENC_NA ) ;\n return tvb_captured_length ( tvb ) ;\n }", "idx": 21930}
{"hash": -4844249011537705593, "project": "chrome", "size": 4, "label": 1, "functionSource": "static void sbr_hf_apply_noise_1 ( float ( * Y ) [ 2 ] , const float * s_m , const float * q_filt , int noise , int kx , int m_max ) {\n float phi_sign = 1 - 2 * ( kx & 1 ) ;\n sbr_hf_apply_noise ( Y , s_m , q_filt , noise , 0.0 , phi_sign , m_max ) ;\n }", "idx": 21931}
{"hash": 4511225370772574632, "project": "debian", "size": 7, "label": 0, "functionSource": "void uwsgi_php_set ( char * opt ) {\n uwsgi_sapi_module . ini_entries = realloc ( uwsgi_sapi_module . ini_entries , uphp . ini_size + strlen ( opt ) + 2 ) ;\n memcpy ( uwsgi_sapi_module . ini_entries + uphp . ini_size , opt , strlen ( opt ) ) ;\n uphp . ini_size += strlen ( opt ) + 1 ;\n uwsgi_sapi_module . ini_entries [ uphp . ini_size - 1 ] = '\\n' ;\n uwsgi_sapi_module . ini_entries [ uphp . ini_size ] = 0 ;\n }", "idx": 21932}
{"hash": -2386031673786599357, "project": "debian", "size": 5, "label": 0, "functionSource": "static void gpgsm_set_status_handler ( void * engine , engine_status_handler_t fnc , void * fnc_value ) {\n engine_gpgsm_t gpgsm = engine ;\n gpgsm -> status . fnc = fnc ;\n gpgsm -> status . fnc_value = fnc_value ;\n }", "idx": 21933}
{"hash": 7092216800726729686, "project": "debian", "size": 14, "label": 0, "functionSource": "static int dissect_h245_T_nonCollapsingRaw ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 689 \"../../asn1/h245/h245.cnf\" tvbuff_t * value_tvb ;\n gef_ctx_t * parent_gefx ;\n gef_ctx_t * gefx ;\n parent_gefx = gef_ctx_get ( actx -> private_data ) ;\n actx -> private_data = gef_ctx_alloc ( parent_gefx , \"nonCollapsingRaw\" ) ;\n offset = dissect_per_octet_string ( tvb , offset , actx , tree , hf_index , NO_BOUND , NO_BOUND , FALSE , & value_tvb ) ;\n gefx = gef_ctx_get ( actx -> private_data ) ;\n if ( gefx ) {\n dissector_try_string ( gef_content_dissector_table , gefx -> key , value_tvb , actx -> pinfo , tree , actx ) ;\n }\n actx -> private_data = parent_gefx ;\n return offset ;\n }", "idx": 21934}
{"hash": 1223258652239369123, "project": "debian", "size": 8, "label": 0, "functionSource": "static void spl_filesystem_dir_it_rewind ( zend_object_iterator * iter TSRMLS_DC ) {\n spl_filesystem_object * object = spl_filesystem_iterator_to_object ( ( spl_filesystem_iterator * ) iter ) ;\n object -> u . dir . index = 0 ;\n if ( object -> u . dir . dirp ) {\n php_stream_rewinddir ( object -> u . dir . dirp ) ;\n }\n spl_filesystem_dir_read ( object TSRMLS_CC ) ;\n }", "idx": 21935}
{"hash": 2066486429767443123, "project": "debian", "size": 44, "label": 1, "functionSource": "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n CamtasiaContext * const c = avctx -> priv_data ;\n const unsigned char * encoded = buf ;\n int zret ;\n int ret , len = buf_size ;\n if ( c -> pic . data [ 0 ] ) avctx -> release_buffer ( avctx , & c -> pic ) ;\n c -> pic . reference = 1 ;\n c -> pic . buffer_hints = FF_BUFFER_HINTS_VALID ;\n if ( ( ret = ff_get_buffer ( avctx , & c -> pic ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n zret = inflateReset ( & c -> zstream ) ;\n if ( zret != Z_OK ) {\n av_log ( avctx , AV_LOG_ERROR , \"Inflate reset error: %d\\n\" , zret ) ;\n return AVERROR_UNKNOWN ;\n }\n c -> zstream . next_in = encoded ;\n c -> zstream . avail_in = len ;\n c -> zstream . next_out = c -> decomp_buf ;\n c -> zstream . avail_out = c -> decomp_size ;\n zret = inflate ( & c -> zstream , Z_FINISH ) ;\n if ( ( zret != Z_OK ) && ( zret != Z_STREAM_END ) && ( zret != Z_DATA_ERROR ) ) {\n av_log ( avctx , AV_LOG_ERROR , \"Inflate error: %d\\n\" , zret ) ;\n return AVERROR_UNKNOWN ;\n }\n if ( zret != Z_DATA_ERROR ) {\n bytestream2_init ( & c -> gb , c -> decomp_buf , c -> decomp_size - c -> zstream . avail_out ) ;\n ff_msrle_decode ( avctx , ( AVPicture * ) & c -> pic , c -> bpp , & c -> gb ) ;\n }\n if ( c -> avctx -> pix_fmt == AV_PIX_FMT_PAL8 ) {\n const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;\n if ( pal ) {\n c -> pic . palette_has_changed = 1 ;\n memcpy ( c -> pal , pal , AVPALETTE_SIZE ) ;\n }\n memcpy ( c -> pic . data [ 1 ] , c -> pal , AVPALETTE_SIZE ) ;\n }\n * got_frame = 1 ;\n * ( AVFrame * ) data = c -> pic ;\n return buf_size ;\n }", "idx": 21936}
{"hash": 5991533509192663951, "project": "debian", "size": 30, "label": 0, "functionSource": "mbfl_encoding_detector * mbfl_encoding_detector_new ( enum mbfl_no_encoding * elist , int elistsz , int strict ) {\n mbfl_encoding_detector * identd ;\n int i , num ;\n mbfl_identify_filter * filter ;\n if ( elist == NULL || elistsz <= 0 ) {\n return NULL ;\n }\n identd = ( mbfl_encoding_detector * ) mbfl_malloc ( sizeof ( mbfl_encoding_detector ) ) ;\n if ( identd == NULL ) {\n return NULL ;\n }\n identd -> filter_list = ( mbfl_identify_filter * * ) mbfl_calloc ( elistsz , sizeof ( mbfl_identify_filter * ) ) ;\n if ( identd -> filter_list == NULL ) {\n mbfl_free ( identd ) ;\n return NULL ;\n }\n i = 0 ;\n num = 0 ;\n while ( i < elistsz ) {\n filter = mbfl_identify_filter_new ( elist [ i ] ) ;\n if ( filter != NULL ) {\n identd -> filter_list [ num ] = filter ;\n num ++ ;\n }\n i ++ ;\n }\n identd -> filter_list_size = num ;\n identd -> strict = strict ;\n return identd ;\n }", "idx": 21937}
{"hash": -398565394354770780, "project": "debian", "size": 16, "label": 0, "functionSource": "static void usb_ohci_exit ( PCIDevice * dev ) {\n OHCIPCIState * ohci = PCI_OHCI ( dev ) ;\n OHCIState * s = & ohci -> state ;\n trace_usb_ohci_exit ( s -> name ) ;\n ohci_bus_stop ( s ) ;\n if ( s -> async_td ) {\n usb_cancel_packet ( & s -> usb_packet ) ;\n s -> async_td = 0 ;\n }\n ohci_stop_endpoints ( s ) ;\n if ( ! ohci -> masterbus ) {\n usb_bus_release ( & s -> bus ) ;\n }\n timer_del ( s -> eof_timer ) ;\n timer_free ( s -> eof_timer ) ;\n }", "idx": 21938}
{"hash": 1700977331036764538, "project": "debian", "size": 35, "label": 0, "functionSource": "int EVP_DecryptUpdate ( EVP_CIPHER_CTX * ctx , unsigned char * out , int * outl , const unsigned char * in , int inl ) {\n int fix_len ;\n unsigned int b ;\n if ( ctx -> cipher -> flags & EVP_CIPH_FLAG_CUSTOM_CIPHER ) {\n fix_len = ctx -> cipher -> do_cipher ( ctx , out , in , inl ) ;\n if ( fix_len < 0 ) {\n * outl = 0 ;\n return 0 ;\n }\n else * outl = fix_len ;\n return 1 ;\n }\n if ( inl <= 0 ) {\n * outl = 0 ;\n return inl == 0 ;\n }\n if ( ctx -> flags & EVP_CIPH_NO_PADDING ) return EVP_EncryptUpdate ( ctx , out , outl , in , inl ) ;\n b = ctx -> cipher -> block_size ;\n OPENSSL_assert ( b <= sizeof ctx -> final ) ;\n if ( ctx -> final_used ) {\n memcpy ( out , ctx -> final , b ) ;\n out += b ;\n fix_len = 1 ;\n }\n else fix_len = 0 ;\n if ( ! EVP_EncryptUpdate ( ctx , out , outl , in , inl ) ) return 0 ;\n if ( b > 1 && ! ctx -> buf_len ) {\n * outl -= b ;\n ctx -> final_used = 1 ;\n memcpy ( ctx -> final , & out [ * outl ] , b ) ;\n }\n else ctx -> final_used = 0 ;\n if ( fix_len ) * outl += b ;\n return 1 ;\n }", "idx": 21939}
{"hash": 5045171829429605074, "project": "debian", "size": 43, "label": 0, "functionSource": "static int zeqproc ( i_ctx_t * i_ctx_p ) {\n os_ptr op = osp ;\n ref2_t stack [ MAX_DEPTH + 1 ] ;\n ref2_t * top = stack ;\n if ( ref_stack_count ( & o_stack ) < 2 ) return_error ( gs_error_stackunderflow ) ;\n if ( ! r_is_array ( op - 1 ) || ! r_is_array ( op ) ) {\n return_error ( gs_error_typecheck ) ;\n }\n make_array ( & stack [ 0 ] . proc1 , 0 , 1 , op - 1 ) ;\n make_array ( & stack [ 0 ] . proc2 , 0 , 1 , op ) ;\n for ( ;\n ;\n ) {\n long i ;\n if ( r_size ( & top -> proc1 ) == 0 ) {\n if ( top == stack ) {\n make_true ( op - 1 ) ;\n pop ( 1 ) ;\n return 0 ;\n }\n -- top ;\n continue ;\n }\n i = r_size ( & top -> proc1 ) - 1 ;\n array_get ( imemory , & top -> proc1 , i , & top [ 1 ] . proc1 ) ;\n array_get ( imemory , & top -> proc2 , i , & top [ 1 ] . proc2 ) ;\n r_dec_size ( & top -> proc1 , 1 ) ;\n ++ top ;\n # if 0 if ( r_has_attr ( & top -> proc1 , a_executable ) != r_has_attr ( & top -> proc2 , a_executable ) ) break ;\n # endif if ( obj_eq ( imemory , & top -> proc1 , & top -> proc2 ) ) {\n if ( r_type ( & top -> proc1 ) != r_type ( & top -> proc2 ) && ( r_type ( & top -> proc1 ) == t_name || r_type ( & top -> proc2 ) == t_name ) ) break ;\n -- top ;\n continue ;\n }\n if ( r_is_array ( & top -> proc1 ) && r_is_array ( & top -> proc2 ) && r_size ( & top -> proc1 ) == r_size ( & top -> proc2 ) && top < stack + ( MAX_DEPTH - 1 ) ) {\n continue ;\n }\n break ;\n }\n make_false ( op - 1 ) ;\n pop ( 1 ) ;\n return 0 ;\n }", "idx": 21940}
{"hash": -8028756826159773630, "project": "debian", "size": 9, "label": 0, "functionSource": "int parallel_restore ( ParallelArgs * args ) {\n ArchiveHandle * AH = args -> AH ;\n TocEntry * te = args -> te ;\n int status ;\n Assert ( AH -> connection != NULL ) ;\n AH -> public . n_errors = 0 ;\n status = restore_toc_entry ( AH , te , true ) ;\n return status ;\n }", "idx": 21941}
{"hash": -2607754285145856562, "project": "debian", "size": 4, "label": 0, "functionSource": "static void isofile_init_entry_list ( struct iso9660 * iso9660 ) {\n iso9660 -> all_file_list . first = NULL ;\n iso9660 -> all_file_list . last = & ( iso9660 -> all_file_list . first ) ;\n }", "idx": 21942}
{"hash": -5706788925640467782, "project": "chrome", "size": 50, "label": 1, "functionSource": "static void set_partition_range ( VP9_COMMON * cm , MACROBLOCKD * xd , int mi_row , int mi_col , BLOCK_SIZE bsize , BLOCK_SIZE * min_bs , BLOCK_SIZE * max_bs ) {\n int mi_width = num_8x8_blocks_wide_lookup [ bsize ] ;\n int mi_height = num_8x8_blocks_high_lookup [ bsize ] ;\n int idx , idy ;\n MODE_INFO * mi ;\n MODE_INFO * * prev_mi = & cm -> prev_mi_grid_visible [ mi_row * cm -> mi_stride + mi_col ] ;\n BLOCK_SIZE bs , min_size , max_size ;\n min_size = BLOCK_64X64 ;\n max_size = BLOCK_4X4 ;\n if ( prev_mi ) {\n for ( idy = 0 ;\n idy < mi_height ;\n ++ idy ) {\n for ( idx = 0 ;\n idx < mi_width ;\n ++ idx ) {\n mi = prev_mi [ idy * cm -> mi_stride + idx ] ;\n bs = mi ? mi -> mbmi . sb_type : bsize ;\n min_size = MIN ( min_size , bs ) ;\n max_size = MAX ( max_size , bs ) ;\n }\n }\n }\n if ( xd -> left_available ) {\n for ( idy = 0 ;\n idy < mi_height ;\n ++ idy ) {\n mi = xd -> mi [ idy * cm -> mi_stride - 1 ] ;\n bs = mi ? mi -> mbmi . sb_type : bsize ;\n min_size = MIN ( min_size , bs ) ;\n max_size = MAX ( max_size , bs ) ;\n }\n }\n if ( xd -> up_available ) {\n for ( idx = 0 ;\n idx < mi_width ;\n ++ idx ) {\n mi = xd -> mi [ idx - cm -> mi_stride ] ;\n bs = mi ? mi -> mbmi . sb_type : bsize ;\n min_size = MIN ( min_size , bs ) ;\n max_size = MAX ( max_size , bs ) ;\n }\n }\n if ( min_size == max_size ) {\n min_size = min_partition_size [ min_size ] ;\n max_size = max_partition_size [ max_size ] ;\n }\n * min_bs = min_size ;\n * max_bs = max_size ;\n }", "idx": 21943}
{"hash": 8320716512483418415, "project": "chrome", "size": 142, "label": 0, "functionSource": "static void idct16 ( const tran_low_t * input , tran_low_t * output ) {\n tran_low_t step1 [ 16 ] , step2 [ 16 ] ;\n tran_high_t temp1 , temp2 ;\n step1 [ 0 ] = input [ 0 / 2 ] ;\n step1 [ 1 ] = input [ 16 / 2 ] ;\n step1 [ 2 ] = input [ 8 / 2 ] ;\n step1 [ 3 ] = input [ 24 / 2 ] ;\n step1 [ 4 ] = input [ 4 / 2 ] ;\n step1 [ 5 ] = input [ 20 / 2 ] ;\n step1 [ 6 ] = input [ 12 / 2 ] ;\n step1 [ 7 ] = input [ 28 / 2 ] ;\n step1 [ 8 ] = input [ 2 / 2 ] ;\n step1 [ 9 ] = input [ 18 / 2 ] ;\n step1 [ 10 ] = input [ 10 / 2 ] ;\n step1 [ 11 ] = input [ 26 / 2 ] ;\n step1 [ 12 ] = input [ 6 / 2 ] ;\n step1 [ 13 ] = input [ 22 / 2 ] ;\n step1 [ 14 ] = input [ 14 / 2 ] ;\n step1 [ 15 ] = input [ 30 / 2 ] ;\n step2 [ 0 ] = step1 [ 0 ] ;\n step2 [ 1 ] = step1 [ 1 ] ;\n step2 [ 2 ] = step1 [ 2 ] ;\n step2 [ 3 ] = step1 [ 3 ] ;\n step2 [ 4 ] = step1 [ 4 ] ;\n step2 [ 5 ] = step1 [ 5 ] ;\n step2 [ 6 ] = step1 [ 6 ] ;\n step2 [ 7 ] = step1 [ 7 ] ;\n temp1 = step1 [ 8 ] * cospi_30_64 - step1 [ 15 ] * cospi_2_64 ;\n temp2 = step1 [ 8 ] * cospi_2_64 + step1 [ 15 ] * cospi_30_64 ;\n step2 [ 8 ] = dct_const_round_shift ( temp1 ) ;\n step2 [ 15 ] = dct_const_round_shift ( temp2 ) ;\n temp1 = step1 [ 9 ] * cospi_14_64 - step1 [ 14 ] * cospi_18_64 ;\n temp2 = step1 [ 9 ] * cospi_18_64 + step1 [ 14 ] * cospi_14_64 ;\n step2 [ 9 ] = dct_const_round_shift ( temp1 ) ;\n step2 [ 14 ] = dct_const_round_shift ( temp2 ) ;\n temp1 = step1 [ 10 ] * cospi_22_64 - step1 [ 13 ] * cospi_10_64 ;\n temp2 = step1 [ 10 ] * cospi_10_64 + step1 [ 13 ] * cospi_22_64 ;\n step2 [ 10 ] = dct_const_round_shift ( temp1 ) ;\n step2 [ 13 ] = dct_const_round_shift ( temp2 ) ;\n temp1 = step1 [ 11 ] * cospi_6_64 - step1 [ 12 ] * cospi_26_64 ;\n temp2 = step1 [ 11 ] * cospi_26_64 + step1 [ 12 ] * cospi_6_64 ;\n step2 [ 11 ] = dct_const_round_shift ( temp1 ) ;\n step2 [ 12 ] = dct_const_round_shift ( temp2 ) ;\n step1 [ 0 ] = step2 [ 0 ] ;\n step1 [ 1 ] = step2 [ 1 ] ;\n step1 [ 2 ] = step2 [ 2 ] ;\n step1 [ 3 ] = step2 [ 3 ] ;\n temp1 = step2 [ 4 ] * cospi_28_64 - step2 [ 7 ] * cospi_4_64 ;\n temp2 = step2 [ 4 ] * cospi_4_64 + step2 [ 7 ] * cospi_28_64 ;\n step1 [ 4 ] = dct_const_round_shift ( temp1 ) ;\n step1 [ 7 ] = dct_const_round_shift ( temp2 ) ;\n temp1 = step2 [ 5 ] * cospi_12_64 - step2 [ 6 ] * cospi_20_64 ;\n temp2 = step2 [ 5 ] * cospi_20_64 + step2 [ 6 ] * cospi_12_64 ;\n step1 [ 5 ] = dct_const_round_shift ( temp1 ) ;\n step1 [ 6 ] = dct_const_round_shift ( temp2 ) ;\n step1 [ 8 ] = step2 [ 8 ] + step2 [ 9 ] ;\n step1 [ 9 ] = step2 [ 8 ] - step2 [ 9 ] ;\n step1 [ 10 ] = - step2 [ 10 ] + step2 [ 11 ] ;\n step1 [ 11 ] = step2 [ 10 ] + step2 [ 11 ] ;\n step1 [ 12 ] = step2 [ 12 ] + step2 [ 13 ] ;\n step1 [ 13 ] = step2 [ 12 ] - step2 [ 13 ] ;\n step1 [ 14 ] = - step2 [ 14 ] + step2 [ 15 ] ;\n step1 [ 15 ] = step2 [ 14 ] + step2 [ 15 ] ;\n temp1 = ( step1 [ 0 ] + step1 [ 1 ] ) * cospi_16_64 ;\n temp2 = ( step1 [ 0 ] - step1 [ 1 ] ) * cospi_16_64 ;\n step2 [ 0 ] = dct_const_round_shift ( temp1 ) ;\n step2 [ 1 ] = dct_const_round_shift ( temp2 ) ;\n temp1 = step1 [ 2 ] * cospi_24_64 - step1 [ 3 ] * cospi_8_64 ;\n temp2 = step1 [ 2 ] * cospi_8_64 + step1 [ 3 ] * cospi_24_64 ;\n step2 [ 2 ] = dct_const_round_shift ( temp1 ) ;\n step2 [ 3 ] = dct_const_round_shift ( temp2 ) ;\n step2 [ 4 ] = step1 [ 4 ] + step1 [ 5 ] ;\n step2 [ 5 ] = step1 [ 4 ] - step1 [ 5 ] ;\n step2 [ 6 ] = - step1 [ 6 ] + step1 [ 7 ] ;\n step2 [ 7 ] = step1 [ 6 ] + step1 [ 7 ] ;\n step2 [ 8 ] = step1 [ 8 ] ;\n step2 [ 15 ] = step1 [ 15 ] ;\n temp1 = - step1 [ 9 ] * cospi_8_64 + step1 [ 14 ] * cospi_24_64 ;\n temp2 = step1 [ 9 ] * cospi_24_64 + step1 [ 14 ] * cospi_8_64 ;\n step2 [ 9 ] = dct_const_round_shift ( temp1 ) ;\n step2 [ 14 ] = dct_const_round_shift ( temp2 ) ;\n temp1 = - step1 [ 10 ] * cospi_24_64 - step1 [ 13 ] * cospi_8_64 ;\n temp2 = - step1 [ 10 ] * cospi_8_64 + step1 [ 13 ] * cospi_24_64 ;\n step2 [ 10 ] = dct_const_round_shift ( temp1 ) ;\n step2 [ 13 ] = dct_const_round_shift ( temp2 ) ;\n step2 [ 11 ] = step1 [ 11 ] ;\n step2 [ 12 ] = step1 [ 12 ] ;\n step1 [ 0 ] = step2 [ 0 ] + step2 [ 3 ] ;\n step1 [ 1 ] = step2 [ 1 ] + step2 [ 2 ] ;\n step1 [ 2 ] = step2 [ 1 ] - step2 [ 2 ] ;\n step1 [ 3 ] = step2 [ 0 ] - step2 [ 3 ] ;\n step1 [ 4 ] = step2 [ 4 ] ;\n temp1 = ( step2 [ 6 ] - step2 [ 5 ] ) * cospi_16_64 ;\n temp2 = ( step2 [ 5 ] + step2 [ 6 ] ) * cospi_16_64 ;\n step1 [ 5 ] = dct_const_round_shift ( temp1 ) ;\n step1 [ 6 ] = dct_const_round_shift ( temp2 ) ;\n step1 [ 7 ] = step2 [ 7 ] ;\n step1 [ 8 ] = step2 [ 8 ] + step2 [ 11 ] ;\n step1 [ 9 ] = step2 [ 9 ] + step2 [ 10 ] ;\n step1 [ 10 ] = step2 [ 9 ] - step2 [ 10 ] ;\n step1 [ 11 ] = step2 [ 8 ] - step2 [ 11 ] ;\n step1 [ 12 ] = - step2 [ 12 ] + step2 [ 15 ] ;\n step1 [ 13 ] = - step2 [ 13 ] + step2 [ 14 ] ;\n step1 [ 14 ] = step2 [ 13 ] + step2 [ 14 ] ;\n step1 [ 15 ] = step2 [ 12 ] + step2 [ 15 ] ;\n step2 [ 0 ] = step1 [ 0 ] + step1 [ 7 ] ;\n step2 [ 1 ] = step1 [ 1 ] + step1 [ 6 ] ;\n step2 [ 2 ] = step1 [ 2 ] + step1 [ 5 ] ;\n step2 [ 3 ] = step1 [ 3 ] + step1 [ 4 ] ;\n step2 [ 4 ] = step1 [ 3 ] - step1 [ 4 ] ;\n step2 [ 5 ] = step1 [ 2 ] - step1 [ 5 ] ;\n step2 [ 6 ] = step1 [ 1 ] - step1 [ 6 ] ;\n step2 [ 7 ] = step1 [ 0 ] - step1 [ 7 ] ;\n step2 [ 8 ] = step1 [ 8 ] ;\n step2 [ 9 ] = step1 [ 9 ] ;\n temp1 = ( - step1 [ 10 ] + step1 [ 13 ] ) * cospi_16_64 ;\n temp2 = ( step1 [ 10 ] + step1 [ 13 ] ) * cospi_16_64 ;\n step2 [ 10 ] = dct_const_round_shift ( temp1 ) ;\n step2 [ 13 ] = dct_const_round_shift ( temp2 ) ;\n temp1 = ( - step1 [ 11 ] + step1 [ 12 ] ) * cospi_16_64 ;\n temp2 = ( step1 [ 11 ] + step1 [ 12 ] ) * cospi_16_64 ;\n step2 [ 11 ] = dct_const_round_shift ( temp1 ) ;\n step2 [ 12 ] = dct_const_round_shift ( temp2 ) ;\n step2 [ 14 ] = step1 [ 14 ] ;\n step2 [ 15 ] = step1 [ 15 ] ;\n output [ 0 ] = step2 [ 0 ] + step2 [ 15 ] ;\n output [ 1 ] = step2 [ 1 ] + step2 [ 14 ] ;\n output [ 2 ] = step2 [ 2 ] + step2 [ 13 ] ;\n output [ 3 ] = step2 [ 3 ] + step2 [ 12 ] ;\n output [ 4 ] = step2 [ 4 ] + step2 [ 11 ] ;\n output [ 5 ] = step2 [ 5 ] + step2 [ 10 ] ;\n output [ 6 ] = step2 [ 6 ] + step2 [ 9 ] ;\n output [ 7 ] = step2 [ 7 ] + step2 [ 8 ] ;\n output [ 8 ] = step2 [ 7 ] - step2 [ 8 ] ;\n output [ 9 ] = step2 [ 6 ] - step2 [ 9 ] ;\n output [ 10 ] = step2 [ 5 ] - step2 [ 10 ] ;\n output [ 11 ] = step2 [ 4 ] - step2 [ 11 ] ;\n output [ 12 ] = step2 [ 3 ] - step2 [ 12 ] ;\n output [ 13 ] = step2 [ 2 ] - step2 [ 13 ] ;\n output [ 14 ] = step2 [ 1 ] - step2 [ 14 ] ;\n output [ 15 ] = step2 [ 0 ] - step2 [ 15 ] ;\n }", "idx": 21944}
{"hash": -866921002076081979, "project": "debian", "size": 19, "label": 0, "functionSource": "static int checkHttpTxnServerReqGet ( SocketTest * test , void * data ) {\n TSMBuffer bufp ;\n TSMLoc mloc ;\n TSHttpTxn txnp = ( TSHttpTxn ) data ;\n if ( TSHttpTxnServerReqGet ( txnp , & bufp , & mloc ) != TS_SUCCESS ) {\n test -> test_server_req_get = false ;\n SDK_RPRINT ( test -> regtest , \"TSHttpTxnServerReqGet\" , \"TestCase1\" , TC_FAIL , \"Unable to get handle to server request\" ) ;\n return TS_EVENT_CONTINUE ;\n }\n if ( ( bufp == reinterpret_cast < TSMBuffer > ( & ( ( HttpSM * ) txnp ) -> t_state . hdr_info . server_request ) ) && ( mloc == reinterpret_cast < TSMLoc > ( ( ( HttpSM * ) txnp ) -> t_state . hdr_info . server_request . m_http ) ) ) {\n test -> test_server_req_get = true ;\n SDK_RPRINT ( test -> regtest , \"TSHttpTxnServerReqGet\" , \"TestCase1\" , TC_PASS , \"ok\" ) ;\n }\n else {\n test -> test_server_req_get = false ;\n SDK_RPRINT ( test -> regtest , \"TSHttpTxnServerReqGet\" , \"TestCase1\" , TC_FAIL , \"Value's Mismatch\" ) ;\n }\n return TS_EVENT_CONTINUE ;\n }", "idx": 21945}
{"hash": -1983921383858884161, "project": "debian", "size": 32, "label": 0, "functionSource": "static int ipvideo_decode_block_opcode_0x7 ( IpvideoContext * s , AVFrame * frame ) {\n int x , y ;\n unsigned char P [ 2 ] ;\n unsigned int flags ;\n P [ 0 ] = bytestream2_get_byte ( & s -> stream_ptr ) ;\n P [ 1 ] = bytestream2_get_byte ( & s -> stream_ptr ) ;\n if ( P [ 0 ] <= P [ 1 ] ) {\n for ( y = 0 ;\n y < 8 ;\n y ++ ) {\n flags = bytestream2_get_byte ( & s -> stream_ptr ) | 0x100 ;\n for ( ;\n flags != 1 ;\n flags >>= 1 ) * s -> pixel_ptr ++ = P [ flags & 1 ] ;\n s -> pixel_ptr += s -> line_inc ;\n }\n }\n else {\n flags = bytestream2_get_le16 ( & s -> stream_ptr ) ;\n for ( y = 0 ;\n y < 8 ;\n y += 2 ) {\n for ( x = 0 ;\n x < 8 ;\n x += 2 , flags >>= 1 ) {\n s -> pixel_ptr [ x ] = s -> pixel_ptr [ x + 1 ] = s -> pixel_ptr [ x + s -> stride ] = s -> pixel_ptr [ x + 1 + s -> stride ] = P [ flags & 1 ] ;\n }\n s -> pixel_ptr += s -> stride * 2 ;\n }\n }\n return 0 ;\n }", "idx": 21946}
{"hash": 1911881859629730975, "project": "chrome", "size": 25, "label": 1, "functionSource": "static void set_block_thresholds ( const VP9_COMMON * cm , RD_OPT * rd ) {\n int i , bsize , segment_id ;\n for ( segment_id = 0 ;\n segment_id < MAX_SEGMENTS ;\n ++ segment_id ) {\n const int qindex = clamp ( vp9_get_qindex ( & cm -> seg , segment_id , cm -> base_qindex ) + cm -> y_dc_delta_q , 0 , MAXQ ) ;\n const int q = compute_rd_thresh_factor ( qindex ) ;\n for ( bsize = 0 ;\n bsize < BLOCK_SIZES ;\n ++ bsize ) {\n const int t = q * rd_thresh_block_size_factor [ bsize ] ;\n const int thresh_max = INT_MAX / t ;\n if ( bsize >= BLOCK_8X8 ) {\n for ( i = 0 ;\n i < MAX_MODES ;\n ++ i ) rd -> threshes [ segment_id ] [ bsize ] [ i ] = rd -> thresh_mult [ i ] < thresh_max ? rd -> thresh_mult [ i ] * t / 4 : INT_MAX ;\n }\n else {\n for ( i = 0 ;\n i < MAX_REFS ;\n ++ i ) rd -> threshes [ segment_id ] [ bsize ] [ i ] = rd -> thresh_mult_sub8x8 [ i ] < thresh_max ? rd -> thresh_mult_sub8x8 [ i ] * t / 4 : INT_MAX ;\n }\n }\n }\n }", "idx": 21947}
{"hash": -5780611388839125875, "project": "chrome", "size": 4, "label": 0, "functionSource": "int * __xmlLineNumbersDefaultValue ( void ) {\n if ( IS_MAIN_THREAD ) return ( & xmlLineNumbersDefaultValue ) ;\n else return ( & xmlGetGlobalState ( ) -> xmlLineNumbersDefaultValue ) ;\n }", "idx": 21948}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_V75Parameters ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_V75Parameters , V75Parameters_sequence ) ;\n return offset ;\n }", "idx": 21949}
{"hash": -16551315108292821, "project": "debian", "size": 414, "label": 0, "functionSource": "static gcry_error_t vsexp_sscan ( gcry_sexp_t * retsexp , size_t * erroff , const char * buffer , size_t length , int argflag , void * * arg_list , va_list arg_ptr ) {\n gcry_err_code_t err = 0 ;\n static const char tokenchars [ ] = \"abcdefghijklmnopqrstuvwxyz\" \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" \"0123456789-./_:*+=\" ;\n const char * p ;\n size_t n ;\n const char * digptr = NULL ;\n const char * quoted = NULL ;\n const char * tokenp = NULL ;\n const char * hexfmt = NULL ;\n const char * base64 = NULL ;\n const char * disphint = NULL ;\n const char * percent = NULL ;\n int hexcount = 0 ;\n int quoted_esc = 0 ;\n int datalen = 0 ;\n size_t dummy_erroff ;\n struct make_space_ctx c ;\n int arg_counter = 0 ;\n int level = 0 ;\n if ( ! erroff ) erroff = & dummy_erroff ;\n # define ARG_NEXT ( storage , type ) \\ do \\ {\n \\ if ( ! arg_list ) \\ storage = va_arg ( arg_ptr , type ) ;\n \\ else \\ storage = * ( ( type * ) ( arg_list [ arg_counter ++ ] ) ) ;\n \\ }\n \\ while ( 0 ) # define MAKE_SPACE ( n ) do {\n \\ gpg_err_code_t _ms_err = make_space ( & c , ( n ) ) ;\n \\ if ( _ms_err ) \\ {\n \\ err = _ms_err ;\n \\ * erroff = p - buffer ;\n \\ goto leave ;\n \\ }\n \\ }\n while ( 0 ) # define STORE_LEN ( p , n ) do {\n \\ DATALEN ashort = ( n ) ;\n \\ memcpy ( ( p ) , & ashort , sizeof ( ashort ) ) ;\n \\ ( p ) += sizeof ( ashort ) ;\n \\ }\n while ( 0 ) c . allocated = length + sizeof ( DATALEN ) ;\n if ( buffer && length && gcry_is_secure ( buffer ) ) c . sexp = gcry_malloc_secure ( sizeof * c . sexp + c . allocated - 1 ) ;\n else c . sexp = gcry_malloc ( sizeof * c . sexp + c . allocated - 1 ) ;\n if ( ! c . sexp ) {\n err = gpg_err_code_from_errno ( errno ) ;\n * erroff = 0 ;\n goto leave ;\n }\n c . pos = c . sexp -> d ;\n for ( p = buffer , n = length ;\n n ;\n p ++ , n -- ) {\n if ( tokenp && ! hexfmt ) {\n if ( strchr ( tokenchars , * p ) ) continue ;\n else {\n datalen = p - tokenp ;\n MAKE_SPACE ( datalen ) ;\n * c . pos ++ = ST_DATA ;\n STORE_LEN ( c . pos , datalen ) ;\n memcpy ( c . pos , tokenp , datalen ) ;\n c . pos += datalen ;\n tokenp = NULL ;\n }\n }\n if ( quoted ) {\n if ( quoted_esc ) {\n switch ( * p ) {\n case 'b' : case 't' : case 'v' : case 'n' : case 'f' : case 'r' : case '\"' : case '\\'' : case '\\\\' : quoted_esc = 0 ;\n break ;\n case '0' : case '1' : case '2' : case '3' : case '4' : case '5' : case '6' : case '7' : if ( ! ( ( n > 2 ) && ( p [ 1 ] >= '0' ) && ( p [ 1 ] <= '7' ) && ( p [ 2 ] >= '0' ) && ( p [ 2 ] <= '7' ) ) ) {\n * erroff = p - buffer ;\n err = GPG_ERR_SEXP_BAD_QUOTATION ;\n goto leave ;\n }\n p += 2 ;\n n -= 2 ;\n quoted_esc = 0 ;\n break ;\n case 'x' : if ( ! ( ( n > 2 ) && hexdigitp ( p + 1 ) && hexdigitp ( p + 2 ) ) ) {\n * erroff = p - buffer ;\n err = GPG_ERR_SEXP_BAD_QUOTATION ;\n goto leave ;\n }\n p += 2 ;\n n -= 2 ;\n quoted_esc = 0 ;\n break ;\n case '\\r' : if ( n && ( p [ 1 ] == '\\n' ) ) {\n p ++ ;\n n -- ;\n }\n quoted_esc = 0 ;\n break ;\n case '\\n' : if ( n && ( p [ 1 ] == '\\r' ) ) {\n p ++ ;\n n -- ;\n }\n quoted_esc = 0 ;\n break ;\n default : * erroff = p - buffer ;\n err = GPG_ERR_SEXP_BAD_QUOTATION ;\n goto leave ;\n }\n }\n else if ( * p == '\\\\' ) quoted_esc = 1 ;\n else if ( * p == '\\\"' ) {\n unsigned char * save ;\n size_t len ;\n quoted ++ ;\n MAKE_SPACE ( p - quoted ) ;\n * c . pos ++ = ST_DATA ;\n save = c . pos ;\n STORE_LEN ( c . pos , 0 ) ;\n len = unquote_string ( quoted , p - quoted , c . pos ) ;\n c . pos += len ;\n STORE_LEN ( save , len ) ;\n quoted = NULL ;\n }\n }\n else if ( hexfmt ) {\n if ( isxdigit ( * p ) ) hexcount ++ ;\n else if ( * p == '#' ) {\n if ( ( hexcount & 1 ) ) {\n * erroff = p - buffer ;\n err = GPG_ERR_SEXP_ODD_HEX_NUMBERS ;\n goto leave ;\n }\n datalen = hexcount / 2 ;\n MAKE_SPACE ( datalen ) ;\n * c . pos ++ = ST_DATA ;\n STORE_LEN ( c . pos , datalen ) ;\n for ( hexfmt ++ ;\n hexfmt < p ;\n hexfmt ++ ) {\n int tmpc ;\n if ( whitespacep ( hexfmt ) ) continue ;\n tmpc = hextonibble ( * ( const unsigned char * ) hexfmt ) ;\n for ( hexfmt ++ ;\n hexfmt < p && whitespacep ( hexfmt ) ;\n hexfmt ++ ) ;\n if ( hexfmt < p ) {\n tmpc *= 16 ;\n tmpc += hextonibble ( * ( const unsigned char * ) hexfmt ) ;\n }\n * c . pos ++ = tmpc ;\n }\n hexfmt = NULL ;\n }\n else if ( ! whitespacep ( p ) ) {\n * erroff = p - buffer ;\n err = GPG_ERR_SEXP_BAD_HEX_CHAR ;\n goto leave ;\n }\n }\n else if ( base64 ) {\n if ( * p == '|' ) base64 = NULL ;\n }\n else if ( digptr ) {\n if ( digitp ( p ) ) ;\n else if ( * p == ':' ) {\n datalen = atoi ( digptr ) ;\n digptr = NULL ;\n if ( datalen > n - 1 ) {\n * erroff = p - buffer ;\n err = GPG_ERR_SEXP_STRING_TOO_LONG ;\n goto leave ;\n }\n MAKE_SPACE ( datalen ) ;\n * c . pos ++ = ST_DATA ;\n STORE_LEN ( c . pos , datalen ) ;\n memcpy ( c . pos , p + 1 , datalen ) ;\n c . pos += datalen ;\n n -= datalen ;\n p += datalen ;\n }\n else if ( * p == '\\\"' ) {\n digptr = NULL ;\n quoted = p ;\n quoted_esc = 0 ;\n }\n else if ( * p == '#' ) {\n digptr = NULL ;\n hexfmt = p ;\n hexcount = 0 ;\n }\n else if ( * p == '|' ) {\n digptr = NULL ;\n base64 = p ;\n }\n else {\n * erroff = p - buffer ;\n err = GPG_ERR_SEXP_INV_LEN_SPEC ;\n goto leave ;\n }\n }\n else if ( percent ) {\n if ( * p == 'm' || * p == 'M' ) {\n gcry_mpi_t m ;\n size_t nm = 0 ;\n int mpifmt = * p == 'm' ? GCRYMPI_FMT_STD : GCRYMPI_FMT_USG ;\n ARG_NEXT ( m , gcry_mpi_t ) ;\n if ( gcry_mpi_get_flag ( m , GCRYMPI_FLAG_OPAQUE ) ) {\n void * mp ;\n unsigned int nbits ;\n mp = gcry_mpi_get_opaque ( m , & nbits ) ;\n nm = ( nbits + 7 ) / 8 ;\n if ( mp && nm ) {\n MAKE_SPACE ( nm ) ;\n if ( ! gcry_is_secure ( c . sexp -> d ) && gcry_mpi_get_flag ( m , GCRYMPI_FLAG_SECURE ) ) {\n gcry_sexp_t newsexp ;\n byte * newhead ;\n newsexp = gcry_malloc_secure ( sizeof * newsexp + c . allocated - 1 ) ;\n if ( ! newsexp ) {\n err = gpg_err_code_from_errno ( errno ) ;\n goto leave ;\n }\n newhead = newsexp -> d ;\n memcpy ( newhead , c . sexp -> d , ( c . pos - c . sexp -> d ) ) ;\n c . pos = newhead + ( c . pos - c . sexp -> d ) ;\n gcry_free ( c . sexp ) ;\n c . sexp = newsexp ;\n }\n * c . pos ++ = ST_DATA ;\n STORE_LEN ( c . pos , nm ) ;\n memcpy ( c . pos , mp , nm ) ;\n c . pos += nm ;\n }\n }\n else {\n if ( gcry_mpi_print ( mpifmt , NULL , 0 , & nm , m ) ) BUG ( ) ;\n MAKE_SPACE ( nm ) ;\n if ( ! gcry_is_secure ( c . sexp -> d ) && gcry_mpi_get_flag ( m , GCRYMPI_FLAG_SECURE ) ) {\n gcry_sexp_t newsexp ;\n byte * newhead ;\n newsexp = gcry_malloc_secure ( sizeof * newsexp + c . allocated - 1 ) ;\n if ( ! newsexp ) {\n err = gpg_err_code_from_errno ( errno ) ;\n goto leave ;\n }\n newhead = newsexp -> d ;\n memcpy ( newhead , c . sexp -> d , ( c . pos - c . sexp -> d ) ) ;\n c . pos = newhead + ( c . pos - c . sexp -> d ) ;\n gcry_free ( c . sexp ) ;\n c . sexp = newsexp ;\n }\n * c . pos ++ = ST_DATA ;\n STORE_LEN ( c . pos , nm ) ;\n if ( gcry_mpi_print ( mpifmt , c . pos , nm , & nm , m ) ) BUG ( ) ;\n c . pos += nm ;\n }\n }\n else if ( * p == 's' ) {\n const char * astr ;\n size_t alen ;\n ARG_NEXT ( astr , const char * ) ;\n alen = strlen ( astr ) ;\n MAKE_SPACE ( alen ) ;\n * c . pos ++ = ST_DATA ;\n STORE_LEN ( c . pos , alen ) ;\n memcpy ( c . pos , astr , alen ) ;\n c . pos += alen ;\n }\n else if ( * p == 'b' ) {\n const char * astr ;\n int alen ;\n ARG_NEXT ( alen , int ) ;\n ARG_NEXT ( astr , const char * ) ;\n MAKE_SPACE ( alen ) ;\n if ( alen && ! gcry_is_secure ( c . sexp -> d ) && gcry_is_secure ( astr ) ) {\n gcry_sexp_t newsexp ;\n byte * newhead ;\n newsexp = gcry_malloc_secure ( sizeof * newsexp + c . allocated - 1 ) ;\n if ( ! newsexp ) {\n err = gpg_err_code_from_errno ( errno ) ;\n goto leave ;\n }\n newhead = newsexp -> d ;\n memcpy ( newhead , c . sexp -> d , ( c . pos - c . sexp -> d ) ) ;\n c . pos = newhead + ( c . pos - c . sexp -> d ) ;\n gcry_free ( c . sexp ) ;\n c . sexp = newsexp ;\n }\n * c . pos ++ = ST_DATA ;\n STORE_LEN ( c . pos , alen ) ;\n memcpy ( c . pos , astr , alen ) ;\n c . pos += alen ;\n }\n else if ( * p == 'd' ) {\n int aint ;\n size_t alen ;\n char buf [ 35 ] ;\n ARG_NEXT ( aint , int ) ;\n sprintf ( buf , \"%d\" , aint ) ;\n alen = strlen ( buf ) ;\n MAKE_SPACE ( alen ) ;\n * c . pos ++ = ST_DATA ;\n STORE_LEN ( c . pos , alen ) ;\n memcpy ( c . pos , buf , alen ) ;\n c . pos += alen ;\n }\n else if ( * p == 'u' ) {\n unsigned int aint ;\n size_t alen ;\n char buf [ 35 ] ;\n ARG_NEXT ( aint , unsigned int ) ;\n sprintf ( buf , \"%u\" , aint ) ;\n alen = strlen ( buf ) ;\n MAKE_SPACE ( alen ) ;\n * c . pos ++ = ST_DATA ;\n STORE_LEN ( c . pos , alen ) ;\n memcpy ( c . pos , buf , alen ) ;\n c . pos += alen ;\n }\n else if ( * p == 'S' ) {\n gcry_sexp_t asexp ;\n size_t alen , aoff ;\n ARG_NEXT ( asexp , gcry_sexp_t ) ;\n alen = get_internal_buffer ( asexp , & aoff ) ;\n if ( alen ) {\n MAKE_SPACE ( alen ) ;\n memcpy ( c . pos , asexp -> d + aoff , alen ) ;\n c . pos += alen ;\n }\n }\n else {\n * erroff = p - buffer ;\n err = GPG_ERR_SEXP_INV_LEN_SPEC ;\n goto leave ;\n }\n percent = NULL ;\n }\n else if ( * p == '(' ) {\n if ( disphint ) {\n * erroff = p - buffer ;\n err = GPG_ERR_SEXP_UNMATCHED_DH ;\n goto leave ;\n }\n MAKE_SPACE ( 0 ) ;\n * c . pos ++ = ST_OPEN ;\n level ++ ;\n }\n else if ( * p == ')' ) {\n if ( disphint ) {\n * erroff = p - buffer ;\n err = GPG_ERR_SEXP_UNMATCHED_DH ;\n goto leave ;\n }\n MAKE_SPACE ( 0 ) ;\n * c . pos ++ = ST_CLOSE ;\n level -- ;\n }\n else if ( * p == '\\\"' ) {\n quoted = p ;\n quoted_esc = 0 ;\n }\n else if ( * p == '#' ) {\n hexfmt = p ;\n hexcount = 0 ;\n }\n else if ( * p == '|' ) base64 = p ;\n else if ( * p == '[' ) {\n if ( disphint ) {\n * erroff = p - buffer ;\n err = GPG_ERR_SEXP_NESTED_DH ;\n goto leave ;\n }\n disphint = p ;\n }\n else if ( * p == ']' ) {\n if ( ! disphint ) {\n * erroff = p - buffer ;\n err = GPG_ERR_SEXP_UNMATCHED_DH ;\n goto leave ;\n }\n disphint = NULL ;\n }\n else if ( digitp ( p ) ) {\n if ( * p == '0' ) {\n * erroff = p - buffer ;\n err = GPG_ERR_SEXP_ZERO_PREFIX ;\n goto leave ;\n }\n digptr = p ;\n }\n else if ( strchr ( tokenchars , * p ) ) tokenp = p ;\n else if ( whitespacep ( p ) ) ;\n else if ( * p == '{\n' ) {\n * erroff = p - buffer ;\n err = GPG_ERR_SEXP_UNEXPECTED_PUNC ;\n goto leave ;\n }\n else if ( strchr ( \"&\\\\\" , * p ) ) {\n * erroff = p - buffer ;\n err = GPG_ERR_SEXP_UNEXPECTED_PUNC ;\n goto leave ;\n }\n else if ( argflag && ( * p == '%' ) ) percent = p ;\n else {\n * erroff = p - buffer ;\n err = GPG_ERR_SEXP_BAD_CHARACTER ;\n goto leave ;\n }\n }\n MAKE_SPACE ( 0 ) ;\n * c . pos ++ = ST_STOP ;\n if ( level && ! err ) err = GPG_ERR_SEXP_UNMATCHED_PAREN ;\n leave : if ( err ) {\n if ( c . sexp ) {\n if ( gcry_is_secure ( c . sexp ) ) wipememory ( c . sexp , sizeof ( struct gcry_sexp ) + c . allocated - 1 ) ;\n gcry_free ( c . sexp ) ;\n }\n * retsexp = NULL ;\n }\n else * retsexp = normalize ( c . sexp ) ;\n return gcry_error ( err ) ;\n # undef MAKE_SPACE # undef STORE_LEN }", "idx": 21950}
{"hash": -1409799581796815039, "project": "debian", "size": 9, "label": 0, "functionSource": "int cpu_signal_handler ( int host_signum , void * pinfo , void * puc ) {\n siginfo_t * info = pinfo ;\n unsigned long pc ;\n # if defined ( __NetBSD__ ) || defined ( __FreeBSD__ ) || defined ( __DragonFly__ ) ucontext_t * uc = puc ;\n # elif defined ( __OpenBSD__ ) struct sigcontext * uc = puc ;\n # else struct ucontext * uc = puc ;\n # endif pc = PC_sig ( uc ) ;\n return handle_cpu_signal ( pc , ( unsigned long ) info -> si_addr , TRAP_sig ( uc ) == 0xe ? ( ERROR_sig ( uc ) >> 1 ) & 1 : 0 , & MASK_sig ( uc ) , puc ) ;\n }", "idx": 21951}
{"hash": -1672864273235910388, "project": "debian", "size": 12, "label": 0, "functionSource": "static void _slurm_rpc_job_step_kill ( uint32_t uid , slurm_msg_t * msg ) {\n static int active_rpc_cnt = 0 ;\n int error_code = SLURM_SUCCESS ;\n job_step_kill_msg_t * job_step_kill_msg = ( job_step_kill_msg_t * ) msg -> data ;\n if ( slurmctld_conf . debug_flags & DEBUG_FLAG_STEPS ) {\n info ( \"Processing RPC: REQUEST_CANCEL_JOB_STEP %u.%u uid=%u\" , job_step_kill_msg -> job_id , job_step_kill_msg -> job_step_id , uid ) ;\n }\n _throttle_start ( & active_rpc_cnt ) ;\n error_code = kill_job_step ( job_step_kill_msg , uid ) ;\n _throttle_fini ( & active_rpc_cnt ) ;\n slurm_send_rc_msg ( msg , error_code ) ;\n }", "idx": 21952}
{"hash": 847431771831526026, "project": "debian", "size": 52, "label": 0, "functionSource": "static size_t try_block ( const char * d , size_t dlen , const char * fromcode , const char * tocode , encoder_t * encoder , size_t * wlen ) {\n char buf [ ENCWORD_LEN_MAX - ENCWORD_LEN_MIN + 1 ] ;\n const char * ib = NULL ;\n char * ob = NULL ;\n size_t ibl , obl ;\n int count , len , len_b , len_q ;\n if ( fromcode ) {\n iconv_t cd = mutt_ch_iconv_open ( tocode , fromcode , 0 ) ;\n assert ( cd != ( iconv_t ) ( - 1 ) ) ;\n ib = d ;\n ibl = dlen ;\n ob = buf ;\n obl = sizeof ( buf ) - strlen ( tocode ) ;\n if ( iconv ( cd , ( ICONV_CONST char * * ) & ib , & ibl , & ob , & obl ) == ( size_t ) ( - 1 ) || iconv ( cd , NULL , NULL , & ob , & obl ) == ( size_t ) ( - 1 ) ) {\n assert ( errno == E2BIG ) ;\n iconv_close ( cd ) ;\n assert ( ib > d ) ;\n return ( ib - d == dlen ) ? dlen : ib - d + 1 ;\n }\n iconv_close ( cd ) ;\n }\n else {\n if ( dlen > ( sizeof ( buf ) - strlen ( tocode ) ) ) return ( sizeof ( buf ) - strlen ( tocode ) + 1 ) ;\n memcpy ( buf , d , dlen ) ;\n ob = buf + dlen ;\n }\n count = 0 ;\n for ( char * p = buf ;\n p < ob ;\n p ++ ) {\n unsigned char c = * p ;\n assert ( strchr ( MimeSpecials , '?' ) ) ;\n if ( ( c >= 0x7f ) || ( c < 0x20 ) || ( * p == '_' ) || ( ( c != ' ' ) && strchr ( MimeSpecials , * p ) ) ) {\n count ++ ;\n }\n }\n len = ENCWORD_LEN_MIN - 2 + strlen ( tocode ) ;\n len_b = len + ( ( ( ob - buf ) + 2 ) / 3 ) * 4 ;\n len_q = len + ( ob - buf ) + 2 * count ;\n if ( mutt_str_strcasecmp ( tocode , \"ISO-2022-JP\" ) == 0 ) len_q = ENCWORD_LEN_MAX + 1 ;\n if ( ( len_b < len_q ) && ( len_b <= ENCWORD_LEN_MAX ) ) {\n * encoder = b_encoder ;\n * wlen = len_b ;\n return 0 ;\n }\n else if ( len_q <= ENCWORD_LEN_MAX ) {\n * encoder = q_encoder ;\n * wlen = len_q ;\n return 0 ;\n }\n else return dlen ;\n }", "idx": 21953}
{"hash": 3584320764213684062, "project": "debian", "size": 29, "label": 0, "functionSource": "static int vvalue_tvb_vector_internal ( tvbuff_t * tvb , int offset , struct vt_vector * val , struct vtype_data * type , guint num ) {\n const int offset_in = offset ;\n const gboolean varsize = ( type -> size == - 1 ) ;\n const guint elsize = varsize ? ( guint ) sizeof ( struct data_blob ) : ( guint ) type -> size ;\n guint8 * data ;\n int len ;\n guint i ;\n if ( ( guint64 ) elsize * ( guint64 ) num > G_MAXUINT ) {\n THROW ( ReportedBoundsError ) ;\n }\n tvb_ensure_bytes_exist ( tvb , offset , elsize * num ) ;\n data = ( guint8 * ) wmem_alloc ( wmem_packet_scope ( ) , elsize * num ) ;\n val -> len = num ;\n val -> u . vt_ui1 = data ;\n DISSECTOR_ASSERT ( ( void * ) & val -> u == ( ( void * ) & val -> u . vt_ui1 ) ) ;\n for ( i = 0 ;\n i < num ;\n i ++ ) {\n DISSECTOR_ASSERT_HINT ( type -> tvb_get != 0 , \"type that we don't know yet how to handle, please submit a bug with trace\" ) ;\n len = type -> tvb_get ( tvb , offset , data ) ;\n data += elsize ;\n offset += len ;\n if ( varsize && ( offset % 4 ) ) {\n int padding = 4 - ( offset % 4 ) ;\n offset += padding ;\n }\n }\n return offset - offset_in ;\n }", "idx": 21954}
{"hash": -7777331401175181229, "project": "debian", "size": 12, "label": 0, "functionSource": "static void cmd_server ( const char * data ) {\n if ( * data != '\\0' ) return ;\n if ( servers == NULL && lookup_servers == NULL && reconnects == NULL ) {\n printformat ( NULL , NULL , MSGLEVEL_CLIENTNOTICE , TXT_NO_CONNECTED_SERVERS ) ;\n }\n else {\n print_servers ( ) ;\n print_lookup_servers ( ) ;\n print_reconnects ( ) ;\n }\n signal_stop ( ) ;\n }", "idx": 21955}
{"hash": 7424930167238097621, "project": "debian", "size": 4, "label": 0, "functionSource": "static struct usb_host_endpoint * ep_to_host_endpoint ( struct usb_device * dev , unsigned char ep ) {\n if ( ep & USB_ENDPOINT_DIR_MASK ) return dev -> ep_in [ ep & USB_ENDPOINT_NUMBER_MASK ] ;\n else return dev -> ep_out [ ep & USB_ENDPOINT_NUMBER_MASK ] ;\n }", "idx": 21956}
{"hash": -6119142299306266167, "project": "debian", "size": 18, "label": 0, "functionSource": "static int zzstop ( i_ctx_t * i_ctx_p ) {\n os_ptr op = osp ;\n uint count ;\n check_type ( * op , t_integer ) ;\n count = count_to_stopped ( i_ctx_p , op -> value . intval ) ;\n if ( count ) {\n ref save_result ;\n check_op ( 2 ) ;\n save_result = op [ - 1 ] ;\n pop ( 2 ) ;\n pop_estack ( i_ctx_p , count ) ;\n op = osp ;\n push ( 1 ) ;\n * op = save_result ;\n return o_pop_estack ;\n }\n return unmatched_exit ( op , zzstop ) ;\n }", "idx": 21957}
{"hash": 3804373597256531021, "project": "debian", "size": 3, "label": 0, "functionSource": "inline GRANT_TABLE * table_hash_search ( const char * host , const char * ip , const char * db , const char * user , const char * tname , bool exact ) {\n return ( GRANT_TABLE * ) name_hash_search ( & column_priv_hash , host , ip , db , user , tname , exact , FALSE ) ;\n }", "idx": 21958}
{"hash": -3559021711340554904, "project": "debian", "size": 3, "label": 0, "functionSource": "static bool contain_volatile_functions_not_nextval_checker ( Oid func_id , void * context ) {\n return ( func_id != F_NEXTVAL_OID && func_volatile ( func_id ) == PROVOLATILE_VOLATILE ) ;\n }", "idx": 21959}
{"hash": 1825251920369138543, "project": "debian", "size": 86, "label": 0, "functionSource": "int dtls1_get_record ( SSL * s ) {\n int ssl_major , ssl_minor ;\n int i , n ;\n SSL3_RECORD * rr ;\n unsigned char * p = NULL ;\n unsigned short version ;\n DTLS1_BITMAP * bitmap ;\n unsigned int is_next_epoch ;\n rr = RECORD_LAYER_get_rrec ( & s -> rlayer ) ;\n again : if ( ! dtls1_process_buffered_records ( s ) ) return - 1 ;\n if ( dtls1_get_processed_record ( s ) ) return 1 ;\n if ( ( RECORD_LAYER_get_rstate ( & s -> rlayer ) != SSL_ST_READ_BODY ) || ( RECORD_LAYER_get_packet_length ( & s -> rlayer ) < DTLS1_RT_HEADER_LENGTH ) ) {\n n = ssl3_read_n ( s , DTLS1_RT_HEADER_LENGTH , SSL3_BUFFER_get_len ( & s -> rlayer . rbuf ) , 0 , 1 ) ;\n if ( n <= 0 ) return ( n ) ;\n if ( RECORD_LAYER_get_packet_length ( & s -> rlayer ) != DTLS1_RT_HEADER_LENGTH ) {\n RECORD_LAYER_reset_packet_length ( & s -> rlayer ) ;\n goto again ;\n }\n RECORD_LAYER_set_rstate ( & s -> rlayer , SSL_ST_READ_BODY ) ;\n p = RECORD_LAYER_get_packet ( & s -> rlayer ) ;\n if ( s -> msg_callback ) s -> msg_callback ( 0 , 0 , SSL3_RT_HEADER , p , DTLS1_RT_HEADER_LENGTH , s , s -> msg_callback_arg ) ;\n rr -> type = * ( p ++ ) ;\n ssl_major = * ( p ++ ) ;\n ssl_minor = * ( p ++ ) ;\n version = ( ssl_major << 8 ) | ssl_minor ;\n n2s ( p , rr -> epoch ) ;\n memcpy ( & ( RECORD_LAYER_get_read_sequence ( & s -> rlayer ) [ 2 ] ) , p , 6 ) ;\n p += 6 ;\n n2s ( p , rr -> length ) ;\n if ( ! s -> first_packet ) {\n if ( version != s -> version ) {\n rr -> length = 0 ;\n RECORD_LAYER_reset_packet_length ( & s -> rlayer ) ;\n goto again ;\n }\n }\n if ( ( version & 0xff00 ) != ( s -> version & 0xff00 ) ) {\n rr -> length = 0 ;\n RECORD_LAYER_reset_packet_length ( & s -> rlayer ) ;\n goto again ;\n }\n if ( rr -> length > SSL3_RT_MAX_ENCRYPTED_LENGTH ) {\n rr -> length = 0 ;\n RECORD_LAYER_reset_packet_length ( & s -> rlayer ) ;\n goto again ;\n }\n }\n if ( rr -> length > RECORD_LAYER_get_packet_length ( & s -> rlayer ) - DTLS1_RT_HEADER_LENGTH ) {\n i = rr -> length ;\n n = ssl3_read_n ( s , i , i , 1 , 1 ) ;\n if ( n != i ) {\n rr -> length = 0 ;\n RECORD_LAYER_reset_packet_length ( & s -> rlayer ) ;\n goto again ;\n }\n }\n RECORD_LAYER_set_rstate ( & s -> rlayer , SSL_ST_READ_HEADER ) ;\n bitmap = dtls1_get_bitmap ( s , rr , & is_next_epoch ) ;\n if ( bitmap == NULL ) {\n rr -> length = 0 ;\n RECORD_LAYER_reset_packet_length ( & s -> rlayer ) ;\n goto again ;\n }\n # ifndef OPENSSL_NO_SCTP if ( ! BIO_dgram_is_sctp ( SSL_get_rbio ( s ) ) ) {\n # endif if ( ! dtls1_record_replay_check ( s , bitmap ) ) {\n rr -> length = 0 ;\n RECORD_LAYER_reset_packet_length ( & s -> rlayer ) ;\n goto again ;\n }\n # ifndef OPENSSL_NO_SCTP }\n # endif if ( rr -> length == 0 ) goto again ;\n if ( is_next_epoch ) {\n if ( ( SSL_in_init ( s ) || ossl_statem_get_in_handshake ( s ) ) ) {\n if ( dtls1_buffer_record ( s , & ( DTLS_RECORD_LAYER_get_unprocessed_rcds ( & s -> rlayer ) ) , rr -> seq_num ) < 0 ) return - 1 ;\n }\n rr -> length = 0 ;\n RECORD_LAYER_reset_packet_length ( & s -> rlayer ) ;\n goto again ;\n }\n if ( ! dtls1_process_record ( s , bitmap ) ) {\n rr -> length = 0 ;\n RECORD_LAYER_reset_packet_length ( & s -> rlayer ) ;\n goto again ;\n }\n return ( 1 ) ;\n }", "idx": 21960}
{"hash": 9046191708840218774, "project": "debian", "size": 26, "label": 0, "functionSource": "static int tipc_nl_compat_publ_dump ( struct tipc_nl_compat_msg * msg , u32 sock ) {\n int err ;\n void * hdr ;\n struct nlattr * nest ;\n struct sk_buff * args ;\n struct tipc_nl_compat_cmd_dump dump ;\n args = nlmsg_new ( NLMSG_GOODSIZE , GFP_KERNEL ) ;\n if ( ! args ) return - ENOMEM ;\n hdr = genlmsg_put ( args , 0 , 0 , & tipc_genl_family , NLM_F_MULTI , TIPC_NL_PUBL_GET ) ;\n nest = nla_nest_start ( args , TIPC_NLA_SOCK ) ;\n if ( ! nest ) {\n kfree_skb ( args ) ;\n return - EMSGSIZE ;\n }\n if ( nla_put_u32 ( args , TIPC_NLA_SOCK_REF , sock ) ) {\n kfree_skb ( args ) ;\n return - EMSGSIZE ;\n }\n nla_nest_end ( args , nest ) ;\n genlmsg_end ( args , hdr ) ;\n dump . dumpit = tipc_nl_publ_dump ;\n dump . format = __tipc_nl_compat_publ_dump ;\n err = __tipc_nl_compat_dumpit ( & dump , msg , args ) ;\n kfree_skb ( args ) ;\n return err ;\n }", "idx": 21961}
{"hash": -1658505547857059267, "project": "debian", "size": 15, "label": 1, "functionSource": "static inline int unreference_pic ( H264Context * h , Picture * pic , int refmask ) {\n int i ;\n if ( pic -> f . reference &= refmask ) {\n return 0 ;\n }\n else {\n for ( i = 0 ;\n h -> delayed_pic [ i ] ;\n i ++ ) if ( pic == h -> delayed_pic [ i ] ) {\n pic -> f . reference = DELAYED_PIC_REF ;\n break ;\n }\n return 1 ;\n }\n }", "idx": 21962}
{"hash": 313627013719508831, "project": "debian", "size": 3, "label": 0, "functionSource": "static inline void SetPixelGreen ( const Image * restrict image , const Quantum green , Quantum * restrict pixel ) {\n pixel [ image -> channel_map [ GreenPixelChannel ] . offset ] = green ;\n }", "idx": 21963}
{"hash": 3599206110384554647, "project": "debian", "size": 54, "label": 1, "functionSource": "static ossl_inline void sk_ ## t1 ## _zero ( STACK_OF ( t1 ) * sk ) {\n OPENSSL_sk_zero ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _delete ( STACK_OF ( t1 ) * sk , int i ) {\n return ( t2 * ) OPENSSL_sk_delete ( ( OPENSSL_STACK * ) sk , i ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _delete_ptr ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return ( t2 * ) OPENSSL_sk_delete_ptr ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _push ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_push ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _unshift ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_unshift ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _pop ( STACK_OF ( t1 ) * sk ) {\n return ( t2 * ) OPENSSL_sk_pop ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _shift ( STACK_OF ( t1 ) * sk ) {\n return ( t2 * ) OPENSSL_sk_shift ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline void sk_ ## t1 ## _pop_free ( STACK_OF ( t1 ) * sk , sk_ ## t1 ## _freefunc freefunc ) {\n OPENSSL_sk_pop_free ( ( OPENSSL_STACK * ) sk , ( OPENSSL_sk_freefunc ) freefunc ) ;\n }\n static ossl_inline int sk_ ## t1 ## _insert ( STACK_OF ( t1 ) * sk , t2 * ptr , int idx ) {\n return OPENSSL_sk_insert ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr , idx ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _set ( STACK_OF ( t1 ) * sk , int idx , t2 * ptr ) {\n return ( t2 * ) OPENSSL_sk_set ( ( OPENSSL_STACK * ) sk , idx , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _find ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_find ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _find_ex ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_find_ex ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline void sk_ ## t1 ## _sort ( STACK_OF ( t1 ) * sk ) {\n OPENSSL_sk_sort ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline int sk_ ## t1 ## _is_sorted ( const STACK_OF ( t1 ) * sk ) {\n return OPENSSL_sk_is_sorted ( ( const OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _dup ( const STACK_OF ( t1 ) * sk ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_dup ( ( const OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _deep_copy ( const STACK_OF ( t1 ) * sk , sk_ ## t1 ## _copyfunc copyfunc , sk_ ## t1 ## _freefunc freefunc ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_deep_copy ( ( const OPENSSL_STACK * ) sk , ( OPENSSL_sk_copyfunc ) copyfunc , ( OPENSSL_sk_freefunc ) freefunc ) ;\n }\n static ossl_inline sk_ ## t1 ## _compfunc sk_ ## t1 ## _set_cmp_func ( STACK_OF ( t1 ) * sk , sk_ ## t1 ## _compfunc compare ) {\n return ( sk_ ## t1 ## _compfunc ) OPENSSL_sk_set_cmp_func ( ( OPENSSL_STACK * ) sk , ( OPENSSL_sk_compfunc ) compare ) ;\n }\n # define DEFINE_SPECIAL_STACK_OF ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , t2 , t2 ) # define DEFINE_STACK_OF ( t ) SKM_DEFINE_STACK_OF ( t , t , t ) # define DEFINE_SPECIAL_STACK_OF_CONST ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , const t2 , t2 ) # define DEFINE_STACK_OF_CONST ( t ) SKM_DEFINE_STACK_OF ( t , const t , t ) typedef char * OPENSSL_STRING ;\n typedef const char * OPENSSL_CSTRING ;\n DEFINE_SPECIAL_STACK_OF ( OPENSSL_STRING , char ) DEFINE_SPECIAL_STACK_OF_CONST ( OPENSSL_CSTRING , char )", "idx": 21964}
{"hash": 3616225660295849566, "project": "debian", "size": 42, "label": 0, "functionSource": "static gboolean logcat_read_packet ( struct logcat_phdr * logcat , FILE_T fh , struct wtap_pkthdr * phdr , Buffer * buf , int * err , gchar * * err_info ) {\n gint bytes_read ;\n gint packet_size ;\n guint16 payload_length ;\n guint tmp [ 2 ] ;\n guint8 * pd ;\n struct logger_entry * log_entry ;\n bytes_read = file_read ( & tmp , 2 , fh ) ;\n if ( bytes_read != 2 ) {\n * err = file_error ( fh , err_info ) ;\n if ( * err == 0 && bytes_read != 0 ) * err = WTAP_ERR_SHORT_READ ;\n return FALSE ;\n }\n payload_length = pletoh16 ( tmp ) ;\n if ( logcat -> version == 1 ) {\n packet_size = sizeof ( struct logger_entry ) + payload_length ;\n }\n else if ( logcat -> version == 2 ) {\n packet_size = sizeof ( struct logger_entry_v2 ) + payload_length ;\n }\n else {\n return FALSE ;\n }\n buffer_assure_space ( buf , packet_size ) ;\n pd = buffer_start_ptr ( buf ) ;\n log_entry = ( struct logger_entry * ) pd ;\n memcpy ( pd , tmp , 2 ) ;\n bytes_read = file_read ( pd + 2 , packet_size - 2 , fh ) ;\n if ( bytes_read != packet_size - 2 ) {\n * err = file_error ( fh , err_info ) ;\n if ( * err == 0 ) * err = WTAP_ERR_SHORT_READ ;\n return FALSE ;\n }\n phdr -> rec_type = REC_TYPE_PACKET ;\n phdr -> presence_flags = WTAP_HAS_TS ;\n phdr -> ts . secs = ( time_t ) GINT32_FROM_LE ( log_entry -> sec ) ;\n phdr -> ts . nsecs = GINT32_FROM_LE ( log_entry -> nsec ) ;\n phdr -> caplen = packet_size ;\n phdr -> len = packet_size ;\n phdr -> pseudo_header . logcat . version = logcat -> version ;\n return TRUE ;\n }", "idx": 21965}
{"hash": 7709561160415672285, "project": "chrome", "size": 12, "label": 0, "functionSource": "void reference_8x8_dct_1d ( const double in [ 8 ] , double out [ 8 ] , int stride ) {\n const double kInvSqrt2 = 0.707106781186547524400844362104 ;\n for ( int k = 0 ;\n k < 8 ;\n k ++ ) {\n out [ k ] = 0.0 ;\n for ( int n = 0 ;\n n < 8 ;\n n ++ ) out [ k ] += in [ n ] * cos ( kPi * ( 2 * n + 1 ) * k / 16.0 ) ;\n if ( k == 0 ) out [ k ] = out [ k ] * kInvSqrt2 ;\n }\n }", "idx": 21966}
{"hash": -2222463888415249941, "project": "chrome", "size": 16, "label": 0, "functionSource": "static int get_arf_src_index ( VP9_COMP * cpi ) {\n RATE_CONTROL * const rc = & cpi -> rc ;\n int arf_src_index = 0 ;\n if ( is_altref_enabled ( cpi ) ) {\n if ( cpi -> oxcf . pass == 2 ) {\n const GF_GROUP * const gf_group = & cpi -> twopass . gf_group ;\n if ( gf_group -> update_type [ gf_group -> index ] == ARF_UPDATE ) {\n arf_src_index = gf_group -> arf_src_offset [ gf_group -> index ] ;\n }\n }\n else if ( rc -> source_alt_ref_pending ) {\n arf_src_index = rc -> frames_till_gf_update_due ;\n }\n }\n return arf_src_index ;\n }", "idx": 21967}
{"hash": -331579171381918893, "project": "debian", "size": 9, "label": 0, "functionSource": "static int SRP_user_pwd_set_sv ( SRP_user_pwd * vinfo , const char * s , const char * v ) {\n unsigned char tmp [ MAX_LEN ] ;\n int len ;\n if ( strlen ( s ) > MAX_LEN || strlen ( v ) > MAX_LEN ) return 0 ;\n len = t_fromb64 ( tmp , v ) ;\n if ( NULL == ( vinfo -> v = BN_bin2bn ( tmp , len , NULL ) ) ) return 0 ;\n len = t_fromb64 ( tmp , s ) ;\n return ( ( vinfo -> s = BN_bin2bn ( tmp , len , NULL ) ) != NULL ) ;\n }", "idx": 21968}
{"hash": -7555034601056330007, "project": "debian", "size": 20, "label": 0, "functionSource": "int virLogDefineOutputs ( virLogOutputPtr * outputs , size_t noutputs ) {\n # if HAVE_SYSLOG_H int id ;\n char * tmp = NULL ;\n # endif if ( virLogInitialize ( ) < 0 ) return - 1 ;\n virLogLock ( ) ;\n virLogResetOutputs ( ) ;\n # if HAVE_SYSLOG_H if ( ( id = virLogFindOutput ( outputs , noutputs , VIR_LOG_TO_SYSLOG , current_ident ) ) != - 1 ) {\n if ( VIR_STRDUP_QUIET ( tmp , outputs [ id ] -> name ) < 0 ) {\n virLogUnlock ( ) ;\n return - 1 ;\n }\n VIR_FREE ( current_ident ) ;\n current_ident = tmp ;\n openlog ( current_ident , 0 , 0 ) ;\n }\n # endif virLogOutputs = outputs ;\n virLogNbOutputs = noutputs ;\n virLogUnlock ( ) ;\n return 0 ;\n }", "idx": 21969}
{"hash": 455172021572601154, "project": "debian", "size": 55, "label": 0, "functionSource": "int strescape ( char * dst , char * src , size_t len ) {\n char * olddst = dst ;\n char * oldsrc = src ;\n int c ;\n int val ;\n while ( ( c = * src ++ ) != '\\0' && ( size_t ) ( src - oldsrc ) <= len ) {\n if ( c == '\\\\' ) {\n switch ( ( c = * src ++ ) ) {\n case '\\0' : goto strend ;\n default : * dst ++ = ( char ) c ;\n break ;\n case 'n' : * dst ++ = '\\n' ;\n break ;\n case 'r' : * dst ++ = '\\r' ;\n break ;\n case 'b' : * dst ++ = '\\b' ;\n break ;\n case 't' : * dst ++ = '\\t' ;\n break ;\n case 'f' : * dst ++ = '\\f' ;\n break ;\n case 'v' : * dst ++ = '\\v' ;\n break ;\n case '0' : case '1' : case '2' : case '3' : case '4' : case '5' : case '6' : case '7' : val = c - '0' ;\n c = * src ++ ;\n if ( c >= '0' && c <= '7' ) {\n val = ( val << 3 ) | ( c - '0' ) ;\n c = * src ++ ;\n if ( c >= '0' && c <= '7' ) val = ( val << 3 ) | ( c - '0' ) ;\n else if ( src > oldsrc ) -- src ;\n }\n else if ( src > oldsrc ) -- src ;\n * dst ++ = ( char ) val ;\n break ;\n case 'x' : val = 'x' ;\n c = hextoint ( * src ++ ) ;\n if ( c >= 0 ) {\n val = c ;\n c = hextoint ( * src ++ ) ;\n if ( c >= 0 ) val = ( val << 4 ) + c ;\n else if ( src > oldsrc ) -- src ;\n }\n else if ( src > oldsrc ) -- src ;\n * dst ++ = ( char ) val ;\n break ;\n }\n }\n else if ( c == 8 || c == 263 ) {\n if ( dst > oldsrc ) dst -- ;\n }\n else * dst ++ = ( char ) c ;\n }\n strend : * dst = '\\0' ;\n return ( dst - olddst ) ;\n }", "idx": 21970}
{"hash": -4885528830177756816, "project": "debian", "size": 14, "label": 0, "functionSource": "void mi_disable_non_unique_index ( MI_INFO * info , ha_rows rows ) {\n MYISAM_SHARE * share = info -> s ;\n MI_KEYDEF * key = share -> keyinfo ;\n uint i ;\n DBUG_ASSERT ( info -> state -> records == 0 && ( ! rows || rows >= MI_MIN_ROWS_TO_DISABLE_INDEXES ) ) ;\n for ( i = 0 ;\n i < share -> base . keys ;\n i ++ , key ++ ) {\n if ( ! ( key -> flag & ( HA_NOSAME | HA_SPATIAL | HA_AUTO_KEY ) ) && ! mi_too_big_key_for_sort ( key , rows ) && info -> s -> base . auto_key != i + 1 ) {\n mi_clear_key_active ( share -> state . key_map , i ) ;\n info -> update |= HA_STATE_CHANGED ;\n }\n }\n }", "idx": 21971}
{"hash": 8461782184979846246, "project": "chrome", "size": 6, "label": 0, "functionSource": "TEST_F ( ProtocolHandlerRegistryTest , TestEnabledDisabled ) {\n registry ( ) -> Disable ( ) ;\n ASSERT_FALSE ( registry ( ) -> enabled ( ) ) ;\n registry ( ) -> Enable ( ) ;\n ASSERT_TRUE ( registry ( ) -> enabled ( ) ) ;\n }", "idx": 21972}
{"hash": -1929262071302712016, "project": "debian", "size": 28, "label": 0, "functionSource": "static void * Type_MPEcurve_Read ( struct _cms_typehandler_struct * self , cmsIOHANDLER * io , cmsUInt32Number * nItems , cmsUInt32Number SizeOfTag ) {\n cmsStage * mpe = NULL ;\n cmsUInt16Number InputChans , OutputChans ;\n cmsUInt32Number i , BaseOffset ;\n cmsToneCurve * * GammaTables ;\n * nItems = 0 ;\n BaseOffset = io -> Tell ( io ) - sizeof ( _cmsTagBase ) ;\n if ( ! _cmsReadUInt16Number ( io , & InputChans ) ) return NULL ;\n if ( ! _cmsReadUInt16Number ( io , & OutputChans ) ) return NULL ;\n if ( InputChans != OutputChans ) return NULL ;\n GammaTables = ( cmsToneCurve * * ) _cmsCalloc ( self -> ContextID , InputChans , sizeof ( cmsToneCurve * ) ) ;\n if ( GammaTables == NULL ) return NULL ;\n if ( ReadPositionTable ( self , io , InputChans , BaseOffset , GammaTables , ReadMPECurve ) ) {\n mpe = cmsStageAllocToneCurves ( self -> ContextID , InputChans , GammaTables ) ;\n }\n else {\n mpe = NULL ;\n }\n for ( i = 0 ;\n i < InputChans ;\n i ++ ) {\n if ( GammaTables [ i ] ) cmsFreeToneCurve ( GammaTables [ i ] ) ;\n }\n _cmsFree ( self -> ContextID , GammaTables ) ;\n * nItems = ( mpe != NULL ) ? 1 : 0 ;\n return mpe ;\n cmsUNUSED_PARAMETER ( SizeOfTag ) ;\n }", "idx": 21973}
{"hash": -8962831256613787672, "project": "debian", "size": 16, "label": 0, "functionSource": "static gint dissect_as_if_general_body ( tvbuff_t * tvb , gint offset , packet_info * pinfo _U_ , proto_tree * tree , usb_conv_info_t * usb_conv_info ) {\n audio_conv_info_t * audio_conv_info ;\n gint offset_start ;\n audio_conv_info = ( audio_conv_info_t * ) usb_conv_info -> class_data ;\n if ( ! audio_conv_info ) return 0 ;\n offset_start = offset ;\n if ( audio_conv_info -> ver_major == 1 ) {\n proto_tree_add_item ( tree , hf_as_if_gen_term_id , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ;\n offset ++ ;\n proto_tree_add_item ( tree , hf_as_if_gen_delay , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ;\n offset ++ ;\n proto_tree_add_item ( tree , hf_as_if_gen_format , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n return offset - offset_start ;\n }", "idx": 21974}
{"hash": 8461782184979846246, "project": "chrome", "size": 4, "label": 0, "functionSource": "TEST_F ( ProtocolHandlerRegistryTest , TestIsHandledProtocol ) {\n registry ( ) -> GetHandlersFor ( \"test\" ) ;\n ASSERT_FALSE ( registry ( ) -> IsHandledProtocol ( \"test\" ) ) ;\n }", "idx": 21975}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_DataApplicationCapability ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_DataApplicationCapability , DataApplicationCapability_sequence ) ;\n return offset ;\n }", "idx": 21976}
{"hash": -6068399010699045437, "project": "debian", "size": 12, "label": 0, "functionSource": "static int decode_blockcode ( int code , int levels , int * values ) {\n int i ;\n int offset = ( levels - 1 ) >> 1 ;\n for ( i = 0 ;\n i < 4 ;\n i ++ ) {\n int div = FASTDIV ( code , levels ) ;\n values [ i ] = code - offset - div * levels ;\n code = div ;\n }\n return code ;\n }", "idx": 21977}
{"hash": -1672864273235910388, "project": "debian", "size": 206, "label": 1, "functionSource": "static void _slurm_rpc_submit_batch_pack_job ( slurm_msg_t * msg ) {\n static int select_serial = - 1 ;\n static int active_rpc_cnt = 0 ;\n ListIterator iter ;\n int error_code = SLURM_SUCCESS , alloc_only = 0 ;\n DEF_TIMERS ;\n uint32_t pack_job_id = 0 , pack_job_offset = 0 ;\n struct job_record * job_ptr = NULL , * first_job_ptr = NULL ;\n slurm_msg_t response_msg ;\n submit_response_msg_t submit_msg ;\n job_desc_msg_t * job_desc_msg ;\n char * script = NULL ;\n slurmctld_lock_t job_read_lock = {\n READ_LOCK , READ_LOCK , READ_LOCK , READ_LOCK , NO_LOCK }\n ;\n slurmctld_lock_t job_write_lock = {\n READ_LOCK , WRITE_LOCK , WRITE_LOCK , READ_LOCK , NO_LOCK }\n ;\n List job_req_list = ( List ) msg -> data ;\n uid_t uid = g_slurm_auth_get_uid ( msg -> auth_cred , slurmctld_config . auth_info ) ;\n uint32_t job_uid = NO_VAL ;\n char * err_msg = NULL , * job_submit_user_msg = NULL ;\n bool reject_job = false ;\n bool is_super_user ;\n List submit_job_list = NULL ;\n hostset_t jobid_hostset = NULL ;\n char tmp_str [ 32 ] ;\n START_TIMER ;\n debug2 ( \"Processing RPC: REQUEST_SUBMIT_BATCH_PACK_JOB from uid=%d\" , uid ) ;\n if ( ! job_req_list || ( list_count ( job_req_list ) == 0 ) ) {\n info ( \"REQUEST_SUBMIT_BATCH_PACK_JOB from uid=%d with empty job list\" , uid ) ;\n error_code = SLURM_ERROR ;\n reject_job = true ;\n goto send_msg ;\n }\n if ( ! _sched_backfill ( ) ) {\n error_code = ESLURM_NOT_SUPPORTED ;\n reject_job = true ;\n goto send_msg ;\n }\n if ( select_serial == - 1 ) {\n if ( xstrcmp ( slurmctld_conf . select_type , \"select/serial\" ) ) select_serial = 0 ;\n else select_serial = 1 ;\n }\n if ( slurmctld_config . submissions_disabled || ( select_serial == 1 ) ) {\n info ( \"Submissions disabled on system\" ) ;\n error_code = ESLURM_SUBMISSIONS_DISABLED ;\n reject_job = true ;\n goto send_msg ;\n }\n if ( ! job_req_list || ( list_count ( job_req_list ) == 0 ) ) {\n info ( \"REQUEST_SUBMIT_BATCH_PACK_JOB from uid=%d with empty job list\" , uid ) ;\n error_code = SLURM_ERROR ;\n reject_job = true ;\n goto send_msg ;\n }\n is_super_user = validate_super_user ( uid ) ;\n lock_slurmctld ( job_read_lock ) ;\n iter = list_iterator_create ( job_req_list ) ;\n while ( ( job_desc_msg = ( job_desc_msg_t * ) list_next ( iter ) ) ) {\n if ( job_uid == NO_VAL ) job_uid = job_desc_msg -> user_id ;\n if ( ( uid != job_desc_msg -> user_id ) && ! is_super_user ) {\n error ( \"Security violation, REQUEST_SUBMIT_BATCH_PACK_JOB from uid=%d\" , uid ) ;\n error_code = ESLURM_USER_ID_MISSING ;\n break ;\n }\n if ( ( job_desc_msg -> alloc_node == NULL ) || ( job_desc_msg -> alloc_node [ 0 ] == '\\0' ) ) {\n error ( \"REQUEST_SUBMIT_BATCH_PACK_JOB lacks alloc_node from uid=%d\" , uid ) ;\n error_code = ESLURM_INVALID_NODE_NAME ;\n break ;\n }\n dump_job_desc ( job_desc_msg ) ;\n job_desc_msg -> pack_job_offset = pack_job_offset ;\n error_code = validate_job_create_req ( job_desc_msg , uid , & err_msg ) ;\n if ( error_code != SLURM_SUCCESS ) {\n reject_job = true ;\n break ;\n }\n if ( err_msg ) {\n char * save_ptr = NULL , * tok ;\n tok = strtok_r ( err_msg , \"\\n\" , & save_ptr ) ;\n while ( tok ) {\n char * sep = \"\" ;\n if ( job_submit_user_msg ) sep = \"\\n\" ;\n xstrfmtcat ( job_submit_user_msg , \"%s%d: %s\" , sep , pack_job_offset , tok ) ;\n tok = strtok_r ( NULL , \"\\n\" , & save_ptr ) ;\n }\n xfree ( err_msg ) ;\n }\n pack_job_offset ++ ;\n }\n list_iterator_destroy ( iter ) ;\n unlock_slurmctld ( job_read_lock ) ;\n if ( error_code != SLURM_SUCCESS ) goto send_msg ;\n if ( err_msg ) job_submit_user_msg = xstrdup ( err_msg ) ;\n submit_job_list = list_create ( NULL ) ;\n pack_job_offset = 0 ;\n _throttle_start ( & active_rpc_cnt ) ;\n lock_slurmctld ( job_write_lock ) ;\n START_TIMER ;\n iter = list_iterator_create ( job_req_list ) ;\n while ( ( job_desc_msg = ( job_desc_msg_t * ) list_next ( iter ) ) ) {\n if ( ! script ) script = xstrdup ( job_desc_msg -> script ) ;\n if ( pack_job_offset && job_desc_msg -> script ) {\n info ( \"%s: Pack job %u offset %u has script, being ignored\" , __func__ , pack_job_id , pack_job_offset ) ;\n xfree ( job_desc_msg -> script ) ;\n }\n if ( pack_job_offset ) {\n job_desc_msg -> mail_type = 0 ;\n xfree ( job_desc_msg -> mail_user ) ;\n }\n if ( ! job_desc_msg -> burst_buffer ) {\n xfree ( job_desc_msg -> script ) ;\n job_desc_msg -> script = bb_g_build_pack_script ( script , pack_job_offset ) ;\n }\n job_desc_msg -> pack_job_offset = pack_job_offset ;\n error_code = job_allocate ( job_desc_msg , job_desc_msg -> immediate , false , NULL , alloc_only , uid , & job_ptr , & err_msg , msg -> protocol_version ) ;\n if ( ! job_ptr || ( error_code && job_ptr -> job_state == JOB_FAILED ) ) {\n reject_job = true ;\n }\n else {\n if ( pack_job_id == 0 ) {\n pack_job_id = job_ptr -> job_id ;\n first_job_ptr = job_ptr ;\n alloc_only = 1 ;\n }\n snprintf ( tmp_str , sizeof ( tmp_str ) , \"%u\" , job_ptr -> job_id ) ;\n if ( jobid_hostset ) hostset_insert ( jobid_hostset , tmp_str ) ;\n else jobid_hostset = hostset_create ( tmp_str ) ;\n job_ptr -> pack_job_id = pack_job_id ;\n job_ptr -> pack_job_offset = pack_job_offset ++ ;\n job_ptr -> batch_flag = 1 ;\n list_append ( submit_job_list , job_ptr ) ;\n }\n if ( job_desc_msg -> immediate && ( error_code != SLURM_SUCCESS ) ) {\n error_code = ESLURM_CAN_NOT_START_IMMEDIATELY ;\n reject_job = true ;\n }\n if ( reject_job ) break ;\n }\n list_iterator_destroy ( iter ) ;\n xfree ( script ) ;\n if ( ( pack_job_id == 0 ) && ! reject_job ) {\n info ( \"%s: No error, but no pack_job_id\" , __func__ ) ;\n error_code = SLURM_ERROR ;\n reject_job = true ;\n }\n if ( ! reject_job && ( accounting_enforce & ACCOUNTING_ENFORCE_LIMITS ) && ! acct_policy_validate_pack ( submit_job_list ) ) {\n info ( \"Pack job %u exceeded association/QOS limit for user %u\" , pack_job_id , job_uid ) ;\n error_code = ESLURM_ACCOUNTING_POLICY ;\n reject_job = true ;\n }\n if ( ! reject_job ) {\n int buf_size = pack_job_offset * 16 ;\n char * tmp_str = xmalloc ( buf_size ) ;\n char * tmp_offset = tmp_str ;\n first_job_ptr -> pack_job_list = submit_job_list ;\n hostset_ranged_string ( jobid_hostset , buf_size , tmp_str ) ;\n if ( tmp_str [ 0 ] == '[' ) {\n tmp_offset = strchr ( tmp_str , ']' ) ;\n if ( tmp_offset ) tmp_offset [ 0 ] = '\\0' ;\n tmp_offset = tmp_str + 1 ;\n }\n iter = list_iterator_create ( submit_job_list ) ;\n while ( ( job_ptr = ( struct job_record * ) list_next ( iter ) ) ) {\n job_ptr -> pack_job_id_set = xstrdup ( tmp_offset ) ;\n if ( slurmctld_conf . debug_flags & DEBUG_FLAG_HETERO_JOBS ) {\n char buf [ JBUFSIZ ] ;\n info ( \"Submit %s\" , jobid2fmt ( job_ptr , buf , sizeof ( buf ) ) ) ;\n }\n }\n list_iterator_destroy ( iter ) ;\n xfree ( tmp_str ) ;\n }\n unlock_slurmctld ( job_write_lock ) ;\n _throttle_fini ( & active_rpc_cnt ) ;\n send_msg : END_TIMER2 ( \"_slurm_rpc_submit_batch_pack_job\" ) ;\n if ( reject_job ) {\n info ( \"%s: %s\" , __func__ , slurm_strerror ( error_code ) ) ;\n if ( err_msg ) slurm_send_rc_err_msg ( msg , error_code , err_msg ) ;\n else slurm_send_rc_msg ( msg , error_code ) ;\n if ( submit_job_list ) {\n ( void ) list_for_each ( submit_job_list , _pack_job_cancel , NULL ) ;\n if ( first_job_ptr ) first_job_ptr -> pack_job_list = submit_job_list ;\n else FREE_NULL_LIST ( submit_job_list ) ;\n }\n }\n else {\n info ( \"%s: JobId=%u %s\" , __func__ , pack_job_id , TIME_STR ) ;\n submit_msg . job_id = pack_job_id ;\n submit_msg . step_id = SLURM_BATCH_SCRIPT ;\n submit_msg . error_code = error_code ;\n submit_msg . job_submit_user_msg = job_submit_user_msg ;\n slurm_msg_t_init ( & response_msg ) ;\n response_msg . flags = msg -> flags ;\n response_msg . protocol_version = msg -> protocol_version ;\n response_msg . conn = msg -> conn ;\n response_msg . msg_type = RESPONSE_SUBMIT_BATCH_JOB ;\n response_msg . data = & submit_msg ;\n slurm_send_node_msg ( msg -> conn_fd , & response_msg ) ;\n schedule_job_save ( ) ;\n }\n if ( jobid_hostset ) hostset_destroy ( jobid_hostset ) ;\n xfree ( err_msg ) ;\n xfree ( job_submit_user_msg ) ;\n }", "idx": 21978}
{"hash": 4537091194729139981, "project": "chrome", "size": 8, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( FullscreenControllerInteractiveTest , DISABLED_TestTabExitsFullscreenOnGoBack ) {\n ASSERT_TRUE ( test_server ( ) -> Start ( ) ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , GURL ( \"about:blank\" ) ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , GURL ( \"chrome:/ewtab\" ) ) ;\n ASSERT_NO_FATAL_FAILURE ( ToggleTabFullscreen ( true ) ) ;\n GoBack ( ) ;\n ASSERT_FALSE ( browser ( ) -> window ( ) -> IsFullscreen ( ) ) ;\n }", "idx": 21979}
{"hash": 2578089348587614328, "project": "debian", "size": 3, "label": 0, "functionSource": "int i2d_X509_REQ_bio ( BIO * bp , X509_REQ * req ) {\n return ASN1_item_i2d_bio ( ASN1_ITEM_rptr ( X509_REQ ) , bp , req ) ;\n }", "idx": 21980}
{"hash": -8815658870890288443, "project": "chrome", "size": 3, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( CrossOriginXHR , FileAccessAllURLs ) {\n ASSERT_TRUE ( RunExtensionTest ( \"cross_origin_xhr/file_access_all_urls\" ) ) << message_ ;\n }", "idx": 21981}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_T_isdnOptions ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_T_isdnOptions , T_isdnOptions_choice , NULL ) ;\n return offset ;\n }", "idx": 21982}
{"hash": -3086035825515629592, "project": "debian", "size": 8, "label": 0, "functionSource": "void mszipd_free ( struct mszipd_stream * zip ) {\n struct mspack_system * sys ;\n if ( zip ) {\n sys = zip -> sys ;\n sys -> free ( zip -> inbuf ) ;\n sys -> free ( zip ) ;\n }\n }", "idx": 21983}
{"hash": -4534372572324105488, "project": "debian", "size": 48, "label": 0, "functionSource": "static int ni_prepare_read ( AVFormatContext * s ) {\n AVIContext * avi = s -> priv_data ;\n int best_stream_index = 0 ;\n AVStream * best_st = NULL ;\n AVIStream * best_ast ;\n int64_t best_ts = INT64_MAX ;\n int i ;\n for ( i = 0 ;\n i < s -> nb_streams ;\n i ++ ) {\n AVStream * st = s -> streams [ i ] ;\n AVIStream * ast = st -> priv_data ;\n int64_t ts = ast -> frame_offset ;\n int64_t last_ts ;\n if ( ! st -> nb_index_entries ) continue ;\n last_ts = st -> index_entries [ st -> nb_index_entries - 1 ] . timestamp ;\n if ( ! ast -> remaining && ts > last_ts ) continue ;\n ts = av_rescale_q ( ts , st -> time_base , ( AVRational ) {\n FFMAX ( 1 , ast -> sample_size ) , AV_TIME_BASE }\n ) ;\n av_log ( s , AV_LOG_TRACE , \"%\" PRId64 \" %d/%d %\" PRId64 \"\\n\" , ts , st -> time_base . num , st -> time_base . den , ast -> frame_offset ) ;\n if ( ts < best_ts ) {\n best_ts = ts ;\n best_st = st ;\n best_stream_index = i ;\n }\n }\n if ( ! best_st ) return AVERROR_EOF ;\n best_ast = best_st -> priv_data ;\n best_ts = best_ast -> frame_offset ;\n if ( best_ast -> remaining ) {\n i = av_index_search_timestamp ( best_st , best_ts , AVSEEK_FLAG_ANY | AVSEEK_FLAG_BACKWARD ) ;\n }\n else {\n i = av_index_search_timestamp ( best_st , best_ts , AVSEEK_FLAG_ANY ) ;\n if ( i >= 0 ) best_ast -> frame_offset = best_st -> index_entries [ i ] . timestamp ;\n }\n if ( i >= 0 ) {\n int64_t pos = best_st -> index_entries [ i ] . pos ;\n pos += best_ast -> packet_size - best_ast -> remaining ;\n if ( avio_seek ( s -> pb , pos + 8 , SEEK_SET ) < 0 ) return AVERROR_EOF ;\n av_assert0 ( best_ast -> remaining <= best_ast -> packet_size ) ;\n avi -> stream_index = best_stream_index ;\n if ( ! best_ast -> remaining ) best_ast -> packet_size = best_ast -> remaining = best_st -> index_entries [ i ] . size ;\n }\n else return AVERROR_EOF ;\n return 0 ;\n }", "idx": 21984}
{"hash": -2908211205972632000, "project": "debian", "size": 3, "label": 0, "functionSource": "static void cmd_window_rshow ( const char * data ) {\n _cmd_window_show_opt ( data , TRUE ) ;\n }", "idx": 21985}
{"hash": -7777331401175181229, "project": "debian", "size": 21, "label": 0, "functionSource": "static void cmd_server_remove ( const char * data ) {\n SERVER_SETUP_REC * rec ;\n char * addr , * port , * chatnet ;\n void * free_arg ;\n if ( ! cmd_get_params ( data , & free_arg , 3 , & addr , & port , & chatnet ) ) return ;\n if ( * addr == '\\0' ) cmd_param_error ( CMDERR_NOT_ENOUGH_PARAMS ) ;\n if ( * port == '\\0' ) {\n if ( * chatnet == '\\0' ) rec = server_setup_find ( addr , - 1 , NULL ) ;\n else rec = server_setup_find ( addr , - 1 , chatnet ) ;\n }\n else {\n if ( * chatnet == '\\0' ) rec = server_setup_find ( addr , atoi ( port ) , NULL ) ;\n else rec = server_setup_find ( addr , atoi ( port ) , chatnet ) ;\n }\n if ( rec == NULL ) printformat ( NULL , NULL , MSGLEVEL_CLIENTNOTICE , TXT_SETUPSERVER_NOT_FOUND , addr , port ) ;\n else {\n server_setup_remove ( rec ) ;\n printformat ( NULL , NULL , MSGLEVEL_CLIENTNOTICE , TXT_SETUPSERVER_REMOVED , addr , port ) ;\n }\n cmd_params_free ( free_arg ) ;\n }", "idx": 21986}
{"hash": 2335222688263906532, "project": "debian", "size": 48, "label": 0, "functionSource": "static int rv34_decode_inter_mb_header ( RV34DecContext * r , int8_t * intra_types ) {\n MpegEncContext * s = & r -> s ;\n GetBitContext * gb = & s -> gb ;\n int mb_pos = s -> mb_x + s -> mb_y * s -> mb_stride ;\n int i , t ;\n r -> block_type = r -> decode_mb_info ( r ) ;\n if ( r -> block_type == - 1 ) return - 1 ;\n s -> current_picture_ptr -> mb_type [ mb_pos ] = rv34_mb_type_to_lavc [ r -> block_type ] ;\n r -> mb_type [ mb_pos ] = r -> block_type ;\n if ( r -> block_type == RV34_MB_SKIP ) {\n if ( s -> pict_type == AV_PICTURE_TYPE_P ) r -> mb_type [ mb_pos ] = RV34_MB_P_16x16 ;\n if ( s -> pict_type == AV_PICTURE_TYPE_B ) r -> mb_type [ mb_pos ] = RV34_MB_B_DIRECT ;\n }\n r -> is16 = ! ! IS_INTRA16x16 ( s -> current_picture_ptr -> mb_type [ mb_pos ] ) ;\n rv34_decode_mv ( r , r -> block_type ) ;\n if ( r -> block_type == RV34_MB_SKIP ) {\n fill_rectangle ( intra_types , 4 , 4 , r -> intra_types_stride , 0 , sizeof ( intra_types [ 0 ] ) ) ;\n return 0 ;\n }\n r -> chroma_vlc = 1 ;\n r -> luma_vlc = 0 ;\n if ( IS_INTRA ( s -> current_picture_ptr -> mb_type [ mb_pos ] ) ) {\n if ( r -> is16 ) {\n t = get_bits ( gb , 2 ) ;\n fill_rectangle ( intra_types , 4 , 4 , r -> intra_types_stride , t , sizeof ( intra_types [ 0 ] ) ) ;\n r -> luma_vlc = 2 ;\n }\n else {\n if ( r -> decode_intra_types ( r , gb , intra_types ) < 0 ) return - 1 ;\n r -> luma_vlc = 1 ;\n }\n r -> chroma_vlc = 0 ;\n r -> cur_vlcs = choose_vlc_set ( r -> si . quant , r -> si . vlc_set , 0 ) ;\n }\n else {\n for ( i = 0 ;\n i < 16 ;\n i ++ ) intra_types [ ( i & 3 ) + ( i >> 2 ) * r -> intra_types_stride ] = 0 ;\n r -> cur_vlcs = choose_vlc_set ( r -> si . quant , r -> si . vlc_set , 1 ) ;\n if ( r -> mb_type [ mb_pos ] == RV34_MB_P_MIX16x16 ) {\n r -> is16 = 1 ;\n r -> chroma_vlc = 1 ;\n r -> luma_vlc = 2 ;\n r -> cur_vlcs = choose_vlc_set ( r -> si . quant , r -> si . vlc_set , 0 ) ;\n }\n }\n return rv34_decode_cbp ( gb , r -> cur_vlcs , r -> is16 ) ;\n }", "idx": 21987}
{"hash": 3576240888172463140, "project": "debian", "size": 85, "label": 0, "functionSource": "static int maybe_create_keyring_or_box ( char * filename , int is_box , int force_create ) {\n dotlock_t lockhd = NULL ;\n IOBUF iobuf ;\n int rc ;\n mode_t oldmask ;\n char * last_slash_in_filename ;\n int save_slash ;\n if ( ! access ( filename , F_OK ) ) return 0 ;\n if ( ! force_create ) return gpg_error ( GPG_ERR_ENOENT ) ;\n last_slash_in_filename = strrchr ( filename , DIRSEP_C ) ;\n # if HAVE_W32_SYSTEM {\n char * p = strrchr ( filename , '/' ) ;\n if ( ! last_slash_in_filename || p > last_slash_in_filename ) last_slash_in_filename = p ;\n }\n # endif if ( ! last_slash_in_filename ) return gpg_error ( GPG_ERR_ENOENT ) ;\n save_slash = * last_slash_in_filename ;\n * last_slash_in_filename = 0 ;\n if ( access ( filename , F_OK ) ) {\n static int tried ;\n if ( ! tried ) {\n tried = 1 ;\n try_make_homedir ( filename ) ;\n }\n if ( access ( filename , F_OK ) ) {\n rc = gpg_error_from_syserror ( ) ;\n * last_slash_in_filename = save_slash ;\n goto leave ;\n }\n }\n * last_slash_in_filename = save_slash ;\n lockhd = dotlock_create ( filename , 0 ) ;\n if ( ! lockhd ) {\n rc = gpg_error_from_syserror ( ) ;\n if ( opt . verbose ) log_info ( \"can't allocate lock for '%s': %s\\n\" , filename , gpg_strerror ( rc ) ) ;\n if ( ! force_create ) return gpg_error ( GPG_ERR_ENOENT ) ;\n else return rc ;\n }\n if ( dotlock_take ( lockhd , - 1 ) ) {\n rc = gpg_error_from_syserror ( ) ;\n log_info ( \"can't lock '%s': %s\\n\" , filename , gpg_strerror ( rc ) ) ;\n goto leave ;\n }\n if ( ! access ( filename , F_OK ) ) {\n rc = 0 ;\n goto leave ;\n }\n oldmask = umask ( 077 ) ;\n if ( is_secured_filename ( filename ) ) {\n iobuf = NULL ;\n gpg_err_set_errno ( EPERM ) ;\n }\n else iobuf = iobuf_create ( filename , 0 ) ;\n umask ( oldmask ) ;\n if ( ! iobuf ) {\n rc = gpg_error_from_syserror ( ) ;\n if ( is_box ) log_error ( _ ( \"error creating keybox '%s': %s\\n\" ) , filename , gpg_strerror ( rc ) ) ;\n else log_error ( _ ( \"error creating keyring '%s': %s\\n\" ) , filename , gpg_strerror ( rc ) ) ;\n goto leave ;\n }\n iobuf_close ( iobuf ) ;\n iobuf_ioctl ( NULL , IOBUF_IOCTL_INVALIDATE_CACHE , 0 , filename ) ;\n if ( is_box ) {\n FILE * fp = fopen ( filename , \"w\" ) ;\n if ( ! fp ) rc = gpg_error_from_syserror ( ) ;\n else {\n rc = _keybox_write_header_blob ( fp , 1 ) ;\n fclose ( fp ) ;\n }\n if ( rc ) {\n if ( is_box ) log_error ( _ ( \"error creating keybox '%s': %s\\n\" ) , filename , gpg_strerror ( rc ) ) ;\n else log_error ( _ ( \"error creating keyring '%s': %s\\n\" ) , filename , gpg_strerror ( rc ) ) ;\n goto leave ;\n }\n }\n if ( ! opt . quiet ) {\n if ( is_box ) log_info ( _ ( \"keybox '%s' created\\n\" ) , filename ) ;\n else log_info ( _ ( \"keyring '%s' created\\n\" ) , filename ) ;\n }\n rc = 0 ;\n leave : if ( lockhd ) {\n dotlock_release ( lockhd ) ;\n dotlock_destroy ( lockhd ) ;\n }\n return rc ;\n }", "idx": 21988}
{"hash": -1315695702746584250, "project": "debian", "size": 7, "label": 0, "functionSource": "static inline const guint8 * get_string_value ( wmem_allocator_t * scope , tvbuff_t * tvb , gint start , gint length , gint * ret_length , const guint encoding ) {\n if ( length == - 1 ) {\n length = tvb_ensure_captured_length_remaining ( tvb , start ) ;\n }\n * ret_length = length ;\n return tvb_get_string_enc ( scope , tvb , start , length , encoding ) ;\n }", "idx": 21989}
{"hash": 4180964683905830761, "project": "debian", "size": 9, "label": 0, "functionSource": "static int selinux_shm_associate ( struct shmid_kernel * shp , int shmflg ) {\n struct ipc_security_struct * isec ;\n struct common_audit_data ad ;\n u32 sid = current_sid ( ) ;\n isec = shp -> shm_perm . security ;\n ad . type = LSM_AUDIT_DATA_IPC ;\n ad . u . ipc_id = shp -> shm_perm . key ;\n return avc_has_perm ( sid , isec -> sid , SECCLASS_SHM , SHM__ASSOCIATE , & ad ) ;\n }", "idx": 21990}
{"hash": -2222463888415249941, "project": "chrome", "size": 6, "label": 1, "functionSource": "static void Pass2Encode ( VP9_COMP * cpi , size_t * size , uint8_t * dest , unsigned int * frame_flags ) {\n cpi -> allow_encode_breakout = ENCODE_BREAKOUT_ENABLED ;\n vp9_rc_get_second_pass_params ( cpi ) ;\n encode_frame_to_data_rate ( cpi , size , dest , frame_flags ) ;\n vp9_twopass_postencode_update ( cpi ) ;\n }", "idx": 21991}
{"hash": 3557739556029059195, "project": "chrome", "size": 7, "label": 0, "functionSource": "void vp9_sad ## m ## x ## n ## x4d_c ( const uint8_t * src , int src_stride , const uint8_t * const refs [ ] , int ref_stride , unsigned int * sads ) {\n int i ;\n for ( i = 0 ;\n i < 4 ;\n ++ i ) sads [ i ] = vp9_sad ## m ## x ## n ## _c ( src , src_stride , refs [ i ] , ref_stride ) ;\n \\ }\n sadMxN ( 64 , 64 ) sadMxNxK ( 64 , 64 , 3 ) sadMxNxK ( 64 , 64 , 8 ) sadMxNx4D ( 64 , 64 ) sadMxN ( 64 , 32 ) sadMxNx4D ( 64 , 32 ) sadMxN ( 32 , 64 ) sadMxNx4D ( 32 , 64 ) sadMxN ( 32 , 32 ) sadMxNxK ( 32 , 32 , 3 ) sadMxNxK ( 32 , 32 , 8 ) sadMxNx4D ( 32 , 32 )", "idx": 21992}
{"hash": 2419147764757351618, "project": "debian", "size": 8, "label": 0, "functionSource": "static int s390_virtio_net_init ( VirtIOS390Device * dev ) {\n VirtIODevice * vdev ;\n vdev = virtio_net_init ( ( DeviceState * ) dev , & dev -> nic ) ;\n if ( ! vdev ) {\n return - 1 ;\n }\n return s390_virtio_device_init ( dev , vdev ) ;\n }", "idx": 21993}
{"hash": -866921002076081979, "project": "debian", "size": 35, "label": 0, "functionSource": "EXCLUSIVE_REGRESSION_TEST ( SDK_API_HttpTxnTransform ) ( RegressionTest * test , int , int * pstatus ) {\n * pstatus = REGRESSION_TEST_INPROGRESS ;\n Debug ( UTDBG_TAG \"_transform\" , \"Starting test\" ) ;\n TSCont cont = TSContCreate ( transform_hook_handler , TSMutexCreate ( ) ) ;\n if ( cont == nullptr ) {\n SDK_RPRINT ( test , \"TSHttpSsn\" , \"TestCase1\" , TC_FAIL , \"Unable to create Continuation.\" ) ;\n * pstatus = REGRESSION_TEST_FAILED ;\n return ;\n }\n TransformTestData * socktest = ( TransformTestData * ) TSmalloc ( sizeof ( TransformTestData ) ) ;\n socktest -> test = test ;\n socktest -> pstatus = pstatus ;\n socktest -> test_passed_txn_transform_resp_get = true ;\n socktest -> test_passed_txn_transformed_resp_cache = false ;\n socktest -> test_passed_txn_transformed_resp_cache = false ;\n socktest -> test_passed_transform_create = false ;\n socktest -> req_no = 1 ;\n socktest -> magic = MAGIC_ALIVE ;\n TSContDataSet ( cont , socktest ) ;\n load ( TRANSFORM_APPEND_STRING ) ;\n TSHttpHookAdd ( TS_HTTP_READ_REQUEST_HDR_HOOK , cont ) ;\n TSHttpHookAdd ( TS_HTTP_READ_RESPONSE_HDR_HOOK , cont ) ;\n socktest -> os = synserver_create ( SYNSERVER_LISTEN_PORT ) ;\n synserver_start ( socktest -> os ) ;\n socktest -> browser1 = synclient_txn_create ( ) ;\n socktest -> browser2 = synclient_txn_create ( ) ;\n socktest -> browser3 = synclient_txn_create ( ) ;\n socktest -> browser4 = synclient_txn_create ( ) ;\n socktest -> request1 = generate_request ( 4 ) ;\n socktest -> request2 = generate_request ( 5 ) ;\n Debug ( UTDBG_TAG \"_transform\" , \"Running Browser 1\" ) ;\n synclient_txn_send_request ( socktest -> browser1 , socktest -> request1 ) ;\n TSContSchedule ( cont , 25 , TS_THREAD_POOL_DEFAULT ) ;\n return ;\n }", "idx": 21994}
{"hash": 6595989226414083189, "project": "debian", "size": 3, "label": 0, "functionSource": "static __always_inline __le32 __cpu_to_le32p ( const __u32 * p ) {\n return ( __le32 ) * p ;\n }", "idx": 21995}
{"hash": -2127895299879503273, "project": "debian", "size": 119, "label": 0, "functionSource": "static void pmac_ide_transfer_cb ( void * opaque , int ret ) {\n DBDMA_io * io = opaque ;\n MACIOIDEState * m = io -> opaque ;\n IDEState * s = idebus_active_if ( & m -> bus ) ;\n int n = 0 ;\n int64_t sector_num ;\n int unaligned ;\n if ( ret < 0 ) {\n MACIO_DPRINTF ( \"DMA error\\n\" ) ;\n m -> aiocb = NULL ;\n qemu_sglist_destroy ( & s -> sg ) ;\n ide_dma_error ( s ) ;\n io -> remainder_len = 0 ;\n goto done ;\n }\n if ( -- io -> requests ) {\n return ;\n }\n if ( ! m -> dma_active ) {\n MACIO_DPRINTF ( \"waiting for data (%#x - %#x - %x)\\n\" , s -> nsector , io -> len , s -> status ) ;\n io -> processing = false ;\n return ;\n }\n sector_num = ide_get_sector ( s ) ;\n MACIO_DPRINTF ( \"io_buffer_size = %#x\\n\" , s -> io_buffer_size ) ;\n if ( s -> io_buffer_size > 0 ) {\n m -> aiocb = NULL ;\n qemu_sglist_destroy ( & s -> sg ) ;\n n = ( s -> io_buffer_size + 0x1ff ) >> 9 ;\n sector_num += n ;\n ide_set_sector ( s , sector_num ) ;\n s -> nsector -= n ;\n }\n if ( io -> finish_remain_read ) {\n io -> finish_remain_read = false ;\n cpu_physical_memory_write ( io -> finish_addr , io -> remainder , io -> finish_len ) ;\n }\n MACIO_DPRINTF ( \"remainder: %d io->len: %d nsector: %d \" \"sector_num: %\" PRId64 \"\\n\" , io -> remainder_len , io -> len , s -> nsector , sector_num ) ;\n if ( io -> remainder_len && io -> len ) {\n int remainder_len = MIN ( io -> remainder_len , io -> len ) ;\n uint8_t * p = & io -> remainder [ 0x200 - remainder_len ] ;\n MACIO_DPRINTF ( \"copying remainder %d bytes at %#\" HWADDR_PRIx \"\\n\" , remainder_len , io -> addr ) ;\n switch ( s -> dma_cmd ) {\n case IDE_DMA_READ : cpu_physical_memory_write ( io -> addr , p , remainder_len ) ;\n break ;\n case IDE_DMA_WRITE : cpu_physical_memory_read ( io -> addr , p , remainder_len ) ;\n break ;\n case IDE_DMA_TRIM : break ;\n }\n io -> addr += remainder_len ;\n io -> len -= remainder_len ;\n io -> remainder_len -= remainder_len ;\n if ( s -> dma_cmd == IDE_DMA_WRITE && ! io -> remainder_len ) {\n io -> requests ++ ;\n qemu_iovec_reset ( & io -> iov ) ;\n qemu_iovec_add ( & io -> iov , io -> remainder , 0x200 ) ;\n m -> aiocb = blk_aio_writev ( s -> blk , sector_num - 1 , & io -> iov , 1 , pmac_ide_transfer_cb , io ) ;\n }\n }\n if ( s -> nsector == 0 && ! io -> remainder_len ) {\n MACIO_DPRINTF ( \"end of transfer\\n\" ) ;\n s -> status = READY_STAT | SEEK_STAT ;\n ide_set_irq ( s -> bus ) ;\n m -> dma_active = false ;\n }\n if ( io -> len == 0 ) {\n MACIO_DPRINTF ( \"end of DMA\\n\" ) ;\n goto done ;\n }\n s -> io_buffer_index = 0 ;\n s -> io_buffer_size = MIN ( io -> len , s -> nsector * 512 ) ;\n unaligned = io -> len & 0x1ff ;\n if ( unaligned ) {\n int nsector = io -> len >> 9 ;\n MACIO_DPRINTF ( \"precopying unaligned %d bytes to %#\" HWADDR_PRIx \"\\n\" , unaligned , io -> addr + io -> len - unaligned ) ;\n switch ( s -> dma_cmd ) {\n case IDE_DMA_READ : io -> requests ++ ;\n io -> finish_addr = io -> addr + io -> len - unaligned ;\n io -> finish_len = unaligned ;\n io -> finish_remain_read = true ;\n qemu_iovec_reset ( & io -> iov ) ;\n qemu_iovec_add ( & io -> iov , io -> remainder , 0x200 ) ;\n m -> aiocb = blk_aio_readv ( s -> blk , sector_num + nsector , & io -> iov , 1 , pmac_ide_transfer_cb , io ) ;\n break ;\n case IDE_DMA_WRITE : cpu_physical_memory_read ( io -> addr + io -> len - unaligned , io -> remainder + io -> remainder_len , unaligned ) ;\n break ;\n case IDE_DMA_TRIM : break ;\n }\n }\n MACIO_DPRINTF ( \"io->len = %#x\\n\" , io -> len ) ;\n qemu_sglist_init ( & s -> sg , DEVICE ( m ) , io -> len / MACIO_PAGE_SIZE + 1 , & address_space_memory ) ;\n qemu_sglist_add ( & s -> sg , io -> addr , io -> len ) ;\n io -> addr += io -> len + unaligned ;\n io -> remainder_len = ( 0x200 - unaligned ) & 0x1ff ;\n MACIO_DPRINTF ( \"set remainder to: %d\\n\" , io -> remainder_len ) ;\n if ( ! io -> len ) {\n if ( ! io -> requests ) {\n io -> requests ++ ;\n pmac_ide_transfer_cb ( opaque , ret ) ;\n }\n return ;\n }\n io -> len = 0 ;\n MACIO_DPRINTF ( \"sector_num=%\" PRId64 \" n=%d, nsector=%d, cmd_cmd=%d\\n\" , sector_num , n , s -> nsector , s -> dma_cmd ) ;\n switch ( s -> dma_cmd ) {\n case IDE_DMA_READ : m -> aiocb = dma_blk_read ( s -> blk , & s -> sg , sector_num , pmac_ide_transfer_cb , io ) ;\n break ;\n case IDE_DMA_WRITE : m -> aiocb = dma_blk_write ( s -> blk , & s -> sg , sector_num , pmac_ide_transfer_cb , io ) ;\n break ;\n case IDE_DMA_TRIM : m -> aiocb = dma_blk_io ( s -> blk , & s -> sg , sector_num , ide_issue_trim , pmac_ide_transfer_cb , io , DMA_DIRECTION_TO_DEVICE ) ;\n break ;\n }\n io -> requests ++ ;\n return ;\n done : if ( s -> dma_cmd == IDE_DMA_READ || s -> dma_cmd == IDE_DMA_WRITE ) {\n block_acct_done ( blk_get_stats ( s -> blk ) , & s -> acct ) ;\n }\n io -> dma_end ( io ) ;\n }", "idx": 21996}
{"hash": -2943582541244387919, "project": "chrome", "size": 36, "label": 0, "functionSource": "unsigned int vp9_sub_pixel_avg_variance ## W ## x ## H ## _c ( const uint8_t * src , int src_stride , int xoffset , int yoffset , const uint8_t * dst , int dst_stride , unsigned int * sse , const uint8_t * second_pred ) {\n uint16_t fdata3 [ ( H + 1 ) * W ] ;\n uint8_t temp2 [ H * W ] ;\n DECLARE_ALIGNED_ARRAY ( 16 , uint8_t , temp3 , H * W ) ;\n var_filter_block2d_bil_first_pass ( src , fdata3 , src_stride , 1 , H + 1 , W , BILINEAR_FILTERS_2TAP ( xoffset ) ) ;\n var_filter_block2d_bil_second_pass ( fdata3 , temp2 , W , W , H , W , BILINEAR_FILTERS_2TAP ( yoffset ) ) ;\n vp9_comp_avg_pred ( temp3 , second_pred , W , H , temp2 , W ) ;\n return vp9_variance ## W ## x ## H ## _c ( temp3 , W , dst , dst_stride , sse ) ;\n \\ }\n void vp9_get16x16var_c ( const uint8_t * src_ptr , int source_stride , const uint8_t * ref_ptr , int ref_stride , unsigned int * sse , int * sum ) {\n variance ( src_ptr , source_stride , ref_ptr , ref_stride , 16 , 16 , sse , sum ) ;\n }\n void vp9_get8x8var_c ( const uint8_t * src_ptr , int source_stride , const uint8_t * ref_ptr , int ref_stride , unsigned int * sse , int * sum ) {\n variance ( src_ptr , source_stride , ref_ptr , ref_stride , 8 , 8 , sse , sum ) ;\n }\n unsigned int vp9_mse16x16_c ( const uint8_t * src , int src_stride , const uint8_t * ref , int ref_stride , unsigned int * sse ) {\n int sum ;\n variance ( src , src_stride , ref , ref_stride , 16 , 16 , sse , & sum ) ;\n return * sse ;\n }\n unsigned int vp9_mse16x8_c ( const uint8_t * src , int src_stride , const uint8_t * ref , int ref_stride , unsigned int * sse ) {\n int sum ;\n variance ( src , src_stride , ref , ref_stride , 16 , 8 , sse , & sum ) ;\n return * sse ;\n }\n unsigned int vp9_mse8x16_c ( const uint8_t * src , int src_stride , const uint8_t * ref , int ref_stride , unsigned int * sse ) {\n int sum ;\n variance ( src , src_stride , ref , ref_stride , 8 , 16 , sse , & sum ) ;\n return * sse ;\n }\n unsigned int vp9_mse8x8_c ( const uint8_t * src , int src_stride , const uint8_t * ref , int ref_stride , unsigned int * sse ) {\n int sum ;\n variance ( src , src_stride , ref , ref_stride , 8 , 8 , sse , & sum ) ;\n return * sse ;\n }\n VAR ( 4 , 4 ) SUBPIX_VAR ( 4 , 4 ) SUBPIX_AVG_VAR ( 4 , 4 ) VAR ( 4 , 8 ) SUBPIX_VAR ( 4 , 8 ) SUBPIX_AVG_VAR ( 4 , 8 ) VAR ( 8 , 4 ) SUBPIX_VAR ( 8 , 4 ) SUBPIX_AVG_VAR ( 8 , 4 ) VAR ( 8 , 8 ) SUBPIX_VAR ( 8 , 8 ) SUBPIX_AVG_VAR ( 8 , 8 ) VAR ( 8 , 16 ) SUBPIX_VAR ( 8 , 16 ) SUBPIX_AVG_VAR ( 8 , 16 ) VAR ( 16 , 8 ) SUBPIX_VAR ( 16 , 8 ) SUBPIX_AVG_VAR ( 16 , 8 ) VAR ( 16 , 16 ) SUBPIX_VAR ( 16 , 16 ) SUBPIX_AVG_VAR ( 16 , 16 ) VAR ( 16 , 32 ) SUBPIX_VAR ( 16 , 32 ) SUBPIX_AVG_VAR ( 16 , 32 )", "idx": 21997}
{"hash": 2716625165137468453, "project": "debian", "size": 25, "label": 1, "functionSource": "static int msvideo1_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n Msvideo1Context * s = avctx -> priv_data ;\n s -> buf = buf ;\n s -> size = buf_size ;\n s -> frame . reference = 1 ;\n s -> frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE ;\n if ( avctx -> reget_buffer ( avctx , & s -> frame ) ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"reget_buffer() failed\\n\" ) ;\n return - 1 ;\n }\n if ( s -> mode_8bit ) {\n const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;\n if ( pal ) {\n memcpy ( s -> pal , pal , AVPALETTE_SIZE ) ;\n s -> frame . palette_has_changed = 1 ;\n }\n }\n if ( s -> mode_8bit ) msvideo1_decode_8bit ( s ) ;\n else msvideo1_decode_16bit ( s ) ;\n * got_frame = 1 ;\n * ( AVFrame * ) data = s -> frame ;\n return buf_size ;\n }", "idx": 21998}
{"hash": 3599206110384554647, "project": "debian", "size": 65, "label": 1, "functionSource": "unsigned long # define BN_BYTES 8 # endif # ifdef SIXTY_FOUR_BIT # define BN_ULONG unsigned long long # define BN_BYTES 8 # endif # ifdef THIRTY_TWO_BIT # define BN_ULONG unsigned int # define BN_BYTES 4 # endif # define BN_BITS2 ( BN_BYTES * 8 ) # define BN_BITS ( BN_BITS2 * 2 ) # define BN_TBIT ( ( BN_ULONG ) 1 << ( BN_BITS2 - 1 ) ) # define BN_FLG_MALLOCED 0x01 # define BN_FLG_STATIC_DATA 0x02 # define BN_FLG_CONSTTIME 0x04 # define BN_FLG_SECURE 0x08 # if OPENSSL_API_COMPAT < 0x00908000L # define BN_FLG_EXP_CONSTTIME BN_FLG_CONSTTIME # define BN_FLG_FREE 0x8000 # endif void BN_set_flags ( BIGNUM * b , int n ) ;\n int BN_get_flags ( const BIGNUM * b , int n ) ;\n # define BN_RAND_TOP_ANY - 1 # define BN_RAND_TOP_ONE 0 # define BN_RAND_TOP_TWO 1 # define BN_RAND_BOTTOM_ANY 0 # define BN_RAND_BOTTOM_ODD 1 void BN_with_flags ( BIGNUM * dest , const BIGNUM * b , int flags ) ;\n int BN_GENCB_call ( BN_GENCB * cb , int a , int b ) ;\n BN_GENCB * BN_GENCB_new ( void ) ;\n void BN_GENCB_free ( BN_GENCB * cb ) ;\n void BN_GENCB_set_old ( BN_GENCB * gencb , void ( * callback ) ( int , int , void * ) , void * cb_arg ) ;\n void BN_GENCB_set ( BN_GENCB * gencb , int ( * callback ) ( int , int , BN_GENCB * ) , void * cb_arg ) ;\n void * BN_GENCB_get_arg ( BN_GENCB * cb ) ;\n # define BN_prime_checks 0 # define BN_prime_checks_for_size ( b ) ( ( b ) >= 3747 ? 3 : ( b ) >= 1345 ? 4 : ( b ) >= 476 ? 5 : ( b ) >= 400 ? 6 : ( b ) >= 347 ? 7 : ( b ) >= 308 ? 8 : ( b ) >= 55 ? 27 : 34 ) # define BN_num_bytes ( a ) ( ( BN_num_bits ( a ) + 7 ) / 8 ) int BN_abs_is_word ( const BIGNUM * a , const BN_ULONG w ) ;\n int BN_is_zero ( const BIGNUM * a ) ;\n int BN_is_one ( const BIGNUM * a ) ;\n int BN_is_word ( const BIGNUM * a , const BN_ULONG w ) ;\n int BN_is_odd ( const BIGNUM * a ) ;\n # define BN_one ( a ) ( BN_set_word ( ( a ) , 1 ) ) void BN_zero_ex ( BIGNUM * a ) ;\n # if OPENSSL_API_COMPAT >= 0x00908000L # define BN_zero ( a ) BN_zero_ex ( a ) # else # define BN_zero ( a ) ( BN_set_word ( ( a ) , 0 ) ) # endif const BIGNUM * BN_value_one ( void ) ;\n char * BN_options ( void ) ;\n BN_CTX * BN_CTX_new ( void ) ;\n BN_CTX * BN_CTX_secure_new ( void ) ;\n void BN_CTX_free ( BN_CTX * c ) ;\n void BN_CTX_start ( BN_CTX * ctx ) ;\n BIGNUM * BN_CTX_get ( BN_CTX * ctx ) ;\n void BN_CTX_end ( BN_CTX * ctx ) ;\n int BN_rand ( BIGNUM * rnd , int bits , int top , int bottom ) ;\n int BN_priv_rand ( BIGNUM * rnd , int bits , int top , int bottom ) ;\n int BN_rand_range ( BIGNUM * rnd , const BIGNUM * range ) ;\n int BN_priv_rand_range ( BIGNUM * rnd , const BIGNUM * range ) ;\n int BN_pseudo_rand ( BIGNUM * rnd , int bits , int top , int bottom ) ;\n int BN_pseudo_rand_range ( BIGNUM * rnd , const BIGNUM * range ) ;\n int BN_num_bits ( const BIGNUM * a ) ;\n int BN_num_bits_word ( BN_ULONG l ) ;\n int BN_security_bits ( int L , int N ) ;\n BIGNUM * BN_new ( void ) ;\n BIGNUM * BN_secure_new ( void ) ;\n void BN_clear_free ( BIGNUM * a ) ;\n BIGNUM * BN_copy ( BIGNUM * a , const BIGNUM * b ) ;\n void BN_swap ( BIGNUM * a , BIGNUM * b ) ;\n BIGNUM * BN_bin2bn ( const unsigned char * s , int len , BIGNUM * ret ) ;\n int BN_bn2bin ( const BIGNUM * a , unsigned char * to ) ;\n int BN_bn2binpad ( const BIGNUM * a , unsigned char * to , int tolen ) ;\n BIGNUM * BN_lebin2bn ( const unsigned char * s , int len , BIGNUM * ret ) ;\n int BN_bn2lebinpad ( const BIGNUM * a , unsigned char * to , int tolen ) ;\n BIGNUM * BN_mpi2bn ( const unsigned char * s , int len , BIGNUM * ret ) ;\n int BN_bn2mpi ( const BIGNUM * a , unsigned char * to ) ;\n int BN_sub ( BIGNUM * r , const BIGNUM * a , const BIGNUM * b ) ;\n int BN_usub ( BIGNUM * r , const BIGNUM * a , const BIGNUM * b ) ;\n int BN_uadd ( BIGNUM * r , const BIGNUM * a , const BIGNUM * b ) ;\n int BN_add ( BIGNUM * r , const BIGNUM * a , const BIGNUM * b ) ;\n int BN_mul ( BIGNUM * r , const BIGNUM * a , const BIGNUM * b , BN_CTX * ctx ) ;\n int BN_sqr ( BIGNUM * r , const BIGNUM * a , BN_CTX * ctx ) ;\n void BN_set_negative ( BIGNUM * b , int n ) ;\n int BN_is_negative ( const BIGNUM * b ) ;\n int BN_div ( BIGNUM * dv , BIGNUM * rem , const BIGNUM * m , const BIGNUM * d , BN_CTX * ctx ) ;\n # define BN_mod ( rem , m , d , ctx ) BN_div ( NULL , ( rem ) , ( m ) , ( d ) , ( ctx ) ) int BN_nnmod ( BIGNUM * r , const BIGNUM * m , const BIGNUM * d , BN_CTX * ctx ) ;\n int BN_mod_add ( BIGNUM * r , const BIGNUM * a , const BIGNUM * b , const BIGNUM * m , BN_CTX * ctx ) ;\n int BN_mod_add_quick ( BIGNUM * r , const BIGNUM * a , const BIGNUM * b , const BIGNUM * m ) ;\n int BN_mod_sub ( BIGNUM * r , const BIGNUM * a , const BIGNUM * b , const BIGNUM * m , BN_CTX * ctx ) ;\n int BN_mod_sub_quick ( BIGNUM * r , const BIGNUM * a , const BIGNUM * b , const BIGNUM * m ) ;\n int BN_mod_mul ( BIGNUM * r , const BIGNUM * a , const BIGNUM * b , const BIGNUM * m , BN_CTX * ctx ) ;\n int BN_mod_sqr ( BIGNUM * r , const BIGNUM * a , const BIGNUM * m , BN_CTX * ctx ) ;\n int BN_mod_lshift1 ( BIGNUM * r , const BIGNUM * a , const BIGNUM * m , BN_CTX * ctx ) ;\n int BN_mod_lshift1_quick ( BIGNUM * r , const BIGNUM * a , const BIGNUM * m ) ;\n int BN_mod_lshift ( BIGNUM * r , const BIGNUM * a , int n , const BIGNUM * m , BN_CTX * ctx ) ;\n int BN_mod_lshift_quick ( BIGNUM * r , const BIGNUM * a , int n , const BIGNUM * m ) ;\n BN_ULONG BN_mod_word ( const BIGNUM * a , BN_ULONG w )", "idx": 21999}
{"hash": 1366214969540455677, "project": "debian", "size": 97, "label": 1, "functionSource": "int i2d_ ## name ( type * a , unsigned char * * out ) ;\n DECLARE_ASN1_ITEM ( itname ) # define DECLARE_ASN1_ENCODE_FUNCTIONS_const ( type , name ) type * d2i_ ## name ( type * * a , const unsigned char * * in , long len ) ;\n int i2d_ ## name ( const type * a , unsigned char * * out ) ;\n DECLARE_ASN1_ITEM ( name ) # define DECLARE_ASN1_NDEF_FUNCTION ( name ) int i2d_ ## name ## _NDEF ( name * a , unsigned char * * out ) ;\n # define DECLARE_ASN1_FUNCTIONS_const ( name ) DECLARE_ASN1_ALLOC_FUNCTIONS ( name ) DECLARE_ASN1_ENCODE_FUNCTIONS_const ( name , name ) # define DECLARE_ASN1_ALLOC_FUNCTIONS_name ( type , name ) type * name ## _new ( void ) ;\n void name ## _free ( type * a ) ;\n # define DECLARE_ASN1_PRINT_FUNCTION ( stname ) DECLARE_ASN1_PRINT_FUNCTION_fname ( stname , stname ) # define DECLARE_ASN1_PRINT_FUNCTION_fname ( stname , fname ) int fname ## _print_ctx ( BIO * out , stname * x , int indent , const ASN1_PCTX * pctx ) ;\n # define D2I_OF ( type ) type * ( * ) ( type * * , const unsigned char * * , long ) # define I2D_OF ( type ) int ( * ) ( type * , unsigned char * * ) # define I2D_OF_const ( type ) int ( * ) ( const type * , unsigned char * * ) # define CHECKED_D2I_OF ( type , d2i ) ( ( d2i_of_void * ) ( 1 ? d2i : ( ( D2I_OF ( type ) ) 0 ) ) ) # define CHECKED_I2D_OF ( type , i2d ) ( ( i2d_of_void * ) ( 1 ? i2d : ( ( I2D_OF ( type ) ) 0 ) ) ) # define CHECKED_NEW_OF ( type , xnew ) ( ( void * ( * ) ( void ) ) ( 1 ? xnew : ( ( type * ( * ) ( void ) ) 0 ) ) ) # define CHECKED_PTR_OF ( type , p ) ( ( void * ) ( 1 ? p : ( type * ) 0 ) ) # define CHECKED_PPTR_OF ( type , p ) ( ( void * * ) ( 1 ? p : ( type * * ) 0 ) ) # define TYPEDEF_D2I_OF ( type ) typedef type * d2i_of_ ## type ( type * * , const unsigned char * * , long ) # define TYPEDEF_I2D_OF ( type ) typedef int i2d_of_ ## type ( type * , unsigned char * * ) # define TYPEDEF_D2I2D_OF ( type ) TYPEDEF_D2I_OF ( type ) ;\n TYPEDEF_I2D_OF ( type ) TYPEDEF_D2I2D_OF ( void ) ;\n # ifndef OPENSSL_EXPORT_VAR_AS_FUNCTION typedef const ASN1_ITEM ASN1_ITEM_EXP ;\n # define ASN1_ITEM_ptr ( iptr ) ( iptr ) # define ASN1_ITEM_ref ( iptr ) ( & ( iptr ## _it ) ) # define ASN1_ITEM_rptr ( ref ) ( & ( ref ## _it ) ) # define DECLARE_ASN1_ITEM ( name ) OPENSSL_EXTERN const ASN1_ITEM name ## _it ;\n # else typedef const ASN1_ITEM * ASN1_ITEM_EXP ( void ) ;\n # define ASN1_ITEM_ptr ( iptr ) ( iptr ( ) ) # define ASN1_ITEM_ref ( iptr ) ( iptr ## _it ) # define ASN1_ITEM_rptr ( ref ) ( ref ## _it ( ) ) # define DECLARE_ASN1_ITEM ( name ) const ASN1_ITEM * name ## _it ( void ) ;\n # endif # define ASN1_STRFLGS_ESC_2253 1 # define ASN1_STRFLGS_ESC_CTRL 2 # define ASN1_STRFLGS_ESC_MSB 4 # define ASN1_STRFLGS_ESC_QUOTE 8 # define CHARTYPE_PRINTABLESTRING 0x10 # define CHARTYPE_FIRST_ESC_2253 0x20 # define CHARTYPE_LAST_ESC_2253 0x40 # define ASN1_STRFLGS_UTF8_CONVERT 0x10 # define ASN1_STRFLGS_IGNORE_TYPE 0x20 # define ASN1_STRFLGS_SHOW_TYPE 0x40 # define ASN1_STRFLGS_DUMP_ALL 0x80 # define ASN1_STRFLGS_DUMP_UNKNOWN 0x100 # define ASN1_STRFLGS_DUMP_DER 0x200 # define ASN1_STRFLGS_ESC_2254 0x400 # define ASN1_STRFLGS_RFC2253 ( ASN1_STRFLGS_ESC_2253 | ASN1_STRFLGS_ESC_CTRL | ASN1_STRFLGS_ESC_MSB | ASN1_STRFLGS_UTF8_CONVERT | ASN1_STRFLGS_DUMP_UNKNOWN | ASN1_STRFLGS_DUMP_DER ) DEFINE_STACK_OF ( ASN1_INTEGER ) DEFINE_STACK_OF ( ASN1_GENERALSTRING ) DEFINE_STACK_OF ( ASN1_UTF8STRING ) typedef struct asn1_type_st {\n int type ;\n union {\n char * ptr ;\n ASN1_BOOLEAN boolean ;\n ASN1_STRING * asn1_string ;\n ASN1_OBJECT * object ;\n ASN1_INTEGER * integer ;\n ASN1_ENUMERATED * enumerated ;\n ASN1_BIT_STRING * bit_string ;\n ASN1_OCTET_STRING * octet_string ;\n ASN1_PRINTABLESTRING * printablestring ;\n ASN1_T61STRING * t61string ;\n ASN1_IA5STRING * ia5string ;\n ASN1_GENERALSTRING * generalstring ;\n ASN1_BMPSTRING * bmpstring ;\n ASN1_UNIVERSALSTRING * universalstring ;\n ASN1_UTCTIME * utctime ;\n ASN1_GENERALIZEDTIME * generalizedtime ;\n ASN1_VISIBLESTRING * visiblestring ;\n ASN1_UTF8STRING * utf8string ;\n ASN1_STRING * set ;\n ASN1_STRING * sequence ;\n ASN1_VALUE * asn1_value ;\n }\n value ;\n }\n ASN1_TYPE ;\n DEFINE_STACK_OF ( ASN1_TYPE ) typedef STACK_OF ( ASN1_TYPE ) ASN1_SEQUENCE_ANY ;\n DECLARE_ASN1_ENCODE_FUNCTIONS_const ( ASN1_SEQUENCE_ANY , ASN1_SEQUENCE_ANY ) DECLARE_ASN1_ENCODE_FUNCTIONS_const ( ASN1_SEQUENCE_ANY , ASN1_SET_ANY ) typedef struct BIT_STRING_BITNAME_st {\n int bitnum ;\n const char * lname ;\n const char * sname ;\n }\n BIT_STRING_BITNAME ;\n # define B_ASN1_TIME B_ASN1_UTCTIME | B_ASN1_GENERALIZEDTIME # define B_ASN1_PRINTABLE B_ASN1_NUMERICSTRING | B_ASN1_PRINTABLESTRING | B_ASN1_T61STRING | B_ASN1_IA5STRING | B_ASN1_BIT_STRING | B_ASN1_UNIVERSALSTRING | B_ASN1_BMPSTRING | B_ASN1_UTF8STRING | B_ASN1_SEQUENCE | B_ASN1_UNKNOWN # define B_ASN1_DIRECTORYSTRING B_ASN1_PRINTABLESTRING | B_ASN1_TELETEXSTRING | B_ASN1_BMPSTRING | B_ASN1_UNIVERSALSTRING | B_ASN1_UTF8STRING # define B_ASN1_DISPLAYTEXT B_ASN1_IA5STRING | B_ASN1_VISIBLESTRING | B_ASN1_BMPSTRING | B_ASN1_UTF8STRING DECLARE_ASN1_FUNCTIONS_fname ( ASN1_TYPE , ASN1_ANY , ASN1_TYPE ) int ASN1_TYPE_get ( const ASN1_TYPE * a ) ;\n void ASN1_TYPE_set ( ASN1_TYPE * a , int type , void * value ) ;\n int ASN1_TYPE_set1 ( ASN1_TYPE * a , int type , const void * value ) ;\n int ASN1_TYPE_cmp ( const ASN1_TYPE * a , const ASN1_TYPE * b ) ;\n ASN1_TYPE * ASN1_TYPE_pack_sequence ( const ASN1_ITEM * it , void * s , ASN1_TYPE * * t ) ;\n void * ASN1_TYPE_unpack_sequence ( const ASN1_ITEM * it , const ASN1_TYPE * t ) ;\n ASN1_OBJECT * ASN1_OBJECT_new ( void ) ;\n void ASN1_OBJECT_free ( ASN1_OBJECT * a ) ;\n int i2d_ASN1_OBJECT ( const ASN1_OBJECT * a , unsigned char * * pp ) ;\n ASN1_OBJECT * d2i_ASN1_OBJECT ( ASN1_OBJECT * * a , const unsigned char * * pp , long length ) ;\n DECLARE_ASN1_ITEM ( ASN1_OBJECT ) DEFINE_STACK_OF ( ASN1_OBJECT ) ASN1_STRING * ASN1_STRING_new ( void ) ;\n void ASN1_STRING_free ( ASN1_STRING * a ) ;\n void ASN1_STRING_clear_free ( ASN1_STRING * a ) ;\n int ASN1_STRING_copy ( ASN1_STRING * dst , const ASN1_STRING * str ) ;\n ASN1_STRING * ASN1_STRING_dup ( const ASN1_STRING * a ) ;\n ASN1_STRING * ASN1_STRING_type_new ( int type ) ;\n int ASN1_STRING_cmp ( const ASN1_STRING * a , const ASN1_STRING * b ) ;\n int ASN1_STRING_set ( ASN1_STRING * str , const void * data , int len ) ;\n void ASN1_STRING_set0 ( ASN1_STRING * str , void * data , int len ) ;\n int ASN1_STRING_length ( const ASN1_STRING * x ) ;\n void ASN1_STRING_length_set ( ASN1_STRING * x , int n ) ;\n int ASN1_STRING_type ( const ASN1_STRING * x ) ;\n DEPRECATEDIN_1_1_0 ( unsigned char * ASN1_STRING_data ( ASN1_STRING * x ) ) const unsigned char * ASN1_STRING_get0_data ( const ASN1_STRING * x ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_BIT_STRING ) int ASN1_BIT_STRING_set ( ASN1_BIT_STRING * a , unsigned char * d , int length ) ;\n int ASN1_BIT_STRING_set_bit ( ASN1_BIT_STRING * a , int n , int value ) ;\n int ASN1_BIT_STRING_get_bit ( const ASN1_BIT_STRING * a , int n ) ;\n int ASN1_BIT_STRING_check ( const ASN1_BIT_STRING * a , const unsigned char * flags , int flags_len ) ;\n int ASN1_BIT_STRING_name_print ( BIO * out , ASN1_BIT_STRING * bs , BIT_STRING_BITNAME * tbl , int indent ) ;\n int ASN1_BIT_STRING_num_asc ( const char * name , BIT_STRING_BITNAME * tbl ) ;\n int ASN1_BIT_STRING_set_asc ( ASN1_BIT_STRING * bs , const char * name , int value , BIT_STRING_BITNAME * tbl ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_INTEGER ) ASN1_INTEGER * d2i_ASN1_UINTEGER ( ASN1_INTEGER * * a , const unsigned char * * pp , long length ) ;\n ASN1_INTEGER * ASN1_INTEGER_dup ( const ASN1_INTEGER * x ) ;\n int ASN1_INTEGER_cmp ( const ASN1_INTEGER * x , const ASN1_INTEGER * y ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_ENUMERATED ) int ASN1_UTCTIME_check ( const ASN1_UTCTIME * a ) ;\n ASN1_UTCTIME * ASN1_UTCTIME_set ( ASN1_UTCTIME * s , time_t t ) ;\n ASN1_UTCTIME * ASN1_UTCTIME_adj ( ASN1_UTCTIME * s , time_t t , int offset_day , long offset_sec ) ;\n int ASN1_UTCTIME_set_string ( ASN1_UTCTIME * s , const char * str ) ;\n int ASN1_UTCTIME_cmp_time_t ( const ASN1_UTCTIME * s , time_t t ) ;\n int ASN1_GENERALIZEDTIME_check ( const ASN1_GENERALIZEDTIME * a ) ;\n ASN1_GENERALIZEDTIME * ASN1_GENERALIZEDTIME_set ( ASN1_GENERALIZEDTIME * s , time_t t ) ;\n ASN1_GENERALIZEDTIME * ASN1_GENERALIZEDTIME_adj ( ASN1_GENERALIZEDTIME * s , time_t t , int offset_day , long offset_sec ) ;\n int ASN1_GENERALIZEDTIME_set_string ( ASN1_GENERALIZEDTIME * s , const char * str ) ;\n int ASN1_TIME_diff ( int * pday , int * psec , const ASN1_TIME * from , const ASN1_TIME * to ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_OCTET_STRING ) ASN1_OCTET_STRING * ASN1_OCTET_STRING_dup ( const ASN1_OCTET_STRING * a ) ;\n int ASN1_OCTET_STRING_cmp ( const ASN1_OCTET_STRING * a , const ASN1_OCTET_STRING * b ) ;\n int ASN1_OCTET_STRING_set ( ASN1_OCTET_STRING * str , const unsigned char * data , int len ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_VISIBLESTRING ) DECLARE_ASN1_FUNCTIONS ( ASN1_UNIVERSALSTRING ) DECLARE_ASN1_FUNCTIONS ( ASN1_UTF8STRING ) DECLARE_ASN1_FUNCTIONS ( ASN1_NULL ) DECLARE_ASN1_FUNCTIONS ( ASN1_BMPSTRING ) int UTF8_getc ( const unsigned char * str , int len , unsigned long * val ) ;\n int UTF8_putc ( unsigned char * str , int len , unsigned long value ) ;\n DECLARE_ASN1_FUNCTIONS_name ( ASN1_STRING , ASN1_PRINTABLE ) DECLARE_ASN1_FUNCTIONS_name ( ASN1_STRING , DIRECTORYSTRING ) DECLARE_ASN1_FUNCTIONS_name ( ASN1_STRING , DISPLAYTEXT ) DECLARE_ASN1_FUNCTIONS ( ASN1_PRINTABLESTRING ) DECLARE_ASN1_FUNCTIONS ( ASN1_T61STRING ) DECLARE_ASN1_FUNCTIONS ( ASN1_IA5STRING ) DECLARE_ASN1_FUNCTIONS ( ASN1_GENERALSTRING ) DECLARE_ASN1_FUNCTIONS ( ASN1_UTCTIME ) DECLARE_ASN1_FUNCTIONS ( ASN1_GENERALIZEDTIME )", "idx": 22000}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_INTEGER_1_72 ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_constrained_integer ( tvb , offset , actx , tree , hf_index , 1U , 72U , NULL , FALSE ) ;\n return offset ;\n }", "idx": 22001}
{"hash": 2895622461494525400, "project": "debian", "size": 3, "label": 0, "functionSource": "static void bug20023_change_user ( MYSQL * con ) {\n DIE_IF ( mysql_change_user ( con , opt_user , opt_password , opt_db ? opt_db : \"test\" ) ) ;\n }", "idx": 22002}
{"hash": -6552851419396579257, "project": "debian", "size": 6, "label": 0, "functionSource": "static void notify_job_time_cb ( packet_info * pinfo _U_ , proto_tree * tree _U_ , proto_item * item , dcerpc_info * di , tvbuff_t * tvb _U_ , int start_offset _U_ , int end_offset _U_ , void * callback_args _U_ ) {\n dcerpc_call_value * dcv = ( dcerpc_call_value * ) di -> call_data ;\n char * str = ( char * ) dcv -> private_data ;\n proto_item_append_text ( item , \": %s\" , str ) ;\n if ( item ) proto_item_append_text ( item -> parent , \": %s\" , str ) ;\n }", "idx": 22003}
{"hash": 8461266595329035000, "project": "chrome", "size": 31, "label": 0, "functionSource": "int event_base_once ( struct event_base * base , int fd , short events , void ( * callback ) ( int , short , void * ) , void * arg , const struct timeval * tv ) {\n struct event_once * eonce ;\n struct timeval etv ;\n int res ;\n if ( events & EV_SIGNAL ) return ( - 1 ) ;\n if ( ( eonce = calloc ( 1 , sizeof ( struct event_once ) ) ) == NULL ) return ( - 1 ) ;\n eonce -> cb = callback ;\n eonce -> arg = arg ;\n if ( events == EV_TIMEOUT ) {\n if ( tv == NULL ) {\n evutil_timerclear ( & etv ) ;\n tv = & etv ;\n }\n evtimer_set ( & eonce -> ev , event_once_cb , eonce ) ;\n }\n else if ( events & ( EV_READ | EV_WRITE ) ) {\n events &= EV_READ | EV_WRITE ;\n event_set ( & eonce -> ev , fd , events , event_once_cb , eonce ) ;\n }\n else {\n free ( eonce ) ;\n return ( - 1 ) ;\n }\n res = event_base_set ( base , & eonce -> ev ) ;\n if ( res == 0 ) res = event_add ( & eonce -> ev , tv ) ;\n if ( res != 0 ) {\n free ( eonce ) ;\n return ( res ) ;\n }\n return ( 0 ) ;\n }", "idx": 22004}
{"hash": -2807496476613334427, "project": "debian", "size": 16, "label": 0, "functionSource": "bool cephx_build_service_ticket_blob ( CephContext * cct , CephXSessionAuthInfo & info , CephXTicketBlob & blob ) {\n CephXServiceTicketInfo ticket_info ;\n ticket_info . session_key = info . session_key ;\n ticket_info . ticket = info . ticket ;\n ticket_info . ticket . caps = info . ticket . caps ;\n ldout ( cct , 10 ) << \"build_service_ticket service \" << ceph_entity_type_name ( info . service_id ) << \" secret_id \" << info . secret_id << \" ticket_info.ticket.name=\" << ticket_info . ticket . name . to_str ( ) << dendl ;\n blob . secret_id = info . secret_id ;\n std : : string error ;\n if ( ! info . service_secret . get_secret ( ) . length ( ) ) error = \"invalid key\" ;\n else encode_encrypt_enc_bl ( cct , ticket_info , info . service_secret , blob . blob , error ) ;\n if ( ! error . empty ( ) ) {\n ldout ( cct , - 1 ) << \"cephx_build_service_ticket_blob failed with error \" << error << dendl ;\n return false ;\n }\n return true ;\n }", "idx": 22005}
{"hash": -6552851419396579257, "project": "debian", "size": 48, "label": 0, "functionSource": "static int dissect_spoolss_printer_enum_values ( tvbuff_t * tvb , int offset , packet_info * pinfo , proto_tree * tree , dcerpc_info * di , guint8 * drep ) {\n guint32 start_offset = offset ;\n guint32 name_offset , name_len , val_offset , val_len , val_type ;\n char * name ;\n proto_item * item ;\n proto_tree * subtree ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , NULL , di , drep , hf_enumprinterdataex_name_offset , & name_offset ) ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , NULL , di , drep , hf_enumprinterdataex_name_len , & name_len ) ;\n dissect_spoolss_uint16uni ( tvb , start_offset + name_offset , pinfo , NULL , drep , & name , hf_enumprinterdataex_name ) ;\n subtree = proto_tree_add_subtree_format ( tree , tvb , offset , 0 , ett_printer_enumdataex_value , & item , \"Name: %s\" , name ) ;\n proto_tree_add_uint ( subtree , hf_enumprinterdataex_name_offset , tvb , offset - 8 , 4 , name_offset ) ;\n proto_tree_add_uint ( subtree , hf_enumprinterdataex_name_len , tvb , offset - 4 , 4 , name_len ) ;\n proto_tree_add_string ( subtree , hf_enumprinterdataex_name , tvb , start_offset + name_offset , ( ( int ) strlen ( name ) + 1 ) * 2 , name ) ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , subtree , di , drep , hf_printerdata_type , & val_type ) ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , subtree , di , drep , hf_enumprinterdataex_val_offset , & val_offset ) ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , subtree , di , drep , hf_enumprinterdataex_val_len , & val_len ) ;\n if ( val_len == 0 ) {\n proto_tree_add_uint_format_value ( subtree , hf_enumprinterdataex_value_null , tvb , start_offset + val_offset , 4 , 0 , \"(null)\" ) ;\n goto done ;\n }\n switch ( val_type ) {\n case DCERPC_REG_DWORD : {\n guint32 value ;\n guint16 low , high ;\n int offset2 = start_offset + val_offset ;\n offset2 = dissect_ndr_uint16 ( tvb , offset2 , pinfo , subtree , di , drep , hf_enumprinterdataex_val_dword_low , & low ) ;\n dissect_ndr_uint16 ( tvb , offset2 , pinfo , subtree , di , drep , hf_enumprinterdataex_val_dword_high , & high ) ;\n value = ( high << 16 ) | low ;\n proto_tree_add_uint ( subtree , hf_enumprinterdataex_value_uint , tvb , start_offset + val_offset , 4 , value ) ;\n proto_item_append_text ( item , \", Value: %d\" , value ) ;\n break ;\n }\n case DCERPC_REG_SZ : {\n char * value ;\n dissect_spoolss_uint16uni ( tvb , start_offset + val_offset , pinfo , subtree , drep , & value , hf_value_string ) ;\n proto_item_append_text ( item , \", Value: %s\" , value ) ;\n g_free ( value ) ;\n break ;\n }\n case DCERPC_REG_BINARY : proto_tree_add_bytes_format_value ( subtree , hf_enumprinterdataex_value_binary , tvb , start_offset + val_offset , val_len , NULL , \"<binary data>\" ) ;\n break ;\n case DCERPC_REG_MULTI_SZ : proto_tree_add_bytes_format_value ( subtree , hf_enumprinterdataex_value_multi_sz , tvb , start_offset + val_offset , val_len , NULL , \"<REG_MULTI_SZ not implemented>\" ) ;\n break ;\n default : proto_tree_add_expert_format ( subtree , pinfo , & ei_enumprinterdataex_value , tvb , start_offset + val_offset , val_len , \"%s: unknown type %d\" , name , val_type ) ;\n }\n done : g_free ( name ) ;\n return offset ;\n }", "idx": 22006}
{"hash": -7422764464424760982, "project": "chrome", "size": 20, "label": 0, "functionSource": "TEST_F ( ExtensionServiceSyncTest , DeferredSyncStartupOnInstall ) {\n InitializeEmptyExtensionService ( ) ;\n service ( ) -> Init ( ) ;\n ASSERT_TRUE ( service ( ) -> is_ready ( ) ) ;\n bool flare_was_called = false ;\n syncer : : ModelType triggered_type ( syncer : : UNSPECIFIED ) ;\n base : : WeakPtrFactory < ExtensionServiceSyncTest > factory ( this ) ;\n extension_sync_service ( ) -> SetSyncStartFlareForTesting ( base : : Bind ( & ExtensionServiceSyncTest : : MockSyncStartFlare , factory . GetWeakPtr ( ) , & flare_was_called , & triggered_type ) ) ;\n base : : FilePath path = data_dir ( ) . AppendASCII ( \"good.crx\" ) ;\n InstallCRX ( path , INSTALL_NEW ) ;\n EXPECT_TRUE ( flare_was_called ) ;\n EXPECT_EQ ( syncer : : EXTENSIONS , triggered_type ) ;\n flare_was_called = false ;\n triggered_type = syncer : : UNSPECIFIED ;\n extension_sync_service ( ) -> MergeDataAndStartSyncing ( syncer : : EXTENSIONS , syncer : : SyncDataList ( ) , base : : MakeUnique < syncer : : FakeSyncChangeProcessor > ( ) , base : : MakeUnique < syncer : : SyncErrorFactoryMock > ( ) ) ;\n path = data_dir ( ) . AppendASCII ( \"page_action.crx\" ) ;\n InstallCRX ( path , INSTALL_NEW ) ;\n EXPECT_FALSE ( flare_was_called ) ;\n ASSERT_EQ ( syncer : : UNSPECIFIED , triggered_type ) ;\n }", "idx": 22007}
{"hash": -1315695702746584250, "project": "debian", "size": 3, "label": 0, "functionSource": "int proto_get_id ( const protocol_t * protocol ) {\n return protocol -> proto_id ;\n }", "idx": 22008}
{"hash": -571446645408709055, "project": "debian", "size": 37, "label": 1, "functionSource": "int main ( int argc , char * * argv ) {\n gpg_error_t err ;\n if ( argc ) {\n argc -- ;\n argv ++ ;\n }\n if ( argc ) {\n unsigned char * buffer ;\n size_t n , buflen ;\n for ( ;\n argc ;\n argc -- , argv ++ ) {\n err = ksba_oid_from_str ( * argv , & buffer , & buflen ) ;\n if ( err ) {\n fprintf ( stderr , \"can't convert `%s': %s\\n\" , * argv , gpg_strerror ( err ) ) ;\n return 1 ;\n }\n printf ( \"%s ->\" , * argv ) ;\n for ( n = 0 ;\n n < buflen ;\n n ++ ) printf ( \" %02X\" , buffer [ n ] ) ;\n putchar ( '\\n' ) ;\n free ( buffer ) ;\n }\n }\n else {\n char * buffer ;\n size_t buflen ;\n char * result ;\n buffer = read_into_buffer ( stdin , & buflen ) ;\n result = ksba_oid_to_str ( buffer , buflen ) ;\n free ( buffer ) ;\n printf ( \"%s\\n\" , result ? result : \"[malloc failed]\" ) ;\n free ( result ) ;\n }\n return 0 ;\n }", "idx": 22009}
{"hash": -3292234626779322843, "project": "chrome", "size": 12, "label": 0, "functionSource": "TEST ( AutocompleteMatchTest , MergeClassifications ) {\n EXPECT_EQ ( std : : string ( ) , AutocompleteMatch : : ClassificationsToString ( AutocompleteMatch : : MergeClassifications ( AutocompleteMatch : : ACMatchClassifications ( ) , AutocompleteMatch : : ACMatchClassifications ( ) ) ) ) ;\n EXPECT_EQ ( \"0,0\" , AutocompleteMatch : : ClassificationsToString ( AutocompleteMatch : : MergeClassifications ( AutocompleteMatch : : ClassificationsFromString ( \"0,0\" ) , AutocompleteMatch : : ACMatchClassifications ( ) ) ) ) ;\n EXPECT_EQ ( \"0,0\" , AutocompleteMatch : : ClassificationsToString ( AutocompleteMatch : : MergeClassifications ( AutocompleteMatch : : ACMatchClassifications ( ) , AutocompleteMatch : : ClassificationsFromString ( \"0,0\" ) ) ) ) ;\n EXPECT_EQ ( \"0,1\" , AutocompleteMatch : : ClassificationsToString ( AutocompleteMatch : : MergeClassifications ( AutocompleteMatch : : ClassificationsFromString ( \"0,1\" ) , AutocompleteMatch : : ACMatchClassifications ( ) ) ) ) ;\n EXPECT_EQ ( \"0,1\" , AutocompleteMatch : : ClassificationsToString ( AutocompleteMatch : : MergeClassifications ( AutocompleteMatch : : ACMatchClassifications ( ) , AutocompleteMatch : : ClassificationsFromString ( \"0,1\" ) ) ) ) ;\n EXPECT_EQ ( \"0,1\" , AutocompleteMatch : : ClassificationsToString ( AutocompleteMatch : : MergeClassifications ( AutocompleteMatch : : ClassificationsFromString ( \"0,0\" ) , AutocompleteMatch : : ClassificationsFromString ( \"0,1\" ) ) ) ) ;\n EXPECT_EQ ( \"0,3,\" \"1,2\" , AutocompleteMatch : : ClassificationsToString ( AutocompleteMatch : : MergeClassifications ( AutocompleteMatch : : ClassificationsFromString ( \"0,1,\" \"1,0\" ) , AutocompleteMatch : : ClassificationsFromString ( \"0,2\" ) ) ) ) ;\n EXPECT_EQ ( \"0,3,\" \"1,2\" , AutocompleteMatch : : ClassificationsToString ( AutocompleteMatch : : MergeClassifications ( AutocompleteMatch : : ClassificationsFromString ( \"0,2\" ) , AutocompleteMatch : : ClassificationsFromString ( \"0,1,\" \"1,0\" ) ) ) ) ;\n EXPECT_EQ ( \"0,3\" , AutocompleteMatch : : ClassificationsToString ( AutocompleteMatch : : MergeClassifications ( AutocompleteMatch : : ClassificationsFromString ( \"0,1,\" \"1,2\" ) , AutocompleteMatch : : ClassificationsFromString ( \"0,2,\" \"1,1\" ) ) ) ) ;\n EXPECT_EQ ( \"0,2,\" \"1,0,\" \"2,1,\" \"4,3,\" \"5,7,\" \"6,3,\" \"7,7,\" \"15,1,\" \"17,0\" , AutocompleteMatch : : ClassificationsToString ( AutocompleteMatch : : MergeClassifications ( AutocompleteMatch : : ClassificationsFromString ( \"0,0,\" \"2,1,\" \"4,3,\" \"7,7,\" \"10,6,\" \"15,0\" ) , AutocompleteMatch : : ClassificationsFromString ( \"0,2,\" \"1,0,\" \"5,7,\" \"6,1,\" \"17,0\" ) ) ) ) ;\n }", "idx": 22010}
{"hash": -2607754285145856562, "project": "debian", "size": 193, "label": 0, "functionSource": "static int iso9660_options ( struct archive_write * a , const char * key , const char * value ) {\n struct iso9660 * iso9660 = a -> format_data ;\n const char * p ;\n int r ;\n switch ( key [ 0 ] ) {\n case 'a' : if ( strcmp ( key , \"abstract-file\" ) == 0 ) {\n r = get_str_opt ( a , & ( iso9660 -> abstract_file_identifier ) , ABSTRACT_FILE_SIZE , key , value ) ;\n iso9660 -> opt . abstract_file = r == ARCHIVE_OK ;\n return ( r ) ;\n }\n if ( strcmp ( key , \"application-id\" ) == 0 ) {\n r = get_str_opt ( a , & ( iso9660 -> application_identifier ) , APPLICATION_IDENTIFIER_SIZE , key , value ) ;\n iso9660 -> opt . application_id = r == ARCHIVE_OK ;\n return ( r ) ;\n }\n if ( strcmp ( key , \"allow-vernum\" ) == 0 ) {\n iso9660 -> opt . allow_vernum = value != NULL ;\n return ( ARCHIVE_OK ) ;\n }\n break ;\n case 'b' : if ( strcmp ( key , \"biblio-file\" ) == 0 ) {\n r = get_str_opt ( a , & ( iso9660 -> bibliographic_file_identifier ) , BIBLIO_FILE_SIZE , key , value ) ;\n iso9660 -> opt . biblio_file = r == ARCHIVE_OK ;\n return ( r ) ;\n }\n if ( strcmp ( key , \"boot\" ) == 0 ) {\n if ( value == NULL ) iso9660 -> opt . boot = 0 ;\n else {\n iso9660 -> opt . boot = 1 ;\n archive_strcpy ( & ( iso9660 -> el_torito . boot_filename ) , value ) ;\n }\n return ( ARCHIVE_OK ) ;\n }\n if ( strcmp ( key , \"boot-catalog\" ) == 0 ) {\n r = get_str_opt ( a , & ( iso9660 -> el_torito . catalog_filename ) , 1024 , key , value ) ;\n iso9660 -> opt . boot_catalog = r == ARCHIVE_OK ;\n return ( r ) ;\n }\n if ( strcmp ( key , \"boot-info-table\" ) == 0 ) {\n iso9660 -> opt . boot_info_table = value != NULL ;\n return ( ARCHIVE_OK ) ;\n }\n if ( strcmp ( key , \"boot-load-seg\" ) == 0 ) {\n uint32_t seg ;\n iso9660 -> opt . boot_load_seg = 0 ;\n if ( value == NULL ) goto invalid_value ;\n seg = 0 ;\n p = value ;\n if ( p [ 0 ] == '0' && ( p [ 1 ] == 'x' || p [ 1 ] == 'X' ) ) p += 2 ;\n while ( * p ) {\n if ( seg ) seg <<= 4 ;\n if ( * p >= 'A' && * p <= 'F' ) seg += * p - 'A' + 0x0a ;\n else if ( * p >= 'a' && * p <= 'f' ) seg += * p - 'a' + 0x0a ;\n else if ( * p >= '0' && * p <= '9' ) seg += * p - '0' ;\n else goto invalid_value ;\n if ( seg > 0xffff ) {\n archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , \"Invalid value(over 0xffff) for \" \"option ``%s''\" , key ) ;\n return ( ARCHIVE_FATAL ) ;\n }\n p ++ ;\n }\n iso9660 -> el_torito . boot_load_seg = ( uint16_t ) seg ;\n iso9660 -> opt . boot_load_seg = 1 ;\n return ( ARCHIVE_OK ) ;\n }\n if ( strcmp ( key , \"boot-load-size\" ) == 0 ) {\n int num = 0 ;\n r = get_num_opt ( a , & num , 0xffff , 1 , key , value ) ;\n iso9660 -> opt . boot_load_size = r == ARCHIVE_OK ;\n if ( r != ARCHIVE_OK ) return ( ARCHIVE_FATAL ) ;\n iso9660 -> el_torito . boot_load_size = ( uint16_t ) num ;\n return ( ARCHIVE_OK ) ;\n }\n if ( strcmp ( key , \"boot-type\" ) == 0 ) {\n if ( value == NULL ) goto invalid_value ;\n if ( strcmp ( value , \"no-emulation\" ) == 0 ) iso9660 -> opt . boot_type = OPT_BOOT_TYPE_NO_EMU ;\n else if ( strcmp ( value , \"fd\" ) == 0 ) iso9660 -> opt . boot_type = OPT_BOOT_TYPE_FD ;\n else if ( strcmp ( value , \"hard-disk\" ) == 0 ) iso9660 -> opt . boot_type = OPT_BOOT_TYPE_HARD_DISK ;\n else goto invalid_value ;\n return ( ARCHIVE_OK ) ;\n }\n break ;\n case 'c' : if ( strcmp ( key , \"compression-level\" ) == 0 ) {\n # ifdef HAVE_ZLIB_H if ( value == NULL || ! ( value [ 0 ] >= '0' && value [ 0 ] <= '9' ) || value [ 1 ] != '\\0' ) goto invalid_value ;\n iso9660 -> zisofs . compression_level = value [ 0 ] - '0' ;\n iso9660 -> opt . compression_level = 1 ;\n return ( ARCHIVE_OK ) ;\n # else archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , \"Option ``%s'' \" \"is not supported on this platform.\" , key ) ;\n return ( ARCHIVE_FATAL ) ;\n # endif }\n if ( strcmp ( key , \"copyright-file\" ) == 0 ) {\n r = get_str_opt ( a , & ( iso9660 -> copyright_file_identifier ) , COPYRIGHT_FILE_SIZE , key , value ) ;\n iso9660 -> opt . copyright_file = r == ARCHIVE_OK ;\n return ( r ) ;\n }\n # ifdef DEBUG if ( strcmp ( key , \"creation\" ) == 0 ) {\n struct tm tm ;\n char buf [ 5 ] ;\n p = value ;\n if ( p == NULL || strlen ( p ) < 14 ) goto invalid_value ;\n memset ( & tm , 0 , sizeof ( tm ) ) ;\n memcpy ( buf , p , 4 ) ;\n buf [ 4 ] = '\\0' ;\n p += 4 ;\n tm . tm_year = strtol ( buf , NULL , 10 ) - 1900 ;\n memcpy ( buf , p , 2 ) ;\n buf [ 2 ] = '\\0' ;\n p += 2 ;\n tm . tm_mon = strtol ( buf , NULL , 10 ) - 1 ;\n memcpy ( buf , p , 2 ) ;\n buf [ 2 ] = '\\0' ;\n p += 2 ;\n tm . tm_mday = strtol ( buf , NULL , 10 ) ;\n memcpy ( buf , p , 2 ) ;\n buf [ 2 ] = '\\0' ;\n p += 2 ;\n tm . tm_hour = strtol ( buf , NULL , 10 ) ;\n memcpy ( buf , p , 2 ) ;\n buf [ 2 ] = '\\0' ;\n p += 2 ;\n tm . tm_min = strtol ( buf , NULL , 10 ) ;\n memcpy ( buf , p , 2 ) ;\n buf [ 2 ] = '\\0' ;\n tm . tm_sec = strtol ( buf , NULL , 10 ) ;\n iso9660 -> birth_time = mktime ( & tm ) ;\n return ( ARCHIVE_OK ) ;\n }\n # endif break ;\n case 'i' : if ( strcmp ( key , \"iso-level\" ) == 0 ) {\n if ( value != NULL && value [ 1 ] == '\\0' && ( value [ 0 ] >= '1' && value [ 0 ] <= '4' ) ) {\n iso9660 -> opt . iso_level = value [ 0 ] - '0' ;\n return ( ARCHIVE_OK ) ;\n }\n goto invalid_value ;\n }\n break ;\n case 'j' : if ( strcmp ( key , \"joliet\" ) == 0 ) {\n if ( value == NULL ) iso9660 -> opt . joliet = OPT_JOLIET_DISABLE ;\n else if ( strcmp ( value , \"1\" ) == 0 ) iso9660 -> opt . joliet = OPT_JOLIET_ENABLE ;\n else if ( strcmp ( value , \"long\" ) == 0 ) iso9660 -> opt . joliet = OPT_JOLIET_LONGNAME ;\n else goto invalid_value ;\n return ( ARCHIVE_OK ) ;\n }\n break ;\n case 'l' : if ( strcmp ( key , \"limit-depth\" ) == 0 ) {\n iso9660 -> opt . limit_depth = value != NULL ;\n return ( ARCHIVE_OK ) ;\n }\n if ( strcmp ( key , \"limit-dirs\" ) == 0 ) {\n iso9660 -> opt . limit_dirs = value != NULL ;\n return ( ARCHIVE_OK ) ;\n }\n break ;\n case 'p' : if ( strcmp ( key , \"pad\" ) == 0 ) {\n iso9660 -> opt . pad = value != NULL ;\n return ( ARCHIVE_OK ) ;\n }\n if ( strcmp ( key , \"publisher\" ) == 0 ) {\n r = get_str_opt ( a , & ( iso9660 -> publisher_identifier ) , PUBLISHER_IDENTIFIER_SIZE , key , value ) ;\n iso9660 -> opt . publisher = r == ARCHIVE_OK ;\n return ( r ) ;\n }\n break ;\n case 'r' : if ( strcmp ( key , \"rockridge\" ) == 0 || strcmp ( key , \"Rockridge\" ) == 0 ) {\n if ( value == NULL ) iso9660 -> opt . rr = OPT_RR_DISABLED ;\n else if ( strcmp ( value , \"1\" ) == 0 ) iso9660 -> opt . rr = OPT_RR_USEFUL ;\n else if ( strcmp ( value , \"strict\" ) == 0 ) iso9660 -> opt . rr = OPT_RR_STRICT ;\n else if ( strcmp ( value , \"useful\" ) == 0 ) iso9660 -> opt . rr = OPT_RR_USEFUL ;\n else goto invalid_value ;\n return ( ARCHIVE_OK ) ;\n }\n break ;\n case 'v' : if ( strcmp ( key , \"volume-id\" ) == 0 ) {\n r = get_str_opt ( a , & ( iso9660 -> volume_identifier ) , VOLUME_IDENTIFIER_SIZE , key , value ) ;\n iso9660 -> opt . volume_id = r == ARCHIVE_OK ;\n return ( r ) ;\n }\n break ;\n case 'z' : if ( strcmp ( key , \"zisofs\" ) == 0 ) {\n if ( value == NULL ) iso9660 -> opt . zisofs = OPT_ZISOFS_DISABLED ;\n else {\n # ifdef HAVE_ZLIB_H iso9660 -> opt . zisofs = OPT_ZISOFS_DIRECT ;\n # else archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , \"``zisofs'' \" \"is not supported on this platform.\" ) ;\n return ( ARCHIVE_FATAL ) ;\n # endif }\n return ( ARCHIVE_OK ) ;\n }\n break ;\n }\n return ( ARCHIVE_WARN ) ;\n invalid_value : archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , \"Invalid value for option ``%s''\" , key ) ;\n return ( ARCHIVE_FAILED ) ;\n }", "idx": 22011}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_TransparencyParameters ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_TransparencyParameters , TransparencyParameters_sequence ) ;\n return offset ;\n }", "idx": 22012}
{"hash": 2546373479020365143, "project": "debian", "size": 5, "label": 0, "functionSource": "void mime_field_value_set_int64 ( HdrHeap * heap , MIMEHdrImpl * mh , MIMEField * field , int64_t value ) {\n char buf [ 20 ] ;\n int len = mime_format_int64 ( buf , value , sizeof ( buf ) ) ;\n mime_field_value_set ( heap , mh , field , buf , len , true ) ;\n }", "idx": 22013}
{"hash": -704025756752474526, "project": "debian", "size": 8, "label": 0, "functionSource": "void PNGAPI png_set_compression_buffer_size ( png_structp png_ptr , png_uint_32 size ) {\n if ( png_ptr == NULL ) return ;\n png_free ( png_ptr , png_ptr -> zbuf ) ;\n png_ptr -> zbuf_size = ( png_size_t ) size ;\n png_ptr -> zbuf = ( png_bytep ) png_malloc ( png_ptr , size ) ;\n png_ptr -> zstream . next_out = png_ptr -> zbuf ;\n png_ptr -> zstream . avail_out = ( uInt ) png_ptr -> zbuf_size ;\n }", "idx": 22014}
{"hash": 6393050609822897742, "project": "debian", "size": 54, "label": 0, "functionSource": "static void xhci_events_update ( XHCIState * xhci , int v ) {\n XHCIInterrupter * intr = & xhci -> intr [ v ] ;\n dma_addr_t erdp ;\n unsigned int dp_idx ;\n bool do_irq = 0 ;\n if ( xhci -> usbsts & USBSTS_HCH ) {\n return ;\n }\n erdp = xhci_addr64 ( intr -> erdp_low , intr -> erdp_high ) ;\n if ( erdp < intr -> er_start || erdp >= ( intr -> er_start + TRB_SIZE * intr -> er_size ) ) {\n DPRINTF ( \"xhci: ERDP out of bounds: \" DMA_ADDR_FMT \"\\n\" , erdp ) ;\n DPRINTF ( \"xhci: ER[%d] at \" DMA_ADDR_FMT \" len %d\\n\" , v , intr -> er_start , intr -> er_size ) ;\n xhci_die ( xhci ) ;\n return ;\n }\n dp_idx = ( erdp - intr -> er_start ) / TRB_SIZE ;\n assert ( dp_idx < intr -> er_size ) ;\n if ( intr -> er_full ) {\n int er_free = dp_idx - intr -> er_ep_idx ;\n if ( er_free <= 0 ) {\n er_free += intr -> er_size ;\n }\n if ( er_free < ( intr -> er_size / 2 ) ) {\n DPRINTF ( \"xhci_events_update(): event ring still \" \"more than half full (hack)\\n\" ) ;\n return ;\n }\n }\n while ( intr -> ev_buffer_put != intr -> ev_buffer_get ) {\n assert ( intr -> er_full ) ;\n if ( ( ( intr -> er_ep_idx + 1 ) % intr -> er_size ) == dp_idx ) {\n DPRINTF ( \"xhci_events_update(): event ring full again\\n\" ) ;\n # ifndef ER_FULL_HACK XHCIEvent full = {\n ER_HOST_CONTROLLER , CC_EVENT_RING_FULL_ERROR }\n ;\n xhci_write_event ( xhci , & full , v ) ;\n # endif do_irq = 1 ;\n break ;\n }\n XHCIEvent * event = & intr -> ev_buffer [ intr -> ev_buffer_get ] ;\n xhci_write_event ( xhci , event , v ) ;\n intr -> ev_buffer_get ++ ;\n do_irq = 1 ;\n if ( intr -> ev_buffer_get == EV_QUEUE ) {\n intr -> ev_buffer_get = 0 ;\n }\n }\n if ( do_irq ) {\n xhci_intr_raise ( xhci , v ) ;\n }\n if ( intr -> er_full && intr -> ev_buffer_put == intr -> ev_buffer_get ) {\n DPRINTF ( \"xhci_events_update(): event ring no longer full\\n\" ) ;\n intr -> er_full = 0 ;\n }\n }", "idx": 22015}
{"hash": 3576240888172463140, "project": "debian", "size": 7, "label": 0, "functionSource": "gpg_error_t keydb_search_fpr ( KEYDB_HANDLE hd , const byte * fpr ) {\n KEYDB_SEARCH_DESC desc ;\n memset ( & desc , 0 , sizeof desc ) ;\n desc . mode = KEYDB_SEARCH_MODE_FPR ;\n memcpy ( desc . u . fpr , fpr , MAX_FINGERPRINT_LEN ) ;\n return keydb_search ( hd , & desc , 1 , NULL ) ;\n }", "idx": 22016}
{"hash": -2338718868165006846, "project": "chrome", "size": 17, "label": 0, "functionSource": "void usage_exit ( ) {\n int i ;\n fprintf ( stderr , \"Usage: %s <options> filename\\n\\n\" \"Options:\\n\" , exec_name ) ;\n arg_show_usage ( stderr , all_args ) ;\n # if CONFIG_VP8_DECODER fprintf ( stderr , \"\\nVP8 Postprocessing Options:\\n\" ) ;\n arg_show_usage ( stderr , vp8_pp_args ) ;\n # endif fprintf ( stderr , \"\\nOutput File Patterns:\\n\\n\" \" The -o argument specifies the name of the file(s) to \" \"write to. If the\\n argument does not include any escape \" \"characters, the output will be\\n written to a single file. \" \"Otherwise, the filename will be calculated by\\n expanding \" \"the following escape characters:\\n\" ) ;\n fprintf ( stderr , \"\\n\\t%%w - Frame width\" \"\\n\\t%%h - Frame height\" \"\\n\\t%%<n> - Frame number, zero padded to <n> places (1..9)\" \"\\n\\n Pattern arguments are only supported in conjunction \" \"with the --yv12 and\\n --i420 options. If the -o option is \" \"not specified, the output will be\\n directed to stdout.\\n\" ) ;\n fprintf ( stderr , \"\\nIncluded decoders:\\n\\n\" ) ;\n for ( i = 0 ;\n i < get_vpx_decoder_count ( ) ;\n ++ i ) {\n const VpxInterface * const decoder = get_vpx_decoder_by_index ( i ) ;\n fprintf ( stderr , \" %-6s - %s\\n\" , decoder -> name , vpx_codec_iface_name ( decoder -> codec_interface ( ) ) ) ;\n }\n exit ( EXIT_FAILURE ) ;\n }", "idx": 22017}
{"hash": -3146697469509848825, "project": "debian", "size": 3, "label": 0, "functionSource": "static int dsa_priv_print ( BIO * bp , const EVP_PKEY * pkey , int indent , ASN1_PCTX * ctx ) {\n return do_dsa_print ( bp , pkey -> pkey . dsa , indent , 2 ) ;\n }", "idx": 22018}
{"hash": 1750726979859153417, "project": "debian", "size": 14, "label": 0, "functionSource": "static PyObject * authGSSClientResponse ( PyObject * self , PyObject * args ) {\n gss_client_state * state ;\n PyObject * pystate ;\n if ( ! PyArg_ParseTuple ( args , \"O\" , & pystate ) ) return NULL ;\n # if PY_MAJOR_VERSION >= 3 if ( ! PyCapsule_CheckExact ( pystate ) ) {\n # else if ( ! PyCObject_Check ( pystate ) ) {\n # endif PyErr_SetString ( PyExc_TypeError , \"Expected a context object\" ) ;\n return NULL ;\n }\n # if PY_MAJOR_VERSION >= 3 state = PyCapsule_GetPointer ( pystate , NULL ) ;\n # else state = ( gss_client_state * ) PyCObject_AsVoidPtr ( pystate ) ;\n # endif if ( state == NULL ) return NULL ;\n return Py_BuildValue ( \"s\" , state -> response ) ;\n }", "idx": 22019}
{"hash": 6755873269946787742, "project": "debian", "size": 14, "label": 0, "functionSource": "static void pk_transaction_get_categories ( PkTransaction * transaction , GVariant * params , GDBusMethodInvocation * context ) {\n g_autoptr ( GError ) error = NULL ;\n g_return_if_fail ( PK_IS_TRANSACTION ( transaction ) ) ;\n g_return_if_fail ( transaction -> priv -> tid != NULL ) ;\n g_debug ( \"GetCategories method called\" ) ;\n if ( ! pk_backend_is_implemented ( transaction -> priv -> backend , PK_ROLE_ENUM_GET_CATEGORIES ) ) {\n g_set_error ( & error , PK_TRANSACTION_ERROR , PK_TRANSACTION_ERROR_NOT_SUPPORTED , \"GetCategories not supported by backend\" ) ;\n pk_transaction_set_state ( transaction , PK_TRANSACTION_STATE_ERROR ) ;\n goto out ;\n }\n pk_transaction_set_role ( transaction , PK_ROLE_ENUM_GET_CATEGORIES ) ;\n pk_transaction_set_state ( transaction , PK_TRANSACTION_STATE_READY ) ;\n out : pk_transaction_dbus_return ( context , error ) ;\n }", "idx": 22020}
{"hash": 2578089348587614328, "project": "debian", "size": 3, "label": 0, "functionSource": "int i2d_PKCS7_bio ( BIO * bp , PKCS7 * p7 ) {\n return ASN1_item_i2d_bio ( ASN1_ITEM_rptr ( PKCS7 ) , bp , p7 ) ;\n }", "idx": 22021}
{"hash": 6393050609822897742, "project": "debian", "size": 5, "label": 0, "functionSource": "static void xhci_stop ( XHCIState * xhci ) {\n trace_usb_xhci_stop ( ) ;\n xhci -> usbsts |= USBSTS_HCH ;\n xhci -> crcr_low &= ~ CRCR_CRR ;\n }", "idx": 22022}
{"hash": -3889154245145551951, "project": "debian", "size": 2, "label": 0, "functionSource": "static void set_checkpoint_signal ( void ) {\n }", "idx": 22023}
{"hash": 6667142528452941476, "project": "debian", "size": 12, "label": 0, "functionSource": "static const char * fix_for_comment ( const char * ident ) {\n static char buf [ 1024 ] ;\n char c , * s = buf ;\n while ( ( c = * s ++ = * ident ++ ) ) {\n if ( s >= buf + sizeof ( buf ) - 10 ) {\n strmov ( s , \"...\" ) ;\n break ;\n }\n if ( c == '\\n' ) s = strmov ( s , \"-- \" ) ;\n }\n return buf ;\n }", "idx": 22024}
{"hash": -3975292313894439939, "project": "debian", "size": 18, "label": 0, "functionSource": "int main ( void ) {\n static void ( * test_functions [ ] ) ( void ) = {\n test_master_service_settings_cache , NULL }\n ;\n pool_t pool ;\n int ret ;\n i_zero ( & input ) ;\n input . module = \"module\" ;\n input . service = \"service_name\" ;\n set . config_cache_size = 1024 * 4 ;\n pool = pool_alloconly_create ( \"set pool\" , 1024 ) ;\n test_master_service . set_parser = settings_parser_init ( pool , & test_setting_parser_info , 0 ) ;\n master_service = & test_master_service ;\n ret = test_run ( test_functions ) ;\n settings_parser_deinit ( & test_master_service . set_parser ) ;\n pool_unref ( & pool ) ;\n return ret ;\n }", "idx": 22025}
{"hash": -1768728156572022708, "project": "debian", "size": 3, "label": 0, "functionSource": "static void jbig2_default_free ( Jbig2Allocator * allocator , void * p ) {\n free ( p ) ;\n }", "idx": 22026}
{"hash": -5927738579069082820, "project": "debian", "size": 27, "label": 0, "functionSource": "static void xps_parse_poly_bezier_segment ( fz_context * doc , fz_path * path , fz_xml * root , int stroking , int * skipped_stroke ) {\n char * points_att = fz_xml_att ( root , \"Points\" ) ;\n char * is_stroked_att = fz_xml_att ( root , \"IsStroked\" ) ;\n float x [ 3 ] , y [ 3 ] ;\n int is_stroked ;\n char * s ;\n int n ;\n if ( ! points_att ) {\n fz_warn ( doc , \"PolyBezierSegment element has no points\" ) ;\n return ;\n }\n is_stroked = 1 ;\n if ( is_stroked_att && ! strcmp ( is_stroked_att , \"false\" ) ) is_stroked = 0 ;\n if ( ! is_stroked ) * skipped_stroke = 1 ;\n s = points_att ;\n n = 0 ;\n while ( * s != 0 ) {\n while ( * s == ' ' ) s ++ ;\n s = xps_parse_point ( s , & x [ n ] , & y [ n ] ) ;\n n ++ ;\n if ( n == 3 ) {\n if ( stroking && ! is_stroked ) fz_moveto ( doc , path , x [ 2 ] , y [ 2 ] ) ;\n else fz_curveto ( doc , path , x [ 0 ] , y [ 0 ] , x [ 1 ] , y [ 1 ] , x [ 2 ] , y [ 2 ] ) ;\n n = 0 ;\n }\n }\n }", "idx": 22027}
{"hash": 1742637512846796448, "project": "debian", "size": 69, "label": 1, "functionSource": "static int dissect_mac_fdd_rach ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , void * data ) {\n guint8 tctf ;\n guint8 chan ;\n guint16 bitoffs = 0 ;\n tvbuff_t * next_tvb ;\n proto_tree * rach_tree = NULL ;\n proto_item * channel_type ;\n umts_mac_info * macinf ;\n fp_info * fpinf ;\n rlc_info * rlcinf ;\n proto_item * ti = NULL ;\n guint8 c_t ;\n tctf = tvb_get_bits8 ( tvb , 0 , 2 ) ;\n bitoffs += 2 ;\n col_set_str ( pinfo -> cinfo , COL_PROTOCOL , \"MAC\" ) ;\n col_set_str ( pinfo -> cinfo , COL_INFO , val_to_str_const ( tctf , rach_fdd_tctf_vals , \"Unknown TCTF\" ) ) ;\n ti = proto_tree_add_item ( tree , proto_umts_mac , tvb , 0 , - 1 , ENC_NA ) ;\n rach_tree = proto_item_add_subtree ( ti , ett_mac_rach ) ;\n macinf = ( umts_mac_info * ) p_get_proto_data ( wmem_file_scope ( ) , pinfo , proto_umts_mac , 0 ) ;\n fpinf = ( fp_info * ) p_get_proto_data ( wmem_file_scope ( ) , pinfo , proto_fp , 0 ) ;\n rlcinf = ( rlc_info * ) p_get_proto_data ( wmem_file_scope ( ) , pinfo , proto_rlc , 0 ) ;\n if ( ! macinf || ! fpinf ) {\n proto_tree_add_expert ( rach_tree , pinfo , & ei_mac_per_frame_info_missing , tvb , 0 , - 1 ) ;\n return 1 ;\n }\n proto_tree_add_bits_item ( rach_tree , hf_mac_rach_fdd_tctf , tvb , 0 , 2 , ENC_BIG_ENDIAN ) ;\n if ( tctf == TCTF_DCCH_DTCH_RACH_FDD ) {\n macinf -> ctmux [ fpinf -> cur_tb ] = 1 ;\n bitoffs = tree_add_common_dcch_dtch_fields ( tvb , pinfo , rach_tree , bitoffs , fpinf , macinf , rlcinf ) ;\n }\n chan = fpinf -> cur_chan ;\n switch ( tctf ) {\n case TCTF_CCCH_RACH_FDD : proto_item_append_text ( ti , \" (CCCH)\" ) ;\n channel_type = proto_tree_add_uint ( rach_tree , hf_mac_channel , tvb , 0 , 0 , MAC_CCCH ) ;\n PROTO_ITEM_SET_GENERATED ( channel_type ) ;\n next_tvb = tvb_new_octet_aligned ( tvb , bitoffs , fpinf -> chan_tf_size [ chan ] - bitoffs ) ;\n add_new_data_source ( pinfo , next_tvb , \"Octet-Aligned CCCH Data\" ) ;\n call_dissector_with_data ( rlc_ccch_handle , next_tvb , pinfo , tree , data ) ;\n break ;\n case TCTF_DCCH_DTCH_RACH_FDD : c_t = tvb_get_bits8 ( tvb , bitoffs - 4 , 4 ) ;\n rlcinf -> mode [ chan ] = lchId_rlc_map [ c_t + 1 ] ;\n macinf -> content [ chan ] = lchId_type_table [ c_t + 1 ] ;\n rlcinf -> rbid [ chan ] = c_t + 1 ;\n switch ( macinf -> content [ chan ] ) {\n case MAC_CONTENT_DCCH : proto_item_append_text ( ti , \" (DCCH)\" ) ;\n channel_type = proto_tree_add_uint ( rach_tree , hf_mac_channel , tvb , 0 , 0 , MAC_DCCH ) ;\n PROTO_ITEM_SET_GENERATED ( channel_type ) ;\n next_tvb = tvb_new_octet_aligned ( tvb , bitoffs , fpinf -> chan_tf_size [ chan ] - bitoffs ) ;\n add_new_data_source ( pinfo , next_tvb , \"Octet-Aligned DCCH Data\" ) ;\n call_dissector_with_data ( rlc_dcch_handle , next_tvb , pinfo , tree , data ) ;\n break ;\n case MAC_CONTENT_PS_DTCH : proto_item_append_text ( ti , \" (PS DTCH)\" ) ;\n channel_type = proto_tree_add_uint ( rach_tree , hf_mac_channel , tvb , 0 , 0 , MAC_DTCH ) ;\n PROTO_ITEM_SET_GENERATED ( channel_type ) ;\n next_tvb = tvb_new_octet_aligned ( tvb , bitoffs , fpinf -> chan_tf_size [ chan ] - bitoffs ) ;\n add_new_data_source ( pinfo , next_tvb , \"Octet-Aligned DTCH Data\" ) ;\n call_dissector_with_data ( rlc_ps_dtch_handle , next_tvb , pinfo , tree , data ) ;\n break ;\n case MAC_CONTENT_CS_DTCH : proto_item_append_text ( ti , \" (CS DTCH)\" ) ;\n break ;\n default : proto_item_append_text ( ti , \" (Unknown RACH DCCH/DTCH Content)\" ) ;\n expert_add_info_format ( pinfo , NULL , & ei_mac_unknown_content , \"Unknown RACH DCCH/DTCH Content\" ) ;\n }\n break ;\n default : proto_item_append_text ( ti , \" (Unknown RACH TCTF)\" ) ;\n expert_add_info_format ( pinfo , NULL , & ei_mac_rach_tctf_unknown , \"Unknown RACH TCTF\" ) ;\n }\n return tvb_captured_length ( tvb ) ;\n }", "idx": 22028}
{"hash": 455172021572601154, "project": "debian", "size": 8, "label": 0, "functionSource": "size_t strlen_utf8 ( const char * s ) {\n u_char c ;\n size_t len = 0 ;\n while ( ( c = * s ++ ) ) {\n if ( ( c & 0xC0 ) != 0x80 ) ++ len ;\n }\n return len ;\n }", "idx": 22029}
{"hash": 6250095321513210169, "project": "debian", "size": 7, "label": 0, "functionSource": "rfbClientIteratorPtr rfbGetClientIteratorWithClosed ( rfbScreenInfoPtr rfbScreen ) {\n rfbClientIteratorPtr i = ( rfbClientIteratorPtr ) malloc ( sizeof ( struct rfbClientIterator ) ) ;\n i -> next = NULL ;\n i -> screen = rfbScreen ;\n i -> closedToo = TRUE ;\n return i ;\n }", "idx": 22030}
{"hash": 2713698759296604855, "project": "debian", "size": 24, "label": 0, "functionSource": "int ff_MPV_lowest_referenced_row ( MpegEncContext * s , int dir ) {\n int my_max = INT_MIN , my_min = INT_MAX , qpel_shift = ! s -> quarter_sample ;\n int my , off , i , mvs ;\n if ( s -> picture_structure != PICT_FRAME || s -> mcsel ) goto unhandled ;\n switch ( s -> mv_type ) {\n case MV_TYPE_16X16 : mvs = 1 ;\n break ;\n case MV_TYPE_16X8 : mvs = 2 ;\n break ;\n case MV_TYPE_8X8 : mvs = 4 ;\n break ;\n default : goto unhandled ;\n }\n for ( i = 0 ;\n i < mvs ;\n i ++ ) {\n my = s -> mv [ dir ] [ i ] [ 1 ] << qpel_shift ;\n my_max = FFMAX ( my_max , my ) ;\n my_min = FFMIN ( my_min , my ) ;\n }\n off = ( FFMAX ( - my_min , my_max ) + 63 ) >> 6 ;\n return FFMIN ( FFMAX ( s -> mb_y + off , 0 ) , s -> mb_height - 1 ) ;\n unhandled : return s -> mb_height - 1 ;\n }", "idx": 22031}
{"hash": 3584320764213684062, "project": "debian", "size": 3, "label": 0, "functionSource": "static int vvalue_tvb_get0 ( tvbuff_t * tvb _U_ , int offset _U_ , void * val _U_ ) {\n return 0 ;\n }", "idx": 22032}
{"hash": 1223258652239369123, "project": "debian", "size": 44, "label": 1, "functionSource": "static zend_object_value spl_filesystem_object_clone ( zval * zobject TSRMLS_DC ) {\n zend_object_value new_obj_val ;\n zend_object * old_object ;\n zend_object * new_object ;\n zend_object_handle handle = Z_OBJ_HANDLE_P ( zobject ) ;\n spl_filesystem_object * intern ;\n spl_filesystem_object * source ;\n int index , skip_dots ;\n old_object = zend_objects_get_address ( zobject TSRMLS_CC ) ;\n source = ( spl_filesystem_object * ) old_object ;\n new_obj_val = spl_filesystem_object_new_ex ( old_object -> ce , & intern TSRMLS_CC ) ;\n new_object = & intern -> std ;\n intern -> flags = source -> flags ;\n switch ( source -> type ) {\n case SPL_FS_INFO : intern -> _path_len = source -> _path_len ;\n intern -> _path = estrndup ( source -> _path , source -> _path_len ) ;\n intern -> file_name_len = source -> file_name_len ;\n intern -> file_name = estrndup ( source -> file_name , intern -> file_name_len ) ;\n break ;\n case SPL_FS_DIR : spl_filesystem_dir_open ( intern , source -> _path TSRMLS_CC ) ;\n skip_dots = SPL_HAS_FLAG ( source -> flags , SPL_FILE_DIR_SKIPDOTS ) ;\n for ( index = 0 ;\n index < source -> u . dir . index ;\n ++ index ) {\n do {\n spl_filesystem_dir_read ( intern TSRMLS_CC ) ;\n }\n while ( skip_dots && spl_filesystem_is_dot ( intern -> u . dir . entry . d_name ) ) ;\n }\n intern -> u . dir . index = index ;\n break ;\n case SPL_FS_FILE : php_error_docref ( NULL TSRMLS_CC , E_ERROR , \"An object of class %s cannot be cloned\" , old_object -> ce -> name ) ;\n break ;\n }\n intern -> file_class = source -> file_class ;\n intern -> info_class = source -> info_class ;\n intern -> oth = source -> oth ;\n intern -> oth_handler = source -> oth_handler ;\n zend_objects_clone_members ( new_object , new_obj_val , old_object , handle TSRMLS_CC ) ;\n if ( intern -> oth_handler && intern -> oth_handler -> clone ) {\n intern -> oth_handler -> clone ( source , intern TSRMLS_CC ) ;\n }\n return new_obj_val ;\n }", "idx": 22033}
{"hash": -187662502455871220, "project": "debian", "size": 28, "label": 0, "functionSource": "static int dissect_usb_vid_control ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , void * data ) {\n gboolean is_request = ( pinfo -> srcport == NO_ENDPOINT ) ;\n usb_conv_info_t * usb_conv_info ;\n usb_trans_info_t * usb_trans_info ;\n int offset = 0 ;\n usb_setup_dissector dissector = NULL ;\n const usb_setup_dissector_table_t * tmp ;\n if ( data == NULL || ( ( usb_conv_info_t * ) data ) -> usb_trans_info == NULL ) return 0 ;\n usb_conv_info = ( usb_conv_info_t * ) data ;\n usb_trans_info = usb_conv_info -> usb_trans_info ;\n for ( tmp = setup_dissectors ;\n tmp -> dissector ;\n tmp ++ ) {\n if ( tmp -> request == usb_trans_info -> setup . request ) {\n dissector = tmp -> dissector ;\n break ;\n }\n }\n if ( ! dissector ) return 0 ;\n col_set_str ( pinfo -> cinfo , COL_PROTOCOL , \"USBVIDEO\" ) ;\n col_add_fstr ( pinfo -> cinfo , COL_INFO , \"%s %s\" , val_to_str ( usb_trans_info -> setup . request , setup_request_names_vals , \"Unknown type %x\" ) , is_request ? \"Request \" : \"Response\" ) ;\n if ( is_request ) {\n proto_tree_add_item ( tree , hf_usb_vid_request , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ;\n offset += 1 ;\n }\n offset = dissector ( pinfo , tree , tvb , offset , is_request , usb_trans_info , usb_conv_info ) ;\n return offset ;\n }", "idx": 22034}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_SET_SIZE_1_15_OF_MultiplexEntryDescriptor ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_constrained_set_of ( tvb , offset , actx , tree , hf_index , ett_h245_SET_SIZE_1_15_OF_MultiplexEntryDescriptor , SET_SIZE_1_15_OF_MultiplexEntryDescriptor_set_of , 1 , 15 , FALSE ) ;\n return offset ;\n }", "idx": 22035}
{"hash": 1504508151056681409, "project": "debian", "size": 41, "label": 0, "functionSource": "static int record_hardlink ( struct archive_read * a , struct cpio * cpio , struct archive_entry * entry ) {\n struct links_entry * le ;\n dev_t dev ;\n int64_t ino ;\n if ( archive_entry_nlink ( entry ) <= 1 ) return ( ARCHIVE_OK ) ;\n dev = archive_entry_dev ( entry ) ;\n ino = archive_entry_ino64 ( entry ) ;\n for ( le = cpio -> links_head ;\n le ;\n le = le -> next ) {\n if ( le -> dev == dev && le -> ino == ino ) {\n archive_entry_copy_hardlink ( entry , le -> name ) ;\n if ( -- le -> links <= 0 ) {\n if ( le -> previous != NULL ) le -> previous -> next = le -> next ;\n if ( le -> next != NULL ) le -> next -> previous = le -> previous ;\n if ( cpio -> links_head == le ) cpio -> links_head = le -> next ;\n free ( le -> name ) ;\n free ( le ) ;\n }\n return ( ARCHIVE_OK ) ;\n }\n }\n le = ( struct links_entry * ) malloc ( sizeof ( struct links_entry ) ) ;\n if ( le == NULL ) {\n archive_set_error ( & a -> archive , ENOMEM , \"Out of memory adding file to list\" ) ;\n return ( ARCHIVE_FATAL ) ;\n }\n if ( cpio -> links_head != NULL ) cpio -> links_head -> previous = le ;\n le -> next = cpio -> links_head ;\n le -> previous = NULL ;\n cpio -> links_head = le ;\n le -> dev = dev ;\n le -> ino = ino ;\n le -> links = archive_entry_nlink ( entry ) - 1 ;\n le -> name = strdup ( archive_entry_pathname ( entry ) ) ;\n if ( le -> name == NULL ) {\n archive_set_error ( & a -> archive , ENOMEM , \"Out of memory adding file to list\" ) ;\n return ( ARCHIVE_FATAL ) ;\n }\n return ( ARCHIVE_OK ) ;\n }", "idx": 22036}
{"hash": 2419147764757351618, "project": "debian", "size": 10, "label": 0, "functionSource": "void s390_virtio_device_update_status ( VirtIOS390Device * dev ) {\n VirtIODevice * vdev = dev -> vdev ;\n uint32_t features ;\n vdev -> status = ldub_phys ( dev -> dev_offs + VIRTIO_DEV_OFFS_STATUS ) ;\n features = ldl_phys ( dev -> feat_offs ) ;\n if ( vdev -> set_features ) {\n vdev -> set_features ( vdev , features ) ;\n }\n vdev -> guest_features = features ;\n }", "idx": 22037}
{"hash": -5706788925640467782, "project": "chrome", "size": 14, "label": 0, "functionSource": "static void reset_skip_tx_size ( VP9_COMMON * cm , TX_SIZE max_tx_size ) {\n int mi_row , mi_col ;\n const int mis = cm -> mi_stride ;\n MODE_INFO * mi_ptr = cm -> mi ;\n for ( mi_row = 0 ;\n mi_row < cm -> mi_rows ;\n ++ mi_row , mi_ptr += mis ) {\n for ( mi_col = 0 ;\n mi_col < cm -> mi_cols ;\n ++ mi_col ) {\n if ( mi_ptr [ mi_col ] . src_mi -> mbmi . tx_size > max_tx_size ) mi_ptr [ mi_col ] . src_mi -> mbmi . tx_size = max_tx_size ;\n }\n }\n }", "idx": 22038}
{"hash": -5268859819325807498, "project": "debian", "size": 46, "label": 0, "functionSource": "static gboolean request_is_satisfied ( NautilusDirectory * directory , NautilusFile * file , Request request ) {\n if ( REQUEST_WANTS_TYPE ( request , REQUEST_FILE_LIST ) && ! ( directory -> details -> directory_loaded && directory -> details -> directory_loaded_sent_notification ) ) {\n return FALSE ;\n }\n if ( REQUEST_WANTS_TYPE ( request , REQUEST_DIRECTORY_COUNT ) ) {\n if ( has_problem ( directory , file , lacks_directory_count ) ) {\n return FALSE ;\n }\n }\n if ( REQUEST_WANTS_TYPE ( request , REQUEST_FILE_INFO ) ) {\n if ( has_problem ( directory , file , lacks_info ) ) {\n return FALSE ;\n }\n }\n if ( REQUEST_WANTS_TYPE ( request , REQUEST_FILESYSTEM_INFO ) ) {\n if ( has_problem ( directory , file , lacks_filesystem_info ) ) {\n return FALSE ;\n }\n }\n if ( REQUEST_WANTS_TYPE ( request , REQUEST_DEEP_COUNT ) ) {\n if ( has_problem ( directory , file , lacks_deep_count ) ) {\n return FALSE ;\n }\n }\n if ( REQUEST_WANTS_TYPE ( request , REQUEST_THUMBNAIL ) ) {\n if ( has_problem ( directory , file , lacks_thumbnail ) ) {\n return FALSE ;\n }\n }\n if ( REQUEST_WANTS_TYPE ( request , REQUEST_MOUNT ) ) {\n if ( has_problem ( directory , file , lacks_mount ) ) {\n return FALSE ;\n }\n }\n if ( REQUEST_WANTS_TYPE ( request , REQUEST_MIME_LIST ) ) {\n if ( has_problem ( directory , file , lacks_mime_list ) ) {\n return FALSE ;\n }\n }\n if ( REQUEST_WANTS_TYPE ( request , REQUEST_LINK_INFO ) ) {\n if ( has_problem ( directory , file , lacks_link_info ) ) {\n return FALSE ;\n }\n }\n return TRUE ;\n }", "idx": 22039}
{"hash": -2181129709629421970, "project": "chrome", "size": 18, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( DownloadNotificationTest , DISABLED_DiscardDangerousFile ) {\n GURL download_url ( embedded_test_server ( ) -> GetURL ( \"/downloads/dangerous/dangerous.swf\" ) ) ;\n content : : DownloadTestObserverTerminal download_terminal_observer ( GetDownloadManager ( browser ( ) ) , 1u , content : : DownloadTestObserver : : ON_DANGEROUS_DOWNLOAD_IGNORE ) ;\n CreateDownloadForBrowserAndURL ( browser ( ) , download_url ) ;\n base : : FilePath filename = download_item ( ) -> GetFileNameToReportUser ( ) ;\n EXPECT_EQ ( download : : DOWNLOAD_DANGER_TYPE_DANGEROUS_FILE , download_item ( ) -> GetDangerType ( ) ) ;\n EXPECT_TRUE ( download_item ( ) -> IsDangerous ( ) ) ;\n EXPECT_TRUE ( notification ( ) ) ;\n display_service_ -> SimulateClick ( NotificationHandler : : Type : : TRANSIENT , notification_id ( ) , 0 , base : : nullopt ) ;\n EXPECT_FALSE ( notification ( ) ) ;\n download_terminal_observer . WaitForFinished ( ) ;\n EXPECT_FALSE ( notification ( ) ) ;\n EXPECT_EQ ( 0u , GetDownloadNotifications ( ) . size ( ) ) ;\n std : : vector < download : : DownloadItem * > downloads ;\n GetDownloadManager ( browser ( ) ) -> GetAllDownloads ( & downloads ) ;\n EXPECT_EQ ( 0u , downloads . size ( ) ) ;\n EXPECT_FALSE ( base : : PathExists ( GetDownloadPath ( ) . Append ( filename . BaseName ( ) ) ) ) ;\n }", "idx": 22040}
{"hash": -7248963932691286231, "project": "debian", "size": 71, "label": 0, "functionSource": "static struct server * get_server ( char * buf , int len ) {\n char * data = get_data ( buf , len ) ;\n char error_buf [ 512 ] ;\n if ( data == NULL ) {\n LOGE ( \"No data found\" ) ;\n return NULL ;\n }\n json_settings settings = {\n 0 }\n ;\n json_value * obj = json_parse_ex ( & settings , data , strlen ( data ) , error_buf ) ;\n if ( obj == NULL ) {\n LOGE ( \"%s\" , error_buf ) ;\n return NULL ;\n }\n struct server * server = ss_malloc ( sizeof ( struct server ) ) ;\n memset ( server , 0 , sizeof ( struct server ) ) ;\n if ( obj -> type == json_object ) {\n int i = 0 ;\n for ( i = 0 ;\n i < obj -> u . object . length ;\n i ++ ) {\n char * name = obj -> u . object . values [ i ] . name ;\n json_value * value = obj -> u . object . values [ i ] . value ;\n if ( strcmp ( name , \"server_port\" ) == 0 ) {\n if ( value -> type == json_string ) {\n strncpy ( server -> port , value -> u . string . ptr , 8 ) ;\n }\n else if ( value -> type == json_integer ) {\n snprintf ( server -> port , 8 , \"%\" PRIu64 \"\" , value -> u . integer ) ;\n }\n }\n else if ( strcmp ( name , \"password\" ) == 0 ) {\n if ( value -> type == json_string ) {\n strncpy ( server -> password , value -> u . string . ptr , 128 ) ;\n }\n }\n else if ( strcmp ( name , \"method\" ) == 0 ) {\n if ( value -> type == json_string ) {\n server -> method = strdup ( value -> u . string . ptr ) ;\n }\n }\n else if ( strcmp ( name , \"fast_open\" ) == 0 ) {\n if ( value -> type == json_boolean ) {\n strncpy ( server -> fast_open , ( value -> u . boolean ? \"true\" : \"false\" ) , 8 ) ;\n }\n }\n else if ( strcmp ( name , \"plugin\" ) == 0 ) {\n if ( value -> type == json_string ) {\n server -> plugin = strdup ( value -> u . string . ptr ) ;\n }\n }\n else if ( strcmp ( name , \"plugin_opts\" ) == 0 ) {\n if ( value -> type == json_string ) {\n server -> plugin_opts = strdup ( value -> u . string . ptr ) ;\n }\n }\n else if ( strcmp ( name , \"mode\" ) == 0 ) {\n if ( value -> type == json_string ) {\n server -> mode = strdup ( value -> u . string . ptr ) ;\n }\n }\n else {\n LOGE ( \"invalid data: %s\" , data ) ;\n break ;\n }\n }\n }\n json_value_free ( obj ) ;\n return server ;\n }", "idx": 22041}
{"hash": -8365810778652022218, "project": "debian", "size": 3, "label": 0, "functionSource": "static bool virtio_net_started ( VirtIONet * n , uint8_t status ) {\n return ( status & VIRTIO_CONFIG_S_DRIVER_OK ) && ( n -> status & VIRTIO_NET_S_LINK_UP ) && n -> vdev . vm_running ;\n }", "idx": 22042}
{"hash": 6627875687115906550, "project": "chrome", "size": 15, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( WebRtcApprtcBrowserTest , MAYBE_MANUAL_FirefoxApprtcInteropTest ) {\n DetectErrorsInJavaScript ( ) ;\n ASSERT_TRUE ( LaunchApprtcInstanceOnLocalhost ( \"9999\" ) ) ;\n ASSERT_TRUE ( LaunchColliderOnLocalHost ( \"http://localhost:9999\" , \"8089\" ) ) ;\n while ( ! LocalApprtcInstanceIsUp ( ) ) DVLOG ( 1 ) << \"Waiting for AppRTC to come up...\" ;\n GURL room_url = GURL ( \"http://localhost:9999/r/some_room\" \"?wshpp=localhost:8089&wstls=false\" \"&firefox_fake_device=1\" ) ;\n chrome : : AddTabAt ( browser ( ) , GURL ( ) , - 1 , true ) ;\n content : : WebContents * chrome_tab = browser ( ) -> tab_strip_model ( ) -> GetActiveWebContents ( ) ;\n PermissionRequestManager : : FromWebContents ( chrome_tab ) -> set_auto_response_for_test ( PermissionRequestManager : : ACCEPT_ALL ) ;\n InfoBarResponder infobar_responder ( InfoBarService : : FromWebContents ( chrome_tab ) , InfoBarResponder : : ACCEPT ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , room_url ) ;\n ASSERT_TRUE ( LaunchFirefoxWithUrl ( room_url ) ) ;\n ASSERT_TRUE ( WaitForCallToComeUp ( chrome_tab ) ) ;\n ASSERT_TRUE ( DetectRemoteVideoPlaying ( chrome_tab ) ) ;\n }", "idx": 22043}
{"hash": 6827449473891484617, "project": "chrome", "size": 3, "label": 1, "functionSource": "int16_t vp9_dc_quant ( int qindex , int delta ) {\n return dc_qlookup [ clamp ( qindex + delta , 0 , MAXQ ) ] ;\n }", "idx": 22044}
{"hash": 3584320764213684062, "project": "debian", "size": 29, "label": 0, "functionSource": "static int dissect_CPMFindIndices ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * parent_tree , gboolean in , void * data _U_ ) {\n gint offset = 16 ;\n proto_item * item ;\n proto_tree * tree ;\n col_append_str ( pinfo -> cinfo , COL_INFO , \"FindIndices\" ) ;\n item = proto_tree_add_item ( parent_tree , hf_mswsp_msg , tvb , offset , - 1 , ENC_NA ) ;\n tree = proto_item_add_subtree ( item , ett_mswsp_msg ) ;\n proto_item_set_text ( item , \"FindIndices%s\" , in ? \"In\" : \"Out\" ) ;\n if ( in ) {\n guint32 cWids ;\n guint32 cDepthPrev ;\n cWids = tvb_get_letohl ( tvb , offset ) ;\n proto_tree_add_uint ( tree , hf_mswsp_msg_cpmfindindices_cwids , tvb , offset , 4 , cWids ) ;\n offset += 4 ;\n cDepthPrev = tvb_get_letohl ( tvb , offset ) ;\n proto_tree_add_uint ( tree , hf_mswsp_msg_cpmfindindices_cdepthprev , tvb , offset , 4 , cDepthPrev ) ;\n offset += 4 ;\n offset = parse_uin32_array ( tvb , offset , tree , cWids , \"pwids\" ) ;\n parse_uin32_array ( tvb , offset , tree , cDepthPrev , \"prgiRowPrev\" ) ;\n }\n else {\n guint32 cDepthNext ;\n cDepthNext = tvb_get_letohl ( tvb , offset ) ;\n proto_tree_add_uint ( tree , hf_mswsp_msg_cpmfindindices_cdepthnext , tvb , offset , 4 , cDepthNext ) ;\n offset += 4 ;\n parse_uin32_array ( tvb , offset , tree , cDepthNext , \"prgiRowNext\" ) ;\n }\n return tvb_reported_length ( tvb ) ;\n }", "idx": 22045}
{"hash": -5861178779585941932, "project": "debian", "size": 8, "label": 1, "functionSource": "void safeputs ( netdissect_options * ndo , const u_char * s , const u_int maxlen ) {\n u_int idx = 0 ;\n while ( * s && idx < maxlen ) {\n safeputchar ( ndo , * s ) ;\n idx ++ ;\n s ++ ;\n }\n }", "idx": 22046}
{"hash": -2653265013496966602, "project": "debian", "size": 3, "label": 0, "functionSource": "static float spot1_dummy ( double x , double y ) {\n return ( x + y ) / 2 ;\n }", "idx": 22047}
{"hash": -7884836206149374350, "project": "chrome", "size": 5, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( BluetoothChooserBrowserTest , InvokeDialog_ConnectedBubble ) {\n set_status ( FakeBluetoothChooserController : : BluetoothStatus : : IDLE ) ;\n AddConnectedDevice ( ) ;\n RunDialog ( ) ;\n }", "idx": 22048}
{"hash": -5172040337488261750, "project": "debian", "size": 64, "label": 0, "functionSource": "static Image * ReadARTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) {\n const unsigned char * pixels ;\n Image * image ;\n QuantumInfo * quantum_info ;\n QuantumType quantum_type ;\n MagickBooleanType status ;\n size_t length ;\n ssize_t count , y ;\n assert ( image_info != ( const ImageInfo * ) NULL ) ;\n assert ( image_info -> signature == MagickSignature ) ;\n if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ;\n assert ( exception != ( ExceptionInfo * ) NULL ) ;\n assert ( exception -> signature == MagickSignature ) ;\n image = AcquireImage ( image_info ) ;\n status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ;\n if ( status == MagickFalse ) {\n image = DestroyImageList ( image ) ;\n return ( ( Image * ) NULL ) ;\n }\n image -> depth = 1 ;\n image -> endian = MSBEndian ;\n ( void ) ReadBlobLSBShort ( image ) ;\n image -> columns = ( size_t ) ReadBlobLSBShort ( image ) ;\n ( void ) ReadBlobLSBShort ( image ) ;\n image -> rows = ( size_t ) ReadBlobLSBShort ( image ) ;\n if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ;\n if ( AcquireImageColormap ( image , 2 ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ;\n if ( image_info -> ping != MagickFalse ) {\n ( void ) CloseBlob ( image ) ;\n return ( GetFirstImageInList ( image ) ) ;\n }\n status = SetImageExtent ( image , image -> columns , image -> rows ) ;\n if ( status == MagickFalse ) {\n InheritException ( exception , & image -> exception ) ;\n return ( DestroyImageList ( image ) ) ;\n }\n SetImageColorspace ( image , GRAYColorspace ) ;\n quantum_type = IndexQuantum ;\n quantum_info = AcquireQuantumInfo ( image_info , image ) ;\n if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ;\n length = GetQuantumExtent ( image , quantum_info , quantum_type ) ;\n for ( y = 0 ;\n y < ( ssize_t ) image -> rows ;\n y ++ ) {\n register PixelPacket * magick_restrict q ;\n q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;\n if ( q == ( PixelPacket * ) NULL ) break ;\n pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ;\n if ( count != ( ssize_t ) length ) {\n quantum_info = DestroyQuantumInfo ( quantum_info ) ;\n ThrowReaderException ( CorruptImageError , \"UnableToReadImageData\" ) ;\n }\n ( void ) ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , quantum_type , pixels , exception ) ;\n ( void ) ReadBlobStream ( image , ( size_t ) ( - ( ssize_t ) length ) & 0x01 , GetQuantumPixels ( quantum_info ) , & count ) ;\n if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ;\n status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ;\n if ( status == MagickFalse ) break ;\n }\n SetQuantumImageType ( image , quantum_type ) ;\n quantum_info = DestroyQuantumInfo ( quantum_info ) ;\n if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , \"UnexpectedEndOfFile\" , image -> filename ) ;\n ( void ) CloseBlob ( image ) ;\n return ( GetFirstImageInList ( image ) ) ;\n }", "idx": 22049}
{"hash": 1223258652239369123, "project": "debian", "size": 35, "label": 1, "functionSource": "SPL_METHOD ( SplFileInfo , getLinkTarget ) {\n spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n int ret ;\n char buff [ MAXPATHLEN ] ;\n zend_error_handling error_handling ;\n if ( zend_parse_parameters_none ( ) == FAILURE ) {\n return ;\n }\n zend_replace_error_handling ( EH_THROW , spl_ce_RuntimeException , & error_handling TSRMLS_CC ) ;\n # if defined ( PHP_WIN32 ) || HAVE_SYMLINK if ( intern -> file_name == NULL ) {\n php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Empty filename\" ) ;\n RETURN_FALSE ;\n }\n else if ( ! IS_ABSOLUTE_PATH ( intern -> file_name , intern -> file_name_len ) ) {\n char expanded_path [ MAXPATHLEN ] ;\n if ( ! expand_filepath_with_mode ( intern -> file_name , expanded_path , NULL , 0 , CWD_EXPAND TSRMLS_CC ) ) {\n php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"No such file or directory\" ) ;\n RETURN_FALSE ;\n }\n ret = php_sys_readlink ( expanded_path , buff , MAXPATHLEN - 1 ) ;\n }\n else {\n ret = php_sys_readlink ( intern -> file_name , buff , MAXPATHLEN - 1 ) ;\n }\n # else ret = - 1 ;\n # endif if ( ret == - 1 ) {\n zend_throw_exception_ex ( spl_ce_RuntimeException , 0 TSRMLS_CC , \"Unable to read link %s, error: %s\" , intern -> file_name , strerror ( errno ) ) ;\n RETVAL_FALSE ;\n }\n else {\n buff [ ret ] = '\\0' ;\n RETVAL_STRINGL ( buff , ret , 1 ) ;\n }\n zend_restore_error_handling ( & error_handling TSRMLS_CC ) ;\n }", "idx": 22050}
{"hash": -1672864273235910388, "project": "debian", "size": 33, "label": 0, "functionSource": "static void _slurm_rpc_dump_job_single ( slurm_msg_t * msg ) {\n DEF_TIMERS ;\n char * dump = NULL ;\n int dump_size , rc ;\n slurm_msg_t response_msg ;\n job_id_msg_t * job_id_msg = ( job_id_msg_t * ) msg -> data ;\n slurmctld_lock_t job_read_lock = {\n READ_LOCK , READ_LOCK , NO_LOCK , READ_LOCK , READ_LOCK }\n ;\n uid_t uid = g_slurm_auth_get_uid ( msg -> auth_cred , slurmctld_config . auth_info ) ;\n START_TIMER ;\n debug3 ( \"Processing RPC: REQUEST_JOB_INFO_SINGLE from uid=%d\" , uid ) ;\n lock_slurmctld ( job_read_lock ) ;\n rc = pack_one_job ( & dump , & dump_size , job_id_msg -> job_id , job_id_msg -> show_flags , uid , msg -> protocol_version ) ;\n unlock_slurmctld ( job_read_lock ) ;\n END_TIMER2 ( \"_slurm_rpc_dump_job_single\" ) ;\n # if 0 info ( \"_slurm_rpc_dump_job_single, size=%d %s\" , dump_size , TIME_STR ) ;\n # endif if ( rc != SLURM_SUCCESS ) {\n slurm_send_rc_msg ( msg , rc ) ;\n }\n else {\n slurm_msg_t_init ( & response_msg ) ;\n response_msg . flags = msg -> flags ;\n response_msg . protocol_version = msg -> protocol_version ;\n response_msg . address = msg -> address ;\n response_msg . conn = msg -> conn ;\n response_msg . msg_type = RESPONSE_JOB_INFO ;\n response_msg . data = dump ;\n response_msg . data_size = dump_size ;\n slurm_send_node_msg ( msg -> conn_fd , & response_msg ) ;\n }\n xfree ( dump ) ;\n }", "idx": 22051}
{"hash": -866921002076081979, "project": "debian", "size": 79, "label": 0, "functionSource": "static int cont_test_handler ( TSCont contp , TSEvent event , void * edata ) {\n TSHttpTxn txnp = ( TSHttpTxn ) edata ;\n ConnectTestData * data = nullptr ;\n int request_id = - 1 ;\n CHECK_SPURIOUS_EVENT ( contp , event , edata ) ;\n data = ( ConnectTestData * ) TSContDataGet ( contp ) ;\n TSReleaseAssert ( data -> magic == MAGIC_ALIVE ) ;\n TSReleaseAssert ( ( data -> test_case == TEST_CASE_CONNECT_ID1 ) || ( data -> test_case == TEST_CASE_CONNECT_ID2 ) ) ;\n TSDebug ( UTDBG_TAG , \"Calling cont_test_handler with event %s (%d)\" , TSHttpEventNameLookup ( event ) , event ) ;\n switch ( event ) {\n case TS_EVENT_HTTP_READ_REQUEST_HDR : TSDebug ( UTDBG_TAG , \"cont_test_handler: event READ_REQUEST\" ) ;\n request_id = get_request_id ( txnp ) ;\n TSReleaseAssert ( request_id != - 1 ) ;\n TSDebug ( UTDBG_TAG , \"cont_test_handler: Request id = %d\" , request_id ) ;\n if ( ( request_id != TEST_CASE_CONNECT_ID1 ) && ( request_id != TEST_CASE_CONNECT_ID2 ) ) {\n TSDebug ( UTDBG_TAG , \"This is not an event for this test !\" ) ;\n TSHttpTxnReenable ( txnp , TS_EVENT_HTTP_CONTINUE ) ;\n goto done ;\n }\n if ( ( request_id == TEST_CASE_CONNECT_ID1 ) && ( data -> test_case == TEST_CASE_CONNECT_ID1 ) ) {\n TSDebug ( UTDBG_TAG , \"Calling TSHttpTxnIntercept\" ) ;\n TSHttpTxnIntercept ( data -> os -> accept_cont , txnp ) ;\n }\n else if ( ( request_id == TEST_CASE_CONNECT_ID2 ) && ( data -> test_case == TEST_CASE_CONNECT_ID2 ) ) {\n TSDebug ( UTDBG_TAG , \"Calling TSHttpTxnServerIntercept\" ) ;\n TSHttpTxnServerIntercept ( data -> os -> accept_cont , txnp ) ;\n }\n TSHttpTxnReenable ( txnp , TS_EVENT_HTTP_CONTINUE ) ;\n break ;\n case TS_EVENT_TIMEOUT : if ( data -> browser -> status == REQUEST_INPROGRESS ) {\n TSDebug ( UTDBG_TAG , \"Browser still waiting response...\" ) ;\n TSContSchedule ( contp , 25 , TS_THREAD_POOL_DEFAULT ) ;\n }\n else {\n char * body_response = get_body_ptr ( data -> browser -> response ) ;\n const char * body_expected ;\n if ( data -> test_case == TEST_CASE_CONNECT_ID1 ) {\n body_expected = \"Body for response 9\" ;\n }\n else {\n body_expected = \"Body for response 10\" ;\n }\n TSDebug ( UTDBG_TAG , \"Body Response = \\n|%s|\\nBody Expected = \\n|%s|\" , body_response ? body_response : \"*NULL*\" , body_expected ) ;\n if ( ! body_response || strncmp ( body_response , body_expected , strlen ( body_expected ) ) != 0 ) {\n if ( data -> test_case == TEST_CASE_CONNECT_ID1 ) {\n SDK_RPRINT ( data -> test , \"TSHttpConnect\" , \"TestCase1\" , TC_FAIL , \"Unexpected response\" ) ;\n SDK_RPRINT ( data -> test , \"TSHttpTxnIntercept\" , \"TestCase1\" , TC_FAIL , \"Unexpected response\" ) ;\n }\n else {\n SDK_RPRINT ( data -> test , \"TSHttpConnect\" , \"TestCase2\" , TC_FAIL , \"Unexpected response\" ) ;\n SDK_RPRINT ( data -> test , \"TSHttpTxnServerIntercept\" , \"TestCase2\" , TC_FAIL , \"Unexpected response\" ) ;\n }\n * ( data -> pstatus ) = REGRESSION_TEST_FAILED ;\n }\n else {\n if ( data -> test_case == TEST_CASE_CONNECT_ID1 ) {\n SDK_RPRINT ( data -> test , \"TSHttpConnect\" , \"TestCase1\" , TC_PASS , \"ok\" ) ;\n SDK_RPRINT ( data -> test , \"TSHttpTxnIntercept\" , \"TestCase1\" , TC_PASS , \"ok\" ) ;\n }\n else {\n SDK_RPRINT ( data -> test , \"TSHttpConnect\" , \"TestCase2\" , TC_PASS , \"ok\" ) ;\n SDK_RPRINT ( data -> test , \"TSHttpTxnServerIntercept\" , \"TestCase2\" , TC_PASS , \"ok\" ) ;\n }\n * ( data -> pstatus ) = REGRESSION_TEST_PASSED ;\n }\n synclient_txn_delete ( data -> browser ) ;\n synserver_delete ( data -> os ) ;\n data -> os = nullptr ;\n data -> magic = MAGIC_DEAD ;\n TSfree ( data ) ;\n TSContDataSet ( contp , nullptr ) ;\n }\n break ;\n default : * ( data -> pstatus ) = REGRESSION_TEST_FAILED ;\n SDK_RPRINT ( data -> test , \"TSHttpConnect\" , \"TestCase1 or 2\" , TC_FAIL , \"Unexpected event %d\" , event ) ;\n break ;\n }\n done : return TS_EVENT_IMMEDIATE ;\n }", "idx": 22052}
{"hash": 4180964683905830761, "project": "debian", "size": 26, "label": 0, "functionSource": "static int selinux_getprocattr ( struct task_struct * p , char * name , char * * value ) {\n const struct task_security_struct * __tsec ;\n u32 sid ;\n int error ;\n unsigned len ;\n if ( current != p ) {\n error = current_has_perm ( p , PROCESS__GETATTR ) ;\n if ( error ) return error ;\n }\n rcu_read_lock ( ) ;\n __tsec = __task_cred ( p ) -> security ;\n if ( ! strcmp ( name , \"current\" ) ) sid = __tsec -> sid ;\n else if ( ! strcmp ( name , \"prev\" ) ) sid = __tsec -> osid ;\n else if ( ! strcmp ( name , \"exec\" ) ) sid = __tsec -> exec_sid ;\n else if ( ! strcmp ( name , \"fscreate\" ) ) sid = __tsec -> create_sid ;\n else if ( ! strcmp ( name , \"keycreate\" ) ) sid = __tsec -> keycreate_sid ;\n else if ( ! strcmp ( name , \"sockcreate\" ) ) sid = __tsec -> sockcreate_sid ;\n else goto invalid ;\n rcu_read_unlock ( ) ;\n if ( ! sid ) return 0 ;\n error = security_sid_to_context ( sid , value , & len ) ;\n if ( error ) return error ;\n return len ;\n invalid : rcu_read_unlock ( ) ;\n return - EINVAL ;\n }", "idx": 22053}
{"hash": -8028756826159773630, "project": "debian", "size": 90, "label": 0, "functionSource": "void ReadToc ( ArchiveHandle * AH ) {\n int i ;\n char * tmp ;\n DumpId * deps ;\n int depIdx ;\n int depSize ;\n TocEntry * te ;\n AH -> tocCount = ReadInt ( AH ) ;\n AH -> maxDumpId = 0 ;\n for ( i = 0 ;\n i < AH -> tocCount ;\n i ++ ) {\n te = ( TocEntry * ) pg_malloc0 ( sizeof ( TocEntry ) ) ;\n te -> dumpId = ReadInt ( AH ) ;\n if ( te -> dumpId > AH -> maxDumpId ) AH -> maxDumpId = te -> dumpId ;\n if ( te -> dumpId <= 0 ) exit_horribly ( modulename , \"entry ID %d out of range -- perhaps a corrupt TOC\\n\" , te -> dumpId ) ;\n te -> hadDumper = ReadInt ( AH ) ;\n if ( AH -> version >= K_VERS_1_8 ) {\n tmp = ReadStr ( AH ) ;\n sscanf ( tmp , \"%u\" , & te -> catalogId . tableoid ) ;\n free ( tmp ) ;\n }\n else te -> catalogId . tableoid = InvalidOid ;\n tmp = ReadStr ( AH ) ;\n sscanf ( tmp , \"%u\" , & te -> catalogId . oid ) ;\n free ( tmp ) ;\n te -> tag = ReadStr ( AH ) ;\n te -> desc = ReadStr ( AH ) ;\n if ( AH -> version >= K_VERS_1_11 ) {\n te -> section = ReadInt ( AH ) ;\n }\n else {\n if ( strcmp ( te -> desc , \"COMMENT\" ) == 0 || strcmp ( te -> desc , \"ACL\" ) == 0 || strcmp ( te -> desc , \"ACL LANGUAGE\" ) == 0 ) te -> section = SECTION_NONE ;\n else if ( strcmp ( te -> desc , \"TABLE DATA\" ) == 0 || strcmp ( te -> desc , \"BLOBS\" ) == 0 || strcmp ( te -> desc , \"BLOB COMMENTS\" ) == 0 ) te -> section = SECTION_DATA ;\n else if ( strcmp ( te -> desc , \"CONSTRAINT\" ) == 0 || strcmp ( te -> desc , \"CHECK CONSTRAINT\" ) == 0 || strcmp ( te -> desc , \"FK CONSTRAINT\" ) == 0 || strcmp ( te -> desc , \"INDEX\" ) == 0 || strcmp ( te -> desc , \"RULE\" ) == 0 || strcmp ( te -> desc , \"TRIGGER\" ) == 0 ) te -> section = SECTION_POST_DATA ;\n else te -> section = SECTION_PRE_DATA ;\n }\n te -> defn = ReadStr ( AH ) ;\n te -> dropStmt = ReadStr ( AH ) ;\n if ( AH -> version >= K_VERS_1_3 ) te -> copyStmt = ReadStr ( AH ) ;\n if ( AH -> version >= K_VERS_1_6 ) te -> namespace = ReadStr ( AH ) ;\n if ( AH -> version >= K_VERS_1_10 ) te -> tablespace = ReadStr ( AH ) ;\n te -> owner = ReadStr ( AH ) ;\n if ( AH -> version >= K_VERS_1_9 ) {\n if ( strcmp ( ReadStr ( AH ) , \"true\" ) == 0 ) te -> withOids = true ;\n else te -> withOids = false ;\n }\n else te -> withOids = true ;\n if ( AH -> version >= K_VERS_1_5 ) {\n depSize = 100 ;\n deps = ( DumpId * ) pg_malloc ( sizeof ( DumpId ) * depSize ) ;\n depIdx = 0 ;\n for ( ;\n ;\n ) {\n tmp = ReadStr ( AH ) ;\n if ( ! tmp ) break ;\n if ( depIdx >= depSize ) {\n depSize *= 2 ;\n deps = ( DumpId * ) pg_realloc ( deps , sizeof ( DumpId ) * depSize ) ;\n }\n sscanf ( tmp , \"%d\" , & deps [ depIdx ] ) ;\n free ( tmp ) ;\n depIdx ++ ;\n }\n if ( depIdx > 0 ) {\n deps = ( DumpId * ) pg_realloc ( deps , sizeof ( DumpId ) * depIdx ) ;\n te -> dependencies = deps ;\n te -> nDeps = depIdx ;\n }\n else {\n free ( deps ) ;\n te -> dependencies = NULL ;\n te -> nDeps = 0 ;\n }\n }\n else {\n te -> dependencies = NULL ;\n te -> nDeps = 0 ;\n }\n if ( AH -> ReadExtraTocPtr ) ( * AH -> ReadExtraTocPtr ) ( AH , te ) ;\n ahlog ( AH , 3 , \"read TOC entry %d (ID %d) for %s %s\\n\" , i , te -> dumpId , te -> desc , te -> tag ) ;\n te -> prev = AH -> toc -> prev ;\n AH -> toc -> prev -> next = te ;\n AH -> toc -> prev = te ;\n te -> next = AH -> toc ;\n if ( strcmp ( te -> desc , \"ENCODING\" ) == 0 ) processEncodingEntry ( AH , te ) ;\n else if ( strcmp ( te -> desc , \"STDSTRINGS\" ) == 0 ) processStdStringsEntry ( AH , te ) ;\n }\n }", "idx": 22054}
{"hash": -4525874104093394205, "project": "debian", "size": 82, "label": 1, "functionSource": "OFCondition parseAssociate ( unsigned char * buf , unsigned long pduLength , PRV_ASSOCIATEPDU * assoc ) {\n OFCondition cond = EC_Normal ;\n unsigned char type ;\n unsigned long itemLength ;\n PRV_PRESENTATIONCONTEXTITEM * context ;\n ( void ) memset ( assoc , 0 , sizeof ( * assoc ) ) ;\n if ( ( assoc -> presentationContextList = LST_Create ( ) ) == NULL ) return EC_MemoryExhausted ;\n if ( ( assoc -> userInfo . SCUSCPRoleList = LST_Create ( ) ) == NULL ) return EC_MemoryExhausted ;\n if ( pduLength < 2 + 2 + 16 + 16 + 32 ) return makeLengthError ( \"associate PDU\" , pduLength , 2 + 2 + 16 + 16 + 32 ) ;\n assoc -> type = * buf ++ ;\n assoc -> rsv1 = * buf ++ ;\n EXTRACT_LONG_BIG ( buf , assoc -> length ) ;\n buf += 4 ;\n EXTRACT_SHORT_BIG ( buf , assoc -> protocol ) ;\n buf += 2 ;\n pduLength -= 2 ;\n if ( ( assoc -> protocol & DUL_PROTOCOL ) == 0 ) {\n char buffer [ 256 ] ;\n sprintf ( buffer , \"DUL Unsupported peer protocol %04x;\n expected %04x in %s\" , assoc -> protocol , DUL_PROTOCOL , \"parseAssociate\" ) ;\n return makeDcmnetCondition ( DULC_UNSUPPORTEDPEERPROTOCOL , OF_error , buffer ) ;\n }\n assoc -> rsv2 [ 0 ] = * buf ++ ;\n pduLength -- ;\n assoc -> rsv2 [ 1 ] = * buf ++ ;\n pduLength -- ;\n ( void ) strncpy ( assoc -> calledAPTitle , ( char * ) buf , 16 ) ;\n assoc -> calledAPTitle [ 16 ] = '\\0' ;\n trim_trailing_spaces ( assoc -> calledAPTitle ) ;\n buf += 16 ;\n pduLength -= 16 ;\n ( void ) strncpy ( assoc -> callingAPTitle , ( char * ) buf , 16 ) ;\n assoc -> callingAPTitle [ 16 ] = '\\0' ;\n trim_trailing_spaces ( assoc -> callingAPTitle ) ;\n buf += 16 ;\n pduLength -= 16 ;\n ( void ) memcpy ( assoc -> rsv3 , buf , 32 ) ;\n buf += 32 ;\n pduLength -= 32 ;\n if ( DCM_dcmnetLogger . isEnabledFor ( OFLogger : : DEBUG_LOG_LEVEL ) ) {\n const char * s ;\n DCMNET_DEBUG ( \"Parsing an A-ASSOCIATE PDU\" ) ;\n if ( assoc -> type == DUL_TYPEASSOCIATERQ ) s = \"A-ASSOCIATE RQ\" ;\n else if ( assoc -> type == DUL_TYPEASSOCIATEAC ) s = \"A-ASSOCIATE AC\" ;\n else s = \"Unknown: Programming bug in parseAssociate\" ;\n DCMNET_TRACE ( \"PDU type: \" << STD_NAMESPACE hex << ( ( unsigned int ) assoc -> type ) << STD_NAMESPACE dec << \" (\" << s << \"), PDU Length: \" << assoc -> length << OFendl << \"DICOM Protocol: \" << STD_NAMESPACE hex << assoc -> protocol << STD_NAMESPACE dec << OFendl << \"Called AP Title: \" << assoc -> calledAPTitle << OFendl << \"Calling AP Title: \" << assoc -> callingAPTitle ) ;\n }\n while ( ( cond . good ( ) ) && ( pduLength > 0 ) ) {\n type = * buf ;\n DCMNET_TRACE ( \"Parsing remaining \" << pduLength << \" bytes of A-ASSOCIATE PDU\" << OFendl << \"Next item type: \" << STD_NAMESPACE hex << STD_NAMESPACE setfill ( '0' ) << STD_NAMESPACE setw ( 2 ) << ( ( unsigned int ) type ) ) ;\n switch ( type ) {\n case DUL_TYPEAPPLICATIONCONTEXT : cond = parseSubItem ( & assoc -> applicationContext , buf , & itemLength , pduLength ) ;\n if ( cond . good ( ) ) {\n buf += itemLength ;\n pduLength -= itemLength ;\n DCMNET_TRACE ( \"Successfully parsed Application Context\" ) ;\n }\n break ;\n case DUL_TYPEPRESENTATIONCONTEXTRQ : case DUL_TYPEPRESENTATIONCONTEXTAC : context = ( PRV_PRESENTATIONCONTEXTITEM * ) malloc ( sizeof ( PRV_PRESENTATIONCONTEXTITEM ) ) ;\n if ( context == NULL ) return EC_MemoryExhausted ;\n ( void ) memset ( context , 0 , sizeof ( * context ) ) ;\n cond = parsePresentationContext ( type , context , buf , & itemLength , pduLength ) ;\n if ( cond . bad ( ) ) return cond ;\n buf += itemLength ;\n pduLength -= itemLength ;\n LST_Enqueue ( & assoc -> presentationContextList , ( LST_NODE * ) context ) ;\n DCMNET_TRACE ( \"Successfully parsed Presentation Context\" ) ;\n break ;\n case DUL_TYPEUSERINFO : cond = parseUserInfo ( & assoc -> userInfo , buf , & itemLength , assoc -> type , pduLength ) ;\n if ( cond . bad ( ) ) return cond ;\n buf += itemLength ;\n pduLength -= itemLength ;\n DCMNET_TRACE ( \"Successfully parsed User Information\" ) ;\n break ;\n default : cond = parseDummy ( buf , & itemLength , pduLength ) ;\n buf += itemLength ;\n pduLength -= itemLength ;\n break ;\n }\n }\n return cond ;\n }", "idx": 22055}
{"hash": 1760449185745615462, "project": "debian", "size": 6, "label": 0, "functionSource": "TSReturnCode sdk_sanity_check_mime_parser ( TSMimeParser parser ) {\n if ( parser == nullptr ) {\n return TS_ERROR ;\n }\n return TS_SUCCESS ;\n }", "idx": 22056}
{"hash": 58020529414140129, "project": "chrome", "size": 61, "label": 1, "functionSource": "void vp9_choose_segmap_coding_method ( VP9_COMMON * cm , MACROBLOCKD * xd ) {\n struct segmentation * seg = & cm -> seg ;\n int no_pred_cost ;\n int t_pred_cost = INT_MAX ;\n int i , tile_col , mi_row , mi_col ;\n int temporal_predictor_count [ PREDICTION_PROBS ] [ 2 ] = {\n {\n 0 }\n }\n ;\n int no_pred_segcounts [ MAX_SEGMENTS ] = {\n 0 }\n ;\n int t_unpred_seg_counts [ MAX_SEGMENTS ] = {\n 0 }\n ;\n vp9_prob no_pred_tree [ SEG_TREE_PROBS ] ;\n vp9_prob t_pred_tree [ SEG_TREE_PROBS ] ;\n vp9_prob t_nopred_prob [ PREDICTION_PROBS ] ;\n vpx_memset ( seg -> tree_probs , 255 , sizeof ( seg -> tree_probs ) ) ;\n vpx_memset ( seg -> pred_probs , 255 , sizeof ( seg -> pred_probs ) ) ;\n for ( tile_col = 0 ;\n tile_col < 1 << cm -> log2_tile_cols ;\n tile_col ++ ) {\n TileInfo tile ;\n MODE_INFO * * mi_ptr ;\n vp9_tile_init ( & tile , cm , 0 , tile_col ) ;\n mi_ptr = cm -> mi_grid_visible + tile . mi_col_start ;\n for ( mi_row = 0 ;\n mi_row < cm -> mi_rows ;\n mi_row += 8 , mi_ptr += 8 * cm -> mi_stride ) {\n MODE_INFO * * mi = mi_ptr ;\n for ( mi_col = tile . mi_col_start ;\n mi_col < tile . mi_col_end ;\n mi_col += 8 , mi += 8 ) count_segs_sb ( cm , xd , & tile , mi , no_pred_segcounts , temporal_predictor_count , t_unpred_seg_counts , mi_row , mi_col , BLOCK_64X64 ) ;\n }\n }\n calc_segtree_probs ( no_pred_segcounts , no_pred_tree ) ;\n no_pred_cost = cost_segmap ( no_pred_segcounts , no_pred_tree ) ;\n if ( ! frame_is_intra_only ( cm ) ) {\n calc_segtree_probs ( t_unpred_seg_counts , t_pred_tree ) ;\n t_pred_cost = cost_segmap ( t_unpred_seg_counts , t_pred_tree ) ;\n for ( i = 0 ;\n i < PREDICTION_PROBS ;\n i ++ ) {\n const int count0 = temporal_predictor_count [ i ] [ 0 ] ;\n const int count1 = temporal_predictor_count [ i ] [ 1 ] ;\n t_nopred_prob [ i ] = get_binary_prob ( count0 , count1 ) ;\n t_pred_cost += count0 * vp9_cost_zero ( t_nopred_prob [ i ] ) + count1 * vp9_cost_one ( t_nopred_prob [ i ] ) ;\n }\n }\n if ( t_pred_cost < no_pred_cost ) {\n seg -> temporal_update = 1 ;\n vpx_memcpy ( seg -> tree_probs , t_pred_tree , sizeof ( t_pred_tree ) ) ;\n vpx_memcpy ( seg -> pred_probs , t_nopred_prob , sizeof ( t_nopred_prob ) ) ;\n }\n else {\n seg -> temporal_update = 0 ;\n vpx_memcpy ( seg -> tree_probs , no_pred_tree , sizeof ( no_pred_tree ) ) ;\n }\n }", "idx": 22057}
{"hash": 6632536031698733342, "project": "debian", "size": 25, "label": 0, "functionSource": "static const char * json_escape_str ( AVBPrint * dst , const char * src , void * log_ctx ) {\n static const char json_escape [ ] = {\n '\"' , '\\\\' , '\\b' , '\\f' , '\\n' , '\\r' , '\\t' , 0 }\n ;\n static const char json_subst [ ] = {\n '\"' , '\\\\' , 'b' , 'f' , 'n' , 'r' , 't' , 0 }\n ;\n const char * p ;\n for ( p = src ;\n * p ;\n p ++ ) {\n char * s = strchr ( json_escape , * p ) ;\n if ( s ) {\n av_bprint_chars ( dst , '\\\\' , 1 ) ;\n av_bprint_chars ( dst , json_subst [ s - json_escape ] , 1 ) ;\n }\n else if ( ( unsigned char ) * p < 32 ) {\n av_bprintf ( dst , \"\\\\u00%02x\" , * p & 0xff ) ;\n }\n else {\n av_bprint_chars ( dst , * p , 1 ) ;\n }\n }\n return dst -> str ;\n }", "idx": 22058}
{"hash": 6667142528452941476, "project": "debian", "size": 51, "label": 0, "functionSource": "static int get_options ( int * argc , char * * * argv ) {\n int ho_error ;\n MYSQL_PARAMETERS * mysql_params = mysql_get_parameters ( ) ;\n opt_max_allowed_packet = * mysql_params -> p_max_allowed_packet ;\n opt_net_buffer_length = * mysql_params -> p_net_buffer_length ;\n md_result_file = stdout ;\n if ( load_defaults ( \"my\" , load_default_groups , argc , argv ) ) return 1 ;\n defaults_argv = * argv ;\n if ( my_hash_init ( & ignore_table , charset_info , 16 , 0 , 0 , ( my_hash_get_key ) get_table_key , my_free , 0 ) ) return ( EX_EOM ) ;\n if ( my_hash_insert ( & ignore_table , ( uchar * ) my_strdup ( \"mysql.apply_status\" , MYF ( MY_WME ) ) ) || my_hash_insert ( & ignore_table , ( uchar * ) my_strdup ( \"mysql.schema\" , MYF ( MY_WME ) ) ) || my_hash_insert ( & ignore_table , ( uchar * ) my_strdup ( \"mysql.general_log\" , MYF ( MY_WME ) ) ) || my_hash_insert ( & ignore_table , ( uchar * ) my_strdup ( \"mysql.slow_log\" , MYF ( MY_WME ) ) ) ) return ( EX_EOM ) ;\n if ( ( ho_error = handle_options ( argc , argv , my_long_options , get_one_option ) ) ) return ( ho_error ) ;\n * mysql_params -> p_max_allowed_packet = opt_max_allowed_packet ;\n * mysql_params -> p_net_buffer_length = opt_net_buffer_length ;\n if ( debug_info_flag ) my_end_arg = MY_CHECK_ERROR | MY_GIVE_INFO ;\n if ( debug_check_flag ) my_end_arg = MY_CHECK_ERROR ;\n if ( opt_delayed ) opt_lock = 0 ;\n if ( ! path && ( enclosed || opt_enclosed || escaped || lines_terminated || fields_terminated ) ) {\n fprintf ( stderr , \"%s: You must use option --tab with --fields-...\\n\" , my_progname_short ) ;\n return ( EX_USAGE ) ;\n }\n if ( opt_slave_data ) {\n opt_lock_all_tables = ! opt_single_transaction ;\n opt_master_data = 0 ;\n opt_delete_master_logs = 0 ;\n }\n if ( opt_delete_master_logs && ! opt_master_data ) opt_master_data = MYSQL_OPT_MASTER_DATA_COMMENTED_SQL ;\n if ( opt_single_transaction && opt_lock_all_tables ) {\n fprintf ( stderr , \"%s: You can't use --single-transaction and \" \"--lock-all-tables at the same time.\\n\" , my_progname_short ) ;\n return ( EX_USAGE ) ;\n }\n if ( opt_master_data ) {\n opt_lock_all_tables = ! opt_single_transaction ;\n opt_slave_data = 0 ;\n }\n if ( opt_single_transaction || opt_lock_all_tables ) lock_tables = 0 ;\n if ( enclosed && opt_enclosed ) {\n fprintf ( stderr , \"%s: You can't use ..enclosed.. and ..optionally-enclosed.. at the same time.\\n\" , my_progname_short ) ;\n return ( EX_USAGE ) ;\n }\n if ( ( opt_databases || opt_alldbs ) && path ) {\n fprintf ( stderr , \"%s: --databases or --all-databases can't be used with --tab.\\n\" , my_progname_short ) ;\n return ( EX_USAGE ) ;\n }\n if ( strcmp ( default_charset , charset_info -> csname ) && ! ( charset_info = get_charset_by_csname ( default_charset , MY_CS_PRIMARY , MYF ( MY_WME ) ) ) ) exit ( 1 ) ;\n if ( ( * argc < 1 && ! opt_alldbs ) || ( * argc > 0 && opt_alldbs ) ) {\n short_usage ( stderr ) ;\n return EX_USAGE ;\n }\n if ( tty_password ) opt_password = get_tty_password ( NullS ) ;\n return ( 0 ) ;\n }", "idx": 22059}
{"hash": -2928324134072492299, "project": "debian", "size": 121, "label": 0, "functionSource": "static int isup_calls_packet ( void * ptr _U_ , packet_info * pinfo , epan_dissect_t * edt _U_ , const void * isup_info _U_ ) {\n voip_calls_tapinfo_t * tapinfo = & the_tapinfo_struct ;\n voip_calls_info_t * tmp_listinfo ;\n voip_calls_info_t * callsinfo = NULL ;\n isup_calls_info_t * tmp_isupinfo ;\n gboolean found = FALSE ;\n gboolean forward = FALSE ;\n gboolean right_pair ;\n GList * list ;\n gchar * frame_label = NULL ;\n gchar * comment = NULL ;\n const isup_tap_rec_t * pi = ( const isup_tap_rec_t * ) isup_info ;\n if ( mtp3_frame_num != pinfo -> fd -> num ) return 0 ;\n list = g_list_first ( tapinfo -> callsinfo_list ) ;\n while ( list ) {\n right_pair = TRUE ;\n tmp_listinfo = ( voip_calls_info_t * ) list -> data ;\n if ( ( tmp_listinfo -> protocol == VOIP_ISUP ) && ( tmp_listinfo -> call_active_state == VOIP_ACTIVE ) ) {\n tmp_isupinfo = ( isup_calls_info_t * ) tmp_listinfo -> prot_info ;\n if ( ( tmp_isupinfo -> cic == pinfo -> circuit_id ) && ( tmp_isupinfo -> ni == mtp3_ni ) ) {\n if ( ( tmp_isupinfo -> opc == mtp3_opc ) && ( tmp_isupinfo -> dpc == mtp3_dpc ) ) {\n forward = TRUE ;\n }\n else if ( ( tmp_isupinfo -> dpc == mtp3_opc ) && ( tmp_isupinfo -> opc == mtp3_dpc ) ) {\n forward = FALSE ;\n }\n else {\n right_pair = FALSE ;\n }\n if ( right_pair ) {\n if ( tmp_listinfo -> call_state == VOIP_CALL_SETUP ) {\n found = TRUE ;\n }\n else if ( pi -> message_type != 1 ) {\n found = TRUE ;\n }\n else {\n tmp_listinfo -> call_active_state = VOIP_INACTIVE ;\n }\n }\n if ( found ) {\n callsinfo = ( voip_calls_info_t * ) ( list -> data ) ;\n break ;\n }\n }\n }\n list = g_list_next ( list ) ;\n }\n if ( ( callsinfo == NULL ) && ( pi -> message_type == 1 ) ) {\n callsinfo = ( voip_calls_info_t * ) g_malloc0 ( sizeof ( voip_calls_info_t ) ) ;\n callsinfo -> call_active_state = VOIP_ACTIVE ;\n callsinfo -> call_state = VOIP_UNKNOWN ;\n COPY_ADDRESS ( & ( callsinfo -> initial_speaker ) , & ( pinfo -> src ) ) ;\n callsinfo -> selected = FALSE ;\n callsinfo -> start_fd = pinfo -> fd ;\n callsinfo -> start_rel_ts = pinfo -> rel_ts ;\n callsinfo -> protocol = VOIP_ISUP ;\n if ( pi -> calling_number != NULL ) {\n callsinfo -> from_identity = g_strdup ( pi -> calling_number ) ;\n }\n if ( pi -> called_number != NULL ) {\n callsinfo -> to_identity = g_strdup ( pi -> called_number ) ;\n }\n callsinfo -> prot_info = g_malloc ( sizeof ( isup_calls_info_t ) ) ;\n callsinfo -> free_prot_info = g_free ;\n tmp_isupinfo = ( isup_calls_info_t * ) callsinfo -> prot_info ;\n tmp_isupinfo -> opc = mtp3_opc ;\n tmp_isupinfo -> dpc = mtp3_dpc ;\n tmp_isupinfo -> ni = mtp3_ni ;\n tmp_isupinfo -> cic = pinfo -> circuit_id ;\n callsinfo -> npackets = 0 ;\n callsinfo -> call_num = tapinfo -> ncalls ++ ;\n tapinfo -> callsinfo_list = g_list_prepend ( tapinfo -> callsinfo_list , callsinfo ) ;\n }\n if ( callsinfo != NULL ) {\n callsinfo -> stop_fd = pinfo -> fd ;\n callsinfo -> stop_rel_ts = pinfo -> rel_ts ;\n ++ ( callsinfo -> npackets ) ;\n frame_label = g_strdup ( val_to_str_ext_const ( pi -> message_type , & isup_message_type_value_acro_ext , \"Unknown\" ) ) ;\n if ( callsinfo -> npackets == 1 ) {\n if ( ( pi -> calling_number != NULL ) && ( pi -> called_number != NULL ) ) {\n comment = g_strdup_printf ( \"Call from %s to %s\" , pi -> calling_number , pi -> called_number ) ;\n }\n }\n else if ( callsinfo -> npackets == 2 ) {\n if ( forward ) {\n comment = g_strdup_printf ( \"%i-%i -> %i-%i. Cic:%i\" , mtp3_ni , mtp3_opc , mtp3_ni , mtp3_dpc , pinfo -> circuit_id ) ;\n }\n else {\n comment = g_strdup_printf ( \"%i-%i -> %i-%i. Cic:%i\" , mtp3_ni , mtp3_dpc , mtp3_ni , mtp3_opc , pinfo -> circuit_id ) ;\n }\n }\n switch ( pi -> message_type ) {\n case 1 : callsinfo -> call_state = VOIP_CALL_SETUP ;\n break ;\n case 7 : case 9 : callsinfo -> call_state = VOIP_IN_CALL ;\n break ;\n case 12 : if ( callsinfo -> call_state == VOIP_CALL_SETUP ) {\n if ( forward ) {\n callsinfo -> call_state = VOIP_CANCELLED ;\n }\n else {\n callsinfo -> call_state = VOIP_REJECTED ;\n tapinfo -> rejected_calls ++ ;\n }\n }\n else if ( callsinfo -> call_state == VOIP_IN_CALL ) {\n callsinfo -> call_state = VOIP_COMPLETED ;\n tapinfo -> completed_calls ++ ;\n }\n comment = g_strdup_printf ( \"Cause %i - %s\" , pi -> cause_value , val_to_str_ext_const ( pi -> cause_value , & q931_cause_code_vals_ext , \"(Unknown)\" ) ) ;\n break ;\n }\n ++ ( tapinfo -> npackets ) ;\n add_to_graph ( tapinfo , pinfo , frame_label , comment , callsinfo -> call_num , & ( pinfo -> src ) , & ( pinfo -> dst ) , 1 ) ;\n g_free ( comment ) ;\n g_free ( frame_label ) ;\n }\n tapinfo -> redraw = TRUE ;\n return 1 ;\n }", "idx": 22060}
{"hash": 6336384260629386331, "project": "debian", "size": 10, "label": 0, "functionSource": "static guint8 dissect_zcl_ota_field_ctrl_field ( tvbuff_t * tvb , proto_tree * tree , guint * offset ) {\n guint8 field ;\n static const int * field_ctrl [ ] = {\n & hf_zbee_zcl_ota_field_ctrl_hw_ver_present , & hf_zbee_zcl_ota_field_ctrl_reserved , NULL }\n ;\n field = tvb_get_guint8 ( tvb , * offset ) ;\n proto_tree_add_bitmask ( tree , tvb , * offset , hf_zbee_zcl_ota_field_ctrl , ett_zbee_zcl_ota_field_ctrl , field_ctrl , ENC_BIG_ENDIAN ) ;\n * offset += 1 ;\n return field ;\n }", "idx": 22061}
{"hash": 1245821301839614810, "project": "debian", "size": 34, "label": 0, "functionSource": "static void delete_files ( CommonJob * job , GList * files , int * files_skipped ) {\n GList * l ;\n GFile * file ;\n SourceInfo source_info ;\n TransferInfo transfer_info ;\n DeleteData data ;\n if ( job_aborted ( job ) ) {\n return ;\n }\n scan_sources ( files , & source_info , job , OP_KIND_DELETE ) ;\n if ( job_aborted ( job ) ) {\n return ;\n }\n g_timer_start ( job -> time ) ;\n memset ( & transfer_info , 0 , sizeof ( transfer_info ) ) ;\n report_delete_progress ( job , & source_info , & transfer_info ) ;\n data . job = job ;\n data . source_info = & source_info ;\n data . transfer_info = & transfer_info ;\n for ( l = files ;\n l != NULL && ! job_aborted ( job ) ;\n l = l -> next ) {\n gboolean success ;\n file = l -> data ;\n if ( should_skip_file ( job , file ) ) {\n ( * files_skipped ) ++ ;\n continue ;\n }\n success = delete_file_recursively ( file , job -> cancellable , file_deleted_callback , & data ) ;\n if ( ! success ) {\n ( * files_skipped ) ++ ;\n }\n }\n }", "idx": 22062}
{"hash": 3649198920984613385, "project": "debian", "size": 8, "label": 0, "functionSource": "static void vmsvga_invalidate_display ( void * opaque ) {\n struct vmsvga_state_s * s = opaque ;\n if ( ! s -> enable ) {\n s -> vga . hw_ops -> invalidate ( & s -> vga ) ;\n return ;\n }\n s -> invalidated = 1 ;\n }", "idx": 22063}
{"hash": 5357882892791796049, "project": "debian", "size": 5, "label": 0, "functionSource": "static inline void e1000e_raise_legacy_irq ( E1000ECore * core ) {\n trace_e1000e_irq_legacy_notify ( true ) ;\n e1000x_inc_reg_if_not_full ( core -> mac , IAC ) ;\n pci_set_irq ( core -> owner , 1 ) ;\n }", "idx": 22064}
{"hash": -6333668321124139371, "project": "debian", "size": 3, "label": 0, "functionSource": "static void rtp_fragment_init ( void ) {\n reassembly_table_init ( & rtp_reassembly_table , & addresses_reassembly_table_functions ) ;\n }", "idx": 22065}
{"hash": 2388171415474875762, "project": "debian", "size": 6, "label": 0, "functionSource": "static int rsvp_conversation_packet ( void * pct , packet_info * pinfo , epan_dissect_t * edt _U_ , const void * vip ) {\n conv_hash_t * hash = ( conv_hash_t * ) pct ;\n const rsvp_conversation_info * rsvph = ( const rsvp_conversation_info * ) vip ;\n add_conversation_table_data ( hash , & rsvph -> source , & rsvph -> destination , 0 , 0 , 1 , pinfo -> fd -> pkt_len , & pinfo -> rel_ts , & pinfo -> fd -> abs_ts , & rsvp_ct_dissector_info , PT_NONE ) ;\n return 1 ;\n }", "idx": 22066}
{"hash": 8320716512483418415, "project": "chrome", "size": 15, "label": 0, "functionSource": "void vp9_idct8x8_1_add_c ( const tran_low_t * input , uint8_t * dest , int stride ) {\n int i , j ;\n tran_high_t a1 ;\n tran_low_t out = dct_const_round_shift ( input [ 0 ] * cospi_16_64 ) ;\n out = dct_const_round_shift ( out * cospi_16_64 ) ;\n a1 = ROUND_POWER_OF_TWO ( out , 5 ) ;\n for ( j = 0 ;\n j < 8 ;\n ++ j ) {\n for ( i = 0 ;\n i < 8 ;\n ++ i ) dest [ i ] = clip_pixel ( dest [ i ] + a1 ) ;\n dest += stride ;\n }\n }", "idx": 22067}
{"hash": -8884965407551053630, "project": "debian", "size": 8, "label": 0, "functionSource": "static vout_thread_t * aout_request_vout ( void * p_private , vout_thread_t * p_vout , video_format_t * p_fmt , bool b_recyle ) {\n decoder_t * p_dec = p_private ;\n decoder_owner_sys_t * p_owner = p_dec -> p_owner ;\n input_thread_t * p_input = p_owner -> p_input ;\n p_vout = input_resource_RequestVout ( p_owner -> p_resource , p_vout , p_fmt , 1 , b_recyle ) ;\n if ( p_input != NULL ) input_SendEventVout ( p_input ) ;\n return p_vout ;\n }", "idx": 22068}
{"hash": 1223258652239369123, "project": "debian", "size": 27, "label": 0, "functionSource": "SPL_METHOD ( SplFileObject , fgetcsv ) {\n spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n char delimiter = intern -> u . file . delimiter , enclosure = intern -> u . file . enclosure , escape = intern -> u . file . escape ;\n char * delim = NULL , * enclo = NULL , * esc = NULL ;\n int d_len = 0 , e_len = 0 , esc_len = 0 ;\n if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , \"|sss\" , & delim , & d_len , & enclo , & e_len , & esc , & esc_len ) == SUCCESS ) {\n switch ( ZEND_NUM_ARGS ( ) ) {\n case 3 : if ( esc_len != 1 ) {\n php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"escape must be a character\" ) ;\n RETURN_FALSE ;\n }\n escape = esc [ 0 ] ;\n case 2 : if ( e_len != 1 ) {\n php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"enclosure must be a character\" ) ;\n RETURN_FALSE ;\n }\n enclosure = enclo [ 0 ] ;\n case 1 : if ( d_len != 1 ) {\n php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"delimiter must be a character\" ) ;\n RETURN_FALSE ;\n }\n delimiter = delim [ 0 ] ;\n case 0 : break ;\n }\n spl_filesystem_file_read_csv ( intern , delimiter , enclosure , escape , return_value TSRMLS_CC ) ;\n }\n }", "idx": 22069}
{"hash": 8127806390163862344, "project": "debian", "size": 7, "label": 0, "functionSource": "static void vapic_reset ( DeviceState * dev ) {\n VAPICROMState * s = DO_UPCAST ( VAPICROMState , busdev . qdev , dev ) ;\n if ( s -> state == VAPIC_ACTIVE ) {\n s -> state = VAPIC_STANDBY ;\n }\n vapic_enable_tpr_reporting ( false ) ;\n }", "idx": 22070}
{"hash": 1223258652239369123, "project": "debian", "size": 23, "label": 0, "functionSource": "static void spl_filesystem_tree_it_current_data ( zend_object_iterator * iter , zval * * * data TSRMLS_DC ) {\n spl_filesystem_iterator * iterator = ( spl_filesystem_iterator * ) iter ;\n spl_filesystem_object * object = spl_filesystem_iterator_to_object ( iterator ) ;\n if ( SPL_FILE_DIR_CURRENT ( object , SPL_FILE_DIR_CURRENT_AS_PATHNAME ) ) {\n if ( ! iterator -> current ) {\n ALLOC_INIT_ZVAL ( iterator -> current ) ;\n spl_filesystem_object_get_file_name ( object TSRMLS_CC ) ;\n ZVAL_STRINGL ( iterator -> current , object -> file_name , object -> file_name_len , 1 ) ;\n }\n * data = & iterator -> current ;\n }\n else if ( SPL_FILE_DIR_CURRENT ( object , SPL_FILE_DIR_CURRENT_AS_FILEINFO ) ) {\n if ( ! iterator -> current ) {\n ALLOC_INIT_ZVAL ( iterator -> current ) ;\n spl_filesystem_object_get_file_name ( object TSRMLS_CC ) ;\n spl_filesystem_object_create_type ( 0 , object , SPL_FS_INFO , NULL , iterator -> current TSRMLS_CC ) ;\n }\n * data = & iterator -> current ;\n }\n else {\n * data = ( zval * * ) & iterator -> intern . data ;\n }\n }", "idx": 22071}
{"hash": -5493081488206619677, "project": "debian", "size": 7, "label": 0, "functionSource": "static const char * cmd_upload_dir ( cmd_parms * cmd , void * _dcfg , const char * p1 ) {\n directory_config * dcfg = ( directory_config * ) _dcfg ;\n if ( dcfg == NULL ) return NULL ;\n if ( strcasecmp ( p1 , \"none\" ) == 0 ) dcfg -> upload_dir = NULL ;\n else dcfg -> upload_dir = ap_server_root_relative ( cmd -> pool , p1 ) ;\n return NULL ;\n }", "idx": 22072}
{"hash": 6667142528452941476, "project": "debian", "size": 7, "label": 0, "functionSource": "static int switch_character_set_results ( MYSQL * mysql , const char * cs_name ) {\n char query_buffer [ QUERY_LENGTH ] ;\n size_t query_length ;\n if ( ! server_supports_switching_charsets ) return FALSE ;\n query_length = my_snprintf ( query_buffer , sizeof ( query_buffer ) , \"SET SESSION character_set_results = '%s'\" , ( const char * ) cs_name ) ;\n return mysql_real_query ( mysql , query_buffer , query_length ) ;\n }", "idx": 22073}
{"hash": 3950861381020172342, "project": "debian", "size": 134, "label": 0, "functionSource": "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n const uint8_t * buf_end = avpkt -> data + avpkt -> size ;\n int buf_size = avpkt -> size ;\n AVFrame * const p = data ;\n uint8_t * ptr ;\n unsigned int offset ;\n int magic_num , endian ;\n int x , y , ret ;\n int w , h , stride , bits_per_color , descriptor , elements , target_packet_size , source_packet_size ;\n unsigned int rgbBuffer ;\n if ( avpkt -> size <= 1634 ) {\n av_log ( avctx , AV_LOG_ERROR , \"Packet too small for DPX header\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n magic_num = AV_RB32 ( buf ) ;\n buf += 4 ;\n if ( magic_num == AV_RL32 ( \"SDPX\" ) ) {\n endian = 0 ;\n }\n else if ( magic_num == AV_RB32 ( \"SDPX\" ) ) {\n endian = 1 ;\n }\n else {\n av_log ( avctx , AV_LOG_ERROR , \"DPX marker not found\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n offset = read32 ( & buf , endian ) ;\n if ( avpkt -> size <= offset ) {\n av_log ( avctx , AV_LOG_ERROR , \"Invalid data start offset\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n buf = avpkt -> data + 0x304 ;\n w = read32 ( & buf , endian ) ;\n h = read32 ( & buf , endian ) ;\n buf += 20 ;\n descriptor = buf [ 0 ] ;\n buf += 3 ;\n avctx -> bits_per_raw_sample = bits_per_color = buf [ 0 ] ;\n buf += 825 ;\n avctx -> sample_aspect_ratio . num = read32 ( & buf , endian ) ;\n avctx -> sample_aspect_ratio . den = read32 ( & buf , endian ) ;\n switch ( descriptor ) {\n case 51 : elements = 4 ;\n break ;\n case 50 : elements = 3 ;\n break ;\n default : av_log ( avctx , AV_LOG_ERROR , \"Unsupported descriptor %d\\n\" , descriptor ) ;\n return AVERROR_INVALIDDATA ;\n }\n switch ( bits_per_color ) {\n case 8 : if ( elements == 4 ) {\n avctx -> pix_fmt = AV_PIX_FMT_RGBA ;\n }\n else {\n avctx -> pix_fmt = AV_PIX_FMT_RGB24 ;\n }\n source_packet_size = elements ;\n target_packet_size = elements ;\n break ;\n case 10 : avctx -> pix_fmt = AV_PIX_FMT_RGB48 ;\n target_packet_size = 6 ;\n source_packet_size = 4 ;\n break ;\n case 12 : case 16 : if ( endian ) {\n avctx -> pix_fmt = AV_PIX_FMT_RGB48BE ;\n }\n else {\n avctx -> pix_fmt = AV_PIX_FMT_RGB48LE ;\n }\n target_packet_size = 6 ;\n source_packet_size = elements * 2 ;\n break ;\n default : av_log ( avctx , AV_LOG_ERROR , \"Unsupported color depth : %d\\n\" , bits_per_color ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( ( ret = av_image_check_size ( w , h , 0 , avctx ) ) < 0 ) return ret ;\n if ( w != avctx -> width || h != avctx -> height ) avcodec_set_dimensions ( avctx , w , h ) ;\n if ( ( ret = ff_get_buffer ( avctx , p , 0 ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n buf = avpkt -> data + offset ;\n ptr = p -> data [ 0 ] ;\n stride = p -> linesize [ 0 ] ;\n if ( source_packet_size * avctx -> width * avctx -> height > buf_end - buf ) {\n av_log ( avctx , AV_LOG_ERROR , \"Overread buffer. Invalid header?\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n switch ( bits_per_color ) {\n case 10 : for ( x = 0 ;\n x < avctx -> height ;\n x ++ ) {\n uint16_t * dst = ( uint16_t * ) ptr ;\n for ( y = 0 ;\n y < avctx -> width ;\n y ++ ) {\n rgbBuffer = read32 ( & buf , endian ) ;\n * dst ++ = make_16bit ( rgbBuffer >> 16 ) ;\n * dst ++ = make_16bit ( rgbBuffer >> 6 ) ;\n * dst ++ = make_16bit ( rgbBuffer << 4 ) ;\n }\n ptr += stride ;\n }\n break ;\n case 8 : case 12 : case 16 : if ( source_packet_size == target_packet_size ) {\n for ( x = 0 ;\n x < avctx -> height ;\n x ++ ) {\n memcpy ( ptr , buf , target_packet_size * avctx -> width ) ;\n ptr += stride ;\n buf += source_packet_size * avctx -> width ;\n }\n }\n else {\n for ( x = 0 ;\n x < avctx -> height ;\n x ++ ) {\n uint8_t * dst = ptr ;\n for ( y = 0 ;\n y < avctx -> width ;\n y ++ ) {\n memcpy ( dst , buf , target_packet_size ) ;\n dst += target_packet_size ;\n buf += source_packet_size ;\n }\n ptr += stride ;\n }\n }\n break ;\n }\n * got_frame = 1 ;\n return buf_size ;\n }", "idx": 22074}
{"hash": -1672864273235910388, "project": "debian", "size": 50, "label": 0, "functionSource": "static void _build_alloc_msg ( struct job_record * job_ptr , resource_allocation_response_msg_t * alloc_msg , int error_code , char * job_submit_user_msg ) {\n int i ;\n memset ( alloc_msg , 0 , sizeof ( resource_allocation_response_msg_t ) ) ;\n if ( job_ptr -> job_resrcs && job_ptr -> job_resrcs -> cpu_array_cnt ) {\n alloc_msg -> num_cpu_groups = job_ptr -> job_resrcs -> cpu_array_cnt ;\n alloc_msg -> cpu_count_reps = xmalloc ( sizeof ( uint32_t ) * job_ptr -> job_resrcs -> cpu_array_cnt ) ;\n memcpy ( alloc_msg -> cpu_count_reps , job_ptr -> job_resrcs -> cpu_array_reps , ( sizeof ( uint32_t ) * job_ptr -> job_resrcs -> cpu_array_cnt ) ) ;\n alloc_msg -> cpus_per_node = xmalloc ( sizeof ( uint16_t ) * job_ptr -> job_resrcs -> cpu_array_cnt ) ;\n memcpy ( alloc_msg -> cpus_per_node , job_ptr -> job_resrcs -> cpu_array_value , ( sizeof ( uint16_t ) * job_ptr -> job_resrcs -> cpu_array_cnt ) ) ;\n }\n alloc_msg -> error_code = error_code ;\n alloc_msg -> job_submit_user_msg = xstrdup ( job_submit_user_msg ) ;\n alloc_msg -> job_id = job_ptr -> job_id ;\n alloc_msg -> node_cnt = job_ptr -> node_cnt ;\n alloc_msg -> node_list = xstrdup ( job_ptr -> nodes ) ;\n alloc_msg -> partition = xstrdup ( job_ptr -> partition ) ;\n alloc_msg -> alias_list = xstrdup ( job_ptr -> alias_list ) ;\n alloc_msg -> select_jobinfo = select_g_select_jobinfo_copy ( job_ptr -> select_jobinfo ) ;\n if ( job_ptr -> details ) {\n alloc_msg -> pn_min_memory = job_ptr -> details -> pn_min_memory ;\n if ( job_ptr -> details -> mc_ptr ) {\n alloc_msg -> ntasks_per_board = job_ptr -> details -> mc_ptr -> ntasks_per_board ;\n alloc_msg -> ntasks_per_core = job_ptr -> details -> mc_ptr -> ntasks_per_core ;\n alloc_msg -> ntasks_per_socket = job_ptr -> details -> mc_ptr -> ntasks_per_socket ;\n }\n if ( job_ptr -> details -> env_cnt ) {\n alloc_msg -> env_size = job_ptr -> details -> env_cnt ;\n alloc_msg -> environment = xmalloc ( sizeof ( char * ) * alloc_msg -> env_size ) ;\n for ( i = 0 ;\n i < alloc_msg -> env_size ;\n i ++ ) {\n alloc_msg -> environment [ i ] = xstrdup ( job_ptr -> details -> env_sup [ i ] ) ;\n }\n }\n }\n else {\n alloc_msg -> pn_min_memory = 0 ;\n alloc_msg -> ntasks_per_board = NO_VAL16 ;\n alloc_msg -> ntasks_per_core = NO_VAL16 ;\n alloc_msg -> ntasks_per_socket = NO_VAL16 ;\n }\n if ( job_ptr -> account ) alloc_msg -> account = xstrdup ( job_ptr -> account ) ;\n if ( job_ptr -> qos_ptr ) {\n slurmdb_qos_rec_t * qos ;\n qos = ( slurmdb_qos_rec_t * ) job_ptr -> qos_ptr ;\n alloc_msg -> qos = xstrdup ( qos -> name ) ;\n }\n if ( job_ptr -> resv_name ) alloc_msg -> resv_name = xstrdup ( job_ptr -> resv_name ) ;\n set_remote_working_response ( alloc_msg , job_ptr , job_ptr -> origin_cluster ) ;\n }", "idx": 22075}
{"hash": 5397012298191038220, "project": "chrome", "size": 3, "label": 0, "functionSource": "bool matchesOrigin ( const url : : Origin & origin , const GURL & url ) {\n return origin . IsSameOriginWith ( url : : Origin ( url ) ) ;\n }", "idx": 22076}
{"hash": -8228664527580018723, "project": "debian", "size": 8, "label": 0, "functionSource": "int curl_msnprintf ( char * buffer , size_t maxlength , const char * format , ... ) {\n int retcode ;\n va_list ap_save ;\n va_start ( ap_save , format ) ;\n retcode = curl_mvsnprintf ( buffer , maxlength , format , ap_save ) ;\n va_end ( ap_save ) ;\n return retcode ;\n }", "idx": 22077}
{"hash": -3583911607183901019, "project": "debian", "size": 7, "label": 0, "functionSource": "static void fail ( const char * format , ... ) {\n va_list arg_ptr ;\n va_start ( arg_ptr , format ) ;\n vfprintf ( stderr , format , arg_ptr ) ;\n va_end ( arg_ptr ) ;\n error_count ++ ;\n }", "idx": 22078}
{"hash": 7424930167238097621, "project": "debian", "size": 9, "label": 0, "functionSource": "static int proc_setintf ( struct usb_dev_state * ps , void __user * arg ) {\n struct usbdevfs_setinterface setintf ;\n int ret ;\n if ( copy_from_user ( & setintf , arg , sizeof ( setintf ) ) ) return - EFAULT ;\n ret = checkintf ( ps , setintf . interface ) ;\n if ( ret ) return ret ;\n destroy_async_on_interface ( ps , setintf . interface ) ;\n return usb_set_interface ( ps -> dev , setintf . interface , setintf . altsetting ) ;\n }", "idx": 22079}
{"hash": 3887066622454352196, "project": "chrome", "size": 51, "label": 0, "functionSource": "static int64_t encode_inter_mb_segment ( VP9_COMP * cpi , MACROBLOCK * x , int64_t best_yrd , int i , int * labelyrate , int64_t * distortion , int64_t * sse , ENTROPY_CONTEXT * ta , ENTROPY_CONTEXT * tl , int mi_row , int mi_col ) {\n int k ;\n MACROBLOCKD * xd = & x -> e_mbd ;\n struct macroblockd_plane * const pd = & xd -> plane [ 0 ] ;\n struct macroblock_plane * const p = & x -> plane [ 0 ] ;\n MODE_INFO * const mi = xd -> mi [ 0 ] . src_mi ;\n const BLOCK_SIZE plane_bsize = get_plane_block_size ( mi -> mbmi . sb_type , pd ) ;\n const int width = 4 * num_4x4_blocks_wide_lookup [ plane_bsize ] ;\n const int height = 4 * num_4x4_blocks_high_lookup [ plane_bsize ] ;\n int idx , idy ;\n const uint8_t * const src = & p -> src . buf [ raster_block_offset ( BLOCK_8X8 , i , p -> src . stride ) ] ;\n uint8_t * const dst = & pd -> dst . buf [ raster_block_offset ( BLOCK_8X8 , i , pd -> dst . stride ) ] ;\n int64_t thisdistortion = 0 , thissse = 0 ;\n int thisrate = 0 , ref ;\n const scan_order * so = & vp9_default_scan_orders [ TX_4X4 ] ;\n const int is_compound = has_second_ref ( & mi -> mbmi ) ;\n const InterpKernel * kernel = vp9_get_interp_kernel ( mi -> mbmi . interp_filter ) ;\n for ( ref = 0 ;\n ref < 1 + is_compound ;\n ++ ref ) {\n const uint8_t * pre = & pd -> pre [ ref ] . buf [ raster_block_offset ( BLOCK_8X8 , i , pd -> pre [ ref ] . stride ) ] ;\n vp9_build_inter_predictor ( pre , pd -> pre [ ref ] . stride , dst , pd -> dst . stride , & mi -> bmi [ i ] . as_mv [ ref ] . as_mv , & xd -> block_refs [ ref ] -> sf , width , height , ref , kernel , MV_PRECISION_Q3 , mi_col * MI_SIZE + 4 * ( i % 2 ) , mi_row * MI_SIZE + 4 * ( i / 2 ) ) ;\n }\n vp9_subtract_block ( height , width , raster_block_offset_int16 ( BLOCK_8X8 , i , p -> src_diff ) , 8 , src , p -> src . stride , dst , pd -> dst . stride ) ;\n k = i ;\n for ( idy = 0 ;\n idy < height / 4 ;\n ++ idy ) {\n for ( idx = 0 ;\n idx < width / 4 ;\n ++ idx ) {\n int64_t ssz , rd , rd1 , rd2 ;\n tran_low_t * coeff ;\n k += ( idy * 2 + idx ) ;\n coeff = BLOCK_OFFSET ( p -> coeff , k ) ;\n x -> fwd_txm4x4 ( raster_block_offset_int16 ( BLOCK_8X8 , k , p -> src_diff ) , coeff , 8 ) ;\n vp9_regular_quantize_b_4x4 ( x , 0 , k , so -> scan , so -> iscan ) ;\n thisdistortion += vp9_block_error ( coeff , BLOCK_OFFSET ( pd -> dqcoeff , k ) , 16 , & ssz ) ;\n thissse += ssz ;\n thisrate += cost_coeffs ( x , 0 , k , ta + ( k & 1 ) , tl + ( k >> 1 ) , TX_4X4 , so -> scan , so -> neighbors , cpi -> sf . use_fast_coef_costing ) ;\n rd1 = RDCOST ( x -> rdmult , x -> rddiv , thisrate , thisdistortion >> 2 ) ;\n rd2 = RDCOST ( x -> rdmult , x -> rddiv , 0 , thissse >> 2 ) ;\n rd = MIN ( rd1 , rd2 ) ;\n if ( rd >= best_yrd ) return INT64_MAX ;\n }\n }\n * distortion = thisdistortion >> 2 ;\n * labelyrate = thisrate ;\n * sse = thissse >> 2 ;\n return RDCOST ( x -> rdmult , x -> rddiv , * labelyrate , * distortion ) ;\n }", "idx": 22080}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_T_v76wCompression ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_T_v76wCompression , T_v76wCompression_choice , NULL ) ;\n return offset ;\n }", "idx": 22081}
{"hash": 8484475213808847345, "project": "debian", "size": 3, "label": 0, "functionSource": "void do_info_qtree ( Monitor * mon ) {\n if ( main_system_bus ) qbus_print ( mon , main_system_bus , 0 ) ;\n }", "idx": 22082}
{"hash": 6323824267898511453, "project": "debian", "size": 6, "label": 0, "functionSource": "void fz_set_default_gray ( fz_context * ctx , fz_default_colorspaces * default_cs , fz_colorspace * cs ) {\n if ( cs -> n == 1 ) {\n fz_drop_colorspace ( ctx , default_cs -> gray ) ;\n default_cs -> gray = fz_keep_colorspace ( ctx , cs ) ;\n }\n }", "idx": 22083}
{"hash": -5004587816582723841, "project": "chrome", "size": 3, "label": 0, "functionSource": "bool HasPendingUncleanExit ( Profile * profile ) {\n return profile -> GetLastSessionExitType ( ) == Profile : : EXIT_CRASHED && ! profile_launch_observer . Get ( ) . HasBeenLaunched ( profile ) ;\n }", "idx": 22084}
{"hash": -5992472514718425579, "project": "debian", "size": 38, "label": 0, "functionSource": "static int handle_cgroup_settings ( struct cgroup_mount_point * mp , char * cgroup_path ) {\n int r , saved_errno = 0 ;\n char buf [ 2 ] ;\n mp -> need_cpuset_init = false ;\n if ( lxc_string_in_array ( \"memory\" , ( const char * * ) mp -> hierarchy -> subsystems ) ) {\n char * cc_path = cgroup_to_absolute_path ( mp , cgroup_path , \"/memory.use_hierarchy\" ) ;\n if ( cc_path ) {\n r = lxc_read_from_file ( cc_path , buf , 1 ) ;\n if ( r < 1 || buf [ 0 ] != '1' ) {\n r = lxc_write_to_file ( cc_path , \"1\" , 1 , false ) ;\n if ( r < 0 ) SYSERROR ( \"failed to set memory.use_hierarchy to 1;\n continuing\" ) ;\n }\n free ( cc_path ) ;\n }\n }\n if ( lxc_string_in_array ( \"cpuset\" , ( const char * * ) mp -> hierarchy -> subsystems ) ) {\n char * cc_path = cgroup_to_absolute_path ( mp , cgroup_path , \"/cgroup.clone_children\" ) ;\n struct stat sb ;\n if ( ! cc_path ) return - 1 ;\n if ( stat ( cc_path , & sb ) != 0 && errno == ENOENT ) {\n mp -> need_cpuset_init = true ;\n free ( cc_path ) ;\n return 0 ;\n }\n r = lxc_read_from_file ( cc_path , buf , 1 ) ;\n if ( r == 1 && buf [ 0 ] == '1' ) {\n free ( cc_path ) ;\n return 0 ;\n }\n r = lxc_write_to_file ( cc_path , \"1\" , 1 , false ) ;\n saved_errno = errno ;\n free ( cc_path ) ;\n errno = saved_errno ;\n return r < 0 ? - 1 : 0 ;\n }\n return 0 ;\n }", "idx": 22085}
{"hash": -5082285935423529157, "project": "debian", "size": 14, "label": 0, "functionSource": "static int dissect_rsl_ie_meas_res_no ( tvbuff_t * tvb , packet_info * pinfo _U_ , proto_tree * tree , int offset , gboolean is_mandatory ) {\n proto_tree * ie_tree ;\n guint8 ie_id ;\n if ( is_mandatory == FALSE ) {\n ie_id = tvb_get_guint8 ( tvb , offset ) ;\n if ( ie_id != RSL_IE_MEAS_RES_NO ) return offset ;\n }\n ie_tree = proto_tree_add_subtree ( tree , tvb , offset , 2 , ett_ie_meas_res_no , NULL , \"Measurement result number IE\" ) ;\n proto_tree_add_item ( ie_tree , hf_rsl_ie_id , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n offset ++ ;\n proto_tree_add_item ( ie_tree , hf_rsl_meas_res_no , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n offset ++ ;\n return offset ;\n }", "idx": 22086}
{"hash": -3405049855481807624, "project": "chrome", "size": 3, "label": 0, "functionSource": "int xmlIsBaseChar ( unsigned int ch ) {\n return ( xmlIsBaseCharQ ( ch ) ) ;\n }", "idx": 22087}
{"hash": 3309252579593081468, "project": "debian", "size": 51, "label": 0, "functionSource": "int nntp_post ( const char * msg ) {\n struct NntpData * nntp_data , nntp_tmp ;\n char buf [ LONG_STRING ] ;\n if ( Context && Context -> magic == MUTT_NNTP ) nntp_data = Context -> data ;\n else {\n CurrentNewsSrv = nntp_select_server ( NewsServer , false ) ;\n if ( ! CurrentNewsSrv ) return - 1 ;\n nntp_data = & nntp_tmp ;\n nntp_data -> nserv = CurrentNewsSrv ;\n nntp_data -> group = NULL ;\n }\n FILE * fp = mutt_file_fopen ( msg , \"r\" ) ;\n if ( ! fp ) {\n mutt_perror ( msg ) ;\n return - 1 ;\n }\n mutt_str_strfcpy ( buf , \"POST\\r\\n\" , sizeof ( buf ) ) ;\n if ( nntp_query ( nntp_data , buf , sizeof ( buf ) ) < 0 ) {\n mutt_file_fclose ( & fp ) ;\n return - 1 ;\n }\n if ( buf [ 0 ] != '3' ) {\n mutt_error ( _ ( \"Can't post article: %s\" ) , buf ) ;\n mutt_file_fclose ( & fp ) ;\n return - 1 ;\n }\n buf [ 0 ] = '.' ;\n buf [ 1 ] = '\\0' ;\n while ( fgets ( buf + 1 , sizeof ( buf ) - 2 , fp ) ) {\n size_t len = strlen ( buf ) ;\n if ( buf [ len - 1 ] == '\\n' ) {\n buf [ len - 1 ] = '\\r' ;\n buf [ len ] = '\\n' ;\n len ++ ;\n buf [ len ] = '\\0' ;\n }\n if ( mutt_socket_send_d ( nntp_data -> nserv -> conn , buf [ 1 ] == '.' ? buf : buf + 1 , MUTT_SOCK_LOG_HDR ) < 0 ) {\n mutt_file_fclose ( & fp ) ;\n return nntp_connect_error ( nntp_data -> nserv ) ;\n }\n }\n mutt_file_fclose ( & fp ) ;\n if ( ( buf [ strlen ( buf ) - 1 ] != '\\n' && mutt_socket_send_d ( nntp_data -> nserv -> conn , \"\\r\\n\" , MUTT_SOCK_LOG_HDR ) < 0 ) || mutt_socket_send_d ( nntp_data -> nserv -> conn , \".\\r\\n\" , MUTT_SOCK_LOG_HDR ) < 0 || mutt_socket_readln ( buf , sizeof ( buf ) , nntp_data -> nserv -> conn ) < 0 ) {\n return nntp_connect_error ( nntp_data -> nserv ) ;\n }\n if ( buf [ 0 ] != '2' ) {\n mutt_error ( _ ( \"Can't post article: %s\" ) , buf ) ;\n return - 1 ;\n }\n return 0 ;\n }", "idx": 22088}
{"hash": -6024601983167898950, "project": "debian", "size": 21, "label": 0, "functionSource": "static gboolean confirm_multiple_windows ( GtkWindow * parent_window , int count , gboolean use_tabs ) {\n GtkDialog * dialog ;\n char * prompt ;\n char * detail ;\n int response ;\n if ( count <= SILENT_WINDOW_OPEN_LIMIT ) {\n return TRUE ;\n }\n prompt = _ ( \"Are you sure you want to open all files?\" ) ;\n if ( use_tabs ) {\n detail = g_strdup_printf ( ngettext ( \"This will open %d separate tab.\" , \"This will open %d separate tabs.\" , count ) , count ) ;\n }\n else {\n detail = g_strdup_printf ( ngettext ( \"This will open %d separate window.\" , \"This will open %d separate windows.\" , count ) , count ) ;\n }\n dialog = eel_show_yes_no_dialog ( prompt , detail , _ ( \"_OK\" ) , _ ( \"_Cancel\" ) , parent_window ) ;\n g_free ( detail ) ;\n response = gtk_dialog_run ( dialog ) ;\n gtk_widget_destroy ( GTK_WIDGET ( dialog ) ) ;\n return response == GTK_RESPONSE_YES ;\n }", "idx": 22089}
{"hash": -954364585377557207, "project": "debian", "size": 18, "label": 0, "functionSource": "static void lsf2lsp_5 ( AMRContext * p ) {\n const uint16_t * lsf_param = p -> frame . lsf ;\n float lsf_no_r [ LP_FILTER_ORDER ] ;\n const int16_t * lsf_quantizer [ 5 ] ;\n int i ;\n lsf_quantizer [ 0 ] = lsf_5_1 [ lsf_param [ 0 ] ] ;\n lsf_quantizer [ 1 ] = lsf_5_2 [ lsf_param [ 1 ] ] ;\n lsf_quantizer [ 2 ] = lsf_5_3 [ lsf_param [ 2 ] >> 1 ] ;\n lsf_quantizer [ 3 ] = lsf_5_4 [ lsf_param [ 3 ] ] ;\n lsf_quantizer [ 4 ] = lsf_5_5 [ lsf_param [ 4 ] ] ;\n for ( i = 0 ;\n i < LP_FILTER_ORDER ;\n i ++ ) lsf_no_r [ i ] = p -> prev_lsf_r [ i ] * LSF_R_FAC * PRED_FAC_MODE_12k2 + lsf_5_mean [ i ] ;\n lsf2lsp_for_mode12k2 ( p , p -> lsp [ 1 ] , lsf_no_r , lsf_quantizer , 0 , lsf_param [ 2 ] & 1 , 0 ) ;\n lsf2lsp_for_mode12k2 ( p , p -> lsp [ 3 ] , lsf_no_r , lsf_quantizer , 2 , lsf_param [ 2 ] & 1 , 1 ) ;\n weighted_vector_sumd ( p -> lsp [ 0 ] , p -> prev_lsp_sub4 , p -> lsp [ 1 ] , 0.5 , 0.5 , LP_FILTER_ORDER ) ;\n weighted_vector_sumd ( p -> lsp [ 2 ] , p -> lsp [ 1 ] , p -> lsp [ 3 ] , 0.5 , 0.5 , LP_FILTER_ORDER ) ;\n }", "idx": 22090}
{"hash": 8460430819945784394, "project": "debian", "size": 7, "label": 0, "functionSource": "static uint32_t PPC_io_readb ( target_phys_addr_t addr ) {\n uint32_t ret = cpu_inb ( NULL , addr - PPC_IO_BASE ) ;\n # if 0 if ( ( addr < 0x800003F0 || addr > 0x80000400 ) && ( addr < 0x80000074 || addr > 0x80000077 ) && ( addr < 0x80000020 || addr > 0x80000021 ) && ( addr < 0x800000a0 || addr > 0x800000a1 ) && ( addr < 0x800001f0 || addr > 0x800001f7 ) && ( addr < 0x80000170 || addr > 0x80000177 ) && ( addr < 0x8000060 || addr > 0x8000064 ) ) # endif {\n PPC_IO_DPRINTF ( \"0x%08x <= 0x%02x\\n\" , addr - PPC_IO_BASE , ret ) ;\n }\n return ret ;\n }", "idx": 22091}
{"hash": 5498422609764865307, "project": "debian", "size": 4, "label": 0, "functionSource": "static int compress_bidder_free ( struct archive_read_filter_bidder * self ) {\n self -> data = NULL ;\n return ( ARCHIVE_OK ) ;\n }", "idx": 22092}
{"hash": 58020529414140129, "project": "chrome", "size": 13, "label": 0, "functionSource": "static void calc_segtree_probs ( int * segcounts , vp9_prob * segment_tree_probs ) {\n const int c01 = segcounts [ 0 ] + segcounts [ 1 ] ;\n const int c23 = segcounts [ 2 ] + segcounts [ 3 ] ;\n const int c45 = segcounts [ 4 ] + segcounts [ 5 ] ;\n const int c67 = segcounts [ 6 ] + segcounts [ 7 ] ;\n segment_tree_probs [ 0 ] = get_binary_prob ( c01 + c23 , c45 + c67 ) ;\n segment_tree_probs [ 1 ] = get_binary_prob ( c01 , c23 ) ;\n segment_tree_probs [ 2 ] = get_binary_prob ( c45 , c67 ) ;\n segment_tree_probs [ 3 ] = get_binary_prob ( segcounts [ 0 ] , segcounts [ 1 ] ) ;\n segment_tree_probs [ 4 ] = get_binary_prob ( segcounts [ 2 ] , segcounts [ 3 ] ) ;\n segment_tree_probs [ 5 ] = get_binary_prob ( segcounts [ 4 ] , segcounts [ 5 ] ) ;\n segment_tree_probs [ 6 ] = get_binary_prob ( segcounts [ 6 ] , segcounts [ 7 ] ) ;\n }", "idx": 22093}
{"hash": -2325305888478261876, "project": "debian", "size": 4, "label": 0, "functionSource": "int tm_notify ( int tm_signal ) {\n if ( ! init_done ) return TM_BADINIT ;\n return TM_ENOTIMPLEMENTED ;\n }", "idx": 22094}
{"hash": -7455544248455991006, "project": "debian", "size": 4, "label": 0, "functionSource": "static bool kvm_x2apic_api_set_flags ( uint64_t flags ) {\n KVMState * s = KVM_STATE ( current_machine -> accelerator ) ;\n return ! kvm_vm_enable_cap ( s , KVM_CAP_X2APIC_API , 0 , flags ) ;\n }", "idx": 22095}
{"hash": 6336384260629386331, "project": "debian", "size": 171, "label": 0, "functionSource": "void proto_register_zbee_zcl_pwr_prof ( void ) {\n guint i , j ;\n static hf_register_info hf [ ] = {\n {\n & hf_zbee_zcl_pwr_prof_tot_prof_num , {\n \"Total Profile Number\" , \"zbee_zcl_general.pwrprof.attr.totprofnum\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_zbee_zcl_pwr_prof_multiple_sched , {\n \"Multiple Scheduling\" , \"zbee_zcl_general.pwrprof.attr.multiplesched\" , FT_BOOLEAN , BASE_NONE , TFS ( & tfs_supported_not_supported ) , 0x0 , NULL , HFILL }\n }\n , {\n & hf_zbee_zcl_pwr_prof_energy_format , {\n \"Data\" , \"zbee_zcl_general.pwrprof.attr.energyformat\" , FT_UINT8 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_zbee_zcl_pwr_prof_energy_format_rdigit , {\n \"Number of Digits to the right of the Decimal Point\" , \"zbee_zcl_general.pwrprof.attr.energyformat.rdigit\" , FT_UINT8 , BASE_DEC , NULL , ZBEE_ZCL_OPT_PWRPROF_NUM_R_DIGIT , NULL , HFILL }\n }\n , {\n & hf_zbee_zcl_pwr_prof_energy_format_ldigit , {\n \"Number of Digits to the left of the Decimal Point\" , \"zbee_zcl_general.pwrprof.attr.energyformat.ldigit\" , FT_UINT8 , BASE_DEC , NULL , ZBEE_ZCL_OPT_PWRPROF_NUM_L_DIGIT , NULL , HFILL }\n }\n , {\n & hf_zbee_zcl_pwr_prof_energy_format_noleadingzero , {\n \"Suppress leading zeros.\" , \"zbee_zcl_general.pwrprof.attr.energyformat.noleadingzero\" , FT_BOOLEAN , 8 , TFS ( & tfs_true_false ) , ZBEE_ZCL_OPT_PWRPROF_NO_LEADING_ZERO , NULL , HFILL }\n }\n , {\n & hf_zbee_zcl_pwr_prof_energy_remote , {\n \"Energy Remote\" , \"zbee_zcl_general.pwrprof.attr.energyremote\" , FT_BOOLEAN , BASE_NONE , TFS ( & tfs_enabled_disabled ) , 0x0 , NULL , HFILL }\n }\n , {\n & hf_zbee_zcl_pwr_prof_sched_mode , {\n \"Schedule Mode\" , \"zbee_zcl_general.pwrprof.attr.schedmode\" , FT_UINT8 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_zbee_zcl_pwr_prof_sched_mode_cheapest , {\n \"Schedule Mode Cheapest\" , \"zbee_zcl_general.pwrprof.attr.schedmode.cheapest\" , FT_BOOLEAN , 8 , TFS ( & tfs_active_inactive ) , ZBEE_ZCL_OPT_PWRPROF_SCHED_CHEAPEST , NULL , HFILL }\n }\n , {\n & hf_zbee_zcl_pwr_prof_sched_mode_greenest , {\n \"Schedule Mode Greenest\" , \"zbee_zcl_general.pwrprof.attr.schedmode.greenest\" , FT_BOOLEAN , 8 , TFS ( & tfs_active_inactive ) , ZBEE_ZCL_OPT_PWRPROF_SCHED_GREENEST , NULL , HFILL }\n }\n , {\n & hf_zbee_zcl_pwr_prof_sched_mode_reserved , {\n \"Schedule Mode Reserved\" , \"zbee_zcl_general.pwrprof.attr.schedmode.reserved\" , FT_UINT8 , BASE_HEX , NULL , ZBEE_ZCL_OPT_PWRPROF_SCHED_RESERVED , NULL , HFILL }\n }\n , {\n & hf_zbee_zcl_pwr_prof_attr_id , {\n \"Attribute\" , \"zbee_zcl_general.pwrprof.attr_id\" , FT_UINT16 , BASE_HEX , VALS ( zbee_zcl_pwr_prof_attr_names ) , 0x0 , NULL , HFILL }\n }\n , {\n & hf_zbee_zcl_pwr_prof_srv_tx_cmd_id , {\n \"Command\" , \"zbee_zcl_general.pwrprof.cmd.srv_tx.id\" , FT_UINT8 , BASE_HEX , VALS ( zbee_zcl_pwr_prof_srv_tx_cmd_names ) , 0x0 , NULL , HFILL }\n }\n , {\n & hf_zbee_zcl_pwr_prof_srv_rx_cmd_id , {\n \"Command\" , \"zbee_zcl_general.pwrprof.cmd.srv_rx.id\" , FT_UINT8 , BASE_HEX , VALS ( zbee_zcl_pwr_prof_srv_rx_cmd_names ) , 0x0 , NULL , HFILL }\n }\n , {\n & hf_zbee_zcl_pwr_prof_pwr_prof_id , {\n \"Power Profile ID\" , \"zbee_zcl_general.pwrprof.pwrprofid\" , FT_UINT8 , BASE_CUSTOM , CF_FUNC ( decode_power_profile_id ) , 0x00 , \"Identifier of the specific profile\" , HFILL }\n }\n , {\n & hf_zbee_zcl_pwr_prof_currency , {\n \"Currency\" , \"zbee_zcl_general.pwrprof.currency\" , FT_UINT16 , BASE_HEX , VALS ( zbee_zcl_currecy_names ) , 0x0 , \"Local unit of currency (ISO 4217) used in the price field.\" , HFILL }\n }\n , {\n & hf_zbee_zcl_pwr_prof_price , {\n \"Price\" , \"zbee_zcl_general.pwrprof.price\" , FT_UINT32 , BASE_CUSTOM , CF_FUNC ( decode_price_in_cents ) , 0x0 , \"Price of the energy of a specific Power Profile.\" , HFILL }\n }\n , {\n & hf_zbee_zcl_pwr_prof_price_trailing_digit , {\n \"Price Trailing Digit\" , \"zbee_zcl_general.pwrprof.pricetrailingdigit\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , \"Number of digits to the right of the decimal point.\" , HFILL }\n }\n , {\n & hf_zbee_zcl_pwr_prof_num_of_sched_phases , {\n \"Number of Scheduled Phases\" , \"zbee_zcl_general.pwrprof.numofschedphases\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , \"Total number of the energy phases of the Power Profile that need to be scheduled.\" , HFILL }\n }\n , {\n & hf_zbee_zcl_pwr_prof_energy_phase_id , {\n \"Energy Phase ID\" , \"zbee_zcl_general.pwrprof.energyphaseid\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , \"Identifier of the specific phase.\" , HFILL }\n }\n , {\n & hf_zbee_zcl_pwr_prof_scheduled_time , {\n \"Scheduled Time\" , \"zbee_zcl_general.pwrprof.scheduledtime\" , FT_UINT16 , BASE_CUSTOM , CF_FUNC ( decode_zcl_time_in_minutes ) , 0x0 , NULL , HFILL }\n }\n , {\n & hf_zbee_zcl_pwr_prof_macro_phase_id , {\n \"Macro Phase ID\" , \"zbee_zcl_general.pwrprof.macrophaseid\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , \"Identifier of the specific energy phase.\" , HFILL }\n }\n , {\n & hf_zbee_zcl_pwr_prof_expect_duration , {\n \"Expected Duration\" , \"zbee_zcl_general.pwrprof.expecduration\" , FT_UINT16 , BASE_CUSTOM , CF_FUNC ( decode_zcl_time_in_minutes ) , 0x0 , \"The estimated duration of the specific phase.\" , HFILL }\n }\n , {\n & hf_zbee_zcl_pwr_prof_num_of_trans_phases , {\n \"Number of Transferred Phases\" , \"zbee_zcl_general.pwrprof.numoftransphases\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_zbee_zcl_pwr_prof_peak_power , {\n \"Peak Power\" , \"zbee_zcl_general.pwrprof.peakpower\" , FT_UINT16 , BASE_CUSTOM , CF_FUNC ( decode_power_in_watt ) , 0x0 , \"The estimated power for the specific phase.\" , HFILL }\n }\n , {\n & hf_zbee_zcl_pwr_prof_energy , {\n \"Energy\" , \"zbee_zcl_general.pwrprof.energy\" , FT_UINT16 , BASE_CUSTOM , CF_FUNC ( decode_energy ) , 0x0 , \"The estimated energy consumption for the accounted phase.\" , HFILL }\n }\n , {\n & hf_zbee_zcl_pwr_prof_max_active_delay , {\n \"Max Activation Delay\" , \"zbee_zcl_general.pwrprof.maxactivdelay\" , FT_UINT16 , BASE_CUSTOM , CF_FUNC ( func_decode_delayinminute ) , 0x0 , \"The maximum interruption time between the end of the previous phase and the beginning of the specific phase.\" , HFILL }\n }\n , {\n & hf_zbee_zcl_pwr_prof_pwr_prof_count , {\n \"Power Profile Count\" , \"zbee_zcl_general.pwrprof.pwrprofcount\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_zbee_zcl_pwr_prof_pwr_prof_rem_ctrl , {\n \"Power Profile Remote Control\" , \"zbee_zcl_general.pwrprof.pwrprofremctrl\" , FT_BOOLEAN , BASE_NONE , TFS ( & tfs_enabled_disabled ) , 0x00 , \"It indicates if the PowerProfile is currently remotely controllable or not.\" , HFILL }\n }\n , {\n & hf_zbee_zcl_pwr_prof_pwr_prof_state , {\n \"Power Profile State\" , \"zbee_zcl_general.pwrprof.pwrprofstate\" , FT_UINT8 , BASE_HEX , VALS ( zbee_zcl_pwr_prof_state_names ) , 0x0 , NULL , HFILL }\n }\n , {\n & hf_zbee_zcl_pwr_prof_start_after , {\n \"Start After\" , \"zbee_zcl_general.pwrprof.startafter\" , FT_UINT16 , BASE_CUSTOM , CF_FUNC ( decode_zcl_time_in_minutes ) , 0x0 , NULL , HFILL }\n }\n , {\n & hf_zbee_zcl_pwr_prof_stop_before , {\n \"Stop Before\" , \"zbee_zcl_general.pwrprof.stopbefore\" , FT_UINT16 , BASE_CUSTOM , CF_FUNC ( decode_zcl_time_in_minutes ) , 0x0 , NULL , HFILL }\n }\n , {\n & hf_zbee_zcl_pwr_prof_options , {\n \"Options\" , \"zbee_zcl_general.pwrprof.options\" , FT_UINT8 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_zbee_zcl_pwr_prof_options_01 , {\n \"PowerProfileStartTime Field Present\" , \"zbee_zcl_general.pwrprof.options.01\" , FT_BOOLEAN , 8 , TFS ( & tfs_true_false ) , ZBEE_ZCL_OPT_PWRPROF_STIME_PRESENT , NULL , HFILL }\n }\n , {\n & hf_zbee_zcl_pwr_prof_options_res , {\n \"Reserved\" , \"zbee_zcl_general.pwrprof.options.reserved\" , FT_UINT8 , BASE_HEX , NULL , ZBEE_ZCL_OPT_PWRPROF_RESERVED , NULL , HFILL }\n }\n , {\n & hf_zbee_zcl_pwr_prof_pwr_prof_stime , {\n \"Power Profile Start Time\" , \"zbee_zcl_general.pwrprof.pwrprofstime\" , FT_UINT16 , BASE_CUSTOM , CF_FUNC ( decode_zcl_time_in_minutes ) , 0x0 , NULL , HFILL }\n }\n }\n ;\n static gint * ett [ ZBEE_ZCL_PWR_PROF_NUM_ETT ] ;\n ett [ 0 ] = & ett_zbee_zcl_pwr_prof ;\n ett [ 1 ] = & ett_zbee_zcl_pwr_prof_options ;\n ett [ 2 ] = & ett_zbee_zcl_pwr_prof_en_format ;\n ett [ 3 ] = & ett_zbee_zcl_pwr_prof_sched_mode ;\n for ( i = 0 , j = ZBEE_ZCL_PWR_PROF_NUM_GENERIC_ETT ;\n i < ZBEE_ZCL_PWR_PROF_NUM_PWR_PROF_ETT ;\n i ++ , j ++ ) {\n ett_zbee_zcl_pwr_prof_pwrprofiles [ i ] = - 1 ;\n ett [ j ] = & ett_zbee_zcl_pwr_prof_pwrprofiles [ i ] ;\n }\n for ( i = 0 ;\n i < ZBEE_ZCL_PWR_PROF_NUM_EN_PHS_ETT ;\n i ++ , j ++ ) {\n ett_zbee_zcl_pwr_prof_enphases [ i ] = - 1 ;\n ett [ j ] = & ett_zbee_zcl_pwr_prof_enphases [ i ] ;\n }\n proto_zbee_zcl_pwr_prof = proto_register_protocol ( \"ZigBee ZCL Power Profile\" , \"ZCL Power Profile\" , ZBEE_PROTOABBREV_ZCL_PWRPROF ) ;\n proto_register_field_array ( proto_zbee_zcl_pwr_prof , hf , array_length ( hf ) ) ;\n proto_register_subtree_array ( ett , array_length ( ett ) ) ;\n register_dissector ( ZBEE_PROTOABBREV_ZCL_PWRPROF , dissect_zbee_zcl_pwr_prof , proto_zbee_zcl_pwr_prof ) ;\n }", "idx": 22096}
{"hash": 5045872831385413038, "project": "debian", "size": 8, "label": 0, "functionSource": "static int dissect_btgatt_microbit_accelerometer_period ( tvbuff_t * tvb , packet_info * pinfo _U_ , proto_tree * tree , void * data ) {\n btatt_data_t * att_data = ( btatt_data_t * ) data ;\n gint offset = 0 ;\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) return - 1 ;\n proto_tree_add_item ( tree , hf_gatt_microbit_accelerometer_period , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n return offset ;\n }", "idx": 22097}
{"hash": -398565394354770780, "project": "debian", "size": 21, "label": 0, "functionSource": "static void ohci_port_set_status ( OHCIState * ohci , int portnum , uint32_t val ) {\n uint32_t old_state ;\n OHCIPort * port ;\n port = & ohci -> rhport [ portnum ] ;\n old_state = port -> ctrl ;\n if ( val & OHCI_PORT_WTC ) port -> ctrl &= ~ ( val & OHCI_PORT_WTC ) ;\n if ( val & OHCI_PORT_CCS ) port -> ctrl &= ~ OHCI_PORT_PES ;\n ohci_port_set_if_connected ( ohci , portnum , val & OHCI_PORT_PES ) ;\n if ( ohci_port_set_if_connected ( ohci , portnum , val & OHCI_PORT_PSS ) ) {\n trace_usb_ohci_port_suspend ( portnum ) ;\n }\n if ( ohci_port_set_if_connected ( ohci , portnum , val & OHCI_PORT_PRS ) ) {\n trace_usb_ohci_port_reset ( portnum ) ;\n usb_device_reset ( port -> port . dev ) ;\n port -> ctrl &= ~ OHCI_PORT_PRS ;\n port -> ctrl |= OHCI_PORT_PES | OHCI_PORT_PRSC ;\n }\n if ( val & OHCI_PORT_LSDA ) ohci_port_power ( ohci , portnum , 0 ) ;\n if ( val & OHCI_PORT_PPS ) ohci_port_power ( ohci , portnum , 1 ) ;\n if ( old_state != port -> ctrl ) ohci_set_interrupt ( ohci , OHCI_INTR_RHSC ) ;\n }", "idx": 22098}
{"hash": 3584320764213684062, "project": "debian", "size": 26, "label": 0, "functionSource": "static const char * str_CBaseStorageVariant ( struct CBaseStorageVariant * value , gboolean print_type ) {\n wmem_strbuf_t * strbuf = wmem_strbuf_new ( wmem_packet_scope ( ) , \"\" ) ;\n if ( value == NULL ) {\n return \"<NULL>\" ;\n }\n if ( value -> type == NULL ) {\n return \"<??\" \"?>\" ;\n }\n if ( print_type ) {\n wmem_strbuf_append ( strbuf , value -> type -> str ) ;\n if ( value -> vType & 0xFF00 ) {\n wmem_strbuf_append_printf ( strbuf , \"[%d]\" , value -> vValue . vt_vector . len ) ;\n }\n wmem_strbuf_append ( strbuf , \": \" ) ;\n }\n switch ( value -> vType & 0xFF00 ) {\n case 0 : value -> type -> strbuf_append ( strbuf , & value -> vValue ) ;\n break ;\n case VT_ARRAY : vvalue_strbuf_append_vector ( strbuf , value -> vValue . vt_array . vData , value -> type ) ;\n break ;\n case VT_VECTOR : vvalue_strbuf_append_vector ( strbuf , value -> vValue . vt_vector , value -> type ) ;\n break ;\n default : wmem_strbuf_append ( strbuf , \"Invalid\" ) ;\n }\n return wmem_strbuf_get_str ( strbuf ) ;\n }", "idx": 22099}
{"hash": -1604848228542845191, "project": "debian", "size": 4, "label": 0, "functionSource": "static void flip ( AVCodecContext * avctx , AVPicture * picture ) {\n picture -> data [ 0 ] += picture -> linesize [ 0 ] * ( avctx -> height - 1 ) ;\n picture -> linesize [ 0 ] *= - 1 ;\n }", "idx": 22100}
{"hash": -7131177824150194183, "project": "debian", "size": 10, "label": 0, "functionSource": "static inline void put_pixels8x8_overlapped ( uint8_t * dst , uint8_t * src , int stride ) {\n uint8_t tmp [ 64 ] ;\n int i ;\n for ( i = 0 ;\n i < 8 ;\n i ++ ) memcpy ( tmp + i * 8 , src + i * stride , 8 ) ;\n for ( i = 0 ;\n i < 8 ;\n i ++ ) memcpy ( dst + i * stride , tmp + i * 8 , 8 ) ;\n }", "idx": 22101}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_T_rfc_number ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_constrained_integer ( tvb , offset , actx , tree , hf_index , 1U , 32768U , & rfc_number , TRUE ) ;\n return offset ;\n }", "idx": 22102}
{"hash": -5025430721469043309, "project": "debian", "size": 4, "label": 0, "functionSource": "static void version_check_doit ( void * a ) {\n struct version_check_args * args = ( struct version_check_args * ) a ;\n if ( _dl_check_all_versions ( GL ( dl_ns ) [ LM_ID_BASE ] . _ns_loaded , 1 , args -> dotrace ) && args -> doexit ) _exit ( 1 ) ;\n }", "idx": 22103}
{"hash": 2125998987781803371, "project": "debian", "size": 26, "label": 0, "functionSource": "static void SetVideoFormat ( decoder_t * p_dec ) {\n decoder_sys_t * p_sys = p_dec -> p_sys ;\n p_sys -> p_format = schro_decoder_get_video_format ( p_sys -> p_schro ) ;\n if ( p_sys -> p_format == NULL ) return ;\n p_sys -> i_frame_pts_delta = CLOCK_FREQ * p_sys -> p_format -> frame_rate_denominator / p_sys -> p_format -> frame_rate_numerator ;\n switch ( p_sys -> p_format -> chroma_format ) {\n case SCHRO_CHROMA_420 : p_dec -> fmt_out . i_codec = VLC_CODEC_I420 ;\n break ;\n case SCHRO_CHROMA_422 : p_dec -> fmt_out . i_codec = VLC_CODEC_I422 ;\n break ;\n case SCHRO_CHROMA_444 : p_dec -> fmt_out . i_codec = VLC_CODEC_I444 ;\n break ;\n default : p_dec -> fmt_out . i_codec = 0 ;\n break ;\n }\n p_dec -> fmt_out . video . i_visible_width = p_sys -> p_format -> clean_width ;\n p_dec -> fmt_out . video . i_x_offset = p_sys -> p_format -> left_offset ;\n p_dec -> fmt_out . video . i_width = p_sys -> p_format -> width ;\n p_dec -> fmt_out . video . i_visible_height = p_sys -> p_format -> clean_height ;\n p_dec -> fmt_out . video . i_y_offset = p_sys -> p_format -> top_offset ;\n p_dec -> fmt_out . video . i_height = p_sys -> p_format -> height ;\n p_dec -> fmt_out . video . i_sar_num = p_sys -> p_format -> aspect_ratio_numerator ;\n p_dec -> fmt_out . video . i_sar_den = p_sys -> p_format -> aspect_ratio_denominator ;\n p_dec -> fmt_out . video . i_frame_rate = p_sys -> p_format -> frame_rate_numerator ;\n p_dec -> fmt_out . video . i_frame_rate_base = p_sys -> p_format -> frame_rate_denominator ;\n }", "idx": 22104}
{"hash": -5493081488206619677, "project": "debian", "size": 9, "label": 0, "functionSource": "static const char * cmd_unicode_codepage ( cmd_parms * cmd , void * _dcfg , const char * p1 ) {\n long val ;\n val = atol ( p1 ) ;\n if ( val <= 0 ) {\n return apr_psprintf ( cmd -> pool , \"ModSecurity: Invalid setting for \" \"SecUnicodeCodePage: %s\" , p1 ) ;\n }\n unicode_codepage = ( unsigned long int ) val ;\n return NULL ;\n }", "idx": 22105}
{"hash": -1950979830238945732, "project": "debian", "size": 8, "label": 0, "functionSource": "static int stem_hint_handler ( void * client_data , gx_san_sect * ss ) {\n t1_hinter_aux * h = ( t1_hinter_aux * ) client_data ;\n if ( ss -> side_mask == 3 ) {\n if ( ss -> xl > h -> midx && h -> transpose ) return ( h -> transpose ? t1_hinter__hstem : t1_hinter__vstem ) ( & h -> super , ss -> xr , ss -> xl - ss -> xr ) ;\n else return ( h -> transpose ? t1_hinter__hstem : t1_hinter__vstem ) ( & h -> super , ss -> xl , ss -> xr - ss -> xl ) ;\n }\n else return t1_hinter__overall_hstem ( & h -> super , ss -> xl , ss -> xr - ss -> xl , ss -> side_mask ) ;\n }", "idx": 22106}
{"hash": -1929262071302712016, "project": "debian", "size": 51, "label": 0, "functionSource": "static cmsBool Type_Dictionary_Write ( struct _cms_typehandler_struct * self , cmsIOHANDLER * io , void * Ptr , cmsUInt32Number nItems ) {\n cmsHANDLE hDict = ( cmsHANDLE ) Ptr ;\n const cmsDICTentry * p ;\n cmsBool AnyName , AnyValue ;\n cmsUInt32Number i , Count , Length ;\n cmsUInt32Number DirectoryPos , CurrentPos , BaseOffset ;\n _cmsDICarray a ;\n if ( hDict == NULL ) return FALSE ;\n BaseOffset = io -> Tell ( io ) - sizeof ( _cmsTagBase ) ;\n Count = 0 ;\n AnyName = FALSE ;\n AnyValue = FALSE ;\n for ( p = cmsDictGetEntryList ( hDict ) ;\n p != NULL ;\n p = cmsDictNextEntry ( p ) ) {\n if ( p -> DisplayName != NULL ) AnyName = TRUE ;\n if ( p -> DisplayValue != NULL ) AnyValue = TRUE ;\n Count ++ ;\n }\n Length = 16 ;\n if ( AnyName ) Length += 8 ;\n if ( AnyValue ) Length += 8 ;\n if ( ! _cmsWriteUInt32Number ( io , Count ) ) return FALSE ;\n if ( ! _cmsWriteUInt32Number ( io , Length ) ) return FALSE ;\n DirectoryPos = io -> Tell ( io ) ;\n if ( ! AllocArray ( self -> ContextID , & a , Count , Length ) ) goto Error ;\n if ( ! WriteOffsetArray ( io , & a , Count , Length ) ) goto Error ;\n p = cmsDictGetEntryList ( hDict ) ;\n for ( i = 0 ;\n i < Count ;\n i ++ ) {\n if ( ! WriteOneWChar ( io , & a . Name , i , p -> Name , BaseOffset ) ) goto Error ;\n if ( ! WriteOneWChar ( io , & a . Value , i , p -> Value , BaseOffset ) ) goto Error ;\n if ( p -> DisplayName != NULL ) {\n if ( ! WriteOneMLUC ( self , io , & a . DisplayName , i , p -> DisplayName , BaseOffset ) ) goto Error ;\n }\n if ( p -> DisplayValue != NULL ) {\n if ( ! WriteOneMLUC ( self , io , & a . DisplayValue , i , p -> DisplayValue , BaseOffset ) ) goto Error ;\n }\n p = cmsDictNextEntry ( p ) ;\n }\n CurrentPos = io -> Tell ( io ) ;\n if ( ! io -> Seek ( io , DirectoryPos ) ) goto Error ;\n if ( ! WriteOffsetArray ( io , & a , Count , Length ) ) goto Error ;\n if ( ! io -> Seek ( io , CurrentPos ) ) goto Error ;\n FreeArray ( & a ) ;\n return TRUE ;\n Error : FreeArray ( & a ) ;\n return FALSE ;\n cmsUNUSED_PARAMETER ( nItems ) ;\n }", "idx": 22107}
{"hash": -6552851419396579257, "project": "debian", "size": 12, "label": 0, "functionSource": "static int dissect_DRIVER_INFO_2 ( tvbuff_t * tvb , int offset , packet_info * pinfo , proto_tree * tree , dcerpc_info * di , guint8 * drep ) {\n proto_tree * subtree ;\n int struct_start = offset ;\n subtree = proto_tree_add_subtree ( tree , tvb , offset , 0 , ett_DRIVER_INFO_2 , NULL , \"Driver info level 2\" ) ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , subtree , di , drep , hf_driverinfo_cversion , NULL ) ;\n offset = dissect_spoolss_relstr ( tvb , offset , pinfo , subtree , di , drep , hf_drivername , struct_start , NULL ) ;\n offset = dissect_spoolss_relstr ( tvb , offset , pinfo , subtree , di , drep , hf_environment , struct_start , NULL ) ;\n offset = dissect_spoolss_relstr ( tvb , offset , pinfo , subtree , di , drep , hf_driverpath , struct_start , NULL ) ;\n offset = dissect_spoolss_relstr ( tvb , offset , pinfo , subtree , di , drep , hf_datafile , struct_start , NULL ) ;\n offset = dissect_spoolss_relstr ( tvb , offset , pinfo , subtree , di , drep , hf_configfile , struct_start , NULL ) ;\n return offset ;\n }", "idx": 22108}
{"hash": -1335877942018854351, "project": "chrome", "size": 10, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( FastUnloadTest , BrowserListForceCloseAfterNormalCloseWithFastUnload ) {\n NavigateToDataURL ( BEFORE_UNLOAD_HTML , \"beforeunload\" ) ;\n content : : WindowedNotificationObserver window_observer ( chrome : : NOTIFICATION_BROWSER_CLOSED , content : : NotificationService : : AllSources ( ) ) ;\n UnloadResults unload_results ;\n BrowserList : : CloseAllBrowsersWithProfile ( browser ( ) -> profile ( ) , base : : Bind ( & UnloadResults : : AddSuccess , base : : Unretained ( & unload_results ) ) , base : : Bind ( & UnloadResults : : AddAbort , base : : Unretained ( & unload_results ) ) , false ) ;\n BrowserList : : CloseAllBrowsersWithProfile ( browser ( ) -> profile ( ) , base : : Bind ( & UnloadResults : : AddSuccess , base : : Unretained ( & unload_results ) ) , base : : Bind ( & UnloadResults : : AddAbort , base : : Unretained ( & unload_results ) ) , true ) ;\n window_observer . Wait ( ) ;\n EXPECT_EQ ( 1 , unload_results . get_successes ( ) ) ;\n EXPECT_EQ ( 0 , unload_results . get_aborts ( ) ) ;\n }", "idx": 22109}
{"hash": -7455544248455991006, "project": "debian", "size": 4, "label": 0, "functionSource": "static bool hyperv_enabled ( X86CPU * cpu ) {\n CPUState * cs = CPU ( cpu ) ;\n return kvm_check_extension ( cs -> kvm_state , KVM_CAP_HYPERV ) > 0 && ( hyperv_hypercall_available ( cpu ) || cpu -> hyperv_time || cpu -> hyperv_relaxed_timing || cpu -> hyperv_crash || cpu -> hyperv_reset || cpu -> hyperv_vpindex || cpu -> hyperv_runtime || cpu -> hyperv_synic || cpu -> hyperv_stimer || cpu -> hyperv_reenlightenment ) ;\n }", "idx": 22110}
{"hash": 2772622454795674000, "project": "debian", "size": 32, "label": 0, "functionSource": "static int h263_decode_gob_header ( MpegEncContext * s ) {\n unsigned int val , gob_number ;\n int left ;\n val = show_bits ( & s -> gb , 16 ) ;\n if ( val ) return - 1 ;\n skip_bits ( & s -> gb , 16 ) ;\n left = get_bits_left ( & s -> gb ) ;\n for ( ;\n left > 13 ;\n left -- ) {\n if ( get_bits1 ( & s -> gb ) ) break ;\n }\n if ( left <= 13 ) return - 1 ;\n if ( s -> h263_slice_structured ) {\n if ( get_bits1 ( & s -> gb ) == 0 ) return - 1 ;\n ff_h263_decode_mba ( s ) ;\n if ( s -> mb_num > 1583 ) if ( get_bits1 ( & s -> gb ) == 0 ) return - 1 ;\n s -> qscale = get_bits ( & s -> gb , 5 ) ;\n if ( get_bits1 ( & s -> gb ) == 0 ) return - 1 ;\n skip_bits ( & s -> gb , 2 ) ;\n }\n else {\n gob_number = get_bits ( & s -> gb , 5 ) ;\n s -> mb_x = 0 ;\n s -> mb_y = s -> gob_index * gob_number ;\n skip_bits ( & s -> gb , 2 ) ;\n s -> qscale = get_bits ( & s -> gb , 5 ) ;\n }\n if ( s -> mb_y >= s -> mb_height ) return - 1 ;\n if ( s -> qscale == 0 ) return - 1 ;\n return 0 ;\n }", "idx": 22111}
{"hash": -275948070528829821, "project": "debian", "size": 14, "label": 0, "functionSource": "static subpicture_t * DecodeBlock ( decoder_t * p_dec , block_t * * pp_block ) {\n subpicture_t * p_spu ;\n block_t * p_block ;\n if ( ! pp_block || * pp_block == NULL ) return NULL ;\n p_block = * pp_block ;\n if ( p_block -> i_flags & ( BLOCK_FLAG_DISCONTINUITY | BLOCK_FLAG_CORRUPTED ) ) {\n block_Release ( p_block ) ;\n return NULL ;\n }\n p_spu = ParseText ( p_dec , p_block ) ;\n block_Release ( p_block ) ;\n * pp_block = NULL ;\n return p_spu ;\n }", "idx": 22112}
{"hash": -7076754245473579218, "project": "chrome", "size": 28, "label": 0, "functionSource": "static void evhttp_read_body ( struct evhttp_connection * evcon , struct evhttp_request * req ) {\n struct evbuffer * buf = evcon -> input_buffer ;\n if ( req -> chunked ) {\n switch ( evhttp_handle_chunked_read ( req , buf ) ) {\n case ALL_DATA_READ : evcon -> state = EVCON_READING_TRAILER ;\n evhttp_read_trailer ( evcon , req ) ;\n return ;\n case DATA_CORRUPTED : evhttp_connection_fail ( evcon , EVCON_HTTP_INVALID_HEADER ) ;\n return ;\n case REQUEST_CANCELED : evhttp_request_free ( req ) ;\n return ;\n case MORE_DATA_EXPECTED : default : break ;\n }\n }\n else if ( req -> ntoread < 0 ) {\n evbuffer_add_buffer ( req -> input_buffer , buf ) ;\n }\n else if ( EVBUFFER_LENGTH ( buf ) >= req -> ntoread ) {\n evbuffer_add ( req -> input_buffer , EVBUFFER_DATA ( buf ) , ( size_t ) req -> ntoread ) ;\n evbuffer_drain ( buf , ( size_t ) req -> ntoread ) ;\n req -> ntoread = 0 ;\n evhttp_connection_done ( evcon ) ;\n return ;\n }\n event_set ( & evcon -> ev , evcon -> fd , EV_READ , evhttp_read , evcon ) ;\n EVHTTP_BASE_SET ( evcon , & evcon -> ev ) ;\n evhttp_add_event ( & evcon -> ev , evcon -> timeout , HTTP_READ_TIMEOUT ) ;\n }", "idx": 22113}
{"hash": 1760449185745615462, "project": "debian", "size": 5, "label": 0, "functionSource": "void TSVConnInactivityTimeoutSet ( TSVConn connp , TSHRTime timeout ) {\n sdk_assert ( sdk_sanity_check_iocore_structure ( connp ) == TS_SUCCESS ) ;\n NetVConnection * vc = ( NetVConnection * ) connp ;\n vc -> set_inactivity_timeout ( timeout ) ;\n }", "idx": 22114}
{"hash": 378220832151730865, "project": "debian", "size": 78, "label": 0, "functionSource": "int qemuMonitorTextGetBlockStatsInfo ( qemuMonitorPtr mon , const char * dev_name , long long * rd_req , long long * rd_bytes , long long * rd_total_times , long long * wr_req , long long * wr_bytes , long long * wr_total_times , long long * flush_req , long long * flush_total_times , long long * errs ) {\n char * info = NULL ;\n int ret = - 1 ;\n char * dummy ;\n const char * p , * eol ;\n int devnamelen = strlen ( dev_name ) ;\n if ( qemuMonitorHMPCommand ( mon , \"info blockstats\" , & info ) < 0 ) {\n qemuReportError ( VIR_ERR_OPERATION_FAILED , \"%s\" , _ ( \"'info blockstats' command failed\" ) ) ;\n goto cleanup ;\n }\n if ( strstr ( info , \"\\ninfo \" ) ) {\n qemuReportError ( VIR_ERR_OPERATION_INVALID , \"%s\" , _ ( \"'info blockstats' not supported by this qemu\" ) ) ;\n goto cleanup ;\n }\n * rd_req = * rd_bytes = - 1 ;\n * wr_req = * wr_bytes = * errs = - 1 ;\n if ( rd_total_times ) * rd_total_times = - 1 ;\n if ( wr_total_times ) * wr_total_times = - 1 ;\n if ( flush_req ) * flush_req = - 1 ;\n if ( flush_total_times ) * flush_total_times = - 1 ;\n p = info ;\n while ( * p ) {\n if ( STRPREFIX ( p , QEMU_DRIVE_HOST_PREFIX ) ) p += strlen ( QEMU_DRIVE_HOST_PREFIX ) ;\n if ( STREQLEN ( p , dev_name , devnamelen ) && p [ devnamelen ] == ':' && p [ devnamelen + 1 ] == ' ' ) {\n eol = strchr ( p , '\\n' ) ;\n if ( ! eol ) eol = p + strlen ( p ) ;\n p += devnamelen + 2 ;\n while ( * p ) {\n if ( STRPREFIX ( p , \"rd_bytes=\" ) ) {\n p += strlen ( \"rd_bytes=\" ) ;\n if ( virStrToLong_ll ( p , & dummy , 10 , rd_bytes ) == - 1 ) VIR_DEBUG ( \"error reading rd_bytes: %s\" , p ) ;\n }\n else if ( STRPREFIX ( p , \"wr_bytes=\" ) ) {\n p += strlen ( \"wr_bytes=\" ) ;\n if ( virStrToLong_ll ( p , & dummy , 10 , wr_bytes ) == - 1 ) VIR_DEBUG ( \"error reading wr_bytes: %s\" , p ) ;\n }\n else if ( STRPREFIX ( p , \"rd_operations=\" ) ) {\n p += strlen ( \"rd_operations=\" ) ;\n if ( virStrToLong_ll ( p , & dummy , 10 , rd_req ) == - 1 ) VIR_DEBUG ( \"error reading rd_req: %s\" , p ) ;\n }\n else if ( STRPREFIX ( p , \"wr_operations=\" ) ) {\n p += strlen ( \"wr_operations=\" ) ;\n if ( virStrToLong_ll ( p , & dummy , 10 , wr_req ) == - 1 ) VIR_DEBUG ( \"error reading wr_req: %s\" , p ) ;\n }\n else if ( rd_total_times && STRPREFIX ( p , \"rd_total_times_ns=\" ) ) {\n p += strlen ( \"rd_total_times_ns=\" ) ;\n if ( virStrToLong_ll ( p , & dummy , 10 , rd_total_times ) == - 1 ) VIR_DEBUG ( \"error reading rd_total_times: %s\" , p ) ;\n }\n else if ( wr_total_times && STRPREFIX ( p , \"wr_total_times_ns=\" ) ) {\n p += strlen ( \"wr_total_times_ns=\" ) ;\n if ( virStrToLong_ll ( p , & dummy , 10 , wr_total_times ) == - 1 ) VIR_DEBUG ( \"error reading wr_total_times: %s\" , p ) ;\n }\n else if ( flush_req && STRPREFIX ( p , \"flush_operations=\" ) ) {\n p += strlen ( \"flush_operations=\" ) ;\n if ( virStrToLong_ll ( p , & dummy , 10 , flush_req ) == - 1 ) VIR_DEBUG ( \"error reading flush_req: %s\" , p ) ;\n }\n else if ( flush_total_times && STRPREFIX ( p , \"flush_total_times_ns=\" ) ) {\n p += strlen ( \"flush_total_times_ns=\" ) ;\n if ( virStrToLong_ll ( p , & dummy , 10 , flush_total_times ) == - 1 ) VIR_DEBUG ( \"error reading flush_total_times: %s\" , p ) ;\n }\n else {\n VIR_DEBUG ( \"unknown block stat near %s\" , p ) ;\n }\n p = strchr ( p , ' ' ) ;\n if ( ! p || p >= eol ) break ;\n p ++ ;\n }\n ret = 0 ;\n goto cleanup ;\n }\n p = strchr ( p , '\\n' ) ;\n if ( ! p ) break ;\n p ++ ;\n }\n qemuReportError ( VIR_ERR_INVALID_ARG , _ ( \"no stats found for device %s\" ) , dev_name ) ;\n cleanup : VIR_FREE ( info ) ;\n return ret ;\n }", "idx": 22115}
{"hash": 2917602761308156638, "project": "debian", "size": 37, "label": 0, "functionSource": "static Asn1Generic * DecodeAsn1DerPrintableString ( const unsigned char * buffer , uint32_t max_size , uint8_t depth , uint32_t * errcode ) {\n const unsigned char * d_ptr = buffer ;\n uint32_t length , numbytes ;\n Asn1Generic * a ;\n unsigned char c ;\n d_ptr ++ ;\n c = d_ptr [ 0 ] ;\n if ( ( c & ( 1 << 7 ) ) >> 7 == 0 ) {\n length = c ;\n d_ptr ++ ;\n }\n else {\n numbytes = c & 0x7f ;\n d_ptr ++ ;\n if ( DecodeAsn1BuildValue ( & d_ptr , & length , numbytes , errcode ) == - 1 ) {\n return NULL ;\n }\n }\n if ( length == UINT32_MAX || length > max_size ) {\n if ( errcode ) * errcode = ERR_DER_ELEMENT_SIZE_TOO_BIG ;\n return NULL ;\n }\n a = Asn1GenericNew ( ) ;\n if ( a == NULL ) return NULL ;\n a -> type = ASN1_PRINTSTRING ;\n a -> strlen = length ;\n a -> str = SCMalloc ( length + 1 ) ;\n if ( a -> str == NULL ) {\n SCFree ( a ) ;\n return NULL ;\n }\n strlcpy ( a -> str , ( const char * ) d_ptr , length + 1 ) ;\n a -> str [ length ] = '\\0' ;\n d_ptr += length ;\n a -> length = ( d_ptr - buffer ) ;\n return a ;\n }", "idx": 22116}
{"hash": -7777644912037188223, "project": "debian", "size": 46, "label": 1, "functionSource": "static int dissect_udvm_reference_operand_memory ( guint8 * buff , guint operand_address , guint16 * value , guint * result_dest ) {\n guint bytecode ;\n guint16 operand ;\n guint offset = operand_address ;\n guint test_bits ;\n guint8 temp_data ;\n guint16 temp_data16 ;\n bytecode = buff [ operand_address ] ;\n test_bits = bytecode >> 7 ;\n if ( test_bits == 1 ) {\n test_bits = bytecode >> 6 ;\n if ( test_bits == 2 ) {\n temp_data = buff [ operand_address ] & 0x3f ;\n operand = temp_data << 8 ;\n temp_data = buff [ ( operand_address + 1 ) & 0xffff ] ;\n operand = operand | temp_data ;\n operand = ( operand * 2 ) ;\n * result_dest = operand ;\n temp_data16 = buff [ operand ] << 8 ;\n temp_data16 = temp_data16 | buff [ ( operand + 1 ) & 0xffff ] ;\n * value = temp_data16 ;\n offset = offset + 2 ;\n }\n else {\n operand_address ++ ;\n operand = buff [ operand_address ] << 8 ;\n operand = operand | buff [ ( operand_address + 1 ) & 0xffff ] ;\n * result_dest = operand ;\n temp_data16 = buff [ operand ] << 8 ;\n temp_data16 = temp_data16 | buff [ ( operand + 1 ) & 0xffff ] ;\n * value = temp_data16 ;\n offset = offset + 3 ;\n }\n }\n else {\n operand = ( bytecode & 0x7f ) ;\n operand = ( operand * 2 ) ;\n * result_dest = operand ;\n temp_data16 = buff [ operand ] << 8 ;\n temp_data16 = temp_data16 | buff [ ( operand + 1 ) & 0xffff ] ;\n * value = temp_data16 ;\n offset ++ ;\n }\n if ( offset >= UDVM_MEMORY_SIZE || * result_dest >= UDVM_MEMORY_SIZE - 1 ) return 0 ;\n return offset ;\n }", "idx": 22117}
{"hash": -2728678221258889842, "project": "chrome", "size": 19, "label": 0, "functionSource": "TEST_F ( ShortcutsBackendTest , AddAndUpdateShortcut ) {\n InitBackend ( ) ;\n EXPECT_FALSE ( changed_notified ( ) ) ;\n ShortcutsDatabase : : Shortcut shortcut ( \"BD85DBA2-8C29-49F9-84AE-48E1E90880DF\" , base : : ASCIIToUTF16 ( \"goog\" ) , MatchCoreForTesting ( \"http://www.google.com\" ) , base : : Time : : Now ( ) , 100 ) ;\n EXPECT_TRUE ( AddShortcut ( shortcut ) ) ;\n EXPECT_TRUE ( changed_notified ( ) ) ;\n ShortcutsBackend : : ShortcutMap : : const_iterator shortcut_iter ( shortcuts_map ( ) . find ( shortcut . text ) ) ;\n ASSERT_TRUE ( shortcut_iter != shortcuts_map ( ) . end ( ) ) ;\n EXPECT_EQ ( shortcut . id , shortcut_iter -> second . id ) ;\n EXPECT_EQ ( shortcut . match_core . contents , shortcut_iter -> second . match_core . contents ) ;\n set_changed_notified ( false ) ;\n shortcut . match_core . contents = base : : ASCIIToUTF16 ( \"Google Web Search\" ) ;\n EXPECT_TRUE ( UpdateShortcut ( shortcut ) ) ;\n EXPECT_TRUE ( changed_notified ( ) ) ;\n shortcut_iter = shortcuts_map ( ) . find ( shortcut . text ) ;\n ASSERT_TRUE ( shortcut_iter != shortcuts_map ( ) . end ( ) ) ;\n EXPECT_EQ ( shortcut . id , shortcut_iter -> second . id ) ;\n EXPECT_EQ ( shortcut . match_core . contents , shortcut_iter -> second . match_core . contents ) ;\n }", "idx": 22118}
{"hash": -1102844685921778700, "project": "debian", "size": 25, "label": 0, "functionSource": "static int cesu8_to_unicode ( uint32_t * pwc , const char * s , size_t n ) {\n uint32_t wc = 0 ;\n int cnt ;\n cnt = _utf8_to_unicode ( & wc , s , n ) ;\n if ( cnt == 3 && IS_HIGH_SURROGATE_LA ( wc ) ) {\n uint32_t wc2 = 0 ;\n if ( n - 3 < 3 ) {\n goto invalid_sequence ;\n }\n cnt = _utf8_to_unicode ( & wc2 , s + 3 , n - 3 ) ;\n if ( cnt != 3 || ! IS_LOW_SURROGATE_LA ( wc2 ) ) {\n goto invalid_sequence ;\n }\n wc = combine_surrogate_pair ( wc , wc2 ) ;\n cnt = 6 ;\n }\n else if ( cnt == 3 && IS_LOW_SURROGATE_LA ( wc ) ) {\n goto invalid_sequence ;\n }\n * pwc = wc ;\n return ( cnt ) ;\n invalid_sequence : * pwc = UNICODE_R_CHAR ;\n if ( cnt > 0 ) cnt *= - 1 ;\n return ( cnt ) ;\n }", "idx": 22119}
{"hash": 8849962823026424130, "project": "debian", "size": 11, "label": 0, "functionSource": "static void qio_channel_websock_handshake_send_res ( QIOChannelWebsock * ioc , const char * resmsg , ... ) {\n va_list vargs ;\n char * response ;\n size_t responselen ;\n va_start ( vargs , resmsg ) ;\n response = g_strdup_vprintf ( resmsg , vargs ) ;\n responselen = strlen ( response ) ;\n buffer_reserve ( & ioc -> encoutput , responselen ) ;\n buffer_append ( & ioc -> encoutput , response , responselen ) ;\n va_end ( vargs ) ;\n }", "idx": 22120}
{"hash": -7076754245473579218, "project": "chrome", "size": 31, "label": 0, "functionSource": "static void evhttp_read_header ( struct evhttp_connection * evcon , struct evhttp_request * req ) {\n enum message_read_status res ;\n int fd = evcon -> fd ;\n res = evhttp_parse_headers ( req , evcon -> input_buffer ) ;\n if ( res == DATA_CORRUPTED ) {\n event_debug ( ( \"%s: bad header lines on %d\\n\" , __func__ , fd ) ) ;\n evhttp_connection_fail ( evcon , EVCON_HTTP_INVALID_HEADER ) ;\n return ;\n }\n else if ( res == MORE_DATA_EXPECTED ) {\n evhttp_add_event ( & evcon -> ev , evcon -> timeout , HTTP_READ_TIMEOUT ) ;\n return ;\n }\n switch ( req -> kind ) {\n case EVHTTP_REQUEST : event_debug ( ( \"%s: checking for post data on %d\\n\" , __func__ , fd ) ) ;\n evhttp_get_body ( evcon , req ) ;\n break ;\n case EVHTTP_RESPONSE : if ( req -> response_code == HTTP_NOCONTENT || req -> response_code == HTTP_NOTMODIFIED || ( req -> response_code >= 100 && req -> response_code < 200 ) ) {\n event_debug ( ( \"%s: skipping body for code %d\\n\" , __func__ , req -> response_code ) ) ;\n evhttp_connection_done ( evcon ) ;\n }\n else {\n event_debug ( ( \"%s: start of read body for %s on %d\\n\" , __func__ , req -> remote_host , fd ) ) ;\n evhttp_get_body ( evcon , req ) ;\n }\n break ;\n default : event_warnx ( \"%s: bad header on %d\" , __func__ , fd ) ;\n evhttp_connection_fail ( evcon , EVCON_HTTP_INVALID_HEADER ) ;\n break ;\n }\n }", "idx": 22121}
{"hash": -2226094829431805196, "project": "debian", "size": 3, "label": 0, "functionSource": "jpc_pchg_t * jpc_pchglist_get ( jpc_pchglist_t * pchglist , int pchgno ) {\n return pchglist -> pchgs [ pchgno ] ;\n }", "idx": 22122}
{"hash": -5697857125570093892, "project": "chrome", "size": 14, "label": 0, "functionSource": "static const char * ultag_getVariant ( const ULanguageTag * langtag , int32_t idx ) {\n const char * var = NULL ;\n VariantListEntry * cur = langtag -> variants ;\n int32_t i = 0 ;\n while ( cur ) {\n if ( i == idx ) {\n var = cur -> variant ;\n break ;\n }\n cur = cur -> next ;\n i ++ ;\n }\n return var ;\n }", "idx": 22123}
{"hash": 5611940141018433728, "project": "chrome", "size": 49, "label": 0, "functionSource": "static void write_uncompressed_header ( VP9_COMP * cpi , struct vp9_write_bit_buffer * wb ) {\n VP9_COMMON * const cm = & cpi -> common ;\n vp9_wb_write_literal ( wb , VP9_FRAME_MARKER , 2 ) ;\n write_profile ( cm -> profile , wb ) ;\n vp9_wb_write_bit ( wb , 0 ) ;\n vp9_wb_write_bit ( wb , cm -> frame_type ) ;\n vp9_wb_write_bit ( wb , cm -> show_frame ) ;\n vp9_wb_write_bit ( wb , cm -> error_resilient_mode ) ;\n if ( cm -> frame_type == KEY_FRAME ) {\n write_sync_code ( wb ) ;\n write_bitdepth_colorspace_sampling ( cm , wb ) ;\n write_frame_size ( cm , wb ) ;\n }\n else {\n if ( ! cm -> show_frame || ( is_two_pass_svc ( cpi ) && cm -> error_resilient_mode == 0 ) ) vp9_wb_write_bit ( wb , cm -> intra_only ) ;\n if ( ! cm -> error_resilient_mode ) vp9_wb_write_literal ( wb , cm -> reset_frame_context , 2 ) ;\n if ( cm -> intra_only ) {\n write_sync_code ( wb ) ;\n if ( cm -> profile > PROFILE_0 ) {\n write_bitdepth_colorspace_sampling ( cm , wb ) ;\n }\n vp9_wb_write_literal ( wb , get_refresh_mask ( cpi ) , REF_FRAMES ) ;\n write_frame_size ( cm , wb ) ;\n }\n else {\n MV_REFERENCE_FRAME ref_frame ;\n vp9_wb_write_literal ( wb , get_refresh_mask ( cpi ) , REF_FRAMES ) ;\n for ( ref_frame = LAST_FRAME ;\n ref_frame <= ALTREF_FRAME ;\n ++ ref_frame ) {\n vp9_wb_write_literal ( wb , get_ref_frame_idx ( cpi , ref_frame ) , REF_FRAMES_LOG2 ) ;\n vp9_wb_write_bit ( wb , cm -> ref_frame_sign_bias [ ref_frame ] ) ;\n }\n write_frame_size_with_refs ( cpi , wb ) ;\n vp9_wb_write_bit ( wb , cm -> allow_high_precision_mv ) ;\n fix_interp_filter ( cm ) ;\n write_interp_filter ( cm -> interp_filter , wb ) ;\n }\n }\n if ( ! cm -> error_resilient_mode ) {\n vp9_wb_write_bit ( wb , cm -> refresh_frame_context ) ;\n vp9_wb_write_bit ( wb , cm -> frame_parallel_decoding_mode ) ;\n }\n vp9_wb_write_literal ( wb , cm -> frame_context_idx , FRAME_CONTEXTS_LOG2 ) ;\n encode_loopfilter ( & cm -> lf , wb ) ;\n encode_quantization ( cm , wb ) ;\n encode_segmentation ( cm , & cpi -> mb . e_mbd , wb ) ;\n write_tile_info ( cm , wb ) ;\n }", "idx": 22124}
{"hash": -2607754285145856562, "project": "debian", "size": 4, "label": 0, "functionSource": "static void set_date_time_null ( unsigned char * p ) {\n memset ( p , '0' , 16 ) ;\n p [ 16 ] = 0 ;\n }", "idx": 22125}
{"hash": -1315695702746584250, "project": "debian", "size": 14, "label": 0, "functionSource": "static void proto_tree_set_int ( field_info * fi , gint32 value ) {\n header_field_info * hfinfo ;\n guint32 integer ;\n gint no_of_bits ;\n hfinfo = fi -> hfinfo ;\n integer = ( guint32 ) value ;\n if ( hfinfo -> bitmask ) {\n integer &= ( guint32 ) ( hfinfo -> bitmask ) ;\n integer >>= hfinfo_bitshift ( hfinfo ) ;\n no_of_bits = ws_count_ones ( hfinfo -> bitmask ) ;\n integer = ws_sign_ext32 ( integer , no_of_bits ) ;\n }\n fvalue_set_sinteger ( & fi -> value , integer ) ;\n }", "idx": 22126}
{"hash": 4187524518637656726, "project": "debian", "size": 8, "label": 0, "functionSource": "static int collated_compare ( const void * a , const void * b ) {\n const char * const s1 = * ( const char * const * const ) a ;\n const char * const s2 = * ( const char * const * const ) b ;\n if ( s1 == s2 ) return 0 ;\n if ( s1 == NULL ) return 1 ;\n if ( s2 == NULL ) return - 1 ;\n return strcoll ( s1 , s2 ) ;\n }", "idx": 22127}
{"hash": 3309252579593081468, "project": "debian", "size": 71, "label": 0, "functionSource": "static int nntp_msg_open ( struct Context * ctx , struct Message * msg , int msgno ) {\n struct NntpData * nntp_data = ctx -> data ;\n struct Header * hdr = ctx -> hdrs [ msgno ] ;\n char article [ 16 ] ;\n struct NntpAcache * acache = & nntp_data -> acache [ hdr -> index % NNTP_ACACHE_LEN ] ;\n if ( acache -> path ) {\n if ( acache -> index == hdr -> index ) {\n msg -> fp = mutt_file_fopen ( acache -> path , \"r\" ) ;\n if ( msg -> fp ) return 0 ;\n }\n else {\n unlink ( acache -> path ) ;\n FREE ( & acache -> path ) ;\n }\n }\n snprintf ( article , sizeof ( article ) , \"%d\" , NHDR ( hdr ) -> article_num ) ;\n msg -> fp = mutt_bcache_get ( nntp_data -> bcache , article ) ;\n if ( msg -> fp ) {\n if ( NHDR ( hdr ) -> parsed ) return 0 ;\n }\n else {\n char buf [ PATH_MAX ] ;\n if ( nntp_data -> deleted ) return - 1 ;\n const char * fetch_msg = _ ( \"Fetching message...\" ) ;\n mutt_message ( fetch_msg ) ;\n msg -> fp = mutt_bcache_put ( nntp_data -> bcache , article ) ;\n if ( ! msg -> fp ) {\n mutt_mktemp ( buf , sizeof ( buf ) ) ;\n acache -> path = mutt_str_strdup ( buf ) ;\n acache -> index = hdr -> index ;\n msg -> fp = mutt_file_fopen ( acache -> path , \"w+\" ) ;\n if ( ! msg -> fp ) {\n mutt_perror ( acache -> path ) ;\n unlink ( acache -> path ) ;\n FREE ( & acache -> path ) ;\n return - 1 ;\n }\n }\n snprintf ( buf , sizeof ( buf ) , \"ARTICLE %s\\r\\n\" , NHDR ( hdr ) -> article_num ? article : hdr -> env -> message_id ) ;\n const int rc = nntp_fetch_lines ( nntp_data , buf , sizeof ( buf ) , fetch_msg , fetch_tempfile , msg -> fp ) ;\n if ( rc ) {\n mutt_file_fclose ( & msg -> fp ) ;\n if ( acache -> path ) {\n unlink ( acache -> path ) ;\n FREE ( & acache -> path ) ;\n }\n if ( rc > 0 ) {\n if ( mutt_str_strncmp ( NHDR ( hdr ) -> article_num ? \"423\" : \"430\" , buf , 3 ) == 0 ) {\n mutt_error ( _ ( \"Article %d not found on the server.\" ) , NHDR ( hdr ) -> article_num ? article : hdr -> env -> message_id ) ;\n }\n else mutt_error ( \"ARTICLE: %s\" , buf ) ;\n }\n return - 1 ;\n }\n if ( ! acache -> path ) mutt_bcache_commit ( nntp_data -> bcache , article ) ;\n }\n if ( ctx -> id_hash && hdr -> env -> message_id ) mutt_hash_delete ( ctx -> id_hash , hdr -> env -> message_id , hdr ) ;\n if ( ctx -> subj_hash && hdr -> env -> real_subj ) mutt_hash_delete ( ctx -> subj_hash , hdr -> env -> real_subj , hdr ) ;\n mutt_env_free ( & hdr -> env ) ;\n hdr -> env = mutt_rfc822_read_header ( msg -> fp , hdr , 0 , 0 ) ;\n if ( ctx -> id_hash && hdr -> env -> message_id ) mutt_hash_insert ( ctx -> id_hash , hdr -> env -> message_id , hdr ) ;\n if ( ctx -> subj_hash && hdr -> env -> real_subj ) mutt_hash_insert ( ctx -> subj_hash , hdr -> env -> real_subj , hdr ) ;\n fseek ( msg -> fp , 0 , SEEK_END ) ;\n hdr -> content -> length = ftell ( msg -> fp ) - hdr -> content -> offset ;\n NHDR ( hdr ) -> parsed = true ;\n mutt_parse_mime_message ( ctx , hdr ) ;\n if ( WithCrypto ) hdr -> security = crypt_query ( hdr -> content ) ;\n rewind ( msg -> fp ) ;\n mutt_clear_error ( ) ;\n return 0 ;\n }", "idx": 22128}
{"hash": -8562387810778703674, "project": "chrome", "size": 5, "label": 0, "functionSource": "static hb_bool_t hb_font_get_glyph_name_nil ( hb_font_t * font , void * font_data HB_UNUSED , hb_codepoint_t glyph , char * name , unsigned int size , void * user_data HB_UNUSED ) {\n if ( font -> parent ) return font -> parent -> get_glyph_name ( glyph , name , size ) ;\n if ( size ) * name = '\\0' ;\n return false ;\n }", "idx": 22129}
{"hash": -650231346353974279, "project": "debian", "size": 10, "label": 0, "functionSource": "static PQExpBuffer defaultGetLocalPQExpBuffer ( void ) {\n static PQExpBuffer id_return = NULL ;\n if ( id_return ) {\n resetPQExpBuffer ( id_return ) ;\n }\n else {\n id_return = createPQExpBuffer ( ) ;\n }\n return id_return ;\n }", "idx": 22130}
{"hash": -305162769887579921, "project": "debian", "size": 26, "label": 0, "functionSource": "static void build_basis ( uint8_t * perm ) {\n int i , j , x , y ;\n emms_c ( ) ;\n for ( i = 0 ;\n i < 8 ;\n i ++ ) {\n for ( j = 0 ;\n j < 8 ;\n j ++ ) {\n for ( y = 0 ;\n y < 8 ;\n y ++ ) {\n for ( x = 0 ;\n x < 8 ;\n x ++ ) {\n double s = 0.25 * ( 1 << BASIS_SHIFT ) ;\n int index = 8 * i + j ;\n int perm_index = perm [ index ] ;\n if ( i == 0 ) s *= sqrt ( 0.5 ) ;\n if ( j == 0 ) s *= sqrt ( 0.5 ) ;\n basis [ perm_index ] [ 8 * x + y ] = lrintf ( s * cos ( ( M_PI / 8.0 ) * i * ( x + 0.5 ) ) * cos ( ( M_PI / 8.0 ) * j * ( y + 0.5 ) ) ) ;\n }\n }\n }\n }\n }", "idx": 22131}
{"hash": 7424930167238097621, "project": "debian", "size": 11, "label": 0, "functionSource": "static struct async * async_getcompleted ( struct usb_dev_state * ps ) {\n unsigned long flags ;\n struct async * as = NULL ;\n spin_lock_irqsave ( & ps -> lock , flags ) ;\n if ( ! list_empty ( & ps -> async_completed ) ) {\n as = list_entry ( ps -> async_completed . next , struct async , asynclist ) ;\n list_del_init ( & as -> asynclist ) ;\n }\n spin_unlock_irqrestore ( & ps -> lock , flags ) ;\n return as ;\n }", "idx": 22132}
{"hash": 5611940141018433728, "project": "chrome", "size": 143, "label": 0, "functionSource": "static void update_coef_probs_common ( vp9_writer * const bc , VP9_COMP * cpi , TX_SIZE tx_size , vp9_coeff_stats * frame_branch_ct , vp9_coeff_probs_model * new_coef_probs ) {\n vp9_coeff_probs_model * old_coef_probs = cpi -> common . fc . coef_probs [ tx_size ] ;\n const vp9_prob upd = DIFF_UPDATE_PROB ;\n const int entropy_nodes_update = UNCONSTRAINED_NODES ;\n int i , j , k , l , t ;\n switch ( cpi -> sf . use_fast_coef_updates ) {\n case TWO_LOOP : {\n int savings = 0 ;\n int update [ 2 ] = {\n 0 , 0 }\n ;\n for ( i = 0 ;\n i < PLANE_TYPES ;\n ++ i ) {\n for ( j = 0 ;\n j < REF_TYPES ;\n ++ j ) {\n for ( k = 0 ;\n k < COEF_BANDS ;\n ++ k ) {\n for ( l = 0 ;\n l < BAND_COEFF_CONTEXTS ( k ) ;\n ++ l ) {\n for ( t = 0 ;\n t < entropy_nodes_update ;\n ++ t ) {\n vp9_prob newp = new_coef_probs [ i ] [ j ] [ k ] [ l ] [ t ] ;\n const vp9_prob oldp = old_coef_probs [ i ] [ j ] [ k ] [ l ] [ t ] ;\n int s ;\n int u = 0 ;\n if ( t == PIVOT_NODE ) s = vp9_prob_diff_update_savings_search_model ( frame_branch_ct [ i ] [ j ] [ k ] [ l ] [ 0 ] , old_coef_probs [ i ] [ j ] [ k ] [ l ] , & newp , upd ) ;\n else s = vp9_prob_diff_update_savings_search ( frame_branch_ct [ i ] [ j ] [ k ] [ l ] [ t ] , oldp , & newp , upd ) ;\n if ( s > 0 && newp != oldp ) u = 1 ;\n if ( u ) savings += s - ( int ) ( vp9_cost_zero ( upd ) ) ;\n else savings -= ( int ) ( vp9_cost_zero ( upd ) ) ;\n update [ u ] ++ ;\n }\n }\n }\n }\n }\n if ( update [ 1 ] == 0 || savings < 0 ) {\n vp9_write_bit ( bc , 0 ) ;\n return ;\n }\n vp9_write_bit ( bc , 1 ) ;\n for ( i = 0 ;\n i < PLANE_TYPES ;\n ++ i ) {\n for ( j = 0 ;\n j < REF_TYPES ;\n ++ j ) {\n for ( k = 0 ;\n k < COEF_BANDS ;\n ++ k ) {\n for ( l = 0 ;\n l < BAND_COEFF_CONTEXTS ( k ) ;\n ++ l ) {\n for ( t = 0 ;\n t < entropy_nodes_update ;\n ++ t ) {\n vp9_prob newp = new_coef_probs [ i ] [ j ] [ k ] [ l ] [ t ] ;\n vp9_prob * oldp = old_coef_probs [ i ] [ j ] [ k ] [ l ] + t ;\n const vp9_prob upd = DIFF_UPDATE_PROB ;\n int s ;\n int u = 0 ;\n if ( t == PIVOT_NODE ) s = vp9_prob_diff_update_savings_search_model ( frame_branch_ct [ i ] [ j ] [ k ] [ l ] [ 0 ] , old_coef_probs [ i ] [ j ] [ k ] [ l ] , & newp , upd ) ;\n else s = vp9_prob_diff_update_savings_search ( frame_branch_ct [ i ] [ j ] [ k ] [ l ] [ t ] , * oldp , & newp , upd ) ;\n if ( s > 0 && newp != * oldp ) u = 1 ;\n vp9_write ( bc , u , upd ) ;\n if ( u ) {\n vp9_write_prob_diff_update ( bc , newp , * oldp ) ;\n * oldp = newp ;\n }\n }\n }\n }\n }\n }\n return ;\n }\n case ONE_LOOP : case ONE_LOOP_REDUCED : {\n const int prev_coef_contexts_to_update = cpi -> sf . use_fast_coef_updates == ONE_LOOP_REDUCED ? COEFF_CONTEXTS >> 1 : COEFF_CONTEXTS ;\n const int coef_band_to_update = cpi -> sf . use_fast_coef_updates == ONE_LOOP_REDUCED ? COEF_BANDS >> 1 : COEF_BANDS ;\n int updates = 0 ;\n int noupdates_before_first = 0 ;\n for ( i = 0 ;\n i < PLANE_TYPES ;\n ++ i ) {\n for ( j = 0 ;\n j < REF_TYPES ;\n ++ j ) {\n for ( k = 0 ;\n k < COEF_BANDS ;\n ++ k ) {\n for ( l = 0 ;\n l < BAND_COEFF_CONTEXTS ( k ) ;\n ++ l ) {\n for ( t = 0 ;\n t < entropy_nodes_update ;\n ++ t ) {\n vp9_prob newp = new_coef_probs [ i ] [ j ] [ k ] [ l ] [ t ] ;\n vp9_prob * oldp = old_coef_probs [ i ] [ j ] [ k ] [ l ] + t ;\n int s ;\n int u = 0 ;\n if ( l >= prev_coef_contexts_to_update || k >= coef_band_to_update ) {\n u = 0 ;\n }\n else {\n if ( t == PIVOT_NODE ) s = vp9_prob_diff_update_savings_search_model ( frame_branch_ct [ i ] [ j ] [ k ] [ l ] [ 0 ] , old_coef_probs [ i ] [ j ] [ k ] [ l ] , & newp , upd ) ;\n else s = vp9_prob_diff_update_savings_search ( frame_branch_ct [ i ] [ j ] [ k ] [ l ] [ t ] , * oldp , & newp , upd ) ;\n if ( s > 0 && newp != * oldp ) u = 1 ;\n }\n updates += u ;\n if ( u == 0 && updates == 0 ) {\n noupdates_before_first ++ ;\n continue ;\n }\n if ( u == 1 && updates == 1 ) {\n int v ;\n vp9_write_bit ( bc , 1 ) ;\n for ( v = 0 ;\n v < noupdates_before_first ;\n ++ v ) vp9_write ( bc , 0 , upd ) ;\n }\n vp9_write ( bc , u , upd ) ;\n if ( u ) {\n vp9_write_prob_diff_update ( bc , newp , * oldp ) ;\n * oldp = newp ;\n }\n }\n }\n }\n }\n }\n if ( updates == 0 ) {\n vp9_write_bit ( bc , 0 ) ;\n }\n return ;\n }\n default : assert ( 0 ) ;\n }\n }", "idx": 22133}
{"hash": -6024601983167898950, "project": "debian", "size": 12, "label": 0, "functionSource": "GList * nautilus_mime_types_group_get_mimetypes ( gint group_index ) {\n GList * mimetypes ;\n gint i ;\n g_return_val_if_fail ( group_index < G_N_ELEMENTS ( mimetype_groups ) , NULL ) ;\n mimetypes = NULL ;\n for ( i = 0 ;\n mimetype_groups [ group_index ] . mimetypes [ i ] ;\n i ++ ) {\n mimetypes = g_list_append ( mimetypes , mimetype_groups [ group_index ] . mimetypes [ i ] ) ;\n }\n return mimetypes ;\n }", "idx": 22134}
{"hash": -1102844685921778700, "project": "debian", "size": 7, "label": 0, "functionSource": "int archive_mstring_copy_mbs ( struct archive_mstring * aes , const char * mbs ) {\n if ( mbs == NULL ) {\n aes -> aes_set = 0 ;\n return ( 0 ) ;\n }\n return ( archive_mstring_copy_mbs_len ( aes , mbs , strlen ( mbs ) ) ) ;\n }", "idx": 22135}
{"hash": -4885528830177756816, "project": "debian", "size": 15, "label": 0, "functionSource": "static int sort_key_read ( MI_SORT_PARAM * sort_param , void * key ) {\n int error ;\n SORT_INFO * sort_info = sort_param -> sort_info ;\n MI_INFO * info = sort_info -> info ;\n DBUG_ENTER ( \"sort_key_read\" ) ;\n if ( ( error = sort_get_next_record ( sort_param ) ) ) DBUG_RETURN ( error ) ;\n if ( info -> state -> records == sort_info -> max_records ) {\n mi_check_print_error ( sort_info -> param , \"Key %d - Found too many records;\n Can't continue\" , sort_param -> key + 1 ) ;\n DBUG_RETURN ( 1 ) ;\n }\n sort_param -> real_key_length = ( info -> s -> rec_reflength + _mi_make_key ( info , sort_param -> key , ( uchar * ) key , sort_param -> record , sort_param -> filepos ) ) ;\n # ifdef HAVE_purify bzero ( key + sort_param -> real_key_length , ( sort_param -> key_length - sort_param -> real_key_length ) ) ;\n # endif DBUG_RETURN ( sort_write_record ( sort_param ) ) ;\n }", "idx": 22136}
{"hash": -6126432314261451839, "project": "debian", "size": 16, "label": 1, "functionSource": "int gs_nulldevice ( gs_gstate * pgs ) {\n int code = 0 ;\n if ( pgs -> device == 0 || ! gx_device_is_null ( pgs -> device ) ) {\n gx_device * ndev ;\n code = gs_copydevice ( & ndev , ( const gx_device * ) & gs_null_device , pgs -> memory ) ;\n if ( code < 0 ) return code ;\n rc_init ( ndev , pgs -> memory , 0 ) ;\n if ( pgs -> device != NULL ) {\n if ( ( code = dev_proc ( pgs -> device , get_profile ) ( pgs -> device , & ( ndev -> icc_struct ) ) ) < 0 ) return code ;\n rc_increment ( ndev -> icc_struct ) ;\n set_dev_proc ( ndev , get_profile , gx_default_get_profile ) ;\n }\n if ( ( code = gs_setdevice_no_erase ( pgs , ndev ) ) < 0 ) gs_free_object ( pgs -> memory , ndev , \"gs_copydevice(device)\" ) ;\n }\n return code ;\n }", "idx": 22137}
{"hash": 1020583704101101585, "project": "chrome", "size": 8, "label": 0, "functionSource": "static void LaunchPermissionUpdateInfoBar ( JNIEnv * env , const JavaParamRef < jclass > & clazz , const JavaParamRef < jobject > & tab , const JavaParamRef < jstring > & jpermission , jlong callback_id ) {\n TabAndroid * tab_android = TabAndroid : : GetNativeTab ( env , tab ) ;\n std : : string permission = base : : android : : ConvertJavaStringToUTF8 ( env , jpermission ) ;\n scoped_ptr < DownloadControllerAndroid : : AcquireFileAccessPermissionCallback > cb ( reinterpret_cast < DownloadControllerAndroid : : AcquireFileAccessPermissionCallback * > ( callback_id ) ) ;\n std : : vector < std : : string > permissions ;\n permissions . push_back ( permission ) ;\n PermissionUpdateInfoBarDelegate : : Create ( tab_android -> web_contents ( ) , permissions , IDS_MISSING_STORAGE_PERMISSION_DOWNLOAD_EDUCATION_TEXT , * cb ) ;\n }", "idx": 22138}
{"hash": -3559021711340554904, "project": "debian", "size": 8, "label": 0, "functionSource": "static bool contain_volatile_functions_walker ( Node * node , void * context ) {\n if ( node == NULL ) return false ;\n if ( check_functions_in_node ( node , contain_volatile_functions_checker , context ) ) return true ;\n if ( IsA ( node , Query ) ) {\n return query_tree_walker ( ( Query * ) node , contain_volatile_functions_walker , context , 0 ) ;\n }\n return expression_tree_walker ( node , contain_volatile_functions_walker , context ) ;\n }", "idx": 22139}
{"hash": -1983921383858884161, "project": "debian", "size": 16, "label": 1, "functionSource": "static int ipvideo_decode_block_opcode_0x4 ( IpvideoContext * s ) {\n int x , y ;\n unsigned char B , BL , BH ;\n if ( ! s -> is_16bpp ) {\n B = bytestream2_get_byte ( & s -> stream_ptr ) ;\n }\n else {\n B = bytestream2_get_byte ( & s -> mv_ptr ) ;\n }\n BL = B & 0x0F ;\n BH = ( B >> 4 ) & 0x0F ;\n x = - 8 + BL ;\n y = - 8 + BH ;\n av_dlog ( NULL , \" motion byte = %d, (x, y) = (%d, %d)\\n\" , B , x , y ) ;\n return copy_from ( s , & s -> last_frame , x , y ) ;\n }", "idx": 22140}
{"hash": 8572106347813672436, "project": "debian", "size": 8, "label": 0, "functionSource": "static inline int verify_sec_ctx_len ( const void * p ) {\n const struct sadb_x_sec_ctx * sec_ctx = p ;\n int len = sec_ctx -> sadb_x_ctx_len ;\n if ( len > PAGE_SIZE ) return - EINVAL ;\n len = pfkey_sec_ctx_len ( sec_ctx ) ;\n if ( sec_ctx -> sadb_x_sec_len != len ) return - EINVAL ;\n return 0 ;\n }", "idx": 22141}
{"hash": -1102844685921778700, "project": "debian", "size": 4, "label": 0, "functionSource": "struct archive_wstring * archive_wstrappend_wchar ( struct archive_wstring * as , wchar_t c ) {\n if ( ( as = archive_wstring_append ( as , & c , 1 ) ) == NULL ) __archive_errx ( 1 , \"Out of memory\" ) ;\n return ( as ) ;\n }", "idx": 22142}
{"hash": 2713698759296604855, "project": "debian", "size": 18, "label": 0, "functionSource": "void ff_mpeg_flush ( AVCodecContext * avctx ) {\n int i ;\n MpegEncContext * s = avctx -> priv_data ;\n if ( s == NULL || s -> picture == NULL ) return ;\n for ( i = 0 ;\n i < MAX_PICTURE_COUNT ;\n i ++ ) ff_mpeg_unref_picture ( s , & s -> picture [ i ] ) ;\n s -> current_picture_ptr = s -> last_picture_ptr = s -> next_picture_ptr = NULL ;\n s -> mb_x = s -> mb_y = 0 ;\n s -> parse_context . state = - 1 ;\n s -> parse_context . frame_start_found = 0 ;\n s -> parse_context . overread = 0 ;\n s -> parse_context . overread_index = 0 ;\n s -> parse_context . index = 0 ;\n s -> parse_context . last_index = 0 ;\n s -> bitstream_buffer_size = 0 ;\n s -> pp_time = 0 ;\n }", "idx": 22143}
{"hash": 6980637897759012306, "project": "chrome", "size": 25, "label": 0, "functionSource": "void evsignal_dealloc ( struct event_base * base ) {\n int i = 0 ;\n if ( base -> sig . ev_signal_added ) {\n event_del ( & base -> sig . ev_signal ) ;\n base -> sig . ev_signal_added = 0 ;\n }\n for ( i = 0 ;\n i < NSIG ;\n ++ i ) {\n if ( i < base -> sig . sh_old_max && base -> sig . sh_old [ i ] != NULL ) _evsignal_restore_handler ( base , i ) ;\n }\n if ( base -> sig . ev_signal_pair [ 0 ] != - 1 ) {\n EVUTIL_CLOSESOCKET ( base -> sig . ev_signal_pair [ 0 ] ) ;\n base -> sig . ev_signal_pair [ 0 ] = - 1 ;\n }\n if ( base -> sig . ev_signal_pair [ 1 ] != - 1 ) {\n EVUTIL_CLOSESOCKET ( base -> sig . ev_signal_pair [ 1 ] ) ;\n base -> sig . ev_signal_pair [ 1 ] = - 1 ;\n }\n base -> sig . sh_old_max = 0 ;\n if ( base -> sig . sh_old ) {\n free ( base -> sig . sh_old ) ;\n base -> sig . sh_old = NULL ;\n }\n }", "idx": 22144}
{"hash": 4976989049001279223, "project": "debian", "size": 4, "label": 0, "functionSource": "void http_parser_clear ( HTTPParser * parser ) {\n _http_parser_init ( parser ) ;\n mime_parser_clear ( & parser -> m_mime_parser ) ;\n }", "idx": 22145}
{"hash": -2928324134072492299, "project": "debian", "size": 70, "label": 0, "functionSource": "static int skinny_calls_packet ( void * ptr _U_ , packet_info * pinfo , epan_dissect_t * edt _U_ , const void * skinny_info ) {\n voip_calls_tapinfo_t * tapinfo = & the_tapinfo_struct ;\n GList * list ;\n voip_calls_info_t * callsinfo = NULL ;\n address * phone ;\n const skinny_info_t * si = ( const skinny_info_t * ) skinny_info ;\n skinny_calls_info_t * tmp_skinnyinfo ;\n gchar * comment ;\n if ( si == NULL || ( si -> callId == 0 && si -> passThruId == 0 ) ) return 0 ;\n list = g_list_first ( tapinfo -> callsinfo_list ) ;\n while ( list ) {\n voip_calls_info_t * tmp_listinfo = ( voip_calls_info_t * ) list -> data ;\n if ( tmp_listinfo -> protocol == VOIP_SKINNY ) {\n tmp_skinnyinfo = ( skinny_calls_info_t * ) tmp_listinfo -> prot_info ;\n if ( tmp_skinnyinfo -> callId == si -> callId || tmp_skinnyinfo -> callId == si -> passThruId ) {\n callsinfo = ( voip_calls_info_t * ) ( list -> data ) ;\n break ;\n }\n }\n list = g_list_next ( list ) ;\n }\n if ( si -> messId >= 256 ) phone = & ( pinfo -> dst ) ;\n else phone = & ( pinfo -> src ) ;\n if ( callsinfo == NULL ) {\n callsinfo = ( voip_calls_info_t * ) g_malloc0 ( sizeof ( voip_calls_info_t ) ) ;\n callsinfo -> call_state = VOIP_NO_STATE ;\n callsinfo -> call_active_state = VOIP_ACTIVE ;\n callsinfo -> from_identity = g_strdup ( \"\" ) ;\n callsinfo -> to_identity = g_strdup ( \"\" ) ;\n callsinfo -> prot_info = g_malloc ( sizeof ( skinny_calls_info_t ) ) ;\n callsinfo -> free_prot_info = g_free ;\n tmp_skinnyinfo = ( skinny_calls_info_t * ) callsinfo -> prot_info ;\n tmp_skinnyinfo -> callId = si -> callId ? si -> callId : si -> passThruId ;\n callsinfo -> npackets = 1 ;\n COPY_ADDRESS ( & ( callsinfo -> initial_speaker ) , phone ) ;\n callsinfo -> protocol = VOIP_SKINNY ;\n callsinfo -> call_num = tapinfo -> ncalls ++ ;\n callsinfo -> start_fd = pinfo -> fd ;\n callsinfo -> start_rel_ts = pinfo -> rel_ts ;\n callsinfo -> stop_fd = pinfo -> fd ;\n callsinfo -> stop_rel_ts = pinfo -> rel_ts ;\n callsinfo -> selected = FALSE ;\n tapinfo -> callsinfo_list = g_list_prepend ( tapinfo -> callsinfo_list , callsinfo ) ;\n }\n else {\n if ( si -> callingParty ) {\n g_free ( callsinfo -> from_identity ) ;\n callsinfo -> from_identity = g_strdup ( si -> callingParty ) ;\n }\n if ( si -> calledParty ) {\n g_free ( callsinfo -> to_identity ) ;\n callsinfo -> to_identity = g_strdup ( si -> calledParty ) ;\n }\n if ( ( si -> callState > 0 ) && ( si -> callState < ( sizeof ( skinny_tap_voip_state ) / sizeof ( skinny_tap_voip_state [ 0 ] ) ) ) ) callsinfo -> call_state = skinny_tap_voip_state [ si -> callState ] ;\n callsinfo -> stop_fd = pinfo -> fd ;\n callsinfo -> stop_rel_ts = pinfo -> rel_ts ;\n ++ ( callsinfo -> npackets ) ;\n }\n if ( si -> callId ) {\n if ( si -> passThruId ) comment = g_strdup_printf ( \"CallId = %u, PTId = %u\" , si -> callId , si -> passThruId ) ;\n else comment = g_strdup_printf ( \"CallId = %u, LineId = %u\" , si -> callId , si -> lineId ) ;\n }\n else {\n if ( si -> passThruId ) comment = g_strdup_printf ( \"PTId = %u\" , si -> passThruId ) ;\n else comment = NULL ;\n }\n add_to_graph ( tapinfo , pinfo , si -> messageName , comment , callsinfo -> call_num , & ( pinfo -> src ) , & ( pinfo -> dst ) , 1 ) ;\n g_free ( comment ) ;\n return 1 ;\n }", "idx": 22146}
{"hash": 6323824267898511453, "project": "debian", "size": 18, "label": 0, "functionSource": "static void lab_to_rgb ( fz_context * ctx , const fz_colorspace * cs , const float * lab , float * rgb ) {\n float lstar , astar , bstar , l , m , n , x , y , z , r , g , b ;\n lstar = lab [ 0 ] ;\n astar = lab [ 1 ] ;\n bstar = lab [ 2 ] ;\n m = ( lstar + 16 ) / 116 ;\n l = m + astar / 500 ;\n n = m - bstar / 200 ;\n x = fung ( l ) ;\n y = fung ( m ) ;\n z = fung ( n ) ;\n r = ( 3.240449f * x + - 1.537136f * y + - 0.498531f * z ) * 0.830026f ;\n g = ( - 0.969265f * x + 1.876011f * y + 0.041556f * z ) * 1.05452f ;\n b = ( 0.055643f * x + - 0.204026f * y + 1.057229f * z ) * 1.1003f ;\n rgb [ 0 ] = sqrtf ( fz_clamp ( r , 0 , 1 ) ) ;\n rgb [ 1 ] = sqrtf ( fz_clamp ( g , 0 , 1 ) ) ;\n rgb [ 2 ] = sqrtf ( fz_clamp ( b , 0 , 1 ) ) ;\n }", "idx": 22147}
{"hash": 6675626110148442062, "project": "debian", "size": 5, "label": 0, "functionSource": "static long sfile_seek ( jas_stream_obj_t * obj , long offset , int origin ) {\n FILE * fp ;\n fp = JAS_CAST ( FILE * , obj ) ;\n return fseek ( fp , offset , origin ) ;\n }", "idx": 22148}
{"hash": 5357882892791796049, "project": "debian", "size": 5, "label": 0, "functionSource": "static uint32_t e1000e_mac_read_clr4 ( E1000ECore * core , int index ) {\n uint32_t ret = core -> mac [ index ] ;\n core -> mac [ index ] = 0 ;\n return ret ;\n }", "idx": 22149}
{"hash": -3819889754140204145, "project": "debian", "size": 3, "label": 0, "functionSource": "METHOD ( x509_t , create_policy_mapping_enumerator , enumerator_t * , private_x509_cert_t * this ) {\n return this -> policy_mappings -> create_enumerator ( this -> policy_mappings ) ;\n }", "idx": 22150}
{"hash": 3887066622454352196, "project": "chrome", "size": 88, "label": 0, "functionSource": "static void joint_motion_search ( VP9_COMP * cpi , MACROBLOCK * x , BLOCK_SIZE bsize , int_mv * frame_mv , int mi_row , int mi_col , int_mv single_newmv [ MAX_REF_FRAMES ] , int * rate_mv ) {\n const int pw = 4 * num_4x4_blocks_wide_lookup [ bsize ] ;\n const int ph = 4 * num_4x4_blocks_high_lookup [ bsize ] ;\n MACROBLOCKD * xd = & x -> e_mbd ;\n MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] . src_mi -> mbmi ;\n const int refs [ 2 ] = {\n mbmi -> ref_frame [ 0 ] , mbmi -> ref_frame [ 1 ] < 0 ? 0 : mbmi -> ref_frame [ 1 ] }\n ;\n int_mv ref_mv [ 2 ] ;\n int ite , ref ;\n uint8_t * second_pred = vpx_memalign ( 16 , pw * ph * sizeof ( uint8_t ) ) ;\n const InterpKernel * kernel = vp9_get_interp_kernel ( mbmi -> interp_filter ) ;\n struct buf_2d backup_yv12 [ 2 ] [ MAX_MB_PLANE ] ;\n struct buf_2d scaled_first_yv12 = xd -> plane [ 0 ] . pre [ 0 ] ;\n int last_besterr [ 2 ] = {\n INT_MAX , INT_MAX }\n ;\n const YV12_BUFFER_CONFIG * const scaled_ref_frame [ 2 ] = {\n vp9_get_scaled_ref_frame ( cpi , mbmi -> ref_frame [ 0 ] ) , vp9_get_scaled_ref_frame ( cpi , mbmi -> ref_frame [ 1 ] ) }\n ;\n for ( ref = 0 ;\n ref < 2 ;\n ++ ref ) {\n ref_mv [ ref ] = mbmi -> ref_mvs [ refs [ ref ] ] [ 0 ] ;\n if ( scaled_ref_frame [ ref ] ) {\n int i ;\n for ( i = 0 ;\n i < MAX_MB_PLANE ;\n i ++ ) backup_yv12 [ ref ] [ i ] = xd -> plane [ i ] . pre [ ref ] ;\n vp9_setup_pre_planes ( xd , ref , scaled_ref_frame [ ref ] , mi_row , mi_col , NULL ) ;\n }\n frame_mv [ refs [ ref ] ] . as_int = single_newmv [ refs [ ref ] ] . as_int ;\n }\n for ( ite = 0 ;\n ite < 4 ;\n ite ++ ) {\n struct buf_2d ref_yv12 [ 2 ] ;\n int bestsme = INT_MAX ;\n int sadpb = x -> sadperbit16 ;\n MV tmp_mv ;\n int search_range = 3 ;\n int tmp_col_min = x -> mv_col_min ;\n int tmp_col_max = x -> mv_col_max ;\n int tmp_row_min = x -> mv_row_min ;\n int tmp_row_max = x -> mv_row_max ;\n int id = ite % 2 ;\n ref_yv12 [ 0 ] = xd -> plane [ 0 ] . pre [ 0 ] ;\n ref_yv12 [ 1 ] = xd -> plane [ 0 ] . pre [ 1 ] ;\n vp9_build_inter_predictor ( ref_yv12 [ ! id ] . buf , ref_yv12 [ ! id ] . stride , second_pred , pw , & frame_mv [ refs [ ! id ] ] . as_mv , & xd -> block_refs [ ! id ] -> sf , pw , ph , 0 , kernel , MV_PRECISION_Q3 , mi_col * MI_SIZE , mi_row * MI_SIZE ) ;\n if ( id ) xd -> plane [ 0 ] . pre [ 0 ] = ref_yv12 [ id ] ;\n vp9_set_mv_search_range ( x , & ref_mv [ id ] . as_mv ) ;\n tmp_mv = frame_mv [ refs [ id ] ] . as_mv ;\n tmp_mv . col >>= 3 ;\n tmp_mv . row >>= 3 ;\n bestsme = vp9_refining_search_8p_c ( x , & tmp_mv , sadpb , search_range , & cpi -> fn_ptr [ bsize ] , & ref_mv [ id ] . as_mv , second_pred ) ;\n if ( bestsme < INT_MAX ) bestsme = vp9_get_mvpred_av_var ( x , & tmp_mv , & ref_mv [ id ] . as_mv , second_pred , & cpi -> fn_ptr [ bsize ] , 1 ) ;\n x -> mv_col_min = tmp_col_min ;\n x -> mv_col_max = tmp_col_max ;\n x -> mv_row_min = tmp_row_min ;\n x -> mv_row_max = tmp_row_max ;\n if ( bestsme < INT_MAX ) {\n int dis ;\n unsigned int sse ;\n bestsme = cpi -> find_fractional_mv_step ( x , & tmp_mv , & ref_mv [ id ] . as_mv , cpi -> common . allow_high_precision_mv , x -> errorperbit , & cpi -> fn_ptr [ bsize ] , 0 , cpi -> sf . mv . subpel_iters_per_step , NULL , x -> nmvjointcost , x -> mvcost , & dis , & sse , second_pred , pw , ph ) ;\n }\n if ( id ) xd -> plane [ 0 ] . pre [ 0 ] = scaled_first_yv12 ;\n if ( bestsme < last_besterr [ id ] ) {\n frame_mv [ refs [ id ] ] . as_mv = tmp_mv ;\n last_besterr [ id ] = bestsme ;\n }\n else {\n break ;\n }\n }\n * rate_mv = 0 ;\n for ( ref = 0 ;\n ref < 2 ;\n ++ ref ) {\n if ( scaled_ref_frame [ ref ] ) {\n int i ;\n for ( i = 0 ;\n i < MAX_MB_PLANE ;\n i ++ ) xd -> plane [ i ] . pre [ ref ] = backup_yv12 [ ref ] [ i ] ;\n }\n * rate_mv += vp9_mv_bit_cost ( & frame_mv [ refs [ ref ] ] . as_mv , & mbmi -> ref_mvs [ refs [ ref ] ] [ 0 ] . as_mv , x -> nmvjointcost , x -> mvcost , MV_COST_WEIGHT ) ;\n }\n vpx_free ( second_pred ) ;\n }", "idx": 22151}
{"hash": 4180964683905830761, "project": "debian", "size": 3, "label": 0, "functionSource": "static void selinux_msg_msg_free_security ( struct msg_msg * msg ) {\n msg_msg_free_security ( msg ) ;\n }", "idx": 22152}
{"hash": -4299048894522449432, "project": "debian", "size": 25, "label": 0, "functionSource": "static void imc_imdct256 ( IMCContext * q , IMCChannel * chctx , int channels ) {\n int i ;\n float re , im ;\n float * dst1 = q -> out_samples ;\n float * dst2 = q -> out_samples + ( COEFFS - 1 ) ;\n for ( i = 0 ;\n i < COEFFS / 2 ;\n i ++ ) {\n q -> samples [ i ] . re = - ( q -> pre_coef1 [ i ] * chctx -> CWdecoded [ COEFFS - 1 - i * 2 ] ) - ( q -> pre_coef2 [ i ] * chctx -> CWdecoded [ i * 2 ] ) ;\n q -> samples [ i ] . im = ( q -> pre_coef2 [ i ] * chctx -> CWdecoded [ COEFFS - 1 - i * 2 ] ) - ( q -> pre_coef1 [ i ] * chctx -> CWdecoded [ i * 2 ] ) ;\n }\n q -> fft . fft_permute ( & q -> fft , q -> samples ) ;\n q -> fft . fft_calc ( & q -> fft , q -> samples ) ;\n for ( i = 0 ;\n i < COEFFS / 2 ;\n i ++ ) {\n re = ( q -> samples [ i ] . re * q -> post_cos [ i ] ) + ( - q -> samples [ i ] . im * q -> post_sin [ i ] ) ;\n im = ( - q -> samples [ i ] . im * q -> post_cos [ i ] ) - ( q -> samples [ i ] . re * q -> post_sin [ i ] ) ;\n * dst1 = ( q -> mdct_sine_window [ COEFFS - 1 - i * 2 ] * chctx -> last_fft_im [ i ] ) + ( q -> mdct_sine_window [ i * 2 ] * re ) ;\n * dst2 = ( q -> mdct_sine_window [ i * 2 ] * chctx -> last_fft_im [ i ] ) - ( q -> mdct_sine_window [ COEFFS - 1 - i * 2 ] * re ) ;\n dst1 += 2 ;\n dst2 -= 2 ;\n chctx -> last_fft_im [ i ] = im ;\n }\n }", "idx": 22153}
{"hash": 370610032569630438, "project": "debian", "size": 36, "label": 0, "functionSource": "int tls1_alert_code ( int code ) {\n switch ( code ) {\n case SSL_AD_CLOSE_NOTIFY : return ( SSL3_AD_CLOSE_NOTIFY ) ;\n case SSL_AD_UNEXPECTED_MESSAGE : return ( SSL3_AD_UNEXPECTED_MESSAGE ) ;\n case SSL_AD_BAD_RECORD_MAC : return ( SSL3_AD_BAD_RECORD_MAC ) ;\n case SSL_AD_DECRYPTION_FAILED : return ( TLS1_AD_DECRYPTION_FAILED ) ;\n case SSL_AD_RECORD_OVERFLOW : return ( TLS1_AD_RECORD_OVERFLOW ) ;\n case SSL_AD_DECOMPRESSION_FAILURE : return ( SSL3_AD_DECOMPRESSION_FAILURE ) ;\n case SSL_AD_HANDSHAKE_FAILURE : return ( SSL3_AD_HANDSHAKE_FAILURE ) ;\n case SSL_AD_NO_CERTIFICATE : return ( - 1 ) ;\n case SSL_AD_BAD_CERTIFICATE : return ( SSL3_AD_BAD_CERTIFICATE ) ;\n case SSL_AD_UNSUPPORTED_CERTIFICATE : return ( SSL3_AD_UNSUPPORTED_CERTIFICATE ) ;\n case SSL_AD_CERTIFICATE_REVOKED : return ( SSL3_AD_CERTIFICATE_REVOKED ) ;\n case SSL_AD_CERTIFICATE_EXPIRED : return ( SSL3_AD_CERTIFICATE_EXPIRED ) ;\n case SSL_AD_CERTIFICATE_UNKNOWN : return ( SSL3_AD_CERTIFICATE_UNKNOWN ) ;\n case SSL_AD_ILLEGAL_PARAMETER : return ( SSL3_AD_ILLEGAL_PARAMETER ) ;\n case SSL_AD_UNKNOWN_CA : return ( TLS1_AD_UNKNOWN_CA ) ;\n case SSL_AD_ACCESS_DENIED : return ( TLS1_AD_ACCESS_DENIED ) ;\n case SSL_AD_DECODE_ERROR : return ( TLS1_AD_DECODE_ERROR ) ;\n case SSL_AD_DECRYPT_ERROR : return ( TLS1_AD_DECRYPT_ERROR ) ;\n case SSL_AD_EXPORT_RESTRICTION : return ( TLS1_AD_EXPORT_RESTRICTION ) ;\n case SSL_AD_PROTOCOL_VERSION : return ( TLS1_AD_PROTOCOL_VERSION ) ;\n case SSL_AD_INSUFFICIENT_SECURITY : return ( TLS1_AD_INSUFFICIENT_SECURITY ) ;\n case SSL_AD_INTERNAL_ERROR : return ( TLS1_AD_INTERNAL_ERROR ) ;\n case SSL_AD_USER_CANCELLED : return ( TLS1_AD_USER_CANCELLED ) ;\n case SSL_AD_NO_RENEGOTIATION : return ( TLS1_AD_NO_RENEGOTIATION ) ;\n case SSL_AD_UNSUPPORTED_EXTENSION : return ( TLS1_AD_UNSUPPORTED_EXTENSION ) ;\n case SSL_AD_CERTIFICATE_UNOBTAINABLE : return ( TLS1_AD_CERTIFICATE_UNOBTAINABLE ) ;\n case SSL_AD_UNRECOGNIZED_NAME : return ( TLS1_AD_UNRECOGNIZED_NAME ) ;\n case SSL_AD_BAD_CERTIFICATE_STATUS_RESPONSE : return ( TLS1_AD_BAD_CERTIFICATE_STATUS_RESPONSE ) ;\n case SSL_AD_BAD_CERTIFICATE_HASH_VALUE : return ( TLS1_AD_BAD_CERTIFICATE_HASH_VALUE ) ;\n case SSL_AD_UNKNOWN_PSK_IDENTITY : return ( TLS1_AD_UNKNOWN_PSK_IDENTITY ) ;\n # if 0 case DTLS1_AD_MISSING_HANDSHAKE_MESSAGE : return ( DTLS1_AD_MISSING_HANDSHAKE_MESSAGE ) ;\n # endif default : return ( - 1 ) ;\n }\n }", "idx": 22154}
{"hash": -2386031673786599357, "project": "debian", "size": 34, "label": 0, "functionSource": "static gpgme_error_t gpgsm_keylist ( void * engine , const char * pattern , int secret_only , gpgme_keylist_mode_t mode ) {\n engine_gpgsm_t gpgsm = engine ;\n char * line ;\n gpgme_error_t err ;\n int list_mode = 0 ;\n if ( mode & GPGME_KEYLIST_MODE_LOCAL ) list_mode |= 1 ;\n if ( mode & GPGME_KEYLIST_MODE_EXTERN ) list_mode |= 2 ;\n if ( ! pattern ) pattern = \"\" ;\n if ( secret_only || ( mode & GPGME_KEYLIST_MODE_WITH_SECRET ) ) gpgsm_assuan_simple_command ( gpgsm -> assuan_ctx , \"GETINFO agent-check\" , NULL , NULL ) ;\n if ( asprintf ( & line , \"OPTION list-mode=%d\" , ( list_mode & 3 ) ) < 0 ) return gpg_error_from_syserror ( ) ;\n err = gpgsm_assuan_simple_command ( gpgsm -> assuan_ctx , line , NULL , NULL ) ;\n free ( line ) ;\n if ( err ) return err ;\n gpgsm_assuan_simple_command ( gpgsm -> assuan_ctx , ( mode & GPGME_KEYLIST_MODE_VALIDATE ) ? \"OPTION with-validation=1\" : \"OPTION with-validation=0\" , NULL , NULL ) ;\n gpgsm_assuan_simple_command ( gpgsm -> assuan_ctx , ( mode & GPGME_KEYLIST_MODE_EPHEMERAL ) ? \"OPTION with-ephemeral-keys=1\" : \"OPTION with-ephemeral-keys=0\" , NULL , NULL ) ;\n gpgsm_assuan_simple_command ( gpgsm -> assuan_ctx , ( mode & GPGME_KEYLIST_MODE_WITH_SECRET ) ? \"OPTION with-secret=1\" : \"OPTION with-secret=0\" , NULL , NULL ) ;\n line = malloc ( 15 + strlen ( pattern ) + 1 ) ;\n if ( ! line ) return gpg_error_from_syserror ( ) ;\n if ( secret_only ) {\n strcpy ( line , \"LISTSECRETKEYS \" ) ;\n strcpy ( & line [ 15 ] , pattern ) ;\n }\n else {\n strcpy ( line , \"LISTKEYS \" ) ;\n strcpy ( & line [ 9 ] , pattern ) ;\n }\n gpgsm_clear_fd ( gpgsm , INPUT_FD ) ;\n gpgsm_clear_fd ( gpgsm , OUTPUT_FD ) ;\n gpgsm_clear_fd ( gpgsm , MESSAGE_FD ) ;\n gpgsm -> inline_data = NULL ;\n err = start ( gpgsm , line ) ;\n free ( line ) ;\n return err ;\n }", "idx": 22155}
{"hash": 5360072031850965731, "project": "debian", "size": 5, "label": 0, "functionSource": "static void PPC_prep_io_writeb ( void * opaque , hwaddr addr , uint32_t value ) {\n sysctrl_t * sysctrl = opaque ;\n addr = prep_IO_address ( sysctrl , addr ) ;\n cpu_outb ( addr , value ) ;\n }", "idx": 22156}
{"hash": 3246343243711264189, "project": "debian", "size": 14, "label": 0, "functionSource": "static void process_downstream_ack ( int userid , int down_seq , int down_frag ) {\n if ( users [ userid ] . outpacket . len <= 0 ) return ;\n if ( users [ userid ] . outpacket . seqno != down_seq || users [ userid ] . outpacket . fragment != down_frag ) return ;\n users [ userid ] . outpacket . offset += users [ userid ] . outpacket . sentlen ;\n users [ userid ] . outpacket . sentlen = 0 ;\n users [ userid ] . outpacket . fragment ++ ;\n users [ userid ] . outfragresent = 0 ;\n if ( users [ userid ] . outpacket . offset >= users [ userid ] . outpacket . len ) {\n users [ userid ] . outpacket . len = 0 ;\n users [ userid ] . outpacket . offset = 0 ;\n users [ userid ] . outpacket . fragment -- ;\n # ifdef OUTPACKETQ_LEN get_from_outpacketq ( userid ) ;\n # endif }\n }", "idx": 22157}
{"hash": -9028269206303312561, "project": "debian", "size": 22, "label": 0, "functionSource": "static void xps_draw_one_radial_gradient ( xps_document * doc , const fz_matrix * ctm , struct stop * stops , int count , int extend , float x0 , float y0 , float r0 , float x1 , float y1 , float r1 ) {\n fz_shade * shade ;\n shade = fz_malloc_struct ( doc -> ctx , fz_shade ) ;\n FZ_INIT_STORABLE ( shade , 1 , fz_free_shade_imp ) ;\n shade -> colorspace = fz_device_rgb ( doc -> ctx ) ;\n shade -> bbox = fz_infinite_rect ;\n shade -> matrix = fz_identity ;\n shade -> use_background = 0 ;\n shade -> use_function = 1 ;\n shade -> type = FZ_RADIAL ;\n shade -> u . l_or_r . extend [ 0 ] = extend ;\n shade -> u . l_or_r . extend [ 1 ] = extend ;\n xps_sample_gradient_stops ( shade , stops , count ) ;\n shade -> u . l_or_r . coords [ 0 ] [ 0 ] = x0 ;\n shade -> u . l_or_r . coords [ 0 ] [ 1 ] = y0 ;\n shade -> u . l_or_r . coords [ 0 ] [ 2 ] = r0 ;\n shade -> u . l_or_r . coords [ 1 ] [ 0 ] = x1 ;\n shade -> u . l_or_r . coords [ 1 ] [ 1 ] = y1 ;\n shade -> u . l_or_r . coords [ 1 ] [ 2 ] = r1 ;\n fz_fill_shade ( doc -> dev , shade , ctm , 1 ) ;\n fz_drop_shade ( doc -> ctx , shade ) ;\n }", "idx": 22158}
{"hash": -4032982860280343776, "project": "chrome", "size": 380, "label": 1, "functionSource": "static void _SCSUFromUnicodeWithOffsets ( UConverterFromUnicodeArgs * pArgs , UErrorCode * pErrorCode ) {\n UConverter * cnv ;\n SCSUData * scsu ;\n const UChar * source , * sourceLimit ;\n uint8_t * target ;\n int32_t targetCapacity ;\n int32_t * offsets ;\n UBool isSingleByteMode ;\n uint8_t dynamicWindow ;\n uint32_t currentOffset ;\n uint32_t c , delta ;\n int32_t sourceIndex , nextSourceIndex ;\n int32_t length ;\n uint32_t offset ;\n UChar lead , trail ;\n int code ;\n int8_t window ;\n cnv = pArgs -> converter ;\n scsu = ( SCSUData * ) cnv -> extraInfo ;\n source = pArgs -> source ;\n sourceLimit = pArgs -> sourceLimit ;\n target = ( uint8_t * ) pArgs -> target ;\n targetCapacity = ( int32_t ) ( pArgs -> targetLimit - pArgs -> target ) ;\n offsets = pArgs -> offsets ;\n isSingleByteMode = scsu -> fromUIsSingleByteMode ;\n dynamicWindow = scsu -> fromUDynamicWindow ;\n currentOffset = scsu -> fromUDynamicOffsets [ dynamicWindow ] ;\n c = cnv -> fromUChar32 ;\n sourceIndex = c == 0 ? 0 : - 1 ;\n nextSourceIndex = 0 ;\n loop : if ( isSingleByteMode ) {\n if ( c != 0 && targetCapacity > 0 ) {\n goto getTrailSingle ;\n }\n while ( source < sourceLimit ) {\n if ( targetCapacity <= 0 ) {\n * pErrorCode = U_BUFFER_OVERFLOW_ERROR ;\n break ;\n }\n c = * source ++ ;\n ++ nextSourceIndex ;\n if ( ( c - 0x20 ) <= 0x5f ) {\n * target ++ = ( uint8_t ) c ;\n if ( offsets != NULL ) {\n * offsets ++ = sourceIndex ;\n }\n -- targetCapacity ;\n }\n else if ( c < 0x20 ) {\n if ( ( 1UL << c ) & 0x2601 ) {\n * target ++ = ( uint8_t ) c ;\n if ( offsets != NULL ) {\n * offsets ++ = sourceIndex ;\n }\n -- targetCapacity ;\n }\n else {\n c |= SQ0 << 8 ;\n length = 2 ;\n goto outputBytes ;\n }\n }\n else if ( ( delta = c - currentOffset ) <= 0x7f ) {\n * target ++ = ( uint8_t ) ( delta | 0x80 ) ;\n if ( offsets != NULL ) {\n * offsets ++ = sourceIndex ;\n }\n -- targetCapacity ;\n }\n else if ( U16_IS_SURROGATE ( c ) ) {\n if ( U16_IS_SURROGATE_LEAD ( c ) ) {\n getTrailSingle : lead = ( UChar ) c ;\n if ( source < sourceLimit ) {\n trail = * source ;\n if ( U16_IS_TRAIL ( trail ) ) {\n ++ source ;\n ++ nextSourceIndex ;\n c = U16_GET_SUPPLEMENTARY ( c , trail ) ;\n }\n else {\n * pErrorCode = U_ILLEGAL_CHAR_FOUND ;\n goto endloop ;\n }\n }\n else {\n break ;\n }\n }\n else {\n * pErrorCode = U_ILLEGAL_CHAR_FOUND ;\n goto endloop ;\n }\n if ( ( delta = c - currentOffset ) <= 0x7f ) {\n * target ++ = ( uint8_t ) ( delta | 0x80 ) ;\n if ( offsets != NULL ) {\n * offsets ++ = sourceIndex ;\n }\n -- targetCapacity ;\n }\n else if ( ( window = getWindow ( scsu -> fromUDynamicOffsets , c ) ) >= 0 ) {\n dynamicWindow = window ;\n currentOffset = scsu -> fromUDynamicOffsets [ dynamicWindow ] ;\n useDynamicWindow ( scsu , dynamicWindow ) ;\n c = ( ( uint32_t ) ( SC0 + dynamicWindow ) << 8 ) | ( c - currentOffset ) | 0x80 ;\n length = 2 ;\n goto outputBytes ;\n }\n else if ( ( code = getDynamicOffset ( c , & offset ) ) >= 0 ) {\n code -= 0x200 ;\n dynamicWindow = getNextDynamicWindow ( scsu ) ;\n currentOffset = scsu -> fromUDynamicOffsets [ dynamicWindow ] = offset ;\n useDynamicWindow ( scsu , dynamicWindow ) ;\n c = ( ( uint32_t ) SDX << 24 ) | ( ( uint32_t ) dynamicWindow << 21 ) | ( ( uint32_t ) code << 8 ) | ( c - currentOffset ) | 0x80 ;\n length = 4 ;\n goto outputBytes ;\n }\n else {\n isSingleByteMode = FALSE ;\n * target ++ = ( uint8_t ) SCU ;\n if ( offsets != NULL ) {\n * offsets ++ = sourceIndex ;\n }\n -- targetCapacity ;\n c = ( ( uint32_t ) lead << 16 ) | trail ;\n length = 4 ;\n goto outputBytes ;\n }\n }\n else if ( c < 0xa0 ) {\n c = ( c & 0x7f ) | ( SQ0 + 1 ) << 8 ;\n length = 2 ;\n goto outputBytes ;\n }\n else if ( c == 0xfeff || c >= 0xfff0 ) {\n c |= SQU << 16 ;\n length = 3 ;\n goto outputBytes ;\n }\n else {\n if ( ( window = getWindow ( scsu -> fromUDynamicOffsets , c ) ) >= 0 ) {\n if ( source >= sourceLimit || isInOffsetWindowOrDirect ( scsu -> fromUDynamicOffsets [ window ] , * source ) ) {\n dynamicWindow = window ;\n currentOffset = scsu -> fromUDynamicOffsets [ dynamicWindow ] ;\n useDynamicWindow ( scsu , dynamicWindow ) ;\n c = ( ( uint32_t ) ( SC0 + dynamicWindow ) << 8 ) | ( c - currentOffset ) | 0x80 ;\n length = 2 ;\n goto outputBytes ;\n }\n else {\n c = ( ( uint32_t ) ( SQ0 + window ) << 8 ) | ( c - scsu -> fromUDynamicOffsets [ window ] ) | 0x80 ;\n length = 2 ;\n goto outputBytes ;\n }\n }\n else if ( ( window = getWindow ( staticOffsets , c ) ) >= 0 ) {\n c = ( ( uint32_t ) ( SQ0 + window ) << 8 ) | ( c - staticOffsets [ window ] ) ;\n length = 2 ;\n goto outputBytes ;\n }\n else if ( ( code = getDynamicOffset ( c , & offset ) ) >= 0 ) {\n dynamicWindow = getNextDynamicWindow ( scsu ) ;\n currentOffset = scsu -> fromUDynamicOffsets [ dynamicWindow ] = offset ;\n useDynamicWindow ( scsu , dynamicWindow ) ;\n c = ( ( uint32_t ) ( SD0 + dynamicWindow ) << 16 ) | ( ( uint32_t ) code << 8 ) | ( c - currentOffset ) | 0x80 ;\n length = 3 ;\n goto outputBytes ;\n }\n else if ( ( uint32_t ) ( c - 0x3400 ) < ( 0xd800 - 0x3400 ) && ( source >= sourceLimit || ( uint32_t ) ( * source - 0x3400 ) < ( 0xd800 - 0x3400 ) ) ) {\n isSingleByteMode = FALSE ;\n c |= SCU << 16 ;\n length = 3 ;\n goto outputBytes ;\n }\n else {\n c |= SQU << 16 ;\n length = 3 ;\n goto outputBytes ;\n }\n }\n c = 0 ;\n sourceIndex = nextSourceIndex ;\n }\n }\n else {\n if ( c != 0 && targetCapacity > 0 ) {\n goto getTrailUnicode ;\n }\n while ( source < sourceLimit ) {\n if ( targetCapacity <= 0 ) {\n * pErrorCode = U_BUFFER_OVERFLOW_ERROR ;\n break ;\n }\n c = * source ++ ;\n ++ nextSourceIndex ;\n if ( ( uint32_t ) ( c - 0x3400 ) < ( 0xd800 - 0x3400 ) ) {\n if ( targetCapacity >= 2 ) {\n * target ++ = ( uint8_t ) ( c >> 8 ) ;\n * target ++ = ( uint8_t ) c ;\n if ( offsets != NULL ) {\n * offsets ++ = sourceIndex ;\n * offsets ++ = sourceIndex ;\n }\n targetCapacity -= 2 ;\n }\n else {\n length = 2 ;\n goto outputBytes ;\n }\n }\n else if ( ( uint32_t ) ( c - 0x3400 ) >= ( 0xf300 - 0x3400 ) ) {\n if ( ! ( source < sourceLimit && ( uint32_t ) ( * source - 0x3400 ) < ( 0xd800 - 0x3400 ) ) ) {\n if ( ( ( uint32_t ) ( c - 0x30 ) < 10 || ( uint32_t ) ( c - 0x61 ) < 26 || ( uint32_t ) ( c - 0x41 ) < 26 ) ) {\n isSingleByteMode = TRUE ;\n c |= ( ( uint32_t ) ( UC0 + dynamicWindow ) << 8 ) | c ;\n length = 2 ;\n goto outputBytes ;\n }\n else if ( ( window = getWindow ( scsu -> fromUDynamicOffsets , c ) ) >= 0 ) {\n isSingleByteMode = TRUE ;\n dynamicWindow = window ;\n currentOffset = scsu -> fromUDynamicOffsets [ dynamicWindow ] ;\n useDynamicWindow ( scsu , dynamicWindow ) ;\n c = ( ( uint32_t ) ( UC0 + dynamicWindow ) << 8 ) | ( c - currentOffset ) | 0x80 ;\n length = 2 ;\n goto outputBytes ;\n }\n else if ( ( code = getDynamicOffset ( c , & offset ) ) >= 0 ) {\n isSingleByteMode = TRUE ;\n dynamicWindow = getNextDynamicWindow ( scsu ) ;\n currentOffset = scsu -> fromUDynamicOffsets [ dynamicWindow ] = offset ;\n useDynamicWindow ( scsu , dynamicWindow ) ;\n c = ( ( uint32_t ) ( UD0 + dynamicWindow ) << 16 ) | ( ( uint32_t ) code << 8 ) | ( c - currentOffset ) | 0x80 ;\n length = 3 ;\n goto outputBytes ;\n }\n }\n length = 2 ;\n goto outputBytes ;\n }\n else if ( c < 0xe000 ) {\n if ( U16_IS_SURROGATE_LEAD ( c ) ) {\n getTrailUnicode : lead = ( UChar ) c ;\n if ( source < sourceLimit ) {\n trail = * source ;\n if ( U16_IS_TRAIL ( trail ) ) {\n ++ source ;\n ++ nextSourceIndex ;\n c = U16_GET_SUPPLEMENTARY ( c , trail ) ;\n }\n else {\n * pErrorCode = U_ILLEGAL_CHAR_FOUND ;\n goto endloop ;\n }\n }\n else {\n break ;\n }\n }\n else {\n * pErrorCode = U_ILLEGAL_CHAR_FOUND ;\n goto endloop ;\n }\n if ( ( window = getWindow ( scsu -> fromUDynamicOffsets , c ) ) >= 0 && ! ( source < sourceLimit && ( uint32_t ) ( * source - 0x3400 ) < ( 0xd800 - 0x3400 ) ) ) {\n isSingleByteMode = TRUE ;\n dynamicWindow = window ;\n currentOffset = scsu -> fromUDynamicOffsets [ dynamicWindow ] ;\n useDynamicWindow ( scsu , dynamicWindow ) ;\n c = ( ( uint32_t ) ( UC0 + dynamicWindow ) << 8 ) | ( c - currentOffset ) | 0x80 ;\n length = 2 ;\n goto outputBytes ;\n }\n else if ( source < sourceLimit && lead == * source && ( code = getDynamicOffset ( c , & offset ) ) >= 0 ) {\n isSingleByteMode = TRUE ;\n code -= 0x200 ;\n dynamicWindow = getNextDynamicWindow ( scsu ) ;\n currentOffset = scsu -> fromUDynamicOffsets [ dynamicWindow ] = offset ;\n useDynamicWindow ( scsu , dynamicWindow ) ;\n c = ( ( uint32_t ) UDX << 24 ) | ( ( uint32_t ) dynamicWindow << 21 ) | ( ( uint32_t ) code << 8 ) | ( c - currentOffset ) | 0x80 ;\n length = 4 ;\n goto outputBytes ;\n }\n else {\n c = ( ( uint32_t ) lead << 16 ) | trail ;\n length = 4 ;\n goto outputBytes ;\n }\n }\n else {\n c |= UQU << 16 ;\n length = 3 ;\n goto outputBytes ;\n }\n c = 0 ;\n sourceIndex = nextSourceIndex ;\n }\n }\n endloop : scsu -> fromUIsSingleByteMode = isSingleByteMode ;\n scsu -> fromUDynamicWindow = dynamicWindow ;\n cnv -> fromUChar32 = c ;\n pArgs -> source = source ;\n pArgs -> target = ( char * ) target ;\n pArgs -> offsets = offsets ;\n return ;\n outputBytes : if ( length <= targetCapacity ) {\n if ( offsets == NULL ) {\n switch ( length ) {\n case 4 : * target ++ = ( uint8_t ) ( c >> 24 ) ;\n U_FALLTHROUGH ;\n case 3 : * target ++ = ( uint8_t ) ( c >> 16 ) ;\n U_FALLTHROUGH ;\n case 2 : * target ++ = ( uint8_t ) ( c >> 8 ) ;\n U_FALLTHROUGH ;\n case 1 : * target ++ = ( uint8_t ) c ;\n U_FALLTHROUGH ;\n default : break ;\n }\n }\n else {\n switch ( length ) {\n case 4 : * target ++ = ( uint8_t ) ( c >> 24 ) ;\n * offsets ++ = sourceIndex ;\n U_FALLTHROUGH ;\n case 3 : * target ++ = ( uint8_t ) ( c >> 16 ) ;\n * offsets ++ = sourceIndex ;\n U_FALLTHROUGH ;\n case 2 : * target ++ = ( uint8_t ) ( c >> 8 ) ;\n * offsets ++ = sourceIndex ;\n U_FALLTHROUGH ;\n case 1 : * target ++ = ( uint8_t ) c ;\n * offsets ++ = sourceIndex ;\n U_FALLTHROUGH ;\n default : break ;\n }\n }\n targetCapacity -= length ;\n c = 0 ;\n sourceIndex = nextSourceIndex ;\n goto loop ;\n }\n else {\n uint8_t * p ;\n length -= targetCapacity ;\n p = ( uint8_t * ) cnv -> charErrorBuffer ;\n switch ( length ) {\n case 4 : * p ++ = ( uint8_t ) ( c >> 24 ) ;\n U_FALLTHROUGH ;\n case 3 : * p ++ = ( uint8_t ) ( c >> 16 ) ;\n U_FALLTHROUGH ;\n case 2 : * p ++ = ( uint8_t ) ( c >> 8 ) ;\n U_FALLTHROUGH ;\n case 1 : * p = ( uint8_t ) c ;\n U_FALLTHROUGH ;\n default : break ;\n }\n cnv -> charErrorBufferLength = ( int8_t ) length ;\n c >>= 8 * length ;\n switch ( targetCapacity ) {\n case 3 : * target ++ = ( uint8_t ) ( c >> 16 ) ;\n if ( offsets != NULL ) {\n * offsets ++ = sourceIndex ;\n }\n U_FALLTHROUGH ;\n case 2 : * target ++ = ( uint8_t ) ( c >> 8 ) ;\n if ( offsets != NULL ) {\n * offsets ++ = sourceIndex ;\n }\n U_FALLTHROUGH ;\n case 1 : * target ++ = ( uint8_t ) c ;\n if ( offsets != NULL ) {\n * offsets ++ = sourceIndex ;\n }\n U_FALLTHROUGH ;\n default : break ;\n }\n targetCapacity = 0 ;\n * pErrorCode = U_BUFFER_OVERFLOW_ERROR ;\n c = 0 ;\n goto endloop ;\n }\n }", "idx": 22159}
{"hash": -1950979830238945732, "project": "debian", "size": 34, "label": 0, "functionSource": "static int path_to_hinter ( t1_hinter * h , gx_path * path ) {\n int code ;\n gs_path_enum penum ;\n gs_fixed_point pts [ 3 ] ;\n gs_fixed_point p = {\n 0 , 0 }\n ;\n bool first = true ;\n int op ;\n code = gx_path_enum_init ( & penum , path ) ;\n if ( code < 0 ) return code ;\n while ( ( op = gx_path_enum_next ( & penum , pts ) ) != 0 ) {\n switch ( op ) {\n case gs_pe_moveto : if ( first ) {\n first = false ;\n p = pts [ 0 ] ;\n code = t1_hinter__rmoveto ( h , p . x , p . y ) ;\n }\n else code = t1_hinter__rmoveto ( h , pts [ 0 ] . x - p . x , pts [ 0 ] . y - p . y ) ;\n break ;\n case gs_pe_lineto : case gs_pe_gapto : code = t1_hinter__rlineto ( h , pts [ 0 ] . x - p . x , pts [ 0 ] . y - p . y ) ;\n break ;\n case gs_pe_curveto : code = t1_hinter__rcurveto ( h , pts [ 0 ] . x - p . x , pts [ 0 ] . y - p . y , pts [ 1 ] . x - pts [ 0 ] . x , pts [ 1 ] . y - pts [ 0 ] . y , pts [ 2 ] . x - pts [ 1 ] . x , pts [ 2 ] . y - pts [ 1 ] . y ) ;\n pts [ 0 ] = pts [ 2 ] ;\n break ;\n case gs_pe_closepath : code = t1_hinter__closepath ( h ) ;\n break ;\n default : return_error ( gs_error_unregistered ) ;\n }\n if ( code < 0 ) return code ;\n p = pts [ 0 ] ;\n }\n return 0 ;\n }", "idx": 22160}
{"hash": -1335877942018854351, "project": "chrome", "size": 8, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( FastUnloadTest , PRE_ClosingLastTabFinishesUnload ) {\n NavigateToPage ( \"unload_sleep_before_cookie\" ) ;\n EXPECT_EQ ( 1 , browser ( ) -> tab_strip_model ( ) -> count ( ) ) ;\n EXPECT_EQ ( \"\" , GetCookies ( \"unload_sleep_before_cookie\" ) ) ;\n content : : WindowedNotificationObserver window_observer ( chrome : : NOTIFICATION_BROWSER_CLOSED , content : : NotificationService : : AllSources ( ) ) ;\n chrome : : CloseTab ( browser ( ) ) ;\n window_observer . Wait ( ) ;\n }", "idx": 22161}
{"hash": -5268859819325807498, "project": "debian", "size": 5, "label": 0, "functionSource": "static void get_one_value_callback ( gpointer key , gpointer value , gpointer callback_data ) {\n gpointer * returned_value ;\n returned_value = callback_data ;\n * returned_value = value ;\n }", "idx": 22162}
{"hash": 1366214969540455677, "project": "debian", "size": 90, "label": 1, "functionSource": "void name ## _free ( type * a ) ;\n # define DECLARE_ASN1_PRINT_FUNCTION ( stname ) DECLARE_ASN1_PRINT_FUNCTION_fname ( stname , stname ) # define DECLARE_ASN1_PRINT_FUNCTION_fname ( stname , fname ) int fname ## _print_ctx ( BIO * out , stname * x , int indent , const ASN1_PCTX * pctx ) ;\n # define D2I_OF ( type ) type * ( * ) ( type * * , const unsigned char * * , long ) # define I2D_OF ( type ) int ( * ) ( type * , unsigned char * * ) # define I2D_OF_const ( type ) int ( * ) ( const type * , unsigned char * * ) # define CHECKED_D2I_OF ( type , d2i ) ( ( d2i_of_void * ) ( 1 ? d2i : ( ( D2I_OF ( type ) ) 0 ) ) ) # define CHECKED_I2D_OF ( type , i2d ) ( ( i2d_of_void * ) ( 1 ? i2d : ( ( I2D_OF ( type ) ) 0 ) ) ) # define CHECKED_NEW_OF ( type , xnew ) ( ( void * ( * ) ( void ) ) ( 1 ? xnew : ( ( type * ( * ) ( void ) ) 0 ) ) ) # define CHECKED_PTR_OF ( type , p ) ( ( void * ) ( 1 ? p : ( type * ) 0 ) ) # define CHECKED_PPTR_OF ( type , p ) ( ( void * * ) ( 1 ? p : ( type * * ) 0 ) ) # define TYPEDEF_D2I_OF ( type ) typedef type * d2i_of_ ## type ( type * * , const unsigned char * * , long ) # define TYPEDEF_I2D_OF ( type ) typedef int i2d_of_ ## type ( type * , unsigned char * * ) # define TYPEDEF_D2I2D_OF ( type ) TYPEDEF_D2I_OF ( type ) ;\n TYPEDEF_I2D_OF ( type ) TYPEDEF_D2I2D_OF ( void ) ;\n # ifndef OPENSSL_EXPORT_VAR_AS_FUNCTION typedef const ASN1_ITEM ASN1_ITEM_EXP ;\n # define ASN1_ITEM_ptr ( iptr ) ( iptr ) # define ASN1_ITEM_ref ( iptr ) ( & ( iptr ## _it ) ) # define ASN1_ITEM_rptr ( ref ) ( & ( ref ## _it ) ) # define DECLARE_ASN1_ITEM ( name ) OPENSSL_EXTERN const ASN1_ITEM name ## _it ;\n # else typedef const ASN1_ITEM * ASN1_ITEM_EXP ( void ) ;\n # define ASN1_ITEM_ptr ( iptr ) ( iptr ( ) ) # define ASN1_ITEM_ref ( iptr ) ( iptr ## _it ) # define ASN1_ITEM_rptr ( ref ) ( ref ## _it ( ) ) # define DECLARE_ASN1_ITEM ( name ) const ASN1_ITEM * name ## _it ( void ) ;\n # endif # define ASN1_STRFLGS_ESC_2253 1 # define ASN1_STRFLGS_ESC_CTRL 2 # define ASN1_STRFLGS_ESC_MSB 4 # define ASN1_STRFLGS_ESC_QUOTE 8 # define CHARTYPE_PRINTABLESTRING 0x10 # define CHARTYPE_FIRST_ESC_2253 0x20 # define CHARTYPE_LAST_ESC_2253 0x40 # define ASN1_STRFLGS_UTF8_CONVERT 0x10 # define ASN1_STRFLGS_IGNORE_TYPE 0x20 # define ASN1_STRFLGS_SHOW_TYPE 0x40 # define ASN1_STRFLGS_DUMP_ALL 0x80 # define ASN1_STRFLGS_DUMP_UNKNOWN 0x100 # define ASN1_STRFLGS_DUMP_DER 0x200 # define ASN1_STRFLGS_ESC_2254 0x400 # define ASN1_STRFLGS_RFC2253 ( ASN1_STRFLGS_ESC_2253 | ASN1_STRFLGS_ESC_CTRL | ASN1_STRFLGS_ESC_MSB | ASN1_STRFLGS_UTF8_CONVERT | ASN1_STRFLGS_DUMP_UNKNOWN | ASN1_STRFLGS_DUMP_DER ) DEFINE_STACK_OF ( ASN1_INTEGER ) DEFINE_STACK_OF ( ASN1_GENERALSTRING ) DEFINE_STACK_OF ( ASN1_UTF8STRING ) typedef struct asn1_type_st {\n int type ;\n union {\n char * ptr ;\n ASN1_BOOLEAN boolean ;\n ASN1_STRING * asn1_string ;\n ASN1_OBJECT * object ;\n ASN1_INTEGER * integer ;\n ASN1_ENUMERATED * enumerated ;\n ASN1_BIT_STRING * bit_string ;\n ASN1_OCTET_STRING * octet_string ;\n ASN1_PRINTABLESTRING * printablestring ;\n ASN1_T61STRING * t61string ;\n ASN1_IA5STRING * ia5string ;\n ASN1_GENERALSTRING * generalstring ;\n ASN1_BMPSTRING * bmpstring ;\n ASN1_UNIVERSALSTRING * universalstring ;\n ASN1_UTCTIME * utctime ;\n ASN1_GENERALIZEDTIME * generalizedtime ;\n ASN1_VISIBLESTRING * visiblestring ;\n ASN1_UTF8STRING * utf8string ;\n ASN1_STRING * set ;\n ASN1_STRING * sequence ;\n ASN1_VALUE * asn1_value ;\n }\n value ;\n }\n ASN1_TYPE ;\n DEFINE_STACK_OF ( ASN1_TYPE ) typedef STACK_OF ( ASN1_TYPE ) ASN1_SEQUENCE_ANY ;\n DECLARE_ASN1_ENCODE_FUNCTIONS_const ( ASN1_SEQUENCE_ANY , ASN1_SEQUENCE_ANY ) DECLARE_ASN1_ENCODE_FUNCTIONS_const ( ASN1_SEQUENCE_ANY , ASN1_SET_ANY ) typedef struct BIT_STRING_BITNAME_st {\n int bitnum ;\n const char * lname ;\n const char * sname ;\n }\n BIT_STRING_BITNAME ;\n # define B_ASN1_TIME B_ASN1_UTCTIME | B_ASN1_GENERALIZEDTIME # define B_ASN1_PRINTABLE B_ASN1_NUMERICSTRING | B_ASN1_PRINTABLESTRING | B_ASN1_T61STRING | B_ASN1_IA5STRING | B_ASN1_BIT_STRING | B_ASN1_UNIVERSALSTRING | B_ASN1_BMPSTRING | B_ASN1_UTF8STRING | B_ASN1_SEQUENCE | B_ASN1_UNKNOWN # define B_ASN1_DIRECTORYSTRING B_ASN1_PRINTABLESTRING | B_ASN1_TELETEXSTRING | B_ASN1_BMPSTRING | B_ASN1_UNIVERSALSTRING | B_ASN1_UTF8STRING # define B_ASN1_DISPLAYTEXT B_ASN1_IA5STRING | B_ASN1_VISIBLESTRING | B_ASN1_BMPSTRING | B_ASN1_UTF8STRING DECLARE_ASN1_FUNCTIONS_fname ( ASN1_TYPE , ASN1_ANY , ASN1_TYPE ) int ASN1_TYPE_get ( const ASN1_TYPE * a ) ;\n void ASN1_TYPE_set ( ASN1_TYPE * a , int type , void * value ) ;\n int ASN1_TYPE_set1 ( ASN1_TYPE * a , int type , const void * value ) ;\n int ASN1_TYPE_cmp ( const ASN1_TYPE * a , const ASN1_TYPE * b ) ;\n ASN1_TYPE * ASN1_TYPE_pack_sequence ( const ASN1_ITEM * it , void * s , ASN1_TYPE * * t ) ;\n void * ASN1_TYPE_unpack_sequence ( const ASN1_ITEM * it , const ASN1_TYPE * t ) ;\n ASN1_OBJECT * ASN1_OBJECT_new ( void ) ;\n void ASN1_OBJECT_free ( ASN1_OBJECT * a ) ;\n int i2d_ASN1_OBJECT ( const ASN1_OBJECT * a , unsigned char * * pp ) ;\n ASN1_OBJECT * d2i_ASN1_OBJECT ( ASN1_OBJECT * * a , const unsigned char * * pp , long length ) ;\n DECLARE_ASN1_ITEM ( ASN1_OBJECT ) DEFINE_STACK_OF ( ASN1_OBJECT ) ASN1_STRING * ASN1_STRING_new ( void ) ;\n void ASN1_STRING_free ( ASN1_STRING * a ) ;\n void ASN1_STRING_clear_free ( ASN1_STRING * a ) ;\n int ASN1_STRING_copy ( ASN1_STRING * dst , const ASN1_STRING * str ) ;\n ASN1_STRING * ASN1_STRING_dup ( const ASN1_STRING * a ) ;\n ASN1_STRING * ASN1_STRING_type_new ( int type ) ;\n int ASN1_STRING_cmp ( const ASN1_STRING * a , const ASN1_STRING * b ) ;\n int ASN1_STRING_set ( ASN1_STRING * str , const void * data , int len ) ;\n void ASN1_STRING_set0 ( ASN1_STRING * str , void * data , int len ) ;\n int ASN1_STRING_length ( const ASN1_STRING * x ) ;\n void ASN1_STRING_length_set ( ASN1_STRING * x , int n ) ;\n int ASN1_STRING_type ( const ASN1_STRING * x ) ;\n DEPRECATEDIN_1_1_0 ( unsigned char * ASN1_STRING_data ( ASN1_STRING * x ) ) const unsigned char * ASN1_STRING_get0_data ( const ASN1_STRING * x ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_BIT_STRING ) int ASN1_BIT_STRING_set ( ASN1_BIT_STRING * a , unsigned char * d , int length ) ;\n int ASN1_BIT_STRING_set_bit ( ASN1_BIT_STRING * a , int n , int value ) ;\n int ASN1_BIT_STRING_get_bit ( const ASN1_BIT_STRING * a , int n ) ;\n int ASN1_BIT_STRING_check ( const ASN1_BIT_STRING * a , const unsigned char * flags , int flags_len ) ;\n int ASN1_BIT_STRING_name_print ( BIO * out , ASN1_BIT_STRING * bs , BIT_STRING_BITNAME * tbl , int indent ) ;\n int ASN1_BIT_STRING_num_asc ( const char * name , BIT_STRING_BITNAME * tbl ) ;\n int ASN1_BIT_STRING_set_asc ( ASN1_BIT_STRING * bs , const char * name , int value , BIT_STRING_BITNAME * tbl ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_INTEGER ) ASN1_INTEGER * d2i_ASN1_UINTEGER ( ASN1_INTEGER * * a , const unsigned char * * pp , long length ) ;\n ASN1_INTEGER * ASN1_INTEGER_dup ( const ASN1_INTEGER * x ) ;\n int ASN1_INTEGER_cmp ( const ASN1_INTEGER * x , const ASN1_INTEGER * y ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_ENUMERATED ) int ASN1_UTCTIME_check ( const ASN1_UTCTIME * a ) ;\n ASN1_UTCTIME * ASN1_UTCTIME_set ( ASN1_UTCTIME * s , time_t t ) ;\n ASN1_UTCTIME * ASN1_UTCTIME_adj ( ASN1_UTCTIME * s , time_t t , int offset_day , long offset_sec ) ;\n int ASN1_UTCTIME_set_string ( ASN1_UTCTIME * s , const char * str ) ;\n int ASN1_UTCTIME_cmp_time_t ( const ASN1_UTCTIME * s , time_t t ) ;\n int ASN1_GENERALIZEDTIME_check ( const ASN1_GENERALIZEDTIME * a ) ;\n ASN1_GENERALIZEDTIME * ASN1_GENERALIZEDTIME_set ( ASN1_GENERALIZEDTIME * s , time_t t ) ;\n ASN1_GENERALIZEDTIME * ASN1_GENERALIZEDTIME_adj ( ASN1_GENERALIZEDTIME * s , time_t t , int offset_day , long offset_sec ) ;\n int ASN1_GENERALIZEDTIME_set_string ( ASN1_GENERALIZEDTIME * s , const char * str ) ;\n int ASN1_TIME_diff ( int * pday , int * psec , const ASN1_TIME * from , const ASN1_TIME * to ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_OCTET_STRING ) ASN1_OCTET_STRING * ASN1_OCTET_STRING_dup ( const ASN1_OCTET_STRING * a ) ;\n int ASN1_OCTET_STRING_cmp ( const ASN1_OCTET_STRING * a , const ASN1_OCTET_STRING * b ) ;\n int ASN1_OCTET_STRING_set ( ASN1_OCTET_STRING * str , const unsigned char * data , int len ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_VISIBLESTRING ) DECLARE_ASN1_FUNCTIONS ( ASN1_UNIVERSALSTRING ) DECLARE_ASN1_FUNCTIONS ( ASN1_UTF8STRING ) DECLARE_ASN1_FUNCTIONS ( ASN1_NULL ) DECLARE_ASN1_FUNCTIONS ( ASN1_BMPSTRING )", "idx": 22163}
{"hash": 5575425611513297119, "project": "debian", "size": 59, "label": 0, "functionSource": "static int dtls1_reassemble_fragment ( SSL * s , const struct hm_header_st * msg_hdr , int * ok ) {\n hm_fragment * frag = NULL ;\n pitem * item = NULL ;\n int i = - 1 , is_complete ;\n unsigned char seq64be [ 8 ] ;\n unsigned long frag_len = msg_hdr -> frag_len ;\n if ( ( msg_hdr -> frag_off + frag_len ) > msg_hdr -> msg_len || msg_hdr -> msg_len > dtls1_max_handshake_message_len ( s ) ) goto err ;\n if ( frag_len == 0 ) return DTLS1_HM_FRAGMENT_RETRY ;\n memset ( seq64be , 0 , sizeof ( seq64be ) ) ;\n seq64be [ 6 ] = ( unsigned char ) ( msg_hdr -> seq >> 8 ) ;\n seq64be [ 7 ] = ( unsigned char ) msg_hdr -> seq ;\n item = pqueue_find ( s -> d1 -> buffered_messages , seq64be ) ;\n if ( item == NULL ) {\n frag = dtls1_hm_fragment_new ( msg_hdr -> msg_len , 1 ) ;\n if ( frag == NULL ) goto err ;\n memcpy ( & ( frag -> msg_header ) , msg_hdr , sizeof ( * msg_hdr ) ) ;\n frag -> msg_header . frag_len = frag -> msg_header . msg_len ;\n frag -> msg_header . frag_off = 0 ;\n }\n else {\n frag = ( hm_fragment * ) item -> data ;\n if ( frag -> msg_header . msg_len != msg_hdr -> msg_len ) {\n item = NULL ;\n frag = NULL ;\n goto err ;\n }\n }\n if ( frag -> reassembly == NULL ) {\n unsigned char devnull [ 256 ] ;\n while ( frag_len ) {\n i = s -> method -> ssl_read_bytes ( s , SSL3_RT_HANDSHAKE , NULL , devnull , frag_len > sizeof ( devnull ) ? sizeof ( devnull ) : frag_len , 0 ) ;\n if ( i <= 0 ) goto err ;\n frag_len -= i ;\n }\n return DTLS1_HM_FRAGMENT_RETRY ;\n }\n i = s -> method -> ssl_read_bytes ( s , SSL3_RT_HANDSHAKE , NULL , frag -> fragment + msg_hdr -> frag_off , frag_len , 0 ) ;\n if ( ( unsigned long ) i != frag_len ) i = - 1 ;\n if ( i <= 0 ) goto err ;\n RSMBLY_BITMASK_MARK ( frag -> reassembly , ( long ) msg_hdr -> frag_off , ( long ) ( msg_hdr -> frag_off + frag_len ) ) ;\n RSMBLY_BITMASK_IS_COMPLETE ( frag -> reassembly , ( long ) msg_hdr -> msg_len , is_complete ) ;\n if ( is_complete ) {\n OPENSSL_free ( frag -> reassembly ) ;\n frag -> reassembly = NULL ;\n }\n if ( item == NULL ) {\n item = pitem_new ( seq64be , frag ) ;\n if ( item == NULL ) {\n i = - 1 ;\n goto err ;\n }\n item = pqueue_insert ( s -> d1 -> buffered_messages , item ) ;\n OPENSSL_assert ( item != NULL ) ;\n }\n return DTLS1_HM_FRAGMENT_RETRY ;\n err : if ( item == NULL ) dtls1_hm_fragment_free ( frag ) ;\n * ok = 0 ;\n return i ;\n }", "idx": 22164}
{"hash": -2607754285145856562, "project": "debian", "size": 8, "label": 0, "functionSource": "static size_t fd_boot_image_size ( int media_type ) {\n switch ( media_type ) {\n case BOOT_MEDIA_1_2M_DISKETTE : return ( FD_1_2M_SIZE ) ;\n case BOOT_MEDIA_1_44M_DISKETTE : return ( FD_1_44M_SIZE ) ;\n case BOOT_MEDIA_2_88M_DISKETTE : return ( FD_2_88M_SIZE ) ;\n default : return ( 0 ) ;\n }\n }", "idx": 22165}
{"hash": 6080147530626246065, "project": "debian", "size": 192, "label": 1, "functionSource": "static int vc1_decode_p_mb_intfr ( VC1Context * v ) {\n MpegEncContext * s = & v -> s ;\n GetBitContext * gb = & s -> gb ;\n int i ;\n int mb_pos = s -> mb_x + s -> mb_y * s -> mb_stride ;\n int cbp = 0 ;\n int mqdiff , mquant ;\n int ttmb = v -> ttfrm ;\n int mb_has_coeffs = 1 ;\n int dmv_x , dmv_y ;\n int val ;\n int first_block = 1 ;\n int dst_idx , off ;\n int skipped , fourmv = 0 , twomv = 0 ;\n int block_cbp = 0 , pat , block_tt = 0 ;\n int idx_mbmode = 0 , mvbp ;\n int stride_y , fieldtx ;\n mquant = v -> pq ;\n if ( v -> skip_is_raw ) skipped = get_bits1 ( gb ) ;\n else skipped = v -> s . mbskip_table [ mb_pos ] ;\n if ( ! skipped ) {\n if ( v -> fourmvswitch ) idx_mbmode = get_vlc2 ( gb , v -> mbmode_vlc -> table , VC1_INTFR_4MV_MBMODE_VLC_BITS , 2 ) ;\n else idx_mbmode = get_vlc2 ( gb , v -> mbmode_vlc -> table , VC1_INTFR_NON4MV_MBMODE_VLC_BITS , 2 ) ;\n switch ( ff_vc1_mbmode_intfrp [ v -> fourmvswitch ] [ idx_mbmode ] [ 0 ] ) {\n case MV_PMODE_INTFR_4MV : fourmv = 1 ;\n v -> blk_mv_type [ s -> block_index [ 0 ] ] = 0 ;\n v -> blk_mv_type [ s -> block_index [ 1 ] ] = 0 ;\n v -> blk_mv_type [ s -> block_index [ 2 ] ] = 0 ;\n v -> blk_mv_type [ s -> block_index [ 3 ] ] = 0 ;\n break ;\n case MV_PMODE_INTFR_4MV_FIELD : fourmv = 1 ;\n v -> blk_mv_type [ s -> block_index [ 0 ] ] = 1 ;\n v -> blk_mv_type [ s -> block_index [ 1 ] ] = 1 ;\n v -> blk_mv_type [ s -> block_index [ 2 ] ] = 1 ;\n v -> blk_mv_type [ s -> block_index [ 3 ] ] = 1 ;\n break ;\n case MV_PMODE_INTFR_2MV_FIELD : twomv = 1 ;\n v -> blk_mv_type [ s -> block_index [ 0 ] ] = 1 ;\n v -> blk_mv_type [ s -> block_index [ 1 ] ] = 1 ;\n v -> blk_mv_type [ s -> block_index [ 2 ] ] = 1 ;\n v -> blk_mv_type [ s -> block_index [ 3 ] ] = 1 ;\n break ;\n case MV_PMODE_INTFR_1MV : v -> blk_mv_type [ s -> block_index [ 0 ] ] = 0 ;\n v -> blk_mv_type [ s -> block_index [ 1 ] ] = 0 ;\n v -> blk_mv_type [ s -> block_index [ 2 ] ] = 0 ;\n v -> blk_mv_type [ s -> block_index [ 3 ] ] = 0 ;\n break ;\n }\n if ( ff_vc1_mbmode_intfrp [ v -> fourmvswitch ] [ idx_mbmode ] [ 0 ] == MV_PMODE_INTFR_INTRA ) {\n s -> current_picture . f . motion_val [ 1 ] [ s -> block_index [ 0 ] ] [ 0 ] = 0 ;\n s -> current_picture . f . motion_val [ 1 ] [ s -> block_index [ 0 ] ] [ 1 ] = 0 ;\n s -> current_picture . f . mb_type [ mb_pos ] = MB_TYPE_INTRA ;\n s -> mb_intra = v -> is_intra [ s -> mb_x ] = 1 ;\n for ( i = 0 ;\n i < 6 ;\n i ++ ) v -> mb_type [ 0 ] [ s -> block_index [ i ] ] = 1 ;\n fieldtx = v -> fieldtx_plane [ mb_pos ] = get_bits1 ( gb ) ;\n mb_has_coeffs = get_bits1 ( gb ) ;\n if ( mb_has_coeffs ) cbp = 1 + get_vlc2 ( & v -> s . gb , v -> cbpcy_vlc -> table , VC1_CBPCY_P_VLC_BITS , 2 ) ;\n v -> s . ac_pred = v -> acpred_plane [ mb_pos ] = get_bits1 ( gb ) ;\n GET_MQUANT ( ) ;\n s -> current_picture . f . qscale_table [ mb_pos ] = mquant ;\n s -> y_dc_scale = s -> y_dc_scale_table [ mquant ] ;\n s -> c_dc_scale = s -> c_dc_scale_table [ mquant ] ;\n dst_idx = 0 ;\n for ( i = 0 ;\n i < 6 ;\n i ++ ) {\n s -> dc_val [ 0 ] [ s -> block_index [ i ] ] = 0 ;\n dst_idx += i >> 2 ;\n val = ( ( cbp >> ( 5 - i ) ) & 1 ) ;\n v -> mb_type [ 0 ] [ s -> block_index [ i ] ] = s -> mb_intra ;\n v -> a_avail = v -> c_avail = 0 ;\n if ( i == 2 || i == 3 || ! s -> first_slice_line ) v -> a_avail = v -> mb_type [ 0 ] [ s -> block_index [ i ] - s -> block_wrap [ i ] ] ;\n if ( i == 1 || i == 3 || s -> mb_x ) v -> c_avail = v -> mb_type [ 0 ] [ s -> block_index [ i ] - 1 ] ;\n vc1_decode_intra_block ( v , s -> block [ i ] , i , val , mquant , ( i & 4 ) ? v -> codingset2 : v -> codingset ) ;\n if ( ( i > 3 ) && ( s -> flags & CODEC_FLAG_GRAY ) ) continue ;\n v -> vc1dsp . vc1_inv_trans_8x8 ( s -> block [ i ] ) ;\n if ( i < 4 ) {\n stride_y = s -> linesize << fieldtx ;\n off = ( fieldtx ) ? ( ( i & 1 ) * 8 ) + ( ( i & 2 ) >> 1 ) * s -> linesize : ( i & 1 ) * 8 + 4 * ( i & 2 ) * s -> linesize ;\n }\n else {\n stride_y = s -> uvlinesize ;\n off = 0 ;\n }\n s -> dsp . put_signed_pixels_clamped ( s -> block [ i ] , s -> dest [ dst_idx ] + off , stride_y ) ;\n }\n }\n else {\n mb_has_coeffs = ff_vc1_mbmode_intfrp [ v -> fourmvswitch ] [ idx_mbmode ] [ 3 ] ;\n if ( mb_has_coeffs ) cbp = 1 + get_vlc2 ( & v -> s . gb , v -> cbpcy_vlc -> table , VC1_CBPCY_P_VLC_BITS , 2 ) ;\n if ( ff_vc1_mbmode_intfrp [ v -> fourmvswitch ] [ idx_mbmode ] [ 0 ] == MV_PMODE_INTFR_2MV_FIELD ) {\n v -> twomvbp = get_vlc2 ( gb , v -> twomvbp_vlc -> table , VC1_2MV_BLOCK_PATTERN_VLC_BITS , 1 ) ;\n }\n else {\n if ( ( ff_vc1_mbmode_intfrp [ v -> fourmvswitch ] [ idx_mbmode ] [ 0 ] == MV_PMODE_INTFR_4MV ) || ( ff_vc1_mbmode_intfrp [ v -> fourmvswitch ] [ idx_mbmode ] [ 0 ] == MV_PMODE_INTFR_4MV_FIELD ) ) {\n v -> fourmvbp = get_vlc2 ( gb , v -> fourmvbp_vlc -> table , VC1_4MV_BLOCK_PATTERN_VLC_BITS , 1 ) ;\n }\n }\n s -> mb_intra = v -> is_intra [ s -> mb_x ] = 0 ;\n for ( i = 0 ;\n i < 6 ;\n i ++ ) v -> mb_type [ 0 ] [ s -> block_index [ i ] ] = 0 ;\n fieldtx = v -> fieldtx_plane [ mb_pos ] = ff_vc1_mbmode_intfrp [ v -> fourmvswitch ] [ idx_mbmode ] [ 1 ] ;\n dst_idx = 0 ;\n if ( fourmv ) {\n mvbp = v -> fourmvbp ;\n for ( i = 0 ;\n i < 6 ;\n i ++ ) {\n if ( i < 4 ) {\n dmv_x = dmv_y = 0 ;\n val = ( ( mvbp >> ( 3 - i ) ) & 1 ) ;\n if ( val ) {\n get_mvdata_interlaced ( v , & dmv_x , & dmv_y , 0 ) ;\n }\n vc1_pred_mv_intfr ( v , i , dmv_x , dmv_y , 0 , v -> range_x , v -> range_y , v -> mb_type [ 0 ] ) ;\n vc1_mc_4mv_luma ( v , i , 0 ) ;\n }\n else if ( i == 4 ) {\n vc1_mc_4mv_chroma4 ( v ) ;\n }\n }\n }\n else if ( twomv ) {\n mvbp = v -> twomvbp ;\n dmv_x = dmv_y = 0 ;\n if ( mvbp & 2 ) {\n get_mvdata_interlaced ( v , & dmv_x , & dmv_y , 0 ) ;\n }\n vc1_pred_mv_intfr ( v , 0 , dmv_x , dmv_y , 2 , v -> range_x , v -> range_y , v -> mb_type [ 0 ] ) ;\n vc1_mc_4mv_luma ( v , 0 , 0 ) ;\n vc1_mc_4mv_luma ( v , 1 , 0 ) ;\n dmv_x = dmv_y = 0 ;\n if ( mvbp & 1 ) {\n get_mvdata_interlaced ( v , & dmv_x , & dmv_y , 0 ) ;\n }\n vc1_pred_mv_intfr ( v , 2 , dmv_x , dmv_y , 2 , v -> range_x , v -> range_y , v -> mb_type [ 0 ] ) ;\n vc1_mc_4mv_luma ( v , 2 , 0 ) ;\n vc1_mc_4mv_luma ( v , 3 , 0 ) ;\n vc1_mc_4mv_chroma4 ( v ) ;\n }\n else {\n mvbp = ff_vc1_mbmode_intfrp [ v -> fourmvswitch ] [ idx_mbmode ] [ 2 ] ;\n dmv_x = dmv_y = 0 ;\n if ( mvbp ) {\n get_mvdata_interlaced ( v , & dmv_x , & dmv_y , 0 ) ;\n }\n vc1_pred_mv_intfr ( v , 0 , dmv_x , dmv_y , 1 , v -> range_x , v -> range_y , v -> mb_type [ 0 ] ) ;\n vc1_mc_1mv ( v , 0 ) ;\n }\n if ( cbp ) GET_MQUANT ( ) ;\n s -> current_picture . f . qscale_table [ mb_pos ] = mquant ;\n if ( ! v -> ttmbf && cbp ) ttmb = get_vlc2 ( gb , ff_vc1_ttmb_vlc [ v -> tt_index ] . table , VC1_TTMB_VLC_BITS , 2 ) ;\n for ( i = 0 ;\n i < 6 ;\n i ++ ) {\n s -> dc_val [ 0 ] [ s -> block_index [ i ] ] = 0 ;\n dst_idx += i >> 2 ;\n val = ( ( cbp >> ( 5 - i ) ) & 1 ) ;\n if ( ! fieldtx ) off = ( i & 4 ) ? 0 : ( ( i & 1 ) * 8 + ( i & 2 ) * 4 * s -> linesize ) ;\n else off = ( i & 4 ) ? 0 : ( ( i & 1 ) * 8 + ( ( i > 1 ) * s -> linesize ) ) ;\n if ( val ) {\n pat = vc1_decode_p_block ( v , s -> block [ i ] , i , mquant , ttmb , first_block , s -> dest [ dst_idx ] + off , ( i & 4 ) ? s -> uvlinesize : ( s -> linesize << fieldtx ) , ( i & 4 ) && ( s -> flags & CODEC_FLAG_GRAY ) , & block_tt ) ;\n block_cbp |= pat << ( i << 2 ) ;\n if ( ! v -> ttmbf && ttmb < 8 ) ttmb = - 1 ;\n first_block = 0 ;\n }\n }\n }\n }\n else {\n s -> mb_intra = v -> is_intra [ s -> mb_x ] = 0 ;\n for ( i = 0 ;\n i < 6 ;\n i ++ ) {\n v -> mb_type [ 0 ] [ s -> block_index [ i ] ] = 0 ;\n s -> dc_val [ 0 ] [ s -> block_index [ i ] ] = 0 ;\n }\n s -> current_picture . f . mb_type [ mb_pos ] = MB_TYPE_SKIP ;\n s -> current_picture . f . qscale_table [ mb_pos ] = 0 ;\n v -> blk_mv_type [ s -> block_index [ 0 ] ] = 0 ;\n v -> blk_mv_type [ s -> block_index [ 1 ] ] = 0 ;\n v -> blk_mv_type [ s -> block_index [ 2 ] ] = 0 ;\n v -> blk_mv_type [ s -> block_index [ 3 ] ] = 0 ;\n vc1_pred_mv_intfr ( v , 0 , 0 , 0 , 1 , v -> range_x , v -> range_y , v -> mb_type [ 0 ] ) ;\n vc1_mc_1mv ( v , 0 ) ;\n }\n if ( s -> mb_x == s -> mb_width - 1 ) memmove ( v -> is_intra_base , v -> is_intra , sizeof ( v -> is_intra_base [ 0 ] ) * s -> mb_stride ) ;\n return 0 ;\n }", "idx": 22166}
{"hash": -1055531103257174901, "project": "debian", "size": 10, "label": 0, "functionSource": "static void sig_nick_changed ( CHANNEL_REC * channel , NICK_REC * nick , const char * oldnick ) {\n MODULE_CHANNEL_REC * mchannel ;\n LAST_MSG_REC * rec ;\n mchannel = MODULE_DATA ( channel ) ;\n rec = last_msg_find ( mchannel -> lastmsgs , oldnick ) ;\n if ( rec != NULL ) {\n g_free ( rec -> nick ) ;\n rec -> nick = g_strdup ( nick -> nick ) ;\n }\n }", "idx": 22167}
{"hash": -1102844685921778700, "project": "debian", "size": 5, "label": 0, "functionSource": "struct archive_string_conv * archive_string_conversion_from_charset ( struct archive * a , const char * charset , int best_effort ) {\n int flag = SCONV_FROM_CHARSET ;\n if ( best_effort ) flag |= SCONV_BEST_EFFORT ;\n return ( get_sconv_object ( a , charset , get_current_charset ( a ) , flag ) ) ;\n }", "idx": 22168}
{"hash": -4555950263653671147, "project": "debian", "size": 5, "label": 0, "functionSource": "static PyObject * string_sizeof ( PyStringObject * v ) {\n Py_ssize_t res ;\n res = PyStringObject_SIZE + PyString_GET_SIZE ( v ) * Py_TYPE ( v ) -> tp_itemsize ;\n return PyInt_FromSsize_t ( res ) ;\n }", "idx": 22169}
{"hash": 355220887711506893, "project": "debian", "size": 3, "label": 0, "functionSource": "Datum regexnesel ( PG_FUNCTION_ARGS ) {\n PG_RETURN_FLOAT8 ( patternsel ( fcinfo , Pattern_Type_Regex , true ) ) ;\n }", "idx": 22170}
{"hash": 6393050609822897742, "project": "debian", "size": 16, "label": 0, "functionSource": "static TRBCCode xhci_disable_slot ( XHCIState * xhci , unsigned int slotid ) {\n int i ;\n trace_usb_xhci_slot_disable ( slotid ) ;\n assert ( slotid >= 1 && slotid <= xhci -> numslots ) ;\n for ( i = 1 ;\n i <= 31 ;\n i ++ ) {\n if ( xhci -> slots [ slotid - 1 ] . eps [ i - 1 ] ) {\n xhci_disable_ep ( xhci , slotid , i ) ;\n }\n }\n xhci -> slots [ slotid - 1 ] . enabled = 0 ;\n xhci -> slots [ slotid - 1 ] . addressed = 0 ;\n xhci -> slots [ slotid - 1 ] . uport = NULL ;\n return CC_SUCCESS ;\n }", "idx": 22171}
{"hash": -7455544248455991006, "project": "debian", "size": 27, "label": 0, "functionSource": "int kvm_arch_insert_hw_breakpoint ( target_ulong addr , target_ulong len , int type ) {\n switch ( type ) {\n case GDB_BREAKPOINT_HW : len = 1 ;\n break ;\n case GDB_WATCHPOINT_WRITE : case GDB_WATCHPOINT_ACCESS : switch ( len ) {\n case 1 : break ;\n case 2 : case 4 : case 8 : if ( addr & ( len - 1 ) ) {\n return - EINVAL ;\n }\n break ;\n default : return - EINVAL ;\n }\n break ;\n default : return - ENOSYS ;\n }\n if ( nb_hw_breakpoint == 4 ) {\n return - ENOBUFS ;\n }\n if ( find_hw_breakpoint ( addr , len , type ) >= 0 ) {\n return - EEXIST ;\n }\n hw_breakpoint [ nb_hw_breakpoint ] . addr = addr ;\n hw_breakpoint [ nb_hw_breakpoint ] . len = len ;\n hw_breakpoint [ nb_hw_breakpoint ] . type = type ;\n nb_hw_breakpoint ++ ;\n return 0 ;\n }", "idx": 22172}
{"hash": -1315695702746584250, "project": "debian", "size": 3, "label": 0, "functionSource": "static void proto_tree_set_boolean ( field_info * fi , guint64 value ) {\n proto_tree_set_uint64 ( fi , value ) ;\n }", "idx": 22173}
{"hash": -7777331401175181229, "project": "debian", "size": 4, "label": 0, "functionSource": "static void sig_server_disconnected ( SERVER_REC * server ) {\n g_return_if_fail ( server != NULL ) ;\n printformat ( server , NULL , MSGLEVEL_CLIENTNOTICE , TXT_CONNECTION_LOST , server -> connrec -> address ) ;\n }", "idx": 22174}
{"hash": 583170025160259883, "project": "debian", "size": 41, "label": 1, "functionSource": "static int slirp_smb ( SlirpState * s , const char * exported_dir , struct in_addr vserver_addr ) {\n static int instance ;\n char smb_conf [ 128 ] ;\n char smb_cmdline [ 128 ] ;\n struct passwd * passwd ;\n FILE * f ;\n passwd = getpwuid ( geteuid ( ) ) ;\n if ( ! passwd ) {\n error_report ( \"failed to retrieve user name\" ) ;\n return - 1 ;\n }\n if ( access ( CONFIG_SMBD_COMMAND , F_OK ) ) {\n error_report ( \"could not find '%s', please install it\" , CONFIG_SMBD_COMMAND ) ;\n return - 1 ;\n }\n if ( access ( exported_dir , R_OK | X_OK ) ) {\n error_report ( \"error accessing shared directory '%s': %s\" , exported_dir , strerror ( errno ) ) ;\n return - 1 ;\n }\n snprintf ( s -> smb_dir , sizeof ( s -> smb_dir ) , \"/tmp/qemu-smb.%ld-%d\" , ( long ) getpid ( ) , instance ++ ) ;\n if ( mkdir ( s -> smb_dir , 0700 ) < 0 ) {\n error_report ( \"could not create samba server dir '%s'\" , s -> smb_dir ) ;\n return - 1 ;\n }\n snprintf ( smb_conf , sizeof ( smb_conf ) , \"%s/%s\" , s -> smb_dir , \"smb.conf\" ) ;\n f = fopen ( smb_conf , \"w\" ) ;\n if ( ! f ) {\n slirp_smb_cleanup ( s ) ;\n error_report ( \"could not create samba server configuration file '%s'\" , smb_conf ) ;\n return - 1 ;\n }\n fprintf ( f , \"[global]\\n\" \"private dir=%s\\n\" \"interfaces=127.0.0.1\\n\" \"bind interfaces only=yes\\n\" \"pid directory=%s\\n\" \"lock directory=%s\\n\" \"state directory=%s\\n\" \"cache directory=%s\\n\" \"ncalrpc dir=%scalrpc\\n\" \"log file=%s/log.smbd\\n\" \"smb passwd file=%s/smbpasswd\\n\" \"security = user\\n\" \"map to guest = Bad User\\n\" \"load printers = no\\n\" \"printing = bsd\\n\" \"disable spoolss = yes\\n\" \"usershare max shares = 0\\n\" \"[qemu]\\n\" \"path=%s\\n\" \"read only=no\\n\" \"guest ok=yes\\n\" \"force user=%s\\n\" , s -> smb_dir , s -> smb_dir , s -> smb_dir , s -> smb_dir , s -> smb_dir , s -> smb_dir , s -> smb_dir , s -> smb_dir , exported_dir , passwd -> pw_name ) ;\n fclose ( f ) ;\n snprintf ( smb_cmdline , sizeof ( smb_cmdline ) , \"%s -l %s -s %s\" , CONFIG_SMBD_COMMAND , s -> smb_dir , smb_conf ) ;\n if ( slirp_add_exec ( s -> slirp , 0 , smb_cmdline , & vserver_addr , 139 ) < 0 || slirp_add_exec ( s -> slirp , 0 , smb_cmdline , & vserver_addr , 445 ) < 0 ) {\n slirp_smb_cleanup ( s ) ;\n error_report ( \"conflicting/invalid smbserver address\" ) ;\n return - 1 ;\n }\n return 0 ;\n }", "idx": 22175}
{"hash": -1055531103257174901, "project": "debian", "size": 37, "label": 0, "functionSource": "void chat_completion_deinit ( void ) {\n while ( global_lastmsgs != NULL ) last_msg_destroy ( & global_lastmsgs , global_lastmsgs -> data ) ;\n signal_remove ( \"complete word\" , ( SIGNAL_FUNC ) sig_complete_word ) ;\n signal_remove ( \"complete command msg\" , ( SIGNAL_FUNC ) sig_complete_msg ) ;\n signal_remove ( \"complete command query\" , ( SIGNAL_FUNC ) sig_complete_msg ) ;\n signal_remove ( \"complete command action\" , ( SIGNAL_FUNC ) sig_complete_msg ) ;\n signal_remove ( \"complete erase command msg\" , ( SIGNAL_FUNC ) sig_erase_complete_msg ) ;\n signal_remove ( \"complete erase command query\" , ( SIGNAL_FUNC ) sig_erase_complete_msg ) ;\n signal_remove ( \"complete erase command action\" , ( SIGNAL_FUNC ) sig_erase_complete_msg ) ;\n signal_remove ( \"complete command connect\" , ( SIGNAL_FUNC ) sig_complete_connect ) ;\n signal_remove ( \"complete command server\" , ( SIGNAL_FUNC ) sig_complete_connect ) ;\n signal_remove ( \"complete command disconnect\" , ( SIGNAL_FUNC ) sig_complete_tag ) ;\n signal_remove ( \"complete command reconnect\" , ( SIGNAL_FUNC ) sig_complete_tag ) ;\n signal_remove ( \"complete command window server\" , ( SIGNAL_FUNC ) sig_complete_tag ) ;\n signal_remove ( \"complete command topic\" , ( SIGNAL_FUNC ) sig_complete_topic ) ;\n signal_remove ( \"complete command away\" , ( SIGNAL_FUNC ) sig_complete_away ) ;\n signal_remove ( \"complete command unalias\" , ( SIGNAL_FUNC ) sig_complete_unalias ) ;\n signal_remove ( \"complete command alias\" , ( SIGNAL_FUNC ) sig_complete_alias ) ;\n signal_remove ( \"complete command window goto\" , ( SIGNAL_FUNC ) sig_complete_window ) ;\n signal_remove ( \"complete command window item move\" , ( SIGNAL_FUNC ) sig_complete_channel ) ;\n signal_remove ( \"complete command server add\" , ( SIGNAL_FUNC ) sig_complete_server ) ;\n signal_remove ( \"complete command server remove\" , ( SIGNAL_FUNC ) sig_complete_server ) ;\n signal_remove ( \"complete command recode remove\" , ( SIGNAL_FUNC ) sig_complete_target ) ;\n signal_remove ( \"message public\" , ( SIGNAL_FUNC ) sig_message_public ) ;\n signal_remove ( \"message join\" , ( SIGNAL_FUNC ) sig_message_join ) ;\n signal_remove ( \"message private\" , ( SIGNAL_FUNC ) sig_message_private ) ;\n signal_remove ( \"message own_public\" , ( SIGNAL_FUNC ) sig_message_own_public ) ;\n signal_remove ( \"message own_private\" , ( SIGNAL_FUNC ) sig_message_own_private ) ;\n signal_remove ( \"nicklist remove\" , ( SIGNAL_FUNC ) sig_nick_removed ) ;\n signal_remove ( \"nicklist changed\" , ( SIGNAL_FUNC ) sig_nick_changed ) ;\n signal_remove ( \"send text\" , ( SIGNAL_FUNC ) event_text ) ;\n signal_remove ( \"server disconnected\" , ( SIGNAL_FUNC ) sig_server_disconnected ) ;\n signal_remove ( \"channel destroyed\" , ( SIGNAL_FUNC ) sig_channel_destroyed ) ;\n signal_remove ( \"setup changed\" , ( SIGNAL_FUNC ) read_settings ) ;\n g_free_not_null ( completion_char ) ;\n g_free_not_null ( cmdchars ) ;\n }", "idx": 22176}
{"hash": -5968890769755017734, "project": "debian", "size": 12, "label": 0, "functionSource": "static bool restricted_shell ( const char * shellname ) {\n const char * line ;\n setusershell ( ) ;\n while ( ( line = getusershell ( ) ) != NULL ) {\n if ( ( '#' != * line ) && ( strcmp ( line , shellname ) == 0 ) ) {\n endusershell ( ) ;\n return false ;\n }\n }\n endusershell ( ) ;\n return true ;\n }", "idx": 22177}
{"hash": -8958254313220732728, "project": "debian", "size": 28, "label": 0, "functionSource": "static uint32_t virtio_ioport_read ( VirtIOPCIProxy * proxy , uint32_t addr ) {\n VirtIODevice * vdev = proxy -> vdev ;\n uint32_t ret = 0xFFFFFFFF ;\n switch ( addr ) {\n case VIRTIO_PCI_HOST_FEATURES : ret = proxy -> host_features ;\n break ;\n case VIRTIO_PCI_GUEST_FEATURES : ret = vdev -> guest_features ;\n break ;\n case VIRTIO_PCI_QUEUE_PFN : ret = virtio_queue_get_addr ( vdev , vdev -> queue_sel ) >> VIRTIO_PCI_QUEUE_ADDR_SHIFT ;\n break ;\n case VIRTIO_PCI_QUEUE_NUM : ret = virtio_queue_get_num ( vdev , vdev -> queue_sel ) ;\n break ;\n case VIRTIO_PCI_QUEUE_SEL : ret = vdev -> queue_sel ;\n break ;\n case VIRTIO_PCI_STATUS : ret = vdev -> status ;\n break ;\n case VIRTIO_PCI_ISR : ret = vdev -> isr ;\n vdev -> isr = 0 ;\n qemu_set_irq ( proxy -> pci_dev . irq [ 0 ] , 0 ) ;\n break ;\n case VIRTIO_MSI_CONFIG_VECTOR : ret = vdev -> config_vector ;\n break ;\n case VIRTIO_MSI_QUEUE_VECTOR : ret = virtio_queue_vector ( vdev , vdev -> queue_sel ) ;\n break ;\n default : break ;\n }\n return ret ;\n }", "idx": 22178}
{"hash": 8947170728280515149, "project": "debian", "size": 4, "label": 0, "functionSource": "static void Transform ( BasePoint * to , DBasePoint * from , real trans [ 6 ] ) {\n to -> x = trans [ 0 ] * from -> x + trans [ 2 ] * from -> y + trans [ 4 ] ;\n to -> y = trans [ 1 ] * from -> x + trans [ 3 ] * from -> y + trans [ 5 ] ;\n }", "idx": 22179}
{"hash": 6458694302493204858, "project": "debian", "size": 12, "label": 0, "functionSource": "static Datum ExecEvalCoalesce ( CoalesceExprState * coalesceExpr , ExprContext * econtext , bool * isNull , ExprDoneCond * isDone ) {\n ListCell * arg ;\n if ( isDone ) * isDone = ExprSingleResult ;\n foreach ( arg , coalesceExpr -> args ) {\n ExprState * e = ( ExprState * ) lfirst ( arg ) ;\n Datum value ;\n value = ExecEvalExpr ( e , econtext , isNull , NULL ) ;\n if ( ! * isNull ) return value ;\n }\n * isNull = true ;\n return ( Datum ) 0 ;\n }", "idx": 22180}
{"hash": -2423144171479606949, "project": "debian", "size": 6, "label": 0, "functionSource": "static void pdf_run_cs ( fz_context * ctx , pdf_processor * proc , const char * name , fz_colorspace * colorspace ) {\n pdf_run_processor * pr = ( pdf_run_processor * ) proc ;\n pr -> dev -> flags &= ~ FZ_DEVFLAG_FILLCOLOR_UNDEFINED ;\n if ( ! strcmp ( name , \"Pattern\" ) ) pdf_set_pattern ( ctx , pr , PDF_FILL , NULL , NULL ) ;\n else pdf_set_colorspace ( ctx , pr , PDF_FILL , colorspace ) ;\n }", "idx": 22181}
{"hash": 2895622461494525400, "project": "debian", "size": 58, "label": 0, "functionSource": "static void test_wl4166_4 ( ) {\n MYSQL_STMT * stmt ;\n int rc ;\n const char * stmt_text ;\n MYSQL_BIND bind_array [ 2 ] ;\n const char * koi8 = \"\\xee\\xd5\\x2c\\x20\\xda\\xc1\\x20\\xd2\\xd9\\xc2\\xc1\\xcc\\xcb\\xd5\" ;\n const char * cp1251 = \"\\xcd\\xf3\\x2c\\x20\\xe7\\xe0\\x20\\xf0\\xfb\\xe1\\xe0\\xeb\\xea\\xf3\" ;\n char buf1 [ 16 ] , buf2 [ 16 ] ;\n ulong buf1_len , buf2_len ;\n myheader ( \"test_wl4166_4\" ) ;\n rc = mysql_query ( mysql , \"drop table if exists t1\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"create table t1 (c1 varbinary(255), c2 varbinary(255))\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"set character_set_client=koi8r, \" \"character_set_connection=cp1251, \" \"character_set_results=koi8r\" ) ;\n myquery ( rc ) ;\n memset ( bind_array , 0 , sizeof ( bind_array ) ) ;\n bind_array [ 0 ] . buffer_type = MYSQL_TYPE_STRING ;\n bind_array [ 1 ] . buffer_type = MYSQL_TYPE_STRING ;\n bind_array [ 1 ] . buffer = ( void * ) koi8 ;\n bind_array [ 1 ] . buffer_length = strlen ( koi8 ) ;\n stmt = mysql_stmt_init ( mysql ) ;\n check_stmt ( stmt ) ;\n stmt_text = \"insert into t1 (c1, c2) values (?, ?)\" ;\n rc = mysql_stmt_prepare ( stmt , stmt_text , strlen ( stmt_text ) ) ;\n check_execute ( stmt , rc ) ;\n mysql_stmt_bind_param ( stmt , bind_array ) ;\n mysql_stmt_send_long_data ( stmt , 0 , koi8 , strlen ( koi8 ) ) ;\n rc = mysql_query ( mysql , \"alter table t1 add column d int\" ) ;\n myquery ( rc ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n stmt_text = \"select c1, c2 from t1\" ;\n rc = mysql_stmt_prepare ( stmt , stmt_text , strlen ( stmt_text ) ) ;\n check_execute ( stmt , rc ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n bind_array [ 0 ] . buffer = buf1 ;\n bind_array [ 0 ] . buffer_length = sizeof ( buf1 ) ;\n bind_array [ 0 ] . length = & buf1_len ;\n bind_array [ 1 ] . buffer = buf2 ;\n bind_array [ 1 ] . buffer_length = sizeof ( buf2 ) ;\n bind_array [ 1 ] . length = & buf2_len ;\n mysql_stmt_bind_result ( stmt , bind_array ) ;\n rc = mysql_stmt_fetch ( stmt ) ;\n check_execute ( stmt , rc ) ;\n DIE_UNLESS ( buf1_len == strlen ( cp1251 ) ) ;\n DIE_UNLESS ( buf2_len == strlen ( cp1251 ) ) ;\n DIE_UNLESS ( ! memcmp ( buf1 , cp1251 , buf1_len ) ) ;\n DIE_UNLESS ( ! memcmp ( buf2 , cp1251 , buf1_len ) ) ;\n rc = mysql_stmt_fetch ( stmt ) ;\n DIE_UNLESS ( rc == MYSQL_NO_DATA ) ;\n mysql_stmt_close ( stmt ) ;\n rc = mysql_query ( mysql , \"drop table t1\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"set names default\" ) ;\n myquery ( rc ) ;\n }", "idx": 22182}
{"hash": 1760449185745615462, "project": "debian", "size": 18, "label": 0, "functionSource": "TSReturnCode TSHttpTxnUpdateCachedObject ( TSHttpTxn txnp ) {\n sdk_assert ( sdk_sanity_check_txn ( txnp ) == TS_SUCCESS ) ;\n HttpSM * sm = ( HttpSM * ) txnp ;\n HttpTransact : : State * s = & ( sm -> t_state ) ;\n HTTPInfo * cached_obj_store = & ( sm -> t_state . cache_info . object_store ) ;\n HTTPHdr * client_request = & ( sm -> t_state . hdr_info . client_request ) ;\n if ( ! cached_obj_store -> valid ( ) || ! cached_obj_store -> response_get ( ) ) {\n return TS_ERROR ;\n }\n if ( ! cached_obj_store -> request_get ( ) && ! client_request -> valid ( ) ) {\n return TS_ERROR ;\n }\n if ( s -> cache_info . write_lock_state == HttpTransact : : CACHE_WL_READ_RETRY ) {\n return TS_ERROR ;\n }\n s -> api_update_cached_object = HttpTransact : : UPDATE_CACHED_OBJECT_PREPARE ;\n return TS_SUCCESS ;\n }", "idx": 22183}
{"hash": -770464550770502023, "project": "chrome", "size": 10, "label": 1, "functionSource": "IN_PROC_BROWSER_TEST_F ( ExternalProtocolDialogBrowserTest , TestClose ) {\n ShowDialog ( ) ;\n EXPECT_TRUE ( dialog_ -> Close ( ) ) ;\n EXPECT_TRUE ( called_ ) ;\n EXPECT_FALSE ( accept_ ) ;\n EXPECT_TRUE ( cancel_ ) ;\n EXPECT_FALSE ( dont_block_ ) ;\n histogram_tester_ . ExpectTotalCount ( ExternalProtocolHandler : : kRememberCheckboxMetric , 0 ) ;\n histogram_tester_ . ExpectTotalCount ( ExternalProtocolHandler : : kHandleStateMetric , 0 ) ;\n }", "idx": 22184}
{"hash": 8436997111466619903, "project": "debian", "size": 43, "label": 0, "functionSource": "static void init_mv_penalty_and_fcode ( MpegEncContext * s ) {\n int f_code ;\n int mv ;\n for ( f_code = 1 ;\n f_code <= MAX_FCODE ;\n f_code ++ ) {\n for ( mv = - MAX_MV ;\n mv <= MAX_MV ;\n mv ++ ) {\n int len ;\n if ( mv == 0 ) len = ff_mvtab [ 0 ] [ 1 ] ;\n else {\n int val , bit_size , code ;\n bit_size = f_code - 1 ;\n val = mv ;\n if ( val < 0 ) val = - val ;\n val -- ;\n code = ( val >> bit_size ) + 1 ;\n if ( code < 33 ) {\n len = ff_mvtab [ code ] [ 1 ] + 1 + bit_size ;\n }\n else {\n len = ff_mvtab [ 32 ] [ 1 ] + av_log2 ( code >> 5 ) + 2 + bit_size ;\n }\n }\n mv_penalty [ f_code ] [ mv + MAX_MV ] = len ;\n }\n }\n for ( f_code = MAX_FCODE ;\n f_code > 0 ;\n f_code -- ) {\n for ( mv = - ( 16 << f_code ) ;\n mv < ( 16 << f_code ) ;\n mv ++ ) {\n fcode_tab [ mv + MAX_MV ] = f_code ;\n }\n }\n for ( mv = 0 ;\n mv < MAX_MV * 2 + 1 ;\n mv ++ ) {\n umv_fcode_tab [ mv ] = 1 ;\n }\n }", "idx": 22185}
{"hash": -7042392412001533358, "project": "debian", "size": 10, "label": 0, "functionSource": "void pdf_add_codespace ( fz_context * ctx , pdf_cmap * cmap , unsigned int low , unsigned int high , int n ) {\n if ( cmap -> codespace_len + 1 == nelem ( cmap -> codespace ) ) {\n fz_warn ( ctx , \"assert: too many code space ranges\" ) ;\n return ;\n }\n cmap -> codespace [ cmap -> codespace_len ] . n = n ;\n cmap -> codespace [ cmap -> codespace_len ] . low = low ;\n cmap -> codespace [ cmap -> codespace_len ] . high = high ;\n cmap -> codespace_len ++ ;\n }", "idx": 22186}
{"hash": -7019074708255236794, "project": "debian", "size": 14, "label": 0, "functionSource": "static void pitch_enhancer ( float * fixed_vector , float voice_fac ) {\n int i ;\n float cpe = 0.125 * ( 1 + voice_fac ) ;\n float last = fixed_vector [ 0 ] ;\n fixed_vector [ 0 ] -= cpe * fixed_vector [ 1 ] ;\n for ( i = 1 ;\n i < AMRWB_SFR_SIZE - 1 ;\n i ++ ) {\n float cur = fixed_vector [ i ] ;\n fixed_vector [ i ] -= cpe * ( last + fixed_vector [ i + 1 ] ) ;\n last = cur ;\n }\n fixed_vector [ AMRWB_SFR_SIZE - 1 ] -= cpe * last ;\n }", "idx": 22187}
{"hash": 1504508151056681409, "project": "debian", "size": 15, "label": 0, "functionSource": "static int64_t atol16 ( const char * p , unsigned char_cnt ) {\n int64_t l ;\n int digit ;\n l = 0 ;\n while ( char_cnt -- > 0 ) {\n if ( * p >= 'a' && * p <= 'f' ) digit = * p - 'a' + 10 ;\n else if ( * p >= 'A' && * p <= 'F' ) digit = * p - 'A' + 10 ;\n else if ( * p >= '0' && * p <= '9' ) digit = * p - '0' ;\n else return ( l ) ;\n p ++ ;\n l <<= 4 ;\n l |= digit ;\n }\n return ( l ) ;\n }", "idx": 22188}
{"hash": -954364585377557207, "project": "debian", "size": 31, "label": 0, "functionSource": "static const float * anti_sparseness ( AMRContext * p , AMRFixed * fixed_sparse , const float * fixed_vector , float fixed_gain , float * out ) {\n int ir_filter_nr ;\n if ( p -> pitch_gain [ 4 ] < 0.6 ) {\n ir_filter_nr = 0 ;\n }\n else if ( p -> pitch_gain [ 4 ] < 0.9 ) {\n ir_filter_nr = 1 ;\n }\n else ir_filter_nr = 2 ;\n if ( fixed_gain > 2.0 * p -> prev_sparse_fixed_gain ) {\n p -> ir_filter_onset = 2 ;\n }\n else if ( p -> ir_filter_onset ) p -> ir_filter_onset -- ;\n if ( ! p -> ir_filter_onset ) {\n int i , count = 0 ;\n for ( i = 0 ;\n i < 5 ;\n i ++ ) if ( p -> pitch_gain [ i ] < 0.6 ) count ++ ;\n if ( count > 2 ) ir_filter_nr = 0 ;\n if ( ir_filter_nr > p -> prev_ir_filter_nr + 1 ) ir_filter_nr -- ;\n }\n else if ( ir_filter_nr < 2 ) ir_filter_nr ++ ;\n if ( fixed_gain < 5.0 ) ir_filter_nr = 2 ;\n if ( p -> cur_frame_mode != MODE_7k4 && p -> cur_frame_mode < MODE_10k2 && ir_filter_nr < 2 ) {\n apply_ir_filter ( out , fixed_sparse , ( p -> cur_frame_mode == MODE_7k95 ? ir_filters_lookup_MODE_7k95 : ir_filters_lookup ) [ ir_filter_nr ] ) ;\n fixed_vector = out ;\n }\n p -> prev_ir_filter_nr = ir_filter_nr ;\n p -> prev_sparse_fixed_gain = fixed_gain ;\n return fixed_vector ;\n }", "idx": 22189}
{"hash": -1111775978048960297, "project": "chrome", "size": 14, "label": 0, "functionSource": "TEST_F ( BrowsingDataRemoverImplTest , RemoveQuotaManagedDataForeverSpecificOrigin ) {\n std : : unique_ptr < BrowsingDataFilterBuilder > builder ( BrowsingDataFilterBuilder : : Create ( BrowsingDataFilterBuilder : : WHITELIST ) ) ;\n builder -> AddRegisterableDomain ( kTestRegisterableDomain1 ) ;\n BlockUntilOriginDataRemoved ( base : : Time ( ) , base : : Time : : Max ( ) , BrowsingDataRemover : : REMOVE_APPCACHE | BrowsingDataRemover : : REMOVE_SERVICE_WORKERS | BrowsingDataRemover : : REMOVE_CACHE_STORAGE | BrowsingDataRemover : : REMOVE_FILE_SYSTEMS | BrowsingDataRemover : : REMOVE_INDEXEDDB | BrowsingDataRemover : : REMOVE_WEBSQL , std : : move ( builder ) ) ;\n EXPECT_EQ ( BrowsingDataRemover : : REMOVE_APPCACHE | BrowsingDataRemover : : REMOVE_SERVICE_WORKERS | BrowsingDataRemover : : REMOVE_CACHE_STORAGE | BrowsingDataRemover : : REMOVE_FILE_SYSTEMS | BrowsingDataRemover : : REMOVE_INDEXEDDB | BrowsingDataRemover : : REMOVE_WEBSQL , GetRemovalMask ( ) ) ;\n EXPECT_EQ ( BrowsingDataHelper : : UNPROTECTED_WEB , GetOriginTypeMask ( ) ) ;\n StoragePartitionRemovalData removal_data = GetStoragePartitionRemovalData ( ) ;\n EXPECT_EQ ( removal_data . remove_mask , StoragePartition : : REMOVE_DATA_MASK_FILE_SYSTEMS | StoragePartition : : REMOVE_DATA_MASK_WEBSQL | StoragePartition : : REMOVE_DATA_MASK_APPCACHE | StoragePartition : : REMOVE_DATA_MASK_SERVICE_WORKERS | StoragePartition : : REMOVE_DATA_MASK_CACHE_STORAGE | StoragePartition : : REMOVE_DATA_MASK_INDEXEDDB ) ;\n EXPECT_EQ ( removal_data . quota_storage_remove_mask , StoragePartition : : QUOTA_MANAGED_STORAGE_MASK_ALL ) ;\n EXPECT_TRUE ( removal_data . origin_matcher . Run ( kOrigin1 , mock_policy ( ) ) ) ;\n EXPECT_FALSE ( removal_data . origin_matcher . Run ( kOrigin2 , mock_policy ( ) ) ) ;\n EXPECT_FALSE ( removal_data . origin_matcher . Run ( kOrigin3 , mock_policy ( ) ) ) ;\n EXPECT_FALSE ( removal_data . origin_matcher . Run ( kOrigin4 , mock_policy ( ) ) ) ;\n }", "idx": 22190}
{"hash": 378220832151730865, "project": "debian", "size": 14, "label": 0, "functionSource": "static int qemuMonitorSendVNCPassphrase ( qemuMonitorPtr mon ATTRIBUTE_UNUSED , qemuMonitorMessagePtr msg , const char * data ATTRIBUTE_UNUSED , size_t len ATTRIBUTE_UNUSED , void * opaque ) {\n char * passphrase = opaque ;\n size_t passphrase_len = strlen ( passphrase ) ;\n if ( VIR_REALLOC_N ( msg -> txBuffer , msg -> txLength + passphrase_len + 1 + 1 ) < 0 ) {\n virReportOOMError ( ) ;\n return - 1 ;\n }\n memcpy ( msg -> txBuffer + msg -> txLength , passphrase , passphrase_len ) ;\n msg -> txLength += passphrase_len ;\n msg -> txBuffer [ msg -> txLength ] = '\\r' ;\n msg -> txLength ++ ;\n msg -> txBuffer [ msg -> txLength ] = '\\0' ;\n return 0 ;\n }", "idx": 22191}
{"hash": 6415329349331062723, "project": "chrome", "size": 10, "label": 0, "functionSource": "static void close_detect_launch ( int fd , short what , void * arg ) {\n struct evhttp_connection * evcon = arg ;\n struct evhttp_request * req ;\n req = evhttp_request_new ( close_detect_done , NULL ) ;\n evhttp_add_header ( req -> output_headers , \"Host\" , \"somehost\" ) ;\n if ( evhttp_make_request ( evcon , req , EVHTTP_REQ_GET , \"/test\" ) == - 1 ) {\n fprintf ( stdout , \"FAILED\\n\" ) ;\n exit ( 1 ) ;\n }\n }", "idx": 22192}
{"hash": 1859256631654516868, "project": "chrome", "size": 19, "label": 0, "functionSource": "static void decode_finish_row ( H264Context * h ) {\n int top = 16 * ( h -> mb_y >> FIELD_PICTURE ( h ) ) ;\n int pic_height = 16 * h -> mb_height >> FIELD_PICTURE ( h ) ;\n int height = 16 << FRAME_MBAFF ( h ) ;\n int deblock_border = ( 16 + 4 ) << FRAME_MBAFF ( h ) ;\n if ( h -> deblocking_filter ) {\n if ( ( top + height ) >= pic_height ) height += deblock_border ;\n top -= deblock_border ;\n }\n if ( top >= pic_height || ( top + height ) < 0 ) return ;\n height = FFMIN ( height , pic_height - top ) ;\n if ( top < 0 ) {\n height = top + height ;\n top = 0 ;\n }\n ff_h264_draw_horiz_band ( h , top , height ) ;\n if ( h -> droppable || h -> er . error_occurred ) return ;\n ff_thread_report_progress ( & h -> cur_pic_ptr -> tf , top + height - 1 , h -> picture_structure == PICT_BOTTOM_FIELD ) ;\n }", "idx": 22193}
{"hash": -7381368573324403493, "project": "chrome", "size": 23, "label": 0, "functionSource": "int vp9_get_reference_mode_context ( const VP9_COMMON * cm , const MACROBLOCKD * xd ) {\n int ctx ;\n const MB_MODE_INFO * const above_mbmi = get_mbmi ( get_above_mi ( xd ) ) ;\n const MB_MODE_INFO * const left_mbmi = get_mbmi ( get_left_mi ( xd ) ) ;\n const int has_above = above_mbmi != NULL ;\n const int has_left = left_mbmi != NULL ;\n if ( has_above && has_left ) {\n if ( ! has_second_ref ( above_mbmi ) && ! has_second_ref ( left_mbmi ) ) ctx = ( above_mbmi -> ref_frame [ 0 ] == cm -> comp_fixed_ref ) ^ ( left_mbmi -> ref_frame [ 0 ] == cm -> comp_fixed_ref ) ;\n else if ( ! has_second_ref ( above_mbmi ) ) ctx = 2 + ( above_mbmi -> ref_frame [ 0 ] == cm -> comp_fixed_ref || ! is_inter_block ( above_mbmi ) ) ;\n else if ( ! has_second_ref ( left_mbmi ) ) ctx = 2 + ( left_mbmi -> ref_frame [ 0 ] == cm -> comp_fixed_ref || ! is_inter_block ( left_mbmi ) ) ;\n else ctx = 4 ;\n }\n else if ( has_above || has_left ) {\n const MB_MODE_INFO * edge_mbmi = has_above ? above_mbmi : left_mbmi ;\n if ( ! has_second_ref ( edge_mbmi ) ) ctx = edge_mbmi -> ref_frame [ 0 ] == cm -> comp_fixed_ref ;\n else ctx = 3 ;\n }\n else {\n ctx = 1 ;\n }\n assert ( ctx >= 0 && ctx < COMP_INTER_CONTEXTS ) ;\n return ctx ;\n }", "idx": 22194}
{"hash": -1768728156572022708, "project": "debian", "size": 4, "label": 0, "functionSource": "void * jbig2_alloc ( Jbig2Allocator * allocator , size_t size , size_t num ) {\n if ( num > 0 && size >= ( size_t ) - 0x100 / num ) return NULL ;\n return allocator -> alloc ( allocator , size * num ) ;\n }", "idx": 22195}
{"hash": 6632536031698733342, "project": "debian", "size": 4, "label": 0, "functionSource": "static void xml_print_int ( WriterContext * wctx , const char * key , long long int value ) {\n if ( wctx -> nb_item [ wctx -> level ] ) printf ( \" \" ) ;\n printf ( \"%s=\\\"%lld\\\"\" , key , value ) ;\n }", "idx": 22196}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_H222Capability ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_H222Capability , H222Capability_sequence ) ;\n return offset ;\n }", "idx": 22197}
{"hash": 7191899184788440065, "project": "debian", "size": 13, "label": 0, "functionSource": "static void init_tee ( const char * file_name ) {\n FILE * new_outfile ;\n if ( opt_outfile ) end_tee ( ) ;\n if ( ! ( new_outfile = my_fopen ( file_name , O_APPEND | O_WRONLY , MYF ( MY_WME ) ) ) ) {\n tee_fprintf ( stdout , \"Error logging to file '%s'\\n\" , file_name ) ;\n return ;\n }\n OUTFILE = new_outfile ;\n strmake_buf ( outfile , file_name ) ;\n tee_fprintf ( stdout , \"Logging to file '%s'\\n\" , file_name ) ;\n opt_outfile = 1 ;\n return ;\n }", "idx": 22198}
{"hash": -3133987110086012192, "project": "chrome", "size": 7, "label": 0, "functionSource": "TEST_F ( SoundContentSettingObserverTest , DontUnmuteWhenMutedByExtension ) {\n EXPECT_FALSE ( web_contents ( ) -> IsAudioMuted ( ) ) ;\n SetMuteStateForReason ( true , TabMutedReason : : EXTENSION ) ;\n EXPECT_TRUE ( web_contents ( ) -> IsAudioMuted ( ) ) ;\n NavigateAndCommit ( GURL ( kURL2 ) ) ;\n EXPECT_TRUE ( web_contents ( ) -> IsAudioMuted ( ) ) ;\n }", "idx": 22199}
{"hash": 7279312193592248512, "project": "debian", "size": 10, "label": 0, "functionSource": "static void intra_pred_horiz ( uint8_t * d , uint8_t * top , uint8_t * left , int stride ) {\n int y ;\n uint64_t a ;\n for ( y = 0 ;\n y < 8 ;\n y ++ ) {\n a = left [ y + 1 ] * 0x0101010101010101ULL ;\n * ( ( uint64_t * ) ( d + y * stride ) ) = a ;\n }\n }", "idx": 22200}
{"hash": -5280794106681745199, "project": "debian", "size": 13, "label": 0, "functionSource": "static gboolean gst_asf_demux_send_event_unlocked ( GstASFDemux * demux , GstEvent * event ) {\n gboolean ret = TRUE ;\n gint i ;\n GST_DEBUG_OBJECT ( demux , \"sending %s event to all source pads\" , GST_EVENT_TYPE_NAME ( event ) ) ;\n for ( i = 0 ;\n i < demux -> num_streams ;\n ++ i ) {\n gst_event_ref ( event ) ;\n ret &= gst_pad_push_event ( demux -> stream [ i ] . pad , event ) ;\n }\n gst_event_unref ( event ) ;\n return ret ;\n }", "idx": 22201}
{"hash": -5493081488206619677, "project": "debian", "size": 10, "label": 0, "functionSource": "static const char * cmd_response_body_mime_type ( cmd_parms * cmd , void * _dcfg , const char * _p1 ) {\n directory_config * dcfg = ( directory_config * ) _dcfg ;\n char * p1 = apr_pstrdup ( cmd -> pool , _p1 ) ;\n if ( ( dcfg -> of_mime_types == NULL ) || ( dcfg -> of_mime_types == NOT_SET_P ) ) {\n dcfg -> of_mime_types = apr_table_make ( cmd -> pool , 10 ) ;\n }\n strtolower_inplace ( ( unsigned char * ) p1 ) ;\n apr_table_setn ( dcfg -> of_mime_types , p1 , \"1\" ) ;\n return NULL ;\n }", "idx": 22202}
{"hash": -4960438251319819237, "project": "chrome", "size": 6, "label": 1, "functionSource": "static double calc_correction_factor ( double err_per_mb , double err_divisor , double pt_low , double pt_high , int q ) {\n const double error_term = err_per_mb / err_divisor ;\n const double power_term = MIN ( vp9_convert_qindex_to_q ( q ) * 0.0125 + pt_low , pt_high ) ;\n if ( power_term < 1.0 ) assert ( error_term >= 0.0 ) ;\n return fclamp ( pow ( error_term , power_term ) , 0.05 , 5.0 ) ;\n }", "idx": 22203}
{"hash": -8028756826159773630, "project": "debian", "size": 44, "label": 0, "functionSource": "void ReadHead ( ArchiveHandle * AH ) {\n char tmpMag [ 7 ] ;\n int fmt ;\n struct tm crtm ;\n if ( ! AH -> readHeader ) {\n ( * AH -> ReadBufPtr ) ( AH , tmpMag , 5 ) ;\n if ( strncmp ( tmpMag , \"PGDMP\" , 5 ) != 0 ) exit_horribly ( modulename , \"did not find magic string in file header\\n\" ) ;\n AH -> vmaj = ( * AH -> ReadBytePtr ) ( AH ) ;\n AH -> vmin = ( * AH -> ReadBytePtr ) ( AH ) ;\n if ( AH -> vmaj > 1 || ( ( AH -> vmaj == 1 ) && ( AH -> vmin > 0 ) ) ) AH -> vrev = ( * AH -> ReadBytePtr ) ( AH ) ;\n else AH -> vrev = 0 ;\n AH -> version = ( ( AH -> vmaj * 256 + AH -> vmin ) * 256 + AH -> vrev ) * 256 + 0 ;\n if ( AH -> version < K_VERS_1_0 || AH -> version > K_VERS_MAX ) exit_horribly ( modulename , \"unsupported version (%d.%d) in file header\\n\" , AH -> vmaj , AH -> vmin ) ;\n AH -> intSize = ( * AH -> ReadBytePtr ) ( AH ) ;\n if ( AH -> intSize > 32 ) exit_horribly ( modulename , \"sanity check on integer size (%lu) failed\\n\" , ( unsigned long ) AH -> intSize ) ;\n if ( AH -> intSize > sizeof ( int ) ) write_msg ( modulename , \"WARNING: archive was made on a machine with larger integers, some operations might fail\\n\" ) ;\n if ( AH -> version >= K_VERS_1_7 ) AH -> offSize = ( * AH -> ReadBytePtr ) ( AH ) ;\n else AH -> offSize = AH -> intSize ;\n fmt = ( * AH -> ReadBytePtr ) ( AH ) ;\n if ( AH -> format != fmt ) exit_horribly ( modulename , \"expected format (%d) differs from format found in file (%d)\\n\" , AH -> format , fmt ) ;\n }\n if ( AH -> version >= K_VERS_1_2 ) {\n if ( AH -> version < K_VERS_1_4 ) AH -> compression = ( * AH -> ReadBytePtr ) ( AH ) ;\n else AH -> compression = ReadInt ( AH ) ;\n }\n else AH -> compression = Z_DEFAULT_COMPRESSION ;\n # ifndef HAVE_LIBZ if ( AH -> compression != 0 ) write_msg ( modulename , \"WARNING: archive is compressed, but this installation does not support compression -- no data will be available\\n\" ) ;\n # endif if ( AH -> version >= K_VERS_1_4 ) {\n crtm . tm_sec = ReadInt ( AH ) ;\n crtm . tm_min = ReadInt ( AH ) ;\n crtm . tm_hour = ReadInt ( AH ) ;\n crtm . tm_mday = ReadInt ( AH ) ;\n crtm . tm_mon = ReadInt ( AH ) ;\n crtm . tm_year = ReadInt ( AH ) ;\n crtm . tm_isdst = ReadInt ( AH ) ;\n AH -> archdbname = ReadStr ( AH ) ;\n AH -> createDate = mktime ( & crtm ) ;\n if ( AH -> createDate == ( time_t ) - 1 ) write_msg ( modulename , \"WARNING: invalid creation date in header\\n\" ) ;\n }\n if ( AH -> version >= K_VERS_1_10 ) {\n AH -> archiveRemoteVersion = ReadStr ( AH ) ;\n AH -> archiveDumpVersion = ReadStr ( AH ) ;\n }\n }", "idx": 22204}
{"hash": 2218137424821696593, "project": "debian", "size": 5, "label": 0, "functionSource": "void ff_xvmc_field_end ( MpegEncContext * s ) {\n struct xvmc_pix_fmt * render = ( struct xvmc_pix_fmt * ) s -> current_picture . f . data [ 2 ] ;\n assert ( render ) ;\n if ( render -> filled_mv_blocks_num > 0 ) ff_mpeg_draw_horiz_band ( s , 0 , 0 ) ;\n }", "idx": 22205}
{"hash": 6249489553242542670, "project": "debian", "size": 7, "label": 0, "functionSource": "filegen_node * create_filegen_node ( int filegen_token , attr_val_fifo * options ) {\n filegen_node * my_node ;\n my_node = emalloc_zero ( sizeof ( * my_node ) ) ;\n my_node -> filegen_token = filegen_token ;\n my_node -> options = options ;\n return my_node ;\n }", "idx": 22206}
{"hash": -1102844685921778700, "project": "debian", "size": 3, "label": 0, "functionSource": "static int utf16be_to_unicode ( uint32_t * pwc , const char * s , size_t n ) {\n return ( utf16_to_unicode ( pwc , s , n , 1 ) ) ;\n }", "idx": 22207}
{"hash": -8228664527580018723, "project": "debian", "size": 7, "label": 0, "functionSource": "static int storebuffer ( int output , FILE * data ) {\n char * * buffer = ( char * * ) data ;\n unsigned char outc = ( unsigned char ) output ;\n * * buffer = outc ;\n ( * buffer ) ++ ;\n return outc ;\n }", "idx": 22208}
{"hash": 2895622461494525400, "project": "debian", "size": 7, "label": 0, "functionSource": "static void disable_query_logs ( ) {\n int rc ;\n rc = mysql_query ( mysql , \"set @@global.general_log=off\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"set @@global.slow_query_log=off\" ) ;\n myquery ( rc ) ;\n }", "idx": 22209}
{"hash": -714975729066076397, "project": "chrome", "size": 3, "label": 0, "functionSource": "void * hb_blob_get_user_data ( hb_blob_t * blob , hb_user_data_key_t * key ) {\n return hb_object_get_user_data ( blob , key ) ;\n }", "idx": 22210}
{"hash": 9176142195250515812, "project": "debian", "size": 12, "label": 0, "functionSource": "static int purple_send_typing ( struct im_connection * ic , char * who , int flags ) {\n PurpleTypingState state = PURPLE_NOT_TYPING ;\n struct purple_data * pd = ic -> proto_data ;\n if ( flags & OPT_TYPING ) {\n state = PURPLE_TYPING ;\n }\n else if ( flags & OPT_THINKING ) {\n state = PURPLE_TYPED ;\n }\n serv_send_typing ( purple_account_get_connection ( pd -> account ) , who , state ) ;\n return 1 ;\n }", "idx": 22211}
{"hash": 5825340398912191389, "project": "debian", "size": 5, "label": 0, "functionSource": "extern int name ( int ) __THROW __exctype ( isalnum ) ;\n __exctype ( isalpha ) ;\n __exctype ( iscntrl ) ;\n __exctype ( isdigit ) ;\n __exctype ( islower )", "idx": 22212}
{"hash": 6323824267898511453, "project": "debian", "size": 3, "label": 0, "functionSource": "int fz_colorspace_is_lab_icc ( fz_context * ctx , const fz_colorspace * cs ) {\n return fz_colorspace_is_lab ( ctx , cs ) && fz_colorspace_is_icc ( ctx , cs ) ;\n }", "idx": 22213}
{"hash": -1929262071302712016, "project": "debian", "size": 5, "label": 0, "functionSource": "static void Type_ProfileSequenceId_Free ( struct _cms_typehandler_struct * self , void * Ptr ) {\n cmsFreeProfileSequenceDescription ( ( cmsSEQ * ) Ptr ) ;\n return ;\n cmsUNUSED_PARAMETER ( self ) ;\n }", "idx": 22214}
{"hash": -1658505547857059267, "project": "debian", "size": 16, "label": 0, "functionSource": "void ff_h264_remove_all_refs ( H264Context * h ) {\n int i ;\n for ( i = 0 ;\n i < 16 ;\n i ++ ) {\n remove_long ( h , i , 0 ) ;\n }\n assert ( h -> long_ref_count == 0 ) ;\n for ( i = 0 ;\n i < h -> short_ref_count ;\n i ++ ) {\n unreference_pic ( h , h -> short_ref [ i ] , 0 ) ;\n h -> short_ref [ i ] = NULL ;\n }\n h -> short_ref_count = 0 ;\n }", "idx": 22215}
{"hash": -7555034601056330007, "project": "debian", "size": 6, "label": 0, "functionSource": "bool virLogProbablyLogMessage ( const char * str ) {\n bool ret = false ;\n if ( ! virLogRegex ) return false ;\n if ( regexec ( virLogRegex , str , 0 , NULL , 0 ) == 0 ) ret = true ;\n return ret ;\n }", "idx": 22216}
{"hash": -2931981263594364686, "project": "debian", "size": 9, "label": 0, "functionSource": "void keyring_release ( KEYRING_HANDLE hd ) {\n if ( ! hd ) return ;\n assert ( active_handles > 0 ) ;\n active_handles -- ;\n xfree ( hd -> word_match . name ) ;\n xfree ( hd -> word_match . pattern ) ;\n iobuf_close ( hd -> current . iobuf ) ;\n xfree ( hd ) ;\n }", "idx": 22217}
{"hash": 8388187431631506723, "project": "debian", "size": 5, "label": 0, "functionSource": "static bool mcg_ext_ctl_needed ( void * opaque ) {\n X86CPU * cpu = opaque ;\n CPUX86State * env = & cpu -> env ;\n return cpu -> enable_lmce && env -> mcg_ext_ctl ;\n }", "idx": 22218}
{"hash": 1760449185745615462, "project": "debian", "size": 9, "label": 0, "functionSource": "TSReturnCode TSMgmtIntCreate ( TSRecordType rec_type , const char * name , TSMgmtInt data_default , TSRecordUpdateType update_type , TSRecordCheckType check_type , const char * check_regex , TSRecordAccessType access_type ) {\n if ( check_regex == nullptr && check_type != TS_RECORDCHECK_NULL ) {\n return TS_ERROR ;\n }\n if ( REC_ERR_OKAY != RecRegisterConfigInt ( ( enum RecT ) rec_type , name , ( RecInt ) data_default , ( enum RecUpdateT ) update_type , ( enum RecCheckT ) check_type , check_regex , REC_SOURCE_PLUGIN , ( enum RecAccessT ) access_type ) ) {\n return TS_ERROR ;\n }\n return TS_SUCCESS ;\n }", "idx": 22219}
{"hash": -7237039260294671485, "project": "debian", "size": 10, "label": 0, "functionSource": "static int dissect_nlm_freeall ( tvbuff_t * tvb , int offset , packet_info * pinfo _U_ , proto_tree * tree , int version _U_ ) {\n guint32 nlm_stat ;\n offset = dissect_rpc_string ( tvb , tree , hf_nlm_share_name , offset , NULL ) ;\n nlm_stat = tvb_get_ntohl ( tvb , offset ) ;\n if ( nlm_stat ) {\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \" %s\" , val_to_str ( nlm_stat , names_nlm_stats , \"Unknown Status (%u)\" ) ) ;\n }\n offset = dissect_rpc_uint32 ( tvb , tree , hf_nlm_stat , offset ) ;\n return offset ;\n }", "idx": 22220}
{"hash": 7039307292471244756, "project": "debian", "size": 19, "label": 0, "functionSource": "static guint16 de_tp_sub_channel ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len _U_ , gchar * add_string _U_ , int string_len _U_ ) {\n guint32 curr_offset ;\n guchar oct ;\n const gchar * str ;\n curr_offset = offset ;\n oct = tvb_get_guint8 ( tvb , curr_offset ) & 0x3f ;\n if ( ( oct & 0x38 ) == 0x38 ) str = \"I\" ;\n else if ( ( oct & 0x38 ) == 0x18 ) str = \"F\" ;\n else if ( ( oct & 0x38 ) == 0x10 ) str = \"E\" ;\n else if ( ( oct & 0x38 ) == 0x08 ) str = \"D\" ;\n else if ( ( oct & 0x3c ) == 0x04 ) str = \"C\" ;\n else if ( ( oct & 0x3e ) == 0x02 ) str = \"B\" ;\n else if ( ( oct & 0x3e ) == 0x00 ) str = \"A\" ;\n else str = \"unknown\" ;\n proto_tree_add_uint_format_value ( tree , hf_gsm_a_dtap_test_loop , tvb , curr_offset , 1 , oct , \"%s\" , str ) ;\n proto_tree_add_item ( tree , hf_gsm_a_dtap_subchannel , tvb , curr_offset , 1 , ENC_NA ) ;\n curr_offset += 1 ;\n return ( curr_offset - offset ) ;\n }", "idx": 22221}
{"hash": -1055531103257174901, "project": "debian", "size": 6, "label": 0, "functionSource": "void completion_last_message_remove ( const char * nick ) {\n LAST_MSG_REC * rec ;\n g_return_if_fail ( nick != NULL ) ;\n rec = last_msg_find ( global_lastmsgs , nick ) ;\n if ( rec != NULL ) last_msg_destroy ( & global_lastmsgs , rec ) ;\n }", "idx": 22222}
{"hash": 8588713512322173474, "project": "debian", "size": 14, "label": 0, "functionSource": "static void tgq_idct_put_mb_dconly ( TgqContext * s , AVFrame * frame , int mb_x , int mb_y , const int8_t * dc ) {\n int linesize = frame -> linesize [ 0 ] ;\n uint8_t * dest_y = frame -> data [ 0 ] + ( mb_y * 16 * linesize ) + mb_x * 16 ;\n uint8_t * dest_cb = frame -> data [ 1 ] + ( mb_y * 8 * frame -> linesize [ 1 ] ) + mb_x * 8 ;\n uint8_t * dest_cr = frame -> data [ 2 ] + ( mb_y * 8 * frame -> linesize [ 2 ] ) + mb_x * 8 ;\n tgq_dconly ( s , dest_y , linesize , dc [ 0 ] ) ;\n tgq_dconly ( s , dest_y + 8 , linesize , dc [ 1 ] ) ;\n tgq_dconly ( s , dest_y + 8 * linesize , linesize , dc [ 2 ] ) ;\n tgq_dconly ( s , dest_y + 8 * linesize + 8 , linesize , dc [ 3 ] ) ;\n if ( ! ( s -> avctx -> flags & CODEC_FLAG_GRAY ) ) {\n tgq_dconly ( s , dest_cb , frame -> linesize [ 1 ] , dc [ 4 ] ) ;\n tgq_dconly ( s , dest_cr , frame -> linesize [ 2 ] , dc [ 5 ] ) ;\n }\n }", "idx": 22223}
{"hash": -877789201846276110, "project": "chrome", "size": 27, "label": 0, "functionSource": "TEST_F ( WebUsbDetectorTest , ThreeUsbDevicesWereThereBeforeAndThenRemovedAfterWebUsbDetectorWasCreated ) {\n base : : string16 product_name_1 = base : : UTF8ToUTF16 ( kProductName_1 ) ;\n GURL landing_page_1 ( kLandingPage_1 ) ;\n scoped_refptr < device : : MockUsbDevice > device_1 ( new device : : MockUsbDevice ( 0 , 1 , \"Google\" , kProductName_1 , \"002\" , landing_page_1 ) ) ;\n std : : string guid_1 = device_1 -> guid ( ) ;\n base : : string16 product_name_2 = base : : UTF8ToUTF16 ( kProductName_2 ) ;\n GURL landing_page_2 ( kLandingPage_2 ) ;\n scoped_refptr < device : : MockUsbDevice > device_2 ( new device : : MockUsbDevice ( 3 , 4 , \"Google\" , kProductName_2 , \"005\" , landing_page_2 ) ) ;\n std : : string guid_2 = device_2 -> guid ( ) ;\n base : : string16 product_name_3 = base : : UTF8ToUTF16 ( kProductName_3 ) ;\n GURL landing_page_3 ( kLandingPage_3 ) ;\n scoped_refptr < device : : MockUsbDevice > device_3 ( new device : : MockUsbDevice ( 6 , 7 , \"Google\" , kProductName_3 , \"008\" , landing_page_3 ) ) ;\n std : : string guid_3 = device_3 -> guid ( ) ;\n device_client_ . usb_service ( ) -> AddDevice ( device_1 ) ;\n EXPECT_TRUE ( message_center_ -> FindVisibleNotificationById ( guid_1 ) == nullptr ) ;\n device_client_ . usb_service ( ) -> AddDevice ( device_2 ) ;\n EXPECT_TRUE ( message_center_ -> FindVisibleNotificationById ( guid_2 ) == nullptr ) ;\n device_client_ . usb_service ( ) -> AddDevice ( device_3 ) ;\n EXPECT_TRUE ( message_center_ -> FindVisibleNotificationById ( guid_3 ) == nullptr ) ;\n Initialize ( ) ;\n device_client_ . usb_service ( ) -> RemoveDevice ( device_1 ) ;\n EXPECT_TRUE ( message_center_ -> FindVisibleNotificationById ( guid_1 ) == nullptr ) ;\n device_client_ . usb_service ( ) -> RemoveDevice ( device_2 ) ;\n EXPECT_TRUE ( message_center_ -> FindVisibleNotificationById ( guid_2 ) == nullptr ) ;\n device_client_ . usb_service ( ) -> RemoveDevice ( device_3 ) ;\n EXPECT_TRUE ( message_center_ -> FindVisibleNotificationById ( guid_3 ) == nullptr ) ;\n }", "idx": 22224}
{"hash": -2443662135687614592, "project": "chrome", "size": 6, "label": 0, "functionSource": "static __inline__ int ethtool_validate_duplex ( __u8 duplex ) {\n switch ( duplex ) {\n case DUPLEX_HALF : case DUPLEX_FULL : case DUPLEX_UNKNOWN : return 1 ;\n }\n return 0 ;\n }", "idx": 22225}
{"hash": 6120640898537304364, "project": "debian", "size": 40, "label": 0, "functionSource": "static fz_image * parse_inline_image ( fz_context * ctx , pdf_csi * csi , fz_stream * stm ) {\n pdf_document * doc = csi -> doc ;\n pdf_obj * rdb = csi -> rdb ;\n pdf_obj * obj = NULL ;\n fz_image * img = NULL ;\n int ch , found ;\n fz_var ( obj ) ;\n fz_var ( img ) ;\n fz_try ( ctx ) {\n obj = pdf_parse_dict ( ctx , doc , stm , & doc -> lexbuf . base ) ;\n ch = fz_read_byte ( ctx , stm ) ;\n if ( ch == '\\r' ) if ( fz_peek_byte ( ctx , stm ) == '\\n' ) fz_read_byte ( ctx , stm ) ;\n img = pdf_load_inline_image ( ctx , doc , rdb , obj , stm ) ;\n found = 0 ;\n ch = fz_read_byte ( ctx , stm ) ;\n do {\n while ( ch != 'E' && ch != EOF ) ch = fz_read_byte ( ctx , stm ) ;\n if ( ch == 'E' ) {\n ch = fz_read_byte ( ctx , stm ) ;\n if ( ch == 'I' ) {\n ch = fz_peek_byte ( ctx , stm ) ;\n if ( ch == ' ' || ch <= 32 || ch == EOF || ch == '<' || ch == '/' ) {\n found = 1 ;\n break ;\n }\n }\n }\n }\n while ( ch != EOF ) ;\n if ( ! found ) fz_throw ( ctx , FZ_ERROR_SYNTAX , \"syntax error after inline image\" ) ;\n }\n fz_always ( ctx ) {\n pdf_drop_obj ( ctx , obj ) ;\n }\n fz_catch ( ctx ) {\n fz_drop_image ( ctx , img ) ;\n fz_rethrow ( ctx ) ;\n }\n return img ;\n }", "idx": 22226}
{"hash": 6298409723927571872, "project": "chrome", "size": 3, "label": 1, "functionSource": "static void initial_reordering_broken_cluster ( const hb_ot_shape_plan_t * plan , hb_face_t * face , hb_buffer_t * buffer , unsigned int start , unsigned int end ) {\n initial_reordering_consonant_syllable ( plan , face , buffer , start , end ) ;\n }", "idx": 22227}
{"hash": -1929262071302712016, "project": "debian", "size": 103, "label": 0, "functionSource": "static cmsBool Type_LUT16_Write ( struct _cms_typehandler_struct * self , cmsIOHANDLER * io , void * Ptr , cmsUInt32Number nItems ) {\n cmsUInt32Number nTabSize ;\n cmsPipeline * NewLUT = ( cmsPipeline * ) Ptr ;\n cmsStage * mpe ;\n _cmsStageToneCurvesData * PreMPE = NULL , * PostMPE = NULL ;\n _cmsStageMatrixData * MatMPE = NULL ;\n _cmsStageCLutData * clut = NULL ;\n int i , InputChannels , OutputChannels , clutPoints ;\n mpe = NewLUT -> Elements ;\n if ( mpe != NULL && mpe -> Type == cmsSigMatrixElemType ) {\n MatMPE = ( _cmsStageMatrixData * ) mpe -> Data ;\n mpe = mpe -> Next ;\n }\n if ( mpe != NULL && mpe -> Type == cmsSigCurveSetElemType ) {\n PreMPE = ( _cmsStageToneCurvesData * ) mpe -> Data ;\n mpe = mpe -> Next ;\n }\n if ( mpe != NULL && mpe -> Type == cmsSigCLutElemType ) {\n clut = ( _cmsStageCLutData * ) mpe -> Data ;\n mpe = mpe -> Next ;\n }\n if ( mpe != NULL && mpe -> Type == cmsSigCurveSetElemType ) {\n PostMPE = ( _cmsStageToneCurvesData * ) mpe -> Data ;\n mpe = mpe -> Next ;\n }\n if ( mpe != NULL ) {\n cmsSignalError ( mpe -> ContextID , cmsERROR_UNKNOWN_EXTENSION , \"LUT is not suitable to be saved as LUT16\" ) ;\n return FALSE ;\n }\n InputChannels = cmsPipelineInputChannels ( NewLUT ) ;\n OutputChannels = cmsPipelineOutputChannels ( NewLUT ) ;\n if ( clut == NULL ) clutPoints = 0 ;\n else clutPoints = clut -> Params -> nSamples [ 0 ] ;\n if ( ! _cmsWriteUInt8Number ( io , ( cmsUInt8Number ) InputChannels ) ) return FALSE ;\n if ( ! _cmsWriteUInt8Number ( io , ( cmsUInt8Number ) OutputChannels ) ) return FALSE ;\n if ( ! _cmsWriteUInt8Number ( io , ( cmsUInt8Number ) clutPoints ) ) return FALSE ;\n if ( ! _cmsWriteUInt8Number ( io , 0 ) ) return FALSE ;\n if ( MatMPE != NULL ) {\n if ( ! _cmsWrite15Fixed16Number ( io , MatMPE -> Double [ 0 ] ) ) return FALSE ;\n if ( ! _cmsWrite15Fixed16Number ( io , MatMPE -> Double [ 1 ] ) ) return FALSE ;\n if ( ! _cmsWrite15Fixed16Number ( io , MatMPE -> Double [ 2 ] ) ) return FALSE ;\n if ( ! _cmsWrite15Fixed16Number ( io , MatMPE -> Double [ 3 ] ) ) return FALSE ;\n if ( ! _cmsWrite15Fixed16Number ( io , MatMPE -> Double [ 4 ] ) ) return FALSE ;\n if ( ! _cmsWrite15Fixed16Number ( io , MatMPE -> Double [ 5 ] ) ) return FALSE ;\n if ( ! _cmsWrite15Fixed16Number ( io , MatMPE -> Double [ 6 ] ) ) return FALSE ;\n if ( ! _cmsWrite15Fixed16Number ( io , MatMPE -> Double [ 7 ] ) ) return FALSE ;\n if ( ! _cmsWrite15Fixed16Number ( io , MatMPE -> Double [ 8 ] ) ) return FALSE ;\n }\n else {\n if ( ! _cmsWrite15Fixed16Number ( io , 1 ) ) return FALSE ;\n if ( ! _cmsWrite15Fixed16Number ( io , 0 ) ) return FALSE ;\n if ( ! _cmsWrite15Fixed16Number ( io , 0 ) ) return FALSE ;\n if ( ! _cmsWrite15Fixed16Number ( io , 0 ) ) return FALSE ;\n if ( ! _cmsWrite15Fixed16Number ( io , 1 ) ) return FALSE ;\n if ( ! _cmsWrite15Fixed16Number ( io , 0 ) ) return FALSE ;\n if ( ! _cmsWrite15Fixed16Number ( io , 0 ) ) return FALSE ;\n if ( ! _cmsWrite15Fixed16Number ( io , 0 ) ) return FALSE ;\n if ( ! _cmsWrite15Fixed16Number ( io , 1 ) ) return FALSE ;\n }\n if ( PreMPE != NULL ) {\n if ( ! _cmsWriteUInt16Number ( io , ( cmsUInt16Number ) PreMPE -> TheCurves [ 0 ] -> nEntries ) ) return FALSE ;\n }\n else {\n if ( ! _cmsWriteUInt16Number ( io , 2 ) ) return FALSE ;\n }\n if ( PostMPE != NULL ) {\n if ( ! _cmsWriteUInt16Number ( io , ( cmsUInt16Number ) PostMPE -> TheCurves [ 0 ] -> nEntries ) ) return FALSE ;\n }\n else {\n if ( ! _cmsWriteUInt16Number ( io , 2 ) ) return FALSE ;\n }\n if ( PreMPE != NULL ) {\n if ( ! Write16bitTables ( self -> ContextID , io , PreMPE ) ) return FALSE ;\n }\n else {\n for ( i = 0 ;\n i < InputChannels ;\n i ++ ) {\n if ( ! _cmsWriteUInt16Number ( io , 0 ) ) return FALSE ;\n if ( ! _cmsWriteUInt16Number ( io , 0xffff ) ) return FALSE ;\n }\n }\n nTabSize = uipow ( OutputChannels , clutPoints , InputChannels ) ;\n if ( nTabSize == ( cmsUInt32Number ) - 1 ) return FALSE ;\n if ( nTabSize > 0 ) {\n if ( clut != NULL ) {\n if ( ! _cmsWriteUInt16Array ( io , nTabSize , clut -> Tab . T ) ) return FALSE ;\n }\n }\n if ( PostMPE != NULL ) {\n if ( ! Write16bitTables ( self -> ContextID , io , PostMPE ) ) return FALSE ;\n }\n else {\n for ( i = 0 ;\n i < OutputChannels ;\n i ++ ) {\n if ( ! _cmsWriteUInt16Number ( io , 0 ) ) return FALSE ;\n if ( ! _cmsWriteUInt16Number ( io , 0xffff ) ) return FALSE ;\n }\n }\n return TRUE ;\n cmsUNUSED_PARAMETER ( nItems ) ;\n }", "idx": 22228}
{"hash": 3672688962041927109, "project": "chrome", "size": 53, "label": 0, "functionSource": "vpx_codec_err_t vpx_codec_enc_init_multi_ver ( vpx_codec_ctx_t * ctx , vpx_codec_iface_t * iface , vpx_codec_enc_cfg_t * cfg , int num_enc , vpx_codec_flags_t flags , vpx_rational_t * dsf , int ver ) {\n vpx_codec_err_t res = VPX_CODEC_OK ;\n if ( ver != VPX_ENCODER_ABI_VERSION ) res = VPX_CODEC_ABI_MISMATCH ;\n else if ( ! ctx || ! iface || ! cfg || ( num_enc > 16 || num_enc < 1 ) ) res = VPX_CODEC_INVALID_PARAM ;\n else if ( iface -> abi_version != VPX_CODEC_INTERNAL_ABI_VERSION ) res = VPX_CODEC_ABI_MISMATCH ;\n else if ( ! ( iface -> caps & VPX_CODEC_CAP_ENCODER ) ) res = VPX_CODEC_INCAPABLE ;\n else if ( ( flags & VPX_CODEC_USE_PSNR ) && ! ( iface -> caps & VPX_CODEC_CAP_PSNR ) ) res = VPX_CODEC_INCAPABLE ;\n else if ( ( flags & VPX_CODEC_USE_OUTPUT_PARTITION ) && ! ( iface -> caps & VPX_CODEC_CAP_OUTPUT_PARTITION ) ) res = VPX_CODEC_INCAPABLE ;\n else {\n int i ;\n void * mem_loc = NULL ;\n if ( ! ( res = iface -> enc . mr_get_mem_loc ( cfg , & mem_loc ) ) ) {\n for ( i = 0 ;\n i < num_enc ;\n i ++ ) {\n vpx_codec_priv_enc_mr_cfg_t mr_cfg ;\n if ( dsf -> num < 1 || dsf -> num > 4096 || dsf -> den < 1 || dsf -> den > dsf -> num ) {\n res = VPX_CODEC_INVALID_PARAM ;\n break ;\n }\n mr_cfg . mr_low_res_mode_info = mem_loc ;\n mr_cfg . mr_total_resolutions = num_enc ;\n mr_cfg . mr_encoder_id = num_enc - 1 - i ;\n mr_cfg . mr_down_sampling_factor . num = dsf -> num ;\n mr_cfg . mr_down_sampling_factor . den = dsf -> den ;\n if ( mr_cfg . mr_encoder_id ) cfg -> kf_mode = VPX_KF_DISABLED ;\n ctx -> iface = iface ;\n ctx -> name = iface -> name ;\n ctx -> priv = NULL ;\n ctx -> init_flags = flags ;\n ctx -> config . enc = cfg ;\n res = ctx -> iface -> init ( ctx , & mr_cfg ) ;\n if ( res ) {\n const char * error_detail = ctx -> priv ? ctx -> priv -> err_detail : NULL ;\n ctx -> err_detail = error_detail ;\n vpx_codec_destroy ( ctx ) ;\n while ( i ) {\n ctx -- ;\n ctx -> err_detail = error_detail ;\n vpx_codec_destroy ( ctx ) ;\n i -- ;\n }\n }\n if ( res ) break ;\n ctx ++ ;\n cfg ++ ;\n dsf ++ ;\n }\n ctx -- ;\n }\n }\n return SAVE_STATUS ( ctx , res ) ;\n }", "idx": 22229}
{"hash": -6986708248145981986, "project": "debian", "size": 17, "label": 0, "functionSource": "static kadm5_ret_t copy_tl_data ( krb5_int16 n_tl_data , krb5_tl_data * tl_data , krb5_tl_data * * out ) {\n kadm5_ret_t ret ;\n krb5_tl_data * tl , * tl_new ;\n if ( ( ret = alloc_tl_data ( n_tl_data , out ) ) ) return ret ;\n tl = tl_data ;\n tl_new = * out ;\n for ( ;\n tl ;\n tl = tl -> tl_data_next , tl_new = tl_new -> tl_data_next ) {\n tl_new -> tl_data_contents = malloc ( tl -> tl_data_length ) ;\n if ( tl_new -> tl_data_contents == NULL ) return ENOMEM ;\n memcpy ( tl_new -> tl_data_contents , tl -> tl_data_contents , tl -> tl_data_length ) ;\n tl_new -> tl_data_type = tl -> tl_data_type ;\n tl_new -> tl_data_length = tl -> tl_data_length ;\n }\n return 0 ;\n }", "idx": 22230}
{"hash": 1223258652239369123, "project": "debian", "size": 7, "label": 0, "functionSource": "SPL_METHOD ( SplFileObject , getMaxLineLen ) {\n spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n if ( zend_parse_parameters_none ( ) == FAILURE ) {\n return ;\n }\n RETURN_LONG ( ( long ) intern -> u . file . max_line_len ) ;\n }", "idx": 22231}
{"hash": 1859256631654516868, "project": "chrome", "size": 10, "label": 0, "functionSource": "int ff_h264_get_profile ( SPS * sps ) {\n int profile = sps -> profile_idc ;\n switch ( sps -> profile_idc ) {\n case FF_PROFILE_H264_BASELINE : profile |= ( sps -> constraint_set_flags & 1 << 1 ) ? FF_PROFILE_H264_CONSTRAINED : 0 ;\n break ;\n case FF_PROFILE_H264_HIGH_10 : case FF_PROFILE_H264_HIGH_422 : case FF_PROFILE_H264_HIGH_444_PREDICTIVE : profile |= ( sps -> constraint_set_flags & 1 << 3 ) ? FF_PROFILE_H264_INTRA : 0 ;\n break ;\n }\n return profile ;\n }", "idx": 22232}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_INTEGER_0_7 ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_constrained_integer ( tvb , offset , actx , tree , hf_index , 0U , 7U , NULL , FALSE ) ;\n return offset ;\n }", "idx": 22233}
{"hash": 6632536031698733342, "project": "debian", "size": 5, "label": 0, "functionSource": "static int opt_show_ ## section ( const char * opt , const char * arg ) {\n mark_section_show_entries ( SECTION_ID_ ## target_section_id , 1 , NULL ) ;\n return 0 ;\n }\n DEFINE_OPT_SHOW_SECTION ( chapters , CHAPTERS ) DEFINE_OPT_SHOW_SECTION ( error , ERROR ) DEFINE_OPT_SHOW_SECTION ( format , FORMAT ) DEFINE_OPT_SHOW_SECTION ( frames , FRAMES ) DEFINE_OPT_SHOW_SECTION ( library_versions , LIBRARY_VERSIONS ) DEFINE_OPT_SHOW_SECTION ( packets , PACKETS ) DEFINE_OPT_SHOW_SECTION ( pixel_formats , PIXEL_FORMATS ) DEFINE_OPT_SHOW_SECTION ( program_version , PROGRAM_VERSION ) DEFINE_OPT_SHOW_SECTION ( streams , STREAMS )", "idx": 22234}
{"hash": -5493081488206619677, "project": "debian", "size": 7, "label": 0, "functionSource": "static const char * cmd_audit_log_type ( cmd_parms * cmd , void * _dcfg , const char * p1 ) {\n directory_config * dcfg = _dcfg ;\n if ( strcasecmp ( p1 , \"Serial\" ) == 0 ) dcfg -> auditlog_type = AUDITLOG_SERIAL ;\n else if ( strcasecmp ( p1 , \"Concurrent\" ) == 0 ) dcfg -> auditlog_type = AUDITLOG_CONCURRENT ;\n else return ( const char * ) apr_psprintf ( cmd -> pool , \"ModSecurity: Unrecognised parameter value for SecAuditLogType: %s\" , p1 ) ;\n return NULL ;\n }", "idx": 22235}
{"hash": 8320716512483418415, "project": "chrome", "size": 15, "label": 0, "functionSource": "void vp9_idct32x32_1_add_c ( const tran_low_t * input , uint8_t * dest , int stride ) {\n int i , j ;\n tran_high_t a1 ;\n tran_low_t out = dct_const_round_shift ( input [ 0 ] * cospi_16_64 ) ;\n out = dct_const_round_shift ( out * cospi_16_64 ) ;\n a1 = ROUND_POWER_OF_TWO ( out , 6 ) ;\n for ( j = 0 ;\n j < 32 ;\n ++ j ) {\n for ( i = 0 ;\n i < 32 ;\n ++ i ) dest [ i ] = clip_pixel ( dest [ i ] + a1 ) ;\n dest += stride ;\n }\n }", "idx": 22236}
{"hash": -1335877942018854351, "project": "chrome", "size": 7, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( UnloadTest , BrowserCloseBeforeUnloadOK ) {\n NavigateToDataURL ( BEFORE_UNLOAD_HTML , \"beforeunload\" ) ;\n content : : WindowedNotificationObserver window_observer ( chrome : : NOTIFICATION_BROWSER_CLOSED , content : : NotificationService : : AllSources ( ) ) ;\n chrome : : CloseWindow ( browser ( ) ) ;\n ClickModalDialogButton ( true ) ;\n window_observer . Wait ( ) ;\n }", "idx": 22237}
{"hash": -8933711118846965366, "project": "debian", "size": 27, "label": 0, "functionSource": "static void cirrus_update_bank_ptr ( CirrusVGAState * s , unsigned bank_index ) {\n unsigned offset ;\n unsigned limit ;\n if ( ( s -> vga . gr [ 0x0b ] & 0x01 ) != 0 ) offset = s -> vga . gr [ 0x09 + bank_index ] ;\n else offset = s -> vga . gr [ 0x09 ] ;\n if ( ( s -> vga . gr [ 0x0b ] & 0x20 ) != 0 ) offset <<= 14 ;\n else offset <<= 12 ;\n if ( s -> real_vram_size <= offset ) limit = 0 ;\n else limit = s -> real_vram_size - offset ;\n if ( ( ( s -> vga . gr [ 0x0b ] & 0x01 ) == 0 ) && ( bank_index != 0 ) ) {\n if ( limit > 0x8000 ) {\n offset += 0x8000 ;\n limit -= 0x8000 ;\n }\n else {\n limit = 0 ;\n }\n }\n if ( limit > 0 ) {\n s -> cirrus_bank_base [ bank_index ] = offset ;\n s -> cirrus_bank_limit [ bank_index ] = limit ;\n }\n else {\n s -> cirrus_bank_base [ bank_index ] = 0 ;\n s -> cirrus_bank_limit [ bank_index ] = 0 ;\n }\n }", "idx": 22238}
{"hash": 7651945086108393719, "project": "debian", "size": 17, "label": 0, "functionSource": "int qemuMonitorJSONAddDrive ( qemuMonitorPtr mon , const char * drivestr ) {\n int ret ;\n virJSONValuePtr cmd ;\n virJSONValuePtr reply = NULL ;\n cmd = qemuMonitorJSONMakeCommand ( \"drive_add\" , \"s:pci_addr\" , \"dummy\" , \"s:opts\" , drivestr , NULL ) ;\n if ( ! cmd ) return - 1 ;\n if ( ( ret = qemuMonitorJSONCommand ( mon , cmd , & reply ) < 0 ) ) goto cleanup ;\n if ( qemuMonitorJSONHasError ( reply , \"CommandNotFound\" ) && qemuMonitorCheckHMP ( mon , \"drive_add\" ) ) {\n VIR_DEBUG ( \"drive_add command not found, trying HMP\" ) ;\n ret = qemuMonitorTextAddDrive ( mon , drivestr ) ;\n goto cleanup ;\n }\n ret = qemuMonitorJSONCheckError ( cmd , reply ) ;\n cleanup : virJSONValueFree ( cmd ) ;\n virJSONValueFree ( reply ) ;\n return ret ;\n }", "idx": 22239}
{"hash": 1760449185745615462, "project": "debian", "size": 3, "label": 0, "functionSource": "TSReturnCode TSMgmtCounterGet ( const char * var_name , TSMgmtCounter * result ) {\n return RecGetRecordCounter ( ( char * ) var_name , ( RecCounter * ) result ) == REC_ERR_OKAY ? TS_SUCCESS : TS_ERROR ;\n }", "idx": 22240}
{"hash": -3165961362620712443, "project": "chrome", "size": 3, "label": 1, "functionSource": "static void initial_reordering_vowel_syllable ( const hb_ot_shape_plan_t * plan , hb_face_t * face , hb_buffer_t * buffer , unsigned int start , unsigned int end ) {\n initial_reordering_consonant_syllable ( plan , face , buffer , start , end ) ;\n }", "idx": 22241}
{"hash": 8484475213808847345, "project": "debian", "size": 5, "label": 0, "functionSource": "void qdev_init_gpio_in ( DeviceState * dev , qemu_irq_handler handler , int n ) {\n assert ( dev -> num_gpio_in == 0 ) ;\n dev -> num_gpio_in = n ;\n dev -> gpio_in = qemu_allocate_irqs ( handler , dev , n ) ;\n }", "idx": 22242}
{"hash": 2546373479020365143, "project": "debian", "size": 22, "label": 0, "functionSource": "void mime_field_block_describe ( HdrHeapObjImpl * raw , bool ) {\n unsigned int i ;\n static const char * readiness_names [ ] = {\n \"EMPTY\" , \"DETACHED\" , \"LIVE\" , \"DELETED\" }\n ;\n MIMEFieldBlockImpl * obj = ( MIMEFieldBlockImpl * ) raw ;\n Debug ( \"http\" , \"[FREETOP: %d, NEXTBLK: %p]\" , obj -> m_freetop , obj -> m_next ) ;\n for ( i = 0 ;\n i < obj -> m_freetop ;\n i ++ ) {\n MIMEField * f = & ( obj -> m_field_slots [ i ] ) ;\n Debug ( \"http\" , \"\\tSLOT #%2d (%p), %-8s\" , i , f , readiness_names [ f -> m_readiness ] ) ;\n switch ( f -> m_readiness ) {\n case MIME_FIELD_SLOT_READINESS_EMPTY : break ;\n case MIME_FIELD_SLOT_READINESS_DETACHED : case MIME_FIELD_SLOT_READINESS_LIVE : case MIME_FIELD_SLOT_READINESS_DELETED : Debug ( \"http\" , \"[N: \\\"%.*s\\\", N_LEN: %d, N_IDX: %d, \" , f -> m_len_name , ( f -> m_ptr_name ? f -> m_ptr_name : \"NULL\" ) , f -> m_len_name , f -> m_wks_idx ) ;\n Debug ( \"http\" , \"V: \\\"%.*s\\\", V_LEN: %d, \" , f -> m_len_value , ( f -> m_ptr_value ? f -> m_ptr_value : \"NULL\" ) , f -> m_len_value ) ;\n Debug ( \"http\" , \"NEXTDUP: %p, RAW: %d, RAWLEN: %d, F: %d]\" , f -> m_next_dup , f -> m_n_v_raw_printable , f -> m_len_name + f -> m_len_value + f -> m_n_v_raw_printable_pad , f -> m_flags ) ;\n break ;\n }\n Debug ( \"http\" , \"\\n\" ) ;\n }\n }", "idx": 22243}
{"hash": -1658505547857059267, "project": "debian", "size": 11, "label": 1, "functionSource": "static void pic_as_field ( Picture * pic , const int parity ) {\n int i ;\n for ( i = 0 ;\n i < 4 ;\n ++ i ) {\n if ( parity == PICT_BOTTOM_FIELD ) pic -> f . data [ i ] += pic -> f . linesize [ i ] ;\n pic -> f . reference = parity ;\n pic -> f . linesize [ i ] *= 2 ;\n }\n pic -> poc = pic -> field_poc [ parity == PICT_BOTTOM_FIELD ] ;\n }", "idx": 22244}
{"hash": 378220832151730865, "project": "debian", "size": 21, "label": 0, "functionSource": "int qemuMonitorTextExpirePassword ( qemuMonitorPtr mon , const char * protocol , const char * expire_time ) {\n char * cmd = NULL ;\n char * reply = NULL ;\n int ret = - 1 ;\n if ( virAsprintf ( & cmd , \"expire_password %s %s\" , protocol , expire_time ) < 0 ) {\n virReportOOMError ( ) ;\n goto cleanup ;\n }\n if ( qemuMonitorHMPCommand ( mon , cmd , & reply ) < 0 ) {\n qemuReportError ( VIR_ERR_OPERATION_FAILED , \"%s\" , _ ( \"expiring password failed\" ) ) ;\n goto cleanup ;\n }\n if ( strstr ( reply , \"unknown command:\" ) ) {\n ret = - 2 ;\n goto cleanup ;\n }\n ret = 0 ;\n cleanup : VIR_FREE ( reply ) ;\n VIR_FREE ( cmd ) ;\n return ret ;\n }", "idx": 22245}
{"hash": 7399683071036018868, "project": "debian", "size": 4, "label": 0, "functionSource": "static int pdo_row_serialize ( zval * object , unsigned char * * buffer , zend_uint * buf_len , zend_serialize_data * data TSRMLS_DC ) {\n php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"PDORow instances may not be serialized\" ) ;\n return FAILURE ;\n }", "idx": 22246}
{"hash": -8958254313220732728, "project": "debian", "size": 11, "label": 0, "functionSource": "static int virtio_serial_init_pci ( PCIDevice * pci_dev ) {\n VirtIOPCIProxy * proxy = DO_UPCAST ( VirtIOPCIProxy , pci_dev , pci_dev ) ;\n VirtIODevice * vdev ;\n if ( proxy -> class_code != PCI_CLASS_COMMUNICATION_OTHER && proxy -> class_code != PCI_CLASS_DISPLAY_OTHER && proxy -> class_code != PCI_CLASS_OTHERS ) proxy -> class_code = PCI_CLASS_COMMUNICATION_OTHER ;\n vdev = virtio_serial_init ( & pci_dev -> qdev , proxy -> max_virtserial_ports ) ;\n if ( ! vdev ) {\n return - 1 ;\n }\n virtio_init_pci ( proxy , vdev , PCI_VENDOR_ID_REDHAT_QUMRANET , PCI_DEVICE_ID_VIRTIO_CONSOLE , proxy -> class_code , 0x00 ) ;\n return 0 ;\n }", "idx": 22247}
{"hash": 4811253651057229458, "project": "debian", "size": 167, "label": 1, "functionSource": "static void CONCAT ( send_hextile_tile_ , NAME ) ( VncState * vs , int x , int y , int w , int h , void * last_bg_ , void * last_fg_ , int * has_bg , int * has_fg ) {\n uint8_t * row = ( ds_get_data ( vs -> ds ) + y * ds_get_linesize ( vs -> ds ) + x * vs -> depth ) ;\n pixel_t * irow = ( pixel_t * ) row ;\n int j , i ;\n pixel_t * last_bg = ( pixel_t * ) last_bg_ ;\n pixel_t * last_fg = ( pixel_t * ) last_fg_ ;\n pixel_t bg = 0 ;\n pixel_t fg = 0 ;\n int n_colors = 0 ;\n int bg_count = 0 ;\n int fg_count = 0 ;\n int flags = 0 ;\n uint8_t data [ ( vs -> pix_bpp + 2 ) * 16 * 16 ] ;\n int n_data = 0 ;\n int n_subtiles = 0 ;\n for ( j = 0 ;\n j < h ;\n j ++ ) {\n for ( i = 0 ;\n i < w ;\n i ++ ) {\n switch ( n_colors ) {\n case 0 : bg = irow [ i ] ;\n n_colors = 1 ;\n break ;\n case 1 : if ( irow [ i ] != bg ) {\n fg = irow [ i ] ;\n n_colors = 2 ;\n }\n break ;\n case 2 : if ( irow [ i ] != bg && irow [ i ] != fg ) {\n n_colors = 3 ;\n }\n else {\n if ( irow [ i ] == bg ) bg_count ++ ;\n else if ( irow [ i ] == fg ) fg_count ++ ;\n }\n break ;\n default : break ;\n }\n }\n if ( n_colors > 2 ) break ;\n irow += ds_get_linesize ( vs -> ds ) / sizeof ( pixel_t ) ;\n }\n if ( n_colors > 1 && fg_count > bg_count ) {\n pixel_t tmp = fg ;\n fg = bg ;\n bg = tmp ;\n }\n if ( ! * has_bg || * last_bg != bg ) {\n flags |= 0x02 ;\n * has_bg = 1 ;\n * last_bg = bg ;\n }\n if ( ! * has_fg || * last_fg != fg ) {\n flags |= 0x04 ;\n * has_fg = 1 ;\n * last_fg = fg ;\n }\n switch ( n_colors ) {\n case 1 : n_data = 0 ;\n break ;\n case 2 : flags |= 0x08 ;\n irow = ( pixel_t * ) row ;\n for ( j = 0 ;\n j < h ;\n j ++ ) {\n int min_x = - 1 ;\n for ( i = 0 ;\n i < w ;\n i ++ ) {\n if ( irow [ i ] == fg ) {\n if ( min_x == - 1 ) min_x = i ;\n }\n else if ( min_x != - 1 ) {\n hextile_enc_cord ( data + n_data , min_x , j , i - min_x , 1 ) ;\n n_data += 2 ;\n n_subtiles ++ ;\n min_x = - 1 ;\n }\n }\n if ( min_x != - 1 ) {\n hextile_enc_cord ( data + n_data , min_x , j , i - min_x , 1 ) ;\n n_data += 2 ;\n n_subtiles ++ ;\n }\n irow += ds_get_linesize ( vs -> ds ) / sizeof ( pixel_t ) ;\n }\n break ;\n case 3 : flags |= 0x18 ;\n irow = ( pixel_t * ) row ;\n if ( ! * has_bg || * last_bg != bg ) flags |= 0x02 ;\n for ( j = 0 ;\n j < h ;\n j ++ ) {\n int has_color = 0 ;\n int min_x = - 1 ;\n pixel_t color = 0 ;\n for ( i = 0 ;\n i < w ;\n i ++ ) {\n if ( ! has_color ) {\n if ( irow [ i ] == bg ) continue ;\n color = irow [ i ] ;\n min_x = i ;\n has_color = 1 ;\n }\n else if ( irow [ i ] != color ) {\n has_color = 0 ;\n # ifdef GENERIC vnc_convert_pixel ( vs , data + n_data , color ) ;\n n_data += vs -> pix_bpp ;\n # else memcpy ( data + n_data , & color , sizeof ( color ) ) ;\n n_data += sizeof ( pixel_t ) ;\n # endif hextile_enc_cord ( data + n_data , min_x , j , i - min_x , 1 ) ;\n n_data += 2 ;\n n_subtiles ++ ;\n min_x = - 1 ;\n if ( irow [ i ] != bg ) {\n color = irow [ i ] ;\n min_x = i ;\n has_color = 1 ;\n }\n }\n }\n if ( has_color ) {\n # ifdef GENERIC vnc_convert_pixel ( vs , data + n_data , color ) ;\n n_data += vs -> pix_bpp ;\n # else memcpy ( data + n_data , & color , sizeof ( color ) ) ;\n n_data += sizeof ( pixel_t ) ;\n # endif hextile_enc_cord ( data + n_data , min_x , j , i - min_x , 1 ) ;\n n_data += 2 ;\n n_subtiles ++ ;\n }\n irow += ds_get_linesize ( vs -> ds ) / sizeof ( pixel_t ) ;\n }\n * has_fg = 0 ;\n if ( n_data > ( w * h * sizeof ( pixel_t ) ) ) {\n n_colors = 4 ;\n flags = 0x01 ;\n * has_bg = 0 ;\n }\n default : break ;\n }\n if ( n_colors > 3 ) {\n flags = 0x01 ;\n * has_fg = 0 ;\n * has_bg = 0 ;\n n_colors = 4 ;\n }\n vnc_write_u8 ( vs , flags ) ;\n if ( n_colors < 4 ) {\n if ( flags & 0x02 ) vs -> write_pixels ( vs , last_bg , sizeof ( pixel_t ) ) ;\n if ( flags & 0x04 ) vs -> write_pixels ( vs , last_fg , sizeof ( pixel_t ) ) ;\n if ( n_subtiles ) {\n vnc_write_u8 ( vs , n_subtiles ) ;\n vnc_write ( vs , data , n_data ) ;\n }\n }\n else {\n for ( j = 0 ;\n j < h ;\n j ++ ) {\n vs -> write_pixels ( vs , row , w * vs -> depth ) ;\n row += ds_get_linesize ( vs -> ds ) ;\n }\n }\n }", "idx": 22248}
{"hash": 3668456668028959955, "project": "debian", "size": 6, "label": 0, "functionSource": "static VALUE mString_Extend_json_create ( VALUE self , VALUE o ) {\n VALUE ary ;\n Check_Type ( o , T_HASH ) ;\n ary = rb_hash_aref ( o , rb_str_new2 ( \"raw\" ) ) ;\n return rb_funcall ( ary , i_pack , 1 , rb_str_new2 ( \"C*\" ) ) ;\n }", "idx": 22249}
{"hash": 1202634027547122397, "project": "debian", "size": 40, "label": 0, "functionSource": "static int kex_agree_kex_hostkey ( LIBSSH2_SESSION * session , unsigned char * kex , unsigned long kex_len , unsigned char * hostkey , unsigned long hostkey_len ) {\n const LIBSSH2_KEX_METHOD * * kexp = libssh2_kex_methods ;\n unsigned char * s ;\n if ( session -> kex_prefs ) {\n s = ( unsigned char * ) session -> kex_prefs ;\n while ( s && * s ) {\n unsigned char * q , * p = ( unsigned char * ) strchr ( ( char * ) s , ',' ) ;\n size_t method_len = ( p ? ( size_t ) ( p - s ) : strlen ( ( char * ) s ) ) ;\n if ( ( q = kex_agree_instr ( kex , kex_len , s , method_len ) ) ) {\n const LIBSSH2_KEX_METHOD * method = ( const LIBSSH2_KEX_METHOD * ) kex_get_method_by_name ( ( char * ) s , method_len , ( const LIBSSH2_COMMON_METHOD * * ) kexp ) ;\n if ( ! method ) {\n return - 1 ;\n }\n if ( kex_agree_hostkey ( session , method -> flags , hostkey , hostkey_len ) == 0 ) {\n session -> kex = method ;\n if ( session -> burn_optimistic_kexinit && ( kex == q ) ) {\n session -> burn_optimistic_kexinit = 0 ;\n }\n return 0 ;\n }\n }\n s = p ? p + 1 : NULL ;\n }\n return - 1 ;\n }\n while ( * kexp && ( * kexp ) -> name ) {\n s = kex_agree_instr ( kex , kex_len , ( unsigned char * ) ( * kexp ) -> name , strlen ( ( * kexp ) -> name ) ) ;\n if ( s ) {\n if ( kex_agree_hostkey ( session , ( * kexp ) -> flags , hostkey , hostkey_len ) == 0 ) {\n session -> kex = * kexp ;\n if ( session -> burn_optimistic_kexinit && ( kex == s ) ) {\n session -> burn_optimistic_kexinit = 0 ;\n }\n return 0 ;\n }\n }\n kexp ++ ;\n }\n return - 1 ;\n }", "idx": 22250}
{"hash": 6755873269946787742, "project": "debian", "size": 29, "label": 0, "functionSource": "static void pk_transaction_upgrade_system ( PkTransaction * transaction , GVariant * params , GDBusMethodInvocation * context ) {\n gboolean ret ;\n PkBitfield transaction_flags ;\n PkUpgradeKindEnum upgrade_kind ;\n const gchar * distro_id ;\n g_autoptr ( GError ) error = NULL ;\n g_autofree gchar * transaction_flags_temp = NULL ;\n g_return_if_fail ( PK_IS_TRANSACTION ( transaction ) ) ;\n g_return_if_fail ( transaction -> priv -> tid != NULL ) ;\n g_variant_get ( params , \"(t&su)\" , & transaction_flags , & distro_id , & upgrade_kind ) ;\n transaction_flags_temp = pk_transaction_flag_bitfield_to_string ( transaction_flags ) ;\n g_debug ( \"UpgradeSystem method called: %s: %s (transaction_flags: %s)\" , distro_id , pk_upgrade_kind_enum_to_string ( upgrade_kind ) , transaction_flags_temp ) ;\n if ( ! pk_backend_is_implemented ( transaction -> priv -> backend , PK_ROLE_ENUM_UPGRADE_SYSTEM ) ) {\n g_set_error ( & error , PK_TRANSACTION_ERROR , PK_TRANSACTION_ERROR_NOT_SUPPORTED , \"UpgradeSystem not supported by backend\" ) ;\n pk_transaction_set_state ( transaction , PK_TRANSACTION_STATE_ERROR ) ;\n goto out ;\n }\n transaction -> priv -> cached_transaction_flags = transaction_flags ;\n transaction -> priv -> cached_value = g_strdup ( distro_id ) ;\n transaction -> priv -> cached_upgrade_kind = upgrade_kind ;\n pk_transaction_set_role ( transaction , PK_ROLE_ENUM_UPGRADE_SYSTEM ) ;\n pk_transaction_emit_property_changed ( transaction , \"TransactionFlags\" , g_variant_new_uint64 ( transaction_flags ) ) ;\n ret = pk_transaction_obtain_authorization ( transaction , PK_ROLE_ENUM_UPGRADE_SYSTEM , & error ) ;\n if ( ! ret ) {\n pk_transaction_set_state ( transaction , PK_TRANSACTION_STATE_ERROR ) ;\n goto out ;\n }\n out : pk_transaction_dbus_return ( context , error ) ;\n }", "idx": 22251}
{"hash": 3035587999006680483, "project": "debian", "size": 63, "label": 0, "functionSource": "static long dtls1_get_message_fragment ( SSL * s , int st1 , int stn , long max , int * ok ) {\n unsigned char wire [ DTLS1_HM_HEADER_LENGTH ] ;\n unsigned long len , frag_off , frag_len ;\n int i , al ;\n struct hm_header_st msg_hdr ;\n if ( ( frag_len = dtls1_retrieve_buffered_fragment ( s , max , ok ) ) || * ok ) {\n if ( * ok ) s -> init_num = frag_len ;\n return frag_len ;\n }\n i = s -> method -> ssl_read_bytes ( s , SSL3_RT_HANDSHAKE , wire , DTLS1_HM_HEADER_LENGTH , 0 ) ;\n if ( i <= 0 ) {\n s -> rwstate = SSL_READING ;\n * ok = 0 ;\n return i ;\n }\n if ( i != DTLS1_HM_HEADER_LENGTH ) {\n al = SSL_AD_UNEXPECTED_MESSAGE ;\n SSLerr ( SSL_F_DTLS1_GET_MESSAGE_FRAGMENT , SSL_R_UNEXPECTED_MESSAGE ) ;\n goto f_err ;\n }\n dtls1_get_message_header ( wire , & msg_hdr ) ;\n if ( msg_hdr . seq != s -> d1 -> handshake_read_seq && ! ( s -> d1 -> listen && msg_hdr . seq == 1 ) ) return dtls1_process_out_of_seq_message ( s , & msg_hdr , ok ) ;\n len = msg_hdr . msg_len ;\n frag_off = msg_hdr . frag_off ;\n frag_len = msg_hdr . frag_len ;\n if ( frag_len && frag_len < len ) return dtls1_reassemble_fragment ( s , & msg_hdr , ok ) ;\n if ( ! s -> server && s -> d1 -> r_msg_hdr . frag_off == 0 && wire [ 0 ] == SSL3_MT_HELLO_REQUEST ) {\n if ( wire [ 1 ] == 0 && wire [ 2 ] == 0 && wire [ 3 ] == 0 ) {\n if ( s -> msg_callback ) s -> msg_callback ( 0 , s -> version , SSL3_RT_HANDSHAKE , wire , DTLS1_HM_HEADER_LENGTH , s , s -> msg_callback_arg ) ;\n s -> init_num = 0 ;\n return dtls1_get_message_fragment ( s , st1 , stn , max , ok ) ;\n }\n else {\n al = SSL_AD_UNEXPECTED_MESSAGE ;\n SSLerr ( SSL_F_DTLS1_GET_MESSAGE_FRAGMENT , SSL_R_UNEXPECTED_MESSAGE ) ;\n goto f_err ;\n }\n }\n if ( ( al = dtls1_preprocess_fragment ( s , & msg_hdr , max ) ) ) goto f_err ;\n s -> state = stn ;\n if ( frag_len > 0 ) {\n unsigned char * p = ( unsigned char * ) s -> init_buf -> data + DTLS1_HM_HEADER_LENGTH ;\n i = s -> method -> ssl_read_bytes ( s , SSL3_RT_HANDSHAKE , & p [ frag_off ] , frag_len , 0 ) ;\n if ( i <= 0 ) {\n s -> rwstate = SSL_READING ;\n * ok = 0 ;\n return i ;\n }\n }\n else i = 0 ;\n if ( i != ( int ) frag_len ) {\n al = SSL3_AD_ILLEGAL_PARAMETER ;\n SSLerr ( SSL_F_DTLS1_GET_MESSAGE_FRAGMENT , SSL3_AD_ILLEGAL_PARAMETER ) ;\n goto f_err ;\n }\n * ok = 1 ;\n s -> init_num = frag_len ;\n return frag_len ;\n f_err : ssl3_send_alert ( s , SSL3_AL_FATAL , al ) ;\n s -> init_num = 0 ;\n * ok = 0 ;\n return ( - 1 ) ;\n }", "idx": 22252}
{"hash": 3599206110384554647, "project": "debian", "size": 11, "label": 0, "functionSource": "static ossl_inline void lh_ ## type ## _set_down_load ( LHASH_OF ( type ) * lh , unsigned long dl ) {\n OPENSSL_LH_set_down_load ( ( OPENSSL_LHASH * ) lh , dl ) ;\n }\n static ossl_inline void lh_ ## type ## _doall ( LHASH_OF ( type ) * lh , void ( * doall ) ( type * ) ) {\n OPENSSL_LH_doall ( ( OPENSSL_LHASH * ) lh , ( OPENSSL_LH_DOALL_FUNC ) doall ) ;\n }\n LHASH_OF ( type ) # define IMPLEMENT_LHASH_DOALL_ARG_CONST ( type , argtype ) int_implement_lhash_doall ( type , argtype , const type ) # define IMPLEMENT_LHASH_DOALL_ARG ( type , argtype ) int_implement_lhash_doall ( type , argtype , type ) # define int_implement_lhash_doall ( type , argtype , cbargtype ) static ossl_inline void lh_ ## type ## _doall_ ## argtype ( LHASH_OF ( type ) * lh , void ( * fn ) ( cbargtype * , argtype * ) , argtype * arg ) {\n OPENSSL_LH_doall_arg ( ( OPENSSL_LHASH * ) lh , ( OPENSSL_LH_DOALL_FUNCARG ) fn , ( void * ) arg ) ;\n }\n LHASH_OF ( type ) DEFINE_LHASH_OF ( OPENSSL_STRING ) ;\n # ifdef _MSC_VER # pragma warning ( push ) # pragma warning ( disable : 4090 ) # endif DEFINE_LHASH_OF ( OPENSSL_CSTRING )", "idx": 22253}
{"hash": -1672864273235910388, "project": "debian", "size": 181, "label": 0, "functionSource": "static void _slurm_rpc_allocate_pack ( slurm_msg_t * msg ) {\n static int select_serial = - 1 ;\n static int active_rpc_cnt = 0 ;\n int error_code = SLURM_SUCCESS , inx , pack_cnt = - 1 ;\n DEF_TIMERS ;\n job_desc_msg_t * job_desc_msg ;\n List job_req_list = ( List ) msg -> data ;\n slurmctld_lock_t job_write_lock = {\n READ_LOCK , WRITE_LOCK , WRITE_LOCK , READ_LOCK , READ_LOCK }\n ;\n uid_t uid = g_slurm_auth_get_uid ( msg -> auth_cred , slurmctld_config . auth_info ) ;\n gid_t gid = g_slurm_auth_get_gid ( msg -> auth_cred , slurmctld_config . auth_info ) ;\n uint32_t job_uid = NO_VAL ;\n struct job_record * job_ptr , * first_job_ptr = NULL ;\n char * err_msg = NULL , * * job_submit_user_msg = NULL ;\n ListIterator iter ;\n List submit_job_list = NULL ;\n uint32_t pack_job_id = 0 , pack_job_offset = 0 ;\n hostset_t jobid_hostset = NULL ;\n char tmp_str [ 32 ] ;\n List resp = NULL ;\n slurm_addr_t resp_addr ;\n char resp_host [ 16 ] ;\n uint16_t port ;\n START_TIMER ;\n if ( select_serial == - 1 ) {\n if ( xstrcmp ( slurmctld_conf . select_type , \"select/serial\" ) ) select_serial = 0 ;\n else select_serial = 1 ;\n }\n if ( slurmctld_config . submissions_disabled || ( select_serial == 1 ) ) {\n info ( \"Submissions disabled on system\" ) ;\n error_code = ESLURM_SUBMISSIONS_DISABLED ;\n goto send_msg ;\n }\n if ( ! _sched_backfill ( ) ) {\n error_code = ESLURM_NOT_SUPPORTED ;\n goto send_msg ;\n }\n if ( ! job_req_list || ( list_count ( job_req_list ) == 0 ) ) {\n info ( \"REQUEST_JOB_PACK_ALLOCATION from uid=%d with empty job list\" , uid ) ;\n error_code = SLURM_ERROR ;\n goto send_msg ;\n }\n if ( slurm_get_peer_addr ( msg -> conn_fd , & resp_addr ) == 0 ) {\n slurm_get_ip_str ( & resp_addr , & port , resp_host , sizeof ( resp_host ) ) ;\n }\n else {\n info ( \"REQUEST_JOB_PACK_ALLOCATION from uid=%d , can't get peer addr\" , uid ) ;\n error_code = SLURM_ERROR ;\n goto send_msg ;\n }\n debug2 ( \"sched: Processing RPC: REQUEST_JOB_PACK_ALLOCATION from uid=%d\" , uid ) ;\n pack_cnt = list_count ( job_req_list ) ;\n job_submit_user_msg = xmalloc ( sizeof ( char * ) * pack_cnt ) ;\n submit_job_list = list_create ( NULL ) ;\n _throttle_start ( & active_rpc_cnt ) ;\n lock_slurmctld ( job_write_lock ) ;\n inx = 0 ;\n iter = list_iterator_create ( job_req_list ) ;\n while ( ( job_desc_msg = ( job_desc_msg_t * ) list_next ( iter ) ) ) {\n if ( job_uid == NO_VAL ) job_uid = job_desc_msg -> user_id ;\n if ( ( error_code = _valid_id ( \"REQUEST_JOB_PACK_ALLOCATION\" , job_desc_msg , uid , gid ) ) ) {\n break ;\n }\n if ( ( job_desc_msg -> alloc_node == NULL ) || ( job_desc_msg -> alloc_node [ 0 ] == '\\0' ) ) {\n error_code = ESLURM_INVALID_NODE_NAME ;\n error ( \"REQUEST_JOB_PACK_ALLOCATION lacks alloc_node from uid=%d\" , uid ) ;\n break ;\n }\n if ( job_desc_msg -> array_inx ) {\n error_code = ESLURM_INVALID_ARRAY ;\n break ;\n }\n if ( job_desc_msg -> immediate ) {\n error_code = ESLURM_CAN_NOT_START_IMMEDIATELY ;\n break ;\n }\n job_desc_msg -> pack_job_offset = pack_job_offset ;\n error_code = validate_job_create_req ( job_desc_msg , uid , & job_submit_user_msg [ inx ++ ] ) ;\n if ( error_code ) break ;\n # if HAVE_ALPS_CRAY if ( allocated_session_in_use ( job_desc_msg ) ) {\n error_code = ESLURM_RESERVATION_BUSY ;\n error ( \"attempt to nest ALPS allocation on %s:%d by uid=%d\" , job_desc_msg -> alloc_node , job_desc_msg -> alloc_sid , uid ) ;\n break ;\n }\n # endif dump_job_desc ( job_desc_msg ) ;\n job_ptr = NULL ;\n if ( ! job_desc_msg -> resp_host ) job_desc_msg -> resp_host = xstrdup ( resp_host ) ;\n if ( pack_job_offset ) {\n job_desc_msg -> mail_type = 0 ;\n xfree ( job_desc_msg -> mail_user ) ;\n }\n job_desc_msg -> pack_job_offset = pack_job_offset ;\n error_code = job_allocate ( job_desc_msg , false , false , NULL , true , uid , & job_ptr , & err_msg , msg -> protocol_version ) ;\n if ( ! job_ptr ) {\n if ( error_code == SLURM_SUCCESS ) error_code = SLURM_ERROR ;\n break ;\n }\n if ( error_code && ( job_ptr -> job_state == JOB_FAILED ) ) break ;\n error_code = SLURM_SUCCESS ;\n if ( pack_job_id == 0 ) {\n pack_job_id = job_ptr -> job_id ;\n first_job_ptr = job_ptr ;\n }\n snprintf ( tmp_str , sizeof ( tmp_str ) , \"%u\" , job_ptr -> job_id ) ;\n if ( jobid_hostset ) hostset_insert ( jobid_hostset , tmp_str ) ;\n else jobid_hostset = hostset_create ( tmp_str ) ;\n job_ptr -> pack_job_id = pack_job_id ;\n job_ptr -> pack_job_offset = pack_job_offset ++ ;\n list_append ( submit_job_list , job_ptr ) ;\n }\n list_iterator_destroy ( iter ) ;\n if ( ( error_code == 0 ) && ( ! first_job_ptr ) ) {\n error ( \"%s: No error, but no pack_job_id\" , __func__ ) ;\n error_code = SLURM_ERROR ;\n }\n if ( ( error_code == SLURM_SUCCESS ) && ( accounting_enforce & ACCOUNTING_ENFORCE_LIMITS ) && ! acct_policy_validate_pack ( submit_job_list ) ) {\n info ( \"Pack job %u exceeded association/QOS limit for user %u\" , pack_job_id , job_uid ) ;\n error_code = ESLURM_ACCOUNTING_POLICY ;\n }\n if ( error_code ) {\n ( void ) list_for_each ( submit_job_list , _pack_job_cancel , NULL ) ;\n if ( first_job_ptr ) first_job_ptr -> pack_job_list = submit_job_list ;\n else FREE_NULL_LIST ( submit_job_list ) ;\n }\n else {\n resource_allocation_response_msg_t * alloc_msg ;\n ListIterator iter ;\n int buf_size = pack_job_offset * 16 ;\n char * tmp_str = xmalloc ( buf_size ) ;\n char * tmp_offset = tmp_str ;\n first_job_ptr -> pack_job_list = submit_job_list ;\n hostset_ranged_string ( jobid_hostset , buf_size , tmp_str ) ;\n if ( tmp_str [ 0 ] == '[' ) {\n tmp_offset = strchr ( tmp_str , ']' ) ;\n if ( tmp_offset ) tmp_offset [ 0 ] = '\\0' ;\n tmp_offset = tmp_str + 1 ;\n }\n inx = 0 ;\n iter = list_iterator_create ( submit_job_list ) ;\n while ( ( job_ptr = ( struct job_record * ) list_next ( iter ) ) ) {\n job_ptr -> pack_job_id_set = xstrdup ( tmp_offset ) ;\n if ( ! resp ) resp = list_create ( _del_alloc_pack_msg ) ;\n alloc_msg = xmalloc_nz ( sizeof ( resource_allocation_response_msg_t ) ) ;\n _build_alloc_msg ( job_ptr , alloc_msg , error_code , job_submit_user_msg [ inx ++ ] ) ;\n list_append ( resp , alloc_msg ) ;\n if ( slurmctld_conf . debug_flags & DEBUG_FLAG_HETERO_JOBS ) {\n char buf [ BUFSIZ ] ;\n info ( \"Submit %s\" , jobid2fmt ( job_ptr , buf , sizeof ( buf ) ) ) ;\n }\n }\n list_iterator_destroy ( iter ) ;\n xfree ( tmp_str ) ;\n }\n unlock_slurmctld ( job_write_lock ) ;\n _throttle_fini ( & active_rpc_cnt ) ;\n END_TIMER2 ( \"_slurm_rpc_allocate_pack\" ) ;\n if ( resp ) {\n slurm_msg_t response_msg ;\n slurm_msg_t_init ( & response_msg ) ;\n response_msg . conn = msg -> conn ;\n response_msg . flags = msg -> flags ;\n response_msg . protocol_version = msg -> protocol_version ;\n response_msg . msg_type = RESPONSE_JOB_PACK_ALLOCATION ;\n response_msg . data = resp ;\n if ( slurm_send_node_msg ( msg -> conn_fd , & response_msg ) < 0 ) _kill_job_on_msg_fail ( pack_job_id ) ;\n list_destroy ( resp ) ;\n }\n else {\n send_msg : info ( \"%s: %s \" , __func__ , slurm_strerror ( error_code ) ) ;\n if ( err_msg ) slurm_send_rc_err_msg ( msg , error_code , err_msg ) ;\n else slurm_send_rc_msg ( msg , error_code ) ;\n }\n xfree ( err_msg ) ;\n for ( inx = 0 ;\n inx < pack_cnt ;\n inx ++ ) xfree ( job_submit_user_msg [ inx ] ) ;\n xfree ( job_submit_user_msg ) ;\n if ( jobid_hostset ) hostset_destroy ( jobid_hostset ) ;\n schedule_job_save ( ) ;\n }", "idx": 22254}
{"hash": 6249489553242542670, "project": "debian", "size": 12, "label": 0, "functionSource": "static void config_ttl ( config_tree * ptree ) {\n int i = 0 ;\n int_node * curr_ttl ;\n curr_ttl = HEAD_PFIFO ( ptree -> ttl ) ;\n for ( ;\n curr_ttl != NULL ;\n curr_ttl = curr_ttl -> link ) {\n if ( i < COUNTOF ( sys_ttl ) ) sys_ttl [ i ++ ] = ( u_char ) curr_ttl -> i ;\n else msyslog ( LOG_INFO , \"ttl: Number of TTL entries exceeds %lu. Ignoring TTL %d...\" , ( u_long ) COUNTOF ( sys_ttl ) , curr_ttl -> i ) ;\n }\n sys_ttlmax = i - 1 ;\n }", "idx": 22255}
{"hash": 330507736709312787, "project": "chrome", "size": 4, "label": 0, "functionSource": "gr_font * hb_graphite2_font_get_gr_font ( hb_font_t * font ) {\n if ( unlikely ( ! hb_graphite2_shaper_font_data_ensure ( font ) ) ) return NULL ;\n return HB_SHAPER_DATA_GET ( font ) ;\n }", "idx": 22256}
{"hash": -1929262071302712016, "project": "debian", "size": 5, "label": 0, "functionSource": "static void * Type_ParametricCurve_Dup ( struct _cms_typehandler_struct * self , const void * Ptr , cmsUInt32Number n ) {\n return ( void * ) cmsDupToneCurve ( ( cmsToneCurve * ) Ptr ) ;\n cmsUNUSED_PARAMETER ( n ) ;\n cmsUNUSED_PARAMETER ( self ) ;\n }", "idx": 22257}
{"hash": 8458201026073747179, "project": "debian", "size": 38, "label": 0, "functionSource": "static int jbig2_decode_generic_template3_TPGDON ( Jbig2Ctx * ctx , Jbig2Segment * segment , const Jbig2GenericRegionParams * params , Jbig2ArithState * as , Jbig2Image * image , Jbig2ArithCx * GB_stats ) {\n const int GBW = image -> width ;\n const int GBH = image -> height ;\n uint32_t CONTEXT ;\n int x , y ;\n bool bit ;\n int LTP = 0 ;\n for ( y = 0 ;\n y < GBH ;\n y ++ ) {\n bit = jbig2_arith_decode ( as , & GB_stats [ 0x0195 ] ) ;\n if ( bit < 0 ) return - 1 ;\n LTP ^= bit ;\n if ( ! LTP ) {\n for ( x = 0 ;\n x < GBW ;\n x ++ ) {\n CONTEXT = jbig2_image_get_pixel ( image , x - 1 , y ) ;\n CONTEXT |= jbig2_image_get_pixel ( image , x - 2 , y ) << 1 ;\n CONTEXT |= jbig2_image_get_pixel ( image , x - 3 , y ) << 2 ;\n CONTEXT |= jbig2_image_get_pixel ( image , x - 4 , y ) << 3 ;\n CONTEXT |= jbig2_image_get_pixel ( image , x + params -> gbat [ 0 ] , y + params -> gbat [ 1 ] ) << 4 ;\n CONTEXT |= jbig2_image_get_pixel ( image , x + 1 , y - 1 ) << 5 ;\n CONTEXT |= jbig2_image_get_pixel ( image , x , y - 1 ) << 6 ;\n CONTEXT |= jbig2_image_get_pixel ( image , x - 1 , y - 1 ) << 7 ;\n CONTEXT |= jbig2_image_get_pixel ( image , x - 2 , y - 1 ) << 8 ;\n CONTEXT |= jbig2_image_get_pixel ( image , x - 3 , y - 1 ) << 9 ;\n bit = jbig2_arith_decode ( as , & GB_stats [ CONTEXT ] ) ;\n if ( bit < 0 ) return - 1 ;\n jbig2_image_set_pixel ( image , x , y , bit ) ;\n }\n }\n else {\n copy_prev_row ( image , y ) ;\n }\n }\n return 0 ;\n }", "idx": 22258}
{"hash": -341028540041678099, "project": "debian", "size": 47, "label": 0, "functionSource": "static int getarg ( const char * str , int code , arg_v * argp ) {\n u_long ul ;\n switch ( code & ~ OPT ) {\n case NTP_STR : argp -> string = str ;\n break ;\n case NTP_ADD : if ( ! getnetnum ( str , & argp -> netnum , NULL , 0 ) ) return 0 ;\n break ;\n case NTP_UINT : if ( '&' == str [ 0 ] ) {\n if ( ! atouint ( & str [ 1 ] , & ul ) ) {\n fprintf ( stderr , \"***Association index `%s' invalid/undecodable\\n\" , str ) ;\n return 0 ;\n }\n if ( 0 == numassoc ) {\n dogetassoc ( stdout ) ;\n if ( 0 == numassoc ) {\n fprintf ( stderr , \"***No associations found, `%s' unknown\\n\" , str ) ;\n return 0 ;\n }\n }\n ul = min ( ul , numassoc ) ;\n argp -> uval = assoc_cache [ ul - 1 ] . assid ;\n break ;\n }\n if ( ! atouint ( str , & argp -> uval ) ) {\n fprintf ( stderr , \"***Illegal unsigned value %s\\n\" , str ) ;\n return 0 ;\n }\n break ;\n case NTP_INT : if ( ! atoint ( str , & argp -> ival ) ) {\n fprintf ( stderr , \"***Illegal integer value %s\\n\" , str ) ;\n return 0 ;\n }\n break ;\n case IP_VERSION : if ( ! strcmp ( \"-6\" , str ) ) {\n argp -> ival = 6 ;\n }\n else if ( ! strcmp ( \"-4\" , str ) ) {\n argp -> ival = 4 ;\n }\n else {\n fprintf ( stderr , \"***Version must be either 4 or 6\\n\" ) ;\n return 0 ;\n }\n break ;\n }\n return 1 ;\n }", "idx": 22259}
{"hash": 8895005875911486570, "project": "debian", "size": 10, "label": 0, "functionSource": "static void curses_destroy_conndata ( void ) {\n conntrack_hook_conn_del ( curr_conn , split_print_po ) ;\n conntrack_hook_conn_del ( curr_conn , join_print_po ) ;\n wdg_conndata = NULL ;\n wdg_c1 = NULL ;\n wdg_c2 = NULL ;\n wdg_join = NULL ;\n curr_conn -> flags &= ~ CONN_VIEWING ;\n curr_conn = NULL ;\n }", "idx": 22260}
{"hash": 589395864685553737, "project": "debian", "size": 13, "label": 0, "functionSource": "static void systick_timer_tick ( void * opaque ) {\n nvic_state * s = ( nvic_state * ) opaque ;\n s -> systick . control |= SYSTICK_COUNTFLAG ;\n if ( s -> systick . control & SYSTICK_TICKINT ) {\n armv7m_nvic_set_pending ( s , ARMV7M_EXCP_SYSTICK ) ;\n }\n if ( s -> systick . reload == 0 ) {\n s -> systick . control &= ~ SYSTICK_ENABLE ;\n }\n else {\n systick_reload ( s , 0 ) ;\n }\n }", "idx": 22261}
{"hash": -6615083443578004976, "project": "debian", "size": 13, "label": 0, "functionSource": "static void dissect_usb_ms_get_max_lun ( packet_info * pinfo _U_ , proto_tree * tree , tvbuff_t * tvb , int offset , gboolean is_request , usb_trans_info_t * usb_trans_info _U_ , usb_conv_info_t * usb_conv_info _U_ ) {\n if ( is_request ) {\n proto_tree_add_item ( tree , hf_usb_ms_value , tvb , offset , 2 , ENC_BIG_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_usb_ms_index , tvb , offset , 2 , ENC_BIG_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_usb_ms_length , tvb , offset , 2 , ENC_BIG_ENDIAN ) ;\n }\n else {\n proto_tree_add_item ( tree , hf_usb_ms_maxlun , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n offset ++ ;\n }\n }", "idx": 22262}
{"hash": 1182028467273264883, "project": "debian", "size": 36, "label": 0, "functionSource": "static void show_query ( MYSQL * mysql , const char * query ) {\n MYSQL_RES * res ;\n DBUG_ENTER ( \"show_query\" ) ;\n if ( ! mysql ) DBUG_VOID_RETURN ;\n if ( mysql_query ( mysql , query ) ) {\n log_msg ( \"Error running query '%s': %d %s\" , query , mysql_errno ( mysql ) , mysql_error ( mysql ) ) ;\n DBUG_VOID_RETURN ;\n }\n if ( ( res = mysql_store_result ( mysql ) ) == NULL ) {\n DBUG_VOID_RETURN ;\n }\n {\n MYSQL_ROW row ;\n unsigned int i ;\n unsigned int row_num = 0 ;\n unsigned int num_fields = mysql_num_fields ( res ) ;\n MYSQL_FIELD * fields = mysql_fetch_fields ( res ) ;\n fprintf ( stderr , \"=== %s ===\\n\" , query ) ;\n while ( ( row = mysql_fetch_row ( res ) ) ) {\n unsigned long * lengths = mysql_fetch_lengths ( res ) ;\n row_num ++ ;\n fprintf ( stderr , \"---- %d. ----\\n\" , row_num ) ;\n for ( i = 0 ;\n i < num_fields ;\n i ++ ) {\n fprintf ( stderr , \"%s\\t%.*s\\n\" , fields [ i ] . name , ( int ) lengths [ i ] , row [ i ] ? row [ i ] : \"NULL\" ) ;\n }\n }\n for ( i = 0 ;\n i < strlen ( query ) + 8 ;\n i ++ ) fprintf ( stderr , \"=\" ) ;\n fprintf ( stderr , \"\\n\\n\" ) ;\n }\n mysql_free_result ( res ) ;\n DBUG_VOID_RETURN ;\n }", "idx": 22263}
{"hash": 3887066622454352196, "project": "chrome", "size": 66, "label": 1, "functionSource": "static void model_rd_for_sb ( VP9_COMP * cpi , BLOCK_SIZE bsize , MACROBLOCK * x , MACROBLOCKD * xd , int * out_rate_sum , int64_t * out_dist_sum ) {\n int i ;\n int64_t rate_sum = 0 ;\n int64_t dist_sum = 0 ;\n const int ref = xd -> mi [ 0 ] -> mbmi . ref_frame [ 0 ] ;\n unsigned int sse ;\n unsigned int var = 0 ;\n unsigned int sum_sse = 0 ;\n const int shift = 8 ;\n int rate ;\n int64_t dist ;\n x -> pred_sse [ ref ] = 0 ;\n for ( i = 0 ;\n i < MAX_MB_PLANE ;\n ++ i ) {\n struct macroblock_plane * const p = & x -> plane [ i ] ;\n struct macroblockd_plane * const pd = & xd -> plane [ i ] ;\n const BLOCK_SIZE bs = get_plane_block_size ( bsize , pd ) ;\n const TX_SIZE max_tx_size = max_txsize_lookup [ bs ] ;\n const BLOCK_SIZE unit_size = txsize_to_bsize [ max_tx_size ] ;\n int bw = 1 << ( b_width_log2_lookup [ bs ] - b_width_log2_lookup [ unit_size ] ) ;\n int bh = 1 << ( b_height_log2_lookup [ bs ] - b_width_log2_lookup [ unit_size ] ) ;\n int idx , idy ;\n int lw = b_width_log2_lookup [ unit_size ] + 2 ;\n int lh = b_height_log2_lookup [ unit_size ] + 2 ;\n sum_sse = 0 ;\n for ( idy = 0 ;\n idy < bh ;\n ++ idy ) {\n for ( idx = 0 ;\n idx < bw ;\n ++ idx ) {\n uint8_t * src = p -> src . buf + ( idy * p -> src . stride << lh ) + ( idx << lw ) ;\n uint8_t * dst = pd -> dst . buf + ( idy * pd -> dst . stride << lh ) + ( idx << lh ) ;\n int block_idx = ( idy << 1 ) + idx ;\n var = cpi -> fn_ptr [ unit_size ] . vf ( src , p -> src . stride , dst , pd -> dst . stride , & sse ) ;\n x -> bsse [ ( i << 2 ) + block_idx ] = sse ;\n sum_sse += sse ;\n if ( ! x -> select_tx_size ) {\n if ( x -> bsse [ ( i << 2 ) + block_idx ] < p -> quant_thred [ 0 ] >> shift ) x -> skip_txfm [ ( i << 2 ) + block_idx ] = 1 ;\n else if ( var < p -> quant_thred [ 1 ] >> shift ) x -> skip_txfm [ ( i << 2 ) + block_idx ] = 2 ;\n else x -> skip_txfm [ ( i << 2 ) + block_idx ] = 0 ;\n }\n if ( i == 0 ) x -> pred_sse [ ref ] += sse ;\n }\n }\n if ( cpi -> oxcf . speed > 4 ) {\n int64_t rate ;\n int64_t dist ;\n int64_t square_error = sse ;\n int quantizer = ( pd -> dequant [ 1 ] >> 3 ) ;\n if ( quantizer < 120 ) rate = ( square_error * ( 280 - quantizer ) ) >> 8 ;\n else rate = 0 ;\n dist = ( square_error * quantizer ) >> 8 ;\n rate_sum += rate ;\n dist_sum += dist ;\n }\n else {\n vp9_model_rd_from_var_lapndz ( sum_sse , 1 << num_pels_log2_lookup [ bs ] , pd -> dequant [ 1 ] >> 3 , & rate , & dist ) ;\n rate_sum += rate ;\n dist_sum += dist ;\n }\n }\n * out_rate_sum = ( int ) rate_sum ;\n * out_dist_sum = dist_sum << 4 ;\n }", "idx": 22264}
{"hash": -2242211406757466627, "project": "debian", "size": 3, "label": 0, "functionSource": "static guint32 get_uint32 ( tvbuff_t * tvb , gint32 offset , gint encoding ) {\n return ( ENC_BIG_ENDIAN == encoding ) ? tvb_get_ntohl ( tvb , offset ) : tvb_get_letohl ( tvb , offset ) ;\n }", "idx": 22265}
{"hash": -4558261210024070448, "project": "chrome", "size": 15, "label": 0, "functionSource": "void xmlListReverse ( xmlListPtr l ) {\n xmlLinkPtr lk ;\n xmlLinkPtr lkPrev ;\n if ( l == NULL ) return ;\n lkPrev = l -> sentinel ;\n for ( lk = l -> sentinel -> next ;\n lk != l -> sentinel ;\n lk = lk -> next ) {\n lkPrev -> next = lkPrev -> prev ;\n lkPrev -> prev = lk ;\n lkPrev = lk ;\n }\n lkPrev -> next = lkPrev -> prev ;\n lkPrev -> prev = lk ;\n }", "idx": 22266}
{"hash": -714975729066076397, "project": "chrome", "size": 3, "label": 0, "functionSource": "hb_bool_t hb_blob_is_immutable ( hb_blob_t * blob ) {\n return blob -> immutable ;\n }", "idx": 22267}
{"hash": -3135212895432241239, "project": "debian", "size": 6, "label": 0, "functionSource": "static guint32 dissect_netb_data_ack ( tvbuff_t * tvb , packet_info * pinfo _U_ , int offset , proto_tree * tree ) {\n nb_xmit_corrl ( tvb , offset , tree ) ;\n nb_remote_session ( tvb , offset , tree ) ;\n nb_local_session ( tvb , offset , tree ) ;\n return 0 ;\n }", "idx": 22268}
{"hash": -2625033791912996344, "project": "debian", "size": 21, "label": 0, "functionSource": "static int rv30_decode_mb_info ( RV34DecContext * r ) {\n static const int rv30_p_types [ 6 ] = {\n RV34_MB_SKIP , RV34_MB_P_16x16 , RV34_MB_P_8x8 , - 1 , RV34_MB_TYPE_INTRA , RV34_MB_TYPE_INTRA16x16 }\n ;\n static const int rv30_b_types [ 6 ] = {\n RV34_MB_SKIP , RV34_MB_B_DIRECT , RV34_MB_B_FORWARD , RV34_MB_B_BACKWARD , RV34_MB_TYPE_INTRA , RV34_MB_TYPE_INTRA16x16 }\n ;\n MpegEncContext * s = & r -> s ;\n GetBitContext * gb = & s -> gb ;\n unsigned code = svq3_get_ue_golomb ( gb ) ;\n if ( code > 11 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"Incorrect MB type code\\n\" ) ;\n return - 1 ;\n }\n if ( code > 5 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"dquant needed\\n\" ) ;\n code -= 6 ;\n }\n if ( s -> pict_type != AV_PICTURE_TYPE_B ) return rv30_p_types [ code ] ;\n else return rv30_b_types [ code ] ;\n }", "idx": 22269}
{"hash": -2325305888478261876, "project": "debian", "size": 186, "label": 0, "functionSource": "int tm_poll ( tm_event_t poll_event , tm_event_t * result_event , int wait , int * tm_errno ) {\n int num , i ;\n int ret , mtype , nnodes ;\n int prot , protver ;\n int * obitvalp ;\n event_info * ep = NULL ;\n tm_task_id tid , * tidp ;\n tm_event_t nevent ;\n tm_node_id node ;\n char * jobid = NULL ;\n char * info = NULL ;\n struct tm_roots * roots ;\n struct taskhold * thold ;\n struct infohold * ihold ;\n struct reschold * rhold ;\n extern time_t pbs_tcp_timeout ;\n if ( ! init_done ) {\n return ( TM_BADINIT ) ;\n }\n if ( result_event == NULL ) return ( TM_EBADENVIRONMENT ) ;\n * result_event = TM_ERROR_EVENT ;\n if ( poll_event != TM_NULL_EVENT ) return ( TM_ENOTIMPLEMENTED ) ;\n if ( tm_errno == NULL ) return ( TM_EBADENVIRONMENT ) ;\n if ( event_count == 0 ) {\n TM_DBPRT ( ( \"%s: no events waiting\\n\" , __func__ ) ) return ( TM_ENOTFOUND ) ;\n }\n if ( local_conn < 0 ) {\n TM_DBPRT ( ( \"%s: INTERNAL ERROR %d events but no connection (%d)\\n\" , __func__ , event_count , local_conn ) ) if ( static_chan != NULL ) {\n DIS_tcp_cleanup ( static_chan ) ;\n static_chan = NULL ;\n }\n return ( TM_ENOTCONNECTED ) ;\n }\n if ( ( static_chan == NULL ) && ( ( static_chan = DIS_tcp_setup ( local_conn ) ) == NULL ) ) {\n TM_DBPRT ( ( \"%s: Error allocating memory for sock buffer %d\" , __func__ , PBSE_MEM_MALLOC ) ) return TM_BADINIT ;\n }\n pbs_tcp_timeout = wait ? FOREVER : 1 ;\n prot = disrsi ( static_chan , & ret ) ;\n if ( ret == DIS_EOD ) {\n * result_event = TM_NULL_EVENT ;\n DIS_tcp_cleanup ( static_chan ) ;\n static_chan = NULL ;\n return TM_SUCCESS ;\n }\n else if ( ret != DIS_SUCCESS ) {\n TM_DBPRT ( ( \"%s: protocol number dis error %d\\n\" , __func__ , ret ) ) goto tm_poll_error ;\n }\n if ( prot != TM_PROTOCOL ) {\n TM_DBPRT ( ( \"%s: bad protocol number %d\\n\" , __func__ , prot ) ) goto tm_poll_error ;\n }\n pbs_tcp_timeout = FOREVER ;\n protver = disrsi ( static_chan , & ret ) ;\n if ( ret != DIS_SUCCESS ) {\n TM_DBPRT ( ( \"%s: protocol version dis error %d\\n\" , __func__ , ret ) ) goto tm_poll_error ;\n }\n if ( protver != TM_PROTOCOL_VER ) {\n TM_DBPRT ( ( \"%s: bad protocol version %d\\n\" , __func__ , protver ) ) goto tm_poll_error ;\n }\n mtype = disrsi ( static_chan , & ret ) ;\n if ( ret != DIS_SUCCESS ) {\n TM_DBPRT ( ( \"%s: mtype dis error %d\\n\" , __func__ , ret ) ) goto tm_poll_error ;\n }\n nevent = disrsi ( static_chan , & ret ) ;\n if ( ret != DIS_SUCCESS ) {\n TM_DBPRT ( ( \"%s: event dis error %d\\n\" , __func__ , ret ) ) goto tm_poll_error ;\n }\n * result_event = nevent ;\n TM_DBPRT ( ( \"%s: got event %d return %d\\n\" , __func__ , nevent , mtype ) ) if ( ( ep = find_event ( nevent ) ) == NULL ) {\n TM_DBPRT ( ( \"%s: No event found for number %d\\n\" , __func__ , nevent ) ) ;\n DIS_tcp_close ( static_chan ) ;\n static_chan = NULL ;\n local_conn = - 1 ;\n return TM_ENOEVENT ;\n }\n if ( mtype == TM_ERROR ) {\n * tm_errno = disrsi ( static_chan , & ret ) ;\n TM_DBPRT ( ( \"%s: event %d error %d\\n\" , __func__ , nevent , * tm_errno ) ) ;\n goto tm_poll_done ;\n }\n * tm_errno = TM_SUCCESS ;\n switch ( ep -> e_mtype ) {\n case TM_INIT : nnodes = disrsi ( static_chan , & ret ) ;\n if ( ret != DIS_SUCCESS ) {\n TM_DBPRT ( ( \"%s: INIT failed nnodes\\n\" , __func__ ) ) goto tm_poll_error ;\n }\n node_table = ( tm_node_id * ) calloc ( nnodes + 1 , sizeof ( tm_node_id ) ) ;\n if ( node_table == NULL ) {\n perror ( \"Memory allocation failed\" ) ;\n goto tm_poll_error ;\n }\n TM_DBPRT ( ( \"%s: INIT nodes %d\\n\" , __func__ , nnodes ) ) for ( i = 0 ;\n i < nnodes ;\n i ++ ) {\n node_table [ i ] = disrsi ( static_chan , & ret ) ;\n if ( ret != DIS_SUCCESS ) {\n TM_DBPRT ( ( \"%s: INIT failed nodeid %d\\n\" , __func__ , i ) ) goto tm_poll_error ;\n }\n }\n node_table [ nnodes ] = TM_ERROR_NODE ;\n jobid = disrst ( static_chan , & ret ) ;\n if ( ret != DIS_SUCCESS ) {\n TM_DBPRT ( ( \"%s: INIT failed jobid\\n\" , __func__ ) ) goto tm_poll_error ;\n }\n TM_DBPRT ( ( \"%s: INIT daddy jobid %s\\n\" , __func__ , jobid ) ) node = disrsi ( static_chan , & ret ) ;\n if ( ret != DIS_SUCCESS ) {\n TM_DBPRT ( ( \"%s: INIT failed parent nodeid\\n\" , __func__ ) ) goto tm_poll_error ;\n }\n TM_DBPRT ( ( \"%s: INIT daddy node %d\\n\" , __func__ , node ) ) tid = disrsi ( static_chan , & ret ) ;\n if ( ret != DIS_SUCCESS ) {\n TM_DBPRT ( ( \"%s: INIT failed parent taskid\\n\" , __func__ ) ) goto tm_poll_error ;\n }\n TM_DBPRT ( ( \"%s: INIT daddy tid %lu\\n\" , __func__ , ( unsigned long ) tid ) ) roots = ( struct tm_roots * ) ep -> e_info ;\n roots -> tm_parent = new_task ( jobid , node , tid ) ;\n roots -> tm_me = new_task ( tm_jobid , tm_jobndid , tm_jobtid ) ;\n roots -> tm_nnodes = nnodes ;\n roots -> tm_ntasks = 0 ;\n roots -> tm_taskpoolid = - 1 ;\n roots -> tm_tasklist = NULL ;\n break ;\n case TM_TASKS : thold = ( struct taskhold * ) ep -> e_info ;\n tidp = thold -> list ;\n num = thold -> size ;\n for ( i = 0 ;\n ;\n i ++ ) {\n tid = disrsi ( static_chan , & ret ) ;\n if ( tid == TM_NULL_TASK ) break ;\n if ( ret != DIS_SUCCESS ) goto tm_poll_error ;\n if ( i < num ) {\n tidp [ i ] = new_task ( tm_jobid , ep -> e_node , tid ) ;\n }\n }\n if ( i < num ) tidp [ i ] = TM_NULL_TASK ;\n * ( thold -> ntasks ) = i ;\n break ;\n case TM_SPAWN : tid = disrsi ( static_chan , & ret ) ;\n if ( ret != DIS_SUCCESS ) {\n TM_DBPRT ( ( \"%s: SPAWN failed tid\\n\" , __func__ ) ) goto tm_poll_error ;\n }\n tidp = ( tm_task_id * ) ep -> e_info ;\n * tidp = new_task ( tm_jobid , ep -> e_node , tid ) ;\n break ;\n case TM_SIGNAL : break ;\n case TM_OBIT : obitvalp = ( int * ) ep -> e_info ;\n * obitvalp = disrsi ( static_chan , & ret ) ;\n if ( ret != DIS_SUCCESS ) {\n TM_DBPRT ( ( \"%s: OBIT failed obitval\\n\" , __func__ ) ) goto tm_poll_error ;\n }\n break ;\n case TM_POSTINFO : break ;\n case TM_GETINFO : ihold = ( struct infohold * ) ep -> e_info ;\n info = disrcs ( static_chan , ( size_t * ) ihold -> info_len , & ret ) ;\n if ( ret != DIS_SUCCESS ) {\n if ( info != NULL ) free ( info ) ;\n TM_DBPRT ( ( \"%s: GETINFO failed info\\n\" , __func__ ) ) break ;\n }\n memcpy ( ihold -> info , info , MIN ( * ihold -> info_len , ihold -> len ) ) ;\n free ( info ) ;\n break ;\n case TM_RESOURCES : rhold = ( struct reschold * ) ep -> e_info ;\n info = disrst ( static_chan , & ret ) ;\n if ( ret != DIS_SUCCESS ) {\n if ( info != NULL ) free ( info ) ;\n break ;\n }\n snprintf ( rhold -> resc , rhold -> len , \"%s\" , info ) ;\n free ( info ) ;\n break ;\n default : TM_DBPRT ( ( \"%s: unknown event command %d\\n\" , __func__ , ep -> e_mtype ) ) goto tm_poll_error ;\n }\n DIS_tcp_wflush ( static_chan ) ;\n tm_poll_done : if ( jobid != NULL ) free ( jobid ) ;\n del_event ( ep ) ;\n if ( tcp_chan_has_data ( static_chan ) == FALSE ) {\n DIS_tcp_cleanup ( static_chan ) ;\n static_chan = NULL ;\n }\n return TM_SUCCESS ;\n tm_poll_error : if ( jobid != NULL ) free ( jobid ) ;\n if ( ep ) del_event ( ep ) ;\n close ( local_conn ) ;\n DIS_tcp_cleanup ( static_chan ) ;\n static_chan = NULL ;\n local_conn = - 1 ;\n return TM_ENOTCONNECTED ;\n }", "idx": 22270}
{"hash": -5268859819325807498, "project": "debian", "size": 14, "label": 0, "functionSource": "static void deep_count_stop ( NautilusDirectory * directory ) {\n NautilusFile * file ;\n if ( directory -> details -> deep_count_in_progress != NULL ) {\n file = directory -> details -> deep_count_file ;\n if ( file != NULL ) {\n g_assert ( NAUTILUS_IS_FILE ( file ) ) ;\n g_assert ( file -> details -> directory == directory ) ;\n if ( is_needy ( file , lacks_deep_count , REQUEST_DEEP_COUNT ) ) {\n return ;\n }\n }\n deep_count_cancel ( directory ) ;\n }\n }", "idx": 22271}
{"hash": 6343276067273564310, "project": "debian", "size": 47, "label": 0, "functionSource": "static afs_int32 getCPS2 ( struct rx_call * call , afs_int32 aid , afs_uint32 ahost , prlist * alist , afs_int32 * over , afs_int32 * cid ) {\n afs_int32 code ;\n struct ubik_trans * tt ;\n afs_int32 temp ;\n struct prentry tentry ;\n struct prentry host_tentry ;\n afs_int32 hostid ;\n int host_list = 0 ;\n struct in_addr iaddr ;\n char hoststr [ 16 ] ;\n * over = 0 ;\n iaddr . s_addr = ntohl ( ahost ) ;\n alist -> prlist_len = 0 ;\n alist -> prlist_val = NULL ;\n code = Initdb ( ) ;\n if ( code != PRSUCCESS ) return code ;\n code = ubik_BeginTransReadAny ( dbase , UBIK_READTRANS , & tt ) ;\n if ( code ) return code ;\n code = ubik_SetLock ( tt , 1 , 1 , LOCKREAD ) ;\n if ( code ) ABORT_WITH ( tt , code ) ;\n code = read_DbHeader ( tt ) ;\n if ( code ) ABORT_WITH ( tt , code ) ;\n if ( aid != PRBADID ) {\n temp = FindByID ( tt , aid ) ;\n if ( ! temp ) ABORT_WITH ( tt , PRNOENT ) ;\n code = pr_ReadEntry ( tt , 0 , temp , & tentry ) ;\n if ( code ) ABORT_WITH ( tt , code ) ;\n code = WhoIsThis ( call , tt , cid ) ;\n if ( code || ! AccessOK ( tt , * cid , & tentry , PRP_MEMBER_MEM , PRP_MEMBER_ANY ) ) ABORT_WITH ( tt , PRPERM ) ;\n }\n code = NameToID ( tt , afs_inet_ntoa_r ( iaddr . s_addr , hoststr ) , & hostid ) ;\n if ( code == PRSUCCESS && hostid != 0 ) {\n temp = FindByID ( tt , hostid ) ;\n if ( temp ) {\n code = pr_ReadEntry ( tt , 0 , temp , & host_tentry ) ;\n if ( code == PRSUCCESS ) host_list = 1 ;\n else fprintf ( stderr , \"pr_ReadEntry returned %d\\n\" , code ) ;\n }\n else fprintf ( stderr , \"FindByID Failed -- Not found\\n\" ) ;\n }\n if ( host_list ) code = GetList2 ( tt , & tentry , & host_tentry , alist , 1 ) ;\n else code = GetList ( tt , & tentry , alist , 1 ) ;\n if ( ! code ) code = addWildCards ( tt , alist , ntohl ( ahost ) ) ;\n if ( code != PRSUCCESS ) ABORT_WITH ( tt , code ) ;\n code = ubik_EndTrans ( tt ) ;\n return code ;\n }", "idx": 22272}
{"hash": 7279312193592248512, "project": "debian", "size": 16, "label": 0, "functionSource": "void ff_cavs_load_intra_pred_chroma ( AVSContext * h ) {\n h -> left_border_u [ 9 ] = h -> left_border_u [ 8 ] ;\n h -> left_border_v [ 9 ] = h -> left_border_v [ 8 ] ;\n h -> top_border_u [ h -> mbx * 10 + 9 ] = h -> top_border_u [ h -> mbx * 10 + 8 ] ;\n h -> top_border_v [ h -> mbx * 10 + 9 ] = h -> top_border_v [ h -> mbx * 10 + 8 ] ;\n if ( h -> mbx && h -> mby ) {\n h -> top_border_u [ h -> mbx * 10 ] = h -> left_border_u [ 0 ] = h -> topleft_border_u ;\n h -> top_border_v [ h -> mbx * 10 ] = h -> left_border_v [ 0 ] = h -> topleft_border_v ;\n }\n else {\n h -> left_border_u [ 0 ] = h -> left_border_u [ 1 ] ;\n h -> left_border_v [ 0 ] = h -> left_border_v [ 1 ] ;\n h -> top_border_u [ h -> mbx * 10 ] = h -> top_border_u [ h -> mbx * 10 + 1 ] ;\n h -> top_border_v [ h -> mbx * 10 ] = h -> top_border_v [ h -> mbx * 10 + 1 ] ;\n }\n }", "idx": 22273}
{"hash": -4422011356016453021, "project": "debian", "size": 49, "label": 0, "functionSource": "static int s302m_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n AVFrame * frame = data ;\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n int block_size , ret ;\n int frame_size = s302m_parse_frame_header ( avctx , buf , buf_size ) ;\n if ( frame_size < 0 ) return frame_size ;\n buf_size -= AES3_HEADER_LEN ;\n buf += AES3_HEADER_LEN ;\n block_size = ( avctx -> bits_per_coded_sample + 4 ) / 4 ;\n frame -> nb_samples = 2 * ( buf_size / block_size ) / avctx -> channels ;\n if ( ( ret = ff_get_buffer ( avctx , frame , 0 ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n buf_size = ( frame -> nb_samples * avctx -> channels / 2 ) * block_size ;\n if ( avctx -> bits_per_coded_sample == 24 ) {\n uint32_t * o = ( uint32_t * ) frame -> data [ 0 ] ;\n for ( ;\n buf_size > 6 ;\n buf_size -= 7 ) {\n * o ++ = ( ff_reverse [ buf [ 2 ] ] << 24 ) | ( ff_reverse [ buf [ 1 ] ] << 16 ) | ( ff_reverse [ buf [ 0 ] ] << 8 ) ;\n * o ++ = ( ff_reverse [ buf [ 6 ] & 0xf0 ] << 28 ) | ( ff_reverse [ buf [ 5 ] ] << 20 ) | ( ff_reverse [ buf [ 4 ] ] << 12 ) | ( ff_reverse [ buf [ 3 ] & 0x0f ] << 4 ) ;\n buf += 7 ;\n }\n }\n else if ( avctx -> bits_per_coded_sample == 20 ) {\n uint32_t * o = ( uint32_t * ) frame -> data [ 0 ] ;\n for ( ;\n buf_size > 5 ;\n buf_size -= 6 ) {\n * o ++ = ( ff_reverse [ buf [ 2 ] & 0xf0 ] << 28 ) | ( ff_reverse [ buf [ 1 ] ] << 20 ) | ( ff_reverse [ buf [ 0 ] ] << 12 ) ;\n * o ++ = ( ff_reverse [ buf [ 5 ] & 0xf0 ] << 28 ) | ( ff_reverse [ buf [ 4 ] ] << 20 ) | ( ff_reverse [ buf [ 3 ] ] << 12 ) ;\n buf += 6 ;\n }\n }\n else {\n uint16_t * o = ( uint16_t * ) frame -> data [ 0 ] ;\n for ( ;\n buf_size > 4 ;\n buf_size -= 5 ) {\n * o ++ = ( ff_reverse [ buf [ 1 ] ] << 8 ) | ff_reverse [ buf [ 0 ] ] ;\n * o ++ = ( ff_reverse [ buf [ 4 ] & 0xf0 ] << 12 ) | ( ff_reverse [ buf [ 3 ] ] << 4 ) | ( ff_reverse [ buf [ 2 ] ] >> 4 ) ;\n buf += 5 ;\n }\n }\n * got_frame_ptr = 1 ;\n return avpkt -> size ;\n }", "idx": 22274}
{"hash": 2636502839178711655, "project": "debian", "size": 11, "label": 0, "functionSource": "static void dissect_coap_opt_uri_host ( tvbuff_t * tvb , proto_item * head_item , proto_tree * subtree , gint offset , gint opt_length , coap_info * coinfo , int hf ) {\n const guint8 * str ;\n proto_tree_add_item_ret_string ( subtree , hf , tvb , offset , opt_length , ENC_ASCII , wmem_packet_scope ( ) , & str ) ;\n proto_item_append_text ( head_item , \": %s\" , str ) ;\n if ( strchr ( str , ':' ) == NULL ) {\n wmem_strbuf_append_printf ( coinfo -> uri_str_strbuf , \"coap://%s\" , str ) ;\n }\n else {\n wmem_strbuf_append_printf ( coinfo -> uri_str_strbuf , \"coap://[%s]\" , str ) ;\n }\n }", "idx": 22275}
{"hash": -2607754285145856562, "project": "debian", "size": 30, "label": 0, "functionSource": "static void isoent_free_all ( struct isoent * isoent ) {\n struct isoent * np , * np_temp ;\n if ( isoent == NULL ) return ;\n np = isoent ;\n for ( ;\n ;\n ) {\n if ( np -> dir ) {\n if ( np -> children . first != NULL ) {\n np = np -> children . first ;\n continue ;\n }\n }\n for ( ;\n ;\n ) {\n np_temp = np ;\n if ( np -> chnext == NULL ) {\n np = np -> parent ;\n _isoent_free ( np_temp ) ;\n if ( np == np_temp ) return ;\n }\n else {\n np = np -> chnext ;\n _isoent_free ( np_temp ) ;\n break ;\n }\n }\n }\n }", "idx": 22276}
{"hash": 8320716512483418415, "project": "chrome", "size": 25, "label": 0, "functionSource": "void vp9_iht16x16_256_add_c ( const tran_low_t * input , uint8_t * dest , int stride , int tx_type ) {\n int i , j ;\n tran_low_t out [ 16 * 16 ] ;\n tran_low_t * outptr = out ;\n tran_low_t temp_in [ 16 ] , temp_out [ 16 ] ;\n const transform_2d ht = IHT_16 [ tx_type ] ;\n for ( i = 0 ;\n i < 16 ;\n ++ i ) {\n ht . rows ( input , outptr ) ;\n input += 16 ;\n outptr += 16 ;\n }\n for ( i = 0 ;\n i < 16 ;\n ++ i ) {\n for ( j = 0 ;\n j < 16 ;\n ++ j ) temp_in [ j ] = out [ j * 16 + i ] ;\n ht . cols ( temp_in , temp_out ) ;\n for ( j = 0 ;\n j < 16 ;\n ++ j ) dest [ j * stride + i ] = clip_pixel ( ROUND_POWER_OF_TWO ( temp_out [ j ] , 6 ) + dest [ j * stride + i ] ) ;\n }\n }", "idx": 22277}
{"hash": 8035933693347914822, "project": "debian", "size": 126, "label": 0, "functionSource": "static int dissect_opcua_message ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , void * data _U_ ) {\n FctParse pfctParse = NULL ;\n enum MessageType msgtype = MSG_INVALID ;\n col_set_str ( pinfo -> cinfo , COL_PROTOCOL , \"OpcUa\" ) ;\n if ( tvb_memeql ( tvb , 0 , \"HEL\" , 3 ) == 0 ) {\n msgtype = MSG_HELLO ;\n pfctParse = parseHello ;\n }\n else if ( tvb_memeql ( tvb , 0 , \"ACK\" , 3 ) == 0 ) {\n msgtype = MSG_ACKNOWLEDGE ;\n pfctParse = parseAcknowledge ;\n }\n else if ( tvb_memeql ( tvb , 0 , \"ERR\" , 3 ) == 0 ) {\n msgtype = MSG_ERROR ;\n pfctParse = parseError ;\n }\n else if ( tvb_memeql ( tvb , 0 , \"MSG\" , 3 ) == 0 ) {\n msgtype = MSG_MESSAGE ;\n pfctParse = parseMessage ;\n }\n else if ( tvb_memeql ( tvb , 0 , \"OPN\" , 3 ) == 0 ) {\n msgtype = MSG_OPENSECURECHANNEL ;\n pfctParse = parseOpenSecureChannel ;\n }\n else if ( tvb_memeql ( tvb , 0 , \"CLO\" , 3 ) == 0 ) {\n msgtype = MSG_CLOSESECURECHANNEL ;\n pfctParse = parseCloseSecureChannel ;\n }\n else {\n msgtype = MSG_INVALID ;\n }\n col_set_str ( pinfo -> cinfo , COL_INFO , g_szMessageTypes [ msgtype ] ) ;\n if ( pfctParse ) {\n gint offset = 0 ;\n int iServiceId = - 1 ;\n tvbuff_t * next_tvb = tvb ;\n gboolean bParseService = TRUE ;\n gboolean bIsLastFragment = FALSE ;\n proto_item * ti = NULL ;\n proto_tree * transport_tree = NULL ;\n ti = proto_tree_add_item ( tree , proto_opcua , tvb , 0 , - 1 , ENC_NA ) ;\n transport_tree = proto_item_add_subtree ( ti , ett_opcua_transport ) ;\n if ( msgtype == MSG_MESSAGE ) {\n guint8 chunkType = 0 ;\n guint32 opcua_seqid = 0 ;\n guint32 opcua_num = 0 ;\n guint32 opcua_seqnum = 0 ;\n fragment_head * frag_msg = NULL ;\n offset = 3 ;\n chunkType = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n offset += 4 ;\n offset += 4 ;\n offset += 4 ;\n opcua_num = tvb_get_letohl ( tvb , offset ) ;\n offset += 4 ;\n opcua_seqid = tvb_get_letohl ( tvb , offset ) ;\n offset += 4 ;\n if ( chunkType == 'A' ) {\n fragment_delete ( & opcua_reassembly_table , pinfo , opcua_seqid , NULL ) ;\n col_clear_fence ( pinfo -> cinfo , COL_INFO ) ;\n col_set_str ( pinfo -> cinfo , COL_INFO , \"Abort message\" ) ;\n offset = 0 ;\n ( * pfctParse ) ( transport_tree , tvb , pinfo , & offset ) ;\n parseAbort ( transport_tree , tvb , pinfo , & offset ) ;\n return tvb_reported_length ( tvb ) ;\n }\n frag_msg = fragment_get ( & opcua_reassembly_table , pinfo , opcua_seqid , NULL ) ;\n if ( frag_msg == NULL ) {\n frag_msg = fragment_get_reassembled_id ( & opcua_reassembly_table , pinfo , opcua_seqid ) ;\n }\n if ( frag_msg != NULL || chunkType != 'F' ) {\n gboolean bSaveFragmented = pinfo -> fragmented ;\n gboolean bMoreFragments = TRUE ;\n tvbuff_t * new_tvb = NULL ;\n pinfo -> fragmented = TRUE ;\n if ( frag_msg == NULL ) {\n opcua_seqnum = 0 ;\n }\n else {\n while ( frag_msg -> next ) {\n frag_msg = frag_msg -> next ;\n }\n opcua_seqnum = frag_msg -> offset + 1 ;\n if ( chunkType == 'F' ) {\n bMoreFragments = FALSE ;\n }\n }\n frag_msg = fragment_add_seq_check ( & opcua_reassembly_table , tvb , offset , pinfo , opcua_seqid , NULL , opcua_seqnum , tvb_captured_length_remaining ( tvb , offset ) , bMoreFragments ) ;\n new_tvb = process_reassembled_data ( tvb , offset , pinfo , \"Reassembled Message\" , frag_msg , & opcua_frag_items , NULL , transport_tree ) ;\n if ( new_tvb ) {\n bIsLastFragment = TRUE ;\n }\n else {\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \" (Message fragment %u)\" , opcua_num ) ;\n }\n if ( new_tvb ) {\n next_tvb = new_tvb ;\n }\n else {\n bParseService = FALSE ;\n next_tvb = tvb_new_subset_remaining ( tvb , 0 ) ;\n }\n pinfo -> fragmented = bSaveFragmented ;\n }\n }\n offset = 0 ;\n iServiceId = ( * pfctParse ) ( transport_tree , tvb , pinfo , & offset ) ;\n if ( msgtype == MSG_MESSAGE && bParseService ) {\n if ( bIsLastFragment != FALSE ) {\n offset = 0 ;\n }\n iServiceId = parseService ( transport_tree , next_tvb , pinfo , & offset ) ;\n }\n if ( iServiceId != - 1 ) {\n const gchar * szServiceName = val_to_str ( ( guint32 ) iServiceId , g_requesttypes , \"ServiceId %d\" ) ;\n if ( bIsLastFragment == FALSE ) {\n col_add_fstr ( pinfo -> cinfo , COL_INFO , \"%s: %s\" , g_szMessageTypes [ msgtype ] , szServiceName ) ;\n }\n else {\n col_add_fstr ( pinfo -> cinfo , COL_INFO , \"%s: %s (Message Reassembled)\" , g_szMessageTypes [ msgtype ] , szServiceName ) ;\n }\n }\n }\n return tvb_reported_length ( tvb ) ;\n }", "idx": 22278}
{"hash": 7607805321589710329, "project": "debian", "size": 18, "label": 0, "functionSource": "static int convert_to_string ( const gs_memory_t * mem , os_ptr op1 , os_ptr op ) {\n uint len ;\n const byte * pstr = 0 ;\n int code = obj_cvs ( mem , op1 , op -> value . bytes , r_size ( op ) , & len , & pstr ) ;\n if ( code < 0 ) {\n if ( code == gs_error_rangecheck ) switch ( r_btype ( op1 ) ) {\n case t_oparray : case t_operator : if ( pstr != 0 ) switch ( * pstr ) {\n case '%' : case '.' : case '@' : len = r_size ( op ) ;\n memcpy ( op -> value . bytes , pstr , len ) ;\n goto ok ;\n }\n }\n return code ;\n }\n ok : * op1 = * op ;\n r_set_size ( op1 , len ) ;\n return 0 ;\n }", "idx": 22279}
{"hash": 7092216800726729686, "project": "debian", "size": 45, "label": 0, "functionSource": "static int dissect_h245_OpenLogicalChannelAck ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 218 \"../../asn1/h245/h245.cnf\" guint32 temp ;\n int p2p_dir ;\n h223_pending_olc * pend ;\n const gchar * olc_key ;\n olc_info_t * olc_req ;\n upcoming_olc = ( ! actx -> pinfo -> fd -> flags . visited ) ? wmem_new0 ( wmem_packet_scope ( ) , olc_info_t ) : NULL ;\n h223_fw_lc_num = 0 ;\n h223_rev_lc_num = 0 ;\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_OpenLogicalChannelAck , OpenLogicalChannelAck_sequence ) ;\n temp = h223_fw_lc_num ;\n p2p_dir = actx -> pinfo -> p2p_dir ;\n if ( actx -> pinfo -> p2p_dir == P2P_DIR_SENT ) actx -> pinfo -> p2p_dir = P2P_DIR_RECV ;\n else actx -> pinfo -> p2p_dir = P2P_DIR_SENT ;\n pend = ( h223_pending_olc * ) g_hash_table_lookup ( h223_pending_olc_reqs [ actx -> pinfo -> p2p_dir ] , GINT_TO_POINTER ( temp ) ) ;\n if ( pend ) {\n DISSECTOR_ASSERT ( ( h223_rev_lc_num && pend -> rev_channel_params ) || ( ! h223_rev_lc_num && ! pend -> rev_channel_params ) ) ;\n if ( h223_add_lc_handle ) {\n ( * h223_add_lc_handle ) ( actx -> pinfo , h223_fw_lc_num , pend -> fw_channel_params ) ;\n if ( h223_rev_lc_num ) ( * h223_add_lc_handle ) ( actx -> pinfo , h223_rev_lc_num , pend -> rev_channel_params ) ;\n }\n }\n else {\n }\n actx -> pinfo -> p2p_dir = p2p_dir ;\n if ( upcoming_olc ) {\n olc_key = gen_olc_key ( upcoming_olc -> fwd_lc_num , & actx -> pinfo -> src , & actx -> pinfo -> dst ) ;\n olc_req = ( olc_info_t * ) g_hash_table_lookup ( h245_pending_olc_reqs , olc_key ) ;\n if ( olc_req ) {\n update_unicast_addr ( & olc_req -> fwd_lc . media_addr , & upcoming_olc -> fwd_lc . media_addr ) ;\n update_unicast_addr ( & olc_req -> fwd_lc . media_control_addr , & upcoming_olc -> fwd_lc . media_control_addr ) ;\n update_unicast_addr ( & olc_req -> rev_lc . media_addr , & upcoming_olc -> rev_lc . media_addr ) ;\n update_unicast_addr ( & olc_req -> rev_lc . media_control_addr , & upcoming_olc -> rev_lc . media_control_addr ) ;\n h245_setup_channels ( actx -> pinfo , & olc_req -> fwd_lc ) ;\n h245_setup_channels ( actx -> pinfo , & olc_req -> rev_lc ) ;\n g_hash_table_remove ( h245_pending_olc_reqs , olc_key ) ;\n }\n else {\n h245_setup_channels ( actx -> pinfo , & upcoming_olc -> fwd_lc ) ;\n }\n }\n upcoming_olc = NULL ;\n if ( h245_pi != NULL ) h245_pi -> msg_type = H245_OpenLogChnAck ;\n return offset ;\n }", "idx": 22280}
{"hash": 2895622461494525400, "project": "debian", "size": 10, "label": 0, "functionSource": "static void test_status ( ) {\n const char * status ;\n DBUG_ENTER ( \"test_status\" ) ;\n myheader ( \"test_status\" ) ;\n if ( ! ( status = mysql_stat ( mysql ) ) ) {\n myerror ( \"mysql_stat failed\" ) ;\n die ( __FILE__ , __LINE__ , \"mysql_stat failed\" ) ;\n }\n DBUG_VOID_RETURN ;\n }", "idx": 22281}
{"hash": -3146697469509848825, "project": "debian", "size": 50, "label": 0, "functionSource": "static int dsa_priv_decode ( EVP_PKEY * pkey , PKCS8_PRIV_KEY_INFO * p8 ) {\n const unsigned char * p , * q , * pm ;\n int pklen , pmlen ;\n int ptype ;\n void * pval ;\n ASN1_STRING * pstr ;\n X509_ALGOR * palg ;\n ASN1_INTEGER * privkey = NULL ;\n BN_CTX * ctx = NULL ;\n DSA * dsa = NULL ;\n int ret = 0 ;\n if ( ! PKCS8_pkey_get0 ( NULL , & p , & pklen , & palg , p8 ) ) return 0 ;\n X509_ALGOR_get0 ( NULL , & ptype , & pval , palg ) ;\n q = p ;\n if ( ( privkey = d2i_ASN1_INTEGER ( NULL , & p , pklen ) ) == NULL ) goto decerr ;\n if ( privkey -> type == V_ASN1_NEG_INTEGER ) {\n p8 -> broken = PKCS8_NEG_PRIVKEY ;\n ASN1_STRING_clear_free ( privkey ) ;\n if ( ( privkey = d2i_ASN1_UINTEGER ( NULL , & q , pklen ) ) == NULL ) goto decerr ;\n }\n if ( ptype != V_ASN1_SEQUENCE ) goto decerr ;\n pstr = pval ;\n pm = pstr -> data ;\n pmlen = pstr -> length ;\n if ( ( dsa = d2i_DSAparams ( NULL , & pm , pmlen ) ) == NULL ) goto decerr ;\n if ( ( dsa -> priv_key = BN_secure_new ( ) ) == NULL || ! ASN1_INTEGER_to_BN ( privkey , dsa -> priv_key ) ) {\n DSAerr ( DSA_F_DSA_PRIV_DECODE , DSA_R_BN_ERROR ) ;\n goto dsaerr ;\n }\n if ( ( dsa -> pub_key = BN_new ( ) ) == NULL ) {\n DSAerr ( DSA_F_DSA_PRIV_DECODE , ERR_R_MALLOC_FAILURE ) ;\n goto dsaerr ;\n }\n if ( ( ctx = BN_CTX_new ( ) ) == NULL ) {\n DSAerr ( DSA_F_DSA_PRIV_DECODE , ERR_R_MALLOC_FAILURE ) ;\n goto dsaerr ;\n }\n if ( ! BN_mod_exp ( dsa -> pub_key , dsa -> g , dsa -> priv_key , dsa -> p , ctx ) ) {\n DSAerr ( DSA_F_DSA_PRIV_DECODE , DSA_R_BN_ERROR ) ;\n goto dsaerr ;\n }\n EVP_PKEY_assign_DSA ( pkey , dsa ) ;\n ret = 1 ;\n goto done ;\n decerr : DSAerr ( DSA_F_DSA_PRIV_DECODE , DSA_R_DECODE_ERROR ) ;\n dsaerr : DSA_free ( dsa ) ;\n done : BN_CTX_free ( ctx ) ;\n ASN1_STRING_clear_free ( privkey ) ;\n return ret ;\n }", "idx": 22282}
{"hash": 4489017523191997023, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h225_SEQUENCE_OF_ServiceControlSession ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence_of ( tvb , offset , actx , tree , hf_index , ett_h225_SEQUENCE_OF_ServiceControlSession , SEQUENCE_OF_ServiceControlSession_sequence_of ) ;\n return offset ;\n }", "idx": 22283}
{"hash": -1315695702746584250, "project": "debian", "size": 46, "label": 0, "functionSource": "proto_item * proto_tree_add_time_item ( proto_tree * tree , int hfindex , tvbuff_t * tvb , const gint start , gint length , const guint encoding , nstime_t * retval , gint * endoff , gint * err ) {\n field_info * new_fi ;\n nstime_t time_stamp ;\n gint saved_err = 0 ;\n header_field_info * hfinfo ;\n PROTO_REGISTRAR_GET_NTH ( hfindex , hfinfo ) ;\n DISSECTOR_ASSERT_HINT ( hfinfo != NULL , \"Not passed hfi!\" ) ;\n DISSECTOR_ASSERT_FIELD_TYPE_IS_TIME ( hfinfo ) ;\n if ( length < - 1 || length == 0 ) {\n REPORT_DISSECTOR_BUG ( wmem_strdup_printf ( wmem_packet_scope ( ) , \"Invalid length %d passed to proto_tree_add_time_item\" , length ) ) ;\n }\n time_stamp . secs = 0 ;\n time_stamp . nsecs = 0 ;\n if ( encoding & ENC_STR_TIME_MASK ) {\n tvb_get_string_time ( tvb , start , length , encoding , & time_stamp , endoff ) ;\n saved_err = errno ;\n }\n else {\n const gboolean is_relative = ( hfinfo -> type == FT_RELATIVE_TIME ) ? TRUE : FALSE ;\n if ( length != 8 && length != 4 ) {\n const gboolean length_error = length < 4 ? TRUE : FALSE ;\n if ( is_relative ) report_type_length_mismatch ( tree , \"a relative time value\" , length , length_error ) ;\n else report_type_length_mismatch ( tree , \"an absolute time value\" , length , length_error ) ;\n }\n tvb_ensure_bytes_exist ( tvb , start , length ) ;\n get_time_value ( tvb , start , length , encoding , & time_stamp , is_relative ) ;\n if ( endoff ) * endoff = length ;\n }\n if ( err ) * err = saved_err ;\n if ( retval ) {\n retval -> secs = time_stamp . secs ;\n retval -> nsecs = time_stamp . nsecs ;\n }\n CHECK_FOR_NULL_TREE ( tree ) ;\n TRY_TO_FAKE_THIS_ITEM ( tree , hfinfo -> id , hfinfo ) ;\n new_fi = new_field_info ( tree , hfinfo , tvb , start , length ) ;\n proto_tree_set_time ( new_fi , & time_stamp ) ;\n if ( encoding & ENC_STRING ) {\n if ( saved_err == ERANGE ) expert_add_info ( NULL , tree , & ei_number_string_decoding_erange_error ) ;\n else if ( saved_err == EDOM ) expert_add_info ( NULL , tree , & ei_number_string_decoding_failed_error ) ;\n }\n else {\n FI_SET_FLAG ( new_fi , ( encoding & ENC_LITTLE_ENDIAN ) ? FI_LITTLE_ENDIAN : FI_BIG_ENDIAN ) ;\n }\n return proto_tree_add_node ( tree , new_fi ) ;\n }", "idx": 22284}
{"hash": 6336384260629386331, "project": "debian", "size": 10, "label": 0, "functionSource": "static void dissect_zcl_power_profile ( tvbuff_t * tvb , proto_tree * tree , guint * offset ) {\n proto_tree_add_item ( tree , hf_zbee_zcl_pwr_prof_pwr_prof_id , tvb , * offset , 1 , ENC_NA ) ;\n * offset += 1 ;\n proto_tree_add_item ( tree , hf_zbee_zcl_pwr_prof_energy_phase_id , tvb , * offset , 1 , ENC_NA ) ;\n * offset += 1 ;\n proto_tree_add_item ( tree , hf_zbee_zcl_pwr_prof_pwr_prof_rem_ctrl , tvb , * offset , 1 , ENC_NA ) ;\n * offset += 1 ;\n proto_tree_add_item ( tree , hf_zbee_zcl_pwr_prof_pwr_prof_state , tvb , * offset , 1 , ENC_NA ) ;\n * offset += 1 ;\n }", "idx": 22285}
{"hash": 4489017523191997023, "project": "debian", "size": 5, "label": 0, "functionSource": "int dissect_h225_NonStandardParameter ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 815 \"./asn1/h225/h225.cnf\" nsp_handle = NULL ;\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_NonStandardParameter , NonStandardParameter_sequence ) ;\n return offset ;\n }", "idx": 22286}
{"hash": 1750726979859153417, "project": "debian", "size": 14, "label": 0, "functionSource": "static PyObject * authGSSClientUserName ( PyObject * self , PyObject * args ) {\n gss_client_state * state ;\n PyObject * pystate ;\n if ( ! PyArg_ParseTuple ( args , \"O\" , & pystate ) ) return NULL ;\n # if PY_MAJOR_VERSION >= 3 if ( ! PyCapsule_CheckExact ( pystate ) ) {\n # else if ( ! PyCObject_Check ( pystate ) ) {\n # endif PyErr_SetString ( PyExc_TypeError , \"Expected a context object\" ) ;\n return NULL ;\n }\n # if PY_MAJOR_VERSION >= 3 state = PyCapsule_GetPointer ( pystate , NULL ) ;\n # else state = ( gss_client_state * ) PyCObject_AsVoidPtr ( pystate ) ;\n # endif if ( state == NULL ) return NULL ;\n return Py_BuildValue ( \"s\" , state -> username ) ;\n }", "idx": 22287}
{"hash": 2335222688263906532, "project": "debian", "size": 54, "label": 1, "functionSource": "static void rv34_pred_mv_b ( RV34DecContext * r , int block_type , int dir ) {\n MpegEncContext * s = & r -> s ;\n int mb_pos = s -> mb_x + s -> mb_y * s -> mb_stride ;\n int mv_pos = s -> mb_x * 2 + s -> mb_y * 2 * s -> b8_stride ;\n int A [ 2 ] = {\n 0 }\n , B [ 2 ] = {\n 0 }\n , C [ 2 ] = {\n 0 }\n ;\n int has_A = 0 , has_B = 0 , has_C = 0 ;\n int mx , my ;\n int i , j ;\n Picture * cur_pic = s -> current_picture_ptr ;\n const int mask = dir ? MB_TYPE_L1 : MB_TYPE_L0 ;\n int type = cur_pic -> f . mb_type [ mb_pos ] ;\n if ( ( r -> avail_cache [ 6 - 1 ] & type ) & mask ) {\n A [ 0 ] = cur_pic -> f . motion_val [ dir ] [ mv_pos - 1 ] [ 0 ] ;\n A [ 1 ] = cur_pic -> f . motion_val [ dir ] [ mv_pos - 1 ] [ 1 ] ;\n has_A = 1 ;\n }\n if ( ( r -> avail_cache [ 6 - 4 ] & type ) & mask ) {\n B [ 0 ] = cur_pic -> f . motion_val [ dir ] [ mv_pos - s -> b8_stride ] [ 0 ] ;\n B [ 1 ] = cur_pic -> f . motion_val [ dir ] [ mv_pos - s -> b8_stride ] [ 1 ] ;\n has_B = 1 ;\n }\n if ( r -> avail_cache [ 6 - 4 ] && ( r -> avail_cache [ 6 - 2 ] & type ) & mask ) {\n C [ 0 ] = cur_pic -> f . motion_val [ dir ] [ mv_pos - s -> b8_stride + 2 ] [ 0 ] ;\n C [ 1 ] = cur_pic -> f . motion_val [ dir ] [ mv_pos - s -> b8_stride + 2 ] [ 1 ] ;\n has_C = 1 ;\n }\n else if ( ( s -> mb_x + 1 ) == s -> mb_width && ( r -> avail_cache [ 6 - 5 ] & type ) & mask ) {\n C [ 0 ] = cur_pic -> f . motion_val [ dir ] [ mv_pos - s -> b8_stride - 1 ] [ 0 ] ;\n C [ 1 ] = cur_pic -> f . motion_val [ dir ] [ mv_pos - s -> b8_stride - 1 ] [ 1 ] ;\n has_C = 1 ;\n }\n rv34_pred_b_vector ( A , B , C , has_A , has_B , has_C , & mx , & my ) ;\n mx += r -> dmv [ dir ] [ 0 ] ;\n my += r -> dmv [ dir ] [ 1 ] ;\n for ( j = 0 ;\n j < 2 ;\n j ++ ) {\n for ( i = 0 ;\n i < 2 ;\n i ++ ) {\n cur_pic -> f . motion_val [ dir ] [ mv_pos + i + j * s -> b8_stride ] [ 0 ] = mx ;\n cur_pic -> f . motion_val [ dir ] [ mv_pos + i + j * s -> b8_stride ] [ 1 ] = my ;\n }\n }\n if ( block_type == RV34_MB_B_BACKWARD || block_type == RV34_MB_B_FORWARD ) {\n ZERO8x2 ( cur_pic -> f . motion_val [ ! dir ] [ mv_pos ] , s -> b8_stride ) ;\n }\n }", "idx": 22288}
{"hash": 1788300783882316916, "project": "debian", "size": 5, "label": 0, "functionSource": "static int minima_cmp ( const void * a , const void * b ) {\n const Minima * da = ( const Minima * ) a ;\n const Minima * db = ( const Minima * ) b ;\n return da -> height - db -> height ;\n }", "idx": 22289}
{"hash": 6755873269946787742, "project": "debian", "size": 51, "label": 1, "functionSource": "static void pk_transaction_authorize_actions_finished_cb ( GObject * source_object , GAsyncResult * res , struct AuthorizeActionsData * data ) {\n const gchar * action_id = NULL ;\n PkTransactionPrivate * priv = data -> transaction -> priv ;\n g_autoptr ( GError ) error = NULL ;\n g_autoptr ( PolkitAuthorizationResult ) result = NULL ;\n g_assert ( data -> actions && data -> actions -> len > 0 ) ;\n action_id = g_ptr_array_index ( data -> actions , 0 ) ;\n result = polkit_authority_check_authorization_finish ( priv -> authority , res , & error ) ;\n if ( g_cancellable_is_cancelled ( priv -> cancellable ) ) {\n priv -> waiting_for_auth = FALSE ;\n pk_transaction_status_changed_emit ( data -> transaction , PK_STATUS_ENUM_FINISHED ) ;\n pk_transaction_error_code_emit ( data -> transaction , PK_ERROR_ENUM_NOT_AUTHORIZED , \"The authentication was cancelled due to a timeout.\" ) ;\n pk_transaction_finished_emit ( data -> transaction , PK_EXIT_ENUM_FAILED , 0 ) ;\n goto out ;\n }\n if ( result == NULL ) {\n g_autofree gchar * message = NULL ;\n priv -> waiting_for_auth = FALSE ;\n g_warning ( \"failed to check for auth: %s\" , error -> message ) ;\n pk_transaction_status_changed_emit ( data -> transaction , PK_STATUS_ENUM_FINISHED ) ;\n message = g_strdup_printf ( \"Failed to check for authentication: %s\" , error -> message ) ;\n pk_transaction_error_code_emit ( data -> transaction , PK_ERROR_ENUM_NOT_AUTHORIZED , message ) ;\n pk_transaction_finished_emit ( data -> transaction , PK_EXIT_ENUM_FAILED , 0 ) ;\n goto out ;\n }\n if ( ! polkit_authorization_result_get_is_authorized ( result ) ) {\n if ( g_strcmp0 ( action_id , \"org.freedesktop.packagekit.package-install\" ) == 0 && pk_bitfield_contain ( priv -> cached_transaction_flags , PK_TRANSACTION_FLAG_ENUM_ALLOW_REINSTALL ) ) {\n g_debug ( \"allowing just reinstallation\" ) ;\n pk_bitfield_add ( priv -> cached_transaction_flags , PK_TRANSACTION_FLAG_ENUM_JUST_REINSTALL ) ;\n }\n else {\n priv -> waiting_for_auth = FALSE ;\n pk_transaction_status_changed_emit ( data -> transaction , PK_STATUS_ENUM_FINISHED ) ;\n pk_transaction_error_code_emit ( data -> transaction , PK_ERROR_ENUM_NOT_AUTHORIZED , \"Failed to obtain authentication.\" ) ;\n pk_transaction_finished_emit ( data -> transaction , PK_EXIT_ENUM_FAILED , 0 ) ;\n syslog ( LOG_AUTH | LOG_NOTICE , \"uid %i failed to obtain auth\" , priv -> uid ) ;\n goto out ;\n }\n }\n if ( data -> actions -> len <= 1 ) {\n priv -> waiting_for_auth = FALSE ;\n pk_transaction_set_state ( data -> transaction , PK_TRANSACTION_STATE_READY ) ;\n syslog ( LOG_AUTH | LOG_INFO , \"uid %i obtained auth for %s\" , priv -> uid , action_id ) ;\n }\n else {\n g_ptr_array_remove_index ( data -> actions , 0 ) ;\n pk_transaction_authorize_actions ( data -> transaction , data -> role , data -> actions ) ;\n }\n out : g_ptr_array_unref ( data -> actions ) ;\n g_free ( data ) ;\n }", "idx": 22290}
{"hash": 6323824267898511453, "project": "debian", "size": 3, "label": 0, "functionSource": "fz_colorspace * fz_colorspace_base ( fz_context * ctx , const fz_colorspace * cs ) {\n return cs && cs -> get_base ? cs -> get_base ( cs ) : NULL ;\n }", "idx": 22291}
{"hash": 6249489553242542670, "project": "debian", "size": 12, "label": 0, "functionSource": "static unsigned long get_pfxmatch ( char * * s , struct masks * m ) {\n while ( m -> name ) {\n if ( strncmp ( * s , m -> name , strlen ( m -> name ) ) == 0 ) {\n * s += strlen ( m -> name ) ;\n return m -> mask ;\n }\n else {\n m ++ ;\n }\n }\n return 0 ;\n }", "idx": 22292}
{"hash": 6675626110148442062, "project": "debian", "size": 5, "label": 0, "functionSource": "static int sfile_write ( jas_stream_obj_t * obj , char * buf , int cnt ) {\n FILE * fp ;\n fp = JAS_CAST ( FILE * , obj ) ;\n return fwrite ( buf , 1 , cnt , fp ) ;\n }", "idx": 22293}
{"hash": 6862887795439011210, "project": "chrome", "size": 25, "label": 0, "functionSource": "TEST_F ( SSLErrorAssistantTest , DynamicInterstitialListNoCommonName ) {\n ASSERT_TRUE ( embedded_test_server ( ) -> Start ( ) ) ;\n EXPECT_EQ ( 1u , ssl_info ( ) . public_key_hashes . size ( ) ) ;\n auto config_proto = std : : make_unique < chrome_browser_ssl : : SSLErrorAssistantConfig > ( ) ;\n config_proto -> set_version_id ( kLargeVersionId ) ;\n chrome_browser_ssl : : DynamicInterstitial * filter = config_proto -> add_dynamic_interstitial ( ) ;\n filter -> set_interstitial_type ( chrome_browser_ssl : : DynamicInterstitial : : INTERSTITIAL_PAGE_CAPTIVE_PORTAL ) ;\n filter -> set_cert_error ( chrome_browser_ssl : : DynamicInterstitial : : UNKNOWN_CERT_ERROR ) ;\n filter -> add_sha256_hash ( \"sha256ightjar\" ) ;\n filter -> add_sha256_hash ( \"sha256/frogmouth\" ) ;\n filter -> add_sha256_hash ( \"sha256/poorwill\" ) ;\n filter = config_proto -> add_dynamic_interstitial ( ) ;\n filter -> set_interstitial_type ( chrome_browser_ssl : : DynamicInterstitial : : INTERSTITIAL_PAGE_SSL ) ;\n filter -> set_cert_error ( chrome_browser_ssl : : DynamicInterstitial : : ERR_CERT_COMMON_NAME_INVALID ) ;\n filter -> add_sha256_hash ( \"sha256uthatch\" ) ;\n filter -> add_sha256_hash ( ssl_info ( ) . public_key_hashes [ 0 ] . ToString ( ) ) ;\n filter -> add_sha256_hash ( \"sha256/treecreeper\" ) ;\n filter -> set_issuer_common_name_regex ( std : : string ( ) ) ;\n filter -> set_issuer_organization_regex ( issuer_organization_name ( ) ) ;\n filter -> set_mitm_software_name ( \"UwS\" ) ;\n error_assistant ( ) -> SetErrorAssistantProto ( std : : move ( config_proto ) ) ;\n base : : Optional < DynamicInterstitialInfo > dynamic_interstitial = error_assistant ( ) -> MatchDynamicInterstitial ( ssl_info ( ) ) ;\n ASSERT_TRUE ( dynamic_interstitial ) ;\n EXPECT_EQ ( chrome_browser_ssl : : DynamicInterstitial : : INTERSTITIAL_PAGE_SSL , dynamic_interstitial -> interstitial_type ) ;\n }", "idx": 22294}
{"hash": -4299048894522449432, "project": "debian", "size": 54, "label": 0, "functionSource": "static void imc_get_skip_coeff ( IMCContext * q , IMCChannel * chctx ) {\n int i , j ;\n memset ( chctx -> skipFlagBits , 0 , sizeof ( chctx -> skipFlagBits ) ) ;\n memset ( chctx -> skipFlagCount , 0 , sizeof ( chctx -> skipFlagCount ) ) ;\n for ( i = 0 ;\n i < BANDS ;\n i ++ ) {\n if ( ! chctx -> bandFlagsBuf [ i ] || ! chctx -> bandWidthT [ i ] ) continue ;\n if ( ! chctx -> skipFlagRaw [ i ] ) {\n chctx -> skipFlagBits [ i ] = band_tab [ i + 1 ] - band_tab [ i ] ;\n for ( j = band_tab [ i ] ;\n j < band_tab [ i + 1 ] ;\n j ++ ) {\n chctx -> skipFlags [ j ] = get_bits1 ( & q -> gb ) ;\n if ( chctx -> skipFlags [ j ] ) chctx -> skipFlagCount [ i ] ++ ;\n }\n }\n else {\n for ( j = band_tab [ i ] ;\n j < band_tab [ i + 1 ] - 1 ;\n j += 2 ) {\n if ( ! get_bits1 ( & q -> gb ) ) {\n chctx -> skipFlagBits [ i ] ++ ;\n chctx -> skipFlags [ j ] = 1 ;\n chctx -> skipFlags [ j + 1 ] = 1 ;\n chctx -> skipFlagCount [ i ] += 2 ;\n }\n else {\n if ( get_bits1 ( & q -> gb ) ) {\n chctx -> skipFlagBits [ i ] += 2 ;\n chctx -> skipFlags [ j ] = 0 ;\n chctx -> skipFlags [ j + 1 ] = 1 ;\n chctx -> skipFlagCount [ i ] ++ ;\n }\n else {\n chctx -> skipFlagBits [ i ] += 3 ;\n chctx -> skipFlags [ j + 1 ] = 0 ;\n if ( ! get_bits1 ( & q -> gb ) ) {\n chctx -> skipFlags [ j ] = 1 ;\n chctx -> skipFlagCount [ i ] ++ ;\n }\n else {\n chctx -> skipFlags [ j ] = 0 ;\n }\n }\n }\n }\n if ( j < band_tab [ i + 1 ] ) {\n chctx -> skipFlagBits [ i ] ++ ;\n if ( ( chctx -> skipFlags [ j ] = get_bits1 ( & q -> gb ) ) ) chctx -> skipFlagCount [ i ] ++ ;\n }\n }\n }\n }", "idx": 22295}
{"hash": 5506079590431503777, "project": "debian", "size": 18, "label": 0, "functionSource": "static int get_dns_name_type_class ( tvbuff_t * tvb , int offset , int dns_data_offset , const guchar * * name_ret , int * name_len_ret , int * type_ret , int * class_ret ) {\n int len ;\n int name_len ;\n int type ;\n int dns_class ;\n int start_offset = offset ;\n name_len = get_dns_name ( tvb , offset , 0 , dns_data_offset , name_ret ) ;\n offset += name_len ;\n type = tvb_get_ntohs ( tvb , offset ) ;\n offset += 2 ;\n dns_class = tvb_get_ntohs ( tvb , offset ) ;\n offset += 2 ;\n * type_ret = type ;\n * class_ret = dns_class ;\n * name_len_ret = name_len ;\n len = offset - start_offset ;\n return len ;\n }", "idx": 22296}
{"hash": -3740862514502467070, "project": "debian", "size": 178, "label": 0, "functionSource": "static void setos2 ( struct os2 * os2 , struct alltabs * at , SplineFont * sf , enum fontformat format ) {\n int i , cnt1 , cnt2 , first , last , avg1 , avg2 , gid ;\n char * pt ;\n static int const weightFactors [ 26 ] = {\n 64 , 14 , 27 , 35 , 100 , 20 , 14 , 42 , 63 , 3 , 6 , 35 , 20 , 56 , 56 , 17 , 4 , 49 , 56 , 71 , 31 , 10 , 18 , 3 , 18 , 2 }\n ;\n EncMap * map ;\n SplineChar * sc ;\n int modformat = format ;\n os2 -> version = 1 ;\n if ( format == ff_otf || format == ff_otfcid ) os2 -> version = 3 ;\n if ( sf -> use_typo_metrics || sf -> weight_width_slope_only ) os2 -> version = 4 ;\n if ( sf -> os2_version > os2 -> version ) os2 -> version = sf -> os2_version ;\n if ( ( format >= ff_ttf && format <= ff_otfdfont ) && ( at -> gi . flags & ttf_flag_symbol ) ) modformat = ff_ttfsym ;\n os2 -> weightClass = sf -> pfminfo . weight ;\n os2 -> widthClass = sf -> pfminfo . width ;\n os2 -> fstype = 0x8 ;\n if ( sf -> pfminfo . fstype != - 1 ) os2 -> fstype = sf -> pfminfo . fstype ;\n if ( ! sf -> pfminfo . subsuper_set ) SFDefaultOS2SubSuper ( & sf -> pfminfo , sf -> ascent + sf -> descent , sf -> italicangle ) ;\n os2 -> ysupYSize = sf -> pfminfo . os2_supysize ;\n os2 -> ysubXSize = sf -> pfminfo . os2_subxsize ;\n os2 -> ysubYSize = sf -> pfminfo . os2_subysize ;\n os2 -> ysupXSize = sf -> pfminfo . os2_supxsize ;\n os2 -> ysubYOff = sf -> pfminfo . os2_subyoff ;\n os2 -> ysubXOff = sf -> pfminfo . os2_subxoff ;\n os2 -> ysupXOff = sf -> pfminfo . os2_supxoff ;\n os2 -> ysupYOff = sf -> pfminfo . os2_supyoff ;\n os2 -> yStrikeoutSize = sf -> pfminfo . os2_strikeysize ;\n os2 -> yStrikeoutPos = sf -> pfminfo . os2_strikeypos ;\n if ( sf -> pfminfo . stylemap != - 1 ) {\n int changed = 0 ;\n os2 -> fsSel = sf -> pfminfo . stylemap ;\n if ( at -> head . macstyle & 1 && ! ( os2 -> fsSel & 32 ) ) {\n at -> head . macstyle &= 0x7E ;\n changed = 1 ;\n }\n if ( at -> head . macstyle & 2 && ! ( os2 -> fsSel & 1 ) ) {\n at -> head . macstyle &= 0x7D ;\n changed = 1 ;\n }\n if ( changed ) redohead ( at ) ;\n }\n else {\n os2 -> fsSel = ( at -> head . macstyle & 1 ? 32 : 0 ) | ( at -> head . macstyle & 2 ? 1 : 0 ) ;\n if ( os2 -> fsSel == 0 && sf -> pfminfo . weight == 400 ) os2 -> fsSel = 64 ;\n }\n if ( sf -> fullname != NULL && strstrmatch ( sf -> fullname , \"outline\" ) != NULL ) os2 -> fsSel |= 8 ;\n if ( os2 -> version >= 4 ) {\n if ( strstrmatch ( sf -> fontname , \"Obli\" ) != NULL ) {\n os2 -> fsSel |= 512 ;\n }\n if ( sf -> use_typo_metrics ) os2 -> fsSel |= 128 ;\n if ( sf -> weight_width_slope_only ) os2 -> fsSel |= 256 ;\n }\n if ( sf -> pfminfo . typoascent_add ) os2 -> ascender = sf -> ascent + sf -> pfminfo . os2_typoascent ;\n else os2 -> ascender = sf -> pfminfo . os2_typoascent ;\n if ( sf -> pfminfo . typodescent_add ) os2 -> descender = - sf -> descent + sf -> pfminfo . os2_typodescent ;\n else os2 -> descender = sf -> pfminfo . os2_typodescent ;\n WinBB ( sf , & os2 -> winascent , & os2 -> windescent , at ) ;\n os2 -> linegap = sf -> pfminfo . os2_typolinegap ;\n os2 -> sFamilyClass = sf -> pfminfo . os2_family_class ;\n avg1 = avg2 = last = 0 ;\n first = 0xffff ;\n cnt1 = cnt2 = 0 ;\n for ( i = 0 ;\n i < sf -> glyphcnt ;\n ++ i ) if ( ( sc = sf -> glyphs [ i ] ) != NULL ) {\n if ( SCWorthOutputting ( sc ) && sc -> unicodeenc != - 1 ) {\n if ( ( format >= ff_ttf && format <= ff_otfdfont && sc -> ttf_glyph > 2 ) || ( format >= ff_ttf && format <= ff_otfdfont && sc -> ttf_glyph > 0 ) ) {\n if ( sc -> unicodeenc <= 0xffff ) {\n if ( sc -> unicodeenc < first ) first = sc -> unicodeenc ;\n if ( sc -> unicodeenc > last ) last = sc -> unicodeenc ;\n }\n else {\n last = 0xffff ;\n }\n }\n if ( sc -> width != 0 ) {\n avg2 += sc -> width ;\n ++ cnt2 ;\n }\n if ( sc -> unicodeenc == ' ' ) {\n avg1 += sc -> width * 166 ;\n ++ cnt1 ;\n }\n else if ( sc -> unicodeenc >= 'a' && sc -> unicodeenc <= 'z' ) {\n avg1 += sc -> width * weightFactors [ sc -> unicodeenc - 'a' ] ;\n ++ cnt1 ;\n }\n }\n }\n if ( sf -> pfminfo . hasunicoderanges ) memcpy ( os2 -> unicoderange , sf -> pfminfo . unicoderanges , sizeof ( os2 -> unicoderange ) ) ;\n else OS2FigureUnicodeRanges ( sf , os2 -> unicoderange ) ;\n if ( modformat == ff_ttfsym ) memset ( os2 -> unicoderange , 0 , sizeof ( os2 -> unicoderange ) ) ;\n if ( sf -> pfminfo . pfmset ) strncpy ( os2 -> achVendID , sf -> pfminfo . os2_vendor , 4 ) ;\n else if ( TTFFoundry != NULL ) strncpy ( os2 -> achVendID , TTFFoundry , 4 ) ;\n else memcpy ( os2 -> achVendID , \"PfEd\" , 4 ) ;\n for ( pt = os2 -> achVendID ;\n pt < os2 -> achVendID && * pt != '\\0' ;\n ++ pt ) ;\n while ( pt < os2 -> achVendID ) * pt ++ = ' ' ;\n os2 -> avgCharWid = 500 ;\n os2 -> v1_avgCharWid = os2 -> v3_avgCharWid = 0 ;\n if ( cnt1 == 27 ) os2 -> v1_avgCharWid = avg1 / 1000 ;\n if ( cnt2 != 0 ) os2 -> v3_avgCharWid = avg2 / cnt2 ;\n memcpy ( os2 -> panose , sf -> pfminfo . panose , sizeof ( os2 -> panose ) ) ;\n map = at -> map ;\n if ( modformat == ff_ttfsym ) {\n if ( sf -> pfminfo . hascodepages ) memcpy ( os2 -> ulCodePage , sf -> pfminfo . codepages , sizeof ( os2 -> ulCodePage ) ) ;\n else {\n os2 -> ulCodePage [ 0 ] = 0x80000000 ;\n os2 -> ulCodePage [ 1 ] = 0 ;\n }\n if ( AlreadyMSSymbolArea ( sf , map ) ) {\n first = 0xf0ff ;\n last = 0 ;\n for ( i = 0xf020 ;\n i < map -> enccount && i <= 0xf0ff ;\n ++ i ) if ( ( gid = map -> map [ i ] ) != - 1 && sf -> glyphs [ gid ] != NULL && sf -> glyphs [ gid ] -> ttf_glyph != - 1 ) {\n if ( i < first ) first = i ;\n if ( i > last ) last = i ;\n }\n for ( i = 0 ;\n i < map -> enccount && i <= 255 ;\n ++ i ) if ( ( gid = map -> map [ i ] ) != - 1 && sf -> glyphs [ gid ] != NULL && sf -> glyphs [ gid ] -> ttf_glyph != - 1 ) {\n if ( i + 0xf000 < first ) first = i + 0xf000 ;\n if ( i + 0xf000 > last ) last = i + 0xf000 ;\n }\n os2 -> firstcharindex = first ;\n os2 -> lastcharindex = last ;\n }\n else {\n first = 255 ;\n last = 0 ;\n for ( i = 0 ;\n i < map -> enccount && i <= 255 ;\n ++ i ) if ( ( gid = map -> map [ i ] ) != - 1 && sf -> glyphs [ gid ] != NULL && sf -> glyphs [ gid ] -> ttf_glyph != - 1 ) {\n if ( i < first ) first = i ;\n if ( i > last ) last = i ;\n }\n for ( i = 0xf020 ;\n i < map -> enccount && i <= 0xf0ff ;\n ++ i ) if ( ( gid = map -> map [ i ] ) != - 1 && sf -> glyphs [ gid ] != NULL && sf -> glyphs [ gid ] -> ttf_glyph != - 1 ) {\n if ( i - 0xf000 < first ) first = i - 0xf000 ;\n if ( i - 0xf000 > last ) last = i - 0xf000 ;\n }\n if ( first < ' ' ) first = ' ' ;\n os2 -> firstcharindex = 0xf000 + first ;\n os2 -> lastcharindex = 0xf000 + last ;\n }\n }\n else {\n os2 -> firstcharindex = first ;\n os2 -> lastcharindex = last ;\n if ( sf -> pfminfo . hascodepages ) memcpy ( os2 -> ulCodePage , sf -> pfminfo . codepages , sizeof ( os2 -> ulCodePage ) ) ;\n else OS2FigureCodePages ( sf , os2 -> ulCodePage ) ;\n if ( ! sf -> pfminfo . hascodepages ) if ( ( os2 -> ulCodePage [ 0 ] & ~ ( 1U << 31 ) ) == 0 && os2 -> ulCodePage [ 1 ] == 0 ) os2 -> ulCodePage [ 0 ] |= 1 ;\n }\n if ( os2 -> version >= 2 ) {\n if ( sf -> pfminfo . os2_xheight != 0 ) os2 -> xHeight = sf -> pfminfo . os2_xheight ;\n else {\n double xh = SFXHeight ( sf , at -> gi . layer , true ) ;\n os2 -> xHeight = ( xh >= 0.0 ? xh : 0 ) ;\n }\n if ( sf -> pfminfo . os2_capheight != 0 ) os2 -> capHeight = sf -> pfminfo . os2_capheight ;\n else {\n double caph = SFCapHeight ( sf , at -> gi . layer , true ) ;\n os2 -> capHeight = ( caph >= 0.0 ? caph : 0 ) ;\n }\n os2 -> defChar = 0 ;\n if ( format == ff_otf || format == ff_otfcid ) os2 -> defChar = ' ' ;\n os2 -> breakChar = ' ' ;\n os2 -> maxContext = 1 ;\n }\n if ( os2 -> version >= 3 && os2 -> v3_avgCharWid != 0 ) os2 -> avgCharWid = os2 -> v3_avgCharWid ;\n else if ( os2 -> v1_avgCharWid != 0 ) os2 -> avgCharWid = os2 -> v1_avgCharWid ;\n else if ( os2 -> v3_avgCharWid != 0 ) os2 -> avgCharWid = os2 -> v3_avgCharWid ;\n }", "idx": 22297}
{"hash": 6968788423709606113, "project": "debian", "size": 49, "label": 0, "functionSource": "static int ReadBlobLZWByte ( LZWInfo * lzw_info ) {\n int code ;\n size_t one , value ;\n ssize_t count ;\n if ( lzw_info -> stack -> index != lzw_info -> stack -> codes ) return ( PopLZWStack ( lzw_info -> stack ) ) ;\n if ( lzw_info -> genesis != MagickFalse ) {\n lzw_info -> genesis = MagickFalse ;\n do {\n lzw_info -> first_code = ( size_t ) GetNextLZWCode ( lzw_info , lzw_info -> bits ) ;\n lzw_info -> last_code = lzw_info -> first_code ;\n }\n while ( lzw_info -> first_code == lzw_info -> clear_code ) ;\n return ( ( int ) lzw_info -> first_code ) ;\n }\n code = GetNextLZWCode ( lzw_info , lzw_info -> bits ) ;\n if ( code < 0 ) return ( code ) ;\n if ( ( size_t ) code == lzw_info -> clear_code ) {\n ResetLZWInfo ( lzw_info ) ;\n return ( ReadBlobLZWByte ( lzw_info ) ) ;\n }\n if ( ( size_t ) code == lzw_info -> end_code ) return ( - 1 ) ;\n if ( ( size_t ) code < lzw_info -> slot ) value = ( size_t ) code ;\n else {\n PushLZWStack ( lzw_info -> stack , lzw_info -> first_code ) ;\n value = lzw_info -> last_code ;\n }\n count = 0 ;\n while ( value > lzw_info -> maximum_data_value ) {\n if ( ( size_t ) count > MaximumLZWCode ) return ( - 1 ) ;\n count ++ ;\n if ( ( size_t ) value > MaximumLZWCode ) return ( - 1 ) ;\n PushLZWStack ( lzw_info -> stack , lzw_info -> table [ 1 ] [ value ] ) ;\n value = lzw_info -> table [ 0 ] [ value ] ;\n }\n lzw_info -> first_code = lzw_info -> table [ 1 ] [ value ] ;\n PushLZWStack ( lzw_info -> stack , lzw_info -> first_code ) ;\n one = 1 ;\n if ( lzw_info -> slot < MaximumLZWCode ) {\n lzw_info -> table [ 0 ] [ lzw_info -> slot ] = lzw_info -> last_code ;\n lzw_info -> table [ 1 ] [ lzw_info -> slot ] = lzw_info -> first_code ;\n lzw_info -> slot ++ ;\n if ( ( lzw_info -> slot >= lzw_info -> maximum_code ) && ( lzw_info -> bits < MaximumLZWBits ) ) {\n lzw_info -> bits ++ ;\n lzw_info -> maximum_code = one << lzw_info -> bits ;\n }\n }\n lzw_info -> last_code = ( size_t ) code ;\n return ( PopLZWStack ( lzw_info -> stack ) ) ;\n }", "idx": 22298}
{"hash": -7253276028511611170, "project": "debian", "size": 4, "label": 0, "functionSource": "static void encode_signal_range ( VC2EncContext * s ) {\n put_bits ( & s -> pb , 1 , ! s -> strict_compliance ) ;\n if ( ! s -> strict_compliance ) put_vc2_ue_uint ( & s -> pb , s -> bpp_idx ) ;\n }", "idx": 22299}
{"hash": 8801969307247112896, "project": "debian", "size": 59, "label": 0, "functionSource": "static int aes_ccm_ctrl ( EVP_CIPHER_CTX * c , int type , int arg , void * ptr ) {\n EVP_AES_CCM_CTX * cctx = EVP_C_DATA ( EVP_AES_CCM_CTX , c ) ;\n switch ( type ) {\n case EVP_CTRL_INIT : cctx -> key_set = 0 ;\n cctx -> iv_set = 0 ;\n cctx -> L = 8 ;\n cctx -> M = 12 ;\n cctx -> tag_set = 0 ;\n cctx -> len_set = 0 ;\n cctx -> tls_aad_len = - 1 ;\n return 1 ;\n case EVP_CTRL_AEAD_TLS1_AAD : if ( arg != EVP_AEAD_TLS1_AAD_LEN ) return 0 ;\n memcpy ( EVP_CIPHER_CTX_buf_noconst ( c ) , ptr , arg ) ;\n cctx -> tls_aad_len = arg ;\n {\n uint16_t len = EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 2 ] << 8 | EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 1 ] ;\n if ( len < EVP_CCM_TLS_EXPLICIT_IV_LEN ) return 0 ;\n len -= EVP_CCM_TLS_EXPLICIT_IV_LEN ;\n if ( ! EVP_CIPHER_CTX_encrypting ( c ) ) {\n if ( len < cctx -> M ) return 0 ;\n len -= cctx -> M ;\n }\n EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 2 ] = len >> 8 ;\n EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 1 ] = len & 0xff ;\n }\n return cctx -> M ;\n case EVP_CTRL_CCM_SET_IV_FIXED : if ( arg != EVP_CCM_TLS_FIXED_IV_LEN ) return 0 ;\n memcpy ( EVP_CIPHER_CTX_iv_noconst ( c ) , ptr , arg ) ;\n return 1 ;\n case EVP_CTRL_AEAD_SET_IVLEN : arg = 15 - arg ;\n case EVP_CTRL_CCM_SET_L : if ( arg < 2 || arg > 8 ) return 0 ;\n cctx -> L = arg ;\n return 1 ;\n case EVP_CTRL_AEAD_SET_TAG : if ( ( arg & 1 ) || arg < 4 || arg > 16 ) return 0 ;\n if ( EVP_CIPHER_CTX_encrypting ( c ) && ptr ) return 0 ;\n if ( ptr ) {\n cctx -> tag_set = 1 ;\n memcpy ( EVP_CIPHER_CTX_buf_noconst ( c ) , ptr , arg ) ;\n }\n cctx -> M = arg ;\n return 1 ;\n case EVP_CTRL_AEAD_GET_TAG : if ( ! EVP_CIPHER_CTX_encrypting ( c ) || ! cctx -> tag_set ) return 0 ;\n if ( ! CRYPTO_ccm128_tag ( & cctx -> ccm , ptr , ( size_t ) arg ) ) return 0 ;\n cctx -> tag_set = 0 ;\n cctx -> iv_set = 0 ;\n cctx -> len_set = 0 ;\n return 1 ;\n case EVP_CTRL_COPY : {\n EVP_CIPHER_CTX * out = ptr ;\n EVP_AES_CCM_CTX * cctx_out = EVP_C_DATA ( EVP_AES_CCM_CTX , out ) ;\n if ( cctx -> ccm . key ) {\n if ( cctx -> ccm . key != & cctx -> ks ) return 0 ;\n cctx_out -> ccm . key = & cctx_out -> ks ;\n }\n return 1 ;\n }\n default : return - 1 ;\n }\n }", "idx": 22300}
{"hash": 3668456668028959955, "project": "debian", "size": 4, "label": 0, "functionSource": "static VALUE cState_buffer_initial_length ( VALUE self ) {\n GET_STATE ( self ) ;\n return LONG2FIX ( state -> buffer_initial_length ) ;\n }", "idx": 22301}
{"hash": 3919646340804521652, "project": "debian", "size": 7, "label": 0, "functionSource": "static void add_family_to_write_order ( struct object_entry * * wo , unsigned int * endp , struct object_entry * e ) {\n struct object_entry * root ;\n for ( root = e ;\n root -> delta ;\n root = root -> delta ) ;\n add_descendants_to_write_order ( wo , endp , root ) ;\n }", "idx": 22302}
{"hash": -7555034601056330007, "project": "debian", "size": 5, "label": 0, "functionSource": "static int virLogSetDefaultOutputToJournald ( void ) {\n virLogPriority priority = virLogDefaultPriority ;\n if ( priority == VIR_LOG_DEBUG ) priority = VIR_LOG_INFO ;\n return virAsprintf ( & virLogDefaultOutput , \"%d:journald\" , priority ) ;\n }", "idx": 22303}
{"hash": -9197960073880365676, "project": "debian", "size": 30, "label": 0, "functionSource": "static int read_unknown_extension ( Gif_Context * gfc , Gif_Reader * grr , int kind , char * appname , int applength ) {\n uint8_t block_len = gifgetbyte ( grr ) ;\n uint8_t * data = 0 ;\n int data_len = 0 ;\n Gif_Extension * gfex = 0 ;\n while ( block_len > 0 ) {\n Gif_ReArray ( data , uint8_t , data_len + block_len + 2 ) ;\n if ( ! data ) goto done ;\n data [ data_len ] = block_len ;\n gifgetblock ( data + data_len + 1 , block_len , grr ) ;\n data_len += block_len + 1 ;\n block_len = gifgetbyte ( grr ) ;\n }\n if ( data ) gfex = Gif_NewExtension ( kind , appname , applength ) ;\n if ( gfex ) {\n gfex -> data = data ;\n gfex -> free_data = Gif_Free ;\n gfex -> length = data_len ;\n gfex -> packetized = 1 ;\n data [ data_len ] = 0 ;\n Gif_AddExtension ( gfc -> stream , gfc -> gfi , gfex ) ;\n }\n done : if ( ! gfex ) Gif_DeleteArray ( data ) ;\n while ( block_len > 0 ) {\n uint8_t buffer [ GIF_MAX_BLOCK ] ;\n gifgetblock ( buffer , block_len , grr ) ;\n block_len = gifgetbyte ( grr ) ;\n }\n return gfex != 0 ;\n }", "idx": 22304}
{"hash": -4525941100783779911, "project": "debian", "size": 5, "label": 0, "functionSource": "static void SkipEOLN ( cmsIT8 * it8 ) {\n while ( it8 -> sy == SEOLN ) {\n InSymbol ( it8 ) ;\n }\n }", "idx": 22305}
{"hash": -1315695702746584250, "project": "debian", "size": 13, "label": 0, "functionSource": "proto_item * proto_tree_add_int64 ( proto_tree * tree , int hfindex , tvbuff_t * tvb , gint start , gint length , gint64 value ) {\n proto_item * pi = NULL ;\n header_field_info * hfinfo ;\n CHECK_FOR_NULL_TREE ( tree ) ;\n TRY_TO_FAKE_THIS_ITEM ( tree , hfindex , hfinfo ) ;\n switch ( hfinfo -> type ) {\n case FT_INT40 : case FT_INT48 : case FT_INT56 : case FT_INT64 : pi = proto_tree_add_pi ( tree , hfinfo , tvb , start , & length ) ;\n proto_tree_set_int64 ( PNODE_FINFO ( pi ) , value ) ;\n break ;\n default : DISSECTOR_ASSERT_NOT_REACHED ( ) ;\n }\n return pi ;\n }", "idx": 22306}
{"hash": 3309252579593081468, "project": "debian", "size": 71, "label": 0, "functionSource": "int nntp_check_new_groups ( struct NntpServer * nserv ) {\n struct NntpData nntp_data ;\n time_t now ;\n struct tm * tm = NULL ;\n char buf [ LONG_STRING ] ;\n char * msg = _ ( \"Checking for new newsgroups...\" ) ;\n unsigned int i ;\n int rc , update_active = false ;\n if ( ! nserv || ! nserv -> newgroups_time ) return - 1 ;\n if ( ShowNewNews ) {\n mutt_message ( _ ( \"Checking for new messages...\" ) ) ;\n for ( i = 0 ;\n i < nserv -> groups_num ;\n i ++ ) {\n struct NntpData * data = nserv -> groups_list [ i ] ;\n if ( data && data -> subscribed ) {\n rc = nntp_group_poll ( data , 1 ) ;\n if ( rc < 0 ) return - 1 ;\n if ( rc > 0 ) update_active = true ;\n }\n }\n if ( Context && Context -> magic == MUTT_NNTP ) {\n buf [ 0 ] = '\\0' ;\n if ( nntp_query ( ( struct NntpData * ) Context -> data , buf , sizeof ( buf ) ) < 0 ) return - 1 ;\n }\n }\n else if ( nserv -> newgroups_time ) return 0 ;\n mutt_message ( msg ) ;\n if ( nntp_date ( nserv , & now ) < 0 ) return - 1 ;\n nntp_data . nserv = nserv ;\n if ( Context && Context -> magic == MUTT_NNTP ) nntp_data . group = ( ( struct NntpData * ) Context -> data ) -> group ;\n else nntp_data . group = NULL ;\n i = nserv -> groups_num ;\n tm = gmtime ( & nserv -> newgroups_time ) ;\n snprintf ( buf , sizeof ( buf ) , \"NEWGROUPS %02d%02d%02d %02d%02d%02d GMT\\r\\n\" , tm -> tm_year % 100 , tm -> tm_mon + 1 , tm -> tm_mday , tm -> tm_hour , tm -> tm_min , tm -> tm_sec ) ;\n rc = nntp_fetch_lines ( & nntp_data , buf , sizeof ( buf ) , msg , nntp_add_group , nserv ) ;\n if ( rc ) {\n if ( rc > 0 ) {\n mutt_error ( \"NEWGROUPS: %s\" , buf ) ;\n }\n return - 1 ;\n }\n rc = 0 ;\n if ( nserv -> groups_num != i ) {\n int groups_num = i ;\n nserv -> newgroups_time = now ;\n for ( ;\n i < nserv -> groups_num ;\n i ++ ) {\n struct NntpData * data = nserv -> groups_list [ i ] ;\n data -> new = true ;\n }\n if ( NntpLoadDescription ) {\n unsigned int count = 0 ;\n struct Progress progress ;\n mutt_progress_init ( & progress , _ ( \"Loading descriptions...\" ) , MUTT_PROGRESS_MSG , ReadInc , nserv -> groups_num - i ) ;\n for ( i = groups_num ;\n i < nserv -> groups_num ;\n i ++ ) {\n struct NntpData * data = nserv -> groups_list [ i ] ;\n if ( get_description ( data , NULL , NULL ) < 0 ) return - 1 ;\n mutt_progress_update ( & progress , ++ count , - 1 ) ;\n }\n }\n update_active = true ;\n rc = 1 ;\n }\n if ( update_active ) nntp_active_save_cache ( nserv ) ;\n mutt_clear_error ( ) ;\n return rc ;\n }", "idx": 22307}
{"hash": 5210559217603684076, "project": "chrome", "size": 41, "label": 0, "functionSource": "static UBool ucnv_outputOverflowFromUnicode ( UConverter * cnv , char * * target , const char * targetLimit , int32_t * * pOffsets , UErrorCode * err ) {\n int32_t * offsets ;\n char * overflow , * t ;\n int32_t i , length ;\n t = * target ;\n if ( pOffsets != NULL ) {\n offsets = * pOffsets ;\n }\n else {\n offsets = NULL ;\n }\n overflow = ( char * ) cnv -> charErrorBuffer ;\n length = cnv -> charErrorBufferLength ;\n i = 0 ;\n while ( i < length ) {\n if ( t == targetLimit ) {\n int32_t j = 0 ;\n do {\n overflow [ j ++ ] = overflow [ i ++ ] ;\n }\n while ( i < length ) ;\n cnv -> charErrorBufferLength = ( int8_t ) j ;\n * target = t ;\n if ( offsets != NULL ) {\n * pOffsets = offsets ;\n }\n * err = U_BUFFER_OVERFLOW_ERROR ;\n return TRUE ;\n }\n * t ++ = overflow [ i ++ ] ;\n if ( offsets != NULL ) {\n * offsets ++ = - 1 ;\n }\n }\n cnv -> charErrorBufferLength = 0 ;\n * target = t ;\n if ( offsets != NULL ) {\n * pOffsets = offsets ;\n }\n return FALSE ;\n }", "idx": 22308}
{"hash": -6552851419396579257, "project": "debian", "size": 13, "label": 0, "functionSource": "static int SpoolssGetPrinter_q ( tvbuff_t * tvb , int offset , packet_info * pinfo , proto_tree * tree , dcerpc_info * di , guint8 * drep _U_ ) {\n dcerpc_call_value * dcv = ( dcerpc_call_value * ) di -> call_data ;\n guint32 level ;\n offset = dissect_nt_policy_hnd ( tvb , offset , pinfo , tree , di , drep , hf_hnd , NULL , NULL , FALSE , FALSE ) ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , tree , di , drep , hf_level , & level ) ;\n if ( ! pinfo -> fd -> flags . visited ) {\n dcv -> se_data = GINT_TO_POINTER ( ( int ) level ) ;\n }\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \", level %d\" , level ) ;\n offset = dissect_spoolss_buffer ( tvb , offset , pinfo , tree , di , drep , NULL ) ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , tree , di , drep , hf_offered , NULL ) ;\n return offset ;\n }", "idx": 22309}
{"hash": 8445816931248660591, "project": "debian", "size": 20, "label": 0, "functionSource": "zend_object_iterator * spl_dllist_get_iterator ( zend_class_entry * ce , zval * object , int by_ref TSRMLS_DC ) {\n spl_dllist_it * iterator ;\n spl_dllist_object * dllist_object = ( spl_dllist_object * ) zend_object_store_get_object ( object TSRMLS_CC ) ;\n if ( by_ref ) {\n zend_throw_exception ( spl_ce_RuntimeException , \"An iterator cannot be used with foreach by reference\" , 0 TSRMLS_CC ) ;\n return NULL ;\n }\n Z_ADDREF_P ( object ) ;\n iterator = emalloc ( sizeof ( spl_dllist_it ) ) ;\n iterator -> intern . it . data = ( void * ) object ;\n iterator -> intern . it . funcs = & spl_dllist_it_funcs ;\n iterator -> intern . ce = ce ;\n iterator -> intern . value = NULL ;\n iterator -> traverse_position = dllist_object -> traverse_position ;\n iterator -> traverse_pointer = dllist_object -> traverse_pointer ;\n iterator -> flags = dllist_object -> flags & SPL_DLLIST_IT_MASK ;\n iterator -> object = dllist_object ;\n SPL_LLIST_CHECK_ADDREF ( iterator -> traverse_pointer ) ;\n return ( zend_object_iterator * ) iterator ;\n }", "idx": 22310}
{"hash": -4558261210024070448, "project": "chrome", "size": 8, "label": 0, "functionSource": "static xmlLinkPtr xmlListHigherSearch ( xmlListPtr l , void * data ) {\n xmlLinkPtr lk ;\n if ( l == NULL ) return ( NULL ) ;\n for ( lk = l -> sentinel -> prev ;\n lk != l -> sentinel && l -> linkCompare ( lk -> data , data ) > 0 ;\n lk = lk -> prev ) ;\n return lk ;\n }", "idx": 22311}
{"hash": 5750382823403258531, "project": "debian", "size": 29, "label": 1, "functionSource": "static int cinaudio_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n AVFrame * frame = data ;\n const uint8_t * buf = avpkt -> data ;\n CinAudioContext * cin = avctx -> priv_data ;\n const uint8_t * buf_end = buf + avpkt -> size ;\n int16_t * samples ;\n int delta , ret ;\n frame -> nb_samples = avpkt -> size - cin -> initial_decode_frame ;\n if ( ( ret = ff_get_buffer ( avctx , frame ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n samples = ( int16_t * ) frame -> data [ 0 ] ;\n delta = cin -> delta ;\n if ( cin -> initial_decode_frame ) {\n cin -> initial_decode_frame = 0 ;\n delta = sign_extend ( AV_RL16 ( buf ) , 16 ) ;\n buf += 2 ;\n * samples ++ = delta ;\n }\n while ( buf < buf_end ) {\n delta += cinaudio_delta16_table [ * buf ++ ] ;\n delta = av_clip_int16 ( delta ) ;\n * samples ++ = delta ;\n }\n cin -> delta = delta ;\n * got_frame_ptr = 1 ;\n return avpkt -> size ;\n }", "idx": 22312}
{"hash": 1760449185745615462, "project": "debian", "size": 4, "label": 0, "functionSource": "char * TSMatcherLineValue ( TSMatcherLine ml , int element ) {\n sdk_assert ( sdk_sanity_check_null_ptr ( ( void * ) ml ) == TS_SUCCESS ) ;\n return ( ( ( matcher_line * ) ml ) -> line ) [ 1 ] [ element ] ;\n }", "idx": 22313}
{"hash": -3231032419759162058, "project": "debian", "size": 7, "label": 0, "functionSource": "static inline int16_t inverse_quant ( G726Context * c , int i ) {\n int dql , dex , dqt ;\n dql = c -> tbls . iquant [ i ] + ( c -> y >> 2 ) ;\n dex = ( dql >> 7 ) & 0xf ;\n dqt = ( 1 << 7 ) + ( dql & 0x7f ) ;\n return ( dql < 0 ) ? 0 : ( ( dqt << dex ) >> 7 ) ;\n }", "idx": 22314}
{"hash": -8933711118846965366, "project": "debian", "size": 13, "label": 0, "functionSource": "static int cirrus_vga_read_sr ( CirrusVGAState * s ) {\n switch ( s -> vga . sr_index ) {\n case 0x00 : case 0x01 : case 0x02 : case 0x03 : case 0x04 : return s -> vga . sr [ s -> vga . sr_index ] ;\n case 0x06 : return s -> vga . sr [ s -> vga . sr_index ] ;\n case 0x10 : case 0x30 : case 0x50 : case 0x70 : case 0x90 : case 0xb0 : case 0xd0 : case 0xf0 : return s -> vga . sr [ 0x10 ] ;\n case 0x11 : case 0x31 : case 0x51 : case 0x71 : case 0x91 : case 0xb1 : case 0xd1 : case 0xf1 : return s -> vga . sr [ 0x11 ] ;\n case 0x05 : case 0x07 : case 0x08 : case 0x09 : case 0x0a : case 0x0b : case 0x0c : case 0x0d : case 0x0e : case 0x0f : case 0x12 : case 0x13 : case 0x14 : case 0x15 : case 0x16 : case 0x17 : case 0x18 : case 0x19 : case 0x1a : case 0x1b : case 0x1c : case 0x1d : case 0x1e : case 0x1f : # ifdef DEBUG_CIRRUS printf ( \"cirrus: handled inport sr_index %02x\\n\" , s -> vga . sr_index ) ;\n # endif return s -> vga . sr [ s -> vga . sr_index ] ;\n default : # ifdef DEBUG_CIRRUS printf ( \"cirrus: inport sr_index %02x\\n\" , s -> vga . sr_index ) ;\n # endif return 0xff ;\n break ;\n }\n }", "idx": 22315}
{"hash": 2419147764757351618, "project": "debian", "size": 15, "label": 1, "functionSource": "static int s390_virtio_console_init ( VirtIOS390Device * dev ) {\n VirtIOS390Bus * bus ;\n VirtIODevice * vdev ;\n int r ;\n bus = DO_UPCAST ( VirtIOS390Bus , bus , dev -> qdev . parent_bus ) ;\n vdev = virtio_console_init ( ( DeviceState * ) dev ) ;\n if ( ! vdev ) {\n return - 1 ;\n }\n r = s390_virtio_device_init ( dev , vdev ) ;\n if ( ! r ) {\n bus -> console = dev ;\n }\n return r ;\n }", "idx": 22316}
{"hash": -8815658870890288443, "project": "chrome", "size": 4, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( CrossOriginXHR , BackgroundPage ) {\n ASSERT_TRUE ( StartFTPServer ( base : : FilePath ( kFtpDocRoot ) ) ) ;\n ASSERT_TRUE ( RunExtensionTest ( \"cross_origin_xhr/background_page\" ) ) << message_ ;\n }", "idx": 22317}
{"hash": 1760449185745615462, "project": "debian", "size": 3, "label": 0, "functionSource": "TSReturnCode TSUrlDestroy ( TSMBuffer , TSMLoc ) {\n return TS_SUCCESS ;\n }", "idx": 22318}
{"hash": 2315393806700093389, "project": "chrome", "size": 3, "label": 0, "functionSource": "static int get_filter_offset ( const int16_t * f , const InterpKernel * base ) {\n return ( int ) ( ( const InterpKernel * ) ( intptr_t ) f - base ) ;\n }", "idx": 22319}
{"hash": 5357882892791796049, "project": "debian", "size": 20, "label": 0, "functionSource": "void e1000e_core_set_link_status ( E1000ECore * core ) {\n NetClientState * nc = qemu_get_queue ( core -> owner_nic ) ;\n uint32_t old_status = core -> mac [ STATUS ] ;\n trace_e1000e_link_status_changed ( nc -> link_down ? false : true ) ;\n if ( nc -> link_down ) {\n e1000x_update_regs_on_link_down ( core -> mac , core -> phy [ 0 ] ) ;\n }\n else {\n if ( e1000e_have_autoneg ( core ) && ! ( core -> phy [ 0 ] [ PHY_STATUS ] & MII_SR_AUTONEG_COMPLETE ) ) {\n e1000x_restart_autoneg ( core -> mac , core -> phy [ 0 ] , core -> autoneg_timer ) ;\n }\n else {\n e1000x_update_regs_on_link_up ( core -> mac , core -> phy [ 0 ] ) ;\n e1000e_start_recv ( core ) ;\n }\n }\n if ( core -> mac [ STATUS ] != old_status ) {\n e1000e_set_interrupt_cause ( core , E1000_ICR_LSC ) ;\n }\n }", "idx": 22320}
{"hash": 4839943401171415484, "project": "chrome", "size": 42, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_P ( BrowserCloseManagerBrowserTest , MAYBE_AddBeforeUnloadDuringClosing ) {\n if ( GetParam ( ) ) return ;\n ASSERT_NO_FATAL_FAILURE ( ui_test_utils : : NavigateToURL ( browser ( ) , embedded_test_server ( ) -> GetURL ( \"/title1.html\" ) ) ) ;\n ui_test_utils : : NavigateToURLWithDisposition ( browser ( ) , embedded_test_server ( ) -> GetURL ( \"/beforeunload.html\" ) , WindowOpenDisposition : : NEW_WINDOW , ui_test_utils : : BROWSER_TEST_WAIT_FOR_BROWSER ) ;\n EXPECT_EQ ( 2u , BrowserList : : GetInstance ( ) -> size ( ) ) ;\n auto * browser2 = BrowserList : : GetInstance ( ) -> get ( 0 ) != browser ( ) ? BrowserList : : GetInstance ( ) -> get ( 0 ) : BrowserList : : GetInstance ( ) -> get ( 1 ) ;\n content : : WaitForLoadStop ( browser2 -> tab_strip_model ( ) -> GetWebContentsAt ( 0 ) ) ;\n EXPECT_TRUE ( browser2 -> tab_strip_model ( ) -> GetWebContentsAt ( 0 ) -> NeedToFireBeforeUnload ( ) ) ;\n ui_test_utils : : NavigateToURLWithDisposition ( browser2 , embedded_test_server ( ) -> GetURL ( \"/title2.html\" ) , WindowOpenDisposition : : NEW_FOREGROUND_TAB , ui_test_utils : : BROWSER_TEST_WAIT_FOR_NAVIGATION ) ;\n content : : WaitForLoadStop ( browser2 -> tab_strip_model ( ) -> GetWebContentsAt ( 1 ) ) ;\n EXPECT_FALSE ( browser2 -> tab_strip_model ( ) -> GetWebContentsAt ( 1 ) -> NeedToFireBeforeUnload ( ) ) ;\n EXPECT_EQ ( 2 , browser2 -> tab_strip_model ( ) -> count ( ) ) ;\n PrepareForDialog ( browser2 ) ;\n TabRestoreServiceChangesObserver restore_observer ( browser2 -> profile ( ) ) ;\n content : : WindowedNotificationObserver observer ( chrome : : NOTIFICATION_BROWSER_CLOSED , content : : NotificationService : : AllSources ( ) ) ;\n chrome : : CloseWindow ( browser2 ) ;\n content : : RunAllPendingInMessageLoop ( ) ;\n EXPECT_EQ ( 2u , BrowserList : : GetInstance ( ) -> size ( ) ) ;\n ASSERT_TRUE ( content : : ExecuteScript ( browser2 -> tab_strip_model ( ) -> GetWebContentsAt ( 1 ) -> GetRenderViewHost ( ) , \"window.addEventListener('beforeunload', \" \"function(event) {\n event.returnValue = 'Foo';\n }\n);\n\" ) ) ;\n EXPECT_TRUE ( browser2 -> tab_strip_model ( ) -> GetWebContentsAt ( 1 ) -> NeedToFireBeforeUnload ( ) ) ;\n ASSERT_NO_FATAL_FAILURE ( AcceptClose ( ) ) ;\n content : : RunAllPendingInMessageLoop ( ) ;\n EXPECT_EQ ( 2u , BrowserList : : GetInstance ( ) -> size ( ) ) ;\n EXPECT_EQ ( 2 , browser2 -> tab_strip_model ( ) -> count ( ) ) ;\n ASSERT_NO_FATAL_FAILURE ( AcceptClose ( ) ) ;\n observer . Wait ( ) ;\n EXPECT_EQ ( 1u , BrowserList : : GetInstance ( ) -> size ( ) ) ;\n EXPECT_EQ ( browser ( ) , BrowserList : : GetInstance ( ) -> get ( 0 ) ) ;\n EXPECT_EQ ( 1u , restore_observer . changes_count ( ) ) ;\n content : : WindowedNotificationObserver open_window_observer ( chrome : : NOTIFICATION_BROWSER_OPENED , content : : NotificationService : : AllSources ( ) ) ;\n chrome : : OpenWindowWithRestoredTabs ( browser ( ) -> profile ( ) ) ;\n open_window_observer . Wait ( ) ;\n EXPECT_EQ ( 2u , BrowserList : : GetInstance ( ) -> size ( ) ) ;\n browser2 = BrowserList : : GetInstance ( ) -> get ( 0 ) != browser ( ) ? BrowserList : : GetInstance ( ) -> get ( 0 ) : BrowserList : : GetInstance ( ) -> get ( 1 ) ;\n EXPECT_EQ ( 2 , browser2 -> tab_strip_model ( ) -> count ( ) ) ;\n EXPECT_EQ ( embedded_test_server ( ) -> GetURL ( \"/beforeunload.html\" ) , browser2 -> tab_strip_model ( ) -> GetWebContentsAt ( 0 ) -> GetURL ( ) ) ;\n EXPECT_EQ ( embedded_test_server ( ) -> GetURL ( \"/title2.html\" ) , browser2 -> tab_strip_model ( ) -> GetWebContentsAt ( 1 ) -> GetURL ( ) ) ;\n }", "idx": 22321}
{"hash": -8620097311326519087, "project": "chrome", "size": 3, "label": 0, "functionSource": "void append_salt_to_key ( uint8_t * key , unsigned int bytes_in_key , uint8_t * salt , unsigned int bytes_in_salt ) {\n memcpy ( key + bytes_in_key , salt , bytes_in_salt ) ;\n }", "idx": 22322}
{"hash": 5400542917484463750, "project": "chrome", "size": 5, "label": 0, "functionSource": "const char * vpx_svc_get_message ( const SvcContext * svc_ctx ) {\n const SvcInternal * const si = get_const_svc_internal ( svc_ctx ) ;\n if ( svc_ctx == NULL || si == NULL ) return NULL ;\n return si -> message_buffer ;\n }", "idx": 22323}
{"hash": 4489017523191997023, "project": "debian", "size": 15, "label": 0, "functionSource": "int dissect_h225_RasMessage ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 294 \"./asn1/h225/h225.cnf\" gint32 rasmessage_value ;\n h225_packet_info * h225_pi ;\n call_id_guid = NULL ;\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_RasMessage , RasMessage_choice , & rasmessage_value ) ;\n col_add_fstr ( actx -> pinfo -> cinfo , COL_INFO , \"RAS: %s \" , val_to_str ( rasmessage_value , h225_RasMessage_vals , \"<unknown>\" ) ) ;\n h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;\n if ( h225_pi != NULL ) {\n h225_pi -> msg_tag = rasmessage_value ;\n if ( call_id_guid ) {\n h225_pi -> guid = * call_id_guid ;\n }\n }\n return offset ;\n }", "idx": 22324}
{"hash": 6871081691104220210, "project": "debian", "size": 69, "label": 0, "functionSource": "static void fill_picture_parameters ( struct dxva_context * ctx , const H264Context * h , DXVA_PicParams_H264 * pp ) {\n const Picture * current_picture = h -> cur_pic_ptr ;\n int i , j ;\n memset ( pp , 0 , sizeof ( * pp ) ) ;\n fill_picture_entry ( & pp -> CurrPic , ff_dxva2_get_surface_index ( ctx , current_picture ) , h -> picture_structure == PICT_BOTTOM_FIELD ) ;\n pp -> UsedForReferenceFlags = 0 ;\n pp -> NonExistingFrameFlags = 0 ;\n for ( i = 0 , j = 0 ;\n i < FF_ARRAY_ELEMS ( pp -> RefFrameList ) ;\n i ++ ) {\n const Picture * r ;\n if ( j < h -> short_ref_count ) {\n r = h -> short_ref [ j ++ ] ;\n }\n else {\n r = NULL ;\n while ( ! r && j < h -> short_ref_count + 16 ) r = h -> long_ref [ j ++ - h -> short_ref_count ] ;\n }\n if ( r ) {\n fill_picture_entry ( & pp -> RefFrameList [ i ] , ff_dxva2_get_surface_index ( ctx , r ) , r -> long_ref != 0 ) ;\n if ( ( r -> reference & PICT_TOP_FIELD ) && r -> field_poc [ 0 ] != INT_MAX ) pp -> FieldOrderCntList [ i ] [ 0 ] = r -> field_poc [ 0 ] ;\n if ( ( r -> reference & PICT_BOTTOM_FIELD ) && r -> field_poc [ 1 ] != INT_MAX ) pp -> FieldOrderCntList [ i ] [ 1 ] = r -> field_poc [ 1 ] ;\n pp -> FrameNumList [ i ] = r -> long_ref ? r -> pic_id : r -> frame_num ;\n if ( r -> reference & PICT_TOP_FIELD ) pp -> UsedForReferenceFlags |= 1 << ( 2 * i + 0 ) ;\n if ( r -> reference & PICT_BOTTOM_FIELD ) pp -> UsedForReferenceFlags |= 1 << ( 2 * i + 1 ) ;\n }\n else {\n pp -> RefFrameList [ i ] . bPicEntry = 0xff ;\n pp -> FieldOrderCntList [ i ] [ 0 ] = 0 ;\n pp -> FieldOrderCntList [ i ] [ 1 ] = 0 ;\n pp -> FrameNumList [ i ] = 0 ;\n }\n }\n pp -> wFrameWidthInMbsMinus1 = h -> mb_width - 1 ;\n pp -> wFrameHeightInMbsMinus1 = h -> mb_height - 1 ;\n pp -> num_ref_frames = h -> sps . ref_frame_count ;\n pp -> wBitFields = ( ( h -> picture_structure != PICT_FRAME ) << 0 ) | ( ( h -> sps . mb_aff && ( h -> picture_structure == PICT_FRAME ) ) << 1 ) | ( h -> sps . residual_color_transform_flag << 2 ) | ( 0 << 3 ) | ( h -> sps . chroma_format_idc << 4 ) | ( ( h -> nal_ref_idc != 0 ) << 6 ) | ( h -> pps . constrained_intra_pred << 7 ) | ( h -> pps . weighted_pred << 8 ) | ( h -> pps . weighted_bipred_idc << 9 ) | ( 1 << 11 ) | ( h -> sps . frame_mbs_only_flag << 12 ) | ( h -> pps . transform_8x8_mode << 13 ) | ( ( h -> sps . level_idc >= 31 ) << 14 ) | ( 1 << 15 ) ;\n pp -> bit_depth_luma_minus8 = h -> sps . bit_depth_luma - 8 ;\n pp -> bit_depth_chroma_minus8 = h -> sps . bit_depth_chroma - 8 ;\n if ( ctx -> workaround & FF_DXVA2_WORKAROUND_SCALING_LIST_ZIGZAG ) pp -> Reserved16Bits = 0 ;\n else pp -> Reserved16Bits = 3 ;\n pp -> StatusReportFeedbackNumber = 1 + ctx -> report_id ++ ;\n pp -> CurrFieldOrderCnt [ 0 ] = 0 ;\n if ( ( h -> picture_structure & PICT_TOP_FIELD ) && current_picture -> field_poc [ 0 ] != INT_MAX ) pp -> CurrFieldOrderCnt [ 0 ] = current_picture -> field_poc [ 0 ] ;\n pp -> CurrFieldOrderCnt [ 1 ] = 0 ;\n if ( ( h -> picture_structure & PICT_BOTTOM_FIELD ) && current_picture -> field_poc [ 1 ] != INT_MAX ) pp -> CurrFieldOrderCnt [ 1 ] = current_picture -> field_poc [ 1 ] ;\n pp -> pic_init_qs_minus26 = h -> pps . init_qs - 26 ;\n pp -> chroma_qp_index_offset = h -> pps . chroma_qp_index_offset [ 0 ] ;\n pp -> second_chroma_qp_index_offset = h -> pps . chroma_qp_index_offset [ 1 ] ;\n pp -> ContinuationFlag = 1 ;\n pp -> pic_init_qp_minus26 = h -> pps . init_qp - 26 ;\n pp -> num_ref_idx_l0_active_minus1 = h -> pps . ref_count [ 0 ] - 1 ;\n pp -> num_ref_idx_l1_active_minus1 = h -> pps . ref_count [ 1 ] - 1 ;\n pp -> Reserved8BitsA = 0 ;\n pp -> frame_num = h -> frame_num ;\n pp -> log2_max_frame_num_minus4 = h -> sps . log2_max_frame_num - 4 ;\n pp -> pic_order_cnt_type = h -> sps . poc_type ;\n if ( h -> sps . poc_type == 0 ) pp -> log2_max_pic_order_cnt_lsb_minus4 = h -> sps . log2_max_poc_lsb - 4 ;\n else if ( h -> sps . poc_type == 1 ) pp -> delta_pic_order_always_zero_flag = h -> sps . delta_pic_order_always_zero_flag ;\n pp -> direct_8x8_inference_flag = h -> sps . direct_8x8_inference_flag ;\n pp -> entropy_coding_mode_flag = h -> pps . cabac ;\n pp -> pic_order_present_flag = h -> pps . pic_order_present ;\n pp -> num_slice_groups_minus1 = h -> pps . slice_group_count - 1 ;\n pp -> slice_group_map_type = h -> pps . mb_slice_group_map_type ;\n pp -> deblocking_filter_control_present_flag = h -> pps . deblocking_filter_parameters_present ;\n pp -> redundant_pic_cnt_present_flag = h -> pps . redundant_pic_cnt_present ;\n pp -> Reserved8BitsB = 0 ;\n pp -> slice_group_change_rate_minus1 = 0 ;\n }", "idx": 22325}
{"hash": 6600620671673714486, "project": "debian", "size": 4, "label": 0, "functionSource": "static void i_enable_free ( gs_memory_t * mem , bool enable ) {\n if ( enable ) mem -> procs . free_object = i_free_object , mem -> procs . free_string = i_free_string ;\n else mem -> procs . free_object = gs_ignore_free_object , mem -> procs . free_string = gs_ignore_free_string ;\n }", "idx": 22326}
{"hash": -2222758297961835509, "project": "debian", "size": 10, "label": 0, "functionSource": "static int ivi_dec_tile_data_size ( GetBitContext * gb ) {\n int len ;\n len = 0 ;\n if ( get_bits1 ( gb ) ) {\n len = get_bits ( gb , 8 ) ;\n if ( len == 255 ) len = get_bits_long ( gb , 24 ) ;\n }\n align_get_bits ( gb ) ;\n return len ;\n }", "idx": 22327}
{"hash": 2578089348587614328, "project": "debian", "size": 3, "label": 0, "functionSource": "int i2d_DSAPrivateKey_fp ( FILE * fp , DSA * dsa ) {\n return ASN1_i2d_fp_of_const ( DSA , i2d_DSAPrivateKey , fp , dsa ) ;\n }", "idx": 22328}
{"hash": 1760449185745615462, "project": "debian", "size": 4, "label": 0, "functionSource": "int TSHttpTxnIsInternal ( TSHttpTxn txnp ) {\n sdk_assert ( sdk_sanity_check_txn ( txnp ) == TS_SUCCESS ) ;\n return TSHttpSsnIsInternal ( TSHttpTxnSsnGet ( txnp ) ) ;\n }", "idx": 22329}
{"hash": -5511323081862746166, "project": "debian", "size": 23, "label": 0, "functionSource": "static gboolean k12_dump_finish ( wtap_dumper * wdh , int * err ) {\n k12_dump_t * k12 = ( k12_dump_t * ) wdh -> priv ;\n union {\n guint8 b [ sizeof ( guint32 ) ] ;\n guint32 u ;\n }\n d ;\n if ( ! wtap_dump_file_write ( wdh , k12_eof , 2 , err ) ) return FALSE ;\n k12 -> file_len += 2 ;\n if ( wtap_dump_file_seek ( wdh , K12_FILE_HDR_FILE_SIZE , SEEK_SET , err ) == - 1 ) return FALSE ;\n d . u = g_htonl ( k12 -> file_len ) ;\n if ( ! wtap_dump_file_write ( wdh , d . b , 4 , err ) ) return FALSE ;\n if ( wtap_dump_file_seek ( wdh , K12_FILE_HDR_PAGE_SIZE , SEEK_SET , err ) == - 1 ) return FALSE ;\n d . u = g_htonl ( 8192 ) ;\n if ( ! wtap_dump_file_write ( wdh , d . b , 4 , err ) ) return FALSE ;\n if ( wtap_dump_file_seek ( wdh , K12_FILE_HDR_RECORD_COUNT_1 , SEEK_SET , err ) == - 1 ) return FALSE ;\n d . u = g_htonl ( k12 -> num_of_records ) ;\n if ( ! wtap_dump_file_write ( wdh , d . b , 4 , err ) ) return FALSE ;\n if ( wtap_dump_file_seek ( wdh , K12_FILE_HDR_RECORD_COUNT_2 , SEEK_SET , err ) == - 1 ) return FALSE ;\n d . u = g_htonl ( k12 -> num_of_records ) ;\n if ( ! wtap_dump_file_write ( wdh , d . b , 4 , err ) ) return FALSE ;\n return TRUE ;\n }", "idx": 22330}
{"hash": -1983921383858884161, "project": "debian", "size": 63, "label": 0, "functionSource": "static int ipvideo_decode_block_opcode_0x8_16 ( IpvideoContext * s , AVFrame * frame ) {\n int x , y ;\n uint16_t P [ 4 ] ;\n unsigned int flags = 0 ;\n uint16_t * pixel_ptr = ( uint16_t * ) s -> pixel_ptr ;\n P [ 0 ] = bytestream2_get_le16 ( & s -> stream_ptr ) ;\n P [ 1 ] = bytestream2_get_le16 ( & s -> stream_ptr ) ;\n if ( ! ( P [ 0 ] & 0x8000 ) ) {\n for ( y = 0 ;\n y < 16 ;\n y ++ ) {\n if ( ! ( y & 3 ) ) {\n if ( y ) {\n P [ 0 ] = bytestream2_get_le16 ( & s -> stream_ptr ) ;\n P [ 1 ] = bytestream2_get_le16 ( & s -> stream_ptr ) ;\n }\n flags = bytestream2_get_le16 ( & s -> stream_ptr ) ;\n }\n for ( x = 0 ;\n x < 4 ;\n x ++ , flags >>= 1 ) * pixel_ptr ++ = P [ flags & 1 ] ;\n pixel_ptr += s -> stride - 4 ;\n if ( y == 7 ) pixel_ptr -= 8 * s -> stride - 4 ;\n }\n }\n else {\n flags = bytestream2_get_le32 ( & s -> stream_ptr ) ;\n P [ 2 ] = bytestream2_get_le16 ( & s -> stream_ptr ) ;\n P [ 3 ] = bytestream2_get_le16 ( & s -> stream_ptr ) ;\n if ( ! ( P [ 2 ] & 0x8000 ) ) {\n for ( y = 0 ;\n y < 16 ;\n y ++ ) {\n for ( x = 0 ;\n x < 4 ;\n x ++ , flags >>= 1 ) * pixel_ptr ++ = P [ flags & 1 ] ;\n pixel_ptr += s -> stride - 4 ;\n if ( y == 7 ) {\n pixel_ptr -= 8 * s -> stride - 4 ;\n P [ 0 ] = P [ 2 ] ;\n P [ 1 ] = P [ 3 ] ;\n flags = bytestream2_get_le32 ( & s -> stream_ptr ) ;\n }\n }\n }\n else {\n for ( y = 0 ;\n y < 8 ;\n y ++ ) {\n if ( y == 4 ) {\n P [ 0 ] = P [ 2 ] ;\n P [ 1 ] = P [ 3 ] ;\n flags = bytestream2_get_le32 ( & s -> stream_ptr ) ;\n }\n for ( x = 0 ;\n x < 8 ;\n x ++ , flags >>= 1 ) * pixel_ptr ++ = P [ flags & 1 ] ;\n pixel_ptr += s -> line_inc ;\n }\n }\n }\n return 0 ;\n }", "idx": 22331}
{"hash": -2323311514228246061, "project": "chrome", "size": 69, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( DownloadExtensionTest , DownloadExtensionTest_OnDeterminingFilename_Overwrite ) {\n GoOnTheRecord ( ) ;\n LoadExtension ( \"downloads_split\" ) ;\n AddFilenameDeterminer ( ) ;\n ASSERT_TRUE ( StartEmbeddedTestServer ( ) ) ;\n std : : string download_url = embedded_test_server ( ) -> GetURL ( \"/slow?0\" ) . spec ( ) ;\n std : : unique_ptr < base : : Value > result ( RunFunctionAndReturnResult ( new DownloadsDownloadFunction ( ) , base : : StringPrintf ( \"[{\n\\\"url\\\": \\\"%s\\\"}\n]\" , download_url . c_str ( ) ) ) ) ;\n ASSERT_TRUE ( result . get ( ) ) ;\n int result_id = - 1 ;\n ASSERT_TRUE ( result -> GetAsInteger ( & result_id ) ) ;\n DownloadItem * item = GetCurrentManager ( ) -> GetDownload ( result_id ) ;\n ASSERT_TRUE ( item ) ;\n ScopedCancellingItem canceller ( item ) ;\n ASSERT_EQ ( download_url , item -> GetOriginalUrl ( ) . spec ( ) ) ;\n ASSERT_TRUE ( WaitFor ( downloads : : OnCreated : : kEventName , base : : StringPrintf ( \"[{\n\\\"danger\\\": \\\"safe\\\",\" \" \\\"incognito\\\": false,\" \" \\\"id\\\": %d,\" \" \\\"mime\\\": \\\"text/plain\\\",\" \" \\\"paused\\\": false,\" \" \\\"url\\\": \\\"%s\\\"}\n]\" , result_id , download_url . c_str ( ) ) ) ) ;\n ASSERT_TRUE ( WaitFor ( downloads : : OnDeterminingFilename : : kEventName , base : : StringPrintf ( \"[{\n\\\"id\\\": %d,\" \" \\\"filename\\\":\\\"slow.txt\\\"}\n]\" , result_id ) ) ) ;\n ASSERT_TRUE ( item -> GetTargetFilePath ( ) . empty ( ) ) ;\n ASSERT_EQ ( DownloadItem : : IN_PROGRESS , item -> GetState ( ) ) ;\n std : : string error ;\n ASSERT_TRUE ( ExtensionDownloadsEventRouter : : DetermineFilename ( browser ( ) -> profile ( ) , false , GetExtensionId ( ) , result_id , base : : FilePath ( ) , downloads : : FILENAME_CONFLICT_ACTION_UNIQUIFY , & error ) ) ;\n EXPECT_EQ ( \"\" , error ) ;\n ASSERT_TRUE ( WaitFor ( downloads : : OnChanged : : kEventName , base : : StringPrintf ( \"[{\n\\\"id\\\": %d,\" \" \\\"filename\\\": {\n\" \" \\\"previous\\\": \\\"\\\",\" \" \\\"current\\\": \\\"%s\\\"}\n}\n]\" , result_id , GetFilename ( \"slow.txt\" ) . c_str ( ) ) ) ) ;\n ASSERT_TRUE ( WaitFor ( downloads : : OnChanged : : kEventName , base : : StringPrintf ( \"[{\n\\\"id\\\": %d,\" \" \\\"state\\\": {\n\" \" \\\"previous\\\": \\\"in_progress\\\",\" \" \\\"current\\\": \\\"complete\\\"}\n}\n]\" , result_id ) ) ) ;\n result . reset ( RunFunctionAndReturnResult ( new DownloadsDownloadFunction ( ) , base : : StringPrintf ( \"[{\n\\\"url\\\": \\\"%s\\\"}\n]\" , download_url . c_str ( ) ) ) ) ;\n ASSERT_TRUE ( result . get ( ) ) ;\n result_id = - 1 ;\n ASSERT_TRUE ( result -> GetAsInteger ( & result_id ) ) ;\n item = GetCurrentManager ( ) -> GetDownload ( result_id ) ;\n ASSERT_TRUE ( item ) ;\n ScopedCancellingItem canceller2 ( item ) ;\n ASSERT_EQ ( download_url , item -> GetOriginalUrl ( ) . spec ( ) ) ;\n ASSERT_TRUE ( WaitFor ( downloads : : OnCreated : : kEventName , base : : StringPrintf ( \"[{\n\\\"danger\\\": \\\"safe\\\",\" \" \\\"incognito\\\": false,\" \" \\\"id\\\": %d,\" \" \\\"mime\\\": \\\"text/plain\\\",\" \" \\\"paused\\\": false,\" \" \\\"url\\\": \\\"%s\\\"}\n]\" , result_id , download_url . c_str ( ) ) ) ) ;\n ASSERT_TRUE ( WaitFor ( downloads : : OnDeterminingFilename : : kEventName , base : : StringPrintf ( \"[{\n\\\"id\\\": %d,\" \" \\\"filename\\\":\\\"slow.txt\\\"}\n]\" , result_id ) ) ) ;\n ASSERT_TRUE ( item -> GetTargetFilePath ( ) . empty ( ) ) ;\n ASSERT_EQ ( DownloadItem : : IN_PROGRESS , item -> GetState ( ) ) ;\n error = \"\" ;\n ASSERT_TRUE ( ExtensionDownloadsEventRouter : : DetermineFilename ( browser ( ) -> profile ( ) , false , GetExtensionId ( ) , result_id , base : : FilePath ( ) , downloads : : FILENAME_CONFLICT_ACTION_OVERWRITE , & error ) ) ;\n EXPECT_EQ ( \"\" , error ) ;\n ASSERT_TRUE ( WaitFor ( downloads : : OnChanged : : kEventName , base : : StringPrintf ( \"[{\n\\\"id\\\": %d,\" \" \\\"filename\\\": {\n\" \" \\\"previous\\\": \\\"\\\",\" \" \\\"current\\\": \\\"%s\\\"}\n}\n]\" , result_id , GetFilename ( \"slow.txt\" ) . c_str ( ) ) ) ) ;\n ASSERT_TRUE ( WaitFor ( downloads : : OnChanged : : kEventName , base : : StringPrintf ( \"[{\n\\\"id\\\": %d,\" \" \\\"state\\\": {\n\" \" \\\"previous\\\": \\\"in_progress\\\",\" \" \\\"current\\\": \\\"complete\\\"}\n}\n]\" , result_id ) ) ) ;\n }", "idx": 22332}
{"hash": 2634052037515388009, "project": "debian", "size": 18, "label": 0, "functionSource": "int archive_read_support_format_all ( struct archive * a ) {\n archive_check_magic ( a , ARCHIVE_READ_MAGIC , ARCHIVE_STATE_NEW , \"archive_read_support_format_all\" ) ;\n archive_read_support_format_ar ( a ) ;\n archive_read_support_format_cpio ( a ) ;\n archive_read_support_format_empty ( a ) ;\n archive_read_support_format_lha ( a ) ;\n archive_read_support_format_mtree ( a ) ;\n archive_read_support_format_tar ( a ) ;\n archive_read_support_format_xar ( a ) ;\n archive_read_support_format_warc ( a ) ;\n archive_read_support_format_7zip ( a ) ;\n archive_read_support_format_cab ( a ) ;\n archive_read_support_format_rar ( a ) ;\n archive_read_support_format_iso9660 ( a ) ;\n archive_read_support_format_zip ( a ) ;\n archive_clear_error ( a ) ;\n return ( ARCHIVE_OK ) ;\n }", "idx": 22333}
{"hash": 927123821003322045, "project": "chrome", "size": 11, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( PageLoadMetricsBrowserTest , UseCounterCSSPropertiesInIframes ) {\n ASSERT_TRUE ( embedded_test_server ( ) -> Start ( ) ) ;\n auto waiter = CreatePageLoadMetricsWaiter ( ) ;\n waiter -> AddPageExpectation ( TimingField : : LOAD_EVENT ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , embedded_test_server ( ) -> GetURL ( \"/page_load_metrics/use_counter_features_in_iframes.html\" ) ) ;\n waiter -> Wait ( ) ;\n NavigateToUntrackedUrl ( ) ;\n histogram_tester_ . ExpectBucketCount ( internal : : kCssPropertiesHistogramName , 6 , 1 ) ;\n histogram_tester_ . ExpectBucketCount ( internal : : kCssPropertiesHistogramName , 7 , 1 ) ;\n histogram_tester_ . ExpectBucketCount ( internal : : kCssPropertiesHistogramName , blink : : mojom : : kTotalPagesMeasuredCSSSampleId , 1 ) ;\n }", "idx": 22334}
{"hash": -1929262071302712016, "project": "debian", "size": 5, "label": 0, "functionSource": "static void * Type_LUT16_Dup ( struct _cms_typehandler_struct * self , const void * Ptr , cmsUInt32Number n ) {\n return ( void * ) cmsPipelineDup ( ( cmsPipeline * ) Ptr ) ;\n cmsUNUSED_PARAMETER ( n ) ;\n cmsUNUSED_PARAMETER ( self ) ;\n }", "idx": 22335}
{"hash": -8962831256613787672, "project": "debian", "size": 34, "label": 1, "functionSource": "static gint dissect_ac_if_hdr_body ( tvbuff_t * tvb , gint offset , packet_info * pinfo _U_ , proto_tree * tree , usb_conv_info_t * usb_conv_info ) {\n gint offset_start ;\n guint16 bcdADC ;\n guint8 ver_major ;\n double ver ;\n guint8 if_in_collection , i ;\n audio_conv_info_t * audio_conv_info ;\n offset_start = offset ;\n bcdADC = tvb_get_letohs ( tvb , offset ) ;\n ver_major = USB_AUDIO_BCD44_TO_DEC ( bcdADC >> 8 ) ;\n ver = ver_major + USB_AUDIO_BCD44_TO_DEC ( bcdADC & 0xFF ) / 100.0 ;\n proto_tree_add_double_format_value ( tree , hf_ac_if_hdr_ver , tvb , offset , 2 , ver , \"%2.2f\" , ver ) ;\n audio_conv_info = ( audio_conv_info_t * ) usb_conv_info -> class_data ;\n if ( ! audio_conv_info ) {\n audio_conv_info = wmem_new ( wmem_file_scope ( ) , audio_conv_info_t ) ;\n usb_conv_info -> class_data = audio_conv_info ;\n }\n audio_conv_info -> ver_major = ver_major ;\n offset += 2 ;\n if ( ver_major == 1 ) {\n proto_tree_add_item ( tree , hf_ac_if_hdr_total_len , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n if_in_collection = tvb_get_guint8 ( tvb , offset ) ;\n proto_tree_add_item ( tree , hf_ac_if_hdr_bInCollection , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ;\n offset ++ ;\n for ( i = 0 ;\n i < if_in_collection ;\n i ++ ) {\n proto_tree_add_item ( tree , hf_ac_if_hdr_if_num , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ;\n offset ++ ;\n }\n }\n return offset - offset_start ;\n }", "idx": 22336}
{"hash": 4537091194729139981, "project": "chrome", "size": 13, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( FullscreenControllerInteractiveTest , MAYBE_TestTabExitsMouseLockOnGoBack ) {\n ASSERT_TRUE ( test_server ( ) -> Start ( ) ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , GURL ( \"about:blank\" ) ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , test_server ( ) -> GetURL ( kFullscreenMouseLockHTML ) ) ;\n ASSERT_TRUE ( ui_test_utils : : SendKeyPressAndWait ( browser ( ) , ui : : VKEY_1 , false , false , false , false , chrome : : NOTIFICATION_MOUSE_LOCK_CHANGED , content : : NotificationService : : AllSources ( ) ) ) ;\n ASSERT_TRUE ( IsFullscreenBubbleDisplayed ( ) ) ;\n ASSERT_TRUE ( IsMouseLockPermissionRequested ( ) ) ;\n ASSERT_FALSE ( IsMouseLocked ( ) ) ;\n AcceptCurrentFullscreenOrMouseLockRequest ( ) ;\n ASSERT_TRUE ( IsMouseLocked ( ) ) ;\n GoBack ( ) ;\n ASSERT_FALSE ( IsMouseLocked ( ) ) ;\n }", "idx": 22337}
{"hash": 3935234056444097745, "project": "debian", "size": 21, "label": 0, "functionSource": "static int rtp_packetize_pcm ( sout_stream_id_sys_t * id , block_t * in ) {\n unsigned max = rtp_mtu ( id ) ;\n while ( in -> i_buffer > max ) {\n unsigned duration = ( in -> i_length * max ) / in -> i_buffer ;\n bool marker = ( in -> i_flags & BLOCK_FLAG_DISCONTINUITY ) != 0 ;\n block_t * out = block_Alloc ( 12 + max ) ;\n if ( unlikely ( out == NULL ) ) {\n block_Release ( in ) ;\n return VLC_ENOMEM ;\n }\n rtp_packetize_common ( id , out , marker , in -> i_pts ) ;\n memcpy ( out -> p_buffer + 12 , in -> p_buffer , max ) ;\n rtp_packetize_send ( id , out ) ;\n in -> p_buffer += max ;\n in -> i_buffer -= max ;\n in -> i_pts += duration ;\n in -> i_length -= duration ;\n in -> i_flags &= ~ BLOCK_FLAG_DISCONTINUITY ;\n }\n return rtp_packetize_simple ( id , in ) ;\n }", "idx": 22338}
{"hash": 9046191708840218774, "project": "debian", "size": 18, "label": 0, "functionSource": "static int tipc_nl_compat_bearer_enable ( struct tipc_nl_compat_cmd_doit * cmd , struct sk_buff * skb , struct tipc_nl_compat_msg * msg ) {\n struct nlattr * prop ;\n struct nlattr * bearer ;\n struct tipc_bearer_config * b ;\n b = ( struct tipc_bearer_config * ) TLV_DATA ( msg -> req ) ;\n bearer = nla_nest_start ( skb , TIPC_NLA_BEARER ) ;\n if ( ! bearer ) return - EMSGSIZE ;\n if ( nla_put_string ( skb , TIPC_NLA_BEARER_NAME , b -> name ) ) return - EMSGSIZE ;\n if ( nla_put_u32 ( skb , TIPC_NLA_BEARER_DOMAIN , ntohl ( b -> disc_domain ) ) ) return - EMSGSIZE ;\n if ( ntohl ( b -> priority ) <= TIPC_MAX_LINK_PRI ) {\n prop = nla_nest_start ( skb , TIPC_NLA_BEARER_PROP ) ;\n if ( ! prop ) return - EMSGSIZE ;\n if ( nla_put_u32 ( skb , TIPC_NLA_PROP_PRIO , ntohl ( b -> priority ) ) ) return - EMSGSIZE ;\n nla_nest_end ( skb , prop ) ;\n }\n nla_nest_end ( skb , bearer ) ;\n return 0 ;\n }", "idx": 22339}
{"hash": -1929262071302712016, "project": "debian", "size": 7, "label": 0, "functionSource": "static cmsBool Type_Data_Write ( struct _cms_typehandler_struct * self , cmsIOHANDLER * io , void * Ptr , cmsUInt32Number nItems ) {\n cmsICCData * BinData = ( cmsICCData * ) Ptr ;\n if ( ! _cmsWriteUInt32Number ( io , BinData -> flag ) ) return FALSE ;\n return io -> Write ( io , BinData -> len , BinData -> data ) ;\n cmsUNUSED_PARAMETER ( nItems ) ;\n cmsUNUSED_PARAMETER ( self ) ;\n }", "idx": 22340}
{"hash": -4422011356016453021, "project": "debian", "size": 49, "label": 1, "functionSource": "static int s302m_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n AVFrame * frame = data ;\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n int block_size , ret ;\n int frame_size = s302m_parse_frame_header ( avctx , buf , buf_size ) ;\n if ( frame_size < 0 ) return frame_size ;\n buf_size -= AES3_HEADER_LEN ;\n buf += AES3_HEADER_LEN ;\n block_size = ( avctx -> bits_per_coded_sample + 4 ) / 4 ;\n frame -> nb_samples = 2 * ( buf_size / block_size ) / avctx -> channels ;\n if ( ( ret = ff_get_buffer ( avctx , frame ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n buf_size = ( frame -> nb_samples * avctx -> channels / 2 ) * block_size ;\n if ( avctx -> bits_per_coded_sample == 24 ) {\n uint32_t * o = ( uint32_t * ) frame -> data [ 0 ] ;\n for ( ;\n buf_size > 6 ;\n buf_size -= 7 ) {\n * o ++ = ( ff_reverse [ buf [ 2 ] ] << 24 ) | ( ff_reverse [ buf [ 1 ] ] << 16 ) | ( ff_reverse [ buf [ 0 ] ] << 8 ) ;\n * o ++ = ( ff_reverse [ buf [ 6 ] & 0xf0 ] << 28 ) | ( ff_reverse [ buf [ 5 ] ] << 20 ) | ( ff_reverse [ buf [ 4 ] ] << 12 ) | ( ff_reverse [ buf [ 3 ] & 0x0f ] << 4 ) ;\n buf += 7 ;\n }\n }\n else if ( avctx -> bits_per_coded_sample == 20 ) {\n uint32_t * o = ( uint32_t * ) frame -> data [ 0 ] ;\n for ( ;\n buf_size > 5 ;\n buf_size -= 6 ) {\n * o ++ = ( ff_reverse [ buf [ 2 ] & 0xf0 ] << 28 ) | ( ff_reverse [ buf [ 1 ] ] << 20 ) | ( ff_reverse [ buf [ 0 ] ] << 12 ) ;\n * o ++ = ( ff_reverse [ buf [ 5 ] & 0xf0 ] << 28 ) | ( ff_reverse [ buf [ 4 ] ] << 20 ) | ( ff_reverse [ buf [ 3 ] ] << 12 ) ;\n buf += 6 ;\n }\n }\n else {\n uint16_t * o = ( uint16_t * ) frame -> data [ 0 ] ;\n for ( ;\n buf_size > 4 ;\n buf_size -= 5 ) {\n * o ++ = ( ff_reverse [ buf [ 1 ] ] << 8 ) | ff_reverse [ buf [ 0 ] ] ;\n * o ++ = ( ff_reverse [ buf [ 4 ] & 0xf0 ] << 12 ) | ( ff_reverse [ buf [ 3 ] ] << 4 ) | ( ff_reverse [ buf [ 2 ] ] >> 4 ) ;\n buf += 5 ;\n }\n }\n * got_frame_ptr = 1 ;\n return avpkt -> size ;\n }", "idx": 22341}
{"hash": -7456613930747243098, "project": "debian", "size": 6, "label": 0, "functionSource": "static float get_float ( GetBitContext * gb ) {\n int power = get_bits ( gb , 5 ) ;\n float f = ldexpf ( get_bits_long ( gb , 23 ) , power - 23 ) ;\n if ( get_bits1 ( gb ) ) f = - f ;\n return f ;\n }", "idx": 22342}
{"hash": 313627013719508831, "project": "debian", "size": 3, "label": 0, "functionSource": "static inline void SetPixelIndexTraits ( Image * image , const PixelTrait traits ) {\n image -> channel_map [ IndexPixelChannel ] . traits = traits ;\n }", "idx": 22343}
{"hash": 2343071019501443392, "project": "chrome", "size": 5, "label": 0, "functionSource": "void vp9_build_nmv_cost_table ( int * mvjoint , int * mvcost [ 2 ] , const nmv_context * ctx , int usehp ) {\n vp9_cost_tokens ( mvjoint , ctx -> joints , vp9_mv_joint_tree ) ;\n build_nmv_component_cost_table ( mvcost [ 0 ] , & ctx -> comps [ 0 ] , usehp ) ;\n build_nmv_component_cost_table ( mvcost [ 1 ] , & ctx -> comps [ 1 ] , usehp ) ;\n }", "idx": 22344}
{"hash": -560820000732125076, "project": "chrome", "size": 20, "label": 0, "functionSource": "void exsltMathRegister ( void ) {\n xsltRegisterExtModuleFunction ( ( const xmlChar * ) \"min\" , EXSLT_MATH_NAMESPACE , exsltMathMinFunction ) ;\n xsltRegisterExtModuleFunction ( ( const xmlChar * ) \"max\" , EXSLT_MATH_NAMESPACE , exsltMathMaxFunction ) ;\n xsltRegisterExtModuleFunction ( ( const xmlChar * ) \"highest\" , EXSLT_MATH_NAMESPACE , exsltMathHighestFunction ) ;\n xsltRegisterExtModuleFunction ( ( const xmlChar * ) \"lowest\" , EXSLT_MATH_NAMESPACE , exsltMathLowestFunction ) ;\n xsltRegisterExtModuleFunction ( ( const xmlChar * ) \"constant\" , EXSLT_MATH_NAMESPACE , exsltMathConstantFunction ) ;\n # ifdef HAVE_STDLIB_H xsltRegisterExtModuleFunction ( ( const xmlChar * ) \"random\" , EXSLT_MATH_NAMESPACE , exsltMathRandomFunction ) ;\n # endif # if HAVE_MATH_H xsltRegisterExtModuleFunction ( ( const xmlChar * ) \"abs\" , EXSLT_MATH_NAMESPACE , exsltMathAbsFunction ) ;\n xsltRegisterExtModuleFunction ( ( const xmlChar * ) \"sqrt\" , EXSLT_MATH_NAMESPACE , exsltMathSqrtFunction ) ;\n xsltRegisterExtModuleFunction ( ( const xmlChar * ) \"power\" , EXSLT_MATH_NAMESPACE , exsltMathPowerFunction ) ;\n xsltRegisterExtModuleFunction ( ( const xmlChar * ) \"log\" , EXSLT_MATH_NAMESPACE , exsltMathLogFunction ) ;\n xsltRegisterExtModuleFunction ( ( const xmlChar * ) \"sin\" , EXSLT_MATH_NAMESPACE , exsltMathSinFunction ) ;\n xsltRegisterExtModuleFunction ( ( const xmlChar * ) \"cos\" , EXSLT_MATH_NAMESPACE , exsltMathCosFunction ) ;\n xsltRegisterExtModuleFunction ( ( const xmlChar * ) \"tan\" , EXSLT_MATH_NAMESPACE , exsltMathTanFunction ) ;\n xsltRegisterExtModuleFunction ( ( const xmlChar * ) \"asin\" , EXSLT_MATH_NAMESPACE , exsltMathAsinFunction ) ;\n xsltRegisterExtModuleFunction ( ( const xmlChar * ) \"acos\" , EXSLT_MATH_NAMESPACE , exsltMathAcosFunction ) ;\n xsltRegisterExtModuleFunction ( ( const xmlChar * ) \"atan\" , EXSLT_MATH_NAMESPACE , exsltMathAtanFunction ) ;\n xsltRegisterExtModuleFunction ( ( const xmlChar * ) \"atan2\" , EXSLT_MATH_NAMESPACE , exsltMathAtan2Function ) ;\n xsltRegisterExtModuleFunction ( ( const xmlChar * ) \"exp\" , EXSLT_MATH_NAMESPACE , exsltMathExpFunction ) ;\n # endif }", "idx": 22345}
{"hash": 5357882892791796049, "project": "debian", "size": 10, "label": 0, "functionSource": "static void e1000e_set_eerd ( E1000ECore * core , int index , uint32_t val ) {\n uint32_t addr = ( val >> E1000_EERW_ADDR_SHIFT ) & E1000_EERW_ADDR_MASK ;\n uint32_t flags = 0 ;\n uint32_t data = 0 ;\n if ( ( addr < E1000E_EEPROM_SIZE ) && ( val & E1000_EERW_START ) ) {\n data = core -> eeprom [ addr ] ;\n flags = E1000_EERW_DONE ;\n }\n core -> mac [ EERD ] = flags | ( addr << E1000_EERW_ADDR_SHIFT ) | ( data << E1000_EERW_DATA_SHIFT ) ;\n }", "idx": 22346}
{"hash": 2388171415474875762, "project": "debian", "size": 62, "label": 1, "functionSource": "static void dissect_rsvp_common ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , gboolean e2ei ) {\n guint8 message_type ;\n int session_off , tempfilt_off ;\n rsvp_conversation_info * rsvph ;\n conversation_t * conversation ;\n struct rsvp_request_key request_key , * new_request_key ;\n struct rsvp_request_val * request_val ;\n col_clear ( pinfo -> cinfo , COL_INFO ) ;\n message_type = tvb_get_guint8 ( tvb , 1 ) ;\n rsvph = wmem_new0 ( wmem_packet_scope ( ) , rsvp_conversation_info ) ;\n set_address ( & rsvph -> source , pinfo -> src . type , pinfo -> src . len , pinfo -> src . data ) ;\n set_address ( & rsvph -> destination , pinfo -> dst . type , pinfo -> dst . len , pinfo -> dst . data ) ;\n col_add_str ( pinfo -> cinfo , COL_INFO , val_to_str_ext ( message_type , & message_type_vals_ext , \"Unknown (%u). \" ) ) ;\n if ( message_type == RSVP_MSG_BUNDLE ) {\n col_set_str ( pinfo -> cinfo , COL_INFO , rsvp_bundle_dissect ? \"Component Messages Dissected\" : \"Component Messages Not Dissected\" ) ;\n }\n else {\n find_rsvp_session_tempfilt ( tvb , 0 , & session_off , & tempfilt_off ) ;\n if ( session_off ) col_append_str ( pinfo -> cinfo , COL_INFO , summary_session ( tvb , session_off ) ) ;\n if ( tempfilt_off ) col_append_str ( pinfo -> cinfo , COL_INFO , summary_template ( tvb , tempfilt_off ) ) ;\n }\n dissect_rsvp_msg_tree ( tvb , pinfo , tree , TREE ( TT_RSVP ) , rsvph , e2ei ) ;\n if ( ( message_type == RSVP_MSG_ACK ) || ( message_type == RSVP_MSG_SREFRESH ) || ( message_type == RSVP_MSG_HELLO ) ) return ;\n conversation = find_or_create_conversation ( pinfo ) ;\n memset ( & request_key , 0 , sizeof ( request_key ) ) ;\n request_key . conversation = conversation -> index ;\n request_key . session_type = rsvph -> session_type ;\n switch ( request_key . session_type ) {\n case RSVP_SESSION_TYPE_IPV4 : set_address ( & request_key . u . session_ipv4 . destination , rsvph -> destination . type , rsvph -> destination . len , rsvph -> destination . data ) ;\n request_key . u . session_ipv4 . protocol = rsvph -> protocol ;\n request_key . u . session_ipv4 . udp_dest_port = rsvph -> udp_dest_port ;\n break ;\n case RSVP_SESSION_TYPE_IPV6 : break ;\n case RSVP_SESSION_TYPE_IPV4_LSP : set_address ( & request_key . u . session_ipv4_lsp . destination , rsvph -> destination . type , rsvph -> destination . len , rsvph -> destination . data ) ;\n request_key . u . session_ipv4_lsp . udp_dest_port = rsvph -> udp_dest_port ;\n request_key . u . session_ipv4_lsp . ext_tunnel_id = rsvph -> ext_tunnel_id ;\n break ;\n case RSVP_SESSION_TYPE_AGGREGATE_IPV4 : set_address ( & request_key . u . session_agg_ipv4 . destination , rsvph -> destination . type , rsvph -> destination . len , rsvph -> destination . data ) ;\n request_key . u . session_agg_ipv4 . dscp = rsvph -> dscp ;\n break ;\n case RSVP_SESSION_TYPE_IPV4_UNI : set_address ( & request_key . u . session_ipv4_uni . destination , rsvph -> destination . type , rsvph -> destination . len , rsvph -> destination . data ) ;\n request_key . u . session_ipv4_uni . udp_dest_port = rsvph -> udp_dest_port ;\n request_key . u . session_ipv4_uni . ext_tunnel_id = rsvph -> ext_tunnel_id ;\n break ;\n case RSVP_SESSION_TYPE_IPV4_E_NNI : set_address ( & request_key . u . session_ipv4_enni . destination , rsvph -> destination . type , rsvph -> destination . len , rsvph -> destination . data ) ;\n request_key . u . session_ipv4_enni . udp_dest_port = rsvph -> udp_dest_port ;\n request_key . u . session_ipv4_enni . ext_tunnel_id = rsvph -> ext_tunnel_id ;\n break ;\n default : proto_tree_add_expert ( tree , pinfo , & ei_rsvp_session_type , tvb , 0 , 0 ) ;\n break ;\n }\n copy_address_wmem ( wmem_file_scope ( ) , & request_key . source_info . source , & rsvph -> source ) ;\n request_key . source_info . udp_source_port = rsvph -> udp_source_port ;\n request_val = ( struct rsvp_request_val * ) g_hash_table_lookup ( rsvp_request_hash , & request_key ) ;\n if ( ! request_val ) {\n new_request_key = ( struct rsvp_request_key * ) wmem_memdup ( wmem_file_scope ( ) , & request_key , sizeof ( struct rsvp_request_key ) ) ;\n request_val = wmem_new ( wmem_file_scope ( ) , struct rsvp_request_val ) ;\n request_val -> value = conversation -> index ;\n g_hash_table_insert ( rsvp_request_hash , new_request_key , request_val ) ;\n }\n tap_queue_packet ( rsvp_tap , pinfo , rsvph ) ;\n }", "idx": 22347}
{"hash": 6323824267898511453, "project": "debian", "size": 3, "label": 0, "functionSource": "const fz_cmm_engine * fz_get_cmm_engine ( fz_context * ctx ) {\n return ctx -> colorspace ? ctx -> colorspace -> cmm : NULL ;\n }", "idx": 22348}
{"hash": 6323824267898511453, "project": "debian", "size": 3, "label": 0, "functionSource": "int fz_colorspace_device_n_has_only_cmyk ( fz_context * ctx , const fz_colorspace * cs ) {\n return cs && ( ( cs -> flags & FZ_CS_HAS_CMYK_AND_SPOTS ) == FZ_CS_HAS_CMYK ) ;\n }", "idx": 22349}
{"hash": -1950979830238945732, "project": "debian", "size": 15, "label": 0, "functionSource": "static void WarnPatented ( gs_font_type42 * pfont , ttfFont * ttf , const char * txt ) {\n if ( ! ttf -> design_grid ) {\n char buf [ gs_font_name_max + 1 ] ;\n int l ;\n gs_font_type42 * base_font = pfont ;\n while ( ( gs_font_type42 * ) base_font -> base != base_font ) base_font = ( gs_font_type42 * ) base_font -> base ;\n if ( ! base_font -> data . warning_patented ) {\n l = min ( sizeof ( buf ) - 1 , base_font -> font_name . size ) ;\n memcpy ( buf , base_font -> font_name . chars , l ) ;\n buf [ l ] = 0 ;\n emprintf2 ( pfont -> memory , \"%s %s requires a patented True Type interpreter.\\n\" , txt , buf ) ;\n base_font -> data . warning_patented = true ;\n }\n }\n }", "idx": 22350}
{"hash": -5268859819325807498, "project": "debian", "size": 10, "label": 0, "functionSource": "static void request_counter_add_request ( RequestCounter counter , Request request ) {\n guint i ;\n for ( i = 0 ;\n i < REQUEST_TYPE_LAST ;\n i ++ ) {\n if ( REQUEST_WANTS_TYPE ( request , i ) ) {\n counter [ i ] ++ ;\n }\n }\n }", "idx": 22351}
{"hash": 1245821301839614810, "project": "debian", "size": 4, "label": 0, "functionSource": "static void abort_job ( CommonJob * job ) {\n g_clear_object ( & job -> undo_info ) ;\n g_cancellable_cancel ( job -> cancellable ) ;\n }", "idx": 22352}
{"hash": -2423144171479606949, "project": "debian", "size": 5, "label": 0, "functionSource": "static void pdf_run_BT ( fz_context * ctx , pdf_processor * proc ) {\n pdf_run_processor * pr = ( pdf_run_processor * ) proc ;\n pr -> tos . tm = fz_identity ;\n pr -> tos . tlm = fz_identity ;\n }", "idx": 22353}
{"hash": -7334302271653594926, "project": "debian", "size": 3, "label": 0, "functionSource": "bool agg_item_collations_for_comparison ( DTCollation & c , const char * fname , Item * * av , uint count , uint flags ) {\n return ( agg_item_collations ( c , fname , av , count , flags | MY_COLL_DISALLOW_NONE , 1 ) ) ;\n }", "idx": 22354}
{"hash": 5838244232542871853, "project": "chrome", "size": 41, "label": 0, "functionSource": "TEST_F ( ScoredHistoryMatchTest , Scoring ) {\n base : : Time now = base : : Time : : NowFromSystemTime ( ) ;\n history : : URLRow row_a ( MakeURLRow ( \"http://fedcba\" , \"abcd bcd\" , 3 , 30 , 1 ) ) ;\n RowWordStarts word_starts_a ;\n PopulateWordStarts ( row_a , & word_starts_a ) ;\n WordStarts one_word_no_offset ( 1 , 0u ) ;\n VisitInfoVector visits_a = CreateVisitInfoVector ( 3 , 30 , now ) ;\n visits_a [ 0 ] . second = ui : : PAGE_TRANSITION_TYPED ;\n ScoredHistoryMatch scored_a ( row_a , visits_a , ASCIIToUTF16 ( \"abc\" ) , Make1Term ( \"abc\" ) , one_word_no_offset , word_starts_a , false , nullptr , now ) ;\n history : : URLRow row_b ( MakeURLRow ( \"http://abcdef\" , \"abcd bcd\" , 10 , 30 , 1 ) ) ;\n RowWordStarts word_starts_b ;\n PopulateWordStarts ( row_b , & word_starts_b ) ;\n VisitInfoVector visits_b = CreateVisitInfoVector ( 10 , 30 , now ) ;\n visits_b [ 0 ] . second = ui : : PAGE_TRANSITION_TYPED ;\n ScoredHistoryMatch scored_b ( row_b , visits_b , ASCIIToUTF16 ( \"abc\" ) , Make1Term ( \"abc\" ) , one_word_no_offset , word_starts_b , false , nullptr , now ) ;\n EXPECT_GT ( scored_b . raw_score , scored_a . raw_score ) ;\n history : : URLRow row_c ( MakeURLRow ( \"http://abcdef\" , \"abcd bcd\" , 3 , 10 , 1 ) ) ;\n RowWordStarts word_starts_c ;\n PopulateWordStarts ( row_c , & word_starts_c ) ;\n VisitInfoVector visits_c = CreateVisitInfoVector ( 3 , 10 , now ) ;\n visits_c [ 0 ] . second = ui : : PAGE_TRANSITION_TYPED ;\n ScoredHistoryMatch scored_c ( row_c , visits_c , ASCIIToUTF16 ( \"abc\" ) , Make1Term ( \"abc\" ) , one_word_no_offset , word_starts_c , false , nullptr , now ) ;\n EXPECT_GT ( scored_c . raw_score , scored_a . raw_score ) ;\n history : : URLRow row_d ( MakeURLRow ( \"http://abcdef\" , \"abcd bcd\" , 3 , 30 , 3 ) ) ;\n RowWordStarts word_starts_d ;\n PopulateWordStarts ( row_d , & word_starts_d ) ;\n VisitInfoVector visits_d = CreateVisitInfoVector ( 3 , 30 , now ) ;\n visits_d [ 0 ] . second = ui : : PAGE_TRANSITION_TYPED ;\n visits_d [ 1 ] . second = ui : : PAGE_TRANSITION_TYPED ;\n visits_d [ 2 ] . second = ui : : PAGE_TRANSITION_TYPED ;\n ScoredHistoryMatch scored_d ( row_d , visits_d , ASCIIToUTF16 ( \"abc\" ) , Make1Term ( \"abc\" ) , one_word_no_offset , word_starts_d , false , nullptr , now ) ;\n EXPECT_GT ( scored_d . raw_score , scored_a . raw_score ) ;\n history : : URLRow row_e ( MakeURLRow ( \"http://csi.csi.csi/csi_csi\" , \"CSI Guide to CSI Las Vegas, CSI New York, CSI Provo\" , 3 , 30 , 3 ) ) ;\n RowWordStarts word_starts_e ;\n PopulateWordStarts ( row_e , & word_starts_e ) ;\n const VisitInfoVector visits_e = visits_d ;\n ScoredHistoryMatch scored_e ( row_e , visits_e , ASCIIToUTF16 ( \"csi\" ) , Make1Term ( \"csi\" ) , one_word_no_offset , word_starts_e , false , nullptr , now ) ;\n EXPECT_LT ( scored_e . raw_score , 1400 ) ;\n ScoredHistoryMatch scored_f ( row_a , visits_a , ASCIIToUTF16 ( \"cd\" ) , Make1Term ( \"cd\" ) , one_word_no_offset , word_starts_a , false , nullptr , now ) ;\n EXPECT_EQ ( scored_f . raw_score , 0 ) ;\n }", "idx": 22355}
{"hash": -1335877942018854351, "project": "chrome", "size": 16, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( FastUnloadTest , MAYBE_UnloadHidden ) {\n NavigateToPage ( \"no_listeners\" ) ;\n NavigateToPageInNewTab ( \"unload_sets_cookie\" ) ;\n EXPECT_EQ ( \"\" , GetCookies ( \"no_listeners\" ) ) ;\n content : : WebContentsDestroyedWatcher destroyed_watcher ( browser ( ) -> tab_strip_model ( ) -> GetActiveWebContents ( ) ) ;\n {\n base : : RunLoop run_loop ;\n FastTabCloseTabStripModelObserver observer ( browser ( ) -> tab_strip_model ( ) , & run_loop ) ;\n chrome : : CloseTab ( browser ( ) ) ;\n run_loop . Run ( ) ;\n }\n CheckTitle ( \"no_listeners\" ) ;\n EXPECT_EQ ( 1 , browser ( ) -> tab_strip_model ( ) -> count ( ) ) ;\n destroyed_watcher . Wait ( ) ;\n EXPECT_EQ ( \"unloaded=ohyeah\" , GetCookies ( \"no_listeners\" ) ) ;\n }", "idx": 22356}
{"hash": -4525874104093394205, "project": "debian", "size": 82, "label": 0, "functionSource": "OFCondition parseAssociate ( unsigned char * buf , unsigned long pduLength , PRV_ASSOCIATEPDU * assoc ) {\n OFCondition cond = EC_Normal ;\n unsigned char type ;\n unsigned long itemLength ;\n PRV_PRESENTATIONCONTEXTITEM * context ;\n ( void ) memset ( assoc , 0 , sizeof ( * assoc ) ) ;\n if ( ( assoc -> presentationContextList = LST_Create ( ) ) == NULL ) return EC_MemoryExhausted ;\n if ( ( assoc -> userInfo . SCUSCPRoleList = LST_Create ( ) ) == NULL ) return EC_MemoryExhausted ;\n if ( pduLength < 2 + 2 + 16 + 16 + 32 ) return makeLengthError ( \"associate PDU\" , pduLength , 2 + 2 + 16 + 16 + 32 ) ;\n assoc -> type = * buf ++ ;\n assoc -> rsv1 = * buf ++ ;\n EXTRACT_LONG_BIG ( buf , assoc -> length ) ;\n buf += 4 ;\n EXTRACT_SHORT_BIG ( buf , assoc -> protocol ) ;\n buf += 2 ;\n pduLength -= 2 ;\n if ( ( assoc -> protocol & DUL_PROTOCOL ) == 0 ) {\n char buffer [ 256 ] ;\n sprintf ( buffer , \"DUL Unsupported peer protocol %04x;\n expected %04x in %s\" , assoc -> protocol , DUL_PROTOCOL , \"parseAssociate\" ) ;\n return makeDcmnetCondition ( DULC_UNSUPPORTEDPEERPROTOCOL , OF_error , buffer ) ;\n }\n assoc -> rsv2 [ 0 ] = * buf ++ ;\n pduLength -- ;\n assoc -> rsv2 [ 1 ] = * buf ++ ;\n pduLength -- ;\n ( void ) strncpy ( assoc -> calledAPTitle , ( char * ) buf , 16 ) ;\n assoc -> calledAPTitle [ 16 ] = '\\0' ;\n trim_trailing_spaces ( assoc -> calledAPTitle ) ;\n buf += 16 ;\n pduLength -= 16 ;\n ( void ) strncpy ( assoc -> callingAPTitle , ( char * ) buf , 16 ) ;\n assoc -> callingAPTitle [ 16 ] = '\\0' ;\n trim_trailing_spaces ( assoc -> callingAPTitle ) ;\n buf += 16 ;\n pduLength -= 16 ;\n ( void ) memcpy ( assoc -> rsv3 , buf , 32 ) ;\n buf += 32 ;\n pduLength -= 32 ;\n if ( DCM_dcmnetLogger . isEnabledFor ( OFLogger : : DEBUG_LOG_LEVEL ) ) {\n const char * s ;\n DCMNET_DEBUG ( \"Parsing an A-ASSOCIATE PDU\" ) ;\n if ( assoc -> type == DUL_TYPEASSOCIATERQ ) s = \"A-ASSOCIATE RQ\" ;\n else if ( assoc -> type == DUL_TYPEASSOCIATEAC ) s = \"A-ASSOCIATE AC\" ;\n else s = \"Unknown: Programming bug in parseAssociate\" ;\n DCMNET_TRACE ( \"PDU type: \" << STD_NAMESPACE hex << ( ( unsigned int ) assoc -> type ) << STD_NAMESPACE dec << \" (\" << s << \"), PDU Length: \" << assoc -> length << OFendl << \"DICOM Protocol: \" << STD_NAMESPACE hex << assoc -> protocol << STD_NAMESPACE dec << OFendl << \"Called AP Title: \" << assoc -> calledAPTitle << OFendl << \"Calling AP Title: \" << assoc -> callingAPTitle ) ;\n }\n while ( ( cond . good ( ) ) && ( pduLength > 0 ) ) {\n type = * buf ;\n DCMNET_TRACE ( \"Parsing remaining \" << pduLength << \" bytes of A-ASSOCIATE PDU\" << OFendl << \"Next item type: \" << STD_NAMESPACE hex << STD_NAMESPACE setfill ( '0' ) << STD_NAMESPACE setw ( 2 ) << ( ( unsigned int ) type ) ) ;\n switch ( type ) {\n case DUL_TYPEAPPLICATIONCONTEXT : cond = parseSubItem ( & assoc -> applicationContext , buf , & itemLength , pduLength ) ;\n if ( cond . good ( ) ) {\n buf += itemLength ;\n pduLength -= itemLength ;\n DCMNET_TRACE ( \"Successfully parsed Application Context\" ) ;\n }\n break ;\n case DUL_TYPEPRESENTATIONCONTEXTRQ : case DUL_TYPEPRESENTATIONCONTEXTAC : context = ( PRV_PRESENTATIONCONTEXTITEM * ) malloc ( sizeof ( PRV_PRESENTATIONCONTEXTITEM ) ) ;\n if ( context == NULL ) return EC_MemoryExhausted ;\n ( void ) memset ( context , 0 , sizeof ( * context ) ) ;\n cond = parsePresentationContext ( type , context , buf , & itemLength , pduLength ) ;\n if ( cond . bad ( ) ) return cond ;\n buf += itemLength ;\n pduLength -= itemLength ;\n LST_Enqueue ( & assoc -> presentationContextList , ( LST_NODE * ) context ) ;\n DCMNET_TRACE ( \"Successfully parsed Presentation Context\" ) ;\n break ;\n case DUL_TYPEUSERINFO : cond = parseUserInfo ( & assoc -> userInfo , buf , & itemLength , assoc -> type , pduLength ) ;\n if ( cond . bad ( ) ) return cond ;\n buf += itemLength ;\n pduLength -= itemLength ;\n DCMNET_TRACE ( \"Successfully parsed User Information\" ) ;\n break ;\n default : cond = parseDummy ( buf , & itemLength , pduLength ) ;\n buf += itemLength ;\n if ( ! OFStandard : : safeSubtract ( pduLength , itemLength , pduLength ) ) return makeUnderflowError ( \"unknown item type\" , pduLength , itemLength ) ;\n break ;\n }\n }\n return cond ;\n }", "idx": 22357}
{"hash": 1535921111212871029, "project": "debian", "size": 3, "label": 0, "functionSource": "void remoteDispatchOOMError ( remote_error * rerr ) {\n remoteDispatchStringError ( rerr , VIR_ERR_NO_MEMORY , \"out of memory\" ) ;\n }", "idx": 22358}
{"hash": -4534372572324105488, "project": "debian", "size": 7, "label": 0, "functionSource": "static int avi_probe ( AVProbeData * p ) {\n int i ;\n for ( i = 0 ;\n avi_headers [ i ] [ 0 ] ;\n i ++ ) if ( AV_RL32 ( p -> buf ) == AV_RL32 ( avi_headers [ i ] ) && AV_RL32 ( p -> buf + 8 ) == AV_RL32 ( avi_headers [ i ] + 4 ) ) return AVPROBE_SCORE_MAX ;\n return 0 ;\n }", "idx": 22359}
{"hash": 313627013719508831, "project": "debian", "size": 3, "label": 0, "functionSource": "static inline Quantum GetPixelL ( const Image * restrict image , const Quantum * restrict pixel ) {\n return ( pixel [ image -> channel_map [ LPixelChannel ] . offset ] ) ;\n }", "idx": 22360}
{"hash": 3309252579593081468, "project": "debian", "size": 34, "label": 0, "functionSource": "static int nntp_mbox_sync ( struct Context * ctx , int * index_hint ) {\n struct NntpData * nntp_data = ctx -> data ;\n int rc ;\n # ifdef USE_HCACHE header_cache_t * hc = NULL ;\n # endif nntp_data -> nserv -> check_time = 0 ;\n rc = check_mailbox ( ctx ) ;\n if ( rc ) return rc ;\n # ifdef USE_HCACHE nntp_data -> last_cached = 0 ;\n hc = nntp_hcache_open ( nntp_data ) ;\n # endif for ( int i = 0 ;\n i < ctx -> msgcount ;\n i ++ ) {\n struct Header * hdr = ctx -> hdrs [ i ] ;\n char buf [ 16 ] ;\n snprintf ( buf , sizeof ( buf ) , \"%d\" , NHDR ( hdr ) -> article_num ) ;\n if ( nntp_data -> bcache && hdr -> deleted ) {\n mutt_debug ( 2 , \"mutt_bcache_del %s\\n\" , buf ) ;\n mutt_bcache_del ( nntp_data -> bcache , buf ) ;\n }\n # ifdef USE_HCACHE if ( hc && ( hdr -> changed || hdr -> deleted ) ) {\n if ( hdr -> deleted && ! hdr -> read ) nntp_data -> unread -- ;\n mutt_debug ( 2 , \"mutt_hcache_store %s\\n\" , buf ) ;\n mutt_hcache_store ( hc , buf , strlen ( buf ) , hdr , 0 ) ;\n }\n # endif }\n # ifdef USE_HCACHE if ( hc ) {\n mutt_hcache_close ( hc ) ;\n nntp_data -> last_cached = nntp_data -> last_loaded ;\n }\n # endif nntp_newsrc_gen_entries ( ctx ) ;\n nntp_newsrc_update ( nntp_data -> nserv ) ;\n nntp_newsrc_close ( nntp_data -> nserv ) ;\n return 0 ;\n }", "idx": 22361}
{"hash": 1245821301839614810, "project": "debian", "size": 65, "label": 0, "functionSource": "static void delete_task_thread_func ( GTask * task , gpointer source_object , gpointer task_data , GCancellable * cancellable ) {\n DeleteJob * job = task_data ;\n GList * to_trash_files ;\n GList * to_delete_files ;\n GList * l ;\n GFile * file ;\n gboolean confirmed ;\n CommonJob * common ;\n gboolean must_confirm_delete_in_trash ;\n gboolean must_confirm_delete ;\n int files_skipped ;\n common = ( CommonJob * ) job ;\n nautilus_progress_info_start ( job -> common . progress ) ;\n to_trash_files = NULL ;\n to_delete_files = NULL ;\n must_confirm_delete_in_trash = FALSE ;\n must_confirm_delete = FALSE ;\n files_skipped = 0 ;\n for ( l = job -> files ;\n l != NULL ;\n l = l -> next ) {\n file = l -> data ;\n if ( job -> try_trash && g_file_has_uri_scheme ( file , \"trash\" ) ) {\n must_confirm_delete_in_trash = TRUE ;\n to_delete_files = g_list_prepend ( to_delete_files , file ) ;\n }\n else if ( can_delete_without_confirm ( file ) ) {\n to_delete_files = g_list_prepend ( to_delete_files , file ) ;\n }\n else {\n if ( job -> try_trash ) {\n to_trash_files = g_list_prepend ( to_trash_files , file ) ;\n }\n else {\n must_confirm_delete = TRUE ;\n to_delete_files = g_list_prepend ( to_delete_files , file ) ;\n }\n }\n }\n if ( to_delete_files != NULL ) {\n to_delete_files = g_list_reverse ( to_delete_files ) ;\n confirmed = TRUE ;\n if ( must_confirm_delete_in_trash ) {\n confirmed = confirm_delete_from_trash ( common , to_delete_files ) ;\n }\n else if ( must_confirm_delete ) {\n confirmed = confirm_delete_directly ( common , to_delete_files ) ;\n }\n if ( confirmed ) {\n delete_files ( common , to_delete_files , & files_skipped ) ;\n }\n else {\n job -> user_cancel = TRUE ;\n }\n }\n if ( to_trash_files != NULL ) {\n to_trash_files = g_list_reverse ( to_trash_files ) ;\n trash_files ( common , to_trash_files , & files_skipped ) ;\n }\n g_list_free ( to_trash_files ) ;\n g_list_free ( to_delete_files ) ;\n if ( files_skipped == g_list_length ( job -> files ) ) {\n job -> user_cancel = TRUE ;\n }\n }", "idx": 22362}
{"hash": 1760449185745615462, "project": "debian", "size": 11, "label": 0, "functionSource": "TSReturnCode TSHttpTxnSecondUrlTryLock ( TSHttpTxn txnp ) {\n sdk_assert ( sdk_sanity_check_txn ( txnp ) == TS_SUCCESS ) ;\n HttpSM * sm = ( HttpSM * ) txnp ;\n HttpTransact : : State * s = & ( sm -> t_state ) ;\n if ( ! s -> cache_info . original_url . valid ( ) ) {\n return TS_ERROR ;\n }\n sm -> add_cache_sm ( ) ;\n s -> api_lock_url = HttpTransact : : LOCK_URL_SECOND ;\n return TS_SUCCESS ;\n }", "idx": 22363}
{"hash": -6068976579504840746, "project": "debian", "size": 10, "label": 0, "functionSource": "u_short ctlpeerstatus ( register struct peer * p ) {\n u_short status ;\n status = p -> status ;\n if ( FLAG_CONFIG & p -> flags ) status |= CTL_PST_CONFIG ;\n if ( p -> keyid ) status |= CTL_PST_AUTHENABLE ;\n if ( FLAG_AUTHENTIC & p -> flags ) status |= CTL_PST_AUTHENTIC ;\n if ( p -> reach ) status |= CTL_PST_REACH ;\n if ( MDF_TXONLY_MASK & p -> cast_flags ) status |= CTL_PST_BCAST ;\n return CTL_PEER_STATUS ( status , p -> num_events , p -> last_event ) ;\n }", "idx": 22364}
{"hash": -1672864273235910388, "project": "debian", "size": 27, "label": 0, "functionSource": "static slurm_addr_t * _build_node_addr ( char * node_list , uint32_t node_cnt , uint32_t pack_job_id ) {\n hostlist_t host_list = NULL ;\n struct node_record * node_ptr ;\n slurm_addr_t * node_addr ;\n char * this_node_name ;\n int error_code = SLURM_SUCCESS , node_inx = 0 ;\n if ( ( host_list = hostlist_create ( node_list ) ) == NULL ) {\n error ( \"%s hostlist_create error for pack job %u (%s): %m\" , __func__ , pack_job_id , node_list ) ;\n return NULL ;\n }\n node_addr = xmalloc ( sizeof ( slurm_addr_t ) * node_cnt ) ;\n while ( ( this_node_name = hostlist_shift ( host_list ) ) ) {\n if ( ( node_ptr = find_node_record ( this_node_name ) ) ) {\n memcpy ( node_addr + node_inx , & node_ptr -> slurm_addr , sizeof ( slurm_addr_t ) ) ;\n node_inx ++ ;\n }\n else {\n error ( \"%s: Invalid node %s in pack job %u\" , __func__ , this_node_name , pack_job_id ) ;\n error_code = SLURM_ERROR ;\n }\n free ( this_node_name ) ;\n if ( error_code != SLURM_SUCCESS ) break ;\n }\n hostlist_destroy ( host_list ) ;\n if ( error_code != SLURM_SUCCESS ) xfree ( node_addr ) ;\n return node_addr ;\n }", "idx": 22365}
{"hash": 3599206110384554647, "project": "debian", "size": 24, "label": 0, "functionSource": "static ossl_inline int sk_ ## t1 ## _find ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_find ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _find_ex ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_find_ex ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline void sk_ ## t1 ## _sort ( STACK_OF ( t1 ) * sk ) {\n OPENSSL_sk_sort ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline int sk_ ## t1 ## _is_sorted ( const STACK_OF ( t1 ) * sk ) {\n return OPENSSL_sk_is_sorted ( ( const OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _dup ( const STACK_OF ( t1 ) * sk ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_dup ( ( const OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _deep_copy ( const STACK_OF ( t1 ) * sk , sk_ ## t1 ## _copyfunc copyfunc , sk_ ## t1 ## _freefunc freefunc ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_deep_copy ( ( const OPENSSL_STACK * ) sk , ( OPENSSL_sk_copyfunc ) copyfunc , ( OPENSSL_sk_freefunc ) freefunc ) ;\n }\n static ossl_inline sk_ ## t1 ## _compfunc sk_ ## t1 ## _set_cmp_func ( STACK_OF ( t1 ) * sk , sk_ ## t1 ## _compfunc compare ) {\n return ( sk_ ## t1 ## _compfunc ) OPENSSL_sk_set_cmp_func ( ( OPENSSL_STACK * ) sk , ( OPENSSL_sk_compfunc ) compare ) ;\n }\n # define DEFINE_SPECIAL_STACK_OF ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , t2 , t2 ) # define DEFINE_STACK_OF ( t ) SKM_DEFINE_STACK_OF ( t , t , t ) # define DEFINE_SPECIAL_STACK_OF_CONST ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , const t2 , t2 ) # define DEFINE_STACK_OF_CONST ( t ) SKM_DEFINE_STACK_OF ( t , const t , t ) typedef char * OPENSSL_STRING ;\n typedef const char * OPENSSL_CSTRING ;\n DEFINE_SPECIAL_STACK_OF ( OPENSSL_STRING , char ) DEFINE_SPECIAL_STACK_OF_CONST ( OPENSSL_CSTRING , char )", "idx": 22366}
{"hash": 7817292828288926681, "project": "debian", "size": 379, "label": 1, "functionSource": "static Image * ReadVIFFImage ( const ImageInfo * image_info , ExceptionInfo * exception ) {\n # define VFF_CM_genericRGB 15 # define VFF_CM_ntscRGB 1 # define VFF_CM_NONE 0 # define VFF_DEP_DECORDER 0x4 # define VFF_DEP_NSORDER 0x8 # define VFF_DES_RAW 0 # define VFF_LOC_IMPLICIT 1 # define VFF_MAPTYP_NONE 0 # define VFF_MAPTYP_1_BYTE 1 # define VFF_MAPTYP_2_BYTE 2 # define VFF_MAPTYP_4_BYTE 4 # define VFF_MAPTYP_FLOAT 5 # define VFF_MAPTYP_DOUBLE 7 # define VFF_MS_NONE 0 # define VFF_MS_ONEPERBAND 1 # define VFF_MS_SHARED 3 # define VFF_TYP_BIT 0 # define VFF_TYP_1_BYTE 1 # define VFF_TYP_2_BYTE 2 # define VFF_TYP_4_BYTE 4 # define VFF_TYP_FLOAT 5 # define VFF_TYP_DOUBLE 9 typedef struct _ViffInfo {\n unsigned char identifier , file_type , release , version , machine_dependency , reserve [ 3 ] ;\n char comment [ 512 ] ;\n unsigned int rows , columns , subrows ;\n int x_offset , y_offset ;\n float x_bits_per_pixel , y_bits_per_pixel ;\n unsigned int location_type , location_dimension , number_of_images , number_data_bands , data_storage_type , data_encode_scheme , map_scheme , map_storage_type , map_rows , map_columns , map_subrows , map_enable , maps_per_cycle , color_space_model ;\n }\n ViffInfo ;\n double min_value , scale_factor , value ;\n Image * image ;\n int bit ;\n MagickBooleanType status ;\n MagickSizeType number_pixels ;\n register IndexPacket * indexes ;\n register ssize_t x ;\n register PixelPacket * q ;\n register ssize_t i ;\n register unsigned char * p ;\n size_t bytes_per_pixel , max_packets , quantum ;\n ssize_t count , y ;\n unsigned char * pixels ;\n unsigned long lsb_first ;\n ViffInfo viff_info ;\n assert ( image_info != ( const ImageInfo * ) NULL ) ;\n assert ( image_info -> signature == MagickSignature ) ;\n if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ;\n assert ( exception != ( ExceptionInfo * ) NULL ) ;\n assert ( exception -> signature == MagickSignature ) ;\n image = AcquireImage ( image_info ) ;\n status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ;\n if ( status == MagickFalse ) {\n image = DestroyImageList ( image ) ;\n return ( ( Image * ) NULL ) ;\n }\n count = ReadBlob ( image , 1 , & viff_info . identifier ) ;\n do {\n if ( ( count != 1 ) || ( ( unsigned char ) viff_info . identifier != 0xab ) ) ThrowReaderException ( CorruptImageError , \"NotAVIFFImage\" ) ;\n ( void ) ReadBlob ( image , sizeof ( viff_info . file_type ) , & viff_info . file_type ) ;\n ( void ) ReadBlob ( image , sizeof ( viff_info . release ) , & viff_info . release ) ;\n ( void ) ReadBlob ( image , sizeof ( viff_info . version ) , & viff_info . version ) ;\n ( void ) ReadBlob ( image , sizeof ( viff_info . machine_dependency ) , & viff_info . machine_dependency ) ;\n ( void ) ReadBlob ( image , sizeof ( viff_info . reserve ) , viff_info . reserve ) ;\n ( void ) ReadBlob ( image , 512 , ( unsigned char * ) viff_info . comment ) ;\n viff_info . comment [ 511 ] = '\\0' ;\n if ( strlen ( viff_info . comment ) > 4 ) ( void ) SetImageProperty ( image , \"comment\" , viff_info . comment ) ;\n if ( ( viff_info . machine_dependency == VFF_DEP_DECORDER ) || ( viff_info . machine_dependency == VFF_DEP_NSORDER ) ) image -> endian = LSBEndian ;\n else image -> endian = MSBEndian ;\n viff_info . rows = ReadBlobLong ( image ) ;\n viff_info . columns = ReadBlobLong ( image ) ;\n viff_info . subrows = ReadBlobLong ( image ) ;\n viff_info . x_offset = ( int ) ReadBlobLong ( image ) ;\n viff_info . y_offset = ( int ) ReadBlobLong ( image ) ;\n viff_info . x_bits_per_pixel = ( float ) ReadBlobLong ( image ) ;\n viff_info . y_bits_per_pixel = ( float ) ReadBlobLong ( image ) ;\n viff_info . location_type = ReadBlobLong ( image ) ;\n viff_info . location_dimension = ReadBlobLong ( image ) ;\n viff_info . number_of_images = ReadBlobLong ( image ) ;\n viff_info . number_data_bands = ReadBlobLong ( image ) ;\n viff_info . data_storage_type = ReadBlobLong ( image ) ;\n viff_info . data_encode_scheme = ReadBlobLong ( image ) ;\n viff_info . map_scheme = ReadBlobLong ( image ) ;\n viff_info . map_storage_type = ReadBlobLong ( image ) ;\n viff_info . map_rows = ReadBlobLong ( image ) ;\n viff_info . map_columns = ReadBlobLong ( image ) ;\n viff_info . map_subrows = ReadBlobLong ( image ) ;\n viff_info . map_enable = ReadBlobLong ( image ) ;\n viff_info . maps_per_cycle = ReadBlobLong ( image ) ;\n viff_info . color_space_model = ReadBlobLong ( image ) ;\n for ( i = 0 ;\n i < 420 ;\n i ++ ) ( void ) ReadBlobByte ( image ) ;\n if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , \"UnexpectedEndOfFile\" ) ;\n image -> columns = viff_info . rows ;\n image -> rows = viff_info . columns ;\n image -> depth = viff_info . x_bits_per_pixel <= 8 ? 8UL : MAGICKCORE_QUANTUM_DEPTH ;\n number_pixels = ( MagickSizeType ) viff_info . columns * viff_info . rows ;\n if ( number_pixels != ( size_t ) number_pixels ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ;\n if ( number_pixels == 0 ) ThrowReaderException ( CoderError , \"ImageColumnOrRowSizeIsNotSupported\" ) ;\n if ( ( viff_info . number_data_bands < 1 ) || ( viff_info . number_data_bands > 4 ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ;\n if ( ( viff_info . data_storage_type != VFF_TYP_BIT ) && ( viff_info . data_storage_type != VFF_TYP_1_BYTE ) && ( viff_info . data_storage_type != VFF_TYP_2_BYTE ) && ( viff_info . data_storage_type != VFF_TYP_4_BYTE ) && ( viff_info . data_storage_type != VFF_TYP_FLOAT ) && ( viff_info . data_storage_type != VFF_TYP_DOUBLE ) ) ThrowReaderException ( CoderError , \"DataStorageTypeIsNotSupported\" ) ;\n if ( viff_info . data_encode_scheme != VFF_DES_RAW ) ThrowReaderException ( CoderError , \"DataEncodingSchemeIsNotSupported\" ) ;\n if ( ( viff_info . map_storage_type != VFF_MAPTYP_NONE ) && ( viff_info . map_storage_type != VFF_MAPTYP_1_BYTE ) && ( viff_info . map_storage_type != VFF_MAPTYP_2_BYTE ) && ( viff_info . map_storage_type != VFF_MAPTYP_4_BYTE ) && ( viff_info . map_storage_type != VFF_MAPTYP_FLOAT ) && ( viff_info . map_storage_type != VFF_MAPTYP_DOUBLE ) ) ThrowReaderException ( CoderError , \"MapStorageTypeIsNotSupported\" ) ;\n if ( ( viff_info . color_space_model != VFF_CM_NONE ) && ( viff_info . color_space_model != VFF_CM_ntscRGB ) && ( viff_info . color_space_model != VFF_CM_genericRGB ) ) ThrowReaderException ( CoderError , \"ColorspaceModelIsNotSupported\" ) ;\n if ( viff_info . location_type != VFF_LOC_IMPLICIT ) ThrowReaderException ( CoderError , \"LocationTypeIsNotSupported\" ) ;\n if ( viff_info . number_of_images != 1 ) ThrowReaderException ( CoderError , \"NumberOfImagesIsNotSupported\" ) ;\n if ( viff_info . map_rows == 0 ) viff_info . map_scheme = VFF_MS_NONE ;\n switch ( ( int ) viff_info . map_scheme ) {\n case VFF_MS_NONE : {\n if ( viff_info . number_data_bands < 3 ) {\n if ( viff_info . data_storage_type == VFF_TYP_BIT ) image -> colors = 2 ;\n else if ( viff_info . data_storage_type == VFF_MAPTYP_1_BYTE ) image -> colors = 256UL ;\n else image -> colors = image -> depth <= 8 ? 256UL : 65536UL ;\n if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ;\n }\n break ;\n }\n case VFF_MS_ONEPERBAND : case VFF_MS_SHARED : {\n unsigned char * viff_colormap ;\n switch ( ( int ) viff_info . map_storage_type ) {\n case VFF_MAPTYP_1_BYTE : bytes_per_pixel = 1 ;\n break ;\n case VFF_MAPTYP_2_BYTE : bytes_per_pixel = 2 ;\n break ;\n case VFF_MAPTYP_4_BYTE : bytes_per_pixel = 4 ;\n break ;\n case VFF_MAPTYP_FLOAT : bytes_per_pixel = 4 ;\n break ;\n case VFF_MAPTYP_DOUBLE : bytes_per_pixel = 8 ;\n break ;\n default : bytes_per_pixel = 1 ;\n break ;\n }\n image -> colors = viff_info . map_columns ;\n if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ;\n if ( viff_info . map_rows > ( viff_info . map_rows * bytes_per_pixel * sizeof ( * viff_colormap ) ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ;\n viff_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , viff_info . map_rows * bytes_per_pixel * sizeof ( * viff_colormap ) ) ;\n if ( viff_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ;\n ( void ) ReadBlob ( image , bytes_per_pixel * image -> colors * viff_info . map_rows , viff_colormap ) ;\n lsb_first = 1 ;\n if ( * ( char * ) & lsb_first && ( ( viff_info . machine_dependency != VFF_DEP_DECORDER ) && ( viff_info . machine_dependency != VFF_DEP_NSORDER ) ) ) switch ( ( int ) viff_info . map_storage_type ) {\n case VFF_MAPTYP_2_BYTE : {\n MSBOrderShort ( viff_colormap , ( bytes_per_pixel * image -> colors * viff_info . map_rows ) ) ;\n break ;\n }\n case VFF_MAPTYP_4_BYTE : case VFF_MAPTYP_FLOAT : {\n MSBOrderLong ( viff_colormap , ( bytes_per_pixel * image -> colors * viff_info . map_rows ) ) ;\n break ;\n }\n default : break ;\n }\n for ( i = 0 ;\n i < ( ssize_t ) ( viff_info . map_rows * image -> colors ) ;\n i ++ ) {\n switch ( ( int ) viff_info . map_storage_type ) {\n case VFF_MAPTYP_2_BYTE : value = 1.0 * ( ( short * ) viff_colormap ) [ i ] ;\n break ;\n case VFF_MAPTYP_4_BYTE : value = 1.0 * ( ( int * ) viff_colormap ) [ i ] ;\n break ;\n case VFF_MAPTYP_FLOAT : value = ( ( float * ) viff_colormap ) [ i ] ;\n break ;\n case VFF_MAPTYP_DOUBLE : value = ( ( double * ) viff_colormap ) [ i ] ;\n break ;\n default : value = 1.0 * viff_colormap [ i ] ;\n break ;\n }\n if ( i < ( ssize_t ) image -> colors ) {\n image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) value ) ;\n image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) value ) ;\n image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) value ) ;\n }\n else if ( i < ( ssize_t ) ( 2 * image -> colors ) ) image -> colormap [ i % image -> colors ] . green = ScaleCharToQuantum ( ( unsigned char ) value ) ;\n else if ( i < ( ssize_t ) ( 3 * image -> colors ) ) image -> colormap [ i % image -> colors ] . blue = ScaleCharToQuantum ( ( unsigned char ) value ) ;\n }\n viff_colormap = ( unsigned char * ) RelinquishMagickMemory ( viff_colormap ) ;\n break ;\n }\n default : ThrowReaderException ( CoderError , \"ColormapTypeNotSupported\" ) ;\n }\n image -> matte = viff_info . number_data_bands == 4 ? MagickTrue : MagickFalse ;\n image -> storage_class = ( viff_info . number_data_bands < 3 ? PseudoClass : DirectClass ) ;\n image -> columns = viff_info . rows ;\n image -> rows = viff_info . columns ;\n if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;\n status = SetImageExtent ( image , image -> columns , image -> rows ) ;\n if ( status == MagickFalse ) {\n InheritException ( exception , & image -> exception ) ;\n return ( DestroyImageList ( image ) ) ;\n }\n switch ( ( int ) viff_info . data_storage_type ) {\n case VFF_TYP_2_BYTE : bytes_per_pixel = 2 ;\n break ;\n case VFF_TYP_4_BYTE : bytes_per_pixel = 4 ;\n break ;\n case VFF_TYP_FLOAT : bytes_per_pixel = 4 ;\n break ;\n case VFF_TYP_DOUBLE : bytes_per_pixel = 8 ;\n break ;\n default : bytes_per_pixel = 1 ;\n break ;\n }\n if ( viff_info . data_storage_type == VFF_TYP_BIT ) max_packets = ( ( image -> columns + 7UL ) >> 3UL ) * image -> rows ;\n else max_packets = ( size_t ) ( number_pixels * viff_info . number_data_bands ) ;\n pixels = ( unsigned char * ) AcquireQuantumMemory ( max_packets , bytes_per_pixel * sizeof ( * pixels ) ) ;\n if ( pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ;\n ( void ) ReadBlob ( image , bytes_per_pixel * max_packets , pixels ) ;\n lsb_first = 1 ;\n if ( * ( char * ) & lsb_first && ( ( viff_info . machine_dependency != VFF_DEP_DECORDER ) && ( viff_info . machine_dependency != VFF_DEP_NSORDER ) ) ) switch ( ( int ) viff_info . data_storage_type ) {\n case VFF_TYP_2_BYTE : {\n MSBOrderShort ( pixels , bytes_per_pixel * max_packets ) ;\n break ;\n }\n case VFF_TYP_4_BYTE : case VFF_TYP_FLOAT : {\n MSBOrderLong ( pixels , bytes_per_pixel * max_packets ) ;\n break ;\n }\n default : break ;\n }\n min_value = 0.0 ;\n scale_factor = 1.0 ;\n if ( ( viff_info . data_storage_type != VFF_TYP_1_BYTE ) && ( viff_info . map_scheme == VFF_MS_NONE ) ) {\n double max_value ;\n switch ( ( int ) viff_info . data_storage_type ) {\n case VFF_TYP_2_BYTE : value = 1.0 * ( ( short * ) pixels ) [ 0 ] ;\n break ;\n case VFF_TYP_4_BYTE : value = 1.0 * ( ( int * ) pixels ) [ 0 ] ;\n break ;\n case VFF_TYP_FLOAT : value = ( ( float * ) pixels ) [ 0 ] ;\n break ;\n case VFF_TYP_DOUBLE : value = ( ( double * ) pixels ) [ 0 ] ;\n break ;\n default : value = 1.0 * pixels [ 0 ] ;\n break ;\n }\n max_value = value ;\n min_value = value ;\n for ( i = 0 ;\n i < ( ssize_t ) max_packets ;\n i ++ ) {\n switch ( ( int ) viff_info . data_storage_type ) {\n case VFF_TYP_2_BYTE : value = 1.0 * ( ( short * ) pixels ) [ i ] ;\n break ;\n case VFF_TYP_4_BYTE : value = 1.0 * ( ( int * ) pixels ) [ i ] ;\n break ;\n case VFF_TYP_FLOAT : value = ( ( float * ) pixels ) [ i ] ;\n break ;\n case VFF_TYP_DOUBLE : value = ( ( double * ) pixels ) [ i ] ;\n break ;\n default : value = 1.0 * pixels [ i ] ;\n break ;\n }\n if ( value > max_value ) max_value = value ;\n else if ( value < min_value ) min_value = value ;\n }\n if ( ( min_value == 0 ) && ( max_value == 0 ) ) scale_factor = 0 ;\n else if ( min_value == max_value ) {\n scale_factor = ( MagickRealType ) QuantumRange / min_value ;\n min_value = 0 ;\n }\n else scale_factor = ( MagickRealType ) QuantumRange / ( max_value - min_value ) ;\n }\n p = ( unsigned char * ) pixels ;\n for ( i = 0 ;\n i < ( ssize_t ) max_packets ;\n i ++ ) {\n switch ( ( int ) viff_info . data_storage_type ) {\n case VFF_TYP_2_BYTE : value = 1.0 * ( ( short * ) pixels ) [ i ] ;\n break ;\n case VFF_TYP_4_BYTE : value = 1.0 * ( ( int * ) pixels ) [ i ] ;\n break ;\n case VFF_TYP_FLOAT : value = ( ( float * ) pixels ) [ i ] ;\n break ;\n case VFF_TYP_DOUBLE : value = ( ( double * ) pixels ) [ i ] ;\n break ;\n default : value = 1.0 * pixels [ i ] ;\n break ;\n }\n if ( viff_info . map_scheme == VFF_MS_NONE ) {\n value = ( value - min_value ) * scale_factor ;\n if ( value > QuantumRange ) value = QuantumRange ;\n else if ( value < 0 ) value = 0 ;\n }\n * p = ( unsigned char ) ( ( Quantum ) value ) ;\n p ++ ;\n }\n p = ( unsigned char * ) pixels ;\n if ( viff_info . data_storage_type == VFF_TYP_BIT ) {\n if ( image -> storage_class != PseudoClass ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ;\n for ( y = 0 ;\n y < ( ssize_t ) image -> rows ;\n y ++ ) {\n q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;\n if ( q == ( PixelPacket * ) NULL ) break ;\n indexes = GetAuthenticIndexQueue ( image ) ;\n for ( x = 0 ;\n x < ( ssize_t ) ( image -> columns - 7 ) ;\n x += 8 ) {\n for ( bit = 0 ;\n bit < 8 ;\n bit ++ ) {\n quantum = ( size_t ) ( ( * p ) & ( 0x01 << bit ) ? 0 : 1 ) ;\n SetPixelRed ( q , quantum == 0 ? 0 : QuantumRange ) ;\n SetPixelGreen ( q , quantum == 0 ? 0 : QuantumRange ) ;\n SetPixelBlue ( q , quantum == 0 ? 0 : QuantumRange ) ;\n if ( image -> storage_class == PseudoClass ) SetPixelIndex ( indexes + x + bit , quantum ) ;\n }\n p ++ ;\n }\n if ( ( image -> columns % 8 ) != 0 ) {\n for ( bit = 0 ;\n bit < ( int ) ( image -> columns % 8 ) ;\n bit ++ ) {\n quantum = ( size_t ) ( ( * p ) & ( 0x01 << bit ) ? 0 : 1 ) ;\n SetPixelRed ( q , quantum == 0 ? 0 : QuantumRange ) ;\n SetPixelGreen ( q , quantum == 0 ? 0 : QuantumRange ) ;\n SetPixelBlue ( q , quantum == 0 ? 0 : QuantumRange ) ;\n if ( image -> storage_class == PseudoClass ) SetPixelIndex ( indexes + x + bit , quantum ) ;\n }\n p ++ ;\n }\n if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ;\n if ( image -> previous == ( Image * ) NULL ) {\n status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ;\n if ( status == MagickFalse ) break ;\n }\n }\n }\n else if ( image -> storage_class == PseudoClass ) for ( y = 0 ;\n y < ( ssize_t ) image -> rows ;\n y ++ ) {\n q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;\n if ( q == ( PixelPacket * ) NULL ) break ;\n indexes = GetAuthenticIndexQueue ( image ) ;\n for ( x = 0 ;\n x < ( ssize_t ) image -> columns ;\n x ++ ) SetPixelIndex ( indexes + x , * p ++ ) ;\n if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ;\n if ( image -> previous == ( Image * ) NULL ) {\n status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ;\n if ( status == MagickFalse ) break ;\n }\n }\n else {\n number_pixels = ( MagickSizeType ) image -> columns * image -> rows ;\n for ( y = 0 ;\n y < ( ssize_t ) image -> rows ;\n y ++ ) {\n q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;\n if ( q == ( PixelPacket * ) NULL ) break ;\n for ( x = 0 ;\n x < ( ssize_t ) image -> columns ;\n x ++ ) {\n SetPixelRed ( q , ScaleCharToQuantum ( * p ) ) ;\n SetPixelGreen ( q , ScaleCharToQuantum ( * ( p + number_pixels ) ) ) ;\n SetPixelBlue ( q , ScaleCharToQuantum ( * ( p + 2 * number_pixels ) ) ) ;\n if ( image -> colors != 0 ) {\n ssize_t index ;\n index = ( ssize_t ) GetPixelRed ( q ) ;\n SetPixelRed ( q , image -> colormap [ ( ssize_t ) ConstrainColormapIndex ( image , index ) ] . red ) ;\n index = ( ssize_t ) GetPixelGreen ( q ) ;\n SetPixelGreen ( q , image -> colormap [ ( ssize_t ) ConstrainColormapIndex ( image , index ) ] . green ) ;\n index = ( ssize_t ) GetPixelRed ( q ) ;\n SetPixelBlue ( q , image -> colormap [ ( ssize_t ) ConstrainColormapIndex ( image , index ) ] . blue ) ;\n }\n SetPixelOpacity ( q , image -> matte != MagickFalse ? QuantumRange - ScaleCharToQuantum ( * ( p + number_pixels * 3 ) ) : OpaqueOpacity ) ;\n p ++ ;\n q ++ ;\n }\n if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ;\n if ( image -> previous == ( Image * ) NULL ) {\n status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ;\n if ( status == MagickFalse ) break ;\n }\n }\n }\n pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ;\n if ( image -> storage_class == PseudoClass ) ( void ) SyncImage ( image ) ;\n if ( EOFBlob ( image ) != MagickFalse ) {\n ThrowFileException ( exception , CorruptImageError , \"UnexpectedEndOfFile\" , image -> filename ) ;\n break ;\n }\n if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;\n count = ReadBlob ( image , 1 , & viff_info . identifier ) ;\n if ( ( count != 0 ) && ( viff_info . identifier == 0xab ) ) {\n AcquireNextImage ( image_info , image ) ;\n if ( GetNextImageInList ( image ) == ( Image * ) NULL ) {\n image = DestroyImageList ( image ) ;\n return ( ( Image * ) NULL ) ;\n }\n image = SyncNextImageInList ( image ) ;\n status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ;\n if ( status == MagickFalse ) break ;\n }\n }\n while ( ( count != 0 ) && ( viff_info . identifier == 0xab ) ) ;\n ( void ) CloseBlob ( image ) ;\n return ( GetFirstImageInList ( image ) ) ;\n }", "idx": 22367}
{"hash": -6063487367164326236, "project": "debian", "size": 4, "label": 0, "functionSource": "static inline bool auth_principal_needs_rotating_keys ( EntityName & name ) {\n uint32_t ty ( name . get_type ( ) ) ;\n return ( ( ty == CEPH_ENTITY_TYPE_OSD ) || ( ty == CEPH_ENTITY_TYPE_MDS ) || ( ty == CEPH_ENTITY_TYPE_MGR ) ) ;\n }", "idx": 22368}
{"hash": 5357882892791796049, "project": "debian", "size": 19, "label": 0, "functionSource": "static uint32_t e1000e_rss_calc_hash ( E1000ECore * core , struct NetRxPkt * pkt , E1000E_RSSInfo * info ) {\n NetRxPktRssType type ;\n assert ( e1000e_rss_enabled ( core ) ) ;\n switch ( info -> type ) {\n case E1000_MRQ_RSS_TYPE_IPV4 : type = NetPktRssIpV4 ;\n break ;\n case E1000_MRQ_RSS_TYPE_IPV4TCP : type = NetPktRssIpV4Tcp ;\n break ;\n case E1000_MRQ_RSS_TYPE_IPV6TCP : type = NetPktRssIpV6Tcp ;\n break ;\n case E1000_MRQ_RSS_TYPE_IPV6 : type = NetPktRssIpV6 ;\n break ;\n case E1000_MRQ_RSS_TYPE_IPV6EX : type = NetPktRssIpV6Ex ;\n break ;\n default : assert ( false ) ;\n return 0 ;\n }\n return net_rx_pkt_calc_rss_hash ( pkt , type , ( uint8_t * ) & core -> mac [ RSSRK ] ) ;\n }", "idx": 22369}
{"hash": -6627217369018123590, "project": "chrome", "size": 3, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( ContentSettingBubbleDialogTest , InvokeDialog_mixed_script ) {\n RunDialog ( ) ;\n }", "idx": 22370}
{"hash": -1672864273235910388, "project": "debian", "size": 30, "label": 0, "functionSource": "inline static void _slurm_rpc_set_schedlog_level ( slurm_msg_t * msg ) {\n int schedlog_level ;\n uid_t uid = g_slurm_auth_get_uid ( msg -> auth_cred , slurmctld_config . auth_info ) ;\n slurmctld_lock_t config_read_lock = {\n READ_LOCK , NO_LOCK , NO_LOCK , NO_LOCK , NO_LOCK }\n ;\n set_debug_level_msg_t * request_msg = ( set_debug_level_msg_t * ) msg -> data ;\n log_options_t log_opts = SCHEDLOG_OPTS_INITIALIZER ;\n debug2 ( \"Processing RPC: REQUEST_SET_SCHEDLOG_LEVEL from uid=%d\" , uid ) ;\n if ( ! validate_super_user ( uid ) ) {\n error ( \"set scheduler log level request from non-super user \" \"uid=%d\" , uid ) ;\n slurm_send_rc_msg ( msg , EACCES ) ;\n return ;\n }\n if ( slurmctld_conf . sched_logfile == NULL ) {\n error ( \"set scheduler log level failed: no log file!\" ) ;\n slurm_send_rc_msg ( msg , ESLURM_DISABLED ) ;\n return ;\n }\n schedlog_level = MIN ( request_msg -> debug_level , ( LOG_LEVEL_QUIET + 1 ) ) ;\n schedlog_level = MAX ( schedlog_level , LOG_LEVEL_QUIET ) ;\n lock_slurmctld ( config_read_lock ) ;\n log_opts . logfile_level = schedlog_level ;\n sched_log_alter ( log_opts , LOG_DAEMON , slurmctld_conf . sched_logfile ) ;\n unlock_slurmctld ( config_read_lock ) ;\n if ( schedlog_level != slurmctld_conf . sched_log_level ) info ( \"sched: Set scheduler log level to %d\" , schedlog_level ) ;\n slurmctld_conf . sched_log_level = schedlog_level ;\n slurmctld_conf . last_update = time ( NULL ) ;\n slurm_send_rc_msg ( msg , SLURM_SUCCESS ) ;\n }", "idx": 22371}
{"hash": 8184523117871478575, "project": "chrome", "size": 60, "label": 0, "functionSource": "TEST ( URLFixerTest , FixupFile ) {\n base : : ScopedTempDir temp_dir_ ;\n ASSERT_TRUE ( temp_dir_ . CreateUniqueTempDir ( ) ) ;\n base : : FilePath original ;\n ASSERT_TRUE ( MakeTempFile ( temp_dir_ . GetPath ( ) , base : : FilePath ( FILE_PATH_LITERAL ( \"url fixer upper existing file.txt\" ) ) , & original ) ) ;\n GURL golden ( net : : FilePathToFileURL ( original ) ) ;\n GURL fixedup ( url_formatter : : FixupURL ( original . AsUTF8Unsafe ( ) , std : : string ( ) ) ) ;\n EXPECT_EQ ( golden , fixedup ) ;\n # if defined ( OS_WIN ) std : : string cur ( base : : WideToUTF8 ( original . value ( ) ) ) ;\n EXPECT_EQ ( ':' , cur [ 1 ] ) ;\n cur [ 1 ] = '|' ;\n EXPECT_EQ ( golden , url_formatter : : FixupURL ( cur , std : : string ( ) ) ) ;\n FixupCase cases [ ] = {\n {\n \"c:\\\\Non-existent%20file.txt\" , \"file:///C:/Non-existent%2520file.txt\" }\n , {\n \"\\\\\\\\NonexistentHost\\\\foo\\\\bar.txt\" , \"file:/onexistenthost/foo/bar.txt\" }\n , {\n \"//NonexistentHost\\\\foo/bar.txt\" , \"http:/onexistenthost/foo/bar.txt\" }\n , {\n \"file:///C:/foo/bar\" , \"file:///C:/foo/bar\" }\n , {\n \"file://C:/foo/bar\" , \"file:///C:/foo/bar\" }\n , {\n \"file:c:\" , \"file:///C:/\" }\n , {\n \"file:c:WINDOWS\" , \"file:///C:/WINDOWS\" }\n , {\n \"file:c|Program Files\" , \"file:///C:/Program%20Files\" }\n , {\n \"file:/file\" , \"file://file/\" }\n , {\n \"file:////////c:\\\\foo\" , \"file:///C:/foo\" }\n , {\n \"file://server/folder/file\" , \"file://server/folder/file\" }\n , }\n ;\n # elif defined ( OS_POSIX ) # if defined ( OS_MACOSX ) # define HOME \"/Users/\" # else # define HOME \"/home/\" # endif url_formatter : : home_directory_override = \"/foo\" ;\n FixupCase cases [ ] = {\n {\n \"/A%20non-existent file.txt\" , \"file:///A%2520non-existent%20file.txt\" }\n , {\n \"/\" , \"file:///\" }\n , {\n \"~\" , \"file:///foo\" }\n , {\n \"~/bar\" , \"file:///foo/bar\" }\n , {\n \"~foo\" , \"file://\" HOME \"foo\" }\n , {\n \"~x/blah\" , \"file://\" HOME \"x/blah\" }\n , }\n ;\n # endif for ( size_t i = 0 ;\n i < arraysize ( cases ) ;\n i ++ ) {\n EXPECT_EQ ( cases [ i ] . output , url_formatter : : FixupURL ( cases [ i ] . input , std : : string ( ) ) . possibly_invalid_spec ( ) ) ;\n }\n EXPECT_TRUE ( base : : DeleteFile ( original , false ) ) ;\n }", "idx": 22372}
{"hash": 1504508151056681409, "project": "debian", "size": 27, "label": 0, "functionSource": "static int header_bin_le ( struct archive_read * a , struct cpio * cpio , struct archive_entry * entry , size_t * namelength , size_t * name_pad ) {\n const void * h ;\n const unsigned char * header ;\n a -> archive . archive_format = ARCHIVE_FORMAT_CPIO_BIN_LE ;\n a -> archive . archive_format_name = \"cpio (little-endian binary)\" ;\n h = __archive_read_ahead ( a , bin_header_size , NULL ) ;\n if ( h == NULL ) {\n archive_set_error ( & a -> archive , 0 , \"End of file trying to read next cpio header\" ) ;\n return ( ARCHIVE_FATAL ) ;\n }\n header = ( const unsigned char * ) h ;\n archive_entry_set_dev ( entry , header [ bin_dev_offset ] + header [ bin_dev_offset + 1 ] * 256 ) ;\n archive_entry_set_ino ( entry , header [ bin_ino_offset ] + header [ bin_ino_offset + 1 ] * 256 ) ;\n archive_entry_set_mode ( entry , header [ bin_mode_offset ] + header [ bin_mode_offset + 1 ] * 256 ) ;\n archive_entry_set_uid ( entry , header [ bin_uid_offset ] + header [ bin_uid_offset + 1 ] * 256 ) ;\n archive_entry_set_gid ( entry , header [ bin_gid_offset ] + header [ bin_gid_offset + 1 ] * 256 ) ;\n archive_entry_set_nlink ( entry , header [ bin_nlink_offset ] + header [ bin_nlink_offset + 1 ] * 256 ) ;\n archive_entry_set_rdev ( entry , header [ bin_rdev_offset ] + header [ bin_rdev_offset + 1 ] * 256 ) ;\n archive_entry_set_mtime ( entry , le4 ( header + bin_mtime_offset ) , 0 ) ;\n * namelength = header [ bin_namesize_offset ] + header [ bin_namesize_offset + 1 ] * 256 ;\n * name_pad = * namelength & 1 ;\n cpio -> entry_bytes_remaining = le4 ( header + bin_filesize_offset ) ;\n archive_entry_set_size ( entry , cpio -> entry_bytes_remaining ) ;\n cpio -> entry_padding = cpio -> entry_bytes_remaining & 1 ;\n __archive_read_consume ( a , bin_header_size ) ;\n return ( ARCHIVE_OK ) ;\n }", "idx": 22373}
{"hash": -6245610163896160314, "project": "debian", "size": 35, "label": 0, "functionSource": "static uint64_t malta_fpga_read ( void * opaque , hwaddr addr , unsigned size ) {\n MaltaFPGAState * s = opaque ;\n uint32_t val = 0 ;\n uint32_t saddr ;\n saddr = ( addr & 0xfffff ) ;\n switch ( saddr ) {\n case 0x00200 : val = 0x00000000 ;\n break ;\n case 0x00208 : # ifdef TARGET_WORDS_BIGENDIAN val = 0x00000012 ;\n # else val = 0x00000010 ;\n # endif break ;\n case 0x00210 : val = 0x00 ;\n break ;\n case 0x00408 : val = s -> leds ;\n break ;\n case 0x00508 : val = s -> brk ;\n break ;\n case 0x00a00 : val = s -> gpout ;\n break ;\n case 0x00a08 : if ( s -> i2csel ) val = s -> i2cout ;\n else val = 0x00 ;\n break ;\n case 0x00b00 : val = ( ( s -> i2cin & ~ 1 ) | eeprom24c0x_read ( ) ) ;\n break ;\n case 0x00b08 : val = s -> i2coe ;\n break ;\n case 0x00b10 : val = s -> i2cout ;\n break ;\n case 0x00b18 : val = s -> i2csel ;\n break ;\n default : # if 0 printf ( \"malta_fpga_read: Bad register offset 0x\" TARGET_FMT_lx \"\\n\" , addr ) ;\n # endif break ;\n }\n return val ;\n }", "idx": 22374}
{"hash": -1270180049246846366, "project": "chrome", "size": 3, "label": 0, "functionSource": "hb_face_t * hb_face_reference ( hb_face_t * face ) {\n return hb_object_reference ( face ) ;\n }", "idx": 22375}
{"hash": 1458662858915721428, "project": "debian", "size": 26, "label": 0, "functionSource": "static inline void tb_jmp_remove ( TranslationBlock * tb , int n ) {\n TranslationBlock * tb1 , * * ptb ;\n unsigned int n1 ;\n ptb = & tb -> jmp_next [ n ] ;\n tb1 = * ptb ;\n if ( tb1 ) {\n for ( ;\n ;\n ) {\n tb1 = * ptb ;\n n1 = ( uintptr_t ) tb1 & 3 ;\n tb1 = ( TranslationBlock * ) ( ( uintptr_t ) tb1 & ~ 3 ) ;\n if ( n1 == n && tb1 == tb ) {\n break ;\n }\n if ( n1 == 2 ) {\n ptb = & tb1 -> jmp_first ;\n }\n else {\n ptb = & tb1 -> jmp_next [ n1 ] ;\n }\n }\n * ptb = tb -> jmp_next [ n ] ;\n tb -> jmp_next [ n ] = NULL ;\n }\n }", "idx": 22376}
{"hash": 2521579609370336371, "project": "debian", "size": 23, "label": 0, "functionSource": "int dtls1_send_server_certificate ( SSL * s ) {\n unsigned long l ;\n X509 * x ;\n if ( s -> state == SSL3_ST_SW_CERT_A ) {\n x = ssl_get_server_send_cert ( s ) ;\n if ( x == NULL ) {\n if ( ( s -> s3 -> tmp . new_cipher -> algorithm_mkey != SSL_kKRB5 ) || ( s -> s3 -> tmp . new_cipher -> algorithm_auth != SSL_aKRB5 ) ) {\n SSLerr ( SSL_F_DTLS1_SEND_SERVER_CERTIFICATE , ERR_R_INTERNAL_ERROR ) ;\n return ( 0 ) ;\n }\n }\n l = dtls1_output_cert_chain ( s , x ) ;\n if ( ! l ) {\n SSLerr ( SSL_F_DTLS1_SEND_SERVER_CERTIFICATE , ERR_R_INTERNAL_ERROR ) ;\n return ( 0 ) ;\n }\n s -> state = SSL3_ST_SW_CERT_B ;\n s -> init_num = ( int ) l ;\n s -> init_off = 0 ;\n dtls1_buffer_message ( s , 0 ) ;\n }\n return ( dtls1_do_write ( s , SSL3_RT_HANDSHAKE ) ) ;\n }", "idx": 22377}
{"hash": -3062453801436404700, "project": "debian", "size": 18, "label": 1, "functionSource": "static ossl_inline void sk_ ## t1 ## _sort ( STACK_OF ( t1 ) * sk ) {\n OPENSSL_sk_sort ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline int sk_ ## t1 ## _is_sorted ( const STACK_OF ( t1 ) * sk ) {\n return OPENSSL_sk_is_sorted ( ( const OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _dup ( const STACK_OF ( t1 ) * sk ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_dup ( ( const OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _deep_copy ( const STACK_OF ( t1 ) * sk , sk_ ## t1 ## _copyfunc copyfunc , sk_ ## t1 ## _freefunc freefunc ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_deep_copy ( ( const OPENSSL_STACK * ) sk , ( OPENSSL_sk_copyfunc ) copyfunc , ( OPENSSL_sk_freefunc ) freefunc ) ;\n }\n static ossl_inline sk_ ## t1 ## _compfunc sk_ ## t1 ## _set_cmp_func ( STACK_OF ( t1 ) * sk , sk_ ## t1 ## _compfunc compare ) {\n return ( sk_ ## t1 ## _compfunc ) OPENSSL_sk_set_cmp_func ( ( OPENSSL_STACK * ) sk , ( OPENSSL_sk_compfunc ) compare ) ;\n }\n # define DEFINE_SPECIAL_STACK_OF ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , t2 , t2 ) # define DEFINE_STACK_OF ( t ) SKM_DEFINE_STACK_OF ( t , t , t ) # define DEFINE_SPECIAL_STACK_OF_CONST ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , const t2 , t2 ) # define DEFINE_STACK_OF_CONST ( t ) SKM_DEFINE_STACK_OF ( t , const t , t ) typedef char * OPENSSL_STRING ;\n typedef const char * OPENSSL_CSTRING ;\n DEFINE_SPECIAL_STACK_OF ( OPENSSL_STRING , char )", "idx": 22378}
{"hash": 6632536031698733342, "project": "debian", "size": 26, "label": 0, "functionSource": "static void writer_print_data ( WriterContext * wctx , const char * name , uint8_t * data , int size ) {\n AVBPrint bp ;\n int offset = 0 , l , i ;\n av_bprint_init ( & bp , 0 , AV_BPRINT_SIZE_UNLIMITED ) ;\n av_bprintf ( & bp , \"\\n\" ) ;\n while ( size ) {\n av_bprintf ( & bp , \"%08x: \" , offset ) ;\n l = FFMIN ( size , 16 ) ;\n for ( i = 0 ;\n i < l ;\n i ++ ) {\n av_bprintf ( & bp , \"%02x\" , data [ i ] ) ;\n if ( i & 1 ) av_bprintf ( & bp , \" \" ) ;\n }\n av_bprint_chars ( & bp , ' ' , 41 - 2 * i - i / 2 ) ;\n for ( i = 0 ;\n i < l ;\n i ++ ) av_bprint_chars ( & bp , data [ i ] - 32U < 95 ? data [ i ] : '.' , 1 ) ;\n av_bprintf ( & bp , \"\\n\" ) ;\n offset += l ;\n data += l ;\n size -= l ;\n }\n writer_print_string ( wctx , name , bp . str , 0 ) ;\n av_bprint_finalize ( & bp , NULL ) ;\n }", "idx": 22379}
{"hash": 4715922168896528064, "project": "debian", "size": 69, "label": 0, "functionSource": "void jpc_qmfb_join_colgrp ( jpc_fix_t * a , int numrows , int stride , int parity ) {\n int bufsize = JPC_CEILDIVPOW2 ( numrows , 1 ) ;\n jpc_fix_t joinbuf [ QMFB_JOINBUFSIZE * JPC_QMFB_COLGRPSIZE ] ;\n jpc_fix_t * buf = joinbuf ;\n jpc_fix_t * srcptr ;\n jpc_fix_t * dstptr ;\n register jpc_fix_t * srcptr2 ;\n register jpc_fix_t * dstptr2 ;\n register int n ;\n register int i ;\n int hstartcol ;\n if ( bufsize > QMFB_JOINBUFSIZE ) {\n if ( ! ( buf = jas_alloc3 ( bufsize , JPC_QMFB_COLGRPSIZE , sizeof ( jpc_fix_t ) ) ) ) {\n abort ( ) ;\n }\n }\n hstartcol = ( numrows + 1 - parity ) >> 1 ;\n n = hstartcol ;\n srcptr = & a [ 0 ] ;\n dstptr = buf ;\n while ( n -- > 0 ) {\n dstptr2 = dstptr ;\n srcptr2 = srcptr ;\n for ( i = 0 ;\n i < JPC_QMFB_COLGRPSIZE ;\n ++ i ) {\n * dstptr2 = * srcptr2 ;\n ++ dstptr2 ;\n ++ srcptr2 ;\n }\n srcptr += stride ;\n dstptr += JPC_QMFB_COLGRPSIZE ;\n }\n srcptr = & a [ hstartcol * stride ] ;\n dstptr = & a [ ( 1 - parity ) * stride ] ;\n n = numrows - hstartcol ;\n while ( n -- > 0 ) {\n dstptr2 = dstptr ;\n srcptr2 = srcptr ;\n for ( i = 0 ;\n i < JPC_QMFB_COLGRPSIZE ;\n ++ i ) {\n * dstptr2 = * srcptr2 ;\n ++ dstptr2 ;\n ++ srcptr2 ;\n }\n dstptr += 2 * stride ;\n srcptr += stride ;\n }\n srcptr = buf ;\n dstptr = & a [ parity * stride ] ;\n n = hstartcol ;\n while ( n -- > 0 ) {\n dstptr2 = dstptr ;\n srcptr2 = srcptr ;\n for ( i = 0 ;\n i < JPC_QMFB_COLGRPSIZE ;\n ++ i ) {\n * dstptr2 = * srcptr2 ;\n ++ dstptr2 ;\n ++ srcptr2 ;\n }\n dstptr += 2 * stride ;\n srcptr += JPC_QMFB_COLGRPSIZE ;\n }\n if ( buf != joinbuf ) {\n jas_free ( buf ) ;\n }\n }", "idx": 22380}
{"hash": 4715922168896528064, "project": "debian", "size": 45, "label": 0, "functionSource": "void jpc_ft_invlift_row ( jpc_fix_t * a , int numcols , int parity ) {\n register jpc_fix_t * lptr ;\n register jpc_fix_t * hptr ;\n register int n ;\n int llen ;\n llen = ( numcols + 1 - parity ) >> 1 ;\n if ( numcols > 1 ) {\n lptr = & a [ 0 ] ;\n hptr = & a [ llen ] ;\n if ( ! parity ) {\n lptr [ 0 ] -= jpc_fix_asr ( hptr [ 0 ] + 1 , 1 ) ;\n ++ lptr ;\n }\n n = llen - ( ! parity ) - ( parity != ( numcols & 1 ) ) ;\n while ( n -- > 0 ) {\n lptr [ 0 ] -= jpc_fix_asr ( hptr [ 0 ] + hptr [ 1 ] + 2 , 2 ) ;\n ++ lptr ;\n ++ hptr ;\n }\n if ( parity != ( numcols & 1 ) ) {\n lptr [ 0 ] -= jpc_fix_asr ( hptr [ 0 ] + 1 , 1 ) ;\n }\n lptr = & a [ 0 ] ;\n hptr = & a [ llen ] ;\n if ( parity ) {\n hptr [ 0 ] += lptr [ 0 ] ;\n ++ hptr ;\n }\n n = numcols - llen - parity - ( parity == ( numcols & 1 ) ) ;\n while ( n -- > 0 ) {\n hptr [ 0 ] += jpc_fix_asr ( lptr [ 0 ] + lptr [ 1 ] , 1 ) ;\n ++ hptr ;\n ++ lptr ;\n }\n if ( parity == ( numcols & 1 ) ) {\n hptr [ 0 ] += lptr [ 0 ] ;\n }\n }\n else {\n if ( parity ) {\n lptr = & a [ 0 ] ;\n lptr [ 0 ] = jpc_fix_asr ( lptr [ 0 ] , 1 ) ;\n }\n }\n }", "idx": 22381}
{"hash": 2546373479020365143, "project": "debian", "size": 17, "label": 0, "functionSource": "inline void mime_hdr_reset_accelerators_and_presence_bits ( MIMEHdrImpl * mh ) {\n mime_hdr_init_accelerators_and_presence_bits ( mh ) ;\n for ( MIMEFieldBlockImpl * fblock = & ( mh -> m_first_fblock ) ;\n fblock != nullptr ;\n fblock = fblock -> m_next ) {\n for ( MIMEField * field = fblock -> m_field_slots , * limit = field + fblock -> m_freetop ;\n field < limit ;\n ++ field ) {\n if ( field -> is_live ( ) ) {\n field -> m_wks_idx = hdrtoken_tokenize ( field -> m_ptr_name , field -> m_len_name ) ;\n if ( field -> is_dup_head ( ) ) {\n mime_hdr_set_accelerators_and_presence_bits ( mh , field ) ;\n }\n }\n }\n }\n }", "idx": 22382}
{"hash": -7855974557509681261, "project": "debian", "size": 9, "label": 0, "functionSource": "float4 get_func_rows ( Oid funcid ) {\n HeapTuple tp ;\n float4 result ;\n tp = SearchSysCache1 ( PROCOID , ObjectIdGetDatum ( funcid ) ) ;\n if ( ! HeapTupleIsValid ( tp ) ) elog ( ERROR , \"cache lookup failed for function %u\" , funcid ) ;\n result = ( ( Form_pg_proc ) GETSTRUCT ( tp ) ) -> prorows ;\n ReleaseSysCache ( tp ) ;\n return result ;\n }", "idx": 22383}
{"hash": 8035933693347914822, "project": "debian", "size": 4, "label": 0, "functionSource": "void proto_reg_handoff_opcua ( void ) {\n opcua_handle = create_dissector_handle ( dissect_opcua , proto_opcua ) ;\n dissector_add_uint_range_with_preference ( \"tcp.port\" , OPCUA_PORT_RANGE , opcua_handle ) ;\n }", "idx": 22384}
{"hash": 1182028467273264883, "project": "debian", "size": 5, "label": 0, "functionSource": "FILE * my_popen ( DYNAMIC_STRING * ds_cmd , const char * mode ) {\n # if defined __WIN__ && defined USE_CYGWIN str_to_file ( tmp_sh_name , ds_cmd -> str , ds_cmd -> length ) ;\n return popen ( tmp_sh_cmd , mode ) ;\n # else return popen ( ds_cmd -> str , mode ) ;\n # endif }", "idx": 22385}
{"hash": 1182028467273264883, "project": "debian", "size": 5, "label": 0, "functionSource": "void free_sets ( REP_SETS * sets ) {\n my_free ( sets -> set_buffer ) ;\n my_free ( sets -> bit_buffer ) ;\n return ;\n }", "idx": 22386}
{"hash": -2654475221056024278, "project": "debian", "size": 8, "label": 1, "functionSource": "static void process_blob ( struct rev_info * revs , struct blob * blob , show_object_fn show , struct name_path * path , const char * name , void * cb_data ) {\n struct object * obj = & blob -> object ;\n if ( ! revs -> blob_objects ) return ;\n if ( ! obj ) die ( \"bad blob object\" ) ;\n if ( obj -> flags & ( UNINTERESTING | SEEN ) ) return ;\n obj -> flags |= SEEN ;\n show ( obj , path , name , cb_data ) ;\n }", "idx": 22387}
{"hash": -4555950263653671147, "project": "debian", "size": 9, "label": 0, "functionSource": "static PyObject * string_rindex ( PyStringObject * self , PyObject * args ) {\n Py_ssize_t result = string_find_internal ( self , args , - 1 ) ;\n if ( result == - 2 ) return NULL ;\n if ( result == - 1 ) {\n PyErr_SetString ( PyExc_ValueError , \"substring not found\" ) ;\n return NULL ;\n }\n return PyInt_FromSsize_t ( result ) ;\n }", "idx": 22388}
{"hash": 8849962823026424130, "project": "debian", "size": 24, "label": 0, "functionSource": "static ssize_t qio_channel_websock_write_wire ( QIOChannelWebsock * ioc , Error * * errp ) {\n ssize_t ret ;\n ssize_t done = 0 ;\n if ( ! ioc -> ping_reply . offset ) {\n qio_channel_websock_encode ( ioc ) ;\n }\n else if ( ! ioc -> encoutput . offset ) {\n buffer_move_empty ( & ioc -> encoutput , & ioc -> ping_reply ) ;\n }\n while ( ioc -> encoutput . offset > 0 ) {\n ret = qio_channel_write ( ioc -> master , ( char * ) ioc -> encoutput . buffer , ioc -> encoutput . offset , errp ) ;\n if ( ret < 0 ) {\n if ( ret == QIO_CHANNEL_ERR_BLOCK && done > 0 ) {\n return done ;\n }\n else {\n return ret ;\n }\n }\n buffer_advance ( & ioc -> encoutput , ret ) ;\n done += ret ;\n }\n return done ;\n }", "idx": 22389}
{"hash": 378220832151730865, "project": "debian", "size": 44, "label": 0, "functionSource": "int qemuMonitorTextGetPtyPaths ( qemuMonitorPtr mon , virHashTablePtr paths ) {\n char * reply = NULL ;\n int ret = - 1 ;\n if ( qemuMonitorHMPCommand ( mon , \"info chardev\" , & reply ) < 0 ) {\n qemuReportError ( VIR_ERR_OPERATION_FAILED , \"%s\" , _ ( \"failed to retrieve chardev info in qemu with 'info chardev'\" ) ) ;\n return - 1 ;\n }\n char * pos ;\n char * next = reply ;\n char * eol ;\n char * end = reply + strlen ( reply ) ;\n while ( next ) {\n pos = next ;\n eol = memchr ( pos , '\\n' , end - pos ) ;\n if ( eol == NULL ) {\n eol = end ;\n next = NULL ;\n }\n else {\n next = eol + 1 ;\n }\n while ( eol > pos && c_isspace ( * ( eol - 1 ) ) ) eol -= 1 ;\n # define NEEDLE \"filename=pty:\" char * needle = memmem ( pos , eol - pos , NEEDLE , strlen ( NEEDLE ) ) ;\n if ( ! needle ) continue ;\n char * colon = memchr ( pos , ':' , needle - pos ) ;\n if ( colon == NULL ) continue ;\n * colon = '\\0' ;\n char * id = pos ;\n * eol = '\\0' ;\n char * path = strdup ( needle + strlen ( NEEDLE ) ) ;\n if ( path == NULL ) {\n virReportOOMError ( ) ;\n goto cleanup ;\n }\n if ( virHashAddEntry ( paths , id , path ) < 0 ) {\n qemuReportError ( VIR_ERR_OPERATION_FAILED , _ ( \"failed to save chardev path '%s'\" ) , path ) ;\n VIR_FREE ( path ) ;\n goto cleanup ;\n }\n # undef NEEDLE }\n ret = 0 ;\n cleanup : VIR_FREE ( reply ) ;\n return ret ;\n }", "idx": 22390}
{"hash": 7092216800726729686, "project": "debian", "size": 17, "label": 0, "functionSource": "static int dissect_h245_T_returnedFunction ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 990 \"../../asn1/h245/h245.cnf\" tvbuff_t * next_tvb = NULL ;\n proto_item * item ;\n proto_tree * subtree ;\n h245_packet_info * saved_h245_pi ;\n offset = dissect_per_octet_string ( tvb , offset , actx , tree , hf_index , NO_BOUND , NO_BOUND , FALSE , & next_tvb ) ;\n if ( next_tvb && tvb_length ( next_tvb ) ) {\n saved_h245_pi = h245_pi ;\n h245_pi = NULL ;\n item = proto_tree_add_text ( tree , next_tvb , 0 , - 1 , \"The returned function\" ) ;\n subtree = proto_item_add_subtree ( item , ett_h245_returnedFunction ) ;\n PROTO_ITEM_SET_GENERATED ( item ) ;\n dissect_h245_MultimediaSystemControlMessage ( next_tvb , 0 , actx , subtree , hf_h245_pdu_type ) ;\n h245_pi = saved_h245_pi ;\n }\n return offset ;\n }", "idx": 22391}
{"hash": -2325305888478261876, "project": "debian", "size": 16, "label": 0, "functionSource": "void add_event ( tm_event_t event , tm_node_id node , int type , void * info ) {\n event_info * ep , * * head ;\n ep = ( event_info * ) calloc ( 1 , sizeof ( event_info ) ) ;\n assert ( ep != NULL ) ;\n head = & event_hash [ event % EVENT_HASH ] ;\n ep -> e_event = event ;\n ep -> e_node = node ;\n ep -> e_mtype = type ;\n ep -> e_info = info ;\n ep -> e_next = * head ;\n ep -> e_prev = NULL ;\n if ( * head ) ( * head ) -> e_prev = ep ;\n * head = ep ;\n event_count ++ ;\n return ;\n }", "idx": 22392}
{"hash": -1315695702746584250, "project": "debian", "size": 3, "label": 0, "functionSource": "proto_item * proto_tree_add_bitmask ( proto_tree * parent_tree , tvbuff_t * tvb , const guint offset , const int hf_hdr , const gint ett , const int * * fields , const guint encoding ) {\n return proto_tree_add_bitmask_with_flags ( parent_tree , tvb , offset , hf_hdr , ett , fields , encoding , BMT_NO_INT | BMT_NO_TFS ) ;\n }", "idx": 22393}
{"hash": 3599206110384554647, "project": "debian", "size": 31, "label": 0, "functionSource": "static ossl_inline int sk_ ## t1 ## _insert ( STACK_OF ( t1 ) * sk , t2 * ptr , int idx ) {\n return OPENSSL_sk_insert ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr , idx ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _set ( STACK_OF ( t1 ) * sk , int idx , t2 * ptr ) {\n return ( t2 * ) OPENSSL_sk_set ( ( OPENSSL_STACK * ) sk , idx , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _find ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_find ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _find_ex ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_find_ex ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline void sk_ ## t1 ## _sort ( STACK_OF ( t1 ) * sk ) {\n OPENSSL_sk_sort ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline int sk_ ## t1 ## _is_sorted ( const STACK_OF ( t1 ) * sk ) {\n return OPENSSL_sk_is_sorted ( ( const OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _dup ( const STACK_OF ( t1 ) * sk ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_dup ( ( const OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _deep_copy ( const STACK_OF ( t1 ) * sk , sk_ ## t1 ## _copyfunc copyfunc , sk_ ## t1 ## _freefunc freefunc ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_deep_copy ( ( const OPENSSL_STACK * ) sk , ( OPENSSL_sk_copyfunc ) copyfunc , ( OPENSSL_sk_freefunc ) freefunc ) ;\n }\n static ossl_inline sk_ ## t1 ## _compfunc sk_ ## t1 ## _set_cmp_func ( STACK_OF ( t1 ) * sk , sk_ ## t1 ## _compfunc compare ) {\n return ( sk_ ## t1 ## _compfunc ) OPENSSL_sk_set_cmp_func ( ( OPENSSL_STACK * ) sk , ( OPENSSL_sk_compfunc ) compare ) ;\n }\n # define DEFINE_SPECIAL_STACK_OF ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , t2 , t2 ) # define DEFINE_STACK_OF ( t ) SKM_DEFINE_STACK_OF ( t , t , t ) # define DEFINE_SPECIAL_STACK_OF_CONST ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , const t2 , t2 ) # define DEFINE_STACK_OF_CONST ( t ) SKM_DEFINE_STACK_OF ( t , const t , t ) typedef char * OPENSSL_STRING ;\n typedef const char * OPENSSL_CSTRING ;\n DEFINE_SPECIAL_STACK_OF ( OPENSSL_STRING , char ) DEFINE_SPECIAL_STACK_OF_CONST ( OPENSSL_CSTRING , char ) typedef void * OPENSSL_BLOCK ;\n DEFINE_SPECIAL_STACK_OF ( OPENSSL_BLOCK , void )", "idx": 22394}
{"hash": -9032389459913766398, "project": "debian", "size": 6, "label": 0, "functionSource": "static inline void ipv6_addr_set ( struct in6_addr * addr , __be32 w1 , __be32 w2 , __be32 w3 , __be32 w4 ) {\n addr -> s6_addr32 [ 0 ] = w1 ;\n addr -> s6_addr32 [ 1 ] = w2 ;\n addr -> s6_addr32 [ 2 ] = w3 ;\n addr -> s6_addr32 [ 3 ] = w4 ;\n }", "idx": 22395}
{"hash": -2928324134072492299, "project": "debian", "size": 4, "label": 0, "functionSource": "void remove_tap_listener_rtp ( void ) {\n remove_tap_listener ( & ( the_tapinfo_rtp_struct . rtp_dummy ) ) ;\n have_RTP_tap_listener = FALSE ;\n }", "idx": 22396}
{"hash": 3887066622454352196, "project": "chrome", "size": 25, "label": 1, "functionSource": "static void txfm_rd_in_plane ( MACROBLOCK * x , int * rate , int64_t * distortion , int * skippable , int64_t * sse , int64_t ref_best_rd , int plane , BLOCK_SIZE bsize , TX_SIZE tx_size , int use_fast_coef_casting ) {\n MACROBLOCKD * const xd = & x -> e_mbd ;\n const struct macroblockd_plane * const pd = & xd -> plane [ plane ] ;\n struct rdcost_block_args args ;\n vp9_zero ( args ) ;\n args . x = x ;\n args . best_rd = ref_best_rd ;\n args . use_fast_coef_costing = use_fast_coef_casting ;\n if ( plane == 0 ) xd -> mi [ 0 ] -> mbmi . tx_size = tx_size ;\n vp9_get_entropy_contexts ( bsize , tx_size , pd , args . t_above , args . t_left ) ;\n args . so = get_scan ( xd , tx_size , pd -> plane_type , 0 ) ;\n vp9_foreach_transformed_block_in_plane ( xd , bsize , plane , block_rd_txfm , & args ) ;\n if ( args . skip ) {\n * rate = INT_MAX ;\n * distortion = INT64_MAX ;\n * sse = INT64_MAX ;\n * skippable = 0 ;\n }\n else {\n * distortion = args . this_dist ;\n * rate = args . this_rate ;\n * sse = args . this_sse ;\n * skippable = vp9_is_skippable_in_plane ( x , bsize , plane ) ;\n }\n }", "idx": 22397}
{"hash": -3135212895432241239, "project": "debian", "size": 10, "label": 0, "functionSource": "static guint32 dissect_netb_data_first_middle ( tvbuff_t * tvb , packet_info * pinfo _U_ , int offset , proto_tree * tree ) {\n guint8 remote_session , local_session ;\n netbios_data_first_middle_flags ( tvb , tree , offset + NB_FLAGS ) ;\n nb_resync_indicator ( tvb , offset , tree , \"DATA FIRST MIDDLE\" ) ;\n nb_xmit_corrl ( tvb , offset , tree ) ;\n nb_resp_corrl ( tvb , offset , tree ) ;\n remote_session = nb_remote_session ( tvb , offset , tree ) ;\n local_session = nb_local_session ( tvb , offset , tree ) ;\n return ( remote_session << 8 ) + local_session ;\n }", "idx": 22398}
{"hash": -2127895299879503273, "project": "debian", "size": 6, "label": 0, "functionSource": "static void pmac_ide_flush ( DBDMA_io * io ) {\n MACIOIDEState * m = io -> opaque ;\n if ( m -> aiocb ) {\n blk_drain_all ( ) ;\n }\n }", "idx": 22399}
{"hash": 1700977331036764538, "project": "debian", "size": 5, "label": 0, "functionSource": "int EVP_CIPHER_CTX_rand_key ( EVP_CIPHER_CTX * ctx , unsigned char * key ) {\n if ( ctx -> cipher -> flags & EVP_CIPH_RAND_KEY ) return EVP_CIPHER_CTX_ctrl ( ctx , EVP_CTRL_RAND_KEY , 0 , key ) ;\n if ( RAND_bytes ( key , ctx -> key_len ) <= 0 ) return 0 ;\n return 1 ;\n }", "idx": 22400}
{"hash": -6872005221209485070, "project": "chrome", "size": 39, "label": 0, "functionSource": "static void decFinalize ( decNumber * dn , decContext * set , Int * residue , uInt * status ) {\n Int shift ;\n Int tinyexp = set -> emin - dn -> digits + 1 ;\n if ( dn -> exponent <= tinyexp ) {\n Int comp ;\n decNumber nmin ;\n if ( dn -> exponent < tinyexp ) {\n decSetSubnormal ( dn , set , residue , status ) ;\n return ;\n }\n uprv_decNumberZero ( & nmin ) ;\n nmin . lsu [ 0 ] = 1 ;\n nmin . exponent = set -> emin ;\n comp = decCompare ( dn , & nmin , 1 ) ;\n if ( comp == BADINT ) {\n * status |= DEC_Insufficient_storage ;\n return ;\n }\n if ( * residue < 0 && comp == 0 ) {\n decApplyRound ( dn , set , * residue , status ) ;\n decSetSubnormal ( dn , set , residue , status ) ;\n return ;\n }\n }\n if ( * residue != 0 ) decApplyRound ( dn , set , * residue , status ) ;\n if ( dn -> exponent <= set -> emax - set -> digits + 1 ) return ;\n if ( dn -> exponent > set -> emax - dn -> digits + 1 ) {\n decSetOverflow ( dn , set , status ) ;\n return ;\n }\n if ( ! set -> clamp ) return ;\n shift = dn -> exponent - ( set -> emax - set -> digits + 1 ) ;\n if ( ! ISZERO ( dn ) ) {\n dn -> digits = decShiftToMost ( dn -> lsu , dn -> digits , shift ) ;\n }\n dn -> exponent -= shift ;\n * status |= DEC_Clamped ;\n return ;\n }", "idx": 22401}
{"hash": -6359684484462176044, "project": "debian", "size": 11, "label": 0, "functionSource": "int EC_GROUP_get_pentanomial_basis ( const EC_GROUP * group , unsigned int * k1 , unsigned int * k2 , unsigned int * k3 ) {\n if ( group == NULL ) return 0 ;\n if ( EC_GROUP_method_of ( group ) -> group_set_curve != ec_GF2m_simple_group_set_curve || ! ( ( group -> poly [ 0 ] != 0 ) && ( group -> poly [ 1 ] != 0 ) && ( group -> poly [ 2 ] != 0 ) && ( group -> poly [ 3 ] != 0 ) && ( group -> poly [ 4 ] == 0 ) ) ) {\n ECerr ( EC_F_EC_GROUP_GET_PENTANOMIAL_BASIS , ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED ) ;\n return 0 ;\n }\n if ( k1 ) * k1 = group -> poly [ 3 ] ;\n if ( k2 ) * k2 = group -> poly [ 2 ] ;\n if ( k3 ) * k3 = group -> poly [ 1 ] ;\n return 1 ;\n }", "idx": 22402}
{"hash": 1700977331036764538, "project": "debian", "size": 4, "label": 0, "functionSource": "int EVP_CipherFinal_ex ( EVP_CIPHER_CTX * ctx , unsigned char * out , int * outl ) {\n if ( ctx -> encrypt ) return EVP_EncryptFinal_ex ( ctx , out , outl ) ;\n else return EVP_DecryptFinal_ex ( ctx , out , outl ) ;\n }", "idx": 22403}
{"hash": 4876100961671882393, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_pvfs2_getattr_response ( tvbuff_t * tvb , proto_tree * tree , int offset , packet_info * pinfo ) {\n offset = dissect_pvfs_object_attr ( tvb , tree , offset , pinfo ) ;\n return offset ;\n }", "idx": 22404}
{"hash": 1105505185808271410, "project": "debian", "size": 85, "label": 0, "functionSource": "static CURLcode glob_range ( URLGlob * glob , char * * patternp , size_t * posp , unsigned long * amount , int globindex ) {\n URLPattern * pat ;\n int rc ;\n char * pattern = * patternp ;\n char * c ;\n pat = & glob -> pattern [ glob -> size ] ;\n pat -> globindex = globindex ;\n if ( ISALPHA ( * pattern ) ) {\n char min_c ;\n char max_c ;\n int step = 1 ;\n pat -> type = UPTCharRange ;\n rc = sscanf ( pattern , \"%c-%c\" , & min_c , & max_c ) ;\n if ( ( rc == 2 ) && ( pattern [ 3 ] == ':' ) ) {\n char * endp ;\n unsigned long lstep ;\n errno = 0 ;\n lstep = strtoul ( & pattern [ 4 ] , & endp , 10 ) ;\n if ( errno || ( * endp != ']' ) ) step = - 1 ;\n else {\n pattern = endp + 1 ;\n step = ( int ) lstep ;\n if ( step > ( max_c - min_c ) ) step = - 1 ;\n }\n }\n else pattern += 4 ;\n * posp += ( pattern - * patternp ) ;\n if ( ( rc != 2 ) || ( min_c >= max_c ) || ( ( max_c - min_c ) > ( 'z' - 'a' ) ) || ( step <= 0 ) ) return GLOBERROR ( \"bad range\" , * posp , CURLE_URL_MALFORMAT ) ;\n pat -> content . CharRange . step = step ;\n pat -> content . CharRange . ptr_c = pat -> content . CharRange . min_c = min_c ;\n pat -> content . CharRange . max_c = max_c ;\n if ( multiply ( amount , ( pat -> content . CharRange . max_c - pat -> content . CharRange . min_c ) / pat -> content . CharRange . step + 1 ) ) return GLOBERROR ( \"range overflow\" , * posp , CURLE_URL_MALFORMAT ) ;\n }\n else if ( ISDIGIT ( * pattern ) ) {\n unsigned long min_n ;\n unsigned long max_n = 0 ;\n unsigned long step_n = 0 ;\n char * endp ;\n pat -> type = UPTNumRange ;\n pat -> content . NumRange . padlength = 0 ;\n if ( * pattern == '0' ) {\n c = pattern ;\n while ( ISDIGIT ( * c ) ) {\n c ++ ;\n ++ pat -> content . NumRange . padlength ;\n }\n }\n errno = 0 ;\n min_n = strtoul ( pattern , & endp , 10 ) ;\n if ( errno || ( endp == pattern ) ) endp = NULL ;\n else {\n if ( * endp != '-' ) endp = NULL ;\n else {\n pattern = endp + 1 ;\n while ( * pattern && ISBLANK ( * pattern ) ) pattern ++ ;\n if ( ! ISDIGIT ( * pattern ) ) {\n endp = NULL ;\n goto fail ;\n }\n errno = 0 ;\n max_n = strtoul ( pattern , & endp , 10 ) ;\n if ( errno || ( * endp == ':' ) ) {\n pattern = endp + 1 ;\n errno = 0 ;\n step_n = strtoul ( pattern , & endp , 10 ) ;\n if ( errno ) endp = NULL ;\n }\n else step_n = 1 ;\n if ( endp && ( * endp == ']' ) ) {\n pattern = endp + 1 ;\n }\n else endp = NULL ;\n }\n }\n fail : * posp += ( pattern - * patternp ) ;\n if ( ! endp || ( min_n > max_n ) || ( step_n > ( max_n - min_n ) ) || ! step_n ) return GLOBERROR ( \"bad range\" , * posp , CURLE_URL_MALFORMAT ) ;\n pat -> content . NumRange . ptr_n = pat -> content . NumRange . min_n = min_n ;\n pat -> content . NumRange . max_n = max_n ;\n pat -> content . NumRange . step = step_n ;\n if ( multiply ( amount , ( pat -> content . NumRange . max_n - pat -> content . NumRange . min_n ) / pat -> content . NumRange . step + 1 ) ) return GLOBERROR ( \"range overflow\" , * posp , CURLE_URL_MALFORMAT ) ;\n }\n else return GLOBERROR ( \"bad range specification\" , * posp , CURLE_URL_MALFORMAT ) ;\n * patternp = pattern ;\n return CURLE_OK ;\n }", "idx": 22405}
{"hash": 7092216800726729686, "project": "debian", "size": 16, "label": 0, "functionSource": "static int dissect_h245_T_unsignedMax ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 800 \"../../asn1/h245/h245.cnf\" guint32 value ;\n guint8 * buf ;\n tvbuff_t * value_tvb ;\n gef_ctx_t * gefx ;\n offset = dissect_per_constrained_integer ( tvb , offset , actx , tree , hf_index , 0U , 65535U , & value , FALSE ) ;\n gefx = gef_ctx_get ( actx -> private_data ) ;\n if ( gefx ) {\n buf = ( guint8 * ) wmem_new ( actx -> pinfo -> pool , guint16 ) ;\n phton16 ( buf , value ) ;\n value_tvb = tvb_new_child_real_data ( tvb , buf , sizeof ( guint16 ) , sizeof ( guint16 ) ) ;\n add_new_data_source ( actx -> pinfo , value_tvb , \"unsignedMax\" ) ;\n dissector_try_string ( gef_content_dissector_table , gefx -> key , value_tvb , actx -> pinfo , tree , actx ) ;\n }\n return offset ;\n }", "idx": 22406}
{"hash": 3576240888172463140, "project": "debian", "size": 95, "label": 0, "functionSource": "gpg_error_t keydb_add_resource ( const char * url , unsigned int flags ) {\n static int any_registered ;\n const char * resname = url ;\n char * filename = NULL ;\n int create ;\n int read_only = ! ! ( flags & KEYDB_RESOURCE_FLAG_READONLY ) ;\n int is_default = ! ! ( flags & KEYDB_RESOURCE_FLAG_DEFAULT ) ;\n int rc = 0 ;\n KeydbResourceType rt = KEYDB_RESOURCE_TYPE_NONE ;\n void * token ;\n create = ( ! read_only && ! any_registered ) ;\n if ( strlen ( resname ) > 11 && ! strncmp ( resname , \"gnupg-ring:\" , 11 ) ) {\n rt = KEYDB_RESOURCE_TYPE_KEYRING ;\n resname += 11 ;\n }\n else if ( strlen ( resname ) > 10 && ! strncmp ( resname , \"gnupg-kbx:\" , 10 ) ) {\n rt = KEYDB_RESOURCE_TYPE_KEYBOX ;\n resname += 10 ;\n }\n # if ! defined ( HAVE_DRIVE_LETTERS ) && ! defined ( __riscos__ ) else if ( strchr ( resname , ':' ) ) {\n log_error ( \"invalid key resource URL '%s'\\n\" , url ) ;\n rc = gpg_error ( GPG_ERR_GENERAL ) ;\n goto leave ;\n }\n # endif if ( * resname != DIRSEP_C ) {\n if ( strchr ( resname , DIRSEP_C ) ) filename = make_filename ( resname , NULL ) ;\n else filename = make_filename ( opt . homedir , resname , NULL ) ;\n }\n else filename = xstrdup ( resname ) ;\n if ( rt == KEYDB_RESOURCE_TYPE_NONE ) {\n int found , openpgp_flag ;\n int pass = 0 ;\n size_t filenamelen ;\n check_again : filenamelen = strlen ( filename ) ;\n rt = rt_from_file ( filename , & found , & openpgp_flag ) ;\n if ( found ) {\n if ( ! pass && is_default && rt == KEYDB_RESOURCE_TYPE_KEYRING && filenamelen > 4 && ! strcmp ( filename + filenamelen - 4 , \".gpg\" ) ) {\n strcpy ( filename + filenamelen - 4 , \".kbx\" ) ;\n if ( ( rt_from_file ( filename , & found , & openpgp_flag ) == KEYDB_RESOURCE_TYPE_KEYBOX ) && found && openpgp_flag ) rt = KEYDB_RESOURCE_TYPE_KEYBOX ;\n else strcpy ( filename + filenamelen - 4 , \".gpg\" ) ;\n }\n }\n else if ( ! pass && is_default && create && filenamelen > 4 && ! strcmp ( filename + filenamelen - 4 , \".gpg\" ) ) {\n strcpy ( filename + filenamelen - 4 , \".kbx\" ) ;\n pass ++ ;\n goto check_again ;\n }\n else rt = KEYDB_RESOURCE_TYPE_KEYBOX ;\n }\n switch ( rt ) {\n case KEYDB_RESOURCE_TYPE_NONE : log_error ( \"unknown type of key resource '%s'\\n\" , url ) ;\n rc = gpg_error ( GPG_ERR_GENERAL ) ;\n goto leave ;\n case KEYDB_RESOURCE_TYPE_KEYRING : rc = maybe_create_keyring_or_box ( filename , 0 , create ) ;\n if ( rc ) goto leave ;\n if ( keyring_register_filename ( filename , read_only , & token ) ) {\n if ( used_resources >= MAX_KEYDB_RESOURCES ) rc = gpg_error ( GPG_ERR_RESOURCE_LIMIT ) ;\n else {\n if ( ( flags & KEYDB_RESOURCE_FLAG_PRIMARY ) ) primary_keyring = token ;\n all_resources [ used_resources ] . type = rt ;\n all_resources [ used_resources ] . u . kr = NULL ;\n all_resources [ used_resources ] . token = token ;\n used_resources ++ ;\n }\n }\n else {\n if ( ( flags & KEYDB_RESOURCE_FLAG_PRIMARY ) ) primary_keyring = token ;\n }\n break ;\n case KEYDB_RESOURCE_TYPE_KEYBOX : {\n rc = maybe_create_keyring_or_box ( filename , 1 , create ) ;\n if ( rc ) goto leave ;\n token = keybox_register_file ( filename , 0 ) ;\n if ( token ) {\n if ( used_resources >= MAX_KEYDB_RESOURCES ) rc = gpg_error ( GPG_ERR_RESOURCE_LIMIT ) ;\n else {\n all_resources [ used_resources ] . type = rt ;\n all_resources [ used_resources ] . u . kb = NULL ;\n all_resources [ used_resources ] . token = token ;\n used_resources ++ ;\n }\n }\n else {\n }\n }\n break ;\n default : log_error ( \"resource type of '%s' not supported\\n\" , url ) ;\n rc = gpg_error ( GPG_ERR_GENERAL ) ;\n goto leave ;\n }\n leave : if ( rc ) log_error ( _ ( \"keyblock resource '%s': %s\\n\" ) , filename , gpg_strerror ( rc ) ) ;\n else any_registered = 1 ;\n xfree ( filename ) ;\n return rc ;\n }", "idx": 22407}
{"hash": -2901388205723537271, "project": "debian", "size": 6, "label": 0, "functionSource": "VALUE rb_dlhandle_disable_close ( VALUE self ) {\n struct dl_handle * dlhandle ;\n Data_Get_Struct ( self , struct dl_handle , dlhandle ) ;\n dlhandle -> enable_close = 0 ;\n return Qnil ;\n }", "idx": 22408}
{"hash": -7795592811940874822, "project": "debian", "size": 13, "label": 0, "functionSource": "static int pubkey_get_nskey ( int algorithm ) {\n gcry_module_t pubkey ;\n int nskey = 0 ;\n REGISTER_DEFAULT_PUBKEYS ;\n ath_mutex_lock ( & pubkeys_registered_lock ) ;\n pubkey = _gcry_module_lookup_id ( pubkeys_registered , algorithm ) ;\n if ( pubkey ) {\n nskey = strlen ( ( ( gcry_pk_spec_t * ) pubkey -> spec ) -> elements_skey ) ;\n _gcry_module_release ( pubkey ) ;\n }\n ath_mutex_unlock ( & pubkeys_registered_lock ) ;\n return nskey ;\n }", "idx": 22409}
{"hash": -7117046864335130087, "project": "chrome", "size": 6, "label": 1, "functionSource": "int vp9_rc_bits_per_mb ( FRAME_TYPE frame_type , int qindex , double correction_factor ) {\n const double q = vp9_convert_qindex_to_q ( qindex ) ;\n int enumerator = frame_type == KEY_FRAME ? 3300000 : 2250000 ;\n enumerator += ( int ) ( enumerator * q ) >> 12 ;\n return ( int ) ( enumerator * correction_factor / q ) ;\n }", "idx": 22410}
{"hash": -7690167309709817279, "project": "debian", "size": 21, "label": 0, "functionSource": "static void icmp_put ( struct seq_file * seq ) {\n int i ;\n struct net * net = seq -> private ;\n atomic_long_t * ptr = net -> mib . icmpmsg_statistics -> mibs ;\n seq_puts ( seq , \"\\nIcmp: InMsgs InErrors\" ) ;\n for ( i = 0 ;\n icmpmibmap [ i ] . name != NULL ;\n i ++ ) seq_printf ( seq , \" In%s\" , icmpmibmap [ i ] . name ) ;\n seq_printf ( seq , \" OutMsgs OutErrors\" ) ;\n for ( i = 0 ;\n icmpmibmap [ i ] . name != NULL ;\n i ++ ) seq_printf ( seq , \" Out%s\" , icmpmibmap [ i ] . name ) ;\n seq_printf ( seq , \"\\nIcmp: %lu %lu\" , snmp_fold_field ( ( void __percpu * * ) net -> mib . icmp_statistics , ICMP_MIB_INMSGS ) , snmp_fold_field ( ( void __percpu * * ) net -> mib . icmp_statistics , ICMP_MIB_INERRORS ) ) ;\n for ( i = 0 ;\n icmpmibmap [ i ] . name != NULL ;\n i ++ ) seq_printf ( seq , \" %lu\" , atomic_long_read ( ptr + icmpmibmap [ i ] . index ) ) ;\n seq_printf ( seq , \" %lu %lu\" , snmp_fold_field ( ( void __percpu * * ) net -> mib . icmp_statistics , ICMP_MIB_OUTMSGS ) , snmp_fold_field ( ( void __percpu * * ) net -> mib . icmp_statistics , ICMP_MIB_OUTERRORS ) ) ;\n for ( i = 0 ;\n icmpmibmap [ i ] . name != NULL ;\n i ++ ) seq_printf ( seq , \" %lu\" , atomic_long_read ( ptr + ( icmpmibmap [ i ] . index | 0x100 ) ) ) ;\n }", "idx": 22411}
{"hash": 6600620671673714486, "project": "debian", "size": 10, "label": 0, "functionSource": "static byte * i_alloc_byte_array_immovable ( gs_memory_t * mem , uint num_elements , uint elt_size , client_name_t cname ) {\n gs_ref_memory_t * const imem = ( gs_ref_memory_t * ) mem ;\n obj_header_t * obj ;\n ulong lsize ;\n # ifdef MEMENTO if ( Memento_failThisEvent ( ) ) return NULL ;\n # endif if ( alloc_array_check_size ( num_elements , elt_size , & lsize ) == false ) return NULL ;\n obj = alloc_obj ( imem , lsize , & st_bytes , ALLOC_IMMOVABLE | ALLOC_DIRECT , cname ) ;\n if_debug6m ( 'A' , mem , \"[a%d|+b.]%s -bytes-*(%lu=%u*%u) = 0x%lx\\n\" , alloc_trace_space ( imem ) , client_name_string ( cname ) , ( ulong ) num_elements * elt_size , num_elements , elt_size , ( ulong ) obj ) ;\n return ( byte * ) obj ;\n }", "idx": 22412}
{"hash": -2607754285145856562, "project": "debian", "size": 4, "label": 0, "functionSource": "static int zisofs_free ( struct archive_write * a ) {\n ( void ) a ;\n return ( ARCHIVE_OK ) ;\n }", "idx": 22413}
{"hash": -1768728156572022708, "project": "debian", "size": 4, "label": 0, "functionSource": "void * jbig2_realloc ( Jbig2Allocator * allocator , void * p , size_t size , size_t num ) {\n if ( num > 0 && size >= ( size_t ) - 0x100 / num ) return NULL ;\n return allocator -> realloc ( allocator , p , size * num ) ;\n }", "idx": 22414}
{"hash": 5357882892791796049, "project": "debian", "size": 3, "label": 0, "functionSource": "static void e1000e_mac_writereg ( E1000ECore * core , int index , uint32_t val ) {\n core -> mac [ index ] = val ;\n }", "idx": 22415}
{"hash": -1983921383858884161, "project": "debian", "size": 16, "label": 1, "functionSource": "static int ipvideo_decode_block_opcode_0xD ( IpvideoContext * s ) {\n int y ;\n unsigned char P [ 2 ] ;\n for ( y = 0 ;\n y < 8 ;\n y ++ ) {\n if ( ! ( y & 3 ) ) {\n P [ 0 ] = bytestream2_get_byte ( & s -> stream_ptr ) ;\n P [ 1 ] = bytestream2_get_byte ( & s -> stream_ptr ) ;\n }\n memset ( s -> pixel_ptr , P [ 0 ] , 4 ) ;\n memset ( s -> pixel_ptr + 4 , P [ 1 ] , 4 ) ;\n s -> pixel_ptr += s -> stride ;\n }\n return 0 ;\n }", "idx": 22416}
{"hash": 1911881859629730975, "project": "chrome", "size": 12, "label": 1, "functionSource": "int vp9_compute_rd_mult ( const VP9_COMP * cpi , int qindex ) {\n const int q = vp9_dc_quant ( qindex , 0 ) ;\n int rdmult = 88 * q * q / 24 ;\n if ( cpi -> oxcf . pass == 2 && ( cpi -> common . frame_type != KEY_FRAME ) ) {\n const GF_GROUP * const gf_group = & cpi -> twopass . gf_group ;\n const FRAME_UPDATE_TYPE frame_type = gf_group -> update_type [ gf_group -> index ] ;\n const int boost_index = MIN ( 15 , ( cpi -> rc . gfu_boost / 100 ) ) ;\n rdmult = ( rdmult * rd_frame_type_factor [ frame_type ] ) >> 7 ;\n rdmult += ( ( rdmult * rd_boost_factor [ boost_index ] ) >> 7 ) ;\n }\n return rdmult ;\n }", "idx": 22417}
{"hash": -5780611388839125875, "project": "chrome", "size": 4, "label": 0, "functionSource": "xmlSAXLocator * __xmlDefaultSAXLocator ( void ) {\n if ( IS_MAIN_THREAD ) return ( & xmlDefaultSAXLocator ) ;\n else return ( & xmlGetGlobalState ( ) -> xmlDefaultSAXLocator ) ;\n }", "idx": 22418}
{"hash": 2626033973808493247, "project": "chrome", "size": 56, "label": 0, "functionSource": "static void qcms_transform_module_clut ( struct qcms_modular_transform * transform , float * src , float * dest , size_t length ) {\n size_t i ;\n int xy_len = 1 ;\n int x_len = transform -> grid_size ;\n int len = x_len * x_len ;\n float * r_table = transform -> r_clut ;\n float * g_table = transform -> g_clut ;\n float * b_table = transform -> b_clut ;\n assert ( transform -> grid_size >= 1 ) ;\n for ( i = 0 ;\n i < length ;\n i ++ ) {\n float device_r = * src ++ ;\n float device_g = * src ++ ;\n float device_b = * src ++ ;\n float linear_r = lut_interp_linear_float ( device_r , transform -> input_clut_table_r , transform -> input_clut_table_length ) ;\n float linear_g = lut_interp_linear_float ( device_g , transform -> input_clut_table_g , transform -> input_clut_table_length ) ;\n float linear_b = lut_interp_linear_float ( device_b , transform -> input_clut_table_b , transform -> input_clut_table_length ) ;\n int x = floor ( linear_r * ( transform -> grid_size - 1 ) ) ;\n int y = floor ( linear_g * ( transform -> grid_size - 1 ) ) ;\n int z = floor ( linear_b * ( transform -> grid_size - 1 ) ) ;\n int x_n = ceil ( linear_r * ( transform -> grid_size - 1 ) ) ;\n int y_n = ceil ( linear_g * ( transform -> grid_size - 1 ) ) ;\n int z_n = ceil ( linear_b * ( transform -> grid_size - 1 ) ) ;\n float x_d = linear_r * ( transform -> grid_size - 1 ) - x ;\n float y_d = linear_g * ( transform -> grid_size - 1 ) - y ;\n float z_d = linear_b * ( transform -> grid_size - 1 ) - z ;\n float r_x1 = lerp ( CLU ( r_table , x , y , z ) , CLU ( r_table , x_n , y , z ) , x_d ) ;\n float r_x2 = lerp ( CLU ( r_table , x , y_n , z ) , CLU ( r_table , x_n , y_n , z ) , x_d ) ;\n float r_y1 = lerp ( r_x1 , r_x2 , y_d ) ;\n float r_x3 = lerp ( CLU ( r_table , x , y , z_n ) , CLU ( r_table , x_n , y , z_n ) , x_d ) ;\n float r_x4 = lerp ( CLU ( r_table , x , y_n , z_n ) , CLU ( r_table , x_n , y_n , z_n ) , x_d ) ;\n float r_y2 = lerp ( r_x3 , r_x4 , y_d ) ;\n float clut_r = lerp ( r_y1 , r_y2 , z_d ) ;\n float g_x1 = lerp ( CLU ( g_table , x , y , z ) , CLU ( g_table , x_n , y , z ) , x_d ) ;\n float g_x2 = lerp ( CLU ( g_table , x , y_n , z ) , CLU ( g_table , x_n , y_n , z ) , x_d ) ;\n float g_y1 = lerp ( g_x1 , g_x2 , y_d ) ;\n float g_x3 = lerp ( CLU ( g_table , x , y , z_n ) , CLU ( g_table , x_n , y , z_n ) , x_d ) ;\n float g_x4 = lerp ( CLU ( g_table , x , y_n , z_n ) , CLU ( g_table , x_n , y_n , z_n ) , x_d ) ;\n float g_y2 = lerp ( g_x3 , g_x4 , y_d ) ;\n float clut_g = lerp ( g_y1 , g_y2 , z_d ) ;\n float b_x1 = lerp ( CLU ( b_table , x , y , z ) , CLU ( b_table , x_n , y , z ) , x_d ) ;\n float b_x2 = lerp ( CLU ( b_table , x , y_n , z ) , CLU ( b_table , x_n , y_n , z ) , x_d ) ;\n float b_y1 = lerp ( b_x1 , b_x2 , y_d ) ;\n float b_x3 = lerp ( CLU ( b_table , x , y , z_n ) , CLU ( b_table , x_n , y , z_n ) , x_d ) ;\n float b_x4 = lerp ( CLU ( b_table , x , y_n , z_n ) , CLU ( b_table , x_n , y_n , z_n ) , x_d ) ;\n float b_y2 = lerp ( b_x3 , b_x4 , y_d ) ;\n float clut_b = lerp ( b_y1 , b_y2 , z_d ) ;\n float pcs_r = lut_interp_linear_float ( clut_r , transform -> output_clut_table_r , transform -> output_clut_table_length ) ;\n float pcs_g = lut_interp_linear_float ( clut_g , transform -> output_clut_table_g , transform -> output_clut_table_length ) ;\n float pcs_b = lut_interp_linear_float ( clut_b , transform -> output_clut_table_b , transform -> output_clut_table_length ) ;\n * dest ++ = clamp_float ( pcs_r ) ;\n * dest ++ = clamp_float ( pcs_g ) ;\n * dest ++ = clamp_float ( pcs_b ) ;\n }\n }", "idx": 22419}
{"hash": 4489017523191997023, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h225_PrivatePartyNumber ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_PrivatePartyNumber , PrivatePartyNumber_sequence ) ;\n return offset ;\n }", "idx": 22420}
{"hash": 3576240888172463140, "project": "debian", "size": 19, "label": 0, "functionSource": "gpg_error_t keydb_delete_keyblock ( KEYDB_HANDLE hd ) {\n gpg_error_t rc ;\n if ( ! hd ) return gpg_error ( GPG_ERR_INV_ARG ) ;\n keyblock_cache_clear ( ) ;\n if ( hd -> found < 0 || hd -> found >= hd -> used ) return gpg_error ( GPG_ERR_VALUE_NOT_FOUND ) ;\n if ( opt . dry_run ) return 0 ;\n rc = lock_all ( hd ) ;\n if ( rc ) return rc ;\n switch ( hd -> active [ hd -> found ] . type ) {\n case KEYDB_RESOURCE_TYPE_NONE : rc = gpg_error ( GPG_ERR_GENERAL ) ;\n break ;\n case KEYDB_RESOURCE_TYPE_KEYRING : rc = keyring_delete_keyblock ( hd -> active [ hd -> found ] . u . kr ) ;\n break ;\n case KEYDB_RESOURCE_TYPE_KEYBOX : rc = keybox_delete ( hd -> active [ hd -> found ] . u . kb ) ;\n break ;\n }\n unlock_all ( hd ) ;\n return rc ;\n }", "idx": 22421}
{"hash": 8588713512322173474, "project": "debian", "size": 14, "label": 0, "functionSource": "static void tgq_idct_put_mb ( TgqContext * s , int16_t ( * block ) [ 64 ] , AVFrame * frame , int mb_x , int mb_y ) {\n int linesize = frame -> linesize [ 0 ] ;\n uint8_t * dest_y = frame -> data [ 0 ] + ( mb_y * 16 * linesize ) + mb_x * 16 ;\n uint8_t * dest_cb = frame -> data [ 1 ] + ( mb_y * 8 * frame -> linesize [ 1 ] ) + mb_x * 8 ;\n uint8_t * dest_cr = frame -> data [ 2 ] + ( mb_y * 8 * frame -> linesize [ 2 ] ) + mb_x * 8 ;\n ff_ea_idct_put_c ( dest_y , linesize , block [ 0 ] ) ;\n ff_ea_idct_put_c ( dest_y + 8 , linesize , block [ 1 ] ) ;\n ff_ea_idct_put_c ( dest_y + 8 * linesize , linesize , block [ 2 ] ) ;\n ff_ea_idct_put_c ( dest_y + 8 * linesize + 8 , linesize , block [ 3 ] ) ;\n if ( ! ( s -> avctx -> flags & CODEC_FLAG_GRAY ) ) {\n ff_ea_idct_put_c ( dest_cb , frame -> linesize [ 1 ] , block [ 4 ] ) ;\n ff_ea_idct_put_c ( dest_cr , frame -> linesize [ 2 ] , block [ 5 ] ) ;\n }\n }", "idx": 22422}
{"hash": 6458694302493204858, "project": "debian", "size": 14, "label": 0, "functionSource": "static TupleDesc get_cached_rowtype ( Oid type_id , int32 typmod , TupleDesc * cache_field , ExprContext * econtext ) {\n TupleDesc tupDesc = * cache_field ;\n if ( tupDesc == NULL || type_id != tupDesc -> tdtypeid || typmod != tupDesc -> tdtypmod ) {\n tupDesc = lookup_rowtype_tupdesc ( type_id , typmod ) ;\n if ( * cache_field ) {\n ReleaseTupleDesc ( * cache_field ) ;\n }\n else {\n RegisterExprContextCallback ( econtext , ShutdownTupleDescRef , PointerGetDatum ( cache_field ) ) ;\n }\n * cache_field = tupDesc ;\n }\n return tupDesc ;\n }", "idx": 22423}
{"hash": 6249489553242542670, "project": "debian", "size": 14, "label": 0, "functionSource": "static void destroy_attr_val_fifo ( attr_val_fifo * av_fifo ) {\n attr_val * av ;\n if ( av_fifo != NULL ) {\n do {\n UNLINK_FIFO ( av , * av_fifo , link ) ;\n if ( av != NULL ) {\n if ( T_String == av -> type ) free ( av -> value . s ) ;\n free ( av ) ;\n }\n }\n while ( av != NULL ) ;\n free ( av_fifo ) ;\n }\n }", "idx": 22424}
{"hash": 3502077845611765963, "project": "debian", "size": 28, "label": 1, "functionSource": "static struct cvec * range ( struct vars * v , celt a , celt b , int cases ) {\n int nchrs ;\n struct cvec * cv ;\n celt c , lc , uc ;\n if ( a != b && ! before ( a , b ) ) {\n ERR ( REG_ERANGE ) ;\n return NULL ;\n }\n if ( ! cases ) {\n cv = getcvec ( v , 0 , 1 ) ;\n NOERRN ( ) ;\n addrange ( cv , a , b ) ;\n return cv ;\n }\n nchrs = ( b - a + 1 ) * 2 + 4 ;\n cv = getcvec ( v , nchrs , 0 ) ;\n NOERRN ( ) ;\n for ( c = a ;\n c <= b ;\n c ++ ) {\n addchr ( cv , c ) ;\n lc = pg_wc_tolower ( ( chr ) c ) ;\n if ( c != lc ) addchr ( cv , lc ) ;\n uc = pg_wc_toupper ( ( chr ) c ) ;\n if ( c != uc ) addchr ( cv , uc ) ;\n }\n return cv ;\n }", "idx": 22425}
{"hash": -1315695702746584250, "project": "debian", "size": 4, "label": 0, "functionSource": "void proto_report_dissector_bug ( const char * message ) {\n if ( getenv ( \"WIRESHARK_ABORT_ON_DISSECTOR_BUG\" ) != NULL ) abort ( ) ;\n else THROW_MESSAGE ( DissectorError , message ) ;\n }", "idx": 22426}
{"hash": -2607754285145856562, "project": "debian", "size": 37, "label": 0, "functionSource": "static int iso9660_free ( struct archive_write * a ) {\n struct iso9660 * iso9660 ;\n int i , ret ;\n iso9660 = a -> format_data ;\n if ( iso9660 -> temp_fd >= 0 ) close ( iso9660 -> temp_fd ) ;\n ret = zisofs_free ( a ) ;\n isoent_free_all ( iso9660 -> primary . rootent ) ;\n for ( i = 0 ;\n i < iso9660 -> primary . max_depth ;\n i ++ ) free ( iso9660 -> primary . pathtbl [ i ] . sorted ) ;\n free ( iso9660 -> primary . pathtbl ) ;\n if ( iso9660 -> opt . joliet ) {\n isoent_free_all ( iso9660 -> joliet . rootent ) ;\n for ( i = 0 ;\n i < iso9660 -> joliet . max_depth ;\n i ++ ) free ( iso9660 -> joliet . pathtbl [ i ] . sorted ) ;\n free ( iso9660 -> joliet . pathtbl ) ;\n }\n isofile_free_all_entries ( iso9660 ) ;\n isofile_free_hardlinks ( iso9660 ) ;\n archive_string_free ( & ( iso9660 -> cur_dirstr ) ) ;\n archive_string_free ( & ( iso9660 -> volume_identifier ) ) ;\n archive_string_free ( & ( iso9660 -> publisher_identifier ) ) ;\n archive_string_free ( & ( iso9660 -> data_preparer_identifier ) ) ;\n archive_string_free ( & ( iso9660 -> application_identifier ) ) ;\n archive_string_free ( & ( iso9660 -> copyright_file_identifier ) ) ;\n archive_string_free ( & ( iso9660 -> abstract_file_identifier ) ) ;\n archive_string_free ( & ( iso9660 -> bibliographic_file_identifier ) ) ;\n archive_string_free ( & ( iso9660 -> el_torito . catalog_filename ) ) ;\n archive_string_free ( & ( iso9660 -> el_torito . boot_filename ) ) ;\n archive_string_free ( & ( iso9660 -> el_torito . id ) ) ;\n archive_string_free ( & ( iso9660 -> utf16be ) ) ;\n archive_string_free ( & ( iso9660 -> mbs ) ) ;\n free ( iso9660 ) ;\n a -> format_data = NULL ;\n return ( ret ) ;\n }", "idx": 22427}
{"hash": -4136373206107992781, "project": "chrome", "size": 154, "label": 0, "functionSource": "static void U_CALLCONV UConverter_fromUnicode_ISCII_OFFSETS_LOGIC ( UConverterFromUnicodeArgs * args , UErrorCode * err ) {\n const UChar * source = args -> source ;\n const UChar * sourceLimit = args -> sourceLimit ;\n unsigned char * target = ( unsigned char * ) args -> target ;\n unsigned char * targetLimit = ( unsigned char * ) args -> targetLimit ;\n int32_t * offsets = args -> offsets ;\n uint32_t targetByteUnit = 0x0000 ;\n UChar32 sourceChar = 0x0000 ;\n UChar32 tempContextFromUnicode = 0x0000 ;\n UConverterDataISCII * converterData ;\n uint16_t newDelta = 0 ;\n uint16_t range = 0 ;\n UBool deltaChanged = FALSE ;\n if ( ( args -> converter == NULL ) || ( args -> targetLimit < args -> target ) || ( args -> sourceLimit < args -> source ) ) {\n * err = U_ILLEGAL_ARGUMENT_ERROR ;\n return ;\n }\n converterData = ( UConverterDataISCII * ) args -> converter -> extraInfo ;\n newDelta = converterData -> currentDeltaFromUnicode ;\n range = ( uint16_t ) ( newDelta / DELTA ) ;\n if ( ( sourceChar = args -> converter -> fromUChar32 ) != 0 ) {\n goto getTrail ;\n }\n while ( source < sourceLimit ) {\n if ( args -> converter -> fromUnicodeStatus == LF ) {\n targetByteUnit = ATR << 8 ;\n targetByteUnit += ( uint8_t ) lookupInitialData [ range ] . isciiLang ;\n args -> converter -> fromUnicodeStatus = 0x0000 ;\n WRITE_TO_TARGET_FROM_U ( args , offsets , source , target , targetLimit , targetByteUnit , err ) ;\n if ( U_FAILURE ( * err ) ) {\n break ;\n }\n }\n sourceChar = * source ++ ;\n tempContextFromUnicode = converterData -> contextCharFromUnicode ;\n targetByteUnit = missingCharMarker ;\n if ( sourceChar <= ASCII_END ) {\n args -> converter -> fromUnicodeStatus = sourceChar ;\n WRITE_TO_TARGET_FROM_U ( args , offsets , source , target , targetLimit , sourceChar , err ) ;\n if ( U_FAILURE ( * err ) ) {\n break ;\n }\n continue ;\n }\n switch ( sourceChar ) {\n case ZWNJ : if ( converterData -> contextCharFromUnicode ) {\n converterData -> contextCharFromUnicode = 0x00 ;\n targetByteUnit = ISCII_HALANT ;\n }\n else {\n converterData -> contextCharFromUnicode = 0x00 ;\n continue ;\n }\n break ;\n case ZWJ : if ( converterData -> contextCharFromUnicode ) {\n targetByteUnit = ISCII_NUKTA ;\n }\n else {\n targetByteUnit = ISCII_INV ;\n }\n converterData -> contextCharFromUnicode = 0x00 ;\n break ;\n default : if ( ( uint16_t ) ( INDIC_BLOCK_END - sourceChar ) <= INDIC_RANGE ) {\n if ( sourceChar != DANDA && sourceChar != DOUBLE_DANDA ) {\n range = ( uint16_t ) ( ( sourceChar - INDIC_BLOCK_BEGIN ) / DELTA ) ;\n newDelta = ( uint16_t ) ( range * DELTA ) ;\n if ( newDelta != converterData -> currentDeltaFromUnicode || converterData -> isFirstBuffer ) {\n converterData -> currentDeltaFromUnicode = newDelta ;\n converterData -> currentMaskFromUnicode = lookupInitialData [ range ] . maskEnum ;\n deltaChanged = TRUE ;\n converterData -> isFirstBuffer = FALSE ;\n }\n if ( converterData -> currentDeltaFromUnicode == PNJ_DELTA ) {\n if ( sourceChar == PNJ_TIPPI ) {\n sourceChar = PNJ_BINDI ;\n }\n else if ( sourceChar == PNJ_ADHAK ) {\n converterData -> contextCharFromUnicode = PNJ_ADHAK ;\n }\n }\n sourceChar -= converterData -> currentDeltaFromUnicode ;\n }\n targetByteUnit = fromUnicodeTable [ ( uint8_t ) sourceChar ] ;\n if ( ( validityTable [ ( uint8_t ) sourceChar ] & converterData -> currentMaskFromUnicode ) == 0 ) {\n if ( converterData -> currentDeltaFromUnicode != ( TELUGU_DELTA ) || sourceChar != VOCALLIC_RR ) {\n targetByteUnit = missingCharMarker ;\n }\n }\n if ( deltaChanged ) {\n uint32_t temp = 0 ;\n temp = ( uint16_t ) ( ATR << 8 ) ;\n temp += ( uint16_t ) ( ( uint8_t ) lookupInitialData [ range ] . isciiLang ) ;\n deltaChanged = FALSE ;\n WRITE_TO_TARGET_FROM_U ( args , offsets , source , target , targetLimit , temp , err ) ;\n if ( U_FAILURE ( * err ) ) {\n break ;\n }\n }\n if ( converterData -> currentDeltaFromUnicode == PNJ_DELTA && ( sourceChar + PNJ_DELTA ) == PNJ_ADHAK ) {\n continue ;\n }\n }\n converterData -> contextCharFromUnicode = 0x00 ;\n break ;\n }\n if ( converterData -> currentDeltaFromUnicode == PNJ_DELTA && tempContextFromUnicode == PNJ_ADHAK && isPNJConsonant ( ( sourceChar + PNJ_DELTA ) ) ) {\n converterData -> contextCharFromUnicode = 0x0000 ;\n targetByteUnit = targetByteUnit << 16 | ISCII_HALANT << 8 | targetByteUnit ;\n WRITE_TO_TARGET_FROM_U ( args , offsets , source , target , targetLimit , targetByteUnit , err ) ;\n if ( U_FAILURE ( * err ) ) {\n break ;\n }\n }\n else if ( targetByteUnit != missingCharMarker ) {\n if ( targetByteUnit == ISCII_HALANT ) {\n converterData -> contextCharFromUnicode = ( UChar ) targetByteUnit ;\n }\n WRITE_TO_TARGET_FROM_U ( args , offsets , source , target , targetLimit , targetByteUnit , err ) ;\n if ( U_FAILURE ( * err ) ) {\n break ;\n }\n }\n else {\n if ( U16_IS_SURROGATE ( sourceChar ) ) {\n if ( U16_IS_SURROGATE_LEAD ( sourceChar ) ) {\n getTrail : if ( source < sourceLimit ) {\n UChar trail = ( * source ) ;\n if ( U16_IS_TRAIL ( trail ) ) {\n source ++ ;\n sourceChar = U16_GET_SUPPLEMENTARY ( sourceChar , trail ) ;\n * err = U_INVALID_CHAR_FOUND ;\n }\n else {\n * err = U_ILLEGAL_CHAR_FOUND ;\n }\n }\n else {\n * err = U_ZERO_ERROR ;\n }\n }\n else {\n * err = U_ILLEGAL_CHAR_FOUND ;\n }\n }\n else {\n * err = U_INVALID_CHAR_FOUND ;\n }\n args -> converter -> fromUChar32 = sourceChar ;\n break ;\n }\n }\n args -> source = source ;\n args -> target = ( char * ) target ;\n }", "idx": 22428}
{"hash": 2487534775710400322, "project": "chrome", "size": 13, "label": 0, "functionSource": "TEST_F ( ExtensionWelcomeNotificationTest , FirstRunShowRegularNotification ) {\n StartPreferenceSyncing ( ) ;\n EXPECT_FALSE ( GetBooleanPref ( prefs : : kWelcomeNotificationDismissed ) ) ;\n EXPECT_FALSE ( GetBooleanPref ( prefs : : kWelcomeNotificationDismissedLocal ) ) ;\n EXPECT_FALSE ( GetBooleanPref ( prefs : : kWelcomeNotificationPreviouslyPoppedUp ) ) ;\n ShowRegularNotification ( ) ;\n EXPECT_EQ ( message_center ( ) -> add_notification_calls ( ) , 0 ) ;\n EXPECT_EQ ( message_center ( ) -> remove_notification_calls ( ) , 0 ) ;\n EXPECT_EQ ( message_center ( ) -> notifications_with_shown_as_popup ( ) , 0 ) ;\n EXPECT_FALSE ( GetBooleanPref ( prefs : : kWelcomeNotificationDismissed ) ) ;\n EXPECT_FALSE ( GetBooleanPref ( prefs : : kWelcomeNotificationDismissedLocal ) ) ;\n EXPECT_FALSE ( GetBooleanPref ( prefs : : kWelcomeNotificationPreviouslyPoppedUp ) ) ;\n }", "idx": 22429}
{"hash": 2100112064176019294, "project": "chrome", "size": 17, "label": 0, "functionSource": "xsltDocumentPtr xsltNewDocument ( xsltTransformContextPtr ctxt , xmlDocPtr doc ) {\n xsltDocumentPtr cur ;\n cur = ( xsltDocumentPtr ) xmlMalloc ( sizeof ( xsltDocument ) ) ;\n if ( cur == NULL ) {\n xsltTransformError ( ctxt , NULL , ( xmlNodePtr ) doc , \"xsltNewDocument : malloc failed\\n\" ) ;\n return ( NULL ) ;\n }\n memset ( cur , 0 , sizeof ( xsltDocument ) ) ;\n cur -> doc = doc ;\n if ( ctxt != NULL ) {\n if ( ! XSLT_IS_RES_TREE_FRAG ( doc ) ) {\n cur -> next = ctxt -> docList ;\n ctxt -> docList = cur ;\n }\n }\n return ( cur ) ;\n }", "idx": 22430}
{"hash": 252275190935145023, "project": "debian", "size": 8, "label": 0, "functionSource": "static void set_ref ( VP9_COMMON * const cm , MACROBLOCKD * const xd , int idx , int mi_row , int mi_col ) {\n MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ;\n RefBuffer * ref_buffer = & cm -> frame_refs [ mbmi -> ref_frame [ idx ] - LAST_FRAME ] ;\n xd -> block_refs [ idx ] = ref_buffer ;\n if ( ! vp9_is_valid_scale ( & ref_buffer -> sf ) ) vpx_internal_error ( & cm -> error , VPX_CODEC_UNSUP_BITSTREAM , \"Invalid scale factors\" ) ;\n vp9_setup_pre_planes ( xd , idx , ref_buffer -> buf , mi_row , mi_col , & ref_buffer -> sf ) ;\n xd -> corrupted |= ref_buffer -> buf -> corrupted ;\n }", "idx": 22431}
{"hash": -7076754245473579218, "project": "chrome", "size": 33, "label": 0, "functionSource": "int evhttp_hostportfile ( char * url , char * * phost , u_short * pport , char * * pfile ) {\n static char host [ 1024 ] ;\n static char file [ 1024 ] ;\n char * p ;\n const char * p2 ;\n int len ;\n u_short port ;\n len = strlen ( HTTP_PREFIX ) ;\n if ( strncasecmp ( url , HTTP_PREFIX , len ) ) return ( - 1 ) ;\n url += len ;\n if ( strlcpy ( host , url , sizeof ( host ) ) >= sizeof ( host ) ) return ( - 1 ) ;\n p = strchr ( host , '/' ) ;\n if ( p != NULL ) {\n * p = '\\0' ;\n p2 = p + 1 ;\n }\n else p2 = NULL ;\n if ( pfile != NULL ) {\n if ( p2 == NULL ) p2 = \"\" ;\n evutil_snprintf ( file , sizeof ( file ) , \"/%s\" , p2 ) ;\n }\n p = strchr ( host , ':' ) ;\n if ( p != NULL ) {\n * p = '\\0' ;\n port = atoi ( p + 1 ) ;\n if ( port == 0 ) return ( - 1 ) ;\n }\n else port = HTTP_DEFAULTPORT ;\n if ( phost != NULL ) * phost = host ;\n if ( pport != NULL ) * pport = port ;\n if ( pfile != NULL ) * pfile = file ;\n return ( 0 ) ;\n }", "idx": 22432}
{"hash": 2343071019501443392, "project": "chrome", "size": 12, "label": 0, "functionSource": "static void inc_mvs ( const MB_MODE_INFO * mbmi , const int_mv mvs [ 2 ] , nmv_context_counts * counts ) {\n int i ;\n for ( i = 0 ;\n i < 1 + has_second_ref ( mbmi ) ;\n ++ i ) {\n const MV * ref = & mbmi -> ref_mvs [ mbmi -> ref_frame [ i ] ] [ 0 ] . as_mv ;\n const MV diff = {\n mvs [ i ] . as_mv . row - ref -> row , mvs [ i ] . as_mv . col - ref -> col }\n ;\n vp9_inc_mv ( & diff , counts ) ;\n }\n }", "idx": 22433}
{"hash": -7775977291865552483, "project": "debian", "size": 22, "label": 0, "functionSource": "int qemuAssignDeviceControllerAlias ( virDomainDefPtr domainDef , virQEMUCapsPtr qemuCaps , virDomainControllerDefPtr controller ) {\n const char * prefix = virDomainControllerTypeToString ( controller -> type ) ;\n if ( controller -> type == VIR_DOMAIN_CONTROLLER_TYPE_PCI ) {\n if ( ! virQEMUCapsHasPCIMultiBus ( qemuCaps , domainDef ) ) {\n return VIR_STRDUP ( controller -> info . alias , \"pci\" ) ;\n }\n else if ( controller -> model == VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT ) {\n return virAsprintf ( & controller -> info . alias , \"pcie.%d\" , controller -> idx ) ;\n }\n return virAsprintf ( & controller -> info . alias , \"pci.%d\" , controller -> idx ) ;\n }\n else if ( controller -> type == VIR_DOMAIN_CONTROLLER_TYPE_IDE ) {\n if ( qemuDomainMachineHasBuiltinIDE ( domainDef ) && controller -> idx == 0 ) return VIR_STRDUP ( controller -> info . alias , \"ide\" ) ;\n }\n else if ( controller -> type == VIR_DOMAIN_CONTROLLER_TYPE_SATA ) {\n if ( qemuDomainMachineIsQ35 ( domainDef ) && controller -> idx == 0 ) return VIR_STRDUP ( controller -> info . alias , \"ide\" ) ;\n }\n else if ( controller -> type == VIR_DOMAIN_CONTROLLER_TYPE_USB ) {\n if ( controller -> idx == 0 ) return VIR_STRDUP ( controller -> info . alias , \"usb\" ) ;\n }\n return virAsprintf ( & controller -> info . alias , \"%s%d\" , prefix , controller -> idx ) ;\n }", "idx": 22434}
{"hash": 8849962823026424130, "project": "debian", "size": 29, "label": 0, "functionSource": "static ssize_t qio_channel_websock_read_wire ( QIOChannelWebsock * ioc , Error * * errp ) {\n ssize_t ret ;\n if ( ioc -> encinput . offset < 4096 ) {\n size_t want = 4096 - ioc -> encinput . offset ;\n buffer_reserve ( & ioc -> encinput , want ) ;\n ret = qio_channel_read ( ioc -> master , ( char * ) ioc -> encinput . buffer + ioc -> encinput . offset , want , errp ) ;\n if ( ret < 0 ) {\n return ret ;\n }\n if ( ret == 0 && ioc -> encinput . offset == 0 ) {\n ioc -> io_eof = TRUE ;\n return 0 ;\n }\n ioc -> encinput . offset += ret ;\n }\n while ( ioc -> encinput . offset != 0 ) {\n if ( ioc -> payload_remain == 0 ) {\n ret = qio_channel_websock_decode_header ( ioc , errp ) ;\n if ( ret < 0 ) {\n return ret ;\n }\n }\n ret = qio_channel_websock_decode_payload ( ioc , errp ) ;\n if ( ret < 0 ) {\n return ret ;\n }\n }\n return 1 ;\n }", "idx": 22435}
{"hash": 4876100961671882393, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_pvfs2_statfs_request ( tvbuff_t * tvb , proto_tree * tree , int offset , packet_info * pinfo _U_ ) {\n offset = dissect_pvfs_fs_id ( tvb , tree , offset ) ;\n return offset ;\n }", "idx": 22436}
{"hash": 4876100961671882393, "project": "debian", "size": 6, "label": 0, "functionSource": "static int dissect_pvfs2_deleattr_request ( tvbuff_t * tvb , proto_tree * tree , int offset , packet_info * pinfo ) {\n offset = dissect_pvfs_fh ( tvb , offset , pinfo , tree , \"handle\" , NULL ) ;\n offset = dissect_pvfs_fs_id ( tvb , tree , offset ) ;\n offset = dissect_pvfs_ds_keyval ( tvb , tree , offset ) ;\n return offset ;\n }", "idx": 22437}
{"hash": -866921002076081979, "project": "debian", "size": 174, "label": 0, "functionSource": "static int transform_hook_handler ( TSCont contp , TSEvent event , void * edata ) {\n TSHttpTxn txnp = nullptr ;\n TransformTestData * data = nullptr ;\n CHECK_SPURIOUS_EVENT ( contp , event , edata ) ;\n data = ( TransformTestData * ) TSContDataGet ( contp ) ;\n switch ( event ) {\n case TS_EVENT_HTTP_READ_REQUEST_HDR : txnp = ( TSHttpTxn ) edata ;\n TSSkipRemappingSet ( txnp , 1 ) ;\n TSHttpTxnReenable ( txnp , TS_EVENT_HTTP_CONTINUE ) ;\n break ;\n case TS_EVENT_HTTP_READ_RESPONSE_HDR : txnp = ( TSHttpTxn ) edata ;\n if ( transformable ( txnp , data ) ) {\n transform_add ( txnp , data ) ;\n }\n {\n TSMBuffer bufp ;\n TSMLoc hdr ;\n TSMLoc field ;\n if ( TSHttpTxnClientReqGet ( txnp , & bufp , & hdr ) != TS_SUCCESS ) {\n SDK_RPRINT ( data -> test , \"TSHttpTxnTransform\" , \"TestCase\" , TC_FAIL , \"TSHttpTxnClientReqGet returns 0\" ) ;\n }\n else {\n if ( TS_NULL_MLOC == ( field = TSMimeHdrFieldFind ( bufp , hdr , \"Request\" , - 1 ) ) ) {\n SDK_RPRINT ( data -> test , \"TSHttpTxnTransform\" , \"TestCase\" , TC_FAIL , \"Didn't find field request\" ) ;\n }\n else {\n int reqid = TSMimeHdrFieldValueIntGet ( bufp , hdr , field , 0 ) ;\n if ( reqid == 1 ) {\n TSHttpTxnTransformedRespCache ( txnp , 0 ) ;\n TSHttpTxnUntransformedRespCache ( txnp , 1 ) ;\n }\n if ( reqid == 2 ) {\n TSHttpTxnTransformedRespCache ( txnp , 1 ) ;\n TSHttpTxnUntransformedRespCache ( txnp , 0 ) ;\n }\n if ( TSHandleMLocRelease ( bufp , hdr , field ) != TS_SUCCESS ) {\n SDK_RPRINT ( data -> test , \"TSHttpTxnTransform\" , \"TestCase\" , TC_FAIL , \"Unable to release handle to field in Client request\" ) ;\n }\n }\n if ( TSHandleMLocRelease ( bufp , TS_NULL_MLOC , hdr ) != TS_SUCCESS ) {\n SDK_RPRINT ( data -> test , \"TSHttpTxnTransform\" , \"TestCase\" , TC_FAIL , \"Unable to release handle to Client request\" ) ;\n }\n }\n }\n TSHttpTxnHookAdd ( txnp , TS_HTTP_SEND_RESPONSE_HDR_HOOK , contp ) ;\n TSHttpTxnReenable ( txnp , TS_EVENT_HTTP_CONTINUE ) ;\n break ;\n case TS_EVENT_HTTP_SEND_RESPONSE_HDR : {\n TSMBuffer bufp ;\n TSMLoc hdr ;\n txnp = ( TSHttpTxn ) edata ;\n if ( TSHttpTxnTransformRespGet ( txnp , & bufp , & hdr ) != TS_SUCCESS ) {\n SDK_RPRINT ( data -> test , \"TSHttpTxnTransformRespGet\" , \"TestCase\" , TC_FAIL , \"TSHttpTxnTransformRespGet returns 0\" ) ;\n data -> test_passed_txn_transform_resp_get = false ;\n }\n else {\n if ( ( bufp == reinterpret_cast < TSMBuffer > ( & ( ( ( HttpSM * ) txnp ) -> t_state . hdr_info . transform_response ) ) ) && ( hdr == reinterpret_cast < TSMLoc > ( ( & ( ( ( HttpSM * ) txnp ) -> t_state . hdr_info . transform_response ) ) -> m_http ) ) ) {\n SDK_RPRINT ( data -> test , \"TSHttpTxnTransformRespGet\" , \"TestCase\" , TC_PASS , \"ok\" ) ;\n }\n else {\n SDK_RPRINT ( data -> test , \"TSHttpTxnTransformRespGet\" , \"TestCase\" , TC_FAIL , \"Value's Mismatch\" ) ;\n data -> test_passed_txn_transform_resp_get = false ;\n }\n if ( TSHandleMLocRelease ( bufp , TS_NULL_MLOC , hdr ) != TS_SUCCESS ) {\n SDK_RPRINT ( data -> test , \"TSHttpTxnTransformRespGet\" , \"TestCase\" , TC_FAIL , \"Unable to release handle to Transform header handle\" ) ;\n }\n }\n }\n TSHttpTxnReenable ( txnp , TS_EVENT_HTTP_CONTINUE ) ;\n break ;\n case TS_EVENT_IMMEDIATE : case TS_EVENT_TIMEOUT : switch ( data -> req_no ) {\n case 1 : if ( data -> browser1 -> status == REQUEST_INPROGRESS ) {\n TSContSchedule ( contp , 25 , TS_THREAD_POOL_DEFAULT ) ;\n return 0 ;\n }\n data -> req_no ++ ;\n Debug ( UTDBG_TAG \"_transform\" , \"Running Browser 2\" ) ;\n synclient_txn_send_request ( data -> browser2 , data -> request2 ) ;\n TSContSchedule ( contp , 25 , TS_THREAD_POOL_DEFAULT ) ;\n return 0 ;\n case 2 : if ( data -> browser2 -> status == REQUEST_INPROGRESS ) {\n TSContSchedule ( contp , 25 , TS_THREAD_POOL_DEFAULT ) ;\n return 0 ;\n }\n data -> req_no ++ ;\n Debug ( UTDBG_TAG \"_transform\" , \"Running Browser 3\" ) ;\n synclient_txn_send_request ( data -> browser3 , data -> request1 ) ;\n TSContSchedule ( contp , 25 , TS_THREAD_POOL_DEFAULT ) ;\n return 0 ;\n case 3 : if ( data -> browser3 -> status == REQUEST_INPROGRESS ) {\n TSContSchedule ( contp , 25 , TS_THREAD_POOL_DEFAULT ) ;\n return 0 ;\n }\n data -> req_no ++ ;\n Debug ( UTDBG_TAG \"_transform\" , \"Running Browser 4\" ) ;\n synclient_txn_send_request ( data -> browser4 , data -> request2 ) ;\n TSContSchedule ( contp , 25 , TS_THREAD_POOL_DEFAULT ) ;\n return 0 ;\n case 4 : if ( data -> browser4 -> status == REQUEST_INPROGRESS ) {\n TSContSchedule ( contp , 25 , TS_THREAD_POOL_DEFAULT ) ;\n return 0 ;\n }\n synserver_delete ( data -> os ) ;\n data -> os = nullptr ;\n data -> req_no ++ ;\n TSfree ( data -> request1 ) ;\n TSfree ( data -> request2 ) ;\n break ;\n default : SDK_RPRINT ( data -> test , \"TSHttpTxnTransform\" , \"TestCase\" , TC_FAIL , \"Something terribly wrong with the test\" ) ;\n exit ( 0 ) ;\n }\n {\n if ( ( strstr ( data -> browser1 -> response , TRANSFORM_APPEND_STRING ) != nullptr ) && ( strstr ( data -> browser3 -> response , TRANSFORM_APPEND_STRING ) == nullptr ) ) {\n SDK_RPRINT ( data -> test , \"TSHttpTxnUntransformedResponseCache\" , \"TestCase1\" , TC_PASS , \"ok\" ) ;\n data -> test_passed_txn_untransformed_resp_cache = true ;\n }\n else {\n SDK_RPRINT ( data -> test , \"TSHttpTxnUntransformedResponseCache\" , \"TestCase1\" , TC_FAIL , \"Value's Mismatch\" ) ;\n }\n if ( ( strstr ( data -> browser2 -> response , TRANSFORM_APPEND_STRING ) != nullptr ) && ( strstr ( data -> browser4 -> response , TRANSFORM_APPEND_STRING ) != nullptr ) ) {\n SDK_RPRINT ( data -> test , \"TSHttpTxnTransformedResponseCache\" , \"TestCase1\" , TC_PASS , \"ok\" ) ;\n data -> test_passed_txn_transformed_resp_cache = true ;\n }\n else {\n SDK_RPRINT ( data -> test , \"TSHttpTxnTransformedResponseCache\" , \"TestCase1\" , TC_FAIL , \"Value's Mismatch\" ) ;\n }\n * ( data -> pstatus ) = REGRESSION_TEST_PASSED ;\n if ( data -> browser1 -> status != REQUEST_SUCCESS ) {\n SDK_RPRINT ( data -> test , \"TSTransformCreate\" , \"TestCase1\" , TC_FAIL , \"Browser 1 status was not REQUEST_SUCCESS\" ) ;\n * ( data -> pstatus ) = REGRESSION_TEST_FAILED ;\n }\n if ( data -> browser2 -> status != REQUEST_SUCCESS ) {\n SDK_RPRINT ( data -> test , \"TSTransformCreate\" , \"TestCase1\" , TC_FAIL , \"Browser 2 status was not REQUEST_SUCCESS\" ) ;\n * ( data -> pstatus ) = REGRESSION_TEST_FAILED ;\n }\n if ( data -> browser3 -> status != REQUEST_SUCCESS ) {\n SDK_RPRINT ( data -> test , \"TSTransformCreate\" , \"TestCase1\" , TC_FAIL , \"Browser 3 status was not REQUEST_SUCCESS\" ) ;\n * ( data -> pstatus ) = REGRESSION_TEST_FAILED ;\n }\n if ( data -> browser4 -> status != REQUEST_SUCCESS ) {\n SDK_RPRINT ( data -> test , \"TSTransformCreate\" , \"TestCase1\" , TC_FAIL , \"Browser 4 status was not REQUEST_SUCCESS\" ) ;\n * ( data -> pstatus ) = REGRESSION_TEST_FAILED ;\n }\n if ( data -> test_passed_txn_transform_resp_get != true ) {\n SDK_RPRINT ( data -> test , \"TSTransformCreate\" , \"TestCase1\" , TC_FAIL , \"did not pass transform_resp_get\" ) ;\n * ( data -> pstatus ) = REGRESSION_TEST_FAILED ;\n }\n if ( data -> test_passed_txn_transformed_resp_cache != true ) {\n SDK_RPRINT ( data -> test , \"TSTransformCreate\" , \"TestCase1\" , TC_FAIL , \"did not pass transformed_resp_cache\" ) ;\n * ( data -> pstatus ) = REGRESSION_TEST_FAILED ;\n }\n if ( data -> test_passed_txn_untransformed_resp_cache != true ) {\n SDK_RPRINT ( data -> test , \"TSTransformCreate\" , \"TestCase1\" , TC_FAIL , \"did not pass untransformed_resp_cache\" ) ;\n * ( data -> pstatus ) = REGRESSION_TEST_FAILED ;\n }\n if ( data -> test_passed_transform_create != true ) {\n SDK_RPRINT ( data -> test , \"TSTransformCreate\" , \"TestCase1\" , TC_FAIL , \"did not pass transform_create\" ) ;\n * ( data -> pstatus ) = REGRESSION_TEST_FAILED ;\n }\n synclient_txn_delete ( data -> browser1 ) ;\n synclient_txn_delete ( data -> browser2 ) ;\n synclient_txn_delete ( data -> browser3 ) ;\n synclient_txn_delete ( data -> browser4 ) ;\n TSContDataSet ( contp , nullptr ) ;\n data -> magic = MAGIC_DEAD ;\n TSfree ( data ) ;\n }\n break ;\n default : * ( data -> pstatus ) = REGRESSION_TEST_FAILED ;\n SDK_RPRINT ( data -> test , \"TSHttpTxnTransform\" , \"TestCase1\" , TC_FAIL , \"Unexpected event %d\" , event ) ;\n break ;\n }\n return 0 ;\n }", "idx": 22438}
{"hash": 2895622461494525400, "project": "debian", "size": 26, "label": 0, "functionSource": "static void test_bug28934 ( ) {\n my_bool error = 0 ;\n MYSQL_BIND bind [ 5 ] ;\n MYSQL_STMT * stmt ;\n int cnt ;\n myquery ( mysql_query ( mysql , \"drop table if exists t1\" ) ) ;\n myquery ( mysql_query ( mysql , \"create table t1(id int)\" ) ) ;\n myquery ( mysql_query ( mysql , \"insert into t1 values(1),(2),(3),(4),(5)\" ) ) ;\n stmt = mysql_simple_prepare ( mysql , \"select * from t1 where id in(?,?,?,?,?)\" ) ;\n check_stmt ( stmt ) ;\n memset ( & bind , 0 , sizeof ( bind ) ) ;\n for ( cnt = 0 ;\n cnt < 5 ;\n cnt ++ ) {\n bind [ cnt ] . buffer_type = MYSQL_TYPE_LONG ;\n bind [ cnt ] . buffer = ( char * ) & cnt ;\n bind [ cnt ] . buffer_length = 0 ;\n }\n myquery ( mysql_stmt_bind_param ( stmt , bind ) ) ;\n stmt -> param_count = 2 ;\n error = mysql_stmt_execute ( stmt ) ;\n DIE_UNLESS ( error != 0 ) ;\n myerror ( NULL ) ;\n mysql_stmt_close ( stmt ) ;\n myquery ( mysql_query ( mysql , \"drop table t1\" ) ) ;\n }", "idx": 22439}
{"hash": -5612058238993493687, "project": "debian", "size": 48, "label": 0, "functionSource": "static void ppp_hdlc ( netdissect_options * ndo , const u_char * p , int length ) {\n u_char * b , * t , c ;\n const u_char * s ;\n int i , proto ;\n const void * se ;\n if ( length <= 0 ) return ;\n b = ( u_char * ) malloc ( length ) ;\n if ( b == NULL ) return ;\n for ( s = p , t = b , i = length ;\n i > 0 && ND_TTEST ( * s ) ;\n i -- ) {\n c = * s ++ ;\n if ( c == 0x7d ) {\n if ( i <= 1 || ! ND_TTEST ( * s ) ) break ;\n i -- ;\n c = * s ++ ^ 0x20 ;\n }\n * t ++ = c ;\n }\n se = ndo -> ndo_snapend ;\n ndo -> ndo_snapend = t ;\n length = t - b ;\n if ( length < 1 ) goto trunc ;\n proto = * b ;\n switch ( proto ) {\n case PPP_IP : ip_print ( ndo , b + 1 , length - 1 ) ;\n goto cleanup ;\n case PPP_IPV6 : ip6_print ( ndo , b + 1 , length - 1 ) ;\n goto cleanup ;\n default : break ;\n }\n if ( length < 2 ) goto trunc ;\n proto = EXTRACT_16BITS ( b ) ;\n switch ( proto ) {\n case ( PPP_ADDRESS << 8 | PPP_CONTROL ) : if ( length < 4 ) goto trunc ;\n proto = EXTRACT_16BITS ( b + 2 ) ;\n handle_ppp ( ndo , proto , b + 4 , length - 4 ) ;\n break ;\n default : handle_ppp ( ndo , proto , b + 2 , length - 2 ) ;\n break ;\n }\n cleanup : ndo -> ndo_snapend = se ;\n free ( b ) ;\n return ;\n trunc : ndo -> ndo_snapend = se ;\n free ( b ) ;\n ND_PRINT ( ( ndo , \"[|ppp]\" ) ) ;\n }", "idx": 22440}
{"hash": -4719501675862910941, "project": "debian", "size": 11, "label": 0, "functionSource": "void proto_reg_handoff_h245 ( void ) {\n dissector_handle_t h245_handle ;\n rtcp_handle = find_dissector ( \"rtcp\" ) ;\n data_handle = find_dissector ( \"data\" ) ;\n h263_handle = find_dissector ( \"h263data\" ) ;\n amr_handle = find_dissector ( \"amr_if2_nb\" ) ;\n h245_handle = find_dissector ( \"h245\" ) ;\n dissector_add_handle ( \"tcp.port\" , h245_handle ) ;\n MultimediaSystemControlMessage_handle = find_dissector ( \"h245dg\" ) ;\n dissector_add_handle ( \"udp.port\" , MultimediaSystemControlMessage_handle ) ;\n }", "idx": 22441}
{"hash": 1859256631654516868, "project": "chrome", "size": 42, "label": 0, "functionSource": "static int context_init ( H264Context * h ) {\n ERContext * er = & h -> er ;\n int mb_array_size = h -> mb_height * h -> mb_stride ;\n int y_size = ( 2 * h -> mb_width + 1 ) * ( 2 * h -> mb_height + 1 ) ;\n int c_size = h -> mb_stride * ( h -> mb_height + 1 ) ;\n int yc_size = y_size + 2 * c_size ;\n int x , y , i ;\n FF_ALLOCZ_OR_GOTO ( h -> avctx , h -> top_borders [ 0 ] , h -> mb_width * 16 * 3 * sizeof ( uint8_t ) * 2 , fail ) FF_ALLOCZ_OR_GOTO ( h -> avctx , h -> top_borders [ 1 ] , h -> mb_width * 16 * 3 * sizeof ( uint8_t ) * 2 , fail ) h -> ref_cache [ 0 ] [ scan8 [ 5 ] + 1 ] = h -> ref_cache [ 0 ] [ scan8 [ 7 ] + 1 ] = h -> ref_cache [ 0 ] [ scan8 [ 13 ] + 1 ] = h -> ref_cache [ 1 ] [ scan8 [ 5 ] + 1 ] = h -> ref_cache [ 1 ] [ scan8 [ 7 ] + 1 ] = h -> ref_cache [ 1 ] [ scan8 [ 13 ] + 1 ] = PART_NOT_AVAILABLE ;\n if ( CONFIG_ERROR_RESILIENCE ) {\n er -> avctx = h -> avctx ;\n er -> dsp = & h -> dsp ;\n er -> decode_mb = h264_er_decode_mb ;\n er -> opaque = h ;\n er -> quarter_sample = 1 ;\n er -> mb_num = h -> mb_num ;\n er -> mb_width = h -> mb_width ;\n er -> mb_height = h -> mb_height ;\n er -> mb_stride = h -> mb_stride ;\n er -> b8_stride = h -> mb_width * 2 + 1 ;\n FF_ALLOCZ_OR_GOTO ( h -> avctx , er -> mb_index2xy , ( h -> mb_num + 1 ) * sizeof ( int ) , fail ) ;\n for ( y = 0 ;\n y < h -> mb_height ;\n y ++ ) for ( x = 0 ;\n x < h -> mb_width ;\n x ++ ) er -> mb_index2xy [ x + y * h -> mb_width ] = x + y * h -> mb_stride ;\n er -> mb_index2xy [ h -> mb_height * h -> mb_width ] = ( h -> mb_height - 1 ) * h -> mb_stride + h -> mb_width ;\n FF_ALLOCZ_OR_GOTO ( h -> avctx , er -> error_status_table , mb_array_size * sizeof ( uint8_t ) , fail ) ;\n FF_ALLOC_OR_GOTO ( h -> avctx , er -> mbintra_table , mb_array_size , fail ) ;\n memset ( er -> mbintra_table , 1 , mb_array_size ) ;\n FF_ALLOCZ_OR_GOTO ( h -> avctx , er -> mbskip_table , mb_array_size + 2 , fail ) ;\n FF_ALLOC_OR_GOTO ( h -> avctx , er -> er_temp_buffer , h -> mb_height * h -> mb_stride , fail ) ;\n FF_ALLOCZ_OR_GOTO ( h -> avctx , h -> dc_val_base , yc_size * sizeof ( int16_t ) , fail ) ;\n er -> dc_val [ 0 ] = h -> dc_val_base + h -> mb_width * 2 + 2 ;\n er -> dc_val [ 1 ] = h -> dc_val_base + y_size + h -> mb_stride + 1 ;\n er -> dc_val [ 2 ] = er -> dc_val [ 1 ] + c_size ;\n for ( i = 0 ;\n i < yc_size ;\n i ++ ) h -> dc_val_base [ i ] = 1024 ;\n }\n return 0 ;\n fail : return AVERROR ( ENOMEM ) ;\n }", "idx": 22442}
{"hash": 6755873269946787742, "project": "debian", "size": 35, "label": 0, "functionSource": "static void pk_transaction_search_groups ( PkTransaction * transaction , GVariant * params , GDBusMethodInvocation * context ) {\n gboolean ret ;\n guint i ;\n PkBitfield filter ;\n g_autofree gchar * * values = NULL ;\n g_autoptr ( GError ) error = NULL ;\n g_return_if_fail ( PK_IS_TRANSACTION ( transaction ) ) ;\n g_return_if_fail ( transaction -> priv -> tid != NULL ) ;\n g_variant_get ( params , \"(t^a&s)\" , & filter , & values ) ;\n g_debug ( \"SearchGroups method called: %\" G_GUINT64_FORMAT \", %s\" , filter , values [ 0 ] ) ;\n if ( ! pk_backend_is_implemented ( transaction -> priv -> backend , PK_ROLE_ENUM_SEARCH_GROUP ) ) {\n g_set_error ( & error , PK_TRANSACTION_ERROR , PK_TRANSACTION_ERROR_NOT_SUPPORTED , \"SearchGroups not supported by backend\" ) ;\n pk_transaction_set_state ( transaction , PK_TRANSACTION_STATE_ERROR ) ;\n goto out ;\n }\n ret = pk_transaction_search_check ( values , & error ) ;\n if ( ! ret ) {\n pk_transaction_set_state ( transaction , PK_TRANSACTION_STATE_ERROR ) ;\n goto out ;\n }\n for ( i = 0 ;\n values [ i ] != NULL ;\n i ++ ) {\n if ( strstr ( values [ i ] , \" \" ) != NULL ) {\n g_set_error ( & error , PK_TRANSACTION_ERROR , PK_TRANSACTION_ERROR_SEARCH_INVALID , \"Invalid search containing spaces\" ) ;\n pk_transaction_set_state ( transaction , PK_TRANSACTION_STATE_ERROR ) ;\n goto out ;\n }\n }\n transaction -> priv -> cached_filters = filter ;\n transaction -> priv -> cached_values = g_strdupv ( values ) ;\n pk_transaction_set_role ( transaction , PK_ROLE_ENUM_SEARCH_GROUP ) ;\n pk_transaction_set_state ( transaction , PK_TRANSACTION_STATE_READY ) ;\n out : pk_transaction_dbus_return ( context , error ) ;\n }", "idx": 22443}
{"hash": 5737086831275946085, "project": "debian", "size": 7, "label": 0, "functionSource": "static void imlt_window_float ( COOKContext * q , float * inbuffer , cook_gains * gains_ptr , float * previous_buffer ) {\n const float fc = pow2tab [ gains_ptr -> previous [ 0 ] + 63 ] ;\n int i ;\n for ( i = 0 ;\n i < q -> samples_per_channel ;\n i ++ ) inbuffer [ i ] = inbuffer [ i ] * fc * q -> mlt_window [ i ] - previous_buffer [ i ] * q -> mlt_window [ q -> samples_per_channel - 1 - i ] ;\n }", "idx": 22444}
{"hash": -5706788925640467782, "project": "chrome", "size": 45, "label": 1, "functionSource": "static void encode_sb_rt ( VP9_COMP * cpi , const TileInfo * const tile , TOKENEXTRA * * tp , int mi_row , int mi_col , int output_enabled , BLOCK_SIZE bsize , PC_TREE * pc_tree ) {\n VP9_COMMON * const cm = & cpi -> common ;\n MACROBLOCK * const x = & cpi -> mb ;\n MACROBLOCKD * const xd = & x -> e_mbd ;\n const int bsl = b_width_log2 ( bsize ) , hbs = ( 1 << bsl ) / 4 ;\n int ctx ;\n PARTITION_TYPE partition ;\n BLOCK_SIZE subsize ;\n if ( mi_row >= cm -> mi_rows || mi_col >= cm -> mi_cols ) return ;\n if ( bsize >= BLOCK_8X8 ) {\n const int idx_str = xd -> mi_stride * mi_row + mi_col ;\n MODE_INFO * * mi_8x8 = cm -> mi_grid_visible + idx_str ;\n ctx = partition_plane_context ( xd , mi_row , mi_col , bsize ) ;\n subsize = mi_8x8 [ 0 ] -> mbmi . sb_type ;\n }\n else {\n ctx = 0 ;\n subsize = BLOCK_4X4 ;\n }\n partition = partition_lookup [ bsl ] [ subsize ] ;\n if ( output_enabled && bsize != BLOCK_4X4 ) cm -> counts . partition [ ctx ] [ partition ] ++ ;\n switch ( partition ) {\n case PARTITION_NONE : encode_b_rt ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> none ) ;\n break ;\n case PARTITION_VERT : encode_b_rt ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> vertical [ 0 ] ) ;\n if ( mi_col + hbs < cm -> mi_cols && bsize > BLOCK_8X8 ) {\n encode_b_rt ( cpi , tile , tp , mi_row , mi_col + hbs , output_enabled , subsize , & pc_tree -> vertical [ 1 ] ) ;\n }\n break ;\n case PARTITION_HORZ : encode_b_rt ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> horizontal [ 0 ] ) ;\n if ( mi_row + hbs < cm -> mi_rows && bsize > BLOCK_8X8 ) {\n encode_b_rt ( cpi , tile , tp , mi_row + hbs , mi_col , output_enabled , subsize , & pc_tree -> horizontal [ 1 ] ) ;\n }\n break ;\n case PARTITION_SPLIT : subsize = get_subsize ( bsize , PARTITION_SPLIT ) ;\n encode_sb_rt ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize , pc_tree -> split [ 0 ] ) ;\n encode_sb_rt ( cpi , tile , tp , mi_row , mi_col + hbs , output_enabled , subsize , pc_tree -> split [ 1 ] ) ;\n encode_sb_rt ( cpi , tile , tp , mi_row + hbs , mi_col , output_enabled , subsize , pc_tree -> split [ 2 ] ) ;\n encode_sb_rt ( cpi , tile , tp , mi_row + hbs , mi_col + hbs , output_enabled , subsize , pc_tree -> split [ 3 ] ) ;\n break ;\n default : assert ( \"Invalid partition type.\" ) ;\n break ;\n }\n if ( partition != PARTITION_SPLIT || bsize == BLOCK_8X8 ) update_partition_context ( xd , mi_row , mi_col , subsize , bsize ) ;\n }", "idx": 22445}
{"hash": 2388171415474875762, "project": "debian", "size": 12, "label": 0, "functionSource": "static void dissect_rsvp_hello ( proto_tree * ti , proto_tree * rsvp_object_tree , tvbuff_t * tvb , int offset , int obj_length _U_ , int rsvp_class _U_ , int type ) {\n switch ( type ) {\n case 1 : case 2 : proto_tree_add_uint_format_value ( rsvp_object_tree , hf_rsvp_ctype , tvb , offset + 3 , 1 , tvb_get_guint8 ( tvb , offset + 3 ) , \"%d - HELLO %s object\" , tvb_get_guint8 ( tvb , offset + 3 ) , type == 1 ? \"REQUEST\" : \"ACK\" ) ;\n proto_tree_add_item ( rsvp_object_tree , hf_rsvp_hello_source_instance , tvb , offset + 4 , 4 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rsvp_object_tree , hf_rsvp_hello_destination_instance , tvb , offset + 8 , 4 , ENC_BIG_ENDIAN ) ;\n proto_item_append_text ( ti , \": %s. Src Instance: 0x%0x. Dest Instance: 0x%0x. \" , type == 1 ? \"REQUEST\" : \"ACK\" , tvb_get_ntohl ( tvb , offset + 4 ) , tvb_get_ntohl ( tvb , offset + 8 ) ) ;\n break ;\n default : proto_tree_add_uint_format_value ( rsvp_object_tree , hf_rsvp_ctype , tvb , offset + 3 , 1 , type , \"%d - UNKNOWN\" , type ) ;\n break ;\n }\n ;\n }", "idx": 22446}
{"hash": -6024601983167898950, "project": "debian", "size": 10, "label": 0, "functionSource": "static int file_compare_by_mime_type ( NautilusFile * file_a , NautilusFile * file_b ) {\n char * mime_type_a , * mime_type_b ;\n int ret ;\n mime_type_a = nautilus_file_get_mime_type ( file_a ) ;\n mime_type_b = nautilus_file_get_mime_type ( file_b ) ;\n ret = strcmp ( mime_type_a , mime_type_b ) ;\n g_free ( mime_type_a ) ;\n g_free ( mime_type_b ) ;\n return ret ;\n }", "idx": 22447}
{"hash": 7191899184788440065, "project": "debian", "size": 7, "label": 0, "functionSource": "static void report_progress ( const MYSQL * mysql , uint stage , uint max_stage , double progress , const char * proc_info , uint proc_info_length ) {\n uint length = printf ( \"Stage: %d of %d '%.*s' %6.3g%% of stage done\" , stage , max_stage , proc_info_length , proc_info , progress ) ;\n if ( length < last_progress_report_length ) printf ( \"%*s\" , last_progress_report_length - length , \"\" ) ;\n putc ( '\\r' , stdout ) ;\n fflush ( stdout ) ;\n last_progress_report_length = length ;\n }", "idx": 22448}
{"hash": 1182028467273264883, "project": "debian", "size": 8, "label": 0, "functionSource": "void free_pointer_array ( POINTER_ARRAY * pa ) {\n if ( pa -> typelib . count ) {\n pa -> typelib . count = 0 ;\n my_free ( pa -> typelib . type_names ) ;\n pa -> typelib . type_names = 0 ;\n my_free ( pa -> str ) ;\n }\n }", "idx": 22449}
{"hash": 9118387177353441960, "project": "debian", "size": 15, "label": 0, "functionSource": "static char * StrTok ( char * * Src , const char * Del ) {\n char * TmpPtr ;\n char * RetPtr ;\n if ( * Src != NULL ) {\n RetPtr = * Src ;\n TmpPtr = strstr ( * Src , Del ) ;\n if ( TmpPtr != NULL ) {\n * TmpPtr = '\\0' ;\n * Src = TmpPtr + strlen ( Del ) ;\n }\n else * Src = NULL ;\n return RetPtr ;\n }\n return NULL ;\n }", "idx": 22450}
{"hash": -5420171864670538459, "project": "debian", "size": 8, "label": 0, "functionSource": "void cpu_synchronize_all_states ( void ) {\n CPUArchState * env ;\n for ( env = first_cpu ;\n env ;\n env = env -> next_cpu ) {\n cpu_synchronize_state ( ENV_GET_CPU ( env ) ) ;\n }\n }", "idx": 22451}
{"hash": 7037573792123850742, "project": "debian", "size": 33, "label": 0, "functionSource": "static PHP_NAMED_FUNCTION ( zif_zip_read ) {\n zval * zip_dp ;\n zip_read_rsrc * zr_rsrc ;\n int ret ;\n zip_rsrc * rsrc_int ;\n if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , \"r\" , & zip_dp ) == FAILURE ) {\n return ;\n }\n ZEND_FETCH_RESOURCE ( rsrc_int , zip_rsrc * , & zip_dp , - 1 , le_zip_dir_name , le_zip_dir ) ;\n if ( rsrc_int && rsrc_int -> za ) {\n if ( rsrc_int -> index_current >= rsrc_int -> num_files ) {\n RETURN_FALSE ;\n }\n zr_rsrc = emalloc ( sizeof ( zip_read_rsrc ) ) ;\n ret = zip_stat_index ( rsrc_int -> za , rsrc_int -> index_current , 0 , & zr_rsrc -> sb ) ;\n if ( ret != 0 ) {\n efree ( zr_rsrc ) ;\n RETURN_FALSE ;\n }\n zr_rsrc -> zf = zip_fopen_index ( rsrc_int -> za , rsrc_int -> index_current , 0 ) ;\n if ( zr_rsrc -> zf ) {\n rsrc_int -> index_current ++ ;\n ZEND_REGISTER_RESOURCE ( return_value , zr_rsrc , le_zip_entry ) ;\n }\n else {\n efree ( zr_rsrc ) ;\n RETURN_FALSE ;\n }\n }\n else {\n RETURN_FALSE ;\n }\n }", "idx": 22452}
{"hash": 1760449185745615462, "project": "debian", "size": 7, "label": 0, "functionSource": "int TSMimeHdrFieldValuesCount ( TSMBuffer bufp , TSMLoc hdr , TSMLoc field ) {\n sdk_assert ( sdk_sanity_check_mbuffer ( bufp ) == TS_SUCCESS ) ;\n sdk_assert ( ( sdk_sanity_check_mime_hdr_handle ( hdr ) == TS_SUCCESS ) || ( sdk_sanity_check_http_hdr_handle ( hdr ) == TS_SUCCESS ) ) ;\n sdk_assert ( sdk_sanity_check_field_handle ( field , hdr ) == TS_SUCCESS ) ;\n MIMEFieldSDKHandle * handle = ( MIMEFieldSDKHandle * ) field ;\n return mime_field_value_get_comma_val_count ( handle -> field_ptr ) ;\n }", "idx": 22453}
{"hash": -3135212895432241239, "project": "debian", "size": 3, "label": 0, "functionSource": "static void nb_xmit_corrl ( tvbuff_t * tvb , int offset , proto_tree * tree ) {\n proto_tree_add_item ( tree , hf_netb_xmit_corrl , tvb , offset + NB_XMIT_CORL , 2 , ENC_LITTLE_ENDIAN ) ;\n }", "idx": 22454}
{"hash": 7563956670602033500, "project": "chrome", "size": 8, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( HostedAppTest , ShouldShowLocationBarForHostedApp ) {\n SetupApp ( \"app\" , false ) ;\n NavigateAndCheckForLocationBar ( app_browser_ , \"http://www.example.com/empty.html\" , false ) ;\n NavigateAndCheckForLocationBar ( app_browser_ , \"http://www.example.com/blah\" , false ) ;\n NavigateAndCheckForLocationBar ( app_browser_ , \"https://www.example.com/blah\" , false ) ;\n NavigateAndCheckForLocationBar ( app_browser_ , \"http://www.foo.com/blah\" , true ) ;\n NavigateAndCheckForLocationBar ( app_browser_ , \"http://www.example.com/blah\" , false ) ;\n }", "idx": 22455}
{"hash": 313627013719508831, "project": "debian", "size": 5, "label": 0, "functionSource": "static inline MagickBooleanType IsPixelInfoGray ( const PixelInfo * restrict pixel_info ) {\n if ( ( pixel_info -> colorspace != GRAYColorspace ) && ( pixel_info -> colorspace != RGBColorspace ) ) return ( MagickFalse ) ;\n if ( ( AbsolutePixelValue ( pixel_info -> red - pixel_info -> green ) < MagickEpsilon ) && ( AbsolutePixelValue ( pixel_info -> green - pixel_info -> blue ) < MagickEpsilon ) ) return ( MagickTrue ) ;\n return ( MagickFalse ) ;\n }", "idx": 22456}
{"hash": 6632536031698733342, "project": "debian", "size": 5, "label": 0, "functionSource": "static int opt_show_versions ( const char * opt , const char * arg ) {\n mark_section_show_entries ( SECTION_ID_PROGRAM_VERSION , 1 , NULL ) ;\n mark_section_show_entries ( SECTION_ID_LIBRARY_VERSION , 1 , NULL ) ;\n return 0 ;\n }", "idx": 22457}
{"hash": -1335877942018854351, "project": "chrome", "size": 3, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( UnloadTest , BrowserCloseNoUnloadListeners ) {\n LoadUrlAndQuitBrowser ( NOLISTENERS_HTML , \"nolisteners\" ) ;\n }", "idx": 22458}
{"hash": -6068976579504840746, "project": "debian", "size": 62, "label": 0, "functionSource": "static void send_restrict_entry ( restrict_u * pres , int ipv6 , u_int idx ) {\n const char addr_fmtu [ ] = \"addr.%u\" ;\n const char mask_fmtu [ ] = \"mask.%u\" ;\n const char hits_fmt [ ] = \"hits.%u\" ;\n const char flags_fmt [ ] = \"flags.%u\" ;\n char tag [ 32 ] ;\n u_char sent [ RESLIST_FIELDS ] ;\n int noisebits ;\n u_int32 noise ;\n u_int which ;\n u_int remaining ;\n sockaddr_u addr ;\n sockaddr_u mask ;\n const char * pch ;\n char * buf ;\n const char * match_str ;\n const char * access_str ;\n sockaddrs_from_restrict_u ( & addr , & mask , pres , ipv6 ) ;\n remaining = COUNTOF ( sent ) ;\n ZERO ( sent ) ;\n noise = 0 ;\n noisebits = 0 ;\n while ( remaining > 0 ) {\n if ( noisebits < 2 ) {\n noise = rand ( ) ^ ( rand ( ) << 16 ) ;\n noisebits = 31 ;\n }\n which = ( noise & 0x3 ) % COUNTOF ( sent ) ;\n noise >>= 2 ;\n noisebits -= 2 ;\n while ( sent [ which ] ) which = ( which + 1 ) % COUNTOF ( sent ) ;\n switch ( which ) {\n case 0 : snprintf ( tag , sizeof ( tag ) , addr_fmtu , idx ) ;\n pch = stoa ( & addr ) ;\n ctl_putunqstr ( tag , pch , strlen ( pch ) ) ;\n break ;\n case 1 : snprintf ( tag , sizeof ( tag ) , mask_fmtu , idx ) ;\n pch = stoa ( & mask ) ;\n ctl_putunqstr ( tag , pch , strlen ( pch ) ) ;\n break ;\n case 2 : snprintf ( tag , sizeof ( tag ) , hits_fmt , idx ) ;\n ctl_putuint ( tag , pres -> count ) ;\n break ;\n case 3 : snprintf ( tag , sizeof ( tag ) , flags_fmt , idx ) ;\n match_str = res_match_flags ( pres -> mflags ) ;\n access_str = res_access_flags ( pres -> flags ) ;\n if ( '\\0' == match_str [ 0 ] ) {\n pch = access_str ;\n }\n else {\n LIB_GETBUF ( buf ) ;\n snprintf ( buf , LIB_BUFLENGTH , \"%s %s\" , match_str , access_str ) ;\n pch = buf ;\n }\n ctl_putunqstr ( tag , pch , strlen ( pch ) ) ;\n break ;\n }\n sent [ which ] = TRUE ;\n remaining -- ;\n }\n send_random_tag_value ( ( int ) idx ) ;\n }", "idx": 22459}
{"hash": 4383303759030234417, "project": "debian", "size": 51, "label": 0, "functionSource": "static krb5_error_code build_principal_va ( krb5_context context , krb5_principal princ , unsigned int rlen , const char * realm , va_list ap ) {\n krb5_error_code retval = 0 ;\n char * r = NULL ;\n krb5_data * data = NULL ;\n krb5_int32 count = 0 ;\n krb5_int32 size = 2 ;\n char * component = NULL ;\n data = malloc ( size * sizeof ( krb5_data ) ) ;\n if ( ! data ) {\n retval = ENOMEM ;\n }\n if ( ! retval ) r = k5memdup0 ( realm , rlen , & retval ) ;\n while ( ! retval && ( component = va_arg ( ap , char * ) ) ) {\n if ( count == size ) {\n krb5_data * new_data = NULL ;\n size *= 2 ;\n new_data = realloc ( data , size * sizeof ( krb5_data ) ) ;\n if ( new_data ) {\n data = new_data ;\n }\n else {\n retval = ENOMEM ;\n }\n }\n if ( ! retval ) {\n data [ count ] . length = strlen ( component ) ;\n data [ count ] . data = strdup ( component ) ;\n if ( ! data [ count ] . data ) {\n retval = ENOMEM ;\n }\n count ++ ;\n }\n }\n if ( ! retval ) {\n princ -> type = KRB5_NT_UNKNOWN ;\n princ -> magic = KV5M_PRINCIPAL ;\n princ -> realm = make_data ( r , rlen ) ;\n princ -> data = data ;\n princ -> length = count ;\n r = NULL ;\n data = NULL ;\n }\n if ( data ) {\n while ( -- count >= 0 ) {\n free ( data [ count ] . data ) ;\n }\n free ( data ) ;\n }\n free ( r ) ;\n return retval ;\n }", "idx": 22460}
{"hash": 594127775011357110, "project": "debian", "size": 196, "label": 0, "functionSource": "static void ImportBGRAQuantum ( const Image * image , QuantumInfo * quantum_info , const MagickSizeType number_pixels , const unsigned char * magick_restrict p , Quantum * magick_restrict q , ExceptionInfo * exception ) {\n QuantumAny range ;\n register ssize_t x ;\n unsigned int pixel ;\n assert ( image != ( Image * ) NULL ) ;\n assert ( image -> signature == MagickCoreSignature ) ;\n switch ( quantum_info -> depth ) {\n case 8 : {\n unsigned char pixel ;\n for ( x = 0 ;\n x < ( ssize_t ) number_pixels ;\n x ++ ) {\n p = PushCharPixel ( p , & pixel ) ;\n SetPixelBlue ( image , ScaleCharToQuantum ( pixel ) , q ) ;\n p = PushCharPixel ( p , & pixel ) ;\n SetPixelGreen ( image , ScaleCharToQuantum ( pixel ) , q ) ;\n p = PushCharPixel ( p , & pixel ) ;\n SetPixelRed ( image , ScaleCharToQuantum ( pixel ) , q ) ;\n p = PushCharPixel ( p , & pixel ) ;\n SetPixelAlpha ( image , ScaleCharToQuantum ( pixel ) , q ) ;\n p += quantum_info -> pad ;\n q += GetPixelChannels ( image ) ;\n }\n break ;\n }\n case 10 : {\n pixel = 0 ;\n if ( quantum_info -> pack == MagickFalse ) {\n register ssize_t i ;\n size_t quantum ;\n ssize_t n ;\n n = 0 ;\n quantum = 0 ;\n for ( x = 0 ;\n x < ( ssize_t ) number_pixels ;\n x ++ ) {\n for ( i = 0 ;\n i < 4 ;\n i ++ ) {\n switch ( n % 3 ) {\n case 0 : {\n p = PushLongPixel ( quantum_info -> endian , p , & pixel ) ;\n quantum = ( size_t ) ( ScaleShortToQuantum ( ( unsigned short ) ( ( ( pixel >> 22 ) & 0x3ff ) << 6 ) ) ) ;\n break ;\n }\n case 1 : {\n quantum = ( size_t ) ( ScaleShortToQuantum ( ( unsigned short ) ( ( ( pixel >> 12 ) & 0x3ff ) << 6 ) ) ) ;\n break ;\n }\n case 2 : {\n quantum = ( size_t ) ( ScaleShortToQuantum ( ( unsigned short ) ( ( ( pixel >> 2 ) & 0x3ff ) << 6 ) ) ) ;\n break ;\n }\n }\n switch ( i ) {\n case 0 : SetPixelRed ( image , ( Quantum ) quantum , q ) ;\n break ;\n case 1 : SetPixelGreen ( image , ( Quantum ) quantum , q ) ;\n break ;\n case 2 : SetPixelBlue ( image , ( Quantum ) quantum , q ) ;\n break ;\n case 3 : SetPixelAlpha ( image , ( Quantum ) quantum , q ) ;\n break ;\n }\n n ++ ;\n }\n p += quantum_info -> pad ;\n q += GetPixelChannels ( image ) ;\n }\n break ;\n }\n for ( x = 0 ;\n x < ( ssize_t ) number_pixels ;\n x ++ ) {\n p = PushQuantumPixel ( quantum_info , p , & pixel ) ;\n SetPixelRed ( image , ScaleShortToQuantum ( ( unsigned short ) ( pixel << 6 ) ) , q ) ;\n p = PushQuantumPixel ( quantum_info , p , & pixel ) ;\n SetPixelGreen ( image , ScaleShortToQuantum ( ( unsigned short ) ( pixel << 6 ) ) , q ) ;\n p = PushQuantumPixel ( quantum_info , p , & pixel ) ;\n SetPixelBlue ( image , ScaleShortToQuantum ( ( unsigned short ) ( pixel << 6 ) ) , q ) ;\n p = PushQuantumPixel ( quantum_info , p , & pixel ) ;\n SetPixelAlpha ( image , ScaleShortToQuantum ( ( unsigned short ) ( pixel << 6 ) ) , q ) ;\n q += GetPixelChannels ( image ) ;\n }\n break ;\n }\n case 16 : {\n unsigned short pixel ;\n if ( quantum_info -> format == FloatingPointQuantumFormat ) {\n for ( x = 0 ;\n x < ( ssize_t ) number_pixels ;\n x ++ ) {\n p = PushShortPixel ( quantum_info -> endian , p , & pixel ) ;\n SetPixelRed ( image , ClampToQuantum ( QuantumRange * HalfToSinglePrecision ( pixel ) ) , q ) ;\n p = PushShortPixel ( quantum_info -> endian , p , & pixel ) ;\n SetPixelGreen ( image , ClampToQuantum ( QuantumRange * HalfToSinglePrecision ( pixel ) ) , q ) ;\n p = PushShortPixel ( quantum_info -> endian , p , & pixel ) ;\n SetPixelBlue ( image , ClampToQuantum ( QuantumRange * HalfToSinglePrecision ( pixel ) ) , q ) ;\n p = PushShortPixel ( quantum_info -> endian , p , & pixel ) ;\n SetPixelAlpha ( image , ClampToQuantum ( QuantumRange * HalfToSinglePrecision ( pixel ) ) , q ) ;\n p += quantum_info -> pad ;\n q += GetPixelChannels ( image ) ;\n }\n break ;\n }\n for ( x = 0 ;\n x < ( ssize_t ) number_pixels ;\n x ++ ) {\n p = PushShortPixel ( quantum_info -> endian , p , & pixel ) ;\n SetPixelBlue ( image , ScaleShortToQuantum ( pixel ) , q ) ;\n p = PushShortPixel ( quantum_info -> endian , p , & pixel ) ;\n SetPixelGreen ( image , ScaleShortToQuantum ( pixel ) , q ) ;\n p = PushShortPixel ( quantum_info -> endian , p , & pixel ) ;\n SetPixelRed ( image , ScaleShortToQuantum ( pixel ) , q ) ;\n p = PushShortPixel ( quantum_info -> endian , p , & pixel ) ;\n SetPixelAlpha ( image , ScaleShortToQuantum ( pixel ) , q ) ;\n p += quantum_info -> pad ;\n q += GetPixelChannels ( image ) ;\n }\n break ;\n }\n case 32 : {\n unsigned int pixel ;\n if ( quantum_info -> format == FloatingPointQuantumFormat ) {\n float pixel ;\n for ( x = 0 ;\n x < ( ssize_t ) number_pixels ;\n x ++ ) {\n p = PushFloatPixel ( quantum_info , p , & pixel ) ;\n SetPixelRed ( image , ClampToQuantum ( pixel ) , q ) ;\n p = PushFloatPixel ( quantum_info , p , & pixel ) ;\n SetPixelGreen ( image , ClampToQuantum ( pixel ) , q ) ;\n p = PushFloatPixel ( quantum_info , p , & pixel ) ;\n SetPixelBlue ( image , ClampToQuantum ( pixel ) , q ) ;\n p = PushFloatPixel ( quantum_info , p , & pixel ) ;\n SetPixelAlpha ( image , ClampToQuantum ( pixel ) , q ) ;\n p += quantum_info -> pad ;\n q += GetPixelChannels ( image ) ;\n }\n break ;\n }\n for ( x = 0 ;\n x < ( ssize_t ) number_pixels ;\n x ++ ) {\n p = PushLongPixel ( quantum_info -> endian , p , & pixel ) ;\n SetPixelBlue ( image , ScaleLongToQuantum ( pixel ) , q ) ;\n p = PushLongPixel ( quantum_info -> endian , p , & pixel ) ;\n SetPixelGreen ( image , ScaleLongToQuantum ( pixel ) , q ) ;\n p = PushLongPixel ( quantum_info -> endian , p , & pixel ) ;\n SetPixelRed ( image , ScaleLongToQuantum ( pixel ) , q ) ;\n p = PushLongPixel ( quantum_info -> endian , p , & pixel ) ;\n SetPixelAlpha ( image , ScaleLongToQuantum ( pixel ) , q ) ;\n p += quantum_info -> pad ;\n q += GetPixelChannels ( image ) ;\n }\n break ;\n }\n case 64 : {\n if ( quantum_info -> format == FloatingPointQuantumFormat ) {\n double pixel ;\n for ( x = 0 ;\n x < ( ssize_t ) number_pixels ;\n x ++ ) {\n p = PushDoublePixel ( quantum_info , p , & pixel ) ;\n SetPixelRed ( image , ClampToQuantum ( pixel ) , q ) ;\n p = PushDoublePixel ( quantum_info , p , & pixel ) ;\n SetPixelGreen ( image , ClampToQuantum ( pixel ) , q ) ;\n p = PushDoublePixel ( quantum_info , p , & pixel ) ;\n SetPixelBlue ( image , ClampToQuantum ( pixel ) , q ) ;\n p = PushDoublePixel ( quantum_info , p , & pixel ) ;\n SetPixelAlpha ( image , ClampToQuantum ( pixel ) , q ) ;\n p += quantum_info -> pad ;\n q += GetPixelChannels ( image ) ;\n }\n break ;\n }\n }\n default : {\n range = GetQuantumRange ( quantum_info -> depth ) ;\n for ( x = 0 ;\n x < ( ssize_t ) number_pixels ;\n x ++ ) {\n p = PushQuantumPixel ( quantum_info , p , & pixel ) ;\n SetPixelBlue ( image , ScaleAnyToQuantum ( pixel , range ) , q ) ;\n p = PushQuantumPixel ( quantum_info , p , & pixel ) ;\n SetPixelGreen ( image , ScaleAnyToQuantum ( pixel , range ) , q ) ;\n p = PushQuantumPixel ( quantum_info , p , & pixel ) ;\n SetPixelRed ( image , ScaleAnyToQuantum ( pixel , range ) , q ) ;\n p = PushQuantumPixel ( quantum_info , p , & pixel ) ;\n SetPixelAlpha ( image , ScaleAnyToQuantum ( pixel , range ) , q ) ;\n q += GetPixelChannels ( image ) ;\n }\n break ;\n }\n }\n }", "idx": 22461}
{"hash": 2713698759296604855, "project": "debian", "size": 26, "label": 0, "functionSource": "static void dct_unquantize_mpeg2_intra_c ( MpegEncContext * s , int16_t * block , int n , int qscale ) {\n int i , level , nCoeffs ;\n const uint16_t * quant_matrix ;\n if ( s -> alternate_scan ) nCoeffs = 63 ;\n else nCoeffs = s -> block_last_index [ n ] ;\n if ( n < 4 ) block [ 0 ] = block [ 0 ] * s -> y_dc_scale ;\n else block [ 0 ] = block [ 0 ] * s -> c_dc_scale ;\n quant_matrix = s -> intra_matrix ;\n for ( i = 1 ;\n i <= nCoeffs ;\n i ++ ) {\n int j = s -> intra_scantable . permutated [ i ] ;\n level = block [ j ] ;\n if ( level ) {\n if ( level < 0 ) {\n level = - level ;\n level = ( int ) ( level * qscale * quant_matrix [ j ] ) >> 3 ;\n level = - level ;\n }\n else {\n level = ( int ) ( level * qscale * quant_matrix [ j ] ) >> 3 ;\n }\n block [ j ] = level ;\n }\n }\n }", "idx": 22462}
{"hash": -3740862514502467070, "project": "debian", "size": 36, "label": 0, "functionSource": "static void redohhead ( struct alltabs * at , int isv ) {\n int i ;\n struct hhead * head ;\n FILE * f ;\n if ( ! isv ) {\n f = at -> hheadf = tmpfile ( ) ;\n head = & at -> hhead ;\n }\n else {\n f = at -> vheadf = tmpfile ( ) ;\n head = & at -> vhead ;\n }\n putlong ( f , head -> version ) ;\n putshort ( f , head -> ascender ) ;\n putshort ( f , head -> descender ) ;\n putshort ( f , head -> linegap ) ;\n putshort ( f , head -> maxwidth ) ;\n putshort ( f , head -> minlsb ) ;\n putshort ( f , head -> minrsb ) ;\n putshort ( f , head -> maxextent ) ;\n putshort ( f , head -> caretSlopeRise ) ;\n putshort ( f , head -> caretSlopeRun ) ;\n for ( i = 0 ;\n i < 5 ;\n ++ i ) putshort ( f , head -> mbz [ i ] ) ;\n putshort ( f , head -> metricformat ) ;\n putshort ( f , head -> numMetrics ) ;\n if ( ! isv ) {\n at -> hheadlen = ftell ( f ) ;\n if ( ( at -> hheadlen & 2 ) != 0 ) putshort ( f , 0 ) ;\n }\n else {\n at -> vheadlen = ftell ( f ) ;\n if ( ( at -> vheadlen & 2 ) != 0 ) putshort ( f , 0 ) ;\n }\n }", "idx": 22463}
{"hash": -4527380754569407959, "project": "chrome", "size": 2, "label": 1, "functionSource": "static void user_data_key_destroy ( hb_user_data_key_t l ) {\n }", "idx": 22464}
{"hash": 3584320764213684062, "project": "debian", "size": 5, "label": 0, "functionSource": "static int vvalue_tvb_get2 ( tvbuff_t * tvb , int offset , void * val ) {\n guint16 * ui2 = ( guint16 * ) val ;\n * ui2 = tvb_get_letohs ( tvb , offset ) ;\n return 2 ;\n }", "idx": 22465}
{"hash": 7279312193592248512, "project": "debian", "size": 34, "label": 0, "functionSource": "static inline void mc_dir_part ( AVSContext * h , AVFrame * pic , int chroma_height , int delta , int list , uint8_t * dest_y , uint8_t * dest_cb , uint8_t * dest_cr , int src_x_offset , int src_y_offset , qpel_mc_func * qpix_op , h264_chroma_mc_func chroma_op , cavs_vector * mv ) {\n const int mx = mv -> x + src_x_offset * 8 ;\n const int my = mv -> y + src_y_offset * 8 ;\n const int luma_xy = ( mx & 3 ) + ( ( my & 3 ) << 2 ) ;\n uint8_t * src_y = pic -> data [ 0 ] + ( mx >> 2 ) + ( my >> 2 ) * h -> l_stride ;\n uint8_t * src_cb = pic -> data [ 1 ] + ( mx >> 3 ) + ( my >> 3 ) * h -> c_stride ;\n uint8_t * src_cr = pic -> data [ 2 ] + ( mx >> 3 ) + ( my >> 3 ) * h -> c_stride ;\n int extra_width = 0 ;\n int extra_height = extra_width ;\n int emu = 0 ;\n const int full_mx = mx >> 2 ;\n const int full_my = my >> 2 ;\n const int pic_width = 16 * h -> mb_width ;\n const int pic_height = 16 * h -> mb_height ;\n if ( ! pic -> data [ 0 ] ) return ;\n if ( mx & 7 ) extra_width -= 3 ;\n if ( my & 7 ) extra_height -= 3 ;\n if ( full_mx < 0 - extra_width || full_my < 0 - extra_height || full_mx + 16 > pic_width + extra_width || full_my + 16 > pic_height + extra_height ) {\n h -> vdsp . emulated_edge_mc ( h -> edge_emu_buffer , src_y - 2 - 2 * h -> l_stride , h -> l_stride , 16 + 5 , 16 + 5 , full_mx - 2 , full_my - 2 , pic_width , pic_height ) ;\n src_y = h -> edge_emu_buffer + 2 + 2 * h -> l_stride ;\n emu = 1 ;\n }\n qpix_op [ luma_xy ] ( dest_y , src_y , h -> l_stride ) ;\n if ( emu ) {\n h -> vdsp . emulated_edge_mc ( h -> edge_emu_buffer , src_cb , h -> c_stride , 9 , 9 , ( mx >> 3 ) , ( my >> 3 ) , pic_width >> 1 , pic_height >> 1 ) ;\n src_cb = h -> edge_emu_buffer ;\n }\n chroma_op ( dest_cb , src_cb , h -> c_stride , chroma_height , mx & 7 , my & 7 ) ;\n if ( emu ) {\n h -> vdsp . emulated_edge_mc ( h -> edge_emu_buffer , src_cr , h -> c_stride , 9 , 9 , ( mx >> 3 ) , ( my >> 3 ) , pic_width >> 1 , pic_height >> 1 ) ;\n src_cr = h -> edge_emu_buffer ;\n }\n chroma_op ( dest_cr , src_cr , h -> c_stride , chroma_height , mx & 7 , my & 7 ) ;\n }", "idx": 22466}
{"hash": 1760449185745615462, "project": "debian", "size": 3, "label": 0, "functionSource": "const char * TSHttpServerStateNameLookup ( TSServerState state ) {\n return HttpDebugNames : : get_server_state_name ( static_cast < HttpTransact : : ServerState_t > ( state ) ) ;\n }", "idx": 22467}
{"hash": 2687336064028423153, "project": "chrome", "size": 11, "label": 0, "functionSource": "static void request_submit ( struct request * const req ) {\n if ( req -> ns ) {\n evdns_request_insert ( req , & req_head ) ;\n global_requests_inflight ++ ;\n evdns_request_transmit ( req ) ;\n }\n else {\n evdns_request_insert ( req , & req_waiting_head ) ;\n global_requests_waiting ++ ;\n }\n }", "idx": 22468}
{"hash": -7855974557509681261, "project": "debian", "size": 10, "label": 0, "functionSource": "void op_input_types ( Oid opno , Oid * lefttype , Oid * righttype ) {\n HeapTuple tp ;\n Form_pg_operator optup ;\n tp = SearchSysCache1 ( OPEROID , ObjectIdGetDatum ( opno ) ) ;\n if ( ! HeapTupleIsValid ( tp ) ) elog ( ERROR , \"cache lookup failed for operator %u\" , opno ) ;\n optup = ( Form_pg_operator ) GETSTRUCT ( tp ) ;\n * lefttype = optup -> oprleft ;\n * righttype = optup -> oprright ;\n ReleaseSysCache ( tp ) ;\n }", "idx": 22469}
{"hash": -3740862514502467070, "project": "debian", "size": 8, "label": 0, "functionSource": "static int32 getuint32 ( FILE * ttf ) {\n int ch1 = getc ( ttf ) ;\n int ch2 = getc ( ttf ) ;\n int ch3 = getc ( ttf ) ;\n int ch4 = getc ( ttf ) ;\n if ( ch4 == EOF ) return ( EOF ) ;\n return ( ( ch1 << 24 ) | ( ch2 << 16 ) | ( ch3 << 8 ) | ch4 ) ;\n }", "idx": 22470}
{"hash": -938099838013462850, "project": "debian", "size": 8, "label": 0, "functionSource": "static enum AVPixelFormat get_chroma_format ( SchroChromaFormat schro_pix_fmt ) {\n int num_formats = sizeof ( schro_pixel_format_map ) / sizeof ( schro_pixel_format_map [ 0 ] ) ;\n int idx ;\n for ( idx = 0 ;\n idx < num_formats ;\n ++ idx ) if ( schro_pixel_format_map [ idx ] . schro_pix_fmt == schro_pix_fmt ) return schro_pixel_format_map [ idx ] . ff_pix_fmt ;\n return AV_PIX_FMT_NONE ;\n }", "idx": 22471}
{"hash": 1245821301839614810, "project": "debian", "size": 13, "label": 0, "functionSource": "static GList * location_list_from_uri_list ( const GList * uris ) {\n const GList * l ;\n GList * files ;\n GFile * f ;\n files = NULL ;\n for ( l = uris ;\n l != NULL ;\n l = l -> next ) {\n f = g_file_new_for_uri ( l -> data ) ;\n files = g_list_prepend ( files , f ) ;\n }\n return g_list_reverse ( files ) ;\n }", "idx": 22472}
{"hash": 8895005875911486570, "project": "debian", "size": 5, "label": 0, "functionSource": "static void curses_kill_connections ( void ) {\n DEBUG_MSG ( \"curses_kill_connections\" ) ;\n wdg_del_idle_callback ( refresh_connections ) ;\n wdg_connections = NULL ;\n }", "idx": 22473}
{"hash": 1931051720960659129, "project": "debian", "size": 121, "label": 1, "functionSource": "DEFINE_TEST ( test_write_disk_secure ) {\n # if defined ( _WIN32 ) && ! defined ( __CYGWIN__ ) skipping ( \"archive_write_disk security checks not supported on Windows\" ) ;\n # else struct archive * a ;\n struct archive_entry * ae ;\n struct stat st ;\n assertUmask ( UMASK ) ;\n assert ( ( a = archive_write_disk_new ( ) ) != NULL ) ;\n assert ( ( ae = archive_entry_new ( ) ) != NULL ) ;\n archive_entry_copy_pathname ( ae , \"dir\" ) ;\n archive_entry_set_mode ( ae , S_IFDIR | 0777 ) ;\n assert ( 0 == archive_write_header ( a , ae ) ) ;\n archive_entry_free ( ae ) ;\n assert ( 0 == archive_write_finish_entry ( a ) ) ;\n assert ( ( ae = archive_entry_new ( ) ) != NULL ) ;\n archive_entry_copy_pathname ( ae , \"link_to_dir\" ) ;\n archive_entry_set_mode ( ae , S_IFLNK | 0777 ) ;\n archive_entry_set_symlink ( ae , \"dir\" ) ;\n archive_write_disk_set_options ( a , 0 ) ;\n assert ( 0 == archive_write_header ( a , ae ) ) ;\n assert ( 0 == archive_write_finish_entry ( a ) ) ;\n assert ( archive_entry_clear ( ae ) != NULL ) ;\n archive_entry_copy_pathname ( ae , \"link_to_dir/filea\" ) ;\n archive_entry_set_mode ( ae , S_IFREG | 0777 ) ;\n assert ( 0 == archive_write_header ( a , ae ) ) ;\n assert ( 0 == archive_write_finish_entry ( a ) ) ;\n assert ( archive_entry_clear ( ae ) != NULL ) ;\n archive_entry_copy_pathname ( ae , \"link_to_dir/fileb\" ) ;\n archive_entry_set_mode ( ae , S_IFREG | 0777 ) ;\n archive_write_disk_set_options ( a , ARCHIVE_EXTRACT_SECURE_SYMLINKS ) ;\n failure ( \"Extracting a file through a symlink should fail here.\" ) ;\n assertEqualInt ( ARCHIVE_FAILED , archive_write_header ( a , ae ) ) ;\n archive_entry_free ( ae ) ;\n assert ( 0 == archive_write_finish_entry ( a ) ) ;\n assert ( ( ae = archive_entry_new ( ) ) != NULL ) ;\n archive_entry_copy_pathname ( ae , \"link_to_dir2\" ) ;\n archive_entry_set_mode ( ae , S_IFLNK | 0777 ) ;\n archive_entry_set_symlink ( ae , \"dir\" ) ;\n archive_write_disk_set_options ( a , 0 ) ;\n assert ( 0 == archive_write_header ( a , ae ) ) ;\n assert ( 0 == archive_write_finish_entry ( a ) ) ;\n assert ( archive_entry_clear ( ae ) != NULL ) ;\n archive_entry_copy_pathname ( ae , \"link_to_dir2/filec\" ) ;\n archive_entry_set_mode ( ae , S_IFREG | 0777 ) ;\n archive_write_disk_set_options ( a , ARCHIVE_EXTRACT_SECURE_SYMLINKS | ARCHIVE_EXTRACT_UNLINK ) ;\n assertEqualIntA ( a , ARCHIVE_OK , archive_write_header ( a , ae ) ) ;\n archive_entry_free ( ae ) ;\n assert ( 0 == archive_write_finish_entry ( a ) ) ;\n assert ( ( ae = archive_entry_new ( ) ) != NULL ) ;\n archive_entry_copy_pathname ( ae , \"link_to_dir3\" ) ;\n archive_entry_set_mode ( ae , S_IFLNK | 0777 ) ;\n archive_entry_set_symlink ( ae , \"dir\" ) ;\n archive_write_disk_set_options ( a , 0 ) ;\n assert ( 0 == archive_write_header ( a , ae ) ) ;\n assert ( 0 == archive_write_finish_entry ( a ) ) ;\n assert ( archive_entry_clear ( ae ) != NULL ) ;\n archive_entry_copy_pathname ( ae , \"link_to_dir3\" ) ;\n archive_entry_set_mode ( ae , S_IFDIR | 0777 ) ;\n assert ( 0 == archive_write_header ( a , ae ) ) ;\n assert ( 0 == archive_write_finish_entry ( a ) ) ;\n assertEqualInt ( 0 , lstat ( \"link_to_dir3\" , & st ) ) ;\n assert ( S_ISLNK ( st . st_mode ) ) ;\n archive_entry_free ( ae ) ;\n assert ( ( ae = archive_entry_new ( ) ) != NULL ) ;\n archive_entry_copy_pathname ( ae , \"link_to_dir4\" ) ;\n archive_entry_set_mode ( ae , S_IFLNK | 0777 ) ;\n archive_entry_set_symlink ( ae , \"nonexistent_dir\" ) ;\n archive_write_disk_set_options ( a , 0 ) ;\n assert ( 0 == archive_write_header ( a , ae ) ) ;\n assert ( 0 == archive_write_finish_entry ( a ) ) ;\n assert ( archive_entry_clear ( ae ) != NULL ) ;\n archive_entry_copy_pathname ( ae , \"link_to_dir4\" ) ;\n archive_entry_set_mode ( ae , S_IFDIR | 0777 ) ;\n assert ( 0 == archive_write_header ( a , ae ) ) ;\n assert ( 0 == archive_write_finish_entry ( a ) ) ;\n assertEqualInt ( 0 , lstat ( \"link_to_dir4\" , & st ) ) ;\n assert ( S_ISDIR ( st . st_mode ) ) ;\n archive_entry_free ( ae ) ;\n assert ( ( ae = archive_entry_new ( ) ) != NULL ) ;\n archive_entry_copy_pathname ( ae , \"non_dir\" ) ;\n archive_entry_set_mode ( ae , S_IFREG | 0777 ) ;\n archive_write_disk_set_options ( a , 0 ) ;\n assert ( 0 == archive_write_header ( a , ae ) ) ;\n assert ( 0 == archive_write_finish_entry ( a ) ) ;\n archive_entry_copy_pathname ( ae , \"link_to_dir5\" ) ;\n archive_entry_set_mode ( ae , S_IFLNK | 0777 ) ;\n archive_entry_set_symlink ( ae , \"non_dir\" ) ;\n archive_write_disk_set_options ( a , 0 ) ;\n assert ( 0 == archive_write_header ( a , ae ) ) ;\n assert ( 0 == archive_write_finish_entry ( a ) ) ;\n assert ( archive_entry_clear ( ae ) != NULL ) ;\n archive_entry_copy_pathname ( ae , \"link_to_dir5\" ) ;\n archive_entry_set_mode ( ae , S_IFDIR | 0777 ) ;\n assert ( 0 == archive_write_header ( a , ae ) ) ;\n assert ( 0 == archive_write_finish_entry ( a ) ) ;\n assertEqualInt ( 0 , lstat ( \"link_to_dir5\" , & st ) ) ;\n assert ( S_ISDIR ( st . st_mode ) ) ;\n archive_entry_free ( ae ) ;\n assertEqualInt ( ARCHIVE_OK , archive_write_free ( a ) ) ;\n assert ( 0 == lstat ( \"dir\" , & st ) ) ;\n failure ( \"dir: st.st_mode=%o\" , st . st_mode ) ;\n assert ( ( st . st_mode & 0777 ) == 0755 ) ;\n assert ( 0 == lstat ( \"link_to_dir\" , & st ) ) ;\n failure ( \"link_to_dir: st.st_mode=%o\" , st . st_mode ) ;\n assert ( S_ISLNK ( st . st_mode ) ) ;\n # if HAVE_LCHMOD failure ( \"link_to_dir: st.st_mode=%o\" , st . st_mode ) ;\n assert ( ( st . st_mode & 07777 ) == 0755 ) ;\n # endif assert ( 0 == lstat ( \"dir/filea\" , & st ) ) ;\n failure ( \"dir/filea: st.st_mode=%o\" , st . st_mode ) ;\n assert ( ( st . st_mode & 07777 ) == 0755 ) ;\n failure ( \"dir/fileb: This file should not have been created\" ) ;\n assert ( 0 != lstat ( \"dir/fileb\" , & st ) ) ;\n assert ( 0 == lstat ( \"link_to_dir2\" , & st ) ) ;\n failure ( \"link_to_dir2 should have been re-created as a true dir\" ) ;\n assert ( S_ISDIR ( st . st_mode ) ) ;\n failure ( \"link_to_dir2: Implicit dir creation should obey umask, but st.st_mode=%o\" , st . st_mode ) ;\n assert ( ( st . st_mode & 0777 ) == 0755 ) ;\n assert ( 0 == lstat ( \"link_to_dir2/filec\" , & st ) ) ;\n assert ( S_ISREG ( st . st_mode ) ) ;\n failure ( \"link_to_dir2/filec: st.st_mode=%o\" , st . st_mode ) ;\n assert ( ( st . st_mode & 07777 ) == 0755 ) ;\n # endif }", "idx": 22474}
{"hash": -8721757784652752372, "project": "debian", "size": 17, "label": 1, "functionSource": "static void band_destroy ( jpc_enc_band_t * band ) {\n jpc_enc_prc_t * prc ;\n jpc_enc_rlvl_t * rlvl ;\n uint_fast32_t prcno ;\n if ( band -> prcs ) {\n rlvl = band -> rlvl ;\n for ( prcno = 0 , prc = band -> prcs ;\n prcno < rlvl -> numprcs ;\n ++ prcno , ++ prc ) {\n prc_destroy ( prc ) ;\n }\n jas_free ( band -> prcs ) ;\n }\n if ( band -> data ) {\n jas_seq2d_destroy ( band -> data ) ;\n }\n }", "idx": 22475}
{"hash": 2335222688263906532, "project": "debian", "size": 9, "label": 0, "functionSource": "static void rv34_decoder_free ( RV34DecContext * r ) {\n av_freep ( & r -> intra_types_hist ) ;\n r -> intra_types = NULL ;\n av_freep ( & r -> tmp_b_block_base ) ;\n av_freep ( & r -> mb_type ) ;\n av_freep ( & r -> cbp_luma ) ;\n av_freep ( & r -> cbp_chroma ) ;\n av_freep ( & r -> deblock_coefs ) ;\n }", "idx": 22476}
{"hash": 6080147530626246065, "project": "debian", "size": 130, "label": 1, "functionSource": "static void vc1_mc_4mv_luma ( VC1Context * v , int n , int dir ) {\n MpegEncContext * s = & v -> s ;\n DSPContext * dsp = & v -> s . dsp ;\n uint8_t * srcY ;\n int dxy , mx , my , src_x , src_y ;\n int off ;\n int fieldmv = ( v -> fcm == ILACE_FRAME ) ? v -> blk_mv_type [ s -> block_index [ n ] ] : 0 ;\n int v_edge_pos = s -> v_edge_pos >> v -> field_mode ;\n if ( ( ! v -> field_mode || ( v -> ref_field_type [ dir ] == 1 && v -> cur_field_type == 1 ) ) && ! v -> s . last_picture . f . data [ 0 ] ) return ;\n mx = s -> mv [ dir ] [ n ] [ 0 ] ;\n my = s -> mv [ dir ] [ n ] [ 1 ] ;\n if ( ! dir ) {\n if ( v -> field_mode ) {\n if ( ( v -> cur_field_type != v -> ref_field_type [ dir ] ) && v -> cur_field_type ) srcY = s -> current_picture . f . data [ 0 ] ;\n else srcY = s -> last_picture . f . data [ 0 ] ;\n }\n else srcY = s -> last_picture . f . data [ 0 ] ;\n }\n else srcY = s -> next_picture . f . data [ 0 ] ;\n if ( v -> field_mode ) {\n if ( v -> cur_field_type != v -> ref_field_type [ dir ] ) my = my - 2 + 4 * v -> cur_field_type ;\n }\n if ( s -> pict_type == AV_PICTURE_TYPE_P && n == 3 && v -> field_mode ) {\n int same_count = 0 , opp_count = 0 , k ;\n int chosen_mv [ 2 ] [ 4 ] [ 2 ] , f ;\n int tx , ty ;\n for ( k = 0 ;\n k < 4 ;\n k ++ ) {\n f = v -> mv_f [ 0 ] [ s -> block_index [ k ] + v -> blocks_off ] ;\n chosen_mv [ f ] [ f ? opp_count : same_count ] [ 0 ] = s -> mv [ 0 ] [ k ] [ 0 ] ;\n chosen_mv [ f ] [ f ? opp_count : same_count ] [ 1 ] = s -> mv [ 0 ] [ k ] [ 1 ] ;\n opp_count += f ;\n same_count += 1 - f ;\n }\n f = opp_count > same_count ;\n switch ( f ? opp_count : same_count ) {\n case 4 : tx = median4 ( chosen_mv [ f ] [ 0 ] [ 0 ] , chosen_mv [ f ] [ 1 ] [ 0 ] , chosen_mv [ f ] [ 2 ] [ 0 ] , chosen_mv [ f ] [ 3 ] [ 0 ] ) ;\n ty = median4 ( chosen_mv [ f ] [ 0 ] [ 1 ] , chosen_mv [ f ] [ 1 ] [ 1 ] , chosen_mv [ f ] [ 2 ] [ 1 ] , chosen_mv [ f ] [ 3 ] [ 1 ] ) ;\n break ;\n case 3 : tx = mid_pred ( chosen_mv [ f ] [ 0 ] [ 0 ] , chosen_mv [ f ] [ 1 ] [ 0 ] , chosen_mv [ f ] [ 2 ] [ 0 ] ) ;\n ty = mid_pred ( chosen_mv [ f ] [ 0 ] [ 1 ] , chosen_mv [ f ] [ 1 ] [ 1 ] , chosen_mv [ f ] [ 2 ] [ 1 ] ) ;\n break ;\n case 2 : tx = ( chosen_mv [ f ] [ 0 ] [ 0 ] + chosen_mv [ f ] [ 1 ] [ 0 ] ) / 2 ;\n ty = ( chosen_mv [ f ] [ 0 ] [ 1 ] + chosen_mv [ f ] [ 1 ] [ 1 ] ) / 2 ;\n break ;\n }\n s -> current_picture . f . motion_val [ 1 ] [ s -> block_index [ 0 ] + v -> blocks_off ] [ 0 ] = tx ;\n s -> current_picture . f . motion_val [ 1 ] [ s -> block_index [ 0 ] + v -> blocks_off ] [ 1 ] = ty ;\n for ( k = 0 ;\n k < 4 ;\n k ++ ) v -> mv_f [ 1 ] [ s -> block_index [ k ] + v -> blocks_off ] = f ;\n }\n if ( v -> fcm == ILACE_FRAME ) {\n int qx , qy ;\n int width = s -> avctx -> coded_width ;\n int height = s -> avctx -> coded_height >> 1 ;\n qx = ( s -> mb_x * 16 ) + ( mx >> 2 ) ;\n qy = ( s -> mb_y * 8 ) + ( my >> 3 ) ;\n if ( qx < - 17 ) mx -= 4 * ( qx + 17 ) ;\n else if ( qx > width ) mx -= 4 * ( qx - width ) ;\n if ( qy < - 18 ) my -= 8 * ( qy + 18 ) ;\n else if ( qy > height + 1 ) my -= 8 * ( qy - height - 1 ) ;\n }\n if ( ( v -> fcm == ILACE_FRAME ) && fieldmv ) off = ( ( n > 1 ) ? s -> linesize : 0 ) + ( n & 1 ) * 8 ;\n else off = s -> linesize * 4 * ( n & 2 ) + ( n & 1 ) * 8 ;\n if ( v -> field_mode && v -> cur_field_type ) off += s -> current_picture_ptr -> f . linesize [ 0 ] ;\n src_x = s -> mb_x * 16 + ( n & 1 ) * 8 + ( mx >> 2 ) ;\n if ( ! fieldmv ) src_y = s -> mb_y * 16 + ( n & 2 ) * 4 + ( my >> 2 ) ;\n else src_y = s -> mb_y * 16 + ( ( n > 1 ) ? 1 : 0 ) + ( my >> 2 ) ;\n if ( v -> profile != PROFILE_ADVANCED ) {\n src_x = av_clip ( src_x , - 16 , s -> mb_width * 16 ) ;\n src_y = av_clip ( src_y , - 16 , s -> mb_height * 16 ) ;\n }\n else {\n src_x = av_clip ( src_x , - 17 , s -> avctx -> coded_width ) ;\n if ( v -> fcm == ILACE_FRAME ) {\n if ( src_y & 1 ) src_y = av_clip ( src_y , - 17 , s -> avctx -> coded_height + 1 ) ;\n else src_y = av_clip ( src_y , - 18 , s -> avctx -> coded_height ) ;\n }\n else {\n src_y = av_clip ( src_y , - 18 , s -> avctx -> coded_height + 1 ) ;\n }\n }\n srcY += src_y * s -> linesize + src_x ;\n if ( v -> field_mode && v -> ref_field_type [ dir ] ) srcY += s -> current_picture_ptr -> f . linesize [ 0 ] ;\n if ( fieldmv && ! ( src_y & 1 ) ) v_edge_pos -- ;\n if ( fieldmv && ( src_y & 1 ) && src_y < 4 ) src_y -- ;\n if ( v -> rangeredfrm || ( v -> mv_mode == MV_PMODE_INTENSITY_COMP ) || s -> h_edge_pos < 13 || v_edge_pos < 23 || ( unsigned ) ( src_x - s -> mspel ) > s -> h_edge_pos - ( mx & 3 ) - 8 - s -> mspel * 2 || ( unsigned ) ( src_y - ( s -> mspel << fieldmv ) ) > v_edge_pos - ( my & 3 ) - ( ( 8 + s -> mspel * 2 ) << fieldmv ) ) {\n srcY -= s -> mspel * ( 1 + ( s -> linesize << fieldmv ) ) ;\n s -> vdsp . emulated_edge_mc ( s -> edge_emu_buffer , srcY , s -> linesize , 9 + s -> mspel * 2 , ( 9 + s -> mspel * 2 ) << fieldmv , src_x - s -> mspel , src_y - ( s -> mspel << fieldmv ) , s -> h_edge_pos , v_edge_pos ) ;\n srcY = s -> edge_emu_buffer ;\n if ( v -> rangeredfrm ) {\n int i , j ;\n uint8_t * src ;\n src = srcY ;\n for ( j = 0 ;\n j < 9 + s -> mspel * 2 ;\n j ++ ) {\n for ( i = 0 ;\n i < 9 + s -> mspel * 2 ;\n i ++ ) src [ i ] = ( ( src [ i ] - 128 ) >> 1 ) + 128 ;\n src += s -> linesize << fieldmv ;\n }\n }\n if ( v -> mv_mode == MV_PMODE_INTENSITY_COMP ) {\n int i , j ;\n uint8_t * src ;\n src = srcY ;\n for ( j = 0 ;\n j < 9 + s -> mspel * 2 ;\n j ++ ) {\n for ( i = 0 ;\n i < 9 + s -> mspel * 2 ;\n i ++ ) src [ i ] = v -> luty [ src [ i ] ] ;\n src += s -> linesize << fieldmv ;\n }\n }\n srcY += s -> mspel * ( 1 + ( s -> linesize << fieldmv ) ) ;\n }\n if ( s -> mspel ) {\n dxy = ( ( my & 3 ) << 2 ) | ( mx & 3 ) ;\n v -> vc1dsp . put_vc1_mspel_pixels_tab [ dxy ] ( s -> dest [ 0 ] + off , srcY , s -> linesize << fieldmv , v -> rnd ) ;\n }\n else {\n dxy = ( my & 2 ) | ( ( mx & 2 ) >> 1 ) ;\n if ( ! v -> rnd ) dsp -> put_pixels_tab [ 1 ] [ dxy ] ( s -> dest [ 0 ] + off , srcY , s -> linesize , 8 ) ;\n else dsp -> put_no_rnd_pixels_tab [ 1 ] [ dxy ] ( s -> dest [ 0 ] + off , srcY , s -> linesize , 8 ) ;\n }\n }", "idx": 22477}
{"hash": -2323311514228246061, "project": "chrome", "size": 31, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( DownloadExtensionTest , MAYBE_DownloadExtensionTest_OnDeterminingFilename_RemoveFilenameDeterminer ) {\n ASSERT_TRUE ( StartEmbeddedTestServer ( ) ) ;\n GoOnTheRecord ( ) ;\n LoadExtension ( \"downloads_split\" ) ;\n content : : RenderProcessHost * host = AddFilenameDeterminer ( ) ;\n std : : string download_url = embedded_test_server ( ) -> GetURL ( \"/slow?0\" ) . spec ( ) ;\n std : : unique_ptr < base : : Value > result ( RunFunctionAndReturnResult ( new DownloadsDownloadFunction ( ) , base : : StringPrintf ( \"[{\n\\\"url\\\": \\\"%s\\\"}\n]\" , download_url . c_str ( ) ) ) ) ;\n ASSERT_TRUE ( result . get ( ) ) ;\n int result_id = - 1 ;\n ASSERT_TRUE ( result -> GetAsInteger ( & result_id ) ) ;\n DownloadItem * item = GetCurrentManager ( ) -> GetDownload ( result_id ) ;\n ASSERT_TRUE ( item ) ;\n ScopedCancellingItem canceller ( item ) ;\n ASSERT_EQ ( download_url , item -> GetOriginalUrl ( ) . spec ( ) ) ;\n ASSERT_TRUE ( WaitFor ( downloads : : OnCreated : : kEventName , base : : StringPrintf ( \"[{\n\\\"danger\\\": \\\"safe\\\",\" \" \\\"incognito\\\": false,\" \" \\\"id\\\": %d,\" \" \\\"mime\\\": \\\"text/plain\\\",\" \" \\\"paused\\\": false,\" \" \\\"url\\\": \\\"%s\\\"}\n]\" , result_id , download_url . c_str ( ) ) ) ) ;\n ASSERT_TRUE ( WaitFor ( downloads : : OnDeterminingFilename : : kEventName , base : : StringPrintf ( \"[{\n\\\"id\\\": %d,\" \" \\\"filename\\\":\\\"slow.txt\\\"}\n]\" , result_id ) ) ) ;\n ASSERT_TRUE ( item -> GetTargetFilePath ( ) . empty ( ) ) ;\n ASSERT_EQ ( DownloadItem : : IN_PROGRESS , item -> GetState ( ) ) ;\n RemoveFilenameDeterminer ( host ) ;\n ASSERT_TRUE ( WaitFor ( downloads : : OnChanged : : kEventName , base : : StringPrintf ( \"[{\n\\\"id\\\": %d,\" \" \\\"state\\\": {\n\" \" \\\"previous\\\": \\\"in_progress\\\",\" \" \\\"current\\\": \\\"complete\\\"}\n}\n]\" , result_id ) ) ) ;\n }", "idx": 22478}
{"hash": 7078129966845159750, "project": "debian", "size": 15, "label": 0, "functionSource": "static inline void idct_put ( MDECContext * a , AVFrame * frame , int mb_x , int mb_y ) {\n int16_t ( * block ) [ 64 ] = a -> block ;\n int linesize = frame -> linesize [ 0 ] ;\n uint8_t * dest_y = frame -> data [ 0 ] + ( mb_y * 16 * linesize ) + mb_x * 16 ;\n uint8_t * dest_cb = frame -> data [ 1 ] + ( mb_y * 8 * frame -> linesize [ 1 ] ) + mb_x * 8 ;\n uint8_t * dest_cr = frame -> data [ 2 ] + ( mb_y * 8 * frame -> linesize [ 2 ] ) + mb_x * 8 ;\n a -> dsp . idct_put ( dest_y , linesize , block [ 0 ] ) ;\n a -> dsp . idct_put ( dest_y + 8 , linesize , block [ 1 ] ) ;\n a -> dsp . idct_put ( dest_y + 8 * linesize , linesize , block [ 2 ] ) ;\n a -> dsp . idct_put ( dest_y + 8 * linesize + 8 , linesize , block [ 3 ] ) ;\n if ( ! ( a -> avctx -> flags & CODEC_FLAG_GRAY ) ) {\n a -> dsp . idct_put ( dest_cb , frame -> linesize [ 1 ] , block [ 4 ] ) ;\n a -> dsp . idct_put ( dest_cr , frame -> linesize [ 2 ] , block [ 5 ] ) ;\n }\n }", "idx": 22479}
{"hash": 7039307292471244756, "project": "debian", "size": 11, "label": 0, "functionSource": "static void dtap_cc_user_info ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len ) {\n guint32 curr_offset ;\n guint32 consumed ;\n guint curr_len ;\n curr_offset = offset ;\n curr_len = len ;\n is_uplink = IS_UPLINK_TRUE ;\n ELEM_MAND_LV ( GSM_A_PDU_TYPE_DTAP , DE_USER_USER , NULL ) ;\n ELEM_OPT_T ( 0xa0 , GSM_A_PDU_TYPE_DTAP , DE_MORE_DATA , NULL ) ;\n EXTRANEOUS_DATA_CHECK ( curr_len , 0 , pinfo , & ei_gsm_a_dtap_extraneous_data ) ;\n }", "idx": 22480}
{"hash": 1760449185745615462, "project": "debian", "size": 5, "label": 0, "functionSource": "int64_t TSHttpTxnClientReqBodyBytesGet ( TSHttpTxn txnp ) {\n sdk_assert ( sdk_sanity_check_txn ( txnp ) == TS_SUCCESS ) ;\n HttpSM * sm = ( HttpSM * ) txnp ;\n return sm -> client_request_body_bytes ;\n }", "idx": 22481}
{"hash": 1760449185745615462, "project": "debian", "size": 15, "label": 0, "functionSource": "TSReturnCode TSHttpTxnServerRespIgnore ( TSHttpTxn txnp ) {\n sdk_assert ( sdk_sanity_check_txn ( txnp ) == TS_SUCCESS ) ;\n HttpTransact : : State * s = & ( ( ( HttpSM * ) txnp ) -> t_state ) ;\n HTTPInfo * cached_obj = s -> cache_info . object_read ;\n HTTPHdr * cached_resp ;\n if ( cached_obj == nullptr || ! cached_obj -> valid ( ) ) {\n return TS_ERROR ;\n }\n cached_resp = cached_obj -> response_get ( ) ;\n if ( cached_resp == nullptr || ! cached_resp -> valid ( ) ) {\n return TS_ERROR ;\n }\n s -> api_server_response_ignore = true ;\n return TS_SUCCESS ;\n }", "idx": 22482}
{"hash": 7039307292471244756, "project": "debian", "size": 14, "label": 0, "functionSource": "static void dtap_cc_release ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len ) {\n guint32 curr_offset ;\n guint32 consumed ;\n guint curr_len ;\n curr_offset = offset ;\n curr_len = len ;\n is_uplink = IS_UPLINK_TRUE ;\n ELEM_OPT_TLV ( 0x08 , GSM_A_PDU_TYPE_DTAP , DE_CAUSE , NULL ) ;\n ELEM_OPT_TLV ( 0x08 , GSM_A_PDU_TYPE_DTAP , DE_CAUSE , \" 2\" ) ;\n ELEM_OPT_TLV ( 0x1c , GSM_A_PDU_TYPE_DTAP , DE_FACILITY , NULL ) ;\n ELEM_OPT_TLV ( 0x7e , GSM_A_PDU_TYPE_DTAP , DE_USER_USER , NULL ) ;\n ELEM_OPT_TLV ( 0x7f , GSM_A_PDU_TYPE_DTAP , DE_SS_VER_IND , NULL ) ;\n EXTRANEOUS_DATA_CHECK ( curr_len , 0 , pinfo , & ei_gsm_a_dtap_extraneous_data ) ;\n }", "idx": 22483}
{"hash": -8395062201045616187, "project": "debian", "size": 5, "label": 0, "functionSource": "static inline int asv1_get_level ( GetBitContext * gb ) {\n int code = get_vlc2 ( gb , level_vlc . table , VLC_BITS , 1 ) ;\n if ( code == 3 ) return get_sbits ( gb , 8 ) ;\n else return code - 3 ;\n }", "idx": 22484}
{"hash": 8323148621905688627, "project": "chrome", "size": 35, "label": 0, "functionSource": "void vp8_denoiser_set_parameters ( VP8_DENOISER * denoiser , int mode ) {\n assert ( mode > 0 ) ;\n if ( mode == 1 ) {\n denoiser -> denoiser_mode = kDenoiserOnYOnly ;\n }\n else if ( mode == 2 ) {\n denoiser -> denoiser_mode = kDenoiserOnYUV ;\n }\n else if ( mode == 3 ) {\n denoiser -> denoiser_mode = kDenoiserOnYUVAggressive ;\n }\n else {\n denoiser -> denoiser_mode = kDenoiserOnAdaptive ;\n }\n if ( denoiser -> denoiser_mode != kDenoiserOnYUVAggressive ) {\n denoiser -> denoise_pars . scale_sse_thresh = 1 ;\n denoiser -> denoise_pars . scale_motion_thresh = 8 ;\n denoiser -> denoise_pars . scale_increase_filter = 0 ;\n denoiser -> denoise_pars . denoise_mv_bias = 95 ;\n denoiser -> denoise_pars . pickmode_mv_bias = 100 ;\n denoiser -> denoise_pars . qp_thresh = 0 ;\n denoiser -> denoise_pars . consec_zerolast = UINT_MAX ;\n denoiser -> denoise_pars . spatial_blur = 0 ;\n }\n else {\n denoiser -> denoise_pars . scale_sse_thresh = 2 ;\n denoiser -> denoise_pars . scale_motion_thresh = 16 ;\n denoiser -> denoise_pars . scale_increase_filter = 1 ;\n denoiser -> denoise_pars . denoise_mv_bias = 60 ;\n denoiser -> denoise_pars . pickmode_mv_bias = 60 ;\n denoiser -> denoise_pars . qp_thresh = 100 ;\n denoiser -> denoise_pars . consec_zerolast = 10 ;\n denoiser -> denoise_pars . spatial_blur = 20 ;\n }\n }", "idx": 22485}
{"hash": -4341894042551388054, "project": "chrome", "size": 38, "label": 0, "functionSource": "static void encode_breakout_test ( VP9_COMP * cpi , MACROBLOCK * x , BLOCK_SIZE bsize , int mi_row , int mi_col , MV_REFERENCE_FRAME ref_frame , PREDICTION_MODE this_mode , unsigned int var_y , unsigned int sse_y , struct buf_2d yv12_mb [ ] [ MAX_MB_PLANE ] , int * rate , int64_t * dist ) {\n MACROBLOCKD * xd = & x -> e_mbd ;\n MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] . src_mi -> mbmi ;\n const BLOCK_SIZE uv_size = get_plane_block_size ( bsize , & xd -> plane [ 1 ] ) ;\n unsigned int var = var_y , sse = sse_y ;\n unsigned int thresh_ac ;\n unsigned int thresh_dc ;\n if ( x -> encode_breakout > 0 ) {\n const unsigned int max_thresh = 36000 ;\n const unsigned int min_thresh = MIN ( ( ( unsigned int ) x -> encode_breakout << 4 ) , max_thresh ) ;\n thresh_ac = ( xd -> plane [ 0 ] . dequant [ 1 ] * xd -> plane [ 0 ] . dequant [ 1 ] ) / 9 ;\n thresh_ac = clamp ( thresh_ac , min_thresh , max_thresh ) ;\n thresh_ac >>= - ( b_width_log2 ( bsize ) + b_height_log2 ( bsize ) ) ;\n thresh_dc = ( xd -> plane [ 0 ] . dequant [ 0 ] * xd -> plane [ 0 ] . dequant [ 0 ] >> 6 ) ;\n }\n else {\n thresh_ac = 0 ;\n thresh_dc = 0 ;\n }\n if ( var <= thresh_ac && ( sse - var ) <= thresh_dc ) {\n unsigned int sse_u , sse_v ;\n unsigned int var_u , var_v ;\n if ( x -> encode_breakout == 0 ) {\n xd -> plane [ 1 ] . pre [ 0 ] = yv12_mb [ ref_frame ] [ 1 ] ;\n xd -> plane [ 2 ] . pre [ 0 ] = yv12_mb [ ref_frame ] [ 2 ] ;\n vp9_build_inter_predictors_sbuv ( xd , mi_row , mi_col , bsize ) ;\n }\n var_u = cpi -> fn_ptr [ uv_size ] . vf ( x -> plane [ 1 ] . src . buf , x -> plane [ 1 ] . src . stride , xd -> plane [ 1 ] . dst . buf , xd -> plane [ 1 ] . dst . stride , & sse_u ) ;\n if ( ( var_u * 4 <= thresh_ac ) && ( sse_u - var_u <= thresh_dc ) ) {\n var_v = cpi -> fn_ptr [ uv_size ] . vf ( x -> plane [ 2 ] . src . buf , x -> plane [ 2 ] . src . stride , xd -> plane [ 2 ] . dst . buf , xd -> plane [ 2 ] . dst . stride , & sse_v ) ;\n if ( ( var_v * 4 <= thresh_ac ) && ( sse_v - var_v <= thresh_dc ) ) {\n x -> skip = 1 ;\n * rate = cpi -> inter_mode_cost [ mbmi -> mode_context [ ref_frame ] ] [ INTER_OFFSET ( this_mode ) ] ;\n * dist = ( sse << 4 ) ;\n }\n }\n }\n }", "idx": 22486}
{"hash": -1270180049246846366, "project": "chrome", "size": 3, "label": 0, "functionSource": "unsigned int hb_face_get_upem ( hb_face_t * face ) {\n return face -> get_upem ( ) ;\n }", "idx": 22487}
{"hash": 3528176083733952042, "project": "debian", "size": 5, "label": 1, "functionSource": "static uint32_t vmport_cmd_ram_size ( void * opaque , uint32_t addr ) {\n CPUX86State * env = cpu_single_env ;\n env -> regs [ R_EBX ] = 0x1177 ;\n return ram_size ;\n }", "idx": 22488}
{"hash": 2064081176034684128, "project": "debian", "size": 34, "label": 0, "functionSource": "static int matroska_parse_seekhead_entry ( MatroskaDemuxContext * matroska , int idx ) {\n EbmlList * seekhead_list = & matroska -> seekhead ;\n uint32_t level_up = matroska -> level_up ;\n uint32_t saved_id = matroska -> current_id ;\n MatroskaSeekhead * seekhead = seekhead_list -> elem ;\n int64_t before_pos = avio_tell ( matroska -> ctx -> pb ) ;\n MatroskaLevel level ;\n int64_t offset ;\n int ret = 0 ;\n if ( idx >= seekhead_list -> nb_elem || seekhead [ idx ] . id == MATROSKA_ID_SEEKHEAD || seekhead [ idx ] . id == MATROSKA_ID_CLUSTER ) return 0 ;\n offset = seekhead [ idx ] . pos + matroska -> segment_start ;\n if ( avio_seek ( matroska -> ctx -> pb , offset , SEEK_SET ) == offset ) {\n if ( matroska -> num_levels == EBML_MAX_DEPTH ) {\n av_log ( matroska -> ctx , AV_LOG_INFO , \"Max EBML element depth (%d) reached, \" \"cannot parse further.\\n\" , EBML_MAX_DEPTH ) ;\n ret = AVERROR_INVALIDDATA ;\n }\n else {\n level . start = 0 ;\n level . length = ( uint64_t ) - 1 ;\n matroska -> levels [ matroska -> num_levels ] = level ;\n matroska -> num_levels ++ ;\n matroska -> current_id = 0 ;\n ret = ebml_parse ( matroska , matroska_segment , matroska ) ;\n while ( matroska -> num_levels ) {\n uint64_t length = matroska -> levels [ -- matroska -> num_levels ] . length ;\n if ( length == ( uint64_t ) - 1 ) break ;\n }\n }\n }\n avio_seek ( matroska -> ctx -> pb , before_pos , SEEK_SET ) ;\n matroska -> level_up = level_up ;\n matroska -> current_id = saved_id ;\n return ret ;\n }", "idx": 22489}
{"hash": -5385892304146930196, "project": "debian", "size": 22, "label": 0, "functionSource": "static int asf_write_trailer ( AVFormatContext * s ) {\n ASFContext * asf = s -> priv_data ;\n int64_t file_size , data_size ;\n int ret ;\n if ( asf -> pb . buf_ptr > asf -> pb . buffer ) flush_packet ( s ) ;\n data_size = avio_tell ( s -> pb ) ;\n if ( ! asf -> is_streamed && asf -> next_start_sec ) {\n if ( ( ret = update_index ( s , asf -> end_sec + 1 , 0 , 0 , 0 ) ) < 0 ) return ret ;\n asf_write_index ( s , asf -> index_ptr , asf -> maximum_packet , asf -> next_start_sec ) ;\n }\n avio_flush ( s -> pb ) ;\n if ( asf -> is_streamed || ! s -> pb -> seekable ) {\n put_chunk ( s , 0x4524 , 0 , 0 ) ;\n }\n else {\n file_size = avio_tell ( s -> pb ) ;\n avio_seek ( s -> pb , 0 , SEEK_SET ) ;\n asf_write_header1 ( s , file_size , data_size - asf -> data_offset ) ;\n }\n av_freep ( & asf -> index_ptr ) ;\n return 0 ;\n }", "idx": 22490}
{"hash": -3384986069176965684, "project": "chrome", "size": 16, "label": 0, "functionSource": "void vp8_new_framerate ( VP8_COMP * cpi , double framerate ) {\n if ( framerate < .1 ) framerate = 30 ;\n cpi -> framerate = framerate ;\n cpi -> output_framerate = framerate ;\n cpi -> per_frame_bandwidth = ( int ) ( cpi -> oxcf . target_bandwidth / cpi -> output_framerate ) ;\n cpi -> av_per_frame_bandwidth = cpi -> per_frame_bandwidth ;\n cpi -> min_frame_bandwidth = ( int ) ( cpi -> av_per_frame_bandwidth * cpi -> oxcf . two_pass_vbrmin_section / 100 ) ;\n cpi -> max_gf_interval = ( ( int ) ( cpi -> output_framerate / 2.0 ) + 2 ) ;\n if ( cpi -> max_gf_interval < 12 ) cpi -> max_gf_interval = 12 ;\n cpi -> twopass . static_scene_max_gf_interval = cpi -> key_frame_frequency >> 1 ;\n if ( cpi -> oxcf . play_alternate && cpi -> oxcf . lag_in_frames ) {\n if ( cpi -> max_gf_interval > cpi -> oxcf . lag_in_frames - 1 ) cpi -> max_gf_interval = cpi -> oxcf . lag_in_frames - 1 ;\n if ( cpi -> twopass . static_scene_max_gf_interval > cpi -> oxcf . lag_in_frames - 1 ) cpi -> twopass . static_scene_max_gf_interval = cpi -> oxcf . lag_in_frames - 1 ;\n }\n if ( cpi -> max_gf_interval > cpi -> twopass . static_scene_max_gf_interval ) cpi -> max_gf_interval = cpi -> twopass . static_scene_max_gf_interval ;\n }", "idx": 22491}
{"hash": -2648356651055439484, "project": "debian", "size": 8, "label": 0, "functionSource": "guint16 de_cn_common_gsm_map_nas_sys_info ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo , guint32 offset , guint len , gchar * add_string _U_ , int string_len _U_ ) {\n guint32 curr_offset ;\n curr_offset = offset ;\n proto_tree_add_item ( tree , hf_gsm_a_lac , tvb , curr_offset , 2 , ENC_BIG_ENDIAN ) ;\n curr_offset += 2 ;\n EXTRANEOUS_DATA_CHECK ( len , curr_offset - offset , pinfo , & ei_gsm_a_extraneous_data ) ;\n return ( curr_offset - offset ) ;\n }", "idx": 22492}
{"hash": -16551315108292821, "project": "debian", "size": 56, "label": 0, "functionSource": "gcry_sexp_t gcry_sexp_find_token ( const gcry_sexp_t list , const char * tok , size_t toklen ) {\n const byte * p ;\n DATALEN n ;\n if ( ! list ) return NULL ;\n if ( ! toklen ) toklen = strlen ( tok ) ;\n p = list -> d ;\n while ( * p != ST_STOP ) {\n if ( * p == ST_OPEN && p [ 1 ] == ST_DATA ) {\n const byte * head = p ;\n p += 2 ;\n memcpy ( & n , p , sizeof n ) ;\n p += sizeof n ;\n if ( n == toklen && ! memcmp ( p , tok , toklen ) ) {\n gcry_sexp_t newlist ;\n byte * d ;\n int level = 1 ;\n for ( p += n ;\n level ;\n p ++ ) {\n if ( * p == ST_DATA ) {\n memcpy ( & n , ++ p , sizeof n ) ;\n p += sizeof n + n ;\n p -- ;\n }\n else if ( * p == ST_OPEN ) {\n level ++ ;\n }\n else if ( * p == ST_CLOSE ) {\n level -- ;\n }\n else if ( * p == ST_STOP ) {\n BUG ( ) ;\n }\n }\n n = p - head ;\n newlist = gcry_malloc ( sizeof * newlist + n ) ;\n if ( ! newlist ) {\n return NULL ;\n }\n d = newlist -> d ;\n memcpy ( d , head , n ) ;\n d += n ;\n * d ++ = ST_STOP ;\n return normalize ( newlist ) ;\n }\n p += n ;\n }\n else if ( * p == ST_DATA ) {\n memcpy ( & n , ++ p , sizeof n ) ;\n p += sizeof n ;\n p += n ;\n }\n else p ++ ;\n }\n return NULL ;\n }", "idx": 22493}
{"hash": 6600620671673714486, "project": "debian", "size": 8, "label": 1, "functionSource": "static byte * i_alloc_byte_array_immovable ( gs_memory_t * mem , uint num_elements , uint elt_size , client_name_t cname ) {\n gs_ref_memory_t * const imem = ( gs_ref_memory_t * ) mem ;\n obj_header_t * obj ;\n # ifdef MEMENTO if ( Memento_failThisEvent ( ) ) return NULL ;\n # endif obj = alloc_obj ( imem , ( ulong ) num_elements * elt_size , & st_bytes , ALLOC_IMMOVABLE | ALLOC_DIRECT , cname ) ;\n if_debug6m ( 'A' , mem , \"[a%d|+b.]%s -bytes-*(%lu=%u*%u) = 0x%lx\\n\" , alloc_trace_space ( imem ) , client_name_string ( cname ) , ( ulong ) num_elements * elt_size , num_elements , elt_size , ( ulong ) obj ) ;\n return ( byte * ) obj ;\n }", "idx": 22494}
{"hash": -305162769887579921, "project": "debian", "size": 23, "label": 0, "functionSource": "static void denoise_dct_c ( MpegEncContext * s , int16_t * block ) {\n const int intra = s -> mb_intra ;\n int i ;\n s -> dct_count [ intra ] ++ ;\n for ( i = 0 ;\n i < 64 ;\n i ++ ) {\n int level = block [ i ] ;\n if ( level ) {\n if ( level > 0 ) {\n s -> dct_error_sum [ intra ] [ i ] += level ;\n level -= s -> dct_offset [ intra ] [ i ] ;\n if ( level < 0 ) level = 0 ;\n }\n else {\n s -> dct_error_sum [ intra ] [ i ] -= level ;\n level += s -> dct_offset [ intra ] [ i ] ;\n if ( level > 0 ) level = 0 ;\n }\n block [ i ] = level ;\n }\n }\n }", "idx": 22495}
{"hash": 5357882892791796049, "project": "debian", "size": 4, "label": 0, "functionSource": "static void e1000e_set_ics ( E1000ECore * core , int index , uint32_t val ) {\n trace_e1000e_irq_write_ics ( val ) ;\n e1000e_set_interrupt_cause ( core , val ) ;\n }", "idx": 22496}
{"hash": -3740862514502467070, "project": "debian", "size": 22, "label": 1, "functionSource": "void DefaultTTFEnglishNames ( struct ttflangname * dummy , SplineFont * sf ) {\n time_t now ;\n struct tm * tm ;\n char buffer [ 200 ] ;\n if ( dummy -> names [ ttf_copyright ] == NULL || * dummy -> names [ ttf_copyright ] == '\\0' ) dummy -> names [ ttf_copyright ] = utf8_verify_copy ( sf -> copyright ) ;\n if ( dummy -> names [ ttf_family ] == NULL || * dummy -> names [ ttf_family ] == '\\0' ) dummy -> names [ ttf_family ] = utf8_verify_copy ( sf -> familyname ) ;\n if ( dummy -> names [ ttf_subfamily ] == NULL || * dummy -> names [ ttf_subfamily ] == '\\0' ) dummy -> names [ ttf_subfamily ] = utf8_verify_copy ( SFGetModifiers ( sf ) ) ;\n if ( dummy -> names [ ttf_uniqueid ] == NULL || * dummy -> names [ ttf_uniqueid ] == '\\0' ) {\n time ( & now ) ;\n tm = localtime ( & now ) ;\n sprintf ( buffer , \"%s : %s : %d-%d-%d\" , BDFFoundry ? BDFFoundry : TTFFoundry ? TTFFoundry : \"FontForge 2.0\" , sf -> fullname != NULL ? sf -> fullname : sf -> fontname , tm -> tm_mday , tm -> tm_mon + 1 , tm -> tm_year + 1900 ) ;\n dummy -> names [ ttf_uniqueid ] = copy ( buffer ) ;\n }\n if ( dummy -> names [ ttf_fullname ] == NULL || * dummy -> names [ ttf_fullname ] == '\\0' ) dummy -> names [ ttf_fullname ] = utf8_verify_copy ( sf -> fullname ) ;\n if ( dummy -> names [ ttf_version ] == NULL || * dummy -> names [ ttf_version ] == '\\0' ) {\n if ( sf -> subfontcnt != 0 ) sprintf ( buffer , \"Version %f \" , ( double ) sf -> cidversion ) ;\n else if ( sf -> version != NULL ) sprintf ( buffer , \"Version %.20s \" , sf -> version ) ;\n else strcpy ( buffer , \"Version 1.0\" ) ;\n dummy -> names [ ttf_version ] = copy ( buffer ) ;\n }\n if ( dummy -> names [ ttf_postscriptname ] == NULL || * dummy -> names [ ttf_postscriptname ] == '\\0' ) dummy -> names [ ttf_postscriptname ] = utf8_verify_copy ( sf -> fontname ) ;\n }", "idx": 22497}
{"hash": -7855974557509681261, "project": "debian", "size": 3, "label": 0, "functionSource": "bool type_is_rowtype ( Oid typid ) {\n return ( typid == RECORDOID || get_typtype ( typid ) == TYPTYPE_COMPOSITE ) ;\n }", "idx": 22498}
{"hash": -1338403456839869183, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_q931_tpkt ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , void * data _U_ ) {\n dissect_q931_tpkt_heur ( tvb , pinfo , tree , NULL ) ;\n return tvb_captured_length ( tvb ) ;\n }", "idx": 22499}
{"hash": 8193534372312945122, "project": "debian", "size": 53, "label": 0, "functionSource": "static void pcnet_rdte_poll ( PCNetState * s ) {\n s -> csr [ 28 ] = s -> csr [ 29 ] = 0 ;\n if ( s -> rdra ) {\n int bad = 0 ;\n # if 1 hwaddr crda = pcnet_rdra_addr ( s , CSR_RCVRC ( s ) ) ;\n hwaddr nrda = pcnet_rdra_addr ( s , - 1 + CSR_RCVRC ( s ) ) ;\n hwaddr nnrd = pcnet_rdra_addr ( s , - 2 + CSR_RCVRC ( s ) ) ;\n # else hwaddr crda = s -> rdra + ( CSR_RCVRL ( s ) - CSR_RCVRC ( s ) ) * ( BCR_SWSTYLE ( s ) ? 16 : 8 ) ;\n int nrdc = CSR_RCVRC ( s ) <= 1 ? CSR_RCVRL ( s ) : CSR_RCVRC ( s ) - 1 ;\n hwaddr nrda = s -> rdra + ( CSR_RCVRL ( s ) - nrdc ) * ( BCR_SWSTYLE ( s ) ? 16 : 8 ) ;\n int nnrc = nrdc <= 1 ? CSR_RCVRL ( s ) : nrdc - 1 ;\n hwaddr nnrd = s -> rdra + ( CSR_RCVRL ( s ) - nnrc ) * ( BCR_SWSTYLE ( s ) ? 16 : 8 ) ;\n # endif CHECK_RMD ( crda , bad ) ;\n if ( ! bad ) {\n CHECK_RMD ( nrda , bad ) ;\n if ( bad || ( nrda == crda ) ) nrda = 0 ;\n CHECK_RMD ( nnrd , bad ) ;\n if ( bad || ( nnrd == crda ) ) nnrd = 0 ;\n s -> csr [ 28 ] = crda & 0xffff ;\n s -> csr [ 29 ] = crda >> 16 ;\n s -> csr [ 26 ] = nrda & 0xffff ;\n s -> csr [ 27 ] = nrda >> 16 ;\n s -> csr [ 36 ] = nnrd & 0xffff ;\n s -> csr [ 37 ] = nnrd >> 16 ;\n # ifdef PCNET_DEBUG if ( bad ) {\n printf ( \"pcnet: BAD RMD RECORDS AFTER 0x\" TARGET_FMT_plx \"\\n\" , crda ) ;\n }\n }\n else {\n printf ( \"pcnet: BAD RMD RDA=0x\" TARGET_FMT_plx \"\\n\" , crda ) ;\n # endif }\n }\n if ( CSR_CRDA ( s ) ) {\n struct pcnet_RMD rmd ;\n RMDLOAD ( & rmd , PHYSADDR ( s , CSR_CRDA ( s ) ) ) ;\n CSR_CRBC ( s ) = GET_FIELD ( rmd . buf_length , RMDL , BCNT ) ;\n CSR_CRST ( s ) = rmd . status ;\n # ifdef PCNET_DEBUG_RMD_X printf ( \"CRDA=0x%08x CRST=0x%04x RCVRC=%d RMDL=0x%04x RMDS=0x%04x RMDM=0x%08x\\n\" , PHYSADDR ( s , CSR_CRDA ( s ) ) , CSR_CRST ( s ) , CSR_RCVRC ( s ) , rmd . buf_length , rmd . status , rmd . msg_length ) ;\n PRINT_RMD ( & rmd ) ;\n # endif }\n else {\n CSR_CRBC ( s ) = CSR_CRST ( s ) = 0 ;\n }\n if ( CSR_NRDA ( s ) ) {\n struct pcnet_RMD rmd ;\n RMDLOAD ( & rmd , PHYSADDR ( s , CSR_NRDA ( s ) ) ) ;\n CSR_NRBC ( s ) = GET_FIELD ( rmd . buf_length , RMDL , BCNT ) ;\n CSR_NRST ( s ) = rmd . status ;\n }\n else {\n CSR_NRBC ( s ) = CSR_NRST ( s ) = 0 ;\n }\n }", "idx": 22500}
{"hash": -6126432314261451839, "project": "debian", "size": 24, "label": 0, "functionSource": "const gx_device * gs_getdefaultlibdevice ( gs_memory_t * mem ) {\n const gx_device * const * list ;\n int count = gs_lib_device_list ( & list , NULL ) ;\n const char * name , * end , * fin ;\n int i ;\n if ( mem && mem -> gs_lib_ctx && mem -> gs_lib_ctx -> default_device_list ) {\n name = mem -> gs_lib_ctx -> default_device_list ;\n fin = name + strlen ( name ) ;\n }\n else {\n name = gs_dev_defaults ;\n fin = name + strlen ( name ) ;\n }\n while ( name < fin ) {\n while ( ( name < fin ) && ( * name == ' ' || * name == '\\t' ) ) name ++ ;\n end = name ;\n while ( ( end < fin ) && ( * end != ' ' ) && ( * end != '\\t' ) ) end ++ ;\n for ( i = 0 ;\n i < count ;\n i ++ ) if ( ( end - name ) == strlen ( list [ i ] -> dname ) ) if ( ! memcmp ( name , list [ i ] -> dname , end - name ) ) return gs_getdevice ( i ) ;\n name = end ;\n }\n return gs_getdevice ( 0 ) ;\n }", "idx": 22501}
{"hash": -1483849844579170895, "project": "chrome", "size": 11, "label": 0, "functionSource": "static void close_output_file ( struct stream_state * stream , unsigned int fourcc ) {\n const struct vpx_codec_enc_cfg * const cfg = & stream -> config . cfg ;\n if ( cfg -> g_pass == VPX_RC_FIRST_PASS ) return ;\n # if CONFIG_WEBM_IO if ( stream -> config . write_webm ) {\n write_webm_file_footer ( & stream -> ebml ) ;\n }\n # endif if ( ! stream -> config . write_webm ) {\n if ( ! fseek ( stream -> file , 0 , SEEK_SET ) ) ivf_write_file_header ( stream -> file , & stream -> config . cfg , fourcc , stream -> frames_out ) ;\n }\n fclose ( stream -> file ) ;\n }", "idx": 22502}
{"hash": 2125998987781803371, "project": "debian", "size": 6, "label": 0, "functionSource": "static void CloseDecoder ( vlc_object_t * p_this ) {\n decoder_t * p_dec = ( decoder_t * ) p_this ;\n decoder_sys_t * p_sys = p_dec -> p_sys ;\n schro_decoder_free ( p_sys -> p_schro ) ;\n free ( p_sys ) ;\n }", "idx": 22503}
{"hash": -7795592811940874822, "project": "debian", "size": 29, "label": 0, "functionSource": "static gpg_err_code_t octet_string_from_mpi ( unsigned char * * r_frame , void * space , gcry_mpi_t value , size_t nbytes ) {\n gpg_err_code_t rc ;\n size_t nframe , noff , n ;\n unsigned char * frame ;\n if ( ! r_frame == ! space ) return GPG_ERR_INV_ARG ;\n if ( r_frame ) * r_frame = NULL ;\n rc = gcry_err_code ( gcry_mpi_print ( GCRYMPI_FMT_USG , NULL , 0 , & nframe , value ) ) ;\n if ( rc ) return rc ;\n if ( nframe > nbytes ) return GPG_ERR_TOO_LARGE ;\n noff = ( nframe < nbytes ) ? nbytes - nframe : 0 ;\n n = nframe + noff ;\n if ( space ) frame = space ;\n else {\n frame = mpi_is_secure ( value ) ? gcry_malloc_secure ( n ) : gcry_malloc ( n ) ;\n if ( ! frame ) {\n rc = gpg_err_code_from_syserror ( ) ;\n return rc ;\n }\n }\n if ( noff ) memset ( frame , 0 , noff ) ;\n nframe += noff ;\n rc = gcry_err_code ( gcry_mpi_print ( GCRYMPI_FMT_USG , frame + noff , nframe - noff , NULL , value ) ) ;\n if ( rc ) {\n gcry_free ( frame ) ;\n return rc ;\n }\n if ( r_frame ) * r_frame = frame ;\n return 0 ;\n }", "idx": 22504}
{"hash": 7424930167238097621, "project": "debian", "size": 12, "label": 0, "functionSource": "static int proc_reapurb ( struct usb_dev_state * ps , void __user * arg ) {\n struct async * as = reap_as ( ps ) ;\n if ( as ) {\n int retval ;\n snoop ( & ps -> dev -> dev , \"reap %p\\n\" , as -> userurb ) ;\n retval = processcompl ( as , ( void __user * __user * ) arg ) ;\n free_async ( as ) ;\n return retval ;\n }\n if ( signal_pending ( current ) ) return - EINTR ;\n return - ENODEV ;\n }", "idx": 22505}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_SEQUENCE_SIZE_1_256_OF_ModeDescription ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_constrained_sequence_of ( tvb , offset , actx , tree , hf_index , ett_h245_SEQUENCE_SIZE_1_256_OF_ModeDescription , SEQUENCE_SIZE_1_256_OF_ModeDescription_sequence_of , 1 , 256 , FALSE ) ;\n return offset ;\n }", "idx": 22506}
{"hash": -5706788925640467782, "project": "chrome", "size": 13, "label": 1, "functionSource": "static void nonrd_pick_sb_modes ( VP9_COMP * cpi , const TileInfo * const tile , int mi_row , int mi_col , int * rate , int64_t * dist , BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx ) {\n VP9_COMMON * const cm = & cpi -> common ;\n MACROBLOCK * const x = & cpi -> mb ;\n MACROBLOCKD * const xd = & x -> e_mbd ;\n MB_MODE_INFO * mbmi ;\n set_offsets ( cpi , tile , mi_row , mi_col , bsize ) ;\n mbmi = & xd -> mi [ 0 ] -> mbmi ;\n mbmi -> sb_type = bsize ;\n if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ && cm -> seg . enabled ) if ( mbmi -> segment_id && x -> in_static_area ) x -> rdmult = vp9_cyclic_refresh_get_rdmult ( cpi -> cyclic_refresh ) ;\n if ( vp9_segfeature_active ( & cm -> seg , mbmi -> segment_id , SEG_LVL_SKIP ) ) set_mode_info_seg_skip ( x , cm -> tx_mode , rate , dist , bsize ) ;\n else vp9_pick_inter_mode ( cpi , x , tile , mi_row , mi_col , rate , dist , bsize , ctx ) ;\n duplicate_mode_info_in_sb ( cm , xd , mi_row , mi_col , bsize ) ;\n }", "idx": 22507}
{"hash": -8178805850432684665, "project": "debian", "size": 48, "label": 0, "functionSource": "static guint16 dissect_mpa_fpdu ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , mpa_state_t * state , struct tcpinfo * tcpinfo , guint8 endpoint ) {\n proto_item * mpa_item = NULL ;\n proto_item * mpa_header_item = NULL ;\n proto_tree * mpa_tree = NULL ;\n proto_tree * mpa_header_tree = NULL ;\n guint8 pad_length ;\n guint16 ulpdu_length , exp_ulpdu_length ;\n guint32 offset , total_length ;\n guint32 num_of_m = 0 ;\n if ( state -> minfo [ endpoint ] . valid && get_first_marker_offset ( state , tcpinfo , endpoint ) == 0 ) {\n offset = MPA_MARKER_LEN ;\n }\n else {\n offset = 0 ;\n }\n ulpdu_length = ( guint16 ) tvb_get_ntohs ( tvb , offset ) ;\n if ( state -> minfo [ endpoint ] . valid ) {\n num_of_m = number_of_markers ( state , tcpinfo , endpoint ) ;\n }\n pad_length = fpdu_pad_length ( ulpdu_length ) ;\n exp_ulpdu_length = expected_ulpdu_length ( state , tcpinfo , endpoint ) ;\n if ( ! exp_ulpdu_length || exp_ulpdu_length != ( ulpdu_length + pad_length ) ) {\n return 0 ;\n }\n mpa_packetlist ( pinfo , MPA_FPDU ) ;\n mpa_item = proto_tree_add_item ( tree , proto_iwarp_mpa , tvb , 0 , - 1 , ENC_NA ) ;\n mpa_tree = proto_item_add_subtree ( mpa_item , ett_mpa ) ;\n mpa_header_item = proto_tree_add_item ( mpa_tree , hf_mpa_fpdu , tvb , offset , - 1 , ENC_NA ) ;\n mpa_header_tree = proto_item_add_subtree ( mpa_header_item , ett_mpa ) ;\n proto_tree_add_uint ( mpa_header_tree , hf_mpa_ulpdu_length , tvb , offset , MPA_ULPDU_LENGTH_LEN , ulpdu_length ) ;\n if ( state -> minfo [ endpoint ] . valid && num_of_m > 0 ) {\n total_length = fpdu_total_length ( tcpinfo ) ;\n if ( pad_length > 0 ) {\n proto_tree_add_item ( mpa_header_tree , hf_mpa_pad , tvb , pad_offset ( tcpinfo , total_length , pad_length ) , pad_length , ENC_NA ) ;\n }\n dissect_fpdu_crc ( tvb , mpa_header_tree , state , total_length - MPA_CRC_LEN , num_of_m * MPA_MARKER_LEN + ulpdu_length + pad_length + MPA_ULPDU_LENGTH_LEN ) ;\n dissect_fpdu_markers ( tvb , mpa_tree , state , tcpinfo , endpoint ) ;\n }\n else {\n offset += MPA_ULPDU_LENGTH_LEN + ulpdu_length ;\n if ( pad_length > 0 ) {\n proto_tree_add_item ( mpa_header_tree , hf_mpa_pad , tvb , offset , pad_length , ENC_NA ) ;\n offset += pad_length ;\n }\n dissect_fpdu_crc ( tvb , mpa_header_tree , state , offset , ulpdu_length + pad_length + MPA_ULPDU_LENGTH_LEN ) ;\n }\n return ulpdu_length ;\n }", "idx": 22508}
{"hash": 1182028467273264883, "project": "debian", "size": 5, "label": 0, "functionSource": "void set_current_connection ( struct st_connection * con ) {\n cur_con = con ;\n var_set_int ( \"$mysql_get_server_version\" , mysql_get_server_version ( con -> mysql ) ) ;\n var_set_string ( \"$CURRENT_CONNECTION\" , con -> name ) ;\n }", "idx": 22509}
{"hash": -8638406710431929037, "project": "debian", "size": 14, "label": 0, "functionSource": "static bfd_boolean srec_get_section_contents ( bfd * abfd , asection * section , void * location , file_ptr offset , bfd_size_type count ) {\n if ( count == 0 ) return TRUE ;\n if ( offset + count < count || offset + count > section -> size ) {\n bfd_set_error ( bfd_error_invalid_operation ) ;\n return FALSE ;\n }\n if ( section -> used_by_bfd == NULL ) {\n section -> used_by_bfd = bfd_alloc ( abfd , section -> size ) ;\n if ( section -> used_by_bfd == NULL ) return FALSE ;\n if ( ! srec_read_section ( abfd , section , ( bfd_byte * ) section -> used_by_bfd ) ) return FALSE ;\n }\n memcpy ( location , ( bfd_byte * ) section -> used_by_bfd + offset , ( size_t ) count ) ;\n return TRUE ;\n }", "idx": 22510}
{"hash": 9176142195250515812, "project": "debian", "size": 14, "label": 0, "functionSource": "static void purple_ui_init ( ) {\n purple_connections_set_ui_ops ( & bee_conn_uiops ) ;\n purple_blist_set_ui_ops ( & bee_blist_uiops ) ;\n purple_conversations_set_ui_ops ( & bee_conv_uiops ) ;\n purple_request_set_ui_ops ( & bee_request_uiops ) ;\n purple_privacy_set_ui_ops ( & bee_privacy_uiops ) ;\n purple_roomlist_set_ui_ops ( & bee_roomlist_uiops ) ;\n purple_notify_set_ui_ops ( & bee_notify_uiops ) ;\n purple_accounts_set_ui_ops ( & bee_account_uiops ) ;\n purple_xfers_set_ui_ops ( & bee_xfer_uiops ) ;\n if ( getenv ( \"BITLBEE_DEBUG\" ) ) {\n purple_debug_set_ui_ops ( & bee_debug_uiops ) ;\n }\n }", "idx": 22511}
{"hash": 1415862279747793542, "project": "chrome", "size": 30, "label": 0, "functionSource": "static void * linux_udev_event_thread_main ( void * arg ) {\n char dummy ;\n int r ;\n struct udev_device * udev_dev ;\n struct pollfd fds [ ] = {\n {\n . fd = udev_control_pipe [ 0 ] , . events = POLLIN }\n , {\n . fd = udev_monitor_fd , . events = POLLIN }\n , }\n ;\n usbi_dbg ( \"udev event thread entering.\" ) ;\n while ( poll ( fds , 2 , - 1 ) >= 0 ) {\n if ( fds [ 0 ] . revents & POLLIN ) {\n r = usbi_read ( udev_control_pipe [ 0 ] , & dummy , sizeof ( dummy ) ) ;\n if ( r <= 0 ) {\n usbi_warn ( NULL , \"udev control pipe read failed\" ) ;\n }\n break ;\n }\n if ( fds [ 1 ] . revents & POLLIN ) {\n usbi_mutex_static_lock ( & linux_hotplug_lock ) ;\n udev_dev = device : : udev_monitor_receive_device ( udev_monitor ) ;\n if ( udev_dev ) udev_hotplug_event ( udev_dev ) ;\n usbi_mutex_static_unlock ( & linux_hotplug_lock ) ;\n }\n }\n usbi_dbg ( \"udev event thread exiting\" ) ;\n return NULL ;\n }", "idx": 22512}
{"hash": 8572106347813672436, "project": "debian", "size": 3, "label": 0, "functionSource": "static int pfkey_send_migrate ( const struct xfrm_selector * sel , u8 dir , u8 type , const struct xfrm_migrate * m , int num_bundles , const struct xfrm_kmaddress * k ) {\n return - ENOPROTOOPT ;\n }", "idx": 22513}
{"hash": -1968566663266802355, "project": "chrome", "size": 40, "label": 0, "functionSource": "TEST_F ( OmniboxViewViewsTest , Emphasis ) {\n constexpr struct {\n const char * input ;\n bool expected_base_text_emphasized ;\n Range expected_emphasis_range ;\n Range expected_scheme_range ;\n }\n test_cases [ ] = {\n {\n \"data:text/html,Hello%20World\" , false , Range ( 0 , 4 ) , Range ( 0 , 4 ) }\n , {\n \"http://www.example.com/path/file.htm\" , false , Range ( 7 , 22 ) , Range ( 0 , 4 ) }\n , {\n \"https://www.example.com/path/file.htm\" , false , Range ( 8 , 23 ) , Range ( 0 , 5 ) }\n , {\n \"chrome-extension://ldfbacdbackkjhclmhnjabngnppnkagl\" , false , Range : : InvalidRange ( ) , Range ( 0 , 16 ) }\n , {\n \"nosuchscheme://opaque/string\" , true , Range : : InvalidRange ( ) , Range ( 0 , 12 ) }\n , {\n \"nosuchscheme:opaquestring\" , true , Range : : InvalidRange ( ) , Range ( 0 , 12 ) }\n , {\n \"host.com/path/file\" , false , Range ( 0 , 8 ) , Range : : InvalidRange ( ) }\n , {\n \"This is plain text\" , true , Range : : InvalidRange ( ) , Range : : InvalidRange ( ) }\n , }\n ;\n for ( const auto & test_case : test_cases ) {\n SCOPED_TRACE ( test_case . input ) ;\n SetAndEmphasizeText ( test_case . input , false ) ;\n EXPECT_EQ ( TestingOmniboxView : : to_base_text_emphasis ( test_case . expected_base_text_emphasized ) , omnibox_view ( ) -> base_text_emphasis ( ) ) ;\n EXPECT_EQ ( test_case . expected_emphasis_range , omnibox_view ( ) -> emphasis_range ( ) ) ;\n EXPECT_FALSE ( omnibox_view ( ) -> scheme_range ( ) . IsValid ( ) ) ;\n if ( test_case . expected_scheme_range . IsValid ( ) ) {\n SetAndEmphasizeText ( test_case . input , true ) ;\n EXPECT_EQ ( TestingOmniboxView : : to_base_text_emphasis ( test_case . expected_base_text_emphasized ) , omnibox_view ( ) -> base_text_emphasis ( ) ) ;\n EXPECT_EQ ( test_case . expected_emphasis_range , omnibox_view ( ) -> emphasis_range ( ) ) ;\n EXPECT_EQ ( test_case . expected_scheme_range , omnibox_view ( ) -> scheme_range ( ) ) ;\n }\n }\n }", "idx": 22514}
{"hash": -6090091127667448005, "project": "debian", "size": 3, "label": 0, "functionSource": "static inline unsigned int ip_hdrlen ( const struct sk_buff * skb ) {\n return ip_hdr ( skb ) -> ihl * 4 ;\n }", "idx": 22515}
{"hash": -1929262071302712016, "project": "debian", "size": 38, "label": 0, "functionSource": "static cmsBool Type_vcgt_Write ( struct _cms_typehandler_struct * self , cmsIOHANDLER * io , void * Ptr , cmsUInt32Number nItems ) {\n cmsToneCurve * * Curves = ( cmsToneCurve * * ) Ptr ;\n cmsUInt32Number i , j ;\n if ( cmsGetToneCurveParametricType ( Curves [ 0 ] ) == 5 && cmsGetToneCurveParametricType ( Curves [ 1 ] ) == 5 && cmsGetToneCurveParametricType ( Curves [ 2 ] ) == 5 ) {\n if ( ! _cmsWriteUInt32Number ( io , cmsVideoCardGammaFormulaType ) ) return FALSE ;\n for ( i = 0 ;\n i < 3 ;\n i ++ ) {\n _cmsVCGTGAMMA v ;\n v . Gamma = Curves [ i ] -> Segments [ 0 ] . Params [ 0 ] ;\n v . Min = Curves [ i ] -> Segments [ 0 ] . Params [ 5 ] ;\n v . Max = pow ( Curves [ i ] -> Segments [ 0 ] . Params [ 1 ] , v . Gamma ) + v . Min ;\n if ( ! _cmsWrite15Fixed16Number ( io , v . Gamma ) ) return FALSE ;\n if ( ! _cmsWrite15Fixed16Number ( io , v . Min ) ) return FALSE ;\n if ( ! _cmsWrite15Fixed16Number ( io , v . Max ) ) return FALSE ;\n }\n }\n else {\n if ( ! _cmsWriteUInt32Number ( io , cmsVideoCardGammaTableType ) ) return FALSE ;\n if ( ! _cmsWriteUInt16Number ( io , 3 ) ) return FALSE ;\n if ( ! _cmsWriteUInt16Number ( io , 256 ) ) return FALSE ;\n if ( ! _cmsWriteUInt16Number ( io , 2 ) ) return FALSE ;\n for ( i = 0 ;\n i < 3 ;\n i ++ ) {\n for ( j = 0 ;\n j < 256 ;\n j ++ ) {\n cmsFloat32Number v = cmsEvalToneCurveFloat ( Curves [ i ] , ( cmsFloat32Number ) ( j / 255.0 ) ) ;\n cmsUInt16Number n = _cmsQuickSaturateWord ( v * 65535.0 ) ;\n if ( ! _cmsWriteUInt16Number ( io , n ) ) return FALSE ;\n }\n }\n }\n return TRUE ;\n cmsUNUSED_PARAMETER ( self ) ;\n cmsUNUSED_PARAMETER ( nItems ) ;\n }", "idx": 22516}
{"hash": -3889154245145551951, "project": "debian", "size": 4, "label": 0, "functionSource": "static void parse_checkpoint ( void ) {\n checkpoint_requested = 1 ;\n skip_optional_lf ( ) ;\n }", "idx": 22517}
{"hash": -1968566663266802355, "project": "chrome", "size": 7, "label": 1, "functionSource": "TEST_F ( OmniboxViewViewsTest , ScheduledTextEditCommand ) {\n omnibox_textfield ( ) -> SetTextEditCommandForNextKeyEvent ( ui : : TextEditCommand : : MOVE_UP ) ;\n EXPECT_EQ ( ui : : TextEditCommand : : MOVE_UP , scheduled_text_edit_command ( ) ) ;\n ui : : KeyEvent up_pressed ( ui : : ET_KEY_PRESSED , ui : : VKEY_UP , 0 ) ;\n omnibox_textfield ( ) -> OnKeyEvent ( & up_pressed ) ;\n EXPECT_EQ ( ui : : TextEditCommand : : INVALID_COMMAND , scheduled_text_edit_command ( ) ) ;\n }", "idx": 22518}
{"hash": 6120640898537304364, "project": "debian", "size": 4, "label": 0, "functionSource": "void pdf_tos_translate ( pdf_text_object_state * tos , float tx , float ty ) {\n fz_pre_translate ( & tos -> tlm , tx , ty ) ;\n tos -> tm = tos -> tlm ;\n }", "idx": 22519}
{"hash": 8572106347813672436, "project": "debian", "size": 10, "label": 0, "functionSource": "static inline int event2poltype ( int event ) {\n switch ( event ) {\n case XFRM_MSG_DELPOLICY : return SADB_X_SPDDELETE ;\n case XFRM_MSG_NEWPOLICY : return SADB_X_SPDADD ;\n case XFRM_MSG_UPDPOLICY : return SADB_X_SPDUPDATE ;\n case XFRM_MSG_POLEXPIRE : default : pr_err ( \"pfkey: Unknown policy event %d\\n\" , event ) ;\n break ;\n }\n return 0 ;\n }", "idx": 22520}
{"hash": 6287901954906207197, "project": "chrome", "size": 3, "label": 0, "functionSource": "static void TestValidOriginIdentifier ( bool expected_result , const std : : string & id ) {\n EXPECT_EQ ( expected_result , DatabaseUtil : : IsValidOriginIdentifier ( id ) ) ;\n }", "idx": 22521}
{"hash": -1315695702746584250, "project": "debian", "size": 28, "label": 0, "functionSource": "static gint32 get_int_value ( proto_tree * tree , tvbuff_t * tvb , gint offset , gint length , const guint encoding ) {\n gint32 value ;\n gboolean length_error ;\n switch ( length ) {\n case 1 : value = ( gint8 ) tvb_get_guint8 ( tvb , offset ) ;\n break ;\n case 2 : value = ( gint16 ) ( encoding ? tvb_get_letohs ( tvb , offset ) : tvb_get_ntohs ( tvb , offset ) ) ;\n break ;\n case 3 : value = encoding ? tvb_get_letoh24 ( tvb , offset ) : tvb_get_ntoh24 ( tvb , offset ) ;\n if ( value & 0x00800000 ) {\n value |= 0xFF000000 ;\n }\n break ;\n case 4 : value = encoding ? tvb_get_letohl ( tvb , offset ) : tvb_get_ntohl ( tvb , offset ) ;\n break ;\n default : if ( length < 1 ) {\n length_error = TRUE ;\n value = 0 ;\n }\n else {\n length_error = FALSE ;\n value = encoding ? tvb_get_letohl ( tvb , offset ) : tvb_get_ntohl ( tvb , offset ) ;\n }\n report_type_length_mismatch ( tree , \"a signed integer\" , length , length_error ) ;\n break ;\n }\n return value ;\n }", "idx": 22522}
{"hash": 7092216800726729686, "project": "debian", "size": 6, "label": 0, "functionSource": "static int dissect_h245_DataModeApplication ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 523 \"../../asn1/h245/h245.cnf\" gint32 value ;\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_DataModeApplication , DataModeApplication_choice , & value ) ;\n codec_type = val_to_str ( value , h245_DataModeApplication_vals , \"<unknown>\" ) ;\n return offset ;\n }", "idx": 22523}
{"hash": 1743019814289113128, "project": "debian", "size": 8, "label": 0, "functionSource": "void ff_h264_pred_direct_motion ( H264Context * const h , int * mb_type ) {\n if ( h -> direct_spatial_mv_pred ) {\n pred_spatial_direct_motion ( h , mb_type ) ;\n }\n else {\n pred_temp_direct_motion ( h , mb_type ) ;\n }\n }", "idx": 22524}
{"hash": -8958254313220732728, "project": "debian", "size": 41, "label": 0, "functionSource": "static void virtio_ioport_write ( void * opaque , uint32_t addr , uint32_t val ) {\n VirtIOPCIProxy * proxy = opaque ;\n VirtIODevice * vdev = proxy -> vdev ;\n target_phys_addr_t pa ;\n switch ( addr ) {\n case VIRTIO_PCI_GUEST_FEATURES : if ( val & ( 1 << VIRTIO_F_BAD_FEATURE ) ) {\n if ( vdev -> bad_features ) val = proxy -> host_features & vdev -> bad_features ( vdev ) ;\n else val = 0 ;\n }\n if ( vdev -> set_features ) vdev -> set_features ( vdev , val ) ;\n vdev -> guest_features = val ;\n break ;\n case VIRTIO_PCI_QUEUE_PFN : pa = ( target_phys_addr_t ) val << VIRTIO_PCI_QUEUE_ADDR_SHIFT ;\n if ( pa == 0 ) {\n virtio_reset ( proxy -> vdev ) ;\n msix_unuse_all_vectors ( & proxy -> pci_dev ) ;\n }\n else virtio_queue_set_addr ( vdev , vdev -> queue_sel , pa ) ;\n break ;\n case VIRTIO_PCI_QUEUE_SEL : if ( val < VIRTIO_PCI_QUEUE_MAX ) vdev -> queue_sel = val ;\n break ;\n case VIRTIO_PCI_QUEUE_NOTIFY : virtio_queue_notify ( vdev , val ) ;\n break ;\n case VIRTIO_PCI_STATUS : vdev -> status = val & 0xFF ;\n if ( vdev -> status == 0 ) {\n virtio_reset ( proxy -> vdev ) ;\n msix_unuse_all_vectors ( & proxy -> pci_dev ) ;\n }\n break ;\n case VIRTIO_MSI_CONFIG_VECTOR : msix_vector_unuse ( & proxy -> pci_dev , vdev -> config_vector ) ;\n if ( msix_vector_use ( & proxy -> pci_dev , val ) < 0 ) val = VIRTIO_NO_VECTOR ;\n vdev -> config_vector = val ;\n break ;\n case VIRTIO_MSI_QUEUE_VECTOR : msix_vector_unuse ( & proxy -> pci_dev , virtio_queue_vector ( vdev , vdev -> queue_sel ) ) ;\n if ( msix_vector_use ( & proxy -> pci_dev , val ) < 0 ) val = VIRTIO_NO_VECTOR ;\n virtio_queue_set_vector ( vdev , vdev -> queue_sel , val ) ;\n break ;\n default : fprintf ( stderr , \"%s: unexpected address 0x%x value 0x%x\\n\" , __func__ , addr , val ) ;\n break ;\n }\n }", "idx": 22525}
{"hash": 6600620671673714486, "project": "debian", "size": 67, "label": 0, "functionSource": "static void splay_move_to_root ( clump_t * x , gs_ref_memory_t * mem ) {\n clump_t * y , * z ;\n if ( x == NULL ) return ;\n while ( ( y = x -> parent ) != NULL ) {\n if ( ( z = y -> parent ) != NULL ) {\n x -> parent = z -> parent ;\n if ( x -> parent ) {\n if ( x -> parent -> left == z ) x -> parent -> left = x ;\n else x -> parent -> right = x ;\n }\n y -> parent = x ;\n if ( y -> left == x ) {\n if ( z -> left == y ) {\n y -> left = x -> right ;\n if ( y -> left ) y -> left -> parent = y ;\n z -> left = y -> right ;\n if ( z -> left ) z -> left -> parent = z ;\n y -> right = z ;\n z -> parent = y ;\n }\n else {\n z -> right = x -> left ;\n if ( z -> right ) z -> right -> parent = z ;\n y -> left = x -> right ;\n if ( y -> left ) y -> left -> parent = y ;\n x -> left = z ;\n z -> parent = x ;\n }\n x -> right = y ;\n }\n else {\n if ( z -> left == y ) {\n y -> right = x -> left ;\n if ( y -> right ) y -> right -> parent = y ;\n z -> left = x -> right ;\n if ( z -> left ) z -> left -> parent = z ;\n x -> right = z ;\n z -> parent = x ;\n }\n else {\n z -> right = y -> left ;\n if ( z -> right ) z -> right -> parent = z ;\n y -> right = x -> left ;\n if ( y -> right ) y -> right -> parent = y ;\n y -> left = z ;\n z -> parent = y ;\n }\n x -> left = y ;\n }\n }\n else {\n x -> parent = NULL ;\n y -> parent = x ;\n if ( y -> left == x ) {\n y -> left = x -> right ;\n if ( y -> left ) y -> left -> parent = y ;\n x -> right = y ;\n }\n else {\n y -> right = x -> left ;\n if ( y -> right ) y -> right -> parent = y ;\n x -> left = y ;\n }\n }\n }\n mem -> root = x ;\n }", "idx": 22526}
{"hash": -3591633859713840564, "project": "debian", "size": 258, "label": 0, "functionSource": "static int mp_decode_layer3 ( MPADecodeContext * s ) {\n int nb_granules , main_data_begin ;\n int gr , ch , blocksplit_flag , i , j , k , n , bits_pos ;\n GranuleDef * g ;\n int16_t exponents [ 576 ] ;\n if ( s -> lsf ) {\n main_data_begin = get_bits ( & s -> gb , 8 ) ;\n skip_bits ( & s -> gb , s -> nb_channels ) ;\n nb_granules = 1 ;\n }\n else {\n main_data_begin = get_bits ( & s -> gb , 9 ) ;\n if ( s -> nb_channels == 2 ) skip_bits ( & s -> gb , 3 ) ;\n else skip_bits ( & s -> gb , 5 ) ;\n nb_granules = 2 ;\n for ( ch = 0 ;\n ch < s -> nb_channels ;\n ch ++ ) {\n s -> granules [ ch ] [ 0 ] . scfsi = 0 ;\n s -> granules [ ch ] [ 1 ] . scfsi = get_bits ( & s -> gb , 4 ) ;\n }\n }\n for ( gr = 0 ;\n gr < nb_granules ;\n gr ++ ) {\n for ( ch = 0 ;\n ch < s -> nb_channels ;\n ch ++ ) {\n av_dlog ( s -> avctx , \"gr=%d ch=%d: side_info\\n\" , gr , ch ) ;\n g = & s -> granules [ ch ] [ gr ] ;\n g -> part2_3_length = get_bits ( & s -> gb , 12 ) ;\n g -> big_values = get_bits ( & s -> gb , 9 ) ;\n if ( g -> big_values > 288 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"big_values too big\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n g -> global_gain = get_bits ( & s -> gb , 8 ) ;\n if ( ( s -> mode_ext & ( MODE_EXT_MS_STEREO | MODE_EXT_I_STEREO ) ) == MODE_EXT_MS_STEREO ) g -> global_gain -= 2 ;\n if ( s -> lsf ) g -> scalefac_compress = get_bits ( & s -> gb , 9 ) ;\n else g -> scalefac_compress = get_bits ( & s -> gb , 4 ) ;\n blocksplit_flag = get_bits1 ( & s -> gb ) ;\n if ( blocksplit_flag ) {\n g -> block_type = get_bits ( & s -> gb , 2 ) ;\n if ( g -> block_type == 0 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"invalid block type\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n g -> switch_point = get_bits1 ( & s -> gb ) ;\n for ( i = 0 ;\n i < 2 ;\n i ++ ) g -> table_select [ i ] = get_bits ( & s -> gb , 5 ) ;\n for ( i = 0 ;\n i < 3 ;\n i ++ ) g -> subblock_gain [ i ] = get_bits ( & s -> gb , 3 ) ;\n ff_init_short_region ( s , g ) ;\n }\n else {\n int region_address1 , region_address2 ;\n g -> block_type = 0 ;\n g -> switch_point = 0 ;\n for ( i = 0 ;\n i < 3 ;\n i ++ ) g -> table_select [ i ] = get_bits ( & s -> gb , 5 ) ;\n region_address1 = get_bits ( & s -> gb , 4 ) ;\n region_address2 = get_bits ( & s -> gb , 3 ) ;\n av_dlog ( s -> avctx , \"region1=%d region2=%d\\n\" , region_address1 , region_address2 ) ;\n ff_init_long_region ( s , g , region_address1 , region_address2 ) ;\n }\n ff_region_offset2size ( g ) ;\n ff_compute_band_indexes ( s , g ) ;\n g -> preflag = 0 ;\n if ( ! s -> lsf ) g -> preflag = get_bits1 ( & s -> gb ) ;\n g -> scalefac_scale = get_bits1 ( & s -> gb ) ;\n g -> count1table_select = get_bits1 ( & s -> gb ) ;\n av_dlog ( s -> avctx , \"block_type=%d switch_point=%d\\n\" , g -> block_type , g -> switch_point ) ;\n }\n }\n if ( ! s -> adu_mode ) {\n int skip ;\n const uint8_t * ptr = s -> gb . buffer + ( get_bits_count ( & s -> gb ) >> 3 ) ;\n int extrasize = av_clip ( get_bits_left ( & s -> gb ) >> 3 , 0 , FFMAX ( 0 , LAST_BUF_SIZE - s -> last_buf_size ) ) ;\n assert ( ( get_bits_count ( & s -> gb ) & 7 ) == 0 ) ;\n av_dlog ( s -> avctx , \"seekback:%d, lastbuf:%d\\n\" , main_data_begin , s -> last_buf_size ) ;\n memcpy ( s -> last_buf + s -> last_buf_size , ptr , extrasize ) ;\n s -> in_gb = s -> gb ;\n init_get_bits ( & s -> gb , s -> last_buf , s -> last_buf_size * 8 ) ;\n # if ! UNCHECKED_BITSTREAM_READER s -> gb . size_in_bits_plus8 += extrasize * 8 ;\n # endif s -> last_buf_size <<= 3 ;\n for ( gr = 0 ;\n gr < nb_granules && ( s -> last_buf_size >> 3 ) < main_data_begin ;\n gr ++ ) {\n for ( ch = 0 ;\n ch < s -> nb_channels ;\n ch ++ ) {\n g = & s -> granules [ ch ] [ gr ] ;\n s -> last_buf_size += g -> part2_3_length ;\n memset ( g -> sb_hybrid , 0 , sizeof ( g -> sb_hybrid ) ) ;\n compute_imdct ( s , g , & s -> sb_samples [ ch ] [ 18 * gr ] [ 0 ] , s -> mdct_buf [ ch ] ) ;\n }\n }\n skip = s -> last_buf_size - 8 * main_data_begin ;\n if ( skip >= s -> gb . size_in_bits && s -> in_gb . buffer ) {\n skip_bits_long ( & s -> in_gb , skip - s -> gb . size_in_bits ) ;\n s -> gb = s -> in_gb ;\n s -> in_gb . buffer = NULL ;\n }\n else {\n skip_bits_long ( & s -> gb , skip ) ;\n }\n }\n else {\n gr = 0 ;\n }\n for ( ;\n gr < nb_granules ;\n gr ++ ) {\n for ( ch = 0 ;\n ch < s -> nb_channels ;\n ch ++ ) {\n g = & s -> granules [ ch ] [ gr ] ;\n bits_pos = get_bits_count ( & s -> gb ) ;\n if ( ! s -> lsf ) {\n uint8_t * sc ;\n int slen , slen1 , slen2 ;\n slen1 = slen_table [ 0 ] [ g -> scalefac_compress ] ;\n slen2 = slen_table [ 1 ] [ g -> scalefac_compress ] ;\n av_dlog ( s -> avctx , \"slen1=%d slen2=%d\\n\" , slen1 , slen2 ) ;\n if ( g -> block_type == 2 ) {\n n = g -> switch_point ? 17 : 18 ;\n j = 0 ;\n if ( slen1 ) {\n for ( i = 0 ;\n i < n ;\n i ++ ) g -> scale_factors [ j ++ ] = get_bits ( & s -> gb , slen1 ) ;\n }\n else {\n for ( i = 0 ;\n i < n ;\n i ++ ) g -> scale_factors [ j ++ ] = 0 ;\n }\n if ( slen2 ) {\n for ( i = 0 ;\n i < 18 ;\n i ++ ) g -> scale_factors [ j ++ ] = get_bits ( & s -> gb , slen2 ) ;\n for ( i = 0 ;\n i < 3 ;\n i ++ ) g -> scale_factors [ j ++ ] = 0 ;\n }\n else {\n for ( i = 0 ;\n i < 21 ;\n i ++ ) g -> scale_factors [ j ++ ] = 0 ;\n }\n }\n else {\n sc = s -> granules [ ch ] [ 0 ] . scale_factors ;\n j = 0 ;\n for ( k = 0 ;\n k < 4 ;\n k ++ ) {\n n = k == 0 ? 6 : 5 ;\n if ( ( g -> scfsi & ( 0x8 >> k ) ) == 0 ) {\n slen = ( k < 2 ) ? slen1 : slen2 ;\n if ( slen ) {\n for ( i = 0 ;\n i < n ;\n i ++ ) g -> scale_factors [ j ++ ] = get_bits ( & s -> gb , slen ) ;\n }\n else {\n for ( i = 0 ;\n i < n ;\n i ++ ) g -> scale_factors [ j ++ ] = 0 ;\n }\n }\n else {\n for ( i = 0 ;\n i < n ;\n i ++ ) {\n g -> scale_factors [ j ] = sc [ j ] ;\n j ++ ;\n }\n }\n }\n g -> scale_factors [ j ++ ] = 0 ;\n }\n }\n else {\n int tindex , tindex2 , slen [ 4 ] , sl , sf ;\n if ( g -> block_type == 2 ) tindex = g -> switch_point ? 2 : 1 ;\n else tindex = 0 ;\n sf = g -> scalefac_compress ;\n if ( ( s -> mode_ext & MODE_EXT_I_STEREO ) && ch == 1 ) {\n sf >>= 1 ;\n if ( sf < 180 ) {\n lsf_sf_expand ( slen , sf , 6 , 6 , 0 ) ;\n tindex2 = 3 ;\n }\n else if ( sf < 244 ) {\n lsf_sf_expand ( slen , sf - 180 , 4 , 4 , 0 ) ;\n tindex2 = 4 ;\n }\n else {\n lsf_sf_expand ( slen , sf - 244 , 3 , 0 , 0 ) ;\n tindex2 = 5 ;\n }\n }\n else {\n if ( sf < 400 ) {\n lsf_sf_expand ( slen , sf , 5 , 4 , 4 ) ;\n tindex2 = 0 ;\n }\n else if ( sf < 500 ) {\n lsf_sf_expand ( slen , sf - 400 , 5 , 4 , 0 ) ;\n tindex2 = 1 ;\n }\n else {\n lsf_sf_expand ( slen , sf - 500 , 3 , 0 , 0 ) ;\n tindex2 = 2 ;\n g -> preflag = 1 ;\n }\n }\n j = 0 ;\n for ( k = 0 ;\n k < 4 ;\n k ++ ) {\n n = lsf_nsf_table [ tindex2 ] [ tindex ] [ k ] ;\n sl = slen [ k ] ;\n if ( sl ) {\n for ( i = 0 ;\n i < n ;\n i ++ ) g -> scale_factors [ j ++ ] = get_bits ( & s -> gb , sl ) ;\n }\n else {\n for ( i = 0 ;\n i < n ;\n i ++ ) g -> scale_factors [ j ++ ] = 0 ;\n }\n }\n for ( ;\n j < 40 ;\n j ++ ) g -> scale_factors [ j ] = 0 ;\n }\n exponents_from_scale_factors ( s , g , exponents ) ;\n huffman_decode ( s , g , exponents , bits_pos + g -> part2_3_length ) ;\n }\n if ( s -> mode == MPA_JSTEREO ) compute_stereo ( s , & s -> granules [ 0 ] [ gr ] , & s -> granules [ 1 ] [ gr ] ) ;\n for ( ch = 0 ;\n ch < s -> nb_channels ;\n ch ++ ) {\n g = & s -> granules [ ch ] [ gr ] ;\n reorder_block ( s , g ) ;\n compute_antialias ( s , g ) ;\n compute_imdct ( s , g , & s -> sb_samples [ ch ] [ 18 * gr ] [ 0 ] , s -> mdct_buf [ ch ] ) ;\n }\n }\n if ( get_bits_count ( & s -> gb ) < 0 ) skip_bits_long ( & s -> gb , - get_bits_count ( & s -> gb ) ) ;\n return nb_granules * 18 ;\n }", "idx": 22527}
{"hash": 2895622461494525400, "project": "debian", "size": 65, "label": 0, "functionSource": "static void test_buffers ( ) {\n MYSQL_STMT * stmt ;\n MYSQL_BIND my_bind [ 2 ] ;\n int rc ;\n ulong length ;\n my_bool is_null ;\n char buffer [ 20 ] ;\n myheader ( \"test_buffers\" ) ;\n rc = mysql_query ( mysql , \"DROP TABLE IF EXISTS test_buffer\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"CREATE TABLE test_buffer(str varchar(20))\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"insert into test_buffer values('MySQL')\\ , ('Database'), ('Open-Source'), ('Popular')\" ) ;\n myquery ( rc ) ;\n stmt = mysql_simple_prepare ( mysql , \"select str from test_buffer\" ) ;\n check_stmt ( stmt ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n memset ( buffer , 0 , sizeof ( buffer ) ) ;\n memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n my_bind [ 0 ] . length = & length ;\n my_bind [ 0 ] . is_null = & is_null ;\n my_bind [ 0 ] . buffer_length = 1 ;\n my_bind [ 0 ] . buffer_type = MYSQL_TYPE_STRING ;\n my_bind [ 0 ] . buffer = ( void * ) buffer ;\n my_bind [ 0 ] . error = & my_bind [ 0 ] . error_value ;\n rc = mysql_stmt_bind_result ( stmt , my_bind ) ;\n check_execute ( stmt , rc ) ;\n rc = mysql_stmt_store_result ( stmt ) ;\n check_execute ( stmt , rc ) ;\n buffer [ 1 ] = 'X' ;\n rc = mysql_stmt_fetch ( stmt ) ;\n DIE_UNLESS ( rc == MYSQL_DATA_TRUNCATED ) ;\n DIE_UNLESS ( my_bind [ 0 ] . error_value ) ;\n if ( ! opt_silent ) fprintf ( stdout , \"\\n data: %s (%lu)\" , buffer , length ) ;\n DIE_UNLESS ( buffer [ 0 ] == 'M' ) ;\n DIE_UNLESS ( buffer [ 1 ] == 'X' ) ;\n DIE_UNLESS ( length == 5 ) ;\n my_bind [ 0 ] . buffer_length = 8 ;\n rc = mysql_stmt_bind_result ( stmt , my_bind ) ;\n check_execute ( stmt , rc ) ;\n rc = mysql_stmt_fetch ( stmt ) ;\n check_execute ( stmt , rc ) ;\n if ( ! opt_silent ) fprintf ( stdout , \"\\n data: %s (%lu)\" , buffer , length ) ;\n DIE_UNLESS ( strncmp ( buffer , \"Database\" , 8 ) == 0 ) ;\n DIE_UNLESS ( length == 8 ) ;\n my_bind [ 0 ] . buffer_length = 12 ;\n rc = mysql_stmt_bind_result ( stmt , my_bind ) ;\n check_execute ( stmt , rc ) ;\n rc = mysql_stmt_fetch ( stmt ) ;\n check_execute ( stmt , rc ) ;\n if ( ! opt_silent ) fprintf ( stdout , \"\\n data: %s (%lu)\" , buffer , length ) ;\n DIE_UNLESS ( strcmp ( buffer , \"Open-Source\" ) == 0 ) ;\n DIE_UNLESS ( length == 11 ) ;\n my_bind [ 0 ] . buffer_length = 6 ;\n rc = mysql_stmt_bind_result ( stmt , my_bind ) ;\n check_execute ( stmt , rc ) ;\n rc = mysql_stmt_fetch ( stmt ) ;\n DIE_UNLESS ( rc == MYSQL_DATA_TRUNCATED ) ;\n DIE_UNLESS ( my_bind [ 0 ] . error_value ) ;\n if ( ! opt_silent ) fprintf ( stdout , \"\\n data: %s (%lu)\" , buffer , length ) ;\n DIE_UNLESS ( strncmp ( buffer , \"Popula\" , 6 ) == 0 ) ;\n DIE_UNLESS ( length == 7 ) ;\n mysql_stmt_close ( stmt ) ;\n }", "idx": 22528}
{"hash": 7847057953677889923, "project": "debian", "size": 76, "label": 0, "functionSource": "static int user_key_command_allowed2 ( struct ssh * ssh , struct passwd * user_pw , struct sshkey * key , struct sshauthopt * * authoptsp ) {\n struct passwd * runas_pw = NULL ;\n FILE * f = NULL ;\n int r , ok , found_key = 0 ;\n int i , uid_swapped = 0 , ac = 0 ;\n pid_t pid ;\n char * username = NULL , * key_fp = NULL , * keytext = NULL ;\n char uidstr [ 32 ] , * tmp , * command = NULL , * * av = NULL ;\n void ( * osigchld ) ( int ) ;\n if ( authoptsp != NULL ) * authoptsp = NULL ;\n if ( options . authorized_keys_command == NULL ) return 0 ;\n if ( options . authorized_keys_command_user == NULL ) {\n error ( \"No user for AuthorizedKeysCommand specified, skipping\" ) ;\n return 0 ;\n }\n osigchld = signal ( SIGCHLD , SIG_DFL ) ;\n username = percent_expand ( options . authorized_keys_command_user , \"u\" , user_pw -> pw_name , ( char * ) NULL ) ;\n runas_pw = getpwnam ( username ) ;\n if ( runas_pw == NULL ) {\n error ( \"AuthorizedKeysCommandUser \\\"%s\\\" not found: %s\" , username , strerror ( errno ) ) ;\n goto out ;\n }\n if ( ( key_fp = sshkey_fingerprint ( key , options . fingerprint_hash , SSH_FP_DEFAULT ) ) == NULL ) {\n error ( \"%s: sshkey_fingerprint failed\" , __func__ ) ;\n goto out ;\n }\n if ( ( r = sshkey_to_base64 ( key , & keytext ) ) != 0 ) {\n error ( \"%s: sshkey_to_base64 failed: %s\" , __func__ , ssh_err ( r ) ) ;\n goto out ;\n }\n if ( argv_split ( options . authorized_keys_command , & ac , & av ) != 0 ) {\n error ( \"AuthorizedKeysCommand \\\"%s\\\" contains invalid quotes\" , command ) ;\n goto out ;\n }\n if ( ac == 0 ) {\n error ( \"AuthorizedKeysCommand \\\"%s\\\" yielded no arguments\" , command ) ;\n goto out ;\n }\n snprintf ( uidstr , sizeof ( uidstr ) , \"%llu\" , ( unsigned long long ) user_pw -> pw_uid ) ;\n for ( i = 1 ;\n i < ac ;\n i ++ ) {\n tmp = percent_expand ( av [ i ] , \"U\" , uidstr , \"u\" , user_pw -> pw_name , \"h\" , user_pw -> pw_dir , \"t\" , sshkey_ssh_name ( key ) , \"f\" , key_fp , \"k\" , keytext , ( char * ) NULL ) ;\n if ( tmp == NULL ) fatal ( \"%s: percent_expand failed\" , __func__ ) ;\n free ( av [ i ] ) ;\n av [ i ] = tmp ;\n }\n command = argv_assemble ( ac , av ) ;\n if ( ac == 1 ) {\n av = xreallocarray ( av , ac + 2 , sizeof ( * av ) ) ;\n av [ 1 ] = xstrdup ( user_pw -> pw_name ) ;\n av [ 2 ] = NULL ;\n free ( command ) ;\n xasprintf ( & command , \"%s %s\" , av [ 0 ] , av [ 1 ] ) ;\n }\n if ( ( pid = subprocess ( \"AuthorizedKeysCommand\" , runas_pw , command , ac , av , & f , SSH_SUBPROCESS_STDOUT_CAPTURE | SSH_SUBPROCESS_STDERR_DISCARD ) ) == 0 ) goto out ;\n uid_swapped = 1 ;\n temporarily_use_uid ( runas_pw ) ;\n ok = check_authkeys_file ( ssh , user_pw , f , options . authorized_keys_command , key , authoptsp ) ;\n fclose ( f ) ;\n f = NULL ;\n if ( exited_cleanly ( pid , \"AuthorizedKeysCommand\" , command , 0 ) != 0 ) goto out ;\n found_key = ok ;\n out : if ( f != NULL ) fclose ( f ) ;\n signal ( SIGCHLD , osigchld ) ;\n for ( i = 0 ;\n i < ac ;\n i ++ ) free ( av [ i ] ) ;\n free ( av ) ;\n if ( uid_swapped ) restore_uid ( ) ;\n free ( command ) ;\n free ( username ) ;\n free ( key_fp ) ;\n free ( keytext ) ;\n return found_key ;\n }", "idx": 22529}
{"hash": -5390559971540708342, "project": "debian", "size": 27, "label": 0, "functionSource": "static int x8_get_dc_rlf ( IntraX8Context * const w , int const mode , int * const level , int * const final ) {\n MpegEncContext * const s = w -> s ;\n int i , e , c ;\n assert ( mode < 3 ) ;\n if ( ! w -> j_dc_vlc [ mode ] ) {\n int table_index ;\n table_index = get_bits ( & s -> gb , 3 ) ;\n w -> j_dc_vlc [ mode ] = & j_dc_vlc [ w -> quant < 13 ] [ table_index ] ;\n }\n assert ( w -> j_dc_vlc ) ;\n assert ( w -> j_dc_vlc [ mode ] -> table ) ;\n i = get_vlc2 ( & s -> gb , w -> j_dc_vlc [ mode ] -> table , DC_VLC_BITS , DC_VLC_MTD ) ;\n c = i > 16 ;\n ( * final ) = c ;\n i -= 17 * c ;\n if ( i <= 0 ) {\n ( * level ) = 0 ;\n return - i ;\n }\n c = ( i + 1 ) >> 1 ;\n c -= c > 1 ;\n e = get_bits ( & s -> gb , c ) ;\n i = dc_index_offset [ i ] + ( e >> 1 ) ;\n e = - ( e & 1 ) ;\n ( * level ) = ( i ^ e ) - e ;\n return 0 ;\n }", "idx": 22530}
{"hash": 3309252579593081468, "project": "debian", "size": 19, "label": 0, "functionSource": "static void nntp_parse_xref ( struct Context * ctx , struct Header * hdr ) {\n struct NntpData * nntp_data = ctx -> data ;\n char * buf = mutt_str_strdup ( hdr -> env -> xref ) ;\n char * p = buf ;\n while ( p ) {\n anum_t anum ;\n p += strspn ( p , \" \\t\" ) ;\n char * grp = p ;\n p = strpbrk ( p , \" \\t\" ) ;\n if ( p ) * p ++ = '\\0' ;\n char * colon = strchr ( grp , ':' ) ;\n if ( ! colon ) continue ;\n * colon ++ = '\\0' ;\n if ( sscanf ( colon , ANUM , & anum ) != 1 ) continue ;\n nntp_article_status ( ctx , hdr , grp , anum ) ;\n if ( ! NHDR ( hdr ) -> article_num && ( mutt_str_strcmp ( nntp_data -> group , grp ) == 0 ) ) NHDR ( hdr ) -> article_num = anum ;\n }\n FREE ( & buf ) ;\n }", "idx": 22531}
{"hash": 2687336064028423153, "project": "chrome", "size": 11, "label": 0, "functionSource": "static void evdns_request_insert ( struct request * req , struct request * * head ) {\n if ( ! * head ) {\n * head = req ;\n req -> next = req -> prev = req ;\n return ;\n }\n req -> prev = ( * head ) -> prev ;\n req -> prev -> next = req ;\n req -> next = * head ;\n ( * head ) -> prev = req ;\n }", "idx": 22532}
{"hash": 8445816931248660591, "project": "debian", "size": 7, "label": 0, "functionSource": "SPL_METHOD ( SplDoublyLinkedList , next ) {\n spl_dllist_object * intern = ( spl_dllist_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n if ( zend_parse_parameters_none ( ) == FAILURE ) {\n return ;\n }\n spl_dllist_it_helper_move_forward ( & intern -> traverse_pointer , & intern -> traverse_position , intern -> llist , intern -> flags TSRMLS_CC ) ;\n }", "idx": 22533}
{"hash": 6805657479815417135, "project": "chrome", "size": 11, "label": 0, "functionSource": "static char * allocString ( uint32_t length ) {\n uint32_t top = stringTop + length ;\n char * p ;\n if ( top > STRING_STORE_SIZE ) {\n fprintf ( stderr , \"gencmn: out of memory\\n\" ) ;\n exit ( U_MEMORY_ALLOCATION_ERROR ) ;\n }\n p = stringStore + stringTop ;\n stringTop = top ;\n return p ;\n }", "idx": 22534}
{"hash": -2908211205972632000, "project": "debian", "size": 36, "label": 0, "functionSource": "void mainwindows_init ( void ) {\n screen_width = term_width ;\n screen_height = term_height ;\n mainwindows = NULL ;\n active_mainwin = NULL ;\n clrtoeol_info = g_new0 ( MAIN_WINDOW_BORDER_REC , 1 ) ;\n screen_reserved_top = screen_reserved_bottom = 0 ;\n screen_reserved_left = screen_reserved_right = 0 ;\n command_bind ( \"window grow\" , NULL , ( SIGNAL_FUNC ) cmd_window_grow ) ;\n command_bind ( \"window shrink\" , NULL , ( SIGNAL_FUNC ) cmd_window_shrink ) ;\n command_bind ( \"window size\" , NULL , ( SIGNAL_FUNC ) cmd_window_size ) ;\n command_bind ( \"window balance\" , NULL , ( SIGNAL_FUNC ) cmd_window_balance ) ;\n command_bind ( \"window hide\" , NULL , ( SIGNAL_FUNC ) cmd_window_hide ) ;\n command_bind ( \"window show\" , NULL , ( SIGNAL_FUNC ) cmd_window_show ) ;\n command_bind ( \"window up\" , NULL , ( SIGNAL_FUNC ) cmd_window_up ) ;\n command_bind ( \"window down\" , NULL , ( SIGNAL_FUNC ) cmd_window_down ) ;\n command_bind ( \"window left\" , NULL , ( SIGNAL_FUNC ) cmd_window_left ) ;\n command_bind ( \"window right\" , NULL , ( SIGNAL_FUNC ) cmd_window_right ) ;\n command_bind ( \"window dup\" , NULL , ( SIGNAL_FUNC ) cmd_window_dup ) ;\n command_bind ( \"window ddown\" , NULL , ( SIGNAL_FUNC ) cmd_window_ddown ) ;\n command_bind ( \"window dleft\" , NULL , ( SIGNAL_FUNC ) cmd_window_dleft ) ;\n command_bind ( \"window dright\" , NULL , ( SIGNAL_FUNC ) cmd_window_dright ) ;\n command_bind ( \"window stick\" , NULL , ( SIGNAL_FUNC ) cmd_window_stick ) ;\n command_bind ( \"window move left\" , NULL , ( SIGNAL_FUNC ) cmd_window_move_left ) ;\n command_bind ( \"window move right\" , NULL , ( SIGNAL_FUNC ) cmd_window_move_right ) ;\n command_bind ( \"window move up\" , NULL , ( SIGNAL_FUNC ) cmd_window_move_up ) ;\n command_bind ( \"window move down\" , NULL , ( SIGNAL_FUNC ) cmd_window_move_down ) ;\n command_bind ( \"window move dleft\" , NULL , ( SIGNAL_FUNC ) cmd_window_move_dleft ) ;\n command_bind ( \"window move dright\" , NULL , ( SIGNAL_FUNC ) cmd_window_move_dright ) ;\n command_bind ( \"window rgrow\" , NULL , ( SIGNAL_FUNC ) cmd_window_rgrow ) ;\n command_bind ( \"window rshrink\" , NULL , ( SIGNAL_FUNC ) cmd_window_rshrink ) ;\n command_bind ( \"window rsize\" , NULL , ( SIGNAL_FUNC ) cmd_window_rsize ) ;\n command_bind ( \"window rbalance\" , NULL , ( SIGNAL_FUNC ) cmd_window_rbalance ) ;\n command_bind ( \"window rshow\" , NULL , ( SIGNAL_FUNC ) cmd_window_rshow ) ;\n signal_add ( \"window print info\" , ( SIGNAL_FUNC ) sig_window_print_info ) ;\n }", "idx": 22535}
{"hash": 4313735399044135249, "project": "debian", "size": 8, "label": 0, "functionSource": "static void psf_log_syserr ( SF_PRIVATE * psf , int error ) {\n if ( psf -> error == 0 ) {\n psf -> error = SFE_SYSTEM ;\n snprintf ( psf -> syserr , sizeof ( psf -> syserr ) , \"System error : %s.\" , strerror ( error ) ) ;\n }\n ;\n return ;\n }", "idx": 22536}
{"hash": -8178805850432684665, "project": "debian", "size": 17, "label": 0, "functionSource": "static void dissect_fpdu_crc ( tvbuff_t * tvb , proto_tree * tree , mpa_state_t * state , guint32 offset , guint32 length ) {\n guint32 crc = 0 ;\n guint32 sent_crc = 0 ;\n if ( state -> crc ) {\n crc = ~ crc32c_tvb_offset_calculate ( tvb , 0 , length , CRC32C_PRELOAD ) ;\n sent_crc = tvb_get_ntohl ( tvb , offset ) ;\n if ( crc == sent_crc ) {\n proto_tree_add_uint_format_value ( tree , hf_mpa_crc_check , tvb , offset , MPA_CRC_LEN , sent_crc , \"0x%08x (Good CRC32)\" , sent_crc ) ;\n }\n else {\n proto_tree_add_uint_format_value ( tree , hf_mpa_crc_check , tvb , offset , MPA_CRC_LEN , sent_crc , \"0x%08x (Bad CRC32, should be 0x%08x)\" , sent_crc , crc ) ;\n }\n }\n else {\n proto_tree_add_item ( tree , hf_mpa_crc , tvb , offset , MPA_CRC_LEN , ENC_BIG_ENDIAN ) ;\n }\n }", "idx": 22537}
{"hash": -5615323818347734353, "project": "debian", "size": 9, "label": 0, "functionSource": "static void wait_for_signal_thread_to_end ( ) {\n uint i ;\n for ( i = 0 ;\n i < 100 && signal_thread_in_use ;\n i ++ ) {\n if ( pthread_kill ( signal_thread , MYSQL_KILL_SIGNAL ) == ESRCH ) break ;\n my_sleep ( 100 ) ;\n }\n }", "idx": 22538}
{"hash": -866921002076081979, "project": "debian", "size": 28, "label": 0, "functionSource": "EXCLUSIVE_REGRESSION_TEST ( SDK_API_HttpTxnCache ) ( RegressionTest * test , int , int * pstatus ) {\n * pstatus = REGRESSION_TEST_INPROGRESS ;\n TSCont cont = TSContCreate ( cache_hook_handler , TSMutexCreate ( ) ) ;\n if ( cont == nullptr ) {\n SDK_RPRINT ( test , \"TSHttpSsn\" , \"TestCase1\" , TC_FAIL , \"Unable to create Continuation.\" ) ;\n * pstatus = REGRESSION_TEST_FAILED ;\n return ;\n }\n CacheTestData * socktest = ( CacheTestData * ) TSmalloc ( sizeof ( CacheTestData ) ) ;\n socktest -> test = test ;\n socktest -> pstatus = pstatus ;\n socktest -> test_passed_txn_cached_req_get = false ;\n socktest -> test_passed_txn_cached_resp_get = false ;\n socktest -> first_time = true ;\n socktest -> magic = MAGIC_ALIVE ;\n TSContDataSet ( cont , socktest ) ;\n TSHttpHookAdd ( TS_HTTP_READ_REQUEST_HDR_HOOK , cont ) ;\n TSHttpHookAdd ( TS_HTTP_READ_CACHE_HDR_HOOK , cont ) ;\n TSHttpHookAdd ( TS_HTTP_CACHE_LOOKUP_COMPLETE_HOOK , cont ) ;\n socktest -> os = synserver_create ( SYNSERVER_LISTEN_PORT ) ;\n synserver_start ( socktest -> os ) ;\n socktest -> browser1 = synclient_txn_create ( ) ;\n socktest -> browser2 = synclient_txn_create ( ) ;\n socktest -> request = generate_request ( 2 ) ;\n synclient_txn_send_request ( socktest -> browser1 , socktest -> request ) ;\n TSContSchedule ( cont , 25 , TS_THREAD_POOL_DEFAULT ) ;\n return ;\n }", "idx": 22539}
{"hash": 3557739556029059195, "project": "chrome", "size": 21, "label": 0, "functionSource": "unsigned int vp9_sad ## m ## x ## n ## _c ( const uint8_t * src , int src_stride , const uint8_t * ref , int ref_stride ) {\n return sad ( src , src_stride , ref , ref_stride , m , n ) ;\n \\ }\n unsigned int vp9_sad ## m ## x ## n ## _avg_c ( const uint8_t * src , int src_stride , const uint8_t * ref , int ref_stride , const uint8_t * second_pred ) {\n uint8_t comp_pred [ m * n ] ;\n vp9_comp_avg_pred ( comp_pred , second_pred , m , n , ref , ref_stride ) ;\n return sad ( src , src_stride , comp_pred , m , m , n ) ;\n \\ }\n # define sadMxNxK ( m , n , k ) void vp9_sad ## m ## x ## n ## x ## k ## _c ( const uint8_t * src , int src_stride , const uint8_t * ref , int ref_stride , unsigned int * sads ) {\n int i ;\n for ( i = 0 ;\n i < k ;\n ++ i ) sads [ i ] = vp9_sad ## m ## x ## n ## _c ( src , src_stride , & ref [ i ] , ref_stride ) ;\n \\ }\n # define sadMxNx4D ( m , n ) void vp9_sad ## m ## x ## n ## x4d_c ( const uint8_t * src , int src_stride , const uint8_t * const refs [ ] , int ref_stride , unsigned int * sads ) {\n int i ;\n for ( i = 0 ;\n i < 4 ;\n ++ i ) sads [ i ] = vp9_sad ## m ## x ## n ## _c ( src , src_stride , refs [ i ] , ref_stride ) ;\n \\ }\n sadMxN ( 64 , 64 ) sadMxNxK ( 64 , 64 , 3 ) sadMxNxK ( 64 , 64 , 8 ) sadMxNx4D ( 64 , 64 ) sadMxN ( 64 , 32 ) sadMxNx4D ( 64 , 32 ) sadMxN ( 32 , 64 ) sadMxNx4D ( 32 , 64 ) sadMxN ( 32 , 32 ) sadMxNxK ( 32 , 32 , 3 ) sadMxNxK ( 32 , 32 , 8 ) sadMxNx4D ( 32 , 32 ) sadMxN ( 32 , 16 ) sadMxNx4D ( 32 , 16 ) sadMxN ( 16 , 32 ) sadMxNx4D ( 16 , 32 ) sadMxN ( 16 , 16 ) sadMxNxK ( 16 , 16 , 3 ) sadMxNxK ( 16 , 16 , 8 ) sadMxNx4D ( 16 , 16 ) sadMxN ( 16 , 8 ) sadMxNxK ( 16 , 8 , 3 ) sadMxNxK ( 16 , 8 , 8 ) sadMxNx4D ( 16 , 8 ) sadMxN ( 8 , 16 ) sadMxNxK ( 8 , 16 , 3 ) sadMxNxK ( 8 , 16 , 8 ) sadMxNx4D ( 8 , 16 ) sadMxN ( 8 , 8 ) sadMxNxK ( 8 , 8 , 3 ) sadMxNxK ( 8 , 8 , 8 ) sadMxNx4D ( 8 , 8 ) sadMxN ( 8 , 4 ) sadMxNxK ( 8 , 4 , 8 ) sadMxNx4D ( 8 , 4 ) sadMxN ( 4 , 8 ) sadMxNxK ( 4 , 8 , 8 ) sadMxNx4D ( 4 , 8 ) sadMxN ( 4 , 4 )", "idx": 22540}
{"hash": -7455544248455991006, "project": "debian", "size": 3, "label": 0, "functionSource": "static bool hyperv_hypercall_available ( X86CPU * cpu ) {\n return cpu -> hyperv_vapic || ( cpu -> hyperv_spinlock_attempts != HYPERV_SPINLOCK_NEVER_RETRY ) ;\n }", "idx": 22541}
{"hash": -5262394088289559608, "project": "debian", "size": 9, "label": 0, "functionSource": "static void arm_mptimer_reset ( DeviceState * dev ) {\n ARMMPTimerState * s = FROM_SYSBUS ( ARMMPTimerState , SYS_BUS_DEVICE ( dev ) ) ;\n int i ;\n for ( i = 0 ;\n i < ARRAY_SIZE ( s -> timerblock ) ;\n i ++ ) {\n timerblock_reset ( & s -> timerblock [ i ] ) ;\n }\n }", "idx": 22542}
{"hash": -2222463888415249941, "project": "chrome", "size": 155, "label": 1, "functionSource": "static void encode_frame_to_data_rate ( VP9_COMP * cpi , size_t * size , uint8_t * dest , unsigned int * frame_flags ) {\n VP9_COMMON * const cm = & cpi -> common ;\n const VP9EncoderConfig * const oxcf = & cpi -> oxcf ;\n struct segmentation * const seg = & cm -> seg ;\n TX_SIZE t ;\n int q ;\n int top_index ;\n int bottom_index ;\n set_ext_overrides ( cpi ) ;\n cpi -> Source = vp9_scale_if_required ( cm , cpi -> un_scaled_source , & cpi -> scaled_source ) ;\n if ( cpi -> unscaled_last_source != NULL ) cpi -> Last_Source = vp9_scale_if_required ( cm , cpi -> unscaled_last_source , & cpi -> scaled_last_source ) ;\n vp9_scale_references ( cpi ) ;\n vp9_clear_system_state ( ) ;\n cpi -> zbin_mode_boost = 0 ;\n cpi -> zbin_mode_boost_enabled = 0 ;\n set_arf_sign_bias ( cpi ) ;\n cm -> lf . mode_ref_delta_update = 0 ;\n set_mv_search_params ( cpi ) ;\n if ( cpi -> oxcf . pass == 2 && cpi -> sf . adaptive_interp_filter_search ) cpi -> sf . interp_filter_search_mask = setup_interp_filter_search_mask ( cpi ) ;\n if ( frame_is_intra_only ( cm ) ) {\n vp9_reset_segment_features ( & cm -> seg ) ;\n if ( seg -> enabled ) {\n seg -> update_map = 1 ;\n seg -> update_data = 1 ;\n }\n cpi -> rc . source_alt_ref_active = 0 ;\n cm -> error_resilient_mode = oxcf -> error_resilient_mode ;\n if ( cm -> error_resilient_mode ) {\n cm -> frame_parallel_decoding_mode = 1 ;\n cm -> reset_frame_context = 0 ;\n cm -> refresh_frame_context = 0 ;\n }\n else if ( cm -> intra_only ) {\n cm -> frame_parallel_decoding_mode = oxcf -> frame_parallel_decoding_mode ;\n cm -> reset_frame_context = 2 ;\n }\n }\n if ( is_two_pass_svc ( cpi ) && cm -> error_resilient_mode == 0 ) {\n cm -> frame_context_idx = cpi -> svc . spatial_layer_id * cpi -> svc . number_temporal_layers + cpi -> svc . temporal_layer_id ;\n if ( cpi -> svc . number_temporal_layers == 1 ) {\n if ( cpi -> svc . spatial_layer_id == 0 && cpi -> svc . layer_context [ 0 ] . last_frame_type == KEY_FRAME ) cm -> frame_parallel_decoding_mode = 1 ;\n else cm -> frame_parallel_decoding_mode = 0 ;\n }\n else if ( cpi -> svc . spatial_layer_id == 0 ) {\n int i ;\n for ( i = 0 ;\n i < cpi -> svc . number_temporal_layers ;\n ++ i ) {\n if ( cpi -> svc . layer_context [ 0 ] . frames_from_key_frame == 1 << i ) {\n cm -> frame_parallel_decoding_mode = 1 ;\n break ;\n }\n }\n if ( i == cpi -> svc . number_temporal_layers ) cm -> frame_parallel_decoding_mode = 0 ;\n }\n }\n if ( oxcf -> pass == 2 && cpi -> sf . static_segmentation ) configure_static_seg_features ( cpi ) ;\n if ( oxcf -> pass == 2 && ( ! cpi -> use_svc || is_two_pass_svc ( cpi ) ) ) {\n cpi -> skippable_frame = is_skippable_frame ( cpi ) ;\n }\n if ( oxcf -> pass == 0 && oxcf -> rc_mode == VPX_CBR && cm -> frame_type != KEY_FRAME ) {\n if ( vp9_rc_drop_frame ( cpi ) ) {\n vp9_rc_postencode_update_drop_frame ( cpi ) ;\n ++ cm -> current_video_frame ;\n return ;\n }\n }\n vp9_clear_system_state ( ) ;\n # if CONFIG_VP9_POSTPROC if ( oxcf -> noise_sensitivity > 0 ) {\n int l = 0 ;\n switch ( oxcf -> noise_sensitivity ) {\n case 1 : l = 20 ;\n break ;\n case 2 : l = 40 ;\n break ;\n case 3 : l = 60 ;\n break ;\n case 4 : case 5 : l = 100 ;\n break ;\n case 6 : l = 150 ;\n break ;\n }\n vp9_denoise ( cpi -> Source , cpi -> Source , l ) ;\n }\n # endif # if CONFIG_INTERNAL_STATS int i ;\n for ( i = 0 ;\n i < MAX_MODES ;\n ++ i ) cpi -> mode_chosen_counts [ i ] = 0 ;\n # endif vp9_set_speed_features ( cpi ) ;\n vp9_set_rd_speed_thresholds ( cpi ) ;\n vp9_set_rd_speed_thresholds_sub8x8 ( cpi ) ;\n q = vp9_rc_pick_q_and_bounds ( cpi , & bottom_index , & top_index ) ;\n if ( ! frame_is_intra_only ( cm ) ) {\n cm -> interp_filter = cpi -> sf . default_interp_filter ;\n vp9_set_high_precision_mv ( cpi , q < HIGH_PRECISION_MV_QTHRESH ) ;\n }\n if ( cpi -> sf . recode_loop == DISALLOW_RECODE ) {\n encode_without_recode_loop ( cpi , q ) ;\n }\n else {\n encode_with_recode_loop ( cpi , size , dest , q , bottom_index , top_index ) ;\n }\n # if CONFIG_VP9_TEMPORAL_DENOISING # ifdef OUTPUT_YUV_DENOISED if ( oxcf -> noise_sensitivity > 0 ) {\n vp9_write_yuv_frame_420 ( & cpi -> denoiser . running_avg_y [ INTRA_FRAME ] , yuv_denoised_file ) ;\n }\n # endif # endif if ( cpi -> rc . next_key_frame_forced && cpi -> rc . frames_to_key == 1 ) {\n cpi -> ambient_err = vp9_get_y_sse ( cpi -> Source , get_frame_new_buffer ( cm ) ) ;\n }\n if ( cm -> frame_type == KEY_FRAME ) cpi -> refresh_last_frame = 1 ;\n cm -> frame_to_show = get_frame_new_buffer ( cm ) ;\n loopfilter_frame ( cpi , cm ) ;\n vp9_pack_bitstream ( cpi , dest , size ) ;\n if ( cm -> seg . update_map ) update_reference_segmentation_map ( cpi ) ;\n release_scaled_references ( cpi ) ;\n vp9_update_reference_frames ( cpi ) ;\n for ( t = TX_4X4 ;\n t <= TX_32X32 ;\n t ++ ) full_to_model_counts ( cm -> counts . coef [ t ] , cpi -> coef_counts [ t ] ) ;\n if ( ! cm -> error_resilient_mode && ! cm -> frame_parallel_decoding_mode ) vp9_adapt_coef_probs ( cm ) ;\n if ( ! frame_is_intra_only ( cm ) ) {\n if ( ! cm -> error_resilient_mode && ! cm -> frame_parallel_decoding_mode ) {\n vp9_adapt_mode_probs ( cm ) ;\n vp9_adapt_mv_probs ( cm , cm -> allow_high_precision_mv ) ;\n }\n }\n if ( cpi -> refresh_golden_frame == 1 ) cpi -> frame_flags |= FRAMEFLAGS_GOLDEN ;\n else cpi -> frame_flags &= ~ FRAMEFLAGS_GOLDEN ;\n if ( cpi -> refresh_alt_ref_frame == 1 ) cpi -> frame_flags |= FRAMEFLAGS_ALTREF ;\n else cpi -> frame_flags &= ~ FRAMEFLAGS_ALTREF ;\n cpi -> ref_frame_flags = get_ref_frame_flags ( cpi ) ;\n cm -> last_frame_type = cm -> frame_type ;\n vp9_rc_postencode_update ( cpi , * size ) ;\n # if 0 output_frame_level_debug_stats ( cpi ) ;\n # endif if ( cm -> frame_type == KEY_FRAME ) {\n * frame_flags = cpi -> frame_flags | FRAMEFLAGS_KEY ;\n }\n else {\n * frame_flags = cpi -> frame_flags & ~ FRAMEFLAGS_KEY ;\n }\n cm -> seg . update_map = 0 ;\n cm -> seg . update_data = 0 ;\n cm -> lf . mode_ref_delta_update = 0 ;\n cm -> last_width = cm -> width ;\n cm -> last_height = cm -> height ;\n if ( ! cm -> show_existing_frame ) {\n if ( is_two_pass_svc ( cpi ) && cm -> error_resilient_mode == 0 ) cm -> last_show_frame = 0 ;\n else cm -> last_show_frame = cm -> show_frame ;\n }\n if ( cm -> show_frame ) {\n vp9_swap_mi_and_prev_mi ( cm ) ;\n ++ cm -> current_video_frame ;\n if ( cpi -> use_svc ) vp9_inc_frame_in_layer ( cpi ) ;\n }\n if ( is_two_pass_svc ( cpi ) ) cpi -> svc . layer_context [ cpi -> svc . spatial_layer_id ] . last_frame_type = cm -> frame_type ;\n }", "idx": 22543}
{"hash": -3616725510139109047, "project": "chrome", "size": 24, "label": 0, "functionSource": "void vp9_update_mbgraph_stats ( VP9_COMP * cpi ) {\n VP9_COMMON * const cm = & cpi -> common ;\n int i , n_frames = vp9_lookahead_depth ( cpi -> lookahead ) ;\n YV12_BUFFER_CONFIG * golden_ref = get_ref_frame_buffer ( cpi , GOLDEN_FRAME ) ;\n if ( n_frames <= cpi -> rc . frames_till_gf_update_due ) return ;\n if ( n_frames > MAX_LAG_BUFFERS ) n_frames = MAX_LAG_BUFFERS ;\n cpi -> mbgraph_n_frames = n_frames ;\n for ( i = 0 ;\n i < n_frames ;\n i ++ ) {\n MBGRAPH_FRAME_STATS * frame_stats = & cpi -> mbgraph_stats [ i ] ;\n vpx_memset ( frame_stats -> mb_stats , 0 , cm -> mb_rows * cm -> mb_cols * sizeof ( * cpi -> mbgraph_stats [ i ] . mb_stats ) ) ;\n }\n for ( i = 0 ;\n i < n_frames ;\n i ++ ) {\n MBGRAPH_FRAME_STATS * frame_stats = & cpi -> mbgraph_stats [ i ] ;\n struct lookahead_entry * q_cur = vp9_lookahead_peek ( cpi -> lookahead , i ) ;\n assert ( q_cur != NULL ) ;\n update_mbgraph_frame_stats ( cpi , frame_stats , & q_cur -> img , golden_ref , cpi -> Source ) ;\n }\n vp9_clear_system_state ( ) ;\n separate_arf_mbs ( cpi ) ;\n }", "idx": 22544}
{"hash": -2423144171479606949, "project": "debian", "size": 2, "label": 0, "functionSource": "static void pdf_run_gs_end ( fz_context * ctx , pdf_processor * proc ) {\n }", "idx": 22545}
{"hash": 6336384260629386331, "project": "debian", "size": 4, "label": 0, "functionSource": "static void decode_power_conf_voltage ( gchar * s , guint32 value ) {\n g_snprintf ( s , ITEM_LABEL_LENGTH , \"%d.%d [V]\" , value / 10 , value % 10 ) ;\n return ;\n }", "idx": 22546}
{"hash": 8572106347813672436, "project": "debian", "size": 18, "label": 0, "functionSource": "static int pfkey_promisc ( struct sock * sk , struct sk_buff * skb , const struct sadb_msg * hdr , void * const * ext_hdrs ) {\n struct pfkey_sock * pfk = pfkey_sk ( sk ) ;\n int satype = hdr -> sadb_msg_satype ;\n bool reset_errno = false ;\n if ( hdr -> sadb_msg_len == ( sizeof ( * hdr ) / sizeof ( uint64_t ) ) ) {\n reset_errno = true ;\n if ( satype != 0 && satype != 1 ) return - EINVAL ;\n pfk -> promisc = satype ;\n }\n if ( reset_errno && skb_cloned ( skb ) ) skb = skb_copy ( skb , GFP_KERNEL ) ;\n else skb = skb_clone ( skb , GFP_KERNEL ) ;\n if ( reset_errno && skb ) {\n struct sadb_msg * new_hdr = ( struct sadb_msg * ) skb -> data ;\n new_hdr -> sadb_msg_errno = 0 ;\n }\n pfkey_broadcast ( skb , GFP_KERNEL , BROADCAST_ALL , NULL , sock_net ( sk ) ) ;\n return 0 ;\n }", "idx": 22547}
{"hash": -3616725510139109047, "project": "chrome", "size": 56, "label": 1, "functionSource": "static void update_mbgraph_frame_stats ( VP9_COMP * cpi , MBGRAPH_FRAME_STATS * stats , YV12_BUFFER_CONFIG * buf , YV12_BUFFER_CONFIG * golden_ref , YV12_BUFFER_CONFIG * alt_ref ) {\n MACROBLOCK * const x = & cpi -> mb ;\n MACROBLOCKD * const xd = & x -> e_mbd ;\n VP9_COMMON * const cm = & cpi -> common ;\n int mb_col , mb_row , offset = 0 ;\n int mb_y_offset = 0 , arf_y_offset = 0 , gld_y_offset = 0 ;\n MV gld_top_mv = {\n 0 , 0 }\n ;\n MODE_INFO mi_local ;\n vp9_zero ( mi_local ) ;\n x -> mv_row_min = - BORDER_MV_PIXELS_B16 ;\n x -> mv_row_max = ( cm -> mb_rows - 1 ) * 8 + BORDER_MV_PIXELS_B16 ;\n xd -> up_available = 0 ;\n xd -> plane [ 0 ] . dst . stride = buf -> y_stride ;\n xd -> plane [ 0 ] . pre [ 0 ] . stride = buf -> y_stride ;\n xd -> plane [ 1 ] . dst . stride = buf -> uv_stride ;\n xd -> mi [ 0 ] = & mi_local ;\n mi_local . mbmi . sb_type = BLOCK_16X16 ;\n mi_local . mbmi . ref_frame [ 0 ] = LAST_FRAME ;\n mi_local . mbmi . ref_frame [ 1 ] = NONE ;\n for ( mb_row = 0 ;\n mb_row < cm -> mb_rows ;\n mb_row ++ ) {\n MV gld_left_mv = gld_top_mv ;\n int mb_y_in_offset = mb_y_offset ;\n int arf_y_in_offset = arf_y_offset ;\n int gld_y_in_offset = gld_y_offset ;\n x -> mv_col_min = - BORDER_MV_PIXELS_B16 ;\n x -> mv_col_max = ( cm -> mb_cols - 1 ) * 8 + BORDER_MV_PIXELS_B16 ;\n xd -> left_available = 0 ;\n for ( mb_col = 0 ;\n mb_col < cm -> mb_cols ;\n mb_col ++ ) {\n MBGRAPH_MB_STATS * mb_stats = & stats -> mb_stats [ offset + mb_col ] ;\n update_mbgraph_mb_stats ( cpi , mb_stats , buf , mb_y_in_offset , golden_ref , & gld_left_mv , alt_ref , mb_row , mb_col ) ;\n gld_left_mv = mb_stats -> ref [ GOLDEN_FRAME ] . m . mv . as_mv ;\n if ( mb_col == 0 ) {\n gld_top_mv = gld_left_mv ;\n }\n xd -> left_available = 1 ;\n mb_y_in_offset += 16 ;\n gld_y_in_offset += 16 ;\n arf_y_in_offset += 16 ;\n x -> mv_col_min -= 16 ;\n x -> mv_col_max -= 16 ;\n }\n xd -> up_available = 1 ;\n mb_y_offset += buf -> y_stride * 16 ;\n gld_y_offset += golden_ref -> y_stride * 16 ;\n if ( alt_ref ) arf_y_offset += alt_ref -> y_stride * 16 ;\n x -> mv_row_min -= 16 ;\n x -> mv_row_max -= 16 ;\n offset += cm -> mb_cols ;\n }\n }", "idx": 22548}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_T_status ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_T_status , T_status_choice , NULL ) ;\n return offset ;\n }", "idx": 22549}
{"hash": -7670127399145950875, "project": "debian", "size": 9, "label": 0, "functionSource": "int gs_main_run_file_open ( gs_main_instance * minst , const char * file_name , ref * pfref ) {\n gs_main_set_lib_paths ( minst ) ;\n if ( gs_main_lib_open ( minst , file_name , pfref ) < 0 ) {\n emprintf1 ( minst -> heap , \"Can't find initialization file %s.\\n\" , file_name ) ;\n return_error ( gs_error_Fatal ) ;\n }\n r_set_attrs ( pfref , a_execute + a_executable ) ;\n return 0 ;\n }", "idx": 22550}
{"hash": 378220832151730865, "project": "debian", "size": 31, "label": 0, "functionSource": "int qemuMonitorTextDeleteSnapshot ( qemuMonitorPtr mon , const char * name ) {\n char * cmd = NULL ;\n char * reply = NULL ;\n int ret = - 1 ;\n char * safename ;\n if ( ! ( safename = qemuMonitorEscapeArg ( name ) ) || virAsprintf ( & cmd , \"delvm \\\"%s\\\"\" , safename ) < 0 ) {\n virReportOOMError ( ) ;\n goto cleanup ;\n }\n if ( qemuMonitorHMPCommand ( mon , cmd , & reply ) ) {\n qemuReportError ( VIR_ERR_OPERATION_FAILED , _ ( \"failed to delete snapshot using command '%s'\" ) , cmd ) ;\n goto cleanup ;\n }\n if ( strstr ( reply , \"No block device supports snapshots\" ) != NULL ) {\n qemuReportError ( VIR_ERR_OPERATION_INVALID , \"%s\" , _ ( \"this domain does not have a device to delete snapshots\" ) ) ;\n goto cleanup ;\n }\n else if ( strstr ( reply , \"Snapshots not supported on device\" ) != NULL ) {\n qemuReportError ( VIR_ERR_OPERATION_INVALID , \"%s\" , reply ) ;\n goto cleanup ;\n }\n else if ( strstr ( reply , \"Error\" ) != NULL && strstr ( reply , \"while deleting snapshot\" ) != NULL ) {\n qemuReportError ( VIR_ERR_OPERATION_FAILED , \"%s\" , reply ) ;\n goto cleanup ;\n }\n ret = 0 ;\n cleanup : VIR_FREE ( safename ) ;\n VIR_FREE ( cmd ) ;\n VIR_FREE ( reply ) ;\n return ret ;\n }", "idx": 22551}
{"hash": -866921002076081979, "project": "debian", "size": 21, "label": 0, "functionSource": "EXCLUSIVE_REGRESSION_TEST ( SDK_API_TSHttpConnectServerIntercept ) ( RegressionTest * test , int , int * pstatus ) {\n * pstatus = REGRESSION_TEST_INPROGRESS ;\n TSDebug ( UTDBG_TAG , \"Starting test TSHttpConnectServerintercept\" ) ;\n TSCont cont_test = TSContCreate ( cont_test_handler , TSMutexCreate ( ) ) ;\n ConnectTestData * data = ( ConnectTestData * ) TSmalloc ( sizeof ( ConnectTestData ) ) ;\n TSContDataSet ( cont_test , data ) ;\n data -> test = test ;\n data -> pstatus = pstatus ;\n data -> magic = MAGIC_ALIVE ;\n data -> test_case = TEST_CASE_CONNECT_ID2 ;\n TSHttpHookAdd ( TS_HTTP_READ_REQUEST_HDR_HOOK , cont_test ) ;\n data -> os = synserver_create ( SYNSERVER_DUMMY_PORT ) ;\n data -> browser = synclient_txn_create ( ) ;\n data -> request = generate_request ( 10 ) ;\n sockaddr_in addr ;\n ats_ip4_set ( & addr , 2 , 2 ) ;\n data -> vc = TSHttpConnect ( ats_ip_sa_cast ( & addr ) ) ;\n synclient_txn_send_request_to_vc ( data -> browser , data -> request , data -> vc ) ;\n TSContSchedule ( cont_test , 25 , TS_THREAD_POOL_DEFAULT ) ;\n return ;\n }", "idx": 22552}
{"hash": -8925552398357902286, "project": "chrome", "size": 34, "label": 0, "functionSource": "static void tokenize_init_one ( TOKENVALUE * t , const vp9_extra_bit * const e , int16_t * value_cost , int max_value ) {\n int i = - max_value ;\n int sign = 1 ;\n do {\n if ( ! i ) sign = 0 ;\n {\n const int a = sign ? - i : i ;\n int eb = sign ;\n if ( a > 4 ) {\n int j = 4 ;\n while ( ++ j < 11 && e [ j ] . base_val <= a ) {\n }\n t [ i ] . token = -- j ;\n eb |= ( a - e [ j ] . base_val ) << 1 ;\n }\n else {\n t [ i ] . token = a ;\n }\n t [ i ] . extra = eb ;\n }\n {\n int cost = 0 ;\n const vp9_extra_bit * p = & e [ t [ i ] . token ] ;\n if ( p -> base_val ) {\n const int extra = t [ i ] . extra ;\n const int length = p -> len ;\n if ( length ) cost += treed_cost ( p -> tree , p -> prob , extra >> 1 , length ) ;\n cost += vp9_cost_bit ( vp9_prob_half , extra & 1 ) ;\n value_cost [ i ] = cost ;\n }\n }\n }\n while ( ++ i < max_value ) ;\n }", "idx": 22553}
{"hash": 6600620671673714486, "project": "debian", "size": 13, "label": 0, "functionSource": "clump_t * clump_splay_walk_init ( clump_splay_walker * sw , const gs_ref_memory_t * mem ) {\n clump_t * cp = mem -> root ;\n if ( cp ) {\n SANITY_CHECK ( cp ) ;\n sw -> from = SPLAY_FROM_LEFT ;\n while ( cp -> left ) {\n cp = cp -> left ;\n }\n }\n sw -> cp = cp ;\n sw -> end = NULL ;\n return cp ;\n }", "idx": 22554}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_DialingInformationNumber ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_DialingInformationNumber , DialingInformationNumber_sequence ) ;\n return offset ;\n }", "idx": 22555}
{"hash": -6105298668491046960, "project": "debian", "size": 80, "label": 0, "functionSource": "static int msmpeg4v34_decode_mb ( MpegEncContext * s , int16_t block [ 6 ] [ 64 ] ) {\n int cbp , code , i ;\n uint8_t * coded_val ;\n uint32_t * const mb_type_ptr = & s -> current_picture . mb_type [ s -> mb_x + s -> mb_y * s -> mb_stride ] ;\n if ( s -> pict_type == AV_PICTURE_TYPE_P ) {\n if ( s -> use_skip_mb_code ) {\n if ( get_bits1 ( & s -> gb ) ) {\n s -> mb_intra = 0 ;\n for ( i = 0 ;\n i < 6 ;\n i ++ ) s -> block_last_index [ i ] = - 1 ;\n s -> mv_dir = MV_DIR_FORWARD ;\n s -> mv_type = MV_TYPE_16X16 ;\n s -> mv [ 0 ] [ 0 ] [ 0 ] = 0 ;\n s -> mv [ 0 ] [ 0 ] [ 1 ] = 0 ;\n s -> mb_skipped = 1 ;\n * mb_type_ptr = MB_TYPE_SKIP | MB_TYPE_L0 | MB_TYPE_16x16 ;\n return 0 ;\n }\n }\n code = get_vlc2 ( & s -> gb , ff_mb_non_intra_vlc [ DEFAULT_INTER_INDEX ] . table , MB_NON_INTRA_VLC_BITS , 3 ) ;\n if ( code < 0 ) return - 1 ;\n s -> mb_intra = ( ~ code & 0x40 ) >> 6 ;\n cbp = code & 0x3f ;\n }\n else {\n s -> mb_intra = 1 ;\n code = get_vlc2 ( & s -> gb , ff_msmp4_mb_i_vlc . table , MB_INTRA_VLC_BITS , 2 ) ;\n if ( code < 0 ) return - 1 ;\n cbp = 0 ;\n for ( i = 0 ;\n i < 6 ;\n i ++ ) {\n int val = ( ( code >> ( 5 - i ) ) & 1 ) ;\n if ( i < 4 ) {\n int pred = ff_msmpeg4_coded_block_pred ( s , i , & coded_val ) ;\n val = val ^ pred ;\n * coded_val = val ;\n }\n cbp |= val << ( 5 - i ) ;\n }\n }\n if ( ! s -> mb_intra ) {\n int mx , my ;\n if ( s -> per_mb_rl_table && cbp ) {\n s -> rl_table_index = decode012 ( & s -> gb ) ;\n s -> rl_chroma_table_index = s -> rl_table_index ;\n }\n ff_h263_pred_motion ( s , 0 , 0 , & mx , & my ) ;\n if ( ff_msmpeg4_decode_motion ( s , & mx , & my ) < 0 ) return - 1 ;\n s -> mv_dir = MV_DIR_FORWARD ;\n s -> mv_type = MV_TYPE_16X16 ;\n s -> mv [ 0 ] [ 0 ] [ 0 ] = mx ;\n s -> mv [ 0 ] [ 0 ] [ 1 ] = my ;\n * mb_type_ptr = MB_TYPE_L0 | MB_TYPE_16x16 ;\n }\n else {\n av_dlog ( s , \"I at %d %d %d %06X\\n\" , s -> mb_x , s -> mb_y , ( ( cbp & 3 ) ? 1 : 0 ) + ( ( cbp & 0x3C ) ? 2 : 0 ) , show_bits ( & s -> gb , 24 ) ) ;\n s -> ac_pred = get_bits1 ( & s -> gb ) ;\n * mb_type_ptr = MB_TYPE_INTRA ;\n if ( s -> inter_intra_pred ) {\n s -> h263_aic_dir = get_vlc2 ( & s -> gb , ff_inter_intra_vlc . table , INTER_INTRA_VLC_BITS , 1 ) ;\n av_dlog ( s , \"%d%d %d %d/\" , s -> ac_pred , s -> h263_aic_dir , s -> mb_x , s -> mb_y ) ;\n }\n if ( s -> per_mb_rl_table && cbp ) {\n s -> rl_table_index = decode012 ( & s -> gb ) ;\n s -> rl_chroma_table_index = s -> rl_table_index ;\n }\n }\n s -> dsp . clear_blocks ( s -> block [ 0 ] ) ;\n for ( i = 0 ;\n i < 6 ;\n i ++ ) {\n if ( ff_msmpeg4_decode_block ( s , block [ i ] , i , ( cbp >> ( 5 - i ) ) & 1 , NULL ) < 0 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"\\nerror while decoding block: %d x %d (%d)\\n\" , s -> mb_x , s -> mb_y , i ) ;\n return - 1 ;\n }\n }\n return 0 ;\n }", "idx": 22556}
{"hash": -3384986069176965684, "project": "chrome", "size": 13, "label": 0, "functionSource": "int vp8_set_active_map ( VP8_COMP * cpi , unsigned char * map , unsigned int rows , unsigned int cols ) {\n if ( rows == cpi -> common . mb_rows && cols == cpi -> common . mb_cols ) {\n if ( map ) {\n vpx_memcpy ( cpi -> active_map , map , rows * cols ) ;\n cpi -> active_map_enabled = 1 ;\n }\n else cpi -> active_map_enabled = 0 ;\n return 0 ;\n }\n else {\n return - 1 ;\n }\n }", "idx": 22557}
{"hash": 6380456053173444622, "project": "debian", "size": 14, "label": 0, "functionSource": "const char * SSL_rstate_string_long ( const SSL * s ) {\n const char * str ;\n switch ( s -> rstate ) {\n case SSL_ST_READ_HEADER : str = \"read header\" ;\n break ;\n case SSL_ST_READ_BODY : str = \"read body\" ;\n break ;\n case SSL_ST_READ_DONE : str = \"read done\" ;\n break ;\n default : str = \"unknown\" ;\n break ;\n }\n return ( str ) ;\n }", "idx": 22558}
{"hash": -2423144171479606949, "project": "debian", "size": 5, "label": 0, "functionSource": "static void pdf_run_Tstar ( fz_context * ctx , pdf_processor * proc ) {\n pdf_run_processor * pr = ( pdf_run_processor * ) proc ;\n pdf_gstate * gstate = pr -> gstate + pr -> gtop ;\n pdf_tos_newline ( & pr -> tos , gstate -> text . leading ) ;\n }", "idx": 22559}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_UserInputIndication ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_UserInputIndication , UserInputIndication_choice , NULL ) ;\n return offset ;\n }", "idx": 22560}
{"hash": 3557739556029059195, "project": "chrome", "size": 7, "label": 0, "functionSource": "void vp9_sad ## m ## x ## n ## x4d_c ( const uint8_t * src , int src_stride , const uint8_t * const refs [ ] , int ref_stride , unsigned int * sads ) {\n int i ;\n for ( i = 0 ;\n i < 4 ;\n ++ i ) sads [ i ] = vp9_sad ## m ## x ## n ## _c ( src , src_stride , refs [ i ] , ref_stride ) ;\n \\ }\n sadMxN ( 64 , 64 ) sadMxNxK ( 64 , 64 , 3 ) sadMxNxK ( 64 , 64 , 8 ) sadMxNx4D ( 64 , 64 ) sadMxN ( 64 , 32 ) sadMxNx4D ( 64 , 32 ) sadMxN ( 32 , 64 ) sadMxNx4D ( 32 , 64 )", "idx": 22561}
{"hash": 4489017523191997023, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h225_TunnelledProtocol_id ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_TunnelledProtocol_id , TunnelledProtocol_id_choice , NULL ) ;\n return offset ;\n }", "idx": 22562}
{"hash": -1055531103257174901, "project": "debian", "size": 21, "label": 0, "functionSource": "static void sig_message_own_public ( SERVER_REC * server , const char * msg , const char * target , const char * origtarget ) {\n CHANNEL_REC * channel ;\n NICK_REC * nick ;\n char * p , * msgnick ;\n g_return_if_fail ( server != NULL ) ;\n g_return_if_fail ( msg != NULL ) ;\n if ( target == NULL ) return ;\n channel = channel_find ( server , target ) ;\n if ( channel == NULL ) return ;\n p = strchr ( msg , ' ' ) ;\n if ( p != NULL && p != msg ) {\n msgnick = g_strndup ( msg , ( int ) ( p - msg ) ) ;\n nick = nicklist_find ( channel , msgnick ) ;\n if ( nick == NULL && msgnick [ 1 ] != '\\0' ) {\n msgnick [ strlen ( msgnick ) - 1 ] = '\\0' ;\n nick = nicklist_find ( channel , msgnick ) ;\n }\n g_free ( msgnick ) ;\n if ( nick != NULL && nick != channel -> ownnick ) CHANNEL_LAST_MSG_ADD ( channel , nick -> nick , TRUE ) ;\n }\n }", "idx": 22563}
{"hash": -7049333455584635197, "project": "chrome", "size": 61, "label": 1, "functionSource": "static UChar32 _UTF16BEGetNextUChar ( UConverterToUnicodeArgs * pArgs , UErrorCode * err ) {\n const uint8_t * s , * sourceLimit ;\n UChar32 c ;\n if ( pArgs -> converter -> mode < 8 ) {\n return UCNV_GET_NEXT_UCHAR_USE_TO_U ;\n }\n s = ( const uint8_t * ) pArgs -> source ;\n sourceLimit = ( const uint8_t * ) pArgs -> sourceLimit ;\n if ( s >= sourceLimit ) {\n * err = U_INDEX_OUTOFBOUNDS_ERROR ;\n return 0xffff ;\n }\n if ( s + 2 > sourceLimit ) {\n pArgs -> converter -> toUBytes [ 0 ] = * s ++ ;\n pArgs -> converter -> toULength = 1 ;\n pArgs -> source = ( const char * ) s ;\n * err = U_TRUNCATED_CHAR_FOUND ;\n return 0xffff ;\n }\n c = ( ( UChar32 ) * s << 8 ) | s [ 1 ] ;\n s += 2 ;\n if ( U_IS_SURROGATE ( c ) ) {\n if ( U16_IS_SURROGATE_LEAD ( c ) ) {\n if ( s + 2 <= sourceLimit ) {\n UChar trail ;\n trail = ( ( UChar ) * s << 8 ) | s [ 1 ] ;\n if ( U16_IS_TRAIL ( trail ) ) {\n c = U16_GET_SUPPLEMENTARY ( c , trail ) ;\n s += 2 ;\n }\n else {\n c = - 2 ;\n }\n }\n else {\n uint8_t * bytes = pArgs -> converter -> toUBytes ;\n s -= 2 ;\n pArgs -> converter -> toULength = ( int8_t ) ( sourceLimit - s ) ;\n do {\n * bytes ++ = * s ++ ;\n }\n while ( s < sourceLimit ) ;\n c = 0xffff ;\n * err = U_TRUNCATED_CHAR_FOUND ;\n }\n }\n else {\n c = - 2 ;\n }\n if ( c < 0 ) {\n uint8_t * bytes = pArgs -> converter -> toUBytes ;\n pArgs -> converter -> toULength = 2 ;\n * bytes = * ( s - 2 ) ;\n bytes [ 1 ] = * ( s - 1 ) ;\n c = 0xffff ;\n * err = U_ILLEGAL_CHAR_FOUND ;\n }\n }\n pArgs -> source = ( const char * ) s ;\n return c ;\n }", "idx": 22564}
{"hash": -6068399010699045437, "project": "debian", "size": 101, "label": 0, "functionSource": "static int dca_exss_parse_asset_header ( DCAContext * s ) {\n int header_pos = get_bits_count ( & s -> gb ) ;\n int header_size ;\n int channels ;\n int embedded_stereo = 0 ;\n int embedded_6ch = 0 ;\n int drc_code_present ;\n int extensions_mask ;\n int i , j ;\n if ( get_bits_left ( & s -> gb ) < 16 ) return - 1 ;\n header_size = get_bits ( & s -> gb , 9 ) + 1 ;\n skip_bits ( & s -> gb , 3 ) ;\n if ( s -> static_fields ) {\n if ( get_bits1 ( & s -> gb ) ) skip_bits ( & s -> gb , 4 ) ;\n if ( get_bits1 ( & s -> gb ) ) skip_bits_long ( & s -> gb , 24 ) ;\n if ( get_bits1 ( & s -> gb ) ) {\n int text_length = get_bits ( & s -> gb , 10 ) + 1 ;\n if ( get_bits_left ( & s -> gb ) < text_length * 8 ) return - 1 ;\n skip_bits_long ( & s -> gb , text_length * 8 ) ;\n }\n skip_bits ( & s -> gb , 5 ) ;\n skip_bits ( & s -> gb , 4 ) ;\n channels = get_bits ( & s -> gb , 8 ) + 1 ;\n if ( get_bits1 ( & s -> gb ) ) {\n int spkr_remap_sets ;\n int spkr_mask_size = 16 ;\n int num_spkrs [ 7 ] ;\n if ( channels > 2 ) embedded_stereo = get_bits1 ( & s -> gb ) ;\n if ( channels > 6 ) embedded_6ch = get_bits1 ( & s -> gb ) ;\n if ( get_bits1 ( & s -> gb ) ) {\n spkr_mask_size = ( get_bits ( & s -> gb , 2 ) + 1 ) << 2 ;\n skip_bits ( & s -> gb , spkr_mask_size ) ;\n }\n spkr_remap_sets = get_bits ( & s -> gb , 3 ) ;\n for ( i = 0 ;\n i < spkr_remap_sets ;\n i ++ ) {\n num_spkrs [ i ] = dca_exss_mask2count ( get_bits ( & s -> gb , spkr_mask_size ) ) ;\n }\n for ( i = 0 ;\n i < spkr_remap_sets ;\n i ++ ) {\n int num_dec_ch_remaps = get_bits ( & s -> gb , 5 ) + 1 ;\n if ( get_bits_left ( & s -> gb ) < 0 ) return - 1 ;\n for ( j = 0 ;\n j < num_spkrs [ i ] ;\n j ++ ) {\n int remap_dec_ch_mask = get_bits_long ( & s -> gb , num_dec_ch_remaps ) ;\n int num_dec_ch = av_popcount ( remap_dec_ch_mask ) ;\n skip_bits_long ( & s -> gb , num_dec_ch * 5 ) ;\n }\n }\n }\n else {\n skip_bits ( & s -> gb , 3 ) ;\n }\n }\n drc_code_present = get_bits1 ( & s -> gb ) ;\n if ( drc_code_present ) get_bits ( & s -> gb , 8 ) ;\n if ( get_bits1 ( & s -> gb ) ) skip_bits ( & s -> gb , 5 ) ;\n if ( drc_code_present && embedded_stereo ) get_bits ( & s -> gb , 8 ) ;\n if ( s -> mix_metadata && get_bits1 ( & s -> gb ) ) {\n skip_bits ( & s -> gb , 1 ) ;\n skip_bits ( & s -> gb , 6 ) ;\n if ( get_bits ( & s -> gb , 2 ) != 3 ) skip_bits ( & s -> gb , 3 ) ;\n else skip_bits ( & s -> gb , 8 ) ;\n if ( get_bits1 ( & s -> gb ) ) for ( i = 0 ;\n i < s -> num_mix_configs ;\n i ++ ) skip_bits_long ( & s -> gb , s -> mix_config_num_ch [ i ] * 6 ) ;\n else skip_bits_long ( & s -> gb , s -> num_mix_configs * 6 ) ;\n for ( i = 0 ;\n i < s -> num_mix_configs ;\n i ++ ) {\n if ( get_bits_left ( & s -> gb ) < 0 ) return - 1 ;\n dca_exss_skip_mix_coeffs ( & s -> gb , channels , s -> mix_config_num_ch [ i ] ) ;\n if ( embedded_6ch ) dca_exss_skip_mix_coeffs ( & s -> gb , 6 , s -> mix_config_num_ch [ i ] ) ;\n if ( embedded_stereo ) dca_exss_skip_mix_coeffs ( & s -> gb , 2 , s -> mix_config_num_ch [ i ] ) ;\n }\n }\n switch ( get_bits ( & s -> gb , 2 ) ) {\n case 0 : extensions_mask = get_bits ( & s -> gb , 12 ) ;\n break ;\n case 1 : extensions_mask = DCA_EXT_EXSS_XLL ;\n break ;\n case 2 : extensions_mask = DCA_EXT_EXSS_LBR ;\n break ;\n case 3 : extensions_mask = 0 ;\n break ;\n }\n if ( get_bits_left ( & s -> gb ) < 0 ) return - 1 ;\n if ( get_bits_count ( & s -> gb ) - header_pos > header_size * 8 ) {\n av_log ( s -> avctx , AV_LOG_WARNING , \"Asset header size mismatch.\\n\" ) ;\n return - 1 ;\n }\n skip_bits_long ( & s -> gb , header_pos + header_size * 8 - get_bits_count ( & s -> gb ) ) ;\n if ( extensions_mask & DCA_EXT_EXSS_XLL ) s -> profile = FF_PROFILE_DTS_HD_MA ;\n else if ( extensions_mask & ( DCA_EXT_EXSS_XBR | DCA_EXT_EXSS_X96 | DCA_EXT_EXSS_XXCH ) ) s -> profile = FF_PROFILE_DTS_HD_HRA ;\n if ( ! ( extensions_mask & DCA_EXT_CORE ) ) av_log ( s -> avctx , AV_LOG_WARNING , \"DTS core detection mismatch.\\n\" ) ;\n if ( ( extensions_mask & DCA_CORE_EXTS ) != s -> core_ext_mask ) av_log ( s -> avctx , AV_LOG_WARNING , \"DTS extensions detection mismatch (%d, %d)\\n\" , extensions_mask & DCA_CORE_EXTS , s -> core_ext_mask ) ;\n return 0 ;\n }", "idx": 22565}
{"hash": -6527276140940489090, "project": "chrome", "size": 29, "label": 1, "functionSource": "TEST_F ( TransportSecurityPersisterTest , PublicKeyHashes ) {\n TransportSecurityState : : DomainState domain_state ;\n static const char kTestDomain [ ] = \"example.com\" ;\n EXPECT_FALSE ( state_ . GetDomainState ( kTestDomain , false , & domain_state ) ) ;\n net : : HashValueVector hashes ;\n std : : string failure_log ;\n EXPECT_FALSE ( domain_state . CheckPublicKeyPins ( hashes , & failure_log ) ) ;\n net : : HashValue sha1 ( net : : HASH_VALUE_SHA1 ) ;\n memset ( sha1 . data ( ) , '1' , sha1 . size ( ) ) ;\n domain_state . dynamic_spki_hashes . push_back ( sha1 ) ;\n EXPECT_FALSE ( domain_state . CheckPublicKeyPins ( hashes , & failure_log ) ) ;\n hashes . push_back ( sha1 ) ;\n EXPECT_TRUE ( domain_state . CheckPublicKeyPins ( hashes , & failure_log ) ) ;\n hashes [ 0 ] . data ( ) [ 0 ] = '2' ;\n EXPECT_FALSE ( domain_state . CheckPublicKeyPins ( hashes , & failure_log ) ) ;\n const base : : Time current_time ( base : : Time : : Now ( ) ) ;\n const base : : Time expiry = current_time + base : : TimeDelta : : FromSeconds ( 1000 ) ;\n bool include_subdomains = false ;\n state_ . AddHSTS ( kTestDomain , expiry , include_subdomains ) ;\n state_ . AddHPKP ( kTestDomain , expiry , include_subdomains , domain_state . dynamic_spki_hashes ) ;\n std : : string ser ;\n EXPECT_TRUE ( persister_ -> SerializeData ( & ser ) ) ;\n bool dirty ;\n EXPECT_TRUE ( persister_ -> LoadEntries ( ser , & dirty ) ) ;\n EXPECT_TRUE ( state_ . GetDomainState ( kTestDomain , false , & domain_state ) ) ;\n EXPECT_EQ ( 1u , domain_state . dynamic_spki_hashes . size ( ) ) ;\n EXPECT_EQ ( sha1 . tag , domain_state . dynamic_spki_hashes [ 0 ] . tag ) ;\n EXPECT_EQ ( 0 , memcmp ( domain_state . dynamic_spki_hashes [ 0 ] . data ( ) , sha1 . data ( ) , sha1 . size ( ) ) ) ;\n }", "idx": 22566}
{"hash": 2335116444795821310, "project": "debian", "size": 9, "label": 0, "functionSource": "void config_filter_deinit ( struct config_filter_context * * _ctx ) {\n struct config_filter_context * ctx = * _ctx ;\n unsigned int i ;\n * _ctx = NULL ;\n for ( i = 0 ;\n ctx -> parsers [ i ] != NULL ;\n i ++ ) config_filter_parsers_free ( ctx -> parsers [ i ] -> parsers ) ;\n pool_unref ( & ctx -> pool ) ;\n }", "idx": 22567}
{"hash": 1245821301839614810, "project": "debian", "size": 20, "label": 0, "functionSource": "static int seconds_count_format_time_units ( int seconds ) {\n int minutes ;\n int hours ;\n if ( seconds < 0 ) {\n seconds = 0 ;\n }\n if ( seconds < 60 ) {\n return seconds ;\n }\n if ( seconds < 60 * 60 ) {\n minutes = seconds / 60 ;\n return minutes ;\n }\n hours = seconds / ( 60 * 60 ) ;\n if ( seconds < 60 * 60 * 4 ) {\n minutes = ( seconds - hours * 60 * 60 ) / 60 ;\n return minutes + hours ;\n }\n return hours ;\n }", "idx": 22568}
{"hash": 453825853695477219, "project": "debian", "size": 234, "label": 1, "functionSource": "int ff_h263_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n MpegEncContext * s = avctx -> priv_data ;\n int ret ;\n AVFrame * pict = data ;\n # ifdef PRINT_FRAME_TIME uint64_t time = rdtsc ( ) ;\n # endif s -> flags = avctx -> flags ;\n s -> flags2 = avctx -> flags2 ;\n if ( buf_size == 0 ) {\n if ( s -> low_delay == 0 && s -> next_picture_ptr ) {\n * pict = s -> next_picture_ptr -> f ;\n s -> next_picture_ptr = NULL ;\n * got_frame = 1 ;\n }\n return 0 ;\n }\n if ( s -> flags & CODEC_FLAG_TRUNCATED ) {\n int next ;\n if ( CONFIG_MPEG4_DECODER && s -> codec_id == AV_CODEC_ID_MPEG4 ) {\n next = ff_mpeg4_find_frame_end ( & s -> parse_context , buf , buf_size ) ;\n }\n else if ( CONFIG_H263_DECODER && s -> codec_id == AV_CODEC_ID_H263 ) {\n next = ff_h263_find_frame_end ( & s -> parse_context , buf , buf_size ) ;\n }\n else {\n av_log ( s -> avctx , AV_LOG_ERROR , \"this codec does not support truncated bitstreams\\n\" ) ;\n return - 1 ;\n }\n if ( ff_combine_frame ( & s -> parse_context , next , ( const uint8_t * * ) & buf , & buf_size ) < 0 ) return buf_size ;\n }\n retry : if ( s -> bitstream_buffer_size && ( s -> divx_packed || buf_size < 20 ) ) {\n init_get_bits ( & s -> gb , s -> bitstream_buffer , s -> bitstream_buffer_size * 8 ) ;\n }\n else init_get_bits ( & s -> gb , buf , buf_size * 8 ) ;\n s -> bitstream_buffer_size = 0 ;\n if ( ! s -> context_initialized ) {\n if ( ff_MPV_common_init ( s ) < 0 ) return - 1 ;\n }\n if ( s -> current_picture_ptr == NULL || s -> current_picture_ptr -> f . data [ 0 ] ) {\n int i = ff_find_unused_picture ( s , 0 ) ;\n if ( i < 0 ) return i ;\n s -> current_picture_ptr = & s -> picture [ i ] ;\n }\n if ( CONFIG_WMV2_DECODER && s -> msmpeg4_version == 5 ) {\n ret = ff_wmv2_decode_picture_header ( s ) ;\n }\n else if ( CONFIG_MSMPEG4_DECODER && s -> msmpeg4_version ) {\n ret = ff_msmpeg4_decode_picture_header ( s ) ;\n }\n else if ( CONFIG_MPEG4_DECODER && s -> h263_pred ) {\n if ( s -> avctx -> extradata_size && s -> picture_number == 0 ) {\n GetBitContext gb ;\n init_get_bits ( & gb , s -> avctx -> extradata , s -> avctx -> extradata_size * 8 ) ;\n ret = ff_mpeg4_decode_picture_header ( s , & gb ) ;\n }\n ret = ff_mpeg4_decode_picture_header ( s , & s -> gb ) ;\n }\n else if ( CONFIG_H263I_DECODER && s -> codec_id == AV_CODEC_ID_H263I ) {\n ret = ff_intel_h263_decode_picture_header ( s ) ;\n }\n else if ( CONFIG_FLV_DECODER && s -> h263_flv ) {\n ret = ff_flv_decode_picture_header ( s ) ;\n }\n else {\n ret = ff_h263_decode_picture_header ( s ) ;\n }\n if ( ret == FRAME_SKIPPED ) return get_consumed_bytes ( s , buf_size ) ;\n if ( ret < 0 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"header damaged\\n\" ) ;\n return - 1 ;\n }\n avctx -> has_b_frames = ! s -> low_delay ;\n if ( s -> xvid_build == - 1 && s -> divx_version == - 1 && s -> lavc_build == - 1 ) {\n if ( s -> stream_codec_tag == AV_RL32 ( \"XVID\" ) || s -> codec_tag == AV_RL32 ( \"XVID\" ) || s -> codec_tag == AV_RL32 ( \"XVIX\" ) || s -> codec_tag == AV_RL32 ( \"RMP4\" ) || s -> codec_tag == AV_RL32 ( \"ZMP4\" ) || s -> codec_tag == AV_RL32 ( \"SIPP\" ) ) s -> xvid_build = 0 ;\n # if 0 if ( s -> codec_tag == AV_RL32 ( \"DIVX\" ) && s -> vo_type == 0 && s -> vol_control_parameters == 1 && s -> padding_bug_score > 0 && s -> low_delay ) s -> xvid_build = 0 ;\n # endif }\n if ( s -> xvid_build == - 1 && s -> divx_version == - 1 && s -> lavc_build == - 1 ) {\n if ( s -> codec_tag == AV_RL32 ( \"DIVX\" ) && s -> vo_type == 0 && s -> vol_control_parameters == 0 ) s -> divx_version = 400 ;\n }\n if ( s -> xvid_build >= 0 && s -> divx_version >= 0 ) {\n s -> divx_version = s -> divx_build = - 1 ;\n }\n if ( s -> workaround_bugs & FF_BUG_AUTODETECT ) {\n if ( s -> codec_tag == AV_RL32 ( \"XVIX\" ) ) s -> workaround_bugs |= FF_BUG_XVID_ILACE ;\n if ( s -> codec_tag == AV_RL32 ( \"UMP4\" ) ) {\n s -> workaround_bugs |= FF_BUG_UMP4 ;\n }\n if ( s -> divx_version >= 500 && s -> divx_build < 1814 ) {\n s -> workaround_bugs |= FF_BUG_QPEL_CHROMA ;\n }\n if ( s -> divx_version > 502 && s -> divx_build < 1814 ) {\n s -> workaround_bugs |= FF_BUG_QPEL_CHROMA2 ;\n }\n if ( s -> xvid_build <= 3U ) s -> padding_bug_score = 256 * 256 * 256 * 64 ;\n if ( s -> xvid_build <= 1U ) s -> workaround_bugs |= FF_BUG_QPEL_CHROMA ;\n if ( s -> xvid_build <= 12U ) s -> workaround_bugs |= FF_BUG_EDGE ;\n if ( s -> xvid_build <= 32U ) s -> workaround_bugs |= FF_BUG_DC_CLIP ;\n # define SET_QPEL_FUNC ( postfix1 , postfix2 ) s -> dsp . put_ ## postfix1 = ff_put_ ## postfix2 ;\n s -> dsp . put_no_rnd_ ## postfix1 = ff_put_no_rnd_ ## postfix2 ;\n s -> dsp . avg_ ## postfix1 = ff_avg_ ## postfix2 ;\n if ( s -> lavc_build < 4653U ) s -> workaround_bugs |= FF_BUG_STD_QPEL ;\n if ( s -> lavc_build < 4655U ) s -> workaround_bugs |= FF_BUG_DIRECT_BLOCKSIZE ;\n if ( s -> lavc_build < 4670U ) {\n s -> workaround_bugs |= FF_BUG_EDGE ;\n }\n if ( s -> lavc_build <= 4712U ) s -> workaround_bugs |= FF_BUG_DC_CLIP ;\n if ( s -> divx_version >= 0 ) s -> workaround_bugs |= FF_BUG_DIRECT_BLOCKSIZE ;\n if ( s -> divx_version == 501 && s -> divx_build == 20020416 ) s -> padding_bug_score = 256 * 256 * 256 * 64 ;\n if ( s -> divx_version < 500U ) {\n s -> workaround_bugs |= FF_BUG_EDGE ;\n }\n if ( s -> divx_version >= 0 ) s -> workaround_bugs |= FF_BUG_HPEL_CHROMA ;\n # if 0 if ( s -> divx_version == 500 ) s -> padding_bug_score = 256 * 256 * 256 * 64 ;\n if ( s -> resync_marker == 0 && s -> data_partitioning == 0 && s -> divx_version == - 1 && s -> codec_id == AV_CODEC_ID_MPEG4 && s -> vo_type == 0 ) s -> workaround_bugs |= FF_BUG_NO_PADDING ;\n if ( s -> lavc_build < 4609U ) s -> workaround_bugs |= FF_BUG_NO_PADDING ;\n # endif }\n if ( s -> workaround_bugs & FF_BUG_STD_QPEL ) {\n SET_QPEL_FUNC ( qpel_pixels_tab [ 0 ] [ 5 ] , qpel16_mc11_old_c ) SET_QPEL_FUNC ( qpel_pixels_tab [ 0 ] [ 7 ] , qpel16_mc31_old_c ) SET_QPEL_FUNC ( qpel_pixels_tab [ 0 ] [ 9 ] , qpel16_mc12_old_c ) SET_QPEL_FUNC ( qpel_pixels_tab [ 0 ] [ 11 ] , qpel16_mc32_old_c ) SET_QPEL_FUNC ( qpel_pixels_tab [ 0 ] [ 13 ] , qpel16_mc13_old_c ) SET_QPEL_FUNC ( qpel_pixels_tab [ 0 ] [ 15 ] , qpel16_mc33_old_c ) SET_QPEL_FUNC ( qpel_pixels_tab [ 1 ] [ 5 ] , qpel8_mc11_old_c ) SET_QPEL_FUNC ( qpel_pixels_tab [ 1 ] [ 7 ] , qpel8_mc31_old_c ) SET_QPEL_FUNC ( qpel_pixels_tab [ 1 ] [ 9 ] , qpel8_mc12_old_c ) SET_QPEL_FUNC ( qpel_pixels_tab [ 1 ] [ 11 ] , qpel8_mc32_old_c ) SET_QPEL_FUNC ( qpel_pixels_tab [ 1 ] [ 13 ] , qpel8_mc13_old_c ) SET_QPEL_FUNC ( qpel_pixels_tab [ 1 ] [ 15 ] , qpel8_mc33_old_c ) }\n if ( avctx -> debug & FF_DEBUG_BUGS ) av_log ( s -> avctx , AV_LOG_DEBUG , \"bugs: %X lavc_build:%d xvid_build:%d divx_version:%d divx_build:%d %s\\n\" , s -> workaround_bugs , s -> lavc_build , s -> xvid_build , s -> divx_version , s -> divx_build , s -> divx_packed ? \"p\" : \"\" ) ;\n # if HAVE_MMX if ( s -> codec_id == AV_CODEC_ID_MPEG4 && s -> xvid_build >= 0 && avctx -> idct_algo == FF_IDCT_AUTO && ( av_get_cpu_flags ( ) & AV_CPU_FLAG_MMX ) ) {\n avctx -> idct_algo = FF_IDCT_XVIDMMX ;\n ff_dct_common_init ( s ) ;\n s -> picture_number = 0 ;\n }\n # endif if ( ! avctx -> coded_width || ! avctx -> coded_height ) {\n ParseContext pc = s -> parse_context ;\n s -> parse_context . buffer = 0 ;\n ff_MPV_common_end ( s ) ;\n s -> parse_context = pc ;\n avcodec_set_dimensions ( avctx , s -> width , s -> height ) ;\n goto retry ;\n }\n if ( s -> width != avctx -> coded_width || s -> height != avctx -> coded_height || s -> context_reinit ) {\n s -> context_reinit = 0 ;\n avcodec_set_dimensions ( avctx , s -> width , s -> height ) ;\n if ( ( ret = ff_MPV_common_frame_size_change ( s ) ) ) return ret ;\n }\n if ( ( s -> codec_id == AV_CODEC_ID_H263 || s -> codec_id == AV_CODEC_ID_H263P || s -> codec_id == AV_CODEC_ID_H263I ) ) s -> gob_index = ff_h263_get_gob_height ( s ) ;\n s -> current_picture . f . pict_type = s -> pict_type ;\n s -> current_picture . f . key_frame = s -> pict_type == AV_PICTURE_TYPE_I ;\n if ( s -> last_picture_ptr == NULL && ( s -> pict_type == AV_PICTURE_TYPE_B || s -> droppable ) ) return get_consumed_bytes ( s , buf_size ) ;\n if ( ( avctx -> skip_frame >= AVDISCARD_NONREF && s -> pict_type == AV_PICTURE_TYPE_B ) || ( avctx -> skip_frame >= AVDISCARD_NONKEY && s -> pict_type != AV_PICTURE_TYPE_I ) || avctx -> skip_frame >= AVDISCARD_ALL ) return get_consumed_bytes ( s , buf_size ) ;\n if ( s -> next_p_frame_damaged ) {\n if ( s -> pict_type == AV_PICTURE_TYPE_B ) return get_consumed_bytes ( s , buf_size ) ;\n else s -> next_p_frame_damaged = 0 ;\n }\n if ( ( ! s -> no_rounding ) || s -> pict_type == AV_PICTURE_TYPE_B ) {\n s -> me . qpel_put = s -> dsp . put_qpel_pixels_tab ;\n s -> me . qpel_avg = s -> dsp . avg_qpel_pixels_tab ;\n }\n else {\n s -> me . qpel_put = s -> dsp . put_no_rnd_qpel_pixels_tab ;\n s -> me . qpel_avg = s -> dsp . avg_qpel_pixels_tab ;\n }\n if ( ff_MPV_frame_start ( s , avctx ) < 0 ) return - 1 ;\n if ( ! s -> divx_packed ) ff_thread_finish_setup ( avctx ) ;\n if ( CONFIG_MPEG4_VDPAU_DECODER && ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU ) ) {\n ff_vdpau_mpeg4_decode_picture ( s , s -> gb . buffer , s -> gb . buffer_end - s -> gb . buffer ) ;\n goto frame_end ;\n }\n if ( avctx -> hwaccel ) {\n if ( avctx -> hwaccel -> start_frame ( avctx , s -> gb . buffer , s -> gb . buffer_end - s -> gb . buffer ) < 0 ) return - 1 ;\n }\n ff_mpeg_er_frame_start ( s ) ;\n if ( CONFIG_WMV2_DECODER && s -> msmpeg4_version == 5 ) {\n ret = ff_wmv2_decode_secondary_picture_header ( s ) ;\n if ( ret < 0 ) return ret ;\n if ( ret == 1 ) goto intrax8_decoded ;\n }\n s -> mb_x = 0 ;\n s -> mb_y = 0 ;\n ret = decode_slice ( s ) ;\n while ( s -> mb_y < s -> mb_height ) {\n if ( s -> msmpeg4_version ) {\n if ( s -> slice_height == 0 || s -> mb_x != 0 || ( s -> mb_y % s -> slice_height ) != 0 || get_bits_left ( & s -> gb ) < 0 ) break ;\n }\n else {\n int prev_x = s -> mb_x , prev_y = s -> mb_y ;\n if ( ff_h263_resync ( s ) < 0 ) break ;\n if ( prev_y * s -> mb_width + prev_x < s -> mb_y * s -> mb_width + s -> mb_x ) s -> er . error_occurred = 1 ;\n }\n if ( s -> msmpeg4_version < 4 && s -> h263_pred ) ff_mpeg4_clean_buffers ( s ) ;\n if ( decode_slice ( s ) < 0 ) ret = AVERROR_INVALIDDATA ;\n }\n if ( s -> msmpeg4_version && s -> msmpeg4_version < 4 && s -> pict_type == AV_PICTURE_TYPE_I ) if ( ! CONFIG_MSMPEG4_DECODER || ff_msmpeg4_decode_ext_header ( s , buf_size ) < 0 ) {\n s -> er . error_status_table [ s -> mb_num - 1 ] = ER_MB_ERROR ;\n }\n assert ( s -> bitstream_buffer_size == 0 ) ;\n frame_end : if ( s -> codec_id == AV_CODEC_ID_MPEG4 && s -> divx_packed ) {\n int current_pos = get_bits_count ( & s -> gb ) >> 3 ;\n int startcode_found = 0 ;\n if ( buf_size - current_pos > 5 ) {\n int i ;\n for ( i = current_pos ;\n i < buf_size - 3 ;\n i ++ ) {\n if ( buf [ i ] == 0 && buf [ i + 1 ] == 0 && buf [ i + 2 ] == 1 && buf [ i + 3 ] == 0xB6 ) {\n startcode_found = 1 ;\n break ;\n }\n }\n }\n if ( s -> gb . buffer == s -> bitstream_buffer && buf_size > 7 && s -> xvid_build >= 0 ) {\n startcode_found = 1 ;\n current_pos = 0 ;\n }\n if ( startcode_found ) {\n av_fast_malloc ( & s -> bitstream_buffer , & s -> allocated_bitstream_buffer_size , buf_size - current_pos + FF_INPUT_BUFFER_PADDING_SIZE ) ;\n if ( ! s -> bitstream_buffer ) return AVERROR ( ENOMEM ) ;\n memcpy ( s -> bitstream_buffer , buf + current_pos , buf_size - current_pos ) ;\n s -> bitstream_buffer_size = buf_size - current_pos ;\n }\n }\n intrax8_decoded : ff_er_frame_end ( & s -> er ) ;\n if ( avctx -> hwaccel ) {\n if ( avctx -> hwaccel -> end_frame ( avctx ) < 0 ) return - 1 ;\n }\n ff_MPV_frame_end ( s ) ;\n assert ( s -> current_picture . f . pict_type == s -> current_picture_ptr -> f . pict_type ) ;\n assert ( s -> current_picture . f . pict_type == s -> pict_type ) ;\n if ( s -> pict_type == AV_PICTURE_TYPE_B || s -> low_delay ) {\n * pict = s -> current_picture_ptr -> f ;\n }\n else if ( s -> last_picture_ptr != NULL ) {\n * pict = s -> last_picture_ptr -> f ;\n }\n if ( s -> last_picture_ptr || s -> low_delay ) {\n * got_frame = 1 ;\n ff_print_debug_info ( s , pict ) ;\n }\n # ifdef PRINT_FRAME_TIME av_log ( avctx , AV_LOG_DEBUG , \"%\" PRId64 \"\\n\" , rdtsc ( ) - time ) ;\n # endif return ( ret && ( avctx -> err_recognition & AV_EF_EXPLODE ) ) ? ret : get_consumed_bytes ( s , buf_size ) ;\n }", "idx": 22569}
{"hash": 1859256631654516868, "project": "chrome", "size": 85, "label": 0, "functionSource": "static int fill_filter_caches ( H264Context * h , int mb_type ) {\n const int mb_xy = h -> mb_xy ;\n int top_xy , left_xy [ LEFT_MBS ] ;\n int top_type , left_type [ LEFT_MBS ] ;\n uint8_t * nnz ;\n uint8_t * nnz_cache ;\n top_xy = mb_xy - ( h -> mb_stride << MB_FIELD ( h ) ) ;\n left_xy [ LBOT ] = left_xy [ LTOP ] = mb_xy - 1 ;\n if ( FRAME_MBAFF ( h ) ) {\n const int left_mb_field_flag = IS_INTERLACED ( h -> cur_pic . mb_type [ mb_xy - 1 ] ) ;\n const int curr_mb_field_flag = IS_INTERLACED ( mb_type ) ;\n if ( h -> mb_y & 1 ) {\n if ( left_mb_field_flag != curr_mb_field_flag ) left_xy [ LTOP ] -= h -> mb_stride ;\n }\n else {\n if ( curr_mb_field_flag ) top_xy += h -> mb_stride & ( ( ( h -> cur_pic . mb_type [ top_xy ] >> 7 ) & 1 ) - 1 ) ;\n if ( left_mb_field_flag != curr_mb_field_flag ) left_xy [ LBOT ] += h -> mb_stride ;\n }\n }\n h -> top_mb_xy = top_xy ;\n h -> left_mb_xy [ LTOP ] = left_xy [ LTOP ] ;\n h -> left_mb_xy [ LBOT ] = left_xy [ LBOT ] ;\n {\n int qp_thresh = h -> qp_thresh ;\n int qp = h -> cur_pic . qscale_table [ mb_xy ] ;\n if ( qp <= qp_thresh && ( left_xy [ LTOP ] < 0 || ( ( qp + h -> cur_pic . qscale_table [ left_xy [ LTOP ] ] + 1 ) >> 1 ) <= qp_thresh ) && ( top_xy < 0 || ( ( qp + h -> cur_pic . qscale_table [ top_xy ] + 1 ) >> 1 ) <= qp_thresh ) ) {\n if ( ! FRAME_MBAFF ( h ) ) return 1 ;\n if ( ( left_xy [ LTOP ] < 0 || ( ( qp + h -> cur_pic . qscale_table [ left_xy [ LBOT ] ] + 1 ) >> 1 ) <= qp_thresh ) && ( top_xy < h -> mb_stride || ( ( qp + h -> cur_pic . qscale_table [ top_xy - h -> mb_stride ] + 1 ) >> 1 ) <= qp_thresh ) ) return 1 ;\n }\n }\n top_type = h -> cur_pic . mb_type [ top_xy ] ;\n left_type [ LTOP ] = h -> cur_pic . mb_type [ left_xy [ LTOP ] ] ;\n left_type [ LBOT ] = h -> cur_pic . mb_type [ left_xy [ LBOT ] ] ;\n if ( h -> deblocking_filter == 2 ) {\n if ( h -> slice_table [ top_xy ] != h -> slice_num ) top_type = 0 ;\n if ( h -> slice_table [ left_xy [ LBOT ] ] != h -> slice_num ) left_type [ LTOP ] = left_type [ LBOT ] = 0 ;\n }\n else {\n if ( h -> slice_table [ top_xy ] == 0xFFFF ) top_type = 0 ;\n if ( h -> slice_table [ left_xy [ LBOT ] ] == 0xFFFF ) left_type [ LTOP ] = left_type [ LBOT ] = 0 ;\n }\n h -> top_type = top_type ;\n h -> left_type [ LTOP ] = left_type [ LTOP ] ;\n h -> left_type [ LBOT ] = left_type [ LBOT ] ;\n if ( IS_INTRA ( mb_type ) ) return 0 ;\n fill_filter_caches_inter ( h , mb_type , top_xy , left_xy , top_type , left_type , mb_xy , 0 ) ;\n if ( h -> list_count == 2 ) fill_filter_caches_inter ( h , mb_type , top_xy , left_xy , top_type , left_type , mb_xy , 1 ) ;\n nnz = h -> non_zero_count [ mb_xy ] ;\n nnz_cache = h -> non_zero_count_cache ;\n AV_COPY32 ( & nnz_cache [ 4 + 8 * 1 ] , & nnz [ 0 ] ) ;\n AV_COPY32 ( & nnz_cache [ 4 + 8 * 2 ] , & nnz [ 4 ] ) ;\n AV_COPY32 ( & nnz_cache [ 4 + 8 * 3 ] , & nnz [ 8 ] ) ;\n AV_COPY32 ( & nnz_cache [ 4 + 8 * 4 ] , & nnz [ 12 ] ) ;\n h -> cbp = h -> cbp_table [ mb_xy ] ;\n if ( top_type ) {\n nnz = h -> non_zero_count [ top_xy ] ;\n AV_COPY32 ( & nnz_cache [ 4 + 8 * 0 ] , & nnz [ 3 * 4 ] ) ;\n }\n if ( left_type [ LTOP ] ) {\n nnz = h -> non_zero_count [ left_xy [ LTOP ] ] ;\n nnz_cache [ 3 + 8 * 1 ] = nnz [ 3 + 0 * 4 ] ;\n nnz_cache [ 3 + 8 * 2 ] = nnz [ 3 + 1 * 4 ] ;\n nnz_cache [ 3 + 8 * 3 ] = nnz [ 3 + 2 * 4 ] ;\n nnz_cache [ 3 + 8 * 4 ] = nnz [ 3 + 3 * 4 ] ;\n }\n if ( ! CABAC ( h ) && h -> pps . transform_8x8_mode ) {\n if ( IS_8x8DCT ( top_type ) ) {\n nnz_cache [ 4 + 8 * 0 ] = nnz_cache [ 5 + 8 * 0 ] = ( h -> cbp_table [ top_xy ] & 0x4000 ) >> 12 ;\n nnz_cache [ 6 + 8 * 0 ] = nnz_cache [ 7 + 8 * 0 ] = ( h -> cbp_table [ top_xy ] & 0x8000 ) >> 12 ;\n }\n if ( IS_8x8DCT ( left_type [ LTOP ] ) ) {\n nnz_cache [ 3 + 8 * 1 ] = nnz_cache [ 3 + 8 * 2 ] = ( h -> cbp_table [ left_xy [ LTOP ] ] & 0x2000 ) >> 12 ;\n }\n if ( IS_8x8DCT ( left_type [ LBOT ] ) ) {\n nnz_cache [ 3 + 8 * 3 ] = nnz_cache [ 3 + 8 * 4 ] = ( h -> cbp_table [ left_xy [ LBOT ] ] & 0x8000 ) >> 12 ;\n }\n if ( IS_8x8DCT ( mb_type ) ) {\n nnz_cache [ scan8 [ 0 ] ] = nnz_cache [ scan8 [ 1 ] ] = nnz_cache [ scan8 [ 2 ] ] = nnz_cache [ scan8 [ 3 ] ] = ( h -> cbp & 0x1000 ) >> 12 ;\n nnz_cache [ scan8 [ 0 + 4 ] ] = nnz_cache [ scan8 [ 1 + 4 ] ] = nnz_cache [ scan8 [ 2 + 4 ] ] = nnz_cache [ scan8 [ 3 + 4 ] ] = ( h -> cbp & 0x2000 ) >> 12 ;\n nnz_cache [ scan8 [ 0 + 8 ] ] = nnz_cache [ scan8 [ 1 + 8 ] ] = nnz_cache [ scan8 [ 2 + 8 ] ] = nnz_cache [ scan8 [ 3 + 8 ] ] = ( h -> cbp & 0x4000 ) >> 12 ;\n nnz_cache [ scan8 [ 0 + 12 ] ] = nnz_cache [ scan8 [ 1 + 12 ] ] = nnz_cache [ scan8 [ 2 + 12 ] ] = nnz_cache [ scan8 [ 3 + 12 ] ] = ( h -> cbp & 0x8000 ) >> 12 ;\n }\n }\n return 0 ;\n }", "idx": 22570}
{"hash": -6024601983167898950, "project": "debian", "size": 23, "label": 0, "functionSource": "static void activation_get_activation_uris ( ActivateParameters * parameters ) {\n GList * l , * files ;\n NautilusFile * file ;\n LaunchLocation * location ;\n for ( l = parameters -> locations ;\n l != NULL ;\n l = l -> next ) {\n location = l -> data ;\n file = location -> file ;\n if ( file_was_cancelled ( file ) ) {\n launch_location_free ( location ) ;\n parameters -> locations = g_list_delete_link ( parameters -> locations , l ) ;\n continue ;\n }\n }\n if ( parameters -> locations == NULL ) {\n activation_parameters_free ( parameters ) ;\n return ;\n }\n files = get_file_list_for_launch_locations ( parameters -> locations ) ;\n nautilus_file_list_call_when_ready ( files , nautilus_mime_actions_get_required_file_attributes ( ) , & parameters -> files_handle , activate_activation_uris_ready_callback , parameters ) ;\n nautilus_file_list_free ( files ) ;\n }", "idx": 22571}
{"hash": 5838244232542871853, "project": "chrome", "size": 20, "label": 0, "functionSource": "TEST_F ( ScoredHistoryMatchTest , GetFinalRelevancyScore ) {\n std : : vector < ScoredHistoryMatch : : ScoreMaxRelevance > hqp_buckets ;\n hqp_buckets . push_back ( std : : make_pair ( 0.0 , 100 ) ) ;\n hqp_buckets . push_back ( std : : make_pair ( 1.0 , 200 ) ) ;\n hqp_buckets . push_back ( std : : make_pair ( 4.0 , 500 ) ) ;\n hqp_buckets . push_back ( std : : make_pair ( 8.0 , 900 ) ) ;\n hqp_buckets . push_back ( std : : make_pair ( 10.0 , 1000 ) ) ;\n float topicality_score = 0.0 ;\n float frequency_score = 10.0 ;\n EXPECT_EQ ( 0 , ScoredHistoryMatch : : GetFinalRelevancyScore ( topicality_score , frequency_score , hqp_buckets ) ) ;\n topicality_score = 0.4f ;\n frequency_score = 10.0f ;\n EXPECT_EQ ( 500 , ScoredHistoryMatch : : GetFinalRelevancyScore ( topicality_score , frequency_score , hqp_buckets ) ) ;\n topicality_score = 0.5f ;\n frequency_score = 10.0f ;\n EXPECT_EQ ( 600 , ScoredHistoryMatch : : GetFinalRelevancyScore ( topicality_score , frequency_score , hqp_buckets ) ) ;\n topicality_score = 0.5f ;\n frequency_score = 22.0f ;\n EXPECT_EQ ( 1000 , ScoredHistoryMatch : : GetFinalRelevancyScore ( topicality_score , frequency_score , hqp_buckets ) ) ;\n }", "idx": 22572}
{"hash": -2648356651055439484, "project": "debian", "size": 3, "label": 0, "functionSource": "static gboolean gsm_a_dtap_ss_stat_packet ( void * tapdata , packet_info * pinfo _U_ , epan_dissect_t * edt _U_ , const void * gatr_ptr ) {\n return gsm_a_stat_packet ( tapdata , gatr_ptr , BSSAP_PDU_TYPE_DTAP , PD_SS ) ;\n }", "idx": 22573}
{"hash": -8933711118846965366, "project": "debian", "size": 41, "label": 0, "functionSource": "static void cirrus_vga_write_gr ( CirrusVGAState * s , unsigned reg_index , int reg_value ) {\n # if defined ( DEBUG_BITBLT ) && 0 printf ( \"gr%02x: %02x\\n\" , reg_index , reg_value ) ;\n # endif switch ( reg_index ) {\n case 0x00 : s -> vga . gr [ reg_index ] = reg_value & gr_mask [ reg_index ] ;\n s -> cirrus_shadow_gr0 = reg_value ;\n break ;\n case 0x01 : s -> vga . gr [ reg_index ] = reg_value & gr_mask [ reg_index ] ;\n s -> cirrus_shadow_gr1 = reg_value ;\n break ;\n case 0x02 : case 0x03 : case 0x04 : case 0x06 : case 0x07 : case 0x08 : s -> vga . gr [ reg_index ] = reg_value & gr_mask [ reg_index ] ;\n break ;\n case 0x05 : s -> vga . gr [ reg_index ] = reg_value & 0x7f ;\n cirrus_update_memory_access ( s ) ;\n break ;\n case 0x09 : case 0x0A : s -> vga . gr [ reg_index ] = reg_value ;\n cirrus_update_bank_ptr ( s , 0 ) ;\n cirrus_update_bank_ptr ( s , 1 ) ;\n cirrus_update_memory_access ( s ) ;\n break ;\n case 0x0B : s -> vga . gr [ reg_index ] = reg_value ;\n cirrus_update_bank_ptr ( s , 0 ) ;\n cirrus_update_bank_ptr ( s , 1 ) ;\n cirrus_update_memory_access ( s ) ;\n break ;\n case 0x10 : case 0x11 : case 0x12 : case 0x13 : case 0x14 : case 0x15 : case 0x20 : case 0x22 : case 0x24 : case 0x26 : case 0x28 : case 0x29 : case 0x2c : case 0x2d : case 0x2f : case 0x30 : case 0x32 : case 0x33 : case 0x34 : case 0x35 : case 0x38 : case 0x39 : s -> vga . gr [ reg_index ] = reg_value ;\n break ;\n case 0x21 : case 0x23 : case 0x25 : case 0x27 : s -> vga . gr [ reg_index ] = reg_value & 0x1f ;\n break ;\n case 0x2a : s -> vga . gr [ reg_index ] = reg_value & 0x3f ;\n if ( s -> vga . gr [ 0x31 ] & CIRRUS_BLT_AUTOSTART ) {\n cirrus_bitblt_start ( s ) ;\n }\n break ;\n case 0x2e : s -> vga . gr [ reg_index ] = reg_value & 0x3f ;\n break ;\n case 0x31 : cirrus_write_bitblt ( s , reg_value ) ;\n break ;\n default : # ifdef DEBUG_CIRRUS printf ( \"cirrus: outport gr_index %02x, gr_value %02x\\n\" , reg_index , reg_value ) ;\n # endif break ;\n }\n }", "idx": 22574}
{"hash": -3559021711340554904, "project": "debian", "size": 7, "label": 0, "functionSource": "void get_agg_clause_costs ( PlannerInfo * root , Node * clause , AggSplit aggsplit , AggClauseCosts * costs ) {\n get_agg_clause_costs_context context ;\n context . root = root ;\n context . aggsplit = aggsplit ;\n context . costs = costs ;\n ( void ) get_agg_clause_costs_walker ( clause , & context ) ;\n }", "idx": 22575}
{"hash": -3502382902740740634, "project": "debian", "size": 18, "label": 0, "functionSource": "static int diameterstat_packet ( void * pss , packet_info * pinfo , epan_dissect_t * edt _U_ , const void * prv ) {\n guint i = 0 ;\n srt_stat_table * diameter_srt_table ;\n srt_data_t * data = ( srt_data_t * ) pss ;\n const diameter_req_ans_pair_t * diameter = ( const diameter_req_ans_pair_t * ) prv ;\n int * idx = NULL ;\n if ( ! diameter || diameter -> processing_request || ! diameter -> req_frame ) return 0 ;\n diameter_srt_table = g_array_index ( data -> srt_array , srt_stat_table * , i ) ;\n idx = ( int * ) g_hash_table_lookup ( diameterstat_cmd_str_hash , diameter -> cmd_str ) ;\n if ( idx == NULL ) {\n idx = ( int * ) g_malloc ( sizeof ( int ) ) ;\n * idx = ( int ) g_hash_table_size ( diameterstat_cmd_str_hash ) ;\n g_hash_table_insert ( diameterstat_cmd_str_hash , ( gchar * ) diameter -> cmd_str , idx ) ;\n init_srt_table_row ( diameter_srt_table , * idx , ( const char * ) diameter -> cmd_str ) ;\n }\n add_srt_table_data ( diameter_srt_table , * idx , & diameter -> req_time , pinfo ) ;\n return 1 ;\n }", "idx": 22576}
{"hash": 1788300783882316916, "project": "debian", "size": 36, "label": 0, "functionSource": "void ff_fix_long_mvs ( MpegEncContext * s , uint8_t * field_select_table , int field_select , int16_t ( * mv_table ) [ 2 ] , int f_code , int type , int truncate ) {\n MotionEstContext * const c = & s -> me ;\n int y , h_range , v_range ;\n int range = ( ( ( s -> out_format == FMT_MPEG1 || s -> msmpeg4_version ) ? 8 : 16 ) << f_code ) ;\n if ( c -> avctx -> me_range && range > c -> avctx -> me_range ) range = c -> avctx -> me_range ;\n h_range = range ;\n v_range = field_select_table ? range >> 1 : range ;\n for ( y = 0 ;\n y < s -> mb_height ;\n y ++ ) {\n int x ;\n int xy = y * s -> mb_stride ;\n for ( x = 0 ;\n x < s -> mb_width ;\n x ++ ) {\n if ( s -> mb_type [ xy ] & type ) {\n if ( field_select_table == NULL || field_select_table [ xy ] == field_select ) {\n if ( mv_table [ xy ] [ 0 ] >= h_range || mv_table [ xy ] [ 0 ] < - h_range || mv_table [ xy ] [ 1 ] >= v_range || mv_table [ xy ] [ 1 ] < - v_range ) {\n if ( truncate ) {\n if ( mv_table [ xy ] [ 0 ] > h_range - 1 ) mv_table [ xy ] [ 0 ] = h_range - 1 ;\n else if ( mv_table [ xy ] [ 0 ] < - h_range ) mv_table [ xy ] [ 0 ] = - h_range ;\n if ( mv_table [ xy ] [ 1 ] > v_range - 1 ) mv_table [ xy ] [ 1 ] = v_range - 1 ;\n else if ( mv_table [ xy ] [ 1 ] < - v_range ) mv_table [ xy ] [ 1 ] = - v_range ;\n }\n else {\n s -> mb_type [ xy ] &= ~ type ;\n s -> mb_type [ xy ] |= CANDIDATE_MB_TYPE_INTRA ;\n mv_table [ xy ] [ 0 ] = mv_table [ xy ] [ 1 ] = 0 ;\n }\n }\n }\n }\n xy ++ ;\n }\n }\n }", "idx": 22577}
{"hash": -3281230495821979567, "project": "chrome", "size": 35, "label": 0, "functionSource": "int main ( int argc , char * * argv ) {\n int frame_cnt = 0 ;\n FILE * outfile = NULL ;\n vpx_codec_ctx_t codec ;\n VpxVideoReader * reader = NULL ;\n const VpxInterface * decoder = NULL ;\n const VpxVideoInfo * info = NULL ;\n exec_name = argv [ 0 ] ;\n if ( argc != 3 ) die ( \"Invalid number of arguments.\" ) ;\n reader = vpx_video_reader_open ( argv [ 1 ] ) ;\n if ( ! reader ) die ( \"Failed to open %s for reading.\" , argv [ 1 ] ) ;\n if ( ! ( outfile = fopen ( argv [ 2 ] , \"wb\" ) ) ) die ( \"Failed to open %s for writing.\" , argv [ 2 ] ) ;\n info = vpx_video_reader_get_info ( reader ) ;\n decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ;\n if ( ! decoder ) die ( \"Unknown input codec.\" ) ;\n printf ( \"Using %s\\n\" , vpx_codec_iface_name ( decoder -> codec_interface ( ) ) ) ;\n if ( vpx_codec_dec_init ( & codec , decoder -> codec_interface ( ) , NULL , 0 ) ) die_codec ( & codec , \"Failed to initialize decoder.\" ) ;\n while ( vpx_video_reader_read_frame ( reader ) ) {\n vpx_codec_iter_t iter = NULL ;\n vpx_image_t * img = NULL ;\n size_t frame_size = 0 ;\n const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ;\n if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , \"Failed to decode frame.\" ) ;\n while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) {\n vpx_img_write ( img , outfile ) ;\n ++ frame_cnt ;\n }\n }\n printf ( \"Processed %d frames.\\n\" , frame_cnt ) ;\n if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed to destroy codec\" ) ;\n printf ( \"Play: ffplay -f rawvideo -pix_fmt yuv420p -s %dx%d %s\\n\" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ;\n vpx_video_reader_close ( reader ) ;\n fclose ( outfile ) ;\n return EXIT_SUCCESS ;\n }", "idx": 22578}
{"hash": 6442032569499442758, "project": "chrome", "size": 10, "label": 0, "functionSource": "PREDICTION_MODE vp9_left_block_mode ( const MODE_INFO * cur_mi , const MODE_INFO * left_mi , int b ) {\n if ( b == 0 || b == 2 ) {\n if ( ! left_mi || is_inter_block ( & left_mi -> mbmi ) ) return DC_PRED ;\n return get_y_mode ( left_mi , b + 1 ) ;\n }\n else {\n assert ( b == 1 || b == 3 ) ;\n return cur_mi -> bmi [ b - 1 ] . as_mode ;\n }\n }", "idx": 22579}
{"hash": 2755982813601944893, "project": "debian", "size": 23, "label": 0, "functionSource": "static void dec_bark_env ( TwinContext * tctx , const uint8_t * in , int use_hist , int ch , float * out , float gain , enum FrameType ftype ) {\n const ModeTab * mtab = tctx -> mtab ;\n int i , j ;\n float * hist = tctx -> bark_hist [ ftype ] [ ch ] ;\n float val = ( ( const float [ ] ) {\n 0.4 , 0.35 , 0.28 }\n ) [ ftype ] ;\n int bark_n_coef = mtab -> fmode [ ftype ] . bark_n_coef ;\n int fw_cb_len = mtab -> fmode [ ftype ] . bark_env_size / bark_n_coef ;\n int idx = 0 ;\n for ( i = 0 ;\n i < fw_cb_len ;\n i ++ ) for ( j = 0 ;\n j < bark_n_coef ;\n j ++ , idx ++ ) {\n float tmp2 = mtab -> fmode [ ftype ] . bark_cb [ fw_cb_len * in [ j ] + i ] * ( 1. / 4096 ) ;\n float st = use_hist ? ( 1. - val ) * tmp2 + val * hist [ idx ] + 1. : tmp2 + 1. ;\n hist [ idx ] = tmp2 ;\n if ( st < - 1. ) st = 1. ;\n memset_float ( out , st * gain , mtab -> fmode [ ftype ] . bark_tab [ idx ] ) ;\n out += mtab -> fmode [ ftype ] . bark_tab [ idx ] ;\n }\n }", "idx": 22580}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_DepFECData ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_DepFECData , DepFECData_choice , NULL ) ;\n return offset ;\n }", "idx": 22581}
{"hash": 6415329349331062723, "project": "chrome", "size": 5, "label": 0, "functionSource": "static void terminate_chunked_client ( int fd , short event , void * arg ) {\n struct terminate_state * state = arg ;\n bufferevent_free ( state -> bev ) ;\n EVUTIL_CLOSESOCKET ( state -> fd ) ;\n }", "idx": 22582}
{"hash": 643387607984457432, "project": "debian", "size": 61, "label": 0, "functionSource": "static void aw_pulse_set2 ( WMAVoiceContext * s , GetBitContext * gb , int block_idx , AMRFixed * fcb ) {\n uint16_t use_mask_mem [ 9 ] ;\n uint16_t * use_mask = use_mask_mem + 2 ;\n int pulse_off = s -> aw_first_pulse_off [ block_idx ] , pulse_start , n , idx , range , aidx , start_off = 0 ;\n if ( s -> aw_n_pulses [ block_idx ] > 0 ) while ( pulse_off + s -> aw_pulse_range < 1 ) pulse_off += fcb -> pitch_lag ;\n if ( s -> aw_n_pulses [ 0 ] > 0 ) {\n if ( block_idx == 0 ) {\n range = 32 ;\n }\n else {\n range = 8 ;\n if ( s -> aw_n_pulses [ block_idx ] > 0 ) pulse_off = s -> aw_next_pulse_off_cache ;\n }\n }\n else range = 16 ;\n pulse_start = s -> aw_n_pulses [ block_idx ] > 0 ? pulse_off - range / 2 : 0 ;\n memset ( & use_mask [ - 2 ] , 0 , 2 * sizeof ( use_mask [ 0 ] ) ) ;\n memset ( use_mask , - 1 , 5 * sizeof ( use_mask [ 0 ] ) ) ;\n memset ( & use_mask [ 5 ] , 0 , 2 * sizeof ( use_mask [ 0 ] ) ) ;\n if ( s -> aw_n_pulses [ block_idx ] > 0 ) for ( idx = pulse_off ;\n idx < MAX_FRAMESIZE / 2 ;\n idx += fcb -> pitch_lag ) {\n int excl_range = s -> aw_pulse_range ;\n uint16_t * use_mask_ptr = & use_mask [ idx >> 4 ] ;\n int first_sh = 16 - ( idx & 15 ) ;\n * use_mask_ptr ++ &= 0xFFFFu << first_sh ;\n excl_range -= first_sh ;\n if ( excl_range >= 16 ) {\n * use_mask_ptr ++ = 0 ;\n * use_mask_ptr &= 0xFFFF >> ( excl_range - 16 ) ;\n }\n else * use_mask_ptr &= 0xFFFF >> excl_range ;\n }\n aidx = get_bits ( gb , s -> aw_n_pulses [ 0 ] > 0 ? 5 - 2 * block_idx : 4 ) ;\n for ( n = 0 ;\n n <= aidx ;\n pulse_start ++ ) {\n for ( idx = pulse_start ;\n idx < 0 ;\n idx += fcb -> pitch_lag ) ;\n if ( idx >= MAX_FRAMESIZE / 2 ) {\n if ( use_mask [ 0 ] ) idx = 0x0F ;\n else if ( use_mask [ 1 ] ) idx = 0x1F ;\n else if ( use_mask [ 2 ] ) idx = 0x2F ;\n else if ( use_mask [ 3 ] ) idx = 0x3F ;\n else if ( use_mask [ 4 ] ) idx = 0x4F ;\n else return ;\n idx -= av_log2_16bit ( use_mask [ idx >> 4 ] ) ;\n }\n if ( use_mask [ idx >> 4 ] & ( 0x8000 >> ( idx & 15 ) ) ) {\n use_mask [ idx >> 4 ] &= ~ ( 0x8000 >> ( idx & 15 ) ) ;\n n ++ ;\n start_off = idx ;\n }\n }\n fcb -> x [ fcb -> n ] = start_off ;\n fcb -> y [ fcb -> n ] = get_bits1 ( gb ) ? - 1.0 : 1.0 ;\n fcb -> n ++ ;\n n = ( MAX_FRAMESIZE / 2 - start_off ) % fcb -> pitch_lag ;\n s -> aw_next_pulse_off_cache = n ? fcb -> pitch_lag - n : 0 ;\n }", "idx": 22583}
{"hash": 6581530453642608175, "project": "chrome", "size": 14, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( ProfileBrowserTest , DISABLED_CreateOldProfileAsynchronous ) {\n base : : ScopedTempDir temp_dir ;\n ASSERT_TRUE ( temp_dir . CreateUniqueTempDir ( ) ) ;\n CreatePrefsFileInDirectory ( temp_dir . path ( ) ) ;\n MockProfileDelegate delegate ;\n EXPECT_CALL ( delegate , OnProfileCreated ( testing : : NotNull ( ) , true , false ) ) ;\n {\n content : : WindowedNotificationObserver observer ( chrome : : NOTIFICATION_PROFILE_CREATED , content : : NotificationService : : AllSources ( ) ) ;\n std : : unique_ptr < Profile > profile ( CreateProfile ( temp_dir . path ( ) , & delegate , Profile : : CREATE_MODE_ASYNCHRONOUS ) ) ;\n observer . Wait ( ) ;\n CheckChromeVersion ( profile . get ( ) , false ) ;\n }\n FlushIoTaskRunnerAndSpinThreads ( ) ;\n }", "idx": 22584}
{"hash": 4180964683905830761, "project": "debian", "size": 24, "label": 0, "functionSource": "static int selinux_sock_rcv_skb_compat ( struct sock * sk , struct sk_buff * skb , u16 family ) {\n int err = 0 ;\n struct sk_security_struct * sksec = sk -> sk_security ;\n u32 sk_sid = sksec -> sid ;\n struct common_audit_data ad ;\n struct lsm_network_audit net = {\n 0 , }\n ;\n char * addrp ;\n ad . type = LSM_AUDIT_DATA_NET ;\n ad . u . net = & net ;\n ad . u . net -> netif = skb -> skb_iif ;\n ad . u . net -> family = family ;\n err = selinux_parse_skb ( skb , & ad , & addrp , 1 , NULL ) ;\n if ( err ) return err ;\n if ( selinux_secmark_enabled ( ) ) {\n err = avc_has_perm ( sk_sid , skb -> secmark , SECCLASS_PACKET , PACKET__RECV , & ad ) ;\n if ( err ) return err ;\n }\n err = selinux_netlbl_sock_rcv_skb ( sksec , skb , family , & ad ) ;\n if ( err ) return err ;\n err = selinux_xfrm_sock_rcv_skb ( sksec -> sid , skb , & ad ) ;\n return err ;\n }", "idx": 22585}
{"hash": 2917602761308156638, "project": "debian", "size": 18, "label": 0, "functionSource": "Asn1Generic * DecodeDer ( const unsigned char * buffer , uint32_t size , uint32_t * errcode ) {\n const unsigned char * d_ptr = buffer ;\n uint32_t d_length , numbytes ;\n Asn1Generic * cert ;\n uint8_t c ;\n if ( d_ptr [ 0 ] != 0x30 && d_ptr [ 1 ] != 0x82 ) return NULL ;\n c = d_ptr [ 1 ] ;\n if ( ( c & ( 1 << 7 ) ) >> 7 != 1 ) return NULL ;\n numbytes = c & 0x7f ;\n d_ptr += 2 ;\n if ( DecodeAsn1BuildValue ( & d_ptr , & d_length , numbytes , errcode ) == - 1 ) {\n return NULL ;\n }\n if ( d_length + ( d_ptr - buffer ) != size ) return NULL ;\n if ( errcode ) * errcode = 0 ;\n cert = DecodeAsn1DerGeneric ( buffer , size , 0 , 0 , errcode ) ;\n return cert ;\n }", "idx": 22586}
{"hash": 6458694302493204858, "project": "debian", "size": 12, "label": 0, "functionSource": "static bool isAssignmentIndirectionExpr ( ExprState * exprstate ) {\n if ( exprstate == NULL ) return false ;\n if ( IsA ( exprstate , FieldStoreState ) ) {\n FieldStore * fstore = ( FieldStore * ) exprstate -> expr ;\n if ( fstore -> arg && IsA ( fstore -> arg , CaseTestExpr ) ) return true ;\n }\n else if ( IsA ( exprstate , ArrayRefExprState ) ) {\n ArrayRef * arrayRef = ( ArrayRef * ) exprstate -> expr ;\n if ( arrayRef -> refexpr && IsA ( arrayRef -> refexpr , CaseTestExpr ) ) return true ;\n }\n return false ;\n }", "idx": 22587}
{"hash": -2607754285145856562, "project": "debian", "size": 4, "label": 0, "functionSource": "static int isoent_cmp_key ( const struct archive_rb_node * n , const void * key ) {\n const struct isoent * e = ( const struct isoent * ) n ;\n return ( strcmp ( e -> file -> basename . s , ( const char * ) key ) ) ;\n }", "idx": 22588}
{"hash": 1353431100313404503, "project": "chrome", "size": 17, "label": 1, "functionSource": "static void predict_and_reconstruct_intra_block ( int plane , int block , BLOCK_SIZE plane_bsize , TX_SIZE tx_size , void * arg ) {\n struct intra_args * const args = ( struct intra_args * ) arg ;\n VP9_COMMON * const cm = args -> cm ;\n MACROBLOCKD * const xd = args -> xd ;\n struct macroblockd_plane * const pd = & xd -> plane [ plane ] ;\n MODE_INFO * const mi = xd -> mi [ 0 ] ;\n const PREDICTION_MODE mode = ( plane == 0 ) ? get_y_mode ( mi , block ) : mi -> mbmi . uv_mode ;\n int x , y ;\n uint8_t * dst ;\n txfrm_block_to_raster_xy ( plane_bsize , tx_size , block , & x , & y ) ;\n dst = & pd -> dst . buf [ 4 * y * pd -> dst . stride + 4 * x ] ;\n vp9_predict_intra_block ( xd , block >> ( tx_size << 1 ) , b_width_log2 ( plane_bsize ) , tx_size , mode , dst , pd -> dst . stride , dst , pd -> dst . stride , x , y , plane ) ;\n if ( ! mi -> mbmi . skip ) {\n const int eob = vp9_decode_block_tokens ( cm , xd , plane , block , plane_bsize , x , y , tx_size , args -> r ) ;\n inverse_transform_block ( xd , plane , block , tx_size , dst , pd -> dst . stride , eob ) ;\n }\n }", "idx": 22589}
{"hash": 7651945086108393719, "project": "debian", "size": 3, "label": 0, "functionSource": "int qemuMonitorJSONSaveVirtualMemory ( qemuMonitorPtr mon , unsigned long long offset , size_t length , const char * path ) {\n return qemuMonitorJSONSaveMemory ( mon , \"memsave\" , offset , length , path ) ;\n }", "idx": 22590}
{"hash": -6435087038712482873, "project": "debian", "size": 43, "label": 1, "functionSource": "static int mpeg_field_start ( MpegEncContext * s , const uint8_t * buf , int buf_size ) {\n AVCodecContext * avctx = s -> avctx ;\n Mpeg1Context * s1 = ( Mpeg1Context * ) s ;\n if ( s -> first_field || s -> picture_structure == PICT_FRAME ) {\n if ( ff_MPV_frame_start ( s , avctx ) < 0 ) return - 1 ;\n ff_mpeg_er_frame_start ( s ) ;\n s -> current_picture_ptr -> f . repeat_pict = 0 ;\n if ( s -> repeat_first_field ) {\n if ( s -> progressive_sequence ) {\n if ( s -> top_field_first ) s -> current_picture_ptr -> f . repeat_pict = 4 ;\n else s -> current_picture_ptr -> f . repeat_pict = 2 ;\n }\n else if ( s -> progressive_frame ) {\n s -> current_picture_ptr -> f . repeat_pict = 1 ;\n }\n }\n * s -> current_picture_ptr -> f . pan_scan = s1 -> pan_scan ;\n if ( HAVE_THREADS && ( avctx -> active_thread_type & FF_THREAD_FRAME ) ) ff_thread_finish_setup ( avctx ) ;\n }\n else {\n int i ;\n if ( ! s -> current_picture_ptr ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"first field missing\\n\" ) ;\n return - 1 ;\n }\n if ( s -> avctx -> hwaccel && ( s -> avctx -> slice_flags & SLICE_FLAG_ALLOW_FIELD ) ) {\n if ( s -> avctx -> hwaccel -> end_frame ( s -> avctx ) < 0 ) av_log ( avctx , AV_LOG_ERROR , \"hardware accelerator failed to decode first field\\n\" ) ;\n }\n for ( i = 0 ;\n i < 4 ;\n i ++ ) {\n s -> current_picture . f . data [ i ] = s -> current_picture_ptr -> f . data [ i ] ;\n if ( s -> picture_structure == PICT_BOTTOM_FIELD ) {\n s -> current_picture . f . data [ i ] += s -> current_picture_ptr -> f . linesize [ i ] ;\n }\n }\n }\n if ( avctx -> hwaccel ) {\n if ( avctx -> hwaccel -> start_frame ( avctx , buf , buf_size ) < 0 ) return - 1 ;\n }\n if ( CONFIG_MPEG_XVMC_DECODER && s -> avctx -> xvmc_acceleration ) if ( ff_xvmc_field_start ( s , avctx ) < 0 ) return - 1 ;\n return 0 ;\n }", "idx": 22591}
{"hash": 6790518433053241091, "project": "debian", "size": 10, "label": 0, "functionSource": "static void gtkui_connection_kill_curr_conn ( void ) {\n DEBUG_MSG ( \"gtkui_connection_kill_curr_conn\" ) ;\n switch ( user_kill ( curr_conn ) ) {\n case E_SUCCESS : curr_conn -> status = CONN_KILLED ;\n gtkui_message ( \"The connection was killed !!\" ) ;\n break ;\n case - E_FATAL : gtkui_message ( \"Cannot kill UDP connections !!\" ) ;\n break ;\n }\n }", "idx": 22592}
{"hash": -4341894042551388054, "project": "chrome", "size": 58, "label": 0, "functionSource": "static int combined_motion_search ( VP9_COMP * cpi , MACROBLOCK * x , BLOCK_SIZE bsize , int mi_row , int mi_col , int_mv * tmp_mv , int * rate_mv , int64_t best_rd_sofar ) {\n MACROBLOCKD * xd = & x -> e_mbd ;\n MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] . src_mi -> mbmi ;\n struct buf_2d backup_yv12 [ MAX_MB_PLANE ] = {\n {\n 0 , 0 }\n }\n ;\n const int step_param = cpi -> sf . mv . fullpel_search_step_param ;\n const int sadpb = x -> sadperbit16 ;\n MV mvp_full ;\n const int ref = mbmi -> ref_frame [ 0 ] ;\n const MV ref_mv = mbmi -> ref_mvs [ ref ] [ 0 ] . as_mv ;\n int dis ;\n int rate_mode ;\n const int tmp_col_min = x -> mv_col_min ;\n const int tmp_col_max = x -> mv_col_max ;\n const int tmp_row_min = x -> mv_row_min ;\n const int tmp_row_max = x -> mv_row_max ;\n int rv = 0 ;\n int sad_list [ 5 ] ;\n const YV12_BUFFER_CONFIG * scaled_ref_frame = vp9_get_scaled_ref_frame ( cpi , ref ) ;\n if ( cpi -> common . show_frame && ( x -> pred_mv_sad [ ref ] >> 3 ) > x -> pred_mv_sad [ LAST_FRAME ] ) return rv ;\n if ( scaled_ref_frame ) {\n int i ;\n for ( i = 0 ;\n i < MAX_MB_PLANE ;\n i ++ ) backup_yv12 [ i ] = xd -> plane [ i ] . pre [ 0 ] ;\n vp9_setup_pre_planes ( xd , 0 , scaled_ref_frame , mi_row , mi_col , NULL ) ;\n }\n vp9_set_mv_search_range ( x , & ref_mv ) ;\n assert ( x -> mv_best_ref_index [ ref ] <= 2 ) ;\n if ( x -> mv_best_ref_index [ ref ] < 2 ) mvp_full = mbmi -> ref_mvs [ ref ] [ x -> mv_best_ref_index [ ref ] ] . as_mv ;\n else mvp_full = x -> pred_mv [ ref ] ;\n mvp_full . col >>= 3 ;\n mvp_full . row >>= 3 ;\n vp9_full_pixel_search ( cpi , x , bsize , & mvp_full , step_param , sadpb , cond_sad_list ( cpi , sad_list ) , & ref_mv , & tmp_mv -> as_mv , INT_MAX , 0 ) ;\n x -> mv_col_min = tmp_col_min ;\n x -> mv_col_max = tmp_col_max ;\n x -> mv_row_min = tmp_row_min ;\n x -> mv_row_max = tmp_row_max ;\n mvp_full . row = tmp_mv -> as_mv . row * 8 ;\n mvp_full . col = tmp_mv -> as_mv . col * 8 ;\n * rate_mv = vp9_mv_bit_cost ( & mvp_full , & ref_mv , x -> nmvjointcost , x -> mvcost , MV_COST_WEIGHT ) ;\n rate_mode = cpi -> inter_mode_cost [ mbmi -> mode_context [ ref ] ] [ INTER_OFFSET ( NEWMV ) ] ;\n rv = ! ( RDCOST ( x -> rdmult , x -> rddiv , ( * rate_mv + rate_mode ) , 0 ) > best_rd_sofar ) ;\n if ( rv ) {\n cpi -> find_fractional_mv_step ( x , & tmp_mv -> as_mv , & ref_mv , cpi -> common . allow_high_precision_mv , x -> errorperbit , & cpi -> fn_ptr [ bsize ] , cpi -> sf . mv . subpel_force_stop , cpi -> sf . mv . subpel_iters_per_step , cond_sad_list ( cpi , sad_list ) , x -> nmvjointcost , x -> mvcost , & dis , & x -> pred_sse [ ref ] , NULL , 0 , 0 ) ;\n x -> pred_mv [ ref ] = tmp_mv -> as_mv ;\n }\n if ( scaled_ref_frame ) {\n int i ;\n for ( i = 0 ;\n i < MAX_MB_PLANE ;\n i ++ ) xd -> plane [ i ] . pre [ 0 ] = backup_yv12 [ i ] ;\n }\n return rv ;\n }", "idx": 22593}
{"hash": 4206838170759624883, "project": "debian", "size": 4, "label": 0, "functionSource": "static void termsig_handler ( int signum ) {\n atomic_cmpxchg ( & state , RUNNING , TERMINATE ) ;\n qemu_notify_event ( ) ;\n }", "idx": 22594}
{"hash": 313627013719508831, "project": "debian", "size": 13, "label": 0, "functionSource": "static inline MagickBooleanType IsPixelInfoEquivalent ( const PixelInfo * restrict p , const PixelInfo * restrict q ) {\n if ( ( p -> alpha_trait != UndefinedPixelTrait ) && ( q -> alpha_trait == UndefinedPixelTrait ) && ( AbsolutePixelValue ( p -> alpha - OpaqueAlpha ) >= MagickEpsilon ) ) return ( MagickFalse ) ;\n if ( ( q -> alpha_trait != UndefinedPixelTrait ) && ( p -> alpha_trait == UndefinedPixelTrait ) && ( AbsolutePixelValue ( q -> alpha - OpaqueAlpha ) ) >= MagickEpsilon ) return ( MagickFalse ) ;\n if ( ( p -> alpha_trait != UndefinedPixelTrait ) && ( q -> alpha_trait != UndefinedPixelTrait ) ) {\n if ( AbsolutePixelValue ( p -> alpha - q -> alpha ) >= MagickEpsilon ) return ( MagickFalse ) ;\n if ( AbsolutePixelValue ( p -> alpha - TransparentAlpha ) < MagickEpsilon ) return ( MagickTrue ) ;\n }\n if ( AbsolutePixelValue ( p -> red - q -> red ) >= MagickEpsilon ) return ( MagickFalse ) ;\n if ( AbsolutePixelValue ( p -> green - q -> green ) >= MagickEpsilon ) return ( MagickFalse ) ;\n if ( AbsolutePixelValue ( p -> blue - q -> blue ) >= MagickEpsilon ) return ( MagickFalse ) ;\n if ( ( p -> colorspace == CMYKColorspace ) && ( AbsolutePixelValue ( p -> black - q -> black ) >= MagickEpsilon ) ) return ( MagickFalse ) ;\n return ( MagickTrue ) ;\n }", "idx": 22595}
{"hash": -5268859819325807498, "project": "debian", "size": 36, "label": 0, "functionSource": "static void directory_count_start ( NautilusDirectory * directory , NautilusFile * file , gboolean * doing_io ) {\n DirectoryCountState * state ;\n GFile * location ;\n if ( directory -> details -> count_in_progress != NULL ) {\n * doing_io = TRUE ;\n return ;\n }\n if ( ! is_needy ( file , should_get_directory_count_now , REQUEST_DIRECTORY_COUNT ) ) {\n return ;\n }\n * doing_io = TRUE ;\n if ( ! nautilus_file_is_directory ( file ) ) {\n file -> details -> directory_count_is_up_to_date = TRUE ;\n file -> details -> directory_count_failed = FALSE ;\n file -> details -> got_directory_count = FALSE ;\n nautilus_directory_async_state_changed ( directory ) ;\n return ;\n }\n if ( ! async_job_start ( directory , \"directory count\" ) ) {\n return ;\n }\n state = g_new0 ( DirectoryCountState , 1 ) ;\n state -> count_file = file ;\n state -> directory = nautilus_directory_ref ( directory ) ;\n state -> cancellable = g_cancellable_new ( ) ;\n directory -> details -> count_in_progress = state ;\n location = nautilus_file_get_location ( file ) ;\n # ifdef DEBUG_LOAD_DIRECTORY {\n char * uri ;\n uri = g_file_get_uri ( location ) ;\n g_message ( \"load_directory called to get shallow file count for %s\" , uri ) ;\n g_free ( uri ) ;\n }\n # endif g_file_enumerate_children_async ( location , G_FILE_ATTRIBUTE_STANDARD_NAME \",\" G_FILE_ATTRIBUTE_STANDARD_IS_HIDDEN \",\" G_FILE_ATTRIBUTE_STANDARD_IS_BACKUP , G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS , G_PRIORITY_DEFAULT , state -> cancellable , count_children_callback , state ) ;\n g_object_unref ( location ) ;\n }", "idx": 22596}
{"hash": -6024601983167898950, "project": "debian", "size": 6, "label": 0, "functionSource": "static void list_to_parameters_foreach ( GAppInfo * application , GList * uris , GList * * ret ) {\n ApplicationLaunchParameters * parameters ;\n uris = g_list_reverse ( uris ) ;\n parameters = application_launch_parameters_new ( application , uris ) ;\n * ret = g_list_prepend ( * ret , parameters ) ;\n }", "idx": 22597}
{"hash": -7775977291865552483, "project": "debian", "size": 16, "label": 0, "functionSource": "int qemuAssignDeviceNetAlias ( virDomainDefPtr def , virDomainNetDefPtr net , int idx ) {\n if ( networkGetActualType ( net ) == VIR_DOMAIN_NET_TYPE_HOSTDEV ) return qemuAssignDeviceHostdevAlias ( def , & net -> info . alias , - 1 ) ;\n if ( idx == - 1 ) {\n size_t i ;\n idx = 0 ;\n for ( i = 0 ;\n i < def -> nnets ;\n i ++ ) {\n int thisidx ;\n if ( ( thisidx = qemuDomainDeviceAliasIndex ( & def -> nets [ i ] -> info , \"net\" ) ) < 0 ) continue ;\n if ( thisidx >= idx ) idx = thisidx + 1 ;\n }\n }\n if ( virAsprintf ( & net -> info . alias , \"net%d\" , idx ) < 0 ) return - 1 ;\n return 0 ;\n }", "idx": 22598}
{"hash": 1676654288894940649, "project": "debian", "size": 4, "label": 0, "functionSource": "static krb5_error_code create_princ ( kadm5_principal_ent_rec * princ , long mask , int n_ks , krb5_key_salt_tuple * ks , char * pass ) {\n if ( ks ) return kadm5_create_principal_3 ( handle , princ , mask , n_ks , ks , pass ) ;\n else return kadm5_create_principal ( handle , princ , mask , pass ) ;\n }", "idx": 22599}
{"hash": -2423144171479606949, "project": "debian", "size": 4, "label": 0, "functionSource": "static void pdf_run_q ( fz_context * ctx , pdf_processor * proc ) {\n pdf_run_processor * pr = ( pdf_run_processor * ) proc ;\n pdf_gsave ( ctx , pr ) ;\n }", "idx": 22600}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_T_mCTerminalIDResponse ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_T_mCTerminalIDResponse , T_mCTerminalIDResponse_sequence ) ;\n return offset ;\n }", "idx": 22601}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_T_adaptationLayerType ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_T_adaptationLayerType , T_adaptationLayerType_choice , NULL ) ;\n return offset ;\n }", "idx": 22602}
{"hash": 1742637512846796448, "project": "debian", "size": 16, "label": 0, "functionSource": "static int dissect_mac_fdd_pch ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , void * data ) {\n proto_tree * pch_tree = NULL ;\n proto_item * channel_type ;\n col_set_str ( pinfo -> cinfo , COL_PROTOCOL , \"MAC\" ) ;\n col_set_str ( pinfo -> cinfo , COL_INFO , \"PCCH\" ) ;\n if ( tree ) {\n proto_item * ti ;\n ti = proto_tree_add_item ( tree , proto_umts_mac , tvb , 0 , - 1 , ENC_NA ) ;\n pch_tree = proto_item_add_subtree ( ti , ett_mac_pch ) ;\n proto_item_append_text ( ti , \" (PCCH)\" ) ;\n channel_type = proto_tree_add_uint ( pch_tree , hf_mac_channel , tvb , 0 , 0 , MAC_PCCH ) ;\n PROTO_ITEM_SET_GENERATED ( channel_type ) ;\n }\n call_dissector_with_data ( rlc_pcch_handle , tvb , pinfo , tree , data ) ;\n return tvb_captured_length ( tvb ) ;\n }", "idx": 22603}
{"hash": -2943582541244387919, "project": "chrome", "size": 43, "label": 0, "functionSource": "unsigned int vp9_sub_pixel_variance ## W ## x ## H ## _c ( const uint8_t * src , int src_stride , int xoffset , int yoffset , const uint8_t * dst , int dst_stride , unsigned int * sse ) {\n uint16_t fdata3 [ ( H + 1 ) * W ] ;\n uint8_t temp2 [ H * W ] ;\n var_filter_block2d_bil_first_pass ( src , fdata3 , src_stride , 1 , H + 1 , W , BILINEAR_FILTERS_2TAP ( xoffset ) ) ;\n var_filter_block2d_bil_second_pass ( fdata3 , temp2 , W , W , H , W , BILINEAR_FILTERS_2TAP ( yoffset ) ) ;\n return vp9_variance ## W ## x ## H ## _c ( temp2 , W , dst , dst_stride , sse ) ;\n \\ }\n # define SUBPIX_AVG_VAR ( W , H ) unsigned int vp9_sub_pixel_avg_variance ## W ## x ## H ## _c ( const uint8_t * src , int src_stride , int xoffset , int yoffset , const uint8_t * dst , int dst_stride , unsigned int * sse , const uint8_t * second_pred ) {\n uint16_t fdata3 [ ( H + 1 ) * W ] ;\n uint8_t temp2 [ H * W ] ;\n DECLARE_ALIGNED_ARRAY ( 16 , uint8_t , temp3 , H * W ) ;\n var_filter_block2d_bil_first_pass ( src , fdata3 , src_stride , 1 , H + 1 , W , BILINEAR_FILTERS_2TAP ( xoffset ) ) ;\n var_filter_block2d_bil_second_pass ( fdata3 , temp2 , W , W , H , W , BILINEAR_FILTERS_2TAP ( yoffset ) ) ;\n vp9_comp_avg_pred ( temp3 , second_pred , W , H , temp2 , W ) ;\n return vp9_variance ## W ## x ## H ## _c ( temp3 , W , dst , dst_stride , sse ) ;\n \\ }\n void vp9_get16x16var_c ( const uint8_t * src_ptr , int source_stride , const uint8_t * ref_ptr , int ref_stride , unsigned int * sse , int * sum ) {\n variance ( src_ptr , source_stride , ref_ptr , ref_stride , 16 , 16 , sse , sum ) ;\n }\n void vp9_get8x8var_c ( const uint8_t * src_ptr , int source_stride , const uint8_t * ref_ptr , int ref_stride , unsigned int * sse , int * sum ) {\n variance ( src_ptr , source_stride , ref_ptr , ref_stride , 8 , 8 , sse , sum ) ;\n }\n unsigned int vp9_mse16x16_c ( const uint8_t * src , int src_stride , const uint8_t * ref , int ref_stride , unsigned int * sse ) {\n int sum ;\n variance ( src , src_stride , ref , ref_stride , 16 , 16 , sse , & sum ) ;\n return * sse ;\n }\n unsigned int vp9_mse16x8_c ( const uint8_t * src , int src_stride , const uint8_t * ref , int ref_stride , unsigned int * sse ) {\n int sum ;\n variance ( src , src_stride , ref , ref_stride , 16 , 8 , sse , & sum ) ;\n return * sse ;\n }\n unsigned int vp9_mse8x16_c ( const uint8_t * src , int src_stride , const uint8_t * ref , int ref_stride , unsigned int * sse ) {\n int sum ;\n variance ( src , src_stride , ref , ref_stride , 8 , 16 , sse , & sum ) ;\n return * sse ;\n }\n unsigned int vp9_mse8x8_c ( const uint8_t * src , int src_stride , const uint8_t * ref , int ref_stride , unsigned int * sse ) {\n int sum ;\n variance ( src , src_stride , ref , ref_stride , 8 , 8 , sse , & sum ) ;\n return * sse ;\n }\n VAR ( 4 , 4 ) SUBPIX_VAR ( 4 , 4 ) SUBPIX_AVG_VAR ( 4 , 4 ) VAR ( 4 , 8 ) SUBPIX_VAR ( 4 , 8 ) SUBPIX_AVG_VAR ( 4 , 8 ) VAR ( 8 , 4 ) SUBPIX_VAR ( 8 , 4 ) SUBPIX_AVG_VAR ( 8 , 4 ) VAR ( 8 , 8 ) SUBPIX_VAR ( 8 , 8 )", "idx": 22604}
{"hash": 2447070537606626244, "project": "debian", "size": 250, "label": 1, "functionSource": "int ParseCaffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) {\n uint32_t chan_chunk = 0 , channel_layout = 0 , bcount ;\n unsigned char * channel_identities = NULL ;\n unsigned char * channel_reorder = NULL ;\n int64_t total_samples = 0 , infilesize ;\n CAFFileHeader caf_file_header ;\n CAFChunkHeader caf_chunk_header ;\n CAFAudioFormat caf_audio_format ;\n int i ;\n infilesize = DoGetFileSize ( infile ) ;\n memcpy ( & caf_file_header , fourcc , 4 ) ;\n if ( ( ! DoReadFile ( infile , ( ( char * ) & caf_file_header ) + 4 , sizeof ( CAFFileHeader ) - 4 , & bcount ) || bcount != sizeof ( CAFFileHeader ) - 4 ) ) {\n error_line ( \"%s is not a valid .CAF file!\" , infilename ) ;\n return WAVPACK_SOFT_ERROR ;\n }\n else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & caf_file_header , sizeof ( CAFFileHeader ) ) ) {\n error_line ( \"%s\" , WavpackGetErrorMessage ( wpc ) ) ;\n return WAVPACK_SOFT_ERROR ;\n }\n WavpackBigEndianToNative ( & caf_file_header , CAFFileHeaderFormat ) ;\n if ( caf_file_header . mFileVersion != 1 ) {\n error_line ( \"%s: can't handle version %d .CAF files!\" , infilename , caf_file_header . mFileVersion ) ;\n return WAVPACK_SOFT_ERROR ;\n }\n while ( 1 ) {\n if ( ! DoReadFile ( infile , & caf_chunk_header , sizeof ( CAFChunkHeader ) , & bcount ) || bcount != sizeof ( CAFChunkHeader ) ) {\n error_line ( \"%s is not a valid .CAF file!\" , infilename ) ;\n return WAVPACK_SOFT_ERROR ;\n }\n else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & caf_chunk_header , sizeof ( CAFChunkHeader ) ) ) {\n error_line ( \"%s\" , WavpackGetErrorMessage ( wpc ) ) ;\n return WAVPACK_SOFT_ERROR ;\n }\n WavpackBigEndianToNative ( & caf_chunk_header , CAFChunkHeaderFormat ) ;\n if ( ! strncmp ( caf_chunk_header . mChunkType , \"desc\" , 4 ) ) {\n int supported = TRUE ;\n if ( caf_chunk_header . mChunkSize != sizeof ( CAFAudioFormat ) || ! DoReadFile ( infile , & caf_audio_format , ( uint32_t ) caf_chunk_header . mChunkSize , & bcount ) || bcount != caf_chunk_header . mChunkSize ) {\n error_line ( \"%s is not a valid .CAF file!\" , infilename ) ;\n return WAVPACK_SOFT_ERROR ;\n }\n else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & caf_audio_format , ( uint32_t ) caf_chunk_header . mChunkSize ) ) {\n error_line ( \"%s\" , WavpackGetErrorMessage ( wpc ) ) ;\n return WAVPACK_SOFT_ERROR ;\n }\n WavpackBigEndianToNative ( & caf_audio_format , CAFAudioFormatFormat ) ;\n if ( debug_logging_mode ) {\n char formatstr [ 5 ] ;\n memcpy ( formatstr , caf_audio_format . mFormatID , 4 ) ;\n formatstr [ 4 ] = 0 ;\n error_line ( \"format = %s, flags = %x, sampling rate = %g\" , formatstr , caf_audio_format . mFormatFlags , caf_audio_format . mSampleRate ) ;\n error_line ( \"packet = %d bytes and %d frames\" , caf_audio_format . mBytesPerPacket , caf_audio_format . mFramesPerPacket ) ;\n error_line ( \"channels per frame = %d, bits per channel = %d\" , caf_audio_format . mChannelsPerFrame , caf_audio_format . mBitsPerChannel ) ;\n }\n if ( strncmp ( caf_audio_format . mFormatID , \"lpcm\" , 4 ) || ( caf_audio_format . mFormatFlags & ~ 3 ) ) supported = FALSE ;\n else if ( caf_audio_format . mSampleRate < 1.0 || caf_audio_format . mSampleRate > 16777215.0 || caf_audio_format . mSampleRate != floor ( caf_audio_format . mSampleRate ) ) supported = FALSE ;\n else if ( ! caf_audio_format . mChannelsPerFrame || caf_audio_format . mChannelsPerFrame > 256 ) supported = FALSE ;\n else if ( caf_audio_format . mBitsPerChannel < 1 || caf_audio_format . mBitsPerChannel > 32 || ( ( caf_audio_format . mFormatFlags & CAF_FORMAT_FLOAT ) && caf_audio_format . mBitsPerChannel != 32 ) ) supported = FALSE ;\n else if ( caf_audio_format . mFramesPerPacket != 1 || caf_audio_format . mBytesPerPacket / caf_audio_format . mChannelsPerFrame < ( caf_audio_format . mBitsPerChannel + 7 ) / 8 || caf_audio_format . mBytesPerPacket / caf_audio_format . mChannelsPerFrame > 4 || caf_audio_format . mBytesPerPacket % caf_audio_format . mChannelsPerFrame ) supported = FALSE ;\n if ( ! supported ) {\n error_line ( \"%s is an unsupported .CAF format!\" , infilename ) ;\n return WAVPACK_SOFT_ERROR ;\n }\n config -> bytes_per_sample = caf_audio_format . mBytesPerPacket / caf_audio_format . mChannelsPerFrame ;\n config -> float_norm_exp = ( caf_audio_format . mFormatFlags & CAF_FORMAT_FLOAT ) ? 127 : 0 ;\n config -> bits_per_sample = caf_audio_format . mBitsPerChannel ;\n config -> num_channels = caf_audio_format . mChannelsPerFrame ;\n config -> sample_rate = ( int ) caf_audio_format . mSampleRate ;\n if ( ! ( caf_audio_format . mFormatFlags & CAF_FORMAT_LITTLE_ENDIAN ) && config -> bytes_per_sample > 1 ) config -> qmode |= QMODE_BIG_ENDIAN ;\n if ( config -> bytes_per_sample == 1 ) config -> qmode |= QMODE_SIGNED_BYTES ;\n if ( debug_logging_mode ) {\n if ( config -> float_norm_exp == 127 ) error_line ( \"data format: 32-bit %s-endian floating point\" , ( config -> qmode & QMODE_BIG_ENDIAN ) ? \"big\" : \"little\" ) ;\n else error_line ( \"data format: %d-bit %s-endian integers stored in %d byte(s)\" , config -> bits_per_sample , ( config -> qmode & QMODE_BIG_ENDIAN ) ? \"big\" : \"little\" , config -> bytes_per_sample ) ;\n }\n }\n else if ( ! strncmp ( caf_chunk_header . mChunkType , \"chan\" , 4 ) ) {\n CAFChannelLayout * caf_channel_layout = malloc ( ( size_t ) caf_chunk_header . mChunkSize ) ;\n if ( caf_chunk_header . mChunkSize < sizeof ( CAFChannelLayout ) || ! DoReadFile ( infile , caf_channel_layout , ( uint32_t ) caf_chunk_header . mChunkSize , & bcount ) || bcount != caf_chunk_header . mChunkSize ) {\n error_line ( \"%s is not a valid .CAF file!\" , infilename ) ;\n free ( caf_channel_layout ) ;\n return WAVPACK_SOFT_ERROR ;\n }\n else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , caf_channel_layout , ( uint32_t ) caf_chunk_header . mChunkSize ) ) {\n error_line ( \"%s\" , WavpackGetErrorMessage ( wpc ) ) ;\n free ( caf_channel_layout ) ;\n return WAVPACK_SOFT_ERROR ;\n }\n WavpackBigEndianToNative ( caf_channel_layout , CAFChannelLayoutFormat ) ;\n chan_chunk = 1 ;\n if ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) {\n error_line ( \"this CAF file already has channel order information!\" ) ;\n free ( caf_channel_layout ) ;\n return WAVPACK_SOFT_ERROR ;\n }\n switch ( caf_channel_layout -> mChannelLayoutTag ) {\n case kCAFChannelLayoutTag_UseChannelDescriptions : {\n CAFChannelDescription * descriptions = ( CAFChannelDescription * ) ( caf_channel_layout + 1 ) ;\n int num_descriptions = caf_channel_layout -> mNumberChannelDescriptions ;\n int label , cindex = 0 , idents = 0 ;\n if ( caf_chunk_header . mChunkSize != sizeof ( CAFChannelLayout ) + sizeof ( CAFChannelDescription ) * num_descriptions || num_descriptions != config -> num_channels ) {\n error_line ( \"channel descriptions in 'chan' chunk are the wrong size!\" ) ;\n free ( caf_channel_layout ) ;\n return WAVPACK_SOFT_ERROR ;\n }\n if ( num_descriptions >= 256 ) {\n error_line ( \"%d channel descriptions is more than we can handle...ignoring!\" ) ;\n break ;\n }\n channel_reorder = malloc ( num_descriptions ) ;\n memset ( channel_reorder , - 1 , num_descriptions ) ;\n channel_identities = malloc ( num_descriptions + 1 ) ;\n for ( i = 0 ;\n i < num_descriptions ;\n ++ i ) {\n WavpackBigEndianToNative ( descriptions + i , CAFChannelDescriptionFormat ) ;\n if ( debug_logging_mode ) error_line ( \"chan %d --> %d\" , i + 1 , descriptions [ i ] . mChannelLabel ) ;\n }\n for ( label = 1 ;\n label <= 18 ;\n ++ label ) for ( i = 0 ;\n i < num_descriptions ;\n ++ i ) if ( descriptions [ i ] . mChannelLabel == label ) {\n config -> channel_mask |= 1 << ( label - 1 ) ;\n channel_reorder [ i ] = cindex ++ ;\n break ;\n }\n for ( i = 0 ;\n i < num_descriptions ;\n ++ i ) if ( channel_reorder [ i ] == ( unsigned char ) - 1 ) {\n uint32_t clabel = descriptions [ i ] . mChannelLabel ;\n if ( clabel == 0 || clabel == 0xffffffff || clabel == 100 ) channel_identities [ idents ++ ] = 0xff ;\n else if ( ( clabel >= 33 && clabel <= 44 ) || ( clabel >= 200 && clabel <= 207 ) || ( clabel >= 301 && clabel <= 305 ) ) channel_identities [ idents ++ ] = clabel >= 301 ? clabel - 80 : clabel ;\n else {\n error_line ( \"warning: unknown channel descriptions label: %d\" , clabel ) ;\n channel_identities [ idents ++ ] = 0xff ;\n }\n channel_reorder [ i ] = cindex ++ ;\n }\n for ( i = 0 ;\n i < num_descriptions ;\n ++ i ) if ( channel_reorder [ i ] != i ) break ;\n if ( i == num_descriptions ) {\n free ( channel_reorder ) ;\n channel_reorder = NULL ;\n }\n else {\n config -> qmode |= QMODE_REORDERED_CHANS ;\n channel_layout = num_descriptions ;\n }\n if ( ! idents ) {\n free ( channel_identities ) ;\n channel_identities = NULL ;\n }\n else channel_identities [ idents ] = 0 ;\n if ( debug_logging_mode ) {\n error_line ( \"layout_tag = 0x%08x, so generated bitmap of 0x%08x from %d descriptions, %d non-MS\" , caf_channel_layout -> mChannelLayoutTag , config -> channel_mask , caf_channel_layout -> mNumberChannelDescriptions , idents ) ;\n if ( channel_reorder && num_descriptions <= 8 ) {\n char reorder_string [ ] = \"12345678\" ;\n for ( i = 0 ;\n i < num_descriptions ;\n ++ i ) reorder_string [ i ] = channel_reorder [ i ] + '1' ;\n reorder_string [ i ] = 0 ;\n error_line ( \"reordering string = \\\"%s\\\"\\n\" , reorder_string ) ;\n }\n }\n }\n break ;\n case kCAFChannelLayoutTag_UseChannelBitmap : config -> channel_mask = caf_channel_layout -> mChannelBitmap ;\n if ( debug_logging_mode ) error_line ( \"layout_tag = 0x%08x, so using supplied bitmap of 0x%08x\" , caf_channel_layout -> mChannelLayoutTag , caf_channel_layout -> mChannelBitmap ) ;\n break ;\n default : for ( i = 0 ;\n i < NUM_LAYOUTS ;\n ++ i ) if ( caf_channel_layout -> mChannelLayoutTag == layouts [ i ] . mChannelLayoutTag ) {\n config -> channel_mask = layouts [ i ] . mChannelBitmap ;\n channel_layout = layouts [ i ] . mChannelLayoutTag ;\n if ( layouts [ i ] . mChannelReorder ) {\n channel_reorder = ( unsigned char * ) strdup ( layouts [ i ] . mChannelReorder ) ;\n config -> qmode |= QMODE_REORDERED_CHANS ;\n }\n if ( layouts [ i ] . mChannelIdentities ) channel_identities = ( unsigned char * ) strdup ( layouts [ i ] . mChannelIdentities ) ;\n if ( debug_logging_mode ) error_line ( \"layout_tag 0x%08x found in table, bitmap = 0x%08x, reorder = %s, identities = %s\" , channel_layout , config -> channel_mask , channel_reorder ? \"yes\" : \"no\" , channel_identities ? \"yes\" : \"no\" ) ;\n break ;\n }\n if ( i == NUM_LAYOUTS && debug_logging_mode ) error_line ( \"layout_tag 0x%08x not found in table...all channels unassigned\" , caf_channel_layout -> mChannelLayoutTag ) ;\n break ;\n }\n free ( caf_channel_layout ) ;\n }\n else if ( ! strncmp ( caf_chunk_header . mChunkType , \"data\" , 4 ) ) {\n uint32_t mEditCount ;\n if ( ! DoReadFile ( infile , & mEditCount , sizeof ( mEditCount ) , & bcount ) || bcount != sizeof ( mEditCount ) ) {\n error_line ( \"%s is not a valid .CAF file!\" , infilename ) ;\n return WAVPACK_SOFT_ERROR ;\n }\n else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & mEditCount , sizeof ( mEditCount ) ) ) {\n error_line ( \"%s\" , WavpackGetErrorMessage ( wpc ) ) ;\n return WAVPACK_SOFT_ERROR ;\n }\n if ( ( config -> qmode & QMODE_IGNORE_LENGTH ) || caf_chunk_header . mChunkSize == - 1 ) {\n config -> qmode |= QMODE_IGNORE_LENGTH ;\n if ( infilesize && DoGetFilePosition ( infile ) != - 1 ) total_samples = ( infilesize - DoGetFilePosition ( infile ) ) / caf_audio_format . mBytesPerPacket ;\n else total_samples = - 1 ;\n }\n else {\n if ( infilesize && infilesize - caf_chunk_header . mChunkSize > 16777216 ) {\n error_line ( \".CAF file %s has over 16 MB of extra CAFF data, probably is corrupt!\" , infilename ) ;\n return WAVPACK_SOFT_ERROR ;\n }\n if ( ( caf_chunk_header . mChunkSize - 4 ) % caf_audio_format . mBytesPerPacket ) {\n error_line ( \".CAF file %s has an invalid data chunk size, probably is corrupt!\" , infilename ) ;\n return WAVPACK_SOFT_ERROR ;\n }\n total_samples = ( caf_chunk_header . mChunkSize - 4 ) / caf_audio_format . mBytesPerPacket ;\n if ( ! total_samples ) {\n error_line ( \"this .CAF file has no audio samples, probably is corrupt!\" ) ;\n return WAVPACK_SOFT_ERROR ;\n }\n if ( total_samples > MAX_WAVPACK_SAMPLES ) {\n error_line ( \"%s has too many samples for WavPack!\" , infilename ) ;\n return WAVPACK_SOFT_ERROR ;\n }\n }\n break ;\n }\n else {\n int bytes_to_copy = ( uint32_t ) caf_chunk_header . mChunkSize ;\n char * buff = malloc ( bytes_to_copy ) ;\n if ( debug_logging_mode ) error_line ( \"extra unknown chunk \\\"%c%c%c%c\\\" of %d bytes\" , caf_chunk_header . mChunkType [ 0 ] , caf_chunk_header . mChunkType [ 1 ] , caf_chunk_header . mChunkType [ 2 ] , caf_chunk_header . mChunkType [ 3 ] , caf_chunk_header . mChunkSize ) ;\n if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || bcount != bytes_to_copy || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) {\n error_line ( \"%s\" , WavpackGetErrorMessage ( wpc ) ) ;\n free ( buff ) ;\n return WAVPACK_SOFT_ERROR ;\n }\n free ( buff ) ;\n }\n }\n if ( ! chan_chunk && ! config -> channel_mask && config -> num_channels <= 2 && ! ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) config -> channel_mask = 0x5 - config -> num_channels ;\n if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , channel_identities ) ) {\n error_line ( \"%s\" , WavpackGetErrorMessage ( wpc ) ) ;\n return WAVPACK_SOFT_ERROR ;\n }\n if ( channel_identities ) free ( channel_identities ) ;\n if ( channel_layout || channel_reorder ) {\n if ( ! WavpackSetChannelLayout ( wpc , channel_layout , channel_reorder ) ) {\n error_line ( \"problem with setting channel layout (should not happen)\" ) ;\n return WAVPACK_SOFT_ERROR ;\n }\n if ( channel_reorder ) free ( channel_reorder ) ;\n }\n return WAVPACK_NO_ERROR ;\n }", "idx": 22605}
{"hash": -8503439282031333562, "project": "debian", "size": 135, "label": 0, "functionSource": "int tmx_check_pretran ( sip_msg_t * msg ) {\n unsigned int chid ;\n unsigned int slotid ;\n int dsize ;\n struct via_param * vbr ;\n str scallid ;\n str scseqmet ;\n str scseqnum ;\n str sftag ;\n str svbranch = {\n NULL , 0 }\n ;\n pretran_t * it ;\n if ( _tmx_ptran_table == NULL ) {\n LM_ERR ( \"pretran hash table not initialized yet\\n\" ) ;\n return - 1 ;\n }\n if ( get_route_type ( ) != REQUEST_ROUTE ) {\n LM_ERR ( \"invalid usage - not in request route\\n\" ) ;\n return - 1 ;\n }\n if ( msg -> first_line . type != SIP_REQUEST ) {\n LM_ERR ( \"invalid usage - not a sip request\\n\" ) ;\n return - 1 ;\n }\n if ( parse_headers ( msg , HDR_FROM_F | HDR_VIA1_F | HDR_CALLID_F | HDR_CSEQ_F , 0 ) < 0 ) {\n LM_ERR ( \"failed to parse required headers\\n\" ) ;\n return - 1 ;\n }\n if ( msg -> cseq == NULL || msg -> cseq -> parsed == NULL ) {\n LM_ERR ( \"failed to parse cseq headers\\n\" ) ;\n return - 1 ;\n }\n if ( get_cseq ( msg ) -> method_id == METHOD_ACK || get_cseq ( msg ) -> method_id == METHOD_CANCEL ) {\n LM_DBG ( \"no pre-transaction management for ACK or CANCEL\\n\" ) ;\n return - 1 ;\n }\n if ( msg -> via1 == 0 ) {\n LM_ERR ( \"failed to get Via header\\n\" ) ;\n return - 1 ;\n }\n if ( parse_from_header ( msg ) < 0 || get_from ( msg ) -> tag_value . len == 0 ) {\n LM_ERR ( \"failed to get From header\\n\" ) ;\n return - 1 ;\n }\n if ( msg -> callid == NULL || msg -> callid -> body . s == NULL ) {\n LM_ERR ( \"failed to parse callid headers\\n\" ) ;\n return - 1 ;\n }\n vbr = msg -> via1 -> branch ;\n scallid = msg -> callid -> body ;\n trim ( & scallid ) ;\n scseqmet = get_cseq ( msg ) -> method ;\n trim ( & scseqmet ) ;\n scseqnum = get_cseq ( msg ) -> number ;\n trim ( & scseqnum ) ;\n sftag = get_from ( msg ) -> tag_value ;\n trim ( & sftag ) ;\n chid = get_hash1_raw ( msg -> callid -> body . s , msg -> callid -> body . len ) ;\n slotid = chid & ( _tmx_ptran_size - 1 ) ;\n if ( unlikely ( _tmx_proc_ptran == NULL ) ) {\n _tmx_proc_ptran = ( pretran_t * ) shm_malloc ( sizeof ( pretran_t ) ) ;\n if ( _tmx_proc_ptran == NULL ) {\n LM_ERR ( \"not enough memory for pretran structure\\n\" ) ;\n return - 1 ;\n }\n memset ( _tmx_proc_ptran , 0 , sizeof ( pretran_t ) ) ;\n _tmx_proc_ptran -> pid = my_pid ( ) ;\n }\n dsize = scallid . len + scseqnum . len + scseqmet . len + sftag . len + 4 ;\n if ( likely ( vbr != NULL ) ) {\n svbranch = vbr -> value ;\n trim ( & svbranch ) ;\n dsize += svbranch . len + 1 ;\n }\n if ( dsize < 256 ) dsize = 256 ;\n tmx_pretran_unlink ( ) ;\n if ( dsize > _tmx_proc_ptran -> dbuf . len ) {\n if ( _tmx_proc_ptran -> dbuf . s ) shm_free ( _tmx_proc_ptran -> dbuf . s ) ;\n _tmx_proc_ptran -> dbuf . s = ( char * ) shm_malloc ( dsize ) ;\n if ( _tmx_proc_ptran -> dbuf . s == NULL ) {\n LM_ERR ( \"not enough memory for pretran data\\n\" ) ;\n return - 1 ;\n }\n _tmx_proc_ptran -> dbuf . len = dsize ;\n }\n _tmx_proc_ptran -> hid = chid ;\n _tmx_proc_ptran -> cseqmetid = ( get_cseq ( msg ) ) -> method_id ;\n _tmx_proc_ptran -> callid . s = _tmx_proc_ptran -> dbuf . s ;\n memcpy ( _tmx_proc_ptran -> callid . s , scallid . s , scallid . len ) ;\n _tmx_proc_ptran -> callid . len = scallid . len ;\n _tmx_proc_ptran -> callid . s [ _tmx_proc_ptran -> callid . len ] = '\\0' ;\n _tmx_proc_ptran -> ftag . s = _tmx_proc_ptran -> callid . s + _tmx_proc_ptran -> callid . len + 1 ;\n memcpy ( _tmx_proc_ptran -> ftag . s , sftag . s , sftag . len ) ;\n _tmx_proc_ptran -> ftag . len = sftag . len ;\n _tmx_proc_ptran -> ftag . s [ _tmx_proc_ptran -> ftag . len ] = '\\0' ;\n _tmx_proc_ptran -> cseqnum . s = _tmx_proc_ptran -> ftag . s + _tmx_proc_ptran -> ftag . len + 1 ;\n memcpy ( _tmx_proc_ptran -> cseqnum . s , scseqnum . s , scseqnum . len ) ;\n _tmx_proc_ptran -> cseqnum . len = scseqnum . len ;\n _tmx_proc_ptran -> cseqnum . s [ _tmx_proc_ptran -> cseqnum . len ] = '\\0' ;\n _tmx_proc_ptran -> cseqmet . s = _tmx_proc_ptran -> cseqnum . s + _tmx_proc_ptran -> cseqnum . len + 1 ;\n memcpy ( _tmx_proc_ptran -> cseqmet . s , scseqmet . s , scseqmet . len ) ;\n _tmx_proc_ptran -> cseqmet . len = scseqmet . len ;\n _tmx_proc_ptran -> cseqmet . s [ _tmx_proc_ptran -> cseqmet . len ] = '\\0' ;\n if ( likely ( vbr != NULL ) ) {\n _tmx_proc_ptran -> vbranch . s = _tmx_proc_ptran -> cseqmet . s + _tmx_proc_ptran -> cseqmet . len + 1 ;\n memcpy ( _tmx_proc_ptran -> vbranch . s , svbranch . s , svbranch . len ) ;\n _tmx_proc_ptran -> vbranch . len = svbranch . len ;\n _tmx_proc_ptran -> vbranch . s [ _tmx_proc_ptran -> vbranch . len ] = '\\0' ;\n }\n else {\n _tmx_proc_ptran -> vbranch . s = NULL ;\n _tmx_proc_ptran -> vbranch . len = 0 ;\n }\n lock_get ( & _tmx_ptran_table [ slotid ] . lock ) ;\n it = _tmx_ptran_table [ slotid ] . plist ;\n tmx_pretran_link_safe ( slotid ) ;\n for ( ;\n it != NULL ;\n it = it -> next ) {\n if ( _tmx_proc_ptran -> hid != it -> hid || _tmx_proc_ptran -> cseqmetid != it -> cseqmetid || _tmx_proc_ptran -> callid . len != it -> callid . len || _tmx_proc_ptran -> ftag . len != it -> ftag . len || _tmx_proc_ptran -> cseqmet . len != it -> cseqmet . len || _tmx_proc_ptran -> cseqnum . len != it -> cseqnum . len ) continue ;\n if ( _tmx_proc_ptran -> vbranch . s != NULL && it -> vbranch . s != NULL ) {\n if ( _tmx_proc_ptran -> vbranch . len != it -> vbranch . len ) continue ;\n if ( _tmx_proc_ptran -> vbranch . s [ it -> vbranch . len - 1 ] != it -> vbranch . s [ it -> vbranch . len - 1 ] ) continue ;\n if ( memcmp ( _tmx_proc_ptran -> vbranch . s , it -> vbranch . s , it -> vbranch . len ) != 0 ) continue ;\n }\n if ( memcmp ( _tmx_proc_ptran -> callid . s , it -> callid . s , it -> callid . len ) != 0 || memcmp ( _tmx_proc_ptran -> ftag . s , it -> ftag . s , it -> ftag . len ) != 0 || memcmp ( _tmx_proc_ptran -> cseqnum . s , it -> cseqnum . s , it -> cseqnum . len ) != 0 ) continue ;\n if ( ( it -> cseqmetid == METHOD_OTHER || it -> cseqmetid == METHOD_UNDEF ) && memcmp ( _tmx_proc_ptran -> cseqmet . s , it -> cseqmet . s , it -> cseqmet . len ) != 0 ) continue ;\n LM_DBG ( \"matched another pre-transaction by pid %d for [%.*s]\\n\" , it -> pid , it -> callid . len , it -> callid . s ) ;\n lock_release ( & _tmx_ptran_table [ slotid ] . lock ) ;\n return 1 ;\n }\n lock_release ( & _tmx_ptran_table [ slotid ] . lock ) ;\n return 0 ;\n }", "idx": 22606}
{"hash": -8962831256613787672, "project": "debian", "size": 8, "label": 0, "functionSource": "void proto_reg_handoff_usb_audio ( void ) {\n dissector_handle_t usb_audio_bulk_handle , usb_audio_descr_handle ;\n usb_audio_descr_handle = create_dissector_handle ( dissect_usb_audio_descriptor , proto_usb_audio ) ;\n dissector_add_uint ( \"usb.descriptor\" , IF_CLASS_AUDIO , usb_audio_descr_handle ) ;\n usb_audio_bulk_handle = find_dissector ( \"usbaudio\" ) ;\n dissector_add_uint ( \"usb.bulk\" , IF_CLASS_AUDIO , usb_audio_bulk_handle ) ;\n sysex_handle = find_dissector_add_dependency ( \"sysex\" , proto_usb_audio ) ;\n }", "idx": 22607}
{"hash": 7424930167238097621, "project": "debian", "size": 24, "label": 0, "functionSource": "static int check_ctrlrecip ( struct usb_dev_state * ps , unsigned int requesttype , unsigned int request , unsigned int index ) {\n int ret = 0 ;\n struct usb_host_interface * alt_setting ;\n if ( ps -> dev -> state != USB_STATE_UNAUTHENTICATED && ps -> dev -> state != USB_STATE_ADDRESS && ps -> dev -> state != USB_STATE_CONFIGURED ) return - EHOSTUNREACH ;\n if ( USB_TYPE_VENDOR == ( USB_TYPE_MASK & requesttype ) ) return 0 ;\n if ( requesttype == 0xa1 && request == 0 ) {\n alt_setting = usb_find_alt_setting ( ps -> dev -> actconfig , index >> 8 , index & 0xff ) ;\n if ( alt_setting && alt_setting -> desc . bInterfaceClass == USB_CLASS_PRINTER ) return 0 ;\n }\n index &= 0xff ;\n switch ( requesttype & USB_RECIP_MASK ) {\n case USB_RECIP_ENDPOINT : if ( ( index & ~ USB_DIR_IN ) == 0 ) return 0 ;\n ret = findintfep ( ps -> dev , index ) ;\n if ( ret < 0 ) {\n ret = findintfep ( ps -> dev , index ^ 0x80 ) ;\n if ( ret >= 0 ) dev_info ( & ps -> dev -> dev , \"%s: process %i (%s) requesting ep %02x but needs %02x\\n\" , __func__ , task_pid_nr ( current ) , current -> comm , index , index ^ 0x80 ) ;\n }\n if ( ret >= 0 ) ret = checkintf ( ps , ret ) ;\n break ;\n case USB_RECIP_INTERFACE : ret = checkintf ( ps , index ) ;\n break ;\n }\n return ret ;\n }", "idx": 22608}
{"hash": 6755873269946787742, "project": "debian", "size": 27, "label": 0, "functionSource": "static void pk_transaction_set_hints ( PkTransaction * transaction , GVariant * params , GDBusMethodInvocation * context ) {\n gboolean ret ;\n guint i ;\n g_autofree gchar * * hints = NULL ;\n g_autoptr ( GError ) error = NULL ;\n g_autofree gchar * dbg = NULL ;\n g_return_if_fail ( PK_IS_TRANSACTION ( transaction ) ) ;\n g_return_if_fail ( transaction -> priv -> tid != NULL ) ;\n g_variant_get ( params , \"(^a&s)\" , & hints ) ;\n dbg = g_strjoinv ( \", \" , ( gchar * * ) hints ) ;\n g_debug ( \"SetHints method called: %s\" , dbg ) ;\n for ( i = 0 ;\n hints [ i ] != NULL ;\n i ++ ) {\n g_auto ( GStrv ) sections = NULL ;\n sections = g_strsplit ( hints [ i ] , \"=\" , 2 ) ;\n if ( g_strv_length ( sections ) == 2 ) {\n ret = pk_transaction_set_hint ( transaction , sections [ 0 ] , sections [ 1 ] , & error ) ;\n if ( ! ret ) goto out ;\n }\n else {\n g_set_error ( & error , PK_TRANSACTION_ERROR , PK_TRANSACTION_ERROR_NOT_SUPPORTED , \"Could not parse hint '%s'\" , hints [ i ] ) ;\n goto out ;\n }\n }\n out : pk_transaction_dbus_return ( context , error ) ;\n }", "idx": 22609}
{"hash": -5456913190944844754, "project": "chrome", "size": 16, "label": 0, "functionSource": "TEST_F ( TemplateURLTest , ParseURLNoKnownParameters ) {\n TemplateURLData data ;\n data . SetURL ( \"{\n}\n\" ) ;\n TemplateURL url ( data ) ;\n TemplateURLRef : : Replacements replacements ;\n bool valid = false ;\n EXPECT_EQ ( \"{\n}\n\" , url . url_ref ( ) . ParseURL ( \"{\n}\n\" , & replacements , NULL , & valid ) ) ;\n EXPECT_TRUE ( replacements . empty ( ) ) ;\n EXPECT_TRUE ( valid ) ;\n }", "idx": 22610}
{"hash": 2895622461494525400, "project": "debian", "size": 17, "label": 0, "functionSource": "static void test_bug9735 ( ) {\n MYSQL_RES * res ;\n int rc ;\n myheader ( \"test_bug9735\" ) ;\n rc = mysql_query ( mysql , \"drop table if exists t1\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"create table t1 (a mediumtext, b longtext) \" \"character set latin1\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"select * from t1\" ) ;\n myquery ( rc ) ;\n res = mysql_store_result ( mysql ) ;\n verify_prepare_field ( res , 0 , \"a\" , \"a\" , MYSQL_TYPE_BLOB , \"t1\" , \"t1\" , current_db , ( 1U << 24 ) - 1 , 0 ) ;\n verify_prepare_field ( res , 1 , \"b\" , \"b\" , MYSQL_TYPE_BLOB , \"t1\" , \"t1\" , current_db , ~ 0U , 0 ) ;\n mysql_free_result ( res ) ;\n rc = mysql_query ( mysql , \"drop table t1\" ) ;\n myquery ( rc ) ;\n }", "idx": 22611}
{"hash": -8884965407551053630, "project": "debian", "size": 9, "label": 0, "functionSource": "void input_DecoderWait ( decoder_t * p_dec ) {\n decoder_owner_sys_t * p_owner = p_dec -> p_owner ;\n vlc_mutex_lock ( & p_owner -> lock ) ;\n while ( p_owner -> b_waiting && ! p_owner -> b_has_data ) {\n block_FifoWake ( p_owner -> p_fifo ) ;\n vlc_cond_wait ( & p_owner -> wait_acknowledge , & p_owner -> lock ) ;\n }\n vlc_mutex_unlock ( & p_owner -> lock ) ;\n }", "idx": 22612}
{"hash": 4876100961671882393, "project": "debian", "size": 3, "label": 0, "functionSource": "static int dissect_pvfs_string ( tvbuff_t * tvb , proto_tree * tree , int hfindex , int offset , const char * * string_buffer_ret ) {\n return dissect_pvfs_opaque_data ( tvb , offset , tree , NULL , hfindex , FALSE , 0 , TRUE , string_buffer_ret ) ;\n }", "idx": 22613}
{"hash": 8170016074494868282, "project": "debian", "size": 11, "label": 0, "functionSource": "unsigned int auth_server_connection_add_request ( struct auth_server_connection * conn , struct auth_client_request * request ) {\n unsigned int id ;\n i_assert ( conn -> handshake_received ) ;\n id = ++ conn -> client -> request_id_counter ;\n if ( id == 0 ) {\n id = ++ conn -> client -> request_id_counter ;\n }\n i_assert ( hash_table_lookup ( conn -> requests , POINTER_CAST ( id ) ) == NULL ) ;\n hash_table_insert ( conn -> requests , POINTER_CAST ( id ) , request ) ;\n return id ;\n }", "idx": 22614}
{"hash": 6323824267898511453, "project": "debian", "size": 3, "label": 0, "functionSource": "void fz_drop_colorspace_store_key ( fz_context * ctx , fz_colorspace * cs ) {\n fz_drop_key_storable_key ( ctx , & cs -> key_storable ) ;\n }", "idx": 22615}
{"hash": -5780611388839125875, "project": "chrome", "size": 4, "label": 0, "functionSource": "int * __xmlDoValidityCheckingDefaultValue ( void ) {\n if ( IS_MAIN_THREAD ) return ( & xmlDoValidityCheckingDefaultValue ) ;\n else return ( & xmlGetGlobalState ( ) -> xmlDoValidityCheckingDefaultValue ) ;\n }", "idx": 22616}
{"hash": 7749168290238234888, "project": "debian", "size": 23, "label": 0, "functionSource": "static int test_recode_command ( xd3_stream * stream , int ignore ) {\n int has_source ;\n int variant ;\n int change ;\n int ret ;\n for ( has_source = 0 ;\n has_source < 2 ;\n has_source ++ ) {\n for ( variant = 0 ;\n variant < 8 ;\n variant ++ ) {\n for ( change = 0 ;\n change < 8 ;\n change ++ ) {\n if ( ( ret = test_recode_command2 ( stream , has_source , variant , change ) ) ) {\n return ret ;\n }\n }\n DOT ( ) ;\n }\n }\n return 0 ;\n }", "idx": 22617}
{"hash": 7078129966845159750, "project": "debian", "size": 44, "label": 1, "functionSource": "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n MDECContext * const a = avctx -> priv_data ;\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n AVFrame * picture = data ;\n AVFrame * const p = & a -> picture ;\n int i , ret ;\n if ( p -> data [ 0 ] ) ff_thread_release_buffer ( avctx , p ) ;\n p -> reference = 0 ;\n if ( ( ret = ff_thread_get_buffer ( avctx , p ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n p -> pict_type = AV_PICTURE_TYPE_I ;\n p -> key_frame = 1 ;\n av_fast_malloc ( & a -> bitstream_buffer , & a -> bitstream_buffer_size , buf_size + FF_INPUT_BUFFER_PADDING_SIZE ) ;\n if ( ! a -> bitstream_buffer ) return AVERROR ( ENOMEM ) ;\n for ( i = 0 ;\n i < buf_size ;\n i += 2 ) {\n a -> bitstream_buffer [ i ] = buf [ i + 1 ] ;\n a -> bitstream_buffer [ i + 1 ] = buf [ i ] ;\n }\n init_get_bits ( & a -> gb , a -> bitstream_buffer , buf_size * 8 ) ;\n skip_bits ( & a -> gb , 32 ) ;\n a -> qscale = get_bits ( & a -> gb , 16 ) ;\n a -> version = get_bits ( & a -> gb , 16 ) ;\n a -> last_dc [ 0 ] = a -> last_dc [ 1 ] = a -> last_dc [ 2 ] = 128 ;\n for ( a -> mb_x = 0 ;\n a -> mb_x < a -> mb_width ;\n a -> mb_x ++ ) {\n for ( a -> mb_y = 0 ;\n a -> mb_y < a -> mb_height ;\n a -> mb_y ++ ) {\n if ( ( ret = decode_mb ( a , a -> block ) ) < 0 ) return ret ;\n idct_put ( a , a -> mb_x , a -> mb_y ) ;\n }\n }\n p -> quality = a -> qscale * FF_QP2LAMBDA ;\n memset ( p -> qscale_table , a -> qscale , a -> mb_width ) ;\n * picture = a -> picture ;\n * got_frame = 1 ;\n return ( get_bits_count ( & a -> gb ) + 31 ) / 32 * 4 ;\n }", "idx": 22618}
{"hash": 4722923622195275414, "project": "debian", "size": 30, "label": 0, "functionSource": "static void lag_pred_line_yuy2 ( LagarithContext * l , uint8_t * buf , int width , int stride , int line , int is_luma ) {\n int L , TL ;\n if ( ! line ) {\n if ( is_luma ) {\n buf ++ ;\n width -- ;\n }\n l -> dsp . add_hfyu_left_prediction ( buf + 1 , buf + 1 , width - 1 , buf [ 0 ] ) ;\n return ;\n }\n if ( line == 1 ) {\n const int HEAD = is_luma ? 4 : 2 ;\n int i ;\n L = buf [ width - stride - 1 ] ;\n TL = buf [ HEAD - stride - 1 ] ;\n for ( i = 0 ;\n i < HEAD ;\n i ++ ) {\n L += buf [ i ] ;\n buf [ i ] = L ;\n }\n buf += HEAD ;\n width -= HEAD ;\n }\n else {\n TL = buf [ width - ( 2 * stride ) - 1 ] ;\n L = buf [ width - stride - 1 ] ;\n }\n l -> dsp . add_hfyu_median_prediction ( buf , buf - stride , buf , width , & L , & TL ) ;\n }", "idx": 22619}
{"hash": -7076754245473579218, "project": "chrome", "size": 5, "label": 0, "functionSource": "struct evhttp * evhttp_new ( struct event_base * base ) {\n struct evhttp * http = evhttp_new_object ( ) ;\n http -> base = base ;\n return ( http ) ;\n }", "idx": 22620}
{"hash": 1981604082870872490, "project": "chrome", "size": 8, "label": 0, "functionSource": "static int32_t u_printf_count_handler ( const u_printf_stream_handler * handler , void * context , ULocaleBundle * formatBundle , const u_printf_spec_info * info , const ufmt_args * args ) {\n ( void ) handler ;\n ( void ) context ;\n ( void ) formatBundle ;\n int32_t * count = ( int32_t * ) ( args [ 0 ] . ptrValue ) ;\n * count = info -> fWidth ;\n return 0 ;\n }", "idx": 22621}
{"hash": 4876100961671882393, "project": "debian", "size": 12, "label": 0, "functionSource": "static int dissect_pvfs2_mgmt_dspace_info_list_request ( tvbuff_t * tvb , proto_tree * tree , int offset , packet_info * pinfo ) {\n guint32 handle_count , i ;\n offset = dissect_pvfs_fs_id ( tvb , tree , offset ) ;\n handle_count = tvb_get_letohl ( tvb , offset ) ;\n offset += 4 ;\n for ( i = 0 ;\n i < handle_count ;\n i ++ ) {\n offset = dissect_pvfs_fh ( tvb , offset , pinfo , tree , \"handle\" , NULL ) ;\n }\n return offset ;\n }", "idx": 22622}
{"hash": -7811574867662618708, "project": "debian", "size": 3, "label": 0, "functionSource": "static void show_edge ( struct commit * commit ) {\n printf ( \"-%s\\n\" , oid_to_hex ( & commit -> object . oid ) ) ;\n }", "idx": 22623}
{"hash": 1245821301839614810, "project": "debian", "size": 239, "label": 0, "functionSource": "static void create_task_thread_func ( GTask * task , gpointer source_object , gpointer task_data , GCancellable * cancellable ) {\n CreateJob * job ;\n CommonJob * common ;\n int count ;\n GFile * dest ;\n g_autofree gchar * dest_uri = NULL ;\n char * basename ;\n char * filename , * filename2 , * new_filename ;\n char * filename_base , * suffix ;\n char * dest_fs_type ;\n GError * error ;\n gboolean res ;\n gboolean filename_is_utf8 ;\n char * primary , * secondary , * details ;\n int response ;\n char * data ;\n int length ;\n GFileOutputStream * out ;\n gboolean handled_invalid_filename ;\n int max_length , offset ;\n job = task_data ;\n common = & job -> common ;\n nautilus_progress_info_start ( job -> common . progress ) ;\n handled_invalid_filename = FALSE ;\n dest_fs_type = NULL ;\n filename = NULL ;\n dest = NULL ;\n max_length = get_max_name_length ( job -> dest_dir ) ;\n verify_destination ( common , job -> dest_dir , NULL , - 1 ) ;\n if ( job_aborted ( common ) ) {\n goto aborted ;\n }\n filename = g_strdup ( job -> filename ) ;\n filename_is_utf8 = FALSE ;\n if ( filename ) {\n filename_is_utf8 = g_utf8_validate ( filename , - 1 , NULL ) ;\n }\n if ( filename == NULL ) {\n if ( job -> make_dir ) {\n filename = g_strdup ( _ ( \"Untitled Folder\" ) ) ;\n filename_is_utf8 = TRUE ;\n }\n else {\n if ( job -> src != NULL ) {\n basename = g_file_get_basename ( job -> src ) ;\n filename = g_strdup_printf ( \"%s\" , basename ) ;\n g_free ( basename ) ;\n }\n if ( filename == NULL ) {\n filename = g_strdup ( _ ( \"Untitled Document\" ) ) ;\n filename_is_utf8 = TRUE ;\n }\n }\n }\n make_file_name_valid_for_dest_fs ( filename , dest_fs_type ) ;\n if ( filename_is_utf8 ) {\n dest = g_file_get_child_for_display_name ( job -> dest_dir , filename , NULL ) ;\n }\n if ( dest == NULL ) {\n dest = g_file_get_child ( job -> dest_dir , filename ) ;\n }\n count = 1 ;\n retry : error = NULL ;\n if ( job -> make_dir ) {\n res = g_file_make_directory ( dest , common -> cancellable , & error ) ;\n if ( res ) {\n GFile * real ;\n real = map_possibly_volatile_file_to_real ( dest , common -> cancellable , & error ) ;\n if ( real == NULL ) {\n res = FALSE ;\n }\n else {\n g_object_unref ( dest ) ;\n dest = real ;\n }\n }\n if ( res && common -> undo_info != NULL ) {\n nautilus_file_undo_info_create_set_data ( NAUTILUS_FILE_UNDO_INFO_CREATE ( common -> undo_info ) , dest , NULL , 0 ) ;\n }\n }\n else {\n if ( job -> src ) {\n res = g_file_copy ( job -> src , dest , G_FILE_COPY_NONE , common -> cancellable , NULL , NULL , & error ) ;\n if ( res ) {\n GFile * real ;\n real = map_possibly_volatile_file_to_real ( dest , common -> cancellable , & error ) ;\n if ( real == NULL ) {\n res = FALSE ;\n }\n else {\n g_object_unref ( dest ) ;\n dest = real ;\n }\n }\n if ( res && common -> undo_info != NULL ) {\n gchar * uri ;\n uri = g_file_get_uri ( job -> src ) ;\n nautilus_file_undo_info_create_set_data ( NAUTILUS_FILE_UNDO_INFO_CREATE ( common -> undo_info ) , dest , uri , 0 ) ;\n g_free ( uri ) ;\n }\n }\n else {\n data = \"\" ;\n length = 0 ;\n if ( job -> src_data ) {\n data = job -> src_data ;\n length = job -> length ;\n }\n out = g_file_create ( dest , G_FILE_CREATE_NONE , common -> cancellable , & error ) ;\n if ( out ) {\n GFile * real ;\n real = map_possibly_volatile_file_to_real_on_write ( dest , out , common -> cancellable , & error ) ;\n if ( real == NULL ) {\n res = FALSE ;\n g_object_unref ( out ) ;\n }\n else {\n g_object_unref ( dest ) ;\n dest = real ;\n res = g_output_stream_write_all ( G_OUTPUT_STREAM ( out ) , data , length , NULL , common -> cancellable , & error ) ;\n if ( res ) {\n res = g_output_stream_close ( G_OUTPUT_STREAM ( out ) , common -> cancellable , & error ) ;\n if ( res && common -> undo_info != NULL ) {\n nautilus_file_undo_info_create_set_data ( NAUTILUS_FILE_UNDO_INFO_CREATE ( common -> undo_info ) , dest , data , length ) ;\n }\n }\n g_object_unref ( out ) ;\n }\n }\n else {\n res = FALSE ;\n }\n }\n }\n if ( res ) {\n job -> created_file = g_object_ref ( dest ) ;\n nautilus_file_changes_queue_file_added ( dest ) ;\n dest_uri = g_file_get_uri ( dest ) ;\n if ( job -> has_position ) {\n nautilus_file_changes_queue_schedule_position_set ( dest , job -> position , common -> screen_num ) ;\n }\n else if ( eel_uri_is_desktop ( dest_uri ) ) {\n nautilus_file_changes_queue_schedule_position_remove ( dest ) ;\n }\n }\n else {\n g_assert ( error != NULL ) ;\n if ( IS_IO_ERROR ( error , INVALID_FILENAME ) && ! handled_invalid_filename ) {\n handled_invalid_filename = TRUE ;\n g_assert ( dest_fs_type == NULL ) ;\n dest_fs_type = query_fs_type ( job -> dest_dir , common -> cancellable ) ;\n if ( count == 1 ) {\n new_filename = g_strdup ( filename ) ;\n }\n else {\n filename_base = eel_filename_strip_extension ( filename ) ;\n offset = strlen ( filename_base ) ;\n suffix = g_strdup ( filename + offset ) ;\n filename2 = g_strdup_printf ( \"%s %d%s\" , filename_base , count , suffix ) ;\n new_filename = NULL ;\n if ( max_length > 0 && strlen ( filename2 ) > max_length ) {\n new_filename = shorten_utf8_string ( filename2 , strlen ( filename2 ) - max_length ) ;\n }\n if ( new_filename == NULL ) {\n new_filename = g_strdup ( filename2 ) ;\n }\n g_free ( filename2 ) ;\n g_free ( suffix ) ;\n }\n if ( make_file_name_valid_for_dest_fs ( new_filename , dest_fs_type ) ) {\n g_object_unref ( dest ) ;\n if ( filename_is_utf8 ) {\n dest = g_file_get_child_for_display_name ( job -> dest_dir , new_filename , NULL ) ;\n }\n if ( dest == NULL ) {\n dest = g_file_get_child ( job -> dest_dir , new_filename ) ;\n }\n g_free ( new_filename ) ;\n g_error_free ( error ) ;\n goto retry ;\n }\n g_free ( new_filename ) ;\n }\n if ( IS_IO_ERROR ( error , EXISTS ) ) {\n g_object_unref ( dest ) ;\n dest = NULL ;\n filename_base = eel_filename_strip_extension ( filename ) ;\n offset = strlen ( filename_base ) ;\n suffix = g_strdup ( filename + offset ) ;\n filename2 = g_strdup_printf ( \"%s %d%s\" , filename_base , ++ count , suffix ) ;\n if ( max_length > 0 && strlen ( filename2 ) > max_length ) {\n new_filename = shorten_utf8_string ( filename2 , strlen ( filename2 ) - max_length ) ;\n if ( new_filename != NULL ) {\n g_free ( filename2 ) ;\n filename2 = new_filename ;\n }\n }\n make_file_name_valid_for_dest_fs ( filename2 , dest_fs_type ) ;\n if ( filename_is_utf8 ) {\n dest = g_file_get_child_for_display_name ( job -> dest_dir , filename2 , NULL ) ;\n }\n if ( dest == NULL ) {\n dest = g_file_get_child ( job -> dest_dir , filename2 ) ;\n }\n g_free ( filename2 ) ;\n g_free ( suffix ) ;\n g_error_free ( error ) ;\n goto retry ;\n }\n else if ( IS_IO_ERROR ( error , CANCELLED ) ) {\n g_error_free ( error ) ;\n }\n else {\n if ( job -> make_dir ) {\n primary = f ( _ ( \"Error while creating directory %B.\" ) , dest ) ;\n }\n else {\n primary = f ( _ ( \"Error while creating file %B.\" ) , dest ) ;\n }\n secondary = f ( _ ( \"There was an error creating the directory in %F.\" ) , job -> dest_dir ) ;\n details = error -> message ;\n response = run_warning ( common , primary , secondary , details , FALSE , CANCEL , SKIP , NULL ) ;\n g_error_free ( error ) ;\n if ( response == 0 || response == GTK_RESPONSE_DELETE_EVENT ) {\n abort_job ( common ) ;\n }\n else if ( response == 1 ) {\n }\n else {\n g_assert_not_reached ( ) ;\n }\n }\n }\n aborted : if ( dest ) {\n g_object_unref ( dest ) ;\n }\n g_free ( filename ) ;\n g_free ( dest_fs_type ) ;\n }", "idx": 22624}
{"hash": 5835074581393329621, "project": "debian", "size": 12, "label": 0, "functionSource": "relpRetVal relpTcpSetOwnCert ( relpTcp_t * pThis , char * cert ) {\n ENTER_RELPFUNC ;\n RELPOBJ_assert ( pThis , Tcp ) ;\n free ( pThis -> ownCertFile ) ;\n if ( cert == NULL ) {\n pThis -> ownCertFile = NULL ;\n }\n else {\n if ( ( pThis -> ownCertFile = strdup ( cert ) ) == NULL ) ABORT_FINALIZE ( RELP_RET_OUT_OF_MEMORY ) ;\n }\n finalize_it : LEAVE_RELPFUNC ;\n }", "idx": 22625}
{"hash": 7092216800726729686, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_h245_EncryptionMode ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_EncryptionMode , EncryptionMode_choice , NULL ) ;\n return offset ;\n }", "idx": 22626}
{"hash": 1911881859629730975, "project": "chrome", "size": 21, "label": 0, "functionSource": "static void fill_token_costs ( vp9_coeff_cost * c , vp9_coeff_probs_model ( * p ) [ PLANE_TYPES ] ) {\n int i , j , k , l ;\n TX_SIZE t ;\n for ( t = TX_4X4 ;\n t <= TX_32X32 ;\n ++ t ) for ( i = 0 ;\n i < PLANE_TYPES ;\n ++ i ) for ( j = 0 ;\n j < REF_TYPES ;\n ++ j ) for ( k = 0 ;\n k < COEF_BANDS ;\n ++ k ) for ( l = 0 ;\n l < BAND_COEFF_CONTEXTS ( k ) ;\n ++ l ) {\n vp9_prob probs [ ENTROPY_NODES ] ;\n vp9_model_to_full_probs ( p [ t ] [ i ] [ j ] [ k ] [ l ] , probs ) ;\n vp9_cost_tokens ( ( int * ) c [ t ] [ i ] [ j ] [ k ] [ 0 ] [ l ] , probs , vp9_coef_tree ) ;\n vp9_cost_tokens_skip ( ( int * ) c [ t ] [ i ] [ j ] [ k ] [ 1 ] [ l ] , probs , vp9_coef_tree ) ;\n assert ( c [ t ] [ i ] [ j ] [ k ] [ 0 ] [ l ] [ EOB_TOKEN ] == c [ t ] [ i ] [ j ] [ k ] [ 1 ] [ l ] [ EOB_TOKEN ] ) ;\n }\n }", "idx": 22627}
{"hash": -8531860357798072773, "project": "debian", "size": 13, "label": 0, "functionSource": "void send_key_changed ( void ) {\n avl_node_t * node ;\n connection_t * c ;\n send_request ( everyone , \"%d %x %s\" , KEY_CHANGED , rand ( ) , myself -> name ) ;\n for ( node = connection_tree -> head ;\n node ;\n node = node -> next ) {\n c = node -> data ;\n if ( c -> status . active && c -> node && c -> node -> status . reachable ) {\n send_ans_key ( c -> node ) ;\n }\n }\n }", "idx": 22628}
{"hash": 6393050609822897742, "project": "debian", "size": 2, "label": 0, "functionSource": "static void xhci_cap_write ( void * opaque , hwaddr addr , uint64_t val , unsigned width ) {\n }", "idx": 22629}
{"hash": 1760449185745615462, "project": "debian", "size": 14, "label": 0, "functionSource": "TSReturnCode TSHttpTxnConfigFloatGet ( TSHttpTxn txnp , TSOverridableConfigKey conf , TSMgmtFloat * value ) {\n sdk_assert ( sdk_sanity_check_txn ( txnp ) == TS_SUCCESS ) ;\n sdk_assert ( sdk_sanity_check_null_ptr ( ( void * ) value ) == TS_SUCCESS ) ;\n OverridableDataType type ;\n TSMgmtFloat * dest = static_cast < TSMgmtFloat * > ( _conf_to_memberp ( conf , ( ( HttpSM * ) txnp ) -> t_state . txn_conf , & type ) ) ;\n if ( type != OVERRIDABLE_TYPE_FLOAT ) {\n return TS_ERROR ;\n }\n if ( dest ) {\n * value = * dest ;\n return TS_SUCCESS ;\n }\n return TS_SUCCESS ;\n }", "idx": 22630}
{"hash": -16551315108292821, "project": "debian", "size": 6, "label": 0, "functionSource": "gcry_sexp_t gcry_sexp_append ( const gcry_sexp_t a , const gcry_sexp_t n ) {\n ( void ) a ;\n ( void ) n ;\n BUG ( ) ;\n return NULL ;\n }", "idx": 22631}
{"hash": 4839943401171415484, "project": "chrome", "size": 21, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_P ( BrowserCloseManagerBrowserTest , PRE_TestSessionRestore ) {\n ASSERT_NO_FATAL_FAILURE ( ui_test_utils : : NavigateToURL ( browser ( ) , embedded_test_server ( ) -> GetURL ( \"/beforeunload.html\" ) ) ) ;\n AddBlankTabAndShow ( browser ( ) ) ;\n ASSERT_NO_FATAL_FAILURE ( ui_test_utils : : NavigateToURL ( browser ( ) , GURL ( chrome : : kChromeUIAboutURL ) ) ) ;\n PrepareForDialog ( browser ( ) ) ;\n RepeatedNotificationObserver cancel_observer ( chrome : : NOTIFICATION_BROWSER_CLOSE_CANCELLED , 1 ) ;\n chrome : : CloseAllBrowsersAndQuit ( ) ;\n ASSERT_NO_FATAL_FAILURE ( CancelClose ( ) ) ;\n cancel_observer . Wait ( ) ;\n EXPECT_FALSE ( browser_shutdown : : IsTryingToQuit ( ) ) ;\n browser ( ) -> tab_strip_model ( ) -> CloseWebContentsAt ( 1 , TabStripModel : : CLOSE_USER_GESTURE ) ;\n content : : TestNavigationObserver navigation_observer ( browser ( ) -> tab_strip_model ( ) -> GetActiveWebContents ( ) , 1 ) ;\n ASSERT_NO_FATAL_FAILURE ( NavigateToURLWithDisposition ( browser ( ) , GURL ( chrome : : kChromeUIVersionURL ) , WindowOpenDisposition : : CURRENT_TAB , ui_test_utils : : BROWSER_TEST_NONE ) ) ;\n ASSERT_NO_FATAL_FAILURE ( AcceptClose ( ) ) ;\n navigation_observer . Wait ( ) ;\n RepeatedNotificationObserver close_observer ( chrome : : NOTIFICATION_BROWSER_CLOSED , 1 ) ;\n chrome : : CloseAllBrowsersAndQuit ( ) ;\n close_observer . Wait ( ) ;\n EXPECT_TRUE ( browser_shutdown : : IsTryingToQuit ( ) ) ;\n EXPECT_TRUE ( BrowserList : : GetInstance ( ) -> empty ( ) ) ;\n }", "idx": 22632}
{"hash": -16551315108292821, "project": "debian", "size": 60, "label": 0, "functionSource": "static int convert_to_string ( const unsigned char * s , size_t len , char * dest ) {\n if ( dest ) {\n char * p = dest ;\n * p ++ = '\\\"' ;\n for ( ;\n len ;\n len -- , s ++ ) {\n switch ( * s ) {\n case '\\b' : * p ++ = '\\\\' ;\n * p ++ = 'b' ;\n break ;\n case '\\t' : * p ++ = '\\\\' ;\n * p ++ = 't' ;\n break ;\n case '\\v' : * p ++ = '\\\\' ;\n * p ++ = 'v' ;\n break ;\n case '\\n' : * p ++ = '\\\\' ;\n * p ++ = 'n' ;\n break ;\n case '\\f' : * p ++ = '\\\\' ;\n * p ++ = 'f' ;\n break ;\n case '\\r' : * p ++ = '\\\\' ;\n * p ++ = 'r' ;\n break ;\n case '\\\"' : * p ++ = '\\\\' ;\n * p ++ = '\\\"' ;\n break ;\n case '\\'' : * p ++ = '\\\\' ;\n * p ++ = '\\'' ;\n break ;\n case '\\\\' : * p ++ = '\\\\' ;\n * p ++ = '\\\\' ;\n break ;\n default : if ( ( * s < 0x20 || ( * s >= 0x7f && * s <= 0xa0 ) ) ) {\n sprintf ( p , \"\\\\x%02x\" , * s ) ;\n p += 4 ;\n }\n else * p ++ = * s ;\n }\n }\n * p ++ = '\\\"' ;\n return p - dest ;\n }\n else {\n int count = 2 ;\n for ( ;\n len ;\n len -- , s ++ ) {\n switch ( * s ) {\n case '\\b' : case '\\t' : case '\\v' : case '\\n' : case '\\f' : case '\\r' : case '\\\"' : case '\\'' : case '\\\\' : count += 2 ;\n break ;\n default : if ( ( * s < 0x20 || ( * s >= 0x7f && * s <= 0xa0 ) ) ) count += 4 ;\n else count ++ ;\n }\n }\n return count ;\n }\n }", "idx": 22633}
{"hash": -2648356651055439484, "project": "debian", "size": 30, "label": 0, "functionSource": "guint16 elem_v ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo , gint pdu_type , int idx , guint32 offset , const gchar * name_add ) {\n guint16 consumed ;\n guint32 curr_offset ;\n proto_tree * subtree ;\n proto_item * item ;\n value_string_ext elem_names_ext ;\n gint * elem_ett ;\n const gchar * elem_name ;\n guint16 ( * * elem_funcs ) ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo , guint32 offset , guint len , gchar * add_string , int string_len ) ;\n curr_offset = offset ;\n consumed = 0 ;\n SET_ELEM_VARS ( pdu_type , elem_names_ext , elem_ett , elem_funcs , & ei_gsm_a_unknown_pdu_type ) ;\n elem_name = try_val_to_str_ext ( idx , & elem_names_ext ) ;\n if ( elem_name == NULL || elem_funcs [ idx ] == NULL ) {\n proto_tree_add_expert ( tree , pinfo , & ei_gsm_a_no_element_dissector , tvb , curr_offset , 1 ) ;\n consumed = 1 ;\n }\n else {\n gchar * a_add_string ;\n subtree = proto_tree_add_subtree_format ( tree , tvb , curr_offset , 0 , elem_ett [ idx ] , & item , \"%s%s\" , elem_name , ( name_add == NULL ) || ( name_add [ 0 ] == '\\0' ) ? \"\" : name_add ) ;\n a_add_string = ( gchar * ) wmem_alloc ( wmem_packet_scope ( ) , 1024 ) ;\n a_add_string [ 0 ] = '\\0' ;\n consumed = ( * elem_funcs [ idx ] ) ( tvb , subtree , pinfo , curr_offset , - 1 , a_add_string , 1024 ) ;\n if ( a_add_string [ 0 ] != '\\0' ) {\n proto_item_append_text ( item , \"%s\" , a_add_string ) ;\n }\n proto_item_set_len ( item , consumed ) ;\n }\n return ( consumed ) ;\n }", "idx": 22634}
{"hash": -3502382902740740634, "project": "debian", "size": 16, "label": 0, "functionSource": "static const char * proto_avp ( diam_ctx_t * c , diam_avp_t * a , tvbuff_t * tvb , diam_sub_dis_t * diam_sub_dis_inf ) {\n proto_avp_t * t = ( proto_avp_t * ) a -> type_data ;\n col_set_writable ( c -> pinfo -> cinfo , FALSE ) ;\n if ( ! t -> handle ) {\n t -> handle = find_dissector ( t -> name ) ;\n if ( ! t -> handle ) t -> handle = data_handle ;\n }\n TRY {\n call_dissector_with_data ( t -> handle , tvb , c -> pinfo , c -> tree , diam_sub_dis_inf ) ;\n }\n CATCH_NONFATAL_ERRORS {\n show_exception ( tvb , c -> pinfo , c -> tree , EXCEPT_CODE , GET_MESSAGE ) ;\n }\n ENDTRY ;\n return \"\" ;\n }", "idx": 22635}
{"hash": 6249489553242542670, "project": "debian", "size": 6, "label": 0, "functionSource": "string_node * create_string_node ( char * str ) {\n string_node * sn ;\n sn = emalloc_zero ( sizeof ( * sn ) ) ;\n sn -> s = str ;\n return sn ;\n }", "idx": 22636}
{"hash": -2964264153308487898, "project": "debian", "size": 7, "label": 0, "functionSource": "static void InitXCFImage ( XCFLayerInfo * outLayer , ExceptionInfo * exception ) {\n outLayer -> image -> page . x = outLayer -> offset_x ;\n outLayer -> image -> page . y = outLayer -> offset_y ;\n outLayer -> image -> page . width = outLayer -> width ;\n outLayer -> image -> page . height = outLayer -> height ;\n ( void ) SetImageProperty ( outLayer -> image , \"label\" , ( char * ) outLayer -> name , exception ) ;\n }", "idx": 22637}
{"hash": -7117046864335130087, "project": "chrome", "size": 10, "label": 0, "functionSource": "void vp9_rc_set_gf_max_interval ( const VP9_COMP * const cpi , RATE_CONTROL * const rc ) {\n const VP9EncoderConfig * const oxcf = & cpi -> oxcf ;\n rc -> max_gf_interval = 16 ;\n rc -> static_scene_max_gf_interval = oxcf -> key_freq >> 1 ;\n if ( rc -> static_scene_max_gf_interval > ( MAX_LAG_BUFFERS * 2 ) ) rc -> static_scene_max_gf_interval = MAX_LAG_BUFFERS * 2 ;\n if ( is_altref_enabled ( cpi ) ) {\n if ( rc -> static_scene_max_gf_interval > oxcf -> lag_in_frames - 1 ) rc -> static_scene_max_gf_interval = oxcf -> lag_in_frames - 1 ;\n }\n if ( rc -> max_gf_interval > rc -> static_scene_max_gf_interval ) rc -> max_gf_interval = rc -> static_scene_max_gf_interval ;\n }", "idx": 22638}
{"hash": 1891617106617090004, "project": "chrome", "size": 8, "label": 0, "functionSource": "static void U_CALLCONV _UTF32Reset ( UConverter * cnv , UConverterResetChoice choice ) {\n if ( choice <= UCNV_RESET_TO_UNICODE ) {\n cnv -> mode = 0 ;\n }\n if ( choice != UCNV_RESET_TO_UNICODE ) {\n cnv -> fromUnicodeStatus = UCNV_NEED_TO_WRITE_BOM ;\n }\n }", "idx": 22639}
{"hash": 8971837418146377192, "project": "chrome", "size": 116, "label": 0, "functionSource": "static const xmlChar * xsltDefaultRegion ( const xmlChar * localeName ) {\n xmlChar c ;\n const char * region = NULL ;\n c = localeName [ 1 ] ;\n switch ( localeName [ 0 ] ) {\n case 'a' : if ( c == 'a' || c == 'm' ) region = \"ET\" ;\n else if ( c == 'f' ) region = \"ZA\" ;\n else if ( c == 'n' ) region = \"ES\" ;\n else if ( c == 'r' ) region = \"AE\" ;\n else if ( c == 'z' ) region = \"AZ\" ;\n break ;\n case 'b' : if ( c == 'e' ) region = \"BY\" ;\n else if ( c == 'g' ) region = \"BG\" ;\n else if ( c == 'n' ) region = \"BD\" ;\n else if ( c == 'r' ) region = \"FR\" ;\n else if ( c == 's' ) region = \"BA\" ;\n break ;\n case 'c' : if ( c == 'a' ) region = \"ES\" ;\n else if ( c == 's' ) region = \"CZ\" ;\n else if ( c == 'y' ) region = \"GB\" ;\n break ;\n case 'd' : if ( c == 'a' ) region = \"DK\" ;\n else if ( c == 'e' ) region = \"DE\" ;\n break ;\n case 'e' : if ( c == 'l' ) region = \"GR\" ;\n else if ( c == 'n' || c == 'o' ) region = \"US\" ;\n else if ( c == 's' || c == 'u' ) region = \"ES\" ;\n else if ( c == 't' ) region = \"EE\" ;\n break ;\n case 'f' : if ( c == 'a' ) region = \"IR\" ;\n else if ( c == 'i' ) region = \"FI\" ;\n else if ( c == 'o' ) region = \"FO\" ;\n else if ( c == 'r' ) region = \"FR\" ;\n break ;\n case 'g' : if ( c == 'a' ) region = \"IE\" ;\n else if ( c == 'l' ) region = \"ES\" ;\n else if ( c == 'v' ) region = \"GB\" ;\n break ;\n case 'h' : if ( c == 'e' ) region = \"IL\" ;\n else if ( c == 'i' ) region = \"IN\" ;\n else if ( c == 'r' ) region = \"HT\" ;\n else if ( c == 'u' ) region = \"HU\" ;\n break ;\n case 'i' : if ( c == 'd' ) region = \"ID\" ;\n else if ( c == 's' ) region = \"IS\" ;\n else if ( c == 't' ) region = \"IT\" ;\n else if ( c == 'w' ) region = \"IL\" ;\n break ;\n case 'j' : if ( c == 'a' ) region = \"JP\" ;\n break ;\n case 'k' : if ( c == 'l' ) region = \"GL\" ;\n else if ( c == 'o' ) region = \"KR\" ;\n else if ( c == 'w' ) region = \"GB\" ;\n break ;\n case 'l' : if ( c == 't' ) region = \"LT\" ;\n else if ( c == 'v' ) region = \"LV\" ;\n break ;\n case 'm' : if ( c == 'k' ) region = \"MK\" ;\n else if ( c == 'l' || c == 'r' ) region = \"IN\" ;\n else if ( c == 'n' ) region = \"MN\" ;\n else if ( c == 's' ) region = \"MY\" ;\n else if ( c == 't' ) region = \"MT\" ;\n break ;\n case 'n' : if ( c == 'b' || c == 'n' || c == 'o' ) region = \"NO\" ;\n else if ( c == 'e' ) region = \"NP\" ;\n else if ( c == 'l' ) region = \"NL\" ;\n break ;\n case 'o' : if ( c == 'm' ) region = \"ET\" ;\n break ;\n case 'p' : if ( c == 'a' ) region = \"IN\" ;\n else if ( c == 'l' ) region = \"PL\" ;\n else if ( c == 't' ) region = \"PT\" ;\n break ;\n case 'r' : if ( c == 'o' ) region = \"RO\" ;\n else if ( c == 'u' ) region = \"RU\" ;\n break ;\n case 's' : switch ( c ) {\n case 'e' : region = \"NO\" ;\n break ;\n case 'h' : region = \"YU\" ;\n break ;\n case 'k' : region = \"SK\" ;\n break ;\n case 'l' : region = \"SI\" ;\n break ;\n case 'o' : region = \"ET\" ;\n break ;\n case 'q' : region = \"AL\" ;\n break ;\n case 't' : region = \"ZA\" ;\n break ;\n case 'v' : region = \"SE\" ;\n break ;\n }\n break ;\n case 't' : if ( c == 'a' || c == 'e' ) region = \"IN\" ;\n else if ( c == 'h' ) region = \"TH\" ;\n else if ( c == 'i' ) region = \"ER\" ;\n else if ( c == 'r' ) region = \"TR\" ;\n else if ( c == 't' ) region = \"RU\" ;\n break ;\n case 'u' : if ( c == 'k' ) region = \"UA\" ;\n else if ( c == 'r' ) region = \"PK\" ;\n break ;\n case 'v' : if ( c == 'i' ) region = \"VN\" ;\n break ;\n case 'w' : if ( c == 'a' ) region = \"BE\" ;\n break ;\n case 'x' : if ( c == 'h' ) region = \"ZA\" ;\n break ;\n case 'z' : if ( c == 'h' ) region = \"CN\" ;\n else if ( c == 'u' ) region = \"ZA\" ;\n break ;\n }\n return ( ( xmlChar * ) region ) ;\n }", "idx": 22640}
{"hash": 3584320764213684062, "project": "debian", "size": 4, "label": 0, "functionSource": "static void vvalue_strbuf_append_ui8 ( wmem_strbuf_t * strbuf , void * ptr ) {\n guint64 ui8 = * ( guint64 * ) ptr ;\n wmem_strbuf_append_printf ( strbuf , \"%\" G_GINT64_MODIFIER \"u\" , ui8 ) ;\n }", "idx": 22641}
{"hash": 6675626110148442062, "project": "debian", "size": 5, "label": 0, "functionSource": "static int sfile_close ( jas_stream_obj_t * obj ) {\n FILE * fp ;\n fp = JAS_CAST ( FILE * , obj ) ;\n return fclose ( fp ) ;\n }", "idx": 22642}
{"hash": 3557739556029059195, "project": "chrome", "size": 13, "label": 0, "functionSource": "void vp9_sad ## m ## x ## n ## x ## k ## _c ( const uint8_t * src , int src_stride , const uint8_t * ref , int ref_stride , unsigned int * sads ) {\n int i ;\n for ( i = 0 ;\n i < k ;\n ++ i ) sads [ i ] = vp9_sad ## m ## x ## n ## _c ( src , src_stride , & ref [ i ] , ref_stride ) ;\n \\ }\n # define sadMxNx4D ( m , n ) void vp9_sad ## m ## x ## n ## x4d_c ( const uint8_t * src , int src_stride , const uint8_t * const refs [ ] , int ref_stride , unsigned int * sads ) {\n int i ;\n for ( i = 0 ;\n i < 4 ;\n ++ i ) sads [ i ] = vp9_sad ## m ## x ## n ## _c ( src , src_stride , refs [ i ] , ref_stride ) ;\n \\ }\n sadMxN ( 64 , 64 ) sadMxNxK ( 64 , 64 , 3 ) sadMxNxK ( 64 , 64 , 8 )", "idx": 22643}
{"hash": -6704066512670389306, "project": "debian", "size": 3, "label": 0, "functionSource": "static const char * lookup_gname ( struct cpio * cpio , gid_t gid ) {\n return ( lookup_name ( cpio , & cpio -> gname_cache , & lookup_gname_helper , ( id_t ) gid ) ) ;\n }", "idx": 22644}
{"hash": -6068976579504840746, "project": "debian", "size": 16, "label": 0, "functionSource": "char * add_var ( struct ctl_var * * kv , u_long size , u_short def ) {\n u_short c ;\n struct ctl_var * k ;\n char * buf ;\n c = count_var ( * kv ) ;\n * kv = erealloc ( * kv , ( c + 2 ) * sizeof ( * * kv ) ) ;\n k = * kv ;\n buf = emalloc ( size ) ;\n k [ c ] . code = c ;\n k [ c ] . text = buf ;\n k [ c ] . flags = def ;\n k [ c + 1 ] . code = 0 ;\n k [ c + 1 ] . text = NULL ;\n k [ c + 1 ] . flags = EOV ;\n return buf ;\n }", "idx": 22645}
{"hash": 7039307292471244756, "project": "debian", "size": 8, "label": 0, "functionSource": "static guint16 de_tp_loop_ack ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len _U_ , gchar * add_string _U_ , int string_len _U_ ) {\n guint32 curr_offset = offset ;\n proto_tree_add_item ( tree , hf_gsm_a_dtap_channel_coding30 , tvb , curr_offset , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( tree , hf_gsm_a_dtap_loop_mechanism0E , tvb , curr_offset , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( tree , hf_gsm_a_dtap_multislot_tch , tvb , curr_offset , 1 , ENC_BIG_ENDIAN ) ;\n curr_offset += 1 ;\n return ( curr_offset - offset ) ;\n }", "idx": 22646}
{"hash": 8801969307247112896, "project": "debian", "size": 7, "label": 0, "functionSource": "static int aes_ofb_cipher ( EVP_CIPHER_CTX * ctx , unsigned char * out , const unsigned char * in , size_t len ) {\n EVP_AES_KEY * dat = EVP_C_DATA ( EVP_AES_KEY , ctx ) ;\n int num = EVP_CIPHER_CTX_num ( ctx ) ;\n CRYPTO_ofb128_encrypt ( in , out , len , & dat -> ks , EVP_CIPHER_CTX_iv_noconst ( ctx ) , & num , dat -> block ) ;\n EVP_CIPHER_CTX_set_num ( ctx , num ) ;\n return 1 ;\n }", "idx": 22647}
{"hash": -4178541639582894026, "project": "debian", "size": 69, "label": 0, "functionSource": "static int zmbv_decode_xor_16 ( ZmbvContext * c ) {\n uint8_t * src = c -> decomp_buf ;\n uint16_t * output , * prev ;\n int8_t * mvec ;\n int x , y ;\n int d , dx , dy , bw2 , bh2 ;\n int block ;\n int i , j ;\n int mx , my ;\n output = ( uint16_t * ) c -> cur ;\n prev = ( uint16_t * ) c -> prev ;\n mvec = ( int8_t * ) src ;\n src += ( ( c -> bx * c -> by * 2 + 3 ) & ~ 3 ) ;\n block = 0 ;\n for ( y = 0 ;\n y < c -> height ;\n y += c -> bh ) {\n bh2 = ( ( c -> height - y ) > c -> bh ) ? c -> bh : ( c -> height - y ) ;\n for ( x = 0 ;\n x < c -> width ;\n x += c -> bw ) {\n uint16_t * out , * tprev ;\n d = mvec [ block ] & 1 ;\n dx = mvec [ block ] >> 1 ;\n dy = mvec [ block + 1 ] >> 1 ;\n block += 2 ;\n bw2 = ( ( c -> width - x ) > c -> bw ) ? c -> bw : ( c -> width - x ) ;\n out = output + x ;\n tprev = prev + x + dx + dy * c -> width ;\n mx = x + dx ;\n my = y + dy ;\n for ( j = 0 ;\n j < bh2 ;\n j ++ ) {\n if ( my + j < 0 || my + j >= c -> height ) {\n memset ( out , 0 , bw2 * 2 ) ;\n }\n else {\n for ( i = 0 ;\n i < bw2 ;\n i ++ ) {\n if ( mx + i < 0 || mx + i >= c -> width ) out [ i ] = 0 ;\n else out [ i ] = tprev [ i ] ;\n }\n }\n out += c -> width ;\n tprev += c -> width ;\n }\n if ( d ) {\n out = output + x ;\n for ( j = 0 ;\n j < bh2 ;\n j ++ ) {\n for ( i = 0 ;\n i < bw2 ;\n i ++ ) {\n out [ i ] ^= * ( ( uint16_t * ) src ) ;\n src += 2 ;\n }\n out += c -> width ;\n }\n }\n }\n output += c -> width * c -> bh ;\n prev += c -> width * c -> bh ;\n }\n if ( src - c -> decomp_buf != c -> decomp_len ) av_log ( c -> avctx , AV_LOG_ERROR , \"Used %ti of %i bytes\\n\" , src - c -> decomp_buf , c -> decomp_len ) ;\n return 0 ;\n }", "idx": 22648}
{"hash": 2388171415474875762, "project": "debian", "size": 18, "label": 0, "functionSource": "static char * summary_template ( tvbuff_t * tvb , int offset ) {\n const char * objtype ;\n if ( tvb_get_guint8 ( tvb , offset + 2 ) == RSVP_CLASS_FILTER_SPEC ) objtype = \"FILTERSPEC\" ;\n else objtype = \"SENDER TEMPLATE\" ;\n switch ( tvb_get_guint8 ( tvb , offset + 3 ) ) {\n case 1 : return wmem_strdup_printf ( wmem_packet_scope ( ) , \"%s: IPv4, Sender %s, Port %d. \" , objtype , tvb_ip_to_str ( tvb , offset + 4 ) , tvb_get_ntohs ( tvb , offset + 10 ) ) ;\n break ;\n case 7 : return wmem_strdup_printf ( wmem_packet_scope ( ) , \"%s: IPv4-LSP, Tunnel Source: %s, Short Call ID: %d, LSP ID: %d. \" , objtype , tvb_ip_to_str ( tvb , offset + 4 ) , tvb_get_ntohs ( tvb , offset + 8 ) , tvb_get_ntohs ( tvb , offset + 10 ) ) ;\n break ;\n case 8 : return wmem_strdup_printf ( wmem_packet_scope ( ) , \"%s: IPv6-LSP, Tunnel Source: %s, Short Call ID: %d, LSP ID: %d. \" , objtype , tvb_ip6_to_str ( tvb , offset + 4 ) , tvb_get_ntohs ( tvb , offset + 20 ) , tvb_get_ntohs ( tvb , offset + 22 ) ) ;\n break ;\n case 9 : return wmem_strdup_printf ( wmem_packet_scope ( ) , \"%s: IPv4-Aggregate, Aggregator %s. \" , objtype , tvb_ip_to_str ( tvb , offset + 4 ) ) ;\n break ;\n default : return wmem_strdup_printf ( wmem_packet_scope ( ) , \"%s: Type %d. \" , objtype , tvb_get_guint8 ( tvb , offset + 3 ) ) ;\n break ;\n }\n DISSECTOR_ASSERT_NOT_REACHED ( ) ;\n }", "idx": 22649}
{"hash": 6415329349331062723, "project": "chrome", "size": 6, "label": 0, "functionSource": "static int validate_header ( const struct evkeyvalq * headers , const char * key , const char * value ) {\n const char * real_val = evhttp_find_header ( headers , key ) ;\n if ( real_val == NULL ) return ( - 1 ) ;\n if ( strcmp ( real_val , value ) != 0 ) return ( - 1 ) ;\n return ( 0 ) ;\n }", "idx": 22650}
{"hash": -5420171864670538459, "project": "debian", "size": 33, "label": 0, "functionSource": "void qmp_memsave ( int64_t addr , int64_t size , const char * filename , bool has_cpu , int64_t cpu_index , Error * * errp ) {\n FILE * f ;\n uint32_t l ;\n CPUArchState * env ;\n CPUState * cpu ;\n uint8_t buf [ 1024 ] ;\n if ( ! has_cpu ) {\n cpu_index = 0 ;\n }\n cpu = qemu_get_cpu ( cpu_index ) ;\n if ( cpu == NULL ) {\n error_set ( errp , QERR_INVALID_PARAMETER_VALUE , \"cpu-index\" , \"a CPU number\" ) ;\n return ;\n }\n env = cpu -> env_ptr ;\n f = fopen ( filename , \"wb\" ) ;\n if ( ! f ) {\n error_setg_file_open ( errp , errno , filename ) ;\n return ;\n }\n while ( size != 0 ) {\n l = sizeof ( buf ) ;\n if ( l > size ) l = size ;\n cpu_memory_rw_debug ( env , addr , buf , l , 0 ) ;\n if ( fwrite ( buf , 1 , l , f ) != l ) {\n error_set ( errp , QERR_IO_ERROR ) ;\n goto exit ;\n }\n addr += l ;\n size -= l ;\n }\n exit : fclose ( f ) ;\n }", "idx": 22651}
{"hash": 2546373479020365143, "project": "debian", "size": 6, "label": 0, "functionSource": "MIMEField * mime_field_create_named ( HdrHeap * heap , MIMEHdrImpl * mh , const char * name , int length ) {\n MIMEField * field = mime_field_create ( heap , mh ) ;\n int field_name_wks_idx = hdrtoken_tokenize ( name , length ) ;\n mime_field_name_set ( heap , mh , field , field_name_wks_idx , name , length , true ) ;\n return field ;\n }", "idx": 22652}
{"hash": 8849962823026424130, "project": "debian", "size": 5, "label": 0, "functionSource": "static void qio_channel_websock_handshake_send_res_err ( QIOChannelWebsock * ioc , const char * resdata ) {\n char * date = qio_channel_websock_date_str ( ) ;\n qio_channel_websock_handshake_send_res ( ioc , resdata , date ) ;\n g_free ( date ) ;\n }", "idx": 22653}
{"hash": 3599206110384554647, "project": "debian", "size": 45, "label": 0, "functionSource": "static ossl_inline int sk_ ## t1 ## _push ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_push ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _unshift ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_unshift ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _pop ( STACK_OF ( t1 ) * sk ) {\n return ( t2 * ) OPENSSL_sk_pop ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _shift ( STACK_OF ( t1 ) * sk ) {\n return ( t2 * ) OPENSSL_sk_shift ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline void sk_ ## t1 ## _pop_free ( STACK_OF ( t1 ) * sk , sk_ ## t1 ## _freefunc freefunc ) {\n OPENSSL_sk_pop_free ( ( OPENSSL_STACK * ) sk , ( OPENSSL_sk_freefunc ) freefunc ) ;\n }\n static ossl_inline int sk_ ## t1 ## _insert ( STACK_OF ( t1 ) * sk , t2 * ptr , int idx ) {\n return OPENSSL_sk_insert ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr , idx ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _set ( STACK_OF ( t1 ) * sk , int idx , t2 * ptr ) {\n return ( t2 * ) OPENSSL_sk_set ( ( OPENSSL_STACK * ) sk , idx , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _find ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_find ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _find_ex ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_find_ex ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline void sk_ ## t1 ## _sort ( STACK_OF ( t1 ) * sk ) {\n OPENSSL_sk_sort ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline int sk_ ## t1 ## _is_sorted ( const STACK_OF ( t1 ) * sk ) {\n return OPENSSL_sk_is_sorted ( ( const OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _dup ( const STACK_OF ( t1 ) * sk ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_dup ( ( const OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _deep_copy ( const STACK_OF ( t1 ) * sk , sk_ ## t1 ## _copyfunc copyfunc , sk_ ## t1 ## _freefunc freefunc ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_deep_copy ( ( const OPENSSL_STACK * ) sk , ( OPENSSL_sk_copyfunc ) copyfunc , ( OPENSSL_sk_freefunc ) freefunc ) ;\n }\n static ossl_inline sk_ ## t1 ## _compfunc sk_ ## t1 ## _set_cmp_func ( STACK_OF ( t1 ) * sk , sk_ ## t1 ## _compfunc compare ) {\n return ( sk_ ## t1 ## _compfunc ) OPENSSL_sk_set_cmp_func ( ( OPENSSL_STACK * ) sk , ( OPENSSL_sk_compfunc ) compare ) ;\n }\n # define DEFINE_SPECIAL_STACK_OF ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , t2 , t2 ) # define DEFINE_STACK_OF ( t ) SKM_DEFINE_STACK_OF ( t , t , t ) # define DEFINE_SPECIAL_STACK_OF_CONST ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , const t2 , t2 ) # define DEFINE_STACK_OF_CONST ( t ) SKM_DEFINE_STACK_OF ( t , const t , t ) typedef char * OPENSSL_STRING ;\n typedef const char * OPENSSL_CSTRING ;\n DEFINE_SPECIAL_STACK_OF ( OPENSSL_STRING , char ) DEFINE_SPECIAL_STACK_OF_CONST ( OPENSSL_CSTRING , char )", "idx": 22654}
{"hash": -5493081488206619677, "project": "debian", "size": 11, "label": 0, "functionSource": "static const char * cmd_conn_read_state_limit ( cmd_parms * cmd , void * _dcfg , const char * p1 ) {\n directory_config * dcfg = ( directory_config * ) _dcfg ;\n long int limit ;\n if ( dcfg == NULL ) return NULL ;\n limit = strtol ( p1 , NULL , 10 ) ;\n if ( ( limit == LONG_MAX ) || ( limit == LONG_MIN ) || ( limit <= 0 ) ) {\n return apr_psprintf ( cmd -> pool , \"ModSecurity: Invalid value for SecReadStateLimit: %s\" , p1 ) ;\n }\n conn_read_state_limit = limit ;\n return NULL ;\n }", "idx": 22655}
{"hash": -3819889754140204145, "project": "debian", "size": 34, "label": 0, "functionSource": "static bool parse_otherName ( chunk_t * blob , int level0 , id_type_t * type ) {\n asn1_parser_t * parser ;\n chunk_t object ;\n int objectID ;\n int oid = OID_UNKNOWN ;\n bool success = FALSE ;\n parser = asn1_parser_create ( otherNameObjects , * blob ) ;\n parser -> set_top_level ( parser , level0 ) ;\n while ( parser -> iterate ( parser , & objectID , & object ) ) {\n switch ( objectID ) {\n case ON_OBJ_ID_TYPE : oid = asn1_known_oid ( object ) ;\n break ;\n case ON_OBJ_VALUE : switch ( oid ) {\n case OID_XMPP_ADDR : if ( ! asn1_parse_simple_object ( & object , ASN1_UTF8STRING , parser -> get_level ( parser ) + 1 , \"xmppAddr\" ) ) {\n goto end ;\n }\n break ;\n case OID_USER_PRINCIPAL_NAME : if ( asn1_parse_simple_object ( & object , ASN1_UTF8STRING , parser -> get_level ( parser ) + 1 , \"msUPN\" ) ) {\n * blob = object ;\n * type = ID_RFC822_ADDR ;\n }\n else {\n goto end ;\n }\n break ;\n }\n break ;\n default : break ;\n }\n }\n success = parser -> success ( parser ) ;\n end : parser -> destroy ( parser ) ;\n return success ;\n }", "idx": 22656}
{"hash": 1760449185745615462, "project": "debian", "size": 3, "label": 0, "functionSource": "const char * TSUrlHostGet ( TSMBuffer bufp , TSMLoc obj , int * length ) {\n return URLPartGet ( bufp , obj , length , & URL : : host_get ) ;\n }", "idx": 22657}
{"hash": -2943582541244387919, "project": "chrome", "size": 43, "label": 0, "functionSource": "unsigned int vp9_sub_pixel_variance ## W ## x ## H ## _c ( const uint8_t * src , int src_stride , int xoffset , int yoffset , const uint8_t * dst , int dst_stride , unsigned int * sse ) {\n uint16_t fdata3 [ ( H + 1 ) * W ] ;\n uint8_t temp2 [ H * W ] ;\n var_filter_block2d_bil_first_pass ( src , fdata3 , src_stride , 1 , H + 1 , W , BILINEAR_FILTERS_2TAP ( xoffset ) ) ;\n var_filter_block2d_bil_second_pass ( fdata3 , temp2 , W , W , H , W , BILINEAR_FILTERS_2TAP ( yoffset ) ) ;\n return vp9_variance ## W ## x ## H ## _c ( temp2 , W , dst , dst_stride , sse ) ;\n \\ }\n # define SUBPIX_AVG_VAR ( W , H ) unsigned int vp9_sub_pixel_avg_variance ## W ## x ## H ## _c ( const uint8_t * src , int src_stride , int xoffset , int yoffset , const uint8_t * dst , int dst_stride , unsigned int * sse , const uint8_t * second_pred ) {\n uint16_t fdata3 [ ( H + 1 ) * W ] ;\n uint8_t temp2 [ H * W ] ;\n DECLARE_ALIGNED_ARRAY ( 16 , uint8_t , temp3 , H * W ) ;\n var_filter_block2d_bil_first_pass ( src , fdata3 , src_stride , 1 , H + 1 , W , BILINEAR_FILTERS_2TAP ( xoffset ) ) ;\n var_filter_block2d_bil_second_pass ( fdata3 , temp2 , W , W , H , W , BILINEAR_FILTERS_2TAP ( yoffset ) ) ;\n vp9_comp_avg_pred ( temp3 , second_pred , W , H , temp2 , W ) ;\n return vp9_variance ## W ## x ## H ## _c ( temp3 , W , dst , dst_stride , sse ) ;\n \\ }\n void vp9_get16x16var_c ( const uint8_t * src_ptr , int source_stride , const uint8_t * ref_ptr , int ref_stride , unsigned int * sse , int * sum ) {\n variance ( src_ptr , source_stride , ref_ptr , ref_stride , 16 , 16 , sse , sum ) ;\n }\n void vp9_get8x8var_c ( const uint8_t * src_ptr , int source_stride , const uint8_t * ref_ptr , int ref_stride , unsigned int * sse , int * sum ) {\n variance ( src_ptr , source_stride , ref_ptr , ref_stride , 8 , 8 , sse , sum ) ;\n }\n unsigned int vp9_mse16x16_c ( const uint8_t * src , int src_stride , const uint8_t * ref , int ref_stride , unsigned int * sse ) {\n int sum ;\n variance ( src , src_stride , ref , ref_stride , 16 , 16 , sse , & sum ) ;\n return * sse ;\n }\n unsigned int vp9_mse16x8_c ( const uint8_t * src , int src_stride , const uint8_t * ref , int ref_stride , unsigned int * sse ) {\n int sum ;\n variance ( src , src_stride , ref , ref_stride , 16 , 8 , sse , & sum ) ;\n return * sse ;\n }\n unsigned int vp9_mse8x16_c ( const uint8_t * src , int src_stride , const uint8_t * ref , int ref_stride , unsigned int * sse ) {\n int sum ;\n variance ( src , src_stride , ref , ref_stride , 8 , 16 , sse , & sum ) ;\n return * sse ;\n }\n unsigned int vp9_mse8x8_c ( const uint8_t * src , int src_stride , const uint8_t * ref , int ref_stride , unsigned int * sse ) {\n int sum ;\n variance ( src , src_stride , ref , ref_stride , 8 , 8 , sse , & sum ) ;\n return * sse ;\n }\n VAR ( 4 , 4 ) SUBPIX_VAR ( 4 , 4 ) SUBPIX_AVG_VAR ( 4 , 4 ) VAR ( 4 , 8 ) SUBPIX_VAR ( 4 , 8 ) SUBPIX_AVG_VAR ( 4 , 8 ) VAR ( 8 , 4 ) SUBPIX_VAR ( 8 , 4 ) SUBPIX_AVG_VAR ( 8 , 4 ) VAR ( 8 , 8 ) SUBPIX_VAR ( 8 , 8 ) SUBPIX_AVG_VAR ( 8 , 8 ) VAR ( 8 , 16 ) SUBPIX_VAR ( 8 , 16 ) SUBPIX_AVG_VAR ( 8 , 16 ) VAR ( 16 , 8 ) SUBPIX_VAR ( 16 , 8 ) SUBPIX_AVG_VAR ( 16 , 8 ) VAR ( 16 , 16 ) SUBPIX_VAR ( 16 , 16 ) SUBPIX_AVG_VAR ( 16 , 16 ) VAR ( 16 , 32 ) SUBPIX_VAR ( 16 , 32 ) SUBPIX_AVG_VAR ( 16 , 32 ) VAR ( 32 , 16 ) SUBPIX_VAR ( 32 , 16 ) SUBPIX_AVG_VAR ( 32 , 16 ) VAR ( 32 , 32 ) SUBPIX_VAR ( 32 , 32 ) SUBPIX_AVG_VAR ( 32 , 32 ) VAR ( 32 , 64 ) SUBPIX_VAR ( 32 , 64 ) SUBPIX_AVG_VAR ( 32 , 64 ) VAR ( 64 , 32 ) SUBPIX_VAR ( 64 , 32 )", "idx": 22658}
{"hash": -7131177824150194183, "project": "debian", "size": 41, "label": 0, "functionSource": "static void read_tree ( GetBitContext * gb , Tree * tree ) {\n uint8_t tmp1 [ 16 ] = {\n 0 }\n , tmp2 [ 16 ] , * in = tmp1 , * out = tmp2 ;\n int i , t , len ;\n tree -> vlc_num = get_bits ( gb , 4 ) ;\n if ( ! tree -> vlc_num ) {\n for ( i = 0 ;\n i < 16 ;\n i ++ ) tree -> syms [ i ] = i ;\n return ;\n }\n if ( get_bits1 ( gb ) ) {\n len = get_bits ( gb , 3 ) ;\n for ( i = 0 ;\n i <= len ;\n i ++ ) {\n tree -> syms [ i ] = get_bits ( gb , 4 ) ;\n tmp1 [ tree -> syms [ i ] ] = 1 ;\n }\n for ( i = 0 ;\n i < 16 && len < 16 - 1 ;\n i ++ ) if ( ! tmp1 [ i ] ) tree -> syms [ ++ len ] = i ;\n }\n else {\n len = get_bits ( gb , 2 ) ;\n for ( i = 0 ;\n i < 16 ;\n i ++ ) in [ i ] = i ;\n for ( i = 0 ;\n i <= len ;\n i ++ ) {\n int size = 1 << i ;\n for ( t = 0 ;\n t < 16 ;\n t += size << 1 ) merge ( gb , out + t , in + t , size ) ;\n FFSWAP ( uint8_t * , in , out ) ;\n }\n memcpy ( tree -> syms , in , 16 ) ;\n }\n }", "idx": 22659}
{"hash": 3599206110384554647, "project": "debian", "size": 75, "label": 1, "functionSource": "static ossl_inline int sk_ ## t1 ## _num ( const STACK_OF ( t1 ) * sk ) {\n return OPENSSL_sk_num ( ( const OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _value ( const STACK_OF ( t1 ) * sk , int idx ) {\n return ( t2 * ) OPENSSL_sk_value ( ( const OPENSSL_STACK * ) sk , idx ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _new ( sk_ ## t1 ## _compfunc compare ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_new ( ( OPENSSL_sk_compfunc ) compare ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _new_null ( void ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_new_null ( ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _new_reserve ( sk_ ## t1 ## _compfunc compare , int n ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_new_reserve ( ( OPENSSL_sk_compfunc ) compare , n ) ;\n }\n static ossl_inline int sk_ ## t1 ## _reserve ( STACK_OF ( t1 ) * sk , int n ) {\n return OPENSSL_sk_reserve ( ( OPENSSL_STACK * ) sk , n ) ;\n }\n static ossl_inline void sk_ ## t1 ## _free ( STACK_OF ( t1 ) * sk ) {\n OPENSSL_sk_free ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline void sk_ ## t1 ## _zero ( STACK_OF ( t1 ) * sk ) {\n OPENSSL_sk_zero ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _delete ( STACK_OF ( t1 ) * sk , int i ) {\n return ( t2 * ) OPENSSL_sk_delete ( ( OPENSSL_STACK * ) sk , i ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _delete_ptr ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return ( t2 * ) OPENSSL_sk_delete_ptr ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _push ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_push ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _unshift ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_unshift ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _pop ( STACK_OF ( t1 ) * sk ) {\n return ( t2 * ) OPENSSL_sk_pop ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _shift ( STACK_OF ( t1 ) * sk ) {\n return ( t2 * ) OPENSSL_sk_shift ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline void sk_ ## t1 ## _pop_free ( STACK_OF ( t1 ) * sk , sk_ ## t1 ## _freefunc freefunc ) {\n OPENSSL_sk_pop_free ( ( OPENSSL_STACK * ) sk , ( OPENSSL_sk_freefunc ) freefunc ) ;\n }\n static ossl_inline int sk_ ## t1 ## _insert ( STACK_OF ( t1 ) * sk , t2 * ptr , int idx ) {\n return OPENSSL_sk_insert ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr , idx ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _set ( STACK_OF ( t1 ) * sk , int idx , t2 * ptr ) {\n return ( t2 * ) OPENSSL_sk_set ( ( OPENSSL_STACK * ) sk , idx , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _find ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_find ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _find_ex ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_find_ex ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline void sk_ ## t1 ## _sort ( STACK_OF ( t1 ) * sk ) {\n OPENSSL_sk_sort ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline int sk_ ## t1 ## _is_sorted ( const STACK_OF ( t1 ) * sk ) {\n return OPENSSL_sk_is_sorted ( ( const OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _dup ( const STACK_OF ( t1 ) * sk ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_dup ( ( const OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _deep_copy ( const STACK_OF ( t1 ) * sk , sk_ ## t1 ## _copyfunc copyfunc , sk_ ## t1 ## _freefunc freefunc ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_deep_copy ( ( const OPENSSL_STACK * ) sk , ( OPENSSL_sk_copyfunc ) copyfunc , ( OPENSSL_sk_freefunc ) freefunc ) ;\n }\n static ossl_inline sk_ ## t1 ## _compfunc sk_ ## t1 ## _set_cmp_func ( STACK_OF ( t1 ) * sk , sk_ ## t1 ## _compfunc compare ) {\n return ( sk_ ## t1 ## _compfunc ) OPENSSL_sk_set_cmp_func ( ( OPENSSL_STACK * ) sk , ( OPENSSL_sk_compfunc ) compare ) ;\n }\n # define DEFINE_SPECIAL_STACK_OF ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , t2 , t2 ) # define DEFINE_STACK_OF ( t ) SKM_DEFINE_STACK_OF ( t , t , t ) # define DEFINE_SPECIAL_STACK_OF_CONST ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , const t2 , t2 ) # define DEFINE_STACK_OF_CONST ( t ) SKM_DEFINE_STACK_OF ( t , const t , t ) typedef char * OPENSSL_STRING ;\n typedef const char * OPENSSL_CSTRING ;\n DEFINE_SPECIAL_STACK_OF ( OPENSSL_STRING , char )", "idx": 22660}
{"hash": -1676420406744178546, "project": "debian", "size": 15, "label": 0, "functionSource": "static size_t make_flagged_int ( unsigned long value , char * buf , size_t buflen ) {\n int more = 0 ;\n int shift ;\n for ( more = 0 , shift = 28 ;\n shift > 0 ;\n shift -= 7 ) {\n if ( more || value >= ( 1 << shift ) ) {\n buf [ buflen ++ ] = 0x80 | ( value >> shift ) ;\n value -= ( value >> shift ) << shift ;\n more = 1 ;\n }\n }\n buf [ buflen ++ ] = value ;\n return buflen ;\n }", "idx": 22661}
{"hash": -7888349587538303571, "project": "debian", "size": 13, "label": 0, "functionSource": "static int rawv6_init_sk ( struct sock * sk ) {\n struct raw6_sock * rp = raw6_sk ( sk ) ;\n switch ( inet_sk ( sk ) -> inet_num ) {\n case IPPROTO_ICMPV6 : rp -> checksum = 1 ;\n rp -> offset = 2 ;\n break ;\n case IPPROTO_MH : rp -> checksum = 1 ;\n rp -> offset = 4 ;\n break ;\n default : break ;\n }\n return ( 0 ) ;\n }", "idx": 22662}
{"hash": -5268859819325807498, "project": "debian", "size": 5, "label": 0, "functionSource": "void nautilus_file_invalidate_count_and_mime_list ( NautilusFile * file ) {\n NautilusFileAttributes attributes ;\n attributes = NAUTILUS_FILE_ATTRIBUTE_DIRECTORY_ITEM_COUNT | NAUTILUS_FILE_ATTRIBUTE_DIRECTORY_ITEM_MIME_TYPES ;\n nautilus_file_invalidate_attributes ( file , attributes ) ;\n }", "idx": 22663}
{"hash": 1366214969540455677, "project": "debian", "size": 15, "label": 0, "functionSource": "int tls_construct_server_certificate ( SSL * s ) {\n CERT_PKEY * cpk ;\n cpk = ssl_get_server_send_pkey ( s ) ;\n if ( cpk == NULL ) {\n SSLerr ( SSL_F_TLS_CONSTRUCT_SERVER_CERTIFICATE , ERR_R_INTERNAL_ERROR ) ;\n ossl_statem_set_error ( s ) ;\n return 0 ;\n }\n if ( ! ssl3_output_cert_chain ( s , cpk ) ) {\n SSLerr ( SSL_F_TLS_CONSTRUCT_SERVER_CERTIFICATE , ERR_R_INTERNAL_ERROR ) ;\n ossl_statem_set_error ( s ) ;\n return 0 ;\n }\n return 1 ;\n }", "idx": 22664}
{"hash": -7434014980763120366, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dissect_ber_ObjectDescriptor ( gboolean implicit_tag _U_ , tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_ber_restricted_string ( implicit_tag , BER_UNI_TAG_ObjectDescriptor , actx , tree , tvb , offset , hf_index , & actx -> external . data_value_descriptor ) ;\n return offset ;\n }", "idx": 22665}
{"hash": 6632536031698733342, "project": "debian", "size": 10, "label": 0, "functionSource": "static void flat_print_str ( WriterContext * wctx , const char * key , const char * value ) {\n FlatContext * flat = wctx -> priv ;\n AVBPrint buf ;\n printf ( \"%s\" , wctx -> section_pbuf [ wctx -> level ] . str ) ;\n av_bprint_init ( & buf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ;\n printf ( \"%s=\" , flat_escape_key_str ( & buf , key , flat -> sep ) ) ;\n av_bprint_clear ( & buf ) ;\n printf ( \"\\\"%s\\\"\\n\" , flat_escape_value_str ( & buf , value ) ) ;\n av_bprint_finalize ( & buf , NULL ) ;\n }", "idx": 22666}
{"hash": 6571662888192809761, "project": "debian", "size": 3, "label": 0, "functionSource": "inline HTTPType http_hdr_type_get ( HTTPHdrImpl * hh ) {\n return ( hh -> m_polarity ) ;\n }", "idx": 22667}
{"hash": -4555950263653671147, "project": "debian", "size": 7, "label": 0, "functionSource": "static PyObject * string_mod ( PyObject * v , PyObject * w ) {\n if ( ! PyString_Check ( v ) ) {\n Py_INCREF ( Py_NotImplemented ) ;\n return Py_NotImplemented ;\n }\n return PyString_Format ( v , w ) ;\n }", "idx": 22668}
{"hash": 313627013719508831, "project": "debian", "size": 3, "label": 0, "functionSource": "static inline void SetPixelChannelTraits ( Image * image , const PixelChannel channel , const PixelTrait traits ) {\n image -> channel_map [ channel ] . traits = traits ;\n }", "idx": 22669}
{"hash": -6704066512670389306, "project": "debian", "size": 56, "label": 0, "functionSource": "static int entry_to_archive ( struct cpio * cpio , struct archive_entry * entry ) {\n const char * destpath = archive_entry_pathname ( entry ) ;\n const char * srcpath = archive_entry_sourcepath ( entry ) ;\n int fd = - 1 ;\n ssize_t bytes_read ;\n int r ;\n if ( cpio -> verbose ) fprintf ( stderr , \"%s\" , destpath ) ;\n if ( cpio -> dot ) fprintf ( stderr , \".\" ) ;\n if ( cpio -> option_link && archive_entry_filetype ( entry ) == AE_IFREG ) {\n struct archive_entry * t ;\n t = archive_entry_clone ( entry ) ;\n if ( t == NULL ) lafe_errc ( 1 , ENOMEM , \"Can't create link\" ) ;\n archive_entry_set_hardlink ( t , srcpath ) ;\n archive_entry_set_size ( t , 0 ) ;\n r = archive_write_header ( cpio -> archive , t ) ;\n archive_entry_free ( t ) ;\n if ( r != ARCHIVE_OK ) lafe_warnc ( archive_errno ( cpio -> archive ) , \"%s\" , archive_error_string ( cpio -> archive ) ) ;\n if ( r == ARCHIVE_FATAL ) exit ( 1 ) ;\n # ifdef EXDEV if ( r != ARCHIVE_OK && archive_errno ( cpio -> archive ) == EXDEV ) {\n lafe_warnc ( 0 , \"Copying file instead\" ) ;\n }\n else # endif return ( 0 ) ;\n }\n if ( archive_entry_filetype ( entry ) == AE_IFREG ) {\n if ( archive_entry_size ( entry ) > 0 ) {\n fd = open ( srcpath , O_RDONLY | O_BINARY ) ;\n if ( fd < 0 ) {\n lafe_warnc ( errno , \"%s: could not open file\" , srcpath ) ;\n goto cleanup ;\n }\n }\n }\n else {\n archive_entry_set_size ( entry , 0 ) ;\n }\n r = archive_write_header ( cpio -> archive , entry ) ;\n if ( r != ARCHIVE_OK ) lafe_warnc ( archive_errno ( cpio -> archive ) , \"%s: %s\" , srcpath , archive_error_string ( cpio -> archive ) ) ;\n if ( r == ARCHIVE_FATAL ) exit ( 1 ) ;\n if ( r >= ARCHIVE_WARN && archive_entry_size ( entry ) > 0 && fd >= 0 ) {\n bytes_read = read ( fd , cpio -> buff , ( unsigned ) cpio -> buff_size ) ;\n while ( bytes_read > 0 ) {\n ssize_t bytes_write ;\n bytes_write = archive_write_data ( cpio -> archive , cpio -> buff , bytes_read ) ;\n if ( bytes_write < 0 ) lafe_errc ( 1 , archive_errno ( cpio -> archive ) , \"%s\" , archive_error_string ( cpio -> archive ) ) ;\n if ( bytes_write < bytes_read ) {\n lafe_warnc ( 0 , \"Truncated write;\n file may have \" \"grown while being archived.\" ) ;\n }\n bytes_read = read ( fd , cpio -> buff , ( unsigned ) cpio -> buff_size ) ;\n }\n }\n fd = restore_time ( cpio , entry , srcpath , fd ) ;\n cleanup : if ( cpio -> verbose ) fprintf ( stderr , \"\\n\" ) ;\n if ( fd >= 0 ) close ( fd ) ;\n return ( 0 ) ;\n }", "idx": 22670}
{"hash": 914926989019402478, "project": "debian", "size": 4, "label": 0, "functionSource": "int main_file_exists ( main_file * xfile ) {\n struct stat sbuf ;\n return stat ( xfile -> filename , & sbuf ) == 0 && S_ISREG ( sbuf . st_mode ) ;\n }", "idx": 22671}
{"hash": -5456913190944844754, "project": "chrome", "size": 21, "label": 0, "functionSource": "TEST_F ( TemplateURLTest , ReplaceSearchTermsInUTF8URL ) {\n TemplateURLData data ;\n data . SetURL ( \"http://utf-8.ru/?q={\nsearchTerms}\n\" ) ;\n data . alternate_urls . push_back ( \"http://utf-8.ru/#q={\nsearchTerms}\n\" ) ;\n data . alternate_urls . push_back ( \"http://utf-8.ru/path/{\nsearchTerms}\n\" ) ;\n TemplateURL url ( data ) ;\n TemplateURLRef : : SearchTermsArgs search_terms ( base : : WideToUTF16 ( L\"\\x0442\\x0435\\x043A\\x0441\\x0442\" ) ) ;\n GURL result ;\n EXPECT_TRUE ( url . ReplaceSearchTermsInURL ( GURL ( \"http://utf-8.ru/?q=a+b\" ) , search_terms , search_terms_data_ , & result ) ) ;\n EXPECT_EQ ( GURL ( \"http://utf-8.ru/?q=%D1%82%D0%B5%D0%BA%D1%81%D1%82\" ) , result ) ;\n EXPECT_TRUE ( url . ReplaceSearchTermsInURL ( GURL ( \"http://utf-8.ru/#q=a+b\" ) , search_terms , search_terms_data_ , & result ) ) ;\n EXPECT_EQ ( GURL ( \"http://utf-8.ru/#q=%D1%82%D0%B5%D0%BA%D1%81%D1%82\" ) , result ) ;\n EXPECT_TRUE ( url . ReplaceSearchTermsInURL ( GURL ( \"http://utf-8.ru/path/a%20b\" ) , search_terms , search_terms_data_ , & result ) ) ;\n EXPECT_EQ ( GURL ( \"http://utf-8.ru/path/%D1%82%D0%B5%D0%BA%D1%81%D1%82\" ) , result ) ;\n }", "idx": 22672}
{"hash": 4839943401171415484, "project": "chrome", "size": 5, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_P ( BrowserCloseManagerBrowserTest , MAYBE_TestSessionRestore ) {\n EXPECT_EQ ( 2 , browser ( ) -> tab_strip_model ( ) -> count ( ) ) ;\n EXPECT_EQ ( GURL ( chrome : : kChromeUIVersionURL ) , browser ( ) -> tab_strip_model ( ) -> GetWebContentsAt ( 0 ) -> GetURL ( ) ) ;\n EXPECT_EQ ( GURL ( \"about:blank\" ) , browser ( ) -> tab_strip_model ( ) -> GetWebContentsAt ( 1 ) -> GetURL ( ) ) ;\n }", "idx": 22673}
{"hash": 214341372476109918, "project": "debian", "size": 32, "label": 0, "functionSource": "static void set_frozenxids ( bool minmxid_only ) {\n int dbnum ;\n PGconn * conn , * conn_template1 ;\n PGresult * dbres ;\n int ntups ;\n int i_datname ;\n int i_datallowconn ;\n if ( ! minmxid_only ) prep_status ( \"Setting frozenxid and minmxid counters in new cluster\" ) ;\n else prep_status ( \"Setting minmxid counter in new cluster\" ) ;\n conn_template1 = connectToServer ( & new_cluster , \"template1\" ) ;\n if ( ! minmxid_only ) PQclear ( executeQueryOrDie ( conn_template1 , \"UPDATE pg_catalog.pg_database \" \"SET datfrozenxid = '%u'\" , old_cluster . controldata . chkpnt_nxtxid ) ) ;\n PQclear ( executeQueryOrDie ( conn_template1 , \"UPDATE pg_catalog.pg_database \" \"SET datminmxid = '%u'\" , old_cluster . controldata . chkpnt_nxtmulti ) ) ;\n dbres = executeQueryOrDie ( conn_template1 , \"SELECT datname, datallowconn \" \"FROM pg_catalog.pg_database\" ) ;\n i_datname = PQfnumber ( dbres , \"datname\" ) ;\n i_datallowconn = PQfnumber ( dbres , \"datallowconn\" ) ;\n ntups = PQntuples ( dbres ) ;\n for ( dbnum = 0 ;\n dbnum < ntups ;\n dbnum ++ ) {\n char * datname = PQgetvalue ( dbres , dbnum , i_datname ) ;\n char * datallowconn = PQgetvalue ( dbres , dbnum , i_datallowconn ) ;\n if ( strcmp ( datallowconn , \"f\" ) == 0 ) PQclear ( executeQueryOrDie ( conn_template1 , \"ALTER DATABASE %s ALLOW_CONNECTIONS = true\" , quote_identifier ( datname ) ) ) ;\n conn = connectToServer ( & new_cluster , datname ) ;\n if ( ! minmxid_only ) PQclear ( executeQueryOrDie ( conn , \"UPDATE pg_catalog.pg_class \" \"SET relfrozenxid = '%u' \" \"WHERE relkind IN ('r', 'm', 't')\" , old_cluster . controldata . chkpnt_nxtxid ) ) ;\n PQclear ( executeQueryOrDie ( conn , \"UPDATE pg_catalog.pg_class \" \"SET relminmxid = '%u' \" \"WHERE relkind IN ('r', 'm', 't')\" , old_cluster . controldata . chkpnt_nxtmulti ) ) ;\n PQfinish ( conn ) ;\n if ( strcmp ( datallowconn , \"f\" ) == 0 ) PQclear ( executeQueryOrDie ( conn_template1 , \"ALTER DATABASE %s ALLOW_CONNECTIONS = false\" , quote_identifier ( datname ) ) ) ;\n }\n PQclear ( dbres ) ;\n PQfinish ( conn_template1 ) ;\n check_ok ( ) ;\n }", "idx": 22674}
{"hash": -8028756826159773630, "project": "debian", "size": 11, "label": 0, "functionSource": "size_t WriteStr ( ArchiveHandle * AH , const char * c ) {\n size_t res ;\n if ( c ) {\n int len = strlen ( c ) ;\n res = WriteInt ( AH , len ) ;\n ( * AH -> WriteBufPtr ) ( AH , c , len ) ;\n res += len ;\n }\n else res = WriteInt ( AH , - 1 ) ;\n return res ;\n }", "idx": 22675}
{"hash": -5390559971540708342, "project": "debian", "size": 46, "label": 0, "functionSource": "static void x8_get_ac_rlf ( IntraX8Context * const w , const int mode , int * const run , int * const level , int * const final ) {\n MpegEncContext * const s = w -> s ;\n int i , e ;\n i = get_vlc2 ( & s -> gb , w -> j_ac_vlc [ mode ] -> table , AC_VLC_BITS , AC_VLC_MTD ) ;\n if ( i < 46 ) {\n int t , l ;\n if ( i < 0 ) {\n ( * level ) = ( * final ) = ( * run ) = 64 ;\n return ;\n }\n ( * final ) = t = ( i > 22 ) ;\n i -= 23 * t ;\n l = ( 0xE50000 >> ( i & ( 0x1E ) ) ) & 3 ;\n t = ( 0x01030F >> ( l << 3 ) ) ;\n ( * run ) = i & t ;\n ( * level ) = l ;\n }\n else if ( i < 73 ) {\n uint32_t sm ;\n uint32_t mask ;\n i -= 46 ;\n sm = ac_decode_table [ i ] ;\n e = get_bits ( & s -> gb , sm & 0xF ) ;\n sm >>= 8 ;\n mask = sm & 0xff ;\n sm >>= 8 ;\n ( * run ) = ( sm & 0xff ) + ( e & ( mask ) ) ;\n ( * level ) = ( sm >> 8 ) + ( e & ( ~ mask ) ) ;\n ( * final ) = i > ( 58 - 46 ) ;\n }\n else if ( i < 75 ) {\n static const uint8_t crazy_mix_runlevel [ 32 ] = {\n 0x22 , 0x32 , 0x33 , 0x53 , 0x23 , 0x42 , 0x43 , 0x63 , 0x24 , 0x52 , 0x34 , 0x73 , 0x25 , 0x62 , 0x44 , 0x83 , 0x26 , 0x72 , 0x35 , 0x54 , 0x27 , 0x82 , 0x45 , 0x64 , 0x28 , 0x92 , 0x36 , 0x74 , 0x29 , 0xa2 , 0x46 , 0x84 }\n ;\n ( * final ) = ! ( i & 1 ) ;\n e = get_bits ( & s -> gb , 5 ) ;\n ( * run ) = crazy_mix_runlevel [ e ] >> 4 ;\n ( * level ) = crazy_mix_runlevel [ e ] & 0x0F ;\n }\n else {\n ( * level ) = get_bits ( & s -> gb , 7 - 3 * ( i & 1 ) ) ;\n ( * run ) = get_bits ( & s -> gb , 6 ) ;\n ( * final ) = get_bits1 ( & s -> gb ) ;\n }\n return ;\n }", "idx": 22676}
{"hash": -2386031673786599357, "project": "debian", "size": 7, "label": 0, "functionSource": "static void gpgsm_release ( void * engine ) {\n engine_gpgsm_t gpgsm = engine ;\n if ( ! gpgsm ) return ;\n gpgsm_cancel ( engine ) ;\n free ( gpgsm -> colon . attic . line ) ;\n free ( gpgsm ) ;\n }", "idx": 22677}
{"hash": 3071315158823512715, "project": "debian", "size": 19, "label": 0, "functionSource": "static void do_rematrixing ( AC3DecodeContext * s ) {\n int bnd , i ;\n int end , bndend ;\n end = FFMIN ( s -> end_freq [ 1 ] , s -> end_freq [ 2 ] ) ;\n for ( bnd = 0 ;\n bnd < s -> num_rematrixing_bands ;\n bnd ++ ) {\n if ( s -> rematrixing_flags [ bnd ] ) {\n bndend = FFMIN ( end , ff_ac3_rematrix_band_tab [ bnd + 1 ] ) ;\n for ( i = ff_ac3_rematrix_band_tab [ bnd ] ;\n i < bndend ;\n i ++ ) {\n int tmp0 = s -> fixed_coeffs [ 1 ] [ i ] ;\n s -> fixed_coeffs [ 1 ] [ i ] += s -> fixed_coeffs [ 2 ] [ i ] ;\n s -> fixed_coeffs [ 2 ] [ i ] = tmp0 - s -> fixed_coeffs [ 2 ] [ i ] ;\n }\n }\n }\n }", "idx": 22678}
{"hash": -5420171864670538459, "project": "debian", "size": 8, "label": 0, "functionSource": "void cpu_stop_current ( void ) {\n if ( current_cpu ) {\n current_cpu -> stop = false ;\n current_cpu -> stopped = true ;\n cpu_exit ( current_cpu ) ;\n qemu_cond_signal ( & qemu_pause_cond ) ;\n }\n }", "idx": 22679}
{"hash": 5045872831385413038, "project": "debian", "size": 21, "label": 0, "functionSource": "static bluetooth_uuid_t get_uuid_from_handle ( packet_info * pinfo , guint32 handle , bluetooth_data_t * bluetooth_data ) {\n wmem_tree_key_t key [ 4 ] ;\n guint32 frame_number ;\n handle_data_t * handle_data ;\n wmem_tree_t * sub_wmemtree ;\n bluetooth_uuid_t uuid ;\n memset ( & uuid , 0 , sizeof uuid ) ;\n frame_number = pinfo -> num ;\n key [ 0 ] . length = 1 ;\n key [ 0 ] . key = & bluetooth_data -> interface_id ;\n key [ 1 ] . length = 1 ;\n key [ 1 ] . key = & bluetooth_data -> adapter_id ;\n key [ 2 ] . length = 1 ;\n key [ 2 ] . key = & handle ;\n key [ 3 ] . length = 0 ;\n key [ 3 ] . key = NULL ;\n sub_wmemtree = ( wmem_tree_t * ) wmem_tree_lookup32_array ( handle_to_uuid , key ) ;\n handle_data = ( sub_wmemtree ) ? ( handle_data_t * ) wmem_tree_lookup32_le ( sub_wmemtree , frame_number ) : NULL ;\n if ( handle_data ) uuid = handle_data -> uuid ;\n return uuid ;\n }", "idx": 22680}
{"hash": 4198675434481816937, "project": "debian", "size": 20, "label": 0, "functionSource": "void IGDendelt ( void * d , const char * name , int l ) {\n struct IGDdatas * datas = ( struct IGDdatas * ) d ;\n datas -> level -- ;\n if ( ( l == 7 ) && ! memcmp ( name , \"service\" , l ) ) {\n if ( COMPARE ( datas -> tmp . servicetype , \"urn:schemas-upnp-org:service:WANCommonInterfaceConfig:\" ) ) {\n memcpy ( & datas -> CIF , & datas -> tmp , sizeof ( struct IGDdatas_service ) ) ;\n }\n else if ( COMPARE ( datas -> tmp . servicetype , \"urn:schemas-upnp-org:service:WANIPv6FirewallControl:\" ) ) {\n memcpy ( & datas -> IPv6FC , & datas -> tmp , sizeof ( struct IGDdatas_service ) ) ;\n }\n else if ( COMPARE ( datas -> tmp . servicetype , \"urn:schemas-upnp-org:service:WANIPConnection:\" ) || COMPARE ( datas -> tmp . servicetype , \"urn:schemas-upnp-org:service:WANPPPConnection:\" ) ) {\n if ( datas -> first . servicetype [ 0 ] == '\\0' ) {\n memcpy ( & datas -> first , & datas -> tmp , sizeof ( struct IGDdatas_service ) ) ;\n }\n else {\n memcpy ( & datas -> second , & datas -> tmp , sizeof ( struct IGDdatas_service ) ) ;\n }\n }\n }\n }", "idx": 22681}
{"hash": -3146697469509848825, "project": "debian", "size": 4, "label": 0, "functionSource": "static int dsa_cmp_parameters ( const EVP_PKEY * a , const EVP_PKEY * b ) {\n if ( BN_cmp ( a -> pkey . dsa -> p , b -> pkey . dsa -> p ) || BN_cmp ( a -> pkey . dsa -> q , b -> pkey . dsa -> q ) || BN_cmp ( a -> pkey . dsa -> g , b -> pkey . dsa -> g ) ) return 0 ;\n else return 1 ;\n }", "idx": 22682}
{"hash": 2546373479020365143, "project": "debian", "size": 20, "label": 0, "functionSource": "void mime_scanner_append ( MIMEScanner * scanner , const char * data , int data_size ) {\n int free_size = scanner -> m_line_size - scanner -> m_line_length ;\n if ( data_size > free_size ) {\n if ( scanner -> m_line_size == 0 ) {\n scanner -> m_line_size = 128 ;\n }\n while ( free_size < data_size ) {\n scanner -> m_line_size *= 2 ;\n free_size = scanner -> m_line_size - scanner -> m_line_length ;\n }\n if ( scanner -> m_line == nullptr ) {\n scanner -> m_line = ( char * ) ats_malloc ( scanner -> m_line_size ) ;\n }\n else {\n scanner -> m_line = ( char * ) ats_realloc ( scanner -> m_line , scanner -> m_line_size ) ;\n }\n }\n memcpy ( & ( scanner -> m_line [ scanner -> m_line_length ] ) , data , data_size ) ;\n scanner -> m_line_length += data_size ;\n }", "idx": 22683}
{"hash": -1487877838474751244, "project": "debian", "size": 64, "label": 0, "functionSource": "static int append_multiple_key_values ( smart_str * loc_name , HashTable * hash_arr , char * key_name TSRMLS_DC ) {\n zval * * ele_value = NULL ;\n int i = 0 ;\n int isFirstSubtag = 0 ;\n int max_value = 0 ;\n if ( zend_hash_find ( hash_arr , key_name , strlen ( key_name ) + 1 , ( void * * ) & ele_value ) == SUCCESS ) {\n if ( Z_TYPE_PP ( ele_value ) == IS_STRING ) {\n add_prefix ( loc_name , key_name ) ;\n smart_str_appendl ( loc_name , SEPARATOR , sizeof ( SEPARATOR ) - 1 ) ;\n smart_str_appendl ( loc_name , Z_STRVAL_PP ( ele_value ) , Z_STRLEN_PP ( ele_value ) ) ;\n return SUCCESS ;\n }\n else if ( Z_TYPE_PP ( ele_value ) == IS_ARRAY ) {\n HashPosition pos ;\n HashTable * arr = HASH_OF ( * ele_value ) ;\n zval * * data = NULL ;\n zend_hash_internal_pointer_reset_ex ( arr , & pos ) ;\n while ( zend_hash_get_current_data_ex ( arr , ( void * * ) & data , & pos ) != FAILURE ) {\n if ( Z_TYPE_PP ( data ) != IS_STRING ) {\n return FAILURE ;\n }\n if ( isFirstSubtag ++ == 0 ) {\n add_prefix ( loc_name , key_name ) ;\n }\n smart_str_appendl ( loc_name , SEPARATOR , sizeof ( SEPARATOR ) - 1 ) ;\n smart_str_appendl ( loc_name , Z_STRVAL_PP ( data ) , Z_STRLEN_PP ( data ) ) ;\n zend_hash_move_forward_ex ( arr , & pos ) ;\n }\n return SUCCESS ;\n }\n else {\n return FAILURE ;\n }\n }\n else {\n char cur_key_name [ 31 ] ;\n if ( strcmp ( key_name , LOC_VARIANT_TAG ) == 0 ) {\n max_value = MAX_NO_VARIANT ;\n }\n if ( strcmp ( key_name , LOC_EXTLANG_TAG ) == 0 ) {\n max_value = MAX_NO_EXTLANG ;\n }\n if ( strcmp ( key_name , LOC_PRIVATE_TAG ) == 0 ) {\n max_value = MAX_NO_PRIVATE ;\n }\n isFirstSubtag = 0 ;\n for ( i = 0 ;\n i < max_value ;\n i ++ ) {\n snprintf ( cur_key_name , 30 , \"%s%d\" , key_name , i ) ;\n if ( zend_hash_find ( hash_arr , cur_key_name , strlen ( cur_key_name ) + 1 , ( void * * ) & ele_value ) == SUCCESS ) {\n if ( Z_TYPE_PP ( ele_value ) != IS_STRING ) {\n return FAILURE ;\n }\n if ( isFirstSubtag ++ == 0 ) {\n add_prefix ( loc_name , cur_key_name ) ;\n }\n smart_str_appendl ( loc_name , SEPARATOR , sizeof ( SEPARATOR ) - 1 ) ;\n smart_str_appendl ( loc_name , Z_STRVAL_PP ( ele_value ) , Z_STRLEN_PP ( ele_value ) ) ;\n }\n }\n }\n return SUCCESS ;\n }", "idx": 22684}
{"hash": 5045872831385413038, "project": "debian", "size": 6, "label": 0, "functionSource": "static void btatt_handle_prompt ( packet_info * pinfo , gchar * result ) {\n guint16 * value_data ;\n value_data = ( guint16 * ) p_get_proto_data ( pinfo -> pool , pinfo , proto_btatt , PROTO_DATA_BTATT_HANDLE ) ;\n if ( value_data ) g_snprintf ( result , MAX_DECODE_AS_PROMPT_LEN , \"ATT Handle 0x%04x as\" , ( guint ) * value_data ) ;\n else g_snprintf ( result , MAX_DECODE_AS_PROMPT_LEN , \"Unknown ATT Handle\" ) ;\n }", "idx": 22685}
{"hash": -2943582541244387919, "project": "chrome", "size": 16, "label": 0, "functionSource": "void vp9_comp_avg_pred ( uint8_t * comp_pred , const uint8_t * pred , int width , int height , const uint8_t * ref , int ref_stride ) {\n int i , j ;\n for ( i = 0 ;\n i < height ;\n i ++ ) {\n for ( j = 0 ;\n j < width ;\n j ++ ) {\n const int tmp = pred [ j ] + ref [ j ] ;\n comp_pred [ j ] = ROUND_POWER_OF_TWO ( tmp , 1 ) ;\n }\n comp_pred += width ;\n pred += width ;\n ref += ref_stride ;\n }\n }", "idx": 22686}
{"hash": -866921002076081979, "project": "debian", "size": 74, "label": 0, "functionSource": "REGRESSION_TEST ( SDK_API_TSUrlParse ) ( RegressionTest * test , int , int * pstatus ) {\n static const char * const urls [ ] = {\n \"file:///test.dat;\nab?abc=def#abc\" , \"http://www.example.com/\" , \"http://abc:def@www.example.com/\" , \"http://www.example.com:3426/\" , \"http://abc:def@www.example.com:3426/\" , \"http://www.example.com/homepage.cgi\" , \"http://www.example.com/homepage.cgi;\nab?abc=def#abc\" , \"http://abc:def@www.example.com:3426/homepage.cgi;\nab?abc=def#abc\" , \"https://abc:def@www.example.com:3426/homepage.cgi;\nab?abc=def#abc\" , \"ftp://abc:def@www.example.com:3426/homepage.cgi;\nab?abc=def#abc\" , \"file:///c:/test.dat;\nab?abc=def#abc\" , \"file:///test.dat;\nab?abc=def#abc\" , \"foo://bar.com/baz/\" , \"http://a.b.com/xx.jpg?newpath=http://b.c.com\" }\n ;\n static int const num_urls = sizeof ( urls ) / sizeof ( urls [ 0 ] ) ;\n bool test_passed [ num_urls ] = {\n false }\n ;\n const char * start ;\n const char * end ;\n char * temp ;\n int retval ;\n TSMBuffer bufp ;\n TSMLoc url_loc = ( TSMLoc ) nullptr ;\n int length ;\n * pstatus = REGRESSION_TEST_INPROGRESS ;\n int idx ;\n for ( idx = 0 ;\n idx < num_urls ;\n idx ++ ) {\n const char * url = urls [ idx ] ;\n bufp = TSMBufferCreate ( ) ;\n if ( TSUrlCreate ( bufp , & url_loc ) != TS_SUCCESS ) {\n SDK_RPRINT ( test , \"TSUrlParse\" , url , TC_FAIL , \"Cannot create Url for parsing the url\" ) ;\n if ( TSMBufferDestroy ( bufp ) == TS_ERROR ) {\n SDK_RPRINT ( test , \"TSUrlParse\" , url , TC_FAIL , \"Error in Destroying MBuffer\" ) ;\n }\n }\n else {\n start = url ;\n end = url + strlen ( url ) ;\n if ( ( retval = TSUrlParse ( bufp , url_loc , & start , end ) ) == TS_PARSE_ERROR ) {\n SDK_RPRINT ( test , \"TSUrlParse\" , url , TC_FAIL , \"TSUrlParse returns TS_PARSE_ERROR\" ) ;\n }\n else {\n if ( retval == TS_PARSE_DONE ) {\n temp = TSUrlStringGet ( bufp , url_loc , & length ) ;\n if ( strncmp ( url , temp , length ) == 0 ) {\n SDK_RPRINT ( test , \"TSUrlParse\" , url , TC_PASS , \"ok\" ) ;\n test_passed [ idx ] = true ;\n }\n else {\n SDK_RPRINT ( test , \"TSUrlParse\" , url , TC_FAIL , \"Value's Mismatch\" ) ;\n }\n TSfree ( temp ) ;\n }\n else {\n SDK_RPRINT ( test , \"TSUrlParse\" , url , TC_FAIL , \"Parsing Error\" ) ;\n }\n }\n }\n TSHandleMLocRelease ( bufp , TS_NULL_MLOC , url_loc ) ;\n TSMBufferDestroy ( bufp ) ;\n }\n for ( idx = 0 ;\n idx < num_urls ;\n idx ++ ) {\n if ( test_passed [ idx ] != true ) {\n * pstatus = REGRESSION_TEST_FAILED ;\n break ;\n }\n }\n if ( idx >= num_urls ) {\n * pstatus = REGRESSION_TEST_PASSED ;\n }\n return ;\n }", "idx": 22687}
{"hash": 415966375198131126, "project": "debian", "size": 47, "label": 0, "functionSource": "void write_stats ( void ) {\n FILE * fp ;\n # ifdef DOSYNCTODR struct timeval tv ;\n # if ! defined ( VMS ) int prio_set ;\n # endif # ifdef HAVE_GETCLOCK struct timespec ts ;\n # endif int o_prio ;\n # if ! defined ( VMS ) errno = 0 ;\n prio_set = 0 ;\n o_prio = getpriority ( PRIO_PROCESS , 0 ) ;\n if ( ( errno == 0 ) && ( setpriority ( PRIO_PROCESS , 0 , - 20 ) == 0 ) ) prio_set = 1 ;\n # endif # ifdef HAVE_GETCLOCK ( void ) getclock ( TIMEOFDAY , & ts ) ;\n tv . tv_sec = ts . tv_sec ;\n tv . tv_usec = ts . tv_nsec / 1000 ;\n # else GETTIMEOFDAY ( & tv , ( struct timezone * ) NULL ) ;\n # endif if ( ntp_set_tod ( & tv , ( struct timezone * ) NULL ) != 0 ) msyslog ( LOG_ERR , \"can't sync battery time: %m\" ) ;\n # if ! defined ( VMS ) if ( prio_set ) setpriority ( PRIO_PROCESS , 0 , o_prio ) ;\n # endif # endif record_sys_stats ( ) ;\n if ( stats_drift_file != 0 ) {\n # ifdef DEBUG if ( debug ) printf ( \"write_stats: frequency %.6lf thresh %.6lf, freq %.6lf\\n\" , ( prev_drift_comp - drift_comp ) * 1e6 , wander_resid * 1e6 , drift_comp * 1e6 ) ;\n # endif if ( fabs ( prev_drift_comp - drift_comp ) < wander_resid ) {\n wander_resid *= 0.5 ;\n return ;\n }\n prev_drift_comp = drift_comp ;\n wander_resid = wander_threshold ;\n if ( ( fp = fopen ( stats_temp_file , \"w\" ) ) == NULL ) {\n msyslog ( LOG_ERR , \"frequency file %s: %m\" , stats_temp_file ) ;\n return ;\n }\n fprintf ( fp , \"%.3f\\n\" , drift_comp * 1e6 ) ;\n ( void ) fclose ( fp ) ;\n # ifdef SYS_WINNT if ( _unlink ( stats_drift_file ) ) msyslog ( LOG_WARNING , \"Unable to remove prior drift file %s, %m\" , stats_drift_file ) ;\n # endif # ifndef NO_RENAME if ( rename ( stats_temp_file , stats_drift_file ) ) msyslog ( LOG_WARNING , \"Unable to rename temp drift file %s to %s, %m\" , stats_temp_file , stats_drift_file ) ;\n # else if ( ( fp = fopen ( stats_drift_file , \"w\" ) ) == NULL ) {\n msyslog ( LOG_ERR , \"frequency file %s: %m\" , stats_drift_file ) ;\n return ;\n }\n # endif # if defined ( VMS ) {\n $DESCRIPTOR ( oldvers , \";\n-1\" ) ;\n struct dsc$descriptor driftdsc = {\n strlen ( stats_drift_file ) , 0 , 0 , stats_drift_file }\n ;\n while ( lib$delete_file ( & oldvers , & driftdsc ) & 1 ) ;\n }\n # endif }\n }", "idx": 22688}
{"hash": -7236893719053583356, "project": "debian", "size": 6, "label": 0, "functionSource": "static void dissect_zcl_color_control_move_color ( tvbuff_t * tvb , proto_tree * tree , guint * offset ) {\n proto_tree_add_item ( tree , hf_zbee_zcl_color_control_rate_X , tvb , * offset , 2 , ENC_LITTLE_ENDIAN ) ;\n * offset += 2 ;\n proto_tree_add_item ( tree , hf_zbee_zcl_color_control_rate_Y , tvb , * offset , 2 , ENC_LITTLE_ENDIAN ) ;\n * offset += 2 ;\n }", "idx": 22689}
{"hash": -8933711118846965366, "project": "debian", "size": 11, "label": 0, "functionSource": "static void cirrus_get_offsets ( VGACommonState * s1 , uint32_t * pline_offset , uint32_t * pstart_addr , uint32_t * pline_compare ) {\n CirrusVGAState * s = container_of ( s1 , CirrusVGAState , vga ) ;\n uint32_t start_addr , line_offset , line_compare ;\n line_offset = s -> vga . cr [ 0x13 ] | ( ( s -> vga . cr [ 0x1b ] & 0x10 ) << 4 ) ;\n line_offset <<= 3 ;\n * pline_offset = line_offset ;\n start_addr = ( s -> vga . cr [ 0x0c ] << 8 ) | s -> vga . cr [ 0x0d ] | ( ( s -> vga . cr [ 0x1b ] & 0x01 ) << 16 ) | ( ( s -> vga . cr [ 0x1b ] & 0x0c ) << 15 ) | ( ( s -> vga . cr [ 0x1d ] & 0x80 ) << 12 ) ;\n * pstart_addr = start_addr ;\n line_compare = s -> vga . cr [ 0x18 ] | ( ( s -> vga . cr [ 0x07 ] & 0x10 ) << 4 ) | ( ( s -> vga . cr [ 0x09 ] & 0x40 ) << 3 ) ;\n * pline_compare = line_compare ;\n }", "idx": 22690}
{"hash": 1223258652239369123, "project": "debian", "size": 7, "label": 1, "functionSource": "SPL_METHOD ( SplFileObject , rewind ) {\n spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n if ( zend_parse_parameters_none ( ) == FAILURE ) {\n return ;\n }\n spl_filesystem_file_rewind ( getThis ( ) , intern TSRMLS_CC ) ;\n }", "idx": 22691}
{"hash": -7415191846425595149, "project": "chrome", "size": 13, "label": 0, "functionSource": "void vp9_free_ref_frame_buffers ( VP9_COMMON * cm ) {\n int i ;\n for ( i = 0 ;\n i < FRAME_BUFFERS ;\n ++ i ) {\n vp9_free_frame_buffer ( & cm -> frame_bufs [ i ] . buf ) ;\n if ( cm -> frame_bufs [ i ] . ref_count > 0 && cm -> frame_bufs [ i ] . raw_frame_buffer . data != NULL ) {\n cm -> release_fb_cb ( cm -> cb_priv , & cm -> frame_bufs [ i ] . raw_frame_buffer ) ;\n cm -> frame_bufs [ i ] . ref_count = 0 ;\n }\n }\n vp9_free_frame_buffer ( & cm -> post_proc_buffer ) ;\n }", "idx": 22692}
{"hash": -3384986069176965684, "project": "chrome", "size": 3, "label": 0, "functionSource": "int vp8_get_quantizer ( VP8_COMP * cpi ) {\n return cpi -> common . base_qindex ;\n }", "idx": 22693}
{"hash": -6215323349888018447, "project": "debian", "size": 25, "label": 0, "functionSource": "static void dumpUserConfig ( PGconn * conn , const char * username ) {\n PQExpBuffer buf = createPQExpBuffer ( ) ;\n int count = 1 ;\n for ( ;\n ;\n ) {\n PGresult * res ;\n if ( server_version >= 90000 ) printfPQExpBuffer ( buf , \"SELECT setconfig[%d] FROM pg_db_role_setting WHERE \" \"setdatabase = 0 AND setrole = \" \"(SELECT oid FROM pg_authid WHERE rolname = \" , count ) ;\n else if ( server_version >= 80100 ) printfPQExpBuffer ( buf , \"SELECT rolconfig[%d] FROM pg_authid WHERE rolname = \" , count ) ;\n else printfPQExpBuffer ( buf , \"SELECT useconfig[%d] FROM pg_shadow WHERE usename = \" , count ) ;\n appendStringLiteralConn ( buf , username , conn ) ;\n if ( server_version >= 90000 ) appendPQExpBufferChar ( buf , ')' ) ;\n res = executeQuery ( conn , buf -> data ) ;\n if ( PQntuples ( res ) == 1 && ! PQgetisnull ( res , 0 , 0 ) ) {\n makeAlterConfigCommand ( conn , PQgetvalue ( res , 0 , 0 ) , \"ROLE\" , username , NULL , NULL ) ;\n PQclear ( res ) ;\n count ++ ;\n }\n else {\n PQclear ( res ) ;\n break ;\n }\n }\n destroyPQExpBuffer ( buf ) ;\n }", "idx": 22694}
{"hash": 4561548163749120103, "project": "chrome", "size": 104, "label": 1, "functionSource": "static int decode_coefs ( VP9_COMMON * cm , const MACROBLOCKD * xd , PLANE_TYPE type , int16_t * dqcoeff , TX_SIZE tx_size , const int16_t * dq , int ctx , const int16_t * scan , const int16_t * nb , vp9_reader * r ) {\n const int max_eob = 16 << ( tx_size << 1 ) ;\n const FRAME_CONTEXT * const fc = & cm -> fc ;\n FRAME_COUNTS * const counts = & cm -> counts ;\n const int ref = is_inter_block ( & xd -> mi [ 0 ] -> mbmi ) ;\n int band , c = 0 ;\n const vp9_prob ( * coef_probs ) [ COEFF_CONTEXTS ] [ UNCONSTRAINED_NODES ] = fc -> coef_probs [ tx_size ] [ type ] [ ref ] ;\n const vp9_prob * prob ;\n unsigned int ( * coef_counts ) [ COEFF_CONTEXTS ] [ UNCONSTRAINED_NODES + 1 ] = counts -> coef [ tx_size ] [ type ] [ ref ] ;\n unsigned int ( * eob_branch_count ) [ COEFF_CONTEXTS ] = counts -> eob_branch [ tx_size ] [ type ] [ ref ] ;\n uint8_t token_cache [ 32 * 32 ] ;\n const uint8_t * band_translate = get_band_translate ( tx_size ) ;\n const int dq_shift = ( tx_size == TX_32X32 ) ;\n int v ;\n int16_t dqv = dq [ 0 ] ;\n while ( c < max_eob ) {\n int val ;\n band = * band_translate ++ ;\n prob = coef_probs [ band ] [ ctx ] ;\n if ( ! cm -> frame_parallel_decoding_mode ) ++ eob_branch_count [ band ] [ ctx ] ;\n if ( ! vp9_read ( r , prob [ EOB_CONTEXT_NODE ] ) ) {\n INCREMENT_COUNT ( EOB_MODEL_TOKEN ) ;\n break ;\n }\n while ( ! vp9_read ( r , prob [ ZERO_CONTEXT_NODE ] ) ) {\n INCREMENT_COUNT ( ZERO_TOKEN ) ;\n dqv = dq [ 1 ] ;\n token_cache [ scan [ c ] ] = 0 ;\n ++ c ;\n if ( c >= max_eob ) return c ;\n ctx = get_coef_context ( nb , token_cache , c ) ;\n band = * band_translate ++ ;\n prob = coef_probs [ band ] [ ctx ] ;\n }\n if ( ! vp9_read ( r , prob [ ONE_CONTEXT_NODE ] ) ) {\n INCREMENT_COUNT ( ONE_TOKEN ) ;\n WRITE_COEF_CONTINUE ( 1 , ONE_TOKEN ) ;\n }\n INCREMENT_COUNT ( TWO_TOKEN ) ;\n prob = vp9_pareto8_full [ prob [ PIVOT_NODE ] - 1 ] ;\n if ( ! vp9_read ( r , prob [ LOW_VAL_CONTEXT_NODE ] ) ) {\n if ( ! vp9_read ( r , prob [ TWO_CONTEXT_NODE ] ) ) {\n WRITE_COEF_CONTINUE ( 2 , TWO_TOKEN ) ;\n }\n if ( ! vp9_read ( r , prob [ THREE_CONTEXT_NODE ] ) ) {\n WRITE_COEF_CONTINUE ( 3 , THREE_TOKEN ) ;\n }\n WRITE_COEF_CONTINUE ( 4 , FOUR_TOKEN ) ;\n }\n if ( ! vp9_read ( r , prob [ HIGH_LOW_CONTEXT_NODE ] ) ) {\n if ( ! vp9_read ( r , prob [ CAT_ONE_CONTEXT_NODE ] ) ) {\n val = CAT1_MIN_VAL ;\n ADJUST_COEF ( vp9_cat1_prob [ 0 ] , 0 ) ;\n WRITE_COEF_CONTINUE ( val , CATEGORY1_TOKEN ) ;\n }\n val = CAT2_MIN_VAL ;\n ADJUST_COEF ( vp9_cat2_prob [ 0 ] , 1 ) ;\n ADJUST_COEF ( vp9_cat2_prob [ 1 ] , 0 ) ;\n WRITE_COEF_CONTINUE ( val , CATEGORY2_TOKEN ) ;\n }\n if ( ! vp9_read ( r , prob [ CAT_THREEFOUR_CONTEXT_NODE ] ) ) {\n if ( ! vp9_read ( r , prob [ CAT_THREE_CONTEXT_NODE ] ) ) {\n val = CAT3_MIN_VAL ;\n ADJUST_COEF ( vp9_cat3_prob [ 0 ] , 2 ) ;\n ADJUST_COEF ( vp9_cat3_prob [ 1 ] , 1 ) ;\n ADJUST_COEF ( vp9_cat3_prob [ 2 ] , 0 ) ;\n WRITE_COEF_CONTINUE ( val , CATEGORY3_TOKEN ) ;\n }\n val = CAT4_MIN_VAL ;\n ADJUST_COEF ( vp9_cat4_prob [ 0 ] , 3 ) ;\n ADJUST_COEF ( vp9_cat4_prob [ 1 ] , 2 ) ;\n ADJUST_COEF ( vp9_cat4_prob [ 2 ] , 1 ) ;\n ADJUST_COEF ( vp9_cat4_prob [ 3 ] , 0 ) ;\n WRITE_COEF_CONTINUE ( val , CATEGORY4_TOKEN ) ;\n }\n if ( ! vp9_read ( r , prob [ CAT_FIVE_CONTEXT_NODE ] ) ) {\n val = CAT5_MIN_VAL ;\n ADJUST_COEF ( vp9_cat5_prob [ 0 ] , 4 ) ;\n ADJUST_COEF ( vp9_cat5_prob [ 1 ] , 3 ) ;\n ADJUST_COEF ( vp9_cat5_prob [ 2 ] , 2 ) ;\n ADJUST_COEF ( vp9_cat5_prob [ 3 ] , 1 ) ;\n ADJUST_COEF ( vp9_cat5_prob [ 4 ] , 0 ) ;\n WRITE_COEF_CONTINUE ( val , CATEGORY5_TOKEN ) ;\n }\n val = 0 ;\n val = ( val << 1 ) | vp9_read ( r , vp9_cat6_prob [ 0 ] ) ;\n val = ( val << 1 ) | vp9_read ( r , vp9_cat6_prob [ 1 ] ) ;\n val = ( val << 1 ) | vp9_read ( r , vp9_cat6_prob [ 2 ] ) ;\n val = ( val << 1 ) | vp9_read ( r , vp9_cat6_prob [ 3 ] ) ;\n val = ( val << 1 ) | vp9_read ( r , vp9_cat6_prob [ 4 ] ) ;\n val = ( val << 1 ) | vp9_read ( r , vp9_cat6_prob [ 5 ] ) ;\n val = ( val << 1 ) | vp9_read ( r , vp9_cat6_prob [ 6 ] ) ;\n val = ( val << 1 ) | vp9_read ( r , vp9_cat6_prob [ 7 ] ) ;\n val = ( val << 1 ) | vp9_read ( r , vp9_cat6_prob [ 8 ] ) ;\n val = ( val << 1 ) | vp9_read ( r , vp9_cat6_prob [ 9 ] ) ;\n val = ( val << 1 ) | vp9_read ( r , vp9_cat6_prob [ 10 ] ) ;\n val = ( val << 1 ) | vp9_read ( r , vp9_cat6_prob [ 11 ] ) ;\n val = ( val << 1 ) | vp9_read ( r , vp9_cat6_prob [ 12 ] ) ;\n val = ( val << 1 ) | vp9_read ( r , vp9_cat6_prob [ 13 ] ) ;\n val += CAT6_MIN_VAL ;\n WRITE_COEF_CONTINUE ( val , CATEGORY6_TOKEN ) ;\n }\n return c ;\n }", "idx": 22695}
{"hash": 8895005875911486570, "project": "debian", "size": 36, "label": 0, "functionSource": "static void curses_connection_data_join ( void ) {\n char src [ MAX_ASCII_ADDR_LEN ] ;\n char dst [ MAX_ASCII_ADDR_LEN ] ;\n char title [ 64 ] ;\n DEBUG_MSG ( \"curses_connection_data_join\" ) ;\n if ( wdg_conndata ) {\n struct conn_object * tmp_conn = curr_conn ;\n wdg_destroy_object ( & wdg_conndata ) ;\n curses_destroy_conndata ( ) ;\n curr_conn = tmp_conn ;\n }\n curr_conn -> flags |= CONN_VIEWING ;\n wdg_create_object ( & wdg_conndata , WDG_COMPOUND , WDG_OBJ_WANT_FOCUS ) ;\n wdg_set_color ( wdg_conndata , WDG_COLOR_SCREEN , EC_COLOR ) ;\n wdg_set_color ( wdg_conndata , WDG_COLOR_WINDOW , EC_COLOR ) ;\n wdg_set_color ( wdg_conndata , WDG_COLOR_FOCUS , EC_COLOR_FOCUS ) ;\n wdg_set_color ( wdg_conndata , WDG_COLOR_TITLE , EC_COLOR_TITLE ) ;\n wdg_set_title ( wdg_conndata , \"Connection data\" , WDG_ALIGN_LEFT ) ;\n wdg_set_size ( wdg_conndata , 1 , 2 , - 1 , SYSMSG_WIN_SIZE - 1 ) ;\n wdg_create_object ( & wdg_join , WDG_SCROLL , 0 ) ;\n snprintf ( title , 64 , \"%s:%d - %s:%d\" , ip_addr_ntoa ( & curr_conn -> L3_addr1 , src ) , ntohs ( curr_conn -> L4_addr1 ) , ip_addr_ntoa ( & curr_conn -> L3_addr2 , dst ) , ntohs ( curr_conn -> L4_addr2 ) ) ;\n wdg_set_title ( wdg_join , title , WDG_ALIGN_LEFT ) ;\n wdg_set_color ( wdg_join , WDG_COLOR_TITLE , EC_COLOR_TITLE ) ;\n wdg_set_color ( wdg_join , WDG_COLOR_FOCUS , EC_COLOR_FOCUS ) ;\n wdg_set_size ( wdg_join , 2 , 3 , - 2 , SYSMSG_WIN_SIZE - 2 ) ;\n wdg_scroll_set_lines ( wdg_join , GBL_CONF -> connection_buffer / ( current_screen . cols / 2 ) ) ;\n wdg_compound_add ( wdg_conndata , wdg_join ) ;\n wdg_add_destroy_key ( wdg_conndata , CTRL ( 'Q' ) , curses_destroy_conndata ) ;\n wdg_compound_add_callback ( wdg_conndata , 'j' , curses_connection_data_split ) ;\n wdg_compound_add_callback ( wdg_conndata , 'k' , curses_connection_kill_wrapper ) ;\n wdg_compound_add_callback ( wdg_conndata , ' ' , curses_connection_data_help ) ;\n wdg_draw_object ( wdg_conndata ) ;\n wdg_set_focus ( wdg_conndata ) ;\n connbuf_print ( & curr_conn -> data , join_print ) ;\n conntrack_hook_conn_add ( curr_conn , join_print_po ) ;\n }", "idx": 22696}
{"hash": 1859256631654516868, "project": "chrome", "size": 119, "label": 0, "functionSource": "static void decode_postinit ( H264Context * h , int setup_finished ) {\n Picture * out = h -> cur_pic_ptr ;\n Picture * cur = h -> cur_pic_ptr ;\n int i , pics , out_of_order , out_idx ;\n h -> cur_pic_ptr -> f . pict_type = h -> pict_type ;\n if ( h -> next_output_pic ) return ;\n if ( cur -> field_poc [ 0 ] == INT_MAX || cur -> field_poc [ 1 ] == INT_MAX ) {\n return ;\n }\n cur -> f . interlaced_frame = 0 ;\n cur -> f . repeat_pict = 0 ;\n if ( h -> sps . pic_struct_present_flag ) {\n switch ( h -> sei_pic_struct ) {\n case SEI_PIC_STRUCT_FRAME : break ;\n case SEI_PIC_STRUCT_TOP_FIELD : case SEI_PIC_STRUCT_BOTTOM_FIELD : cur -> f . interlaced_frame = 1 ;\n break ;\n case SEI_PIC_STRUCT_TOP_BOTTOM : case SEI_PIC_STRUCT_BOTTOM_TOP : if ( FIELD_OR_MBAFF_PICTURE ( h ) ) cur -> f . interlaced_frame = 1 ;\n else cur -> f . interlaced_frame = h -> prev_interlaced_frame ;\n break ;\n case SEI_PIC_STRUCT_TOP_BOTTOM_TOP : case SEI_PIC_STRUCT_BOTTOM_TOP_BOTTOM : cur -> f . repeat_pict = 1 ;\n break ;\n case SEI_PIC_STRUCT_FRAME_DOUBLING : cur -> f . repeat_pict = 2 ;\n break ;\n case SEI_PIC_STRUCT_FRAME_TRIPLING : cur -> f . repeat_pict = 4 ;\n break ;\n }\n if ( ( h -> sei_ct_type & 3 ) && h -> sei_pic_struct <= SEI_PIC_STRUCT_BOTTOM_TOP ) cur -> f . interlaced_frame = ( h -> sei_ct_type & ( 1 << 1 ) ) != 0 ;\n }\n else {\n cur -> f . interlaced_frame = FIELD_OR_MBAFF_PICTURE ( h ) ;\n }\n h -> prev_interlaced_frame = cur -> f . interlaced_frame ;\n if ( cur -> field_poc [ 0 ] != cur -> field_poc [ 1 ] ) {\n cur -> f . top_field_first = cur -> field_poc [ 0 ] < cur -> field_poc [ 1 ] ;\n }\n else {\n if ( cur -> f . interlaced_frame || h -> sps . pic_struct_present_flag ) {\n if ( h -> sei_pic_struct == SEI_PIC_STRUCT_TOP_BOTTOM || h -> sei_pic_struct == SEI_PIC_STRUCT_TOP_BOTTOM_TOP ) cur -> f . top_field_first = 1 ;\n else cur -> f . top_field_first = 0 ;\n }\n else {\n cur -> f . top_field_first = 0 ;\n }\n }\n cur -> mmco_reset = h -> mmco_reset ;\n h -> mmco_reset = 0 ;\n if ( h -> sps . bitstream_restriction_flag && h -> avctx -> has_b_frames < h -> sps . num_reorder_frames ) {\n h -> avctx -> has_b_frames = h -> sps . num_reorder_frames ;\n h -> low_delay = 0 ;\n }\n if ( h -> avctx -> strict_std_compliance >= FF_COMPLIANCE_STRICT && ! h -> sps . bitstream_restriction_flag ) {\n h -> avctx -> has_b_frames = MAX_DELAYED_PIC_COUNT - 1 ;\n h -> low_delay = 0 ;\n }\n for ( i = 0 ;\n 1 ;\n i ++ ) {\n if ( i == MAX_DELAYED_PIC_COUNT || cur -> poc < h -> last_pocs [ i ] ) {\n if ( i ) h -> last_pocs [ i - 1 ] = cur -> poc ;\n break ;\n }\n else if ( i ) {\n h -> last_pocs [ i - 1 ] = h -> last_pocs [ i ] ;\n }\n }\n out_of_order = MAX_DELAYED_PIC_COUNT - i ;\n if ( cur -> f . pict_type == AV_PICTURE_TYPE_B || ( h -> last_pocs [ MAX_DELAYED_PIC_COUNT - 2 ] > INT_MIN && h -> last_pocs [ MAX_DELAYED_PIC_COUNT - 1 ] - h -> last_pocs [ MAX_DELAYED_PIC_COUNT - 2 ] > 2 ) ) out_of_order = FFMAX ( out_of_order , 1 ) ;\n if ( out_of_order == MAX_DELAYED_PIC_COUNT ) {\n av_log ( h -> avctx , AV_LOG_VERBOSE , \"Invalid POC %d<%d\\n\" , cur -> poc , h -> last_pocs [ 0 ] ) ;\n for ( i = 1 ;\n i < MAX_DELAYED_PIC_COUNT ;\n i ++ ) h -> last_pocs [ i ] = INT_MIN ;\n h -> last_pocs [ 0 ] = cur -> poc ;\n cur -> mmco_reset = 1 ;\n }\n else if ( h -> avctx -> has_b_frames < out_of_order && ! h -> sps . bitstream_restriction_flag ) {\n av_log ( h -> avctx , AV_LOG_VERBOSE , \"Increasing reorder buffer to %d\\n\" , out_of_order ) ;\n h -> avctx -> has_b_frames = out_of_order ;\n h -> low_delay = 0 ;\n }\n pics = 0 ;\n while ( h -> delayed_pic [ pics ] ) pics ++ ;\n av_assert0 ( pics <= MAX_DELAYED_PIC_COUNT ) ;\n h -> delayed_pic [ pics ++ ] = cur ;\n if ( cur -> reference == 0 ) cur -> reference = DELAYED_PIC_REF ;\n out = h -> delayed_pic [ 0 ] ;\n out_idx = 0 ;\n for ( i = 1 ;\n h -> delayed_pic [ i ] && ! h -> delayed_pic [ i ] -> f . key_frame && ! h -> delayed_pic [ i ] -> mmco_reset ;\n i ++ ) if ( h -> delayed_pic [ i ] -> poc < out -> poc ) {\n out = h -> delayed_pic [ i ] ;\n out_idx = i ;\n }\n if ( h -> avctx -> has_b_frames == 0 && ( h -> delayed_pic [ 0 ] -> f . key_frame || h -> delayed_pic [ 0 ] -> mmco_reset ) ) h -> next_outputed_poc = INT_MIN ;\n out_of_order = out -> poc < h -> next_outputed_poc ;\n if ( out_of_order || pics > h -> avctx -> has_b_frames ) {\n out -> reference &= ~ DELAYED_PIC_REF ;\n for ( i = out_idx ;\n h -> delayed_pic [ i ] ;\n i ++ ) h -> delayed_pic [ i ] = h -> delayed_pic [ i + 1 ] ;\n }\n if ( ! out_of_order && pics > h -> avctx -> has_b_frames ) {\n h -> next_output_pic = out ;\n if ( out_idx == 0 && h -> delayed_pic [ 0 ] && ( h -> delayed_pic [ 0 ] -> f . key_frame || h -> delayed_pic [ 0 ] -> mmco_reset ) ) {\n h -> next_outputed_poc = INT_MIN ;\n }\n else h -> next_outputed_poc = out -> poc ;\n }\n else {\n av_log ( h -> avctx , AV_LOG_DEBUG , \"no picture %s\\n\" , out_of_order ? \"ooo\" : \"\" ) ;\n }\n if ( h -> next_output_pic ) {\n if ( h -> next_output_pic -> recovered ) {\n h -> frame_recovered |= FRAME_RECOVERED_SEI ;\n }\n h -> next_output_pic -> recovered |= ! ! ( h -> frame_recovered & FRAME_RECOVERED_SEI ) ;\n }\n if ( setup_finished && ! h -> avctx -> hwaccel ) ff_thread_finish_setup ( h -> avctx ) ;\n }", "idx": 22697}
{"hash": -6119142299306266167, "project": "debian", "size": 6, "label": 0, "functionSource": "static int zcountexecstack1 ( i_ctx_t * i_ctx_p ) {\n os_ptr op = osp ;\n check_type ( * op , t_boolean ) ;\n make_int ( op , count_exec_stack ( i_ctx_p , op -> value . boolval ) ) ;\n return 0 ;\n }", "idx": 22698}
{"hash": -5279853345356125001, "project": "debian", "size": 21, "label": 0, "functionSource": "void pim_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , const u_char * bp2 ) {\n register const u_char * ep ;\n register const struct pim * pim = ( const struct pim * ) bp ;\n ep = ( const u_char * ) ndo -> ndo_snapend ;\n if ( bp >= ep ) return ;\n # ifdef notyet ND_TCHECK ( pim -> pim_rsv ) ;\n # endif switch ( PIM_VER ( pim -> pim_typever ) ) {\n case 2 : if ( ! ndo -> ndo_vflag ) {\n ND_PRINT ( ( ndo , \"PIMv%u, %s, length %u\" , PIM_VER ( pim -> pim_typever ) , tok2str ( pimv2_type_values , \"Unknown Type\" , PIM_TYPE ( pim -> pim_typever ) ) , len ) ) ;\n return ;\n }\n else {\n ND_PRINT ( ( ndo , \"PIMv%u, length %u\\n\\t%s\" , PIM_VER ( pim -> pim_typever ) , len , tok2str ( pimv2_type_values , \"Unknown Type\" , PIM_TYPE ( pim -> pim_typever ) ) ) ) ;\n pimv2_print ( ndo , bp , len , bp2 ) ;\n }\n break ;\n default : ND_PRINT ( ( ndo , \"PIMv%u, length %u\" , PIM_VER ( pim -> pim_typever ) , len ) ) ;\n break ;\n }\n return ;\n }", "idx": 22699}
{"hash": -3559021711340554904, "project": "debian", "size": 475, "label": 0, "functionSource": "static Node * eval_const_expressions_mutator ( Node * node , eval_const_expressions_context * context ) {\n if ( node == NULL ) return NULL ;\n switch ( nodeTag ( node ) ) {\n case T_Param : {\n Param * param = ( Param * ) node ;\n if ( param -> paramkind == PARAM_EXTERN && context -> boundParams != NULL && param -> paramid > 0 && param -> paramid <= context -> boundParams -> numParams ) {\n ParamExternData * prm = & context -> boundParams -> params [ param -> paramid - 1 ] ;\n if ( OidIsValid ( prm -> ptype ) ) {\n if ( context -> estimate || ( prm -> pflags & PARAM_FLAG_CONST ) ) {\n int16 typLen ;\n bool typByVal ;\n Datum pval ;\n Assert ( prm -> ptype == param -> paramtype ) ;\n get_typlenbyval ( param -> paramtype , & typLen , & typByVal ) ;\n if ( prm -> isnull || typByVal ) pval = prm -> value ;\n else pval = datumCopy ( prm -> value , typByVal , typLen ) ;\n return ( Node * ) makeConst ( param -> paramtype , param -> paramtypmod , param -> paramcollid , ( int ) typLen , pval , prm -> isnull , typByVal ) ;\n }\n }\n }\n return ( Node * ) copyObject ( param ) ;\n }\n case T_WindowFunc : {\n WindowFunc * expr = ( WindowFunc * ) node ;\n Oid funcid = expr -> winfnoid ;\n List * args ;\n Expr * aggfilter ;\n HeapTuple func_tuple ;\n WindowFunc * newexpr ;\n func_tuple = SearchSysCache1 ( PROCOID , ObjectIdGetDatum ( funcid ) ) ;\n if ( ! HeapTupleIsValid ( func_tuple ) ) elog ( ERROR , \"cache lookup failed for function %u\" , funcid ) ;\n args = expand_function_arguments ( expr -> args , expr -> wintype , func_tuple ) ;\n ReleaseSysCache ( func_tuple ) ;\n args = ( List * ) expression_tree_mutator ( ( Node * ) args , eval_const_expressions_mutator , ( void * ) context ) ;\n aggfilter = ( Expr * ) eval_const_expressions_mutator ( ( Node * ) expr -> aggfilter , context ) ;\n newexpr = makeNode ( WindowFunc ) ;\n newexpr -> winfnoid = expr -> winfnoid ;\n newexpr -> wintype = expr -> wintype ;\n newexpr -> wincollid = expr -> wincollid ;\n newexpr -> inputcollid = expr -> inputcollid ;\n newexpr -> args = args ;\n newexpr -> aggfilter = aggfilter ;\n newexpr -> winref = expr -> winref ;\n newexpr -> winstar = expr -> winstar ;\n newexpr -> winagg = expr -> winagg ;\n newexpr -> location = expr -> location ;\n return ( Node * ) newexpr ;\n }\n case T_FuncExpr : {\n FuncExpr * expr = ( FuncExpr * ) node ;\n List * args = expr -> args ;\n Expr * simple ;\n FuncExpr * newexpr ;\n simple = simplify_function ( expr -> funcid , expr -> funcresulttype , exprTypmod ( node ) , expr -> funccollid , expr -> inputcollid , & args , expr -> funcvariadic , true , true , context ) ;\n if ( simple ) return ( Node * ) simple ;\n newexpr = makeNode ( FuncExpr ) ;\n newexpr -> funcid = expr -> funcid ;\n newexpr -> funcresulttype = expr -> funcresulttype ;\n newexpr -> funcretset = expr -> funcretset ;\n newexpr -> funcvariadic = expr -> funcvariadic ;\n newexpr -> funcformat = expr -> funcformat ;\n newexpr -> funccollid = expr -> funccollid ;\n newexpr -> inputcollid = expr -> inputcollid ;\n newexpr -> args = args ;\n newexpr -> location = expr -> location ;\n return ( Node * ) newexpr ;\n }\n case T_OpExpr : {\n OpExpr * expr = ( OpExpr * ) node ;\n List * args = expr -> args ;\n Expr * simple ;\n OpExpr * newexpr ;\n set_opfuncid ( expr ) ;\n simple = simplify_function ( expr -> opfuncid , expr -> opresulttype , - 1 , expr -> opcollid , expr -> inputcollid , & args , false , true , true , context ) ;\n if ( simple ) return ( Node * ) simple ;\n if ( expr -> opno == BooleanEqualOperator || expr -> opno == BooleanNotEqualOperator ) {\n simple = ( Expr * ) simplify_boolean_equality ( expr -> opno , args ) ;\n if ( simple ) return ( Node * ) simple ;\n }\n newexpr = makeNode ( OpExpr ) ;\n newexpr -> opno = expr -> opno ;\n newexpr -> opfuncid = expr -> opfuncid ;\n newexpr -> opresulttype = expr -> opresulttype ;\n newexpr -> opretset = expr -> opretset ;\n newexpr -> opcollid = expr -> opcollid ;\n newexpr -> inputcollid = expr -> inputcollid ;\n newexpr -> args = args ;\n newexpr -> location = expr -> location ;\n return ( Node * ) newexpr ;\n }\n case T_DistinctExpr : {\n DistinctExpr * expr = ( DistinctExpr * ) node ;\n List * args ;\n ListCell * arg ;\n bool has_null_input = false ;\n bool all_null_input = true ;\n bool has_nonconst_input = false ;\n Expr * simple ;\n DistinctExpr * newexpr ;\n args = ( List * ) expression_tree_mutator ( ( Node * ) expr -> args , eval_const_expressions_mutator , ( void * ) context ) ;\n foreach ( arg , args ) {\n if ( IsA ( lfirst ( arg ) , Const ) ) {\n has_null_input |= ( ( Const * ) lfirst ( arg ) ) -> constisnull ;\n all_null_input &= ( ( Const * ) lfirst ( arg ) ) -> constisnull ;\n }\n else has_nonconst_input = true ;\n }\n if ( ! has_nonconst_input ) {\n if ( all_null_input ) return makeBoolConst ( false , false ) ;\n if ( has_null_input ) return makeBoolConst ( true , false ) ;\n set_opfuncid ( ( OpExpr * ) expr ) ;\n simple = simplify_function ( expr -> opfuncid , expr -> opresulttype , - 1 , expr -> opcollid , expr -> inputcollid , & args , false , false , false , context ) ;\n if ( simple ) {\n Const * csimple = ( Const * ) simple ;\n Assert ( IsA ( csimple , Const ) ) ;\n csimple -> constvalue = BoolGetDatum ( ! DatumGetBool ( csimple -> constvalue ) ) ;\n return ( Node * ) csimple ;\n }\n }\n newexpr = makeNode ( DistinctExpr ) ;\n newexpr -> opno = expr -> opno ;\n newexpr -> opfuncid = expr -> opfuncid ;\n newexpr -> opresulttype = expr -> opresulttype ;\n newexpr -> opretset = expr -> opretset ;\n newexpr -> opcollid = expr -> opcollid ;\n newexpr -> inputcollid = expr -> inputcollid ;\n newexpr -> args = args ;\n newexpr -> location = expr -> location ;\n return ( Node * ) newexpr ;\n }\n case T_BoolExpr : {\n BoolExpr * expr = ( BoolExpr * ) node ;\n switch ( expr -> boolop ) {\n case OR_EXPR : {\n List * newargs ;\n bool haveNull = false ;\n bool forceTrue = false ;\n newargs = simplify_or_arguments ( expr -> args , context , & haveNull , & forceTrue ) ;\n if ( forceTrue ) return makeBoolConst ( true , false ) ;\n if ( haveNull ) newargs = lappend ( newargs , makeBoolConst ( false , true ) ) ;\n if ( newargs == NIL ) return makeBoolConst ( false , false ) ;\n if ( list_length ( newargs ) == 1 ) return ( Node * ) linitial ( newargs ) ;\n return ( Node * ) make_orclause ( newargs ) ;\n }\n case AND_EXPR : {\n List * newargs ;\n bool haveNull = false ;\n bool forceFalse = false ;\n newargs = simplify_and_arguments ( expr -> args , context , & haveNull , & forceFalse ) ;\n if ( forceFalse ) return makeBoolConst ( false , false ) ;\n if ( haveNull ) newargs = lappend ( newargs , makeBoolConst ( false , true ) ) ;\n if ( newargs == NIL ) return makeBoolConst ( true , false ) ;\n if ( list_length ( newargs ) == 1 ) return ( Node * ) linitial ( newargs ) ;\n return ( Node * ) make_andclause ( newargs ) ;\n }\n case NOT_EXPR : {\n Node * arg ;\n Assert ( list_length ( expr -> args ) == 1 ) ;\n arg = eval_const_expressions_mutator ( linitial ( expr -> args ) , context ) ;\n return negate_clause ( arg ) ;\n }\n default : elog ( ERROR , \"unrecognized boolop: %d\" , ( int ) expr -> boolop ) ;\n break ;\n }\n break ;\n }\n case T_SubPlan : case T_AlternativeSubPlan : return node ;\n case T_RelabelType : {\n RelabelType * relabel = ( RelabelType * ) node ;\n Node * arg ;\n arg = eval_const_expressions_mutator ( ( Node * ) relabel -> arg , context ) ;\n while ( arg && IsA ( arg , RelabelType ) ) arg = ( Node * ) ( ( RelabelType * ) arg ) -> arg ;\n if ( arg && IsA ( arg , Const ) ) {\n Const * con = ( Const * ) arg ;\n con -> consttype = relabel -> resulttype ;\n con -> consttypmod = relabel -> resulttypmod ;\n con -> constcollid = relabel -> resultcollid ;\n return ( Node * ) con ;\n }\n else {\n RelabelType * newrelabel = makeNode ( RelabelType ) ;\n newrelabel -> arg = ( Expr * ) arg ;\n newrelabel -> resulttype = relabel -> resulttype ;\n newrelabel -> resulttypmod = relabel -> resulttypmod ;\n newrelabel -> resultcollid = relabel -> resultcollid ;\n newrelabel -> relabelformat = relabel -> relabelformat ;\n newrelabel -> location = relabel -> location ;\n return ( Node * ) newrelabel ;\n }\n }\n case T_CoerceViaIO : {\n CoerceViaIO * expr = ( CoerceViaIO * ) node ;\n List * args ;\n Oid outfunc ;\n bool outtypisvarlena ;\n Oid infunc ;\n Oid intypioparam ;\n Expr * simple ;\n CoerceViaIO * newexpr ;\n args = list_make1 ( expr -> arg ) ;\n getTypeOutputInfo ( exprType ( ( Node * ) expr -> arg ) , & outfunc , & outtypisvarlena ) ;\n getTypeInputInfo ( expr -> resulttype , & infunc , & intypioparam ) ;\n simple = simplify_function ( outfunc , CSTRINGOID , - 1 , InvalidOid , InvalidOid , & args , false , true , true , context ) ;\n if ( simple ) {\n args = list_make3 ( simple , makeConst ( OIDOID , - 1 , InvalidOid , sizeof ( Oid ) , ObjectIdGetDatum ( intypioparam ) , false , true ) , makeConst ( INT4OID , - 1 , InvalidOid , sizeof ( int32 ) , Int32GetDatum ( - 1 ) , false , true ) ) ;\n simple = simplify_function ( infunc , expr -> resulttype , - 1 , expr -> resultcollid , InvalidOid , & args , false , false , true , context ) ;\n if ( simple ) return ( Node * ) simple ;\n }\n newexpr = makeNode ( CoerceViaIO ) ;\n newexpr -> arg = ( Expr * ) linitial ( args ) ;\n newexpr -> resulttype = expr -> resulttype ;\n newexpr -> resultcollid = expr -> resultcollid ;\n newexpr -> coerceformat = expr -> coerceformat ;\n newexpr -> location = expr -> location ;\n return ( Node * ) newexpr ;\n }\n case T_ArrayCoerceExpr : {\n ArrayCoerceExpr * expr = ( ArrayCoerceExpr * ) node ;\n Expr * arg ;\n ArrayCoerceExpr * newexpr ;\n arg = ( Expr * ) eval_const_expressions_mutator ( ( Node * ) expr -> arg , context ) ;\n newexpr = makeNode ( ArrayCoerceExpr ) ;\n newexpr -> arg = arg ;\n newexpr -> elemfuncid = expr -> elemfuncid ;\n newexpr -> resulttype = expr -> resulttype ;\n newexpr -> resulttypmod = expr -> resulttypmod ;\n newexpr -> resultcollid = expr -> resultcollid ;\n newexpr -> isExplicit = expr -> isExplicit ;\n newexpr -> coerceformat = expr -> coerceformat ;\n newexpr -> location = expr -> location ;\n if ( arg && IsA ( arg , Const ) && ( ! OidIsValid ( newexpr -> elemfuncid ) || func_volatile ( newexpr -> elemfuncid ) == PROVOLATILE_IMMUTABLE ) ) return ( Node * ) evaluate_expr ( ( Expr * ) newexpr , newexpr -> resulttype , newexpr -> resulttypmod , newexpr -> resultcollid ) ;\n return ( Node * ) newexpr ;\n }\n case T_CollateExpr : {\n CollateExpr * collate = ( CollateExpr * ) node ;\n Node * arg ;\n arg = eval_const_expressions_mutator ( ( Node * ) collate -> arg , context ) ;\n if ( arg && IsA ( arg , Const ) ) {\n Const * con = ( Const * ) arg ;\n con -> constcollid = collate -> collOid ;\n return ( Node * ) con ;\n }\n else if ( collate -> collOid == exprCollation ( arg ) ) {\n return arg ;\n }\n else {\n RelabelType * relabel = makeNode ( RelabelType ) ;\n relabel -> resulttype = exprType ( arg ) ;\n relabel -> resulttypmod = exprTypmod ( arg ) ;\n relabel -> resultcollid = collate -> collOid ;\n relabel -> relabelformat = COERCE_IMPLICIT_CAST ;\n relabel -> location = collate -> location ;\n while ( arg && IsA ( arg , RelabelType ) ) arg = ( Node * ) ( ( RelabelType * ) arg ) -> arg ;\n relabel -> arg = ( Expr * ) arg ;\n return ( Node * ) relabel ;\n }\n }\n case T_CaseExpr : {\n CaseExpr * caseexpr = ( CaseExpr * ) node ;\n CaseExpr * newcase ;\n Node * save_case_val ;\n Node * newarg ;\n List * newargs ;\n bool const_true_cond ;\n Node * defresult = NULL ;\n ListCell * arg ;\n newarg = eval_const_expressions_mutator ( ( Node * ) caseexpr -> arg , context ) ;\n save_case_val = context -> case_val ;\n if ( newarg && IsA ( newarg , Const ) ) {\n context -> case_val = newarg ;\n newarg = NULL ;\n }\n else context -> case_val = NULL ;\n newargs = NIL ;\n const_true_cond = false ;\n foreach ( arg , caseexpr -> args ) {\n CaseWhen * oldcasewhen = ( CaseWhen * ) lfirst ( arg ) ;\n Node * casecond ;\n Node * caseresult ;\n Assert ( IsA ( oldcasewhen , CaseWhen ) ) ;\n casecond = eval_const_expressions_mutator ( ( Node * ) oldcasewhen -> expr , context ) ;\n if ( casecond && IsA ( casecond , Const ) ) {\n Const * const_input = ( Const * ) casecond ;\n if ( const_input -> constisnull || ! DatumGetBool ( const_input -> constvalue ) ) continue ;\n const_true_cond = true ;\n }\n caseresult = eval_const_expressions_mutator ( ( Node * ) oldcasewhen -> result , context ) ;\n if ( ! const_true_cond ) {\n CaseWhen * newcasewhen = makeNode ( CaseWhen ) ;\n newcasewhen -> expr = ( Expr * ) casecond ;\n newcasewhen -> result = ( Expr * ) caseresult ;\n newcasewhen -> location = oldcasewhen -> location ;\n newargs = lappend ( newargs , newcasewhen ) ;\n continue ;\n }\n defresult = caseresult ;\n break ;\n }\n if ( ! const_true_cond ) defresult = eval_const_expressions_mutator ( ( Node * ) caseexpr -> defresult , context ) ;\n context -> case_val = save_case_val ;\n if ( newargs == NIL ) return defresult ;\n newcase = makeNode ( CaseExpr ) ;\n newcase -> casetype = caseexpr -> casetype ;\n newcase -> casecollid = caseexpr -> casecollid ;\n newcase -> arg = ( Expr * ) newarg ;\n newcase -> args = newargs ;\n newcase -> defresult = ( Expr * ) defresult ;\n newcase -> location = caseexpr -> location ;\n return ( Node * ) newcase ;\n }\n case T_CaseTestExpr : {\n if ( context -> case_val ) return copyObject ( context -> case_val ) ;\n else return copyObject ( node ) ;\n }\n case T_ArrayExpr : {\n ArrayExpr * arrayexpr = ( ArrayExpr * ) node ;\n ArrayExpr * newarray ;\n bool all_const = true ;\n List * newelems ;\n ListCell * element ;\n newelems = NIL ;\n foreach ( element , arrayexpr -> elements ) {\n Node * e ;\n e = eval_const_expressions_mutator ( ( Node * ) lfirst ( element ) , context ) ;\n if ( ! IsA ( e , Const ) ) all_const = false ;\n newelems = lappend ( newelems , e ) ;\n }\n newarray = makeNode ( ArrayExpr ) ;\n newarray -> array_typeid = arrayexpr -> array_typeid ;\n newarray -> array_collid = arrayexpr -> array_collid ;\n newarray -> element_typeid = arrayexpr -> element_typeid ;\n newarray -> elements = newelems ;\n newarray -> multidims = arrayexpr -> multidims ;\n newarray -> location = arrayexpr -> location ;\n if ( all_const ) return ( Node * ) evaluate_expr ( ( Expr * ) newarray , newarray -> array_typeid , exprTypmod ( node ) , newarray -> array_collid ) ;\n return ( Node * ) newarray ;\n }\n case T_CoalesceExpr : {\n CoalesceExpr * coalesceexpr = ( CoalesceExpr * ) node ;\n CoalesceExpr * newcoalesce ;\n List * newargs ;\n ListCell * arg ;\n newargs = NIL ;\n foreach ( arg , coalesceexpr -> args ) {\n Node * e ;\n e = eval_const_expressions_mutator ( ( Node * ) lfirst ( arg ) , context ) ;\n if ( IsA ( e , Const ) ) {\n if ( ( ( Const * ) e ) -> constisnull ) continue ;\n if ( newargs == NIL ) return e ;\n newargs = lappend ( newargs , e ) ;\n break ;\n }\n newargs = lappend ( newargs , e ) ;\n }\n if ( newargs == NIL ) return ( Node * ) makeNullConst ( coalesceexpr -> coalescetype , - 1 , coalesceexpr -> coalescecollid ) ;\n newcoalesce = makeNode ( CoalesceExpr ) ;\n newcoalesce -> coalescetype = coalesceexpr -> coalescetype ;\n newcoalesce -> coalescecollid = coalesceexpr -> coalescecollid ;\n newcoalesce -> args = newargs ;\n newcoalesce -> location = coalesceexpr -> location ;\n return ( Node * ) newcoalesce ;\n }\n case T_FieldSelect : {\n FieldSelect * fselect = ( FieldSelect * ) node ;\n FieldSelect * newfselect ;\n Node * arg ;\n arg = eval_const_expressions_mutator ( ( Node * ) fselect -> arg , context ) ;\n if ( arg && IsA ( arg , Var ) && ( ( Var * ) arg ) -> varattno == InvalidAttrNumber && ( ( Var * ) arg ) -> varlevelsup == 0 ) {\n if ( rowtype_field_matches ( ( ( Var * ) arg ) -> vartype , fselect -> fieldnum , fselect -> resulttype , fselect -> resulttypmod , fselect -> resultcollid ) ) return ( Node * ) makeVar ( ( ( Var * ) arg ) -> varno , fselect -> fieldnum , fselect -> resulttype , fselect -> resulttypmod , fselect -> resultcollid , ( ( Var * ) arg ) -> varlevelsup ) ;\n }\n if ( arg && IsA ( arg , RowExpr ) ) {\n RowExpr * rowexpr = ( RowExpr * ) arg ;\n if ( fselect -> fieldnum > 0 && fselect -> fieldnum <= list_length ( rowexpr -> args ) ) {\n Node * fld = ( Node * ) list_nth ( rowexpr -> args , fselect -> fieldnum - 1 ) ;\n if ( rowtype_field_matches ( rowexpr -> row_typeid , fselect -> fieldnum , fselect -> resulttype , fselect -> resulttypmod , fselect -> resultcollid ) && fselect -> resulttype == exprType ( fld ) && fselect -> resulttypmod == exprTypmod ( fld ) && fselect -> resultcollid == exprCollation ( fld ) ) return fld ;\n }\n }\n newfselect = makeNode ( FieldSelect ) ;\n newfselect -> arg = ( Expr * ) arg ;\n newfselect -> fieldnum = fselect -> fieldnum ;\n newfselect -> resulttype = fselect -> resulttype ;\n newfselect -> resulttypmod = fselect -> resulttypmod ;\n newfselect -> resultcollid = fselect -> resultcollid ;\n return ( Node * ) newfselect ;\n }\n case T_NullTest : {\n NullTest * ntest = ( NullTest * ) node ;\n NullTest * newntest ;\n Node * arg ;\n arg = eval_const_expressions_mutator ( ( Node * ) ntest -> arg , context ) ;\n if ( ntest -> argisrow && arg && IsA ( arg , RowExpr ) ) {\n RowExpr * rarg = ( RowExpr * ) arg ;\n List * newargs = NIL ;\n ListCell * l ;\n foreach ( l , rarg -> args ) {\n Node * relem = ( Node * ) lfirst ( l ) ;\n if ( relem && IsA ( relem , Const ) ) {\n Const * carg = ( Const * ) relem ;\n if ( carg -> constisnull ? ( ntest -> nulltesttype == IS_NOT_NULL ) : ( ntest -> nulltesttype == IS_NULL ) ) return makeBoolConst ( false , false ) ;\n continue ;\n }\n newntest = makeNode ( NullTest ) ;\n newntest -> arg = ( Expr * ) relem ;\n newntest -> nulltesttype = ntest -> nulltesttype ;\n newntest -> argisrow = false ;\n newntest -> location = ntest -> location ;\n newargs = lappend ( newargs , newntest ) ;\n }\n if ( newargs == NIL ) return makeBoolConst ( true , false ) ;\n if ( list_length ( newargs ) == 1 ) return ( Node * ) linitial ( newargs ) ;\n return ( Node * ) make_andclause ( newargs ) ;\n }\n if ( ! ntest -> argisrow && arg && IsA ( arg , Const ) ) {\n Const * carg = ( Const * ) arg ;\n bool result ;\n switch ( ntest -> nulltesttype ) {\n case IS_NULL : result = carg -> constisnull ;\n break ;\n case IS_NOT_NULL : result = ! carg -> constisnull ;\n break ;\n default : elog ( ERROR , \"unrecognized nulltesttype: %d\" , ( int ) ntest -> nulltesttype ) ;\n result = false ;\n break ;\n }\n return makeBoolConst ( result , false ) ;\n }\n newntest = makeNode ( NullTest ) ;\n newntest -> arg = ( Expr * ) arg ;\n newntest -> nulltesttype = ntest -> nulltesttype ;\n newntest -> argisrow = ntest -> argisrow ;\n newntest -> location = ntest -> location ;\n return ( Node * ) newntest ;\n }\n case T_BooleanTest : {\n BooleanTest * btest = ( BooleanTest * ) node ;\n BooleanTest * newbtest ;\n Node * arg ;\n arg = eval_const_expressions_mutator ( ( Node * ) btest -> arg , context ) ;\n if ( arg && IsA ( arg , Const ) ) {\n Const * carg = ( Const * ) arg ;\n bool result ;\n switch ( btest -> booltesttype ) {\n case IS_TRUE : result = ( ! carg -> constisnull && DatumGetBool ( carg -> constvalue ) ) ;\n break ;\n case IS_NOT_TRUE : result = ( carg -> constisnull || ! DatumGetBool ( carg -> constvalue ) ) ;\n break ;\n case IS_FALSE : result = ( ! carg -> constisnull && ! DatumGetBool ( carg -> constvalue ) ) ;\n break ;\n case IS_NOT_FALSE : result = ( carg -> constisnull || DatumGetBool ( carg -> constvalue ) ) ;\n break ;\n case IS_UNKNOWN : result = carg -> constisnull ;\n break ;\n case IS_NOT_UNKNOWN : result = ! carg -> constisnull ;\n break ;\n default : elog ( ERROR , \"unrecognized booltesttype: %d\" , ( int ) btest -> booltesttype ) ;\n result = false ;\n break ;\n }\n return makeBoolConst ( result , false ) ;\n }\n newbtest = makeNode ( BooleanTest ) ;\n newbtest -> arg = ( Expr * ) arg ;\n newbtest -> booltesttype = btest -> booltesttype ;\n newbtest -> location = btest -> location ;\n return ( Node * ) newbtest ;\n }\n case T_PlaceHolderVar : if ( context -> estimate ) {\n PlaceHolderVar * phv = ( PlaceHolderVar * ) node ;\n return eval_const_expressions_mutator ( ( Node * ) phv -> phexpr , context ) ;\n }\n break ;\n default : break ;\n }\n return expression_tree_mutator ( node , eval_const_expressions_mutator , ( void * ) context ) ;\n }", "idx": 22700}
{"hash": -8620097311326519087, "project": "chrome", "size": 14, "label": 0, "functionSource": "static void srtp_calc_aead_iv_srtcp ( srtp_stream_ctx_t * stream , v128_t * iv , uint32_t seq_num , srtcp_hdr_t * hdr ) {\n v128_t in ;\n v128_t salt ;\n memset ( & in , 0 , sizeof ( v128_t ) ) ;\n memset ( & salt , 0 , sizeof ( v128_t ) ) ;\n in . v16 [ 0 ] = 0 ;\n memcpy ( & in . v16 [ 1 ] , & hdr -> ssrc , 4 ) ;\n in . v16 [ 3 ] = 0 ;\n in . v32 [ 2 ] = 0x7FFFFFFF & htonl ( seq_num ) ;\n debug_print ( mod_srtp , \"Pre-salted RTCP IV = %s\\n\" , v128_hex_string ( & in ) ) ;\n memcpy ( salt . v8 , stream -> c_salt , 12 ) ;\n debug_print ( mod_srtp , \"RTCP SALT = %s\\n\" , v128_hex_string ( & salt ) ) ;\n v128_xor ( iv , & in , & salt ) ;\n }", "idx": 22701}
{"hash": 6667142528452941476, "project": "debian", "size": 34, "label": 0, "functionSource": "static void write_footer ( FILE * sql_file ) {\n if ( opt_xml ) {\n fputs ( \"</mysqldump>\\n\" , sql_file ) ;\n check_io ( sql_file ) ;\n }\n else if ( ! opt_compact ) {\n if ( opt_tz_utc ) fprintf ( sql_file , \"/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;\n\\n\" ) ;\n fprintf ( sql_file , \"\\n/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;\n\\n\" ) ;\n if ( ! path ) {\n fprintf ( md_result_file , \"\\ /*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;\n\\n\" ) ;\n if ( ! opt_no_create_info ) {\n fprintf ( md_result_file , \"\\ /*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;\n\\n\" ) ;\n }\n }\n if ( opt_set_charset ) fprintf ( sql_file , \"/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;\n\\n\" \"/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;\n\\n\" \"/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;\n\\n\" ) ;\n fprintf ( sql_file , \"/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;\n\\n\" ) ;\n fputs ( \"\\n\" , sql_file ) ;\n if ( opt_dump_date ) {\n char time_str [ 20 ] ;\n get_date ( time_str , GETDATE_DATE_TIME , 0 ) ;\n print_comment ( sql_file , 0 , \"-- Dump completed on %s\\n\" , time_str ) ;\n }\n else print_comment ( sql_file , 0 , \"-- Dump completed\\n\" ) ;\n check_io ( sql_file ) ;\n }\n }", "idx": 22702}
{"hash": 1223258652239369123, "project": "debian", "size": 15, "label": 0, "functionSource": "zend_object_iterator * spl_filesystem_tree_get_iterator ( zend_class_entry * ce , zval * object , int by_ref TSRMLS_DC ) {\n spl_filesystem_iterator * iterator ;\n spl_filesystem_object * dir_object ;\n if ( by_ref ) {\n zend_error ( E_ERROR , \"An iterator cannot be used with foreach by reference\" ) ;\n }\n dir_object = ( spl_filesystem_object * ) zend_object_store_get_object ( object TSRMLS_CC ) ;\n iterator = spl_filesystem_object_to_iterator ( dir_object ) ;\n if ( iterator -> intern . data == NULL ) {\n iterator -> intern . data = object ;\n iterator -> intern . funcs = & spl_filesystem_tree_it_funcs ;\n }\n zval_add_ref ( & object ) ;\n return ( zend_object_iterator * ) iterator ;\n }", "idx": 22703}
{"hash": -7455544248455991006, "project": "debian", "size": 6, "label": 0, "functionSource": "static void get_seg ( SegmentCache * lhs , const struct kvm_segment * rhs ) {\n lhs -> selector = rhs -> selector ;\n lhs -> base = rhs -> base ;\n lhs -> limit = rhs -> limit ;\n lhs -> flags = ( rhs -> type << DESC_TYPE_SHIFT ) | ( ( rhs -> present && ! rhs -> unusable ) * DESC_P_MASK ) | ( rhs -> dpl << DESC_DPL_SHIFT ) | ( rhs -> db << DESC_B_SHIFT ) | ( rhs -> s * DESC_S_MASK ) | ( rhs -> l << DESC_L_SHIFT ) | ( rhs -> g * DESC_G_MASK ) | ( rhs -> avl * DESC_AVL_MASK ) ;\n }", "idx": 22704}
{"hash": 5347874611477979643, "project": "chrome", "size": 45, "label": 0, "functionSource": "static void test_evbuffer_find ( void ) {\n u_char * p ;\n const char * test1 = \"1234567890\\r\\n\" ;\n const char * test2 = \"1234567890\\r\" ;\n # define EVBUFFER_INITIAL_LENGTH 256 char test3 [ EVBUFFER_INITIAL_LENGTH ] ;\n unsigned int i ;\n struct evbuffer * buf = evbuffer_new ( ) ;\n fprintf ( stdout , \"Testing evbuffer_find 1: \" ) ;\n evbuffer_add ( buf , ( u_char * ) test1 , strlen ( test1 ) ) ;\n evbuffer_drain ( buf , strlen ( test1 ) ) ;\n evbuffer_add ( buf , ( u_char * ) test2 , strlen ( test2 ) ) ;\n p = evbuffer_find ( buf , ( u_char * ) \"\\r\\n\" , 2 ) ;\n if ( p == NULL ) {\n fprintf ( stdout , \"OK\\n\" ) ;\n }\n else {\n fprintf ( stdout , \"FAILED\\n\" ) ;\n exit ( 1 ) ;\n }\n fprintf ( stdout , \"Testing evbuffer_find 2: \" ) ;\n evbuffer_drain ( buf , strlen ( test2 ) ) ;\n for ( i = 0 ;\n i < EVBUFFER_INITIAL_LENGTH ;\n ++ i ) test3 [ i ] = 'a' ;\n test3 [ EVBUFFER_INITIAL_LENGTH - 1 ] = 'x' ;\n evbuffer_add ( buf , ( u_char * ) test3 , EVBUFFER_INITIAL_LENGTH ) ;\n p = evbuffer_find ( buf , ( u_char * ) \"xy\" , 2 ) ;\n if ( p == NULL ) {\n printf ( \"OK\\n\" ) ;\n }\n else {\n fprintf ( stdout , \"FAILED\\n\" ) ;\n exit ( 1 ) ;\n }\n fprintf ( stdout , \"Testing evbuffer_find 3: \" ) ;\n p = evbuffer_find ( buf , ( u_char * ) \"ax\" , 2 ) ;\n if ( p != NULL && strncmp ( ( char * ) p , \"ax\" , 2 ) == 0 ) {\n printf ( \"OK\\n\" ) ;\n }\n else {\n fprintf ( stdout , \"FAILED\\n\" ) ;\n exit ( 1 ) ;\n }\n evbuffer_free ( buf ) ;\n }", "idx": 22705}
{"hash": 1859256631654516868, "project": "chrome", "size": 55, "label": 0, "functionSource": "static void loop_filter ( H264Context * h , int start_x , int end_x ) {\n uint8_t * dest_y , * dest_cb , * dest_cr ;\n int linesize , uvlinesize , mb_x , mb_y ;\n const int end_mb_y = h -> mb_y + FRAME_MBAFF ( h ) ;\n const int old_slice_type = h -> slice_type ;\n const int pixel_shift = h -> pixel_shift ;\n const int block_h = 16 >> h -> chroma_y_shift ;\n if ( h -> deblocking_filter ) {\n for ( mb_x = start_x ;\n mb_x < end_x ;\n mb_x ++ ) for ( mb_y = end_mb_y - FRAME_MBAFF ( h ) ;\n mb_y <= end_mb_y ;\n mb_y ++ ) {\n int mb_xy , mb_type ;\n mb_xy = h -> mb_xy = mb_x + mb_y * h -> mb_stride ;\n h -> slice_num = h -> slice_table [ mb_xy ] ;\n mb_type = h -> cur_pic . mb_type [ mb_xy ] ;\n h -> list_count = h -> list_counts [ mb_xy ] ;\n if ( FRAME_MBAFF ( h ) ) h -> mb_mbaff = h -> mb_field_decoding_flag = ! ! IS_INTERLACED ( mb_type ) ;\n h -> mb_x = mb_x ;\n h -> mb_y = mb_y ;\n dest_y = h -> cur_pic . f . data [ 0 ] + ( ( mb_x << pixel_shift ) + mb_y * h -> linesize ) * 16 ;\n dest_cb = h -> cur_pic . f . data [ 1 ] + ( mb_x << pixel_shift ) * ( 8 << CHROMA444 ( h ) ) + mb_y * h -> uvlinesize * block_h ;\n dest_cr = h -> cur_pic . f . data [ 2 ] + ( mb_x << pixel_shift ) * ( 8 << CHROMA444 ( h ) ) + mb_y * h -> uvlinesize * block_h ;\n if ( MB_FIELD ( h ) ) {\n linesize = h -> mb_linesize = h -> linesize * 2 ;\n uvlinesize = h -> mb_uvlinesize = h -> uvlinesize * 2 ;\n if ( mb_y & 1 ) {\n dest_y -= h -> linesize * 15 ;\n dest_cb -= h -> uvlinesize * ( block_h - 1 ) ;\n dest_cr -= h -> uvlinesize * ( block_h - 1 ) ;\n }\n }\n else {\n linesize = h -> mb_linesize = h -> linesize ;\n uvlinesize = h -> mb_uvlinesize = h -> uvlinesize ;\n }\n backup_mb_border ( h , dest_y , dest_cb , dest_cr , linesize , uvlinesize , 0 ) ;\n if ( fill_filter_caches ( h , mb_type ) ) continue ;\n h -> chroma_qp [ 0 ] = get_chroma_qp ( h , 0 , h -> cur_pic . qscale_table [ mb_xy ] ) ;\n h -> chroma_qp [ 1 ] = get_chroma_qp ( h , 1 , h -> cur_pic . qscale_table [ mb_xy ] ) ;\n if ( FRAME_MBAFF ( h ) ) {\n ff_h264_filter_mb ( h , mb_x , mb_y , dest_y , dest_cb , dest_cr , linesize , uvlinesize ) ;\n }\n else {\n ff_h264_filter_mb_fast ( h , mb_x , mb_y , dest_y , dest_cb , dest_cr , linesize , uvlinesize ) ;\n }\n }\n }\n h -> slice_type = old_slice_type ;\n h -> mb_x = end_x ;\n h -> mb_y = end_mb_y - FRAME_MBAFF ( h ) ;\n h -> chroma_qp [ 0 ] = get_chroma_qp ( h , 0 , h -> qscale ) ;\n h -> chroma_qp [ 1 ] = get_chroma_qp ( h , 1 , h -> qscale ) ;\n }", "idx": 22706}
{"hash": -1102844685921778700, "project": "debian", "size": 50, "label": 0, "functionSource": "int archive_mstring_copy_mbs_len_l ( struct archive_mstring * aes , const char * mbs , size_t len , struct archive_string_conv * sc ) {\n int r ;\n if ( mbs == NULL ) {\n aes -> aes_set = 0 ;\n return ( 0 ) ;\n }\n archive_string_empty ( & ( aes -> aes_mbs ) ) ;\n archive_wstring_empty ( & ( aes -> aes_wcs ) ) ;\n archive_string_empty ( & ( aes -> aes_utf8 ) ) ;\n # if defined ( _WIN32 ) && ! defined ( __CYGWIN__ ) if ( sc == NULL ) {\n if ( archive_string_append ( & ( aes -> aes_mbs ) , mbs , mbsnbytes ( mbs , len ) ) == NULL ) {\n aes -> aes_set = 0 ;\n r = - 1 ;\n }\n else {\n aes -> aes_set = AES_SET_MBS ;\n r = 0 ;\n }\n # if defined ( HAVE_ICONV ) }\n else if ( sc != NULL && sc -> cd_w != ( iconv_t ) - 1 ) {\n iconv_t cd = sc -> cd ;\n unsigned from_cp ;\n int flag ;\n sc -> cd = sc -> cd_w ;\n r = archive_strncpy_l ( & ( aes -> aes_utf8 ) , mbs , len , sc ) ;\n sc -> cd = cd ;\n if ( r != 0 ) {\n aes -> aes_set = 0 ;\n return ( r ) ;\n }\n aes -> aes_set = AES_SET_UTF8 ;\n flag = sc -> flag ;\n sc -> flag &= ~ ( SCONV_NORMALIZATION_C | SCONV_TO_UTF16 | SCONV_FROM_UTF16 ) ;\n from_cp = sc -> from_cp ;\n sc -> from_cp = CP_UTF8 ;\n r = archive_wstring_append_from_mbs_in_codepage ( & ( aes -> aes_wcs ) , aes -> aes_utf8 . s , aes -> aes_utf8 . length , sc ) ;\n sc -> flag = flag ;\n sc -> from_cp = from_cp ;\n if ( r == 0 ) aes -> aes_set |= AES_SET_WCS ;\n # endif }\n else {\n r = archive_wstring_append_from_mbs_in_codepage ( & ( aes -> aes_wcs ) , mbs , len , sc ) ;\n if ( r == 0 ) aes -> aes_set = AES_SET_WCS ;\n else aes -> aes_set = 0 ;\n }\n # else r = archive_strncpy_l ( & ( aes -> aes_mbs ) , mbs , len , sc ) ;\n if ( r == 0 ) aes -> aes_set = AES_SET_MBS ;\n else aes -> aes_set = 0 ;\n # endif return ( r ) ;\n }", "idx": 22707}
{"hash": 3584320764213684062, "project": "debian", "size": 27, "label": 0, "functionSource": "int parse_CColumnSet ( tvbuff_t * tvb , int offset , proto_tree * tree , const char * fmt , ... ) {\n guint32 count , v , i ;\n proto_item * item ;\n const char * txt ;\n va_list ap ;\n va_start ( ap , fmt ) ;\n txt = wmem_strdup_vprintf ( wmem_packet_scope ( ) , fmt , ap ) ;\n va_end ( ap ) ;\n count = tvb_get_letohl ( tvb , offset ) ;\n offset += 4 ;\n proto_tree_add_subtree ( tree , tvb , offset , count * 4 , ett_mswsp_uin32_array , & item , txt ) ;\n proto_item_append_text ( item , \" Count %u [\" , count ) ;\n for ( i = 0 ;\n i < count ;\n i ++ ) {\n v = tvb_get_letohl ( tvb , offset ) ;\n offset += 4 ;\n if ( i > 0 ) {\n proto_item_append_text ( item , \",%u\" , v ) ;\n }\n else {\n proto_item_append_text ( item , \"%u\" , v ) ;\n }\n }\n proto_item_append_text ( item , \"]\" ) ;\n return offset ;\n }", "idx": 22708}
{"hash": -2424348134098907053, "project": "debian", "size": 13, "label": 0, "functionSource": "static void * counter_func ( void * arg ) {\n {\n set_pid_priority ( 0 , SCHED_FIFO , sched_get_priority_min ( SCHED_FIFO ) , \"Unable to set SCHED_FIFO for %d (\\\"%s\\\"). (%s)\" , \"the counter_func\" ) ;\n }\n for ( ;\n ;\n ) {\n counter ++ ;\n if ( verbose ) print_error ( stderr , \"counter set to %d\" , counter ) ;\n sleep ( increasetime ) ;\n }\n return NULL ;\n }", "idx": 22709}
{"hash": 6632536031698733342, "project": "debian", "size": 8, "label": 0, "functionSource": "static void opt_input_file ( void * optctx , const char * arg ) {\n if ( input_filename ) {\n av_log ( NULL , AV_LOG_ERROR , \"Argument '%s' provided as input filename, but '%s' was already specified.\\n\" , arg , input_filename ) ;\n exit_program ( 1 ) ;\n }\n if ( ! strcmp ( arg , \"-\" ) ) arg = \"pipe:\" ;\n input_filename = arg ;\n }", "idx": 22710}
{"hash": -3299391226809811274, "project": "debian", "size": 46, "label": 0, "functionSource": "int qemuAgentGetVCPUs ( qemuAgentPtr mon , qemuAgentCPUInfoPtr * info ) {\n int ret = - 1 ;\n size_t i ;\n virJSONValuePtr cmd ;\n virJSONValuePtr reply = NULL ;\n virJSONValuePtr data = NULL ;\n ssize_t ndata ;\n if ( ! ( cmd = qemuAgentMakeCommand ( \"guest-get-vcpus\" , NULL ) ) ) return - 1 ;\n if ( qemuAgentCommand ( mon , cmd , & reply , true , VIR_DOMAIN_QEMU_AGENT_COMMAND_BLOCK ) < 0 ) goto cleanup ;\n if ( ! ( data = virJSONValueObjectGet ( reply , \"return\" ) ) ) {\n virReportError ( VIR_ERR_INTERNAL_ERROR , \"%s\" , _ ( \"guest-get-vcpus reply was missing return data\" ) ) ;\n goto cleanup ;\n }\n if ( data -> type != VIR_JSON_TYPE_ARRAY ) {\n virReportError ( VIR_ERR_INTERNAL_ERROR , \"%s\" , _ ( \"guest-get-vcpus return information was not an array\" ) ) ;\n goto cleanup ;\n }\n ndata = virJSONValueArraySize ( data ) ;\n if ( VIR_ALLOC_N ( * info , ndata ) < 0 ) goto cleanup ;\n for ( i = 0 ;\n i < ndata ;\n i ++ ) {\n virJSONValuePtr entry = virJSONValueArrayGet ( data , i ) ;\n qemuAgentCPUInfoPtr in = * info + i ;\n if ( ! entry ) {\n virReportError ( VIR_ERR_INTERNAL_ERROR , \"%s\" , _ ( \"array element missing in guest-get-vcpus return \" \"value\" ) ) ;\n goto cleanup ;\n }\n if ( virJSONValueObjectGetNumberUint ( entry , \"logical-id\" , & in -> id ) < 0 ) {\n virReportError ( VIR_ERR_INTERNAL_ERROR , \"%s\" , _ ( \"'logical-id' missing in reply of guest-get-vcpus\" ) ) ;\n goto cleanup ;\n }\n if ( virJSONValueObjectGetBoolean ( entry , \"online\" , & in -> online ) < 0 ) {\n virReportError ( VIR_ERR_INTERNAL_ERROR , \"%s\" , _ ( \"'online' missing in reply of guest-get-vcpus\" ) ) ;\n goto cleanup ;\n }\n if ( virJSONValueObjectGetBoolean ( entry , \"can-offline\" , & in -> offlinable ) < 0 ) {\n virReportError ( VIR_ERR_INTERNAL_ERROR , \"%s\" , _ ( \"'can-offline' missing in reply of guest-get-vcpus\" ) ) ;\n goto cleanup ;\n }\n }\n ret = ndata ;\n cleanup : virJSONValueFree ( cmd ) ;\n virJSONValueFree ( reply ) ;\n return ret ;\n }", "idx": 22711}
{"hash": -5861178779585941932, "project": "debian", "size": 16, "label": 0, "functionSource": "static char * ts_format ( netdissect_options * ndo # ifndef HAVE_PCAP_SET_TSTAMP_PRECISION _U_ # endif , int sec , int usec , char * buf ) {\n const char * format ;\n # ifdef HAVE_PCAP_SET_TSTAMP_PRECISION switch ( ndo -> ndo_tstamp_precision ) {\n case PCAP_TSTAMP_PRECISION_MICRO : format = \"%02d:%02d:%02d.%06u\" ;\n break ;\n case PCAP_TSTAMP_PRECISION_NANO : format = \"%02d:%02d:%02d.%09u\" ;\n break ;\n default : format = \"%02d:%02d:%02d.{\nunknown}\n\" ;\n break ;\n }\n # else format = \"%02d:%02d:%02d.%06u\" ;\n # endif snprintf ( buf , TS_BUF_SIZE , format , sec / 3600 , ( sec % 3600 ) / 60 , sec % 60 , usec ) ;\n return buf ;\n }", "idx": 22712}
{"hash": 3668456668028959955, "project": "debian", "size": 24, "label": 0, "functionSource": "static unsigned char isLegalUTF8 ( const UTF8 * source , unsigned long length ) {\n UTF8 a ;\n const UTF8 * srcptr = source + length ;\n switch ( length ) {\n default : return 0 ;\n case 4 : if ( ( a = ( * -- srcptr ) ) < 0x80 || a > 0xBF ) return 0 ;\n case 3 : if ( ( a = ( * -- srcptr ) ) < 0x80 || a > 0xBF ) return 0 ;\n case 2 : if ( ( a = ( * -- srcptr ) ) > 0xBF ) return 0 ;\n switch ( * source ) {\n case 0xE0 : if ( a < 0xA0 ) return 0 ;\n break ;\n case 0xED : if ( a > 0x9F ) return 0 ;\n break ;\n case 0xF0 : if ( a < 0x90 ) return 0 ;\n break ;\n case 0xF4 : if ( a > 0x8F ) return 0 ;\n break ;\n default : if ( a < 0x80 ) return 0 ;\n }\n case 1 : if ( * source >= 0x80 && * source < 0xC2 ) return 0 ;\n }\n if ( * source > 0xF4 ) return 0 ;\n return 1 ;\n }", "idx": 22713}
{"hash": 6250095321513210169, "project": "debian", "size": 15, "label": 0, "functionSource": "rfbBool rfbSendXvp ( rfbClientPtr cl , uint8_t version , uint8_t code ) {\n rfbXvpMsg xvp ;\n xvp . type = rfbXvp ;\n xvp . pad = 0 ;\n xvp . version = version ;\n xvp . code = code ;\n LOCK ( cl -> sendMutex ) ;\n if ( rfbWriteExact ( cl , ( char * ) & xvp , sz_rfbXvpMsg ) < 0 ) {\n rfbLogPerror ( \"rfbSendXvp: write\" ) ;\n rfbCloseClient ( cl ) ;\n }\n UNLOCK ( cl -> sendMutex ) ;\n rfbStatRecordMessageSent ( cl , rfbXvp , sz_rfbXvpMsg , sz_rfbXvpMsg ) ;\n return TRUE ;\n }", "idx": 22714}
{"hash": -5550748970150309774, "project": "debian", "size": 4, "label": 0, "functionSource": "static void die_on_query_failure ( ArchiveHandle * AH , const char * modulename , const char * query ) {\n write_msg ( modulename , \"query failed: %s\" , PQerrorMessage ( AH -> connection ) ) ;\n exit_horribly ( modulename , \"query was: %s\\n\" , query ) ;\n }", "idx": 22715}
{"hash": 2895622461494525400, "project": "debian", "size": 49, "label": 0, "functionSource": "static void test_view_insert_fields ( ) {\n MYSQL_STMT * stmt ;\n char parm [ 11 ] [ 1000 ] ;\n ulong l [ 11 ] ;\n int rc , i ;\n MYSQL_BIND my_bind [ 11 ] ;\n const char * query = \"INSERT INTO `v1` ( `K1C4` ,`K2C4` ,`K3C4` ,`K4N4` ,`F1C4` ,`F2I4` ,`F3N5` ,`F7F8` ,`F6N4` ,`F5C8` ,`F9D8` ) VALUES( ? , ? , ? , ? , ? , ? , ? , ? , ? , ? , ? )\" ;\n myheader ( \"test_view_insert_fields\" ) ;\n rc = mysql_query ( mysql , \"DROP TABLE IF EXISTS t1, v1\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"DROP VIEW IF EXISTS t1, v1\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"CREATE TABLE t1 (K1C4 varchar(4) NOT NULL,\" \"K2C4 varchar(4) NOT NULL, K3C4 varchar(4) NOT NULL,\" \"K4N4 varchar(4) NOT NULL default '0000',\" \"F1C4 varchar(4) NOT NULL, F2I4 int(11) NOT NULL,\" \"F3N5 varchar(5) NOT NULL default '00000',\" \"F4I4 int(11) NOT NULL default '0', F5C8 varchar(8) NOT NULL,\" \"F6N4 varchar(4) NOT NULL default '0000',\" \"F7F8 double NOT NULL default '0',\" \"F8F8 double NOT NULL default '0',\" \"F9D8 decimal(8,2) NOT NULL default '0.00',\" \"PRIMARY KEY (K1C4,K2C4,K3C4,K4N4)) \" \"CHARSET=latin1 COLLATE latin1_bin\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"CREATE VIEW v1 AS select sql_no_cache \" \" K1C4 AS K1C4, K2C4 AS K2C4, K3C4 AS K3C4, K4N4 AS K4N4, \" \" F1C4 AS F1C4, F2I4 AS F2I4, F3N5 AS F3N5,\" \" F7F8 AS F7F8, F6N4 AS F6N4, F5C8 AS F5C8, F9D8 AS F9D8\" \" from t1 T0001\" ) ;\n memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n for ( i = 0 ;\n i < 11 ;\n i ++ ) {\n l [ i ] = 20 ;\n my_bind [ i ] . buffer_type = MYSQL_TYPE_STRING ;\n my_bind [ i ] . is_null = 0 ;\n my_bind [ i ] . buffer = ( char * ) & parm [ i ] ;\n strmov ( parm [ i ] , \"1\" ) ;\n my_bind [ i ] . buffer_length = 2 ;\n my_bind [ i ] . length = & l [ i ] ;\n }\n stmt = mysql_stmt_init ( mysql ) ;\n rc = mysql_stmt_prepare ( stmt , query , strlen ( query ) ) ;\n check_execute ( stmt , rc ) ;\n rc = mysql_stmt_bind_param ( stmt , my_bind ) ;\n check_execute ( stmt , rc ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n mysql_stmt_close ( stmt ) ;\n query = \"select * from t1\" ;\n stmt = mysql_stmt_init ( mysql ) ;\n rc = mysql_stmt_prepare ( stmt , query , strlen ( query ) ) ;\n check_execute ( stmt , rc ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n rc = my_process_stmt_result ( stmt ) ;\n DIE_UNLESS ( 1 == rc ) ;\n mysql_stmt_close ( stmt ) ;\n rc = mysql_query ( mysql , \"DROP VIEW v1\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"DROP TABLE t1\" ) ;\n myquery ( rc ) ;\n }", "idx": 22716}
{"hash": 7039307292471244756, "project": "debian", "size": 6, "label": 0, "functionSource": "static guint16 de_conn_sub_addr ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo , guint32 offset , guint len , gchar * add_string _U_ , int string_len _U_ ) {\n gchar * extr_addr ;\n de_sub_addr ( tvb , tree , pinfo , offset , len , & extr_addr ) ;\n if ( extr_addr && add_string ) g_snprintf ( add_string , string_len , \" - (%s)\" , extr_addr ) ;\n return ( len ) ;\n }", "idx": 22717}
{"hash": -7019074708255236794, "project": "debian", "size": 8, "label": 0, "functionSource": "static void de_emphasis ( float * out , float * in , float m , float mem [ 1 ] ) {\n int i ;\n out [ 0 ] = in [ 0 ] + m * mem [ 0 ] ;\n for ( i = 1 ;\n i < AMRWB_SFR_SIZE ;\n i ++ ) out [ i ] = in [ i ] + out [ i - 1 ] * m ;\n mem [ 0 ] = out [ AMRWB_SFR_SIZE - 1 ] ;\n }", "idx": 22718}
{"hash": 8206514580434225668, "project": "chrome", "size": 13, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( HttpsEngagementPageLoadMetricsBrowserTest , BackgroundThenForeground_Https ) {\n StartHttpsServer ( false ) ;\n base : : TimeDelta upper_bound = NavigateInBackgroundAndCloseInForegroundWithTiming ( https_test_server_ -> GetURL ( \"/simple.html\" ) ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHttpEngagementHistogram , 0 ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHttpsEngagementHistogram , 1 ) ;\n int32_t bucket_min = histogram_tester_ . GetAllSamples ( internal : : kHttpsEngagementHistogram ) [ 0 ] . min ;\n EXPECT_GE ( upper_bound . InMilliseconds ( ) , bucket_min ) ;\n EXPECT_LT ( 0 , bucket_min ) ;\n FakeUserMetricsUpload ( ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHttpsEngagementSessionPercentage , 1 ) ;\n int32_t ratio_bucket = histogram_tester_ . GetAllSamples ( internal : : kHttpsEngagementSessionPercentage ) [ 0 ] . min ;\n EXPECT_EQ ( 100 , ratio_bucket ) ;\n }", "idx": 22719}
{"hash": -7236893719053583356, "project": "debian", "size": 3, "label": 0, "functionSource": "void proto_reg_handoff_zbee_zcl_color_control ( void ) {\n zbee_zcl_init_cluster ( ZBEE_PROTOABBREV_ZCL_COLOR_CONTROL , proto_zbee_zcl_color_control , ett_zbee_zcl_color_control , ZBEE_ZCL_CID_COLOR_CONTROL , ZBEE_MFG_CODE_NONE , hf_zbee_zcl_color_control_attr_id , hf_zbee_zcl_color_control_srv_rx_cmd_id , - 1 , ( zbee_zcl_fn_attr_data ) dissect_zcl_color_control_attr_data ) ;\n }", "idx": 22720}
{"hash": 1760449185745615462, "project": "debian", "size": 4, "label": 0, "functionSource": "int TSAcceptorIDGet ( TSAcceptor acceptor ) {\n NetAccept * na = reinterpret_cast < NetAccept * > ( acceptor ) ;\n return na ? na -> id : - 1 ;\n }", "idx": 22721}
{"hash": 6323824267898511453, "project": "debian", "size": 8, "label": 0, "functionSource": "static const fz_colorspace * fz_source_colorspace_cm ( fz_context * ctx , const fz_colorspace * cs ) {\n while ( cs ) {\n if ( fz_colorspace_is_icc ( ctx , cs ) ) return cs ;\n if ( fz_colorspace_is_cal ( ctx , cs ) ) return cs ;\n cs = fz_colorspace_base ( ctx , cs ) ;\n }\n return NULL ;\n }", "idx": 22722}
{"hash": 6752827389510428348, "project": "chrome", "size": 29, "label": 0, "functionSource": "IN_PROC_BROWSER_TEST_F ( ClientHintsBrowserTest , ClientHintsHttpsSubresourceDifferentOrigin ) {\n base : : HistogramTester histogram_tester ;\n ui_test_utils : : NavigateToURL ( browser ( ) , accept_ch_with_lifetime_url ( ) ) ;\n histogram_tester . ExpectUniqueSample ( \"ClientHints.UpdateEventCount\" , 1 , 1 ) ;\n ContentSettingsForOneType client_hints_settings ;\n HostContentSettingsMap * host_content_settings_map = HostContentSettingsMapFactory : : GetForProfile ( browser ( ) -> profile ( ) ) ;\n host_content_settings_map -> GetSettingsForOneType ( CONTENT_SETTINGS_TYPE_CLIENT_HINTS , std : : string ( ) , & client_hints_settings ) ;\n ASSERT_EQ ( 1U , client_hints_settings . size ( ) ) ;\n host_content_settings_map -> SetWebsiteSettingDefaultScope ( GURL ( \"https://foo.com/\" ) , GURL ( ) , CONTENT_SETTINGS_TYPE_CLIENT_HINTS , std : : string ( ) , std : : make_unique < base : : Value > ( client_hints_settings . at ( 0 ) . setting_value -> Clone ( ) ) ) ;\n host_content_settings_map = HostContentSettingsMapFactory : : GetForProfile ( browser ( ) -> profile ( ) ) ;\n host_content_settings_map -> GetSettingsForOneType ( CONTENT_SETTINGS_TYPE_CLIENT_HINTS , std : : string ( ) , & client_hints_settings ) ;\n ASSERT_EQ ( 2U , client_hints_settings . size ( ) ) ;\n SetClientHintExpectationsOnMainFrame ( true ) ;\n SetClientHintExpectationsOnSubresources ( true ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , without_accept_ch_without_lifetime_img_localhost ( ) ) ;\n base : : RunLoop ( ) . RunUntilIdle ( ) ;\n content : : FetchHistogramsFromChildProcesses ( ) ;\n SubprocessMetricsProvider : : MergeHistogramDeltasForTesting ( ) ;\n # if defined ( OS_ANDROID ) EXPECT_EQ ( 4u , count_client_hints_headers_seen ( ) ) ;\n # else EXPECT_EQ ( 6u , count_client_hints_headers_seen ( ) ) ;\n # endif ui_test_utils : : NavigateToURL ( browser ( ) , without_accept_ch_without_lifetime_img_foo_com ( ) ) ;\n base : : RunLoop ( ) . RunUntilIdle ( ) ;\n content : : FetchHistogramsFromChildProcesses ( ) ;\n SubprocessMetricsProvider : : MergeHistogramDeltasForTesting ( ) ;\n # if defined ( OS_ANDROID ) EXPECT_EQ ( 6u , count_client_hints_headers_seen ( ) ) ;\n # else EXPECT_EQ ( 9u , count_client_hints_headers_seen ( ) ) ;\n # endif EXPECT_EQ ( 1u , third_party_request_count_seen ( ) ) ;\n EXPECT_EQ ( 0u , third_party_client_hints_count_seen ( ) ) ;\n }", "idx": 22723}
{"hash": -7599707968689691014, "project": "debian", "size": 3, "label": 0, "functionSource": "static int php_stream_http_stream_stat ( php_stream_wrapper * wrapper , php_stream * stream , php_stream_statbuf * ssb TSRMLS_DC ) {\n return - 1 ;\n }", "idx": 22724}
{"hash": 5918484636148310736, "project": "debian", "size": 41, "label": 0, "functionSource": "int gs_make_mem_device_with_copydevice ( gx_device_memory * * ppdev , const gx_device_memory * mdproto , gs_memory_t * mem , int page_device , gx_device * target ) {\n int code ;\n gx_device_memory * pdev ;\n if ( mem == 0 ) return - 1 ;\n code = gs_copydevice ( ( gx_device * * ) & pdev , ( const gx_device * ) mdproto , mem ) ;\n if ( code < 0 ) return code ;\n switch ( page_device ) {\n case - 1 : set_dev_proc ( pdev , get_page_device , gx_default_get_page_device ) ;\n break ;\n case 1 : set_dev_proc ( pdev , get_page_device , gx_page_device_get_page_device ) ;\n break ;\n }\n if ( target == 0 ) {\n if ( pdev -> color_info . depth == 1 ) {\n pdev -> cached_colors . black = 1 ;\n pdev -> cached_colors . white = 0 ;\n }\n else {\n pdev -> cached_colors . black = 0 ;\n pdev -> cached_colors . white = ( 1 << pdev -> color_info . depth ) - 1 ;\n }\n pdev -> graphics_type_tag = GS_UNKNOWN_TAG ;\n }\n else {\n gx_device_set_target ( ( gx_device_forward * ) pdev , target ) ;\n gx_device_forward_color_procs ( ( gx_device_forward * ) pdev ) ;\n gx_device_copy_color_procs ( ( gx_device * ) pdev , target ) ;\n pdev -> cached_colors = target -> cached_colors ;\n pdev -> graphics_type_tag = target -> graphics_type_tag ;\n }\n if ( pdev -> color_info . depth == 1 ) {\n gx_color_value cv [ 3 ] ;\n cv [ 0 ] = cv [ 1 ] = cv [ 2 ] = 0 ;\n gdev_mem_mono_set_inverted ( pdev , ( target == 0 || ( * dev_proc ( pdev , encode_color ) ) ( ( gx_device * ) pdev , cv ) != 0 ) ) ;\n }\n check_device_separable ( ( gx_device * ) pdev ) ;\n gx_device_fill_in_procs ( ( gx_device * ) pdev ) ;\n pdev -> band_y = 0 ;\n * ppdev = pdev ;\n return 0 ;\n }", "idx": 22725}
{"hash": 6415329349331062723, "project": "chrome", "size": 8, "label": 0, "functionSource": "static void http_badreq_cb ( struct evhttp_request * req , void * arg ) {\n struct evbuffer * buf = evbuffer_new ( ) ;\n evhttp_add_header ( req -> output_headers , \"Content-Type\" , \"text/xml;\n charset=UTF-8\" ) ;\n evbuffer_add_printf ( buf , \"Hello, %s!\" , \"127.0.0.1\" ) ;\n evhttp_send_reply ( req , HTTP_OK , \"OK\" , buf ) ;\n evbuffer_free ( buf ) ;\n }", "idx": 22726}
{"hash": -5952453487978309155, "project": "chrome", "size": 15, "label": 0, "functionSource": "void vp8_update_zbin_extra ( VP8_COMP * cpi , MACROBLOCK * x ) {\n int i ;\n int QIndex = x -> q_index ;\n int zbin_extra ;\n zbin_extra = ZBIN_EXTRA_Y ;\n for ( i = 0 ;\n i < 16 ;\n i ++ ) x -> block [ i ] . zbin_extra = ( short ) zbin_extra ;\n zbin_extra = ZBIN_EXTRA_UV ;\n for ( i = 16 ;\n i < 24 ;\n i ++ ) x -> block [ i ] . zbin_extra = ( short ) zbin_extra ;\n zbin_extra = ZBIN_EXTRA_Y2 ;\n x -> block [ 24 ] . zbin_extra = ( short ) zbin_extra ;\n }", "idx": 22727}
{"hash": 2895622461494525400, "project": "debian", "size": 52, "label": 0, "functionSource": "static void test_conversion ( ) {\n MYSQL_STMT * stmt ;\n const char * stmt_text ;\n int rc ;\n MYSQL_BIND my_bind [ 1 ] ;\n char buff [ 4 ] ;\n ulong length ;\n myheader ( \"test_conversion\" ) ;\n stmt_text = \"DROP TABLE IF EXISTS t1\" ;\n rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n myquery ( rc ) ;\n stmt_text = \"CREATE TABLE t1 (a TEXT) DEFAULT CHARSET latin1\" ;\n rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n myquery ( rc ) ;\n stmt_text = \"SET character_set_connection=utf8, character_set_client=utf8, \" \" character_set_results=latin1\" ;\n rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n myquery ( rc ) ;\n stmt = mysql_stmt_init ( mysql ) ;\n stmt_text = \"INSERT INTO t1 (a) VALUES (?)\" ;\n rc = mysql_stmt_prepare ( stmt , stmt_text , strlen ( stmt_text ) ) ;\n check_execute ( stmt , rc ) ;\n memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n my_bind [ 0 ] . buffer = buff ;\n my_bind [ 0 ] . length = & length ;\n my_bind [ 0 ] . buffer_type = MYSQL_TYPE_STRING ;\n mysql_stmt_bind_param ( stmt , my_bind ) ;\n buff [ 0 ] = ( uchar ) 0xC3 ;\n buff [ 1 ] = ( uchar ) 0xA0 ;\n length = 2 ;\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n stmt_text = \"SELECT a FROM t1\" ;\n rc = mysql_stmt_prepare ( stmt , stmt_text , strlen ( stmt_text ) ) ;\n check_execute ( stmt , rc ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n my_bind [ 0 ] . buffer_length = sizeof ( buff ) ;\n mysql_stmt_bind_result ( stmt , my_bind ) ;\n rc = mysql_stmt_fetch ( stmt ) ;\n DIE_UNLESS ( rc == 0 ) ;\n DIE_UNLESS ( length == 1 ) ;\n DIE_UNLESS ( ( uchar ) buff [ 0 ] == 0xE0 ) ;\n rc = mysql_stmt_fetch ( stmt ) ;\n DIE_UNLESS ( rc == MYSQL_NO_DATA ) ;\n mysql_stmt_close ( stmt ) ;\n stmt_text = \"DROP TABLE t1\" ;\n rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n myquery ( rc ) ;\n stmt_text = \"SET NAMES DEFAULT\" ;\n rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n myquery ( rc ) ;\n }", "idx": 22728}
{"hash": -8704283573519790151, "project": "debian", "size": 14, "label": 0, "functionSource": "void ber_init2 ( BerElement * ber , struct berval * bv , int options ) {\n assert ( ber != NULL ) ;\n ( void ) memset ( ( char * ) ber , '\\0' , sizeof ( BerElement ) ) ;\n ber -> ber_valid = LBER_VALID_BERELEMENT ;\n ber -> ber_tag = LBER_DEFAULT ;\n ber -> ber_options = ( char ) options ;\n ber -> ber_debug = ber_int_debug ;\n if ( bv != NULL ) {\n ber -> ber_buf = bv -> bv_val ;\n ber -> ber_ptr = ber -> ber_buf ;\n ber -> ber_end = ber -> ber_buf + bv -> bv_len ;\n }\n assert ( LBER_VALID ( ber ) ) ;\n }", "idx": 22729}
{"hash": 7889142355347191490, "project": "debian", "size": 6, "label": 0, "functionSource": "void udpv6_destroy_sock ( struct sock * sk ) {\n lock_sock ( sk ) ;\n udp_v6_flush_pending_frames ( sk ) ;\n release_sock ( sk ) ;\n inet6_destroy_sock ( sk ) ;\n }", "idx": 22730}
{"hash": 1245821301839614810, "project": "debian", "size": 8, "label": 0, "functionSource": "static int run_warning ( CommonJob * job , char * primary_text , char * secondary_text , const char * details_text , gboolean show_all , ... ) {\n va_list varargs ;\n int res ;\n va_start ( varargs , show_all ) ;\n res = run_simple_dialog_va ( job , FALSE , GTK_MESSAGE_WARNING , primary_text , secondary_text , details_text , show_all , varargs ) ;\n va_end ( varargs ) ;\n return res ;\n }", "idx": 22731}
{"hash": -5968890769755017734, "project": "debian", "size": 25, "label": 0, "functionSource": "static void execve_shell ( const char * shellname , char * args [ ] , char * const envp [ ] ) {\n int err ;\n ( void ) execve ( shellname , ( char * * ) args , envp ) ;\n err = errno ;\n if ( access ( shellname , R_OK | X_OK ) == 0 ) {\n size_t n_args = 0 ;\n char * * targs ;\n while ( NULL != args [ n_args ] ) {\n n_args ++ ;\n }\n targs = ( char * * ) xmalloc ( ( n_args + 3 ) * sizeof ( args [ 0 ] ) ) ;\n targs [ 0 ] = \"sh\" ;\n targs [ 1 ] = \"-\" ;\n targs [ 2 ] = xstrdup ( shellname ) ;\n targs [ n_args + 2 ] = NULL ;\n while ( 1 != n_args ) {\n targs [ n_args + 1 ] = args [ n_args - 1 ] ;\n n_args -- ;\n }\n ( void ) execve ( SHELL , targs , envp ) ;\n }\n else {\n errno = err ;\n }\n }", "idx": 22732}
{"hash": 4600167735237264207, "project": "chrome", "size": 19, "label": 0, "functionSource": "static int32_t compareMappings ( UCMTable * lTable , const UCMapping * l , UCMTable * rTable , const UCMapping * r , UBool uFirst ) {\n int32_t result ;\n if ( uFirst ) {\n result = compareUnicode ( lTable , l , rTable , r ) ;\n if ( result == 0 ) {\n result = compareBytes ( lTable , l , rTable , r , FALSE ) ;\n }\n }\n else {\n result = compareBytes ( lTable , l , rTable , r , TRUE ) ;\n if ( result == 0 ) {\n result = compareUnicode ( lTable , l , rTable , r ) ;\n }\n }\n if ( result != 0 ) {\n return result ;\n }\n return l -> f - r -> f ;\n }", "idx": 22733}
